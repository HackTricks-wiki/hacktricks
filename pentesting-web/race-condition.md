# Condici칩n de Carrera

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Utiliza [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) para construir y **automatizar flujos de trabajo** con las herramientas comunitarias **m치s avanzadas** del mundo.\
Obt칠n Acceso Hoy:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Aprende hacking en AWS de cero a h칠roe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver a tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF**, consulta los [**PLANES DE SUSCRIPCI칍N**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci칩n de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **칔nete al** 游눫 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s칤gueme** en **Twitter** 游냕 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de GitHub de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Explotando RC

El principal problema al abusar de RC es que necesitas que las solicitudes se procesen en paralelo con una diferencia de tiempo muy corta (usualmente >1ms). En la siguiente secci칩n, se proponen diferentes soluciones para hacer esto posible.

<figure><img src="../.gitbook/assets/image (5) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Ataque de un solo paquete (HTTP/2) / Sincronizaci칩n del 칰ltimo byte (HTTP/1.1)

HTTP2 permite enviar **2 solicitudes en una sola conexi칩n TCP** (mientras que en HTTP/1.1 tienen que ser secuenciales).\
El uso de un solo paquete TCP **elimina completamente el efecto del jitter de red**, por lo que esto claramente tiene potencial para ataques de condici칩n de carrera tambi칠n. Sin embargo, **dos solicitudes no son suficientes para un ataque de carrera fiable** debido al **jitter del lado del servidor** - variaciones en el tiempo de procesamiento de solicitudes de la aplicaci칩n causadas por variables incontrolables como la contenci칩n de CPU.

Pero, utilizando la t칠cnica de '**sincronizaci칩n del 칰ltimo byte**' de HTTP/1.1 es posible pre-enviar la mayor parte de los datos reteniendo un peque침o fragmento de cada solicitud y luego 'completar' **20-30 solicitudes con un solo paquete TCP**.

Para **pre-enviar la mayor parte de cada solicitud**:

* Si la solicitud no tiene cuerpo, env칤a todos los encabezados, pero no establezcas la bandera END\_STREAM. Ret칠n un marco de datos vac칤o con END\_STREAM establecido.
* Si la solicitud tiene cuerpo, env칤a los encabezados y todos los datos del cuerpo excepto el 칰ltimo byte. Ret칠n un marco de datos que contenga el 칰ltimo byte.

A continuaci칩n, **prep치rate para enviar los marcos finales**:

* Espera 100ms para asegurarte de que los marcos iniciales se han enviado.
* Aseg칰rate de que TCP\_NODELAY est칠 desactivado - es crucial que el algoritmo de Nagle agrupe los marcos finales.
* Env칤a un paquete de ping para calentar la conexi칩n local. Si no haces esto, la pila de red del SO colocar치 el primer marco final en un paquete separado.

Finalmente, env칤a los marcos retenidos. Deber칤as poder verificar que aterrizaron en un solo paquete usando Wireshark.

{% hint style="info" %}
Nota que **no funciona para archivos est치ticos** en ciertos servidores, pero los archivos est치ticos son irrelevantes para ataques de RC.
{% endhint %}

Utilizando esta t칠cnica, puedes hacer que 20-30 solicitudes lleguen al servidor simult치neamente - independientemente del jitter de red:

<figure><img src="../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

**Adapt치ndose a la arquitectura del objetivo**

Es importante notar que muchas aplicaciones est치n detr치s de un servidor frontal, y estos pueden decidir reenviar algunas solicitudes a trav칠s de conexiones existentes al back-end, y crear nuevas conexiones para otras.

Como resultado, es importante no atribuir tiempos de solicitud inconsistentes al comportamiento de la aplicaci칩n, como mecanismos de bloqueo que solo permiten que un solo hilo acceda a un recurso a la vez. Adem치s, el enrutamiento de solicitudes del front-end a menudo se hace en base a una conexi칩n por conexi칩n, por lo que puedes ser capaz de suavizar el tiempo de las solicitudes realizando un calentamiento de conexi칩n del lado del servidor - **enviando algunas solicitudes inconsecuentes por tu conexi칩n antes de realizar el ataque** (esto es solo enviar varias solicitudes antes de comenzar el ataque real).

#### Mecanismos de bloqueo basados en sesi칩n <a href="#session-based-locking-mechanisms" id="session-based-locking-mechanisms"></a>

Algunos frameworks intentan prevenir la corrupci칩n accidental de datos utilizando alguna forma de **bloqueo de solicitudes**. Por ejemplo, el m칩dulo de **manejador de sesiones nativo de PHP** solo procesa **una solicitud por sesi칩n a la vez**.

Es extremadamente importante detectar este tipo de comportamiento ya que de lo contrario puede ocultar vulnerabilidades trivialmente explotables. Si notas que todas tus solicitudes se procesan secuencialmente, intenta enviar cada una de ellas utilizando un token de sesi칩n diferente.

#### **Abusando de l칤mites de tasa o recursos**

Si el calentamiento de la conexi칩n no hace ninguna diferencia, hay varias soluciones a este problema.

Usando Turbo Intruder, puedes introducir un breve retraso del lado del cliente. Sin embargo, como esto implica dividir tus solicitudes de ataque reales en m칰ltiples paquetes TCP, no podr치s utilizar la t칠cnica de ataque de un solo paquete. Como resultado, en objetivos con alto jitter, el ataque es poco probable que funcione de manera fiable independientemente del retraso que establezcas.

<figure><img src="../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

En cambio, puedes ser capaz de resolver este problema abusando de una caracter칤stica de seguridad com칰n.

Los servidores web a menudo **retrasan el procesamiento de solicitudes si se env칤an demasiadas demasiado r치pido**. Al enviar un gran n칰mero de solicitudes ficticias para desencadenar intencionalmente el l칤mite de tasa o recursos, puedes ser capaz de causar un retraso adecuado del lado del servidor. Esto hace que el ataque de un solo paquete sea viable incluso cuando se requiere una ejecuci칩n retrasada.

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

{% hint style="warning" %}
Para m치s informaci칩n sobre esta t칠cnica, consulta el informe original en [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
{% endhint %}

#### Ejemplos de Ataque

* **Tubo Intruder - Ataque de un solo paquete HTTP2 (1 endpoint)**: Puedes enviar la solicitud a **Turbo intruder** (`Extensions` -> `Turbo Intruder` -> `Send to Turbo Intruder`), puedes cambiar en la solicitud el valor que quieres forzar bruscamente por **`%s`** como en `csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&username=carlos&password=%s` y luego seleccionar **`examples/race-single-packer-attack.py`** del men칰 desplegable:

<figure><img src="../.gitbook/assets/image (4) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Si vas a **enviar diferentes valores**, podr칤as modificar el c칩digo con este que usa una lista de palabras del portapapeles:
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
{% hint style="warning" %}
Si la web no soporta HTTP2 (solo HTTP1.1) usa `Engine.THREADED` o `Engine.BURP` en lugar de `Engine.BURP2`.
{% endhint %}

* **Tubo Intruder - Ataque de paquete 칰nico HTTP2 (Varios endpoints)**: En caso de que necesites enviar una solicitud a 1 endpoint y luego m칰ltiples a otros endpoints para activar el RCE, puedes cambiar el script `race-single-packet-attack.py` con algo como:
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
* Tambi칠n est치 disponible en **Repeater** a trav칠s de la nueva opci칩n '**Enviar grupo en paralelo**' en Burp Suite.
* Para **limit-overrun** podr칤as simplemente a침adir **la misma solicitud 50 veces** en el grupo.
* Para **connection warming**, podr칤as **a침adir** al **principio** del **grupo** algunas **solicitudes** a alguna parte no est치tica del servidor web.
* Para **retrasar** el proceso **entre** el procesamiento de **una solicitud y otra** en pasos de 2 subestados, podr칤as **a침adir solicitudes extra entre** ambas solicitudes.
* Para un RC de **multi-endpoint** podr칤as empezar enviando la **solicitud** que **va al estado oculto** y luego **50 solicitudes** justo despu칠s que **explotan el estado oculto**.

<figure><img src="../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Raw BF

Antes de la investigaci칩n previa, estos eran algunos payloads utilizados que simplemente intentaban enviar los paquetes lo m치s r치pido posible para causar un RC.

* **Repeater:** Revisa los ejemplos de la secci칩n anterior.
* **Intruder**: Env칤a la **solicitud** a **Intruder**, establece el **n칰mero de hilos** a **30** dentro del **men칰 de Opciones y,** selecciona como payload **Null payloads** y genera **30.**
* **Turbo Intruder**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
* **Python - asyncio**
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## **Metodolog칤a RC**

### Exceso de l칤mite / TOCTOU

Este es el tipo m치s b치sico de condici칩n de carrera donde las **vulnerabilidades** que **aparecen** en lugares que **limitan el n칰mero de veces que puedes realizar una acci칩n**. Como usar el mismo c칩digo de descuento varias veces en una tienda web. Un ejemplo muy f치cil se puede encontrar en [**este informe**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) o en [**este error**](https://hackerone.com/reports/759247)**.**

Hay muchas variaciones de este tipo de ataque, incluyendo:

* Canjear una tarjeta de regalo varias veces
* Valorar un producto varias veces
* Retirar o transferir efectivo en exceso del saldo de tu cuenta
* Reutilizar una 칰nica soluci칩n CAPTCHA
* Evitar un l칤mite de tasa anti-fuerza bruta

### **Subestados ocultos**

Otras RC m치s complicadas explotar치n **subestados en el estado de la m치quina** que podr칤an permitir a un atacante **abusar** de estados a los que **nunca se supon칤a que tuviera acceso**, pero hay una **peque침a ventana** para que el atacante acceda a 칠l.

1. **Predecir subestados ocultos e interesantes potenciales**

El primer paso es identificar todos los puntos finales que escriben en 칠l, o leen datos de 칠l y luego usan esos datos para algo importante. Por ejemplo, los usuarios pueden almacenarse en una tabla de base de datos que es modificada por el registro, ediciones de perfil, inicio de restablecimiento de contrase침a y finalizaci칩n de restablecimiento de contrase침a.

Podemos usar tres preguntas clave para descartar puntos finales que es poco probable que causen colisiones. Para cada objeto y los puntos finales asociados, preg칰ntate:

* **쮺칩mo se almacena el estado?**

Los datos almacenados en una estructura de datos persistente del lado del servidor son ideales para la explotaci칩n. Algunos puntos finales almacenan su estado completamente del lado del cliente, como los restablecimientos de contrase침a que funcionan enviando un JWT por correo electr칩nico - estos se pueden omitir con seguridad.

Las aplicaciones a menudo almacenan alg칰n estado en la sesi칩n del usuario. Estos a menudo est치n algo protegidos contra subestados - m치s sobre eso m치s adelante.

* **쮼stamos editando o a침adiendo?**

Las operaciones que editan datos existentes (como cambiar la direcci칩n de correo electr칩nico principal de una cuenta) tienen un amplio potencial de colisi칩n, mientras que las acciones que simplemente a침aden a los datos existentes (como agregar una direcci칩n de correo electr칩nico adicional) es poco probable que sean vulnerables a algo m치s que ataques de exceso de l칤mite.

* **쮼n qu칠 est치 basada la operaci칩n?**

La mayor칤a de los puntos finales operan sobre un registro espec칤fico, que se busca utilizando una 'clave', como un nombre de usuario, token de restablecimiento de contrase침a o nombre de archivo. Para un ataque exitoso, necesitamos dos operaciones que usen la misma clave. Por ejemplo, imagina dos implementaciones plausibles de restablecimiento de contrase침a:

<figure><img src="../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

2. **Buscar pistas**

En este punto es hora de **lanzar algunos ataques RC** sobre los puntos finales potencialmente interesantes para tratar de encontrar resultados inesperados en comparaci칩n con los regulares. **Cualquier desviaci칩n de la respuesta esperada**, como un cambio en una o m치s respuestas, o un efecto secundario como contenidos de correo electr칩nico diferentes o un cambio visible en tu sesi칩n podr칤a ser una pista que indica que algo est치 mal.

3. **Probar el concepto**

El paso final es **probar el concepto y convertirlo en un ataque viable**.

Cuando env칤as un lote de solicitudes, puedes encontrar que un par de solicitudes tempranas desencadenan un estado final vulnerable, pero las solicitudes posteriores lo sobrescriben/invalidan y el estado final es inexplotable. En este escenario, querr치s eliminar todas las solicitudes innecesarias: dos deber칤an ser suficientes para explotar la mayor칤a de las vulnerabilidades. Sin embargo, reducir a dos solicitudes har치 que el ataque sea m치s sensible al tiempo, por lo que es posible que necesites intentar el ataque varias veces o automatizarlo.

### Ataques Sensibles al Tiempo

A veces es posible que no encuentres condiciones de carrera, pero las **t칠cnicas para entregar solicitudes con un tiempo preciso** a칰n pueden revelar la presencia de otras vulnerabilidades.

Un ejemplo es cuando se utilizan **marcas de tiempo de alta resoluci칩n en lugar de cadenas aleatorias seguras criptogr치ficamente** para generar tokens de seguridad.

Considera un **token de restablecimiento de contrase침a que solo se aleatoriza usando una marca de tiempo**. En este caso, podr칤a ser posible **desencadenar dos restablecimientos de contrase침a para dos usuarios diferentes**, que ambos usen el **mismo token**. Todo lo que necesitas hacer es cronometrar las solicitudes para que generen la misma marca de tiempo.

{% hint style="warning" %}
Para confirmar, por ejemplo, la situaci칩n anterior, podr칤as simplemente pedir **2 tokens de restablecimiento de contrase침a al mismo tiempo** (usando ataque de paquete 칰nico) y verificar si son **iguales**.
{% endhint %}

Revisa el [**ejemplo en este laboratorio**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities).

## Estudios de caso de subestados ocultos

### Pagar y a침adir un art칤culo

[**Revisa este laboratorio**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation) para ver c칩mo **pagar** en una tienda y **a침adir un art칤culo extra** que **no necesitar치s pagar**.

### Confirmar otros correos electr칩nicos

La idea es **verificar una direcci칩n de correo electr칩nico y cambiarla por otra diferente al mismo tiempo** para averiguar si la plataforma verifica la nueva cambiada.

### Cambiar correo electr칩nico a 2 direcciones de correo electr칩nico basado en Cookie

Seg칰n [**este informe**](https://portswigger.net/research/smashing-the-state-machine) Gitlab era vulnerable a una toma de control de esta manera porque podr칤a **enviar** el **token de verificaci칩n de correo electr칩nico de un correo a otro**.

Tambi칠n puedes revisar [**este laboratorio**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint) para aprender sobre esto.

### Estados ocultos de la base de datos / Evitar la confirmaci칩n

Si se utilizan **2 escrituras diferentes** para **a침adir** **informaci칩n** dentro de una **base de datos**, hay una peque침a porci칩n de tiempo donde **solo se ha escrito el primer dato** dentro de la base de datos. Por ejemplo, al crear un usuario, el **nombre de usuario** y la **contrase침a** podr칤an ser **escritos** y **luego el token** para confirmar la cuenta reci칠n creada se escribe. Esto significa que por un peque침o tiempo el **token para confirmar una cuenta es nulo**.

Por lo tanto, **registrar una cuenta y enviar varias solicitudes con un token vac칤o** (`token=` o `token[]=` o cualquier otra variaci칩n) para confirmar la cuenta de inmediato podr칤a permitir **confirmar una cuenta** donde no controlas el correo electr칩nico.

Revisa [**este laboratorio**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction) para ver un ejemplo.

### Evitar 2FA

El siguiente pseudo-c칩digo demuestra c칩mo un sitio web podr칤a ser vulnerable a una variaci칩n de ataque de carrera de esta manera:
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
Como puedes ver, esto es de hecho una **secuencia de varios pasos dentro del lapso de una sola solicitud**. Lo m치s importante es que pasa por un subestado en el que el **usuario temporalmente tiene una sesi칩n v치lida iniciada**, **pero la MFA a칰n no se est치 aplicando**. Un atacante podr칤a potencialmente explotar esto enviando una solicitud de inicio de sesi칩n junto con una solicitud a un punto final sensible y autenticado.

### Persistencia eterna de OAuth2

Hay varios [**proveedores de OAUth**](https://en.wikipedia.org/wiki/List_of_OAuth_providers). Estos servicios te permitir치n crear una aplicaci칩n y autenticar usuarios que el proveedor tiene registrados. Para hacerlo, el **cliente** necesitar치 **permitir que tu aplicaci칩n** acceda a algunos de sus datos dentro del **proveedor de OAUth**.\
Hasta aqu칤, solo un inicio de sesi칩n com칰n con google/linkedin/github... donde te aparece una p치gina que dice: "_La aplicaci칩n \<InsertCoolName> quiere acceder a tu informaci칩n, 쯤uieres permitirlo?_"

#### Condici칩n de carrera en `authorization_code`

El **problema** aparece cuando lo **aceptas** y autom치ticamente se env칤a un **`authorization_code`** a la aplicaci칩n maliciosa. Luego, esta **aplicaci칩n abusa de una Condici칩n de Carrera en el proveedor de servicios de OAUth para generar m치s de un AT/RT** (_Token de Autenticaci칩n/Token de Actualizaci칩n_) a partir del **`authorization_code`** de tu cuenta. B치sicamente, abusar치 del hecho de que has aceptado que la aplicaci칩n acceda a tus datos para **crear varias cuentas**. Entonces, si **dejas de permitir que la aplicaci칩n acceda a tus datos, un par de AT/RT se eliminar치, pero los otros seguir치n siendo v치lidos**.

#### Condici칩n de carrera en `Refresh Token`

Una vez que hayas **obtenido un RT v치lido**, podr칤as intentar **abusar de 칠l para generar varios AT/RT** y **aunque el usuario cancele los permisos** para que la aplicaci칩n maliciosa acceda a sus datos, **varios RT seguir치n siendo v치lidos**.

## **RC en WebSockets**

En [**WS_RaceCondition_PoC**](https://github.com/redrays-io/WS_RaceCondition_PoC) puedes encontrar un PoC en Java para enviar mensajes de websocket en **paralelo** para abusar de **Condici칩n de Carrera tambi칠n en Web Sockets**.

## Referencias

* [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
* [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
* [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
* [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
* [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)

<details>

<summary><strong>Aprende hacking en AWS de cero a h칠roe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver a tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** Consulta los [**PLANES DE SUSCRIPCI칍N**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci칩n de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **칔nete al** 游눫 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **sigue** a **Twitter** 游냕 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de github** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Usa [**Trickest**](https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks) para construir y **automatizar flujos de trabajo** f치cilmente, impulsados por las herramientas comunitarias **m치s avanzadas**.\
Obt칠n Acceso Hoy:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}
