# レースコンディション

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
世界で最も進んだコミュニティツールを駆使して、簡単にワークフローを構築し、**自動化**するために[**Trickest**](https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks)を使用します。\
今すぐアクセス：

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)でAWSハッキングをゼロからヒーローまで学ぶ</strong></summary>

HackTricksをサポートする他の方法：

* **HackTricksにあなたの会社を広告したい**、または**HackTricksをPDFでダウンロードしたい**場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS & HackTricksグッズ**](https://peass.creator-spring.com)を入手する
* [**PEASSファミリー**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFT**](https://opensea.io/collection/the-peass-family)コレクションをチェックする
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に**参加する**か、[**テレグラムグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)を**フォローする**。
* [**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のGitHubリポジトリにPRを提出して、あなたのハッキングテクニックを共有する。

</details>

## RCの悪用

RCを悪用する主な問題は、リクエストが非常に短い時間差（通常は>1ms）で並行して処理される必要があることです。以下のセクションでは、これを可能にするための異なるソリューションが提案されています。

<figure><img src="../.gitbook/assets/image (5) (1) (1).png" alt=""><figcaption></figcaption></figure>

### シングルパケット攻撃（HTTP/2）/ ラストバイト同期（HTTP/1.1）

HTTP2では、**2つのリクエストを1つのTCP接続で送信**できます（HTTP/1.1では順番に送信する必要があります）。\
単一のTCPパケットの使用は、ネットワークジッターの影響を完全に**排除**しますので、これはレースコンディション攻撃にも明らかに可能性があります。しかし、**サーバーサイドジッター**のおかげで、**2つのリクエストでは信頼性のあるレース攻撃には不十分**です。これは、CPU競合などの制御不能な変数によって引き起こされるアプリケーションのリクエスト処理時間の変動です。

しかし、HTTP/1.1の「**ラストバイト同期**」テクニックを使用すると、各リクエストからごく小さな断片を保持して先に送信し、**20-30のリクエストを単一のTCPパケットで「完了」**することが可能です。

**各リクエストの大部分を先に送信する**には：

* リクエストにボディがない場合は、すべてのヘッダーを送信しますが、END_STREAMフラグは設定しません。END_STREAMが設定された空のデータフレームを保持します。
* リクエストにボディがある場合は、ヘッダーとボディデータの最後のバイトを除くすべてを送信します。最後のバイトを含むデータフレームを保持します。

次に、**最終フレームの送信を準備**します：

* 初期フレームが送信されたことを確認するために100ms待ちます。
* TCP_NODELAYが無効になっていることを確認します - 最終フレームをNagleのアルゴリズムがバッチ処理することが重要です。
* ローカル接続を温めるためにピングパケットを送信します。これを行わないと、OSのネットワークスタックが最初の最終フレームを別のパケットに配置します。

最後に、保持していたフレームを送信します。Wiresharkを使用して、それらが単一のパケットに着陸したことを確認できるはずです。

{% hint style="info" %}
特定のサーバー上の静的ファイルには**機能しない**ことに注意してくださいが、静的ファイルはRC攻撃には関係ありません。
{% endhint %}

このテクニックを使用すると、ネットワークジッターに関係なく、20-30のリクエストがサーバーに同時に到着するようにすることができます：

<figure><img src="../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

**ターゲットアーキテクチャへの適応**

多くのアプリケーションはフロントエンドサーバーの背後にあり、これらは一部のリクエストを既存の接続を介してバックエンドに転送し、他のリクエストには新しい接続を作成することを決定する場合があります。

その結果、リクエストのタイミングが一貫性がないとしても、それをアプリケーションの挙動、例えば一度に1つのスレッドのみがリソースにアクセスを許可するロックメカニズムなどに帰することは重要です。また、フロントエンドのリクエストルーティングはしばしば接続ごとに行われるため、攻撃を行う前にサーバーサイドの接続を温めることでリクエストのタイミングを滑らかにすることができるかもしれません（これは実際の攻撃を開始する前にいくつかのリクエストを送信することです）。

#### セッションベースのロックメカニズム <a href="#session-based-locking-mechanisms" id="session-based-locking-mechanisms"></a>

一部のフレームワークは、偶発的なデータ破損を防ぐために、何らかの形の**リクエストロック**を使用しています。例えば、**PHPのネイティブセッションハンドラー**モジュールは、**一度に1つのセッションごとに1つのリクエストのみを処理**します。

このような挙動を見逃さないことが非常に重要です。それがなければ、簡単に悪用できる脆弱性を隠してしまう可能性があります。すべてのリクエストが順番に処理されていることに気づいた場合は、それぞれに異なるセッショントークンを使用して送信してみてください。

#### **レートまたはリソース制限の悪用**

接続の温めが何の違いも生まない場合は、この問題に対するさまざまな解決策があります。

Turbo Intruderを使用すると、クライアント側の短い遅延を導入できます。しかし、これにより実際の攻撃リクエストを複数のTCPパケットに分割する必要があるため、シングルパケット攻撃テクニックは使用できません。その結果、高ジッターのターゲットでは、設定する遅延に関係なく、攻撃は信頼性を持って機能する可能性は低いです。

<figure><img src="../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

代わりに、一般的なセキュリティ機能を悪用することで、この問題を解決できるかもしれません。

Webサーバーは、あまりにも速く多くのリクエストが送信されると、リクエストの処理を遅延させることがよくあります。大量のダミーリクエストを intentionally trigger the rate or resource limit, you may be able to cause a suitable server-side delay. This makes the single-packet attack viable even when delayed execution is required.

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

{% hint style="warning" %}
このテクニックの詳細については、元のレポートを[https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)でチェックしてください。
{% endhint %}

#### 攻撃例

* **Turbo Intruder - HTTP2シングルパケット攻撃（1エンドポイント）**: リクエストを**Turbo Intruder**に送信することができます（`Extensions` -> `Turbo Intruder` -> `Send to Turbo Intruder`）、リクエストの中でブルートフォースしたい値を**`%s`**のように変更できます。例えば`csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&username=carlos&password=%s`のようにして、ドロップダウンから**`examples/race-single-packer-attack.py`**を選択します：

<figure><img src="../.gitbook/assets/image (4) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

もし**異なる値を送信**する場合は、クリップボードからのワードリストを使用するこのコードで修正することができます：
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
{% hint style="warning" %}
もしWebがHTTP2をサポートしていない（HTTP1.1のみ）場合は、`Engine.BURP2`の代わりに`Engine.THREADED`または`Engine.BURP`を使用してください。
{% endhint %}

* **Tubo Intruder - HTTP2 シングルパケット攻撃（複数のエンドポイント）**: RCEをトリガーするために1つのエンドポイントにリクエストを送り、その後他のエンドポイントに複数のリクエストを送る必要がある場合、`race-single-packet-attack.py` スクリプトを以下のように変更できます:
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
* **Repeater**では、Burp Suiteの新機能「**Send group in parallel**」オプションを通じて利用可能です。
* **limit-overrun**の場合、グループに**同じリクエストを50回追加**するだけです。
* **connection warming**のためには、グループの**始め**にウェブサーバーの静的でない部分への**リクエスト**を**追加**します。
* **遅延**は、2つのサブステートステップの間で**一つのリクエストと別のリクエストの処理**を遅らせるために、両リクエストの間に**追加のリクエストを追加**します。
* **multi-endpoint** RCの場合、**隠された状態に行くリクエスト**を送信し始め、その直後に隠された状態を**利用する50のリクエスト**を送信します。

<figure><img src="../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Raw BF

以前の研究より前には、RCを引き起こすためにできるだけ早くパケットを送信しようとするペイロードがいくつか使われていました。

* **Repeater:** 前のセクションの例を確認してください。
* **Intruder**: **リクエスト**を**Intruder**に送信し、**Optionsメニュー**内で**スレッド数**を**30**に設定し、ペイロードに**Null payloads**を選択して**30**を生成します。
* **Turbo Intruder**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
* **Python - asyncio**
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## **RC 方法論**

### Limit-overrun / TOCTOU

これは、**アクションを実行できる回数に制限がある場所に現れる脆弱性**が最も基本的なタイプのレースコンディションです。例えば、ウェブストアで同じ割引コードを何度も使用することです。非常に簡単な例は[**このレポート**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43)や[**このバグ**](https://hackerone.com/reports/759247)で見つけることができます。

この種の攻撃には多くのバリエーションがあります。これには以下が含まれます：

* ギフトカードを複数回償還する
* 製品を複数回評価する
* 口座残高を超えて現金を引き出すまたは転送する
* 単一のCAPTCHAソリューションを再利用する
* アンチブルートフォースレート制限をバイパスする

### **隠されたサブステート**

他の複雑なRCは、攻撃者が**アクセスすることを意図されていなかった**状態を**悪用**することができる**マシン状態のサブステート**を悪用しますが、攻撃者がそれにアクセスするための**小さなウィンドウ**があります。

1. **潜在的な隠された＆興味深いサブステートを予測する**

最初のステップは、それに書き込むか、またはそれからデータを読み取り、そのデータを何か重要なことに使用するすべてのエンドポイントを特定することです。例えば、ユーザーは登録、プロファイル編集、パスワードリセットの開始、パスワードリセットの完了によって変更されるデータベーステーブルに格納されるかもしれません。

衝突を引き起こす可能性が低いエンドポイントを除外するために、3つの重要な質問を使用できます。各オブジェクトと関連するエンドポイントについて、次のことを尋ねます：

* **状態はどのように保存されますか？**

サーバー側の永続的なデータ構造に保存されたデータは、悪用に理想的です。一部のエンドポイントは、JWTをメールで送信するパスワードリセットのように、その状態を完全にクライアント側で保存します - これらは安全にスキップできます。

アプリケーションはしばしばいくつかの状態をユーザーセッションに保存します。これらはしばしばサブステートに対してある程度保護されています - 後で詳しく説明します。

* **編集していますか、それとも追加していますか？**

既存のデータを編集する操作（例えば、アカウントの主要なメールアドレスを変更する）は、衝突の可能性が十分にありますが、既存のデータに単に追加する操作（例えば、追加のメールアドレスを追加する）は、Limit-overrun攻撃以外には脆弱性がある可能性が低いです。

* **操作は何に基づいていますか？**

ほとんどのエンドポイントは、ユーザー名、パスワードリセットトークン、またはファイル名などの「キー」を使用して検索される特定のレコードに対して操作します。成功した攻撃には、同じキーを使用する2つの操作が必要です。例えば、2つのありそうなパスワードリセット実装を想像してみてください：

<figure><img src="../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

2. **手がかりを探る**

この時点で、興味深いエンドポイントに対していくつかのRC攻撃を**開始し**、通常のものと比較して予期しない結果を見つけようとします。**期待される応答からの逸脱**、例えば1つ以上の応答の変更、またはセッションの可視的な変更のような二次効果は、何かが間違っていることを示す手がかりになる可能性があります。

3. **コンセプトを証明する**

最後のステップは、**コンセプトを証明し、実行可能な攻撃に変える**ことです。

一連のリクエストを送信すると、早い段階のリクエストペアが脆弱なエンドステートを引き起こす可能性がありますが、後のリクエストがそれを上書き/無効にし、最終的な状態は悪用できないものになるかもしれません。このシナリオでは、不要なリクエストをすべて排除する必要があります - ほとんどの脆弱性を悪用するには2つで十分です。ただし、2つのリクエストに減らすと攻撃はタイミングに敏感になるため、攻撃を複数回試行するか、自動化する必要があるかもしれません。

### タイムセンシティブ攻撃

時にはレースコンディションを見つけることができないかもしれませんが、**リクエストを正確なタイミングで送信するための技術**は、他の脆弱性の存在を明らかにすることができます。

その一例は、**高解像度のタイムスタンプが暗号学的に**安全なランダム文字列の代わりにセキュリティトークンを生成するために使用される場合です。

**タイムスタンプを使用してランダム化されたパスワードリセットトークン**の場合を考えてみましょう。この場合、**同じトークン**を使用する**2つの異なるユーザー**のパスワードリセットを**トリガー**することが可能かもしれません。必要なのは、同じタイムスタンプを生成するようにリクエストのタイミングを合わせることだけです。

{% hint style="warning" %}
例えば前述の状況を確認するには、**同時に2つのパスワードリセットトークンをリクエスト**する（シングルパケット攻撃を使用）し、それらが**同じ**かどうかを確認するだけです。
{% endhint %}

[**このラボの例**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities)をチェックしてください。

## 隠されたサブステートのケーススタディ

### 支払い＆アイテム追加

[**このラボをチェック**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation)して、店で**支払い**を行い、それに**追加料金を支払う必要がない**アイテムを**追加**する方法を見てください。

### 他のメールを確認する

このアイデアは、**メールアドレスを確認し、同時に別のメールアドレスに変更する**ことで、プラットフォームが新しく変更されたメールを検証するかどうかを確認することです。

### Cookieベースで2つのメールアドレスにメールを変更する

[**このライトアップ**](https://portswigger.net/research/smashing-the-state-machine)によると、Gitlabはこの方法で乗っ取りに脆弱だった可能性があります。なぜなら、**一方のメールのメール確認トークンを他方のメールに送信**する可能性があるからです。

このことについても[**このラボ**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint)をチェックして学ぶことができます。

### 隠されたデータベース状態 / 確認バイパス

**2つの異なる書き込み**が使用されて**データベース**内に**情報を追加**する場合、**最初のデータが書き込まれた後の小さな時間**があります。例えば、ユーザーを作成するときに、**ユーザー名**と**パスワード**が**書き込まれ**、**その後で新しく作成されたアカウントを確認するためのトークン**が書き込まれます。これは、**アカウントを確認するためのトークンがnullである小さな時間**があることを意味します。

したがって、**アカウントを登録し、空のトークン**（`token=`や`token[]=`やその他のバリエーション）を使用して直ちにアカウントを確認するために複数のリクエストを送信することで、メールをコントロールしていないアカウントを**確認する**ことができるかもしれません。

[**このラボ**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction)をチェックして例を確認してください。

### 2FAをバイパスする

次の擬似コードは、ウェブサイトがこの攻撃のレースバリエーションに脆弱である可能性を示しています：
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
以下は、**単一のリクエストの範囲内での多段階シーケンス**であることがわかります。最も重要なのは、**ユーザーが一時的に有効なログインセッションを持っている**が、**まだMFAが強制されていない**というサブステートを経由することです。攻撃者は、ログインリクエストと機密性の高い認証済みエンドポイントへのリクエストを同時に送信することで、これを悪用する可能性があります。

### OAuth2 永続的な保持

いくつかの[**OAuthプロバイダー**](https://en.wikipedia.org/wiki/List_of_OAuth_providers)があります。これらのサービスでは、アプリケーションを作成し、プロバイダーが登録しているユーザーを認証することができます。これを行うためには、**クライアント**は**OAuthプロバイダー**内のデータの一部にアクセスするためにアプリケーションを許可する必要があります。\
ここまでは、google/linkdin/github...での一般的なログインで、"_アプリケーション\<InsertCoolName>があなたの情報にアクセスしたいと思っています。許可しますか？_"というページが表示されます。

#### `authorization_code`のレースコンディション

**問題**は、それを**受け入れる**と自動的に**`authorization_code`**を悪意のあるアプリケーションに送信するところにあります。その後、この**アプリケーションはOAuthサービスプロバイダーのレースコンディションを悪用して、あなたのアカウントの**`authorization_code`**から複数のAT/RT** (_認証トークン/リフレッシュトークン_)を生成します。基本的に、あなたがアプリケーションにデータへのアクセスを許可した事実を悪用して**複数のアカウントを作成します**。その後、アプリケーションへのデータアクセスを停止すると、一組のAT/RTは削除されますが、他のものは有効のままです。

#### `Refresh Token`のレースコンディション

有効なRTを**取得したら**、それを悪用して複数のAT/RTを生成しようと試みることができ、**ユーザーが悪意のあるアプリケーションへのデータアクセス許可をキャンセルしても**、複数のRTが有効のままになります。

## **WebSocketsのRC**

[**WS_RaceCondition_PoC**](https://github.com/redrays-io/WS_RaceCondition_PoC)では、JavaでのPoCを見つけることができ、**並行して**websocketメッセージを送信して**Web Socketsでもレースコンディションを悪用**します。

## 参考文献

* [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
* [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
* [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
* [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
* [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)でAWSハッキングをゼロからヒーローまで学ぶ</strong></summary>

HackTricksをサポートする他の方法:

* **HackTricksにあなたの会社を広告したい**、または**HackTricksをPDFでダウンロードしたい**場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS & HackTricksグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションをチェックする
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)や[**telegramグループ**](https://t.me/peass)に**参加する**か、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)で**フォローする**。
* [**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のgithubリポジトリにPRを提出して、あなたのハッキングのコツを**共有する**。

</details>

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
世界で**最も進んだ**コミュニティツールを駆使してワークフローを簡単に**構築し自動化**するために[**Trickest**](https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks)を使用します。\
今すぐアクセス：

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}
