# Introducci√≥n

Despu√©s de analizar las RCEs a trav√©s de bibliotecas JSON mal configuradas, comenzamos a analizar los ViewStates de las implementaciones JSF. JavaServer Faces (JSF) es una tecnolog√≠a de interfaz de usuario (UI) para construir UI web con componentes reutilizables. JSF se utiliza principalmente para aplicaciones empresariales y una implementaci√≥n de JSF se utiliza t√≠picamente por una aplicaci√≥n web que se ejecuta en un servidor de aplicaciones Java como JBoss EAP o WebLogic Server. Hay dos implementaciones bien conocidas de la especificaci√≥n JSF:

* Oracle Mojarra (implementaci√≥n de referencia de JSF)
* Apache MyFaces

# Alcance

Esta publicaci√≥n de blog se centra en las dos implementaciones JSF 2.x: Oracle Mojarra (Implementaci√≥n de referencia) y Apache MyFaces. Las implementaciones antiguas (JSF 1.x) tambi√©n son susceptibles de verse afectadas por las vulnerabilidades descritas en esta publicaci√≥n. (JSF 2.0.x se lanz√≥ inicialmente en 2009, la versi√≥n actual es 2.3.x).

# El estado del ViewState

Una diferencia entre JSF y tecnolog√≠as web similares es que JSF utiliza ViewStates (adem√°s de sesiones) para almacenar el estado actual de la vista (por ejemplo, qu√© partes de la vista deben mostrarse actualmente). El ViewState puede almacenarse en el `servidor` o en el `cliente`. Los ViewStates de JSF suelen incrustarse autom√°ticamente en los formularios HTML como campo oculto con el nombre `javax.faces.ViewState`. Se env√≠an de vuelta al servidor si se env√≠a el formulario.

## ViewState en el servidor

Si el ViewState de JSF est√° configurado para estar en el `servidor`, el campo oculto `javax.faces.ViewState` contiene un ID que ayuda al servidor a recuperar el estado correcto. En el caso de MyFaces, ¬°ese ID es un **objeto Java serializado**!

## ViewState en el cliente

Si el ViewState de JSF est√° configurado para estar en el `cliente`, el campo oculto `javax.faces.ViewState` contiene un **objeto Java serializado** que est√° al menos codificado en Base64. Es posible que se haya dado cuenta hasta ahora de que esto es un camino potencial hacia el desastre. Esa podr√≠a ser una de las razones por las que hoy en d√≠a los ViewStates de JSF est√°n cifrados y firmados antes de ser enviados al cliente.

# Los peligros de los objetos Java serializados

En 2015, en la conferencia AppSec California, Gabriel Lawrence y Chris Frohoff presentaron [Marshalling Pickles (how deserializing objects can ruin your day)](https://frohoff.github.io/appseccali-marshalling-pickles/). Esta presentaci√≥n arroj√≥ algo de luz sobre los problemas olvidados con la serializaci√≥n de objetos Java y llev√≥ al descubrimiento de varias vulnerabilidades graves de ejecuci√≥n remota de c√≥digo (RCE).

Desafortunadamente, llev√≥ a algunas personas a creer que la vulnerabilidad podr√≠a mitigarse eliminando/actualizando ciertas versiones de Apache Commons Collections. Una acci√≥n que puede ayudar, pero no resuelve la causa ra√≠z del problema: Deserializaci√≥n de datos no confiables ([CWE 502](https://cwe.mitre.org/data/definitions/502.html)). En otras palabras:\
**El uso de una versi√≥n de Apache Commons Collections 'vulnerable' no significa que la aplicaci√≥n sea vulnerable, ni la ausencia de tal versi√≥n de la biblioteca significa que la aplicaci√≥n no sea vulnerable.**

Sin embargo, despu√©s de que un hacker malintencionado [apag√≥ y cifr√≥ los sistemas de la Agencia Municipal de Transporte de San Francisco](https://krebsonsecurity.com/2016/11/san-francisco-rail-system-hacker-hacked/) a trav√©s de una "Vulnerabilidad de deserializaci√≥n de Apache Commons Collections/Mad Gadget", Google inici√≥ [Operation Rosehub](https://opensource.googleblog.com/2017/03/operation-rosehub.html). El objetivo de la operaci√≥n Rosehub era encontrar tantos proyectos de c√≥digo abierto de Java como fuera posible que utilizaran una versi√≥n de colecciones comunes de Apache 'amigable para el atacante' como dependencia y enviar solicitudes de extracci√≥n a los propietarios del proyecto para que esos proyectos dejaran de usar versiones problem√°ticas de colecciones comunes en versiones m√°s nuevas.

# El ataque al ViewState

Supongamos que tenemos una aplicaci√≥n web con una p√°gina de inicio de sesi√≥n basada en JSF:

![JSF based login](https://www.alphabot.com/images/blog/jsf-viewstate/jsf-viewstate-login.png)

Esa p√°gina de inicio de sesi√≥n tiene un ViewState que no est√° cifrado ni firmado. As√≠ que cuando miramos su fuente HTML, vemos un campo oculto que contiene el ViewState: ViewState de MyFaces sin cifrar:
```
<input type="hidden" name="javax.faces.ViewState" id="j_id__v_0:javax.faces.ViewState:1" value="rO0ABXVyABNbTGphdmEubGFuZy5PYmplY3Q7kM5YnxBzKWwCAAB4cAAAAAJwdAAML2xvZ2luLnhodG1s" autocomplete="off" />
```
Si decodificas el ViewState anterior usando Base64, notar√°s que contiene un objeto Java serializado. Este ViewState se env√≠a de vuelta al servidor a trav√©s de POST cuando se env√≠a el formulario (por ejemplo, al hacer clic en Iniciar sesi√≥n). Ahora, antes de que el ViewState se env√≠e de vuelta al servidor, el atacante reemplaza el ViewState con su propio ViewState malicioso utilizando un gadget que ya est√° en el classpath del servidor (por ejemplo, `InvokerTransformer` de commons-collections-3.2.1.jar) o incluso un gadget que a√∫n no es conocido por el p√∫blico. Con dicho gadget malicioso colocado en el ViewState, el atacante especifica qu√© comandos quiere ejecutar en el servidor. La flexibilidad de lo que un atacante puede hacer est√° limitada por los poderes de los gadgets disponibles en el classpath del servidor. En el caso de `InvokerTransformer`, el atacante puede especificar qu√© comandos de l√≠nea de comandos deben ejecutarse en el servidor. El atacante en nuestro ejemplo eligi√≥ iniciar una calculadora en la interfaz de usuario de nuestro servidor basado en Linux.

Despu√©s de que el atacante haya enviado su formulario modificado de vuelta al servidor, la implementaci√≥n de JSF intenta deserializar el ViewState proporcionado. Ahora, incluso antes de que la deserializaci√≥n del ViewState haya terminado, se ejecuta el comando y se inicia la calculadora en el servidor:

![calculadora iniciada a trav√©s de un ViewState de JSF](https://www.alphabot.com/images/blog/jsf-viewstate/jsf-viewstate-started-calculator.png)

Todo sucedi√≥ antes de que la implementaci√≥n de JSF pudiera echar un vistazo al ViewState y decidir que no era bueno. Cuando se encontr√≥ que el ViewState era inv√°lido, t√≠picamente se env√≠a un error de vuelta al cliente como "Vista expirada". Pero entonces ya es demasiado tarde. El atacante tuvo acceso al servidor y ha ejecutado comandos. (La mayor√≠a de los atacantes del mundo real no inician una calculadora, pero t√≠picamente implementan una shell remota, que luego utilizan para acceder al servidor).

=> En resumen, este ejemplo demuestra una vulnerabilidad muy peligrosa de ejecuci√≥n remota de c√≥digo (RCE) no autenticada.

(Casi el mismo escenario de ataque contra JSF como se describe anteriormente ya se hab√≠a esbozado y demostrado en la presentaci√≥n de 2015 (p√°ginas 65 a 67): [Marshalling Pickles](https://frohoff.github.io/appseccali-marshalling-pickles/) realizada por Frohoff y Lawrence).

# Las condiciones previas para un ataque exitoso

Ahora, ¬øcu√°les son los ingredientes para un desastre?

* ViewState no cifrado (o posesi√≥n de la clave de cifrado)
* Gadget en el classpath del servidor
* En el caso de Mojarra: ViewState configurado para residir en el `cliente`
* En el caso de MyFaces: ViewState configurado para residir en el `cliente` **o** en el `servidor`

Veamos esos puntos en relaci√≥n con las dos implementaciones de JSF.

# Oracle Mojarra (implementaci√≥n de referencia de JSF)

Como se dijo antes, Oracle Mojarra es la Implementaci√≥n de Referencia (RI) de JSF, pero puede que no sea conocida con ese nombre. Puede ser conocida como Sun JSF RI, reconocida con el nombre del paquete java `com.sun.faces` o con el nombre ambiguo del archivo jar `jsf-impl.jar`.

## Mojarra: ViewState no cifrado

Aqu√≠ est√° la cosa: Mojarra no cifr√≥ y firm√≥ el ViewState del lado del cliente de forma predeterminada en la mayor√≠a de las versiones de 2.0.x y 2.1.x. Es importante tener en cuenta que un ViewState del lado del servidor es el valor predeterminado en ambas implementaciones de JSF, pero un desarrollador podr√≠a cambiar f√°cilmente la configuraci√≥n para usar un ViewState del lado del cliente estableciendo el par√°metro `javax.faces.STATE_SAVING_METHOD` en `cliente`. El nombre del par√°metro no revela de ninguna manera que cambiarlo a cliente introduce graves vulnerabilidades de ejecuci√≥n remota de c√≥digo (por ejemplo, un ViewState del lado del cliente podr√≠a usarse en aplicaciones web en cl√∫ster).

Si bien el cifrado del ViewState del lado del cliente es el valor predeterminado en Mojarra 2.2 y versiones posteriores, no lo fue para las ramas 2.0.x y 2.1.x. Sin embargo, en mayo de 2016, los desarrolladores de Mojarra comenzaron a retroportar el cifrado predeterminado del ViewState del lado del cliente a [2.0.x](https://github.com/javaserverfaces/mojarra/issues/4142) y [2.1.x](https://github.com/javaserverfaces/mojarra/issues/4141) cuando se dieron cuenta de que los ViewStates no cifrados conduc√≠an a vulnerabilidades de RCE.

Por lo tanto, al menos la versi√≥n [2.1.29-08](https://mvnrepository.com/artifact/com.sun.faces/jsf-impl/2.1.29-08) (lanzada en julio de 2016) de la rama 2.1.x y la versi√≥n [2.0.11-04](https://mvnrepository.com/artifact/com.sun.faces/jsf-impl/2.0.11-04) (tambi√©n lanzada en julio de 2016) de la rama 2.0.x tienen el cifrado habilitado de forma predeterminada.

Cuando analizamos las bibliotecas de Mojarra, notamos que Red Hat tambi√©n lanza versiones de Mojarra para las ramas 2.1.x y 2.0.x, siendo la √∫ltima [2.1.29-jbossorg-1](https://mvnrepository.com/artifact/com.sun.faces/jsf-impl/2.1.29-jbossorg-1) y [2.0.4-b09-jbossorg-4](https://mvnrepository.com/artifact/com.sun.faces/jsf-impl/2.0.4-b09-jbossorg-4). Dado que ambos lanzamientos no ten√≠an cifrado predeterminado del ViewState, contactamos a Red Hat y ellos crearon r√°pidamente [Bug 1479661 - JSF client side view state saving deserializes data](https://bugzilla.redhat.com/show_bug.cgi?id=1479661) en su rastreador de errores con el siguiente consejo de mitigaci√≥n para la rama 2.1.x:

> Una aplicaci√≥n web vulnerable debe haber establecido javax.faces.STATE_SAVING_METHOD en 'cliente' para habilitar el guardado de ViewState del lado del cliente. El valor predeterminado en Enterprise Application Platform (EAP) 6.4.x es 'servidor'.\
> \
> Si javax.faces.STATE_SAVING_METHOD est√° establecido en 'cliente', una mitigaci√≥n para este problema es cifrar la vista estableciendo com.sun.faces.ClientStateSavingPassword en el archivo web.xml de la aplicaci√≥n:
>
> ```markup
>   <context-param>
>     <param-name>javax.faces.STATE_SAVING_METHOD</param-name>
>     <param-value>cliente</param-value>
>   </context-param>
>
>   <env¬≠-entry> 
>     <env¬≠-entry-¬≠name>com.sun.faces.ClientStateSavingPassword</env¬≠-entry-
```python
#!/usr/bin/python3
import sys
import hmac
from urllib import parse
from base64 import b64encode
from hashlib import sha1
from pyDes import *

YELLOW = "\033[93m"
GREEN = "\033[32m"

def encrypt(payload,key):
	cipher = des(key, ECB, IV=None, pad=None, padmode=PAD_PKCS5)
	enc_payload = cipher.encrypt(payload)
	return enc_payload

def hmac_sig(enc_payload,key):
	hmac_sig = hmac.new(key, enc_payload, sha1)
	hmac_sig = hmac_sig.digest()
	return hmac_sig

key = b'JsF9876-'

if len(sys.argv) != 3 :
	print(YELLOW + "[!] Usage : {} [Payload File] [Output File]".format(sys.argv[0]))
else:
	with open(sys.argv[1], "rb") as f:
		payload = f.read()
		f.close()
	print(YELLOW + "[+] Encrypting payload")
	print(YELLOW + "  [!] Key : JsF9876-\n")
	enc_payload = encrypt(payload,key)
	print(YELLOW + "[+] Creating HMAC signature")
	hmac_sig = hmac_sig(enc_payload,key)
	print(YELLOW + "[+] Appending signature to the encrypted payload\n")
	payload = b64encode(enc_payload + hmac_sig)
	payload = parse.quote_plus(payload)
	print(YELLOW + "[*] Final payload : {}\n".format(payload))
	with open(sys.argv[2], "w") as f:
		f.write(payload)
		f.close()
	print(GREEN + "[*] Saved to : {}".format(sys.argv[2]))
```
# Detecci√≥n de claves conocidas con Badsecrets

![Badsecrets](https://github.com/blacklanternsecurity/badsecrets) es una biblioteca capaz de detectar el uso de claves criptogr√°ficas conocidas al examinar los productos que producen y verificarlos con una lista de claves conocidas o d√©biles. Su m√≥dulo `Jsf_viewstate` es capaz de detectar Java Server Faces ViewStates creados con claves conocidas tanto en Mojarra como en MyFaces, adem√°s de ViewStates sin protecci√≥n o comprimidos.

La forma m√°s r√°pida de usarlo es con la herramienta de ejemplo `cli.py` de la siguiente manera:
```
pip install badsecrets
git clone https://github.com/blacklanternsecurity/badsecrets
cd badsecrets
python examples/cli.py Ly8gp+FZKt9XsaxT5gZu41DDxO74k029z88gNBOru2jXW0g1Og+RUPdf2d8hGNTiofkD1VvmQTZAfeV+5qijOoD+SPzw6K72Y1H0sxfx5mFcfFtmqX7iN6Gq0fwLM+9PKQz88f+e7KImJqG1cz5KYhcrgT87c5Ayl03wEHvWwktTq9TcBJc4f1VnNHXVZgALGqQuETU8hYwZ1VilDmQ7J4pZbv+pvPUvzk+/e2oNeybso6TXqUrbT2Mz3k7yfe92q3pRjdxRlGxmkO9bPqNOtETlLPE5dDiZYo1U9gr8BBQ=
```
Si encuentra una coincidencia, tambi√©n mostrar√° la plataforma (Mojarra o MyFaces), el algoritmo de cifrado utilizado y si se utiliz√≥ o no compresi√≥n, lo cual es esencial para la explotaci√≥n.

Para buscar viewstates vulnerables a gran escala, en conjunto con la enumeraci√≥n de subdominios, se puede utilizar el m√≥dulo `badsecrets` de [**BBOT**]().
```
bbot -f subdomain-enum -m badsecrets -t evil.corp
```
# Reflexiones finales

La mayor√≠a de los hechos sobre los JSF ViewStates y sus peligros presentados en esta publicaci√≥n de blog no son exactamente nuevos, pero parece que nunca se presentaron de manera tan condensada. Demostr√≥ [una vez m√°s](https://www.alphabot.com/security/blog/2017/net/How-to-configure-Json.NET-to-create-a-vulnerable-web-API.html) que los cambios de configuraci√≥n aparentemente inofensivos pueden llevar a vulnerabilidades graves.

\=> Uno de los problemas parece ser que no hay suficiente transferencia de conocimiento entre los investigadores de seguridad y los desarrolladores que realmente usan y configuran bibliotecas que pueden ser peligrosas cuando se configuran de ciertas maneras.

# Referencias

* [https://www.alphabot.com/security/blog/2017/java/Misconfigured-JSF-ViewStates-can-lead-to-severe-RCE-vulnerabilities.html](https://www.alphabot.com/security/blog/2017/java/Misconfigured-JSF-ViewStates-can-lead-to-severe-RCE-vulnerabilities.html)
* [https://0xrick.github.io/hack-the-box/arkham/](https://0xrick.github.io/hack-the-box/arkham/)


<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

- ¬øTrabajas en una **empresa de ciberseguridad**? ¬øQuieres ver tu **empresa anunciada en HackTricks**? ¬øO quieres tener acceso a la **√∫ltima versi√≥n de PEASS o descargar HackTricks en PDF**? ¬°Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!

- Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos.

- Obt√©n el [**swag oficial de PEASS y HackTricks**](https://peass.creator-spring.com)

- **√önete al** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live).

- **Comparte tus trucos de hacking enviando PR al [repositorio de hacktricks](https://github.com/carlospolop/hacktricks) y al [repositorio de hacktricks-cloud](https://github.com/carlospolop/hacktricks-cloud)**.

</details>
