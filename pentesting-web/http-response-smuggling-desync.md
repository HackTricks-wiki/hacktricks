# HTTP Response Smuggling / Desync

<details>

<summary><strong>Aprende hacking en AWS de cero a h칠roe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver a tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** revisa los [**PLANES DE SUSCRIPCI칍N**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci칩n de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **칔nete al** 游눫 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s칤gueme** en **Twitter** 游냕 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de GitHub de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Desincronizaci칩n de la Cola de Peticiones HTTP

Primero que nada, esta t칠cnica **abusa de una vulnerabilidad de HTTP Request Smuggling**, por lo que necesitas saber qu칠 es eso:

La **principal diferencia** entre esta t칠cnica y un HTTP Request Smuggling com칰n es que **en lugar de atacar** la **petici칩n** de la **v칤ctima a침adiendo un prefijo a la misma**, vamos a **filtrar o modificar la respuesta que recibe la v칤ctima**. Esto se hace, en lugar de enviar 1 petici칩n y media para abusar del HTTP Request Smuggling, **enviando 2 peticiones completas para desincronizar la cola de respuestas de los proxies**.

Esto se debe a que vamos a poder **desincronizar la cola de respuestas** para que la **respuesta** de la **petici칩n leg칤tima** de la **v칤ctima sea enviada al atacante**, o por **inyectar contenido controlado por el atacante en la respuesta a la v칤ctima**.

### Desincronizaci칩n de Pipeline HTTP

HTTP/1.1 permite solicitar **diferentes recursos sin necesidad de esperar a los anteriores**. Por lo tanto, si hay un **proxy** en el **medio**, es tarea del proxy **mantener un emparejamiento sincronizado de las peticiones enviadas al backend y las respuestas recibidas de este**.

Sin embargo, hay un problema al desincronizar la cola de respuestas. Si un atacante env칤a un ataque de HTTP Response Smuggling y las respuestas a la **petici칩n inicial y la contrabandeada se responden inmediatamente**, la respuesta contrabandeada no ser치 insertada dentro de la cola de respuesta de la v칤ctima sino que **simplemente se descartar치 como un error**.

![](<../.gitbook/assets/image (635) (1) (1) (1).png>)

Por lo tanto, es necesario que la **petici칩n contrabandeada** **tome m치s tiempo en ser procesada** dentro del servidor backend. As칤, para cuando la petici칩n contrabandeada sea procesada, la comunicaci칩n con el atacante habr치 terminado.

Si en esta situaci칩n espec칤fica una **v칤ctima ha enviado una petici칩n** y la **respuesta a la petici칩n contrabandeada se responde antes** que la petici칩n leg칤tima, la **respuesta contrabandeada ser치 enviada a la v칤ctima**. Por lo tanto, el atacante estar치 **controlando la petici칩n "realizada" por la v칤ctima**.

Adem치s, si el **atacante luego realiza una petici칩n** y la **respuesta leg칤tima** a la petici칩n de la **v칤ctima** se **responde** **antes** que la petici칩n del atacante. La **respuesta a la v칤ctima va a ser enviada al atacante**, **robando** la respuesta destinada a la v칤ctima (que puede contener por ejemplo el encabezado **Set-Cookie**).

![](<../.gitbook/assets/image (658) (1).png>)

![](<../.gitbook/assets/image (655) (1) (1) (1).png>)

### Inyecciones Anidadas M칰ltiples

Otra **diferencia interesante** con el HTTP Request Smuggling com칰n es que, en un ataque de smuggling com칰n, el **objetivo** es **modificar el comienzo de la petici칩n de la v칤ctima** para que realice una acci칩n inesperada. En un **ataque de HTTP Response Smuggling**, como est치s **enviando peticiones completas**, puedes **inyectar en un solo payload decenas de respuestas** que estar치n **desincronizando a decenas de usuarios** que estar치n **recibiendo** las **respuestas inyectadas**.

Adem치s de poder **distribuir m치s f치cilmente decenas de exploits** entre usuarios leg칤timos, esto tambi칠n podr칤a usarse para causar un **DoS** en el servidor.

### Organizaci칩n del Exploit

Como se explic칩 anteriormente, para abusar de esta t칠cnica, es necesario que el **primer mensaje contrabandeado** en el servidor **requiera mucho tiempo para ser procesado**.

Esta **petici칩n que consume tiempo es suficiente** si solo queremos **intentar robar la respuesta de la v칤ctima.** Pero si quieres realizar un exploit m치s complejo, esta ser치 una estructura com칰n para el exploit.

Primero, la **petici칩n inicial** abusando del **HTTP Request Smuggling**, luego la **petici칩n que consume tiempo** y luego **1 o m치s peticiones de payload** cuyas respuestas ser치n enviadas a las v칤ctimas.

## Abusando de la Desincronizaci칩n de la Cola de Respuestas HTTP

### Capturando las peticiones de otros usuarios <a href="#capturando-las-peticiones-de-otros-usuarios" id="capturando-las-peticiones-de-otros-usuarios"></a>

Al igual que con los payloads conocidos de HTTP Request Smuggling, puedes **robar la petici칩n de la v칤ctima** con una diferencia importante: En este caso solo necesitas **enviar contenido para que se refleje en la respuesta**, **no se necesita almacenamiento persistente**.

Primero, el atacante env칤a un payload que contiene una **petici칩n POST final con el par치metro reflejado** al final y un Content-Length grande

![](<../.gitbook/assets/image (625).png>)

Luego, una vez que la **petici칩n inicial** (azul) fue **procesada** y **mientras** la **somnolienta** est치 siendo procesada (amarillo) la **siguiente petici칩n que llega de una v칤ctima** va a ser **a침adida en la cola justo despu칠s del par치metro reflejado**:

![](<../.gitbook/assets/image (634) (1).png>)

Luego, la **v칤ctima** **recibir치** la **respuesta a la petici칩n somnolienta** y si mientras tanto el **atacante** **envi칩** **otra** **petici칩n**, la **respuesta del contenido reflejado ser치 enviada a 칠l**.

## Desincronizaci칩n de Respuestas

Hasta este punto, hemos aprendido c칩mo abusar de ataques de HTTP Request Smuggling para **controlar** la **petici칩n** **cuya** **respuesta** un **cliente** va a **recibir** y c칩mo puedes luego **robar la respuesta que estaba destinada para la v칤ctima**.

Pero a칰n es posible **desincronizar a칰n m치s** las respuestas.

Hay peticiones interesantes como la petici칩n **HEAD** que est치n especificadas para no tener **ning칰n contenido dentro del cuerpo de la respuesta** y que deber칤an (deben) **contener el Content-Length** de la petici칩n como **si fuera una petici칩n GET**.

Por lo tanto, si un atacante **inyecta** una petici칩n **HEAD**, como en estas im치genes:

![](<../.gitbook/assets/image (626).png>)

Entonces, **una vez que la azul es respondida al atacante**, la siguiente petici칩n de la v칤ctima va a ser introducida en la cola:

![](<../.gitbook/assets/image (651) (1) (1) (1) (1) (1) (1).png>)

Luego, la **v칤ctima** **recibir치** la **respuesta** de la petici칩n **HEAD**, la cual **va a contener un Content-Length pero ning칰n contenido en absoluto**. Por lo tanto, el proxy **no enviar치 esta respuesta** a la v칤ctima, sino que **esperar치** por alg칰n **contenido**, que en realidad va a ser **respuesta a la petici칩n amarilla** (tambi칠n inyectada por el atacante):

![](<../.gitbook/assets/image (627) (1).png>)

### Confusi칩n de Contenido

Siguiendo el ejemplo anterior, sabiendo que puedes **controlar el cuerpo** de la petici칩n cuya respuesta va a recibir la v칤ctima y que una **respuesta HEAD** usualmente contiene en sus encabezados el **Content-Type y el Content-Length**, puedes **enviar una petici칩n como la siguiente** para **causar XSS** en la v칤ctima sin que la p치gina sea vulnerable a XSS:

![](<../.gitbook/assets/image (654) (1) (1) (1) (1).png>)

### Envenenamiento de Cach칠

Abusando del ataque de desincronizaci칩n de respuesta y Confusi칩n de Contenido comentado anteriormente, **si la cach칠 almacena la respuesta a la petici칩n realizada por la v칤ctima y esta respuesta es una inyectada causando un XSS, entonces la cach칠 est치 envenenada**.

Petici칩n maliciosa que contiene el payload de XSS:

![](<../.gitbook/assets/image (644) (1).png>)

Respuesta maliciosa a la v칤ctima que contiene el encabezado que indica a la cach칠 almacenar la respuesta:

![](<../.gitbook/assets/image (629) (1).png>)

{% hint style="warning" %}
Nota que en este caso si el **"v칤ctima" es el atacante** ahora puede realizar **envenenamiento de cach칠 en URLs arbitrarias** ya que puede **controlar la URL que va a ser almacenada** con la respuesta maliciosa.
{% endhint %}

### Enga침o de Cach칠 Web

Este ataque es similar al anterior, pero **en lugar de inyectar un payload dentro de la cach칠, el atacante estar치 almacenando informaci칩n de la v칤ctima dentro de la cach칠:**

![](<../.gitbook/assets/image (643) (1) (1).png>)

### Divisi칩n de Respuesta

El **objetivo** de este ataque es abusar nuevamente de la **desincronizaci칩n de respuesta** para **hacer que el proxy env칤e una respuesta 100% generada por el atacante**.

Para lograr esto, el atacante necesita encontrar un punto final de la aplicaci칩n web que est칠 **reflejando algunos valores dentro de la respuesta** y **conocer la longitud del contenido de la respuesta HEAD**.

Enviar치n un **exploit** como:

![](<../.gitbook/assets/image (649) (1) (1) (1).png>)

Despu칠s de que la primera petici칩n se resuelve y se env칤a de vuelta al atacante, la **petici칩n de la v칤ctima se a침ade a la cola**:

![](<../.gitbook/assets/image (661) (1) (1) (1).png>)

La v칤ctima recibir치 como respuesta la **respuesta HEAD + el contenido de la segunda respuesta de la petici칩n (conteniendo parte de los datos reflejados):**

![](<../.gitbook/assets/image (633) (1).png>)

Sin embargo, nota c칩mo los **datos reflejados ten칤an un tama침o de acuerdo con el Content-Length** de la **respuesta HEAD** que **gener칩 una respuesta HTTP v치lida en la cola de respuesta**.

Por lo tanto, la **siguiente petici칩n de la segunda v칤ctima** estar치 **recibiendo** como **respuesta algo completamente creado por el atacante**. Como la respuesta es completamente creada por el atacante, tambi칠n puede **hacer que el proxy almacene la respuesta en la cach칠**.

## Referencias

* No olvides revisar este video que explica todas estas t칠cnicas muy bien: [https://www.youtube.com/watch?v=suxDcYViwao\&t=1343s](https://www.youtube.com/watch?v=suxDcYViwao\&t=1343s)

<details>

<summary><strong>Aprende hacking en AWS de cero a h칠roe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver a tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** revisa los [**PLANES DE SUSCRIPCI칍N**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci칩n de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **칔nete al** 游눫 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s칤gueme** en **Twitter** 游냕 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de GitHub de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
