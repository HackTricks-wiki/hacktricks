# HTTP Response Smuggling / Desync

<details>

<summary><strong>Aprende a hackear AWS desde cero hasta convertirte en un experto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Experto en Equipos Rojos de AWS de HackTricks)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si deseas ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF**, ¬°Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Obt√©n la [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

**La t√©cnica de este post fue tomada del video: [https://www.youtube.com/watch?v=suxDcYViwao\&t=1343s](https://www.youtube.com/watch?v=suxDcYViwao\&t=1343s)**

## Desincronizaci√≥n de la Cola de Solicitudes HTTP

En primer lugar, esta t√©cnica **abusa de una vulnerabilidad de Desincronizaci√≥n de Solicitudes HTTP**, por lo que necesitas saber qu√© es:

La **principal** **diferencia** entre esta t√©cnica y una Desincronizaci√≥n de Solicitudes HTTP com√∫n es que **en lugar de atacar la solicitud de la v√≠ctima agregando un prefijo a la misma**, vamos a **filtrar o modificar la respuesta que recibe la v√≠ctima**. Esto se logra enviando 2 solicitudes completas para desincronizar la cola de respuestas de los proxies, en lugar de enviar 1 solicitud y media para abusar de la Desincronizaci√≥n de Solicitudes HTTP.

Esto se debe a que vamos a poder **desincronizar la cola de respuestas** para que la **respuesta** de la **solicitud leg√≠tima de la v√≠ctima se env√≠e al atacante**, o **inyectando contenido controlado por el atacante en la respuesta a la v√≠ctima**.

### Desincronizaci√≥n de Pipelining HTTP

HTTP/1.1 permite solicitar **diferentes recursos sin necesidad de esperar los anteriores**. Por lo tanto, si hay un **proxy** en el **medio**, es tarea de los proxies **mantener una coincidencia sincronizada de las solicitudes enviadas al backend y las respuestas que provienen de √©l**.

Sin embargo, hay un problema al desincronizar la cola de respuestas. Si un atacante env√≠a un ataque de Desincronizaci√≥n de Respuestas HTTP y las respuestas a la **solicitud inicial y la solicitada se responden inmediatamente**, la respuesta solicitada no se insertar√° en la cola de respuestas de la v√≠ctima, sino que **se descartar√° como un error**.

![](<../.gitbook/assets/image (635) (1) (1) (1).png>)

Por lo tanto, es necesario que la **solicitud filtrada** **tome m√°s tiempo en procesarse** dentro del servidor backend. Por lo tanto, cuando la solicitud filtrada se procese, la comunicaci√≥n con el atacante habr√° terminado.

Si en esta situaci√≥n espec√≠fica un **atacante env√≠a una solicitud** y la **solicitud filtrada se responde antes** que la solicitud leg√≠tima, la **respuesta filtrada se enviar√° a la v√≠ctima**. Por lo tanto, el atacante estar√° **controlando la solicitud "realizada" por la v√≠ctima**.

Adem√°s, si el **atacante luego realiza una solicitud** y la **respuesta leg√≠tima** a la **solicitud de la v√≠ctima se responde** **antes** que la solicitud del atacante. La **respuesta a la v√≠ctima se enviar√° al atacante**, **robando** la respuesta a la v√≠ctima (que puede contener, por ejemplo, el encabezado **Set-Cookie**).

![](<../.gitbook/assets/image (658) (1).png>)

![](<../.gitbook/assets/image (655) (1) (1) (1).png>)

### M√∫ltiples Inyecciones Anidadas

Otra **diferencia interesante** con la Desincronizaci√≥n de Solicitudes HTTP com√∫n es que, en un ataque de desincronizaci√≥n com√∫n, el **objetivo** es **modificar el inicio de la solicitud de la v√≠ctima** para que realice una acci√≥n inesperada. En un **ataque de desincronizaci√≥n de respuestas HTTP**, al **enviar solicitudes completas**, puedes **inyectar en una carga √∫til decenas de respuestas** que **desincronizar√°n a decenas de usuarios** que estar√°n **recibiendo** las **respuestas** **inyectadas**.

Adem√°s de poder **distribuir m√°s f√°cilmente decenas de exploits** entre usuarios leg√≠timos, esto tambi√©n podr√≠a usarse para causar una **denegaci√≥n de servicio** en el servidor.

### Organizaci√≥n de Exploits

Como se explic√≥ anteriormente, para abusar de esta t√©cnica, es necesario que el **primer mensaje filtrado** en el servidor **requiera mucho tiempo para procesarse**.

Esta **solicitud que consume tiempo es suficiente** si solo queremos **intentar robar la respuesta de las v√≠ctimas**. Pero si deseas realizar un exploit m√°s complejo, esta ser√° una estructura com√∫n para el exploit.

Primero la **solicitud inicial** abusando de la **Desincronizaci√≥n de Solicitudes HTTP**, luego la **solicitud que consume tiempo** y luego **1 o m√°s solicitudes de carga √∫til** cuyas respuestas se enviar√°n a las v√≠ctimas.

## Abusando de la Desincronizaci√≥n de la Cola de Respuestas HTTP

### Capturando las solicitudes de otros usuarios <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

Al igual que con las cargas √∫tiles conocidas de Desincronizaci√≥n de Solicitudes HTTP, puedes **robar la solicitud de las v√≠ctimas** con una diferencia importante: En este caso, solo necesitas que el **contenido enviado se refleje en la respuesta**, **no se necesita almacenamiento persistente**.

Primero, el atacante env√≠a una carga √∫til que contiene una **solicitud POST final con el par√°metro reflejado** al final y un largo Content-Length

![](<../.gitbook/assets/image (625).png>)

Luego, una vez que la **solicitud inicial** (azul) fue **procesada** y **mientras** la **solicitud lenta** se est√° procesando (amarilla), la **pr√≥xima solicitud que llega de una v√≠ctima** se va a **agregar en la cola justo despu√©s del par√°metro reflejado**:

![](<../.gitbook/assets/image (634) (1).png>)

Entonces, la **v√≠ctima** **recibir√°** la **respuesta a la solicitud lenta** y si en ese momento el **atacante** **env√≠a** **otra** **solicitud**, la **respuesta de la solicitud de contenido reflejado se le enviar√°**.

## Desincronizaci√≥n de Respuestas

Hasta este punto, hemos aprendido c√≥mo abusar de los ataques de Desincronizaci√≥n de Solicitudes HTTP para **controlar** la **solicitud** **cuya** **respuesta** un **cliente** va a **recibir** y c√≥mo luego puedes **robar la respuesta que estaba destinada a la v√≠ctima**.

Pero a√∫n es posible **desincronizar a√∫n m√°s** las respuestas.

Existen solicitudes interesantes como la solicitud **HEAD** que se especifican para no tener **ning√∫n contenido dentro del cuerpo de las respuestas** y que deben (deben) **contener el Content-Length** de la solicitud como **si fuera una solicitud GET**.

Por lo tanto, si un atacante **inyecta** una solicitud **HEAD**, como en estas im√°genes:

![](<../.gitbook/assets/image (626).png>)

Entonces, **una vez que la azul es respondida al atacante**, la pr√≥xima solicitud de la v√≠ctima se introducir√° en la cola:

![](<../.gitbook/assets/image (651) (1) (1) (1) (1) (1) (1).png>)

Entonces, la **v√≠ctima** **recibir√°** la **respuesta** de la **solicitud HEAD**, que **va a contener un Content-Length pero sin contenido alguno**. Por lo tanto, el proxy **no enviar√° esta respuesta** a la v√≠ctima, sino que **esperar√°** alg√∫n **contenido**, que en realidad ser√° **la respuesta a la solicitud amarilla** (tambi√©n inyectada por el atacante):

![](<../.gitbook/assets/image (627) (1).png>)

### Confusi√≥n de Contenido

Siguiendo el ejemplo anterior, sabiendo que puedes **controlar el cuerpo** de la solicitud cuya respuesta va a recibir la v√≠ctima y que una **respuesta HEAD** **generalmente contiene en sus encabezados el Content-Type y el Content-Length**, puedes **enviar una solicitud como la siguiente** para **causar XSS** en la v√≠ctima sin que la p√°gina sea vulnerable a XSS:

![](<../.gitbook/assets/image (654) (1) (1) (1) (1).png>)

### Envenenamiento de Cach√©

Abusando del ataque de Confusi√≥n de Contenido de desincronizaci√≥n de respuestas comentado anteriormente, **si la cach√© almacena la respuesta a la solicitud realizada por la v√≠ctima y esta respuesta es una inyectada que causa un XSS, entonces la cach√© est√° envenenada**.

Solicitud maliciosa que contiene la carga √∫til de XSS:

![](<../.gitbook/assets/image (644) (1).png>)

Respuesta maliciosa a la v√≠ctima que contiene el encabezado que indica a la cach√© que almacene la respuesta:

![](<../.gitbook/assets/image (629) (1).png>)

{% hint style="warning" %}
Ten en cuenta que en este caso, si el **"v√≠ctima" es el atacante**, ahora puede realizar **envenenamiento de cach√© en URLs arbitrarias** ya que puede **controlar la URL que se va a cachear** con la respuesta maliciosa.
{% endhint %}

### Decepci√≥n de Cach√© Web

Este ataque es similar al anterior, pero **en lugar de inyectar una carga √∫til dentro de la cach√©, el atacante almacenar√° informaci√≥n de la v√≠ctima dentro de la cach√©:**

![](<../.gitbook/assets/image (643) (1) (1).png>)

### Divisi√≥n de Respuestas

El **objetivo** de este ataque es abusar nuevamente de la **desincronizaci√≥n de respuestas** para **hacer que el proxy env√≠e una respuesta 100% generada por el atacante**.

Para lograr esto, el atacante necesita encontrar un punto final de la aplicaci√≥n web que **refleje algunos valores dentro de la respuesta** y **conocer la longitud del contenido de la respuesta HEAD**.

Enviar un **exploit** como:

![](<../.gitbook/assets/image (649) (1) (1) (1).png>)

Despu√©s de que la primera solicitud se resuelva y se env√≠e de vuelta al atacante, la **solicitud de la v√≠ctima se agrega a la cola**:

![](<../.gitbook/assets/image (661) (1) (1) (1).png>)

La v√≠ctima recibir√° como respuesta la **respuesta HEAD + el contenido de la respuesta de la segunda solicitud (que contiene parte de los datos reflejados):**

![](<../.gitbook/assets/image (633) (1).png>)

Sin embargo, observa c√≥mo los **datos reflejados ten√≠an un tama√±o de acuerdo con el Content-Length** de la **respuesta HEAD** que **gener√≥ una respuesta HTTP v√°lida en la cola de respuestas**.

Por lo tanto, la **pr√≥xima solicitud del segundo usuario** recibir√° como **respuesta algo completamente creado por el atacante**. Como la respuesta est√° completamente creada por el atacante, tambi√©n puede **hacer que el proxy almacene en cach√© la respuesta**.
