# Metodolog√≠a de Pentesting de Extensiones de Navegador

<details>

<summary><strong>Aprende hacking en AWS de cero a h√©roe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver a tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF**, consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **sigue** a **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de github de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Informaci√≥n B√°sica

Las extensiones de navegador est√°n escritas en JavaScript y son cargadas por el navegador en segundo plano. Tienen su propio [DOM](https://www.w3schools.com/js/js_htmldom.asp) pero pueden interactuar con el DOM de otros sitios. Esto significa que pueden comprometer la confidencialidad, integridad y disponibilidad (CIA) de otros sitios.

## Componentes Principales

El dise√±o de las extensiones se visualiza mejor y consta de tres componentes. Veamos cada componente en detalle.

<figure><img src="../../.gitbook/assets/image.png" alt=""><figcaption><p><a href="http://webblaze.cs.berkeley.edu/papers/Extensions.pdf">http://webblaze.cs.berkeley.edu/papers/Extensions.pdf</a></p></figcaption></figure>

### **Scripts de Contenido**

Cada script de contenido tiene acceso directo al DOM de una **p√°gina web individual** y, por lo tanto, est√° expuesto a **entradas potencialmente maliciosas**. Sin embargo, el script de contenido no tiene permisos aparte de la capacidad de enviar mensajes al n√∫cleo de la extensi√≥n.

Para ver y depurar scripts de contenido en Chrome, puedes abrir el men√∫ de herramientas para desarrolladores de Chrome desde Opciones > M√°s herramientas > Herramientas para desarrolladores O (Presiona - Ctrl + Shift + I).

Con las herramientas para desarrolladores mostradas, haz clic en la pesta√±a **Source**, luego en la pesta√±a **Scripts de Contenido**. Aqu√≠ puedes ver los scripts de contenido en ejecuci√≥n de las diversas extensiones y establecer puntos de interrupci√≥n para monitorear el flujo de ejecuci√≥n. En nuestro caso, lo hemos mostrado a trav√©s de la extensi√≥n de navegador Wappalyzer.&#x20;

<figure><img src="../../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

### **N√∫cleo de la Extensi√≥n**

El n√∫cleo de la extensi√≥n contiene la mayor√≠a de los privilegios/accesos de la extensi√≥n, pero solo puede interactuar con el contenido web a trav√©s de [XMLHttpRequest](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest) y scripts de contenido. Adem√°s, el n√∫cleo de la extensi√≥n no tiene acceso directo a la m√°quina anfitriona.

### **Binario Nativo**

La extensi√≥n permite un binario nativo que puede **acceder a la m√°quina anfitriona con todos los privilegios del usuario.** El binario nativo interact√∫a con el n√∫cleo de la extensi√≥n a trav√©s de la interfaz de programaci√≥n de aplicaciones de plugins de Netscape est√°ndar ([NPAPI](https://en.wikipedia.org/wiki/NPAPI)) utilizada por Flash y otros complementos del navegador.

### L√≠mites

{% hint style="danger" %}
Para obtener los privilegios completos del usuario, un atacante debe convencer a la extensi√≥n de pasar una entrada maliciosa desde el script de contenido al n√∫cleo de la extensi√≥n y desde el n√∫cleo de la extensi√≥n al binario nativo.
{% endhint %}

Cada componente de la extensi√≥n est√° separado de los dem√°s por **fuertes l√≠mites protectores**. Cada componente se ejecuta en un **proceso del sistema operativo separado**. Los scripts de contenido y los n√∫cleos de las extensiones se ejecutan en **procesos de sandbox** a los que no pueden acceder la mayor√≠a de los servicios del sistema operativo. &#x20;

Adem√°s, los scripts de contenido est√°n separados de sus p√°ginas web asociadas al **ejecutarse en un mont√≥n de JavaScript separado**. El script de contenido y la p√°gina web tienen **acceso al mismo DOM subyacente**, pero los dos **nunca intercambian punteros de JavaScript**, evitando la fuga de funcionalidad de JavaScript.

## **`manifest.json`**

Una extensi√≥n de Chrome es simplemente una carpeta ZIP con una extensi√≥n de archivo [.crx](https://www.lifewire.com/crx-file-2620391). El n√∫cleo de la extensi√≥n es el archivo **`manifest.json`** en la ra√≠z de la carpeta, que especifica el dise√±o, permisos y otras opciones de configuraci√≥n.

Ejemplo:
```json
{
"manifest_version": 2,
"name": "My extension",
"version": "1.0",
"permissions": [
"storage"
],
"content_scripts": [
{
"js": [
"script.js"
],
"matches": [
"https://example.com/*",
"https://www.example.com/*"
],
"exclude_matches": ["*://*/*business*"],
}
],
"background": {
"scripts": [
"background.js"
]
},
"options_ui": {
"page": "options.html"
}
}
```
### `content_scripts`

Los scripts de contenido se **cargan** cada vez que el usuario **navega a una p√°gina que coincide**, en nuestro caso cualquier p√°gina que coincida con la expresi√≥n **`https://example.com/*`** y que no coincida con la expresi√≥n regular **`*://*/*/business*`**. Se ejecutan **como si fueran scripts propios de la p√°gina** y tienen acceso arbitrario al [Modelo de Objeto de Documento (DOM)](https://developer.mozilla.org/en-US/docs/Web/API/Document\_Object\_Model) de la p√°gina.
```json
"content_scripts": [
{
"js": [
"script.js"
],
"matches": [
"https://example.com/*",
"https://www.example.com/*"
],
"exclude_matches": ["*://*/*business*"],
}
],
```
Para incluir o excluir m√°s URLs tambi√©n es posible utilizar **`include_globs`** y **`exclude_globs`**.

Este es un ejemplo de un script de contenido que agregar√° un bot√≥n de explicaci√≥n a la p√°gina cuando [la API de almacenamiento](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/storage) para recuperar el valor de `message` del almacenamiento de la extensi√≥n.
```js
chrome.storage.local.get("message", result =>
{
let div = document.createElement("div");
div.innerHTML = result.message + " <button>Explain</button>";
div.querySelector("button").addEventListener("click", () =>
{
chrome.runtime.sendMessage("explain");
});
document.body.appendChild(div);
});
```
<figure><img src="../../.gitbook/assets/image (7).png" alt=""><figcaption></figcaption></figure>

Cuando se hace clic en este bot√≥n, el **content script utiliza** [**runtime.sendMessage() API**](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/runtime/sendMessage) **para enviar un mensaje a las p√°ginas de la extensi√≥n**. Esto se debe a que un content script solo tiene acceso directo a un pu√±ado de APIs como `storage`. Todo lo dem√°s debe ser realizado por las p√°ginas de la extensi√≥n a las que los content scripts pueden enviar mensajes.

{% hint style="warning" %}
Las **capacidades del content script** var√≠an ligeramente dependiendo del navegador. Para navegadores basados en Chromium puedes encontrar la lista en la [documentaci√≥n de Chrome Developers](https://developer.chrome.com/docs/extensions/mv3/content\_scripts/#capabilities), para Firefox [MDN](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Content\_scripts#webextension\_apis) es la fuente definitiva.\
Recuerda que el Content Script tambi√©n puede **comunicarse con los background scripts** para que realicen acciones y env√≠en la respuesta.
{% endhint %}

### Content scripts inyectados

{% hint style="success" %}
Ten en cuenta que los **Content Scripts no son obligatorios**, ya que tambi√©n es posible **inyectar** scripts **din√°micamente** y **program√°ticamente** en p√°ginas web a trav√©s de **`tabs.executeScript`**. Esto en realidad proporciona controles m√°s **granulares**.
{% endhint %}

Para inyectar un content script program√°ticamente, tu extensi√≥n necesita [permisos de host](https://developer.chrome.com/docs/extensions/reference/permissions) para la p√°gina en la que est√° intentando inyectar scripts. Los permisos de host pueden ser otorgados **solicit√°ndolos** como parte del manifiesto de tu extensi√≥n o temporalmente a trav√©s de [**activeTab**](https://developer.chrome.com/docs/extensions/reference/manifest/activeTab)**.**

#### Ejemplo de extensi√≥n basada en activeTab

{% code title="manifest.json" %}
```json
{
"name": "My extension",
...
"permissions": [
"activeTab",
"scripting"
],
"background": {
"service_worker": "background.js"
},
"action": {
"default_title": "Action Button"
}
}
```
* **Inyectar un archivo JS al hacer clic:**
```javascript
// content-script.js
document.body.style.backgroundColor = "orange";

//service-worker.js - Inject the JS file
chrome.action.onClicked.addListener((tab) => {
chrome.scripting.executeScript({
target: { tabId: tab.id },
files: ["content-script.js"]
});
});
```
* **Inyectar una funci√≥n** al hacer clic:
```javascript
//service-worker.js - Inject a function
function injectedFunction() {
document.body.style.backgroundColor = "orange";
}

chrome.action.onClicked.addListener((tab) => {
chrome.scripting.executeScript({
target : {tabId : tab.id},
func : injectedFunction,
});
});
```
#### Ejemplo con permisos de scripting
```javascript
// service-workser.js
chrome.scripting.registerContentScripts([{
id : "test",
matches : [ "https://*.nytimes.com/*" ],
excludeMatches : [ "*://*/*business*" ],
js : [ "contentScript.js" ],
}]);

// ANother example
chrome.tabs.executeScript(tabId, { file: "content_script.js" });
```
Para incluir o excluir m√°s URLs tambi√©n es posible utilizar **`include_globs`** y **`exclude_globs`**.

### Scripts de Contenido `run_at`

El campo `run_at` controla **cu√°ndo se inyectan los archivos JavaScript en la p√°gina web**. El valor preferido y predeterminado es `"document_idle"`.

Los valores posibles son:

* **`document_idle`**: Siempre que sea posible
* **`document_start`**: Despu√©s de cualquier archivo de `css`, pero antes de que se construya cualquier otro DOM o se ejecute cualquier otro script.
* **`document_end`**: Inmediatamente despu√©s de que el DOM est√© completo, pero antes de que se carguen subrecursos como im√°genes y marcos.

#### A trav√©s de `manifest.json`
```json
{
"name": "My extension",
...
"content_scripts": [
{
"matches": ["https://*.nytimes.com/*"],
"run_at": "document_idle",
"js": ["contentScript.js"]
}
],
...
}

```
A trav√©s de **`service-worker.js`**
```javascript
chrome.scripting.registerContentScripts([{
id : "test",
matches : [ "https://*.nytimes.com/*" ],
runAt : "document_idle",
js : [ "contentScript.js" ],
}]);
```
### `fondo`

Cuando los scripts de contenido env√≠an un mensaje, su destino es la **p√°gina de fondo**. La p√°gina de fondo es una p√°gina especial que est√° **siempre presente** a menos que se especifique lo contrario en el manifiesto de la extensi√≥n. Es invisible para el usuario, a pesar de ser una p√°gina regular con su propio DOM y todo. Su funci√≥n es t√≠picamente coordinar todas las dem√°s partes de la extensi√≥n.

{% hint style="success" %}
Si una p√°gina de fondo no se declara expl√≠citamente, el navegador generar√° una **autom√°ticamente** de manera √∫til y se asegurar√° de que todos los **scripts de fondo declarados est√©n cargados** en ella, como en el ejemplo anterior de manifest.json.
{% endhint %}

Ejemplo de script de fondo:
```js
chrome.runtime.onMessage.addListener((request, sender, sendResponse) =>
{
if (request == "explain")
{
chrome.tabs.create({ url: "https://example.net/explanation" });
}
})
```
Utiliza la [API runtime.onMessage](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/runtime/onMessage) para escuchar mensajes. Cuando se recibe un mensaje de `"explain"`, utiliza la [API de tabs](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/tabs) para abrir una p√°gina en una nueva pesta√±a.

### P√°ginas de opciones y otras

Las extensiones de navegador pueden contener varios tipos de p√°ginas:

* **P√°ginas de acci√≥n** se muestran en un **men√∫ desplegable cuando se hace clic en el icono de la extensi√≥n**.
* P√°ginas que la extensi√≥n **cargar√° en una nueva pesta√±a**.
* **P√°ginas de opciones**: Esta p√°gina se muestra encima de la extensi√≥n al hacer clic. En el manifiesto anterior, en mi caso, pude acceder a esta p√°gina en `chrome://extensions/?options=fadlhnelkbeojnebcbkacjilhnbjfjca` o haciendo clic:

<figure><img src="../../.gitbook/assets/image (8).png" alt="" width="375"><figcaption></figcaption></figure>

A diferencia de la p√°gina de fondo, estas p√°ginas no son persistentes, sino que se cargan cuando es necesario. Sin embargo, todas ellas pueden **recibir mensajes de los scripts de contenido**. Y todas tienen **acceso completo a las APIs espec√≠ficas de la extensi√≥n**, en la medida en que lo permitan los permisos de la extensi√≥n.

En conjunto, los contextos relevantes para las extensiones de navegador se ven as√≠:

<figure><img src="../../.gitbook/assets/image (9).png" alt="" width="563"><figcaption></figcaption></figure>

### `permissions` & `host_permissions`

**`permissions`** y **`host_permissions`** son entradas del `manifest.json` que indicar√°n **qu√© permisos** tiene la extensi√≥n de navegador (almacenamiento, ubicaci√≥n...) y en **qu√© p√°ginas web**.

Como las extensiones de navegador pueden ser tan **privilegiadas**, una maliciosa o una que haya sido comprometida podr√≠a permitir al atacante **diferentes medios para robar informaci√≥n sensible y espiar al usuario**.

Revisa c√≥mo funcionan estos ajustes y c√≥mo podr√≠an ser abusados en:

{% content-ref url="browext-permissions-and-host_permissions.md" %}
[browext-permissions-and-host\_permissions.md](browext-permissions-and-host\_permissions.md)
{% endcontent-ref %}

### `content_security_policy`

Una **pol√≠tica de seguridad de contenido** tambi√©n puede ser declarada dentro del `manifest.json`. Si hay una definida, podr√≠a ser **vulnerable**.

La configuraci√≥n predeterminada para las p√°ginas de extensiones de navegador es bastante restrictiva:
```bash
script-src 'self'; object-src 'self';
```
Para obtener m√°s informaci√≥n sobre CSP y posibles bypasses, consulta:

{% content-ref url="../content-security-policy-csp-bypass/" %}
[content-security-policy-csp-bypass](../content-security-policy-csp-bypass/)
{% endcontent-ref %}

### `web_accessible_resources`

para que una p√°gina web acceda a una p√°gina de una Extensi√≥n de Navegador, una p√°gina `.html` por ejemplo, esta p√°gina debe estar mencionada en el campo **`web_accessible_resources`** del `manifest.json`.\
Por ejemplo:
```javascript
{
...
"web_accessible_resources": [
{
"resources": [ "images/*.png" ],
"matches": [ "https://example.com/*" ]
},
{
"resources": [ "fonts/*.woff" ],
"matches": [ "https://example.com/*" ]
}
],
...
}
```
Estas p√°ginas son accesibles en URL como:
```
chrome-extension://<extension-id>/message.html
```
En las extensiones p√∫blicas el **extension-id es accesible**:

<figure><img src="../../.gitbook/assets/image (722).png" alt="" width="375"><figcaption></figcaption></figure>

Sin embargo, si se utiliza el par√°metro `manifest.json` **`use_dynamic_url`**, este **id puede ser din√°mico**.

El poder acceder a estas p√°ginas las hace **potencialmente vulnerables a ClickJacking**:

{% content-ref url="browext-clickjacking.md" %}
[browext-clickjacking.md](browext-clickjacking.md)
{% endcontent-ref %}

{% hint style="success" %}
Permitir que estas p√°ginas solo se carguen por la extensi√≥n y no por URLs aleatorias podr√≠a prevenir ataques de ClickJacking.
{% endhint %}

### `externally_connectable`

Seg√∫n los [**documentos**](https://developer.chrome.com/docs/extensions/reference/manifest/externally-connectable), la propiedad del manifiesto `"externally_connectable"` declara **qu√© extensiones y p√°ginas web pueden conectarse** a tu extensi√≥n a trav√©s de [runtime.connect](https://developer.chrome.com/docs/extensions/reference/runtime#method-connect) y [runtime.sendMessage](https://developer.chrome.com/docs/extensions/reference/runtime#method-sendMessage).

* Si la clave **`externally_connectable`** **no** est√° declarada en el manifiesto de tu extensi√≥n o est√° declarada como **`"ids": ["*"]`**, **todas las extensiones pueden conectarse, pero ninguna p√°gina web puede hacerlo**.
* Si se especifican **IDs espec√≠ficos**, como en `"ids": ["aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"]`, **solo esas aplicaciones** pueden conectarse.
* Si se especifican **coincidencias**, esas aplicaciones web podr√°n conectarse:
```json
"matches": [
"https://*.google.com/*",
"*://*.chromium.org/*",
```
* Si se especifica como vac√≠o: **`"externally_connectable": {}`**, ninguna app o web podr√° conectarse.

Cuantas **menos extensiones y URLs** se indiquen aqu√≠, **menor ser√° la superficie de ataque**.

{% hint style="danger" %}
Si una p√°gina web **vulnerable a XSS o takeover** se indica en **`externally_connectable`**, un atacante podr√° **enviar mensajes directamente al script de fondo**, evitando completamente el Content Script y su CSP.

Por lo tanto, esto es un **bypass muy poderoso**.
{% endhint %}

## Comunicaci√≥n Web **‚ÜîÔ∏é** Content Script

Aunque los entornos de ejecuci√≥n de **los content scripts y las p√°ginas** que los alojan est√°n **aislados** entre s√≠, **comparten acceso al DOM de la p√°gina**. Si la p√°gina desea comunicarse con el content script, o con la extensi√≥n a trav√©s del content script, debe hacerlo a trav√©s del **DOM compartido**.

### Post Messages

{% code title="content-script.js" %}
```javascript
var port = chrome.runtime.connect();

window.addEventListener("message", (event) => {
// We only accept messages from ourselves
if (event.source !== window) {
return;
}

if (event.data.type && (event.data.type === "FROM_PAGE")) {
console.log("Content script received: " + event.data.text);
port.postMessage(event.data.text);
}
}, false);
```
```markdown
{% endcode %}

{% code title="example.js" %}
```
```javascript
document.getElementById("theButton").addEventListener("click", () => {
window.postMessage(
{type : "FROM_PAGE", text : "Hello from the webpage!"}, "*");
}, false);
```
Una comunicaci√≥n segura de Post Message debe verificar la autenticidad del mensaje recibido, esto se puede hacer comprobando:

* **`event.isTrusted`**: Esto es verdadero solo si el evento fue desencadenado por una acci√≥n del usuario
* El script de contenido podr√≠a estar esperando un mensaje solo si el usuario realiza alguna acci√≥n
* **dominio de origen**: Se puede verificar contra una lista de dominios permitidos.
* Si se usa una expresi√≥n regular, tenga mucho cuidado
* **Fuente**: `received_message.source !== window` se puede usar para verificar si el mensaje fue **de la misma ventana** donde el Script de Contenido est√° escuchando.

Las verificaciones anteriores, incluso si se realizan, podr√≠an ser vulnerables, as√≠ que revise en la siguiente p√°gina **posibles bypasses de Post Message**:

{% content-ref url="../postmessage-vulnerabilities/" %}
[postmessage-vulnerabilities](../postmessage-vulnerabilities/)
{% endcontent-ref %}

### Iframe

Otra posible forma de comunicaci√≥n podr√≠a ser a trav√©s de **URLs de Iframe**, puede encontrar un ejemplo en:

{% content-ref url="browext-xss-example.md" %}
[browext-xss-example.md](browext-xss-example.md)
{% endcontent-ref %}

### DOM

Esto no es "exactamente" una forma de comunicaci√≥n, pero **la web y el script de contenido tendr√°n acceso al DOM web**. Por lo tanto, si el **script de contenido** est√° leyendo alguna informaci√≥n de √©l, **confiando en el DOM web**, la web podr√≠a **modificar estos datos** (porque la web no deber√≠a ser confiable, o porque la web es vulnerable a XSS) y **comprometer el Script de Contenido**.

Tambi√©n puede encontrar un ejemplo de un **XSS basado en DOM para comprometer una extensi√≥n de navegador** en:

{% content-ref url="browext-xss-example.md" %}
[browext-xss-example.md](browext-xss-example.md)
{% endcontent-ref %}

## Informaci√≥n Sensible en Memoria/C√≥digo

Si una Extensi√≥n de Navegador almacena **informaci√≥n sensible dentro de su memoria**, esta podr√≠a ser **volcada** (especialmente en m√°quinas Windows) y **buscada** para obtener esta informaci√≥n.

Por lo tanto, la memoria de la Extensi√≥n de Navegador **no debe considerarse segura** y **no se debe almacenar informaci√≥n sensible**, como credenciales o frases mnemot√©cnicas.

Por supuesto, **no coloque informaci√≥n sensible en el c√≥digo**, ya que ser√° **p√∫blica**.

## Comunicaci√≥n Script de Contenido **‚ÜîÔ∏é** Script de Fondo

Un Script de Contenido puede usar las funciones [**runtime.sendMessage()**](https://developer.chrome.com/docs/extensions/reference/runtime#method-sendMessage) **o** [**tabs.sendMessage()**](https://developer.chrome.com/docs/extensions/reference/tabs#method-sendMessage) para enviar un mensaje **serializable en JSON de un solo uso**.

Para manejar la **respuesta**, use la **Promise** devuelta. Aunque, por compatibilidad hacia atr√°s, todav√≠a puede pasar un **callback** como √∫ltimo argumento.

Enviar una solicitud desde un **script de contenido** se ve as√≠:
```javascript
(async () => {
const response = await chrome.runtime.sendMessage({greeting: "hello"});
// do something with response here, not outside the function
console.log(response);
})();
```
Enviando una solicitud desde la **extensi√≥n** (usualmente un **script de fondo**) a un script de contenido es similar, excepto que necesitas especificar a qu√© pesta√±a enviarlo. Este ejemplo demuestra c√≥mo enviar un mensaje al script de contenido en la pesta√±a seleccionada.
```javascript
(async () => {
const [tab] = await chrome.tabs.query({active: true, lastFocusedWindow: true});
const response = await chrome.tabs.sendMessage(tab.id, {greeting: "hello"});
// do something with response here, not outside the function
console.log(response);
})();
```
En el **extremo receptor**, necesitas configurar un [**runtime.onMessage**](https://developer.chrome.com/docs/extensions/reference/runtime#event-onMessage) **event listener** para manejar el mensaje. Esto se ve igual desde un script de contenido o una p√°gina de extensi√≥n.
```javascript
chrome.runtime.onMessage.addListener(
function(request, sender, sendResponse) {
console.log(sender.tab ?
"from a content script:" + sender.tab.url :
"from the extension");
if (request.greeting === "hello")
sendResponse({farewell: "goodbye"});
}
);
```
En el ejemplo anterior, **`sendResponse()`** fue llamado de manera sincr√≥nica. Si quieres usar `sendResponse()` de forma **asincr√≥nica**, a√±ade `return true;` al manejador de eventos `onMessage`.

> Si m√∫ltiples p√°ginas est√°n escuchando eventos `onMessage`, **solo la primera en llamar a `sendResponse()`** para un evento particular tendr√° √©xito al enviar la respuesta. Todas las dem√°s respuestas a ese evento ser√°n ignoradas.

Para extensiones nuevas deber√≠as preferir promesas sobre callbacks. Si est√°s usando callbacks, el callback `sendResponse()` solo es v√°lido si se usa de manera sincr√≥nica, o si el manejador de eventos retorna `true` para indicar que responder√° de forma asincr√≥nica. El callback de la funci√≥n `sendMessage()` ser√° invocado autom√°ticamente si ning√∫n manejador retorna true o si el callback `sendResponse()` es recolectado por el recolector de basura.

## Cargando una Extensi√≥n en el Navegador

1. **Descarga** la Extensi√≥n del Navegador y descompr√≠mela
2. Ve a **`chrome://extensions/`** y **activa** el `Modo de Desarrollador`
3. Haz clic en el bot√≥n **`Cargar descomprimido`**

En **Firefox** ve a **`about:debugging#/runtime/this-firefox`** y haz clic en el bot√≥n **`Cargar Complemento Temporal`**.

## Obteniendo el c√≥digo fuente de la tienda

Desde [**aqu√≠**](https://gist.github.com/paulirish/78d6c1406c901be02c2d):

### Opci√≥n 1: Descarga de la extensi√≥n en l√≠nea de comandos como zip y extrae

{% code overflow="wrap" %}
```bash
extension_id=jifpbeccnghkjeaalbbjmodiffmgedin   # change this ID
curl -L -o "$extension_id.zip" "https://clients2.google.com/service/update2/crx?response=redirect&os=mac&arch=x86-64&nacl_arch=x86-64&prod=chromecrx&prodchannel=stable&prodversion=44.0.2403.130&x=id%3D$extension_id%26uc"
unzip -d "$extension_id-source" "$extension_id.zip"
```
### Opci√≥n 2: Utilizar el sitio web de CRX Viewer

[https://robwu.nl/crxviewer/](https://robwu.nl/crxviewer/)

### Opci√≥n 3: Utilizar la extensi√≥n CRX Viewer

La [Chrome extension source viewer](https://chrome.google.com/webstore/detail/chrome-extension-source-v/jifpbeccnghkjeaalbbjmodiffmgedin?hl=en) es de c√≥digo abierto ([repositorio en github](https://github.com/Rob--W/crxviewer)) y facilita mucho este proceso.

### Opci√≥n 3: Ver el c√≥digo fuente de una extensi√≥n instalada localmente

1. Encuentra el directorio de perfil local de Chrome. Abre `chrome://version/` y busca el campo "Ruta del perfil:". Abre esa carpeta.
2. Abre la subcarpeta `Extensions/`
3. Aqu√≠ est√°n todas tus extensiones, con c√≥digo fuente t√≠picamente legible.

#### Mapeo entre las IDs de extensiones instaladas localmente y sus nombres

* En `about:extensions`, activa el Modo de Desarrollador y ver√°s las IDs bajo cada entrada.
* Dentro de las carpetas `Extensions/`, el archivo manifest.json tiene un campo `name` legible.

## Lista de Verificaci√≥n para Auditor√≠a de Seguridad

Aunque las Extensiones de Navegador tienen una **superficie de ataque limitada**, algunas pueden contener **vulnerabilidades** o **posibles mejoras de endurecimiento**. Las m√°s comunes son:

* [ ] **Limitar** tanto como sea posible los **`permissions`** solicitados.
* [ ] **Limitar** tanto como sea posible los **`host_permissions`**.
* [ ] Usar una **fuerte** **`content_security_policy`**.
* [ ] **Limitar** tanto como sea posible el **`externally_connectable`**, si no se necesita ninguno y es posible, no dejarlo por defecto, especificar **`{}`**.
* [ ] Si se menciona aqu√≠ una **URL vulnerable a XSS o a toma de control**, un atacante podr√° **enviar mensajes directamente a los scripts de fondo**. Un bypass muy poderoso.
* [ ] **Limitar** tanto como sea posible los **`web_accessible_resources`**, incluso vac√≠os si es posible.
* [ ] Si **`web_accessible_resources`** no es ninguno, verificar la presencia de [**ClickJacking**](browext-clickjacking.md).
* [ ] Si ocurre alguna **comunicaci√≥n** desde la **extensi√≥n** a la **p√°gina web**, [**verificar vulnerabilidades de XSS**](browext-xss-example.md) causadas en la comunicaci√≥n.
* [ ] Si se utilizan Mensajes Post, verificar [**vulnerabilidades de Mensajes Post**](../postmessage-vulnerabilities/)**.**
* [ ] Si el **Script de Contenido accede a detalles del DOM**, verificar que no est√©n **introduciendo un XSS** si se **modifican** por la web.
* [ ] Poner especial √©nfasis si esta comunicaci√≥n tambi√©n est√° involucrada en la **comunicaci√≥n Script de Contenido -> Script de fondo**.
* [ ] **No se debe almacenar informaci√≥n sensible** dentro del c√≥digo de la Extensi√≥n de Navegador.
* [ ] **No se debe almacenar informaci√≥n sensible** dentro de la memoria de la Extensi√≥n de Navegador.

## Herramientas

### [**Tarnish**](https://thehackerblog.com/tarnish/)

* Extrae cualquier extensi√≥n de Chrome de un enlace proporcionado de la tienda web de Chrome.
* **Visualizador de [**manifest.json**](https://developer.chrome.com/extensions/manifest)**: simplemente muestra una versi√≥n en JSON bonificado del manifiesto de la extensi√≥n.
* **An√°lisis de Huellas Digitales**: Detecci√≥n de [web_accessible_resources](https://developer.chrome.com/extensions/manifest/web_accessible_resources) y generaci√≥n autom√°tica de JavaScript para la toma de huellas digitales de extensiones de Chrome.
* **An√°lisis Potencial de Clickjacking**: Detecci√≥n de p√°ginas HTML de extensi√≥n con la directiva [web_accessible_resources](https://developer.chrome.com/extensions/manifest/web_accessible_resources) establecida. Estas pueden ser potencialmente vulnerables a clickjacking dependiendo del prop√≥sito de las p√°ginas.
* **Visualizador de Advertencias de Permisos**: que muestra una lista de todas las advertencias de solicitud de permisos de Chrome que se mostrar√°n al usuario al intentar instalar la extensi√≥n.
* **Funciones Peligrosas**: muestra la ubicaci√≥n de funciones peligrosas que podr√≠an ser explotadas potencialmente por un atacante (por ejemplo, funciones como innerHTML, chrome.tabs.executeScript).
* **Puntos de Entrada**: muestra d√≥nde la extensi√≥n recibe entrada de usuario/externa. Esto es √∫til para entender la superficie de ataque de una extensi√≥n y buscar puntos potenciales para enviar datos maliciosamente elaborados a la extensi√≥n.
* Tanto el esc√°ner de Funciones Peligrosas como el de Puntos de Entrada tienen lo siguiente para sus alertas generadas:
  * Fragmento de c√≥digo relevante y l√≠nea que caus√≥ la alerta.
  * Descripci√≥n del problema.
  * Un bot√≥n "Ver Archivo" para ver el archivo fuente completo que contiene el c√≥digo.
  * La ruta del archivo alertado.
  * La URI completa de la extensi√≥n de Chrome del archivo alertado.
  * El tipo de archivo que es, como un script de P√°gina de Fondo, Script de Contenido, Acci√≥n del Navegador, etc.
  * Si la l√≠nea vulnerable est√° en un archivo JavaScript, las rutas de todas las p√°ginas donde est√° incluido, as√≠ como el tipo de estas p√°ginas y el estado de [web_accessible_resource](https://developer.chrome.com/extensions/manifest/web_accessible_resources).
* **Analizador de Pol√≠tica de Seguridad de Contenido (CSP) y verificador de bypass**: Esto se√±alar√° debilidades en la CSP de tu extensi√≥n y tambi√©n iluminar√° cualquier forma potencial de eludir tu CSP debido a CDNs en la lista blanca, etc.
* **Bibliotecas Vulnerables Conocidas**: Esto utiliza [Retire.js](https://retirejs.github.io/retire.js/) para verificar cualquier uso de bibliotecas de JavaScript conocidas por ser vulnerables.
* Descargar extensiones y versiones formateadas.
* Descargar la extensi√≥n original.
* Descargar una versi√≥n embellecida de la extensi√≥n (HTML y JavaScript autom√°ticamente bonificados).
* Cach√© autom√°tico de resultados de an√°lisis, realizar un an√°lisis de extensi√≥n tomar√° un buen tiempo la primera vez que se ejecute. Sin embargo, la segunda vez, asumiendo que la extensi√≥n no ha sido actualizada, ser√° casi instant√°nea debido a que los resultados est√°n en cach√©.
* URLs de Reportes Enlazables, enlaza f√°cilmente a alguien m√°s a un informe de extensi√≥n generado por tarnish.

### [Neto](https://github.com/elevenpaths/neto)

Neto es un paquete de Python 3 concebido para analizar y desentra√±ar caracter√≠sticas ocultas de plugins y extensiones de navegador para navegadores bien conocidos como Firefox y Chrome. Automatiza el proceso de descomprimir los archivos empaquetados para extraer estas caracter√≠sticas de recursos relevantes en una extensi√≥n como `manifest.json`, carpetas de localizaci√≥n o archivos fuente de Javascript y HTML.

## Referencias

* **Gracias a** [**@naivenom**](https://twitter.com/naivenom) **por la ayuda con esta metodolog√≠a**
* [https://www.cobalt.io/blog/introduction-to-chrome-browser-extension-security-testing](https://www.cobalt.io/blog/introduction-to-chrome-browser-extension-security-testing)
* [https://palant.info/2022/08/10/anatomy-of-a-basic-extension/](https://palant.info/2022/08/10/anatomy-of-a-basic-extension/)
* [https://palant.info/2022/08/24/attack-surface-of-extension-pages/](https://palant.info/2022/08/24/attack-surface-of-extension-pages/)
* [https://palant.info/2022/08/31/when-extension-pages-are-web-accessible/](https://palant.info/2022/08/31/when-extension-pages-are-web-accessible/)
* [https://help.passbolt.com/assets/files/PBL-02-report.pdf](https://help.passbolt.com/assets/files/PBL-02-report.pdf)
* [https://developer.chrome.com/docs/extensions/develop/concepts/content-scripts](https://developer.chrome.com/docs/extensions/develop/concepts/content-scripts)
* [https://developer.chrome.com/docs/extensions/mv2/background-pages](https://developer.chrome.com/docs/extensions/mv2/background-pages)
* [https://thehackerblog.com/kicking-the-rims-a-guide-for-securely-writing-and-auditing-chrome-extensions/](https://thehackerblog.com/kicking-the-rims-a-guide-for-securely-writing-and-auditing-chrome-extensions/)

<details>

<summary><strong>Aprende hacking en AWS de cero a h√©roe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver a tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** revisa los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) en github.

</details>
