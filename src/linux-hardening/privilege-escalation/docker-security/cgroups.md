# CGroups

{{#include ../../../banners/hacktricks-training.md}}

## Basic Information

**Linux Control Groups**, або **cgroups**, є функцією ядра Linux, яка дозволяє виділяти, обмежувати та пріоритизувати системні ресурси, такі як ЦП, пам'ять та дисковий ввід/вивід серед груп процесів. Вони пропонують механізм для **управління та ізоляції використання ресурсів** колекціями процесів, що корисно для таких цілей, як обмеження ресурсів, ізоляція навантаження та пріоритизація ресурсів серед різних груп процесів.

Існує **дві версії cgroups**: версія 1 та версія 2. Обидві можуть використовуватися одночасно в системі. Основна відмінність полягає в тому, що **cgroups версії 2** вводить **ієрархічну, деревоподібну структуру**, що дозволяє більш тонке та детальне розподілення ресурсів серед груп процесів. Крім того, версія 2 приносить різні покращення, включаючи:

На додаток до нової ієрархічної організації, cgroups версії 2 також ввела **кілька інших змін та покращень**, таких як підтримка **нових контролерів ресурсів**, краща підтримка застарілих додатків та покращена продуктивність.

В цілому, cgroups **версія 2 пропонує більше функцій та кращу продуктивність** порівняно з версією 1, але остання все ще може використовуватися в певних сценаріях, де важлива сумісність зі старими системами.

Ви можете перерахувати cgroups v1 та v2 для будь-якого процесу, переглянувши його файл cgroup у /proc/\<pid>. Ви можете почати з перегляду cgroups вашої оболонки за допомогою цієї команди:
```shell-session
$ cat /proc/self/cgroup
12:rdma:/
11:net_cls,net_prio:/
10:perf_event:/
9:cpuset:/
8:cpu,cpuacct:/user.slice
7:blkio:/user.slice
6:memory:/user.slice 5:pids:/user.slice/user-1000.slice/session-2.scope 4:devices:/user.slice
3:freezer:/
2:hugetlb:/testcgroup
1:name=systemd:/user.slice/user-1000.slice/session-2.scope
0::/user.slice/user-1000.slice/session-2.scope
```
Структура виходу виглядає наступним чином:

- **Числа 2–12**: cgroups v1, кожен рядок представляє різний cgroup. Контролери для них вказані поруч з номером.
- **Число 1**: Також cgroups v1, але виключно для управлінських цілей (встановлений, наприклад, systemd) і не має контролера.
- **Число 0**: Представляє cgroups v2. Контролери не вказані, і цей рядок є ексклюзивним для систем, які працюють лише з cgroups v2.
- **Імена є ієрархічними**, нагадують файлові шляхи, вказуючи на структуру та взаємозв'язок між різними cgroups.
- **Імена на кшталт /user.slice або /system.slice** вказують на категоризацію cgroups, при цьому user.slice зазвичай призначений для сеансів входу, які керуються systemd, а system.slice для системних служб.

### Перегляд cgroups

Файлова система зазвичай використовується для доступу до **cgroups**, відхиляючись від інтерфейсу системних викликів Unix, традиційно використовуваного для взаємодії з ядром. Щоб дослідити конфігурацію cgroup оболонки, слід перевірити файл **/proc/self/cgroup**, який показує cgroup оболонки. Потім, перейшовши до каталогу **/sys/fs/cgroup** (або **`/sys/fs/cgroup/unified`**) і знайти каталог, що має таку ж назву, можна спостерігати різні налаштування та інформацію про використання ресурсів, що стосується cgroup.

![Cgroup Filesystem](<../../../images/image (1128).png>)

Ключові інтерфейсні файли для cgroups мають префікс **cgroup**. Файл **cgroup.procs**, який можна переглянути за допомогою стандартних команд, таких як cat, перераховує процеси в cgroup. Інший файл, **cgroup.threads**, містить інформацію про потоки.

![Cgroup Procs](<../../../images/image (281).png>)

Cgroups, що керують оболонками, зазвичай охоплюють два контролери, які регулюють використання пам'яті та кількість процесів. Щоб взаємодіяти з контролером, слід звертатися до файлів з префіксом контролера. Наприклад, **pids.current** буде використано для визначення кількості потоків у cgroup.

![Cgroup Memory](<../../../images/image (677).png>)

Вказівка **max** у значенні свідчить про відсутність конкретного обмеження для cgroup. Однак, через ієрархічну природу cgroups, обмеження можуть бути накладені cgroup на нижчому рівні в ієрархії каталогів.

### Маніпулювання та створення cgroups

Процеси призначаються cgroups шляхом **запису їх ідентифікатора процесу (PID) у файл `cgroup.procs`**. Це вимагає прав root. Наприклад, щоб додати процес:
```bash
echo [pid] > cgroup.procs
```
Аналогічно, **модифікація атрибутів cgroup, таких як встановлення обмеження PID**, виконується шляхом запису бажаного значення у відповідний файл. Щоб встановити максимальну кількість 3,000 PID для cgroup:
```bash
echo 3000 > pids.max
```
**Створення нових cgroups** передбачає створення нового підкаталогу в ієрархії cgroup, що спонукає ядро автоматично генерувати необхідні файли інтерфейсу. Хоча cgroups без активних процесів можна видалити за допомогою `rmdir`, будьте обережні з певними обмеженнями:

- **Процеси можуть бути розміщені лише в листових cgroups** (тобто, найбільш вкладених у ієрархії).
- **Cgroup не може мати контролера, відсутнього в його батьківському**.
- **Контролери для дочірніх cgroups повинні бути явно оголошені** у файлі `cgroup.subtree_control`. Наприклад, щоб увімкнути контролери CPU та PID у дочірньому cgroup:
```bash
echo "+cpu +pids" > cgroup.subtree_control
```
**root cgroup** є винятком з цих правил, дозволяючи пряме розміщення процесів. Це можна використовувати для видалення процесів з управління systemd.

**Моніторинг використання CPU** в межах cgroup можливий через файл `cpu.stat`, який відображає загальний час використання CPU, що корисно для відстеження використання серед підпроцесів служби:

<figure><img src="../../../images/image (908).png" alt=""><figcaption><p>Статистика використання CPU, як показано у файлі cpu.stat</p></figcaption></figure>

## References

- **Book: How Linux Works, 3rd Edition: What Every Superuser Should Know By Brian Ward**

{{#include ../../../banners/hacktricks-training.md}}
