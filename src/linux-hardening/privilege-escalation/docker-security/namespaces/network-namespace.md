# नेटवर्क नेमस्पेस

{{#include ../../../../banners/hacktricks-training.md}}

## बुनियादी जानकारी

एक नेटवर्क नेमस्पेस एक Linux कर्नेल फीचर है जो नेटवर्क स्टैक का पृथक्करण प्रदान करता है, जिससे **प्रत्येक नेटवर्क नेमस्पेस की अपनी स्वतंत्र नेटवर्क कॉन्फ़िगरेशन** हो सकती है, इंटरफेस, IP पते, रूटिंग तालिकाएँ, और फ़ायरवॉल नियम। यह पृथक्करण विभिन्न परिदृश्यों में उपयोगी है, जैसे कंटेनरीकरण, जहां प्रत्येक कंटेनर को अन्य कंटेनरों और होस्ट सिस्टम से स्वतंत्र अपनी नेटवर्क कॉन्फ़िगरेशन होनी चाहिए।

### यह कैसे काम करता है:

1. जब एक नया नेटवर्क नेमस्पेस बनाया जाता है, तो यह **पूर्ण रूप से पृथक नेटवर्क स्टैक** के साथ शुरू होता है, जिसमें **कोई नेटवर्क इंटरफेस** नहीं होता है सिवाय लूपबैक इंटरफेस (lo) के। इसका मतलब है कि नए नेटवर्क नेमस्पेस में चलने वाली प्रक्रियाएँ डिफ़ॉल्ट रूप से अन्य नेमस्पेस या होस्ट सिस्टम में चलने वाली प्रक्रियाओं के साथ संवाद नहीं कर सकती हैं।
2. **वर्चुअल नेटवर्क इंटरफेस**, जैसे veth जोड़े, बनाए जा सकते हैं और नेटवर्क नेमस्पेस के बीच स्थानांतरित किए जा सकते हैं। यह नेमस्पेस के बीच या एक नेमस्पेस और होस्ट सिस्टम के बीच नेटवर्क कनेक्टिविटी स्थापित करने की अनुमति देता है। उदाहरण के लिए, एक veth जोड़े का एक सिरा एक कंटेनर के नेटवर्क नेमस्पेस में रखा जा सकता है, और दूसरा सिरा होस्ट नेमस्पेस में एक **ब्रिज** या अन्य नेटवर्क इंटरफेस से जोड़ा जा सकता है, जिससे कंटेनर को नेटवर्क कनेक्टिविटी मिलती है।
3. एक नेमस्पेस के भीतर नेटवर्क इंटरफेस के **अपने IP पते, रूटिंग तालिकाएँ, और फ़ायरवॉल नियम** हो सकते हैं, जो अन्य नेमस्पेस से स्वतंत्र होते हैं। यह विभिन्न नेटवर्क नेमस्पेस में प्रक्रियाओं को विभिन्न नेटवर्क कॉन्फ़िगरेशन रखने और ऐसा कार्य करने की अनुमति देता है जैसे कि वे अलग-अलग नेटवर्क सिस्टम पर चल रही हैं।
4. प्रक्रियाएँ `setns()` सिस्टम कॉल का उपयोग करके नेमस्पेस के बीच स्थानांतरित हो सकती हैं, या `CLONE_NEWNET` फ्लैग के साथ `unshare()` या `clone()` सिस्टम कॉल का उपयोग करके नए नेमस्पेस बना सकती हैं। जब एक प्रक्रिया एक नए नेमस्पेस में जाती है या एक बनाती है, तो यह उस नेमस्पेस से संबंधित नेटवर्क कॉन्फ़िगरेशन और इंटरफेस का उपयोग करना शुरू कर देगी।

## प्रयोगशाला:

### विभिन्न नेमस्पेस बनाएं

#### CLI
```bash
sudo unshare -n [--mount-proc] /bin/bash
# Run ifconfig or ip -a
```
एक नए `/proc` फ़ाइल सिस्टम के उदाहरण को माउंट करके, यदि आप पैरामीटर `--mount-proc` का उपयोग करते हैं, तो आप सुनिश्चित करते हैं कि नए माउंट नामस्थान में **उस नामस्थान के लिए विशिष्ट प्रक्रिया जानकारी का सटीक और अलगावित दृश्य** है।

<details>

<summary>त्रुटि: bash: fork: मेमोरी आवंटित नहीं कर सकता</summary>

जब `unshare` को `-f` विकल्प के बिना निष्पादित किया जाता है, तो एक त्रुटि उत्पन्न होती है क्योंकि Linux नए PID (प्रक्रिया आईडी) नामस्थान को संभालने के तरीके के कारण। मुख्य विवरण और समाधान नीचे दिए गए हैं:

1. **समस्या का विवरण**:

- Linux कर्नेल एक प्रक्रिया को `unshare` सिस्टम कॉल का उपयोग करके नए नामस्थान बनाने की अनुमति देता है। हालाँकि, नए PID नामस्थान के निर्माण की शुरुआत करने वाली प्रक्रिया (जिसे "unshare" प्रक्रिया कहा जाता है) नए नामस्थान में प्रवेश नहीं करती है; केवल इसकी बाल प्रक्रियाएँ करती हैं।
- `%unshare -p /bin/bash%` चलाने से `/bin/bash` उसी प्रक्रिया में शुरू होता है जैसे `unshare`। परिणामस्वरूप, `/bin/bash` और इसकी बाल प्रक्रियाएँ मूल PID नामस्थान में होती हैं।
- नए नामस्थान में `/bin/bash` की पहली बाल प्रक्रिया PID 1 बन जाती है। जब यह प्रक्रिया समाप्त होती है, तो यह नामस्थान की सफाई को ट्रिगर करती है यदि कोई अन्य प्रक्रियाएँ नहीं हैं, क्योंकि PID 1 का विशेष कार्य अनाथ प्रक्रियाओं को अपनाना है। Linux कर्नेल तब उस नामस्थान में PID आवंटन को अक्षम कर देगा।

2. **परिणाम**:

- नए नामस्थान में PID 1 के समाप्त होने से `PIDNS_HASH_ADDING` ध्वज की सफाई होती है। इसका परिणाम यह होता है कि नए प्रक्रिया को बनाने के समय `alloc_pid` फ़ंक्शन नए PID को आवंटित करने में विफल रहता है, जिससे "Cannot allocate memory" त्रुटि उत्पन्न होती है।

3. **समाधान**:
- इस समस्या को `unshare` के साथ `-f` विकल्प का उपयोग करके हल किया जा सकता है। यह विकल्प `unshare` को नए PID नामस्थान बनाने के बाद एक नई प्रक्रिया बनाने के लिए फोर्क करता है।
- `%unshare -fp /bin/bash%` निष्पादित करने से यह सुनिश्चित होता है कि `unshare` कमांड स्वयं नए नामस्थान में PID 1 बन जाता है। `/bin/bash` और इसकी बाल प्रक्रियाएँ फिर इस नए नामस्थान में सुरक्षित रूप से समाहित होती हैं, PID 1 के पूर्व समय में समाप्त होने को रोकती हैं और सामान्य PID आवंटन की अनुमति देती हैं।

यह सुनिश्चित करके कि `unshare` `-f` ध्वज के साथ चलता है, नया PID नामस्थान सही ढंग से बनाए रखा जाता है, जिससे `/bin/bash` और इसकी उप-प्रक्रियाएँ बिना मेमोरी आवंटन त्रुटि का सामना किए कार्य कर सकती हैं।

</details>

#### Docker
```bash
docker run -ti --name ubuntu1 -v /usr:/ubuntu1 ubuntu bash
# Run ifconfig or ip -a
```
### जांचें कि आपका प्रोसेस किस नेमस्पेस में है
```bash
ls -l /proc/self/ns/net
lrwxrwxrwx 1 root root 0 Apr  4 20:30 /proc/self/ns/net -> 'net:[4026531840]'
```
### सभी नेटवर्क नामस्थान खोजें
```bash
sudo find /proc -maxdepth 3 -type l -name net -exec readlink {} \; 2>/dev/null | sort -u | grep "net:"
# Find the processes with an specific namespace
sudo find /proc -maxdepth 3 -type l -name net -exec ls -l  {} \; 2>/dev/null | grep <ns-number>
```
### नेटवर्क नामस्थान के अंदर प्रवेश करें
```bash
nsenter -n TARGET_PID --pid /bin/bash
```
आप केवल **दूसरे प्रक्रिया नामस्थान में प्रवेश कर सकते हैं यदि आप रूट हैं**। और आप **दूसरे नामस्थान में प्रवेश नहीं कर सकते** **बिना एक वर्णनकर्ता** जो इसे इंगित करता है (जैसे `/proc/self/ns/net`)।

## References

- [https://stackoverflow.com/questions/44666700/unshare-pid-bin-bash-fork-cannot-allocate-memory](https://stackoverflow.com/questions/44666700/unshare-pid-bin-bash-fork-cannot-allocate-memory)

{{#include ../../../../banners/hacktricks-training.md}}
