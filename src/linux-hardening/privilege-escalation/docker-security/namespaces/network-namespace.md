# Network Namespace

{{#include ../../../../banners/hacktricks-training.md}}

## Basic Information

Мережевий простір імен - це функція ядра Linux, яка забезпечує ізоляцію мережевого стеку, дозволяючи **кожному мережевому простору імен мати свою власну незалежну мережеву конфігурацію**, інтерфейси, IP-адреси, таблиці маршрутизації та правила брандмауера. Ця ізоляція корисна в різних сценаріях, таких як контейнеризація, де кожен контейнер повинен мати свою власну мережеву конфігурацію, незалежну від інших контейнерів і хост-системи.

### How it works:

1. Коли створюється новий мережевий простір імен, він починає з **повністю ізольованого мережевого стеку**, з **жодними мережевими інтерфейсами**, окрім інтерфейсу зворотного зв'язку (lo). Це означає, що процеси, що виконуються в новому мережевому просторі імен, не можуть за замовчуванням спілкуватися з процесами в інших просторах імен або з хост-системою.
2. **Віртуальні мережеві інтерфейси**, такі як пари veth, можуть бути створені та переміщені між мережевими просторами імен. Це дозволяє встановлювати мережеву зв'язність між просторами імен або між простором імен і хост-системою. Наприклад, один кінець пари veth може бути розміщений у мережевому просторі імен контейнера, а інший кінець може бути підключений до **мосту** або іншого мережевого інтерфейсу в просторі імен хоста, забезпечуючи мережеву зв'язність для контейнера.
3. Мережеві інтерфейси в межах простору імен можуть мати свої **власні IP-адреси, таблиці маршрутизації та правила брандмауера**, незалежно від інших просторів імен. Це дозволяє процесам у різних мережевих просторах імен мати різні мережеві конфігурації та працювати так, ніби вони виконуються на окремих мережевих системах.
4. Процеси можуть переміщатися між просторами імен, використовуючи системний виклик `setns()`, або створювати нові простори імен, використовуючи системні виклики `unshare()` або `clone()` з прапором `CLONE_NEWNET`. Коли процес переміщується в новий простір імен або створює його, він почне використовувати мережеву конфігурацію та інтерфейси, пов'язані з цим простором імен.

## Lab:

### Create different Namespaces

#### CLI
```bash
sudo unshare -n [--mount-proc] /bin/bash
# Run ifconfig or ip -a
```
Монтування нової інстанції файлової системи `/proc`, якщо ви використовуєте параметр `--mount-proc`, забезпечує, що новий простір монтування має **точний та ізольований вигляд інформації про процеси, специфічної для цього простору**.

<details>

<summary>Помилка: bash: fork: Не вдалося виділити пам'ять</summary>

Коли `unshare` виконується без параметра `-f`, виникає помилка через те, як Linux обробляє нові PID (ідентифікатори процесів) простори. Основні деталі та рішення наведені нижче:

1. **Пояснення проблеми**:

- Ядро Linux дозволяє процесу створювати нові простори за допомогою системного виклику `unshare`. Однак процес, який ініціює створення нового PID простору (який називається "процесом unshare"), не входить до нового простору; лише його дочірні процеси входять.
- Виконання `%unshare -p /bin/bash%` запускає `/bin/bash` в тому ж процесі, що й `unshare`. Відповідно, `/bin/bash` та його дочірні процеси знаходяться в оригінальному PID просторі.
- Перший дочірній процес `/bin/bash` у новому просторі стає PID 1. Коли цей процес завершується, це викликає очищення простору, якщо немає інших процесів, оскільки PID 1 має особливу роль усиновлення сирітських процесів. Ядро Linux тоді вимкне виділення PID у цьому просторі.

2. **Наслідок**:

- Завершення PID 1 у новому просторі призводить до очищення прапора `PIDNS_HASH_ADDING`. Це призводить до того, що функція `alloc_pid` не може виділити новий PID при створенні нового процесу, що викликає помилку "Не вдалося виділити пам'ять".

3. **Рішення**:
- Проблему можна вирішити, використовуючи параметр `-f` з `unshare`. Цей параметр змушує `unshare` створити новий процес після створення нового PID простору.
- Виконання `%unshare -fp /bin/bash%` забезпечує, що команда `unshare` сама стає PID 1 у новому просторі. `/bin/bash` та його дочірні процеси тоді безпечно містяться в цьому новому просторі, запобігаючи передчасному завершенню PID 1 та дозволяючи нормальне виділення PID.

Забезпечивши, що `unshare` виконується з прапором `-f`, новий PID простір правильно підтримується, що дозволяє `/bin/bash` та його підпроцесам працювати без виникнення помилки виділення пам'яті.

</details>

#### Docker
```bash
docker run -ti --name ubuntu1 -v /usr:/ubuntu1 ubuntu bash
# Run ifconfig or ip -a
```
### Перевірте, в якому просторі імен знаходиться ваш процес
```bash
ls -l /proc/self/ns/net
lrwxrwxrwx 1 root root 0 Apr  4 20:30 /proc/self/ns/net -> 'net:[4026531840]'
```
### Знайти всі мережеві простори імен
```bash
sudo find /proc -maxdepth 3 -type l -name net -exec readlink {} \; 2>/dev/null | sort -u | grep "net:"
# Find the processes with an specific namespace
sudo find /proc -maxdepth 3 -type l -name net -exec ls -l  {} \; 2>/dev/null | grep <ns-number>
```
### Увійти в мережевий простір імен
```bash
nsenter -n TARGET_PID --pid /bin/bash
```
Також ви можете **входити в інший простір процесів лише якщо ви є root**. І ви **не можете** **входити** в інший простір **без дескриптора**, що вказує на нього (наприклад, `/proc/self/ns/net`).

## References

- [https://stackoverflow.com/questions/44666700/unshare-pid-bin-bash-fork-cannot-allocate-memory](https://stackoverflow.com/questions/44666700/unshare-pid-bin-bash-fork-cannot-allocate-memory)

{{#include ../../../../banners/hacktricks-training.md}}
