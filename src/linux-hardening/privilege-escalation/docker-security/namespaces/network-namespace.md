# Network Namespace

{{#include ../../../../banners/hacktricks-training.md}}

## Basic Information

Ένα network namespace είναι μια δυνατότητα του πυρήνα Linux που παρέχει απομόνωση της στοίβας δικτύου, επιτρέποντας **σε κάθε network namespace να έχει τη δική του ανεξάρτητη ρύθμιση δικτύου**, διεπαφές, διευθύνσεις IP, πίνακες δρομολόγησης και κανόνες τείχους προστασίας. Αυτή η απομόνωση είναι χρήσιμη σε διάφορα σενάρια, όπως η κοντενέρωση, όπου κάθε κοντέινερ θα πρέπει να έχει τη δική του ρύθμιση δικτύου, ανεξάρτητη από άλλα κοντέινερ και το σύστημα φιλοξενίας.

### How it works:

1. Όταν δημιουργείται ένα νέο network namespace, ξεκινά με μια **εντελώς απομονωμένη στοίβα δικτύου**, με **κανέναν δίκτυο διεπαφών** εκτός από τη διεπαφή loopback (lo). Αυτό σημαίνει ότι οι διεργασίες που εκτελούνται στο νέο network namespace δεν μπορούν να επικοινωνούν με διεργασίες σε άλλα namespaces ή το σύστημα φιλοξενίας από προεπιλογή.
2. **Εικονικές διεπαφές δικτύου**, όπως τα veth ζεύγη, μπορούν να δημιουργηθούν και να μετακινηθούν μεταξύ των network namespaces. Αυτό επιτρέπει τη δημιουργία δικτυακής συνδεσιμότητας μεταξύ namespaces ή μεταξύ ενός namespace και του συστήματος φιλοξενίας. Για παράδειγμα, το ένα άκρο ενός veth ζεύγους μπορεί να τοποθετηθεί στο network namespace ενός κοντέινερ, και το άλλο άκρο μπορεί να συνδεθεί σε μια **γέφυρα** ή άλλη διεπαφή δικτύου στο namespace του φιλοξενούμενου, παρέχοντας δικτυακή συνδεσιμότητα στο κοντέινερ.
3. Οι διεπαφές δικτύου εντός ενός namespace μπορούν να έχουν τις **δικές τους διευθύνσεις IP, πίνακες δρομολόγησης και κανόνες τείχους προστασίας**, ανεξάρτητες από άλλα namespaces. Αυτό επιτρέπει στις διεργασίες σε διαφορετικά network namespaces να έχουν διαφορετικές ρυθμίσεις δικτύου και να λειτουργούν σαν να εκτελούνται σε ξεχωριστά δικτυωμένα συστήματα.
4. Οι διεργασίες μπορούν να μετακινηθούν μεταξύ namespaces χρησιμοποιώντας την κλήση συστήματος `setns()`, ή να δημιουργήσουν νέα namespaces χρησιμοποιώντας τις κλήσεις συστήματος `unshare()` ή `clone()` με την σημαία `CLONE_NEWNET`. Όταν μια διεργασία μετακινείται σε ένα νέο namespace ή δημιουργεί ένα, θα αρχίσει να χρησιμοποιεί τη ρύθμιση δικτύου και τις διεπαφές που σχετίζονται με αυτό το namespace.

## Lab:

### Create different Namespaces

#### CLI
```bash
sudo unshare -n [--mount-proc] /bin/bash
# Run ifconfig or ip -a
```
Με την τοποθέτηση μιας νέας παρουσίας του συστήματος αρχείων `/proc` αν χρησιμοποιήσετε την παράμετρο `--mount-proc`, διασφαλίζετε ότι η νέα mount namespace έχει μια **ακριβή και απομονωμένη άποψη των πληροφοριών διαδικασίας που είναι συγκεκριμένες για αυτή τη namespace**.

<details>

<summary>Σφάλμα: bash: fork: Cannot allocate memory</summary>

Όταν εκτελείται το `unshare` χωρίς την επιλογή `-f`, προκύπτει ένα σφάλμα λόγω του τρόπου που το Linux χειρίζεται τις νέες PID (Process ID) namespaces. Οι βασικές λεπτομέρειες και η λύση περιγράφονται παρακάτω:

1. **Εξήγηση Προβλήματος**:

- Ο πυρήνας του Linux επιτρέπει σε μια διαδικασία να δημιουργήσει νέες namespaces χρησιμοποιώντας την κλήση συστήματος `unshare`. Ωστόσο, η διαδικασία που ξεκινά τη δημιουργία μιας νέας PID namespace (αναφερόμενη ως η διαδικασία "unshare") δεν εισέρχεται στη νέα namespace; μόνο οι παιδικές της διαδικασίες το κάνουν.
- Η εκτέλεση `%unshare -p /bin/bash%` ξεκινά το `/bin/bash` στην ίδια διαδικασία με το `unshare`. Κατά συνέπεια, το `/bin/bash` και οι παιδικές του διαδικασίες βρίσκονται στην αρχική PID namespace.
- Η πρώτη παιδική διαδικασία του `/bin/bash` στη νέα namespace γίνεται PID 1. Όταν αυτή η διαδικασία τερματίσει, ενεργοποιεί την καθαριότητα της namespace αν δεν υπάρχουν άλλες διαδικασίες, καθώς το PID 1 έχει τον ειδικό ρόλο της υιοθέτησης ορφανών διαδικασιών. Ο πυρήνας του Linux θα απενεργοποιήσει στη συνέχεια την κατανομή PID σε αυτή τη namespace.

2. **Συνέπεια**:

- Η έξοδος του PID 1 σε μια νέα namespace οδηγεί στον καθαρισμό της σημαίας `PIDNS_HASH_ADDING`. Αυτό έχει ως αποτέλεσμα τη αποτυχία της συνάρτησης `alloc_pid` να κατανοήσει ένα νέο PID κατά τη δημιουργία μιας νέας διαδικασίας, παράγοντας το σφάλμα "Cannot allocate memory".

3. **Λύση**:
- Το πρόβλημα μπορεί να επιλυθεί χρησιμοποιώντας την επιλογή `-f` με το `unshare`. Αυτή η επιλογή κάνει το `unshare` να δημιουργήσει μια νέα διαδικασία μετά τη δημιουργία της νέας PID namespace.
- Η εκτέλεση `%unshare -fp /bin/bash%` διασφαλίζει ότι η εντολή `unshare` γίνεται PID 1 στη νέα namespace. Το `/bin/bash` και οι παιδικές του διαδικασίες είναι στη συνέχεια ασφαλώς περιεχόμενες μέσα σε αυτή τη νέα namespace, αποτρέποντας την πρόωρη έξοδο του PID 1 και επιτρέποντας την κανονική κατανομή PID.

Διασφαλίζοντας ότι το `unshare` εκτελείται με την επιλογή `-f`, η νέα PID namespace διατηρείται σωστά, επιτρέποντας στο `/bin/bash` και τις υπο-διαδικασίες του να λειτουργούν χωρίς να αντιμετωπίζουν το σφάλμα κατανομής μνήμης.

</details>

#### Docker
```bash
docker run -ti --name ubuntu1 -v /usr:/ubuntu1 ubuntu bash
# Run ifconfig or ip -a
```
### &#x20;Ελέγξτε σε ποιο namespace βρίσκεται η διαδικασία σας
```bash
ls -l /proc/self/ns/net
lrwxrwxrwx 1 root root 0 Apr  4 20:30 /proc/self/ns/net -> 'net:[4026531840]'
```
### Βρείτε όλα τα Network namespaces
```bash
sudo find /proc -maxdepth 3 -type l -name net -exec readlink {} \; 2>/dev/null | sort -u | grep "net:"
# Find the processes with an specific namespace
sudo find /proc -maxdepth 3 -type l -name net -exec ls -l  {} \; 2>/dev/null | grep <ns-number>
```
### Είσοδος σε ένα Network namespace
```bash
nsenter -n TARGET_PID --pid /bin/bash
```
Επίσης, μπορείτε να **μπείτε σε άλλη διαδικασία namespace μόνο αν είστε root**. Και **δεν μπορείτε** να **μπείτε** σε άλλο namespace **χωρίς έναν περιγραφέα** που να δείχνει σε αυτό (όπως το `/proc/self/ns/net`).

## Αναφορές

- [https://stackoverflow.com/questions/44666700/unshare-pid-bin-bash-fork-cannot-allocate-memory](https://stackoverflow.com/questions/44666700/unshare-pid-bin-bash-fork-cannot-allocate-memory)

{{#include ../../../../banners/hacktricks-training.md}}
