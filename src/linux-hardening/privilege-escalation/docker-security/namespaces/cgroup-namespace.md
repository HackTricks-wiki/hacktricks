# CGroup Namespace

{{#include ../../../../banners/hacktricks-training.md}}

## Basic Information

Ένα cgroup namespace είναι μια δυνατότητα του πυρήνα Linux που παρέχει **απομόνωση των ιεραρχιών cgroup για διαδικασίες που εκτελούνται εντός ενός namespace**. Τα cgroups, συντομογραφία για **control groups**, είναι μια δυνατότητα του πυρήνα που επιτρέπει την οργάνωση διαδικασιών σε ιεραρχικές ομάδες για τη διαχείριση και επιβολή **ορίων στους πόρους του συστήματος** όπως CPU, μνήμη και I/O.

Ενώ τα cgroup namespaces δεν είναι ένας ξεχωριστός τύπος namespace όπως οι άλλοι που συζητήσαμε νωρίτερα (PID, mount, network, κ.λπ.), σχετίζονται με την έννοια της απομόνωσης namespace. **Τα cgroup namespaces εικονικοποιούν την άποψη της ιεραρχίας cgroup**, έτσι ώστε οι διαδικασίες που εκτελούνται εντός ενός cgroup namespace να έχουν μια διαφορετική άποψη της ιεραρχίας σε σύγκριση με τις διαδικασίες που εκτελούνται στον κεντρικό υπολογιστή ή σε άλλα namespaces.

### How it works:

1. Όταν δημιουργείται ένα νέο cgroup namespace, **ξεκινά με μια άποψη της ιεραρχίας cgroup βασισμένη στην cgroup της διαδικασίας που το δημιουργεί**. Αυτό σημαίνει ότι οι διαδικασίες που εκτελούνται στο νέο cgroup namespace θα βλέπουν μόνο ένα υποσύνολο της συνολικής ιεραρχίας cgroup, περιορισμένο στην υποδένδρο cgroup που έχει ρίζα την cgroup της διαδικασίας που το δημιουργεί.
2. Οι διαδικασίες εντός ενός cgroup namespace θα **βλέπουν τη δική τους cgroup ως τη ρίζα της ιεραρχίας**. Αυτό σημαίνει ότι, από την προοπτική των διαδικασιών μέσα στο namespace, η δική τους cgroup εμφανίζεται ως η ρίζα, και δεν μπορούν να δουν ή να έχουν πρόσβαση σε cgroups εκτός του δικού τους υποδένδρου.
3. Τα cgroup namespaces δεν παρέχουν άμεση απομόνωση πόρων; **παρέχουν μόνο απομόνωση της άποψης της ιεραρχίας cgroup**. **Ο έλεγχος και η απομόνωση πόρων επιβάλλονται ακόμα από τα υποσυστήματα cgroup** (π.χ., cpu, μνήμη, κ.λπ.) αυτά καθαυτά.

Για περισσότερες πληροφορίες σχετικά με τα CGroups ελέγξτε:

{{#ref}}
../cgroups.md
{{#endref}}

## Lab:

### Create different Namespaces

#### CLI
```bash
sudo unshare -C [--mount-proc] /bin/bash
```
Με την τοποθέτηση μιας νέας παρουσίας του συστήματος αρχείων `/proc` αν χρησιμοποιήσετε την παράμετρο `--mount-proc`, διασφαλίζετε ότι η νέα mount namespace έχει μια **ακριβή και απομονωμένη άποψη των πληροφοριών διαδικασίας που είναι συγκεκριμένες για αυτή τη namespace**.

<details>

<summary>Σφάλμα: bash: fork: Cannot allocate memory</summary>

Όταν εκτελείται το `unshare` χωρίς την επιλογή `-f`, προκύπτει ένα σφάλμα λόγω του τρόπου που το Linux χειρίζεται τις νέες PID (Process ID) namespaces. Οι βασικές λεπτομέρειες και η λύση περιγράφονται παρακάτω:

1. **Εξήγηση Προβλήματος**:

- Ο πυρήνας του Linux επιτρέπει σε μια διαδικασία να δημιουργήσει νέες namespaces χρησιμοποιώντας την κλήση συστήματος `unshare`. Ωστόσο, η διαδικασία που ξεκινά τη δημιουργία μιας νέας PID namespace (αναφερόμενη ως διαδικασία "unshare") δεν εισέρχεται στη νέα namespace; μόνο οι παιδικές της διαδικασίες το κάνουν.
- Η εκτέλεση `%unshare -p /bin/bash%` ξεκινά το `/bin/bash` στην ίδια διαδικασία με το `unshare`. Ως εκ τούτου, το `/bin/bash` και οι παιδικές του διαδικασίες βρίσκονται στην αρχική PID namespace.
- Η πρώτη παιδική διαδικασία του `/bin/bash` στη νέα namespace γίνεται PID 1. Όταν αυτή η διαδικασία τερματίσει, ενεργοποιεί την καθαριότητα της namespace αν δεν υπάρχουν άλλες διαδικασίες, καθώς το PID 1 έχει τον ειδικό ρόλο της υιοθέτησης ορφανών διαδικασιών. Ο πυρήνας του Linux θα απενεργοποιήσει στη συνέχεια την κατανομή PID σε αυτή τη namespace.

2. **Συνέπεια**:

- Η έξοδος του PID 1 σε μια νέα namespace οδηγεί στον καθαρισμό της σημαίας `PIDNS_HASH_ADDING`. Αυτό έχει ως αποτέλεσμα τη αποτυχία της συνάρτησης `alloc_pid` να κατανοήσει ένα νέο PID κατά τη δημιουργία μιας νέας διαδικασίας, παράγοντας το σφάλμα "Cannot allocate memory".

3. **Λύση**:
- Το πρόβλημα μπορεί να επιλυθεί χρησιμοποιώντας την επιλογή `-f` με το `unshare`. Αυτή η επιλογή κάνει το `unshare` να δημιουργήσει μια νέα διαδικασία μετά τη δημιουργία της νέας PID namespace.
- Η εκτέλεση `%unshare -fp /bin/bash%` διασφαλίζει ότι η εντολή `unshare` γίνεται PID 1 στη νέα namespace. Το `/bin/bash` και οι παιδικές του διαδικασίες είναι στη συνέχεια ασφαλώς περιορισμένες μέσα σε αυτή τη νέα namespace, αποτρέποντας την πρόωρη έξοδο του PID 1 και επιτρέποντας την κανονική κατανομή PID.

Διασφαλίζοντας ότι το `unshare` εκτελείται με την επιλογή `-f`, η νέα PID namespace διατηρείται σωστά, επιτρέποντας στο `/bin/bash` και τις υπο-διαδικασίες του να λειτουργούν χωρίς να αντιμετωπίζουν το σφάλμα κατανομής μνήμης.

</details>

#### Docker
```bash
docker run -ti --name ubuntu1 -v /usr:/ubuntu1 ubuntu bash
```
### &#x20;Ελέγξτε σε ποιο namespace βρίσκεται η διαδικασία σας
```bash
ls -l /proc/self/ns/cgroup
lrwxrwxrwx 1 root root 0 Apr  4 21:19 /proc/self/ns/cgroup -> 'cgroup:[4026531835]'
```
### Βρείτε όλα τα CGroup namespaces
```bash
sudo find /proc -maxdepth 3 -type l -name cgroup -exec readlink {} \; 2>/dev/null | sort -u
# Find the processes with an specific namespace
sudo find /proc -maxdepth 3 -type l -name cgroup -exec ls -l  {} \; 2>/dev/null | grep <ns-number>
```
### Είσοδος σε ένα CGroup namespace
```bash
nsenter -C TARGET_PID --pid /bin/bash
```
Επίσης, μπορείτε να **μπείτε σε άλλο namespace διαδικασίας μόνο αν είστε root**. Και **δεν μπορείτε** να **μπείτε** σε άλλο namespace **χωρίς έναν περιγραφέα** που να δείχνει σε αυτό (όπως το `/proc/self/ns/cgroup`).

## Αναφορές

- [https://stackoverflow.com/questions/44666700/unshare-pid-bin-bash-fork-cannot-allocate-memory](https://stackoverflow.com/questions/44666700/unshare-pid-bin-bash-fork-cannot-allocate-memory)

{{#include ../../../../banners/hacktricks-training.md}}
