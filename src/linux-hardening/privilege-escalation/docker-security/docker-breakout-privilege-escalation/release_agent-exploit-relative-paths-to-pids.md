# Release Agent Exploit: Relative Paths to PIDs

{{#include ../../../../banners/hacktricks-training.md}}

> **TL;DR**  
> The classic **cgroup-v1 `release_agent` container escape** (detailed in
> {{#ref}}
docker-release_agent-cgroups-escape.md
{{#endref}}) relies on the attacker knowing an _absolute_ path on the host that
> points to a script they control.  When the container’s root filesystem is
> hidden behind storage drivers such as **overlay2**, **devicemapper (thin-lvm)**
> or **Kata Containers’ block-device volumes**, that path becomes hard (or
> impossible) to predict.
>
> This technique shows how to **leverage `/proc/<pid>/root` as a *relative*
> symlink back into the container’s filesystem**, allowing you to keep using
> the `release_agent` trick even when the real host path is unknown.

For further details **check the original blog post** (2020-11-19):  
https://ajxchapman.github.io/containers/2020/11/19/privileged-container-escape.html.  
The remainder of this page expands on that idea and adds 2022-2025 updates.

---

## Why “relative-paths-to-PIDs” works

Every Linux process has a private view of the filesystem hierarchy.  The file
`/proc/<pid>/root` is a **magic symlink** that resolves to **the root (`/`) of
that process’ mount-namespace**, _from the point of view of the **host**_.  As
long as the process you pick really belongs to the target container, you have a
handle to its root directory on the host, no matter where that directory lives
on disk.

Example from inside a container whose upperdir is some deep overlay directory on
`/var/lib/docker` (paths truncated for brevity):

```bash
$ ls -l /proc/1/root
lrwxrwxrwx 1 root root 0 Jul 16 08:27 /proc/1/root -> '/var/lib/docker/overlay2/8a…/merged'
```

If we access `/proc/1/root/etc/shadow` we are **reading the container’s
`/etc/shadow` from the _host perspective_**.

The escape therefore becomes:

1. Bruteforce a **PID that we know lives in the same container**.  
   The original post iterated `1..65535`, but you can shorten the search by
   grepping `/proc/*/cgroup` for the container ID.
2. Write `"/proc/<pid>/root<attack-script>"` into *any* writable
   `release_agent` file.
3. Trigger the notifier via `echo $$ > $CGROUP/cgroup.procs`.

When the last task leaves that cgroup, the kernel (in the initial namespaces!)
executes the string inside `release_agent`.  Because the path is relative to the
chosen PID’s root, the host ends up executing **our script inside the
container’s filesystem**, thus achieving full root on the host.

---

## Updated, faster PID discovery (2024)

On busy Kubernetes nodes 65k PIDs can take minutes.  A more reliable heuristic
is to:

```bash
# still inside the privileged container as root
for p in /proc/[0-9]*; do
  # Use the cgroup path to check we target *this* container only
  if grep -q $(hostname) $p/cgroup 2>/dev/null; then
     candidate=${p##*/}
     echo "/proc/$candidate/root$PAYLOAD_PATH" > $CGROUP/release_agent
     echo $$ > $CGROUP/x/cgroup.procs
  fi
done
```

1. `/proc/<pid>/cgroup` lines contain the container-ID – filtering here drops
   >99 % of host PIDs.
2. The loop therefore finishes in seconds even on nodes with thousands of
   processes.

---

## Kernel hardening since 2022 (CVE-2022-0492)

From Linux 5.10.93/5.15.17/5.16.2 onward the kernel **requires
`CAP_SYS_ADMIN` in the _initial_ user-namespace to write `release_agent`**.  A
*privileged* container still has that capability, so this relative-path variant
remains exploitable.  *Unprivileged* containers on patched kernels, however,
will not bypass the new check.

If you just need the patch details, refer to the dedicated page above.

---

## Limitations on modern hosts (2025)

* **cgroup-v2** (the default in Fedora 40, Ubuntu 24.10 and most
  systemd-256+ distros) **removed the whole `release_agent` interface** – the
  technique simply does not exist there.
* On hybrid systems (`cgroup_no_v1="memory"` etc.) the memory controller may
  reside in v1 while others are in v2; if the memory hierarchy is v2 **the
  exploit must mount some other v1 controller** (e.g. `rdma`) to work.
* Mandatory Access Control profiles (AppArmor/SELinux) that disallow `mount` or
  make `/sys/fs/cgroup/**/release_agent` read-only will block the attack even
  in privileged containers.

---

## Detection ideas

See the Falco rule in {{#ref}}
docker-release_agent-cgroups-escape.md
{{#endref}}.  Because this variant still performs a **write()** system call on a
`*/release_agent` path, the existing rule set already catches it.  Additional
context such as the presence of the string `/proc/<number>/root` in the payload
can reduce false positives.

---

## References

* Chapman, A. J. – *“Privileged container escape: relative paths to PIDs”*
  (Nov 2020)
* Unit 42 – *“CVE-2022-0492: Linux kernel privilege escalation via cgroups”*
  (Feb 2022)

{{#include ../../../../banners/hacktricks-training.md}}