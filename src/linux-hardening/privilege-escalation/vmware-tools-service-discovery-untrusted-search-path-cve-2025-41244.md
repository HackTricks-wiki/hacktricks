# VMware Tools découverte de services LPE (CWE-426) via regex-based binary discovery (CVE-2025-41244)

{{#include ../../banners/hacktricks-training.md}}

Cette technique exploite des pipelines de découverte de services pilotés par des regex qui analysent les lignes de commande des processus en cours pour déduire les versions des services, puis exécutent un binaire candidat avec l'option "version". Lorsque des motifs permissifs acceptent des chemins non fiables contrôlés par l'attaquant (par ex. /tmp/httpd), le collecteur privilégié exécute un binaire arbitraire depuis un emplacement non fiable, entraînant une élévation de privilèges locale. NVISO a documenté cela dans VMware Tools/Aria Operations Service Discovery comme CVE-2025-41244.

- Impact : Élévation locale des privilèges vers root (ou vers le compte de discovery privilégié)
- Root cause : Untrusted Search Path (CWE-426) + permissive regex matching of process command lines
- Affected : open-vm-tools/VMware Tools on Linux (credential-less discovery), VMware Aria Operations SDMP (credential-based discovery via Tools/proxy)

## Comment fonctionne la découverte de services VMware (vue d'ensemble)

- Credential-based (legacy) : Aria exécute des scripts de découverte à l'intérieur du guest via VMware Tools en utilisant des identifiants privilégiés configurés.
- Credential-less (modern) : La logique de découverte s'exécute au sein de VMware Tools, déjà privilégiée dans le guest.

Les deux modes exécutent finalement une logique shell qui scanne les processus ayant des sockets à l'écoute, extrait un chemin de commande correspondant via une regex, et exécute le premier token argv avec un paramètre de version.

## Cause racine et modèle vulnérable (open-vm-tools)

Dans open-vm-tools, le script du plugin serviceDiscovery get-versions.sh matche les binaires candidats en utilisant des expressions régulières larges et exécute le premier token sans aucune validation du chemin de confiance :
```bash
get_version() {
PATTERN=$1
VERSION_OPTION=$2
for p in $space_separated_pids
do
COMMAND=$(get_command_line $p | grep -Eo "$PATTERN")
[ ! -z "$COMMAND" ] && echo VERSIONSTART "$p" "$("${COMMAND%%[[:space:]]*}" $VERSION_OPTION 2>&1)" VERSIONEND
done
}
```
Il est invoqué avec des motifs permissifs contenant \S (caractère non-espace) qui correspondent facilement à des chemins non système dans des emplacements inscriptibles par l'utilisateur :
```bash
get_version "/\S+/(httpd-prefork|httpd|httpd2-prefork)($|\s)" -v
get_version "/usr/(bin|sbin)/apache\S*" -v
get_version "/\S+/mysqld($|\s)" -V
get_version "\.?/\S*nginx($|\s)" -v
get_version "/\S+/srm/bin/vmware-dr($|\s)" --version
get_version "/\S+/dataserver($|\s)" -v
```
- L'extraction utilise grep -Eo et prend le premier token : ${COMMAND%%[[:space:]]*}
- Aucune whitelist/allowlist des chemins système de confiance ; tout listener découvert dont le nom correspond est exécuté avec -v/--version

Cela crée une primitive d'exécution par chemin de recherche non fiable : des binaires arbitraires situés dans des répertoires world-writable (par ex. /tmp/httpd) sont exécutés par un composant privilégié.

## Exploitation (modes sans credentials et avec credentials)

Preconditions
- Vous pouvez exécuter un processus non privilégié qui ouvre un socket d'écoute sur le guest.
- Le discovery job est activé et s'exécute périodiquement (historiquement ~5 minutes).

Steps
1) Placez un binaire dans un chemin correspondant à l'un des regex permissifs, par ex. /tmp/httpd ou ./nginx
2) Exécutez-le en tant qu'utilisateur peu privilégié et assurez-vous qu'il ouvre un socket d'écoute quelconque
3) Attendez le cycle de discovery ; le collector privilégié exécutera automatiquement : /tmp/httpd -v (ou similaire), lançant votre programme en tant que root

Minimal demo (en utilisant l'approche de NVISO)
```bash
# Build any small helper that:
#  - default mode: opens a dummy TCP listener
#  - when called with -v/--version: performs the privileged action (e.g., connect to an abstract UNIX socket and spawn /bin/sh -i)
# Example staging and trigger
cp your_helper /tmp/httpd
chmod +x /tmp/httpd
/tmp/httpd          # run as low-priv user and wait for the cycle
# After the next cycle, expect a root shell or your privileged action
```
Enchaînement de processus typique
- Credential-based: /usr/bin/vmtoolsd -> /bin/sh /tmp/VMware-SDMP-Scripts-.../script_...sh -> /tmp/httpd -v -> /bin/sh -i
- Credential-less: /bin/sh .../get-versions.sh -> /tmp/httpd -v -> /bin/sh -i

Artefacts (credential-based)
Les scripts wrapper SDMP récupérés sous /tmp/VMware-SDMP-Scripts-{UUID}/ peuvent montrer l'exécution directe du chemin malveillant :
```bash
/tmp/httpd -v >"/tmp/VMware-SDMP-Scripts-{UUID}/script_-{ID}_0.stdout" 2>"/tmp/VMware-SDMP-Scripts-{UUID}/script_-{ID}_0.stderr"
```
## Généralisation de la technique: regex-driven discovery abuse (portable pattern)

De nombreux agents et suites de surveillance implémentent la discovery de version/service en :
- Énumérant les processus avec des sockets en écoute
- Greppant argv/command lines avec des regex permissifs (par ex., des patterns contenant \S)
- Exécutant le chemin correspondant avec un flag bénin comme -v, --version, -V, -h

Si le regex accepte des chemins non fiables et que le chemin est exécuté depuis un contexte privilégié, vous obtenez CWE-426 Untrusted Search Path execution.

Abuse recipe
- Nommez votre binaire comme des daemons courants que le regex est susceptible de faire correspondre : httpd, nginx, mysqld, dataserver
- Placez-le dans un répertoire inscriptible : /tmp/httpd, ./nginx
- Assurez-vous qu'il correspond au regex et ouvre un port pour être énuméré
- Attendez le collecteur planifié ; vous obtenez une invocation privilégiée automatique de <path> -v

Masquerading note: Ceci s'aligne sur MITRE ATT&CK T1036.005 (Match Legitimate Name or Location) pour augmenter la probabilité de correspondance et la furtivité.

Reusable privileged I/O relay trick
- Construisez votre helper de sorte que lors d'une invocation privilégiée (-v/--version) il se connecte à un rendezvous connu (par ex., une socket UNIX abstraite Linux comme @cve) et relie stdio à /bin/sh -i. Cela évite les artefacts sur disque et fonctionne dans de nombreux environnements où le même binaire est ré-invoqué avec un flag.

## Detection and DFIR guidance

Hunting queries
- Enfants inhabituels de vmtoolsd ou get-versions.sh tels que /tmp/httpd, ./nginx, /tmp/mysqld
- Toute exécution de chemins absolus non-système par des scripts de découverte (cherchez des espaces dans les expansions ${COMMAND%%...})
- ps -ef --forest pour visualiser les arbres d'ascendance : vmtoolsd -> get-versions.sh -> <non-system path>

On Aria SDMP (credential-based)
- Inspectez /tmp/VMware-SDMP-Scripts-{UUID}/ pour des scripts transitoires et des artefacts stdout/stderr montrant l'exécution de chemins malveillants

Policy/telemetry
- Alerter lorsque des collectors privilégiés s'exécutent depuis des préfixes non-système : ^/(tmp|home|var/tmp|dev/shm)/
- Surveillance d'intégrité des fichiers sur get-versions.sh et les plugins VMware Tools

## Mitigations

- Patch : Appliquez les mises à jour Broadcom/VMware pour CVE-2025-41244 (Tools and Aria Operations SDMP)
- Désactivez ou restreignez la découverte sans credentials lorsque possible
- Validez les chemins de confiance : restreignez l'exécution aux répertoires autorisés (/usr/sbin, /usr/bin, /sbin, /bin) et uniquement aux binaires exacts connus
- Évitez les regex permissifs contenant \S ; privilégiez des chemins absolus ancrés et explicites et des noms de commande exacts
- Abaissez les privilèges des helpers de découverte quand possible ; sandboxez (seccomp/AppArmor) pour réduire l'impact
- Surveillez et alertez sur vmtoolsd/get-versions.sh s'exécutant depuis des chemins non-système

## Notes for defenders and implementers

Modèle d'appariement et d'exécution plus sûr
```bash
# Bad: permissive regex and blind exec
COMMAND=$(get_command_line "$pid" | grep -Eo "/\\S+/nginx(\$|\\s)")
[ -n "$COMMAND" ] && "${COMMAND%%[[:space:]]*}" -v

# Good: strict allowlist + path checks
candidate=$(get_command_line "$pid" | awk '{print $1}')
case "$candidate" in
/usr/sbin/nginx|/usr/sbin/httpd|/usr/sbin/apache2)
"$candidate" -v 2>&1 ;;
*)
: # ignore non-allowlisted paths
;;
esac
```
## Références

- [NVISO – You name it, VMware elevates it (CVE-2025-41244)](https://blog.nviso.eu/2025/09/29/you-name-it-vmware-elevates-it-cve-2025-41244/)
- [Broadcom advisory for CVE-2025-41244](https://support.broadcom.com/web/ecx/support-content-notification/-/external/content/SecurityAdvisories/0/36149)
- [open-vm-tools – serviceDiscovery/get-versions.sh (stable-13.0.0)](https://github.com/vmware/open-vm-tools/blob/stable-13.0.0/open-vm-tools/services/plugins/serviceDiscovery/get-versions.sh)
- [MITRE ATT&CK T1036.005 – Match Legitimate Name or Location](https://attack.mitre.org/techniques/T1036/005/)
- [CWE-426: Untrusted Search Path](https://cwe.mitre.org/data/definitions/426.html)

{{#include ../../banners/hacktricks-training.md}}
