# eSIM / Java Card VM Exploitation

{{#include ../banners/hacktricks-training.md}}

## Panoramica
Le SIM incorporate (eSIM) sono implementate come **Embedded UICC (eUICC)** smart-card che eseguono una **Java Card Virtual Machine (JC VM)** su un elemento sicuro. Poiché i profili e gli applet possono essere forniti *over-the-air* (OTA) tramite Remote SIM Provisioning (RSP), qualsiasi difetto di sicurezza della memoria all'interno della JC VM diventa istantaneamente un primitivo di esecuzione di codice remoto **all'interno del componente più privilegiato del dispositivo**.

Questa pagina descrive un compromesso completo nel mondo reale dell'eUICC di Kigen (Infineon SLC37 ESA1M2, ARM SC300) causato dalla mancanza di controlli di sicurezza dei tipi nei bytecode `getfield` e `putfield`. La stessa tecnica può essere riutilizzata contro altri fornitori che omettono la verifica del bytecode sulla scheda.

## Superficie di attacco
1. **Gestione remota delle applicazioni (RAM)**
I profili eSIM possono incorporare applet Java Card arbitrarie. La fornitura viene eseguita con APDU standard che possono essere incapsulate tramite SMS-PP (Short Message Service Point-to-Point) o HTTPS. Se un attaccante possiede (o ruba) le **chiavi RAM** per un profilo, può `INSTALL`/`LOAD` un applet malevolo da remoto.
2. **Esecuzione del bytecode Java Card**
Dopo l'installazione, l'applet viene eseguito all'interno della VM. La mancanza di controlli di runtime consente la corruzione della memoria.

## Il primitivo di confusione dei tipi
`getfield` / `putfield` dovrebbero operare solo su **riferimenti a oggetti**. Nell'eUICC di Kigen, le istruzioni non convalidano mai se l'operando nello stack è un *oggetto* o un *riferimento a un array*. Poiché una parola `array.length` si trova esattamente allo stesso offset del primo campo di istanza di un oggetto normale, un attaccante può:

1. Creare un array di byte `byte[] buf = new byte[0x100];`
2. Castarlo a `Object o = (Object)buf;`
3. Usare `putfield` per sovrascrivere *qualsiasi* valore a 16 bit all'interno di un oggetto adiacente (inclusi VTABLE / voci di traduzione ptr).
4. Usare `getfield` per leggere *memoria arbitraria* una volta che i puntatori interni sono stati compromessi.
```java
// Pseudo-bytecode sequence executed by the malicious applet
// buf = newarray byte 0x100
// o   = (Object) buf            // illegal but not verified
// putfield <victimObject+offset>, 0xCAFE // arbitrary write
// ... set up read-what-where gadgets ...
```
Il primitivo fornisce **lettura / scrittura arbitraria** nello spazio degli indirizzi eUICC – sufficiente per estrarre la chiave ECC privata unica del dispositivo che autentica la scheda nell'ecosistema GSMA.

## Flusso di lavoro di sfruttamento end-to-end
1. **Enumerare il firmware** – Utilizzare l'elemento `GET DATA` non documentato `DF1F`:
```
80 CA DF 1F 00   // → "ECu10.13" (vulnerabile)
```
2. **Installare l'applet malevolo OTA** – Abusare delle chiavi pubblicamente note del profilo di test generico TS.48 e inviare frammenti SMS-PP che trasportano il file CAP (`LOAD`) seguito da un `INSTALL`:
```
// catena APDU semplificata
80 E6 02 00 <data>   // LOAD (blocco n)
80 E6 0C 00 <data>   // INSTALL per il caricamento
```
3. **Attivare la confusione di tipo** – Quando l'applet viene selezionato, esegue il write-what-where per dirottare una tabella di puntatori e rivelare la memoria attraverso le normali risposte APDU.
4. **Estrarre la chiave del certificato GSMA** – La chiave EC privata viene copiata nella RAM dell'applet e restituita in blocchi.
5. **Impersonare l'eUICC** – La coppia di chiavi rubate + certificati consente all'attaccante di autenticarsi a *qualsiasi* server RSP come una scheda legittima (il binding EID potrebbe essere ancora richiesto per alcuni operatori).
6. **Scaricare e modificare i profili** – I profili in testo semplice contengono campi altamente sensibili come `OPc`, `AMF`, chiavi OTA e persino applet aggiuntivi. L'attaccante può:
* Clonare un profilo su un secondo eUICC (dirottamento voce/SMS);
* Patchare le applicazioni Java Card (ad es. inserire spyware STK) prima di ricaricarle;
* Estrarre segreti dell'operatore per abusi su larga scala.

## Dimostrazione di clonazione / dirottamento
Installare lo stesso profilo su **PHONE A** e **PHONE B** porta il Mobile Switching Centre a instradare il traffico in arrivo verso il dispositivo che si è registrato più recentemente. Una sessione di intercettazione SMS 2FA di Gmail è sufficiente per bypassare la MFA per la vittima.

## Toolkit di test e sfruttamento automatizzato
I ricercatori hanno rilasciato uno strumento interno con un comando `bsc` (*Basic Security Check*) che mostra immediatamente se una VM Java Card è vulnerabile:
```
scard> bsc
- castcheck        [arbitrary int/obj casts]
- ptrgranularity   [pointer granularity/tr table presence]
- locvaraccess     [local variable access]
- stkframeaccess   [stack frame access]
- instfieldaccess  [instance field access]
- objarrconfusion  [object/array size field confusion]
```
Moduli forniti con il framework:
* `introspector` – esploratore completo di VM e memoria (~1.7 MB Java)
* `security-test` – applet generico di verifica bypass (~150 KB)
* `exploit`       – compromissione Kigen eUICC 100 % affidabile (~72 KB)

## Mitigazioni
1. **Verifica del byte-code sulla scheda** – applicare il tracciamento completo del flusso di controllo e del flusso di dati invece di solo quello in cima allo stack.
2. **Nascondere l'intestazione dell'array** – posizionare `length` al di fuori dei campi oggetto sovrapposti.
3. **Rafforzare la politica delle chiavi RAM** – non spedire mai profili con chiavi pubbliche; disabilitare `INSTALL` nei profili di test (trattato in GSMA TS.48 v7).
4. **Euristiche lato server RSP** – limitare il numero di download dei profili per EID, monitorare anomalie geografiche, convalidare la freschezza del certificato.

## Checklist Rapida per Pentester
* Query `GET DATA DF1F` – la stringa firmware vulnerabile `ECu10.13` indica Kigen.
* Controllare se le chiavi RAM sono conosciute ‑> tentare `INSTALL`/`LOAD` OTA.
* Dopo l'installazione dell'applet, forzare la lettura di un semplice cast primitivo (`objarrconfusion`).
* Provare a leggere le chiavi private del Security Domain – successo = compromissione totale.

## Riferimenti
- [Security Explorations – eSIM security](https://security-explorations.com/esim-security.html)
- [GSMA TS.48 Generic Test Profile v7.0](https://www.gsma.com/get-involved/working-groups/gsma_resources/ts-48-v7-0-generic-euicc-test-profile-for-device-testing/)
- [Java Card VM Specification 3.1](https://docs.oracle.com/en/java/javacard/3.1/jc-vm-spec/F12650_05.pdf)

{{#include ../banners/hacktricks-training.md}}
