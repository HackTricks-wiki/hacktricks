# IoT Android App Exploitation / Android Companion App Reverse-Engineering

{{#include /banners/hacktricks-training.md}}

## Overview

Target: Android companion app `com.klh.lwfpv` (LW FPV) controlling Eachine E58 drone on Android 14.

App analysis pipeline:
1. Unpack Bangcle-protected Java layer by intercepting `unlink` with Frida and extracting DEX from an alternative unpacked MF GPS app (`com.lwcx.lwmfgps`).
2. Load and reverse-engineer native libraries:
   - `liblewei-3.2.2.so`
   - `liblewei_uartprotol.so`
   - `liblewei63.so`
   - `libFHDEVNet.so`
3. Analyze network protocols (TCP/UDP) and threading behavior.

## Protocol Analysis

- TCP 7060/8060: `lewei_cmd` control & data transfers (e.g., photo, file ops).
- TCP 7060: H.264 video stream.
- UDP 40000: VGA frames.
- UDP 50000: FlyInfo telemetry.

## Identified Vulnerabilities

### AVC Stream Heap Overflow

In `avc_read_buffer_thread` (`liblewei-3.2.2.so`): unbounded `net_recv(..., buffer, size)` into `malloc(0xA00000)` causes overflow (non-exploitable due to large buffer).

### VGA Stream Heap OOB Write

UDP 40000 handler:
```c
short size = *(short*)&buffer.content[49];
unsigned short index = *(unsigned short*)&buffer.content[45] - 1;
memcpy(&buffer[1400*index + 1036], &buffer.content[51], size); // OOB write into 0xA00000 heap
```
Attacker controls `size` and `index`, enabling arbitrary heap writes.

### JNI `SendGetRecPlan` Heap Overflow

In JNI command (cmd_id=6) over TCP 8060:
```c
char *buf = malloc(0x200);
net_recv(socket_8060, buf, *(int*)&buf->size); // overflow Scudo bins (0x1c0–0x250)
```

### `ParseGLInfoData` BSS Overflow

In `liblewei_uartprotol.so`, UDP 50000:
```c
unsigned char data_length = buffer[2];
memcpy(&GLFlyInfoData, buffer+3, data_length); // overwrites adjacent globals (e.g., LWDroneSoftwareData)
```

### Stack Overflow in `GetUserList`

In `libFHDEVNet.so`:
```c
uint8_t user_list[0x880];
int item_count = length / 0x45;
for (i=0; i<item_count; i++) {
    // write 0x45 bytes per entry into user_list
}
// attacker-controlled length > 31*0x45 → stack overflow
```

## Exploitation Chain

1. **Leak primitive**: Abuse `NC()` in `libFHDEVNet.so` by sending an oversized `msg_length` in the first `TCPSocketRecv`, overflowing the stack to leak cookies, heap & module bases via the second receive.
2. **COP primitive**: Exploit JNI heap overflow (SendGetRecPlan) to corrupt a fake `LinearAllocator.mDtorList` in `libhwui.so`. During destruction, controlled `dtor(addr)` allows arbitrary function calls with attacker-chosen argument.
3. **RCE Gadget**: Identify `sub_738E8(device_t*)` that opens a socket and sends a byte to leak libc base; chain COP to invoke `system()` with attacker data, achieving full RCE on the device.

## Tools

- Wireshark: protocol analysis
- Frida: Bangcle unpacking, instrumentation, PoC scripting
- Python (`struct.pack`): heap overflow simulation

## References

- From cheap IoT toy to your smartphone: Getting RCE by leveraging a companion app – Synacktiv 08/07/2025
  <https://www.synacktiv.com/en/publications/from-cheap-iot-toy-to-your-smartphone-getting-rce-by-leveraging-a-companion-app.html>

{{#include /banners/hacktricks-training.md}}
