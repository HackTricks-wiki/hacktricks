# 2049 - Pentesting NFS Service

{{#include ../banners/hacktricks-training.md}}

## **बुनियादी जानकारी**

**NFS** एक प्रणाली है जो **क्लाइंट/सर्वर** के लिए डिज़ाइन की गई है, जो उपयोगकर्ताओं को नेटवर्क के माध्यम से फ़ाइलों तक सहजता से पहुँचने की अनुमति देती है जैसे कि ये फ़ाइलें स्थानीय निर्देशिका में स्थित हैं।

**डिफ़ॉल्ट पोर्ट**: 2049/TCP/UDP (संस्करण 4 को छोड़कर, इसे केवल TCP या UDP की आवश्यकता होती है)।
```
2049/tcp open  nfs     2-3 (RPC #100003
```
### Authentication

इस प्रोटोकॉल का एक महत्वपूर्ण पहलू इसकी सामान्य कमी है **authentication** या **authorization mechanisms** में। इसके बजाय, authorization **file system information** पर निर्भर करता है, जिसमें सर्वर को **client-provided user information** को file system के आवश्यक **authorization format** में सटीक रूप से अनुवादित करने का कार्य सौंपा गया है, जो मुख्य रूप से **UNIX syntax** का पालन करता है।

Authentication आमतौर पर **UNIX `UID`/`GID` पहचानकर्ताओं और समूह सदस्यताओं** पर निर्भर करता है। हालाँकि, एक चुनौती उत्पन्न होती है क्योंकि **`UID`/`GID` मैपिंग** में संभावित असंगति के कारण क्लाइंट और सर्वर के बीच, सर्वर द्वारा अतिरिक्त सत्यापन के लिए कोई स्थान नहीं छोड़ता। इसके अलावा, ये विवरण क्लाइंट द्वारा भेजे जाते हैं और सर्वर द्वारा विश्वसनीय होते हैं, इसलिए एक धोखेबाज़ क्लाइंट संभावित रूप से **अधिक विशेषाधिकार प्राप्त `uid` और `gid` भेजकर किसी अन्य उपयोगकर्ता का **impersonate** कर सकता है।

**हालांकि, ध्यान दें कि डिफ़ॉल्ट रूप से NFS का उपयोग करके `UID` 0 (root) का impersonate करना संभव नहीं है। इस पर अधिक जानकारी squashing अनुभाग में है।**

#### Hosts

बेहतर (या कुछ) authorization के लिए, आप उन **hosts** को निर्दिष्ट कर सकते हैं जो NFS शेयर तक पहुँच सकते हैं। यह Linux के `/etc/exports` फ़ाइल में किया जा सकता है। उदाहरण:
```
/PATH/TO/EXPORT      CLIENT1(OPTIONS1) CLIENT2(OPTIONS2) ...
/media/disk/share   192.168.2.123(rw,sec=krb5p:krb5i)
```
As you can see, यह एक विशिष्ट **IP** या **hostname** को साझा करने के लिए कॉन्फ़िगर करने की अनुमति देता है। केवल वही पता साझा को एक्सेस कर सकेगा।

### Versions

- **NFSv2**: यह संस्करण विभिन्न प्रणालियों के साथ इसकी व्यापक संगतता के लिए पहचाना जाता है, जो इसके महत्व को UDP पर मुख्य रूप से प्रारंभिक संचालन के साथ चिह्नित करता है। श्रृंखला में **सबसे पुराना** होने के नाते, इसने भविष्य के विकास के लिए आधार तैयार किया।

- **NFSv3**: कई सुधारों के साथ पेश किया गया, NFSv3 ने अपने पूर्ववर्ती पर विस्तार किया, जिसमें परिवर्तनशील फ़ाइल आकारों का समर्थन और बेहतर त्रुटि रिपोर्टिंग तंत्र प्रदान किया। इसके विकास के बावजूद, इसे NFSv2 क्लाइंट के साथ पूर्ण पूर्ववर्ती संगतता में सीमाओं का सामना करना पड़ा।

- **NFSv4**: NFS श्रृंखला में एक महत्वपूर्ण संस्करण, NFSv4 ने नेटवर्क के बीच फ़ाइल साझा करने को आधुनिक बनाने के लिए डिज़ाइन की गई सुविधाओं का एक सेट पेश किया। उल्लेखनीय सुधारों में **उच्च सुरक्षा** के लिए Kerberos का एकीकरण, फ़ायरवॉल को पार करने और बिना पोर्टमैपर्स की आवश्यकता के इंटरनेट पर संचालन करने की क्षमता, एक्सेस कंट्रोल सूचियों (ACLs) का समर्थन, और स्थिति-आधारित संचालन का परिचय शामिल है। इसके प्रदर्शन में सुधार और स्थिति-आधारित प्रोटोकॉल को अपनाने ने NFSv4 को नेटवर्क फ़ाइल साझा करने की तकनीकों में एक महत्वपूर्ण प्रगति के रूप में अलग किया।
- ध्यान दें कि लिनक्स होस्ट NFS में kerberos प्रमाणीकरण का समर्थन करना बहुत अजीब है।

NFS के प्रत्येक संस्करण को नेटवर्क वातावरण की विकसित आवश्यकताओं को संबोधित करने के इरादे से विकसित किया गया है, सुरक्षा, संगतता और प्रदर्शन को क्रमिक रूप से बढ़ाते हुए।

### Squashing

जैसा कि पहले उल्लेख किया गया है, NFS आमतौर पर फ़ाइलों तक पहुँचने के लिए क्लाइंट के `uid` और `gid` पर भरोसा करेगा (यदि kerberos का उपयोग नहीं किया गया है)। हालाँकि, कुछ कॉन्फ़िगरेशन हैं जो सर्वर में **इस व्यवहार को बदलने** के लिए सेट किए जा सकते हैं:

- **all_squash**: यह सभी पहुँच को **`nobody`** (65534 unsigned / -2 signed) पर मैप करके समेटता है। इसलिए, हर कोई `nobody` है और कोई उपयोगकर्ता नहीं हैं।
- **root_squash/no_all_squash**: यह लिनक्स पर डिफ़ॉल्ट है और **केवल uid 0 (root) के साथ पहुँच को समेटता है**। इसलिए, कोई भी `UID` और `GID` पर भरोसा किया जाता है लेकिन `0` को `nobody` में समेटा जाता है (इसलिए कोई रूट अनुकरण संभव नहीं है)।
- **no_root_squash**: यदि यह कॉन्फ़िगरेशन सक्षम है तो यह रूट उपयोगकर्ता को भी समेटता नहीं है। इसका मतलब है कि यदि आप इस कॉन्फ़िगरेशन के साथ एक निर्देशिका को माउंट करते हैं तो आप इसे रूट के रूप में एक्सेस कर सकते हैं।

### Subtree check

केवल लिनक्स पर उपलब्ध। man(5) exports कहता है: "यदि फ़ाइल सिस्टम का एक उपनिर्देशिका निर्यातित है, लेकिन पूरा फ़ाइल सिस्टम नहीं है, तो जब भी एक NFS अनुरोध आता है, सर्वर को यह जांचना चाहिए कि न केवल एक्सेस की गई फ़ाइल उपयुक्त फ़ाइल सिस्टम में है (जो आसान है) बल्कि यह निर्यातित पेड़ में भी है (जो कठिन है)। इस जांच को उप-निर्देशिका जांच कहा जाता है।"

लिनक्स में **`subtree_check` सुविधा डिफ़ॉल्ट रूप से अक्षम है**।

## Enumeration

### Showmount

इसका उपयोग **NFSv3 सर्वर से जानकारी प्राप्त करने** के लिए किया जा सकता है, जैसे **निर्यातों** की सूची, कौन इन निर्यातों को **एक्सेस करने के लिए अधिकृत है**, और कौन से क्लाइंट जुड़े हुए हैं (जो गलत हो सकता है यदि कोई क्लाइंट बिना सर्वर को बताए डिस्कनेक्ट हो जाता है)।
**NFSv4 क्लाइंट सीधे /export** तक पहुँचते हैं और वहाँ से निर्यातों तक पहुँचने की कोशिश करते हैं, यदि यह अवैध या किसी कारण से अनधिकृत है तो विफल हो जाते हैं।

यदि `showmount` जैसे उपकरण या Metasploit मॉड्यूल NFS पोर्ट से जानकारी नहीं दिखाते हैं, तो यह संभावित रूप से एक NFSv4 सर्वर है जो संस्करण 3 का समर्थन नहीं करता है।
```bash
showmount -e <IP>
```
### उपयोगी nmap स्क्रिप्ट्स
```bash
nfs-ls #List NFS exports and check permissions
nfs-showmount #Like showmount -e
nfs-statfs #Disk statistics and info from NFS share
```
### उपयोगी मेटास्प्लॉइट मॉड्यूल
```bash
scanner/nfs/nfsmount #Scan NFS mounts and list permissions
```
### nfs_analyze

यह उपकरण [https://github.com/hvs-consulting/nfs-security-tooling](https://github.com/hvs-consulting/nfs-security-tooling) से NFS सर्वर से बहुत सारे डेटा प्राप्त करने के लिए उपयोग किया जा सकता है जैसे कि **mounts**, समर्थित NFS संस्करण, जुड़े हुए IP, और यहां तक कि यह भी कि क्या **exports से अन्य फ़ोल्डरों में भागना संभव है** या **यदि `no_root_squash` सक्षम है**।


## Mounting

यह जानने के लिए कि **कौन सा फ़ोल्डर** सर्वर **उपलब्ध** है, आप इसे इस प्रकार पूछ सकते हैं:
```bash
showmount -e <IP>
```
फिर इसे माउंट करें:
```bash
mount -t nfs [-o vers=2] <ip>:<remote_folder> <local_folder> -o nolock
```
आपको **संस्करण 2** का उपयोग करने के लिए निर्दिष्ट करना चाहिए क्योंकि इसमें **कोई** **प्रमाणीकरण** या **अधिकार** नहीं है।

**उदाहरण:**
```bash
mkdir /mnt/new_back
mount -t nfs [-o vers=2] 10.12.0.150:/backup /mnt/new_back -o nolock
```
## हमले

### UID और GID पर भरोसा करना

बिल्कुल, यहाँ केवल एक समस्या है कि डिफ़ॉल्ट रूप से रूट (`UID` 0) का अनुकरण करना संभव नहीं है। हालाँकि, किसी अन्य उपयोगकर्ता का अनुकरण करना संभव है या यदि `no_root_squash` सक्षम है तो आप रूट का भी अनुकरण कर सकते हैं।

- यदि आप एक फ़ोल्डर माउंट करते हैं जिसमें **फाइलें या फ़ोल्डर केवल कुछ उपयोगकर्ता द्वारा पहुँच योग्य हैं** (द्वारा **UID**)। आप **स्थानीय रूप से** उस **UID** के साथ एक उपयोगकर्ता **बनाने** में सक्षम होंगे और उस **उपयोगकर्ता** का उपयोग करके आप फ़ाइल/फ़ोल्डर **एक्सेस** कर सकेंगे।
- टूल **`fuse_nfs`** [https://github.com/hvs-consulting/nfs-security-tooling](https://github.com/hvs-consulting/nfs-security-tooling) से मूल रूप से हमेशा आवश्यक UID और GID फ़ाइलों तक पहुँचने के लिए भेजेगा।

### SUID विशेषाधिकार वृद्धि

पृष्ठ की जाँच करें:


{{#ref}}
../linux-hardening/privilege-escalation/nfs-no_root_squash-misconfiguration-pe.md
{{#endref}}

### एक्सपोर्ट से भागना

इस [महान लेख](https://www.hvs-consulting.de/en/nfs-security-identifying-and-exploiting-misconfigurations/) में यह देखा जा सकता है कि **अन्य फ़ोल्डरों तक पहुँचने के लिए एक्सपोर्ट से भागना संभव है**।

इसलिए, यदि एक एक्सपोर्ट एक फ़ोल्डर को निर्यात कर रहा है जो **पूरे फ़ाइल सिस्टम** का एक **उपफ़ोल्डर** है, तो यदि **`subtree_check`** अक्षम है तो निर्यात के बाहर फ़ाइलों तक पहुँचना संभव है। और यह **डिफ़ॉल्ट रूप से Linux में अक्षम है**।

उदाहरण के लिए, यदि एक NFS सर्वर `/srv/` को निर्यात कर रहा है और `/var/` उसी फ़ाइल सिस्टम में है, तो `/var/log/` से लॉग पढ़ना या `/var/www/` में एक वेबशेल स्टोर करना संभव है।

इसके अलावा, ध्यान दें कि डिफ़ॉल्ट रूप से केवल रूट (0) उपयोगकर्ता को अनुकरण से सुरक्षित रखा गया है (Squash अनुभाग की जाँच करें)। हालाँकि, यदि एक फ़ाइल **रूट द्वारा स्वामित्व में है लेकिन समूह 0 नहीं है, तो इसे एक्सेस करना संभव है**। उदाहरण के लिए, फ़ाइल `/etc/shadow` रूट द्वारा स्वामित्व में है लेकिन समूह `shadow` है (डेबियन पर gid 42)। इसलिए, इसे डिफ़ॉल्ट रूप से पढ़ना संभव है!

टूल **`nfs_analyze`** [https://github.com/hvs-consulting/nfs-security-tooling](https://github.com/hvs-consulting/nfs-security-tooling) इस हमले का समर्थन करने के लिए बनाया गया है जो फ़ाइल सिस्टम ext4, xfs, btrfs के संस्करण 3 के खिलाफ है (यह v4 में भी संभव होना चाहिए)।

### NSFShell

फ़ाइलों तक पहुँचने के लिए UID और GID को आसानी से सूचीबद्ध, माउंट और बदलने के लिए आप [nfsshell](https://github.com/NetDirect/nfsshell) का उपयोग कर सकते हैं।

[अच्छा NFSShell ट्यूटोरियल।](https://www.pentestpartners.com/security-blog/using-nfsshell-to-compromise-older-environments/)

## कॉन्फ़िग फ़ाइलें
```
/etc/exports
/etc/lib/nfs/etab
```
## Dangerous settings

- **Read and Write Permissions (`rw`):** यह सेटिंग फ़ाइल सिस्टम से पढ़ने और लिखने की अनुमति देती है। इतनी व्यापक पहुँच देने के परिणामों पर विचार करना आवश्यक है।

- **Use of Insecure Ports (`insecure`):** जब सक्षम किया जाता है, तो यह सिस्टम को 1024 से ऊपर के पोर्ट का उपयोग करने की अनुमति देता है। इस रेंज के ऊपर के पोर्ट की सुरक्षा कम सख्त हो सकती है, जिससे जोखिम बढ़ता है।

- **Visibility of Nested File Systems (`nohide`):** यह कॉन्फ़िगरेशन निर्देशिकाओं को दृश्यमान बनाता है, भले ही एक अन्य फ़ाइल सिस्टम एक निर्यातित निर्देशिका के नीचे माउंट किया गया हो। प्रत्येक निर्देशिका के लिए उचित प्रबंधन के लिए अपनी निर्यात प्रविष्टि की आवश्यकता होती है।

- **Root Files Ownership (`no_root_squash`):** इस सेटिंग के साथ, रूट उपयोगकर्ता द्वारा बनाए गए फ़ाइलें अपनी मूल UID/GID 0 बनाए रखती हैं, न्यूनतम विशेषाधिकार के सिद्धांत की अनदेखी करते हुए और संभावित रूप से अत्यधिक अनुमतियाँ प्रदान करती हैं।

- **Non-Squashing of All Users (`no_all_squash`):** यह विकल्प सुनिश्चित करता है कि उपयोगकर्ता पहचान प्रणाली में संरक्षित रहती है, जो यदि सही तरीके से प्रबंधित नहीं की गई तो अनुमति और पहुँच नियंत्रण समस्याओं का कारण बन सकती है।

## Privilege Escalation using NFS misconfigurations

[NFS no_root_squash and no_all_squash privilege escalation](../linux-hardening/privilege-escalation/nfs-no_root_squash-misconfiguration-pe.md)

## HackTricks Automatic Commands
```
Protocol_Name: NFS    #Protocol Abbreviation if there is one.
Port_Number:  2049     #Comma separated if there is more than one.
Protocol_Description: Network File System         #Protocol Abbreviation Spelled out

Entry_1:
Name: Notes
Description: Notes for NFS
Note: |
NFS is a system designed for client/server that enables users to seamlessly access files over a network as though these files were located within a local directory.

#apt install nfs-common
showmount 10.10.10.180      ~or~showmount -e 10.10.10.180
should show you available shares (example /home)

mount -t nfs -o ver=2 10.10.10.180:/home /mnt/
cd /mnt
nano into /etc/passwd and change the uid (probably 1000 or 1001) to match the owner of the files if you are not able to get in

https://book.hacktricks.wiki/en/network-services-pentesting/nfs-service-pentesting.html

Entry_2:
Name: Nmap
Description: Nmap with NFS Scripts
Command: nmap --script=nfs-ls.nse,nfs-showmount.nse,nfs-statfs.nse -p 2049 {IP}
```
{{#include ../banners/hacktricks-training.md}}
