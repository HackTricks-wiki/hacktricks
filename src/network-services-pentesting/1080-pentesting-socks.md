# 1080 - Pentesting Socks

{{#include ../banners/hacktricks-training.md}}

## Informations de base

**SOCKS** est un protocole utilisé pour transférer des données entre un client et un serveur via un proxy. La cinquième version, **SOCKS5**, ajoute une fonctionnalité d'authentification optionnelle, permettant uniquement aux utilisateurs autorisés d'accéder au serveur. Il gère principalement le proxying des connexions TCP et le transfert des paquets UDP (via la commande `UDP ASSOCIATE`), opérant à la couche session (Layer 5) du modèle OSI. Lorsque les outils prennent en charge le schéma `socks5h`, la résolution DNS est forcée via le proxy, empêchant les fuites DNS locales (local DNS leaks) et rendant plus difficile le fingerprinting de l'hôte d'origine.

**Port par défaut :** 1080

## Énumération

### Vérification d'authentification
```bash
nmap -p 1080 <ip> --script socks-auth-info
```
### Brute Force

#### Utilisation de base
```bash
nmap --script socks-brute -p 1080 <ip>
```
#### Utilisation avancée
```bash
nmap  --script socks-brute --script-args userdb=users.txt,passdb=rockyou.txt,unpwdb.timelimit=30m -p 1080 <ip>
```
#### Sortie
```
PORT     STATE SERVICE
1080/tcp open  socks
| socks-brute:
|   Accounts
|     patrik:12345 - Valid credentials
|   Statistics
|_    Performed 1921 guesses in 6 seconds, average tps: 320
```
#### Module Hydra
```bash
hydra -L users.txt -P passwords.txt -s 1080 -t 16 -V <ip> socks5
```
### Méthode & open-proxy énumération
```bash
nmap -sV --script socks-methods,socks-open-proxy -p 1080 <ip>
```
`socks-methods` force le serveur à lister les types d'authentification pris en charge, tandis que `socks-open-proxy` tente un CONNECT sortant pour confirmer si le service peut être abusé comme relais.

#### Vérification brute du handshake
```bash
printf '\x05\x01\x00' | nc -nv <ip> 1080
```
Une réponse `\x05 01 00` indique que SOCKS5 propose "no authentication". Tout `\x00` suivi de `\x02` signifie que username/password est requis, ce qui est utile pour fingerprinting rapidement des appareils exposés dans des scripts.

### Validation rapide de l'egress
```bash
curl --socks5-hostname <ip>:1080 https://ifconfig.me
curl --socks5-hostname user:pass@<ip>:1080 http://internal.target
```
Utilisez `--socks5-hostname` (ou les URL `socks5h://`) afin que la résolution DNS se fasse à distance. Associez-le à `proxychains4 -q nmap -sT -Pn --top-ports 200 <internal-host>` pour vérifier si le proxy offre réellement un accès interne.

### Découverte à l'échelle d'Internet / fingerprinting
```bash
masscan 0.0.0.0/0 -p1080 --banners --rate 100000 -oX socks.xml
```
Renvoyez les résultats dans NSE, `zgrab2`, ou des scripts python personnalisés pour prioriser les hôtes prometteurs (par ex., chaînes de bannière comme `3proxy`, `Dante`, `MikroTik`).


## Tunneling and Port Forwarding

Pour des informations sur tunneling and post forwarding, consultez la page : [Tunneling and Port Forwarding](../generic-hacking/tunneling-and-port-forwarding.md)

## Références

- [Use a SOCKS5 Proxy to Access the Kubernetes API (Kubernetes Docs, 2024)](https://kubernetes.io/docs/tasks/extend-kubernetes/socks5-proxy-access-api)

{{#include ../banners/hacktricks-training.md}}
