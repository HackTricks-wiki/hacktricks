# 1080 - Pentesting Socks

{{#include ../banners/hacktricks-training.md}}

## Основна інформація

**SOCKS** — протокол, який використовується для передачі даних між клієнтом і сервером через проксі. П'ята версія, **SOCKS5**, додає опціональну функцію автентифікації, що дозволяє доступ лише авторизованим користувачам. В основному він обробляє проксування TCP-з'єднань та пересилання UDP-пакетів (через команду `UDP ASSOCIATE`), працюючи на сеансовому рівні (Layer 5) моделі OSI. Коли інструменти підтримують схему `socks5h`, вирішення DNS примусово виконується через проксі, що запобігає локальним DNS leaks і ускладнює ідентифікацію вихідного хоста.

**Порт за замовчуванням:** 1080

## Перерахування

### Перевірка автентифікації
```bash
nmap -p 1080 <ip> --script socks-auth-info
```
### Brute Force

#### Базове використання
```bash
nmap --script socks-brute -p 1080 <ip>
```
#### Розширене використання
```bash
nmap  --script socks-brute --script-args userdb=users.txt,passdb=rockyou.txt,unpwdb.timelimit=30m -p 1080 <ip>
```
#### Вивід
```
PORT     STATE SERVICE
1080/tcp open  socks
| socks-brute:
|   Accounts
|     patrik:12345 - Valid credentials
|   Statistics
|_    Performed 1921 guesses in 6 seconds, average tps: 320
```
#### Hydra модуль
```bash
hydra -L users.txt -P passwords.txt -s 1080 -t 16 -V <ip> socks5
```
### Метод & open-proxy enumeration
```bash
nmap -sV --script socks-methods,socks-open-proxy -p 1080 <ip>
```
`socks-methods` змушує сервер перерахувати підтримувані типи автентифікації, тоді як `socks-open-proxy` намагається виконати outbound CONNECT, щоб підтвердити, чи можна використовувати сервіс як relay.

#### Перевірка raw handshake
```bash
printf '\x05\x01\x00' | nc -nv <ip> 1080
```
Відповідь `\x05 01 00` вказує, що SOCKS5 пропонує "no authentication". Будь-який `\x00`, після якого йде `\x02`, означає, що username/password потрібні — це корисно для швидкого fingerprinting відкритих пристроїв у scripts.

### Швидка валідація egress
```bash
curl --socks5-hostname <ip>:1080 https://ifconfig.me
curl --socks5-hostname user:pass@<ip>:1080 http://internal.target
```
Використовуйте `--socks5-hostname` (або URL `socks5h://`), щоб DNS-резолюція виконувалася віддалено. Поєднайте це з `proxychains4 -q nmap -sT -Pn --top-ports 200 <internal-host>`, щоб перевірити, чи proxy справді забезпечує доступ до внутрішньої мережі.

### Пошук по всьому Інтернету / fingerprinting
```bash
masscan 0.0.0.0/0 -p1080 --banners --rate 100000 -oX socks.xml
```
Поверніть результати назад в NSE, `zgrab2` або власні python-скрипти, щоб надавати пріоритет перспективним хостам (наприклад, рядки банера на кшталт `3proxy`, `Dante`, `MikroTik`).


## Tunneling and Port Forwarding

Для інформації про tunneling and post forwarding перегляньте сторінку: [Tunneling and Port Forwarding](../generic-hacking/tunneling-and-port-forwarding.md)

## Посилання

- [Use a SOCKS5 Proxy to Access the Kubernetes API (Kubernetes Docs, 2024)](https://kubernetes.io/docs/tasks/extend-kubernetes/socks5-proxy-access-api)

{{#include ../banners/hacktricks-training.md}}
