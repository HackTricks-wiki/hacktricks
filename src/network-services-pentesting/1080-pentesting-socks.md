# 1080 - Pentesting Socks

{{#include ../banners/hacktricks-training.md}}

## Podstawowe informacje

**SOCKS** to protokół używany do przesyłania danych między klientem a serwerem przez proxy. Piąta wersja, **SOCKS5**, dodaje opcjonalną funkcję uwierzytelniania, pozwalającą na dostęp do serwera jedynie upoważnionym użytkownikom. Głównie zajmuje się proxyfikacją połączeń TCP oraz przekazywaniem pakietów UDP (za pomocą polecenia `UDP ASSOCIATE`), działając na warstwie sesji (Layer 5) modelu OSI. Gdy narzędzia obsługują schemat `socks5h`, rozwiązywanie DNS jest wymuszane przez proxy, zapobiegając lokalnym DNS leaks i utrudniając fingerprinting hosta źródłowego.

**Default Port:** 1080

## Enumeracja

### Sprawdzenie uwierzytelniania
```bash
nmap -p 1080 <ip> --script socks-auth-info
```
### Brute Force

#### Podstawowe użycie
```bash
nmap --script socks-brute -p 1080 <ip>
```
#### Zaawansowane użycie
```bash
nmap  --script socks-brute --script-args userdb=users.txt,passdb=rockyou.txt,unpwdb.timelimit=30m -p 1080 <ip>
```
#### Wyjście
```
PORT     STATE SERVICE
1080/tcp open  socks
| socks-brute:
|   Accounts
|     patrik:12345 - Valid credentials
|   Statistics
|_    Performed 1921 guesses in 6 seconds, average tps: 320
```
#### Moduł Hydra
```bash
hydra -L users.txt -P passwords.txt -s 1080 -t 16 -V <ip> socks5
```
### Metoda & open-proxy enumeration
```bash
nmap -sV --script socks-methods,socks-open-proxy -p 1080 <ip>
```
`socks-methods` wymusza na serwerze wypisanie obsługiwanych typów uwierzytelniania, natomiast `socks-open-proxy` próbuje wykonać wychodzący CONNECT, aby potwierdzić, czy usługa może być nadużyta jako przekaźnik.

#### Sprawdzenie surowego handshake
```bash
printf '\x05\x01\x00' | nc -nv <ip> 1080
```
Odpowiedź `\x05 01 00` wskazuje, że SOCKS5 oferuje "no authentication". Każde `\x00` po którym następuje `\x02` oznacza, że wymagane jest username/password, co jest przydatne do szybkiego fingerprinting odsłoniętych urządzeń w skryptach.

### Szybka walidacja egressu
```bash
curl --socks5-hostname <ip>:1080 https://ifconfig.me
curl --socks5-hostname user:pass@<ip>:1080 http://internal.target
```
Użyj `--socks5-hostname` (lub `socks5h://` adresów URL), aby rozwiązywanie DNS odbywało się zdalnie. Połącz to z `proxychains4 -q nmap -sT -Pn --top-ports 200 <internal-host>`, aby zweryfikować, czy proxy rzeczywiście zapewnia dostęp do sieci wewnętrznej.

### Odkrywanie w skali internetu / fingerprinting
```bash
masscan 0.0.0.0/0 -p1080 --banners --rate 100000 -oX socks.xml
```
Wprowadź wyniki z powrotem do NSE, `zgrab2` lub niestandardowych skryptów python, aby priorytetyzować obiecujące hosty (np. ciągi bannerów takie jak `3proxy`, `Dante`, `MikroTik`).

## Tunneling and Port Forwarding

Aby uzyskać informacje o tunneling i post forwarding, sprawdź stronę: [Tunneling and Port Forwarding](../generic-hacking/tunneling-and-port-forwarding.md)

## Referencje

- [Use a SOCKS5 Proxy to Access the Kubernetes API (Kubernetes Docs, 2024)](https://kubernetes.io/docs/tasks/extend-kubernetes/socks5-proxy-access-api)

{{#include ../banners/hacktricks-training.md}}
