# 4840 - Pentesting OPC UA

{{#include ../banners/hacktricks-training.md}}


## बुनियादी जानकारी

**OPC UA**, जिसका पूरा नाम **Open Platform Communications Unified Access** है, निर्माण, ऊर्जा, एयरोस्पेस और रक्षा जैसे विभिन्न उद्योगों में डेटा एक्सचेंज और उपकरण नियंत्रण के लिए उपयोग होने वाला एक महत्वपूर्ण open-source protocol है। यह अलग-अलग विक्रेताओं के उपकरणों को एक-दूसरे से संवाद करने में सक्षम बनाता है, खासकर PLCs के साथ।

इसकी कॉन्फ़िगरेशन मजबूत सुरक्षा उपायों की अनुमति देती है, लेकिन अक्सर पुराने उपकरणों के साथ संगतता के लिए इन्हें कम किया जाता है, जिससे सिस्टम जोख़िम में आ जाते हैं। साथ ही, OPC UA services को ढूँढना मुश्किल हो सकता है क्योंकि network scanners उन्हें nonstandard ports पर होने पर पहचान नहीं पाते।

**Default port:** 4840 (binary `opc.tcp`). कई vendors अलग discovery endpoints (`/discovery`), HTTPS bindings (4843/443), या vendor-specific listener ports जैसे 49320 (KepServerEX), 62541 (OPC Foundation reference stack) और 48050 (UaGateway) एक्सपोज़ करते हैं। प्रति होस्ट कई endpoints की उम्मीद रखें, हर एक transport profile, security policy और user-token support का विज्ञापन करता है।

| Built-in NodeId | क्यों यह महत्वपूर्ण है |
| --- | --- |
| `i=2253` (`0:Server`) | इसमें `ServerArray`, vendor/product strings और namespace URIs होते हैं। |
| `i=2256` (`ServerStatus`) | अपटाइम, वर्तमान स्थिति, और वैकल्पिक रूप से बिल्ड जानकारी प्रकट करता है। |
| `i=2267` (`ServerDiagnosticsSummary`) | session counts, aborted requests आदि दिखाता है। brute-force प्रयासों के fingerprinting के लिए बहुत उपयोगी। |
| `i=85` (`ObjectsFolder`) | एक्सपोज़ किए गए device tags, methods और alarms को ब्राउज़ करने का प्रवेश बिंदु। |
```text
PORT     STATE SERVICE REASON
4840/tcp open  unknown syn-ack
```
## Pentesting OPC UA

OPC UA सर्वरों में सुरक्षा समस्याओं का पता लगाने के लिए, इसे [OpalOPC](https://opalopc.com/) से स्कैन करें।
```bash
opalopc -vv opc.tcp://$target_ip_or_hostname:$target_port
```
### Discovery & Enumeration Playbook

1. **Locate all OPC UA transports**
```bash
nmap -sV -Pn -n --open -p 4840,4843,49320,48050,53530,62541 $TARGET
```
यदि वातावरण LDS-ME multicast discovery का उपयोग करता है तो UDP ग्रुप एड्रेस पर भी दोहराएं।

2. **Fingerprint endpoints**
- प्रत्येक ट्रांसपोर्ट पर `FindServers`/`GetEndpoints` कॉल करके `SecurityPolicyUri`, `SecurityMode`, `UserTokenType`, application URI और product strings कैप्चर करें।
- namespaces को enumerate करें ताकि आप vendor-specific NodeIds को resolve कर सकें; namespace collisions का दुरुपयोग करके clients को attacker-controlled schemas लोड करने के लिए मजबूर करें।

3. **Walk the address space**
- `ObjectsFolder (i=85)` से शुरू करें और recursively `Browse`/`Read` करके writable process variables, `Method` nodes और historian/log nodes ढूंढें।
- `ServerStatus.BuildInfo` क्वेरी करके firmware provenance समझें, और `ServerCapabilities.OperationLimits` से अंदाजा लगाएँ कि server resources को exhaust करना कितना आसान है।
- यदि anonymous access की अनुमति है, तो तुरंत maintenance methods पर `Call` टेस्ट करें (उदा., `ns=2;s=Reset`, `ns=2;s=StartMotor`)। कई vendors custom methods पर role permissions बाँधना भूल जाते हैं।

4. **Session abuse**
- अन्य sessions से `AuthenticationToken` मानों का पुन: उपयोग या क्लोन करें (MITM या diagnostics exposure के माध्यम से captured) ताकि मौजूदा subscriptions hijack की जा सकें।
- दर्जनों inactive sessions बनाकर server को `SessionDiagnostics` flooding में डालें; कुछ stacks `MaxSessionCount` सीमा पार होते ही क्रैश हो जाते हैं।

### Automated assessment with OpalOPC

- scanner interactively या headless दोनों रूपों में चल सकता है, जो CI/CD style OT baselines के लिए उपयोगी है। इसकी machine-readable findings को अपनी reporting pipeline में भेजें ताकि anonymous logins, weak policies, certificate validation errors और writable variables मिनटों में हाइलाइट किए जा सकें।
- OpalOPC आउटपुट को manual browsing के साथ मिलाएँ: discovered endpoint list को अपनी custom tooling में वापस फीड करें, फिर selectively high-impact nodes (उदा., `MotorControl/StartStop`, `RecipeManager/Upload`) को weaponize करें।

### Attacking legacy security policies (Basic128Rsa15)

- **Bleichenbacher-style oracle:** जो systems अब भी deprecated `Basic128Rsa15` policy की अनुमति देते हैं (अक्सर build flags जैसे `CMPOPCUASTACK_ALLOW_SHA1_BASED_SECURITY` द्वारा टॉगल होते हैं) padding validation differences को leak करते हैं। crafted PKCS#1 v1.5 blobs के साथ `CreateSession` / `OpenSecureChannel` handshakes को flood करके server certificate का private key recover करें, फिर server को impersonate करें या ट्रैफ़िक decrypt करें।
- **Authentication bypass:** OPC Foundation’s .NET Standard stack prior to 1.5.374.158 (CVE-2024-42512) और उसके dependent products unauthenticated attackers को उस legacy policy को मजबूर करने और application-level authentication छोड़ने की अनुमति देते हैं। एक बार जब आप key material पर कब्ज़ा कर लेते हैं, तो arbitrary `UserIdentityTokens` पेश कर सकते हैं, signed `ActivateSession` requests replay कर सकते हैं, और plant को trusted engineering workstation की तरह operate कर सकते हैं।
- **Operational workflow:**
1. `GetEndpoints` से policies enumerate करें और किसी भी `Basic128Rsa15` एंट्री को नोट करें।
2. उस policy को स्पष्ट रूप से negotiate करें (`SecurityPolicyUri` को `CreateSession` में सेट करके), फिर अपने oracle loop को चलाएँ जब तक recovered key validate न हो जाए।
3. Key का दुरुपयोग करके high-privilege session बनाने, roles बदलने, या rogue reverse proxy बनकर अन्य clients को चुपचाप downgrade करने का प्रयास करें।
- OPC Foundation ने साथ ही HTTPS bindings के लिए CVE-2024-42513 भी प्रकाशित किया। भले ही आपकी target TLS का दावा करे, सुनिश्चित करें कि proxy के पीछे binary transport के लिए वह चुपचाप Basic128Rsa15 पर fallback नहीं कर रहा है।

### Crafting OPC UA clients for exploitation

- **Custom clients:** Drop-in libraries (python-opcua/asyncua, node-opcua, open62541) आपको खुद exploit logic चलाने देती हैं। हमेशा अपने target namespace index को enforce करें ताकि vendors firmware updates के बाद namespaces reorder करने पर accidental cross-namespace writes से बचा जा सके।
- **Node abuse checklist:**
- `HistoryRead` production tags पर चलाकर proprietary recipes का snapshot लें।
- `TranslateBrowsePathsToNodeIds` का उपयोग करके human-readable asset names को NodeIds में resolve करें जिन्हें Claroty के framework जैसे gadgets को फीड किया जा सके।
- `Call` + `Method` nodes से maintenance tasks (firmware upload, calibration, device reboots) ट्रिगर करें।
- `RegisterNodes` का गलत उपयोग करके बार-बार उपयोग किए जाने वाले nodes को pin करें और फिर handles को कभी रिलीज न करके legitimate clients को starve कर दें।
- **Session hardening tests:** बेहद कम publishing intervals (50 ms से कम) और oversized monitored-item queues के साथ दर्जनों subscriptions bind करने का प्रयास करें। कई stacks `RevisedPublishingInterval` को गलत गणना करते हैं और scheduler overflows के कारण crash हो जाते हैं।

### Fuzzing & exploit development tooling

Claroty Team82 ने एक open-source `opcua-exploit-framework` जारी किया है जो Pwn2Own-ग्रेड रिसर्च को reusable modules में पैकेज करता है:

- **Modes:** `sanity` (lightweight reads/browses), `attacks` (उदा., thread pool starvation, file upload DoS), `corpus` (replay fuzzing payloads), `server` (rogue OPC UA server to backdoor clients)।
- **Usage pattern:**
```bash
# Run a DoS attack against a Prosys Simulation Server endpoint
python3 main.py prosys 10.10.10.10 53530 /OPCUA/SimulationServer thread_pool_wait_starvation

# Replay an entire Boofuzz corpus against open62541
python3 main.py open62541 192.168.1.50 4840 / opcua_message_boofuzz_db input_corpus_minimized/opcua.db
```
- **Rogue server scenario:** bundled asyncua-based server आपको malicious address spaces serve करके client software को target करने देता है (उदा., oversized `ExtensionObject`s के साथ responses, जो UA Expert clones में parsing bugs ट्रिगर कर सकते हैं)।
- **Target coverage:** Built-in profiles Kepware, Ignition, Unified Automation, Softing SIS, Triangle Microworks, Node-OPCUA, Python OPC UA, Milo, open62541, आदि से मैप होती हैं, ताकि आप बिना payloads री-राइट किए तेजी से stacks बदल सकें।
- **Integration tips:** इसका output अपने fuzzers के साथ chain करें—पहले `corpus` payloads स्प्रे करें, फिर OpalOPC से री-चेक कराएँ कि crash ने insecure defaults (anonymous login, setpoint write access, आदि) को पुनर्स्थापित किया है या नहीं।

### Exploiting authentication bypasses

यदि authentication bypass vulnerabilities मिलती हैं, तो आप एक [OPC UA client](https://www.prosysopc.com/products/opc-ua-browser/) को तदनुसार कॉन्फ़िगर करके देख सकते हैं कि आपको क्या access मिलता है। यह सिर्फ process values पढ़ने से लेकर heavy-duty industrial equipment को वास्तव में operate करने तक कुछ भी अनुमति दे सकता है।

डिवाइस के बारे में संकेत पाने के लिए, address space में "ServerStatus" node के मान पढ़ें और usage manual के लिए google करें।

## Shodan

- `port:4840`
- `port:62541 "OPC UA"`
- `ssl:"urn:opcua"`
- `product:"opc ua"`

vendor strings (`"Ignition OPC UA"`, `"KepServerEX"`) या certificates (`"CN=UaServerCert"`) के साथ search को combine करें ताकि intrusive testing शुरू करने से पहले high-value assets को प्राथमिकता दी जा सके।

## References

- [https://opalopc.com/how-to-hack-opc-ua/](https://opalopc.com/how-to-hack-opc-ua/)
- [https://github.com/claroty/opcua-exploit-framework](https://github.com/claroty/opcua-exploit-framework)
- [https://certvde.com/en/advisories/VDE-2025-022/](https://certvde.com/en/advisories/VDE-2025-022/)


{{#include ../banners/hacktricks-training.md}}
