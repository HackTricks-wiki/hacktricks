# 4840 - Pentesting OPC UA

{{#include ../banners/hacktricks-training.md}}


## Basic Information

**OPC UA**, standing for **Open Platform Communications Unified Access**, è un protocollo open-source cruciale utilizzato in vari settori come Manufacturing, Energy, Aerospace e Defence per lo scambio di dati e il controllo delle apparecchiature. Permette in modo unico ai dispositivi di diversi vendor di comunicare tra loro, in particolare con i PLC.

La sua configurazione permette misure di sicurezza robuste, ma spesso, per compatibilità con dispositivi più vecchi, queste vengono attenuate, esponendo i sistemi a rischi. Inoltre, trovare servizi OPC UA può essere complicato visto che gli scanner di rete potrebbero non rilevarli se sono su porte non standard.

**Default port:** 4840 (binario `opc.tcp`). Molti vendor espongono endpoint di discovery separati (`/discovery`), binding HTTPS (4843/443), o porte listener specifiche del vendor come 49320 (KepServerEX), 62541 (OPC Foundation reference stack) e 48050 (UaGateway). Aspettati più endpoint per host, ognuno che pubblicizza transport profile, security policy e user-token support.

| Built-in NodeId | Why it matters |
| --- | --- |
| `i=2253` (`0:Server`) | Contiene `ServerArray`, stringhe vendor/product e namespace URI.
| `i=2256` (`ServerStatus`) | Rivela uptime, stato corrente e opzionalmente informazioni di build.
| `i=2267` (`ServerDiagnosticsSummary`) | Mostra conteggi di sessioni, richieste abortite, ecc. Ottimo per fingerprinting di brute-force attempts.
| `i=85` (`ObjectsFolder`) | Punto d'ingresso per esplorare tag esposti del dispositivo, methods e allarmi.
```text
PORT     STATE SERVICE REASON
4840/tcp open  unknown syn-ack
```
## Pentesting OPC UA

Per rivelare problemi di sicurezza nei server OPC UA, scansionali con [OpalOPC](https://opalopc.com/).
```bash
opalopc -vv opc.tcp://$target_ip_or_hostname:$target_port
```
### Playbook di Scoperta e Enumerazione

1. **Individua tutti i trasporti OPC UA**
```bash
nmap -sV -Pn -n --open -p 4840,4843,49320,48050,53530,62541 $TARGET
```
Ripeti sugli indirizzi di gruppo UDP se l'ambiente usa LDS-ME multicast discovery.

2. **Fingerprint degli endpoint**
- Invoca `FindServers`/`GetEndpoints` su ogni trasporto per catturare `SecurityPolicyUri`, `SecurityMode`, `UserTokenType`, application URI e stringhe di prodotto.
- Enumera gli namespace così da poter risolvere NodeIds specifici del vendor; abusa delle collisioni di namespace per indurre i client a caricare schemi controllati dall'attaccante.

3. **Esplora lo spazio degli indirizzi**
- Parti da `ObjectsFolder (i=85)` e ricorsivamente `Browse`/`Read` per trovare variabili di processo scrivibili, nodi `Method` e nodi di historian/log.
- Interroga `ServerStatus.BuildInfo` per capire la provenienza del firmware, e `ServerCapabilities.OperationLimits` per valutare quanto sia facile esaurire le risorse del server.
- Se l'accesso anonymous è consentito, testa immediatamente `Call` su metodi di manutenzione (es., `ns=2;s=Reset`, `ns=2;s=StartMotor`). Molti vendor dimenticano di vincolare i permessi di ruolo ai metodi custom.

4. **Abuso delle sessioni**
- Riusa o clona i valori di `AuthenticationToken` di altre sessioni (catturati via MITM o esposizione diagnostica) per dirottare subscription esistenti.
- Forza il server in un flooding di `SessionDiagnostics` creando dozzine di sessioni inattive; alcuni stack vanno in crash una volta superato il limite `MaxSessionCount`.

### Valutazione automatizzata con OpalOPC

- Lo scanner può essere eseguito in modalità interattiva o headless, utile per baseline OT in stile CI/CD. Inoltra i suoi risultati machine-readable nella tua pipeline di reporting per evidenziare anonymous logins, policy deboli, errori di validazione dei certificati e variabili scrivibili in pochi minuti.
- Combina l'output di OpalOPC con il browsing manuale: reinserisci la lista di endpoint scoperti nel tuo tooling custom, quindi strumentalizza selettivamente i nodi ad alto impatto (es., `MotorControl/StartStop`, `RecipeManager/Upload`).

### Attaccare policy di sicurezza legacy (Basic128Rsa15)

- **Bleichenbacher-style oracle:** I sistemi che ancora permettono la policy deprecata `Basic128Rsa15` (spesso attivata tramite flag di build come `CMPOPCUASTACK_ALLOW_SHA1_BASED_SECURITY`) leak differenze nella validazione del padding. Sfrutta questo inondando gli handshake `CreateSession` / `OpenSecureChannel` con blob PKCS#1 v1.5 appositamente costruiti per recuperare la chiave privata del certificato del server, quindi impersona il server o decritta il traffico.
- **Authentication bypass:** Lo stack .NET Standard di OPC Foundation precedente alla 1.5.374.158 (CVE-2024-42512) e i prodotti dipendenti permettono ad attaccanti non autenticati di forzare quella policy legacy e successivamente saltare l'autenticazione a livello applicativo. Una volta in possesso del materiale chiave puoi presentare arbitrari `UserIdentityTokens`, replayare `ActivateSession` firmate e operare l'impianto come un engineering workstation fidato.
- **Workflow operativo:**
1. Enumera le policy con `GetEndpoints` e annota eventuali voci `Basic128Rsa15`.
2. Negozia esplicitamente quella policy (`SecurityPolicyUri` in `CreateSession`), poi esegui il loop dell'oracolo finché la chiave recuperata non viene validata.
3. Abusa della chiave per forgiare una sessione ad alto privilegio, cambiare ruoli o degradare silenziosamente altri client agendo come rogue reverse proxy.
- **CODESYS Runtime Toolkit (<3.5.21.0)** riabilitava Basic128Rsa15 ogni volta che gli integratori compilavano con `CMPOPCUASTACK_ALLOW_SHA1_BASED_SECURITY`. Inverti quel flag, riesegui il workflow dell'oracolo sopra e puoi leak la chiave privata del runtime per impersonare trusted engineering workstation fino a quando non viene applicato il fix 3.5.21.0 o successivo.
- OPC Foundation ha pubblicato contemporaneamente CVE-2024-42513 per i binding HTTPS. Anche se il target dichiara TLS, assicurati che non stia silenziosamente ricadendo su Basic128Rsa15 per il trasporto binario dietro al proxy.

### Watchlist exploit 2024-2025

- **open62541 fuzz_binary_decode (CVE-2024-53429):** Chunks di SecureChannel che dichiarano corpi `ExtensionObject` sovradimensionati fanno sì che il decoder dereferenzi memoria già freed, quindi un pre-auth attacker può ripetutamente crashare UA server che embedano open62541 ≤1.4.6. Riutilizza il corpus Claroty (`opcua_message_boofuzz_db`) o crea il tuo harness Boofuzz per spamare mutate `OpenSecureChannel` fino a che il watchdog non uccide il processo; poi riesegui la enumerazione perché molti integratori ricadono in anonymous mode dopo il reboot.
- **Softing OPC UA C++ SDK / edgeConnector / edgeAggregator (CVE-2025-7390):** La pipeline TLS client-auth accetta qualsiasi certificato che replaya un Common Name trusted, quindi puoi mintare un cert usa-e-getta, copiare il CN da un plant engineer e loggarti con arbitrari `UserNameIdentityToken` o `IssuedIdentityToken`. Abbina questo a un downgrade a Basic128Rsa15 per rimuovere i controlli di integrità e impersonare persistentemente gli operatori fino a quando le trustlist non vengono ricostruite.

### Creare client OPC UA per lo sfruttamento

- **Custom clients:** Drop-in libraries (python-opcua/asyncua, node-opcua, open62541) permettono di guidare la logica di exploit direttamente. Applica sempre l'indice di namespace target per evitare scritture cross-namespace accidentali quando i vendor riorganizzano gli namespace dopo aggiornamenti firmware.
- **Checklist per abuso dei nodi:**
- `HistoryRead` su tag di produzione per catturare snapshot di recipe proprietarie.
- `TranslateBrowsePathsToNodeIds` per risolvere nomi asset leggibili in NodeIds che possono essere alimentati in gadget come il framework di Claroty.
- `Call` + nodi `Method` per triggerare task di manutenzione (upload firmware, calibrazione, reboot dispositivi).
- Uso improprio di `RegisterNodes` per ancorare nodi frequentemente accessi e poi affamare i client legittimi non rilasciando mai gli handle.
- **Test di hardening delle sessioni:** Prova a legare dozzine di subscription con publishing interval estremamente bassi (sotto 50 ms) più code di monitored-item sovradimensionate. Molti stack ricalcolano male `RevisedPublishingInterval` e vanno in crash per overflow del scheduler.

### Fuzzing & tooling per sviluppo exploit

Claroty Team82 ha rilasciato un `opcua-exploit-framework` open-source che confeziona anni di ricerca Pwn2Own-grade in moduli riutilizzabili:

- **Modes:** `sanity` (reads/browses leggeri), `attacks` (es., thread pool starvation, file upload DoS), `corpus` (replay fuzzing payloads), `server` (rogue OPC UA server per backdoorare client).
- **Pattern di uso:**
```bash
# Run a DoS attack against a Prosys Simulation Server endpoint
python3 main.py prosys 10.10.10.10 53530 /OPCUA/SimulationServer thread_pool_wait_starvation

# Replay an entire Boofuzz corpus against open62541
python3 main.py open62541 192.168.1.50 4840 / opcua_message_boofuzz_db input_corpus_minimized/opcua.db
```
- **Rogue server scenario:** Il server basato su asyncua incluso permette di targettare software client servendo address space malevoli (per esempio, risposte con `ExtensionObject` sovradimensionati per triggerare bug di parsing in clone di UA Expert).
- **Coverage target:** I profili integrati mappano a Kepware, Ignition, Unified Automation, Softing SIS, Triangle Microworks, Node-OPCUA, Python OPC UA, Milo, open62541, ecc., così puoi scambiare rapidamente tra stack senza riscrivere payload.
- **Suggerimenti di integrazione:** Catena il suo output con i tuoi fuzzers—spruzza i payload `corpus` prima, poi fai verificare da OpalOPC se il crash ha resuscitato default insicuri (anonymous login, setpoint write access, ecc.).

### Sfruttare bypass di autenticazione

Se vengono trovate vulnerabilità di authentication bypass, puoi configurare un [OPC UA client](https://www.prosysopc.com/products/opc-ua-browser/) di conseguenza e vedere cosa è accessibile. Questo può permettere di tutto, dalla semplice lettura di valori di processo fino al controllo di apparecchiature industriali pesanti.

Per farti un'idea del dispositivo a cui hai accesso, leggi i valori del nodo "ServerStatus" nello spazio degli indirizzi e cerca su Google il manuale d'uso.

## Shodan

- `port:4840`
- `port:62541 "OPC UA"`
- `ssl:"urn:opcua"`
- `product:"opc ua"`

Combina la ricerca con stringhe vendor (`"Ignition OPC UA"`, `"KepServerEX"`) o certificati (`"CN=UaServerCert"`) per prioritizzare asset ad alto valore prima di iniziare test intrusivi.

## Riferimenti

- [https://opalopc.com/how-to-hack-opc-ua/](https://opalopc.com/how-to-hack-opc-ua/)
- [https://github.com/claroty/opcua-exploit-framework](https://github.com/claroty/opcua-exploit-framework)
- [https://certvde.com/en/advisories/VDE-2025-022/](https://certvde.com/en/advisories/VDE-2025-022/)
- [https://nvd.nist.gov/vuln/detail/CVE-2024-53429](https://nvd.nist.gov/vuln/detail/CVE-2024-53429)
- [https://industrial.softing.com/fileadmin/psirt/downloads/2025/CVE-2025-7390.html](https://industrial.softing.com/fileadmin/psirt/downloads/2025/CVE-2025-7390.html)


{{#include ../banners/hacktricks-training.md}}
