# 4840 - Pentesting OPC UA

{{#include ../banners/hacktricks-training.md}}


## 基本情報

**OPC UA**, standing for **Open Platform Communications Unified Access**, は、製造、エネルギー、航空宇宙、及び防衛などのさまざまな業界でデータ交換や設備制御に使われる重要なオープンソースプロトコルです。特に PLC のような異なるベンダーの機器同士の通信を可能にします。

設定により強力なセキュリティ対策を実装できますが、古い機器との互換性を保つためにこれらが緩められていることが多く、システムをリスクにさらします。さらに、OPC UA サービスは非標準ポート上にあるとネットワークスキャナが検出できないことがあり、発見が難しい場合があります。

**Default port:** 4840 (バイナリ `opc.tcp`). 多くのベンダーは個別の discovery エンドポイント（`/discovery`）、HTTPS バインディング（4843/443）、または 49320 (KepServerEX)、62541 (OPC Foundation reference stack)、48050 (UaGateway) のようなベンダー固有のリスナーポートを公開しています。ホストごとに複数のエンドポイントが存在し、それぞれがトランスポートプロファイル、セキュリティポリシー、ユーザートークンのサポートを提示します。

| 組み込み NodeId | 重要性 |
| --- | --- |
| `i=2253` (`0:Server`) | `ServerArray`、ベンダー/製品の文字列、namespace URI を保持します。 
| `i=2256` (`ServerStatus`) | アップタイム、現在の状態、およびオプションでビルド情報を明らかにします。
| `i=2267` (`ServerDiagnosticsSummary`) | セッション数、中断されたリクエストなどを示します。brute-force の試行をフィンガープリンティングするのに最適です。
| `i=85` (`ObjectsFolder`) | 公開されたデバイスのタグ、メソッド、アラームを巡回するためのエントリポイントです。
```text
PORT     STATE SERVICE REASON
4840/tcp open  unknown syn-ack
```
## Pentesting OPC UA

OPC UA サーバーのセキュリティ上の問題を明らかにするには、[OpalOPC](https://opalopc.com/)でスキャンしてください。
```bash
opalopc -vv opc.tcp://$target_ip_or_hostname:$target_port
```
### 検出と列挙プレイブック

1. **すべての OPC UA トランスポートを特定する**
```bash
nmap -sV -Pn -n --open -p 4840,4843,49320,48050,53530,62541 $TARGET
```
環境が LDS-ME マルチキャスト探索を使用している場合は、UDP グループアドレスでも繰り返す。

2. **エンドポイントのフィンガープリント**
- 各トランスポート上で `FindServers`/`GetEndpoints` を呼び出し、`SecurityPolicyUri`、`SecurityMode`、`UserTokenType`、アプリケーションURIや製品文字列を取得する。
- 名前空間を列挙してベンダー固有の NodeIds を解決できるようにする。名前空間の衝突を悪用してクライアントに攻撃者管理下のスキーマを読み込ませる。

3. **アドレス空間を走査する**
- `ObjectsFolder (i=85)` から開始し、再帰的に `Browse`/`Read` を行って、書き込み可能なプロセス変数、`Method` ノード、ヒストリアン／ログノードを見つける。
- `ServerStatus.BuildInfo` を照会してファームウェアの由来を把握し、`ServerCapabilities.OperationLimits` を確認してサーバ資源を枯渇させやすいか評価する。
- 匿名アクセスが許可されている場合は、メンテナンス用メソッド（例: `ns=2;s=Reset`, `ns=2;s=StartMotor`）に対して即座に `Call` を試す。多くのベンダーはカスタムメソッドに対してロール権限を正しく結びつけ忘れている。

4. **セッションの悪用**
- 他セッションから取得した（MITM や診断情報で露出した）`AuthenticationToken` 値を再利用またはクローンして既存のサブスクリプションを乗っ取る。
- 数十のアイドルセッションを作成して `SessionDiagnostics` の洪水を誘発する。`MaxSessionCount` 制限を超えると一部のスタックはクラッシュする。

### OpalOPC による自動評価

- スキャナは対話モードまたはヘッドレスで実行でき、CI/CD 風の OT ベースラインに便利。機械可読な結果を報告パイプラインに流し込み、匿名ログイン、弱いポリシー、証明書検証エラー、書き込み可能な変数を数分でハイライトできる。
- OpalOPC の出力を手動ブラウズと組み合わせる：発見したエンドポイント一覧を自作ツールに戻し、高インパクトなノード（例: `MotorControl/StartStop`, `RecipeManager/Upload`）を選択的に weaponize する。

### レガシーセキュリティポリシー (Basic128Rsa15) への攻撃

- **Bleichenbacher-style oracle:** 廃止された `Basic128Rsa15` ポリシーをまだ許可しているシステム（`CMPOPCUASTACK_ALLOW_SHA1_BASED_SECURITY` のようなビルドフラグで切り替えられることが多い）はパディング検証の差異を leak する。`CreateSession` / `OpenSecureChannel` ハンドシェイクに対して細工した PKCS#1 v1.5 ブロブを大量に送ってオラクル攻撃を行い、サーバ証明書の秘密鍵を復元してサーバのなりすましやトラフィックの復号を行う。
- **Authentication bypass:** OPC Foundation の .NET Standard スタック（1.5.374.158 未満、CVE-2024-42512）およびそれに依存する製品は、未認証の攻撃者がそのレガシーポリシーを強制し、結果的にアプリケーションレベル認証をスキップさせることを許す。鍵素材を掌握すれば任意の `UserIdentityTokens` を提示したり、署名済みの `ActivateSession` リクエストをリプレイして、信頼されたエンジニアリングワークステーションとしてプラントを操ることができる。
- **運用ワークフロー:**
  1. `GetEndpoints` でポリシーを列挙し、`Basic128Rsa15` のエントリを確認する。
  2. 明示的にそのポリシーでネゴシエートする（`CreateSession` の `SecurityPolicyUri`）、オラクルループを回して鍵が復元されるまで続ける。
  3. 復元した鍵を悪用して高権限セッションを偽造、ロールを切替、またはローグリバースプロキシとして他クライアントを静かにダウングレードする。
- OPC Foundation は同時に HTTPS バインディング向けの CVE-2024-42513 も公開している。ターゲットが TLS を主張していても、プロキシの背後でバイナリトランスポートが暗黙に Basic128Rsa15 にフォールバックしていないか確認すること。

### 悪用のための OPC UA クライアント作成

- **カスタムクライアント:** drop-in ライブラリ（python-opcua/asyncua、node-opcua、open62541）を使えば自分でエクスプロイトロジックを組める。ベンダーがファームウェア更新で名前空間を並べ替えることがあるため、ターゲットの namespace index を常に厳格に指定して誤ってクロスネームスペースへの書き込みを防ぐ。
- **ノード悪用チェックリスト:**
  - `HistoryRead` を使ってプロダクションタグのレシピをスナップショットする。
  - `TranslateBrowsePathsToNodeIds` で人間可読な資産名を NodeIds に解決し、Claroty のフレームワーク等のガジェットに渡す。
  - `Call` + `Method` ノードでメンテナンスタスク（ファームウェアアップロード、キャリブレーション、デバイス再起動）をトリガする。
  - `RegisterNodes` の悪用で頻繁にアクセスされるノードをピン止めし、ハンドルを解放しないことで正規クライアントを枯渇させる。
- **セッション強化テスト:** 非常に短い公開間隔（50 ms 未満）かつ過大な monitored-item キューで多数のサブスクリプションをバインドしてみる。多くのスタックは `RevisedPublishingInterval` を誤算定し、スケジューラのオーバーフローでクラッシュする。

### Fuzzing とエクスプロイト開発ツール

Claroty Team82 は長年の Pwn2Own レベルの研究を再利用可能なモジュールにまとめたオープンソースの `opcua-exploit-framework` を公開している:

- **モード:** `sanity`（軽量な read/browse）、`attacks`（例: スレッドプール枯渇、ファイルアップロード DoS）、`corpus`（リプレイ型ファズペイロード）、`server`（クライアントをバックドアするローグ OPC UA サーバ）。
- **使用例パターン:**
```bash
# Run a DoS attack against a Prosys Simulation Server endpoint
python3 main.py prosys 10.10.10.10 53530 /OPCUA/SimulationServer thread_pool_wait_starvation

# Replay an entire Boofuzz corpus against open62541
python3 main.py open62541 192.168.1.50 4840 / opcua_message_boofuzz_db input_corpus_minimized/opcua.db
```
- **ローグサーバシナリオ:** 同梱の asyncua ベースのサーバは悪意あるアドレス空間を提供してクライアントソフトを狙える（例: 過大な `ExtensionObject` を返して UA Expert クローンのパーサバグを誘発する）。
- **ターゲットカバレッジ:** 組み込みのプロファイルは Kepware、Ignition、Unified Automation、Softing SIS、Triangle Microworks、Node-OPCUA、Python OPC UA、Milo、open62541 等にマッピングされているため、ペイロードを書き換えずにスタックを素早く切り替えられる。
- **統合のコツ:** 自分のファザーとチェーンして使う — まず `corpus` ペイロードを散布し、続いて OpalOPC に再検証させてクラッシュで不安全なデフォルト（匿名ログイン、セットポイント書き込みなど）が復活していないか確認する。

### 認証バイパスの悪用

認証バイパスの脆弱性が見つかった場合は、対応する [OPC UA client](https://www.prosysopc.com/products/opc-ua-browser/) を設定してアクセスできる内容を確認する。これによりプロセス値の単純な読み取りから実際の大型産業機器の操作まで可能になることがある。

アクセスしているデバイスの手がかりを得るには、アドレス空間の "ServerStatus" ノード値を読み取り、使用マニュアルを Google で検索する。

## Shodan

- `port:4840`
- `port:62541 "OPC UA"`
- `ssl:"urn:opcua"`
- `product:"opc ua"`

検索をベンダーストリング（`"Ignition OPC UA"`, `"KepServerEX"`）や証明書（`"CN=UaServerCert"`）と組み合わせて、侵入的なテストを始める前に価値の高い資産を優先順位付けする。

## References

- [https://opalopc.com/how-to-hack-opc-ua/](https://opalopc.com/how-to-hack-opc-ua/)
- [https://github.com/claroty/opcua-exploit-framework](https://github.com/claroty/opcua-exploit-framework)
- [https://certvde.com/en/advisories/VDE-2025-022/](https://certvde.com/en/advisories/VDE-2025-022/)


{{#include ../banners/hacktricks-training.md}}
