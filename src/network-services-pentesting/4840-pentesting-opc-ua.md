# 4840 - Pentesting OPC UA

{{#include ../banners/hacktricks-training.md}}


## Podstawowe informacje

**OPC UA** (Open Platform Communications Unified Access) jest istotnym otwartoźródłowym protokołem używanym w różnych branżach, takich jak Manufacturing, Energy, Aerospace i Defence, do wymiany danych i sterowania urządzeniami. Umożliwia komunikację sprzętu różnych dostawców, szczególnie z PLC.

Jego konfiguracja pozwala na silne środki bezpieczeństwa, ale często, ze względu na kompatybilność ze starszymi urządzeniami, są one osłabiane, narażając systemy na ryzyko. Dodatkowo, odnalezienie usług OPC UA może być trudne, ponieważ skanery sieciowe mogą ich nie wykryć, jeśli działają na niestandardowych portach.

Domyślny port: 4840 (binary `opc.tcp`). Wielu dostawców udostępnia oddzielne discovery endpoints (`/discovery`), HTTPS bindings (4843/443) lub specyficzne porty nasłuchu, takie jak 49320 (KepServerEX), 62541 (OPC Foundation reference stack) i 48050 (UaGateway). Oczekuj wielu endpointów na host, z których każdy reklamuje transport profile, security policy i obsługę user-token.

| Built-in NodeId | Why it matters |
| --- | --- |
| `i=2253` (`0:Server`) | Zawiera `ServerArray`, vendor/product strings i namespace URIs.
| `i=2256` (`ServerStatus`) | Ujawnia uptime, aktualny stan i opcjonalnie build info.
| `i=2267` (`ServerDiagnosticsSummary`) | Pokazuje liczby sesji, aborted requests, itp. Świetne do fingerprinting brute-force attempts.
| `i=85` (`ObjectsFolder`) | Punkt wejścia do przeglądania exposed device tags, methods i alarms.
```text
PORT     STATE SERVICE REASON
4840/tcp open  unknown syn-ack
```
## Pentesting OPC UA

Aby ujawnić luki bezpieczeństwa w serwerach OPC UA, przeskanuj je za pomocą [OpalOPC](https://opalopc.com/).
```bash
opalopc -vv opc.tcp://$target_ip_or_hostname:$target_port
```
### Playbook odkrywania i enumeracji

1. **Zlokalizuj wszystkie transporty OPC UA**
```bash
nmap -sV -Pn -n --open -p 4840,4843,49320,48050,53530,62541 $TARGET
```
Powtórz dla adresów grup UDP, jeśli środowisko używa odkrywania multicast LDS-ME.

2. **Identyfikacja punktów końcowych**
- Wywołaj `FindServers`/`GetEndpoints` przez każdy transport, aby uchwycić `SecurityPolicyUri`, `SecurityMode`, `UserTokenType`, application URI i łańcuchy produktu.
- Enumeruj przestrzenie nazw, aby móc rozwiązać specyficzne dla dostawcy NodeId; wykorzystaj kolizje przestrzeni nazw, aby skłonić klientów do załadowania schematów kontrolowanych przez atakującego.

3. **Przeglądaj przestrzeń adresową**
- Zacznij od `ObjectsFolder (i=85)` i rekurencyjnie `Browse`/`Read`, aby znaleźć zapisywalne zmienne procesu, węzły `Method` oraz węzły historyczne/logujące.
- Zapytaj o `ServerStatus.BuildInfo`, aby zrozumieć pochodzenie firmware, oraz `ServerCapabilities.OperationLimits`, aby ocenić, jak łatwo można wyczerpać zasoby serwera.
- Jeśli dostęp anonimowy jest dozwolony, natychmiast testuj `Call` na metodach konserwacyjnych (np. `ns=2;s=Reset`, `ns=2;s=StartMotor`). Wielu dostawców zapomina powiązać uprawnienia ról z niestandardowymi metodami.

4. **Nadużycie sesji**
- Reuse lub sklonuj wartości `AuthenticationToken` z innych sesji (uchwyconych przez MITM lub ujawnienie diagnostyki), aby przejąć istniejące subskrypcje.
- Zmuszaj serwer do floodowania `SessionDiagnostics`, tworząc dziesiątki nieaktywnych sesji; niektóre stosy padają po przekroczeniu limitu `MaxSessionCount`.

### Automatyczna ocena za pomocą OpalOPC

- Skaner może działać interaktywnie lub headless, co jest przydatne do CI/CD-owych baseline'ów OT. Przepuszczaj jego wyniki w formacie maszynowym do pipeline raportowania, aby w kilka minut uwidocznić anonimowe loginy, słabe polityki, błędy walidacji certyfikatów i zapisywalne zmienne.
- Połącz output OpalOPC z ręcznym przeglądaniem: wprowadź odkrytą listę endpointów z powrotem do własnych narzędzi, a następnie selektywnie zbrojkiwuj węzły o dużym wpływie (np. `MotorControl/StartStop`, `RecipeManager/Upload`).

### Attacking legacy security policies (Basic128Rsa15)

- Bleichenbacher-style oracle: Systemy, które nadal pozwalają na przestarzałą politykę `Basic128Rsa15` (często włączaną przez flagi build takie jak `CMPOPCUASTACK_ALLOW_SHA1_BASED_SECURITY`) leak różnice w walidacji paddingu. Wykorzystaj to, zalewając `CreateSession` / `OpenSecureChannel` handshake’y spreparowanymi blobami PKCS#1 v1.5, aby odtworzyć prywatny klucz certyfikatu serwera, po czym podszywaj się pod serwer lub odszyfruj ruch.
- Authentication bypass: Stos .NET Standard od OPC Foundation przed wersją 1.5.374.158 (CVE-2024-42512) oraz produkty zależne pozwalają nieautoryzowanym atakującym wymusić tę legacy politykę i następnie pominąć uwierzytelnianie na poziomie aplikacji. Gdy przejmiesz materiale klucza, możesz przedstawić dowolne `UserIdentityTokens`, replayować podpisane żądania `ActivateSession` i działać w zakładzie jako zaufana stacja inżynierska.
- Przebieg operacyjny:
1. Wyszczególnij polityki za pomocą `GetEndpoints` i zanotuj wpisy `Basic128Rsa15`.
2. Negocjuj tę politykę jawnie (`SecurityPolicyUri` w `CreateSession`), potem uruchom pętlę swojego oracla aż odzyskany klucz zostanie zweryfikowany.
3. Wykorzystaj klucz do sfałszowania sesji z wysokimi uprawnieniami, zmiany ról albo cichego downgrade’u innych klientów działając jako złośliwy reverse proxy.
- CODESYS Runtime Toolkit (<3.5.21.0) ponownie włączał Basic128Rsa15 zawsze, gdy integratorzy kompilowali z `CMPOPCUASTACK_ALLOW_SHA1_BASED_SECURITY`. Przełącz tę flagę, ponów workflow oracla powyżej i możesz leakować prywatny klucz runtime, aby podszywać się pod zaufane stacje inżynierskie aż do wdrożenia poprawki 3.5.21.0 lub nowszej.
- OPC Foundation równocześnie opublikował CVE-2024-42513 dla powiązań HTTPS. Nawet jeśli cel deklaruje TLS, upewnij się, że nie cofa się cicho do Basic128Rsa15 dla binarnego transportu za proxy.

### Lista exploitów 2024-2025

- **open62541 fuzz_binary_decode (CVE-2024-53429):** SecureChannel chunks, które deklarują nadmierne rozmiary ciał `ExtensionObject`, powodują, że dekoder odwołuje się do zwolnionej pamięci, więc pre-auth attacker może wielokrotnie wyłączyć serwery UA osadzone na open62541 ≤1.4.6. Wykorzystaj korpus Claroty (`opcua_message_boofuzz_db`) lub stwórz własny harness Boofuzz, aby spamować zmutowanymi żądaniami `OpenSecureChannel` aż watchdog zabije proces, po czym ponownie enumeruj — wielu integratorów wraca do trybu anonimowego po restarcie.
- **Softing OPC UA C++ SDK / edgeConnector / edgeAggregator (CVE-2025-7390):** Pipeline TLS client-auth akceptuje dowolny certyfikat, który odtwarza zaufane Common Name, więc możesz wyemitować jednorazowy cert, skopiować CN od inżyniera zakładu i zalogować się z dowolnymi danymi `UserNameIdentityToken` lub `IssuedIdentityToken`. Połącz to z downgrade’em do Basic128Rsa15, aby zdjąć kontrole integralności i trwale podszywać się pod operatorów, aż listy zaufania zostaną odbudowane.

### Tworzenie klientów OPC UA do eksploatacji

- **Custom clients:** Biblioteki drop-in (python-opcua/asyncua, node-opcua, open62541) pozwalają prowadzić logikę exploita samodzielnie. Zawsze wymuszaj docelowy indeks namespace, aby uniknąć przypadkowych zapisów między przestrzeniami nazw, gdy dostawcy przestawią przestrzenie po aktualizacjach firmware.
- **Lista kontrolna nadużyć węzłów:**
- `HistoryRead` na tagach produkcyjnych, aby snapshotować proprietary recipes.
- `TranslateBrowsePathsToNodeIds` do rozwiązania czytelnych nazw zasobów na NodeId, które można podać do gadżetów jak framework Claroty.
- `Call` + `Method` node’y do wywoływania zadań konserwacyjnych (upload firmware, kalibracja, reboot urządzenia).
- Nadużycie `RegisterNodes` do przypinania często używanych węzłów i następnie blokowania prawowitych klientów przez nigdy nie zwalnianie uchwytów.
- **Testy utwardzania sesji:** Spróbuj związać dziesiątki subskrypcji z ekstremalnie niskimi interwałami publikowania (poniżej 50 ms) oraz przerośniętymi kolejkami monitored-item. Wiele stosów błędnie kalkuluje `RevisedPublishingInterval` i pada z powodu przepełnień schedulerów.

### Fuzzing & tooling do developmentu exploitów

Claroty Team82 wydał open-source `opcua-exploit-framework`, który pakuje lata badań o jakości Pwn2Own w moduły wielokrotnego użytku:

- **Modes:** `sanity` (lekki odczyt/przegląd), `attacks` (np. starvation puli wątków, DoS uploadem plików), `corpus` (replay fuzzing payloadów), `server` (rogue OPC UA server do backdooringu klientów).
- **Wzorzec użycia:**
```bash
# Run a DoS attack against a Prosys Simulation Server endpoint
python3 main.py prosys 10.10.10.10 53530 /OPCUA/SimulationServer thread_pool_wait_starvation

# Replay an entire Boofuzz corpus against open62541
python3 main.py open62541 192.168.1.50 4840 / opcua_message_boofuzz_db input_corpus_minimized/opcua.db
```
- **Rogue server scenario:** Dołączony asyncua-based server pozwala celować w oprogramowanie klienckie, serwując złośliwe przestrzenie adresowe (np. odpowiedzi z nadmiernie dużymi `ExtensionObject` wywołujące błędy parsowania w klonach UA Expert).
- **Zakres celów:** Wbudowane profile mapują się na Kepware, Ignition, Unified Automation, Softing SIS, Triangle Microworks, Node-OPCUA, Python OPC UA, Milo, open62541 itd., dzięki czemu możesz szybko przełączać stosy bez przepisywania payloadów.
- **Wskazówki integracyjne:** Łącz output z własnymi fuzzerami — najpierw rozpraszaj payloady z `corpus`, potem użyj OpalOPC, aby zweryfikować, czy crash przywrócił niepewne domyślne ustawienia (anonimowy login, zapis setpointów itp.).

### Exploiting authentication bypasses

If authentication bypass vulnerabilities are found, you can configure an [OPC UA client](https://www.prosysopc.com/products/opc-ua-browser/) accordingly and see what you can access. This may allow anything from merely reading process values to actually operating heavy-duty industrial equipment.

Aby zorientować się, do jakiego urządzenia masz dostęp, odczytaj wartości węzła "ServerStatus" w przestrzeni adresowej i wyszukaj w Google instrukcję obsługi.

## Shodan

- `port:4840`
- `port:62541 "OPC UA"`
- `ssl:"urn:opcua"`
- `product:"opc ua"`

Połącz wyszukiwanie ze łańcuchami dostawców (`"Ignition OPC UA"`, `"KepServerEX"`) lub certyfikatami (`"CN=UaServerCert"`), aby priorytetyzować zasoby o wysokiej wartości przed rozpoczęciem testów inwazyjnych.

## References

- [https://opalopc.com/how-to-hack-opc-ua/](https://opalopc.com/how-to-hack-opc-ua/)
- [https://github.com/claroty/opcua-exploit-framework](https://github.com/claroty/opcua-exploit-framework)
- [https://certvde.com/en/advisories/VDE-2025-022/](https://certvde.com/en/advisories/VDE-2025-022/)
- [https://nvd.nist.gov/vuln/detail/CVE-2024-53429](https://nvd.nist.gov/vuln/detail/CVE-2024-53429)
- [https://industrial.softing.com/fileadmin/psirt/downloads/2025/CVE-2025-7390.html](https://industrial.softing.com/fileadmin/psirt/downloads/2025/CVE-2025-7390.html)


{{#include ../banners/hacktricks-training.md}}
