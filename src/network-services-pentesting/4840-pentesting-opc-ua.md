# 4840 - Pentesting OPC UA

{{#include ../banners/hacktricks-training.md}}


## Informazioni di base

**OPC UA**, acronimo di **Open Platform Communications Unified Access**, è un protocollo open-source fondamentale utilizzato in vari settori come Manifatturiero, Energia, Aerospaziale e Difesa per lo scambio di dati e il controllo degli apparati. Permette in modo unico a dispositivi di diversi vendor di comunicare, in particolare con i PLC.

La sua configurazione permette misure di sicurezza robuste, ma spesso, per compatibilità con dispositivi più vecchi, queste vengono attenuate, esponendo i sistemi a rischi. Inoltre, trovare servizi OPC UA può essere complicato poiché gli scanner di rete potrebbero non rilevarli se sono su porte non standard.

**Porta predefinita:** 4840 (binary `opc.tcp`). Molti vendor espongono endpoint di discovery separati (`/discovery`), binding HTTPS (4843/443), oppure porte di listener specifiche del vendor come 49320 (KepServerEX), 62541 (OPC Foundation reference stack) e 48050 (UaGateway). Aspettati più endpoint per host, ciascuno che pubblicizza transport profile, security policy e supporto user-token.

| Built-in NodeId | Perché è importante |
| --- | --- |
| `i=2253` (`0:Server`) | Contiene `ServerArray`, stringhe vendor/product e namespace URI.
| `i=2256` (`ServerStatus`) | Rivela uptime, stato corrente e, opzionalmente, informazioni sulla build.
| `i=2267` (`ServerDiagnosticsSummary`) | Mostra il numero di sessioni, richieste abortite, ecc. Ottimo per il fingerprinting di tentativi di brute-force.
| `i=85` (`ObjectsFolder`) | Punto d'ingresso per esplorare i tag esposti del dispositivo, i metodi e gli allarmi.
```text
PORT     STATE SERVICE REASON
4840/tcp open  unknown syn-ack
```
## Pentesting OPC UA

Per rilevare problemi di sicurezza nei server OPC UA, esegui la scansione con [OpalOPC](https://opalopc.com/).
```bash
opalopc -vv opc.tcp://$target_ip_or_hostname:$target_port
```
### Discovery & Enumeration Playbook

1. **Locate all OPC UA transports**
```bash
nmap -sV -Pn -n --open -p 4840,4843,49320,48050,53530,62541 $TARGET
```
Repeat on UDP group addresses if the environment uses LDS-ME multicast discovery.

2. **Fingerprint endpoints**
- Invoke `FindServers`/`GetEndpoints` over each transport to capture `SecurityPolicyUri`, `SecurityMode`, `UserTokenType`, application URI and product strings.
- Enumera gli namespaces in modo da poter risolvere NodeIds specifici del vendor; abusa delle collisioni di namespace per indurre i client a caricare schemi controllati dall'attaccante.

3. **Walk the address space**
- Inizia da `ObjectsFolder (i=85)` e ricorsivamente `Browse`/`Read` per trovare variabili di processo scrivibili, nodi `Method` e nodi di historian/log.
- Interroga `ServerStatus.BuildInfo` per capire la provenienza del firmware, e `ServerCapabilities.OperationLimits` per valutare quanto sia facile esaurire le risorse del server.
- Se l'accesso anonymous è consentito, testa immediatamente `Call` su metodi di manutenzione (es., `ns=2;s=Reset`, `ns=2;s=StartMotor`). Molti vendor dimenticano di legare i permessi di ruolo ai metodi custom.

4. **Session abuse**
- Riutilizza o clona i valori di `AuthenticationToken` da altre sessioni (catturati via MITM o esposizione diagnostica) per dirottare subscription esistenti.
- Forza il server in flooding di `SessionDiagnostics` creando decine di sessioni inattive; alcuni stack crashano una volta superato il limite `MaxSessionCount`.

### Automated assessment with OpalOPC

- Lo scanner può essere eseguito in modalità interattiva o headless, comodo per baseline OT in stile CI/CD. Inoltra i suoi risultati machine-readable nella pipeline di reporting per evidenziare accessi anonimi, policy deboli, errori di validazione dei certificati e variabili scrivibili in pochi minuti.
- Combina l'output di OpalOPC con il browsing manuale: reinserisci la lista di endpoint scoperti nei tuoi tool personalizzati, poi sfrutta selettivamente i nodi ad alto impatto (es., `MotorControl/StartStop`, `RecipeManager/Upload`).

### Attacking legacy security policies (Basic128Rsa15)

- **Bleichenbacher-style oracle:** I sistemi che ancora consentono la policy deprecata `Basic128Rsa15` (spesso attivata tramite flag di build come `CMPOPCUASTACK_ALLOW_SHA1_BASED_SECURITY`) leak differenze di validazione del padding. Sfrutta questo inondando gli handshake `CreateSession` / `OpenSecureChannel` con blob PKCS#1 v1.5 creati per recuperare la chiave privata del certificato del server, quindi impersonare il server o decriptare il traffico.
- **Authentication bypass:** Lo stack .NET Standard di OPC Foundation precedente alla 1.5.374.158 (CVE-2024-42512) e i prodotti dipendenti permettono ad attaccanti non autenticati di forzare quella policy legacy e saltare l'autenticazione a livello applicativo. Una volta in possesso del materiale chiave puoi presentare arbitrari `UserIdentityTokens`, riprodurre richieste firmate `ActivateSession` e operare l'impianto come una engineering workstation trusted.
- **Operational workflow:**
1. Enumera le policy con `GetEndpoints` e annota eventuali voci `Basic128Rsa15`.
2. Negozia quella policy esplicitamente (`SecurityPolicyUri` in `CreateSession`), poi esegui il tuo ciclo oracle finché la chiave recuperata non viene validata.
3. Abusa della chiave per forgiare una sessione con privilegi elevati, cambiare ruoli, o degradare silenziosamente altri client agendo come un rogue reverse proxy.
- OPC Foundation ha pubblicato contemporaneamente CVE-2024-42513 per i binding HTTPS. Anche se il target dichiara TLS, assicurati che non stia silenziosamente tornando a Basic128Rsa15 per il trasporto binario dietro il proxy.

### Crafting OPC UA clients for exploitation

- **Custom clients:** Drop-in libraries (python-opcua/asyncua, node-opcua, open62541) ti permettono di implementare la exploit logic direttamente. Applica sempre l'indice di namespace target per evitare scritture cross-namespace accidentali quando i vendor riorganizzano i namespace dopo aggiornamenti firmware.
- **Node abuse checklist:**
- `HistoryRead` sui tag di produzione per catturare snapshot di ricette proprietarie.
- `TranslateBrowsePathsToNodeIds` per risolvere nomi leggibili in NodeIds che possono essere forniti a gadget come il framework di Claroty.
- `Call` + nodi `Method` per attivare task di manutenzione (firmware upload, calibrazione, reboot del dispositivo).
- Uso improprio di `RegisterNodes` per pinzare nodi frequentemente usati e poi privare i client legittimi non rilasciando mai gli handle.
- **Session hardening tests:** Prova a legare decine di subscription con intervalli di pubblicazione estremamente bassi (sotto 50 ms) e code di monitored-item sovradimensionate. Molti stack calcolano male `RevisedPublishingInterval` e vanno in crash a causa di overflow dello scheduler.

### Fuzzing & exploit development tooling

Claroty Team82 ha rilasciato l'open-source `opcua-exploit-framework` che impacchetta anni di ricerca di livello Pwn2Own in moduli riutilizzabili:

- **Modes:** `sanity` (lightweight reads/browses), `attacks` (es., thread pool starvation, file upload DoS), `corpus` (replay fuzzing payloads), `server` (rogue OPC UA server to backdoor clients).
- **Usage pattern:**
```bash
# Run a DoS attack against a Prosys Simulation Server endpoint
python3 main.py prosys 10.10.10.10 53530 /OPCUA/SimulationServer thread_pool_wait_starvation

# Replay an entire Boofuzz corpus against open62541
python3 main.py open62541 192.168.1.50 4840 / opcua_message_boofuzz_db input_corpus_minimized/opcua.db
```
- **Rogue server scenario:** Il server incluso basato su asyncua permette di colpire software client servendo address space malevoli (ad esempio, risposte con `ExtensionObject` sovradimensionati per triggerare bug di parsing in clone di UA Expert).
- **Target coverage:** I profili built-in mappano Kepware, Ignition, Unified Automation, Softing SIS, Triangle Microworks, Node-OPCUA, Python OPC UA, Milo, open62541, ecc., così puoi rapidamente passare tra stack senza riscrivere i payload.
- **Integration tips:** Concatenane l'output con i tuoi fuzzer—spruzza prima i payload del `corpus`, poi lascia che OpalOPC verifichi nuovamente se il crash ha resuscitato default insicuri (anonymous login, setpoint write access, ecc.).

### Exploiting authentication bypasses

If authentication bypass vulnerabilities are found, you can configure an [OPC UA client](https://www.prosysopc.com/products/opc-ua-browser/) accordingly and see what you can access. This may allow anything from merely reading process values to actually operating heavy-duty industrial equipment.

Per farsi un'idea del dispositivo a cui hai accesso, leggi i valori del nodo "ServerStatus" nell'address space e cerca su Google il manuale d'uso.

## Shodan

- `port:4840`
- `port:62541 "OPC UA"`
- `ssl:"urn:opcua"`
- `product:"opc ua"`

Combina la ricerca con stringhe vendor (`"Ignition OPC UA"`, `"KepServerEX"`) o certificati (`"CN=UaServerCert"`) per prioritizzare asset di alto valore prima di iniziare test intrusivi.

## References

- [https://opalopc.com/how-to-hack-opc-ua/](https://opalopc.com/how-to-hack-opc-ua/)
- [https://github.com/claroty/opcua-exploit-framework](https://github.com/claroty/opcua-exploit-framework)
- [https://certvde.com/en/advisories/VDE-2025-022/](https://certvde.com/en/advisories/VDE-2025-022/)


{{#include ../banners/hacktricks-training.md}}
