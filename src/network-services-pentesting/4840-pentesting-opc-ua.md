# 4840 - Pentesting OPC UA

{{#include ../banners/hacktricks-training.md}}


## Grundlegende Informationen

**OPC UA**, steht für **Open Platform Communications Unified Access**, ist ein wichtiges Open-Source-Protokoll, das in verschiedenen Branchen wie Fertigung, Energie, Luft- und Raumfahrt und Verteidigung für den Datenaustausch und die Steuerung von Geräten verwendet wird. Es ermöglicht unterschiedlichsten Geräten verschiedener Hersteller zu kommunizieren, insbesondere mit PLCs.

Seine Konfiguration erlaubt starke Sicherheitsmaßnahmen, die jedoch häufig zugunsten der Kompatibilität mit älteren Geräten abgeschwächt werden, wodurch Systeme Risiken ausgesetzt sind. Außerdem kann das Auffinden von OPC UA-Services schwierig sein, da Netzwerkscanner sie möglicherweise nicht erkennen, wenn sie auf nichtstandardmäßigen Ports laufen.

**Default port:** 4840 (binary `opc.tcp`). Viele Anbieter stellen separate discovery-Endpunkte (`/discovery`), HTTPS-Bindings (4843/443) oder herstellerspezifische Listener-Ports wie 49320 (KepServerEX), 62541 (OPC Foundation reference stack) und 48050 (UaGateway) bereit. Erwarten Sie mehrere Endpunkte pro Host, die jeweils Transport-Profile, Security-Policy und User-Token-Unterstützung ankündigen.

| Built-in NodeId | Why it matters |
| --- | --- |
| `i=2253` (`0:Server`) | Enthält `ServerArray`, Hersteller-/Produkt-Strings und Namespace-URIs.
| `i=2256` (`ServerStatus`) | Offenbart Betriebszeit, aktuellen Zustand und optional Build-Informationen.
| `i=2267` (`ServerDiagnosticsSummary`) | Zeigt Sitzungsanzahlen, abgebrochene Anfragen usw. Gut für fingerprinting von brute-force-Versuchen.
| `i=85` (`ObjectsFolder`) | Einstiegspunkt, um exponierte Geräte-Tags, Methoden und Alarme zu durchsuchen.
```text
PORT     STATE SERVICE REASON
4840/tcp open  unknown syn-ack
```
## Pentesting OPC UA

Um Sicherheitsprobleme in OPC UA-Servern aufzudecken, scanne sie mit [OpalOPC](https://opalopc.com/).
```bash
opalopc -vv opc.tcp://$target_ip_or_hostname:$target_port
```
### Discovery & Enumeration Playbook

1. **Locate all OPC UA transports**
```bash
nmap -sV -Pn -n --open -p 4840,4843,49320,48050,53530,62541 $TARGET
```
Wiederhole das auf UDP-Group-Adressen, wenn die Umgebung LDS-ME Multicast-Discovery verwendet.

2. **Fingerprint endpoints**
- Führe `FindServers`/`GetEndpoints` über jeden Transport aus, um `SecurityPolicyUri`, `SecurityMode`, `UserTokenType`, Application URI und Produktstrings zu erfassen.
- Enumeriere Namespaces, damit du vendor-spezifische NodeIds auflösen kannst; missbrauche Namespace-Kollisionen, um Clients dazu zu bringen, vom Angreifer kontrollierte Schemas zu laden.

3. **Walk the address space**
- Beginne bei `ObjectsFolder (i=85)` und `Browse`/`Read` rekursiv, um beschreibbare Prozessvariablen, `Method`-Nodes und Historian-/Log-Nodes zu finden.
- Frage `ServerStatus.BuildInfo` ab, um die Herkunft der Firmware zu verstehen, und `ServerCapabilities.OperationLimits`, um einzuschätzen, wie leicht Server-Ressourcen erschöpft werden können.
- Wenn anonymer Zugriff erlaubt ist, teste sofort `Call` auf Wartungsmethoden (z. B. `ns=2;s=Reset`, `ns=2;s=StartMotor`). Viele Hersteller vergessen, Rollenrechte an benutzerdefinierte Methoden zu binden.

4. **Session abuse**
- Reuse oder clone `AuthenticationToken`-Werte aus anderen Sessions (captured via MITM oder diagnostischer Offenlegung), um bestehende Subscriptions zu hijacken.
- Zwinge den Server durch Erzeugen dutzender inaktiver Sessions in `SessionDiagnostics`-Flooding; einige Stacks crashen, sobald das `MaxSessionCount`-Limit überschritten wird.

### Automated assessment with OpalOPC

- Der Scanner kann interaktiv oder headless laufen, was für CI/CD-ähnliche OT-Baselines praktisch ist. Pipe seine maschinenlesbaren Findings in deine Reporting-Pipeline, um in Minuten anonyme Logins, schwache Policies, Zertifikat-Validierungsfehler und beschreibbare Variablen hervorzuheben.
- Kombiniere OpalOPC-Ausgaben mit manuellem Browsing: speise die entdeckte Endpoint-Liste zurück in dein Custom-Tooling und weaponize dann selektiv hochwirksame Nodes (z. B. `MotorControl/StartStop`, `RecipeManager/Upload`).

### Attacking legacy security policies (Basic128Rsa15)

- **Bleichenbacher-style oracle:** Systeme, die noch die veraltete `Basic128Rsa15`-Policy erlauben (oft über Build-Flags wie `CMPOPCUASTACK_ALLOW_SHA1_BASED_SECURITY` aktiviert), zeigen Unterschiede in der Padding-Validierung. Exploitiere dies, indem du `CreateSession` / `OpenSecureChannel`-Handshakes mit manipulierten PKCS#1 v1.5-Blobs flutest, um den privaten Server-Zertifikatsschlüssel zurückzugewinnen; anschließend kannst du den Server impersonifizieren oder Traffic entschlüsseln.
- **Authentication bypass:** OPC Foundation’s .NET Standard Stack vor 1.5.374.158 (CVE-2024-42512) und abhängige Produkte erlauben es nicht-authentifizierten Angreifern, diese Legacy-Policy zu erzwingen und danach die anwendungsseitige Authentifizierung zu überspringen. Sobald du über die Key-Materialien verfügst, kannst du beliebige `UserIdentityTokens` präsentieren, signierte `ActivateSession`-Requests replayen und die Anlage als vertrauenswürdige Engineering-Workstation betreiben.
- **Operational workflow:**
1. Enumeriere Policies mit `GetEndpoints` und notiere alle `Basic128Rsa15`-Einträge.
2. Verhandle diese Policy explizit (`SecurityPolicyUri` in `CreateSession`), dann führe deine Oracle-Schleife aus, bis der zurückgewonnene Schlüssel validiert.
3. Missbrauche den Schlüssel, um eine hochprivilegierte Session zu fälschen, Rollen zu wechseln oder andere Clients stillschweigend durch einen Rogue-Reverse-Proxy downzugraden.
- **CODESYS Runtime Toolkit (<3.5.21.0)** reaktivierte Basic128Rsa15 immer dann, wenn Integratoren mit `CMPOPCUASTACK_ALLOW_SHA1_BASED_SECURITY` kompilieren. Schalte dieses Flag, wiederhole den Oracle-Workflow oben und du kannst den Runtime-Private-Key leak, um vertrauenswürdige Engineering-Workstations zu impersonifizieren, bis Patch-Level 3.5.21.0 oder neuer ausgerollt ist.
- OPC Foundation veröffentlichte zeitgleich CVE-2024-42513 für HTTPS-Bindings. Selbst wenn dein Ziel TLS behauptet, stelle sicher, dass es nicht stillschweigend für den binären Transport hinter einem Proxy auf Basic128Rsa15 fallbackt.

### 2024-2025 exploit watchlist

- **open62541 fuzz_binary_decode (CVE-2024-53429):** SecureChannel-Chunks, die übergroße `ExtensionObject`-Bodies deklarieren, lassen den Decoder auf freed Memory dereferenzieren, sodass ein Pre-Auth-Angreifer UA-Server mit eingebettetem open62541 ≤1.4.6 wiederholt zum Absturz bringen kann. Reuse das Claroty-Corpus (`opcua_message_boofuzz_db`) oder erstelle dein eigenes Boofuzz-Harness, um mutierte `OpenSecureChannel`-Requests zu spammen, bis der Watchdog den Prozess killt — dann re-enumeriere, weil viele Integratoren nach dem Reboot auf anonymen Modus zurückfallen.
- **Softing OPC UA C++ SDK / edgeConnector / edgeAggregator (CVE-2025-7390):** Die TLS-Client-Auth-Pipeline akzeptiert jedes Zertifikat, das einen vertrauenswürdigen Common Name replayt; du kannst also ein Wegwerf-Zertifikat minten, den CN eines Plant-Engineers kopieren und dich mit beliebigen `UserNameIdentityToken`- oder `IssuedIdentityToken`-Daten einloggen. Kombiniere das mit einem Downgrade auf Basic128Rsa15, um Integritätschecks zu entfernen und Operatoren persistent zu impersonifizieren, bis Trustlists neu aufgebaut werden.

### Crafting OPC UA clients for exploitation

- **Custom clients:** Drop-in-Bibliotheken (python-opcua/asyncua, node-opcua, open62541) erlauben es dir, Exploit-Logik selbst zu implementieren. Erzwinge immer deinen Ziel-Namespace-Index, um versehentliche Cross-Namespace-Writes zu vermeiden, wenn Hersteller Namespaces nach Firmware-Updates umsortieren.
- **Node abuse checklist:**
- `HistoryRead` auf Produktionstags, um proprietäre Rezepte zu snapshotten.
- `TranslateBrowsePathsToNodeIds`, um menschenlesbare Asset-Namen in NodeIds aufzulösen, die in Gadgets wie Claroty’s Framework eingespeist werden können.
- `Call` + `Method`-Nodes, um Wartungsaufgaben auszulösen (Firmware-Upload, Kalibrierung, Gerätneustarts).
- `RegisterNodes`-Missbrauch, um häufig genutzte Nodes zu pinnen und dann legitime Clients auszuhungern, indem die Handles nie freigegeben werden.
- **Session hardening tests:** Versuche, dutzende Subscriptions mit extrem niedrigen Publishing-Intervallen (unter 50 ms) plus übergroßen monitored-item-Queues zu binden. Viele Stacks berechnen `RevisedPublishingInterval` falsch und stürzen wegen Scheduler-Overflows ab.

### Fuzzing & exploit development tooling

Claroty Team82 veröffentlichte ein Open-Source `opcua-exploit-framework`, das jahrelange Pwn2Own-ähnliche Forschung in wiederverwendbare Module packt:

- **Modes:** `sanity` (leichte Reads/Browses), `attacks` (z. B. thread-pool-starvation, file-upload-DoS), `corpus` (replay-fuzzing payloads), `server` (rogue OPC UA Server zum Backdooring von Clients).
- **Usage pattern:**
```bash
# Run a DoS attack against a Prosys Simulation Server endpoint
python3 main.py prosys 10.10.10.10 53530 /OPCUA/SimulationServer thread_pool_wait_starvation

# Replay an entire Boofuzz corpus against open62541
python3 main.py open62541 192.168.1.50 4840 / opcua_message_boofuzz_db input_corpus_minimized/opcua.db
```
- **Rogue server scenario:** Der mitgelieferte asyncua-basierte Server erlaubt es, Client-Software anzugreifen, indem er bösartige Address Spaces serviert (z. B. Antworten mit übergroßen `ExtensionObject`s, um Parsing-Bugs in UA Expert-Klons auszulösen).
- **Target coverage:** Eingebaute Profile mappen auf Kepware, Ignition, Unified Automation, Softing SIS, Triangle Microworks, Node-OPCUA, Python OPC UA, Milo, open62541 usw., sodass du schnell zwischen Stacks wechseln kannst, ohne Payloads neu schreiben zu müssen.
- **Integration tips:** Kette seine Outputs mit deinen eigenen Fuzzern — spray zuerst die `corpus`-Payloads, dann lasse OpalOPC re-verifizieren, ob der Crash unsichere Defaults wiederbelebt hat (anonymer Login, Setpoint-Write-Zugriff usw.).

### Exploiting authentication bypasses

Wenn Authentication-Bypass-Schwachstellen gefunden werden, kannst du einen [OPC UA client](https://www.prosysopc.com/products/opc-ua-browser/) entsprechend konfigurieren und sehen, worauf du Zugriff hast. Das kann alles ermöglichen — vom bloßen Lesen von Prozesswerten bis hin zur tatsächlichen Bedienung schwerer Industrieanlagen.

Um einen Hinweis auf das Gerät zu bekommen, auf das du Zugriff hast, lies die "ServerStatus"-Node-Werte im Address Space und google nach einem Benutzerhandbuch.

## Shodan

- `port:4840`
- `port:62541 "OPC UA"`
- `ssl:"urn:opcua"`
- `product:"opc ua"`

Kombiniere die Suche mit Vendor-Strings (`"Ignition OPC UA"`, `"KepServerEX"`) oder Zertifikaten (`"CN=UaServerCert"`), um vor intrusiven Tests hochprioritäre Assets zu identifizieren.

## References

- [https://opalopc.com/how-to-hack-opc-ua/](https://opalopc.com/how-to-hack-opc-ua/)
- [https://github.com/claroty/opcua-exploit-framework](https://github.com/claroty/opcua-exploit-framework)
- [https://certvde.com/en/advisories/VDE-2025-022/](https://certvde.com/en/advisories/VDE-2025-022/)
- [https://nvd.nist.gov/vuln/detail/CVE-2024-53429](https://nvd.nist.gov/vuln/detail/CVE-2024-53429)
- [https://industrial.softing.com/fileadmin/psirt/downloads/2025/CVE-2025-7390.html](https://industrial.softing.com/fileadmin/psirt/downloads/2025/CVE-2025-7390.html)


{{#include ../banners/hacktricks-training.md}}
