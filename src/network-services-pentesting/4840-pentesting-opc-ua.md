# 4840 - Pentesting OPC UA

{{#include ../banners/hacktricks-training.md}}


## Podstawowe informacje

**OPC UA**, oznaczany skrótem **Open Platform Communications Unified Access**, jest kluczowym protokołem open-source używanym w różnych branżach, takich jak produkcja, energetyka, lotnictwo i obronność, do wymiany danych i sterowania urządzeniami. Umożliwia on komunikację urządzeń różnych producentów, szczególnie PLC.

Jego konfiguracja pozwala na stosowanie silnych środków bezpieczeństwa, jednak często, ze względu na kompatybilność ze starszymi urządzeniami, są one osłabiane, co naraża systemy na ryzyko. Dodatkowo wykrycie usług OPC UA może być trudne, ponieważ skanery sieciowe mogą ich nie wykryć, jeśli działają na niestandardowych portach.

**Default port:** 4840 (binary `opc.tcp`). Wielu dostawców udostępnia oddzielne endpointy discovery (`/discovery`), powiązania HTTPS (4843/443) lub porty nasłuchu specyficzne dla producenta, takie jak 49320 (KepServerEX), 62541 (OPC Foundation reference stack) i 48050 (UaGateway). Spodziewaj się wielu endpointów na hoście, z których każdy reklamuje profil transportu, politykę bezpieczeństwa i obsługę tokenów użytkownika.

| Built-in NodeId | Dlaczego to ma znaczenie |
| --- | --- |
| `i=2253` (`0:Server`) | Zawiera `ServerArray`, ciągi vendor/product i namespace URI.
| `i=2256` (`ServerStatus`) | Ujawnia czas pracy, aktualny stan i opcjonalnie informacje o kompilacji.
| `i=2267` (`ServerDiagnosticsSummary`) | Pokazuje liczbę sesji, przerwane żądania itp. Przydatne do identyfikowania prób brute-force.
| `i=85` (`ObjectsFolder`) | Punkt wejścia do przeglądania udostępnionych tagów urządzeń, metod i alarmów.
```text
PORT     STATE SERVICE REASON
4840/tcp open  unknown syn-ack
```
## Pentesting OPC UA

Aby ujawnić problemy z bezpieczeństwem w serwerach OPC UA, przeskanuj je za pomocą [OpalOPC](https://opalopc.com/).
```bash
opalopc -vv opc.tcp://$target_ip_or_hostname:$target_port
```
### Playbook odkrywania i enumeracji

1. **Zlokalizuj wszystkie transporty OPC UA**
```bash
nmap -sV -Pn -n --open -p 4840,4843,49320,48050,53530,62541 $TARGET
```
Powtórz na adresach grup UDP, jeśli środowisko używa wykrywania multicast LDS-ME.

2. **Profilowanie punktów końcowych**
- Wywołaj `FindServers`/`GetEndpoints` przez każdy transport, aby zebrać `SecurityPolicyUri`, `SecurityMode`, `UserTokenType`, URI aplikacji oraz ciągi product.
- Enumeruj namespace'y, aby móc rozwiązywać vendor-specific NodeIds; wykorzystaj kolizje namespace'ów, aby nakłonić klientów do załadowania schematów kontrolowanych przez atakującego.

3. **Przeglądaj przestrzeń adresową**
- Zacznij od `ObjectsFolder (i=85)` i rekurencyjnie `Browse`/`Read`, aby znaleźć zapisywalne zmienne procesowe, węzły `Method` oraz węzły historiografa/logów.
- Zapytaj `ServerStatus.BuildInfo`, aby zrozumieć pochodzenie firmware'u, oraz `ServerCapabilities.OperationLimits`, aby ocenić, jak łatwo można wyczerpać zasoby serwera.
- Jeśli anonimowy dostęp jest dozwolony, natychmiast przetestuj `Call` na metodach serwisowych (np. `ns=2;s=Reset`, `ns=2;s=StartMotor`). Wielu vendorów zapomina powiązać uprawnienia ról z niestandardowymi metodami.

4. **Nadużycia sesji**
- Reużyj lub klonuj wartości `AuthenticationToken` z innych sesji (przechwyconych przez MITM lub ujawnionych w diagnostyce), aby przejąć istniejące subskrypcje.
- Zmień serwer w zalew `SessionDiagnostics`, tworząc dziesiątki nieaktywnych sesji; niektóre stosy padają po przekroczeniu limitu `MaxSessionCount`.

### Zautomatyzowana ocena za pomocą OpalOPC

- Skaner może działać interaktywnie lub w trybie headless, co jest przydatne dla CI/CD i baseline'ów OT. Przekaż jego maszynowo-odczytywalne wyniki do pipeline'u raportowego, aby w kilka minut uwydatnić anonimowe loginy, słabe polityki, błędy walidacji certyfikatów oraz zapisywalne zmienne.
- Połącz output OpalOPC z ręcznym przeglądaniem: podaj odkrytą listę endpointów z powrotem do własnych narzędzi, a następnie selektywnie zaweaponizuj węzły o wysokim wpływie (np. `MotorControl/StartStop`, `RecipeManager/Upload`).

### Atakowanie starych polityk bezpieczeństwa (Basic128Rsa15)

- **Oracle w stylu Bleichenbachera:** Systemy, które nadal dopuszczają przestarzałą politykę `Basic128Rsa15` (często włączaną flaga builda taką jak `CMPOPCUASTACK_ALLOW_SHA1_BASED_SECURITY`), ujawniają różnice w walidacji paddingu. Wykorzystaj to, zalewając handshake'y `CreateSession` / `OpenSecureChannel` spreparowanymi blobami PKCS#1 v1.5, aby odzyskać prywatny klucz certyfikatu serwera, a następnie podszyć się pod serwer lub odszyfrować ruch.
- **Ominięcie uwierzytelniania:** stos .NET Standard OPC Foundation przed 1.5.374.158 (CVE-2024-42512) oraz produkty od niego zależne pozwalają nieautentyfikowanym atakującym wymusić tę legacy politykę i następnie pominąć uwierzytelnianie na poziomie aplikacji. Gdy zdobędziesz material klucza, możesz przedstawić dowolne `UserIdentityTokens`, odtworzyć podpisane żądania `ActivateSession` i działać w zakładzie jako zaufane stanowisko inżynieryjne.
- **Przebieg operacji:**
1. Enumeruj polityki za pomocą `GetEndpoints` i zanotuj wszystkie wpisy `Basic128Rsa15`.
2. Negocjuj tę politykę jawnie (`SecurityPolicyUri` w `CreateSession`), następnie uruchom pętlę oracle aż odzyskany klucz zostanie zweryfikowany.
3. Wykorzystaj klucz do sfałszowania sesji o wysokich uprawnieniach, zmiany ról lub cichego obniżenia bezpieczeństwa innych klientów działając jako rogue reverse proxy.
- OPC Foundation jednocześnie opublikowała CVE-2024-42513 dla powiązań HTTPS. Nawet jeśli cel deklaruje TLS, upewnij się, że nie cofa się po cichu do Basic128Rsa15 dla binarnego transportu za proxy.

### Tworzenie klientów OPC UA do eksploatacji

- **Klienci niestandardowi:** biblioteki drop-in (python-opcua/asyncua, node-opcua, open62541) pozwalają napisać logikę exploitu samodzielnie. Zawsze wymuszaj target namespace index, aby uniknąć przypadkowych zapisów między namespace'ami gdy vendor zmienia ich kolejność po aktualizacjach firmware.
- **Lista nadużyć w węzłach:**
- `HistoryRead` na tagach produkcyjnych, aby zrzucić snapshoty zastrzeżonych receptur.
- `TranslateBrowsePathsToNodeIds` do zamiany czytelnych nazw aktywów na NodeId'y, które można podać do gadżetów takich jak framework Claroty.
- `Call` + węzły `Method` do uruchamiania zadań serwisowych (upload firmware, kalibracja, reboot urządzeń).
- Nadużycie `RegisterNodes` do przypięcia często używanych węzłów, a następnie głodzenia legalnych klientów przez nigdy niezwalnianie uchwytów.
- **Testy usztywniania sesji:** Spróbuj powiązać dziesiątki subskrypcji z bardzo niskimi interwałami publikowania (poniżej 50 ms) i nadmiernie dużymi kolejkami monitored-item. Wiele stosów źle oblicza `RevisedPublishingInterval` i pada z powodu przepełnień schedulerów.

### Fuzzing i narzędzia do tworzenia exploitów

Claroty Team82 opublikował open-source'owy `opcua-exploit-framework`, który pakuje lata badań klasy Pwn2Own w moduły wielokrotnego użytku:

- **Tryby:** `sanity` (lekki read/browse), `attacks` (np. wyczerpanie thread pool, DoS przez upload pliku), `corpus` (replay fuzzing payloadów), `server` (rogue OPC UA server do backdooringu klientów).
- **Wzorzec użycia:**
```bash
# Run a DoS attack against a Prosys Simulation Server endpoint
python3 main.py prosys 10.10.10.10 53530 /OPCUA/SimulationServer thread_pool_wait_starvation

# Replay an entire Boofuzz corpus against open62541
python3 main.py open62541 192.168.1.50 4840 / opcua_message_boofuzz_db input_corpus_minimized/opcua.db
```
- **Scenariusz rogue server:** Dołączony asyncua-based server pozwala atakować oprogramowanie klienckie serwując złośliwe przestrzenie adresowe (np. odpowiedzi z nadmiernie dużymi `ExtensionObject` powodującymi błędy parsowania w klonach UA Expert).
- **Zasięg celów:** Wbudowane profile mapują się na Kepware, Ignition, Unified Automation, Softing SIS, Triangle Microworks, Node-OPCUA, Python OPC UA, Milo, open62541 itd., dzięki czemu można szybko przełączać się między stosami bez przepisywania payloadów.
- **Wskazówki integracyjne:** Łącz jego output z własnymi fuzzerami — najpierw rozpraszaj payloady z `corpus`, potem użyj OpalOPC, aby ponownie zweryfikować, czy awaria nie przywróciła niebezpiecznych domyślnych ustawień (anonimowy login, dostęp do zapisu setpointów itp.).

### Wykorzystywanie obejść uwierzytelniania

Jeśli znalezione zostaną luki pozwalające na obejście uwierzytelniania, możesz skonfigurować [OPC UA client](https://www.prosysopc.com/products/opc-ua-browser/) zgodnie z potrzebą i zobaczyć, do czego masz dostęp. To może umożliwić wszystko — od samego odczytu wartości procesowych po faktyczne sterowanie ciężkim sprzętem przemysłowym.

Aby zorientować się, do jakiego urządzenia masz dostęp, odczytaj wartości węzła "ServerStatus" w przestrzeni adresowej i wyszukaj instrukcję obsługi (manual) w Google.

## Shodan

- `port:4840`
- `port:62541 "OPC UA"`
- `ssl:"urn:opcua"`
- `product:"opc ua"`

Połącz wyszukiwanie z ciągami vendorów (`"Ignition OPC UA"`, `"KepServerEX"`) lub certyfikatami (`"CN=UaServerCert"`), aby priorytetyzować zasoby wysokiej wartości przed rozpoczęciem inwazyjnego testowania.

## References

- [https://opalopc.com/how-to-hack-opc-ua/](https://opalopc.com/how-to-hack-opc-ua/)
- [https://github.com/claroty/opcua-exploit-framework](https://github.com/claroty/opcua-exploit-framework)
- [https://certvde.com/en/advisories/VDE-2025-022/](https://certvde.com/en/advisories/VDE-2025-022/)


{{#include ../banners/hacktricks-training.md}}
