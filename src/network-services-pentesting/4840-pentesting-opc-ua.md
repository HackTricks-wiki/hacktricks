# 4840 - Pentesting OPC UA

{{#include ../banners/hacktricks-training.md}}


## Informations de base

**OPC UA**, signifiant **Open Platform Communications Unified Access**, est un protocole open-source crucial utilisé dans diverses industries telles que la fabrication, l'énergie, l'aérospatiale et la défense pour l'échange de données et le contrôle d'équipements. Il permet à des équipements de différents fournisseurs de communiquer entre eux, notamment avec les PLCs.

Sa configuration permet des mesures de sécurité strictes, mais souvent, pour compatibilité avec des appareils anciens, celles-ci sont réduites, exposant les systèmes à des risques. De plus, trouver des services OPC UA peut être difficile car les scanners réseau peuvent ne pas les détecter s'ils sont sur des ports non standard.

**Port par défaut :** 4840 (binaire `opc.tcp`). De nombreux fournisseurs exposent des endpoints de découverte séparés (`/discovery`), des bindings HTTPS (4843/443), ou des ports d'écoute spécifiques au fournisseur tels que 49320 (KepServerEX), 62541 (OPC Foundation reference stack) et 48050 (UaGateway). Attendez-vous à plusieurs endpoints par hôte, chacun annonçant le transport profile, la security policy et le support des user-tokens.

| Built-in NodeId | Pourquoi c'est important |
| --- | --- |
| `i=2253` (`0:Server`) | Contient `ServerArray`, les vendor/product strings et les namespace URIs. |
| `i=2256` (`ServerStatus`) | Révèle l'uptime, l'état actuel, et éventuellement des informations de build. |
| `i=2267` (`ServerDiagnosticsSummary`) | Montre le nombre de sessions, les requêtes avortées, etc. Utile pour fingerprinting des tentatives de brute-force. |
| `i=85` (`ObjectsFolder`) | Point d'entrée pour parcourir les tags, méthodes et alarmes exposés des dispositifs. |
```text
PORT     STATE SERVICE REASON
4840/tcp open  unknown syn-ack
```
## Pentesting OPC UA

Pour révéler des problèmes de sécurité dans les serveurs OPC UA, scannez-les avec [OpalOPC](https://opalopc.com/).
```bash
opalopc -vv opc.tcp://$target_ip_or_hostname:$target_port
```
### Discovery & Enumeration Playbook

1. **Localiser tous les transports OPC UA**
```bash
nmap -sV -Pn -n --open -p 4840,4843,49320,48050,53530,62541 $TARGET
```
Répétez sur les adresses de groupe UDP si l'environnement utilise la découverte multicast LDS-ME.

2. **Identifier les endpoints**
- Appelez `FindServers`/`GetEndpoints` sur chaque transport pour capturer `SecurityPolicyUri`, `SecurityMode`, `UserTokenType`, l'URI d'application et les chaînes produit.
- Énumérez les namespaces afin de résoudre les NodeIds spécifiques aux fournisseurs ; abusez des collisions de namespace pour inciter les clients à charger des schémas contrôlés par l'attaquant.

3. **Parcourir l'espace d'adressage**
- Commencez par `ObjectsFolder (i=85)` et `Browse`/`Read` de manière récursive pour trouver des variables de processus modifiables, des nœuds `Method` et des nœuds historien/log.
- Interrogez `ServerStatus.BuildInfo` pour comprendre la provenance du firmware, et `ServerCapabilities.OperationLimits` pour évaluer la facilité avec laquelle les ressources du serveur peuvent être épuisées.
- Si l'accès anonyme est autorisé, testez immédiatement `Call` sur les méthodes de maintenance (par ex., `ns=2;s=Reset`, `ns=2;s=StartMotor`). De nombreux fournisseurs oublient d'associer les permissions de rôle aux méthodes personnalisées.

4. **Abus de session**
- Réutilisez ou clonez des valeurs `AuthenticationToken` provenant d'autres sessions (capturées via MITM ou exposition des diagnostics) pour détourner des subscriptions existantes.
- Forcez le serveur dans un flood de `SessionDiagnostics` en créant des dizaines de sessions inactives ; certaines stacks plantent une fois la limite `MaxSessionCount` dépassée.

### Automated assessment with OpalOPC

- Le scanner peut s'exécuter en mode interactif ou headless, ce qui est pratique pour des baselines OT de type CI/CD. Poussez ses résultats lisibles par machine dans votre pipeline de reporting pour mettre en évidence les logins anonymes, les politiques faibles, les erreurs de validation de certificats et les variables modifiables en quelques minutes.
- Combinez la sortie OpalOPC avec un parcours manuel : réinjectez la liste d'endpoints découverts dans vos outils personnalisés, puis exploitez sélectivement les nœuds à fort impact (par ex., `MotorControl/StartStop`, `RecipeManager/Upload`).

### Attacking legacy security policies (Basic128Rsa15)

- **Bleichenbacher-style oracle:** Les systèmes qui autorisent encore la politique obsolète `Basic128Rsa15` (souvent activée via des flags de build comme `CMPOPCUASTACK_ALLOW_SHA1_BASED_SECURITY`) leak des différences de validation du padding. Exploitez cela en inondant les handshakes `CreateSession` / `OpenSecureChannel` avec des blobs PKCS#1 v1.5 fabriqués pour récupérer la clé privée du certificat du serveur, puis usurpez le serveur ou déchiffrez le trafic.
- **Authentication bypass:** Le stack .NET Standard de l'OPC Foundation antérieur à la version 1.5.374.158 (CVE-2024-42512) et les produits dépendants permettent à des attaquants non authentifiés de forcer cette politique legacy puis de sauter l'authentification au niveau applicatif. Une fois la clé compromise, vous pouvez présenter des `UserIdentityTokens` arbitraires, rejouer des requêtes signées `ActivateSession` et opérer l'usine comme une station d'ingénierie de confiance.
- **Operational workflow:**
1. Énumérez les policies avec `GetEndpoints` et notez les entrées `Basic128Rsa15`.
2. Négociez explicitement cette policy (`SecurityPolicyUri` dans `CreateSession`), puis lancez votre boucle oracle jusqu'à ce que la clé récupérée soit validée.
3. Abusez de la clé pour forger une session à haut privilège, changer de rôle, ou rétrograder silencieusement d'autres clients en agissant comme un reverse proxy malveillant.
- **CODESYS Runtime Toolkit (<3.5.21.0)** réactivait Basic128Rsa15 chaque fois que les intégrateurs compilent avec `CMPOPCUASTACK_ALLOW_SHA1_BASED_SECURITY`. Basculez ce flag, relancez le workflow oracle ci‑dessus, et vous pouvez leak la clé privée du runtime pour usurper des stations d'ingénierie de confiance jusqu'à ce que le niveau de patch 3.5.21.0 ou ultérieur soit déployé.
- L'OPC Foundation a simultanément publié CVE-2024-42513 pour les bindings HTTPS. Même si votre cible prétend utiliser TLS, assurez-vous qu'elle ne retombe pas silencieusement sur Basic128Rsa15 pour le transport binaire derrière le proxy.

### 2024-2025 exploit watchlist

- **open62541 fuzz_binary_decode (CVE-2024-53429):** Des chunks SecureChannel déclarant des corps d'`ExtensionObject` surdimensionnés font que le décodeur déréférence de la mémoire libérée, permettant à un attaquant pré-auth de faire planter de façon répétée des serveurs UA qui intègrent open62541 ≤1.4.6. Réutilisez le corpus Claroty (`opcua_message_boofuzz_db`) ou créez votre propre harness Boofuzz pour spammer des requêtes `OpenSecureChannel` mutées jusqu'à ce que le watchdog tue le processus, puis ré-énumérez car de nombreux intégrateurs retombent en mode anonyme après le redémarrage.
- **Softing OPC UA C++ SDK / edgeConnector / edgeAggregator (CVE-2025-7390):** Le pipeline TLS client-auth accepte n'importe quel certificat qui rejoue un Common Name de confiance, vous pouvez donc mint un certificat jetable, copier le CN d'un ingénieur d'usine, et vous connecter avec des données `UserNameIdentityToken` ou `IssuedIdentityToken` arbitraires. Associez cela à un downgrade vers Basic128Rsa15 pour supprimer les contrôles d'intégrité et usurper de façon persistante des opérateurs jusqu'à ce que les listes de confiance soient reconstruites.

### Crafting OPC UA clients for exploitation

- **Custom clients:** Les bibliothèques drop-in (python-opcua/asyncua, node-opcua, open62541) vous permettent d'implémenter vous-même la logique d'exploit. Appliquez toujours l'index de namespace ciblé pour éviter des écritures inter-namespace accidentelles lorsque les fournisseurs réordonnent les namespaces après des mises à jour de firmware.
- **Checklist d'abus de nœuds:**
- `HistoryRead` sur des tags de production pour capturer des recettes propriétaires.
- `TranslateBrowsePathsToNodeIds` pour résoudre des noms d'actifs lisibles par l'humain en NodeIds pouvant être fournis à des gadgets comme le framework Claroty.
- `Call` + nœuds `Method` pour déclencher des tâches de maintenance (upload de firmware, calibration, reboot d'appareils).
- Mauvaise utilisation de `RegisterNodes` pour épingler des nœuds fréquemment accédés puis affamer les clients légitimes en ne libérant jamais les handles.
- **Session hardening tests:** Essayez de binder des dizaines de subscriptions avec des publishing intervals extrêmement bas (en dessous de 50 ms) et des files de monitored-item surdimensionnées. Beaucoup de stacks mal calculent `RevisedPublishingInterval` et plantent à cause de débordements du scheduler.

### Fuzzing & exploit development tooling

Claroty Team82 a publié un `opcua-exploit-framework` open-source qui empaquette des années de recherche de niveau Pwn2Own en modules réutilisables :

- **Modes:** `sanity` (lectures/browses légers), `attacks` (par ex. starvation du thread pool, DoS upload de fichier), `corpus` (replay de payloads de fuzzing), `server` (serveur OPC UA rogue pour backdoor des clients).
- **Usage pattern:**
```bash
# Run a DoS attack against a Prosys Simulation Server endpoint
python3 main.py prosys 10.10.10.10 53530 /OPCUA/SimulationServer thread_pool_wait_starvation

# Replay an entire Boofuzz corpus against open62541
python3 main.py open62541 192.168.1.50 4840 / opcua_message_boofuzz_db input_corpus_minimized/opcua.db
```
- **Rogue server scenario:** Le serveur basé sur asyncua inclus permet de cibler des logiciels clients en servant des address spaces malicieux (par exemple, des réponses avec des `ExtensionObject` surdimensionnés pour déclencher des bugs de parsing dans des clones de UA Expert).
- **Target coverage:** Les profils intégrés couvrent Kepware, Ignition, Unified Automation, Softing SIS, Triangle Microworks, Node-OPCUA, Python OPC UA, Milo, open62541, etc., vous permettant de permuter rapidement entre les stacks sans réécrire les payloads.
- **Integration tips:** Enchaînez sa sortie avec vos propres fuzzers—sprayez d'abord les payloads du `corpus`, puis laissez OpalOPC re-vérifier si le plantage a ressuscité des defaults peu sûrs (login anonyme, écriture des setpoints, etc.).

### Exploiting authentication bypasses

Si des vulnérabilités d'authentication bypass sont trouvées, vous pouvez configurer un [OPC UA client](https://www.prosysopc.com/products/opc-ua-browser/) en conséquence et voir à quoi vous avez accès. Cela peut permettre tout, depuis la lecture simple de valeurs de process jusqu'à l'opération d'équipements industriels lourds.

Pour avoir une idée de l'appareil auquel vous avez accès, lisez les valeurs du nœud "ServerStatus" dans l'espace d'adressage et faites une recherche Google pour un manuel d'utilisation.

## Shodan

- `port:4840`
- `port:62541 "OPC UA"`
- `ssl:"urn:opcua"`
- `product:"opc ua"`

Combinez la recherche avec des chaînes fournisseur (`"Ignition OPC UA"`, `"KepServerEX"`) ou des certificats (`"CN=UaServerCert"`) pour prioriser des assets à haute valeur avant de commencer les tests intrusifs.

## Références

- [https://opalopc.com/how-to-hack-opc-ua/](https://opalopc.com/how-to-hack-opc-ua/)
- [https://github.com/claroty/opcua-exploit-framework](https://github.com/claroty/opcua-exploit-framework)
- [https://certvde.com/en/advisories/VDE-2025-022/](https://certvde.com/en/advisories/VDE-2025-022/)
- [https://nvd.nist.gov/vuln/detail/CVE-2024-53429](https://nvd.nist.gov/vuln/detail/CVE-2024-53429)
- [https://industrial.softing.com/fileadmin/psirt/downloads/2025/CVE-2025-7390.html](https://industrial.softing.com/fileadmin/psirt/downloads/2025/CVE-2025-7390.html)


{{#include ../banners/hacktricks-training.md}}
