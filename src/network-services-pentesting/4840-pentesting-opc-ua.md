# 4840 - Pentesting OPC UA

{{#include ../banners/hacktricks-training.md}}


## Basic Information

**OPC UA**, standing for **Open Platform Communications Unified Access**, es un protocolo open-source crucial usado en industrias como Manufacturing, Energy, Aerospace y Defence para el intercambio de datos y el control de equipos. Permite que equipos de diferentes proveedores se comuniquen, especialmente con PLCs.

Su configuración permite medidas de seguridad fuertes, pero con frecuencia, para compatibilidad con dispositivos antiguos, estas se relajan, exponiendo los sistemas a riesgos. Además, encontrar servicios OPC UA puede ser complicado ya que los escáneres de red podrían no detectarlos si están en puertos no estándar.

**Default port:** 4840 (binary `opc.tcp`). Muchos proveedores exponen endpoints de discovery separados (`/discovery`), enlaces HTTPS (4843/443), o puertos de escucha específicos del proveedor como 49320 (KepServerEX), 62541 (OPC Foundation reference stack) y 48050 (UaGateway). Espere múltiples endpoints por host, cada uno anunciando perfil de transporte, política de seguridad y soporte de tokens de usuario.

| Built-in NodeId | Why it matters |
| --- | --- |
| `i=2253` (`0:Server`) | Contiene `ServerArray`, cadenas de vendor/product y namespace URIs.
| `i=2256` (`ServerStatus`) | Revela uptime, estado actual y, opcionalmente, información de build.
| `i=2267` (`ServerDiagnosticsSummary`) | Muestra recuentos de sesiones, solicitudes abortadas, etc. Excelente para fingerprinting de intentos de brute-force.
| `i=85` (`ObjectsFolder`) | Punto de entrada para recorrer etiquetas de dispositivos expuestos, métodos y alarmas.
```text
PORT     STATE SERVICE REASON
4840/tcp open  unknown syn-ack
```
## Pentesting OPC UA

Para detectar problemas de seguridad en servidores OPC UA, escanéalos con [OpalOPC](https://opalopc.com/).
```bash
opalopc -vv opc.tcp://$target_ip_or_hostname:$target_port
```
### Guía de descubrimiento y enumeración

1. **Localizar todos los transportes OPC UA**
```bash
nmap -sV -Pn -n --open -p 4840,4843,49320,48050,53530,62541 $TARGET
```
Repita en direcciones de grupo UDP si el entorno usa descubrimiento multicast LDS-ME.

2. **Identificación (fingerprinting) de endpoints**
- Invocar `FindServers`/`GetEndpoints` sobre cada transporte para capturar `SecurityPolicyUri`, `SecurityMode`, `UserTokenType`, la URI de la aplicación y las cadenas de producto.
- Enumerar espacios de nombres para poder resolver NodeIds específicos del proveedor; abusar de colisiones de espacios de nombres para inducir a los clientes a cargar esquemas controlados por el atacante.

3. **Recorrer el espacio de direcciones**
- Comenzar en `ObjectsFolder (i=85)` y de forma recursiva `Browse`/`Read` para encontrar variables de proceso escribibles, nodos `Method` y nodos de historizador/log.
- Consultar `ServerStatus.BuildInfo` para entender la procedencia del firmware, y `ServerCapabilities.OperationLimits` para evaluar cuán fácil es agotar los recursos del servidor.
- Si el acceso anónimo está permitido, pruebe inmediatamente `Call` en métodos de mantenimiento (p. ej., `ns=2;s=Reset`, `ns=2;s=StartMotor`). Muchos proveedores olvidan enlazar permisos de roles a métodos personalizados.

4. **Abuso de sesiones**
- Reutilizar o clonar valores `AuthenticationToken` de otras sesiones (capturados vía MITM o exposición de diagnósticos) para secuestrar suscripciones existentes.
- Forzar al servidor a un flooding de `SessionDiagnostics` creando docenas de sesiones inactivas; algunas stacks se bloquean cuando se excede el límite `MaxSessionCount`.

### Evaluación automatizada con OpalOPC

- El escáner puede ejecutarse de forma interactiva o headless, lo cual es útil para líneas base OT estilo CI/CD. Canalice sus hallazgos legibles por máquina hacia su flujo de reporting para resaltar inicios de sesión anónimos, políticas débiles, errores de validación de certificados y variables escribibles en minutos.
- Combine la salida de OpalOPC con navegación manual: inyecte la lista de endpoints descubiertos en sus propias herramientas, luego explote selectivamente nodos de alto impacto (p. ej., `MotorControl/StartStop`, `RecipeManager/Upload`).

### Atacando políticas de seguridad antiguas (Basic128Rsa15)

- **Oráculo estilo Bleichenbacher:** Sistemas que aún permiten la política obsoleta `Basic128Rsa15` (a menudo activada por banderas de compilación como `CMPOPCUASTACK_ALLOW_SHA1_BASED_SECURITY`) filtran diferencias en la validación del padding. Explótelo inundando los handshakes `CreateSession` / `OpenSecureChannel` con blobs PKCS#1 v1.5 diseñados para recuperar la clave privada del certificado del servidor, y luego suplante al servidor o descifre el tráfico.
- **Bypass de autenticación:** El stack .NET Standard de OPC Foundation anterior a 1.5.374.158 (CVE-2024-42512) y productos dependientes permiten que atacantes no autenticados fuerzen esa política antigua y posteriormente omitan la autenticación a nivel de aplicación. Una vez que posea el material de clave puede presentar `UserIdentityTokens` arbitrarios, reproducir solicitudes firmadas `ActivateSession` y operar la planta como una estación de ingeniería confiable.
- **Flujo operativo:**
1. Enumere políticas con `GetEndpoints` y anote cualquier entrada `Basic128Rsa15`.
2. Negocie esa política explícitamente (`SecurityPolicyUri` en `CreateSession`), luego ejecute su bucle de oráculo hasta que la clave recuperada sea válida.
3. Abuse la clave para forjar una sesión de alto privilegio, cambiar roles o degradar silenciosamente otros clientes actuando como un proxy inverso malicioso.
- **CODESYS Runtime Toolkit (<3.5.21.0)** reactivaba Basic128Rsa15 siempre que los integradores compilaban con `CMPOPCUASTACK_ALLOW_SHA1_BASED_SECURITY`. Cambie esa bandera, vuelva a ejecutar el flujo de oráculo anterior y podrá leak la clave privada del runtime para suplantar estaciones de ingeniería confiables hasta que se despliegue el parche 3.5.21.0 o superior.
- OPC Foundation publicó simultáneamente CVE-2024-42513 para bindings HTTPS. Incluso si su objetivo declara TLS, asegúrese de que no está cayendo silenciosamente a Basic128Rsa15 para el transporte binario detrás del proxy.

### Lista de exploits a vigilar (2024-2025)

- **open62541 fuzz_binary_decode (CVE-2024-53429):** Los chunks de SecureChannel que declaran cuerpos `ExtensionObject` sobredimensionados hacen que el decodificador desreferencie memoria liberada, por lo que un atacante pre-auth puede bloquear repetidamente servidores UA que embeben open62541 ≤1.4.6. Reutilice el corpus de Claroty (`opcua_message_boofuzz_db`) o cree su propio harness Boofuzz para bombardear solicitudes `OpenSecureChannel` mutadas hasta que el watchdog mate el proceso, luego reenumere porque muchos integradores vuelven al modo anónimo tras el reinicio.
- **Softing OPC UA C++ SDK / edgeConnector / edgeAggregator (CVE-2025-7390):** La canalización TLS de client-auth acepta cualquier certificado que reitere un Common Name de confianza, por lo que puede crear un certificado descartable, copiar el CN de un ingeniero de planta e iniciar sesión con datos arbitrarios de `UserNameIdentityToken` o `IssuedIdentityToken`. Combine esto con una degradación a Basic128Rsa15 para eliminar las comprobaciones de integridad e impersonar persistentemente a los operadores hasta que se reconstruyan las listas de confianza.

### Creación de clientes OPC UA para explotación

- **Clientes personalizados:** Bibliotecas drop-in (python-opcua/asyncua, node-opcua, open62541) le permiten implementar lógica de exploit usted mismo. Siempre haga cumplir el índice de namespace objetivo para evitar escrituras accidentales entre espacios de nombres cuando los proveedores reordenen namespaces tras actualizaciones de firmware.
- **Checklist de abuso de nodos:**
- `HistoryRead` sobre tags de producción para capturar snapshots de recetas propietarias.
- `TranslateBrowsePathsToNodeIds` para resolver nombres legibles por humanos de activos en NodeIds que pueden entregarse a gadgets como el framework de Claroty.
- `Call` + `Method` nodos para activar tareas de mantenimiento (subida de firmware, calibración, reinicios de dispositivo).
- Abuso de `RegisterNodes` para fijar nodos de acceso frecuente y luego agotar a clientes legítimos al nunca liberar los handles.
- **Pruebas de hardening de sesiones:** Intente enlazar docenas de suscripciones con intervalos de publicación extremadamente bajos (por debajo de 50 ms) además de colas de monitored-item sobredimensionadas. Muchas stacks malcalculan `RevisedPublishingInterval` y se bloquean por desbordes del scheduler.

### Herramientas para fuzzing y desarrollo de exploits

Claroty Team82 lanzó un `opcua-exploit-framework` de código abierto que empaqueta años de investigación de nivel Pwn2Own en módulos reutilizables:

- **Modos:** `sanity` (lecturas/browses ligeros), `attacks` (p. ej., starvation del thread pool, DoS por subida de archivos), `corpus` (reproducción de payloads de fuzzing), `server` (servidor OPC UA malicioso para backdoor a clientes).
- **Patrón de uso:**
```bash
# Run a DoS attack against a Prosys Simulation Server endpoint
python3 main.py prosys 10.10.10.10 53530 /OPCUA/SimulationServer thread_pool_wait_starvation

# Replay an entire Boofuzz corpus against open62541
python3 main.py open62541 192.168.1.50 4840 / opcua_message_boofuzz_db input_corpus_minimized/opcua.db
```
- **Escenario de servidor malicioso:** El servidor incluido basado en asyncua le permite atacar software cliente sirviendo espacios de direcciones maliciosos (por ejemplo, respuestas con `ExtensionObject`s sobredimensionados para disparar bugs de parsing en clones de UA Expert).
- **Cobertura objetivo:** Los perfiles integrados mapean a Kepware, Ignition, Unified Automation, Softing SIS, Triangle Microworks, Node-OPCUA, Python OPC UA, Milo, open62541, etc., por lo que puede cambiar rápidamente entre stacks sin reescribir payloads.
- **Consejos de integración:** Enlace su salida con sus propios fuzzers—rocíe primero los payloads del `corpus`, luego haga que OpalOPC re-verifique si el crash resucitó valores predeterminados inseguros (inicio de sesión anónimo, acceso de escritura a setpoints, etc.).

### Explotando bypasses de autenticación

Si se encuentran vulnerabilidades de bypass de autenticación, puede configurar un [OPC UA client](https://www.prosysopc.com/products/opc-ua-browser/) en consecuencia y ver a qué puede acceder. Esto puede permitir desde leer valores de proceso hasta operar equipos industriales pesados.

Para hacerse una idea del dispositivo al que tiene acceso, lea los valores del nodo "ServerStatus" en el espacio de direcciones y busque en Google un manual de uso.

## Shodan

- `port:4840`
- `port:62541 "OPC UA"`
- `ssl:"urn:opcua"`
- `product:"opc ua"`

Combine la búsqueda con cadenas de proveedor (`"Ignition OPC UA"`, `"KepServerEX"`) o certificados (`"CN=UaServerCert"`) para priorizar activos de alto valor antes de empezar pruebas intrusivas.

## References

- [https://opalopc.com/how-to-hack-opc-ua/](https://opalopc.com/how-to-hack-opc-ua/)
- [https://github.com/claroty/opcua-exploit-framework](https://github.com/claroty/opcua-exploit-framework)
- [https://certvde.com/en/advisories/VDE-2025-022/](https://certvde.com/en/advisories/VDE-2025-022/)
- [https://nvd.nist.gov/vuln/detail/CVE-2024-53429](https://nvd.nist.gov/vuln/detail/CVE-2024-53429)
- [https://industrial.softing.com/fileadmin/psirt/downloads/2025/CVE-2025-7390.html](https://industrial.softing.com/fileadmin/psirt/downloads/2025/CVE-2025-7390.html)


{{#include ../banners/hacktricks-training.md}}
