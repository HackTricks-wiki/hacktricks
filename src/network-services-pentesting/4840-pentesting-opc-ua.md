# 4840 - Pentesting OPC UA

{{#include ../banners/hacktricks-training.md}}


## बुनियादी जानकारी

**OPC UA**, जिसका पूरा नाम **Open Platform Communications Unified Access** है, एक महत्वपूर्ण ओपन-सोर्स प्रोटोकॉल है जो Manufacturing, Energy, Aerospace और Defence जैसी उद्योगों में डेटा एक्सचेंज और उपकरण नियंत्रण के लिए उपयोग होता है। यह अलग-अलग विक्रेताओं के उपकरणों को आपस में संवाद करने में सक्षम बनाता है, विशेषकर PLCs के साथ।

इसकी कॉन्फ़िगरेशन मजबूत सुरक्षा उपायों की अनुमति देती है, लेकिन अक्सर पुराने उपकरणों के साथ कम्पैटिबिलिटी के लिए सुरक्षा कम कर दी जाती है, जिससे सिस्टम जोखिम के संपर्क में आ सकते हैं। इसके अतिरिक्त, OPC UA सेवाओं का पता लगाना मुश्किल हो सकता है क्योंकि नेटवर्क स्कैनर उन्हें गैर-मानक पोर्ट्स पर होने पर पहचान नहीं पाते।

**डिफ़ॉल्ट पोर्ट:** 4840 (binary `opc.tcp`). कई वेंडर अलग discovery endpoints (`/discovery`), HTTPS bindings (4843/443), या vendor-specific listener पोर्ट्स जैसे 49320 (KepServerEX), 62541 (OPC Foundation reference stack) और 48050 (UaGateway) एक्सपोज़ करते हैं। हर होस्ट पर कई endpoints की उम्मीद रखें, जो प्रत्येक transport profile, security policy और user-token support की घोषणा करते हैं।

| Built-in NodeId | Why it matters |
| --- | --- |
| `i=2253` (`0:Server`) | इसमें `ServerArray`, vendor/product strings और namespace URIs होते हैं।
| `i=2256` (`ServerStatus`) | अपटाइम, वर्तमान स्थिति, और वैकल्पिक रूप से build जानकारी प्रकट करता है।
| `i=2267` (`ServerDiagnosticsSummary`) | सेशन की गिनती, aborted requests आदि दिखाता है। ब्रूट-फोर्स प्रयासों के फिंगरप्रिंटिंग के लिए बहुत उपयोगी।
| `i=85` (`ObjectsFolder`) | खुले हुए डिवाइस टैग्स, methods और अलार्म्स को ब्राउज़ करने का प्रवेश बिंदु।
```text
PORT     STATE SERVICE REASON
4840/tcp open  unknown syn-ack
```
## Pentesting OPC UA

OPC UA सर्वरों में सुरक्षा समस्याओं का पता लगाने के लिए, इसे [OpalOPC](https://opalopc.com/) से स्कैन करें।
```bash
opalopc -vv opc.tcp://$target_ip_or_hostname:$target_port
```
### डिस्कवरी और एनेमरेशन प्लेबुक

1. **सभी OPC UA ट्रांसपोर्टों का पता लगाएँ**
```bash
nmap -sV -Pn -n --open -p 4840,4843,49320,48050,53530,62541 $TARGET
```
यदि वातावरण LDS-ME multicast discovery का उपयोग करता है तो UDP ग्रुप पते पर भी दोहराएँ।

2. **एंडपॉइंट्स के फिंगरप्रिंट बनाएं**
- प्रत्येक ट्रांसपोर्ट पर `FindServers`/`GetEndpoints` को कॉल करके `SecurityPolicyUri`, `SecurityMode`, `UserTokenType`, application URI और product स्ट्रिंग्स कैप्चर करें।
- namespaces को enumerate करें ताकि आप vendor-specific NodeIds को resolve कर सकें; namespace collisions का दुरुपयोग करके clients को attacker-controlled schemas लोड करने के लिए उकसाएं।

3. **एड्रेस स्पेस में ब्राउज़ करें**
- `ObjectsFolder (i=85)` से शुरू करें और recursively `Browse`/`Read` करके writable process variables, `Method` nodes और historian/log nodes खोजें।
- फर्मवेयर की उत्पत्ति समझने के लिए `ServerStatus.BuildInfo` को क्वेरी करें, और सर्वर संसाधनों को खत्म करना कितना आसान है यह समझने के लिए `ServerCapabilities.OperationLimits` देखें।
- यदि anonymous access की अनुमति है, तो तुरंत maintenance methods (उदा., `ns=2;s=Reset`, `ns=2;s=StartMotor`) पर `Call` का परीक्षण करें। कई वेन्डर custom methods पर role permissions बांधना भूल जाते हैं।

4. **Session का दुरुपयोग**
- अन्य सत्रों से `AuthenticationToken` मानों का पुन: उपयोग या क्लोन करें (MITM या diagnostics exposure के माध्यम से कैप्चर किए गए) ताकि मौजूदा subscriptions को हाईजैक किया जा सके।
- दर्जनों inactive sessions बनाकर सर्वर को `SessionDiagnostics` फ्लडलिंग में मजबूर करें; कुछ stacks `MaxSessionCount` सीमा पार होते ही क्रैश हो जाते हैं।

### OpalOPC के साथ स्वचालित आकलन

- स्कैनर इंटरैक्टिव या headless दोनों मोड में चल सकता है, जो CI/CD स्टाइल OT बेसलाइनों के लिए सुविधाजनक है। इसके मशीन-रीडेबल findings को अपने रिपोर्टिंग पाइपलाइन में पाइप करें ताकि anonymous logins, कमजोर policies, certificate validation त्रुटियाँ और writable variables मिनटों में हाइलाइट हो सकें।
- OpalOPC आउटपुट को मैन्युअल ब्राउज़िंग के साथ संयोजित करें: डिस्कवर्ड endpoint सूची को अपने कस्टम टूलिंग में वापस खिलाएँ, फिर selectively high-impact nodes (उदा., `MotorControl/StartStop`, `RecipeManager/Upload`) के साथ weaponize करें।

### लेगेसी सिक्योरिटी नीतियों (Basic128Rsa15) पर हमला

- **Bleichenbacher-style oracle:** जो सिस्टम अब भी deprecated `Basic128Rsa15` नीति की अनुमति देते हैं (अक्सर build flags जैसे `CMPOPCUASTACK_ALLOW_SHA1_BASED_SECURITY` द्वारा सक्षम), वे padding validation के अंतर लीक करते हैं। crafted PKCS#1 v1.5 ब्लॉब्स के साथ `CreateSession` / `OpenSecureChannel` हैंडशेक्स को फ्लड करके सर्वर सर्टिफिकेट की प्राइवेट की रिकवर करें, फिर सर्वर की नकल करें या ट्रैफ़िक डिक्रिप्ट करें।
- **Authentication bypass:** OPC Foundation की .NET Standard stack 1.5.374.158 से पहले (CVE-2024-42512) और उससे प्रभावित उत्पाद unauthenticated attackers को उस legacy policy पर मजबूर कर application-level authentication को स्किप करने देते हैं। एक बार जब आप key material पर नियंत्रण कर लेते हैं तो आप arbitrary `UserIdentityTokens` पेश कर सकते हैं, signed `ActivateSession` requests को replay कर सकते हैं, और प्लांट को एक trusted engineering workstation के रूप में ऑपरेट कर सकते हैं।
- **Operational workflow:**
1. `GetEndpoints` के साथ policies को enumerate करें और किसी भी `Basic128Rsa15` entry को नोट करें।
2. स्पष्ट रूप से उस policy पर negotiate करें (`SecurityPolicyUri` को `CreateSession` में सेट करके), फिर अपने oracle लूप को चलाएँ जब तक recovered key validate न हो जाए।
3. high-privilege session को forge करने, roles बदलने, या rogue reverse proxy बनकर अन्य clients को चुपके से downgrade करने के लिए key का दुरुपयोग करें।
- **CODESYS Runtime Toolkit (<3.5.21.0)** integrators जब `CMPOPCUASTACK_ALLOW_SHA1_BASED_SECURITY` के साथ compile करते हैं तब Basic128Rsa15 को पुनः सक्षम कर देता था। उस flag को flip करें, ऊपर बताई गई oracle workflow को फिर चलाएँ, और आप runtime की private key लीक कर सकते हैं ताकि trusted engineering workstations की नकल कर सकें जब तक कि patch level 3.5.21.0 या बाद में लागू न हो।
- OPC Foundation ने एक साथ HTTPS bindings के लिए CVE-2024-42513 भी प्रकाशित किया। भले ही आपका लक्ष्य TLS का दावा करता हो, सुनिश्चित करें कि proxy के पीछे बाइनरी ट्रांसपोर्ट के लिए वह चुपके से Basic128Rsa15 पर fallback नहीं कर रहा है।

### 2024-2025 exploit वॉचलिस्ट

- **open62541 fuzz_binary_decode (CVE-2024-53429):** SecureChannel chunks जो oversized `ExtensionObject` बॉडीज़ घोषित करते हैं, decoder को freed memory को dereference करने पर मजबूर करते हैं, इसलिए एक pre-auth attacker बार-बार open62541 ≤1.4.6 एम्बेडेड UA सर्वरों को क्रैश कर सकता है। Claroty corpus (`opcua_message_boofuzz_db`) का पुन: उपयोग करें या अपना Boofuzz harness बनाकर mutated `OpenSecureChannel` requests स्पैम करें जब तक watchdog process को नहीं मार देता, फिर पुनः-एनेमरेट करें क्योंकि कई integrators reboot के बाद anonymous mode पर fallback कर देते हैं।
- **Softing OPC UA C++ SDK / edgeConnector / edgeAggregator (CVE-2025-7390):** TLS client-auth पाइपलाइन किसी भी सर्टिफिकेट को स्वीकार कर लेती है जो एक trusted Common Name को replay करता है, इसलिए आप एक throwaway cert बना सकते हैं, plant engineer से CN कॉपी कर सकते हैं, और arbitrary `UserNameIdentityToken` या `IssuedIdentityToken` डेटा के साथ लॉग इन कर सकते हैं। इसे Basic128Rsa15 पर downgrade के साथ जोड़ें ताकि integrity checks हट जाएँ और operators की नकल स्थायी रूप से की जा सके जब तक trustlists पुनर्निर्मित न हों।

### exploitation के लिए OPC UA क्लाइंट बनाना

- **Custom clients:** drop-in libraries (python-opcua/asyncua, node-opcua, open62541) आपको खुद exploit लॉजिक चलाने देती हैं। firmware updates के बाद vendors जब namespaces को reorder करते हैं तो अनजाने में cross-namespace writes से बचने के लिए हमेशा अपने target namespace index को enforce करें।
- **Node दुरुपयोग चेकलिस्ट:**
- उत्पादन टैग्स पर `HistoryRead` करके proprietary recipes के snapshots लें।
- human-readable asset नामों को NodeIds में resolve करने के लिए `TranslateBrowsePathsToNodeIds` का उपयोग करें ताकि उन्हें Claroty जैसी frameworks को खिलाया जा सके।
- maintenance tasks (firmware upload, calibration, device reboots) ट्रिगर करने के लिए `Call` + `Method` nodes का उपयोग करें।
- अक्सर एक्सेस किए जाने वाले nodes को pin करने के लिए `RegisterNodes` का दुरुपयोग करें और फिर handles कभी रिलीज़ न करके legitimate clients को starve करें।
- **Session hardening tests:** बेहद कम publishing intervals (50 ms से भी कम) और oversized monitored-item queues के साथ दर्जनों subscriptions बांधने का प्रयास करें। कई stacks `RevisedPublishingInterval` को गलत गणना करते हैं और scheduler overflows के कारण क्रैश हो जाते हैं।

### Fuzzing और exploit development टूलिंग

Claroty Team82 ने एक ओपन-सोर्स `opcua-exploit-framework` रिलीज़ किया है जो वर्षों के Pwn2Own-ग्रेड रिसर्च को reusable modules में पैकेज करता है:

- **Modes:** `sanity` (हल्के पढ़ने/ब्राउज़), `attacks` (उदा., thread pool starvation, file upload DoS), `corpus` (replay fuzzing payloads), `server` (rogue OPC UA server जो clients को backdoor करता है)।
- **Usage pattern:**
```bash
# Run a DoS attack against a Prosys Simulation Server endpoint
python3 main.py prosys 10.10.10.10 53530 /OPCUA/SimulationServer thread_pool_wait_starvation

# Replay an entire Boofuzz corpus against open62541
python3 main.py open62541 192.168.1.50 4840 / opcua_message_boofuzz_db input_corpus_minimized/opcua.db
```
- **Rogue server scenario:** bundled asyncua-based server आपको client software को लक्ष्य बनाने देता है by malicious address spaces serve करके (उदा., oversized `ExtensionObject`s के साथ responses जो UA Expert क्लोन्स में parsing bugs ट्रिगर करें)।
- **Target coverage:** Built-in profiles Kepware, Ignition, Unified Automation, Softing SIS, Triangle Microworks, Node-OPCUA, Python OPC UA, Milo, open62541, आदि से मिलते हैं, ताकि आप बिना payloads को फिर से लिखे stacks के बीच जल्दी से स्वैप कर सकें।
- **Integration tips:** पहले `corpus` payloads स्प्रे करें—फिर OpalOPC से verify कराएं कि crash ने insecure defaults (anonymous login, setpoint write access, इत्यादि) को resurrect किया या नहीं।

### Authentication bypasses का दुरुपयोग

यदि authentication bypass कमजोरियाँ मिलीं, तो आप एक [OPC UA client](https://www.prosysopc.com/products/opc-ua-browser/) को अनुकूलित तरीके से कॉन्फ़िगर कर सकते हैं और देख सकते हैं कि आप क्या एक्सेस कर सकते हैं। इससे केवल process values पढ़ने से लेकर भारी-भरकम इंडस्ट्रियल उपकरणों को वास्तविक रूप से संचालित करने तक कुछ भी संभव हो सकता है।

जिस डिवाइस तक आपकी पहुँच है उसका अंदाज़ा लगाने के लिए, address space में "ServerStatus" node मान पढ़ें और उसके उपयोग मैनुअल के लिए google करें।

## Shodan

- `port:4840`
- `port:62541 "OPC UA"`
- `ssl:"urn:opcua"`
- `product:"opc ua"`

search को vendor strings (`"Ignition OPC UA"`, `"KepServerEX"`) या certificates (`"CN=UaServerCert"`) के साथ जोड़ें ताकि intrusive testing शुरू करने से पहले high-value assets को प्राथमिकता दी जा सके।

## References

- [https://opalopc.com/how-to-hack-opc-ua/](https://opalopc.com/how-to-hack-opc-ua/)
- [https://github.com/claroty/opcua-exploit-framework](https://github.com/claroty/opcua-exploit-framework)
- [https://certvde.com/en/advisories/VDE-2025-022/](https://certvde.com/en/advisories/VDE-2025-022/)
- [https://nvd.nist.gov/vuln/detail/CVE-2024-53429](https://nvd.nist.gov/vuln/detail/CVE-2024-53429)
- [https://industrial.softing.com/fileadmin/psirt/downloads/2025/CVE-2025-7390.html](https://industrial.softing.com/fileadmin/psirt/downloads/2025/CVE-2025-7390.html)


{{#include ../banners/hacktricks-training.md}}
