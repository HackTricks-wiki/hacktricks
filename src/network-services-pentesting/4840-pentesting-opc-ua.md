# 4840 - Pentesting OPC UA

{{#include ../banners/hacktricks-training.md}}


## Informações Básicas

**OPC UA**, que significa **Open Platform Communications Unified Access**, é um protocolo de código aberto crucial usado em várias indústrias como Fabricação, Energia, Aeroespacial e Defesa para troca de dados e controle de equipamentos. Ele permite que equipamentos de diferentes vendors se comuniquem, especialmente com PLCs.

Sua configuração permite medidas de segurança fortes, mas frequentemente, para compatibilidade com dispositivos mais antigos, essas medidas são reduzidas, expondo os sistemas a riscos. Além disso, encontrar serviços OPC UA pode ser complicado, já que scanners de rede podem não detectá-los se estiverem em portas não padrão.

**Default port:** 4840 (binary `opc.tcp`). Muitos vendors expõem endpoints de discovery separados (`/discovery`), bindings HTTPS (4843/443), ou portas de listener específicas do vendor como 49320 (KepServerEX), 62541 (OPC Foundation reference stack) e 48050 (UaGateway). Espere múltiplos endpoints por host, cada um anunciando perfil de transporte, política de segurança e suporte a user-token.

| NodeId embutido | Por que é importante |
| --- | --- |
| `i=2253` (`0:Server`) | Contém `ServerArray`, vendor/product strings e namespace URIs.
| `i=2256` (`ServerStatus`) | Revela tempo de atividade, estado atual e, opcionalmente, informações de build.
| `i=2267` (`ServerDiagnosticsSummary`) | Mostra contagens de sessões, requisições abortadas, etc. Excelente para fingerprinting de tentativas de brute-force.
| `i=85` (`ObjectsFolder`) | Ponto de entrada para percorrer tags expostas do dispositivo, métodos e alarmes.
```text
PORT     STATE SERVICE REASON
4840/tcp open  unknown syn-ack
```
## Pentesting OPC UA

Para revelar problemas de segurança em servidores OPC UA, faça um scan com [OpalOPC](https://opalopc.com/).
```bash
opalopc -vv opc.tcp://$target_ip_or_hostname:$target_port
```
### Playbook de Descoberta e Enumeração

1. **Localize todos os transportes OPC UA**
```bash
nmap -sV -Pn -n --open -p 4840,4843,49320,48050,53530,62541 $TARGET
```
Repita em endereços de grupo UDP se o ambiente usar descoberta multicast LDS-ME.

2. **Fingerprint de endpoints**
- Invoque `FindServers`/`GetEndpoints` sobre cada transporte para capturar `SecurityPolicyUri`, `SecurityMode`, `UserTokenType`, application URI e strings de produto.
- Enumere namespaces para que você possa resolver NodeIds específicos do fornecedor; abuse de colisões de namespace para induzir clientes a carregarem schemas controlados pelo atacante.

3. **Percorra o address space**
- Comece em `ObjectsFolder (i=85)` e recursivamente `Browse`/`Read` para encontrar variáveis de processo graváveis, nós `Method` e nós de historian/log.
- Consulte `ServerStatus.BuildInfo` para entender a proveniência do firmware, e `ServerCapabilities.OperationLimits` para avaliar quão fácil é esgotar recursos do servidor.
- Se acesso anônimo for permitido, teste imediatamente `Call` em métodos de manutenção (por exemplo, `ns=2;s=Reset`, `ns=2;s=StartMotor`). Muitos fornecedores esquecem de vincular permissões de função a métodos customizados.

4. **Abuso de sessão**
- Reutilize ou clone valores de `AuthenticationToken` de outras sessões (capturados via MITM ou exposição de diagnósticos) para sequestrar subscriptions existentes.
- Force o servidor em flooding de `SessionDiagnostics` criando dezenas de sessões inativas; algumas stacks travam quando o limite `MaxSessionCount` é excedido.

### Avaliação automatizada com OpalOPC

- O scanner pode rodar interativamente ou headless, o que é útil para baselines OT em estilo CI/CD. Encaminhe seus achados em formato legível por máquina para seu pipeline de report, para destacar logins anônimos, políticas fracas, erros de validação de certificados e variáveis graváveis em minutos.
- Combine a saída do OpalOPC com navegação manual: alimente a lista de endpoints descobertos de volta em suas ferramentas customizadas, então arme seletivamente nós de alto impacto (por exemplo, `MotorControl/StartStop`, `RecipeManager/Upload`).

### Atacando políticas de segurança legadas (Basic128Rsa15)

- **Oráculo estilo Bleichenbacher:** Sistemas que ainda permitem a política obsoleta `Basic128Rsa15` (frequentemente habilitada via flags de build como `CMPOPCUASTACK_ALLOW_SHA1_BASED_SECURITY`) vazam diferenças na validação de padding. Explore isso enchendo handshakes `CreateSession` / `OpenSecureChannel` com blobs PKCS#1 v1.5 construídos para recuperar a chave privada do certificado do servidor, então imite o servidor ou decripte o tráfego.
- **Bypass de autenticação:** A stack .NET Standard da OPC Foundation anterior à 1.5.374.158 (CVE-2024-42512) e produtos dependentes permitem que atacantes não autenticados forcem essa política legada e subsequentemente pulem a autenticação em nível de aplicação. Uma vez que você possui o material de chave, pode apresentar `UserIdentityTokens` arbitrários, reproduzir `ActivateSession` assinadas e operar a planta como uma estação de engenharia confiável.
- **Fluxo operacional:**
1. Enumere políticas com `GetEndpoints` e observe quaisquer entradas `Basic128Rsa15`.
2. Negocie explicitamente essa política (`SecurityPolicyUri` em `CreateSession`), então execute seu loop de oráculo até que a chave recuperada seja validada.
3. Abuse da chave para forjar uma sessão de alto privilégio, trocar papéis, ou degradar silenciosamente outros clientes agindo como um rogue reverse proxy.
- A OPC Foundation publicou simultaneamente CVE-2024-42513 para bindings HTTPS. Mesmo que seu alvo afirme TLS, certifique-se que não esteja silenciosamente caindo para Basic128Rsa15 para o transporte binário atrás do proxy.

### Construindo clientes OPC UA para exploração

- **Clientes customizados:** Bibliotecas drop-in (python-opcua/asyncua, node-opcua, open62541) permitem que você conduza a lógica de exploit você mesmo. Sempre force seu índice de namespace alvo para evitar escritas cross-namespace acidentais quando os fornecedores reordenam namespaces após updates de firmware.
- **Checklist de abuso de nós:**
- `HistoryRead` em tags de produção para snapshot de receitas proprietárias.
- `TranslateBrowsePathsToNodeIds` para resolver nomes legíveis por humanos de ativos em NodeIds que podem ser alimentados em gadgets como o framework da Claroty.
- `Call` + nós `Method` para disparar tarefas de manutenção (upload de firmware, calibração, reboot de dispositivos).
- Uso indevido de `RegisterNodes` para fixar nós acessados frequentemente e então privar clientes legítimos ao nunca liberar os handles.
- **Testes de hardening de sessão:** Tente vincular dezenas de subscriptions com intervalos de publicação extremamente baixos (abaixo de 50 ms) mais filas de monitored-item superdimensionadas. Muitas stacks mal calculam `RevisedPublishingInterval` e travam devido a estouros do scheduler.

### Fuzzing & tooling de desenvolvimento de exploit

A Claroty Team82 lançou um `opcua-exploit-framework` open-source que empacota anos de pesquisa ao nível Pwn2Own em módulos reutilizáveis:

- **Modos:** `sanity` (reads/browses leves), `attacks` (por exemplo, thread pool starvation, file upload DoS), `corpus` (replay fuzzing payloads), `server` (rogue OPC UA server para backdooring de clientes).
- **Padrão de uso:**
```bash
# Run a DoS attack against a Prosys Simulation Server endpoint
python3 main.py prosys 10.10.10.10 53530 /OPCUA/SimulationServer thread_pool_wait_starvation

# Replay an entire Boofuzz corpus against open62541
python3 main.py open62541 192.168.1.50 4840 / opcua_message_boofuzz_db input_corpus_minimized/opcua.db
```
- **Cenário de rogue server:** O servidor baseado em asyncua empacotado permite que você foque software cliente servindo address spaces maliciosos (por exemplo, respostas com `ExtensionObject`s superdimensionados para disparar bugs de parsing em clones do UA Expert).
- **Cobertura de alvos:** Perfis embutidos mapeiam para Kepware, Ignition, Unified Automation, Softing SIS, Triangle Microworks, Node-OPCUA, Python OPC UA, Milo, open62541, etc., permitindo trocar rapidamente entre stacks sem reescrever payloads.
- **Dicas de integração:** Encadeie sua saída com seus próprios fuzzers—spray os payloads do `corpus` primeiro, então faça o OpalOPC re-verificar se o crash ressuscitou defaults inseguros (login anônimo, acesso de escrita em setpoint, etc.).

### Explorando bypasses de autenticação

Se vulnerabilidades de bypass de autenticação forem encontradas, você pode configurar um [OPC UA client](https://www.prosysopc.com/products/opc-ua-browser/) apropriadamente e ver o que consegue acessar. Isso pode permitir desde apenas leitura de valores de processo até operar equipamento industrial de grande porte.

Para ter uma ideia do dispositivo ao qual você tem acesso, leia os valores do nó "ServerStatus" no address space e pesquise no Google por um manual de uso.

## Shodan

- `port:4840`
- `port:62541 "OPC UA"`
- `ssl:"urn:opcua"`
- `product:"opc ua"`

Combine a busca com strings de fornecedor (`"Ignition OPC UA"`, `"KepServerEX"`) ou certificados (`"CN=UaServerCert"`) para priorizar ativos de alto valor antes de iniciar testes intrusivos.

## Referências

- [https://opalopc.com/how-to-hack-opc-ua/](https://opalopc.com/how-to-hack-opc-ua/)
- [https://github.com/claroty/opcua-exploit-framework](https://github.com/claroty/opcua-exploit-framework)
- [https://certvde.com/en/advisories/VDE-2025-022/](https://certvde.com/en/advisories/VDE-2025-022/)


{{#include ../banners/hacktricks-training.md}}
