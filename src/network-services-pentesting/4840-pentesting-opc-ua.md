# 4840 - Pentesting OPC UA

{{#include ../banners/hacktricks-training.md}}


## Βασικές Πληροφορίες

**OPC UA**, που σημαίνει **Open Platform Communications Unified Access**, είναι ένα κρίσιμο πρωτόκολλο ανοιχτού κώδικα που χρησιμοποιείται σε διάφορες βιομηχανίες όπως Manufacturing, Energy, Aerospace και Defence για ανταλλαγή δεδομένων και έλεγχο εξοπλισμού. Επιτρέπει μοναδικά την επικοινωνία εξοπλισμού από διαφορετικούς vendors, ειδικά με PLCs.

Η διαμόρφωσή του επιτρέπει ισχυρά μέτρα ασφάλειας, αλλά συχνά, για συμβατότητα με παλαιότερες συσκευές, αυτά μειώνονται, εκθέτοντας τα συστήματα σε κινδύνους. Επιπλέον, ο εντοπισμός υπηρεσιών OPC UA μπορεί να είναι δύσκολος καθώς οι network scanners μπορεί να μην τις εντοπίζουν αν βρίσκονται σε μη τυπικές θύρες.

**Προεπιλεγμένη θύρα:** 4840 (binary `opc.tcp`). Πολλοί vendors εκθέτουν ξεχωριστά discovery endpoints (`/discovery`), HTTPS bindings (4843/443) ή vendor-specific listener ports όπως 49320 (KepServerEX), 62541 (OPC Foundation reference stack) και 48050 (UaGateway). Αναμένετε πολλαπλά endpoints ανά host, το κάθε ένα να διαφημίζει transport profile, security policy και user-token support.

| Built-in NodeId | Why it matters |
| --- | --- |
| `i=2253` (`0:Server`) | Περιέχει το `ServerArray`, συμβολοσειρές κατασκευαστή/προϊόντος και namespace URIs. |
| `i=2256` (`ServerStatus`) | Αποκαλύπτει χρόνο λειτουργίας, τρέχουσα κατάσταση και προαιρετικά πληροφορίες build. |
| `i=2267` (`ServerDiagnosticsSummary`) | Δείχνει αριθμούς συνεδριών, aborted requests, κ.λπ. Ιδανικό για fingerprinting προσπαθειών brute-force. |
| `i=85` (`ObjectsFolder`) | Σημείο εισόδου για περιήγηση σε εκτεθειμένες ετικέτες συσκευών, μεθόδους και συναγερμούς. |
```text
PORT     STATE SERVICE REASON
4840/tcp open  unknown syn-ack
```
## Pentesting OPC UA

Για να αποκαλύψετε προβλήματα ασφαλείας σε OPC UA servers, σαρώστε τους με [OpalOPC](https://opalopc.com/).
```bash
opalopc -vv opc.tcp://$target_ip_or_hostname:$target_port
```
### Playbook Ανακάλυψης & Εντοπισμού

1. **Εντοπίστε όλους τους OPC UA transports**
```bash
nmap -sV -Pn -n --open -p 4840,4843,49320,48050,53530,62541 $TARGET
```
Επαναλάβετε στις UDP group διευθύνσεις αν το περιβάλλον χρησιμοποιεί LDS-ME multicast discovery.

2. **Fingerprint endpoints**
- Εκτελέστε `FindServers`/`GetEndpoints` πάνω σε κάθε transport για να καταγράψετε `SecurityPolicyUri`, `SecurityMode`, `UserTokenType`, το application URI και τα product strings.
- Καταγράψτε τα namespaces ώστε να μπορείτε να επιλύσετε vendor-specific NodeIds· εκμεταλλευτείτε namespace collisions για να αναγκάσετε clients να φορτώσουν attacker-controlled schemas.

3. **Περιήγηση στο address space**
- Ξεκινήστε από το `ObjectsFolder (i=85)` και κάντε αναδρομικά `Browse`/`Read` για να βρείτε writable process variables, `Method` nodes και historian/log nodes.
- Query το `ServerStatus.BuildInfo` για να καταλάβετε την προέλευση του firmware, και το `ServerCapabilities.OperationLimits` για να εκτιμήσετε πόσο εύκολο είναι να εξαντληθούν οι πόροι του server.
- Αν επιτρέπεται anonymous access, δοκιμάστε άμεσα `Call` σε maintenance methods (π.χ., `ns=2;s=Reset`, `ns=2;s=StartMotor`). Πολλοί vendors ξεχνούν να δεσμεύσουν role permissions σε custom methods.

4. **Session abuse**
- Επαναχρησιμοποιήστε ή clone-άρετε τιμές `AuthenticationToken` από άλλες sessions (που έχουν καταγραφεί μέσω MITM ή diagnostics exposure) για να hijackάρετε υπάρχουσες subscriptions.
- Αναγκάστε τον server σε `SessionDiagnostics` flooding δημιουργώντας δεκάδες ανενεργές sessions· ορισμένα stacks crαshάρουν μόλις ξεπεραστεί το `MaxSessionCount` limit.

### Automated assessment with OpalOPC

- Ο scanner μπορεί να τρέξει interactive ή headless, χρήσιμο για CI/CD τύπου OT baselines. Σωλήνωστε τα machine-readable findings του στην reporting pipeline για να επισημάνετε anonymous logins, weak policies, certificate validation errors και writable variables σε λίγα λεπτά.
- Συνδυάστε την έξοδο του OpalOPC με manual browsing: τροφοδοτήστε τη λίστα discovered endpoints πίσω στα custom εργαλεία σας και στη συνέχεια επιλεκτικά weaponize high-impact nodes (π.χ., `MotorControl/StartStop`, `RecipeManager/Upload`).

### Attacking legacy security policies (Basic128Rsa15)

- Bleichenbacher-style oracle: Συστήματα που εξακολουθούν να επιτρέπουν την deprecated `Basic128Rsa15` policy (συχνά ενεργοποιημένη μέσω build flags όπως `CMPOPCUASTACK_ALLOW_SHA1_BASED_SECURITY`) leak διαφορές στην padding validation. Εκμεταλλευτείτε το αυτό πλημμυρίζοντας τα `CreateSession` / `OpenSecureChannel` handshakes με crafted PKCS#1 v1.5 blobs για να ανακτήσετε το private key του server certificate, και στη συνέχεια να impersonate τον server ή να αποκρυπτογραφήσετε την κίνηση.
- Authentication bypass: Το OPC Foundation’s .NET Standard stack πριν από την 1.5.374.158 (CVE-2024-42512) και εξαρτώμενα προϊόντα επιτρέπουν σε μη αυθεντικοποιημένους επιτιθέμενους να επιβάλουν εκείνη την legacy policy και στη συνέχεια να παρακάμψουν το application-level authentication. Μόλις αποκτήσετε το key material μπορείτε να παρουσιάσετε αυθαίρετα `UserIdentityTokens`, να replayάρετε υπογεγραμμένα `ActivateSession` requests και να λειτουργήσετε το plant ως trusted engineering workstation.
- Operational workflow:
1. Καταγράψτε τις policies με `GetEndpoints` και σημειώστε οποιεσδήποτε `Basic128Rsa15` εγγραφές.
2. Διαπραγματευτείτε ρητά εκείνη την policy (`SecurityPolicyUri` στο `CreateSession`), και τρέξτε το oracle loop μέχρι το recovered key να επικυρωθεί.
3. Κακοποιήστε το key για να δημιουργήσετε high-privilege session, αλλάξτε roles, ή quietly downgrade άλλους clients ενεργώντας ως rogue reverse proxy.
- Η OPC Foundation δημοσίευσε ταυτόχρονα το CVE-2024-42513 για HTTPS bindings. Ακόμα κι αν ο στόχος ισχυρίζεται ότι χρησιμοποιεί TLS, βεβαιωθείτε ότι δεν fallbackάρει σιωπηρά σε Basic128Rsa15 για το binary transport πίσω από proxy.

### Crafting OPC UA clients for exploitation

- Custom clients: Drop-in libraries (python-opcua/asyncua, node-opcua, open62541) σας επιτρέπουν να γράψετε exploit logic. Πάντα επιβάλλετε το target namespace index για να αποφύγετε τυχαία cross-namespace writes όταν οι vendors αναδιατάσσουν namespaces μετά από firmware updates.
- Node abuse checklist:
- `HistoryRead` σε production tags για snapshoting proprietary recipes.
- `TranslateBrowsePathsToNodeIds` για να επιλύσετε human-readable asset names σε NodeIds που μπορούν να δοθούν σε gadgets όπως το Claroty’s framework.
- `Call` + `Method` nodes για να ενεργοποιήσετε maintenance tasks (firmware upload, calibration, device reboots).
- Κακή χρήση του `RegisterNodes` για να κάνετε pin frequently accessed nodes και στη συνέχεια να starve legitimate clients μη απελευθερώνοντας ποτέ τα handles.
- Session hardening tests: Προσπαθήστε να δέσετε δεκάδες subscriptions με εξαιρετικά χαμηλά publishing intervals (κάτω από 50 ms) συν υπερμεγέθη monitored-item queues. Πολλά stacks υπολογίζουν λανθασμένα το `RevisedPublishingInterval` και crαshάρουν λόγω scheduler overflows.

### Fuzzing & exploit development tooling

Το Claroty Team82 κυκλοφόρησε ένα open-source `opcua-exploit-framework` που πακετάρει χρόνια Pwn2Own-grade έρευνας σε επαναχρησιμοποιήσιμα modules:

- Modes: `sanity` (lightweight reads/browses), `attacks` (π.χ., thread pool starvation, file upload DoS), `corpus` (replay fuzzing payloads), `server` (rogue OPC UA server για backdoor clients).
- Usage pattern:
```bash
# Run a DoS attack against a Prosys Simulation Server endpoint
python3 main.py prosys 10.10.10.10 53530 /OPCUA/SimulationServer thread_pool_wait_starvation

# Replay an entire Boofuzz corpus against open62541
python3 main.py open62541 192.168.1.50 4840 / opcua_message_boofuzz_db input_corpus_minimized/opcua.db
```
- Rogue server scenario: Ο ενσωματωμένος asyncua-based server σας επιτρέπει να στοχεύσετε client software σερβίροντας malicious address spaces (π.χ., responses με oversized `ExtensionObject`s για να ενεργοποιήσετε parsing bugs σε UA Expert clones).
- Target coverage: Τα built-in profiles αντιστοιχούν σε Kepware, Ignition, Unified Automation, Softing SIS, Triangle Microworks, Node-OPCUA, Python OPC UA, Milo, open62541, κ.λπ., ώστε να μπορείτε γρήγορα να αλλάξετε μεταξύ stacks χωρίς να ξαναγράψετε payloads.
- Integration tips: Αλυσσοδέστε την έξοδό του με τους δικούς σας fuzzers—ψεκάστε πρώτα τα `corpus` payloads, έπειτα τρέξτε το OpalOPC για να επαληθεύσετε αν το crash επανέφερε insecure defaults (anonymous login, setpoint write access, κ.λπ.).

### Exploiting authentication bypasses

Αν βρεθούν authentication bypass vulnerabilities, μπορείτε να ρυθμίσετε έναν [OPC UA client](https://www.prosysopc.com/products/opc-ua-browser/) αναλόγως και να δείτε τι μπορείτε να προσπελάσετε. Αυτό μπορεί να επιτρέψει οτιδήποτε από απλό reading process values μέχρι την πραγματική λειτουργία βαρέων βιομηχανικών μηχανημάτων.

Για να πάρετε μια ιδέα για τη συσκευή που έχετε πρόσβαση, διαβάστε τις τιμές του "ServerStatus" node στο address space και κάντε google για το usage manual.

## Shodan

- `port:4840`
- `port:62541 "OPC UA"`
- `ssl:"urn:opcua"`
- `product:"opc ua"`

Συνδυάστε την αναζήτηση με vendor strings (`"Ignition OPC UA"`, `"KepServerEX"`) ή certificates (`"CN=UaServerCert"`) για να προτεραιοποιήσετε high-value assets πριν ξεκινήσετε intrusive testing.

## References

- [https://opalopc.com/how-to-hack-opc-ua/](https://opalopc.com/how-to-hack-opc-ua/)
- [https://github.com/claroty/opcua-exploit-framework](https://github.com/claroty/opcua-exploit-framework)
- [https://certvde.com/en/advisories/VDE-2025-022/](https://certvde.com/en/advisories/VDE-2025-022/)


{{#include ../banners/hacktricks-training.md}}
