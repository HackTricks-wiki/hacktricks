# 4840 - Pentesting OPC UA

{{#include ../banners/hacktricks-training.md}}


## Βασικές Πληροφορίες

**OPC UA**, standing for **Open Platform Communications Unified Access**, είναι ένα κρίσιμο πρωτόκολλο ανοικτού κώδικα που χρησιμοποιείται σε διάφορες βιομηχανίες όπως Βιομηχανία, Ενέργεια, Αεροδιαστημική και Άμυνα για ανταλλαγή δεδομένων και έλεγχο εξοπλισμού. Επιτρέπει μοναδικά την επικοινωνία μεταξύ εξοπλισμού διαφορετικών κατασκευαστών, ιδιαίτερα με PLCs.

Η διαμόρφωσή του επιτρέπει ισχυρά μέτρα ασφάλειας, αλλά συχνά, για συμβατότητα με παλαιότερες συσκευές, αυτά μειώνονται, εκθέτοντας τα συστήματα σε κινδύνους. Επιπλέον, η ανεύρεση υπηρεσιών OPC UA μπορεί να είναι δύσκολη καθώς οι ανιχνευτές δικτύου μπορεί να μην τις εντοπίσουν εάν βρίσκονται σε μη τυπικές θύρες.

Προεπιλεγμένη θύρα: 4840 (binary `opc.tcp`). Πολλοί κατασκευαστές εκθέτουν ξεχωριστά discovery endpoints (`/discovery`), HTTPS bindings (4843/443), ή θύρες ακρόασης ειδικές ανά vendor όπως 49320 (KepServerEX), 62541 (OPC Foundation reference stack) και 48050 (UaGateway). Αναμένετε πολλαπλά endpoints ανά host, το καθένα διαφημίζει προφίλ μεταφοράς, πολιτική ασφάλειας και υποστήριξη user-token.

| Built-in NodeId | Why it matters |
| --- | --- |
| `i=2253` (`0:Server`) | Περιέχει το `ServerArray`, vendor/product strings και namespace URIs.
| `i=2256` (`ServerStatus`) | Αποκαλύπτει χρόνο λειτουργίας (uptime), τρέχουσα κατάσταση, και προαιρετικά πληροφορίες build.
| `i=2267` (`ServerDiagnosticsSummary`) | Δείχνει αριθμό συνεδριών, ακυρωμένα αιτήματα κ.ά. Χρήσιμο για fingerprinting προσπάθειες brute-force.
| `i=85` (`ObjectsFolder`) | Σημείο εισόδου για πλοήγηση στις εκτεθειμένες ετικέτες συσκευής, μεθόδους και συναγερμούς.
```text
PORT     STATE SERVICE REASON
4840/tcp open  unknown syn-ack
```
## Pentesting OPC UA

Για να αποκαλύψετε ζητήματα ασφάλειας σε OPC UA servers, σαρώστε τους με [OpalOPC](https://opalopc.com/).
```bash
opalopc -vv opc.tcp://$target_ip_or_hostname:$target_port
```
### Playbook Εντοπισμού & Απογραφής

1. **Εντοπίστε όλες τις OPC UA μεταφορές**
```bash
nmap -sV -Pn -n --open -p 4840,4843,49320,48050,53530,62541 $TARGET
```
Επαναλάβετε σε UDP group διευθύνσεις αν το περιβάλλον χρησιμοποιεί LDS-ME multicast discovery.

2. **Fingerprint endpoints**
- Κάντε `FindServers`/`GetEndpoints` πάνω σε κάθε transport για να συλλέξετε `SecurityPolicyUri`, `SecurityMode`, `UserTokenType`, application URI και product strings.
- Απογράψτε namespaces ώστε να επιλύσετε vendor-specific NodeIds· εκμεταλλευτείτε namespace collisions για να πιέσετε clients να φορτώσουν attacker-controlled schemas.

3. **Περιήγηση στο address space**
- Ξεκινήστε από `ObjectsFolder (i=85)` και αναδρομικά `Browse`/`Read` για να βρείτε writable process variables, `Method` nodes και historian/log nodes.
- Query το `ServerStatus.BuildInfo` για να κατανοήσετε την προέλευση του firmware, και το `ServerCapabilities.OperationLimits` για να εκτιμήσετε πόσο εύκολο είναι να εξαντλήσετε πόρους του server.
- Αν επιτρέπεται anonymous access, δοκιμάστε αμέσως `Call` σε maintenance methods (π.χ., `ns=2;s=Reset`, `ns=2;s=StartMotor`). Πολλοί vendors ξεχνούν να δέσουν role permissions σε custom methods.

4. **Session abuse**
- Επαναχρησιμοποιήστε ή κλωνοποιήστε `AuthenticationToken` τιμές από άλλες sessions (captured μέσω MITM ή diagnostics exposure) για να hijack υπάρχουσες subscriptions.
- Πιέστε τον server σε `SessionDiagnostics` flooding δημιουργώντας δεκάδες ανενεργές sessions· μερικά stacks crash-άρουν μόλις ξεπεραστεί το `MaxSessionCount` limit.

### Αυτοματοποιημένη αξιολόγηση με OpalOPC

- Ο scanner μπορεί να τρέξει interactive ή headless, κάτι που είναι βολικό για CI/CD style OT baselines. Στείλτε τα machine-readable findings στην reporting pipeline σας για να επισημάνετε anonymous logins, weak policies, certificate validation errors και writable variables μέσα σε λίγα λεπτά.
- Συνδυάστε το OpalOPC output με manual browsing: τροφοδοτήστε τη λίστα των ανακαλυφθέντων endpoints πίσω στα custom εργαλεία σας και στη συνέχεια επιλεκτικά weaponize high-impact nodes (π.χ., `MotorControl/StartStop`, `RecipeManager/Upload`).

### Attacking legacy security policies (Basic128Rsa15)

- **Bleichenbacher-style oracle:** Συστήματα που εξακολουθούν να επιτρέπουν την deprecated `Basic128Rsa15` policy (συχνά ενεργοποιούμενη μέσω build flags όπως `CMPOPCUASTACK_ALLOW_SHA1_BASED_SECURITY`) leak διαφορές στην padding validation. Εκμεταλλευτείτε αυτό πλημμυρίζοντας τα `CreateSession` / `OpenSecureChannel` handshakes με crafted PKCS#1 v1.5 blobs για να ανακτήσετε το private key του server certificate, και στη συνέχεια να impersonate τον server ή να decrypt την κίνηση.
- **Authentication bypass:** Το OPC Foundation .NET Standard stack πριν από την 1.5.374.158 (CVE-2024-42512) και εξαρτώμενα προϊόντα επιτρέπουν σε unauthenticated attackers να αναγκάσουν αυτή την legacy policy και στη συνέχεια να παραβλέψουν το application-level authentication. Μόλις έχετε το key material μπορείτε να παρουσιάσετε αυθαίρετα `UserIdentityTokens`, να replay-άρετε signed `ActivateSession` requests, και να operate το plant ως trusted engineering workstation.
- **Operational workflow:**
1. Απογράψτε policies με `GetEndpoints` και σημειώστε τυχόν `Basic128Rsa15` εγγραφές.
2. Διαπραγματευτείτε ρητά αυτή την policy (`SecurityPolicyUri` στο `CreateSession`), και τρέξτε το oracle loop μέχρι το recovered key να επικυρωθεί.
3. Εκμεταλλευτείτε το key για να κατασκευάσετε μια high-privilege session, να αλλάξετε roles, ή να silently downgrade άλλους clients ενεργώντας ως rogue reverse proxy.
- **CODESYS Runtime Toolkit (<3.5.21.0)** επανενεργοποιούσε το Basic128Rsa15 όποτε οι integrators compile-άρανε με `CMPOPCUASTACK_ALLOW_SHA1_BASED_SECURITY`. Αν αλλάξετε αυτό το flag και επαναλάβετε το oracle workflow πιο πάνω, μπορείτε να leak το runtime's private key για να impersonate trusted engineering workstations μέχρι να εφαρμοστεί patch level 3.5.21.0 ή μεταγενέστερο.
- Η OPC Foundation δημοσίευσε ταυτόχρονα CVE-2024-42513 για HTTPS bindings. Ακόμα κι αν ο στόχος δηλώνει TLS, βεβαιωθείτε ότι δεν κάνει silent fallback σε Basic128Rsa15 για το binary transport πίσω από τον proxy.

### 2024-2025 exploit watchlist

- **open62541 fuzz_binary_decode (CVE-2024-53429):** SecureChannel chunks που δηλώνουν υπερμεγέθη `ExtensionObject` bodies κάνουν τον decoder να dereference freed memory, έτσι ένας pre-auth attacker μπορεί επαναλαμβανόμενα να crash-άρει UA servers που ενσωματώνουν open62541 ≤1.4.6. Επαναχρησιμοποιήστε το Claroty corpus (`opcua_message_boofuzz_db`) ή φτιάξτε το δικό σας Boofuzz harness για να στείλετε mutated `OpenSecureChannel` requests μέχρι το watchdog να σκοτώσει τη διεργασία, και στη συνέχεια επανα-απογράψτε επειδή πολλοί integrators επιστρέφουν σε anonymous mode μετά το reboot.
- **Softing OPC UA C++ SDK / edgeConnector / edgeAggregator (CVE-2025-7390):** Το TLS client-auth pipeline αποδέχεται οποιοδήποτε certificate που επαναλαμβάνει ένα trusted Common Name, οπότε μπορείτε να δημιουργήσετε ένα throwaway cert, να αντιγράψετε το CN από έναν plant engineer, και να συνδεθείτε με αυθαίρετα `UserNameIdentityToken` ή `IssuedIdentityToken` δεδομένα. Συνδυάστε αυτό με ένα downgrade σε Basic128Rsa15 για να αφαιρέσετε integrity checks και να impersonate μόνιμα operators μέχρι να ανακατασκευαστούν οι trustlists.

### Κατασκευή OPC UA clients για exploitation

- **Custom clients:** Drop-in libraries (python-opcua/asyncua, node-opcua, open62541) σας επιτρέπουν να υλοποιήσετε exploit logic. Πάντα επιβάλλετε το target namespace index για να αποφύγετε τυχαία cross-namespace writes όταν οι vendors αναδιατάσσουν τα namespaces μετά από firmware updates.
- **Node abuse checklist:**
- `HistoryRead` πάνω σε production tags για snapshot proprietary recipes.
- `TranslateBrowsePathsToNodeIds` για να επιλύσετε human-readable asset names σε NodeIds που μπορούν να δοθούν σε gadgets όπως το Claroty framework.
- `Call` + `Method` nodes για να ενεργοποιήσετε maintenance tasks (firmware upload, calibration, device reboots).
- `RegisterNodes` mis-use για να pin-άρετε frequently accessed nodes και μετά να starve νόμιμους clients μη απελευθερώνοντας ποτέ τα handles.
- **Session hardening tests:** Προσπαθήστε να δέσετε δεκάδες subscriptions με εξαιρετικά χαμηλά publishing intervals (κάτω από 50 ms) μαζί με oversized monitored-item queues. Πολλά stacks υπολογίζουν λανθασμένα το `RevisedPublishingInterval` και crash-άρουν λόγω scheduler overflows.

### Fuzzing & exploit development tooling

Η Claroty Team82 κυκλοφόρησε ένα open-source `opcua-exploit-framework` που πακετάρει χρόνια έρευνας επιπέδου Pwn2Own σε επαναχρησιμοποιήσιμα modules:

- **Modes:** `sanity` (lightweight reads/browses), `attacks` (π.χ., thread pool starvation, file upload DoS), `corpus` (replay fuzzing payloads), `server` (rogue OPC UA server για backdoor clients).
- **Usage pattern:**
```bash
# Run a DoS attack against a Prosys Simulation Server endpoint
python3 main.py prosys 10.10.10.10 53530 /OPCUA/SimulationServer thread_pool_wait_starvation

# Replay an entire Boofuzz corpus against open62541
python3 main.py open62541 192.168.1.50 4840 / opcua_message_boofuzz_db input_corpus_minimized/opcua.db
```
- **Rogue server scenario:** Ο bundled asyncua-based server σας επιτρέπει να στοχεύσετε client software εξυπηρετώντας malicious address spaces (π.χ., responses με υπερμεγέθεις `ExtensionObject`s για να ενεργοποιήσετε parsing bugs σε UA Expert clones).
- **Target coverage:** Τα built-in profiles αντιστοιχούν σε Kepware, Ignition, Unified Automation, Softing SIS, Triangle Microworks, Node-OPCUA, Python OPC UA, Milo, open62541, κ.λπ., ώστε να μπορείτε γρήγορα να αλλάζετε μεταξύ stacks χωρίς να ξαναγράφετε payloads.
- **Integration tips:** Αλυσοδέστε το output του με τους δικούς σας fuzzers—ψεκάστε πρώτα τα `corpus` payloads, και μετά χρησιμοποιήστε το OpalOPC για να επαληθεύσετε αν το crash επανέφερε insecure defaults (anonymous login, setpoint write access, κ.λπ.).

### Exploiting authentication bypasses

Αν βρεθούν authentication bypass vulnerabilities, μπορείτε να ρυθμίσετε έναν [OPC UA client](https://www.prosysopc.com/products/opc-ua-browser/) κατάλληλα και να δείτε τι μπορείτε να προσπελάσετε. Αυτό μπορεί να επιτρέψει οτιδήποτε από απλό reading process values μέχρι πραγματική λειτουργία βαρέως βιομηχανικού εξοπλισμού.

Για να πάρετε μια ιδέα για τη συσκευή στην οποία έχετε πρόσβαση, διαβάστε τις τιμές του "ServerStatus" node στο address space και κάντε google για το usage manual.

## Shodan

- `port:4840`
- `port:62541 "OPC UA"`
- `ssl:"urn:opcua"`
- `product:"opc ua"`

Συνδυάστε την αναζήτηση με vendor strings (`"Ignition OPC UA"`, `"KepServerEX"`) ή certificates (`"CN=UaServerCert"`) για να προτεραιοποιήσετε high-value assets πριν ξεκινήσετε intrusive testing.

## References

- [https://opalopc.com/how-to-hack-opc-ua/](https://opalopc.com/how-to-hack-opc-ua/)
- [https://github.com/claroty/opcua-exploit-framework](https://github.com/claroty/opcua-exploit-framework)
- [https://certvde.com/en/advisories/VDE-2025-022/](https://certvde.com/en/advisories/VDE-2025-022/)
- [https://nvd.nist.gov/vuln/detail/CVE-2024-53429](https://nvd.nist.gov/vuln/detail/CVE-2024-53429)
- [https://industrial.softing.com/fileadmin/psirt/downloads/2025/CVE-2025-7390.html](https://industrial.softing.com/fileadmin/psirt/downloads/2025/CVE-2025-7390.html)


{{#include ../banners/hacktricks-training.md}}
