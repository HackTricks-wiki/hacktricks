# 4840 - Pentesting OPC UA

{{#include ../banners/hacktricks-training.md}}


## Información básica

**OPC UA**, que significa **Open Platform Communications Unified Access**, es un protocolo de código abierto crucial utilizado en diversas industrias como manufactura, energía, aeroespacial y defensa para el intercambio de datos y el control de equipos. Permite que equipos de distintos proveedores se comuniquen entre sí, especialmente con PLCs.

Su configuración permite aplicar medidas de seguridad fuertes, pero a menudo, por compatibilidad con dispositivos más antiguos, estas se reducen, exponiendo a los sistemas a riesgos. Además, encontrar servicios OPC UA puede ser complicado, ya que los escáneres de red podrían no detectarlos si están en puertos no estándar.

**Puerto por defecto:** 4840 (binario `opc.tcp`). Muchos proveedores exponen endpoints de discovery separados (`/discovery`), bindings HTTPS (4843/443) o puertos de escucha específicos del proveedor, como 49320 (KepServerEX), 62541 (OPC Foundation reference stack) y 48050 (UaGateway). Espere múltiples endpoints por host, cada uno anunciando perfil de transporte, política de seguridad y soporte de user-token.

| Built-in NodeId | Why it matters |
| --- | --- |
| `i=2253` (`0:Server`) | Contiene `ServerArray`, cadenas de proveedor/producto y URIs de espacios de nombres.
| `i=2256` (`ServerStatus`) | Revela uptime, estado actual y, opcionalmente, información de build.
| `i=2267` (`ServerDiagnosticsSummary`) | Muestra conteos de sesiones, solicitudes abortadas, etc. Útil para fingerprinting de intentos de fuerza bruta.
| `i=85` (`ObjectsFolder`) | Punto de entrada para recorrer tags expuestos del dispositivo, métodos y alarmas.
```text
PORT     STATE SERVICE REASON
4840/tcp open  unknown syn-ack
```
## Pentesting OPC UA

Para revelar problemas de seguridad en servidores OPC UA, escanéelos con [OpalOPC](https://opalopc.com/).
```bash
opalopc -vv opc.tcp://$target_ip_or_hostname:$target_port
```
### Playbook de descubrimiento y enumeración

1. **Localizar todos los transportes OPC UA**
```bash
nmap -sV -Pn -n --open -p 4840,4843,49320,48050,53530,62541 $TARGET
```
Repítelo en las direcciones de grupo UDP si el entorno usa LDS-ME multicast discovery.

2. **Identificar endpoints**
- Invocar `FindServers`/`GetEndpoints` sobre cada transporte para capturar `SecurityPolicyUri`, `SecurityMode`, `UserTokenType`, la URI de la aplicación y las cadenas de producto.
- Enumerar los namespaces para poder resolver NodeIds específicos del proveedor; abusar de colisiones de namespaces para inducir a los clientes a cargar esquemas controlados por el atacante.

3. **Recorrer el espacio de direcciones**
- Comenzar en `ObjectsFolder (i=85)` y recursivamente `Browse`/`Read` para encontrar variables de proceso escribibles, nodos `Method` y nodos de historizador/log.
- Consultar `ServerStatus.BuildInfo` para entender la procedencia del firmware, y `ServerCapabilities.OperationLimits` para evaluar lo fácil que es agotar los recursos del servidor.
- Si se permite acceso anónimo, probar inmediatamente `Call` en métodos de mantenimiento (p. ej., `ns=2;s=Reset`, `ns=2;s=StartMotor`). Muchos proveedores olvidan enlazar permisos por rol a métodos personalizados.

4. **Abuso de sesiones**
- Reutilizar o clonar valores `AuthenticationToken` de otras sesiones (capturados vía MITM o exposición de diagnósticos) para secuestrar suscripciones existentes.
- Forzar al servidor a un flooding de `SessionDiagnostics` creando docenas de sesiones inactivas; algunos stacks se bloquean cuando se excede el límite `MaxSessionCount`.

### Evaluación automatizada con OpalOPC

- El scanner puede ejecutarse de forma interactiva o headless, lo cual es útil para baselines OT estilo CI/CD. Canaliza sus hallazgos en formato legible por máquina a tu pipeline de reporting para resaltar inicios de sesión anónimos, políticas débiles, errores de validación de certificados y variables escribibles en minutos.
- Combina la salida de OpalOPC con browsing manual: alimenta la lista de endpoints descubiertos de vuelta a tus herramientas personalizadas y luego explota selectivamente nodos de alto impacto (p. ej., `MotorControl/StartStop`, `RecipeManager/Upload`).

### Attacking legacy security policies (Basic128Rsa15)

- **Bleichenbacher-style oracle:** Systems that still allow the deprecated `Basic128Rsa15` policy (often toggled via build flags such as `CMPOPCUASTACK_ALLOW_SHA1_BASED_SECURITY`) leak padding validation differences. Explota esto inundando los handshakes `CreateSession` / `OpenSecureChannel` con blobs PKCS#1 v1.5 creados para recuperar la clave privada del certificado del servidor, y luego suplantar al servidor o descifrar el tráfico.
- **Authentication bypass:** OPC Foundation’s .NET Standard stack prior to 1.5.374.158 (CVE-2024-42512) and dependent products let unauthenticated attackers force that legacy policy and subsequently skip application-level authentication. Una vez que posees el material de clave puedes presentar `UserIdentityTokens` arbitrarios, reproducir peticiones `ActivateSession` firmadas y operar la planta como una estación de ingeniería confiable.
- **Operational workflow:**
1. Enumerar políticas con `GetEndpoints` y anotar cualquier entrada `Basic128Rsa15`.
2. Negociar explícitamente esa política (`SecurityPolicyUri` en `CreateSession`), luego ejecutar tu bucle del oracle hasta que la clave recuperada valide.
3. Abusar de la clave para forjar una sesión de alto privilegio, cambiar roles o degradar silenciosamente a otros clientes actuando como un reverse proxy malicioso.
- OPC Foundation publicó simultáneamente CVE-2024-42513 para bindings HTTPS. Incluso si tu objetivo afirma usar TLS, asegúrate de que no esté cayendo silenciosamente a Basic128Rsa15 para el transporte binario detrás del proxy.

### Creación de clientes OPC UA para explotación

- **Custom clients:** Drop-in libraries (python-opcua/asyncua, node-opcua, open62541) te permiten orquestar la lógica de exploit tú mismo. Siempre aplica el índice de namespace de tu objetivo para evitar escrituras cross-namespace accidentales cuando los proveedores reordenan namespaces tras actualizaciones de firmware.
- **Lista de verificación de abuso de nodos:**
- `HistoryRead` en tags de producción para snapshotear recetas propietarias.
- `TranslateBrowsePathsToNodeIds` para resolver nombres legibles por humanos de activos en NodeIds que pueden ser alimentados a gadgets como el framework de Claroty.
- `Call` + nodos `Method` para disparar tareas de mantenimiento (upload de firmware, calibración, reboot de dispositivos).
- Mal uso de `RegisterNodes` para fijar nodos de acceso frecuente y luego privar a clientes legítimos al no liberar nunca los handles.
- **Session hardening tests:** Intentar ligar docenas de subscriptions con intervalos de publicación extremadamente bajos (por debajo de 50 ms) más colas de monitored-item sobredimensionadas. Muchos stacks miscalculan `RevisedPublishingInterval` y se bloquean por desbordes del scheduler.

### Fuzzing & exploit development tooling

Claroty Team82 lanzó un `opcua-exploit-framework` open-source que empaqueta años de investigación tipo Pwn2Own en módulos reutilizables:

- **Modes:** `sanity` (lecturas/browses ligeros), `attacks` (p. ej., starvation del thread pool, DoS por upload de archivos), `corpus` (replay de payloads de fuzzing), `server` (servidor OPC UA malicioso para backdoorear clientes).
- **Usage pattern:**
```bash
# Run a DoS attack against a Prosys Simulation Server endpoint
python3 main.py prosys 10.10.10.10 53530 /OPCUA/SimulationServer thread_pool_wait_starvation

# Replay an entire Boofuzz corpus against open62541
python3 main.py open62541 192.168.1.50 4840 / opcua_message_boofuzz_db input_corpus_minimized/opcua.db
```
- **Rogue server scenario:** El servidor incluido basado en asyncua te permite apuntar al software cliente sirviendo espacios de direcciones maliciosos (por ejemplo, respuestas con `ExtensionObject`s sobredimensionados para disparar bugs de parsing en clones de UA Expert).
- **Target coverage:** Los perfiles incorporados mapean a Kepware, Ignition, Unified Automation, Softing SIS, Triangle Microworks, Node-OPCUA, Python OPC UA, Milo, open62541, etc., por lo que puedes intercambiar stacks rápidamente sin reescribir payloads.
- **Integration tips:** Encadena su salida con tus propios fuzzers: pulveriza primero los payloads del `corpus`, luego haz que OpalOPC verifique si el crash resucitó defaults inseguros (login anónimo, acceso de escritura a setpoints, etc.).

### Exploiting authentication bypasses

Si se encuentran vulnerabilidades de bypass de autenticación, puedes configurar un [OPC UA client](https://www.prosysopc.com/products/opc-ua-browser/) acorde y ver qué puedes acceder. Esto puede permitir desde leer valores de proceso hasta operar equipo industrial pesado.

Para hacerte una idea del dispositivo al que tienes acceso, lee los valores del nodo "ServerStatus" en el address space y busca en Google un manual de uso.

## Shodan

- `port:4840`
- `port:62541 "OPC UA"`
- `ssl:"urn:opcua"`
- `product:"opc ua"`

Combina la búsqueda con strings de proveedor (`"Ignition OPC UA"`, `"KepServerEX"`) o certificados (`"CN=UaServerCert"`) para priorizar activos de alto valor antes de comenzar pruebas intrusivas.

## References

- [https://opalopc.com/how-to-hack-opc-ua/](https://opalopc.com/how-to-hack-opc-ua/)
- [https://github.com/claroty/opcua-exploit-framework](https://github.com/claroty/opcua-exploit-framework)
- [https://certvde.com/en/advisories/VDE-2025-022/](https://certvde.com/en/advisories/VDE-2025-022/)


{{#include ../banners/hacktricks-training.md}}
