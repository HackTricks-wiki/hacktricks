# 4840 - Pentesting OPC UA

{{#include ../banners/hacktricks-training.md}}


## Informação Básica

**OPC UA**, que significa **Open Platform Communications Unified Access**, é um protocolo de código aberto crucial usado em várias indústrias como manufatura, energia, aeroespacial e defesa para troca de dados e controle de equipamentos. Ele permite de forma única que equipamentos de diferentes fornecedores se comuniquem, especialmente com PLCs.

Sua configuração permite medidas de segurança fortes, mas frequentemente, para compatibilidade com dispositivos mais antigos, essas medidas são atenuadas, expondo sistemas a riscos. Além disso, encontrar serviços OPC UA pode ser complicado, já que scanners de rede podem não detectá-los se estiverem em portas não padronizadas.

**Default port:** 4840 (binary `opc.tcp`). Muitos fornecedores expõem endpoints de discovery separados (`/discovery`), bindings HTTPS (4843/443), ou portas de listener específicas do fornecedor como 49320 (KepServerEX), 62541 (OPC Foundation reference stack) e 48050 (UaGateway). Espere múltiplos endpoints por host, cada um anunciando transport profile, security policy e suporte a user-token.

| Built-in NodeId | Por que importa |
| --- | --- |
| `i=2253` (`0:Server`) | Contém `ServerArray`, strings de fornecedor/produto e URIs de namespace.
| `i=2256` (`ServerStatus`) | Revela uptime, estado atual e, opcionalmente, informações de build.
| `i=2267` (`ServerDiagnosticsSummary`) | Mostra contagens de sessões, requisições abortadas, etc. Ótimo para fingerprinting de brute-force attempts.
| `i=85` (`ObjectsFolder`) | Ponto de entrada para percorrer tags de dispositivo expostas, métodos e alarmes.
```text
PORT     STATE SERVICE REASON
4840/tcp open  unknown syn-ack
```
## Pentesting OPC UA

Para revelar problemas de segurança em servidores OPC UA, escaneie-os com [OpalOPC](https://opalopc.com/).
```bash
opalopc -vv opc.tcp://$target_ip_or_hostname:$target_port
```
### Playbook de Descoberta & Enumeração

1. **Localize todos os transportes OPC UA**
```bash
nmap -sV -Pn -n --open -p 4840,4843,49320,48050,53530,62541 $TARGET
```
Repita em endereços de grupo UDP se o ambiente usar descoberta multicast LDS-ME.

2. **Fingerprint endpoints**
- Invoque `FindServers`/`GetEndpoints` sobre cada transporte para capturar `SecurityPolicyUri`, `SecurityMode`, `UserTokenType`, application URI e strings de produto.
- Enumere namespaces para resolver NodeIds específicos do fornecedor; abuse colisões de namespace para forçar clientes a carregar schemas controlados pelo atacante.

3. **Percorra o address space**
- Comece em `ObjectsFolder (i=85)` e recursivamente `Browse`/`Read` para encontrar variáveis de processo graváveis, nós `Method` e nós de historizador/log.
- Consulte `ServerStatus.BuildInfo` para entender a proveniência do firmware, e `ServerCapabilities.OperationLimits` para avaliar quão fácil é esgotar recursos do servidor.
- Se o acesso anônimo for permitido, teste imediatamente `Call` em métodos de manutenção (por exemplo, `ns=2;s=Reset`, `ns=2;s=StartMotor`). Muitos fornecedores esquecem de vincular permissões de função a métodos personalizados.

4. **Abuso de sessões**
- Reutilize ou clone valores `AuthenticationToken` de outras sessões (capturados via MITM ou exposição de diagnósticos) para sequestrar subscriptions existentes.
- Force o servidor em flooding de `SessionDiagnostics` criando dezenas de sessões inativas; algumas stacks travam quando o limite `MaxSessionCount` é excedido.

### Avaliação automatizada com OpalOPC

- O scanner pode rodar interativamente ou headless, o que é útil para baselines OT em estilo CI/CD. Encode seus achados em formato legível por máquina para o seu pipeline de relatórios para destacar logins anônimos, políticas fracas, erros de validação de certificado e variáveis graváveis em minutos.
- Combine a saída do OpalOPC com navegação manual: alimente a lista de endpoints descoberta de volta em suas ferramentas customizadas e então arme seletivamente nós de alto impacto (por exemplo, `MotorControl/StartStop`, `RecipeManager/Upload`).

### Atacando políticas de segurança legadas (Basic128Rsa15)

- **Bleichenbacher-style oracle:** Sistemas que ainda permitem a política depreciada `Basic128Rsa15` (frequentemente ativada por flags de build como `CMPOPCUASTACK_ALLOW_SHA1_BASED_SECURITY`) leak diferenças de validação de padding. Explore isso inundando handshakes `CreateSession` / `OpenSecureChannel` com blobs PKCS#1 v1.5 crafted para recuperar a chave privada do certificado do servidor, então finja ser o servidor ou decripte o tráfego.
- **Bypass de autenticação:** O stack .NET Standard da OPC Foundation anterior à 1.5.374.158 (CVE-2024-42512) e produtos dependentes permitem que atacantes não autenticados forcem essa política legada e subsequentemente pulem a autenticação em nível de aplicação. Uma vez com o material de chave, você pode apresentar `UserIdentityTokens` arbitrários, reproduzir `ActivateSession` assinadas e operar a planta como uma estação de engenharia confiável.
- **Fluxo operacional:**
  1. Enumere políticas com `GetEndpoints` e anote quaisquer entradas `Basic128Rsa15`.
  2. Negocie explicitamente essa política (`SecurityPolicyUri` em `CreateSession`), então execute seu loop do oracle até validar a chave recuperada.
  3. Abuse da chave para forjar uma sessão de alto privilégio, trocar papéis, ou degradar silenciosamente outros clientes atuando como um proxy reverso malicioso.
- **CODESYS Runtime Toolkit (<3.5.21.0)** reativava Basic128Rsa15 sempre que integradores compilavam com `CMPOPCUASTACK_ALLOW_SHA1_BASED_SECURITY`. Inverta essa flag, reexecute o workflow do oracle acima, e você pode leak a chave privada do runtime para se passar por estações de engenharia confiáveis até que o patch 3.5.21.0 ou superior seja aplicado.
- A OPC Foundation publicou simultaneamente CVE-2024-42513 para bindings HTTPS. Mesmo se seu alvo afirmar TLS, verifique se não está silenciosamente caindo para Basic128Rsa15 no transporte binário atrás do proxy.

### Watchlist de exploits 2024-2025

- **open62541 fuzz_binary_decode (CVE-2024-53429):** Chunks de SecureChannel que declaram corpos `ExtensionObject` oversized fazem o decoder desreferenciar memória liberada, então um atacante pré-auth pode travar repetidamente servidores UA que embedam open62541 ≤1.4.6. Reuse o corpus Claroty (`opcua_message_boofuzz_db`) ou crie seu próprio harness Boofuzz para spammar `OpenSecureChannel` mutados até o watchdog matar o processo; re-enumerar depois, pois muitos integradores voltam ao modo anônimo após o reboot.
- **Softing OPC UA C++ SDK / edgeConnector / edgeAggregator (CVE-2025-7390):** O pipeline de client-auth TLS aceita qualquer certificado que replique um Common Name confiável, então você pode mintar um cert descartável, copiar o CN de um engenheiro da planta e logar com `UserNameIdentityToken` ou `IssuedIdentityToken` arbitrários. Combine isso com um downgrade para Basic128Rsa15 para remover checagens de integridade e se passar persistentemente por operadores até que trustlists sejam reconstruídas.

### Criando clientes OPC UA para exploração

- **Custom clients:** Bibliotecas drop-in (python-opcua/asyncua, node-opcua, open62541) permitem dirigir sua lógica de exploit. Sempre force o índice de namespace alvo para evitar escritas cross-namespace acidentais quando fornecedores reordenam namespaces após updates de firmware.
- **Checklist de abuso de nós:**
  - `HistoryRead` em tags de produção para snapshot de receitas proprietárias.
  - `TranslateBrowsePathsToNodeIds` para resolver nomes legíveis em NodeIds que podem ser alimentados em gadgets como o framework da Claroty.
  - `Call` + nós `Method` para disparar tarefas de manutenção (upload de firmware, calibração, reboot de dispositivos).
  - Uso indevido de `RegisterNodes` para fixar nós frequentemente acessados e então starvation de clientes legítimos ao nunca liberar os handles.
- **Testes de hardening de sessão:** Tente vincular dezenas de subscriptions com intervalos de publicação extremamente baixos (abaixo de 50 ms) mais filas de monitored-item oversized. Muitas stacks recalculam mal `RevisedPublishingInterval` e travam devido a overflows do scheduler.

### Fuzzing & tooling de desenvolvimento de exploits

A Claroty Team82 lançou um `opcua-exploit-framework` open-source que empacota anos de pesquisa Pwn2Own em módulos reutilizáveis:

- **Modes:** `sanity` (leitura/browse leves), `attacks` (ex.: starvation de thread pool, file upload DoS), `corpus` (replay de payloads de fuzzing), `server` (servidor OPC UA rogue para backdoor em clients).
- **Padrão de uso:**
```bash
# Run a DoS attack against a Prosys Simulation Server endpoint
python3 main.py prosys 10.10.10.10 53530 /OPCUA/SimulationServer thread_pool_wait_starvation

# Replay an entire Boofuzz corpus against open62541
python3 main.py open62541 192.168.1.50 4840 / opcua_message_boofuzz_db input_corpus_minimized/opcua.db
```
- **Rogue server scenario:** O servidor empacotado baseado em asyncua permite mirar software cliente servindo address spaces maliciosos (por exemplo, respostas com `ExtensionObject`s oversized para disparar bugs de parsing em clones do UA Expert).
- **Cobertura de alvos:** Perfis incorporados mapeiam para Kepware, Ignition, Unified Automation, Softing SIS, Triangle Microworks, Node-OPCUA, Python OPC UA, Milo, open62541, etc., permitindo alternar rapidamente entre stacks sem reescrever payloads.
- **Dicas de integração:** Encadear sua saída com seus próprios fuzzers—spray os payloads do `corpus` primeiro, depois usar o OpalOPC para re-verificar se o crash ressuscitou defaults inseguros (login anônimo, write access em setpoints, etc).

### Explorando bypasses de autenticação

Se vulnerabilidades de authentication bypass forem encontradas, você pode configurar um [OPC UA client](https://www.prosysopc.com/products/opc-ua-browser/) adequadamente e ver o que consegue acessar. Isso pode permitir desde apenas leitura de valores de processo até operar equipamentos industriais pesados.

Para ter uma pista do dispositivo ao qual você tem acesso, leia os valores do nó "ServerStatus" no address space e google por um manual de uso.

## Shodan

- `port:4840`
- `port:62541 "OPC UA"`
- `ssl:"urn:opcua"`
- `product:"opc ua"`

Combine a busca com strings de fornecedor (`"Ignition OPC UA"`, `"KepServerEX"`) ou certificados (`"CN=UaServerCert"`) para priorizar ativos de alto valor antes de iniciar testes intrusivos.

## References

- [https://opalopc.com/how-to-hack-opc-ua/](https://opalopc.com/how-to-hack-opc-ua/)
- [https://github.com/claroty/opcua-exploit-framework](https://github.com/claroty/opcua-exploit-framework)
- [https://certvde.com/en/advisories/VDE-2025-022/](https://certvde.com/en/advisories/VDE-2025-022/)
- [https://nvd.nist.gov/vuln/detail/CVE-2024-53429](https://nvd.nist.gov/vuln/detail/CVE-2024-53429)
- [https://industrial.softing.com/fileadmin/psirt/downloads/2025/CVE-2025-7390.html](https://industrial.softing.com/fileadmin/psirt/downloads/2025/CVE-2025-7390.html)


{{#include ../banners/hacktricks-training.md}}
