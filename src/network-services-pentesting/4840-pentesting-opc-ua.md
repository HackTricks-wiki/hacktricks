# 4840 - Pentesting OPC UA

{{#include ../banners/hacktricks-training.md}}


## Grundlegende Informationen

**OPC UA**, was für **Open Platform Communications Unified Access** steht, ist ein wichtiges Open-Source-Protokoll, das in verschiedenen Branchen wie Manufacturing, Energy, Aerospace und Defence für den Datenaustausch und die Steuerung von Geräten verwendet wird. Es ermöglicht die Kommunikation zwischen Geräten unterschiedlicher Hersteller, insbesondere mit PLCs.

Seine Konfiguration erlaubt starke Sicherheitsmaßnahmen, aber oft werden diese zur Kompatibilität mit älteren Geräten reduziert, wodurch Systeme gefährdet werden. Außerdem kann das Auffinden von OPC UA-Services schwierig sein, da Netzwerkscanner sie möglicherweise nicht entdecken, wenn sie auf nicht standardmäßigen Ports laufen.

**Default port:** 4840 (binär `opc.tcp`). Viele Anbieter stellen separate discovery-Endpunkte (`/discovery`), HTTPS-Bindings (4843/443) oder herstellerspezifische Listener-Ports wie 49320 (KepServerEX), 62541 (OPC Foundation reference stack) und 48050 (UaGateway) bereit. Erwarte mehrere Endpunkte pro Host, die jeweils Transportprofile, Security Policy und Unterstützung für User-Tokens ankündigen.

| Built-in NodeId | Why it matters |
| --- | --- |
| `i=2253` (`0:Server`) | Enthält `ServerArray`, Hersteller-/Produkt-Strings und Namespace-URIs.
| `i=2256` (`ServerStatus`) | Zeigt Uptime, aktuellen Zustand und optional Build-Informationen.
| `i=2267` (`ServerDiagnosticsSummary`) | Zeigt Sitzungszahlen, abgebrochene Requests usw. Great for fingerprinting brute-force attempts.
| `i=85` (`ObjectsFolder`) | Einstiegspunkt, um exponierte Geräte-Tags, Methoden und Alarme zu durchlaufen.
```text
PORT     STATE SERVICE REASON
4840/tcp open  unknown syn-ack
```
## Pentesting OPC UA

Um Sicherheitsprobleme in OPC UA-Servern aufzudecken, scannen Sie diese mit [OpalOPC](https://opalopc.com/).
```bash
opalopc -vv opc.tcp://$target_ip_or_hostname:$target_port
```
### Playbook: Entdeckung & Aufklärung

1. **Alle OPC UA-Transporte lokalisieren**
```bash
nmap -sV -Pn -n --open -p 4840,4843,49320,48050,53530,62541 $TARGET
```
Wiederholen Sie dies für UDP-Gruppenadressen, wenn die Umgebung LDS-ME multicast discovery verwendet.

2. **Endpunkte fingerprinten**
- Rufen Sie `FindServers`/`GetEndpoints` über jeden Transport auf, um `SecurityPolicyUri`, `SecurityMode`, `UserTokenType`, Anwendungs-URI und Produkt-Strings zu erfassen.
- Enumerieren Sie Namespaces, damit Sie herstellerspezifische NodeIds auflösen können; missbrauchen Sie Namespace-Kollisionen, um Clients zum Laden angreifer-kontrollierter Schemas zu zwingen.

3. **Adressraum durchsuchen**
- Starten Sie bei `ObjectsFolder (i=85)` und führen Sie rekursives `Browse`/`Read` durch, um schreibbare Prozessvariablen, `Method`-Knoten und Historian/Log-Knoten zu finden.
- Abfragen von `ServerStatus.BuildInfo`, um die Firmware-Provenienz zu verstehen, und `ServerCapabilities.OperationLimits`, um einzuschätzen, wie leicht Serverressourcen erschöpft werden können.
- Wenn anonymer Zugriff erlaubt ist, testen Sie sofort `Call` auf Wartungsmethoden (z. B. `ns=2;s=Reset`, `ns=2;s=StartMotor`). Viele Hersteller vergessen, Rollenberechtigungen an benutzerdefinierte Methoden zu binden.

4. **Session-Missbrauch**
- Wiederverwenden oder Klonen von `AuthenticationToken`-Werten aus anderen Sessions (abgefangen via MITM oder Diagnose-Exposition), um bestehende Subscriptions zu kapern.
- Bringen Sie den Server durch massenhaftes Erzeugen inaktiver Sessions zum `SessionDiagnostics`-Flooding; einige Stacks stürzen ab, sobald das `MaxSessionCount`-Limit überschritten wird.

### Automatisierte Bewertung mit OpalOPC

- Der Scanner kann interaktiv oder headless laufen, was für CI/CD-ähnliche OT-Baselines praktisch ist. Leiten Sie seine maschinenlesbaren Ergebnisse in Ihre Reporting-Pipeline, um anonyme Logins, schwache Policies, Zertifikatvalidierungsfehler und schreibbare Variablen innerhalb von Minuten hervorzuheben.
- Kombinieren Sie OpalOPC-Ausgabe mit manuellem Browsing: Speisen Sie die entdeckte Endpunktliste zurück in Ihre Custom-Tools und nutzen Sie dann gezielt hochwirksame Knoten aus (z. B. `MotorControl/StartStop`, `RecipeManager/Upload`).

### Angriffe auf veraltete Security-Policies (Basic128Rsa15)

- **Bleichenbacher-style oracle:** Systeme, die noch die veraltete `Basic128Rsa15`-Policy erlauben (oft per Build-Flags wie `CMPOPCUASTACK_ALLOW_SHA1_BASED_SECURITY` aktiviert), leak Unterschiede bei der Padding-Validierung. Nutzen Sie dies aus, indem Sie `CreateSession` / `OpenSecureChannel`-Handshakes mit manipulierten PKCS#1 v1.5-Blobs fluten, um den privaten Schlüssel des Serverzertifikats zu rekonstruieren, und sich anschließend als Server ausgeben oder den Verkehr entschlüsseln.
- **Authentication bypass:** Der .NET Standard-Stack der OPC Foundation vor 1.5.374.158 (CVE-2024-42512) und abhängige Produkte erlauben es nicht-authentifizierten Angreifern, jene Legacy-Policy zu erzwingen und anschließend die Anwendungsebene-Authentifizierung zu überspringen. Sobald Sie das Key-Material besitzen, können Sie beliebige `UserIdentityTokens` präsentieren, signierte `ActivateSession`-Anfragen replayen und die Anlage als vertrauenswürdige Engineering-Workstation betreiben.
- **Betriebsablauf:**
1. Policies mit `GetEndpoints` auflisten und etwaige `Basic128Rsa15`-Einträge notieren.
2. Diese Policy ausdrücklich aushandeln (`SecurityPolicyUri` im `CreateSession`), dann Ihre Oracle-Schleife laufen lassen, bis der wiedergewonnene Schlüssel verifiziert ist.
3. Den Schlüssel missbrauchen, um eine Sitzung mit hohen Privilegien zu fälschen, Rollen zu wechseln oder andere Clients stillschweigend durch Agieren als bösartiger Reverse-Proxy herunterzustufen.
- Die OPC Foundation veröffentlichte gleichzeitig CVE-2024-42513 für HTTPS-Bindings. Selbst wenn Ihr Ziel TLS angibt, stellen Sie sicher, dass es nicht stillschweigend für den binären Transport hinter dem Proxy auf Basic128Rsa15 zurückfällt.

### Erstellung von OPC UA-Clients zur Ausnutzung

- **Custom clients:** Drop-in libraries (python-opcua/asyncua, node-opcua, open62541) erlauben es, Exploit-Logik selbst zu steuern. Erzwingen Sie stets den Ziel-Namespace-Index, um versehentliche Cross-Namespace-Schreibvorgänge zu vermeiden, wenn Hersteller Namespaces nach Firmware-Updates neu ordnen.
- Checkliste für Node-Missbrauch:
- `HistoryRead` auf Produktionstags, um proprietäre Rezepte zu erfassen.
- `TranslateBrowsePathsToNodeIds`, um menschenlesbare Asset-Namen in NodeIds aufzulösen, die an Gadgets wie Claroty’s Framework gefüttert werden können.
- `Call` + `Method`-Knoten, um Wartungsaufgaben auszulösen (Firmware-Upload, Kalibrierung, Neustart von Geräten).
- Missbrauch von `RegisterNodes`, um häufig genutzte Knoten zu pinnen und legitime Clients auszuhungern, indem die Handles nie freigegeben werden.
- **Session-Härtungstests:** Versuchen Sie, Dutzende Subscriptions mit extrem niedrigen Publishing-Intervallen (unter 50 ms) und übergroßen monitored-item-Queues zu binden. Viele Stacks berechnen `RevisedPublishingInterval` falsch und stürzen wegen Scheduler-Overflows ab.

### Fuzzing- & Exploit-Entwicklungs-Tooling

Claroty Team82 hat ein Open-Source `opcua-exploit-framework` veröffentlicht, das jahrelange Pwn2Own-grade Forschung in wiederverwendbare Module packt:

- **Modes:** `sanity` (leichte reads/browses), `attacks` (z. B. thread pool starvation, file upload DoS), `corpus` (replay fuzzing payloads), `server` (rogue OPC UA server to backdoor clients).
- **Usage pattern:**
```bash
# Run a DoS attack against a Prosys Simulation Server endpoint
python3 main.py prosys 10.10.10.10 53530 /OPCUA/SimulationServer thread_pool_wait_starvation

# Replay an entire Boofuzz corpus against open62541
python3 main.py open62541 192.168.1.50 4840 / opcua_message_boofuzz_db input_corpus_minimized/opcua.db
```
- **Rogue server scenario:** Der mitgelieferte asyncua-basierte Server ermöglicht es, Client-Software anzugreifen, indem bösartige Address Spaces serviert werden (z. B. Antworten mit übergroßen `ExtensionObject`s, um Parsing-Bugs in UA Expert-Klonen auszulösen).
- **Target coverage:** Eingebaute Profile decken Kepware, Ignition, Unified Automation, Softing SIS, Triangle Microworks, Node-OPCUA, Python OPC UA, Milo, open62541 usw. ab, sodass Sie schnell zwischen Stacks wechseln können, ohne Payloads neu zu schreiben.
- **Integration tips:** Ketten Sie dessen Ausgabe mit Ihren eigenen Fuzzern — sprayen Sie zuerst die `corpus`-Payloads, lassen Sie dann OpalOPC erneut prüfen, ob der Crash unsichere Defaults wiederbelebt hat (anonymer Login, setpoint write access, etc.).

### Ausnutzen von Authentication-Bypass-Schwachstellen

Wenn Authentication-Bypass-Schwachstellen gefunden werden, können Sie einen [OPC UA client](https://www.prosysopc.com/products/opc-ua-browser/) entsprechend konfigurieren und prüfen, worauf Sie Zugriff haben. Das kann vom reinen Auslesen von Prozesswerten bis zum Betreiben schwerer Industrieanlagen reichen.

Um einen Hinweis auf das Gerät zu bekommen, auf das Sie Zugriff haben, lesen Sie die "ServerStatus"-Node-Werte im Adressraum und googeln Sie nach einem Benutzerhandbuch.

## Shodan

- `port:4840`
- `port:62541 "OPC UA"`
- `ssl:"urn:opcua"`
- `product:"opc ua"`

Kombinieren Sie die Suche mit Vendor-Strings (`"Ignition OPC UA"`, `"KepServerEX"`) oder Zertifikaten (`"CN=UaServerCert"`), um High-Value-Assets zu priorisieren, bevor Sie intrusive Tests starten.

## Referenzen

- [https://opalopc.com/how-to-hack-opc-ua/](https://opalopc.com/how-to-hack-opc-ua/)
- [https://github.com/claroty/opcua-exploit-framework](https://github.com/claroty/opcua-exploit-framework)
- [https://certvde.com/en/advisories/VDE-2025-022/](https://certvde.com/en/advisories/VDE-2025-022/)


{{#include ../banners/hacktricks-training.md}}
