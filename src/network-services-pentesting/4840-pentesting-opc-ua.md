# 4840 - Pentesting OPC UA

{{#include ../banners/hacktricks-training.md}}


## 基本情報

**OPC UA**（Open Platform Communications Unified Access）は、製造、エネルギー、航空宇宙、防衛などの業界でデータ交換や機器制御に使われる重要なオープンプロトコルです。特に異なるベンダーの機器、特に PLCs 間の相互通信を可能にします。

設定は強力なセキュリティ対策を可能にしますが、古い機器との互換性のためにこれらが緩められることが多く、システムをリスクにさらします。さらに、OPC UA サービスは非標準ポート上にあるとネットワークスキャナで検出されない場合があり、発見が困難です。

**Default port:** 4840 (binary `opc.tcp`). Many vendors expose separate discovery endpoints (`/discovery`), HTTPS bindings (4843/443), or vendor-specific listener ports such as 49320 (KepServerEX), 62541 (OPC Foundation reference stack) and 48050 (UaGateway). Expect multiple endpoints per host, each advertising transport profile, security policy and user-token support.

| Built-in NodeId | Why it matters |
| --- | --- |
| `i=2253` (`0:Server`) | `ServerArray`、ベンダー/製品文字列、namespace URIs を保持します。 |
| `i=2256` (`ServerStatus`) | 稼働時間、現在の状態、場合によってはビルド情報を明らかにします。 |
| `i=2267` (`ServerDiagnosticsSummary`) | セッション数、中断されたリクエストなどを示します。brute-force attempts のフィンガープリンティングに最適です。 |
| `i=85` (`ObjectsFolder`) | 公開されたデバイスタグ、メソッド、アラームをたどるためのエントリポイントです。 |
```text
PORT     STATE SERVICE REASON
4840/tcp open  unknown syn-ack
```
## Pentesting OPC UA

OPC UA サーバーのセキュリティ上の問題を明らかにするには、[OpalOPC](https://opalopc.com/)でスキャンしてください。
```bash
opalopc -vv opc.tcp://$target_ip_or_hostname:$target_port
```
### 発見と列挙プレイブック

1. **Locate all OPC UA transports**
```bash
nmap -sV -Pn -n --open -p 4840,4843,49320,48050,53530,62541 $TARGET
```
環境が LDS-ME マルチキャストディスカバリを使用している場合は、UDP グループアドレス上でも繰り返してください。

2. **Fingerprint endpoints**
- 各トランスポートで `FindServers`/`GetEndpoints` を呼び出し、`SecurityPolicyUri`、`SecurityMode`、`UserTokenType`、アプリケーション URI やプロダクト文字列を取得します。
- ベンダー固有の NodeIds を解決できるように namespace を列挙し、名前空間の衝突を悪用してクライアントに攻撃者管理下のスキーマを読み込ませます。

3. **Walk the address space**
- `ObjectsFolder (i=85)` から開始して再帰的に `Browse`/`Read` を行い、書き込み可能なプロセス変数、`Method` ノード、ヒストリアン／ログノードを探します。
- `ServerStatus.BuildInfo` を照会してファームウェアの由来を把握し、`ServerCapabilities.OperationLimits` でサーバー資源を枯渇させやすいかを評価します。
- 匿名アクセスが許可されている場合は、まず保守用メソッド（例: `ns=2;s=Reset`, `ns=2;s=StartMotor`）で `Call` を試してみてください。多くのベンダーはカスタムメソッドに対するロール権限のバインドを忘れがちです。

4. **Session abuse**
- 他セッションからの `AuthenticationToken` 値を再利用またはクローン（MITM や診断情報の露出で取得）して既存のサブスクリプションを乗っ取ります。
- 数十の非アクティブセッションを作成してサーバーを `SessionDiagnostics` の洪水状態に追い込みます。`MaxSessionCount` 制限を超えるとクラッシュするスタックがあります。

### Automated assessment with OpalOPC

- スキャナは対話モードでもヘッドレスでも動作し、CI/CD スタイルの OT ベースラインに便利です。機械可読な検出結果をレポートパイプラインに流し、数分で匿名ログイン、弱いポリシー、証明書検証エラー、書き込み可能な変数をハイライトできます。
- OpalOPC の出力を手動ブラウジングと組み合わせて使用してください: 発見したエンドポイント一覧をカスタムツールに戻し、高インパクトのノード（例: `MotorControl/StartStop`, `RecipeManager/Upload`）を選択的に武器化します。

### Attacking legacy security policies (Basic128Rsa15)

- **Bleichenbacher-style oracle:** 依然として廃止された `Basic128Rsa15` ポリシー（例: `CMPOPCUASTACK_ALLOW_SHA1_BASED_SECURITY` のようなビルドフラグで切り替えられることが多い）を許可するシステムは、パディング検証の差異を leak します。これを利用して、細工した PKCS#1 v1.5 ブロブで `CreateSession` / `OpenSecureChannel` ハンドシェイクを大量に流し、サーバー証明書の秘密鍵を回復し、サーバーを偽装したり通信を復号したりできます。
- **Authentication bypass:** OPC Foundation の .NET Standard スタック（1.5.374.158 より前のバージョン、CVE-2024-42512）および依存製品は、未認証攻撃者がその旧ポリシーを強制し、その後アプリケーションレベルの認証をスキップさせることを許します。鍵素材を掌握すれば任意の `UserIdentityTokens` を提示したり、署名済みの `ActivateSession` リクエストをリプレイしたりして、信頼されたエンジニアリングワークステーションとしてプラントを操作できます。
- **Operational workflow:**
1. `GetEndpoints` でポリシーを列挙し、`Basic128Rsa15` のエントリを確認します。
2. 明示的にそのポリシー（`CreateSession` の `SecurityPolicyUri`）でネゴシエートし、オラクルループを回して鍵が復元されるまで続けます。
3. 取得した鍵を悪用して高権限セッションを偽造、ロールを切り替える、あるいはローグなリバースプロキシとして他のクライアントをサイレントにダウングレードします。
- **CODESYS Runtime Toolkit (<3.5.21.0)** は、インテグレータが `CMPOPCUASTACK_ALLOW_SHA1_BASED_SECURITY` でビルドすると Basic128Rsa15 を再度有効化します。フラグを反転させて前述のオラクルワークフローを実行すれば、ランタイムの秘密鍵を leak して信頼されたエンジニアリングワークステーションを偽装できます（パッチレベル 3.5.21.0 以降で修正されるまで）。
- OPC Foundation は HTTPS バインディングに対しても CVE-2024-42513 を同時公開しました。ターゲットが TLS を主張していても、プロキシの背後でバイナリトランスポートが暗黙的に Basic128Rsa15 にフォールバックしていないか確認してください。

### 2024-2025 exploit watchlist

- **open62541 fuzz_binary_decode (CVE-2024-53429):** SecureChannel チャンクが過剰サイズの `ExtensionObject` ボディを宣言すると、デコーダが解放済みメモリを参照してしまい、未認証攻撃者が open62541 ≤1.4.6 を埋め込んだ UA サーバーを繰り返しクラッシュさせることができます。Claroty コーパス（`opcua_message_boofuzz_db`）を再利用するか、自前の Boofuzz ハーネスを作成して変異させた `OpenSecureChannel` リクエストをスパムし、ウォッチドッグでプロセスが終了するまで続けてください。多くのインテグレータは再起動後に匿名モードへフォールバックするため、その後再列挙する価値があります。
- **Softing OPC UA C++ SDK / edgeConnector / edgeAggregator (CVE-2025-7390):** TLS クライアント認証パイプラインが、信頼された Common Name をリプレイする任意の証明書を受け入れるため、使い捨ての証明書を発行してプラントエンジニアの CN をコピーし、任意の `UserNameIdentityToken` または `IssuedIdentityToken` データでログインできます。これを Basic128Rsa15 へのダウングレードと組み合わせれば整合性チェックを剥ぎ取り、トラストリストが再構築されるまで運用者を持続的に偽装できます。

### Crafting OPC UA clients for exploitation

- **Custom clients:** Drop-in ライブラリ（python-opcua/asyncua, node-opcua, open62541）を使えば自分でエクスプロイトロジックを駆動できます。ベンダーがファームウェア更新後に namespace を並べ替えることがあるため、ターゲットの namespace index を必ず固定して、意図せぬクロスネームスペース書き込みを避けてください。
- **Node abuse checklist:**
- `HistoryRead` を本番タグに対して実行し、専有レシピをスナップショットします。
- `TranslateBrowsePathsToNodeIds` を使って人間可読の資産名を NodeIds に解決し、Claroty のフレームワークのようなガジェットに投入します。
- `Call` + `Method` ノードで保守作業（ファームウェアアップロード、較正、デバイス再起動）をトリガーします。
- `RegisterNodes` を誤用して頻繁にアクセスされるノードをピンし、ハンドルを解放しないことで正当なクライアントを枯渇させます。
- **Session hardening tests:** 非常に低いパブリッシング間隔（50 ms 未満）と過剰な monitored-item キューを組み合わせて数十のサブスクリプションをバインドしてみてください。多くのスタックは `RevisedPublishingInterval` を誤算してスケジューラがオーバーフローしクラッシュします。

### Fuzzing & exploit development tooling

Claroty Team82 は数年分の Pwn2Own レベルの研究を再利用可能なモジュールにまとめたオープンソースの `opcua-exploit-framework` を公開しました:

- **Modes:** `sanity`（軽量な read/browse）、`attacks`（例: スレッドプール枯渇、ファイルアップロード DoS）、`corpus`（リプレイファジングペイロード）、`server`（クライアントをバックドアするローグ OPC UA サーバー）。
- **Usage pattern:**
```bash
# Run a DoS attack against a Prosys Simulation Server endpoint
python3 main.py prosys 10.10.10.10 53530 /OPCUA/SimulationServer thread_pool_wait_starvation

# Replay an entire Boofuzz corpus against open62541
python3 main.py open62541 192.168.1.50 4840 / opcua_message_boofuzz_db input_corpus_minimized/opcua.db
```
- **Rogue server scenario:** バンドルされた asyncua ベースのサーバーは、悪意あるアドレススペース（例: 過剰サイズの `ExtensionObject` を含むレスポンス）を提供して UA Expert クローンのパースバグを誘発することでクライアントソフトウェアをターゲットにできます。
- **Target coverage:** 内蔵プロファイルは Kepware、Ignition、Unified Automation、Softing SIS、Triangle Microworks、Node-OPCUA、Python OPC UA、Milo、open62541 などにマップされており、ペイロードを書き換えずにスタックを切り替えられます。
- **Integration tips:** まず `corpus` ペイロードを散布し、その後 OpalOPC によりクラッシュで不安全なデフォルト（匿名ログイン、サセットポイント書き込みアクセス等）が復活していないかを再検証させるようチェインしてください。

### Exploiting authentication bypasses

認証バイパス脆弱性が見つかった場合、適切に設定した [OPC UA client](https://www.prosysopc.com/products/opc-ua-browser/) を使ってアクセス可能なものを確認できます。これによりプロセス値の読み取りから、実際に重機を操作するような行為まで可能になることがあります。

アクセス可能なデバイスの手がかりを得るには、アドレススペース内の "ServerStatus" ノードの値を読み取り、機器の使用マニュアルを検索してください。

## Shodan

- `port:4840`
- `port:62541 "OPC UA"`
- `ssl:"urn:opcua"`
- `product:"opc ua"`

ベンダー文字列（`"Ignition OPC UA"`, `"KepServerEX"`）や証明書（`"CN=UaServerCert"`）と組み合わせて検索し、侵入的テストを始める前に高価値の資産を優先してください。

## References

- [https://opalopc.com/how-to-hack-opc-ua/](https://opalopc.com/how-to-hack-opc-ua/)
- [https://github.com/claroty/opcua-exploit-framework](https://github.com/claroty/opcua-exploit-framework)
- [https://certvde.com/en/advisories/VDE-2025-022/](https://certvde.com/en/advisories/VDE-2025-022/)
- [https://nvd.nist.gov/vuln/detail/CVE-2024-53429](https://nvd.nist.gov/vuln/detail/CVE-2024-53429)
- [https://industrial.softing.com/fileadmin/psirt/downloads/2025/CVE-2025-7390.html](https://industrial.softing.com/fileadmin/psirt/downloads/2025/CVE-2025-7390.html)


{{#include ../banners/hacktricks-training.md}}
