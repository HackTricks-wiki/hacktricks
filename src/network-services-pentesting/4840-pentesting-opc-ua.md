# 4840 - Pentesting OPC UA

{{#include ../banners/hacktricks-training.md}}


## 基本信息

**OPC UA**，即 **Open Platform Communications Unified Access**，是一个关键的开源协议，广泛用于制造、能源、航空航天和国防等行业，用于数据交换和设备控制。它使不同厂商的设备能够互相通信，尤其是与 PLCs 的通信。

其配置支持强安全措施，但为了兼容旧设备，这些措施常被削弱，从而使系统暴露风险。此外，定位 OPC UA 服务可能比较棘手，因为当服务运行在非标准端口时，网络扫描器可能无法检测到它们。

默认端口：4840（二进制 `opc.tcp`）。许多厂商会暴露单独的 discovery 端点（`/discovery`）、HTTPS 绑定（4843/443），或厂商特定的监听端口，例如 49320 (KepServerEX)、62541 (OPC Foundation reference stack) 和 48050 (UaGateway)。每台主机通常有多个端点，每个端点会宣告传输配置文件、安全策略和用户令牌支持。

| Built-in NodeId | Why it matters |
| --- | --- |
| `i=2253` (`0:Server`) | 包含 `ServerArray`、厂商/产品字符串和命名空间 URIs。 |
| `i=2256` (`ServerStatus`) | 显示运行时间、当前状态，及可选的构建信息。 |
| `i=2267` (`ServerDiagnosticsSummary`) | 显示会话计数、被中止的请求等。非常适合用于指纹化以识别暴力破解尝试。 |
| `i=85` (`ObjectsFolder`) | 进入点，用于遍历暴露的设备标签、方法和报警。 |
```text
PORT     STATE SERVICE REASON
4840/tcp open  unknown syn-ack
```
## Pentesting OPC UA

要发现 OPC UA 服务器中的安全问题，请使用 [OpalOPC](https://opalopc.com/) 进行扫描。
```bash
opalopc -vv opc.tcp://$target_ip_or_hostname:$target_port
```
### 发现与枚举 操作手册

1. **定位所有 OPC UA 传输**
```bash
nmap -sV -Pn -n --open -p 4840,4843,49320,48050,53530,62541 $TARGET
```
如果环境使用 LDS-ME 多播发现，请在 UDP 组地址上重复此操作。

2. **端点指纹识别**
- 通过每个传输调用 `FindServers`/`GetEndpoints` 来捕获 `SecurityPolicyUri`、`SecurityMode`、`UserTokenType`、应用程序 URI 和产品字符串。
- 枚举 namespaces，以便解析厂商特定的 NodeIds；滥用 namespace 冲突可以诱使客户端加载由攻击者控制的 schema。

3. **遍历地址空间**
- 从 `ObjectsFolder (i=85)` 开始，递归执行 `Browse`/`Read` 来查找可写的过程变量、`Method` 节点和 historian/log 节点。
- 查询 `ServerStatus.BuildInfo` 以了解固件来源，查询 `ServerCapabilities.OperationLimits` 以评估耗尽服务器资源的难易程度。
- 如果允许匿名访问，立即对维护方法执行 `Call` 测试（例如，`ns=2;s=Reset`、`ns=2;s=StartMotor`）。许多厂商忘记将角色权限绑定到自定义方法。

4. **会话滥用**
- 重用或克隆其他会话的 `AuthenticationToken` 值（通过 MITM 或诊断暴露捕获）以劫持现有订阅。
- 通过创建数十个不活动会话将服务器强制进入 `SessionDiagnostics` 洪泛；一些栈在超过 `MaxSessionCount` 限制后会崩溃。

### 使用 OpalOPC 进行自动化评估

- 扫描器可以交互运行或无头运行，这对于 CI/CD 式的 OT 基线非常便利。将其机器可读的发现结果管道化到你的报告流程中，可以在几分钟内突出显示匿名登录、弱策略、证书验证错误和可写变量。
- 将 OpalOPC 输出与手动浏览结合：把发现的端点列表反馈到自定义工具中，然后有选择地武器化高影响节点（例如 `MotorControl/StartStop`、`RecipeManager/Upload`）。

### 攻击遗留安全策略（Basic128Rsa15）

- **Bleichenbacher-style oracle：** 仍然允许已弃用的 `Basic128Rsa15` 策略的系统（通常通过诸如 `CMPOPCUASTACK_ALLOW_SHA1_BASED_SECURITY` 的构建标志切换）会 leak 填充验证差异。通过向 `CreateSession` / `OpenSecureChannel` 握手发送精心构造的 PKCS#1 v1.5 blob 来恢复服务器证书的私钥，然后伪装服务器或解密流量。
- **认证绕过：** OPC Foundation 的 .NET Standard stack 在 1.5.374.158 之前的版本（CVE-2024-42512）及其相关产品允许未认证的攻击者强制使用该遗留策略，随后跳过应用层认证。一旦掌握密钥材料，你就可以呈现任意的 `UserIdentityTokens`、重放已签名的 `ActivateSession` 请求，并以受信任的工程工作站身份操作工厂。
- **操作工作流程：**
1. 使用 `GetEndpoints` 枚举策略，并记录任何 `Basic128Rsa15` 条目。
2. 在 `CreateSession` 中显式协商该策略（`SecurityPolicyUri`），然后运行你的 oracle 循环直到恢复密钥验证成功。
3. 利用密钥伪造高权限会话、切换角色，或作为恶意反向代理悄然降级其他客户端。
- OPC Foundation 同时发布了针对 HTTPS 绑定的 CVE-2024-42513。即便目标声称使用 TLS，也要确保它不会在代理后面针对二进制传输静默回退到 Basic128Rsa15。

### 为利用而定制 OPC UA 客户端

- **自定义客户端：** 可插拔库（python-opcua/asyncua、node-opcua、open62541）允许你自定义驱动利用逻辑。始终强制使用目标的 namespace index，以避免在厂商在固件更新后重新排序 namespaces 时发生意外的跨命名空间写入。
- **节点滥用检查清单：**
- 在生产标签上执行 `HistoryRead` 以快照专有配方。
- 使用 `TranslateBrowsePathsToNodeIds` 将可读的资产名称解析为可以供工具（例如 Claroty 的框架）使用的 NodeIds。
- 使用 `Call` + `Method` 节点触发维护任务（固件上传、校准、设备重启）。
- 错用 `RegisterNodes` 来固定经常访问的节点，然后通过永不释放句柄来使合法客户端饥饿。
- **会话加固测试：** 尝试绑定数十个订阅，设置极低的发布间隔（低于 50 ms）并配以超大的 monitored-item 队列。许多栈会错误计算 `RevisedPublishingInterval`，并因调度器溢出而崩溃。

### Fuzzing 与漏洞开发工具链

Claroty Team82 发布了一个开源的 `opcua-exploit-framework`，将多年 Pwn2Own 级别的研究打包成可重用模块：

- **模式：** `sanity`（轻量级读取/浏览）、`attacks`（例如线程池饥饿、文件上传 DoS）、`corpus`（重放 fuzz 有效载荷）、`server`（恶意 OPC UA 服务器以后门客户端）。
- **使用模式：**
```bash
# Run a DoS attack against a Prosys Simulation Server endpoint
python3 main.py prosys 10.10.10.10 53530 /OPCUA/SimulationServer thread_pool_wait_starvation

# Replay an entire Boofuzz corpus against open62541
python3 main.py open62541 192.168.1.50 4840 / opcua_message_boofuzz_db input_corpus_minimized/opcua.db
```
- **恶意服务器场景：** 捆绑的基于 asyncua 的服务器让你通过提供恶意地址空间来针对客户端软件（例如，返回包含过大 `ExtensionObject` 的响应以触发 UA Expert 克隆的解析漏洞）。
- **目标覆盖：** 内置配置文件映射到 Kepware、Ignition、Unified Automation、Softing SIS、Triangle Microworks、Node-OPCUA、Python OPC UA、Milo、open62541 等，因此你可以在不重写有效载荷的情况下快速在各栈之间切换。
- **集成建议：** 将其输出与自己的 fuzzer 链接——先喷洒 `corpus` 有效载荷，然后让 OpalOPC 重新验证崩溃是否导致不安全的默认设置复活（匿名登录、设定点写入访问等）。

### 利用认证绕过

如果发现认证绕过漏洞，可以相应地配置一个 [OPC UA client](https://www.prosysopc.com/products/opc-ua-browser/) 并查看可访问的内容。这可能从仅仅读取过程值扩展到实际操作重型工业设备。

要了解你可访问的设备类型，请在地址空间中读取 "ServerStatus" 节点值并在网上搜索使用手册。

## Shodan

- `port:4840`
- `port:62541 "OPC UA"`
- `ssl:"urn:opcua"`
- `product:"opc ua"`

将搜索与厂商字符串（`"Ignition OPC UA"`、`"KepServerEX"`）或证书（`"CN=UaServerCert"`）结合，以在开始侵入性测试前优先考虑高价值资产。

## References

- [https://opalopc.com/how-to-hack-opc-ua/](https://opalopc.com/how-to-hack-opc-ua/)
- [https://github.com/claroty/opcua-exploit-framework](https://github.com/claroty/opcua-exploit-framework)
- [https://certvde.com/en/advisories/VDE-2025-022/](https://certvde.com/en/advisories/VDE-2025-022/)


{{#include ../banners/hacktricks-training.md}}
