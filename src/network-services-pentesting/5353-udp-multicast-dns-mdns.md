# 5353/UDP Multicast DNS (mDNS) and DNS-SD

{{#include ../banners/hacktricks-training.md}}

## Basic Information

Multicast DNS (mDNS) ermöglicht DNS-ähnliche Namensauflösung und Service Discovery innerhalb eines lokalen Links ohne einen unicast DNS-Server. Es verwendet UDP/5353 und die Multicast-Adressen 224.0.0.251 (IPv4) und FF02::FB (IPv6). DNS Service Discovery (DNS-SD, typischerweise mit mDNS verwendet) bietet eine standardisierte Möglichkeit, Dienste über PTR-, SRV- und TXT-Einträge aufzulisten und zu beschreiben.
```
PORT     STATE SERVICE
5353/udp open  zeroconf
```
Wichtige Protokolldetails, die du bei Angriffen häufig nutzt:
- Namen in der .local-Zone werden via mDNS aufgelöst.
- Das QU (Query Unicast)-Bit kann Unicast-Antworten anfordern, selbst für Multicast-Anfragen.
- Implementierungen sollten Pakete, die nicht vom lokalen Link stammen, ignorieren; einige Stacks akzeptieren sie trotzdem.
- Probing/announcing erzwingt eindeutige Host-/Service-Namen; Eingreifen hier erzeugt DoS-/“name squatting”-Zustände.

## DNS-SD Dienstmodell

Services are identified as _<service>._tcp or _<service>._udp under .local, e.g. _ipp._tcp.local (Drucker), _airplay._tcp.local (AirPlay), _adb._tcp.local (Android Debug Bridge), etc. Discover types with _services._dns-sd._udp.local, then resolve discovered instances to SRV/TXT/A/AAAA.

## Netzwerk-Erkundung und Enumeration

- nmap target scan (direct mDNS on a host):
```bash
nmap -sU -p 5353 --script=dns-service-discovery <target>
```
- nmap broadcast discovery (listen to the segment and enumerate all DNS-SD types/instances):
```bash
sudo nmap --script=broadcast-dns-service-discovery
```
- avahi-browse (Linux):
```bash
# List service types
avahi-browse -bt _services._dns-sd._udp
# Browse all services and resolve to host/port
avahi-browse -art
```
- Apple dns-sd (macOS):
```bash
# Browse all HTTP services
dns-sd -B _http._tcp
# Enumerate service types
dns-sd -B _services._dns-sd._udp
# Resolve a specific instance to SRV/TXT
dns-sd -L "My Printer" _ipp._tcp local
```
- Packet capture with tshark:
```bash
# Live capture
sudo tshark -i <iface> -f "udp port 5353" -Y mdns
# Only DNS-SD service list queries
sudo tshark -i <iface> -f "udp port 5353" -Y "dns.qry.name == \"_services._dns-sd._udp.local\""
```

Tipp: Einige Browser/WebRTC verwenden flüchtige mDNS-Hostnamen, um lokale IPs zu verschleiern. Wenn du zufällige random-UUID.local-Kandidaten im Netzwerkverkehr siehst, löse sie per mDNS auf, um auf lokale IPs zu pivotieren.

## Angriffe

### Störung der mDNS-Namens-Probe (DoS / name squatting)

Während der Probing-Phase prüft ein Host die Einzigartigkeit eines Namens. Mit gefälschten Konflikt-Antworten zwingt man ihn, neue Namen zu wählen oder zu scheitern. Das kann die Service-Registrierung und -Erkennung verzögern oder verhindern.

Beispiel mit Pholus:
```bash
# Block new devices from taking names by auto-faking responses
sudo python3 pholus3.py <iface> -afre -stimeout 1000
```
### Service spoofing und impersonation (MitM)

Geben Sie sich als beworbene DNS‑SD‑Dienste aus (Drucker, AirPlay, HTTP, Dateifreigaben), um Clients dazu zu bringen, sich mit Ihnen zu verbinden. Das ist besonders nützlich, um:
- Dokumente abfangen, indem man _ipp._tcp oder _printer._tcp spoofed.
- Clients zu HTTP/HTTPS‑Diensten locken, um Tokens/Cookies zu ernten oder Payloads auszuliefern.
- Mit NTLM relay techniques kombinieren, wenn Windows‑Clients auth gegenüber spoofed services aushandeln.

Mit bettercap’s zerogod module (mDNS/DNS-SD spoofer/impersonator):
```bash
# Start mDNS/DNS-SD discovery
sudo bettercap -iface <iface> -eval "zerogod.discovery on"

# Show all services seen from a host
> zerogod.show 192.168.1.42
# Show full DNS records for a host (newer bettercap)
> zerogod.show-full 192.168.1.42

# Impersonate all services of a target host automatically
> zerogod.impersonate 192.168.1.42

# Save IPP print jobs to disk while impersonating a printer
> set zerogod.ipp.save_path ~/.bettercap/zerogod/documents/
> zerogod.impersonate 192.168.1.42

# Replay previously captured services
> zerogod.save 192.168.1.42 target.yml
> zerogod.advertise target.yml
```
Siehe auch generische LLMNR/NBNS/mDNS/WPAD spoofing und credential capture/relay workflows:

{{#ref}}
../generic-methodologies-and-resources/pentesting-network/spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md
{{#endref}}

### Hinweise zu aktuellen Implementierungsproblemen (nützlich für DoS/persistence während Engagements)

- Avahi reachable-assertion- und D-Bus-Crash-Bugs (2023) können avahi-daemon auf Linux-Distributionen terminieren (z. B. CVE-2023-38469..38473, CVE-2023-1981), wodurch die service discovery auf Zielhosts bis zum Neustart gestört wird.
- Cisco IOS XE Wireless LAN Controller mDNS gateway DoS (CVE-2024-20303) lässt benachbarte WLAN-Clients manipulierte mDNS-Pakete fluten, treibt die CPU des WLC in die Höhe und lässt AP-Tunnel fallen — praktisch, wenn Sie Client-Roaming erzwingen oder Controller-Resets während eines Engagements auslösen müssen.
- Apple mDNSResponder Logic-Error DoS (CVE-2024-44183) erlaubt es einem sandboxed lokalen Prozess, Bonjour zum Absturz zu bringen, um die Service-Publikation/-Suche auf Apple-Endpunkten kurzzeitig zu unterdrücken; in aktuellen iOS/macOS-Releases gepatcht.
- Apple mDNSResponder Korrektheitsproblem (CVE-2025-31222) ermöglichte lokale Privilegieneskalation via mDNSResponder; nützlich für persistence auf unmanaged Macs/iPhones, in aktuellen iOS/macOS-Updates behoben.

### Browser/WebRTC mDNS Überlegungen

Moderne Chromium/Firefox verschleiern host candidates mit zufälligen mDNS-Namen. Sie können LAN-IPs auf managed Endpoints wieder preisgeben, indem Sie die Chrome-Richtlinie `WebRtcLocalIpsAllowedUrls` pushen (oder `chrome://flags/#enable-webrtc-hide-local-ips-with-mdns`/Edge-Äquivalent umschalten), sodass ICE host candidates statt mDNS exponiert; setzen Sie dies via `HKLM\Software\Policies\Google\Chrome`.

Wenn Benutzer den Schutz manuell deaktivieren (häufig in WebRTC-Troubleshooting-Anleitungen), beginnen ihre Browser wieder unverschleierte host candidates zu bewerben, die Sie per mDNS oder ICE-Signalisierung erfassen können, um die Host-Erkennung zu beschleunigen.

## Defensive Überlegungen und OPSEC

- Segmentgrenzen: Routieren Sie 224.0.0.251/FF02::FB nicht zwischen Security-Zonen, es sei denn, ein mDNS-Gateway ist explizit erforderlich. Wenn Sie Discovery bridgen müssen, bevorzugen Sie allowlists und rate limits.
- Windows endpoints/servers:
- To hard-disable name resolution via mDNS set the registry value and reboot:
```
HKLM\SYSTEM\CurrentControlSet\Services\Dnscache\Parameters\EnableMDNS = 0 (DWORD)
```
- In managed environments, disable the built-in “mDNS (UDP-In)” Windows Defender Firewall rule (at least on the Domain profile) to prevent inbound mDNS processing while preserving home/roaming functionality.
- On newer Windows 11 builds/GPO templates, use the policy “Computer Configuration > Administrative Templates > Network > DNS Client > Configure multicast DNS (mDNS) protocol” and set it to Disabled.
- Linux (Avahi):
- Lock down publishing when not needed: set `disable-publishing=yes`, and restrict interfaces with `allow-interfaces=` / `deny-interfaces=` in `/etc/avahi/avahi-daemon.conf`.
- Consider `check-response-ttl=yes` and avoid `enable-reflector=yes` unless strictly required; prefer `reflect-filters=` allowlists when reflecting.
- macOS: Restrict inbound mDNS at host/network firewalls when Bonjour discovery is not needed for specific subnets.
- Monitoring: Alert on unusual surges in `_services._dns-sd._udp.local` queries or sudden changes in SRV/TXT of critical services; these are indicators of spoofing or service impersonation.

## Tooling quick reference

- nmap NSE: `dns-service-discovery` and `broadcast-dns-service-discovery`.
- Pholus: active scan, reverse mDNS sweeps, DoS and spoofing helpers.
```bash
# Passive sniff (timeout seconds)
sudo python3 pholus3.py <iface> -stimeout 60
# Enumerate service types
sudo python3 pholus3.py <iface> -sscan
# Send generic mDNS requests
sudo python3 pholus3.py <iface> --request
# Reverse mDNS sweep of a subnet
sudo python3 pholus3.py <iface> -rdns_scanning 192.168.2.0/24
```
- bettercap zerogod: discover, save, advertise, and impersonate mDNS/DNS-SD services (see examples above).

## Spoofing/MitM

Der interessanteste Angriff, den Sie über diesen Service durchführen können, ist ein MitM in der Kommunikation zwischen dem Client und dem echten Server. Möglicherweise können Sie sensitive Dateien erhalten (MitM der Kommunikation mit dem Drucker) oder sogar credentials (Windows authentication).\
Weitere Informationen:

{{#ref}}
../generic-methodologies-and-resources/pentesting-network/spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md
{{#endref}}

## Referenzen

- [Practical IoT Hacking: The Definitive Guide to Attacking the Internet of Things](https://books.google.co.uk/books/about/Practical_IoT_Hacking.html?id=GbYEEAAAQBAJ&redir_esc=y)
- [Nmap NSE: broadcast-dns-service-discovery](https://nmap.org/nsedoc/scripts/broadcast-dns-service-discovery.html)
- [bettercap zerogod (mDNS/DNS-SD discovery, spoofing, impersonation)](https://www.bettercap.org/modules/ethernet/zerogod/)
- [Cisco IOS XE WLC mDNS gateway DoS (CVE-2024-20303) advisory](https://www.cisco.com/c/en/us/support/docs/csa/cisco-sa-wlc-mdns-dos-4hv6pBGf.html)
- [Rapid7 advisory for Apple mDNSResponder CVE-2024-44183](https://www.rapid7.com/db/vulnerabilities/apple-mdnsresponder-cve-2024-44183/)
- [Rapid7 writeup of Apple mDNSResponder CVE-2025-31222](https://www.rapid7.com/db/vulnerabilities/apple-osx-mdnsresponder-cve-2025-31222/)

{{#include ../banners/hacktricks-training.md}}
