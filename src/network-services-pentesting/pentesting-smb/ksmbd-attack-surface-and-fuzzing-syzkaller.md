# ksmbd Attack Surface & SMB2/SMB3 Protocol Fuzzing (syzkaller)

{{#include ../../banners/hacktricks-training.md}}

## Overview
本页抽象出使用 syzkaller 对 Linux 内核 SMB 服务器 (ksmbd) 进行驱动与模糊测试的实用技术。侧重通过配置扩展协议攻击面、构建能够串联 SMB2 操作的有状态 harness、生成语法合法的 PDUs、将变异偏向覆盖较弱的代码路径，以及利用 syzkaller 的特性（如 focus_areas 和 ANYBLOB）。原始研究列举了具体 CVE，此处强调可复用的方法论和可适配到你自己环境的具体片段。

目标范围：SMB2/SMB3 over TCP。Kerberos 和 RDMA 被故意排除以简化 harness。

---

## Expand ksmbd Attack Surface via Configuration
默认的最小 ksmbd 配置会使服务器的大部分功能未被测试。启用以下特性以驱动服务器进入更多解析器/处理器并到达更深的代码路径：

- Global-level
- Durable handles
- Server multi-channel
- SMB2 leases
- Per-share-level
- Oplocks (on by default)
- VFS objects

启用这些会增加以下模块的执行：
- smb2pdu.c (command parsing/dispatch)
- ndr.c (NDR encode/decode)
- oplock.c (oplock request/break)
- smbacl.c (ACL parsing/enforcement)
- vfs.c (VFS ops)
- vfs_cache.c (lookup cache)

Notes
- 精确选项取决于你发行版的 ksmbd userspace (ksmbd-tools)。查看 /etc/ksmbd/ksmbd.conf 以及每个 share 的配置区块以启用 durable handles、leases、oplocks 和 VFS objects。
- Multi-channel 与 durable handles 会改变状态机和生命周期，在并发条件下常常暴露 UAF/refcount/OOB 类错误。

---

## Authentication and Rate-Limiting Adjustments for Fuzzing
SMB3 需要一个有效 session。 在 harness 中实现 Kerberos 会增加复杂性，因此模糊测试时优先使用 NTLM/guest：

- 允许 guest 访问并将 map to guest 设为 bad user，这样未知用户会回退到 GUEST。
- 接受 NTLMv2（如果被禁用则打补丁）。这能让握手更简单，同时覆盖 SMB3 的代码路径。
- 在试验时可以去掉严格的 credit 检查（post-hardening for CVE-2024-50285 使 simultaneous-op crediting 更严格）。否则，速率限制可能会过早拒绝模糊生成的序列。
- 增加 max connections（例如到 65536）以避免在高吞吐模糊测试时被过早拒绝。

注意：这些放宽仅用于便于模糊测试。不要在生产环境中使用这些设置。

---

## Stateful Harness: Extract Resources and Chain Requests
SMB 是有状态的：许多请求依赖于先前响应中返回的标识符（SessionId、TreeID、FileID 对）。你的 harness 必须解析响应并在同一程序内重用 ID，以到达更深的处理器（例如 smb2_create → smb2_ioctl → smb2_close）。

Example snippet to process a response buffer (skipping the +4B NetBIOS PDU length) and cache IDs:
```c
// process response. does not contain +4B PDU length
void process_buffer(int msg_no, const char *buffer, size_t received) {
uint16_t cmd_rsp = u16((const uint8_t *)(buffer + CMD_OFFSET));
switch (cmd_rsp) {
case SMB2_TREE_CONNECT:
if (received >= TREE_ID_OFFSET + sizeof(uint32_t))
tree_id = u32((const uint8_t *)(buffer + TREE_ID_OFFSET));
break;
case SMB2_SESS_SETUP:
// first session setup response carries session_id
if (msg_no == 0x01 && received >= SESSION_ID_OFFSET + sizeof(uint64_t))
session_id = u64((const uint8_t *)(buffer + SESSION_ID_OFFSET));
break;
case SMB2_CREATE:
if (received >= CREATE_VFID_OFFSET + sizeof(uint64_t)) {
persistent_file_id = u64((const uint8_t *)(buffer + CREATE_PFID_OFFSET));
volatile_file_id   = u64((const uint8_t *)(buffer + CREATE_VFID_OFFSET));
}
break;
default:
break;
}
}
```
提示
- 保持单个 fuzzer 进程共享认证/状态：在 ksmbd 的 global/session tables 上可以获得更好的稳定性和覆盖率。syzkaller 仍然通过将 ops 标记为 async 并在内部重新运行来注入并发。
- Syzkaller’s 实验性 reset_acc_state 可以重置 global state，但可能会引入严重的性能下降。优先考虑稳定性并专注于 fuzzing。

---

## 基于语法的 SMB2 生成（有效 PDUs）
将 Microsoft Open Specifications 中的 SMB2 结构转换为 fuzzer grammar，以使你的生成器产生结构上有效的 PDUs，从而系统性地到达 dispatchers 和 IOCTL handlers。

示例（SMB2 IOCTL request）：
```
smb2_ioctl_req {
Header_Prefix           SMB2Header_Prefix
Command                 const[0xb, int16]
Header_Suffix           SMB2Header_Suffix
StructureSize           const[57, int16]
Reserved                const[0, int16]
CtlCode                 union_control_codes
PersistentFileId        const[0x4, int64]
VolatileFileId          const[0x0, int64]
InputOffset             offsetof[Input, int32]
InputCount              bytesize[Input, int32]
MaxInputResponse        const[65536, int32]
OutputOffset            offsetof[Output, int32]
OutputCount             len[Output, int32]
MaxOutputResponse       const[65536, int32]
Flags                   int32[0:1]
Reserved2               const[0, int32]
Input                   array[int8]
Output                  array[int8]
} [packed]
```
这种风格强制正确的结构大小/偏移，并且相对于盲目变异显著提高覆盖率。

---

## Directed Fuzzing With focus_areas
使用 syzkaller 的实验性 focus_areas 对当前覆盖较弱的特定函数/文件赋予更高权重。示例 JSON:
```json
{
"focus_areas": [
{"filter": {"functions": ["smb_check_perm_dacl"]}, "weight": 20.0},
{"filter": {"files": ["^fs/smb/server/"]}, "weight": 2.0},
{"weight": 1.0}
]
}
```
这有助于构造有效的 ACLs，从而触发 smbacl.c 中的 arithmetic/overflow 路径。例如，一个具有过大 dacloffset 的恶意 Security Descriptor 可以重现 integer-overflow。

Reproducer builder (minimal Python):
```python
def build_sd():
import struct
sd = bytearray(0x14)
sd[0x00] = 0x00; sd[0x01] = 0x00
struct.pack_into('<H', sd, 0x02, 0x0001)
struct.pack_into('<I', sd, 0x04, 0x78)
struct.pack_into('<I', sd, 0x08, 0x00)
struct.pack_into('<I', sd, 0x0C, 0x10000)
struct.pack_into('<I', sd, 0x10, 0xFFFFFFFF)  # dacloffset
while len(sd) < 0x78:
sd += b'A'
sd += b"\x01\x01\x00\x00\x00\x00\x00\x00"  # minimal DACL
sd += b"\xCC" * 64
return bytes(sd)
```
---

## 使用 ANYBLOB 打破覆盖率瓶颈
syzkaller’s anyTypes (ANYBLOB/ANYRES) 允许将复杂结构折叠为可以通用变异的 blobs。 从公开的 SMB pcaps 中生成新的 corpus，并将 payloads 转换为调用你 pseudo-syscall（例如 syz_ksmbd_send_req）的 syzkaller 程序：
```bash
# Extract SMB payloads to JSON
# tshark -r smb2_dac_sample.pcap -Y "smb || smb2" -T json -e tcp.payload > packets.json
```

```python
import json, os
os.makedirs("corpus", exist_ok=True)

with open("packets.json") as f:
data = json.load(f)
# adjust indexing to your tshark JSON structure
packets = [e["_source"]["layers"]["tcp.payload"] for e in data]

for i, pkt in enumerate(packets):
pdu = pkt[0]
pdu_size = len(pdu) // 2  # hex string length → bytes
with open(f"corpus/packet_{i:03d}.txt", "w") as f:
f.write(
f"syz_ksmbd_send_req(&(&(0x7f0000000340))=ANY=[@ANYBLOB=\"{pdu}\"], {hex(pdu_size)}, 0x0, 0x0)"
)
```
这能快速启动探索，并且可以立即触发 UAFs（例如，在 ksmbd_sessions_deregister 中），同时将覆盖率提高几个百分点。

---

## Sanitizers：超越 KASAN
- KASAN 仍然是检测堆漏洞（UAF/OOB）的主要探测器。
- KCSAN 在该目标上经常产生误报或低严重度的数据竞争。
- UBSAN/KUBSAN 能捕获 KASAN 由于数组索引语义而遗漏的声明边界错误。示例：
```c
id = le32_to_cpu(psid->sub_auth[psid->num_subauth - 1]);
struct smb_sid {
__u8 revision; __u8 num_subauth; __u8 authority[NUM_AUTHS];
__le32 sub_auth[SID_MAX_SUB_AUTHORITIES]; /* sub_auth[num_subauth] */
} __attribute__((packed));
```
Setting num_subauth = 0 triggers an in-struct OOB read of sub_auth[-1], caught by UBSAN’s declared-bounds checks.

---

## 吞吐量与并行性说明
- 单个 fuzzer 进程（共享 auth/state）对于 ksmbd 通常更稳定，并且仍能借助 syzkaller 的内部 async executor 触发 races/UAFs。
- 在多台 VMs 下，总体仍可达到每秒数百个 SMB 命令。函数级覆盖率大致可达 fs/smb/server 约 60% 和 smb2pdu.c 约 70%，但这些度量通常不能充分反映 state-transition 的覆盖情况。

---

## 实用检查清单
- 在 ksmbd 中启用 durable handles、leases、multi-channel、oplocks 和 VFS objects。
- 允许 guest 和 map-to-guest；接受 NTLMv2。移除 credit limits 并提高 max connections 以提升 fuzzer 稳定性。
- 构建有状态的 harness，缓存 SessionId/TreeID/FileIDs 并串联 create → ioctl → close。
- 使用 SMB2 PDUs 的 grammar 以保持结构有效性。
- 使用 focus_areas 对覆盖薄弱的函数加权（例如 smbacl.c 中的 smb_check_perm_dacl 路径）。
- 用来自真实 pcaps 的 ANYBLOB 作为种子以打破平台瓶颈；用 syz-db 打包 seeds 以便复用。
- 使用 KASAN + UBSAN 运行；仔细处置 UBSAN 的 declared-bounds 报告。

---

## 参考资料
- Doyensec – ksmbd Fuzzing (Part 2): https://blog.doyensec.com/2025/09/02/ksmbd-2.html
- syzkaller: https://github.com/google/syzkaller
- ANYBLOB/anyTypes (commit 9fe8aa4): https://github.com/google/syzkaller/commit/9fe8aa4
- Async executor change (commit fd8caa5): https://github.com/google/syzkaller/commit/fd8caa5
- syz-db: https://github.com/google/syzkaller/tree/master/tools/syz-db
- KASAN: https://docs.kernel.org/dev-tools/kasan.html
- UBSAN/KUBSAN: https://docs.kernel.org/dev-tools/ubsan.html
- KCSAN: https://docs.kernel.org/dev-tools/kcsan.html
- Microsoft Open Specifications (SMB): https://learn.microsoft.com/openspecs/
- Wireshark Sample Captures: https://wiki.wireshark.org/SampleCaptures
- Background reading: pwning.tech “Tickling ksmbd: fuzzing SMB in the Linux kernel”; Dongliang Mu’s syzkaller notes

{{#include ../../banners/hacktricks-training.md}}
