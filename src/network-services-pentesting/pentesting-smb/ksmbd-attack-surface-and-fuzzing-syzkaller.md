# ksmbd Επιφάνεια Επίθεσης & SMB2/SMB3 Protocol Fuzzing (syzkaller)

{{#include ../../banners/hacktricks-training.md}}

## Επισκόπηση
Αυτή η σελίδα συνοψίζει πρακτικές τεχνικές για την άσκηση και το fuzzing του Linux in-kernel SMB server (ksmbd) χρησιμοποιώντας syzkaller. Εστιάζει στη διεύρυνση της επιφάνειας επίθεσης του πρωτοκόλλου μέσω διαμόρφωσης, στην κατασκευή ενός stateful harness ικανό να αλυσοδέσει SMB2 operations, στη δημιουργία grammar-valid PDUs, στην κατευθυνόμενη μεταβολή προς προσωπουμένους κώδικες με χαμηλή κάλυψη και στην αξιοποίηση δυνατοτήτων του syzkaller όπως focus_areas και ANYBLOB. Ενώ η αρχική έρευνα απαριθμεί συγκεκριμένα CVEs, εδώ δίνουμε έμφαση στην επαναχρησιμοποιήσιμη μεθοδολογία και στα απτά snippets που μπορείτε να προσαρμόσετε στο δικό σας περιβάλλον.

Στόχος: SMB2/SMB3 πάνω από TCP. Kerberos και RDMA είναι σκόπιμα εκτός πεδίου για να κρατήσει το harness απλό.

---

## Διεύρυνση της επιφάνειας επίθεσης του ksmbd μέσω διαμόρφωσης
Σε ένα ελάχιστο ksmbd setup πολλά μέρη του server μένουν ανεξερεύνητα. Ενεργοποιήστε τα παρακάτω χαρακτηριστικά για να αναγκάσετε τον server να περάσει από επιπλέον parsers/handlers και να φτάσετε σε βαθύτερες διαδρομές κώδικα:

- Global-level
- Durable handles
- Server multi-channel
- SMB2 leases
- Per-share-level
- Oplocks (on by default)
- VFS objects

Η ενεργοποίηση αυτών αυξάνει την εκτέλεση σε modules όπως:
- smb2pdu.c (command parsing/dispatch)
- ndr.c (NDR encode/decode)
- oplock.c (oplock request/break)
- smbacl.c (ACL parsing/enforcement)
- vfs.c (VFS ops)
- vfs_cache.c (lookup cache)

Σημειώσεις
- Exact options depend on your distro’s ksmbd userspace (ksmbd-tools). Review /etc/ksmbd/ksmbd.conf and per-share sections to enable durable handles, leases, oplocks and VFS objects.
- Multi-channel and durable handles alter state machines and lifetimes, often surfacing UAF/refcount/OOB bugs under concurrency.

---

## Προσαρμογές αυθεντικοποίησης και περιορισμού ρυθμού για Fuzzing
SMB3 χρειάζεται έγκυρη συνεδρία. Η υλοποίηση Kerberos στα harnesses προσθέτει πολυπλοκότητα, οπότε προτιμήστε NTLM/guest για fuzzing:

- Allow guest access and set map to guest = bad user so unknown users fall back to GUEST.
- Accept NTLMv2 (patch policy if disabled). This keeps the handshake simple while exercising SMB3 code paths.
- Patch out strict credit checks when experimenting (post-hardening for CVE-2024-50285 made simultaneous-op crediting stricter). Otherwise, rate-limits can reject fuzzed sequences too early.
- Increase max connections (e.g., to 65536) to avoid early rejections during high-throughput fuzzing.

Προσοχή: Αυτές οι χαλαρώσεις εξυπηρετούν αποκλειστικά το fuzzing. Μην τις αναπτύξετε σε παραγωγικό περιβάλλον.

---

## Stateful Harness: Εξαγωγή πόρων και αλυσίδωση αιτήσεων
Το SMB είναι stateful: πολλά αιτήματα εξαρτώνται από identifiers που επιστρέφονται από προηγούμενες απαντήσεις (SessionId, TreeID, FileID pairs). Το harness σας πρέπει να κάνει parse τις απαντήσεις και να επαναχρησιμοποιεί IDs μέσα στο ίδιο πρόγραμμα για να φτάσει σε βαθύτερους handlers (π.χ. smb2_create → smb2_ioctl → smb2_close).

Παράδειγμα snippet για επεξεργασία ενός response buffer (παραλείποντας το +4B NetBIOS PDU length) και αποθήκευση των IDs:
```c
// process response. does not contain +4B PDU length
void process_buffer(int msg_no, const char *buffer, size_t received) {
uint16_t cmd_rsp = u16((const uint8_t *)(buffer + CMD_OFFSET));
switch (cmd_rsp) {
case SMB2_TREE_CONNECT:
if (received >= TREE_ID_OFFSET + sizeof(uint32_t))
tree_id = u32((const uint8_t *)(buffer + TREE_ID_OFFSET));
break;
case SMB2_SESS_SETUP:
// first session setup response carries session_id
if (msg_no == 0x01 && received >= SESSION_ID_OFFSET + sizeof(uint64_t))
session_id = u64((const uint8_t *)(buffer + SESSION_ID_OFFSET));
break;
case SMB2_CREATE:
if (received >= CREATE_VFID_OFFSET + sizeof(uint64_t)) {
persistent_file_id = u64((const uint8_t *)(buffer + CREATE_PFID_OFFSET));
volatile_file_id   = u64((const uint8_t *)(buffer + CREATE_VFID_OFFSET));
}
break;
default:
break;
}
}
```
Συμβουλές
- Διατηρήστε μία διεργασία fuzzer που μοιράζεται authentication/state: καλύτερη σταθερότητα και κάλυψη με τους global/session πίνακες του ksmbd. syzkaller εξακολουθεί να εισάγει concurrency με το να χαρακτηρίζει ops ως async, και κάνει rerun εσωτερικά.
- Το πειραματικό reset_acc_state του Syzkaller μπορεί να επαναφέρει την global state αλλά μπορεί να προκαλέσει σημαντική επιβράδυνση. Προτιμήστε τη σταθερότητα και εστιάστε στο fuzzing.

---

## Δημιουργία SMB2 βάσει γραμματικής (Valid PDUs)
Μεταφράστε τις δομές SMB2 των Microsoft Open Specifications σε μια γραμματική για fuzzer ώστε ο generator σας να παράγει δομικά έγκυρα PDUs, που συστηματικά φτάνουν στους dispatchers και στους IOCTL handlers.

Παράδειγμα (SMB2 IOCTL request):
```
smb2_ioctl_req {
Header_Prefix           SMB2Header_Prefix
Command                 const[0xb, int16]
Header_Suffix           SMB2Header_Suffix
StructureSize           const[57, int16]
Reserved                const[0, int16]
CtlCode                 union_control_codes
PersistentFileId        const[0x4, int64]
VolatileFileId          const[0x0, int64]
InputOffset             offsetof[Input, int32]
InputCount              bytesize[Input, int32]
MaxInputResponse        const[65536, int32]
OutputOffset            offsetof[Output, int32]
OutputCount             len[Output, int32]
MaxOutputResponse       const[65536, int32]
Flags                   int32[0:1]
Reserved2               const[0, int32]
Input                   array[int8]
Output                  array[int8]
} [packed]
```
Αυτό το στυλ επιβάλλει τα σωστά μεγέθη/offsets των δομών και βελτιώνει δραματικά την κάλυψη σε σύγκριση με blind mutation.

---

## Κατευθυνόμενο Fuzzing με focus_areas
Χρησιμοποιήστε το πειραματικό focus_areas του syzkaller για να δώσετε μεγαλύτερο βάρος σε συγκεκριμένες συναρτήσεις/αρχεία που προς το παρόν έχουν αδύναμη κάλυψη. Παράδειγμα JSON:
```json
{
"focus_areas": [
{"filter": {"functions": ["smb_check_perm_dacl"]}, "weight": 20.0},
{"filter": {"files": ["^fs/smb/server/"]}, "weight": 2.0},
{"weight": 1.0}
]
}
```
Αυτό βοηθά στο να κατασκευαστούν έγκυρα ACLs που ενεργοποιούν τα arithmetic/overflow μονοπάτια στο smbacl.c. Για παράδειγμα, ένας κακόβουλος Security Descriptor με υπερμεγέθη dacloffset αναπαράγει ένα integer-overflow.

Δημιουργός αναπαραγωγής (ελάχιστο Python):
```python
def build_sd():
import struct
sd = bytearray(0x14)
sd[0x00] = 0x00; sd[0x01] = 0x00
struct.pack_into('<H', sd, 0x02, 0x0001)
struct.pack_into('<I', sd, 0x04, 0x78)
struct.pack_into('<I', sd, 0x08, 0x00)
struct.pack_into('<I', sd, 0x0C, 0x10000)
struct.pack_into('<I', sd, 0x10, 0xFFFFFFFF)  # dacloffset
while len(sd) < 0x78:
sd += b'A'
sd += b"\x01\x01\x00\x00\x00\x00\x00\x00"  # minimal DACL
sd += b"\xCC" * 64
return bytes(sd)
```
---

## Ξεπερνώντας τα πλατώ κάλυψης με ANYBLOB
Τα anyTypes του syzkaller (ANYBLOB/ANYRES) επιτρέπουν τη σύμπτυξη πολύπλοκων δομών σε blobs που μεταλλάσσονται γενικά. Τροφοδοτήστε ένα νέο corpus από δημόσια SMB pcaps και μετατρέψτε τα payloads σε syzkaller προγράμματα που καλούν το pseudo-syscall σας (π.χ., syz_ksmbd_send_req):
```bash
# Extract SMB payloads to JSON
# tshark -r smb2_dac_sample.pcap -Y "smb || smb2" -T json -e tcp.payload > packets.json
```

```python
import json, os
os.makedirs("corpus", exist_ok=True)

with open("packets.json") as f:
data = json.load(f)
# adjust indexing to your tshark JSON structure
packets = [e["_source"]["layers"]["tcp.payload"] for e in data]

for i, pkt in enumerate(packets):
pdu = pkt[0]
pdu_size = len(pdu) // 2  # hex string length → bytes
with open(f"corpus/packet_{i:03d}.txt", "w") as f:
f.write(
f"syz_ksmbd_send_req(&(&(0x7f0000000340))=ANY=[@ANYBLOB=\"{pdu}\"], {hex(pdu_size)}, 0x0, 0x0)"
)
```
Αυτό επιταχύνει την εξερεύνηση και μπορεί άμεσα να ενεργοποιήσει UAFs (π.χ. στο ksmbd_sessions_deregister) ενώ αυξάνει την κάλυψη κατά μερικά τοις εκατό.

---

## Sanitizers: Πέρα από το KASAN
- Το KASAN παραμένει ο κύριος ανιχνευτής για heap bugs (UAF/OOB).
- Το KCSAN συχνά παράγει false positives ή low-severity data races σε αυτόν τον στόχο.
- UBSAN/KUBSAN μπορεί να εντοπίσει declared-bounds mistakes που το KASAN χάνει λόγω array-index semantics. Παράδειγμα:
```c
id = le32_to_cpu(psid->sub_auth[psid->num_subauth - 1]);
struct smb_sid {
__u8 revision; __u8 num_subauth; __u8 authority[NUM_AUTHS];
__le32 sub_auth[SID_MAX_SUB_AUTHORITIES]; /* sub_auth[num_subauth] */
} __attribute__((packed));
```
Η ρύθμιση num_subauth = 0 προκαλεί in-struct OOB read του sub_auth[-1], που εντοπίστηκε από τις declared-bounds checks του UBSAN.

---

## Σημειώσεις για Διεκπεραιωτικότητα και Παραλληλισμό
- Μια μοναδική διεργασία fuzzer (shared auth/state) τείνει να είναι σημαντικά πιο σταθερή για το ksmbd και εξακολουθεί να αποκαλύπτει races/UAFs χάρη στον εσωτερικό async executor του syzkaller.
- Με πολλαπλά VMs μπορείτε ακόμη να φτάσετε σε εκατοντάδες εντολές SMB/δευτερόλεπτο συνολικά. Η κάλυψη σε επίπεδο συνάρτησης περίπου ~60% του fs/smb/server και ~70% του smb2pdu.c είναι εφικτή, αν και η κάλυψη μεταβάσεων κατάστασης υποαντιπροσωπεύεται από τέτοιες μετρήσεις.

---

## Πρακτική Λίστα Ελέγχου
- Ενεργοποιήστε durable handles, leases, multi-channel, oplocks και VFS objects στο ksmbd.
- Επιτρέψτε guest και map-to-guest· αποδεχτείτε NTLMv2. Αφαιρέστε τα credit limits και αυξήστε τα max connections για σταθερότητα του fuzzer.
- Κατασκευάστε ένα stateful harness που αποθηκεύει στην cache τα SessionId/TreeID/FileIDs και αλυσσοποιεί create → ioctl → close.
- Χρησιμοποιήστε ένα grammar για SMB2 PDUs για να διατηρείτε τη δομική εγκυρότητα.
- Χρησιμοποιήστε focus_areas για να υπερβαρύνετε ασθενώς καλυμμένες συναρτήσεις (π.χ. μονοπάτια στο smbacl.c όπως smb_check_perm_dacl).
- Seed με ANYBLOB από πραγματικά pcaps για να σπάσετε plateaus· πακετάρετε τα seeds με syz-db για επαναχρησιμοποίηση.
- Τρέξτε με KASAN + UBSAN· αξιολογήστε προσεκτικά τις αναφορές UBSAN declared-bounds.

---

## Αναφορές
- Doyensec – ksmbd Fuzzing (Part 2): https://blog.doyensec.com/2025/09/02/ksmbd-2.html
- syzkaller: https://github.com/google/syzkaller
- ANYBLOB/anyTypes (commit 9fe8aa4): https://github.com/google/syzkaller/commit/9fe8aa4
- Async executor change (commit fd8caa5): https://github.com/google/syzkaller/commit/fd8caa5
- syz-db: https://github.com/google/syzkaller/tree/master/tools/syz-db
- KASAN: https://docs.kernel.org/dev-tools/kasan.html
- UBSAN/KUBSAN: https://docs.kernel.org/dev-tools/ubsan.html
- KCSAN: https://docs.kernel.org/dev-tools/kcsan.html
- Microsoft Open Specifications (SMB): https://learn.microsoft.com/openspecs/
- Wireshark Sample Captures: https://wiki.wireshark.org/SampleCaptures
- Επιπλέον ανάγνωση: pwning.tech “Tickling ksmbd: fuzzing SMB in the Linux kernel”; Dongliang Mu’s syzkaller notes

{{#include ../../banners/hacktricks-training.md}}
