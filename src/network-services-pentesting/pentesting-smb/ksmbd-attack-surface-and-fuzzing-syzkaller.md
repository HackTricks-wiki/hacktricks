# Поверхня атак ksmbd та fuzzing протоколу SMB2/SMB3 (syzkaller)

{{#include ../../banners/hacktricks-training.md}}

## Огляд
Ця сторінка узагальнює практичні підходи для опрацювання та fuzzing Linux in-kernel SMB сервера (ksmbd) з використанням syzkaller. У фокусі — розширення поверхні атак протоколу через конфігурацію, побудова стейтфул harness'а, здатного ланцюжити SMB2 операції, генерування граматично валідних PDU, спрямовування мутацій у слабо охоплені гілки коду та використання можливостей syzkaller, таких як focus_areas і ANYBLOB. Хоча оригінальне дослідження перелічує конкретні CVE, тут ми наголошуємо на повторно використовувальній методології та конкретних фрагментах, які ви можете адаптувати до власних налаштувань.

Цільовий обсяг: SMB2/SMB3 поверх TCP. Kerberos і RDMA свідомо поза обсягом, щоб зберегти harness простим.

---

## Розширення поверхні атак ksmbd через конфігурацію
За замовчуванням мінімальна конфігурація ksmbd залишає великі частини сервера неохопленими. Увімкніть наступні можливості, щоб прогнати сервер через додаткові парсери/обробники й досягти глибших гілок коду:

- На глобальному рівні
- Durable handles
- Server multi-channel
- SMB2 leases
- На рівні шару (per-share-level)
- Oplocks (увімкнено за замовчуванням)
- VFS objects

Увімкнення цих опцій збільшує виконання в модулях, таких як:
- smb2pdu.c (парсинг/диспатч команд)
- ndr.c (NDR encode/decode)
- oplock.c (oplock request/break)
- smbacl.c (парсинг/примус дотримання ACL)
- vfs.c (VFS ops)
- vfs_cache.c (lookup cache)

Примітки
- Точні опції залежать від вашого дистрибутива та userspace ksmbd (ksmbd-tools). Перегляньте /etc/ksmbd/ksmbd.conf та секції per-share, щоб увімкнути durable handles, leases, oplocks та VFS objects.
- Multi-channel і durable handles змінюють state machines і час життя об’єктів, що часто виявляє UAF/refcount/OOB баги під конкуренцією.

---

## Аутентифікація та налаштування обмеження швидкості для fuzzing
SMB3 потребує валідної сесії. Реалізація Kerberos у harness’ах додає складності, тому для fuzzing краще використовувати NTLM/guest:

- Дозвольте guest доступ і встановіть map to guest = bad user, щоб невідомі користувачі спадали на GUEST.
- Приймайте NTLMv2 (за потреби напатчіть політику, якщо відключено). Це спрощує handshake, водночас зачіпаючи SMB3 кодові шляхи.
- Вимкніть суворі перевірки кредитів під час експериментів (post-hardening для CVE-2024-50285 зробив simultaneous-op crediting суворішим). Інакше rate-limits можуть відкидати fuzzed послідовності занадто рано.
- Збільшіть max connections (наприклад, до 65536), щоб уникнути ранніх відмов під час високопродуктивного fuzzing.

Увага: ці пом’якшення призначені тільки для полегшення fuzzing. Не використовуйте такі налаштування в production.

---

## Stateful Harness: Extract Resources and Chain Requests
SMB є stateful: багато запитів залежать від ідентифікаторів, що повертаються попередніми відповідями (SessionId, TreeID, FileID pairs). Ваш harness має парсити відповіді та повторно використовувати ID в межах одного програми, щоб досягти глибоких обробників (наприклад, smb2_create → smb2_ioctl → smb2_close).

Приклад фрагмента для обробки буфера відповіді (пропускаючи +4B NetBIOS PDU length) та кешування ID:
```c
// process response. does not contain +4B PDU length
void process_buffer(int msg_no, const char *buffer, size_t received) {
uint16_t cmd_rsp = u16((const uint8_t *)(buffer + CMD_OFFSET));
switch (cmd_rsp) {
case SMB2_TREE_CONNECT:
if (received >= TREE_ID_OFFSET + sizeof(uint32_t))
tree_id = u32((const uint8_t *)(buffer + TREE_ID_OFFSET));
break;
case SMB2_SESS_SETUP:
// first session setup response carries session_id
if (msg_no == 0x01 && received >= SESSION_ID_OFFSET + sizeof(uint64_t))
session_id = u64((const uint8_t *)(buffer + SESSION_ID_OFFSET));
break;
case SMB2_CREATE:
if (received >= CREATE_VFID_OFFSET + sizeof(uint64_t)) {
persistent_file_id = u64((const uint8_t *)(buffer + CREATE_PFID_OFFSET));
volatile_file_id   = u64((const uint8_t *)(buffer + CREATE_VFID_OFFSET));
}
break;
default:
break;
}
}
```
Поради
- Підтримуйте один процес fuzzer, який спільно використовує автентифікацію/стан: це дає кращу стабільність і покриття з ksmbd’s global/session tables. syzkaller все ще інжектує concurrency, позначаючи ops як async і повторно запускаючи їх внутрішньо.
- Syzkaller’s експериментальна reset_acc_state може скинути global state, але може призвести до значного уповільнення. Віддавайте перевагу стабільності і сфокусованому fuzzing замість цього.

---

## Генерація SMB2 на основі граматики (валідні PDUs)
Побудуйте граматику для fuzzer на основі структур Microsoft Open Specifications SMB2, щоб ваш генератор створював структурно валідні PDUs, які систематично доходять до dispatchers та IOCTL handlers.

Приклад (SMB2 IOCTL request):
```
smb2_ioctl_req {
Header_Prefix           SMB2Header_Prefix
Command                 const[0xb, int16]
Header_Suffix           SMB2Header_Suffix
StructureSize           const[57, int16]
Reserved                const[0, int16]
CtlCode                 union_control_codes
PersistentFileId        const[0x4, int64]
VolatileFileId          const[0x0, int64]
InputOffset             offsetof[Input, int32]
InputCount              bytesize[Input, int32]
MaxInputResponse        const[65536, int32]
OutputOffset            offsetof[Output, int32]
OutputCount             len[Output, int32]
MaxOutputResponse       const[65536, int32]
Flags                   int32[0:1]
Reserved2               const[0, int32]
Input                   array[int8]
Output                  array[int8]
} [packed]
```
Цей стиль забезпечує правильні розміри/зсуви структур і значно покращує покриття порівняно з blind mutation.

---

## Directed Fuzzing With focus_areas
Використовуйте syzkaller’s experimental focus_areas, щоб надавати більшу вагу конкретним функціям/файлам, які наразі мають слабке покриття. Приклад JSON:
```json
{
"focus_areas": [
{"filter": {"functions": ["smb_check_perm_dacl"]}, "weight": 20.0},
{"filter": {"files": ["^fs/smb/server/"]}, "weight": 2.0},
{"weight": 1.0}
]
}
```
Це допомагає створювати валідні ACLs, які зачіпають арифметичні/переповнювальні шляхи в smbacl.c. Наприклад, зловмисний Security Descriptor з надмірно великим dacloffset відтворює integer-overflow.

Конструктор репродуцера (мінімальний Python):
```python
def build_sd():
import struct
sd = bytearray(0x14)
sd[0x00] = 0x00; sd[0x01] = 0x00
struct.pack_into('<H', sd, 0x02, 0x0001)
struct.pack_into('<I', sd, 0x04, 0x78)
struct.pack_into('<I', sd, 0x08, 0x00)
struct.pack_into('<I', sd, 0x0C, 0x10000)
struct.pack_into('<I', sd, 0x10, 0xFFFFFFFF)  # dacloffset
while len(sd) < 0x78:
sd += b'A'
sd += b"\x01\x01\x00\x00\x00\x00\x00\x00"  # minimal DACL
sd += b"\xCC" * 64
return bytes(sd)
```
---

## Подолання плато покриття за допомогою ANYBLOB
syzkaller’s anyTypes (ANYBLOB/ANYRES) дозволяють зводити складні структури до blobs, які універсально мутують. Створіть новий корпус із публічних SMB pcaps і перетворіть payloads на syzkaller programs, що викликають ваш pseudo-syscall (наприклад, syz_ksmbd_send_req):
```bash
# Extract SMB payloads to JSON
# tshark -r smb2_dac_sample.pcap -Y "smb || smb2" -T json -e tcp.payload > packets.json
```

```python
import json, os
os.makedirs("corpus", exist_ok=True)

with open("packets.json") as f:
data = json.load(f)
# adjust indexing to your tshark JSON structure
packets = [e["_source"]["layers"]["tcp.payload"] for e in data]

for i, pkt in enumerate(packets):
pdu = pkt[0]
pdu_size = len(pdu) // 2  # hex string length → bytes
with open(f"corpus/packet_{i:03d}.txt", "w") as f:
f.write(
f"syz_ksmbd_send_req(&(&(0x7f0000000340))=ANY=[@ANYBLOB=\"{pdu}\"], {hex(pdu_size)}, 0x0, 0x0)"
)
```
Це дає пришвидшений старт дослідженню і може негайно спричинити UAFs (наприклад, у ksmbd_sessions_deregister), одночасно підвищуючи покриття на кілька відсотків.

---

## Санітизери: не тільки KASAN
- KASAN залишається основним детектором для помилок у heap (UAF/OOB).
- KCSAN часто дає false positives або data races низької серйозності в цьому таргеті.
- UBSAN/KUBSAN можуть виявляти помилки оголошених меж, які KASAN пропускає через семантику індексів масиву. Приклад:
```c
id = le32_to_cpu(psid->sub_auth[psid->num_subauth - 1]);
struct smb_sid {
__u8 revision; __u8 num_subauth; __u8 authority[NUM_AUTHS];
__le32 sub_auth[SID_MAX_SUB_AUTHORITIES]; /* sub_auth[num_subauth] */
} __attribute__((packed));
```
Setting num_subauth = 0 призводить до in-struct OOB read of sub_auth[-1], яке перехоплюється перевірками declared-bounds UBSAN.

---

## Примітки щодо пропускної здатності та паралелізму
- Один процес fuzzer (shared auth/state) зазвичай значно стабільніший для ksmbd і все ще виявляє races/UAFs завдяки внутрішньому async executor syzkaller.
- На кількох VM загалом можна досягти сотень SMB commands/second. Покриття на рівні функцій приблизно ~60% для fs/smb/server і ~70% для smb2pdu.c досяжне, хоча покриття переходів станів недооцінюється такими метриками.

---

## Практичний чекліст
- Увімкніть durable handles, leases, multi-channel, oplocks і VFS objects у ksmbd.
- Дозвольте guest і map-to-guest; приймайте NTLMv2. Видаліть credit limits і підніміть max connections для стабільності fuzzer.
- Збудуйте stateful harness, який кешує SessionId/TreeID/FileIDs і ланцюжить create → ioctl → close.
- Використовуйте граматику для SMB2 PDUs, щоб зберегти структурну валідність.
- Використовуйте focus_areas, щоб підсилити вагу слабко покритих функцій (наприклад, шляхи в smbacl.c як smb_check_perm_dacl).
- Сійте ANYBLOB з реальних pcaps, щоб прорвати плато; пакуйте seeds з syz-db для повторного використання.
- Запускайте з KASAN + UBSAN; акуратно триажуйте звіти UBSAN declared-bounds.

---

## Джерела
- Doyensec – ksmbd Fuzzing (Part 2): https://blog.doyensec.com/2025/09/02/ksmbd-2.html
- syzkaller: https://github.com/google/syzkaller
- ANYBLOB/anyTypes (commit 9fe8aa4): https://github.com/google/syzkaller/commit/9fe8aa4
- Async executor change (commit fd8caa5): https://github.com/google/syzkaller/commit/fd8caa5
- syz-db: https://github.com/google/syzkaller/tree/master/tools/syz-db
- KASAN: https://docs.kernel.org/dev-tools/kasan.html
- UBSAN/KUBSAN: https://docs.kernel.org/dev-tools/ubsan.html
- KCSAN: https://docs.kernel.org/dev-tools/kcsan.html
- Microsoft Open Specifications (SMB): https://learn.microsoft.com/openspecs/
- Wireshark Sample Captures: https://wiki.wireshark.org/SampleCaptures
- Background reading: pwning.tech “Tickling ksmbd: fuzzing SMB in the Linux kernel”; Dongliang Mu’s syzkaller notes

{{#include ../../banners/hacktricks-training.md}}
