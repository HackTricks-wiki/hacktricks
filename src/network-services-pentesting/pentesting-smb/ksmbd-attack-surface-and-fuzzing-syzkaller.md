# ksmbd Attack Surface & SMB2/SMB3 Protocol Fuzzing (syzkaller)

{{#include ../../banners/hacktricks-training.md}}

## Panoramica
Questa pagina riassume tecniche pratiche per esercitare e fuzzare il server SMB in-kernel di Linux (ksmbd) usando syzkaller. Si concentra sull'espansione della superficie di attacco del protocollo tramite configurazione, sulla costruzione di un harness stateful capace di concatenare operazioni SMB2, sulla generazione di PDU grammaticalmente valide, sull'orientamento delle mutazioni verso percorsi di codice poco coperti e sull'uso di funzionalità di syzkaller come focus_areas e ANYBLOB. Mentre la ricerca originale elenca CVE specifici, qui enfatizziamo la metodologia riutilizzabile e frammenti concreti che puoi adattare ai tuoi setup.

Ambito target: SMB2/SMB3 su TCP. Kerberos e RDMA sono intenzionalmente fuori dal scope per mantenere semplice l'harness.

---

## Espandi la superficie di attacco di ksmbd tramite configurazione
Per default, una configurazione minima di ksmbd lascia gran parte del server non testata. Abilita le seguenti funzionalità per far attraversare al server parser/handler aggiuntivi e raggiungere percorsi di codice più profondi:

- Global-level
- Durable handles
- Server multi-channel
- SMB2 leases
- Per-share-level
- Oplocks (on by default)
- VFS objects

Abilitandole si aumenta l'esecuzione in moduli come:
- smb2pdu.c (command parsing/dispatch)
- ndr.c (NDR encode/decode)
- oplock.c (oplock request/break)
- smbacl.c (ACL parsing/enforcement)
- vfs.c (VFS ops)
- vfs_cache.c (lookup cache)

Note
- Le opzioni esatte dipendono dal userspace ksmbd della tua distro (ksmbd-tools). Controlla /etc/ksmbd/ksmbd.conf e le sezioni per-share per abilitare durable handles, leases, oplocks e VFS objects.
- Multi-channel e durable handles alterano state machine e lifetimes, spesso facendo emergere UAF/refcount/OOB bug sotto concorrenza.

---

## Autenticazione e aggiustamenti del rate-limiting per il fuzzing
SMB3 richiede una sessione valida. Implementare Kerberos negli harness aggiunge complessità, quindi preferisci NTLM/guest per il fuzzing:

- Consenti accesso guest e imposta map to guest = bad user in modo che utenti non riconosciuti cadano su GUEST.
- Accetta NTLMv2 (applica patch alla policy se disabilitato). Questo mantiene semplice l'handshake pur esercitando i percorsi di codice SMB3.
- Rimuovi i controlli stretti sui credit durante gli esperimenti (post-hardening per CVE-2024-50285 ha reso il crediting per operazioni simultanee più severo). Altrimenti, i rate-limit possono respingere sequenze fuzzate troppo presto.
- Aumenta max connections (es. a 65536) per evitare rifiuti prematuri durante il fuzzing ad alto throughput.

Attenzione: Queste rilassazioni servono solo a facilitare il fuzzing. Non distribuire con queste impostazioni in produzione.

---

## Stateful Harness: Extract Resources and Chain Requests
SMB è stateful: molte richieste dipendono da identificatori restituiti da risposte precedenti (SessionId, TreeID, coppie FileID). Il tuo harness deve parsare le risposte e riusare gli ID all'interno dello stesso programma per raggiungere handler profondi (es., smb2_create → smb2_ioctl → smb2_close).

Esempio di snippet per processare un buffer di risposta (saltando i +4B della lunghezza PDU NetBIOS) e memorizzare gli ID:
```c
// process response. does not contain +4B PDU length
void process_buffer(int msg_no, const char *buffer, size_t received) {
uint16_t cmd_rsp = u16((const uint8_t *)(buffer + CMD_OFFSET));
switch (cmd_rsp) {
case SMB2_TREE_CONNECT:
if (received >= TREE_ID_OFFSET + sizeof(uint32_t))
tree_id = u32((const uint8_t *)(buffer + TREE_ID_OFFSET));
break;
case SMB2_SESS_SETUP:
// first session setup response carries session_id
if (msg_no == 0x01 && received >= SESSION_ID_OFFSET + sizeof(uint64_t))
session_id = u64((const uint8_t *)(buffer + SESSION_ID_OFFSET));
break;
case SMB2_CREATE:
if (received >= CREATE_VFID_OFFSET + sizeof(uint64_t)) {
persistent_file_id = u64((const uint8_t *)(buffer + CREATE_PFID_OFFSET));
volatile_file_id   = u64((const uint8_t *)(buffer + CREATE_VFID_OFFSET));
}
break;
default:
break;
}
}
```
Suggerimenti
- Mantieni un processo fuzzer unico che condivide autenticazione/stato: migliore stabilità e copertura con ksmbd’s global/session tables. syzkaller comunque inietta concorrenza marcando le ops come async, rieseguendole internamente.
- La funzionalità sperimentale reset_acc_state di Syzkaller può resettare lo stato globale ma può introdurre un forte rallentamento. Preferisci la stabilità e concentra il fuzzing.

---

## Generazione basata su grammatica SMB2 (PDUs validi)
Mappa le strutture SMB2 delle Microsoft Open Specifications in una fuzzer grammar in modo che il tuo generatore produca PDUs strutturalmente validi, che raggiungano sistematicamente i dispatchers e gli IOCTL handlers.

Esempio (SMB2 IOCTL request):
```
smb2_ioctl_req {
Header_Prefix           SMB2Header_Prefix
Command                 const[0xb, int16]
Header_Suffix           SMB2Header_Suffix
StructureSize           const[57, int16]
Reserved                const[0, int16]
CtlCode                 union_control_codes
PersistentFileId        const[0x4, int64]
VolatileFileId          const[0x0, int64]
InputOffset             offsetof[Input, int32]
InputCount              bytesize[Input, int32]
MaxInputResponse        const[65536, int32]
OutputOffset            offsetof[Output, int32]
OutputCount             len[Output, int32]
MaxOutputResponse       const[65536, int32]
Flags                   int32[0:1]
Reserved2               const[0, int32]
Input                   array[int8]
Output                  array[int8]
} [packed]
```
Questo stile impone dimensioni/offset corretti delle strutture e migliora drasticamente la copertura rispetto alla blind mutation.

---

## Fuzzing guidato con focus_areas
Usa l'opzione sperimentale focus_areas di syzkaller’s per assegnare un peso maggiore a funzioni/file specifici che attualmente hanno una copertura debole. Esempio JSON:
```json
{
"focus_areas": [
{"filter": {"functions": ["smb_check_perm_dacl"]}, "weight": 20.0},
{"filter": {"files": ["^fs/smb/server/"]}, "weight": 2.0},
{"weight": 1.0}
]
}
```
Questo aiuta a costruire ACL valide che colpiscono i percorsi aritmetici/overflow in smbacl.c. Ad esempio, un Security Descriptor malevolo con un dacloffset sovradimensionato riproduce un integer-overflow.

Costruttore del reproducer (Python minimale):
```python
def build_sd():
import struct
sd = bytearray(0x14)
sd[0x00] = 0x00; sd[0x01] = 0x00
struct.pack_into('<H', sd, 0x02, 0x0001)
struct.pack_into('<I', sd, 0x04, 0x78)
struct.pack_into('<I', sd, 0x08, 0x00)
struct.pack_into('<I', sd, 0x0C, 0x10000)
struct.pack_into('<I', sd, 0x10, 0xFFFFFFFF)  # dacloffset
while len(sd) < 0x78:
sd += b'A'
sd += b"\x01\x01\x00\x00\x00\x00\x00\x00"  # minimal DACL
sd += b"\xCC" * 64
return bytes(sd)
```
---

## Superare i plateau di copertura con ANYBLOB
syzkaller’s anyTypes (ANYBLOB/ANYRES) consentono di ridurre strutture complesse a blob che mutano in modo generico. Inizializza un nuovo corpus a partire da pcaps SMB pubblici e converti i payloads in programmi syzkaller che chiamano la tua pseudo-syscall (ad es., syz_ksmbd_send_req):
```bash
# Extract SMB payloads to JSON
# tshark -r smb2_dac_sample.pcap -Y "smb || smb2" -T json -e tcp.payload > packets.json
```

```python
import json, os
os.makedirs("corpus", exist_ok=True)

with open("packets.json") as f:
data = json.load(f)
# adjust indexing to your tshark JSON structure
packets = [e["_source"]["layers"]["tcp.payload"] for e in data]

for i, pkt in enumerate(packets):
pdu = pkt[0]
pdu_size = len(pdu) // 2  # hex string length → bytes
with open(f"corpus/packet_{i:03d}.txt", "w") as f:
f.write(
f"syz_ksmbd_send_req(&(&(0x7f0000000340))=ANY=[@ANYBLOB=\"{pdu}\"], {hex(pdu_size)}, 0x0, 0x0)"
)
```
Questo dà il via all'esplorazione e può attivare immediatamente UAFs (ad es., in ksmbd_sessions_deregister), aumentando nel contempo la copertura di qualche percento.

---

## Sanitizers: Oltre KASAN
- KASAN rimane il rilevatore principale per heap bugs (UAF/OOB).
- KCSAN spesso produce falsi positivi o data races di bassa severità in questo target.
- UBSAN/KUBSAN possono intercettare errori di declared-bounds che KASAN non rileva a causa della semantica degli indici di array. Esempio:
```c
id = le32_to_cpu(psid->sub_auth[psid->num_subauth - 1]);
struct smb_sid {
__u8 revision; __u8 num_subauth; __u8 authority[NUM_AUTHS];
__le32 sub_auth[SID_MAX_SUB_AUTHORITIES]; /* sub_auth[num_subauth] */
} __attribute__((packed));
```
Impostare num_subauth = 0 provoca una lettura OOB in-struct di sub_auth[-1], rilevata dalle declared-bounds checks di UBSAN.

---

## Note su throughput e parallelismo
- Un singolo processo fuzzer (shared auth/state) tende a essere significativamente più stabile per ksmbd e comunque mette in luce races/UAFs grazie all'async executor interno di syzkaller.
- Con più VM è comunque possibile raggiungere centinaia di comandi SMB/secondo complessivi. La copertura a livello di funzione è intorno al ~60% di fs/smb/server e ~70% di smb2pdu.c, sebbene la copertura delle state-transition sia sottorappresentata da tali metriche.

---

## Checklist pratica
- Abilitare durable handles, leases, multi-channel, oplocks e VFS objects in ksmbd.
- Consentire guest e map-to-guest; accettare NTLMv2. Patchare i credit limits e aumentare max connections per la stabilità del fuzzer.
- Costruire un stateful harness che cachia SessionId/TreeID/FileIDs e concateni create → ioctl → close.
- Usare una grammar per SMB2 PDUs per mantenere la validità strutturale.
- Usare focus_areas per dare più peso alle funzioni poco coperte (es. i percorsi in smbacl.c come smb_check_perm_dacl).
- Seed con ANYBLOB preso da pcaps reali per sbloccare plateau; impacchettare i seed con syz-db per il riutilizzo.
- Eseguire con KASAN + UBSAN; triage accurato dei report declared-bounds di UBSAN.

---

## Riferimenti
- Doyensec – ksmbd Fuzzing (Part 2): https://blog.doyensec.com/2025/09/02/ksmbd-2.html
- syzkaller: https://github.com/google/syzkaller
- ANYBLOB/anyTypes (commit 9fe8aa4): https://github.com/google/syzkaller/commit/9fe8aa4
- Async executor change (commit fd8caa5): https://github.com/google/syzkaller/commit/fd8caa5
- syz-db: https://github.com/google/syzkaller/tree/master/tools/syz-db
- KASAN: https://docs.kernel.org/dev-tools/kasan.html
- UBSAN/KUBSAN: https://docs.kernel.org/dev-tools/ubsan.html
- KCSAN: https://docs.kernel.org/dev-tools/kcsan.html
- Microsoft Open Specifications (SMB): https://learn.microsoft.com/openspecs/
- Wireshark Sample Captures: https://wiki.wireshark.org/SampleCaptures
- Background reading: pwning.tech “Tickling ksmbd: fuzzing SMB in the Linux kernel”; Dongliang Mu’s syzkaller notes

{{#include ../../banners/hacktricks-training.md}}
