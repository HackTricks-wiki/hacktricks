# ksmbd Attack Surface & SMB2/SMB3 Protocol Fuzzing (syzkaller)

{{#include ../../banners/hacktricks-training.md}}

## Overview
Bu sayfa, syzkaller kullanarak Linux çekirdek içi SMB sunucusu (ksmbd) için uygulanabilir ve fuzz tekniklerini soyutlar. Yapılandırma yoluyla protokol saldırı yüzeyini genişletmeye, SMB2 işlemlerini zincirleyebilen durumlu bir harness oluşturmaya, dilbilgisel olarak geçerli PDU'lar üretmeye, mutasyonları zayıf kapsanan kod yollarına yönlendirmeye ve syzkaller özelliklerinden (focus_areas ve ANYBLOB gibi) yararlanmaya odaklanır. Orijinal araştırma belirli CVE'leri sıralasa da, burada yeniden kullanılabilir metodoloji ve kendi kurulumlarınıza uyarlayabileceğiniz somut kesitleri vurguluyoruz.

Hedef kapsam: SMB2/SMB3 over TCP. Harness'i basit tutmak için Kerberos ve RDMA kasıtlı olarak kapsam dışıdır.

---

## Expand ksmbd Attack Surface via Configuration
Varsayılan olarak, minimal bir ksmbd kurulum server'ın büyük bölümlerini test edilmemiş bırakır. Sunucuyu ek ayrıştırıcılar/işleyiciler üzerinden çalıştırmak ve daha derin kod yollarına ulaşmak için aşağıdaki özellikleri etkinleştirin:

- Global düzey
- Durable handles
- Server multi-channel
- SMB2 leases
- Paylaşım bazlı (Per-share-level)
- Oplocks (varsayılan olarak açık)
- VFS objects

Bunları etkinleştirmek, şu modüllerde daha fazla yürütme sağlar:
- smb2pdu.c (command parsing/dispatch)
- ndr.c (NDR encode/decode)
- oplock.c (oplock request/break)
- smbacl.c (ACL parsing/enforcement)
- vfs.c (VFS ops)
- vfs_cache.c (lookup cache)

Notlar
- Tam seçenekler dağıtımınızın ksmbd userspace'ine (ksmbd-tools) bağlıdır. Durable handles, leases, oplocks ve VFS object'leri etkinleştirmek için /etc/ksmbd/ksmbd.conf ve paylaşıma özel bölümleri inceleyin.
- Multi-channel ve durable handles, durum makinelerini ve ömürleri değiştirir; çoğunlukla eşzamanlılık altında UAF/refcount/OOB hatalarını su yüzüne çıkarırlar.

---

## Authentication and Rate-Limiting Adjustments for Fuzzing
SMB3 geçerli bir session gerektirir. Harness'lerde Kerberos uygulamak karmaşıktır, bu yüzden fuzz için NTLM/guest tercih edin:

- Guest erişimine izin verin ve map to guest = bad user olarak ayarlayın ki bilinmeyen kullanıcılar GUEST'e düşsün.
- NTLMv2'yi kabul edin (devre dışıysa policy'yi patch'leyin). Bu, el sıkışmayı basit tutarken SMB3 kod yollarını çalıştırır.
- Deneyler sırasında sıkı credit kontrollerini patch'leyin (CVE-2024-50285 için yapılan sertleştirme aynı anda-op crediting'i daha sıkı hale getirmişti). Aksi halde rate-limitler fuzzed dizileri çok erken reddedebilir.
- Yüksek verimli fuzzing sırasında erken reddeleri önlemek için max connections sayısını (ör. 65536) arttırın.

Uyarı: Bu gevşetmeler sadece fuzz için uygulanmalıdır. Bu ayarlarla production'a deploy etmeyin.

---

## Stateful Harness: Extract Resources and Chain Requests
SMB stateful'dır: birçok istek önceki cevaplar tarafından döndürülen tanımlayıcılara (SessionId, TreeID, FileID çiftleri) bağlıdır. Harness'iniz, cevapları parse etmeli ve aynı program içinde ID'leri yeniden kullanarak derin işleyicilere ulaşmalıdır (ör. smb2_create → smb2_ioctl → smb2_close).

Örnek, bir response buffer'ı işlemek (ilk +4B NetBIOS PDU length atlanarak) ve ID'leri cache'lemek için bir snippet:
```c
// process response. does not contain +4B PDU length
void process_buffer(int msg_no, const char *buffer, size_t received) {
uint16_t cmd_rsp = u16((const uint8_t *)(buffer + CMD_OFFSET));
switch (cmd_rsp) {
case SMB2_TREE_CONNECT:
if (received >= TREE_ID_OFFSET + sizeof(uint32_t))
tree_id = u32((const uint8_t *)(buffer + TREE_ID_OFFSET));
break;
case SMB2_SESS_SETUP:
// first session setup response carries session_id
if (msg_no == 0x01 && received >= SESSION_ID_OFFSET + sizeof(uint64_t))
session_id = u64((const uint8_t *)(buffer + SESSION_ID_OFFSET));
break;
case SMB2_CREATE:
if (received >= CREATE_VFID_OFFSET + sizeof(uint64_t)) {
persistent_file_id = u64((const uint8_t *)(buffer + CREATE_PFID_OFFSET));
volatile_file_id   = u64((const uint8_t *)(buffer + CREATE_VFID_OFFSET));
}
break;
default:
break;
}
}
```
İpuçları
- Tek bir fuzzer sürecinin kimlik doğrulama/durumu paylaşmasını sağlayın: ksmbd’s global/session tables ile daha iyi stabilite ve kapsama elde edilir. syzkaller hâlâ ops'ları async olarak işaretleyerek concurrency enjekte eder; dahili olarak yeniden çalıştırır.
- Syzkaller’s experimental reset_acc_state global state'i sıfırlayabilir ancak ciddi yavaşlamaya neden olabilir. Stabiliteyi tercih edin ve fuzzing'e odaklanın.

---

## Gramer-Tabanlı SMB2 Üretimi (Geçerli PDUs)
Microsoft Open Specifications içindeki SMB2 yapılarını bir fuzzer grammar'ına çevirin, böylece generator'ünüz yapısal olarak geçerli PDUs üretir ve bu PDUs sistematik olarak dispatchers ve IOCTL handlers'a ulaşır.

Örnek (SMB2 IOCTL request):
```
smb2_ioctl_req {
Header_Prefix           SMB2Header_Prefix
Command                 const[0xb, int16]
Header_Suffix           SMB2Header_Suffix
StructureSize           const[57, int16]
Reserved                const[0, int16]
CtlCode                 union_control_codes
PersistentFileId        const[0x4, int64]
VolatileFileId          const[0x0, int64]
InputOffset             offsetof[Input, int32]
InputCount              bytesize[Input, int32]
MaxInputResponse        const[65536, int32]
OutputOffset            offsetof[Output, int32]
OutputCount             len[Output, int32]
MaxOutputResponse       const[65536, int32]
Flags                   int32[0:1]
Reserved2               const[0, int32]
Input                   array[int8]
Output                  array[int8]
} [packed]
```
Bu stil, yapı boyutları/ofsetlerinin doğru olmasını zorlar ve kör mutasyona kıyasla kapsamı önemli ölçüde iyileştirir.

---

## Directed Fuzzing With focus_areas
syzkaller’s deneysel focus_areas özelliğini, halihazırda zayıf kapsama sahip belirli fonksiyonlar/dosyalar için ağırlık vermek üzere kullanın. Örnek JSON:
```json
{
"focus_areas": [
{"filter": {"functions": ["smb_check_perm_dacl"]}, "weight": 20.0},
{"filter": {"files": ["^fs/smb/server/"]}, "weight": 2.0},
{"weight": 1.0}
]
}
```
Bu, smbacl.c içindeki arithmetic/overflow yollarına ulaşan geçerli ACLs'leri oluşturmaya yardımcı olur. Örneğin, aşırı büyük bir dacloffset içeren kötü niyetli bir Security Descriptor bir integer-overflow'u yeniden üretir.

Reproducer oluşturucu (minimal Python):
```python
def build_sd():
import struct
sd = bytearray(0x14)
sd[0x00] = 0x00; sd[0x01] = 0x00
struct.pack_into('<H', sd, 0x02, 0x0001)
struct.pack_into('<I', sd, 0x04, 0x78)
struct.pack_into('<I', sd, 0x08, 0x00)
struct.pack_into('<I', sd, 0x0C, 0x10000)
struct.pack_into('<I', sd, 0x10, 0xFFFFFFFF)  # dacloffset
while len(sd) < 0x78:
sd += b'A'
sd += b"\x01\x01\x00\x00\x00\x00\x00\x00"  # minimal DACL
sd += b"\xCC" * 64
return bytes(sd)
```
---

## ANYBLOB ile Kapsam Platolarını Aşmak
syzkaller’in anyTypes (ANYBLOB/ANYRES), karmaşık yapıları genel olarak mutasyon geçirebilen blob'lara dönüştürmeye izin verir. Kamuya açık SMB pcaps'lerinden yeni bir corpus oluşturun ve payload'ları pseudo-syscall'inizi çağıran syzkaller programlarına dönüştürün (ör., syz_ksmbd_send_req):
```bash
# Extract SMB payloads to JSON
# tshark -r smb2_dac_sample.pcap -Y "smb || smb2" -T json -e tcp.payload > packets.json
```

```python
import json, os
os.makedirs("corpus", exist_ok=True)

with open("packets.json") as f:
data = json.load(f)
# adjust indexing to your tshark JSON structure
packets = [e["_source"]["layers"]["tcp.payload"] for e in data]

for i, pkt in enumerate(packets):
pdu = pkt[0]
pdu_size = len(pdu) // 2  # hex string length → bytes
with open(f"corpus/packet_{i:03d}.txt", "w") as f:
f.write(
f"syz_ksmbd_send_req(&(&(0x7f0000000340))=ANY=[@ANYBLOB=\"{pdu}\"], {hex(pdu_size)}, 0x0, 0x0)"
)
```
This jump-starts exploration and can immediately trigger UAFs (e.g., in ksmbd_sessions_deregister) while lifting coverage a few percent.

---

## Sanitizers: Beyond KASAN
- KASAN, heap hataları (UAF/OOB) için birincil tespit aracı olmaya devam eder.
- KCSAN genellikle bu hedefte false positives veya düşük şiddetli data races üretir.
- UBSAN/KUBSAN, array-index semantiği nedeniyle KASAN'ın kaçırdığı declared-bounds hatalarını yakalayabilir. Örnek:
```c
id = le32_to_cpu(psid->sub_auth[psid->num_subauth - 1]);
struct smb_sid {
__u8 revision; __u8 num_subauth; __u8 authority[NUM_AUTHS];
__le32 sub_auth[SID_MAX_SUB_AUTHORITIES]; /* sub_auth[num_subauth] */
} __attribute__((packed));
```
Setting num_subauth = 0 triggers an in-struct OOB read of sub_auth[-1], caught by UBSAN’s declared-bounds checks.

---

## Bant Genişliği ve Paralellik Notları
- Tek bir fuzzer process (shared auth/state), ksmbd için önemli ölçüde daha kararlı olma eğilimindedir ve syzkaller’ın dahili async executor’u sayesinde yine de races/UAFs’i ortaya çıkarır.
- Birden fazla VM ile toplamda hâlâ saniyede yüzlerce SMB komutu işleyebilirsiniz. Fonksiyon seviyesinde coverage olarak fs/smb/server’ın ~%60’ı ve smb2pdu.c’nin ~%70’i civarı ulaşılabilir; ancak state-transition kapsamı bu tür metriklerle yeterince temsil edilmez.

---

## Pratik Kontrol Listesi
- ksmbd’de durable handles, leases, multi-channel, oplocks ve VFS objects’i etkinleştirin.
- guest ve map-to-guest’e izin verin; NTLMv2’yi kabul edin. credit limits’i patch’leyin ve fuzzer stabilitesi için max connections’ı artırın.
- SessionId/TreeID/FileIDs’i cache’leyen ve create → ioctl → close zinciri kuran stateful bir harness inşa edin.
- Yapısal geçerliliği korumak için SMB2 PDUs için bir grammar kullanın.
- Zayıf kapsanan fonksiyonları overweight etmek için focus_areas kullanın (ör. smbacl.c yolları, smb_check_perm_dacl gibi).
- Plateau’ları kırmak için gerçek pcaps’ten ANYBLOB ile seedleyin; seed’leri tekrar kullanım için syz-db ile paketleyin.
- KASAN + UBSAN ile çalıştırın; UBSAN declared-bounds raporlarını dikkatle triage edin.

---

## Referanslar
- Doyensec – ksmbd Fuzzing (Part 2): https://blog.doyensec.com/2025/09/02/ksmbd-2.html
- syzkaller: https://github.com/google/syzkaller
- ANYBLOB/anyTypes (commit 9fe8aa4): https://github.com/google/syzkaller/commit/9fe8aa4
- Async executor değişikliği (commit fd8caa5): https://github.com/google/syzkaller/commit/fd8caa5
- syz-db: https://github.com/google/syzkaller/tree/master/tools/syz-db
- KASAN: https://docs.kernel.org/dev-tools/kasan.html
- UBSAN/KUBSAN: https://docs.kernel.org/dev-tools/ubsan.html
- KCSAN: https://docs.kernel.org/dev-tools/kcsan.html
- Microsoft Open Specifications (SMB): https://learn.microsoft.com/openspecs/
- Wireshark Sample Captures: https://wiki.wireshark.org/SampleCaptures
- Arka plan okumaları: pwning.tech “Tickling ksmbd: fuzzing SMB in the Linux kernel”; Dongliang Mu’s syzkaller notes

{{#include ../../banners/hacktricks-training.md}}
