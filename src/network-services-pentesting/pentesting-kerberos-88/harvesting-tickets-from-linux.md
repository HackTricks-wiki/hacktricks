# Recupero dei ticket da Linux

{{#include ../../banners/hacktricks-training.md}}

### Archiviazione delle credenziali in Linux

I sistemi Linux memorizzano le credenziali in tre tipi di cache, rispettivamente **file** (nella directory `/tmp`), **Keyring del kernel** (un segmento speciale nel kernel Linux) e **memoria del processo** (per uso single-process). La variabile **default_ccache_name** in `/etc/krb5.conf` rivela il tipo di storage in uso, con valore predefinito `FILE:/tmp/krb5cc_%{uid}` se non specificata.

MIT/Heimdal supportano anche backend aggiuntivi che dovresti cercare durante la post-exploitation:

- `DIR:/run/user/%{uid}/krb5cc` per cache multi-ticket basate su directory (predefinito di systemd-logind nelle distro moderne).
- `KEYRING:persistent:%{uid}` o `KEYRING:session` per conservare i ccaches nel keyring del kernel (`KEY_SPEC_SESSION_KEYRING`, `KEY_SPEC_USER_KEYRING`, ecc.).
- `KCM:%{uid}` quando il Kerberos Cache Manager daemon (kcm) di SSSD fa da front-end allo storage dei ticket.
- `MEMORY:unique_id` per cache locali al processo create da librerie (`gssproxy`, `sshd`, ecc.).

Ogni volta che ottieni una shell, estrai il valore di `KRB5CCNAME` da `/proc/<pid>/environ` dei demoni interessanti (es. Apache, sshd, gssproxy) per sapere quale backend di cache è in uso prima di iniziare a copiare i file.

### Enumerare le cache attive

Elenca le cache prima dell'estrazione per evitare di perdere ticket di alto valore:
```bash
$ klist -l            # list caches registered in the local keyring/KCM
$ klist -A            # show all ticket-granting tickets in the current cache
$ sudo keyctl get_persistent @u
$ sudo keyctl show `keyctl get_persistent @u`
$ sudo ls -al /tmp/krb5cc_* /run/user/*/krb5cc*
$ sudo find /proc -maxdepth 2 -name environ -exec sh -c 'tr "\0" "\n" < {} | grep -H KRB5' \;
```
La combinazione di `klist`, `keyctl` e l'ispezione di `/proc` rivela rapidamente se le credenziali risiedono in file, keyrings o KCM, permettendoti di scegliere la tecnica di dump corretta.

### Estrazione delle credenziali

Il paper del 2017, [**Kerberos Credential Thievery (GNU/Linux)**](https://www.delaat.net/rp/2016-2017/p97/report.pdf), descrive metodi per estrarre le credenziali da keyrings e processi, sottolineando il meccanismo keyring del kernel Linux per la gestione e l'archiviazione delle chiavi.

#### Panoramica sull'estrazione da keyring

La **keyctl system call**, introdotta nella versione del kernel 2.6.10, permette alle applicazioni in user space di interagire con i keyrings del kernel. Le credenziali nei keyrings sono memorizzate come componenti (principal di default e credenziali), a differenza delle ccaches su file che includono anche un header. Lo **script hercules.sh** citato nel paper dimostra come estrarre e ricostruire questi componenti in un file ccache utilizzabile per il furto di credenziali. Ricorda che le ccaches memorizzate nei keyring possono trovarsi sotto `KEYRING:persistent:%{uid}` (permanenti tra i login), `KEYRING:session` (cancellate al logout), o anche `KEY_SPEC_THREAD_KEYRING` per servizi che generano thread helper — quindi enumera sempre tutti i tipi di keyring per l'UID compromesso.

#### Flusso di lavoro manuale per KEYRING

Puoi raccogliere manualmente i ticket senza script di supporto ogni volta che `default_ccache_name` è impostato su `KEYRING:`:
```bash
$ KRING=$(keyctl get_persistent @u)
$ keyctl show $KRING                       # note the key serial of each ccache blob
$ keyctl pipe <serial> > /tmp/ccache_dump  # write raw blob to disk
$ KRB5CCNAME=/tmp/ccache_dump klist        # validate the stolen cache
```
Se sono memorizzati più principal, ripeti il passaggio `keyctl pipe` per ogni seriale, quindi converti il ccache estratto in un `.kirbi`/`.ccache` compatibile con Windows usando strumenti come `kerbtool` (vedi sotto) o `ticketConverter.py` prima di replaying su altre macchine.

#### File/DIR Cache Theft Quick Wins

Quando le credenziali sono memorizzate come cache `FILE:` o `DIR:`, semplici operazioni sui file sono di solito sufficienti:
```bash
$ sudo cp /tmp/krb5cc_1000 /tmp/websvc.ccache
$ sudo cp -r /run/user/1000/krb5cc /tmp/user1000_dircc
$ chmod 600 /tmp/*.ccache && chown attacker /tmp/*.ccache
```
Directory caches contain one file per service ticket, so compress and esfiltra the whole directory to keep TGT + TGS pairs intact. You can also point your tooling at the directory directly: `KRB5CCNAME=DIR:/tmp/user1000_dircc impacket-psexec ...`.

#### Dumping KCM-Managed Caches

Il Kerberos Cache Manager di SSSD (kcm) mette in proxy l'archiviazione delle credenziali tramite `/var/run/kcm/kcmsock` (o `/run/.heim_org.h5l.kcm-socket`) e persiste blob cifrati in `/var/lib/sss/secrets/` insieme a `.secrets.mkey`. Flusso d'attacco:

1. Individua l'uso di KCM tramite `/etc/krb5.conf` (`default_ccache_name = KCM:`) o l'output di `klist -l`.
2. Se hai UID 0 o fai parte del dominio SELinux `kcm`, enumera le cache tramite lo strumento di gestione:
```bash
$ sudo kcm_ctl list                 # lists UID + cache IDs handled by kcm
$ sudo kcm_ctl get 1000 0 > /tmp/1000.kcm.ccache
$ KRB5CCNAME=/tmp/1000.kcm.ccache klist
```
3. Approccio offline: copiare `/var/lib/sss/secrets/secrets.ldb` e `/var/lib/sss/secrets/.secrets.mkey`, quindi eseguire `SSSDKCMExtractor` (o PoC simili) per decrittare e riassemblare i ccaches senza toccare il socket live. Questo è particolarmente utile in ambito forense o quando socket ACLs ti bloccano ma l'accesso al disco è possibile.

Poiché il kcm daemon rispetta gli UID-based ACLs imposti da SSSD, di solito è necessario ottenere privilege escalation a root (o compromettere `sssd_kcm`), ma una volta ottenuto puoi estrarre il TGT di ogni utente in pochi secondi.

### Strumenti per l'estrazione dei ticket

Automatizzare i passaggi sopra riduce gli errori e fornisce materiale di ticket cross-platform che puoi riprodurre usando tooling Windows.

#### Tickey

Sull'onda dei principi dello **hercules.sh script**, lo strumento [**tickey**](https://github.com/TarlogicSecurity/tickey) è specificamente progettato per estrarre ticket dai keyrings, eseguito tramite `/tmp/tickey -i`. Enumera i kernel keyrings, ricostruisce i ccaches serializzati e scrive file cache compatibili MIT che puoi immediatamente fornire a `klist`, `impacket-*`, o `kerberoast`.

#### Kerbtool

[**kerbtool**](https://github.com/jfjallid/kerbtool) è una moderna utility in Go che gira nativamente su Linux e può analizzare, convertire e richiedere Kerberos tickets. Due casi d'uso pratici quando si raccolgono ticket da macchine Linux:
```bash
# Convert a stolen MIT ccache into a .kirbi usable by Windows tooling
$ ./kerbtool --convert --in /tmp/websvc.ccache --out websvc.kirbi

# Use an extracted cache to request additional TGS tickets without touching the victim again
$ KRB5CCNAME=/tmp/websvc.ccache ./kerbtool --ask --spn cifs/fileserver.lab.local
```
Avere sia tickey che kerbtool sul tuo implant host ti permette di muoverti senza soluzione di continuità tra Linux, Windows e cross-platform Kerberos attack chains.

## Riferimenti

- [**https://www.tarlogic.com/en/blog/how-to-attack-kerberos/**](https://www.tarlogic.com/en/blog/how-to-attack-kerberos/)
- [**https://docs.pagure.org/sssd.sssd/design_pages/kcm.html**](https://docs.pagure.org/sssd.sssd/design_pages/kcm.html)
- [**https://github.com/jfjallid/kerbtool**](https://github.com/jfjallid/kerbtool)

{{#include ../../banners/hacktricks-training.md}}
