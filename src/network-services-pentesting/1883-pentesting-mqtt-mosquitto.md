# 1883 - Pentesting MQTT (Mosquitto)

{{#include ../banners/hacktricks-training.md}}

## Informations de base

**MQ Telemetry Transport (MQTT)** est connu comme un **protocole de messagerie publish/subscribe** qui se distingue par son extrême simplicité et légèreté. Ce protocole est spécifiquement conçu pour des environnements où les appareils ont des capacités limitées et fonctionnent sur des réseaux caractérisés par une faible bande passante, une latence élevée ou des connexions peu fiables. Les objectifs principaux de MQTT incluent la minimisation de l'utilisation de la bande passante réseau et la réduction de la demande sur les ressources des appareils. De plus, il vise à maintenir une communication fiable et à fournir un certain niveau d'assurance de livraison. Ces objectifs rendent MQTT exceptionnellement adapté au domaine en pleine expansion de la **communication machine à machine (M2M)** et de l'**Internet des objets (IoT)**, où il est essentiel de connecter efficacement une myriade d'appareils. De plus, MQTT est très bénéfique pour les applications mobiles, où la conservation de la bande passante et de la durée de vie de la batterie est cruciale.

**Port par défaut :** 1883
```
PORT     STATE SERVICE                 REASON
1883/tcp open  mosquitto version 1.4.8 syn-ack
```
## Inspection du trafic

Lorsque un paquet **CONNECT** est reçu par les brokers MQTT, un paquet **CONNACK** est renvoyé. Ce paquet contient un code de retour qui est crucial pour comprendre l'état de la connexion. Un code de retour de **0x00** signifie que les identifiants ont été acceptés, signifiant une connexion réussie. D'autre part, un code de retour de **0x05** signale que les identifiants sont invalides, empêchant ainsi la connexion.

Par exemple, si le broker rejette la connexion en raison d'identifiants invalides, le scénario ressemblerait à ceci :
```
{
"returnCode": "0x05",
"description": "Connection Refused, not authorized"
}
```
![](<../images/image (976).png>)

### [**Brute-Force MQTT**](../generic-hacking/brute-force.md#mqtt)

## Pentesting MQTT

**L'authentification est totalement optionnelle** et même si l'authentification est effectuée, **le chiffrement n'est pas utilisé par défaut** (les identifiants sont envoyés en texte clair). Des attaques MITM peuvent toujours être exécutées pour voler des mots de passe.

Pour se connecter à un service MQTT, vous pouvez utiliser : [https://github.com/bapowell/python-mqtt-client-shell](https://github.com/bapowell/python-mqtt-client-shell) et vous abonner à tous les sujets en faisant :
```
> connect (NOTICE that you need to indicate before this the params of the connection, by default 127.0.0.1:1883)
> subscribe "#" 1
> subscribe "$SYS/#"
```
Vous pouvez également utiliser [**https://github.com/akamai-threat-research/mqtt-pwn**](https://github.com/akamai-threat-research/mqtt-pwn)

Vous pouvez également utiliser :
```bash
apt-get install mosquitto mosquitto-clients
mosquitto_sub -t 'test/topic' -v #Subscribe to 'test/topic'
mosquitto_sub -h <host-ip> -t "#" -v #Subscribe to ALL topics.
```
Ou vous pourriez **exécuter ce code pour essayer de vous connecter à un service MQTT sans authentification, vous abonner à tous les sujets et les écouter** :
```python
#This is a modified version of https://github.com/Warflop/IOT-MQTT-Exploit/blob/master/mqtt.py
import paho.mqtt.client as mqtt
import time
import os

HOST = "127.0.0.1"
PORT = 1883

def on_connect(client, userdata, flags, rc):
client.subscribe('#', qos=1)
client.subscribe('$SYS/index.html#')

def on_message(client, userdata, message):
print('Topic: %s | QOS: %s  | Message: %s' % (message.topic, message.qos, message.payload))

def main():
client = mqtt.Client()
client.on_connect = on_connect
client.on_message = on_message
client.connect(HOST, PORT)
client.loop_start()
#time.sleep(10)
#client.loop_stop()

if __name__ == "__main__":
main()
```
## Plus d'informations

from here: [https://morphuslabs.com/hacking-the-iot-with-mqtt-8edaf0d07b9b](https://morphuslabs.com/hacking-the-iot-with-mqtt-8edaf0d07b9b)

### Le modèle Publish/Subscribe <a href="#b667" id="b667"></a>

Le modèle publish/subscribe est composé de :

- **Publisher** : publie un message sur un (ou plusieurs) sujet(s) dans le broker.
- **Subscriber** : s'abonne à un (ou plusieurs) sujet(s) dans le broker et reçoit tous les messages envoyés par le publisher.
- **Broker** : achemine tous les messages des publishers vers les subscribers.
- **Topic** : consiste en un ou plusieurs niveaux séparés par une barre oblique (par exemple, /smartshouse/livingroom/temperature).

### Format de paquet <a href="#f15a" id="f15a"></a>

Chaque paquet MQTT contient un en-tête fixe (Figure 02).Figure 02 : En-tête fixe

![https://miro.medium.com/max/838/1*k6RkAHEk0576geQGUcKSTA.png](https://miro.medium.com/max/838/1*k6RkAHEk0576geQGUcKSTA.png)

### Types de paquets

- CONNECT (1) : Initié par le client pour demander une connexion au serveur.
- CONNACK (2) : L'accusé de réception du serveur d'une connexion réussie.
- PUBLISH (3) : Utilisé pour envoyer un message du client au serveur ou vice versa.
- PUBACK (4) : Accusé de réception d'un paquet PUBLISH.
- PUBREC (5) : Partie d'un protocole de livraison de message garantissant que le message est reçu.
- PUBREL (6) : Assurance supplémentaire dans la livraison de message, indiquant une libération de message.
- PUBCOMP (7) : Dernière partie du protocole de livraison de message, indiquant l'achèvement.
- SUBSCRIBE (8) : Demande d'un client d'écouter les messages d'un sujet.
- SUBACK (9) : L'accusé de réception du serveur d'une demande de SUBSCRIBE.
- UNSUBSCRIBE (10) : Demande d'un client d'arrêter de recevoir des messages d'un sujet.
- UNSUBACK (11) : La réponse du serveur à une demande d'UNSUBSCRIBE.
- PINGREQ (12) : Un message de cœur envoyé par le client.
- PINGRESP (13) : Réponse du serveur au message de cœur.
- DISCONNECT (14) : Initié par le client pour terminer la connexion.
- Deux valeurs, 0 et 15, sont marquées comme réservées et leur utilisation est interdite.

## Shodan

- `port:1883 MQTT`

{{#include ../banners/hacktricks-training.md}}
