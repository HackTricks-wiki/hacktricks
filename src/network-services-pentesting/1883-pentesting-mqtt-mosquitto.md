# 1883 - Pentesting MQTT (Mosquitto)

{{#include ../banners/hacktricks-training.md}}

## 基本信息

**MQ Telemetry Transport (MQTT)** 被称为 **发布/订阅消息协议**，以其极简和轻量化而著称。该协议专门为设备能力有限且在低带宽、高延迟或不可靠连接的网络环境中运行而量身定制。MQTT的核心目标包括最小化网络带宽的使用和减少对设备资源的需求。此外，它旨在保持可靠的通信并提供一定程度的交付保证。这些目标使MQTT特别适合于快速发展的 **机器对机器 (M2M) 通信** 和 **物联网 (IoT)** 领域，在这些领域中，高效连接大量设备至关重要。此外，MQTT对移动应用程序也非常有利，因为节省带宽和电池寿命至关重要。

**默认端口：** 1883
```
PORT     STATE SERVICE                 REASON
1883/tcp open  mosquitto version 1.4.8 syn-ack
```
## Inspecting the traffic

当 MQTT 代理收到 **CONNECT** 数据包时，会发送回 **CONNACK** 数据包。该数据包包含一个返回代码，这对于理解连接状态至关重要。返回代码 **0x00** 表示凭据已被接受，标志着连接成功。另一方面，返回代码 **0x05** 表示凭据无效，从而阻止连接。

例如，如果代理因凭据无效而拒绝连接，则场景可能如下所示：
```
{
"returnCode": "0x05",
"description": "Connection Refused, not authorized"
}
```
![](<../images/image (976).png>)

### [**暴力破解 MQTT**](../generic-hacking/brute-force.md#mqtt)

## 渗透测试 MQTT

**身份验证是完全可选的**，即使进行身份验证，**默认情况下不使用加密**（凭据以明文发送）。仍然可以执行中间人攻击以窃取密码。

要连接到 MQTT 服务，可以使用：[https://github.com/bapowell/python-mqtt-client-shell](https://github.com/bapowell/python-mqtt-client-shell) 并通过以下方式订阅所有主题：
```
> connect (NOTICE that you need to indicate before this the params of the connection, by default 127.0.0.1:1883)
> subscribe "#" 1
> subscribe "$SYS/#"
```
您还可以使用 [**https://github.com/akamai-threat-research/mqtt-pwn**](https://github.com/akamai-threat-research/mqtt-pwn)

您还可以使用：
```bash
apt-get install mosquitto mosquitto-clients
mosquitto_sub -t 'test/topic' -v #Subscribe to 'test/topic'
mosquitto_sub -h <host-ip> -t "#" -v #Subscribe to ALL topics.
```
或者你可以**运行这段代码尝试连接到一个没有身份验证的MQTT服务，订阅所有主题并监听它们**：
```python
#This is a modified version of https://github.com/Warflop/IOT-MQTT-Exploit/blob/master/mqtt.py
import paho.mqtt.client as mqtt
import time
import os

HOST = "127.0.0.1"
PORT = 1883

def on_connect(client, userdata, flags, rc):
client.subscribe('#', qos=1)
client.subscribe('$SYS/index.html#')

def on_message(client, userdata, message):
print('Topic: %s | QOS: %s  | Message: %s' % (message.topic, message.qos, message.payload))

def main():
client = mqtt.Client()
client.on_connect = on_connect
client.on_message = on_message
client.connect(HOST, PORT)
client.loop_start()
#time.sleep(10)
#client.loop_stop()

if __name__ == "__main__":
main()
```
### 发布/订阅模式 <a href="#b667" id="b667"></a>

发布/订阅模型由以下组成：

- **发布者**：向代理中的一个（或多个）主题发布消息。
- **订阅者**：订阅代理中的一个（或多个）主题，并接收来自发布者的所有消息。
- **代理**：将所有消息从发布者路由到订阅者。
- **主题**：由一个或多个用斜杠分隔的级别组成（例如，/smartshouse/livingroom/temperature）。

### 数据包格式 <a href="#f15a" id="f15a"></a>

每个MQTT数据包包含一个固定头部（图02）。图02：固定头部

![https://miro.medium.com/max/838/1*k6RkAHEk0576geQGUcKSTA.png](https://miro.medium.com/max/838/1*k6RkAHEk0576geQGUcKSTA.png)

### 数据包类型

- CONNECT (1)：由客户端发起，请求与服务器建立连接。
- CONNACK (2)：服务器对成功连接的确认。
- PUBLISH (3)：用于将消息从客户端发送到服务器或反之。
- PUBACK (4)：对PUBLISH数据包的确认。
- PUBREC (5)：消息传递协议的一部分，确保消息被接收。
- PUBREL (6)：进一步确保消息传递，指示消息释放。
- PUBCOMP (7)：消息传递协议的最后部分，指示完成。
- SUBSCRIBE (8)：客户端请求监听来自某个主题的消息。
- SUBACK (9)：服务器对SUBSCRIBE请求的确认。
- UNSUBSCRIBE (10)：客户端请求停止接收来自某个主题的消息。
- UNSUBACK (11)：服务器对UNSUBSCRIBE请求的响应。
- PINGREQ (12)：客户端发送的心跳消息。
- PINGRESP (13)：服务器对心跳消息的响应。
- DISCONNECT (14)：由客户端发起以终止连接。
- 两个值，0和15，被标记为保留，禁止使用。

## Shodan

- `port:1883 MQTT`

{{#include ../banners/hacktricks-training.md}}
