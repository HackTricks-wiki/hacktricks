# 1883 - Pentesting MQTT (Mosquitto)

{{#include ../banners/hacktricks-training.md}}

## 기본 정보

**MQ Telemetry Transport (MQTT)**는 극도로 단순하고 경량화된 것으로 돋보이는 **게시/구독 메시징 프로토콜**로 알려져 있습니다. 이 프로토콜은 자원이 제한된 장치들이 저대역폭, 높은 지연, 또는 신뢰할 수 없는 연결로 특징지어지는 네트워크에서 동작하는 환경에 맞춰 특별히 설계되었습니다. MQTT의 핵심 목표는 네트워크 대역폭 사용을 최소화하고 장치 자원 소모를 줄이는 것입니다. 또한 신뢰성 있는 통신을 유지하고 일정 수준의 전달 보장을 제공하는 것을 목표로 합니다. 이러한 목표들 때문에 MQTT는 수많은 장치를 효율적으로 연결해야 하는 **장치 간 통신 (M2M)** 및 **사물인터넷 (IoT)** 분야에 특히 적합합니다. 더불어, 대역폭과 배터리 수명 보존이 중요한 모바일 애플리케이션에도 MQTT는 매우 유용합니다.

**기본 포트:** 1883
```
PORT     STATE SERVICE                 REASON
1883/tcp open  mosquitto version 1.4.8 syn-ack
```
## 트래픽 검사

MQTT 브로커가 **CONNECT** 패킷을 수신하면 **CONNACK** 패킷을 응답으로 보냅니다. 이 패킷은 연결 상태를 파악하는 데 중요한 리턴 코드를 포함합니다. 리턴 코드가 **0x00**이면 자격 증명이 수락되어 연결이 성공했음을 의미합니다. 반면, 리턴 코드가 **0x05**이면 자격 증명이 유효하지 않아 연결이 거부되었음을 나타냅니다.

예를 들어 브로커가 자격 증명 불일치로 연결을 거부하는 경우, 상황은 대략 다음과 같습니다:
```
{
"returnCode": "0x05",
"description": "Connection Refused, not authorized"
}
```
![](<../images/image (976).png>)

### [**Brute-Force MQTT**](../generic-hacking/brute-force.md#mqtt)

## Pentesting MQTT

**인증은 완전히 선택 사항입니다** 그리고 설령 인증이 이루어지더라도 **암호화는 기본적으로 사용되지 않습니다** (자격 증명이 평문으로 전송됩니다). MITM 공격은 여전히 수행되어 비밀번호를 탈취할 수 있습니다.

To connect to a MQTT service you can use: [https://github.com/bapowell/python-mqtt-client-shell](https://github.com/bapowell/python-mqtt-client-shell) and subscribe yourself to all the topics doing:
```
> connect (NOTICE that you need to indicate before this the params of the connection, by default 127.0.0.1:1883)
> subscribe "#" 1
> subscribe "$SYS/#"
```
다음도 사용할 수 있습니다: [**https://github.com/akamai-threat-research/mqtt-pwn**](https://github.com/akamai-threat-research/mqtt-pwn)

다음도 사용할 수 있습니다:
```bash
apt-get install mosquitto mosquitto-clients
mosquitto_sub -t 'test/topic' -v #Subscribe to 'test/topic'
mosquitto_sub -h <host-ip> -t "#" -v #Subscribe to ALL topics.
```
또는 **이 코드를 실행해 인증 없이 MQTT 서비스에 연결을 시도하고 모든 토픽을 구독하여 메시지를 수신할 수 있습니다**:
```python
#This is a modified version of https://github.com/Warflop/IOT-MQTT-Exploit/blob/master/mqtt.py
import paho.mqtt.client as mqtt
import time
import os

HOST = "127.0.0.1"
PORT = 1883

def on_connect(client, userdata, flags, rc):
client.subscribe('#', qos=1)
client.subscribe('$SYS/index.html#')

def on_message(client, userdata, message):
print('Topic: %s | QOS: %s  | Message: %s' % (message.topic, message.qos, message.payload))

def main():
client = mqtt.Client()
client.on_connect = on_connect
client.on_message = on_message
client.connect(HOST, PORT)
client.loop_start()
#time.sleep(10)
#client.loop_stop()

if __name__ == "__main__":
main()
```
### The Publish/Subscribe Pattern <a href="#b667" id="b667"></a>

publish/subscribe 모델은 다음으로 구성됩니다:

- **Publisher**: 브로커의 하나(또는 여러) 토픽에 메시지를 publish합니다.
- **Subscriber**: 브로커의 하나(또는 여러) 토픽을 subscribe하고 Publisher가 보낸 모든 메시지를 수신합니다.
- **Broker**: Publisher들로부터 Subscriber들로 모든 메시지를 라우팅합니다.
- **Topic**: 슬래시로 구분된 하나 이상의 레벨로 구성됩니다(예: /smartshouse/livingroom/temperature).

### Packet Format <a href="#f15a" id="f15a"></a>

모든 MQTT 패킷은 고정 헤더를 포함합니다(Figure 02).Figure 02: Fixed Header

![https://miro.medium.com/max/838/1*k6RkAHEk0576geQGUcKSTA.png](https://miro.medium.com/max/838/1*k6RkAHEk0576geQGUcKSTA.png)

### Packet Types

- CONNECT (1): 클라이언트가 서버에 연결을 요청하기 위해 시작합니다.
- CONNACK (2): 서버가 연결 성공을 확인하여 응답합니다.
- PUBLISH (3): 클라이언트에서 서버로 또는 그 반대로 메시지를 전송할 때 사용됩니다.
- PUBACK (4): PUBLISH 패킷에 대한 확인 응답입니다.
- PUBREC (5): 메시지 수신을 보장하기 위한 전달 프로토콜의 일부입니다.
- PUBREL (6): 메시지 전달의 추가 보장을 나타내며 메시지 릴리스를 표시합니다.
- PUBCOMP (7): 메시지 전달 프로토콜의 최종 단계로, 완료를 나타냅니다.
- SUBSCRIBE (8): 클라이언트가 특정 토픽의 메시지를 수신하기 위한 요청입니다.
- SUBACK (9): SUBSCRIBE 요청에 대한 서버의 확인 응답입니다.
- UNSUBSCRIBE (10): 클라이언트가 특정 토픽의 메시지 수신을 중단하기 위한 요청입니다.
- UNSUBACK (11): UNSUBSCRIBE 요청에 대한 서버의 응답입니다.
- PINGREQ (12): 클라이언트가 보내는 하트비트 메시지입니다.
- PINGRESP (13): 하트비트 메시지에 대한 서버의 응답입니다.
- DISCONNECT (14): 클라이언트가 연결을 종료하기 위해 시작합니다.
- 값 0과 15는 예약되어 있으며 사용이 금지되어 있습니다.

## IoT MQTT ecosystem attacks: plaintext brokers and topic ACL bypass

많은 소비자용 IoT 플랫폼은 두 가지 역할에서 사용되는 MQTT 브로커를 노출합니다:
- 게이트웨이/허브 장치 — 라디오 프로토콜(e.g., BLE/LoRa/Zigbee)을 클라우드로 브리지합니다.
- 모바일 앱 또는 웹 백엔드 — “app” 토픽을 통해 장치를 제어합니다.

펜테스트 중 악용할 수 있는 일반적인 취약점:

- 비표준 포트에서의 평문 MQTT (예: TCP/8001) 사용 — MQTTS 대신 사용하는 경우. 경로 상의 관찰자는 자격증명과 제어 프레임을 모두 읽을 수 있습니다. Wireshark를 사용해 비정상 포트에서의 cleartext CONNECT/CONNACK 및 SUBSCRIBE/PUBLISH 트래픽을 찾아보세요.
- 테넌트별 topic ACL이 약하거나 없음. 토픽이 deviceId로만 네임스페이스화된 경우(예: "/tenantless/<deviceId>/tx"), 인증된 사용자가 다른 테넌트의 장치로 PUBLISH할 수 있습니다.
- 유지관리/관리 토픽을 통한 민감한 데이터 유출(예: 설정 변경 후 평문으로 방송되는 Wi‑Fi 자격증명).

예시 (플레이스홀더를 실제 값으로 교체):

잠재적으로 민감한 토픽을 알고 있는 토픽 접두사와 device ID로 subscribe:
```bash
# Using mosquitto_sub
mosquitto_sub -h <broker> -p <port> -V mqttv311 \
-i <client_id> -u <username> -P <password> \
-t "<topic_prefix>/<deviceId>/admin" -v
```
ACLs가 약할 때의 Cross-tenant control (publish to another tenant’s device topic):
```bash
mosquitto_pub -h <app-broker> -p <port> -V mqttv311 \
-i <your_client_id> -u <your_username> -P <your_password> \
-t "/ys/<victimDeviceId>/tx" \
-m '{"method":"Device.setState","params":{"state":{"power":"on"}},"targetDevice":"<victimDeviceId>"}'
```
## Shodan

- `port:1883 MQTT`
- 비표준 포트에서의 MQTT 평문 통신은 IoT에서 흔합니다. 대체 포트에서 brokers를 검색하고 protocol detection으로 확인해 보세요.

## 참고자료

- [How a $20 Smart Device Gave Me Access to Your Home](https://bishopfox.com/blog/how-a-20-smart-device-gave-me-access-to-your-home)

{{#include ../banners/hacktricks-training.md}}
