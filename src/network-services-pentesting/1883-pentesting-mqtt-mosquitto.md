# 1883 - Pentesting MQTT (Mosquitto)

{{#include ../banners/hacktricks-training.md}}

## Basiese Inligting

**MQ Telemetry Transport (MQTT)** staan bekend as 'n **publish/subscribe-boodskapprotokol** wat uitstaan vir sy uiterste eenvoud en ligtheid. Hierdie protokol is spesifiek ontwerp vir omgewings waar toestelle beperkte vermoëns het en oor netwerke werk wat gekenmerk word deur lae bandwydte, hoë latensie of onbetroubare verbindings. Die kerndoelwitte van MQTT sluit in om die gebruik van netwerkbandwydte te minimaliseer en die vraag op toestelhulpbronne te verminder. Daarbenewens poog dit om betroubare kommunikasie te handhaaf en 'n sekere vlak van afleweringsversekering te bied. Hierdie doelwitte maak MQTT uiters geskik vir die opkomende veld van **masjien-tot-masjien (M2M) kommunikasie** en die **Internet van Dinge (IoT)**, waar dit noodsaaklik is om 'n menigte toestelle doeltreffend te koppel. Verder is MQTT uiters voordelig vir mobiele toepassings, waar die bewaring van bandwydte en batterylewe kritiek is.

**Default port:** 1883
```
PORT     STATE SERVICE                 REASON
1883/tcp open  mosquitto version 1.4.8 syn-ack
```
## Inspeksie van die verkeer

Wanneer 'n **CONNECT**-pakket deur MQTT brokers ontvang word, word 'n **CONNACK**-pakket teruggestuur. Hierdie pakket bevat 'n return code wat noodsaaklik is om die connection status te verstaan. 'n return code van **0x00** beteken dat die credentials aanvaar is, wat 'n suksesvolle verbinding aandui. Aan die ander kant dui 'n return code van **0x05** aan dat die credentials ongeldig is, en sodoende die verbinding verhoed.

Byvoorbeeld, as die broker die verbinding weens ongeldig credentials verwerp, sal die scenario ongeveer soos volg lyk:
```
{
"returnCode": "0x05",
"description": "Connection Refused, not authorized"
}
```
![](<../images/image (976).png>)

### [**Brute-Force MQTT**](../generic-hacking/brute-force.md#mqtt)

## Pentesting MQTT

Authentication is heeltemal opsioneel en selfs as authentication uitgevoer word, encryption word nie standaard gebruik nie (credentials word in clear text gestuur). MITM attacks kan nog steeds uitgevoer word om wagwoorde te steel.

Om aan 'n MQTT-diens te koppel kan jy gebruik: [https://github.com/bapowell/python-mqtt-client-shell](https://github.com/bapowell/python-mqtt-client-shell) en subscribe yourself aan al die topics deur:
```
> connect (NOTICE that you need to indicate before this the params of the connection, by default 127.0.0.1:1883)
> subscribe "#" 1
> subscribe "$SYS/#"
```
Jy kan ook gebruik maak van [**https://github.com/akamai-threat-research/mqtt-pwn**](https://github.com/akamai-threat-research/mqtt-pwn)

Jy kan ook gebruik maak van:
```bash
apt-get install mosquitto mosquitto-clients
mosquitto_sub -t 'test/topic' -v #Subscribe to 'test/topic'
mosquitto_sub -h <host-ip> -t "#" -v #Subscribe to ALL topics.
```
Of jy kan ook **hierdie kode uitvoer om te probeer verbind met 'n MQTT service sonder authentication, op elke topic subscribe en daarna luister**:
```python
#This is a modified version of https://github.com/Warflop/IOT-MQTT-Exploit/blob/master/mqtt.py
import paho.mqtt.client as mqtt
import time
import os

HOST = "127.0.0.1"
PORT = 1883

def on_connect(client, userdata, flags, rc):
client.subscribe('#', qos=1)
client.subscribe('$SYS/index.html#')

def on_message(client, userdata, message):
print('Topic: %s | QOS: %s  | Message: %s' % (message.topic, message.qos, message.payload))

def main():
client = mqtt.Client()
client.on_connect = on_connect
client.on_message = on_message
client.connect(HOST, PORT)
client.loop_start()
#time.sleep(10)
#client.loop_stop()

if __name__ == "__main__":
main()
```
### The Publish/Subscribe Pattern <a href="#b667" id="b667"></a>

Die publish/subscribe-model bestaan uit:

- **Publisher**: publiseer 'n boodskap na een (of meer) topic(s) in die broker.
- **Subscriber**: teken in op een (of meer) topic(s) in die broker en ontvang al die boodskappe wat deur die publisher gestuur is.
- **Broker**: stuur al die boodskappe van die publishers na die subscribers.
- **Topic**: bestaan uit een of meer vlakke wat deur 'n voorwaartse skuinsstreep (bv., /smartshouse/livingroom/temperature) geskei word.

### Packet Format <a href="#f15a" id="f15a"></a>

Elke MQTT-pakket bevat 'n fixed header (Figure 02). Figuur 02: Fixed Header

![https://miro.medium.com/max/838/1*k6RkAHEk0576geQGUcKSTA.png](https://miro.medium.com/max/838/1*k6RkAHEk0576geQGUcKSTA.png)

### Packet Types

- CONNECT (1): Inisieer deur die kliënt om 'n verbinding met die server aan te vra.
- CONNACK (2): Die server se erkenning van 'n suksesvolle verbinding.
- PUBLISH (3): Word gebruik om 'n boodskap van die kliënt na die server te stuur of omgekeerd.
- PUBACK (4): Erkenning van 'n PUBLISH-pakket.
- PUBREC (5): Deel van 'n boodskap-afleweringsprotokol wat verseker dat die boodskap ontvang is.
- PUBREL (6): Verdere sekerstelling in boodskapaflewering, dui op die vrylating van 'n boodskap.
- PUBCOMP (7): Laaste deel van die boodskap-afleweringsprotokol wat voltooiing aandui.
- SUBSCRIBE (8): 'n Kliënt se versoek om na boodskappe vanaf 'n topic te luister.
- SUBACK (9): Die server se erkenning van 'n SUBSCRIBE-versoek.
- UNSUBSCRIBE (10): 'n Kliënt se versoek om op te hou om boodskappe vanaf 'n topic te ontvang.
- UNSUBACK (11): Die server se reaksie op 'n UNSUBSCRIBE-versoek.
- PINGREQ (12): 'n Heartbeat-boodskap wat deur die kliënt gestuur word.
- PINGRESP (13): Die server se reaksie op die heartbeat-boodskap.
- DISCONNECT (14): Inisieer deur die kliënt om die verbinding te beïndig.
- Twee waardes, 0 en 15, is as gereserveer gemerk en hul gebruik is verbode.

## IoT MQTT ecosystem attacks: plaintext brokers and topic ACL bypass

Baie verbruikers-IoT-platforms openbaar MQTT brokers wat deur twee onderskeibare rolle gebruik word:
- Gateway/hub-toestelle wat radioprotokolle (bv., BLE/LoRa/Zigbee) na die cloud oorbrug.
- Mobiele apps of web-backends wat toestelle beheer via “app” topics.

Algemene swakpunte wat jy tydens 'n pentest kan misbruik:

- Plaintext MQTT oor nie-standaard poorte (bv., TCP/8001) in plaas van MQTTS. Enige on-path waarnemer kan credentials en control frames lees. Gebruik Wireshark om cleartext CONNECT/CONNACK- en SUBSCRIBE/PUBLISH-verkeer op ongebruiklike poorte te identifiseer.
- Swak of ontbrekende per-tenant topic ACLs. As topics slegs volgens deviceId genamespaceer is (bv., "/tenantless/<deviceId>/tx"), kan enige geverifieerde gebruiker dalk PUBLISH na ander tenants se toestelle.
- Sensitiewe data-lekkasie via maintenance/admin topics (bv., Wi‑Fi credentials wat in cleartext uitgesaai word na config-wijzigings).

Examples (replace placeholders with real values):

Teken in op potensieel sensitiewe topics met bekende topic-voorvoegsels en device IDs:
```bash
# Using mosquitto_sub
mosquitto_sub -h <broker> -p <port> -V mqttv311 \
-i <client_id> -u <username> -P <password> \
-t "<topic_prefix>/<deviceId>/admin" -v
```
Kruis-tenant beheer wanneer ACLs swak is (publish na 'n ander tenant se device topic):
```bash
mosquitto_pub -h <app-broker> -p <port> -V mqttv311 \
-i <your_client_id> -u <your_username> -P <your_password> \
-t "/ys/<victimDeviceId>/tx" \
-m '{"method":"Device.setState","params":{"state":{"power":"on"}},"targetDevice":"<victimDeviceId>"}'
```
## Shodan

- `port:1883 MQTT`
- MQTT plaintext op nie-standaard poorte is algemeen in IoT. Oorweeg om na brokers op alternatiewe poorte te soek en dit met protocol detection te bevestig.

## Verwysings

- [How a $20 Smart Device Gave Me Access to Your Home](https://bishopfox.com/blog/how-a-20-smart-device-gave-me-access-to-your-home)

{{#include ../banners/hacktricks-training.md}}
