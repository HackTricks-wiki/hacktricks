# 135, 593 - Pentesting MSRPC

{{#include ../banners/hacktricks-training.md}}

## Informações Básicas

O protocolo Microsoft Remote Procedure Call (MSRPC), um modelo cliente-servidor que permite que um programa solicite um serviço de um programa localizado em outro computador sem entender os detalhes da rede, foi inicialmente derivado de software de código aberto e posteriormente desenvolvido e protegido por direitos autorais pela Microsoft.

O mapeador de endpoint RPC pode ser acessado via porta TCP e UDP 135, SMB na TCP 139 e 445 (com uma sessão nula ou autenticada), e como um serviço web na porta TCP 593.
```
135/tcp   open     msrpc         Microsoft Windows RPC
```
## Como o MSRPC funciona?

Iniciado pela aplicação cliente, o processo MSRPC envolve chamar um procedimento stub local que interage com a biblioteca de tempo de execução do cliente para preparar e transmitir a solicitação ao servidor. Isso inclui converter parâmetros em um formato padrão de Representação de Dados de Rede. A escolha do protocolo de transporte é determinada pela biblioteca de tempo de execução se o servidor for remoto, garantindo que o RPC seja entregue através da pilha de rede.

![https://0xffsec.com/handbook/images/msrpc.png](https://0xffsec.com/handbook/images/msrpc.png)

## **Identificando Serviços RPC Expostos**

A exposição de serviços RPC através de TCP, UDP, HTTP e SMB pode ser determinada consultando o serviço de localizador RPC e pontos finais individuais. Ferramentas como rpcdump facilitam a identificação de serviços RPC únicos, denotados por valores **IFID**, revelando detalhes do serviço e vinculações de comunicação:
```
D:\rpctools> rpcdump [-p port] <IP>
**IFID**: 5a7b91f8-ff00-11d0-a9b2-00c04fb6e6fc version 1.0
Annotation: Messenger Service
UUID: 00000000-0000-0000-0000-000000000000
Binding: ncadg_ip_udp:<IP>[1028]
```
O acesso ao serviço de localizador RPC é habilitado através de protocolos específicos: ncacn_ip_tcp e ncadg_ip_udp para acesso via porta 135, ncacn_np para conexões SMB e ncacn_http para comunicação RPC baseada na web. Os seguintes comandos exemplificam a utilização de módulos do Metasploit para auditar e interagir com serviços MSRPC, focando principalmente na porta 135:
```bash
use auxiliary/scanner/dcerpc/endpoint_mapper
use auxiliary/scanner/dcerpc/hidden
use auxiliary/scanner/dcerpc/management
use auxiliary/scanner/dcerpc/tcp_dcerpc_auditor
rpcdump.py <IP> -p 135
```
Todas as opções, exceto `tcp_dcerpc_auditor`, são especificamente projetadas para direcionar o MSRPC na porta 135.

#### Interfaces RPC Notáveis

- **IFID**: 12345778-1234-abcd-ef00-0123456789ab
- **Named Pipe**: `\pipe\lsarpc`
- **Descrição**: Interface LSA, usada para enumerar usuários.
- **IFID**: 3919286a-b10c-11d0-9ba8-00c04fd92ef5
- **Named Pipe**: `\pipe\lsarpc`
- **Descrição**: Interface de Serviços de Diretório LSA (DS), usada para enumerar domínios e relações de confiança.
- **IFID**: 12345778-1234-abcd-ef00-0123456789ac
- **Named Pipe**: `\pipe\samr`
- **Descrição**: Interface LSA SAMR, usada para acessar elementos públicos do banco de dados SAM (por exemplo, nomes de usuários) e realizar força bruta em senhas de usuários, independentemente da política de bloqueio de conta.
- **IFID**: 1ff70682-0a51-30e8-076d-740be8cee98b
- **Named Pipe**: `\pipe\atsvc`
- **Descrição**: Agendador de tarefas, usado para executar comandos remotamente.
- **IFID**: 338cd001-2244-31f1-aaaa-900038001003
- **Named Pipe**: `\pipe\winreg`
- **Descrição**: Serviço de registro remoto, usado para acessar e modificar o registro do sistema.
- **IFID**: 367abb81-9844-35f1-ad32-98f038001003
- **Named Pipe**: `\pipe\svcctl`
- **Descrição**: Gerenciador de controle de serviços e serviços de servidor, usado para iniciar e parar serviços remotamente e executar comandos.
- **IFID**: 4b324fc8-1670-01d3-1278-5a47bf6ee188
- **Named Pipe**: `\pipe\srvsvc`
- **Descrição**: Gerenciador de controle de serviços e serviços de servidor, usado para iniciar e parar serviços remotamente e executar comandos.
- **IFID**: 4d9f4ab8-7d1c-11cf-861e-0020af6e7c57
- **Named Pipe**: `\pipe\epmapper`
- **Descrição**: Interface DCOM, usada para força bruta em senhas e coleta de informações via WM.

### Identificando endereços IP

Usando [https://github.com/mubix/IOXIDResolver](https://github.com/mubix/IOXIDResolver), que vem da [pesquisa da Airbus](https://www.cyber.airbus.com/the-oxid-resolver-part-1-remote-enumeration-of-network-interfaces-without-any-authentication/), é possível abusar do método _**ServerAlive2**_ dentro da interface _**IOXIDResolver**_.

Esse método tem sido usado para obter informações da interface como endereço **IPv6** da caixa HTB _APT_. Veja [aqui](https://0xdf.gitlab.io/2021/04/10/htb-apt.html) para o relatório APT de 0xdf, que inclui um método alternativo usando rpcmap.py do [Impacket](https://github.com/SecureAuthCorp/impacket/) com _stringbinding_ (veja acima).

### Executando um RCE com credenciais válidas

É possível executar código remoto em uma máquina, se as credenciais de um usuário válido estiverem disponíveis usando [dcomexec.py](https://github.com/fortra/impacket/blob/master/examples/dcomexec.py) do framework impacket.

**Lembre-se de tentar com os diferentes objetos disponíveis**

- ShellWindows
- ShellBrowserWindow
- MMC20

## Porta 593

O **rpcdump.exe** do [rpctools](https://resources.oreilly.com/examples/9780596510305/tree/master/tools/rpctools) pode interagir com esta porta.

## Fuzzing Automatizado de Interfaces MSRPC

As interfaces MS-RPC expõem uma grande e muitas vezes não documentada superfície de ataque. O módulo PowerShell de código aberto [MS-RPC-Fuzzer](https://github.com/warpnet/MS-RPC-Fuzzer) baseia-se no `NtObjectManager` de James Forshaw para *criar dinamicamente* stubs de cliente RPC a partir dos metadados da interface que já estão presentes nos binários do Windows. Uma vez que um stub existe, o módulo pode bombardear cada procedimento com entradas mutadas e registrar o resultado, tornando **fuzzing em larga escala e reproduzível de endpoints RPC possível sem escrever uma única linha de IDL**.

### 1. Inventariar as interfaces
```powershell
# Import the module (download / git clone first)
Import-Module .\MS-RPC-Fuzzer.psm1

# Parse a single binary
Get-RpcServerData -Target "C:\Windows\System32\efssvc.dll" -OutPath .\output

# Or crawl the whole %SystemRoot%\System32 directory
Get-RpcServerData -OutPath .\output
```
`Get-RpcServerData` extrairá o UUID, versão, strings de ligação (named-pipe / TCP / HTTP) e **prototótipos de procedimento completos** para cada interface que encontrar e os armazenará em `rpcServerData.json`.

### 2. Execute o fuzzer
```powershell
'.\output\rpcServerData.json' |
Invoke-RpcFuzzer -OutPath .\output `
-MinStrLen 100  -MaxStrLen 1000 `
-MinIntSize 9999 -MaxIntSize 99999
```
Opções relevantes:

* `-MinStrLen` / `-MaxStrLen` – intervalo de tamanho para strings geradas
* `-MinIntSize` / `-MaxIntSize` – intervalo de valores para inteiros mutados (útil para testes de overflow)
* `-Sorted` – executar procedimentos em uma ordem que respeita **dependências de parâmetros** para que as saídas de uma chamada possam servir como entradas da próxima (aumenta dramaticamente os caminhos alcançáveis)

O fuzzer implementa 2 estratégias:

1. **Fuzzer padrão** – valores primitivos aleatórios + instâncias padrão para tipos complexos
2. **Fuzzer ordenado** – ordenação ciente de dependências (veja `docs/Procedure dependency design.md`)

Cada chamada é registrada atomicamente em `log.txt`; após uma falha, a **última linha imediatamente informa o procedimento ofensivo**. O resultado de cada chamada também é categorizado em três arquivos JSON:

* `allowed.json` – chamada bem-sucedida e retornou dados
* `denied.json`  – servidor respondeu com *Access Denied*
* `error.json`   – qualquer outro erro / falha

### 3. Visualizar com Neo4j
```powershell
'.\output\allowed.json' |
Import-DataToNeo4j -Neo4jHost 192.168.56.10:7474 -Neo4jUsername neo4j
```
`Import-DataToNeo4j` converte os artefatos JSON em uma estrutura de grafo onde:

* Servidores RPC, interfaces e procedimentos são **nós**
* Interações (`ALLOWED`, `DENIED`, `ERROR`) são **relacionamentos**

Consultas Cypher podem então ser usadas para identificar rapidamente procedimentos perigosos ou para reproduzir a cadeia exata de chamadas que precederam uma falha.

⚠️  O fuzzer é *destrutivo*: espere falhas de serviço e até BSODs – sempre execute-o em um snapshot de VM isolado.


### Enumeração de Interface Automatizada & Geração Dinâmica de Cliente (NtObjectManager)

O guru do PowerShell **James Forshaw** expôs a maior parte dos internos do Windows RPC dentro do módulo de código aberto *NtObjectManager*. Usando-o, você pode transformar qualquer DLL / EXE de servidor RPC em um **stub de cliente totalmente funcional** em segundos – sem necessidade de IDL, MIDL ou desmarshalling manual.
```powershell
# Install the module once
Install-Module NtObjectManager -Force

# Parse every RPC interface exported by the target binary
$rpcinterfaces = Get-RpcServer "C:\Windows\System32\efssvc.dll"
$rpcinterfaces | Format-Table Name,Uuid,Version,Procedures

# Inspect a single procedure (opnum 0)
$rpcinterfaces[0].Procedures[0] | Format-List *
```
A saída típica expõe os tipos de parâmetro exatamente como aparecem no **MIDL** (por exemplo, `FC_C_WSTRING`, `FC_LONG`, `FC_BIND_CONTEXT`).

Uma vez que você conhece a interface, você pode **gerar um cliente C# pronto para compilar**:
```powershell
# Reverse the MS-EFSR (EfsRpc*) interface into C#
Format-RpcClient $rpcinterfaces[0] -Namespace MS_EFSR -OutputPath .\MS_EFSR.cs
```
Dentro do stub produzido, você encontrará métodos como:
```csharp
public int EfsRpcOpenFileRaw(out Marshal.NdrContextHandle ctx, string FileName, int Flags) {
// marshals parameters & calls opnum 0
}
```
O helper PowerShell `Get-RpcClient` pode criar um **objeto cliente interativo** para que você possa chamar o procedimento imediatamente:
```powershell
$client = Get-RpcClient $rpcinterfaces[0]
Connect-RpcClient $client -stringbinding 'ncacn_np:127.0.0.1[\\pipe\\efsrpc]' `
-AuthenticationLevel PacketPrivacy `
-AuthenticationType  WinNT  # NTLM auth

# Invoke the procedure → returns an authenticated context handle
$ctx = New-Object Marshal.NdrContextHandle
$client.EfsRpcOpenFileRaw([ref]$ctx, "\\\127.0.0.1\test", 0)
```
Autenticação (Kerberos / NTLM) e níveis de criptografia (`PacketIntegrity`, `PacketPrivacy`, …) podem ser fornecidos diretamente via o cmdlet `Connect-RpcClient` – ideal para **contornar Descritores de Segurança** que protegem pipes nomeados de alto privilégio.

### Fuzzing RPC Consciente do Contexto (MS-RPC-Fuzzer)

O conhecimento estático da interface é ótimo, mas o que você realmente deseja é **fuzzing guiado por cobertura** que entende *handles de contexto* e cadeias de parâmetros complexas. O projeto de código aberto **MS-RPC-Fuzzer** automatiza exatamente esse fluxo de trabalho:

1. Enumere cada interface/procedimento exportado pelo binário alvo (`Get-RpcServer`).
2. Gere clientes dinâmicos para cada interface (`Format-RpcClient`).
3. Randomize os parâmetros de entrada (comprimento de strings largas, intervalos de inteiros, enums) enquanto respeita o **tipo NDR** original.
4. Rastreie *handles de contexto* retornados por uma chamada para alimentar procedimentos subsequentes automaticamente.
5. Realize chamadas de alto volume contra o transporte escolhido (ALPC, TCP, HTTP ou pipe nomeado).
6. Registre status de saída / falhas / timeouts e exporte um arquivo de importação **Neo4j** para visualizar relacionamentos *interface → procedimento → parâmetro* e clusters de falhas.

Execução de exemplo (alvo de pipe nomeado):
```powershell
Invoke-MSRPCFuzzer -Pipe "\\.\pipe\efsrpc" -Auth NTLM `
-MinLen 1  -MaxLen 0x400 `
-Iterations 100000 `
-OutDir .\results
```
Uma única gravação fora dos limites ou exceção inesperada será exibida imediatamente com o opnum exato + payload fuzzed que a acionou – ponto de partida perfeito para um exploit de prova de conceito estável.

> ⚠️  Muitos serviços RPC são executados em processos que rodam como **NT AUTHORITY\SYSTEM**. Qualquer problema de segurança de memória aqui geralmente se traduz em escalonamento de privilégios local ou (quando exposto via SMB/135) *execução remota de código*.


## Referências

- [Automating MS-RPC vulnerability research (2025, Incendium.rocks)](https://www.incendium.rocks/posts/Automating-MS-RPC-Vulnerability-Research/)
- [MS-RPC-Fuzzer – context-aware RPC fuzzer](https://github.com/warpnet/MS-RPC-Fuzzer)
- [NtObjectManager PowerShell module](https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools/tree/master/NtObjectManager)
- [https://www.cyber.airbus.com/the-oxid-resolver-part-1-remote-enumeration-of-network-interfaces-without-any-authentication/](https://www.cyber.airbus.com/the-oxid-resolver-part-1-remote-enumeration-of-network-interfaces-without-any-authentication/)
- [https://www.cyber.airbus.com/the-oxid-resolver-part-2-accessing-a-remote-object-inside-dcom/](https://www.cyber.airbus.com/the-oxid-resolver-part-2-accessing-a-remote-object-inside-dcom/)
- [https://0xffsec.com/handbook/services/msrpc/](https://0xffsec.com/handbook/services/msrpc/)
- [MS-RPC-Fuzzer (GitHub)](https://github.com/warpnet/MS-RPC-Fuzzer)

{{#include ../banners/hacktricks-training.md}}
