# 135, 593 - Pentesting MSRPC

{{#include ../banners/hacktricks-training.md}}

## Basiese Inligting

Die Microsoft Remote Procedure Call (MSRPC) protokol, 'n kliënt-bediener model wat 'n program in staat stel om 'n diens van 'n program op 'n ander rekenaar aan te vra sonder om die netwerk se spesifikasies te verstaan, is aanvanklik afgelei van oopbron sagteware en later ontwikkel en gekopieer deur Microsoft.

Die RPC eindpunt mapper kan toegang verkry word via TCP en UDP poort 135, SMB op TCP 139 en 445 (met 'n nul of geverifieerde sessie), en as 'n webdiens op TCP poort 593.
```
135/tcp   open     msrpc         Microsoft Windows RPC
```
## Hoe werk MSRPC?

Begin deur die kliënttoepassing, die MSRPC-proses behels die oproep van 'n plaaslike stub-prosedure wat dan met die kliënt runtime-biblioteek interaksie het om die versoek voor te berei en na die bediener te stuur. Dit sluit in om parameters in 'n standaard Netwerk Data Representasie-formaat om te skakel. Die keuse van die vervoersprotokol word deur die runtime-biblioteek bepaal as die bediener afgeleë is, wat verseker dat die RPC deur die netwerkstapel afgelewer word.

![https://0xffsec.com/handbook/images/msrpc.png](https://0xffsec.com/handbook/images/msrpc.png)

## **Identifisering van Blootgestelde RPC Dienste**

Blootstelling van RPC-dienste oor TCP, UDP, HTTP, en SMB kan bepaal word deur die RPC-lokasiediens en individuele eindpunte te ondervra. Gereedskap soos rpcdump fasiliteer die identifikasie van unieke RPC-dienste, aangedui deur **IFID** waardes, wat diensbesonderhede en kommunikasie-bindings onthul:
```
D:\rpctools> rpcdump [-p port] <IP>
**IFID**: 5a7b91f8-ff00-11d0-a9b2-00c04fb6e6fc version 1.0
Annotation: Messenger Service
UUID: 00000000-0000-0000-0000-000000000000
Binding: ncadg_ip_udp:<IP>[1028]
```
Toegang tot die RPC-lokasiediens is geaktiveer deur spesifieke protokolle: ncacn_ip_tcp en ncadg_ip_udp vir toegang via poort 135, ncacn_np vir SMB-verbindinge, en ncacn_http vir web-gebaseerde RPC-kommunikasie. Die volgende opdragte illustreer die gebruik van Metasploit-modules om MSRPC-dienste te oudit en mee te werk, met die fokus op poort 135:
```bash
use auxiliary/scanner/dcerpc/endpoint_mapper
use auxiliary/scanner/dcerpc/hidden
use auxiliary/scanner/dcerpc/management
use auxiliary/scanner/dcerpc/tcp_dcerpc_auditor
rpcdump.py <IP> -p 135
```
Alle opsies behalwe `tcp_dcerpc_auditor` is spesifiek ontwerp om MSRPC op poort 135 te teiken.

#### Opmerklike RPC interfaces

- **IFID**: 12345778-1234-abcd-ef00-0123456789ab
- **Named Pipe**: `\pipe\lsarpc`
- **Beskrywing**: LSA-interface, gebruik om gebruikers te enumerate.
- **IFID**: 3919286a-b10c-11d0-9ba8-00c04fd92ef5
- **Named Pipe**: `\pipe\lsarpc`
- **Beskrywing**: LSA Directory Services (DS) interface, gebruik om domeine en vertrouensverhoudings te enumerate.
- **IFID**: 12345778-1234-abcd-ef00-0123456789ac
- **Named Pipe**: `\pipe\samr`
- **Beskrywing**: LSA SAMR interface, gebruik om toegang te verkry tot openbare SAM-databasis elemente (bv. gebruikersname) en om gebruikerswagwoorde te brute-force, ongeag van rekening sluiting beleid.
- **IFID**: 1ff70682-0a51-30e8-076d-740be8cee98b
- **Named Pipe**: `\pipe\atsvc`
- **Beskrywing**: Taak skeduler, gebruik om opdragte op afstand uit te voer.
- **IFID**: 338cd001-2244-31f1-aaaa-900038001003
- **Named Pipe**: `\pipe\winreg`
- **Beskrywing**: Afgeleë registrasiediens, gebruik om toegang te verkry tot en die stelselsregister te wysig.
- **IFID**: 367abb81-9844-35f1-ad32-98f038001003
- **Named Pipe**: `\pipe\svcctl`
- **Beskrywing**: Diensbeheerder en bedienerdienste, gebruik om dienste op afstand te begin en te stop en opdragte uit te voer.
- **IFID**: 4b324fc8-1670-01d3-1278-5a47bf6ee188
- **Named Pipe**: `\pipe\srvsvc`
- **Beskrywing**: Diensbeheerder en bedienerdienste, gebruik om dienste op afstand te begin en te stop en opdragte uit te voer.
- **IFID**: 4d9f4ab8-7d1c-11cf-861e-0020af6e7c57
- **Named Pipe**: `\pipe\epmapper`
- **Beskrywing**: DCOM-interface, gebruik vir brute-force wagwoord grinding en inligting versameling via WM.

### Identifisering van IP adresse

Met behulp van [https://github.com/mubix/IOXIDResolver](https://github.com/mubix/IOXIDResolver), afkomstig van [Airbus navorsing](https://www.cyber.airbus.com/the-oxid-resolver-part-1-remote-enumeration-of-network-interfaces-without-any-authentication/), is dit moontlik om die _**ServerAlive2**_ metode binne die _**IOXIDResolver**_ interface te misbruik.

Hierdie metode is gebruik om interface-inligting as **IPv6** adres van die HTB boks _APT_ te verkry. Sien [hier](https://0xdf.gitlab.io/2021/04/10/htb-apt.html) vir 0xdf APT skrywe, dit sluit 'n alternatiewe metode in wat rpcmap.py van [Impacket](https://github.com/SecureAuthCorp/impacket/) gebruik met _stringbinding_ (sien hierbo).

### Uitvoering van 'n RCE met geldige akrediteer

Dit is moontlik om afstandkode op 'n masjien uit te voer, as die akrediteer van 'n geldige gebruiker beskikbaar is met behulp van [dcomexec.py](https://github.com/fortra/impacket/blob/master/examples/dcomexec.py) van die impacket raamwerk.

**Onthou om met die verskillende beskikbare objekte te probeer**

- ShellWindows
- ShellBrowserWindow
- MMC20

## Poort 593

Die **rpcdump.exe** van [rpctools](https://resources.oreilly.com/examples/9780596510305/tree/master/tools/rpctools) kan met hierdie poort kommunikeer.

### Geoutomatiseerde Interface Enumerasie & Dinamiese Kliënt Generasie (NtObjectManager)

PowerShell guru **James Forshaw** het die meeste van die Windows RPC interne binne die oop-bron *NtObjectManager* module blootgestel. Met dit kan jy enige RPC bediener DLL / EXE in 'n **volledig funksionele kliënt stub** in sekondes omskakel – geen IDL, MIDL of handmatige unmarshalling benodig.
```powershell
# Install the module once
Install-Module NtObjectManager -Force

# Parse every RPC interface exported by the target binary
$rpcinterfaces = Get-RpcServer "C:\Windows\System32\efssvc.dll"
$rpcinterfaces | Format-Table Name,Uuid,Version,Procedures

# Inspect a single procedure (opnum 0)
$rpcinterfaces[0].Procedures[0] | Format-List *
```
Tipiese uitvoer stel parameter tipes bloot presies soos hulle verskyn in **MIDL** (bv. `FC_C_WSTRING`, `FC_LONG`, `FC_BIND_CONTEXT`).

Sodra jy die koppelvlak ken, kan jy **'n gereed-om-te-kompiler C# kliënt genereer**:
```powershell
# Reverse the MS-EFSR (EfsRpc*) interface into C#
Format-RpcClient $rpcinterfaces[0] -Namespace MS_EFSR -OutputPath .\MS_EFSR.cs
```
Binne die geproduseerde stub sal jy metodes vind soos:
```csharp
public int EfsRpcOpenFileRaw(out Marshal.NdrContextHandle ctx, string FileName, int Flags) {
// marshals parameters & calls opnum 0
}
```
Die PowerShell-helper `Get-RpcClient` kan 'n **interaktiewe kliëntobjek** skep sodat jy die prosedure onmiddellik kan aanroep:
```powershell
$client = Get-RpcClient $rpcinterfaces[0]
Connect-RpcClient $client -stringbinding 'ncacn_np:127.0.0.1[\\pipe\\efsrpc]' `
-AuthenticationLevel PacketPrivacy `
-AuthenticationType  WinNT  # NTLM auth

# Invoke the procedure → returns an authenticated context handle
$ctx = New-Object Marshal.NdrContextHandle
$client.EfsRpcOpenFileRaw([ref]$ctx, "\\\127.0.0.1\test", 0)
```
Authentication (Kerberos / NTLM) en versleuteling vlakke (`PacketIntegrity`, `PacketPrivacy`, …) kan direk verskaf word via die `Connect-RpcClient` cmdlet – ideaal vir **omseiling van Sekuriteitsbeskrywings** wat hoë-privilege naamgepipe beskerm.

---

### Konteksbewuste RPC Fuzzing (MS-RPC-Fuzzer)

Statische koppelvlak kennis is wonderlik, maar wat jy regtig wil hê is **dekking-geleide fuzzing** wat *kontekshandvatsels* en komplekse parameter kettings verstaan. Die open-source **MS-RPC-Fuzzer** projek outomatiseer presies daardie werkstroom:

1. Enumereer elke koppelvlak/prosedure wat deur die teiken binêre uitgevoer word (`Get-RpcServer`).
2. Genereer dinamiese kliënte vir elke koppelvlak (`Format-RpcClient`).
3. Randomiseer invoerparameters (wye string lengte, heelgetal reekse, enums) terwyl die oorspronklike **NDR tipe** gerespekteer word.
4. Volg *kontekshandvatsels* wat deur een oproep teruggegee word om opvolg prosedures outomaties te voed.
5. Vuur hoë-volume oproepe teen die gekose vervoer (ALPC, TCP, HTTP of naamgepipe).
6. Log uitgangstatusse / foute / tydsduur en voer 'n **Neo4j** invoer lêer uit om *koppelvlak → prosedure → parameter* verhoudings en crash klusters te visualiseer.

Voorbeeld uitvoering (naamgepipe teiken):
```powershell
Invoke-MSRPCFuzzer -Pipe "\\.\pipe\efsrpc" -Auth NTLM `
-MinLen 1  -MaxLen 0x400 `
-Iterations 100000 `
-OutDir .\results
```
'n Enkele uit-bounds skrywe of onverwagte uitsondering sal onmiddellik na vore kom met die presiese opnum + gefuzzde payload wat dit geaktiveer het – 'n perfekte beginpunt vir 'n stabiele bewys-van-konsep ontploffing.

> ⚠️  Baie RPC dienste werk in prosesse wat as **NT AUTHORITY\SYSTEM** loop. Enige geheue-veiligeheidsprobleem hier vertaal gewoonlik na plaaslike voorregverhoging of (wanneer oor SMB/135 blootgestel) *afgeleë kode-uitvoering*.

---

## Verwysings

- [Automating MS-RPC vulnerability research (2025, Incendium.rocks)](https://www.incendium.rocks/posts/Automating-MS-RPC-Vulnerability-Research/)
- [MS-RPC-Fuzzer – context-aware RPC fuzzer](https://github.com/warpnet/MS-RPC-Fuzzer)
- [NtObjectManager PowerShell module](https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools/tree/master/NtObjectManager)


- [https://www.cyber.airbus.com/the-oxid-resolver-part-1-remote-enumeration-of-network-interfaces-without-any-authentication/](https://www.cyber.airbus.com/the-oxid-resolver-part-1-remote-enumeration-of-network-interfaces-without-any-authentication/)
- [https://www.cyber.airbus.com/the-oxid-resolver-part-2-accessing-a-remote-object-inside-dcom/](https://www.cyber.airbus.com/the-oxid-resolver-part-2-accessing-a-remote-object-inside-dcom/)
- [https://0xffsec.com/handbook/services/msrpc/](https://0xffsec.com/handbook/services/msrpc/)

{{#include ../banners/hacktricks-training.md}}
