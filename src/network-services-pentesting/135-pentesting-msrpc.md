# 135, 593 - Pentesting MSRPC

{{#include ../banners/hacktricks-training.md}}

## Basic Information

Microsoft Remote Procedure Call (MSRPC) प्रोटोकॉल, एक क्लाइंट-सरवर मॉडल जो एक प्रोग्राम को किसी अन्य कंप्यूटर पर स्थित प्रोग्राम से सेवा मांगने की अनुमति देता है बिना नेटवर्क की विशिष्टताओं को समझे, मूल रूप से ओपन-सोर्स सॉफ़्टवेयर से निकाला गया था और बाद में Microsoft द्वारा विकसित और कॉपीराइट किया गया।

RPC एंडपॉइंट मैपर को TCP और UDP पोर्ट 135, SMB पर TCP 139 और 445 (एक शून्य या प्रमाणित सत्र के साथ) के माध्यम से और TCP पोर्ट 593 पर एक वेब सेवा के रूप में एक्सेस किया जा सकता है।
```
135/tcp   open     msrpc         Microsoft Windows RPC
```
## MSRPC कैसे काम करता है?

क्लाइंट एप्लिकेशन द्वारा शुरू किया गया, MSRPC प्रक्रिया में एक स्थानीय स्टब प्रक्रिया को कॉल करना शामिल है जो फिर क्लाइंट रनटाइम लाइब्रेरी के साथ इंटरैक्ट करती है ताकि सर्वर को अनुरोध तैयार और भेजा जा सके। इसमें मानक नेटवर्क डेटा प्रतिनिधित्व प्रारूप में पैरामीटर को परिवर्तित करना शामिल है। यदि सर्वर दूरस्थ है, तो परिवहन प्रोटोकॉल का चयन रनटाइम लाइब्रेरी द्वारा किया जाता है, यह सुनिश्चित करते हुए कि RPC नेटवर्क स्टैक के माध्यम से वितरित किया गया है।

![https://0xffsec.com/handbook/images/msrpc.png](https://0xffsec.com/handbook/images/msrpc.png)

## **प्रदर्शित RPC सेवाओं की पहचान करना**

TCP, UDP, HTTP, और SMB के माध्यम से RPC सेवाओं का प्रदर्शन RPC लोकेटर सेवा और व्यक्तिगत एंडपॉइंट्स को क्वेरी करके निर्धारित किया जा सकता है। rpcdump जैसे उपकरण अद्वितीय RPC सेवाओं की पहचान करने में मदद करते हैं, जिन्हें **IFID** मानों द्वारा दर्शाया जाता है, सेवा विवरण और संचार बाइंडिंग को प्रकट करते हैं:
```
D:\rpctools> rpcdump [-p port] <IP>
**IFID**: 5a7b91f8-ff00-11d0-a9b2-00c04fb6e6fc version 1.0
Annotation: Messenger Service
UUID: 00000000-0000-0000-0000-000000000000
Binding: ncadg_ip_udp:<IP>[1028]
```
RPC लोकेटर सेवा तक पहुँच विशेष प्रोटोकॉल के माध्यम से सक्षम है: ncacn_ip_tcp और ncadg_ip_udp पोर्ट 135 के माध्यम से पहुँच के लिए, SMB कनेक्शनों के लिए ncacn_np, और वेब-आधारित RPC संचार के लिए ncacn_http। निम्नलिखित कमांड MSRPC सेवाओं का ऑडिट और इंटरैक्ट करने के लिए Metasploit मॉड्यूल के उपयोग का उदाहरण प्रस्तुत करते हैं, मुख्य रूप से पोर्ट 135 पर ध्यान केंद्रित करते हुए:
```bash
use auxiliary/scanner/dcerpc/endpoint_mapper
use auxiliary/scanner/dcerpc/hidden
use auxiliary/scanner/dcerpc/management
use auxiliary/scanner/dcerpc/tcp_dcerpc_auditor
rpcdump.py <IP> -p 135
```
सभी विकल्पों को छोड़कर `tcp_dcerpc_auditor` विशेष रूप से पोर्ट 135 पर MSRPC को लक्षित करने के लिए डिज़ाइन किए गए हैं।

#### उल्लेखनीय RPC इंटरफेस

- **IFID**: 12345778-1234-abcd-ef00-0123456789ab
- **Named Pipe**: `\pipe\lsarpc`
- **Description**: LSA इंटरफेस, जिसका उपयोग उपयोगकर्ताओं की गणना करने के लिए किया जाता है।
- **IFID**: 3919286a-b10c-11d0-9ba8-00c04fd92ef5
- **Named Pipe**: `\pipe\lsarpc`
- **Description**: LSA डायरेक्टरी सेवाएँ (DS) इंटरफेस, जिसका उपयोग डोमेन और ट्रस्ट संबंधों की गणना करने के लिए किया जाता है।
- **IFID**: 12345778-1234-abcd-ef00-0123456789ac
- **Named Pipe**: `\pipe\samr`
- **Description**: LSA SAMR इंटरफेस, जिसका उपयोग सार्वजनिक SAM डेटाबेस तत्वों (जैसे, उपयोगकर्ता नाम) तक पहुँचने और उपयोगकर्ता पासवर्ड को ब्रूट-फोर्स करने के लिए किया जाता है, चाहे खाता लॉकआउट नीति कुछ भी हो।
- **IFID**: 1ff70682-0a51-30e8-076d-740be8cee98b
- **Named Pipe**: `\pipe\atsvc`
- **Description**: कार्य शेड्यूलर, जिसका उपयोग दूरस्थ रूप से कमांड निष्पादित करने के लिए किया जाता है।
- **IFID**: 338cd001-2244-31f1-aaaa-900038001003
- **Named Pipe**: `\pipe\winreg`
- **Description**: रिमोट रजिस्ट्री सेवा, जिसका उपयोग सिस्टम रजिस्ट्री तक पहुँचने और उसे संशोधित करने के लिए किया जाता है।
- **IFID**: 367abb81-9844-35f1-ad32-98f038001003
- **Named Pipe**: `\pipe\svcctl`
- **Description**: सेवा नियंत्रण प्रबंधक और सर्वर सेवाएँ, जिसका उपयोग दूरस्थ रूप से सेवाओं को प्रारंभ और रोकने और कमांड निष्पादित करने के लिए किया जाता है।
- **IFID**: 4b324fc8-1670-01d3-1278-5a47bf6ee188
- **Named Pipe**: `\pipe\srvsvc`
- **Description**: सेवा नियंत्रण प्रबंधक और सर्वर सेवाएँ, जिसका उपयोग दूरस्थ रूप से सेवाओं को प्रारंभ और रोकने और कमांड निष्पादित करने के लिए किया जाता है।
- **IFID**: 4d9f4ab8-7d1c-11cf-861e-0020af6e7c57
- **Named Pipe**: `\pipe\epmapper`
- **Description**: DCOM इंटरफेस, जिसका उपयोग ब्रूट-फोर्स पासवर्ड ग्राइंडिंग और WM के माध्यम से जानकारी एकत्र करने के लिए किया जाता है।

### IP पते की पहचान करना

[https://github.com/mubix/IOXIDResolver](https://github.com/mubix/IOXIDResolver) का उपयोग करते हुए, [Airbus research](https://www.cyber.airbus.com/the-oxid-resolver-part-1-remote-enumeration-of-network-interfaces-without-any-authentication/) से आता है, _**IOXIDResolver**_ इंटरफेस के अंदर _**ServerAlive2**_ विधि का दुरुपयोग करना संभव है।

इस विधि का उपयोग HTB बॉक्स _APT_ से **IPv6** पते के रूप में इंटरफेस जानकारी प्राप्त करने के लिए किया गया है। 0xdf APT लेखन के लिए [यहाँ](https://0xdf.gitlab.io/2021/04/10/htb-apt.html) देखें, इसमें _stringbinding_ का उपयोग करते हुए [Impacket](https://github.com/SecureAuthCorp/impacket/) से rpcmap.py का एक वैकल्पिक तरीका शामिल है (ऊपर देखें)।

### मान्य क्रेडेंशियल्स के साथ RCE निष्पादित करना

यदि एक मान्य उपयोगकर्ता के क्रेडेंशियल्स उपलब्ध हैं, तो मशीन पर दूरस्थ कोड निष्पादित करना संभव है, [dcomexec.py](https://github.com/fortra/impacket/blob/master/examples/dcomexec.py) का उपयोग करके impacket ढांचे से।

**विभिन्न उपलब्ध वस्तुओं के साथ प्रयास करना याद रखें**

- ShellWindows
- ShellBrowserWindow
- MMC20

## पोर्ट 593

[rpctools](https://resources.oreilly.com/examples/9780596510305/tree/master/tools/rpctools) से **rpcdump.exe** इस पोर्ट के साथ इंटरैक्ट कर सकता है।

### स्वचालित इंटरफेस गणना और गतिशील क्लाइंट जनरेशन (NtObjectManager)

PowerShell गुरु **James Forshaw** ने ओपन-सोर्स *NtObjectManager* मॉड्यूल के अंदर अधिकांश Windows RPC आंतरिकताओं को उजागर किया। इसका उपयोग करके आप किसी भी RPC सर्वर DLL / EXE को सेकंडों में **पूर्ण विशेषताओं वाले क्लाइंट स्टब** में बदल सकते हैं - कोई IDL, MIDL या मैनुअल अनमार्शलिंग की आवश्यकता नहीं है।
```powershell
# Install the module once
Install-Module NtObjectManager -Force

# Parse every RPC interface exported by the target binary
$rpcinterfaces = Get-RpcServer "C:\Windows\System32\efssvc.dll"
$rpcinterfaces | Format-Table Name,Uuid,Version,Procedures

# Inspect a single procedure (opnum 0)
$rpcinterfaces[0].Procedures[0] | Format-List *
```
सामान्य आउटपुट पैरामीटर प्रकारों को ठीक उसी तरह प्रकट करता है जैसे वे **MIDL** में दिखाई देते हैं (जैसे `FC_C_WSTRING`, `FC_LONG`, `FC_BIND_CONTEXT`)।

एक बार जब आप इंटरफेस को जान लेते हैं, तो आप **एक तैयार-से-संकल C# क्लाइंट** उत्पन्न कर सकते हैं:
```powershell
# Reverse the MS-EFSR (EfsRpc*) interface into C#
Format-RpcClient $rpcinterfaces[0] -Namespace MS_EFSR -OutputPath .\MS_EFSR.cs
```
उत्पादित स्टब के अंदर आपको ऐसे तरीके मिलेंगे:
```csharp
public int EfsRpcOpenFileRaw(out Marshal.NdrContextHandle ctx, string FileName, int Flags) {
// marshals parameters & calls opnum 0
}
```
PowerShell सहायक `Get-RpcClient` एक **इंटरएक्टिव क्लाइंट ऑब्जेक्ट** बना सकता है ताकि आप प्रक्रिया को तुरंत कॉल कर सकें:
```powershell
$client = Get-RpcClient $rpcinterfaces[0]
Connect-RpcClient $client -stringbinding 'ncacn_np:127.0.0.1[\\pipe\\efsrpc]' `
-AuthenticationLevel PacketPrivacy `
-AuthenticationType  WinNT  # NTLM auth

# Invoke the procedure → returns an authenticated context handle
$ctx = New-Object Marshal.NdrContextHandle
$client.EfsRpcOpenFileRaw([ref]$ctx, "\\\127.0.0.1\test", 0)
```
प्रमाणीकरण (Kerberos / NTLM) और एन्क्रिप्शन स्तर (`PacketIntegrity`, `PacketPrivacy`, …) को सीधे `Connect-RpcClient` cmdlet के माध्यम से प्रदान किया जा सकता है - **उच्च-विशेषाधिकार नामित पाइप** की सुरक्षा करने वाले सुरक्षा वर्णनकर्ताओं को बायपास करने के लिए आदर्श।

---

### संदर्भ-जानकारी RPC फज़िंग (MS-RPC-Fuzzer)

स्थैतिक इंटरफ़ेस ज्ञान अच्छा है, लेकिन आप वास्तव में जो चाहते हैं वह है **कवरेज-गाइडेड फज़िंग** जो *संदर्भ हैंडल* और जटिल पैरामीटर श्रृंखलाओं को समझता है। ओपन-सोर्स **MS-RPC-Fuzzer** प्रोजेक्ट ठीक उसी कार्यप्रवाह को स्वचालित करता है:

1. लक्षित बाइनरी द्वारा निर्यातित प्रत्येक इंटरफ़ेस/प्रक्रिया को सूचीबद्ध करें (`Get-RpcServer`)।
2. प्रत्येक इंटरफ़ेस के लिए गतिशील क्लाइंट उत्पन्न करें (`Format-RpcClient`)।
3. मूल **NDR प्रकार** का सम्मान करते हुए इनपुट पैरामीटर (चौड़े स्ट्रिंग लंबाई, पूर्णांक रेंज, एनम) को यादृच्छिक बनाएं।
4. एक कॉल द्वारा लौटाए गए *संदर्भ हैंडल* को ट्रैक करें ताकि स्वचालित रूप से फॉलो-अप प्रक्रियाओं को फीड किया जा सके।
5. चुने हुए परिवहन (ALPC, TCP, HTTP या नामित पाइप) के खिलाफ उच्च मात्रा में कॉल करें।
6. निकासी स्थिति / दोष / टाइमआउट लॉग करें और *इंटरफ़ेस → प्रक्रिया → पैरामीटर* संबंधों और क्रैश क्लस्टरों को दृश्य बनाने के लिए एक **Neo4j** आयात फ़ाइल निर्यात करें।

उदाहरण रन (नामित-पाइप लक्ष्य):
```powershell
Invoke-MSRPCFuzzer -Pipe "\\.\pipe\efsrpc" -Auth NTLM `
-MinLen 1  -MaxLen 0x400 `
-Iterations 100000 `
-OutDir .\results
```
एक एकल आउट-ऑफ-बाउंड लिखना या अप्रत्याशित अपवाद तुरंत प्रकट होगा, जिसमें सटीक opnum + फज़्ड पेलोड होगा जिसने इसे ट्रिगर किया - एक स्थिर प्रमाण-ऑफ-कॉन्सेप्ट एक्सप्लॉइट के लिए एकदम सही प्रारंभिक बिंदु।

> ⚠️  कई RPC सेवाएँ **NT AUTHORITY\SYSTEM** के रूप में चलने वाली प्रक्रियाओं में कार्यान्वित होती हैं। यहाँ कोई भी मेमोरी-सुरक्षा समस्या आमतौर पर स्थानीय विशेषाधिकार वृद्धि या (जब SMB/135 के माध्यम से उजागर किया जाता है) *दूरस्थ कोड निष्पादन* में परिवर्तित होती है।

---

## संदर्भ

- [Automating MS-RPC vulnerability research (2025, Incendium.rocks)](https://www.incendium.rocks/posts/Automating-MS-RPC-Vulnerability-Research/)
- [MS-RPC-Fuzzer – context-aware RPC fuzzer](https://github.com/warpnet/MS-RPC-Fuzzer)
- [NtObjectManager PowerShell module](https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools/tree/master/NtObjectManager)

- [https://www.cyber.airbus.com/the-oxid-resolver-part-1-remote-enumeration-of-network-interfaces-without-any-authentication/](https://www.cyber.airbus.com/the-oxid-resolver-part-1-remote-enumeration-of-network-interfaces-without-any-authentication/)
- [https://www.cyber.airbus.com/the-oxid-resolver-part-2-accessing-a-remote-object-inside-dcom/](https://www.cyber.airbus.com/the-oxid-resolver-part-2-accessing-a-remote-object-inside-dcom/)
- [https://0xffsec.com/handbook/services/msrpc/](https://0xffsec.com/handbook/services/msrpc/)

{{#include ../banners/hacktricks-training.md}}
