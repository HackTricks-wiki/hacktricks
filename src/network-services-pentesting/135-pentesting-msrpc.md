# 135, 593 - Pentesting MSRPC

{{#include ../banners/hacktricks-training.md}}

## 기본 정보

Microsoft 원격 프로시저 호출(MSRPC) 프로토콜은 클라이언트-서버 모델로, 프로그램이 네트워크의 세부 사항을 이해하지 않고도 다른 컴퓨터에 위치한 프로그램으로부터 서비스를 요청할 수 있게 해줍니다. 이 프로토콜은 처음에 오픈 소스 소프트웨어에서 파생되었으며, 이후 Microsoft에 의해 개발되고 저작권이 부여되었습니다.

RPC 엔드포인트 매퍼는 TCP 및 UDP 포트 135, TCP 139 및 445에서 SMB(널 또는 인증된 세션 사용)로, 그리고 TCP 포트 593에서 웹 서비스로 접근할 수 있습니다.
```
135/tcp   open     msrpc         Microsoft Windows RPC
```
## MSRPC는 어떻게 작동하나요?

클라이언트 애플리케이션에 의해 시작된 MSRPC 프로세스는 로컬 스텁 프로시저를 호출한 다음 클라이언트 런타임 라이브러리와 상호작용하여 요청을 서버로 준비하고 전송하는 과정을 포함합니다. 여기에는 매개변수를 표준 네트워크 데이터 표현 형식으로 변환하는 것이 포함됩니다. 서버가 원격인 경우 전송 프로토콜의 선택은 런타임 라이브러리에 의해 결정되어 RPC가 네트워크 스택을 통해 전달되도록 보장합니다.

![https://0xffsec.com/handbook/images/msrpc.png](https://0xffsec.com/handbook/images/msrpc.png)

## **노출된 RPC 서비스 식별하기**

TCP, UDP, HTTP 및 SMB를 통한 RPC 서비스의 노출은 RPC 로케이터 서비스 및 개별 엔드포인트를 쿼리하여 확인할 수 있습니다. rpcdump와 같은 도구는 **IFID** 값으로 표시된 고유한 RPC 서비스의 식별을 용이하게 하여 서비스 세부정보 및 통신 바인딩을 드러냅니다:
```
D:\rpctools> rpcdump [-p port] <IP>
**IFID**: 5a7b91f8-ff00-11d0-a9b2-00c04fb6e6fc version 1.0
Annotation: Messenger Service
UUID: 00000000-0000-0000-0000-000000000000
Binding: ncadg_ip_udp:<IP>[1028]
```
RPC 로케이터 서비스에 대한 접근은 특정 프로토콜을 통해 활성화됩니다: ncacn_ip_tcp 및 ncadg_ip_udp는 포트 135를 통해 접근하기 위해, ncacn_np는 SMB 연결을 위해, ncacn_http는 웹 기반 RPC 통신을 위해 사용됩니다. 다음 명령어는 주로 포트 135에 초점을 맞추어 MSRPC 서비스에 대한 감사 및 상호작용을 위해 Metasploit 모듈을 활용하는 예를 보여줍니다:
```bash
use auxiliary/scanner/dcerpc/endpoint_mapper
use auxiliary/scanner/dcerpc/hidden
use auxiliary/scanner/dcerpc/management
use auxiliary/scanner/dcerpc/tcp_dcerpc_auditor
rpcdump.py <IP> -p 135
```
모든 옵션은 `tcp_dcerpc_auditor`를 제외하고 포트 135에서 MSRPC를 타겟팅하도록 특별히 설계되었습니다.

#### 주목할 만한 RPC 인터페이스

- **IFID**: 12345778-1234-abcd-ef00-0123456789ab
- **Named Pipe**: `\pipe\lsarpc`
- **Description**: LSA 인터페이스, 사용자 열거에 사용됩니다.
- **IFID**: 3919286a-b10c-11d0-9ba8-00c04fd92ef5
- **Named Pipe**: `\pipe\lsarpc`
- **Description**: LSA 디렉터리 서비스(DS) 인터페이스, 도메인 및 신뢰 관계 열거에 사용됩니다.
- **IFID**: 12345778-1234-abcd-ef00-0123456789ac
- **Named Pipe**: `\pipe\samr`
- **Description**: LSA SAMR 인터페이스, 공개 SAM 데이터베이스 요소(예: 사용자 이름)에 접근하고 계정 잠금 정책에 관계없이 사용자 비밀번호를 무차별 대입하는 데 사용됩니다.
- **IFID**: 1ff70682-0a51-30e8-076d-740be8cee98b
- **Named Pipe**: `\pipe\atsvc`
- **Description**: 작업 스케줄러, 원격으로 명령을 실행하는 데 사용됩니다.
- **IFID**: 338cd001-2244-31f1-aaaa-900038001003
- **Named Pipe**: `\pipe\winreg`
- **Description**: 원격 레지스트리 서비스, 시스템 레지스트리에 접근하고 수정하는 데 사용됩니다.
- **IFID**: 367abb81-9844-35f1-ad32-98f038001003
- **Named Pipe**: `\pipe\svcctl`
- **Description**: 서비스 제어 관리자 및 서버 서비스, 원격으로 서비스를 시작 및 중지하고 명령을 실행하는 데 사용됩니다.
- **IFID**: 4b324fc8-1670-01d3-1278-5a47bf6ee188
- **Named Pipe**: `\pipe\srvsvc`
- **Description**: 서비스 제어 관리자 및 서버 서비스, 원격으로 서비스를 시작 및 중지하고 명령을 실행하는 데 사용됩니다.
- **IFID**: 4d9f4ab8-7d1c-11cf-861e-0020af6e7c57
- **Named Pipe**: `\pipe\epmapper`
- **Description**: DCOM 인터페이스, 비밀번호 무차별 대입 및 WM을 통한 정보 수집에 사용됩니다.

### IP 주소 식별

[https://github.com/mubix/IOXIDResolver](https://github.com/mubix/IOXIDResolver)를 사용하면 [Airbus research](https://www.cyber.airbus.com/the-oxid-resolver-part-1-remote-enumeration-of-network-interfaces-without-any-authentication/)에서 제공하는 _**ServerAlive2**_ 메서드를 _**IOXIDResolver**_ 인터페이스 내에서 악용할 수 있습니다.

이 방법은 HTB 박스 _APT_에서 **IPv6** 주소로 인터페이스 정보를 얻는 데 사용되었습니다. [여기](https://0xdf.gitlab.io/2021/04/10/htb-apt.html)에서 0xdf APT 작성물을 확인하면, _stringbinding_을 사용하는 [Impacket](https://github.com/SecureAuthCorp/impacket/)의 rpcmap.py를 사용하는 대체 방법이 포함되어 있습니다.

### 유효한 자격 증명을 사용한 RCE 실행

유효한 사용자의 자격 증명이 있는 경우 [dcomexec.py](https://github.com/fortra/impacket/blob/master/examples/dcomexec.py)에서 원격 코드를 실행할 수 있습니다.

**사용 가능한 다양한 객체로 시도하는 것을 잊지 마세요**

- ShellWindows
- ShellBrowserWindow
- MMC20

## 포트 593

[rpctools](https://resources.oreilly.com/examples/9780596510305/tree/master/tools/rpctools)의 **rpcdump.exe**는 이 포트와 상호작용할 수 있습니다.

## MSRPC 인터페이스의 자동 퍼징

MS-RPC 인터페이스는 크고 종종 문서화되지 않은 공격 표면을 노출합니다. 오픈 소스 [MS-RPC-Fuzzer](https://github.com/warpnet/MS-RPC-Fuzzer) PowerShell 모듈은 James Forshaw의 `NtObjectManager`를 기반으로 하여 *동적으로* Windows 바이너리에 이미 존재하는 인터페이스 메타데이터에서 RPC 클라이언트 스텁을 생성합니다. 스텁이 존재하면 모듈은 변형된 입력으로 각 프로시저를 폭격하고 결과를 기록하여 **IDL을 한 줄도 작성하지 않고 RPC 엔드포인트의 재현 가능한 대규모 퍼징을 가능하게 합니다.**

### 1. 인터페이스 목록 작성
```powershell
# Import the module (download / git clone first)
Import-Module .\MS-RPC-Fuzzer.psm1

# Parse a single binary
Get-RpcServerData -Target "C:\Windows\System32\efssvc.dll" -OutPath .\output

# Or crawl the whole %SystemRoot%\System32 directory
Get-RpcServerData -OutPath .\output
```
`Get-RpcServerData`는 UUID, 버전, 바인딩 문자열(명명된 파이프 / TCP / HTTP) 및 **모든 인터페이스에 대한 전체 프로시저 프로토타입**을 추출하여 `rpcServerData.json`에 저장합니다.

### 2. 퍼저 실행
```powershell
'.\output\rpcServerData.json' |
Invoke-RpcFuzzer -OutPath .\output `
-MinStrLen 100  -MaxStrLen 1000 `
-MinIntSize 9999 -MaxIntSize 99999
```
관련 옵션:

* `-MinStrLen` / `-MaxStrLen` – 생성된 문자열의 크기 범위
* `-MinIntSize` / `-MaxIntSize` – 변형된 정수의 값 범위 (오버플로우 테스트에 유용)
* `-Sorted` – **매개변수 의존성**을 존중하는 순서로 절차를 실행하여 한 호출의 출력이 다음 호출의 입력으로 사용될 수 있도록 함 (도달 가능한 경로를 극적으로 증가시킴)

퍼저는 2가지 전략을 구현합니다:

1. **기본 퍼저** – 무작위 원시 값 + 복합 유형에 대한 기본 인스턴스
2. **정렬된 퍼저** – 의존성 인식 정렬 (참조: `docs/Procedure dependency design.md`)

모든 호출은 `log.txt`에 원자적으로 기록됩니다; 충돌 후 **마지막 줄은 즉시 문제를 일으킨 절차를 알려줍니다**. 각 호출의 결과는 세 개의 JSON 파일로 분류됩니다:

* `allowed.json` – 호출이 성공하고 데이터를 반환함
* `denied.json`  – 서버가 *Access Denied*로 응답함
* `error.json`   – 기타 오류 / 충돌

### 3. Neo4j로 시각화하기
```powershell
'.\output\allowed.json' |
Import-DataToNeo4j -Neo4jHost 192.168.56.10:7474 -Neo4jUsername neo4j
```
`Import-DataToNeo4j`는 JSON 아티팩트를 그래프 구조로 변환합니다:

* RPC 서버, 인터페이스 및 절차는 **노드**입니다.
* 상호작용(`ALLOWED`, `DENIED`, `ERROR`)은 **관계**입니다.

Cypher 쿼리를 사용하여 위험한 절차를 빠르게 찾아내거나 충돌 이전의 정확한 호출 체인을 재생할 수 있습니다.

⚠️  퍼저는 *파괴적*입니다: 서비스 충돌 및 BSOD를 예상하십시오 – 항상 격리된 VM 스냅샷에서 실행하십시오.


### 자동화된 인터페이스 열거 및 동적 클라이언트 생성 (NtObjectManager)

PowerShell 전문가 **James Forshaw**는 오픈 소스 *NtObjectManager* 모듈 내에서 대부분의 Windows RPC 내부를 공개했습니다. 이를 사용하면 IDL, MIDL 또는 수동 언마샬링 없이 몇 초 만에 모든 RPC 서버 DLL / EXE를 **완전한 기능을 갖춘 클라이언트 스텁**으로 변환할 수 있습니다.
```powershell
# Install the module once
Install-Module NtObjectManager -Force

# Parse every RPC interface exported by the target binary
$rpcinterfaces = Get-RpcServer "C:\Windows\System32\efssvc.dll"
$rpcinterfaces | Format-Table Name,Uuid,Version,Procedures

# Inspect a single procedure (opnum 0)
$rpcinterfaces[0].Procedures[0] | Format-List *
```
전형적인 출력은 매개변수 유형을 **MIDL**에 나타나는 그대로 노출합니다 (예: `FC_C_WSTRING`, `FC_LONG`, `FC_BIND_CONTEXT`).

인터페이스를 알게 되면 **컴파일할 준비가 된 C# 클라이언트**를 **생성할 수** 있습니다:
```powershell
# Reverse the MS-EFSR (EfsRpc*) interface into C#
Format-RpcClient $rpcinterfaces[0] -Namespace MS_EFSR -OutputPath .\MS_EFSR.cs
```
생성된 스텁 안에는 다음과 같은 메서드가 포함되어 있습니다:
```csharp
public int EfsRpcOpenFileRaw(out Marshal.NdrContextHandle ctx, string FileName, int Flags) {
// marshals parameters & calls opnum 0
}
```
PowerShell 도우미 `Get-RpcClient`는 **대화형 클라이언트 객체**를 생성하여 절차를 즉시 호출할 수 있습니다:
```powershell
$client = Get-RpcClient $rpcinterfaces[0]
Connect-RpcClient $client -stringbinding 'ncacn_np:127.0.0.1[\\pipe\\efsrpc]' `
-AuthenticationLevel PacketPrivacy `
-AuthenticationType  WinNT  # NTLM auth

# Invoke the procedure → returns an authenticated context handle
$ctx = New-Object Marshal.NdrContextHandle
$client.EfsRpcOpenFileRaw([ref]$ctx, "\\\127.0.0.1\test", 0)
```
인증(Kerberos / NTLM) 및 암호화 수준(`PacketIntegrity`, `PacketPrivacy`, …)은 `Connect-RpcClient` cmdlet을 통해 직접 제공될 수 있습니다 – 이는 고급 권한 명명된 파이프를 보호하는 **보안 설명자**를 우회하는 데 이상적입니다.

### 컨텍스트 인식 RPC 퍼징 (MS-RPC-Fuzzer)

정적 인터페이스 지식은 훌륭하지만, 실제로 원하는 것은 *컨텍스트 핸들*과 복잡한 매개변수 체인을 이해하는 **커버리지 기반 퍼징**입니다. 오픈 소스 **MS-RPC-Fuzzer** 프로젝트는 바로 그 워크플로우를 자동화합니다:

1. 대상 바이너리(`Get-RpcServer`)에 의해 내보내진 모든 인터페이스/절차를 열거합니다.
2. 각 인터페이스에 대한 동적 클라이언트를 생성합니다(`Format-RpcClient`).
3. 원래 **NDR 유형**을 존중하면서 입력 매개변수(와이드 문자열 길이, 정수 범위, 열거형)를 무작위화합니다.
4. 한 호출에 의해 반환된 *컨텍스트 핸들*을 추적하여 후속 절차에 자동으로 공급합니다.
5. 선택한 전송(ALPC, TCP, HTTP 또는 명명된 파이프)에 대해 대량 호출을 실행합니다.
6. 종료 상태/오류/타임아웃을 기록하고 *인터페이스 → 절차 → 매개변수* 관계 및 충돌 클러스터를 시각화하기 위해 **Neo4j** 가져오기 파일을 내보냅니다.

예시 실행(명명된 파이프 대상):
```powershell
Invoke-MSRPCFuzzer -Pipe "\\.\pipe\efsrpc" -Auth NTLM `
-MinLen 1  -MaxLen 0x400 `
-Iterations 100000 `
-OutDir .\results
```
단일 경계 초과 쓰기 또는 예기치 않은 예외는 이를 유발한 정확한 opnum + 퍼즈된 페이로드와 함께 즉시 드러납니다. 이는 안정적인 개념 증명 익스플로잇의 완벽한 시작점입니다.

> ⚠️ 많은 RPC 서비스는 **NT AUTHORITY\SYSTEM**으로 실행되는 프로세스에서 실행됩니다. 여기서 메모리 안전성 문제는 일반적으로 로컬 권한 상승 또는 (SMB/135를 통해 노출될 경우) *원격 코드 실행*으로 이어집니다.


## References

- [Automating MS-RPC vulnerability research (2025, Incendium.rocks)](https://www.incendium.rocks/posts/Automating-MS-RPC-Vulnerability-Research/)
- [MS-RPC-Fuzzer – context-aware RPC fuzzer](https://github.com/warpnet/MS-RPC-Fuzzer)
- [NtObjectManager PowerShell module](https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools/tree/master/NtObjectManager)
- [https://www.cyber.airbus.com/the-oxid-resolver-part-1-remote-enumeration-of-network-interfaces-without-any-authentication/](https://www.cyber.airbus.com/the-oxid-resolver-part-1-remote-enumeration-of-network-interfaces-without-any-authentication/)
- [https://www.cyber.airbus.com/the-oxid-resolver-part-2-accessing-a-remote-object-inside-dcom/](https://www.cyber.airbus.com/the-oxid-resolver-part-2-accessing-a-remote-object-inside-dcom/)
- [https://0xffsec.com/handbook/services/msrpc/](https://0xffsec.com/handbook/services/msrpc/)
- [MS-RPC-Fuzzer (GitHub)](https://github.com/warpnet/MS-RPC-Fuzzer)

{{#include ../banners/hacktricks-training.md}}
