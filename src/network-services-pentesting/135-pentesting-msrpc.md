# 135, 593 - Pentesting MSRPC

{{#include ../banners/hacktricks-training.md}}

## 基本信息

Microsoft 远程过程调用 (MSRPC) 协议是一种客户端-服务器模型，使程序能够请求位于另一台计算机上的程序提供服务，而无需了解网络的具体细节。该协议最初源于开源软件，后来由 Microsoft 开发并获得版权。

RPC 端点映射器可以通过 TCP 和 UDP 端口 135 访问，SMB 在 TCP 139 和 445（使用空会话或经过身份验证的会话）上，以及作为 TCP 端口 593 上的 Web 服务。
```
135/tcp   open     msrpc         Microsoft Windows RPC
```
## MSRPC是如何工作的？

由客户端应用程序发起，MSRPC过程涉及调用本地存根过程，然后与客户端运行时库交互，以准备并将请求传输到服务器。这包括将参数转换为标准网络数据表示格式。如果服务器是远程的，传输协议的选择由运行时库决定，确保RPC通过网络栈传递。

![https://0xffsec.com/handbook/images/msrpc.png](https://0xffsec.com/handbook/images/msrpc.png)

## **识别暴露的RPC服务**

通过查询RPC定位服务和各个端点，可以确定通过TCP、UDP、HTTP和SMB暴露的RPC服务。工具如rpcdump有助于识别独特的RPC服务，以**IFID**值表示，揭示服务细节和通信绑定：
```
D:\rpctools> rpcdump [-p port] <IP>
**IFID**: 5a7b91f8-ff00-11d0-a9b2-00c04fb6e6fc version 1.0
Annotation: Messenger Service
UUID: 00000000-0000-0000-0000-000000000000
Binding: ncadg_ip_udp:<IP>[1028]
```
通过特定协议启用对RPC定位服务的访问：ncacn_ip_tcp和ncadg_ip_udp用于通过端口135访问，ncacn_np用于SMB连接，以及ncacn_http用于基于Web的RPC通信。以下命令示例展示了利用Metasploit模块审计和与MSRPC服务交互，主要集中在端口135：
```bash
use auxiliary/scanner/dcerpc/endpoint_mapper
use auxiliary/scanner/dcerpc/hidden
use auxiliary/scanner/dcerpc/management
use auxiliary/scanner/dcerpc/tcp_dcerpc_auditor
rpcdump.py <IP> -p 135
```
所有选项除了 `tcp_dcerpc_auditor` 都是专门针对端口 135 上的 MSRPC 进行攻击设计的。

#### 显著的 RPC 接口

- **IFID**: 12345778-1234-abcd-ef00-0123456789ab
- **命名管道**: `\pipe\lsarpc`
- **描述**: LSA 接口，用于枚举用户。
- **IFID**: 3919286a-b10c-11d0-9ba8-00c04fd92ef5
- **命名管道**: `\pipe\lsarpc`
- **描述**: LSA 目录服务 (DS) 接口，用于枚举域和信任关系。
- **IFID**: 12345778-1234-abcd-ef00-0123456789ac
- **命名管道**: `\pipe\samr`
- **描述**: LSA SAMR 接口，用于访问公共 SAM 数据库元素（例如，用户名）并强行破解用户密码，无论账户锁定策略如何。
- **IFID**: 1ff70682-0a51-30e8-076d-740be8cee98b
- **命名管道**: `\pipe\atsvc`
- **描述**: 任务调度程序，用于远程执行命令。
- **IFID**: 338cd001-2244-31f1-aaaa-900038001003
- **命名管道**: `\pipe\winreg`
- **描述**: 远程注册表服务，用于访问和修改系统注册表。
- **IFID**: 367abb81-9844-35f1-ad32-98f038001003
- **命名管道**: `\pipe\svcctl`
- **描述**: 服务控制管理器和服务器服务，用于远程启动和停止服务以及执行命令。
- **IFID**: 4b324fc8-1670-01d3-1278-5a47bf6ee188
- **命名管道**: `\pipe\srvsvc`
- **描述**: 服务控制管理器和服务器服务，用于远程启动和停止服务以及执行命令。
- **IFID**: 4d9f4ab8-7d1c-11cf-861e-0020af6e7c57
- **命名管道**: `\pipe\epmapper`
- **描述**: DCOM 接口，用于强行破解密码和通过 WM 收集信息。

### 识别 IP 地址

使用 [https://github.com/mubix/IOXIDResolver](https://github.com/mubix/IOXIDResolver)，来自 [Airbus research](https://www.cyber.airbus.com/the-oxid-resolver-part-1-remote-enumeration-of-network-interfaces-without-any-authentication/)，可以滥用 _**ServerAlive2**_ 方法在 _**IOXIDResolver**_ 接口内。

该方法已被用于从 HTB 盒子 _APT_ 获取接口信息作为 **IPv6** 地址。有关 0xdf APT 的详细信息，请参见 [这里](https://0xdf.gitlab.io/2021/04/10/htb-apt.html)，它包括使用来自 [Impacket](https://github.com/SecureAuthCorp/impacket/) 的 rpcmap.py 的替代方法，使用 _stringbinding_（见上文）。

### 使用有效凭据执行 RCE

如果有有效用户的凭据，可以使用来自 impacket 框架的 [dcomexec.py](https://github.com/fortra/impacket/blob/master/examples/dcomexec.py) 在机器上执行远程代码。

**记得尝试不同的可用对象**

- ShellWindows
- ShellBrowserWindow
- MMC20

## 端口 593

来自 [rpctools](https://resources.oreilly.com/examples/9780596510305/tree/master/tools/rpctools) 的 **rpcdump.exe** 可以与此端口进行交互。

## MSRPC 接口的自动模糊测试

MS-RPC 接口暴露了一个大型且通常未记录的攻击面。开源的 [MS-RPC-Fuzzer](https://github.com/warpnet/MS-RPC-Fuzzer) PowerShell 模块基于 James Forshaw 的 `NtObjectManager` 动态创建 RPC 客户端存根，使用 Windows 二进制文件中已存在的接口元数据。一旦存在存根，该模块可以用变异输入轰炸每个过程并记录结果，使 **可重复的大规模 RPC 端点模糊测试成为可能，而无需编写一行 IDL**。

### 1. 清点接口
```powershell
# Import the module (download / git clone first)
Import-Module .\MS-RPC-Fuzzer.psm1

# Parse a single binary
Get-RpcServerData -Target "C:\Windows\System32\efssvc.dll" -OutPath .\output

# Or crawl the whole %SystemRoot%\System32 directory
Get-RpcServerData -OutPath .\output
```
`Get-RpcServerData` 将提取 UUID、版本、绑定字符串（命名管道 / TCP / HTTP）和每个接口遇到的 **完整过程原型**，并将它们存储在 `rpcServerData.json` 中。

### 2. 运行模糊测试器
```powershell
'.\output\rpcServerData.json' |
Invoke-RpcFuzzer -OutPath .\output `
-MinStrLen 100  -MaxStrLen 1000 `
-MinIntSize 9999 -MaxIntSize 99999
```
相关选项：

* `-MinStrLen` / `-MaxStrLen` – 生成字符串的大小范围
* `-MinIntSize` / `-MaxIntSize` – 变异整数的值范围（对溢出测试有用）
* `-Sorted` – 以尊重 **参数依赖性** 的顺序执行过程，以便一个调用的输出可以作为下一个调用的输入（显著增加可达路径）

模糊测试器实现了两种策略：

1. **默认模糊测试器** – 随机原始值 + 复杂类型的默认实例
2. **排序模糊测试器**  – 依赖感知排序（见 `docs/Procedure dependency design.md`）

每个调用都以原子方式写入 `log.txt`；在崩溃后，**最后一行立即告诉您有问题的过程**。每个调用的结果也被分类到三个 JSON 文件中：

* `allowed.json` – 调用成功并返回数据
* `denied.json`  – 服务器响应 *访问被拒绝*
* `error.json`   – 任何其他错误 / 崩溃

### 3. 使用 Neo4j 可视化
```powershell
'.\output\allowed.json' |
Import-DataToNeo4j -Neo4jHost 192.168.56.10:7474 -Neo4jUsername neo4j
```
`Import-DataToNeo4j` 将 JSON 产物转换为图形结构，其中：

* RPC 服务器、接口和过程是 **节点**
* 交互 (`ALLOWED`, `DENIED`, `ERROR`) 是 **关系**

然后可以使用 Cypher 查询快速发现危险的过程或重放导致崩溃的确切调用链。

⚠️  模糊测试器是 *破坏性的*：预期服务崩溃甚至蓝屏 – 始终在隔离的虚拟机快照中运行。

### 自动化接口枚举与动态客户端生成 (NtObjectManager)

PowerShell 大师 **James Forshaw** 揭示了大多数 Windows RPC 内部结构，位于开源的 *NtObjectManager* 模块中。使用它，您可以在几秒钟内将任何 RPC 服务器 DLL / EXE 转换为 **功能齐全的客户端存根** – 无需 IDL、MIDL 或手动反序列化。
```powershell
# Install the module once
Install-Module NtObjectManager -Force

# Parse every RPC interface exported by the target binary
$rpcinterfaces = Get-RpcServer "C:\Windows\System32\efssvc.dll"
$rpcinterfaces | Format-Table Name,Uuid,Version,Procedures

# Inspect a single procedure (opnum 0)
$rpcinterfaces[0].Procedures[0] | Format-List *
```
典型输出准确地暴露了参数类型，如同它们在 **MIDL** 中出现的那样（例如 `FC_C_WSTRING`，`FC_LONG`，`FC_BIND_CONTEXT`）。

一旦你知道了接口，你可以 **生成一个准备编译的 C# 客户端**：
```powershell
# Reverse the MS-EFSR (EfsRpc*) interface into C#
Format-RpcClient $rpcinterfaces[0] -Namespace MS_EFSR -OutputPath .\MS_EFSR.cs
```
在生成的存根中，您将找到以下方法：
```csharp
public int EfsRpcOpenFileRaw(out Marshal.NdrContextHandle ctx, string FileName, int Flags) {
// marshals parameters & calls opnum 0
}
```
PowerShell 助手 `Get-RpcClient` 可以创建一个 **交互式客户端对象**，以便您可以立即调用该过程：
```powershell
$client = Get-RpcClient $rpcinterfaces[0]
Connect-RpcClient $client -stringbinding 'ncacn_np:127.0.0.1[\\pipe\\efsrpc]' `
-AuthenticationLevel PacketPrivacy `
-AuthenticationType  WinNT  # NTLM auth

# Invoke the procedure → returns an authenticated context handle
$ctx = New-Object Marshal.NdrContextHandle
$client.EfsRpcOpenFileRaw([ref]$ctx, "\\\127.0.0.1\test", 0)
```
认证（Kerberos / NTLM）和加密级别（`PacketIntegrity`，`PacketPrivacy`，…）可以通过 `Connect-RpcClient` cmdlet 直接提供 – 这对于**绕过保护高权限命名管道的安全描述符**非常理想。

### 上下文感知的 RPC 模糊测试 (MS-RPC-Fuzzer)

静态接口知识很好，但你真正想要的是**覆盖引导模糊测试**，它理解*上下文句柄*和复杂的参数链。开源的**MS-RPC-Fuzzer**项目正是自动化了这个工作流程：

1. 枚举目标二进制文件导出的每个接口/过程（`Get-RpcServer`）。
2. 为每个接口生成动态客户端（`Format-RpcClient`）。
3. 随机化输入参数（宽字符串长度、整数范围、枚举），同时尊重原始**NDR 类型**。
4. 跟踪一个调用返回的*上下文句柄*，以自动提供后续过程。
5. 对所选传输（ALPC、TCP、HTTP 或命名管道）发起高频调用。
6. 记录退出状态/故障/超时，并导出**Neo4j**导入文件，以可视化*接口 → 过程 → 参数*关系和崩溃集群。

示例运行（命名管道目标）：
```powershell
Invoke-MSRPCFuzzer -Pipe "\\.\pipe\efsrpc" -Auth NTLM `
-MinLen 1  -MaxLen 0x400 `
-Iterations 100000 `
-OutDir .\results
```
一个单一的越界写入或意外异常将立即显示出触发它的确切 opnum + 模糊负载——这是一个稳定的概念验证漏洞利用的完美起点。

> ⚠️  许多 RPC 服务在以 **NT AUTHORITY\SYSTEM** 身份运行的进程中执行。这里的任何内存安全问题通常会导致本地特权提升或（当通过 SMB/135 暴露时）*远程代码执行*。

## 参考文献

- [Automating MS-RPC vulnerability research (2025, Incendium.rocks)](https://www.incendium.rocks/posts/Automating-MS-RPC-Vulnerability-Research/)
- [MS-RPC-Fuzzer – context-aware RPC fuzzer](https://github.com/warpnet/MS-RPC-Fuzzer)
- [NtObjectManager PowerShell module](https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools/tree/master/NtObjectManager)
- [https://www.cyber.airbus.com/the-oxid-resolver-part-1-remote-enumeration-of-network-interfaces-without-any-authentication/](https://www.cyber.airbus.com/the-oxid-resolver-part-1-remote-enumeration-of-network-interfaces-without-any-authentication/)
- [https://www.cyber.airbus.com/the-oxid-resolver-part-2-accessing-a-remote-object-inside-dcom/](https://www.cyber.airbus.com/the-oxid-resolver-part-2-accessing-a-remote-object-inside-dcom/)
- [https://0xffsec.com/handbook/services/msrpc/](https://0xffsec.com/handbook/services/msrpc/)
- [MS-RPC-Fuzzer (GitHub)](https://github.com/warpnet/MS-RPC-Fuzzer)

{{#include ../banners/hacktricks-training.md}}
