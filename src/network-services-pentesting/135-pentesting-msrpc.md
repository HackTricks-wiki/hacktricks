# 135, 593 - Pentesting MSRPC

{{#include ../banners/hacktricks-training.md}}

## Podstawowe informacje

Protokół Microsoft Remote Procedure Call (MSRPC), model klient-serwer umożliwiający programowi żądanie usługi od programu znajdującego się na innym komputerze bez zrozumienia specyfiki sieci, początkowo pochodził z oprogramowania open-source, a później został opracowany i objęty prawem autorskim przez Microsoft.

Mapper punktów końcowych RPC można uzyskać za pomocą portu TCP i UDP 135, SMB na TCP 139 i 445 (z sesją null lub uwierzytelnioną) oraz jako usługę internetową na porcie TCP 593.
```
135/tcp   open     msrpc         Microsoft Windows RPC
```
## Jak działa MSRPC?

Inicjowany przez aplikację kliencką, proces MSRPC polega na wywołaniu lokalnej procedury stub, która następnie współdziała z biblioteką uruchomieniową klienta, aby przygotować i przesłać żądanie do serwera. Obejmuje to konwersję parametrów na standardowy format Network Data Representation. Wybór protokołu transportowego jest określany przez bibliotekę uruchomieniową, jeśli serwer jest zdalny, zapewniając, że RPC jest dostarczane przez stos sieciowy.

![https://0xffsec.com/handbook/images/msrpc.png](https://0xffsec.com/handbook/images/msrpc.png)

## **Identyfikacja wystawionych usług RPC**

Wystawienie usług RPC przez TCP, UDP, HTTP i SMB można określić, zapytując usługę lokalizatora RPC oraz poszczególne punkty końcowe. Narzędzia takie jak rpcdump ułatwiają identyfikację unikalnych usług RPC, oznaczonych wartościami **IFID**, ujawniając szczegóły usługi i powiązania komunikacyjne:
```
D:\rpctools> rpcdump [-p port] <IP>
**IFID**: 5a7b91f8-ff00-11d0-a9b2-00c04fb6e6fc version 1.0
Annotation: Messenger Service
UUID: 00000000-0000-0000-0000-000000000000
Binding: ncadg_ip_udp:<IP>[1028]
```
Dostęp do usługi lokalizatora RPC jest włączony przez określone protokoły: ncacn_ip_tcp i ncadg_ip_udp do dostępu przez port 135, ncacn_np dla połączeń SMB oraz ncacn_http dla komunikacji RPC opartej na sieci web. Poniższe polecenia ilustrują wykorzystanie modułów Metasploit do audytowania i interakcji z usługami MSRPC, koncentrując się głównie na porcie 135:
```bash
use auxiliary/scanner/dcerpc/endpoint_mapper
use auxiliary/scanner/dcerpc/hidden
use auxiliary/scanner/dcerpc/management
use auxiliary/scanner/dcerpc/tcp_dcerpc_auditor
rpcdump.py <IP> -p 135
```
Wszystkie opcje z wyjątkiem `tcp_dcerpc_auditor` są specjalnie zaprojektowane do atakowania MSRPC na porcie 135.

#### Znaczące interfejsy RPC

- **IFID**: 12345778-1234-abcd-ef00-0123456789ab
- **Named Pipe**: `\pipe\lsarpc`
- **Opis**: Interfejs LSA, używany do enumeracji użytkowników.
- **IFID**: 3919286a-b10c-11d0-9ba8-00c04fd92ef5
- **Named Pipe**: `\pipe\lsarpc`
- **Opis**: Interfejs LSA Directory Services (DS), używany do enumeracji domen i relacji zaufania.
- **IFID**: 12345778-1234-abcd-ef00-0123456789ac
- **Named Pipe**: `\pipe\samr`
- **Opis**: Interfejs LSA SAMR, używany do uzyskiwania dostępu do publicznych elementów bazy danych SAM (np. nazwy użytkowników) i łamania haseł użytkowników niezależnie od polityki blokady konta.
- **IFID**: 1ff70682-0a51-30e8-076d-740be8cee98b
- **Named Pipe**: `\pipe\atsvc`
- **Opis**: Harmonogram zadań, używany do zdalnego wykonywania poleceń.
- **IFID**: 338cd001-2244-31f1-aaaa-900038001003
- **Named Pipe**: `\pipe\winreg`
- **Opis**: Usługa rejestru zdalnego, używana do uzyskiwania dostępu i modyfikacji rejestru systemowego.
- **IFID**: 367abb81-9844-35f1-ad32-98f038001003
- **Named Pipe**: `\pipe\svcctl`
- **Opis**: Menedżer kontroli usług i usługi serwera, używany do zdalnego uruchamiania i zatrzymywania usług oraz wykonywania poleceń.
- **IFID**: 4b324fc8-1670-01d3-1278-5a47bf6ee188
- **Named Pipe**: `\pipe\srvsvc`
- **Opis**: Menedżer kontroli usług i usługi serwera, używany do zdalnego uruchamiania i zatrzymywania usług oraz wykonywania poleceń.
- **IFID**: 4d9f4ab8-7d1c-11cf-861e-0020af6e7c57
- **Named Pipe**: `\pipe\epmapper`
- **Opis**: Interfejs DCOM, używany do łamania haseł i zbierania informacji za pomocą WM.

### Identyfikacja adresów IP

Używając [https://github.com/mubix/IOXIDResolver](https://github.com/mubix/IOXIDResolver), pochodzącego z [badania Airbus](https://www.cyber.airbus.com/the-oxid-resolver-part-1-remote-enumeration-of-network-interfaces-without-any-authentication/), możliwe jest nadużycie metody _**ServerAlive2**_ wewnątrz interfejsu _**IOXIDResolver**_.

Metoda ta była używana do uzyskiwania informacji o interfejsie jako adresie **IPv6** z maszyny HTB _APT_. Zobacz [tutaj](https://0xdf.gitlab.io/2021/04/10/htb-apt.html) dla opisu 0xdf APT, zawiera alternatywną metodę używającą rpcmap.py z [Impacket](https://github.com/SecureAuthCorp/impacket/) z _stringbinding_ (patrz powyżej).

### Wykonywanie RCE z ważnymi poświadczeniami

Możliwe jest wykonanie zdalnego kodu na maszynie, jeśli dostępne są poświadczenia ważnego użytkownika, używając [dcomexec.py](https://github.com/fortra/impacket/blob/master/examples/dcomexec.py) z frameworka impacket.

**Pamiętaj, aby spróbować z różnymi dostępnymi obiektami**

- ShellWindows
- ShellBrowserWindow
- MMC20

## Port 593

**rpcdump.exe** z [rpctools](https://resources.oreilly.com/examples/9780596510305/tree/master/tools/rpctools) może współdziałać z tym portem.

### Zautomatyzowana enumeracja interfejsów i dynamiczne generowanie klientów (NtObjectManager)

Guru PowerShell **James Forshaw** ujawnił większość wewnętrznych elementów Windows RPC w otwartym module *NtObjectManager*. Używając go, możesz w kilka sekund przekształcić dowolny serwer RPC DLL / EXE w **w pełni funkcjonalny stub klienta** – bez potrzeby IDL, MIDL ani ręcznego unmarshalling.
```powershell
# Install the module once
Install-Module NtObjectManager -Force

# Parse every RPC interface exported by the target binary
$rpcinterfaces = Get-RpcServer "C:\Windows\System32\efssvc.dll"
$rpcinterfaces | Format-Table Name,Uuid,Version,Procedures

# Inspect a single procedure (opnum 0)
$rpcinterfaces[0].Procedures[0] | Format-List *
```
Typowy wynik ujawnia typy parametrów dokładnie tak, jak pojawiają się w **MIDL** (np. `FC_C_WSTRING`, `FC_LONG`, `FC_BIND_CONTEXT`).

Gdy znasz interfejs, możesz **wygenerować gotowego do kompilacji klienta C#**:
```powershell
# Reverse the MS-EFSR (EfsRpc*) interface into C#
Format-RpcClient $rpcinterfaces[0] -Namespace MS_EFSR -OutputPath .\MS_EFSR.cs
```
W wygenerowanym stubie znajdziesz metody takie jak:
```csharp
public int EfsRpcOpenFileRaw(out Marshal.NdrContextHandle ctx, string FileName, int Flags) {
// marshals parameters & calls opnum 0
}
```
Pomocnik PowerShell `Get-RpcClient` może utworzyć **interaktywny obiekt klienta**, dzięki czemu możesz natychmiast wywołać procedurę:
```powershell
$client = Get-RpcClient $rpcinterfaces[0]
Connect-RpcClient $client -stringbinding 'ncacn_np:127.0.0.1[\\pipe\\efsrpc]' `
-AuthenticationLevel PacketPrivacy `
-AuthenticationType  WinNT  # NTLM auth

# Invoke the procedure → returns an authenticated context handle
$ctx = New-Object Marshal.NdrContextHandle
$client.EfsRpcOpenFileRaw([ref]$ctx, "\\\127.0.0.1\test", 0)
```
Autoryzacja (Kerberos / NTLM) i poziomy szyfrowania (`PacketIntegrity`, `PacketPrivacy`, …) mogą być dostarczane bezpośrednio za pomocą cmdletu `Connect-RpcClient` – idealne do **omijania deskryptorów zabezpieczeń** chroniących wysokoprzywilejowane nazwane rury.

---

### Fuzzing RPC z uwzględnieniem kontekstu (MS-RPC-Fuzzer)

Statyczna wiedza o interfejsie jest świetna, ale to, czego naprawdę chcesz, to **fuzzing z przewodnictwem pokrycia**, który rozumie *uchwyty kontekstu* i złożone łańcuchy parametrów. Projekt open-source **MS-RPC-Fuzzer** automatyzuje dokładnie ten proces:

1. Wymień każdy interfejs/procedurę eksportowaną przez docelowy plik binarny (`Get-RpcServer`).
2. Generuj dynamiczne klienty dla każdego interfejsu (`Format-RpcClient`).
3. Randomizuj parametry wejściowe (długość szerokich ciągów, zakresy liczb całkowitych, enumy), szanując oryginalny **typ NDR**.
4. Śledź *uchwyty kontekstu* zwracane przez jedno wywołanie, aby automatycznie zasilać procedury następcze.
5. Wykonuj wywołania o dużej objętości przeciwko wybranemu transportowi (ALPC, TCP, HTTP lub nazwanej rurze).
6. Rejestruj statusy wyjścia / błędy / przekroczenia czasu i eksportuj plik importu **Neo4j**, aby wizualizować relacje *interfejs → procedura → parametr* oraz klastry awarii.

Przykładowe uruchomienie (cel nazwanej rury):
```powershell
Invoke-MSRPCFuzzer -Pipe "\\.\pipe\efsrpc" -Auth NTLM `
-MinLen 1  -MaxLen 0x400 `
-Iterations 100000 `
-OutDir .\results
```
Jedno pisanie poza zakresem lub nieoczekiwany wyjątek zostanie natychmiast ujawniony z dokładnym opnum + zafałszowanym ładunkiem, który go wywołał – idealny punkt wyjścia do stabilnego dowodu koncepcji exploita.

> ⚠️  Wiele usług RPC działa w procesach uruchamianych jako **NT AUTHORITY\SYSTEM**. Każdy problem z bezpieczeństwem pamięci tutaj zazwyczaj prowadzi do lokalnej eskalacji uprawnień lub (gdy jest udostępniony przez SMB/135) *zdalnego wykonania kodu*.

---

## Odniesienia

- [Automating MS-RPC vulnerability research (2025, Incendium.rocks)](https://www.incendium.rocks/posts/Automating-MS-RPC-Vulnerability-Research/)
- [MS-RPC-Fuzzer – kontekstowy fuzzer RPC](https://github.com/warpnet/MS-RPC-Fuzzer)
- [Moduł PowerShell NtObjectManager](https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools/tree/master/NtObjectManager)

- [https://www.cyber.airbus.com/the-oxid-resolver-part-1-remote-enumeration-of-network-interfaces-without-any-authentication/](https://www.cyber.airbus.com/the-oxid-resolver-part-1-remote-enumeration-of-network-interfaces-without-any-authentication/)
- [https://www.cyber.airbus.com/the-oxid-resolver-part-2-accessing-a-remote-object-inside-dcom/](https://www.cyber.airbus.com/the-oxid-resolver-part-2-accessing-a-remote-object-inside-dcom/)
- [https://0xffsec.com/handbook/services/msrpc/](https://0xffsec.com/handbook/services/msrpc/)

{{#include ../banners/hacktricks-training.md}}
