# 135, 593 - Pentesting MSRPC

{{#include ../banners/hacktricks-training.md}}

## Podstawowe informacje

Protokół Microsoft Remote Procedure Call (MSRPC), model klient-serwer umożliwiający programowi żądanie usługi od programu znajdującego się na innym komputerze bez zrozumienia specyfiki sieci, początkowo pochodził z oprogramowania open-source, a później został opracowany i objęty prawem autorskim przez Microsoft.

Mapper punktów końcowych RPC można uzyskać za pomocą portu TCP i UDP 135, SMB na TCP 139 i 445 (z sesją null lub uwierzytelnioną) oraz jako usługa internetowa na porcie TCP 593.
```
135/tcp   open     msrpc         Microsoft Windows RPC
```
## Jak działa MSRPC?

Inicjowany przez aplikację kliencką, proces MSRPC polega na wywołaniu lokalnej procedury stub, która następnie współdziała z biblioteką uruchomieniową klienta, aby przygotować i przesłać żądanie do serwera. Obejmuje to konwersję parametrów na standardowy format Network Data Representation. Wybór protokołu transportowego jest określany przez bibliotekę uruchomieniową, jeśli serwer jest zdalny, zapewniając, że RPC jest dostarczane przez stos sieciowy.

![https://0xffsec.com/handbook/images/msrpc.png](https://0xffsec.com/handbook/images/msrpc.png)

## **Identyfikacja wystawionych usług RPC**

Ekspozycję usług RPC przez TCP, UDP, HTTP i SMB można określić, zapytując usługę lokalizatora RPC oraz poszczególne punkty końcowe. Narzędzia takie jak rpcdump ułatwiają identyfikację unikalnych usług RPC, oznaczonych wartościami **IFID**, ujawniając szczegóły usługi i powiązania komunikacyjne:
```
D:\rpctools> rpcdump [-p port] <IP>
**IFID**: 5a7b91f8-ff00-11d0-a9b2-00c04fb6e6fc version 1.0
Annotation: Messenger Service
UUID: 00000000-0000-0000-0000-000000000000
Binding: ncadg_ip_udp:<IP>[1028]
```
Dostęp do usługi lokalizatora RPC jest włączony za pomocą określonych protokołów: ncacn_ip_tcp i ncadg_ip_udp do dostępu przez port 135, ncacn_np dla połączeń SMB oraz ncacn_http dla komunikacji RPC opartej na sieci web. Poniższe polecenia ilustrują wykorzystanie modułów Metasploit do audytowania i interakcji z usługami MSRPC, koncentrując się głównie na porcie 135:
```bash
use auxiliary/scanner/dcerpc/endpoint_mapper
use auxiliary/scanner/dcerpc/hidden
use auxiliary/scanner/dcerpc/management
use auxiliary/scanner/dcerpc/tcp_dcerpc_auditor
rpcdump.py <IP> -p 135
```
Wszystkie opcje z wyjątkiem `tcp_dcerpc_auditor` są specjalnie zaprojektowane do atakowania MSRPC na porcie 135.

#### Znaczące interfejsy RPC

- **IFID**: 12345778-1234-abcd-ef00-0123456789ab
- **Named Pipe**: `\pipe\lsarpc`
- **Opis**: Interfejs LSA, używany do enumeracji użytkowników.
- **IFID**: 3919286a-b10c-11d0-9ba8-00c04fd92ef5
- **Named Pipe**: `\pipe\lsarpc`
- **Opis**: Interfejs LSA Directory Services (DS), używany do enumeracji domen i relacji zaufania.
- **IFID**: 12345778-1234-abcd-ef00-0123456789ac
- **Named Pipe**: `\pipe\samr`
- **Opis**: Interfejs LSA SAMR, używany do uzyskiwania dostępu do publicznych elementów bazy danych SAM (np. nazwy użytkowników) i łamania haseł użytkowników niezależnie od polityki blokady konta.
- **IFID**: 1ff70682-0a51-30e8-076d-740be8cee98b
- **Named Pipe**: `\pipe\atsvc`
- **Opis**: Harmonogram zadań, używany do zdalnego wykonywania poleceń.
- **IFID**: 338cd001-2244-31f1-aaaa-900038001003
- **Named Pipe**: `\pipe\winreg`
- **Opis**: Usługa rejestru zdalnego, używana do uzyskiwania dostępu i modyfikowania rejestru systemowego.
- **IFID**: 367abb81-9844-35f1-ad32-98f038001003
- **Named Pipe**: `\pipe\svcctl`
- **Opis**: Menedżer kontroli usług i usługi serwera, używany do zdalnego uruchamiania i zatrzymywania usług oraz wykonywania poleceń.
- **IFID**: 4b324fc8-1670-01d3-1278-5a47bf6ee188
- **Named Pipe**: `\pipe\srvsvc`
- **Opis**: Menedżer kontroli usług i usługi serwera, używany do zdalnego uruchamiania i zatrzymywania usług oraz wykonywania poleceń.
- **IFID**: 4d9f4ab8-7d1c-11cf-861e-0020af6e7c57
- **Named Pipe**: `\pipe\epmapper`
- **Opis**: Interfejs DCOM, używany do łamania haseł i zbierania informacji za pomocą WM.

### Identyfikacja adresów IP

Używając [https://github.com/mubix/IOXIDResolver](https://github.com/mubix/IOXIDResolver), pochodzącego z [badania Airbus](https://www.cyber.airbus.com/the-oxid-resolver-part-1-remote-enumeration-of-network-interfaces-without-any-authentication/), możliwe jest nadużycie metody _**ServerAlive2**_ wewnątrz interfejsu _**IOXIDResolver**_.

Metoda ta była używana do uzyskiwania informacji o interfejsie jako adresie **IPv6** z maszyny HTB _APT_. Zobacz [tutaj](https://0xdf.gitlab.io/2021/04/10/htb-apt.html) dla opisu 0xdf APT, który zawiera alternatywną metodę używającą rpcmap.py z [Impacket](https://github.com/SecureAuthCorp/impacket/) z _stringbinding_ (patrz powyżej).

### Wykonywanie RCE z ważnymi poświadczeniami

Możliwe jest wykonanie zdalnego kodu na maszynie, jeśli dostępne są poświadczenia ważnego użytkownika, używając [dcomexec.py](https://github.com/fortra/impacket/blob/master/examples/dcomexec.py) z frameworka impacket.

**Pamiętaj, aby spróbować z różnymi dostępnymi obiektami**

- ShellWindows
- ShellBrowserWindow
- MMC20

## Port 593

**rpcdump.exe** z [rpctools](https://resources.oreilly.com/examples/9780596510305/tree/master/tools/rpctools) może współdziałać z tym portem.

## Zautomatyzowane fuzzowanie interfejsów MSRPC

Interfejsy MS-RPC ujawniają dużą i często niedokumentowaną powierzchnię ataku. Otwarty moduł PowerShell [MS-RPC-Fuzzer](https://github.com/warpnet/MS-RPC-Fuzzer) oparty na `NtObjectManager` Jamesa Forshawa, *dynamicznie* tworzy stuby klienta RPC z metadanych interfejsu, które są już obecne w binariach systemu Windows. Gdy stub istnieje, moduł może bombardować każdą procedurę z mutowanymi danymi wejściowymi i rejestrować wyniki, co umożliwia **powtarzalne, dużej skali fuzzowanie punktów końcowych RPC bez pisania ani jednej linii IDL**.

### 1. Inwentaryzacja interfejsów
```powershell
# Import the module (download / git clone first)
Import-Module .\MS-RPC-Fuzzer.psm1

# Parse a single binary
Get-RpcServerData -Target "C:\Windows\System32\efssvc.dll" -OutPath .\output

# Or crawl the whole %SystemRoot%\System32 directory
Get-RpcServerData -OutPath .\output
```
`Get-RpcServerData` wyodrębni UUID, wersję, ciągi powiązań (named-pipe / TCP / HTTP) oraz **pełne prototypy procedur** dla każdego interfejsu, z którym się spotka, i zapisze je w `rpcServerData.json`.

### 2. Uruchom fuzzer
```powershell
'.\output\rpcServerData.json' |
Invoke-RpcFuzzer -OutPath .\output `
-MinStrLen 100  -MaxStrLen 1000 `
-MinIntSize 9999 -MaxIntSize 99999
```
Relewantne opcje:

* `-MinStrLen` / `-MaxStrLen` – zakres rozmiaru dla generowanych ciągów
* `-MinIntSize` / `-MaxIntSize` – zakres wartości dla zmutowanych liczb całkowitych (przydatne do testowania przepełnienia)
* `-Sorted` – wykonuj procedury w kolejności, która uwzględnia **zależności parametrów**, aby wyniki jednego wywołania mogły służyć jako dane wejściowe dla następnego (dramatycznie zwiększa dostępne ścieżki)

Fuzzer implementuje 2 strategie:

1. **Default fuzzer** – losowe wartości prymitywne + domyślne instancje dla typów złożonych
2. **Sorted fuzzer**  – uporządkowanie z uwzględnieniem zależności (zobacz `docs/Procedure dependency design.md`)

Każde wywołanie jest zapisywane atomowo do `log.txt`; po awarii **ostatnia linia natychmiast informuje o problematycznej procedurze**. Wynik każdego wywołania jest również klasyfikowany do trzech plików JSON:

* `allowed.json` – wywołanie zakończone sukcesem i zwrócone dane
* `denied.json`  – serwer odpowiedział *Access Denied*
* `error.json`   – inny błąd / awaria

### 3. Wizualizacja z Neo4j
```powershell
'.\output\allowed.json' |
Import-DataToNeo4j -Neo4jHost 192.168.56.10:7474 -Neo4jUsername neo4j
```
`Import-DataToNeo4j` konwertuje artefakty JSON na strukturę grafu, gdzie:

* Serwery RPC, interfejsy i procedury są **węzłami**
* Interakcje (`ALLOWED`, `DENIED`, `ERROR`) są **relacjami**

Zapytania Cypher mogą być następnie używane do szybkiego wykrywania niebezpiecznych procedur lub do odtworzenia dokładnego łańcucha wywołań, który poprzedzał awarię.

⚠️  Fuzzer jest *destrukcyjny*: spodziewaj się awarii usług, a nawet BSOD – zawsze uruchamiaj go w izolowanym zrzucie VM.


### Zautomatyzowana enumeracja interfejsów i dynamiczna generacja klienta (NtObjectManager)

Guru PowerShell **James Forshaw** ujawnił większość wewnętrznych elementów RPC Windows w otwartoźródłowym module *NtObjectManager*. Używając go, możesz w kilka sekund przekształcić dowolny DLL / EXE serwera RPC w **w pełni funkcjonalny stub klienta** – bez potrzeby IDL, MIDL czy ręcznego unmarshalling.
```powershell
# Install the module once
Install-Module NtObjectManager -Force

# Parse every RPC interface exported by the target binary
$rpcinterfaces = Get-RpcServer "C:\Windows\System32\efssvc.dll"
$rpcinterfaces | Format-Table Name,Uuid,Version,Procedures

# Inspect a single procedure (opnum 0)
$rpcinterfaces[0].Procedures[0] | Format-List *
```
Typowy wynik ujawnia typy parametrów dokładnie tak, jak pojawiają się w **MIDL** (np. `FC_C_WSTRING`, `FC_LONG`, `FC_BIND_CONTEXT`).

Gdy znasz interfejs, możesz **wygenerować gotowego do kompilacji klienta C#**:
```powershell
# Reverse the MS-EFSR (EfsRpc*) interface into C#
Format-RpcClient $rpcinterfaces[0] -Namespace MS_EFSR -OutputPath .\MS_EFSR.cs
```
W wygenerowanym stubie znajdziesz metody takie jak:
```csharp
public int EfsRpcOpenFileRaw(out Marshal.NdrContextHandle ctx, string FileName, int Flags) {
// marshals parameters & calls opnum 0
}
```
Pomocnik PowerShell `Get-RpcClient` może utworzyć **interaktywny obiekt klienta**, dzięki czemu możesz natychmiast wywołać procedurę:
```powershell
$client = Get-RpcClient $rpcinterfaces[0]
Connect-RpcClient $client -stringbinding 'ncacn_np:127.0.0.1[\\pipe\\efsrpc]' `
-AuthenticationLevel PacketPrivacy `
-AuthenticationType  WinNT  # NTLM auth

# Invoke the procedure → returns an authenticated context handle
$ctx = New-Object Marshal.NdrContextHandle
$client.EfsRpcOpenFileRaw([ref]$ctx, "\\\127.0.0.1\test", 0)
```
Autoryzacja (Kerberos / NTLM) i poziomy szyfrowania (`PacketIntegrity`, `PacketPrivacy`, …) mogą być dostarczane bezpośrednio za pomocą cmdletu `Connect-RpcClient` – idealne do **omijania deskryptorów zabezpieczeń** chroniących wysokoprywatne nazwane rury.

### Fuzzing RPC z uwzględnieniem kontekstu (MS-RPC-Fuzzer)

Statyczna wiedza o interfejsie jest świetna, ale to, czego naprawdę chcesz, to **fuzzing z przewodnictwem pokrycia**, który rozumie *uchwyty kontekstu* i złożone łańcuchy parametrów. Projekt open-source **MS-RPC-Fuzzer** automatyzuje dokładnie ten proces:

1. Wymień każdy interfejs/procedurę eksportowaną przez docelowy plik binarny (`Get-RpcServer`).
2. Generuj dynamiczne klientów dla każdego interfejsu (`Format-RpcClient`).
3. Randomizuj parametry wejściowe (długość szerokich ciągów, zakresy liczb całkowitych, enumy), szanując oryginalny **typ NDR**.
4. Śledź *uchwyty kontekstu* zwracane przez jedno wywołanie, aby automatycznie zasilać procedury następcze.
5. Wykonuj wywołania o dużej objętości przeciwko wybranemu transportowi (ALPC, TCP, HTTP lub nazwanej rurze).
6. Rejestruj statusy wyjścia / błędy / przekroczenia czasu i eksportuj plik importu **Neo4j**, aby wizualizować relacje *interfejs → procedura → parametr* oraz klastry awarii.

Przykładowe uruchomienie (cel nazwanej rury):
```powershell
Invoke-MSRPCFuzzer -Pipe "\\.\pipe\efsrpc" -Auth NTLM `
-MinLen 1  -MaxLen 0x400 `
-Iterations 100000 `
-OutDir .\results
```
Jedno pisanie poza zakresem lub nieoczekiwany wyjątek zostanie natychmiast ujawniony z dokładnym opnum + zafałszowanym ładunkiem, który go wywołał – idealny punkt wyjścia do stabilnego dowodu koncepcji exploita.

> ⚠️  Wiele usług RPC działa w procesach uruchamianych jako **NT AUTHORITY\SYSTEM**.  Każdy problem z bezpieczeństwem pamięci tutaj zazwyczaj przekłada się na lokalne podniesienie uprawnień lub (gdy jest wystawiony przez SMB/135) *zdalne wykonanie kodu*.


## Odniesienia

- [Automating MS-RPC vulnerability research (2025, Incendium.rocks)](https://www.incendium.rocks/posts/Automating-MS-RPC-Vulnerability-Research/)
- [MS-RPC-Fuzzer – kontekstowy fuzzer RPC](https://github.com/warpnet/MS-RPC-Fuzzer)
- [Moduł PowerShell NtObjectManager](https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools/tree/master/NtObjectManager)
- [https://www.cyber.airbus.com/the-oxid-resolver-part-1-remote-enumeration-of-network-interfaces-without-any-authentication/](https://www.cyber.airbus.com/the-oxid-resolver-part-1-remote-enumeration-of-network-interfaces-without-any-authentication/)
- [https://www.cyber.airbus.com/the-oxid-resolver-part-2-accessing-a-remote-object-inside-dcom/](https://www.cyber.airbus.com/the-oxid-resolver-part-2-accessing-a-remote-object-inside-dcom/)
- [https://0xffsec.com/handbook/services/msrpc/](https://0xffsec.com/handbook/services/msrpc/)
- [MS-RPC-Fuzzer (GitHub)](https://github.com/warpnet/MS-RPC-Fuzzer)

{{#include ../banners/hacktricks-training.md}}
