# 135, 593 - Pentesting MSRPC

{{#include ../banners/hacktricks-training.md}}

## 基本情報

Microsoft Remote Procedure Call (MSRPC) プロトコルは、クライアント-サーバーモデルであり、プログラムが別のコンピュータ上にあるプログラムからサービスを要求することを可能にし、ネットワークの詳細を理解することなく機能します。このプロトコルは、最初はオープンソースソフトウェアから派生し、その後Microsoftによって開発され、著作権が付与されました。

RPCエンドポイントマッパーは、TCPおよびUDPポート135、TCP 139および445のSMB（ヌルまたは認証されたセッションで）、およびTCPポート593のWebサービスを介してアクセスできます。
```
135/tcp   open     msrpc         Microsoft Windows RPC
```
## MSRPCはどのように機能しますか？

クライアントアプリケーションによって開始されるMSRPCプロセスは、ローカルスタブプロシージャを呼び出し、その後クライアントランタイムライブラリと対話して、リクエストをサーバーに準備して送信します。これには、パラメータを標準のネットワークデータ表現形式に変換することが含まれます。サーバーがリモートの場合、トランスポートプロトコルの選択はランタイムライブラリによって決定され、RPCがネットワークスタックを通じて配信されることを保証します。

![https://0xffsec.com/handbook/images/msrpc.png](https://0xffsec.com/handbook/images/msrpc.png)

## **公開されているRPCサービスの特定**

TCP、UDP、HTTP、SMBを介したRPCサービスの公開は、RPCロケータサービスおよび個々のエンドポイントをクエリすることによって判断できます。rpcdumpなどのツールは、**IFID**値によって示されるユニークなRPCサービスの特定を容易にし、サービスの詳細と通信バインディングを明らかにします：
```
D:\rpctools> rpcdump [-p port] <IP>
**IFID**: 5a7b91f8-ff00-11d0-a9b2-00c04fb6e6fc version 1.0
Annotation: Messenger Service
UUID: 00000000-0000-0000-0000-000000000000
Binding: ncadg_ip_udp:<IP>[1028]
```
RPCロケータサービスへのアクセスは、特定のプロトコルを通じて有効になります：ncacn_ip_tcpおよびncadg_ip_udpはポート135を介してアクセスするため、ncacn_npはSMB接続用、ncacn_httpはWebベースのRPC通信用です。以下のコマンドは、主にポート135に焦点を当てて、MSRPCサービスを監査および対話するためのMetasploitモジュールの利用を示しています：
```bash
use auxiliary/scanner/dcerpc/endpoint_mapper
use auxiliary/scanner/dcerpc/hidden
use auxiliary/scanner/dcerpc/management
use auxiliary/scanner/dcerpc/tcp_dcerpc_auditor
rpcdump.py <IP> -p 135
```
全てのオプションは `tcp_dcerpc_auditor` を除いて、ポート135のMSRPCをターゲットにするために特別に設計されています。

#### 注目すべきRPCインターフェース

- **IFID**: 12345778-1234-abcd-ef00-0123456789ab
- **Named Pipe**: `\pipe\lsarpc`
- **Description**: LSAインターフェース、ユーザーを列挙するために使用されます。
- **IFID**: 3919286a-b10c-11d0-9ba8-00c04fd92ef5
- **Named Pipe**: `\pipe\lsarpc`
- **Description**: LSAディレクトリサービス（DS）インターフェース、ドメインと信頼関係を列挙するために使用されます。
- **IFID**: 12345778-1234-abcd-ef00-0123456789ac
- **Named Pipe**: `\pipe\samr`
- **Description**: LSA SAMRインターフェース、公開SAMデータベース要素（例：ユーザー名）にアクセスし、アカウントロックアウトポリシーに関係なくユーザーパスワードをブルートフォースするために使用されます。
- **IFID**: 1ff70682-0a51-30e8-076d-740be8cee98b
- **Named Pipe**: `\pipe\atsvc`
- **Description**: タスクスケジューラ、リモートでコマンドを実行するために使用されます。
- **IFID**: 338cd001-2244-31f1-aaaa-900038001003
- **Named Pipe**: `\pipe\winreg`
- **Description**: リモートレジストリサービス、システムレジストリにアクセスし、変更するために使用されます。
- **IFID**: 367abb81-9844-35f1-ad32-98f038001003
- **Named Pipe**: `\pipe\svcctl`
- **Description**: サービスコントロールマネージャーとサーバーサービス、リモートでサービスを開始および停止し、コマンドを実行するために使用されます。
- **IFID**: 4b324fc8-1670-01d3-1278-5a47bf6ee188
- **Named Pipe**: `\pipe\srvsvc`
- **Description**: サービスコントロールマネージャーとサーバーサービス、リモートでサービスを開始および停止し、コマンドを実行するために使用されます。
- **IFID**: 4d9f4ab8-7d1c-11cf-861e-0020af6e7c57
- **Named Pipe**: `\pipe\epmapper`
- **Description**: DCOMインターフェース、ブルートフォースパスワードグラインディングとWMを介した情報収集に使用されます。

### IPアドレスの特定

[https://github.com/mubix/IOXIDResolver](https://github.com/mubix/IOXIDResolver)を使用すると、[Airbus research](https://www.cyber.airbus.com/the-oxid-resolver-part-1-remote-enumeration-of-network-interfaces-without-any-authentication/)からの_**ServerAlive2**_メソッドを_**IOXIDResolver**_インターフェース内で悪用することが可能です。

このメソッドは、HTBボックス_APT_から**IPv6**アドレスとしてインターフェース情報を取得するために使用されました。0xdfのAPTの詳細については[こちら](https://0xdf.gitlab.io/2021/04/10/htb-apt.html)を参照してください。rpcmap.pyを使用した代替メソッドが含まれています。[Impacket](https://github.com/SecureAuthCorp/impacket/)の_stringbinding_（上記参照）を使用しています。

### 有効な資格情報を使用したRCEの実行

有効なユーザーの資格情報が利用可能な場合、[dcomexec.py](https://github.com/fortra/impacket/blob/master/examples/dcomexec.py)を使用して、マシン上でリモートコードを実行することが可能です。

**利用可能な異なるオブジェクトで試すことを忘れないでください**

- ShellWindows
- ShellBrowserWindow
- MMC20

## ポート593

[rpctools](https://resources.oreilly.com/examples/9780596510305/tree/master/tools/rpctools)の**rpcdump.exe**は、このポートと対話できます。

## MSRPCインターフェースの自動ファジング

MS-RPCインターフェースは、大規模でしばしば文書化されていない攻撃面を公開しています。オープンソースの[MS-RPC-Fuzzer](https://github.com/warpnet/MS-RPC-Fuzzer) PowerShellモジュールは、James Forshawの`NtObjectManager`を基にして、Windowsバイナリに既に存在するインターフェースメタデータからRPCクライアントスタブを*動的に*作成します。スタブが存在するようになると、モジュールは変異した入力で各手続きを攻撃し、その結果を記録することができ、**IDLの1行も書かずにRPCエンドポイントの再現可能な大規模ファジングが可能になります**。

### 1. インターフェースのインベントリ
```powershell
# Import the module (download / git clone first)
Import-Module .\MS-RPC-Fuzzer.psm1

# Parse a single binary
Get-RpcServerData -Target "C:\Windows\System32\efssvc.dll" -OutPath .\output

# Or crawl the whole %SystemRoot%\System32 directory
Get-RpcServerData -OutPath .\output
```
`Get-RpcServerData` は、UUID、バージョン、バインディング文字列（名前付きパイプ / TCP / HTTP）および **すべてのインターフェースに対する完全な手続きプロトタイプ** を抽出し、それらを `rpcServerData.json` に保存します。

### 2. ファズァを実行する
```powershell
'.\output\rpcServerData.json' |
Invoke-RpcFuzzer -OutPath .\output `
-MinStrLen 100  -MaxStrLen 1000 `
-MinIntSize 9999 -MaxIntSize 99999
```
関連オプション:

* `-MinStrLen` / `-MaxStrLen` – 生成された文字列のサイズ範囲
* `-MinIntSize` / `-MaxIntSize` – 変異した整数の値範囲（オーバーフローテストに便利）
* `-Sorted` – **パラメータ依存関係**を考慮した順序で手続きを実行し、1つの呼び出しの出力が次の入力として使用できるようにする（到達可能なパスが劇的に増加）

ファズァは2つの戦略を実装しています:

1. **デフォルトファズァ** – ランダムなプリミティブ値 + 複雑な型のデフォルトインスタンス
2. **ソートファズァ**  – 依存関係を考慮した順序付け（`docs/Procedure dependency design.md`を参照）

すべての呼び出しは`log.txt`に原子的に書き込まれます; クラッシュ後、**最後の行が問題のある手続きを即座に教えてくれます**。各呼び出しの結果は3つのJSONファイルに分類されます:

* `allowed.json` – 呼び出しが成功し、データを返しました
* `denied.json`  – サーバーが*アクセス拒否*で応答しました
* `error.json`   – その他のエラー / クラッシュ

### 3. Neo4jで可視化する
```powershell
'.\output\allowed.json' |
Import-DataToNeo4j -Neo4jHost 192.168.56.10:7474 -Neo4jUsername neo4j
```
`Import-DataToNeo4j` は、JSON アーティファクトをグラフ構造に変換します。ここで：

* RPC サーバー、インターフェース、手続きは **ノード** です
* インタラクション（`ALLOWED`、`DENIED`、`ERROR`）は **リレーションシップ** です

Cypher クエリを使用して、危険な手続きを迅速に特定したり、クラッシュの前に行われた呼び出しの正確なチェーンを再生したりできます。

⚠️  ファズザーは *破壊的* です：サービスのクラッシュや BSOD を予期してください – 常に隔離された VM スナップショットで実行してください。


### 自動インターフェース列挙と動的クライアント生成 (NtObjectManager)

PowerShell の達人 **James Forshaw** は、オープンソースの *NtObjectManager* モジュール内のほとんどの Windows RPC 内部を公開しました。これを使用すると、任意の RPC サーバー DLL / EXE を数秒で **完全機能のクライアントスタブ** に変換できます – IDL、MIDL、または手動のアンマーシャリングは不要です。
```powershell
# Install the module once
Install-Module NtObjectManager -Force

# Parse every RPC interface exported by the target binary
$rpcinterfaces = Get-RpcServer "C:\Windows\System32\efssvc.dll"
$rpcinterfaces | Format-Table Name,Uuid,Version,Procedures

# Inspect a single procedure (opnum 0)
$rpcinterfaces[0].Procedures[0] | Format-List *
```
典型的な出力は、**MIDL**に表示されるパラメータタイプを正確に示します（例：`FC_C_WSTRING`、`FC_LONG`、`FC_BIND_CONTEXT`）。

インターフェースがわかれば、**コンパイル可能なC#クライアントを生成できます**：
```powershell
# Reverse the MS-EFSR (EfsRpc*) interface into C#
Format-RpcClient $rpcinterfaces[0] -Namespace MS_EFSR -OutputPath .\MS_EFSR.cs
```
生成されたスタブ内には、次のようなメソッドが含まれています：
```csharp
public int EfsRpcOpenFileRaw(out Marshal.NdrContextHandle ctx, string FileName, int Flags) {
// marshals parameters & calls opnum 0
}
```
PowerShellヘルパー`Get-RpcClient`は、**インタラクティブクライアントオブジェクト**を作成できるため、手続きをすぐに呼び出すことができます：
```powershell
$client = Get-RpcClient $rpcinterfaces[0]
Connect-RpcClient $client -stringbinding 'ncacn_np:127.0.0.1[\\pipe\\efsrpc]' `
-AuthenticationLevel PacketPrivacy `
-AuthenticationType  WinNT  # NTLM auth

# Invoke the procedure → returns an authenticated context handle
$ctx = New-Object Marshal.NdrContextHandle
$client.EfsRpcOpenFileRaw([ref]$ctx, "\\\127.0.0.1\test", 0)
```
認証 (Kerberos / NTLM) と暗号化レベル (`PacketIntegrity`, `PacketPrivacy`, …) は `Connect-RpcClient` cmdlet を介して直接提供できます – 高特権の名前付きパイプを保護する **セキュリティ記述子をバイパスする** のに理想的です。

### コンテキスト対応RPCファジング (MS-RPC-Fuzzer)

静的インターフェースの知識は素晴らしいですが、実際に求めているのは *コンテキストハンドル* と複雑なパラメータチェーンを理解する **カバレッジガイドファジング** です。オープンソースの **MS-RPC-Fuzzer** プロジェクトは、まさにそのワークフローを自動化します：

1. ターゲットバイナリによってエクスポートされたすべてのインターフェース/手続きを列挙します (`Get-RpcServer`)。
2. 各インターフェースの動的クライアントを生成します (`Format-RpcClient`)。
3. 元の **NDRタイプ** を尊重しながら、入力パラメータ（ワイド文字列の長さ、整数範囲、列挙型）をランダム化します。
4. 1回の呼び出しで返された *コンテキストハンドル* を追跡し、フォローアップ手続きを自動的に供給します。
5. 選択したトランスポート（ALPC、TCP、HTTP または 名前付きパイプ）に対して高ボリュームの呼び出しを行います。
6. 終了ステータス/障害/タイムアウトをログに記録し、*インターフェース → 手続き → パラメータ* の関係とクラッシュクラスターを視覚化するために **Neo4j** インポートファイルをエクスポートします。

例の実行（名前付きパイプターゲット）：
```powershell
Invoke-MSRPCFuzzer -Pipe "\\.\pipe\efsrpc" -Auth NTLM `
-MinLen 1  -MaxLen 0x400 `
-Iterations 100000 `
-OutDir .\results
```
単一のバッファ外書き込みまたは予期しない例外は、トリガーした正確な opnum + ファズペイロードとともに即座に表面化します - 安定した概念実証エクスプロイトの完璧な出発点です。

> ⚠️  多くの RPC サービスは **NT AUTHORITY\SYSTEM** として実行されるプロセスで動作します。ここでのメモリ安全性の問題は、通常、ローカル特権昇格または (SMB/135 経由で公開される場合) *リモートコード実行* に変換されます。

## 参考文献

- [Automating MS-RPC vulnerability research (2025, Incendium.rocks)](https://www.incendium.rocks/posts/Automating-MS-RPC-Vulnerability-Research/)
- [MS-RPC-Fuzzer – context-aware RPC fuzzer](https://github.com/warpnet/MS-RPC-Fuzzer)
- [NtObjectManager PowerShell module](https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools/tree/master/NtObjectManager)
- [https://www.cyber.airbus.com/the-oxid-resolver-part-1-remote-enumeration-of-network-interfaces-without-any-authentication/](https://www.cyber.airbus.com/the-oxid-resolver-part-1-remote-enumeration-of-network-interfaces-without-any-authentication/)
- [https://www.cyber.airbus.com/the-oxid-resolver-part-2-accessing-a-remote-object-inside-dcom/](https://www.cyber.airbus.com/the-oxid-resolver-part-2-accessing-a-remote-object-inside-dcom/)
- [https://0xffsec.com/handbook/services/msrpc/](https://0xffsec.com/handbook/services/msrpc/)
- [MS-RPC-Fuzzer (GitHub)](https://github.com/warpnet/MS-RPC-Fuzzer)

{{#include ../banners/hacktricks-training.md}}
