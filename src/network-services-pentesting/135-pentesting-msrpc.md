# 135, 593 - Pentesting MSRPC

{{#include ../banners/hacktricks-training.md}}

## Temel Bilgiler

Microsoft Uzaktan Prosedür Çağrısı (MSRPC) protokolü, bir programın başka bir bilgisayarda bulunan bir programdan hizmet talep etmesini sağlayan bir istemci-sunucu modelidir ve ağın ayrıntılarını anlamadan çalışır. İlk olarak açık kaynak yazılımdan türetilmiş ve daha sonra Microsoft tarafından geliştirilip telif hakkı alınmıştır.

RPC uç noktası haritalayıcısına TCP ve UDP port 135, SMB üzerinden TCP 139 ve 445 (boş veya kimlik doğrulamalı oturum ile) ve TCP port 593 üzerinden bir web hizmeti olarak erişilebilir.
```
135/tcp   open     msrpc         Microsoft Windows RPC
```
## MSRPC nasıl çalışır?

İstemci uygulaması tarafından başlatılan MSRPC süreci, istemci çalışma zamanı kütüphanesi ile etkileşime giren yerel bir stub prosedürünü çağırmayı içerir ve ardından isteği sunucuya hazırlayıp iletir. Bu, parametrelerin standart Ağ Veri Temsili formatına dönüştürülmesini içerir. Taşıma protokolü seçimi, sunucu uzaktaysa çalışma zamanı kütüphanesi tarafından belirlenir ve RPC'nin ağ yığını üzerinden iletilmesini sağlar.

![https://0xffsec.com/handbook/images/msrpc.png](https://0xffsec.com/handbook/images/msrpc.png)

## **Açık RPC Hizmetlerini Belirleme**

TCP, UDP, HTTP ve SMB üzerinden RPC hizmetlerinin açığı, RPC yer bulucu hizmeti ve bireysel uç noktalar sorgulanarak belirlenebilir. rpcdump gibi araçlar, **IFID** değerleri ile belirtilen benzersiz RPC hizmetlerinin tanımlanmasına yardımcı olur ve hizmet detayları ile iletişim bağlarını ortaya çıkarır:
```
D:\rpctools> rpcdump [-p port] <IP>
**IFID**: 5a7b91f8-ff00-11d0-a9b2-00c04fb6e6fc version 1.0
Annotation: Messenger Service
UUID: 00000000-0000-0000-0000-000000000000
Binding: ncadg_ip_udp:<IP>[1028]
```
RPC yer bulucu hizmetine erişim, belirli protokoller aracılığıyla etkinleştirilmiştir: ncacn_ip_tcp ve ncadg_ip_udp, port 135 üzerinden erişim için, ncacn_np SMB bağlantıları için ve ncacn_http web tabanlı RPC iletişimi için. Aşağıdaki komutlar, esasen port 135'e odaklanarak, MSRPC hizmetlerini denetlemek ve etkileşimde bulunmak için Metasploit modüllerinin kullanımını örneklemektedir:
```bash
use auxiliary/scanner/dcerpc/endpoint_mapper
use auxiliary/scanner/dcerpc/hidden
use auxiliary/scanner/dcerpc/management
use auxiliary/scanner/dcerpc/tcp_dcerpc_auditor
rpcdump.py <IP> -p 135
```
Tüm seçenekler `tcp_dcerpc_auditor` hariç, 135 numaralı porttaki MSRPC'yi hedef almak için özel olarak tasarlanmıştır.

#### Dikkate Değer RPC Arayüzleri

- **IFID**: 12345778-1234-abcd-ef00-0123456789ab
- **Named Pipe**: `\pipe\lsarpc`
- **Açıklama**: Kullanıcıları listelemek için kullanılan LSA arayüzü.
- **IFID**: 3919286a-b10c-11d0-9ba8-00c04fd92ef5
- **Named Pipe**: `\pipe\lsarpc`
- **Açıklama**: Alanları ve güven ilişkilerini listelemek için kullanılan LSA Dizin Hizmetleri (DS) arayüzü.
- **IFID**: 12345778-1234-abcd-ef00-0123456789ac
- **Named Pipe**: `\pipe\samr`
- **Açıklama**: Kamuya açık SAM veritabanı öğelerine (örneğin, kullanıcı adları) erişmek ve kullanıcı şifrelerini hesap kilitleme politikası gözetmeksizin zorlamak için kullanılan LSA SAMR arayüzü.
- **IFID**: 1ff70682-0a51-30e8-076d-740be8cee98b
- **Named Pipe**: `\pipe\atsvc`
- **Açıklama**: Uzakta komutları yürütmek için kullanılan görev zamanlayıcı.
- **IFID**: 338cd001-2244-31f1-aaaa-900038001003
- **Named Pipe**: `\pipe\winreg`
- **Açıklama**: Sistem kayıt defterine erişmek ve değiştirmek için kullanılan uzak kayıt defteri hizmeti.
- **IFID**: 367abb81-9844-35f1-ad32-98f038001003
- **Named Pipe**: `\pipe\svcctl`
- **Açıklama**: Uzakta hizmetleri başlatmak ve durdurmak ve komutları yürütmek için kullanılan hizmet kontrol yöneticisi ve sunucu hizmetleri.
- **IFID**: 4b324fc8-1670-01d3-1278-5a47bf6ee188
- **Named Pipe**: `\pipe\srvsvc`
- **Açıklama**: Uzakta hizmetleri başlatmak ve durdurmak ve komutları yürütmek için kullanılan hizmet kontrol yöneticisi ve sunucu hizmetleri.
- **IFID**: 4d9f4ab8-7d1c-11cf-861e-0020af6e7c57
- **Named Pipe**: `\pipe\epmapper`
- **Açıklama**: WM aracılığıyla zorla şifre kırma ve bilgi toplama için kullanılan DCOM arayüzü.

### IP adreslerini belirleme

[https://github.com/mubix/IOXIDResolver](https://github.com/mubix/IOXIDResolver) kullanarak, [Airbus araştırmasından](https://www.cyber.airbus.com/the-oxid-resolver-part-1-remote-enumeration-of-network-interfaces-without-any-authentication/) _**IOXIDResolver**_ arayüzü içindeki _**ServerAlive2**_ yöntemini kötüye kullanmak mümkündür.

Bu yöntem, HTB kutusu _APT_ 'den **IPv6** adresi gibi arayüz bilgilerini almak için kullanılmıştır. 0xdf APT yazımı için [buraya](https://0xdf.gitlab.io/2021/04/10/htb-apt.html) bakın, rpcmap.py kullanarak alternatif bir yöntem içermektedir [Impacket](https://github.com/SecureAuthCorp/impacket/) ile _stringbinding_ (yukarıya bakın).

### Geçerli kimlik bilgileri ile RCE yürütme

Geçerli bir kullanıcının kimlik bilgileri mevcutsa, [dcomexec.py](https://github.com/fortra/impacket/blob/master/examples/dcomexec.py) kullanarak bir makinede uzaktan kod yürütmek mümkündür.

**Mevcut farklı nesnelerle denemeyi unutmayın**

- ShellWindows
- ShellBrowserWindow
- MMC20

## Port 593

[rpctools](https://resources.oreilly.com/examples/9780596510305/tree/master/tools/rpctools) içindeki **rpcdump.exe** bu port ile etkileşimde bulunabilir.

## MSRPC Arayüzlerinin Otomatik Fuzzing'i

MS-RPC arayüzleri, büyük ve genellikle belgelenmemiş bir saldırı yüzeyi sunar. Açık kaynak [MS-RPC-Fuzzer](https://github.com/warpnet/MS-RPC-Fuzzer) PowerShell modülü, James Forshaw’ın `NtObjectManager`'ını kullanarak, Windows ikili dosyalarında zaten mevcut olan arayüz meta verilerinden *dinamik olarak* RPC istemci stub'ları oluşturur. Bir stub mevcut olduğunda, modül her prosedürü değiştirilmiş girdilerle bombardıman edebilir ve sonucu kaydedebilir, bu da **tek bir IDL satırı yazmadan RPC uç noktalarının tekrarlanabilir, büyük ölçekli fuzzing'ini mümkün kılar**.

### 1. Arayüzleri envanterleme
```powershell
# Import the module (download / git clone first)
Import-Module .\MS-RPC-Fuzzer.psm1

# Parse a single binary
Get-RpcServerData -Target "C:\Windows\System32\efssvc.dll" -OutPath .\output

# Or crawl the whole %SystemRoot%\System32 directory
Get-RpcServerData -OutPath .\output
```
`Get-RpcServerData`, karşılaştığı her arayüz için UUID, versiyon, bağlama dizgeleri (adlı boru / TCP / HTTP) ve **tam prosedür prototiplerini** çıkaracak ve bunları `rpcServerData.json` dosyasında saklayacaktır.

### 2. Fuzzer'ı çalıştırın
```powershell
'.\output\rpcServerData.json' |
Invoke-RpcFuzzer -OutPath .\output `
-MinStrLen 100  -MaxStrLen 1000 `
-MinIntSize 9999 -MaxIntSize 99999
```
İlgili seçenekler:

* `-MinStrLen` / `-MaxStrLen` – üretilen dizelerin boyut aralığı
* `-MinIntSize` / `-MaxIntSize` – değiştirilmiş tam sayıların değer aralığı (taşma testi için yararlıdır)
* `-Sorted` – bir çağrının çıktılarının bir sonraki çağrının girdileri olarak kullanılabilmesi için **parametre bağımlılıklarını** dikkate alarak prosedürleri bir sırayla yürütme (ulaşılabilir yolları dramatik şekilde artırır)

Fuzzer, 2 strateji uygular:

1. **Varsayılan fuzzer** – rastgele ilkel değerler + karmaşık türler için varsayılan örnekler
2. **Sıralı fuzzer**  – bağımlılık farkındalığına sahip sıralama (bkz. `docs/Procedure dependency design.md`)

Her çağrı atomik olarak `log.txt` dosyasına yazılır; bir çökmeden sonra **son satır hemen hatalı prosedürü bildirir**. Her çağrının sonucu da üç JSON dosyasına kategorize edilir:

* `allowed.json` – çağrı başarılı oldu ve veri döndü
* `denied.json`  – sunucu *Erişim Reddedildi* ile yanıt verdi
* `error.json`   – başka bir hata / çökme

### 3. Neo4j ile Görselleştir
```powershell
'.\output\allowed.json' |
Import-DataToNeo4j -Neo4jHost 192.168.56.10:7474 -Neo4jUsername neo4j
```
`Import-DataToNeo4j`, JSON artefaktlarını bir grafik yapısına dönüştürür:

* RPC sunucuları, arayüzler ve prosedürler **düğümlerdir**
* Etkileşimler (`ALLOWED`, `DENIED`, `ERROR`) **ilişkilerdir**

Cypher sorguları, tehlikeli prosedürleri hızlıca tespit etmek veya bir çökmeden önceki çağrı zincirini tam olarak yeniden oynatmak için kullanılabilir.

⚠️  Fuzzer *yıkıcıdır*: hizmet çöküşleri ve hatta BSOD'lar bekleyin – her zaman izole bir VM anlık görüntüsünde çalıştırın.


### Otomatik Arayüz Sayımı & Dinamik İstemci Üretimi (NtObjectManager)

PowerShell uzmanı **James Forshaw**, açık kaynak *NtObjectManager* modülü içinde Windows RPC iç yapılarının çoğunu ortaya çıkardı. Bunu kullanarak, herhangi bir RPC sunucu DLL / EXE'sini birkaç saniye içinde **tam özellikli bir istemci stub**'a dönüştürebilirsiniz – IDL, MIDL veya manuel ayrıştırma gerektirmez.
```powershell
# Install the module once
Install-Module NtObjectManager -Force

# Parse every RPC interface exported by the target binary
$rpcinterfaces = Get-RpcServer "C:\Windows\System32\efssvc.dll"
$rpcinterfaces | Format-Table Name,Uuid,Version,Procedures

# Inspect a single procedure (opnum 0)
$rpcinterfaces[0].Procedures[0] | Format-List *
```
Tipik çıktı, parametre türlerini **MIDL**'de göründüğü gibi tam olarak açığa çıkarır (örneğin, `FC_C_WSTRING`, `FC_LONG`, `FC_BIND_CONTEXT`).

Arayüzü bildiğinizde, **derlemeye hazır bir C# istemcisi oluşturabilirsiniz**:
```powershell
# Reverse the MS-EFSR (EfsRpc*) interface into C#
Format-RpcClient $rpcinterfaces[0] -Namespace MS_EFSR -OutputPath .\MS_EFSR.cs
```
Üretilen stub içinde şu yöntemleri bulacaksınız:
```csharp
public int EfsRpcOpenFileRaw(out Marshal.NdrContextHandle ctx, string FileName, int Flags) {
// marshals parameters & calls opnum 0
}
```
PowerShell yardımcı programı `Get-RpcClient`, **etkileşimli bir istemci nesnesi** oluşturabilir, böylece prosedürü hemen çağırabilirsiniz:
```powershell
$client = Get-RpcClient $rpcinterfaces[0]
Connect-RpcClient $client -stringbinding 'ncacn_np:127.0.0.1[\\pipe\\efsrpc]' `
-AuthenticationLevel PacketPrivacy `
-AuthenticationType  WinNT  # NTLM auth

# Invoke the procedure → returns an authenticated context handle
$ctx = New-Object Marshal.NdrContextHandle
$client.EfsRpcOpenFileRaw([ref]$ctx, "\\\127.0.0.1\test", 0)
```
Authentication (Kerberos / NTLM) ve şifreleme seviyeleri (`PacketIntegrity`, `PacketPrivacy`, …) doğrudan `Connect-RpcClient` cmdlet'i aracılığıyla sağlanabilir – yüksek ayrıcalıklı adlandırılmış boruları koruyan **Güvenlik Tanımlayıcılarını** atlamak için idealdir.

### Bağlam Bilgisine Duyarlı RPC Fuzzing (MS-RPC-Fuzzer)

Statik arayüz bilgisi harika, ancak gerçekten istediğiniz şey **kapsam rehberli fuzzing**'dir; bu, *bağlam tutucularını* ve karmaşık parametre zincirlerini anlar. Açık kaynak **MS-RPC-Fuzzer** projesi tam olarak bu iş akışını otomatikleştirir:

1. Hedef ikili tarafından dışa aktarılan her arayüz/prosedürü listeleyin (`Get-RpcServer`).
2. Her arayüz için dinamik istemciler oluşturun (`Format-RpcClient`).
3. Orijinal **NDR türünü** dikkate alarak giriş parametrelerini rastgele değiştirin (geniş dizeler uzunluğu, tam sayı aralıkları, enumlar).
4. Bir çağrıdan dönen *bağlam tutucularını* takip edin ve takip eden prosedürleri otomatik olarak besleyin.
5. Seçilen taşıma (ALPC, TCP, HTTP veya adlandırılmış boru) karşısında yüksek hacimli çağrılar yapın.
6. Çıkış durumlarını / hataları / zaman aşımını kaydedin ve *arayüz → prosedür → parametre* ilişkilerini ve çökme kümelerini görselleştirmek için bir **Neo4j** içe aktarma dosyası dışa aktarın.

Örnek çalışma (adlandırılmış boru hedefi):
```powershell
Invoke-MSRPCFuzzer -Pipe "\\.\pipe\efsrpc" -Auth NTLM `
-MinLen 1  -MaxLen 0x400 `
-Iterations 100000 `
-OutDir .\results
```
Bir tek out-of-bounds yazma veya beklenmedik bir istisna, tetikleyen tam opnum + fuzzed yük ile hemen ortaya çıkacaktır - kararlı bir kanıt konsepti istismarı için mükemmel bir başlangıç noktası.

> ⚠️  Birçok RPC hizmeti **NT AUTHORITY\SYSTEM** olarak çalışan süreçlerde yürütülmektedir. Buradaki herhangi bir bellek güvenliği sorunu genellikle yerel ayrıcalık yükselmesine veya (SMB/135 üzerinden açıldığında) *uzaktan kod yürütme* ile sonuçlanır.


## Referanslar

- [Automating MS-RPC vulnerability research (2025, Incendium.rocks)](https://www.incendium.rocks/posts/Automating-MS-RPC-Vulnerability-Research/)
- [MS-RPC-Fuzzer – context-aware RPC fuzzer](https://github.com/warpnet/MS-RPC-Fuzzer)
- [NtObjectManager PowerShell module](https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools/tree/master/NtObjectManager)
- [https://www.cyber.airbus.com/the-oxid-resolver-part-1-remote-enumeration-of-network-interfaces-without-any-authentication/](https://www.cyber.airbus.com/the-oxid-resolver-part-1-remote-enumeration-of-network-interfaces-without-any-authentication/)
- [https://www.cyber.airbus.com/the-oxid-resolver-part-2-accessing-a-remote-object-inside-dcom/](https://www.cyber.airbus.com/the-oxid-resolver-part-2-accessing-a-remote-object-inside-dcom/)
- [https://0xffsec.com/handbook/services/msrpc/](https://0xffsec.com/handbook/services/msrpc/)
- [MS-RPC-Fuzzer (GitHub)](https://github.com/warpnet/MS-RPC-Fuzzer)

{{#include ../banners/hacktricks-training.md}}
