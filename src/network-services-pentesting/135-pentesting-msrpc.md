# 135, 593 - Pentesting MSRPC

{{#include ../banners/hacktricks-training.md}}

## Основна інформація

Протокол Microsoft Remote Procedure Call (MSRPC), клієнт-серверна модель, що дозволяє програмі запитувати послугу у програми, розташованої на іншому комп'ютері, не розуміючи специфіки мережі, спочатку був отриманий з програмного забезпечення з відкритим кодом, а пізніше розроблений і захищений авторським правом компанією Microsoft.

Картографічний кінцевий пункт RPC можна отримати через TCP і UDP порт 135, SMB на TCP 139 і 445 (з нульовою або автентифікованою сесією), а також як веб-сервіс на TCP порті 593.
```
135/tcp   open     msrpc         Microsoft Windows RPC
```
## Як працює MSRPC?

Ініційований клієнтським додатком, процес MSRPC включає виклик локальної стуб-процедури, яка взаємодіє з бібліотекою виконання клієнта для підготовки та передачі запиту на сервер. Це включає перетворення параметрів у стандартний формат представлення даних мережі. Вибір транспортного протоколу визначається бібліотекою виконання, якщо сервер віддалений, що забезпечує доставку RPC через мережевий стек.

![https://0xffsec.com/handbook/images/msrpc.png](https://0xffsec.com/handbook/images/msrpc.png)

## **Визначення відкритих RPC-сервісів**

Відкритість RPC-сервісів через TCP, UDP, HTTP та SMB може бути визначена шляхом запиту до служби локатора RPC та окремих кінцевих точок. Інструменти, такі як rpcdump, полегшують ідентифікацію унікальних RPC-сервісів, позначених значеннями **IFID**, що розкриває деталі сервісу та зв'язки комунікації:
```
D:\rpctools> rpcdump [-p port] <IP>
**IFID**: 5a7b91f8-ff00-11d0-a9b2-00c04fb6e6fc version 1.0
Annotation: Messenger Service
UUID: 00000000-0000-0000-0000-000000000000
Binding: ncadg_ip_udp:<IP>[1028]
```
Доступ до служби локатора RPC забезпечується через специфічні протоколи: ncacn_ip_tcp та ncadg_ip_udp для доступу через порт 135, ncacn_np для SMB з'єднань та ncacn_http для веб-орієнтованої RPC комунікації. Наступні команди ілюструють використання модулів Metasploit для аудиту та взаємодії з MSRPC службами, в основному зосереджуючись на порту 135:
```bash
use auxiliary/scanner/dcerpc/endpoint_mapper
use auxiliary/scanner/dcerpc/hidden
use auxiliary/scanner/dcerpc/management
use auxiliary/scanner/dcerpc/tcp_dcerpc_auditor
rpcdump.py <IP> -p 135
```
Усі опції, крім `tcp_dcerpc_auditor`, спеціально розроблені для націлювання на MSRPC на порту 135.

#### Помітні RPC інтерфейси

- **IFID**: 12345778-1234-abcd-ef00-0123456789ab
- **Named Pipe**: `\pipe\lsarpc`
- **Опис**: Інтерфейс LSA, використовується для перерахунку користувачів.
- **IFID**: 3919286a-b10c-11d0-9ba8-00c04fd92ef5
- **Named Pipe**: `\pipe\lsarpc`
- **Опис**: Інтерфейс LSA Directory Services (DS), використовується для перерахунку доменів і довірчих відносин.
- **IFID**: 12345778-1234-abcd-ef00-0123456789ac
- **Named Pipe**: `\pipe\samr`
- **Опис**: Інтерфейс LSA SAMR, використовується для доступу до елементів публічної бази даних SAM (наприклад, імена користувачів) і брутфорсу паролів користувачів незалежно від політики блокування облікових записів.
- **IFID**: 1ff70682-0a51-30e8-076d-740be8cee98b
- **Named Pipe**: `\pipe\atsvc`
- **Опис**: Планувальник завдань, використовується для віддаленого виконання команд.
- **IFID**: 338cd001-2244-31f1-aaaa-900038001003
- **Named Pipe**: `\pipe\winreg`
- **Опис**: Служба віддаленого реєстру, використовується для доступу та зміни системного реєстру.
- **IFID**: 367abb81-9844-35f1-ad32-98f038001003
- **Named Pipe**: `\pipe\svcctl`
- **Опис**: Менеджер контролю служб і серверні служби, використовується для віддаленого запуску та зупинки служб і виконання команд.
- **IFID**: 4b324fc8-1670-01d3-1278-5a47bf6ee188
- **Named Pipe**: `\pipe\srvsvc`
- **Опис**: Менеджер контролю служб і серверні служби, використовується для віддаленого запуску та зупинки служб і виконання команд.
- **IFID**: 4d9f4ab8-7d1c-11cf-861e-0020af6e7c57
- **Named Pipe**: `\pipe\epmapper`
- **Опис**: Інтерфейс DCOM, використовується для брутфорсу паролів і збору інформації через WM.

### Визначення IP-адрес

Використовуючи [https://github.com/mubix/IOXIDResolver](https://github.com/mubix/IOXIDResolver), що походить з [досліджень Airbus](https://www.cyber.airbus.com/the-oxid-resolver-part-1-remote-enumeration-of-network-interfaces-without-any-authentication/), можливо зловживати методом _**ServerAlive2**_ всередині інтерфейсу _**IOXIDResolver**_.

Цей метод використовувався для отримання інформації про інтерфейс у вигляді **IPv6** адреси з HTB боксу _APT_. Дивіться [тут](https://0xdf.gitlab.io/2021/04/10/htb-apt.html) для опису 0xdf APT, він включає альтернативний метод використання rpcmap.py з [Impacket](https://github.com/SecureAuthCorp/impacket/) з _stringbinding_ (див. вище).

### Виконання RCE з дійсними обліковими даними

Можливо виконати віддалений код на машині, якщо доступні облікові дані дійсного користувача, використовуючи [dcomexec.py](https://github.com/fortra/impacket/blob/master/examples/dcomexec.py) з фреймворку impacket.

**Не забудьте спробувати з різними доступними об'єктами**

- ShellWindows
- ShellBrowserWindow
- MMC20

## Порт 593

**rpcdump.exe** з [rpctools](https://resources.oreilly.com/examples/9780596510305/tree/master/tools/rpctools) може взаємодіяти з цим портом.

## Автоматизоване фуззингування інтерфейсів MSRPC

Інтерфейси MS-RPC відкривають великий і часто не задокументований вектор атаки. Відкритий модуль PowerShell [MS-RPC-Fuzzer](https://github.com/warpnet/MS-RPC-Fuzzer) базується на `NtObjectManager` Джеймса Форшоу, щоб *динамічно* створювати RPC клієнтські стуби з метаданих інтерфейсу, які вже присутні в Windows бінарниках. Як тільки стуб існує, модуль може обстрілювати кожну процедуру з мутаційованими вхідними даними та реєструвати результати, що робить **відтворюване, масштабне фуззингування RPC кінцевих точок можливим без написання жодного рядка IDL**.

### 1. Інвентаризація інтерфейсів
```powershell
# Import the module (download / git clone first)
Import-Module .\MS-RPC-Fuzzer.psm1

# Parse a single binary
Get-RpcServerData -Target "C:\Windows\System32\efssvc.dll" -OutPath .\output

# Or crawl the whole %SystemRoot%\System32 directory
Get-RpcServerData -OutPath .\output
```
`Get-RpcServerData` витягне UUID, версію, рядки зв'язку (named-pipe / TCP / HTTP) та **повні прототипи процедур** для кожного інтерфейсу, з яким він зіткнеться, і зберігатиме їх у `rpcServerData.json`.

### 2. Запустіть фузер
```powershell
'.\output\rpcServerData.json' |
Invoke-RpcFuzzer -OutPath .\output `
-MinStrLen 100  -MaxStrLen 1000 `
-MinIntSize 9999 -MaxIntSize 99999
```
Відповідні параметри:

* `-MinStrLen` / `-MaxStrLen` – діапазон розміру для згенерованих рядків
* `-MinIntSize` / `-MaxIntSize` – діапазон значень для змінених цілих чисел (корисно для тестування переповнення)
* `-Sorted` – виконувати процедури в порядку, що враховує **залежності параметрів**, щоб виходи одного виклику могли слугувати вхідними даними для наступного (значно збільшує досяжні шляхи)

Fuzzer реалізує 2 стратегії:

1. **Default fuzzer** – випадкові примітивні значення + стандартні екземпляри для складних типів
2. **Sorted fuzzer**  – порядок, що враховує залежності (див. `docs/Procedure dependency design.md`)

Кожен виклик записується атомарно в `log.txt`; після збою **остання стрічка негайно повідомляє про проблемну процедуру**. Результат кожного виклику також категоризується в три JSON файли:

* `allowed.json` – виклик успішний і повернув дані
* `denied.json`  – сервер відповів *Access Denied*
* `error.json`   – будь-яка інша помилка / збій

### 3. Візуалізуйте з Neo4j
```powershell
'.\output\allowed.json' |
Import-DataToNeo4j -Neo4jHost 192.168.56.10:7474 -Neo4jUsername neo4j
```
`Import-DataToNeo4j` перетворює JSON артефакти в графову структуру, де:

* RPC сервери, інтерфейси та процедури є **вузлами**
* Взаємодії (`ALLOWED`, `DENIED`, `ERROR`) є **відносинами**

Запити Cypher можна використовувати для швидкого виявлення небезпечних процедур або для відтворення точної послідовності викликів, які передували збою.

⚠️  Fuzzer є *руйнівним*: очікуйте збоїв сервісу та навіть BSOD – завжди запускайте його в ізольованій знімку ВМ.


### Автоматизована енумерація інтерфейсів та динамічна генерація клієнтів (NtObjectManager)

Гуру PowerShell **James Forshaw** розкрив більшість внутрішніх механізмів Windows RPC у відкритому *модулі NtObjectManager*. Використовуючи його, ви можете перетворити будь-який RPC сервер DLL / EXE на **повнофункціональний клієнтський шаблон** за кілька секунд – без IDL, MIDL або ручного розпакування.
```powershell
# Install the module once
Install-Module NtObjectManager -Force

# Parse every RPC interface exported by the target binary
$rpcinterfaces = Get-RpcServer "C:\Windows\System32\efssvc.dll"
$rpcinterfaces | Format-Table Name,Uuid,Version,Procedures

# Inspect a single procedure (opnum 0)
$rpcinterfaces[0].Procedures[0] | Format-List *
```
Типовий вихід показує типи параметрів точно так, як вони з'являються в **MIDL** (наприклад, `FC_C_WSTRING`, `FC_LONG`, `FC_BIND_CONTEXT`).

Якщо ви знаєте інтерфейс, ви можете **згенерувати готовий до компіляції C# клієнт**:
```powershell
# Reverse the MS-EFSR (EfsRpc*) interface into C#
Format-RpcClient $rpcinterfaces[0] -Namespace MS_EFSR -OutputPath .\MS_EFSR.cs
```
Всередині створеного стуба ви знайдете методи, такі як:
```csharp
public int EfsRpcOpenFileRaw(out Marshal.NdrContextHandle ctx, string FileName, int Flags) {
// marshals parameters & calls opnum 0
}
```
PowerShell допоміжний засіб `Get-RpcClient` може створити **інтерактивний об'єкт клієнта**, щоб ви могли викликати процедуру негайно:
```powershell
$client = Get-RpcClient $rpcinterfaces[0]
Connect-RpcClient $client -stringbinding 'ncacn_np:127.0.0.1[\\pipe\\efsrpc]' `
-AuthenticationLevel PacketPrivacy `
-AuthenticationType  WinNT  # NTLM auth

# Invoke the procedure → returns an authenticated context handle
$ctx = New-Object Marshal.NdrContextHandle
$client.EfsRpcOpenFileRaw([ref]$ctx, "\\\127.0.0.1\test", 0)
```
Аутентифікація (Kerberos / NTLM) та рівні шифрування (`PacketIntegrity`, `PacketPrivacy`, …) можуть бути надані безпосередньо через cmdlet `Connect-RpcClient` – ідеально для **обходу дескрипторів безпеки**, які захищають канали з високими привілеями.

### Контекстно-обізнаний RPC Fuzzing (MS-RPC-Fuzzer)

Статичні знання про інтерфейси чудові, але те, що вам дійсно потрібно, це **fuzzing з орієнтацією на покриття**, який розуміє *контекстні дескриптори* та складні ланцюги параметрів. Відкритий проект **MS-RPC-Fuzzer** автоматизує саме цей робочий процес:

1. Перерахувати кожен інтерфейс/процедуру, експортовану цільовим бінарним файлом (`Get-RpcServer`).
2. Генерувати динамічні клієнти для кожного інтерфейсу (`Format-RpcClient`).
3. Випадковизувати вхідні параметри (довжина широких рядків, діапазони цілих чисел, перерахування), дотримуючись оригінального **NDR типу**.
4. Відстежувати *контекстні дескриптори*, повернуті одним викликом, щоб автоматично подавати їх у наступні процедури.
5. Виконувати виклики з високим обсягом проти обраного транспорту (ALPC, TCP, HTTP або іменований канал).
6. Логувати статуси виходу / помилки / тайм-аути та експортувати файл імпорту **Neo4j** для візуалізації відносин *інтерфейс → процедура → параметр* та кластерів збоїв.

Приклад виконання (цільовий іменований канал):
```powershell
Invoke-MSRPCFuzzer -Pipe "\\.\pipe\efsrpc" -Auth NTLM `
-MinLen 1  -MaxLen 0x400 `
-Iterations 100000 `
-OutDir .\results
```
Один запис за межами межі або несподіване виключення буде відображено негайно з точним opnum + спотвореним корисним навантаженням, яке його викликало – ідеальна відправна точка для стабільного експериментального експлойту.

> ⚠️  Багато RPC-сервісів виконуються в процесах, що працюють під **NT AUTHORITY\SYSTEM**. Будь-яка проблема з безпекою пам'яті тут зазвичай призводить до підвищення локальних привілеїв або (коли відкрито через SMB/135) *віддаленого виконання коду*.


## Посилання

- [Автоматизація дослідження вразливостей MS-RPC (2025, Incendium.rocks)](https://www.incendium.rocks/posts/Automating-MS-RPC-Vulnerability-Research/)
- [MS-RPC-Fuzzer – контекстно-обізнаний RPC fuzzer](https://github.com/warpnet/MS-RPC-Fuzzer)
- [Модуль PowerShell NtObjectManager](https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools/tree/master/NtObjectManager)
- [https://www.cyber.airbus.com/the-oxid-resolver-part-1-remote-enumeration-of-network-interfaces-without-any-authentication/](https://www.cyber.airbus.com/the-oxid-resolver-part-1-remote-enumeration-of-network-interfaces-without-any-authentication/)
- [https://www.cyber.airbus.com/the-oxid-resolver-part-2-accessing-a-remote-object-inside-dcom/](https://www.cyber.airbus.com/the-oxid-resolver-part-2-accessing-a-remote-object-inside-dcom/)
- [https://0xffsec.com/handbook/services/msrpc/](https://0xffsec.com/handbook/services/msrpc/)
- [MS-RPC-Fuzzer (GitHub)](https://github.com/warpnet/MS-RPC-Fuzzer)

{{#include ../banners/hacktricks-training.md}}
