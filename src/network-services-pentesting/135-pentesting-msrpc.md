# 135, 593 - Pentesting MSRPC

{{#include ../banners/hacktricks-training.md}}

## Osnovne informacije

Protokol Microsoft Remote Procedure Call (MSRPC), model klijent-server koji omogućava programu da zatraži uslugu od programa koji se nalazi na drugom računaru bez razumevanja specifičnosti mreže, prvobitno je izveden iz softvera otvorenog koda, a kasnije je razvijen i zaštićen autorskim pravima od strane Microsoft-a.

RPC endpoint mapper može se pristupiti putem TCP i UDP porta 135, SMB na TCP 139 i 445 (sa null ili autentifikovanom sesijom), i kao web servis na TCP portu 593.
```
135/tcp   open     msrpc         Microsoft Windows RPC
```
## Kako funkcioniše MSRPC?

Iniciran od strane klijentske aplikacije, MSRPC proces uključuje pozivanje lokalne stub procedure koja zatim komunicira sa klijentskom runtime bibliotekom kako bi pripremila i prenela zahtev serveru. Ovo uključuje konvertovanje parametara u standardni format Network Data Representation. Izbor transportnog protokola određuje runtime biblioteka ako je server udaljen, osiguravajući da se RPC isporučuje kroz mrežni stek.

![https://0xffsec.com/handbook/images/msrpc.png](https://0xffsec.com/handbook/images/msrpc.png)

## **Identifikacija izloženih RPC usluga**

Izloženost RPC usluga preko TCP, UDP, HTTP i SMB može se utvrditi upitom RPC locator servisa i pojedinačnih krajnjih tačaka. Alati kao što je rpcdump olakšavaju identifikaciju jedinstvenih RPC usluga, označenih **IFID** vrednostima, otkrivajući detalje o usluzi i komunikacionim vezama:
```
D:\rpctools> rpcdump [-p port] <IP>
**IFID**: 5a7b91f8-ff00-11d0-a9b2-00c04fb6e6fc version 1.0
Annotation: Messenger Service
UUID: 00000000-0000-0000-0000-000000000000
Binding: ncadg_ip_udp:<IP>[1028]
```
Pristup RPC lokator servisu je omogućen kroz specifične protokole: ncacn_ip_tcp i ncadg_ip_udp za pristup preko porta 135, ncacn_np za SMB konekcije, i ncacn_http za web-baziranu RPC komunikaciju. Sledeće komande ilustruju korišćenje Metasploit modula za audiranje i interakciju sa MSRPC servisima, prvenstveno fokusirajući se na port 135:
```bash
use auxiliary/scanner/dcerpc/endpoint_mapper
use auxiliary/scanner/dcerpc/hidden
use auxiliary/scanner/dcerpc/management
use auxiliary/scanner/dcerpc/tcp_dcerpc_auditor
rpcdump.py <IP> -p 135
```
Sve opcije osim `tcp_dcerpc_auditor` su posebno dizajnirane za ciljanje MSRPC na portu 135.

#### Značajni RPC interfejsi

- **IFID**: 12345778-1234-abcd-ef00-0123456789ab
- **Named Pipe**: `\pipe\lsarpc`
- **Opis**: LSA interfejs, koristi se za enumeraciju korisnika.
- **IFID**: 3919286a-b10c-11d0-9ba8-00c04fd92ef5
- **Named Pipe**: `\pipe\lsarpc`
- **Opis**: LSA Directory Services (DS) interfejs, koristi se za enumeraciju domena i odnosa poverenja.
- **IFID**: 12345778-1234-abcd-ef00-0123456789ac
- **Named Pipe**: `\pipe\samr`
- **Opis**: LSA SAMR interfejs, koristi se za pristup javnim elementima SAM baze podataka (npr. korisnička imena) i brute-force lozinkama korisnika bez obzira na politiku zaključavanja naloga.
- **IFID**: 1ff70682-0a51-30e8-076d-740be8cee98b
- **Named Pipe**: `\pipe\atsvc`
- **Opis**: Planer zadataka, koristi se za daljinsko izvršavanje komandi.
- **IFID**: 338cd001-2244-31f1-aaaa-900038001003
- **Named Pipe**: `\pipe\winreg`
- **Opis**: Usluga daljinskog registra, koristi se za pristup i modifikaciju sistemskog registra.
- **IFID**: 367abb81-9844-35f1-ad32-98f038001003
- **Named Pipe**: `\pipe\svcctl`
- **Opis**: Menadžer kontrole usluga i server usluga, koristi se za daljinsko pokretanje i zaustavljanje usluga i izvršavanje komandi.
- **IFID**: 4b324fc8-1670-01d3-1278-5a47bf6ee188
- **Named Pipe**: `\pipe\srvsvc`
- **Opis**: Menadžer kontrole usluga i server usluga, koristi se za daljinsko pokretanje i zaustavljanje usluga i izvršavanje komandi.
- **IFID**: 4d9f4ab8-7d1c-11cf-861e-0020af6e7c57
- **Named Pipe**: `\pipe\epmapper`
- **Opis**: DCOM interfejs, koristi se za brute-force lozinke i prikupljanje informacija putem WM.

### Identifikacija IP adresa

Korišćenjem [https://github.com/mubix/IOXIDResolver](https://github.com/mubix/IOXIDResolver), dolazi iz [Airbus istraživanja](https://www.cyber.airbus.com/the-oxid-resolver-part-1-remote-enumeration-of-network-interfaces-without-any-authentication/) moguće je zloupotrebiti _**ServerAlive2**_ metodu unutar _**IOXIDResolver**_ interfejsa.

Ova metoda je korišćena za dobijanje informacija o interfejsu kao **IPv6** adresa iz HTB kutije _APT_. Pogledajte [ovde](https://0xdf.gitlab.io/2021/04/10/htb-apt.html) za 0xdf APT izveštaj, uključuje alternativnu metodu koristeći rpcmap.py iz [Impacket](https://github.com/SecureAuthCorp/impacket/) sa _stringbinding_ (vidi iznad).

### Izvršavanje RCE sa validnim kredencijalima

Moguće je izvršiti daljinski kod na mašini, ako su dostupni kredencijali validnog korisnika koristeći [dcomexec.py](https://github.com/fortra/impacket/blob/master/examples/dcomexec.py) iz impacket frameworka.

**Zapamtite da pokušate sa različitim dostupnim objektima**

- ShellWindows
- ShellBrowserWindow
- MMC20

## Port 593

**rpcdump.exe** iz [rpctools](https://resources.oreilly.com/examples/9780596510305/tree/master/tools/rpctools) može interagovati sa ovim portom.

## Automatsko Fuzzing MSRPC Interfejsa

MS-RPC interfejsi izlažu veliku i često nedokumentovanu površinu napada. Open-source [MS-RPC-Fuzzer](https://github.com/warpnet/MS-RPC-Fuzzer) PowerShell modul se oslanja na `NtObjectManager` Jamesa Forshawa da *dinamički* kreira RPC klijentske stubove iz metapodataka interfejsa koji su već prisutni u Windows binarnim datotekama. Kada stub postoji, modul može bombardovati svaku proceduru mutiranim ulazima i zabeležiti ishod, omogućavajući **reproducibilno, masovno fuzzing RPC krajnjih tačaka bez pisanja jedne linije IDL**.

### 1. Inventar interfejsa
```powershell
# Import the module (download / git clone first)
Import-Module .\MS-RPC-Fuzzer.psm1

# Parse a single binary
Get-RpcServerData -Target "C:\Windows\System32\efssvc.dll" -OutPath .\output

# Or crawl the whole %SystemRoot%\System32 directory
Get-RpcServerData -OutPath .\output
```
`Get-RpcServerData` će izvući UUID, verziju, binding stringove (named-pipe / TCP / HTTP) i **pune procedure prototipe** za svaki interfejs koji naiđe i sačuvati ih u `rpcServerData.json`.

### 2. Pokrenite fuzzer
```powershell
'.\output\rpcServerData.json' |
Invoke-RpcFuzzer -OutPath .\output `
-MinStrLen 100  -MaxStrLen 1000 `
-MinIntSize 9999 -MaxIntSize 99999
```
Relevant options:

* `-MinStrLen` / `-MaxStrLen` – opseg veličine za generisane stringove
* `-MinIntSize` / `-MaxIntSize` – opseg vrednosti za mutirane cele brojeve (korisno za testiranje prelivanja)
* `-Sorted` – izvršava procedure u redosledu koji poštuje **zavisnosti parametara** tako da izlazi jednog poziva mogu poslužiti kao ulazi sledećeg (dramatično povećava dostupne puteve)

Fuzzer implementira 2 strategije:

1. **Default fuzzer** – nasumične primitivne vrednosti + podrazumevane instance za složene tipove
2. **Sorted fuzzer**  – redosled svestan zavisnosti (vidi `docs/Procedure dependency design.md`)

Svaki poziv se zapisuje atomarno u `log.txt`; nakon pada, **poslednja linija odmah govori koji je postupak izazvao problem**. Rezultat svakog poziva je takođe kategorizovan u tri JSON datoteke:

* `allowed.json` – poziv je uspeo i vratio podatke
* `denied.json`  – server je odgovorio sa *Access Denied*
* `error.json`   – bilo koja druga greška / pad

### 3. Visualise with Neo4j
```powershell
'.\output\allowed.json' |
Import-DataToNeo4j -Neo4jHost 192.168.56.10:7474 -Neo4jUsername neo4j
```
`Import-DataToNeo4j` konvertuje JSON artefakte u graf strukturu gde:

* RPC serveri, interfejsi i procedure su **čvorovi**
* Interakcije (`ALLOWED`, `DENIED`, `ERROR`) su **odnosi**

Cypher upiti se mogu koristiti za brzo prepoznavanje opasnih procedura ili za ponavljanje tačnog lanca poziva koji je prethodio padu.

⚠️  Fuzzer je *destruktivan*: očekujte padove usluga i čak BSOD-ove – uvek ga pokrećite u izolovanom VM snimku.


### Automatizovana enumeracija interfejsa i dinamička generacija klijenta (NtObjectManager)

PowerShell guru **James Forshaw** je otkrio većinu Windows RPC internih funkcija unutar open-source *NtObjectManager* modula. Koristeći ga, možete pretvoriti bilo koju RPC server DLL / EXE u **klijent stub** sa punim funkcijama za nekoliko sekundi – bez IDL, MIDL ili ručnog unmarshalling-a.
```powershell
# Install the module once
Install-Module NtObjectManager -Force

# Parse every RPC interface exported by the target binary
$rpcinterfaces = Get-RpcServer "C:\Windows\System32\efssvc.dll"
$rpcinterfaces | Format-Table Name,Uuid,Version,Procedures

# Inspect a single procedure (opnum 0)
$rpcinterfaces[0].Procedures[0] | Format-List *
```
Tipičan izlaz otkriva tipove parametara tačno onako kako se pojavljuju u **MIDL** (npr. `FC_C_WSTRING`, `FC_LONG`, `FC_BIND_CONTEXT`).

Kada znate interfejs, možete **generisati C# klijent spreman za kompajliranje**:
```powershell
# Reverse the MS-EFSR (EfsRpc*) interface into C#
Format-RpcClient $rpcinterfaces[0] -Namespace MS_EFSR -OutputPath .\MS_EFSR.cs
```
Unutar proizvedenog stub-a naći ćete metode kao što su:
```csharp
public int EfsRpcOpenFileRaw(out Marshal.NdrContextHandle ctx, string FileName, int Flags) {
// marshals parameters & calls opnum 0
}
```
PowerShell pomoćni alat `Get-RpcClient` može kreirati **interaktivni klijent objekat** tako da možete odmah pozvati proceduru:
```powershell
$client = Get-RpcClient $rpcinterfaces[0]
Connect-RpcClient $client -stringbinding 'ncacn_np:127.0.0.1[\\pipe\\efsrpc]' `
-AuthenticationLevel PacketPrivacy `
-AuthenticationType  WinNT  # NTLM auth

# Invoke the procedure → returns an authenticated context handle
$ctx = New-Object Marshal.NdrContextHandle
$client.EfsRpcOpenFileRaw([ref]$ctx, "\\\127.0.0.1\test", 0)
```
Autentifikacija (Kerberos / NTLM) i nivoi enkripcije (`PacketIntegrity`, `PacketPrivacy`, …) mogu se direktno obezbediti putem `Connect-RpcClient` cmdleta – idealno za **obići sigurnosne deskriptore** koji štite cevi sa visokim privilegijama.

### Fuzzing RPC-a sa svesti o kontekstu (MS-RPC-Fuzzer)

Staticko poznavanje interfejsa je odlično, ali ono što zaista želite je **fuzzing vođen pokrivenošću** koji razume *kontekstualne handle-ove* i složene lance parametara. Open-source projekat **MS-RPC-Fuzzer** automatski obezbeđuje upravo taj radni tok:

1. Enumerisati svaki interfejs/proceduru koju izvozi ciljni binarni fajl (`Get-RpcServer`).
2. Generisati dinamičke klijente za svaki interfejs (`Format-RpcClient`).
3. Randomizovati ulazne parametre (dužina širokih stringova, opsezi celih brojeva, enumeracije) uz poštovanje originalnog **NDR tipa**.
4. Pratiti *kontekstualne handle-ove* koje vraća jedan poziv kako bi se automatski hranili prateći postupci.
5. Izvršiti pozive velikog obima protiv odabranog transporta (ALPC, TCP, HTTP ili imenovana cev).
6. Zapisati izlazne statuse / greške / vremenske limite i izvesti **Neo4j** import fajl za vizualizaciju *interfejs → procedura → parametar* odnosa i klastera rušenja.

Primer izvršavanja (cilj sa imenovanom cevi):
```powershell
Invoke-MSRPCFuzzer -Pipe "\\.\pipe\efsrpc" -Auth NTLM `
-MinLen 1  -MaxLen 0x400 `
-Iterations 100000 `
-OutDir .\results
```
Jedno pisanje van granica ili neočekivana izuzetak će odmah biti prikazani sa tačnim opnum + fuzzed payload koji ga je izazvao – savršena polazna tačka za stabilan proof-of-concept exploit.

> ⚠️  Mnogi RPC servisi se izvršavaju u procesima koji rade kao **NT AUTHORITY\SYSTEM**. Svaki problem sa bezbednošću memorije ovde obično se prevodi u lokalno eskaliranje privilegija ili (kada je izložen preko SMB/135) *daljinsko izvršavanje koda*.


## Reference

- [Automating MS-RPC vulnerability research (2025, Incendium.rocks)](https://www.incendium.rocks/posts/Automating-MS-RPC-Vulnerability-Research/)
- [MS-RPC-Fuzzer – context-aware RPC fuzzer](https://github.com/warpnet/MS-RPC-Fuzzer)
- [NtObjectManager PowerShell module](https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools/tree/master/NtObjectManager)
- [https://www.cyber.airbus.com/the-oxid-resolver-part-1-remote-enumeration-of-network-interfaces-without-any-authentication/](https://www.cyber.airbus.com/the-oxid-resolver-part-1-remote-enumeration-of-network-interfaces-without-any-authentication/)
- [https://www.cyber.airbus.com/the-oxid-resolver-part-2-accessing-a-remote-object-inside-dcom/](https://www.cyber.airbus.com/the-oxid-resolver-part-2-accessing-a-remote-object-inside-dcom/)
- [https://0xffsec.com/handbook/services/msrpc/](https://0xffsec.com/handbook/services/msrpc/)
- [MS-RPC-Fuzzer (GitHub)](https://github.com/warpnet/MS-RPC-Fuzzer)

{{#include ../banners/hacktricks-training.md}}
