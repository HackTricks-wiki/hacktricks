# 135, 593 - Pentesting MSRPC

{{#include ../banners/hacktricks-training.md}}

## Basic Information

Το πρωτόκολλο Microsoft Remote Procedure Call (MSRPC), ένα μοντέλο client-server που επιτρέπει σε ένα πρόγραμμα να ζητήσει μια υπηρεσία από ένα πρόγραμμα που βρίσκεται σε άλλο υπολογιστή χωρίς να κατανοεί τις λεπτομέρειες του δικτύου, προήλθε αρχικά από λογισμικό ανοιχτού κώδικα και αργότερα αναπτύχθηκε και κατοχυρώθηκε με πνευματικά δικαιώματα από τη Microsoft.

Ο χάρτης σημείων RPC μπορεί να προσπελαστεί μέσω TCP και UDP θύρας 135, SMB σε TCP 139 και 445 (με μια κενή ή αυθεντικοποιημένη συνεδρία), και ως υπηρεσία ιστού σε TCP θύρα 593.
```
135/tcp   open     msrpc         Microsoft Windows RPC
```
## Πώς λειτουργεί το MSRPC;

Αφού ξεκινήσει από την εφαρμογή-πελάτη, η διαδικασία MSRPC περιλαμβάνει την κλήση μιας τοπικής διαδικασίας stub που αλληλεπιδρά με τη βιβλιοθήκη χρόνου εκτέλεσης του πελάτη για να προετοιμάσει και να μεταδώσει το αίτημα στον διακομιστή. Αυτό περιλαμβάνει τη μετατροπή παραμέτρων σε μια τυπική μορφή Αναπαράστασης Δεδομένων Δικτύου. Η επιλογή του πρωτοκόλλου μεταφοράς καθορίζεται από τη βιβλιοθήκη χρόνου εκτέλεσης εάν ο διακομιστής είναι απομακρυσμένος, διασφαλίζοντας ότι το RPC παραδίδεται μέσω της στοίβας δικτύου.

![https://0xffsec.com/handbook/images/msrpc.png](https://0xffsec.com/handbook/images/msrpc.png)

## **Αναγνώριση Εκτεθειμένων Υπηρεσιών RPC**

Η έκθεση υπηρεσιών RPC μέσω TCP, UDP, HTTP και SMB μπορεί να προσδιοριστεί με την ερώτηση της υπηρεσίας εντοπισμού RPC και των ατομικών τελών. Εργαλεία όπως το rpcdump διευκολύνουν την αναγνώριση μοναδικών υπηρεσιών RPC, που υποδεικνύονται από τις τιμές **IFID**, αποκαλύπτοντας λεπτομέρειες υπηρεσίας και δεσμεύσεις επικοινωνίας:
```
D:\rpctools> rpcdump [-p port] <IP>
**IFID**: 5a7b91f8-ff00-11d0-a9b2-00c04fb6e6fc version 1.0
Annotation: Messenger Service
UUID: 00000000-0000-0000-0000-000000000000
Binding: ncadg_ip_udp:<IP>[1028]
```
Η πρόσβαση στην υπηρεσία εντοπισμού RPC είναι ενεργοποιημένη μέσω συγκεκριμένων πρωτοκόλλων: ncacn_ip_tcp και ncadg_ip_udp για πρόσβαση μέσω της θύρας 135, ncacn_np για συνδέσεις SMB και ncacn_http για επικοινωνία RPC μέσω διαδικτύου. Οι παρακάτω εντολές παραδείγουν τη χρήση των μονάδων Metasploit για την επιθεώρηση και την αλληλεπίδραση με τις υπηρεσίες MSRPC, εστιάζοντας κυρίως στη θύρα 135:
```bash
use auxiliary/scanner/dcerpc/endpoint_mapper
use auxiliary/scanner/dcerpc/hidden
use auxiliary/scanner/dcerpc/management
use auxiliary/scanner/dcerpc/tcp_dcerpc_auditor
rpcdump.py <IP> -p 135
```
Όλες οι επιλογές εκτός από `tcp_dcerpc_auditor` έχουν σχεδιαστεί ειδικά για στοχοποίηση του MSRPC στην πόρτα 135.

#### Σημαντικά διεπαφές RPC

- **IFID**: 12345778-1234-abcd-ef00-0123456789ab
- **Named Pipe**: `\pipe\lsarpc`
- **Περιγραφή**: Διεπαφή LSA, χρησιμοποιείται για την καταμέτρηση χρηστών.
- **IFID**: 3919286a-b10c-11d0-9ba8-00c04fd92ef5
- **Named Pipe**: `\pipe\lsarpc`
- **Περιγραφή**: Διεπαφή Υπηρεσιών Καταλόγου LSA (DS), χρησιμοποιείται για την καταμέτρηση τομέων και σχέσεων εμπιστοσύνης.
- **IFID**: 12345778-1234-abcd-ef00-0123456789ac
- **Named Pipe**: `\pipe\samr`
- **Περιγραφή**: Διεπαφή LSA SAMR, χρησιμοποιείται για την πρόσβαση σε δημόσια στοιχεία της βάσης δεδομένων SAM (π.χ. ονόματα χρηστών) και για την παραβίαση κωδικών πρόσβασης χρηστών ανεξαρτήτως πολιτικής κλειδώματος λογαριασμού.
- **IFID**: 1ff70682-0a51-30e8-076d-740be8cee98b
- **Named Pipe**: `\pipe\atsvc`
- **Περιγραφή**: Προγραμματιστής εργασιών, χρησιμοποιείται για την απομακρυσμένη εκτέλεση εντολών.
- **IFID**: 338cd001-2244-31f1-aaaa-900038001003
- **Named Pipe**: `\pipe\winreg`
- **Περιγραφή**: Υπηρεσία απομακρυσμένου μητρώου, χρησιμοποιείται για την πρόσβαση και τροποποίηση του μητρώου συστήματος.
- **IFID**: 367abb81-9844-35f1-ad32-98f038001003
- **Named Pipe**: `\pipe\svcctl`
- **Περιγραφή**: Διαχειριστής ελέγχου υπηρεσιών και υπηρεσίες διακομιστή, χρησιμοποιείται για την απομακρυσμένη εκκίνηση και διακοπή υπηρεσιών και την εκτέλεση εντολών.
- **IFID**: 4b324fc8-1670-01d3-1278-5a47bf6ee188
- **Named Pipe**: `\pipe\srvsvc`
- **Περιγραφή**: Διαχειριστής ελέγχου υπηρεσιών και υπηρεσίες διακομιστή, χρησιμοποιείται για την απομακρυσμένη εκκίνηση και διακοπή υπηρεσιών και την εκτέλεση εντολών.
- **IFID**: 4d9f4ab8-7d1c-11cf-861e-0020af6e7c57
- **Named Pipe**: `\pipe\epmapper`
- **Περιγραφή**: Διεπαφή DCOM, χρησιμοποιείται για την παραβίαση κωδικών πρόσβασης και τη συλλογή πληροφοριών μέσω WM.

### Αναγνώριση διευθύνσεων IP

Χρησιμοποιώντας [https://github.com/mubix/IOXIDResolver](https://github.com/mubix/IOXIDResolver), που προέρχεται από [Airbus research](https://www.cyber.airbus.com/the-oxid-resolver-part-1-remote-enumeration-of-network-interfaces-without-any-authentication/), είναι δυνατή η κατάχρηση της μεθόδου _**ServerAlive2**_ μέσα στη διεπαφή _**IOXIDResolver**_.

Αυτή η μέθοδος έχει χρησιμοποιηθεί για να αποκτήσει πληροφορίες διεπαφής ως **IPv6** διεύθυνση από το κουτί HTB _APT_. Δείτε [εδώ](https://0xdf.gitlab.io/2021/04/10/htb-apt.html) για την αναφορά του 0xdf APT, περιλαμβάνει μια εναλλακτική μέθοδο χρησιμοποιώντας rpcmap.py από [Impacket](https://github.com/SecureAuthCorp/impacket/) με _stringbinding_ (βλ. παραπάνω).

### Εκτέλεση RCE με έγκυρα διαπιστευτήρια

Είναι δυνατή η εκτέλεση απομακρυσμένου κώδικα σε μια μηχανή, εάν είναι διαθέσιμα τα διαπιστευτήρια ενός έγκυρου χρήστη χρησιμοποιώντας [dcomexec.py](https://github.com/fortra/impacket/blob/master/examples/dcomexec.py) από το πλαίσιο impacket.

**Θυμηθείτε να δοκιμάσετε με τα διάφορα διαθέσιμα αντικείμενα**

- ShellWindows
- ShellBrowserWindow
- MMC20

## Πόρτα 593

Το **rpcdump.exe** από [rpctools](https://resources.oreilly.com/examples/9780596510305/tree/master/tools/rpctools) μπορεί να αλληλεπιδράσει με αυτή την πόρτα.

## Αυτοματοποιημένο Fuzzing Διεπαφών MSRPC

Οι διεπαφές MS-RPC εκθέτουν μια μεγάλη και συχνά μη τεκμηριωμένη επιφάνεια επίθεσης. Το ανοιχτού κώδικα [MS-RPC-Fuzzer](https://github.com/warpnet/MS-RPC-Fuzzer) PowerShell module βασίζεται στο `NtObjectManager` του James Forshaw για να *δημιουργεί δυναμικά* RPC client stubs από τα μεταδεδομένα διεπαφής που είναι ήδη παρόντα στα Windows binaries. Μόλις υπάρχει ένα stub, το module μπορεί να βομβαρδίσει κάθε διαδικασία με μεταλλαγμένα εισροές και να καταγράψει το αποτέλεσμα, καθιστώντας **επαναλαμβανόμενο, μεγάλης κλίμακας fuzzing των RPC endpoints δυνατό χωρίς να γράψετε ούτε μία γραμμή IDL**.

### 1. Καταγραφή των διεπαφών
```powershell
# Import the module (download / git clone first)
Import-Module .\MS-RPC-Fuzzer.psm1

# Parse a single binary
Get-RpcServerData -Target "C:\Windows\System32\efssvc.dll" -OutPath .\output

# Or crawl the whole %SystemRoot%\System32 directory
Get-RpcServerData -OutPath .\output
```
`Get-RpcServerData` θα εξάγει το UUID, την έκδοση, τις συμβολοσειρές σύνδεσης (named-pipe / TCP / HTTP) και **πλήρεις πρωτότυπες διαδικασίες** για κάθε διεπαφή που συναντά και θα τις αποθηκεύσει στο `rpcServerData.json`.

### 2. Εκτελέστε τον fuzzer
```powershell
'.\output\rpcServerData.json' |
Invoke-RpcFuzzer -OutPath .\output `
-MinStrLen 100  -MaxStrLen 1000 `
-MinIntSize 9999 -MaxIntSize 99999
```
Σχετικές επιλογές:

* `-MinStrLen` / `-MaxStrLen` – εύρος μεγέθους για παραγόμενες συμβολοσειρές
* `-MinIntSize` / `-MaxIntSize` – εύρος τιμών για μεταλλαγμένους ακέραιους (χρήσιμο για δοκιμές υπερχείλισης)
* `-Sorted` – εκτέλεση διαδικασιών με σειρά που σέβεται τις **εξαρτήσεις παραμέτρων** ώστε οι έξοδοι μιας κλήσης να μπορούν να χρησιμεύσουν ως είσοδοι της επόμενης (αυξάνει δραματικά τους προσβάσιμους δρόμους)

Ο fuzzer υλοποιεί 2 στρατηγικές:

1. **Default fuzzer** – τυχαίες πρωτότυπες τιμές + προεπιλεγμένες περιπτώσεις για σύνθετους τύπους
2. **Sorted fuzzer**  – παραγόμενη σειρά με γνώση εξαρτήσεων (βλ. `docs/Procedure dependency design.md`)

Κάθε κλήση καταγράφεται ατομικά στο `log.txt`; μετά από μια κατάρρευση, η **τελευταία γραμμή σας λέει αμέσως ποια διαδικασία προκάλεσε το πρόβλημα**. Το αποτέλεσμα κάθε κλήσης κατηγοριοποιείται επίσης σε τρία αρχεία JSON:

* `allowed.json` – η κλήση ήταν επιτυχής και επέστρεψε δεδομένα
* `denied.json`  – ο διακομιστής απάντησε με *Access Denied*
* `error.json`   – οποιοδήποτε άλλο σφάλμα / κατάρρευση

### 3. Οπτικοποιήστε με Neo4j
```powershell
'.\output\allowed.json' |
Import-DataToNeo4j -Neo4jHost 192.168.56.10:7474 -Neo4jUsername neo4j
```
`Import-DataToNeo4j` μετατρέπει τα JSON αντικείμενα σε μια δομή γραφήματος όπου:

* Οι διακομιστές RPC, οι διεπαφές και οι διαδικασίες είναι **κόμβοι**
* Οι αλληλεπιδράσεις (`ALLOWED`, `DENIED`, `ERROR`) είναι **σχέσεις**

Οι ερωτήσεις Cypher μπορούν στη συνέχεια να χρησιμοποιηθούν για να εντοπίσουν γρήγορα επικίνδυνες διαδικασίες ή να επαναλάβουν την ακριβή αλυσίδα κλήσεων που προηγήθηκε μιας κατάρρευσης.

⚠️  Ο fuzzer είναι *καταστροφικός*: αναμένετε καταρρεύσεις υπηρεσιών και ακόμη και BSODs – πάντα εκτελέστε το σε ένα απομονωμένο στιγμιότυπο VM.


### Αυτοματοποιημένη Αρίθμηση Διεπαφών & Δυναμική Δημιουργία Πελάτη (NtObjectManager)

Ο ειδικός του PowerShell **James Forshaw** αποκάλυψε τα περισσότερα από τα εσωτερικά του Windows RPC μέσα στο ανοιχτού κώδικα *NtObjectManager* module. Χρησιμοποιώντας το, μπορείτε να μετατρέψετε οποιοδήποτε DLL / EXE διακομιστή RPC σε ένα **πλήρως λειτουργικό stub πελάτη** σε δευτερόλεπτα – χωρίς IDL, MIDL ή χειροκίνητη αποσυμπίεση.
```powershell
# Install the module once
Install-Module NtObjectManager -Force

# Parse every RPC interface exported by the target binary
$rpcinterfaces = Get-RpcServer "C:\Windows\System32\efssvc.dll"
$rpcinterfaces | Format-Table Name,Uuid,Version,Procedures

# Inspect a single procedure (opnum 0)
$rpcinterfaces[0].Procedures[0] | Format-List *
```
Η τυπική έξοδος εκθέτει τους τύπους παραμέτρων ακριβώς όπως εμφανίζονται στο **MIDL** (π.χ. `FC_C_WSTRING`, `FC_LONG`, `FC_BIND_CONTEXT`).

Μόλις γνωρίζετε τη διεπαφή, μπορείτε να **δημιουργήσετε έναν έτοιμο προς μεταγλώττιση πελάτη C#**:
```powershell
# Reverse the MS-EFSR (EfsRpc*) interface into C#
Format-RpcClient $rpcinterfaces[0] -Namespace MS_EFSR -OutputPath .\MS_EFSR.cs
```
Μέσα στο παραγόμενο stub θα βρείτε μεθόδους όπως:
```csharp
public int EfsRpcOpenFileRaw(out Marshal.NdrContextHandle ctx, string FileName, int Flags) {
// marshals parameters & calls opnum 0
}
```
Ο βοηθός PowerShell `Get-RpcClient` μπορεί να δημιουργήσει ένα **διαδραστικό αντικείμενο πελάτη** ώστε να μπορείτε να καλέσετε τη διαδικασία αμέσως:
```powershell
$client = Get-RpcClient $rpcinterfaces[0]
Connect-RpcClient $client -stringbinding 'ncacn_np:127.0.0.1[\\pipe\\efsrpc]' `
-AuthenticationLevel PacketPrivacy `
-AuthenticationType  WinNT  # NTLM auth

# Invoke the procedure → returns an authenticated context handle
$ctx = New-Object Marshal.NdrContextHandle
$client.EfsRpcOpenFileRaw([ref]$ctx, "\\\127.0.0.1\test", 0)
```
Authentication (Kerberos / NTLM) και επίπεδα κρυπτογράφησης (`PacketIntegrity`, `PacketPrivacy`, …) μπορούν να παρέχονται απευθείας μέσω του `Connect-RpcClient` cmdlet – ιδανικό για **παράκαμψη των Security Descriptors** που προστατεύουν τις ονομασμένες σωλήνες υψηλών δικαιωμάτων.

### Context-Aware RPC Fuzzing (MS-RPC-Fuzzer)

Η στατική γνώση διεπαφής είναι καλή, αλλά αυτό που πραγματικά θέλετε είναι **fuzzing καθοδηγούμενο από κάλυψη** που κατανοεί *context handles* και σύνθετες αλυσίδες παραμέτρων. Το έργο ανοιχτού κώδικα **MS-RPC-Fuzzer** αυτοματοποιεί ακριβώς αυτή τη ροή εργασίας:

1. Καταγράψτε κάθε διεπαφή/διαδικασία που εξάγεται από το στοχοθετημένο δυαδικό (`Get-RpcServer`).
2. Δημιουργήστε δυναμικούς πελάτες για κάθε διεπαφή (`Format-RpcClient`).
3. Τυχαία παραμετροποιήστε τις εισόδους (μήκος ευρέων συμβολοσειρών, εύρη ακέραιων, enums) ενώ σέβεστε τον αρχικό **τύπο NDR**.
4. Παρακολουθήστε τα *context handles* που επιστρέφονται από μία κλήση για να τροφοδοτήσετε αυτόματα τις επόμενες διαδικασίες.
5. Εκτελέστε κλήσεις υψηλού όγκου κατά της επιλεγμένης μεταφοράς (ALPC, TCP, HTTP ή ονομασμένη σωλήνα).
6. Καταγράψτε τις καταστάσεις εξόδου / σφαλμάτων / χρονικών ορίων και εξάγετε ένα αρχείο εισαγωγής **Neo4j** για να οπτικοποιήσετε τις σχέσεις *διεπαφή → διαδικασία → παράμετρος* και τις ομάδες κρασάρισμα. 

Example run (named–pipe target):
```powershell
Invoke-MSRPCFuzzer -Pipe "\\.\pipe\efsrpc" -Auth NTLM `
-MinLen 1  -MaxLen 0x400 `
-Iterations 100000 `
-OutDir .\results
```
Μια μοναδική εγγραφή εκτός ορίων ή απροσδόκητη εξαίρεση θα εμφανιστεί άμεσα με το ακριβές opnum + το fuzzed payload που την προκάλεσε – τέλειο σημείο εκκίνησης για μια σταθερή απόδειξη έννοιας εκμετάλλευσης.

> ⚠️  Πολλές υπηρεσίες RPC εκτελούνται σε διαδικασίες που τρέχουν ως **NT AUTHORITY\SYSTEM**.  Οποιοδήποτε πρόβλημα ασφάλειας μνήμης εδώ συνήθως μεταφράζεται σε τοπική κλιμάκωση προνομίων ή (όταν εκτίθεται μέσω SMB/135) *εκτέλεση απομακρυσμένου κώδικα*.


## Αναφορές

- [Automating MS-RPC vulnerability research (2025, Incendium.rocks)](https://www.incendium.rocks/posts/Automating-MS-RPC-Vulnerability-Research/)
- [MS-RPC-Fuzzer – context-aware RPC fuzzer](https://github.com/warpnet/MS-RPC-Fuzzer)
- [NtObjectManager PowerShell module](https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools/tree/master/NtObjectManager)
- [https://www.cyber.airbus.com/the-oxid-resolver-part-1-remote-enumeration-of-network-interfaces-without-any-authentication/](https://www.cyber.airbus.com/the-oxid-resolver-part-1-remote-enumeration-of-network-interfaces-without-any-authentication/)
- [https://www.cyber.airbus.com/the-oxid-resolver-part-2-accessing-a-remote-object-inside-dcom/](https://www.cyber.airbus.com/the-oxid-resolver-part-2-accessing-a-remote-object-inside-dcom/)
- [https://0xffsec.com/handbook/services/msrpc/](https://0xffsec.com/handbook/services/msrpc/)
- [MS-RPC-Fuzzer (GitHub)](https://github.com/warpnet/MS-RPC-Fuzzer)

{{#include ../banners/hacktricks-training.md}}
