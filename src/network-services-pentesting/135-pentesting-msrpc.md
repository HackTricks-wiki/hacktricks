# 135, 593 - Pentesting MSRPC

{{#include ../banners/hacktricks-training.md}}

## Basic Information

Microsoft Remote Procedure Call (MSRPC) प्रोटोकॉल, एक क्लाइंट-सरवर मॉडल जो एक प्रोग्राम को किसी अन्य कंप्यूटर पर स्थित प्रोग्राम से सेवा मांगने की अनुमति देता है बिना नेटवर्क की विशिष्टताओं को समझे, मूल रूप से ओपन-सोर्स सॉफ़्टवेयर से निकाला गया था और बाद में Microsoft द्वारा विकसित और कॉपीराइट किया गया।

RPC एंडपॉइंट मैपर को TCP और UDP पोर्ट 135, SMB पर TCP 139 और 445 (एक शून्य या प्रमाणित सत्र के साथ) के माध्यम से और TCP पोर्ट 593 पर एक वेब सेवा के रूप में एक्सेस किया जा सकता है।
```
135/tcp   open     msrpc         Microsoft Windows RPC
```
## MSRPC कैसे काम करता है?

क्लाइंट एप्लिकेशन द्वारा शुरू किया गया, MSRPC प्रक्रिया एक स्थानीय स्टब प्रक्रिया को कॉल करने में शामिल होती है जो फिर क्लाइंट रनटाइम लाइब्रेरी के साथ इंटरैक्ट करती है ताकि सर्वर को अनुरोध तैयार और भेजा जा सके। इसमें पैरामीटर को एक मानक नेटवर्क डेटा प्रतिनिधित्व प्रारूप में परिवर्तित करना शामिल है। यदि सर्वर दूरस्थ है, तो परिवहन प्रोटोकॉल का चयन रनटाइम लाइब्रेरी द्वारा किया जाता है, यह सुनिश्चित करते हुए कि RPC नेटवर्क स्टैक के माध्यम से वितरित किया गया है।

![https://0xffsec.com/handbook/images/msrpc.png](https://0xffsec.com/handbook/images/msrpc.png)

## **प्रदर्शित RPC सेवाओं की पहचान करना**

TCP, UDP, HTTP, और SMB के माध्यम से RPC सेवाओं का प्रदर्शन RPC लोकेटर सेवा और व्यक्तिगत एंडपॉइंट्स को क्वेरी करके निर्धारित किया जा सकता है। rpcdump जैसे उपकरण अद्वितीय RPC सेवाओं की पहचान करने में मदद करते हैं, जिन्हें **IFID** मानों द्वारा दर्शाया जाता है, सेवा विवरण और संचार बाइंडिंग को प्रकट करते हैं:
```
D:\rpctools> rpcdump [-p port] <IP>
**IFID**: 5a7b91f8-ff00-11d0-a9b2-00c04fb6e6fc version 1.0
Annotation: Messenger Service
UUID: 00000000-0000-0000-0000-000000000000
Binding: ncadg_ip_udp:<IP>[1028]
```
RPC लोकेटर सेवा तक पहुँच विशेष प्रोटोकॉल के माध्यम से सक्षम है: ncacn_ip_tcp और ncadg_ip_udp पोर्ट 135 के माध्यम से पहुँच के लिए, SMB कनेक्शनों के लिए ncacn_np, और वेब-आधारित RPC संचार के लिए ncacn_http। निम्नलिखित कमांड MSRPC सेवाओं का ऑडिट और इंटरैक्ट करने के लिए Metasploit मॉड्यूल के उपयोग का उदाहरण प्रस्तुत करते हैं, मुख्य रूप से पोर्ट 135 पर ध्यान केंद्रित करते हुए:
```bash
use auxiliary/scanner/dcerpc/endpoint_mapper
use auxiliary/scanner/dcerpc/hidden
use auxiliary/scanner/dcerpc/management
use auxiliary/scanner/dcerpc/tcp_dcerpc_auditor
rpcdump.py <IP> -p 135
```
All options except `tcp_dcerpc_auditor` are specifically designed for targeting MSRPC on port 135.

#### Notable RPC interfaces

- **IFID**: 12345778-1234-abcd-ef00-0123456789ab
- **Named Pipe**: `\pipe\lsarpc`
- **Description**: LSA इंटरफेस, जिसका उपयोग उपयोगकर्ताओं की सूची बनाने के लिए किया जाता है।
- **IFID**: 3919286a-b10c-11d0-9ba8-00c04fd92ef5
- **Named Pipe**: `\pipe\lsarpc`
- **Description**: LSA डायरेक्टरी सेवाएँ (DS) इंटरफेस, जिसका उपयोग डोमेन और ट्रस्ट संबंधों की सूची बनाने के लिए किया जाता है।
- **IFID**: 12345778-1234-abcd-ef00-0123456789ac
- **Named Pipe**: `\pipe\samr`
- **Description**: LSA SAMR इंटरफेस, जिसका उपयोग सार्वजनिक SAM डेटाबेस तत्वों (जैसे, उपयोगकर्ता नाम) तक पहुँचने और उपयोगकर्ता पासवर्ड को ब्रूट-फोर्स करने के लिए किया जाता है, चाहे खाता लॉकआउट नीति कुछ भी हो।
- **IFID**: 1ff70682-0a51-30e8-076d-740be8cee98b
- **Named Pipe**: `\pipe\atsvc`
- **Description**: कार्य शेड्यूलर, जिसका उपयोग दूरस्थ रूप से कमांड निष्पादित करने के लिए किया जाता है।
- **IFID**: 338cd001-2244-31f1-aaaa-900038001003
- **Named Pipe**: `\pipe\winreg`
- **Description**: रिमोट रजिस्ट्री सेवा, जिसका उपयोग सिस्टम रजिस्ट्री तक पहुँचने और उसे संशोधित करने के लिए किया जाता है।
- **IFID**: 367abb81-9844-35f1-ad32-98f038001003
- **Named Pipe**: `\pipe\svcctl`
- **Description**: सेवा नियंत्रण प्रबंधक और सर्वर सेवाएँ, जिसका उपयोग दूरस्थ रूप से सेवाओं को प्रारंभ और रोकने और कमांड निष्पादित करने के लिए किया जाता है।
- **IFID**: 4b324fc8-1670-01d3-1278-5a47bf6ee188
- **Named Pipe**: `\pipe\srvsvc`
- **Description**: सेवा नियंत्रण प्रबंधक और सर्वर सेवाएँ, जिसका उपयोग दूरस्थ रूप से सेवाओं को प्रारंभ और रोकने और कमांड निष्पादित करने के लिए किया जाता है।
- **IFID**: 4d9f4ab8-7d1c-11cf-861e-0020af6e7c57
- **Named Pipe**: `\pipe\epmapper`
- **Description**: DCOM इंटरफेस, जिसका उपयोग ब्रूट-फोर्स पासवर्ड ग्राइंडिंग और WM के माध्यम से जानकारी एकत्र करने के लिए किया जाता है।

### Identifying IP addresses

Using [https://github.com/mubix/IOXIDResolver](https://github.com/mubix/IOXIDResolver), comes from [Airbus research](https://www.cyber.airbus.com/the-oxid-resolver-part-1-remote-enumeration-of-network-interfaces-without-any-authentication/) is possible to abuse the _**ServerAlive2**_ method inside the _**IOXIDResolver**_ interface.

This method has been used to get interface information as **IPv6** address from the HTB box _APT_. See [here](https://0xdf.gitlab.io/2021/04/10/htb-apt.html) for 0xdf APT writeup, it includes an alternative method using rpcmap.py from [Impacket](https://github.com/SecureAuthCorp/impacket/) with _stringbinding_ (see above).

### Executing a RCE with valid credentials

It is possible to execute remote code on a machine, if the credentials of a valid user are available using [dcomexec.py](https://github.com/fortra/impacket/blob/master/examples/dcomexec.py) from impacket framework.

**Remember to try with the different objects available**

- ShellWindows
- ShellBrowserWindow
- MMC20

## Port 593

The **rpcdump.exe** from [rpctools](https://resources.oreilly.com/examples/9780596510305/tree/master/tools/rpctools) can interact with this port.

## Automated Fuzzing of MSRPC Interfaces

MS-RPC interfaces expose a large and often undocumented attack surface. The open-source [MS-RPC-Fuzzer](https://github.com/warpnet/MS-RPC-Fuzzer) PowerShell module builds on James Forshaw’s `NtObjectManager` to *dynamically* create RPC client stubs from the interface metadata that is already present in Windows binaries. Once a stub exists the module can bombard each procedure with mutated inputs and log the outcome, making **reproducible, large-scale fuzzing of RPC endpoints possible without writing a single line of IDL**.

### 1. Inventory the interfaces
```powershell
# Import the module (download / git clone first)
Import-Module .\MS-RPC-Fuzzer.psm1

# Parse a single binary
Get-RpcServerData -Target "C:\Windows\System32\efssvc.dll" -OutPath .\output

# Or crawl the whole %SystemRoot%\System32 directory
Get-RpcServerData -OutPath .\output
```
`Get-RpcServerData` UUID, संस्करण, बाइंडिंग स्ट्रिंग (नामित-पाइप / TCP / HTTP) और **पूर्ण प्रक्रिया प्रोटोटाइप** को निकाल लेगा जो भी इंटरफेस इसे मिलते हैं और उन्हें `rpcServerData.json` में संग्रहीत करेगा।

### 2. फज़्ज़र चलाएँ
```powershell
'.\output\rpcServerData.json' |
Invoke-RpcFuzzer -OutPath .\output `
-MinStrLen 100  -MaxStrLen 1000 `
-MinIntSize 9999 -MaxIntSize 99999
```
संबंधित विकल्प:

* `-MinStrLen` / `-MaxStrLen` – उत्पन्न स्ट्रिंग्स के लिए आकार सीमा
* `-MinIntSize` / `-MaxIntSize` – उत्परिवर्तित पूर्णांकों के लिए मान सीमा (ओवरफ्लो परीक्षण के लिए उपयोगी)
* `-Sorted` – प्रक्रियाओं को एक क्रम में निष्पादित करें जो **पैरामीटर निर्भरताओं** का सम्मान करता है ताकि एक कॉल के आउटपुट अगले के इनपुट के रूप में कार्य कर सकें (पहुंच योग्य पथों को नाटकीय रूप से बढ़ाता है)

फज़्ज़र 2 रणनीतियों को लागू करता है:

1. **डिफ़ॉल्ट फज़्ज़र** – यादृच्छिक प्राथमिक मान + जटिल प्रकारों के लिए डिफ़ॉल्ट उदाहरण
2. **सॉर्टेड फज़्ज़र**  – निर्भरता-जानकारी क्रम (देखें `docs/Procedure dependency design.md`)

हर कॉल को `log.txt` में परमाणु रूप से लिखा जाता है; एक क्रैश के बाद **अंतिम पंक्ति तुरंत आपको दोषपूर्ण प्रक्रिया बताती है**। प्रत्येक कॉल का परिणाम तीन JSON फ़ाइलों में भी वर्गीकृत किया जाता है:

* `allowed.json` – कॉल सफल रहा और डेटा लौटाया
* `denied.json`  – सर्वर ने *Access Denied* के साथ प्रतिक्रिया दी
* `error.json`   – कोई अन्य त्रुटि / क्रैश

### 3. Neo4j के साथ दृश्य बनाएं
```powershell
'.\output\allowed.json' |
Import-DataToNeo4j -Neo4jHost 192.168.56.10:7474 -Neo4jUsername neo4j
```
`Import-DataToNeo4j` JSON कलाकृतियों को एक ग्राफ संरचना में परिवर्तित करता है जहाँ:

* RPC सर्वर, इंटरफेस और प्रक्रियाएँ **नोड्स** हैं
* इंटरैक्शन (`ALLOWED`, `DENIED`, `ERROR`) **रिश्ते** हैं

Cypher क्वेरीज़ का उपयोग करके खतरनाक प्रक्रियाओं को जल्दी से पहचानने या क्रैश से पहले के कॉल की सटीक श्रृंखला को फिर से चलाने के लिए किया जा सकता है।

⚠️  फज़्ज़र *विनाशकारी* है: सेवा क्रैश और यहां तक कि BSOD की अपेक्षा करें - हमेशा इसे एक अलग VM स्नैपशॉट में चलाएँ।

### स्वचालित इंटरफेस एन्यूमरेशन और डायनामिक क्लाइंट जनरेशन (NtObjectManager)

PowerShell गुरु **James Forshaw** ने ओपन-सोर्स *NtObjectManager* मॉड्यूल के अंदर अधिकांश Windows RPC आंतरिकताओं को उजागर किया। इसका उपयोग करके आप किसी भी RPC सर्वर DLL / EXE को सेकंडों में एक **पूर्ण विशेषताओं वाला क्लाइंट स्टब** में बदल सकते हैं - कोई IDL, MIDL या मैनुअल अनमार्शलिंग की आवश्यकता नहीं है।
```powershell
# Install the module once
Install-Module NtObjectManager -Force

# Parse every RPC interface exported by the target binary
$rpcinterfaces = Get-RpcServer "C:\Windows\System32\efssvc.dll"
$rpcinterfaces | Format-Table Name,Uuid,Version,Procedures

# Inspect a single procedure (opnum 0)
$rpcinterfaces[0].Procedures[0] | Format-List *
```
सामान्य आउटपुट पैरामीटर प्रकारों को ठीक उसी तरह प्रकट करता है जैसे वे **MIDL** में दिखाई देते हैं (जैसे `FC_C_WSTRING`, `FC_LONG`, `FC_BIND_CONTEXT`)।

एक बार जब आप इंटरफेस को जान लेते हैं, तो आप **एक तैयार-से-कंपाइल C# क्लाइंट** उत्पन्न कर सकते हैं:
```powershell
# Reverse the MS-EFSR (EfsRpc*) interface into C#
Format-RpcClient $rpcinterfaces[0] -Namespace MS_EFSR -OutputPath .\MS_EFSR.cs
```
उत्पादित स्टब के अंदर आपको ऐसे तरीके मिलेंगे:
```csharp
public int EfsRpcOpenFileRaw(out Marshal.NdrContextHandle ctx, string FileName, int Flags) {
// marshals parameters & calls opnum 0
}
```
PowerShell सहायक `Get-RpcClient` एक **इंटरएक्टिव क्लाइंट ऑब्जेक्ट** बना सकता है ताकि आप प्रक्रिया को तुरंत कॉल कर सकें:
```powershell
$client = Get-RpcClient $rpcinterfaces[0]
Connect-RpcClient $client -stringbinding 'ncacn_np:127.0.0.1[\\pipe\\efsrpc]' `
-AuthenticationLevel PacketPrivacy `
-AuthenticationType  WinNT  # NTLM auth

# Invoke the procedure → returns an authenticated context handle
$ctx = New-Object Marshal.NdrContextHandle
$client.EfsRpcOpenFileRaw([ref]$ctx, "\\\127.0.0.1\test", 0)
```
प्रमाणीकरण (Kerberos / NTLM) और एन्क्रिप्शन स्तर (`PacketIntegrity`, `PacketPrivacy`, …) को सीधे `Connect-RpcClient` cmdlet के माध्यम से प्रदान किया जा सकता है - **उच्च-विशेषाधिकार नामित पाइप** की सुरक्षा करने वाले सुरक्षा वर्णनकर्ताओं को बायपास करने के लिए आदर्श।

### संदर्भ-जानकारी RPC फज़िंग (MS-RPC-Fuzzer)

स्थैतिक इंटरफ़ेस ज्ञान अच्छा है, लेकिन आप वास्तव में जो चाहते हैं वह है **कवरेज-गाइडेड फज़िंग** जो *संदर्भ हैंडल* और जटिल पैरामीटर श्रृंखलाओं को समझता है। ओपन-सोर्स **MS-RPC-Fuzzer** प्रोजेक्ट ठीक उसी कार्यप्रवाह को स्वचालित करता है:

1. लक्षित बाइनरी द्वारा निर्यातित प्रत्येक इंटरफ़ेस/प्रक्रिया को सूचीबद्ध करें (`Get-RpcServer`)।
2. प्रत्येक इंटरफ़ेस के लिए गतिशील क्लाइंट उत्पन्न करें (`Format-RpcClient`)।
3. मूल **NDR प्रकार** का सम्मान करते हुए इनपुट पैरामीटर (चौड़े स्ट्रिंग लंबाई, पूर्णांक रेंज, एनम) को यादृच्छिक बनाएं।
4. एक कॉल द्वारा लौटाए गए *संदर्भ हैंडल* को ट्रैक करें ताकि स्वचालित रूप से फॉलो-अप प्रक्रियाओं को फीड किया जा सके।
5. चुने हुए परिवहन (ALPC, TCP, HTTP या नामित पाइप) के खिलाफ उच्च मात्रा में कॉल करें।
6. निकासी स्थिति / दोष / टाइमआउट लॉग करें और *इंटरफ़ेस → प्रक्रिया → पैरामीटर* संबंधों और क्रैश क्लस्टरों को दृश्य बनाने के लिए एक **Neo4j** आयात फ़ाइल निर्यात करें।

उदाहरण रन (नामित-पाइप लक्ष्य):
```powershell
Invoke-MSRPCFuzzer -Pipe "\\.\pipe\efsrpc" -Auth NTLM `
-MinLen 1  -MaxLen 0x400 `
-Iterations 100000 `
-OutDir .\results
```
एक एकल आउट-ऑफ-बाउंड्स लिखना या अप्रत्याशित अपवाद तुरंत प्रकट होगा, जिसमें सटीक opnum + फज़्ड पेलोड होगा जिसने इसे ट्रिगर किया - एक स्थिर प्रमाण-ऑफ-धारणा शोषण के लिए सही प्रारंभिक बिंदु।

> ⚠️  कई RPC सेवाएँ **NT AUTHORITY\SYSTEM** के रूप में चलने वाली प्रक्रियाओं में कार्यान्वित होती हैं। यहाँ कोई भी मेमोरी-सुरक्षा समस्या आमतौर पर स्थानीय विशेषाधिकार वृद्धि या (जब SMB/135 के माध्यम से उजागर किया जाता है) *दूरस्थ कोड निष्पादन* में परिवर्तित होती है।

## संदर्भ

- [Automating MS-RPC vulnerability research (2025, Incendium.rocks)](https://www.incendium.rocks/posts/Automating-MS-RPC-Vulnerability-Research/)
- [MS-RPC-Fuzzer – context-aware RPC fuzzer](https://github.com/warpnet/MS-RPC-Fuzzer)
- [NtObjectManager PowerShell module](https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools/tree/master/NtObjectManager)
- [https://www.cyber.airbus.com/the-oxid-resolver-part-1-remote-enumeration-of-network-interfaces-without-any-authentication/](https://www.cyber.airbus.com/the-oxid-resolver-part-1-remote-enumeration-of-network-interfaces-without-any-authentication/)
- [https://www.cyber.airbus.com/the-oxid-resolver-part-2-accessing-a-remote-object-inside-dcom/](https://www.cyber.airbus.com/the-oxid-resolver-part-2-accessing-a-remote-object-inside-dcom/)
- [https://0xffsec.com/handbook/services/msrpc/](https://0xffsec.com/handbook/services/msrpc/)
- [MS-RPC-Fuzzer (GitHub)](https://github.com/warpnet/MS-RPC-Fuzzer)

{{#include ../banners/hacktricks-training.md}}
