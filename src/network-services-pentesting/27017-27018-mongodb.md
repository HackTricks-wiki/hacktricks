# 27017,27018 - Pentesting MongoDB

{{#include ../banners/hacktricks-training.md}}

## Grundlegende Informationen

**MongoDB** ist ein **Open-Source**-Datenbankmanagementsystem, das ein **dokumentenorientiertes Datenbankmodell** verwendet, um verschiedene Datenformen zu verarbeiten. Es bietet Flexibilität und Skalierbarkeit für die Verwaltung unstrukturierter oder semi-strukturierter Daten in Anwendungen wie Big-Data-Analysen und Content-Management. **Standardport:** 27017, 27018
```
PORT      STATE SERVICE VERSION
27017/tcp open  mongodb MongoDB 2.6.9 2.6.9
```
## Enumeration

### Manuell
```python
from pymongo import MongoClient
client = MongoClient(host, port, username=username, password=password)
client.server_info() #Basic info
#If you have admin access you can obtain more info
admin = client.admin
admin_info = admin.command("serverStatus")
cursor = client.list_databases()
for db in cursor:
print(db)
print(client[db["name"]].list_collection_names())
#If admin access, you could dump the database also
```
**Einige MongoDB-Befehle:**
```bash
show dbs
use <db>
show collections
db.<collection>.find()  #Dump the collection
db.<collection>.count() #Number of records of the collection
db.current.find({"username":"admin"})  #Find in current db the username admin
```
### Automatisch
```bash
nmap -sV --script "mongo* and default" -p 27017 <IP> #By default all the nmap mongo enumerate scripts are used
```
### Shodan

- Alle mongodb-Server: `"mongodb server information"`
- Suche nach vollständig offenen mongodb-Servern: `"mongodb server information" -"partially enabled"`
- Nur teilweise aktivierte auth: `"mongodb server information" "partially enabled"`

## Login

Standardmäßig verlangt mongo kein Passwort.\
**Admin** ist eine häufige mongo-Datenbank.
```bash
mongo <HOST>
mongo <HOST>:<PORT>
mongo <HOST>:<PORT>/<DB>
mongo <database> -u <username> -p '<password>'
```
Das nmap-Skript: _**mongodb-brute**_ prüft, ob creds benötigt werden.
```bash
nmap -n -sV --script mongodb-brute -p 27017 <ip>
```
### [**Brute force**](../generic-hacking/brute-force.md#mongo)

Schau in _/opt/bitnami/mongodb/mongodb.conf_ nach, um zu wissen, ob credentials benötigt werden:
```bash
grep "noauth.*true" /opt/bitnami/mongodb/mongodb.conf | grep -v "^#" #Not needed
grep "auth.*true" /opt/bitnami/mongodb/mongodb.conf | grep -v "^#\|noauth" #Not needed
```
## Mongo Objectid Predict

Beispiel [from here](https://techkranti.com/idor-through-mongodb-object-ids-prediction/).

Mongo Object IDs sind **12-Byte hexadezimale** Zeichenketten:

![http://techidiocy.com/_id-objectid-in-mongodb/](../images/id-and-ObjectIds-in-MongoDB.png)

Zum Beispiel, so können wir eine tatsächliche Object ID, die von einer Anwendung zurückgegeben wurde, zerlegen: 5f2459ac9fa6dc2500314019

1. 5f2459ac: 1596217772 in Dezimal = Freitag, 31. Juli 2020 17:49:32
2. 9fa6dc: Maschinenkennung
3. 2500: Process ID
4. 314019: Ein inkrementeller Zähler

Von den oben genannten Elementen bleibt die Maschinenkennung gleich, solange die Datenbank auf derselben physischen/virtuellen Maschine läuft. Die Process ID ändert sich nur, wenn der MongoDB-Prozess neu gestartet wird. Der Timestamp wird jede Sekunde aktualisiert. Die einzige Herausforderung beim Erraten von Object IDs durch einfaches Inkrementieren des Zählers und der Timestamp-Werte ist die Tatsache, dass MongoDB Object IDs auf Systemebene generiert und zugewiesen werden.

Das Tool [https://github.com/andresriancho/mongo-objectid-predict](https://github.com/andresriancho/mongo-objectid-predict), gegeben eine Start-Object-ID (du kannst einen Account erstellen und eine Start-ID bekommen), sendet etwa 1000 wahrscheinliche Object IDs zurück, die möglicherweise den nächsten Objekten zugewiesen wurden, sodass du sie nur bruteforcen musst.

## Post

Wenn du root bist, kannst du die **mongodb.conf** Datei **ändern**, sodass keine Anmeldeinformationen benötigt werden (_noauth = true_) und du dich **ohne Anmeldeinformationen anmelden** kannst.

## MongoBleed zlib Memory Disclosure (CVE-2025-14847)

Eine weitverbreitete unauthentifizierte Memory Disclosure ("MongoBleed") betrifft MongoDB 3.6–8.2, wann immer der **zlib network compressor aktiviert** ist. Während der OP\_MSG-Dekompression gibt MongoDB die **vom Angreifer kontrollierte Allokationslänge anstelle der tatsächlichen unkomprimierten Länge** zurück, sodass die Antwort nicht initialisierten Server-Speicher enthält, der anderen Verbindungen, `/proc`-Dateien oder dem WiredTiger-Cache gehört.

### Exposure requirements & quick checks

- Serverversion muss innerhalb der verwundbaren Versionen liegen (3.6, 4.0, 4.2, 4.4.0–4.4.29, 5.0.0–5.0.31, 6.0.0–6.0.26, 7.0.0–7.0.27, 8.0.0–8.0.16, 8.2.0–8.2.2).
- `net.compression.compressors` oder `networkMessageCompressors` müssen `zlib` enthalten (Standard in vielen Builds). Prüfe es aus der Shell mit:
```javascript
db.adminCommand({getParameter: 1, networkMessageCompressors: 1})
```
- Der Angreifer benötigt nur Netzwerkzugang zum MongoDB-Port. Keine Authentifizierung ist erforderlich.

### Exploitation & harvesting workflow

1. Initiiere den wire-protocol handshake, während `compressors:["zlib"]` angegeben werden, und zwinge die Session zur Nutzung von zlib.
2. Sende speziell gestaltete komprimierte OP\_MSG-Frames, deren deklarierte `uncompressedSize` deutlich größer als die tatsächliche Nutzlast ist, sodass MongoDB einen sehr großen Puffer alloziert.
3. Weil MongoDB die gesamte Pufferlänge in die Antwort kopiert, behandelt der BSON-Parser **garbage field names** als gültige Daten, bis er auf ein `\x00` trifft, leaking bei jeder Antwort Fragmente des Prozessspeichers.
4. Variiere die angegebene Dokumentlänge/den Offset, um im Prozessspeicher zu wandern und leaks zu aggregieren.

Der öffentliche PoC automatisiert die probing offsets und das carving der zurückgegebenen Fragmente:
```bash
python3 mongobleed.py --host <target> --max-offset 50000 --output leaks.bin
```
Die Verwendung größerer Offset-Bereiche führt konsequent zu:

- MongoDB interne Logs, connection UUIDs, client IPs und WireTiger-Stats.
- `/proc`-Artefakte wie `meminfo`, Socket-Statistiken oder Container-Pfade, die bei container escape oder lateral movement hilfreich sind.
- Geheimnisse, die im Speicher vorhanden sind (database creds, API tokens, cloud keys, session cookies, etc.).

Im großen Maßstab identifizieren Angreifer zuerst `mongod`-Instanzen (z. B. sah Censys >87k exposed services), bestätigen die Version/den Compressor und wiederholen dann die obige Sequenz, um einen durchsuchbaren Dump von leaked strings für nachfolgende Kompromittierungen aufzubauen.


## References

- [Tenable – CVE-2025-14847 (MongoBleed): MongoDB Memory Leak Vulnerability Exploited in the Wild](https://www.tenable.com/blog/cve-2025-14847-mongobleed-mongodb-memory-leak-vulnerability-exploited-in-the-wild)
- [MongoDB Security Advisory SERVER-115508](https://jira.mongodb.org/browse/SERVER-115508)
- [Censys – MongoBleed Advisory](https://censys.com/advisory/cve-2025-14847)
- [MongoBleed PoC (joe-desimone/mongobleed)](https://github.com/joe-desimone/mongobleed)

---

{{#include ../banners/hacktricks-training.md}}
