# 27017,27018 - Pentesting MongoDB

{{#include ../banners/hacktricks-training.md}}

## Podstawowe informacje

**MongoDB** jest **otwartoźródłowym** systemem zarządzania bazą danych, który wykorzystuje **dokumentowy model bazy danych** do obsługi różnych form danych. Oferuje elastyczność i skalowalność w zarządzaniu danymi niestrukturalnymi lub półstrukturalnymi w zastosowaniach takich jak analiza dużych zbiorów danych i zarządzanie treścią. **Domyślny port:** 27017, 27018
```
PORT      STATE SERVICE VERSION
27017/tcp open  mongodb MongoDB 2.6.9 2.6.9
```
## Enumeracja

### Ręczne
```python
from pymongo import MongoClient
client = MongoClient(host, port, username=username, password=password)
client.server_info() #Basic info
#If you have admin access you can obtain more info
admin = client.admin
admin_info = admin.command("serverStatus")
cursor = client.list_databases()
for db in cursor:
print(db)
print(client[db["name"]].list_collection_names())
#If admin access, you could dump the database also
```
**Niektóre polecenia MongoDB:**
```bash
show dbs
use <db>
show collections
db.<collection>.find()  #Dump the collection
db.<collection>.count() #Number of records of the collection
db.current.find({"username":"admin"})  #Find in current db the username admin
```
### Automatyczne
```bash
nmap -sV --script "mongo* and default" -p 27017 <IP> #By default all the nmap mongo enumerate scripts are used
```
### Shodan

- Wszystkie mongodb: `"mongodb server information"`
- Szukaj całkowicie otwartych serwerów mongodb: `"mongodb server information" -"partially enabled"`
- Tylko częściowo włączone uwierzytelnianie: `"mongodb server information" "partially enabled"`

## Logowanie

Domyślnie mongo nie wymaga hasła.\
**Admin** jest powszechną bazą danych mongo.
```bash
mongo <HOST>
mongo <HOST>:<PORT>
mongo <HOST>:<PORT>/<DB>
mongo <database> -u <username> -p '<password>'
```
Skrypt nmap: _**mongodb-brute**_ sprawdzi, czy wymagane są creds.
```bash
nmap -n -sV --script mongodb-brute -p 27017 <ip>
```
### [**Brute force**](../generic-hacking/brute-force.md#mongo)

Zajrzyj do _/opt/bitnami/mongodb/mongodb.conf_, aby sprawdzić, czy wymagane są credentials:
```bash
grep "noauth.*true" /opt/bitnami/mongodb/mongodb.conf | grep -v "^#" #Not needed
grep "auth.*true" /opt/bitnami/mongodb/mongodb.conf | grep -v "^#\|noauth" #Not needed
```
## Prognozowanie ObjectID w Mongo

Przykład [stąd](https://techkranti.com/idor-through-mongodb-object-ids-prediction/).

Mongo Object IDs to **12-bajtowe ciągi szesnastkowe**:

![http://techidiocy.com/_id-objectid-in-mongodb/](../images/id-and-ObjectIds-in-MongoDB.png)

Na przykład, tak możemy rozłożyć na części rzeczywisty Object ID zwrócony przez aplikację: 5f2459ac9fa6dc2500314019

1. 5f2459ac: 1596217772 w systemie dziesiętnym = Friday, 31 July 2020 17:49:32
2. 9fa6dc: Machine Identifier
3. 2500: Process ID
4. 314019: An incremental counter

Z wymienionych elementów, machine identifier pozostanie taki sam dopóki baza działa na tej samej fizycznej/wirtualnej maszynie. Process ID zmieni się tylko jeśli proces MongoDB zostanie zrestartowany. Timestamp jest aktualizowany co sekundę. Jedynym wyzwaniem przy zgadywaniu Object ID przez proste inkrementowanie licznika i wartości timestamp jest fakt, że MongoDB generuje i przypisuje Object ID na poziomie systemowym.

Narzędzie [https://github.com/andresriancho/mongo-objectid-predict](https://github.com/andresriancho/mongo-objectid-predict), mając podany początkowy Object ID (możesz założyć konto i otrzymać początkowe ID), zwraca około 1000 prawdopodobnych Object ID, które mogłyby zostać przypisane do kolejnych obiektów, więc wystarczy je bruteforcować.

## Post

Jeśli jesteś rootem, możesz **zmodyfikować** plik **mongodb.conf**, aby nie były potrzebne poświadczenia (_noauth = true_) i **zalogować się bez poświadczeń**.

## MongoBleed zlib Memory Disclosure (CVE-2025-14847)

Szeroko rozpowszechnione niezautoryzowane ujawnienie pamięci ("MongoBleed") dotyka MongoDB 3.6–8.2, gdy **zlib network compressor jest włączony**. Nagłówek `OP_COMPRESSED` ufa dostarczonemu przez atakującego `uncompressedSize`, więc serwer alokuje bufor o tym rozmiarze i kopiuje go z powrotem do odpowiedzi, nawet jeśli dostarczono tylko znacznie mniejszy skompresowany ładunek. Dodatkowe bajty to **niezainicjalizowane dane z heap** pochodzące z innych połączeń, `/proc` lub cache WiredTiger. Następnie atakujący pomijają oczekiwany **BSON `\x00` terminator**, więc parser MongoDB przeszukuje ten przewymiarowany bufor aż znajdzie terminator, a odpowiedź o błędzie odbija zarówno złośliwy dokument, jak i zeskanowane bajty z heap **pre-auth** na TCP/27017.

### Wymagania ekspozycji i szybkie sprawdzenia

- Wersja serwera musi należeć do podatnych zakresów (3.6, 4.0, 4.2, 4.4.0–4.4.29, 5.0.0–5.0.31, 6.0.0–6.0.26, 7.0.0–7.0.27, 8.0.0–8.0.16, 8.2.0–8.2.2).
- `net.compression.compressors` lub `networkMessageCompressors` musi zawierać `zlib` (domyślnie w wielu buildach). Sprawdź to z poziomu shell:
```javascript
db.adminCommand({getParameter: 1, networkMessageCompressors: 1})
```
- Atakujący potrzebuje tylko dostępu sieciowego do portu MongoDB. Uwierzytelnianie nie jest wymagane.

### Przebieg eksploatacji i zbierania danych

1. Rozpocznij handshake protokołu wire-protocol ogłaszając `compressors:["zlib"]`, tak aby sesja używała zlib.
2. Wyślij ramki `OP_COMPRESSED`, których zadeklarowane `uncompressedSize` jest znacznie większe niż rzeczywista zdekompresowana zawartość, aby wymusić **oversized heap allocation full of old data**.
3. Sporządź osadzony BSON **bez końcowego `\x00`**, tak aby parser przechodził poza dane kontrolowane przez atakującego do nadmiernego bufora podczas szukania terminatora.
4. MongoDB generuje błąd, który zawiera oryginalną wiadomość plus przeskanowane bajty ze sterty, leaking memory. Powtórz z różnymi długościami/przesunięciami, aby zebrać sekrety (creds/API keys/session tokens), statystyki WiredTiger oraz artefakty z `/proc`.

The public PoC automates the probing offsets and carving of the returned fragments:
```bash
python3 mongobleed.py --host <target> --max-offset 50000 --output leaks.bin
```
### Sygnał szumu detekcji (połączenia o wysokiej częstotliwości)

Atak zwykle generuje wiele krótkotrwałych żądań. Obserwuj nagłe skoki połączeń przychodzących do `mongod`/`mongod.exe`. Przykład XQL hunt (>500 połączeń/min na każdy zdalny adres IP, domyślnie z wyłączeniem zakresów RFC1918/loopback/link-local/mcast/broadcast/reserved):

<details>
<summary>Cortex XQL high-velocity Mongo connections</summary>
```sql
// High-velocity inbound connections to mongod/mongod.exe (possible MongoBleed probing)

dataset = xdr_data
| filter event_type = ENUM.NETWORK
| filter lowercase(actor_process_image_name) in ("mongod", "mongod.exe")
| filter action_network_is_server = true
| filter action_remote_ip not in (null, "")
| filter incidr(action_remote_ip, "10.0.0.0/8") != true and
incidr(action_remote_ip, "192.168.0.0/16") != true and
incidr(action_remote_ip, "172.16.0.0/12") != true and
incidr(action_remote_ip, "127.0.0.0/8") != true and
incidr(action_remote_ip, "169.254.0.0/16") != true and
incidr(action_remote_ip, "224.0.0.0/4") != true and
incidr(action_remote_ip, "255.255.255.255/32") != true and
incidr(action_remote_ip, "198.18.0.0/15") != true
| filter action_network_session_duration <= 5000
| bin _time span = 1m
| comp count(_time) as Counter by agent_hostname, action_remote_ip, _time
| filter Counter >= 500
```
</details>


## Referencje

- [Unit 42 – Threat Brief: MongoDB Vulnerability (CVE-2025-14847)](https://unit42.paloaltonetworks.com/mongobleed-cve-2025-14847/)
- [Tenable – CVE-2025-14847 (MongoBleed): MongoDB Memory Leak Vulnerability Exploited in the Wild](https://www.tenable.com/blog/cve-2025-14847-mongobleed-mongodb-memory-leak-vulnerability-exploited-in-the-wild)
- [MongoDB Security Advisory SERVER-115508](https://jira.mongodb.org/browse/SERVER-115508)
- [Censys – MongoBleed Advisory](https://censys.com/advisory/cve-2025-14847)
- [MongoBleed PoC (joe-desimone/mongobleed)](https://github.com/joe-desimone/mongobleed)

---

{{#include ../banners/hacktricks-training.md}}
