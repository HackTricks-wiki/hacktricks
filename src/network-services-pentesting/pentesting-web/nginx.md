# Nginx

{{#include ../../banners/hacktricks-training.md}}


## Emplacement root manquant <a href="#missing-root-location" id="missing-root-location"></a>

Lors de la configuration du serveur Nginx, la **root directive** joue un rôle crucial en définissant le répertoire de base à partir duquel les fichiers sont servis. Considérez l'exemple ci-dessous :
```bash
server {
root /etc/nginx;

location /hello.txt {
try_files $uri $uri/ =404;
proxy_pass http://127.0.0.1:8080/;
}
}
```
Dans cette configuration, `/etc/nginx` est désigné comme répertoire racine. Cette configuration permet d'accéder aux fichiers situés dans le répertoire root spécifié, comme `/hello.txt`. Cependant, il est crucial de noter que seule une location spécifique (`/hello.txt`) est définie. Il n'y a pas de configuration pour la location racine (`location / {...}`). Cette omission signifie que la directive root s'applique globalement, autorisant les requêtes vers le chemin racine `/` à accéder aux fichiers sous `/etc/nginx`.

Une considération de sécurité critique découle de cette configuration. Une simple requête `GET`, comme `GET /nginx.conf`, pourrait exposer des informations sensibles en servant le fichier de configuration Nginx situé à `/etc/nginx/nginx.conf`. Définir le root sur un répertoire moins sensible, comme `/etc`, pourrait atténuer ce risque, mais cela peut toujours permettre un accès non intentionnel à d'autres fichiers critiques, y compris d'autres fichiers de configuration, les journaux d'accès (access logs), et même des identifiants chiffrés utilisés pour HTTP basic authentication.

## Alias LFI Misconfiguration <a href="#alias-lfi-misconfiguration" id="alias-lfi-misconfiguration"></a>

Dans les fichiers de configuration de Nginx, une inspection attentive des directives "location" s'impose. Une vulnérabilité connue sous le nom de Local File Inclusion (LFI) peut être introduite involontairement via une configuration qui ressemble à la suivante :
```
location /imgs {
alias /path/images/;
}
```
Cette configuration est vulnérable aux attaques LFI car le serveur interprète des requêtes comme `/imgs../flag.txt` comme une tentative d'accéder à des fichiers en dehors du répertoire prévu, résolvant effectivement en `/path/images/../flag.txt`. Cette faille permet aux attaquants de récupérer des fichiers du système de fichiers du serveur qui ne devraient pas être accessibles via le web.

Pour atténuer cette vulnérabilité, la configuration doit être ajustée pour :
```
location /imgs/ {
alias /path/images/;
}
```
Plus d'infos : [https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/](https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/)

Tests Accunetix :
```
alias../ => HTTP status code 403
alias.../ => HTTP status code 404
alias../../ => HTTP status code 403
alias../../../../../../../../../../../ => HTTP status code 400
alias../ => HTTP status code 403
```
## Restriction de chemin non sécurisée <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

Consultez la page suivante pour apprendre à contourner des directives telles que :
```plaintext
location = /admin {
deny all;
}

location = /admin/ {
deny all;
}
```
{{#ref}}
../../pentesting-web/proxy-waf-protections-bypass.md
{{#endref}}

## Utilisation non sécurisée des variables / HTTP Request Splitting <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

> [!CAUTION]
> Variables vulnérables `$uri` et `$document_ur`i et cela peut être corrigé en les remplaçant par `$request_uri`.
>
> Une regex peut aussi être vulnérable comme :
>
> `location ~ /docs/([^/])? { … $1 … }` - Vulnérable
>
> `location ~ /docs/([^/\s])? { … $1 … }` - Non vulnérable (vérification des espaces)
>
> `location ~ /docs/(.*)? { … $1 … }` - Non vulnérable

L'exemple ci-dessous illustre une vulnérabilité dans la configuration Nginx :
```
location / {
return 302 https://example.com$uri;
}
```
Les caractères \r (Carriage Return) et \n (Line Feed) indiquent des sauts de ligne dans les requêtes HTTP, et leurs formes encodées en URL sont représentées par `%0d%0a`. Inclure ces caractères dans une requête (par ex., `http://localhost/%0d%0aDetectify:%20clrf`) vers un serveur mal configuré entraîne que le serveur émette un nouvel en-tête nommé `Detectify`. Cela se produit parce que la variable $uri décode les caractères de saut de ligne encodés en URL, conduisant à un en-tête inattendu dans la réponse :
```
HTTP/1.1 302 Moved Temporarily
Server: nginx/1.19.3
Content-Type: text/html
Content-Length: 145
Connection: keep-alive
Location: https://example.com/
Detectify: clrf
```
En savoir plus sur les risques de CRLF injection et de response splitting sur [https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/](https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/).

Also this technique is [**explained in this talk**](https://www.youtube.com/watch?v=gWQyWdZbdoY&list=PL0xCSYnG_iTtJe2V6PQqamBF73n7-f1Nr&index=77) avec quelques exemples vulnérables et des mécanismes de détection. Par exemple, pour détecter cette mauvaise configuration depuis une perspective blackbox vous pouvez envoyer ces requêtes :

- `https://example.com/%20X` - Any HTTP code
- `https://example.com/%20H` - 400 Bad Request

Si le serveur est vulnérable, la première répondra normalement car "X" peut être n'importe quelle méthode HTTP, et la seconde renverra une erreur car H n'est pas une méthode valide. Le serveur recevra donc quelque chose comme : `GET / H HTTP/1.1` et cela déclenchera l'erreur.

Un autre exemple de détection serait :

- `http://company.tld/%20HTTP/1.1%0D%0AXXXX:%20x` - Any HTTP code
- `http://company.tld/%20HTTP/1.1%0D%0AHost:%20x` - 400 Bad Request

Quelques configurations vulnérables présentées dans ce talk étaient :

- Notez comment **`$uri`** est défini tel quel dans l'URL finale
```
location ^~ /lite/api/ {
proxy_pass http://lite-backend$uri$is_args$args;
}
```
- Remarquez à nouveau comment **`$uri`** se trouve dans l'URL (cette fois à l'intérieur d'un paramètre)
```
location ~ ^/dna/payment {
rewrite ^/dna/([^/]+) /registered/main.pl?cmd=unifiedPayment&context=$1&native_uri=$uri break;
proxy_pass http://$back;
```
- Maintenant dans AWS S3
```
location /s3/ {
proxy_pass https://company-bucket.s3.amazonaws.com$uri;
}
```
### N'importe quelle variable

Il a été découvert que des **données fournies par l'utilisateur** peuvent parfois être traitées comme une **Nginx variable** dans certaines circonstances. La cause de ce comportement reste quelque peu mystérieuse, néanmoins ce n'est ni rare ni facile à vérifier. Cette anomalie a été mise en évidence dans un rapport de sécurité sur HackerOne, consultable [here](https://hackerone.com/reports/370094). Une investigation plus poussée du message d'erreur a permis d'identifier son occurrence dans le [SSI filter module of Nginx's codebase](https://github.com/nginx/nginx/blob/2187586207e1465d289ae64cedc829719a048a39/src/http/modules/ngx_http_ssi_filter_module.c#L365), pointant Server Side Includes (SSI) comme cause racine.

Pour **détecter cette mauvaise configuration**, la commande suivante peut être exécutée, qui consiste à définir un referer header pour tester l'affichage de la variable :
```bash
$ curl -H ‘Referer: bar’ http://localhost/foo$http_referer | grep ‘foobar’
```
Des analyses de cette mauvaise configuration à travers les systèmes ont révélé plusieurs cas où des variables Nginx pouvaient être affichées par un utilisateur. Cependant, la diminution du nombre d'instances vulnérables suggère que les efforts pour corriger ce problème ont été en partie efficaces.

### Utilisation de try_files avec les variables $URI$ARGS

La mauvaise configuration Nginx suivante peut conduire à une vulnérabilité LFI :
```
location / {
try_files $uri$args $uri$args/ /index.html;
}
```
Dans notre configuration, nous avons la directive `try_files` qui est utilisée pour vérifier l'existence de fichiers dans l'ordre spécifié. Nginx renverra le premier qu'il trouvera. La syntaxe de base de la directive `try_files` est la suivante :
```
try_files file1 file2 ... fileN fallback;
```
Nginx vérifiera l'existence de chaque fichier dans l'ordre spécifié. Si un fichier existe, il sera servi immédiatement. Si aucun des fichiers spécifiés n'existe, la requête sera transmise à l'option de repli (fallback), qui peut être une autre URI ou une page d'erreur spécifique.

Cependant, lorsqu'on utilise les variables `$uri$args` dans cette directive, Nginx tentera de rechercher un fichier correspondant à l'URI de la requête combinée avec les éventuels arguments de la query string. Nous pouvons donc exploiter cette configuration :
```
http {
server {
root /var/www/html/public;

location / {
try_files $uri$args $uri$args/ /index.html;
}
}
}
```
Avec le payload suivant :
```
GET /?../../../../../../../../etc/passwd HTTP/1.1
Host: example.com
```
En utilisant notre payload, nous contournerons le répertoire racine (défini dans la configuration Nginx) et chargerons le fichier `/etc/passwd`. Dans les journaux de débogage, on peut observer comment Nginx tente les fichiers :
```
...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 trying to use file: "/../../../../../../../../etc/passwd" "/var/www/html/public/../../../../../../../../etc/passwd"
2025/07/11 15:49:16 [debug] 79694#79694: *4 try file uri: "/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 http filename: "/var/www/html/public/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 HTTP/1.1 200 OK

```
PoC contre Nginx en utilisant la configuration mentionnée ci-dessus :
![Example burp request](../../images/nginx_try_files.png)

## Lecture de la réponse brute du backend

Nginx offre une fonctionnalité via `proxy_pass` permettant l'interception des erreurs et des en-têtes HTTP produits par le backend, dans le but de masquer les messages d'erreur internes et les en-têtes. Cela s'obtient en faisant servir par Nginx des pages d'erreur personnalisées en réponse aux erreurs du backend. Cependant, des problèmes surviennent lorsque Nginx reçoit une requête HTTP invalide. Une telle requête est transmise au backend telle quelle, et la réponse brute du backend est ensuite renvoyée directement au client sans intervention de Nginx.

Considérons un scénario d'exemple impliquant une application uWSGI :
```python
def application(environ, start_response):
start_response('500 Error', [('Content-Type', 'text/html'), ('Secret-Header', 'secret-info')])
return [b"Secret info, should not be visible!"]
```
Pour gérer cela, des directives spécifiques dans la configuration Nginx sont utilisées :
```
http {
error_page 500 /html/error.html;
proxy_intercept_errors on;
proxy_hide_header Secret-Header;
}
```
- [**proxy_intercept_errors**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_intercept_errors): Cette directive permet à Nginx de fournir une réponse personnalisée pour les réponses du backend dont le code de statut est supérieur à 300. Elle garantit que, pour notre exemple d'application uWSGI, une réponse `500 Error` est interceptée et traitée par Nginx.
- [**proxy_hide_header**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_hide_header): Comme son nom l'indique, cette directive masque certains en-têtes HTTP spécifiés au client, renforçant la confidentialité et la sécurité.

Lorsqu'une requête `GET` valide est effectuée, Nginx la traite normalement, renvoyant une réponse d'erreur standard sans révéler d'en-têtes secrets. Cependant, une requête HTTP invalide contourne ce mécanisme, entraînant l'exposition des réponses brutes du backend, y compris les en-têtes secrets et les messages d'erreur.

## merge_slashes réglé sur off

Par défaut, la **directive `merge_slashes`** de Nginx est définie sur **`on`**, ce qui compresse plusieurs barres obliques dans une URL en une seule. Cette fonctionnalité, bien qu'elle simplifie le traitement des URL, peut involontairement masquer des vulnérabilités des applications derrière Nginx, en particulier celles sujettes au local file inclusion (LFI). Les experts en sécurité Danny Robinson and Rotem Bar ont souligné les risques potentiels associés à ce comportement par défaut, surtout lorsque Nginx agit comme reverse-proxy.

Pour atténuer ces risques, il est recommandé de **désactiver la directive `merge_slashes`** pour les applications susceptibles à ces vulnérabilités. Cela garantit que Nginx transmet les requêtes à l'application sans modifier la structure de l'URL, n'occultant ainsi pas de problèmes de sécurité sous-jacents.

For more information check [Danny Robinson and Rotem Bar](https://medium.com/appsflyer/nginx-may-be-protecting-your-applications-from-traversal-attacks-without-you-even-knowing-b08f882fd43d).

### **En-têtes de réponse Maclicious**

Comme montré dans [**this writeup**](https://mizu.re/post/cors-playground), il existe certains en-têtes qui, s'ils sont présents dans la réponse du serveur web, vont changer le comportement du proxy Nginx. Vous pouvez les consulter [**in the docs**](https://www.nginx.com/resources/wiki/start/topics/examples/x-accel/):

- `X-Accel-Redirect`: Indicate Nginx to internally redirect a request to a specified location.
- `X-Accel-Buffering`: Controls whether Nginx should buffer the response or not.
- `X-Accel-Charset`: Sets the character set for the response when using X-Accel-Redirect.
- `X-Accel-Expires`: Sets the expiration time for the response when using X-Accel-Redirect.
- `X-Accel-Limit-Rate`: Limits the rate of transfer for responses when using X-Accel-Redirect.

Par exemple, l'en-tête **`X-Accel-Redirect`** provoquera une **redirection** interne dans Nginx. Ainsi, avoir une configuration Nginx avec quelque chose comme **`root /`** et une réponse du serveur web contenant **`X-Accel-Redirect: .env`** fera en sorte que Nginx envoie le contenu de **`/.env`** (Path Traversal).

### **Valeur par défaut dans la directive map**

Dans la configuration Nginx, la directive `map` joue souvent un rôle dans le contrôle d'autorisation. Une erreur fréquente est de ne pas spécifier une valeur par défaut, ce qui peut conduire à un accès non autorisé. Par exemple :
```yaml
http {
map $uri $mappocallow {
/map-poc/private 0;
/map-poc/secret 0;
/map-poc/public 1;
}
}
```

```yaml
server {
location /map-poc {
if ($mappocallow = 0) {return 403;}
return 200 "Hello. It is private area: $mappocallow";
}
}
```
Sans `default`, un **utilisateur malveillant** peut contourner la sécurité en accédant à un **URI non défini** dans `/map-poc`. [Le manuel Nginx](https://nginx.org/en/docs/http/ngx_http_map_module.html) conseille de définir une **valeur par défaut** pour éviter ce type de problème.

### **Vulnérabilité DNS Spoofing**

Le DNS spoofing contre Nginx est possible sous certaines conditions. Si un attaquant connaît le **DNS server** utilisé par Nginx et peut intercepter ses requêtes DNS, il peut spoof des enregistrements DNS. Cette méthode, toutefois, est inefficace si Nginx est configuré pour utiliser **localhost (127.0.0.1)** pour la résolution DNS. Nginx permet de spécifier un **DNS server** comme suit:
```yaml
resolver 8.8.8.8;
```
### **`proxy_pass` and `internal` Directives**

La directive **`proxy_pass`** est utilisée pour rediriger les requêtes vers d'autres serveurs, en interne ou en externe. La directive **`internal`** garantit que certains emplacements ne sont accessibles que depuis Nginx. Bien que ces directives ne soient pas des vulnérabilités en elles-mêmes, leur configuration nécessite un examen attentif pour prévenir des failles de sécurité.

## proxy_set_header Upgrade & Connection

Si le serveur nginx est configuré pour transmettre les en-têtes Upgrade et Connection, une [**h2c Smuggling attack**](../../pentesting-web/h2c-smuggling.md) pourrait être réalisée pour accéder à des endpoints protégés/internes.

> [!CAUTION]
> Cette vulnérabilité permettrait à un attaquant d'**établir une connexion directe avec le `proxy_pass` endpoint** (`http://backend:9999` dans ce cas) dont le contenu ne sera pas vérifié par nginx.

Example of vulnerable configuration to steal `/flag` from [here](https://bishopfox.com/blog/h2c-smuggling-request):
```
server {
listen       443 ssl;
server_name  localhost;

ssl_certificate       /usr/local/nginx/conf/cert.pem;
ssl_certificate_key   /usr/local/nginx/conf/privkey.pem;

location / {
proxy_pass http://backend:9999;
proxy_http_version 1.1;
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection $http_connection;
}

location /flag {
deny all;
}
```
> [!WARNING]
> Notez que même si le `proxy_pass` pointait vers un **chemin** spécifique tel que `http://backend:9999/socket.io`, la connexion sera établie avec `http://backend:9999` ; vous pouvez donc **contacter n'importe quel autre chemin à l'intérieur de ce point de terminaison interne. Donc peu importe si un chemin est spécifié dans l'URL de proxy_pass.**

## Module HTTP/3 QUIC — DoS distant & leak (2024)

En 2024, Nginx a publié les CVE-2024-31079, CVE-2024-32760, CVE-2024-34161 et CVE-2024-35200 montrant qu'une **seule session QUIC hostile** peut faire planter les processus worker ou provoquer un leak de mémoire lorsque le module expérimental `ngx_http_v3_module` est compilé et qu'un socket `listen ... quic` est exposé. Les builds impactés sont 1.25.0–1.25.5 et 1.26.0, tandis que 1.27.0/1.26.1 contiennent les correctifs ; la divulgation de mémoire (CVE-2024-34161) nécessite en outre des MTU supérieurs à 4096 octets pour faire remonter des données sensibles (détails dans l'advisory nginx 2024 référencé ci‑dessous).

**Conseils de reconnaissance et d'exploitation**

- HTTP/3 est opt-in, donc scannez les réponses `Alt-Svc: h3=":443"` ou effectuez des handshakes QUIC sur UDP/443 en brute-force ; une fois confirmé, fuzzez le handshake et les frames STREAM avec des payloads personnalisés `quiche-client`/`nghttp3` pour provoquer des plantages des workers et forcer un leak des logs.
- Identifier rapidement la prise en charge cible avec :
```bash
nginx -V 2>&1 | grep -i http_v3
rg -n "listen .*quic" /etc/nginx/
```
## Contournement de la reprise de session TLS de l'authentification par certificat client (CVE-2025-23419)

Un advisory de février 2025 a révélé que nginx 1.11.4–1.27.3 compilé avec OpenSSL permet de **réutiliser une session TLS 1.3** d'un name-based virtual host dans un autre, de sorte qu'un client ayant négocié un host sans certificat peut rejouer le ticket/PSK pour passer dans un vhost protégé avec `ssl_verify_client on;` et contourner complètement mTLS. Le bug se déclenche chaque fois que plusieurs virtual hosts partagent le même cache de session TLS 1.3 et les mêmes tickets (voir l'advisory nginx 2025 référencé ci-dessous).

**Mode opératoire de l'attaquant**
```bash
# 1. Create a TLS session on the public vhost and save the session ticket
openssl s_client -connect public.example.com:443 -sess_out ticket.pem

# 2. Replay that session ticket against the mTLS vhost before it expires
openssl s_client -connect admin.example.com:443 -sess_in ticket.pem -ign_eof
```
Si la cible est vulnérable, la deuxième poignée de main se termine sans présenter de certificat client, révélant des emplacements protégés.

**À auditer**

- Blocs `server_name` mixtes qui partagent `ssl_session_cache shared:SSL` et `ssl_session_tickets on;`.
- Blocs Admin/API qui attendent du mTLS mais héritent des réglages de cache/ticket de session partagés depuis des hôtes publics.
- Automatisation qui active la reprise de session TLS 1.3 globalement (e.g., Ansible roles) sans tenir compte de l'isolation des vhosts.

## Résilience au HTTP/2 Rapid Reset (comportement CVE-2023-44487)

L'attaque HTTP/2 Rapid Reset (CVE-2023-44487) affecte toujours nginx lorsque les opérateurs poussent `keepalive_requests` ou `http2_max_concurrent_streams` au-delà des valeurs par défaut : un attaquant ouvre une connexion HTTP/2, la noie avec des milliers de streams, puis envoie immédiatement des trames `RST_STREAM` de sorte que le plafond de concurrence n'est jamais atteint tandis que le CPU continue de consommer des ressources sur la logique d'arrêt. Les valeurs par défaut de nginx (128 concurrent streams, 1000 keepalive requests) limitent le rayon d'impact ; augmenter ces limites « de façon substantielle » rend trivial l'épuisement des workers même depuis un seul client (voir l'article F5 référencé ci-dessous).

**Conseils de détection**
```bash
# Highlight risky knobs
rg -n "http2_max_concurrent_streams" /etc/nginx/
rg -n "keepalive_requests" /etc/nginx/
```
Les hôtes qui révèlent des valeurs anormalement élevées pour ces directives sont des cibles de choix : un client HTTP/2 peut boucler en créant des streams et en envoyant instantanément des frames `RST_STREAM` pour maintenir le CPU saturé sans atteindre le plafond de concurrence.

## Essayez par vous-même

Detectify a créé un dépôt GitHub où vous pouvez utiliser Docker pour configurer votre propre serveur de test Nginx vulnérable avec certaines des mauvaises configurations abordées dans cet article et essayer de les repérer vous-même !

[https://github.com/detectify/vulnerable-nginx](https://github.com/detectify/vulnerable-nginx)

## Outils d'analyse statique

### [gixy-ng](https://github.com/dvershinin/gixy) & [GixyNG](https://github.com/megamansec/gixyng) & [GIXY](https://github.com/yandex/gixy)


- [GixyNG](https://github.com/megamansec/gixyng) (un fork mis à jour de GIXY) est un outil d'analyse des configurations Nginx, visant à trouver des vulnérabilités, des directives non sécurisées et des erreurs de configuration risquées. Il identifie également des erreurs de configuration affectant les performances et détecte des opportunités de durcissement manquées, permettant une détection automatisée des failles.
- [gixy-ng](https://github.com/dvershinin/gixy) (le fork activement maintenu de GIXY) est un outil d'analyse des configurations Nginx, visant à trouver des vulnérabilités, des directives non sécurisées et des erreurs de configuration risquées. Il identifie également des erreurs de configuration affectant les performances et détecte des opportunités de durcissement manquées, permettant une détection automatisée des failles.

### [Nginxpwner](https://github.com/stark0de/nginxpwner)

Nginxpwner est un outil simple pour rechercher des erreurs de configuration courantes de Nginx et des vulnérabilités.

## Références

- [**https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/**](https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/)
- [**http://blog.zorinaq.com/nginx-resolver-vulns/**](http://blog.zorinaq.com/nginx-resolver-vulns/)
- [**https://github.com/yandex/gixy/issues/115**](https://github.com/yandex/gixy/issues/115)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html**](https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html**](https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html)
- [**https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products**](https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products)


{{#include ../../banners/hacktricks-training.md}}
