# Nginx

{{#include ../../banners/hacktricks-training.md}}


## Brak lokalizacji root <a href="#missing-root-location" id="missing-root-location"></a>

Podczas konfigurowania serwera Nginx, **root directive** odgrywa kluczową rolę, określając katalog bazowy, z którego serwowane są pliki. Rozważ poniższy przykład:
```bash
server {
root /etc/nginx;

location /hello.txt {
try_files $uri $uri/ =404;
proxy_pass http://127.0.0.1:8080/;
}
}
```
W tej konfiguracji `/etc/nginx` jest wyznaczone jako katalog root. To ustawienie pozwala na dostęp do plików w tym katalogu, na przykład `/hello.txt`. Jednak należy zauważyć, że zdefiniowano tylko konkretną lokalizację (`/hello.txt`). Brakuje konfiguracji dla lokalizacji root (`location / {...}`). To pominięcie powoduje, że dyrektywa root jest stosowana globalnie, umożliwiając żądaniom do ścieżki root `/` dostęp do plików znajdujących się w `/etc/nginx`.

Z tej konfiguracji wynika istotne ryzyko bezpieczeństwa. Proste żądanie `GET`, na przykład `GET /nginx.conf`, może ujawnić wrażliwe informacje poprzez udostępnienie pliku konfiguracyjnego Nginx znajdującego się w `/etc/nginx/nginx.conf`. Ustawienie root na mniej wrażliwy katalog, np. `/etc`, może zmniejszyć to ryzyko, ale nadal może pozwolić na niezamierzony dostęp do innych krytycznych plików, w tym innych plików konfiguracyjnych, logów dostępu oraz nawet zaszyfrowanych poświadczeń używanych do HTTP basic authentication.

## Alias LFI Misconfiguration <a href="#alias-lfi-misconfiguration" id="alias-lfi-misconfiguration"></a>

W plikach konfiguracyjnych Nginx należy dokładnie sprawdzić dyrektywy "location". Luka znana jako Local File Inclusion (LFI) może zostać nieumyślnie wprowadzona przez konfigurację przypominającą następującą:
```
location /imgs {
alias /path/images/;
}
```
Ta konfiguracja jest podatna na ataki LFI, ponieważ serwer interpretuje żądania takie jak `/imgs../flag.txt` jako próbę dostępu do plików poza zamierzonym katalogiem, efektywnie rozwiązując je do `/path/images/../flag.txt`. Ta wada pozwala atakującym na pobranie plików z systemu plików serwera, które nie powinny być dostępne via the web.

Aby złagodzić tę podatność, konfigurację należy dostosować do:
```
location /imgs/ {
alias /path/images/;
}
```
Więcej informacji: [https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/](https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/)

Testy Accunetix:
```
alias../ => HTTP status code 403
alias.../ => HTTP status code 404
alias../../ => HTTP status code 403
alias../../../../../../../../../../../ => HTTP status code 400
alias../ => HTTP status code 403
```
## Niebezpieczne ograniczenie ścieżki <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

Sprawdź następującą stronę, aby dowiedzieć się, jak obejść dyrektywy takie jak:
```plaintext
location = /admin {
deny all;
}

location = /admin/ {
deny all;
}
```
{{#ref}}
../../pentesting-web/proxy-waf-protections-bypass.md
{{#endref}}

## Niebezpieczne użycie zmiennych / HTTP Request Splitting <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

> [!CAUTION]
> Zmiennymi podatnymi są `$uri` i `$document_ur`i — można to naprawić, zastępując je `$request_uri`.
>
> Wyrażenie regularne również może być podatne, np.:
>
> `location ~ /docs/([^/])? { … $1 … }` - Podatne
>
> `location ~ /docs/([^/\s])? { … $1 … }` - Niepodatne (sprawdzanie spacji)
>
> `location ~ /docs/(.*)? { … $1 … }` - Niepodatne

Poniższy przykład demonstruje podatność w konfiguracji Nginx:
```
location / {
return 302 https://example.com$uri;
}
```
Znaki \r (Carriage Return) i \n (Line Feed) oznaczają znaki nowej linii w żądaniach HTTP, a ich URL-encoded formy są reprezentowane jako `%0d%0a`. Dołączenie tych znaków w żądaniu (np. `http://localhost/%0d%0aDetectify:%20clrf`) do źle skonfigurowanego serwera powoduje, że serwer wystawia nowy nagłówek o nazwie `Detectify`. Dzieje się tak, ponieważ zmienna $uri dekoduje URL-encoded znaki nowej linii, co prowadzi do nieoczekiwanego nagłówka w odpowiedzi:
```
HTTP/1.1 302 Moved Temporarily
Server: nginx/1.19.3
Content-Type: text/html
Content-Length: 145
Connection: keep-alive
Location: https://example.com/
Detectify: clrf
```
Dowiedz się więcej o ryzyku CRLF injection i response splitting na [https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/](https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/).

Ta technika jest również [**explained in this talk**](https://www.youtube.com/watch?v=gWQyWdZbdoY&list=PL0xCSYnG_iTtJe2V6PQqamBF73n7-f1Nr&index=77) omówiona z kilkoma przykładami podatności i mechanizmami wykrywania. Na przykład, aby wykryć tę błędną konfigurację z perspektywy blackbox możesz wykonać następujące żądania:

- `https://example.com/%20X` - Any HTTP code
- `https://example.com/%20H` - 400 Bad Request

Jeśli serwer jest podatny, pierwsze żądanie zostanie obsłużone, ponieważ "X" jest dowolną metodą HTTP, a drugie zwróci błąd, ponieważ H nie jest prawidłową metodą. Serwer otrzyma coś w stylu: `GET / H HTTP/1.1` i to wywoła błąd.

Inne przykłady wykrywania to:

- `http://company.tld/%20HTTP/1.1%0D%0AXXXX:%20x` - Any HTTP code
- `http://company.tld/%20HTTP/1.1%0D%0AHost:%20x` - 400 Bad Request

W tej prezentacji pokazano kilka znalezionych podatnych konfiguracji:

- Zwróć uwagę, że **`$uri`** jest umieszczone w końcowym URL bez zmian
```
location ^~ /lite/api/ {
proxy_pass http://lite-backend$uri$is_args$args;
}
```
- Zauważ, jak ponownie **`$uri`** znajduje się w URL (tym razem wewnątrz parametru)
```
location ~ ^/dna/payment {
rewrite ^/dna/([^/]+) /registered/main.pl?cmd=unifiedPayment&context=$1&native_uri=$uri break;
proxy_pass http://$back;
```
- Teraz w AWS S3
```
location /s3/ {
proxy_pass https://company-bucket.s3.amazonaws.com$uri;
}
```
### Każda zmienna

Odkryto, że **dane dostarczone przez użytkownika** mogą być traktowane jako **zmienna Nginx** w pewnych okolicznościach. Przyczyna tego zachowania pozostaje nie do końca jasna, jednak nie jest to rzadkie ani łatwe do zweryfikowania. Ta anomalia została podkreślona w raporcie bezpieczeństwa na HackerOne, który można zobaczyć [here](https://hackerone.com/reports/370094). Dalsze badanie komunikatu o błędzie doprowadziło do zidentyfikowania jego występowania w [SSI filter module of Nginx's codebase](https://github.com/nginx/nginx/blob/2187586207e1465d289ae64cedc829719a048a39/src/http/modules/ngx_http_ssi_filter_module.c#L365), wskazując Server Side Includes (SSI) jako przyczynę.

Aby **wykryć tę nieprawidłową konfigurację**, można wykonać następujące polecenie, które polega na ustawieniu referer header w celu przetestowania wyświetlania zmiennych:
```bash
$ curl -H ‘Referer: bar’ http://localhost/foo$http_referer | grep ‘foobar’
```
Skanowania tej miskonfiguracji w systemach wykazały wiele przypadków, w których zmienne Nginx mogły być wyświetlone przez użytkownika. Jednak spadek liczby podatnych instancji sugeruje, że działania naprawcze były w pewnym stopniu skuteczne.

### Użycie try_files z zmiennymi $URI$ARGS

Poniższa miskonfiguracja Nginx może prowadzić do podatności LFI:
```
location / {
try_files $uri$args $uri$args/ /index.html;
}
```
W naszej konfiguracji mamy dyrektywę `try_files`, która służy do sprawdzania istnienia plików w określonej kolejności. Nginx serwuje pierwszy z nich, który znajdzie. Podstawowa składnia dyrektywy `try_files` wygląda następująco:
```
try_files file1 file2 ... fileN fallback;
```
Nginx sprawdzi istnienie każdego pliku w określonej kolejności. Jeśli plik istnieje, zostanie on natychmiast obsłużony. Jeśli żaden z wymienionych plików nie istnieje, żądanie zostanie przekazane do opcji zapasowej, która może być innym URI lub konkretną stroną błędu.

Jednak przy użyciu zmiennych `$uri$args` w tej dyrektywie, Nginx będzie próbował znaleźć plik odpowiadający URI żądania razem z parametrami zapytania. W związku z tym możemy wykorzystać tę konfigurację:
```
http {
server {
root /var/www/html/public;

location / {
try_files $uri$args $uri$args/ /index.html;
}
}
}
```
Z następującym payloadem:
```
GET /?../../../../../../../../etc/passwd HTTP/1.1
Host: example.com
```
Używając naszego payloadu wydostaniemy się z katalogu root (zdefiniowanego w konfiguracji Nginx) i załadujemy plik `/etc/passwd`. W logach debug możemy zaobserwować, jak Nginx próbuje pliki:
```
...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 trying to use file: "/../../../../../../../../etc/passwd" "/var/www/html/public/../../../../../../../../etc/passwd"
2025/07/11 15:49:16 [debug] 79694#79694: *4 try file uri: "/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 http filename: "/var/www/html/public/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 HTTP/1.1 200 OK

```
PoC przeciwko Nginx z użyciem konfiguracji opisanej powyżej:
![Example burp request](../../images/nginx_try_files.png)

## Odczyt surowej odpowiedzi backendu

Nginx oferuje funkcję poprzez `proxy_pass`, która pozwala na przechwytywanie błędów i nagłówków HTTP generowanych przez backend, mając na celu ukrycie wewnętrznych komunikatów o błędach i nagłówków. Osiąga się to poprzez serwowanie przez Nginx niestandardowych stron błędów w odpowiedzi na błędy backendu. Jednak problemy pojawiają się, gdy Nginx napotka nieprawidłowe żądanie HTTP. Takie żądanie jest przesyłane do backendu w takiej postaci, w jakiej zostało odebrane, a surowa odpowiedź backendu jest następnie wysyłana bezpośrednio do klienta bez pośrednictwa Nginx.

Rozważmy przykładowy scenariusz dotyczący aplikacji uWSGI:
```python
def application(environ, start_response):
start_response('500 Error', [('Content-Type', 'text/html'), ('Secret-Header', 'secret-info')])
return [b"Secret info, should not be visible!"]
```
Aby tym zarządzać, w konfiguracji Nginx używa się określonych dyrektyw:
```
http {
error_page 500 /html/error.html;
proxy_intercept_errors on;
proxy_hide_header Secret-Header;
}
```
- [**proxy_intercept_errors**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_intercept_errors): Dyrektywa ta pozwala Nginxowi serwować niestandardową odpowiedź dla odpowiedzi backendu ze statusem większym niż 300. Zapewnia, że, w naszym przykładzie aplikacji uWSGI, odpowiedź `500 Error` zostanie przechwycona i obsłużona przez Nginx.
- [**proxy_hide_header**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_hide_header): Jak sugeruje nazwa, dyrektywa ta ukrywa określone nagłówki HTTP przed klientem, zwiększając prywatność i bezpieczeństwo.

Gdy wykonane jest poprawne żądanie `GET`, Nginx przetwarza je normalnie, zwracając standardową odpowiedź błędu bez ujawniania żadnych ukrytych nagłówków. Jednak nieprawidłowe żądanie HTTP omija ten mechanizm, co skutkuje ujawnieniem surowych odpowiedzi backendu, w tym sekretów w nagłówkach i komunikatów o błędach.

## merge_slashes ustawione na off

Domyślnie dyrektywa **`merge_slashes`** w Nginx jest ustawiona na **`on`**, co kompresuje wielokrotne ukośniki w URL do pojedynczego ukośnika. Ta funkcja, choć upraszcza przetwarzanie URL, może niezamierzenie ukrywać luki w aplikacjach za Nginx, szczególnie tych podatnych na local file inclusion (LFI). Eksperci ds. bezpieczeństwa **Danny Robinson and Rotem Bar** zwrócili uwagę na potencjalne ryzyko związane z tym domyślnym zachowaniem, zwłaszcza gdy Nginx działa jako reverse-proxy.

Aby zmniejszyć takie ryzyko, zaleca się **wyłączyć dyrektywę `merge_slashes`** dla aplikacji podatnych na te luki. Zapewnia to, że Nginx przekazuje żądania do aplikacji bez modyfikowania struktury URL, nie maskując tym samym istniejących problemów bezpieczeństwa.

Po więcej informacji zobacz [Danny Robinson and Rotem Bar](https://medium.com/appsflyer/nginx-may-be-protecting-your-applications-from-traversal-attacks-without-you-even-knowing-b08f882fd43d).

### **Złośliwe nagłówki odpowiedzi**

Jak pokazano w [**this writeup**](https://mizu.re/post/cors-playground), istnieją pewne nagłówki, które, jeśli występują w odpowiedzi z serwera WWW, zmienią zachowanie proxy Nginx. Możesz je sprawdzić [**in the docs**](https://www.nginx.com/resources/wiki/start/topics/examples/x-accel/):

- `X-Accel-Redirect`: Indicate Nginx to internally redirect a request to a specified location.
- `X-Accel-Buffering`: Controls whether Nginx should buffer the response or not.
- `X-Accel-Charset`: Sets the character set for the response when using X-Accel-Redirect.
- `X-Accel-Expires`: Sets the expiration time for the response when using X-Accel-Redirect.
- `X-Accel-Limit-Rate`: Limits the rate of transfer for responses when using X-Accel-Redirect.

Na przykład, nagłówek **`X-Accel-Redirect`** spowoduje wewnętrzne **redirect** w nginx. Tak więc posiadanie konfiguracji nginx z czymś takim jak **`root /`** i odpowiedzi z serwera WWW zawierającej **`X-Accel-Redirect: .env`** spowoduje, że nginx wyśle zawartość **`/.env`** (Path Traversal).

### **Wartość domyślna w dyrektywie map**

W konfiguracji **Nginx** dyrektywa `map` często odgrywa rolę w kontroli autoryzacji. Częstym błędem jest nieokreślenie wartości **domyślnej**, co może prowadzić do nieautoryzowanego dostępu. Na przykład:
```yaml
http {
map $uri $mappocallow {
/map-poc/private 0;
/map-poc/secret 0;
/map-poc/public 1;
}
}
```

```yaml
server {
location /map-poc {
if ($mappocallow = 0) {return 403;}
return 200 "Hello. It is private area: $mappocallow";
}
}
```
Bez `default` **złośliwy użytkownik** może obejść zabezpieczenia, uzyskując dostęp do **niezdefiniowanego URI** w obrębie `/map-poc`. [The Nginx manual](https://nginx.org/en/docs/http/ngx_http_map_module.html) zaleca ustawienie **wartości domyślnej**, aby uniknąć takich problemów.

### **Podatność na DNS Spoofing**

DNS spoofing wobec Nginx jest możliwy w określonych warunkach. Jeśli atakujący zna **DNS server** używany przez Nginx i może przechwycić jego zapytania DNS, może sfałszować rekordy DNS. Metoda ta jest jednak nieskuteczna, jeśli Nginx jest skonfigurowany do używania **localhost (127.0.0.1)** do rozwiązywania nazw DNS. Nginx pozwala określić serwer DNS w następujący sposób:
```yaml
resolver 8.8.8.8;
```
### **Dyrektywy `proxy_pass` i `internal`**

Dyrektywa **`proxy_pass`** służy do przekierowywania żądań do innych serwerów, zarówno wewnętrznych, jak i zewnętrznych. Dyrektywa **`internal`** zapewnia, że niektóre lokalizacje są dostępne tylko wewnątrz Nginx. Chociaż same w sobie nie stanowią luk, ich konfiguracja wymaga dokładnego sprawdzenia, aby zapobiec problemom bezpieczeństwa.

## proxy_set_header Upgrade & Connection

Jeżeli serwer nginx jest skonfigurowany do przekazywania nagłówków Upgrade i Connection, można przeprowadzić [**h2c Smuggling attack**](../../pentesting-web/h2c-smuggling.md), aby uzyskać dostęp do chronionych/wewnętrznych endpointów.

> [!CAUTION]
> Ta luka pozwoliłaby atakującemu na **nawiązanie bezpośredniego połączenia z endpointem `proxy_pass`** (`http://backend:9999` w tym przypadku), którego zawartość nie będzie sprawdzana przez nginx.

Przykład podatnej konfiguracji umożliwiającej wykradzenie `/flag` znajduje się [tutaj](https://bishopfox.com/blog/h2c-smuggling-request):
```
server {
listen       443 ssl;
server_name  localhost;

ssl_certificate       /usr/local/nginx/conf/cert.pem;
ssl_certificate_key   /usr/local/nginx/conf/privkey.pem;

location / {
proxy_pass http://backend:9999;
proxy_http_version 1.1;
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection $http_connection;
}

location /flag {
deny all;
}
```
> [!WARNING]
> Zwróć uwagę, że nawet jeśli `proxy_pass` wskazywałby na konkretną **ścieżkę** taką jak `http://backend:9999/socket.io`, połączenie zostanie nawiązane z `http://backend:9999`, więc możesz **dostępować do dowolnej innej ścieżki wewnątrz tego wewnętrznego endpointu. Tak więc nie ma znaczenia, czy ścieżka jest określona w URL `proxy_pass`.**

## Moduł HTTP/3 QUIC — zdalny DoS i leak (2024)

W 2024 Nginx ujawnił CVE-2024-31079, CVE-2024-32760, CVE-2024-34161 oraz CVE-2024-35200, pokazując, że **pojedyncza wroga sesja QUIC** może spowodować awarię procesów worker lub leak pamięci, gdy eksperymentalny `ngx_http_v3_module` jest skompilowany i udostępniony jest socket `listen ... quic`. Dotknięte buildy to 1.25.0–1.25.5 oraz 1.26.0, natomiast 1.27.0/1.26.1 zawierają poprawki; ujawnienie pamięci (CVE-2024-34161) dodatkowo wymaga MTU większych niż 4096 bajtów, aby ujawnić dane wrażliwe (szczegóły w advisory nginx z 2024 r. przytoczonym poniżej).

**Recon & exploitation hints**

- HTTP/3 jest opcjonalny, więc skanuj odpowiedzi `Alt-Svc: h3=":443"` lub przeprowadzaj brute-force QUIC handshakes na UDP/443; po potwierdzeniu fuzzuj handshake i ramki STREAM za pomocą niestandardowych payloadów `quiche-client`/`nghttp3`, aby wywołać awarie workerów i wymusić log leakage.
- Szybko zidentyfikuj obsługę serwera za pomocą:
```bash
nginx -V 2>&1 | grep -i http_v3
rg -n "listen .*quic" /etc/nginx/
```
## TLS session resumption bypass of client cert auth (CVE-2025-23419)

Ostrzeżenie z lutego 2025 r. ujawniło, że nginx 1.11.4–1.27.3 kompilowany z OpenSSL pozwala na **ponowne użycie sesji TLS 1.3** z jednego name-based virtual host w innym, więc klient, który wynegocjował host bez certyfikatu, może odtworzyć ticket/PSK, aby dostać się do vhosta chronionego przez `ssl_verify_client on;` i całkowicie pominąć mTLS. Błąd występuje zawsze, gdy wiele virtual hostów współdzieli ten sam TLS 1.3 session cache i tickets (zob. ostrzeżenie nginx z 2025 roku cytowane poniżej).

**Scenariusz atakującego**
```bash
# 1. Create a TLS session on the public vhost and save the session ticket
openssl s_client -connect public.example.com:443 -sess_out ticket.pem

# 2. Replay that session ticket against the mTLS vhost before it expires
openssl s_client -connect admin.example.com:443 -sess_in ticket.pem -ign_eof
```
Jeśli cel jest podatny, drugi handshake kończy się bez przedstawienia certyfikatu klienta, ujawniając chronione lokalizacje.

**Co audytować**

- Mieszane bloki `server_name`, które współdzielą `ssl_session_cache shared:SSL` oraz `ssl_session_tickets on;`.
- Bloki Admin/API oczekujące mTLS, ale dziedziczące współdzielone ustawienia session cache/ticket od publicznych hostów.
- Automatyzacja, która globalnie włącza TLS 1.3 session resumption (np. Ansible roles) bez uwzględnienia izolacji vhostów.

## Odporność na HTTP/2 Rapid Reset (zachowanie CVE-2023-44487)

Atak HTTP/2 Rapid Reset (CVE-2023-44487) nadal dotyczy nginx, gdy administratorzy zwiększają wartości `keepalive_requests` lub `http2_max_concurrent_streams` ponad domyślne: atakujący otwiera jedno połączenie HTTP/2, zalewa je tysiącami strumieni, a następnie natychmiast wysyła ramki `RST_STREAM`, przez co pułap równoczesności nigdy nie zostaje osiągnięty, podczas gdy CPU dalej zużywa zasoby na logikę zamykania. Domyślne ustawienia nginx (128 concurrent streams, 1000 keepalive requests) utrzymują zasięg ataku na małym poziomie; podniesienie tych limitów „znacznie wyżej” sprawia, że łatwo jest wyczerpać workerów nawet z jednego klienta (zob. opis F5 cytowany poniżej).

**Wskazówki wykrywania**
```bash
# Highlight risky knobs
rg -n "http2_max_concurrent_streams" /etc/nginx/
rg -n "keepalive_requests" /etc/nginx/
```
Hosty, które ujawniają wyjątkowo wysokie wartości tych dyrektyw, są głównymi celami: jeden klient HTTP/2 może w pętli tworzyć strumienie i wysyłać natychmiastowe ramki `RST_STREAM`, aby utrzymać CPU na maksymalnym obciążeniu, nie powodując przekroczenia limitu współbieżności.

## Wypróbuj samodzielnie

Detectify utworzył repozytorium na GitHubie, gdzie możesz użyć Docker, aby skonfigurować własny podatny serwer testowy Nginx z niektórymi z błędnych konfiguracji omówionych w tym artykule i spróbować je samodzielnie znaleźć!

[https://github.com/detectify/vulnerable-nginx](https://github.com/detectify/vulnerable-nginx)

## Narzędzia analizy statycznej

### [gixy-ng](https://github.com/dvershinin/gixy) & [GixyNG](https://github.com/megamansec/gixyng) & [GIXY](https://github.com/yandex/gixy)


- [GixyNG](https://github.com/megamansec/gixyng) (an updated fork of GIXY) to narzędzie do analizy konfiguracji Nginx, mające na celu odnajdywanie podatności, niebezpiecznych dyrektyw oraz ryzykownych błędnych konfiguracji. Znajduje również konfiguracje wpływające na wydajność oraz wykrywa przeoczone możliwości utwardzenia, umożliwiając automatyczne wykrywanie błędów.
- [gixy-ng](https://github.com/dvershinin/gixy) (the actively maintained fork of GIXY) to narzędzie do analizy konfiguracji Nginx, mające na celu odnajdywanie podatności, niebezpiecznych dyrektyw oraz ryzykownych błędnych konfiguracji. Znajduje również konfiguracje wpływające na wydajność oraz wykrywa przeoczone możliwości utwardzenia, umożliwiając automatyczne wykrywanie błędów.

### [Nginxpwner](https://github.com/stark0de/nginxpwner)

Nginxpwner to proste narzędzie do wyszukiwania typowych błędnych konfiguracji Nginx i podatności.

## Referencje

- [**https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/**](https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/)
- [**http://blog.zorinaq.com/nginx-resolver-vulns/**](http://blog.zorinaq.com/nginx-resolver-vulns/)
- [**https://github.com/yandex/gixy/issues/115**](https://github.com/yandex/gixy/issues/115)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html**](https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html**](https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html)
- [**https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products**](https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products)


{{#include ../../banners/hacktricks-training.md}}
