# Nginx

{{#include ../../banners/hacktricks-training.md}}


## Nedostajući root location <a href="#missing-root-location" id="missing-root-location"></a>

Prilikom konfigurisanja Nginx servera, **root directive** igra ključnu ulogu tako što definiše osnovni direktorijum iz kojeg se fajlovi posluživaju. Pogledajte primer ispod:
```bash
server {
root /etc/nginx;

location /hello.txt {
try_files $uri $uri/ =404;
proxy_pass http://127.0.0.1:8080/;
}
}
```
U ovoj konfiguraciji, `/etc/nginx` je označen kao root direktorijum. Ova podešavanja omogućavaju pristup fajlovima unutar navedenog root direktorijuma, kao što je `/hello.txt`. Međutim, važno je napomenuti da je definisan samo specifičan location (`/hello.txt`). Nema konfiguracije za root location (`location / {...}`). Ovaj propust znači da `root` direktiva važi globalno, omogućavajući zahtevima na root putanju `/` pristup fajlovima pod `/etc/nginx`.

Iz ovog podešavanja proističe kritično bezbednosno pitanje. Jednostavan `GET` zahtev, poput `GET /nginx.conf`, može izložiti osetljive informacije tako što će poslužiti Nginx konfiguracioni fajl koji se nalazi na `/etc/nginx/nginx.conf`. Postavljanje `root` na manje osetljiv direktorijum, poput `/etc`, može ublažiti rizik, ali i dalje može dozvoliti neželjeni pristup drugim kritičnim fajlovima, uključujući druge konfiguracione fajlove, logove pristupa, pa čak i kriptovane kredencijale koji se koriste za HTTP basic authentication.

## Alias LFI pogrešna konfiguracija <a href="#alias-lfi-misconfiguration" id="alias-lfi-misconfiguration"></a>

U konfiguracionim fajlovima Nginx-a, potrebno je pažljivo pregledati `location` direktive. Ranljivost poznata kao Local File Inclusion (LFI) može se nenamerno uvesti kroz konfiguraciju koja liči na sledeću:
```
location /imgs {
alias /path/images/;
}
```
Ova konfiguracija je podložna LFI attacks zato što server tumači zahteve poput `/imgs../flag.txt` kao pokušaj pristupa fajlovima izvan predviđenog direktorijuma, što u praksi rezultira `/path/images/../flag.txt`. Ovaj propust omogućava napadačima da pristupe fajlovima u datotečnom sistemu servera koji ne bi trebalo da budu dostupni putem weba.

Da bi se ublažila ova ranjivost, konfiguracija bi trebalo da se izmeni na sledeći način:
```
location /imgs/ {
alias /path/images/;
}
```
Više informacija: [https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/](https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/)

Accunetix testovi:
```
alias../ => HTTP status code 403
alias.../ => HTTP status code 404
alias../../ => HTTP status code 403
alias../../../../../../../../../../../ => HTTP status code 400
alias../ => HTTP status code 403
```
## Nesigurno ograničenje putanje <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

Pogledajte sledeću stranicu da naučite kako zaobići direktive poput:
```plaintext
location = /admin {
deny all;
}

location = /admin/ {
deny all;
}
```
{{#ref}}
../../pentesting-web/proxy-waf-protections-bypass.md
{{#endref}}

## Neispravna upotreba varijabli / HTTP Request Splitting <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

> [!CAUTION]
> Ranjive promenljive `$uri` i `$document_ur`i — ovo se može popraviti zamenom sa `$request_uri`.
>
> Regex takođe može biti ranjiv, na primer:
>
> `location ~ /docs/([^/])? { … $1 … }` - Ranjiv
>
> `location ~ /docs/([^/\s])? { … $1 … }` - Nije ranjiv (provera razmaka)
>
> `location ~ /docs/(.*)? { … $1 … }` - Nije ranjiv

Ranljivost u Nginx konfiguraciji je demonstrirana primerom ispod:
```
location / {
return 302 https://example.com$uri;
}
```
Karakteri \r (Carriage Return) i \n (Line Feed) označavaju znake novog reda u HTTP zahtevima, a njihove URL-enkodovane forme predstavljene su kao `%0d%0a`. Uključivanje ovih karaktera u zahtev (npr. `http://localhost/%0d%0aDetectify:%20clrf`) ka pogrešno konfigurisanim serverom dovodi do toga da server izda novi header nazvan `Detectify`. Do toga dolazi zato što varijabla $uri dekodira URL-enkodovane znakove novog reda, što dovodi do neočekivanog header-a u odgovoru:
```
HTTP/1.1 302 Moved Temporarily
Server: nginx/1.19.3
Content-Type: text/html
Content-Length: 145
Connection: keep-alive
Location: https://example.com/
Detectify: clrf
```
Saznajte više o rizicima CRLF injection i response splitting na [https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/](https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/).

Takođe, ova tehnika je [**objašnjena u ovom predavanju**](https://www.youtube.com/watch?v=gWQyWdZbdoY&list=PL0xCSYnG_iTtJe2V6PQqamBF73n7-f1Nr&index=77) sa nekim ranjivim primerima i mehanizmima detekcije. Na primer, da biste otkrili ovu pogrešnu konfiguraciju iz blackbox perspektive možete poslati ove zahteve:

- `https://example.com/%20X` - Any HTTP code
- `https://example.com/%20H` - 400 Bad Request

Ako je ranjiv, prvi će vratiti odgovor jer je "X" bilo koji HTTP method, a drugi će vratiti grešku jer H nije validan method. Dakle server će primiti nešto poput: `GET / H HTTP/1.1` i to će izazvati grešku.

Drugi primeri detekcije bi bili:

- `http://company.tld/%20HTTP/1.1%0D%0AXXXX:%20x` - Any HTTP code
- `http://company.tld/%20HTTP/1.1%0D%0AHost:%20x` - 400 Bad Request

Neke pronađene ranjive konfiguracije prikazane u tom predavanju su:

- Note how **`$uri`** is set as is in the final URL
```
location ^~ /lite/api/ {
proxy_pass http://lite-backend$uri$is_args$args;
}
```
- Obratite pažnju kako je ponovo **`$uri`** u URL-u (ovaj put unutar parametra)
```
location ~ ^/dna/payment {
rewrite ^/dna/([^/]+) /registered/main.pl?cmd=unifiedPayment&context=$1&native_uri=$uri break;
proxy_pass http://$back;
```
- Sada u AWS S3
```
location /s3/ {
proxy_pass https://company-bucket.s3.amazonaws.com$uri;
}
```
### Bilo koja promenljiva

Otkriveno je da se **podatak koji korisnik prosleđuje** u određenim okolnostima može tretirati kao **Nginx promenljiva**.

Uzrok ovog ponašanja ostaje donekle nejasan, ali nije redak i nije jednostavno proveriti. Ovu anomaliju je istakao izveštaj o bezbednosti na HackerOne, koji se može pogledati [here](https://hackerone.com/reports/370094). Daljom istragom poruke o grešci utvrđeno je da se pojavljuje u okviru [SSI filter module of Nginx's codebase](https://github.com/nginx/nginx/blob/2187586207e1465d289ae64cedc829719a048a39/src/http/modules/ngx_http_ssi_filter_module.c#L365), što ukazuje na Server Side Includes (SSI) kao osnovni uzrok.

Da biste **otkrili ovu pogrešnu konfiguraciju**, može se izvršiti sledeća komanda, koja podrazumeva postavljanje referer header-a da bi se testiralo ispisivanje promenljive:
```bash
$ curl -H ‘Referer: bar’ http://localhost/foo$http_referer | grep ‘foobar’
```
Skeniranja za ovu pogrešnu konfiguraciju na sistemima otkrila su više slučajeva gde su Nginx promenljive mogle biti ispisane od strane korisnika. Međutim, smanjenje broja ranjivih instanci sugeriše da su napori za zakrpljivanje ovog problema bili donekle uspešni.

### Korišćenje try_files sa $URI$ARGS varijablama

Sledeća pogrešna konfiguracija Nginx-a može dovesti do LFI ranjivosti:
```
location / {
try_files $uri$args $uri$args/ /index.html;
}
```
U našoj konfiguraciji imamo direktivu `try_files` koja se koristi za proveru postojanja fajlova u navedenom redosledu. Nginx će poslužiti prvi fajl koji pronađe. Osnovna sintaksa direktive `try_files` je sledeća:
```
try_files file1 file2 ... fileN fallback;
```
Nginx će proveriti postojanje svake datoteke u navedenom redosledu. Ako datoteka postoji, poslužiće se odmah. Ako nijedna od navedenih datoteka ne postoji, zahtev će biti prosleđen fallback opciji, koja može biti drugi URI ili specifična error stranica.

Međutim, kada se u ovoj direktivi koriste $uri$args varijable, Nginx će pokušati da pronađe datoteku koja odgovara request URI kombinovanom sa bilo kojim argumentima query string-a. Zbog toga možemo exploit-ovati ovu konfiguraciju:
```
http {
server {
root /var/www/html/public;

location / {
try_files $uri$args $uri$args/ /index.html;
}
}
}
```
Sa sledećim payload:
```
GET /?../../../../../../../../etc/passwd HTTP/1.1
Host: example.com
```
Koristeći naš payload izaći ćemo iz root direktorijuma (definisanog u Nginx konfiguraciji) i učitati fajl `/etc/passwd`. U debug logovima možemo videti kako Nginx pokušava fajlove:
```
...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 trying to use file: "/../../../../../../../../etc/passwd" "/var/www/html/public/../../../../../../../../etc/passwd"
2025/07/11 15:49:16 [debug] 79694#79694: *4 try file uri: "/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 http filename: "/var/www/html/public/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 HTTP/1.1 200 OK

```
PoC protiv Nginx-a koristeći konfiguraciju pomenutu iznad:
![Primer burp zahteva](../../images/nginx_try_files.png)

## Čitanje sirovog odgovora backend-a

Nginx nudi funkcionalnost preko `proxy_pass` koja omogućava presretanje grešaka i HTTP zaglavlja koje generiše backend, sa ciljem da sakrije interne poruke o greškama i zaglavlja. Ovo se postiže tako što Nginx servira prilagođene stranice greške kao odgovor na backend greške. Međutim, problemi nastaju kada Nginx dobije nevažeći HTTP zahtev. Takav zahtev se prosleđuje backend-u onako kako je stigao, i backend-ov sirovi odgovor se potom direktno šalje klijentu bez Nginx-ove intervencije.

Razmotrite primer scenarija koji uključuje uWSGI aplikaciju:
```python
def application(environ, start_response):
start_response('500 Error', [('Content-Type', 'text/html'), ('Secret-Header', 'secret-info')])
return [b"Secret info, should not be visible!"]
```
Da bi se to kontrolisalo, koriste se specifične direktive u Nginx konfiguraciji:
```
http {
error_page 500 /html/error.html;
proxy_intercept_errors on;
proxy_hide_header Secret-Header;
}
```
- [**proxy_intercept_errors**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_intercept_errors): Ova direktiva omogućava Nginx-u da isporuči prilagođen odgovor za backend odgovore sa status kodom većim od 300. Ona osigurava da, za naš primer uWSGI aplikacije, `500 Error` odgovor bude presretnut i obrađen od strane Nginx-a.
- [**proxy_hide_header**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_hide_header): Kao što ime sugeriše, ova direktiva skriva navedena HTTP zaglavlja od klijenta, poboljšavajući privatnost i bezbednost.

Kada se pošalje validan `GET` zahtev, Nginx ga obrađuje normalno, vraćajući standardni odgovor o grešci bez otkrivanja bilo kojih tajnih zaglavlja. Međutim, nevažeći HTTP zahtev zaobilazi ovaj mehanizam, što dovodi do izlaganja sirovih backend odgovora, uključujući tajna zaglavlja i poruke o grešci.

## merge_slashes postavljeno na off

Podrazumevano, Nginx-ova **`merge_slashes` direktiva** je postavljena na **`on`**, koja kompresuje više kosih crta u URL-u u jednu kosu crtu. Ova funkcija, iako pojednostavljuje obradu URL-a, može nenamerno prikriti ranjivosti u aplikacijama iza Nginx-a, naročito one podložne local file inclusion (LFI) napadima. Bezbednosni stručnjaci **Danny Robinson and Rotem Bar** skrenuli su pažnju na potencijalne rizike povezane sa ovim podrazumevanim ponašanjem, posebno kada Nginx radi kao reverse-proxy.

Da bi se ublažili takvi rizici, preporučuje se da se **`merge_slashes` direktiva isključi** za aplikacije koje su podložne ovim ranjivostima. Ovo osigurava da Nginx prosleđuje zahteve aplikaciji bez menjanja strukture URL-a, čime se ne prikrivaju eventualni bezbednosni problemi.

Za više informacija pogledajte [Danny Robinson and Rotem Bar](https://medium.com/appsflyer/nginx-may-be-protecting-your-applications-from-traversal-attacks-without-you-even-knowing-b08f882fd43d).

### **Maclicious zaglavlja odgovora**

Kao što je prikazano u [**this writeup**](https://mizu.re/post/cors-playground), postoje određena zaglavlja koja, ako su prisutna u odgovoru web servera, menjaju ponašanje Nginx proxy-a. Možete ih proveriti [**in the docs**](https://www.nginx.com/resources/wiki/start/topics/examples/x-accel/):

- `X-Accel-Redirect`: Nalaže Nginx-u interno preusmeravanje zahteva na određenu lokaciju.
- `X-Accel-Buffering`: Kontroliše da li Nginx treba da bufferuje odgovor ili ne.
- `X-Accel-Charset`: Postavlja karakter set za odgovor kada se koristi X-Accel-Redirect.
- `X-Accel-Expires`: Postavlja vreme isteka za odgovor kada se koristi X-Accel-Redirect.
- `X-Accel-Limit-Rate`: Ograničava brzinu prenosa za odgovore kada se koristi X-Accel-Redirect.

Na primer, zaglavlje **`X-Accel-Redirect`** će uzrokovati internu **redirect** u nginx-u. Dakle, ako nginx konfiguracija sadrži, na primer, **`root /`**, a web server u odgovoru pošalje **`X-Accel-Redirect: .env`**, nginx će poslati sadržaj **`/.env`** (Path Traversal).

### **Podrazumevana vrednost u map direktivi**

U **Nginx konfiguraciji**, `map` direktiva često igra ulogu u kontroli autorizacije. Česta greška je neodređivanje **default** vrednosti, što može dovesti do neovlašćenog pristupa. Na primer:
```yaml
http {
map $uri $mappocallow {
/map-poc/private 0;
/map-poc/secret 0;
/map-poc/public 1;
}
}
```

```yaml
server {
location /map-poc {
if ($mappocallow = 0) {return 403;}
return 200 "Hello. It is private area: $mappocallow";
}
}
```
Bez `default` vrednosti, **zlonamerni korisnik** može zaobići zaštitu pristupom **nedefinisanom URI-ju** unutar `/map-poc`. [The Nginx manual](https://nginx.org/en/docs/http/ngx_http_map_module.html) savetuje postavljanje **default value** kako bi se izbegli takvi problemi.

### **DNS Spoofing Ranjivost**

DNS spoofing protiv Nginx-a je izvodljivo pod određenim uslovima. Ako napadač zna **DNS server** koji Nginx koristi i može presretati njegove DNS upite, može falsifikovati DNS zapise. Međutim, ova metoda je neefikasna ako je Nginx konfigurisan da koristi **localhost (127.0.0.1)** za DNS rezoluciju. Nginx dozvoljava navođenje DNS servera na sledeći način:
```yaml
resolver 8.8.8.8;
```
### **`proxy_pass` i `internal` direktive**

Direktiva **`proxy_pass`** se koristi za preusmeravanje zahteva ka drugim serverima, bilo interno ili eksterno. Direktiva **`internal`** osigurava da su određene lokacije dostupne samo unutar Nginx-a. Iako same ove direktive nisu ranjivosti, njihova konfiguracija zahteva pažljivu proveru kako bi se sprečili bezbednosni propusti.

## proxy_set_header Upgrade & Connection

Ako je nginx server konfigurisan da prosleđuje Upgrade and Connection headers, može se izvesti [**h2c Smuggling attack**](../../pentesting-web/h2c-smuggling.md) kako bi se pristupilo zaštićenim/internim endpoint-ima.

> [!CAUTION]
> Ova ranjivost bi omogućila napadaču da **uspostavi direktnu vezu sa `proxy_pass` endpoint-om** (`http://backend:9999` u ovom slučaju) čiji sadržaj nginx neće proveravati.

Example of vulnerable configuration to steal `/flag` from [here](https://bishopfox.com/blog/h2c-smuggling-request):
```
server {
listen       443 ssl;
server_name  localhost;

ssl_certificate       /usr/local/nginx/conf/cert.pem;
ssl_certificate_key   /usr/local/nginx/conf/privkey.pem;

location / {
proxy_pass http://backend:9999;
proxy_http_version 1.1;
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection $http_connection;
}

location /flag {
deny all;
}
```
> [!WARNING]
> Imajte na umu da čak i ako `proxy_pass` pokazuje na specifičan **path** kao što je `http://backend:9999/socket.io` konekcija će biti uspostavljena sa `http://backend:9999` pa možete **kontaktirati bilo koji drugi path unutar tog internog endpointa. Dakle, nije važno ako je put specificiran u URL-u `proxy_pass`.**

## HTTP/3 QUIC module remote DoS & leak (2024)

Tokom 2024. Nginx je objavio CVE-2024-31079, CVE-2024-32760, CVE-2024-34161 i CVE-2024-35200, pokazujući da jedna zlonamerna QUIC sesija može srušiti worker procese ili leak memoriju kad god je eksperimentalni `ngx_http_v3_module` uključen i izložen `listen ... quic` socket. Pogođene verzije su 1.25.0–1.25.5 i 1.26.0, dok 1.27.0/1.26.1 sadrže zakrpe; the memory disclosure (CVE-2024-34161) dodatno zahteva MTU-eve veće od 4096 bajtova da bi se osetljivi podaci pojavili (detalji u 2024 nginx advisory referenciranom ispod).

**Recon & exploitation hints**

- HTTP/3 je opt-in, pa skenirajte za `Alt-Svc: h3=":443"` odgovore ili brute-force UDP/443 QUIC handshakes; nakon potvrde, fuzz-ujte handshake i STREAM frejmove sa prilagođenim `quiche-client`/`nghttp3` payload-ovima da biste izazvali rušenja workera i forsirali log leakage.
- Brzo identifikujte podršku mete pomoću:
```bash
nginx -V 2>&1 | grep -i http_v3
rg -n "listen .*quic" /etc/nginx/
```
## Zaobilaženje verifikacije klijentskog sertifikata preko ponovnog uspostavljanja TLS sesije (CVE-2025-23419)

U februaru 2025. objavljeno je advisory da nginx 1.11.4–1.27.3 kompajliran sa OpenSSL dozvoljava **ponovnu upotrebu TLS 1.3 sesije** iz jednog virtualnog hosta zasnovanog na imenu unutar drugog, tako da klijent koji je pregovarao host bez zahteva za sertifikatom može ponovo poslati ticket/PSK i preći u vhost zaštićen sa `ssl_verify_client on;` i potpuno zaobići mTLS. Greška se aktivira kad god više virtualnih hostova deli isti TLS 1.3 session cache i tickets (pogledajte 2025 nginx advisory navedenu dole).

**Plan napadača**
```bash
# 1. Create a TLS session on the public vhost and save the session ticket
openssl s_client -connect public.example.com:443 -sess_out ticket.pem

# 2. Replay that session ticket against the mTLS vhost before it expires
openssl s_client -connect admin.example.com:443 -sess_in ticket.pem -ign_eof
```
Ako je cilj ranjiv, drugi handshake se završi bez prezentovanja client certificate, otkrivajući zaštićene lokacije.

**Šta proveriti**

- Pomešani `server_name` blokovi koji dele `ssl_session_cache shared:SSL` i `ssl_session_tickets on;`.
- Admin/API blokovi koji očekuju mTLS, ali nasleđuju podešavanja deljenog session cache/ticket od javnih hostova.
- Automatizacija koja omogućava TLS 1.3 session resumption globalno (npr. Ansible roles) bez razmatranja izolacije vhost-a.

## HTTP/2 Rapid Reset otpornost (CVE-2023-44487 ponašanje)

The HTTP/2 Rapid Reset attack (CVE-2023-44487) i dalje pogađa nginx kada operatori pojačaju `keepalive_requests` ili `http2_max_concurrent_streams` iznad podrazumevanih vrednosti: napadač otvara jednu HTTP/2 connection, preplavljuje je sa hiljadama stream-ova, zatim odmah šalje `RST_STREAM` frejmove tako da se plafon konkurentnosti nikada ne dostigne dok CPU nastavlja da troši resurse na logiku raskida. Nginx podrazumevana podešavanja (128 concurrent streams, 1000 keepalive requests) drže blast radius mali; podizanje tih ograničenja "znatno više" čini jednostavnim uskraćivanje radnika čak i od jednog klijenta (pogledajte F5 write-up spomenut dole).

**Saveti za detekciju**
```bash
# Highlight risky knobs
rg -n "http2_max_concurrent_streams" /etc/nginx/
rg -n "keepalive_requests" /etc/nginx/
```
Hostovi koji otkrivaju neuobičajeno visoke vrednosti tih direktiva su primarni ciljevi: jedan HTTP/2 klijent može da u petlji kreira streamove i šalje instant `RST_STREAM` frejmove kako bi držao CPU na maksimumu bez aktiviranja ograničenja konkurentnosti.

## Isprobajte sami

Detectify je napravio GitHub repozitorijum gde možete pomoću Dockera podići sopstveni ranjivi Nginx test server sa nekim od miskonfiguracija opisanih u ovom članku i pokušati da ih pronađete sami!

[https://github.com/detectify/vulnerable-nginx](https://github.com/detectify/vulnerable-nginx)

## Alati za statičku analizu

### [GIXY](https://github.com/yandex/gixy)

Gixy je alat za analizu Nginx konfiguracije. Glavni cilj Gixy-ja je da spreči sigurnosne miskonfiguracije i automatizuje otkrivanje propusta.

### [Nginxpwner](https://github.com/stark0de/nginxpwner)

Nginxpwner je jednostavan alat za pronalaženje uobičajenih Nginx miskonfiguracija i ranjivosti.

## Reference

- [**https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/**](https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/)
- [**http://blog.zorinaq.com/nginx-resolver-vulns/**](http://blog.zorinaq.com/nginx-resolver-vulns/)
- [**https://github.com/yandex/gixy/issues/115**](https://github.com/yandex/gixy/issues/115)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html**](https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html**](https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html)
- [**https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products**](https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products)


{{#include ../../banners/hacktricks-training.md}}
