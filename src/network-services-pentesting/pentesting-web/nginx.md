# Nginx

{{#include ../../banners/hacktricks-training.md}}


## Nedostajuća root lokacija <a href="#missing-root-location" id="missing-root-location"></a>

Prilikom konfigurisanja Nginx servera, **root directive** ima ključnu ulogu jer definiše bazni direktorijum iz kojeg se poslužuju fajlovi. Pogledajte primer ispod:
```bash
server {
root /etc/nginx;

location /hello.txt {
try_files $uri $uri/ =404;
proxy_pass http://127.0.0.1:8080/;
}
}
```
U ovoj konfiguraciji, `/etc/nginx` je označen kao root direktorijum. Ovakvo podešavanje omogućava pristup fajlovima unutar navedenog root direktorijuma, kao što je `/hello.txt`. Međutim, važno je napomenuti da je definisana samo specifična lokacija (`/hello.txt`). Nema konfiguracije za root lokaciju (`location / {...}`). Ova izostavka znači da root direktiva važi globalno, omogućavajući zahtevima za root putanju `/` da pristupe fajlovima pod `/etc/nginx`.

Od ove konfiguracije proizilazi značajan bezbednosni problem. Jednostavan `GET` zahtev, poput `GET /nginx.conf`, može izložiti osetljive informacije tako što će servirati Nginx konfiguracioni fajl koji se nalazi na `/etc/nginx/nginx.conf`. Postavljanje root na manje osetljiv direktorijum, npr. `/etc`, može ublažiti ovaj rizik, ali i dalje može omogućiti nenamerni pristup drugim kritičnim fajlovima, uključujući druge konfiguracione fajlove, access logove i čak šifrovane kredencijale korišćene za HTTP basic authentication.

## Alias LFI - pogrešna konfiguracija <a href="#alias-lfi-misconfiguration" id="alias-lfi-misconfiguration"></a>

U konfiguracionim fajlovima Nginx-a treba pažljivo pregledati "location" direktive. Ranljivost poznata kao Local File Inclusion (LFI) može se nenamerno pojaviti kroz konfiguraciju koja liči na sledeću:
```
location /imgs {
alias /path/images/;
}
```
Ova konfiguracija je podložna LFI napadima zato što server tumači zahteve poput `/imgs../flag.txt` kao pokušaj pristupa fajlovima izvan predviđenog direktorijuma, efektivno rešavajući ih kao `/path/images/../flag.txt`. Ovaj propust omogućava napadačima da preuzmu fajlove iz fajl-sistema servera koji ne bi trebalo da budu dostupni preko weba.

Da bi se umanjila ova ranjivost, konfiguracija bi trebalo da bude prilagođena na:
```
location /imgs/ {
alias /path/images/;
}
```
Više informacija: [https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/](https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/)

Accunetix testovi:
```
alias../ => HTTP status code 403
alias.../ => HTTP status code 404
alias../../ => HTTP status code 403
alias../../../../../../../../../../../ => HTTP status code 400
alias../ => HTTP status code 403
```
## Nesigurna ograničenja putanja <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

Pogledajte sledeću stranicu da biste naučili kako zaobići direktive poput:
```plaintext
location = /admin {
deny all;
}

location = /admin/ {
deny all;
}
```
{{#ref}}
../../pentesting-web/proxy-waf-protections-bypass.md
{{#endref}}

## Nezaštićeno korišćenje promenljivih / HTTP Request Splitting <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

> [!CAUTION]
> Ranljive promenljive `$uri` i `$document_ur`i; ovo se može popraviti zamenom sa `$request_uri`.
>
> Regex takođe može biti ranjiv, na primer:
>
> `location ~ /docs/([^/])? { … $1 … }` - Ranjivo
>
> `location ~ /docs/([^/\s])? { … $1 … }` - Nije ranjivo (provera razmaka)
>
> `location ~ /docs/(.*)? { … $1 … }` - Nije ranjivo

Sledeći primer prikazuje ranjivost u Nginx konfiguraciji:
```
location / {
return 302 https://example.com$uri;
}
```
Karakteri \r (Carriage Return) i \n (Line Feed) označavaju znake novog reda u HTTP zahtevima, a njihove URL-enkodovane forme predstavljene su kao `%0d%0a`. Uključivanje ovih karaktera u zahtev (npr. `http://localhost/%0d%0aDetectify:%20clrf`) ka pogrešno konfigurisanoj serveru rezultira time da server izda novi header pod nazivom `Detectify`. To se dešava zato što promenljiva $uri dešifruje URL-enkodovane znakove novog reda, što dovodi do neočekivanog header-a u odgovoru:
```
HTTP/1.1 302 Moved Temporarily
Server: nginx/1.19.3
Content-Type: text/html
Content-Length: 145
Connection: keep-alive
Location: https://example.com/
Detectify: clrf
```
Saznajte više o rizicima CRLF injection i response splitting na [https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/](https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/).

Takođe, ova tehnika je [**explained in this talk**](https://www.youtube.com/watch?v=gWQyWdZbdoY&list=PL0xCSYnG_iTtJe2V6PQqamBF73n7-f1Nr&index=77) sa nekoliko ranjivih primera i mehanizmima detekcije. Na primer, da biste detektovali ovu miskonfiguraciju iz blackbox perspektive možete poslati sledeće zahteve:

- `https://example.com/%20X` - Any HTTP code
- `https://example.com/%20H` - 400 Bad Request

Ako je ranjiv, prvi će odgovoriti (bilo koji HTTP kod), jer je "X" bilo koja HTTP metoda, a drugi će vratiti grešku jer "H" nije validna metoda. Dakle server će primiti nešto poput: `GET / H HTTP/1.1` i to će pokrenuti grešku.

Drugi primeri detekcije bili bi:

- `http://company.tld/%20HTTP/1.1%0D%0AXXXX:%20x` - Any HTTP code
- `http://company.tld/%20HTTP/1.1%0D%0AHost:%20x` - 400 Bad Request

Neke ranjive konfiguracije prikazane u tom predavanju su bile:

- Obratite pažnju kako je **`$uri`** postavljen takav kakav jeste u finalnom URL-u
```
location ^~ /lite/api/ {
proxy_pass http://lite-backend$uri$is_args$args;
}
```
- Primeti kako je ponovo **`$uri`** u URL-u (ovaj put unutar parametra)
```
location ~ ^/dna/payment {
rewrite ^/dna/([^/]+) /registered/main.pl?cmd=unifiedPayment&context=$1&native_uri=$uri break;
proxy_pass http://$back;
```
- Sada u AWS S3
```
location /s3/ {
proxy_pass https://company-bucket.s3.amazonaws.com$uri;
}
```
### Bilo koja promenljiva

Otkriveno je da se **user-supplied data** može tretirati kao **Nginx variable** u određenim okolnostima. Uzrok ovog ponašanja je donekle neuhvatljiv, ali nije retko niti jednostavno za verifikaciju. Ova anomalija je istaknuta u security report-u na HackerOne, koji se može pogledati [here](https://hackerone.com/reports/370094). Daljom istragom poruke o grešci otkriveno je da se pojavljuje unutar [SSI filter module of Nginx's codebase](https://github.com/nginx/nginx/blob/2187586207e1465d289ae64cedc829719a048a39/src/http/modules/ngx_http_ssi_filter_module.c#L365), što ukazuje da su Server Side Includes (SSI) koren problema.

Da biste **otkrili ovu pogrešnu konfiguraciju**, možete izvršiti sledeću naredbu, koja podrazumeva postavljanje referer header-a kako biste testirali variable printing:
```bash
$ curl -H ‘Referer: bar’ http://localhost/foo$http_referer | grep ‘foobar’
```
Skaniranja za ovu pogrešnu konfiguraciju na različitim sistemima otkrila su više slučajeva gde su Nginx varijable mogle biti ispisane od strane korisnika. Međutim, smanjenje broja ranjivih instanci sugeriše da su napori za zakrpu ovog problema donekle uspešni.

### Korišćenje try_files sa $URI$ARGS varijablama

Sledeća Nginx pogrešna konfiguracija može dovesti do LFI ranjivosti:
```
location / {
try_files $uri$args $uri$args/ /index.html;
}
```
U našoj konfiguraciji imamo direktivu `try_files` koja se koristi za proveru postojanja fajlova u navedenom redosledu. Nginx će poslužiti prvi koji pronađe. Osnovna sintaksa direktive `try_files` je sledeća:
```
try_files file1 file2 ... fileN fallback;
```
Nginx će proveriti postojanje svake datoteke u navedenom redosledu. Ako datoteka postoji, biće odmah poslužena. Ako nijedna od navedenih datoteka ne postoji, zahtev će biti prebačen na fallback opciju, koja može biti druga URI ili određena stranica za grešku.

Međutim, kada se u ovoj direktivi koriste promenljive `$uri$args`, Nginx će pokušati da pronađe datoteku koja odgovara URI-ju zahteva kombinovanom sa svim argumentima query string-a. Zbog toga možemo iskoristiti ovu konfiguraciju:
```
http {
server {
root /var/www/html/public;

location / {
try_files $uri$args $uri$args/ /index.html;
}
}
}
```
Sa sledećim payload-om:
```
GET /?../../../../../../../../etc/passwd HTTP/1.1
Host: example.com
```
Korišćenjem našeg payload-a pobeći ćemo iz root directory (definisanog u Nginx konfiguraciji) i učitati fajl `/etc/passwd`. U debug logovima možemo da posmatramo kako Nginx pokušava fajlove:
```
...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 trying to use file: "/../../../../../../../../etc/passwd" "/var/www/html/public/../../../../../../../../etc/passwd"
2025/07/11 15:49:16 [debug] 79694#79694: *4 try file uri: "/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 http filename: "/var/www/html/public/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 HTTP/1.1 200 OK

```
PoC protiv Nginx-a koristeći konfiguraciju pomenutu iznad:
![Primer burp zahteva](../../images/nginx_try_files.png)

## Čitanje sirovog odgovora backenda

Nginx nudi mogućnost preko `proxy_pass` koja omogućava presretanje grešaka i HTTP zaglavlja koje proizvodi backend, sa ciljem da sakrije interne poruke o greškama i zaglavlja. Ovo se postiže tako što Nginx prikazuje prilagođene stranice grešaka kao odgovor na greške backenda. Međutim, problem nastaje kada Nginx naiđe na nevažeći HTTP zahtev. Takav zahtev se prosleđuje backendu onakvim kakav je primljen, a sirovi odgovor backenda se zatim direktno šalje klijentu bez intervencije Nginx-a.

Razmotrite primer scenarija koji uključuje uWSGI aplikaciju:
```python
def application(environ, start_response):
start_response('500 Error', [('Content-Type', 'text/html'), ('Secret-Header', 'secret-info')])
return [b"Secret info, should not be visible!"]
```
Za upravljanje ovim koriste se određene direktive u Nginx konfiguraciji:
```
http {
error_page 500 /html/error.html;
proxy_intercept_errors on;
proxy_hide_header Secret-Header;
}
```
- [**proxy_intercept_errors**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_intercept_errors): Ova direktiva omogućava Nginx-u da posluži prilagođeni odgovor za backend odgovore sa statusnim kodom većim od 300. To osigurava da se, za naš primer uWSGI aplikacije, odgovor `500 Error` presretne i obradi od strane Nginx-a.
- [**proxy_hide_header**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_hide_header): Kao što ime sugeriše, ova direktiva skriva određene HTTP zaglavlja od klijenta, povećavajući privatnost i bezbednost.

Kada se napravi važeći `GET` zahtev, Nginx ga obrađuje normalno, vraćajući standardni error odgovor bez otkrivanja tajnih zaglavlja. Međutim, nevažeći HTTP zahtev zaobilazi ovaj mehanizam, što dovodi do izlaganja sirovih backend odgovora, uključujući tajna zaglavlja i poruke o grešci.

## merge_slashes set to off

Po defaultu, Nginx-ova **`merge_slashes` direktiva** je postavljena na **`on`**, što kompresuje više kosih crta u URL-u u jednu kosu crtu. Ova funkcionalnost, iako pojednostavljuje obradu URL-a, može nenamerno prikriti ranjivosti u aplikacijama iza Nginx-a, naročito one sklone local file inclusion (LFI) napadima. Bezbednosni stručnjaci **Danny Robinson and Rotem Bar** su istakli potencijalne rizike povezane sa ovim podrazumevanim ponašanjem, posebno kada Nginx radi kao reverse-proxy.

Da bi se ublažili takvi rizici, preporučuje se da se **`merge_slashes` direktiva isključi** za aplikacije koje su osetljive na ove ranjivosti. Ovo osigurava da Nginx prosledi zahteve aplikaciji bez menjanja strukture URL-a, čime se ne maskiraju eventualni bezbednosni problemi.

For more information check [Danny Robinson and Rotem Bar](https://medium.com/appsflyer/nginx-may-be-protecting-your-applications-from-traversal-attacks-without-you-even-knowing-b08f882fd43d).

### **Maliciozna zaglavlja odgovora**

Kao što je prikazano u [**this writeup**](https://mizu.re/post/cors-playground), postoje određena zaglavlja koja, ako su prisutna u odgovoru web servera, menjaju ponašanje Nginx proxy-ja. Možete ih proveriti [**in the docs**](https://www.nginx.com/resources/wiki/start/topics/examples/x-accel/):

- `X-Accel-Redirect`: Nalaže Nginx-u da interno preusmeri zahtev na određenu lokaciju.
- `X-Accel-Buffering`: Kontroliše da li Nginx treba da buforiše odgovor ili ne.
- `X-Accel-Charset`: Postavlja set karaktera za odgovor prilikom korišćenja X-Accel-Redirect.
- `X-Accel-Expires`: Postavlja vreme isteka za odgovor prilikom korišćenja X-Accel-Redirect.
- `X-Accel-Limit-Rate`: Ograničava brzinu transfera za odgovore prilikom korišćenja X-Accel-Redirect.

Na primer, zaglavlje **`X-Accel-Redirect`** će prouzrokovati interno **preusmeravanje** u Nginx-u. Dakle, ako Nginx konfiguracija sadrži nešto poput **`root /`** i odgovor web servera ima **`X-Accel-Redirect: .env`**, Nginx će poslati sadržaj **`/.env`** (Path Traversal).

### **Default Value in Map Directive**

U **Nginx konfiguraciji**, `map` direktiva često ima ulogu u kontroli pristupa. Česta greška je neodređivanje **podrazumevane** vrednosti, što može dovesti do neautorizovanog pristupa. Na primer:
```yaml
http {
map $uri $mappocallow {
/map-poc/private 0;
/map-poc/secret 0;
/map-poc/public 1;
}
}
```

```yaml
server {
location /map-poc {
if ($mappocallow = 0) {return 403;}
return 200 "Hello. It is private area: $mappocallow";
}
}
```
Bez `default`, **maliciozni korisnik** može zaobići bezbednost pristupanjem **nedefinisanom URI-ju** unutar `/map-poc`. [The Nginx manual](https://nginx.org/en/docs/http/ngx_http_map_module.html) savetuje postavljanje **podrazumevane vrednosti** da bi se izbegli takvi problemi.

### **DNS Spoofing Vulnerability**

DNS spoofing protiv Nginx-a je izvodljiv pod određenim uslovima. Ako napadač zna **DNS server** koji Nginx koristi i može presretati njegove DNS upite, može falsifikovati DNS zapise. Ova metoda, međutim, nije efektivna ako je Nginx konfigurisan da koristi **localhost (127.0.0.1)** za DNS rezoluciju. Nginx dozvoljava navođenje DNS servera na sledeći način:
```yaml
resolver 8.8.8.8;
```
### **`proxy_pass` i `internal` direktive**

Direktiva **`proxy_pass`** se koristi za preusmeravanje zahteva na druge servere, bilo interno ili eksterno. Direktiva **`internal`** osigurava da su određene lokacije dostupne samo unutar Nginx-a. Iako same direktive nisu ranjivosti, njihova konfiguracija zahteva pažljivo ispitivanje kako bi se sprečili bezbednosni propusti.

## proxy_set_header Upgrade & Connection

Ako je nginx server konfigurisan da prosleđuje Upgrade i Connection header-e, može se izvesti [**h2c Smuggling attack**](../../pentesting-web/h2c-smuggling.md) kako bi se pristupilo zaštićenim/internim endpoint-ima.

> [!CAUTION]
> Ova ranjivost bi omogućila napadaču da uspostavi direktnu vezu sa `proxy_pass` endpoint-om (`http://backend:9999` u ovom slučaju), čiji sadržaj neće biti proveravan od strane nginx-a.

Example of vulnerable configuration to steal `/flag` from [here](https://bishopfox.com/blog/h2c-smuggling-request):
```
server {
listen       443 ssl;
server_name  localhost;

ssl_certificate       /usr/local/nginx/conf/cert.pem;
ssl_certificate_key   /usr/local/nginx/conf/privkey.pem;

location / {
proxy_pass http://backend:9999;
proxy_http_version 1.1;
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection $http_connection;
}

location /flag {
deny all;
}
```
> [!WARNING]
> Imajte na umu da čak i ako `proxy_pass` pokazuje na specifičnu **putanju** kao što je `http://backend:9999/socket.io` konekcija će biti uspostavljena sa `http://backend:9999` pa možete **kontaktirati bilo koju drugu putanju unutar tog internog endpointa. Dakle nije važno ako je putanja specificirana u URL-u proxy_pass.**

## Udaljeni DoS i leak modula HTTP/3 QUIC (2024)

Tokom 2024. Nginx je objavio CVE-2024-31079, CVE-2024-32760, CVE-2024-34161 i CVE-2024-35200, pokazujući da **pojedinačna zlonamerna QUIC sesija** može srušiti worker procese ili izazvati leak memorije kad je eksperimentalni `ngx_http_v3_module` kompajliran i kada je izložen `listen ... quic` socket. Pogođene verzije su 1.25.0–1.25.5 i 1.26.0, dok 1.27.0/1.26.1 sadrže ispravke; otkrivanje memorije (CVE-2024-34161) dodatno zahteva MTUs veće od 4096 bajtova da bi se osetljivi podaci pojavili (detalji u 2024 nginx advisory navedenom ispod).

**Recon & exploitation saveti**

- HTTP/3 je opt-in, pa skenirajte za `Alt-Svc: h3=":443"` odgovore ili uradite brute-force UDP/443 QUIC handshakes; po potvrdi, fuzz-ujte handshake i STREAM frames pomoću custom `quiche-client`/`nghttp3` payloads da izazovete worker crashes i naterate log leakage.
- Brzo fingerprint-ujte podršku targeta pomoću:
```bash
nginx -V 2>&1 | grep -i http_v3
rg -n "listen .*quic" /etc/nginx/
```
## Zaobilaženje obnavljanja TLS sesije kod autentifikacije klijentskog sertifikata (CVE-2025-23419)

U februaru 2025. saopštenje je otkrilo da nginx 1.11.4–1.27.3 izgrađen sa OpenSSL omogućava **ponovno korišćenje TLS 1.3 sesije** sa jednog virtualnog hosta zasnovanog na imenu unutar drugog. To znači da klijent koji je pregovarao host bez sertifikata može ponovo iskoristiti tiket/PSK da uđe u vhost zaštićen sa `ssl_verify_client on;` i potpuno zaobiđe mTLS. Bag se aktivira kad god više virtualnih hostova dele isti TLS 1.3 keš sesije i tikete (pogledajte nginx advisory iz 2025. navedeno dole).

**Playbook napadača**
```bash
# 1. Create a TLS session on the public vhost and save the session ticket
openssl s_client -connect public.example.com:443 -sess_out ticket.pem

# 2. Replay that session ticket against the mTLS vhost before it expires
openssl s_client -connect admin.example.com:443 -sess_in ticket.pem -ign_eof
```
Ako je target ranjiv, drugi handshake se završava bez predstavljanja klijentskog sertifikata, otkrivajući zaštićene lokacije.

**Šta treba proveriti**

- Mešoviti `server_name` blokovi koji dele `ssl_session_cache shared:SSL` plus `ssl_session_tickets on;`.
- Admin/API blokovi koji očekuju mTLS ali nasleđuju podešavanja deljenog session cache/ticket-a od javnih hostova.
- Automatizacija koja omogućava TLS 1.3 session resumption globalno (npr. Ansible roles) bez razmatranja izolacije vhost-a.

## HTTP/2 Rapid Reset resilience (CVE-2023-44487 behavior)

The HTTP/2 Rapid Reset attack (CVE-2023-44487) i dalje pogađa nginx kada operatori pojačaju `keepalive_requests` ili `http2_max_concurrent_streams` iznad podrazumevanih vrednosti: napadač otvara jednu HTTP/2 konekciju, preplavi je sa hiljadama streams, a zatim odmah šalje `RST_STREAM` frejmove tako da plafon konkurentnosti nikada nije dostignut dok CPU i dalje troši resurse na logiku za gašenje veza. Nginx defaults (128 concurrent streams, 1000 keepalive requests) drže blast radius mali; podizanje tih ograničenja "substantially higher" čini trivijalnim da se iscrpe workeri čak i od jednog klijenta (see the F5 write-up referenced below).

**Saveti za detekciju**
```bash
# Highlight risky knobs
rg -n "http2_max_concurrent_streams" /etc/nginx/
rg -n "keepalive_requests" /etc/nginx/
```
Hostovi koji otkrivaju neuobičajeno visoke vrednosti za te direktive su glavne mete: jedan HTTP/2 klijent može u petlji praviti tokove (stream creation) i odmah slati `RST_STREAM` frejmove kako bi držao CPU na maksimumu bez aktiviranja ograničenja konkurentnosti.

## Isprobajte sami

Detectify je napravio GitHub repozitorijum gde možete koristiti Docker da podignete sopstveni ranjivi Nginx test server sa nekim od pogrešnih konfiguracija razmatranih u ovom članku i pokušate ih sami pronaći!

[https://github.com/detectify/vulnerable-nginx](https://github.com/detectify/vulnerable-nginx)

## Alati za statičku analizu

### [GixyNG](https://github.com/megamansec/gixyng) & [GIXY](https://github.com/yandex/gixy)

GixyNG (ažurirani fork GIXY) je alat za analizu Nginx konfiguracija, sa ciljem pronalaženja ranjivosti, nesigurnih direktiva i rizičnih pogrešnih konfiguracija. Takođe pronalazi konfiguracione greške koje utiču na performanse i detektuje propuštene mogućnosti za hardening, omogućavajući automatizovano otkrivanje nedostataka.

### [Nginxpwner](https://github.com/stark0de/nginxpwner)

Nginxpwner je jednostavan alat za traženje uobičajenih Nginx pogrešnih konfiguracija i ranjivosti.

## Reference

- [**https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/**](https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/)
- [**http://blog.zorinaq.com/nginx-resolver-vulns/**](http://blog.zorinaq.com/nginx-resolver-vulns/)
- [**https://github.com/yandex/gixy/issues/115**](https://github.com/yandex/gixy/issues/115)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html**](https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html**](https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html)
- [**https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products**](https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products)


{{#include ../../banners/hacktricks-training.md}}
