# Nginx

{{#include ../../banners/hacktricks-training.md}}


## Brak root dla location <a href="#missing-root-location" id="missing-root-location"></a>

Podczas konfigurowania serwera Nginx, **root directive** odgrywa kluczową rolę, definiując katalog bazowy, z którego serwowane są pliki. Rozważ poniższy przykład:
```bash
server {
root /etc/nginx;

location /hello.txt {
try_files $uri $uri/ =404;
proxy_pass http://127.0.0.1:8080/;
}
}
```
W tej konfiguracji `/etc/nginx` jest ustawiony jako katalog root. To ustawienie pozwala na dostęp do plików w określonym katalogu root, takich jak `/hello.txt`. Należy jednak zauważyć, że zdefiniowano tylko konkretną lokalizację (`/hello.txt`). Brakuje konfiguracji dla lokalizacji root (`location / {...}`). Ten brak powoduje, że dyrektywa root obowiązuje globalnie, umożliwiając żądaniom do ścieżki root `/` dostęp do plików pod `/etc/nginx`.

Z taką konfiguracją wiąże się istotne ryzyko bezpieczeństwa. Proste żądanie `GET`, np. `GET /nginx.conf`, może ujawnić wrażliwe informacje, serwując plik konfiguracyjny Nginx znajdujący się pod `/etc/nginx/nginx.conf`. Ustawienie root na mniej wrażliwy katalog, np. `/etc`, może zmniejszyć to ryzyko, lecz nadal może dopuścić do niezamierzonego dostępu do innych krytycznych plików, w tym innych plików konfiguracyjnych, logów dostępu oraz zaszyfrowanych poświadczeń używanych do HTTP basic authentication.

## Alias LFI Misconfiguration <a href="#alias-lfi-misconfiguration" id="alias-lfi-misconfiguration"></a>

W plikach konfiguracyjnych Nginx warto dokładnie sprawdzić dyrektywy "location". Luka znana jako Local File Inclusion (LFI) może zostać nieumyślnie wprowadzona przez konfigurację przypominającą poniższą:
```
location /imgs {
alias /path/images/;
}
```
Ta konfiguracja jest podatna na ataki LFI, ponieważ serwer interpretuje żądania takie jak `/imgs../flag.txt` jako próbę dostępu do plików poza zamierzonym katalogiem, efektywnie rozwiązując je do `/path/images/../flag.txt`. Ta luka pozwala atakującym na pobranie plików z systemu plików serwera, które nie powinny być dostępne przez WWW.

Aby złagodzić tę podatność, konfigurację należy dostosować do:
```
location /imgs/ {
alias /path/images/;
}
```
Więcej informacji: [https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/](https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/)

Testy Accunetix:
```
alias../ => HTTP status code 403
alias.../ => HTTP status code 404
alias../../ => HTTP status code 403
alias../../../../../../../../../../../ => HTTP status code 400
alias../ => HTTP status code 403
```
## Niebezpieczne ograniczenie ścieżki <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

Sprawdź następującą stronę, aby dowiedzieć się, jak obejść dyrektywy takie jak:
```plaintext
location = /admin {
deny all;
}

location = /admin/ {
deny all;
}
```
{{#ref}}
../../pentesting-web/proxy-waf-protections-bypass.md
{{#endref}}

## Niebezpieczne użycie zmiennych / HTTP Request Splitting <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

> [!CAUTION]
> Podatne zmienne to `$uri` i `$document_ur`i — można to naprawić, zastępując je `$request_uri`.
>
> Wyrażenie regularne może być również podatne, na przykład:
>
> `location ~ /docs/([^/])? { … $1 … }` - Podatne
>
> `location ~ /docs/([^/\s])? { … $1 … }` - Niepodatne (sprawdza spacje)
>
> `location ~ /docs/(.*)? { … $1 … }` - Niepodatne

Poniższy przykład demonstruje podatność w konfiguracji Nginx:
```
location / {
return 302 https://example.com$uri;
}
```
Znaki \r (Carriage Return) i \n (Line Feed) oznaczają nowe linie w żądaniach HTTP, a ich formy zakodowane w URL są reprezentowane jako `%0d%0a`. Dołączenie tych znaków do żądania (np. `http://localhost/%0d%0aDetectify:%20clrf`) do źle skonfigurowanego serwera powoduje, że serwer dodaje nowy nagłówek o nazwie `Detectify`. Dzieje się tak, ponieważ zmienna $uri dekoduje zakodowane w URL znaki nowej linii, co prowadzi do nieoczekiwanego nagłówka w odpowiedzi:
```
HTTP/1.1 302 Moved Temporarily
Server: nginx/1.19.3
Content-Type: text/html
Content-Length: 145
Connection: keep-alive
Location: https://example.com/
Detectify: clrf
```
Learn more about the risks of CRLF injection and response splitting at [https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/](https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/).

Also this technique is [**wyjaśnione w tym wystąpieniu**](https://www.youtube.com/watch?v=gWQyWdZbdoY&list=PL0xCSYnG_iTtJe2V6PQqamBF73n7-f1Nr&index=77) z kilkoma przykładami podatności i mechanizmami wykrywania. For example, In order to detect this misconfiguration from a blackbox perspective you could use these requests:

- `https://example.com/%20X` - Dowolny kod HTTP
- `https://example.com/%20H` - 400 Bad Request

If vulnerable, the first will return as "X" is any HTTP method and the second will return an error as H is not a valid method. So the server will receive something like: `GET / H HTTP/1.1` and this will trigger the error.

Another detection examples would be:

- `http://company.tld/%20HTTP/1.1%0D%0AXXXX:%20x` - Dowolny kod HTTP
- `http://company.tld/%20HTTP/1.1%0D%0AHost:%20x` - 400 Bad Request

Some found vulnerable configurations presented in that talk were:

- Zwróć uwagę, że **`$uri`** jest ustawione bez zmian w końcowym URL
```
location ^~ /lite/api/ {
proxy_pass http://lite-backend$uri$is_args$args;
}
```
- Zauważ ponownie, że **`$uri`** znajduje się w URL (tym razem wewnątrz parametru)
```
location ~ ^/dna/payment {
rewrite ^/dna/([^/]+) /registered/main.pl?cmd=unifiedPayment&context=$1&native_uri=$uri break;
proxy_pass http://$back;
```
- Teraz w AWS S3
```
location /s3/ {
proxy_pass https://company-bucket.s3.amazonaws.com$uri;
}
```
### Dowolna zmienna

Stwierdzono, że **dane dostarczone przez użytkownika** mogą być traktowane jako **zmienna Nginx** w pewnych okolicznościach. Przyczyna tego zachowania pozostaje nie do końca jasna, jednak nie jest to zjawisko rzadkie ani proste do zweryfikowania. Ta anomalia została opisana w raporcie bezpieczeństwa na HackerOne, który można zobaczyć [here](https://hackerone.com/reports/370094). Dalsze badanie komunikatu o błędzie doprowadziło do zlokalizowania jej występowania w [moduł filtra SSI w kodzie źródłowym Nginx](https://github.com/nginx/nginx/blob/2187586207e1465d289ae64cedc829719a048a39/src/http/modules/ngx_http_ssi_filter_module.c#L365), wskazując Server Side Includes (SSI) jako główną przyczynę.

Aby **wykryć tę nieprawidłową konfigurację**, można wykonać następujące polecenie, które ustawia nagłówek Referer, aby przetestować wypisywanie zmiennych:
```bash
$ curl -H ‘Referer: bar’ http://localhost/foo$http_referer | grep ‘foobar’
```
Skanowania pod kątem tej nieprawidłowej konfiguracji na różnych systemach ujawniły wiele przypadków, w których zmienne Nginx mogły zostać wypisane przez użytkownika. Jednak zmniejszenie liczby podatnych instancji sugeruje, że działania naprawcze przyniosły częściowy sukces.

### Użycie try_files z zmiennymi $URI$ARGS

Poniższa nieprawidłowa konfiguracja Nginx może prowadzić do podatności LFI:
```
location / {
try_files $uri$args $uri$args/ /index.html;
}
```
W naszej konfiguracji mamy dyrektywę `try_files`, która służy do sprawdzania istnienia plików w określonej kolejności. Nginx serwuje pierwszy znaleziony plik. Podstawowa składnia dyrektywy `try_files` wygląda następująco:
```
try_files file1 file2 ... fileN fallback;
```
Nginx będzie sprawdzał istnienie każdego pliku w określonej kolejności. Jeśli plik istnieje, zostanie on natychmiast zwrócony. Jeśli żaden z określonych plików nie istnieje, żądanie zostanie przekazane do opcji zapasowej (fallback), która może być innym URI lub konkretną stroną błędu.

Jednakże, używając zmiennych `$uri$args` w tej dyrektywie, Nginx będzie próbował znaleźć plik odpowiadający URI żądania połączonemu z dowolnymi parametrami zapytania. W związku z tym możemy wykorzystać tę konfigurację:
```
http {
server {
root /var/www/html/public;

location / {
try_files $uri$args $uri$args/ /index.html;
}
}
}
```
Z następującym payload:
```
GET /?../../../../../../../../etc/passwd HTTP/1.1
Host: example.com
```
Korzystając z naszego payload, opuścimy root directory (zdefiniowany w konfiguracji Nginx) i załadujemy plik `/etc/passwd`. W debug logs możemy zaobserwować, jak Nginx próbuje pliki:
```
...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 trying to use file: "/../../../../../../../../etc/passwd" "/var/www/html/public/../../../../../../../../etc/passwd"
2025/07/11 15:49:16 [debug] 79694#79694: *4 try file uri: "/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 http filename: "/var/www/html/public/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 HTTP/1.1 200 OK

```
PoC przeciw Nginx używając konfiguracji wspomnianej powyżej:
![Example burp request](../../images/nginx_try_files.png)

## Odczyt surowej odpowiedzi backendu

Nginx oferuje funkcję poprzez `proxy_pass`, która pozwala na przechwytywanie błędów i nagłówków HTTP generowanych przez backend, w celu ukrycia wewnętrznych komunikatów o błędach i nagłówków. Odbywa się to poprzez serwowanie przez Nginx niestandardowych stron błędów w odpowiedzi na błędy backendu. Jednakże pojawiają się problemy, gdy Nginx napotka nieprawidłowe żądanie HTTP. Takie żądanie jest przekazywane do backendu w niezmienionej postaci, a surowa odpowiedź backendu jest następnie bezpośrednio wysyłana do klienta bez pośrednictwa Nginx.

Rozważmy przykład z aplikacją uWSGI:
```python
def application(environ, start_response):
start_response('500 Error', [('Content-Type', 'text/html'), ('Secret-Header', 'secret-info')])
return [b"Secret info, should not be visible!"]
```
Aby to zarządzać, w konfiguracji Nginx używa się określonych dyrektyw:
```
http {
error_page 500 /html/error.html;
proxy_intercept_errors on;
proxy_hide_header Secret-Header;
}
```
- [**proxy_intercept_errors**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_intercept_errors): Ta dyrektywa pozwala Nginxowi zwracać niestandardową odpowiedź dla odpowiedzi backendu ze statusem większym niż 300. Zapewnia, że dla naszego przykładowego zastosowania uWSGI odpowiedź `500 Error` jest przechwytywana i obsługiwana przez Nginx.
- [**proxy_hide_header**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_hide_header): Jak sama nazwa wskazuje, dyrektywa ta ukrywa określone nagłówki HTTP przed klientem, zwiększając prywatność i bezpieczeństwo.

Gdy zostanie wykonane poprawne żądanie `GET`, Nginx przetwarza je normalnie, zwracając standardową odpowiedź błędu bez ujawniania żadnych tajnych nagłówków. Jednak nieprawidłowe żądanie HTTP omija ten mechanizm, prowadząc do ujawnienia surowych odpowiedzi backendu, w tym tajnych nagłówków i komunikatów o błędach.

## merge_slashes set to off

Domyślnie dyrektywa **`merge_slashes`** w Nginx jest ustawiona na **`on`**, co kompresuje wiele ukośników w URL do jednego. Ta funkcja, choć upraszcza przetwarzanie URL, może niezamierzenie ukrywać podatności w aplikacjach za Nginx, szczególnie tych podatnych na local file inclusion (LFI). Eksperci bezpieczeństwa **Danny Robinson and Rotem Bar** zwrócili uwagę na potencjalne ryzyko związane z tym domyślnym zachowaniem, zwłaszcza gdy Nginx działa jako reverse-proxy.

Aby złagodzić takie ryzyko, zaleca się **wyłączyć dyrektywę `merge_slashes`** dla aplikacji podatnych na te błędy. Gwarantuje to, że Nginx będzie przekazywać żądania do aplikacji bez modyfikowania struktury URL, nie maskując tym samym żadnych ukrytych problemów bezpieczeństwa.

For more information check [Danny Robinson and Rotem Bar](https://medium.com/appsflyer/nginx-may-be-protecting-your-applications-from-traversal-attacks-without-you-even-knowing-b08f882fd43d).

### **Maclicious Response Headers**

As shown in [**this writeup**](https://mizu.re/post/cors-playground), there are certain headers that if present in the response from the web server they will change the behaviour of the Nginx proxy. You can check them [**in the docs**](https://www.nginx.com/resources/wiki/start/topics/examples/x-accel/):

- `X-Accel-Redirect`: Wskazuje Nginxowi, aby wewnętrznie przekierował żądanie do określonej lokalizacji.
- `X-Accel-Buffering`: Kontroluje, czy Nginx powinien buforować odpowiedź, czy nie.
- `X-Accel-Charset`: Ustawia zestaw znaków dla odpowiedzi przy użyciu X-Accel-Redirect.
- `X-Accel-Expires`: Ustawia czas wygaśnięcia odpowiedzi przy użyciu X-Accel-Redirect.
- `X-Accel-Limit-Rate`: Ogranicza szybkość transferu odpowiedzi przy użyciu X-Accel-Redirect.

For example, the header **`X-Accel-Redirect`** will cause an internal **redirect** in the nginx. So having an nginx configuration with something such as **`root /`** and a response from the web server with **`X-Accel-Redirect: .env`** will make nginx sends the content of **`/.env`** (Path Traversal).

### **Default Value in Map Directive**

In the **Nginx configuration**, the `map` directive often plays a role in **authorization control**. A common mistake is not specifying a **default** value, which could lead to unauthorized access. For instance:
```yaml
http {
map $uri $mappocallow {
/map-poc/private 0;
/map-poc/secret 0;
/map-poc/public 1;
}
}
```

```yaml
server {
location /map-poc {
if ($mappocallow = 0) {return 403;}
return 200 "Hello. It is private area: $mappocallow";
}
}
```
Bez `default`, **złośliwy użytkownik** może obejść zabezpieczenia, uzyskując dostęp do **niezdefiniowanego URI** w obrębie `/map-poc`. [The Nginx manual](https://nginx.org/en/docs/http/ngx_http_map_module.html) zaleca ustawienie **default value**, aby uniknąć takich problemów.

### **DNS Spoofing Vulnerability**

DNS spoofing przeciwko Nginx jest możliwy w określonych warunkach. Jeśli atakujący zna używany przez Nginx **DNS server** i może przechwycić jego zapytania DNS, może sfałszować rekordy DNS. Ta metoda jest jednak nieskuteczna, jeśli Nginx jest skonfigurowany do używania **localhost (127.0.0.1)** do rozwiązywania DNS. Nginx umożliwia określenie **DNS server** w następujący sposób:
```yaml
resolver 8.8.8.8;
```
### **Dyrektywy `proxy_pass` i `internal`**

Dyrektywa **`proxy_pass`** służy do przekierowywania żądań do innych serwerów, zarówno wewnętrznych, jak i zewnętrznych. Dyrektywa **`internal`** zapewnia, że niektóre lokalizacje są dostępne tylko wewnątrz Nginx. Chociaż same te dyrektywy nie są lukami bezpieczeństwa, ich konfiguracja wymaga dokładnej analizy, aby zapobiec naruszeniom bezpieczeństwa.

## proxy_set_header Upgrade & Connection

If the nginx server is configured to pass the Upgrade and Connection headers an [**h2c Smuggling attack**](../../pentesting-web/h2c-smuggling.md) could be performed to access protected/internal endpoints.

> [!CAUTION]
> This vulnerability would allow an attacker to **stablish a direct connection with the `proxy_pass` endpoint** (`http://backend:9999` in this case) that whose content is not going to be checked by nginx.

Example of vulnerable configuration to steal `/flag` from [here](https://bishopfox.com/blog/h2c-smuggling-request):
```
server {
listen       443 ssl;
server_name  localhost;

ssl_certificate       /usr/local/nginx/conf/cert.pem;
ssl_certificate_key   /usr/local/nginx/conf/privkey.pem;

location / {
proxy_pass http://backend:9999;
proxy_http_version 1.1;
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection $http_connection;
}

location /flag {
deny all;
}
```
> [!WARNING]
> Pamiętaj, że nawet jeśli `proxy_pass` wskazywał konkretną **ścieżkę** taką jak `http://backend:9999/socket.io`, połączenie zostanie nawiązane z `http://backend:9999`, więc możesz **odwołać się do dowolnej innej ścieżki wewnątrz tego wewnętrznego endpointu. Zatem nie ma znaczenia, czy w URL `proxy_pass` podano ścieżkę.**

## Zdalny DoS i leak modułu HTTP/3 QUIC (2024)

W 2024 Nginx ujawnił CVE-2024-31079, CVE-2024-32760, CVE-2024-34161 i CVE-2024-35200, pokazując, że **pojedyncza wroga sesja QUIC** może spowodować awarię procesów worker lub leak pamięci, gdy eksperymentalny `ngx_http_v3_module` jest skompilowany i wystawione jest gniazdo `listen ... quic`. Wpływające buildy to 1.25.0–1.25.5 i 1.26.0, podczas gdy 1.27.0/1.26.1 zawierają poprawki; ujawnienie pamięci (CVE-2024-34161) dodatkowo wymaga MTU większych niż 4096 bajtów, aby odsłonić wrażliwe dane (szczegóły w advisoriu nginx z 2024 poniżej).

**Wskazówki rozpoznania i eksploatacji**

- HTTP/3 jest opt-in, więc skanuj pod kątem odpowiedzi `Alt-Svc: h3=":443"` lub brute-force handshake'ów QUIC na UDP/443; po potwierdzeniu fuzzuj handshake i ramki STREAM przy użyciu niestandardowych payloadów `quiche-client`/`nghttp3`, aby wywołać awarie procesów worker i wymusić leak logów.
- Szybko sprawdź obsługę celu za pomocą:
```bash
nginx -V 2>&1 | grep -i http_v3
rg -n "listen .*quic" /etc/nginx/
```
## Omijanie wznowienia sesji TLS w uwierzytelnianiu certyfikatem klienta (CVE-2025-23419)

W komunikacie z lutego 2025 r. ujawniono, że nginx 1.11.4–1.27.3 skompilowany z OpenSSL pozwala na **ponowne użycie sesji TLS 1.3** z jednego name-based virtual host wewnątrz innego, więc klient, który wynegocjował host bez certyfikatu, może odtworzyć ticket/PSK i wskoczyć do vhost chronionego `ssl_verify_client on;`, pomijając całkowicie mTLS. Błąd występuje zawsze, gdy wiele virtual hosts współdzieli ten sam TLS 1.3 session cache i tickets (zob. 2025 nginx advisory wspomniane poniżej).

**Plan atakującego**
```bash
# 1. Create a TLS session on the public vhost and save the session ticket
openssl s_client -connect public.example.com:443 -sess_out ticket.pem

# 2. Replay that session ticket against the mTLS vhost before it expires
openssl s_client -connect admin.example.com:443 -sess_in ticket.pem -ign_eof
```
Jeśli cel jest podatny, drugi handshake kończy się bez przedstawienia certyfikatu klienta, ujawniając chronione lokalizacje.

**Co audytować**

- Mieszane bloki `server_name`, które współdzielą `ssl_session_cache shared:SSL` oraz `ssl_session_tickets on;`.
- Bloki Admin/API, które oczekują mTLS, ale dziedziczą współdzielone ustawienia cache/ticket sesji od publicznych hostów.
- Automatyzacja, która włącza TLS 1.3 session resumption globalnie (np. role Ansible) bez uwzględnienia izolacji vhostów.

## Odporność na HTTP/2 Rapid Reset (zachowanie CVE-2023-44487)

Atak HTTP/2 Rapid Reset (CVE-2023-44487) wciąż wpływa na nginx, gdy operatorzy podnoszą wartości `keepalive_requests` lub `http2_max_concurrent_streams` powyżej domyślnych: atakujący otwiera jedno połączenie HTTP/2, zalewa je tysiącami streamów, a następnie natychmiast wysyła ramki `RST_STREAM`, dzięki czemu sufit równoległości nigdy nie jest osiągnięty, podczas gdy CPU wciąż pracuje nad logiką zamykania. Nginx defaults (128 concurrent streams, 1000 keepalive requests) utrzymują obszar rażenia mały; podniesienie tych limitów "znacząco wyżej" umożliwia łatwe wyczerpanie workerów nawet od pojedynczego klienta (zob. artykuł F5 cytowany poniżej).

**Wskazówki wykrywania**
```bash
# Highlight risky knobs
rg -n "http2_max_concurrent_streams" /etc/nginx/
rg -n "keepalive_requests" /etc/nginx/
```
Hosty ujawniające niezwykle wysokie wartości tych dyrektyw są głównymi celami: jeden klient HTTP/2 może w pętli tworzyć strumienie i natychmiast wysyłać ramki `RST_STREAM`, aby utrzymać CPU na maksymalnym wykorzystaniu bez przekroczenia limitu współbieżności.

## Wypróbuj samodzielnie

Detectify utworzył repozytorium na GitHub, w którym możesz użyć Dockera, aby uruchomić własny podatny serwer testowy Nginx zawierający niektóre z nieprawidłowych konfiguracji omówionych w tym artykule i samodzielnie je znaleźć!

[https://github.com/detectify/vulnerable-nginx](https://github.com/detectify/vulnerable-nginx)

## Narzędzia do analizy statycznej

### [GIXY](https://github.com/yandex/gixy)

Gixy to narzędzie do analizy konfiguracji Nginx. Głównym celem Gixy jest zapobieganie błędnym konfiguracjom bezpieczeństwa i automatyzacja wykrywania usterek.

### [Nginxpwner](https://github.com/stark0de/nginxpwner)

Nginxpwner to proste narzędzie do wyszukiwania typowych nieprawidłowości konfiguracji Nginx i podatności.

## Źródła

- [**https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/**](https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/)
- [**http://blog.zorinaq.com/nginx-resolver-vulns/**](http://blog.zorinaq.com/nginx-resolver-vulns/)
- [**https://github.com/yandex/gixy/issues/115**](https://github.com/yandex/gixy/issues/115)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html**](https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html**](https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html)
- [**https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products**](https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products)


{{#include ../../banners/hacktricks-training.md}}
