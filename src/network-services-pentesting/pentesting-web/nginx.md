# Nginx

{{#include ../../banners/hacktricks-training.md}}

<figure><img src="/images/pentest-tools.svg" alt=""><figcaption></figcaption></figure>

**Pata mtazamo wa hacker kuhusu programu zako za wavuti, mtandao, na wingu**

**Pata na ripoti kuhusu udhaifu muhimu, unaoweza kutumiwa kwa faida halisi ya biashara.** Tumia zana zetu zaidi ya 20 za kawaida kupanga uso wa shambulio, pata masuala ya usalama yanayokuruhusu kupandisha mamlaka, na tumia matumizi ya kiotomatiki kukusanya ushahidi muhimu, ukigeuza kazi yako ngumu kuwa ripoti za kushawishi.

{% embed url="https://pentest-tools.com/?utm_term=jul2024&utm_medium=link&utm_source=hacktricks&utm_campaign=spons" %}

## Missing root location <a href="#missing-root-location" id="missing-root-location"></a>

Wakati wa kuunda seva ya Nginx, **root directive** ina jukumu muhimu kwa kufafanua saraka ya msingi kutoka ambayo faili zinatolewa. Fikiria mfano ulio hapa chini:
```bash
server {
root /etc/nginx;

location /hello.txt {
try_files $uri $uri/ =404;
proxy_pass http://127.0.0.1:8080/;
}
}
```
Katika usanidi huu, `/etc/nginx` imewekwa kama saraka ya mzizi. Mipangilio hii inaruhusu ufikiaji wa faili ndani ya saraka iliyoainishwa, kama vile `/hello.txt`. Hata hivyo, ni muhimu kutambua kwamba eneo maalum tu (`/hello.txt`) limeainishwa. Hakuna usanidi wa eneo la mzizi (`location / {...}`). Kukosekana kwa hili kunamaanisha kwamba mwelekeo wa mzizi unatumika kwa ujumla, ukiruhusu maombi kwenye njia ya mzizi `/` kufikia faili chini ya `/etc/nginx`.

Kipengele muhimu cha usalama kinatokea kutokana na usanidi huu. Ombi rahisi la `GET`, kama `GET /nginx.conf`, linaweza kufichua taarifa nyeti kwa kutoa faili ya usanidi wa Nginx iliyoko kwenye `/etc/nginx/nginx.conf`. Kuweka mzizi kwenye saraka isiyo nyeti sana, kama `/etc`, kunaweza kupunguza hatari hii, lakini bado kunaweza kuruhusu ufikiaji usio kusudiwa wa faili nyingine muhimu, ikiwa ni pamoja na faili zingine za usanidi, kumbukumbu za ufikiaji, na hata akidi zilizofichwa zinazotumika kwa uthibitishaji wa msingi wa HTTP.

## Alias LFI Misconfiguration <a href="#alias-lfi-misconfiguration" id="alias-lfi-misconfiguration"></a>

Katika faili za usanidi za Nginx, ukaguzi wa karibu unahitajika kwa mwelekeo wa "location". Uthibitisho wa udhaifu unaojulikana kama Local File Inclusion (LFI) unaweza kuanzishwa bila kukusudia kupitia usanidi unaofanana na ifuatayo:
```
location /imgs {
alias /path/images/;
}
```
Hii usanidi ina hatari ya mashambulizi ya LFI kwa sababu seva inatafsiri maombi kama `/imgs../flag.txt` kama jaribio la kufikia faili nje ya saraka iliyokusudiwa, ikitafsiriwa kwa ufanisi kama `/path/images/../flag.txt`. Kasoro hii inaruhusu washambuliaji kupata faili kutoka kwenye mfumo wa faili wa seva ambao haupaswi kupatikana kupitia wavuti.

Ili kupunguza udhaifu huu, usanidi unapaswa kubadilishwa kuwa:
```
location /imgs/ {
alias /path/images/;
}
```
Zaidi ya habari: [https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/](https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/)

Majaribio ya Accunetix:
```
alias../ => HTTP status code 403
alias.../ => HTTP status code 404
alias../../ => HTTP status code 403
alias../../../../../../../../../../../ => HTTP status code 400
alias../ => HTTP status code 403
```
## Mipango isiyo salama ya njia <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

Angalia ukurasa ufuatao kujifunza jinsi ya kupita maagizo kama:
```plaintext
location = /admin {
deny all;
}

location = /admin/ {
deny all;
}
```
{{#ref}}
../../pentesting-web/proxy-waf-protections-bypass.md
{{#endref}}

## Matumizi yasiyo salama ya mabadiliko / Kugawanya Maombi ya HTTP <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

> [!CAUTION]
> Mabadiliko yenye hatari `$uri` na `$document_uri` na hii inaweza kurekebishwa kwa kuyabadilisha na `$request_uri`.
>
> Regex inaweza pia kuwa na hatari kama:
>
> `location ~ /docs/([^/])? { … $1 … }` - Ina hatari&#x20;
>
> `location ~ /docs/([^/\s])? { … $1 … }` - Haina hatari (ikikagua nafasi)
>
> `location ~ /docs/(.*)? { … $1 … }` - Haina hatari

Uthibitisho wa udhaifu katika usanidi wa Nginx unadhihirishwa na mfano hapa chini:
```
location / {
return 302 https://example.com$uri;
}
```
Characters \r (Carriage Return) na \n (Line Feed) zinaashiria wahusika wapya katika maombi ya HTTP, na aina zao za URL-encoded zinawakilishwa kama `%0d%0a`. Kuongeza wahusika hawa katika ombi (kwa mfano, `http://localhost/%0d%0aDetectify:%20clrf`) kwa seva isiyo na usanidi mzuri kunasababisha seva kutoa kichwa kipya kinachoitwa `Detectify`. Hii inatokea kwa sababu ya $uri variable inayodecode wahusika wapya wa URL-encoded, na kusababisha kichwa kisichotarajiwa katika jibu:
```
HTTP/1.1 302 Moved Temporarily
Server: nginx/1.19.3
Content-Type: text/html
Content-Length: 145
Connection: keep-alive
Location: https://example.com/
Detectify: clrf
```
Jifunze zaidi kuhusu hatari za CRLF injection na response splitting katika [https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/](https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/).

Pia, mbinu hii [**imeelezwa katika mazungumzo haya**](https://www.youtube.com/watch?v=gWQyWdZbdoY&list=PL0xCSYnG_iTtJe2V6PQqamBF73n7-f1Nr&index=77) ikiwa na mifano yenye udhaifu na mitambo ya kugundua. Kwa mfano, ili kugundua usakinishaji huu usio sahihi kutoka kwa mtazamo wa blackbox unaweza kutumia maombi haya:

- `https://example.com/%20X` - Kila nambari ya HTTP
- `https://example.com/%20H` - 400 Bad Request

Ikiwa kuna udhaifu, ya kwanza itarudisha kama "X" ni mbinu yoyote ya HTTP na ya pili itarudisha kosa kwani H si mbinu halali. Hivyo, seva itapokea kitu kama: `GET / H HTTP/1.1` na hii itasababisha kosa.

Mifano mingine ya kugundua itakuwa:

- `http://company.tld/%20HTTP/1.1%0D%0AXXXX:%20x` - Kila nambari ya HTTP
- `http://company.tld/%20HTTP/1.1%0D%0AHost:%20x` - 400 Bad Request

Baadhi ya usanidi wenye udhaifu ulioonekana katika mazungumzo hayo ulikuwa:

- Angalia jinsi **`$uri`** ilivyowekwa kama ilivyo katika URL ya mwisho.
```
location ^~ /lite/api/ {
proxy_pass http://lite-backend$uri$is_args$args;
}
```
- Kumbuka jinsi tena **`$uri`** iko katika URL (wakati huu ndani ya parameter)
```
location ~ ^/dna/payment {
rewrite ^/dna/([^/]+) /registered/main.pl?cmd=unifiedPayment&context=$1&native_uri=$uri break;
proxy_pass http://$back;
```
- Sasa katika AWS S3
```
location /s3/ {
proxy_pass https://company-bucket.s3.amazonaws.com$uri;
}
```
### Any variable

Iligundulika kwamba **data inayotolewa na mtumiaji** inaweza kut treated kama **Nginx variable** chini ya hali fulani. Sababu ya tabia hii bado haijulikani vizuri, lakini si nadra wala rahisi kuthibitisha. Anomali hii ilisisitizwa katika ripoti ya usalama kwenye HackerOne, ambayo inaweza kuonekana [here](https://hackerone.com/reports/370094). Uchunguzi zaidi wa ujumbe wa kosa ulisababisha kubaini kutokea kwake ndani ya [SSI filter module of Nginx's codebase](https://github.com/nginx/nginx/blob/2187586207e1465d289ae64cedc829719a048a39/src/http/modules/ngx_http_ssi_filter_module.c#L365), ikitaja Server Side Includes (SSI) kama sababu kuu.

Ili **gundua hii misconfiguration**, amri ifuatayo inaweza kutekelezwa, ambayo inahusisha kuweka kichwa cha referer ili kujaribu kuchapisha variable:
```bash
$ curl -H ‘Referer: bar’ http://localhost/foo$http_referer | grep ‘foobar’
```
Skana za usanidi huu mbaya katika mifumo zilionyesha matukio kadhaa ambapo mabadiliko ya Nginx yanaweza kuchapishwa na mtumiaji. Hata hivyo, kupungua kwa idadi ya matukio yaliyo hatarini kunaonyesha kwamba juhudi za kurekebisha tatizo hili zimefanikiwa kwa kiasi fulani.

## Kusoma majibu ya nyuma ya raw

Nginx inatoa kipengele kupitia `proxy_pass` ambacho kinaruhusu kukamatwa kwa makosa na vichwa vya HTTP vinavyotolewa na nyuma, kwa lengo la kuficha ujumbe wa makosa ya ndani na vichwa. Hii inafanywa kwa Nginx kutoa kurasa za makosa za kawaida kama majibu kwa makosa ya nyuma. Hata hivyo, changamoto zinatokea wakati Nginx inakutana na ombi la HTTP lisilo sahihi. Ombi kama hilo linapelekwa kwa nyuma kama lilivyo, na majibu ya raw ya nyuma yanatumwa moja kwa moja kwa mteja bila kuingilia kati kwa Nginx.

Fikiria mfano wa hali inayohusisha programu ya uWSGI:
```python
def application(environ, start_response):
start_response('500 Error', [('Content-Type', 'text/html'), ('Secret-Header', 'secret-info')])
return [b"Secret info, should not be visible!"]
```
Ili kudhibiti hili, maagizo maalum katika usanidi wa Nginx yanatumika:
```
http {
error_page 500 /html/error.html;
proxy_intercept_errors on;
proxy_hide_header Secret-Header;
}
```
- [**proxy_intercept_errors**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_intercept_errors): Hii amri inaruhusu Nginx kutoa jibu maalum kwa majibu ya nyuma yenye msimbo wa hali zaidi ya 300. Inahakikisha kwamba, kwa mfano wetu wa programu ya uWSGI, jibu la `500 Error` linakamatwa na kushughulikiwa na Nginx.
- [**proxy_hide_header**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_hide_header): Kama jina linavyopendekeza, hii amri inaficha vichwa vya HTTP vilivyotajwa kutoka kwa mteja, ikiongeza faragha na usalama.

Wakati ombi halali la `GET` linapotolewa, Nginx linafanya kazi yake kawaida, likirejesha jibu la makosa la kawaida bila kufichua vichwa vyovyote vya siri. Hata hivyo, ombi la HTTP lisilo halali linakwepa mekanism hii, na kusababisha kufichuliwa kwa majibu ya nyuma ya asili, ikiwa ni pamoja na vichwa vya siri na ujumbe wa makosa.

## merge_slashes set to off

Kwa kawaida, amri ya **`merge_slashes`** ya Nginx imewekwa kuwa **`on`**, ambayo inakusanya slashi nyingi za mbele katika URL kuwa slashi moja. Kipengele hiki, ingawa kinaboresha usindikaji wa URL, kinaweza kwa bahati mbaya kuficha udhaifu katika programu zilizo nyuma ya Nginx, hasa zile zinazoweza kukabiliwa na mashambulizi ya kuingiza faili za ndani (LFI). Wataalamu wa usalama **Danny Robinson na Rotem Bar** wameonyesha hatari zinazoweza kutokea zinazohusiana na tabia hii ya kawaida, hasa wakati Nginx inafanya kazi kama reverse-proxy.

Ili kupunguza hatari kama hizo, inapendekezwa **kugeuza amri ya `merge_slashes` kuwa off** kwa programu zinazoweza kukabiliwa na udhaifu hizi. Hii inahakikisha kwamba Nginx inapeleka maombi kwa programu bila kubadilisha muundo wa URL, hivyo basi haina kuficha matatizo yoyote ya usalama yaliyofichika.

Kwa maelezo zaidi angalia [Danny Robinson na Rotem Bar](https://medium.com/appsflyer/nginx-may-be-protecting-your-applications-from-traversal-attacks-without-you-even-knowing-b08f882fd43d).

### **Maclicious Response Headers**

Kama inavyoonyeshwa katika [**hii andiko**](https://mizu.re/post/cors-playground), kuna vichwa fulani ambavyo ikiwa vipo katika jibu kutoka kwa seva ya wavuti vitabadilisha tabia ya proxy ya Nginx. Unaweza kuangalia katika [**nyaraka**](https://www.nginx.com/resources/wiki/start/topics/examples/x-accel/):

- `X-Accel-Redirect`: Inaonyesha Nginx kuhamasisha ombi kwa eneo lililotajwa.
- `X-Accel-Buffering`: Inadhibiti ikiwa Nginx inapaswa kubuffer jibu au la.
- `X-Accel-Charset`: Inaweka seti ya wahusika kwa jibu wakati wa kutumia X-Accel-Redirect.
- `X-Accel-Expires`: Inaweka muda wa kumalizika kwa jibu wakati wa kutumia X-Accel-Redirect.
- `X-Accel-Limit-Rate`: Inapunguza kiwango cha uhamishaji kwa majibu wakati wa kutumia X-Accel-Redirect.

Kwa mfano, kichwa **`X-Accel-Redirect`** kitasababisha **redirect** ya ndani katika nginx. Hivyo kuwa na usanidi wa nginx na kitu kama **`root /`** na jibu kutoka kwa seva ya wavuti lenye **`X-Accel-Redirect: .env`** kutafanya nginx itume maudhui ya **`/.env`** (Path Traversal).

### **Default Value in Map Directive**

Katika **usanidi wa Nginx**, amri ya `map` mara nyingi ina jukumu katika **udhibiti wa idhini**. Kosa la kawaida ni kutoshughulikia **thamani ya default**, ambayo inaweza kusababisha ufikiaji usioidhinishwa. Kwa mfano:
```yaml
http {
map $uri $mappocallow {
/map-poc/private 0;
/map-poc/secret 0;
/map-poc/public 1;
}
}
```

```yaml
server {
location /map-poc {
if ($mappocallow = 0) {return 403;}
return 200 "Hello. It is private area: $mappocallow";
}
}
```
Bila `default`, **mtumiaji mbaya** anaweza kupita usalama kwa kufikia **URI isiyofafanuliwa** ndani ya `/map-poc`. [Mwongozo wa Nginx](https://nginx.org/en/docs/http/ngx_http_map_module.html) unashauri kuweka **thamani ya default** ili kuepuka matatizo kama haya.

### **Udhaifu wa DNS Spoofing**

DNS spoofing dhidi ya Nginx inawezekana chini ya hali fulani. Ikiwa mshambuliaji anajua **seva ya DNS** inayotumika na Nginx na anaweza kukamata maswali yake ya DNS, wanaweza kuficha rekodi za DNS. Hata hivyo, njia hii haiwezi kufanya kazi ikiwa Nginx imewekwa kutumia **localhost (127.0.0.1)** kwa ajili ya ufumbuzi wa DNS. Nginx inaruhusu kuweka seva ya DNS kama ifuatavyo:
```yaml
resolver 8.8.8.8;
```
### **`proxy_pass` na `internal` Miongozo**

Miongozo ya **`proxy_pass`** inatumika kwa ajili ya kuelekeza maombi kwa seva nyingine, ama ndani au nje. Miongozo ya **`internal`** inahakikisha kwamba maeneo fulani yanapatikana tu ndani ya Nginx. Ingawa miongozo hii si udhaifu kwa wenyewe, usanidi wao unahitaji uchunguzi wa makini ili kuzuia mapungufu ya usalama.

## proxy_set_header Upgrade & Connection

Ikiwa seva ya nginx imewekwa ili kupitisha vichwa vya Upgrade na Connection, [**shambulio la h2c Smuggling**](../../pentesting-web/h2c-smuggling.md) linaweza kufanywa ili kufikia mwisho wa ndani uliohifadhiwa.

> [!CAUTION]
> Udhaifu huu utamruhusu mshambuliaji **kuanzisha muunganisho wa moja kwa moja na mwisho wa `proxy_pass`** (`http://backend:9999` katika kesi hii) ambao maudhui yake hayataangaliwa na nginx.

Mfano wa usanidi ulio hatarini kuiba `/flag` kutoka [hapa](https://bishopfox.com/blog/h2c-smuggling-request):
```
server {
listen       443 ssl;
server_name  localhost;

ssl_certificate       /usr/local/nginx/conf/cert.pem;
ssl_certificate_key   /usr/local/nginx/conf/privkey.pem;

location / {
proxy_pass http://backend:9999;
proxy_http_version 1.1;
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection $http_connection;
}

location /flag {
deny all;
}
```
> [!WARNING]
> Kumbuka kwamba hata kama `proxy_pass` ilikuwa ikielekeza kwenye **path** maalum kama `http://backend:9999/socket.io`, muunganisho utaanzishwa na `http://backend:9999` hivyo unaweza **kuwasiliana na path nyingine yoyote ndani ya mwisho huo wa ndani. Hivyo haijalishi kama path imeainishwa katika URL ya proxy_pass.**

## Jaribu mwenyewe

Detectify imeunda hazina ya GitHub ambapo unaweza kutumia Docker kuanzisha seva yako ya majaribio ya Nginx yenye udhaifu kadhaa zilizozungumziwa katika makala hii na jaribu kuzipata mwenyewe!

[https://github.com/detectify/vulnerable-nginx](https://github.com/detectify/vulnerable-nginx)

## Zana za Mchambuzi wa Kihistoria

### [GIXY](https://github.com/yandex/gixy)

Gixy ni zana ya kuchambua usanidi wa Nginx. Lengo kuu la Gixy ni kuzuia makosa ya usalama na kuharakisha kugundua kasoro.

### [Nginxpwner](https://github.com/stark0de/nginxpwner)

Nginxpwner ni zana rahisi ya kutafuta makosa ya kawaida ya Nginx na udhaifu.

## Marejeleo

- [**https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/**](https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/)
- [**http://blog.zorinaq.com/nginx-resolver-vulns/**](http://blog.zorinaq.com/nginx-resolver-vulns/)
- [**https://github.com/yandex/gixy/issues/115**](https://github.com/yandex/gixy/issues/115)

<figure><img src="/images/pentest-tools.svg" alt=""><figcaption></figcaption></figure>

**Pata mtazamo wa hacker kuhusu programu zako za wavuti, mtandao, na wingu**

**Pata na ripoti udhaifu muhimu, unaoweza kutumiwa kwa faida halisi ya biashara.** Tumia zana zetu 20+ za kawaida kupanga uso wa shambulio, pata masuala ya usalama yanayokuruhusu kupandisha mamlaka, na tumia mashambulizi ya kiotomatiki kukusanya ushahidi muhimu, ukigeuza kazi yako ngumu kuwa ripoti za kushawishi.

{% embed url="https://pentest-tools.com/?utm_term=jul2024&utm_medium=link&utm_source=hacktricks&utm_campaign=spons" %}

{{#include ../../banners/hacktricks-training.md}}
