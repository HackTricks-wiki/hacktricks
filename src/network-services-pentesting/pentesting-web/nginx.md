# Nginx

{{#include ../../banners/hacktricks-training.md}}


## 루트 위치 누락 <a href="#missing-root-location" id="missing-root-location"></a>

Nginx 서버를 구성할 때, **root directive**는 파일이 제공되는 기본 디렉터리를 정의하므로 중요한 역할을 합니다. 아래 예시를 보십시오:
```bash
server {
root /etc/nginx;

location /hello.txt {
try_files $uri $uri/ =404;
proxy_pass http://127.0.0.1:8080/;
}
}
```
In this configuration, `/etc/nginx` is designated as the root directory. This setup allows access to files within the specified root directory, such as `/hello.txt`. However, it's crucial to note that only a specific location (`/hello.txt`) is defined. There's no configuration for the root location (`location / {...}`). This omission means that the root directive applies globally, enabling requests to the root path `/` to access files under `/etc/nginx`.

이 구성에서는 `/etc/nginx`가 root 디렉터리로 지정되어 있습니다. 이 설정은 `/hello.txt`와 같이 지정된 root 디렉터리 내의 파일들에 접근할 수 있게 합니다. 다만, 오직 특정 location(`/hello.txt`)만 정의되어 있다는 점을 유의해야 합니다. `location / {...}`에 대한 설정이 없기 때문에 root 지시자는 전역적으로 적용되어 루트 경로 `/`에 대한 요청이 `/etc/nginx` 아래의 파일에 접근할 수 있게 됩니다.

A critical security consideration arises from this configuration. A simple `GET` request, like `GET /nginx.conf`, could expose sensitive information by serving the Nginx configuration file located at `/etc/nginx/nginx.conf`. Setting the root to a less sensitive directory, like `/etc`, could mitigate this risk, yet it still may allow unintended access to other critical files, including other configuration files, access logs, and even encrypted credentials used for HTTP basic authentication.

이 구성에서는 중요한 보안 문제가 발생합니다. 예를 들어 `GET /nginx.conf`와 같은 간단한 `GET` 요청은 `/etc/nginx/nginx.conf`에 위치한 Nginx 설정 파일을 제공하여 민감한 정보를 노출시킬 수 있습니다. root를 `/etc`와 같이 덜 민감한 디렉터리로 설정하면 이 위험을 완화할 수 있지만, 여전히 다른 설정 파일, 액세스 로그, 그리고 HTTP basic authentication에 사용되는 암호화된 자격 증명 등 다른 중요한 파일들에 의도치 않은 접근을 허용할 수 있습니다.

## Alias LFI Misconfiguration <a href="#alias-lfi-misconfiguration" id="alias-lfi-misconfiguration"></a>

In the configuration files of Nginx, a close inspection is warranted for the "location" directives. A vulnerability known as Local File Inclusion (LFI) can be inadvertently introduced through a configuration that resembles the following:
```
location /imgs {
alias /path/images/;
}
```
이 구성은 서버가 `/imgs../flag.txt` 같은 요청을 의도된 디렉토리 밖의 파일에 접근하려는 시도로 해석하여 실제로 `/path/images/../flag.txt`로 해결되기 때문에 LFI 공격에 취약합니다. 이 결함으로 공격자는 웹을 통해 접근해서는 안 되는 서버의 파일 시스템에 있는 파일을 가져올 수 있습니다.

이 취약점을 완화하려면 구성은 다음과 같이 조정해야 합니다:
```
location /imgs/ {
alias /path/images/;
}
```
추가 정보: [https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/](https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/)

Accunetix 테스트:
```
alias../ => HTTP status code 403
alias.../ => HTTP status code 404
alias../../ => HTTP status code 403
alias../../../../../../../../../../../ => HTTP status code 400
alias../ => HTTP status code 403
```
## Unsafe path restriction <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

다음 페이지를 확인하여 다음과 같은 directives를 bypass하는 방법을 알아보세요:
```plaintext
location = /admin {
deny all;
}

location = /admin/ {
deny all;
}
```
{{#ref}}
../../pentesting-web/proxy-waf-protections-bypass.md
{{#endref}}

## 불안전한 변수 사용 / HTTP Request Splitting <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

> [!CAUTION]
> 취약한 변수 `$uri` 및 `$document_ur`i이며, 이는 `$request_uri`로 교체하여 수정할 수 있습니다.
>
> 정규식도 다음과 같이 취약할 수 있습니다:
>
> `location ~ /docs/([^/])? { … $1 … }` - 취약
>
> `location ~ /docs/([^/\s])? { … $1 … }` - 취약하지 않음 (공백 검사)
>
> `location ~ /docs/(.*)? { … $1 … }` - 취약하지 않음

Nginx 구성의 취약점은 아래 예제로 설명됩니다:
```
location / {
return 302 https://example.com$uri;
}
```
문자 `\r` (Carriage Return)와 `\n` (Line Feed)는 HTTP 요청에서 줄 바꿈 문자를 의미하며, 이들의 URL 인코딩된 형태는 `%0d%0a`로 표현됩니다. 요청에 이 문자를 포함하면(예: `http://localhost/%0d%0aDetectify:%20clrf`) 잘못 구성된 서버는 `Detectify`라는 새 헤더를 발행합니다. 이는 `$uri` 변수가 URL 인코딩된 줄 바꿈 문자를 디코딩하기 때문에 발생하며, 그 결과 응답에 예기치 않은 헤더가 추가됩니다:
```
HTTP/1.1 302 Moved Temporarily
Server: nginx/1.19.3
Content-Type: text/html
Content-Length: 145
Connection: keep-alive
Location: https://example.com/
Detectify: clrf
```
CRLF injection과 response splitting의 위험에 대해서는 다음을 참고하세요: [https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/](https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/).

또한 이 기법은 [**explained in this talk**](https://www.youtube.com/watch?v=gWQyWdZbdoY&list=PL0xCSYnG_iTtJe2V6PQqamBF73n7-f1Nr&index=77)에서 일부 취약한 예제와 탐지 메커니즘과 함께 설명되어 있습니다. 예를 들어, 블랙박스 관점에서 이 잘못된 구성을 탐지하려면 다음 요청들을 보낼 수 있습니다:

- `https://example.com/%20X` - 임의의 HTTP 코드
- `https://example.com/%20H` - 400 Bad Request

취약하다면, 첫 번째 요청은 "X"가 어떤 HTTP method여도 응답을 반환하고 두 번째 요청은 "H"가 유효한 method가 아니므로 에러를 반환합니다. 따라서 서버는 다음과 같은 요청을 받게 됩니다: `GET / H HTTP/1.1` — 이로 인해 에러가 발생합니다.

또 다른 탐지 예시는 다음과 같습니다:

- `http://company.tld/%20HTTP/1.1%0D%0AXXXX:%20x` - 임의의 HTTP 코드
- `http://company.tld/%20HTTP/1.1%0D%0AHost:%20x` - 400 Bad Request

그 토크에서 제시된 몇 가지 취약한 구성은 다음과 같습니다:

- 최종 URL에 **`$uri`**가 있는 그대로 설정되어 있는 점에 주목하세요
```
location ^~ /lite/api/ {
proxy_pass http://lite-backend$uri$is_args$args;
}
```
- 다시 한 번 **`$uri`**가 URL에 있는 것을 주목하세요(이번에는 파라미터 안에 있습니다)
```
location ~ ^/dna/payment {
rewrite ^/dna/([^/]+) /registered/main.pl?cmd=unifiedPayment&context=$1&native_uri=$uri break;
proxy_pass http://$back;
```
- 이제 AWS S3에서
```
location /s3/ {
proxy_pass https://company-bucket.s3.amazonaws.com$uri;
}
```
### 임의의 변수

특정 상황에서 **사용자 제공 데이터**가 **Nginx 변수**로 처리될 수 있음이 발견되었습니다. 이 동작의 원인은 다소 불명확하지만, 드문 현상도 아니고 검증도 간단하지 않습니다. 이 이상 현상은 HackerOne의 보안 리포트에서 지적되었으며, [here](https://hackerone.com/reports/370094)에서 확인할 수 있습니다. 오류 메시지를 추가 조사한 결과, 해당 문제가 Nginx의 코드베이스 내 [SSI filter module of Nginx's codebase](https://github.com/nginx/nginx/blob/2187586207e1465d289ae64cedc829719a048a39/src/http/modules/ngx_http_ssi_filter_module.c#L365)에서 발생함을 확인했고, 그 원인이 Server Side Includes (SSI)로 좁혀졌습니다.

To **detect this misconfiguration**, 다음 명령을 실행하여 referer header를 설정해 변수 출력 여부를 테스트할 수 있습니다:
```bash
$ curl -H ‘Referer: bar’ http://localhost/foo$http_referer | grep ‘foobar’
```
시스템 전반에서 이 잘못된 구성에 대한 스캔은 사용자가 Nginx 변수를 출력할 수 있는 여러 사례를 발견했다. 그러나 취약한 인스턴스 수가 감소한 것은 이 문제를 패치하려는 노력이 어느 정도 성공했음을 시사한다.

### try_files를 $URI$ARGS 변수와 함께 사용하기

다음 Nginx 잘못된 구성은 LFI 취약성으로 이어질 수 있다:
```
location / {
try_files $uri$args $uri$args/ /index.html;
}
```
구성에서 `try_files` 지시어는 지정된 순서로 파일의 존재 여부를 확인하는 데 사용됩니다. Nginx는 찾은 첫 번째 파일을 제공합니다. `try_files` 지시어의 기본 문법은 다음과 같습니다:
```
try_files file1 file2 ... fileN fallback;
```
Nginx는 지정된 순서대로 각 파일의 존재 여부를 확인합니다. 파일이 존재하면 즉시 제공됩니다. 지정된 파일이 하나도 존재하지 않으면 요청은 다른 URI나 특정 오류 페이지가 될 수 있는 대체 옵션으로 전달됩니다.

하지만 이 지시문에서 `$uri$args` 변수를 사용할 경우, Nginx는 요청 URI에 쿼리 문자열 인자를 결합한 것과 일치하는 파일을 찾으려고 시도합니다. 따라서 이 구성을 악용할 수 있습니다:
```
http {
server {
root /var/www/html/public;

location / {
try_files $uri$args $uri$args/ /index.html;
}
}
}
```
다음 payload로:
```
GET /?../../../../../../../../etc/passwd HTTP/1.1
Host: example.com
```
우리의 payload를 사용하여 (Nginx 설정에 정의된) 루트 디렉토리에서 벗어나 `/etc/passwd` 파일을 로드합니다. debug logs에서 Nginx가 파일들을 시도하는 방식을 관찰할 수 있습니다:
```
...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 trying to use file: "/../../../../../../../../etc/passwd" "/var/www/html/public/../../../../../../../../etc/passwd"
2025/07/11 15:49:16 [debug] 79694#79694: *4 try file uri: "/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 http filename: "/var/www/html/public/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 HTTP/1.1 200 OK

```
PoC againts Nginx using the configuration mentioned above:
![예시 burp 요청](../../images/nginx_try_files.png)

## 원시 백엔드 응답 읽기

Nginx는 `proxy_pass`를 통해 백엔드에서 발생하는 오류와 HTTP 헤더를 가로채 내부 오류 메시지와 헤더를 숨길 수 있는 기능을 제공합니다. 이는 Nginx가 백엔드 오류에 대해 커스텀 에러 페이지를 제공함으로써 이루어집니다. 그러나 Nginx가 유효하지 않은 HTTP 요청을 만나면 문제가 발생합니다. 그런 요청은 받은 그대로 백엔드로 전달되고, 백엔드의 원시 응답이 Nginx의 개입 없이 직접 클라이언트로 전송됩니다.

uWSGI 애플리케이션을 포함한 예시 시나리오를 고려해보면:
```python
def application(environ, start_response):
start_response('500 Error', [('Content-Type', 'text/html'), ('Secret-Header', 'secret-info')])
return [b"Secret info, should not be visible!"]
```
이를 관리하기 위해 Nginx 구성에서 특정 지시문들이 사용됩니다:
```
http {
error_page 500 /html/error.html;
proxy_intercept_errors on;
proxy_hide_header Secret-Header;
}
```
- [**proxy_intercept_errors**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_intercept_errors): 이 디렉티브는 상태 코드가 300보다 큰 백엔드 응답에 대해 Nginx가 커스텀 응답을 제공하도록 합니다. 예제 uWSGI 애플리케이션의 경우 `500 Error` 응답이 가로채져 Nginx에 의해 처리되도록 보장합니다.
- [**proxy_hide_header**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_hide_header): 이름 그대로 이 디렉티브는 지정된 HTTP 헤더를 클라이언트로부터 숨겨 프라이버시와 보안을 향상시킵니다.

유효한 `GET` 요청이 들어오면 Nginx는 이를 정상적으로 처리하여 비밀 헤더를 노출하지 않는 표준 오류 응답을 반환합니다. 그러나 잘못된 HTTP 요청은 이 메커니즘을 우회하여 비밀 헤더와 오류 메시지를 포함한 백엔드의 원시 응답이 노출되게 합니다.

## merge_slashes set to off

기본적으로 Nginx의 **`merge_slashes` directive**는 **`on`**으로 설정되어 있어 URL 내 연속된 슬래시를 하나의 슬래시로 압축합니다. 이 기능은 URL 처리를 단순화하지만, 특히 Nginx가 리버스 프록시로 동작할 때 애플리케이션의 취약점을 은닉할 수 있어 의도치 않은 위험을 초래할 수 있습니다. 보안 전문가인 **Danny Robinson and Rotem Bar**는 이 기본 동작과 관련된 잠재적 위험을 지적했습니다.

이러한 위험을 완화하기 위해, LFI 등에 취약한 애플리케이션에서는 **`merge_slashes` directive를 off로 설정하는 것이 권장**됩니다. 이렇게 하면 Nginx가 URL 구조를 변경하지 않고 애플리케이션으로 요청을 전달하여 잠재적인 보안 문제를 가리지 않습니다.

자세한 내용은 [Danny Robinson and Rotem Bar](https://medium.com/appsflyer/nginx-may-be-protecting-your-applications-from-traversal-attacks-without-you-even-knowing-b08f882fd43d)를 확인하세요.

### **Maclicious Response Headers**

[**this writeup**](https://mizu.re/post/cors-playground)에 표시된 바와 같이, 웹 서버의 응답에 특정 헤더가 포함되어 있으면 Nginx 프록시의 동작이 변경됩니다. 해당 헤더들은 [**in the docs**](https://www.nginx.com/resources/wiki/start/topics/examples/x-accel/)에서 확인할 수 있습니다:

- `X-Accel-Redirect`: Nginx에게 요청을 지정된 위치로 내부 리디렉션하도록 지시합니다.
- `X-Accel-Buffering`: Nginx가 응답을 버퍼링할지 여부를 제어합니다.
- `X-Accel-Charset`: X-Accel-Redirect를 사용할 때 응답의 문자 집합을 설정합니다.
- `X-Accel-Expires`: X-Accel-Redirect를 사용할 때 응답의 만료 시간을 설정합니다.
- `X-Accel-Limit-Rate`: X-Accel-Redirect를 사용할 때 응답 전송 속도를 제한합니다.

예를 들어, 헤더 **`X-Accel-Redirect`**는 nginx에서 내부 **redirect**를 발생시킵니다. 따라서 `root /`와 같은 nginx 설정이 있고 웹 서버 응답에 **`X-Accel-Redirect: .env`**가 포함되어 있다면 nginx는 **`/.env`**의 내용을 전송하게 되어 (Path Traversal) 문제가 발생합니다.

### **Default Value in Map Directive**

In the **Nginx configuration**, the `map` directive often plays a role in **authorization control**. A common mistake is not specifying a **default** value, which could lead to unauthorized access. For instance:
```yaml
http {
map $uri $mappocallow {
/map-poc/private 0;
/map-poc/secret 0;
/map-poc/public 1;
}
}
```

```yaml
server {
location /map-poc {
if ($mappocallow = 0) {return 403;}
return 200 "Hello. It is private area: $mappocallow";
}
}
```
Without a `default`, a **악의적인 사용자** can bypass security by accessing an **정의되지 않은 URI** within `/map-poc`. [The Nginx manual](https://nginx.org/en/docs/http/ngx_http_map_module.html) advises setting a **기본값** to avoid such issues.

### **DNS Spoofing Vulnerability**

DNS spoofing against Nginx is feasible under certain conditions. If an attacker knows the **DNS server** used by Nginx and can intercept its DNS queries, they can spoof DNS records. This method, however, is ineffective if Nginx is configured to use **localhost (127.0.0.1)** for DNS resolution. Nginx allows specifying a DNS server as follows:
```yaml
resolver 8.8.8.8;
```
### **`proxy_pass` 및 `internal` 지시어**

The **`proxy_pass`** 지시어는 요청을 내부 또는 외부의 다른 서버로 리다이렉트하는 데 사용됩니다. The **`internal`** 지시어는 특정 위치가 Nginx 내에서만 접근 가능하도록 보장합니다. 이들 지시어 자체는 취약점이 아니지만, 설정을 신중히 검토하지 않으면 보안 결함이 발생할 수 있습니다.

## proxy_set_header Upgrade & Connection

nginx 서버가 Upgrade 및 Connection 헤더를 전달하도록 구성되어 있으면 [**h2c Smuggling attack**](../../pentesting-web/h2c-smuggling.md)를 통해 보호된/내부 엔드포인트에 접근할 수 있습니다.

> [!CAUTION]
> 이 취약점은 공격자가 **`proxy_pass` 엔드포인트와 직접 연결을 설정**(`http://backend:9999`의 경우)하여 해당 콘텐츠가 nginx에 의해 검사되지 않도록 허용합니다.

취약한 구성 예시 (to steal `/flag`) — 출처: [here](https://bishopfox.com/blog/h2c-smuggling-request):
```
server {
listen       443 ssl;
server_name  localhost;

ssl_certificate       /usr/local/nginx/conf/cert.pem;
ssl_certificate_key   /usr/local/nginx/conf/privkey.pem;

location / {
proxy_pass http://backend:9999;
proxy_http_version 1.1;
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection $http_connection;
}

location /flag {
deny all;
}
```
> [!WARNING]
> `proxy_pass`가 `http://backend:9999/socket.io`와 같은 특정 **path**를 가리키고 있더라도 실제 연결은 `http://backend:9999`로 설정된다는 점에 유의하세요. 따라서 내부 엔드포인트의 **다른 경로에 contact할 수 있습니다. 즉 proxy_pass URL에 경로가 명시되어 있어도 상관없습니다.**

## HTTP/3 QUIC 모듈 원격 DoS & leak (2024)

2024년 동안 Nginx는 CVE-2024-31079, CVE-2024-32760, CVE-2024-34161 및 CVE-2024-35200을 공개했으며, 실험적인 `ngx_http_v3_module`가 컴파일되어 있고 `listen ... quic` 소켓이 노출된 경우 단일 hostile QUIC session이 worker 프로세스를 크래시시키거나 메모리를 leak시킬 수 있음을 보여주었습니다. 영향을 받는 빌드는 1.25.0–1.25.5 및 1.26.0이며, 1.27.0/1.26.1에서 수정이 적용됩니다; 메모리 노출(CVE-2024-34161)은 민감한 데이터가 노출되기 위해 MTU가 4096 바이트보다 커야 한다는 추가 조건이 있습니다(자세한 내용은 아래의 2024 nginx 권고문 참조).

**Recon & exploitation hints**

- HTTP/3는 opt-in이므로 `Alt-Svc: h3=":443"` 응답을 스캔하거나 UDP/443 QUIC 핸드셰이크를 무차별 대입으로 시도하세요; 확인되면 custom `quiche-client`/`nghttp3` 페이로드로 핸드셰이크와 STREAM 프레임을 fuzz하여 worker 크래시를 유발하고 로그 leak를 강제 발생시킬 수 있습니다.
- 대상의 지원을 빠르게 fingerprint 하려면:
```bash
nginx -V 2>&1 | grep -i http_v3
rg -n "listen .*quic" /etc/nginx/
```
## TLS 세션 재개를 통한 client cert auth 우회 (CVE-2025-23419)

2025년 2월 발표된 권고문에 따르면 OpenSSL로 빌드된 nginx 1.11.4–1.27.3은 한 이름 기반 가상 호스트에서 생성된 **TLS 1.3 세션 재사용**을 다른 호스트 내부에서 허용하므로, 인증서 없이 협상된 호스트에 접속한 클라이언트가 ticket/PSK를 재생(replay)하여 `ssl_verify_client on;`으로 보호된 vhost로 진입해 mTLS를 완전히 우회할 수 있습니다. 이 버그는 여러 가상 호스트가 동일한 TLS 1.3 세션 캐시와 티켓을 공유할 때 발생합니다(아래의 2025 nginx 권고문 참조).

**공격자 플레이북**
```bash
# 1. Create a TLS session on the public vhost and save the session ticket
openssl s_client -connect public.example.com:443 -sess_out ticket.pem

# 2. Replay that session ticket against the mTLS vhost before it expires
openssl s_client -connect admin.example.com:443 -sess_in ticket.pem -ign_eof
```
대상이 취약한 경우, 두 번째 핸드셰이크는 클라이언트 인증서를 제시하지 않고 완료되어 보호된 위치가 노출됩니다.

**감사해야 할 항목**

- 서로 섞여 있는 `server_name` 블록이 `ssl_session_cache shared:SSL` plus `ssl_session_tickets on;`을 공유하는 경우.
- mTLS를 기대하지만 공개 호스트로부터 공유 세션 캐시/티켓 설정을 상속받는 Admin/API 설정 블록.
- vhost 격리를 고려하지 않고 TLS 1.3 session resumption을 전역적으로 활성화하는 자동화(예: Ansible roles).

## HTTP/2 Rapid Reset resilience (CVE-2023-44487 behavior)

HTTP/2 Rapid Reset 공격(CVE-2023-44487)은 운영자가 `keepalive_requests` 또는 `http2_max_concurrent_streams`를 기본값보다 높게 설정할 때 여전히 nginx에 영향을 미칩니다: 공격자는 하나의 HTTP/2 연결을 열고 수천 개의 스트림으로 폭주시킨 다음 즉시 `RST_STREAM` 프레임을 발행해 동시성 상한에 도달하지 못하게 하면서도 CPU가 해제(tear-down) 로직에서 계속 소모되게 합니다. Nginx 기본값(128 concurrent streams, 1000 keepalive requests)은 영향 범위를 작게 유지하지만, 이러한 한계를 "상당히 높이면" 단일 클라이언트에서도 워커를 고갈시키는 것이 쉽습니다(아래의 F5 write-up 참조).

**탐지 팁**
```bash
# Highlight risky knobs
rg -n "http2_max_concurrent_streams" /etc/nginx/
rg -n "keepalive_requests" /etc/nginx/
```
해당 디렉티브들에 대해 비정상적으로 높은 값을 노출하는 호스트는 주요 표적이다: 하나의 HTTP/2 클라이언트가 스트림 생성과 즉시 `RST_STREAM` 프레임을 반복해 concurrency cap을 초과시키지 않고도 CPU 사용률을 지속적으로 최대로 끌어올릴 수 있다.

## 직접 시도해보기

Detectify는 이 글에서 논의한 일부 잘못된 구성들을 포함한 취약한 Nginx 테스트 서버를 Docker로 구성해 직접 찾아볼 수 있는 GitHub 리포지토리를 만들었다!

[https://github.com/detectify/vulnerable-nginx](https://github.com/detectify/vulnerable-nginx)

## 정적 분석 도구

### [gixy-ng](https://github.com/dvershinin/gixy) & [GixyNG](https://github.com/megamansec/gixyng) & [GIXY](https://github.com/yandex/gixy)


- [GixyNG](https://github.com/megamansec/gixyng) (an updated fork of GIXY)는 Nginx 설정을 분석하여 취약점, 보안상 위험한 디렉티브, 그리고 위험한 잘못된 구성을 찾아내는 도구다. 또한 성능에 영향을 미치는 잘못된 구성과 놓친 강화 기회를 탐지해 자동화된 결함 발견을 가능하게 한다.
- [gixy-ng](https://github.com/dvershinin/gixy) (the actively maintained fork of GIXY)는 Nginx 설정을 분석하여 취약점, 보안상 위험한 디렉티브, 그리고 위험한 잘못된 구성을 찾아내는 도구다. 또한 성능에 영향을 미치는 잘못된 구성과 놓친 강화 기회를 탐지해 자동화된 결함 발견을 가능하게 한다.

### [Nginxpwner](https://github.com/stark0de/nginxpwner)

Nginxpwner는 일반적인 Nginx 잘못된 구성과 취약점을 찾아보는 간단한 도구다.

## 참고자료

- [**https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/**](https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/)
- [**http://blog.zorinaq.com/nginx-resolver-vulns/**](http://blog.zorinaq.com/nginx-resolver-vulns/)
- [**https://github.com/yandex/gixy/issues/115**](https://github.com/yandex/gixy/issues/115)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html**](https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html**](https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html)
- [**https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products**](https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products)


{{#include ../../banners/hacktricks-training.md}}
