# Nginx

{{#include ../../banners/hacktricks-training.md}}


## Eksik kök konumu <a href="#missing-root-location" id="missing-root-location"></a>

Nginx sunucusunu yapılandırırken, **root direktifi** dosyaların sunulduğu temel dizini tanımlayarak kritik bir rol oynar. Aşağıdaki örneği dikkate alın:
```bash
server {
root /etc/nginx;

location /hello.txt {
try_files $uri $uri/ =404;
proxy_pass http://127.0.0.1:8080/;
}
}
```
Bu yapılandırmada, `/etc/nginx` kök dizin olarak belirlenmiştir. Bu ayar, belirtilen kök dizin içindeki dosyalara, örneğin `/hello.txt`, erişim sağlar. Ancak, yalnızca belirli bir konum (`/hello.txt`) tanımlandığını belirtmek önemlidir. Kök konumu için (`location / {...}`) herhangi bir yapılandırma yoktur. Bu eksiklik, kök direktifinin genel olarak geçerli olduğu anlamına gelir ve kök yolu `/` için yapılan isteklerin `/etc/nginx` altındaki dosyalara erişmesine olanak tanır.

Bu yapılandırmadan kaynaklanan kritik bir güvenlik durumu vardır. `GET /nginx.conf` gibi basit bir `GET` isteği, `/etc/nginx/nginx.conf` konumundaki Nginx yapılandırma dosyasını sunarak hassas bilgileri açığa çıkarabilir. Kökü daha az hassas bir dizine, örneğin `/etc`, ayarlamak bu riski azaltabilir, ancak yine de diğer kritik dosyalara, diğer yapılandırma dosyalarına, erişim günlüklerine ve hatta HTTP temel kimlik doğrulaması için kullanılan şifrelenmiş kimlik bilgilerine istenmeyen erişime izin verebilir.

## Alias LFI Yanlış Yapılandırması <a href="#alias-lfi-misconfiguration" id="alias-lfi-misconfiguration"></a>

Nginx'in yapılandırma dosyalarında, "location" direktifleri için dikkatli bir inceleme gereklidir. Yerel Dosya Dahil Etme (LFI) olarak bilinen bir zafiyet, aşağıdaki gibi bir yapılandırma aracılığıyla istemeden tanıtılabilir:
```
location /imgs {
alias /path/images/;
}
```
Bu yapılandırma, sunucunun `/imgs../flag.txt` gibi istekleri, hedef dizin dışındaki dosyalara erişim girişimi olarak yorumlaması nedeniyle LFI saldırılarına açıktır ve bu da etkili bir şekilde `/path/images/../flag.txt` olarak çözülmektedir. Bu hata, saldırganların web üzerinden erişilememesi gereken dosyaları sunucunun dosya sisteminden almasına olanak tanır.

Bu güvenlik açığını azaltmak için yapılandırma şu şekilde ayarlanmalıdır:
```
location /imgs/ {
alias /path/images/;
}
```
Daha fazla bilgi: [https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/](https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/)

Accunetix testleri:
```
alias../ => HTTP status code 403
alias.../ => HTTP status code 404
alias../../ => HTTP status code 403
alias../../../../../../../../../../../ => HTTP status code 400
alias../ => HTTP status code 403
```
## Güvensiz yol kısıtlaması <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

Aşağıdaki sayfayı kontrol edin, şu gibi direktifleri nasıl atlayacağınızı öğrenin:
```plaintext
location = /admin {
deny all;
}

location = /admin/ {
deny all;
}
```
{{#ref}}
../../pentesting-web/proxy-waf-protections-bypass.md
{{#endref}}

## Güvensiz değişken kullanımı / HTTP İstek Bölme <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

> [!CAUTION]
> Zayıf değişkenler `$uri` ve `$document_uri` ve bunlar `$request_uri` ile değiştirilerek düzeltilebilir.
>
> Bir regex de zayıf olabilir:
>
> `location ~ /docs/([^/])? { … $1 … }` - Zayıf
>
> `location ~ /docs/([^/\s])? { … $1 … }` - Zayıf değil (boşlukları kontrol ediyor)
>
> `location ~ /docs/(.*)? { … $1 … }` - Zayıf değil

Nginx yapılandırmasındaki bir zayıflık aşağıdaki örnekle gösterilmektedir:
```
location / {
return 302 https://example.com$uri;
}
```
HTTP isteklerinde \r (Carriage Return) ve \n (Line Feed) karakterleri yeni satır karakterlerini belirtir ve URL kodlu formları `%0d%0a` olarak temsil edilir. Bu karakterleri yanlış yapılandırılmış bir sunucuya yapılan bir isteğe (örneğin, `http://localhost/%0d%0aDetectify:%20clrf`) dahil etmek, sunucunun `Detectify` adında yeni bir başlık oluşturmasına neden olur. Bu, $uri değişkeninin URL kodlu yeni satır karakterlerini çözmesi nedeniyle gerçekleşir ve yanıt içinde beklenmeyen bir başlık oluşur:
```
HTTP/1.1 302 Moved Temporarily
Server: nginx/1.19.3
Content-Type: text/html
Content-Length: 145
Connection: keep-alive
Location: https://example.com/
Detectify: clrf
```
CRLF enjeksiyonu ve yanıt bölme riskleri hakkında daha fazla bilgi edinin [https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/](https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/).

Ayrıca bu teknik [**bu konuşmada açıklanmıştır**](https://www.youtube.com/watch?v=gWQyWdZbdoY&list=PL0xCSYnG_iTtJe2V6PQqamBF73n7-f1Nr&index=77) bazı savunmasız örnekler ve tespit mekanizmaları ile. Örneğin, bu yanlış yapılandırmayı bir kara kutu perspektifinden tespit etmek için bu istekleri kullanabilirsiniz:

- `https://example.com/%20X` - Herhangi bir HTTP kodu
- `https://example.com/%20H` - 400 Bad Request

Eğer savunmasızsa, ilki "X" herhangi bir HTTP yöntemi olarak dönecek ve ikincisi H geçerli bir yöntem olmadığından bir hata dönecektir. Böylece sunucu şunları alacak: `GET / H HTTP/1.1` ve bu hata tetiklenecektir.

Diğer tespit örnekleri şunlar olabilir:

- `http://company.tld/%20HTTP/1.1%0D%0AXXXX:%20x` - Herhangi bir HTTP kodu
- `http://company.tld/%20HTTP/1.1%0D%0AHost:%20x` - 400 Bad Request

O konuşmada sunulan bazı savunmasız yapılandırmalar şunlardı:

- **`$uri`**'nin son URL'de olduğu gibi ayarlandığını not edin.
```
location ^~ /lite/api/ {
proxy_pass http://lite-backend$uri$is_args$args;
}
```
- Yine **`$uri`**'nin URL'de (bu sefer bir parametre içinde) olduğunu not edin.
```
location ~ ^/dna/payment {
rewrite ^/dna/([^/]+) /registered/main.pl?cmd=unifiedPayment&context=$1&native_uri=$uri break;
proxy_pass http://$back;
```
- Artık AWS S3'te
```
location /s3/ {
proxy_pass https://company-bucket.s3.amazonaws.com$uri;
}
```
### Herhangi bir değişken

**Kullanıcı tarafından sağlanan verilerin**, belirli koşullar altında **Nginx değişkeni** olarak ele alınabileceği keşfedilmiştir. Bu davranışın nedeni biraz belirsiz kalmakla birlikte, nadir ya da doğrulaması basit değildir. Bu anomali, HackerOne'da bir güvenlik raporunda vurgulanmıştır, rapora [buradan](https://hackerone.com/reports/370094) ulaşabilirsiniz. Hata mesajı üzerindeki daha fazla araştırma, bunun [Nginx'in kod tabanındaki SSI filtre modülünde](https://github.com/nginx/nginx/blob/2187586207e1465d289ae64cedc829719a048a39/src/http/modules/ngx_http_ssi_filter_module.c#L365) meydana geldiğini belirlemiş ve Sunucu Tarafı Dahil Etmelerin (SSI) kök neden olduğunu ortaya çıkarmıştır.

Bu **yanlış yapılandırmayı tespit etmek** için, değişken yazdırmasını test etmek amacıyla bir referer başlığı ayarlamayı içeren aşağıdaki komut çalıştırılabilir:
```bash
$ curl -H ‘Referer: bar’ http://localhost/foo$http_referer | grep ‘foobar’
```
Bu yanlış yapılandırmanın sistemler arasında taranması, Nginx değişkenlerinin bir kullanıcı tarafından yazdırılabileceği birçok örneği ortaya çıkardı. Ancak, savunmasız örneklerin sayısındaki azalma, bu sorunu düzeltme çabalarının bir ölçüde başarılı olduğunu göstermektedir.

## Ham arka uç yanıtı okuma

Nginx, arka uç tarafından üretilen hataların ve HTTP başlıklarının yakalanmasına olanak tanıyan `proxy_pass` aracılığıyla bir özellik sunar; bu, dahili hata mesajlarını ve başlıkları gizlemeyi amaçlar. Bu, Nginx'in arka uç hatalarına yanıt olarak özel hata sayfaları sunmasıyla gerçekleştirilir. Ancak, Nginx geçersiz bir HTTP isteğiyle karşılaştığında zorluklar ortaya çıkar. Böyle bir istek, alındığı gibi arka uca iletilir ve arka ucun ham yanıtı, Nginx'in müdahalesi olmadan doğrudan istemciye gönderilir.

Bir uWSGI uygulamasını içeren örnek bir senaryoyu düşünün:
```python
def application(environ, start_response):
start_response('500 Error', [('Content-Type', 'text/html'), ('Secret-Header', 'secret-info')])
return [b"Secret info, should not be visible!"]
```
Bunu yönetmek için Nginx yapılandırmasında belirli direktifler kullanılır:
```
http {
error_page 500 /html/error.html;
proxy_intercept_errors on;
proxy_hide_header Secret-Header;
}
```
- [**proxy_intercept_errors**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_intercept_errors): Bu direktif, Nginx'in 300'den büyük bir durum koduna sahip arka uç yanıtları için özel bir yanıt sunmasını sağlar. Örneğimizdeki uWSGI uygulaması için, `500 Hatası` yanıtının Nginx tarafından yakalanıp işlenmesini garanti eder.
- [**proxy_hide_header**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_hide_header): İsminden de anlaşılacağı gibi, bu direktif belirtilen HTTP başlıklarını istemciden gizler, gizliliği ve güvenliği artırır.

Geçerli bir `GET` isteği yapıldığında, Nginx bunu normal şekilde işler ve herhangi bir gizli başlık ifşa etmeden standart bir hata yanıtı döner. Ancak, geçersiz bir HTTP isteği bu mekanizmayı atlar ve gizli başlıklar ve hata mesajları da dahil olmak üzere ham arka uç yanıtlarının ifşasına neden olur.

## merge_slashes kapalı

Varsayılan olarak, Nginx'in **`merge_slashes` direktifi** **`açık`** olarak ayarlanmıştır; bu, bir URL'deki birden fazla ileri eğik çizgiyi tek bir eğik çizgiye sıkıştırır. Bu özellik, URL işleme sürecini kolaylaştırırken, Nginx'in arkasındaki uygulamalardaki, özellikle yerel dosya dahil etme (LFI) saldırılarına yatkın olanların, zayıflıklarını yanlışlıkla gizleyebilir. Güvenlik uzmanları **Danny Robinson ve Rotem Bar**, Nginx'in ters proxy olarak hareket ettiği durumlarda bu varsayılan davranışla ilişkili potansiyel riskleri vurgulamışlardır.

Bu tür riskleri azaltmak için, bu zayıflıklara duyarlı uygulamalar için **`merge_slashes` direktifini kapatmak** önerilir. Bu, Nginx'in URL yapısını değiştirmeden uygulamaya istekleri iletmesini sağlar ve böylece temel güvenlik sorunlarını gizlemez.

Daha fazla bilgi için [Danny Robinson ve Rotem Bar](https://medium.com/appsflyer/nginx-may-be-protecting-your-applications-from-traversal-attacks-without-you-even-knowing-b08f882fd43d) bağlantısına bakabilirsiniz.

### **Maclicious Yanıt Başlıkları**

[**bu yazıda**](https://mizu.re/post/cors-playground) gösterildiği gibi, web sunucusundan gelen yanıtta mevcut olan belirli başlıklar, Nginx proxy'sinin davranışını değiştirecektir. Bunları [**belgelere**](https://www.nginx.com/resources/wiki/start/topics/examples/x-accel/) bakarak kontrol edebilirsiniz:

- `X-Accel-Redirect`: Nginx'e bir isteği belirtilen bir konuma dahili olarak yönlendirmesini belirtir.
- `X-Accel-Buffering`: Nginx'in yanıtı tamponlayıp tamponlamayacağını kontrol eder.
- `X-Accel-Charset`: X-Accel-Redirect kullanıldığında yanıt için karakter setini ayarlar.
- `X-Accel-Expires`: X-Accel-Redirect kullanıldığında yanıtın son kullanma süresini ayarlar.
- `X-Accel-Limit-Rate`: X-Accel-Redirect kullanıldığında yanıtlar için transfer hızını sınırlar.

Örneğin, **`X-Accel-Redirect`** başlığı, nginx'de dahili bir **yönlendirme** oluşturur. Dolayısıyla, **`root /`** gibi bir nginx yapılandırmasına sahip olmak ve web sunucusundan **`X-Accel-Redirect: .env`** ile bir yanıt almak, nginx'in **`/.env`** içeriğini göndermesine neden olacaktır (Path Traversal).

### **Map Direktifinde Varsayılan Değer**

**Nginx yapılandırmasında**, `map` direktifi genellikle **yetkilendirme kontrolü** rolü oynar. Yaygın bir hata, **varsayılan** bir değer belirtmemektir; bu, yetkisiz erişime yol açabilir. Örneğin:
```yaml
http {
map $uri $mappocallow {
/map-poc/private 0;
/map-poc/secret 0;
/map-poc/public 1;
}
}
```

```yaml
server {
location /map-poc {
if ($mappocallow = 0) {return 403;}
return 200 "Hello. It is private area: $mappocallow";
}
}
```
Varsayılan bir `default` olmadan, **kötü niyetli bir kullanıcı** `/map-poc` içinde **tanımsız bir URI**'ye erişerek güvenliği aşabilir. [Nginx kılavuzu](https://nginx.org/en/docs/http/ngx_http_map_module.html), bu tür sorunları önlemek için bir **varsayılan değer** ayarlamayı önerir.

### **DNS Spoofing Açığı**

Nginx'e karşı DNS spoofing, belirli koşullar altında mümkündür. Bir saldırgan, Nginx tarafından kullanılan **DNS sunucusunu** biliyorsa ve DNS sorgularını kesebiliyorsa, DNS kayıtlarını sahteleyebilir. Ancak, Nginx **localhost (127.0.0.1)** kullanacak şekilde yapılandırılmışsa, bu yöntem etkisizdir. Nginx, bir DNS sunucusunu aşağıdaki gibi belirtmeye izin verir:
```yaml
resolver 8.8.8.8;
```
### **`proxy_pass` ve `internal` Direktifleri**

**`proxy_pass`** direktifi, istekleri diğer sunuculara, ister dahili ister harici olarak yönlendirmek için kullanılır. **`internal`** direktifi, belirli konumların yalnızca Nginx içinde erişilebilir olmasını sağlar. Bu direktifler kendiliğinden bir zafiyet oluşturmasa da, yapılandırmalarının dikkatlice incelenmesi gerekmektedir; aksi takdirde güvenlik açıkları oluşabilir.

## proxy_set_header Upgrade & Connection

Eğer nginx sunucusu Upgrade ve Connection başlıklarını geçirecek şekilde yapılandırılmışsa, korunan/dahili uç noktalara erişmek için bir [**h2c Smuggling saldırısı**](../../pentesting-web/h2c-smuggling.md) gerçekleştirilebilir.

> [!CAUTION]
> Bu zafiyet, bir saldırganın **`proxy_pass` uç noktası ile doğrudan bir bağlantı kurmasına** (bu durumda `http://backend:9999`) izin verecektir; bu içeriğin nginx tarafından kontrol edilmeyeceği anlamına gelir.

`/flag` çalmak için savunmasız yapılandırma örneği [buradan](https://bishopfox.com/blog/h2c-smuggling-request) alınmıştır:
```
server {
listen       443 ssl;
server_name  localhost;

ssl_certificate       /usr/local/nginx/conf/cert.pem;
ssl_certificate_key   /usr/local/nginx/conf/privkey.pem;

location / {
proxy_pass http://backend:9999;
proxy_http_version 1.1;
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection $http_connection;
}

location /flag {
deny all;
}
```
> [!WARNING]
> `proxy_pass` belirli bir **path**'e, örneğin `http://backend:9999/socket.io` gibi yönlendirilse bile, bağlantı `http://backend:9999` ile kurulacaktır, bu nedenle o iç uç noktasındaki **herhangi bir diğer path** ile iletişim kurabilirsiniz. Bu nedenle, proxy_pass URL'sinde bir path belirtilip belirtilmediği önemli değildir.

## Kendin dene

Detectify, bu makalede tartışılan bazı yanlış yapılandırmalarla kendi savunmasız Nginx test sunucunuzu Docker kullanarak kurabileceğiniz bir GitHub deposu oluşturmuştur ve bunları kendiniz bulmayı deneyebilirsiniz!

[https://github.com/detectify/vulnerable-nginx](https://github.com/detectify/vulnerable-nginx)

## Statik Analiz Araçları

### [GIXY](https://github.com/yandex/gixy)

Gixy, Nginx yapılandırmasını analiz etmek için bir araçtır. Gixy'nin ana hedefi, güvenlik yanlış yapılandırmalarını önlemek ve hata tespitini otomatikleştirmektir.

### [Nginxpwner](https://github.com/stark0de/nginxpwner)

Nginxpwner, yaygın Nginx yanlış yapılandırmalarını ve güvenlik açıklarını aramak için basit bir araçtır.

## Referanslar

- [**https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/**](https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/)
- [**http://blog.zorinaq.com/nginx-resolver-vulns/**](http://blog.zorinaq.com/nginx-resolver-vulns/)
- [**https://github.com/yandex/gixy/issues/115**](https://github.com/yandex/gixy/issues/115)


{{#include ../../banners/hacktricks-training.md}}
