# Git

{{#include ../../banners/hacktricks-training.md}}

**Pour dump un dossier .git depuis une URL utilisez** [**https://github.com/arthaud/git-dumper**](https://github.com/arthaud/git-dumper)

**Utilisez** [**https://www.gitkraken.com/**](https://www.gitkraken.com/) **pour inspecter le contenu**

Si un répertoire _.git_ est trouvé dans une application web, vous pouvez télécharger tout le contenu en utilisant _wget -r http://web.com/.git_. Ensuite, vous pouvez voir les changements effectués en utilisant _git diff_.

Les outils : [Git-Money](https://github.com/dnoiz1/git-money), [DVCS-Pillage](https://github.com/evilpacket/DVCS-Pillage) et [GitTools](https://github.com/internetwache/GitTools) peuvent être utilisés pour récupérer le contenu d'un répertoire git.

L'outil [https://github.com/cve-search/git-vuln-finder](https://github.com/cve-search/git-vuln-finder) peut être utilisé pour rechercher des CVE et des messages de vulnérabilité de sécurité dans les messages de commit.

L'outil [https://github.com/michenriksen/gitrob](https://github.com/michenriksen/gitrob) recherche des données sensibles dans les dépôts d'une organisation et de ses employés.

[Repo security scanner](https://github.com/UKHomeOffice/repo-security-scanner) est un outil en ligne de commande conçu dans un seul but : vous aider à découvrir des secrets GitHub que des développeurs ont accidentellement exposés en poussant des données sensibles. Et comme les autres, il vous aidera à trouver des mots de passe, clés privées, noms d'utilisateur, tokens et plus encore.

Ici vous pouvez trouver une étude sur github dorks : [https://securitytrails.com/blog/github-dorks](https://securitytrails.com/blog/github-dorks)

### Faster /.git dumping & dirlisting bypass (2024–2026)

* [holly-hacker/git-dumper](https://github.com/holly-hacker/git-dumper) est une réécriture 2024 du dumper classique GitTools avec récupération en parallèle (>10x plus rapide). Exemple : `python3 git-dumper.py https://victim/.git/ out && cd out && git checkout -- .`
* [Ebryx/GitDump](https://github.com/Ebryx/GitDump) brute-forces object names from `.git/index`, `packed-refs`, etc. to recover repos even when directory traversal is disabled: `python3 git-dump.py https://victim/.git/ dump && cd dump && git checkout -- .`

### Triage post-dump rapide
```bash
cd dumpdir
# reconstruct working tree
git checkout -- .
# show branch/commit map
git log --graph --oneline --decorate --all
# list suspicious config/remotes/hooks
git config -l
ls .git/hooks
```
### Recherche de secrets/credentials (outillage actuel)

* **TruffleHog v3+**: entropy+regex avec parcours automatique de l'historique Git. `trufflehog git file://$PWD --only-verified --json > secrets.json`
* **Gitleaks** (v8+): jeu de règles regex rapide, peut scanner l'arborescence unpacked ou l'historique complet. `gitleaks detect -v --source . --report-format json --report-path gitleaks.json`

### RCE côté serveur de l'intégration Git via override de `hooksPath`

Les applications web modernes qui intègrent des repos Git réécrivent parfois **`.git/config` en utilisant des identifiants contrôlés par l'utilisateur**. Si ces identifiants sont concaténés dans `hooksPath`, vous pouvez rediriger les hooks Git vers un répertoire contrôlé par un attaquant et exécuter du code arbitraire lorsque le serveur exécute le Git natif (p.ex., `git commit`). Étapes clés :

* **Path traversal in `hooksPath`**: si un nom de repo/nom de dépendance est copié dans `hooksPath`, injectez `../../..` pour sortir du répertoire hooks prévu et pointer vers un emplacement où l'on peut écrire. Ceci est effectivement un [path traversal](../../pentesting-web/file-inclusion/README.md) dans la config Git.
* **Force the target directory to exist**: quand l'application effectue des clones côté serveur, abusez des contrôles de destination du clone (p.ex., un paramètre `ref`/branch/path) pour le faire cloner dans `../../git_hooks` ou un chemin de traversal similaire afin que les dossiers intermédiaires soient créés pour vous.
* **Ship executable hooks**: définissez le bit exécutable dans les métadonnées Git afin que chaque clone écrive le hook avec le mode `100755`:
```bash
git update-index --chmod=+x pre-commit
```
Ajoutez votre payload (reverse shell, file dropper, etc.) à `pre-commit`/`post-commit` dans ce repo.
* **Find a native Git code path**: des bibliothèques comme **JGit** ignorent les hooks. Cherchez des flux/flags de déploiement qui retombent sur le Git système (p.ex., forcer des paramètres deploy-with-attached-repo) afin que les hooks soient réellement exécutés.
* **Race the config rewrite**: si l'app assainit `.git/config` juste avant d'exécuter Git, spammez l'endpoint qui écrit votre `hooksPath` malveillant tout en déclenchant l'action Git pour gagner une [race condition](../../pentesting-web/race-condition.md) et faire exécuter votre hook.

## Références

- [holly-hacker/git-dumper – parallel fast /.git dumper](https://github.com/holly-hacker/git-dumper)
- [Ebryx/GitDump](https://github.com/Ebryx/GitDump)
- [LookOut: RCE and internal access on Looker (Tenable)](https://www.tenable.com/blog/google-looker-vulnerabilities-rce-internal-access-lookout)

{{#include ../../banners/hacktricks-training.md}}
