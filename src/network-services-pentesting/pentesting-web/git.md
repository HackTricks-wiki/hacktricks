# Git

{{#include ../../banners/hacktricks-training.md}}

**Um einen .git-Ordner von einer URL herunterzuladen, verwende** [**https://github.com/arthaud/git-dumper**](https://github.com/arthaud/git-dumper)

**Verwende** [**https://www.gitkraken.com/**](https://www.gitkraken.com/) **um den Inhalt zu inspizieren**

Wenn in einer Webanwendung ein _.git_-Verzeichnis gefunden wird, kannst du den gesamten Inhalt mit _wget -r http://web.com/.git._ herunterladen. Anschließend kannst du die vorgenommenen Änderungen mit _git diff_ ansehen.

Die Tools: [Git-Money](https://github.com/dnoiz1/git-money), [DVCS-Pillage](https://github.com/evilpacket/DVCS-Pillage) und [GitTools](https://github.com/internetwache/GitTools) können verwendet werden, um den Inhalt eines git-Verzeichnisses abzurufen.

Das Tool [https://github.com/cve-search/git-vuln-finder](https://github.com/cve-search/git-vuln-finder) kann verwendet werden, um in Commit-Nachrichten nach CVEs und Meldungen zu Sicherheitslücken zu suchen.

Das Tool [https://github.com/michenriksen/gitrob](https://github.com/michenriksen/gitrob) durchsucht die Repositories einer Organisation und ihrer Mitarbeiter nach sensiblen Daten.

[Repo security scanner](https://github.com/UKHomeOffice/repo-security-scanner) ist ein kommandozeilenbasiertes Tool, das mit einem einzigen Ziel entwickelt wurde: dir zu helfen, GitHub-Secrets zu entdecken, die Entwickler versehentlich durch das Pushen sensibler Daten offengelegt haben. Und wie die anderen hilft es dir, Passwörter, private Schlüssel, Benutzernamen, Tokens und mehr zu finden.

Hier findest du eine Studie über GitHub Dorks: [https://securitytrails.com/blog/github-dorks](https://securitytrails.com/blog/github-dorks)

### Faster /.git dumping & dirlisting bypass (2024–2026)

* [holly-hacker/git-dumper](https://github.com/holly-hacker/git-dumper) ist eine 2024 neu implementierte Version des klassischen GitTools-Dumpers mit parallelem Abruf (>10x Speedup). Beispiel: `python3 git-dumper.py https://victim/.git/ out && cd out && git checkout -- .`
* [Ebryx/GitDump](https://github.com/Ebryx/GitDump) führt Brute-Force auf Objektnamen aus (z. B. aus `.git/index`, `packed-refs` etc.), um Repositories wiederherzustellen, selbst wenn Directory Traversal deaktiviert ist: `python3 git-dump.py https://victim/.git/ dump && cd dump && git checkout -- .`

### Schnelle Triage nach dem Dump
```bash
cd dumpdir
# reconstruct working tree
git checkout -- .
# show branch/commit map
git log --graph --oneline --decorate --all
# list suspicious config/remotes/hooks
git config -l
ls .git/hooks
```
### Suche nach Secrets/Credentials (aktuelle Tools)

* **TruffleHog v3+**: entropy+regex mit automatischer Durchsuchung der Git-Historie. `trufflehog git file://$PWD --only-verified --json > secrets.json`
* **Gitleaks** (v8+): schnelles Regex-Regelwerk, kann den entpackten Baum oder die gesamte Historie scannen. `gitleaks detect -v --source . --report-format json --report-path gitleaks.json`

### Server-side Git integration RCE via `hooksPath` override

Moderne Web-Apps, die Git-Repos integrieren, schreiben manchmal **`.git/config` mit benutzerkontrollierten Bezeichnern neu**. Wenn diese Bezeichner in `hooksPath` konkateniert werden, kannst du Git-Hooks auf ein von einem Angreifer kontrolliertes Verzeichnis umleiten und beliebigen Code ausführen lassen, wenn der Server nativen Git-Code ausführt (z. B. `git commit`). Wichtige Schritte:

* **Path traversal in `hooksPath`**: wenn ein Repo-Name/Dependency-Name in `hooksPath` kopiert wird, injiziere `../../..`, um das vorgesehene hooks-Verzeichnis zu verlassen und auf einen beschreibbaren Ort zu zeigen. Dies ist effektiv ein [path traversal](../../pentesting-web/file-inclusion/README.md) in der Git-Konfiguration.
* **Erzwinge, dass das Zielverzeichnis existiert**: wenn die Anwendung serverseitige clones durchführt, missbrauche Klon-Ziel-Kontrollen (z. B. einen `ref`/branch/path-Parameter), damit es in `../../git_hooks` oder einen ähnlichen Traversal-Pfad klont und so die Zwischenordner für dich erzeugt werden.
* **Ship executable hooks**: setze das Ausführbarkeitsbit in den Git-Metadaten, sodass jeder Clone den Hook mit Modus `100755` schreibt:
```bash
git update-index --chmod=+x pre-commit
```
Füge deinen Payload (reverse shell, file dropper, etc.) zu `pre-commit`/`post-commit` in diesem Repo hinzu.
* **Find a native Git code path**: Bibliotheken wie **JGit** ignorieren hooks. Suche nach Deployment-Flows/Flags, die auf system Git zurückfallen (z. B. durch Erzwingen von deploy-with-attached-repo-Parametern), damit Hooks tatsächlich ausgeführt werden.
* **Race the config rewrite**: wenn die App `.git/config` direkt vor dem Ausführen von Git saniert, spamme den Endpoint, der deinen bösartigen `hooksPath` schreibt, während du die Git-Aktion auslöst, um eine [race condition](../../pentesting-web/race-condition.md) zu gewinnen und deinen Hook ausgeführt zu bekommen.

## Referenzen

- [holly-hacker/git-dumper – parallel fast /.git dumper](https://github.com/holly-hacker/git-dumper)
- [Ebryx/GitDump](https://github.com/Ebryx/GitDump)
- [LookOut: RCE and internal access on Looker (Tenable)](https://www.tenable.com/blog/google-looker-vulnerabilities-rce-internal-access-lookout)

{{#include ../../banners/hacktricks-training.md}}
