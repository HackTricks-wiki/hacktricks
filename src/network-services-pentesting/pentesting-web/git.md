# Git

{{#include ../../banners/hacktricks-training.md}}

**Para volcar una carpeta .git desde una URL utiliza** [**https://github.com/arthaud/git-dumper**](https://github.com/arthaud/git-dumper)

**Usa** [**https://www.gitkraken.com/**](https://www.gitkraken.com/) **para inspeccionar el contenido**

Si se encuentra un directorio _.git_ en una aplicación web puedes descargar todo el contenido usando _wget -r http://web.com/.git._ Luego, puedes ver los cambios realizados usando _git diff_.

Las herramientas: [Git-Money](https://github.com/dnoiz1/git-money), [DVCS-Pillage](https://github.com/evilpacket/DVCS-Pillage) and [GitTools](https://github.com/internetwache/GitTools) se pueden usar para recuperar el contenido de un directorio git.

La herramienta [https://github.com/cve-search/git-vuln-finder](https://github.com/cve-search/git-vuln-finder) se puede usar para buscar CVEs y mensajes de vulnerabilidad de seguridad dentro de los mensajes de los commits.

La herramienta [https://github.com/michenriksen/gitrob](https://github.com/michenriksen/gitrob) busca datos sensibles en los repositorios de una organización y sus empleados.

[Repo security scanner](https://github.com/UKHomeOffice/repo-security-scanner) es una herramienta de línea de comandos creada con un único objetivo: ayudarte a descubrir secretos de GitHub que los desarrolladores subieron accidentalmente al pushear datos sensibles. Y, al igual que las otras, te ayudará a encontrar contraseñas, claves privadas, usernames, tokens y más.

Aquí puedes encontrar un estudio sobre github dorks: [https://securitytrails.com/blog/github-dorks](https://securitytrails.com/blog/github-dorks)

### Más rápido /.git dumping & dirlisting bypass (2024–2026)

* [holly-hacker/git-dumper](https://github.com/holly-hacker/git-dumper) es una reescritura de 2024 del clásico GitTools dumper con fetching paralelo (>10x de aceleración). Ejemplo: `python3 git-dumper.py https://victim/.git/ out && cd out && git checkout -- .`
* [Ebryx/GitDump](https://github.com/Ebryx/GitDump) realiza fuerza bruta sobre nombres de objetos desde `.git/index`, `packed-refs`, etc. para recuperar repos incluso cuando directory traversal está deshabilitado: `python3 git-dump.py https://victim/.git/ dump && cd dump && git checkout -- .`

### Triage rápido tras el volcado
```bash
cd dumpdir
# reconstruct working tree
git checkout -- .
# show branch/commit map
git log --graph --oneline --decorate --all
# list suspicious config/remotes/hooks
git config -l
ls .git/hooks
```
### Búsqueda de secretos/credenciales (herramientas actuales)

* **TruffleHog v3+**: entropy+regex con recorrido automático del historial de Git. `trufflehog git file://$PWD --only-verified --json > secrets.json`
* **Gitleaks** (v8+): conjunto de reglas regex rápido, puede escanear el árbol desempaquetado o el historial completo. `gitleaks detect -v --source . --report-format json --report-path gitleaks.json`

### RCE en integración de Git del lado servidor mediante override de `hooksPath`

Las aplicaciones web modernas que integran repositorios Git a veces **reescriben `.git/config` usando identificadores controlados por el usuario**. Si esos identificadores se concatenan en `hooksPath`, puedes redirigir los hooks de Git a un directorio controlado por el atacante y ejecutar código arbitrario cuando el servidor ejecute Git nativo (p. ej., `git commit`). Pasos clave:

* **Path traversal en `hooksPath`**: si un nombre de repo/nombre de dependencia se copia en `hooksPath`, inyecta `../../..` para escapar del directorio de hooks previsto y apuntar a una ubicación escribible. Esto es efectivamente un [path traversal](../../pentesting-web/file-inclusion/README.md) en la configuración de Git.
* **Forzar que el directorio objetivo exista**: cuando la aplicación realiza clones del lado servidor, abusa de los controles de destino del clone (p. ej., un parámetro `ref`/branch/path) para hacer que clone en `../../git_hooks` o una ruta de traversal similar para que se creen las carpetas intermedias por ti.
* **Distribuir hooks ejecutables**: establece el bit ejecutable dentro de los metadatos de Git para que cada clone escriba el hook con modo `100755`:
```bash
git update-index --chmod=+x pre-commit
```
Añade tu payload (reverse shell, file dropper, etc.) a `pre-commit`/`post-commit` en ese repo.
* **Encontrar una ruta de código de Git nativa**: bibliotecas como **JGit** ignoran los hooks. Busca flujos/flags de despliegue que recurran a system Git (p. ej., forzar deploy-with-attached-repo parameters) para que los hooks realmente se ejecuten.
* **Ganarle a la reescritura de la config**: si la app sanitiza `.git/config` justo antes de ejecutar Git, spamea el endpoint que escribe tu `hooksPath` malicioso mientras disparas la acción de Git para ganar una [race condition](../../pentesting-web/race-condition.md) y lograr que tu hook se ejecute.

## Referencias

- [holly-hacker/git-dumper – parallel fast /.git dumper](https://github.com/holly-hacker/git-dumper)
- [Ebryx/GitDump](https://github.com/Ebryx/GitDump)
- [LookOut: RCE and internal access on Looker (Tenable)](https://www.tenable.com/blog/google-looker-vulnerabilities-rce-internal-access-lookout)

{{#include ../../banners/hacktricks-training.md}}
