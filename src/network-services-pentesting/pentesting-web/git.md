# Git

{{#include ../../banners/hacktricks-training.md}}

**Per scaricare una cartella .git da un URL usa** [**https://github.com/arthaud/git-dumper**](https://github.com/arthaud/git-dumper)

**Usa** [**https://www.gitkraken.com/**](https://www.gitkraken.com/) **per ispezionare il contenuto**

Se viene trovata una directory _.git_ in un'applicazione web, puoi scaricare tutto il contenuto usando _wget -r http://web.com/.git_. Poi puoi vedere le modifiche effettuate usando _git diff_.

Gli strumenti: [Git-Money](https://github.com/dnoiz1/git-money), [DVCS-Pillage](https://github.com/evilpacket/DVCS-Pillage) e [GitTools](https://github.com/internetwache/GitTools) possono essere utilizzati per recuperare il contenuto di una directory git.

Lo strumento [https://github.com/cve-search/git-vuln-finder](https://github.com/cve-search/git-vuln-finder) può essere usato per cercare CVE e messaggi relativi a vulnerabilità di sicurezza all'interno dei messaggi di commit.

Lo strumento [https://github.com/michenriksen/gitrob](https://github.com/michenriksen/gitrob) cerca dati sensibili nei repository di un'organizzazione e dei suoi dipendenti.

[Repo security scanner](https://github.com/UKHomeOffice/repo-security-scanner) è uno strumento da riga di comando scritto con un unico obiettivo: aiutarti a scoprire GitHub secrets che gli sviluppatori hanno accidentalmente pubblicato spingendo dati sensibili. E, come gli altri, ti aiuterà a trovare password, chiavi private, username, token e altro.

Qui puoi trovare uno studio su github dorks: [https://securitytrails.com/blog/github-dorks](https://securitytrails.com/blog/github-dorks)

### Più veloce /.git dumping & dirlisting bypass (2024–2026)

* [holly-hacker/git-dumper](https://github.com/holly-hacker/git-dumper) è una riscrittura del 2024 del classico GitTools dumper con fetching parallelo (velocità >10x). Esempio: `python3 git-dumper.py https://victim/.git/ out && cd out && git checkout -- .`
* [Ebryx/GitDump](https://github.com/Ebryx/GitDump) esegue brute-force sui nomi degli object da `.git/index`, `packed-refs`, ecc. per recuperare repo anche quando il directory traversal è disabilitato: `python3 git-dump.py https://victim/.git/ dump && cd dump && git checkout -- .`

### Triage rapido dopo il dump
```bash
cd dumpdir
# reconstruct working tree
git checkout -- .
# show branch/commit map
git log --graph --oneline --decorate --all
# list suspicious config/remotes/hooks
git config -l
ls .git/hooks
```
### Ricerca di segreti/credenziali (strumentazione attuale)

* **TruffleHog v3+**: entropy+regex con traversamento automatico della cronologia di Git. `trufflehog git file://$PWD --only-verified --json > secrets.json`
* **Gitleaks** (v8+): ruleset regex veloce, può scansionare l'albero unpacked o l'intera cronologia. `gitleaks detect -v --source . --report-format json --report-path gitleaks.json`

### RCE in integrazione Git lato server tramite override di `hooksPath`

Le moderne web app che integrano repository Git a volte **riscrivono `.git/config` usando identificatori controllati dall'utente**. Se tali identificatori vengono concatenati in `hooksPath`, puoi reindirizzare i Git hook verso una directory controllata dall'attaccante ed eseguire codice arbitrario quando il server esegue il Git nativo (es., `git commit`). Passi chiave:

* **Path traversal in `hooksPath`**: se un nome repo/nome dipendenza viene copiato in `hooksPath`, inietta `../../..` per uscire dalla directory hook prevista e puntare a una location scrivibile. Questo è effettivamente un [path traversal](../../pentesting-web/file-inclusion/README.md) nella config di Git.
* **Forza l'esistenza della directory target**: quando l'app effettua clone server-side, sfrutta i controlli di destinazione del clone (es., un parametro `ref`/branch/path) per farlo clonare in `../../git_hooks` o in un percorso di traversal simile in modo che le cartelle intermedie vengano create per te.
* **Distribuisci hook eseguibili**: imposta il bit eseguibile nei metadata di Git in modo che ogni clone scriva l'hook con mode `100755`:
```bash
git update-index --chmod=+x pre-commit
```
Aggiungi il tuo payload (reverse shell, file dropper, ecc.) a `pre-commit`/`post-commit` in quel repo.
* **Trova un codice path che usa Git nativo**: librerie come **JGit** ignorano gli hook. Cerca flow di deployment/flag che ricadono sul system Git (es., forzando parametri deploy-with-attached-repo) in modo che gli hook vengano effettivamente eseguiti.
* **Gara sulla riscrittura della config**: se l'app sanitizza `.git/config` subito prima di eseguire Git, bombarda l'endpoint che scrive il tuo `hooksPath` malevolo mentre triggeri l'azione Git per vincere una [race condition](../../pentesting-web/race-condition.md) e far eseguire il tuo hook.

## Riferimenti

- [holly-hacker/git-dumper – parallel fast /.git dumper](https://github.com/holly-hacker/git-dumper)
- [Ebryx/GitDump](https://github.com/Ebryx/GitDump)
- [LookOut: RCE and internal access on Looker (Tenable)](https://www.tenable.com/blog/google-looker-vulnerabilities-rce-internal-access-lookout)

{{#include ../../banners/hacktricks-training.md}}
