# 80,443 - Pentesting Web Methodology

{{#include ../../banners/hacktricks-training.md}}

## बुनियादी जानकारी

वेब सेवा सबसे **सामान्य और व्यापक सेवा** है और कई तरह की **vulnerabilities** मौजूद हैं।

**डिफ़ॉल्ट पोर्ट:** 80 (HTTP), 443(HTTPS)
```bash
PORT    STATE SERVICE
80/tcp  open  http
443/tcp open  ssl/https
```

```bash
nc -v domain.com 80 # GET / HTTP/1.0
openssl s_client -connect domain.com:443 # GET / HTTP/1.0
```
### Web API मार्गदर्शन


{{#ref}}
web-api-pentesting.md
{{#endref}}

## पद्धति सारांश

> इस पद्धति में हम यह मानकर चलेंगे कि आप केवल एक domain (या subdomain) पर ही attack कर रहे हैं। इसलिए, आपको यह पद्धति प्रत्येक खोजे गए domain, subdomain या उस scope के भीतर किसी undetermined web server वाले IP पर लागू करनी चाहिए।

- [ ] शुरुआत करें और **identify** करें कि web server कौन-कौन सी **technologies** उपयोग कर रहा है। यदि आप tech की पहचान कर पाते हैं तो टेस्ट के बाकी हिस्सों के दौरान ध्यान में रखने के लिए कोई **tricks** देखें।
- [ ] क्या उस technology के version की कोई known vulnerability है?
- [ ] कोई well known tech उपयोग हो रहा है? अधिक जानकारी निकालने के लिए कोई उपयोगी trick है?
- [ ] कोई specialised scanner चलाने लायक है (जैसे wpscan)?
- [ ] general purposes scanners चलाएँ। आप नहीं जानते वे कुछ पाएंगे या कोई interesting information निकालेंगे।
- [ ] शुरू करें **प्रारंभिक जांच**: **robots**, **sitemap**, **404** error और **SSL/TLS scan** (यदि **HTTPS**)।
- [ ] Start **spidering** the web page: यह समय है सभी संभावित **files**, **folders** और **parameters** को खोजने का। साथ ही, special findings की जांच करें।
- [ ] _नोट कि जब भी कोई नया directory brute-forcing या spidering के दौरान खोजा जाए, उसे spider करना चाहिए._
- [ ] **Directory Brute-Forcing**: पाए गए सभी folders पर brute force करें ताकि नए **files** और **directories** मिल सकें।
- [ ] _नोट कि जब भी कोई नया directory brute-forcing या spidering के दौरान खोजा जाए, उसे Brute-Forced किया जाना चाहिए._
- [ ] **Backups checking**: जांचें कि क्या आप खोजे गए files के backups सामान्य backup extensions जोड़कर पा सकते हैं।
- [ ] **Brute-Force parameters**: छुपे हुए parameters खोजने की कोशिश करें।
- [ ] जब आपने उन सभी संभावित endpoints की पहचान कर ली हो जो user input स्वीकार करते हैं, तो उनसे संबंधित सभी प्रकार की vulnerabilities की जाँच करें।
- [ ] [इस चेकलिस्ट का पालन करें](../../pentesting-web/web-vulnerabilities-methodology.md)

## Server Version (Vulnerable?)

### पहचानें

जाँचें कि क्या चल रहे server version के लिए कोई known vulnerabilities हैं।\
HTTP headers और response के cookies तकनीकें और/या उपयोग हो रहा version पहचानने में बहुत उपयोगी हो सकते हैं। Nmap scan server version पहचान सकता है, पर यह tools [**whatweb**](https://github.com/urbanadventurer/WhatWeb)**,** [**webtech**](https://github.com/ShielderSec/webtech) या [**https://builtwith.com/**](https://builtwith.com)**:**
```bash
whatweb -a 1 <URL> #Stealthy
whatweb -a 3 <URL> #Aggresive
webtech -u <URL>
webanalyze -host https://google.com -crawl 2
```
खोजें [**vulnerabilities of the web application** **version**](../../generic-hacking/search-exploits.md)

### **जाँचें कि WAF मौजूद है या नहीं**

- [**https://github.com/EnableSecurity/wafw00f**](https://github.com/EnableSecurity/wafw00f)
- [**https://github.com/Ekultek/WhatWaf.git**](https://github.com/Ekultek/WhatWaf.git)
- [**https://nmap.org/nsedoc/scripts/http-waf-detect.html**](https://nmap.org/nsedoc/scripts/http-waf-detect.html)

### Web tech tricks

कुछ **tricks** उन विभिन्न प्रसिद्ध **technologies** में **vulnerabilities** खोजने के लिए जो उपयोग में हैं:

- [**AEM - Adobe Experience Cloud**](aem-adobe-experience-cloud.md)
- [**Apache**](apache.md)
- [**Artifactory**](artifactory-hacking-guide.md)
- [**Buckets**](buckets/index.html)
- [**CGI**](cgi.md)
- [**Drupal**](drupal/index.html)
- [**Flask**](flask.md)
- [**Git**](git.md)
- [**Golang**](golang.md)
- [**GraphQL**](graphql.md)
- [**H2 - Java SQL database**](h2-java-sql-database.md)
- [**ISPConfig**](ispconfig.md)
- [**IIS tricks**](iis-internet-information-services.md)
- [**Microsoft SharePoint**](microsoft-sharepoint.md)
- [**JBOSS**](jboss.md)
- [**Jenkins**](<[https:/github.com/carlospolop/hacktricks/blob/master/network-services-pentesting/pentesting-web/broken-reference/README.md](https:/github.com/HackTricks-wiki/hacktricks-cloud/tree/master/pentesting-ci-cd/jenkins-security)/>)
- [**Jira**](jira.md)
- [**Joomla**](joomla.md)
- [**JSP**](jsp.md)
- [**Laravel**](laravel.md)
- [**Moodle**](moodle.md)
- [**Nginx**](nginx.md)
- [**PHP (php has a lot of interesting tricks that could be exploited)**](php-tricks-esp/index.html)
- [**Python**](python.md)
- [**Spring Actuators**](spring-actuators.md)
- [**Symphony**](symphony.md)
- [**Tomcat**](tomcat/index.html)
- [**VMWare**](vmware-esx-vcenter....md)
- [**Web API Pentesting**](web-api-pentesting.md)
- [**WebDav**](put-method-webdav.md)
- [**Werkzeug**](werkzeug.md)
- [**Wordpress**](wordpress.md)
- [**Electron Desktop (XSS to RCE)**](electron-desktop-apps/index.html)
- [**Sitecore**](sitecore/index.html)

_ध्यान में रखें कि वही **same domain** विभिन्न **ports**, **folders** और **subdomains** में विभिन्न **technologies** का उपयोग कर सकता है._\
यदि वेब एप्लिकेशन किसी भी प्रसिद्ध **tech/platform listed before** या किसी अन्य का उपयोग कर रहा है, तो नई tricks के लिए इंटरनेट पर खोज करना न भूलें (और मुझे बताइए!).

### स्रोत कोड समीक्षा

यदि एप्लिकेशन का **source code** **github** पर उपलब्ध है, तो आपके द्वारा एप्लिकेशन पर एक **White box test** करने के अलावा कुछ ऐसी **information** हो सकती है जो वर्तमान **Black-Box testing** के लिए **useful** हो:

- क्या कोई **Change-log or Readme or Version** file या कोई ऐसी चीज़ है जिसमें **version info accessible** वेब के जरिए उपलब्ध हो?
- credentials कैसे और कहाँ सेव होते हैं? क्या कोई (accessible?) **file** है जिसमें credentials (usernames या passwords) हैं?
- क्या passwords plain text में हैं, encrypted हैं या किस **hashing algorithm** का उपयोग हुआ है?
- क्या यह किसी **master key** का उपयोग कर रहा है किसी चीज़ को encrypt करने के लिए? कौन सा **algorithm** उपयोग किया जा रहा है?
- क्या आप किसी vulnerability को exploit करके इन फ़ाइलों में से किसी तक पहुँच सकते हैं?
- क्या **github** में (solved और not solved) **issues** में कोई दिलचस्प information है? या **commit history** में (शायद किसी पुराने commit में कोई password introduce हुआ हो)?

{{#ref}}
code-review-tools.md
{{#endref}}

### Automatic scanners

#### General purpose automatic scanners
```bash
nikto -h <URL>
whatweb -a 4 <URL>
wapiti -u <URL>
W3af
zaproxy #You can use an API
nuclei -ut && nuclei -target <URL>

# https://github.com/ignis-sec/puff (client side vulns fuzzer)
node puff.js -w ./wordlist-examples/xss.txt -u "http://www.xssgame.com/f/m4KKGHi2rVUN/?query=FUZZ"
```
#### CMS scanners

यदि CMS का उपयोग हो रहा है तो **run a scanner** करना न भूलें — शायद कुछ दिलचस्प मिल जाए:

[**Clusterd**](https://github.com/hatRiot/clusterd)**:** [**JBoss**](jboss.md)**, ColdFusion, WebLogic,** [**Tomcat**](tomcat/index.html)**, Railo, Axis2, Glassfish**\
[**CMSScan**](https://github.com/ajinabraham/CMSScan): [**WordPress**](wordpress.md), [**Drupal**](drupal/index.html), **Joomla**, **vBulletin** Security issues के लिए वेबसाइट्स। (GUI)\ 
[**VulnX**](https://github.com/anouarbensaad/vulnx)**:** [**Joomla**](joomla.md)**,** [**Wordpress**](wordpress.md)**,** [**Drupal**](drupal/index.html)**, PrestaShop, Opencart**\
**CMSMap**: [**(W)ordpress**](wordpress.md)**,** [**(J)oomla**](joomla.md)**,** [**(D)rupal**](drupal/index.html) **या** [**(M)oodle**](moodle.md)\
[**droopscan**](https://github.com/droope/droopescan)**:** [**Drupal**](drupal/index.html)**,** [**Joomla**](joomla.md)**,** [**Moodle**](moodle.md)**, Silverstripe,** [**Wordpress**](wordpress.md)
```bash
cmsmap [-f W] -F -d <URL>
wpscan --force update -e --url <URL>
joomscan --ec -u <URL>
joomlavs.rb #https://github.com/rastating/joomlavs
```
> इस बिंदु पर आपके पास क्लाइंट द्वारा उपयोग किए जा रहे वेब सर्वर (यदि कोई डेटा दिया गया हो) के बारे में कुछ जानकारी और टेस्ट के दौरान ध्यान में रखने के लिए कुछ ट्रिक्स पहले से होनी चाहिए। अगर आप भाग्यशाली हैं तो आपने एक CMS भी खोज लिया होगा और कुछ स्कैनर चला लिया होगा।

## Step-by-step Web Application Discovery

> इस बिंदु से हम वेब एप्लिकेशन के साथ इंटरैक्ट करना शुरू करेंगे।

### Initial checks

**Default pages with interesting info:**

- /robots.txt
- /sitemap.xml
- /crossdomain.xml
- /clientaccesspolicy.xml
- /.well-known/
- मुख्य और द्वितीयक पेजों में टिप्पणियाँ भी जांचें।

**Forcing errors**

वेब सर्वर जब असामान्य डेटा भेजा जाता है तो **अनपेक्षित रूप से व्यवहार कर सकते हैं**। इससे **vulnerabilities** खुल सकती हैं या **disclosure sensitive information** उजागर हो सकती है।

- /whatever_fake.php (.aspx,.html,.etc) जैसे **fake pages** तक पहुँचें
- **Add "\[]", "]]", and "\[["** को **cookie values** और **parameter values** में जोड़कर त्रुटियाँ उत्पन्न करें
- URL के **end** पर इनपुट देकर error उत्पन्न करें, उदाहरण: **`/~randomthing/%s`**
- PATCH, DEBUG जैसे अलग HTTP Verbs या FAKE जैसे गलत verbs आज़माएँ

#### **जाँचें कि क्या आप फाइलें अपलोड कर सकते हैं (**[**PUT verb, WebDav**](put-method-webdav.md)**)**

यदि आप पाते हैं कि **WebDav** **enabled** है लेकिन root फ़ोल्डर में **uploading files** के लिए पर्याप्त permissions नहीं हैं तो कोशिश करें:

- **Brute Force** credentials
- WebDav के माध्यम से वेब पेज के अंदर मिले हुए अन्य फ़ोल्डर्स (rest of found folders) में **Upload files** करें। हो सकता है कि अन्य फ़ोल्डर्स में फाइलें अपलोड करने की permissions हों।

### **SSL/TLS vulnerabilites**

- यदि application किसी हिस्से में **HTTPS** उपयोग करने के लिए फोर्स नहीं कर रहा है, तो यह **vulnerable to MitM** है
- यदि application संवेदनशील डेटा (passwords) **HTTP** के माध्यम से भेज रहा है, तो यह एक उच्च severity vulnerability है।

[**testssl.sh**](https://github.com/drwetter/testssl.sh) का उपयोग **vulnerabilities** की जाँच के लिए करें (Bug Bounty programs में संभवतः इस प्रकार की vulnerabilities स्वीकार नहीं की जातीं) और पुनः जाँच के लिए [**a2sv**](https://github.com/hahwul/a2sv) का उपयोग करें:
```bash
./testssl.sh [--htmlfile] 10.10.10.10:443
#Use the --htmlfile to save the output inside an htmlfile also

# You can also use other tools, by testssl.sh at this momment is the best one (I think)
sslscan <host:port>
sslyze --regular <ip:port>
```
Information about SSL/TLS vulnerabilities:

- [https://www.gracefulsecurity.com/tls-ssl-vulnerabilities/](https://www.gracefulsecurity.com/tls-ssl-vulnerabilities/)
- [https://www.acunetix.com/blog/articles/tls-vulnerabilities-attacks-final-part/](https://www.acunetix.com/blog/articles/tls-vulnerabilities-attacks-final-part/)

### Spidering

लक्ष्य यह है कि वेब के अंदर कोई न कोई प्रकार का **spider** लॉन्च करें। spider का उद्देश्य टेस्ट की जा रही application से जितने संभव हो उतने **paths ढूँढना** है। इसलिए web crawling और बाहरी स्रोतों का उपयोग करके जितने संभव हो उतने वैध paths खोजने चाहिए।

- [**gospider**](https://github.com/jaeles-project/gospider) (go): HTML spider, JS फ़ाइलों में LinkFinder और बाहरी स्रोतों (Archive.org, CommonCrawl.org, VirusTotal.com) का उपयोग करता है।
- [**hakrawler**](https://github.com/hakluke/hakrawler) (go): HML spider, JS फ़ाइलों के लिए LinkFider और Archive.org को बाहरी स्रोत के रूप में उपयोग करता है।
- [**dirhunt**](https://github.com/Nekmo/dirhunt) (python): HTML spider, "juicy files" की पहचान भी बताता है।
- [**evine** ](https://github.com/saeeddhqan/evine)(go): Interactive CLI HTML spider। यह Archive.org में भी खोजता है।
- [**meg**](https://github.com/tomnomnom/meg) (go): यह टूल spider नहीं है पर उपयोगी हो सकता है। आप hosts की एक फ़ाइल और paths की एक फ़ाइल दे सकते हैं और meg हर host पर हर path को fetch करके response सेव कर देगा।
- [**urlgrab**](https://github.com/IAmStoxe/urlgrab) (go): JS rendering क्षमताओं वाला HTML spider। हालांकि, ऐसा लगता है कि यह unmaintained है, precompiled version पुराना है और वर्तमान कोड compile नहीं होता।
- [**gau**](https://github.com/lc/gau) (go): बाहरी providers (wayback, otx, commoncrawl) का उपयोग करने वाला HTML spider।
- [**ParamSpider**](https://github.com/devanshbatham/ParamSpider): यह script parameter वाले URLs खोजेगा और उन्हें सूचीबद्ध करेगा।
- [**galer**](https://github.com/dwisiswant0/galer) (go): JS rendering क्षमताओं वाला HTML spider।
- [**LinkFinder**](https://github.com/GerbenJavado/LinkFinder) (python): HTML spider, JS beautify क्षमताओं के साथ जो JS फ़ाइलों में नए paths खोज सकता है। इसका wrapper [JSScanner](https://github.com/dark-warlord14/JSScanner) भी देखने लायक है।
- [**goLinkFinder**](https://github.com/0xsha/GoLinkFinder) (go): HTML source और embedded javascript फ़ाइलों दोनों से endpoints निकालने के लिए। bug hunters, red teamers, infosec ninjas के लिए उपयोगी।
- [**JSParser**](https://github.com/nahamsec/JSParser) (python2.7): Tornado और JSBeautifier का उपयोग करके JavaScript फ़ाइलों से relative URLs parse करने वाला python 2.7 script। AJAX requests खोजने में उपयोगी। लगता है unmaintained।
- [**relative-url-extractor**](https://github.com/jobertabma/relative-url-extractor) (ruby): किसी फ़ाइल (HTML) को दिया जाए तो यह एक निफ्टी regular expression का उपयोग करके ugly (minify) फ़ाइलों से relative URLs निकालता है।
- [**JSFScan**](https://github.com/KathanP19/JSFScan.sh) (bash, several tools): कई टूल्स का उपयोग करके JS फ़ाइलों से दिलचस्प जानकारी इकट्ठा करता है।
- [**subjs**](https://github.com/lc/subjs) (go): JS फ़ाइलें ढूँढता है।
- [**page-fetch**](https://github.com/detectify/page-fetch) (go): एक headless browser में पेज लोड करता है और पेज लोड करने के लिए लोड किए गए सभी urls प्रिंट करता है।
- [**Feroxbuster**](https://github.com/epi052/feroxbuster) (rust): Content discovery tool जो पिछले कई विकल्पों के कार्यों को मिलाता है।
- [**Javascript Parsing**](https://github.com/xnl-h4ck3r/burp-extensions): JS फ़ाइलों में path और params खोजने के लिए एक Burp extension।
- [**Sourcemapper**](https://github.com/denandz/sourcemapper): यह टूल .js.map URL दिए जाने पर beautified JS code ला देता है।
- [**xnLinkFinder**](https://github.com/xnl-h4ck3r/xnLinkFinder): किसी दिए गए target के लिए endpoints खोजने में उपयोगी।
- [**waymore**](https://github.com/xnl-h4ck3r/waymore)**:** wayback machine से links खोजें (wayback में responses डाउनलोड करना और वहाँ और links खोजना भी)।
- [**HTTPLoot**](https://github.com/redhuntlabs/HTTPLoot) (go): Crawl (forms भरकर भी) करता है और specific regexes का उपयोग करके sensitive info भी ढूँढता है।
- [**SpiderSuite**](https://github.com/3nock/SpiderSuite): Spider Suite एक एडवांस multi-feature GUI web security Crawler/Spider है जिसे cyber security professionals के लिए डिज़ाइन किया गया है।
- [**jsluice**](https://github.com/BishopFox/jsluice) (go): यह एक Go package और [command-line tool](https://github.com/BishopFox/jsluice/blob/main/cmd/jsluice) है जो JavaScript source code से URLs, paths, secrets, और अन्य दिलचस्प डेटा निकालता है।
- [**ParaForge**](https://github.com/Anof-cyber/ParaForge): ParaForge एक simple **Burp Suite extension** है जो request से **paramters और endpoints extract** करके fuzzing और enumeration के लिए custom wordlist बनाता है।
- [**katana**](https://github.com/projectdiscovery/katana) (go): इस काम के लिए एक शानदार टूल।
- [**Crawley**](https://github.com/s0rg/crawley) (go): पाए गए हर link को प्रिंट करता है।

### Brute Force directories and files

root फ़ोल्डर से **brute-forcing** शुरू करें और सुनिश्चित करें कि आपने इस **method** से पाए गए सभी **directories** और Spidering द्वारा **discovered** किए गए सभी directories पर भी brute-force किया है (आप इसे **recursively** कर सकते हैं और उपयोग की गई wordlist के शुरुआत में पाए गए directories के नाम जोड़ सकते हैं)।\
Tools:

- **Dirb** / **Dirbuster** - Kali में शामिल, **पुराना** (और **धीमा**) पर कार्यक्षम। auto-signed certificates और recursive search की अनुमति देता है। बाकी विकल्पों की तुलना में बहुत slow।
- [**Dirsearch**](https://github.com/maurosoria/dirsearch) (python)**: यह auto-signed certificates की अनुमति नहीं देता पर** recursive search की अनुमति देता है।
- [**Gobuster**](https://github.com/OJ/gobuster) (go): यह auto-signed certificates की अनुमति देता है, इसमें **recursive** search नहीं है।
- [**Feroxbuster**](https://github.com/epi052/feroxbuster) **- Fast, supports recursive search.**
- [**wfuzz**](https://github.com/xmendez/wfuzz) `wfuzz -w /usr/share/seclists/Discovery/Web-Content/raft-medium-directories.txt https://domain.com/api/FUZZ`
- [**ffuf** ](https://github.com/ffuf/ffuf)- Fast: `ffuf -c -w /usr/share/wordlists/dirb/big.txt -u http://10.10.10.10/FUZZ`
- [**uro**](https://github.com/s0md3v/uro) (python): यह spider नहीं है पर एक टूल है जो पाए गए URLs की सूची देकर "duplicated" URLs हटा देता है।
- [**Scavenger**](https://github.com/0xDexter0us/Scavenger): Burp Extension जो burp history से directories की सूची बनाता है।
- [**TrashCompactor**](https://github.com/michael1026/trashcompactor): js imports के आधार पर duplicated functionalities वाले URLs हटाता है।
- [**Chamaleon**](https://github.com/iustin24/chameleon): यह wapalyzer का उपयोग करके उपयोग की गई technologies का पता लगाता और तय करता है कि किन wordlists का उपयोग किया जाए।

**Recommended dictionaries:**

- [https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/bf_directories.txt](https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/bf_directories.txt)
- [**Dirsearch** included dictionary](https://github.com/maurosoria/dirsearch/blob/master/db/dicc.txt)
- [http://gist.github.com/jhaddix/b80ea67d85c13206125806f0828f4d10](http://gist.github.com/jhaddix/b80ea67d85c13206125806f0828f4d10)
- [Assetnote wordlists](https://wordlists.assetnote.io)
- [https://github.com/danielmiessler/SecLists/tree/master/Discovery/Web-Content](https://github.com/danielmiessler/SecLists/tree/master/Discovery/Web-Content)
- raft-large-directories-lowercase.txt
- directory-list-2.3-medium.txt
- RobotsDisallowed/top10000.txt
- [https://github.com/random-robbie/bruteforce-lists](https://github.com/random-robbie/bruteforce-lists)
- [https://github.com/google/fuzzing/tree/master/dictionaries](https://github.com/google/fuzzing/tree/master/dictionaries)
- [https://github.com/six2dez/OneListForAll](https://github.com/six2dez/OneListForAll)
- [https://github.com/random-robbie/bruteforce-lists](https://github.com/random-robbie/bruteforce-lists)
- [https://github.com/ayoubfathi/leaky-paths](https://github.com/ayoubfathi/leaky-paths)
- _/usr/share/wordlists/dirb/common.txt_
- _/usr/share/wordlists/dirb/big.txt_
- _/usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt_

_ध्यान दें कि जब भी brute-forcing या spidering के दौरान कोई नया directory खोजा जाए, उसे भी Brute-Force किया जाना चाहिए।_

### What to check on each file found

- [**Broken link checker**](https://github.com/stevenvachon/broken-link-checker): HTMLs के अंदर broken links खोजें जो takeover के लिए प्रवण हो सकते हैं।
- **File Backups**: एक बार जब आपने सभी फ़ाइलें ढूँढ लीं, तो सभी executable फ़ाइलों के backups खोजें ("_.php_", "_.aspx_"...). backup नामकरण के सामान्य वेरिएंट हैं: _file.ext\~, #file.ext#, \~file.ext, file.ext.bak, file.ext.tmp, file.ext.old, file.bak, file.tmp और file.old._ आप टूल [**bfac**](https://github.com/mazen160/bfac) **या** [**backup-gen**](https://github.com/Nishantbhagat57/backup-gen) का भी उपयोग कर सकते हैं।
- **Discover new parameters**: आप hidden parameters खोजने के लिए [**Arjun**](https://github.com/s0md3v/Arjun)**,** [**parameth**](https://github.com/maK-/parameth)**,** [**x8**](https://github.com/sh1yo/x8) **और** [**Param Miner**](https://github.com/PortSwigger/param-miner) जैसे tools का उपयोग कर सकते हैं। यदि संभव हो तो प्रत्येक executable web फ़ाइल पर hidden parameters तलाशें।
- _Arjun all default wordlists:_ [https://github.com/s0md3v/Arjun/tree/master/arjun/db](https://github.com/s0md3v/Arjun/tree/master/arjun/db)
- _Param-miner “params” :_ [https://github.com/PortSwigger/param-miner/blob/master/resources/params](https://github.com/PortSwigger/param-miner/blob/master/resources/params)
- _Assetnote “parameters_top_1m”:_ [https://wordlists.assetnote.io/](https://wordlists.assetnote.io)
- _nullenc0de “params.txt”:_ [https://gist.github.com/nullenc0de/9cb36260207924f8e1787279a05eb773](https://gist.github.com/nullenc0de/9cb36260207924f8e1787279a05eb773)
- **Comments:** सभी फ़ाइलों के comments चेक करें, वहाँ से आपको **credentials** या **hidden functionality** मिल सकती है।
- यदि आप **CTF** खेल रहे हैं, तो एक "common" trick यह है कि page के दाईं ओर comments के अंदर जानकारी छुपा दी जाए (सैकड़ों spaces का उपयोग करके ताकि browser में source खोलते समय डेटा दिखाई न दे)। एक और सम्भव तरीका है कई new lines का उपयोग करके page के नीचे comment में जानकारी छुपाना।
- **API keys**: यदि आप कोई API key पाते हैं तो विभिन्न platforms की API keys का उपयोग कैसे करें इसका गाइड मौजूद है: [**keyhacks**](https://github.com/streaak/keyhacks)**,** [**zile**](https://github.com/xyele/zile.git)**,** [**truffleHog**](https://github.com/trufflesecurity/truffleHog)**,** [**SecretFinder**](https://github.com/m4ll0k/SecretFinder)**,** [**RegHex**](<https://github.com/l4yton/RegHex)/>)**,** [**DumpsterDive**](https://github.com/securing/DumpsterDiver)**,** [**EarlyBird**](https://github.com/americanexpress/earlybird)
- Google API keys: यदि आपको कोई API key जो AIza से शुरू होती दिखे (उदा. **AIza**SyA-qLheq6xjDiEIRisP_ujUseYLQCHUjik) तो आप यह जांचने के लिए [**gmapapiscanner**](https://github.com/ozguralp/gmapsapiscanner) प्रोजेक्ट का उपयोग कर सकते हैं कि key किन APIs तक access कर सकती है।
- **S3 Buckets**: spidering के दौरान देखें कि कोई **subdomain** या कोई **link** किसी **S3 bucket** से जुड़ा हुआ है या नहीं। उस स्थिति में, [**check** the **permissions** of the bucket](buckets/index.html).

### Special findings

**spidering** और **brute-forcing** करते समय आपको कुछ **interesting** **things** मिल सकते हैं जिन पर ध्यान देना ज़रूरी है।

**Interesting files**

- CSS फ़ाइलों के अंदर अन्य फ़ाइलों के लिए **links** खोजें।
- [यदि आप _**.git**_ फ़ाइल पाते हैं तो कुछ जानकारी निकाली जा सकती है](git.md)
- यदि आप _**.env**_ पाते हैं तो उसमें api keys, dbs passwords और अन्य जानकारी मिल सकती है।
- यदि आप **API endpoints** पाते हैं तो आपको उन्हें [test भी करना चाहिए](web-api-pentesting.md)। ये फ़ाइलें नहीं हैं, पर अक्सर "फ़ाइलों जैसा" दिखते हैं।
- **JS files**: spidering सेक्शन में कई tools बताए गए थे जो JS फ़ाइलों से path निकाल सकते हैं। इसके अलावा यह रुचिकर होगा कि पाए गए हर JS फ़ाइल पर निगरानी रखें, क्योंकि कुछ मामलों में किसी फ़ाइल में बदलाव यह संकेत दे सकता है कि code में कोई संभावित vulnerability आ गई है। आप उदाहरण के लिए [**JSMon**](https://github.com/robre/jsmon) का उपयोग कर सकते हैं।
- आपको पाए गए JS फ़ाइलों को [**RetireJS**](https://github.com/retirejs/retire.js/) या [**JSHole**](https://github.com/callforpapers-source/jshole) से भी चेक करना चाहिए कि क्या वे vulnerable हैं।
- **Javascript Deobfuscator and Unpacker:** [https://lelinhtinh.github.io/de4js/](https://lelinhtinh.github.io/de4js/), [https://www.dcode.fr/javascript-unobfuscator](https://www.dcode.fr/javascript-unobfuscator)
- **Javascript Beautifier:** [http://jsbeautifier.org/](https://beautifier.io), [http://jsnice.org/](http://jsnice.org)
- **JsFuck deobfuscation** (javascript with chars:"\[]!+" [https://enkhee-osiris.github.io/Decoder-JSFuck/](https://enkhee-osiris.github.io/Decoder-JSFuck/))
- **TrainFuck**](https://github.com/taco-c/trainfuck)**:** `+72.+29.+7..+3.-67.-12.+55.+24.+3.-6.-8.-67.-23.`
- कई मौकों पर आपको उपयोग किए गए regular expressions को समझने की ज़रूरत पड़ेगी। यह उपयोगी होगा: [https://regex101.com/](https://regex101.com) या [https://pythonium.net/regex](https://pythonium.net/regex)
- आप उन फ़ाइलों की निगरानी भी कर सकते हैं जहाँ forms detect हुए थे, क्योंकि किसी parameter में बदलाव या किसी नए form का आना एक संभावित नए vulnerable functionality का संकेत दे सकता है।

**403 Forbidden/Basic Authentication/401 Unauthorized (bypass)**


{{#ref}}
403-and-401-bypasses.md
{{#endref}}

**502 Proxy Error**

यदि कोई पेज उस code के साथ respond करता है, तो संभवतः यह एक badly configured proxy है। **यदि आप एक HTTP request भेजते हैं जैसे: `GET https://google.com HTTP/1.1`** (host header और अन्य सामान्य headers के साथ), तो **proxy** कोशिश करेगा _**google.com**_ **को access करने की और आपने एक** SSRF **ढूँढ लिया होगा।**

**NTLM Authentication - Info disclosure**

यदि running server authentication माँग रहा है और वह **Windows** है या आप कोई login पाते हैं जो आपकी **credentials** माँगता है (और **domain** **name** माँगता है), तो आप एक **information disclosure** provoke कर सकते हैं।\
**Send** यह **header**: `“Authorization: NTLM TlRMTVNTUAABAAAAB4IIAAAAAAAAAAAAAAAAAAAAAAA=”` और NTLM authentication के काम करने के तरीके के कारण, server header "WWW-Authenticate" के अंदर internal info (IIS version, Windows version...) के साथ respond करेगा।\
आप इसे automate करने के लिए **nmap plugin** "_http-ntlm-info.nse_" का उपयोग कर सकते हैं।

**HTTP Redirect (CTF)**

Redirection के अंदर content रखना संभव है। यह content user को दिखाई नहीं देगा (क्योंकि browser redirection execute करेगा) पर कुछ चीज़ें वहाँ छुपी हो सकती हैं।

### Web Vulnerabilities Checking

अब जब web application का व्यापक enumeration पूरा हो गया है, तो अब कई संभावित vulnerabilities की जाँच करने का समय है। आप checklist यहाँ पा सकते हैं:


{{#ref}}
../../pentesting-web/web-vulnerabilities-methodology.md
{{#endref}}

web vulns के बारे में और जानकारी:

- [https://six2dez.gitbook.io/pentest-book/others/web-checklist](https://six2dez.gitbook.io/pentest-book/others/web-checklist)
- [https://kennel209.gitbooks.io/owasp-testing-guide-v4/content/en/web_application_security_testing/configuration_and_deployment_management_testing.html](https://kennel209.gitbooks.io/owasp-testing-guide-v4/content/en/web_application_security_testing/configuration_and_deployment_management_testing.html)
- [https://owasp-skf.gitbook.io/asvs-write-ups/kbid-111-client-side-template-injection](https://owasp-skf.gitbook.io/asvs-write-ups/kbid-111-client-side-template-injection)

### Monitor Pages for changes

आप pages में किए गए modifications की निगरानी के लिए [https://github.com/dgtlmoon/changedetection.io](https://github.com/dgtlmoon/changedetection.io) जैसे tools का उपयोग कर सकते हैं ताकि संभावित vulnerabilities के आने पर पता चल सके।

### HackTricks Automatic Commands
```
Protocol_Name: Web    #Protocol Abbreviation if there is one.
Port_Number:  80,443     #Comma separated if there is more than one.
Protocol_Description: Web         #Protocol Abbreviation Spelled out

Entry_1:
Name: Notes
Description: Notes for Web
Note: |
https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/index.html

Entry_2:
Name: Quick Web Scan
Description: Nikto and GoBuster
Command: nikto -host {Web_Proto}://{IP}:{Web_Port} &&&& gobuster dir -w {Small_Dirlist} -u {Web_Proto}://{IP}:{Web_Port} && gobuster dir -w {Big_Dirlist} -u {Web_Proto}://{IP}:{Web_Port}

Entry_3:
Name: Nikto
Description: Basic Site Info via Nikto
Command: nikto -host {Web_Proto}://{IP}:{Web_Port}

Entry_4:
Name: WhatWeb
Description: General purpose auto scanner
Command: whatweb -a 4 {IP}

Entry_5:
Name: Directory Brute Force Non-Recursive
Description:  Non-Recursive Directory Brute Force
Command: gobuster dir -w {Big_Dirlist} -u {Web_Proto}://{IP}:{Web_Port}

Entry_6:
Name: Directory Brute Force Recursive
Description: Recursive Directory Brute Force
Command: python3 {Tool_Dir}dirsearch/dirsearch.py -w {Small_Dirlist} -e php,exe,sh,py,html,pl -f -t 20 -u {Web_Proto}://{IP}:{Web_Port} -r 10

Entry_7:
Name: Directory Brute Force CGI
Description: Common Gateway Interface Brute Force
Command: gobuster dir -u {Web_Proto}://{IP}:{Web_Port}/ -w /usr/share/seclists/Discovery/Web-Content/CGIs.txt -s 200

Entry_8:
Name: Nmap Web Vuln Scan
Description: Tailored Nmap Scan for web Vulnerabilities
Command: nmap -vv --reason -Pn -sV -p {Web_Port} --script=`banner,(http* or ssl*) and not (brute or broadcast or dos or external or http-slowloris* or fuzzer)` {IP}

Entry_9:
Name: Drupal
Description: Drupal Enumeration Notes
Note: |
git clone https://github.com/immunIT/drupwn.git for low hanging fruit and git clone https://github.com/droope/droopescan.git for deeper enumeration

Entry_10:
Name: WordPress
Description: WordPress Enumeration with WPScan
Command: |
?What is the location of the wp-login.php? Example: /Yeet/cannon/wp-login.php
wpscan --url {Web_Proto}://{IP}{1} --enumerate ap,at,cb,dbe && wpscan --url {Web_Proto}://{IP}{1} --enumerate u,tt,t,vp --passwords {Big_Passwordlist} -e

Entry_11:
Name: WordPress Hydra Brute Force
Description: Need User (admin is default)
Command: hydra -l admin -P {Big_Passwordlist} {IP} -V http-form-post '/wp-login.php:log=^USER^&pwd=^PASS^&wp-submit=Log In&testcookie=1:S=Location'

Entry_12:
Name: Ffuf Vhost
Description: Simple Scan with Ffuf for discovering additional vhosts
Command: ffuf -w {Subdomain_List}:FUZZ -u {Web_Proto}://{Domain_Name} -H "Host:FUZZ.{Domain_Name}" -c -mc all {Ffuf_Filters}
```
{{#include ../../banners/hacktricks-training.md}}
