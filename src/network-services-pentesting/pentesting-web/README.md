# 80,443 - Pentesting Web कार्यप्रणाली

{{#include ../../banners/hacktricks-training.md}}

## बुनियादी जानकारी

web service सबसे अधिक **सामान्य और व्यापक सेवा** है और बहुत सारे **विभिन्न प्रकार के vulnerabilities** मौजूद हैं।

**डिफ़ॉल्ट पोर्ट:** 80 (HTTP), 443(HTTPS)
```bash
PORT    STATE SERVICE
80/tcp  open  http
443/tcp open  ssl/https
```

```bash
nc -v domain.com 80 # GET / HTTP/1.0
openssl s_client -connect domain.com:443 # GET / HTTP/1.0
```
### Web API मार्गदर्शन


{{#ref}}
web-api-pentesting.md
{{#endref}}

## कार्यप्रणाली सारांश

> इस कार्यप्रणाली में हम यह मानकर चलेंगे कि आप किसी domain (या subdomain) पर और केवल उस पर हमला करने जा रहे हैं। इसलिए, आपको इस कार्यप्रणाली को प्रत्येक खोजे गए domain, subdomain या IP जिनके अंदर अनिर्धारित web server हो, के लिए लागू करना चाहिए।

- [ ] Start by **identifying** the **technologies** used by the web server. Look for **tricks** to keep in mind during the rest of the test if you can successfully identify the tech.
- [ ] Any **known vulnerability** of the version of the technology?
- [ ] Using any **well known tech**? Any **useful trick** to extract more information?
- [ ] Any **specialised scanner** to run (like wpscan)?
- [ ] Launch **general purposes scanners**. You never know if they are going to find something or if the are going to find some interesting information.
- [ ] Start with the **initial checks**: **robots**, **sitemap**, **404** error and **SSL/TLS scan** (if HTTPS).
- [ ] Start **spidering** the web page: It's time to **find** all the possible **files, folders** and **parameters being used.** Also, check for **special findings**.
- [ ] _Note that anytime a new directory is discovered during brute-forcing or spidering, it should be spidered._
- [ ] **Directory Brute-Forcing**: Try to brute force all the discovered folders searching for new **files** and **directories**.
- [ ] _Note that anytime a new directory is discovered during brute-forcing or spidering, it should be Brute-Forced._
- [ ] **Backups checking**: Test if you can find **backups** of **discovered files** appending common backup extensions.
- [ ] **Brute-Force parameters**: Try to **find hidden parameters**.
- [ ] Once you have **identified** all the possible **endpoints** accepting **user input**, check for all kind of **vulnerabilities** related to it.
- [ ] [Follow this checklist](../../pentesting-web/web-vulnerabilities-methodology.md)

## Server Version (Vulnerable?)

### पहचान

Check if there are **known vulnerabilities** for the server **version** that is running.\
The **HTTP headers and cookies of the response** could be very useful to **identify** the **technologies** and/or **version** being used. **Nmap scan** can identify the server version, but it could also be useful the tools [**whatweb**](https://github.com/urbanadventurer/WhatWeb)**,** [**webtech** ](https://github.com/ShielderSec/webtech)or [**https://builtwith.com/**](https://builtwith.com)**:**
```bash
whatweb -a 1 <URL> #Stealthy
whatweb -a 3 <URL> #Aggresive
webtech -u <URL>
webanalyze -host https://google.com -crawl 2
```
खोजें **के लिए** [**vulnerabilities of the web application** **version**](../../generic-hacking/search-exploits.md)

### **जाँचें कि कोई WAF है या नहीं**

- [**https://github.com/EnableSecurity/wafw00f**](https://github.com/EnableSecurity/wafw00f)
- [**https://github.com/Ekultek/WhatWaf.git**](https://github.com/Ekultek/WhatWaf.git)
- [**https://nmap.org/nsedoc/scripts/http-waf-detect.html**](https://nmap.org/nsedoc/scripts/http-waf-detect.html)

### वेब टेक ट्रिक्स

किसी भी उपयोग की जा रही विभिन्न प्रसिद्ध तकनीकों में कमजोरियाँ खोजने के लिए कुछ ट्रिक्स:

- [**AEM - Adobe Experience Cloud**](aem-adobe-experience-cloud.md)
- [**Apache**](apache.md)
- [**Artifactory**](artifactory-hacking-guide.md)
- [**Buckets**](buckets/index.html)
- [**CGI**](cgi.md)
- [**Custom UDP RPC Protocols**](custom-protocols.md)
- [**Dotnet SOAP WSDL client exploitation**](dotnet-soap-wsdl-client-exploitation.md)
- [**Drupal**](drupal/index.html)
- [**Flask**](flask.md)
- [**Fortinet FortiWeb**](fortinet-fortiweb.md)
- [**Git**](git.md)
- [**Golang**](golang.md)
- [**GraphQL**](graphql.md)
- [**H2 - Java SQL database**](h2-java-sql-database.md)
- [**ISPConfig**](ispconfig.md)
- [**IIS tricks**](iis-internet-information-services.md)
- [**Microsoft SharePoint**](microsoft-sharepoint.md)
- [**JBOSS**](jboss.md)
- [**Jenkins**](https://github.com/HackTricks-wiki/hacktricks-cloud/tree/master/pentesting-ci-cd/jenkins-security)
- [**Jira**](jira.md)
- [**Joomla**](joomla.md)
- [**JSP**](jsp.md)
- [**Laravel**](laravel.md)
- [**Moodle**](moodle.md)
- [**Nginx**](nginx.md)
- [**PHP (php has a lot of interesting tricks that could be exploited)**](php-tricks-esp/index.html)
- [**Python**](python.md)
- [**Roundcube**](roundcube.md)
- [**Spring Actuators**](spring-actuators.md)
- [**Symphony**](symphony.md)
- [**Tomcat**](tomcat/index.html)
- [**VMWare**](vmware-esx-vcenter....md)
- [**Web API Pentesting**](web-api-pentesting.md)
- [**WebDav**](put-method-webdav.md)
- [**Werkzeug**](werkzeug.md)
- [**Wordpress**](wordpress.md)
- [**Electron Desktop (XSS to RCE)**](electron-desktop-apps/index.html)
- [**Sitecore**](sitecore/index.html)
- [**Zabbix**](zabbix.md)

_ध्यान रखें कि **एक ही डोमेन** विभिन्न **प्रौद्योगिकियों** का उपयोग अलग-अलग **पोर्ट्स**, **फ़ोल्डर्स** और **सबडोमेन्स** में कर सकता है._\
यदि वेब एप्लिकेशन कोई भी पहले सूचीबद्ध **tech/platform** या कोई अन्य उपयोग कर रहा है, तो इंटरनेट पर नए ट्रिक्स खोजना न भूलें (और मुझे बताएं!)।

### Source Code Review

यदि एप्लिकेशन का स्रोत कोड github पर उपलब्ध है, तो अपने द्वारा White box test करने के अलावा कुछ ऐसी जानकारी हो सकती है जो वर्तमान Black-Box testing के लिए उपयोगी हो सकती है:

- क्या कोई **Change-log or Readme or Version** फ़ाइल है या वेब के माध्यम से कोई **version info** उपलब्ध है?
- credentials कैसे और कहाँ सेव किए गए हैं? क्या कोई (पहुँच योग्य?) फ़ाइल है जिसमें credentials (usernames या passwords) हैं?
- क्या passwords plain text में हैं, encrypted हैं या किस hashing algorithm का उपयोग किया गया है?
- क्या कोई master key किसी चीज़ को encrypt करने के लिए उपयोग हो रहा है? कौन सा algorithm उपयोग किया गया है?
- क्या आप किसी vulnerability का फायदा उठाकर इन फ़ाइलों में से किसी तक पहुँच सकते हैं?
- क्या github में (solve हुए और अनसुल्व्ड) issues में कोई दिलचस्प जानकारी है? या commit history में (शायद किसी पुराने commit में कोई password शामिल हो) कुछ मिला है?

{{#ref}}
code-review-tools.md
{{#endref}}

### Automatic scanners

#### General purpose automatic scanners
```bash
nikto -h <URL>
whatweb -a 4 <URL>
wapiti -u <URL>
W3af
zaproxy #You can use an API
nuclei -ut && nuclei -target <URL>

# https://github.com/ignis-sec/puff (client side vulns fuzzer)
node puff.js -w ./wordlist-examples/xss.txt -u "http://www.xssgame.com/f/m4KKGHi2rVUN/?query=FUZZ"
```
#### CMS स्कैनर

यदि कोई CMS उपयोग में है तो **run a scanner** करना न भूलें, शायद कुछ दिलचस्प मिल जाए:

[**Clusterd**](https://github.com/hatRiot/clusterd)**:** [**JBoss**](jboss.md)**, ColdFusion, WebLogic,** [**Tomcat**](tomcat/index.html)**, Railo, Axis2, Glassfish**\
[**CMSScan**](https://github.com/ajinabraham/CMSScan): [**WordPress**](wordpress.md), [**Drupal**](drupal/index.html), **Joomla**, **vBulletin** वेबसाइटों में सुरक्षा समस्याओं के लिए। (GUI)\  
[**VulnX**](https://github.com/anouarbensaad/vulnx)**:** [**Joomla**](joomla.md)**,** [**Wordpress**](wordpress.md)**,** [**Drupal**](drupal/index.html)**, PrestaShop, Opencart**\
**CMSMap**: [**(W)ordpress**](wordpress.md)**,** [**(J)oomla**](joomla.md)**,** [**(D)rupal**](drupal/index.html) **or** [**(M)oodle**](moodle.md)\
[**droopscan**](https://github.com/droope/droopescan)**:** [**Drupal**](drupal/index.html)**,** [**Joomla**](joomla.md)**,** [**Moodle**](moodle.md)**, Silverstripe,** [**Wordpress**](wordpress.md)
```bash
cmsmap [-f W] -F -d <URL>
wpscan --force update -e --url <URL>
joomscan --ec -u <URL>
joomlavs.rb #https://github.com/rastating/joomlavs
```
> इस स्तर पर आपके पास पहले से ही क्लाइंट द्वारा उपयोग किए जा रहे वेब सर्वर के बारे में कुछ जानकारी होनी चाहिए (यदि कोई डेटा दिया गया है) और टेस्ट के दौरान ध्यान में रखने के लिए कुछ ट्रिक्स। अगर आप भाग्यशाली हैं तो आपने एक CMS भी पाया होगा और कुछ scanner चला रखा होगा।

## Step-by-step Web Application Discovery

> इस बिंदु से हम वेब एप्लिकेशन के साथ इंटरैक्ट करना शुरू करने जा रहे हैं।

### Initial checks

**Default pages with interesting info:**

- /robots.txt
- /sitemap.xml
- /crossdomain.xml
- /clientaccesspolicy.xml
- /.well-known/
- मुख्य और द्वितीयक पृष्ठों में भी comments चेक करें।

**Forcing errors**

वेब सर्वर तब **अनपेक्षित व्यवहार** कर सकते हैं जब उन्हें अजीब डेटा भेजा जाता है। इससे **vulnerabilities** खुल सकती हैं या **संवेदनशील जानकारी का disclosure** हो सकता है।

- /whatever_fake.php (.aspx,.html,.etc) जैसे **fake pages** को एक्सेस करें
- एरर पैदा करने के लिए **cookie values** और **parameter** values में **"[]", "]]", और "[["** जोड़ें
- **`/~randomthing/%s`** को URL के **अंत** में देकर error जेनरेट करें
- PATCH, DEBUG जैसे विभिन्न HTTP Verbs आज़माएँ या FAKE जैसे गलत verbs भी आज़माएँ

#### **चेक करें कि आप फ़ाइलें अपलोड कर सकते हैं (**[**PUT verb, WebDav**](put-method-webdav.md)**)**

यदि आपको पता चलता है कि **WebDav** **enabled** है पर root फ़ोल्डर में **uploading files** के लिए पर्याप्त permissions नहीं हैं तो कोशिश करें:

- **Brute Force** credentials
- WebDav के माध्यम से वेब पेज के अंदर मिले अन्य फ़ोल्डर्स (rest of found folders) में **Upload files** करें। हो सकता है कि अन्य फ़ोल्डरों में फ़ाइलें अपलोड करने की permissions मिल जाएँ।

### **SSL/TLS vulnerabilites**

- अगर ऐप्लिकेशन किसी भी हिस्से में **HTTPS उपयोग करने के लिए मजबूर** नहीं कर रहा है, तो यह **MitM के लिए vulnerable** है
- अगर ऐप्लिकेशन **HTTP का उपयोग करके sensitive data (passwords) भेज रहा है** तो यह एक गंभीर vulnerability है।

Use [**testssl.sh**](https://github.com/drwetter/testssl.sh) को **vulnerabilities** की जांच करने के लिए इस्तेमाल करें (Bug Bounty प्रोग्राम्स में शायद इस तरह की vulnerabilities को स्वीकार नहीं किया जाएगा) और vulnerabilities को फिर से चेक करने के लिए [**a2sv** ](https://github.com/hahwul/a2sv) का उपयोग करें:
```bash
./testssl.sh [--htmlfile] 10.10.10.10:443
#Use the --htmlfile to save the output inside an htmlfile also

# You can also use other tools, by testssl.sh at this momment is the best one (I think)
sslscan <host:port>
sslyze --regular <ip:port>
```
Information about SSL/TLS vulnerabilities:

- [https://www.gracefulsecurity.com/tls-ssl-vulnerabilities/](https://www.gracefulsecurity.com/tls-ssl-vulnerabilities/)
- [https://www.acunetix.com/blog/articles/tls-vulnerabilities-attacks-final-part/](https://www.acunetix.com/blog/articles/tls-vulnerabilities-attacks-final-part/)

### Spidering

वेब के अंदर किसी प्रकार का **spider** लॉन्च करें। spider का उद्देश्य टेस्ट किए जा रहे एप्लिकेशन से जितने संभव हो उतने **paths ढूँढना** है। इसलिए, web crawling और बाहरी स्रोतों का उपयोग करके जितने भी वैध paths मिल सकें उन्हें खोजा जाना चाहिए।

- [**gospider**](https://github.com/jaeles-project/gospider) (go): HTML spider, JS फ़ाइलों में LinkFinder और बाहरी स्रोतों (Archive.org, CommonCrawl.org, VirusTotal.com) में खोज।
- [**hakrawler**](https://github.com/hakluke/hakrawler) (go): HTML spider, JS फ़ाइलों के लिए LinkFinder और Archive.org को बाहरी स्रोत के रूप में इस्तेमाल करता है।
- [**dirhunt**](https://github.com/Nekmo/dirhunt) (python): HTML spider, साथ ही "juicy files" को इंगित करता है।
- [**evine** ](https://github.com/saeeddhqan/evine)(go): Interactive CLI HTML spider। यह भी Archive.org में खोज करता है।
- [**meg**](https://github.com/tomnomnom/meg) (go): यह टूल spider नहीं है पर उपयोगी हो सकता है। आप hosts की फ़ाइल और paths की फ़ाइल दे सकते हैं और meg हर host पर हर path को fetch करके response सेव करेगा।
- [**urlgrab**](https://github.com/IAmStoxe/urlgrab) (go): JS rendering क्षमताओं के साथ HTML spider। हालांकि, ऐसा प्रतीत होता है कि यह unmaintained है, precompiled version पुराना है और वर्तमान कोड compile नहीं होता।
- [**gau**](https://github.com/lc/gau) (go): बाहरी providers (wayback, otx, commoncrawl) का उपयोग करने वाला HTML spider।
- [**ParamSpider**](https://github.com/devanshbatham/ParamSpider): यह स्क्रिप्ट parameter वाले URLs ढूँढेगी और उन्हें सूचीबद्ध करेगी।
- [**galer**](https://github.com/dwisiswant0/galer) (go): JS rendering क्षमताओं के साथ HTML spider।
- [**LinkFinder**](https://github.com/GerbenJavado/LinkFinder) (python): HTML spider, JS beautify क्षमताओं के साथ जो JS फ़ाइलों में नए paths खोजने में सक्षम है। इसके wrapper [JSScanner](https://github.com/dark-warlord14/JSScanner) पर भी नजर डालना उपयोगी हो सकता है।
- [**goLinkFinder**](https://github.com/0xsha/GoLinkFinder) (go): HTML source और embedded javascript फ़ाइलों दोनों में endpoints extract करने के लिए। bug hunters, red teamers, infosec ninjas के लिए उपयोगी।
- [**JSParser**](https://github.com/nahamsec/JSParser) (python2.7): Tornado और JSBeautifier इस्तेमाल करके JavaScript फ़ाइलों से relative URLs parse करने वाला python 2.7 स्क्रिप्ट। AJAX requests खोजने में उपयोगी। लगता है unmaintained है।
- [**relative-url-extractor**](https://github.com/jobertabma/relative-url-extractor) (ruby): किसी HTML फ़ाइल दी जाए तो यह निफ्टी regular expression का उपयोग करके ugly (minify) फ़ाइलों से relative URLs extract करेगा।
- [**JSFScan**](https://github.com/KathanP19/JSFScan.sh) (bash, several tools): कई टूल्स का उपयोग करके JS फ़ाइलों से रोचक जानकारी इकट्ठा करता है।
- [**subjs**](https://github.com/lc/subjs) (go): JS फ़ाइलें ढूँढता है।
- [**page-fetch**](https://github.com/detectify/page-fetch) (go): headless browser में एक पेज लोड करता है और पेज लोड करने के लिए लोड हुए सभी urls प्रिंट करता है।
- [**Feroxbuster**](https://github.com/epi052/feroxbuster) (rust): Content discovery tool जो पिछले कई विकल्पों को मिलाता है।
- [**Javascript Parsing**](https://github.com/xnl-h4ck3r/burp-extensions): JS फ़ाइलों में path और params खोजने के लिए Burp extension।
- [**Sourcemapper**](https://github.com/denandz/sourcemapper): एक टूल जो दिए गए .js.map URL से beautified JS को प्राप्त कर देता है।
- [**xnLinkFinder**](https://github.com/xnl-h4ck3r/xnLinkFinder): किसी target के endpoints खोजने के लिए उपयोगी टूल।
- [**waymore**](https://github.com/xnl-h4ck3r/waymore)**:** wayback machine से links खोजे (wayback में responses डाउनलोड करके और और links खोजकर)।
- [**HTTPLoot**](https://github.com/redhuntlabs/HTTPLoot) (go): Crawl करता है (यहाँ तक कि forms भरकर भी) और विशिष्ट regexes का उपयोग करके sensitive info भी खोजता है।
- [**SpiderSuite**](https://github.com/3nock/SpiderSuite): Spider Suite एक advanced multi-feature GUI web security Crawler/Spider है जो cyber security professionals के लिए डिज़ाइन किया गया है।
- [**jsluice**](https://github.com/BishopFox/jsluice) (go): Go package और [command-line tool](https://github.com/BishopFox/jsluice/blob/main/cmd/jsluice) जो JavaScript source code से URLs, paths, secrets और अन्य रोचक डेटा extract करता है।
- [**ParaForge**](https://github.com/Anof-cyber/ParaForge): ParaForge एक साधारण **Burp Suite extension** है जो request से parameters और endpoints extract करके fuzzing और enumeration के लिए custom wordlist बनाता है।
- [**katana**](https://github.com/projectdiscovery/katana) (go): इस काम के लिए एक शानदार टूल।
- [**Crawley**](https://github.com/s0rg/crawley) (go): यह जितने भी links पा सकता है उन सबको प्रिंट करता है।

### Brute Force directories and files

रूट फ़ोल्डर से **brute-forcing** शुरू करें और सुनिश्चित करें कि आप इस **method** से पाए गए सभी directories और **Spidering** द्वारा खोजे गए सभी directories के ऊपर भी brute-force करें (आप यह brute-forcing **recursively** कर सकते हैं और इस्तेमाल किए गए wordlist की शुरुआत में मिले हुए directories के नाम जोड़ सकते हैं)।\
Tools:

- **Dirb** / **Dirbuster** - Kali में शामिल, **old** (और **slow**) पर functional। auto-signed certificates और recursive search की अनुमति देता है। अन्य विकल्पों की तुलना में बहुत slow।
- [**Dirsearch**](https://github.com/maurosoria/dirsearch) (python)**: यह auto-signed certificates की अनुमति नहीं देता पर recursive search की अनुमति देता है।
- [**Gobuster**](https://github.com/OJ/gobuster) (go): यह auto-signed certificates की अनुमति देता है, इसमें **recursive** search नहीं है।
- [**Feroxbuster**](https://github.com/epi052/feroxbuster) **- Fast, supports recursive search.**
- [**wfuzz**](https://github.com/xmendez/wfuzz) `wfuzz -w /usr/share/seclists/Discovery/Web-Content/raft-medium-directories.txt https://domain.com/api/FUZZ`
- [**ffuf** ](https://github.com/ffuf/ffuf)- Fast: `ffuf -c -w /usr/share/wordlists/dirb/big.txt -u http://10.10.10.10/FUZZ`
- [**uro**](https://github.com/s0md3v/uro) (python): यह spider नहीं है पर एक ऐसा टूल है जो पाए गए URLs की सूची देकर "duplicated" URLs को हटाता है।
- [**Scavenger**](https://github.com/0xDexter0us/Scavenger): Burp Extension जो burp history से विभिन्न पृष्ठों के directories की सूची बनाता है।
- [**TrashCompactor**](https://github.com/michael1026/trashcompactor): js imports के आधार पर duplicated functionalities वाले URLs को हटाता है।
- [**Chamaleon**](https://github.com/iustin24/chameleon): यह wapalyzer का उपयोग करके उपयोग की गई technologies detect करता है और इस्तेमाल करने के लिए wordlists चुनता है।

**Recommended dictionaries:**

- [https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/bf_directories.txt](https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/bf_directories.txt)
- [**Dirsearch** included dictionary](https://github.com/maurosoria/dirsearch/blob/master/db/dicc.txt)
- [http://gist.github.com/jhaddix/b80ea67d85c13206125806f0828f4d10](http://gist.github.com/jhaddix/b80ea67d85c13206125806f0828f4d10)
- [Assetnote wordlists](https://wordlists.assetnote.io)
- [https://github.com/danielmiessler/SecLists/tree/master/Discovery/Web-Content](https://github.com/danielmiessler/SecLists/tree/master/Discovery/Web-Content)
- raft-large-directories-lowercase.txt
- directory-list-2.3-medium.txt
- RobotsDisallowed/top10000.txt
- [https://github.com/random-robbie/bruteforce-lists](https://github.com/random-robbie/bruteforce-lists)
- [https://github.com/google/fuzzing/tree/master/dictionaries](https://github.com/google/fuzzing/tree/master/dictionaries)
- [https://github.com/six2dez/OneListForAll](https://github.com/six2dez/OneListForAll)
- [https://github.com/random-robbie/bruteforce-lists](https://github.com/random-robbie/bruteforce-lists)
- [https://github.com/ayoubfathi/leaky-paths](https://github.com/ayoubfathi/leaky-paths)
- _/usr/share/wordlists/dirb/common.txt_
- _/usr/share/wordlists/dirb/big.txt_
- _/usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt_

_ध्यान दें कि जब भी कोई नया directory brute-forcing या spidering के दौरान खोजा जाता है, उसे Brute-Force किया जाना चाहिए।_

### What to check on each file found

- [**Broken link checker**](https://github.com/stevenvachon/broken-link-checker): HTMLs के अंदर broken links ढूँढें जो takeover के लिए प्रवण हो सकते हैं।
- **File Backups**: एक बार जब आप सभी फ़ाइलें ढूँढ लें, तो सभी executable फ़ाइलों के backups की तलाश करें ("_.php_", "_.aspx_"...). backup नामकरण के सामान्य रूप हो सकते हैं: _file.ext\~, #file.ext#, \~file.ext, file.ext.bak, file.ext.tmp, file.ext.old, file.bak, file.tmp और file.old._ आप टूल [**bfac**](https://github.com/mazen160/bfac) **या** [**backup-gen**](https://github.com/Nishantbhagat57/backup-gen) का उपयोग भी कर सकते हैं।
- **Discover new parameters**: आप hidden parameters खोजने के लिए [**Arjun**](https://github.com/s0md3v/Arjun), [**parameth**](https://github.com/maK-/parameth), [**x8**](https://github.com/sh1yo/x8) और [**Param Miner**](https://github.com/PortSwigger/param-miner) जैसे टूल्स का उपयोग कर सकते हैं। यदि संभव हो तो हर executable web फ़ाइल पर hidden parameters खोजने की कोशिश करें।
- _Arjun all default wordlists:_ [https://github.com/s0md3v/Arjun/tree/master/arjun/db](https://github.com/s0md3v/Arjun/tree/master/arjun/db)
- _Param-miner “params” :_ [https://github.com/PortSwigger/param-miner/blob/master/resources/params](https://github.com/PortSwigger/param-miner/blob/master/resources/params)
- _Assetnote “parameters_top_1m”:_ [https://wordlists.assetnote.io/](https://wordlists.assetnote.io)
- _nullenc0de “params.txt”:_ [https://gist.github.com/nullenc0de/9cb36260207924f8e1787279a05eb773](https://gist.github.com/nullenc0de/9cb36260207924f8e1787279a05eb773)
- **Comments:** सभी फ़ाइलों की comments की जाँच करें, आपको वहाँ **credentials** या **hidden functionality** मिल सकती है।
- यदि आप **CTF** खेल रहे हैं, तो एक "common" trick यह है कि पेज के source में comments के दाहिने हिस्से में जानकारी **छुपा** दी जाए (सैंकड़ों spaces का उपयोग करके ताकि ब्राउज़र के source view में दिखे नहीं)। एक अन्य संभावना कई new lines का उपयोग करके पेज के नीचे comment में जानकारी छुपाना है।
- **API keys**: यदि आप किसी API key को पाते हैं तो विभिन्न प्लेटफ़ॉर्म्स के API keys का उपयोग कैसे करें इस बारे में मार्गदर्शक हैं: [**keyhacks**](https://github.com/streaak/keyhacks), [**zile**](https://github.com/xyele/zile.git), [**truffleHog**](https://github.com/trufflesecurity/truffleHog), [**SecretFinder**](https://github.com/m4ll0k/SecretFinder), [**RegHex**](https://github.com/l4yton/RegHex), [**DumpsterDive**](https://github.com/securing/DumpsterDiver), [**EarlyBird**](https://github.com/americanexpress/earlybird)
- Google API keys: यदि आपको कोई API key मिलती है जो **AIza** से शुरू होती दिखे (उदा. **AIza**SyA-qLheq6xjDiEIRisP_ujUseYLQCHUjik) तो आप यह जांचने के लिए [**gmapapiscanner**](https://github.com/ozguralp/gmapsapiscanner) प्रोजेक्ट का उपयोग कर सकते हैं कि key किन APIs तक access कर सकती है।
- **S3 Buckets**: Spidering के दौरान देखें कि क्या कोई **subdomain** या कोई **link** किसी **S3 bucket** से संबंधित है। ऐसी स्थिति में, [**check** the **permissions** of the bucket](buckets/index.html).

### Special findings

**Spidering** और **brute-forcing** करते समय आप कुछ **interesting** चीज़ें पा सकते हैं जिनका आपको **ध्यान** रखना चाहिए।

**Interesting files**

- CSS फ़ाइलों के अंदर अन्य फ़ाइलों के **links** की तलाश करें।
- [If you find a _**.git**_ file some information can be extracted](git.md)
- यदि आपको _**.env**_ मिलती है तो उसमें API keys, DB passwords और अन्य जानकारी मिल सकती है।
- यदि आप **API endpoints** पाते हैं तो आपको उन्हें भी [test करना चाहिए](web-api-pentesting.md)। ये फ़ाइलें नहीं हैं, पर अक्सर फ़ाइल जैसी दिखाई देंगी।
- **JS files**: spidering सेक्शन में कई टूल्स बताए गए थे जो JS फ़ाइलों से path extract कर सकते हैं। इसके अलावा, यह उपयोगी होगा कि आप प्रत्येक मिले JS फ़ाइल की निगरानी करें, क्योंकि कुछ मामलों में फ़ाइल में बदलाव एक संभावित vulnerability के परिचय का संकेत दे सकता है। आप उदाहरण के लिए [**JSMon**](https://github.com/robre/jsmon) का उपयोग कर सकते हैं।
- आपको खोजी गई JS फ़ाइलों को [**RetireJS**](https://github.com/retirejs/retire.js/) या [**JSHole**](https://github.com/callforpapers-source/jshole) से भी चेक करना चाहिए ताकि यह पता चल सके कि वे vulnerable हैं या नहीं।
- **Javascript Deobfuscator and Unpacker:** [https://lelinhtinh.github.io/de4js/](https://lelinhtinh.github.io/de4js/), [https://www.dcode.fr/javascript-unobfuscator](https://www.dcode.fr/javascript-unobfuscator)
- **Javascript Beautifier:** [http://jsbeautifier.org/](https://beautifier.io), [http://jsnice.org/](http://jsnice.org)
- **JsFuck deobfuscation** (javascript with chars:"\[]!+" [https://enkhee-osiris.github.io/Decoder-JSFuck/](https://enkhee-osiris.github.io/Decoder-JSFuck/))
- [**TrainFuck**](https://github.com/taco-c/trainfuck)**:** `+72.+29.+7..+3.-67.-12.+55.+24.+3.-6.-8.-67.-23.`
- कई मौकों पर, आपको उपयोग किए गए regular expressions को समझने की ज़रूरत पड़ेगी। यह उपयोगी होगा: [https://regex101.com/](https://regex101.com) या [https://pythonium.net/regex](https://pythonium.net/regex)
- आप उन फाइलों की निगरानी भी कर सकते हैं जहाँ forms detect हुए थे, क्योंकि किसी parameter में बदलाव या नए form की उपस्थिति एक संभावित नए vulnerable functionality का संकेत दे सकती है।

**403 Forbidden/Basic Authentication/401 Unauthorized (bypass)**


{{#ref}}
403-and-401-bypasses.md
{{#endref}}

**502 Proxy Error**

यदि किसी पेज का response उस code के साथ आता है, तो संभवतः proxy की गलत configuration है। **यदि आप एक HTTP request भेजते हैं जैसे: `GET https://google.com HTTP/1.1`** (host header और अन्य common headers के साथ), तो proxy _**google.com**_ तक पहुंचने की कोशिश करेगा और आप एक SSRF ढूँढ लेंगे।

**NTLM Authentication - Info disclosure**

यदि running server authentication मांग रहा है और वह **Windows** है या आप किसी ऐसे login पेज को पाते हैं जो आपके **credentials** के साथ **domain** नाम भी मांगता है, तो आप **information disclosure** provoke कर सकते हैं।\
**Send** the **header**: `“Authorization: NTLM TlRMTVNTUAABAAAAB4IIAAAAAAAAAAAAAAAAAAAAAAA=”` और NTLM authentication के काम करने के तरीके के कारण, server header "WWW-Authenticate" के अंदर internal info (IIS version, Windows version...) के साथ प्रतिक्रिया देगा।\
आप इसे automate करने के लिए **nmap plugin** "_http-ntlm-info.nse_" का उपयोग कर सकते हैं।

**HTTP Redirect (CTF)**

Redirection के अंदर content रख पाना संभव है। यह content user को दिखेगा नहीं (क्योंकि browser redirection execute कर देगा) पर कुछ चीज़ें वहाँ छुपी हो सकती हैं।

### Web Vulnerabilities Checking

अब जब web application का व्यापक enumeration हो चुका है, तो कई संभावित vulnerabilities की जाँच करने का समय है। आप checklist यहाँ पा सकते हैं:


{{#ref}}
../../pentesting-web/web-vulnerabilities-methodology.md
{{#endref}}

web vulns के बारे में और जानकारी:

- [https://six2dez.gitbook.io/pentest-book/others/web-checklist](https://six2dez.gitbook.io/pentest-book/others/web-checklist)
- [https://kennel209.gitbooks.io/owasp-testing-guide-v4/content/en/web_application_security_testing/configuration_and_deployment_management_testing.html](https://kennel209.gitbooks.io/owasp-testing-guide-v4/content/en/web_application_security_testing/configuration_and_deployment_management_testing.html)
- [https://owasp-skf.gitbook.io/asvs-write-ups/kbid-111-client-side-template-injection](https://owasp-skf.gitbook.io/asvs-write-ups/kbid-111-client-side-template-injection)

### Monitor Pages for changes

आप pages में हुए परिवर्तन जो vulnerabilities जोड़ सकते हैं, उनका मॉनिटरिंग करने के लिए [https://github.com/dgtlmoon/changedetection.io](https://github.com/dgtlmoon/changedetection.io) जैसे टूल्स का उपयोग कर सकते हैं।

### HackTricks Automatic Commands

<details>
<summary>HackTricks Automatic Commands</summary>
```yaml
Protocol_Name: Web    #Protocol Abbreviation if there is one.
Port_Number:  80,443     #Comma separated if there is more than one.
Protocol_Description: Web         #Protocol Abbreviation Spelled out

Entry_1:
Name: Notes
Description: Notes for Web
Note: |
https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/index.html

Entry_2:
Name: Quick Web Scan
Description: Nikto and GoBuster
Command: nikto -host {Web_Proto}://{IP}:{Web_Port} &&&& gobuster dir -w {Small_Dirlist} -u {Web_Proto}://{IP}:{Web_Port} && gobuster dir -w {Big_Dirlist} -u {Web_Proto}://{IP}:{Web_Port}

Entry_3:
Name: Nikto
Description: Basic Site Info via Nikto
Command: nikto -host {Web_Proto}://{IP}:{Web_Port}

Entry_4:
Name: WhatWeb
Description: General purpose auto scanner
Command: whatweb -a 4 {IP}

Entry_5:
Name: Directory Brute Force Non-Recursive
Description:  Non-Recursive Directory Brute Force
Command: gobuster dir -w {Big_Dirlist} -u {Web_Proto}://{IP}:{Web_Port}

Entry_6:
Name: Directory Brute Force Recursive
Description: Recursive Directory Brute Force
Command: python3 {Tool_Dir}dirsearch/dirsearch.py -w {Small_Dirlist} -e php,exe,sh,py,html,pl -f -t 20 -u {Web_Proto}://{IP}:{Web_Port} -r 10

Entry_7:
Name: Directory Brute Force CGI
Description: Common Gateway Interface Brute Force
Command: gobuster dir -u {Web_Proto}://{IP}:{Web_Port}/ -w /usr/share/seclists/Discovery/Web-Content/CGIs.txt -s 200

Entry_8:
Name: Nmap Web Vuln Scan
Description: Tailored Nmap Scan for web Vulnerabilities
Command: nmap -vv --reason -Pn -sV -p {Web_Port} --script=`banner,(http* or ssl*) and not (brute or broadcast or dos or external or http-slowloris* or fuzzer)` {IP}

Entry_9:
Name: Drupal
Description: Drupal Enumeration Notes
Note: |
git clone https://github.com/immunIT/drupwn.git for low hanging fruit and git clone https://github.com/droope/droopescan.git for deeper enumeration

Entry_10:
Name: WordPress
Description: WordPress Enumeration with WPScan
Command: |
?What is the location of the wp-login.php? Example: /Yeet/cannon/wp-login.php
wpscan --url {Web_Proto}://{IP}{1} --enumerate ap,at,cb,dbe && wpscan --url {Web_Proto}://{IP}{1} --enumerate u,tt,t,vp --passwords {Big_Passwordlist} -e

Entry_11:
Name: WordPress Hydra Brute Force
Description: Need User (admin is default)
Command: hydra -l admin -P {Big_Passwordlist} {IP} -V http-form-post '/wp-login.php:log=^USER^&pwd=^PASS^&wp-submit=Log In&testcookie=1:S=Location'

Entry_12:
Name: Ffuf Vhost
Description: Simple Scan with Ffuf for discovering additional vhosts
Command: ffuf -w {Subdomain_List}:FUZZ -u {Web_Proto}://{Domain_Name} -H "Host:FUZZ.{Domain_Name}" -c -mc all {Ffuf_Filters}
```
</details>

{{#include ../../banners/hacktricks-training.md}}
