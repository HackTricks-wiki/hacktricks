# 80,443 - Pentesting Web Methodology

{{#include ../../banners/hacktricks-training.md}}

<figure><img src="../../images/pentest-tools.svg" alt=""><figcaption></figcaption></figure>

**Erhalten Sie die Perspektive eines Hackers auf Ihre Webanwendungen, Ihr Netzwerk und die Cloud**

**Finden und melden Sie kritische, ausnutzbare Sicherheitsanfälligkeiten mit echtem Geschäftsauswirkungen.** Verwenden Sie unsere 20+ benutzerdefinierten Tools, um die Angriffsfläche zu kartieren, Sicherheitsprobleme zu finden, die Ihnen ermöglichen, Privilegien zu eskalieren, und nutzen Sie automatisierte Exploits, um wesentliche Beweise zu sammeln, und verwandeln Sie Ihre harte Arbeit in überzeugende Berichte.

{% embed url="https://pentest-tools.com/?utm_term=jul2024&utm_medium=link&utm_source=hacktricks&utm_campaign=spons" %}

## Grundlegende Informationen

Der Webdienst ist der **häufigste und umfangreichste Dienst** und es gibt viele **verschiedene Arten von Sicherheitsanfälligkeiten**.

**Standardport:** 80 (HTTP), 443(HTTPS)
```bash
PORT    STATE SERVICE
80/tcp  open  http
443/tcp open  ssl/https
```

```bash
nc -v domain.com 80 # GET / HTTP/1.0
openssl s_client -connect domain.com:443 # GET / HTTP/1.0
```
### Web API Anleitung

{{#ref}}
web-api-pentesting.md
{{#endref}}

## Methodologie Zusammenfassung

> In dieser Methodologie nehmen wir an, dass Sie eine Domain (oder Subdomain) angreifen werden und nur diese. Daher sollten Sie diese Methodologie auf jede entdeckte Domain, Subdomain oder IP mit unbestimmtem Webserver im Geltungsbereich anwenden.

- [ ] Beginnen Sie mit der **Identifizierung** der **Technologien**, die vom Webserver verwendet werden. Achten Sie auf **Tricks**, die Sie während des restlichen Tests im Hinterkopf behalten sollten, wenn Sie die Technik erfolgreich identifizieren können.
- [ ] Gibt es **bekannte Schwachstellen** der Version der Technologie?
- [ ] Verwenden Sie eine **bekannte Technik**? Gibt es einen **nützlichen Trick**, um mehr Informationen zu extrahieren?
- [ ] Gibt es einen **spezialisierten Scanner**, den Sie ausführen können (wie wpscan)?
- [ ] Starten Sie **Allzweck-Scanner**. Sie wissen nie, ob sie etwas finden oder ob sie interessante Informationen entdecken.
- [ ] Beginnen Sie mit den **ersten Überprüfungen**: **robots**, **sitemap**, **404**-Fehler und **SSL/TLS-Scan** (wenn HTTPS).
- [ ] Beginnen Sie mit dem **Spidering** der Webseite: Es ist Zeit, alle möglichen **Dateien, Ordner** und **Parameter zu finden, die verwendet werden.** Überprüfen Sie auch auf **besondere Funde**.
- [ ] _Beachten Sie, dass jedes Mal, wenn ein neues Verzeichnis während des Brute-Forcings oder Spiderings entdeckt wird, es gespidert werden sollte._
- [ ] **Verzeichnis-Brute-Forcing**: Versuchen Sie, alle entdeckten Ordner zu brute-forcen, um nach neuen **Dateien** und **Verzeichnissen** zu suchen.
- [ ] _Beachten Sie, dass jedes Mal, wenn ein neues Verzeichnis während des Brute-Forcings oder Spiderings entdeckt wird, es brute-forced werden sollte._
- [ ] **Überprüfen von Backups**: Testen Sie, ob Sie **Backups** von **entdeckten Dateien** finden können, indem Sie gängige Backup-Erweiterungen anhängen.
- [ ] **Brute-Force-Parameter**: Versuchen Sie, **versteckte Parameter** zu finden.
- [ ] Sobald Sie alle möglichen **Endpunkte**, die **Benutzereingaben** akzeptieren, **identifiziert** haben, überprüfen Sie alle Arten von **Schwachstellen**, die damit verbunden sind.
- [ ] [Befolgen Sie diese Checkliste](../../pentesting-web/web-vulnerabilities-methodology.md)

## Serverversion (anfällig?)

### Identifizieren

Überprüfen Sie, ob es **bekannte Schwachstellen** für die **Version** des Servers gibt, die ausgeführt wird.\
Die **HTTP-Header und Cookies der Antwort** könnten sehr nützlich sein, um die **Technologien** und/oder **Version** zu **identifizieren**, die verwendet werden. Ein **Nmap-Scan** kann die Serverversion identifizieren, aber auch die Tools [**whatweb**](https://github.com/urbanadventurer/WhatWeb)**,** [**webtech** ](https://github.com/ShielderSec/webtech)oder [**https://builtwith.com/**](https://builtwith.com)**:**
```bash
whatweb -a 1 <URL> #Stealthy
whatweb -a 3 <URL> #Aggresive
webtech -u <URL>
webanalyze -host https://google.com -crawl 2
```
Suche **nach** [**Schwachstellen der Webanwendung** **Version**](../../generic-hacking/search-exploits.md)

### **Überprüfen, ob ein WAF vorhanden ist**

- [**https://github.com/EnableSecurity/wafw00f**](https://github.com/EnableSecurity/wafw00f)
- [**https://github.com/Ekultek/WhatWaf.git**](https://github.com/Ekultek/WhatWaf.git)
- [**https://nmap.org/nsedoc/scripts/http-waf-detect.html**](https://nmap.org/nsedoc/scripts/http-waf-detect.html)

### Web-Technik-Tricks

Einige **Tricks** zum **finden von Schwachstellen** in verschiedenen bekannten **Technologien**, die verwendet werden:

- [**AEM - Adobe Experience Cloud**](aem-adobe-experience-cloud.md)
- [**Apache**](apache.md)
- [**Artifactory**](artifactory-hacking-guide.md)
- [**Buckets**](buckets/)
- [**CGI**](cgi.md)
- [**Drupal**](drupal/)
- [**Flask**](flask.md)
- [**Git**](git.md)
- [**Golang**](golang.md)
- [**GraphQL**](graphql.md)
- [**H2 - Java SQL-Datenbank**](h2-java-sql-database.md)
- [**IIS-Tricks**](iis-internet-information-services.md)
- [**JBOSS**](jboss.md)
- [**Jenkins**](<[https:/github.com/carlospolop/hacktricks/blob/master/network-services-pentesting/pentesting-web/broken-reference/README.md](https:/github.com/HackTricks-wiki/hacktricks-cloud/tree/master/pentesting-ci-cd/jenkins-security)/>)
- [**Jira**](jira.md)
- [**Joomla**](joomla.md)
- [**JSP**](jsp.md)
- [**Laravel**](laravel.md)
- [**Moodle**](moodle.md)
- [**Nginx**](nginx.md)
- [**PHP (php hat viele interessante Tricks, die ausgenutzt werden könnten)**](php-tricks-esp/)
- [**Python**](python.md)
- [**Spring Actuators**](spring-actuators.md)
- [**Symphony**](symphony.md)
- [**Tomcat**](tomcat/)
- [**VMWare**](vmware-esx-vcenter....md)
- [**Web API Pentesting**](web-api-pentesting.md)
- [**WebDav**](put-method-webdav.md)
- [**Werkzeug**](werkzeug.md)
- [**Wordpress**](wordpress.md)
- [**Electron Desktop (XSS zu RCE)**](electron-desktop-apps/)

_Beachten Sie, dass die **gleiche Domain** **verschiedene Technologien** in verschiedenen **Ports**, **Ordnern** und **Subdomains** verwenden kann._\
Wenn die Webanwendung eine bekannte **Technologie/Plattform aus der Liste oben** oder **eine andere** verwendet, vergessen Sie nicht, **im Internet nach neuen Tricks zu suchen** (und lassen Sie es mich wissen!).

### Quellcode-Überprüfung

Wenn der **Quellcode** der Anwendung in **github** verfügbar ist, gibt es neben der Durchführung eines **White-Box-Tests** der Anwendung **einige Informationen**, die für das aktuelle **Black-Box-Testing** **nützlich** sein könnten:

- Gibt es eine **Änderungsprotokoll- oder Readme- oder Versionsdatei** oder etwas mit **Versionsinformationen, das über das Web zugänglich ist**?
- Wie und wo werden die **Anmeldeinformationen** gespeichert? Gibt es eine (zugängliche?) **Datei** mit Anmeldeinformationen (Benutzernamen oder Passwörtern)?
- Sind **Passwörter** im **Klartext**, **verschlüsselt** oder welcher **Hash-Algorithmus** wird verwendet?
- Wird ein **Master-Schlüssel** zur Verschlüsselung von etwas verwendet? Welcher **Algorithmus** wird verwendet?
- Können Sie **auf eine dieser Dateien zugreifen**, indem Sie eine Schwachstelle ausnutzen?
- Gibt es **interessante Informationen in den github** (gelöste und ungelöste) **Issues**? Oder in der **Commit-Historie** (vielleicht ein **Passwort, das in einem alten Commit eingeführt wurde**)?

{{#ref}}
code-review-tools.md
{{#endref}}

### Automatische Scanner

#### Allgemeine automatische Scanner
```bash
nikto -h <URL>
whatweb -a 4 <URL>
wapiti -u <URL>
W3af
zaproxy #You can use an API
nuclei -ut && nuclei -target <URL>

# https://github.com/ignis-sec/puff (client side vulns fuzzer)
node puff.js -w ./wordlist-examples/xss.txt -u "http://www.xssgame.com/f/m4KKGHi2rVUN/?query=FUZZ"
```
#### CMS-Scanner

Wenn ein CMS verwendet wird, vergiss nicht, **einen Scanner auszuführen**, vielleicht wird etwas Interessantes gefunden:

[**Clusterd**](https://github.com/hatRiot/clusterd)**:** [**JBoss**](jboss.md)**, ColdFusion, WebLogic,** [**Tomcat**](tomcat/)**, Railo, Axis2, Glassfish**\
[**CMSScan**](https://github.com/ajinabraham/CMSScan): [**WordPress**](wordpress.md), [**Drupal**](drupal/), **Joomla**, **vBulletin**-Websites auf Sicherheitsprobleme. (GUI)\
[**VulnX**](https://github.com/anouarbensaad/vulnx)**:** [**Joomla**](joomla.md)**,** [**Wordpress**](wordpress.md)**,** [**Drupal**](drupal/)**, PrestaShop, Opencart**\
**CMSMap**: [**(W)ordpress**](wordpress.md)**,** [**(J)oomla**](joomla.md)**,** [**(D)rupal**](drupal/) **oder** [**(M)oodle**](moodle.md)\
[**droopscan**](https://github.com/droope/droopescan)**:** [**Drupal**](drupal/)**,** [**Joomla**](joomla.md)**,** [**Moodle**](moodle.md)**, Silverstripe,** [**Wordpress**](wordpress.md)
```bash
cmsmap [-f W] -F -d <URL>
wpscan --force update -e --url <URL>
joomscan --ec -u <URL>
joomlavs.rb #https://github.com/rastating/joomlavs
```
> An diesem Punkt sollten Sie bereits einige Informationen über den vom Client verwendeten Webserver haben (sofern Daten bereitgestellt werden) und einige Tricks, die Sie während des Tests im Hinterkopf behalten sollten. Wenn Sie Glück haben, haben Sie sogar ein CMS gefunden und einen Scanner ausgeführt.

## Schritt-für-Schritt-Webanwendungsentdeckung

> Ab diesem Punkt werden wir beginnen, mit der Webanwendung zu interagieren.

### Erste Überprüfungen

**Standardseiten mit interessanten Informationen:**

- /robots.txt
- /sitemap.xml
- /crossdomain.xml
- /clientaccesspolicy.xml
- /.well-known/
- Überprüfen Sie auch Kommentare auf den Haupt- und Unterseiten.

**Fehler erzwingen**

Webserver können **unerwartet reagieren**, wenn seltsame Daten an sie gesendet werden. Dies kann **Schwachstellen** oder **Offenlegung sensibler Informationen** öffnen.

- Greifen Sie auf **falsche Seiten** wie /whatever_fake.php (.aspx,.html,.etc) zu
- **Fügen Sie "\[]", "]]" und "\[\["** in **Cookie-Werte** und **Parameter**-Werte ein, um Fehler zu erzeugen
- Generieren Sie einen Fehler, indem Sie als Eingabe **`/~randomthing/%s`** am **Ende** der **URL** angeben
- Versuchen Sie **verschiedene HTTP-Methoden** wie PATCH, DEBUG oder falsche wie FAKE

#### **Überprüfen Sie, ob Sie Dateien hochladen können (**[**PUT-Verb, WebDav**](put-method-webdav.md)**)**

Wenn Sie feststellen, dass **WebDav** **aktiviert** ist, Sie jedoch nicht über ausreichende Berechtigungen zum **Hochladen von Dateien** im Stammordner verfügen, versuchen Sie:

- **Brute Force**-Anmeldeinformationen
- **Hochladen von Dateien** über WebDav in die **restlichen** **gefundenen Ordner** innerhalb der Webseite. Möglicherweise haben Sie Berechtigungen, um Dateien in anderen Ordnern hochzuladen.

### **SSL/TLS-Schwachstellen**

- Wenn die Anwendung **den Benutzer nicht zu HTTPS zwingt**, ist sie **anfällig für MitM**
- Wenn die Anwendung **sensible Daten (Passwörter) über HTTP sendet**, ist das eine hohe Schwachstelle.

Verwenden Sie [**testssl.sh**](https://github.com/drwetter/testssl.sh), um nach **Schwachstellen** zu suchen (In Bug-Bounty-Programmen werden solche Schwachstellen wahrscheinlich nicht akzeptiert) und verwenden Sie [**a2sv**](https://github.com/hahwul/a2sv), um die Schwachstellen erneut zu überprüfen:
```bash
./testssl.sh [--htmlfile] 10.10.10.10:443
#Use the --htmlfile to save the output inside an htmlfile also

# You can also use other tools, by testssl.sh at this momment is the best one (I think)
sslscan <host:port>
sslyze --regular <ip:port>
```
Informationen über SSL/TLS-Sicherheitsanfälligkeiten:

- [https://www.gracefulsecurity.com/tls-ssl-vulnerabilities/](https://www.gracefulsecurity.com/tls-ssl-vulnerabilities/)
- [https://www.acunetix.com/blog/articles/tls-vulnerabilities-attacks-final-part/](https://www.acunetix.com/blog/articles/tls-vulnerabilities-attacks-final-part/)

### Spidering

Starten Sie eine Art von **Spider** im Web. Das Ziel des Spiders ist es, **so viele Pfade wie möglich** aus der getesteten Anwendung zu **finden**. Daher sollten Web-Crawling und externe Quellen verwendet werden, um so viele gültige Pfade wie möglich zu finden.

- [**gospider**](https://github.com/jaeles-project/gospider) (go): HTML-Spider, LinkFinder in JS-Dateien und externen Quellen (Archive.org, CommonCrawl.org, VirusTotal.com, AlienVault.com).
- [**hakrawler**](https://github.com/hakluke/hakrawler) (go): HML-Spider, mit LinkFinder für JS-Dateien und Archive.org als externe Quelle.
- [**dirhunt**](https://github.com/Nekmo/dirhunt) (python): HTML-Spider, zeigt auch "saftige Dateien" an.
- [**evine** ](https://github.com/saeeddhqan/evine)(go): Interaktiver CLI HTML-Spider. Es sucht auch in Archive.org.
- [**meg**](https://github.com/tomnomnom/meg) (go): Dieses Tool ist kein Spider, kann aber nützlich sein. Sie können einfach eine Datei mit Hosts und eine Datei mit Pfaden angeben, und meg wird jeden Pfad auf jedem Host abrufen und die Antwort speichern.
- [**urlgrab**](https://github.com/IAmStoxe/urlgrab) (go): HTML-Spider mit JS-Rendering-Fähigkeiten. Es scheint jedoch unwartbar zu sein, die vorcompilierte Version ist alt und der aktuelle Code kompiliert nicht.
- [**gau**](https://github.com/lc/gau) (go): HTML-Spider, der externe Anbieter (wayback, otx, commoncrawl) nutzt.
- [**ParamSpider**](https://github.com/devanshbatham/ParamSpider): Dieses Skript findet URLs mit Parametern und listet sie auf.
- [**galer**](https://github.com/dwisiswant0/galer) (go): HTML-Spider mit JS-Rendering-Fähigkeiten.
- [**LinkFinder**](https://github.com/GerbenJavado/LinkFinder) (python): HTML-Spider, mit JS-Beautify-Fähigkeiten, die in JS-Dateien nach neuen Pfaden suchen können. Es könnte sich auch lohnen, einen Blick auf [JSScanner](https://github.com/dark-warlord14/JSScanner) zu werfen, das ein Wrapper von LinkFinder ist.
- [**goLinkFinder**](https://github.com/0xsha/GoLinkFinder) (go): Um Endpunkte sowohl im HTML-Quellcode als auch in eingebetteten JavaScript-Dateien zu extrahieren. Nützlich für Bug-Jäger, Red-Teamer, Infosec-Ninjas.
- [**JSParser**](https://github.com/nahamsec/JSParser) (python2.7): Ein Python 2.7-Skript, das Tornado und JSBeautifier verwendet, um relative URLs aus JavaScript-Dateien zu parsen. Nützlich, um AJAX-Anfragen leicht zu entdecken. Sieht unwartbar aus.
- [**relative-url-extractor**](https://github.com/jobertabma/relative-url-extractor) (ruby): Gegeben eine Datei (HTML) wird es URLs daraus extrahieren, indem es raffinierte reguläre Ausdrücke verwendet, um die relativen URLs aus hässlichen (minifizierten) Dateien zu finden und zu extrahieren.
- [**JSFScan**](https://github.com/KathanP19/JSFScan.sh) (bash, mehrere Tools): Interessante Informationen aus JS-Dateien mit mehreren Tools sammeln.
- [**subjs**](https://github.com/lc/subjs) (go): JS-Dateien finden.
- [**page-fetch**](https://github.com/detectify/page-fetch) (go): Eine Seite in einem headless Browser laden und alle URLs ausgeben, die zum Laden der Seite geladen wurden.
- [**Feroxbuster**](https://github.com/epi052/feroxbuster) (rust): Inhaltsentdeckungstool, das mehrere Optionen der vorherigen Tools kombiniert.
- [**Javascript Parsing**](https://github.com/xnl-h4ck3r/burp-extensions): Eine Burp-Erweiterung, um Pfade und Parameter in JS-Dateien zu finden.
- [**Sourcemapper**](https://github.com/denandz/sourcemapper): Ein Tool, das Ihnen den beautifizierten JS-Code gibt, wenn die .js.map-URL angegeben wird.
- [**xnLinkFinder**](https://github.com/xnl-h4ck3r/xnLinkFinder): Dies ist ein Tool, das verwendet wird, um Endpunkte für ein bestimmtes Ziel zu entdecken.
- [**waymore**](https://github.com/xnl-h4ck3r/waymore)**:** Entdecken Sie Links von der Wayback-Maschine (auch die Antworten in der Wayback herunterladen und nach weiteren Links suchen).
- [**HTTPLoot**](https://github.com/redhuntlabs/HTTPLoot) (go): Crawlen (auch durch Ausfüllen von Formularen) und auch sensible Informationen mit spezifischen Regexen finden.
- [**SpiderSuite**](https://github.com/3nock/SpiderSuite): Spider Suite ist ein fortschrittlicher, multifunktionaler GUI-Websicherheits-Crawler/Spider, der für Cybersicherheitsprofis entwickelt wurde.
- [**jsluice**](https://github.com/BishopFox/jsluice) (go): Es ist ein Go-Paket und [Befehlszeilentool](https://github.com/BishopFox/jsluice/blob/main/cmd/jsluice) zum Extrahieren von URLs, Pfaden, Geheimnissen und anderen interessanten Daten aus JavaScript-Quellcode.
- [**ParaForge**](https://github.com/Anof-cyber/ParaForge): ParaForge ist eine einfache **Burp Suite-Erweiterung**, um **Parameter und Endpunkte** aus der Anfrage zu extrahieren, um benutzerdefinierte Wortlisten für Fuzzing und Enumeration zu erstellen.
- [**katana**](https://github.com/projectdiscovery/katana) (go): Tolle Tool dafür.
- [**Crawley**](https://github.com/s0rg/crawley) (go): Drucken Sie jeden Link aus, den es finden kann.

### Brute Force-Verzeichnisse und -Dateien

Beginnen Sie mit dem **Brute-Forcen** vom Stammverzeichnis und stellen Sie sicher, dass Sie **alle** **gefundenen Verzeichnisse** mit **dieser Methode** und allen Verzeichnissen **entdeckt** durch das **Spidering** brute-forcen (Sie können dieses Brute-Forcing **rekursiv** durchführen und am Anfang der verwendeten Wortliste die Namen der gefundenen Verzeichnisse anhängen).\
Tools:

- **Dirb** / **Dirbuster** - In Kali enthalten, **alt** (und **langsam**), aber funktional. Erlaubt automatisch signierte Zertifikate und rekursive Suche. Zu langsam im Vergleich zu den anderen Optionen.
- [**Dirsearch**](https://github.com/maurosoria/dirsearch) (python)**: Es erlaubt keine automatisch signierten Zertifikate, aber** erlaubt rekursive Suche.
- [**Gobuster**](https://github.com/OJ/gobuster) (go): Es erlaubt automatisch signierte Zertifikate, hat jedoch keine **rekursive** Suche.
- [**Feroxbuster**](https://github.com/epi052/feroxbuster) **- Schnell, unterstützt rekursive Suche.**
- [**wfuzz**](https://github.com/xmendez/wfuzz) `wfuzz -w /usr/share/seclists/Discovery/Web-Content/raft-medium-directories.txt https://domain.com/api/FUZZ`
- [**ffuf** ](https://github.com/ffuf/ffuf)- Schnell: `ffuf -c -w /usr/share/wordlists/dirb/big.txt -u http://10.10.10.10/FUZZ`
- [**uro**](https://github.com/s0md3v/uro) (python): Dies ist kein Spider, sondern ein Tool, das eine Liste gefundener URLs verwendet, um "duplizierte" URLs zu löschen.
- [**Scavenger**](https://github.com/0xDexter0us/Scavenger): Burp-Erweiterung zur Erstellung einer Liste von Verzeichnissen aus der Burp-Historie verschiedener Seiten.
- [**TrashCompactor**](https://github.com/michael1026/trashcompactor): Entfernen Sie URLs mit duplizierten Funktionen (basierend auf JS-Imports).
- [**Chamaleon**](https://github.com/iustin24/chameleon): Es verwendet Wappalyzer, um verwendete Technologien zu erkennen und die zu verwendenden Wortlisten auszuwählen.

**Empfohlene Wörterbücher:**

- [https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/bf_directories.txt](https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/bf_directories.txt)
- [**Dirsearch** enthaltenes Wörterbuch](https://github.com/maurosoria/dirsearch/blob/master/db/dicc.txt)
- [http://gist.github.com/jhaddix/b80ea67d85c13206125806f0828f4d10](http://gist.github.com/jhaddix/b80ea67d85c13206125806f0828f4d10)
- [Assetnote-Wortlisten](https://wordlists.assetnote.io)
- [https://github.com/danielmiessler/SecLists/tree/master/Discovery/Web-Content](https://github.com/danielmiessler/SecLists/tree/master/Discovery/Web-Content)
- raft-large-directories-lowercase.txt
- directory-list-2.3-medium.txt
- RobotsDisallowed/top10000.txt
- [https://github.com/random-robbie/bruteforce-lists](https://github.com/random-robbie/bruteforce-lists)
- [https://github.com/google/fuzzing/tree/master/dictionaries](https://github.com/google/fuzzing/tree/master/dictionaries)
- [https://github.com/six2dez/OneListForAll](https://github.com/six2dez/OneListForAll)
- [https://github.com/random-robbie/bruteforce-lists](https://github.com/random-robbie/bruteforce-lists)
- [https://github.com/ayoubfathi/leaky-paths](https://github.com/ayoubfathi/leaky-paths)
- _/usr/share/wordlists/dirb/common.txt_
- _/usr/share/wordlists/dirb/big.txt_
- _/usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt_

_Bedenken Sie, dass jedes Mal, wenn während des Brute-Forcings oder Spiderings ein neues Verzeichnis entdeckt wird, es brute-forced werden sollte._

### Was bei jeder gefundenen Datei zu überprüfen ist

- [**Broken link checker**](https://github.com/stevenvachon/broken-link-checker): Finden Sie defekte Links in HTMLs, die anfällig für Übernahmen sein könnten.
- **Dateisicherungen**: Sobald Sie alle Dateien gefunden haben, suchen Sie nach Sicherungen aller ausführbaren Dateien ("_.php_", "_.aspx_"...). Häufige Variationen zur Benennung einer Sicherung sind: _file.ext\~, #file.ext#, \~file.ext, file.ext.bak, file.ext.tmp, file.ext.old, file.bak, file.tmp und file.old._ Sie können auch das Tool [**bfac**](https://github.com/mazen160/bfac) **oder** [**backup-gen**](https://github.com/Nishantbhagat57/backup-gen)** verwenden.**
- **Neue Parameter entdecken**: Sie können Tools wie [**Arjun**](https://github.com/s0md3v/Arjun)**,** [**parameth**](https://github.com/maK-/parameth)**,** [**x8**](https://github.com/sh1yo/x8) **und** [**Param Miner**](https://github.com/PortSwigger/param-miner) **verwenden, um versteckte Parameter zu entdecken. Wenn Sie können, könnten Sie versuchen, versteckte Parameter in jeder ausführbaren Webdatei zu suchen.**
- _Arjun alle Standard-Wortlisten:_ [https://github.com/s0md3v/Arjun/tree/master/arjun/db](https://github.com/s0md3v/Arjun/tree/master/arjun/db)
- _Param-miner “params” :_ [https://github.com/PortSwigger/param-miner/blob/master/resources/params](https://github.com/PortSwigger/param-miner/blob/master/resources/params)
- _Assetnote “parameters_top_1m”:_ [https://wordlists.assetnote.io/](https://wordlists.assetnote.io)
- _nullenc0de “params.txt”:_ [https://gist.github.com/nullenc0de/9cb36260207924f8e1787279a05eb773](https://gist.github.com/nullenc0de/9cb36260207924f8e1787279a05eb773)
- **Kommentare:** Überprüfen Sie die Kommentare aller Dateien, Sie können **Anmeldeinformationen** oder **versteckte Funktionen** finden.
- Wenn Sie **CTF** spielen, ist ein "gewöhnlicher" Trick, **Informationen** in Kommentaren auf der **rechten** Seite der **Seite** zu **verstecken** (indem Sie **hunderte** von **Leerzeichen** verwenden, sodass Sie die Daten nicht sehen, wenn Sie den Quellcode mit dem Browser öffnen). Eine andere Möglichkeit besteht darin, **mehrere neue Zeilen** zu verwenden und **Informationen** in einem Kommentar am **unteren** Ende der Webseite zu **verstecken**.
- **API-Schlüssel**: Wenn Sie **einen API-Schlüssel finden**, gibt es eine Anleitung, die angibt, wie man API-Schlüssel verschiedener Plattformen verwendet: [**keyhacks**](https://github.com/streaak/keyhacks)**,** [**zile**](https://github.com/xyele/zile.git)**,** [**truffleHog**](https://github.com/trufflesecurity/truffleHog)**,** [**SecretFinder**](https://github.com/m4ll0k/SecretFinder)**,** [**RegHex**](<https://github.com/l4yton/RegHex)/>)**,** [**DumpsterDive**](https://github.com/securing/DumpsterDiver)**,** [**EarlyBird**](https://github.com/americanexpress/earlybird)
- Google API-Schlüssel: Wenn Sie einen API-Schlüssel finden, der wie **AIza**SyA-qLheq6xjDiEIRisP_ujUseYLQCHUjik aussieht, können Sie das Projekt [**gmapapiscanner**](https://github.com/ozguralp/gmapsapiscanner) verwenden, um zu überprüfen, auf welche APIs der Schlüssel zugreifen kann.
- **S3-Buckets**: Achten Sie beim Spidering darauf, ob eine **Subdomain** oder ein **Link** mit einem **S3-Bucket** verbunden ist. In diesem Fall [**überprüfen** Sie die **Berechtigungen** des Buckets](buckets/).

### Besondere Funde

**Während** Sie das **Spidering** und **Brute-Forcing** durchführen, könnten Sie **interessante** **Dinge** finden, die Sie **beachten** sollten.

**Interessante Dateien**

- Suchen Sie nach **Links** zu anderen Dateien in den **CSS**-Dateien.
- [Wenn Sie eine _**.git**_-Datei finden, können einige Informationen extrahiert werden](git.md)
- Wenn Sie eine _**.env**_-Datei finden, können Informationen wie API-Schlüssel, Datenbankpasswörter und andere Informationen gefunden werden.
- Wenn Sie **API-Endpunkte** finden, [sollten Sie diese ebenfalls testen](web-api-pentesting.md). Diese sind keine Dateien, sehen aber wahrscheinlich "so aus".
- **JS-Dateien**: Im Abschnitt Spidering wurden mehrere Tools erwähnt, die Pfade aus JS-Dateien extrahieren können. Es wäre auch interessant, **jede gefundene JS-Datei zu überwachen**, da in einigen Fällen eine Änderung darauf hindeuten kann, dass eine potenzielle Sicherheitsanfälligkeit im Code eingeführt wurde. Sie könnten beispielsweise [**JSMon**](https://github.com/robre/jsmon)** verwenden.**
- Sie sollten auch entdeckte JS-Dateien mit [**RetireJS**](https://github.com/retirejs/retire.js/) oder [**JSHole**](https://github.com/callforpapers-source/jshole) überprüfen, um herauszufinden, ob sie anfällig sind.
- **Javascript Deobfuscator und Unpacker:** [https://lelinhtinh.github.io/de4js/](https://lelinhtinh.github.io/de4js/), [https://www.dcode.fr/javascript-unobfuscator](https://www.dcode.fr/javascript-unobfuscator)
- **Javascript Beautifier:** [http://jsbeautifier.org/](https://beautifier.io), [http://jsnice.org/](http://jsnice.org)
- **JsFuck-Deobfuskation** (Javascript mit Zeichen:"\[]!+" [https://enkhee-osiris.github.io/Decoder-JSFuck/](https://enkhee-osiris.github.io/Decoder-JSFuck/))
- [**TrainFuck**](https://github.com/taco-c/trainfuck)**:** `+72.+29.+7..+3.-67.-12.+55.+24.+3.-6.-8.-67.-23.`
- In mehreren Fällen müssen Sie die **regulären Ausdrücke** verstehen, die verwendet werden. Dies wird nützlich sein: [https://regex101.com/](https://regex101.com) oder [https://pythonium.net/regex](https://pythonium.net/regex)
- Sie könnten auch die Dateien überwachen, in denen Formulare erkannt wurden, da eine Änderung im Parameter oder das Auftauchen eines neuen Formulars auf eine potenziell neue anfällige Funktionalität hinweisen könnte.

**403 Forbidden/Basic Authentication/401 Unauthorized (Umgehung)**

{{#ref}}
403-and-401-bypasses.md
{{#endref}}

**502 Proxy-Fehler**

Wenn eine Seite mit diesem **Code** **antwortet**, handelt es sich wahrscheinlich um einen **schlecht konfigurierten Proxy**. **Wenn Sie eine HTTP-Anfrage wie: `GET https://google.com HTTP/1.1`** (mit dem Host-Header und anderen gängigen Headern) senden, wird der **Proxy** versuchen, auf _**google.com**_ zuzugreifen, und Sie haben eine **SSRF** gefunden.

**NTLM-Authentifizierung - Informationsoffenlegung**

Wenn der laufende Server nach Authentifizierung fragt und **Windows** ist oder Sie ein Login finden, das nach Ihren **Anmeldeinformationen** (und nach dem **Domänennamen**) fragt, können Sie eine **Informationsoffenlegung** provozieren.\
**Senden** Sie den **Header**: `“Authorization: NTLM TlRMTVNTUAABAAAAB4IIAAAAAAAAAAAAAAAAAAAAAAA=”` und aufgrund der Funktionsweise der **NTLM-Authentifizierung** wird der Server mit internen Informationen (IIS-Version, Windows-Version...) im Header "WWW-Authenticate" antworten.\
Sie können dies mit dem **nmap-Plugin** "_http-ntlm-info.nse_" **automatisieren**.

**HTTP-Weiterleitung (CTF)**

Es ist möglich, **Inhalte** in eine **Weiterleitung** einzufügen. Diese Inhalte **werden dem Benutzer nicht angezeigt** (da der Browser die Weiterleitung ausführt), aber es könnte etwas **versteckt** sein.

### Überprüfung von Web-Sicherheitsanfälligkeiten

Jetzt, da eine umfassende Enumeration der Webanwendung durchgeführt wurde, ist es an der Zeit, nach vielen möglichen Sicherheitsanfälligkeiten zu suchen. Sie finden die Checkliste hier:

{{#ref}}
../../pentesting-web/web-vulnerabilities-methodology.md
{{#endref}}

Weitere Informationen zu Web-Sicherheitsanfälligkeiten finden Sie unter:

- [https://six2dez.gitbook.io/pentest-book/others/web-checklist](https://six2dez.gitbook.io/pentest-book/others/web-checklist)
- [https://kennel209.gitbooks.io/owasp-testing-guide-v4/content/en/web_application_security_testing/configuration_and_deployment_management_testing.html](https://kennel209.gitbooks.io/owasp-testing-guide-v4/content/en/web_application_security_testing/configuration_and_deployment_management_testing.html)
- [https://owasp-skf.gitbook.io/asvs-write-ups/kbid-111-client-side-template-injection](https://owasp-skf.gitbook.io/asvs-write-ups/kbid-111-client-side-template-injection)

### Überwachen von Seiten auf Änderungen

Sie können Tools wie [https://github.com/dgtlmoon/changedetection.io](https://github.com/dgtlmoon/changedetection.io) verwenden, um Seiten auf Änderungen zu überwachen, die Sicherheitsanfälligkeiten einfügen könnten.

<figure><img src="../../images/pentest-tools.svg" alt=""><figcaption></figcaption></figure>

**Erhalten Sie die Perspektive eines Hackers auf Ihre Webanwendungen, Ihr Netzwerk und Ihre Cloud**

**Finden und melden Sie kritische, ausnutzbare Sicherheitsanfälligkeiten mit echtem Geschäftswert.** Verwenden Sie unsere 20+ benutzerdefinierten Tools, um die Angriffsfläche zu kartieren, Sicherheitsprobleme zu finden, die Ihnen ermöglichen, Berechtigungen zu eskalieren, und verwenden Sie automatisierte Exploits, um wesentliche Beweise zu sammeln, die Ihre harte Arbeit in überzeugende Berichte verwandeln.

{% embed url="https://pentest-tools.com/?utm_term=jul2024&utm_medium=link&utm_source=hacktricks&utm_campaign=spons" %}

### HackTricks Automatische Befehle
```
Protocol_Name: Web    #Protocol Abbreviation if there is one.
Port_Number:  80,443     #Comma separated if there is more than one.
Protocol_Description: Web         #Protocol Abbreviation Spelled out

Entry_1:
Name: Notes
Description: Notes for Web
Note: |
https://book.hacktricks.xyz/pentesting/pentesting-web

Entry_2:
Name: Quick Web Scan
Description: Nikto and GoBuster
Command: nikto -host {Web_Proto}://{IP}:{Web_Port} &&&& gobuster dir -w {Small_Dirlist} -u {Web_Proto}://{IP}:{Web_Port} && gobuster dir -w {Big_Dirlist} -u {Web_Proto}://{IP}:{Web_Port}

Entry_3:
Name: Nikto
Description: Basic Site Info via Nikto
Command: nikto -host {Web_Proto}://{IP}:{Web_Port}

Entry_4:
Name: WhatWeb
Description: General purpose auto scanner
Command: whatweb -a 4 {IP}

Entry_5:
Name: Directory Brute Force Non-Recursive
Description:  Non-Recursive Directory Brute Force
Command: gobuster dir -w {Big_Dirlist} -u {Web_Proto}://{IP}:{Web_Port}

Entry_6:
Name: Directory Brute Force Recursive
Description: Recursive Directory Brute Force
Command: python3 {Tool_Dir}dirsearch/dirsearch.py -w {Small_Dirlist} -e php,exe,sh,py,html,pl -f -t 20 -u {Web_Proto}://{IP}:{Web_Port} -r 10

Entry_7:
Name: Directory Brute Force CGI
Description: Common Gateway Interface Brute Force
Command: gobuster dir -u {Web_Proto}://{IP}:{Web_Port}/ -w /usr/share/seclists/Discovery/Web-Content/CGIs.txt -s 200

Entry_8:
Name: Nmap Web Vuln Scan
Description: Tailored Nmap Scan for web Vulnerabilities
Command: nmap -vv --reason -Pn -sV -p {Web_Port} --script=`banner,(http* or ssl*) and not (brute or broadcast or dos or external or http-slowloris* or fuzzer)` {IP}

Entry_9:
Name: Drupal
Description: Drupal Enumeration Notes
Note: |
git clone https://github.com/immunIT/drupwn.git for low hanging fruit and git clone https://github.com/droope/droopescan.git for deeper enumeration

Entry_10:
Name: WordPress
Description: WordPress Enumeration with WPScan
Command: |
?What is the location of the wp-login.php? Example: /Yeet/cannon/wp-login.php
wpscan --url {Web_Proto}://{IP}{1} --enumerate ap,at,cb,dbe && wpscan --url {Web_Proto}://{IP}{1} --enumerate u,tt,t,vp --passwords {Big_Passwordlist} -e

Entry_11:
Name: WordPress Hydra Brute Force
Description: Need User (admin is default)
Command: hydra -l admin -P {Big_Passwordlist} {IP} -V http-form-post '/wp-login.php:log=^USER^&pwd=^PASS^&wp-submit=Log In&testcookie=1:S=Location'

Entry_12:
Name: Ffuf Vhost
Description: Simple Scan with Ffuf for discovering additional vhosts
Command: ffuf -w {Subdomain_List}:FUZZ -u {Web_Proto}://{Domain_Name} -H "Host:FUZZ.{Domain_Name}" -c -mc all {Ffuf_Filters}
```
{{#include ../../banners/hacktricks-training.md}}
