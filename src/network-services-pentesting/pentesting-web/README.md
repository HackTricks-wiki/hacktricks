# 80,443 - Pentesting Веб-методологія

{{#include ../../banners/hacktricks-training.md}}

## Основна інформація

Веб-сервіс є **найпоширенішим та наймасштабнішим сервісом**, і існує багато **різних типів вразливостей**.

**Порт за замовчуванням:** 80 (HTTP), 443 (HTTPS)
```bash
PORT    STATE SERVICE
80/tcp  open  http
443/tcp open  ssl/https
```

```bash
nc -v domain.com 80 # GET / HTTP/1.0
openssl s_client -connect domain.com:443 # GET / HTTP/1.0
```
### Web API Guidance


{{#ref}}
web-api-pentesting.md
{{#endref}}

## Methodology summary

> У цій методології ми припускаємо, що ви збираєтеся атакувати один домен (або subdomain) і лише його. Отже, ви повинні застосувати цю методологію до кожного виявленого domain, subdomain або IP з невизначеним веб-сервером в межах scope.

- [ ] Почніть з **ідентифікації** **technologies**, які використовує веб-сервер. Шукайте **tricks**, які варто пам'ятати протягом решти тесту, якщо ви зможете успішно ідентифікувати tech.
- [ ] Чи є які-небудь **known vulnerability** для версії технології?
- [ ] Чи використовується якась **well known tech**? Чи є якісь **useful trick** для витягнення додаткової інформації?
- [ ] Чи є якийсь **specialised scanner** для запуску (наприклад, wpscan)?
- [ ] Запустіть **general purposes scanners**. Ніколи не знаєш, чи вони щось знайдуть або виявлять цікаву інформацію.
- [ ] Почніть з **initial checks**: **robots**, **sitemap**, **404** error та **SSL/TLS scan** (якщо HTTPS).
- [ ] Почніть **spidering** веб-сторінки: настав час **find** всі можливі **files, folders** та **parameters being used.** Також перевірте на **special findings**.
- [ ] _Note that anytime a new directory is discovered during brute-forcing or spidering, it should be spidered._
- [ ] **Directory Brute-Forcing**: Спробуйте brute force всі виявлені папки в пошуках нових **files** та **directories**.
- [ ] _Note that anytime a new directory is discovered during brute-forcing or spidering, it should be Brute-Forced._
- [ ] **Backups checking**: Перевірте, чи можна знайти **backups** **виявлених файлів**, додаючи загальні розширення для резервних копій.
- [ ] **Brute-Force parameters**: Спробуйте **find hidden parameters**.
- [ ] Після того, як ви **identified** всі можливі **endpoints**, що приймають **user input**, перевірте їх на всі види пов'язаних **vulnerabilities**.
- [ ] [Follow this checklist](../../pentesting-web/web-vulnerabilities-methodology.md)

## Server Version (Vulnerable?)

### Identify

Перевірте, чи існують **known vulnerabilities** для версії сервера, яка працює.\  
**HTTP headers and cookies of the response** можуть бути дуже корисними для **identify** **technologies** та/або **version**, що використовуються. **Nmap scan** може визначити версію сервера, але також можуть бути корисні інструменти [**whatweb**](https://github.com/urbanadventurer/WhatWeb)**,** [**webtech** ](https://github.com/ShielderSec/webtech)or [**https://builtwith.com/**](https://builtwith.com)**:**
```bash
whatweb -a 1 <URL> #Stealthy
whatweb -a 3 <URL> #Aggresive
webtech -u <URL>
webanalyze -host https://google.com -crawl 2
```
Шукати **для** [**вразливостей веб-застосунку** **версії**](../../generic-hacking/search-exploits.md)

### **Перевірити наявність WAF**

- [**https://github.com/EnableSecurity/wafw00f**](https://github.com/EnableSecurity/wafw00f)
- [**https://github.com/Ekultek/WhatWaf.git**](https://github.com/Ekultek/WhatWaf.git)
- [**https://nmap.org/nsedoc/scripts/http-waf-detect.html**](https://nmap.org/nsedoc/scripts/http-waf-detect.html)

### Трюки з веб-технологій

Деякі **трюки** для **знаходження вразливостей** у різних відомих **технологіях**, що використовуються:

- [**AEM - Adobe Experience Cloud**](aem-adobe-experience-cloud.md)
- [**Apache**](apache.md)
- [**Artifactory**](artifactory-hacking-guide.md)
- [**Buckets**](buckets/index.html)
- [**CGI**](cgi.md)
- [**Drupal**](drupal/index.html)
- [**Flask**](flask.md)
- [**Git**](git.md)
- [**Golang**](golang.md)
- [**GraphQL**](graphql.md)
- [**H2 - Java SQL database**](h2-java-sql-database.md)
- [**ISPConfig**](ispconfig.md)
- [**IIS tricks**](iis-internet-information-services.md)
- [**Microsoft SharePoint**](microsoft-sharepoint.md)
- [**JBOSS**](jboss.md)
- [**Jenkins**](<[https:/github.com/carlospolop/hacktricks/blob/master/network-services-pentesting/pentesting-web/broken-reference/README.md](https:/github.com/HackTricks-wiki/hacktricks-cloud/tree/master/pentesting-ci-cd/jenkins-security)/>)
- [**Jira**](jira.md)
- [**Joomla**](joomla.md)
- [**JSP**](jsp.md)
- [**Laravel**](laravel.md)
- [**Moodle**](moodle.md)
- [**Nginx**](nginx.md)
- [**PHP (php has a lot of interesting tricks that could be exploited)**](php-tricks-esp/index.html)
- [**Python**](python.md)
- [**Spring Actuators**](spring-actuators.md)
- [**Symphony**](symphony.md)
- [**Tomcat**](tomcat/index.html)
- [**VMWare**](vmware-esx-vcenter....md)
- [**Web API Pentesting**](web-api-pentesting.md)
- [**WebDav**](put-method-webdav.md)
- [**Werkzeug**](werkzeug.md)
- [**Wordpress**](wordpress.md)
- [**Electron Desktop (XSS to RCE)**](electron-desktop-apps/index.html)
- [**Sitecore**](sitecore/index.html)

_Врахуйте, що **той самий домен** може використовувати **різні технології** на різних **портах**, **папках** та **піддоменах**._\
Якщо веб-застосунок використовує будь-яку відому **технологію/платформу**, перераховану вище, або будь-яку іншу, не забувайте **шукати в Інтернеті** нові трюки (і повідомте мене!).

### Source Code Review

Якщо **вихідний код** застосунку доступний на **github**, окрім виконання вами власного **White box test** застосунку, є **деяка інформація**, яка може бути **корисною** для поточного **Black-Box testing**:

- Чи є **Change-log or Readme or Version** файл або щось з **інформацією про версію**, доступне через web?
- Як і де зберігаються **облікові дані**? Чи є якийсь (доступний?) **файл** з обліковими даними (імена користувачів або паролі)?
- Чи зберігаються **паролі** у **plain text**, **зашифровані** або який **алгоритм хешування** використовується?
- Чи використовується якийсь **master key** для шифрування чогось? Який **алгоритм** використовується?
- Чи можна **отримати доступ до будь-якого з цих файлів**, експлуатуючи якусь вразливість?
- Чи є якась **цікава інформація в github** (вирішені та не вирішені) **issues**? Або в **commit history** (можливо якийсь **пароль** був доданий у старому коміті)?

{{#ref}}
code-review-tools.md
{{#endref}}

### Automatic scanners

#### Універсальні автоматичні сканери
```bash
nikto -h <URL>
whatweb -a 4 <URL>
wapiti -u <URL>
W3af
zaproxy #You can use an API
nuclei -ut && nuclei -target <URL>

# https://github.com/ignis-sec/puff (client side vulns fuzzer)
node puff.js -w ./wordlist-examples/xss.txt -u "http://www.xssgame.com/f/m4KKGHi2rVUN/?query=FUZZ"
```
#### CMS scanners

Якщо використовується CMS, не забудьте **run a scanner**, можливо знайдеться щось цікаве:

[**Clusterd**](https://github.com/hatRiot/clusterd)**:** [**JBoss**](jboss.md)**, ColdFusion, WebLogic,** [**Tomcat**](tomcat/index.html)**, Railo, Axis2, Glassfish**\
[**CMSScan**](https://github.com/ajinabraham/CMSScan): [**WordPress**](wordpress.md), [**Drupal**](drupal/index.html), **Joomla**, **vBulletin** вебсайти на предмет проблем безпеки. (GUI)\
[**VulnX**](https://github.com/anouarbensaad/vulnx)**:** [**Joomla**](joomla.md)**,** [**Wordpress**](wordpress.md)**,** [**Drupal**](drupal/index.html)**, PrestaShop, Opencart**\
**CMSMap**: [**(W)ordpress**](wordpress.md)**,** [**(J)oomla**](joomla.md)**,** [**(D)rupal**](drupal/index.html) **або** [**(M)oodle**](moodle.md)\
[**droopscan**](https://github.com/droope/droopescan)**:** [**Drupal**](drupal/index.html)**,** [**Joomla**](joomla.md)**,** [**Moodle**](moodle.md)**, Silverstripe,** [**Wordpress**](wordpress.md)
```bash
cmsmap [-f W] -F -d <URL>
wpscan --force update -e --url <URL>
joomscan --ec -u <URL>
joomlavs.rb #https://github.com/rastating/joomlavs
```
> На цьому етапі ви повинні вже мати деяку інформацію про веб‑сервер, що використовується клієнтом (якщо надані дані), та кілька прийомів, які слід пам’ятати під час тесту. Якщо пощастить, ви навіть знайшли CMS і запустили сканер.

## Покрокова розвідка веб‑застосунку

> З цього моменту ми починаємо взаємодіяти з веб‑застосунком.

### Початкові перевірки

**Типові сторінки з цікавою інформацією:**

- /robots.txt
- /sitemap.xml
- /crossdomain.xml
- /clientaccesspolicy.xml
- /.well-known/
- Перевіряйте також коментарі на головних і другорядних сторінках.

**Форсування помилок**

Веб‑сервери можуть **поводитися непередбачувано**, коли їм надсилають дивні дані. Це може відкрити **вразливості** або призвести до **розкриття конфіденційної інформації**.

- Доступ до **фейкових сторінок** на кшталт /whatever_fake.php (.aspx,.html,.etc)
- **Додавайте "\[]", "]]", and "\[["** у **значення cookie** та **значення параметрів**, щоб створити помилки
- Генеруйте помилку, подавши вхід як **`/~randomthing/%s`** в **кінці URL**
- Спробуйте **різні HTTP Verbs** як PATCH, DEBUG або некоректні, наприклад FAKE

#### **Перевірте, чи можете завантажувати файли (**[**PUT verb, WebDav**](put-method-webdav.md)**)**

Якщо ви виявите, що **WebDav** **увімкнено**, але у вас недостатньо дозволів для **завантаження файлів** в кореневу теку, спробуйте:

- **Brute Force** облікових даних
- **Завантажити файли** через WebDav у решту знайдених папок на сайті. Можливо, у вас є дозволи на завантаження файлів в інших папках.

### **SSL/TLS вразливості**

- Якщо застосунок **не примушує використовувати HTTPS** в жодній частині, то він **вразливий до MitM**
- Якщо застосунок **надсилає чутливі дані (паролі) через HTTP**, це серйозна вразливість.

Використовуйте [**testssl.sh**](https://github.com/drwetter/testssl.sh) щоб перевірити на **вразливості** (у Bug Bounty програмах, ймовірно, такого роду вразливості не будуть прийняті) та використайте [**a2sv** ](https://github.com/hahwul/a2sv)щоб перепровірити вразливості:
```bash
./testssl.sh [--htmlfile] 10.10.10.10:443
#Use the --htmlfile to save the output inside an htmlfile also

# You can also use other tools, by testssl.sh at this momment is the best one (I think)
sslscan <host:port>
sslyze --regular <ip:port>
```
Інформація про вразливості SSL/TLS:

- [https://www.gracefulsecurity.com/tls-ssl-vulnerabilities/](https://www.gracefulsecurity.com/tls-ssl-vulnerabilities/)
- [https://www.acunetix.com/blog/articles/tls-vulnerabilities-attacks-final-part/](https://www.acunetix.com/blog/articles/tls-vulnerabilities-attacks-final-part/)

### Spidering

Запустіть якийсь вид **spider** по веб-додатку. Мета spider — **знайти якомога більше шляхів** у тестованому застосунку. Тому для пошуку валідних шляхів слід використовувати web crawling та зовнішні джерела.

- [**gospider**](https://github.com/jaeles-project/gospider) (go): HTML spider, LinkFinder у JS файлах та зовнішні джерела (Archive.org, CommonCrawl.org, VirusTotal.com).
- [**hakrawler**](https://github.com/hakluke/hakrawler) (go): HML spider, з LinkFinder для JS файлів та Archive.org як зовнішнє джерело.
- [**dirhunt**](https://github.com/Nekmo/dirhunt) (python): HTML spider, також вказує "juicy files".
- [**evine** ](https://github.com/saeeddhqan/evine)(go): Інтерактивний CLI HTML spider. Також шукає в Archive.org
- [**meg**](https://github.com/tomnomnom/meg) (go): Цей інструмент не є spider'ом, але може бути корисним. Ви можете вказати файл з hosts і файл з paths, а meg завантажить кожен шлях на кожному хості та збереже відповіді.
- [**urlgrab**](https://github.com/IAmStoxe/urlgrab) (go): HTML spider з можливістю рендерингу JS. Однак, схоже, що проект не підтримується, попередньо зібрана версія стара і поточний код не компілюється.
- [**gau**](https://github.com/lc/gau) (go): HTML spider, що використовує зовнішніх провайдерів (wayback, otx, commoncrawl).
- [**ParamSpider**](https://github.com/devanshbatham/ParamSpider): Скрипт знайде URL з параметрами і виведе їх.
- [**galer**](https://github.com/dwisiswant0/galer) (go): HTML spider з можливістю рендерингу JS.
- [**LinkFinder**](https://github.com/GerbenJavado/LinkFinder) (python): HTML spider з можливістю JS beautify, здатний шукати нові шляхи в JS файлах. Варто також глянути на [JSScanner](https://github.com/dark-warlord14/JSScanner), який є обгорткою для LinkFinder.
- [**goLinkFinder**](https://github.com/0xsha/GoLinkFinder) (go): Для витягування endpoint'ів з HTML та вбудованих javascript файлів. Корисно для bug hunters, red teamers, infosec ninjas.
- [**JSParser**](https://github.com/nahamsec/JSParser) (python2.7): Скрипт на python 2.7, що використовує Tornado і JSBeautifier для парсингу відносних URL з JavaScript файлів. Корисний для виявлення AJAX запитів. Схоже, що не підтримується.
- [**relative-url-extractor**](https://github.com/jobertabma/relative-url-extractor) (ruby): Беручи файл (HTML), витягує URL за допомогою регулярних виразів, щоб знайти і витягти відносні URL з мінімізованих файлів.
- [**JSFScan**](https://github.com/KathanP19/JSFScan.sh) (bash, several tools): Збирає цікаву інформацію з JS файлів, використовуючи кілька інструментів.
- [**subjs**](https://github.com/lc/subjs) (go): Знаходить JS файли.
- [**page-fetch**](https://github.com/detectify/page-fetch) (go): Завантажує сторінку в headless browser і виводить всі URL, які були завантажені для рендерингу сторінки.
- [**Feroxbuster**](https://github.com/epi052/feroxbuster) (rust): Інструмент для discovery вмісту, що поєднує декілька опцій попередніх інструментів.
- [**Javascript Parsing**](https://github.com/xnl-h4ck3r/burp-extensions): Burp extension для пошуку шляхів та параметрів в JS файлах.
- [**Sourcemapper**](https://github.com/denandz/sourcemapper): Інструмент, який за .js.map URL надає beautified JS код.
- [**xnLinkFinder**](https://github.com/xnl-h4ck3r/xnLinkFinder): Інструмент для виявлення endpoint'ів для заданої цілі.
- [**waymore**](https://github.com/xnl-h4ck3r/waymore)**:** Виявляє посилання з wayback machine (також завантажуючи відповіді у wayback і шукаючи більше посилань).
- [**HTTPLoot**](https://github.com/redhuntlabs/HTTPLoot) (go): Краулер (навіть з заповненням форм) і також знаходить чутливу інформацію за допомогою специфічних regex'ів.
- [**SpiderSuite**](https://github.com/3nock/SpiderSuite): Spider Suite — розширений GUI web security Crawler/Spider для професіоналів з кібербезпеки.
- [**jsluice**](https://github.com/BishopFox/jsluice) (go): Go package і [command-line tool](https://github.com/BishopFox/jsluice/blob/main/cmd/jsluice) для витягування URL, шляхів, секретів та іншої цікавої інформації з JavaScript коду.
- [**ParaForge**](https://github.com/Anof-cyber/ParaForge): Простий **Burp Suite extension** для **витягування параметрів та endpoint'ів** з запитів для створення кастомних wordlist'ів для fuzzing та enumeration.
- [**katana**](https://github.com/projectdiscovery/katana) (go): Чудовий інструмент для цього.
- [**Crawley**](https://github.com/s0rg/crawley) (go): Виводить кожне посилання, яке йому вдалося знайти.

### Brute Force directories and files

Розпочніть **brute-forcing** з root каталогу і переконайтесь, що ви brute-force'ите **всі** **знайдені директорії**, використовуючи **цей метод**, а також усі директорії, **виявлені** під час **Spidering** (можна робити brute-forcing **рекурсивно**, додаючи на початок використаного wordlist імена знайдених директорій).\
Інструменти:

- **Dirb** / **Dirbuster** - Включені в Kali, **старі** (і **повільні**), але функціональні. Підтримують self-signed сертифікати та рекурсивний пошук. Надто повільні у порівнянні з іншими опціями.
- [**Dirsearch**](https://github.com/maurosoria/dirsearch) (python)**: Не дозволяє self-signed сертифікати, але** дозволяє рекурсивний пошук.
- [**Gobuster**](https://github.com/OJ/gobuster) (go): Підтримує self-signed сертифікати, але **не** має **рекурсивного** пошуку.
- [**Feroxbuster**](https://github.com/epi052/feroxbuster) **- Fast, supports recursive search.**
- [**wfuzz**](https://github.com/xmendez/wfuzz) `wfuzz -w /usr/share/seclists/Discovery/Web-Content/raft-medium-directories.txt https://domain.com/api/FUZZ`
- [**ffuf** ](https://github.com/ffuf/ffuf)- Fast: `ffuf -c -w /usr/share/wordlists/dirb/big.txt -u http://10.10.10.10/FUZZ`
- [**uro**](https://github.com/s0md3v/uro) (python): Це не spider, але інструмент, який, беручи список знайдених URL, видаляє "дубльовані" URL.
- [**Scavenger**](https://github.com/0xDexter0us/Scavenger): Burp Extension для створення списку директорій із історії Burp для різних сторінок.
- [**TrashCompactor**](https://github.com/michael1026/trashcompactor): Видаляє URL з дубльованою функціональністю (на основі js імпортів).
- [**Chamaleon**](https://github.com/iustin24/chameleon): Використовує Wappalyzer для визначення використовуваних технологій і підбору відповідних wordlist'ів.

Рекомендовані словники:

- [https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/bf_directories.txt](https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/bf_directories.txt)
- [**Dirsearch** included dictionary](https://github.com/maurosoria/dirsearch/blob/master/db/dicc.txt)
- [http://gist.github.com/jhaddix/b80ea67d85c13206125806f0828f4d10](http://gist.github.com/jhaddix/b80ea67d85c13206125806f0828f4d10)
- [Assetnote wordlists](https://wordlists.assetnote.io)
- [https://github.com/danielmiessler/SecLists/tree/master/Discovery/Web-Content](https://github.com/danielmiessler/SecLists/tree/master/Discovery/Web-Content)
- raft-large-directories-lowercase.txt
- directory-list-2.3-medium.txt
- RobotsDisallowed/top10000.txt
- [https://github.com/random-robbie/bruteforce-lists](https://github.com/random-robbie/bruteforce-lists)
- [https://github.com/google/fuzzing/tree/master/dictionaries](https://github.com/google/fuzzing/tree/master/dictionaries)
- [https://github.com/six2dez/OneListForAll](https://github.com/six2dez/OneListForAll)
- [https://github.com/random-robbie/bruteforce-lists](https://github.com/random-robbie/bruteforce-lists)
- [https://github.com/ayoubfathi/leaky-paths](https://github.com/ayoubfathi/leaky-paths)
- _/usr/share/wordlists/dirb/common.txt_
- _/usr/share/wordlists/dirb/big.txt_
- _/usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt_

_Зверніть увагу, що щоразу, коли під час brute-forcing або spidering виявляється нова директорія, її слід Brute-Force'ити._

### What to check on each file found

- [**Broken link checker**](https://github.com/stevenvachon/broken-link-checker): Знаходить биті посилання в HTML, які можуть бути піддатливими до takeover.
- **File Backups**: Після того як ви знайшли всі файли, шукайте бекапи виконуваних файлів ("_.php_", "_.aspx_"...). Поширені варіації іменування бекапів: _file.ext\~, #file.ext#, \~file.ext, file.ext.bak, file.ext.tmp, file.ext.old, file.bak, file.tmp and file.old._ Можна також використати інструмент [**bfac**](https://github.com/mazen160/bfac) **або** [**backup-gen**](https://github.com/Nishantbhagat57/backup-gen)**.**
- **Discover new parameters**: Можна використати інструменти як [**Arjun**](https://github.com/s0md3v/Arjun)**,** [**parameth**](https://github.com/maK-/parameth)**,** [**x8**](https://github.com/sh1yo/x8) **та** [**Param Miner**](https://github.com/PortSwigger/param-miner) **для виявлення прихованих параметрів. За можливості намагайтесь шукати** приховані параметри в кожному виконуваному web файлі.
- _Arjun all default wordlists:_ [https://github.com/s0md3v/Arjun/tree/master/arjun/db](https://github.com/s0md3v/Arjun/tree/master/arjun/db)
- _Param-miner “params” :_ [https://github.com/PortSwigger/param-miner/blob/master/resources/params](https://github.com/PortSwigger/param-miner/blob/master/resources/params)
- _Assetnote “parameters_top_1m”:_ [https://wordlists.assetnote.io/](https://wordlists.assetnote.io)
- _nullenc0de “params.txt”:_ [https://gist.github.com/nullenc0de/9cb36260207924f8e1787279a05eb773](https://gist.github.com/nullenc0de/9cb36260207924f8e1787279a05eb773)
- **Comments:** Перевіряйте коментарі у всіх файлах — там можна знайти **credentials** або **приховану функціональність**.
- Якщо ви граєте в **CTF**, "поширений" трюк — **сховати** **інформацію** всередині коментарів праворуч на сторінці (використовуючи **сотні** пробілів, щоб не бачити дані при відкритті вихідного коду в браузері). Інша можливість — використати **декілька нових рядків** і **сховати інформацію** в коментарі в **низу** веб-сторінки.
- **API keys**: Якщо ви **знайдете API key**, є гайди, які показують як використовувати ключі для різних платформ: [**keyhacks**](https://github.com/streaak/keyhacks)**,** [**zile**](https://github.com/xyele/zile.git)**,** [**truffleHog**](https://github.com/trufflesecurity/truffleHog)**,** [**SecretFinder**](https://github.com/m4ll0k/SecretFinder)**,** [**RegHex**](<https://github.com/l4yton/RegHex)/>)**,** [**DumpsterDive**](https://github.com/securing/DumpsterDiver)**,** [**EarlyBird**](https://github.com/americanexpress/earlybird)
- Google API keys: Якщо знайдете API key, що починається з **AIza**SyA-qLheq6xjDiEIRisP_ujUseYLQCHUjik, можна використати проект [**gmapapiscanner**](https://github.com/ozguralp/gmapsapiscanner) щоб перевірити, до яких API має доступ ключ.
- **S3 Buckets**: Під час spidering перевіряйте, чи будь-який **subdomain** або **посилання** повʼязані з якимись **S3 bucket**. У такому випадку [**перевірте** права доступу бакету](buckets/index.html).

### Special findings

Під час виконання **spidering** та **brute-forcing** ви можете знайти **цікаві** **елементи**, які слід **зафіксувати**.

Interesting files

- Шукайте **посилання** на інші файли всередині **CSS** файлів.
- [Якщо знайдете _**.git**_, можна витягти деяку інформацію](git.md)
- Якщо знайдете _**.env**_, можна знайти такі дані як api keys, паролі до БД та іншу інформацію.
- Якщо знайдете **API endpoints**, вам слід [також протестувати їх](web-api-pentesting.md). Це не файли, але вони, ймовірно, "виглядатимуть" як такі.
- **JS files**: У секції spidering згадувалось декілька інструментів для витягування шляхів з JS файлів. Також цікаво **моніторити кожен знайдений JS файл**, оскільки іноді зміна може вказувати на появу потенційної вразливості в коді. Можна використати, наприклад, [**JSMon**](https://github.com/robre/jsmon)**.**
- Варто також перевіряти знайдені JS файли за допомогою [**RetireJS**](https://github.com/retirejs/retire.js/) або [**JSHole**](https://github.com/callforpapers-source/jshole) на наявність вразливостей.
- **Javascript Deobfuscator and Unpacker:** [https://lelinhtinh.github.io/de4js/](https://lelinhtinh.github.io/de4js/), [https://www.dcode.fr/javascript-unobfuscator](https://www.dcode.fr/javascript-unobfuscator)
- **Javascript Beautifier:** [http://jsbeautifier.org/](https://beautifier.io), [http://jsnice.org/](http://jsnice.org)
- **JsFuck deobfuscation** (javascript with chars:"\[]!+" [https://enkhee-osiris.github.io/Decoder-JSFuck/](https://enkhee-osiris.github.io/Decoder-JSFuck/))
- **TrainFuck**](https://github.com/taco-cy/trainfuck)**:** `+72.+29.+7..+3.-67.-12.+55.+24.+3.-6.-8.-67.-23.`
- У багатьох випадках вам знадобиться **розуміти регулярні вирази**, які використовуються. Це буде корисно: [https://regex101.com/](https://regex101.com) або [https://pythonium.net/regex](https://pythonium.net/regex)
- Також можна **моніторити файли, де були виявлені форми**, оскільки зміна параметрів або поява нової форми може вказувати на потенційну нову вразливість.

**403 Forbidden/Basic Authentication/401 Unauthorized (bypass)**


{{#ref}}
403-and-401-bypasses.md
{{#endref}}

**502 Proxy Error**

Якщо будь-яка сторінка відповідає цим кодом, ймовірно має місце **погано налаштований proxy**. **Якщо ви надішлете HTTP запит типу: `GET https://google.com HTTP/1.1`** (з Host header та іншими звичними заголовками), **proxy** спробує **доступитися** до _**google.com**_ **і ви знайдете** SSRF.

**NTLM Authentication - Info disclosure**

Якщо сервер, що вимагає аутентифікацію, працює на **Windows** або ви знайдете логін, що просить ваші **credentials** (і просить **domain** **name**), ви можете спровокувати **витік інформації**.\
**Надішліть** заголовок: `“Authorization: NTLM TlRMTVNTUAABAAAAB4IIAAAAAAAAAAAAAAAAAAAAAAA=”` і через особливості роботи **NTLM authentication**, сервер відповість внутрішньою інформацією (версія IIS, версія Windows...) в заголовку "WWW-Authenticate".\
Можна автоматизувати це за допомогою nmap плагіна "_http-ntlm-info.nse_".

**HTTP Redirect (CTF)**

У редиректі можна **запхати контент**. Цей контент **не буде показаний користувачу** (оскільки браузер виконає редирект), але там може бути **схована** інформація.

### Web Vulnerabilities Checking

Тепер, коли проведено комплексну енумерацію веб-застосунку, час перевірити багато можливих вразливостей. Чекліст доступний тут:


{{#ref}}
../../pentesting-web/web-vulnerabilities-methodology.md
{{#endref}}

Детальніше про web vulns:

- [https://six2dez.gitbook.io/pentest-book/others/web-checklist](https://six2dez.gitbook.io/pentest-book/others/web-checklist)
- [https://kennel209.gitbooks.io/owasp-testing-guide-v4/content/en/web_application_security_testing/configuration_and_deployment_management_testing.html](https://kennel209.gitbooks.io/owasp-testing-guide-v4/content/en/web_application_security_testing/configuration_and_deployment_management_testing.html)
- [https://owasp-skf.gitbook.io/asvs-write-ups/kbid-111-client-side-template-injection](https://owasp-skf.gitbook.io/asvs-write-ups/kbid-111-client-side-template-injection)

### Monitor Pages for changes

Можна використовувати інструменти на кшталт [https://github.com/dgtlmoon/changedetection.io](https://github.com/dgtlmoon/changedetection.io) для моніторингу сторінок на предмет змін, які можуть вставити вразливості.

### HackTricks Automatic Commands
```
Protocol_Name: Web    #Protocol Abbreviation if there is one.
Port_Number:  80,443     #Comma separated if there is more than one.
Protocol_Description: Web         #Protocol Abbreviation Spelled out

Entry_1:
Name: Notes
Description: Notes for Web
Note: |
https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/index.html

Entry_2:
Name: Quick Web Scan
Description: Nikto and GoBuster
Command: nikto -host {Web_Proto}://{IP}:{Web_Port} &&&& gobuster dir -w {Small_Dirlist} -u {Web_Proto}://{IP}:{Web_Port} && gobuster dir -w {Big_Dirlist} -u {Web_Proto}://{IP}:{Web_Port}

Entry_3:
Name: Nikto
Description: Basic Site Info via Nikto
Command: nikto -host {Web_Proto}://{IP}:{Web_Port}

Entry_4:
Name: WhatWeb
Description: General purpose auto scanner
Command: whatweb -a 4 {IP}

Entry_5:
Name: Directory Brute Force Non-Recursive
Description:  Non-Recursive Directory Brute Force
Command: gobuster dir -w {Big_Dirlist} -u {Web_Proto}://{IP}:{Web_Port}

Entry_6:
Name: Directory Brute Force Recursive
Description: Recursive Directory Brute Force
Command: python3 {Tool_Dir}dirsearch/dirsearch.py -w {Small_Dirlist} -e php,exe,sh,py,html,pl -f -t 20 -u {Web_Proto}://{IP}:{Web_Port} -r 10

Entry_7:
Name: Directory Brute Force CGI
Description: Common Gateway Interface Brute Force
Command: gobuster dir -u {Web_Proto}://{IP}:{Web_Port}/ -w /usr/share/seclists/Discovery/Web-Content/CGIs.txt -s 200

Entry_8:
Name: Nmap Web Vuln Scan
Description: Tailored Nmap Scan for web Vulnerabilities
Command: nmap -vv --reason -Pn -sV -p {Web_Port} --script=`banner,(http* or ssl*) and not (brute or broadcast or dos or external or http-slowloris* or fuzzer)` {IP}

Entry_9:
Name: Drupal
Description: Drupal Enumeration Notes
Note: |
git clone https://github.com/immunIT/drupwn.git for low hanging fruit and git clone https://github.com/droope/droopescan.git for deeper enumeration

Entry_10:
Name: WordPress
Description: WordPress Enumeration with WPScan
Command: |
?What is the location of the wp-login.php? Example: /Yeet/cannon/wp-login.php
wpscan --url {Web_Proto}://{IP}{1} --enumerate ap,at,cb,dbe && wpscan --url {Web_Proto}://{IP}{1} --enumerate u,tt,t,vp --passwords {Big_Passwordlist} -e

Entry_11:
Name: WordPress Hydra Brute Force
Description: Need User (admin is default)
Command: hydra -l admin -P {Big_Passwordlist} {IP} -V http-form-post '/wp-login.php:log=^USER^&pwd=^PASS^&wp-submit=Log In&testcookie=1:S=Location'

Entry_12:
Name: Ffuf Vhost
Description: Simple Scan with Ffuf for discovering additional vhosts
Command: ffuf -w {Subdomain_List}:FUZZ -u {Web_Proto}://{Domain_Name} -H "Host:FUZZ.{Domain_Name}" -c -mc all {Ffuf_Filters}
```
{{#include ../../banners/hacktricks-training.md}}
