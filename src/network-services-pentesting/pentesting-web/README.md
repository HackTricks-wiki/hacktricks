# 80,443 - Pentesting Web Methodology

{{#include ../../banners/hacktricks-training.md}}

## Basic Info

Η υπηρεσία ιστού είναι η πιο **συνηθισμένη και εκτενή υπηρεσία** και υπάρχουν πολλές **διαφορετικοί τύποι ευπαθειών**.

**Προεπιλεγμένη θύρα:** 80 (HTTP), 443(HTTPS)
```bash
PORT    STATE SERVICE
80/tcp  open  http
443/tcp open  ssl/https
```

```bash
nc -v domain.com 80 # GET / HTTP/1.0
openssl s_client -connect domain.com:443 # GET / HTTP/1.0
```
### Οδηγίες Web API

{{#ref}}
web-api-pentesting.md
{{#endref}}

## Περίληψη Μεθοδολογίας

> Σε αυτή τη μεθοδολογία θα υποθέσουμε ότι θα επιτεθείτε σε ένα domain (ή subdomain) και μόνο σε αυτό. Έτσι, θα πρέπει να εφαρμόσετε αυτή τη μεθοδολογία σε κάθε ανακαλυφθέν domain, subdomain ή IP με ακαθόριστο web server εντός του πεδίου εφαρμογής.

- [ ] Ξεκινήστε με την **ταυτοποίηση** των **τεχνολογιών** που χρησιμοποιούνται από τον web server. Αναζητήστε **κόλπα** που να έχετε υπόψη σας κατά τη διάρκεια της υπόλοιπης δοκιμής αν μπορείτε να ταυτοποιήσετε επιτυχώς την τεχνολογία.
- [ ] Υπάρχει κάποια **γνωστή ευπάθεια** της έκδοσης της τεχνολογίας;
- [ ] Χρησιμοποιείτε κάποια **γνωστή τεχνολογία**; Υπάρχει κάποιο **χρήσιμο κόλπο** για να εξάγετε περισσότερες πληροφορίες;
- [ ] Υπάρχει κάποιος **ειδικευμένος σαρωτής** που να τρέξει (όπως το wpscan);
- [ ] Ξεκινήστε με **γενικούς σαρωτές**. Ποτέ δεν ξέρετε αν θα βρουν κάτι ή αν θα βρουν κάποιες ενδιαφέρουσες πληροφορίες.
- [ ] Ξεκινήστε με τους **αρχικούς ελέγχους**: **robots**, **sitemap**, **σφάλμα 404** και **σάρωση SSL/TLS** (αν είναι HTTPS).
- [ ] Ξεκινήστε **spidering** τη σελίδα: Είναι ώρα να **βρείτε** όλα τα πιθανά **αρχεία, φακέλους** και **παραμέτρους που χρησιμοποιούνται.** Επίσης, ελέγξτε για **ειδικές ανακαλύψεις**.
- [ ] _Σημειώστε ότι κάθε φορά που ανακαλύπτεται ένας νέος φάκελος κατά τη διάρκεια του brute-forcing ή του spidering, θα πρέπει να γίνει spidering._
- [ ] **Brute-Forcing Φακέλων**: Προσπαθήστε να κάνετε brute force σε όλους τους ανακαλυφθέντες φακέλους αναζητώντας νέα **αρχεία** και **φακέλους**.
- [ ] _Σημειώστε ότι κάθε φορά που ανακαλύπτεται ένας νέος φάκελος κατά τη διάρκεια του brute-forcing ή του spidering, θα πρέπει να γίνει Brute-Forced._
- [ ] **Έλεγχος Αντιγράφων**: Δοκιμάστε αν μπορείτε να βρείτε **αντίγραφα** των **ανακαλυφθέντων αρχείων** προσθέτοντας κοινές επεκτάσεις αντιγράφων.
- [ ] **Brute-Force παράμετροι**: Προσπαθήστε να **βρείτε κρυφές παραμέτρους**.
- [ ] Μόλις έχετε **ταυτοποιήσει** όλα τα πιθανά **endpoints** που δέχονται **είσοδο χρήστη**, ελέγξτε για κάθε είδους **ευπάθειες** που σχετίζονται με αυτό.
- [ ] [Ακολουθήστε αυτή τη λίστα ελέγχου](../../pentesting-web/web-vulnerabilities-methodology.md)

## Έκδοση Server (Ευάλωτη;)

### Ταυτοποίηση

Ελέγξτε αν υπάρχουν **γνωστές ευπάθειες** για την **έκδοση** του server που τρέχει.\
Οι **HTTP headers και τα cookies της απάντησης** θα μπορούσαν να είναι πολύ χρήσιμα για να **ταυτοποιήσετε** τις **τεχνολογίες** και/ή την **έκδοση** που χρησιμοποιείται. Η **σάρωση Nmap** μπορεί να ταυτοποιήσει την έκδοση του server, αλλά θα μπορούσαν επίσης να είναι χρήσιμα τα εργαλεία [**whatweb**](https://github.com/urbanadventurer/WhatWeb)**,** [**webtech** ](https://github.com/ShielderSec/webtech)ή [**https://builtwith.com/**](https://builtwith.com)**:**
```bash
whatweb -a 1 <URL> #Stealthy
whatweb -a 3 <URL> #Aggresive
webtech -u <URL>
webanalyze -host https://google.com -crawl 2
```
Αναζητήστε **για** [**ευπάθειες της έκδοσης της διαδικτυακής εφαρμογής**](../../generic-hacking/search-exploits.md)

### **Ελέγξτε αν υπάρχει WAF**

- [**https://github.com/EnableSecurity/wafw00f**](https://github.com/EnableSecurity/wafw00f)
- [**https://github.com/Ekultek/WhatWaf.git**](https://github.com/Ekultek/WhatWaf.git)
- [**https://nmap.org/nsedoc/scripts/http-waf-detect.html**](https://nmap.org/nsedoc/scripts/http-waf-detect.html)

### Τεχνάσματα διαδικτύου

Ορισμένα **τεχνάσματα** για **να βρείτε ευπάθειες** σε διάφορες γνωστές **τεχνολογίες** που χρησιμοποιούνται:

- [**AEM - Adobe Experience Cloud**](aem-adobe-experience-cloud.md)
- [**Apache**](apache.md)
- [**Artifactory**](artifactory-hacking-guide.md)
- [**Buckets**](buckets/)
- [**CGI**](cgi.md)
- [**Drupal**](drupal/)
- [**Flask**](flask.md)
- [**Git**](git.md)
- [**Golang**](golang.md)
- [**GraphQL**](graphql.md)
- [**H2 - Java SQL database**](h2-java-sql-database.md)
- [**IIS tricks**](iis-internet-information-services.md)
- [**JBOSS**](jboss.md)
- [**Jenkins**](<[https:/github.com/carlospolop/hacktricks/blob/master/network-services-pentesting/pentesting-web/broken-reference/README.md](https:/github.com/HackTricks-wiki/hacktricks-cloud/tree/master/pentesting-ci-cd/jenkins-security)/>)
- [**Jira**](jira.md)
- [**Joomla**](joomla.md)
- [**JSP**](jsp.md)
- [**Laravel**](laravel.md)
- [**Moodle**](moodle.md)
- [**Nginx**](nginx.md)
- [**PHP (το php έχει πολλά ενδιαφέροντα τρικ που θα μπορούσαν να εκμεταλλευτούν)**](php-tricks-esp/)
- [**Python**](python.md)
- [**Spring Actuators**](spring-actuators.md)
- [**Symphony**](symphony.md)
- [**Tomcat**](tomcat/)
- [**VMWare**](vmware-esx-vcenter....md)
- [**Web API Pentesting**](web-api-pentesting.md)
- [**WebDav**](put-method-webdav.md)
- [**Werkzeug**](werkzeug.md)
- [**Wordpress**](wordpress.md)
- [**Electron Desktop (XSS σε RCE)**](electron-desktop-apps/)

_Λάβετε υπόψη ότι το **ίδιο domain** μπορεί να χρησιμοποιεί **διαφορετικές τεχνολογίες** σε διαφορετικές **θύρες**, **φακέλους** και **subdomains**._\
Εάν η διαδικτυακή εφαρμογή χρησιμοποιεί οποιαδήποτε γνωστή **τεχνολογία/πλατφόρμα που αναφέρεται παραπάνω** ή **οποιαδήποτε άλλη**, μην ξεχάσετε να **αναζητήσετε στο Διαδίκτυο** νέες τεχνικές (και ενημερώστε με!).

### Ανασκόπηση Πηγαίου Κώδικα

Εάν ο **πηγαίος κώδικας** της εφαρμογής είναι διαθέσιμος στο **github**, εκτός από την εκτέλεση ενός **White box test** της εφαρμογής, υπάρχει **ορισμένες πληροφορίες** που θα μπορούσαν να είναι **χρήσιμες** για την τρέχουσα **Black-Box testing**:

- Υπάρχει κάποιο **Change-log ή Readme ή Version** αρχείο ή οτιδήποτε με **πληροφορίες έκδοσης προσβάσιμες** μέσω διαδικτύου;
- Πώς και πού αποθηκεύονται τα **credentials**; Υπάρχει κάποιο (προσβάσιμο;) **αρχείο** με credentials (ονόματα χρηστών ή κωδικούς πρόσβασης);
- Είναι οι **κωδικοί πρόσβασης** σε **καθαρό κείμενο**, **κρυπτογραφημένοι** ή ποιος **αλγόριθμος κατακερματισμού** χρησιμοποιείται;
- Χρησιμοποιεί κάποιο **master key** για την κρυπτογράφηση κάποιου πράγματος; Ποιος **αλγόριθμος** χρησιμοποιείται;
- Μπορείτε να **πρόσβαση σε οποιοδήποτε από αυτά τα αρχεία** εκμεταλλευόμενοι κάποια ευπάθεια;
- Υπάρχει κάποια **ενδιαφέρουσα πληροφορία στο github** (λυμένα και μη λυμένα) **ζητήματα**; Ή στην **ιστορία commit** (ίσως κάποιο **password που εισήχθη σε ένα παλιό commit**) ;

{{#ref}}
code-review-tools.md
{{#endref}}

### Αυτόματοι σαρωτές

#### Αυτόματοι σαρωτές γενικής χρήσης
```bash
nikto -h <URL>
whatweb -a 4 <URL>
wapiti -u <URL>
W3af
zaproxy #You can use an API
nuclei -ut && nuclei -target <URL>

# https://github.com/ignis-sec/puff (client side vulns fuzzer)
node puff.js -w ./wordlist-examples/xss.txt -u "http://www.xssgame.com/f/m4KKGHi2rVUN/?query=FUZZ"
```
#### CMS scanners

Αν χρησιμοποιείται ένα CMS, μην ξεχάσετε να **τρέξετε έναν σαρωτή**, ίσως βρείτε κάτι ενδιαφέρον:

[**Clusterd**](https://github.com/hatRiot/clusterd)**:** [**JBoss**](jboss.md)**, ColdFusion, WebLogic,** [**Tomcat**](tomcat/)**, Railo, Axis2, Glassfish**\
[**CMSScan**](https://github.com/ajinabraham/CMSScan): [**WordPress**](wordpress.md), [**Drupal**](drupal/), **Joomla**, **vBulletin** ιστοσελίδες για θέματα Ασφαλείας. (GUI)\
[**VulnX**](https://github.com/anouarbensaad/vulnx)**:** [**Joomla**](joomla.md)**,** [**Wordpress**](wordpress.md)**,** [**Drupal**](drupal/)**, PrestaShop, Opencart**\
**CMSMap**: [**(W)ordpress**](wordpress.md)**,** [**(J)oomla**](joomla.md)**,** [**(D)rupal**](drupal/) **ή** [**(M)oodle**](moodle.md)\
[**droopscan**](https://github.com/droope/droopescan)**:** [**Drupal**](drupal/)**,** [**Joomla**](joomla.md)**,** [**Moodle**](moodle.md)**, Silverstripe,** [**Wordpress**](wordpress.md)
```bash
cmsmap [-f W] -F -d <URL>
wpscan --force update -e --url <URL>
joomscan --ec -u <URL>
joomlavs.rb #https://github.com/rastating/joomlavs
```
> Σε αυτό το σημείο θα πρέπει ήδη να έχετε κάποιες πληροφορίες για τον web server που χρησιμοποιεί ο πελάτης (αν έχουν δοθεί δεδομένα) και μερικά κόλπα που πρέπει να έχετε κατά νου κατά τη διάρκεια της δοκιμής. Αν είστε τυχεροί, μπορεί να έχετε βρει ακόμη και ένα CMS και να έχετε τρέξει κάποιο scanner.

## Βήμα-βήμα Ανακάλυψη Εφαρμογής Ιστού

> Από αυτό το σημείο θα αρχίσουμε να αλληλεπιδρούμε με την εφαρμογή ιστού.

### Αρχικές ελέγχοι

**Προεπιλεγμένες σελίδες με ενδιαφέροντα πληροφορίες:**

- /robots.txt
- /sitemap.xml
- /crossdomain.xml
- /clientaccesspolicy.xml
- /.well-known/
- Ελέγξτε επίσης τα σχόλια στις κύριες και δευτερεύουσες σελίδες.

**Εξαναγκασμός σφαλμάτων**

Οι web servers μπορεί να **συμπεριφέρονται απροσδόκητα** όταν τους αποστέλλονται περίεργα δεδομένα. Αυτό μπορεί να ανοίξει **ευπάθειες** ή **να αποκαλύψει ευαίσθητες πληροφορίες**.

- Πρόσβαση σε **ψεύτικες σελίδες** όπως /whatever_fake.php (.aspx,.html,.κ.λπ.)
- **Προσθέστε "\[]", "]]", και "\[\["** στις **τιμές cookie** και **τιμές παραμέτρων** για να δημιουργήσετε σφάλματα
- Δημιουργήστε σφάλμα δίνοντας είσοδο ως **`/~randomthing/%s`** στο **τέλος** της **διεύθυνσης URL**
- Δοκιμάστε **διαφορετικά HTTP Verbs** όπως PATCH, DEBUG ή λάθος όπως FAKE

#### **Ελέγξτε αν μπορείτε να ανεβάσετε αρχεία (**[**PUT verb, WebDav**](put-method-webdav.md)**)**

Αν διαπιστώσετε ότι το **WebDav** είναι **ενεργοποιημένο** αλλά δεν έχετε αρκετές άδειες για **ανέβασμα αρχείων** στον ριζικό φάκελο, προσπαθήστε να:

- **Brute Force** διαπιστευτήρια
- **Ανεβάστε αρχεία** μέσω WebDav στους **υπόλοιπους** **βρεθέντες φακέλους** μέσα στην ιστοσελίδα. Μπορεί να έχετε άδειες να ανεβάσετε αρχεία σε άλλους φακέλους.

### **SSL/TLS ευπάθειες**

- Αν η εφαρμογή **δεν αναγκάζει τον χρήστη να χρησιμοποιεί HTTPS** σε κανένα σημείο, τότε είναι **ευάλωτη σε MitM**
- Αν η εφαρμογή **αποστέλλει ευαίσθητα δεδομένα (κωδικούς πρόσβασης) χρησιμοποιώντας HTTP**. Τότε είναι μια υψηλή ευπάθεια.

Χρησιμοποιήστε [**testssl.sh**](https://github.com/drwetter/testssl.sh) για να ελέγξετε για **ευπάθειες** (Στα προγράμματα Bug Bounty πιθανώς αυτές οι ευπάθειες δεν θα γίνουν αποδεκτές) και χρησιμοποιήστε [**a2sv** ](https://github.com/hahwul/a2sv) για να επανελέγξετε τις ευπάθειες:
```bash
./testssl.sh [--htmlfile] 10.10.10.10:443
#Use the --htmlfile to save the output inside an htmlfile also

# You can also use other tools, by testssl.sh at this momment is the best one (I think)
sslscan <host:port>
sslyze --regular <ip:port>
```
Πληροφορίες σχετικά με τις ευπάθειες SSL/TLS:

- [https://www.gracefulsecurity.com/tls-ssl-vulnerabilities/](https://www.gracefulsecurity.com/tls-ssl-vulnerabilities/)
- [https://www.acunetix.com/blog/articles/tls-vulnerabilities-attacks-final-part/](https://www.acunetix.com/blog/articles/tls-vulnerabilities-attacks-final-part/)

### Spidering

Εκκινήστε κάποιο είδος **spider** μέσα στο διαδίκτυο. Ο στόχος του spider είναι να **βρει όσο το δυνατόν περισσότερους δρόμους** από την εφαρμογή που δοκιμάζεται. Επομένως, θα πρέπει να χρησιμοποιηθούν web crawling και εξωτερικές πηγές για να βρείτε όσο το δυνατόν περισσότερους έγκυρους δρόμους.

- [**gospider**](https://github.com/jaeles-project/gospider) (go): HTML spider, LinkFinder σε αρχεία JS και εξωτερικές πηγές (Archive.org, CommonCrawl.org, VirusTotal.com, AlienVault.com).
- [**hakrawler**](https://github.com/hakluke/hakrawler) (go): HML spider, με LinkFinder για αρχεία JS και Archive.org ως εξωτερική πηγή.
- [**dirhunt**](https://github.com/Nekmo/dirhunt) (python): HTML spider, υποδεικνύει επίσης "juicy files".
- [**evine** ](https://github.com/saeeddhqan/evine)(go): Διαδραστικός CLI HTML spider. Αναζητά επίσης στο Archive.org.
- [**meg**](https://github.com/tomnomnom/meg) (go): Αυτό το εργαλείο δεν είναι spider αλλά μπορεί να είναι χρήσιμο. Μπορείτε απλώς να υποδείξετε ένα αρχείο με hosts και ένα αρχείο με paths και το meg θα ανακτήσει κάθε path σε κάθε host και θα αποθηκεύσει την απάντηση.
- [**urlgrab**](https://github.com/IAmStoxe/urlgrab) (go): HTML spider με δυνατότητες απόδοσης JS. Ωστόσο, φαίνεται ότι δεν συντηρείται, η προcompiled έκδοση είναι παλιά και ο τρέχων κώδικας δεν συντάσσεται.
- [**gau**](https://github.com/lc/gau) (go): HTML spider που χρησιμοποιεί εξωτερικούς παρόχους (wayback, otx, commoncrawl).
- [**ParamSpider**](https://github.com/devanshbatham/ParamSpider): Αυτό το script θα βρει URLs με παραμέτρους και θα τα καταγράψει.
- [**galer**](https://github.com/dwisiswant0/galer) (go): HTML spider με δυνατότητες απόδοσης JS.
- [**LinkFinder**](https://github.com/GerbenJavado/LinkFinder) (python): HTML spider, με δυνατότητες beautify JS ικανές να αναζητούν νέους δρόμους σε αρχεία JS. Θα άξιζε επίσης να ρίξετε μια ματιά στο [JSScanner](https://github.com/dark-warlord14/JSScanner), το οποίο είναι ένα wrapper του LinkFinder.
- [**goLinkFinder**](https://github.com/0xsha/GoLinkFinder) (go): Για την εξαγωγή endpoints τόσο από HTML πηγή όσο και από ενσωματωμένα αρχεία javascript. Χρήσιμο για κυνηγούς σφαλμάτων, red teamers, infosec ninjas.
- [**JSParser**](https://github.com/nahamsec/JSParser) (python2.7): Ένα script python 2.7 που χρησιμοποιεί Tornado και JSBeautifier για να αναλύσει σχετικές URLs από αρχεία JavaScript. Χρήσιμο για την εύκολη ανακάλυψη AJAX αιτημάτων. Φαίνεται ότι δεν συντηρείται.
- [**relative-url-extractor**](https://github.com/jobertabma/relative-url-extractor) (ruby): Δίνοντας ένα αρχείο (HTML) θα εξάγει URLs από αυτό χρησιμοποιώντας έξυπνη κανονική έκφραση για να βρει και να εξάγει τις σχετικές URLs από άσχημα (minify) αρχεία.
- [**JSFScan**](https://github.com/KathanP19/JSFScan.sh) (bash, διάφορα εργαλεία): Συγκεντρώνει ενδιαφέρουσες πληροφορίες από αρχεία JS χρησιμοποιώντας διάφορα εργαλεία.
- [**subjs**](https://github.com/lc/subjs) (go): Βρείτε αρχεία JS.
- [**page-fetch**](https://github.com/detectify/page-fetch) (go): Φορτώστε μια σελίδα σε έναν headless browser και εκτυπώστε όλες τις URLs που φορτώθηκαν για να φορτώσετε τη σελίδα.
- [**Feroxbuster**](https://github.com/epi052/feroxbuster) (rust): Εργαλείο ανακάλυψης περιεχομένου που συνδυάζει πολλές επιλογές των προηγούμενων εργαλείων.
- [**Javascript Parsing**](https://github.com/xnl-h4ck3r/burp-extensions): Μια επέκταση Burp για να βρείτε δρόμους και παραμέτρους σε αρχεία JS.
- [**Sourcemapper**](https://github.com/denandz/sourcemapper): Ένα εργαλείο που δίνοντας το URL .js.map θα σας δώσει τον beautified κώδικα JS.
- [**xnLinkFinder**](https://github.com/xnl-h4ck3r/xnLinkFinder): Αυτό είναι ένα εργαλείο που χρησιμοποιείται για την ανακάλυψη endpoints για έναν δεδομένο στόχο.
- [**waymore**](https://github.com/xnl-h4ck3r/waymore)**:** Ανακαλύψτε συνδέσμους από τη μηχανή wayback (κατεβάζοντας επίσης τις απαντήσεις στη wayback και αναζητώντας περισσότερους συνδέσμους).
- [**HTTPLoot**](https://github.com/redhuntlabs/HTTPLoot) (go): Crawl (ακόμη και συμπληρώνοντας φόρμες) και επίσης βρείτε ευαίσθητες πληροφορίες χρησιμοποιώντας συγκεκριμένες κανονικές εκφράσεις.
- [**SpiderSuite**](https://github.com/3nock/SpiderSuite): Το Spider Suite είναι ένα προηγμένο multi-feature GUI web security Crawler/Spider σχεδιασμένο για επαγγελματίες κυβερνοασφάλειας.
- [**jsluice**](https://github.com/BishopFox/jsluice) (go): Είναι ένα πακέτο Go και [εργαλείο γραμμής εντολών](https://github.com/BishopFox/jsluice/blob/main/cmd/jsluice) για την εξαγωγή URLs, δρόμων, μυστικών και άλλων ενδιαφερόντων δεδομένων από τον πηγαίο κώδικα JavaScript.
- [**ParaForge**](https://github.com/Anof-cyber/ParaForge): Το ParaForge είναι μια απλή **επέκταση Burp Suite** για **να εξάγει τις παραμέτρους και τα endpoints** από το αίτημα για να δημιουργήσει προσαρμοσμένες λίστες λέξεων για fuzzing και αρίθμηση.
- [**katana**](https://github.com/projectdiscovery/katana) (go): Καταπληκτικό εργαλείο για αυτό.
- [**Crawley**](https://github.com/s0rg/crawley) (go): Εκτυπώνει κάθε σύνδεσμο που μπορεί να βρει.

### Brute Force directories and files

Ξεκινήστε **brute-forcing** από τον ριζικό φάκελο και βεβαιωθείτε ότι θα brute-force **όλους** τους **φακέλους που βρέθηκαν** χρησιμοποιώντας **αυτή τη μέθοδο** και όλους τους φακέλους **που ανακαλύφθηκαν** από το **Spidering** (μπορείτε να κάνετε αυτό το brute-forcing **αναδρομικά** και προσθέτοντας στην αρχή της χρησιμοποιούμενης λίστας λέξεων τα ονόματα των βρεθέντων φακέλων).\
Εργαλεία:

- **Dirb** / **Dirbuster** - Συμπεριλαμβάνεται στο Kali, **παλιό** (και **αργό**) αλλά λειτουργικό. Επιτρέπει αυτόματα υπογεγραμμένα πιστοποιητικά και αναδρομική αναζήτηση. Πολύ αργό σε σύγκριση με τις άλλες επιλογές.
- [**Dirsearch**](https://github.com/maurosoria/dirsearch) (python)**: Δεν επιτρέπει αυτόματα υπογεγραμμένα πιστοποιητικά αλλά** επιτρέπει αναδρομική αναζήτηση.
- [**Gobuster**](https://github.com/OJ/gobuster) (go): Επιτρέπει αυτόματα υπογεγραμμένα πιστοποιητικά, **δεν έχει** **αναδρομική** αναζήτηση.
- [**Feroxbuster**](https://github.com/epi052/feroxbuster) **- Γρήγορο, υποστηρίζει αναδρομική αναζήτηση.**
- [**wfuzz**](https://github.com/xmendez/wfuzz) `wfuzz -w /usr/share/seclists/Discovery/Web-Content/raft-medium-directories.txt https://domain.com/api/FUZZ`
- [**ffuf** ](https://github.com/ffuf/ffuf)- Γρήγορο: `ffuf -c -w /usr/share/wordlists/dirb/big.txt -u http://10.10.10.10/FUZZ`
- [**uro**](https://github.com/s0md3v/uro) (python): Αυτό δεν είναι spider αλλά ένα εργαλείο που δίνοντας τη λίστα των βρεθέντων URLs θα διαγράψει τα "διπλά" URLs.
- [**Scavenger**](https://github.com/0xDexter0us/Scavenger): Επέκταση Burp για να δημιουργήσει μια λίστα φακέλων από την ιστορία burp διαφόρων σελίδων.
- [**TrashCompactor**](https://github.com/michael1026/trashcompactor): Αφαιρεί URLs με διπλές λειτουργίες (βάσει js imports).
- [**Chamaleon**](https://github.com/iustin24/chameleon): Χρησιμοποιεί το wapalyzer για να ανιχνεύσει τις χρησιμοποιούμενες τεχνολογίες και να επιλέξει τις λίστες λέξεων που θα χρησιμοποιηθούν.

**Συνιστώμενα λεξικά:**

- [https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/bf_directories.txt](https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/bf_directories.txt)
- [**Dirsearch** included dictionary](https://github.com/maurosoria/dirsearch/blob/master/db/dicc.txt)
- [http://gist.github.com/jhaddix/b80ea67d85c13206125806f0828f4d10](http://gist.github.com/jhaddix/b80ea67d85c13206125806f0828f4d10)
- [Assetnote wordlists](https://wordlists.assetnote.io)
- [https://github.com/danielmiessler/SecLists/tree/master/Discovery/Web-Content](https://github.com/danielmiessler/SecLists/tree/master/Discovery/Web-Content)
- raft-large-directories-lowercase.txt
- directory-list-2.3-medium.txt
- RobotsDisallowed/top10000.txt
- [https://github.com/random-robbie/bruteforce-lists](https://github.com/random-robbie/bruteforce-lists)
- [https://github.com/google/fuzzing/tree/master/dictionaries](https://github.com/google/fuzzing/tree/master/dictionaries)
- [https://github.com/six2dez/OneListForAll](https://github.com/six2dez/OneListForAll)
- [https://github.com/random-robbie/bruteforce-lists](https://github.com/random-robbie/bruteforce-lists)
- [https://github.com/ayoubfathi/leaky-paths](https://github.com/ayoubfathi/leaky-paths)
- _/usr/share/wordlists/dirb/common.txt_
- _/usr/share/wordlists/dirb/big.txt_
- _/usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt_

_Σημειώστε ότι κάθε φορά που ανακαλύπτεται ένας νέος φάκελος κατά τη διάρκεια του brute-forcing ή του spidering, θα πρέπει να γίνει Brute-Forced._

### Τι να ελέγξετε σε κάθε αρχείο που βρέθηκε

- [**Broken link checker**](https://github.com/stevenvachon/broken-link-checker): Βρείτε σπασμένους συνδέσμους μέσα σε HTML που μπορεί να είναι επιρρεπείς σε καταλήψεις.
- **Αντίγραφα αρχείων**: Μόλις βρείτε όλα τα αρχεία, αναζητήστε αντίγραφα όλων των εκτελέσιμων αρχείων ("_.php_", "_.aspx_"...). Κοινές παραλλαγές για την ονομασία ενός αντιγράφου είναι: _file.ext\~, #file.ext#, \~file.ext, file.ext.bak, file.ext.tmp, file.ext.old, file.bak, file.tmp και file.old._ Μπορείτε επίσης να χρησιμοποιήσετε το εργαλείο [**bfac**](https://github.com/mazen160/bfac) **ή** [**backup-gen**](https://github.com/Nishantbhagat57/backup-gen)**.**
- **Ανακαλύψτε νέες παραμέτρους**: Μπορείτε να χρησιμοποιήσετε εργαλεία όπως [**Arjun**](https://github.com/s0md3v/Arjun)**,** [**parameth**](https://github.com/maK-/parameth)**,** [**x8**](https://github.com/sh1yo/x8) **και** [**Param Miner**](https://github.com/PortSwigger/param-miner) **για να ανακαλύψετε κρυφές παραμέτρους. Αν μπορείτε, θα μπορούσατε να προσπαθήσετε να αναζητήσετε** κρυφές παραμέτρους σε κάθε εκτελέσιμο αρχείο web.
- _Arjun all default wordlists:_ [https://github.com/s0md3v/Arjun/tree/master/arjun/db](https://github.com/s0md3v/Arjun/tree/master/arjun/db)
- _Param-miner “params” :_ [https://github.com/PortSwigger/param-miner/blob/master/resources/params](https://github.com/PortSwigger/param-miner/blob/master/resources/params)
- _Assetnote “parameters_top_1m”:_ [https://wordlists.assetnote.io/](https://wordlists.assetnote.io)
- _nullenc0de “params.txt”:_ [https://gist.github.com/nullenc0de/9cb36260207924f8e1787279a05eb773](https://gist.github.com/nullenc0de/9cb36260207924f8e1787279a05eb773)
- **Σχόλια:** Ελέγξτε τα σχόλια όλων των αρχείων, μπορείτε να βρείτε **credentials** ή **κρυφή λειτουργικότητα**.
- Αν παίζετε **CTF**, ένα "κοινό" κόλπο είναι να **κρύβετε** **πληροφορίες** μέσα σε σχόλια στα **δεξιά** της **σελίδας** (χρησιμοποιώντας **εκατοντάδες** **κενά** ώστε να μην βλέπετε τα δεδομένα αν ανοίξετε τον πηγαίο κώδικα με τον browser). Μια άλλη δυνατότητα είναι να χρησιμοποιήσετε **πολλές νέες γραμμές** και να **κρύψετε πληροφορίες** σε ένα σχόλιο στο **κάτω μέρος** της ιστοσελίδας.
- **API keys**: Αν **βρείτε οποιοδήποτε API key** υπάρχει οδηγός που υποδεικνύει πώς να χρησιμοποιήσετε API keys διαφόρων πλατφορμών: [**keyhacks**](https://github.com/streaak/keyhacks)**,** [**zile**](https://github.com/xyele/zile.git)**,** [**truffleHog**](https://github.com/trufflesecurity/truffleHog)**,** [**SecretFinder**](https://github.com/m4ll0k/SecretFinder)**,** [**RegHex**](<https://github.com/l4yton/RegHex)/>)**,** [**DumpsterDive**](https://github.com/securing/DumpsterDiver)**,** [**EarlyBird**](https://github.com/americanexpress/earlybird).
- Google API keys: Αν βρείτε οποιοδήποτε API key που μοιάζει με **AIza**SyA-qLheq6xjDiEIRisP_ujUseYLQCHUjik μπορείτε να χρησιμοποιήσετε το έργο [**gmapapiscanner**](https://github.com/ozguralp/gmapsapiscanner) για να ελέγξετε ποιες APIs μπορεί να έχει πρόσβαση το key.
- **S3 Buckets**: Κατά τη διάρκεια του spidering ελέγξτε αν οποιοδήποτε **subdomain** ή οποιοσδήποτε **σύνδεσμος** σχετίζεται με κάποιο **S3 bucket**. Σε αυτή την περίπτωση, [**ελέγξτε** τις **άδειες** του bucket](buckets/).

### Ειδικές ανακαλύψεις

**Κατά τη διάρκεια** της **spidering** και του **brute-forcing** μπορεί να βρείτε **ενδιαφέροντα** **πράγματα** που πρέπει να **σημειώσετε**.

**Ενδιαφέροντα αρχεία**

- Αναζητήστε **συνδέσμους** σε άλλα αρχεία μέσα στα **CSS** αρχεία.
- [Αν βρείτε ένα _**.git**_ αρχείο μπορεί να εξαχθεί κάποια πληροφορία](git.md).
- Αν βρείτε ένα _**.env**_ πληροφορίες όπως api keys, κωδικούς db και άλλες πληροφορίες μπορεί να βρεθούν.
- Αν βρείτε **API endpoints** θα [πρέπει επίσης να τα δοκιμάσετε](web-api-pentesting.md). Αυτά δεν είναι αρχεία, αλλά πιθανότατα θα "μοιάζουν" με αυτά.
- **JS αρχεία**: Στην ενότητα spidering αναφέρθηκαν διάφορα εργαλεία που μπορούν να εξάγουν δρόμους από αρχεία JS. Επίσης, θα ήταν ενδιαφέρον να **παρακολουθείτε κάθε JS αρχείο που βρέθηκε**, καθώς σε ορισμένες περιπτώσεις, μια αλλαγή μπορεί να υποδηλώνει ότι μια πιθανή ευπάθεια εισήχθη στον κώδικα. Μπορείτε να χρησιμοποιήσετε για παράδειγμα [**JSMon**](https://github.com/robre/jsmon)**.**
- Πρέπει επίσης να ελέγξετε τα ανακαλυφθέντα JS αρχεία με [**RetireJS**](https://github.com/retirejs/retire.js/) ή [**JSHole**](https://github.com/callforpapers-source/jshole) για να δείτε αν είναι ευάλωτα.
- **Javascript Deobfuscator and Unpacker:** [https://lelinhtinh.github.io/de4js/](https://lelinhtinh.github.io/de4js/), [https://www.dcode.fr/javascript-unobfuscator](https://www.dcode.fr/javascript-unobfuscator).
- **Javascript Beautifier:** [http://jsbeautifier.org/](https://beautifier.io), [http://jsnice.org/](http://jsnice.org).
- **JsFuck deobfuscation** (javascript με χαρακτήρες:"\[]!+" [https://enkhee-osiris.github.io/Decoder-JSFuck/](https://enkhee-osiris.github.io/Decoder-JSFuck/)).
- [**TrainFuck**](https://github.com/taco-c/trainfuck)**:** `+72.+29.+7..+3.-67.-12.+55.+24.+3.-6.-8.-67.-23.`
- Σε πολλές περιπτώσεις, θα χρειαστεί να **κατανοήσετε τις κανονικές εκφράσεις** που χρησιμοποιούνται. Αυτό θα είναι χρήσιμο: [https://regex101.com/](https://regex101.com) ή [https://pythonium.net/regex](https://pythonium.net/regex).
- Μπορείτε επίσης να **παρακολουθείτε τα αρχεία όπου ανιχνεύθηκαν φόρμες**, καθώς μια αλλαγή στην παράμετρο ή η εμφάνιση μιας νέας φόρμας μπορεί να υποδηλώνει μια πιθανή νέα ευάλωτη λειτουργία.

**403 Forbidden/Basic Authentication/401 Unauthorized (bypass)**

{{#ref}}
403-and-401-bypasses.md
{{#endref}}

**502 Proxy Error**

Αν οποιαδήποτε σελίδα **απαντά** με αυτόν τον **κωδικό**, είναι πιθανό να είναι μια **κακώς ρυθμισμένη proxy**. **Αν στείλετε ένα HTTP αίτημα όπως: `GET https://google.com HTTP/1.1`** (με την κεφαλίδα host και άλλες κοινές κεφαλίδες), η **proxy** θα προσπαθήσει να **πρόσβαση** _**google.com**_ **και θα έχετε βρει μια** SSRF.

**NTLM Authentication - Info disclosure**

Αν ο τρέχων server που ζητάει αυθεντικοποίηση είναι **Windows** ή αν βρείτε μια είσοδο που ζητάει τα **credentials** σας (και ζητάει το **domain** **name**), μπορείτε να προκαλέσετε μια **διαρροή πληροφοριών**.\
**Στείλτε** την **κεφαλίδα**: `“Authorization: NTLM TlRMTVNTUAABAAAAB4IIAAAAAAAAAAAAAAAAAAAAAAA=”` και λόγω του πώς λειτουργεί η **NTLM αυθεντικοποίηση**, ο server θα απαντήσει με εσωτερικές πληροφορίες (έκδοση IIS, έκδοση Windows...) μέσα στην κεφαλίδα "WWW-Authenticate".\
Μπορείτε να **αυτοματοποιήσετε** αυτό χρησιμοποιώντας το **nmap plugin** "_http-ntlm-info.nse_".

**HTTP Redirect (CTF)**

Είναι δυνατόν να **τοποθετήσετε περιεχόμενο** μέσα σε μια **Redirection**. Αυτό το περιεχόμενο **δεν θα εμφανιστεί στον χρήστη** (καθώς ο browser θα εκτελέσει την ανακατεύθυνση) αλλά κάτι θα μπορούσε να είναι **κρυμμένο** εκεί.

### Έλεγχος ευπαθειών Web

Τώρα που έχει γίνει μια εκτενής αρίθμηση της web εφαρμογής, είναι καιρός να ελέγξετε για πολλές πιθανές ευπάθειες. Μπορείτε να βρείτε τη λίστα ελέγχου εδώ:

{{#ref}}
../../pentesting-web/web-vulnerabilities-methodology.md
{{#endref}}

Βρείτε περισσότερες πληροφορίες σχετικά με τις ευπάθειες web στο:

- [https://six2dez.gitbook.io/pentest-book/others/web-checklist](https://six2dez.gitbook.io/pentest-book/others/web-checklist)
- [https://kennel209.gitbooks.io/owasp-testing-guide-v4/content/en/web_application_security_testing/configuration_and_deployment_management_testing.html](https://kennel209.gitbooks.io/owasp-testing-guide-v4/content/en/web_application_security_testing/configuration_and_deployment_management_testing.html)
- [https://owasp-skf.gitbook.io/asvs-write-ups/kbid-111-client-side-template-injection](https://owasp-skf.gitbook.io/asvs-write-ups/kbid-111-client-side-template-injection)

### Παρακολούθηση Σελίδων για αλλαγές

Μπορείτε να χρησιμοποιήσετε εργαλεία όπως [https://github.com/dgtlmoon/changedetection.io](https://github.com/dgtlmoon/changedetection.io) για να παρακολουθείτε σελίδες για τροποποιήσεις που μπορεί να εισάγουν ευπάθειες.

### HackTricks Αυτόματες Εντολές
```
Protocol_Name: Web    #Protocol Abbreviation if there is one.
Port_Number:  80,443     #Comma separated if there is more than one.
Protocol_Description: Web         #Protocol Abbreviation Spelled out

Entry_1:
Name: Notes
Description: Notes for Web
Note: |
https://book.hacktricks.xyz/pentesting/pentesting-web

Entry_2:
Name: Quick Web Scan
Description: Nikto and GoBuster
Command: nikto -host {Web_Proto}://{IP}:{Web_Port} &&&& gobuster dir -w {Small_Dirlist} -u {Web_Proto}://{IP}:{Web_Port} && gobuster dir -w {Big_Dirlist} -u {Web_Proto}://{IP}:{Web_Port}

Entry_3:
Name: Nikto
Description: Basic Site Info via Nikto
Command: nikto -host {Web_Proto}://{IP}:{Web_Port}

Entry_4:
Name: WhatWeb
Description: General purpose auto scanner
Command: whatweb -a 4 {IP}

Entry_5:
Name: Directory Brute Force Non-Recursive
Description:  Non-Recursive Directory Brute Force
Command: gobuster dir -w {Big_Dirlist} -u {Web_Proto}://{IP}:{Web_Port}

Entry_6:
Name: Directory Brute Force Recursive
Description: Recursive Directory Brute Force
Command: python3 {Tool_Dir}dirsearch/dirsearch.py -w {Small_Dirlist} -e php,exe,sh,py,html,pl -f -t 20 -u {Web_Proto}://{IP}:{Web_Port} -r 10

Entry_7:
Name: Directory Brute Force CGI
Description: Common Gateway Interface Brute Force
Command: gobuster dir -u {Web_Proto}://{IP}:{Web_Port}/ -w /usr/share/seclists/Discovery/Web-Content/CGIs.txt -s 200

Entry_8:
Name: Nmap Web Vuln Scan
Description: Tailored Nmap Scan for web Vulnerabilities
Command: nmap -vv --reason -Pn -sV -p {Web_Port} --script=`banner,(http* or ssl*) and not (brute or broadcast or dos or external or http-slowloris* or fuzzer)` {IP}

Entry_9:
Name: Drupal
Description: Drupal Enumeration Notes
Note: |
git clone https://github.com/immunIT/drupwn.git for low hanging fruit and git clone https://github.com/droope/droopescan.git for deeper enumeration

Entry_10:
Name: WordPress
Description: WordPress Enumeration with WPScan
Command: |
?What is the location of the wp-login.php? Example: /Yeet/cannon/wp-login.php
wpscan --url {Web_Proto}://{IP}{1} --enumerate ap,at,cb,dbe && wpscan --url {Web_Proto}://{IP}{1} --enumerate u,tt,t,vp --passwords {Big_Passwordlist} -e

Entry_11:
Name: WordPress Hydra Brute Force
Description: Need User (admin is default)
Command: hydra -l admin -P {Big_Passwordlist} {IP} -V http-form-post '/wp-login.php:log=^USER^&pwd=^PASS^&wp-submit=Log In&testcookie=1:S=Location'

Entry_12:
Name: Ffuf Vhost
Description: Simple Scan with Ffuf for discovering additional vhosts
Command: ffuf -w {Subdomain_List}:FUZZ -u {Web_Proto}://{Domain_Name} -H "Host:FUZZ.{Domain_Name}" -c -mc all {Ffuf_Filters}
```
{{#include ../../banners/hacktricks-training.md}}
