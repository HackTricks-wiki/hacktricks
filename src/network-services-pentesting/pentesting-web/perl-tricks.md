# PrestaShop

{{#include ../../banners/hacktricks-training.md}}

## Perl backticks/qx// sinks in Apache mod_perl handlers (reachability and exploitation)

वास्तविक दुनिया का पैटर्न: Perl कोड एक शेल कमांड स्ट्रिंग बनाता है और इसे backticks (or qx//) के माध्यम से execute करता है। In a mod_perl AccessHandler, attacker-controlled request components like $r->uri() उस स्ट्रिंग में फ्लो कर सकते हैं। यदि किसी भी शाखा में raw input concatenate करके फिर shell के साथ evaluate किया जाए, तो आपको pre-auth RCE मिल जाता है।

Risky Perl execution primitives (spawn a shell when given a single string):
- Backticks / qx//: my $out = `cmd ...`;
- system with a single string: system("/bin/sh -c '...'") implicitly
- open with a pipe: open my $fh, "cmd |" or "| cmd"
- IPC::Open3 with a single string

Minimal vulnerable shape observed in the wild:
```perl
sub getCASURL {
...
my $exec_cmd = "...";
if ($type eq 'login') {
$exec_cmd .= $uri;        # $uri from $r->uri() → attacker-controlled
my $out = `$exec_cmd`;    # backticks = shell
}
}
```
mod_perl में पहुँच से संबंधित प्रमुख विचार:
- Handler registration: httpd.conf को यह सुनिश्चित करना चाहिए कि अनुरोध आपके Perl मॉड्यूल में रूट हों, उदाहरण के लिए PerlModule MOD_SEC_EMC::AccessHandler और वह कॉन्फ़िगरेशन जो किसी path scope के लिए AccessHandler::handler को कॉल करता हो।
- Triggering the vulnerable branch: अनधिकृत login flow को मजबूर करें ताकि type == "login" हो (उदा., अपेक्षित auth cookie को छोड़ दें)।
- Resolvable path: सुनिश्चित करें कि आपकी request उस URI को लक्षित करती है जो कॉन्फ़िगर किए गए scope के भीतर resolve होती हो। अगर Apache कभी request को handler के माध्यम से route नहीं करता, तो sink तक नहीं पहुंचा जाएगा।

Exploitation workflow
1) Inspect httpd.conf for PerlModule/MOD_PERL handler scopes to find a resolvable path processed by the handler.
2) Send an unauthenticated request so the login redirect path is taken (type == "login").
3) Place shell metacharacters in the request-URI path so $r->uri() carries your payload into the command string.

Example HTTP PoC (path injection via ';')
```http
GET /ui/health;id HTTP/1.1
Host: target
Connection: close
```
Tips
- separators आज़माएँ: ;, &&, |, `backticks`, $(...), और encoded newlines (%0A) quoting पर निर्भर करता है।
- अगर पुराने patches में किसी ब्रांच में अन्य args quote किए गए हों लेकिन URI नहीं, तो payloads string के अंत में जोड़ने पर अक्सर काम करते हैं: ;id# या &&/usr/bin/id#

Hardening (Perl)
- shell strings न बनाएं। argument-vector execution पसंद करें: system('/usr/bin/curl', '--silent', '--', $safe_url) — कोई shell नहीं।
- अगर shell अनिवार्य है, तो सभी ब्रांच में सख्ती और एकरूपता से escape करें; $r->uri() को hostile मानें। paths/queries के लिए URI::Escape और मजबूत allowlists पर विचार करें।
- command execution के लिए backticks/qx// से बचें; अगर वास्तव में जरूरत हो तो बिना shell invoke किए output को open3/list form के जरिए कैप्चर करें।
- mod_perl handlers में, auth/redirect code paths को command execution से मुक्त रखें या सभी ब्रांच में identical sanitization सुनिश्चित करें ताकि “fixed everywhere but one branch” जैसे regressions न हों।

Vulnerability hunting
- उन modules के patch-diff देखें जो shell commands assemble करते हैं; ब्रांचों के बीच inconsistent quoting देखें (उदा., if ($type eq 'login') जो unescaped रह गया हो)।
- backticks, qx//, open\s*\(|\||, और system\s*\(\s*" के लिए grep करें ताकि string-based shells मिल सकें। sink से request entry ($r) तक call graph बनाकर pre-auth reachability सत्यापित करें।

Real-world case: Dell UnityVSA pre-auth RCE (CVE-2025-36604)
- Pre-auth command injection backticks के जरिए AccessTool.pm:getCASURL में जब type == "login" हो और raw $uri ($r->uri()) concatenate किया गया हो।
- पहुंच योग्य था: MOD_SEC_EMC::AccessHandler → make_return_address($r) → getCASLoginURL(..., type="login") → getCASURL(..., $uri, 'login').
- Practical nuance: handler द्वारा कवर किया गया एक resolvable path उपयोग करें; अन्यथा module execute नहीं होगा और sink hit नहीं होगा।

## References

- [It’s Never Simple Until It Is: Dell UnityVSA Pre‑Auth Command Injection (CVE‑2025‑36604)](https://labs.watchtowr.com/its-never-simple-until-it-is-dell-unityvsa-pre-auth-command-injection-cve-2025-36604/)
- [Dell PSIRT DSA‑2025‑281 – Security update for Dell Unity/UnityVSA/Unity XT](https://www.dell.com/support/kbdoc/en-uk/000350756/dsa-2025-281-security-update-for-dell-unity-dell-unityvsa-and-dell-unity-xt-security-update-for-multiple-vulnerabilities)
- [watchTowr Detection Artefact Generator – Dell UnityVSA Pre‑Auth CVE‑2025‑36604](https://github.com/watchtowrlabs/watchTowr-vs-Dell-UnityVSA-PreAuth-CVE-2025-36604)

{{#include ../../banners/hacktricks-training.md}}
