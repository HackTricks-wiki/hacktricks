# PrestaShop

{{#include ../../banners/hacktricks-training.md}}

## Perl backticks/qx// sinks in Apache mod_perl handlers (reachability and exploitation)

実際のパターン: Perlコードがシェルコマンド文字列を構築し、backticks (または qx//) で実行します。mod_perl AccessHandler 内では、$r->uri() のような攻撃者制御のリクエスト要素がその文字列に流入する可能性があります。どの分岐でも生の入力を連結してシェルで評価すると、pre-auth RCE を引き起こします。

Risky Perl execution primitives (spawn a shell when given a single string):
- Backticks / qx//: my $out = `cmd ...`;
- system with a single string: system("/bin/sh -c '...'") implicitly
- open with a pipe: open my $fh, "cmd |" or "| cmd"
- IPC::Open3 with a single string

Minimal vulnerable shape observed in the wild:
```perl
sub getCASURL {
...
my $exec_cmd = "...";
if ($type eq 'login') {
$exec_cmd .= $uri;        # $uri from $r->uri() → attacker-controlled
my $out = `$exec_cmd`;    # backticks = shell
}
}
```
mod_perl における到達性の重要な考慮点:
- ハンドラの登録: httpd.conf はリクエストをあなたの Perl モジュールにルーティングする必要があります。例えば PerlModule MOD_SEC_EMC::AccessHandler と、特定のパススコープで AccessHandler::handler を呼び出す設定などです。
- 脆弱な分岐のトリガー: 未認証のログインフローを強制して type == "login" にする（例: 期待される auth cookie を省略する）。
- 解決可能なパス: リクエストが設定済みのスコープ内で解決される URI をターゲットにしていることを確認してください。Apache がそのリクエストをハンドラ経由でルーティングしない場合、sink に到達しません。

Exploitation workflow
1) httpd.conf を調査して、PerlModule/MOD_PERL のハンドラ範囲を確認し、ハンドラで処理される解決可能なパスを見つける。
2) 未認証のリクエストを送ってログインリダイレクトのパスを通らせる（type == "login"）。
3) リクエスト URI パスにシェルのメタ文字を入れ、$r->uri() がペイロードをコマンド文字列に運ぶようにする。

Example HTTP PoC (path injection via ';')
```http
GET /ui/health;id HTTP/1.1
Host: target
Connection: close
```
ヒント
- セパレータを試す: ;, &&, |, `backticks`, $(...), およびエンコードされた改行 (%0A) — 引用の仕方によって変わる。
- もし以前のパッチが他の引数を引用しているがあるブランチで URI を引用していない場合、文字列の末尾に付けたペイロードが機能することが多い: ;id# or &&/usr/bin/id#

ハードニング (Perl)
- shell文字列を構築しない。引数ベクトル実行を優先: system('/usr/bin/curl', '--silent', '--', $safe_url) — no shell.
- shell が避けられない場合は、すべてのブランチで厳格かつ一貫してエスケープすること；$r->uri() を敵対的入力として扱う。パス/クエリには URI::Escape の使用や強力な allowlists を検討する。
- コマンド実行に backticks/qx// を使わない；本当に必要な場合は shell を呼び出さずに open3/list 形式で出力を取得すること。
- mod_perl ハンドラでは、auth/redirect のコードパスをコマンド実行から解放するか、ブランチ間で同一のサニタイズを保証して「他は全部直っているが一つのブランチだけ直っていない」という回帰を避けること。

脆弱性ハンティング
- シェルコマンドを組み立てるモジュールのパッチ差分を確認する；ブランチ間での引用の不整合を探す（例: if ($type eq 'login') が未エスケープのまま残っているなど）。
- backticks, qx//, open\s*\(|\||, and system\s*\(\s*" を grep して文字列ベースのシェルを見つける。sink からリクエスト入口 ($r) までのコールグラフを構築して認証前に到達可能かを確認する。

実世界の事例: Dell UnityVSA pre-auth RCE (CVE-2025-36604)
- AccessTool.pm:getCASURL 内で type == "login" の場合に backticks を通した pre-auth コマンドインジェクション。生の $uri ($r->uri()) が連結されていた。
- MOD_SEC_EMC::AccessHandler → make_return_address($r) → getCASLoginURL(..., type="login") → getCASURL(..., $uri, 'login') を通って到達可能。
- 実務上の注意点: ハンドラで扱われる解決可能なパスを使うこと。そうでなければモジュールは実行されず、sink に到達しない。

## 参考資料

- [It’s Never Simple Until It Is: Dell UnityVSA Pre‑Auth Command Injection (CVE‑2025‑36604)](https://labs.watchtowr.com/its-never-simple-until-it-is-dell-unityvsa-pre-auth-command-injection-cve-2025-36604/)
- [Dell PSIRT DSA‑2025‑281 – Security update for Dell Unity/UnityVSA/Unity XT](https://www.dell.com/support/kbdoc/en-uk/000350756/dsa-2025-281-security-update-for-dell-unity-dell-unityvsa-and-dell-unity-xt-security-update-for-multiple-vulnerabilities)
- [watchTowr Detection Artefact Generator – Dell UnityVSA Pre‑Auth CVE‑2025‑36604](https://github.com/watchtowrlabs/watchTowr-vs-Dell-UnityVSA-PreAuth-CVE-2025-36604)

{{#include ../../banners/hacktricks-training.md}}
