# PrestaShop

{{#include ../../banners/hacktricks-training.md}}

## Perl backticks/qx// sinks in Apache mod_perl handlers (reachability and exploitation)

Modèle observé en conditions réelles : du code Perl construit une chaîne de commande shell et l'exécute via des backticks (ou qx//). Dans un mod_perl AccessHandler, des composants de requête contrôlés par l'attaquant comme $r->uri() peuvent s'écouler dans cette chaîne. Si une branche quelconque concatène une entrée brute puis l'évalue avec un shell, vous obtenez une pre-auth RCE.

Primitives d'exécution Perl risquées (ouvrent un shell lorsqu'on leur fournit une seule chaîne) :
- Backticks / qx//: my $out = `cmd ...`;
- system with a single string: system("/bin/sh -c '...'") implicitly
- open with a pipe: open my $fh, "cmd |" or "| cmd"
- IPC::Open3 with a single string

Forme minimale vulnérable observée en conditions réelles:
```perl
sub getCASURL {
...
my $exec_cmd = "...";
if ($type eq 'login') {
$exec_cmd .= $uri;        # $uri from $r->uri() → attacker-controlled
my $out = `$exec_cmd`;    # backticks = shell
}
}
```
Considérations clés d'atteignabilité dans mod_perl :
- Enregistrement du handler : httpd.conf doit router les requêtes vers votre module Perl, par ex. PerlModule MOD_SEC_EMC::AccessHandler et une configuration qui invoque AccessHandler::handler pour une portée de chemin.
- Déclenchement de la branche vulnérable : forcez le flux de login non authentifié pour que type == "login" (par ex., omettez le auth cookie attendu).
- Chemin résoluble : assurez-vous que votre requête cible une URI qui se résout dans la portée configurée. Si Apache ne route jamais la requête via le handler, le sink n'est pas atteint.

Exploitation workflow
1) Inspectez httpd.conf pour les scopes PerlModule/MOD_PERL du handler afin de trouver un chemin résoluble traité par le handler.
2) Envoyez une requête non authentifiée pour que le chemin de redirection de login soit pris (type == "login").
3) Placez des shell metacharacters dans le chemin request-URI pour que $r->uri() transporte votre payload dans la chaîne de commande.

Example HTTP PoC (path injection via ';')
```http
GET /ui/health;id HTTP/1.1
Host: target
Connection: close
```
Conseils
- Essayez des séparateurs : ;, &&, |, `backticks`, $(...), et des sauts de ligne encodés (%0A) selon la façon dont la chaîne est citée.
- Si des patches antérieurs mettent entre guillemets d'autres arguments mais pas l'URI dans une branche, les payloads ajoutés à la fin de la chaîne fonctionnent souvent : ;id# or &&/usr/bin/id#

Durcissement (Perl)
- Ne construisez pas de chaînes pour le shell. Préférez l'exécution avec vecteur d'arguments : system('/usr/bin/curl', '--silent', '--', $safe_url) — sans shell.
- Si un shell est inévitable, échappez strictement et de manière cohérente dans toutes les branches ; considérez $r->uri() comme hostile. Envisagez URI::Escape pour les chemins/queries et des allowlists strictes.
- Évitez les backticks/qx// pour l'exécution de commandes ; capturez la sortie via open3/list si vraiment nécessaire sans invoquer un shell.
- Dans les handlers mod_perl, maintenez les chemins de code auth/redirect sans exécution de commandes ou assurez une sanitisation identique entre les branches pour éviter les régressions du type « corrigé partout sauf dans une branche ».

Recherche de vulnérabilités
- Différenciez les patches des modules qui assemblent des commandes shell ; cherchez des guillemets incohérents entre branches (p.ex., if ($type eq 'login') laissé non échappé).
- Cherchez avec grep : backticks, qx//, open\s*\(|\||, et system\s*\(\s* pour trouver des shells basés sur des chaînes. Construisez un graphe d'appels du sink jusqu'à l'entrée de la requête ($r) pour vérifier l'atteignabilité pré-auth.

Cas réel : Dell UnityVSA pre-auth RCE (CVE-2025-36604)
- Injection de commande pré-auth via backticks dans AccessTool.pm:getCASURL lorsque type == "login" concaténait le $uri brut ($r->uri()).
- Accessible via MOD_SEC_EMC::AccessHandler → make_return_address($r) → getCASLoginURL(..., type="login") → getCASURL(..., $uri, 'login').
- Nuance pratique : utilisez un chemin résoluble pris en charge par le handler ; sinon le module ne s'exécutera pas et le sink ne sera pas atteint.

## Références

- [It’s Never Simple Until It Is: Dell UnityVSA Pre‑Auth Command Injection (CVE‑2025‑36604)](https://labs.watchtowr.com/its-never-simple-until-it-is-dell-unityvsa-pre-auth-command-injection-cve-2025-36604/)
- [Dell PSIRT DSA‑2025‑281 – Security update for Dell Unity/UnityVSA/Unity XT](https://www.dell.com/support/kbdoc/en-uk/000350756/dsa-2025-281-security-update-for-dell-unity-dell-unityvsa-and-dell-unity-xt-security-update-for-multiple-vulnerabilities)
- [watchTowr Detection Artefact Generator – Dell UnityVSA Pre‑Auth CVE‑2025‑36604](https://github.com/watchtowrlabs/watchTowr-vs-Dell-UnityVSA-PreAuth-CVE-2025-36604)

{{#include ../../banners/hacktricks-training.md}}
