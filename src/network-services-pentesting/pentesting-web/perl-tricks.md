# PrestaShop

{{#include ../../banners/hacktricks-training.md}}

## Perl backticks/qx// sinks in Apache mod_perl handlers (reachability and exploitation)

Patrón en el mundo real: el código Perl construye una cadena de comando y la ejecuta vía backticks (o qx//). En un mod_perl AccessHandler, componentes de la petición controlados por el atacante como $r->uri() pueden fluir hacia esa cadena. Si alguna rama concatena entrada sin sanear y luego la evalúa con un shell, obtienes pre-auth RCE.

Primitivas de ejecución de Perl riesgosas (generan un shell cuando se les pasa una única cadena):
- Backticks / qx//: my $out = `cmd ...`;
- system with a single string: system("/bin/sh -c '...'") implicitly
- open with a pipe: open my $fh, "cmd |" or "| cmd"
- IPC::Open3 with a single string

Minimal vulnerable shape observed in the wild:
```perl
sub getCASURL {
...
my $exec_cmd = "...";
if ($type eq 'login') {
$exec_cmd .= $uri;        # $uri from $r->uri() → attacker-controlled
my $out = `$exec_cmd`;    # backticks = shell
}
}
```
Consideraciones clave de alcanzabilidad en mod_perl:
- Handler registration: httpd.conf must route requests into your Perl module, e.g. PerlModule MOD_SEC_EMC::AccessHandler and configuration that invokes AccessHandler::handler for a path scope.
- Triggering the vulnerable branch: fuerza el flujo de login no autenticado para que type == "login" (p. ej., omite la cookie de autenticación esperada).
- Resolvable path: asegura que tu petición apunte a un URI que se resuelva dentro del ámbito configurado. Si Apache nunca enruta la petición a través del handler, el sink no se alcanza.

Exploitation workflow
1) Inspecciona httpd.conf en busca de ámbitos de handler PerlModule/MOD_PERL para encontrar una ruta resolvible procesada por el handler.
2) Envía una petición no autenticada para que se tome la ruta de redirección de login (type == "login").
3) Coloca metacaracteres de shell en la ruta request-URI para que $r->uri() lleve tu payload dentro de la cadena de comando.

Example HTTP PoC (path injection via ';')
```http
GET /ui/health;id HTTP/1.1
Host: target
Connection: close
```
Consejos
- Prueba separadores: ;, &&, |, `backticks`, $(...), y saltos de línea codificados (%0A) dependiendo del quoting.
- Si en parches anteriores se citan otros args pero no la URI en una rama, los payloads añadidos al final de la cadena suelen funcionar: ;id# or &&/usr/bin/id#

Endurecimiento (Perl)
- No construyas cadenas para el shell. Prefiere ejecución por vector de argumentos: system('/usr/bin/curl', '--silent', '--', $safe_url) — no shell.
- Si un shell es inevitable, escapa estricta y consistentemente en todas las ramas; trata $r->uri() como hostil. Considera URI::Escape para paths/queries y listas de permitidos estrictas.
- Evita backticks/qx// para ejecución de comandos; captura la salida vía open3/list si realmente es necesario sin invocar un shell.
- En handlers mod_perl, mantiene las rutas de código auth/redirect libres de ejecución de comandos o asegura una sanitización idéntica entre ramas para evitar regresiones del tipo “arreglado en todas partes salvo en una rama”.

Búsqueda de vulnerabilidades
- Haz diff de parches en módulos que ensamblan comandos para el shell; busca citación inconsistente entre ramas (p. ej., if ($type eq 'login') left unescaped).
- Haz grep de backticks, qx//, open\s*\(|\||, y system\s*\(\s* para encontrar shells basados en strings. Construye un grafo de llamadas desde el sink hasta la entrada de la request ($r) para verificar alcanzabilidad pre-auth.

Caso real: Dell UnityVSA pre-auth RCE (CVE-2025-36604)
- Inyección de comandos pre-auth vía backticks en AccessTool.pm:getCASURL cuando type == "login" concatenaba raw $uri ($r->uri()).
- Accesible a través de MOD_SEC_EMC::AccessHandler → make_return_address($r) → getCASLoginURL(..., type="login") → getCASURL(..., $uri, 'login').
- Matiz práctico: usa una ruta resoluble cubierta por el handler; de lo contrario el módulo no se ejecutará y el sink no será alcanzado.

## Referencias

- [It’s Never Simple Until It Is: Dell UnityVSA Pre‑Auth Command Injection (CVE‑2025‑36604)](https://labs.watchtowr.com/its-never-simple-until-it-is-dell-unityvsa-pre-auth-command-injection-cve-2025-36604/)
- [Dell PSIRT DSA‑2025‑281 – Security update for Dell Unity/UnityVSA/Unity XT](https://www.dell.com/support/kbdoc/en-uk/000350756/dsa-2025-281-security-update-for-dell-unity-dell-unityvsa-and-dell-unity-xt-security-update-for-multiple-vulnerabilities)
- [watchTowr Detection Artefact Generator – Dell UnityVSA Pre‑Auth CVE‑2025‑36604](https://github.com/watchtowrlabs/watchTowr-vs-Dell-UnityVSA-PreAuth-CVE-2025-36604)

{{#include ../../banners/hacktricks-training.md}}
