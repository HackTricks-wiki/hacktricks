# PrestaShop

{{#include ../../banners/hacktricks-training.md}}

## Perl backticks/qx// sinks in Apache mod_perl handlers (reachability and exploitation)

실제 사례 패턴: Perl 코드가 셸 명령 문자열을 생성하고 backticks (또는 qx//)를 통해 실행합니다. mod_perl AccessHandler에서는 $r->uri() 같은 공격자 제어 요청 구성 요소가 그 문자열로 흘러들어갈 수 있습니다. 어떤 분기에서 원시 입력을 단순히 이어붙이고 이를 셸로 평가하면 pre-auth RCE가 발생합니다.

Risky Perl execution primitives (spawn a shell when given a single string):
- Backticks / qx//: my $out = `cmd ...`;
- system with a single string: system("/bin/sh -c '...'") implicitly
- open with a pipe: open my $fh, "cmd |" or "| cmd"
- IPC::Open3 with a single string

Minimal vulnerable shape observed in the wild:
```perl
sub getCASURL {
...
my $exec_cmd = "...";
if ($type eq 'login') {
$exec_cmd .= $uri;        # $uri from $r->uri() → attacker-controlled
my $out = `$exec_cmd`;    # backticks = shell
}
}
```
mod_perl에서의 주요 도달성 고려사항:
- Handler 등록: httpd.conf가 요청을 Perl 모듈로 라우팅해야 합니다. 예: PerlModule MOD_SEC_EMC::AccessHandler 및 특정 경로 범위에 대해 AccessHandler::handler를 호출하도록 구성되어 있어야 합니다.
- 취약한 분기 트리거: 인증되지 않은 로그인 흐름을 강제하여 type == "login"이 되게 합니다(예: 예상되는 auth cookie를 생략).
- 해석 가능한 경로: 요청이 구성된 범위 내에서 해석되는 URI를 대상으로 하는지 확인하세요. Apache가 요청을 핸들러로 절대 라우팅하지 않으면 sink에 도달하지 않습니다.

Exploitation workflow
1) httpd.conf를 검사하여 PerlModule/MOD_PERL 핸들러 범위를 찾아 핸들러가 처리하는 해석 가능한 경로를 찾습니다.
2) 인증되지 않은 요청을 보내 로그인 리디렉트 경로가 선택되게 합니다 (type == "login").
3) 요청 URI 경로에 쉘 메타문자(shell metacharacters)를 삽입하여 $r->uri()가 페이로드를 명령 문자열로 전달하게 합니다.

예시 HTTP PoC (path injection via ';')
```http
GET /ui/health;id HTTP/1.1
Host: target
Connection: close
```
Tips
- 구분자들을 시도해보세요: ;, &&, |, `backticks`, $(...), 그리고 인용 방식에 따라 인코딩된 줄바꿈(%0A).
- 이전 패치가 다른 인자를 인용하지만 어떤 분기에서는 URI를 인용하지 않는 경우, 문자열 끝에 페이로드를 덧붙이면 종종 동작합니다: ;id# or &&/usr/bin/id#

Hardening (Perl)
- 쉘 문자열을 만들지 마세요. 인수 벡터 형태의 실행을 선호하세요: system('/usr/bin/curl', '--silent', '--', $safe_url) — 쉘을 사용하지 마세요.
- 쉘 사용이 불가피한 경우, 모든 분기에서 엄격하고 일관되게 이스케이프하세요; $r->uri()를 적대적 입력으로 취급하세요. 경로/쿼리에 대해서는 URI::Escape와 강력한 허용리스트 사용을 고려하세요.
- 명령 실행에 backticks/qx// 사용을 피하세요; 정말 필요하다면 쉘을 호출하지 않는 open3/list 형태로 출력을 캡처하세요.
- mod_perl 핸들러에서는 auth/redirect 코드 경로에서 명령 실행을 피하거나, 모든 분기에서 동일한 정제(또는 검증)를 보장해 "모두 고쳤지만 한 분기만 빠진" 회귀를 방지하세요.

Vulnerability hunting
- 쉘 명령을 조립하는 모듈의 패치-디프를 검사하세요; 분기 간 불일치하는 인용을 찾으세요(예: if ($type eq 'login')가 이스케이프되지 않은 경우).
- 문자열 기반 쉘을 찾기 위해 backticks, qx//, open\s*\(|\||, and system\s*\(\s*"를 grep하세요. sink부터 요청 진입($r)까지 호출 그래프를 만들어 pre-auth로 도달 가능한지 확인하세요.

Real-world case: Dell UnityVSA pre-auth RCE (CVE-2025-36604)
- Pre-auth command injection via backticks in AccessTool.pm:getCASURL when type == "login" concatenated raw $uri ($r->uri()).
- Reachable through MOD_SEC_EMC::AccessHandler → make_return_address($r) → getCASLoginURL(..., type="login") → getCASURL(..., $uri, 'login').
- Practical nuance: use a resolvable path covered by the handler; otherwise the module won’t execute and the sink won’t be hit.

## References

- [It’s Never Simple Until It Is: Dell UnityVSA Pre‑Auth Command Injection (CVE‑2025‑36604)](https://labs.watchtowr.com/its-never-simple-until-it-is-dell-unityvsa-pre-auth-command-injection-cve-2025-36604/)
- [Dell PSIRT DSA‑2025‑281 – Security update for Dell Unity/UnityVSA/Unity XT](https://www.dell.com/support/kbdoc/en-uk/000350756/dsa-2025-281-security-update-for-dell-unity-dell-unityvsa-and-dell-unity-xt-security-update-for-multiple-vulnerabilities)
- [watchTowr Detection Artefact Generator – Dell UnityVSA Pre‑Auth CVE‑2025‑36604](https://github.com/watchtowrlabs/watchTowr-vs-Dell-UnityVSA-PreAuth-CVE-2025-36604)

{{#include ../../banners/hacktricks-training.md}}
