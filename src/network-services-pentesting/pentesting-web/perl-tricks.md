# PrestaShop

{{#include ../../banners/hacktricks-training.md}}

## Perl backticks/qx// sinks in Apache mod_perl handlers (reachability and exploitation)

Wzorzec z rzeczywistego świata: Kod Perl konstruuje łańcuch polecenia powłoki i wykonuje go za pomocą backticks (lub qx//). W mod_perl AccessHandler elementy żądania kontrolowane przez atakującego, takie jak $r->uri(), mogą trafić do tego łańcucha. Jeśli w którymkolwiek miejscu surowe dane wejściowe są konkatenowane i następnie wykonywane przez powłokę, dochodzi do pre-auth RCE.

Risky Perl execution primitives (spawn a shell when given a single string):
- Backticks / qx//: my $out = `cmd ...`;
- system with a single string: system("/bin/sh -c '...'") implicitly
- open with a pipe: open my $fh, "cmd |" or "| cmd"
- IPC::Open3 with a single string

Minimalny podatny wzorzec zaobserwowany w praktyce:
```perl
sub getCASURL {
...
my $exec_cmd = "...";
if ($type eq 'login') {
$exec_cmd .= $uri;        # $uri from $r->uri() → attacker-controlled
my $out = `$exec_cmd`;    # backticks = shell
}
}
```
Kluczowe uwagi dotyczące dostępności w mod_perl:
- Rejestracja handlera: httpd.conf musi kierować żądania do twojego modułu Perl, np. PerlModule MOD_SEC_EMC::AccessHandler oraz konfiguracja, która wywołuje AccessHandler::handler dla zakresu ścieżki.
- Wywołanie podatnego fragmentu: wymuś przepływ logowania bez uwierzytelnienia tak, aby type == "login" (np. pominąć oczekiwany auth cookie).
- Rozwiązywalna ścieżka: upewnij się, że twoje żądanie celuje w URI, który rozwiązuje się w obrębie skonfigurowanego zakresu. Jeśli Apache nigdy nie kieruje żądania przez handler, sink nie zostanie osiągnięty.

Exploitation workflow
1) Przejrzyj httpd.conf w poszukiwaniu PerlModule/MOD_PERL i zakresów handlera, aby znaleźć rozwiązywalną ścieżkę przetwarzaną przez handler.
2) Wyślij żądanie bez uwierzytelnienia, aby został wybrany redirect logowania (type == "login").
3) Umieść metaznaki powłoki w ścieżce request-URI, tak aby $r->uri() przeniósł twój ładunek do ciągu polecenia.

Przykład HTTP PoC (path injection via ';')
```http
GET /ui/health;id HTTP/1.1
Host: target
Connection: close
```
Wskazówki
- Wypróbuj separatory: ;, &&, |, `backticks`, $(...), oraz zakodowane nowe linie (%0A) w zależności od sposobu cytowania.
- Jeśli wcześniejsze poprawki cytują inne argumenty, ale nie URI w jednej gałęzi, payloady dołączane na końcu ciągu często działają: ;id# or &&/usr/bin/id#

Hardening (Perl)
- Nie buduj stringów dla powłoki. Preferuj wykonanie w formie wektora argumentów: system('/usr/bin/curl', '--silent', '--', $safe_url) — bez powłoki.
- Jeśli powłoka jest nieunikniona, escapuj ściśle i konsekwentnie we wszystkich gałęziach; traktuj $r->uri() jako wrogi. Rozważ URI::Escape dla ścieżek/zapytań oraz stosowanie silnych allowlist.
- Unikaj backticks/qx// do wykonywania poleceń; przechwytuj wyjście przez open3/list form jeśli naprawdę potrzebne, bez wywoływania powłoki.
- W handlerach mod_perl trzymaj ścieżki auth/redirect wolne od wykonywania poleceń lub zapewnij identyczne sanitizowanie we wszystkich gałęziach, aby uniknąć regresji „fixed everywhere but one branch”.

Wyszukiwanie podatności
- Porównuj patch-diffy modułów, które składują komendy shell; szukaj niespójnego cytowania między gałęziami (np. if ($type eq 'login') pozostawione bez escapingu).
- Grep for backticks, qx//, open\s*\(|\||, and system\s*\(\s*" aby znaleźć string-based shells. Zbuduj graf wywołań od sink do punktu wejścia żądania ($r), aby zweryfikować osiągalność przed uwierzytelnieniem.

Real-world case: Dell UnityVSA pre-auth RCE (CVE-2025-36604)
- Pre-auth command injection via backticks in AccessTool.pm:getCASURL when type == "login" concatenated raw $uri ($r->uri()).
- Reachable through MOD_SEC_EMC::AccessHandler → make_return_address($r) → getCASLoginURL(..., type="login") → getCASURL(..., $uri, 'login').
- Practical nuance: use a resolvable path covered by the handler; otherwise the module won’t execute and the sink won’t be hit.

## Źródła

- [It’s Never Simple Until It Is: Dell UnityVSA Pre‑Auth Command Injection (CVE‑2025‑36604)](https://labs.watchtowr.com/its-never-simple-until-it-is-dell-unityvsa-pre-auth-command-injection-cve-2025-36604/)
- [Dell PSIRT DSA‑2025‑281 – Security update for Dell Unity/UnityVSA/Unity XT](https://www.dell.com/support/kbdoc/en-uk/000350756/dsa-2025-281-security-update-for-dell-unity-dell-unityvsa-and-dell-unity-xt-security-update-for-multiple-vulnerabilities)
- [watchTowr Detection Artefact Generator – Dell UnityVSA Pre‑Auth CVE‑2025‑36604](https://github.com/watchtowrlabs/watchTowr-vs-Dell-UnityVSA-PreAuth-CVE-2025-36604)

{{#include ../../banners/hacktricks-training.md}}
