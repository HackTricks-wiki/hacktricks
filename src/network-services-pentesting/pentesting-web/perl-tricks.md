# PrestaShop

{{#include ../../banners/hacktricks-training.md}}

## Perl backticks/qx// sinks in Apache mod_perl handlers (reachability and exploitation)

Reales Muster: Perl-Code baut einen shell-Befehlsstring zusammen und führt ihn über Backticks (oder qx//) aus. In einem mod_perl AccessHandler können angreiferkontrollierte Request-Komponenten wie $r->uri() in diesen String fließen. Wenn irgendein Pfad rohe Eingaben konkateniert und dann mit einer Shell auswertet, erhält man pre-auth RCE.

Riskante Perl-Ausführungsprimitiven (starten eine Shell, wenn ihnen ein einzelner String übergeben wird):
- Backticks / qx//: my $out = `cmd ...`;
- system mit einem einzelnen String: system("/bin/sh -c '...'") (implizit)
- open mit einer Pipe: open my $fh, "cmd |" or "| cmd"
- IPC::Open3 mit einem einzelnen String

Minimal verwundbare Form, in freier Wildbahn beobachtet:
```perl
sub getCASURL {
...
my $exec_cmd = "...";
if ($type eq 'login') {
$exec_cmd .= $uri;        # $uri from $r->uri() → attacker-controlled
my $out = `$exec_cmd`;    # backticks = shell
}
}
```
Wichtige Erreichbarkeitsaspekte in mod_perl:
- Handler-Registrierung: httpd.conf muss Requests in Ihr Perl-Modul routen, z. B. PerlModule MOD_SEC_EMC::AccessHandler und eine Konfiguration, die AccessHandler::handler für einen Pfadbereich aufruft.
- Auslösen des verwundbaren Zweigs: Erzwingen Sie den nicht-authentifizierten Login-Flow, sodass type == "login" (z. B. das erwartete auth cookie weglassen).
- Auflösbarer Pfad: Stellen Sie sicher, dass Ihre Anfrage eine URI trifft, die innerhalb des konfigurierten Bereichs aufgelöst wird. Wenn Apache die Anfrage niemals durch den Handler routet, wird der Sink nicht erreicht.

Ablauf der Ausnutzung
1) Untersuchen Sie httpd.conf nach PerlModule/MOD_PERL-Handler-Bereichen, um einen auflösbaren Pfad zu finden, der vom Handler verarbeitet wird.
2) Senden Sie eine nicht-authentifizierte Anfrage, sodass der Login-Redirect-Pfad genommen wird (type == "login").
3) Platzieren Sie Shell-Metakennzeichen im request-URI-Pfad, sodass $r->uri() Ihre Nutzlast in die Befehlszeichenkette trägt.

Example HTTP PoC (path injection via ';')
```http
GET /ui/health;id HTTP/1.1
Host: target
Connection: close
```
Tipps
- Probier Separatoren: ;, &&, |, `backticks`, $(...), und kodierte Zeilenumbrüche (%0A) je nach Quotierung.
- Wenn frühere Patches andere Args quotieren, aber in einem Branch die URI nicht, funktionieren Payloads, die ans Ende des Strings angehängt werden, oft: ;id# oder &&/usr/bin/id#

Härtung (Perl)
- Erzeuge keine Shell-Strings. Bevorzuge Argument-Vektor-Ausführung: system('/usr/bin/curl', '--silent', '--', $safe_url) — keine Shell.
- Wenn eine Shell unvermeidbar ist, escape strikt und konsistent über alle Branches; behandle $r->uri() als feindlich. Ziehe URI::Escape für Pfade/Queries und strikte Allowlists in Betracht.
- Vermeide backticks/qx// für Kommandoausführung; erfasse Ausgabe via open3/list-Form, falls wirklich nötig, ohne eine Shell zu starten.
- In mod_perl-Handlern sollten auth/redirect-Codepfade frei von Kommandoausführung bleiben oder eine identische Sanitization über alle Branches sichergestellt werden, um “fixed everywhere but one branch”-Regressionen zu vermeiden.

Schwachstellenjagd
- Analysiere Patch-Diffs von Modulen, die Shell-Kommandos zusammenbauen; suche nach inkonsistenter Quotierung zwischen Branches (z. B. if ($type eq 'login') nicht escaped).
- Grep nach backticks, qx//, open\s*\(|\||, and system\s*\(\s*" um string-basierte Shells zu finden. Erstelle einen Call-Graph von sink bis Request-Einstieg ($r), um die Pre-Auth-Erreichbarkeit zu verifizieren.

Praxisfall: Dell UnityVSA pre-auth RCE (CVE-2025-36604)
- Pre-auth command injection via backticks in AccessTool.pm:getCASURL when type == "login" concatenated raw $uri ($r->uri()).
- Erreichbar über MOD_SEC_EMC::AccessHandler → make_return_address($r) → getCASLoginURL(..., type="login") → getCASURL(..., $uri, 'login').
- Praktischer Hinweis: verwende einen auflösbaren Pfad, der vom handler abgedeckt wird; sonst wird das Modul nicht ausgeführt und der sink nicht erreicht.

## Referenzen

- [It’s Never Simple Until It Is: Dell UnityVSA Pre‑Auth Command Injection (CVE‑2025‑36604)](https://labs.watchtowr.com/its-never-simple-until-it-is-dell-unityvsa-pre-auth-command-injection-cve-2025-36604/)
- [Dell PSIRT DSA‑2025‑281 – Security update for Dell Unity/UnityVSA/Unity XT](https://www.dell.com/support/kbdoc/en-uk/000350756/dsa-2025-281-security-update-for-dell-unity-dell-unityvsa-and-dell-unity-xt-security-update-for-multiple-vulnerabilities)
- [watchTowr Detection Artefact Generator – Dell UnityVSA Pre‑Auth CVE‑2025‑36604](https://github.com/watchtowrlabs/watchTowr-vs-Dell-UnityVSA-PreAuth-CVE-2025-36604)

{{#include ../../banners/hacktricks-training.md}}
