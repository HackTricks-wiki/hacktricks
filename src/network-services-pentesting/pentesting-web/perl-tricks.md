# PrestaShop

{{#include ../../banners/hacktricks-training.md}}

## Perl backticks/qx// sinks in Apache mod_perl handlers (可达性和利用)

现实中的模式：Perl 代码构建一个 shell 命令字符串并通过 backticks（或 qx//）执行它。在 mod_perl 的 AccessHandler 中，攻击者可控的请求组件（如 $r->uri()）可能流入该字符串。如果任何分支将原始输入拼接进去然后通过 shell 求值，就会导致 pre-auth RCE。

风险较高的 Perl 执行原语（当传入单个字符串时会启动 shell）：
- Backticks / qx//: my $out = `cmd ...`;
- system with a single string: system("/bin/sh -c '...'") implicitly
- open with a pipe: open my $fh, "cmd |" or "| cmd"
- IPC::Open3 with a single string

在野外观察到的最小易受攻击形态：
```perl
sub getCASURL {
...
my $exec_cmd = "...";
if ($type eq 'login') {
$exec_cmd .= $uri;        # $uri from $r->uri() → attacker-controlled
my $out = `$exec_cmd`;    # backticks = shell
}
}
```
mod_perl 中的关键可达性考虑：
- Handler 注册：httpd.conf 必须将请求路由到你的 Perl 模块，例如 PerlModule MOD_SEC_EMC::AccessHandler 以及为某个路径作用域配置以调用 AccessHandler::handler。
- 触发易受攻击分支：强制未认证的登录流程以使 type == "login"（例如，省略预期的 auth cookie）。
- 可解析路径：确保你的请求目标为在配置作用域内可解析的 URI。如果 Apache 从未通过该 handler 路由请求，则无法到达 sink。

Exploitation workflow
1) 检查 httpd.conf 中的 PerlModule/MOD_PERL handler 作用域，找到由 handler 处理的可解析路径。
2) 发送未认证请求，使采用登录重定向路径（type == "login"）。
3) 在请求-URI 路径中放入 shell metacharacters，使 $r->uri() 将你的 payload 带入命令字符串。

Example HTTP PoC (path injection via ';')
```http
GET /ui/health;id HTTP/1.1
Host: target
Connection: close
```
技巧
- 尝试分隔符： ;, &&, |, `backticks`, $(...), 以及编码的新行 (%0A)，取决于引用方式。
- 如果较早的补丁在某个分支对其他参数进行了引用但没有引用 URI，那么将 payloads 追加到字符串末尾通常会有效： ;id# or &&/usr/bin/id#

加固 (Perl)
- 不要构造 shell 字符串。优先使用 argument-vector execution: system('/usr/bin/curl', '--silent', '--', $safe_url) — 不要调用 shell。
- 如果无法避免使用 shell，请在所有分支上严格且一致地进行转义；将 $r->uri() 视为不可信。对于路径/查询，考虑使用 URI::Escape 和严格的允许列表 (allowlists)。
- 避免使用 backticks/qx// 来执行命令；如果确实需要获取输出，使用 open3/list 形式来捕获，且不要调用 shell。
- 在 mod_perl 的 handlers 中，确保 auth/redirect 的代码路径不要执行命令，或者在各分支中保证相同的清理（sanitization），以避免“修好了所有地方但漏掉一个分支”这类回归。

漏洞查找
- 对生成 shell 命令的模块做 patch-diff；查找分支间引用不一致的情况（例如 if ($type eq 'login') 未被转义）。
- 使用 grep 搜索 backticks, qx//, open\s*\(|\||, 和 system\s*\(\s* 等，以发现基于字符串的 shell 调用。构建从 sink 到请求入口 ($r) 的调用图以验证 pre-auth 的可达性。

Real-world case: Dell UnityVSA pre-auth RCE (CVE-2025-36604)
- 在 AccessTool.pm:getCASURL 中，当 type == "login" 时通过 backticks 将原始 $uri ($r->uri()) 串联，导致 pre-auth command injection.
- 可通过 MOD_SEC_EMC::AccessHandler → make_return_address($r) → getCASLoginURL(..., type="login") → getCASURL(..., $uri, 'login') 到达。
- 实践注意事项：使用由该 handler 覆盖且可解析的路径；否则模块不会执行，sink 不会被触发。

## References

- [It’s Never Simple Until It Is: Dell UnityVSA Pre‑Auth Command Injection (CVE‑2025‑36604)](https://labs.watchtowr.com/its-never-simple-until-it-is-dell-unityvsa-pre-auth-command-injection-cve-2025-36604/)
- [Dell PSIRT DSA‑2025‑281 – Security update for Dell Unity/UnityVSA/Unity XT](https://www.dell.com/support/kbdoc/en-uk/000350756/dsa-2025-281-security-update-for-dell-unity-dell-unityvsa-and-dell-unity-xt-security-update-for-multiple-vulnerabilities)
- [watchTowr Detection Artefact Generator – Dell UnityVSA Pre‑Auth CVE‑2025‑36604](https://github.com/watchtowrlabs/watchTowr-vs-Dell-UnityVSA-PreAuth-CVE-2025-36604)

{{#include ../../banners/hacktricks-training.md}}
