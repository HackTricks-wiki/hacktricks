# PrestaShop

{{#include ../../banners/hacktricks-training.md}}

## Perl backticks/qx// sinks em Apache mod_perl handlers (reachability and exploitation)

Padrão observado na prática: código Perl constrói uma string de comando de shell e a executa via backticks (ou qx//). Em um mod_perl AccessHandler, componentes da requisição controlados pelo atacante como $r->uri() podem fluir para essa string. Se qualquer ramo concatenar input bruto e então avaliá-lo com um shell, você obtém pre-auth RCE.

Primitivas Perl de execução arriscadas (disparam um shell quando recebem uma única string):
- Backticks / qx//: my $out = `cmd ...`;
- system with a single string: system("/bin/sh -c '...'") implicitly
- open with a pipe: open my $fh, "cmd |" or "| cmd"
- IPC::Open3 with a single string

Minimal vulnerable shape observed in the wild:
```perl
sub getCASURL {
...
my $exec_cmd = "...";
if ($type eq 'login') {
$exec_cmd .= $uri;        # $uri from $r->uri() → attacker-controlled
my $out = `$exec_cmd`;    # backticks = shell
}
}
```
Considerações chave de alcance em mod_perl:
- Handler registration: o httpd.conf deve direcionar as requisições para o seu módulo Perl, por exemplo PerlModule MOD_SEC_EMC::AccessHandler, e conter configuração que invoque AccessHandler::handler para um escopo de caminho.
- Triggering the vulnerable branch: force o fluxo de login não autenticado para que type == "login" (por exemplo, omita o auth cookie esperado).
- Resolvable path: garanta que sua requisição aponte para uma URI que seja resolvida dentro do escopo configurado. Se o Apache nunca encaminhar a requisição pelo handler, o sink não é alcançado.

Exploitation workflow
1) Inspecione o httpd.conf em busca de escopos de handler PerlModule/MOD_PERL para encontrar um caminho resolvível processado pelo handler.
2) Envie uma requisição não autenticada para que o caminho de redirecionamento de login seja seguido (type == "login").
3) Coloque shell metacharacters no caminho do request-URI para que $r->uri() leve seu payload para dentro da string de comando.

Example HTTP PoC (path injection via ';')
```http
GET /ui/health;id HTTP/1.1
Host: target
Connection: close
```
Dicas
- Tente separadores: ;, &&, |, `backticks`, $(...), and encoded newlines (%0A) dependendo do quoting.
- Se patches anteriores colocam outros args entre aspas mas não a URI em um ramo, payloads anexados ao final da string frequentemente funcionam: ;id# ou &&/usr/bin/id#

Endurecimento (Perl)
- Do not build shell strings. Prefira execução por vetor de argumentos: system('/usr/bin/curl', '--silent', '--', $safe_url) — sem shell.
- Se um shell for inevitável, escape estritamente e de forma consistente em todos os ramos; trate $r->uri() como hostil. Considere URI::Escape para paths/queries e strong allowlists.
- Evite backticks/qx// para execução de comandos; capture a saída via open3/list form se realmente necessário sem invocar um shell.
- Em mod_perl handlers, mantenha os caminhos de código de auth/redirect livres de execução de comandos ou garanta sanitização idêntica entre os ramos para evitar regressões do tipo “fixed everywhere but one branch”.

Caça a vulnerabilidades
- Analise diffs de patches em módulos que montam comandos de shell; procure por cotações inconsistentes entre ramos (por exemplo, if ($type eq 'login') left unescaped).
- Grep por backticks, qx//, open\s*\(|\||, and system\s*\(\s*" para encontrar shells baseados em strings. Construa um grafo de chamadas do sink até a entrada da request ($r) para verificar se é alcançável sem autenticação.

Caso real: Dell UnityVSA pre-auth RCE (CVE-2025-36604)
- Pre-auth command injection via backticks em AccessTool.pm:getCASURL quando type == "login" concatenated raw $uri ($r->uri()).
- Alcançável via MOD_SEC_EMC::AccessHandler → make_return_address($r) → getCASLoginURL(..., type="login") → getCASURL(..., $uri, 'login').
- Detalhe prático: use um path resolvível coberto pelo handler; caso contrário o módulo não executará e o sink não será atingido.

## Referências

- [It’s Never Simple Until It Is: Dell UnityVSA Pre‑Auth Command Injection (CVE‑2025‑36604)](https://labs.watchtowr.com/its-never-simple-until-it-is-dell-unityvsa-pre-auth-command-injection-cve-2025-36604/)
- [Dell PSIRT DSA‑2025‑281 – Security update for Dell Unity/UnityVSA/Unity XT](https://www.dell.com/support/kbdoc/en-uk/000350756/dsa-2025-281-security-update-for-dell-unity-dell-unityvsa-and-dell-unity-xt-security-update-for-multiple-vulnerabilities)
- [watchTowr Detection Artefact Generator – Dell UnityVSA Pre‑Auth CVE‑2025‑36604](https://github.com/watchtowrlabs/watchTowr-vs-Dell-UnityVSA-PreAuth-CVE-2025-36604)

{{#include ../../banners/hacktricks-training.md}}
