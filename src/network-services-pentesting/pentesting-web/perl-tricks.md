# PrestaShop

{{#include ../../banners/hacktricks-training.md}}

## Perl backticks/qx// sinks in Apache mod_perl handlers (reachability and exploitation)

Pattern reale: il codice Perl costruisce una stringa di comando shell ed la esegue tramite backticks (o qx//). In un mod_perl AccessHandler, componenti della request controllate dall'attaccante come $r->uri() possono fluire in quella stringa. Se qualche ramo concatena input raw e poi lo valuta con una shell, ottieni pre-auth RCE.

Primitive di esecuzione Perl rischiose (avviano una shell quando ricevono una singola stringa):
- Backticks / qx//: my $out = `cmd ...`;
- system with a single string: system("/bin/sh -c '...'") implicitly
- open with a pipe: open my $fh, "cmd |" or "| cmd"
- IPC::Open3 with a single string

Minimal vulnerable shape observed in the wild:
```perl
sub getCASURL {
...
my $exec_cmd = "...";
if ($type eq 'login') {
$exec_cmd .= $uri;        # $uri from $r->uri() → attacker-controlled
my $out = `$exec_cmd`;    # backticks = shell
}
}
```
Considerazioni chiave sulla raggiungibilità in mod_perl:
- Registrazione dell'handler: httpd.conf deve instradare le richieste nel tuo modulo Perl, e.g. PerlModule MOD_SEC_EMC::AccessHandler e configurazione che invoca AccessHandler::handler per uno scope di percorso.
- Attivazione del ramo vulnerabile: forza il flusso di login non autenticato in modo che type == "login" (e.g., ometti il cookie di auth previsto).
- Percorso risolvibile: assicurati che la tua richiesta punti a una URI che si risolve nello scope configurato. Se Apache non instrada mai la richiesta attraverso l'handler, la sink non viene raggiunta.

Exploitation workflow
1) Ispeziona httpd.conf per PerlModule/MOD_PERL handler scopes per trovare un percorso risolvibile processato dall'handler.
2) Invia una richiesta non autenticata in modo che sia presa la path di redirect del login (type == "login").
3) Inserisci metacaratteri shell nel percorso del request-URI così che $r->uri() trasporti il tuo payload nella stringa di comando.

Example HTTP PoC (path injection via ';')
```http
GET /ui/health;id HTTP/1.1
Host: target
Connection: close
```
Tips
- Prova separatori: ;, &&, |, `backticks`, $(...), and encoded newlines (%0A) a seconda del quoting.
- Se patch precedenti citano altri argomenti ma non l'URI in un ramo, i payload aggiunti alla fine della stringa spesso funzionano: ;id# or &&/usr/bin/id#

Rafforzamento (Perl)
- Non costruire stringhe shell. Preferisci l'esecuzione con vettore di argomenti: system('/usr/bin/curl', '--silent', '--', $safe_url) — no shell.
- Se una shell è inevitabile, effettua escaping in modo rigoroso e coerente in tutti i rami; tratta $r->uri() come ostile. Considera URI::Escape per paths/queries e allowlist rigorose.
- Evita backticks/qx// per l'esecuzione di comandi; cattura l'output tramite open3/list form se veramente necessario senza invocare una shell.
- Nei mod_perl handlers, mantieni i percorsi di auth/redirect privi di esecuzione di comandi o assicurati che la sanitizzazione sia identica in tutti i rami per evitare regressioni “fixed everywhere but one branch”.

Ricerca di vulnerabilità
- Diff delle patch sui moduli che assemblano comandi shell; cerca quote incoerenti tra i rami (e.g., if ($type eq 'login') left unescaped).
- Grep per backticks, qx//, open\s*\(|\||, and system\s*\(\s*" per trovare shell basate su stringhe. Costruisci un call graph dal sink all'entry della richiesta ($r) per verificare la raggiungibilità pre-auth.

Real-world case: Dell UnityVSA pre-auth RCE (CVE-2025-36604)
- Pre-auth command injection via backticks in AccessTool.pm:getCASURL when type == "login" concatenated raw $uri ($r->uri()).
- Raggiungibile tramite MOD_SEC_EMC::AccessHandler → make_return_address($r) → getCASLoginURL(..., type="login") → getCASURL(..., $uri, 'login').
- Nuance pratica: use a resolvable path covered by the handler; otherwise the module won’t execute and the sink won’t be hit.

## References

- [It’s Never Simple Until It Is: Dell UnityVSA Pre‑Auth Command Injection (CVE‑2025‑36604)](https://labs.watchtowr.com/its-never-simple-until-it-is-dell-unityvsa-pre-auth-command-injection-cve-2025-36604/)
- [Dell PSIRT DSA‑2025‑281 – Security update for Dell Unity/UnityVSA/Unity XT](https://www.dell.com/support/kbdoc/en-uk/000350756/dsa-2025-281-security-update-for-dell-unity-dell-unityvsa-and-dell-unity-xt-security-update-for-multiple-vulnerabilities)
- [watchTowr Detection Artefact Generator – Dell UnityVSA Pre‑Auth CVE‑2025‑36604](https://github.com/watchtowrlabs/watchTowr-vs-Dell-UnityVSA-PreAuth-CVE-2025-36604)

{{#include ../../banners/hacktricks-training.md}}
