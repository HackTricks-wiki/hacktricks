# Web API Pentesting

{{#include ../../banners/hacktricks-training.md}}

## API Pentesting Methodik — Zusammenfassung

Das Pentesting von APIs erfordert einen strukturierten Ansatz zur Aufdeckung von Schwachstellen. Dieser Leitfaden fasst eine umfassende Methodik zusammen und legt den Schwerpunkt auf praktische Techniken und Tools.

### **Verständnis der API-Typen**

- **SOAP/XML Web Services**: Verwenden das WSDL-Format für die Dokumentation, typischerweise unter `?wsdl`-Pfaden zu finden. Tools wie **SOAPUI** und **WSDLer** (Burp Suite Extension) sind beim Parsen und Erzeugen von Anfragen hilfreich. Beispiel-Dokumentation ist erreichbar unter [DNE Online](http://www.dneonline.com/calculator.asmx).
- **REST APIs (JSON)**: Die Dokumentation liegt häufig in WADL-Dateien vor, jedoch bieten Tools wie [Swagger UI](https://swagger.io/tools/swagger-ui/) eine benutzerfreundlichere Oberfläche zur Interaktion. **Postman** ist ein wertvolles Tool zum Erstellen und Verwalten von Beispielanfragen.
- **GraphQL**: Eine Query-Sprache für APIs, die eine vollständige und verständliche Beschreibung der Daten in Ihrer API bietet.

### **Practice Labs**

- [**VAmPI**](https://github.com/erev0s/VAmPI): Eine absichtlich verwundbare API für praktische Übungen, die die OWASP Top-10 API-Schwachstellen abdeckt.

### **Effektive Tricks für API Pentesting**

- **SOAP/XML Vulnerabilities**: Untersuche XXE-Schwachstellen, obwohl DTD-Deklarationen oft eingeschränkt sind. CDATA-Tags können das Einfügen von Payloads erlauben, sofern das XML gültig bleibt.
- **Privilege Escalation**: Teste Endpunkte mit unterschiedlichen Privilegien, um Möglichkeiten unautorisierter Zugriffe zu identifizieren.
- **CORS Misconfigurations**: Untersuche CORS-Einstellungen auf mögliche Ausnutzbarkeit durch CSRF-Angriffe aus authentifizierten Sessions.
- **Endpoint Discovery**: Nutze API-Muster, um versteckte Endpunkte zu entdecken. Tools wie Fuzzer können diesen Prozess automatisieren.
- **Parameter Tampering**: Experimentiere damit, Parameter in Anfragen hinzuzufügen oder zu ersetzen, um auf unautorisierte Daten oder Funktionen zuzugreifen.
- **HTTP Method Testing**: Variiere Request-Methoden (GET, POST, PUT, DELETE, PATCH), um unerwartetes Verhalten oder Informationslecks zu entdecken.
- **Content-Type Manipulation**: Wechsle zwischen verschiedenen Content-Types (x-www-form-urlencoded, application/xml, application/json), um Parsing-Probleme oder Schwachstellen zu testen.
- **Advanced Parameter Techniques**: Teste mit unerwarteten Datentypen in JSON-Payloads oder spiele mit XML-Daten für XXE-Injektionen. Probiere außerdem Parameter-Pollution und Wildcard-Character für breitere Tests.
- **Version Testing**: Ältere API-Versionen sind möglicherweise anfälliger für Angriffe. Prüfe stets und teste gegen mehrere API-Versionen.

### Autorisierung & Business-Logik (AuthN != AuthZ) — tRPC/Zod protectedProcedure-Fallstricke

Moderne TypeScript-Stacks nutzen häufig tRPC mit Zod für die Input-Validierung. In tRPC stellt `protectedProcedure` typischerweise sicher, dass die Anfrage über eine gültige Session (Authentication) verfügt, impliziert jedoch nicht, dass der Aufrufer die richtigen Rollen/Berechtigungen (Authorization) besitzt. Diese Diskrepanz führt zu Broken Function Level Authorization (BOLA), wenn sensitive Prozeduren nur durch `protectedProcedure` abgesichert sind.

- Bedrohungsmodell: Jeder niedrig privilegierte authentifizierte Benutzer kann Admin-Grade-Prozeduren aufrufen, wenn Rollenprüfungen fehlen (z. B. background migrations, feature flags, tenant-wide maintenance, job control).
- Black-box signal: `POST /api/trpc/<router>.<procedure>`-Endpunkte, die für normale Accounts erfolgreich sind, obwohl sie nur für Admins sein sollten. Self-serve Anmeldungen erhöhen die Ausnutzbarkeit drastisch.
- Typische tRPC-Route (v10+): JSON-Body verpackt unter `{"input": {...}}`.

Beispiel für ein verwundbares Muster (keine Rollen-/Berechtigungsprüfung):
```ts
// The endpoint for retrying a migration job
// This checks for a valid session (authentication)
retry: protectedProcedure
// but not for an admin role (authorization).
.input(z.object({ name: z.string() }))
.mutation(async ({ input, ctx }) => {
// Logic to restart a sensitive migration
}),
```
Praktische Exploitation (black-box)

1) Registriere ein normales Konto und erhalte eine authentifizierte Sitzung (cookies/headers).
2) Enumeriere Hintergrund-Jobs oder andere sensible Ressourcen via “list”/“all”/“status” Verfahren.
```bash
curl -s -X POST 'https://<tenant>/api/trpc/backgroundMigrations.all' \
-H 'Content-Type: application/json' \
-b '<AUTH_COOKIES>' \
--data '{"input":{}}'
```
3) Privilegierte Aktionen aufrufen, z. B. einen Job neu starten:
```bash
curl -s -X POST 'https://<tenant>/api/trpc/backgroundMigrations.retry' \
-H 'Content-Type: application/json' \
-b '<AUTH_COOKIES>' \
--data '{"input":{"name":"<migration_name>"}}'
```
Zu bewertende Auswirkungen

- Datenkorruption durch nicht-idempotente Neustarts: Das Erzwingen gleichzeitiger Ausführungen von migrations/workers kann Race Conditions und inkonsistente partielle Zustände erzeugen (stiller Datenverlust, fehlerhafte Analytics).
- DoS via worker/DB starvation: Das wiederholte Auslösen ressourcenintensiver Jobs kann worker-Pools und Datenbankverbindungen erschöpfen und mandantenweite Ausfälle verursachen.

### **Tools und Ressourcen für API Pentesting**

- [**kiterunner**](https://github.com/assetnote/kiterunner): Ausgezeichnet zum Auffinden von API-Endpunkten. Verwende es, um Pfade und Parameter gegen Ziel-APIs zu scannen und brute force auszuführen.
```bash
kr scan https://domain.com/api/ -w routes-large.kite -x 20
kr scan https://domain.com/api/ -A=apiroutes-220828 -x 20
kr brute https://domain.com/api/ -A=raft-large-words -x 20 -d=0
kr brute https://domain.com/api/ -w /tmp/lang-english.txt -x 20 -d=0
```
- [**https://github.com/BishopFox/sj**](https://github.com/BishopFox/sj): sj ist ein Kommandozeilen-Tool, das beim Audit von **exposed Swagger/OpenAPI definition files** hilft, indem es die zugehörigen API-Endpunkte auf schwache Authentifizierung prüft. Es liefert außerdem Kommandovorlagen für manuelle Vulnerability-Tests.
- Additional tools like **automatic-api-attack-tool**, **Astra**, and **restler-fuzzer** offer tailored functionalities for API security testing, ranging from attack simulation to fuzzing and vulnerability scanning.
- [**Cherrybomb**](https://github.com/blst-security/cherrybomb): Es ist ein API-Security-Tool, das die API basierend auf einer OAS-Datei prüft (das Tool ist in rust geschrieben).

### **Lern- und Übungsressourcen**

- **OWASP API Security Top 10**: Unverzichtbare Lektüre zum Verständnis häufiger API-Schwachstellen ([OWASP Top 10](https://github.com/OWASP/API-Security/blob/master/2019/en/dist/owasp-api-security-top-10.pdf)).
- **API Security Checklist**: Eine umfassende Checkliste zur Absicherung von APIs ([GitHub link](https://github.com/shieldfy/API-Security-Checklist)).
- **Logger++ Filters**: Zum Aufspüren von API-Schwachstellen bietet Logger++ nützliche Filter ([GitHub link](https://github.com/bnematzadeh/LoggerPlusPlus-API-Filters)).
- **API Endpoints List**: Eine kuratierte Liste potenzieller API-Endpunkte für Testzwecke ([GitHub gist](https://gist.github.com/yassineaboukir/8e12adefbd505ef704674ad6ad48743d)).

## Referenzen

- [https://github.com/Cyber-Guy1/API-SecurityEmpire](https://github.com/Cyber-Guy1/API-SecurityEmpire)
- [How An Authorization Flaw Reveals A Common Security Blind Spot: CVE-2025-59305 Case Study](https://www.depthfirst.com/post/how-an-authorization-flaw-reveals-a-common-security-blind-spot-cve-2025-59305-case-study)

{{#include ../../banners/hacktricks-training.md}}
