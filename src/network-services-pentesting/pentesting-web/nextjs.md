# NextJS

{{#include ../../banners/hacktricks-training.md}}

## Γενική Αρχιτεκτονική μιας Εφαρμογής Next.js

### Τυπική Δομή Αρχείων

Ένα τυπικό έργο Next.js ακολουθεί μια συγκεκριμένη δομή αρχείων και φακέλων που διευκολύνει λειτουργίες όπως routing, API endpoints και διαχείριση στατικών πόρων. Ακολουθεί μια τυπική διάταξη:
```lua
my-nextjs-app/
├── node_modules/
├── public/
│   ├── images/
│   │   └── logo.png
│   └── favicon.ico
├── app/
│   ├── api/
│   │   └── hello/
│   │       └── route.ts
│   ├── layout.tsx
│   ├── page.tsx
│   ├── about/
│   │   └── page.tsx
│   ├── dashboard/
│   │   ├── layout.tsx
│   │   └── page.tsx
│   ├── components/
│   │   ├── Header.tsx
│   │   └── Footer.tsx
│   ├── styles/
│   │   ├── globals.css
│   │   └── Home.module.css
│   └── utils/
│       └── api.ts
├── .env.local
├── next.config.js
├── tsconfig.json
├── package.json
├── README.md
└── yarn.lock / package-lock.json

```
### Κύριοι Κατάλογοι και Αρχεία

- **public/:** Φιλοξενεί στατικά αρχεία όπως εικόνες, γραμματοσειρές και άλλα αρχεία. Τα αρχεία εδώ είναι προσβάσιμα στη ρίζα (`/`).
- **app/:** Κεντρικός κατάλογος για τις σελίδες, layouts, components και API routes της εφαρμογής σας. Υιοθετεί το **App Router** παράδειγμα, επιτρέποντας προηγμένες λειτουργίες routing και διαχωρισμό server-client components.
- **app/layout.tsx:** Ορίζει το root layout της εφαρμογής, που τυλίγει όλες τις σελίδες και παρέχει συνεπή στοιχεία UI όπως headers, footers και navigation bars.
- **app/page.tsx:** Λειτουργεί ως σημείο εισόδου για το root route `/`, αποδίδοντας την αρχική σελίδα.
- **app/[route]/page.tsx:** Χειρίζεται στατικές και δυναμικές διαδρομές. Κάθε φάκελος μέσα στο `app/` αντιπροσωπεύει ένα route segment, και το `page.tsx` σε αυτούς τους φακέλους αντιστοιχεί στο component της διαδρομής.
- **app/api/:** Περιέχει API routes, επιτρέποντάς σας να δημιουργήσετε serverless functions που χειρίζονται HTTP αιτήματα. Αυτές οι διαδρομές αντικαθιστούν τον παραδοσιακό κατάλογο `pages/api`.
- **app/components/:** Φιλοξενεί επαναχρησιμοποιήσιμα React components που μπορούν να χρησιμοποιηθούν σε διαφορετικές σελίδες και layouts.
- **app/styles/:** Περιέχει global CSS αρχεία και CSS Modules για styling σε επίπεδο component.
- **app/utils/:** Περιλαμβάνει utility functions, helper modules και άλλη μη-UI λογική που μπορεί να κοινοποιηθεί στην εφαρμογή.
- **.env.local:** Αποθηκεύει environment variables ειδικές για το τοπικό development περιβάλλον. Αυτές οι μεταβλητές **δεν** δεσμεύονται στο version control.
- **next.config.js:** Προσαρμόζει τη συμπεριφορά του Next.js, συμπεριλαμβανομένων webpack configurations, environment variables και security settings.
- **tsconfig.json:** Ρυθμίζει τις TypeScript ρυθμίσεις του project, ενεργοποιώντας type checking και άλλες TypeScript λειτουργίες.
- **package.json:** Διαχειρίζεται dependencies του project, scripts και metadata.
- **README.md:** Παρέχει documentation και πληροφορίες για το project, συμπεριλαμβανομένων οδηγιών εγκατάστασης, οδηγών χρήσης και άλλων σχετικών λεπτομερειών.
- **yarn.lock / package-lock.json:** Κλειδώνουν τις εξαρτήσεις του project σε συγκεκριμένες εκδόσεις, εξασφαλίζοντας συνεπείς εγκαταστάσεις σε διαφορετικά περιβάλλοντα.

## Client-Side στο Next.js

### Routing με βάση τα αρχεία στον κατάλογο `app`

Ο κατάλογος `app` είναι ο ακρογωνιαίος λίθος του routing στις τελευταίες εκδόσεις του Next.js. Χρησιμοποιεί το filesystem για να ορίσει τις διαδρομές, κάνοντας τη διαχείριση routes διαισθητική και επεκτάσιμη.

<details>

<summary>Χειρισμός της ρίζας διαδρομής /</summary>

**Δομή Αρχείων:**
```arduino
my-nextjs-app/
├── app/
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Βασικά Αρχεία:**

- **`app/page.tsx`**: Διαχειρίζεται αιτήματα προς το root path `/`.
- **`app/layout.tsx`**: Ορίζει τη διάταξη για την εφαρμογή, περιβάλλοντας όλες τις σελίδες.

**Υλοποίηση:**
```tsx
tsxCopy code// app/page.tsx

export default function HomePage() {
return (
<div>
<h1>Welcome to the Home Page!</h1>
<p>This is the root route.</p>
</div>
);
}
```
**Επεξήγηση:**

- **Ορισμός διαδρομής:** Το αρχείο `page.tsx` που βρίσκεται απευθείας στον κατάλογο `app` αντιστοιχεί στη διαδρομή `/`.
- **Απόδοση:** Αυτό το component εμφανίζει το περιεχόμενο για την αρχική σελίδα.
- **Ενσωμάτωση layout:** Το component `HomePage` περιτυλίγεται από το `layout.tsx`, το οποίο μπορεί να περιλαμβάνει επικεφαλίδες, υποσέλιδα και άλλα κοινά στοιχεία.

</details>

<details>

<summary>Χειρισμός άλλων στατικών διαδρομών</summary>

**Παράδειγμα: `/about` Διαδρομή**

**Δομή αρχείων:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── about/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Υλοποίηση:**
```tsx
// app/about/page.tsx

export default function AboutPage() {
return (
<div>
<h1>About Us</h1>
<p>Learn more about our mission and values.</p>
</div>
)
}
```
**Επεξήγηση:**

- **Ορισμός διαδρομής:** Το αρχείο `page.tsx` μέσα στον φάκελο `about` αντιστοιχεί στη διαδρομή `/about`.
- **Απόδοση:** Αυτό το component αποδίδει το περιεχόμενο για τη σελίδα about.

</details>

<details>

<summary>Δυναμικές διαδρομές</summary>

Οι δυναμικές διαδρομές επιτρέπουν τη διαχείριση μονοπατιών με μεταβλητά τμήματα, δίνοντας τη δυνατότητα στις εφαρμογές να εμφανίζουν περιεχόμενο βάσει παραμέτρων όπως IDs, slugs κ.λπ.

**Παράδειγμα: Διαδρομή `/posts/[id]`**

**Δομή αρχείων:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── posts/
│   │   └── [id]/
│   │       └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Υλοποίηση:**
```tsx
tsxCopy code// app/posts/[id]/page.tsx

import { useRouter } from 'next/navigation';

interface PostProps {
params: { id: string };
}

export default function PostPage({ params }: PostProps) {
const { id } = params;
// Fetch post data based on 'id'

return (
<div>
<h1>Post #{id}</h1>
<p>This is the content of post {id}.</p>
</div>
);
}
```
**Επεξήγηση:**

- **Δυναμικό Τμήμα:** `[id]` υποδηλώνει ένα δυναμικό τμήμα στη διαδρομή, που συλλαμβάνει την παράμετρο `id` από το URL.
- **Πρόσβαση σε Παραμέτρους:** Το αντικείμενο `params` περιέχει τις δυναμικές παραμέτρους, προσβάσιμες εντός του component.
- **Ταύτιση Διαδρομής:** Οποιοδήποτε μονοπάτι που ταιριάζει με `/posts/*`, όπως `/posts/1`, `/posts/abc`, κ.λπ., θα χειρίζεται από αυτό το component.

</details>

<details>

<summary>Εμφωλευμένες Διαδρομές</summary>

Next.js υποστηρίζει εμφωλευμένη δρομολόγηση, επιτρέποντας ιεραρχικές δομές διαδρομών που αντικατοπτρίζουν τη διάταξη των φακέλων.

**Παράδειγμα: Διαδρομή `/dashboard/settings/profile`**

**Δομή Αρχείων:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── dashboard/
│   │   ├── settings/
│   │   │   └── profile/
│   │   │       └── page.tsx
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Υλοποίηση:**
```tsx
tsxCopy code// app/dashboard/settings/profile/page.tsx

export default function ProfileSettingsPage() {
return (
<div>
<h1>Profile Settings</h1>
<p>Manage your profile information here.</p>
</div>
);
}
```
**Επεξήγηση:**

- **Βαθιά εμφώλευση:** Το αρχείο `page.tsx` μέσα στο `dashboard/settings/profile/` αντιστοιχεί στη διαδρομή `/dashboard/settings/profile`.
- **Αντανάκλαση ιεραρχίας:** Η δομή των φακέλων αντανακλά τη διαδρομή του URL, βελτιώνοντας τη συντηρησιμότητα και τη σαφήνεια.

</details>

<details>

<summary>Διαδρομές Catch-All</summary>

Οι διαδρομές Catch-All χειρίζονται πολλαπλά εμφωλευμένα τμήματα ή άγνωστες διαδρομές, παρέχοντας ευελιξία στη δρομολόγηση.

**Παράδειγμα: `/*` Διαδρομή**

**Δομή Αρχείων:**
```arduino
my-nextjs-app/
├── app/
│   ├── [..slug]/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Υλοποίηση:**
```tsx
// app/[...slug]/page.tsx

interface CatchAllProps {
params: { slug: string[] }
}

export default function CatchAllPage({ params }: CatchAllProps) {
const { slug } = params
const fullPath = `/${slug.join("/")}`

return (
<div>
<h1>Catch-All Route</h1>
<p>You have navigated to: {fullPath}</p>
</div>
)
}
```
**Επεξήγηση:**

- **Catch-All Segment:** `[...slug]` καταγράφει όλα τα υπόλοιπα segments της διαδρομής ως array.
- **Χρήση:** Χρήσιμο για τον χειρισμό δυναμικών σεναρίων δρομολόγησης όπως διαδρομές που δημιουργούνται από χρήστες, εμφωλευμένες κατηγορίες κ.λπ.
- **Ταύτιση Διαδρομής:** Διαδρομές όπως `/anything/here`, `/foo/bar/baz` κ.λπ. χειρίζονται από αυτό το component.

</details>

### Πιθανές ευπάθειες στην πλευρά του client

Ενώ το Next.js παρέχει ένα ασφαλές θεμέλιο, λανθασμένες πρακτικές κωδικοποίησης μπορούν να εισαγάγουν ευπάθειες. Σημαντικές ευπάθειες στην πλευρά του client περιλαμβάνουν:

<details>

<summary>Cross-Site Scripting (XSS)</summary>

Οι XSS επιθέσεις συμβαίνουν όταν κακόβουλα scripts εισάγονται σε αξιόπιστους ιστότοπους. Οι επιτιθέμενοι μπορούν να εκτελέσουν αυτά τα scripts στα προγράμματα περιήγησης των χρηστών, κλέβοντας δεδομένα ή πραγματοποιώντας ενέργειες εκ μέρους του χρήστη.

**Παράδειγμα ευάλωτου κώδικα:**
```jsx
// Dangerous: Injecting user input directly into HTML
function Comment({ userInput }) {
return <div dangerouslySetInnerHTML={{ __html: userInput }} />
}
```
**Γιατί είναι ευάλωτο:** Η χρήση του `dangerouslySetInnerHTML` με μη αξιόπιστη είσοδο επιτρέπει σε επιτιθέμενους να εισάγουν κακόβουλο κώδικα.

</details>

<details>

<summary>Client-Side Template Injection</summary>

Εμφανίζεται όταν οι εισροές των χρηστών δεν χειρίζονται σωστά στα templates, επιτρέποντας σε επιτιθέμενους να εισάγουν και να εκτελέσουν templates ή εκφράσεις.

**Παράδειγμα ευάλωτου κώδικα:**
```jsx
import React from "react"
import ejs from "ejs"

function RenderTemplate({ template, data }) {
const html = ejs.render(template, data)
return <div dangerouslySetInnerHTML={{ __html: html }} />
}
```
**Γιατί είναι ευάλωτο:** Αν το `template` ή το `data` περιέχει κακόβουλο περιεχόμενο, μπορεί να οδηγήσει στην εκτέλεση μη προοριζόμενου κώδικα.

</details>

<details>

<summary>Client Path Traversal</summary>

Είναι μια ευπάθεια που επιτρέπει σε επιτιθέμενους να χειραγωγήσουν client-side paths για να πραγματοποιήσουν μη προοριζόμενες ενέργειες, όπως Cross-Site Request Forgery (CSRF). Σε αντίθεση με το server-side path traversal, το οποίο στοχεύει το server's filesystem, το CSPT εστιάζει στην εκμετάλλευση μηχανισμών στην client πλευρά για την αναδρομολόγηση νόμιμων API requests προς κακόβουλα endpoints.

**Παράδειγμα ευάλωτου κώδικα:**

Μια εφαρμογή Next.js επιτρέπει στους χρήστες να ανεβάζουν και να κατεβάζουν αρχεία. Η λειτουργία λήψης υλοποιείται στην client πλευρά, όπου οι χρήστες μπορούν να καθορίσουν τη διαδρομή αρχείου για λήψη.
```jsx
// pages/download.js
import { useState } from "react"

export default function DownloadPage() {
const [filePath, setFilePath] = useState("")

const handleDownload = () => {
fetch(`/api/files/${filePath}`)
.then((response) => response.blob())
.then((blob) => {
const url = window.URL.createObjectURL(blob)
const a = document.createElement("a")
a.href = url
a.download = filePath
a.click()
})
}

return (
<div>
<h1>Download File</h1>
<input
type="text"
value={filePath}
onChange={(e) => setFilePath(e.target.value)}
placeholder="Enter file path"
/>
<button onClick={handleDownload}>Download</button>
</div>
)
}
```
#### Σενάριο Επίθεσης

1. **Στόχος του επιτιθέμενου**: Perform a CSRF attack to delete a critical file (e.g., `admin/config.json`) by manipulating the `filePath`.
2. **Εκμετάλλευση του CSPT**:
- **Κακόβουλη Είσοδος**: Ο επιτιθέμενος δημιουργεί ένα URL με χειραγωγημένο `filePath` όπως `../deleteFile/config.json`.
- **Προκύπτον αίτημα API**: Ο κώδικας στην πλευρά του client πραγματοποιεί αίτημα προς `/api/files/../deleteFile/config.json`.
- **Διαχείριση από τον διακομιστή**: Εάν ο διακομιστής δεν επικυρώνει το `filePath`, επεξεργάζεται το αίτημα, ενδεχομένως διαγράφοντας ή αποκαλύπτοντας ευαίσθητα αρχεία.
3. **Εκτέλεση CSRF**:
- **Κατασκευασμένος Σύνδεσμος**: Ο επιτιθέμενος στέλνει στο θύμα έναν σύνδεσμο ή ενσωματώνει κακόβουλο script που προκαλεί το αίτημα λήψης με το χειραγωγημένο `filePath`.
- **Αποτέλεσμα**: Το θύμα εκτελεί άθελά του τη δράση, οδηγώντας σε μη εξουσιοδοτημένη πρόσβαση ή διαγραφή αρχείων.

#### Γιατί είναι ευάλωτο

- **Έλλειψη Επικύρωσης Εισόδου**: Η πλευρά του client επιτρέπει αυθαίρετες τιμές για το `filePath`, δίνοντας τη δυνατότητα path traversal.
- **Εμπιστοσύνη σε Εισροές του Client**: Το server-side API εμπιστεύεται και επεξεργάζεται το `filePath` χωρίς sanitization.
- **Πιθανές Ενέργειες API**: Εάν το API endpoint εκτελεί ενέργειες που αλλάζουν κατάσταση (π.χ., διαγραφή, τροποποίηση αρχείων), μπορεί να εκμεταλλευτεί μέσω του CSPT.

</details>

## Πλευρά διακομιστή στο Next.js

### Απόδοση στην πλευρά διακομιστή (SSR)

Οι σελίδες αποδίδονται στον διακομιστή σε κάθε αίτημα, εξασφαλίζοντας ότι ο χρήστης λαμβάνει πλήρως αποδιδόμενο HTML. Σε αυτή την περίπτωση θα πρέπει να δημιουργήσετε έναν προσαρμοσμένο διακομιστή για να επεξεργάζεται τα αιτήματα.

**Περιπτώσεις χρήσης:**

- Δυναμικό περιεχόμενο που αλλάζει συχνά.
- Βελτιστοποίηση SEO, καθώς οι μηχανές αναζήτησης μπορούν να ανιχνεύσουν την πλήρως αποδιδόμενη σελίδα.

**Υλοποίηση:**
```jsx
// pages/index.js
export async function getServerSideProps(context) {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data } }
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### Στατική Δημιουργία Ιστοσελίδων (SSG)

Οι σελίδες αποδίδονται εκ των προτέρων κατά το χρόνο build, με αποτέλεσμα γρηγορότερους χρόνους φόρτωσης και μειωμένο φόρτο στον διακομιστή.

**Περιπτώσεις χρήσης:**

- Περιεχόμενο που δεν αλλάζει συχνά.
- Ιστολόγια, τεκμηρίωση, σελίδες μάρκετινγκ.

**Υλοποίηση:**
```jsx
// pages/index.js
export async function getStaticProps() {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data }, revalidate: 60 } // Revalidate every 60 seconds
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### Λειτουργίες χωρίς διακομιστή (API Routes)

Το Next.js επιτρέπει τη δημιουργία σημείων τερματισμού API ως λειτουργίες χωρίς διακομιστή. Αυτές οι λειτουργίες εκτελούνται κατ' απαίτηση χωρίς την ανάγκη ενός αφιερωμένου διακομιστή.

**Περιπτώσεις χρήσης:**

- Διαχείριση υποβολών φορμών.
- Αλληλεπίδραση με βάσεις δεδομένων.
- Επεξεργασία δεδομένων ή ενσωμάτωση με APIs τρίτων.

**Υλοποίηση:**

Με την εισαγωγή του καταλόγου `app` στο Next.js 13, η δρομολόγηση και η διαχείριση API έχουν γίνει πιο ευέλικτες και ισχυρές. Αυτή η σύγχρονη προσέγγιση ευθυγραμμίζεται στενά με το σύστημα δρομολόγησης βάσει αρχείων αλλά εισάγει βελτιωμένες δυνατότητες, συμπεριλαμβανομένης της υποστήριξης για server και client components.

#### Βασικός Route Handler

**Δομή αρχείων:**
```go
my-nextjs-app/
├── app/
│   └── api/
│       └── hello/
│           └── route.js
├── package.json
└── ...
```
**Υλοποίηση:**
```javascript
// app/api/hello/route.js

export async function POST(request) {
return new Response(JSON.stringify({ message: "Hello from App Router!" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

// Client-side fetch to access the API endpoint
fetch("/api/submit", {
method: "POST",
headers: { "Content-Type": "application/json" },
body: JSON.stringify({ name: "John Doe" }),
})
.then((res) => res.json())
.then((data) => console.log(data))
```
**Επεξήγηση:**

- **Τοποθεσία:** Οι API routes τοποθετούνται στον κατάλογο `app/api/`.
- **Ονομασία Αρχείων:** Κάθε API endpoint βρίσκεται σε ξεχωριστό φάκελο που περιέχει ένα αρχείο `route.js` ή `route.ts`.
- **Εξαγόμενες Συναρτήσεις:** Αντί για ένα μοναδικό default export, εξάγονται συγκεκριμένες συναρτήσεις για HTTP μεθόδους (π.χ. `GET`, `POST`).
- **Χειρισμός Απαντήσεων:** Χρησιμοποιήστε τον constructor `Response` για να επιστρέψετε responses, επιτρέποντας μεγαλύτερο έλεγχο στα headers και τους status codes.

#### Πώς να χειριστείς άλλες διαδρομές και μεθόδους:

<details>

<summary>Χειρισμός Συγκεκριμένων HTTP Μεθόδων</summary>

Το Next.js 13+ σου επιτρέπει να ορίζεις handlers για συγκεκριμένες HTTP μεθόδους μέσα στο ίδιο αρχείο `route.js` ή `route.ts`, προάγοντας πιο σαφή και οργανωμένο κώδικα.

**Παράδειγμα:**
```javascript
// app/api/users/[id]/route.js

export async function GET(request, { params }) {
const { id } = params
// Fetch user data based on 'id'
return new Response(JSON.stringify({ userId: id, name: "Jane Doe" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function PUT(request, { params }) {
const { id } = params
// Update user data based on 'id'
return new Response(JSON.stringify({ message: `User ${id} updated.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function DELETE(request, { params }) {
const { id } = params
// Delete user based on 'id'
return new Response(JSON.stringify({ message: `User ${id} deleted.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**Επεξήγηση:**

- **Πολλαπλές εξαγωγές:** Κάθε HTTP μέθοδος (`GET`, `PUT`, `DELETE`) έχει τη δική της εξαγόμενη συνάρτηση.
- **Παράμετροι:** Το δεύτερο όρισμα παρέχει πρόσβαση στις παραμέτρους της διαδρομής μέσω του `params`.
- **Βελτιωμένες Απαντήσεις:** Μεγαλύτερος έλεγχος πάνω στα αντικείμενα απάντησης, επιτρέποντας ακριβή διαχείριση headers και status codes.

</details>

<details>

<summary>Catch-All and Nested Routes</summary>

Next.js 13+ υποστηρίζει προχωρημένες λειτουργίες δρομολόγησης όπως catch-all routes και nested API routes, επιτρέποντας πιο δυναμικές και επεκτάσιμες δομές API.

**Catch-All Route Example:**
```javascript
// app/api/[...slug]/route.js

export async function GET(request, { params }) {
const { slug } = params
// Handle dynamic nested routes
return new Response(JSON.stringify({ slug }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**Εξήγηση:**

- **Σύνταξη:** `[...]` υποδηλώνει ένα catch-all τμήμα, που συλλαμβάνει όλα τα εμφωλευμένα μονοπάτια.
- **Χρήση:** Χρήσιμο για APIs που χρειάζεται να χειριστούν μεταβαλλόμενα βάθη διαδρομών ή δυναμικά τμήματα.

**Παράδειγμα εμφωλευμένων διαδρομών:**
```javascript
// app/api/posts/[postId]/comments/[commentId]/route.js

export async function GET(request, { params }) {
const { postId, commentId } = params
// Fetch specific comment for a post
return new Response(
JSON.stringify({ postId, commentId, comment: "Great post!" }),
{
status: 200,
headers: { "Content-Type": "application/json" },
}
)
}
```
**Επεξήγηση:**

- **Βαθιά εμφώλευση:** Επιτρέπει ιεραρχικές δομές API, που αντικατοπτρίζουν τις σχέσεις μεταξύ πόρων.
- **Πρόσβαση σε Παραμέτρους:** Εύκολη πρόσβαση σε πολλαπλές παραμέτρους διαδρομής μέσω του αντικειμένου `params`.

</details>

<details>

<summary>Διαχείριση API routes στο Next.js 12 και παλαιότερα</summary>

## API Routes στον φάκελο `pages` (Next.js 12 και παλαιότερα)

Πριν το Next.js 13 εισάγει τον φάκελο `app` και τις βελτιωμένες δυνατότητες δρομολόγησης, οι API routes ορίζονταν κυρίως μέσα στον φάκελο `pages`. Αυτή η προσέγγιση εξακολουθεί να χρησιμοποιείται ευρέως και υποστηρίζεται στις εκδόσεις Next.js 12 και παλαιότερες.

#### Βασική API Route

**Δομή Αρχείων:**
```go
goCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── hello.js
├── package.json
└── ...
```
**Υλοποίηση:**
```javascript
javascriptCopy code// pages/api/hello.js

export default function handler(req, res) {
res.status(200).json({ message: 'Hello, World!' });
}
```
**Επεξήγηση:**

- **Location:** Οι API routes βρίσκονται στον κατάλογο `pages/api/`.
- **Export:** Χρησιμοποιήστε `export default` για να ορίσετε τη συνάρτηση handler.
- **Function Signature:** Η συνάρτηση handler λαμβάνει αντικείμενα `req` (HTTP request) και `res` (HTTP response).
- **Routing:** Το όνομα αρχείου (`hello.js`) αντιστοιχεί στο endpoint `/api/hello`.

#### Δυναμικές API Routes

**Δομή αρχείων:**
```bash
bashCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── users/
│           └── [id].js
├── package.json
└── ...
```
**Υλοποίηση:**
```javascript
javascriptCopy code// pages/api/users/[id].js

export default function handler(req, res) {
const {
query: { id },
method,
} = req;

switch (method) {
case 'GET':
// Fetch user data based on 'id'
res.status(200).json({ userId: id, name: 'John Doe' });
break;
case 'PUT':
// Update user data based on 'id'
res.status(200).json({ message: `User ${id} updated.` });
break;
case 'DELETE':
// Delete user based on 'id'
res.status(200).json({ message: `User ${id} deleted.` });
break;
default:
res.setHeader('Allow', ['GET', 'PUT', 'DELETE']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**Εξήγηση:**

- **Δυναμικά Τμήματα:** Τα αγκύλες (`[id].js`) δηλώνουν δυναμικά τμήματα διαδρομής.
- **Πρόσβαση σε Παράμετρους:** Χρησιμοποιήστε `req.query.id` για να αποκτήσετε πρόσβαση στην δυναμική παράμετρο.
- **Χειρισμός Μεθόδων:** Χρησιμοποιήστε λογική με συνθήκες για να χειριστείτε διαφορετικές HTTP μεθόδους (`GET`, `PUT`, `DELETE`, κ.λπ.).

#### Χειρισμός Διαφορετικών HTTP Μεθόδων

Ενώ το βασικό παράδειγμα διαδρομής API χειρίζεται όλες τις HTTP μεθόδους μέσα σε μία συνάρτηση, μπορείτε να οργανώσετε τον κώδικά σας ώστε να χειρίζεται κάθε μέθοδο ρητά για καλύτερη σαφήνεια και συντηρησιμότητα.

**Παράδειγμα:**
```javascript
javascriptCopy code// pages/api/posts.js

export default async function handler(req, res) {
const { method } = req;

switch (method) {
case 'GET':
// Handle GET request
res.status(200).json({ message: 'Fetching posts.' });
break;
case 'POST':
// Handle POST request
res.status(201).json({ message: 'Post created.' });
break;
default:
res.setHeader('Allow', ['GET', 'POST']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**Βέλτιστες Πρακτικές:**

- **Διαχωρισμός Ευθυνών:** Διαχωρίστε σαφώς τη λογική για διαφορετικές μεθόδους HTTP.
- **Συνέπεια Αποκρίσεων:** Διασφαλίστε συνεπή δομή αποκρίσεων για ευκολότερη διαχείριση από την πλευρά του client.
- **Διαχείριση Σφαλμάτων:** Χειριστείτε ομαλά τις μη υποστηριζόμενες μεθόδους και τα απρόσμενα σφάλματα.

</details>

### Ρύθμιση CORS

Ελέγξτε ποιες origins μπορούν να έχουν πρόσβαση στις API routes σας, με σκοπό να μετριάσετε τις ευπάθειες Cross-Origin Resource Sharing (CORS).

**Κακό Παράδειγμα Ρύθμισης:**
```javascript
// app/api/data/route.js

export async function GET(request) {
return new Response(JSON.stringify({ data: "Public Data" }), {
status: 200,
headers: {
"Access-Control-Allow-Origin": "*", // Allows any origin
"Access-Control-Allow-Methods": "GET, POST, PUT, DELETE",
},
})
}
```
Σημειώστε ότι **το CORS μπορεί επίσης να ρυθμιστεί σε όλες τις API routes** μέσα στο αρχείο **`middleware.ts`**:
```javascript
// app/middleware.ts

import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(request: NextRequest) {
const allowedOrigins = [
"https://yourdomain.com",
"https://sub.yourdomain.com",
]
const origin = request.headers.get("Origin")

const response = NextResponse.next()

if (allowedOrigins.includes(origin || "")) {
response.headers.set("Access-Control-Allow-Origin", origin || "")
response.headers.set(
"Access-Control-Allow-Methods",
"GET, POST, PUT, DELETE, OPTIONS"
)
response.headers.set(
"Access-Control-Allow-Headers",
"Content-Type, Authorization"
)
// If credentials are needed:
// response.headers.set('Access-Control-Allow-Credentials', 'true');
}

// Handle preflight requests
if (request.method === "OPTIONS") {
return new Response(null, {
status: 204,
headers: response.headers,
})
}

return response
}

export const config = {
matcher: "/api/:path*", // Apply to all API routes
}
```
**Πρόβλημα:**

- **`Access-Control-Allow-Origin: '*'`:** Επιτρέπει σε οποιονδήποτε ιστότοπο να έχει πρόσβαση στο API, ενδεχομένως επιτρέποντας σε κακόβουλους ιστότοπους να αλληλεπιδρούν με το API σας χωρίς περιορισμούς.
- **Ευρεία Αποδοχή Μεθόδων:** Το να επιτρέπονται όλες οι μέθοδοι μπορεί να δώσει τη δυνατότητα σε επιτιθέμενους να εκτελέσουν ανεπιθύμητες ενέργειες.

**Πώς το εκμεταλλεύονται οι επιτιθέμενοι:**

Οι επιτιθέμενοι μπορούν να δημιουργήσουν κακόβουλους ιστότοπους που κάνουν αιτήματα στο API σας, πιθανόν καταχρώμενοι λειτουργίες όπως ανάκτηση δεδομένων, τροποποίηση δεδομένων ή ενεργοποίηση ανεπιθύμητων ενεργειών εξ ονόματος πιστοποιημένων χρηστών.


{{#ref}}
../../pentesting-web/cors-bypass.md
{{#endref}}

### Έκθεση κώδικα διακομιστή στην πλευρά πελάτη

Μπορεί να είναι εύκολο να **χρησιμοποιηθεί κώδικας που χρησιμοποιείται από τον server και επίσης να εκτεθεί και να χρησιμοποιηθεί στην πλευρά του client**. Ο καλύτερος τρόπος για να διασφαλίσετε ότι ένα αρχείο κώδικα δεν θα εκτεθεί στην πλευρά του client είναι να χρησιμοποιήσετε αυτό το import στην αρχή του αρχείου:
```js
import "server-only"
```
## Κύρια Αρχεία και ο Ρόλος τους

### `middleware.ts` / `middleware.js`

**Τοποθεσία:** Στη ρίζα του έργου ή μέσα στο `src/`.

**Σκοπός:** Εκτελεί κώδικα σε λειτουργία serverless από την πλευρά του διακομιστή πριν επεξεργαστεί ένα αίτημα, επιτρέποντας εργασίες όπως έλεγχος ταυτότητας, ανακατευθύνσεις ή τροποποίηση απαντήσεων.

**Ροή Εκτέλεσης:**

1. **Εισερχόμενο Αίτημα:** Το middleware παρεμβάλλεται στο αίτημα.
2. **Επεξεργασία:** Εκτελεί λειτουργίες βάσει του αιτήματος (π.χ. έλεγχος ταυτότητας).
3. **Τροποποίηση Απάντησης:** Μπορεί να αλλάξει την απάντηση ή να δώσει τον έλεγχο στον επόμενο handler.

**Παραδείγματα Χρήσης:**

- Ανακατεύθυνση μη αυθεντικοποιημένων χρηστών.
- Προσθήκη προσαρμοσμένων κεφαλίδων.
- Καταγραφή αιτημάτων.

**Παράδειγμα Διαμόρφωσης:**
```typescript
// middleware.ts
import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(req: NextRequest) {
const url = req.nextUrl.clone()
if (!req.cookies.has("token")) {
url.pathname = "/login"
return NextResponse.redirect(url)
}
return NextResponse.next()
}

export const config = {
matcher: ["/protected/:path*"],
}
```
### `next.config.js`

**Τοποθεσία:** Ρίζα του έργου.

**Σκοπός:** Διαμορφώνει τη συμπεριφορά του Next.js, ενεργοποιώντας ή απενεργοποιώντας δυνατότητες, προσαρμόζοντας τις ρυθμίσεις του webpack, ορίζοντας μεταβλητές περιβάλλοντος και ρυθμίζοντας διάφορες λειτουργίες ασφάλειας.

**Κύριες Ρυθμίσεις Ασφαλείας:**

<details>

<summary>Κεφαλίδες Ασφαλείας</summary>

Οι κεφαλίδες ασφαλείας ενισχύουν την ασφάλεια της εφαρμογής σας, καθοδηγώντας τα browsers σχετικά με το πώς να χειρίζονται το περιεχόμενο. Βοηθούν στη μείωση διαφόρων επιθέσεων όπως Cross-Site Scripting (XSS), Clickjacking και MIME type sniffing:

- Content Security Policy (CSP)
- X-Frame-Options
- X-Content-Type-Options
- Strict-Transport-Security (HSTS)
- Referrer Policy

**Παραδείγματα:**
```javascript
// next.config.js

module.exports = {
async headers() {
return [
{
source: "/(.*)", // Apply to all routes
headers: [
{
key: "X-Frame-Options",
value: "DENY",
},
{
key: "Content-Security-Policy",
value:
"default-src *; script-src 'self' 'unsafe-inline' 'unsafe-eval';",
},
{
key: "X-Content-Type-Options",
value: "nosniff",
},
{
key: "Strict-Transport-Security",
value: "max-age=63072000; includeSubDomains; preload", // Enforces HTTPS
},
{
key: "Referrer-Policy",
value: "no-referrer", // Completely hides referrer
},
// Additional headers...
],
},
]
},
}
```
</details>

<details>

<summary>Ρυθμίσεις βελτιστοποίησης εικόνων</summary>

Next.js βελτιστοποιεί τις εικόνες για απόδοση, αλλά λανθασμένες ρυθμίσεις μπορούν να οδηγήσουν σε ευπάθειες ασφαλείας, όπως το να επιτρέπεται σε μη αξιόπιστες πηγές η έγχυση κακόβουλου περιεχομένου.

**Παράδειγμα κακής ρύθμισης:**
```javascript
// next.config.js

module.exports = {
images: {
domains: ["*"], // Allows images from any domain
},
}
```
**Πρόβλημα:**

- **`'*'`:** Επιτρέπει τη φόρτωση εικόνων από οποιαδήποτε εξωτερική πηγή, συμπεριλαμβανομένων μη αξιόπιστων ή κακόβουλων domains. Οι επιτιθέμενοι μπορούν να φιλοξενήσουν εικόνες που περιέχουν κακόβουλα payloads ή περιεχόμενο που παραπλανά τους χρήστες.
- Ένα άλλο πρόβλημα μπορεί να είναι να επιτρέπεται ένα domain **όπου ο καθένας μπορεί να ανεβάσει μια εικόνα** (όπως `raw.githubusercontent.com`)

**How attackers abuse it:**

Με την εισαγωγή εικόνων από κακόβουλες πηγές, οι επιτιθέμενοι μπορούν να πραγματοποιήσουν phishing attacks, να εμφανίσουν παραπλανητικές πληροφορίες ή να εκμεταλλευτούν ευπάθειες σε image rendering libraries.

</details>

<details>

<summary>Έκθεση μεταβλητών περιβάλλοντος</summary>

Διαχειριστείτε ευαίσθητες πληροφορίες όπως API keys και διαπιστευτήρια βάσης δεδομένων με ασφάλεια χωρίς να τα εκθέτετε στον client.

#### a. Έκθεση ευαίσθητων μεταβλητών

**Κακό παράδειγμα ρύθμισης:**
```javascript
// next.config.js

module.exports = {
env: {
SECRET_API_KEY: process.env.SECRET_API_KEY, // Exposed to the client
NEXT_PUBLIC_API_URL: process.env.NEXT_PUBLIC_API_URL, // Correctly prefixed for client
},
}
```
**Πρόβλημα:**

- **`SECRET_API_KEY`:** Χωρίς το πρόθεμα `NEXT_PUBLIC_`, το Next.js δεν εκθέτει μεταβλητές στον client. Ωστόσο, αν προστεθεί λανθασμένα ως πρόθεμα (π.χ., `NEXT_PUBLIC_SECRET_API_KEY`), γίνεται προσβάσιμη στο client side.

**Πώς το εκμεταλλεύονται οι επιτιθέμενοι:**

Αν ευαίσθητες μεταβλητές εκτεθούν στον client, οι επιτιθέμενοι μπορούν να τις ανακτήσουν εξετάζοντας τον client-side code ή τα network requests, αποκτώντας μη εξουσιοδοτημένη πρόσβαση σε APIs, databases ή άλλες υπηρεσίες.

</details>

<details>

<summary>Ανακατευθύνσεις</summary>

Διαχειριστείτε URL redirections και rewrites μέσα στην εφαρμογή σας, εξασφαλίζοντας ότι οι χρήστες κατευθύνονται σωστά χωρίς να εισάγετε open redirect vulnerabilities.

#### a. Open Redirect Vulnerability

**Κακό Παράδειγμα Διαμόρφωσης:**
```javascript
// next.config.js

module.exports = {
async redirects() {
return [
{
source: "/redirect",
destination: (req) => req.query.url, // Dynamically redirects based on query parameter
permanent: false,
},
]
},
}
```
**Πρόβλημα:**

- **Δυναμικός Προορισμός:** Επιτρέπει στους χρήστες να καθορίσουν οποιοδήποτε URL, επιτρέποντας open redirect attacks.
- **Εμπιστοσύνη στην είσοδο του χρήστη:** Ανακατευθύνσεις σε URLs που παρέχονται από χρήστες χωρίς έλεγχο μπορούν να οδηγήσουν σε phishing, malware distribution, ή credential theft.

**Πώς το εκμεταλλεύονται οι επιτιθέμενοι:**

Οι επιτιθέμενοι μπορούν να δημιουργήσουν URLs που φαίνεται να προέρχονται από το domain σας αλλά ανακατευθύνουν τους χρήστες σε κακόβουλους ιστότοπους. Για παράδειγμα:
```bash
https://yourdomain.com/redirect?url=https://malicious-site.com
```
Χρήστες που εμπιστεύονται το αρχικό domain μπορεί να πλοηγηθούν χωρίς να το γνωρίζουν σε κακόβουλους ιστότοπους.

</details>

<details>

<summary>Webpack Configuration</summary>

Προσαρμόστε τις ρυθμίσεις του Webpack για την εφαρμογή σας Next.js, κάτι που μπορεί να εισαγάγει χωρίς πρόθεση ευπάθειες ασφαλείας αν δεν αντιμετωπιστεί προσεκτικά.

#### a. Αποκάλυψη Ευαίσθητων Μονάδων

**Κακό Παράδειγμα Διαμόρφωσης:**
```javascript
// next.config.js

module.exports = {
webpack: (config, { isServer }) => {
if (!isServer) {
config.resolve.alias["@sensitive"] = path.join(__dirname, "secret-folder")
}
return config
},
}
```
**Πρόβλημα:**

- **Αποκάλυψη Ευαίσθητων Διαδρομών:** Η δημιουργία alias για ευαίσθητους φακέλους και η παροχή πρόσβασης από την client-side μπορεί to leak εμπιστευτικές πληροφορίες.
- **Bundling Secrets:** Εάν ευαίσθητα αρχεία bundled για τον client, το περιεχόμενό τους γίνεται προσβάσιμο μέσω source maps ή με έλεγχο του client-side code.

**Πώς το εκμεταλλεύονται οι επιτιθέμενοι:**

Οι επιτιθέμενοι μπορούν να αποκτήσουν πρόσβαση ή να ανακατασκευάσουν τη δομή καταλόγων της εφαρμογής, ενδεχομένως εντοπίζοντας και εκμεταλλευόμενοι ευαίσθητα αρχεία ή δεδομένα.

</details>

### `pages/_app.js` and `pages/_document.js`

#### **`pages/_app.js`**

**Σκοπός:** Αντικαθιστά το προεπιλεγμένο App component, επιτρέποντας global state, styles και components για layout.

**Περιπτώσεις Χρήσης:**

- Εισαγωγή global CSS.
- Προσθήκη layout wrappers.
- Ενσωμάτωση state management libraries.

**Παράδειγμα:**
```jsx
// pages/_app.js
import "../styles/globals.css"

function MyApp({ Component, pageProps }) {
return <Component {...pageProps} />
}

export default MyApp
```
#### **`pages/_document.js`**

**Σκοπός:** Αντικαθιστά το προεπιλεγμένο Document, επιτρέποντας την προσαρμογή των tags `<html>` και `<body>`.

**Περιπτώσεις χρήσης:**

- Τροποποίηση των `<html>` ή `<body>` tags.
- Προσθήκη meta tags ή προσαρμοσμένων scripts.
- Ενσωμάτωση γραμματοσειρών τρίτων.

**Παράδειγμα:**
```jsx
// pages/_document.js
import Document, { Html, Head, Main, NextScript } from "next/document"

class MyDocument extends Document {
render() {
return (
<Html lang="en">
<Head>{/* Custom fonts or meta tags */}</Head>
<body>
<Main />
<NextScript />
</body>
</Html>
)
}
}

export default MyDocument
```
### Προσαρμοσμένος διακομιστής (Προαιρετικό)

**Σκοπός:** Ενώ το Next.js παρέχει ενσωματωμένο διακομιστή, μπορείτε να δημιουργήσετε προσαρμοσμένο διακομιστή για προηγμένες περιπτώσεις χρήσης όπως προσαρμοσμένη δρομολόγηση ή ενσωμάτωση με υπάρχουσες υπηρεσίες backend.

**Σημείωση:** Η χρήση προσαρμοσμένου διακομιστή μπορεί να περιορίσει τις επιλογές ανάπτυξης, ειδικά σε πλατφόρμες όπως η Vercel που βελτιστοποιούν για τον ενσωματωμένο διακομιστή του Next.js.

**Παράδειγμα:**
```javascript
// server.js
const express = require("express")
const next = require("next")

const dev = process.env.NODE_ENV !== "production"
const app = next({ dev })
const handle = app.getRequestHandler()

app.prepare().then(() => {
const server = express()

// Custom route
server.get("/a", (req, res) => {
return app.render(req, res, "/a")
})

// Default handler
server.all("*", (req, res) => {
return handle(req, res)
})

server.listen(3000, (err) => {
if (err) throw err
console.log("> Ready on http://localhost:3000")
})
})
```
---

## Επιπλέον Αρχιτεκτονικές και Θέματα Ασφαλείας

### Μεταβλητές Περιβάλλοντος και Διαμόρφωση

**Σκοπός:** Διαχείριση ευαίσθητων πληροφοριών και ρυθμίσεων διαμόρφωσης εκτός του κώδικα.

**Καλύτερες Πρακτικές:**

- **Χρησιμοποιήστε αρχεία `.env`:** Αποθηκεύστε μεταβλητές όπως API keys στο `.env.local` (εξαιρείται από τον έλεγχο έκδοσης).
- **Πρόσβαση στις μεταβλητές με ασφάλεια:** Χρησιμοποιήστε `process.env.VARIABLE_NAME` για πρόσβαση στις μεταβλητές περιβάλλοντος.
- **Μη δίνετε ποτέ πρόσβαση σε μυστικά από τον client:** Βεβαιωθείτε ότι οι ευαίσθητες μεταβλητές χρησιμοποιούνται μόνο server-side.

**Παράδειγμα:**
```javascript
// next.config.js
module.exports = {
env: {
API_KEY: process.env.API_KEY, // Accessible on both client and server
SECRET_KEY: process.env.SECRET_KEY, // Be cautious if accessible on the client
},
}
```
**Σημείωση:** Για να περιορίσετε μεταβλητές μόνο στην πλευρά του server, παραλείψτε τες από το `env` αντικείμενο ή προθέστε `NEXT_PUBLIC_` για έκθεση στο client.

### Πιστοποίηση και Εξουσιοδότηση

**Προσέγγιση:**

- **Session-Based Authentication:** Χρησιμοποιήστε cookies για τη διαχείριση των συνεδριών χρηστών.
- **Token-Based Authentication:** Υλοποιήστε JWTs για stateless authentication.
- **Third-Party Providers:** Ενσωματώστε OAuth providers (π.χ., Google, GitHub) χρησιμοποιώντας βιβλιοθήκες όπως `next-auth`.

**Πρακτικές Ασφαλείας:**

- **Secure Cookies:** Ορίστε τα attributes `HttpOnly`, `Secure` και `SameSite`.
- **Password Hashing:** Πάντα κάντε hash τους κωδικούς πριν τους αποθηκεύσετε.
- **Input Validation:** Αποφύγετε injection attacks επικυρώνοντας και sanitizing τα inputs.

**Παράδειγμα:**
```javascript
// pages/api/login.js
import { sign } from "jsonwebtoken"
import { serialize } from "cookie"

export default async function handler(req, res) {
const { username, password } = req.body

// Validate user credentials
if (username === "admin" && password === "password") {
const token = sign({ username }, process.env.JWT_SECRET, {
expiresIn: "1h",
})
res.setHeader(
"Set-Cookie",
serialize("auth", token, {
path: "/",
httpOnly: true,
secure: true,
sameSite: "strict",
})
)
res.status(200).json({ message: "Logged in" })
} else {
res.status(401).json({ error: "Invalid credentials" })
}
}
```
### Βελτιστοποίηση Απόδοσης

**Στρατηγικές:**

- **Βελτιστοποίηση εικόνων:** Χρησιμοποιήστε το component `next/image` του Next.js για αυτόματη βελτιστοποίηση εικόνων.
- **Διαχωρισμός κώδικα:** Εκμεταλλευτείτε τις δυναμικές εισαγωγές (dynamic imports) για να χωρίσετε τον κώδικα και να μειώσετε τους αρχικούς χρόνους φόρτωσης.
- **Caching:** Εφαρμόστε στρατηγικές caching για απαντήσεις API και στατικά αρχεία.
- **Lazy Loading:** Φορτώστε components ή αρχεία μόνο όταν χρειάζονται.

**Παράδειγμα:**
```jsx
// Dynamic Import with Code Splitting
import dynamic from "next/dynamic"

const HeavyComponent = dynamic(() => import("../components/HeavyComponent"), {
loading: () => <p>Loading...</p>,
})
```
## Εντοπισμός Next.js Server Actions (hash to function name via source maps)

Το σύγχρονο Next.js χρησιμοποιεί «Server Actions» που εκτελούνται στον server αλλά καλούνται από τον client. Σε production αυτές οι κλήσεις είναι αδιαφανείς: όλες οι POSTs καταλήγουν σε ένα κοινό endpoint και διακρίνονται από ένα build-specific hash που στέλνεται στην κεφαλίδα `Next-Action`. Παράδειγμα:
```http
POST /
Next-Action: a9f8e2b4c7d1...
```
When `productionBrowserSourceMaps` is enabled, minified JS chunks contain calls to `createServerReference(...)` that leak enough structure (plus associated source maps) to recover a mapping between the action hash and the original function name. This lets you translate hashes observed in `Next-Action` into concrete targets like `deleteUserAccount()` or `exportFinancialData()`.

### Προσέγγιση εξαγωγής (regex on minified JS + optional source maps)

Αναζητήστε τα downloaded JS chunks για `createServerReference` και εξάγετε το hash και το function/source symbol. Δύο χρήσιμα patterns:
```regex
# Strict pattern for standard minification
createServerReference\)\"([a-f0-9]{40,})\",\w+\.callServer,void 0,\w+\.findSourceMapURL,\"([^\"]+)\"\)

# Flexible pattern handling various minification styles
createServerReference[^\"]*\"([a-f0-9]{40,})\"[^\"]*\"([^\"]+)\"\s*\)
```
- Ομάδα 1: server action hash (40+ hex chars)
- Ομάδα 2: symbol ή path που μπορεί να επιλυθεί στο αρχικό όνομα συνάρτησης μέσω του source map όταν υπάρχει

Αν το script δηλώνει ένα source map (trailer comment `//# sourceMappingURL=<...>.map`), κατεβάστε το και επιλύστε το symbol/path στο αρχικό όνομα συνάρτησης.

### Πρακτική ροή εργασίας

- Παθητική ανακάλυψη κατά την περιήγηση: καταγράψτε requests με `Next-Action` headers και JS chunk URLs.
- Fetch τα αναφερόμενα JS bundles και τα συνοδευτικά `*.map` αρχεία (όταν υπάρχουν).
- Εκτελέστε το regex παραπάνω για να φτιάξετε ένα λεξικό hash↔name.
- Χρησιμοποιήστε το λεξικό για στοχοθετημένες δοκιμές:
- Διαλογή με βάση το όνομα (π.χ., `transferFunds`, `exportFinancialData`).
- Παρακολουθήστε την κάλυψη ανάμεσα σε builds με βάση το όνομα συνάρτησης (hashes αλλάζουν μεταξύ builds).

### Εκτέλεση κρυφών actions (template-based request)

Πάρτε ένα έγκυρο POST που παρατηρήθηκε στο proxy ως πρότυπο και αντικαταστήστε την τιμή `Next-Action` για να στοχεύσετε άλλη ανακαλυφθείσα action:
```http
# Before
Next-Action: a9f8e2b4c7d1

# After
Next-Action: b7e3f9a2d8c5
```
Επανεκτέλεσε στο Repeater και δοκίμασε authorization, input validation και business logic ενεργειών που διαφορετικά είναι μη προσβάσιμες.

### Αυτοματισμός Burp

- NextjsServerActionAnalyzer (Burp extension) αυτοματοποιεί τα παραπάνω στο Burp:
- Σαρώνει το proxy history για JS chunks, εξάγει καταχωρήσεις `createServerReference(...)` και αναλύει source maps όταν είναι διαθέσιμα.
- Διατηρεί ένα αναζητήσιμο λεξικό hash↔function-name και αφαιρεί διπλότυπα ανά build με βάση το function name.
- Μπορεί να εντοπίσει ένα έγκυρο template POST και να ανοίξει μια έτοιμη προς αποστολή καρτέλα Repeater με το hash της στοχευόμενης ενέργειας αντικατεστημένο.
- Repo: https://github.com/Adversis/NextjsServerActionAnalyzer

### Σημειώσεις και περιορισμοί

- Απαιτεί `productionBrowserSourceMaps` ενεργοποιημένο στην production για την ανάκτηση ονομάτων από bundles/source maps.
- Η αποκάλυψη του function-name δεν αποτελεί ευπάθεια από μόνη της· χρησιμοποίησέ την για να καθοδηγήσεις την ανακάλυψη και να δοκιμάσεις την authorization κάθε ενέργειας.

## References

- [Pentesting Next.js Server Actions — A Burp Extension for Hash-to-Function Mapping](https://www.adversis.io/blogs/pentesting-next-js-server-actions)
- [NextjsServerActionAnalyzer (Burp extension)](https://github.com/Adversis/NextjsServerActionAnalyzer)

{{#include ../../banners/hacktricks-training.md}}
