# NextJS

{{#include ../../banners/hacktricks-training.md}}

## Next.js एप्लिकेशन की सामान्य वास्तुकला

### सामान्य फ़ाइल संरचना

एक मानक Next.js प्रोजेक्ट एक विशिष्ट फ़ाइल और डायरेक्टरी संरचना का पालन करता है जो इसके फीचर्स जैसे रूटिंग, API endpoints, और स्टैटिक एसेट प्रबंधन को सक्षम बनाती है। यहाँ एक सामान्य लेआउट है:
```lua
my-nextjs-app/
├── node_modules/
├── public/
│   ├── images/
│   │   └── logo.png
│   └── favicon.ico
├── app/
│   ├── api/
│   │   └── hello/
│   │       └── route.ts
│   ├── layout.tsx
│   ├── page.tsx
│   ├── about/
│   │   └── page.tsx
│   ├── dashboard/
│   │   ├── layout.tsx
│   │   └── page.tsx
│   ├── components/
│   │   ├── Header.tsx
│   │   └── Footer.tsx
│   ├── styles/
│   │   ├── globals.css
│   │   └── Home.module.css
│   └── utils/
│       └── api.ts
├── .env.local
├── next.config.js
├── tsconfig.json
├── package.json
├── README.md
└── yarn.lock / package-lock.json

```
### मुख्य निर्देशिकाएँ और फ़ाइलें

- **public/:** images, fonts, और अन्य फाइलों जैसे static assets को host करता है। यहाँ की फाइलें root path (`/`) पर उपलब्ध होती हैं।
- **app/:** आपके application के pages, layouts, components, और API routes के लिए केंद्रीय निर्देशिका। यह **App Router** पैटर्न को अपनाती है, जिससे उन्नत routing सुविधाएँ और server-client component segregation संभव होता है।
- **app/layout.tsx:** आपके एप्लिकेशन के लिए root layout को परिभाषित करता है, जो सभी पृष्ठों को घेरता है और headers, footers, और navigation bars जैसे सामंजस्यपूर्ण UI elements प्रदान करता है।
- **app/page.tsx:** root route `/` के लिए entry point के रूप में कार्य करता है, जो home page को render करता है।
- **app/[route]/page.tsx:** static और dynamic routes को संभालता है। `app/` के भीतर प्रत्येक फ़ोल्डर एक route segment का प्रतिनिधित्व करता है, और उन फ़ोल्डरों के भीतर `page.tsx` उस route के component के अनुरूप होता है।
- **app/api/:** API routes को समाहित करता है, जिससे आप serverless functions बना सकते हैं जो HTTP requests को हैंडल करते हैं। ये routes पारंपरिक `pages/api` निर्देशिका की जगह लेते हैं।
- **app/components/:** reusable React components को रखता है जिन्हें विभिन्न pages और layouts में उपयोग किया जा सकता है।
- **app/styles/:** global CSS फाइलें और component-scoped styling के लिए CSS Modules रखता है।
- **app/utils/:** utility functions, helper modules, और अन्य non-UI logic शामिल करता है जिन्हें application भर में साझा किया जा सकता है।
- **.env.local:** स्थानीय development environment के लिए specific environment variables को स्टोर करता है। ये variables version control में commit नहीं किए जाते।
- **next.config.js:** Next.js व्यवहार को अनुकूलित करता है, जिसमें webpack configurations, environment variables, और security settings शामिल हैं।
- **tsconfig.json:** परियोजना के लिए TypeScript सेटिंग्स को कॉन्फ़िगर करता है, जिससे type checking और अन्य TypeScript सुविधाएँ सक्षम होती हैं।
- **package.json:** परियोजना की dependencies, scripts, और metadata का प्रबंधन करता है।
- **README.md:** परियोजना के बारे में documentation और जानकारी प्रदान करता है, जिसमें setup निर्देश, usage guidelines, और अन्य प्रासंगिक विवरण शामिल हैं।
- **yarn.lock / package-lock.json:** परियोजना की dependencies को विशिष्ट संस्करणों तक लॉक करता है, जिससे विभिन्न environments में consistent installations सुनिश्चित होते हैं।

## Next.js में क्लाइंट-साइड

### `app` निर्देशिका में File-Based Routing

`app` निर्देशिका नवीनतम Next.js संस्करणों में routing का आधार है। यह filesystem का उपयोग करके routes को परिभाषित करती है, जिससे route प्रबंधन सहज और स्केलेबल होता है।

<details>

<summary>रूट पाथ / को संभालना</summary>

**File Structure:**
```arduino
my-nextjs-app/
├── app/
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**मुख्य फाइलें:**

- **`app/page.tsx`**: रूट पाथ `/` के अनुरोधों को हैंडल करता है।
- **`app/layout.tsx`**: एप्लिकेशन के लिए लेआउट को परिभाषित करता है, जो सभी पेजों को रैप करता है।

**क्रियान्वयन:**
```tsx
tsxCopy code// app/page.tsx

export default function HomePage() {
return (
<div>
<h1>Welcome to the Home Page!</h1>
<p>This is the root route.</p>
</div>
);
}
```
**स्पष्टीकरण:**

- **रूट परिभाषा:** The `page.tsx` file directly under the `app` directory corresponds to the `/` route.
- **रेन्डरिंग:** यह कॉम्पोनेंट होम पेज के लिए कंटेंट रेंडर करता है।
- **लेआउट एकीकरण:** The `HomePage` component is wrapped by the `layout.tsx`, which can include headers, footers, and other common elements.

</details>

<details>

<summary>अन्य स्टेटिक पाथ्स को हैंडल करना</summary>

**उदाहरण: `/about` रूट**

**फ़ाइल संरचना:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── about/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**क्रियान्वयन:**
```tsx
// app/about/page.tsx

export default function AboutPage() {
return (
<div>
<h1>About Us</h1>
<p>Learn more about our mission and values.</p>
</div>
)
}
```
**व्याख्या:**

- **रूट परिभाषा:** `page.tsx` फ़ाइल `about` फ़ोल्डर के अंदर `/about` रूट के अनुरूप होती है।
- **रेंडरिंग:** यह कंपोनेंट about पृष्ठ की सामग्री रेंडर करता है।

</details>

<details>

<summary>डायनेमिक रूट्स</summary>

डायनेमिक रूट्स वेरिएबल सेगमेंट वाले पाथ्स को हैंडल करने की अनुमति देते हैं, जिससे एप्लिकेशन पैरामीटर जैसे IDs, slugs आदि के आधार पर कंटेंट प्रदर्शित कर सकें।

**उदाहरण: `/posts/[id]` रूट**

**फ़ाइल संरचना:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── posts/
│   │   └── [id]/
│   │       └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**क्रियान्वयन:**
```tsx
tsxCopy code// app/posts/[id]/page.tsx

import { useRouter } from 'next/navigation';

interface PostProps {
params: { id: string };
}

export default function PostPage({ params }: PostProps) {
const { id } = params;
// Fetch post data based on 'id'

return (
<div>
<h1>Post #{id}</h1>
<p>This is the content of post {id}.</p>
</div>
);
}
```
**व्याख्या:**

- **डायनामिक सेगमेंट:** `[id]` रूट में एक डायनामिक सेगमेंट को दर्शाता है, जो URL से `id` पेरामीटर को कैप्चर करता है।
- **पैरामीटर एक्सेस करना:** `params` ऑब्जेक्ट डायनामिक पैरामीटर्स रखता है, और इसे component के भीतर एक्सेस किया जा सकता है।
- **रूट मैचिंग:** `/posts/*` से मैच करने वाला कोई भी path, जैसे `/posts/1`, `/posts/abc` आदि, इस component द्वारा हैंडल किया जाएगा।

</details>

<details>

<summary>नेस्टेड रूट्स</summary>

Next.js नेस्टेड राउटिंग को सपोर्ट करता है, जिससे डायरेक्टरी लेआउट के अनुरूप hierarchical route संरचनाएँ बनती हैं।

**उदाहरण: `/dashboard/settings/profile` रूट**

**फ़ाइल संरचना:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── dashboard/
│   │   ├── settings/
│   │   │   └── profile/
│   │   │       └── page.tsx
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**क्रियान्वयन:**
```tsx
tsxCopy code// app/dashboard/settings/profile/page.tsx

export default function ProfileSettingsPage() {
return (
<div>
<h1>Profile Settings</h1>
<p>Manage your profile information here.</p>
</div>
);
}
```
**व्याख्या:**

- **गहरी नेस्टिंग:** फ़ाइल `page.tsx`, जो `dashboard/settings/profile/` के अंदर है, `/dashboard/settings/profile` रूट के अनुरूप है।
- **हायरार्की का प्रतिबिंब:** डायरेक्टरी संरचना URL पथ को परिलक्षित करती है, जिससे रख-रखाव और स्पष्टता बेहतर होती है।

</details>

<details>

<summary>Catch-All Routes</summary>

Catch-all रूट्स कई नेस्टेड सेगमेंट या अज्ञात पथों को संभालते हैं, रूट हैंडलिंग में लचीलापन प्रदान करते हैं।

**उदाहरण: `/*` रूट**

**फ़ाइल संरचना:**
```arduino
my-nextjs-app/
├── app/
│   ├── [...slug]/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**कार्यान्वयन:**
```tsx
// app/[...slug]/page.tsx

interface CatchAllProps {
params: { slug: string[] }
}

export default function CatchAllPage({ params }: CatchAllProps) {
const { slug } = params
const fullPath = `/${slug.join("/")}`

return (
<div>
<h1>Catch-All Route</h1>
<p>You have navigated to: {fullPath}</p>
</div>
)
}
```
**व्याख्या:**

- **Catch-All Segment:** `[...slug]` शेष सभी पाथ खंडों को एक array के रूप में कैप्चर करता है।
- **Usage:** dynamic routing परिदृश्यों को संभालने के लिए उपयोगी, जैसे user-generated paths, nested categories, आदि।
- **Route Matching:** ऐसे paths जैसे `/anything/here`, `/foo/bar/baz` आदि इस component द्वारा संभाले जाते हैं।

</details>

### संभावित क्लाइंट-साइड कमजोरियाँ

हालाँकि Next.js एक सुरक्षित आधार प्रदान करता है, गलत coding प्रथाएँ कमजोरियाँ उत्पन्न कर सकती हैं। प्रमुख क्लाइंट-साइड कमजोरियों में शामिल हैं:

<details>

<summary>Cross-Site Scripting (XSS)</summary>

XSS हमले तब होते हैं जब दुर्भावनापूर्ण स्क्रिप्ट्स भरोसेमंद वेबसाइट्स में इंजेक्ट किए जाते हैं। हमलावर उपयोगकर्ताओं के ब्राउज़र में स्क्रिप्ट्स चला सकते हैं, डेटा चुरा सकते हैं या उपयोगकर्ता की ओर से क्रियाएँ कर सकते हैं।

**कमजोर कोड का उदाहरण:**
```jsx
// Dangerous: Injecting user input directly into HTML
function Comment({ userInput }) {
return <div dangerouslySetInnerHTML={{ __html: userInput }} />
}
```
**क्यों यह असुरक्षित है:** `dangerouslySetInnerHTML` का उपयोग untrusted input के साथ करने से attackers को दुर्भावनापूर्ण स्क्रिप्ट इंजेक्ट करने की अनुमति मिलती है।

</details>

<details>

<summary>Client-Side Template Injection</summary>

यह तब होता है जब उपयोगकर्ता इनपुट्स को टेम्पलेट्स में सही ढंग से हैंडल नहीं किया जाता है, जिससे attackers टेम्पलेट्स या अभिव्यक्तियाँ इंजेक्ट और निष्पादित कर सकते हैं।

**कमजोर कोड का उदाहरण:**
```jsx
import React from "react"
import ejs from "ejs"

function RenderTemplate({ template, data }) {
const html = ejs.render(template, data)
return <div dangerouslySetInnerHTML={{ __html: html }} />
}
```
**Why It's Vulnerable:** यदि `template` या `data` में हानिकारक सामग्री शामिल हो तो यह अनचाहे कोड के निष्पादन का कारण बन सकता है।

</details>

<details>

<summary>Client Path Traversal</summary>

यह एक vulnerability है जो attackers को client-side paths को manipulate करके अनपेक्षित कार्रवाइयाँ करने की अनुमति देती है, जैसे Cross-Site Request Forgery (CSRF)। server-side path traversal के विपरीत, जो server के filesystem को लक्षित करता है, CSPT client-side mechanisms का उपयोग कर legitimate API requests को malicious endpoints पर reroute करने पर केंद्रित है।

**कमज़ोर कोड का उदाहरण:** 

एक Next.js application उपयोगकर्ताओं को फ़ाइलें upload और download करने की अनुमति देता है। Download फीचर client side पर लागू किया गया है, जहाँ उपयोगकर्ता डाउनलोड करने के लिए file path निर्दिष्ट कर सकते हैं।
```jsx
// pages/download.js
import { useState } from "react"

export default function DownloadPage() {
const [filePath, setFilePath] = useState("")

const handleDownload = () => {
fetch(`/api/files/${filePath}`)
.then((response) => response.blob())
.then((blob) => {
const url = window.URL.createObjectURL(blob)
const a = document.createElement("a")
a.href = url
a.download = filePath
a.click()
})
}

return (
<div>
<h1>Download File</h1>
<input
type="text"
value={filePath}
onChange={(e) => setFilePath(e.target.value)}
placeholder="Enter file path"
/>
<button onClick={handleDownload}>Download</button>
</div>
)
}
```
#### हमले का परिदृश्य

1. **Attacker's Objective**: CSRF हमला करके महत्वपूर्ण फ़ाइल (उदा., `admin/config.json`) को हटाने के लिए `filePath` को बदलना।
2. **CSPT का शोषण**:
- **Malicious Input**: आक्रमणकारी एक URL तैयार करता है जिसमें बदला हुआ `filePath` होता है जैसे `../deleteFile/config.json`।
- **Resulting API Call**: क्लाइंट-साइड कोड `/api/files/../deleteFile/config.json` पर अनुरोध भेजता है।
- **Server's Handling**: यदि सर्वर `filePath` को मान्य नहीं करता है, तो वह अनुरोध को प्रोसेस करता है, जिससे संवेदनशील फ़ाइलें हट सकती हैं या एक्स्पोज़ हो सकती हैं।
3. **Executing CSRF**:
- **Crafted Link**: आक्रमणकारी पीड़ित को एक लिंक भेजता है या एक हानिकारक स्क्रिप्ट एम्बेड करता है जो बदले हुए `filePath` के साथ डाउनलोड अनुरोध ट्रिगर करता है।
- **Outcome**: पीड़ित अनजाने में यह क्रिया निष्पादित कर देता है, जिसके परिणामस्वरूप अनधिकृत फ़ाइल एक्सेस या हटाना हो सकता है।

#### यह कमजोर क्यों है

- **Lack of Input Validation**: क्लाइंट-साइड किसी भी `filePath` इनपुट की अनुमति देता है, जिससे path traversal संभव होता है।
- **Trusting Client Inputs**: सर्वर-साइड API `filePath` पर भरोसा करता है और बिना sanitization के उसे प्रोसेस करता है।
- **Potential API Actions**: यदि API endpoint state-changing actions (उदा., फ़ाइल हटाना, संशोधित करना) करता है, तो इसे CSPT के माध्यम से शोषण किया जा सकता है।

</details>

## Next.js में Server-Side

### Server-Side Rendering (SSR)

हर अनुरोध पर पेज सर्वर पर रेंडर होते हैं, जिससे उपयोगकर्ता को पूरी तरह रेंडर किया गया HTML मिलता है। इस मामले में आपको अनुरोधों को प्रोसेस करने के लिए अपना कस्टम सर्वर बनाना चाहिए।

**Use Cases:**

- अक्सर बदलने वाला dynamic content।
- SEO अनुकूलन, क्योंकि सर्च इंज़िन पूरी तरह रेंडर किए गए पेज को क्रॉल कर सकते हैं।

**Implementation:**
```jsx
// pages/index.js
export async function getServerSideProps(context) {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data } }
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### स्टैटिक साइट जनरेशन (SSG)

पेज़ बिल्ड समय पर प्री-रेंडर किए जाते हैं, जिससे लोड टाइम तेज़ होते हैं और सर्वर लोड घटता है।

**उपयोग के मामले:**

- ऐसी सामग्री जो अक्सर बदलती नहीं है।
- ब्लॉग, दस्तावेज़, मार्केटिंग पेज।

**कार्यान्वयन:**
```jsx
// pages/index.js
export async function getStaticProps() {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data }, revalidate: 60 } // Revalidate every 60 seconds
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### सर्वरलेस फ़ंक्शन्स (API Routes)

Next.js API endpoints को सर्वरलेस फ़ंक्शन्स के रूप में बनाने की अनुमति देता है। ये फ़ंक्शन्स ऑन‑डिमांड चलते हैं और समर्पित सर्वर की जरूरत नहीं होती।

**उपयोग के मामले:**

- फॉर्म सबमिशन को हैंडल करना।
- डेटाबेस के साथ इंटरैक्ट करना।
- डेटा को प्रोसेस करना या थर्ड‑पार्टी APIs के साथ इंटीग्रेट करना।

**इम्प्लीमेंटेशन:**

Next.js 13 में `app` डायरेक्टरी के परिचय के साथ, routing और API handling अधिक लचीला और शक्तिशाली हो गया है। यह आधुनिक तरीका file-based routing system के साथ निकटता से मेल खाता है पर इसमें enhanced capabilities भी आई हैं, जिनमें server और client components का सपोर्ट शामिल है।

#### बेसिक रूट हैंडलर

**फ़ाइल संरचना:**
```go
my-nextjs-app/
├── app/
│   └── api/
│       └── hello/
│           └── route.js
├── package.json
└── ...
```
**कार्यान्वयन:**
```javascript
// app/api/hello/route.js

export async function POST(request) {
return new Response(JSON.stringify({ message: "Hello from App Router!" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

// Client-side fetch to access the API endpoint
fetch("/api/submit", {
method: "POST",
headers: { "Content-Type": "application/json" },
body: JSON.stringify({ name: "John Doe" }),
})
.then((res) => res.json())
.then((data) => console.log(data))
```
**व्याख्या:**

- **स्थान:** API routes को `app/api/` directory के अंतर्गत रखा जाता है।
- **फ़ाइल नामकरण:** प्रत्येक API endpoint अपनी अलग फ़ोल्डर में रहता है जिसमें एक `route.js` या `route.ts` फ़ाइल होती है।
- **निर्यात किए गए फ़ंक्शन:** single default export के बजाय, विशिष्ट HTTP method फ़ंक्शन (जैसे `GET`, `POST`) निर्यात किए जाते हैं।
- **Response Handling:** रिस्पॉन्स लौटाने के लिए `Response` constructor का उपयोग करें, जिससे headers और status codes पर अधिक नियंत्रण मिलता है।

#### अन्य paths और methods कैसे हैंडल करें:

<details>

<summary>विशिष्ट HTTP मेथड्स को हैंडल करना</summary>

Next.js 13+ आपको उसी `route.js` या `route.ts` फ़ाइल के भीतर विशिष्ट HTTP मेथड्स के लिए handlers परिभाषित करने की अनुमति देता है, जिससे कोड अधिक स्पष्ट और संगठित बनता है।

**उदाहरण:**
```javascript
// app/api/users/[id]/route.js

export async function GET(request, { params }) {
const { id } = params
// Fetch user data based on 'id'
return new Response(JSON.stringify({ userId: id, name: "Jane Doe" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function PUT(request, { params }) {
const { id } = params
// Update user data based on 'id'
return new Response(JSON.stringify({ message: `User ${id} updated.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function DELETE(request, { params }) {
const { id } = params
// Delete user based on 'id'
return new Response(JSON.stringify({ message: `User ${id} deleted.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**व्याख्या:**

- **Multiple Exports:** हर HTTP मेथड (`GET`, `PUT`, `DELETE`) का अपना निर्यातित फ़ंक्शन होता है।
- **Parameters:** दूसरे आर्ग्युमेंट के माध्यम से `params` के जरिए रूट पैरामीटर्स तक पहुँच मिलती है।
- **Enhanced Responses:** response objects पर अधिक नियंत्रण देता है, जिससे headers और status codes को सटीक रूप से नियंत्रित किया जा सकता है।

</details>

<details>

<summary>Catch-All और Nested Routes</summary>

Next.js 13+ catch-all routes और nested API routes जैसे उन्नत राउटिंग फीचर्स का समर्थन करता है, जिससे अधिक dynamic और scalable API संरचनाएँ बनाना संभव होता है।

**Catch-All रूट का उदाहरण:**
```javascript
// app/api/[...slug]/route.js

export async function GET(request, { params }) {
const { slug } = params
// Handle dynamic nested routes
return new Response(JSON.stringify({ slug }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**व्याख्या:**

- **Syntax:** `[...]` एक catch-all सेगमेंट को दर्शाता है, जो सभी नेस्टेड paths को कैप्चर करता है।
- **Usage:** उन APIs के लिए उपयोगी है जिन्हें विभिन्न रूट गहराइयों या डायनेमिक सेगमेंट्स को हैंडल करना होता है।

**नेस्टेड रूट्स उदाहरण:**
```javascript
// app/api/posts/[postId]/comments/[commentId]/route.js

export async function GET(request, { params }) {
const { postId, commentId } = params
// Fetch specific comment for a post
return new Response(
JSON.stringify({ postId, commentId, comment: "Great post!" }),
{
status: 200,
headers: { "Content-Type": "application/json" },
}
)
}
```
**व्याख्या:**

- **Deep Nesting:** हायरार्किकल API संरचनाओं की अनुमति देता है, जो संसाधन संबंधों को दर्शाता है।
- **Parameter Access:** `params` object के माध्यम से कई route parameters को आसानी से एक्सेस करें।

</details>

<details>

<summary>Next.js 12 और उससे पहले में API routes को हैंडल करना</summary>

## `pages` Directory में API Routes (Next.js 12 और उससे पहले)

Next.js 13 ने `app` directory और enhanced routing capabilities पेश करने से पहले, API routes मुख्यतः `pages` directory के भीतर परिभाषित किए जाते थे। यह तरीका अभी भी व्यापक रूप से उपयोग में है और Next.js 12 तथा पहले के संस्करणों में समर्थित है।

#### बुनियादी API Route

**फ़ाइल संरचना:**
```go
goCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── hello.js
├── package.json
└── ...
```
**कार्यान्वयन:**
```javascript
javascriptCopy code// pages/api/hello.js

export default function handler(req, res) {
res.status(200).json({ message: 'Hello, World!' });
}
```
**स्पष्टीकरण:**

- **स्थान:** API routes `pages/api/` डायरेक्टरी के अंदर रहते हैं।
- **निर्यात:** `export default` का उपयोग करके हैंडलर फ़ंक्शन को परिभाषित करें।
- **फ़ंक्शन सिग्नेचर:** हैंडलर को `req` (HTTP request) और `res` (HTTP response) ऑब्जेक्ट्स प्राप्त होते हैं।
- **रूटिंग:** फ़ाइल का नाम (`hello.js`) endpoint `/api/hello` से मैप होता है।

#### डायनेमिक API रूट्स

**फ़ाइल संरचना:**
```bash
bashCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── users/
│           └── [id].js
├── package.json
└── ...
```
**क्रियान्वयन:**
```javascript
javascriptCopy code// pages/api/users/[id].js

export default function handler(req, res) {
const {
query: { id },
method,
} = req;

switch (method) {
case 'GET':
// Fetch user data based on 'id'
res.status(200).json({ userId: id, name: 'John Doe' });
break;
case 'PUT':
// Update user data based on 'id'
res.status(200).json({ message: `User ${id} updated.` });
break;
case 'DELETE':
// Delete user based on 'id'
res.status(200).json({ message: `User ${id} deleted.` });
break;
default:
res.setHeader('Allow', ['GET', 'PUT', 'DELETE']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**व्याख्या:**

- **डायनेमिक सेगमेंट:** Square brackets (`[id].js`) डायनेमिक route segments को दर्शाते हैं।
- **पैरामीटर एक्सेस करना:** डायनेमिक पैरामीटर तक पहुँचने के लिए `req.query.id` का उपयोग करें।
- **मेथड्स को हैंडल करना:** विभिन्न HTTP मेथड्स (`GET`, `PUT`, `DELETE`, आदि) को हैंडल करने के लिए शर्त-आधारित तर्क का उपयोग करें।

#### विभिन्न HTTP मेथड्स को हैंडल करना

जबकि बेसिक API route उदाहरण एक ही फ़ंक्शन के अंदर सभी HTTP मेथड्स को हैंडल करता है, आप बेहतर स्पष्टता और मेंटेनबिलिटी के लिए अपने कोड को प्रत्येक मेथड को स्पष्ट रूप से हैंडल करने के लिए संरचित कर सकते हैं।

**उदाहरण:**
```javascript
javascriptCopy code// pages/api/posts.js

export default async function handler(req, res) {
const { method } = req;

switch (method) {
case 'GET':
// Handle GET request
res.status(200).json({ message: 'Fetching posts.' });
break;
case 'POST':
// Handle POST request
res.status(201).json({ message: 'Post created.' });
break;
default:
res.setHeader('Allow', ['GET', 'POST']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**सर्वोत्तम प्रथाएँ:**

- **Separation of Concerns:** विभिन्न HTTP methods के लिए लॉजिक को स्पष्ट रूप से अलग रखें।
- **Response Consistency:** क्लाइंट-साइड हैंडलिंग को आसान बनाने के लिए सुसंगत response संरचनाएँ सुनिश्चित करें।
- **Error Handling:** असमर्थित methods और अप्रत्याशित त्रुटियों को सहजता से संभालें।

</details>

### CORS कॉन्फ़िगरेशन

नियंत्रण करें कि कौन से origins आपके API routes तक पहुँच सकते हैं, जिससे Cross-Origin Resource Sharing (CORS) कमजोरियों का जोखिम कम होता है।

**खराब कॉन्फ़िगरेशन उदाहरण:**
```javascript
// app/api/data/route.js

export async function GET(request) {
return new Response(JSON.stringify({ data: "Public Data" }), {
status: 200,
headers: {
"Access-Control-Allow-Origin": "*", // Allows any origin
"Access-Control-Allow-Methods": "GET, POST, PUT, DELETE",
},
})
}
```
ध्यान दें कि **CORS को सभी API routes में भी कॉन्फ़िगर किया जा सकता है** **`middleware.ts`** फ़ाइल के अंदर:
```javascript
// app/middleware.ts

import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(request: NextRequest) {
const allowedOrigins = [
"https://yourdomain.com",
"https://sub.yourdomain.com",
]
const origin = request.headers.get("Origin")

const response = NextResponse.next()

if (allowedOrigins.includes(origin || "")) {
response.headers.set("Access-Control-Allow-Origin", origin || "")
response.headers.set(
"Access-Control-Allow-Methods",
"GET, POST, PUT, DELETE, OPTIONS"
)
response.headers.set(
"Access-Control-Allow-Headers",
"Content-Type, Authorization"
)
// If credentials are needed:
// response.headers.set('Access-Control-Allow-Credentials', 'true');
}

// Handle preflight requests
if (request.method === "OPTIONS") {
return new Response(null, {
status: 204,
headers: response.headers,
})
}

return response
}

export const config = {
matcher: "/api/:path*", // Apply to all API routes
}
```
**समस्या:**

- **`Access-Control-Allow-Origin: '*'`:** किसी भी वेबसाइट को API तक पहुंच की अनुमति देता है, जिससे दुर्भावनापूर्ण साइटें बिना प्रतिबंध के आपके API के साथ इंटरैक्ट कर सकती हैं।
- **Wide Method Allowance:** सभी methods की अनुमति देने से attackers अनचाहे क्रियाएँ कर सकते हैं।

**How attackers exploit it:**

Attackers दुर्भावनापूर्ण वेबसाइटें बना सकते हैं जो आपके API को requests भेजती हैं, और संभावित रूप से data retrieval, data manipulation जैसी functionalities का दुरुपयोग कर सकती हैं या authenticated users की ओर से अनचाहे कार्य ट्रिगर कर सकती हैं।

{{#ref}}
../../pentesting-web/cors-bypass.md
{{#endref}}

### Server code exposure in Client Side

यह आसान हो सकता है कि आप server द्वारा उपयोग किया गया code client side में भी expose कर दें; किसी फ़ाइल को कभी client side में expose न होने सुनिश्चित करने का सबसे अच्छा तरीका है कि फ़ाइल की शुरुआत में यह import उपयोग किया जाए:
```js
import "server-only"
```
## प्रमुख फ़ाइलें और उनकी भूमिकाएँ

### `middleware.ts` / `middleware.js`

**स्थान:** परियोजना की रूट या `src/` के भीतर।

**उद्देश्य:** अनुरोध प्रोसेस होने से पहले server-side serverless function में कोड निष्पादित करता है, जिससे authentication, redirects, या responses को संशोधित करने जैसे कार्य संभव होते हैं।

**निष्पादन प्रवाह:**

1. **आने वाला अनुरोध:** middleware अनुरोध को इंटरसेप्ट करता है।
2. **प्रोसेसिंग:** अनुरोध के आधार पर ऑपरेशन्स करता है (उदा., authentication की जाँच)।
3. **रिस्पॉन्स संशोधन:** रिस्पॉन्स को बदल सकता है या अगले हैंडलर को नियंत्रण दे सकता है।

**उदाहरण उपयोग के मामले:**

- अप्रमाणित उपयोगकर्ताओं को redirect करना।
- कस्टम headers जोड़ना।
- अनुरोधों का लॉग रखना।

**नमूना कॉन्फ़िगरेशन:**
```typescript
// middleware.ts
import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(req: NextRequest) {
const url = req.nextUrl.clone()
if (!req.cookies.has("token")) {
url.pathname = "/login"
return NextResponse.redirect(url)
}
return NextResponse.next()
}

export const config = {
matcher: ["/protected/:path*"],
}
```
### `next.config.js`

**स्थान:** Root of the project.

**उद्देश्य:** Next.js के व्यवहार को कॉन्फ़िगर करता है, फीचर्स को सक्षम या अक्षम करने, webpack कॉन्फ़िगरेशन को कस्टमाइज़ करने, environment variables सेट करने, और कई सुरक्षा सुविधाओं को कॉन्फ़िगर करने के लिए।

**मुख्य सुरक्षा कॉन्फ़िगरेशन:**

<details>

<summary>सुरक्षा हेडर्स</summary>

सुरक्षा हेडर ब्राउज़रों को सामग्री को कैसे संभालना है यह निर्देश देकर आपके एप्लिकेशन की सुरक्षा बढ़ाते हैं। वे Cross-Site Scripting (XSS), Clickjacking, और MIME type sniffing जैसे विभिन्न हमलों को कम करने में मदद करते हैं:

- Content Security Policy (CSP)
- X-Frame-Options
- X-Content-Type-Options
- Strict-Transport-Security (HSTS)
- Referrer Policy

**उदाहरण:**
```javascript
// next.config.js

module.exports = {
async headers() {
return [
{
source: "/(.*)", // Apply to all routes
headers: [
{
key: "X-Frame-Options",
value: "DENY",
},
{
key: "Content-Security-Policy",
value:
"default-src *; script-src 'self' 'unsafe-inline' 'unsafe-eval';",
},
{
key: "X-Content-Type-Options",
value: "nosniff",
},
{
key: "Strict-Transport-Security",
value: "max-age=63072000; includeSubDomains; preload", // Enforces HTTPS
},
{
key: "Referrer-Policy",
value: "no-referrer", // Completely hides referrer
},
// Additional headers...
],
},
]
},
}
```
</details>

<details>

<summary>इमेज ऑप्टिमाइज़ेशन सेटिंग्स</summary>

Next.js प्रदर्शन के लिए छवियों को अनुकूलित करता है, लेकिन गलत कॉन्फ़िगरेशन सुरक्षा कमजोरियों का कारण बन सकते हैं, जैसे कि अविश्वसनीय स्रोतों को हानिकारक सामग्री इंजेक्ट करने की अनुमति देना।

**खराब कॉन्फ़िगरेशन उदाहरण:**
```javascript
// next.config.js

module.exports = {
images: {
domains: ["*"], // Allows images from any domain
},
}
```
**समस्या:**

- **`'*'`:** किसी भी बाहरी स्रोत से इमेज लोड होने की अनुमति देता है, जिसमें अनविश्वसनीय या दुर्भावनापूर्ण डोमेन भी शामिल हैं। हमलावर ऐसे इमेज होस्ट कर सकते हैं जिनमें malicious payloads या उपयोगकर्ताओं को भ्रामक सामग्री शामिल हो सकती है।
- एक और समस्या यह हो सकती है कि किसी ऐसे डोमेन को अनुमति दे दी जाए **जहाँ कोई भी इमेज अपलोड कर सकता है** (जैसे `raw.githubusercontent.com`)

**हमलावर इसका दुरुपयोग कैसे करते हैं:**

दुर्भावनापूर्ण स्रोतों से इमेज इंजेक्ट करके, हमलावर फिशिंग हमले कर सकते हैं, भ्रामक जानकारी दिखा सकते हैं, या इमेज रेंडरिंग लाइब्रेरीज़ में मौजूदा कमियों का फायदा उठा सकते हैं।

</details>

<details>

<summary>Environment Variables Exposure</summary>

API keys और database credentials जैसे संवेदनशील जानकारी को क्लाइंट के सामने उजागर किए बिना सुरक्षित रूप से संभालें।

#### a. Exposing Sensitive Variables

**खराब कॉन्फ़िगरेशन उदाहरण:**
```javascript
// next.config.js

module.exports = {
env: {
SECRET_API_KEY: process.env.SECRET_API_KEY, // Exposed to the client
NEXT_PUBLIC_API_URL: process.env.NEXT_PUBLIC_API_URL, // Correctly prefixed for client
},
}
```
**समस्या:**

- **`SECRET_API_KEY`:** `NEXT_PUBLIC_` prefix के बिना, Next.js वेरिएबल्स को client को expose नहीं करता है। हालांकि, अगर गलती से prefix कर दिया जाए (जैसे `NEXT_PUBLIC_SECRET_API_KEY`), तो यह client side पर accessible हो जाता है।

**हमलावर इसका दुरुपयोग कैसे करते हैं:**

यदि संवेदनशील वेरिएबल्स client पर एक्सपोज़ हो जाते हैं, तो हमलावर client-side कोड या नेटवर्क अनुरोधों की जाँच करके उन्हें प्राप्त कर सकते हैं, और APIs, databases, या अन्य सेवाओं तक अनधिकृत पहुँच हासिल कर सकते हैं।

</details>

<details>

<summary>Redirects</summary>

अपने application के भीतर URL redirections और rewrites को मैनेज करें, ताकि users को उचित रूप से निर्देशित किया जाए और साथ ही open redirect vulnerabilities न हों।

#### a. Open Redirect Vulnerability

**खराब कॉन्फ़िगरेशन उदाहरण:**
```javascript
// next.config.js

module.exports = {
async redirects() {
return [
{
source: "/redirect",
destination: (req) => req.query.url, // Dynamically redirects based on query parameter
permanent: false,
},
]
},
}
```
**समस्या:**

- **डायनामिक गंतव्य:** उपयोगकर्ताओं को कोई भी URL निर्दिष्ट करने की अनुमति देता है, जिससे open redirect attacks संभव होते हैं।
- **उपयोगकर्ता इनपुट पर भरोसा करना:** उपयोगकर्ताओं द्वारा प्रदान किए गए URL पर बिना सत्यापन के रीडायरेक्ट करना phishing, malware distribution, या credential theft का कारण बन सकता है।

**हमलावर इसका दुरुपयोग कैसे करते हैं:**

हमलावर ऐसे URLs तैयार कर सकते हैं जो आपके डोमेन से आते हुए दिखते हैं, लेकिन उपयोगकर्ताओं को हानिकारक साइटों पर रीडायरेक्ट कर देते हैं। उदाहरण के लिए:
```bash
https://yourdomain.com/redirect?url=https://malicious-site.com
```
मूल डोमेन पर भरोसा करने वाले उपयोगकर्ता अनजाने में हानिकारक वेबसाइटों पर जा सकते हैं।

</details>

<details>

<summary>Webpack Configuration</summary>

अपने Webpack कॉन्फ़िगरेशन को अपने Next.js एप्लिकेशन के लिए अनुकूलित करें, जो सावधानीपूर्वक न संभाला जाए तो अनजाने में सुरक्षा कमजोरियाँ ला सकता है।

#### a. संवेदनशील मॉड्यूल उजागर करना

**खराब कॉन्फ़िगरेशन उदाहरण:**
```javascript
// next.config.js

module.exports = {
webpack: (config, { isServer }) => {
if (!isServer) {
config.resolve.alias["@sensitive"] = path.join(__dirname, "secret-folder")
}
return config
},
}
```
**समस्या:**

- **Exposing Sensitive Paths:** Aliasing sensitive directories और client-side access की अनुमति देने से गोपनीय जानकारी leak हो सकती है।
- **Bundling Secrets:** यदि संवेदनशील फाइलें क्लाइंट के लिए bundled की जाती हैं, तो उनके contents source maps या client-side code की जाँच करके पहुँच योग्य हो सकते हैं।

**How attackers abuse it:**

Attackers एप्लिकेशन की directory structure तक पहुँच या पुनर्निर्माण कर सकते हैं, जिससे संभावित रूप से संवेदनशील फाइलें या डेटा खोजकर exploit किया जा सकता है।

</details>

### `pages/_app.js` and `pages/_document.js`

#### **`pages/_app.js`**

**Purpose:** डिफ़ॉल्ट App component को ओवरराइड करता है, जिससे global state, styles, और layout components का उपयोग संभव होता है।

**Use Cases:**

- Global CSS को inject करना।
- Layout wrappers जोड़ना।
- State management libraries को integrate करना।

**Example:**
```jsx
// pages/_app.js
import "../styles/globals.css"

function MyApp({ Component, pageProps }) {
return <Component {...pageProps} />
}

export default MyApp
```
#### **`pages/_document.js`**

**उद्देश्य:** डिफ़ॉल्ट Document को ओवरराइड करता है, जिससे <html> और <body> टैग्स को अनुकूलित किया जा सके।

**उपयोग के मामले:**

- `<html>` या `<body>` टैग्स को संशोधित करना।
- meta टैग्स या कस्टम स्क्रिप्ट जोड़ना।
- थर्ड-पार्टी फोंट्स को इंटीग्रेट करना।

**उदाहरण:**
```jsx
// pages/_document.js
import Document, { Html, Head, Main, NextScript } from "next/document"

class MyDocument extends Document {
render() {
return (
<Html lang="en">
<Head>{/* Custom fonts or meta tags */}</Head>
<body>
<Main />
<NextScript />
</body>
</Html>
)
}
}

export default MyDocument
```
### कस्टम सर्वर (वैकल्पिक)

**उद्देश्य:** हालांकि Next.js एक बिल्ट-इन सर्वर के साथ आता है, आप उन्नत उपयोग मामलों के लिए कस्टम सर्वर बना सकते हैं, जैसे कस्टम रूटिंग या मौजूदा बैकएंड सेवाओं के साथ एकीकरण।

**नोट:** कस्टम सर्वर का उपयोग डिप्लॉयमेंट विकल्पों को सीमित कर सकता है, विशेष रूप से Vercel जैसे प्लेटफ़ॉर्मों पर जो Next.js के बिल्ट-इन सर्वर के लिए अनुकूलित हैं।

**उदाहरण:**
```javascript
// server.js
const express = require("express")
const next = require("next")

const dev = process.env.NODE_ENV !== "production"
const app = next({ dev })
const handle = app.getRequestHandler()

app.prepare().then(() => {
const server = express()

// Custom route
server.get("/a", (req, res) => {
return app.render(req, res, "/a")
})

// Default handler
server.all("*", (req, res) => {
return handle(req, res)
})

server.listen(3000, (err) => {
if (err) throw err
console.log("> Ready on http://localhost:3000")
})
})
```
---

## अतिरिक्त वास्तुकला और सुरक्षा विचार

### पर्यावरण वेरिएबल और कॉन्फ़िगरेशन

**Purpose:** कोडबेस के बाहर संवेदनशील जानकारी और कॉन्फ़िगरेशन सेटिंग्स प्रबंधित करना।

**सर्वोत्तम प्रथाएँ:**

- **Use `.env` Files:** API keys जैसे वेरिएबल `.env.local` में स्टोर करें (संस्करण नियंत्रण से बाहर)।
- **Access Variables Securely:** पर्यावरण वेरिएबल्स तक सुरक्षित रूप से पहुँचने के लिए `process.env.VARIABLE_NAME` का उपयोग करें।
- **Never Expose Secrets on the Client:** सुनिश्चित करें कि संवेदनशील वेरिएबल केवल server-side पर ही उपयोग किए जाएँ।

**उदाहरण:**
```javascript
// next.config.js
module.exports = {
env: {
API_KEY: process.env.API_KEY, // Accessible on both client and server
SECRET_KEY: process.env.SECRET_KEY, // Be cautious if accessible on the client
},
}
```
**ध्यान दें:** सर्वर-साइड तक ही variables को सीमित करने के लिए, उन्हें `env` ऑब्जेक्ट से हटा दें या क्लाइंट एक्सपोज़र के लिए `NEXT_PUBLIC_` से प्रीफ़िक्स करें।

### प्रमाणीकरण और प्राधिकरण

**रणनीति:**

- **सेशन-आधारित प्रमाणीकरण:** उपयोगकर्ता सेशनों को प्रबंधित करने के लिए cookies का उपयोग करें।
- **टोकन-आधारित प्रमाणीकरण:** स्टेटलेस प्रमाणीकरण के लिए `JWTs` लागू करें।
- **थर्ड-पार्टी प्रदाताओं:** `next-auth` जैसी लाइब्रेरी का उपयोग करके OAuth प्रदाताओं (उदा., Google, GitHub) के साथ एकीकृत करें।

**सुरक्षा अभ्यास:**

- **सुरक्षित कुकीज़:** `HttpOnly`, `Secure`, और `SameSite` विशेषताएँ सेट करें।
- **पासवर्ड हैशिंग:** संग्रह करने से पहले हमेशा पासवर्ड को हैश करें।
- **इनपुट वैलिडेशन:** इनपुट को वैलिडेट और सैनिटाइज़ करके injection attacks को रोकें।

**उदाहरण:**
```javascript
// pages/api/login.js
import { sign } from "jsonwebtoken"
import { serialize } from "cookie"

export default async function handler(req, res) {
const { username, password } = req.body

// Validate user credentials
if (username === "admin" && password === "password") {
const token = sign({ username }, process.env.JWT_SECRET, {
expiresIn: "1h",
})
res.setHeader(
"Set-Cookie",
serialize("auth", token, {
path: "/",
httpOnly: true,
secure: true,
sameSite: "strict",
})
)
res.status(200).json({ message: "Logged in" })
} else {
res.status(401).json({ error: "Invalid credentials" })
}
}
```
### प्रदर्शन अनुकूलन

**रणनीतियाँ:**

- **छवि अनुकूलन:** Next.js का `next/image` component उपयोग करके स्वचालित छवि अनुकूलन करें।
- **कोड विभाजन:** dynamic imports का उपयोग कर कोड विभाजित करें और प्रारंभिक लोड समय घटाएँ।
- **कैशिंग:** API responses और static assets के लिए कैशिंग रणनीतियाँ लागू करें।
- **लेज़ी लोडिंग:** केवल आवश्यक होने पर ही components या assets लोड करें।

**उदाहरण:**
```jsx
// Dynamic Import with Code Splitting
import dynamic from "next/dynamic"

const HeavyComponent = dynamic(() => import("../components/HeavyComponent"), {
loading: () => <p>Loading...</p>,
})
```
## Next.js Server Actions Enumeration (hash to function name via source maps)

आधुनिक Next.js “Server Actions” का उपयोग करता है जो server पर निष्पादित होते हैं लेकिन client से invoke किए जाते हैं।

प्रोडक्शन में ये invocations अस्पष्ट होते हैं: सभी POSTs एक सामान्य endpoint पर आते हैं और उन्हें `Next-Action` header में भेजे गए build-specific hash द्वारा अलग पहचाना जाता है। उदाहरण:
```http
POST /
Next-Action: a9f8e2b4c7d1...
```
जब `productionBrowserSourceMaps` सक्षम होता है, तो minified JS chunks में `createServerReference(...)` कॉल्स होते हैं जो पर्याप्त संरचना (साथ संबंधित source maps) leak करती हैं ताकि action hash और मूल function नाम के बीच एक mapping पुनर्प्राप्त की जा सके। इससे आप `Next-Action` में देखे गए hashes को ठोस लक्ष्यों जैसे `deleteUserAccount()` या `exportFinancialData()` में मैप कर सकते हैं।

### निकालने का तरीका (regex on minified JS + optional source maps)

डाउनलोड किए गए JS chunks में `createServerReference` खोजें और hash और function/source symbol निकालें। दो उपयोगी पैटर्न:
```regex
# Strict pattern for standard minification
createServerReference\)"([a-f0-9]{40,})",\w+\.callServer,void 0,\w+\.findSourceMapURL,"([^"]+)"\)

# Flexible pattern handling various minification styles
createServerReference[^\"]*"([a-f0-9]{40,})"[^\"]*"([^"]+)"\s*\)
```
- Group 1: सर्वर एक्शन हैश (40+ hex chars)
- Group 2: symbol या path जिसे मौजूद होने पर source map के माध्यम से मूल function में resolve किया जा सकता है

यदि स्क्रिप्ट source map का विज्ञापन करती है (trailer comment `//# sourceMappingURL=<...>.map`), तो इसे फ़ेच करें और symbol/path को मूल function नाम में resolve करें।

### Practical workflow

- Passive discovery while browsing: `Next-Action` headers और JS chunk URLs को capture करें।
- संदर्भित JS bundles और साथ के `*.map` फाइलों को (जब मौजूद हों) fetch करें।
- ऊपर दिया गया regex चलाकर एक hash↔name dictionary बनाएं।
- dictionary का उपयोग करके testing को target करें:
  - Name-driven triage (उदाहरण के लिए `transferFunds`, `exportFinancialData`)।
  - function name के आधार पर builds में coverage को track करें (hashes builds के साथ rotate होते हैं)।

### Exercising hidden actions (template-based request)

एक valid POST जो proxy में देखा गया है उसे template के रूप में लें और किसी खोजे गए दूसरे action को target करने के लिए `Next-Action` value को बदलें:
```http
# Before
Next-Action: a9f8e2b4c7d1

# After
Next-Action: b7e3f9a2d8c5
```
Repeater में replay करें और otherwise unreachable actions की authorization, input validation और business logic को टेस्ट करें।

### Burp automation

- NextjsServerActionAnalyzer (Burp extension) उपरोक्त को Burp में स्वचालित करता है:
- proxy history को JS chunks के लिए scan करता है, `createServerReference(...)` एंट्रीज़ निकालता है, और जहाँ उपलब्ध हों वहां source maps को parse करता है।
- एक searchable hash↔function-name dictionary बनाए रखता है और function name के आधार पर builds के बीच de-duplicate करता है।
- एक valid template POST locate कर सकता है और target action के hash को swap करके एक ready-to-send Repeater tab खोल सकता है।
- Repo: https://github.com/Adversis/NextjsServerActionAnalyzer

### Notes and limitations

- bundles/source maps से नाम recover करने के लिए production में `productionBrowserSourceMaps` सक्षम होने की आवश्यकता है।
- Function-name disclosure स्वयं में एक vulnerability नहीं है; इसका उपयोग discovery के लिए निर्देशित करने और प्रत्येक action की authorization टेस्ट करने के लिए करें।

### React Server Components Flight protocol deserialization RCE (CVE-2025-55182)

जो Next.js App Router deployments Server Actions को `react-server-dom-webpack` **19.0.0–19.2.0 (Next.js 15.x/16.x)** पर expose करते हैं, उनमें **Flight** chunk deserialization के दौरान एक critical server-side prototype pollution होता है। Flight payload के अंदर `$` references बनाकर attacker polluted prototypes से arbitrary JavaScript execution तक और फिर Node.js process के अंदर OS command execution तक pivot कर सकता है।

{{#ref}}
../../pentesting-web/deserialization/nodejs-proto-prototype-pollution/README.md
{{#endref}}

#### Attack chain in Flight chunks

1. **Prototype pollution primitive:** `"then": "$1:__proto__:then"` सेट करें ताकि resolver `Object.prototype` पर एक `then` function लिखे। उसके बाद किसी भी plain object पर प्रोसेस होने पर वह thenable बन जाता है, जिससे attacker RSC internals के भीतर async control flow को प्रभावित कर सकता है।
2. **Rebinding to the global `Function` constructor:** `_response._formData.get` को `"$1:constructor:constructor"` की ओर point करें। resolution के दौरान, `object.constructor` → `Object`, और `Object.constructor` → `Function` होता है, इसलिए भविष्य के `_formData.get()` कॉल वास्तव में `Function(...)` को execute करेंगे।
3. **Code execution via `_prefix`:** JavaScript source को `_response._prefix` में रखें। जब polluted `_formData.get` invoke होता है, framework `Function(_prefix)(...)` evaluate करता है, इसलिए injected JS `require('child_process').exec()` या कोई अन्य Node primitive चला सकता है।

#### Payload skeleton
```json
{
"then": "$1:__proto__:then",
"status": "resolved_model",
"reason": -1,
"value": "{\"then\":\"$B1337\"}",
"_response": {
"_prefix": "require('child_process').exec('id')",
"_chunks": "$Q2",
"_formData": { "get": "$1:constructor:constructor" }
}
}
```
## संदर्भ

- [Pentesting Next.js Server Actions — A Burp Extension for Hash-to-Function Mapping](https://www.adversis.io/blogs/pentesting-next-js-server-actions)
- [NextjsServerActionAnalyzer (Burp extension)](https://github.com/Adversis/NextjsServerActionAnalyzer)
- [CVE-2025-55182 React Server Components Remote Code Execution Exploit Tool](https://github.com/Spritualkb/CVE-2025-55182-exp)

{{#include ../../banners/hacktricks-training.md}}
