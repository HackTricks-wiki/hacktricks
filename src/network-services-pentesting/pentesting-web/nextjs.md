# NextJS

{{#include ../../banners/hacktricks-training.md}}

## Next.js Uygulamasının Genel Mimarisi

### Tipik Dosya Yapısı

Standart bir Next.js projesi, yönlendirme, API uç noktaları ve statik varlık yönetimi gibi özelliklerini kolaylaştıran belirli bir dosya ve dizin yapısını takip eder. İşte tipik bir yapı:
```lua
my-nextjs-app/
├── node_modules/
├── public/
│   ├── images/
│   │   └── logo.png
│   └── favicon.ico
├── app/
│   ├── api/
│   │   └── hello/
│   │       └── route.ts
│   ├── layout.tsx
│   ├── page.tsx
│   ├── about/
│   │   └── page.tsx
│   ├── dashboard/
│   │   ├── layout.tsx
│   │   └── page.tsx
│   ├── components/
│   │   ├── Header.tsx
│   │   └── Footer.tsx
│   ├── styles/
│   │   ├── globals.css
│   │   └── Home.module.css
│   └── utils/
│       └── api.ts
├── .env.local
├── next.config.js
├── tsconfig.json
├── package.json
├── README.md
└── yarn.lock / package-lock.json

```
### Temel Dizinler ve Dosyalar

- **public/:** Görseller, fontlar ve diğer dosyalar gibi statik varlıkları barındırır. Buradaki dosyalara kök yolundan (`/`) erişilebilir.
- **app/:** Uygulamanızın sayfaları, layout'ları, bileşenleri ve API rotaları için merkez dizindir. Gelişmiş yönlendirme özellikleri ve sunucu-istemci bileşen ayrımını sağlayan **App Router** paradigmasını benimser.
- **app/layout.tsx:** Uygulamanız için kök layout'u tanımlar; tüm sayfaları sarar ve başlıklar, altbilgiler ve gezinme çubukları gibi tutarlı UI öğeleri sağlar.
- **app/page.tsx:** Kök rota `/` için giriş noktasıdır ve ana sayfayı render eder.
- **app/[route]/page.tsx:** Statik ve dinamik rotaları yönetir. `app/` içindeki her klasör bir rota segmentini temsil eder ve o klasördeki `page.tsx`, rotanın bileşenine karşılık gelir.
- **app/api/:** API rotalarını içerir; HTTP isteklerini işleyen serverless fonksiyonlar oluşturmanıza olanak tanır. Bu rotalar, geleneksel `pages/api` dizininin yerini alır.
- **app/components/:** Farklı sayfalar ve layout'lar arasında kullanılabilecek yeniden kullanılabilir React bileşenlerini barındırır.
- **app/styles/:** Küresel CSS dosyalarını ve bileşen kapsamlı stil için CSS Modüllerini içerir.
- **app/utils/:** Yardımcı fonksiyonlar, yardımcı modüller ve uygulama genelinde paylaşılabilecek diğer UI dışı mantıkları içerir.
- **.env.local:** Yerel geliştirme ortamına özgü environment değişkenlerini depolar. Bu değişkenler versiyon kontrolüne **kaydedilmez**.
- **next.config.js:** webpack yapılandırmaları, ortam değişkenleri ve güvenlik ayarları dahil olmak üzere Next.js davranışını özelleştirir.
- **tsconfig.json:** Proje için TypeScript ayarlarını yapılandırır; tür denetimi ve diğer TypeScript özelliklerini etkinleştirir.
- **package.json:** Proje bağımlılıklarını, script'leri ve meta veriyi yönetir.
- **README.md:** Kurulum talimatları, kullanım yönergeleri ve diğer ilgili detaylar dahil olmak üzere proje hakkında dokümantasyon ve bilgiler sağlar.
- **yarn.lock / package-lock.json:** Projenin bağımlılıklarını belirli sürümlere kilitler ve farklı ortamlarda tutarlı kurulumları garanti eder.

## Next.js'de İstemci Tarafı

### `app` Dizininde Dosya Tabanlı Yönlendirme

`app` dizini, en güncel Next.js sürümlerinde yönlendirmenin temelidir. Dosya sistemi ile rotaları tanımlar; böylece rota yönetimini sezgisel ve ölçeklenebilir hale getirir.

<details>

<summary>Kök Yol /'u İşleme</summary>

**Dosya Yapısı:**
```arduino
my-nextjs-app/
├── app/
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Önemli Dosyalar:**

- **`app/page.tsx`**: Kök yol `/`'e gelen istekleri işler.
- **`app/layout.tsx`**: Uygulamanın düzenini tanımlar; tüm sayfaları kapsar.

**Uygulama:**
```tsx
tsxCopy code// app/page.tsx

export default function HomePage() {
return (
<div>
<h1>Welcome to the Home Page!</h1>
<p>This is the root route.</p>
</div>
);
}
```
**Açıklama:**

- **Rota Tanımı:** `app` dizini altındaki doğrudan `page.tsx` dosyası `/` rotasına karşılık gelir.
- **Renderleme:** Bu bileşen ana sayfa için içeriği render eder.
- **Layout Entegrasyonu:** `HomePage` bileşeni `layout.tsx` tarafından sarılır; bu, başlıklar, altbilgiler ve diğer ortak öğeleri içerebilir.

</details>

<details>

<summary>Diğer Statik Yolların Ele Alınması</summary>

**Örnek: `/about` Rota**

**Dosya Yapısı:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── about/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Uygulama:**
```tsx
// app/about/page.tsx

export default function AboutPage() {
return (
<div>
<h1>About Us</h1>
<p>Learn more about our mission and values.</p>
</div>
)
}
```
**Açıklama:**

- **Rota Tanımı:** `page.tsx` dosyası `about` klasörü içinde `/about` route'una karşılık gelir.
- **Render Etme:** Bu bileşen about sayfası için içeriği render eder.

</details>

<details>

<summary>Dinamik Rotalar</summary>

Dinamik rotalar, değişken segmentlere sahip yolları işlemenize izin verir; bu sayede uygulamalar ID'ler, slug'lar gibi parametrelere bağlı olarak içerik gösterebilir.

**Örnek: `/posts/[id]` Rota**

**Dosya Yapısı:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── posts/
│   │   └── [id]/
│   │       └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Uygulama:**
```tsx
tsxCopy code// app/posts/[id]/page.tsx

import { useRouter } from 'next/navigation';

interface PostProps {
params: { id: string };
}

export default function PostPage({ params }: PostProps) {
const { id } = params;
// Fetch post data based on 'id'

return (
<div>
<h1>Post #{id}</h1>
<p>This is the content of post {id}.</p>
</div>
);
}
```
**Açıklama:**

- **Dinamik Segment:** `[id]` bir route içindeki dinamik segmenti gösterir ve URL'den `id` parametresini yakalar.
- **Parametrelere Erişim:** `params` nesnesi dinamik parametreleri içerir ve bileşen içinde erişilebilir.
- **Route Eşleştirme:** `/posts/*` ile eşleşen herhangi bir yol, örn. `/posts/1`, `/posts/abc` vb., bu bileşen tarafından işlenecektir.

</details>

<details>

<summary>İç İçe Rotalar</summary>

Next.js, dizin yapısını yansıtan hiyerarşik rota yapıları oluşturulmasına olanak veren iç içe rotaları destekler.

**Örnek: `/dashboard/settings/profile` Rotası**

**Dosya Yapısı:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── dashboard/
│   │   ├── settings/
│   │   │   └── profile/
│   │   │       └── page.tsx
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Uygulama:**
```tsx
tsxCopy code// app/dashboard/settings/profile/page.tsx

export default function ProfileSettingsPage() {
return (
<div>
<h1>Profile Settings</h1>
<p>Manage your profile information here.</p>
</div>
);
}
```
**Açıklama:**

- **Derin İç İçe Geçme:** The `page.tsx` file inside `dashboard/settings/profile/` corresponds to the `/dashboard/settings/profile` route.
- **Hiyerarşinin Yansıtılması:** Dizin yapısı URL yolunu yansıtır, bakım kolaylığı ve açıklık sağlar.

</details>

<details>

<summary>Catch-All Rotaları</summary>

Catch-all rotalar birden fazla iç içe segmenti veya bilinmeyen yolları işler, rota yönetiminde esneklik sağlar.

**Örnek: `/*` Rota**

**Dosya Yapısı:**
```arduino
my-nextjs-app/
├── app/
│   ├── [...slug]/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Uygulama:**
```tsx
// app/[...slug]/page.tsx

interface CatchAllProps {
params: { slug: string[] }
}

export default function CatchAllPage({ params }: CatchAllProps) {
const { slug } = params
const fullPath = `/${slug.join("/")}`

return (
<div>
<h1>Catch-All Route</h1>
<p>You have navigated to: {fullPath}</p>
</div>
)
}
```
**Açıklama:**

- **Catch-All Segment:** `[...slug]` kalan tüm yol segmentlerini bir dizi olarak yakalar.
- **Usage:** Kullanıcı tarafından oluşturulan yollar, iç içe kategoriler gibi dinamik routing senaryolarını yönetmek için kullanışlıdır.
- **Route Matching:** `/anything/here`, `/foo/bar/baz` gibi yollar bu bileşen tarafından işlenir.

</details>

### Potansiyel İstemci Tarafı Zafiyetleri

Next.js güvenli bir temel sağlasa da, hatalı kodlama uygulamaları zafiyetlere yol açabilir. Önemli istemci tarafı zafiyetler şunlardır:

<details>

<summary>Cross-Site Scripting (XSS)</summary>

XSS saldırıları, kötü amaçlı betikler güvenilen web sitelerine enjekte edildiğinde meydana gelir. Saldırganlar, kullanıcıların tarayıcılarında betikler çalıştırarak veri çalabilir veya kullanıcının adına işlemler gerçekleştirebilir.

**Örnek Güvenlik Açığı Olan Kod:**
```jsx
// Dangerous: Injecting user input directly into HTML
function Comment({ userInput }) {
return <div dangerouslySetInnerHTML={{ __html: userInput }} />
}
```
**Neden Güvenli Değil:** Güvenilmeyen girdilerle `dangerouslySetInnerHTML` kullanmak, saldırganların kötü amaçlı script'ler enjekte etmesine izin verir.

</details>

<details>

<summary>Client-Side Template Injection</summary>

Kullanıcı girdilerinin şablonlarda yanlış işlendiği durumlarda meydana gelir; bu, saldırganların şablonlar veya ifadeler enjekte edip çalıştırmasına olanak tanır.

**Zafiyetli Kod Örneği:**
```jsx
import React from "react"
import ejs from "ejs"

function RenderTemplate({ template, data }) {
const html = ejs.render(template, data)
return <div dangerouslySetInnerHTML={{ __html: html }} />
}
```
**Neden Zayıf:** Eğer `template` veya `data` kötü amaçlı içerik içeriyorsa, bu beklenmeyen kodların çalıştırılmasına yol açabilir.

</details>

<details>

<summary>Client Path Traversal</summary>

Bu, saldırganların istemci tarafı yollarını manipüle ederek Cross-Site Request Forgery (CSRF) gibi beklenmeyen işlemler gerçekleştirmesine olanak tanıyan bir zafiyettir. Server-side path traversal'ın sunucunun dosya sistemini hedeflemesinin aksine, CSPT meşru API isteklerini kötü amaçlı endpoints'lere yönlendirmek için istemci tarafı mekanizmalarını istismar etmeye odaklanır.

**Güvenlik Açığı İçeren Kod Örneği:**

Bir Next.js uygulaması kullanıcılara dosya yükleme ve indirme izni veriyor. İndirme özelliği istemci tarafında uygulanmış; kullanıcılar indirilecek dosyanın dosya yolunu belirtebiliyor.
```jsx
// pages/download.js
import { useState } from "react"

export default function DownloadPage() {
const [filePath, setFilePath] = useState("")

const handleDownload = () => {
fetch(`/api/files/${filePath}`)
.then((response) => response.blob())
.then((blob) => {
const url = window.URL.createObjectURL(blob)
const a = document.createElement("a")
a.href = url
a.download = filePath
a.click()
})
}

return (
<div>
<h1>Download File</h1>
<input
type="text"
value={filePath}
onChange={(e) => setFilePath(e.target.value)}
placeholder="Enter file path"
/>
<button onClick={handleDownload}>Download</button>
</div>
)
}
```
#### Saldırı Senaryosu

1. **Saldırganın Amacı**: `filePath`'i manipüle ederek kritik bir dosyayı (ör. `admin/config.json`) silmek için bir CSRF attack gerçekleştirmek.
2. **CSPT'nin Sömürülmesi**:
- **Kötücül Girdi**: Saldırgan, `filePath`'i manipüle ederek `../deleteFile/config.json` gibi bir URL oluşturur.
- **Oluşan API Çağrısı**: The client-side code makes a request to `/api/files/../deleteFile/config.json`.
- **Sunucunun İşleyişi**: Eğer server `filePath`'i doğrulamazsa, isteği işler ve hassas dosyaları silme veya açığa çıkarma potansiyeline sahip olur.
3. **CSRF'nin Gerçekleştirilmesi**:
- **Hazırlanan Link**: Saldırgan, mağdura manipüle edilmiş `filePath` ile indirme isteğini tetikleyen bir link gönderir veya kötü amaçlı bir script gömer.
- **Sonuç**: Mağdur habersizce işlemi gerçekleştirir; yetkisiz dosya erişimi veya silinmesi meydana gelir.

#### Neden Zayıf

- **Girdi Doğrulama Eksikliği**: The client-side allows arbitrary `filePath` inputs, enabling path traversal.
- **Client Girdilerine Güvenme**: The server-side API trusts and processes the `filePath` without sanitization.
- **Olası API İşlemleri**: If the API endpoint performs state-changing actions (e.g., delete, modify files), it can be exploited via CSPT.

</details>

## Next.js'de Sunucu Tarafı

### Server-Side Rendering (SSR)

Sayfalar her istekte sunucuda render edilir, böylece kullanıcı tam renderlanmış HTML alır. Bu durumda istekleri işlemek için kendi özel sunucunuzu oluşturmalısınız.

**Kullanım Örnekleri:**

- Sık sık değişen dinamik içerik.
- SEO optimizasyonu, çünkü arama motorları tam renderlanmış sayfayı tarayabilir.

**Uygulama:**
```jsx
// pages/index.js
export async function getServerSideProps(context) {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data } }
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### Statik Site Oluşturma (SSG)

Sayfalar derleme zamanında önceden oluşturulur; bu, daha hızlı yükleme süreleri ve azalan sunucu yükü sağlar.

**Kullanım Durumları:**

- Sık sık değişmeyen içerik.
- Bloglar, dokümantasyon, pazarlama sayfaları.

**Uygulama:**
```jsx
// pages/index.js
export async function getStaticProps() {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data }, revalidate: 60 } // Revalidate every 60 seconds
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### Sunucusuz Fonksiyonlar (API Routes)

Next.js, API endpoints oluşturmayı sunucusuz fonksiyonlar olarak mümkün kılar. Bu fonksiyonlar, adanmış bir sunucuya ihtiyaç duymadan isteğe bağlı olarak çalışır.

**Kullanım Durumları:**

- Form gönderimlerini işleme.
- Veritabanlarıyla etkileşim.
- Veri işleme veya üçüncü taraf APIs ile entegrasyon.

**Uygulama:**

Next.js 13'te `app` dizininin tanıtılmasıyla, yönlendirme ve API işlemleri daha esnek ve güçlü hale geldi. Bu modern yaklaşım, dosya tabanlı yönlendirme sistemiyle yakından uyumlu olmakla birlikte, sunucu ve istemci bileşenleri için destek dahil gelişmiş yetenekler sunar.

#### Temel Rota İşleyicisi

**Dosya Yapısı:**
```go
my-nextjs-app/
├── app/
│   └── api/
│       └── hello/
│           └── route.js
├── package.json
└── ...
```
**Uygulama:**
```javascript
// app/api/hello/route.js

export async function POST(request) {
return new Response(JSON.stringify({ message: "Hello from App Router!" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

// Client-side fetch to access the API endpoint
fetch("/api/submit", {
method: "POST",
headers: { "Content-Type": "application/json" },
body: JSON.stringify({ name: "John Doe" }),
})
.then((res) => res.json())
.then((data) => console.log(data))
```
**Açıklama:**

- **Konum:** API routes `app/api/` dizini altında yer alır.
- **Dosya Adlandırma:** Her API endpoint'i kendi klasöründe `route.js` veya `route.ts` dosyasını içerir.
- **Dışa Aktarılan Fonksiyonlar:** Tek bir default export yerine belirli HTTP method fonksiyonları (ör. `GET`, `POST`) export edilir.
- **Yanıt İşleme:** Yanıtları döndürmek için `Response` constructor'ını kullanın; bu, header'lar ve durum kodları üzerinde daha fazla kontrol sağlar.

#### Diğer yollar ve yöntemler nasıl ele alınır:

<details>

<summary>Belirli HTTP Yöntemlerini İşleme</summary>

Next.js 13+ aynı `route.js` veya `route.ts` dosyası içinde belirli HTTP yöntemleri için handler'lar tanımlamanıza izin verir; bu, daha net ve düzenli kod yazımını teşvik eder.

**Örnek:**
```javascript
// app/api/users/[id]/route.js

export async function GET(request, { params }) {
const { id } = params
// Fetch user data based on 'id'
return new Response(JSON.stringify({ userId: id, name: "Jane Doe" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function PUT(request, { params }) {
const { id } = params
// Update user data based on 'id'
return new Response(JSON.stringify({ message: `User ${id} updated.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function DELETE(request, { params }) {
const { id } = params
// Delete user based on 'id'
return new Response(JSON.stringify({ message: `User ${id} deleted.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**Açıklama:**

- **Birden Çok Export:** Her HTTP yöntemi (`GET`, `PUT`, `DELETE`) kendi export edilmiş fonksiyona sahiptir.
- **Parametreler:** İkinci argüman, `params` aracılığıyla rota parametrelerine erişim sağlar.
- **Gelişmiş Yanıtlar:** Yanıt nesneleri üzerinde daha fazla kontrol sağlar; başlıklar ve durum kodu yönetimini hassas şekilde yapmaya olanak verir.

</details>

<details>

<summary>Catch-All ve İç İçe Rotalar</summary>

Next.js 13+ catch-all rotalar ve iç içe API rotaları gibi gelişmiş yönlendirme özelliklerini destekler; bu, daha dinamik ve ölçeklenebilir API yapıları oluşturulmasına olanak tanır.

**Catch-All Rota Örneği:**
```javascript
// app/api/[...slug]/route.js

export async function GET(request, { params }) {
const { slug } = params
// Handle dynamic nested routes
return new Response(JSON.stringify({ slug }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**Açıklama:**

- **Sözdizimi:** `[...]` tüm iç içe geçmiş yolları yakalayarak catch-all segmentini belirtir.
- **Kullanım:** Yol derinlikleri veya dinamik segmentleri değişen API'leri işlemek için kullanışlıdır.

**İç İçe Rotalar Örneği:**
```javascript
// app/api/posts/[postId]/comments/[commentId]/route.js

export async function GET(request, { params }) {
const { postId, commentId } = params
// Fetch specific comment for a post
return new Response(
JSON.stringify({ postId, commentId, comment: "Great post!" }),
{
status: 200,
headers: { "Content-Type": "application/json" },
}
)
}
```
**Açıklama:**

- **Derin iç içe yapı:** Kaynak ilişkilerini yansıtan hiyerarşik API yapılarına izin verir.
- **Parametre Erişimi:** `params` nesnesi aracılığıyla birden fazla rota parametresine kolayca erişim sağlar.

</details>

<details>

<summary>Next.js 12 ve Öncesinde API rotalarının Yönetimi</summary>

## `pages` Dizinindeki API Rotaları (Next.js 12 ve Öncesi)

Next.js 13 `app` dizinini ve gelişmiş yönlendirme yeteneklerini tanıtmadan önce, API rotaları çoğunlukla `pages` dizini içinde tanımlanıyordu. Bu yaklaşım hâlâ yaygın olarak kullanılmakta ve Next.js 12 ve öncesi sürümlerde desteklenmektedir.

#### Temel API Rotası

**Dosya Yapısı:**
```go
goCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── hello.js
├── package.json
└── ...
```
**Uygulama:**
```javascript
javascriptCopy code// pages/api/hello.js

export default function handler(req, res) {
res.status(200).json({ message: 'Hello, World!' });
}
```
**Açıklama:**

- **Konum:** API route'ları `pages/api/` dizini altında bulunur.
- **Export:** Handler fonksiyonunu tanımlamak için `export default` kullanın.
- **Fonksiyon İmzası:** Handler `req` (HTTP isteği) ve `res` (HTTP yanıtı) nesnelerini alır.
- **Routing:** Dosya adı (`hello.js`) `/api/hello` endpoint'ine karşılık gelir.

#### Dinamik API Rotaları

**Dosya Yapısı:**
```bash
bashCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── users/
│           └── [id].js
├── package.json
└── ...
```
**Uygulama:**
```javascript
javascriptCopy code// pages/api/users/[id].js

export default function handler(req, res) {
const {
query: { id },
method,
} = req;

switch (method) {
case 'GET':
// Fetch user data based on 'id'
res.status(200).json({ userId: id, name: 'John Doe' });
break;
case 'PUT':
// Update user data based on 'id'
res.status(200).json({ message: `User ${id} updated.` });
break;
case 'DELETE':
// Delete user based on 'id'
res.status(200).json({ message: `User ${id} deleted.` });
break;
default:
res.setHeader('Allow', ['GET', 'PUT', 'DELETE']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**Açıklama:**

- **Dinamik segmentler:** Köşeli parantezler (`[id].js`) dinamik rota segmentlerini belirtir.
- **Parametrelere erişim:** Dinamik parametreye erişmek için `req.query.id` kullanın.
- **Yöntemleri işleme:** Farklı HTTP yöntemlerini (`GET`, `PUT`, `DELETE`, vb.) işlemek için koşullu mantık kullanın.

#### Farklı HTTP Yöntemlerini İşleme

Temel API rota örneği tüm HTTP yöntemlerini tek bir fonksiyon içinde ele alırken, kodunuzu her yöntemi açıkça ayrı ayrı işleyecek şekilde yapılandırabilirsiniz; bu, daha iyi açıklık ve bakım kolaylığı sağlar.

**Örnek:**
```javascript
javascriptCopy code// pages/api/posts.js

export default async function handler(req, res) {
const { method } = req;

switch (method) {
case 'GET':
// Handle GET request
res.status(200).json({ message: 'Fetching posts.' });
break;
case 'POST':
// Handle POST request
res.status(201).json({ message: 'Post created.' });
break;
default:
res.setHeader('Allow', ['GET', 'POST']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**En İyi Uygulamalar:**

- **Sorumlulukların ayrılması:** Farklı HTTP yöntemleri için mantığı net şekilde ayırın.
- **Yanıt Tutarlılığı:** İstemci tarafı işlemenin kolay olması için yanıt yapılarını tutarlı tutun.
- **Hata Yönetimi:** Desteklenmeyen yöntemleri ve beklenmeyen hataları düzgün şekilde ele alın.

</details>

### CORS Yapılandırması

API route'larınıza hangi origins'in erişebileceğini kontrol edin; bu, Cross-Origin Resource Sharing (CORS) zafiyetlerini azaltır.

**Kötü Yapılandırma Örneği:**
```javascript
// app/api/data/route.js

export async function GET(request) {
return new Response(JSON.stringify({ data: "Public Data" }), {
status: 200,
headers: {
"Access-Control-Allow-Origin": "*", // Allows any origin
"Access-Control-Allow-Methods": "GET, POST, PUT, DELETE",
},
})
}
```
Unutmayın ki **CORS tüm API route'larında da yapılandırılabilir** **`middleware.ts`** dosyası içinde:
```javascript
// app/middleware.ts

import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(request: NextRequest) {
const allowedOrigins = [
"https://yourdomain.com",
"https://sub.yourdomain.com",
]
const origin = request.headers.get("Origin")

const response = NextResponse.next()

if (allowedOrigins.includes(origin || "")) {
response.headers.set("Access-Control-Allow-Origin", origin || "")
response.headers.set(
"Access-Control-Allow-Methods",
"GET, POST, PUT, DELETE, OPTIONS"
)
response.headers.set(
"Access-Control-Allow-Headers",
"Content-Type, Authorization"
)
// If credentials are needed:
// response.headers.set('Access-Control-Allow-Credentials', 'true');
}

// Handle preflight requests
if (request.method === "OPTIONS") {
return new Response(null, {
status: 204,
headers: response.headers,
})
}

return response
}

export const config = {
matcher: "/api/:path*", // Apply to all API routes
}
```
**Sorun:**

- **`Access-Control-Allow-Origin: '*'`:** Herhangi bir web sitesinin API'ye erişimine izin verir; bu, kötü niyetli sitelerin API'nizle kısıtlama olmaksızın etkileşimde bulunmasına olanak tanıyabilir.
- **Geniş HTTP yöntem izni:** Tüm HTTP yöntemlerine izin vermek, saldırganların istenmeyen eylemler gerçekleştirmesine olanak sağlayabilir.

**Saldırganların bunu kullanma şekli:**

Saldırganlar API'nize istek yapan kötü amaçlı web siteleri oluşturabilir; bu sayede veri alma, veri değiştirme veya kimlik doğrulaması yapılmış kullanıcılar adına istenmeyen eylemleri tetikleme gibi işlevleri kötüye kullanabilirler.

{{#ref}}
../../pentesting-web/cors-bypass.md
{{#endref}}

### Sunucu kodunun istemci tarafında açığa çıkması

Sunucu tarafından kullanılan kodun istemci tarafında da açığa çıkıp kullanılması kolaydır; bir kod dosyasının asla istemci tarafında açığa çıkmamasını sağlamak için dosyanın başında şu import'u kullanmak en iyi yoldur:
```js
import "server-only"
```
## Önemli Dosyalar ve Rolleri

### `middleware.ts` / `middleware.js`

**Konum:** Projenin kök dizini veya `src/` içinde.

**Amaç:** İstek işlenmeden önce sunucu tarafı serverless fonksiyonunda kod çalıştırır; bu, kimlik doğrulama, yönlendirmeler veya yanıtları değiştirme gibi görevleri yapmayı sağlar.

**Çalışma Akışı:**

1. **Gelen İstek:** Middleware isteği yakalar.
2. **İşleme:** İstek temelinde işlemler yapar (ör. kimlik doğrulamasını kontrol etme).
3. **Yanıt Değişikliği:** Yanıtı değiştirebilir veya kontrolü bir sonraki handler'a devredebilir.

**Örnek Kullanım Durumları:**

- Kimlik doğrulaması yapılmamış kullanıcıları yönlendirme.
- Özel header ekleme.
- İstekleri kaydetme.

**Örnek Yapılandırma:**
```typescript
// middleware.ts
import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(req: NextRequest) {
const url = req.nextUrl.clone()
if (!req.cookies.has("token")) {
url.pathname = "/login"
return NextResponse.redirect(url)
}
return NextResponse.next()
}

export const config = {
matcher: ["/protected/:path*"],
}
```
### `next.config.js`

**Location:** Projenin kökü.

**Purpose:** Next.js davranışını yapılandırır; özellikleri etkinleştirme veya devre dışı bırakma, webpack yapılandırmalarını özelleştirme, ortam değişkenlerini ayarlama ve çeşitli güvenlik özelliklerini yapılandırma.

**Key Security Configurations:**

<details>

<summary>Güvenlik Başlıkları</summary>

Güvenlik başlıkları, tarayıcılara içeriği nasıl işleyeceklerini bildirerek uygulamanızın güvenliğini artırır. Bunlar, Cross-Site Scripting (XSS), Clickjacking ve MIME type sniffing gibi çeşitli saldırıları hafifletmeye yardımcı olur:

- Content Security Policy (CSP)
- X-Frame-Options
- X-Content-Type-Options
- Strict-Transport-Security (HSTS)
- Referrer Policy

**Örnekler:**
```javascript
// next.config.js

module.exports = {
async headers() {
return [
{
source: "/(.*)", // Apply to all routes
headers: [
{
key: "X-Frame-Options",
value: "DENY",
},
{
key: "Content-Security-Policy",
value:
"default-src *; script-src 'self' 'unsafe-inline' 'unsafe-eval';",
},
{
key: "X-Content-Type-Options",
value: "nosniff",
},
{
key: "Strict-Transport-Security",
value: "max-age=63072000; includeSubDomains; preload", // Enforces HTTPS
},
{
key: "Referrer-Policy",
value: "no-referrer", // Completely hides referrer
},
// Additional headers...
],
},
]
},
}
```
</details>

<details>

<summary>Görüntü Optimizasyonu Ayarları</summary>

Next.js görüntüleri performans için optimize eder, ancak yanlış yapılandırmalar güvensiz kaynakların kötü amaçlı içerik enjekte etmesine izin vermek gibi güvenlik açıklarına yol açabilir.

**Kötü Yapılandırma Örneği:**
```javascript
// next.config.js

module.exports = {
images: {
domains: ["*"], // Allows images from any domain
},
}
```
**Problem:**

- **`'*'`:** Herhangi bir dış kaynaktan, güvenilmeyen veya kötü amaçlı alanlar da dahil olmak üzere, görüntülerin yüklenmesine izin verir. Saldırganlar, kötü amaçlı yükler içeren veya kullanıcıları yanıltan içerikler barındıran görüntüler yayınlayabilir.
- Diğer bir sorun, bir alan adının **herkesin görüntü yükleyebileceği** şekilde izin verilmesi olabilir (gibi `raw.githubusercontent.com`)

**How attackers abuse it:**

Kötü amaçlı kaynaklardan görüntüler enjekte ederek, saldırganlar phishing saldırıları düzenleyebilir, yanıltıcı bilgi gösterebilir veya görüntü işleme kütüphanelerindeki güvenlik açıklarını istismar edebilir.

</details>

<details>

<summary>Ortam Değişkenlerinin Açığa Çıkması</summary>

Manage sensitive information like API keys and database credentials securely without exposing them to the client.

#### a. Hassas Değişkenlerin Açığa Çıkması

**Kötü Yapılandırma Örneği:**
```javascript
// next.config.js

module.exports = {
env: {
SECRET_API_KEY: process.env.SECRET_API_KEY, // Exposed to the client
NEXT_PUBLIC_API_URL: process.env.NEXT_PUBLIC_API_URL, // Correctly prefixed for client
},
}
```
**Sorun:**

- **`SECRET_API_KEY`:** `NEXT_PUBLIC_` öneki olmadan, Next.js değişkenleri istemciye açmaz. Ancak yanlışlıkla öneklendiğinde (ör. `NEXT_PUBLIC_SECRET_API_KEY`), istemci tarafında erişilebilir hale gelir.

**Saldırganlar bunu nasıl kötüye kullanır:**

Eğer hassas değişkenler istemciye açılırsa, saldırganlar bunları istemci tarafı kodunu veya ağ isteklerini inceleyerek elde edebilir ve API'lere, veritabanlarına veya diğer servislere yetkisiz erişim sağlayabilir.

</details>

<details>

<summary>Yönlendirmeler</summary>

Uygulamanız içinde URL yönlendirmelerini ve yeniden yazımları yönetin; kullanıcıların uygun şekilde yönlendirildiğinden ve open redirect vulnerabilities oluşmadığından emin olun.

#### a. Open Redirect Vulnerability

**Kötü Yapılandırma Örneği:**
```javascript
// next.config.js

module.exports = {
async redirects() {
return [
{
source: "/redirect",
destination: (req) => req.query.url, // Dynamically redirects based on query parameter
permanent: false,
},
]
},
}
```
**Sorun:**

- **Dynamic Destination:** Kullanıcıların herhangi bir URL belirtmesine izin verir, bu da open redirect saldırılarına olanak tanır.
- **Trusting User Input:** Kullanıcıların sağladığı URL'lere doğrulama olmadan yapılan yönlendirmeler phishing, malware distribution veya credential theft ile sonuçlanabilir.

**Saldırganlar bunu nasıl kötüye kullanır:**

Saldırganlar, alan adınızdan kaynaklanıyormuş gibi görünen ancak kullanıcıları kötü amaçlı sitelere yönlendiren URL'ler oluşturabilir. Örneğin:
```bash
https://yourdomain.com/redirect?url=https://malicious-site.com
```
Orijinal domaine güvenen kullanıcılar farkında olmadan zararlı web sitelerine yönlendirilebilir.

</details>

<details>

<summary>Webpack Configuration</summary>

Next.js uygulamanız için Webpack yapılandırmalarını özelleştirmek, dikkatli ele alınmadığında istemeden güvenlik açıklarına yol açabilir.

#### a. Hassas Modüllerin Açığa Çıkması

**Kötü Yapılandırma Örneği:**
```javascript
// next.config.js

module.exports = {
webpack: (config, { isServer }) => {
if (!isServer) {
config.resolve.alias["@sensitive"] = path.join(__dirname, "secret-folder")
}
return config
},
}
```
**Sorun:**

- **Exposing Sensitive Paths:** Hassas dizinlerin alias'lanması ve istemci tarafı erişime izin verilmesi gizli bilgilerin leak olmasına yol açabilir.
- **Bundling Secrets:** Hassas dosyalar client için bundle edilirse, içerikleri source maps aracılığıyla veya istemci tarafı kodunun incelenmesiyle erişilebilir hale gelir.

**Saldırganlar bunu nasıl kötüye kullanır:**

Saldırganlar uygulamanın dizin yapısına erişebilir veya bunu yeniden oluşturabilir; bu da potansiyel olarak hassas dosyalar veya veriler bulmalarına ve bunları istismar etmelerine neden olabilir.

</details>

### `pages/_app.js` and `pages/_document.js`

#### **`pages/_app.js`**

**Purpose:** Varsayılan App bileşeninin davranışını özelleştirir; global state, stiller ve layout bileşenlerine izin verir.

**Use Cases:**

- Global CSS ekleme.
- Layout wrapper'ları ekleme.
- Durum yönetimi kütüphanelerinin entegrasyonu.

**Example:**
```jsx
// pages/_app.js
import "../styles/globals.css"

function MyApp({ Component, pageProps }) {
return <Component {...pageProps} />
}

export default MyApp
```
#### **`pages/_document.js`**

**Purpose:** Varsayılan Document'i geçersiz kılar, HTML ve Body etiketlerinin özelleştirilmesine olanak sağlar.

**Use Cases:**

- `<html>` veya `<body>` etiketlerini değiştirme.
- Meta etiketleri veya özel script'ler ekleme.
- Üçüncü taraf fontları entegre etme.

**Example:**
```jsx
// pages/_document.js
import Document, { Html, Head, Main, NextScript } from "next/document"

class MyDocument extends Document {
render() {
return (
<Html lang="en">
<Head>{/* Custom fonts or meta tags */}</Head>
<body>
<Main />
<NextScript />
</body>
</Html>
)
}
}

export default MyDocument
```
### Özel Sunucu (İsteğe Bağlı)

**Amaç:** Next.js yerleşik bir sunucu ile gelirken, özel yönlendirme veya mevcut backend hizmetleriyle entegrasyon gibi gelişmiş kullanım durumları için özel bir sunucu oluşturabilirsiniz.

**Not:** Özel bir sunucu kullanmak dağıtım seçeneklerini sınırlayabilir, özellikle Next.js'in yerleşik sunucusu için optimize eden Vercel gibi platformlarda.

**Örnek:**
```javascript
// server.js
const express = require("express")
const next = require("next")

const dev = process.env.NODE_ENV !== "production"
const app = next({ dev })
const handle = app.getRequestHandler()

app.prepare().then(() => {
const server = express()

// Custom route
server.get("/a", (req, res) => {
return app.render(req, res, "/a")
})

// Default handler
server.all("*", (req, res) => {
return handle(req, res)
})

server.listen(3000, (err) => {
if (err) throw err
console.log("> Ready on http://localhost:3000")
})
})
```
---

## Ek Mimari ve Güvenlik Hususları

### Ortam Değişkenleri ve Yapılandırma

**Amaç:** Hassas bilgileri ve yapılandırma ayarlarını kod tabanının dışında yönetmek.

**En İyi Uygulamalar:**

- **Use `.env` Files:** API anahtarları gibi değişkenleri `.env.local` içinde saklayın (sürüm kontrolünden hariç tutulur).
- **Access Variables Securely:** Ortam değişkenlerine erişmek için `process.env.VARIABLE_NAME` kullanın.
- **Never Expose Secrets on the Client:** Hassas değişkenlerin yalnızca sunucu tarafında kullanıldığından emin olun.

**Example:**
```javascript
// next.config.js
module.exports = {
env: {
API_KEY: process.env.API_KEY, // Accessible on both client and server
SECRET_KEY: process.env.SECRET_KEY, // Be cautious if accessible on the client
},
}
```
**Not:** Değişkenleri yalnızca sunucu tarafında tutmak için, onları `env` nesnesinden çıkarın veya istemciye açmak için `NEXT_PUBLIC_` ile önekleyin.

### Kimlik Doğrulama ve Yetkilendirme

**Yaklaşım:**

- **Oturum Tabanlı Kimlik Doğrulama:** Kullanıcı oturumlarını yönetmek için cookies kullanın.
- **Token Tabanlı Kimlik Doğrulama:** Durumsuz kimlik doğrulama için JWTs uygulayın.
- **Üçüncü Taraf Sağlayıcılar:** OAuth sağlayıcıları (örn., Google, GitHub) ile `next-auth` gibi kütüphaneler kullanarak entegre edin.

**Güvenlik Uygulamaları:**

- **Güvenli Cookies:** `HttpOnly`, `Secure` ve `SameSite` özniteliklerini ayarlayın.
- **Parola Hashleme:** Parolaları depolamadan önce her zaman hashleyin.
- **Girdi Doğrulama:** Girdileri doğrulayarak ve temizleyerek injection saldırılarını önleyin.

**Örnek:**
```javascript
// pages/api/login.js
import { sign } from "jsonwebtoken"
import { serialize } from "cookie"

export default async function handler(req, res) {
const { username, password } = req.body

// Validate user credentials
if (username === "admin" && password === "password") {
const token = sign({ username }, process.env.JWT_SECRET, {
expiresIn: "1h",
})
res.setHeader(
"Set-Cookie",
serialize("auth", token, {
path: "/",
httpOnly: true,
secure: true,
sameSite: "strict",
})
)
res.status(200).json({ message: "Logged in" })
} else {
res.status(401).json({ error: "Invalid credentials" })
}
}
```
### Performans Optimizasyonu

**Stratejiler:**

- **Görüntü Optimizasyonu:** Otomatik görüntü optimizasyonu için Next.js'in `next/image` bileşenini kullanın.
- **Kod Bölme:** Dinamik import'ları kullanarak kodu bölün ve ilk yükleme sürelerini azaltın.
- **Önbellekleme:** API yanıtları ve statik varlıklar için önbellekleme stratejileri uygulayın.
- **Tembel Yükleme:** Bileşenleri veya varlıkları yalnızca gerektiğinde yükleyin.

**Örnek:**
```jsx
// Dynamic Import with Code Splitting
import dynamic from "next/dynamic"

const HeavyComponent = dynamic(() => import("../components/HeavyComponent"), {
loading: () => <p>Loading...</p>,
})
```
## Next.js Server Actions Enumerasyonu (hash'ten function adına source maps aracılığıyla)

Modern Next.js, sunucuda çalışan ancak istemciden çağrılan “Server Actions” kullanır. Prodüksiyonda bu çağrılar opaktır: tüm POST'lar ortak bir endpoint'e düşer ve `Next-Action` header'ında gönderilen build'e özgü bir hash ile ayırt edilir. Örnek:
```http
POST /
Next-Action: a9f8e2b4c7d1...
```
`productionBrowserSourceMaps` etkinleştirildiğinde, minified JS parçaları `createServerReference(...)` çağrıları içerir; bu çağrılar action hash ile orijinal fonksiyon adı arasındaki eşlemeyi geri kazanmak için yeterli yapı leak (ve ilişkili source maps) sağlar. Bu, `Next-Action` içinde gözlemlenen hash'leri `deleteUserAccount()` veya `exportFinancialData()` gibi somut hedeflere çevirmenize olanak verir.

### Çıkarım yaklaşımı (regex on minified JS + optional source maps)

İndirilen JS parçalarında `createServerReference` arayın ve hash ile fonksiyon/source sembolünü çıkarın. İki faydalı desen:
```regex
# Strict pattern for standard minification
createServerReference\)"([a-f0-9]{40,})",\w+\.callServer,void 0,\w+\.findSourceMapURL,"([^"]+)"\)

# Flexible pattern handling various minification styles
createServerReference[^\"]*"([a-f0-9]{40,})"[^\"]*"([^"]+)"\s*\)
```
- Grup 1: server action hash (40+ hex karakter)
- Grup 2: kaynak haritası mevcut olduğunda orijinal fonksiyona çözülebilen sembol veya yol

Eğer script bir source map ilan ediyorsa (trailer comment `//# sourceMappingURL=<...>.map`), onu al ve sembol/yolu orijinal fonksiyon adına çevir.

### Pratik iş akışı

- Tarama esnasında pasif keşif: `Next-Action` header'lı istekleri ve JS chunk URL'lerini yakala.
- Referans verilen JS bundle'larını ve eşlik eden `*.map` dosyalarını çek (varsa).
- Yukarıdaki regex'i çalıştırarak bir hash↔name sözlüğü oluştur.
- Test hedeflemesi için sözlüğü kullan:
- İsim odaklı triage (ör. `transferFunds`, `exportFinancialData`).
- Fonksiyon adına göre derlemeler arası kapsama takibi (hash'ler derlemeler arasında döner).

### Gizli action'ları çalıştırma (şablon tabanlı istek)

Proxy'de gözlemlenen geçerli bir POST'u şablon olarak al ve hedef olarak başka bir keşfedilmiş action'ı hedeflemek için `Next-Action` değerini değiştir:
```http
# Before
Next-Action: a9f8e2b4c7d1

# After
Next-Action: b7e3f9a2d8c5
```
Repeater'da yeniden oynatın ve aksi halde ulaşılamayan eylemlerin yetkilendirmesini, girdi doğrulamasını ve iş mantığını test edin.

### Burp automation

- NextjsServerActionAnalyzer (Burp uzantısı) yukarıdakileri Burp içinde otomatikleştirir:
- Proxy geçmişini JS chunkları için tarar, `createServerReference(...)` girdilerini çıkarır ve mevcutsa source map'leri çözer.
- Aranabilir bir hash↔function-name sözlüğü tutar ve fonksiyon adına göre build'ler arasında duplikasyonu önler.
- Geçerli bir template POST'u bulup hedef eylemin hash'i yerleştirilmiş, gönderilmeye hazır bir Repeater sekmesi açabilir.
- Repo: https://github.com/Adversis/NextjsServerActionAnalyzer

### Notes and limitations

- İsimleri bundle'lar/source map'lerden geri kazanmak için üretimde `productionBrowserSourceMaps`'ın etkin olması gerekir.
- Fonksiyon adı ifşası tek başına bir zafiyet değildir; keşfi yönlendirmek ve her eylemin yetkilendirmesini test etmek için kullanın.

### React Server Components Flight protocol deserialization RCE (CVE-2025-55182)

Next.js App Router dağıtımları, `react-server-dom-webpack` **19.0.0–19.2.0 (Next.js 15.x/16.x)** üzerinde Server Actions'ı açığa çıkardığında, **Flight** chunk'larının deserialization sırasında kritik bir server-side prototype pollution içerir. Bir Flight payload'u içine `$` referansları yerleştirerek saldırgan, kirlenmiş prototiplerden keyfi JavaScript yürütmeye ve ardından Node.js sürecinde OS komut yürütmeye geçiş yapabilir.

{{#ref}}
../../pentesting-web/deserialization/nodejs-proto-prototype-pollution/README.md
{{#endref}}

#### Attack chain in Flight chunks

1. **Prototype pollution primitive:** Resolver'ın `Object.prototype` üzerinde bir `then` fonksiyonu yazması için `"then": "$1:__proto__:then"` ayarlayın. İşlemden sonra işlenen herhangi bir düz nesne thenable olur; bu da saldırganın RSC iç mantığındaki async kontrol akışını etkilemesine izin verir.
2. **Rebinding to the global `Function` constructor:** `_response._formData.get`'i `"$1:constructor:constructor"`'a yönlendirin. Çözümleme sırasında `object.constructor` → `Object`, ve `Object.constructor` → `Function` olur; böylece sonraki `_formData.get()` çağrıları aslında `Function(...)`'ı çalıştırır.
3. **Code execution via `_prefix`:** JavaScript kaynağını `_response._prefix` içine yerleştirin. Kirlenmiş `_formData.get` çağrıldığında framework `Function(_prefix)(...)`'ı değerlendirir, dolayısıyla enjekte edilen JS `require('child_process').exec()` veya başka herhangi bir Node primitive'ini çalıştırabilir.

#### Payload skeleton
```json
{
"then": "$1:__proto__:then",
"status": "resolved_model",
"reason": -1,
"value": "{\"then\":\"$B1337\"}",
"_response": {
"_prefix": "require('child_process').exec('id')",
"_chunks": "$Q2",
"_formData": { "get": "$1:constructor:constructor" }
}
}
```
## Referanslar

- [Pentesting Next.js Server Actions — A Burp Extension for Hash-to-Function Mapping](https://www.adversis.io/blogs/pentesting-next-js-server-actions)
- [NextjsServerActionAnalyzer (Burp extension)](https://github.com/Adversis/NextjsServerActionAnalyzer)
- [CVE-2025-55182 React Server Components Remote Code Execution Exploit Tool](https://github.com/Spritualkb/CVE-2025-55182-exp)

{{#include ../../banners/hacktricks-training.md}}
