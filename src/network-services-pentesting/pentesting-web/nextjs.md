# NextJS

{{#include ../../banners/hacktricks-training.md}}

## Architecture générale d'une application Next.js

### Structure de fichiers typique

Un projet Next.js standard suit une structure de fichiers et de répertoires spécifique qui facilite ses fonctionnalités comme routing, API endpoints et static asset management. Voici une organisation typique :
```lua
my-nextjs-app/
├── node_modules/
├── public/
│   ├── images/
│   │   └── logo.png
│   └── favicon.ico
├── app/
│   ├── api/
│   │   └── hello/
│   │       └── route.ts
│   ├── layout.tsx
│   ├── page.tsx
│   ├── about/
│   │   └── page.tsx
│   ├── dashboard/
│   │   ├── layout.tsx
│   │   └── page.tsx
│   ├── components/
│   │   ├── Header.tsx
│   │   └── Footer.tsx
│   ├── styles/
│   │   ├── globals.css
│   │   └── Home.module.css
│   └── utils/
│       └── api.ts
├── .env.local
├── next.config.js
├── tsconfig.json
├── package.json
├── README.md
└── yarn.lock / package-lock.json

```
### Répertoires et fichiers principaux

- **public/:** Contient des assets statiques tels que images, polices et autres fichiers. Les fichiers ici sont accessibles à la racine (`/`).
- **app/:** Répertoire central pour les pages, layouts, composants et routes API de votre application. Adopte le paradigme **App Router**, permettant des fonctionnalités de routage avancées et la séparation des composants côté serveur et côté client.
- **app/layout.tsx:** Définit le layout racine de votre application, englobant toutes les pages et fournissant des éléments d'UI cohérents comme headers, footers et barres de navigation.
- **app/page.tsx:** Sert d'entrée pour la route racine `/`, rendant la page d'accueil.
- **app/[route]/page.tsx:** Gère les routes statiques et dynamiques. Chaque dossier dans `app/` représente un segment de route, et le `page.tsx` à l'intérieur de ces dossiers correspond au composant de la route.
- **app/api/:** Contient des routes API, vous permettant de créer des fonctions serverless qui traitent les requêtes HTTP. Ces routes remplacent le traditionnel répertoire `pages/api`.
- **app/components/:** Héberge des composants React réutilisables qui peuvent être utilisés à travers différentes pages et layouts.
- **app/styles/:** Contient des fichiers CSS globaux et des CSS Modules pour du styling scoped aux composants.
- **app/utils/:** Inclut des fonctions utilitaires, modules helper et autre logique non-UI partageable à travers l'application.
- **.env.local:** Stocke les variables d'environnement spécifiques au développement local. Ces variables ne sont **pas** committées dans le contrôle de version.
- **next.config.js:** Personnalise le comportement de Next.js, incluant les configurations webpack, les variables d'environnement et les réglages de sécurité.
- **tsconfig.json:** Configure les options TypeScript pour le projet, activant la vérification de types et autres fonctionnalités TypeScript.
- **package.json:** Gère les dépendances du projet, les scripts et les métadonnées.
- **README.md:** Fournit la documentation et les informations sur le projet, incluant les instructions d'installation, les consignes d'utilisation et autres détails pertinents.
- **yarn.lock / package-lock.json:** Verrouillent les dépendances du projet à des versions spécifiques, assurant des installations cohérentes entre différents environnements.

## Côté client dans Next.js

### Routage basé sur les fichiers dans le répertoire `app`

Le répertoire `app` est la pierre angulaire du routage dans les dernières versions de Next.js. Il utilise le système de fichiers pour définir les routes, rendant la gestion des routes intuitive et évolutive.

<details>

<summary>Gestion du chemin racine /</summary>

**Structure des fichiers :**
```arduino
my-nextjs-app/
├── app/
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Fichiers clés :**

- **`app/page.tsx`**: Gère les requêtes vers le chemin racine `/`.
- **`app/layout.tsx`**: Définit la mise en page de l'application, englobant toutes les pages.

**Implémentation :**
```tsx
tsxCopy code// app/page.tsx

export default function HomePage() {
return (
<div>
<h1>Welcome to the Home Page!</h1>
<p>This is the root route.</p>
</div>
);
}
```
**Explication :**

- **Définition de la route :** Le fichier `page.tsx` situé directement sous le répertoire `app` correspond à la route `/`.
- **Rendu :** Ce composant affiche le contenu de la page d'accueil.
- **Intégration de la mise en page :** Le composant `HomePage` est enveloppé par `layout.tsx`, qui peut inclure des en-têtes, des pieds de page et d'autres éléments communs.

</details>

<details>

<summary>Gestion des autres chemins statiques</summary>

**Exemple : route `/about`**

**Structure des fichiers :**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── about/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implémentation:**
```tsx
// app/about/page.tsx

export default function AboutPage() {
return (
<div>
<h1>About Us</h1>
<p>Learn more about our mission and values.</p>
</div>
)
}
```
**Explication :**

- **Définition de la route :** Le fichier `page.tsx` à l'intérieur du dossier `about` correspond à la route `/about`.
- **Rendu :** Ce composant affiche le contenu de la page about.

</details>

<details>

<summary>Routes dynamiques</summary>

Les routes dynamiques permettent de gérer des chemins avec des segments variables, permettant aux applications d'afficher du contenu en fonction de paramètres comme des IDs, des slugs, etc.

**Exemple : route `/posts/[id]`**

**Structure des fichiers :**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── posts/
│   │   └── [id]/
│   │       └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implémentation:**
```tsx
tsxCopy code// app/posts/[id]/page.tsx

import { useRouter } from 'next/navigation';

interface PostProps {
params: { id: string };
}

export default function PostPage({ params }: PostProps) {
const { id } = params;
// Fetch post data based on 'id'

return (
<div>
<h1>Post #{id}</h1>
<p>This is the content of post {id}.</p>
</div>
);
}
```
**Explication:**

- **Segment dynamique:** `[id]` désigne un segment dynamique dans la route, capturant le paramètre `id` depuis l'URL.
- **Accès aux paramètres:** L'objet `params` contient les paramètres dynamiques, accessibles au sein du composant.
- **Correspondance de route:** Tout chemin correspondant à `/posts/*`, tel que `/posts/1`, `/posts/abc`, etc., sera géré par ce composant.

</details>

<details>

<summary>Routes imbriquées</summary>

Next.js prend en charge le routage imbriqué, permettant des structures de routes hiérarchiques qui reflètent l'organisation des répertoires.

**Exemple : route `/dashboard/settings/profile`**

**Structure des fichiers :**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── dashboard/
│   │   ├── settings/
│   │   │   └── profile/
│   │   │       └── page.tsx
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implémentation:**
```tsx
tsxCopy code// app/dashboard/settings/profile/page.tsx

export default function ProfileSettingsPage() {
return (
<div>
<h1>Profile Settings</h1>
<p>Manage your profile information here.</p>
</div>
);
}
```
**Explication:**

- **Imbrication profonde:** Le fichier `page.tsx` à l'intérieur de `dashboard/settings/profile/` correspond à la route `/dashboard/settings/profile`.
- **Réflexion de la hiérarchie:** La structure des répertoires reflète le chemin URL, améliorant la maintenabilité et la clarté.

</details>

<details>

<summary>Routes catch-all</summary>

Les routes catch-all gèrent plusieurs segments imbriqués ou des chemins inconnus, offrant de la flexibilité dans la gestion des routes.

**Exemple: `/*` Route**

**Structure des fichiers:**
```arduino
my-nextjs-app/
├── app/
│   ├── [..slug]/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implémentation :**
```tsx
// app/[...slug]/page.tsx

interface CatchAllProps {
params: { slug: string[] }
}

export default function CatchAllPage({ params }: CatchAllProps) {
const { slug } = params
const fullPath = `/${slug.join("/")}`

return (
<div>
<h1>Catch-All Route</h1>
<p>You have navigated to: {fullPath}</p>
</div>
)
}
```
**Explication :**

- **Segment catch-all :** `[...slug]` capture tous les segments de chemin restants sous forme de tableau.
- **Utilisation :** Utile pour gérer des scénarios de routage dynamique comme les chemins générés par les utilisateurs, les catégories imbriquées, etc.
- **Correspondance de route :** Des chemins comme `/anything/here`, `/foo/bar/baz`, etc., sont traités par ce composant.

</details>

### Vulnérabilités potentielles côté client

Bien que Next.js fournisse une base sécurisée, des pratiques de codage inappropriées peuvent introduire des vulnérabilités. Les principales vulnérabilités côté client incluent :

<details>

<summary>Cross-Site Scripting (XSS)</summary>

Les attaques XSS surviennent lorsque des scripts malveillants sont injectés dans des sites de confiance. Les attaquants peuvent exécuter des scripts dans le navigateur des utilisateurs, voler des données ou effectuer des actions au nom de l'utilisateur.

**Exemple de code vulnérable :**
```jsx
// Dangerous: Injecting user input directly into HTML
function Comment({ userInput }) {
return <div dangerouslySetInnerHTML={{ __html: userInput }} />
}
```
**Pourquoi c'est vulnérable :** L'utilisation de `dangerouslySetInnerHTML` avec des données non fiables permet aux attaquants d'injecter des scripts malveillants.

</details>

<details>

<summary>Client-Side Template Injection</summary>

Se produit lorsque les entrées utilisateur sont mal traitées dans les templates, permettant aux attaquants d'injecter et d'exécuter des templates ou des expressions.

**Exemple de code vulnérable :**
```jsx
import React from "react"
import ejs from "ejs"

function RenderTemplate({ template, data }) {
const html = ejs.render(template, data)
return <div dangerouslySetInnerHTML={{ __html: html }} />
}
```
**Pourquoi c'est vulnérable :** Si `template` ou `data` contient du contenu malveillant, cela peut entraîner l'exécution de code non prévu.

</details>

<details>

<summary>Client Path Traversal</summary>

C'est une vulnérabilité qui permet aux attaquants de manipuler les chemins côté client pour effectuer des actions non prévues, telles que Cross-Site Request Forgery (CSRF). Contrairement au server-side path traversal, qui vise le système de fichiers du serveur, CSPT se concentre sur l'exploitation des mécanismes côté client pour rediriger des requêtes API légitimes vers des endpoints malveillants.

**Exemple de code vulnérable :**

Une application Next.js permet aux utilisateurs de téléverser et de télécharger des fichiers. La fonctionnalité de téléchargement est implémentée côté client, où les utilisateurs peuvent spécifier le chemin du fichier à télécharger.
```jsx
// pages/download.js
import { useState } from "react"

export default function DownloadPage() {
const [filePath, setFilePath] = useState("")

const handleDownload = () => {
fetch(`/api/files/${filePath}`)
.then((response) => response.blob())
.then((blob) => {
const url = window.URL.createObjectURL(blob)
const a = document.createElement("a")
a.href = url
a.download = filePath
a.click()
})
}

return (
<div>
<h1>Download File</h1>
<input
type="text"
value={filePath}
onChange={(e) => setFilePath(e.target.value)}
placeholder="Enter file path"
/>
<button onClick={handleDownload}>Download</button>
</div>
)
}
```
#### Scénario d'attaque

1. **Attacker's Objective**: Effectuer une attaque CSRF pour supprimer un fichier critique (par ex., `admin/config.json`) en manipulant le `filePath`.
2. **Exploiting CSPT**:
- **Malicious Input**: L'attaquant crée une URL avec un `filePath` manipulé tel que `../deleteFile/config.json`.
- **Resulting API Call**: Le code côté client effectue une requête vers `/api/files/../deleteFile/config.json`.
- **Server's Handling**: Si le serveur ne valide pas le `filePath`, il traite la requête, supprimant potentiellement ou exposant des fichiers sensibles.
3. **Executing CSRF**:
- **Crafted Link**: L'attaquant envoie à la victime un lien ou intègre un script malveillant qui déclenche la requête de téléchargement avec le `filePath` manipulé.
- **Outcome**: La victime exécute involontairement l'action, entraînant un accès ou une suppression non autorisés de fichiers.

#### Why It's Vulnerable

- **Lack of Input Validation**: Le côté client permet des entrées arbitraires pour `filePath`, permettant le path traversal.
- **Trusting Client Inputs**: L'API côté serveur fait confiance et traite le `filePath` sans assainissement.
- **Potential API Actions**: Si le endpoint API effectue des actions modifiant l'état (par ex., supprimer, modifier des fichiers), il peut être exploité via CSPT.

</details>

## Server-Side in Next.js

### Rendu côté serveur (SSR)

Les pages sont rendues sur le serveur à chaque requête, garantissant que l'utilisateur reçoit du HTML entièrement rendu. Dans ce cas, vous devriez créer votre propre serveur personnalisé pour traiter les requêtes.

**Use Cases:**

- Contenu dynamique qui change fréquemment.
- Optimisation SEO, car les moteurs de recherche peuvent indexer la page entièrement rendue.

**Implementation:**
```jsx
// pages/index.js
export async function getServerSideProps(context) {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data } }
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### Génération de site statique (SSG)

Les pages sont pré-rendues au moment du build, ce qui entraîne des temps de chargement plus rapides et une charge serveur réduite.

**Cas d'utilisation:**

- Contenu qui ne change pas fréquemment.
- Blogs, documentation, pages marketing.

**Implémentation:**
```jsx
// pages/index.js
export async function getStaticProps() {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data }, revalidate: 60 } // Revalidate every 60 seconds
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### Fonctions serverless (API Routes)

Next.js permet la création de endpoints API sous forme de fonctions serverless. Ces fonctions s'exécutent à la demande sans nécessiter de serveur dédié.

**Cas d'utilisation :**

- Traitement des soumissions de formulaires.
- Interaction avec des bases de données.
- Traitement des données ou intégration avec des API tierces.

**Implémentation :**

Avec l'introduction du répertoire `app` dans Next.js 13, le routage et la gestion des API sont devenus plus flexibles et puissants. Cette approche moderne s'aligne étroitement sur le système de routage basé sur les fichiers mais introduit des capacités accrues, notamment la prise en charge des composants côté serveur et côté client.

#### Gestionnaire de route de base

**File Structure:**
```go
my-nextjs-app/
├── app/
│   └── api/
│       └── hello/
│           └── route.js
├── package.json
└── ...
```
**Implémentation :**
```javascript
// app/api/hello/route.js

export async function POST(request) {
return new Response(JSON.stringify({ message: "Hello from App Router!" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

// Client-side fetch to access the API endpoint
fetch("/api/submit", {
method: "POST",
headers: { "Content-Type": "application/json" },
body: JSON.stringify({ name: "John Doe" }),
})
.then((res) => res.json())
.then((data) => console.log(data))
```
**Explication :**

- **Emplacement :** Les routes API sont placées sous le répertoire `app/api/`.
- **Nommage des fichiers :** Chaque endpoint API se trouve dans son propre dossier contenant un fichier `route.js` ou `route.ts`.
- **Fonctions exportées :** Plutôt qu'un export default unique, des fonctions pour des méthodes HTTP spécifiques (par ex. `GET`, `POST`) sont exportées.
- **Gestion des réponses :** Utilisez le constructeur `Response` pour renvoyer des réponses, ce qui permet un meilleur contrôle des en-têtes et des codes de statut.

#### Comment gérer d'autres chemins et méthodes :

<details>

<summary>Gestion des méthodes HTTP spécifiques</summary>

Next.js 13+ vous permet de définir des gestionnaires pour des méthodes HTTP spécifiques dans le même fichier `route.js` ou `route.ts`, ce qui favorise un code plus clair et mieux organisé.

**Exemple :**
```javascript
// app/api/users/[id]/route.js

export async function GET(request, { params }) {
const { id } = params
// Fetch user data based on 'id'
return new Response(JSON.stringify({ userId: id, name: "Jane Doe" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function PUT(request, { params }) {
const { id } = params
// Update user data based on 'id'
return new Response(JSON.stringify({ message: `User ${id} updated.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function DELETE(request, { params }) {
const { id } = params
// Delete user based on 'id'
return new Response(JSON.stringify({ message: `User ${id} deleted.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**Explication :**

- **Exports multiples :** Chaque méthode HTTP (`GET`, `PUT`, `DELETE`) possède sa propre fonction exportée.
- **Paramètres :** Le deuxième argument donne accès aux paramètres de route via `params`.
- **Réponses améliorées :** Un contrôle accru des objets Response, permettant une gestion précise des en-têtes et des codes d'état.

</details>

<details>

<summary>Routes catch-all et imbriquées</summary>

Next.js 13+ prend en charge des fonctionnalités de routage avancées comme les routes catch-all et les routes API imbriquées, permettant des structures d'API plus dynamiques et évolutives.

**Exemple de route catch-all :**
```javascript
// app/api/[...slug]/route.js

export async function GET(request, { params }) {
const { slug } = params
// Handle dynamic nested routes
return new Response(JSON.stringify({ slug }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**Explication :**

- **Syntax:** `[...]` indique un segment catch-all, capturant tous les chemins imbriqués.
- **Usage:** Utile pour les API qui doivent gérer des profondeurs de route variables ou des segments dynamiques.

**Exemple de routes imbriquées :**
```javascript
// app/api/posts/[postId]/comments/[commentId]/route.js

export async function GET(request, { params }) {
const { postId, commentId } = params
// Fetch specific comment for a post
return new Response(
JSON.stringify({ postId, commentId, comment: "Great post!" }),
{
status: 200,
headers: { "Content-Type": "application/json" },
}
)
}
```
**Explication :**

- **Imbrication profonde :** Permet des structures d'API hiérarchiques, reflétant les relations entre ressources.
- **Accès aux paramètres :** Permet d'accéder facilement à plusieurs paramètres de route via l'objet `params`.

</details>

<details>

<summary>Gestion des routes API dans Next.js 12 et versions antérieures</summary>

## Routes API dans le répertoire `pages` (Next.js 12 et versions antérieures)

Avant que Next.js 13 n'introduise le répertoire `app` et des capacités de routage améliorées, les routes API étaient principalement définies dans le répertoire `pages`. Cette approche est encore largement utilisée et prise en charge dans Next.js 12 et les versions antérieures.

#### Route API de base

**Structure de fichiers :**
```go
goCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── hello.js
├── package.json
└── ...
```
**Implémentation :**
```javascript
javascriptCopy code// pages/api/hello.js

export default function handler(req, res) {
res.status(200).json({ message: 'Hello, World!' });
}
```
**Explication :**

- **Emplacement :** Les routes API se trouvent dans le répertoire `pages/api/`.
- **Export :** Utilisez `export default` pour définir la fonction handler.
- **Signature de la fonction :** Le handler reçoit les objets `req` (requête HTTP) et `res` (réponse HTTP).
- **Routage :** Le nom du fichier (`hello.js`) correspond à l'endpoint `/api/hello`.

#### Routes API dynamiques

**Structure des fichiers :**
```bash
bashCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── users/
│           └── [id].js
├── package.json
└── ...
```
**Implémentation:**
```javascript
javascriptCopy code// pages/api/users/[id].js

export default function handler(req, res) {
const {
query: { id },
method,
} = req;

switch (method) {
case 'GET':
// Fetch user data based on 'id'
res.status(200).json({ userId: id, name: 'John Doe' });
break;
case 'PUT':
// Update user data based on 'id'
res.status(200).json({ message: `User ${id} updated.` });
break;
case 'DELETE':
// Delete user based on 'id'
res.status(200).json({ message: `User ${id} deleted.` });
break;
default:
res.setHeader('Allow', ['GET', 'PUT', 'DELETE']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**Explication :**

- **Segments dynamiques :** Les crochets (`[id].js`) désignent des segments de route dynamiques.
- **Accès aux paramètres :** Utilisez `req.query.id` pour accéder au paramètre dynamique.
- **Gestion des méthodes :** Utilisez une logique conditionnelle pour gérer différentes méthodes HTTP (`GET`, `PUT`, `DELETE`, etc).

#### Gestion des différentes méthodes HTTP

Bien que l'exemple de route API de base gère toutes les méthodes HTTP au sein d'une seule fonction, vous pouvez structurer votre code pour gérer chaque méthode explicitement pour plus de clarté et de maintenabilité.

**Exemple :**
```javascript
javascriptCopy code// pages/api/posts.js

export default async function handler(req, res) {
const { method } = req;

switch (method) {
case 'GET':
// Handle GET request
res.status(200).json({ message: 'Fetching posts.' });
break;
case 'POST':
// Handle POST request
res.status(201).json({ message: 'Post created.' });
break;
default:
res.setHeader('Allow', ['GET', 'POST']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**Meilleures pratiques :**

- **Séparation des responsabilités :** Séparer clairement la logique pour les différentes méthodes HTTP.
- **Cohérence des réponses :** Garantir des structures de réponse cohérentes pour faciliter le traitement côté client.
- **Gestion des erreurs :** Gérer proprement les méthodes non prises en charge et les erreurs inattendues.

</details>

### Configuration CORS

Contrôlez quelles origines peuvent accéder à vos routes API, atténuant les vulnérabilités liées au Cross-Origin Resource Sharing (CORS).

**Exemple de mauvaise configuration :**
```javascript
// app/api/data/route.js

export async function GET(request) {
return new Response(JSON.stringify({ data: "Public Data" }), {
status: 200,
headers: {
"Access-Control-Allow-Origin": "*", // Allows any origin
"Access-Control-Allow-Methods": "GET, POST, PUT, DELETE",
},
})
}
```
Notez que **CORS peut également être configuré dans toutes les routes API** dans le fichier **`middleware.ts`** :
```javascript
// app/middleware.ts

import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(request: NextRequest) {
const allowedOrigins = [
"https://yourdomain.com",
"https://sub.yourdomain.com",
]
const origin = request.headers.get("Origin")

const response = NextResponse.next()

if (allowedOrigins.includes(origin || "")) {
response.headers.set("Access-Control-Allow-Origin", origin || "")
response.headers.set(
"Access-Control-Allow-Methods",
"GET, POST, PUT, DELETE, OPTIONS"
)
response.headers.set(
"Access-Control-Allow-Headers",
"Content-Type, Authorization"
)
// If credentials are needed:
// response.headers.set('Access-Control-Allow-Credentials', 'true');
}

// Handle preflight requests
if (request.method === "OPTIONS") {
return new Response(null, {
status: 204,
headers: response.headers,
})
}

return response
}

export const config = {
matcher: "/api/:path*", // Apply to all API routes
}
```
**Problème :**

- **`Access-Control-Allow-Origin: '*'`:** Permet à n'importe quel site d'accéder à l'API, pouvant permettre à des sites malveillants d'interagir avec votre API sans restrictions.
- **Autorisation large des méthodes :** Autoriser toutes les méthodes peut permettre à des attaquants d'effectuer des actions non désirées.

**Comment les attaquants l'exploitent :**

Les attaquants peuvent créer des sites malveillants qui envoient des requêtes à votre API, abusant potentiellement de fonctionnalités telles que la récupération de données, la manipulation de données ou le déclenchement d'actions indésirables au nom d'utilisateurs authentifiés.


{{#ref}}
../../pentesting-web/cors-bypass.md
{{#endref}}

### Exposition du code serveur côté client

Il est facile d'**utiliser du code employé par le serveur également dans du code exposé et utilisé côté client**, la meilleure façon de s'assurer qu'un fichier de code ne soit jamais exposé côté client est d'utiliser cet import au début du fichier:
```js
import "server-only"
```
## Fichiers clés et leurs rôles

### `middleware.ts` / `middleware.js`

**Emplacement :** Racine du projet ou dans `src/`.

**But :** Exécute du code dans la fonction serverless côté serveur avant qu'une requête ne soit traitée, permettant des tâches telles que l'authentification, les redirections ou la modification des réponses.

**Flux d'exécution :**

1. **Requête entrante :** Le middleware intercepte la requête.
2. **Traitement :** Effectue des opérations basées sur la requête (par ex. vérifier l'authentification).
3. **Modification de la réponse :** Peut altérer la réponse ou passer le contrôle au handler suivant.

**Exemples d'utilisation :**

- Rediriger les utilisateurs non authentifiés.
- Ajouter des en-têtes personnalisés.
- Logger les requêtes.

**Exemple de configuration :**
```typescript
// middleware.ts
import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(req: NextRequest) {
const url = req.nextUrl.clone()
if (!req.cookies.has("token")) {
url.pathname = "/login"
return NextResponse.redirect(url)
}
return NextResponse.next()
}

export const config = {
matcher: ["/protected/:path*"],
}
```
### `next.config.js`

**Emplacement :** Racine du projet.

**But :** Configure le comportement de Next.js, activer ou désactiver des fonctionnalités, personnaliser les configurations webpack, définir des variables d'environnement et configurer plusieurs fonctionnalités de sécurité.

**Principales configurations de sécurité :**

<details>

<summary>En-têtes de sécurité</summary>

Les en-têtes de sécurité renforcent la sécurité de votre application en indiquant aux navigateurs comment gérer le contenu. Ils aident à atténuer diverses attaques comme Cross-Site Scripting (XSS), Clickjacking, et MIME type sniffing :

- Content Security Policy (CSP)
- X-Frame-Options
- X-Content-Type-Options
- Strict-Transport-Security (HSTS)
- Referrer Policy

**Exemples :**
```javascript
// next.config.js

module.exports = {
async headers() {
return [
{
source: "/(.*)", // Apply to all routes
headers: [
{
key: "X-Frame-Options",
value: "DENY",
},
{
key: "Content-Security-Policy",
value:
"default-src *; script-src 'self' 'unsafe-inline' 'unsafe-eval';",
},
{
key: "X-Content-Type-Options",
value: "nosniff",
},
{
key: "Strict-Transport-Security",
value: "max-age=63072000; includeSubDomains; preload", // Enforces HTTPS
},
{
key: "Referrer-Policy",
value: "no-referrer", // Completely hides referrer
},
// Additional headers...
],
},
]
},
}
```
</details>

<details>

<summary>Paramètres d'optimisation des images</summary>

Next.js optimise les images pour les performances, mais de mauvaises configurations peuvent mener à des vulnérabilités de sécurité, comme permettre à des sources non fiables d'injecter du contenu malveillant.

**Exemple de mauvaise configuration :**
```javascript
// next.config.js

module.exports = {
images: {
domains: ["*"], // Allows images from any domain
},
}
```
**Problème :**

- **`'*'` :** Permet le chargement d'images depuis n'importe quelle source externe, y compris des domaines non fiables ou malveillants. Les attaquants peuvent héberger des images contenant des payloads malveillants ou du contenu qui induit les utilisateurs en erreur.
- Un autre problème peut être d'autoriser un domaine **où n'importe qui peut téléverser une image** (comme `raw.githubusercontent.com`)

**Comment les attaquants en abusent :**

En injectant des images depuis des sources malveillantes, les attaquants peuvent mener des attaques de phishing, afficher des informations trompeuses, ou exploiter des vulnérabilités dans les bibliothèques de rendu d'images.

</details>

<details>

<summary>Exposition des variables d'environnement</summary>

Gérez les informations sensibles comme les API keys et les identifiants de base de données de manière sécurisée sans les exposer au client.

#### a. Exposition de variables sensibles

**Mauvais exemple de configuration :**
```javascript
// next.config.js

module.exports = {
env: {
SECRET_API_KEY: process.env.SECRET_API_KEY, // Exposed to the client
NEXT_PUBLIC_API_URL: process.env.NEXT_PUBLIC_API_URL, // Correctly prefixed for client
},
}
```
**Problème :**

- **`SECRET_API_KEY` :** Sans le préfixe `NEXT_PUBLIC_`, Next.js n'expose pas les variables au client. Cependant, si le préfixe est ajouté par erreur (par ex., `NEXT_PUBLIC_SECRET_API_KEY`), il devient accessible côté client.

**Comment les attaquants l'exploitent :**

Si des variables sensibles sont exposées au client, les attaquants peuvent les récupérer en inspectant le code côté client ou les requêtes réseau, obtenant ainsi un accès non autorisé aux API, aux bases de données ou à d'autres services.

</details>

<details>

<summary>Redirections</summary>

Gérez les redirections et les réécritures d'URL dans votre application, en veillant à ce que les utilisateurs soient dirigés correctement sans introduire d'open redirect vulnerabilities.

#### a. Open Redirect Vulnerability

**Mauvais exemple de configuration :**
```javascript
// next.config.js

module.exports = {
async redirects() {
return [
{
source: "/redirect",
destination: (req) => req.query.url, // Dynamically redirects based on query parameter
permanent: false,
},
]
},
}
```
**Problème :**

- **Destination dynamique :** Permet aux utilisateurs de spécifier n'importe quelle URL, ce qui permet des attaques d'open redirect.
- **Faire confiance aux entrées utilisateur :** Les redirections vers des URL fournies par les utilisateurs sans validation peuvent conduire au phishing, à la malware distribution ou au credential theft.

**Comment les attaquants l'exploitent :**

Les attaquants peuvent fabriquer des URLs qui semblent provenir de votre domaine mais redirigent les utilisateurs vers des sites malveillants. Par exemple :
```bash
https://yourdomain.com/redirect?url=https://malicious-site.com
```
Les utilisateurs faisant confiance au domaine d'origine peuvent, sans le savoir, être redirigés vers des sites malveillants.

</details>

<details>

<summary>Configuration de Webpack</summary>

Personnalisez les configurations Webpack de votre application Next.js, ce qui peut involontairement introduire des vulnérabilités de sécurité si ce n'est pas fait avec prudence.

#### a. Exposition de modules sensibles

**Exemple de mauvaise configuration :**
```javascript
// next.config.js

module.exports = {
webpack: (config, { isServer }) => {
if (!isServer) {
config.resolve.alias["@sensitive"] = path.join(__dirname, "secret-folder")
}
return config
},
}
```
**Problème :**

- **Exposing Sensitive Paths :** L'aliasing de répertoires sensibles et le fait d'autoriser l'accès côté client peuvent leak des informations confidentielles.
- **Bundling Secrets :** Si des fichiers sensibles sont bundled pour le client, leur contenu devient accessible via les source maps ou en inspectant le client-side code.

**Comment les attaquants l'exploitent :**

Les attaquants peuvent accéder à, ou reconstruire, la structure de répertoires de l'application, pouvant potentiellement trouver et exploiter des fichiers ou données sensibles.

</details>

### `pages/_app.js` et `pages/_document.js`

#### **`pages/_app.js`**

**Objectif :** Remplace le composant App par défaut, permettant un état global, des styles et des composants de mise en page.

**Cas d'utilisation :**

- Injection de CSS global.
- Ajout d'éléments de mise en page.
- Intégration de bibliothèques de gestion d'état.

**Exemple :**
```jsx
// pages/_app.js
import "../styles/globals.css"

function MyApp({ Component, pageProps }) {
return <Component {...pageProps} />
}

export default MyApp
```
#### **`pages/_document.js`**

**Objectif :** Remplace le Document par défaut, permettant de personnaliser les balises `<html>` et `<body>`.

**Cas d'utilisation :**

- Modifier les balises `<html>` ou `<body>`.
- Ajouter des balises meta ou des scripts personnalisés.
- Intégrer des polices tierces.

**Exemple :**
```jsx
// pages/_document.js
import Document, { Html, Head, Main, NextScript } from "next/document"

class MyDocument extends Document {
render() {
return (
<Html lang="en">
<Head>{/* Custom fonts or meta tags */}</Head>
<body>
<Main />
<NextScript />
</body>
</Html>
)
}
}

export default MyDocument
```
### Serveur personnalisé (optionnel)

**Objectif :** Alors que Next.js est fourni avec un serveur intégré, vous pouvez créer un serveur personnalisé pour des cas d'utilisation avancés comme le routage personnalisé ou l'intégration avec des services back-end existants.

**Remarque :** L'utilisation d'un serveur personnalisé peut limiter les options de déploiement, en particulier sur des plateformes comme Vercel qui optimisent le serveur intégré de Next.js.

**Exemple :**
```javascript
// server.js
const express = require("express")
const next = require("next")

const dev = process.env.NODE_ENV !== "production"
const app = next({ dev })
const handle = app.getRequestHandler()

app.prepare().then(() => {
const server = express()

// Custom route
server.get("/a", (req, res) => {
return app.render(req, res, "/a")
})

// Default handler
server.all("*", (req, res) => {
return handle(req, res)
})

server.listen(3000, (err) => {
if (err) throw err
console.log("> Ready on http://localhost:3000")
})
})
```
---

## Considérations architecturales et de sécurité supplémentaires

### Variables d'environnement et configuration

**Objectif :** Gérer les informations sensibles et les paramètres de configuration en dehors du code.

**Bonnes pratiques :**

- **Utilisez des fichiers `.env` :** Stockez des variables telles que les clés API dans `.env.local` (exclu du contrôle de version).
- **Accédez aux variables de façon sécurisée :** Utilisez `process.env.VARIABLE_NAME` pour accéder aux variables d'environnement.
- **Ne divulguez jamais de secrets côté client :** Assurez-vous que les variables sensibles ne sont utilisées que côté serveur.

**Exemple :**
```javascript
// next.config.js
module.exports = {
env: {
API_KEY: process.env.API_KEY, // Accessible on both client and server
SECRET_KEY: process.env.SECRET_KEY, // Be cautious if accessible on the client
},
}
```
**Remarque :** Pour restreindre les variables au seul serveur, omettez-les de l'objet `env` ou préfixez-les par `NEXT_PUBLIC_` pour les exposer au client.

### Authentification et autorisation

**Approche :**

- **Authentification par session :** Utilisez des cookies pour gérer les sessions utilisateur.
- **Authentification par token :** Implémentez des JWTs pour une authentification sans état.
- **Fournisseurs tiers :** Intégrez des providers OAuth (par ex. Google, GitHub) en utilisant des bibliothèques comme `next-auth`.

**Bonnes pratiques de sécurité :**

- **Cookies sécurisés :** Définissez les attributs `HttpOnly`, `Secure` et `SameSite`.
- **Hachage des mots de passe :** Hachez toujours les mots de passe avant de les stocker.
- **Validation des entrées :** Prévenez les attaques par injection en validant et en assainissant les entrées.

**Exemple :**
```javascript
// pages/api/login.js
import { sign } from "jsonwebtoken"
import { serialize } from "cookie"

export default async function handler(req, res) {
const { username, password } = req.body

// Validate user credentials
if (username === "admin" && password === "password") {
const token = sign({ username }, process.env.JWT_SECRET, {
expiresIn: "1h",
})
res.setHeader(
"Set-Cookie",
serialize("auth", token, {
path: "/",
httpOnly: true,
secure: true,
sameSite: "strict",
})
)
res.status(200).json({ message: "Logged in" })
} else {
res.status(401).json({ error: "Invalid credentials" })
}
}
```
### Optimisation des performances

**Stratégies :**

- **Optimisation des images :** Utilisez le composant `next/image` de Next.js pour l'optimisation automatique des images.
- **Fractionnement du code :** Utilisez les imports dynamiques pour fragmenter le code et réduire les temps de chargement initiaux.
- **Mise en cache :** Mettez en œuvre des stratégies de mise en cache pour les réponses d'API et les ressources statiques.
- **Chargement différé :** Chargez les composants ou ressources uniquement lorsqu'ils sont nécessaires.

**Exemple :**
```jsx
// Dynamic Import with Code Splitting
import dynamic from "next/dynamic"

const HeavyComponent = dynamic(() => import("../components/HeavyComponent"), {
loading: () => <p>Loading...</p>,
})
```
## Énumération des Server Actions de Next.js (hash to function name via source maps)

Next.js moderne utilise les “Server Actions” qui s'exécutent sur le serveur mais sont invoquées depuis le client. En production, ces invocations sont opaques : toutes les POSTs arrivent sur un endpoint commun et sont distinguées par un hash spécifique au build envoyé dans l'en-tête `Next-Action`. Exemple:
```http
POST /
Next-Action: a9f8e2b4c7d1...
```
When `productionBrowserSourceMaps` is enabled, minified JS chunks contain calls to `createServerReference(...)` that leak enough structure (plus associated source maps) to recover a mapping between the action hash and the original function name. This lets you translate hashes observed in `Next-Action` into concrete targets like `deleteUserAccount()` or `exportFinancialData()`.

### Extraction approach (regex on minified JS + optional source maps)

Parcourez les chunks JS téléchargés à la recherche de `createServerReference` et extrayez le hash ainsi que le symbole fonction/source. Deux motifs utiles :
```regex
# Strict pattern for standard minification
createServerReference\)\"([a-f0-9]{40,})\",\w+\.callServer,void 0,\w+\.findSourceMapURL,\"([^\"]+)\"\)

# Flexible pattern handling various minification styles
createServerReference[^\"]*\"([a-f0-9]{40,})\"[^\"]*\"([^\"]+)\"\s*\)
```
- Groupe 1: server action hash (40+ hex chars)
- Groupe 2: symbole ou chemin pouvant être résolu au nom de la fonction d'origine via le source map quand présent

Si le script annonce un source map (commentaire de fin `//# sourceMappingURL=<...>.map`), récupérez-le et résolvez le symbole/chemin vers le nom de fonction d'origine.

### Workflow pratique

- Découverte passive lors de la navigation : capturer les requêtes avec les en-têtes `Next-Action` et les URLs des chunks JS.
- Récupérer les bundles JS référencés et les fichiers `*.map` associés (lorsqu'ils sont présents).
- Exécuter la regex ci-dessus pour construire un dictionnaire hash↔name.
- Utiliser le dictionnaire pour cibler les tests :
  - Triage basé sur les noms (p.ex., `transferFunds`, `exportFinancialData`).
  - Suivre la couverture entre les builds par nom de fonction (les hashes changent entre builds).

### Exécution d'actions cachées (requête basée sur un template)

Prendre un POST valide observé dans-proxy comme template et remplacer la valeur `Next-Action` pour cibler une autre action découverte :
```http
# Before
Next-Action: a9f8e2b4c7d1

# After
Next-Action: b7e3f9a2d8c5
```
Relancez dans Repeater et testez l'autorisation, la validation des entrées et la logique métier d'actions autrement inaccessibles.

### Automatisation Burp

- NextjsServerActionAnalyzer (Burp extension) automatise ce qui précède dans Burp :
- Analyse l'historique du proxy pour les chunks JS, extrait les entrées `createServerReference(...)` et analyse les source maps quand elles sont disponibles.
- Maintient un dictionnaire consultable hash↔function-name et dé-duplique entre les builds par function name.
- Peut localiser un POST template valide et ouvrir un onglet Repeater prêt à l'envoi avec le hash de l'action ciblée remplacé.
- Repo: https://github.com/Adversis/NextjsServerActionAnalyzer

### Remarques et limites

- Requiert que `productionBrowserSourceMaps` soit activé en production pour récupérer les noms à partir des bundles/source maps.
- La divulgation du function-name n'est pas une vulnérabilité en soi ; utilisez-la pour orienter la découverte et tester l'autorisation de chaque action.

## Références

- [Pentesting Next.js Server Actions — A Burp Extension for Hash-to-Function Mapping](https://www.adversis.io/blogs/pentesting-next-js-server-actions)
- [NextjsServerActionAnalyzer (Burp extension)](https://github.com/Adversis/NextjsServerActionAnalyzer)

{{#include ../../banners/hacktricks-training.md}}
