# NextJS

{{#include ../../banners/hacktricks-training.md}}

## Algemene argitektuur van 'n Next.js-toepassing

### Tipiese lêerstruktuur

'n Standaard Next.js-projek volg 'n spesifieke lêer- en gidsstruktuur wat sy funksies soos routering, API-eindpunte en bestuur van statiese bates vergemaklik. Hier is 'n tipiese uitleg:
```lua
my-nextjs-app/
├── node_modules/
├── public/
│   ├── images/
│   │   └── logo.png
│   └── favicon.ico
├── app/
│   ├── api/
│   │   └── hello/
│   │       └── route.ts
│   ├── layout.tsx
│   ├── page.tsx
│   ├── about/
│   │   └── page.tsx
│   ├── dashboard/
│   │   ├── layout.tsx
│   │   └── page.tsx
│   ├── components/
│   │   ├── Header.tsx
│   │   └── Footer.tsx
│   ├── styles/
│   │   ├── globals.css
│   │   └── Home.module.css
│   └── utils/
│       └── api.ts
├── .env.local
├── next.config.js
├── tsconfig.json
├── package.json
├── README.md
└── yarn.lock / package-lock.json

```
### Kerngidse en Lêers

- **public/:** Gasheer statiese bates soos beelde, lettertipes, en ander lêers. Lêers hier is toeganklik by die wortelpad (`/`).
- **app/:** Sentrale gids vir jou aansoek se bladsye, layouts, komponente, en API-roetes. Omhels die **App Router** paradigma, wat gevorderde routerfunksies en skeiding tussen server- en kliëntkomponente moontlik maak.
- **app/layout.tsx:** Definieer die wortel layout vir jou toepassing, wat om alle bladsye vou en konsekwente UI-elemente soos headers, footers, en navigasiebalkies voorsien.
- **app/page.tsx:** Bedien as die ingangspunt vir die wortelroute `/`, en render die tuisblad.
- **app/[route]/page.tsx:** Hanteer statiese en dinamiese roetes. Elke gids binne `app/` verteenwoordig ’n route-segment, en `page.tsx` binne daardie gidse kom ooreen met die route se komponent.
- **app/api/:** Bevat API-roetes, wat jou toelaat om serverless funksies te skep wat HTTP-versoeke hanteer. Hierdie roetes vervang die tradisionele `pages/api` gids.
- **app/components/:** Huisves herbruikbare React-komponente wat oor verskeie bladsye en layouts gebruik kan word.
- **app/styles/:** Bevat globale CSS-lêers en CSS Modules vir komponent-geskepte styling.
- **app/utils/:** Sluit nuttige funksies, helper modules, en ander nie-UI logika in wat gedeel kan word oor die toepassing.
- **.env.local:** Stoor omgewingsveranderlikes spesifiek vir die plaaslike ontwikkelomgewing. Hierdie veranderlikes word nie in weergawebeheer gecommit nie.
- **next.config.js:** Pas Next.js-gedrag aan, insluitend webpack-konfigurasies, omgewingsveranderlikes, en sekuriteitsinstellings.
- **tsconfig.json:** Konfigureer TypeScript-instellings vir die projek, wat tipekontroles en ander TypeScript-funksies moontlik maak.
- **package.json:** Bestuur projekafhanklikhede, skripte, en metadata.
- **README.md:** Verskaf dokumentasie en inligting oor die projek, insluitend opstelinstruksies, gebruiksriglyne, en ander relevante besonderhede.
- **yarn.lock / package-lock.json:** Sluit die projek se afhanklikhede vas op spesifieke weergawes, wat konsekwente installasies oor verskillende omgewings verseker.

## Kliëntkant in Next.js

### Lêergebaseerde Routing in die `app` Directory

Die `app` gids is die hoeksteen van routing in die nuutste Next.js weergawes. Dit gebruik die lêerstelsel om roetes te definieer, wat routebestuur intuïtief en skaalbaar maak.

<details>

<summary>Hantering van die wortelpad /</summary>

**File Structure:**
```arduino
my-nextjs-app/
├── app/
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Sleutel Lêers:**

- **`app/page.tsx`**: Hanteer versoeke na die wortelpad `/`.
- **`app/layout.tsx`**: Definieer die layout vir die toepassing en omsluit alle bladsye.

**Implementering:**
```tsx
tsxCopy code// app/page.tsx

export default function HomePage() {
return (
<div>
<h1>Welcome to the Home Page!</h1>
<p>This is the root route.</p>
</div>
);
}
```
**Verduideliking:**

- **Roete-definisie:** Die `page.tsx` lêer direk in die `app` gids ooreen met die `/` roete.
- **Weergawering:** Hierdie komponent gee die inhoud van die tuisblad weer.
- **Layout-integrasie:** Die `HomePage` komponent word deur die `layout.tsx` omhul, wat kopstukke, voetskrifte en ander algemene elemente kan insluit.

</details>

<details>

<summary>Hantering van Ander Statiese Paaie</summary>

**Voorbeeld: `/about` Roete**

**Lêerstruktuur:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── about/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementering:**
```tsx
// app/about/page.tsx

export default function AboutPage() {
return (
<div>
<h1>About Us</h1>
<p>Learn more about our mission and values.</p>
</div>
)
}
```
**Verduideliking:**

- **Roete-definisie:** Die `page.tsx` lêer in die `about` gids kom ooreen met die `/about` roete.
- **Weergawing:** Hierdie komponent gee die inhoud vir die about-bladsy weer.

</details>

<details>

<summary>Dinamiese Roetes</summary>

Dinamiese roetes maak dit moontlik om paaie met veranderlike segmente te hanteer, sodat toepassings inhoud kan wys gebaseer op parameters soos IDs, slugs, ens.

**Voorbeeld: `/posts/[id]` Route**

**Lêerstruktuur:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── posts/
│   │   └── [id]/
│   │       └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementering:**
```tsx
tsxCopy code// app/posts/[id]/page.tsx

import { useRouter } from 'next/navigation';

interface PostProps {
params: { id: string };
}

export default function PostPage({ params }: PostProps) {
const { id } = params;
// Fetch post data based on 'id'

return (
<div>
<h1>Post #{id}</h1>
<p>This is the content of post {id}.</p>
</div>
);
}
```
**Verduideliking:**

- **Dynamic Segment:** `[id]` dui 'n dinamiese segment in die roete aan, wat die `id` parameter van die URL vasvang.
- **Accessing Parameters:** Die `params` object bevat die dinamiese parameters, toeganklik binne die komponent.
- **Route Matching:** Enige pad wat by `/posts/*` pas, soos `/posts/1`, `/posts/abc`, ens., sal deur hierdie komponent hanteer word.

</details>

<details>

<summary>Geneste Roetes</summary>

Next.js ondersteun geneste routering, wat hiërargiese roetestrukture moontlik maak wat die gidsstruktuur weerspieël.

**Example: `/dashboard/settings/profile` Route**

**Lêerstruktuur:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── dashboard/
│   │   ├── settings/
│   │   │   └── profile/
│   │   │       └── page.tsx
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementering:**
```tsx
tsxCopy code// app/dashboard/settings/profile/page.tsx

export default function ProfileSettingsPage() {
return (
<div>
<h1>Profile Settings</h1>
<p>Manage your profile information here.</p>
</div>
);
}
```
**Verduideliking:**

- **Diepe nesteling:** Die `page.tsx` lêer binne `dashboard/settings/profile/` ooreenstem met die `/dashboard/settings/profile` roete.
- **Weerspieëling van hiërargie:** Die gidsstruktuur weerspieël die URL-pad, wat die onderhoudbaarheid en duidelikheid verbeter.

</details>

<details>

<summary>Catch-all-roetes</summary>

Catch-all-roetes hanteer veelvuldige geneste segmente of onbekende paaie, wat buigsaamheid in roetehantering bied.

**Voorbeeld: `/*` Roete**

**Lêerstruktuur:**
```arduino
my-nextjs-app/
├── app/
│   ├── [..slug]/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementering:**
```tsx
// app/[...slug]/page.tsx

interface CatchAllProps {
params: { slug: string[] }
}

export default function CatchAllPage({ params }: CatchAllProps) {
const { slug } = params
const fullPath = `/${slug.join("/")}`

return (
<div>
<h1>Catch-All Route</h1>
<p>You have navigated to: {fullPath}</p>
</div>
)
}
```
**Verduideliking:**

- **Catch-All Segment:** `[...slug]` vang al die oorblywende padsegmenten as 'n array.
- **Gebruik:** Nuttig vir die hantering van dinamiese routing-scenario's soos gebruikersgegenereerde paaie, geneste kategorieë, ens.
- **Roete-ooreenstemming:** Paaie soos `/anything/here`, `/foo/bar/baz`, ens., word deur hierdie komponent hanteer.

</details>

### Potensiële kliëntkant-kwesbaarhede

Alhoewel Next.js 'n veilige fondament bied, kan onvanpaste koderingpraktyke kwesbaarhede inbring. Belangrike kliëntkant-kwesbaarhede sluit in:

<details>

<summary>Cross-Site Scripting (XSS)</summary>

XSS-aanvalle gebeur wanneer kwaadwillige scripts in vertroude webwerwe ingespuit word. Aanvallers kan scripts in gebruikers se blaaiers uitvoer, data steel of aksies namens die gebruiker uitvoer.

**Voorbeeld van kwesbare kode:**
```jsx
// Dangerous: Injecting user input directly into HTML
function Comment({ userInput }) {
return <div dangerouslySetInnerHTML={{ __html: userInput }} />
}
```
**Waarom dit kwesbaar is:** Deur `dangerouslySetInnerHTML` met onbetroubare insette te gebruik, kan aanvallers kwaadwillige skripte inspuit.

</details>

<details>

<summary>Client-Side Template Injection</summary>

Dit gebeur wanneer gebruikersinsette verkeerd hanteer word in sjablone, wat aanvallers toelaat om sjablone of uitdrukkings in te spuit en uit te voer.

**Voorbeeld van kwesbare kode:**
```jsx
import React from "react"
import ejs from "ejs"

function RenderTemplate({ template, data }) {
const html = ejs.render(template, data)
return <div dangerouslySetInnerHTML={{ __html: html }} />
}
```
**Waarom dit kwesbaar is:** As `template` of `data` kwaadwillige inhoud bevat, kan dit lei tot die uitvoering van onbedoelde kode.

</details>

<details>

<summary>Client Path Traversal</summary>

Dit is 'n kwesbaarheid wat aanvallers in staat stel om client-side paths te manipuleer om onbedoelde aksies uit te voer, soos Cross-Site Request Forgery (CSRF). Anders as server-side path traversal, wat die bediener se lêerstelsel teiken, fokus CSPT op die uitbuiting van client-side meganismes om legitieme API-versoeke na kwaadwillige endpoints om te lei.

**Voorbeeld van kwesbare kode:**

'n Next.js toepassing laat gebruikers toe om lêers op te laai en af te laai. Die aflaaifunksie is aan die client side geïmplementeer, waar gebruikers die lêerpad kan spesifiseer om af te laai.
```jsx
// pages/download.js
import { useState } from "react"

export default function DownloadPage() {
const [filePath, setFilePath] = useState("")

const handleDownload = () => {
fetch(`/api/files/${filePath}`)
.then((response) => response.blob())
.then((blob) => {
const url = window.URL.createObjectURL(blob)
const a = document.createElement("a")
a.href = url
a.download = filePath
a.click()
})
}

return (
<div>
<h1>Download File</h1>
<input
type="text"
value={filePath}
onChange={(e) => setFilePath(e.target.value)}
placeholder="Enter file path"
/>
<button onClick={handleDownload}>Download</button>
</div>
)
}
```
#### Aanvalscenario

1. **Aanvaller se doelwit**: Perform a CSRF attack to delete a critical file (e.g., `admin/config.json`) by manipulating the `filePath`.
2. **Uitbuiting van CSPT**:
- **Kwaadaardige invoer**: Die aanvaller stel 'n URL saam met 'n gemanipuleerde `filePath` soos `../deleteFile/config.json`.
- **Resulterende API-oproep**: Die client-side kode maak 'n versoek na `/api/files/../deleteFile/config.json`.
- **Bediener se hantering**: Indien die bediener die `filePath` nie valideer nie, verwerk dit die versoek en kan dit sensitiewe lêers verwyder of openbaar maak.
3. **Uitvoering van CSRF**:
- **Gemaakte skakel**: Die aanvaller stuur die slagoffer 'n skakel of plaas 'n kwaadaardige script wat die aflaaiversoek met die gemanipuleerde `filePath` trigger.
- **Uitkoms**: Die slagoffer voer onbedoeld die aksie uit, wat tot ongemagtigde lêertoegang of -verwydering lei.

#### Waarom dit kwesbaar is

- **Gebrek aan invoervalidasie**: Die client-side laat arbitrêre `filePath` insette toe, wat path traversal moontlik maak.
- **Vertroue op kliëntinsette**: Die server-side API vertrou en verwerk die `filePath` sonder sanitisering.
- **Potensiële API-aksies**: Indien die API-endpoint toestandveranderende aksies uitvoer (bv. delete, modify files), kan dit via CSPT uitgebuit word.

</details>

## Bedienerkant in Next.js

### Bedienerkant Rendering (SSR)

Bladsye word by elke versoek op die bediener gerender, wat verseker dat die gebruiker volledige gerenderde HTML ontvang. In hierdie geval behoort jy jou eie pasgemaakte server te skep om die versoeke te verwerk.

**Use Cases:**

- Dinamiese inhoud wat gereeld verander.
- SEO-optimering, aangesien soekenjins die volledig gerenderde bladsy kan deursoek.

**Implementering:**
```jsx
// pages/index.js
export async function getServerSideProps(context) {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data } }
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### Statiese Site Generering (SSG)

Bladsye word vooraf gerender tydens build-tyd, wat lei tot vinniger laaitye en verminderde bedienerbelasting.

**Gebruikgevalle:**

- Inhoud wat nie gereeld verander nie.
- Blogs, dokumentasie, bemarkingsbladsye.

**Implementering:**
```jsx
// pages/index.js
export async function getStaticProps() {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data }, revalidate: 60 } // Revalidate every 60 seconds
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### Serverlose Funksies (API Routes)

Next.js laat die skep van API-endpunte toe as serverlose funksies. Hierdie funksies hardloop op aanvraag sonder die behoefte aan 'n toegewyde bediener.

**Gebruikgevalle:**

- Verwerking van vorminskrywings.
- Interaksie met databasisse.
- Verwerking van data of integrasie met derdeparty-APIs.

**Implementering:**

Met die bekendstelling van die `app` directory in Next.js 13 het routering en API-hantering meer buigsaam en kragtig geword. Hierdie moderne benadering stem nouver saam met die lêer-gebaseerde routeringstelsel, maar bring verbeterde vermoëns in, insluitend ondersteuning vir server- en clientkomponente.

#### Basiese roete-hanteraar

**Lêerstruktuur:**
```go
my-nextjs-app/
├── app/
│   └── api/
│       └── hello/
│           └── route.js
├── package.json
└── ...
```
**Implementering:**
```javascript
// app/api/hello/route.js

export async function POST(request) {
return new Response(JSON.stringify({ message: "Hello from App Router!" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

// Client-side fetch to access the API endpoint
fetch("/api/submit", {
method: "POST",
headers: { "Content-Type": "application/json" },
body: JSON.stringify({ name: "John Doe" }),
})
.then((res) => res.json())
.then((data) => console.log(data))
```
**Verduideliking:**

- **Ligging:** API routes is geplaas onder die `app/api/` directory.
- **Lêernaam:** Elke API-endpoint lê in sy eie gids wat 'n `route.js` of `route.ts` file bevat.
- **Geëksporteerde Funksies:** In plaas van 'n enkele default-export, word spesifieke HTTP-metode funksies (bv. `GET`, `POST`) geëksporteer.
- **Response Hantering:** Gebruik die `Response` constructor om responses terug te gee, wat meer beheer oor headers en statuskodes toelaat.

#### Hoe om ander paaie en metodes te hanteer:

<details>

<summary>Hanering van spesifieke HTTP-metodes</summary>

Next.js 13+ laat jou toe om handlers vir spesifieke HTTP-metodes binne dieselfde `route.js` of `route.ts` file te definieer, wat duideliker en meer georganiseerde kode bevorder.

**Voorbeeld:**
```javascript
// app/api/users/[id]/route.js

export async function GET(request, { params }) {
const { id } = params
// Fetch user data based on 'id'
return new Response(JSON.stringify({ userId: id, name: "Jane Doe" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function PUT(request, { params }) {
const { id } = params
// Update user data based on 'id'
return new Response(JSON.stringify({ message: `User ${id} updated.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function DELETE(request, { params }) {
const { id } = params
// Delete user based on 'id'
return new Response(JSON.stringify({ message: `User ${id} deleted.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**Verduideliking:**

- **Meerdere Exporte:** Elke HTTP-metode (`GET`, `PUT`, `DELETE`) het sy eie geëksporteerde funksie.
- **Parameters:** Die tweede argument gee toegang tot roeteparameters via `params`.
- **Verbeterde Antwoorde:** Groter beheer oor response-objekte, wat 'n presiese beheer van headers en statuskodes moontlik maak.

</details>

<details>

<summary>Catch-All en Geneste Roetes</summary>

Next.js 13+ ondersteun gevorderde routeringsfunksies soos catch-all roetes en geneste API-roetes, wat meer dinamiese en skaalbare API-strukture toelaat.

**Catch-All Roete Voorbeeld:**
```javascript
// app/api/[...slug]/route.js

export async function GET(request, { params }) {
const { slug } = params
// Handle dynamic nested routes
return new Response(JSON.stringify({ slug }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**Verduideliking:**

- **Syntax:** `[...]` dui 'n catch-all-segment aan en vang alle geneste paaie op.
- **Gebruik:** Handig vir APIs wat wisselende roete-diepte of dinamiese segmente moet hanteer.

**Geneste Roetes Voorbeeld:**
```javascript
// app/api/posts/[postId]/comments/[commentId]/route.js

export async function GET(request, { params }) {
const { postId, commentId } = params
// Fetch specific comment for a post
return new Response(
JSON.stringify({ postId, commentId, comment: "Great post!" }),
{
status: 200,
headers: { "Content-Type": "application/json" },
}
)
}
```
**Verduideliking:**

- **Diepe nesteling:** Laat hiërargiese API-strukture toe wat verhoudings tussen hulpbronne weerspieël.
- **Parametertoegang:** Maklik toegang tot verskeie roete-parameters via die `params`-objek.

</details>

<details>

<summary>Hantering van API-roetes in Next.js 12 en vroeër</summary>

## API-roetes in die `pages`-gids (Next.js 12 en vroeër)

Voor Next.js 13 die `app`-gids en verbeterde routing-vaardighede bekendgestel het, is API-roetes hoofsaaklik binne die `pages`-gids gedefinieer. Hierdie benadering word steeds algemeen gebruik en ondersteun in Next.js 12 en vroeër weergawes.

#### Basiese API-roete

**Lêerstruktuur:**
```go
goCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── hello.js
├── package.json
└── ...
```
**Implementering:**
```javascript
javascriptCopy code// pages/api/hello.js

export default function handler(req, res) {
res.status(200).json({ message: 'Hello, World!' });
}
```
**Verduideliking:**

- **Ligging:** API-roetes is geleë onder die `pages/api/` gids.
- **Uitvoer:** Gebruik `export default` om die handler-funksie te definieer.
- **Funksie-handtekening:** Die handler ontvang `req` (HTTP request) en `res` (HTTP response) objekte.
- **Roetering:** Die lêernaam (`hello.js`) stem ooreen met die endpoint `/api/hello`.

#### Dinamiese API-roetes

**Lêerstruktuur:**
```bash
bashCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── users/
│           └── [id].js
├── package.json
└── ...
```
**Implementering:**
```javascript
javascriptCopy code// pages/api/users/[id].js

export default function handler(req, res) {
const {
query: { id },
method,
} = req;

switch (method) {
case 'GET':
// Fetch user data based on 'id'
res.status(200).json({ userId: id, name: 'John Doe' });
break;
case 'PUT':
// Update user data based on 'id'
res.status(200).json({ message: `User ${id} updated.` });
break;
case 'DELETE':
// Delete user based on 'id'
res.status(200).json({ message: `User ${id} deleted.` });
break;
default:
res.setHeader('Allow', ['GET', 'PUT', 'DELETE']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**Verduideliking:**

- **Dynamic Segments:** Vierkantige hakies (`[id].js`) dui dinamiese roete-segmente aan.
- **Accessing Parameters:** Gebruik `req.query.id` om die dinamiese parameter te kry.
- **Handling Methods:** Gebruik voorwaardelike logika om verskillende HTTP-metodes (`GET`, `PUT`, `DELETE`, etc.) te hanteer.

#### Hantering van verskillende HTTP-metodes

Alhoewel die basiese API-roetevoorbeeld alle HTTP-metodes binne 'n enkele funksie hanteer, kan jy jou kode struktureer om elke metode eksplisiet te hanteer vir beter duidelikheid en onderhoudbaarheid.

**Voorbeeld:**
```javascript
javascriptCopy code// pages/api/posts.js

export default async function handler(req, res) {
const { method } = req;

switch (method) {
case 'GET':
// Handle GET request
res.status(200).json({ message: 'Fetching posts.' });
break;
case 'POST':
// Handle POST request
res.status(201).json({ message: 'Post created.' });
break;
default:
res.setHeader('Allow', ['GET', 'POST']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**Beste praktyke:**

- **Skeiding van verantwoordelikhede:** Skei die logika duidelik vir verskillende HTTP-metodes.
- **Konsekwentheid van antwoorde:** Verseker konsekwente antwoordstrukture om hantering aan kliëntkant te vergemaklik.
- **Fouthantering:** Hanteer nie-ondersteunde metodes en onvoorsiene foute op 'n elegante wyse.

</details>

### CORS-konfigurasie

Beheer watter oorspronge toegang tot jou API-roetes kan kry, en sodoende Cross-Origin Resource Sharing (CORS) kwesbaarhede verminder.

**Slegte konfigurasie-voorbeeld:**
```javascript
// app/api/data/route.js

export async function GET(request) {
return new Response(JSON.stringify({ data: "Public Data" }), {
status: 200,
headers: {
"Access-Control-Allow-Origin": "*", // Allows any origin
"Access-Control-Allow-Methods": "GET, POST, PUT, DELETE",
},
})
}
```
Let wel dat **CORS ook in al die API routes** binne die **`middleware.ts`**-lêer geconfigureer kan word:
```javascript
// app/middleware.ts

import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(request: NextRequest) {
const allowedOrigins = [
"https://yourdomain.com",
"https://sub.yourdomain.com",
]
const origin = request.headers.get("Origin")

const response = NextResponse.next()

if (allowedOrigins.includes(origin || "")) {
response.headers.set("Access-Control-Allow-Origin", origin || "")
response.headers.set(
"Access-Control-Allow-Methods",
"GET, POST, PUT, DELETE, OPTIONS"
)
response.headers.set(
"Access-Control-Allow-Headers",
"Content-Type, Authorization"
)
// If credentials are needed:
// response.headers.set('Access-Control-Allow-Credentials', 'true');
}

// Handle preflight requests
if (request.method === "OPTIONS") {
return new Response(null, {
status: 204,
headers: response.headers,
})
}

return response
}

export const config = {
matcher: "/api/:path*", // Apply to all API routes
}
```
**Probleem:**

- **`Access-Control-Allow-Origin: '*'`:** Laat enige webwerf toe om toegang tot die API te kry, wat moontlik kwaadwillige werwe kan toelaat om sonder beperking met jou API te kommunikeer.
- **Breed toegelate metodes:** Om alle metodes toe te laat kan aanvallers in staat stel om ongewenste aksies uit te voer.

**Hoe aanvallers dit uitbuit:**

Aanvallers kan kwaadwillige werwe skep wat versoeke aan jou API maak, moontlik funksionaliteite misbruik soos dataherwinning, datamanipulasie, of die ontketen van ongewenste aksies namens geauthentiseerde gebruikers.


{{#ref}}
../../pentesting-web/cors-bypass.md
{{#endref}}

### Server-kode blootstelling aan kliëntkant

Dit kan maklik gebeur dat **kode wat deur die server gebruik word ook aan die kliëntkant blootgestel en gebruik word**, die beste manier om te verseker dat 'n kode-lêer nooit aan die kliëntkant blootgestel word nie, is deur hierdie import aan die begin van die lêer te gebruik:
```js
import "server-only"
```
## Sleutel-lêers en hul rolle

### `middleware.ts` / `middleware.js`

**Ligging:** Wortel van die projek of binne `src/`.

**Doel:** Voer kode uit in die server-side serverless-funksie voordat 'n versoek verwerk word, wat take soos verifikasie, omleidings of die wysiging van antwoorde moontlik maak.

**Uitvoeringsvloei:**

1. **Inkomende versoek:** Die middleware onderskep die versoek.
2. **Verwerking:** Voer bedrywighede uit gebaseer op die versoek (bv. kontroleer of die gebruiker geverifieer is).
3. **Antwoordmodifikasie:** Kan die antwoord verander of beheer aan die volgende handler deurgee.

**Voorbeelde van gebruiksgevalle:**

- Herlei ongeverifieerde gebruikers.
- Voeg aangepaste headers by.
- Log versoeke.

**Voorbeeldkonfigurasie:**
```typescript
// middleware.ts
import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(req: NextRequest) {
const url = req.nextUrl.clone()
if (!req.cookies.has("token")) {
url.pathname = "/login"
return NextResponse.redirect(url)
}
return NextResponse.next()
}

export const config = {
matcher: ["/protected/:path*"],
}
```
### `next.config.js`

**Ligging:** Wortel van die projek.

**Doel:** Konfigureer Next.js-gedrag, skakel funksies aan of af, pas webpack-konfigurasies aan, stel omgewingsveranderlikes, en konfigureer verskeie sekuriteitskenmerke.

**Belangrike Sekuriteitskonfigurasies:**

<details>

<summary>Sekuriteitsheaders</summary>

Sekuriteitsheaders verbeter die sekuriteit van jou toepassing deur blaaiers te instrueer oor hoe om inhoud te hanteer. Hulle help om verskeie aanvalle soos Cross-Site Scripting (XSS), Clickjacking, en MIME type sniffing te mitiageer:

- Content Security Policy (CSP)
- X-Frame-Options
- X-Content-Type-Options
- Strict-Transport-Security (HSTS)
- Referrer Policy

**Voorbeelde:**
```javascript
// next.config.js

module.exports = {
async headers() {
return [
{
source: "/(.*)", // Apply to all routes
headers: [
{
key: "X-Frame-Options",
value: "DENY",
},
{
key: "Content-Security-Policy",
value:
"default-src *; script-src 'self' 'unsafe-inline' 'unsafe-eval';",
},
{
key: "X-Content-Type-Options",
value: "nosniff",
},
{
key: "Strict-Transport-Security",
value: "max-age=63072000; includeSubDomains; preload", // Enforces HTTPS
},
{
key: "Referrer-Policy",
value: "no-referrer", // Completely hides referrer
},
// Additional headers...
],
},
]
},
}
```
</details>

<details>

<summary>Beeldoptimaliseringsinstellings</summary>

Next.js optimaliseer beelde vir prestasie, maar verkeerd gekonfigureerde instellings kan tot sekuriteitskwesbaarhede lei, byvoorbeeld deur onbetroubare bronne toe te laat om kwaadwillige inhoud in te spuit.

**Slegte konfigurasievoorbeeld:**
```javascript
// next.config.js

module.exports = {
images: {
domains: ["*"], // Allows images from any domain
},
}
```
**Probleem:**

- **`'*'`:** Laat toe dat beelde van enige eksterne bron gelaai word, insluitend onbetroubare of kwaadwillige domeine. Aanvallers kan beelde host wat kwaadwillige payloads of inhoud bevat wat gebruikers mislei.
- Nog 'n probleem kan wees om 'n domein toe te laat **waar enigiemand 'n beeld kan oplaai** (soos `raw.githubusercontent.com`)

**Hoe aanvallers dit misbruik:**

Deur beelde vanaf kwaadwillige bronne in te sluit, kan aanvallers phishing-aanvalle uitvoer, misleidende inligting vertoon, of kwesbaarhede in beeld-rendering biblioteke uitbuit.

</details>

<details>

<summary>Blootstelling van Omgewingsveranderlikes</summary>

Bestuur sensitiewe inligting soos API keys en database credentials veilig sonder om dit aan die kliënt bloot te stel.

#### a. Blootstelling van Sensitiewe Veranderlikes

**Slegte Konfigurasie Voorbeeld:**
```javascript
// next.config.js

module.exports = {
env: {
SECRET_API_KEY: process.env.SECRET_API_KEY, // Exposed to the client
NEXT_PUBLIC_API_URL: process.env.NEXT_PUBLIC_API_URL, // Correctly prefixed for client
},
}
```
**Probleem:**

- **`SECRET_API_KEY`:** Sonder die `NEXT_PUBLIC_` voorvoegsel stel Next.js nie veranderlikes aan die kliënt bloot nie. As dit egter per ongeluk met die voorvoegsel geplaas word (bv. `NEXT_PUBLIC_SECRET_API_KEY`), word dit op die kliëntkant toeganklik.

**Hoe aanvallers dit misbruik:**

As sensitiewe veranderlikes aan die kliënt blootgestel word, kan aanvallers dit bekom deur die kliëntkantkode of netwerkaanvrae te inspekteer, en so ongemagtigde toegang tot APIs, databasisse of ander dienste verkry.

</details>

<details>

<summary>Omleidings</summary>

Bestuur URL-omleidings en herskrywings binne jou toepassing en verseker dat gebruikers na die korrekte plekke geleid word sonder om open redirect kwesbaarhede te skep.

#### a. Open Redirect Vulnerability

**Slegte konfigurasie-voorbeeld:**
```javascript
// next.config.js

module.exports = {
async redirects() {
return [
{
source: "/redirect",
destination: (req) => req.query.url, // Dynamically redirects based on query parameter
permanent: false,
},
]
},
}
```
**Probleem:**

- **Dinamiese Bestemming:** Laat gebruikers toe om enige URL te spesifiseer, wat open redirect attacks moontlik maak.
- **Vertrou gebruikersinvoer:** Omleidings na URL's wat deur gebruikers verskaf word sonder validatie, kan lei tot phishing, malware distribution, of credential theft.

**Hoe aanvallers dit misbruik:**

Aanvallers kan URLs saamstel wat skynbaar vanaf jou domein afkomstig lyk, maar gebruikers na kwaadaardige werwe herlei. Byvoorbeeld:
```bash
https://yourdomain.com/redirect?url=https://malicious-site.com
```
Gebruikers wat die oorspronklike domein vertrou, kan onbewustelik na skadelike webwerwe navigeer.

</details>

<details>

<summary>Webpack Configuration</summary>

Pas Webpack-konfigurasies aan vir jou Next.js-toepassing, wat onbedoeld sekuriteitskwesbaarhede kan inbring as dit nie versigtig hanteer word nie.

#### a. Blootstelling van sensitiewe modules

**Slegte konfigurasievoorbeeld:**
```javascript
// next.config.js

module.exports = {
webpack: (config, { isServer }) => {
if (!isServer) {
config.resolve.alias["@sensitive"] = path.join(__dirname, "secret-folder")
}
return config
},
}
```
**Problem:**

- **Blootstelling van Gevoelige Paaie:** Om gevoelig directories te alias en kliënt-side toegang toe te laat kan leak vertroulike inligting.
- **Bundeling van Sekrete:** As gevoelig lêers vir die kliënt saamgebundel word, word hul inhoud toeganklik deur source maps of deur ondersoek van die client-side code.

**How attackers abuse it:**

Aanvallers kan toegang kry tot of die toepassing se gidsstruktuur herbou, en moontlik gevoelige lêers of data vind en misbruik.

</details>

### `pages/_app.js` and `pages/_document.js`

#### **`pages/_app.js`**

**Purpose:** Oorskryf die standaard App-komponent, wat voorsiening maak vir globale state, style en layout-komponente.

**Use Cases:**

- Inspuiting van globale CSS.
- Byvoeging van layout-wrappers.
- Integrasie van toestandbestuursbiblioteke.

**Example:**
```jsx
// pages/_app.js
import "../styles/globals.css"

function MyApp({ Component, pageProps }) {
return <Component {...pageProps} />
}

export default MyApp
```
#### **`pages/_document.js`**

**Doel:** Oorskryf die standaard Document, wat aanpassing van die HTML- en Body-tags moontlik maak.

**Gebruiksscenario's:**

- Aanpassing van die `<html>` of `<body>` tags.
- Byvoeging van meta tags of pasgemaakte scripts.
- Integrasie van lettertipes van derde partye.

**Voorbeeld:**
```jsx
// pages/_document.js
import Document, { Html, Head, Main, NextScript } from "next/document"

class MyDocument extends Document {
render() {
return (
<Html lang="en">
<Head>{/* Custom fonts or meta tags */}</Head>
<body>
<Main />
<NextScript />
</body>
</Html>
)
}
}

export default MyDocument
```
### Pasgemaakte Server (Opsioneel)

**Doel:** Alhoewel Next.js met 'n ingeboude server kom, kan jy 'n pasgemaakte server skep vir gevorderde gebruiksgevalle soos aangepaste routing of integrasie met bestaande backend-dienste.

**Nota:** Die gebruik van 'n pasgemaakte server kan ontplooiingsopsies beperk, veral op platforms soos Vercel wat optimaliseer vir die ingeboude server van Next.js.

**Voorbeeld:**
```javascript
// server.js
const express = require("express")
const next = require("next")

const dev = process.env.NODE_ENV !== "production"
const app = next({ dev })
const handle = app.getRequestHandler()

app.prepare().then(() => {
const server = express()

// Custom route
server.get("/a", (req, res) => {
return app.render(req, res, "/a")
})

// Default handler
server.all("*", (req, res) => {
return handle(req, res)
})

server.listen(3000, (err) => {
if (err) throw err
console.log("> Ready on http://localhost:3000")
})
})
```
---

## Bykomende argitektoniese en sekuriteits-oorwegings

### Omgewingsveranderlikes en Konfigurasie

**Doel:** Hantering van sensitiewe inligting en konfigurasie-instellings buite die kodebasis.

**Beste praktyke:**

- **Gebruik `.env`-lêers:** Berg veranderlikes soos API-sleutels in `.env.local` (uitgesluit van weergawebeheer).
- **Kry toegang tot veranderlikes op 'n veilige manier:** Gebruik `process.env.VARIABLE_NAME` om omgewingsveranderlikes te kry.
- **Moet nooit geheime aan die kliënt blootstel nie:** Verseker dat sensitiewe veranderlikes slegs aan die serverkant gebruik word.

**Voorbeeld:**
```javascript
// next.config.js
module.exports = {
env: {
API_KEY: process.env.API_KEY, // Accessible on both client and server
SECRET_KEY: process.env.SECRET_KEY, // Be cautious if accessible on the client
},
}
```
**Let wel:** Om veranderlikes slegs op die server-kant te beperk, laat hulle uit die `env`-object weg of voorsien die voorvoegsel `NEXT_PUBLIC_` vir kliëntblootstelling.

### Verifikasie en magtiging

**Benadering:**

- **Sessiegebaseerde verifikasie:** Gebruik cookies om gebruikersessies te bestuur.
- **Tokengebaseerde verifikasie:** Implementeer JWTs vir staatlose verifikasie.
- **Derdeparty-verskaffers:** Integreer met OAuth-verskaffers (bv., Google, GitHub) deur biblioteke soos `next-auth` te gebruik.

**Sekuriteitspraktyke:**

- **Veilige cookies:** Stel die `HttpOnly`, `Secure`, en `SameSite` eienskappe.
- **Wagwoord-hashing:** Hash altyd wagwoorde voordat jy dit stoor.
- **Invoervalidasie:** Voorkom injection attacks deur invoer te valideer en te ontsmet.

**Voorbeeld:**
```javascript
// pages/api/login.js
import { sign } from "jsonwebtoken"
import { serialize } from "cookie"

export default async function handler(req, res) {
const { username, password } = req.body

// Validate user credentials
if (username === "admin" && password === "password") {
const token = sign({ username }, process.env.JWT_SECRET, {
expiresIn: "1h",
})
res.setHeader(
"Set-Cookie",
serialize("auth", token, {
path: "/",
httpOnly: true,
secure: true,
sameSite: "strict",
})
)
res.status(200).json({ message: "Logged in" })
} else {
res.status(401).json({ error: "Invalid credentials" })
}
}
```
### Prestasie-optimalisering

**Strategieë:**

- **Image Optimization:** Gebruik Next.js se `next/image` component vir outomatiese beeldoptimalisering.
- **Code Splitting:** Maak gebruik van dynamic imports om kode te verdeel en die aanvanklike laaitye te verminder.
- **Caching:** Implementeer cachingstrategieë vir API-antwoorde en statiese assets.
- **Lazy Loading:** Laai komponente of assets slegs wanneer dit nodig is.

**Voorbeeld:**
```jsx
// Dynamic Import with Code Splitting
import dynamic from "next/dynamic"

const HeavyComponent = dynamic(() => import("../components/HeavyComponent"), {
loading: () => <p>Loading...</p>,
})
```
## Next.js Server Actions Enumeration (hash to function name via source maps)

Moderne Next.js gebruik “Server Actions” wat op die server uitgevoer word, maar vanaf die client aangeroep word. In produksie is hierdie aanroepe ondoorgrondelik: alle POSTs beland by 'n algemene endpoint en word onderskei deur 'n build-spesifieke hash wat in die `Next-Action` header gestuur word. Voorbeeld:
```http
POST /
Next-Action: a9f8e2b4c7d1...
```
Wanneer `productionBrowserSourceMaps` geaktiveer is, bevat geminifiseerde JS-chunks oproepe na `createServerReference(...)` wat leak genoeg struktuur (plus geassosieerde source maps) om 'n kartering tussen die action hash en die oorspronklike funksienaam te herstel. Dit laat jou toe om hashes wat in `Next-Action` waargeneem word te vertaal na konkrete teikens soos `deleteUserAccount()` of `exportFinancialData()`.

### Extraction approach (regex on minified JS + optional source maps)

Soek afgelaaide JS-chunks vir `createServerReference` en haal die hash en die funksie/bron-simbool uit. Twee nuttige patrone:
```regex
# Strict pattern for standard minification
createServerReference\)\"([a-f0-9]{40,})\",\w+\.callServer,void 0,\w+\.findSourceMapURL,\"([^\"]+)\"\)

# Flexible pattern handling various minification styles
createServerReference[^\"]*\"([a-f0-9]{40,})\"[^\"]*\"([^\"]+)\"\s*\)
```
- Groep 1: server action hash (40+ hex chars)
- Groep 2: simbool of pad wat, wanneer 'n source map teenwoordig is, na die oorspronklike funksienaam opgelos kan word

As die script 'n source map adverteer (trailer-kommentaar `//# sourceMappingURL=<...>.map`), haal dit af en los die simbool/pad op na die oorspronklike funksienaam.

### Praktiese werkvloei

- Passiewe ontdekking terwyl jy blaai: vang versoeke met `Next-Action` headers en JS chunk URLs.
- Haal die verwysde JS-bundels en die vergesellende `*.map`-lêers af (wanneer teenwoordig).
- Voer die regex hierbo uit om 'n hash↔name-woordeboek op te bou.
- Gebruik die woordeboek om toetsing te teiken:
  - Naam-gedrewe triage (bv., `transferFunds`, `exportFinancialData`).
  - Volg dekking oor builds deur funksienaam (hashes roteer oor builds).

### Oefen van verborge aksies (sjabloon-gebaseerde aanvraag)

Neem 'n geldige POST wat in-proxy waargeneem is as 'n sjabloon en vervang die `Next-Action`-waarde om 'n ander ontdekte aksie te teiken:
```http
# Before
Next-Action: a9f8e2b4c7d1

# After
Next-Action: b7e3f9a2d8c5
```
Herhaal in Repeater en toets authorization, input validation en business logic van andersins onbereikbare actions.

### Burp automatisering

- NextjsServerActionAnalyzer (Burp extension) automatiseer die bostaande in Burp:
- Gaan proxy history na vir JS chunks, onttrek `createServerReference(...)` inskrywings, en ontleed source maps waar beskikbaar.
- Onderhou 'n deursoekbare hash↔function-name woordeboek en verwyder duplikate oor builds volgens function name.
- Kan 'n geldige template POST opspoor en 'n gereed-om-te-stuur Repeater tab oopmaak met die teiken action’s hash vervang.
- Repo: https://github.com/Adversis/NextjsServerActionAnalyzer

### Aantekeninge en beperkings

- Vereis dat `productionBrowserSourceMaps` in production geaktiveer is om name uit bundles/source maps te herstel.
- Function-name disclosure is nie 'n vulnerability op sigself nie; gebruik dit om discovery te rig en toets elke action’s authorization.

## References

- [Pentesting Next.js Server Actions — A Burp Extension for Hash-to-Function Mapping](https://www.adversis.io/blogs/pentesting-next-js-server-actions)
- [NextjsServerActionAnalyzer (Burp extension)](https://github.com/Adversis/NextjsServerActionAnalyzer)

{{#include ../../banners/hacktricks-training.md}}
