# NextJS

{{#include ../../banners/hacktricks-training.md}}

## Arquitetura Geral de uma Aplicação Next.js

### Estrutura de Arquivos Típica

Um projeto Next.js padrão segue uma estrutura específica de arquivos e diretórios que facilita suas funcionalidades como roteamento, endpoints de API e gerenciamento de recursos estáticos. Aqui está uma disposição típica:
```lua
my-nextjs-app/
├── node_modules/
├── public/
│   ├── images/
│   │   └── logo.png
│   └── favicon.ico
├── app/
│   ├── api/
│   │   └── hello/
│   │       └── route.ts
│   ├── layout.tsx
│   ├── page.tsx
│   ├── about/
│   │   └── page.tsx
│   ├── dashboard/
│   │   ├── layout.tsx
│   │   └── page.tsx
│   ├── components/
│   │   ├── Header.tsx
│   │   └── Footer.tsx
│   ├── styles/
│   │   ├── globals.css
│   │   └── Home.module.css
│   └── utils/
│       └── api.ts
├── .env.local
├── next.config.js
├── tsconfig.json
├── package.json
├── README.md
└── yarn.lock / package-lock.json

```
### Core Directories and Files

- **public/:** Hospeda assets estáticos como imagens, fonts, e outros arquivos. Arquivos aqui são acessíveis no caminho raiz (`/`).
- **app/:** Diretório central para as páginas, layouts, components e API routes da sua aplicação. Adota o **App Router** paradigm, permitindo recursos avançados de roteamento e a segregação de componentes entre servidor e cliente.
- **app/layout.tsx:** Define o root layout da sua aplicação, envolvendo todas as páginas e fornecendo elementos de UI consistentes como headers, footers e barras de navegação.
- **app/page.tsx:** Serve como ponto de entrada para a root route `/`, renderizando a página inicial.
- **app/[route]/page.tsx:** Lida com rotas estáticas e dinâmicas. Cada pasta dentro de `app/` representa um segmento de rota, e `page.tsx` dentro dessas pastas corresponde ao componente da rota.
- **app/api/:** Contém API routes, permitindo criar serverless functions que processam requisições HTTP. Essas rotas substituem o tradicional diretório `pages/api`.
- **app/components/:** Abriga React components reutilizáveis que podem ser utilizados em diferentes páginas e layouts.
- **app/styles/:** Contém arquivos CSS globais e CSS Modules para estilização com escopo de componente.
- **app/utils/:** Inclui funções utilitárias, módulos helper e outra lógica não-UI que pode ser compartilhada pela aplicação.
- **.env.local:** Armazena variáveis de ambiente específicas do ambiente de desenvolvimento local. Essas variáveis **não** são incluídas no controle de versão.
- **next.config.js:** Personaliza o comportamento do Next.js, incluindo configurações do webpack, variáveis de ambiente e definições de segurança.
- **tsconfig.json:** Configura as opções do TypeScript para o projeto, habilitando verificação de tipos e outros recursos do TypeScript.
- **package.json:** Gerencia dependências do projeto, scripts e metadados.
- **README.md:** Fornece documentação e informações sobre o projeto, incluindo instruções de configuração, guias de uso e outros detalhes relevantes.
- **yarn.lock / package-lock.json:** Bloqueiam as dependências do projeto em versões específicas, garantindo instalações consistentes entre diferentes ambientes.

## Client-Side in Next.js

### File-Based Routing in the `app` Directory

The `app` directory is the cornerstone of routing in the latest Next.js versions. It leverages the filesystem to define routes, making route management intuitive and scalable.

<details>

<summary>Tratando o caminho raiz /</summary>

**Estrutura de arquivos:**
```arduino
my-nextjs-app/
├── app/
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Arquivos-chave:**

- **`app/page.tsx`**: Lida com requisições para o caminho raiz `/`.
- **`app/layout.tsx`**: Define o layout da aplicação, envolvendo todas as páginas.

**Implementação:**
```tsx
tsxCopy code// app/page.tsx

export default function HomePage() {
return (
<div>
<h1>Welcome to the Home Page!</h1>
<p>This is the root route.</p>
</div>
);
}
```
**Explicação:**

- **Definição da Rota:** O arquivo `page.tsx` diretamente dentro do diretório `app` corresponde à rota `/`.
- **Renderização:** Este componente renderiza o conteúdo da página inicial.
- **Integração com Layout:** O componente `HomePage` é envolvido por `layout.tsx`, que pode incluir cabeçalhos, rodapés e outros elementos comuns.

</details>

<details>

<summary>Tratando Outras Rotas Estáticas</summary>

**Exemplo: Rota `/about`**

**Estrutura de Arquivos:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── about/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementação:**
```tsx
// app/about/page.tsx

export default function AboutPage() {
return (
<div>
<h1>About Us</h1>
<p>Learn more about our mission and values.</p>
</div>
)
}
```
**Explicação:**

- **Definição de Rota:** O arquivo `page.tsx` dentro da pasta `about` corresponde à rota `/about`.
- **Renderização:** Este componente renderiza o conteúdo da página about.

</details>

<details>

<summary>Rotas Dinâmicas</summary>

Rotas dinâmicas permitem lidar com caminhos com segmentos variáveis, permitindo que aplicações exibam conteúdo com base em parâmetros como IDs, slugs, etc.

**Exemplo: Rota `/posts/[id]`**

**Estrutura de Arquivos:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── posts/
│   │   └── [id]/
│   │       └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementação:**
```tsx
tsxCopy code// app/posts/[id]/page.tsx

import { useRouter } from 'next/navigation';

interface PostProps {
params: { id: string };
}

export default function PostPage({ params }: PostProps) {
const { id } = params;
// Fetch post data based on 'id'

return (
<div>
<h1>Post #{id}</h1>
<p>This is the content of post {id}.</p>
</div>
);
}
```
**Explicação:**

- **Segmento Dinâmico:** `[id]` denota um segmento dinâmico na rota, capturando o parâmetro `id` da URL.
- **Acesso aos Parâmetros:** O objeto `params` contém os parâmetros dinâmicos, acessíveis dentro do componente.
- **Correspondência de Rotas:** Qualquer caminho que combine com `/posts/*`, como `/posts/1`, `/posts/abc`, etc., será tratado por este componente.

</details>

<details>

<summary>Rotas Aninhadas</summary>

Next.js suporta roteamento aninhado, permitindo estruturas de rotas hierárquicas que espelham a organização de diretórios.

**Exemplo: Rota `/dashboard/settings/profile`**

**Estrutura de Arquivos:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── dashboard/
│   │   ├── settings/
│   │   │   └── profile/
│   │   │       └── page.tsx
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementação:**
```tsx
tsxCopy code// app/dashboard/settings/profile/page.tsx

export default function ProfileSettingsPage() {
return (
<div>
<h1>Profile Settings</h1>
<p>Manage your profile information here.</p>
</div>
);
}
```
**Explicação:**

- **Aninhamento Profundo:** O arquivo `page.tsx` dentro de `dashboard/settings/profile/` corresponde à rota `/dashboard/settings/profile`.
- **Reflexo da Hierarquia:** A estrutura de diretórios reflete o caminho da URL, facilitando a manutenção e a clareza.

</details>

<details>

<summary>Rotas Catch-All</summary>

Rotas catch-all lidam com múltiplos segmentos aninhados ou caminhos desconhecidos, oferecendo flexibilidade no tratamento de rotas.

**Exemplo: Rota `/*`**

**Estrutura de Arquivos:**
```arduino
my-nextjs-app/
├── app/
│   ├── [..slug]/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementação:**
```tsx
// app/[...slug]/page.tsx

interface CatchAllProps {
params: { slug: string[] }
}

export default function CatchAllPage({ params }: CatchAllProps) {
const { slug } = params
const fullPath = `/${slug.join("/")}`

return (
<div>
<h1>Catch-All Route</h1>
<p>You have navigated to: {fullPath}</p>
</div>
)
}
```
**Explicação:**

- **Segmento Catch-All:** `[...slug]` captura todos os segmentos de caminho restantes como um array.
- **Uso:** Útil para lidar com cenários de roteamento dinâmico como paths gerados por usuários, categorias aninhadas, etc.
- **Correspondência de Rotas:** Caminhos como `/anything/here`, `/foo/bar/baz`, etc., são tratados por este componente.

</details>

### Potenciais Vulnerabilidades no Lado do Cliente

Embora o Next.js forneça uma base segura, práticas de codificação inadequadas podem introduzir vulnerabilidades. As principais vulnerabilidades no lado do cliente incluem:

<details>

<summary>Cross-Site Scripting (XSS)</summary>

Ataques XSS ocorrem quando scripts maliciosos são injetados em sites confiáveis. Os atacantes podem executar scripts nos navegadores dos usuários, roubando dados ou realizando ações em nome do usuário.

**Exemplo de Código Vulnerável:**
```jsx
// Dangerous: Injecting user input directly into HTML
function Comment({ userInput }) {
return <div dangerouslySetInnerHTML={{ __html: userInput }} />
}
```
**Por que é vulnerável:** Usar `dangerouslySetInnerHTML` com entrada não confiável permite que atacantes injetem scripts maliciosos.

</details>

<details>

<summary>Client-Side Template Injection</summary>

Ocorre quando entradas de usuário são tratadas incorretamente em templates, permitindo que atacantes injetem e executem templates ou expressões.

**Exemplo de Código Vulnerável:**
```jsx
import React from "react"
import ejs from "ejs"

function RenderTemplate({ template, data }) {
const html = ejs.render(template, data)
return <div dangerouslySetInnerHTML={{ __html: html }} />
}
```
**Por que é vulnerável:** Se `template` ou `data` incluir conteúdo malicioso, isso pode levar à execução de código não intencional.

</details>

<details>

<summary>Client Path Traversal</summary>

É uma vulnerabilidade que permite a atacantes manipular caminhos no lado do cliente para executar ações não intencionais, como Cross-Site Request Forgery (CSRF). Ao contrário do server-side path traversal, que ataca o sistema de arquivos do servidor, o CSPT se concentra em explorar mecanismos no lado do cliente para redirecionar requisições legítimas de API para endpoints maliciosos.

**Exemplo de Código Vulnerável:**

Uma aplicação Next.js permite que usuários façam upload e download de arquivos. O recurso de download é implementado no lado do cliente, onde os usuários podem especificar o caminho do arquivo para baixar.
```jsx
// pages/download.js
import { useState } from "react"

export default function DownloadPage() {
const [filePath, setFilePath] = useState("")

const handleDownload = () => {
fetch(`/api/files/${filePath}`)
.then((response) => response.blob())
.then((blob) => {
const url = window.URL.createObjectURL(blob)
const a = document.createElement("a")
a.href = url
a.download = filePath
a.click()
})
}

return (
<div>
<h1>Download File</h1>
<input
type="text"
value={filePath}
onChange={(e) => setFilePath(e.target.value)}
placeholder="Enter file path"
/>
<button onClick={handleDownload}>Download</button>
</div>
)
}
```
#### Cenário de Ataque

1. **Objetivo do atacante**: Realizar um ataque CSRF para excluir um arquivo crítico (por ex., `admin/config.json`) manipulando o `filePath`.
2. **Explorando CSPT**:
- **Entrada maliciosa**: O atacante cria uma URL com um `filePath` manipulado, como `../deleteFile/config.json`.
- **Chamada de API resultante**: O código do lado do cliente faz uma requisição para `/api/files/../deleteFile/config.json`.
- **Tratamento pelo servidor**: Se o servidor não validar o `filePath`, ele processa a requisição, potencialmente excluindo ou expondo arquivos sensíveis.
3. **Executando CSRF**:
- **Link forjado**: O atacante envia à vítima um link ou incorpora um script malicioso que dispara a requisição de download com o `filePath` manipulado.
- **Resultado**: A vítima executa a ação sem saber, levando a acesso ou exclusão não autorizada de arquivos.

#### Por que é vulnerável

- **Falta de validação de entrada**: O lado do cliente permite entradas arbitrárias `filePath`, possibilitando path traversal.
- **Confiança nas entradas do cliente**: A API do lado do servidor confia e processa o `filePath` sem sanitização.
- **Ações potenciais da API**: Se o endpoint da API executar ações que alteram o estado (por exemplo, excluir ou modificar arquivos), pode ser explorado via CSPT.

</details>

## Lado do Servidor no Next.js

### Renderização do Lado do Servidor (SSR)

As páginas são renderizadas no servidor a cada requisição, garantindo que o usuário receba HTML completamente renderizado. Nesse caso você deve criar seu próprio servidor customizado para processar as requisições.

**Casos de uso:**

- Conteúdo dinâmico que muda com frequência.
- Otimização de SEO, já que os motores de busca podem rastrear a página totalmente renderizada.

**Implementação:**
```jsx
// pages/index.js
export async function getServerSideProps(context) {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data } }
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### Geração Estática de Sites (SSG)

As páginas são pré-renderizadas em tempo de build, resultando em tempos de carregamento mais rápidos e redução da carga no servidor.

**Casos de Uso:**

- Conteúdo que não muda com frequência.
- Blogs, documentação, páginas de marketing.

**Implementação:**
```jsx
// pages/index.js
export async function getStaticProps() {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data }, revalidate: 60 } // Revalidate every 60 seconds
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### Funções Serverless (Rotas de API)

Next.js permite a criação de endpoints de API como funções serverless. Essas funções são executadas sob demanda sem a necessidade de um servidor dedicado.

**Casos de uso:**

- Tratamento de submissões de formulários.
- Interação com bancos de dados.
- Processamento de dados ou integração com APIs de terceiros.

**Implementação:**

Com a introdução do diretório `app` no Next.js 13, o roteamento e o tratamento de APIs se tornaram mais flexíveis e poderosos. Essa abordagem moderna se alinha estreitamente com o sistema de roteamento baseado em arquivos, mas introduz capacidades aprimoradas, incluindo suporte para componentes do servidor e do cliente.

#### Manipulador de Rota Básico

**File Structure:**
```go
my-nextjs-app/
├── app/
│   └── api/
│       └── hello/
│           └── route.js
├── package.json
└── ...
```
**Implementação:**
```javascript
// app/api/hello/route.js

export async function POST(request) {
return new Response(JSON.stringify({ message: "Hello from App Router!" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

// Client-side fetch to access the API endpoint
fetch("/api/submit", {
method: "POST",
headers: { "Content-Type": "application/json" },
body: JSON.stringify({ name: "John Doe" }),
})
.then((res) => res.json())
.then((data) => console.log(data))
```
**Explicação:**

- **Location:** API routes are placed under the `app/api/` directory.
- **File Naming:** Each API endpoint resides in its own folder containing a `route.js` or `route.ts` file.
- **Exported Functions:** Instead of a single default export, specific HTTP method functions (e.g., `GET`, `POST`) are exported.
- **Response Handling:** Use the `Response` constructor to return responses, allowing more control over headers and status codes.

#### Como lidar com outros paths e métodos:

<details>

<summary>Handling Specific HTTP Methods</summary>

Next.js 13+ allows you to define handlers for specific HTTP methods within the same `route.js` or `route.ts` file, promoting clearer and more organized code.

**Exemplo:**
```javascript
// app/api/users/[id]/route.js

export async function GET(request, { params }) {
const { id } = params
// Fetch user data based on 'id'
return new Response(JSON.stringify({ userId: id, name: "Jane Doe" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function PUT(request, { params }) {
const { id } = params
// Update user data based on 'id'
return new Response(JSON.stringify({ message: `User ${id} updated.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function DELETE(request, { params }) {
const { id } = params
// Delete user based on 'id'
return new Response(JSON.stringify({ message: `User ${id} deleted.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**Explicação:**

- **Múltiplas exportações:** Cada método HTTP (`GET`, `PUT`, `DELETE`) tem sua própria função exportada.
- **Parâmetros:** O segundo argumento fornece acesso aos parâmetros da rota via `params`.
- **Respostas aprimoradas:** Maior controle sobre os objetos de resposta, permitindo gerenciamento preciso de cabeçalhos e códigos de status.

</details>

<details>

<summary>Rotas Catch-All e Aninhadas</summary>

Next.js 13+ suporta recursos avançados de roteamento como rotas catch-all e rotas de API aninhadas, permitindo estruturas de API mais dinâmicas e escaláveis.

**Exemplo de Rota Catch-All:**
```javascript
// app/api/[...slug]/route.js

export async function GET(request, { params }) {
const { slug } = params
// Handle dynamic nested routes
return new Response(JSON.stringify({ slug }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**Explicação:**

- **Sintaxe:** `[...]` denota um segmento catch-all, capturando todos os caminhos aninhados.
- **Uso:** Útil para APIs que precisam lidar com profundidades de rota variadas ou segmentos dinâmicos.

**Exemplo de Rotas Aninhadas:**
```javascript
// app/api/posts/[postId]/comments/[commentId]/route.js

export async function GET(request, { params }) {
const { postId, commentId } = params
// Fetch specific comment for a post
return new Response(
JSON.stringify({ postId, commentId, comment: "Great post!" }),
{
status: 200,
headers: { "Content-Type": "application/json" },
}
)
}
```
**Explicação:**

- **Aninhamento profundo:** Permite estruturas de API hierárquicas, refletindo relacionamentos entre recursos.
- **Acesso a parâmetros:** Permite acessar facilmente múltiplos parâmetros de rota através do objeto `params`.

</details>

<details>

<summary>Tratando rotas de API no Next.js 12 e anteriores</summary>

## Rotas de API no diretório `pages` (Next.js 12 e anteriores)

Antes do Next.js 13 introduzir o diretório `app` e capacidades de roteamento aprimoradas, as rotas de API eram definidas principalmente dentro do diretório `pages`. Essa abordagem ainda é amplamente usada e suportada no Next.js 12 e em versões anteriores.

#### Rota de API básica

**Estrutura de arquivos:**
```go
goCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── hello.js
├── package.json
└── ...
```
**Implementação:**
```javascript
javascriptCopy code// pages/api/hello.js

export default function handler(req, res) {
res.status(200).json({ message: 'Hello, World!' });
}
```
**Explicação:**

- **Localização:** As rotas de API ficam sob o diretório `pages/api/`.
- **Exportação:** Use `export default` para definir a função handler.
- **Assinatura da Função:** O handler recebe os objetos `req` (requisição HTTP) e `res` (resposta HTTP).
- **Roteamento:** O nome do arquivo (`hello.js`) mapeia para o endpoint `/api/hello`.

#### Rotas de API Dinâmicas

**Estrutura de Arquivos:**
```bash
bashCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── users/
│           └── [id].js
├── package.json
└── ...
```
**Implementação:**
```javascript
javascriptCopy code// pages/api/users/[id].js

export default function handler(req, res) {
const {
query: { id },
method,
} = req;

switch (method) {
case 'GET':
// Fetch user data based on 'id'
res.status(200).json({ userId: id, name: 'John Doe' });
break;
case 'PUT':
// Update user data based on 'id'
res.status(200).json({ message: `User ${id} updated.` });
break;
case 'DELETE':
// Delete user based on 'id'
res.status(200).json({ message: `User ${id} deleted.` });
break;
default:
res.setHeader('Allow', ['GET', 'PUT', 'DELETE']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**Explicação:**

- **Segmentos Dinâmicos:** Colchetes (`[id].js`) indicam segmentos de rota dinâmicos.
- **Acessando Parâmetros:** Use `req.query.id` para acessar o parâmetro dinâmico.
- **Tratamento de Métodos:** Utilize lógica condicional para tratar diferentes métodos HTTP (`GET`, `PUT`, `DELETE`, etc.).

#### Tratando Diferentes Métodos HTTP

Embora o exemplo básico de rota de API trate todos os métodos HTTP dentro de uma única função, você pode estruturar seu código para tratar cada método explicitamente para maior clareza e manutenibilidade.

**Exemplo:**
```javascript
javascriptCopy code// pages/api/posts.js

export default async function handler(req, res) {
const { method } = req;

switch (method) {
case 'GET':
// Handle GET request
res.status(200).json({ message: 'Fetching posts.' });
break;
case 'POST':
// Handle POST request
res.status(201).json({ message: 'Post created.' });
break;
default:
res.setHeader('Allow', ['GET', 'POST']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**Melhores Práticas:**

- **Separação de Responsabilidades:** Separe claramente a lógica para diferentes métodos HTTP.
- **Consistência de Resposta:** Garanta estruturas de resposta consistentes para facilitar o tratamento no lado do cliente.
- **Tratamento de Erros:** Trate de forma adequada métodos não suportados e erros inesperados.

</details>

### Configuração de CORS

Controle quais origens podem acessar suas rotas de API, mitigando vulnerabilidades de Cross-Origin Resource Sharing (CORS).

**Exemplo de Configuração Ruim:**
```javascript
// app/api/data/route.js

export async function GET(request) {
return new Response(JSON.stringify({ data: "Public Data" }), {
status: 200,
headers: {
"Access-Control-Allow-Origin": "*", // Allows any origin
"Access-Control-Allow-Methods": "GET, POST, PUT, DELETE",
},
})
}
```
Observe que **o CORS também pode ser configurado em todas as rotas de API** dentro do arquivo **`middleware.ts`**:
```javascript
// app/middleware.ts

import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(request: NextRequest) {
const allowedOrigins = [
"https://yourdomain.com",
"https://sub.yourdomain.com",
]
const origin = request.headers.get("Origin")

const response = NextResponse.next()

if (allowedOrigins.includes(origin || "")) {
response.headers.set("Access-Control-Allow-Origin", origin || "")
response.headers.set(
"Access-Control-Allow-Methods",
"GET, POST, PUT, DELETE, OPTIONS"
)
response.headers.set(
"Access-Control-Allow-Headers",
"Content-Type, Authorization"
)
// If credentials are needed:
// response.headers.set('Access-Control-Allow-Credentials', 'true');
}

// Handle preflight requests
if (request.method === "OPTIONS") {
return new Response(null, {
status: 204,
headers: response.headers,
})
}

return response
}

export const config = {
matcher: "/api/:path*", // Apply to all API routes
}
```
**Problema:**

- **`Access-Control-Allow-Origin: '*'`:** Permite que qualquer site acesse a API, potencialmente permitindo que sites maliciosos interajam com sua API sem restrições.
- **Permissão ampla de métodos:** Permitir todos os métodos pode permitir que atacantes realizem ações indesejadas.

**Como atacantes exploram isso:**

Atacantes podem criar sites maliciosos que fazem requisições para sua API, potencialmente abusando de funcionalidades como recuperação de dados, manipulação de dados ou acionando ações indesejadas em nome de usuários autenticados.


{{#ref}}
../../pentesting-web/cors-bypass.md
{{#endref}}

### Exposição de código do servidor no lado do cliente

Pode ser fácil **usar código do servidor também em código exposto e executado no lado do cliente**, a melhor forma de garantir que um arquivo de código nunca seja exposto no lado do cliente é usando este import no início do arquivo:
```js
import "server-only"
```
## Arquivos-chave e suas funções

### `middleware.ts` / `middleware.js`

**Localização:** Raiz do projeto ou dentro de `src/`.

**Finalidade:** Executa código na função serverless do lado do servidor antes que uma requisição seja processada, permitindo tarefas como autenticação, redirecionamentos ou modificação de respostas.

**Fluxo de execução:**

1. **Requisição de entrada:** O middleware intercepta a requisição.
2. **Processamento:** Executa operações com base na requisição (por exemplo, verificar autenticação).
3. **Modificação da resposta:** Pode alterar a resposta ou passar o controle para o próximo handler.

**Exemplos de uso:**

- Redirecionar usuários não autenticados.
- Adicionar cabeçalhos personalizados.
- Registrar requisições.

**Exemplo de configuração:**
```typescript
// middleware.ts
import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(req: NextRequest) {
const url = req.nextUrl.clone()
if (!req.cookies.has("token")) {
url.pathname = "/login"
return NextResponse.redirect(url)
}
return NextResponse.next()
}

export const config = {
matcher: ["/protected/:path*"],
}
```
### `next.config.js`

**Localização:** Raiz do projeto.

**Finalidade:** Configura o comportamento do Next.js, habilitando ou desabilitando recursos, personalizando configurações do webpack, definindo variáveis de ambiente e configurando várias funcionalidades de segurança.

**Principais Configurações de Segurança:**

<details>

<summary>Cabeçalhos de Segurança</summary>

Cabeçalhos de segurança aumentam a proteção da sua aplicação ao instruir os navegadores sobre como lidar com o conteúdo. Eles ajudam a mitigar vários ataques como Cross-Site Scripting (XSS), Clickjacking e sniffing de tipo MIME:

- Content Security Policy (CSP)
- X-Frame-Options
- X-Content-Type-Options
- Strict-Transport-Security (HSTS)
- Referrer Policy

**Exemplos:**
```javascript
// next.config.js

module.exports = {
async headers() {
return [
{
source: "/(.*)", // Apply to all routes
headers: [
{
key: "X-Frame-Options",
value: "DENY",
},
{
key: "Content-Security-Policy",
value:
"default-src *; script-src 'self' 'unsafe-inline' 'unsafe-eval';",
},
{
key: "X-Content-Type-Options",
value: "nosniff",
},
{
key: "Strict-Transport-Security",
value: "max-age=63072000; includeSubDomains; preload", // Enforces HTTPS
},
{
key: "Referrer-Policy",
value: "no-referrer", // Completely hides referrer
},
// Additional headers...
],
},
]
},
}
```
</details>

<details>

<summary>Configurações de Otimização de Imagens</summary>

Next.js otimiza imagens para performance, mas configurações incorretas podem levar a vulnerabilidades de segurança, como permitir que fontes não confiáveis injetem conteúdo malicioso.

**Exemplo de Configuração Ruim:**
```javascript
// next.config.js

module.exports = {
images: {
domains: ["*"], // Allows images from any domain
},
}
```
**Problema:**

- **`'*'`:** Permite que imagens sejam carregadas de qualquer fonte externa, incluindo domínios não confiáveis ou maliciosos. Atacantes podem hospedar imagens contendo payloads maliciosos ou conteúdo que engana os usuários.
- Outro problema pode ser permitir um domínio **onde qualquer pessoa pode fazer upload de uma imagem** (como `raw.githubusercontent.com`)

**Como atacantes abusam disso:**

Ao injetar imagens de fontes maliciosas, atacantes podem realizar ataques de phishing, exibir informações enganosas ou explorar vulnerabilidades em bibliotecas de renderização de imagens.

</details>

<details>

<summary>Exposição de Variáveis de Ambiente</summary>

Gerencie informações sensíveis como chaves de API e credenciais de banco de dados de forma segura sem expô-las ao cliente.

#### a. Expondo Variáveis Sensíveis

**Exemplo de Configuração Ruim:**
```javascript
// next.config.js

module.exports = {
env: {
SECRET_API_KEY: process.env.SECRET_API_KEY, // Exposed to the client
NEXT_PUBLIC_API_URL: process.env.NEXT_PUBLIC_API_URL, // Correctly prefixed for client
},
}
```
**Problem:**

- **`SECRET_API_KEY`:** Sem o prefixo `NEXT_PUBLIC_`, o Next.js não expõe variáveis para o cliente. Porém, se for prefixado por engano (ex.: `NEXT_PUBLIC_SECRET_API_KEY`), torna-se acessível do lado do cliente.

**How attackers abuse it:**

Se variáveis sensíveis forem expostas ao cliente, atacantes podem recuperá-las inspecionando o código do cliente ou requisições de rede, obtendo acesso não autorizado a APIs, bancos de dados ou outros serviços.

</details>

<details>

<summary>Redirecionamentos</summary>

Gerencie redirecionamentos e reescritas de URL dentro da sua aplicação, garantindo que os usuários sejam direcionados adequadamente sem introduzir open redirect vulnerabilities.

#### a. Open Redirect Vulnerability

**Bad Configuration Example:**
```javascript
// next.config.js

module.exports = {
async redirects() {
return [
{
source: "/redirect",
destination: (req) => req.query.url, // Dynamically redirects based on query parameter
permanent: false,
},
]
},
}
```
**Problema:**

- **Destino dinâmico:** Permite que usuários especifiquem qualquer URL, possibilitando ataques de open redirect.
- **Confiar na entrada do usuário:** Redirecionamentos para URLs fornecidas pelos usuários sem validação podem levar a phishing, distribuição de malware ou roubo de credenciais.

**Como atacantes abusam disso:**

Atacantes podem criar URLs que parecem originar-se do seu domínio, mas redirecionam usuários para sites maliciosos. Por exemplo:
```bash
https://yourdomain.com/redirect?url=https://malicious-site.com
```
Usuários que confiam no domínio original podem, sem saber, navegar para sites maliciosos.

</details>

<details>

<summary>Configuração do Webpack</summary>

Personalize as configurações do Webpack para sua aplicação Next.js, o que pode involuntariamente introduzir vulnerabilidades de segurança se não for tratado com cautela.

#### a. Expondo Módulos Sensíveis

**Exemplo de má configuração:**
```javascript
// next.config.js

module.exports = {
webpack: (config, { isServer }) => {
if (!isServer) {
config.resolve.alias["@sensitive"] = path.join(__dirname, "secret-folder")
}
return config
},
}
```
**Problema:**

- **Expondo caminhos sensíveis:** Criar alias de diretórios sensíveis e permitir acesso do lado do cliente pode leak informações confidenciais.
- **Empacotamento de segredos:** Se arquivos sensíveis forem empacotados para o cliente, seus conteúdos tornam-se acessíveis através de source maps ou inspecionando o código do lado do cliente.

**Como atacantes exploram isso:**

Atacantes podem acessar ou reconstruir a estrutura de diretórios da aplicação, potencialmente encontrando e explorando arquivos ou dados sensíveis.

</details>

### `pages/_app.js` and `pages/_document.js`

#### **`pages/_app.js`**

**Propósito:** Substitui o componente App padrão, permitindo estado global, estilos e componentes de layout.

**Casos de uso:**

- Injetar CSS global.
- Adicionar wrappers de layout.
- Integrar bibliotecas de gerenciamento de estado.

**Exemplo:**
```jsx
// pages/_app.js
import "../styles/globals.css"

function MyApp({ Component, pageProps }) {
return <Component {...pageProps} />
}

export default MyApp
```
#### **`pages/_document.js`**

**Propósito:** Substitui o Document padrão, permitindo a personalização das tags HTML e Body.

**Casos de uso:**

- Modificar as tags `<html>` ou `<body>`.
- Adicionar meta tags ou scripts personalizados.
- Integrar fontes de terceiros.

**Exemplo:**
```jsx
// pages/_document.js
import Document, { Html, Head, Main, NextScript } from "next/document"

class MyDocument extends Document {
render() {
return (
<Html lang="en">
<Head>{/* Custom fonts or meta tags */}</Head>
<body>
<Main />
<NextScript />
</body>
</Html>
)
}
}

export default MyDocument
```
### Servidor Personalizado (Opcional)

**Finalidade:** Embora o Next.js venha com um servidor embutido, você pode criar um servidor personalizado para casos de uso avançados, como roteamento customizado ou integração com serviços backend existentes.

**Observação:** Usar um servidor personalizado pode limitar as opções de implantação, especialmente em plataformas como Vercel que otimizam para o servidor embutido do Next.js.

**Exemplo:**
```javascript
// server.js
const express = require("express")
const next = require("next")

const dev = process.env.NODE_ENV !== "production"
const app = next({ dev })
const handle = app.getRequestHandler()

app.prepare().then(() => {
const server = express()

// Custom route
server.get("/a", (req, res) => {
return app.render(req, res, "/a")
})

// Default handler
server.all("*", (req, res) => {
return handle(req, res)
})

server.listen(3000, (err) => {
if (err) throw err
console.log("> Ready on http://localhost:3000")
})
})
```
---

## Considerações Arquitetônicas e de Segurança Adicionais

### Variáveis de Ambiente e Configuração

**Objetivo:** Gerenciar informações sensíveis e configurações fora do código-fonte.

**Melhores Práticas:**

- **Use arquivos `.env`**: Armazene variáveis como chaves de API em `.env.local` (excluído do controle de versão).
- **Acesse as Variáveis com Segurança:** Use `process.env.VARIABLE_NAME` para acessar variáveis de ambiente.
- **Nunca Exponha Segredos no Cliente:** Garanta que variáveis sensíveis sejam usadas apenas no servidor.

**Exemplo:**
```javascript
// next.config.js
module.exports = {
env: {
API_KEY: process.env.API_KEY, // Accessible on both client and server
SECRET_KEY: process.env.SECRET_KEY, // Be cautious if accessible on the client
},
}
```
**Nota:** Para restringir variáveis apenas ao lado do servidor, omita-as do objeto `env` ou prefixá-las com `NEXT_PUBLIC_` para exposição ao cliente.

### Autenticação e Autorização

**Abordagem:**

- **Autenticação baseada em sessão:** Use cookies para gerenciar sessões de usuário.
- **Autenticação baseada em token:** Implemente JWTs para autenticação stateless.
- **Provedores de terceiros:** Integre com provedores OAuth (por exemplo, Google, GitHub) usando bibliotecas como `next-auth`.

**Práticas de segurança:**

- **Cookies seguros:** Defina os atributos `HttpOnly`, `Secure` e `SameSite`.
- **Hash de senhas:** Sempre faça hash das senhas antes de armazená-las.
- **Validação de entrada:** Previna ataques de injeção validando e sanitizando as entradas.

**Exemplo:**
```javascript
// pages/api/login.js
import { sign } from "jsonwebtoken"
import { serialize } from "cookie"

export default async function handler(req, res) {
const { username, password } = req.body

// Validate user credentials
if (username === "admin" && password === "password") {
const token = sign({ username }, process.env.JWT_SECRET, {
expiresIn: "1h",
})
res.setHeader(
"Set-Cookie",
serialize("auth", token, {
path: "/",
httpOnly: true,
secure: true,
sameSite: "strict",
})
)
res.status(200).json({ message: "Logged in" })
} else {
res.status(401).json({ error: "Invalid credentials" })
}
}
```
### Otimização de Desempenho

**Estratégias:**

- **Otimização de Imagens:** Use o componente `next/image` do Next.js para otimização automática de imagens.
- **Divisão de Código:** Aproveite importações dinâmicas para dividir o código e reduzir o tempo de carregamento inicial.
- **Cache:** Implemente estratégias de cache para respostas de API e ativos estáticos.
- **Carregamento sob demanda:** Carregue componentes ou ativos somente quando eles forem necessários.

**Exemplo:**
```jsx
// Dynamic Import with Code Splitting
import dynamic from "next/dynamic"

const HeavyComponent = dynamic(() => import("../components/HeavyComponent"), {
loading: () => <p>Loading...</p>,
})
```
## Next.js Server Actions Enumeration (hash to function name via source maps)

O Next.js moderno usa “Server Actions” que são executadas no servidor mas são invocadas a partir do cliente. Em produção essas invocações são opacas: todos os POSTs chegam a um endpoint comum e são distinguidos por um hash específico da build enviado no cabeçalho `Next-Action`. Exemplo:
```http
POST /
Next-Action: a9f8e2b4c7d1...
```
Quando `productionBrowserSourceMaps` está habilitado, minified JS chunks contêm chamadas para `createServerReference(...)` que leak estrutura suficiente (mais os source maps associados) para recuperar um mapeamento entre o action hash e o nome da função original. Isso permite que você traduza hashes observados em `Next-Action` para alvos concretos como `deleteUserAccount()` ou `exportFinancialData()`.

### Abordagem de extração (regex on minified JS + optional source maps)

Procure nos JS chunks baixados por `createServerReference` e extraia o hash e o símbolo da função/fonte. Dois padrões úteis:
```regex
# Strict pattern for standard minification
createServerReference\)\"([a-f0-9]{40,})\",\w+\.callServer,void 0,\w+\.findSourceMapURL,\"([^\"]+)\"\)

# Flexible pattern handling various minification styles
createServerReference[^\"]*\"([a-f0-9]{40,})\"[^\"]*\"([^\"]+)\"\s*\)
```
- Grupo 1: server action hash (40+ hex chars)
- Grupo 2: símbolo ou caminho que pode ser resolvido para a função original via source map quando presente

Se o script anuncia um source map (comentário final `//# sourceMappingURL=<...>.map`), obtenha-o e resolva o símbolo/caminho para o nome original da função.

### Fluxo de trabalho prático

- Descoberta passiva durante a navegação: capture requests com cabeçalhos `Next-Action` e JS chunk URLs.
- Obtenha os bundles JS referenciados e os arquivos `*.map` acompanhantes (quando presentes).
- Execute a regex acima para construir um dicionário hash↔name.
- Use o dicionário para direcionar os testes:
  - Triagem dirigida por nome (ex.: `transferFunds`, `exportFinancialData`).
  - Acompanhe a cobertura entre builds pelo nome da função (hashes rotacionam entre builds).

### Exercitando ações ocultas (requisição baseada em template)

Pegue um POST válido observado no proxy como modelo e troque o valor `Next-Action` para direcionar outra action descoberta:
```http
# Before
Next-Action: a9f8e2b4c7d1

# After
Next-Action: b7e3f9a2d8c5
```
Replay in Repeater and teste autorização, validação de input e lógica de negócio de ações que seriam inacessíveis de outra forma.

### Burp automation

- NextjsServerActionAnalyzer (Burp extension) automatiza o acima no Burp:
- Varre o histórico do proxy por JS chunks, extrai entradas `createServerReference(...)` e analisa source maps quando disponíveis.
- Mantém um dicionário pesquisável hash↔function-name e remove duplicatas entre builds por function name.
- Pode localizar um POST de template válido e abrir uma aba do Repeater pronta para envio com o hash da ação alvo substituído.
- Repo: https://github.com/Adversis/NextjsServerActionAnalyzer

### Notes and limitations

- Requer `productionBrowserSourceMaps` ativado em produção para recuperar nomes de bundles/source maps.
- Function-name disclosure não é uma vulnerabilidade por si só; use-a para guiar a descoberta e testar a autorização de cada ação.

## References

- [Pentesting Next.js Server Actions — A Burp Extension for Hash-to-Function Mapping](https://www.adversis.io/blogs/pentesting-next-js-server-actions)
- [NextjsServerActionAnalyzer (Burp extension)](https://github.com/Adversis/NextjsServerActionAnalyzer)

{{#include ../../banners/hacktricks-training.md}}
