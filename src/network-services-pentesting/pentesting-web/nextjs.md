# NextJS

{{#include ../../banners/hacktricks-training.md}}

## Opšta arhitektura Next.js aplikacije

### Tipična struktura fajlova

Standardni Next.js projekat prati specifičnu strukturu fajlova i direktorijuma koja olakšava njegove funkcije kao što su rutiranje, API endpoints i upravljanje statičkim resursima. Evo tipičnog rasporeda:
```lua
my-nextjs-app/
├── node_modules/
├── public/
│   ├── images/
│   │   └── logo.png
│   └── favicon.ico
├── app/
│   ├── api/
│   │   └── hello/
│   │       └── route.ts
│   ├── layout.tsx
│   ├── page.tsx
│   ├── about/
│   │   └── page.tsx
│   ├── dashboard/
│   │   ├── layout.tsx
│   │   └── page.tsx
│   ├── components/
│   │   ├── Header.tsx
│   │   └── Footer.tsx
│   ├── styles/
│   │   ├── globals.css
│   │   └── Home.module.css
│   └── utils/
│       └── api.ts
├── .env.local
├── next.config.js
├── tsconfig.json
├── package.json
├── README.md
└── yarn.lock / package-lock.json

```
### Osnovni direktorijumi i fajlovi

- **public/:** Hostuje statične resurse kao što su slike, fontovi i drugi fajlovi. Fajlovi ovde su dostupni na korenskoj putanji (`/`).
- **app/:** Centralni direktorijum za stranice aplikacije, layoute, komponente i API rute. Usvaja **App Router** paradigm, omogućavajući napredne mogućnosti rutiranja i razdvajanje server-client komponenti.
- **app/layout.tsx:** Definiše root layout vaše aplikacije, obavijajući sve stranice i obezbeđujući konzistentne UI elemente poput headera, footera i navigacionih traka.
- **app/page.tsx:** Služi kao ulazna tačka za root rutu `/`, renderujući početnu stranicu.
- **app/[route]/page.tsx:** Rukuje statičkim i dinamičkim rutama. Svaka fascikla unutar `app/` predstavlja segment rute, a `page.tsx` unutar tih fascikli odgovara komponenti rute.
- **app/api/:** Sadrži API rute, omogućavajući kreiranje serverless funkcija koje obrađuju HTTP zahteve. Ove rute zamenjuju tradicionalni `pages/api` direktorijum.
- **app/components/:** Smešta ponovo upotrebljive React komponente koje se mogu koristiti na različitim stranicama i u layoutima.
- **app/styles/:** Sadrži globalne CSS fajlove i CSS Modules za stilizovanje ograničeno na komponente.
- **app/utils/:** Uključuje utility funkcije, pomoćne module i drugu ne-UI logiku koja se može deliti kroz aplikaciju.
- **.env.local:** Čuva environment variabls specifične za lokalno razvojno okruženje. Ove varijable se **ne** commituju u verzioni kontrolni sistem.
- **next.config.js:** Prilagođava ponašanje Next.js-a, uključujući webpack konfiguracije, environment variabls i sigurnosna podešavanja.
- **tsconfig.json:** Konfiguriše TypeScript podešavanja za projekat, omogućavajući proveru tipova i druge TypeScript funkcionalnosti.
- **package.json:** Upravljа zavisnostima projekta, skriptama i metapodacima.
- **README.md:** Pruža dokumentaciju i informacije o projektu, uključujući instrukcije za postavljanje, smernice za korišćenje i druge relevantne detalje.
- **yarn.lock / package-lock.json:** Zaključavaju zavisnosti projekta na specifične verzije, obezbeđujući konzistentne instalacije u različitim okruženjima.

## Klijentska strana u Next.js

### Routiranje zasnovano na fajlovima u direktorijumu `app`

Direktorijum `app` je kamen temeljac rutiranja u najnovijim verzijama Next.js-a. On koristi fajl-sistem za definisanje ruta, čineći upravljanje rutama intuitivnim i skalabilnim.

<details>

<summary>Rukovanje korenskom putanjom /</summary>

**File Structure:**
```arduino
my-nextjs-app/
├── app/
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Ključne datoteke:**

- **`app/page.tsx`**: Obrađuje zahteve za korensku putanju `/`.
- **`app/layout.tsx`**: Definiše izgled aplikacije, obuhvatajući sve stranice.

**Implementacija:**
```tsx
tsxCopy code// app/page.tsx

export default function HomePage() {
return (
<div>
<h1>Welcome to the Home Page!</h1>
<p>This is the root route.</p>
</div>
);
}
```
**Objašnjenje:**

- **Definicija rute:** Fajl `page.tsx` koji se nalazi direktno u direktorijumu `app` odgovara ruti `/`.
- **Renderovanje:** Ova komponenta prikazuje sadržaj početne stranice.
- **Integracija layout-a:** Komponenta `HomePage` se nalazi unutar `layout.tsx`, koji može da sadrži zaglavlja, podnožja i druge uobičajene elemente.

</details>

<details>

<summary>Rukovanje drugim statičkim putanjama</summary>

**Primer: ruta `/about`**

**Struktura fajlova:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── about/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementacija:**
```tsx
// app/about/page.tsx

export default function AboutPage() {
return (
<div>
<h1>About Us</h1>
<p>Learn more about our mission and values.</p>
</div>
)
}
```
**Objašnjenje:**

- **Definicija rute:** Datoteka `page.tsx` unutar foldera `about` odgovara ruti `/about`.
- **Prikazivanje:** Ova komponenta prikazuje sadržaj za stranicu /about.

</details>

<details>

<summary>Dinamičke rute</summary>

Dinamičke rute omogućavaju rukovanje putanjama sa promenljivim segmentima, što omogućava aplikacijama da prikazuju sadržaj na osnovu parametara kao što su ID-ovi, slugovi itd.

**Primer: ruta `/posts/[id]`**

**Struktura fajlova:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── posts/
│   │   └── [id]/
│   │       └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementacija:**
```tsx
tsxCopy code// app/posts/[id]/page.tsx

import { useRouter } from 'next/navigation';

interface PostProps {
params: { id: string };
}

export default function PostPage({ params }: PostProps) {
const { id } = params;
// Fetch post data based on 'id'

return (
<div>
<h1>Post #{id}</h1>
<p>This is the content of post {id}.</p>
</div>
);
}
```
**Objašnjenje:**

- **Dinamički segment:** `[id]` označava dinamički segment u ruti, hvatajući `id` parametar iz URL-a.
- **Pristup parametrima:** Objekat `params` sadrži dinamičke parametre, dostupne unutar komponente.
- **Poklapanje rute:** Bilo koja putanja koja odgovara `/posts/*`, poput `/posts/1`, `/posts/abc`, itd., biće obrađena od strane ove komponente.

</details>

<details>

<summary>Ugnježdene rute</summary>

Next.js podržava ugnježdene rute, omogućavajući hijerarhijsku strukturu ruta koja odražava raspored direktorijuma.

**Primer: `/dashboard/settings/profile` ruta**

**Struktura fajlova:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── dashboard/
│   │   ├── settings/
│   │   │   └── profile/
│   │   │       └── page.tsx
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementacija:**
```tsx
tsxCopy code// app/dashboard/settings/profile/page.tsx

export default function ProfileSettingsPage() {
return (
<div>
<h1>Profile Settings</h1>
<p>Manage your profile information here.</p>
</div>
);
}
```
**Objašnjenje:**

- **Duboko ugnježđivanje:** Fajl `page.tsx` unutar `dashboard/settings/profile/` odgovara ruti `/dashboard/settings/profile`.
- **Odraz hijerarhije:** Struktura direktorijuma odražava URL putanju, poboljšavajući održavanje i jasnoću.

</details>

<details>

<summary>Catch-All rute</summary>

Catch-all rute obrađuju više ugnježdenih segmenata ili nepoznate putanje, pružajući fleksibilnost u rukovanju rutama.

**Primer: `/*` ruta**

**Struktura fajlova:**
```arduino
my-nextjs-app/
├── app/
│   ├── [...slug]/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementacija:**
```tsx
// app/[...slug]/page.tsx

interface CatchAllProps {
params: { slug: string[] }
}

export default function CatchAllPage({ params }: CatchAllProps) {
const { slug } = params
const fullPath = `/${slug.join("/")}`

return (
<div>
<h1>Catch-All Route</h1>
<p>You have navigated to: {fullPath}</p>
</div>
)
}
```
**Objašnjenje:**

- **Catch-All Segment:** `[...slug]` hvata sve preostale segmente puta kao niz.
- **Upotreba:** Koristan za rukovanje dinamičkim routing scenarijima kao što su putevi koje kreiraju korisnici, ugneždene kategorije itd.
- **Uparivanje ruta:** Rute poput `/anything/here`, `/foo/bar/baz` itd. obrađuje ova komponenta.

</details>

### Potencijalne ranjivosti na strani klijenta

Iako Next.js pruža sigurnu osnovu, nepravilne prakse kodiranja mogu uvesti ranjivosti. Ključne ranjivosti na strani klijenta uključuju:

<details>

<summary>Cross-Site Scripting (XSS)</summary>

XSS napadi se dešavaju kada se zlonamerni skripti ubace u pouzdane veb-stranice. Napadači mogu izvršavati skripte u pregledačima korisnika, krasti podatke ili izvoditi radnje u ime korisnika.

**Primer ranjivog koda:**
```jsx
// Dangerous: Injecting user input directly into HTML
function Comment({ userInput }) {
return <div dangerouslySetInnerHTML={{ __html: userInput }} />
}
```
**Zašto je ranjivo:** Korišćenje `dangerouslySetInnerHTML` sa nepouzdanim unosom omogućava napadačima da ubace zlonamerne skripte.

</details>

<details>

<summary>Client-Side Template Injection</summary>

Javlja se kada se korisnički unosi nepravilno obrađuju u šablonima, omogućavajući napadačima da ubace i izvrše šablone ili izraze.

**Primer ranjivog koda:**
```jsx
import React from "react"
import ejs from "ejs"

function RenderTemplate({ template, data }) {
const html = ejs.render(template, data)
return <div dangerouslySetInnerHTML={{ __html: html }} />
}
```
**Zašto je ranjivo:** Ako `template` ili `data` sadrže zlonamerni sadržaj, to može dovesti do izvršavanja neželjenog koda.

</details>

<details>

<summary>Client Path Traversal</summary>

To je ranjivost koja omogućava napadačima da manipulišu putanjama na strani klijenta kako bi izvršili neželjene radnje, kao što je Cross-Site Request Forgery (CSRF). Za razliku od server-side path traversal, koja cilja fajl sistem servera, CSPT se fokusira na iskorišćavanje mehanizama na strani klijenta kako bi preusmerio legitimne API zahteve na zlonamerne krajnje tačke.

**Primer ranjivog koda:**  

Next.js aplikacija omogućava korisnicima da otpremaju i preuzimaju fajlove. Funkcija preuzimanja je implementirana na strani klijenta, gde korisnici mogu da navedu putanju fajla za preuzimanje.
```jsx
// pages/download.js
import { useState } from "react"

export default function DownloadPage() {
const [filePath, setFilePath] = useState("")

const handleDownload = () => {
fetch(`/api/files/${filePath}`)
.then((response) => response.blob())
.then((blob) => {
const url = window.URL.createObjectURL(blob)
const a = document.createElement("a")
a.href = url
a.download = filePath
a.click()
})
}

return (
<div>
<h1>Download File</h1>
<input
type="text"
value={filePath}
onChange={(e) => setFilePath(e.target.value)}
placeholder="Enter file path"
/>
<button onClick={handleDownload}>Download</button>
</div>
)
}
```
#### Scenarij napada

1. **Cilj napadača**: Izvesti CSRF napad da obriše kritičan fajl (npr. `admin/config.json`) manipulišući `filePath`.
2. **Eksploatisanje CSPT**:
- **Zlonameran unos**: Napadač kreira URL sa manipulisanim `filePath` kao što je `../deleteFile/config.json`.
- **Rezultujući API poziv**: Kod na strani klijenta pravi zahtev na `/api/files/../deleteFile/config.json`.
- **Rukovanje na serveru**: Ako server ne validira `filePath`, procesira zahtev, potencijalno brišući ili otkrivajući osetljive fajlove.
3. **Izvođenje CSRF-a**:
- **Pripremljeni link**: Napadač pošalje žrtvi link ili ubaci zlonamerni skript koji pokreće zahtev za preuzimanje sa manipulisanim `filePath`.
- **Ishod**: Žrtva nesvesno izvršava akciju, što dovodi do neautorizovanog pristupa fajlovima ili brisanja.

</details>

## Server-Side u Next.js

### Server-side renderovanje (SSR)

Stranice se renderuju na serveru pri svakom zahtevu, osiguravajući da korisnik dobije potpuno renderovan HTML. U tom slučaju treba da kreirate sopstveni prilagođeni server za obradu zahteva.

**Slučajevi upotrebe:**

- Dinamički sadržaj koji se često menja.
- Optimizacija za SEO, jer pretraživači mogu indeksirati potpuno renderovanu stranicu.

**Implementacija:**
```jsx
// pages/index.js
export async function getServerSideProps(context) {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data } }
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### Generisanje statičkih sajtova (SSG)

Stranice se prerenderuju tokom build faze, što rezultuje bržim vremenom učitavanja i smanjenim opterećenjem servera.

**Slučajevi upotrebe:**

- Sadržaj koji se ne menja često.
- Blogovi, dokumentacija, marketinške stranice.

**Implementacija:**
```jsx
// pages/index.js
export async function getStaticProps() {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data }, revalidate: 60 } // Revalidate every 60 seconds
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### Serverless Functions (API Routes)

Next.js omogućava kreiranje API endpoint-a kao serverless funkcije. Ove funkcije se izvršavaju na zahtev bez potrebe za posvećenim serverom.

**Use Cases:**

- Rukovanje slanjem obrazaca.
- Interakcija sa bazama podataka.
- Obrada podataka ili integracija sa API-ima trećih strana.

**Implementation:**

Sa uvođenjem `app` directory u Next.js 13, rutiranje i rukovanje API-ima su postali fleksibilniji i moćniji. Ovaj moderni pristup se usko poklapa sa file-based routing system ali uvodi unapređene mogućnosti, uključujući podršku za server i client komponente.

#### Basic Route Handler

**File Structure:**
```go
my-nextjs-app/
├── app/
│   └── api/
│       └── hello/
│           └── route.js
├── package.json
└── ...
```
**Implementacija:**
```javascript
// app/api/hello/route.js

export async function POST(request) {
return new Response(JSON.stringify({ message: "Hello from App Router!" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

// Client-side fetch to access the API endpoint
fetch("/api/submit", {
method: "POST",
headers: { "Content-Type": "application/json" },
body: JSON.stringify({ name: "John Doe" }),
})
.then((res) => res.json())
.then((data) => console.log(data))
```
**Objašnjenje:**

- **Lokacija:** API rute se nalaze u direktorijumu `app/api/`.
- **Naziv fajlova:** Svaki API endpoint se nalazi u sopstvenom folderu koji sadrži fajl `route.js` ili `route.ts`.
- **Eksportovane funkcije:** Umesto jednog default export-a, eksportuju se funkcije za specifične HTTP metode (npr. `GET`, `POST`).
- **Rukovanje odgovorima:** Koristite konstruktor `Response` za vraćanje odgovora, što omogućava veću kontrolu nad header-ima i status kodovima.

#### Kako rukovati drugim putanjama i metodama:

<details>

<summary>Rukovanje specifičnim HTTP metodama</summary>

Next.js 13+ vam omogućava da definišete handlere za specifične HTTP metode u istom fajlu `route.js` ili `route.ts`, što doprinosi jasnijem i organizovanijem kodu.

**Primer:**
```javascript
// app/api/users/[id]/route.js

export async function GET(request, { params }) {
const { id } = params
// Fetch user data based on 'id'
return new Response(JSON.stringify({ userId: id, name: "Jane Doe" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function PUT(request, { params }) {
const { id } = params
// Update user data based on 'id'
return new Response(JSON.stringify({ message: `User ${id} updated.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function DELETE(request, { params }) {
const { id } = params
// Delete user based on 'id'
return new Response(JSON.stringify({ message: `User ${id} deleted.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**Objašnjenje:**

- **Višestruki exporti:** Svaka HTTP metoda (`GET`, `PUT`, `DELETE`) ima sopstvenu izvezenu funkciju.
- **Parametri:** Drugi argument omogućava pristup parametrima rute preko `params`.
- **Unapređeni odgovori:** Veća kontrola nad objektima odgovora, omogućavajući precizno upravljanje zaglavljima i status kodovima.

</details>

<details>

<summary>Catch-All i ugnježdene rute</summary>

Next.js 13+ podržava napredne funkcije rutiranja kao što su catch-all rute i ugnježdene API rute, omogućavajući dinamičnije i skalabilnije API strukture.

**Primer Catch-All rute:**
```javascript
// app/api/[...slug]/route.js

export async function GET(request, { params }) {
const { slug } = params
// Handle dynamic nested routes
return new Response(JSON.stringify({ slug }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**Objašnjenje:**

- **Sintaksa:** `[...]` označava catch-all segment, koji hvata sve ugnježdene rute.
- **Upotreba:** Korisno za API-je koji treba da rukuju promenljivim dubinama ruta ili dinamičkim segmentima.

**Primer ugnježdenih ruta:**
```javascript
// app/api/posts/[postId]/comments/[commentId]/route.js

export async function GET(request, { params }) {
const { postId, commentId } = params
// Fetch specific comment for a post
return new Response(
JSON.stringify({ postId, commentId, comment: "Great post!" }),
{
status: 200,
headers: { "Content-Type": "application/json" },
}
)
}
```
**Objašnjenje:**

- **Deep Nesting:** Omogućava hijerarhijsku strukturu API-ja koja odražava odnose između resursa.
- **Parameter Access:** Lako pristupiti višestrukim parametrima rute putem `params` objekta.

</details>

<details>

<summary>Rukovanje API rutama u Next.js 12 i ranijim verzijama</summary>

## API rute u direktorijumu `pages` (Next.js 12 i ranije)

Pre nego što je Next.js 13 uveo direktorijum `app` i poboljšane mogućnosti rutiranja, API rute su se prvenstveno definisale unutar direktorijuma `pages`. Ovakav pristup je i dalje široko korišćen i podržan u Next.js 12 i ranijim verzijama.

#### Osnovna API ruta

**File Structure:**
```go
goCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── hello.js
├── package.json
└── ...
```
**Implementacija:**
```javascript
javascriptCopy code// pages/api/hello.js

export default function handler(req, res) {
res.status(200).json({ message: 'Hello, World!' });
}
```
**Objašnjenje:**

- **Lokacija:** API rute se nalaze u direktorijumu `pages/api/`.
- **Export:** Koristite `export default` da definišete handler funkciju.
- **Potpis funkcije:** Handler prima objekte `req` (HTTP request) i `res` (HTTP response).
- **Routing:** Ime fajla (`hello.js`) mapira se na endpoint `/api/hello`.

#### Dinamičke API rute

**Struktura fajlova:**
```bash
bashCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── users/
│           └── [id].js
├── package.json
└── ...
```
**Implementacija:**
```javascript
javascriptCopy code// pages/api/users/[id].js

export default function handler(req, res) {
const {
query: { id },
method,
} = req;

switch (method) {
case 'GET':
// Fetch user data based on 'id'
res.status(200).json({ userId: id, name: 'John Doe' });
break;
case 'PUT':
// Update user data based on 'id'
res.status(200).json({ message: `User ${id} updated.` });
break;
case 'DELETE':
// Delete user based on 'id'
res.status(200).json({ message: `User ${id} deleted.` });
break;
default:
res.setHeader('Allow', ['GET', 'PUT', 'DELETE']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**Objašnjenje:**

- **Dinamički segmenti:** Uglaste zagrade (`[id].js`) označavaju dinamičke segmente ruta.
- **Pristup parametrima:** Koristite `req.query.id` da pristupite dinamičkom parametru.
- **Rukovanje metodama:** Koristite uslovnu logiku za rukovanje različitim HTTP metodama (`GET`, `PUT`, `DELETE`, itd.).

#### Rukovanje različitim HTTP metodama

Iako osnovni primer API rute obrađuje sve HTTP metode unutar jedne funkcije, možete strukturisati svoj kod da eksplicitno obradi svaku metodu radi bolje preglednosti i održavanja.

**Primer:**
```javascript
javascriptCopy code// pages/api/posts.js

export default async function handler(req, res) {
const { method } = req;

switch (method) {
case 'GET':
// Handle GET request
res.status(200).json({ message: 'Fetching posts.' });
break;
case 'POST':
// Handle POST request
res.status(201).json({ message: 'Post created.' });
break;
default:
res.setHeader('Allow', ['GET', 'POST']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**Najbolje prakse:**

- **Razdvajanje odgovornosti:** Jasno razdvojite logiku za različite HTTP metode.
- **Konzistentnost odgovora:** Obezbedite konzistentnu strukturu odgovora kako bi rukovanje na klijentskoj strani bilo jednostavnije.
- **Rukovanje greškama:** Na odgovarajući način obradite nepodržane metode i neočekivane greške.

</details>

### CORS Konfiguracija

Kontrolišite koji origins mogu pristupiti vašim API rutama, čime se ublažavaju ranjivosti vezane za Cross-Origin Resource Sharing (CORS) vulnerabilities.

**Loš primer konfiguracije:**
```javascript
// app/api/data/route.js

export async function GET(request) {
return new Response(JSON.stringify({ data: "Public Data" }), {
status: 200,
headers: {
"Access-Control-Allow-Origin": "*", // Allows any origin
"Access-Control-Allow-Methods": "GET, POST, PUT, DELETE",
},
})
}
```
Imajte na umu da se **CORS može takođe konfigurisati u svim API rutama** unutar **`middleware.ts`** datoteke:
```javascript
// app/middleware.ts

import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(request: NextRequest) {
const allowedOrigins = [
"https://yourdomain.com",
"https://sub.yourdomain.com",
]
const origin = request.headers.get("Origin")

const response = NextResponse.next()

if (allowedOrigins.includes(origin || "")) {
response.headers.set("Access-Control-Allow-Origin", origin || "")
response.headers.set(
"Access-Control-Allow-Methods",
"GET, POST, PUT, DELETE, OPTIONS"
)
response.headers.set(
"Access-Control-Allow-Headers",
"Content-Type, Authorization"
)
// If credentials are needed:
// response.headers.set('Access-Control-Allow-Credentials', 'true');
}

// Handle preflight requests
if (request.method === "OPTIONS") {
return new Response(null, {
status: 204,
headers: response.headers,
})
}

return response
}

export const config = {
matcher: "/api/:path*", // Apply to all API routes
}
```
**Problem:**

- **`Access-Control-Allow-Origin: '*'`:** Dozvoljava bilo kom web sajtu da pristupi API-ju, potencijalno omogućavajući zlonamernim sajtovima da interaguju sa vašim API-jem bez ograničenja.
- **Wide Method Allowance:** Dozvola svih metoda može omogućiti napadačima izvođenje nepoželjnih radnji.

**How attackers exploit it:**

Napadači mogu napraviti zlonamerne web sajtove koji šalju zahteve vašem API-ju, potencijalno zloupotrebljavajući funkcionalnosti kao što su preuzimanje podataka, manipulacija podacima ili pokretanje nepoželjnih akcija u ime autentifikovanih korisnika.


{{#ref}}
../../pentesting-web/cors-bypass.md
{{#endref}}

### Izlaganje server koda na klijentskoj strani

Lako je **koristiti kod koji se koristi na serveru i u kodu koji je izložen i korišćen na klijentskoj strani**; najbolji način da se osigura da fajl sa kodom nikada ne bude izložen na klijentskoj strani je koristeći ovaj import na početku fajla:
```js
import "server-only"
```
## Ključne datoteke i njihove uloge

### `middleware.ts` / `middleware.js`

**Lokacija:** Korenski direktorijum projekta ili unutar `src/`.

**Svrha:** Izvršava kod u server-side serverless funkciji pre nego što se zahtev obradi, omogućavajući zadatke kao što su autentifikacija, preusmeravanja ili modifikovanje odgovora.

**Tok izvršavanja:**

1. **Dolazni zahtev:** middleware presreće zahtev.
2. **Obrada:** Izvršava operacije na osnovu zahteva (npr. provera autentifikacije).
3. **Modifikacija odgovora:** Može izmeniti odgovor ili predati kontrolu sledećem handleru.

**Primeri upotrebe:**

- Preusmeravanje neautentifikovanih korisnika.
- Dodavanje prilagođenih zaglavlja.
- Logovanje zahteva.

**Primer konfiguracije:**
```typescript
// middleware.ts
import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(req: NextRequest) {
const url = req.nextUrl.clone()
if (!req.cookies.has("token")) {
url.pathname = "/login"
return NextResponse.redirect(url)
}
return NextResponse.next()
}

export const config = {
matcher: ["/protected/:path*"],
}
```
### `next.config.js`

**Location:** Koren projekta.

**Purpose:** Konfiguriše ponašanje Next.js-a, omogućavajući ili onemogućavajući funkcije, prilagođavajući webpack konfiguracije, podešavajući varijable okruženja i konfigurišući nekoliko bezbednosnih opcija.

**Key Security Configurations:**

<details>

<summary>Bezbednosni HTTP headeri</summary>

Bezbednosni header-i poboljšavaju sigurnost vaše aplikacije tako što browserima govore kako da tretiraju sadržaj. Pomažu u ublažavanju napada kao što su Cross-Site Scripting (XSS), Clickjacking i MIME type sniffing:

- Content Security Policy (CSP)
- X-Frame-Options
- X-Content-Type-Options
- Strict-Transport-Security (HSTS)
- Referrer Policy

**Primeri:**
```javascript
// next.config.js

module.exports = {
async headers() {
return [
{
source: "/(.*)", // Apply to all routes
headers: [
{
key: "X-Frame-Options",
value: "DENY",
},
{
key: "Content-Security-Policy",
value:
"default-src *; script-src 'self' 'unsafe-inline' 'unsafe-eval';",
},
{
key: "X-Content-Type-Options",
value: "nosniff",
},
{
key: "Strict-Transport-Security",
value: "max-age=63072000; includeSubDomains; preload", // Enforces HTTPS
},
{
key: "Referrer-Policy",
value: "no-referrer", // Completely hides referrer
},
// Additional headers...
],
},
]
},
}
```
</details>

<details>

<summary>Podešavanja optimizacije slika</summary>

Next.js optimizuje slike radi performansi, ali pogrešna podešavanja mogu dovesti do bezbednosnih ranjivosti, na primer omogućavanjem nepouzdanim izvorima da ubace zlonamerni sadržaj.

**Primer loše konfiguracije:**
```javascript
// next.config.js

module.exports = {
images: {
domains: ["*"], // Allows images from any domain
},
}
```
**Problem:**

- **`'*'`:** Dozvoljava učitavanje slika sa bilo kog eksternog izvora, uključujući nepouzdane ili maliciozne domene. Napadači mogu hostovati slike koje sadrže maliciozne payload-e ili sadržaj koji obmanjuje korisnike.
- Drugi problem može biti dozvoljavanje domena **na kojem bilo ko može da otpremi sliku** (npr. `raw.githubusercontent.com`)

**How attackers abuse it:**

Ubacivanjem slika sa malicioznih izvora, napadači mogu izvoditi phishing napade, prikazivati obmanjujuće informacije ili iskoristiti ranjivosti u bibliotekama za renderovanje slika.

</details>

<details>

<summary>Izlaganje promenljivih okruženja</summary>

Upravljajte osetljivim informacijama kao što su API keys i database credentials sigurno, bez izlaganja klijentu.

#### a. Izlaganje osetljivih promenljivih

**Loš primer konfiguracije:**
```javascript
// next.config.js

module.exports = {
env: {
SECRET_API_KEY: process.env.SECRET_API_KEY, // Exposed to the client
NEXT_PUBLIC_API_URL: process.env.NEXT_PUBLIC_API_URL, // Correctly prefixed for client
},
}
```
**Problem:**

- **`SECRET_API_KEY`:** Bez prefiksa `NEXT_PUBLIC_`, Next.js ne izlaže varijable na client. Međutim, ako je greškom prefiksovan (npr. `NEXT_PUBLIC_SECRET_API_KEY`), postaje dostupan na client side.

**How attackers abuse it:**

Ako su osetljive varijable izložene clientu, napadači ih mogu preuzeti pregledom client-side koda ili network requests, dobijajući neovlašćen pristup API-ima, bazama podataka ili drugim servisima.

</details>

<details>

<summary>Preusmeravanja</summary>

Upravljajte URL redirekcijama i rewrite-ovima unutar vaše aplikacije, obezbeđujući da su korisnici pravilno usmereni bez uvođenja open redirect vulnerabilities.

#### a. Open Redirect Vulnerability

**Primer loše konfiguracije:**
```javascript
// next.config.js

module.exports = {
async redirects() {
return [
{
source: "/redirect",
destination: (req) => req.query.url, // Dynamically redirects based on query parameter
permanent: false,
},
]
},
}
```
**Problem:**

- **Dinamička destinacija:** Omogućava korisnicima da navedu bilo koji URL, omogućavajući open redirect attacks.
- **Poverenje u korisnički unos:** Redirects to URLs provided by users without validation can lead to phishing, malware distribution, or credential theft.

**How attackers abuse it:**

Napadači mogu kreirati URL-ove koji izgledaju kao da potiču sa vašeg domena, ali redirect korisnike na maliciozne sajtove. Na primer:
```bash
https://yourdomain.com/redirect?url=https://malicious-site.com
```
Korisnici koji veruju originalnoj domeni mogu nenamerno posetiti štetne veb-sajtove.

</details>

<details>

<summary>Webpack Configuration</summary>

Prilagođavanje Webpack konfiguracija za vašu Next.js aplikaciju može nenamerno uvesti bezbednosne ranjivosti ako se ne postupa pažljivo.

#### a. Otkrivanje osetljivih modula

**Loš primer konfiguracije:**
```javascript
// next.config.js

module.exports = {
webpack: (config, { isServer }) => {
if (!isServer) {
config.resolve.alias["@sensitive"] = path.join(__dirname, "secret-folder")
}
return config
},
}
```
**Problem:**

- **Izlaganje osetljivih putanja:** Aliasovanje osetljivih direktorijuma i omogućavanje client-side pristupa može uzrokovati leak poverljivih informacija.
- **Bundlovanje tajni:** Ako su osetljivi fajlovi bundlovani za klijenta, njihov sadržaj postaje dostupan kroz source maps ili inspekcijom client-side koda.

**Kako napadači zloupotrebljavaju ovo:**

Napadači mogu pristupiti ili rekonstruisati strukturu direktorijuma aplikacije, potencijalno pronalazeći i iskorišćavajući osetljive fajlove ili podatke.

</details>

### `pages/_app.js` and `pages/_document.js`

#### **`pages/_app.js`**

**Svrha:** Zamenjuje podrazumevanu App komponentu, omogućavajući global state, stilove i layout komponente.

**Slučajevi upotrebe:**

- Ubacivanje global CSS.
- Dodavanje layout wrapper-a.
- Integracija state management biblioteka.

**Primer:**
```jsx
// pages/_app.js
import "../styles/globals.css"

function MyApp({ Component, pageProps }) {
return <Component {...pageProps} />
}

export default MyApp
```
#### **`pages/_document.js`**

**Svrha:** Zamenjuje podrazumevani Document, omogućavajući prilagođavanje `<html>` i `<body>` tagova.

**Upotrebe:**

- Izmena `<html>` ili `<body>` tagova.
- Dodavanje meta tagova ili prilagođenih skripti.
- Integracija fontova treće strane.

**Primer:**
```jsx
// pages/_document.js
import Document, { Html, Head, Main, NextScript } from "next/document"

class MyDocument extends Document {
render() {
return (
<Html lang="en">
<Head>{/* Custom fonts or meta tags */}</Head>
<body>
<Main />
<NextScript />
</body>
</Html>
)
}
}

export default MyDocument
```
### Prilagođeni server (opciono)

**Svrha:** Iako Next.js dolazi sa ugrađenim serverom, možete napraviti prilagođeni server za napredne slučajeve upotrebe kao što su prilagođeno rutiranje ili integracija sa postojećim backend servisima.

**Napomena:** Korišćenje prilagođenog servera može ograničiti opcije deploy-a, posebno na platformama poput Vercel koje su optimizovane za ugrađeni server Next.js-a.

**Primer:**
```javascript
// server.js
const express = require("express")
const next = require("next")

const dev = process.env.NODE_ENV !== "production"
const app = next({ dev })
const handle = app.getRequestHandler()

app.prepare().then(() => {
const server = express()

// Custom route
server.get("/a", (req, res) => {
return app.render(req, res, "/a")
})

// Default handler
server.all("*", (req, res) => {
return handle(req, res)
})

server.listen(3000, (err) => {
if (err) throw err
console.log("> Ready on http://localhost:3000")
})
})
```
---

## Dodatna arhitektonska i bezbednosna razmatranja

### Promenljive okruženja i konfiguracija

**Svrha:** Upravljanje osetljivim informacijama i podešavanjima konfiguracije van koda.

**Najbolje prakse:**

- **Koristite `.env` fajlove:** Čuvajte promenljive kao što su API ključevi u `.env.local` (isključeno iz sistema za kontrolu verzija).
- **Pristupite promenljivama sigurno:** Koristite `process.env.VARIABLE_NAME` za pristup promenljivim okruženja.
- **Nikada ne izlažite tajne na klijentu:** Osigurajte da se osetljive promenljive koriste samo na serverskoj strani.

**Primer:**
```javascript
// next.config.js
module.exports = {
env: {
API_KEY: process.env.API_KEY, // Accessible on both client and server
SECRET_KEY: process.env.SECRET_KEY, // Be cautious if accessible on the client
},
}
```
**Napomena:** Da biste ograničili varijable samo na server-side, izostavite ih iz `env` objekta ili ih prefiksirajte sa `NEXT_PUBLIC_` da biste ih izložili klijentu.

### Autentifikacija i autorizacija

**Pristup:**

- **Session-Based Authentication:** Koristite cookies za upravljanje korisničkim sesijama.
- **Token-Based Authentication:** Implementirajte JWTs za stateless autentifikaciju.
- **Third-Party Providers:** Integrirajte se sa OAuth provajderima (npr. Google, GitHub) koristeći biblioteke kao što su `next-auth`.

**Bezbednosne prakse:**

- **Sigurni cookies:** Podešavajte `HttpOnly`, `Secure` i `SameSite` atribute.
- **Hashiranje lozinki:** Uvek heširajte lozinke pre nego što ih čuvate.
- **Input Validation:** Sprečite injection attacks validacijom i sanitizacijom inputa.

**Primer:**
```javascript
// pages/api/login.js
import { sign } from "jsonwebtoken"
import { serialize } from "cookie"

export default async function handler(req, res) {
const { username, password } = req.body

// Validate user credentials
if (username === "admin" && password === "password") {
const token = sign({ username }, process.env.JWT_SECRET, {
expiresIn: "1h",
})
res.setHeader(
"Set-Cookie",
serialize("auth", token, {
path: "/",
httpOnly: true,
secure: true,
sameSite: "strict",
})
)
res.status(200).json({ message: "Logged in" })
} else {
res.status(401).json({ error: "Invalid credentials" })
}
}
```
### Optimizacija performansi

**Strategije:**

- **Optimizacija slika:** Koristite Next.js-ov `next/image` komponentu za automatsku optimizaciju slika.
- **Razdvajanje koda:** Iskoristite dynamic imports za razdvajanje koda i smanjenje početnog vremena učitavanja.
- **Keširanje:** Implementirajte strategije keširanja za API odgovore i statičke resurse.
- **Lazy Loading:** Učitavajte komponente ili resurse samo kada su potrebni.

**Primer:**
```jsx
// Dynamic Import with Code Splitting
import dynamic from "next/dynamic"

const HeavyComponent = dynamic(() => import("../components/HeavyComponent"), {
loading: () => <p>Loading...</p>,
})
```
## Next.js Server Actions Enumeration (hash to function name via source maps)

Moderni Next.js koristi “Server Actions” koji se izvršavaju na serveru, ali se pozivaju sa klijenta. U produkciji su ti pozivi neprozirni: svi POSTs stižu na zajednički endpoint i razlikuju se po build-specifičnom hash-u poslatom u the `Next-Action` headeru. Primer:
```http
POST /
Next-Action: a9f8e2b4c7d1...
```
Kada je `productionBrowserSourceMaps` omogućeno, minifikovani JS chunks sadrže pozive na `createServerReference(...)` koji leak dovoljno strukture (plus pripadajuće source maps) da se oporavi mapa između action hasha i originalnog imena funkcije. Ovo vam omogućava da prevedete hashes primećene u `Next-Action` u konkretne ciljeve kao što su `deleteUserAccount()` ili `exportFinancialData()`.

### Pristup ekstrakciji (regex on minified JS + optional source maps)

Pretražite preuzete JS chunks za `createServerReference` i izdvojite hash i simbol funkcije/izvora. Dva korisna obrasca:
```regex
# Strict pattern for standard minification
createServerReference\)"([a-f0-9]{40,})",\w+\.callServer,void 0,\w+\.findSourceMapURL,"([^"]+)"\)

# Flexible pattern handling various minification styles
createServerReference[^\"]*"([a-f0-9]{40,})"[^\"]*"([^"]+)"\s*\)
```
- Grupa 1: server action hash (40+ hex chars)
- Grupa 2: simbol ili putanja koja se može razrešiti do originalne funkcije preko source map-a kada je prisutan

Ako skripta reklamira source map (trailer komentar `//# sourceMappingURL=<...>.map`), preuzmite je i razrešite simbol/putanju do originalnog imena funkcije.

### Praktični tok rada

- Pasivno otkrivanje tokom pregledanja: beležite zahteve sa `Next-Action` zaglavljima i JS chunk URL-ovima.
- Preuzmite referencirane JS bundle-ove i prateće `*.map` fajlove (kada su prisutni).
- Pokrenite regex iznad da biste izgradili hash↔ime rečnik.
- Koristite rečnik za ciljano testiranje:
- Triage vođen imenima (npr., `transferFunds`, `exportFinancialData`).
- Pratite pokrivenost kroz build-ove po imenu funkcije (hashovi se rotiraju između build-ova).

### Izvršavanje skrivenih akcija (zahtev zasnovan na šablonu)

Uzmite validan POST zabeležen u proxyju kao šablon i zamenite vrednost `Next-Action` da ciljate neku drugu otkrivenu akciju:
```http
# Before
Next-Action: a9f8e2b4c7d1

# After
Next-Action: b7e3f9a2d8c5
```
Replay in Repeater and test authorization, input validation and business logic of otherwise unreachable actions.

### Burp automatizacija

- NextjsServerActionAnalyzer (Burp extension) automatizuje gore navedeno u Burp-u:
- Pretražuje proxy history za JS chunks, izvlači `createServerReference(...)` entry-je, i parsira source maps kada su dostupni.
- Održava pretraživu hash↔function-name rečnik i de-duplicira između build-ova po imenu funkcije.
- Može pronaći validan template POST i otvoriti spreman za slanje Repeater tab sa zamenjenim hash-om ciljne akcije.
- Repo: https://github.com/Adversis/NextjsServerActionAnalyzer

### Napomene i ograničenja

- Zahteva da `productionBrowserSourceMaps` bude omogućen u production-u da bi se povratila imena iz bundle-ova/source maps.
- Function-name disclosure nije ranjivost sam po sebi; koristite ga da usmerite otkrivanje i testirate autorizaciju svake akcije.

### React Server Components Flight protocol deserialization RCE (CVE-2025-55182)

Next.js App Router deployments koji izlažu Server Actions na `react-server-dom-webpack` **19.0.0–19.2.0 (Next.js 15.x/16.x)** sadrže kritičnu server-side prototype pollution tokom **Flight** chunk deserijalizacije. Kroz kreiranje `$` referenci unutar Flight payload-a, napadač može pivotirati od zagađenih prototipova ka proizvoljnom izvršavanju JavaScript-a, a zatim ka izvršenju OS komandi unutar Node.js procesa.

{{#ref}}
../../pentesting-web/deserialization/nodejs-proto-prototype-pollution/README.md
{{#endref}}

#### Lanac napada u Flight chunk-ovima

1. **Prototype pollution primitive:** Set `"then": "$1:__proto__:then"` tako da resolver upiše `then` funkciju na `Object.prototype`. Bilo koji običan objekat obrađen nakon toga postaje thenable, dopuštajući napadaču da utiče na asinkronu kontrolu toka unutar internog RSC izvršavanja.
2. **Rebinding to the global `Function` constructor:** Usmerite `_response._formData.get` na `"$1:constructor:constructor"`. Tokom rezolucije, `object.constructor` → `Object`, a `Object.constructor` → `Function`, pa budući pozivi `_formData.get()` zaista izvršavaju `Function(...)`.
3. **Code execution via `_prefix`:** Postavite JavaScript izvor u `_response._prefix`. Kada se zaraženi `_formData.get` pozove, framework evalua `Function(_prefix)(...)`, tako da injektovani JS može pokrenuti `require('child_process').exec()` ili bilo koji drugi Node primitiv.

#### Payload skeleton
```json
{
"then": "$1:__proto__:then",
"status": "resolved_model",
"reason": -1,
"value": "{\"then\":\"$B1337\"}",
"_response": {
"_prefix": "require('child_process').exec('id')",
"_chunks": "$Q2",
"_formData": { "get": "$1:constructor:constructor" }
}
}
```
#### Mapiranje izloženosti React Server Function

React Server Functions (RSF) su funkcije koje sadrže direktivu 'use server';. Svaka form action, mutation, ili fetch helper vezan za jednu od tih funkcija postaje RSC Flight endpoint koji će rado deserijalizovati payloads koje dostavi napadač. Korisni recon koraci izvedeni iz React2Shell assessments:

- **Statički inventar:** potražite direktivu da biste shvatili koliko se RSF-ova automatski izlaže od strane framework-a.
```bash
rg -n "'use server';" -g"*.{js,ts,jsx,tsx}" app/
```
- **App Router defaults:** `create-next-app` enables the App Router + `app/` directory by default, which silently turns every route into an RSC-capable endpoint. App Router assets such as `/_next/static/chunks/app/` or responses that stream Flight chunks over `text/x-component` are strong Internet-facing fingerprints.
- **Implicitly vulnerable RSC deployments:** React’s own advisory notes that apps shipping the RSC runtime can be exploitable **even without explicit RSFs**, so treat any build using `react-server-dom-*` 19.0.0–19.2.0 as suspect.
- **Other frameworks bundling RSC:** Vite RSC, Parcel RSC, React Router RSC preview, RedwoodSDK, Waku, etc. reuse the same serializer and inherit the identical remote attack surface until they embed patched React builds.

#### Obuhvat verzija (React2Shell)

- `react-server-dom-webpack`, `react-server-dom-parcel`, `react-server-dom-turbopack`: **ranjive** u 19.0.0, 19.1.0–19.1.1 i 19.2.0; **ispravljeno** u 19.0.1, 19.1.2 i 19.2.1 respektivno.
- **Next.js stable:** App Router izdanja 15.0.0–16.0.6 ugrađuju ranjiv RSC stack. Patch train-ovi 15.0.5 / 15.1.9 / 15.2.6 / 15.3.6 / 15.4.8 / 15.5.7 / 16.0.7 uključuju ispravljene deps, tako da je svaki build ispod tih verzija vredan cilja.
- **Next.js canary:** `14.3.0-canary.77+` takođe sadrži buggy runtime i trenutno nema patched canary drop-ove, što čini te otiske snažnim kandidatima za eksploataciju.

#### Orakl za daljinsko otkrivanje

Assetnote’s [`react2shell-scanner`](https://github.com/assetnote/react2shell-scanner) šalje pažljivo konstruisan multipart Flight request na kandidatske putanje i posmatra ponašanje na serveru:

- **Default mode** izvršava deterministički RCE payload (math operation reflektovana putem `X-Action-Redirect`) koji dokazuje izvršenje koda.
- **`--safe-check` mode** namerno malformira Flight poruku tako da patched serveri vraćaju `200/400`, dok ranjivi ciljevi emituju `HTTP/500` odgovore koji u telu sadrže substring `E{"digest"`. Taj `(500 + digest)` par je trenutno najpouzdaniji remote oracle objavljen od strane defenders.
- Ugrađeni `--waf-bypass`, `--vercel-waf-bypass`, and `--windows` switch-evi prilagođavaju layout payload-a, dodaju junk na početak, ili zamene OS komande kako biste mogli da sondirate realne Internet asset-e.
```bash
python3 scanner.py -u https://target.tld --path /app/api/submit --safe-check
python3 scanner.py -l hosts.txt -t 20 --waf-bypass -o vulnerable.json
```
## Reference

- [Pentesting Next.js Server Actions — A Burp Extension for Hash-to-Function Mapping](https://www.adversis.io/blogs/pentesting-next-js-server-actions)
- [NextjsServerActionAnalyzer (Burp extension)](https://github.com/Adversis/NextjsServerActionAnalyzer)
- [CVE-2025-55182 React Server Components Remote Code Execution Exploit Tool](https://github.com/Spritualkb/CVE-2025-55182-exp)
- [CVE-2025-55182 & CVE-2025-66478 React2Shell – All You Need to Know](https://jfrog.com/blog/2025-55182-and-2025-66478-react2shell-all-you-need-to-know/)
- [assetnote/react2shell-scanner](https://github.com/assetnote/react2shell-scanner)

{{#include ../../banners/hacktricks-training.md}}
