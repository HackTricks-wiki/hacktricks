# NextJS

{{#include ../../banners/hacktricks-training.md}}

## Ogólna architektura aplikacji Next.js

### Typowa struktura plików

Standardowy projekt Next.js stosuje określoną strukturę plików i katalogów, która ułatwia funkcje takie jak routing, punkty końcowe API oraz zarządzanie zasobami statycznymi. Oto typowy układ:
```lua
my-nextjs-app/
├── node_modules/
├── public/
│   ├── images/
│   │   └── logo.png
│   └── favicon.ico
├── app/
│   ├── api/
│   │   └── hello/
│   │       └── route.ts
│   ├── layout.tsx
│   ├── page.tsx
│   ├── about/
│   │   └── page.tsx
│   ├── dashboard/
│   │   ├── layout.tsx
│   │   └── page.tsx
│   ├── components/
│   │   ├── Header.tsx
│   │   └── Footer.tsx
│   ├── styles/
│   │   ├── globals.css
│   │   └── Home.module.css
│   └── utils/
│       └── api.ts
├── .env.local
├── next.config.js
├── tsconfig.json
├── package.json
├── README.md
└── yarn.lock / package-lock.json

```
### Główne katalogi i pliki

- **public/:** Hostuje statyczne zasoby, takie jak obrazy, fonty i inne pliki. Pliki te są dostępne pod ścieżką root (`/`).
- **app/:** Centralny katalog dla stron aplikacji, layoutów, komponentów i API routes. Przyjmuje paradygmat **App Router**, umożliwiając zaawansowane funkcje routingu oraz separację komponentów serwer-klient.
- **app/layout.tsx:** Definiuje główny layout aplikacji, obejmując wszystkie strony i dostarczając spójne elementy UI, takie jak nagłówki, stopki i paski nawigacji.
- **app/page.tsx:** Służy jako punkt wejścia dla root route `/`, renderując stronę główną.
- **app/[route]/page.tsx:** Obsługuje trasy statyczne i dynamiczne. Każdy folder w `app/` reprezentuje segment trasy, a `page.tsx` w tych folderach odpowiada komponentowi danej trasy.
- **app/api/:** Zawiera API routes, pozwalając na tworzenie funkcji serverless obsługujących żądania HTTP. Te trasy zastępują tradycyjny katalog `pages/api`.
- **app/components/:** Zawiera wielokrotnego użytku komponenty React, które można wykorzystywać na różnych stronach i w layoutach.
- **app/styles/:** Zawiera globalne pliki CSS oraz CSS Modules dla stylowania ograniczonego do komponentów.
- **app/utils/:** Zawiera funkcje narzędziowe, moduły pomocnicze i inną logikę niepowiązaną z UI, którą można współdzielić w aplikacji.
- **.env.local:** Przechowuje zmienne środowiskowe specyficzne dla lokalnego środowiska deweloperskiego. Zmienne te **nie** są dodawane do kontroli wersji.
- **next.config.js:** Dostosowuje zachowanie Next.js, w tym konfiguracje webpack, zmienne środowiskowe i ustawienia bezpieczeństwa.
- **tsconfig.json:** Konfiguruje ustawienia TypeScript dla projektu, umożliwiając sprawdzanie typów i inne funkcje TypeScript.
- **package.json:** Zarządza zależnościami projektu, skryptami i metadanymi.
- **README.md:** Dostarcza dokumentację i informacje o projekcie, w tym instrukcje konfiguracji, wytyczne dotyczące użycia i inne istotne szczegóły.
- **yarn.lock / package-lock.json:** Blokują wersje zależności projektu do konkretnych wersji, zapewniając spójne instalacje w różnych środowiskach.

## Warstwa kliencka w Next.js

### Routowanie oparte na plikach w katalogu `app`

Katalog `app` jest fundamentem routingu w najnowszych wersjach Next.js. Wykorzystuje system plików do definiowania tras, co sprawia, że zarządzanie trasami jest intuicyjne i skalowalne.

<details>

<summary>Obsługa ścieżki root /</summary>

**Struktura plików:**
```arduino
my-nextjs-app/
├── app/
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Kluczowe pliki:**

- **`app/page.tsx`**: Obsługuje żądania do ścieżki głównej `/`.
- **`app/layout.tsx`**: Definiuje układ aplikacji, obejmując wszystkie strony.

**Implementacja:**
```tsx
tsxCopy code// app/page.tsx

export default function HomePage() {
return (
<div>
<h1>Welcome to the Home Page!</h1>
<p>This is the root route.</p>
</div>
);
}
```
**Wyjaśnienie:**

- **Definicja trasy:** Plik `page.tsx` bezpośrednio w katalogu `app` odpowiada ścieżce `/`.
- **Renderowanie:** Ten komponent renderuje zawartość strony głównej.
- **Integracja z layoutem:** Komponent `HomePage` jest opakowany przez `layout.tsx`, który może zawierać nagłówki, stopki i inne wspólne elementy.

</details>

<details>

<summary>Obsługa innych statycznych ścieżek</summary>

**Przykład: trasa `/about`**

**Struktura plików:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── about/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementacja:**
```tsx
// app/about/page.tsx

export default function AboutPage() {
return (
<div>
<h1>About Us</h1>
<p>Learn more about our mission and values.</p>
</div>
)
}
```
**Wyjaśnienie:**

- **Definicja trasy:** Plik `page.tsx` wewnątrz folderu `about` odpowiada ścieżce `/about`.
- **Renderowanie:** Ten komponent renderuje zawartość strony `/about`.

</details>

<details>

<summary>Trasy dynamiczne</summary>

Trasy dynamiczne pozwalają obsługiwać ścieżki z zmiennymi segmentami, umożliwiając aplikacjom wyświetlanie treści na podstawie parametrów takich jak ID, slugi itp.

**Przykład: trasa `/posts/[id]`**

**Struktura plików:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── posts/
│   │   └── [id]/
│   │       └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementacja:**
```tsx
tsxCopy code// app/posts/[id]/page.tsx

import { useRouter } from 'next/navigation';

interface PostProps {
params: { id: string };
}

export default function PostPage({ params }: PostProps) {
const { id } = params;
// Fetch post data based on 'id'

return (
<div>
<h1>Post #{id}</h1>
<p>This is the content of post {id}.</p>
</div>
);
}
```
**Wyjaśnienie:**

- **Dynamic Segment:** `[id]` oznacza dynamiczny segment w trasie, przechwytując parametr `id` z adresu URL.
- **Accessing Parameters:** Obiekt `params` zawiera parametry dynamiczne, dostępne wewnątrz komponentu.
- **Route Matching:** Każda ścieżka pasująca do `/posts/*`, na przykład `/posts/1`, `/posts/abc`, itd., będzie obsługiwana przez ten komponent.

</details>

<details>

<summary>Zagnieżdżone trasy</summary>

Next.js obsługuje zagnieżdżone routowanie, pozwalając na hierarchiczną strukturę tras, która odzwierciedla układ katalogów.

**Przykład: trasa `/dashboard/settings/profile`**

**Struktura plików:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── dashboard/
│   │   ├── settings/
│   │   │   └── profile/
│   │   │       └── page.tsx
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementacja:**
```tsx
tsxCopy code// app/dashboard/settings/profile/page.tsx

export default function ProfileSettingsPage() {
return (
<div>
<h1>Profile Settings</h1>
<p>Manage your profile information here.</p>
</div>
);
}
```
**Wyjaśnienie:**

- **Głębokie zagnieżdżenie:** Plik `page.tsx` znajdujący się w `dashboard/settings/profile/` odpowiada ścieżce `/dashboard/settings/profile`.
- **Odwzorowanie hierarchii:** Struktura katalogów odzwierciedla ścieżkę URL, poprawiając utrzymywalność i przejrzystość.

</details>

<details>

<summary>Trasy Catch-All</summary>

Trasy catch-all obsługują wiele zagnieżdżonych segmentów lub nieznane ścieżki, zapewniając elastyczność w obsłudze routingu.

**Przykład: trasa `/*`**

**Struktura plików:**
```arduino
my-nextjs-app/
├── app/
│   ├── [..slug]/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementacja:**
```tsx
// app/[...slug]/page.tsx

interface CatchAllProps {
params: { slug: string[] }
}

export default function CatchAllPage({ params }: CatchAllProps) {
const { slug } = params
const fullPath = `/${slug.join("/")}`

return (
<div>
<h1>Catch-All Route</h1>
<p>You have navigated to: {fullPath}</p>
</div>
)
}
```
**Wyjaśnienie:**

- **Segment Catch-All:** `[...slug]` przechwytuje wszystkie pozostałe segmenty ścieżki jako tablicę.
- **Zastosowanie:** Przydatne do obsługi dynamicznych scenariuszy routingu, takich jak ścieżki generowane przez użytkowników, zagnieżdżone kategorie itp.
- **Dopasowywanie tras:** Ścieżki takie jak `/anything/here`, `/foo/bar/baz`, itd. są obsługiwane przez ten komponent.

</details>

### Potencjalne podatności po stronie klienta

Chociaż Next.js zapewnia bezpieczną podstawę, niewłaściwe praktyki programistyczne mogą wprowadzić podatności. Kluczowe podatności po stronie klienta obejmują:

<details>

<summary>Cross-Site Scripting (XSS)</summary>

Ataki XSS występują, gdy złośliwe skrypty są wstrzykiwane do zaufanych serwisów. Atakujący mogą uruchamiać skrypty w przeglądarkach użytkowników, kradnąc dane lub wykonując akcje w imieniu użytkownika.

**Przykład podatnego kodu:**
```jsx
// Dangerous: Injecting user input directly into HTML
function Comment({ userInput }) {
return <div dangerouslySetInnerHTML={{ __html: userInput }} />
}
```
**Dlaczego jest to podatne:** Używanie `dangerouslySetInnerHTML` z niezaufanym wejściem pozwala atakującym na wstrzyknięcie złośliwych skryptów.

</details>

<details>

<summary>Client-Side Template Injection</summary>

Występuje, gdy dane od użytkownika są niewłaściwie obsługiwane w szablonach, co pozwala atakującym na wstrzyknięcie i wykonanie szablonów lub wyrażeń.

**Przykład podatnego kodu:**
```jsx
import React from "react"
import ejs from "ejs"

function RenderTemplate({ template, data }) {
const html = ejs.render(template, data)
return <div dangerouslySetInnerHTML={{ __html: html }} />
}
```
**Dlaczego to jest podatne:** Jeśli `template` lub `data` zawierają złośliwą zawartość, może to prowadzić do wykonania niezamierzonego kodu.

</details>

<details>

<summary>Client Path Traversal</summary>

Jest to luka, która pozwala atakującym manipulować ścieżkami po stronie klienta w celu wykonania niezamierzonych działań, takich jak Cross-Site Request Forgery (CSRF). W przeciwieństwie do server-side path traversal, które celuje w system plików serwera, CSPT koncentruje się na wykorzystywaniu mechanizmów po stronie klienta do przekierowywania legalnych żądań API do złośliwych endpointów.

**Przykład podatnego kodu:**

Aplikacja Next.js pozwala użytkownikom przesyłać i pobierać pliki. Funkcja pobierania jest zaimplementowana po stronie klienta, gdzie użytkownicy mogą podać ścieżkę pliku do pobrania.
```jsx
// pages/download.js
import { useState } from "react"

export default function DownloadPage() {
const [filePath, setFilePath] = useState("")

const handleDownload = () => {
fetch(`/api/files/${filePath}`)
.then((response) => response.blob())
.then((blob) => {
const url = window.URL.createObjectURL(blob)
const a = document.createElement("a")
a.href = url
a.download = filePath
a.click()
})
}

return (
<div>
<h1>Download File</h1>
<input
type="text"
value={filePath}
onChange={(e) => setFilePath(e.target.value)}
placeholder="Enter file path"
/>
<button onClick={handleDownload}>Download</button>
</div>
)
}
```
#### Scenariusz ataku

1. **Cel atakującego**: Wykonać atak CSRF w celu usunięcia krytycznego pliku (np. `admin/config.json`) poprzez manipulację `filePath`.
2. **Wykorzystanie CSPT**:
- **Złośliwe dane wejściowe**: Atakujący przygotowuje URL z zmanipulowanym `filePath`, np. `../deleteFile/config.json`.
- **Wynikowe wywołanie API**: Kod po stronie klienta wykonuje żądanie do `/api/files/../deleteFile/config.json`.
- **Obsługa po stronie serwera**: Jeśli serwer nie waliduje `filePath`, przetwarza żądanie, co może prowadzić do usunięcia lub ujawnienia wrażliwych plików.
3. **Wykonanie CSRF**:
- **Sfałszowany link**: Atakujący wysyła ofierze link lub osadza złośliwy skrypt, który wyzwala żądanie pobrania z zmanipulowanym `filePath`.
- **Skutek**: Ofiara nieświadomie wykonuje akcję, co prowadzi do nieautoryzowanego dostępu do plików lub ich usunięcia.

#### Dlaczego jest podatne

- **Brak walidacji danych wejściowych**: Po stronie klienta dopuszcza się dowolne wartości `filePath`, co umożliwia path traversal.
- **Zaufanie danym od klienta**: API po stronie serwera ufa i przetwarza `filePath` bez sanitizacji.
- **Potencjalne działania API**: Jeśli endpoint API wykonuje operacje zmieniające stan (np. usuwanie, modyfikacja plików), może być wykorzystany przez CSPT.

</details>

## Po stronie serwera w Next.js

### Server-Side Rendering (SSR)

Strony są renderowane na serwerze przy każdym żądaniu, zapewniając użytkownikowi w pełni wyrenderowany HTML. W takim przypadku należy utworzyć własny serwer, aby obsługiwać żądania.

**Przypadki użycia:**

- Dynamiczna zawartość, która często się zmienia.
- Optymalizacja SEO, ponieważ wyszukiwarki mogą indeksować w pełni wyrenderowaną stronę.

**Implementacja:**
```jsx
// pages/index.js
export async function getServerSideProps(context) {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data } }
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### Statyczne generowanie stron (SSG)

Strony są wstępnie renderowane w czasie budowania, co skutkuje krótszym czasem ładowania i zmniejszonym obciążeniem serwera.

**Zastosowania:**

- Treści, które nie zmieniają się często.
- Blogi, dokumentacja, strony marketingowe.

**Implementacja:**
```jsx
// pages/index.js
export async function getStaticProps() {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data }, revalidate: 60 } // Revalidate every 60 seconds
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### Funkcje serverless (API Routes)

Next.js umożliwia tworzenie endpointów API jako funkcji serverless. Te funkcje uruchamiają się na żądanie bez potrzeby dedykowanego serwera.

**Zastosowania:**

- Obsługa przesyłania formularzy.
- Interakcja z bazami danych.
- Przetwarzanie danych lub integracja z zewnętrznymi API.

**Implementacja:**

Wprowadzenie katalogu `app` w Next.js 13 sprawiło, że routing i obsługa API stały się bardziej elastyczne i rozbudowane. To nowoczesne podejście jest ściśle powiązane z systemem routingu opartym na plikach, ale wprowadza rozszerzone możliwości, w tym wsparcie dla komponentów serwerowych i klienckich.

#### Podstawowy Route Handler

**File Structure:**
```go
my-nextjs-app/
├── app/
│   └── api/
│       └── hello/
│           └── route.js
├── package.json
└── ...
```
**Implementacja:**
```javascript
// app/api/hello/route.js

export async function POST(request) {
return new Response(JSON.stringify({ message: "Hello from App Router!" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

// Client-side fetch to access the API endpoint
fetch("/api/submit", {
method: "POST",
headers: { "Content-Type": "application/json" },
body: JSON.stringify({ name: "John Doe" }),
})
.then((res) => res.json())
.then((data) => console.log(data))
```
**Wyjaśnienie:**

- **Lokalizacja:** Trasy API znajdują się w katalogu `app/api/`.
- **Nazewnictwo plików:** Każdy endpoint API znajduje się w osobnym folderze zawierającym plik `route.js` lub `route.ts`.
- **Eksportowane funkcje:** Zamiast pojedynczego eksportu domyślnego, eksportuje się funkcje dla konkretnych metod HTTP (np. `GET`, `POST`).
- **Obsługa odpowiedzi:** Użyj konstruktora `Response` do zwracania odpowiedzi, co pozwala na większą kontrolę nad nagłówkami i kodami statusu.

#### Jak obsługiwać inne ścieżki i metody:

<details>

<summary>Obsługa konkretnych metod HTTP</summary>

Next.js 13+ pozwala zdefiniować handlery dla konkretnych metod HTTP w tym samym pliku `route.js` lub `route.ts`, co sprzyja czytelniejszemu i bardziej zorganizowanemu kodowi.

**Przykład:**
```javascript
// app/api/users/[id]/route.js

export async function GET(request, { params }) {
const { id } = params
// Fetch user data based on 'id'
return new Response(JSON.stringify({ userId: id, name: "Jane Doe" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function PUT(request, { params }) {
const { id } = params
// Update user data based on 'id'
return new Response(JSON.stringify({ message: `User ${id} updated.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function DELETE(request, { params }) {
const { id } = params
// Delete user based on 'id'
return new Response(JSON.stringify({ message: `User ${id} deleted.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**Wyjaśnienie:**

- **Wiele eksportów:** Każda metoda HTTP (`GET`, `PUT`, `DELETE`) ma swoją własną eksportowaną funkcję.
- **Parametry:** Drugi argument umożliwia dostęp do parametrów trasy za pomocą `params`.
- **Ulepszone odpowiedzi:** Większa kontrola nad obiektami odpowiedzi, umożliwiająca precyzyjne zarządzanie nagłówkami i kodami statusu.

</details>

<details>

<summary>Trasy catch-all i zagnieżdżone</summary>

Next.js 13+ obsługuje zaawansowane funkcje routingu, takie jak trasy catch-all i zagnieżdżone trasy API, co pozwala na bardziej dynamiczne i skalowalne struktury API.

**Przykład trasy catch-all:**
```javascript
// app/api/[...slug]/route.js

export async function GET(request, { params }) {
const { slug } = params
// Handle dynamic nested routes
return new Response(JSON.stringify({ slug }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**Wyjaśnienie:**

- **Składnia:** `[...]` oznacza segment catch-all, przechwytujący wszystkie zagnieżdżone ścieżki.
- **Zastosowanie:** Przydatne dla API, które muszą obsługiwać różne głębokości ścieżek lub dynamiczne segmenty.

**Przykład zagnieżdżonych tras:**
```javascript
// app/api/posts/[postId]/comments/[commentId]/route.js

export async function GET(request, { params }) {
const { postId, commentId } = params
// Fetch specific comment for a post
return new Response(
JSON.stringify({ postId, commentId, comment: "Great post!" }),
{
status: 200,
headers: { "Content-Type": "application/json" },
}
)
}
```
**Wyjaśnienie:**

- **Głębokie zagnieżdżenie:** Umożliwia hierarchiczną strukturę API, odzwierciedlając relacje między zasobami.
- **Dostęp do parametrów:** Umożliwia łatwy dostęp do wielu parametrów trasy za pomocą obiektu `params`.

</details>

<details>

<summary>Obsługa tras API w Next.js 12 i wcześniejszych</summary>

## Trasy API w katalogu `pages` (Next.js 12 i wcześniejsze)

Zanim Next.js 13 wprowadził katalog `app` i rozszerzone możliwości routingu, trasy API były głównie definiowane w katalogu `pages`. To podejście jest nadal szeroko stosowane i wspierane w Next.js 12 i wcześniejszych wersjach.

#### Podstawowa trasa API

**Struktura plików:**
```go
goCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── hello.js
├── package.json
└── ...
```
**Implementacja:**
```javascript
javascriptCopy code// pages/api/hello.js

export default function handler(req, res) {
res.status(200).json({ message: 'Hello, World!' });
}
```
**Wyjaśnienie:**

- **Lokalizacja:** Trasy API znajdują się w katalogu `pages/api/`.
- **Eksport:** Użyj `export default` do zdefiniowania funkcji obsługującej.
- **Sygnatura funkcji:** Funkcja obsługująca otrzymuje obiekty `req` (żądanie HTTP) i `res` (odpowiedź HTTP).
- **Routing:** Nazwa pliku (`hello.js`) odpowiada endpointowi `/api/hello`.

#### Dynamiczne trasy API

**Struktura plików:**
```bash
bashCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── users/
│           └── [id].js
├── package.json
└── ...
```
**Implementacja:**
```javascript
javascriptCopy code// pages/api/users/[id].js

export default function handler(req, res) {
const {
query: { id },
method,
} = req;

switch (method) {
case 'GET':
// Fetch user data based on 'id'
res.status(200).json({ userId: id, name: 'John Doe' });
break;
case 'PUT':
// Update user data based on 'id'
res.status(200).json({ message: `User ${id} updated.` });
break;
case 'DELETE':
// Delete user based on 'id'
res.status(200).json({ message: `User ${id} deleted.` });
break;
default:
res.setHeader('Allow', ['GET', 'PUT', 'DELETE']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**Wyjaśnienie:**

- **Dynamiczne segmenty:** Nawiasy kwadratowe (`[id].js`) oznaczają dynamiczne segmenty tras.
- **Dostęp do parametrów:** Użyj `req.query.id`, aby uzyskać dostęp do dynamicznego parametru.
- **Obsługa metod:** Użyj logiki warunkowej do obsługi różnych metod HTTP (`GET`, `PUT`, `DELETE`, itp.).

#### Obsługa różnych metod HTTP

Podczas gdy podstawowy przykład trasy API obsługuje wszystkie metody HTTP w jednej funkcji, możesz zorganizować kod tak, aby każdą metodę obsługiwać osobno — dla lepszej czytelności i łatwiejszego utrzymania.

**Przykład:**
```javascript
javascriptCopy code// pages/api/posts.js

export default async function handler(req, res) {
const { method } = req;

switch (method) {
case 'GET':
// Handle GET request
res.status(200).json({ message: 'Fetching posts.' });
break;
case 'POST':
// Handle POST request
res.status(201).json({ message: 'Post created.' });
break;
default:
res.setHeader('Allow', ['GET', 'POST']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**Najlepsze praktyki:**

- **Separation of Concerns:** Wyraźnie oddziel logikę dla różnych metod HTTP.
- **Response Consistency:** Zapewnij spójne struktury odpowiedzi, aby ułatwić obsługę po stronie klienta.
- **Error Handling:** Prawidłowo obsługuj nieobsługiwane metody i nieoczekiwane błędy.

</details>

### Konfiguracja CORS

Kontroluj, które originy mają dostęp do tras API, łagodząc podatności związane z Cross-Origin Resource Sharing (CORS).

**Przykład złej konfiguracji:**
```javascript
// app/api/data/route.js

export async function GET(request) {
return new Response(JSON.stringify({ data: "Public Data" }), {
status: 200,
headers: {
"Access-Control-Allow-Origin": "*", // Allows any origin
"Access-Control-Allow-Methods": "GET, POST, PUT, DELETE",
},
})
}
```
Zwróć uwagę, że **CORS można również skonfigurować dla wszystkich tras API** w pliku **`middleware.ts`**:
```javascript
// app/middleware.ts

import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(request: NextRequest) {
const allowedOrigins = [
"https://yourdomain.com",
"https://sub.yourdomain.com",
]
const origin = request.headers.get("Origin")

const response = NextResponse.next()

if (allowedOrigins.includes(origin || "")) {
response.headers.set("Access-Control-Allow-Origin", origin || "")
response.headers.set(
"Access-Control-Allow-Methods",
"GET, POST, PUT, DELETE, OPTIONS"
)
response.headers.set(
"Access-Control-Allow-Headers",
"Content-Type, Authorization"
)
// If credentials are needed:
// response.headers.set('Access-Control-Allow-Credentials', 'true');
}

// Handle preflight requests
if (request.method === "OPTIONS") {
return new Response(null, {
status: 204,
headers: response.headers,
})
}

return response
}

export const config = {
matcher: "/api/:path*", // Apply to all API routes
}
```
**Problem:**

- **`Access-Control-Allow-Origin: '*'`:** Umożliwia każdej stronie dostęp do API, potencjalnie pozwalając złośliwym serwisom na interakcję z Twoim API bez ograniczeń.
- **Szerokie zezwolenie na metody:** Zezwalanie na wszystkie metody może umożliwić atakującym wykonywanie niepożądanych operacji.

**Jak atakujący to wykorzystują:**

Atakujący mogą stworzyć złośliwe strony internetowe, które wysyłają żądania do Twojego API, potencjalnie wykorzystując funkcje takie jak pobieranie danych, manipulacja danymi lub wywoływanie niepożądanych akcji w imieniu uwierzytelnionych użytkowników.


{{#ref}}
../../pentesting-web/cors-bypass.md
{{#endref}}

### Ujawnienie kodu serwera po stronie klienta

Łatwo jest **użyć kodu wykorzystywanego przez serwer również w kodzie ujawnianym i używanym po stronie klienta**, najlepszym sposobem, aby upewnić się, że plik z kodem nigdy nie zostanie ujawniony po stronie klienta, jest użycie tego importu na początku pliku:
```js
import "server-only"
```
## Kluczowe pliki i ich role

### `middleware.ts` / `middleware.js`

**Lokalizacja:** Root projektu lub w katalogu `src/`.

**Cel:** Wykonuje kod w server-side serverless function przed przetworzeniem żądania, umożliwiając zadania takie jak uwierzytelnianie, przekierowania lub modyfikacja odpowiedzi.

**Przepływ wykonania:**

1. **Przychodzące żądanie:** middleware przechwytuje żądanie.
2. **Przetwarzanie:** Wykonuje operacje w oparciu o żądanie (np. sprawdź uwierzytelnienie).
3. **Modyfikacja odpowiedzi:** Może zmienić odpowiedź lub przekazać kontrolę do następnego handlera.

**Przykłady zastosowań:**

- Przekierowywanie niezalogowanych użytkowników.
- Dodawanie niestandardowych nagłówków.
- Rejestrowanie żądań.

**Przykładowa konfiguracja:**
```typescript
// middleware.ts
import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(req: NextRequest) {
const url = req.nextUrl.clone()
if (!req.cookies.has("token")) {
url.pathname = "/login"
return NextResponse.redirect(url)
}
return NextResponse.next()
}

export const config = {
matcher: ["/protected/:path*"],
}
```
### `next.config.js`

**Lokalizacja:** Katalog główny projektu.

**Cel:** Konfiguruje zachowanie Next.js, włączając lub wyłączając funkcje, dostosowując konfiguracje webpack, ustawiając zmienne środowiskowe oraz konfigurując kilka funkcji związanych z bezpieczeństwem.

**Kluczowe ustawienia bezpieczeństwa:**

<details>

<summary>Nagłówki bezpieczeństwa</summary>

Nagłówki bezpieczeństwa zwiększają ochronę aplikacji, instruując przeglądarki, jak obsługiwać zawartość. Pomagają łagodzić różne ataki, takie jak Cross-Site Scripting (XSS), Clickjacking i MIME type sniffing:

- Content Security Policy (CSP)
- X-Frame-Options
- X-Content-Type-Options
- Strict-Transport-Security (HSTS)
- Referrer Policy

**Przykłady:**
```javascript
// next.config.js

module.exports = {
async headers() {
return [
{
source: "/(.*)", // Apply to all routes
headers: [
{
key: "X-Frame-Options",
value: "DENY",
},
{
key: "Content-Security-Policy",
value:
"default-src *; script-src 'self' 'unsafe-inline' 'unsafe-eval';",
},
{
key: "X-Content-Type-Options",
value: "nosniff",
},
{
key: "Strict-Transport-Security",
value: "max-age=63072000; includeSubDomains; preload", // Enforces HTTPS
},
{
key: "Referrer-Policy",
value: "no-referrer", // Completely hides referrer
},
// Additional headers...
],
},
]
},
}
```
</details>

<details>

<summary>Ustawienia optymalizacji obrazów</summary>

Next.js optymalizuje obrazy pod kątem wydajności, ale błędne konfiguracje mogą prowadzić do luk bezpieczeństwa, takich jak umożliwienie niezaufanym źródłom wstrzyknięcia złośliwej zawartości.

**Zły przykład konfiguracji:**
```javascript
// next.config.js

module.exports = {
images: {
domains: ["*"], // Allows images from any domain
},
}
```
**Problem:**

- **`'*'`:** Zezwala na ładowanie obrazów z dowolnego zewnętrznego źródła, łącznie z niezaufanymi lub złośliwymi domenami. Atakujący mogą hostować obrazy zawierające złośliwe ładunki lub treści wprowadzające użytkowników w błąd.
- Innym problemem może być zezwolenie na domenę **na której każdy może przesłać obraz** (np. `raw.githubusercontent.com`)

**Jak atakujący to wykorzystują:**

Przez wstrzykiwanie obrazów z złośliwych źródeł, atakujący mogą przeprowadzać phishing, wyświetlać wprowadzające w błąd informacje lub wykorzystywać podatności w bibliotekach renderujących obrazy.

</details>

<details>

<summary>Ujawnianie zmiennych środowiskowych</summary>

Zarządzaj poufnymi informacjami, takimi jak API keys i database credentials, w sposób bezpieczny, nie ujawniając ich klientowi.

#### a. Ujawnianie poufnych zmiennych

**Przykład złej konfiguracji:**
```javascript
// next.config.js

module.exports = {
env: {
SECRET_API_KEY: process.env.SECRET_API_KEY, // Exposed to the client
NEXT_PUBLIC_API_URL: process.env.NEXT_PUBLIC_API_URL, // Correctly prefixed for client
},
}
```
**Problem:**

- **`SECRET_API_KEY`:** Bez prefiksu `NEXT_PUBLIC_` Next.js nie ujawnia zmiennych po stronie klienta. Jednak jeśli omyłkowo dodany jest prefiks (np. `NEXT_PUBLIC_SECRET_API_KEY`), staje się on dostępny po stronie klienta.

**Jak atakujący to wykorzystują:**

Jeżeli wrażliwe zmienne są ujawnione po stronie klienta, atakujący mogą je odzyskać poprzez analizę kodu po stronie klienta lub żądań sieciowych, uzyskując nieautoryzowany dostęp do API, baz danych lub innych usług.

</details>

<details>

<summary>Przekierowania</summary>

Zarządzaj przekierowaniami i rewrites URL w aplikacji, zapewniając, że użytkownicy są kierowani właściwie, bez wprowadzania podatności typu open redirect.

#### a. Open Redirect Vulnerability

**Przykład złej konfiguracji:**
```javascript
// next.config.js

module.exports = {
async redirects() {
return [
{
source: "/redirect",
destination: (req) => req.query.url, // Dynamically redirects based on query parameter
permanent: false,
},
]
},
}
```
**Problem:**

- **Dynamic Destination:** Pozwala użytkownikom określić dowolny URL, co umożliwia ataki typu open redirect.
- **Trusting User Input:** Przekierowania do URL-ów podanych przez użytkowników bez walidacji mogą prowadzić do phishing, malware distribution lub credential theft.

**How attackers abuse it:**

Atakujący mogą tworzyć URLs, które wydają się pochodzić z Twojej domeny, ale przekierowują użytkowników do złośliwych serwisów. Na przykład:
```bash
https://yourdomain.com/redirect?url=https://malicious-site.com
```
Użytkownicy ufający oryginalnej domenie mogą nieświadomie trafić na złośliwe strony.

</details>

<details>

<summary>Konfiguracja Webpack</summary>

Dostosowywanie konfiguracji Webpack dla aplikacji Next.js może niezamierzenie wprowadzić luki bezpieczeństwa, jeśli nie zostanie wykonane ostrożnie.

#### a. Ujawnianie wrażliwych modułów

**Przykład złej konfiguracji:**
```javascript
// next.config.js

module.exports = {
webpack: (config, { isServer }) => {
if (!isServer) {
config.resolve.alias["@sensitive"] = path.join(__dirname, "secret-folder")
}
return config
},
}
```
**Problem:**

- **Exposing Sensitive Paths:** Aliasowanie wrażliwych katalogów i umożliwienie dostępu po stronie klienta może leak poufnych informacji.
- **Bundling Secrets:** Jeśli wrażliwe pliki są zbundlowane dla klienta, ich zawartość staje się dostępna przez source maps lub poprzez inspekcję kodu po stronie klienta.

**How attackers abuse it:**

Atakujący mogą uzyskać dostęp lub odtworzyć strukturę katalogów aplikacji, potencjalnie znajdując i wykorzystując wrażliwe pliki lub dane.

</details>

### `pages/_app.js` and `pages/_document.js`

#### **`pages/_app.js`**

**Purpose:** Zastępuje domyślny komponent App, umożliwiając globalny stan, style i komponenty układu.

**Use Cases:**

- Wstrzykiwanie globalnego CSS.
- Dodawanie wrapperów układu.
- Integracja bibliotek zarządzania stanem.

**Example:**
```jsx
// pages/_app.js
import "../styles/globals.css"

function MyApp({ Component, pageProps }) {
return <Component {...pageProps} />
}

export default MyApp
```
#### **`pages/_document.js`**

**Purpose:** Nadpisuje domyślny Document, umożliwiając dostosowanie tagów HTML i Body.

**Use Cases:**

- Modyfikowanie tagów `<html>` lub `<body>`.
- Dodawanie meta tagów lub niestandardowych skryptów.
- Integracja czcionek zewnętrznych.

**Example:**
```jsx
// pages/_document.js
import Document, { Html, Head, Main, NextScript } from "next/document"

class MyDocument extends Document {
render() {
return (
<Html lang="en">
<Head>{/* Custom fonts or meta tags */}</Head>
<body>
<Main />
<NextScript />
</body>
</Html>
)
}
}

export default MyDocument
```
### Serwer niestandardowy (opcjonalnie)

**Cel:** Chociaż Next.js zawiera wbudowany serwer, możesz stworzyć serwer niestandardowy dla zaawansowanych przypadków użycia, takich jak niestandardowe routowanie lub integracja z istniejącymi usługami backendowymi.

**Uwaga:** Korzystanie z serwera niestandardowego może ograniczyć opcje wdrażania, szczególnie na platformach takich jak Vercel, które są zoptymalizowane pod wbudowany serwer Next.js.

**Przykład:**
```javascript
// server.js
const express = require("express")
const next = require("next")

const dev = process.env.NODE_ENV !== "production"
const app = next({ dev })
const handle = app.getRequestHandler()

app.prepare().then(() => {
const server = express()

// Custom route
server.get("/a", (req, res) => {
return app.render(req, res, "/a")
})

// Default handler
server.all("*", (req, res) => {
return handle(req, res)
})

server.listen(3000, (err) => {
if (err) throw err
console.log("> Ready on http://localhost:3000")
})
})
```
---

## Dodatkowe aspekty architektoniczne i bezpieczeństwa

### Zmienne środowiskowe i konfiguracja

**Cel:** Zarządzanie wrażliwymi informacjami i ustawieniami konfiguracyjnymi poza bazą kodu.

**Najlepsze praktyki:**

- **Używaj plików `.env`:** Przechowuj zmienne, takie jak klucze API, w `.env.local` (wyłączone z kontroli wersji).
- **Dostęp do zmiennych w bezpieczny sposób:** Używaj `process.env.VARIABLE_NAME` do odczytu zmiennych środowiskowych.
- **Nigdy nie ujawniaj sekretów po stronie klienta:** Upewnij się, że wrażliwe zmienne są używane wyłącznie po stronie serwera.

**Przykład:**
```javascript
// next.config.js
module.exports = {
env: {
API_KEY: process.env.API_KEY, // Accessible on both client and server
SECRET_KEY: process.env.SECRET_KEY, // Be cautious if accessible on the client
},
}
```
**Uwaga:** Aby ograniczyć zmienne tylko do strony serwera, usuń je z obiektu `env` lub poprzedź je prefiksem `NEXT_PUBLIC_`, aby udostępnić je klientowi.

### Uwierzytelnianie i autoryzacja

**Podejście:**

- **Uwierzytelnianie oparte na sesjach:** Użyj cookies do zarządzania sesjami użytkowników.
- **Uwierzytelnianie oparte na tokenach:** Zaimplementuj JWTs dla bezstanowego uwierzytelniania.
- **Dostawcy zewnętrzni:** Integruj z dostawcami OAuth (np. Google, GitHub) używając bibliotek takich jak `next-auth`.

**Praktyki bezpieczeństwa:**

- **Bezpieczne cookies:** Ustaw atrybuty `HttpOnly`, `Secure`, i `SameSite`.
- **Hashowanie haseł:** Zawsze haszuj hasła przed zapisaniem.
- **Walidacja danych wejściowych:** Zapobiegaj atakom typu injection przez walidację i sanitizację danych wejściowych.

**Przykład:**
```javascript
// pages/api/login.js
import { sign } from "jsonwebtoken"
import { serialize } from "cookie"

export default async function handler(req, res) {
const { username, password } = req.body

// Validate user credentials
if (username === "admin" && password === "password") {
const token = sign({ username }, process.env.JWT_SECRET, {
expiresIn: "1h",
})
res.setHeader(
"Set-Cookie",
serialize("auth", token, {
path: "/",
httpOnly: true,
secure: true,
sameSite: "strict",
})
)
res.status(200).json({ message: "Logged in" })
} else {
res.status(401).json({ error: "Invalid credentials" })
}
}
```
### Optymalizacja wydajności

**Strategie:**

- **Optymalizacja obrazów:** Użyj komponentu Next.js `next/image` do automatycznej optymalizacji obrazów.
- **Dzielenie kodu:** Wykorzystaj dynamiczne importy do dzielenia kodu i skrócenia czasu ładowania początkowego.
- **Buforowanie:** Wdrażaj strategie buforowania odpowiedzi API i statycznych zasobów.
- **Leniwe ładowanie:** Ładuj komponenty lub zasoby tylko wtedy, gdy są potrzebne.

**Przykład:**
```jsx
// Dynamic Import with Code Splitting
import dynamic from "next/dynamic"

const HeavyComponent = dynamic(() => import("../components/HeavyComponent"), {
loading: () => <p>Loading...</p>,
})
```
## Next.js Server Actions Enumeration (hash to function name via source maps)

Nowoczesny Next.js używa “Server Actions”, które wykonują się po stronie serwera, ale są wywoływane z klienta. W produkcji te wywołania są nieprzejrzyste: wszystkie POSTs trafiają na wspólny endpoint i są rozróżniane przez hash specyficzny dla builda wysyłany w nagłówku `Next-Action`. Przykład:
```http
POST /
Next-Action: a9f8e2b4c7d1...
```
Kiedy `productionBrowserSourceMaps` jest włączony, zminifikowane kawałki JS zawierają wywołania `createServerReference(...)`. Te wywołania leak enough structure (plus associated source maps), co pozwala odzyskać mapowanie między hashem akcji a oryginalną nazwą funkcji. To pozwala przetłumaczyć hashe zaobserwowane w `Next-Action` na konkretne cele, takie jak `deleteUserAccount()` czy `exportFinancialData()`.

### Extraction approach (regex on minified JS + optional source maps)

Przeszukaj pobrane kawałki JS pod kątem `createServerReference` i wyciągnij hash oraz symbol funkcji/źródła. Dwa użyteczne wzorce:
```regex
# Strict pattern for standard minification
createServerReference\)\"([a-f0-9]{40,})\",\w+\.callServer,void 0,\w+\.findSourceMapURL,\"([^\"]+)\"\)

# Flexible pattern handling various minification styles
createServerReference[^\"]*\"([a-f0-9]{40,})\"[^\"]*\"([^\"]+)\"\s*\)
```
- Grupa 1: hash akcji serwera (40+ znaków szesnastkowych)
- Grupa 2: symbol lub ścieżka, którą można rozwiązać do oryginalnej funkcji za pomocą source map, gdy jest dostępna

If the script advertises a source map (trailer comment `//# sourceMappingURL=<...>.map`), fetch it and resolve the symbol/path to the original function name.

### Praktyczny przebieg

- Pasywne wykrywanie podczas przeglądania: przechwytuj żądania z nagłówkami `Next-Action` i URL-ami chunków JS.
- Pobierz wskazane bundlery JS oraz towarzyszące pliki `*.map` (jeśli dostępne).
- Uruchom powyższe wyrażenie regularne (regex), aby zbudować słownik hash↔nazwa.
- Użyj słownika do ukierunkowania testów:
- Triage oparty na nazwach (np. `transferFunds`, `exportFinancialData`).
- Śledź pokrycie między buildami według nazwy funkcji (hashe rotują między buildami).

### Wykonywanie ukrytych akcji (żądanie oparte na szablonie)

Weź poprawne żądanie POST zaobserwowane w proxy jako szablon i zamień wartość `Next-Action`, aby wycelować w inną wykrytą akcję:
```http
# Before
Next-Action: a9f8e2b4c7d1

# After
Next-Action: b7e3f9a2d8c5
```
Odtwórz w Repeater i przetestuj autoryzację, walidację danych wejściowych oraz logikę biznesową inaczej nieosiągalnych akcji.

### Automatyzacja Burp

- NextjsServerActionAnalyzer (Burp extension) automatyzuje powyższe w Burp:
- Przeszukuje historię proxy w poszukiwaniu chunków JS, wyciąga wpisy `createServerReference(...)` i parsuje source maps, gdy są dostępne.
- Utrzymuje przeszukiwalny słownik hash↔function-name i usuwa duplikaty między buildami na podstawie nazwy funkcji.
- Może zlokalizować poprawny szablonowy POST i otworzyć gotową do wysłania zakładkę Repeater z zastąpionym hashem docelowej akcji.
- Repo: https://github.com/Adversis/NextjsServerActionAnalyzer

### Uwagi i ograniczenia

- Wymaga włączenia `productionBrowserSourceMaps` w produkcji, aby odzyskać nazwy z bundle'ów/source maps.
- Ujawnienie function-name samo w sobie nie jest podatnością; użyj go do kierowania odkrywaniem i testowania autoryzacji każdej akcji.

## Źródła

- [Pentesting Next.js Server Actions — A Burp Extension for Hash-to-Function Mapping](https://www.adversis.io/blogs/pentesting-next-js-server-actions)
- [NextjsServerActionAnalyzer (Burp extension)](https://github.com/Adversis/NextjsServerActionAnalyzer)

{{#include ../../banners/hacktricks-training.md}}
