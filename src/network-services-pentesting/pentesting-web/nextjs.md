# NextJS

{{#include ../../banners/hacktricks-training.md}}

## Architettura generale di un'applicazione Next.js

### Struttura tipica dei file

Un progetto Next.js standard segue una struttura specifica di file e directory che facilita funzionalità come routing, API endpoints e gestione degli asset statici. Ecco una disposizione tipica:
```lua
my-nextjs-app/
├── node_modules/
├── public/
│   ├── images/
│   │   └── logo.png
│   └── favicon.ico
├── app/
│   ├── api/
│   │   └── hello/
│   │       └── route.ts
│   ├── layout.tsx
│   ├── page.tsx
│   ├── about/
│   │   └── page.tsx
│   ├── dashboard/
│   │   ├── layout.tsx
│   │   └── page.tsx
│   ├── components/
│   │   ├── Header.tsx
│   │   └── Footer.tsx
│   ├── styles/
│   │   ├── globals.css
│   │   └── Home.module.css
│   └── utils/
│       └── api.ts
├── .env.local
├── next.config.js
├── tsconfig.json
├── package.json
├── README.md
└── yarn.lock / package-lock.json

```
### Directory e file principali

- **public/:** Ospita asset statici come immagini, font e altri file. I file qui sono accessibili al percorso root (`/`).
- **app/:** Directory centrale per le pages, i layout, i componenti e le API routes della tua applicazione. Adotta il paradigma **App Router**, consentendo funzionalità di routing avanzate e la segregazione tra componenti server-client.
- **app/layout.tsx:** Definisce il layout radice della tua applicazione, avvolgendo tutte le pagine e fornendo elementi UI coerenti come header, footer e barre di navigazione.
- **app/page.tsx:** Serve come punto di ingresso per la route root `/`, renderizzando la home page.
- **app/[route]/page.tsx:** Gestisce route statiche e dinamiche. Ogni cartella all'interno di `app/` rappresenta un segmento di route, e `page.tsx` in quelle cartelle corrisponde al componente della route.
- **app/api/:** Contiene API routes, permettendo di creare funzioni serverless che gestiscono richieste HTTP. Queste route sostituiscono la tradizionale directory `pages/api`.
- **app/components/:** Ospita componenti React riutilizzabili che possono essere impiegati nelle diverse pagine e layout.
- **app/styles/:** Contiene file CSS globali e CSS Modules per lo styling scope dei componenti.
- **app/utils/:** Include funzioni di utilità, moduli helper e altra logica non-UI che può essere condivisa nell'applicazione.
- **.env.local:** Memorizza variabili d'ambiente specifiche per l'ambiente di sviluppo locale. Queste variabili **non** vengono commesse al version control.
- **next.config.js:** Personalizza il comportamento di Next.js, incluse configurazioni webpack, variabili d'ambiente e impostazioni di sicurezza.
- **tsconfig.json:** Configura le impostazioni di TypeScript per il progetto, abilitando il type checking e altre funzionalità di TypeScript.
- **package.json:** Gestisce le dipendenze del progetto, gli script e i metadata.
- **README.md:** Fornisce documentazione e informazioni sul progetto, incluse istruzioni di setup, linee guida d'uso e altri dettagli rilevanti.
- **yarn.lock / package-lock.json:** Bloccano le dipendenze del progetto a versioni specifiche, garantendo installazioni coerenti tra diversi ambienti.

## Lato client in Next.js

### Routing basato sui file nella directory `app`

La directory `app` è la pietra angolare del routing nelle versioni più recenti di Next.js. Sfrutta il filesystem per definire le route, rendendo la gestione delle route intuitiva e scalabile.

<details>

<summary>Gestione del percorso root /</summary>

**File Structure:**
```arduino
my-nextjs-app/
├── app/
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**File chiave:**

- **`app/page.tsx`**: Gestisce le richieste al percorso root `/`.
- **`app/layout.tsx`**: Definisce il layout per l'applicazione, avvolgendo tutte le pagine.

**Implementazione:**
```tsx
tsxCopy code// app/page.tsx

export default function HomePage() {
return (
<div>
<h1>Welcome to the Home Page!</h1>
<p>This is the root route.</p>
</div>
);
}
```
**Spiegazione:**

- **Definizione della route:** Il file `page.tsx` direttamente sotto la directory `app` corrisponde alla route `/`.
- **Rendering:** Questo componente renderizza il contenuto della home page.
- **Integrazione del layout:** Il componente `HomePage` è avvolto da `layout.tsx`, che può includere intestazioni, piè di pagina e altri elementi comuni.

</details>

<details>

<summary>Gestione di altri percorsi statici</summary>

**Esempio: route `/about`**

**Struttura dei file:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── about/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementazione:**
```tsx
// app/about/page.tsx

export default function AboutPage() {
return (
<div>
<h1>About Us</h1>
<p>Learn more about our mission and values.</p>
</div>
)
}
```
**Spiegazione:**

- **Definizione della rotta:** Il file `page.tsx` dentro la cartella `about` corrisponde alla rotta `/about`.
- **Rendering:** Questo componente renderizza il contenuto della pagina about.

</details>

<details>

<summary>Route dinamiche</summary>

Le route dinamiche permettono di gestire percorsi con segmenti variabili, consentendo alle applicazioni di mostrare contenuti in base a parametri come ID, slug, ecc.

**Esempio: `/posts/[id]` rotta**

**Struttura dei file:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── posts/
│   │   └── [id]/
│   │       └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementazione:**
```tsx
tsxCopy code// app/posts/[id]/page.tsx

import { useRouter } from 'next/navigation';

interface PostProps {
params: { id: string };
}

export default function PostPage({ params }: PostProps) {
const { id } = params;
// Fetch post data based on 'id'

return (
<div>
<h1>Post #{id}</h1>
<p>This is the content of post {id}.</p>
</div>
);
}
```
**Spiegazione:**

- **Dynamic Segment:** `[id]` indica un segmento dinamico nella route, catturando il parametro `id` dall'URL.
- **Accessing Parameters:** L'oggetto `params` contiene i parametri dinamici, accessibili all'interno del componente.
- **Route Matching:** Qualsiasi percorso che corrisponde a `/posts/*`, come `/posts/1`, `/posts/abc`, ecc., sarà gestito da questo componente.

</details>

<details>

<summary>Routing annidato</summary>

Next.js supporta il routing annidato, consentendo strutture di route gerarchiche che rispecchiano la disposizione delle directory.

**Esempio: `/dashboard/settings/profile` Route**

**File Structure:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── dashboard/
│   │   ├── settings/
│   │   │   └── profile/
│   │   │       └── page.tsx
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementazione:**
```tsx
tsxCopy code// app/dashboard/settings/profile/page.tsx

export default function ProfileSettingsPage() {
return (
<div>
<h1>Profile Settings</h1>
<p>Manage your profile information here.</p>
</div>
);
}
```
**Spiegazione:**

- **Annidamento profondo:** Il file `page.tsx` all'interno di `dashboard/settings/profile/` corrisponde alla route `/dashboard/settings/profile`.
- **Riflessione della gerarchia:** La struttura delle directory riflette il percorso URL, migliorando la manutenibilità e la chiarezza.

</details>

<details>

<summary>Route Catch-All</summary>

Le route catch-all gestiscono segmenti annidati multipli o percorsi sconosciuti, offrendo flessibilità nella gestione delle route.

**Esempio: `/*` Route**

**Struttura dei file:**
```arduino
my-nextjs-app/
├── app/
│   ├── [...slug]/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementazione:**
```tsx
// app/[...slug]/page.tsx

interface CatchAllProps {
params: { slug: string[] }
}

export default function CatchAllPage({ params }: CatchAllProps) {
const { slug } = params
const fullPath = `/${slug.join("/")}`

return (
<div>
<h1>Catch-All Route</h1>
<p>You have navigated to: {fullPath}</p>
</div>
)
}
```
**Spiegazione:**

- **Catch-All Segment:** `[...slug]` cattura tutti i segmenti di percorso rimanenti come un array.
- **Usage:** Utile per gestire scenari di routing dinamico come percorsi generati dagli utenti, categorie annidate, ecc.
- **Route Matching:** Percorsi come `/anything/here`, `/foo/bar/baz`, ecc., sono gestiti da questo componente.

</details>

### Potenziali vulnerabilità lato client

Sebbene Next.js fornisca una base sicura, pratiche di sviluppo improprie possono introdurre vulnerabilità. Le principali vulnerabilità lato client includono:

<details>

<summary>Cross-Site Scripting (XSS)</summary>

XSS attacks occur when malicious scripts are injected into trusted websites. Attackers can execute scripts in users' browsers, stealing data or performing actions on behalf of the user.

**Esempio di codice vulnerabile:**
```jsx
// Dangerous: Injecting user input directly into HTML
function Comment({ userInput }) {
return <div dangerouslySetInnerHTML={{ __html: userInput }} />
}
```
**Perché è vulnerabile:** L'uso di `dangerouslySetInnerHTML` con input non attendibili permette agli attaccanti di iniettare script dannosi.

</details>

<details>

<summary>Client-Side Template Injection</summary>

Si verifica quando gli input degli utenti vengono gestiti in modo improprio nei template, consentendo agli attaccanti di iniettare ed eseguire template o espressioni.

**Esempio di codice vulnerabile:**
```jsx
import React from "react"
import ejs from "ejs"

function RenderTemplate({ template, data }) {
const html = ejs.render(template, data)
return <div dangerouslySetInnerHTML={{ __html: html }} />
}
```
**Perché è vulnerabile:** Se `template` o `data` includono contenuto malevolo, può portare all'esecuzione di codice non intenzionale.

</details>

<details>

<summary>Client Path Traversal</summary>

È una vulnerabilità che permette agli attaccanti di manipolare i percorsi lato client per eseguire azioni non intenzionali, come Cross-Site Request Forgery (CSRF). A differenza di server-side path traversal, che mira al filesystem del server, CSPT si concentra sullo sfruttamento dei meccanismi lato client per reindirizzare richieste API legittime verso endpoint malevoli.

**Esempio di codice vulnerabile:**

Un'applicazione Next.js consente agli utenti di caricare e scaricare file. La funzionalità di download è implementata lato client, dove gli utenti possono specificare il percorso del file da scaricare.
```jsx
// pages/download.js
import { useState } from "react"

export default function DownloadPage() {
const [filePath, setFilePath] = useState("")

const handleDownload = () => {
fetch(`/api/files/${filePath}`)
.then((response) => response.blob())
.then((blob) => {
const url = window.URL.createObjectURL(blob)
const a = document.createElement("a")
a.href = url
a.download = filePath
a.click()
})
}

return (
<div>
<h1>Download File</h1>
<input
type="text"
value={filePath}
onChange={(e) => setFilePath(e.target.value)}
placeholder="Enter file path"
/>
<button onClick={handleDownload}>Download</button>
</div>
)
}
```
#### Scenario d'attacco

1. **Attacker's Objective**: Eseguire un attacco CSRF per eliminare un file critico (ad es., `admin/config.json`) manipolando il `filePath`.
2. **Exploiting CSPT**:
- **Malicious Input**: L'attaccante crea un URL con un `filePath` manipolato, ad esempio `../deleteFile/config.json`.
- **Resulting API Call**: Il codice client-side effettua una richiesta a `/api/files/../deleteFile/config.json`.
- **Server's Handling**: Se il server non convalida il `filePath`, elabora la richiesta, potenzialmente eliminando o esponendo file sensibili.
3. **Executing CSRF**:
- **Crafted Link**: L'attaccante invia alla vittima un link o incorpora uno script malevolo che attiva la richiesta di download con il `filePath` manipolato.
- **Outcome**: La vittima esegue inconsapevolmente l'azione, portando ad accessi o eliminazioni non autorizzate di file.

#### Perché è vulnerabile

- **Lack of Input Validation**: Il client-side permette input arbitrari per `filePath`, abilitando path traversal.
- **Trusting Client Inputs**: L'API server-side si fida e processa il `filePath` senza sanitizzazione.
- **Potential API Actions**: Se l'endpoint API esegue azioni che cambiano lo stato (ad es., delete, modify files), può essere sfruttato tramite CSPT.

</details>

## Server-Side in Next.js

### Server-Side Rendering (SSR)

Pages are rendered on the server on each request, ensuring that the user receives fully rendered HTML. In this case you should create your own custom server to process the requests.

**Use Cases:**

- Dynamic content that changes frequently.
- SEO optimization, as search engines can crawl the fully rendered page.

**Implementation:**
```jsx
// pages/index.js
export async function getServerSideProps(context) {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data } }
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### Generazione statica del sito (SSG)

Le pagine vengono pre-renderizzate al momento della build, risultando in tempi di caricamento più rapidi e in un ridotto carico sul server.

**Casi d'uso:**

- Contenuti che non cambiano frequentemente.
- Blog, documentazione, pagine di marketing.

**Implementazione:**
```jsx
// pages/index.js
export async function getStaticProps() {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data }, revalidate: 60 } // Revalidate every 60 seconds
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### Funzioni Serverless (API Routes)

Next.js permette la creazione di endpoint API come funzioni serverless. Queste funzioni vengono eseguite on-demand senza la necessità di un server dedicato.

**Casi d'uso:**

- Gestione dell'invio dei moduli.
- Interazione con database.
- Elaborazione dei dati o integrazione con API di terze parti.

**Implementazione:**

Con l'introduzione della directory `app` in Next.js 13, il routing e la gestione delle API sono diventati più flessibili e potenti. Questo approccio moderno si allinea strettamente con il sistema di routing basato sui file ma introduce capacità avanzate, incluso il supporto per componenti server e client.

#### Gestore di route di base

**Struttura dei file:**
```go
my-nextjs-app/
├── app/
│   └── api/
│       └── hello/
│           └── route.js
├── package.json
└── ...
```
**Implementazione:**
```javascript
// app/api/hello/route.js

export async function POST(request) {
return new Response(JSON.stringify({ message: "Hello from App Router!" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

// Client-side fetch to access the API endpoint
fetch("/api/submit", {
method: "POST",
headers: { "Content-Type": "application/json" },
body: JSON.stringify({ name: "John Doe" }),
})
.then((res) => res.json())
.then((data) => console.log(data))
```
**Spiegazione:**

- **Posizione:** Le API routes sono posizionate nella directory `app/api/`.
- **Nome file:** Ogni endpoint API risiede in una propria cartella contenente un file `route.js` o `route.ts`.
- **Funzioni esportate:** Invece di un'unica export di default, vengono esportate funzioni specifiche per i metodi HTTP (es. `GET`, `POST`).
- **Gestione delle risposte:** Usa il costruttore `Response` per restituire le risposte, consentendo un maggiore controllo su header e codici di stato.

#### Come gestire altri percorsi e metodi:

<details>

<summary>Gestione di metodi HTTP specifici</summary>

Next.js 13+ permette di definire handler per metodi HTTP specifici all'interno dello stesso file `route.js` o `route.ts`, favorendo codice più chiaro e organizzato.

**Esempio:**
```javascript
// app/api/users/[id]/route.js

export async function GET(request, { params }) {
const { id } = params
// Fetch user data based on 'id'
return new Response(JSON.stringify({ userId: id, name: "Jane Doe" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function PUT(request, { params }) {
const { id } = params
// Update user data based on 'id'
return new Response(JSON.stringify({ message: `User ${id} updated.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function DELETE(request, { params }) {
const { id } = params
// Delete user based on 'id'
return new Response(JSON.stringify({ message: `User ${id} deleted.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**Spiegazione:**

- **Esportazioni multiple:** Ogni metodo HTTP (`GET`, `PUT`, `DELETE`) ha la propria funzione esportata.
- **Parametri:** Il secondo argomento fornisce accesso ai parametri della route tramite `params`.
- **Risposte avanzate:** Maggiore controllo sugli oggetti di risposta, permettendo una gestione precisa di header e status code.

</details>

<details>

<summary>Route catch-all e route annidate</summary>

Next.js 13+ supporta funzionalità di routing avanzate come catch-all routes e nested API routes, permettendo strutture API più dinamiche e scalabili.

**Esempio di route catch-all:**
```javascript
// app/api/[...slug]/route.js

export async function GET(request, { params }) {
const { slug } = params
// Handle dynamic nested routes
return new Response(JSON.stringify({ slug }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**Spiegazione:**

- **Sintassi:** `[...]` indica un segmento catch-all, che cattura tutti i percorsi annidati.
- **Uso:** Utile per API che devono gestire profondità di percorso variabili o segmenti dinamici.

**Esempio di rotte annidate:**
```javascript
// app/api/posts/[postId]/comments/[commentId]/route.js

export async function GET(request, { params }) {
const { postId, commentId } = params
// Fetch specific comment for a post
return new Response(
JSON.stringify({ postId, commentId, comment: "Great post!" }),
{
status: 200,
headers: { "Content-Type": "application/json" },
}
)
}
```
**Spiegazione:**

- **Deep Nesting:** Permette strutture API gerarchiche, riflettendo le relazioni tra le risorse.
- **Parameter Access:** Consente di accedere facilmente a più parametri di route tramite l'oggetto `params`.

</details>

<details>

<summary>Gestione delle API routes in Next.js 12 e versioni precedenti</summary>

## API Routes nella directory `pages` (Next.js 12 e versioni precedenti)

Prima che Next.js 13 introducesse la directory `app` e le funzionalità di routing avanzate, le API routes venivano principalmente definite nella directory `pages`. Questo approccio è ancora ampiamente utilizzato e supportato in Next.js 12 e nelle versioni precedenti.

#### Rotta API di base

**Struttura dei file:**
```go
goCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── hello.js
├── package.json
└── ...
```
**Implementazione:**
```javascript
javascriptCopy code// pages/api/hello.js

export default function handler(req, res) {
res.status(200).json({ message: 'Hello, World!' });
}
```
**Spiegazione:**

- **Location:** Le route API risiedono nella directory `pages/api/`.
- **Export:** Usa `export default` per definire la funzione handler.
- **Function Signature:** La funzione handler riceve gli oggetti `req` (HTTP request) e `res` (HTTP response).
- **Routing:** Il nome del file (`hello.js`) mappa all'endpoint `/api/hello`.

#### Rotte API dinamiche

**Struttura dei file:**
```bash
bashCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── users/
│           └── [id].js
├── package.json
└── ...
```
**Implementazione:**
```javascript
javascriptCopy code// pages/api/users/[id].js

export default function handler(req, res) {
const {
query: { id },
method,
} = req;

switch (method) {
case 'GET':
// Fetch user data based on 'id'
res.status(200).json({ userId: id, name: 'John Doe' });
break;
case 'PUT':
// Update user data based on 'id'
res.status(200).json({ message: `User ${id} updated.` });
break;
case 'DELETE':
// Delete user based on 'id'
res.status(200).json({ message: `User ${id} deleted.` });
break;
default:
res.setHeader('Allow', ['GET', 'PUT', 'DELETE']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**Spiegazione:**

- **Segmenti dinamici:** Le parentesi quadre (`[id].js`) indicano segmenti di route dinamici.
- **Accesso ai parametri:** Usa `req.query.id` per ottenere il parametro dinamico.
- **Gestione dei metodi:** Utilizza logica condizionale per gestire i diversi metodi HTTP (`GET`, `PUT`, `DELETE`, ecc.).

#### Gestione dei diversi metodi HTTP

Sebbene l'esempio base di API route gestisca tutti i metodi HTTP all'interno di una singola funzione, puoi strutturare il codice per gestire ciascun metodo esplicitamente per maggiore chiarezza e manutenibilità.

**Esempio:**
```javascript
javascriptCopy code// pages/api/posts.js

export default async function handler(req, res) {
const { method } = req;

switch (method) {
case 'GET':
// Handle GET request
res.status(200).json({ message: 'Fetching posts.' });
break;
case 'POST':
// Handle POST request
res.status(201).json({ message: 'Post created.' });
break;
default:
res.setHeader('Allow', ['GET', 'POST']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**Migliori pratiche:**

- **Separazione delle responsabilità:** Separa chiaramente la logica per i diversi metodi HTTP.
- **Coerenza delle risposte:** Assicurati che le strutture di risposta siano coerenti per facilitare la gestione lato client.
- **Gestione degli errori:** Gestisci in modo appropriato i metodi non supportati e gli errori inattesi.

</details>

### Configurazione CORS

Controlla quali origini possono accedere alle tue route API, mitigando le vulnerabilità di Cross-Origin Resource Sharing (CORS).

**Esempio di configurazione errata:**
```javascript
// app/api/data/route.js

export async function GET(request) {
return new Response(JSON.stringify({ data: "Public Data" }), {
status: 200,
headers: {
"Access-Control-Allow-Origin": "*", // Allows any origin
"Access-Control-Allow-Methods": "GET, POST, PUT, DELETE",
},
})
}
```
Nota che **CORS può anche essere configurato in tutte le API routes** all'interno del file **`middleware.ts`**:
```javascript
// app/middleware.ts

import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(request: NextRequest) {
const allowedOrigins = [
"https://yourdomain.com",
"https://sub.yourdomain.com",
]
const origin = request.headers.get("Origin")

const response = NextResponse.next()

if (allowedOrigins.includes(origin || "")) {
response.headers.set("Access-Control-Allow-Origin", origin || "")
response.headers.set(
"Access-Control-Allow-Methods",
"GET, POST, PUT, DELETE, OPTIONS"
)
response.headers.set(
"Access-Control-Allow-Headers",
"Content-Type, Authorization"
)
// If credentials are needed:
// response.headers.set('Access-Control-Allow-Credentials', 'true');
}

// Handle preflight requests
if (request.method === "OPTIONS") {
return new Response(null, {
status: 204,
headers: response.headers,
})
}

return response
}

export const config = {
matcher: "/api/:path*", // Apply to all API routes
}
```
**Problema:**

- **`Access-Control-Allow-Origin: '*'`:** Consente a qualsiasi sito web di accedere all'API, permettendo potenzialmente a siti maligni di interagire con la tua API senza restrizioni.
- **Permesso ampio dei metodi:** Consentire tutti i metodi può permettere agli attaccanti di eseguire azioni indesiderate.

**Come gli attaccanti lo sfruttano:**

Gli attaccanti possono creare siti web maligni che effettuano richieste alla tua API, abusando potenzialmente di funzionalità come il recupero di dati, la manipolazione di dati o l'attivazione di azioni indesiderate per conto di utenti autenticati.


{{#ref}}
../../pentesting-web/cors-bypass.md
{{#endref}}

### Esposizione del codice server nel lato client

Può essere facile **usare codice usato dal server anche nel codice esposto e usato dal lato client**, il modo migliore per assicurarsi che un file di codice non venga mai esposto nel lato client è utilizzare questo import all'inizio del file:
```js
import "server-only"
```
## File chiave e i loro ruoli

### `middleware.ts` / `middleware.js`

**Location:** Radice del progetto o all'interno di `src/`.

**Purpose:** Esegue codice nella funzione serverless lato server prima che una richiesta venga processata, permettendo operazioni come autenticazione, redirect o modifica delle risposte.

**Execution Flow:**

1. **Incoming Request:** Il middleware intercetta la richiesta.
2. **Processing:** Esegue operazioni basate sulla richiesta (es. verifica dell'autenticazione).
3. **Response Modification:** Può alterare la risposta o passare il controllo al prossimo gestore.

**Example Use Cases:**

- Reindirizzamento degli utenti non autenticati.
- Aggiunta di header personalizzati.
- Registrazione delle richieste.

**Sample Configuration:**
```typescript
// middleware.ts
import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(req: NextRequest) {
const url = req.nextUrl.clone()
if (!req.cookies.has("token")) {
url.pathname = "/login"
return NextResponse.redirect(url)
}
return NextResponse.next()
}

export const config = {
matcher: ["/protected/:path*"],
}
```
### `next.config.js`

**Posizione:** Radice del progetto.

**Scopo:** Configura il comportamento di Next.js, abilitando o disabilitando funzionalità, personalizzando le configurazioni di webpack, impostando variabili d'ambiente e configurando diverse funzionalità di sicurezza.

**Principali configurazioni di sicurezza:**

<details>

<summary>Intestazioni di sicurezza</summary>

Le intestazioni di sicurezza migliorano la protezione della tua applicazione istruendo i browser su come gestire i contenuti. Aiutano a mitigare vari attacchi come Cross-Site Scripting (XSS), Clickjacking e MIME type sniffing:

- Content Security Policy (CSP)
- X-Frame-Options
- X-Content-Type-Options
- Strict-Transport-Security (HSTS)
- Referrer Policy

**Esempi:**
```javascript
// next.config.js

module.exports = {
async headers() {
return [
{
source: "/(.*)", // Apply to all routes
headers: [
{
key: "X-Frame-Options",
value: "DENY",
},
{
key: "Content-Security-Policy",
value:
"default-src *; script-src 'self' 'unsafe-inline' 'unsafe-eval';",
},
{
key: "X-Content-Type-Options",
value: "nosniff",
},
{
key: "Strict-Transport-Security",
value: "max-age=63072000; includeSubDomains; preload", // Enforces HTTPS
},
{
key: "Referrer-Policy",
value: "no-referrer", // Completely hides referrer
},
// Additional headers...
],
},
]
},
}
```
</details>

<details>

<summary>Impostazioni di ottimizzazione delle immagini</summary>

Next.js ottimizza le immagini per le prestazioni, ma configurazioni errate possono portare a vulnerabilità di sicurezza, come permettere a fonti non attendibili di iniettare contenuti dannosi.

**Esempio di configurazione errata:**
```javascript
// next.config.js

module.exports = {
images: {
domains: ["*"], // Allows images from any domain
},
}
```
**Problema:**

- **`'*'`:** Consente il caricamento di immagini da qualsiasi sorgente esterna, inclusi domini non affidabili o dannosi. Attackers possono ospitare immagini contenenti payloads dannosi o contenuti che inducano in errore gli utenti.
- Un altro problema può essere consentire un dominio **dove chiunque può caricare un'immagine** (come `raw.githubusercontent.com`)

**Come gli attacker lo abusano:**

Inserendo immagini da sorgenti malicious, attackers possono effettuare attacchi di phishing, mostrare informazioni fuorvianti o exploitare vulnerabilità nelle librerie di rendering delle immagini.

</details>

<details>

<summary>Esposizione delle variabili d'ambiente</summary>

Gestire informazioni sensibili come chiavi API e credenziali del database in modo sicuro senza esporle al client.

#### a. Esposizione di variabili sensibili

**Esempio di cattiva configurazione:**
```javascript
// next.config.js

module.exports = {
env: {
SECRET_API_KEY: process.env.SECRET_API_KEY, // Exposed to the client
NEXT_PUBLIC_API_URL: process.env.NEXT_PUBLIC_API_URL, // Correctly prefixed for client
},
}
```
**Problema:**

- **`SECRET_API_KEY`:** Senza il prefisso `NEXT_PUBLIC_`, Next.js non espone le variabili al client. Tuttavia, se per errore viene prefissata (es. `NEXT_PUBLIC_SECRET_API_KEY`), diventa accessibile dal client.

**Come gli attaccanti lo sfruttano:**

Se variabili sensibili sono esposte al client, gli attaccanti possono recuperarle ispezionando il codice client-side o le richieste di rete, ottenendo accesso non autorizzato ad API, database o altri servizi.

</details>

<details>

<summary>Reindirizzamenti</summary>

Gestisci i redirect e le riscritture URL all'interno della tua applicazione, assicurandoti che gli utenti vengano indirizzati correttamente senza introdurre open redirect vulnerabilities.

#### a. Open Redirect Vulnerability

**Esempio di cattiva configurazione:**
```javascript
// next.config.js

module.exports = {
async redirects() {
return [
{
source: "/redirect",
destination: (req) => req.query.url, // Dynamically redirects based on query parameter
permanent: false,
},
]
},
}
```
**Problema:**

- **Destinazione dinamica:** Consente agli utenti di specificare qualsiasi URL, permettendo attacchi di open redirect.
- **Fidarsi dell'input dell'utente:** I redirect verso URL forniti dagli utenti senza validazione possono portare a phishing, malware distribution o credential theft.

**Come gli attaccanti lo sfruttano:**

Gli attaccanti possono creare URL che sembrano provenire dal tuo dominio ma reindirizzano gli utenti verso siti malevoli. Ad esempio:
```bash
https://yourdomain.com/redirect?url=https://malicious-site.com
```
Gli utenti che si fidano del dominio originale potrebbero navigare inconsapevolmente verso siti dannosi.

</details>

<details>

<summary>Webpack Configuration</summary>

Personalizza le configurazioni di Webpack per la tua applicazione Next.js, cosa che può introdurre involontariamente vulnerabilità di sicurezza se non gestita con cautela.

#### a. Esposizione di moduli sensibili

**Esempio di configurazione errata:**
```javascript
// next.config.js

module.exports = {
webpack: (config, { isServer }) => {
if (!isServer) {
config.resolve.alias["@sensitive"] = path.join(__dirname, "secret-folder")
}
return config
},
}
```
**Problema:**

- **Esposizione di percorsi sensibili:** La creazione di alias per directory sensibili e la loro esposizione al client possono causare leak di informazioni riservate.
- **Inclusione di segreti nei bundle:** Se file sensibili vengono inclusi nel bundle per il client, i loro contenuti diventano accessibili tramite source maps o ispezionando il codice client-side.

**How attackers abuse it:**

Attackers possono accedere o ricostruire la struttura delle directory dell'applicazione, potenzialmente trovando e sfruttando file o dati sensibili.

</details>

### `pages/_app.js` and `pages/_document.js`

#### **`pages/_app.js`**

**Purpose:** Sovrascrive il componente App di default, permettendo stato globale, stili e componenti di layout.

**Use Cases:**

- Iniettare CSS globale.
- Aggiungere wrapper di layout.
- Integrare librerie per la gestione dello stato.

**Esempio:**
```jsx
// pages/_app.js
import "../styles/globals.css"

function MyApp({ Component, pageProps }) {
return <Component {...pageProps} />
}

export default MyApp
```
#### **`pages/_document.js`**

**Scopo:** Sovrascrive il Document predefinito, permettendo la personalizzazione dei tag `<html>` e `<body>`.

**Casi d'uso:**

- Modificare i tag `<html>` o `<body>`.
- Aggiungere meta tag o script personalizzati.
- Integrare font di terze parti.

**Esempio:**
```jsx
// pages/_document.js
import Document, { Html, Head, Main, NextScript } from "next/document"

class MyDocument extends Document {
render() {
return (
<Html lang="en">
<Head>{/* Custom fonts or meta tags */}</Head>
<body>
<Main />
<NextScript />
</body>
</Html>
)
}
}

export default MyDocument
```
### Server personalizzato (opzionale)

**Scopo:** Sebbene Next.js includa un server integrato, puoi creare un server personalizzato per casi d'uso avanzati come il routing personalizzato o l'integrazione con servizi backend esistenti.

**Nota:** L'uso di un server personalizzato può limitare le opzioni di deployment, specialmente su piattaforme come Vercel che ottimizzano per il server integrato di Next.js.

**Esempio:**
```javascript
// server.js
const express = require("express")
const next = require("next")

const dev = process.env.NODE_ENV !== "production"
const app = next({ dev })
const handle = app.getRequestHandler()

app.prepare().then(() => {
const server = express()

// Custom route
server.get("/a", (req, res) => {
return app.render(req, res, "/a")
})

// Default handler
server.all("*", (req, res) => {
return handle(req, res)
})

server.listen(3000, (err) => {
if (err) throw err
console.log("> Ready on http://localhost:3000")
})
})
```
---

## Considerazioni aggiuntive sull'architettura e la sicurezza

### Variabili d'ambiente e configurazione

**Scopo:** Gestire informazioni sensibili e impostazioni di configurazione fuori dalla codebase.

**Migliori pratiche:**

- **Usare file `.env`:** Conservare variabili come API keys in `.env.local` (escluso dal controllo versione).
- **Accedere alle variabili in modo sicuro:** Usare `process.env.VARIABLE_NAME` per accedere alle variabili d'ambiente.
- **Non esporre mai i segreti sul client:** Assicurarsi che le variabili sensibili siano usate solo lato server.

**Esempio:**
```javascript
// next.config.js
module.exports = {
env: {
API_KEY: process.env.API_KEY, // Accessible on both client and server
SECRET_KEY: process.env.SECRET_KEY, // Be cautious if accessible on the client
},
}
```
**Nota:** Per limitare le variabili solo al lato server, omettile dall'oggetto `env` oppure aggiungi il prefisso `NEXT_PUBLIC_` per esporle al client.

### Autenticazione e Autorizzazione

**Approccio:**

- **Session-Based Authentication:** Usa i cookie per gestire le sessioni degli utenti.
- **Token-Based Authentication:** Implementa JWTs per un'autenticazione senza stato.
- **Third-Party Providers:** Integra con provider OAuth (es. Google, GitHub) usando librerie come `next-auth`.

**Pratiche di Sicurezza:**

- **Secure Cookies:** Imposta gli attributi `HttpOnly`, `Secure` e `SameSite`.
- **Password Hashing:** Esegui sempre l'hash delle password prima di memorizzarle.
- **Input Validation:** Previeni attacchi di injection validando e sanitizzando gli input.

**Esempio:**
```javascript
// pages/api/login.js
import { sign } from "jsonwebtoken"
import { serialize } from "cookie"

export default async function handler(req, res) {
const { username, password } = req.body

// Validate user credentials
if (username === "admin" && password === "password") {
const token = sign({ username }, process.env.JWT_SECRET, {
expiresIn: "1h",
})
res.setHeader(
"Set-Cookie",
serialize("auth", token, {
path: "/",
httpOnly: true,
secure: true,
sameSite: "strict",
})
)
res.status(200).json({ message: "Logged in" })
} else {
res.status(401).json({ error: "Invalid credentials" })
}
}
```
### Ottimizzazione delle prestazioni

**Strategie:**

- **Ottimizzazione delle immagini:** Usa il componente `next/image` di Next.js per l'ottimizzazione automatica delle immagini.
- **Suddivisione del codice:** Sfrutta gli import dinamici per suddividere il codice e ridurre i tempi di caricamento iniziale.
- **Caching:** Implementa strategie di caching per le risposte API e le risorse statiche.
- **Caricamento differito:** Carica componenti o risorse solo quando necessario.

**Esempio:**
```jsx
// Dynamic Import with Code Splitting
import dynamic from "next/dynamic"

const HeavyComponent = dynamic(() => import("../components/HeavyComponent"), {
loading: () => <p>Loading...</p>,
})
```
## Next.js Server Actions Enumeration (hash to function name via source maps)

Le moderne versioni di Next.js utilizzano le “Server Actions” che vengono eseguite sul server ma vengono invocate dal client. In produzione queste invocazioni sono opache: tutte le POST arrivano su un endpoint comune e sono distinte da un hash specifico della build inviato nell'header `Next-Action`. Esempio:
```http
POST /
Next-Action: a9f8e2b4c7d1...
```
Quando `productionBrowserSourceMaps` è abilitato, i chunk JS minimizzati contengono chiamate a `createServerReference(...)` che causano un leak di struttura sufficiente (più le source maps associate) per ricavare una mappatura tra l'hash dell'azione e il nome della funzione originale. Questo permette di tradurre gli hash osservati in `Next-Action` in obiettivi concreti come `deleteUserAccount()` o `exportFinancialData()`.

### Approccio di estrazione (regex sui JS minimizzati + source maps opzionali)

Cerca nei chunk JS scaricati `createServerReference` ed estrai l'hash e il function/source symbol. Due pattern utili:
```regex
# Strict pattern for standard minification
createServerReference\)"([a-f0-9]{40,})",\w+\.callServer,void 0,\w+\.findSourceMapURL,"([^"]+)"\)

# Flexible pattern handling various minification styles
createServerReference[^\"]*"([a-f0-9]{40,})"[^\"]*"([^"]+)"\s*\)
```
- Gruppo 1: server action hash (40+ hex chars)
- Gruppo 2: simbolo o percorso che può essere risolto al nome della funzione originale tramite la source map quando presente

Se lo script dichiara una source map (commento finale `//# sourceMappingURL=<...>.map`), scaricala e risolvi il simbolo/percorso al nome della funzione originale.

### Flusso pratico

- Scoperta passiva durante la navigazione: cattura le richieste con header `Next-Action` e gli URL dei chunk JS.
- Recupera i bundle JS referenziati e i relativi file `*.map` (quando presenti).
- Esegui la regex sopra per costruire un dizionario hash↔nome.
- Usa il dizionario per indirizzare i test:
- Triage basato sui nomi (es., `transferFunds`, `exportFinancialData`).
- Monitora la copertura tra le build per nome funzione (gli hash ruotano tra le build).

### Esecuzione di azioni nascoste (richiesta basata su template)

Prendi un POST valido osservato nel proxy come modello e sostituisci il valore `Next-Action` per puntare a un'altra action scoperta:
```http
# Before
Next-Action: a9f8e2b4c7d1

# After
Next-Action: b7e3f9a2d8c5
```
Esegui un replay in Repeater e testa authorization, input validation e business logic di azioni altrimenti non raggiungibili.

### Automazione Burp

- NextjsServerActionAnalyzer (Burp extension) automatizza quanto sopra in Burp:
- Scansiona la cronologia del proxy per JS chunks, estrae le voci `createServerReference(...)` e analizza gli source maps quando disponibili.
- Mantiene un dizionario ricercabile hash↔function-name e de-duplica across builds per nome della funzione.
- Può individuare un POST di template valido e aprire una scheda Repeater pronta per l'invio con l'hash dell'azione target sostituito.
- Repo: https://github.com/Adversis/NextjsServerActionAnalyzer

### Note e limitazioni

- Richiede `productionBrowserSourceMaps` abilitato in production per recuperare i nomi dai bundles/source maps.
- La divulgazione del function-name non è di per sé una vulnerabilità; usala per guidare la discovery e testare l'authorization di ogni action.

### RCE da deserializzazione del protocollo Flight di React Server Components (CVE-2025-55182)

Le deployment con App Router di Next.js che espongono Server Actions su `react-server-dom-webpack` **19.0.0–19.2.0 (Next.js 15.x/16.x)** contengono una critica prototype pollution lato server durante la deserializzazione dei chunk **Flight**. Costruendo riferimenti `$` all'interno di un payload Flight, un attaccante può pivotare da prototype polluted a esecuzione arbitraria di JavaScript e poi all'esecuzione di comandi OS all'interno del processo Node.js.

{{#ref}}
../../pentesting-web/deserialization/nodejs-proto-prototype-pollution/README.md
{{#endref}}

#### Catena d'attacco nei Flight chunks

1. **Prototype pollution primitive:** Imposta `"then": "$1:__proto__:then"` in modo che il resolver scriva una funzione `then` su `Object.prototype`. Qualsiasi oggetto plain processato successivamente diventa thenable, permettendo all'attaccante di influenzare il controllo asincrono all'interno degli internals di RSC.
2. **Rebinding to the global `Function` constructor:** Punta `_response._formData.get` su `"$1:constructor:constructor"`. Durante la risoluzione, `object.constructor` → `Object`, e `Object.constructor` → `Function`, quindi le chiamate future a `_formData.get()` eseguono in pratica `Function(...)`.
3. **Code execution via `_prefix`:** Inserisci il sorgente JavaScript in `_response._prefix`. Quando il `_formData.get` inquinato viene invocato, il framework valuta `Function(_prefix)(...)`, quindi il JS iniettato può eseguire `require('child_process').exec()` o qualsiasi altro primitivo Node.

#### Scheletro del payload
```json
{
"then": "$1:__proto__:then",
"status": "resolved_model",
"reason": -1,
"value": "{\"then\":\"$B1337\"}",
"_response": {
"_prefix": "require('child_process').exec('id')",
"_chunks": "$Q2",
"_formData": { "get": "$1:constructor:constructor" }
}
}
```
## Riferimenti

- [Pentesting Next.js Server Actions — A Burp Extension for Hash-to-Function Mapping](https://www.adversis.io/blogs/pentesting-next-js-server-actions)
- [NextjsServerActionAnalyzer (Burp extension)](https://github.com/Adversis/NextjsServerActionAnalyzer)
- [CVE-2025-55182 React Server Components Remote Code Execution Exploit Tool](https://github.com/Spritualkb/CVE-2025-55182-exp)

{{#include ../../banners/hacktricks-training.md}}
