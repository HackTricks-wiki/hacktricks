# NextJS

{{#include ../../banners/hacktricks-training.md}}

## Γενική Αρχιτεκτονική μιας Εφαρμογής Next.js

### Τυπική Δομή Αρχείων

Ένα τυπικό project Next.js ακολουθεί μια συγκεκριμένη δομή αρχείων και φακέλων που διευκολύνει λειτουργίες όπως routing, API endpoints και διαχείριση στατικών πόρων. Ακολουθεί μια τυπική διάταξη:
```lua
my-nextjs-app/
├── node_modules/
├── public/
│   ├── images/
│   │   └── logo.png
│   └── favicon.ico
├── app/
│   ├── api/
│   │   └── hello/
│   │       └── route.ts
│   ├── layout.tsx
│   ├── page.tsx
│   ├── about/
│   │   └── page.tsx
│   ├── dashboard/
│   │   ├── layout.tsx
│   │   └── page.tsx
│   ├── components/
│   │   ├── Header.tsx
│   │   └── Footer.tsx
│   ├── styles/
│   │   ├── globals.css
│   │   └── Home.module.css
│   └── utils/
│       └── api.ts
├── .env.local
├── next.config.js
├── tsconfig.json
├── package.json
├── README.md
└── yarn.lock / package-lock.json

```
### Κύριοι κατάλογοι και αρχεία

- **public/:** Φιλοξενεί στατικά assets όπως εικόνες, γραμματοσειρές και άλλα αρχεία. Τα αρχεία εδώ είναι προσβάσιμα στη ρίζα (`/`).
- **app/:** Κεντρικός κατάλογος για τις σελίδες της εφαρμογής σας, layouts, components και API routes. Υιοθετεί το παράδειγμα του **App Router**, επιτρέποντας προηγμένα χαρακτηριστικά δρομολόγησης και τον διαχωρισμό server-client components.
- **app/layout.tsx:** Ορίζει το root layout για την εφαρμογή σας, περιβάλλοντας όλες τις σελίδες και παρέχοντας συνεπή στοιχεία UI όπως επικεφαλίδες, υποσέλιδα και μπάρες πλοήγησης.
- **app/page.tsx:** Λειτουργεί ως σημείο εισόδου για τη ρίζα `/`, αποδίδοντας την αρχική σελίδα.
- **app/[route]/page.tsx:** Αντιμετωπίζει στατικές και δυναμικές διαδρομές. Κάθε φάκελος εντός του `app/` αντιπροσωπεύει ένα segment της διαδρομής, και το `page.tsx` μέσα σε αυτούς τους φακέλους αντιστοιχεί στο component της διαδρομής.
- **app/api/:** Περιέχει API routes, επιτρέποντάς σας να δημιουργήσετε serverless functions που χειρίζονται HTTP αιτήματα. Αυτές οι routes αντικαθιστούν τον παραδοσιακό κατάλογο `pages/api`.
- **app/components/:** Φιλοξενεί επαναχρησιμοποιήσιμα React components που μπορούν να χρησιμοποιηθούν σε διαφορετικές σελίδες και layouts.
- **app/styles/:** Περιέχει παγκόσμια αρχεία CSS και CSS Modules για styling σε επίπεδο component.
- **app/utils/:** Περιλαμβάνει utility functions, helper modules και άλλη μη UI λογική που μπορεί να μοιραστεί σε όλη την εφαρμογή.
- **.env.local:** Αποθηκεύει μεταβλητές περιβάλλοντος συγκεκριμένες για το τοπικό περιβάλλον ανάπτυξης. Αυτές οι μεταβλητές **δεν** δεσμεύονται στο version control.
- **next.config.js:** Προσαρμόζει τη συμπεριφορά του Next.js, συμπεριλαμβανομένων των ρυθμίσεων webpack, μεταβλητών περιβάλλοντος και ρυθμίσεων ασφαλείας.
- **tsconfig.json:** Ρυθμίζει τις επιλογές TypeScript για το έργο, ενεργοποιώντας τον έλεγχο τύπων και άλλα χαρακτηριστικά TypeScript.
- **package.json:** Διαχειρίζεται τις εξαρτήσεις του έργου, scripts και μεταδεδομένα.
- **README.md:** Παρέχει τεκμηρίωση και πληροφορίες για το έργο, συμπεριλαμβανομένων οδηγιών εγκατάστασης, οδηγιών χρήσης και άλλων σχετικών λεπτομερειών.
- **yarn.lock / package-lock.json:** Κλειδώνουν τις εξαρτήσεις του έργου σε συγκεκριμένες εκδόσεις, εξασφαλίζοντας συνεπείς εγκαταστάσεις σε διαφορετικά περιβάλλοντα.

## Client-side στο Next.js

### File-Based Routing in the `app` Directory

Ο κατάλογος `app` είναι ο ακρογωνιαίος λίθος της δρομολόγησης στις νεότερες εκδόσεις του Next.js. Εκμεταλλεύεται το filesystem για να ορίσει routes, καθιστώντας τη διαχείριση διαδρομών διαισθητική και κλιμακούμενη.

<details>

<summary>Διαχείριση της ριζικής διαδρομής /</summary>

**Δομή Αρχείων:**
```arduino
my-nextjs-app/
├── app/
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Βασικά αρχεία:**

- **`app/page.tsx`**: Χειρίζεται αιτήματα στη ρίζα (`/`).
- **`app/layout.tsx`**: Ορίζει τη διάταξη της εφαρμογής, περιβάλλοντας όλες τις σελίδες.

**Υλοποίηση:**
```tsx
tsxCopy code// app/page.tsx

export default function HomePage() {
return (
<div>
<h1>Welcome to the Home Page!</h1>
<p>This is the root route.</p>
</div>
);
}
```
**Επεξήγηση:**

- **Ορισμός διαδρομής:** Το αρχείο `page.tsx` απευθείας κάτω από τον κατάλογο `app` αντιστοιχεί στη διαδρομή `/`.
- **Απόδοση:** Αυτό το component αποδίδει το περιεχόμενο για την αρχική σελίδα.
- **Ενσωμάτωση διάταξης:** Το component `HomePage` περικλείεται από το `layout.tsx`, το οποίο μπορεί να περιλαμβάνει επικεφαλίδες, υποσέλιδα και άλλα κοινά στοιχεία.

</details>

<details>

<summary>Χειρισμός άλλων στατικών διαδρομών</summary>

**Παράδειγμα: διαδρομή `/about`**

**Δομή Αρχείων:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── about/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Υλοποίηση:**
```tsx
// app/about/page.tsx

export default function AboutPage() {
return (
<div>
<h1>About Us</h1>
<p>Learn more about our mission and values.</p>
</div>
)
}
```
**Εξήγηση:**

- **Ορισμός Διαδρομής:** Το αρχείο `page.tsx` μέσα στον φάκελο `about` αντιστοιχεί στη διαδρομή `/about`.
- **Rendering:** Αυτό το component αποδίδει το περιεχόμενο για τη σελίδα about.

</details>

<details>

<summary>Δυναμικές Διαδρομές</summary>

Οι δυναμικές διαδρομές επιτρέπουν την επεξεργασία μονοπατιών με μεταβλητά τμήματα, επιτρέποντας στις εφαρμογές να εμφανίζουν περιεχόμενο βασισμένο σε παραμέτρους όπως IDs, slugs κ.λπ.

**Παράδειγμα: `/posts/[id]` Διαδρομή**

**Δομή Αρχείων:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── posts/
│   │   └── [id]/
│   │       └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Υλοποίηση:**
```tsx
tsxCopy code// app/posts/[id]/page.tsx

import { useRouter } from 'next/navigation';

interface PostProps {
params: { id: string };
}

export default function PostPage({ params }: PostProps) {
const { id } = params;
// Fetch post data based on 'id'

return (
<div>
<h1>Post #{id}</h1>
<p>This is the content of post {id}.</p>
</div>
);
}
```
**Επεξήγηση:**

- **Dynamic Segment:** `[id]` δηλώνει ένα δυναμικό τμήμα στη διαδρομή, καταγράφοντας την παράμετρο `id` από το URL.
- **Accessing Parameters:** Το αντικείμενο `params` περιέχει τις δυναμικές παραμέτρους, προσβάσιμες εντός του component.
- **Route Matching:** Οποιοδήποτε μονοπάτι που ταιριάζει με `/posts/*`, όπως `/posts/1`, `/posts/abc`, κ.λπ., θα χειρίζεται αυτό το component.

</details>

<details>

<summary>Ενσωματωμένες Διαδρομές</summary>

Next.js υποστηρίζει εμφωλευμένη δρομολόγηση, επιτρέποντας ιεραρχικές δομές διαδρομών που αντικατοπτρίζουν τη διάταξη των καταλόγων.

**Παράδειγμα: `/dashboard/settings/profile` Διαδρομή**

**Δομή Αρχείων:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── dashboard/
│   │   ├── settings/
│   │   │   └── profile/
│   │   │       └── page.tsx
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Υλοποίηση:**
```tsx
tsxCopy code// app/dashboard/settings/profile/page.tsx

export default function ProfileSettingsPage() {
return (
<div>
<h1>Profile Settings</h1>
<p>Manage your profile information here.</p>
</div>
);
}
```
**Επεξήγηση:**

- **Βαθιά εμφώλευση:** Το αρχείο `page.tsx` μέσα στο `dashboard/settings/profile/` αντιστοιχεί στη διαδρομή `/dashboard/settings/profile`.
- **Αντανάκλαση ιεραρχίας:** Η δομή των φακέλων αντικατοπτρίζει τη διαδρομή URL, βελτιώνοντας τη συντηρησιμότητα και την ευκρίνεια.

</details>

<details>

<summary>Διαδρομές Catch-All</summary>

Οι διαδρομές Catch-All χειρίζονται πολλαπλά εμφωλευμένα τμήματα ή άγνωστες διαδρομές, προσφέροντας ευελιξία στον χειρισμό διαδρομών.

**Παράδειγμα: `/*` Διαδρομή**

**Δομή αρχείων:**
```arduino
my-nextjs-app/
├── app/
│   ├── [...slug]/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Υλοποίηση:**
```tsx
// app/[...slug]/page.tsx

interface CatchAllProps {
params: { slug: string[] }
}

export default function CatchAllPage({ params }: CatchAllProps) {
const { slug } = params
const fullPath = `/${slug.join("/")}`

return (
<div>
<h1>Catch-All Route</h1>
<p>You have navigated to: {fullPath}</p>
</div>
)
}
```
**Επεξήγηση:**

- **Τμήμα Catch-All:** `[...slug]` συλλαμβάνει όλα τα υπόλοιπα τμήματα διαδρομής ως πίνακα.
- **Χρήση:** Χρήσιμο για το χειρισμό δυναμικών σεναρίων δρομολόγησης όπως διαδρομές που δημιουργούνται από χρήστες, εμφωλευμένες κατηγορίες κ.λπ.
- **Αντιστοίχιση Διαδρομών:** Διαδρομές όπως `/anything/here`, `/foo/bar/baz`, κ.λπ., χειρίζονται από αυτό το συστατικό.

</details>

### Πιθανές ευπάθειες στην πλευρά του πελάτη

Ενώ το Next.js παρέχει ένα ασφαλές θεμέλιο, λανθασμένες πρακτικές κωδικοποίησης μπορούν να εισαγάγουν ευπάθειες. Κύριες ευπάθειες στην πλευρά του πελάτη περιλαμβάνουν:

<details>

<summary>Cross-Site Scripting (XSS)</summary>

Οι επιθέσεις Cross-Site Scripting (XSS) συμβαίνουν όταν κακόβουλα scripts εγχέονται σε αξιόπιστους ιστότοπους. Οι επιτιθέμενοι μπορούν να εκτελέσουν scripts στο πρόγραμμα περιήγησης των χρηστών, κλέβοντας δεδομένα ή πραγματοποιώντας ενέργειες εκ μέρους του χρήστη.

**Παράδειγμα Ευάλωτου Κώδικα:**
```jsx
// Dangerous: Injecting user input directly into HTML
function Comment({ userInput }) {
return <div dangerouslySetInnerHTML={{ __html: userInput }} />
}
```
**Γιατί είναι ευάλωτο:** Η χρήση του `dangerouslySetInnerHTML` με μη αξιόπιστη είσοδο επιτρέπει σε επιτιθέμενους να εισάγουν κακόβουλα scripts.

</details>

<details>

<summary>Client-Side Template Injection</summary>

Συμβαίνει όταν οι εισροές χρηστών χειρίζονται λανθασμένα σε πρότυπα, επιτρέποντας σε επιτιθέμενους να εισάγουν και να εκτελέσουν πρότυπα ή εκφράσεις.

**Παράδειγμα ευάλωτου κώδικα:**
```jsx
import React from "react"
import ejs from "ejs"

function RenderTemplate({ template, data }) {
const html = ejs.render(template, data)
return <div dangerouslySetInnerHTML={{ __html: html }} />
}
```
**Γιατί είναι ευάλωτο:** If `template` or `data` includes malicious content, it can lead to execution of unintended code.

</details>

<details>

<summary>Client Path Traversal</summary>

Είναι μια ευπάθεια που επιτρέπει σε επιτιθέμενους να χειραγωγήσουν client-side paths για να εκτελέσουν μη επιθυμητές ενέργειες, όπως Cross-Site Request Forgery (CSRF). Σε αντίθεση με το server-side path traversal, που στοχεύει το filesystem του server, το CSPT επικεντρώνεται στην εκμετάλλευση μηχανισμών client-side για να αναδρομολογήσει νόμιμα API requests προς κακόβουλα endpoints.

**Παράδειγμα Ευάλωτου Κώδικα:**

Μια Next.js εφαρμογή επιτρέπει στους χρήστες να κάνουν upload και download αρχείων. Η λειτουργία download υλοποιείται στην client side, όπου οι χρήστες μπορούν να καθορίσουν το file path που θέλουν να κατεβάσουν.
```jsx
// pages/download.js
import { useState } from "react"

export default function DownloadPage() {
const [filePath, setFilePath] = useState("")

const handleDownload = () => {
fetch(`/api/files/${filePath}`)
.then((response) => response.blob())
.then((blob) => {
const url = window.URL.createObjectURL(blob)
const a = document.createElement("a")
a.href = url
a.download = filePath
a.click()
})
}

return (
<div>
<h1>Download File</h1>
<input
type="text"
value={filePath}
onChange={(e) => setFilePath(e.target.value)}
placeholder="Enter file path"
/>
<button onClick={handleDownload}>Download</button>
</div>
)
}
```
#### Σενάριο Επίθεσης

1. **Στόχος του Επιτιθέμενου**: Εκτέλεση μιας CSRF επίθεσης για διαγραφή ενός κρίσιμου αρχείου (π.χ., `admin/config.json`) με παραβίαση του `filePath`.
2. **Εκμετάλλευση CSPT**:
- **Κακόβουλη Είσοδος**: Ο επιτιθέμενος δημιουργεί ένα URL με παραποιημένο `filePath`, όπως `../deleteFile/config.json`.
- **Αποτέλεσμα κλήσης API**: Ο client-side κώδικας κάνει αίτημα στο `/api/files/../deleteFile/config.json`.
- **Χειρισμός από τον διακομιστή**: Εάν ο διακομιστής δεν επικυρώνει το `filePath`, επεξεργάζεται το αίτημα, ενδεχομένως διαγράφοντας ή αποκαλύπτοντας ευαίσθητα αρχεία.
3. **Εκτέλεση CSRF**:
- **Κατασκευασμένος σύνδεσμος**: Ο επιτιθέμενος στέλνει στο θύμα έναν σύνδεσμο ή ενσωματώνει ένα κακόβουλο script που ενεργοποιεί το αίτημα λήψης με το παραποιημένο `filePath`.
- **Αποτέλεσμα**: Το θύμα εκτελεί ασυνείδητα τη δράση, οδηγώντας σε μη εξουσιοδοτημένη πρόσβαση ή διαγραφή αρχείων.

#### Γιατί είναι ευάλωτο

- **Έλλειψη επικύρωσης εισόδου**: Ο client-side επιτρέπει αυθαίρετες εισόδους `filePath`, επιτρέποντας path traversal.
- **Εμπιστοσύνη στις εισόδους του client**: Το server-side API εμπιστεύεται και επεξεργάζεται το `filePath` χωρίς sanitization.
- **Πιθανές ενέργειες API**: Εάν το API endpoint εκτελεί αλλαγές κατάστασης (π.χ., διαγραφή, τροποποίηση αρχείων), μπορεί να εκμεταλλευτεί μέσω CSPT.

</details>

## Server-Side στο Next.js

### Server-Side Rendering (SSR)

Οι σελίδες αποδίδονται στον διακομιστή σε κάθε αίτημα, διασφαλίζοντας ότι ο χρήστης λαμβάνει πλήρως αποδομένη HTML. Σε αυτή την περίπτωση θα πρέπει να δημιουργήσετε τον δικό σας custom server για την επεξεργασία των αιτημάτων.

**Περιπτώσεις Χρήσης:**

- Δυναμικό περιεχόμενο που αλλάζει συχνά.
- Βελτιστοποίηση SEO, καθώς οι μηχανές αναζήτησης μπορούν να ανιχνεύσουν τη σελίδα με πλήρως αποδομένη HTML.

**Υλοποίηση:**
```jsx
// pages/index.js
export async function getServerSideProps(context) {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data } }
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### Στατική δημιουργία ιστοτόπου (SSG)

Οι σελίδες προκατασκευάζονται κατά το χρόνο κατασκευής, με αποτέλεσμα ταχύτερους χρόνους φόρτωσης και μειωμένο φόρτο στον διακομιστή.

**Περιπτώσεις χρήσης:**

- Περιεχόμενο που δεν αλλάζει συχνά.
- Ιστολόγια, τεκμηρίωση, σελίδες μάρκετινγκ.

**Υλοποίηση:**
```jsx
// pages/index.js
export async function getStaticProps() {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data }, revalidate: 60 } // Revalidate every 60 seconds
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### Serverless Functions (API Routes)

Το Next.js επιτρέπει τη δημιουργία API endpoints ως serverless functions. Αυτές οι συναρτήσεις εκτελούνται κατά απαίτηση χωρίς την ανάγκη για έναν αφιερωμένο server.

**Use Cases:**

- Διαχείριση υποβολών φορμών.
- Αλληλεπίδραση με βάσεις δεδομένων.
- Επεξεργασία δεδομένων ή ενσωμάτωση με APIs τρίτων.

**Implementation:**

Με την εισαγωγή του `app` directory στο Next.js 13, το routing και ο χειρισμός των API έγιναν πιο ευέλικτα και ισχυρά. Αυτή η σύγχρονη προσέγγιση ευθυγραμμίζεται στενά με το file-based routing system αλλά εισάγει βελτιωμένες δυνατότητες, συμπεριλαμβανομένης της υποστήριξης για server και client components.

#### Basic Route Handler

**File Structure:**
```go
my-nextjs-app/
├── app/
│   └── api/
│       └── hello/
│           └── route.js
├── package.json
└── ...
```
**Υλοποίηση:**
```javascript
// app/api/hello/route.js

export async function POST(request) {
return new Response(JSON.stringify({ message: "Hello from App Router!" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

// Client-side fetch to access the API endpoint
fetch("/api/submit", {
method: "POST",
headers: { "Content-Type": "application/json" },
body: JSON.stringify({ name: "John Doe" }),
})
.then((res) => res.json())
.then((data) => console.log(data))
```
**Επεξήγηση:**

- **Τοποθεσία:** Οι API routes τοποθετούνται κάτω από τον κατάλογο `app/api/`.
- **Ονομασία αρχείων:** Κάθε API endpoint βρίσκεται σε ξεχωριστό φάκελο που περιέχει ένα αρχείο `route.js` ή `route.ts`.
- **Εξαγόμενες Συναρτήσεις:** Αντί για ένα ενιαίο default export, εξάγονται συγκεκριμένες συναρτήσεις για HTTP μεθόδους (π.χ. `GET`, `POST`).
- **Επεξεργασία Απαντήσεων:** Χρησιμοποιήστε τον constructor `Response` για να επιστρέψετε απαντήσεις, επιτρέποντας μεγαλύτερο έλεγχο πάνω στα headers και τους κωδικούς κατάστασης.

#### Πώς να χειριστείτε άλλες διαδρομές και μεθόδους:

<details>

<summary>Χειρισμός συγκεκριμένων HTTP μεθόδων</summary>

Next.js 13+ σας επιτρέπει να ορίσετε handlers για συγκεκριμένες HTTP μεθόδους μέσα στο ίδιο αρχείο `route.js` ή `route.ts`, προάγοντας πιο καθαρό και οργανωμένο κώδικα.

**Παράδειγμα:**
```javascript
// app/api/users/[id]/route.js

export async function GET(request, { params }) {
const { id } = params
// Fetch user data based on 'id'
return new Response(JSON.stringify({ userId: id, name: "Jane Doe" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function PUT(request, { params }) {
const { id } = params
// Update user data based on 'id'
return new Response(JSON.stringify({ message: `User ${id} updated.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function DELETE(request, { params }) {
const { id } = params
// Delete user based on 'id'
return new Response(JSON.stringify({ message: `User ${id} deleted.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**Επεξήγηση:**

- **Πολλαπλές Εξαγωγές:** Κάθε HTTP μέθοδος (`GET`, `PUT`, `DELETE`) έχει τη δική της εξαγόμενη συνάρτηση.
- **Παράμετροι:** Το δεύτερο όρισμα παρέχει πρόσβαση σε παραμέτρους διαδρομής μέσω του `params`.
- **Ενισχυμένες Απαντήσεις:** Μεγαλύτερος έλεγχος στα αντικείμενα απόκρισης, επιτρέποντας ακριβή διαχείριση επικεφαλίδων και κωδικών κατάστασης.

</details>

<details>

<summary>Catch-All και Nested Routes</summary>

Next.js 13+ υποστηρίζει προηγμένες δυνατότητες δρομολόγησης όπως catch-all routes και nested API routes, επιτρέποντας πιο δυναμικές και επεκτάσιμες δομές API.

**Catch-All Route Example:**
```javascript
// app/api/[...slug]/route.js

export async function GET(request, { params }) {
const { slug } = params
// Handle dynamic nested routes
return new Response(JSON.stringify({ slug }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**Επεξήγηση:**

- **Σύνταξη:** `[...]` δηλώνει ένα τμήμα catch-all, που συλλαμβάνει όλες τις εμφωλευμένες διαδρομές.
- **Χρήση:** Χρήσιμο για APIs που πρέπει να χειριστούν διαδρομές με μεταβαλλόμενο βάθος ή δυναμικά τμήματα.

**Παράδειγμα εμφωλευμένων routes:**
```javascript
// app/api/posts/[postId]/comments/[commentId]/route.js

export async function GET(request, { params }) {
const { postId, commentId } = params
// Fetch specific comment for a post
return new Response(
JSON.stringify({ postId, commentId, comment: "Great post!" }),
{
status: 200,
headers: { "Content-Type": "application/json" },
}
)
}
```
**Επεξήγηση:**

- **Βαθιά εμφώλευση:** Επιτρέπει ιεραρχικές δομές API, αντικατοπτρίζοντας τις σχέσεις μεταξύ πόρων.
- **Πρόσβαση σε παραμέτρους:** Επιτρέπει εύκολη πρόσβαση σε πολλαπλές παραμέτρους διαδρομής μέσω του αντικειμένου `params`.

</details>

<details>

<summary>Διαχείριση API routes σε Next.js 12 και παλαιότερες εκδόσεις</summary>

## Διαδρομές API στον φάκελο `pages` (Next.js 12 και παλαιότερες εκδόσεις)

Πριν το Next.js 13 εισαγάγει τον φάκελο `app` και βελτιώσει τις δυνατότητες δρομολόγησης, οι διαδρομές API ορίζονταν κυρίως μέσα στον φάκελο `pages`. Αυτή η προσέγγιση εξακολουθεί να χρησιμοποιείται ευρέως και υποστηρίζεται στις εκδόσεις Next.js 12 και παλαιότερες.

#### Βασική διαδρομή API

**Δομή αρχείων:**
```go
goCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── hello.js
├── package.json
└── ...
```
**Υλοποίηση:**
```javascript
javascriptCopy code// pages/api/hello.js

export default function handler(req, res) {
res.status(200).json({ message: 'Hello, World!' });
}
```
**Επεξήγηση:**

- **Τοποθεσία:** Οι διαδρομές API βρίσκονται στον κατάλογο `pages/api/`.
- **Εξαγωγή:** Χρησιμοποιήστε `export default` για να ορίσετε τη συνάρτηση χειριστή.
- **Υπογραφή Συνάρτησης:** Ο χειριστής λαμβάνει τα αντικείμενα `req` (HTTP request) και `res` (HTTP response).
- **Δρομολόγηση:** Το όνομα αρχείου (`hello.js`) αντιστοιχίζεται στο endpoint `/api/hello`.

#### Δυναμικές Διαδρομές API

**Δομή Αρχείων:**
```bash
bashCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── users/
│           └── [id].js
├── package.json
└── ...
```
**Υλοποίηση:**
```javascript
javascriptCopy code// pages/api/users/[id].js

export default function handler(req, res) {
const {
query: { id },
method,
} = req;

switch (method) {
case 'GET':
// Fetch user data based on 'id'
res.status(200).json({ userId: id, name: 'John Doe' });
break;
case 'PUT':
// Update user data based on 'id'
res.status(200).json({ message: `User ${id} updated.` });
break;
case 'DELETE':
// Delete user based on 'id'
res.status(200).json({ message: `User ${id} deleted.` });
break;
default:
res.setHeader('Allow', ['GET', 'PUT', 'DELETE']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**Επεξήγηση:**

- **Δυναμικά Τμήματα:** Οι τετράγωνες αγκύλες (`[id].js`) δηλώνουν δυναμικά τμήματα διαδρομής.
- **Πρόσβαση σε Παραμέτρους:** Χρησιμοποιήστε `req.query.id` για να προσπελάσετε τη δυναμική παράμετρο.
- **Χειρισμός Μεθόδων:** Χρησιμοποιήστε συνθήκη λογικής για να χειριστείτε διαφορετικές HTTP μεθόδους (`GET`, `PUT`, `DELETE`, κ.λπ.).

#### Χειρισμός Διαφορετικών HTTP Μεθόδων

Ενώ το βασικό παράδειγμα API route χειρίζεται όλες τις HTTP μεθόδους μέσα σε μία συνάρτηση, μπορείτε να δομήσετε τον κώδικά σας ώστε να χειρίζεται κάθε μέθοδο ρητά για καλύτερη σαφήνεια και συντηρησιμότητα.

**Παράδειγμα:**
```javascript
javascriptCopy code// pages/api/posts.js

export default async function handler(req, res) {
const { method } = req;

switch (method) {
case 'GET':
// Handle GET request
res.status(200).json({ message: 'Fetching posts.' });
break;
case 'POST':
// Handle POST request
res.status(201).json({ message: 'Post created.' });
break;
default:
res.setHeader('Allow', ['GET', 'POST']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**Καλές Πρακτικές:**

- **Διαχωρισμός Ευθυνών:** Διαχωρίστε σαφώς τη λογική για τις διαφορετικές HTTP μεθόδους.
- **Συνέπεια Απαντήσεων:** Εξασφαλίστε συνεπή δομή απαντήσεων για ευκολότερη διαχείριση από την πλευρά του client.
- **Διαχείριση Σφαλμάτων:** Χειριστείτε με κομψότητα μη υποστηριζόμενες μεθόδους και μη αναμενόμενα σφάλματα.

</details>

### Διαμόρφωση CORS

Ελέγξτε ποιες προελεύσεις (origins) μπορούν να έχουν πρόσβαση στις API routes σας, μετριάζοντας ευπάθειες του Cross-Origin Resource Sharing (CORS).

**Παράδειγμα Κακής Διαμόρφωσης:**
```javascript
// app/api/data/route.js

export async function GET(request) {
return new Response(JSON.stringify({ data: "Public Data" }), {
status: 200,
headers: {
"Access-Control-Allow-Origin": "*", // Allows any origin
"Access-Control-Allow-Methods": "GET, POST, PUT, DELETE",
},
})
}
```
Σημειώστε ότι **το CORS μπορεί επίσης να διαμορφωθεί σε όλες τις διαδρομές API** μέσα στο αρχείο **`middleware.ts`**:
```javascript
// app/middleware.ts

import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(request: NextRequest) {
const allowedOrigins = [
"https://yourdomain.com",
"https://sub.yourdomain.com",
]
const origin = request.headers.get("Origin")

const response = NextResponse.next()

if (allowedOrigins.includes(origin || "")) {
response.headers.set("Access-Control-Allow-Origin", origin || "")
response.headers.set(
"Access-Control-Allow-Methods",
"GET, POST, PUT, DELETE, OPTIONS"
)
response.headers.set(
"Access-Control-Allow-Headers",
"Content-Type, Authorization"
)
// If credentials are needed:
// response.headers.set('Access-Control-Allow-Credentials', 'true');
}

// Handle preflight requests
if (request.method === "OPTIONS") {
return new Response(null, {
status: 204,
headers: response.headers,
})
}

return response
}

export const config = {
matcher: "/api/:path*", // Apply to all API routes
}
```
**Πρόβλημα:**

- **`Access-Control-Allow-Origin: '*'`:** Επιτρέπει σε οποιονδήποτε ιστότοπο να έχει πρόσβαση στο API, ενδέχεται να επιτρέψει σε κακόβουλους ιστότοπους να αλληλεπιδρούν με το API σας χωρίς περιορισμούς.
- **Ευρεία Επιτρεπόμενη Χρήση Μεθόδων:** Η επιτρεπή όλων των μεθόδων μπορεί να δώσει τη δυνατότητα σε επιτιθέμενους να εκτελέσουν ανεπιθύμητες ενέργειες.

**Πώς το εκμεταλλεύονται οι επιτιθέμενοι:**

Οι επιτιθέμενοι μπορούν να δημιουργήσουν κακόβουλους ιστότοπους που κάνουν αιτήσεις στο API σας, καταχρώμενοι λειτουργίες όπως ανάκτηση δεδομένων, τροποποίηση δεδομένων ή ενεργοποίηση ανεπιθύμητων ενεργειών εκ μέρους πιστοποιημένων χρηστών.


{{#ref}}
../../pentesting-web/cors-bypass.md
{{#endref}}

### Server code exposure in Client Side

Είναι εύκολο να **use code used by the server also in code exposed and used by the client side**, ο καλύτερος τρόπος για να διασφαλίσετε ότι ένα αρχείο code δεν εκτίθεται ποτέ στο client side είναι να χρησιμοποιήσετε αυτό το import στην αρχή του αρχείου:
```js
import "server-only"
```
## Βασικά αρχεία και ο ρόλος τους

### `middleware.ts` / `middleware.js`

**Τοποθεσία:** Στη ρίζα του έργου ή μέσα στο `src/`.

**Σκοπός:** Εκτελεί κώδικα σε server-side serverless function πριν επεξεργαστεί ένα request, επιτρέποντας εργασίες όπως authentication, redirects ή τροποποίηση των responses.

**Ροή εκτέλεσης:**

1. **Εισερχόμενο Request:** Το middleware αναχαιτίζει το request.
2. **Επεξεργασία:** Εκτελεί λειτουργίες βάσει του request (π.χ., έλεγχος authentication).
3. **Τροποποίηση Response:** Μπορεί να αλλάξει το response ή να μεταβιβάσει τον έλεγχο στον επόμενο handler.

**Παραδείγματα χρήσης:**

- Ανακατεύθυνση μη αυθεντικοποιημένων χρηστών.
- Προσθήκη custom headers.
- Καταγραφή requests.

**Παράδειγμα ρυθμίσεων:**
```typescript
// middleware.ts
import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(req: NextRequest) {
const url = req.nextUrl.clone()
if (!req.cookies.has("token")) {
url.pathname = "/login"
return NextResponse.redirect(url)
}
return NextResponse.next()
}

export const config = {
matcher: ["/protected/:path*"],
}
```
### `next.config.js`

**Τοποθεσία:** Ρίζα του έργου.

**Σκοπός:** Ρυθμίζει τη συμπεριφορά του Next.js, ενεργοποιώντας ή απενεργοποιώντας λειτουργίες, προσαρμόζοντας τις ρυθμίσεις του webpack, ορίζοντας μεταβλητές περιβάλλοντος και διαμορφώνοντας διάφορες δυνατότητες ασφαλείας.

**Βασικές Ρυθμίσεις Ασφαλείας:**

<details>

<summary>Κεφαλίδες Ασφαλείας</summary>

Οι κεφαλίδες ασφαλείας ενισχύουν την ασφάλεια της εφαρμογής σας δίνοντας οδηγίες στους browsers σχετικά με τον τρόπο χειρισμού του περιεχομένου. Βοηθούν στη μείωση διάφορων επιθέσεων όπως Cross-Site Scripting (XSS), Clickjacking και MIME type sniffing:

- Content Security Policy (CSP)
- X-Frame-Options
- X-Content-Type-Options
- Strict-Transport-Security (HSTS)
- Referrer Policy

**Παραδείγματα:**
```javascript
// next.config.js

module.exports = {
async headers() {
return [
{
source: "/(.*)", // Apply to all routes
headers: [
{
key: "X-Frame-Options",
value: "DENY",
},
{
key: "Content-Security-Policy",
value:
"default-src *; script-src 'self' 'unsafe-inline' 'unsafe-eval';",
},
{
key: "X-Content-Type-Options",
value: "nosniff",
},
{
key: "Strict-Transport-Security",
value: "max-age=63072000; includeSubDomains; preload", // Enforces HTTPS
},
{
key: "Referrer-Policy",
value: "no-referrer", // Completely hides referrer
},
// Additional headers...
],
},
]
},
}
```
</details>

<details>

<summary>Ρυθμίσεις Βελτιστοποίησης Εικόνων</summary>

Next.js βελτιστοποιεί τις εικόνες για απόδοση, αλλά λανθασμένες ρυθμίσεις μπορούν να οδηγήσουν σε ευπάθειες ασφαλείας, όπως να επιτρέψουν σε μη αξιόπιστες πηγές να εγχύσουν κακόβουλο περιεχόμενο.

**Κακό Παράδειγμα Διαμόρφωσης:**
```javascript
// next.config.js

module.exports = {
images: {
domains: ["*"], // Allows images from any domain
},
}
```
**Πρόβλημα:**

- **`'*'`:** Επιτρέπει τη φόρτωση εικόνων από οποιαδήποτε εξωτερική πηγή, συμπεριλαμβανομένων μη αξιόπιστων ή κακόβουλων τομέων. Οι επιτιθέμενοι μπορούν να φιλοξενήσουν εικόνες που περιέχουν κακόβουλα payloads ή περιεχόμενο που παραπλανεί τους χρήστες.
- Ένα άλλο πρόβλημα μπορεί να είναι να επιτρέπεται ένα domain **όπου οποιοσδήποτε μπορεί να ανεβάσει μια εικόνα** (όπως `raw.githubusercontent.com`)

**Πώς το εκμεταλλεύονται οι επιτιθέμενοι:**

Με την εισαγωγή εικόνων από κακόβουλες πηγές, οι επιτιθέμενοι μπορούν να πραγματοποιήσουν phishing attacks, να εμφανίσουν παραπλανητικές πληροφορίες ή να εκμεταλλευτούν ευπάθειες σε βιβλιοθήκες απόδοσης εικόνας.

</details>

<details>

<summary>Έκθεση Μεταβλητών Περιβάλλοντος</summary>

Διαχειριστείτε ευαίσθητες πληροφορίες όπως κλειδιά API και διαπιστευτήρια βάσης δεδομένων με ασφάλεια χωρίς να τα εκθέτετε στον πελάτη.

#### a. Έκθεση Ευαίσθητων Μεταβλητών

**Κακό Παράδειγμα Διαμόρφωσης:**
```javascript
// next.config.js

module.exports = {
env: {
SECRET_API_KEY: process.env.SECRET_API_KEY, // Exposed to the client
NEXT_PUBLIC_API_URL: process.env.NEXT_PUBLIC_API_URL, // Correctly prefixed for client
},
}
```
**Πρόβλημα:**

- **`SECRET_API_KEY`:** Χωρίς το πρόθεμα `NEXT_PUBLIC_`, το Next.js δεν εκθέτει μεταβλητές στον client. Ωστόσο, αν προστεθεί κατά λάθος (π.χ. `NEXT_PUBLIC_SECRET_API_KEY`), γίνεται προσβάσιμη από την πλευρά του client.

**Πώς το εκμεταλλεύονται οι επιτιθέμενοι:**

Αν ευαίσθητες μεταβλητές εκτεθούν στον client, οι επιτιθέμενοι μπορούν να τις ανακτήσουν εξετάζοντας τον κώδικα στην πλευρά του client ή τα network requests, αποκτώντας μη εξουσιοδοτημένη πρόσβαση σε APIs, βάσεις δεδομένων ή άλλες υπηρεσίες.

</details>

<details>

<summary>Ανακατευθύνσεις</summary>

Διαχειριστείτε τις ανακατευθύνσεις και τις επαναγραφές URL μέσα στην εφαρμογή σας, διασφαλίζοντας ότι οι χρήστες προωθούνται σωστά χωρίς να εισάγονται open redirect vulnerabilities.

#### a. Open Redirect Vulnerability

**Κακό Παράδειγμα Διαμόρφωσης:**
```javascript
// next.config.js

module.exports = {
async redirects() {
return [
{
source: "/redirect",
destination: (req) => req.query.url, // Dynamically redirects based on query parameter
permanent: false,
},
]
},
}
```
**Πρόβλημα:**

- **Dynamic Destination:** Επιτρέπει στους χρήστες να καθορίζουν οποιοδήποτε URL, επιτρέποντας επιθέσεις open redirect.
- **Trusting User Input:** Οι ανακατευθύνσεις προς URLs που παρέχονται από χρήστες χωρίς επικύρωση μπορούν να οδηγήσουν σε phishing, διανομή malware ή κλοπή διαπιστευτηρίων.

**Πώς το εκμεταλλεύονται οι επιτιθέμενοι:**

Οι επιτιθέμενοι μπορούν να κατασκευάσουν URLs που φαίνεται να προέρχονται από το domain σας αλλά ανακατευθύνουν τους χρήστες σε κακόβουλους ιστότοπους. Για παράδειγμα:
```bash
https://yourdomain.com/redirect?url=https://malicious-site.com
```
Χρήστες που εμπιστεύονται το αρχικό domain μπορεί άθελά τους να πλοηγηθούν σε επιβλαβείς ιστότοπους.

</details>

<details>

<summary>Ρυθμίσεις Webpack</summary>

Η προσαρμογή των ρυθμίσεων Webpack για την εφαρμογή Next.js σας μπορεί χωρίς πρόθεση να εισαγάγει ευπάθειες ασφαλείας εάν δεν γίνει με προσοχή.

#### a. Αποκάλυψη ευαίσθητων modules

**Κακό παράδειγμα διαμόρφωσης:**
```javascript
// next.config.js

module.exports = {
webpack: (config, { isServer }) => {
if (!isServer) {
config.resolve.alias["@sensitive"] = path.join(__dirname, "secret-folder")
}
return config
},
}
```
**Πρόβλημα:**

- **Exposing Sensitive Paths:** Η δημιουργία aliases για ευαίσθητους καταλόγους και η επιτρεψη client-side πρόσβασης μπορεί να leak εμπιστευτικές πληροφορίες.
- **Bundling Secrets:** Αν ευαίσθητα αρχεία συμπεριληφθούν για τον client, τα περιεχόμενά τους γίνονται προσβάσιμα μέσω source maps ή επιθεώρησης του client-side code.

**Πώς το εκμεταλλεύονται οι επιτιθέμενοι:**

Οι επιτιθέμενοι μπορούν να αποκτήσουν πρόσβαση ή να ανασυνθέσουν τη δομή των καταλόγων της εφαρμογής, εντοπίζοντας και εκμεταλλευόμενοι ευαίσθητα αρχεία ή δεδομένα.

</details>

### `pages/_app.js` και `pages/_document.js`

#### **`pages/_app.js`**

**Purpose:** Επικαλύπτει το προεπιλεγμένο App component, επιτρέποντας global state, styles και layout components.

**Use Cases:**

- Προσθήκη global CSS.
- Προσθήκη layout wrappers.
- Ενσωμάτωση βιβλιοθηκών για state management.

**Example:**
```jsx
// pages/_app.js
import "../styles/globals.css"

function MyApp({ Component, pageProps }) {
return <Component {...pageProps} />
}

export default MyApp
```
#### **`pages/_document.js`**

**Σκοπός:** Παρεμβαίνει στο προεπιλεγμένο Document, επιτρέποντας την προσαρμογή των tags `<html>` και `<body>`.

**Περιπτώσεις χρήσης:**

- Τροποποίηση των `<html>` ή `<body>` tags.
- Προσθήκη meta tags ή προσαρμοσμένων scripts.
- Ενσωμάτωση γραμματοσειρών τρίτων.

**Παράδειγμα:**
```jsx
// pages/_document.js
import Document, { Html, Head, Main, NextScript } from "next/document"

class MyDocument extends Document {
render() {
return (
<Html lang="en">
<Head>{/* Custom fonts or meta tags */}</Head>
<body>
<Main />
<NextScript />
</body>
</Html>
)
}
}

export default MyDocument
```
### Προσαρμοσμένος Server (Προαιρετικό)

**Σκοπός:** Ενώ το Next.js περιλαμβάνει έναν built-in server, μπορείτε να δημιουργήσετε έναν custom server για προχωρημένες περιπτώσεις χρήσης όπως custom routing ή ενσωμάτωση με υπάρχοντα backend services.

**Σημείωση:** Η χρήση ενός custom server μπορεί να περιορίσει τις επιλογές ανάπτυξης, ειδικά σε πλατφόρμες όπως η Vercel που βελτιστοποιούν για τον built-in server του Next.js.

**Παράδειγμα:**
```javascript
// server.js
const express = require("express")
const next = require("next")

const dev = process.env.NODE_ENV !== "production"
const app = next({ dev })
const handle = app.getRequestHandler()

app.prepare().then(() => {
const server = express()

// Custom route
server.get("/a", (req, res) => {
return app.render(req, res, "/a")
})

// Default handler
server.all("*", (req, res) => {
return handle(req, res)
})

server.listen(3000, (err) => {
if (err) throw err
console.log("> Ready on http://localhost:3000")
})
})
```
---

## Πρόσθετες Αρχιτεκτονικές και Θέματα Ασφαλείας

### Περιβαλλοντικές Μεταβλητές και Διαμόρφωση

**Σκοπός:** Διαχείριση ευαίσθητων πληροφοριών και ρυθμίσεων διαμόρφωσης εκτός του κώδικα.

**Βέλτιστες Πρακτικές:**

- **Χρήση αρχείων `.env`:** Αποθηκεύστε μεταβλητές όπως κλειδιά API σε `.env.local` (εξαιρούμενο από τον έλεγχο έκδοσης).
- **Πρόσβαση στις μεταβλητές με ασφάλεια:** Χρησιμοποιήστε `process.env.VARIABLE_NAME` για πρόσβαση στις περιβαλλοντικές μεταβλητές.
- **Μην εκθέτετε ποτέ μυστικά στον Client:** Βεβαιωθείτε ότι οι ευαίσθητες μεταβλητές χρησιμοποιούνται μόνο από την πλευρά του server.

**Παράδειγμα:**
```javascript
// next.config.js
module.exports = {
env: {
API_KEY: process.env.API_KEY, // Accessible on both client and server
SECRET_KEY: process.env.SECRET_KEY, // Be cautious if accessible on the client
},
}
```
**Σημείωση:** Για να περιορίσετε μεταβλητές μόνο στην πλευρά του server, παραλείψτε τις από το αντικείμενο `env` ή προθέστε `NEXT_PUBLIC_` για έκθεση στον client.

### Αυθεντικοποίηση και Εξουσιοδότηση

**Προσέγγιση:**

- **Αυθεντικοποίηση βάσει συνεδρίας:** Χρησιμοποιήστε cookies για τη διαχείριση των συνεδριών χρηστών.
- **Αυθεντικοποίηση με token:** Χρησιμοποιήστε JWTs για αυθεντικοποίηση χωρίς κατάσταση.
- **Πάροχοι τρίτων:** Ενσωματώστε παρόχους OAuth (π.χ., Google, GitHub) χρησιμοποιώντας βιβλιοθήκες όπως `next-auth`.

**Πρακτικές Ασφαλείας:**

- **Ασφαλή Cookies:** Ορίστε τις ιδιότητες `HttpOnly`, `Secure` και `SameSite`.
- **Κατακερματισμός κωδικών:** Πάντα κατακερματίζετε τους κωδικούς πριν τους αποθηκεύσετε.
- **Επικύρωση εισροών:** Αποτρέψτε τα injection attacks επαληθεύοντας και καθαρίζοντας τις εισροές.

**Παράδειγμα:**
```javascript
// pages/api/login.js
import { sign } from "jsonwebtoken"
import { serialize } from "cookie"

export default async function handler(req, res) {
const { username, password } = req.body

// Validate user credentials
if (username === "admin" && password === "password") {
const token = sign({ username }, process.env.JWT_SECRET, {
expiresIn: "1h",
})
res.setHeader(
"Set-Cookie",
serialize("auth", token, {
path: "/",
httpOnly: true,
secure: true,
sameSite: "strict",
})
)
res.status(200).json({ message: "Logged in" })
} else {
res.status(401).json({ error: "Invalid credentials" })
}
}
```
### Βελτιστοποίηση Απόδοσης

**Στρατηγικές:**

- **Βελτιστοποίηση Εικόνων:** Χρησιμοποιήστε το component `next/image` του Next.js για αυτόματη βελτιστοποίηση εικόνων.
- **Διαίρεση Κώδικα (Code Splitting):** Χρησιμοποιήστε δυναμικές εισαγωγές (dynamic imports) για να διαχωρίσετε τον κώδικα και να μειώσετε τον αρχικό χρόνο φόρτωσης.
- **Caching:** Εφαρμόστε στρατηγικές caching για τις αποκρίσεις API και τα static assets.
- **Lazy Loading:** Φορτώστε components ή assets μόνο όταν χρειάζονται.

**Παράδειγμα:**
```jsx
// Dynamic Import with Code Splitting
import dynamic from "next/dynamic"

const HeavyComponent = dynamic(() => import("../components/HeavyComponent"), {
loading: () => <p>Loading...</p>,
})
```
## Next.js Server Actions Enumeration (hash to function name via source maps)

Το σύγχρονο Next.js χρησιμοποιεί “Server Actions” που εκτελούνται στον διακομιστή αλλά καλούνται από τον πελάτη. Σε production αυτές οι κλήσεις είναι αδιαφανείς: όλα τα POSTs καταλήγουν σε ένα κοινό endpoint και διακρίνονται από ένα build-specific hash που αποστέλλεται στην κεφαλίδα `Next-Action`. Παράδειγμα:
```http
POST /
Next-Action: a9f8e2b4c7d1...
```
Όταν ενεργοποιείται το `productionBrowserSourceMaps`, τα minified JS chunks περιέχουν κλήσεις προς το `createServerReference(...)` που leak αρκετή δομή (συν τα σχετιζόμενα source maps) ώστε να ανακτήσετε μια αντιστοίχιση μεταξύ του action hash και του αρχικού ονόματος της συνάρτησης. Αυτό σας επιτρέπει να μεταφράζετε τα hashes που παρατηρούνται στο `Next-Action` σε συγκεκριμένους στόχους όπως `deleteUserAccount()` ή `exportFinancialData()`.

### Προσέγγιση εξαγωγής (regex on minified JS + optional source maps)

Αναζητήστε τα ληφθέντα JS chunks για το `createServerReference` και εξάγετε το hash και το σύμβολο της συνάρτησης/πηγής. Δύο χρήσιμα μοτίβα:
```regex
# Strict pattern for standard minification
createServerReference\)"([a-f0-9]{40,})",\w+\.callServer,void 0,\w+\.findSourceMapURL,"([^"]+)"\)

# Flexible pattern handling various minification styles
createServerReference[^\"]*"([a-f0-9]{40,})"[^\"]*"([^"]+)"\s*\)
```
- Ομάδα 1: server action hash (40+ hex chars)
- Ομάδα 2: symbol ή path που μπορεί να επιλυθεί στο αρχικό όνομα συνάρτησης μέσω του source map όταν υπάρχει

If the script advertises a source map (trailer comment `//# sourceMappingURL=<...>.map`), fetch it and resolve the symbol/path to the original function name.

### Πρακτική ροή εργασίας

- Παθητική ανακάλυψη κατά την περιήγηση: καταγράψτε requests με headers `Next-Action` και JS chunk URLs.
- Fetch the referenced JS bundles and accompanying `*.map` files (when present).
- Run the regex above to build a hash↔name dictionary.
- Use the dictionary to target testing:
- Name-driven triage (e.g., `transferFunds`, `exportFinancialData`).
- Track coverage across builds by function name (hashes rotate across builds).

### Εκτέλεση κρυφών actions (template-based request)

Take a valid POST observed in-proxy as a template and swap the `Next-Action` value to target another discovered action:
```http
# Before
Next-Action: a9f8e2b4c7d1

# After
Next-Action: b7e3f9a2d8c5
```
Αναπαραγωγή στο Repeater και έλεγχος authorization, input validation και business logic ενεργειών που διαφορετικά είναι απρόσιτες.

### Burp αυτοματοποίηση

- NextjsServerActionAnalyzer (Burp επέκταση) αυτοματοποιεί τα παραπάνω στο Burp:
- Σαρώνει το ιστορικό proxy για JS chunks, εξάγει `createServerReference(...)` entries, και αναλύει source maps όταν είναι διαθέσιμα.
- Διατηρεί αναζητήσιμο λεξικό hash↔function-name και αφαιρεί διπλότυπα ανά builds με βάση το όνομα της συνάρτησης.
- Μπορεί να εντοπίσει ένα έγκυρο template POST και να ανοίξει μια έτοιμη για αποστολή καρτέλα Repeater με το hash της στοχευόμενης ενέργειας αντικατεστημένο.
- Repo: https://github.com/Adversis/NextjsServerActionAnalyzer

### Σημειώσεις και περιορισμοί

- Απαιτεί `productionBrowserSourceMaps` ενεργοποιημένο σε production για να ανακτήσει ονόματα από bundles/source maps.
- Η αποκάλυψη function-name από μόνη της δεν αποτελεί ευπάθεια — χρησιμοποιήστε την για να καθοδηγήσετε την ανακάλυψη και να ελέγξετε την authorization κάθε ενέργειας.

### React Server Components Flight protocol deserialization RCE (CVE-2025-55182)

Next.js App Router deployments που εκθέτουν Server Actions στο `react-server-dom-webpack` **19.0.0–19.2.0 (Next.js 15.x/16.x)** περιέχουν μια κρίσιμη server-side prototype pollution κατά την απο-σειριοποίηση των **Flight** chunks. Με τη δημιουργία `$` references μέσα σε ένα Flight payload, ένας επιτιθέμενος μπορεί να μεταβεί από μολυσμένα prototypes σε αυθαίρετη εκτέλεση JavaScript και στη συνέχεια σε εκτέλεση εντολών OS μέσα στη διεργασία του Node.js.

{{#ref}}
../../pentesting-web/deserialization/nodejs-proto-prototype-pollution/README.md
{{#endref}}

#### Αλυσίδα επίθεσης σε Flight chunks

1. **Prototype pollution primitive:** Ορίστε `"then": "$1:__proto__:then"` έτσι ώστε ο resolver να γράψει μια συνάρτηση `then` στο `Object.prototype`. Οποιοδήποτε plain object επεξεργάζεται μετά γίνεται thenable, επιτρέποντας στον επιτιθέμενο να επηρεάσει τον async control flow μέσα στα RSC internals.
2. **Rebinding to the global `Function` constructor:** Δείξτε `_response._formData.get` προς `"$1:constructor:constructor"`. Κατά την επίλυση, `object.constructor` → `Object`, και `Object.constructor` → `Function`, οπότε μελλοντικές κλήσεις σε `_formData.get()` εκτελούν στην πραγματικότητα `Function(...)`.
3. **Code execution via `_prefix`:** Τοποθετήστε πηγαίο JavaScript σε `_response._prefix`. Όταν κληθεί το μολυσμένο `_formData.get`, το framework αξιολογεί `Function(_prefix)(...)`, οπότε το εισαγμένο JS μπορεί να εκτελέσει `require('child_process').exec()` ή οποιοδήποτε άλλο Node primitive.

#### Σκελετός payload
```json
{
"then": "$1:__proto__:then",
"status": "resolved_model",
"reason": -1,
"value": "{\"then\":\"$B1337\"}",
"_response": {
"_prefix": "require('child_process').exec('id')",
"_chunks": "$Q2",
"_formData": { "get": "$1:constructor:constructor" }
}
}
```
## Αναφορές

- [Pentesting Next.js Server Actions — A Burp Extension for Hash-to-Function Mapping](https://www.adversis.io/blogs/pentesting-next-js-server-actions)
- [NextjsServerActionAnalyzer (Burp extension)](https://github.com/Adversis/NextjsServerActionAnalyzer)
- [CVE-2025-55182 React Server Components Remote Code Execution Exploit Tool](https://github.com/Spritualkb/CVE-2025-55182-exp)

{{#include ../../banners/hacktricks-training.md}}
