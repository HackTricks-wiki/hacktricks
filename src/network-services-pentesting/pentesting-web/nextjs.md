# NextJS

{{#include ../../banners/hacktricks-training.md}}

## Arquitetura Geral de uma Aplicação Next.js

### Estrutura de Arquivos Típica

Um projeto Next.js padrão segue uma estrutura específica de arquivos e diretórios que facilita recursos como roteamento, endpoints de API e gerenciamento de ativos estáticos. Aqui está um layout típico:
```lua
my-nextjs-app/
├── node_modules/
├── public/
│   ├── images/
│   │   └── logo.png
│   └── favicon.ico
├── app/
│   ├── api/
│   │   └── hello/
│   │       └── route.ts
│   ├── layout.tsx
│   ├── page.tsx
│   ├── about/
│   │   └── page.tsx
│   ├── dashboard/
│   │   ├── layout.tsx
│   │   └── page.tsx
│   ├── components/
│   │   ├── Header.tsx
│   │   └── Footer.tsx
│   ├── styles/
│   │   ├── globals.css
│   │   └── Home.module.css
│   └── utils/
│       └── api.ts
├── .env.local
├── next.config.js
├── tsconfig.json
├── package.json
├── README.md
└── yarn.lock / package-lock.json

```
### Diretórios e Arquivos Principais

- **public/:** Hospeda assets estáticos como imagens, fontes e outros arquivos. Arquivos aqui são acessíveis no caminho raiz (`/`).
- **app/:** Diretório central para as páginas, layouts, componentes e API routes da sua aplicação. Adota o paradigma **App Router**, permitindo recursos avançados de roteamento e segregação entre componentes do servidor e do cliente.
- **app/layout.tsx:** Define o layout raiz da sua aplicação, envolvendo todas as páginas e fornecendo elementos de UI consistentes como headers, footers e barras de navegação.
- **app/page.tsx:** Serve como ponto de entrada para a rota raiz `/`, renderizando a página inicial.
- **app/[route]/page.tsx:** Lida com rotas estáticas e dinâmicas. Cada pasta dentro de `app/` representa um segmento de rota, e o `page.tsx` dentro dessas pastas corresponde ao componente da rota.
- **app/api/:** Contém API routes, permitindo criar funções serverless que tratam requisições HTTP. Essas rotas substituem o tradicional diretório `pages/api`.
- **app/components/:** Abriga componentes React reutilizáveis que podem ser utilizados em diferentes páginas e layouts.
- **app/styles/:** Contém arquivos CSS globais e CSS Modules para estilização com escopo por componente.
- **app/utils/:** Inclui funções utilitárias, módulos auxiliares e outra lógica não-UI que pode ser compartilhada pela aplicação.
- **.env.local:** Armazena variáveis de ambiente específicas do ambiente de desenvolvimento local. Essas variáveis **não** são commitadas no controle de versão.
- **next.config.js:** Customiza o comportamento do Next.js, incluindo configurações do webpack, variáveis de ambiente e configurações de segurança.
- **tsconfig.json:** Configura as opções do TypeScript para o projeto, habilitando verificação de tipos e outras funcionalidades do TypeScript.
- **package.json:** Gerencia dependências do projeto, scripts e metadata.
- **README.md:** Fornece documentação e informações sobre o projeto, incluindo instruções de setup, diretrizes de uso e outros detalhes relevantes.
- **yarn.lock / package-lock.json:** Travem as dependências do projeto em versões específicas, garantindo instalações consistentes entre diferentes ambientes.

## Lado do Cliente em Next.js

### Roteamento baseado em arquivos no diretório `app`

O diretório `app` é a pedra angular do roteamento nas versões mais recentes do Next.js. Ele aproveita o filesystem para definir rotas, tornando o gerenciamento de rotas intuitivo e escalável.

<details>

<summary>Tratando o caminho raiz /</summary>

**Estrutura de Arquivos:**
```arduino
my-nextjs-app/
├── app/
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Arquivos-chave:**

- **`app/page.tsx`**: Lida com requisições para o caminho raiz `/`.
- **`app/layout.tsx`**: Define o layout da aplicação, envolvendo todas as páginas.

**Implementação:**
```tsx
tsxCopy code// app/page.tsx

export default function HomePage() {
return (
<div>
<h1>Welcome to the Home Page!</h1>
<p>This is the root route.</p>
</div>
);
}
```
**Explicação:**

- **Definição de Rota:** O arquivo `page.tsx` diretamente sob o diretório `app` corresponde à rota `/`.
- **Renderização:** Esse componente renderiza o conteúdo da página inicial.
- **Integração de Layout:** O componente `HomePage` é envolvido por `layout.tsx`, que pode incluir cabeçalhos, rodapés e outros elementos comuns.

</details>

<details>

<summary>Tratando Outros Caminhos Estáticos</summary>

**Exemplo: rota `/about`**

**Estrutura de Arquivos:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── about/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementação:**
```tsx
// app/about/page.tsx

export default function AboutPage() {
return (
<div>
<h1>About Us</h1>
<p>Learn more about our mission and values.</p>
</div>
)
}
```
**Explicação:**

- **Definição de Rota:** O arquivo `page.tsx` dentro da pasta `about` corresponde à rota `/about`.
- **Renderização:** Este componente renderiza o conteúdo da página about.

</details>

<details>

<summary>Rotas Dinâmicas</summary>

Rotas dinâmicas permitem lidar com caminhos com segmentos variáveis, permitindo que aplicações exibam conteúdo com base em parâmetros como IDs, slugs, etc.

**Exemplo: `/posts/[id]` Rota**

**Estrutura de Arquivos:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── posts/
│   │   └── [id]/
│   │       └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementação:**
```tsx
tsxCopy code// app/posts/[id]/page.tsx

import { useRouter } from 'next/navigation';

interface PostProps {
params: { id: string };
}

export default function PostPage({ params }: PostProps) {
const { id } = params;
// Fetch post data based on 'id'

return (
<div>
<h1>Post #{id}</h1>
<p>This is the content of post {id}.</p>
</div>
);
}
```
**Explicação:**

- **Segmento Dinâmico:** `[id]` denota um segmento dinâmico na rota, capturando o parâmetro `id` da URL.
- **Acessando Parâmetros:** O objeto `params` contém os parâmetros dinâmicos, acessíveis dentro do componente.
- **Correspondência de Rota:** Qualquer caminho que bata com `/posts/*`, como `/posts/1`, `/posts/abc`, etc., será tratado por este componente.

</details>

<details>

<summary>Nested Routes</summary>

Next.js suporta rotas aninhadas, permitindo estruturas de rotas hierárquicas que espelham a organização de diretórios.

**Exemplo: `/dashboard/settings/profile` Rota**

**File Structure:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── dashboard/
│   │   ├── settings/
│   │   │   └── profile/
│   │   │       └── page.tsx
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementação:**
```tsx
tsxCopy code// app/dashboard/settings/profile/page.tsx

export default function ProfileSettingsPage() {
return (
<div>
<h1>Profile Settings</h1>
<p>Manage your profile information here.</p>
</div>
);
}
```
**Explicação:**

- **Aninhamento Profundo:** O arquivo `page.tsx` dentro de `dashboard/settings/profile/` corresponde à rota `/dashboard/settings/profile`.
- **Reflexo da Hierarquia:** A estrutura de diretórios reflete o caminho da URL, melhorando a manutenibilidade e a clareza.

</details>

<details>

<summary>Rotas Catch-All</summary>

Rotas catch-all lidam com múltiplos segmentos aninhados ou caminhos desconhecidos, proporcionando flexibilidade no tratamento de rotas.

**Exemplo: `/*` Rota**

**Estrutura de Arquivos:**
```arduino
my-nextjs-app/
├── app/
│   ├── [...slug]/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementação:**
```tsx
// app/[...slug]/page.tsx

interface CatchAllProps {
params: { slug: string[] }
}

export default function CatchAllPage({ params }: CatchAllProps) {
const { slug } = params
const fullPath = `/${slug.join("/")}`

return (
<div>
<h1>Catch-All Route</h1>
<p>You have navigated to: {fullPath}</p>
</div>
)
}
```
**Explicação:**

- **Segmento Catch-All:** `[...slug]` captura todos os segmentos de caminho restantes como um array.
- **Uso:** Útil para lidar com cenários de roteamento dinâmico como caminhos gerados por usuários, categorias aninhadas, etc.
- **Correspondência de Rotas:** Rotas como `/anything/here`, `/foo/bar/baz`, etc., são tratadas por este componente.

</details>

### Possíveis Vulnerabilidades no Lado do Cliente

Embora o Next.js forneça uma base segura, práticas de codificação inadequadas podem introduzir vulnerabilidades. As principais vulnerabilidades no lado do cliente incluem:

<details>

<summary>Cross-Site Scripting (XSS)</summary>

Ataques XSS ocorrem quando scripts maliciosos são injetados em sites confiáveis. Atacantes podem executar scripts nos navegadores dos usuários, roubando dados ou realizando ações em nome do usuário.

**Exemplo de Código Vulnerável:**
```jsx
// Dangerous: Injecting user input directly into HTML
function Comment({ userInput }) {
return <div dangerouslySetInnerHTML={{ __html: userInput }} />
}
```
**Por que é vulnerável:** Usar `dangerouslySetInnerHTML` com input não confiável permite que atacantes injetem scripts maliciosos.

</details>

<details>

<summary>Client-Side Template Injection</summary>

Ocorre quando as entradas do usuário são tratadas inadequadamente em templates, permitindo que atacantes injetem e executem templates ou expressões.

**Exemplo de Código Vulnerável:**
```jsx
import React from "react"
import ejs from "ejs"

function RenderTemplate({ template, data }) {
const html = ejs.render(template, data)
return <div dangerouslySetInnerHTML={{ __html: html }} />
}
```
**Por que é vulnerável:** Se `template` ou `data` incluir conteúdo malicioso, isso pode levar à execução de código não intencional.

</details>

<details>

<summary>Client Path Traversal</summary>

É uma vulnerabilidade que permite que atacantes manipulem caminhos no lado do cliente para executar ações não intencionais, como Cross-Site Request Forgery (CSRF). Ao contrário do server-side path traversal, que targets the server's filesystem, CSPT foca em explorar mecanismos do lado do cliente para redirecionar requisições API legítimas para endpoints maliciosos.

**Exemplo de Código Vulnerável:**

Uma aplicação Next.js permite que usuários façam upload e download de arquivos. A funcionalidade de download é implementada no lado do cliente, onde os usuários podem especificar o caminho do arquivo a ser baixado.
```jsx
// pages/download.js
import { useState } from "react"

export default function DownloadPage() {
const [filePath, setFilePath] = useState("")

const handleDownload = () => {
fetch(`/api/files/${filePath}`)
.then((response) => response.blob())
.then((blob) => {
const url = window.URL.createObjectURL(blob)
const a = document.createElement("a")
a.href = url
a.download = filePath
a.click()
})
}

return (
<div>
<h1>Download File</h1>
<input
type="text"
value={filePath}
onChange={(e) => setFilePath(e.target.value)}
placeholder="Enter file path"
/>
<button onClick={handleDownload}>Download</button>
</div>
)
}
```
#### Attack Scenario

1. **Attacker's Objective**: Realizar um ataque CSRF para apagar um arquivo crítico (por exemplo, `admin/config.json`) manipulando o `filePath`.
2. **Exploiting CSPT**:
- **Malicious Input**: O atacante cria uma URL com o `filePath` manipulado, como `../deleteFile/config.json`.
- **Resulting API Call**: O código do client-side faz uma requisição para `/api/files/../deleteFile/config.json`.
- **Server's Handling**: Se o servidor não validar o `filePath`, ele processa a requisição, potencialmente apagando ou expondo arquivos sensíveis.
3. **Executing CSRF**:
- **Crafted Link**: O atacante envia à vítima um link ou incorpora um script malicioso que dispara a requisição de download com o `filePath` manipulado.
- **Outcome**: A vítima executa a ação sem saber, levando a acesso ou exclusão não autorizada de arquivos.

#### Why It's Vulnerable

- **Lack of Input Validation**: O client-side permite entradas arbitrárias em `filePath`, possibilitando path traversal.
- **Trusting Client Inputs**: A API do server-side confia e processa o `filePath` sem sanitização.
- **Potential API Actions**: Se o endpoint da API realiza ações que mudam o estado (por exemplo, deletar, modificar arquivos), ele pode ser explorado via CSPT.

</details>

## Server-Side in Next.js

### Server-Side Rendering (SSR)

Pages são renderizadas no servidor a cada requisição, garantindo que o usuário receba HTML totalmente renderizado. Nesse caso você deve criar seu próprio servidor customizado para processar as requisições.

**Use Cases:**

- Conteúdo dinâmico que muda com frequência.
- Otimização de SEO, já que os motores de busca podem rastrear a página totalmente renderizada.

**Implementation:**
```jsx
// pages/index.js
export async function getServerSideProps(context) {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data } }
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### Geração Estática de Sites (SSG)

As páginas são pré-renderizadas em tempo de build, resultando em tempos de carregamento mais rápidos e menor carga no servidor.

**Casos de Uso:**

- Conteúdo que não muda com frequência.
- Blogs, documentação, páginas de marketing.

**Implementação:**
```jsx
// pages/index.js
export async function getStaticProps() {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data }, revalidate: 60 } // Revalidate every 60 seconds
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### Funções Serverless (API Routes)

Next.js permite a criação de endpoints de API como funções serverless. Essas funções executam sob demanda sem a necessidade de um servidor dedicado.

**Casos de Uso:**

- Processar envios de formulários.
- Interagir com bancos de dados.
- Processar dados ou integrar com APIs de terceiros.

**Implementação:**

Com a introdução do diretório `app` no Next.js 13, o roteamento e o manuseio de API tornaram-se mais flexíveis e poderosos. Essa abordagem moderna se alinha estreitamente com o sistema de roteamento baseado em arquivos, mas introduz capacidades aprimoradas, incluindo suporte para componentes de servidor e cliente.

#### Manipulador de Rota Básico

**Estrutura de Arquivos:**
```go
my-nextjs-app/
├── app/
│   └── api/
│       └── hello/
│           └── route.js
├── package.json
└── ...
```
**Implementação:**
```javascript
// app/api/hello/route.js

export async function POST(request) {
return new Response(JSON.stringify({ message: "Hello from App Router!" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

// Client-side fetch to access the API endpoint
fetch("/api/submit", {
method: "POST",
headers: { "Content-Type": "application/json" },
body: JSON.stringify({ name: "John Doe" }),
})
.then((res) => res.json())
.then((data) => console.log(data))
```
**Explicação:**

- **Localização:** As rotas de API ficam sob o diretório `app/api/`.
- **Nome dos Arquivos:** Cada endpoint de API reside em sua própria pasta contendo um arquivo `route.js` ou `route.ts`.
- **Funções Exportadas:** Em vez de um único default export, funções específicas para métodos HTTP (ex.: `GET`, `POST`) são exportadas.
- **Tratamento de Resposta:** Use o construtor `Response` para retornar respostas, permitindo maior controle sobre headers e códigos de status.

#### Como lidar com outros caminhos e métodos:

<details>

<summary>Tratamento de Métodos HTTP Específicos</summary>

Next.js 13+ permite definir manipuladores para métodos HTTP específicos dentro do mesmo arquivo `route.js` ou `route.ts`, promovendo um código mais claro e organizado.

**Exemplo:**
```javascript
// app/api/users/[id]/route.js

export async function GET(request, { params }) {
const { id } = params
// Fetch user data based on 'id'
return new Response(JSON.stringify({ userId: id, name: "Jane Doe" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function PUT(request, { params }) {
const { id } = params
// Update user data based on 'id'
return new Response(JSON.stringify({ message: `User ${id} updated.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function DELETE(request, { params }) {
const { id } = params
// Delete user based on 'id'
return new Response(JSON.stringify({ message: `User ${id} deleted.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**Explicação:**

- **Múltiplas Exportações:** Cada método HTTP (`GET`, `PUT`, `DELETE`) possui sua própria função exportada.
- **Parâmetros:** O segundo argumento fornece acesso aos parâmetros de rota via `params`.
- **Respostas Aprimoradas:** Maior controle sobre objetos de resposta, permitindo gerenciamento preciso de cabeçalhos e códigos de status.

</details>

<details>

<summary>Rotas catch-all e aninhadas</summary>

Next.js 13+ suporta recursos de roteamento avançados como rotas catch-all e rotas de API aninhadas, permitindo estruturas de API mais dinâmicas e escaláveis.

**Exemplo de Rota Catch-All:**
```javascript
// app/api/[...slug]/route.js

export async function GET(request, { params }) {
const { slug } = params
// Handle dynamic nested routes
return new Response(JSON.stringify({ slug }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**Explicação:**

- **Sintaxe:** `[...]` denota um segmento coringa, capturando todos os caminhos aninhados.
- **Uso:** Útil para APIs que precisam lidar com profundidades de rota variáveis ou segmentos dinâmicos.

**Exemplo de Rotas Aninhadas:**
```javascript
// app/api/posts/[postId]/comments/[commentId]/route.js

export async function GET(request, { params }) {
const { postId, commentId } = params
// Fetch specific comment for a post
return new Response(
JSON.stringify({ postId, commentId, comment: "Great post!" }),
{
status: 200,
headers: { "Content-Type": "application/json" },
}
)
}
```
**Explicação:**

- **Aninhamento Profundo:** Permite estruturas de API hierárquicas, refletindo relacionamentos entre recursos.
- **Acesso a Parâmetros:** Acesse facilmente múltiplos parâmetros de rota via o objeto `params`.

</details>

<details>

<summary>Tratamento de rotas de API no Next.js 12 e anteriores</summary>

## Rotas de API no diretório `pages` (Next.js 12 e anteriores)

Antes do Next.js 13 introduzir o diretório `app` e capacidades de roteamento aprimoradas, as rotas de API eram definidas principalmente dentro do diretório `pages`. Essa abordagem ainda é amplamente utilizada e suportada no Next.js 12 e em versões anteriores.

#### Rota de API Básica

**Estrutura de Arquivos:**
```go
goCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── hello.js
├── package.json
└── ...
```
**Implementação:**
```javascript
javascriptCopy code// pages/api/hello.js

export default function handler(req, res) {
res.status(200).json({ message: 'Hello, World!' });
}
```
**Explicação:**

- **Localização:** As API routes ficam sob o diretório `pages/api/`.
- **Exportação:** Use `export default` para definir a função handler.
- **Assinatura da função:** O handler recebe os objetos `req` (requisição HTTP) e `res` (resposta HTTP).
- **Roteamento:** O nome do arquivo (`hello.js`) mapeia para o endpoint `/api/hello`.

#### Rotas de API Dinâmicas

**Estrutura de arquivos:**
```bash
bashCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── users/
│           └── [id].js
├── package.json
└── ...
```
**Implementação:**
```javascript
javascriptCopy code// pages/api/users/[id].js

export default function handler(req, res) {
const {
query: { id },
method,
} = req;

switch (method) {
case 'GET':
// Fetch user data based on 'id'
res.status(200).json({ userId: id, name: 'John Doe' });
break;
case 'PUT':
// Update user data based on 'id'
res.status(200).json({ message: `User ${id} updated.` });
break;
case 'DELETE':
// Delete user based on 'id'
res.status(200).json({ message: `User ${id} deleted.` });
break;
default:
res.setHeader('Allow', ['GET', 'PUT', 'DELETE']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**Explicação:**

- **Segmentos Dinâmicos:** Colchetes (`[id].js`) denotam segmentos de rota dinâmicos.
- **Acessando Parâmetros:** Use `req.query.id` para acessar o parâmetro dinâmico.
- **Tratamento de Métodos:** Utilize lógica condicional para lidar com diferentes métodos HTTP (`GET`, `PUT`, `DELETE`, etc.).

#### Tratando Diferentes Métodos HTTP

Enquanto o exemplo básico de API route trata todos os métodos HTTP dentro de uma única função, você pode estruturar seu código para lidar com cada método explicitamente para maior clareza e manutenibilidade.

**Exemplo:**
```javascript
javascriptCopy code// pages/api/posts.js

export default async function handler(req, res) {
const { method } = req;

switch (method) {
case 'GET':
// Handle GET request
res.status(200).json({ message: 'Fetching posts.' });
break;
case 'POST':
// Handle POST request
res.status(201).json({ message: 'Post created.' });
break;
default:
res.setHeader('Allow', ['GET', 'POST']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**Melhores Práticas:**

- **Separação de Responsabilidades:** Separe claramente a lógica para diferentes métodos HTTP.
- **Consistência de Resposta:** Garanta estruturas de resposta consistentes para facilitar o tratamento no lado do cliente.
- **Tratamento de Erros:** Trate de forma adequada métodos não suportados e erros inesperados.

</details>

### Configuração de CORS

Controle quais origens podem acessar suas rotas de API, mitigando vulnerabilidades de Cross-Origin Resource Sharing (CORS).

**Exemplo de Configuração Ruim:**
```javascript
// app/api/data/route.js

export async function GET(request) {
return new Response(JSON.stringify({ data: "Public Data" }), {
status: 200,
headers: {
"Access-Control-Allow-Origin": "*", // Allows any origin
"Access-Control-Allow-Methods": "GET, POST, PUT, DELETE",
},
})
}
```
Observe que **CORS também pode ser configurado em todas as rotas de API** dentro do arquivo **`middleware.ts`**:
```javascript
// app/middleware.ts

import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(request: NextRequest) {
const allowedOrigins = [
"https://yourdomain.com",
"https://sub.yourdomain.com",
]
const origin = request.headers.get("Origin")

const response = NextResponse.next()

if (allowedOrigins.includes(origin || "")) {
response.headers.set("Access-Control-Allow-Origin", origin || "")
response.headers.set(
"Access-Control-Allow-Methods",
"GET, POST, PUT, DELETE, OPTIONS"
)
response.headers.set(
"Access-Control-Allow-Headers",
"Content-Type, Authorization"
)
// If credentials are needed:
// response.headers.set('Access-Control-Allow-Credentials', 'true');
}

// Handle preflight requests
if (request.method === "OPTIONS") {
return new Response(null, {
status: 204,
headers: response.headers,
})
}

return response
}

export const config = {
matcher: "/api/:path*", // Apply to all API routes
}
```
**Problema:**

- **`Access-Control-Allow-Origin: '*'`:** Permite que qualquer site acesse a API, potencialmente permitindo que sites maliciosos interajam com sua API sem restrições.
- **Permissão ampla de métodos:** Permitir todos os métodos pode permitir que atacantes realizem ações indesejadas.

**Como atacantes exploram isso:**

Atacantes podem criar websites maliciosos que fazem requisições para sua API, potencialmente abusando de funcionalidades como recuperação de dados, manipulação de dados ou disparo de ações indesejadas em nome de usuários autenticados.


{{#ref}}
../../pentesting-web/cors-bypass.md
{{#endref}}

### Exposição de código do servidor no lado do cliente

Pode ser fácil **usar código do servidor também no código exposto ao cliente**. A melhor forma de garantir que um arquivo de código nunca seja exposto no cliente é usar este import no início do arquivo:
```js
import "server-only"
```
## Arquivos-chave e suas funções

### `middleware.ts` / `middleware.js`

**Localização:** Raiz do projeto ou dentro de `src/`.

**Propósito:** Executa código na função server-side serverless antes que uma requisição seja processada, permitindo tarefas como autenticação, redirects ou modificação de respostas.

**Fluxo de execução:**

1. **Requisição de entrada:** O middleware intercepta a requisição.
2. **Processamento:** Executa operações com base na requisição (por exemplo, verificar autenticação).
3. **Modificação da resposta:** Pode alterar a resposta ou passar o controle para o próximo handler.

**Exemplos de uso:**

- Redirecionar usuários não autenticados.
- Adicionar cabeçalhos personalizados.
- Registrar requisições.

**Exemplo de configuração:**
```typescript
// middleware.ts
import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(req: NextRequest) {
const url = req.nextUrl.clone()
if (!req.cookies.has("token")) {
url.pathname = "/login"
return NextResponse.redirect(url)
}
return NextResponse.next()
}

export const config = {
matcher: ["/protected/:path*"],
}
```
### `next.config.js`

**Localização:** Raiz do projeto.

**Propósito:** Configura o comportamento do Next.js, habilitando ou desabilitando recursos, customizando configurações do webpack, definindo variáveis de ambiente e configurando várias funcionalidades de segurança.

**Principais Configurações de Segurança:**

<details>

<summary>Cabeçalhos de Segurança</summary>

Os cabeçalhos de segurança aumentam a proteção da sua aplicação instruindo os navegadores sobre como lidar com o conteúdo. Eles ajudam a mitigar vários ataques como Cross-Site Scripting (XSS), Clickjacking e MIME type sniffing:

- Content Security Policy (CSP)
- X-Frame-Options
- X-Content-Type-Options
- Strict-Transport-Security (HSTS)
- Referrer Policy

**Exemplos:**
```javascript
// next.config.js

module.exports = {
async headers() {
return [
{
source: "/(.*)", // Apply to all routes
headers: [
{
key: "X-Frame-Options",
value: "DENY",
},
{
key: "Content-Security-Policy",
value:
"default-src *; script-src 'self' 'unsafe-inline' 'unsafe-eval';",
},
{
key: "X-Content-Type-Options",
value: "nosniff",
},
{
key: "Strict-Transport-Security",
value: "max-age=63072000; includeSubDomains; preload", // Enforces HTTPS
},
{
key: "Referrer-Policy",
value: "no-referrer", // Completely hides referrer
},
// Additional headers...
],
},
]
},
}
```
</details>

<details>

<summary>Configurações de Otimização de Imagens</summary>

Next.js otimiza imagens para desempenho, mas configurações incorretas podem levar a vulnerabilidades de segurança, como permitir que fontes não confiáveis injetem conteúdo malicioso.

**Exemplo de Configuração Ruim:**
```javascript
// next.config.js

module.exports = {
images: {
domains: ["*"], // Allows images from any domain
},
}
```
**Problema:**

- **`'*'`:** Permite que imagens sejam carregadas de qualquer fonte externa, incluindo domínios não confiáveis ou maliciosos. Atacantes podem hospedar imagens contendo payloads maliciosos ou conteúdo que engana os usuários.
- Outro problema pode ser permitir um domínio **onde qualquer um pode fazer upload de uma imagem** (como `raw.githubusercontent.com`)

**Como atacantes abusam disso:**

Ao injetar imagens de fontes maliciosas, atacantes podem realizar ataques de phishing, exibir informações enganosas ou explorar vulnerabilidades em bibliotecas de renderização de imagens.

</details>

<details>

<summary>Exposição de Variáveis de Ambiente</summary>

Gerencie informações sensíveis como chaves de API e credenciais de banco de dados com segurança sem expô-las ao cliente.

#### a. Expondo Variáveis Sensíveis

**Exemplo de Configuração Ruim:**
```javascript
// next.config.js

module.exports = {
env: {
SECRET_API_KEY: process.env.SECRET_API_KEY, // Exposed to the client
NEXT_PUBLIC_API_URL: process.env.NEXT_PUBLIC_API_URL, // Correctly prefixed for client
},
}
```
**Problema:**

- **`SECRET_API_KEY`:** Sem o prefixo `NEXT_PUBLIC_`, o Next.js não expõe variáveis para o cliente. No entanto, se prefixada por engano (p.ex., `NEXT_PUBLIC_SECRET_API_KEY`), ela se torna acessível no lado do cliente.

**Como atacantes exploram isso:**

Se variáveis sensíveis são expostas ao cliente, atacantes podem recuperá-las inspecionando o código do lado do cliente ou as requisições de rede, obtendo acesso não autorizado a APIs, bancos de dados ou outros serviços.

</details>

<details>

<summary>Redirecionamentos</summary>

Gerencie redirecionamentos e reescritas de URL dentro da sua aplicação, garantindo que os usuários sejam direcionados adequadamente sem introduzir open redirect vulnerabilities.

#### a. Open Redirect Vulnerability

**Exemplo de configuração ruim:**
```javascript
// next.config.js

module.exports = {
async redirects() {
return [
{
source: "/redirect",
destination: (req) => req.query.url, // Dynamically redirects based on query parameter
permanent: false,
},
]
},
}
```
**Problema:**

- **Dynamic Destination:** Permite que usuários especifiquem qualquer URL, possibilitando ataques de open redirect.
- **Trusting User Input:** Redirecionamentos para URLs fornecidas pelos usuários sem validação podem levar a phishing, distribuição de malware ou roubo de credenciais.

**Como atacantes o exploram:**

Atacantes podem criar URLs que aparentam originar do seu domínio, mas redirecionam os usuários para sites maliciosos. Por exemplo:
```bash
https://yourdomain.com/redirect?url=https://malicious-site.com
```
Usuários que confiam no domínio original podem, sem saber, navegar para sites maliciosos.

</details>

<details>

<summary>Webpack Configuration</summary>

Personalize as configurações do Webpack para sua aplicação Next.js, o que pode introduzir inadvertidamente vulnerabilidades de segurança se não for feito com cautela.

#### a. Expondo Módulos Sensíveis

**Exemplo de Configuração Ruim:**
```javascript
// next.config.js

module.exports = {
webpack: (config, { isServer }) => {
if (!isServer) {
config.resolve.alias["@sensitive"] = path.join(__dirname, "secret-folder")
}
return config
},
}
```
**Problema:**

- **Expondo caminhos sensíveis:** Alias de diretórios sensíveis e permitir acesso do lado do cliente pode leak informações confidenciais.
- **Empacotamento de segredos:** Se arquivos sensíveis são bundleados para o cliente, seu conteúdo se torna acessível através de source maps ou inspecionando o client-side code.

**Como atacantes exploram isso:**

Atacantes podem acessar ou reconstruir a estrutura de diretórios da aplicação, potencialmente encontrando e explorando arquivos ou dados sensíveis.

</details>

### `pages/_app.js` and `pages/_document.js`

#### **`pages/_app.js`**

**Propósito:** Substitui o componente App padrão, permitindo estado global, estilos e componentes de layout.

**Casos de uso:**

- Injetar CSS global.
- Adicionar layout wrappers.
- Integrar bibliotecas de gerenciamento de estado.

**Exemplo:**
```jsx
// pages/_app.js
import "../styles/globals.css"

function MyApp({ Component, pageProps }) {
return <Component {...pageProps} />
}

export default MyApp
```
#### **`pages/_document.js`**

**Propósito:** Substitui o Document padrão, permitindo a personalização das tags HTML e Body.

**Casos de uso:**

- Modificar as tags `<html>` ou `<body>`.
- Adicionar meta tags ou scripts personalizados.
- Integrar fontes de terceiros.

**Exemplo:**
```jsx
// pages/_document.js
import Document, { Html, Head, Main, NextScript } from "next/document"

class MyDocument extends Document {
render() {
return (
<Html lang="en">
<Head>{/* Custom fonts or meta tags */}</Head>
<body>
<Main />
<NextScript />
</body>
</Html>
)
}
}

export default MyDocument
```
### Custom Server (Opcional)

**Purpose:** Enquanto o Next.js vem com um servidor embutido, você pode criar um servidor customizado para casos de uso avançados, como roteamento customizado ou integração com serviços de back-end existentes.

**Note:** Usar um servidor customizado pode limitar as opções de implantação, especialmente em plataformas como Vercel que otimizam para o servidor embutido do Next.js.

**Example:**
```javascript
// server.js
const express = require("express")
const next = require("next")

const dev = process.env.NODE_ENV !== "production"
const app = next({ dev })
const handle = app.getRequestHandler()

app.prepare().then(() => {
const server = express()

// Custom route
server.get("/a", (req, res) => {
return app.render(req, res, "/a")
})

// Default handler
server.all("*", (req, res) => {
return handle(req, res)
})

server.listen(3000, (err) => {
if (err) throw err
console.log("> Ready on http://localhost:3000")
})
})
```
---

## Considerações Arquiteturais e de Segurança Adicionais

### Variáveis de Ambiente e Configuração

**Objetivo:** Gerenciar informações sensíveis e configurações fora da base de código.

**Boas Práticas:**

- **Use arquivos `.env`:** Armazene variáveis como API keys em `.env.local` (excluído do controle de versão).
- **Acesse Variáveis com Segurança:** Use `process.env.VARIABLE_NAME` para acessar variáveis de ambiente.
- **Nunca Exponha Secrets no Cliente:** Garanta que variáveis sensíveis sejam usadas apenas no lado do servidor.

**Exemplo:**
```javascript
// next.config.js
module.exports = {
env: {
API_KEY: process.env.API_KEY, // Accessible on both client and server
SECRET_KEY: process.env.SECRET_KEY, // Be cautious if accessible on the client
},
}
```
**Nota:** Para restringir variáveis apenas ao lado do servidor, omita-as do objeto `env` ou prefixe-as com `NEXT_PUBLIC_` para exposição no cliente.

### Autenticação e Autorização

**Abordagem:**

- **Autenticação baseada em sessão:** Use cookies para gerenciar sessões de usuário.
- **Autenticação baseada em tokens:** Implemente JWTs para autenticação sem estado.
- **Provedores de terceiros:** Integre com provedores OAuth (e.g., Google, GitHub) usando bibliotecas como `next-auth`.

**Práticas de segurança:**

- **Cookies seguros:** Defina os atributos `HttpOnly`, `Secure` e `SameSite`.
- **Hash de senhas:** Sempre aplique hash nas senhas antes de armazená-las.
- **Validação de entrada:** Previna ataques de injeção validando e sanitizando as entradas.

**Exemplo:**
```javascript
// pages/api/login.js
import { sign } from "jsonwebtoken"
import { serialize } from "cookie"

export default async function handler(req, res) {
const { username, password } = req.body

// Validate user credentials
if (username === "admin" && password === "password") {
const token = sign({ username }, process.env.JWT_SECRET, {
expiresIn: "1h",
})
res.setHeader(
"Set-Cookie",
serialize("auth", token, {
path: "/",
httpOnly: true,
secure: true,
sameSite: "strict",
})
)
res.status(200).json({ message: "Logged in" })
} else {
res.status(401).json({ error: "Invalid credentials" })
}
}
```
### Otimização de Desempenho

**Estratégias:**

- **Otimização de Imagens:** Use o componente `next/image` do Next.js para otimização automática de imagens.
- **Divisão de Código:** Use imports dinâmicos para dividir o código e reduzir o tempo de carregamento inicial.
- **Cache:** Implemente estratégias de cache para respostas de API e ativos estáticos.
- **Carregamento sob demanda:** Carregue componentes ou ativos apenas quando forem necessários.

**Exemplo:**
```jsx
// Dynamic Import with Code Splitting
import dynamic from "next/dynamic"

const HeavyComponent = dynamic(() => import("../components/HeavyComponent"), {
loading: () => <p>Loading...</p>,
})
```
## Enumeração de Server Actions do Next.js (hash para nome da função via source maps)

O Next.js moderno usa “Server Actions” que são executadas no servidor, mas são invocadas a partir do cliente. Em produção, essas invocações são opacas: todos os POSTs chegam a um endpoint comum e são distinguidos por um hash específico da build enviado no cabeçalho `Next-Action`. Exemplo:
```http
POST /
Next-Action: a9f8e2b4c7d1...
```
Quando `productionBrowserSourceMaps` está ativado, os chunks de JS minificado contêm chamadas para `createServerReference(...)` que leakam estrutura suficiente (além dos source maps associados) para recuperar um mapeamento entre o action hash e o nome original da função. Isso permite traduzir hashes observados em `Next-Action` para alvos concretos como `deleteUserAccount()` ou `exportFinancialData()`.

### Abordagem de extração (regex em JS minificado + source maps opcionais)

Procure nos chunks de JS baixados por `createServerReference` e extraia o hash e o símbolo da função/fonte. Dois padrões úteis:
```regex
# Strict pattern for standard minification
createServerReference\)"([a-f0-9]{40,})",\w+\.callServer,void 0,\w+\.findSourceMapURL,"([^"]+)"\)

# Flexible pattern handling various minification styles
createServerReference[^\"]*"([a-f0-9]{40,})"[^\"]*"([^"]+)"\s*\)
```
- Grupo 1: hash da server action (40+ caracteres hexadecimais)
- Grupo 2: símbolo ou caminho que pode ser resolvido para a função original via o source map quando presente

Se o script anunciar um source map (comentário de trailer `//# sourceMappingURL=<...>.map`), busque-o e resolva o símbolo/caminho para o nome da função original.

### Fluxo prático

- Descoberta passiva durante a navegação: capture requests com cabeçalhos `Next-Action` e URLs de JS chunk.
- Busque os bundles JS referenciados e os arquivos `*.map` acompanhantes (quando presentes).
- Execute a regex acima para construir um dicionário hash↔nome.
- Use o dicionário para direcionar os testes:
- Triagem orientada por nome (ex.: `transferFunds`, `exportFinancialData`).
- Acompanhe a cobertura entre builds pelo nome da função (hashes rotacionam entre builds).

### Exercitando ações ocultas (requisição baseada em template)

Pegue um POST válido observado no proxy como template e troque o valor `Next-Action` para direcionar outra action descoberta:
```http
# Before
Next-Action: a9f8e2b4c7d1

# After
Next-Action: b7e3f9a2d8c5
```
Reproduza no Repeater e teste autorização, validação de entrada e lógica de negócio de ações que seriam inacessíveis de outra forma.

### Burp automation

- NextjsServerActionAnalyzer (Burp extension) automatiza o acima no Burp:
- Varre o histórico do proxy em busca de JS chunks, extrai entradas `createServerReference(...)` e analisa source maps quando disponíveis.
- Mantém um dicionário pesquisável hash↔function-name e remove duplicatas entre builds pelo nome da função.
- Pode localizar um POST de template válido e abrir uma aba do Repeater pronta para envio com o hash da ação alvo substituído.
- Repo: https://github.com/Adversis/NextjsServerActionAnalyzer

### Notes and limitations

- Requer `productionBrowserSourceMaps` habilitado em produção para recuperar nomes de bundles/source maps.
- A divulgação de function-name não é uma vulnerabilidade por si só; use-a para orientar a descoberta e testar a autorização de cada action.

### React Server Components Flight protocol deserialization RCE (CVE-2025-55182)

Implantações do Next.js App Router que expõem Server Actions em `react-server-dom-webpack` **19.0.0–19.2.0 (Next.js 15.x/16.x)** contêm uma prototype pollution crítica no lado servidor durante a desserialização de chunks **Flight**. Ao criar referências `$` dentro de um payload Flight um atacante pode pivotar de prototypes poluídos para execução arbitrária de JavaScript e em seguida para execução de comandos do SO dentro do processo Node.js.

{{#ref}}
../../pentesting-web/deserialization/nodejs-proto-prototype-pollution/README.md
{{#endref}}

#### Cadeia de ataque em chunks Flight

1. **Prototype pollution primitive:** Defina `"then": "$1:__proto__:then"` para que o resolver escreva uma função `then` em `Object.prototype`. Qualquer objeto simples processado depois se torna thenable, permitindo ao atacante influenciar o fluxo de controle assíncrono dentro dos internals do RSC.
2. **Rebinding to the global `Function` constructor:** Aponte `_response._formData.get` para `"$1:constructor:constructor"`. Durante a resolução, `object.constructor` → `Object`, e `Object.constructor` → `Function`, então chamadas futuras a `_formData.get()` realmente executam `Function(...)`.
3. **Code execution via `_prefix`:** Coloque código JavaScript em `_response._prefix`. Quando o `_formData.get` poluído for invocado, o framework avalia `Function(_prefix)(...)`, então o JS injetado pode executar `require('child_process').exec()` ou qualquer outro primitivo do Node.

#### Esqueleto do payload
```json
{
"then": "$1:__proto__:then",
"status": "resolved_model",
"reason": -1,
"value": "{\"then\":\"$B1337\"}",
"_response": {
"_prefix": "require('child_process').exec('id')",
"_chunks": "$Q2",
"_formData": { "get": "$1:constructor:constructor" }
}
}
```
#### Mapeando a exposição de React Server Functions

React Server Functions (RSF) são quaisquer funções que incluem a diretiva 'use server';. Cada form action, mutation ou fetch helper ligado a uma dessas funções torna-se um RSC Flight endpoint que irá desserializar attacker-supplied payloads. Useful recon steps derived from React2Shell assessments:

- **Inventário estático:** procure pela diretiva para entender quantos RSFs estão sendo automaticamente expostos pelo framework.
```bash
rg -n "'use server';" -g"*.{js,ts,jsx,tsx}" app/
```
- **Padrões do App Router:** `create-next-app` habilita o App Router + o diretório `app/` por padrão, o que transforma silenciosamente cada rota em um endpoint compatível com RSC. App Router assets tais como `/_next/static/chunks/app/` ou respostas que streamam chunks Flight sobre `text/x-component` são fortes fingerprints expostos à Internet.
- **Implantações RSC implicitamente vulneráveis:** o advisory do React observa que apps que entregam o runtime RSC podem ser exploráveis **mesmo sem RSFs explícitas**, então trate qualquer build usando `react-server-dom-*` 19.0.0–19.2.0 como suspeito.
- **Outros frameworks que empacotam RSC:** Vite RSC, Parcel RSC, React Router RSC preview, RedwoodSDK, Waku, etc. reutilizam o mesmo serializer e herdam a mesma superfície remota de ataque até incorporarem builds do React corrigidos.

#### Cobertura de versões (React2Shell)

- `react-server-dom-webpack`, `react-server-dom-parcel`, `react-server-dom-turbopack`: **vulneráveis** em 19.0.0, 19.1.0–19.1.1 e 19.2.0; **corrigidos** em 19.0.1, 19.1.2 e 19.2.1, respectivamente.
- **Next.js stable:** releases do App Router 15.0.0–16.0.6 incorporam a pilha RSC vulnerável. Trens de patch 15.0.5 / 15.1.9 / 15.2.6 / 15.3.6 / 15.4.8 / 15.5.7 / 16.0.7 incluem dependências corrigidas, então qualquer build abaixo dessas versões é de alto valor.
- **Next.js canary:** `14.3.0-canary.77+` também entrega o runtime com bug e atualmente carece de canary drops corrigidos, tornando esses fingerprints fortes candidatos à exploração.

#### Oráculo de detecção remota

Assetnote’s [`react2shell-scanner`](https://github.com/assetnote/react2shell-scanner) envia uma Flight request multipart craftada para caminhos candidatos e observa o comportamento do lado servidor:

- **Modo padrão** executa um payload RCE determinístico (operação matemática refletida via `X-Action-Redirect`) provando execução de código.
- **`--safe-check` mode** malforma propositadamente a mensagem Flight para que servidores corrigidos retornem `200/400`, enquanto alvos vulneráveis emitem respostas `HTTP/500` contendo a substring `E{"digest"` dentro do corpo. Esse par `(500 + digest)` é atualmente o oráculo remoto mais confiável publicado por defensores.
- Os switches embutidos `--waf-bypass`, `--vercel-waf-bypass`, e `--windows` ajustam o layout do payload, prefixam junk, ou trocam comandos OS para que você possa sondar assets reais na Internet.
```bash
python3 scanner.py -u https://target.tld --path /app/api/submit --safe-check
python3 scanner.py -l hosts.txt -t 20 --waf-bypass -o vulnerable.json
```
## Referências

- [Pentesting Next.js Server Actions — Uma extensão do Burp para mapeamento hash-para-função](https://www.adversis.io/blogs/pentesting-next-js-server-actions)
- [NextjsServerActionAnalyzer (extensão do Burp)](https://github.com/Adversis/NextjsServerActionAnalyzer)
- [CVE-2025-55182 React Server Components — ferramenta de exploit de RCE](https://github.com/Spritualkb/CVE-2025-55182-exp)
- [CVE-2025-55182 & CVE-2025-66478 React2Shell – Tudo o que você precisa saber](https://jfrog.com/blog/2025-55182-and-2025-66478-react2shell-all-you-need-to-know/)
- [assetnote/react2shell-scanner](https://github.com/assetnote/react2shell-scanner)

{{#include ../../banners/hacktricks-training.md}}
