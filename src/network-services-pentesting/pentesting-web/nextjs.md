# NextJS

{{#include ../../banners/hacktricks-training.md}}

## Next.js एप्लिकेशन की सामान्य संरचना

### सामान्य फ़ाइल संरचना

एक मानक Next.js प्रोजेक्ट एक विशिष्ट फ़ाइल और डायरेक्टरी संरचना का पालन करता है जो इसके फीचर्स जैसे रूटिंग, API endpoints, और static asset management को सक्षम बनाती है। यहाँ एक सामान्य लेआउट है:
```lua
my-nextjs-app/
├── node_modules/
├── public/
│   ├── images/
│   │   └── logo.png
│   └── favicon.ico
├── app/
│   ├── api/
│   │   └── hello/
│   │       └── route.ts
│   ├── layout.tsx
│   ├── page.tsx
│   ├── about/
│   │   └── page.tsx
│   ├── dashboard/
│   │   ├── layout.tsx
│   │   └── page.tsx
│   ├── components/
│   │   ├── Header.tsx
│   │   └── Footer.tsx
│   ├── styles/
│   │   ├── globals.css
│   │   └── Home.module.css
│   └── utils/
│       └── api.ts
├── .env.local
├── next.config.js
├── tsconfig.json
├── package.json
├── README.md
└── yarn.lock / package-lock.json

```
### मुख्य निर्देशिकाएं और फ़ाइलें

- **public/:** images, fonts, और अन्य फाइलों जैसे static assets को होस्ट करता है। यहाँ की फाइलें root path (`/`) पर उपलब्ध होती हैं।
- **app/:** आपके एप्लिकेशन के pages, layouts, components, और API routes के लिए केंद्रीय डायरेक्टरी। यह **App Router** पैरेडाइम को अपनाती है, जो advanced routing features और server-client component segregation सक्षम बनाती है।
- **app/layout.tsx:** आपके एप्लिकेशन के लिए root layout परिभाषित करता है, सभी pages को रैप करता है और headers, footers, और navigation bars जैसे स्थायी UI तत्व प्रदान करता है।
- **app/page.tsx:** root route `/` के लिए entry point के रूप में कार्य करता है और home page render करता है।
- **app/[route]/page.tsx:** static और dynamic routes को संभालता है। `app/` के भीतर प्रत्येक फ़ोल्डर एक route segment का प्रतिनिधित्व करता है, और उन फ़ोल्डरों में मौजूद `page.tsx` उस route के component के अनुरूप होता है।
- **app/api/:** API routes को रखता है, जिससे आप serverless functions बना सकते हैं जो HTTP requests को हैंडल करते हैं। ये routes पारंपरिक `pages/api` डायरेक्टरी की जगह लेते हैं।
- **app/components/:** पुन: उपयोग योग्य React components को रखता है जिन्हें विभिन्न pages और layouts में उपयोग किया जा सकता है।
- **app/styles/:** global CSS फाइलें और component-scoped styling के लिए CSS Modules रखता है।
- **app/utils/:** utility functions, helper modules, और अन्य non-UI लॉजिक शामिल करता है जिन्हें पूरे एप्लिकेशन में साझा किया जा सकता है।
- **.env.local:** स्थानीय development environment के लिए specific environment variables को स्टोर करता है। ये variables version control में commit नहीं किए जाते हैं।
- **next.config.js:** Next.js के व्यवहार को customize करता है, जिसमें webpack configurations, environment variables, और security settings शामिल हैं।
- **tsconfig.json:** प्रोजेक्ट के लिए TypeScript सेटिंग्स configure करता है, जो type checking और अन्य TypeScript फीचर्स को सक्षम बनाती है।
- **package.json:** प्रोजेक्ट की dependencies, scripts, और metadata को manage करता है।
- **README.md:** प्रोजेक्ट के बारे में documentation और जानकारी प्रदान करता है, जिसमें setup निर्देश, उपयोग के निर्देश, और अन्य प्रासंगिक विवरण शामिल हैं।
- **yarn.lock / package-lock.json:** प्रोजेक्ट की dependencies को specific versions पर lock करते हैं, जिससे विभिन्न environments में consistent installations सुनिश्चित होती हैं।

## Next.js में क्लाइंट-साइड

### `app` डायरेक्टरी में फ़ाइल-आधारित राउटिंग

`app` डायरेक्टरी नवीनतम Next.js वर्ज़न्स में राउटिंग की आधारशिला है। यह filesystem का उपयोग करके routes को परिभाषित करती है, जिससे route प्रबंधन सहज और स्केलेबल बन जाता है।

<details>

<summary>रूट पाथ / को संभालना</summary>

**फ़ाइल संरचना:**
```arduino
my-nextjs-app/
├── app/
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**मुख्य फ़ाइलें:**

- **`app/page.tsx`**: रूट पाथ `/` पर आने वाले अनुरोधों को हैंडल करता है।
- **`app/layout.tsx`**: एप्लिकेशन के लिए लेआउट परिभाषित करता है, जो सभी पेजों को घेरता है।

**इम्प्लीमेंटेशन:**
```tsx
tsxCopy code// app/page.tsx

export default function HomePage() {
return (
<div>
<h1>Welcome to the Home Page!</h1>
<p>This is the root route.</p>
</div>
);
}
```
**व्याख्या:**

- **Route Definition:** `app` डायरेक्टरी के सीधे अंदर वाली `page.tsx` फ़ाइल `/` रूट के अनुरूप होती है।
- **Rendering:** यह घटक होम पेज के लिए सामग्री रेंडर करता है।
- **Layout Integration:** `HomePage` घटक को `layout.tsx` द्वारा लपेटा गया है, जो हेडर, फुटर और अन्य सामान्य तत्वों को शामिल कर सकता है।

</details>

<details>

<summary>अन्य स्थिर पथों को संभालना</summary>

**उदाहरण: `/about` रूट**

**फ़ाइल संरचना:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── about/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**क्रियान्वयन:**
```tsx
// app/about/page.tsx

export default function AboutPage() {
return (
<div>
<h1>About Us</h1>
<p>Learn more about our mission and values.</p>
</div>
)
}
```
**व्याख्या:** 

- **रूट परिभाषा:** `page.tsx` फाइल जो `about` फ़ोल्डर के अंदर है `/about` रूट के अनुरूप होती है।
- **रेंडरिंग:** यह component about पेज के लिए कंटेंट रेंडर करता है।

</details>

<details>

<summary>डायनामिक रूट्स</summary>

डायनामिक रूट्स उन पाथ्स को हैंडल करने की अनुमति देते हैं जिनमें वैरिएबल सेगमेंट होते हैं, जिससे एप्लिकेशन ऐसे पैरामीटरों (जैसे IDs, slugs आदि) के आधार पर कंटेंट दिखा सकती हैं।

**उदाहरण: `/posts/[id]` Route**

**File Structure:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── posts/
│   │   └── [id]/
│   │       └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**कार्यान्वयन:**
```tsx
tsxCopy code// app/posts/[id]/page.tsx

import { useRouter } from 'next/navigation';

interface PostProps {
params: { id: string };
}

export default function PostPage({ params }: PostProps) {
const { id } = params;
// Fetch post data based on 'id'

return (
<div>
<h1>Post #{id}</h1>
<p>This is the content of post {id}.</p>
</div>
);
}
```
**व्याख्या:**

- **डायनामिक सेगमेंट:** `[id]` रूट में एक डायनामिक सेगमेंट दर्शाता है, जो URL से `id` पैरामीटर को कैप्चर करता है।
- **पैरामीटर तक पहुँच:** `params` ऑब्जेक्ट में डायनामिक पैरामीटर होते हैं, जिन्हें component के भीतर एक्सेस किया जा सकता है।
- **रूट मिलान:** `/posts/*` से मेल खाने वाली कोई भी path, जैसे `/posts/1`, `/posts/abc`, आदि, इस component द्वारा संभाली जाएगी।

</details>

<details>

<summary>नेस्टेड रूट्स</summary>

Next.js nested routing को सपोर्ट करता है, जिससे directory layout की नकल करने वाली hierarchical route संरचनाएँ बनती हैं।

**उदाहरण: `/dashboard/settings/profile` Route**

**File Structure:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── dashboard/
│   │   ├── settings/
│   │   │   └── profile/
│   │   │       └── page.tsx
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**कार्यान्वयन:**
```tsx
tsxCopy code// app/dashboard/settings/profile/page.tsx

export default function ProfileSettingsPage() {
return (
<div>
<h1>Profile Settings</h1>
<p>Manage your profile information here.</p>
</div>
);
}
```
**स्पष्टीकरण:**

- **गहरी नेस्टिंग:** `page.tsx` फ़ाइल जो `dashboard/settings/profile/` के अंदर है, वह `/dashboard/settings/profile` रूट के अनुरूप है।
- **अनुक्रमिक संरचना का प्रतिबिंब:** डायरेक्टरी संरचना URL path को प्रतिबिंबित करती है, जिससे रखरखाव और स्पष्टता बेहतर होती है।

</details>

<details>

<summary>कैच-ऑल रूट्स</summary>

Catch-all routes कई nested segments या unknown paths को संभालते हैं, जिससे रूट हैंडलिंग में लचीलापन मिलता है।

**उदाहरण: `/*` रूट**

**फ़ाइल संरचना:**
```arduino
my-nextjs-app/
├── app/
│   ├── [..slug]/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**कार्यान्वयन:**
```tsx
// app/[...slug]/page.tsx

interface CatchAllProps {
params: { slug: string[] }
}

export default function CatchAllPage({ params }: CatchAllProps) {
const { slug } = params
const fullPath = `/${slug.join("/")}`

return (
<div>
<h1>Catch-All Route</h1>
<p>You have navigated to: {fullPath}</p>
</div>
)
}
```
**व्याख्या:**

- **Catch-All Segment:** `[...slug]` सभी शेष path segments को एक array के रूप में कैप्चर करता है।
- **Usage:** डायनेमिक रूटिंग परिदृश्यों जैसे user-generated paths, नेस्टेड श्रेणियाँ आदि को हैंडल करने के लिए उपयोगी।
- **Route Matching:** `/anything/here`, `/foo/bar/baz` जैसे paths इस component द्वारा हैंडल किए जाते हैं।

</details>

### संभावित क्लाइंट-साइड कमजोरियाँ

यद्यपि Next.js एक सुरक्षित आधार प्रदान करता है, अनुचित कोडिंग प्रथाएँ कमजोरियाँ पैदा कर सकती हैं। प्रमुख क्लाइंट-साइड कमजोरियों में शामिल हैं:

<details>

<summary>Cross-Site Scripting (XSS)</summary>

XSS हमले तब होते हैं जब दुर्भावनापूर्ण स्क्रिप्ट्स भरोसेमंद वेबसाइटों में इंजेक्ट की जाती हैं। हमलावर उपयोगकर्ता के ब्राउज़रों में स्क्रिप्ट्स चला सकते हैं, डेटा चुरा सकते हैं या उपयोगकर्ता की ओर से क्रियाएँ करवा सकते हैं।

**कमज़ोर कोड का उदाहरण:**
```jsx
// Dangerous: Injecting user input directly into HTML
function Comment({ userInput }) {
return <div dangerouslySetInnerHTML={{ __html: userInput }} />
}
```
**क्यों यह कमजोर है:** अविश्वसनीय इनपुट के साथ `dangerouslySetInnerHTML` का उपयोग करने से हमलावरों को हानिकारक स्क्रिप्ट इंजेक्ट करने की अनुमति मिलती है।

</details>

<details>

<summary>Client-Side Template Injection</summary>

यह तब होता है जब टेम्पलेट्स में उपयोगकर्ता इनपुट को ठीक से संभाला नहीं जाता, जिससे हमलावर टेम्पलेट्स या अभिव्यक्तियाँ इंजेक्ट और निष्पादित कर सकते हैं।

**कमज़ोर कोड का उदाहरण:**
```jsx
import React from "react"
import ejs from "ejs"

function RenderTemplate({ template, data }) {
const html = ejs.render(template, data)
return <div dangerouslySetInnerHTML={{ __html: html }} />
}
```
**क्यों यह कमजोर है:** यदि `template` या `data` में दुर्भावनापूर्ण सामग्री शामिल है, तो यह अनपेक्षित code के execution का कारण बन सकता है।

</details>

<details>

<summary>Client Path Traversal</summary>

यह एक vulnerability है जो attackers को client-side paths में हेरफेर करने की अनुमति देती है ताकि अनपेक्षित क्रियाएँ की जा सकें, जैसे कि Cross-Site Request Forgery (CSRF)। server-side path traversal, जो server के filesystem को लक्षित करता है, के विपरीत, CSPT client-side mechanisms का उपयोग करके वैध API requests को दुर्भावनापूर्ण endpoints की ओर reroute करने पर केंद्रित है।

**Example of Vulnerable Code:**

एक Next.js application उपयोगकर्ताओं को फ़ाइलें upload और download करने की अनुमति देता है। Download feature client side पर implement किया गया है, जहाँ उपयोगकर्ता डाउनलोड करने के लिए file path specify कर सकते हैं।
```jsx
// pages/download.js
import { useState } from "react"

export default function DownloadPage() {
const [filePath, setFilePath] = useState("")

const handleDownload = () => {
fetch(`/api/files/${filePath}`)
.then((response) => response.blob())
.then((blob) => {
const url = window.URL.createObjectURL(blob)
const a = document.createElement("a")
a.href = url
a.download = filePath
a.click()
})
}

return (
<div>
<h1>Download File</h1>
<input
type="text"
value={filePath}
onChange={(e) => setFilePath(e.target.value)}
placeholder="Enter file path"
/>
<button onClick={handleDownload}>Download</button>
</div>
)
}
```
#### हमला परिदृश्य

1. **हमलवार का उद्देश्य**: `filePath` को बदलकर CSRF attack करके एक महत्वपूर्ण फ़ाइल (उदा., `admin/config.json`) को हटाना।
2. **CSPT का शोषण**:
- **दुष्ट इनपुट**: हमलावर एक URL बनाता है जिसमें बदला हुआ `filePath` होता है जैसे `../deleteFile/config.json`।
- **Resulting API Call**: client-side code `/api/files/../deleteFile/config.json` पर अनुरोध भेजता है।
- **Server's Handling**: यदि server `filePath` को validate नहीं करता है, तो वह अनुरोध को process करता है, जिससे संवेदनशील फ़ाइलें हट सकती हैं या उजागर हो सकती हैं।
3. **CSRF को निष्पादित करना**:
- **Crafted Link**: हमलावर शिकार को एक लिंक भेजता है या एक दुष्ट script embed करता है जो बदले हुए `filePath` के साथ डाउनलोड अनुरोध को ट्रिगर करता है।
- **परिणाम**: शिकार अनजाने में यह क्रिया निष्पादित कर देता है, जिससे अनधिकृत फ़ाइल पहुँच या हटाना हो सकता है।

#### क्यों यह कमजोर है

- **इनपुट सत्यापन की कमी**: client-side arbitrary `filePath` inputs की अनुमति देता है, जिससे path traversal सक्षम हो जाता है।
- **Client Inputs पर भरोसा**: server-side API क्लाइंट इनपुट पर भरोसा करता है और बिना sanitization के `filePath` को process करता है।
- **संभावित API क्रियाएँ**: यदि API endpoint state-changing actions (उदा., फ़ाइलें delete या modify करना) करता है, तो इसे CSPT के जरिए exploit किया जा सकता है।

</details>

## Server-Side in Next.js

### Server-Side Rendering (SSR)

Pages प्रत्येक अनुरोध पर server पर render होते हैं, जिससे user को पूरी तरह rendered HTML मिलता है। इस मामले में आपको अनुरोधों को process करने के लिए अपना custom server बनाना चाहिए।

**उपयोग के मामले:**

- बार-बार बदलने वाली dynamic content।
- SEO optimization, क्योंकि search engines पूरी rendered page को crawl कर सकते हैं।

**Implementation:**
```jsx
// pages/index.js
export async function getServerSideProps(context) {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data } }
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### Static Site Generation (SSG)

पृष्ठों को बिल्ड समय पर पूर्व-रेंडर किया जाता है, जिससे लोड समय तेज़ और सर्वर लोड कम होता है।

**उपयोग के मामले:**

- ऐसी सामग्री जो अक्सर बदलती नहीं है।
- ब्लॉग, दस्तावेज़ और मार्केटिंग पेज।

**कार्यान्वयन:**
```jsx
// pages/index.js
export async function getStaticProps() {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data }, revalidate: 60 } // Revalidate every 60 seconds
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### सर्वरलेस फ़ंक्शंस (API Routes)

Next.js API endpoints को serverless functions के रूप में बनाने की अनुमति देता है। ये फ़ंक्शंस ऑन‑डिमांड चलते हैं और इनके लिए किसी समर्पित सर्वर की जरूरत नहीं होती।

**उपयोग के मामले:**

- फ़ॉर्म सबमिशन को संभालना।
- डेटाबेस के साथ इंटरैक्ट करना।
- डेटा प्रोसेस करना या थर्ड‑पार्टी APIs के साथ इंटीग्रेशन करना।

**कार्यान्वयन:**

Next.js 13 में `app` directory के परिचय के साथ, routing और API हैंडलिंग अधिक लचीला और सक्षम हो गया है। यह आधुनिक तरीका फ़ाइल‑आधारित राउटिंग सिस्टम के साथ निकटता से मेल खाता है और उन्नत क्षमताएँ प्रस्तुत करता है, जिनमें server और client components के लिए समर्थन शामिल है।

#### बेसिक रूट हैंडलर

**File Structure:**
```go
my-nextjs-app/
├── app/
│   └── api/
│       └── hello/
│           └── route.js
├── package.json
└── ...
```
**क्रियान्वयन:**
```javascript
// app/api/hello/route.js

export async function POST(request) {
return new Response(JSON.stringify({ message: "Hello from App Router!" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

// Client-side fetch to access the API endpoint
fetch("/api/submit", {
method: "POST",
headers: { "Content-Type": "application/json" },
body: JSON.stringify({ name: "John Doe" }),
})
.then((res) => res.json())
.then((data) => console.log(data))
```
**व्याख्या:**

- **स्थान:** API routes को `app/api/` डायरेक्टरी के अंतर्गत रखा जाता है।
- **फ़ाइल नामकरण:** हर API endpoint अपने अलग फ़ोल्डर में होता है जिसमें एक `route.js` या `route.ts` फ़ाइल होती है।
- **निर्यात किए गए फ़ंक्शन्स:** एक single default export की बजाय, विशिष्ट HTTP method फ़ंक्शन्स (जैसे `GET`, `POST`) को एक्सपोर्ट किया जाता है।
- **Response Handling:** `Response` constructor का उपयोग responses लौटाने के लिए करें, जिससे headers और status codes पर अधिक नियंत्रण मिलता है।

#### अन्य paths और methods को कैसे हैंडल करें:

<details>

<summary>विशिष्ट HTTP Methods को हैंडल करना</summary>

Next.js 13+ आपको उसी `route.js` या `route.ts` फ़ाइल के भीतर विशिष्ट HTTP methods के लिए handlers परिभाषित करने की अनुमति देता है, जिससे कोड स्पष्ट और अधिक व्यवस्थित बनता है।

**उदाहरण:**
```javascript
// app/api/users/[id]/route.js

export async function GET(request, { params }) {
const { id } = params
// Fetch user data based on 'id'
return new Response(JSON.stringify({ userId: id, name: "Jane Doe" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function PUT(request, { params }) {
const { id } = params
// Update user data based on 'id'
return new Response(JSON.stringify({ message: `User ${id} updated.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function DELETE(request, { params }) {
const { id } = params
// Delete user based on 'id'
return new Response(JSON.stringify({ message: `User ${id} deleted.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**व्याख्या:**

- **Multiple Exports:** हर HTTP method (`GET`, `PUT`, `DELETE`) की अपनी exported function होती है।
- **Parameters:** दूसरा आर्गुमेंट `params` के माध्यम से route parameters तक पहुँच प्रदान करता है।
- **Enhanced Responses:** response objects पर बेहतर नियंत्रण, जिससे headers और status codes का सटीक प्रबंधन संभव होता है।

</details>

<details>

<summary>Catch-All और Nested Routes</summary>

Next.js 13+ advanced routing features जैसे कि catch-all routes और nested API routes को सपोर्ट करता है, जो अधिक dynamic और scalable API संरचनाओं की अनुमति देता है।

**Catch-All Route उदाहरण:**
```javascript
// app/api/[...slug]/route.js

export async function GET(request, { params }) {
const { slug } = params
// Handle dynamic nested routes
return new Response(JSON.stringify({ slug }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**व्याख्या:**

- **Syntax:** `[...]` किसी catch-all segment को दर्शाता है, जो सभी nested paths को कैप्चर करता है।
- **Usage:** उन APIs के लिए उपयोगी जो बदलते route depths या dynamic segments को हैंडल करने की आवश्यकता रखते हैं।

**Nested Routes Example:**
```javascript
// app/api/posts/[postId]/comments/[commentId]/route.js

export async function GET(request, { params }) {
const { postId, commentId } = params
// Fetch specific comment for a post
return new Response(
JSON.stringify({ postId, commentId, comment: "Great post!" }),
{
status: 200,
headers: { "Content-Type": "application/json" },
}
)
}
```
**व्याख्या:**

- **Deep Nesting:** hierarchical API संरचनाओं की अनुमति देता है, जो संसाधन संबंधों को दर्शाती हैं।
- **Parameter Access:** `params` ऑब्जेक्ट के माध्यम से कई रूट पैरामीटरों तक आसानी से पहुंच।

</details>

<details>

<summary>Next.js 12 और उससे पहले में API routes को हैंडल करना</summary>

## `pages` Directory में API Routes (Next.js 12 और उससे पहले)

Next.js 13 ने `app` directory और बेहतर routing क्षमताएँ पेश करने से पहले, API routes मुख्यतः `pages` directory के भीतर परिभाषित होते थे। यह तरीका अभी भी व्यापक रूप से उपयोग किया जाता है और Next.js 12 और पुराने वर्ज़नों में समर्थित है।

#### बुनियादी API Route

**फ़ाइल संरचना:**
```go
goCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── hello.js
├── package.json
└── ...
```
**क्रियान्वयन:**
```javascript
javascriptCopy code// pages/api/hello.js

export default function handler(req, res) {
res.status(200).json({ message: 'Hello, World!' });
}
```
**व्याख्या:**

- **Location:** API routes `pages/api/` निर्देशिका के अंतर्गत स्थित होते हैं।
- **Export:** handler function को परिभाषित करने के लिए `export default` का उपयोग करें।
- **Function Signature:** handler को `req` (HTTP request) और `res` (HTTP response) ऑब्जेक्ट्स मिलते हैं।
- **Routing:** फ़ाइल का नाम (`hello.js`) endpoint `/api/hello` से मैप होता है।

#### डायनामिक API Routes

**फ़ाइल संरचना:**
```bash
bashCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── users/
│           └── [id].js
├── package.json
└── ...
```
**कार्यान्वयन:**
```javascript
javascriptCopy code// pages/api/users/[id].js

export default function handler(req, res) {
const {
query: { id },
method,
} = req;

switch (method) {
case 'GET':
// Fetch user data based on 'id'
res.status(200).json({ userId: id, name: 'John Doe' });
break;
case 'PUT':
// Update user data based on 'id'
res.status(200).json({ message: `User ${id} updated.` });
break;
case 'DELETE':
// Delete user based on 'id'
res.status(200).json({ message: `User ${id} deleted.` });
break;
default:
res.setHeader('Allow', ['GET', 'PUT', 'DELETE']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**व्याख्या:**

- **डायनेमिक सेगमेंट्स:** स्क्वायर ब्रैकेट्स (`[id].js`) डायनेमिक रूट सेगमेंट को दर्शाते हैं।
- **पैरामीटर एक्सेस करना:** डायनेमिक पैरामीटर तक पहुँचने के लिए `req.query.id` का उपयोग करें।
- **मेथड्स को हैंडल करना:** विभिन्न HTTP मेथड्स (`GET`, `PUT`, `DELETE`, आदि) को हैंडल करने के लिए शर्तीय लॉजिक का उपयोग करें।

#### विभिन्न HTTP मेथड्स को हैंडल करना

जबकि बेसिक API रूट उदाहरण एक ही फ़ंक्शन के भीतर सभी HTTP मेथड्स को हैंडल करता है, आप बेहतर स्पष्टता और मेंटेनबिलिटी के लिए प्रत्येक मेथड को स्पष्ट रूप से हैंडल करने हेतु अपना कोड संरचित कर सकते हैं।

**उदाहरण:**
```javascript
javascriptCopy code// pages/api/posts.js

export default async function handler(req, res) {
const { method } = req;

switch (method) {
case 'GET':
// Handle GET request
res.status(200).json({ message: 'Fetching posts.' });
break;
case 'POST':
// Handle POST request
res.status(201).json({ message: 'Post created.' });
break;
default:
res.setHeader('Allow', ['GET', 'POST']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**सर्वोत्तम प्रथाएँ:**

- **जिम्मेदारियों का पृथक्करण:** विभिन्न HTTP methods के लिए लॉजिक को स्पष्ट रूप से अलग रखें।
- **रिस्पॉन्स स्थिरता:** क्लाइंट-साइड हैंडलिंग की सुविधा के लिए response संरचनाओं को सुसंगत रखें।
- **त्रुटि हैंडलिंग:** असमर्थित मेथड्स और अप्रत्याशित त्रुटियों को उपयुक्त रूप से संभालें।

</details>

### CORS कॉन्फ़िगरेशन

नियंत्रित करें कि कौन से origins आपके API routes तक पहुँच सकते हैं, ताकि Cross-Origin Resource Sharing (CORS) vulnerabilities को कम किया जा सके।

**खराब कॉन्फ़िगरेशन उदाहरण:**
```javascript
// app/api/data/route.js

export async function GET(request) {
return new Response(JSON.stringify({ data: "Public Data" }), {
status: 200,
headers: {
"Access-Control-Allow-Origin": "*", // Allows any origin
"Access-Control-Allow-Methods": "GET, POST, PUT, DELETE",
},
})
}
```
ध्यान दें कि **CORS को सभी API routes में भी कॉन्फ़िगर किया जा सकता है** **`middleware.ts`** फ़ाइल के अंदर:
```javascript
// app/middleware.ts

import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(request: NextRequest) {
const allowedOrigins = [
"https://yourdomain.com",
"https://sub.yourdomain.com",
]
const origin = request.headers.get("Origin")

const response = NextResponse.next()

if (allowedOrigins.includes(origin || "")) {
response.headers.set("Access-Control-Allow-Origin", origin || "")
response.headers.set(
"Access-Control-Allow-Methods",
"GET, POST, PUT, DELETE, OPTIONS"
)
response.headers.set(
"Access-Control-Allow-Headers",
"Content-Type, Authorization"
)
// If credentials are needed:
// response.headers.set('Access-Control-Allow-Credentials', 'true');
}

// Handle preflight requests
if (request.method === "OPTIONS") {
return new Response(null, {
status: 204,
headers: response.headers,
})
}

return response
}

export const config = {
matcher: "/api/:path*", // Apply to all API routes
}
```
**समस्या:**

- **`Access-Control-Allow-Origin: '*'`:** किसी भी वेबसाइट को API तक पहुँच की अनुमति देता है, संभावित रूप से दुर्भावनापूर्ण साइटों को बिना किसी प्रतिबंध के आपके API के साथ इंटरैक्ट करने की अनुमति देता है।
- **विधियों की व्यापक अनुमति:** सभी विधियों को अनुमति देने से हमलावर अवांछित क्रियाएँ कर सकते हैं।

**हमलावर इसका कैसे फायदा उठाते हैं:**

हमलावर दुर्भावनापूर्ण वेबसाइटें बना सकते हैं जो आपके API के लिए अनुरोध करती हैं, संभावित रूप से डेटा पुनर्प्राप्ति, डेटा हेरफेर जैसी कार्यक्षमताओं का दुरुपयोग कर सकती हैं, या प्रमाणीकृत उपयोगकर्ताओं की ओर से अवांछित क्रियाएँ ट्रिगर कर सकती हैं।


{{#ref}}
../../pentesting-web/cors-bypass.md
{{#endref}}

### क्लाइंट-साइड में सर्वर कोड का एक्सपोज़ होना

यह आसान हो सकता है कि **सर्वर द्वारा उपयोग किया गया कोड क्लाइंट साइड में भी एक्सपोज़ होकर उपयोग में आ जाए**, किसी फ़ाइल के क्लाइंट साइड में कभी भी एक्सपोज़ न होने को सुनिश्चित करने का सबसे अच्छा तरीका है कि फ़ाइल की शुरुआत में इस import का उपयोग किया जाए:
```js
import "server-only"
```
## प्रमुख फ़ाइलें और उनकी भूमिकाएँ

### `middleware.ts` / `middleware.js`

**Location:** प्रोजेक्ट की रूट या `src/` के भीतर।

**Purpose:** किसी request को प्रोसेस करने से पहले सर्वर-साइड serverless फ़ंक्शन में कोड चलाता है, जिससे प्रमाणीकरण, रीडायरेक्ट्स, या प्रतिक्रियाओं को संशोधित करने जैसे कार्य संभव होते हैं।

**Execution Flow:**

1. **Incoming Request:** middleware रिक्वेस्ट को इंटरसेप्ट करता है।
2. **Processing:** रिक्वेस्ट के आधार पर ऑपरेशन करता है (उदा., प्रमाणीकरण की जाँच)।
3. **Response Modification:** प्रतिक्रिया को बदल सकता है या अगले handler को नियंत्रण दे सकता है।

**Example Use Cases:**

- अनप्रमाणीकृत उपयोगकर्ताओं को रीडायरेक्ट करना।
- कस्टम हेडर जोड़ना।
- रिक्वेस्ट्स का लॉग रखना।

**Sample Configuration:**
```typescript
// middleware.ts
import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(req: NextRequest) {
const url = req.nextUrl.clone()
if (!req.cookies.has("token")) {
url.pathname = "/login"
return NextResponse.redirect(url)
}
return NextResponse.next()
}

export const config = {
matcher: ["/protected/:path*"],
}
```
### `next.config.js`

**Location:** प्रोजेक्ट की रूट डायरेक्टरी।

**Purpose:** Next.js के व्यवहार को कॉन्फ़िगर करता है, फीचर्स को सक्षम या अक्षम करने, webpack कॉन्फ़िगरेशन्स को कस्टमाइज़ करने, environment variables सेट करने, और कई सुरक्षा फीचर्स कॉन्फ़िगर करने के लिए।

**Key Security Configurations:**

<details>

<summary>सुरक्षा हेडर्स</summary>

Security headers आपके एप्लिकेशन की सुरक्षा बढ़ाते हैं, ब्राउज़र को यह निर्देश देकर कि सामग्री को कैसे हैंडल करना है। वे Cross-Site Scripting (XSS), Clickjacking, और MIME type sniffing जैसे विभिन्न हमलों को कम करने में मदद करते हैं:

- Content Security Policy (CSP)
- X-Frame-Options
- X-Content-Type-Options
- Strict-Transport-Security (HSTS)
- Referrer Policy

**उदाहरण:**
```javascript
// next.config.js

module.exports = {
async headers() {
return [
{
source: "/(.*)", // Apply to all routes
headers: [
{
key: "X-Frame-Options",
value: "DENY",
},
{
key: "Content-Security-Policy",
value:
"default-src *; script-src 'self' 'unsafe-inline' 'unsafe-eval';",
},
{
key: "X-Content-Type-Options",
value: "nosniff",
},
{
key: "Strict-Transport-Security",
value: "max-age=63072000; includeSubDomains; preload", // Enforces HTTPS
},
{
key: "Referrer-Policy",
value: "no-referrer", // Completely hides referrer
},
// Additional headers...
],
},
]
},
}
```
</details>

<details>

<summary>Image Optimization Settings</summary>

Next.js प्रदर्शन के लिए इमेज़ों का अनुकूलन करता है, लेकिन गलत कॉन्फ़िगरेशन सुरक्षा कमजोरियों को जन्म दे सकते हैं, जैसे कि अविश्वसनीय स्रोतों को हानिकारक सामग्री इंजेक्ट करने की अनुमति देना।

**खराब कॉन्फ़िगरेशन उदाहरण:**
```javascript
// next.config.js

module.exports = {
images: {
domains: ["*"], // Allows images from any domain
},
}
```
**समस्या:**

- **`'*'`:** किसी भी external source से images को लोड करने की अनुमति देता है, जिसमें untrusted या malicious domains भी शामिल हैं। Attackers malicious payloads वाले images होस्ट कर सकते हैं या ऐसा content रख सकते हैं जो users को भ्रमित करे।
- एक और समस्या यह हो सकती है कि किसी डोमेन को अनुमति देना जहाँ **कोई भी image upload कर सके** (जैसे `raw.githubusercontent.com`)

**How attackers abuse it:**

Malicious sources से images इंजेक्ट करके, Attackers phishing attacks कर सकते हैं, भ्रामक जानकारी दिखा सकते हैं, या image rendering libraries में मौजूद vulnerabilities का exploit कर सकते हैं।

</details>

<details>

<summary>Environment Variables Exposure</summary>

API keys और database credentials जैसे sensitive information को secure तरीके से manage करें और इन्हें client को expose न होने दें।

#### a. Exposing Sensitive Variables

**खराब कॉन्फ़िगरेशन उदाहरण:**
```javascript
// next.config.js

module.exports = {
env: {
SECRET_API_KEY: process.env.SECRET_API_KEY, // Exposed to the client
NEXT_PUBLIC_API_URL: process.env.NEXT_PUBLIC_API_URL, // Correctly prefixed for client
},
}
```
**समस्या:**

- **`SECRET_API_KEY`:** `NEXT_PUBLIC_` prefix के बिना, Next.js client को variables expose नहीं करता है। हालांकि, यदि गलती से prefix किया गया (e.g., `NEXT_PUBLIC_SECRET_API_KEY`), तो यह client side पर accessible हो जाता है।

**How attackers इसका दुरुपयोग करते हैं:**

यदि संवेदनशील variables client को expose हो जाते हैं, तो attackers उन्हें client-side code या network requests की जांच करके प्राप्त कर सकते हैं, जिससे APIs, databases या अन्य सेवाओं तक अनधिकृत पहुँच मिल सकती है।

</details>

<details>

<summary>रिडायरेक्ट्स</summary>

अपने एप्लिकेशन में URL redirections और rewrites का प्रबंध करें, यह सुनिश्चित करते हुए कि users को सही तरीके से निर्देशित किया जाए बिना open redirect vulnerabilities पेश किए।

#### a. Open Redirect Vulnerability

**खराब कॉन्फ़िगरेशन उदाहरण:**
```javascript
// next.config.js

module.exports = {
async redirects() {
return [
{
source: "/redirect",
destination: (req) => req.query.url, // Dynamically redirects based on query parameter
permanent: false,
},
]
},
}
```
**समस्या:**

- **डायनामिक गंतव्य:** उपयोगकर्ताओं को किसी भी URL निर्दिष्ट करने की अनुमति देता है, जिससे open redirect attacks सक्षम होते हैं।
- **User Input पर भरोसा करना:** बिना सत्यापन के उपयोगकर्ताओं द्वारा दिए गए URLs पर रीडायरेक्ट करना phishing, malware distribution, या credential theft का कारण बन सकता है।

**हमलावर इसे कैसे दुरुपयोग करते हैं:**

हमलावर ऐसे URLs तैयार कर सकते हैं जो आपके डोमेन से आते हुए दिखते हैं, लेकिन उपयोगकर्ताओं को हानिकारक साइटों पर रीडायरेक्ट कर देते हैं। उदाहरण के लिए:
```bash
https://yourdomain.com/redirect?url=https://malicious-site.com
```
मूल डोमेन पर भरोसा करने वाले उपयोगकर्ता अनजाने में हानिकारक वेबसाइटों पर जा सकते हैं।

</details>

<details>

<summary>Webpack कॉन्फ़िगरेशन</summary>

अपने Next.js एप्लिकेशन के लिए Webpack कॉन्फ़िगरेशन कस्टमाइज़ करना — यदि सावधानी से न किया गया तो — अनजाने में सुरक्षा कमजोरियाँ पैदा कर सकता है।

#### a. संवेदनशील मॉड्यूल का खुलासा

**खराब कॉन्फ़िगरेशन उदाहरण:**
```javascript
// next.config.js

module.exports = {
webpack: (config, { isServer }) => {
if (!isServer) {
config.resolve.alias["@sensitive"] = path.join(__dirname, "secret-folder")
}
return config
},
}
```
**समस्या:**

- **Exposing Sensitive Paths:** Aliasing sensitive directories और client-side एक्सेस की अनुमति देने से गोपनीय जानकारी leak हो सकती है।
- **Bundling Secrets:** यदि संवेदनशील फ़ाइलें client के लिए bundled की जाती हैं, तो उनकी सामग्री source maps या client-side कोड की जांच से accessible हो सकती है।

**हमलावर इसे कैसे दुरुपयोग करते हैं:**

हमलावर एप्लिकेशन की directory structure तक पहुँच सकते हैं या उसे पुनर्निर्मित कर सकते हैं, जिससे संभावित रूप से संवेदनशील फाइलें या डेटा खोजे और exploit किए जा सकते हैं।

</details>

### `pages/_app.js` and `pages/_document.js`

#### **`pages/_app.js`**

**Purpose:** डिफ़ॉल्ट App component को ओवरराइड करता है, जो global state, styles, और layout components की अनुमति देता है।

**Use Cases:**

- global CSS को inject करना।
- layout wrappers जोड़ना।
- state management libraries को integrate करना।

**Example:**
```jsx
// pages/_app.js
import "../styles/globals.css"

function MyApp({ Component, pageProps }) {
return <Component {...pageProps} />
}

export default MyApp
```
#### **`pages/_document.js`**

**Purpose:** डिफ़ॉल्ट Document को ओवरराइड करता है, जिससे HTML और Body टैग्स को कस्टमाइज़ किया जा सकता है।

**Use Cases:**

- `<html>` या `<body>` टैग्स को संशोधित करना।
- meta टैग्स या कस्टम स्क्रिप्ट जोड़ना।
- थर्ड-पार्टी फॉन्ट्स को इंटीग्रेट करना।

**Example:**
```jsx
// pages/_document.js
import Document, { Html, Head, Main, NextScript } from "next/document"

class MyDocument extends Document {
render() {
return (
<Html lang="en">
<Head>{/* Custom fonts or meta tags */}</Head>
<body>
<Main />
<NextScript />
</body>
</Html>
)
}
}

export default MyDocument
```
### कस्टम सर्वर (वैकल्पिक)

**उद्देश्य:** हालांकि Next.js बिल्ट-इन सर्वर के साथ आता है, आप उन्नत उपयोग मामलों के लिए कस्टम सर्वर बना सकते हैं जैसे कस्टम रूटिंग या मौजूदा बैकएंड सेवाओं के साथ एकीकरण।

**नोट:** कस्टम सर्वर का उपयोग तैनाती विकल्पों को सीमित कर सकता है, विशेषकर उन प्लेटफ़ॉर्म्स पर जैसे Vercel जो Next.js के बिल्ट-इन सर्वर के लिए अनुकूलित हैं।

**उदाहरण:**
```javascript
// server.js
const express = require("express")
const next = require("next")

const dev = process.env.NODE_ENV !== "production"
const app = next({ dev })
const handle = app.getRequestHandler()

app.prepare().then(() => {
const server = express()

// Custom route
server.get("/a", (req, res) => {
return app.render(req, res, "/a")
})

// Default handler
server.all("*", (req, res) => {
return handle(req, res)
})

server.listen(3000, (err) => {
if (err) throw err
console.log("> Ready on http://localhost:3000")
})
})
```
---

## अतिरिक्त आर्किटेक्चरल और सुरक्षा विचार

### पर्यावरण वेरिएबल और कॉन्फ़िगरेशन

**उद्देश्य:** संवेदनशील जानकारी और कॉन्फ़िगरेशन सेटिंग्स को कोडबेस के बाहर प्रबंधित करना।

**सर्वश्रेष्ठ अभ्यास:**

- **`.env` फाइलों का उपयोग करें:** API keys जैसे वेरिएबल को `.env.local` में स्टोर करें (version control से बाहर)।
- **वेरिएबल्स तक सुरक्षित रूप से पहुँचें:** environment variables तक पहुँचने के लिए `process.env.VARIABLE_NAME` का उपयोग करें।
- **कभी भी क्लाइंट पर Secrets उजागर न करें:** सुनिश्चित करें कि संवेदनशील वेरिएबल केवल सर्वर-साइड पर ही उपयोग हों।

**उदाहरण:**
```javascript
// next.config.js
module.exports = {
env: {
API_KEY: process.env.API_KEY, // Accessible on both client and server
SECRET_KEY: process.env.SECRET_KEY, // Be cautious if accessible on the client
},
}
```
**नोट:** वेरिएबल्स को केवल server-side तक सीमित करने के लिए, उन्हें `env` object से हटा दें या client exposure के लिए `NEXT_PUBLIC_` से prefix करें।

### प्रमाणीकरण और प्राधिकरण

**पद्धति:**

- **Session-Based Authentication:** यूज़र सेशन्स को प्रबंधित करने के लिए cookies का उपयोग करें।
- **Token-Based Authentication:** stateless authentication के लिए JWTs लागू करें।
- **Third-Party Providers:** `next-auth` जैसी libraries का उपयोग करके OAuth providers (उदा., Google, GitHub) के साथ integrate करें।

**सुरक्षा अभ्यास:**

- **Secure Cookies:** `HttpOnly`, `Secure`, और `SameSite` attributes सेट करें।
- **Password Hashing:** स्टोर करने से पहले हमेशा पासवर्ड्स को hash करें।
- **Input Validation:** इनपुट्स को validate और sanitize करके injection attacks को रोकें।

**उदाहरण:**
```javascript
// pages/api/login.js
import { sign } from "jsonwebtoken"
import { serialize } from "cookie"

export default async function handler(req, res) {
const { username, password } = req.body

// Validate user credentials
if (username === "admin" && password === "password") {
const token = sign({ username }, process.env.JWT_SECRET, {
expiresIn: "1h",
})
res.setHeader(
"Set-Cookie",
serialize("auth", token, {
path: "/",
httpOnly: true,
secure: true,
sameSite: "strict",
})
)
res.status(200).json({ message: "Logged in" })
} else {
res.status(401).json({ error: "Invalid credentials" })
}
}
```
### प्रदर्शन अनुकूलन

**रणनीतियाँ:**

- **Image Optimization:** स्वचालित छवि अनुकूलन के लिए Next.js के `next/image` component का उपयोग करें।
- **Code Splitting:** कोड को विभाजित करने और प्रारंभिक लोड समय घटाने के लिए dynamic imports का उपयोग करें।
- **Caching:** API responses और static assets के लिए caching रणनीतियाँ लागू करें।
- **Lazy Loading:** घटकों या assets को केवल तभी लोड करें जब उनकी आवश्यकता हो।

**उदाहरण:**
```jsx
// Dynamic Import with Code Splitting
import dynamic from "next/dynamic"

const HeavyComponent = dynamic(() => import("../components/HeavyComponent"), {
loading: () => <p>Loading...</p>,
})
```
## Next.js Server Actions Enumeration (hash to function name via source maps)

आधुनिक Next.js “Server Actions” का उपयोग करता है जो सर्वर पर निष्पादित होते हैं पर क्लाइंट से invoke किए जाते हैं। प्रोडक्शन में ये अनुरोध अस्पष्ट होते हैं: सभी POSTs एक सामान्य endpoint पर आते हैं और इन्हें build-specific hash द्वारा अलग पहचाना जाता है जो `Next-Action` हेडर में भेजा जाता है। उदाहरण:
```http
POST /
Next-Action: a9f8e2b4c7d1...
```
When `productionBrowserSourceMaps` सक्षम होने पर, minified JS chunks में `createServerReference(...)` कॉल्स इतनी structure (plus associated source maps) leak कर देती हैं कि action hash और मूल function name के बीच mapping recover की जा सकती है। इससे आप `Next-Action` में देखे गए hashes को concrete targets जैसे `deleteUserAccount()` या `exportFinancialData()` में translate कर सकते हैं।

### Extraction approach (regex on minified JS + optional source maps)

downloaded JS chunks में `createServerReference` खोजें और hash तथा function/source symbol को extract करें। दो उपयोगी पैटर्न:
```regex
# Strict pattern for standard minification
createServerReference\)\"([a-f0-9]{40,})\",\w+\.callServer,void 0,\w+\.findSourceMapURL,\"([^\"]+)\"\)

# Flexible pattern handling various minification styles
createServerReference[^\"]*\"([a-f0-9]{40,})\"[^\"]*\"([^\"]+)\"\s*\)
```
- Group 1: सर्वर-एक्शन हैश (40+ hex chars)
- Group 2: symbol या path जो मौजूद source map से मूल फ़ंक्शन नाम में resolve किया जा सकता है

यदि स्क्रिप्ट किसी source map का ऐलान करती है (trailer comment `//# sourceMappingURL=<...>.map`), तो उसे fetch करें और symbol/path को मूल फ़ंक्शन नाम में resolve करें।

### व्यावहारिक वर्कफ़्लो

- ब्राउज़िंग के दौरान passive discovery: `Next-Action` headers और JS chunk URLs वाले requests को capture करें।
- संदर्भित JS bundles और साथ की `*.map` फाइलें (यदि मौजूद हों) fetch करें।
- ऊपर दिए regex को चलाकर hash↔name dictionary बनाएं।
- टेस्टिंग टार्गेट करने के लिए dictionary का उपयोग करें:
  - नाम-आधारित triage (e.g., `transferFunds`, `exportFinancialData`)।
  - function name के आधार पर builds में coverage track करें (hashes rotate across builds)।

### छिपे हुए actions का अभ्यास (template-based request)

प्रॉक्सी में देखे गए किसी मान्य POST को template के रूप में लें और किसी अन्य पाए गए action को लक्ष्य करने के लिए `Next-Action` value को बदल दें:
```http
# Before
Next-Action: a9f8e2b4c7d1

# After
Next-Action: b7e3f9a2d8c5
```
Repeater में replay करें और अन्यथा unreachable actions के authorization, input validation और business logic का परीक्षण करें।

### Burp ऑटोमेशन

- NextjsServerActionAnalyzer (Burp extension) ऊपर बताए गए कार्यों को Burp में ऑटोमेट करता है:
- Proxy history से JS chunks खंगालता है, `createServerReference(...)` एंट्रीज़ निकालता है, और उपलब्ध होने पर source maps को parse करता है।
- searchable hash↔function-name dictionary बनाए रखता है और function name के आधार पर builds में duplicates हटाता है।
- एक valid template POST खोज सकता है और target action के hash को swap करके एक ready-to-send Repeater tab खोल सकता है।
- Repo: https://github.com/Adversis/NextjsServerActionAnalyzer

### Notes and limitations

- Requires `productionBrowserSourceMaps` enabled in production ताकि bundles/source maps से names recover किए जा सकें।
- Function-name disclosure स्वयं में vulnerability नहीं है; इसे discovery में मार्गदर्शन और प्रत्येक action की authorization टेस्ट करने के लिए उपयोग करें।

## संदर्भ

- [Pentesting Next.js Server Actions — A Burp Extension for Hash-to-Function Mapping](https://www.adversis.io/blogs/pentesting-next-js-server-actions)
- [NextjsServerActionAnalyzer (Burp extension)](https://github.com/Adversis/NextjsServerActionAnalyzer)

{{#include ../../banners/hacktricks-training.md}}
