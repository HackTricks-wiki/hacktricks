# NextJS

{{#include ../../banners/hacktricks-training.md}}

## Bir Next.js Uygulamasının Genel Mimarisi

### Tipik Dosya Yapısı

Standart bir Next.js projesi, yönlendirme, API uç noktaları ve statik varlık yönetimi gibi özellikleri kolaylaştıran belirli bir dosya ve dizin yapısını takip eder. İşte tipik bir düzen:
```lua
my-nextjs-app/
├── node_modules/
├── public/
│   ├── images/
│   │   └── logo.png
│   └── favicon.ico
├── app/
│   ├── api/
│   │   └── hello/
│   │       └── route.ts
│   ├── layout.tsx
│   ├── page.tsx
│   ├── about/
│   │   └── page.tsx
│   ├── dashboard/
│   │   ├── layout.tsx
│   │   └── page.tsx
│   ├── components/
│   │   ├── Header.tsx
│   │   └── Footer.tsx
│   ├── styles/
│   │   ├── globals.css
│   │   └── Home.module.css
│   └── utils/
│       └── api.ts
├── .env.local
├── next.config.js
├── tsconfig.json
├── package.json
├── README.md
└── yarn.lock / package-lock.json

```
### Temel Dizinler ve Dosyalar

- **public/:** Görseller, fontlar ve diğer dosyalar gibi statik varlıkları barındırır. Buradaki dosyalara kök yolundan (`/`) erişilebilir.
- **app/:** Uygulamanızın sayfaları, layout'ları, komponentleri ve API route'ları için merkez dizin. **App Router** paradigmasını benimser; gelişmiş yönlendirme özellikleri ve sunucu-istemci komponent ayrımı sağlar.
- **app/layout.tsx:** Uygulama için kök layout'u tanımlar; tüm sayfaları sarar ve header, footer, navigasyon çubukları gibi tutarlı UI öğeleri sağlar.
- **app/page.tsx:** Kök rota `/` için giriş noktasıdır; ana sayfayı render eder.
- **app/[route]/page.tsx:** Statik ve dinamik route'ları ele alır. `app/` içindeki her klasör bir route segmentini temsil eder ve bu klasörlerdeki `page.tsx` ilgili route'un komponentine karşılık gelir.
- **app/api/:** API route'larını içerir; HTTP isteklerini işleyen sunucusuz fonksiyonlar oluşturmanıza olanak tanır. Bu route'lar geleneksel `pages/api` dizininin yerini alır.
- **app/components/:** Farklı sayfa ve layout'larda yeniden kullanılabilecek React komponentlerini barındırır.
- **app/styles/:** Global CSS dosyaları ve komponent-odaklı stil için CSS Module'ları içerir.
- **app/utils/:** Yardımcı fonksiyonlar, yardımcı modüller ve UI dışı diğer mantıkları içerir; uygulama genelinde paylaşılabilir.
- **.env.local:** Yerel geliştirme ortamına özgü environment değişkenlerini saklar. Bu değişkenler versiyon kontrolüne dahil edilmez.
- **next.config.js:** Next.js davranışını özelleştirir; webpack konfigürasyonları, environment değişkenleri ve güvenlik ayarlarını içerir.
- **tsconfig.json:** Proje için TypeScript ayarlarını yapılandırır; type checking ve diğer TypeScript özelliklerini etkinleştirir.
- **package.json:** Proje bağımlılıklarını, script'leri ve metadata'yı yönetir.
- **README.md:** Proje hakkında dokümantasyon ve bilgiler sağlar; kurulum talimatları, kullanım yönergeleri ve diğer ilgili detayları içerir.
- **yarn.lock / package-lock.json:** Projenin bağımlılıklarını belirli sürümlere kilitler; farklı ortamlarda tutarlı kurulumlar sağlar.

## Next.js'te İstemci Tarafı

### `app` Dizini'nde Dosya Tabanlı Yönlendirme

`app` dizini, son Next.js sürümlerinde yönlendirmenin temelini oluşturur. Route'ları tanımlamak için dosya sisteminden yararlanır; bu da route yönetimini sezgisel ve ölçeklenebilir hale getirir.

<details>

<summary>Kök Yol /'un İşlenmesi</summary>

**Dosya Yapısı:**
```arduino
my-nextjs-app/
├── app/
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Önemli Dosyalar:**

- **`app/page.tsx`**: Kök yol `/` için istekleri işler.
- **`app/layout.tsx`**: Uygulamanın düzenini tanımlar; tüm sayfaları kapsar.

**Uygulama:**
```tsx
tsxCopy code// app/page.tsx

export default function HomePage() {
return (
<div>
<h1>Welcome to the Home Page!</h1>
<p>This is the root route.</p>
</div>
);
}
```
**Açıklama:**

- **Rota Tanımı:** `page.tsx` dosyası, `app` dizininin doğrudan altındaki konumuyla `/` rotasına karşılık gelir.
- **Render Etme:** Bu bileşen ana sayfanın içeriğini render eder.
- **Layout Entegrasyonu:** `HomePage` bileşeni `layout.tsx` tarafından sarılır; bu dosya başlıklar, altbilgiler ve diğer ortak öğeleri içerebilir.

</details>

<details>

<summary>Diğer Statik Yolların İşlenmesi</summary>

**Örnek: `/about` Rotası**

**Dosya Yapısı:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── about/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Uygulama:**
```tsx
// app/about/page.tsx

export default function AboutPage() {
return (
<div>
<h1>About Us</h1>
<p>Learn more about our mission and values.</p>
</div>
)
}
```
**Açıklama:**

- **Rota Tanımı:** `about` klasörü içindeki `page.tsx` dosyası `/about` rotasına karşılık gelir.
- **Rendering:** Bu bileşen about sayfasının içeriğini render eder.

</details>

<details>

<summary>Dinamik Rotalar</summary>

Dinamik rotalar, değişken segmentlere sahip yolları işlemeyi sağlar; uygulamaların ID'ler, slug'lar gibi parametrelere göre içerik göstermesine olanak tanır.

**Örnek: `/posts/[id]` Rotası**

**Dosya Yapısı:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── posts/
│   │   └── [id]/
│   │       └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Uygulama:**
```tsx
tsxCopy code// app/posts/[id]/page.tsx

import { useRouter } from 'next/navigation';

interface PostProps {
params: { id: string };
}

export default function PostPage({ params }: PostProps) {
const { id } = params;
// Fetch post data based on 'id'

return (
<div>
<h1>Post #{id}</h1>
<p>This is the content of post {id}.</p>
</div>
);
}
```
**Açıklama:**

- **Dynamic Segment:** `[id]` yönlendirmedeki dinamik bir segmenti belirtir ve URL'den `id` parametresini yakalar.
- **Accessing Parameters:** `params` nesnesi dinamik parametreleri içerir ve bileşen içinde erişilebilir.
- **Route Matching:** `/posts/*` ile eşleşen herhangi bir yol, örn. `/posts/1`, `/posts/abc` vb., bu bileşen tarafından işlenecektir.

</details>

<details>

<summary>İç İçe Rotalar</summary>

Next.js, dizin yapısını yansıtan hiyerarşik rota yapıları oluşturmayı sağlayan iç içe yönlendirmeyi destekler.

**Örnek: `/dashboard/settings/profile` Rotası**

**Dosya Yapısı:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── dashboard/
│   │   ├── settings/
│   │   │   └── profile/
│   │   │       └── page.tsx
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Uygulama:**
```tsx
tsxCopy code// app/dashboard/settings/profile/page.tsx

export default function ProfileSettingsPage() {
return (
<div>
<h1>Profile Settings</h1>
<p>Manage your profile information here.</p>
</div>
);
}
```
**Açıklama:**

- **Derin İç İçe Geçme:** `page.tsx` dosyası `dashboard/settings/profile/` içindeki `/dashboard/settings/profile` rotasına karşılık gelir.
- **Hiyerarşi Yansıması:** Dizin yapısı URL yolunu yansıtarak bakım kolaylığı ve açıklık sağlar.

</details>

<details>

<summary>Catch-All Rotaları</summary>

Catch-All rotalar birden çok iç içe geçmiş segmenti veya bilinmeyen yolları işler ve rota yönetiminde esneklik sağlar.

**Örnek: `/*` Rota**

**Dosya Yapısı:**
```arduino
my-nextjs-app/
├── app/
│   ├── [..slug]/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Uygulama:**
```tsx
// app/[...slug]/page.tsx

interface CatchAllProps {
params: { slug: string[] }
}

export default function CatchAllPage({ params }: CatchAllProps) {
const { slug } = params
const fullPath = `/${slug.join("/")}`

return (
<div>
<h1>Catch-All Route</h1>
<p>You have navigated to: {fullPath}</p>
</div>
)
}
```
**Açıklama:**

- **Catch-All Segment:** `[...slug]` kalan tüm yol segmentlerini bir dizi olarak yakalar.
- **Kullanım:** Kullanıcı tarafından oluşturulan yollar, iç içe kategoriler gibi dinamik yönlendirme senaryolarını yönetmek için faydalıdır.
- **Rota Eşleştirme:** `/anything/here`, `/foo/bar/baz`, vb. yollar bu bileşen tarafından işlenir.

</details>

### Potansiyel İstemci Tarafı Zafiyetleri

Next.js güvenli bir temel sağlasa da, hatalı kodlama uygulamaları zafiyetlere yol açabilir. Temel istemci tarafı zafiyetleri şunlardır:

<details>

<summary>Cross-Site Scripting (XSS)</summary>

XSS saldırıları, kötü amaçlı betiklerin güvenilir web sitelerine enjekte edilmesi durumunda meydana gelir. Saldırganlar kullanıcıların tarayıcılarında betikler çalıştırarak veri çalabilir veya kullanıcının adına işlemler gerçekleştirebilir.

**Zafiyetli Kod Örneği:**
```jsx
// Dangerous: Injecting user input directly into HTML
function Comment({ userInput }) {
return <div dangerouslySetInnerHTML={{ __html: userInput }} />
}
```
**Neden Güvenli Değil:** Güvenilmeyen girdilerle `dangerouslySetInnerHTML` kullanmak, saldırganların kötü amaçlı script'ler enjekte etmesine izin verir.

</details>

<details>

<summary>Client-Side Template Injection</summary>

Kullanıcı girdilerinin şablonlarda düzgün işlenmemesi durumunda ortaya çıkar; bu, saldırganların şablon veya ifadeleri enjekte edip çalıştırmasına olanak tanır.

**Kırılgan Kod Örneği:**
```jsx
import React from "react"
import ejs from "ejs"

function RenderTemplate({ template, data }) {
const html = ejs.render(template, data)
return <div dangerouslySetInnerHTML={{ __html: html }} />
}
```
**Neden Zafiyet Var:** Eğer `template` veya `data` kötü amaçlı içerik içeriyorsa, istem dışı kod çalıştırılmasına yol açabilir.

</details>

<details>

<summary>Client Path Traversal</summary>

Bu, saldırganların istemci tarafı yollarını manipüle ederek Cross-Site Request Forgery (CSRF) gibi istem dışı işlemler gerçekleştirmesine izin veren bir zafiyettir. Sunucunun dosya sistemini hedef alan server-side path traversal'ın aksine, CSPT meşru API isteklerini kötü amaçlı uç noktalara yönlendirmek için istemci tarafı mekanizmaları istismar etmeye odaklanır.

**Örnek Zafiyetli Kod:**

Bir Next.js uygulaması kullanıcılara dosya yükleyip indirme imkanı sunar. İndirme özelliği istemci tarafında uygulanmıştır; kullanıcılar indirmek istedikleri dosyanın yolunu belirtebilirler.
```jsx
// pages/download.js
import { useState } from "react"

export default function DownloadPage() {
const [filePath, setFilePath] = useState("")

const handleDownload = () => {
fetch(`/api/files/${filePath}`)
.then((response) => response.blob())
.then((blob) => {
const url = window.URL.createObjectURL(blob)
const a = document.createElement("a")
a.href = url
a.download = filePath
a.click()
})
}

return (
<div>
<h1>Download File</h1>
<input
type="text"
value={filePath}
onChange={(e) => setFilePath(e.target.value)}
placeholder="Enter file path"
/>
<button onClick={handleDownload}>Download</button>
</div>
)
}
```
#### Saldırı Senaryosu

1. **Saldırganın Hedefi**: `filePath`'i manipüle ederek kritik bir dosyayı (ör. `admin/config.json`) silmek için bir CSRF saldırısı gerçekleştirmek.
2. **CSPT'yi İstismar Etme**:
- **Kötü Amaçlı Girdi**: Saldırgan `../deleteFile/config.json` gibi manipüle edilmiş bir `filePath` ile bir URL hazırlar.
- **Ortaya Çıkan API Çağrısı**: İstemci tarafı kodu `/api/files/../deleteFile/config.json` isteği yapar.
- **Sunucunun İşleyişi**: Eğer sunucu `filePath`'i doğrulamazsa isteği işler ve potansiyel olarak hassas dosyaları silebilir veya açığa çıkarabilir.
3. **CSRF'i Gerçekleştirme**:
- **Hazırlanmış Bağlantı**: Saldırgan, kurbana manipüle edilmiş `filePath` ile indirme isteğini tetikleyen bir bağlantı gönderir veya kötü amaçlı bir script gömer.
- **Sonuç**: Kurban farkında olmadan işlemi gerçekleştirir; bu da yetkisiz dosya erişimine veya silinmesine yol açar.

#### Neden Güvenlik Açığı Var

- **Girdi Doğrulama Eksikliği**: İstemci tarafı rastgele `filePath` girdilerine izin veriyor, bu da path traversal'a izin veriyor.
- **İstemci Girdilerine Güvenme**: Sunucu tarafı API, `filePath`'i sanitasyon olmadan güvenerek işler.
- **Olası API Eylemleri**: Eğer API endpoint'i durum değiştirici eylemler gerçekleştiriyorsa (ör. dosyaları silme, değiştirme), CSPT aracılığıyla istismar edilebilir.

</details>

## Next.js'de Sunucu Tarafı

### Sunucu Tarafı Rendering (SSR)

Sayfalar her istekte sunucuda render edilir, böylece kullanıcıya tam render edilmiş HTML ulaşır. Bu durumda istekleri işlemek için kendi özel sunucunuzu oluşturmalısınız.

**Kullanım Durumları:**

- Sık sık değişen dinamik içerik.
- SEO optimizasyonu, çünkü arama motorları tam render edilmiş sayfayı tarayabilir.

**Uygulama:**
```jsx
// pages/index.js
export async function getServerSideProps(context) {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data } }
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### Statik Site Oluşturma (SSG)

Sayfalar derleme zamanında önceden render edilir, bu da daha hızlı yükleme süreleri ve azaltılmış sunucu yükü ile sonuçlanır.

**Kullanım Durumları:**

- Sık değişmeyen içerik.
- Bloglar, dokümantasyon, pazarlama sayfaları.

**Uygulama:**
```jsx
// pages/index.js
export async function getStaticProps() {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data }, revalidate: 60 } // Revalidate every 60 seconds
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### Sunucusuz Fonksiyonlar (API Routes)

Next.js, API uç noktalarının sunucusuz fonksiyonlar olarak oluşturulmasına izin verir. Bu fonksiyonlar, özel bir sunucuya ihtiyaç duymadan talep üzerine çalışır.

**Kullanım Durumları:**

- Form gönderimlerini işleme.
- Veritabanlarıyla etkileşim.
- Veri işleme veya üçüncü taraf API'lerle entegrasyon.

**Uygulama:**

Next.js 13'teki `app` dizininin tanıtılmasıyla routing ve API işleme daha esnek ve güçlü hale geldi. Bu modern yaklaşım, dosya tabanlı routing sistemiyle yakından uyumlu olmakla birlikte sunucu ve istemci bileşenlerini destekleme dahil olmak üzere geliştirilmiş yetenekler sunar.

#### Temel Route Handler

**Dosya Yapısı:**
```go
my-nextjs-app/
├── app/
│   └── api/
│       └── hello/
│           └── route.js
├── package.json
└── ...
```
**Uygulama:**
```javascript
// app/api/hello/route.js

export async function POST(request) {
return new Response(JSON.stringify({ message: "Hello from App Router!" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

// Client-side fetch to access the API endpoint
fetch("/api/submit", {
method: "POST",
headers: { "Content-Type": "application/json" },
body: JSON.stringify({ name: "John Doe" }),
})
.then((res) => res.json())
.then((data) => console.log(data))
```
**Açıklama:**

- **Konum:** API route'ları `app/api/` dizini altında yer alır.
- **Dosya İsimlendirmesi:** Her API endpoint'i, içinde `route.js` veya `route.ts` dosyası bulunan kendi klasöründe yer alır.
- **Export Edilen Fonksiyonlar:** Tek bir varsayılan export yerine, belirli HTTP methodu fonksiyonları (ör. `GET`, `POST`) export edilir.
- **Yanıt İşleme:** Yanıtları döndürmek için `Response` constructor'ını kullanın; bu, başlıklar ve durum kodları üzerinde daha fazla kontrol sağlar.

#### Diğer yollar ve HTTP methodları nasıl ele alınır:

<details>

<summary>Belirli HTTP Metodlarının İşlenmesi</summary>

Next.js 13+, aynı `route.js` veya `route.ts` dosyası içinde belirli HTTP metodları için handler'lar tanımlamanıza izin verir; bu, daha temiz ve düzenli kod sağlar.

**Örnek:**
```javascript
// app/api/users/[id]/route.js

export async function GET(request, { params }) {
const { id } = params
// Fetch user data based on 'id'
return new Response(JSON.stringify({ userId: id, name: "Jane Doe" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function PUT(request, { params }) {
const { id } = params
// Update user data based on 'id'
return new Response(JSON.stringify({ message: `User ${id} updated.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function DELETE(request, { params }) {
const { id } = params
// Delete user based on 'id'
return new Response(JSON.stringify({ message: `User ${id} deleted.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**Açıklama:**

- **Birden Çok Dışa Aktarım:** Her HTTP yöntemi (`GET`, `PUT`, `DELETE`) kendi dışa aktarılmış fonksiyonuna sahiptir.
- **Parametreler:** İkinci argüman, route parametrelerine `params` aracılığıyla erişim sağlar.
- **Gelişmiş Yanıtlar:** Yanıt nesneleri üzerinde daha fazla kontrol, başlıklar ve durum kodlarının hassas yönetimine olanak tanır.

</details>

<details>

<summary>Catch-All ve İç İçe Rotalar</summary>

Next.js 13+ catch-all rotalar ve iç içe API rotaları gibi gelişmiş yönlendirme özelliklerini destekler; bu da daha dinamik ve ölçeklenebilir API yapıları sağlar.

**Catch-All Rota Örneği:**
```javascript
// app/api/[...slug]/route.js

export async function GET(request, { params }) {
const { slug } = params
// Handle dynamic nested routes
return new Response(JSON.stringify({ slug }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**Açıklama:**

- **Sözdizimi:** `[...]` tüm iç içe geçmiş yolları yakalayan bir catch-all segmentini belirtir.
- **Kullanım:** Değişken yol derinliklerine veya dinamik segmentlere ihtiyaç duyan API'ler için kullanışlıdır.

**İç İçe Rotalar Örneği:**
```javascript
// app/api/posts/[postId]/comments/[commentId]/route.js

export async function GET(request, { params }) {
const { postId, commentId } = params
// Fetch specific comment for a post
return new Response(
JSON.stringify({ postId, commentId, comment: "Great post!" }),
{
status: 200,
headers: { "Content-Type": "application/json" },
}
)
}
```
**Açıklama:**

- **Derin İç İçe Yerleştirme:** Kaynak ilişkilerini yansıtan hiyerarşik API yapıları sağlar.
- **Parametre Erişimi:** `params` nesnesi aracılığıyla birden fazla yol parametresine kolayca erişim sağlar.

</details>

<details>

<summary>Next.js 12 ve Öncesinde API route'larının Ele Alınması</summary>

## `pages` Dizinindeki API Route'ları (Next.js 12 ve Öncesi)

Next.js 13 `app` dizinini ve geliştirilmiş yönlendirme yeteneklerini tanıtmadan önce, API route'ları esas olarak `pages` dizini içinde tanımlanıyordu. Bu yaklaşım, Next.js 12 ve önceki sürümlerde hâlâ yaygın olarak kullanılır ve desteklenir.

#### Temel API Route

**Dosya Yapısı:**
```go
goCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── hello.js
├── package.json
└── ...
```
**Uygulama:**
```javascript
javascriptCopy code// pages/api/hello.js

export default function handler(req, res) {
res.status(200).json({ message: 'Hello, World!' });
}
```
**Açıklama:**

- **Konum:** API rotaları `pages/api/` dizini altında yer alır.
- **Dışa Aktarım:** Handler fonksiyonunu tanımlamak için `export default` kullanın.
- **Fonksiyon İmzası:** Handler, `req` (HTTP isteği) ve `res` (HTTP yanıtı) nesnelerini alır.
- **Yönlendirme:** Dosya adı (`hello.js`) `/api/hello` endpoint'ine karşılık gelir.

#### Dinamik API Rotaları

**Dosya Yapısı:**
```bash
bashCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── users/
│           └── [id].js
├── package.json
└── ...
```
**Uygulama:**
```javascript
javascriptCopy code// pages/api/users/[id].js

export default function handler(req, res) {
const {
query: { id },
method,
} = req;

switch (method) {
case 'GET':
// Fetch user data based on 'id'
res.status(200).json({ userId: id, name: 'John Doe' });
break;
case 'PUT':
// Update user data based on 'id'
res.status(200).json({ message: `User ${id} updated.` });
break;
case 'DELETE':
// Delete user based on 'id'
res.status(200).json({ message: `User ${id} deleted.` });
break;
default:
res.setHeader('Allow', ['GET', 'PUT', 'DELETE']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**Açıklama:**

- **Dinamik Segmentler:** Köşeli parantezler (`[id].js`) dinamik rota segmentlerini belirtir.
- **Parametrelere Erişim:** Dinamik parametreye erişmek için `req.query.id` kullanın.
- **Metodların İşlenmesi:** Farklı HTTP yöntemlerini (`GET`, `PUT`, `DELETE`, vb.) işlemek için koşullu mantık kullanın.

#### Farklı HTTP Yöntemlerini İşleme

Temel API rota örneği tek bir fonksiyon içinde tüm HTTP yöntemlerini işlerken, daha iyi açıklık ve sürdürülebilirlik için kodunuzu her yöntemi açıkça ele alacak şekilde yapılandırabilirsiniz.

**Örnek:**
```javascript
javascriptCopy code// pages/api/posts.js

export default async function handler(req, res) {
const { method } = req;

switch (method) {
case 'GET':
// Handle GET request
res.status(200).json({ message: 'Fetching posts.' });
break;
case 'POST':
// Handle POST request
res.status(201).json({ message: 'Post created.' });
break;
default:
res.setHeader('Allow', ['GET', 'POST']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**En İyi Uygulamalar:**

- **Sorumlulukların Ayrılması:** Farklı HTTP yöntemleri için mantığı açıkça ayırın.
- **Yanıt Tutarlılığı:** İstemci tarafı işlemlerini kolaylaştırmak için tutarlı yanıt yapıları sağlayın.
- **Hata Yönetimi:** Desteklenmeyen yöntemleri ve beklenmeyen hataları uygun şekilde ele alın.

</details>

### CORS Configuration

API rotalarınıza hangi origin'lerin erişebileceğini kontrol ederek Cross-Origin Resource Sharing (CORS) zafiyetlerini hafifletin.

**Kötü Yapılandırma Örneği:**
```javascript
// app/api/data/route.js

export async function GET(request) {
return new Response(JSON.stringify({ data: "Public Data" }), {
status: 200,
headers: {
"Access-Control-Allow-Origin": "*", // Allows any origin
"Access-Control-Allow-Methods": "GET, POST, PUT, DELETE",
},
})
}
```
Unutmayın ki **CORS tüm API routes'ta da yapılandırılabilir** `middleware.ts` dosyası içinde:
```javascript
// app/middleware.ts

import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(request: NextRequest) {
const allowedOrigins = [
"https://yourdomain.com",
"https://sub.yourdomain.com",
]
const origin = request.headers.get("Origin")

const response = NextResponse.next()

if (allowedOrigins.includes(origin || "")) {
response.headers.set("Access-Control-Allow-Origin", origin || "")
response.headers.set(
"Access-Control-Allow-Methods",
"GET, POST, PUT, DELETE, OPTIONS"
)
response.headers.set(
"Access-Control-Allow-Headers",
"Content-Type, Authorization"
)
// If credentials are needed:
// response.headers.set('Access-Control-Allow-Credentials', 'true');
}

// Handle preflight requests
if (request.method === "OPTIONS") {
return new Response(null, {
status: 204,
headers: response.headers,
})
}

return response
}

export const config = {
matcher: "/api/:path*", // Apply to all API routes
}
```
**Problem:**

- **`Access-Control-Allow-Origin: '*'`:** Herhangi bir web sitesinin API'ye erişmesine izin verir; kötü amaçlı sitelerin API'nizle sınırlama olmadan etkileşimde bulunmasına olanak sağlayabilir.
- **Wide Method Allowance:** Tüm HTTP yöntemlerine izin vermek, saldırganların istenmeyen işlemler gerçekleştirmesine olanak tanıyabilir.

**How attackers exploit it:**

Saldırganlar, API'nize istek gönderen kötü amaçlı web siteleri oluşturabilir; bu sayede veri alma, veri manipülasyonu veya yetkili kullanıcılar adına istenmeyen işlemleri tetikleme gibi işlevleri suistimal edebilirler.


{{#ref}}
../../pentesting-web/cors-bypass.md
{{#endref}}

### Sunucu kodunun İstemci Tarafında açığa çıkması

Sunucuda kullanılan kodun istemci tarafında açığa çıkarılan ve kullanılan kodlarda da kolayca **use code used by the server also in code exposed and used by the client side** olarak kullanılabileceği durumlar olabilir; bir kod dosyasının hiçbir zaman istemci tarafında açığa çıkmamasını sağlamak için dosyanın başında şu import'u kullanmak en iyi yoldur:
```js
import "server-only"
```
## Ana Dosyalar ve Rolleri

### `middleware.ts` / `middleware.js`

**Konum:** Projenin kökünde veya `src/` içinde.

**Amaç:** Bir isteğin işlenmesinden önce sunucu tarafındaki serverless fonksiyonunda kod çalıştırır; kimlik doğrulama, yönlendirmeler veya yanıtları değiştirme gibi görevleri yapmaya olanak tanır.

**Çalışma Akışı:**

1. **Gelen İstek:** middleware isteği yakalar.
2. **İşleme:** İsteğe bağlı işlemler gerçekleştirir (ör. kimlik doğrulaması kontrolü).
3. **Yanıt Değişikliği:** Yanıtı değiştirebilir veya kontrolü bir sonraki işleyiciye geçirebilir.

**Örnek Kullanım Senaryoları:**

- Kimlik doğrulanmamış kullanıcıları yönlendirme.
- Özel başlıklar ekleme.
- İstekleri kaydetme.

**Örnek Konfigürasyon:**
```typescript
// middleware.ts
import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(req: NextRequest) {
const url = req.nextUrl.clone()
if (!req.cookies.has("token")) {
url.pathname = "/login"
return NextResponse.redirect(url)
}
return NextResponse.next()
}

export const config = {
matcher: ["/protected/:path*"],
}
```
### `next.config.js`

**Konum:** Projenin kök dizini.

**Amaç:** Next.js davranışlarını yapılandırır; özellikleri etkinleştirip devre dışı bırakma, webpack yapılandırmalarını özelleştirme, environment değişkenlerini ayarlama ve çeşitli güvenlik özelliklerini yapılandırma.

**Önemli Güvenlik Yapılandırmaları:**

<details>

<summary>Güvenlik Başlıkları</summary>

Güvenlik başlıkları, tarayıcılara içeriği nasıl işlemeleri gerektiğini bildirerek uygulamanızın güvenliğini artırır. Cross-Site Scripting (XSS), Clickjacking ve MIME type sniffing gibi çeşitli saldırıları hafifletmeye yardımcı olurlar:

- Content Security Policy (CSP)
- X-Frame-Options
- X-Content-Type-Options
- Strict-Transport-Security (HSTS)
- Referrer Policy

**Örnekler:**
```javascript
// next.config.js

module.exports = {
async headers() {
return [
{
source: "/(.*)", // Apply to all routes
headers: [
{
key: "X-Frame-Options",
value: "DENY",
},
{
key: "Content-Security-Policy",
value:
"default-src *; script-src 'self' 'unsafe-inline' 'unsafe-eval';",
},
{
key: "X-Content-Type-Options",
value: "nosniff",
},
{
key: "Strict-Transport-Security",
value: "max-age=63072000; includeSubDomains; preload", // Enforces HTTPS
},
{
key: "Referrer-Policy",
value: "no-referrer", // Completely hides referrer
},
// Additional headers...
],
},
]
},
}
```
</details>

<details>

<summary>Görüntü Optimizasyonu Ayarları</summary>

Next.js performans için görselleri optimize eder, ancak yanlış yapılandırmalar, güvensiz kaynakların kötü amaçlı içerik enjekte etmesine izin vermek gibi güvenlik açıklarına yol açabilir.

**Kötü Yapılandırma Örneği:**
```javascript
// next.config.js

module.exports = {
images: {
domains: ["*"], // Allows images from any domain
},
}
```
**Sorun:**

- **`'*'`:** Herhangi bir harici kaynaktan, güvensiz veya kötü niyetli alanlar da dahil olmak üzere görüntülerin yüklenmesine izin verir. Saldırganlar kötü amaçlı payload'lar içeren veya kullanıcıları yanıltan içerikler barındıran görüntüleri sunabilir.
- Diğer bir sorun, **herkesin bir görüntü yükleyebileceği** bir alan adına izin vermek olabilir (ör. `raw.githubusercontent.com`)

**Saldırganlar bunu nasıl kötüye kullanır:**

Kötü amaçlı kaynaklardan görüntüler enjekte ederek, saldırganlar phishing saldırıları gerçekleştirebilir, yanıltıcı bilgiler gösterebilir veya görüntü renderlama kütüphanelerindeki güvenlik açıklarından faydalanabilir.

</details>

<details>

<summary>Environment Variables Exposure</summary>

API anahtarları ve veritabanı kimlik bilgileri gibi hassas bilgileri, bunları istemciye ifşa etmeden güvenli bir şekilde yönetin.

#### a. Hassas Değişkenlerin İfşası

**Kötü Yapılandırma Örneği:**
```javascript
// next.config.js

module.exports = {
env: {
SECRET_API_KEY: process.env.SECRET_API_KEY, // Exposed to the client
NEXT_PUBLIC_API_URL: process.env.NEXT_PUBLIC_API_URL, // Correctly prefixed for client
},
}
```
**Sorun:**

- **`SECRET_API_KEY`:** `NEXT_PUBLIC_` öneki olmadan, Next.js değişkenleri istemciye açmaz. Ancak yanlışlıkla öneklenirse (ör. `NEXT_PUBLIC_SECRET_API_KEY`), istemci tarafında erişilebilir hale gelir.

**Saldırganlar bunu nasıl kötüye kullanır:**

Eğer hassas değişkenler istemciye açılırsa, saldırganlar istemci tarafı kodunu veya ağ isteklerini inceleyerek bunları ele geçirebilir ve API'lara, veritabanlarına veya diğer servislere yetkisiz erişim sağlayabilir.

</details>

<details>

<summary>Yönlendirmeler</summary>

Uygulamanız içinde URL yönlendirmelerini ve rewrite işlemlerini yönetin; kullanıcıların uygun şekilde yönlendirildiğinden emin olun ve open redirect zafiyetleri oluşturmayın.

#### a. Open Redirect Vulnerability

**Kötü Konfigürasyon Örneği:**
```javascript
// next.config.js

module.exports = {
async redirects() {
return [
{
source: "/redirect",
destination: (req) => req.query.url, // Dynamically redirects based on query parameter
permanent: false,
},
]
},
}
```
**Sorun:**

- **Dinamik Hedef:** Kullanıcıların herhangi bir URL belirtmesine izin verir; bu da open redirect attacks'e olanak tanır.
- **Kullanıcı Girdisine Güvenme:** Doğrulama olmadan kullanıcılar tarafından sağlanan URL'lere yapılan yönlendirmeler phishing, malware distribution veya credential theft ile sonuçlanabilir.

**Saldırganlar bunu nasıl suistimal eder:**

Saldırganlar, domaininizden kaynaklanıyormuş gibi görünen ancak kullanıcıları kötü amaçlı sitelere yönlendiren URL'ler oluşturabilir. Örneğin:
```bash
https://yourdomain.com/redirect?url=https://malicious-site.com
```
Orijinal domaine güvenen kullanıcılar farkında olmadan zararlı web sitelerine yönlendirilebilir.

</details>

<details>

<summary>Webpack Yapılandırması</summary>

Next.js uygulamanız için Webpack yapılandırmalarını özelleştirmek, dikkatli davranılmadığında istemeden güvenlik açıkları oluşturabilir.

#### a. Hassas Modüllerin Açığa Çıkarılması

**Kötü Yapılandırma Örneği:**
```javascript
// next.config.js

module.exports = {
webpack: (config, { isServer }) => {
if (!isServer) {
config.resolve.alias["@sensitive"] = path.join(__dirname, "secret-folder")
}
return config
},
}
```
**Sorun:**

- **Hassas Yolların Açığa Çıkması:** Hassas dizinlerin aliaslanması ve istemci tarafı erişimine izin verilmesi gizli bilgilerin leak olmasına neden olabilir.
- **Gizli Dosyaların Paketlenmesi:** Hassas dosyalar istemci için bundle edildiğinde, içerikleri source maps veya istemci tarafı kodunu inceleyerek erişilebilir hale gelir.

**Saldırganlar bunu nasıl kötüye kullanır:**

Saldırganlar uygulamanın dizin yapısına erişebilir veya yeniden oluşturabilir; potansiyel olarak hassas dosyaları veya verileri bulup exploit edebilirler.

</details>

### `pages/_app.js` ve `pages/_document.js`

#### **`pages/_app.js`**

**Amaç:** Varsayılan App bileşenini override ederek global state, stiller ve layout bileşenlerine izin verir.

**Kullanım Durumları:**

- Global CSS ekleme.
- Layout wrapper'ları ekleme.
- Durum yönetimi kütüphanelerini entegre etme.

**Örnek:**
```jsx
// pages/_app.js
import "../styles/globals.css"

function MyApp({ Component, pageProps }) {
return <Component {...pageProps} />
}

export default MyApp
```
#### **`pages/_document.js`**

**Amaç:** Varsayılan Document'i geçersiz kılarak `<html>` ve `<body>` etiketlerini özelleştirmeye olanak tanır.

**Kullanım Durumları:**

- `<html>` veya `<body>` etiketlerini değiştirme.
- meta etiketleri veya özel scriptler ekleme.
- üçüncü taraf fontlarını entegre etme.

**Örnek:**
```jsx
// pages/_document.js
import Document, { Html, Head, Main, NextScript } from "next/document"

class MyDocument extends Document {
render() {
return (
<Html lang="en">
<Head>{/* Custom fonts or meta tags */}</Head>
<body>
<Main />
<NextScript />
</body>
</Html>
)
}
}

export default MyDocument
```
### Özel Sunucu (İsteğe Bağlı)

**Amaç:** Next.js yerleşik bir sunucu ile birlikte gelirken, özelleştirilmiş yönlendirme veya mevcut backend hizmetleriyle entegrasyon gibi gelişmiş kullanım durumları için özel bir sunucu oluşturabilirsiniz.

**Not:** Özel bir sunucu kullanmak, özellikle Next.js'in yerleşik sunucusu için optimize eden Vercel gibi platformlarda dağıtım seçeneklerini sınırlayabilir.

**Örnek:**
```javascript
// server.js
const express = require("express")
const next = require("next")

const dev = process.env.NODE_ENV !== "production"
const app = next({ dev })
const handle = app.getRequestHandler()

app.prepare().then(() => {
const server = express()

// Custom route
server.get("/a", (req, res) => {
return app.render(req, res, "/a")
})

// Default handler
server.all("*", (req, res) => {
return handle(req, res)
})

server.listen(3000, (err) => {
if (err) throw err
console.log("> Ready on http://localhost:3000")
})
})
```
---

## Ek Mimari ve Güvenlik Hususları

### Ortam Değişkenleri ve Konfigürasyon

**Amaç:** Hassas bilgileri ve konfigürasyon ayarlarını kod tabanının dışında yönetmek.

**En İyi Uygulamalar:**

- **`.env` Dosyalarını Kullanın:** API anahtarları gibi değişkenleri `.env.local` içinde saklayın (versiyon kontrolünden hariç tutulur).
- **Değişkenlere Güvenli Erişim:** Ortam değişkenlerine erişmek için `process.env.VARIABLE_NAME` kullanın.
- **Sırlar Asla İstemci Tarafında Açığa Çıkartılmasın:** Hassas değişkenlerin sadece sunucu tarafında kullanıldığından emin olun.

**Örnek:**
```javascript
// next.config.js
module.exports = {
env: {
API_KEY: process.env.API_KEY, // Accessible on both client and server
SECRET_KEY: process.env.SECRET_KEY, // Be cautious if accessible on the client
},
}
```
**Not:** Değişkenleri yalnızca sunucu tarafıyla sınırlamak için, onları `env` object'inden çıkarın veya istemciye açmak için başlarına `NEXT_PUBLIC_` önekini ekleyin.

### Kimlik Doğrulama ve Yetkilendirme

**Yaklaşım:**

- **Oturum Tabanlı Kimlik Doğrulama:** Kullanıcı oturumlarını yönetmek için çerezleri kullanın.
- **Jeton Tabanlı Kimlik Doğrulama:** Durumsuz kimlik doğrulama için JWTs uygulayın.
- **Üçüncü Taraf Sağlayıcılar:** OAuth sağlayıcılarıyla (ör. Google, GitHub) `next-auth` gibi kütüphaneler kullanarak entegrasyon yapın.

**Güvenlik Uygulamaları:**

- **Güvenli Çerezler:** `HttpOnly`, `Secure` ve `SameSite` özniteliklerini ayarlayın.
- **Parola Hashleme:** Parolaları saklamadan önce her zaman hash'leyin.
- **Girdi Doğrulama:** Girdileri doğrulayarak ve temizleyerek injection saldırılarını önleyin.

**Örnek:**
```javascript
// pages/api/login.js
import { sign } from "jsonwebtoken"
import { serialize } from "cookie"

export default async function handler(req, res) {
const { username, password } = req.body

// Validate user credentials
if (username === "admin" && password === "password") {
const token = sign({ username }, process.env.JWT_SECRET, {
expiresIn: "1h",
})
res.setHeader(
"Set-Cookie",
serialize("auth", token, {
path: "/",
httpOnly: true,
secure: true,
sameSite: "strict",
})
)
res.status(200).json({ message: "Logged in" })
} else {
res.status(401).json({ error: "Invalid credentials" })
}
}
```
### Performans Optimizasyonu

**Stratejiler:**

- **Görüntü Optimizasyonu:** Otomatik görüntü optimizasyonu için Next.js'in `next/image` bileşenini kullanın.
- **Kod Bölme:** Kodun bölünmesi ve ilk yükleme sürelerini azaltmak için dinamik import'ları kullanın.
- **Önbellekleme:** API yanıtları ve statik varlıklar için önbellekleme stratejileri uygulayın.
- **Tembel Yükleme:** Bileşenleri veya varlıkları yalnızca gerektiğinde yükleyin.

**Örnek:**
```jsx
// Dynamic Import with Code Splitting
import dynamic from "next/dynamic"

const HeavyComponent = dynamic(() => import("../components/HeavyComponent"), {
loading: () => <p>Loading...</p>,
})
```
## Next.js Server Actions Enumeration (hash to function name via source maps)

Modern Next.js, sunucuda çalışan ama istemciden çağrılan “Server Actions” kullanır. Prodüksiyonda bu çağrılar opaktır: tüm POST'lar ortak bir endpoint'e düşer ve `Next-Action` header'ında gönderilen build'e özgü bir hash ile ayırt edilir. Örnek:
```http
POST /
Next-Action: a9f8e2b4c7d1...
```
`productionBrowserSourceMaps` etkinleştirildiğinde, minified JS parçaları `createServerReference(...)` çağrılarını içerir; bu çağrılar action hash ile orijinal fonksiyon adı arasındaki eşlemeyi geri kazanmak için yeterli yapı (ve ilişkili source maps) leak eder. Bu sayede `Next-Action` içinde gözlemlenen hash'leri `deleteUserAccount()` veya `exportFinancialData()` gibi somut hedeflere çevirebilirsiniz.

### Çıkarma yaklaşımı (regex on minified JS + optional source maps)

İndirilen JS parçalarında `createServerReference`'ı arayın ve hash ile fonksiyon/kaynak sembolünü çıkarın. İki kullanışlı desen:
```regex
# Strict pattern for standard minification
createServerReference\)\"([a-f0-9]{40,})\",\w+\.callServer,void 0,\w+\.findSourceMapURL,\"([^\"]+)\"\)

# Flexible pattern handling various minification styles
createServerReference[^\"]*\"([a-f0-9]{40,})\"[^\"]*\"([^\"]+)\"\s*\)
```
- Grup 1: server action hash (40+ hex chars)
- Grup 2: source map mevcut olduğunda orijinal fonksiyon adına çözülebilen sembol veya yol

If the script advertises a source map (trailer comment `//# sourceMappingURL=<...>.map`), fetch it and resolve the symbol/path to the original function name.

### Pratik iş akışı

- Gözatma sırasında pasif keşif: `Next-Action` header'ları ve JS chunk URL'lerini içeren istekleri yakalayın.
- Referans verilen JS bundle'larını ve mevcutsa beraberindeki `*.map` dosyalarını fetch edin.
- Yukarıdaki regex'i çalıştırarak bir hash↔name sözlüğü oluşturun.
- Sözlüğü test hedeflemekte kullanın:
  - İsim tabanlı önceliklendirme (ör. `transferFunds`, `exportFinancialData`).
  - Fonksiyon adına göre build'ler arasında coverage'ı takip edin (hash'ler build'ler arasında döner).

### Exercising hidden actions (template-based request)

Proxy'de gözlemlenen geçerli bir POST'u şablon olarak alın ve başka bir keşfedilmiş action'ı hedeflemek için `Next-Action` değerini değiştirin:
```http
# Before
Next-Action: a9f8e2b4c7d1

# After
Next-Action: b7e3f9a2d8c5
```
Repeater'da yeniden oynatıp aksi takdirde ulaşılamayan eylemlerin authorization, input validation ve business logic'ini test edin.

### Burp automation

- NextjsServerActionAnalyzer (Burp extension) yukarıdakileri Burp içinde otomatikleştirir:
- Proxy geçmişini JS chunk'ları için tarar, `createServerReference(...)` girdilerini çıkarır ve mevcutsa source map'lerini çözer.
- Aranabilir bir hash↔function-name sözlüğü tutar ve function name'e göre build'ler arasında duplicate'leri kaldırır.
- Geçerli bir template POST bulabilir ve hedef action'ın hash'inin yerleştirildiği, gönderilmeye hazır bir Repeater sekmesi açabilir.
- Repo: https://github.com/Adversis/NextjsServerActionAnalyzer

### Notes and limitations

- `productionBrowserSourceMaps`'un production'da etkin olmasını gerektirir; aksi takdirde bundle/source map'lerden isimleri kurtaramaz.
- Function-name disclosure tek başına bir güvenlik açığı değildir; bunu keşfi yönlendirmek ve her bir action'ın authorization'ını test etmek için kullanın.

## Referanslar

- [Pentesting Next.js Server Actions — A Burp Extension for Hash-to-Function Mapping](https://www.adversis.io/blogs/pentesting-next-js-server-actions)
- [NextjsServerActionAnalyzer (Burp extension)](https://github.com/Adversis/NextjsServerActionAnalyzer)

{{#include ../../banners/hacktricks-training.md}}
