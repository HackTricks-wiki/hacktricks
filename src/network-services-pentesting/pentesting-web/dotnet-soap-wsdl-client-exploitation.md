# .NET SOAP/WSDL Client Proxy Abuse

{{#include ../../banners/hacktricks-training.md}}

## TL;DR

- `SoapHttpClientProtocol`, `DiscoveryClientProtocol` and friends inherit from `HttpWebClientProtocol`, whose `GetWebRequest()` returns the scheme-agnostic `WebRequest` instance produced by `WebRequest.Create()` without enforcing `HttpWebRequest`.
- If an attacker controls the proxy `Url`, the framework silently swaps in `FileWebRequest`, `FtpWebRequest` or UNC/SMB handlers, turning "HTTP" proxies into NTLM leak gadgets or arbitrary file writers.
- Any feature that imports attacker-supplied WSDL with `ServiceDescriptionImporter` compounds the bug: the WSDL controls the generated proxy constructor, SOAP methods, complex types and namespaces, enabling pre-auth RCE (webshells, script drops) in products such as Barracuda Service Center RMM, Ivanti EPM, Umbraco 8, PowerShell and SSIS.

## Root cause: HttpWebClientProtocol is scheme-agnostic

`WebClientProtocol.GetWebRequest()` doen `var req = WebRequest.Create(uri)` en gee dit terug sonder verandering. `HttpWebClientProtocol.GetWebRequest()` probeer `req as HttpWebRequest` om HTTP-only velde te stel, maar dit **gee nog steeds die oorspronklike `req` terug** selfs wanneer die cast misluk. Die runtime gehoorsaam dus watter skema in `Url` geskryf is:

- `http(s)://` → `HttpWebRequest`
- `file:///` of `\\host\share\` → `FileWebRequest`
- `ftp://` → `FtpWebRequest`

`SoapHttpClientProtocol.Invoke()` stroom dan die SOAP POST-body deur watter transportskyf ook al gekies is, selfs al beteken dit skryf na skyf of oor SMB.

## Primitief 1 – NTLM capture / relay via UNC targets

1. Verkry beheer oor `SoapHttpClientProtocol.Url` (direkte setter, config-waarde, databasisry, ens.).
2. Wys dit na 'n UNC-pad soos `file://attacker.local/sink/payload`.
3. Die CLR open die pad via SMB en voer geïntegreerde autentisering uit, wat NTLM challenge/response na die aanvaller lekt.
4. Gebruik vasgelegde hashes vir offline kraking of NTLM relay (SMB/HTTP) as signing/EPA afwesig is.

Dit geld vir **enige** .NET SOAP/HTTP proxy-pad wat gebruikersinvoer aanvaar, selfs al is verdere eksploit nie moontlik nie.

## Primitief 2 – Arbitrêre lêerskrywe via `file://`

1. Stel `Url = "file:///inetpub/wwwroot/poc.aspx"` (of enige skryfbare pad) voordat die proxy-oproep.
2. Roep enige SOAP-metode aan; die framework skryf die hele SOAP-envelope na die gekose pad en oorskryf bestaande lêers.
3. Gebruiker-beheerde argumente verskyn binne XML-elemente, wat aanvallers toelaat om CSHTML/ASPX payloads te drop of konfigurasielêers te vergiftig.

Beperkings:

- Inhoud is altyd XML; scalêre velde word entity-gekodeer, so direkte invoeging van `<script>` via eenvoudige strings vereis addisionele truuks.
- Betekenisvolle payloads benodig minstens een aanvaller-beïnvloede argument of die vermoë om die metode-handtekening te wysig (sien WSDL-abuse).

Die runtime gooi dikwels `Client found response content type of 'application/octet-stream', but expected 'text/xml'` na die skryf — behandel hierdie fout as 'n IOC.

## Weaponizing WSDL imports

### Auto-generated proxies via `ServiceDescriptionImporter`

Baie produkte bied "custom web service" funksies wat 'n WSDL URL aanvaar, en dan:

1. `ServiceDescription.Read()` die aanvaller-beheerde WSDL.
2. `ServiceDescriptionImporter` genereer C# proxy-klasses wat `SoapHttpClientProtocol` uitbrei.
3. CodeDOM kompileer die proxy en reflection roep die versoekte metode aan.

Die aanvaller beheer volledig:

- `soap:address` / `soap12:address` `location` → word `base.Url` (kan `file://` of UNC-paaie stel).
- Metode name, parameterlyste, komplekse tipes en serializers.
- Namespace URIs wat uiteindelik as `xmlns:*` attributte in elke SOAP-boodskap eindig.

Geen skema-validasie vind plaas nie, so elke gegenereerde proxy erf die oorspronklike ontwerp-fout.

### Shaping the SOAP envelope for RCE

- **Complex type serialization**: Definieer custom structs in die WSDL sodat wanneer `XmlSerializer` dit weer uitstuur, hulle aanvaller-gekose elementname/attributte produseer. Vir ASPX webshell drops, skryf tipes wat serialiseer na:
```xml
<script runat="server">
// payload pulling `Request.QueryString["cmd"]`
</script>
```
en wys `Url` na `file:///.../webroot/shell.aspx` om RCE te kry.
- **Namespace injection**: Selfs wanneer argumente hardgekodeer is (bv. Umbraco Forms), word namespaces in die WSDL (bv. `xmlns:tns="http://host/service?x=@{...}"`) woordelik gekopieer in die SOAP-envelope. Kodering van payloads binne die namespace query string maak CSHTML Razor of PowerShell script drops moontlik sonder parameerkontrole.

Hierdie tegnieke dryf die Barracuda Service Center RMM (CVE-2025-34392) exploit: 'n ongeauthentiseerde SOAP-oproep verskaf 'n kwaadwillige WSDL, stel `soap12:address` op `file:///Program Files/.../SCMessaging/poc.aspx`, injekteer `<script runat="server">` via komplekse parameters, en laai 'n webshell op wat arbitraire `cmd.exe` opdragte uitgevoer het.

## Tipiese aanval-werkvloei

1. Identifiseer funksionaliteit wat 'n WSDL URL aanvaar of gebruikers toelaat om SOAP endpoints te konfigureer (bv. Barracuda `InvokeRemoteMethod`, Ivanti EPM connectors, Umbraco 8 Forms datasources, PowerShell `New-WebServiceProxy`).
2. Host 'n kwaadwillige WSDL waarvan `soap:address` na 'n skryfbare pad of UNC-share wys en waarvan die schema definisies payload-vriendelike metodes/tipes voorsien.
3. Trigger die import/kompilering. Die teiken produseer 'n proxy DLL met aanvaller-beheerde konstruktor en metodes.
4. Wanneer die toepassing die gegenereerde metode aanroep, word die SOAP-versoek geserialiseer en na die aanvaller-gespesifiseerde pad geskryf, met die payload ingebed.
5. Voer die ge-dropte lêer uit (blaai na `poc.aspx?cmd=whoami`, laai die CSHTML, of laat PowerShell die script uitvoer) of her-speel vasgelegde NTLM-materiaal.

## Detection & hunting

- **Static analysis**: Grep vir `ServiceDescriptionImporter`, `SoapHttpClientProtocol`, `HttpWebClientProtocol`, of `New-WebServiceProxy`. Volg hoe `Url` of WSDL-insette gebron word—enigiets gebruikers-gekontroleerd is 'n rooi vlag.
- **Runtime telemetry**:
- Instrumenteer proxy-creating om skemas te log; alarm op `file`, `ftp`, of UNC waardes.
- Monitor vir die kenmerkende "Client found response content type of 'application/octet-stream'" foute na SOAP-oproepe.
- Kyk vir onverklaarbare `.aspx/.cshtml/.ps1` skryfbeweginge in toepassingsgidse uitgevoer deur die webdiens-identiteit.
- **Network/file signals**: SMB-verbindinge geïnisieer deur web-bedieners na aanvaller-infrastruktuur, of skielike kompilering van tydelike proxy DLLs, gaan dikwels eksploitasie vooraf.

## Mitigations

- **Enforce transport validation** voordat enige `HttpWebClientProtocol`-afgeleide proxy aangeroep word:
```csharp
var uri = new Uri(proxy.Url);
if (uri.Scheme != Uri.UriSchemeHttp && uri.Scheme != Uri.UriSchemeHttps)
throw new InvalidOperationException("SOAP clients must stay on HTTP/S");
```
- **Sanitize imported WSDL**: Proxy downloads deur 'n broker wat `soap:address` entries wat nie HTTP/S is nie herskryf of verwerp, onbekende bindings verwyder, en namespace payload-betrugs verbied.
- **Disable untrusted WSDL features**: Vervang "upload a WSDL" geriewe met geverifieerde, server-side templates of allowlists.
- **Segregate write locations**: Maak seker app pools kan nie in uitvoerbare gidse skryf nie; gebruik aparte volumes vir data vs. kode sodat lêerskryf-primitiewe nie RCE word nie.
- **Harden NTLM exposure**: Deaktiveer uitgaande SMB waar moontlik; andersens afdwing SMB signing, EPA en ander relay-mitigasies.

## References

- [watchTowr Labs – SOAPwn: Pwning .NET Framework Applications Through HTTP Client Proxies and WSDL](https://labs.watchtowr.com/soapwn-pwning-net-framework-applications-through-http-client-proxies-and-wsdl/)

{{#include ../../banners/hacktricks-training.md}}
