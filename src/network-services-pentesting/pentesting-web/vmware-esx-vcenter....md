# VMware ESX / vCenter Pentesting

{{#include ../../banners/hacktricks-training.md}}


## Enumeration
```bash
nmap -sV --script "http-vmware-path-vuln or vmware-version" -p <PORT> <IP>
msf> use auxiliary/scanner/vmware/esx_fingerprint
msf> use auxiliary/scanner/http/ms15_034_http_sys_memory_dump
```
## Bruteforce
```bash
msf> auxiliary/scanner/vmware/vmware_http_login
```
Si vous trouvez des identifiants valides, vous pouvez utiliser davantage de modules de scan metasploit pour obtenir des informations.

## ESXi Post-Exploitation & Ransomware Operations

### Attack Workflow inside Virtual Estates

* **Develop**: maintenir un agent de gestion léger (e.g., *MrAgent*), un encryptor (e.g., *Mario*) et une infrastructure de leak.
* **Infiltrate**: compromettre la gestion vSphere, énumérer les hosts, voler des données et préparer des payloads.
* **Deploy**: pousser des agents sur chaque host ESXi, les laisser interroger le C2, et récupérer l'encryptor quand on l'ordonne.
* **Extort**: leak des données de preuve de compromission et lancer des ransom chats une fois le chiffrement confirmé.

### Hypervisor Takeover Primitives

Une fois l'exécution de commandes sur une console ESXi/une session SSH obtenue, les attaquants exécutent typiquement les commandes de gestion suivantes pour fingerprint et isoler le host avant le déploiement du ransomware :
```bash
uname -a                                   # hostname / build metadata for tracking
esxcli --formatter=csv network nic list    # adapter + MAC inventory
esxcli --formatter=csv network ip interface ipv4 get
esxcli network firewall set --enabled false
/etc/init.d/vpxa stop                      # cut vCenter off from the host
passwd root                                # rotate credentials under attacker control
```
Le même agent garde généralement une boucle persistante qui interroge une C2 URI codée en dur. Tout statut inaccessible déclenche des tentatives de nouvelle connexion, ce qui signifie que le beacon reste actif jusqu'à ce que les opérateurs envoient des instructions.

### Canal d'instructions de type MrAgent

Des agents de gestion légers exposent un jeu d'instructions concis parsé depuis la file d'attente C2. Cet ensemble suffit à piloter des dizaines d'hyperviseurs compromis sans shells interactifs :

| Instruction | Effet |
| --- | --- |
| `Config` | Écrase le config JSON local qui définit les répertoires cibles, les délais d'exécution ou le throttling, permettant de reconfigurer à chaud sans redéployer les binaires. |
| `Info` | Retourne les infos de build de l'hyperviseur, les IPs et les métadonnées des adaptateurs récupérées avec les probes `uname`/`esxcli`. |
| `Exec` | Lance la phase de ransomware : change les credentials `root`, stoppe `vpxa`, planifie éventuellement un délai de reboot puis télécharge+exécute l'encryptor. |
| `Run` | Implémente un shell distant en écrivant des commandes arbitraires fournies par la C2 dans `./shmv`, en faisant chmod +x puis en l'exécutant. |
| `Remove` | Exécute `rm -rf <path>` pour le nettoyage des outils ou l'effacement destructeur. |
| `Abort` / `Abort_f` | Arrête les encryptions en file d'attente ou tue les threads worker en cours si l'opérateur veut mettre en pause les actions post-reboot. |
| `Quit` | Termine l'agent et `rm -f` son binaire pour une suppression rapide par lui-même. |
| `Welcome` | Abuse `esxcli system welcomemesg set -m="text"` pour afficher des avis de rançon directement dans la bannière de la console. |

En interne, ces agents conservent deux blobs JSON protégés par mutex (config runtime + status/télémetry) afin que les threads concurrents (par ex. beaconing + workers de chiffrement) ne corrompent pas l'état partagé. Les échantillons sont souvent bourrés de code junk pour ralentir l'analyse statique superficielle, mais les routines principales restent intactes.

### Ciblage adapté à la virtualisation et aux sauvegardes

Les encryptors de type Mario ne parcourent que les racines de répertoires fournies par l'opérateur et touchent les artefacts de virtualisation qui affectent la continuité métier :

| Extension | Cible |
| --- | --- |
| `vmdk`, `vmem`, `vmsd`, `vmsn`, `vswp` | Disques VM, instantanés mémoire et fichiers de backing de swap. |
| `ova`, `ovf` | Bundles d'appliances VM portables / métadonnées. |
| `vib` | Bundles d'installation ESXi pouvant bloquer la remédiation / le patching. |
| `vbk`, `vbm` | Sauvegardes Veeam de VM + métadonnées pour saboter les restaurations locales. |

Quirks opérationnels :

* Chaque répertoire visité reçoit un fichier `How To Restore Your Files.txt` avant le chiffrement pour s'assurer que les canaux de rançon sont affichés même sur des hôtes déconnectés.
* Les fichiers déjà traités sont ignorés quand leurs noms contiennent `.emario`, `.marion`, `.lmario`, `.nmario`, `.mmario` ou `.wmario`, empêchant un double chiffrement qui casserait le déchiffreur des attaquants.
* Les payloads chiffrés sont renommés avec un suffixe de style `*.mario` (généralement `.emario`) afin que les opérateurs puissent vérifier la couverture à distance dans les consoles ou les listings de datastores.

### Améliorations de chiffrement en couches

Les builds Mario récents remplacent la routine linéaire à clé unique par un design sparse multi-clés optimisé pour des VMDK de plusieurs centaines de gigaoctets :

* **Schéma de clés** : Génère une clé primaire de 32 octets (stockée autour de `var_1150`) et une clé secondaire indépendante de 8 octets (`var_20`). Les données sont d'abord transformées avec le contexte primaire puis remélangées avec la clé secondaire avant les écritures disque.
* **En-têtes par fichier** : Des buffers de métadonnées (ex. `var_40`) suivent les maps de chunks et les flags pour que le déchiffreur privé des attaquants puisse reconstruire la disposition sparse.
* **Découpage dynamique** : Au lieu d'une boucle constante `0xA00000`, la taille des chunks et les offsets sont recomputés en fonction de la taille du fichier, avec des seuils étendus jusqu'à ~8 GB pour correspondre aux images VM modernes.
* **Couverture parcellaire** : Seules des régions stratégiquement choisies sont touchées, réduisant drastiquement le temps d'exécution tout en corrompant les métadonnées VMFS, les structures NTFS/EXT4 à l'intérieur de la guest ou les index de backup.
* **Instrumentation** : Les builds améliorés loguent les comptes d'octets par chunk et les totaux (chiffrés/sautés/échoués) sur stdout, fournissant de la télémétrie aux affiliés pendant les intrusions en direct sans outillage supplémentaire.

### See also

Linux LPE via VMware Tools service discovery (CWE-426 / CVE-2025-41244) :

{{#ref}}
../../linux-hardening/privilege-escalation/vmware-tools-service-discovery-untrusted-search-path-cve-2025-41244.md
{{#endref}}

## References

- [Unit 42 – From Linear to Complex: An Upgrade in RansomHouse Encryption](https://unit42.paloaltonetworks.com/ransomhouse-encryption-upgrade/)

{{#include ../../banners/hacktricks-training.md}}
