# Posebna HTTP zaglavlja

{{#include ../../banners/hacktricks-training.md}}

## Rečnici i alati

- [https://github.com/danielmiessler/SecLists/tree/master/Miscellaneous/Web/http-request-headers](https://github.com/danielmiessler/SecLists/tree/master/Miscellaneous/Web/http-request-headers)
- [https://github.com/rfc-st/humble](https://github.com/rfc-st/humble)

## Zaglavlja za promenu lokacije

Prepiši **IP izvor**:

- `X-Originating-IP: 127.0.0.1`
- `X-Forwarded-For: 127.0.0.1`
- `X-Forwarded: 127.0.0.1`
- `Forwarded-For: 127.0.0.1`
- `X-Forwarded-Host: 127.0.0.1`
- `X-Remote-IP: 127.0.0.1`
- `X-Remote-Addr: 127.0.0.1`
- `X-ProxyUser-Ip: 127.0.0.1`
- `X-Original-URL: 127.0.0.1`
- `Client-IP: 127.0.0.1`
- `X-Client-IP: 127.0.0.1`
- `X-Host: 127.0.0.1`
- `True-Client-IP: 127.0.0.1`
- `Cluster-Client-IP: 127.0.0.1`
- `Via: 1.0 fred, 1.1 127.0.0.1`
- `Connection: close, X-Forwarded-For` (Proveri hop-by-hop zaglavlja)

Prepiši **lokaciju**:

- `X-Original-URL: /admin/console`
- `X-Rewrite-URL: /admin/console`

## Hop-by-Hop zaglavlja

Hop-by-hop zaglavlje je zaglavlje koje treba da obradi i potroši proxy koji trenutno obrađuje zahtev, za razliku od end-to-end zaglavlja.

- `Connection: close, X-Forwarded-For`


{{#ref}}
../../pentesting-web/abusing-hop-by-hop-headers.md
{{#endref}}

## HTTP Request Smuggling

- `Content-Length: 30`
- `Transfer-Encoding: chunked`


{{#ref}}
../../pentesting-web/http-request-smuggling/
{{#endref}}

## Zaglavlje Expect

Moguće je da klijent pošalje zaglavlje `Expect: 100-continue`, a server odgovori sa `HTTP/1.1 100 Continue` da bi dozvolio klijentu da nastavi sa slanjem tela zahteva. Međutim, neki proxyji ne vole ovo zaglavlje.

Zanimljivi rezultati `Expect: 100-continue`:
- Slanje HEAD zahteva sa telom — server nije uzeo u obzir da HEAD zahtevi obično nemaju telo i drži konekciju otvorenom dok ne istekne timeout.
- Neki serveri su slali čudne podatke: nasumične podatke pročitane sa soketa u odgovoru, tajne ključeve ili čak omogućili da front-end ne ukloni vrednosti zaglavlja.
- Takođe je izazvalo `0.CL` desync kada je backend odgovorio sa 400 umesto sa 100, ali frontend proxy je bio spreman da pošalje telo inicijalnog zahteva, pa ga je poslao, a backend ga je tretirao kao novi zahtev.
- Slanje varijacije poput `Expect: y 100-continue` takođe je izazvalo `0.CL` desync.
- Slična greška gde je backend odgovorio sa 404 je generisala `CL.0` desync jer zlonamerni zahtev navodi `Content-Length`, pa backend šalje zlonamerni zahtev + `Content-Length` bajtova sledećeg zahteva (žrtve). Ovo desinhronizuje red: backend šalje 404 odgovor za zlonamerni zahtev + odgovor žrtvinog zahteva, dok frontend misli da je poslat samo 1 zahtev, pa drugi odgovor pošalje drugom žrtvinom zahtevu i tako dalje...

Za više informacija o HTTP Request Smuggling pogledajte:

{{#ref}}
../../pentesting-web/http-request-smuggling/
{{#endref}}


## Cache zaglavlja

**Server cache zaglavlja**:

- **`X-Cache`** u odgovoru može imati vrednost **`miss`** kada zahtev nije bio keširan i vrednost **`hit`** kada jeste keširan
- Sličan ponašanje ima zaglavlje **`Cf-Cache-Status`**
- **`Cache-Control`** pokazuje da li se resurs kešira i kada će sledeći put resurs isteći: `Cache-Control: public, max-age=1800`
- **`Vary`** se često koristi u odgovoru da **naznači dodatna zaglavlja** koja se tretiraju kao **deo ključa keša** čak i ako se obično ne koriste za keširanje.
- **`Age`** definiše koliko je objekat bio u proxy kešu, u sekundama.
- **`Server-Timing: cdn-cache; desc=HIT`** takođe ukazuje da je resurs bio keširan


{{#ref}}
../../pentesting-web/cache-deception/
{{#endref}}

**Lokalna cache zaglavlja**:

- `Clear-Site-Data`: Zaglavlje koje ukazuje koji keš treba obrisati: `Clear-Site-Data: "cache", "cookies"`
- `Expires`: Sadrži datum/vreme kada odgovor treba isteći: `Expires: Wed, 21 Oct 2015 07:28:00 GMT`
- `Pragma: no-cache` isto kao `Cache-Control: no-cache`
- `Warning`: Generalno HTTP zaglavlje koje sadrži informacije o mogućim problemima sa statusom poruke. Više od jednog `Warning` zaglavlja može se pojaviti u odgovoru. `Warning: 110 anderson/1.3.37 "Response is stale"`

## Uslovni zahtevi

- Zahtevi koji koriste ova zaglavlja: **`If-Modified-Since`** i **`If-Unmodified-Since`** biće odgovoreni podacima samo ako odgovor sadrži drugačije vreme u zaglavlju **`Last-Modified`**.
- Uslovni zahtevi koristeći **`If-Match`** i **`If-None-Match`** koriste vrednost Etag, tako da web server pošalje sadržaj odgovora samo ako se podaci (Etag) promene. `Etag` se uzima iz HTTP odgovora.
- Vrednost **Etag** se obično **izračunava** na osnovu **sadržaja** odgovora. Na primer, `ETag: W/"37-eL2g8DEyqntYlaLp5XLInBWsjWI"` ukazuje da je `Etag` **Sha1** od **37 bajtova**.

## Range zahtevi

- **`Accept-Ranges`**: Ukazuje da li server podržava range zahteve, i u kojoj jedinici se opseg može izraziti. `Accept-Ranges: <range-unit>`
- **`Range`**: Ukazuje koji deo dokumenta server treba da vrati. Na primer, `Range:80-100` će vratiti bajtove 80 do 100 originalnog odgovora sa status kodom 206 Partial Content. Takođe, zapamtite da uklonite `Accept-Encoding` zaglavlje iz zahteva.
- Ovo može biti korisno za dobijanje odgovora sa proizvoljnim reflektovanim javascript kodom koji bi inače bio escapovan. Ali da biste to zloupotrebili, potreban je način da ubacite ova zaglavlja u zahtev.
- **`If-Range`**: Pravi uslovni range zahtev koji se izvršava samo ako zadati etag ili datum odgovara udaljenom resursu. Koristi se da se spreči preuzimanje dva range-a iz neslagajućih verzija resursa.
- **`Content-Range`**: Ukazuje gde u punom telu poruke pripada parcijalna poruka.

## Informacije o telu poruke

- **`Content-Length`:** Veličina resursa, u decimalnom broju bajtova.
- **`Content-Type`**: Ukazuje medija tip resursa
- **`Content-Encoding`**: Koristi se da specificira algoritam kompresije.
- **`Content-Language`**: Opisuje ljudski jezik(e) namenjen publici, kako bi omogućilo korisniku da razlikuje prema svom preferiranom jeziku.
- **`Content-Location`**: Ukazuje alternativnu lokaciju za vraćene podatke.

Sa stanovišta pentesta ove informacije su obično "useless", ali ako je resurs **protected** od 401 ili 403 i možete naći neki **način** da dobijete ove **info**, to može biti **interesantno.**\
Na primer, kombinacija **`Range`** i **`Etag`** u HEAD zahtevu može leak-ovati sadržaj stranice putem HEAD zahteva:

- Zahtev sa zaglavljem `Range: bytes=20-20` i odgovor koji sadrži `ETag: W/"1-eoGvPlkaxxP4HqHv6T3PNhV9g3Y"` otkriva da je SHA1 od bajta 20 `ETag: eoGvPlkaxxP4HqHv6T3PNhV9g3Y`

## Informacije o serveru

- `Server: Apache/2.4.1 (Unix)`
- `X-Powered-By: PHP/5.3.3`

## Kontrole

- **`Allow`**: Ovo zaglavlje se koristi da saopšti HTTP metode koje resurs može da podrži. Na primer, može biti specificirano kao `Allow: GET, POST, HEAD`, što znači da resurs podržava te metode.
- **`Expect`**: Koristi se od strane klijenta da izrazi očekivanja koja server mora da ispuni da bi zahtev bio uspešno obrađen. Uobičajen primer je `Expect: 100-continue`, koji signalizira da klijent namerava da pošalje veliki payload i očekuje `100 (Continue)` pre nego što nastavi sa slanjem. Ovaj mehanizam pomaže u optimizaciji mrežnog saobraćaja čekajući potvrdu servera.

## Preuzimanja

- Zaglavlje **`Content-Disposition`** u HTTP odgovorima određuje da li fajl treba da bude prikazan **inline** (u okviru web stranice) ili tretiran kao **attachment** (preuzet). Na primer:
```
Content-Disposition: attachment; filename="filename.jpg"
```
Ovo znači da je fajl pod imenom "filename.jpg" predviđen za preuzimanje i čuvanje.

## Sigurnosni zaglavlja

### Politika bezbednosti sadržaja (CSP) <a href="#csp" id="csp"></a>


{{#ref}}
../../pentesting-web/content-security-policy-csp-bypass/
{{#endref}}

### **Trusted Types**

Sprovodeći Trusted Types putem CSP-a, aplikacije mogu biti zaštićene od DOM XSS napada. Trusted Types osiguravaju da se u opasnim pozivima web API-ja mogu koristiti samo posebno kreirani objekti, usklađeni sa uspostavljenim bezbednosnim politikama, čime se JavaScript kod podrazumevano štiti.
```javascript
// Feature detection
if (window.trustedTypes && trustedTypes.createPolicy) {
// Name and create a policy
const policy = trustedTypes.createPolicy('escapePolicy', {
createHTML: str => str.replace(/\</g, '&lt;').replace(/>/g, '&gt;');
});
}
```

```javascript
// Assignment of raw strings is blocked, ensuring safety.
el.innerHTML = "some string" // Throws an exception.
const escaped = policy.createHTML("<img src=x onerror=alert(1)>")
el.innerHTML = escaped // Results in safe assignment.
```
### **X-Content-Type-Options**

Ovaj header sprečava MIME type sniffing — praksu koja može dovesti do XSS ranjivosti. Time se osigurava da pregledači poštuju MIME tipove koje server navede.
```
X-Content-Type-Options: nosniff
```
### **X-Frame-Options**

Da bi se suzbio clickjacking, ovo zaglavlje ograničava kako se dokumenti mogu ugrađivati u `<frame>`, `<iframe>`, `<embed>` ili `<object>` tagove, preporučujući da svi dokumenti eksplicitno navedu svoje dozvole za ugradnju.
```
X-Frame-Options: DENY
```
### **Cross-Origin Resource Policy (CORP) i Cross-Origin Resource Sharing (CORS)**

CORP je ključan za navođenje koje resurse sajtovi mogu da učitaju, smanjujući cross-site leaks. CORS, s druge strane, omogućava fleksibilniji mehanizam za cross-origin deljenje resursa, opuštajući same-origin policy pod određenim uslovima.
```
Cross-Origin-Resource-Policy: same-origin
Access-Control-Allow-Origin: https://example.com
Access-Control-Allow-Credentials: true
```
### **Cross-Origin Embedder Policy (COEP) i Cross-Origin Opener Policy (COOP)**

COEP i COOP su ključne za omogućavanje cross-origin izolacije, što značajno smanjuje rizik od napada sličnih Spectre-u. One kontrolišu učitavanje cross-origin resursa, odnosno interakciju sa cross-origin prozorima.
```
Cross-Origin-Embedder-Policy: require-corp
Cross-Origin-Opener-Policy: same-origin-allow-popups
```
### **HTTP Strict Transport Security (HSTS)**

Na kraju, HSTS je sigurnosna funkcija koja primorava pregledače da komuniciraju sa serverima samo preko sigurnih HTTPS veza, čime se poboljšava privatnost i bezbednost.
```
Strict-Transport-Security: max-age=3153600
```
## Header Name Casing Bypass

HTTP/1.1 definiše imena polja zaglavlja kao **neosetljiva na veličinu slova** (RFC 9110 §5.1). Ipak, veoma je često naći custom middleware, security filters, ili business logic koji porede *literal* ime zaglavlja koje su dobili bez prethodnog normalizovanja zapisa velikih/malih slova (npr. `header.equals("CamelExecCommandExecutable")`). Ako se te provere izvode **case-sensitively**, napadač ih može zaobići jednostavnim slanjem istog zaglavlja sa drugačijom kapitalizacijom.

Tipične situacije u kojima se ova greška pojavljuje:

* Custom allow/deny lists koje pokušavaju da blokiraju “dangerous” internal headers pre nego što zahtev stigne do osetljive komponente.
* Interna implementacija reverse-proxy pseudo-headers (npr. `X-Forwarded-For` sanitisation).
* Frameworks koji izlažu management / debug endpoints i oslanjaju se na imena zaglavlja za autentifikaciju ili izbor komande.

### Abusing the bypass

1. Identifikujte zaglavlje koje se filtrira ili validira na server-side (na primer, čitanjem source code-a, dokumentacije, ili error poruka).
2. Pošaljite **isto zaglavlje sa drugačijom veličinom slova** (mešoviti zapis ili samo velika slova). Pošto HTTP stack-ovi obično canonicalizuju zaglavlja tek *nakon* što korisnički kod izvrši, ranjiva provera može biti zaobiđena.
3. Ako downstream komponenta tretira zaglavlja na način neosetljiv na veličinu slova (većina tako radi), prihvatiće vrednost koju kontroliše napadač.

### Example: Apache Camel `exec` RCE (CVE-2025-27636)

U ranjivim verzijama Apache Camel, *Command Center* rute pokušavaju da blokiraju nepouzdane zahteve tako što uklanjaju zaglavlja `CamelExecCommandExecutable` i `CamelExecCommandArgs`. Poređenje je rađeno pomoću `equals()` pa su uklanjana samo imena koja su se tačno poklapala (sa istom veličinom slova).
```bash
# Bypass the filter by using mixed-case header names and execute `ls /` on the host
curl "http://<IP>/command-center" \
-H "CAmelExecCommandExecutable: ls" \
-H "CAmelExecCommandArgs: /"
```
Zaglavlja stižu do `exec` komponente nefiltrirano, što dovodi do izvršavanja udaljenih komandi sa privilegijama Camel procesa.

### Otkrivanje i ublažavanje

* Normalizujte sva imena zaglavlja na jedan oblik (obično lowercase) **pre nego što** izvršite allow/deny poređenja.
* Odbacite sumnjive duplikate: ako su prisutni i `Header:` i `HeAdEr:`, tretirajte to kao anomaliju.
* Koristite pozitivnu allow-listu koja se primenjuje **nakon** kanonizacije.
* Zaštitite management endpoint-e autentikacijom i mrežnom segmentacijom.


## References

- [CVE-2025-27636 – RCE in Apache Camel via header casing bypass (OffSec blog)](https://www.offsec.com/blog/cve-2025-27636/)
- [https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition)
- [https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers)
- [https://web.dev/security-headers/](https://web.dev/security-headers/)
- [https://web.dev/articles/security-headers](https://web.dev/articles/security-headers)

{{#include ../../banners/hacktricks-training.md}}
