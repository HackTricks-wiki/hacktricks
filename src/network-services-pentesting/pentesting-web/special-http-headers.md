# Özel HTTP başlıkları

{{#include ../../banners/hacktricks-training.md}}

## Wordlists & Tools

- [https://github.com/danielmiessler/SecLists/tree/master/Miscellaneous/Web/http-request-headers](https://github.com/danielmiessler/SecLists/tree/master/Miscellaneous/Web/http-request-headers)
- [https://github.com/rfc-st/humble](https://github.com/rfc-st/humble)

## Konumu Değiştirmek İçin Başlıklar

IP kaynağını yeniden yaz:

- `X-Originating-IP: 127.0.0.1`
- `X-Forwarded-For: 127.0.0.1`
- `X-Forwarded: 127.0.0.1`
- `Forwarded-For: 127.0.0.1`
- `X-Forwarded-Host: 127.0.0.1`
- `X-Remote-IP: 127.0.0.1`
- `X-Remote-Addr: 127.0.0.1`
- `X-ProxyUser-Ip: 127.0.0.1`
- `X-Original-URL: 127.0.0.1`
- `Client-IP: 127.0.0.1`
- `X-Client-IP: 127.0.0.1`
- `X-Host: 127.0.0.1`
- `True-Client-IP: 127.0.0.1`
- `Cluster-Client-IP: 127.0.0.1`
- `Via: 1.0 fred, 1.1 127.0.0.1`
- `Connection: close, X-Forwarded-For` (Hop-by-hop header'ları kontrol edin)

Konumu yeniden yaz:

- `X-Original-URL: /admin/console`
- `X-Rewrite-URL: /admin/console`

## Hop-by-Hop başlıkları

Bir hop-by-hop header, isteği şu anda işleyen proxy tarafından işlenip tüketilmek üzere tasarlanmış bir başlıktır; end-to-end header'dan farklı olarak yalnızca ara düğümün işlemine yöneliktir.

- `Connection: close, X-Forwarded-For`


{{#ref}}
../../pentesting-web/abusing-hop-by-hop-headers.md
{{#endref}}

## HTTP Request Smuggling

- `Content-Length: 30`
- `Transfer-Encoding: chunked`


{{#ref}}
../../pentesting-web/http-request-smuggling/
{{#endref}}

## Expect başlığı

İstemcinin `Expect: 100-continue` başlığını gönderip ardından sunucunun `HTTP/1.1 100 Continue` ile yanıt vererek istemcinin isteğin gövdesini göndermeye devam etmesine izin vermesi mümkündür. Ancak bazı proxy'ler bu başlığı pek sevmez.

`Expect: 100-continue`'ün ilginç sonuçları:
- Bir HEAD isteğine gövde gönderildiğinde, sunucu HEAD isteklerinin gövde içermediğini hesaba katmayıp bağlantıyı zaman aşımına uğrayana kadar açık tutabiliyor.
- Diğer sunucular garip veriler gönderdi: yanıtta soketten rastgele okunan veriler, gizli anahtarlar veya hatta ön uçun başlık değerlerini kaldırmasını engelleyen durumlar görüldü.
- Ayrıca backend 100 yerine 400 ile yanıtladığında `0.CL` desync'e yol açtı; çünkü proxy ön uç ilk isteğin gövdesini göndermeye hazırlanmıştı, bu yüzden gövdeyi gönderdi ve backend bunu yeni bir istek olarak aldı.
- `Expect: y 100-continue` benzeri varyasyonlar da `0.CL` desync'e sebep oldu.
- Backend 404 ile yanıtladığında oluşan benzer bir hata `CL.0` desync üretti; kötü niyetli istek bir `Content-Length` belirttiği için backend kötü niyetli isteği + sonraki isteğin (bir victim'ın) `Content-Length` baytlarını gönderiyor. Bu, kuyruğun desync olmasına neden oluyor: backend kötü niyetli istek için 404 yanıtını + victim isteklerinin yanıtlarını gönderirken, ön uç sadece 1 istek gönderildiğini sanıyor; böylece ikinci yanıt farklı bir victim isteğine gidiyor ve onun yanıtı bir sonrakiye aktarılıyor...

HTTP Request Smuggling hakkında daha fazla bilgi için bakınız:

{{#ref}}
../../pentesting-web/http-request-smuggling/
{{#endref}}


## Önbellek Başlıkları

**Sunucu Önbellek Başlıkları**:

- **`X-Cache`** yanıtında, istek önbelleğe alınmadıysa değer **`miss`**, önbelleğe alındıysa **`hit`** olabilir
- Benzer davranış **`Cf-Cache-Status`** başlığında görülebilir
- **`Cache-Control`** bir kaynağın önbelleğe alınıp alınmadığını ve bir sonraki ne zaman önbelleğe alınacağını gösterir: `Cache-Control: public, max-age=1800`
- **`Vary`** genellikle yanıtta, normalde önbellek anahtarında olmayan ek başlıkların önbellek anahtarının parçası olarak ele alındığını belirtmek için kullanılır
- **`Age`** nesnenin proxy önbelleğinde bulunduğu süreyi saniye cinsinden tanımlar
- **`Server-Timing: cdn-cache; desc=HIT`** ayrıca bir kaynağın cachelendiğini gösterir


{{#ref}}
../../pentesting-web/cache-deception/
{{#endref}}

**Yerel Önbellek başlıkları**:

- `Clear-Site-Data`: Hangi önbelleğin kaldırılması gerektiğini belirtir: `Clear-Site-Data: "cache", "cookies"`
- `Expires`: Yanıtın ne zaman sona ermesi gerektiğini içeren tarih/saat: `Expires: Wed, 21 Oct 2015 07:28:00 GMT`
- `Pragma: no-cache` `Cache-Control: no-cache` ile aynı
- `Warning`: Genel HTTP başlığı olan **`Warning`**, mesajın durumu ile ilgili olası sorunlar hakkında bilgi içerir. Bir yanıtta birden fazla `Warning` başlığı görünebilir. `Warning: 110 anderson/1.3.37 "Response is stale"`

## Koşullu İstekler

- **`If-Modified-Since`** ve **`If-Unmodified-Since`** başlıklarını kullanan isteklere, yalnızca yanıt başlığı **`Last-Modified`** farklı bir zamanı içeriyorsa veri ile yanıt verilir.
- **`If-Match`** ve **`If-None-Match`** kullanan koşullu istekler bir Etag değeri kullanır; sunucu verinin (Etag) değişmesi durumunda yanıt içeriğini gönderir. `Etag` HTTP yanıtından alınır.
- **Etag** değeri genellikle yanıtın **içeriğine** göre hesaplanır. Örneğin, `ETag: W/"37-eL2g8DEyqntYlaLp5XLInBWsjWI"` ifadesi, `Etag`'in **37 baytın Sha1**'i olduğunu gösterir.

## Range istekleri

- **`Accept-Ranges`**: Sunucunun range isteklerini destekleyip desteklemediğini ve destekliyorsa hangi birimde range belirtilebileceğini gösterir. `Accept-Ranges: <range-unit>`
- **`Range`**: Sunucunun döndürmesi gereken belgenin kısmını belirtir. Örneğin, `Range:80-100` orijinal yanıtın 80 ile 100 baytları arasını 206 Partial Content statü kodu ile döndürecektir. Ayrıca istekte `Accept-Encoding` başlığını kaldırmayı unutmayın.
- Bu, aksi takdirde kaçışlanan reflected javascript kodunu almak için faydalı olabilir. Ancak bunu kötüye kullanmak için bu başlıkları isteğe enjekte etmeniz gerekir.
- **`If-Range`**: Verilen etag veya tarih uzaktaki kaynakla eşleşiyorsa yerine getirilecek koşullu bir range isteği oluşturur. Kaynağın uyumsuz sürümlerinden iki range indirmeyi önlemek için kullanılır.
- **`Content-Range`**: Kısmi bir mesajın tam bir gövde mesajı içindeki yerini belirtir.

## Mesaj gövdesi bilgisi

- **`Content-Length`:** Kaynağın boyutu, ondalık bayt sayısı olarak.
- **`Content-Type`**: Kaynağın medya tipini belirtir
- **`Content-Encoding`**: Sıkıştırma algoritmasını belirtmek için kullanılır.
- **`Content-Language`**: Hedef kitle için amaçlanan insan dil(ler)ini tanımlar; böylece kullanıcıların tercih ettiği dile göre ayrım yapmasına olanak verir.
- **`Content-Location`**: Döndürülen veri için alternatif bir konumu gösterir.

Pentest açısından bu bilgiler genellikle "kullanışsız"dır, ancak kaynak 401 veya 403 ile **korunuyorsa** ve bu bilgiyi **almanın** bir yolunu bulabiliyorsanız, bu ilginç olabilir.\
Örneğin HEAD isteğinde **`Range`** ve **`Etag`** kombinasyonu sayfanın içeriğini HEAD istekleri aracılığıyla leak edebilir:

- `Range: bytes=20-20` başlığı ile yapılan bir istek ve `ETag: W/"1-eoGvPlkaxxP4HqHv6T3PNhV9g3Y"` içeren bir yanıt, 20. baytın SHA1'inin `ETag: eoGvPlkaxxP4HqHv6T3PNhV9g3Y` olduğunu leaking ediyor

## Sunucu Bilgisi

- `Server: Apache/2.4.1 (Unix)`
- `X-Powered-By: PHP/5.3.3`

## Kontroller

- **`Allow`**: Bu başlık bir kaynağın hangi HTTP metodlarını işleyebileceğini iletmek için kullanılır. Örneğin `Allow: GET, POST, HEAD` şeklinde belirtilerek kaynağın bu metodları desteklediği gösterilebilir.
- **`Expect`**: İstemcinin, isteğin başarılı işlenmesi için sunucunun karşılaması gereken beklentileri iletmek için kullandığı başlıktır. Yaygın kullanım örneği `Expect: 100-continue` başlığıdır; bu, istemcinin büyük bir veri yükü göndermeyi planladığını sinyaller. İstemci, devam etmeden önce `100 (Continue)` yanıtını bekler. Bu mekanizma, sunucudan onay gelene kadar veri göndermeyi erteleyerek ağ kullanımını optimize etmeye yardımcı olur.

## İndirmeler

- HTTP yanıtlarındaki **`Content-Disposition`** başlığı, bir dosyanın **inline** (sayfa içinde gösterilmesi) mı yoksa **attachment** (indirilen) olarak mı muamele edileceğini yönlendirir. Örneğin:
```
Content-Disposition: attachment; filename="filename.jpg"
```
Bu, "filename.jpg" adlı dosyanın indirilip kaydedilmesinin amaçlandığı anlamına gelir.

## Güvenlik Başlıkları

### İçerik Güvenlik Politikası (CSP) <a href="#csp" id="csp"></a>


{{#ref}}
../../pentesting-web/content-security-policy-csp-bypass/
{{#endref}}

### **Trusted Types**

CSP aracılığıyla Trusted Types uygulanarak, uygulamalar DOM XSS saldırılarına karşı korunabilir. Trusted Types, yalnızca belirlenmiş güvenlik politikalarına uygun, özel olarak oluşturulmuş nesnelerin tehlikeli web API çağrılarında kullanılmasına izin vererek JavaScript kodunu varsayılan olarak güvence altına alır.
```javascript
// Feature detection
if (window.trustedTypes && trustedTypes.createPolicy) {
// Name and create a policy
const policy = trustedTypes.createPolicy('escapePolicy', {
createHTML: str => str.replace(/\</g, '&lt;').replace(/>/g, '&gt;');
});
}
```

```javascript
// Assignment of raw strings is blocked, ensuring safety.
el.innerHTML = "some string" // Throws an exception.
const escaped = policy.createHTML("<img src=x onerror=alert(1)>")
el.innerHTML = escaped // Results in safe assignment.
```
### **X-Content-Type-Options**

Bu header, MIME türlerini tahmin etme (MIME type sniffing) uygulamasını engeller; bu uygulama XSS zafiyetlerine yol açabilir. Tarayıcıların sunucu tarafından belirtilen MIME türlerine uymasını sağlar.
```
X-Content-Type-Options: nosniff
```
### **X-Frame-Options**

Clickjacking ile mücadele etmek için, bu header belgelerin `<frame>`, `<iframe>`, `<embed>` veya `<object>` etiketlerine nasıl gömülebileceğini kısıtlar ve tüm belgelerin gömme izinlerini açıkça belirtmesini önerir.
```
X-Frame-Options: DENY
```
### **Cross-Origin Resource Policy (CORP) ve Cross-Origin Resource Sharing (CORS)**

CORP, hangi kaynakların web siteleri tarafından yüklenebileceğini belirtmek için kritik öneme sahiptir; cross-site leaks'i azaltır. CORS ise daha esnek bir cross-origin resource sharing mekanizmasına izin verir ve belirli koşullar altında same-origin policy'yi gevşetir.
```
Cross-Origin-Resource-Policy: same-origin
Access-Control-Allow-Origin: https://example.com
Access-Control-Allow-Credentials: true
```
### **Cross-Origin Embedder Policy (COEP) ve Cross-Origin Opener Policy (COOP)**

COEP ve COOP, çapraz-kaynak izolasyonunu etkinleştirmek için gereklidir ve Spectre benzeri saldırı riskini önemli ölçüde azaltır. Bunlar sırasıyla çapraz-kaynaklı kaynakların yüklenmesini ve çapraz-kaynaklı pencerelerle etkileşimi kontrol eder.
```
Cross-Origin-Embedder-Policy: require-corp
Cross-Origin-Opener-Policy: same-origin-allow-popups
```
### **HTTP Strict Transport Security (HSTS)**

Son olarak, HSTS, tarayıcıların sunucularla yalnızca güvenli HTTPS bağlantıları üzerinden iletişim kurmasını zorunlu kılan bir güvenlik özelliğidir; bu da gizliliği ve güvenliği artırır.
```
Strict-Transport-Security: max-age=3153600
```
## Header Name Casing Bypass

HTTP/1.1, başlık alan adlarının **büyük/küçük harfe duyarsız** olduğunu belirtir (RFC 9110 §5.1). Buna rağmen, gelen başlık adını önce büyük/küçük harf normalleştirmesi yapmadan *literal* olarak karşılaştıran custom middleware, security filters veya business logic parçalarına sıkça rastlanır (ör. `header.equals("CamelExecCommandExecutable")`). Bu kontroller **büyük/küçük harfe duyarlı** yapılırsa, bir saldırgan aynı başlığı farklı bir yazımla göndererek kontrolleri atlayabilir.

Typical situations where this mistake appears:

* Hassas bir bileşene ulaşmadan önce “tehlikeli” iç başlıkları engellemeye çalışan özel allow/deny listeleri.
* Reverse-proxy pseudo-headers'ın şirket içi implementasyonları (ör. `X-Forwarded-For` sanitisation).
* Yönetim / debug endpoint'larını açan ve kimlik doğrulama veya komut seçimi için başlık isimlerine dayanan frameworkler.

### Abusing the bypass

1. Sunucu tarafında filtrelenen veya doğrulanan bir başlığı tespit edin (örneğin kaynak kodunu, dokümantasyonu veya hata mesajlarını okuyarak).
2. Aynı başlığı **farklı bir yazımla** gönderin (karışık harf kullanımı veya tamamı büyük harf). HTTP yığınları genellikle başlıkları kullanıcı kodu çalıştıktan *sonra* canonicalise ettiğinden, zafiyete sahip kontrol atlanabilir.
3. Eğer downstream bileşen başlıkları büyük/küçük harfe duyarsız şekilde işliyorsa (çoğu öyledir), saldırgan kontrollü değeri kabul edecektir.

### Example: Apache Camel `exec` RCE (CVE-2025-27636)

Zafiyetli Apache Camel sürümlerinde *Command Center* route'ları, güvensiz istekleri engellemek için `CamelExecCommandExecutable` ve `CamelExecCommandArgs` başlıklarını kaldırmaya çalışır. Karşılaştırma `equals()` ile yapıldığı için sadece tam olarak aynı yazıma sahip başlıklar kaldırılıyordu.
```bash
# Bypass the filter by using mixed-case header names and execute `ls /` on the host
curl "http://<IP>/command-center" \
-H "CAmelExecCommandExecutable: ls" \
-H "CAmelExecCommandArgs: /"
```
Başlıklar `exec` bileşenine filtrelenmeden ulaşır ve bu, Camel işleminin yetkileriyle remote command execution'a yol açar.

### Tespit ve Hafifletme

* Tüm başlık isimlerini tek bir duruma (genellikle küçük harf) normalleştirin **önce** izin/engelleme karşılaştırmaları yapmadan.
* Şüpheli yinelenenleri reddedin: hem `Header:` hem `HeAdEr:` varsa, bunu bir anomali olarak değerlendirin.
* Pozitif bir izin-listesi kullanın ve bu liste kanonikleştirmeden **sonra** uygulanmalıdır.
* Yönetim endpointlerini kimlik doğrulama ve ağ segmentasyonu ile koruyun.


## Kaynaklar

- [CVE-2025-27636 – RCE in Apache Camel via header casing bypass (OffSec blog)](https://www.offsec.com/blog/cve-2025-27636/)
- [https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition)
- [https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers)
- [https://web.dev/security-headers/](https://web.dev/security-headers/)
- [https://web.dev/articles/security-headers](https://web.dev/articles/security-headers)

{{#include ../../banners/hacktricks-training.md}}
