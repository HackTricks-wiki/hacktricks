# Ειδικές HTTP κεφαλίδες

{{#include ../../banners/hacktricks-training.md}}

## Λίστες λέξεων & Εργαλεία

- [https://github.com/danielmiessler/SecLists/tree/master/Miscellaneous/Web/http-request-headers](https://github.com/danielmiessler/SecLists/tree/master/Miscellaneous/Web/http-request-headers)
- [https://github.com/rfc-st/humble](https://github.com/rfc-st/humble)

## Κεφαλίδες για αλλαγή τοποθεσίας

Επανεγγραφή πηγής IP:

- `X-Originating-IP: 127.0.0.1`
- `X-Forwarded-For: 127.0.0.1`
- `X-Forwarded: 127.0.0.1`
- `Forwarded-For: 127.0.0.1`
- `X-Forwarded-Host: 127.0.0.1`
- `X-Remote-IP: 127.0.0.1`
- `X-Remote-Addr: 127.0.0.1`
- `X-ProxyUser-Ip: 127.0.0.1`
- `X-Original-URL: 127.0.0.1`
- `Client-IP: 127.0.0.1`
- `X-Client-IP: 127.0.0.1`
- `X-Host: 127.0.0.1`
- `True-Client-IP: 127.0.0.1`
- `Cluster-Client-IP: 127.0.0.1`
- `Via: 1.0 fred, 1.1 127.0.0.1`
- `Connection: close, X-Forwarded-For` (Έλεγχος hop-by-hop headers)

Επανεγγραφή τοποθεσίας:

- `X-Original-URL: /admin/console`
- `X-Rewrite-URL: /admin/console`

## Hop-by-Hop headers

Μια hop-by-hop κεφαλίδα είναι μια κεφαλίδα που προορίζεται να επεξεργαστεί και να καταναλωθεί από τον proxy που χειρίζεται επί του παρόντος το αίτημα, σε αντίθεση με μια end-to-end κεφαλίδα.

- `Connection: close, X-Forwarded-For`


{{#ref}}
../../pentesting-web/abusing-hop-by-hop-headers.md
{{#endref}}

## HTTP Request Smuggling

- `Content-Length: 30`
- `Transfer-Encoding: chunked`


{{#ref}}
../../pentesting-web/http-request-smuggling/
{{#endref}}

## Η κεφαλίδα Expect

Είναι δυνατόν ο client να στείλει την κεφαλίδα `Expect: 100-continue` και τότε ο server να απαντήσει με `HTTP/1.1 100 Continue` για να επιτρέψει στον client να συνεχίσει και να στείλει το σώμα του request. Ωστόσο, κάποιοι proxies δεν συμπαθούν αυτή την κεφαλίδα.

Ενδιαφέροντα αποτελέσματα του `Expect: 100-continue`:
- Η αποστολή ενός HEAD request με σώμα οδήγησε στο ότι ο server δεν έλαβε υπόψη πως τα HEAD requests δεν έχουν σώμα και κράτησε τη σύνδεση ανοιχτή μέχρι το timeout.
- Άλλοι servers επέστρεψαν παράξενα δεδομένα: τυχαία bytes διαβασμένα από την socket στην απάντηση, μυστικά κλειδιά ή ακόμα επέτρεψαν να εμποδιστεί η front-end από το να αφαιρέσει τιμές κεφαλίδων.
- Προκάλεσε επίσης ένα `0.CL` desync όταν το backend απάντησε με 400 αντί για 100, αλλά το proxy front-end ήταν έτοιμο να στείλει το σώμα του αρχικού request, οπότε το έστειλε και το backend το θεώρησε νέο request.
- Μια παραλλαγή `Expect: y 100-continue` επίσης προκάλεσε το `0.CL` desync.
- Ένα παρόμοιο σφάλμα όπου το backend απάντησε με 404 δημιούργησε `CL.0` desync επειδή το κακόβουλο request δήλωνε `Content-Length`, οπότε το backend έστειλε το κακόβουλο request + τα `Content-Length` bytes του επόμενου request (ενός θύματος). Αυτό αποσυντόνισε την ουρά επειδή το backend έστειλε την 404 απάντηση για το κακόβουλο request + την απάντηση του victim request, αλλά το front-end νόμιζε ότι είχε σταλεί μόνο 1 request, οπότε η δεύτερη απάντηση στάλθηκε σε δεύτερο victim και η απάντηση αυτού στάλθηκε στο επόμενο...

Για περισσότερες πληροφορίες για HTTP Request Smuggling δείτε:

{{#ref}}
../../pentesting-web/http-request-smuggling/
{{#endref}}


## Κεφαλίδες Cache

**Κεφαλίδες cache του Server**:

- **`X-Cache`** στην απάντηση μπορεί να έχει την τιμή **`miss`** όταν το request δεν ήταν cached και την τιμή **`hit`** όταν είναι cached
- Παρόμοια συμπεριφορά στην κεφαλίδα **`Cf-Cache-Status`**
- **`Cache-Control`** υποδεικνύει αν ένα resource γίνεται cache και πότε θα γίνει πάλι cached: `Cache-Control: public, max-age=1800`
- **`Vary`** χρησιμοποιείται συχνά στην απάντηση για να **υποδείξει επιπλέον κεφαλίδες** που θεωρούνται **μέρος του cache key** ακόμα κι αν κανονικά δεν είναι key.
- **`Age`** ορίζει το χρόνο σε δευτερόλεπτα που το αντικείμενο βρίσκεται στην proxy cache.
- **`Server-Timing: cdn-cache; desc=HIT`** επίσης υποδεικνύει ότι ένα resource ήταν cached


{{#ref}}
../../pentesting-web/cache-deception/
{{#endref}}

**Τοπικές κεφαλίδες cache**:

- `Clear-Site-Data`: Κεφαλίδα για να υποδείξει την cache που πρέπει να αφαιρεθεί: `Clear-Site-Data: "cache", "cookies"`
- `Expires`: Περιέχει ημερομηνία/ώρα πότε η απάντηση πρέπει να λήξει: `Expires: Wed, 21 Oct 2015 07:28:00 GMT`
- `Pragma: no-cache` ίδιο με `Cache-Control: no-cache`
- `Warning`: Η γενική HTTP κεφαλίδα **`Warning`** περιέχει πληροφορίες σχετικά με πιθανά προβλήματα με την κατάσταση του μηνύματος. Περισσότερες από μία κεφαλίδα `Warning` μπορεί να εμφανιστούν σε μια απάντηση. `Warning: 110 anderson/1.3.37 "Response is stale"`

## Συνθήκες

- Τα requests που χρησιμοποιούν αυτές τις κεφαλίδες: **`If-Modified-Since`** και **`If-Unmodified-Since`** θα απαντηθούν με περιεχόμενο μόνο αν η κεφαλίδα απάντησης **`Last-Modified`** περιέχει διαφορετική ώρα.
- Τα υπό όρους requests που χρησιμοποιούν **`If-Match`** και **`If-None-Match`** χρησιμοποιούν μια τιμή Etag ώστε ο web server να στείλει το περιεχόμενο της απάντησης αν τα δεδομένα (Etag) έχουν αλλάξει. Το `Etag` λαμβάνεται από την HTTP απάντηση.
- Η τιμή **Etag** συνήθως **υπολογίζεται βάσει** του **περιεχομένου** της απάντησης. Για παράδειγμα, `ETag: W/"37-eL2g8DEyqntYlaLp5XLInBWsjWI"` υποδεικνύει ότι το `Etag` είναι το **Sha1** των **37 bytes**.

## Αιτήματα Range

- **`Accept-Ranges`**: Υποδεικνύει αν ο server υποστηρίζει range requests, και αν ναι σε ποια μονάδα μπορεί να εκφραστεί το range. `Accept-Ranges: <range-unit>`
- **`Range`**: Υποδεικνύει το τμήμα ενός εγγράφου που ο server πρέπει να επιστρέψει. Για παράδειγμα, `Range:80-100` θα επιστρέψει τα bytes 80 έως 100 της αρχικής απάντησης με status code 206 Partial Content. Θυμηθείτε επίσης να αφαιρέσετε την κεφαλίδα `Accept-Encoding` από το request.
- Αυτό μπορεί να είναι χρήσιμο για να πάρετε μια απάντηση με αυθαίρετο reflected javascript κώδικα που αλλιώς θα μπορούσε να αποφεύγεται. Αλλά για να το εκμεταλλευτείτε, θα χρειαστεί να εισάγετε αυτές τις κεφαλίδες στο request.
- **`If-Range`**: Δημιουργεί ένα υπό όρους range request που ικανοποιείται μόνο αν το δοθέν etag ή ημερομηνία ταιριάζει με το απομακρυσμένο resource. Χρησιμοποιείται για να αποτρέψει το κατέβασμα δύο ranges από ασύμβατες εκδόσεις του resource.
- **`Content-Range`**: Υποδεικνύει πού σε ένα πλήρες σώμα ανήκει ένα μερικό μήνυμα.

## Πληροφορίες σώματος μηνύματος

- **`Content-Length`:** Το μέγεθος του resource, σε δεκαδικό αριθμό bytes.
- **`Content-Type`**: Υποδεικνύει τον τύπο μέσου (media type) του resource
- **`Content-Encoding`**: Χρησιμοποιείται για να καθορίσει τον αλγόριθμο συμπίεσης.
- **`Content-Language`**: Περιγράφει τη γλώσσα(-ες) στόχο για το κοινό, ώστε να επιτρέπει σε έναν χρήστη να διαφοροποιήσει ανάλογα με τις προτιμήσεις γλώσσας του.
- **`Content-Location`**: Υποδεικνύει μια εναλλακτική τοποθεσία για τα επιστρεφόμενα δεδομένα.

Από την πλευρά ενός pentest αυτό το είδος πληροφοριών συνήθως είναι "άχρηστο", αλλά αν το resource είναι **protected** με 401 ή 403 και μπορείτε να βρείτε κάποιο **τρόπο** να **πάρετε** αυτή την **info**, αυτό θα μπορούσε να είναι **ενδιαφέρον.**\
Για παράδειγμα ένας συνδυασμός **`Range`** και **`Etag`** σε ένα HEAD request μπορεί να cause το περιεχόμενο της σελίδας να *leak* μέσω HEAD requests:

- Ένα request με την κεφαλίδα `Range: bytes=20-20` και με μια απάντηση που περιέχει `ETag: W/"1-eoGvPlkaxxP4HqHv6T3PNhV9g3Y"` δείχνει ότι το SHA1 του byte 20 είναι `ETag: eoGvPlkaxxP4HqHv6T3PNhV9g3Y` (is leaking)

## Πληροφορίες Server

- `Server: Apache/2.4.1 (Unix)`
- `X-Powered-By: PHP/5.3.3`

## Έλεγχοι

- **`Allow`**: Αυτή η κεφαλίδα χρησιμοποιείται για να επικοινωνήσει ποιες HTTP μεθόδους μπορεί να χειριστεί ένας πόρος. Για παράδειγμα, μπορεί να δηλωθεί ως `Allow: GET, POST, HEAD`, υποδεικνύοντας ότι ο πόρος υποστηρίζει αυτές τις μεθόδους.
- **`Expect`**: Χρησιμοποιείται από τον client για να μεταφέρει προσδοκίες που ο server πρέπει να ικανοποιήσει για να επεξεργαστεί με επιτυχία το request. Μια συνηθισμένη χρήση είναι η κεφαλίδα `Expect: 100-continue`, η οποία σηματοδοτεί ότι ο client σκοπεύει να στείλει μεγάλο payload δεδομένων. Ο client αναμένει μια απάντηση `100 (Continue)` πριν προχωρήσει στην αποστολή. Αυτό το μηχανισμό βοηθά στην βελτιστοποίηση της χρήσης του δικτύου, περιμένοντας την επιβεβαίωση του server.

## Λήψεις

- Η κεφαλίδα **`Content-Disposition`** στις HTTP απαντήσεις καθοδηγεί αν ένα αρχείο θα εμφανιστεί **inline** (μέσα στη σελίδα) ή θα αντιμετωπιστεί ως **attachment** (θα γίνει download). Για παράδειγμα:
```
Content-Disposition: attachment; filename="filename.jpg"
```
Αυτό σημαίνει ότι το αρχείο με όνομα "filename.jpg" προορίζεται να μεταφορτωθεί και να αποθηκευτεί.

## Επικεφαλίδες Ασφαλείας

### Πολιτική Ασφάλειας Περιεχομένου (CSP) <a href="#csp" id="csp"></a>


{{#ref}}
../../pentesting-web/content-security-policy-csp-bypass/
{{#endref}}

### **Trusted Types**

Με την επιβολή των Trusted Types μέσω του CSP, οι εφαρμογές μπορούν να προστατευθούν από επιθέσεις DOM XSS. Οι Trusted Types διασφαλίζουν ότι μόνο ειδικά κατασκευασμένα αντικείμενα, συμβατά με καθιερωμένες πολιτικές ασφαλείας, μπορούν να χρησιμοποιηθούν σε επικίνδυνες κλήσεις web API, εξασφαλίζοντας έτσι τον κώδικα JavaScript εξ ορισμού.
```javascript
// Feature detection
if (window.trustedTypes && trustedTypes.createPolicy) {
// Name and create a policy
const policy = trustedTypes.createPolicy('escapePolicy', {
createHTML: str => str.replace(/\</g, '&lt;').replace(/>/g, '&gt;');
});
}
```

```javascript
// Assignment of raw strings is blocked, ensuring safety.
el.innerHTML = "some string" // Throws an exception.
const escaped = policy.createHTML("<img src=x onerror=alert(1)>")
el.innerHTML = escaped // Results in safe assignment.
```
### **X-Content-Type-Options**

Αυτή η κεφαλίδα αποτρέπει την ανίχνευση τύπου MIME (MIME type sniffing), μια πρακτική που θα μπορούσε να οδηγήσει σε ευπάθειες XSS. Εξασφαλίζει ότι οι browsers σέβονται τους τύπους MIME που καθορίζονται από τον server.
```
X-Content-Type-Options: nosniff
```
### **X-Frame-Options**

Για την αντιμετώπιση του clickjacking, αυτή η κεφαλίδα περιορίζει τον τρόπο με τον οποίο τα έγγραφα μπορούν να ενσωματωθούν σε `<frame>`, `<iframe>`, `<embed>` ή `<object>` tags, και συνιστά σε όλα τα έγγραφα να καθορίζουν ρητά τα δικαιώματα ενσωμάτωσής τους.
```
X-Frame-Options: DENY
```
### **Cross-Origin Resource Policy (CORP) και Cross-Origin Resource Sharing (CORS)**

Το CORP είναι κρίσιμο για τον καθορισμό ποίων πόρων μπορούν να φορτωθούν από ιστοσελίδες, μειώνοντας τα cross-site leaks. Το CORS, από την άλλη, επιτρέπει έναν πιο ευέλικτο μηχανισμό cross-origin resource sharing, χαλαρώνοντας τη same-origin policy υπό ορισμένες συνθήκες.
```
Cross-Origin-Resource-Policy: same-origin
Access-Control-Allow-Origin: https://example.com
Access-Control-Allow-Credentials: true
```
### **Πολιτική Ενσωμάτωσης Διασταυρούμενης Προέλευσης (COEP) και Πολιτική Άνοιγματος Διασταυρούμενης Προέλευσης (COOP)**

Το COEP και το COOP είναι απαραίτητα για την ενεργοποίηση της απομόνωσης διασταυρούμενης προέλευσης, μειώνοντας σημαντικά τον κίνδυνο επιθέσεων τύπου Spectre. Ελέγχουν, αντίστοιχα, τη φόρτωση πόρων διασταυρούμενης προέλευσης και την αλληλεπίδραση με παράθυρα διασταυρούμενης προέλευσης.
```
Cross-Origin-Embedder-Policy: require-corp
Cross-Origin-Opener-Policy: same-origin-allow-popups
```
### **HTTP Strict Transport Security (HSTS)**

Τέλος, το HSTS είναι μια λειτουργία ασφαλείας που αναγκάζει τα προγράμματα περιήγησης να επικοινωνούν με διακομιστές μόνο μέσω ασφαλών συνδέσεων HTTPS, ενισχύοντας έτσι το απόρρητο και την ασφάλεια.
```
Strict-Transport-Security: max-age=3153600
```
### **Permissions-Policy (formerly Feature-Policy)**

Το Permissions-Policy επιτρέπει στους προγραμματιστές ιστού να ενεργοποιούν, απενεργοποιούν ή να τροποποιούν επιλεκτικά τη συμπεριφορά ορισμένων χαρακτηριστικών του browser και των APIs μέσα σε ένα έγγραφο. Είναι ο διάδοχος της πλέον αποσυρμένης κεφαλίδας `Feature-Policy`. Αυτή η κεφαλίδα βοηθά στη μείωση της επιφάνειας επίθεσης περιορίζοντας την πρόσβαση σε ισχυρά χαρακτηριστικά που θα μπορούσαν να καταχραστούν.
```
Permissions-Policy: geolocation=(), camera=(), microphone=()
```
**Συνήθεις οδηγίες:**

| Directive | Περιγραφή |
| --- | --- |
| `accelerometer` | Ελέγχει την πρόσβαση στον αισθητήρα επιτάχυνσης |
| `camera` | Ελέγχει την πρόσβαση σε συσκευές εισόδου βίντεο (webcam) |
| `geolocation` | Ελέγχει την πρόσβαση στο Geolocation API |
| `gyroscope` | Ελέγχει την πρόσβαση στον αισθητήρα γυροσκοπίου |
| `magnetometer` | Ελέγχει την πρόσβαση στον μαγνητόμετρο |
| `microphone` | Ελέγχει την πρόσβαση σε συσκευές εισόδου ήχου |
| `payment` | Ελέγχει την πρόσβαση στο Payment Request API |
| `usb` | Ελέγχει την πρόσβαση στο WebUSB API |
| `fullscreen` | Ελέγχει την πρόσβαση στο Fullscreen API |
| `autoplay` | Ελέγχει εάν τα μέσα μπορούν να αναπαραχθούν αυτόματα |
| `clipboard-read` | Ελέγχει την πρόσβαση για ανάγνωση του clipboard |
| `clipboard-write` | Ελέγχει την πρόσβαση για εγγραφή στο clipboard |

**Τιμές σύνταξης:**

- `()` - Απενεργοποιεί πλήρως το χαρακτηριστικό
- `(self)` - Επιτρέπει το χαρακτηριστικό μόνο για την ίδια προέλευση
- `*` - Επιτρέπει το χαρακτηριστικό για όλες τις προελεύσεις
- `(self "https://example.com")` - Επιτρέπει για την ίδια προέλευση και για τον συγκεκριμένο domain

**Παραδείγματα ρυθμίσεων:**
```
# Restrictive policy - disable most features
Permissions-Policy: geolocation=(), camera=(), microphone=(), payment=(), usb=()

# Allow camera only from same origin
Permissions-Policy: camera=(self)

# Allow geolocation for same origin and a trusted partner
Permissions-Policy: geolocation=(self "https://maps.example.com")
```
Από πλευράς ασφάλειας, η απουσία ή η υπερβολικά επιτρεπτική χρήση των `Permissions-Policy` headers μπορεί να επιτρέψει σε επιτιθέμενους (π.χ. μέσω XSS ή ενσωματωμένων iframes) να καταχραστούν ισχυρές λειτουργίες του browser. Περιορίστε πάντα τις λειτουργίες στο ελάχιστο απαραίτητο για την εφαρμογή σας.

## Παράκαμψη ευαισθησίας πεζών-κεφαλαίων στα ονόματα κεφαλίδων

HTTP/1.1 ορίζει τα header field‑names ως **case-insensitive** (RFC 9110 §5.1). Παρ’ όλα αυτά είναι πολύ συνηθισμένο να βρίσκονται custom middleware, security filters ή business logic που συγκρίνουν το *κυριολεκτικό* όνομα της κεφαλίδας που λαμβάνεται χωρίς πρώτα να κανονικοποιήσουν την χρήση πεζών/κεφαλαίων (π.χ. `header.equals("CamelExecCommandExecutable")`). Αν αυτοί οι έλεγχοι γίνονται **case-sensitively**, ένας επιτιθέμενος μπορεί να τους παρακάμψει απλά στέλνοντας την ίδια κεφαλίδα με διαφορετική κεφαλαιοποίηση.

Τυπικές περιπτώσεις όπου εμφανίζεται αυτό το λάθος:

* Προσαρμοσμένες λίστες allow/deny που προσπαθούν να μπλοκάρουν «επικίνδυνες» εσωτερικές κεφαλίδες πριν το αίτημα φτάσει σε ευαίσθητο component.
* Εσωτερικές υλοποιήσεις pseudo-headers του reverse-proxy (π.χ. `X-Forwarded-For` sanitisation).
* Frameworks που εκθέτουν management / debug endpoints και βασίζονται στα ονόματα κεφαλίδων για authentication ή επιλογή εντολής.

### Κατάχρηση της παράκαμψης

1. Εντοπίστε μια κεφαλίδα που φιλτράρεται ή επικυρώνεται server-side (π.χ. διαβάζοντας source code, documentation ή error messages).
2. Στείλτε την **ίδια κεφαλίδα με διαφορετική χρήση πεζών/κεφαλαίων** (mixed-case ή upper-case). Επειδή τα HTTP stacks συνήθως κανονικοποιούν τις κεφαλίδες μόνο *μετά* την εκτέλεση του user code, ο ευάλωτος έλεγχος μπορεί να παρακαμφθεί.
3. Αν το downstream component χειρίζεται τις κεφαλίδες χωρίς ευαισθησία στα πεζά/κεφαλαία (οι περισσότερες το κάνουν), θα αποδεχθεί την τιμή που ελέγχεται από τον επιτιθέμενο.

### Παράδειγμα: Apache Camel `exec` RCE (CVE-2025-27636)

Σε ευάλωτες εκδόσεις του Apache Camel, οι διαδρομές του *Command Center* προσπαθούν να μπλοκάρουν μη αξιόπιστα αιτήματα αφαιρώντας τις κεφαλίδες `CamelExecCommandExecutable` και `CamelExecCommandArgs`. Η σύγκριση γινόταν με `equals()` οπότε μόνο τα ακριβή ονόματα με την ίδια χρήση πεζών/κεφαλαίων αφαιρούνταν.
```bash
# Bypass the filter by using mixed-case header names and execute `ls /` on the host
curl "http://<IP>/command-center" \
-H "CAmelExecCommandExecutable: ls" \
-H "CAmelExecCommandArgs: /"
```
Οι headers φτάνουν στο component `exec` χωρίς φιλτράρισμα, με αποτέλεσμα remote command execution με τα προνόμια της διεργασίας Camel.

### Ανίχνευση & Αντιμετώπιση

* Κανονικοποιήστε όλα τα ονόματα header σε ένα ενιαίο case (συνήθως lowercase) **πριν** από τις allow/deny συγκρίσεις.
* Απορρίψτε ύποπτα διπλότυπα: εάν υπάρχουν και τα `Header:` και `HeAdEr:`, αντιμετωπίστε το ως ανωμαλία.
* Χρησιμοποιήστε θετική allow-list που εφαρμόζεται **μετά** την canonicalisation.
* Προστατέψτε τα management endpoints με έλεγχο ταυτότητας και διαχωρισμό δικτύου.


## Αναφορές

- [CVE-2025-27636 – RCE in Apache Camel via header casing bypass (OffSec blog)](https://www.offsec.com/blog/cve-2025-27636/)
- [https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition)
- [https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers)
- [https://web.dev/security-headers/](https://web.dev/security-headers/)
- [https://web.dev/articles/security-headers](https://web.dev/articles/security-headers)

{{#include ../../banners/hacktricks-training.md}}
