# 特殊 HTTP 头

{{#include ../../banners/hacktricks-training.md}}

## 字典和工具

- [https://github.com/danielmiessler/SecLists/tree/master/Miscellaneous/Web/http-request-headers](https://github.com/danielmiessler/SecLists/tree/master/Miscellaneous/Web/http-request-headers)
- [https://github.com/rfc-st/humble](https://github.com/rfc-st/humble)

## 更改位置的头

重写 **IP 源**：

- `X-Originating-IP: 127.0.0.1`
- `X-Forwarded-For: 127.0.0.1`
- `X-Forwarded: 127.0.0.1`
- `Forwarded-For: 127.0.0.1`
- `X-Forwarded-Host: 127.0.0.1`
- `X-Remote-IP: 127.0.0.1`
- `X-Remote-Addr: 127.0.0.1`
- `X-ProxyUser-Ip: 127.0.0.1`
- `X-Original-URL: 127.0.0.1`
- `Client-IP: 127.0.0.1`
- `X-Client-IP: 127.0.0.1`
- `X-Host: 127.0.0.1`
- `True-Client-IP: 127.0.0.1`
- `Cluster-Client-IP: 127.0.0.1`
- `Via: 1.0 fred, 1.1 127.0.0.1`
- `Connection: close, X-Forwarded-For` (检查逐跳头)

重写 **位置**：

- `X-Original-URL: /admin/console`
- `X-Rewrite-URL: /admin/console`

## 逐跳头

逐跳头是设计用于由当前处理请求的代理处理和消费的头，而不是端到端头。

- `Connection: close, X-Forwarded-For`

{{#ref}}
../../pentesting-web/abusing-hop-by-hop-headers.md
{{#endref}}

## HTTP 请求走私

- `Content-Length: 30`
- `Transfer-Encoding: chunked`

{{#ref}}
../../pentesting-web/http-request-smuggling/
{{#endref}}

## 缓存头

**服务器缓存头**：

- **`X-Cache`** 在响应中可能具有值 **`miss`** 当请求未被缓存时，值 **`hit`** 当它被缓存时
- 在头 **`Cf-Cache-Status`** 中有类似的行为
- **`Cache-Control`** 指示资源是否被缓存以及下次资源将何时再次被缓存：`Cache-Control: public, max-age=1800`
- **`Vary`** 通常在响应中使用，以 **指示额外的头**，这些头被视为 **缓存键的一部分**，即使它们通常没有键。
- **`Age`** 定义对象在代理缓存中存在的时间（以秒为单位）。
- **`Server-Timing: cdn-cache; desc=HIT`** 也指示资源已被缓存

{{#ref}}
../../pentesting-web/cache-deception/
{{#endref}}

**本地缓存头**：

- `Clear-Site-Data`: 指示应删除的缓存的头：`Clear-Site-Data: "cache", "cookies"`
- `Expires`: 包含响应应过期的日期/时间：`Expires: Wed, 21 Oct 2015 07:28:00 GMT`
- `Pragma: no-cache` 与 `Cache-Control: no-cache` 相同
- `Warning`: **`Warning`** 一般 HTTP 头包含有关消息状态可能存在问题的信息。响应中可能出现多个 `Warning` 头。`Warning: 110 anderson/1.3.37 "Response is stale"`

## 条件请求

- 使用这些头的请求：**`If-Modified-Since`** 和 **`If-Unmodified-Since`** 仅在响应头 **`Last-Modified`** 包含不同时间时才会返回数据。
- 使用 **`If-Match`** 和 **`If-None-Match`** 的条件请求使用 Etag 值，因此如果数据（Etag）已更改，Web 服务器将发送响应的内容。`Etag` 是从 HTTP 响应中获取的。
- **Etag** 值通常是 **基于** 响应的 **内容** 计算的。例如，`ETag: W/"37-eL2g8DEyqntYlaLp5XLInBWsjWI"` 表示 `Etag` 是 **37 字节** 的 **Sha1**。

## 范围请求

- **`Accept-Ranges`**: 指示服务器是否支持范围请求，如果支持，则以哪种单位表示范围。`Accept-Ranges: <range-unit>`
- **`Range`**: 指示服务器应返回文档的部分。例如，`Range:80-100` 将返回原始响应的字节 80 到 100，状态码为 206 部分内容。还要记得从请求中删除 `Accept-Encoding` 头。
- 这可能有助于获取包含任意反射 JavaScript 代码的响应，否则可能会被转义。但要滥用这一点，您需要在请求中注入这些头。
- **`If-Range`**: 创建一个条件范围请求，仅在给定的 etag 或日期与远程资源匹配时满足。用于防止从不兼容版本的资源下载两个范围。
- **`Content-Range`**: 指示部分消息在完整消息中的位置。

## 消息体信息

- **`Content-Length`:** 资源的大小，以字节的十进制数表示。
- **`Content-Type`**: 指示资源的媒体类型
- **`Content-Encoding`**: 用于指定压缩算法。
- **`Content-Language`**: 描述面向受众的人类语言，以便允许用户根据用户自己的首选语言进行区分。
- **`Content-Location`**: 指示返回数据的替代位置。

从渗透测试的角度来看，这些信息通常是“无用的”，但如果资源受到 **401** 或 **403** 的保护，并且您可以找到某种 **方法** 来 **获取** 这些 **信息**，这可能是 **有趣的**。\
例如，在 HEAD 请求中结合 **`Range`** 和 **`Etag`** 可以通过 HEAD 请求泄露页面的内容：

- 带有头 `Range: bytes=20-20` 的请求和包含 `ETag: W/"1-eoGvPlkaxxP4HqHv6T3PNhV9g3Y"` 的响应泄露了字节 20 的 SHA1 为 `ETag: eoGvPlkaxxP4HqHv6T3PNhV9g3Y`

## 服务器信息

- `Server: Apache/2.4.1 (Unix)`
- `X-Powered-By: PHP/5.3.3`

## 控制

- **`Allow`**: 此头用于传达资源可以处理的 HTTP 方法。例如，它可能被指定为 `Allow: GET, POST, HEAD`，指示资源支持这些方法。
- **`Expect`**: 客户端用于传达服务器需要满足的期望，以便请求能够成功处理。一个常见的用例涉及 `Expect: 100-continue` 头，表示客户端打算发送大量数据负载。客户端在继续传输之前会寻找 `100 (Continue)` 响应。此机制有助于通过等待服务器确认来优化网络使用。

## 下载

- **`Content-Disposition`** 头在 HTTP 响应中指示文件应显示为 **内联**（在网页内）还是作为 **附件**（下载）。例如：
```
Content-Disposition: attachment; filename="filename.jpg"
```
这意味着名为 "filename.jpg" 的文件旨在被下载和保存。

## 安全头部

### 内容安全策略 (CSP) <a href="#csp" id="csp"></a>

{{#ref}}
../../pentesting-web/content-security-policy-csp-bypass/
{{#endref}}

### **受信任的类型**

通过 CSP 强制实施受信任的类型，应用程序可以防止 DOM XSS 攻击。受信任的类型确保只有符合既定安全政策的特定构造对象可以用于危险的 Web API 调用，从而默认保护 JavaScript 代码。
```javascript
// Feature detection
if (window.trustedTypes && trustedTypes.createPolicy) {
// Name and create a policy
const policy = trustedTypes.createPolicy('escapePolicy', {
createHTML: str => str.replace(/\</g, '&lt;').replace(/>/g, '&gt;');
});
}
```

```javascript
// Assignment of raw strings is blocked, ensuring safety.
el.innerHTML = "some string" // Throws an exception.
const escaped = policy.createHTML("<img src=x onerror=alert(1)>")
el.innerHTML = escaped // Results in safe assignment.
```
### **X-Content-Type-Options**

此头部防止 MIME 类型嗅探，这是一种可能导致 XSS 漏洞的做法。它确保浏览器遵循服务器指定的 MIME 类型。
```
X-Content-Type-Options: nosniff
```
### **X-Frame-Options**

为了对抗点击劫持，此头部限制了文档如何嵌入在 `<frame>`、`<iframe>`、`<embed>` 或 `<object>` 标签中，建议所有文档明确指定其嵌入权限。
```
X-Frame-Options: DENY
```
### **跨源资源策略 (CORP) 和跨源资源共享 (CORS)**

CORP 对于指定哪些资源可以被网站加载至关重要，减轻跨站泄漏。另一方面，CORS 允许更灵活的跨源资源共享机制，在某些条件下放宽同源政策。
```
Cross-Origin-Resource-Policy: same-origin
Access-Control-Allow-Origin: https://example.com
Access-Control-Allow-Credentials: true
```
### **Cross-Origin Embedder Policy (COEP) 和 Cross-Origin Opener Policy (COOP)**

COEP 和 COOP 对于启用跨源隔离至关重要，显著降低了类似 Spectre 的攻击风险。它们分别控制跨源资源的加载和与跨源窗口的交互。
```
Cross-Origin-Embedder-Policy: require-corp
Cross-Origin-Opener-Policy: same-origin-allow-popups
```
### **HTTP Strict Transport Security (HSTS)**

最后，HSTS 是一种安全功能，强制浏览器仅通过安全的 HTTPS 连接与服务器通信，从而增强隐私和安全性。
```
Strict-Transport-Security: max-age=3153600
```
## Header Name Casing Bypass

HTTP/1.1 定义头字段名称为 **不区分大小写** (RFC 9110 §5.1)。然而，常常会发现自定义中间件、安全过滤器或业务逻辑在比较接收到的 *字面* 头名称时没有先进行大小写规范化 (例如 `header.equals("CamelExecCommandExecutable")`)。如果这些检查是 **区分大小写** 的，攻击者可以通过发送相同的头但使用不同的大小写来绕过它们。

这种错误出现的典型情况：

* 自定义的允许/拒绝列表，试图在请求到达敏感组件之前阻止“危险”的内部头。
* 内部实现的反向代理伪头 (例如 `X-Forwarded-For` 的清理)。
* 暴露管理/调试端点并依赖头名称进行身份验证或命令选择的框架。

### Abusing the bypass

1. 识别一个在服务器端被过滤或验证的头（例如，通过阅读源代码、文档或错误消息）。
2. 发送 **相同的头但使用不同的大小写**（混合大小写或大写）。因为 HTTP 堆栈通常只在用户代码运行后才规范化头，所以可以跳过脆弱的检查。
3. 如果下游组件以不区分大小写的方式处理头（大多数是），它将接受攻击者控制的值。

### Example: Apache Camel `exec` RCE (CVE-2025-27636)

在易受攻击的 Apache Camel 版本中，*Command Center* 路由试图通过去除头 `CamelExecCommandExecutable` 和 `CamelExecCommandArgs` 来阻止不受信任的请求。比较是通过 `equals()` 完成的，因此只有确切的小写名称被移除。
```bash
# Bypass the filter by using mixed-case header names and execute `ls /` on the host
curl "http://<IP>/command-center" \
-H "CAmelExecCommandExecutable: ls" \
-H "CAmelExecCommandArgs: /"
```
头部未经过滤地到达 `exec` 组件，导致以 Camel 进程的权限执行远程命令。

### 检测与缓解

* 在执行允许/拒绝比较之前，将所有头部名称规范化为单一大小写（通常为小写）。
* 拒绝可疑的重复项：如果同时存在 `Header:` 和 `HeAdEr:`，则将其视为异常。
* 在规范化后使用强制的正面允许列表。
* 通过身份验证和网络分段保护管理端点。


## 参考文献

- [CVE-2025-27636 – RCE in Apache Camel via header casing bypass (OffSec blog)](https://www.offsec.com/blog/cve-2025-27636/)
- [https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition)
- [https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers)
- [https://web.dev/security-headers/](https://web.dev/security-headers/)
- [https://web.dev/articles/security-headers](https://web.dev/articles/security-headers)

{{#include ../../banners/hacktricks-training.md}}
