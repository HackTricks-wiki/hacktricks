# Özel HTTP başlıkları

{{#include ../../banners/hacktricks-training.md}}

## Kelime Listeleri & Araçlar

- [https://github.com/danielmiessler/SecLists/tree/master/Miscellaneous/Web/http-request-headers](https://github.com/danielmiessler/SecLists/tree/master/Miscellaneous/Web/http-request-headers)
- [https://github.com/rfc-st/humble](https://github.com/rfc-st/humble)

## Konum Değiştirmek İçin Başlıklar

IP kaynağını yeniden yaz:

- `X-Originating-IP: 127.0.0.1`
- `X-Forwarded-For: 127.0.0.1`
- `X-Forwarded: 127.0.0.1`
- `Forwarded-For: 127.0.0.1`
- `X-Forwarded-Host: 127.0.0.1`
- `X-Remote-IP: 127.0.0.1`
- `X-Remote-Addr: 127.0.0.1`
- `X-ProxyUser-Ip: 127.0.0.1`
- `X-Original-URL: 127.0.0.1`
- `Client-IP: 127.0.0.1`
- `X-Client-IP: 127.0.0.1`
- `X-Host: 127.0.0.1`
- `True-Client-IP: 127.0.0.1`
- `Cluster-Client-IP: 127.0.0.1`
- `Via: 1.0 fred, 1.1 127.0.0.1`
- `Connection: close, X-Forwarded-For` (hop-by-hop header'ları kontrol edin)

Konumu yeniden yaz:

- `X-Original-URL: /admin/console`
- `X-Rewrite-URL: /admin/console`

## Hop-by-Hop header'ları

Hop-by-hop header, isteği şu anda işleyen proxy tarafından işlenip tüketilmek üzere tasarlanmış bir header'dır; son kullanıcıya kadar gidip gitmeyen end-to-end header'dan farklıdır.

- `Connection: close, X-Forwarded-For`


{{#ref}}
../../pentesting-web/abusing-hop-by-hop-headers.md
{{#endref}}

## HTTP Request Smuggling

- `Content-Length: 30`
- `Transfer-Encoding: chunked`


{{#ref}}
../../pentesting-web/http-request-smuggling/
{{#endref}}

## The Expect header

İstemci `Expect: 100-continue` header'ını gönderebilir ve sunucu buna `HTTP/1.1 100 Continue` ile yanıt vererek istemcinin isteğin gövdesini göndermeye devam etmesine izin verebilir. Ancak bazı proxy'ler bu header'ı pek sevmez.

`Expect: 100-continue` ile ilgili ilginç sonuçlar:
- HEAD isteği gövde ile gönderildiğinde, sunucu HEAD isteklerinin gövdesi olmadığını dikkate almayıp bağlantıyı zaman aşımına kadar açık tutmuştur.
- Bazı sunucular yanıt içinde garip veriler göndermiş: soketten rastgele okunan veriler, gizli anahtarlar veya ön uçun header değerlerini kaldırmasını engelleyen durumlar.
- Ayrıca backend 100 yerine 400 ile yanıtlayınca `0.CL` desync'e neden oldu; çünkü proxy ön uç, orijinal isteğin gövdesini göndermeye hazırlanmıştı, bu yüzden gövdeyi gönderdi ve backend bunu yeni bir istek olarak aldı.
- `Expect: y 100-continue` varyasyonu da `0.CL` desync'e neden oldu.
- Benzer bir hata, backend 404 ile yanıtladığında `CL.0` desync üretti; çünkü kötü amaçlı istek bir `Content-Length` belirtiyordu, bu yüzden backend kötü amaçlı isteği + sonraki isteğin `Content-Length` baytlarını (bir kurbanın isteği) gönderdi. Bu kuyruğu desync etti çünkü backend kötü amaçlı istek için 404 yanıtını + kurban isteğinin yanıtını gönderirken, ön uç yalnızca 1 istek gönderildiğini düşündü; böylece ikinci yanıt başka bir kurbana gönderildi ve sonraki yanıt da bir sonrakine yönlendirildi...

HTTP Request Smuggling hakkında daha fazla bilgi için bakınız:

{{#ref}}
../../pentesting-web/http-request-smuggling/
{{#endref}}


## Cache Header'ları

Sunucu Cache Header'ları:

- **`X-Cache`** cevapta `miss` değeri isteğin cache'te olmadığını, `hit` ise cache'te olduğunu gösterebilir
- Benzer davranış **`Cf-Cache-Status`** header'ında görülebilir
- **`Cache-Control`** bir kaynağın cache'lenip cache'lenmediğini ve bir sonraki cache zamanını belirtir: `Cache-Control: public, max-age=1800`
- **`Vary`** genellikle cevapta, normalde cache anahtarının parçası olmayan ek header'ların da cache anahtarının parçası olarak değerlendirildiğini belirtmek için kullanılır.
- **`Age`** nesnenin proxy cache'te bulunduğu süreyi saniye olarak tanımlar.
- **`Server-Timing: cdn-cache; desc=HIT`** ayrıca bir kaynağın cache'lendiğini gösterir


{{#ref}}
../../pentesting-web/cache-deception/
{{#endref}}

Yerel Cache header'ları:

- `Clear-Site-Data`: Kaldırılması gereken cache türünü belirtir: `Clear-Site-Data: "cache", "cookies"`
- `Expires`: Cevabın ne zaman süresinin dolacağını içerir: `Expires: Wed, 21 Oct 2015 07:28:00 GMT`
- `Pragma: no-cache` `Cache-Control: no-cache` ile aynı
- `Warning`: Genel HTTP header'ı olan **`Warning`**, mesajın durumu ile ilgili olası problemlere dair bilgi içerir. Bir cevapta birden fazla `Warning` header'ı bulunabilir. `Warning: 110 anderson/1.3.37 "Response is stale"`

## Koşullular (Conditionals)

- Bu header'ları kullanan istekler: **`If-Modified-Since`** ve **`If-Unmodified-Since`** yalnızca cevap header'ı **`Last-Modified`** farklı bir zaman içeriyorsa veri ile yanıtlanır.
- **`If-Match`** ve **`If-None-Match`** kullanan koşullu istekler Etag değerini kullanır; web sunucusu, veri (Etag) değiştiyse cevabı gönderir. `Etag` HTTP cevabından alınır.
- **Etag** değeri genellikle cevabın **içeriğine** göre hesaplanır. Örneğin, `ETag: W/"37-eL2g8DEyqntYlaLp5XLInBWsjWI"` ifadesi `Etag`'in **37 byte** için **Sha1** olduğunu gösterir.

## Range istekleri

- **`Accept-Ranges`**: Sunucunun range isteklerini destekleyip desteklemediğini ve destekliyorsa hangi birimde range belirtilebileceğini gösterir. `Accept-Ranges: <range-unit>`
- **`Range`**: Sunucunun döndürmesi gereken belgenin parçasını belirtir. Örneğin, `Range:80-100` orijinal cevabın 80 ile 100 arasındaki byte'larını döndürür ve durum kodu 206 Partial Content olur. Ayrıca `Accept-Encoding` header'ını istekten kaldırmayı unutmayın.
- Bu, aksi halde kaçışlanan reflected javascript kodunu arbitrary olarak almak için yararlı olabilir. Ancak bunu kötüye kullanmak için bu header'ları isteğe enjekte etmeniz gerekir.
- **`If-Range`**: Verilen etag veya tarih uzak kaynağa uyuyorsa yerine getirilecek koşullu bir range isteği oluşturur. Kaynağın uyumsuz versiyonlarından iki range indirilmeyi önlemek için kullanılır.
- **`Content-Range`**: Kısmi bir mesajın tam bir gövde mesajının neresine ait olduğunu belirtir.

## Mesaj gövdesi bilgisi

- **`Content-Length`:** Kaynağın boyutu, bayt cinsinden ondalık sayı.
- **`Content-Type`**: Kaynağın medya tipini belirtir
- **`Content-Encoding`**: Sıkıştırma algoritmasını belirtmek için kullanılır.
- **`Content-Language`**: Hedef kitle için amaçlanan insan dili(leri)ni tanımlar; böylece kullanıcı kendi tercih ettiği dile göre ayırt edebilir.
- **`Content-Location`**: Döndürülen veriler için alternatif bir konumu gösterir.

Bir pentest bakış açısından bu bilgiler genellikle "kullanışsız"dır, ancak kaynak bir 401 veya 403 ile korunuyorsa ve bu bilgiyi elde etmenin bir yolunu bulabiliyorsanız bu ilginç olabilir.\
Örneğin, HEAD isteğinde **`Range`** ve **`Etag`** kombinasyonu sayfanın içeriğini HEAD istekleri aracılığıyla leak edebilir:

- `Range: bytes=20-20` header'lı bir istek ve `ETag: W/"1-eoGvPlkaxxP4HqHv6T3PNhV9g3Y"` cevabı, byte 20'nin SHA1'inin `ETag: eoGvPlkaxxP4HqHv6T3PNhV9g3Y` olduğunu leak ediyor

## Sunucu Bilgisi

- `Server: Apache/2.4.1 (Unix)`
- `X-Powered-By: PHP/5.3.3`

## Kontroller

- **`Allow`**: Bu header bir kaynağın hangi HTTP yöntemlerini işleyebildiğini bildirir. Örneğin, `Allow: GET, POST, HEAD` gibi belirtilerek kaynağın bu yöntemleri desteklediği gösterilir.
- **`Expect`**: İstemcinin, isteğin başarılı şekilde işlenebilmesi için sunucunun karşılaması gereken beklentileri iletmek için kullandığı header'dır. Yaygın bir kullanım `Expect: 100-continue` header'ıdır; bu, istemcinin büyük bir veri yükü göndermeyi düşündüğünü işaret eder. İstemci, gönderime devam etmeden önce `100 (Continue)` yanıtını bekler. Bu mekanizma, sunucudan onay bekleyerek ağ kullanımını optimize etmeye yardımcı olur.

## İndirilmeler

- HTTP cevaplarındaki **`Content-Disposition`** header'ı bir dosyanın sayfa içinde (inline) gösterilip gösterilmeyeceğini veya bir **attachment** (indirilecek) olarak muamele edilip edilmeyeceğini belirtir. Örneğin:
```
Content-Disposition: attachment; filename="filename.jpg"
```
Bu, "filename.jpg" adlı dosyanın indirilip kaydedilmesi amaçlandığı anlamına gelir.

## Güvenlik Başlıkları

### İçerik Güvenlik Politikası (CSP) <a href="#csp" id="csp"></a>


{{#ref}}
../../pentesting-web/content-security-policy-csp-bypass/
{{#endref}}

### **Trusted Types**

Trusted Types'ı CSP aracılığıyla zorunlu kılarak, uygulamalar DOM XSS saldırılarına karşı korunabilir. Trusted Types, yalnızca belirli güvenlik politikalarına uygun şekilde özel olarak oluşturulmuş nesnelerin tehlikeli web API çağrılarında kullanılmasına izin vererek JavaScript kodunu varsayılan olarak korur.
```javascript
// Feature detection
if (window.trustedTypes && trustedTypes.createPolicy) {
// Name and create a policy
const policy = trustedTypes.createPolicy('escapePolicy', {
createHTML: str => str.replace(/\</g, '&lt;').replace(/>/g, '&gt;');
});
}
```

```javascript
// Assignment of raw strings is blocked, ensuring safety.
el.innerHTML = "some string" // Throws an exception.
const escaped = policy.createHTML("<img src=x onerror=alert(1)>")
el.innerHTML = escaped // Results in safe assignment.
```
### **X-Content-Type-Options**

Bu header MIME türü tespitini engeller; bu uygulama XSS zafiyetlerine yol açabilir. Sunucu tarafından belirtilen MIME türlerine tarayıcıların uymasını sağlar.
```
X-Content-Type-Options: nosniff
```
### **X-Frame-Options**

Clickjacking ile mücadele etmek için, bu header `<frame>`, `<iframe>`, `<embed>` veya `<object>` etiketlerine belgelerin nasıl gömülebileceğini kısıtlar ve tüm belgelerin gömme izinlerini açıkça belirtmesini önerir.
```
X-Frame-Options: DENY
```
### **Cross-Origin Resource Policy (CORP) and Cross-Origin Resource Sharing (CORS)**

CORP, web sitelerinin hangi kaynakları yükleyebileceğini belirtmek için kritik öneme sahiptir; cross-site leaks'i azaltır. Öte yandan CORS, belirli koşullar altında same-origin policy'yi gevşeterek daha esnek bir cross-origin resource sharing mekanizması sağlar.
```
Cross-Origin-Resource-Policy: same-origin
Access-Control-Allow-Origin: https://example.com
Access-Control-Allow-Credentials: true
```
### **Cross-Origin Embedder Policy (COEP) ve Cross-Origin Opener Policy (COOP)**

COEP ve COOP, kökenler arası izolasyonu etkinleştirmek için gereklidir ve Spectre benzeri saldırı riskini önemli ölçüde azaltır. Bunlar sırasıyla kökenler arası kaynakların yüklenmesini ve kökenler arası pencerelerle etkileşimi kontrol eder.
```
Cross-Origin-Embedder-Policy: require-corp
Cross-Origin-Opener-Policy: same-origin-allow-popups
```
### **HTTP Strict Transport Security (HSTS)**

Son olarak, HSTS tarayıcıların sunucularla yalnızca güvenli HTTPS bağlantıları üzerinden iletişim kurmasını zorunlu kılan bir güvenlik özelliğidir; böylece gizliliği ve güvenliği artırır.
```
Strict-Transport-Security: max-age=3153600
```
### **Permissions-Policy (formerly Feature-Policy)**

Permissions-Policy, web geliştiricilerinin bir belge içinde belirli tarayıcı özelliklerini ve API'leri seçici olarak etkinleştirmesine, devre dışı bırakmasına veya davranışlarını değiştirmesine olanak tanır. Bu, artık kullanımdan kaldırılmış olan `Feature-Policy` başlığının ardılıdır. Bu başlık, kötüye kullanılabilecek güçlü özelliklere erişimi kısıtlayarak saldırı yüzeyini azaltmaya yardımcı olur.
```
Permissions-Policy: geolocation=(), camera=(), microphone=()
```
**Yaygın direktifler:**

| Directive | Açıklama |
| --- | --- |
| `accelerometer` | Accelerometer sensörüne erişimi kontrol eder |
| `camera` | Video giriş aygıtlarına (webcam) erişimi kontrol eder |
| `geolocation` | Geolocation API'sine erişimi kontrol eder |
| `gyroscope` | Gyroscope sensörüne erişimi kontrol eder |
| `magnetometer` | Magnetometer sensörüne erişimi kontrol eder |
| `microphone` | Ses giriş aygıtlarına erişimi kontrol eder |
| `payment` | Payment Request API'sine erişimi kontrol eder |
| `usb` | WebUSB API'sine erişimi kontrol eder |
| `fullscreen` | Fullscreen API'sine erişimi kontrol eder |
| `autoplay` | Medyanın otomatik oynatılmasına izin verilip verilmeyeceğini kontrol eder |
| `clipboard-read` | Panodan içerik okumaya erişimi kontrol eder |
| `clipboard-write` | Panoya yazma erişimini kontrol eder |

**Sözdizimi değerleri:**

- `()` - Özelliği tamamen devre dışı bırakır
- `(self)` - Özelliğe yalnızca aynı origin için izin verir
- `*` - Özelliğe tüm originler için izin verir
- `(self "https://example.com")` - Aynı origin ve belirtilen domaine izin verir

**Örnek yapılandırmalar:**
```
# Restrictive policy - disable most features
Permissions-Policy: geolocation=(), camera=(), microphone=(), payment=(), usb=()

# Allow camera only from same origin
Permissions-Policy: camera=(self)

# Allow geolocation for same origin and a trusted partner
Permissions-Policy: geolocation=(self "https://maps.example.com")
```
Güvenlik açısından, eksik veya aşırı izin veren `Permissions-Policy` başlıkları, saldırganların (ör. XSS veya gömülü iframes aracılığıyla) güçlü tarayıcı özelliklerini suistimal etmesine izin verebilir. Özellikleri uygulamanız için gereken asgari düzeyle sınırlandırın.

## Başlık Adı Büyük/Küçük Harf Bypass'ı

HTTP/1.1, başlık alan adlarını **büyük/küçük harf duyarsız** olarak tanımlar (RFC 9110 §5.1). Buna rağmen, alınan *literal* başlık adını önce harf biçimini normalleştirmeden karşılaştıran özel middleware, güvenlik filtreleri veya iş mantığına sıkça rastlanır (ör. `header.equals("CamelExecCommandExecutable")`). Eğer bu kontroller **büyük/küçük harf duyarlı** şekilde yapılıyorsa, bir saldırgan aynı başlığı farklı bir kapitalizasyonla göndererek bu kontrolleri atlayabilir.

Bu hatanın sık görüldüğü durumlar:

* İsteğin hassas bir bileşene ulaşmadan önce “tehlikeli” iç başlıkları engellemeye çalışan özel izin/engelleme listeleri.
* Reverse-proxy pseudo-headers'ın dahili uygulamaları (ör. `X-Forwarded-For` sanitisation).
* Yönetim / debug uç noktalarını açığa çıkaran ve kimlik doğrulama veya komut seçimi için başlık isimlerine dayanan framework'ler.

### Bypass'ın kötüye kullanımı

1. Sunucu tarafında filtrelenen veya doğrulanan bir başlığı tespit edin (ör. kaynak kodu, dökümantasyon veya hata mesajları okuyarak).
2. Aynı başlığı **farklı bir harf biçimiyle** gönderin (karışık harfli veya tamamen büyük harf). Çünkü HTTP yığınları genellikle başlıkları kullanıcı kodu çalıştıktan *sonra* normalleştirir; bu nedenle savunmasız kontrol atlanabilir.
3. Eğer sonraki bileşen başlıkları büyük/küçük harf duyarsız şekilde ele alıyorsa (çoğu öyledir), saldırgan kontrollü değeri kabul edecektir.

### Örnek: Apache Camel `exec` RCE (CVE-2025-27636)

Zafiyetli Apache Camel sürümlerinde *Command Center* rotaları, güvensiz istekleri `CamelExecCommandExecutable` ve `CamelExecCommandArgs` başlıklarını temizleyerek engellemeye çalışıyordu. Karşılaştırma `equals()` ile yapıldığından yalnızca tam olarak eşleşen (küçük harfli) isimler kaldırılıyordu.
```bash
# Bypass the filter by using mixed-case header names and execute `ls /` on the host
curl "http://<IP>/command-center" \
-H "CAmelExecCommandExecutable: ls" \
-H "CAmelExecCommandArgs: /"
```
Başlıklar `exec` bileşenine filtrelenmeden ulaşır; bu da Camel işleminin ayrıcalıklarıyla uzaktan komut çalıştırılmasına yol açar.

### Tespit ve Hafifletme

* Tüm başlık adlarını tek bir duruma (çoğunlukla küçük harf) **izin/verme karşılaştırmalarını yapmadan önce** normalleştirin.
* Şüpheli çoğaltmaları reddedin: hem `Header:` hem de `HeAdEr:` varsa, bunu bir anomali olarak değerlendirin.
* Kanonikleştirmeden **sonra** uygulanacak pozitif bir izin listesi (allow-list) kullanın.
* Yönetim endpoint'lerini kimlik doğrulama ve ağ segmentasyonu ile koruyun.


## Kaynaklar

- [CVE-2025-27636 – RCE in Apache Camel via header casing bypass (OffSec blog)](https://www.offsec.com/blog/cve-2025-27636/)
- [https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition)
- [https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers)
- [https://web.dev/security-headers/](https://web.dev/security-headers/)
- [https://web.dev/articles/security-headers](https://web.dev/articles/security-headers)

{{#include ../../banners/hacktricks-training.md}}
