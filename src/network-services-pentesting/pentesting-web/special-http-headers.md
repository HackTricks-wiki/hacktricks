# Спеціальні HTTP заголовки

{{#include ../../banners/hacktricks-training.md}}

## Словники та інструменти

- [https://github.com/danielmiessler/SecLists/tree/master/Miscellaneous/Web/http-request-headers](https://github.com/danielmiessler/SecLists/tree/master/Miscellaneous/Web/http-request-headers)
- [https://github.com/rfc-st/humble](https://github.com/rfc-st/humble)

## Заголовки для зміни розташування

Перезаписати **джерело IP**:

- `X-Originating-IP: 127.0.0.1`
- `X-Forwarded-For: 127.0.0.1`
- `X-Forwarded: 127.0.0.1`
- `Forwarded-For: 127.0.0.1`
- `X-Forwarded-Host: 127.0.0.1`
- `X-Remote-IP: 127.0.0.1`
- `X-Remote-Addr: 127.0.0.1`
- `X-ProxyUser-Ip: 127.0.0.1`
- `X-Original-URL: 127.0.0.1`
- `Client-IP: 127.0.0.1`
- `X-Client-IP: 127.0.0.1`
- `X-Host: 127.0.0.1`
- `True-Client-IP: 127.0.0.1`
- `Cluster-Client-IP: 127.0.0.1`
- `Via: 1.0 fred, 1.1 127.0.0.1`
- `Connection: close, X-Forwarded-For` (Перевіряйте hop-by-hop заголовки)

Перезаписати **location**:

- `X-Original-URL: /admin/console`
- `X-Rewrite-URL: /admin/console`

## Hop-by-Hop заголовки

Hop-by-hop заголовок — це заголовок, який призначений для обробки і використання проксі, що наразі обробляє запит, на відміну від end-to-end заголовка.

- `Connection: close, X-Forwarded-For`


{{#ref}}
../../pentesting-web/abusing-hop-by-hop-headers.md
{{#endref}}

## HTTP Request Smuggling

- `Content-Length: 30`
- `Transfer-Encoding: chunked`


{{#ref}}
../../pentesting-web/http-request-smuggling/
{{#endref}}

## Заголовок Expect

Клієнт може надіслати заголовок `Expect: 100-continue`, і тоді сервер може відповісти `HTTP/1.1 100 Continue`, щоб дозволити клієнту продовжити відправку тіла запиту. Однак деяким проксі цей заголовок не дуже подобається.

Цікаві наслідки `Expect: 100-continue`:
- Надсилання HEAD-запиту з тілом — сервер не врахував, що у HEAD немає тіла, і тримає з'єднання відкритим до тайм-ауту.
- Деякі сервери надсилали дивні дані: випадкові дані, прочитані з сокета у відповіді, секретні ключі або навіть це дозволяло завадити фронт-енду видаляти значення заголовків.
- Це також спричиняло `0.CL` desync, коли бекенд відповів 400 замість 100, але фронт-проксі вже був готовий відправити тіло початкового запиту, тому відправляє його, а бекенд сприймає його як новий запит.
- Надсилання варіації `Expect: y 100-continue` також викликало `0.CL` desync.
- Схожа помилка, коли бекенд відповів 404, породила `CL.0` desync, бо шкідливий запит вказував `Content-Length`, тож бекенд відправляє шкідливий запит + `Content-Length` байт наступного запиту (жертви); це розсинхронізує чергу, бо бекенд відправляє 404 відповідь для шкідливого запиту + відповідь жертви, але фронт думав, що було відправлено лише 1 запит, тож друга відповідь йде другому клієнту, а відповідь того — наступному...

Для детальнішої інформації про HTTP Request Smuggling див.:


{{#ref}}
../../pentesting-web/http-request-smuggling/
{{#endref}}


## Cache заголовки

**Server Cache Headers**:

- **`X-Cache`** в відповіді може мати значення **`miss`**, коли запит не був закешований, і значення **`hit`**, коли він був закешований
- Подібна поведінка в заголовку **`Cf-Cache-Status`**
- **`Cache-Control`** вказує, чи ресурс кешується і коли наступного разу ресурс буде вважатися свіжим: `Cache-Control: public, max-age=1800`
- **`Vary`** часто використовується у відповіді, щоб **вказати додаткові заголовки**, які вважаються **частиною ключа кешу**, навіть якщо за замовчуванням вони не використовуються як ключ
- **`Age`** визначає час в секундах, протягом якого об'єкт знаходиться в проксі-кеші
- **`Server-Timing: cdn-cache; desc=HIT`** також вказує, що ресурс був закешований


{{#ref}}
../../pentesting-web/cache-deception/
{{#endref}}

**Local Cache headers**:

- `Clear-Site-Data`: Заголовок для вказівки кешу, які дані слід видалити: `Clear-Site-Data: "cache", "cookies"`
- `Expires`: Містить дату/час, коли відповідь має стати протермінованою: `Expires: Wed, 21 Oct 2015 07:28:00 GMT`
- `Pragma: no-cache` те саме, що `Cache-Control: no-cache`
- `Warning`: Загальний HTTP-заголовок **`Warning`** містить інформацію про можливі проблеми зі статусом повідомлення. У відповіді може бути більше ніж один `Warning` заголовок. `Warning: 110 anderson/1.3.37 "Response is stale"`

## Умовні запити

- Запити, що використовують заголовки **`If-Modified-Since`** та **`If-Unmodified-Since`**, будуть відповідати даними лише якщо заголовок відповіді **`Last-Modified`** містить інший час.
- Умовні запити з використанням **`If-Match`** та **`If-None-Match`** використовують значення Etag, тому вебсервер надішле вміст відповіді, якщо дані (Etag) змінилися. `Etag` береться з HTTP-відповіді.
- Значення **Etag** зазвичай **обчислюється на основі** **вмісту** відповіді. Наприклад, `ETag: W/"37-eL2g8DEyqntYlaLp5XLInBWsjWI"` вказує, що `Etag` — це **Sha1** **37 байт**.

## Range-запити

- **`Accept-Ranges`**: Вказує, чи сервер підтримує range-запити, і в якій одиниці може вказуватися діапазон. `Accept-Ranges: <range-unit>`
- **`Range`**: Вказує частину документа, яку сервер повинен повернути. Наприклад, `Range:80-100` поверне байти з 80 по 100 оригінальної відповіді зі статусом 206 Partial Content. Також не забудьте видалити заголовок `Accept-Encoding` із запиту.
- Це може бути корисно, щоб отримати response з довільним відображеним javascript-кодом, який інакше міг би бути escaped. Але для зловживання цим потрібно інжектити ці заголовки в запит.
- **`If-Range`**: Створює умовний range-запит, який виконується лише якщо заданий etag або дата відповідає віддаленому ресурсу. Використовується, щоб уникнути завантаження двох діапазонів з несумісних версій ресурсу.
- **`Content-Range`**: Вказує, куди в повному тілі повідомлення належить часткове повідомлення.

## Інформація про тіло повідомлення

- **`Content-Length`:** Розмір ресурсу в десятковому числі байтів.
- **`Content-Type`**: Вказує медіа-тип ресурсу.
- **`Content-Encoding`**: Використовується для вказівки алгоритму стиснення.
- **`Content-Language`**: Описує людські мови(и), для яких призначено вміст, щоб дозволити користувачу відфільтрувати відповідно до його мовних уподобань.
- **`Content-Location`**: Вказує альтернативне місце для повернутих даних.

З точки зору pentest ця інформація зазвичай "марна", але якщо ресурс **захищений** через 401 або 403 і ви можете знайти якийсь **спосіб** отримати цю **інформацію**, це може бути **цікавим**.\
Наприклад, комбінація **`Range`** та **`Etag`** в HEAD-запиті може leak вміст сторінки через HEAD-запити:

- A request with the header `Range: bytes=20-20` and with a response containing `ETag: W/"1-eoGvPlkaxxP4HqHv6T3PNhV9g3Y"` is leaking that the SHA1 of the byte 20 is `ETag: eoGvPlkaxxP4HqHv6T3PNhV9g3Y`

## Інформація про сервер

- `Server: Apache/2.4.1 (Unix)`
- `X-Powered-By: PHP/5.3.3`

## Контролі

- **`Allow`**: Цей заголовок використовується для повідомлення HTTP-методів, які ресурс може обробляти. Наприклад: `Allow: GET, POST, HEAD`, що вказує, що ресурс підтримує ці методи.
- **`Expect`**: Використовується клієнтом для повідомлення очікувань, які сервер має виконати, щоб запит був успішно оброблений. Звичний випадок — `Expect: 100-continue`, який повідомляє, що клієнт має намір надіслати великий обсяг даних і чекає відповіді `100 (Continue)` перед тим як продовжити передачу. Цей механізм допомагає оптимізувати використання мережі, чекаючи підтвердження від сервера.

## Завантаження

- Заголовок **`Content-Disposition`** у HTTP-відповідях вказує, чи файл повинен відображатися **inline** (в межах сторінки) або оброблятися як **attachment** (завантажуватися). Наприклад:
```
Content-Disposition: attachment; filename="filename.jpg"
```
Це означає, що файл із назвою "filename.jpg" призначено для завантаження та збереження.

## Заголовки безпеки

### Content Security Policy (CSP) <a href="#csp" id="csp"></a>


{{#ref}}
../../pentesting-web/content-security-policy-csp-bypass/
{{#endref}}

### **Trusted Types**

Впровадження Trusted Types через CSP дозволяє захистити додатки від DOM XSS attacks. Trusted Types гарантують, що лише спеціально створені об'єкти, які відповідають встановленим політикам безпеки, можуть використовуватися в небезпечних викликах web API, тим самим за замовчуванням захищаючи JavaScript-код.
```javascript
// Feature detection
if (window.trustedTypes && trustedTypes.createPolicy) {
// Name and create a policy
const policy = trustedTypes.createPolicy('escapePolicy', {
createHTML: str => str.replace(/\</g, '&lt;').replace(/>/g, '&gt;');
});
}
```

```javascript
// Assignment of raw strings is blocked, ensuring safety.
el.innerHTML = "some string" // Throws an exception.
const escaped = policy.createHTML("<img src=x onerror=alert(1)>")
el.innerHTML = escaped // Results in safe assignment.
```
### **X-Content-Type-Options**

Цей заголовок запобігає MIME type sniffing — практиці, яка може призвести до XSS-вразливостей. Він забезпечує, що браузери дотримуються MIME-типів, зазначених сервером.
```
X-Content-Type-Options: nosniff
```
### **X-Frame-Options**

Щоб протидіяти clickjacking, цей заголовок обмежує спосіб, у який документи можуть вбудовуватися в `<frame>`, `<iframe>`, `<embed>` або `<object>` теги, і рекомендує всім документам явно вказувати свої дозволи на вбудовування.
```
X-Frame-Options: DENY
```
### **Політика ресурсів між походженнями (Cross-Origin Resource Policy, CORP) та Cross-Origin Resource Sharing (CORS)**

CORP має ключове значення для вказання того, які ресурси можуть завантажуватися вебсайтами, зменшуючи cross-site leaks. CORS, натомість, дозволяє більш гнучкий механізм cross-origin resource sharing, послаблюючи same-origin policy за певних умов.
```
Cross-Origin-Resource-Policy: same-origin
Access-Control-Allow-Origin: https://example.com
Access-Control-Allow-Credentials: true
```
### **Політика Cross-Origin Embedder (COEP) та Політика Cross-Origin Opener (COOP)**

COEP та COOP є необхідними для увімкнення ізоляції між походженнями (cross-origin isolation), що значно знижує ризик атак, подібних до Spectre. Вони відповідно контролюють завантаження ресурсів з інших походжень та взаємодію з вікнами з інших походжень.
```
Cross-Origin-Embedder-Policy: require-corp
Cross-Origin-Opener-Policy: same-origin-allow-popups
```
### **HTTP Strict Transport Security (HSTS)**

Нарешті, HSTS — це функція безпеки, яка змушує браузери спілкуватися з серверами лише через захищені HTTPS-з'єднання, тим самим підвищуючи конфіденційність та безпеку.
```
Strict-Transport-Security: max-age=3153600
```
### **Permissions-Policy (formerly Feature-Policy)**

Permissions-Policy дозволяє веб-розробникам вибірково вмикати, вимикати або змінювати поведінку певних функцій браузера та API в межах документа. Це наступник тепер застарілого заголовка `Feature-Policy`. Цей заголовок допомагає зменшити поверхню атаки, обмежуючи доступ до потужних функцій, які можуть бути зловживані.
```
Permissions-Policy: geolocation=(), camera=(), microphone=()
```
**Поширені директиви:**

| Директива | Опис |
| --- | --- |
| `accelerometer` | Керує доступом до акселерометра |
| `camera` | Керує доступом до пристроїв відеовведення (веб-камера) |
| `geolocation` | Керує доступом до Geolocation API |
| `gyroscope` | Керує доступом до гіроскопа |
| `magnetometer` | Керує доступом до магнітометра |
| `microphone` | Керує доступом до аудіопристроїв введення |
| `payment` | Керує доступом до Payment Request API |
| `usb` | Керує доступом до WebUSB API |
| `fullscreen` | Керує доступом до Fullscreen API |
| `autoplay` | Керує тим, чи може медіа відтворюватися автоматично |
| `clipboard-read` | Керує доступом для читання вмісту буфера обміну |
| `clipboard-write` | Керує доступом для запису в буфер обміну |

**Значення синтаксису:**

- `()` - Повністю відключає функцію
- `(self)` - Дозволяє функцію лише для того самого origin
- `*` - Дозволяє функцію для всіх origin
- `(self "https://example.com")` - Дозволяє для того самого origin та зазначеного домену

**Приклади конфігурацій:**
```
# Restrictive policy - disable most features
Permissions-Policy: geolocation=(), camera=(), microphone=(), payment=(), usb=()

# Allow camera only from same origin
Permissions-Policy: camera=(self)

# Allow geolocation for same origin and a trusted partner
Permissions-Policy: geolocation=(self "https://maps.example.com")
```
З позиції безпеки, відсутні або надмірно ліберальні заголовки `Permissions-Policy` можуть дозволити атакам (наприклад, через XSS або вбудовані iframes) зловживати потужними можливостями браузера. Завжди обмежуйте функції до мінімально необхідних для вашого застосунку.

## Обхід через регістр імен заголовків

HTTP/1.1 визначає імена полів заголовків як **нечутливі до регістру** (RFC 9110 §5.1). Проте дуже часто зустрічаються custom middleware, security filters або бізнес-логіка, які порівнюють *буквальне* ім'я заголовка, отриманого без попередньої нормалізації регістру (наприклад, `header.equals("CamelExecCommandExecutable")`). Якщо такі перевірки виконуються **чутливо до регістру**, атакуючий може обійти їх просто відправивши той самий заголовок з іншою капіталізацією.

Типові ситуації, де ця помилка з'являється:

* Власні списки дозволених/заборонених, які намагаються блокувати «небезпечні» внутрішні заголовки до того, як запит досягне чутливого компонента.
* Внутрішні реалізації псевдо-заголовків reverse-proxy (наприклад, санітизація `X-Forwarded-For`).
* Фреймворки, що відкривають management / debug endpoints і покладаються на імена заголовків для аутентифікації або вибору команд.

### Зловживання обходом

1. Визначте заголовок, який фільтрується або перевіряється на сервері (наприклад, читаючи вихідний код, документацію або повідомлення про помилки).
2. Надішліть **той самий заголовок з іншою капіталізацією** (змішаний регістр або верхній регістр). Оскільки HTTP-стек зазвичай канонізує заголовки лише *після* виконання користувацького коду, вразлива перевірка може бути пропущена.
3. Якщо нижчестоящий компонент обробляє заголовки нечутливо до регістру (більшість так робить), він прийме значення, контрольоване атакуючим.

### Example: Apache Camel `exec` RCE (CVE-2025-27636)

У вразливих версіях Apache Camel маршрути *Command Center* намагалися блокувати недовірені запити, видаляючи заголовки `CamelExecCommandExecutable` та `CamelExecCommandArgs`. Порівняння виконувалося за допомогою `equals()`, тож були видалені тільки імена, що точно відповідали нижньому регістру.
```bash
# Bypass the filter by using mixed-case header names and execute `ls /` on the host
curl "http://<IP>/command-center" \
-H "CAmelExecCommandExecutable: ls" \
-H "CAmelExecCommandArgs: /"
```
Заголовки потрапляють до компонента `exec` без фільтрації, що призводить до remote command execution з привілеями процесу Camel.

### Виявлення та пом'якшення

* Нормалізуйте всі імена заголовків до одного регістру (зазвичай lowercase) **перед** виконанням allow/deny-порівнянь.
* Відкидайте підозрілі дублі: якщо присутні одночасно `Header:` і `HeAdEr:`, вважайте це аномалією.
* Використовуйте позитивний allow-list, що застосовується **після** canonicalisation.
* Захищайте management endpoints за допомогою автентифікації та мережевої сегментації.


## Посилання

- [CVE-2025-27636 – RCE in Apache Camel via header casing bypass (OffSec blog)](https://www.offsec.com/blog/cve-2025-27636/)
- [https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition)
- [https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers)
- [https://web.dev/security-headers/](https://web.dev/security-headers/)
- [https://web.dev/articles/security-headers](https://web.dev/articles/security-headers)

{{#include ../../banners/hacktricks-training.md}}
