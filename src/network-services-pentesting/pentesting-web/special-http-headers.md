# Encabezados HTTP especiales

{{#include ../../banners/hacktricks-training.md}}

## Listas de palabras y herramientas

- [https://github.com/danielmiessler/SecLists/tree/master/Miscellaneous/Web/http-request-headers](https://github.com/danielmiessler/SecLists/tree/master/Miscellaneous/Web/http-request-headers)
- [https://github.com/rfc-st/humble](https://github.com/rfc-st/humble)

## Encabezados para cambiar la ubicación

Reescribir **IP de origen**:

- `X-Originating-IP: 127.0.0.1`
- `X-Forwarded-For: 127.0.0.1`
- `X-Forwarded: 127.0.0.1`
- `Forwarded-For: 127.0.0.1`
- `X-Forwarded-Host: 127.0.0.1`
- `X-Remote-IP: 127.0.0.1`
- `X-Remote-Addr: 127.0.0.1`
- `X-ProxyUser-Ip: 127.0.0.1`
- `X-Original-URL: 127.0.0.1`
- `Client-IP: 127.0.0.1`
- `X-Client-IP: 127.0.0.1`
- `X-Host: 127.0.0.1`
- `True-Client-IP: 127.0.0.1`
- `Cluster-Client-IP: 127.0.0.1`
- `Via: 1.0 fred, 1.1 127.0.0.1`
- `Connection: close, X-Forwarded-For` (Ver encabezados hop-by-hop)

Reescribir **ubicación**:

- `X-Original-URL: /admin/console`
- `X-Rewrite-URL: /admin/console`

## Encabezados hop-by-hop

Un encabezado hop-by-hop es un encabezado diseñado para ser procesado y consumido por el proxy que maneja actualmente la solicitud, a diferencia de un encabezado de extremo a extremo.

- `Connection: close, X-Forwarded-For`

{{#ref}}
../../pentesting-web/abusing-hop-by-hop-headers.md
{{#endref}}

## HTTP Request Smuggling

- `Content-Length: 30`
- `Transfer-Encoding: chunked`

{{#ref}}
../../pentesting-web/http-request-smuggling/
{{#endref}}

## Encabezados de caché

**Encabezados de caché del servidor**:

- **`X-Cache`** en la respuesta puede tener el valor **`miss`** cuando la solicitud no fue almacenada en caché y el valor **`hit`** cuando está almacenada en caché
- Comportamiento similar en el encabezado **`Cf-Cache-Status`**
- **`Cache-Control`** indica si un recurso está siendo almacenado en caché y cuándo será la próxima vez que el recurso será almacenado en caché nuevamente: `Cache-Control: public, max-age=1800`
- **`Vary`** se usa a menudo en la respuesta para **indicar encabezados adicionales** que se tratan como **parte de la clave de caché** incluso si normalmente no tienen clave.
- **`Age`** define el tiempo en segundos que el objeto ha estado en la caché del proxy.
- **`Server-Timing: cdn-cache; desc=HIT`** también indica que un recurso fue almacenado en caché

{{#ref}}
../../pentesting-web/cache-deception/
{{#endref}}

**Encabezados de caché local**:

- `Clear-Site-Data`: Encabezado para indicar la caché que debe ser eliminada: `Clear-Site-Data: "cache", "cookies"`
- `Expires`: Contiene la fecha/hora cuando la respuesta debe expirar: `Expires: Wed, 21 Oct 2015 07:28:00 GMT`
- `Pragma: no-cache` igual que `Cache-Control: no-cache`
- `Warning`: El encabezado HTTP general **`Warning`** contiene información sobre posibles problemas con el estado del mensaje. Puede aparecer más de un encabezado `Warning` en una respuesta. `Warning: 110 anderson/1.3.37 "Response is stale"`

## Condicionales

- Las solicitudes que utilizan estos encabezados: **`If-Modified-Since`** y **`If-Unmodified-Since`** recibirán respuesta con datos solo si el encabezado de respuesta **`Last-Modified`** contiene un tiempo diferente.
- Las solicitudes condicionales que utilizan **`If-Match`** y **`If-None-Match`** utilizan un valor Etag para que el servidor web envíe el contenido de la respuesta si los datos (Etag) han cambiado. El `Etag` se toma de la respuesta HTTP.
- El valor **Etag** generalmente se **calcula** en función del **contenido** de la respuesta. Por ejemplo, `ETag: W/"37-eL2g8DEyqntYlaLp5XLInBWsjWI"` indica que el `Etag` es el **Sha1** de **37 bytes**.

## Solicitudes de rango

- **`Accept-Ranges`**: Indica si el servidor admite solicitudes de rango, y si es así, en qué unidad se puede expresar el rango. `Accept-Ranges: <range-unit>`
- **`Range`**: Indica la parte de un documento que el servidor debe devolver. Por ejemplo, `Range:80-100` devolverá los bytes 80 a 100 de la respuesta original con un código de estado 206 Partial Content. También recuerda eliminar el encabezado `Accept-Encoding` de la solicitud.
- Esto podría ser útil para obtener una respuesta con código javascript reflejado arbitrario que de otro modo podría ser escapado. Pero para abusar de esto necesitarías inyectar estos encabezados en la solicitud.
- **`If-Range`**: Crea una solicitud de rango condicional que solo se cumple si el etag o la fecha dados coinciden con el recurso remoto. Se utiliza para evitar descargar dos rangos de versiones incompatibles del recurso.
- **`Content-Range`**: Indica dónde en un mensaje de cuerpo completo pertenece un mensaje parcial.

## Información del cuerpo del mensaje

- **`Content-Length`:** El tamaño del recurso, en número decimal de bytes.
- **`Content-Type`**: Indica el tipo de medio del recurso
- **`Content-Encoding`**: Se utiliza para especificar el algoritmo de compresión.
- **`Content-Language`**: Describe el/los idioma(s) humano(s) destinados a la audiencia, de modo que permite a un usuario diferenciar según el idioma preferido del usuario.
- **`Content-Location`**: Indica una ubicación alternativa para los datos devueltos.

Desde el punto de vista de un pentest, esta información suele ser "inútil", pero si el recurso está **protegido** por un 401 o 403 y puedes encontrar alguna **manera** de **obtener** esta **info**, esto podría ser **interesante.**\
Por ejemplo, una combinación de **`Range`** y **`Etag`** en una solicitud HEAD puede filtrar el contenido de la página a través de solicitudes HEAD:

- Una solicitud con el encabezado `Range: bytes=20-20` y con una respuesta que contiene `ETag: W/"1-eoGvPlkaxxP4HqHv6T3PNhV9g3Y"` está filtrando que el SHA1 del byte 20 es `ETag: eoGvPlkaxxP4HqHv6T3PNhV9g3Y`

## Información del servidor

- `Server: Apache/2.4.1 (Unix)`
- `X-Powered-By: PHP/5.3.3`

## Controles

- **`Allow`**: Este encabezado se utiliza para comunicar los métodos HTTP que un recurso puede manejar. Por ejemplo, podría especificarse como `Allow: GET, POST, HEAD`, indicando que el recurso admite estos métodos.
- **`Expect`**: Utilizado por el cliente para transmitir expectativas que el servidor necesita cumplir para que la solicitud se procese con éxito. Un caso de uso común implica el encabezado `Expect: 100-continue`, que señala que el cliente tiene la intención de enviar una carga de datos grande. El cliente busca una respuesta `100 (Continue)` antes de proceder con la transmisión. Este mecanismo ayuda a optimizar el uso de la red al esperar la confirmación del servidor.

## Descargas

- El encabezado **`Content-Disposition`** en las respuestas HTTP indica si un archivo debe ser mostrado **inline** (dentro de la página web) o tratado como un **adjunto** (descargado). Por ejemplo:
```
Content-Disposition: attachment; filename="filename.jpg"
```
Esto significa que el archivo llamado "filename.jpg" está destinado a ser descargado y guardado.

## Encabezados de Seguridad

### Política de Seguridad de Contenido (CSP) <a href="#csp" id="csp"></a>

{{#ref}}
../../pentesting-web/content-security-policy-csp-bypass/
{{#endref}}

### **Tipos de Confianza**

Al hacer cumplir los Tipos de Confianza a través de CSP, las aplicaciones pueden protegerse contra ataques XSS en el DOM. Los Tipos de Confianza aseguran que solo se puedan utilizar objetos específicamente diseñados, que cumplan con las políticas de seguridad establecidas, en llamadas a API web peligrosas, asegurando así el código JavaScript por defecto.
```javascript
// Feature detection
if (window.trustedTypes && trustedTypes.createPolicy) {
// Name and create a policy
const policy = trustedTypes.createPolicy('escapePolicy', {
createHTML: str => str.replace(/\</g, '&lt;').replace(/>/g, '&gt;');
});
}
```

```javascript
// Assignment of raw strings is blocked, ensuring safety.
el.innerHTML = "some string" // Throws an exception.
const escaped = policy.createHTML("<img src=x onerror=alert(1)>")
el.innerHTML = escaped // Results in safe assignment.
```
### **X-Content-Type-Options**

Este encabezado previene la detección de tipos MIME, una práctica que podría llevar a vulnerabilidades XSS. Asegura que los navegadores respeten los tipos MIME especificados por el servidor.
```
X-Content-Type-Options: nosniff
```
### **X-Frame-Options**

Para combatir el clickjacking, este encabezado restringe cómo se pueden incrustar documentos en las etiquetas `<frame>`, `<iframe>`, `<embed>` u `<object>`, recomendando que todos los documentos especifiquen explícitamente sus permisos de incrustación.
```
X-Frame-Options: DENY
```
### **Política de Recursos de Origen Cruzado (CORP) y Compartición de Recursos de Origen Cruzado (CORS)**

CORP es crucial para especificar qué recursos pueden ser cargados por sitios web, mitigando filtraciones entre sitios. CORS, por otro lado, permite un mecanismo de compartición de recursos de origen cruzado más flexible, relajando la política de mismo origen bajo ciertas condiciones.
```
Cross-Origin-Resource-Policy: same-origin
Access-Control-Allow-Origin: https://example.com
Access-Control-Allow-Credentials: true
```
### **Política de Incrustación de Origen Cruzado (COEP) y Política de Apertura de Origen Cruzado (COOP)**

COEP y COOP son esenciales para habilitar el aislamiento de origen cruzado, reduciendo significativamente el riesgo de ataques similares a Spectre. Controlan la carga de recursos de origen cruzado y la interacción con ventanas de origen cruzado, respectivamente.
```
Cross-Origin-Embedder-Policy: require-corp
Cross-Origin-Opener-Policy: same-origin-allow-popups
```
### **HTTP Strict Transport Security (HSTS)**

Por último, HSTS es una característica de seguridad que obliga a los navegadores a comunicarse con los servidores solo a través de conexiones HTTPS seguras, mejorando así la privacidad y la seguridad.
```
Strict-Transport-Security: max-age=3153600
```
## Header Name Casing Bypass

HTTP/1.1 define los nombres de los campos de encabezado como **insensibles a mayúsculas y minúsculas** (RFC 9110 §5.1). Sin embargo, es muy común encontrar middleware personalizado, filtros de seguridad o lógica de negocio que comparan el nombre de encabezado *literal* recibido sin normalizar primero la capitalización (por ejemplo, `header.equals("CamelExecCommandExecutable")`). Si esas verificaciones se realizan **sensible a mayúsculas y minúsculas**, un atacante puede eludirlas simplemente enviando el mismo encabezado con una capitalización diferente.

Situaciones típicas donde aparece este error:

* Listas personalizadas de permitir/denegar que intentan bloquear encabezados internos "peligrosos" antes de que la solicitud llegue a un componente sensible.
* Implementaciones internas de pseudo-encabezados de proxy inverso (por ejemplo, sanitización de `X-Forwarded-For`).
* Frameworks que exponen puntos finales de gestión / depuración y dependen de los nombres de encabezados para la autenticación o selección de comandos.

### Abusing the bypass

1. Identificar un encabezado que sea filtrado o validado del lado del servidor (por ejemplo, leyendo el código fuente, la documentación o los mensajes de error).
2. Enviar el **mismo encabezado con una capitalización diferente** (mixta o en mayúsculas). Debido a que las pilas HTTP generalmente canonizan los encabezados solo *después* de que se ha ejecutado el código del usuario, se puede omitir la verificación vulnerable.
3. Si el componente de downstream trata los encabezados de manera insensible a mayúsculas y minúsculas (la mayoría lo hace), aceptará el valor controlado por el atacante.

### Example: Apache Camel `exec` RCE (CVE-2025-27636)

En versiones vulnerables de Apache Camel, las rutas del *Command Center* intentan bloquear solicitudes no confiables eliminando los encabezados `CamelExecCommandExecutable` y `CamelExecCommandArgs`. La comparación se realizó con `equals()`, por lo que solo se eliminaron los nombres exactos en minúsculas.
```bash
# Bypass the filter by using mixed-case header names and execute `ls /` on the host
curl "http://<IP>/command-center" \
-H "CAmelExecCommandExecutable: ls" \
-H "CAmelExecCommandArgs: /"
```
Los encabezados llegan al componente `exec` sin filtrar, lo que resulta en la ejecución remota de comandos con los privilegios del proceso Camel.

### Detección y Mitigación

* Normaliza todos los nombres de encabezados a un solo caso (generalmente en minúsculas) **antes** de realizar comparaciones de permitir/negar.
* Rechaza duplicados sospechosos: si están presentes tanto `Header:` como `HeAdEr:`, trátalo como una anomalía.
* Utiliza una lista de permitidos positiva aplicada **después** de la canonicalización.
* Protege los puntos finales de gestión con autenticación y segmentación de red.

## Referencias

- [CVE-2025-27636 – RCE en Apache Camel a través de eludir el caso de encabezado (blog de OffSec)](https://www.offsec.com/blog/cve-2025-27636/)
- [https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition)
- [https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers)
- [https://web.dev/security-headers/](https://web.dev/security-headers/)
- [https://web.dev/articles/security-headers](https://web.dev/articles/security-headers)

{{#include ../../banners/hacktricks-training.md}}
